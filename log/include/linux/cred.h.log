commit 5825a95fe92566ada2292a65de030850b5cff1da
Merge: 3c6a6910a81e 15322a0d90b6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Sep 23 11:21:04 2019 -0700

    Merge tag 'selinux-pr-20190917' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux
    
    Pull selinux updates from Paul Moore:
    
     - Add LSM hooks, and SELinux access control hooks, for dnotify,
       fanotify, and inotify watches. This has been discussed with both the
       LSM and fs/notify folks and everybody is good with these new hooks.
    
     - The LSM stacking changes missed a few calls to current_security() in
       the SELinux code; we fix those and remove current_security() for
       good.
    
     - Improve our network object labeling cache so that we always return
       the object's label, even when under memory pressure. Previously we
       would return an error if we couldn't allocate a new cache entry, now
       we always return the label even if we can't create a new cache entry
       for it.
    
     - Convert the sidtab atomic_t counter to a normal u32 with
       READ/WRITE_ONCE() and memory barrier protection.
    
     - A few patches to policydb.c to clean things up (remove forward
       declarations, long lines, bad variable names, etc)
    
    * tag 'selinux-pr-20190917' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux:
      lsm: remove current_security()
      selinux: fix residual uses of current_security() for the SELinux blob
      selinux: avoid atomic_t usage in sidtab
      fanotify, inotify, dnotify, security: add security hook for fs notifications
      selinux: always return a secid from the network caches if we find one
      selinux: policydb - rename type_val_to_struct_array
      selinux: policydb - fix some checkpatch.pl warnings
      selinux: shuffle around policydb.c to get rid of forward declarations

commit 15322a0d90b6fd62ae8f22e5b87f735c3fdfeff7
Author: Paul Moore <paul@paul-moore.com>
Date:   Wed Sep 4 18:53:39 2019 -0400

    lsm: remove current_security()
    
    There are no remaining callers and it really is unsafe in the brave
    new world of LSM stacking.
    
    Acked-by: James Morris <jamorris@linux.microsoft.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index efb6edf32de7..98b0a23ddd23 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -384,7 +384,6 @@ static inline void put_cred(const struct cred *_cred)
 #define current_fsgid() 	(current_cred_xxx(fsgid))
 #define current_cap()		(current_cred_xxx(cap_effective))
 #define current_user()		(current_cred_xxx(user))
-#define current_security()	(current_cred_xxx(security))
 
 extern struct user_namespace init_user_ns;
 #ifdef CONFIG_USER_NS

commit d7852fbd0f0423937fa287a598bfde188bb68c22
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 11 09:54:40 2019 -0700

    access: avoid the RCU grace period for the temporary subjective credentials
    
    It turns out that 'access()' (and 'faccessat()') can cause a lot of RCU
    work because it installs a temporary credential that gets allocated and
    freed for each system call.
    
    The allocation and freeing overhead is mostly benign, but because
    credentials can be accessed under the RCU read lock, the freeing
    involves a RCU grace period.
    
    Which is not a huge deal normally, but if you have a lot of access()
    calls, this causes a fair amount of seconday damage: instead of having a
    nice alloc/free patterns that hits in hot per-CPU slab caches, you have
    all those delayed free's, and on big machines with hundreds of cores,
    the RCU overhead can end up being enormous.
    
    But it turns out that all of this is entirely unnecessary.  Exactly
    because access() only installs the credential as the thread-local
    subjective credential, the temporary cred pointer doesn't actually need
    to be RCU free'd at all.  Once we're done using it, we can just free it
    synchronously and avoid all the RCU overhead.
    
    So add a 'non_rcu' flag to 'struct cred', which can be set by users that
    know they only use it in non-RCU context (there are other potential
    users for this).  We can make it a union with the rcu freeing list head
    that we need for the RCU case, so this doesn't need any extra storage.
    
    Note that this also makes 'get_current_cred()' clear the new non_rcu
    flag, in case we have filesystems that take a long-term reference to the
    cred and then expect the RCU delayed freeing afterwards.  It's not
    entirely clear that this is required, but it makes for clear semantics:
    the subjective cred remains non-RCU as long as you only access it
    synchronously using the thread-local accessors, but you _can_ use it as
    a generic cred if you want to.
    
    It is possible that we should just remove the whole RCU markings for
    ->cred entirely.  Only ->real_cred is really supposed to be accessed
    through RCU, and the long-term cred copies that nfs uses might want to
    explicitly re-enable RCU freeing if required, rather than have
    get_current_cred() do it implicitly.
    
    But this is a "minimal semantic changes" change for the immediate
    problem.
    
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Acked-by: Paul E. McKenney <paulmck@linux.ibm.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Jan Glauber <jglauber@marvell.com>
    Cc: Jiri Kosina <jikos@kernel.org>
    Cc: Jayachandran Chandrasekharan Nair <jnair@marvell.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Miklos Szeredi <miklos@szeredi.hu>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 7eb43a038330..f7a30e0099be 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -145,7 +145,11 @@ struct cred {
 	struct user_struct *user;	/* real user ID subscription */
 	struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
 	struct group_info *group_info;	/* supplementary groups for euid/fsgid */
-	struct rcu_head	rcu;		/* RCU deletion hook */
+	/* RCU deletion */
+	union {
+		int non_rcu;			/* Can we skip RCU deletion? */
+		struct rcu_head	rcu;		/* RCU deletion hook */
+	};
 } __randomize_layout;
 
 extern void __put_cred(struct cred *);
@@ -246,6 +250,7 @@ static inline const struct cred *get_cred(const struct cred *cred)
 	if (!cred)
 		return cred;
 	validate_creds(cred);
+	nonconst_cred->non_rcu = 0;
 	return get_new_cred(nonconst_cred);
 }
 
@@ -257,6 +262,7 @@ static inline const struct cred *get_cred_rcu(const struct cred *cred)
 	if (!atomic_inc_not_zero(&nonconst_cred->usage))
 		return NULL;
 	validate_creds(cred);
+	nonconst_cred->non_rcu = 0;
 	return cred;
 }
 

commit b4d0d230ccfb5d1a9ea85da64aa584df7c148ee9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 19:08:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 36
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public licence as published by
      the free software foundation either version 2 of the licence or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 114 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520170857.552531963@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index efb6edf32de7..7eb43a038330 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -1,12 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /* Credentials management - see Documentation/security/credentials.rst
  *
  * Copyright (C) 2008 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public Licence
- * as published by the Free Software Foundation; either version
- * 2 of the Licence, or (at your option) any later version.
  */
 
 #ifndef _LINUX_CRED_H

commit 5c7e372caa35d303e414caeb64ee2243fd3cac3d
Author: Jann Horn <jannh@google.com>
Date:   Wed Mar 27 16:39:38 2019 +0100

    security: don't use RCU accessors for cred->session_keyring
    
    sparse complains that a bunch of places in kernel/cred.c access
    cred->session_keyring without the RCU helpers required by the __rcu
    annotation.
    
    cred->session_keyring is written in the following places:
    
     - prepare_kernel_cred() [in a new cred struct]
     - keyctl_session_to_parent() [in a new cred struct]
     - prepare_creds [in a new cred struct, via memcpy]
     - install_session_keyring_to_cred()
      - from install_session_keyring() on new creds
      - from join_session_keyring() on new creds [twice]
      - from umh_keys_init()
       - from call_usermodehelper_exec_async() on new creds
    
    All of these writes are before the creds are committed; therefore,
    cred->session_keyring doesn't need RCU protection.
    
    Remove the __rcu annotation and fix up all existing users that use __rcu.
    
    Signed-off-by: Jann Horn <jannh@google.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index ddd45bb74887..efb6edf32de7 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -138,7 +138,7 @@ struct cred {
 #ifdef CONFIG_KEYS
 	unsigned char	jit_keyring;	/* default keyring to attach requested
 					 * keys to */
-	struct key __rcu *session_keyring; /* keyring inherited over fork */
+	struct key	*session_keyring; /* keyring inherited over fork */
 	struct key	*process_keyring; /* keyring private to this process */
 	struct key	*thread_keyring; /* keyring private to this thread */
 	struct key	*request_key_auth; /* assumed request_key authority */

commit 3d252529480c68bfd6a6774652df7c8968b28e41
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Fri Sep 21 17:17:34 2018 -0700

    SELinux: Remove unused selinux_is_enabled
    
    There are no longer users of selinux_is_enabled().
    Remove it. As selinux_is_enabled() is the only reason
    for include/linux/selinux.h remove that as well.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 4907c9df86b3..ddd45bb74887 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -15,7 +15,6 @@
 #include <linux/capability.h>
 #include <linux/init.h>
 #include <linux/key.h>
-#include <linux/selinux.h>
 #include <linux/atomic.h>
 #include <linux/uidgid.h>
 #include <linux/sched.h>

commit f06bc03339ad4c1baa964a5f0606247ac1c3c50b
Author: NeilBrown <neilb@suse.com>
Date:   Mon Dec 3 11:30:30 2018 +1100

    cred: allow get_cred() and put_cred() to be given NULL.
    
    It is common practice for helpers like this to silently,
    accept a NULL pointer.
    get_rpccred() and put_rpccred() used by NFS act this way
    and using the same interface will ease the conversion
    for NFS, and simplify the resulting code.
    
    Signed-off-by: NeilBrown <neilb@suse.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 48979fcb95cf..4907c9df86b3 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -237,7 +237,7 @@ static inline struct cred *get_new_cred(struct cred *cred)
  * @cred: The credentials to reference
  *
  * Get a reference on the specified set of credentials.  The caller must
- * release the reference.
+ * release the reference.  If %NULL is passed, it is returned with no action.
  *
  * This is used to deal with a committed set of credentials.  Although the
  * pointer is const, this will temporarily discard the const and increment the
@@ -248,6 +248,8 @@ static inline struct cred *get_new_cred(struct cred *cred)
 static inline const struct cred *get_cred(const struct cred *cred)
 {
 	struct cred *nonconst_cred = (struct cred *) cred;
+	if (!cred)
+		return cred;
 	validate_creds(cred);
 	return get_new_cred(nonconst_cred);
 }
@@ -268,7 +270,7 @@ static inline const struct cred *get_cred_rcu(const struct cred *cred)
  * @cred: The credentials to release
  *
  * Release a reference to a set of credentials, deleting them when the last ref
- * is released.
+ * is released.  If %NULL is passed, nothing is done.
  *
  * This takes a const pointer to a set of credentials because the credentials
  * on task_struct are attached by const pointers to prevent accidental
@@ -278,9 +280,11 @@ static inline void put_cred(const struct cred *_cred)
 {
 	struct cred *cred = (struct cred *) _cred;
 
-	validate_creds(cred);
-	if (atomic_dec_and_test(&(cred)->usage))
-		__put_cred(cred);
+	if (cred) {
+		validate_creds(cred);
+		if (atomic_dec_and_test(&(cred)->usage))
+			__put_cred(cred);
+	}
 }
 
 /**

commit 97d0fb239c041f5f99655af74812c3ab75cc4346
Author: NeilBrown <neilb@suse.com>
Date:   Mon Dec 3 11:30:30 2018 +1100

    cred: add get_cred_rcu()
    
    Sometimes we want to opportunistically get a
    ref to a cred in an rcu_read_lock protected section.
    get_task_cred() does this, and NFS does as similar thing
    with its own credential structures.
    To prepare for NFS converting to use 'struct cred' more
    uniformly, define get_cred_rcu(), and use it in
    get_task_cred().
    
    Signed-off-by: NeilBrown <neilb@suse.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index f1085767e1b3..48979fcb95cf 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -252,6 +252,17 @@ static inline const struct cred *get_cred(const struct cred *cred)
 	return get_new_cred(nonconst_cred);
 }
 
+static inline const struct cred *get_cred_rcu(const struct cred *cred)
+{
+	struct cred *nonconst_cred = (struct cred *) cred;
+	if (!cred)
+		return NULL;
+	if (!atomic_inc_not_zero(&nonconst_cred->usage))
+		return NULL;
+	validate_creds(cred);
+	return cred;
+}
+
 /**
  * put_cred - Release a reference to a set of credentials
  * @cred: The credentials to release

commit d89b22d46a40da3a1630ecea111beaf3ef10bc21
Author: NeilBrown <neilb@suse.com>
Date:   Mon Dec 3 11:30:30 2018 +1100

    cred: add cred_fscmp() for comparing creds.
    
    NFS needs to compare to credentials, to see if they can
    be treated the same w.r.t. filesystem access.  Sometimes
    an ordering is needed when credentials are used as a key
    to an rbtree.
    NFS currently has its own private credential management from
    before 'struct cred' existed.  To move it over to more consistent
    use of 'struct cred' we need a comparison function.
    This patch adds that function.
    
    Signed-off-by: NeilBrown <neilb@suse.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 7eed6101c791..f1085767e1b3 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -169,6 +169,7 @@ extern int change_create_files_as(struct cred *, struct inode *);
 extern int set_security_override(struct cred *, u32);
 extern int set_security_override_from_ctx(struct cred *, const char *);
 extern int set_create_files_as(struct cred *, struct inode *);
+extern int cred_fscmp(const struct cred *, const struct cred *);
 extern void __init cred_init(void);
 
 /*

commit 4b09791ba059cc5a5ec7d69049f5d05da65b6418
Author: Ondrej Mosnáček <omosnace@redhat.com>
Date:   Tue Jun 26 13:04:42 2018 +0200

    cred: conditionally declare groups-related functions
    
    The groups-related functions declared in include/linux/cred.h are
    defined in kernel/groups.c, which is compiled only when
    CONFIG_MULTIUSER=y. Move all these function declarations under #ifdef
    CONFIG_MULTIUSER to help avoid accidental usage in contexts where
    CONFIG_MULTIUSER might be disabled.
    
    This patch also adds a fallback for groups_search(). Currently this
    function is only called from kernel/groups.c itself and
    security/keys/permissions.c, where the call is (by coincidence)
    optimized away in case CONFIG_MULTIUSER=n. However, the audit subsystem
    (which does not depend on CONFIG_MULTIUSER) calls this function in
    -next, so the fallback will be needed to avoid compilation errors or
    ugly workarounds.
    
    See also:
    https://lkml.org/lkml/2018/6/20/670
    https://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/audit.git/commit/?h=next&id=af85d1772e31fed34165a1b3decef340cf4080c0
    
    Reported-by: Randy Dunlap <rdunlap@infradead.org>
    Tested-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 631286535d0f..7eed6101c791 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -65,6 +65,12 @@ extern void groups_free(struct group_info *);
 
 extern int in_group_p(kgid_t);
 extern int in_egroup_p(kgid_t);
+extern int groups_search(const struct group_info *, kgid_t);
+
+extern int set_current_groups(struct group_info *);
+extern void set_groups(struct cred *, struct group_info *);
+extern bool may_setgroups(void);
+extern void groups_sort(struct group_info *);
 #else
 static inline void groups_free(struct group_info *group_info)
 {
@@ -78,12 +84,11 @@ static inline int in_egroup_p(kgid_t grp)
 {
         return 1;
 }
+static inline int groups_search(const struct group_info *group_info, kgid_t grp)
+{
+	return 1;
+}
 #endif
-extern int set_current_groups(struct group_info *);
-extern void set_groups(struct cred *, struct group_info *);
-extern int groups_search(const struct group_info *, kgid_t);
-extern bool may_setgroups(void);
-extern void groups_sort(struct group_info *);
 
 /*
  * The security context of a task

commit bdcf0a423ea1c40bbb40e7ee483b50fc8aa3d758
Author: Thiago Rafael Becker <thiago.becker@gmail.com>
Date:   Thu Dec 14 15:33:12 2017 -0800

    kernel: make groups_sort calling a responsibility group_info allocators
    
    In testing, we found that nfsd threads may call set_groups in parallel
    for the same entry cached in auth.unix.gid, racing in the call of
    groups_sort, corrupting the groups for that entry and leading to
    permission denials for the client.
    
    This patch:
     - Make groups_sort globally visible.
     - Move the call to groups_sort to the modifiers of group_info
     - Remove the call to groups_sort from set_groups
    
    Link: http://lkml.kernel.org/r/20171211151420.18655-1-thiago.becker@gmail.com
    Signed-off-by: Thiago Rafael Becker <thiago.becker@gmail.com>
    Reviewed-by: Matthew Wilcox <mawilcox@microsoft.com>
    Reviewed-by: NeilBrown <neilb@suse.com>
    Acked-by: "J. Bruce Fields" <bfields@fieldses.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 099058e1178b..631286535d0f 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -83,6 +83,7 @@ extern int set_current_groups(struct group_info *);
 extern void set_groups(struct cred *, struct group_info *);
 extern int groups_search(const struct group_info *, kgid_t);
 extern bool may_setgroups(void);
+extern void groups_sort(struct group_info *);
 
 /*
  * The security context of a task

commit e06fdaf40a5c021dd4a2ec797e8b724f07360070
Merge: a90c6ac2b565 8acdf5055974
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 19 08:55:18 2017 -0700

    Merge tag 'gcc-plugins-v4.13-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/kees/linux
    
    Pull structure randomization updates from Kees Cook:
     "Now that IPC and other changes have landed, enable manual markings for
      randstruct plugin, including the task_struct.
    
      This is the rest of what was staged in -next for the gcc-plugins, and
      comes in three patches, largest first:
    
       - mark "easy" structs with __randomize_layout
    
       - mark task_struct with an optional anonymous struct to isolate the
         __randomize_layout section
    
       - mark structs to opt _out_ of automated marking (which will come
         later)
    
      And, FWIW, this continues to pass allmodconfig (normal and patched to
      enable gcc-plugins) builds of x86_64, i386, arm64, arm, powerpc, and
      s390 for me"
    
    * tag 'gcc-plugins-v4.13-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/kees/linux:
      randstruct: opt-out externally exposed function pointer structs
      task_struct: Allow randomized layout
      randstruct: Mark various structs for randomization

commit 3859a271a003aba01e45b85c9d8b355eb7bf25f9
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Oct 28 01:22:25 2016 -0700

    randstruct: Mark various structs for randomization
    
    This marks many critical kernel structures for randomization. These are
    structures that have been targeted in the past in security exploits, or
    contain functions pointers, pointers to function pointer tables, lists,
    workqueues, ref-counters, credentials, permissions, or are otherwise
    sensitive. This initial list was extracted from Brad Spengler/PaX Team's
    code in the last public patch of grsecurity/PaX based on my understanding
    of the code. Changes or omissions from the original code are mine and
    don't reflect the original grsecurity/PaX code.
    
    Left out of this list is task_struct, which requires special handling
    and will be covered in a subsequent patch.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index b03e7d049a64..82c8a9e1aabb 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -31,7 +31,7 @@ struct group_info {
 	atomic_t	usage;
 	int		ngroups;
 	kgid_t		gid[0];
-};
+} __randomize_layout;
 
 /**
  * get_group_info - Get a reference to a group info structure
@@ -145,7 +145,7 @@ struct cred {
 	struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
 	struct group_info *group_info;	/* supplementary groups for euid/fsgid */
 	struct rcu_head	rcu;		/* RCU deletion hook */
-};
+} __randomize_layout;
 
 extern void __put_cred(struct cred *);
 extern void exit_creds(struct task_struct *);

commit af777cd1b83e95138e7285fde87c795ef0ae7c4d
Author: Kees Cook <keescook@chromium.org>
Date:   Sat May 13 04:51:40 2017 -0700

    doc: ReSTify credentials.txt
    
    This updates the credentials API documentation to ReST markup and moves
    it under the security subsection of kernel API documentation.
    
    Cc: David Howells <dhowells@redhat.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index b03e7d049a64..c728d515e5e2 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -1,4 +1,4 @@
-/* Credentials management - see Documentation/security/credentials.txt
+/* Credentials management - see Documentation/security/credentials.rst
  *
  * Copyright (C) 2008 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)

commit 5b825c3af1d8a0af4deb4a5eb349d0d0050c62e5
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Feb 2 17:54:15 2017 +0100

    sched/headers: Prepare to remove <linux/cred.h> inclusion from <linux/sched.h>
    
    Add #include <linux/cred.h> dependencies to all .c files rely on sched.h
    doing that for them.
    
    Note that even if the count where we need to add extra headers seems high,
    it's still a net win, because <linux/sched.h> is included in over
    2,200 files ...
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 045d33e48069..b03e7d049a64 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -18,6 +18,7 @@
 #include <linux/selinux.h>
 #include <linux/atomic.h>
 #include <linux/uidgid.h>
+#include <linux/sched.h>
 #include <linux/sched/user.h>
 
 struct cred;

commit 8703e8a465b1e9cadc3680b4b1248f5987e54518
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 8 18:51:30 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <linux/sched/user.h>
    
    We are going to split <linux/sched/user.h> out of <linux/sched.h>, which
    will have to be picked up from other headers and a couple of .c files.
    
    Create a trivial placeholder <linux/sched/user.h> file that just
    maps to <linux/sched.h> to make this patch obviously correct and
    bisectable.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index f0e70a1bb3ac..045d33e48069 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -18,8 +18,8 @@
 #include <linux/selinux.h>
 #include <linux/atomic.h>
 #include <linux/uidgid.h>
+#include <linux/sched/user.h>
 
-struct user_struct;
 struct cred;
 struct inode;
 

commit 81243eacfa400f5f7b89f4c2323d0de9982bb0fb
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Fri Oct 7 17:03:12 2016 -0700

    cred: simpler, 1D supplementary groups
    
    Current supplementary groups code can massively overallocate memory and
    is implemented in a way so that access to individual gid is done via 2D
    array.
    
    If number of gids is <= 32, memory allocation is more or less tolerable
    (140/148 bytes).  But if it is not, code allocates full page (!)
    regardless and, what's even more fun, doesn't reuse small 32-entry
    array.
    
    2D array means dependent shifts, loads and LEAs without possibility to
    optimize them (gid is never known at compile time).
    
    All of the above is unnecessary.  Switch to the usual
    trailing-zero-len-array scheme.  Memory is allocated with
    kmalloc/vmalloc() and only as much as needed.  Accesses become simpler
    (LEA 8(gi,idx,4) or even without displacement).
    
    Maximum number of gids is 65536 which translates to 256KB+8 bytes.  I
    think kernel can handle such allocation.
    
    On my usual desktop system with whole 9 (nine) aux groups, struct
    group_info shrinks from 148 bytes to 44 bytes, yay!
    
    Nice side effects:
    
     - "gi->gid[i]" is shorter than "GROUP_AT(gi, i)", less typing,
    
     - fix little mess in net/ipv4/ping.c
       should have been using GROUP_AT macro but this point becomes moot,
    
     - aux group allocation is persistent and should be accounted as such.
    
    Link: http://lkml.kernel.org/r/20160817201927.GA2096@p183.telecom.by
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Vasily Kulikov <segoon@openwall.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 257db64562e5..f0e70a1bb3ac 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -26,15 +26,10 @@ struct inode;
 /*
  * COW Supplementary groups list
  */
-#define NGROUPS_SMALL		32
-#define NGROUPS_PER_BLOCK	((unsigned int)(PAGE_SIZE / sizeof(kgid_t)))
-
 struct group_info {
 	atomic_t	usage;
 	int		ngroups;
-	int		nblocks;
-	kgid_t		small_block[NGROUPS_SMALL];
-	kgid_t		*blocks[0];
+	kgid_t		gid[0];
 };
 
 /**
@@ -88,10 +83,6 @@ extern void set_groups(struct cred *, struct group_info *);
 extern int groups_search(const struct group_info *, kgid_t);
 extern bool may_setgroups(void);
 
-/* access the groups "array" with this macro */
-#define GROUP_AT(gi, i) \
-	((gi)->blocks[(i) / NGROUPS_PER_BLOCK][(i) % NGROUPS_PER_BLOCK])
-
 /*
  * The security context of a task
  *

commit 0335695dfa4df01edff5bb102b9a82a0668ee51e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Mar 22 14:27:11 2016 -0700

    cred/userns: define current_user_ns() as a function
    
    The current_user_ns() macro currently returns &init_user_ns when user
    namespaces are disabled, and that causes several warnings when building
    with gcc-6.0 in code that compares the result of the macro to
    &init_user_ns itself:
    
      fs/xfs/xfs_ioctl.c: In function 'xfs_ioctl_setattr_check_projid':
      fs/xfs/xfs_ioctl.c:1249:22: error: self-comparison always evaluates to true [-Werror=tautological-compare]
        if (current_user_ns() == &init_user_ns)
    
    This is a legitimate warning in principle, but here it isn't really
    helpful, so I'm reprasing the definition in a way that shuts up the
    warning.  Apparently gcc only warns when comparing identical literals,
    but it can figure out that the result of an inline function can be
    identical to a constant expression in order to optimize a condition yet
    not warn about the fact that the condition is known at compile time.
    This is exactly what we want here, and it looks reasonable because we
    generally prefer inline functions over macros anyway.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Yaowei Bai <baiyaowei@cmss.chinamobile.com>
    Cc: James Morris <james.l.morris@oracle.com>
    Cc: "Paul E. McKenney" <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 8d70e1361ecd..257db64562e5 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -377,7 +377,10 @@ extern struct user_namespace init_user_ns;
 #ifdef CONFIG_USER_NS
 #define current_user_ns()	(current_cred_xxx(user_ns))
 #else
-#define current_user_ns()	(&init_user_ns)
+static inline struct user_namespace *current_user_ns(void)
+{
+	return &init_user_ns;
+}
 #endif
 
 

commit 58319057b7847667f0c9585b9de0e8932b0fdb08
Author: Andy Lutomirski <luto@kernel.org>
Date:   Fri Sep 4 15:42:45 2015 -0700

    capabilities: ambient capabilities
    
    Credit where credit is due: this idea comes from Christoph Lameter with
    a lot of valuable input from Serge Hallyn.  This patch is heavily based
    on Christoph's patch.
    
    ===== The status quo =====
    
    On Linux, there are a number of capabilities defined by the kernel.  To
    perform various privileged tasks, processes can wield capabilities that
    they hold.
    
    Each task has four capability masks: effective (pE), permitted (pP),
    inheritable (pI), and a bounding set (X).  When the kernel checks for a
    capability, it checks pE.  The other capability masks serve to modify
    what capabilities can be in pE.
    
    Any task can remove capabilities from pE, pP, or pI at any time.  If a
    task has a capability in pP, it can add that capability to pE and/or pI.
    If a task has CAP_SETPCAP, then it can add any capability to pI, and it
    can remove capabilities from X.
    
    Tasks are not the only things that can have capabilities; files can also
    have capabilities.  A file can have no capabilty information at all [1].
    If a file has capability information, then it has a permitted mask (fP)
    and an inheritable mask (fI) as well as a single effective bit (fE) [2].
    File capabilities modify the capabilities of tasks that execve(2) them.
    
    A task that successfully calls execve has its capabilities modified for
    the file ultimately being excecuted (i.e.  the binary itself if that
    binary is ELF or for the interpreter if the binary is a script.) [3] In
    the capability evolution rules, for each mask Z, pZ represents the old
    value and pZ' represents the new value.  The rules are:
    
      pP' = (X & fP) | (pI & fI)
      pI' = pI
      pE' = (fE ? pP' : 0)
      X is unchanged
    
    For setuid binaries, fP, fI, and fE are modified by a moderately
    complicated set of rules that emulate POSIX behavior.  Similarly, if
    euid == 0 or ruid == 0, then fP, fI, and fE are modified differently
    (primary, fP and fI usually end up being the full set).  For nonroot
    users executing binaries with neither setuid nor file caps, fI and fP
    are empty and fE is false.
    
    As an extra complication, if you execute a process as nonroot and fE is
    set, then the "secure exec" rules are in effect: AT_SECURE gets set,
    LD_PRELOAD doesn't work, etc.
    
    This is rather messy.  We've learned that making any changes is
    dangerous, though: if a new kernel version allows an unprivileged
    program to change its security state in a way that persists cross
    execution of a setuid program or a program with file caps, this
    persistent state is surprisingly likely to allow setuid or file-capped
    programs to be exploited for privilege escalation.
    
    ===== The problem =====
    
    Capability inheritance is basically useless.
    
    If you aren't root and you execute an ordinary binary, fI is zero, so
    your capabilities have no effect whatsoever on pP'.  This means that you
    can't usefully execute a helper process or a shell command with elevated
    capabilities if you aren't root.
    
    On current kernels, you can sort of work around this by setting fI to
    the full set for most or all non-setuid executable files.  This causes
    pP' = pI for nonroot, and inheritance works.  No one does this because
    it's a PITA and it isn't even supported on most filesystems.
    
    If you try this, you'll discover that every nonroot program ends up with
    secure exec rules, breaking many things.
    
    This is a problem that has bitten many people who have tried to use
    capabilities for anything useful.
    
    ===== The proposed change =====
    
    This patch adds a fifth capability mask called the ambient mask (pA).
    pA does what most people expect pI to do.
    
    pA obeys the invariant that no bit can ever be set in pA if it is not
    set in both pP and pI.  Dropping a bit from pP or pI drops that bit from
    pA.  This ensures that existing programs that try to drop capabilities
    still do so, with a complication.  Because capability inheritance is so
    broken, setting KEEPCAPS, using setresuid to switch to nonroot uids, and
    then calling execve effectively drops capabilities.  Therefore,
    setresuid from root to nonroot conditionally clears pA unless
    SECBIT_NO_SETUID_FIXUP is set.  Processes that don't like this can
    re-add bits to pA afterwards.
    
    The capability evolution rules are changed:
    
      pA' = (file caps or setuid or setgid ? 0 : pA)
      pP' = (X & fP) | (pI & fI) | pA'
      pI' = pI
      pE' = (fE ? pP' : pA')
      X is unchanged
    
    If you are nonroot but you have a capability, you can add it to pA.  If
    you do so, your children get that capability in pA, pP, and pE.  For
    example, you can set pA = CAP_NET_BIND_SERVICE, and your children can
    automatically bind low-numbered ports.  Hallelujah!
    
    Unprivileged users can create user namespaces, map themselves to a
    nonzero uid, and create both privileged (relative to their namespace)
    and unprivileged process trees.  This is currently more or less
    impossible.  Hallelujah!
    
    You cannot use pA to try to subvert a setuid, setgid, or file-capped
    program: if you execute any such program, pA gets cleared and the
    resulting evolution rules are unchanged by this patch.
    
    Users with nonzero pA are unlikely to unintentionally leak that
    capability.  If they run programs that try to drop privileges, dropping
    privileges will still work.
    
    It's worth noting that the degree of paranoia in this patch could
    possibly be reduced without causing serious problems.  Specifically, if
    we allowed pA to persist across executing non-pA-aware setuid binaries
    and across setresuid, then, naively, the only capabilities that could
    leak as a result would be the capabilities in pA, and any attacker
    *already* has those capabilities.  This would make me nervous, though --
    setuid binaries that tried to privilege-separate might fail to do so,
    and putting CAP_DAC_READ_SEARCH or CAP_DAC_OVERRIDE into pA could have
    unexpected side effects.  (Whether these unexpected side effects would
    be exploitable is an open question.) I've therefore taken the more
    paranoid route.  We can revisit this later.
    
    An alternative would be to require PR_SET_NO_NEW_PRIVS before setting
    ambient capabilities.  I think that this would be annoying and would
    make granting otherwise unprivileged users minor ambient capabilities
    (CAP_NET_BIND_SERVICE or CAP_NET_RAW for example) much less useful than
    it is with this patch.
    
    ===== Footnotes =====
    
    [1] Files that are missing the "security.capability" xattr or that have
    unrecognized values for that xattr end up with has_cap set to false.
    The code that does that appears to be complicated for no good reason.
    
    [2] The libcap capability mask parsers and formatters are dangerously
    misleading and the documentation is flat-out wrong.  fE is *not* a mask;
    it's a single bit.  This has probably confused every single person who
    has tried to use file capabilities.
    
    [3] Linux very confusingly processes both the script and the interpreter
    if applicable, for reasons that elude me.  The results from thinking
    about a script's file capabilities and/or setuid bits are mostly
    discarded.
    
    Preliminary userspace code is here, but it needs updating:
    https://git.kernel.org/cgit/linux/kernel/git/luto/util-linux-playground.git/commit/?h=cap_ambient&id=7f5afbd175d2
    
    Here is a test program that can be used to verify the functionality
    (from Christoph):
    
    /*
     * Test program for the ambient capabilities. This program spawns a shell
     * that allows running processes with a defined set of capabilities.
     *
     * (C) 2015 Christoph Lameter <cl@linux.com>
     * Released under: GPL v3 or later.
     *
     *
     * Compile using:
     *
     *      gcc -o ambient_test ambient_test.o -lcap-ng
     *
     * This program must have the following capabilities to run properly:
     * Permissions for CAP_NET_RAW, CAP_NET_ADMIN, CAP_SYS_NICE
     *
     * A command to equip the binary with the right caps is:
     *
     *      setcap cap_net_raw,cap_net_admin,cap_sys_nice+p ambient_test
     *
     *
     * To get a shell with additional caps that can be inherited by other processes:
     *
     *      ./ambient_test /bin/bash
     *
     *
     * Verifying that it works:
     *
     * From the bash spawed by ambient_test run
     *
     *      cat /proc/$$/status
     *
     * and have a look at the capabilities.
     */
    
    #include <stdlib.h>
    #include <stdio.h>
    #include <errno.h>
    #include <cap-ng.h>
    #include <sys/prctl.h>
    #include <linux/capability.h>
    
    /*
     * Definitions from the kernel header files. These are going to be removed
     * when the /usr/include files have these defined.
     */
    #define PR_CAP_AMBIENT 47
    #define PR_CAP_AMBIENT_IS_SET 1
    #define PR_CAP_AMBIENT_RAISE 2
    #define PR_CAP_AMBIENT_LOWER 3
    #define PR_CAP_AMBIENT_CLEAR_ALL 4
    
    static void set_ambient_cap(int cap)
    {
            int rc;
    
            capng_get_caps_process();
            rc = capng_update(CAPNG_ADD, CAPNG_INHERITABLE, cap);
            if (rc) {
                    printf("Cannot add inheritable cap\n");
                    exit(2);
            }
            capng_apply(CAPNG_SELECT_CAPS);
    
            /* Note the two 0s at the end. Kernel checks for these */
            if (prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, cap, 0, 0)) {
                    perror("Cannot set cap");
                    exit(1);
            }
    }
    
    int main(int argc, char **argv)
    {
            int rc;
    
            set_ambient_cap(CAP_NET_RAW);
            set_ambient_cap(CAP_NET_ADMIN);
            set_ambient_cap(CAP_SYS_NICE);
    
            printf("Ambient_test forking shell\n");
            if (execv(argv[1], argv + 1))
                    perror("Cannot exec");
    
            return 0;
    }
    
    Signed-off-by: Christoph Lameter <cl@linux.com> # Original author
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Aaron Jones <aaronmdjones@gmail.com>
    Cc: Ted Ts'o <tytso@mit.edu>
    Cc: Andrew G. Morgan <morgan@kernel.org>
    Cc: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Cc: Austin S Hemmelgarn <ahferroin7@gmail.com>
    Cc: Markku Savela <msa@moth.iki.fi>
    Cc: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: James Morris <james.l.morris@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 8b6c083e68a7..8d70e1361ecd 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -137,6 +137,7 @@ struct cred {
 	kernel_cap_t	cap_permitted;	/* caps we're permitted */
 	kernel_cap_t	cap_effective;	/* caps we can actually use */
 	kernel_cap_t	cap_bset;	/* capability bounding set */
+	kernel_cap_t	cap_ambient;	/* Ambient capability set */
 #ifdef CONFIG_KEYS
 	unsigned char	jit_keyring;	/* default keyring to attach requested
 					 * keys to */
@@ -212,6 +213,13 @@ static inline void validate_process_creds(void)
 }
 #endif
 
+static inline bool cap_ambient_invariant_ok(const struct cred *cred)
+{
+	return cap_issubset(cred->cap_ambient,
+			    cap_intersect(cred->cap_permitted,
+					  cred->cap_inheritable));
+}
+
 /**
  * get_new_cred - Get a reference on a new set of credentials
  * @cred: The new credentials to reference

commit 2813893f8b197a14f1e1ddb04d99bce46817c84a
Author: Iulia Manda <iulia.manda21@gmail.com>
Date:   Wed Apr 15 16:16:41 2015 -0700

    kernel: conditionally support non-root users, groups and capabilities
    
    There are a lot of embedded systems that run most or all of their
    functionality in init, running as root:root.  For these systems,
    supporting multiple users is not necessary.
    
    This patch adds a new symbol, CONFIG_MULTIUSER, that makes support for
    non-root users, non-root groups, and capabilities optional.  It is enabled
    under CONFIG_EXPERT menu.
    
    When this symbol is not defined, UID and GID are zero in any possible case
    and processes always have all capabilities.
    
    The following syscalls are compiled out: setuid, setregid, setgid,
    setreuid, setresuid, getresuid, setresgid, getresgid, setgroups,
    getgroups, setfsuid, setfsgid, capget, capset.
    
    Also, groups.c is compiled out completely.
    
    In kernel/capability.c, capable function was moved in order to avoid
    adding two ifdef blocks.
    
    This change saves about 25 KB on a defconfig build.  The most minimal
    kernels have total text sizes in the high hundreds of kB rather than
    low MB.  (The 25k goes down a bit with allnoconfig, but not that much.
    
    The kernel was booted in Qemu.  All the common functionalities work.
    Adding users/groups is not possible, failing with -ENOSYS.
    
    Bloat-o-meter output:
    add/remove: 7/87 grow/shrink: 19/397 up/down: 1675/-26325 (-24650)
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Iulia Manda <iulia.manda21@gmail.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Tested-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Reviewed-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 2fb2ca2127ed..8b6c083e68a7 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -62,9 +62,27 @@ do {							\
 		groups_free(group_info);		\
 } while (0)
 
-extern struct group_info *groups_alloc(int);
 extern struct group_info init_groups;
+#ifdef CONFIG_MULTIUSER
+extern struct group_info *groups_alloc(int);
 extern void groups_free(struct group_info *);
+
+extern int in_group_p(kgid_t);
+extern int in_egroup_p(kgid_t);
+#else
+static inline void groups_free(struct group_info *group_info)
+{
+}
+
+static inline int in_group_p(kgid_t grp)
+{
+        return 1;
+}
+static inline int in_egroup_p(kgid_t grp)
+{
+        return 1;
+}
+#endif
 extern int set_current_groups(struct group_info *);
 extern void set_groups(struct cred *, struct group_info *);
 extern int groups_search(const struct group_info *, kgid_t);
@@ -74,9 +92,6 @@ extern bool may_setgroups(void);
 #define GROUP_AT(gi, i) \
 	((gi)->blocks[(i) / NGROUPS_PER_BLOCK][(i) % NGROUPS_PER_BLOCK])
 
-extern int in_group_p(kgid_t);
-extern int in_egroup_p(kgid_t);
-
 /*
  * The security context of a task
  *

commit 7ff4d90b4c24a03666f296c3d4878cd39001e81e
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Dec 5 17:19:27 2014 -0600

    groups: Consolidate the setgroups permission checks
    
    Today there are 3 instances of setgroups and due to an oversight their
    permission checking has diverged.  Add a common function so that
    they may all share the same permission checking code.
    
    This corrects the current oversight in the current permission checks
    and adds a helper to avoid this in the future.
    
    A user namespace security fix will update this new helper, shortly.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index b2d0820837c4..2fb2ca2127ed 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -68,6 +68,7 @@ extern void groups_free(struct group_info *);
 extern int set_current_groups(struct group_info *);
 extern void set_groups(struct cred *, struct group_info *);
 extern int groups_search(const struct group_info *, kgid_t);
+extern bool may_setgroups(void);
 
 /* access the groups "array" with this macro */
 #define GROUP_AT(gi, i) \

commit ae4b884fc6316b3190be19448cea24b020c1cad6
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Tue Jul 15 12:59:36 2014 -0400

    nfsd: silence sparse warning about accessing credentials
    
    sparse says:
    
        fs/nfsd/auth.c:31:38: warning: incorrect type in argument 1 (different address spaces)
        fs/nfsd/auth.c:31:38:    expected struct cred const *cred
        fs/nfsd/auth.c:31:38:    got struct cred const [noderef] <asn:4>*real_cred
    
    Add a new accessor for the ->real_cred and use that to fetch the
    pointer. Accessing current->real_cred directly is actually quite safe
    since we know that they can't go away so this is mostly a cosmetic fixup
    to silence sparse.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index f61d6c8f5ef3..b2d0820837c4 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -258,6 +258,15 @@ static inline void put_cred(const struct cred *_cred)
 #define current_cred() \
 	rcu_dereference_protected(current->cred, 1)
 
+/**
+ * current_real_cred - Access the current task's objective credentials
+ *
+ * Access the objective credentials of the current task.  RCU-safe,
+ * since nobody else can modify it.
+ */
+#define current_real_cred() \
+	rcu_dereference_protected(current->real_cred, 1)
+
 /**
  * __task_cred - Access a task's objective credentials
  * @task: The task to query

commit 8f6c5ffc8987f4f5b5a3e9d557d94bbf3a9bf216
Author: Wang YanQing <udknight@gmail.com>
Date:   Thu Apr 3 14:48:26 2014 -0700

    kernel/groups.c: remove return value of set_groups
    
    After commit 6307f8fee295 ("security: remove dead hook task_setgroups"),
    set_groups will always return zero, so we could just remove return value
    of set_groups.
    
    This patch reduces code size, and simplfies code to use set_groups,
    because we don't need to check its return value any more.
    
    [akpm@linux-foundation.org: remove obsolete claims from set_groups() comment]
    Signed-off-by: Wang YanQing <udknight@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Serge Hallyn <serge.hallyn@canonical.com>
    Cc: Eric Paris <eparis@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 04421e825365..f61d6c8f5ef3 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -66,7 +66,7 @@ extern struct group_info *groups_alloc(int);
 extern struct group_info init_groups;
 extern void groups_free(struct group_info *);
 extern int set_current_groups(struct group_info *);
-extern int set_groups(struct cred *, struct group_info *);
+extern void set_groups(struct cred *, struct group_info *);
 extern int groups_search(const struct group_info *, kgid_t);
 
 /* access the groups "array" with this macro */

commit 08c097fc3bb283299a6915a6a3795edab85979b1
Author: Marc Dionne <marc.c.dionne@gmail.com>
Date:   Wed Jan 9 14:16:30 2013 +0000

    cred: Remove tgcred pointer from struct cred
    
    Commit 3a50597de863 ("KEYS: Make the session and process keyrings
    per-thread") removed the definition of the thread_group_cred structure,
    but left a now unused pointer in struct cred.
    
    Signed-off-by: Marc Dionne <marc.c.dionne@gmail.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index abb2cd50f6b2..04421e825365 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -128,7 +128,6 @@ struct cred {
 	struct key	*process_keyring; /* keyring private to this process */
 	struct key	*thread_keyring; /* keyring private to this thread */
 	struct key	*request_key_auth; /* assumed request_key authority */
-	struct thread_group_cred *tgcred; /* thread-group shared credentials */
 #endif
 #ifdef CONFIG_SECURITY
 	void		*security;	/* subjective LSM security */

commit 6a2b60b17b3e48a418695a94bd2420f6ab32e519
Merge: 9228ff90387e 98f842e675f9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 17 15:44:47 2012 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull user namespace changes from Eric Biederman:
     "While small this set of changes is very significant with respect to
      containers in general and user namespaces in particular.  The user
      space interface is now complete.
    
      This set of changes adds support for unprivileged users to create user
      namespaces and as a user namespace root to create other namespaces.
      The tyranny of supporting suid root preventing unprivileged users from
      using cool new kernel features is broken.
    
      This set of changes completes the work on setns, adding support for
      the pid, user, mount namespaces.
    
      This set of changes includes a bunch of basic pid namespace
      cleanups/simplifications.  Of particular significance is the rework of
      the pid namespace cleanup so it no longer requires sending out
      tendrils into all kinds of unexpected cleanup paths for operation.  At
      least one case of broken error handling is fixed by this cleanup.
    
      The files under /proc/<pid>/ns/ have been converted from regular files
      to magic symlinks which prevents incorrect caching by the VFS,
      ensuring the files always refer to the namespace the process is
      currently using and ensuring that the ptrace_mayaccess permission
      checks are always applied.
    
      The files under /proc/<pid>/ns/ have been given stable inode numbers
      so it is now possible to see if different processes share the same
      namespaces.
    
      Through the David Miller's net tree are changes to relax many of the
      permission checks in the networking stack to allowing the user
      namespace root to usefully use the networking stack.  Similar changes
      for the mount namespace and the pid namespace are coming through my
      tree.
    
      Two small changes to add user namespace support were commited here adn
      in David Miller's -net tree so that I could complete the work on the
      /proc/<pid>/ns/ files in this tree.
    
      Work remains to make it safe to build user namespaces and 9p, afs,
      ceph, cifs, coda, gfs2, ncpfs, nfs, nfsd, ocfs2, and xfs so the
      Kconfig guard remains in place preventing that user namespaces from
      being built when any of those filesystems are enabled.
    
      Future design work remains to allow root users outside of the initial
      user namespace to mount more than just /proc and /sys."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace: (38 commits)
      proc: Usable inode numbers for the namespace file descriptors.
      proc: Fix the namespace inode permission checks.
      proc: Generalize proc inode allocation
      userns: Allow unprivilged mounts of proc and sysfs
      userns: For /proc/self/{uid,gid}_map derive the lower userns from the struct file
      procfs: Print task uids and gids in the userns that opened the proc file
      userns: Implement unshare of the user namespace
      userns: Implent proc namespace operations
      userns: Kill task_user_ns
      userns: Make create_new_namespaces take a user_ns parameter
      userns: Allow unprivileged use of setns.
      userns: Allow unprivileged users to create new namespaces
      userns: Allow setting a userns mapping to your current uid.
      userns: Allow chown and setgid preservation
      userns: Allow unprivileged users to create user namespaces.
      userns: Ignore suid and sgid on binaries if the uid or gid can not be mapped
      userns: fix return value on mntns_install() failure
      vfs: Allow unprivileged manipulation of the mount namespace.
      vfs: Only support slave subtrees across different user namespaces
      vfs: Add a user namespace reference from struct mnt_namespace
      ...

commit 4c44aaafa8108f584831850ab48a975e971db2de
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Jul 26 05:05:21 2012 -0700

    userns: Kill task_user_ns
    
    The task_user_ns function hides the fact that it is getting the user
    namespace from struct cred on the task.  struct cred may go away as
    soon as the rcu lock is released.  This leads to a race where we
    can dereference a stale user namespace pointer.
    
    To make it obvious a struct cred is involved kill task_user_ns.
    
    To kill the race modify the users of task_user_ns to only
    reference the user namespace while the rcu lock is held.
    
    Cc: Kees Cook <keescook@chromium.org>
    Cc: James Morris <james.l.morris@oracle.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index ebbed2ce6637..856d2622d832 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -357,10 +357,8 @@ static inline void put_cred(const struct cred *_cred)
 extern struct user_namespace init_user_ns;
 #ifdef CONFIG_USER_NS
 #define current_user_ns()	(current_cred_xxx(user_ns))
-#define task_user_ns(task)	(task_cred_xxx((task), user_ns))
 #else
 #define current_user_ns()	(&init_user_ns)
-#define task_user_ns(task)	(&init_user_ns)
 #endif
 
 

commit 3a50597de8635cd05133bd12c95681c82fe7b878
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 2 19:24:29 2012 +0100

    KEYS: Make the session and process keyrings per-thread
    
    Make the session keyring per-thread rather than per-process, but still
    inherited from the parent thread to solve a problem with PAM and gdm.
    
    The problem is that join_session_keyring() will reject attempts to change the
    session keyring of a multithreaded program but gdm is now multithreaded before
    it gets to the point of starting PAM and running pam_keyinit to create the
    session keyring.  See:
    
            https://bugs.freedesktop.org/show_bug.cgi?id=49211
    
    The reason that join_session_keyring() will only change the session keyring
    under a single-threaded environment is that it's hard to alter the other
    thread's credentials to effect the change in a multi-threaded program.  The
    problems are such as:
    
     (1) How to prevent two threads both running join_session_keyring() from
         racing.
    
     (2) Another thread's credentials may not be modified directly by this process.
    
     (3) The number of threads is uncertain whilst we're not holding the
         appropriate spinlock, making preallocation slightly tricky.
    
     (4) We could use TIF_NOTIFY_RESUME and key_replace_session_keyring() to get
         another thread to replace its keyring, but that means preallocating for
         each thread.
    
    A reasonable way around this is to make the session keyring per-thread rather
    than per-process and just document that if you want a common session keyring,
    you must get it before you spawn any threads - which is the current situation
    anyway.
    
    Whilst we're at it, we can the process keyring behave in the same way.  This
    means we can clean up some of the ickyness in the creds code.
    
    Basically, after this patch, the session, process and thread keyrings are about
    inheritance rules only and not about sharing changes of keyring.
    
    Reported-by: Mantas M. <grawity@gmail.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Ray Strode <rstrode@redhat.com>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index ebbed2ce6637..0142aacb70b7 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -76,21 +76,6 @@ extern int groups_search(const struct group_info *, kgid_t);
 extern int in_group_p(kgid_t);
 extern int in_egroup_p(kgid_t);
 
-/*
- * The common credentials for a thread group
- * - shared by CLONE_THREAD
- */
-#ifdef CONFIG_KEYS
-struct thread_group_cred {
-	atomic_t	usage;
-	pid_t		tgid;			/* thread group process ID */
-	spinlock_t	lock;
-	struct key __rcu *session_keyring;	/* keyring inherited over fork */
-	struct key	*process_keyring;	/* keyring private to this process */
-	struct rcu_head	rcu;			/* RCU deletion hook */
-};
-#endif
-
 /*
  * The security context of a task
  *
@@ -139,6 +124,8 @@ struct cred {
 #ifdef CONFIG_KEYS
 	unsigned char	jit_keyring;	/* default keyring to attach requested
 					 * keys to */
+	struct key __rcu *session_keyring; /* keyring inherited over fork */
+	struct key	*process_keyring; /* keyring private to this process */
 	struct key	*thread_keyring; /* keyring private to this thread */
 	struct key	*request_key_auth; /* assumed request_key authority */
 	struct thread_group_cred *tgcred; /* thread-group shared credentials */

commit 43e13cc107cf6cd3c15fbe1cef849435c2223d50
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Thu May 31 16:26:16 2012 -0700

    cred: remove task_is_dead() from __task_cred() validation
    
    Commit 8f92054e7ca1 ("CRED: Fix __task_cred()'s lockdep check and banner
    comment"):
    
        add the following validation condition:
    
            task->exit_state >= 0
    
        to permit the access if the target task is dead and therefore
        unable to change its own credentials.
    
    OK, but afaics currently this can only help wait_task_zombie() which calls
    __task_cred() without rcu lock.
    
    Remove this validation and change wait_task_zombie() to use task_uid()
    instead.  This means we do rcu_read_lock() only to shut up the lockdep,
    but we already do the same in, say, wait_task_stopped().
    
    task_is_dead() should die, task->exit_state != 0 means that this task has
    passed exit_notify(), only do_wait-like code paths should use this.
    
    Unfortunately, we can't kill task_is_dead() right now, it has already
    acquired buggy users in drivers/staging.  The fix already exists.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Reviewed-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: James Morris <jmorris@namei.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 917dc5aeb1d4..ebbed2ce6637 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -277,17 +277,13 @@ static inline void put_cred(const struct cred *_cred)
  * @task: The task to query
  *
  * Access the objective credentials of a task.  The caller must hold the RCU
- * readlock or the task must be dead and unable to change its own credentials.
+ * readlock.
  *
  * The result of this function should not be passed directly to get_cred();
  * rather get_task_cred() should be used instead.
  */
-#define __task_cred(task)						\
-	({								\
-		const struct task_struct *__t = (task);			\
-		rcu_dereference_check(__t->real_cred,			\
-				      task_is_dead(__t));		\
-	})
+#define __task_cred(task)	\
+	rcu_dereference((task)->real_cred)
 
 /**
  * get_current_cred - Get the current task's subjective credentials

commit 72cda3d1ef24ab0a9a89c15e9776ca737b75f45a
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Feb 9 09:09:39 2012 -0800

    userns: Convert in_group_p and in_egroup_p to use kgid_t
    
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index fac0579258fc..917dc5aeb1d4 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -73,8 +73,8 @@ extern int groups_search(const struct group_info *, kgid_t);
 #define GROUP_AT(gi, i) \
 	((gi)->blocks[(i) / NGROUPS_PER_BLOCK][(i) % NGROUPS_PER_BLOCK])
 
-extern int in_group_p(gid_t);
-extern int in_egroup_p(gid_t);
+extern int in_group_p(kgid_t);
+extern int in_egroup_p(kgid_t);
 
 /*
  * The common credentials for a thread group

commit 078de5f706ece36afd73bb4b8283314132d2dfdf
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Feb 8 07:00:08 2012 -0800

    userns: Store uid and gid values in struct cred with kuid_t and kgid_t types
    
    cred.h and a few trivial users of struct cred are changed.  The rest of the users
    of struct cred are left for other patches as there are too many changes to make
    in one go and leave the change reviewable.  If the user namespace is disabled and
    CONFIG_UIDGID_STRICT_TYPE_CHECKS are disabled the code will contiue to compile
    and behave correctly.
    
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 0ab3cda4a774..fac0579258fc 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -123,14 +123,14 @@ struct cred {
 #define CRED_MAGIC	0x43736564
 #define CRED_MAGIC_DEAD	0x44656144
 #endif
-	uid_t		uid;		/* real UID of the task */
-	gid_t		gid;		/* real GID of the task */
-	uid_t		suid;		/* saved UID of the task */
-	gid_t		sgid;		/* saved GID of the task */
-	uid_t		euid;		/* effective UID of the task */
-	gid_t		egid;		/* effective GID of the task */
-	uid_t		fsuid;		/* UID for VFS ops */
-	gid_t		fsgid;		/* GID for VFS ops */
+	kuid_t		uid;		/* real UID of the task */
+	kgid_t		gid;		/* real GID of the task */
+	kuid_t		suid;		/* saved UID of the task */
+	kgid_t		sgid;		/* saved GID of the task */
+	kuid_t		euid;		/* effective UID of the task */
+	kgid_t		egid;		/* effective GID of the task */
+	kuid_t		fsuid;		/* UID for VFS ops */
+	kgid_t		fsgid;		/* GID for VFS ops */
 	unsigned	securebits;	/* SUID-less security management */
 	kernel_cap_t	cap_inheritable; /* caps our children can inherit */
 	kernel_cap_t	cap_permitted;	/* caps we're permitted */

commit ae2975bc3476243b45a1e2344236d7920c268f38
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Nov 14 15:56:38 2011 -0800

    userns: Convert group_info values from gid_t to kgid_t.
    
    As a first step to converting struct cred to be all kuid_t and kgid_t
    values convert the group values stored in group_info to always be
    kgid_t values.   Unless user namespaces are used this change should
    have no effect.
    
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 2c60ec802678..0ab3cda4a774 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -17,6 +17,7 @@
 #include <linux/key.h>
 #include <linux/selinux.h>
 #include <linux/atomic.h>
+#include <linux/uidgid.h>
 
 struct user_struct;
 struct cred;
@@ -26,14 +27,14 @@ struct inode;
  * COW Supplementary groups list
  */
 #define NGROUPS_SMALL		32
-#define NGROUPS_PER_BLOCK	((unsigned int)(PAGE_SIZE / sizeof(gid_t)))
+#define NGROUPS_PER_BLOCK	((unsigned int)(PAGE_SIZE / sizeof(kgid_t)))
 
 struct group_info {
 	atomic_t	usage;
 	int		ngroups;
 	int		nblocks;
-	gid_t		small_block[NGROUPS_SMALL];
-	gid_t		*blocks[0];
+	kgid_t		small_block[NGROUPS_SMALL];
+	kgid_t		*blocks[0];
 };
 
 /**
@@ -66,7 +67,7 @@ extern struct group_info init_groups;
 extern void groups_free(struct group_info *);
 extern int set_current_groups(struct group_info *);
 extern int set_groups(struct cred *, struct group_info *);
-extern int groups_search(const struct group_info *, gid_t);
+extern int groups_search(const struct group_info *, kgid_t);
 
 /* access the groups "array" with this macro */
 #define GROUP_AT(gi, i) \

commit 0093ccb68f3753c0ba4d74c89d7e0f444b8d6123
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Nov 16 21:52:53 2011 -0800

    cred: Refcount the user_ns pointed to by the cred.
    
    struct user_struct will shortly loose it's user_ns reference
    so make the cred user_ns reference a proper reference complete
    with reference counting.
    
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index d12c4e475c15..2c60ec802678 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -146,7 +146,7 @@ struct cred {
 	void		*security;	/* subjective LSM security */
 #endif
 	struct user_struct *user;	/* real user ID subscription */
-	struct user_namespace *user_ns; /* cached user->user_ns */
+	struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
 	struct group_info *group_info;	/* supplementary groups for euid/fsgid */
 	struct rcu_head	rcu;		/* RCU deletion hook */
 };

commit 7e6bd8fadd1216f50468f965d0308f45e5109ced
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Nov 14 19:29:17 2011 -0800

    cred: Add forward declaration of init_user_ns in all cases.
    
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index adadf71a7327..d12c4e475c15 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -357,11 +357,11 @@ static inline void put_cred(const struct cred *_cred)
 #define current_user()		(current_cred_xxx(user))
 #define current_security()	(current_cred_xxx(security))
 
+extern struct user_namespace init_user_ns;
 #ifdef CONFIG_USER_NS
 #define current_user_ns()	(current_cred_xxx(user_ns))
 #define task_user_ns(task)	(task_cred_xxx((task), user_ns))
 #else
-extern struct user_namespace init_user_ns;
 #define current_user_ns()	(&init_user_ns)
 #define task_user_ns(task)	(&init_user_ns)
 #endif

commit f1c84dae0ecc51aa35c81f19a0ebcd6c0921ddcb
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Jan 3 12:25:15 2012 -0500

    capabilities: remove task_ns_* functions
    
    task_ in the front of a function, in the security subsystem anyway, means
    to me at least, that we are operating with that task as the subject of the
    security decision.  In this case what it means is that we are using current as
    the subject but we use the task to get the right namespace.  Who in the world
    would ever realize that's what task_ns_capability means just by the name?  This
    patch eliminates the task_ns functions entirely and uses the has_ns_capability
    function instead.  This means we explicitly open code the ns in question in
    the caller.  I think it makes the caller a LOT more clear what is going on.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@canonical.com>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 40308969ed00..adadf71a7327 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -358,10 +358,12 @@ static inline void put_cred(const struct cred *_cred)
 #define current_security()	(current_cred_xxx(security))
 
 #ifdef CONFIG_USER_NS
-#define current_user_ns() (current_cred_xxx(user_ns))
+#define current_user_ns()	(current_cred_xxx(user_ns))
+#define task_user_ns(task)	(task_cred_xxx((task), user_ns))
 #else
 extern struct user_namespace init_user_ns;
-#define current_user_ns() (&init_user_ns)
+#define current_user_ns()	(&init_user_ns)
+#define task_user_ns(task)	(&init_user_ns)
 #endif
 
 

commit 638a8439096c582bdb523fcea9d875d3e1fed38a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 8 11:33:23 2011 -0700

    cred: use 'const' in get_current_{user,groups}
    
    Avoid annoying warnings from these functions ("discards qualifiers")
    because they assign 'current_cred()' to a non-const pointer.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 8e2fd44eb160..40308969ed00 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -307,7 +307,7 @@ static inline void put_cred(const struct cred *_cred)
 #define get_current_user()				\
 ({							\
 	struct user_struct *__u;			\
-	struct cred *__cred;				\
+	const struct cred *__cred;			\
 	__cred = current_cred();			\
 	__u = get_uid(__cred->user);			\
 	__u;						\
@@ -322,7 +322,7 @@ static inline void put_cred(const struct cred *_cred)
 #define get_current_groups()				\
 ({							\
 	struct group_info *__groups;			\
-	struct cred *__cred;				\
+	const struct cred *__cred;			\
 	__cred = current_cred();			\
 	__groups = get_group_info(__cred->group_info);	\
 	__groups;					\

commit 27e4e4362756a78b15e83ef104c8bbe257f40f90
Author: David Howells <dhowells@redhat.com>
Date:   Mon Aug 8 15:54:53 2011 +0100

    CRED: Restore const to current_cred()
    
    Commit 3295514841c2 ("fix rcu annotations noise in cred.h") accidentally
    dropped the const of current->cred inside current_cred() by the
    insertion of a cast to deal with an RCU annotation loss warning from
    sparce.
    
    Use an appropriate RCU wrapper instead so as not to lose the const.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 98f46efbe2d2..8e2fd44eb160 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -269,7 +269,7 @@ static inline void put_cred(const struct cred *_cred)
  * since nobody else can modify it.
  */
 #define current_cred() \
-	(*(__force struct cred **)&current->cred)
+	rcu_dereference_protected(current->cred, 1)
 
 /**
  * __task_cred - Access a task's objective credentials

commit 3295514841c2112d94451ba5deaf54f5afb78ea9
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Sun Aug 7 18:55:11 2011 +0100

    fix rcu annotations noise in cred.h
    
    task->cred is declared as __rcu, and access to other tasks' ->cred is,
    indeed, protected.  Access to current->cred does not need rcu_dereference()
    at all, since only the task itself can change its ->cred.  sparse, of
    course, has no way of knowing that...
    
    Add force-cast in current_cred(), make current_fsuid() et.al. use it.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 48e82af1159b..98f46efbe2d2 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -265,10 +265,11 @@ static inline void put_cred(const struct cred *_cred)
 /**
  * current_cred - Access the current task's subjective credentials
  *
- * Access the subjective credentials of the current task.
+ * Access the subjective credentials of the current task.  RCU-safe,
+ * since nobody else can modify it.
  */
 #define current_cred() \
-	(current->cred)
+	(*(__force struct cred **)&current->cred)
 
 /**
  * __task_cred - Access a task's objective credentials
@@ -307,7 +308,7 @@ static inline void put_cred(const struct cred *_cred)
 ({							\
 	struct user_struct *__u;			\
 	struct cred *__cred;				\
-	__cred = (struct cred *) current_cred();	\
+	__cred = current_cred();			\
 	__u = get_uid(__cred->user);			\
 	__u;						\
 })
@@ -322,7 +323,7 @@ static inline void put_cred(const struct cred *_cred)
 ({							\
 	struct group_info *__groups;			\
 	struct cred *__cred;				\
-	__cred = (struct cred *) current_cred();	\
+	__cred = current_cred();			\
 	__groups = get_group_info(__cred->group_info);	\
 	__groups;					\
 })
@@ -341,7 +342,7 @@ static inline void put_cred(const struct cred *_cred)
 
 #define current_cred_xxx(xxx)			\
 ({						\
-	current->cred->xxx;			\
+	current_cred()->xxx;			\
 })
 
 #define current_uid()		(current_cred_xxx(uid))

commit 60063497a95e716c9a689af3be2687d261f115b4
Author: Arun Sharma <asharma@fb.com>
Date:   Tue Jul 26 16:09:06 2011 -0700

    atomic: use <linux/atomic.h>
    
    This allows us to move duplicated code in <asm/atomic.h>
    (atomic_inc_not_zero() for now) to <linux/atomic.h>
    
    Signed-off-by: Arun Sharma <asharma@fb.com>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index f240f2fa0197..48e82af1159b 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -16,7 +16,7 @@
 #include <linux/init.h>
 #include <linux/key.h>
 #include <linux/selinux.h>
-#include <asm/atomic.h>
+#include <linux/atomic.h>
 
 struct user_struct;
 struct cred;

commit d8bf4ca9ca9576548628344c9725edd3786e90b1
Author: Michal Hocko <mhocko@suse.cz>
Date:   Fri Jul 8 14:39:41 2011 +0200

    rcu: treewide: Do not use rcu_read_lock_held when calling rcu_dereference_check
    
    Since ca5ecddf (rcu: define __rcu address space modifier for sparse)
    rcu_dereference_check use rcu_read_lock_held as a part of condition
    automatically so callers do not have to do that as well.
    
    Signed-off-by: Michal Hocko <mhocko@suse.cz>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 82607992f308..f240f2fa0197 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -284,7 +284,6 @@ static inline void put_cred(const struct cred *_cred)
 	({								\
 		const struct task_struct *__t = (task);			\
 		rcu_dereference_check(__t->real_cred,			\
-				      rcu_read_lock_held() ||		\
 				      task_is_dead(__t));		\
 	})
 

commit d410fa4ef99112386de5f218dd7df7b4fca910b4
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Thu May 19 15:59:38 2011 -0700

    Create Documentation/security/,
    move LSM-, credentials-, and keys-related files from Documentation/
      to Documentation/security/,
    add Documentation/security/00-INDEX, and
    update all occurrences of Documentation/<moved_file>
      to Documentation/security/<moved_file>.

diff --git a/include/linux/cred.h b/include/linux/cred.h
index be16b61283cc..82607992f308 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -1,4 +1,4 @@
-/* Credentials management - see Documentation/credentials.txt
+/* Credentials management - see Documentation/security/credentials.txt
  *
  * Copyright (C) 2008 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)

commit 47a150edc2ae734c0f4bf50aa19499e23b9a46f8
Author: Serge E. Hallyn <serge.hallyn@canonical.com>
Date:   Fri May 13 04:27:54 2011 +0100

    Cache user_ns in struct cred
    
    If !CONFIG_USERNS, have current_user_ns() defined to (&init_user_ns).
    
    Get rid of _current_user_ns.  This requires nsown_capable() to be
    defined in capability.c rather than as static inline in capability.h,
    so do that.
    
    Request_key needs init_user_ns defined at current_user_ns if
    !CONFIG_USERNS, so forward-declare that in cred.h if !CONFIG_USERNS
    at current_user_ns() define.
    
    Compile-tested with and without CONFIG_USERNS.
    
    Signed-off-by: Serge E. Hallyn <serge.hallyn@canonical.com>
    [ This makes a huge performance difference for acl_permission_check(),
      up to 30%.  And that is one of the hottest kernel functions for loads
      that are pathname-lookup heavy.  ]
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 9aeeb0ba2003..be16b61283cc 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -146,6 +146,7 @@ struct cred {
 	void		*security;	/* subjective LSM security */
 #endif
 	struct user_struct *user;	/* real user ID subscription */
+	struct user_namespace *user_ns; /* cached user->user_ns */
 	struct group_info *group_info;	/* supplementary groups for euid/fsgid */
 	struct rcu_head	rcu;		/* RCU deletion hook */
 };
@@ -354,10 +355,15 @@ static inline void put_cred(const struct cred *_cred)
 #define current_fsgid() 	(current_cred_xxx(fsgid))
 #define current_cap()		(current_cred_xxx(cap_effective))
 #define current_user()		(current_cred_xxx(user))
-#define _current_user_ns()	(current_cred_xxx(user)->user_ns)
 #define current_security()	(current_cred_xxx(security))
 
-extern struct user_namespace *current_user_ns(void);
+#ifdef CONFIG_USER_NS
+#define current_user_ns() (current_cred_xxx(user_ns))
+#else
+extern struct user_namespace init_user_ns;
+#define current_user_ns() (&init_user_ns)
+#endif
+
 
 #define current_uid_gid(_uid, _gid)		\
 do {						\

commit 3486740a4f32a6a466f5ac931654d154790ba648
Author: Serge E. Hallyn <serge@hallyn.com>
Date:   Wed Mar 23 16:43:17 2011 -0700

    userns: security: make capabilities relative to the user namespace
    
    - Introduce ns_capable to test for a capability in a non-default
      user namespace.
    - Teach cap_capable to handle capabilities in a non-default
      user namespace.
    
    The motivation is to get to the unprivileged creation of new
    namespaces.  It looks like this gets us 90% of the way there, with
    only potential uid confusion issues left.
    
    I still need to handle getting all caps after creation but otherwise I
    think I have a good starter patch that achieves all of your goals.
    
    Changelog:
            11/05/2010: [serge] add apparmor
            12/14/2010: [serge] fix capabilities to created user namespaces
            Without this, if user serge creates a user_ns, he won't have
            capabilities to the user_ns he created.  THis is because we
            were first checking whether his effective caps had the caps
            he needed and returning -EPERM if not, and THEN checking whether
            he was the creator.  Reverse those checks.
            12/16/2010: [serge] security_real_capable needs ns argument in !security case
            01/11/2011: [serge] add task_ns_capable helper
            01/11/2011: [serge] add nsown_capable() helper per Bastian Blank suggestion
            02/16/2011: [serge] fix a logic bug: the root user is always creator of
                        init_user_ns, but should not always have capabilities to
                        it!  Fix the check in cap_capable().
            02/21/2011: Add the required user_ns parameter to security_capable,
                        fixing a compile failure.
            02/23/2011: Convert some macros to functions as per akpm comments.  Some
                        couldn't be converted because we can't easily forward-declare
                        them (they are inline if !SECURITY, extern if SECURITY).  Add
                        a current_user_ns function so we can use it in capability.h
                        without #including cred.h.  Move all forward declarations
                        together to the top of the #ifdef __KERNEL__ section, and use
                        kernel-doc format.
            02/23/2011: Per dhowells, clean up comment in cap_capable().
            02/23/2011: Per akpm, remove unreachable 'return -EPERM' in cap_capable.
    
    (Original written and signed off by Eric;  latest, modified version
    acked by him)
    
    [akpm@linux-foundation.org: fix build]
    [akpm@linux-foundation.org: export current_user_ns() for ecryptfs]
    [serge.hallyn@canonical.com: remove unneeded extra argument in selinux's task_has_capability]
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Serge E. Hallyn <serge.hallyn@canonical.com>
    Acked-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Acked-by: Daniel Lezcano <daniel.lezcano@free.fr>
    Acked-by: David Howells <dhowells@redhat.com>
    Cc: James Morris <jmorris@namei.org>
    Signed-off-by: Serge E. Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 4aaeab376446..9aeeb0ba2003 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -354,9 +354,11 @@ static inline void put_cred(const struct cred *_cred)
 #define current_fsgid() 	(current_cred_xxx(fsgid))
 #define current_cap()		(current_cred_xxx(cap_effective))
 #define current_user()		(current_cred_xxx(user))
-#define current_user_ns()	(current_cred_xxx(user)->user_ns)
+#define _current_user_ns()	(current_cred_xxx(user)->user_ns)
 #define current_security()	(current_cred_xxx(security))
 
+extern struct user_namespace *current_user_ns(void);
+
 #define current_uid_gid(_uid, _gid)		\
 do {						\
 	const struct cred *__cred;		\

commit e63ba744a64d234c8a07c469ab1806443cb0a6ff
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Feb 26 18:01:20 2010 +0100

    keys: __rcu annotations
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 4d2c39573f36..4aaeab376446 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -84,7 +84,7 @@ struct thread_group_cred {
 	atomic_t	usage;
 	pid_t		tgid;			/* thread group process ID */
 	spinlock_t	lock;
-	struct key	*session_keyring;	/* keyring inherited over fork */
+	struct key __rcu *session_keyring;	/* keyring inherited over fork */
 	struct key	*process_keyring;	/* keyring private to this process */
 	struct rcu_head	rcu;			/* RCU deletion hook */
 };

commit 8f92054e7ca1d3a3ae50fb42d2253ac8730d9b2a
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jul 29 12:45:55 2010 +0100

    CRED: Fix __task_cred()'s lockdep check and banner comment
    
    Fix __task_cred()'s lockdep check by removing the following validation
    condition:
    
            lockdep_tasklist_lock_is_held()
    
    as commit_creds() does not take the tasklist_lock, and nor do most of the
    functions that call it, so this check is pointless and it can prevent
    detection of the RCU lock not being held if the tasklist_lock is held.
    
    Instead, add the following validation condition:
    
            task->exit_state >= 0
    
    to permit the access if the target task is dead and therefore unable to change
    its own credentials.
    
    Fix __task_cred()'s comment to:
    
     (1) discard the bit that says that the caller must prevent the target task
         from being deleted.  That shouldn't need saying.
    
     (2) Add a comment indicating the result of __task_cred() should not be passed
         directly to get_cred(), but rather than get_task_cred() should be used
         instead.
    
    Also put a note into the documentation to enforce this point there too.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Jiri Olsa <jolsa@redhat.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index ce40cbc791e2..4d2c39573f36 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -274,13 +274,18 @@ static inline void put_cred(const struct cred *_cred)
  * @task: The task to query
  *
  * Access the objective credentials of a task.  The caller must hold the RCU
- * readlock.
+ * readlock or the task must be dead and unable to change its own credentials.
  *
- * The caller must make sure task doesn't go away, either by holding a ref on
- * task or by holding tasklist_lock to prevent it from being unlinked.
+ * The result of this function should not be passed directly to get_cred();
+ * rather get_task_cred() should be used instead.
  */
-#define __task_cred(task) \
-	((const struct cred *)(rcu_dereference_check((task)->real_cred, rcu_read_lock_held() || lockdep_tasklist_lock_is_held())))
+#define __task_cred(task)						\
+	({								\
+		const struct task_struct *__t = (task);			\
+		rcu_dereference_check(__t->real_cred,			\
+				      rcu_read_lock_held() ||		\
+				      task_is_dead(__t));		\
+	})
 
 /**
  * get_current_cred - Get the current task's subjective credentials

commit de09a9771a5346029f4d11e4ac886be7f9bfdd75
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jul 29 12:45:49 2010 +0100

    CRED: Fix get_task_cred() and task_state() to not resurrect dead credentials
    
    It's possible for get_task_cred() as it currently stands to 'corrupt' a set of
    credentials by incrementing their usage count after their replacement by the
    task being accessed.
    
    What happens is that get_task_cred() can race with commit_creds():
    
            TASK_1                  TASK_2                  RCU_CLEANER
            -->get_task_cred(TASK_2)
            rcu_read_lock()
            __cred = __task_cred(TASK_2)
                                    -->commit_creds()
                                    old_cred = TASK_2->real_cred
                                    TASK_2->real_cred = ...
                                    put_cred(old_cred)
                                      call_rcu(old_cred)
                    [__cred->usage == 0]
            get_cred(__cred)
                    [__cred->usage == 1]
            rcu_read_unlock()
                                                            -->put_cred_rcu()
                                                            [__cred->usage == 1]
                                                            panic()
    
    However, since a tasks credentials are generally not changed very often, we can
    reasonably make use of a loop involving reading the creds pointer and using
    atomic_inc_not_zero() to attempt to increment it if it hasn't already hit zero.
    
    If successful, we can safely return the credentials in the knowledge that, even
    if the task we're accessing has released them, they haven't gone to the RCU
    cleanup code.
    
    We then change task_state() in procfs to use get_task_cred() rather than
    calling get_cred() on the result of __task_cred(), as that suffers from the
    same problem.
    
    Without this change, a BUG_ON in __put_cred() or in put_cred_rcu() can be
    tripped when it is noticed that the usage count is not zero as it ought to be,
    for example:
    
    kernel BUG at kernel/cred.c:168!
    invalid opcode: 0000 [#1] SMP
    last sysfs file: /sys/kernel/mm/ksm/run
    CPU 0
    Pid: 2436, comm: master Not tainted 2.6.33.3-85.fc13.x86_64 #1 0HR330/OptiPlex
    745
    RIP: 0010:[<ffffffff81069881>]  [<ffffffff81069881>] __put_cred+0xc/0x45
    RSP: 0018:ffff88019e7e9eb8  EFLAGS: 00010202
    RAX: 0000000000000001 RBX: ffff880161514480 RCX: 00000000ffffffff
    RDX: 00000000ffffffff RSI: ffff880140c690c0 RDI: ffff880140c690c0
    RBP: ffff88019e7e9eb8 R08: 00000000000000d0 R09: 0000000000000000
    R10: 0000000000000001 R11: 0000000000000040 R12: ffff880140c690c0
    R13: ffff88019e77aea0 R14: 00007fff336b0a5c R15: 0000000000000001
    FS:  00007f12f50d97c0(0000) GS:ffff880007400000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007f8f461bc000 CR3: 00000001b26ce000 CR4: 00000000000006f0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    Process master (pid: 2436, threadinfo ffff88019e7e8000, task ffff88019e77aea0)
    Stack:
     ffff88019e7e9ec8 ffffffff810698cd ffff88019e7e9ef8 ffffffff81069b45
    <0> ffff880161514180 ffff880161514480 ffff880161514180 0000000000000000
    <0> ffff88019e7e9f28 ffffffff8106aace 0000000000000001 0000000000000246
    Call Trace:
     [<ffffffff810698cd>] put_cred+0x13/0x15
     [<ffffffff81069b45>] commit_creds+0x16b/0x175
     [<ffffffff8106aace>] set_current_groups+0x47/0x4e
     [<ffffffff8106ac89>] sys_setgroups+0xf6/0x105
     [<ffffffff81009b02>] system_call_fastpath+0x16/0x1b
    Code: 48 8d 71 ff e8 7e 4e 15 00 85 c0 78 0b 8b 75 ec 48 89 df e8 ef 4a 15 00
    48 83 c4 18 5b c9 c3 55 8b 07 8b 07 48 89 e5 85 c0 74 04 <0f> 0b eb fe 65 48 8b
    04 25 00 cc 00 00 48 3b b8 58 04 00 00 75
    RIP  [<ffffffff81069881>] __put_cred+0xc/0x45
     RSP <ffff88019e7e9eb8>
    ---[ end trace df391256a100ebdd ]---
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Jiri Olsa <jolsa@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 75c0fa881308..ce40cbc791e2 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -153,6 +153,7 @@ struct cred {
 extern void __put_cred(struct cred *);
 extern void exit_creds(struct task_struct *);
 extern int copy_creds(struct task_struct *, unsigned long);
+extern const struct cred *get_task_cred(struct task_struct *);
 extern struct cred *cred_alloc_blank(void);
 extern struct cred *prepare_creds(void);
 extern struct cred *prepare_exec_creds(void);
@@ -281,26 +282,6 @@ static inline void put_cred(const struct cred *_cred)
 #define __task_cred(task) \
 	((const struct cred *)(rcu_dereference_check((task)->real_cred, rcu_read_lock_held() || lockdep_tasklist_lock_is_held())))
 
-/**
- * get_task_cred - Get another task's objective credentials
- * @task: The task to query
- *
- * Get the objective credentials of a task, pinning them so that they can't go
- * away.  Accessing a task's credentials directly is not permitted.
- *
- * The caller must make sure task doesn't go away, either by holding a ref on
- * task or by holding tasklist_lock to prevent it from being unlinked.
- */
-#define get_task_cred(task)				\
-({							\
-	struct cred *__cred;				\
-	rcu_read_lock();				\
-	__cred = (struct cred *) __task_cred((task));	\
-	get_cred(__cred);				\
-	rcu_read_unlock();				\
-	__cred;						\
-})
-
 /**
  * get_current_cred - Get the current task's subjective credentials
  *

commit c70a626d3eba373514c72287c93588b6974a0059
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Wed May 26 14:43:01 2010 -0700

    umh: creds: kill subprocess_info->cred logic
    
    Now that nobody ever changes subprocess_info->cred we can kill this member
    and related code.  ____call_usermodehelper() always runs in the context of
    freshly forked kernel thread, it has the proper ->cred copied from its
    parent kthread, keventd.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 52507c3e1387..75c0fa881308 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -156,7 +156,6 @@ extern int copy_creds(struct task_struct *, unsigned long);
 extern struct cred *cred_alloc_blank(void);
 extern struct cred *prepare_creds(void);
 extern struct cred *prepare_exec_creds(void);
-extern struct cred *prepare_usermodehelper_creds(void);
 extern int commit_creds(struct cred *);
 extern void abort_creds(struct cred *);
 extern const struct cred *override_creds(const struct cred *);

commit db1466b3e1bd1727375cdbfcbea4bcce2f860f61
Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Date:   Wed Mar 3 07:46:56 2010 -0800

    rcu: Use wrapper function instead of exporting tasklist_lock
    
    Lockdep-RCU commit d11c563d exported tasklist_lock, which is not
    a good thing.  This patch instead exports a function that uses
    lockdep to check whether tasklist_lock is held.
    
    Suggested-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: laijs@cn.fujitsu.com
    Cc: dipankar@in.ibm.com
    Cc: mathieu.desnoyers@polymtl.ca
    Cc: josh@joshtriplett.org
    Cc: dvhltc@us.ibm.com
    Cc: niv@us.ibm.com
    Cc: peterz@infradead.org
    Cc: rostedt@goodmis.org
    Cc: Valdis.Kletnieks@vt.edu
    Cc: dhowells@redhat.com
    Cc: Christoph Hellwig <hch@lst.de>
    LKML-Reference: <1267631219-8713-1-git-send-email-paulmck@linux.vnet.ibm.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 4db09f89b637..52507c3e1387 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -280,7 +280,7 @@ static inline void put_cred(const struct cred *_cred)
  * task or by holding tasklist_lock to prevent it from being unlinked.
  */
 #define __task_cred(task) \
-	((const struct cred *)(rcu_dereference_check((task)->real_cred, rcu_read_lock_held() || lockdep_is_held(&tasklist_lock))))
+	((const struct cred *)(rcu_dereference_check((task)->real_cred, rcu_read_lock_held() || lockdep_tasklist_lock_is_held())))
 
 /**
  * get_task_cred - Get another task's objective credentials

commit d11c563dd20ff35da5652c3e1c989d9e10e1d6d0
Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Date:   Mon Feb 22 17:04:50 2010 -0800

    sched: Use lockdep-based checking on rcu_dereference()
    
    Update the rcu_dereference() usages to take advantage of the new
    lockdep-based checking.
    
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: laijs@cn.fujitsu.com
    Cc: dipankar@in.ibm.com
    Cc: mathieu.desnoyers@polymtl.ca
    Cc: josh@joshtriplett.org
    Cc: dvhltc@us.ibm.com
    Cc: niv@us.ibm.com
    Cc: peterz@infradead.org
    Cc: rostedt@goodmis.org
    Cc: Valdis.Kletnieks@vt.edu
    Cc: dhowells@redhat.com
    LKML-Reference: <1266887105-1528-6-git-send-email-paulmck@linux.vnet.ibm.com>
    [ -v2: fix allmodconfig missing symbol export build failure on x86 ]
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 4e3387a89cb9..4db09f89b637 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -280,7 +280,7 @@ static inline void put_cred(const struct cred *_cred)
  * task or by holding tasklist_lock to prevent it from being unlinked.
  */
 #define __task_cred(task) \
-	((const struct cred *)(rcu_dereference((task)->real_cred)))
+	((const struct cred *)(rcu_dereference_check((task)->real_cred, rcu_read_lock_held() || lockdep_is_held(&tasklist_lock))))
 
 /**
  * get_task_cred - Get another task's objective credentials

commit 74908a0009eb36054190ab80deb9671014efed96
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Thu Sep 17 17:47:12 2009 -0700

    include/linux/cred.h: fix build
    
    mips allmodconfig:
    
    include/linux/cred.h: In function `creds_are_invalid':
    include/linux/cred.h:187: error: `PAGE_SIZE' undeclared (first use in this function)
    include/linux/cred.h:187: error: (Each undeclared identifier is reported only once
    include/linux/cred.h:187: error: for each function it appears in.)
    
    Fixes
    
    commit b6dff3ec5e116e3af6f537d4caedcad6b9e5082a
    Author:     David Howells <dhowells@redhat.com>
    AuthorDate: Fri Nov 14 10:39:16 2008 +1100
    Commit:     James Morris <jmorris@namei.org>
    CommitDate: Fri Nov 14 10:39:16 2008 +1100
    
        CRED: Separate task security context from task_struct
    
    I think.
    
    It's way too large to be inlined anyway.
    
    Dunno if this needs an EXPORT_SYMBOL() yet.
    
    Cc: David Howells <dhowells@redhat.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index fb371601a3b4..4e3387a89cb9 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -176,23 +176,7 @@ extern void __invalid_creds(const struct cred *, const char *, unsigned);
 extern void __validate_process_creds(struct task_struct *,
 				     const char *, unsigned);
 
-static inline bool creds_are_invalid(const struct cred *cred)
-{
-	if (cred->magic != CRED_MAGIC)
-		return true;
-	if (atomic_read(&cred->usage) < atomic_read(&cred->subscribers))
-		return true;
-#ifdef CONFIG_SECURITY_SELINUX
-	if (selinux_is_enabled()) {
-		if ((unsigned long) cred->security < PAGE_SIZE)
-			return true;
-		if ((*(u32 *)cred->security & 0xffffff00) ==
-		    (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8))
-			return true;
-	}
-#endif
-	return false;
-}
+extern bool creds_are_invalid(const struct cred *cred);
 
 static inline void __validate_creds(const struct cred *cred,
 				    const char *file, unsigned line)

commit ed868a56988464cd31de0302426a5e94d3127f10
Author: Eric Paris <eparis@redhat.com>
Date:   Sat Sep 12 22:54:10 2009 -0400

    Creds: creds->security can be NULL is selinux is disabled
    
    __validate_process_creds should check if selinux is actually enabled before
    running tests on the selinux portion of the credentials struct.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 24520a539c6f..fb371601a3b4 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -15,6 +15,7 @@
 #include <linux/capability.h>
 #include <linux/init.h>
 #include <linux/key.h>
+#include <linux/selinux.h>
 #include <asm/atomic.h>
 
 struct user_struct;
@@ -182,11 +183,13 @@ static inline bool creds_are_invalid(const struct cred *cred)
 	if (atomic_read(&cred->usage) < atomic_read(&cred->subscribers))
 		return true;
 #ifdef CONFIG_SECURITY_SELINUX
-	if ((unsigned long) cred->security < PAGE_SIZE)
-		return true;
-	if ((*(u32*)cred->security & 0xffffff00) ==
-	    (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8))
-		return true;
+	if (selinux_is_enabled()) {
+		if ((unsigned long) cred->security < PAGE_SIZE)
+			return true;
+		if ((*(u32 *)cred->security & 0xffffff00) ==
+		    (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8))
+			return true;
+	}
 #endif
 	return false;
 }

commit ee18d64c1f632043a02e6f5ba5e045bb26a5465f
Author: David Howells <dhowells@redhat.com>
Date:   Wed Sep 2 09:14:21 2009 +0100

    KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]
    
    Add a keyctl to install a process's session keyring onto its parent.  This
    replaces the parent's session keyring.  Because the COW credential code does
    not permit one process to change another process's credentials directly, the
    change is deferred until userspace next starts executing again.  Normally this
    will be after a wait*() syscall.
    
    To support this, three new security hooks have been provided:
    cred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in
    the blank security creds and key_session_to_parent() - which asks the LSM if
    the process may replace its parent's session keyring.
    
    The replacement may only happen if the process has the same ownership details
    as its parent, and the process has LINK permission on the session keyring, and
    the session keyring is owned by the process, and the LSM permits it.
    
    Note that this requires alteration to each architecture's notify_resume path.
    This has been done for all arches barring blackfin, m68k* and xtensa, all of
    which need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the
    replacement to be performed at the point the parent process resumes userspace
    execution.
    
    This allows the userspace AFS pioctl emulation to fully emulate newpag() and
    the VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to
    alter the parent process's PAG membership.  However, since kAFS doesn't use
    PAGs per se, but rather dumps the keys into the session keyring, the session
    keyring of the parent must be replaced if, for example, VIOCSETTOK is passed
    the newpag flag.
    
    This can be tested with the following program:
    
            #include <stdio.h>
            #include <stdlib.h>
            #include <keyutils.h>
    
            #define KEYCTL_SESSION_TO_PARENT        18
    
            #define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)
    
            int main(int argc, char **argv)
            {
                    key_serial_t keyring, key;
                    long ret;
    
                    keyring = keyctl_join_session_keyring(argv[1]);
                    OSERROR(keyring, "keyctl_join_session_keyring");
    
                    key = add_key("user", "a", "b", 1, keyring);
                    OSERROR(key, "add_key");
    
                    ret = keyctl(KEYCTL_SESSION_TO_PARENT);
                    OSERROR(ret, "KEYCTL_SESSION_TO_PARENT");
    
                    return 0;
            }
    
    Compiled and linked with -lkeyutils, you should see something like:
    
            [dhowells@andromeda ~]$ keyctl show
            Session Keyring
                   -3 --alswrv   4043  4043  keyring: _ses
            355907932 --alswrv   4043    -1   \_ keyring: _uid.4043
            [dhowells@andromeda ~]$ /tmp/newpag
            [dhowells@andromeda ~]$ keyctl show
            Session Keyring
                   -3 --alswrv   4043  4043  keyring: _ses
            1055658746 --alswrv   4043  4043   \_ user: a
            [dhowells@andromeda ~]$ /tmp/newpag hello
            [dhowells@andromeda ~]$ keyctl show
            Session Keyring
                   -3 --alswrv   4043  4043  keyring: hello
            340417692 --alswrv   4043  4043   \_ user: a
    
    Where the test program creates a new session keyring, sticks a user key named
    'a' into it and then installs it on its parent.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 85439abdbc80..24520a539c6f 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -152,6 +152,7 @@ struct cred {
 extern void __put_cred(struct cred *);
 extern void exit_creds(struct task_struct *);
 extern int copy_creds(struct task_struct *, unsigned long);
+extern struct cred *cred_alloc_blank(void);
 extern struct cred *prepare_creds(void);
 extern struct cred *prepare_exec_creds(void);
 extern struct cred *prepare_usermodehelper_creds(void);

commit e0e817392b9acf2c98d3be80c233dddb1b52003d
Author: David Howells <dhowells@redhat.com>
Date:   Wed Sep 2 09:13:40 2009 +0100

    CRED: Add some configurable debugging [try #6]
    
    Add a config option (CONFIG_DEBUG_CREDENTIALS) to turn on some debug checking
    for credential management.  The additional code keeps track of the number of
    pointers from task_structs to any given cred struct, and checks to see that
    this number never exceeds the usage count of the cred struct (which includes
    all references, not just those from task_structs).
    
    Furthermore, if SELinux is enabled, the code also checks that the security
    pointer in the cred struct is never seen to be invalid.
    
    This attempts to catch the bug whereby inode_has_perm() faults in an nfsd
    kernel thread on seeing cred->security be a NULL pointer (it appears that the
    credential struct has been previously released):
    
            http://www.kerneloops.org/oops.php?number=252883
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index b3c76e815d66..85439abdbc80 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -114,6 +114,13 @@ struct thread_group_cred {
  */
 struct cred {
 	atomic_t	usage;
+#ifdef CONFIG_DEBUG_CREDENTIALS
+	atomic_t	subscribers;	/* number of processes subscribed */
+	void		*put_addr;
+	unsigned	magic;
+#define CRED_MAGIC	0x43736564
+#define CRED_MAGIC_DEAD	0x44656144
+#endif
 	uid_t		uid;		/* real UID of the task */
 	gid_t		gid;		/* real GID of the task */
 	uid_t		suid;		/* saved UID of the task */
@@ -143,6 +150,7 @@ struct cred {
 };
 
 extern void __put_cred(struct cred *);
+extern void exit_creds(struct task_struct *);
 extern int copy_creds(struct task_struct *, unsigned long);
 extern struct cred *prepare_creds(void);
 extern struct cred *prepare_exec_creds(void);
@@ -158,6 +166,60 @@ extern int set_security_override_from_ctx(struct cred *, const char *);
 extern int set_create_files_as(struct cred *, struct inode *);
 extern void __init cred_init(void);
 
+/*
+ * check for validity of credentials
+ */
+#ifdef CONFIG_DEBUG_CREDENTIALS
+extern void __invalid_creds(const struct cred *, const char *, unsigned);
+extern void __validate_process_creds(struct task_struct *,
+				     const char *, unsigned);
+
+static inline bool creds_are_invalid(const struct cred *cred)
+{
+	if (cred->magic != CRED_MAGIC)
+		return true;
+	if (atomic_read(&cred->usage) < atomic_read(&cred->subscribers))
+		return true;
+#ifdef CONFIG_SECURITY_SELINUX
+	if ((unsigned long) cred->security < PAGE_SIZE)
+		return true;
+	if ((*(u32*)cred->security & 0xffffff00) ==
+	    (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8))
+		return true;
+#endif
+	return false;
+}
+
+static inline void __validate_creds(const struct cred *cred,
+				    const char *file, unsigned line)
+{
+	if (unlikely(creds_are_invalid(cred)))
+		__invalid_creds(cred, file, line);
+}
+
+#define validate_creds(cred)				\
+do {							\
+	__validate_creds((cred), __FILE__, __LINE__);	\
+} while(0)
+
+#define validate_process_creds()				\
+do {								\
+	__validate_process_creds(current, __FILE__, __LINE__);	\
+} while(0)
+
+extern void validate_creds_for_do_exit(struct task_struct *);
+#else
+static inline void validate_creds(const struct cred *cred)
+{
+}
+static inline void validate_creds_for_do_exit(struct task_struct *tsk)
+{
+}
+static inline void validate_process_creds(void)
+{
+}
+#endif
+
 /**
  * get_new_cred - Get a reference on a new set of credentials
  * @cred: The new credentials to reference
@@ -187,6 +249,7 @@ static inline struct cred *get_new_cred(struct cred *cred)
 static inline const struct cred *get_cred(const struct cred *cred)
 {
 	struct cred *nonconst_cred = (struct cred *) cred;
+	validate_creds(cred);
 	return get_new_cred(nonconst_cred);
 }
 
@@ -205,7 +268,7 @@ static inline void put_cred(const struct cred *_cred)
 {
 	struct cred *cred = (struct cred *) _cred;
 
-	BUG_ON(atomic_read(&(cred)->usage) <= 0);
+	validate_creds(cred);
 	if (atomic_dec_and_test(&(cred)->usage))
 		__put_cred(cred);
 }

commit 1c388ad054fb1ead3dc354b1719570b99e464135
Author: Paul Menage <menage@google.com>
Date:   Fri Jul 17 16:16:18 2009 -0700

    include/linux/cred.h: work around gcc-4.2.4 warning in get_cred()
    
    With gcc 4.2.4 (building UML) I get the warning
    
    include/linux/cred.h: In function 'get_cred':
    include/linux/cred.h:189: warning: passing argument 1 of
    'get_new_cred' discards qualifiers from pointer target type
    
    Inserting an additional local variable appears to keep the compiler happy,
    although it's not clear to me why this should be needed.
    
    Signed-off-by: Paul Menage <menage@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 4fa999696310..b3c76e815d66 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -186,7 +186,8 @@ static inline struct cred *get_new_cred(struct cred *cred)
  */
 static inline const struct cred *get_cred(const struct cred *cred)
 {
-	return get_new_cred((struct cred *) cred);
+	struct cred *nonconst_cred = (struct cred *) cred;
+	return get_new_cred(nonconst_cred);
 }
 
 /**

commit b2e1feaf0af6b8a826b86748a19ddc2013ab7dbd
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Thu May 28 14:34:20 2009 -0700

    cred: #include init.h in cred.h
    
    linux/cred.h can't be included as first header (alphabetical order)
    because it uses __init which is enough to break compilation on some archs.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Acked-by: James Morris <jmorris@namei.org>
    Acked-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 3282ee4318e7..4fa999696310 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -13,6 +13,7 @@
 #define _LINUX_CRED_H
 
 #include <linux/capability.h>
+#include <linux/init.h>
 #include <linux/key.h>
 #include <asm/atomic.h>
 

commit 18b6e0414e42d95183f07d8177e3ff0241abd825
Author: Serge Hallyn <serue@us.ibm.com>
Date:   Wed Oct 15 16:38:45 2008 -0500

    User namespaces: set of cleanups (v2)
    
    The user_ns is moved from nsproxy to user_struct, so that a struct
    cred by itself is sufficient to determine access (which it otherwise
    would not be).  Corresponding ecryptfs fixes (by David Howells) are
    here as well.
    
    Fix refcounting.  The following rules now apply:
            1. The task pins the user struct.
            2. The user struct pins its user namespace.
            3. The user namespace pins the struct user which created it.
    
    User namespaces are cloned during copy_creds().  Unsharing a new user_ns
    is no longer possible.  (We could re-add that, but it'll cause code
    duplication and doesn't seem useful if PAM doesn't need to clone user
    namespaces).
    
    When a user namespace is created, its first user (uid 0) gets empty
    keyrings and a clean group_info.
    
    This incorporates a previous patch by David Howells.  Here
    is his original patch description:
    
    >I suggest adding the attached incremental patch.  It makes the following
    >changes:
    >
    > (1) Provides a current_user_ns() macro to wrap accesses to current's user
    >     namespace.
    >
    > (2) Fixes eCryptFS.
    >
    > (3) Renames create_new_userns() to create_user_ns() to be more consistent
    >     with the other associated functions and because the 'new' in the name is
    >     superfluous.
    >
    > (4) Moves the argument and permission checks made for CLONE_NEWUSER to the
    >     beginning of do_fork() so that they're done prior to making any attempts
    >     at allocation.
    >
    > (5) Calls create_user_ns() after prepare_creds(), and gives it the new creds
    >     to fill in rather than have it return the new root user.  I don't imagine
    >     the new root user being used for anything other than filling in a cred
    >     struct.
    >
    >     This also permits me to get rid of a get_uid() and a free_uid(), as the
    >     reference the creds were holding on the old user_struct can just be
    >     transferred to the new namespace's creator pointer.
    >
    > (6) Makes create_user_ns() reset the UIDs and GIDs of the creds under
    >     preparation rather than doing it in copy_creds().
    >
    >David
    
    >Signed-off-by: David Howells <dhowells@redhat.com>
    
    Changelog:
            Oct 20: integrate dhowells comments
                    1. leave thread_keyring alone
                    2. use current_user_ns() in set_user()
    
    Signed-off-by: Serge Hallyn <serue@us.ibm.com>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 26c1ab179946..3282ee4318e7 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -60,6 +60,7 @@ do {							\
 } while (0)
 
 extern struct group_info *groups_alloc(int);
+extern struct group_info init_groups;
 extern void groups_free(struct group_info *);
 extern int set_current_groups(struct group_info *);
 extern int set_groups(struct cred *, struct group_info *);
@@ -315,6 +316,7 @@ static inline void put_cred(const struct cred *_cred)
 #define current_fsgid() 	(current_cred_xxx(fsgid))
 #define current_cap()		(current_cred_xxx(cap_effective))
 #define current_user()		(current_cred_xxx(user))
+#define current_user_ns()	(current_cred_xxx(user)->user_ns)
 #define current_security()	(current_cred_xxx(security))
 
 #define current_uid_gid(_uid, _gid)		\

commit 3a3b7ce9336952ea7b9564d976d068a238976c9d
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:28 2008 +1100

    CRED: Allow kernel services to override LSM settings for task actions
    
    Allow kernel services to override LSM settings appropriate to the actions
    performed by a task by duplicating a set of credentials, modifying it and then
    using task_struct::cred to point to it when performing operations on behalf of
    a task.
    
    This is used, for example, by CacheFiles which has to transparently access the
    cache on behalf of a process that thinks it is doing, say, NFS accesses with a
    potentially inappropriate (with respect to accessing the cache) set of
    credentials.
    
    This patch provides two LSM hooks for modifying a task security record:
    
     (*) security_kernel_act_as() which allows modification of the security datum
         with which a task acts on other objects (most notably files).
    
     (*) security_kernel_create_files_as() which allows modification of the
         security datum that is used to initialise the security data on a file that
         a task creates.
    
    The patch also provides four new credentials handling functions, which wrap the
    LSM functions:
    
     (1) prepare_kernel_cred()
    
         Prepare a set of credentials for a kernel service to use, based either on
         a daemon's credentials or on init_cred.  All the keyrings are cleared.
    
     (2) set_security_override()
    
         Set the LSM security ID in a set of credentials to a specific security
         context, assuming permission from the LSM policy.
    
     (3) set_security_override_from_ctx()
    
         As (2), but takes the security context as a string.
    
     (4) set_create_files_as()
    
         Set the file creation LSM security ID in a set of credentials to be the
         same as that on a particular inode.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com> [Smack changes]
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 55a9c995d694..26c1ab179946 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -18,6 +18,7 @@
 
 struct user_struct;
 struct cred;
+struct inode;
 
 /*
  * COW Supplementary groups list
@@ -148,6 +149,11 @@ extern int commit_creds(struct cred *);
 extern void abort_creds(struct cred *);
 extern const struct cred *override_creds(const struct cred *);
 extern void revert_creds(const struct cred *);
+extern struct cred *prepare_kernel_cred(struct task_struct *);
+extern int change_create_files_as(struct cred *, struct inode *);
+extern int set_security_override(struct cred *, u32);
+extern int set_security_override_from_ctx(struct cred *, const char *);
+extern int set_create_files_as(struct cred *, struct inode *);
 extern void __init cred_init(void);
 
 /**

commit 3b11a1decef07c19443d24ae926982bc8ec9f4c0
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:26 2008 +1100

    CRED: Differentiate objective and effective subjective credentials on a task
    
    Differentiate the objective and real subjective credentials from the effective
    subjective credentials on a task by introducing a second credentials pointer
    into the task_struct.
    
    task_struct::real_cred then refers to the objective and apparent real
    subjective credentials of a task, as perceived by the other tasks in the
    system.
    
    task_struct::cred then refers to the effective subjective credentials of a
    task, as used by that task when it's actually running.  These are not visible
    to the other tasks in the system.
    
    __task_cred(task) then refers to the objective/real credentials of the task in
    question.
    
    current_cred() refers to the effective subjective credentials of the current
    task.
    
    prepare_creds() uses the objective creds as a base and commit_creds() changes
    both pointers in the task_struct (indeed commit_creds() requires them to be the
    same).
    
    override_creds() and revert_creds() change the subjective creds pointer only,
    and the former returns the old subjective creds.  These are used by NFSD,
    faccessat() and do_coredump(), and will by used by CacheFiles.
    
    In SELinux, current_has_perm() is provided as an alternative to
    task_has_perm().  This uses the effective subjective context of current,
    whereas task_has_perm() uses the objective/real context of the subject.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 794aab5c66e5..55a9c995d694 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -146,8 +146,8 @@ extern struct cred *prepare_exec_creds(void);
 extern struct cred *prepare_usermodehelper_creds(void);
 extern int commit_creds(struct cred *);
 extern void abort_creds(struct cred *);
-extern const struct cred *override_creds(const struct cred *) __deprecated;
-extern void revert_creds(const struct cred *) __deprecated;
+extern const struct cred *override_creds(const struct cred *);
+extern void revert_creds(const struct cred *);
 extern void __init cred_init(void);
 
 /**
@@ -202,32 +202,32 @@ static inline void put_cred(const struct cred *_cred)
 }
 
 /**
- * current_cred - Access the current task's credentials
+ * current_cred - Access the current task's subjective credentials
  *
- * Access the credentials of the current task.
+ * Access the subjective credentials of the current task.
  */
 #define current_cred() \
 	(current->cred)
 
 /**
- * __task_cred - Access another task's credentials
+ * __task_cred - Access a task's objective credentials
  * @task: The task to query
  *
- * Access the credentials of another task.  The caller must hold the
- * RCU readlock.
+ * Access the objective credentials of a task.  The caller must hold the RCU
+ * readlock.
  *
  * The caller must make sure task doesn't go away, either by holding a ref on
  * task or by holding tasklist_lock to prevent it from being unlinked.
  */
 #define __task_cred(task) \
-	((const struct cred *)(rcu_dereference((task)->cred)))
+	((const struct cred *)(rcu_dereference((task)->real_cred)))
 
 /**
- * get_task_cred - Get another task's credentials
+ * get_task_cred - Get another task's objective credentials
  * @task: The task to query
  *
- * Get the credentials of a task, pinning them so that they can't go away.
- * Accessing a task's credentials directly is not permitted.
+ * Get the objective credentials of a task, pinning them so that they can't go
+ * away.  Accessing a task's credentials directly is not permitted.
  *
  * The caller must make sure task doesn't go away, either by holding a ref on
  * task or by holding tasklist_lock to prevent it from being unlinked.
@@ -243,10 +243,11 @@ static inline void put_cred(const struct cred *_cred)
 })
 
 /**
- * get_current_cred - Get the current task's credentials
+ * get_current_cred - Get the current task's subjective credentials
  *
- * Get the credentials of the current task, pinning them so that they can't go
- * away.  Accessing the current task's credentials directly is not permitted.
+ * Get the subjective credentials of the current task, pinning them so that
+ * they can't go away.  Accessing the current task's credentials directly is
+ * not permitted.
  */
 #define get_current_cred()				\
 	(get_cred(current_cred()))

commit 98870ab0a5a3f1822aee681d2997017e1c87d026
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:26 2008 +1100

    CRED: Documentation
    
    Document credentials and the new credentials API.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 8edb4d1d5427..794aab5c66e5 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -1,4 +1,4 @@
-/* Credentials management
+/* Credentials management - see Documentation/credentials.txt
  *
  * Copyright (C) 2008 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
@@ -169,6 +169,12 @@ static inline struct cred *get_new_cred(struct cred *cred)
  *
  * Get a reference on the specified set of credentials.  The caller must
  * release the reference.
+ *
+ * This is used to deal with a committed set of credentials.  Although the
+ * pointer is const, this will temporarily discard the const and increment the
+ * usage count.  The purpose of this is to attempt to catch at compile time the
+ * accidental alteration of a set of credentials that should be considered
+ * immutable.
  */
 static inline const struct cred *get_cred(const struct cred *cred)
 {
@@ -181,6 +187,10 @@ static inline const struct cred *get_cred(const struct cred *cred)
  *
  * Release a reference to a set of credentials, deleting them when the last ref
  * is released.
+ *
+ * This takes a const pointer to a set of credentials because the credentials
+ * on task_struct are attached by const pointers to prevent accidental
+ * alteration of otherwise immutable credential sets.
  */
 static inline void put_cred(const struct cred *_cred)
 {

commit a6f76f23d297f70e2a6b3ec607f7aeeea9e37e8d
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:24 2008 +1100

    CRED: Make execve() take advantage of copy-on-write credentials
    
    Make execve() take advantage of copy-on-write credentials, allowing it to set
    up the credentials in advance, and then commit the whole lot after the point
    of no return.
    
    This patch and the preceding patches have been tested with the LTP SELinux
    testsuite.
    
    This patch makes several logical sets of alteration:
    
     (1) execve().
    
         The credential bits from struct linux_binprm are, for the most part,
         replaced with a single credentials pointer (bprm->cred).  This means that
         all the creds can be calculated in advance and then applied at the point
         of no return with no possibility of failure.
    
         I would like to replace bprm->cap_effective with:
    
            cap_isclear(bprm->cap_effective)
    
         but this seems impossible due to special behaviour for processes of pid 1
         (they always retain their parent's capability masks where normally they'd
         be changed - see cap_bprm_set_creds()).
    
         The following sequence of events now happens:
    
         (a) At the start of do_execve, the current task's cred_exec_mutex is
             locked to prevent PTRACE_ATTACH from obsoleting the calculation of
             creds that we make.
    
         (a) prepare_exec_creds() is then called to make a copy of the current
             task's credentials and prepare it.  This copy is then assigned to
             bprm->cred.
    
             This renders security_bprm_alloc() and security_bprm_free()
             unnecessary, and so they've been removed.
    
         (b) The determination of unsafe execution is now performed immediately
             after (a) rather than later on in the code.  The result is stored in
             bprm->unsafe for future reference.
    
         (c) prepare_binprm() is called, possibly multiple times.
    
             (i) This applies the result of set[ug]id binaries to the new creds
                 attached to bprm->cred.  Personality bit clearance is recorded,
                 but now deferred on the basis that the exec procedure may yet
                 fail.
    
             (ii) This then calls the new security_bprm_set_creds().  This should
                 calculate the new LSM and capability credentials into *bprm->cred.
    
                 This folds together security_bprm_set() and parts of
                 security_bprm_apply_creds() (these two have been removed).
                 Anything that might fail must be done at this point.
    
             (iii) bprm->cred_prepared is set to 1.
    
                 bprm->cred_prepared is 0 on the first pass of the security
                 calculations, and 1 on all subsequent passes.  This allows SELinux
                 in (ii) to base its calculations only on the initial script and
                 not on the interpreter.
    
         (d) flush_old_exec() is called to commit the task to execution.  This
             performs the following steps with regard to credentials:
    
             (i) Clear pdeath_signal and set dumpable on certain circumstances that
                 may not be covered by commit_creds().
    
             (ii) Clear any bits in current->personality that were deferred from
                 (c.i).
    
         (e) install_exec_creds() [compute_creds() as was] is called to install the
             new credentials.  This performs the following steps with regard to
             credentials:
    
             (i) Calls security_bprm_committing_creds() to apply any security
                 requirements, such as flushing unauthorised files in SELinux, that
                 must be done before the credentials are changed.
    
                 This is made up of bits of security_bprm_apply_creds() and
                 security_bprm_post_apply_creds(), both of which have been removed.
                 This function is not allowed to fail; anything that might fail
                 must have been done in (c.ii).
    
             (ii) Calls commit_creds() to apply the new credentials in a single
                 assignment (more or less).  Possibly pdeath_signal and dumpable
                 should be part of struct creds.
    
             (iii) Unlocks the task's cred_replace_mutex, thus allowing
                 PTRACE_ATTACH to take place.
    
             (iv) Clears The bprm->cred pointer as the credentials it was holding
                 are now immutable.
    
             (v) Calls security_bprm_committed_creds() to apply any security
                 alterations that must be done after the creds have been changed.
                 SELinux uses this to flush signals and signal handlers.
    
         (f) If an error occurs before (d.i), bprm_free() will call abort_creds()
             to destroy the proposed new credentials and will then unlock
             cred_replace_mutex.  No changes to the credentials will have been
             made.
    
     (2) LSM interface.
    
         A number of functions have been changed, added or removed:
    
         (*) security_bprm_alloc(), ->bprm_alloc_security()
         (*) security_bprm_free(), ->bprm_free_security()
    
             Removed in favour of preparing new credentials and modifying those.
    
         (*) security_bprm_apply_creds(), ->bprm_apply_creds()
         (*) security_bprm_post_apply_creds(), ->bprm_post_apply_creds()
    
             Removed; split between security_bprm_set_creds(),
             security_bprm_committing_creds() and security_bprm_committed_creds().
    
         (*) security_bprm_set(), ->bprm_set_security()
    
             Removed; folded into security_bprm_set_creds().
    
         (*) security_bprm_set_creds(), ->bprm_set_creds()
    
             New.  The new credentials in bprm->creds should be checked and set up
             as appropriate.  bprm->cred_prepared is 0 on the first call, 1 on the
             second and subsequent calls.
    
         (*) security_bprm_committing_creds(), ->bprm_committing_creds()
         (*) security_bprm_committed_creds(), ->bprm_committed_creds()
    
             New.  Apply the security effects of the new credentials.  This
             includes closing unauthorised files in SELinux.  This function may not
             fail.  When the former is called, the creds haven't yet been applied
             to the process; when the latter is called, they have.
    
             The former may access bprm->cred, the latter may not.
    
     (3) SELinux.
    
         SELinux has a number of changes, in addition to those to support the LSM
         interface changes mentioned above:
    
         (a) The bprm_security_struct struct has been removed in favour of using
             the credentials-under-construction approach.
    
         (c) flush_unauthorized_files() now takes a cred pointer and passes it on
             to inode_has_perm(), file_has_perm() and dentry_open().
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: James Morris <jmorris@namei.org>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index eaf6fa695a04..8edb4d1d5427 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -84,8 +84,6 @@ struct thread_group_cred {
 	struct key	*process_keyring;	/* keyring private to this process */
 	struct rcu_head	rcu;			/* RCU deletion hook */
 };
-
-extern void release_tgcred(struct cred *cred);
 #endif
 
 /*
@@ -144,6 +142,7 @@ struct cred {
 extern void __put_cred(struct cred *);
 extern int copy_creds(struct task_struct *, unsigned long);
 extern struct cred *prepare_creds(void);
+extern struct cred *prepare_exec_creds(void);
 extern struct cred *prepare_usermodehelper_creds(void);
 extern int commit_creds(struct cred *);
 extern void abort_creds(struct cred *);

commit d84f4f992cbd76e8f39c488cf0c5d123843923b1
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:23 2008 +1100

    CRED: Inaugurate COW credentials
    
    Inaugurate copy-on-write credentials management.  This uses RCU to manage the
    credentials pointer in the task_struct with respect to accesses by other tasks.
    A process may only modify its own credentials, and so does not need locking to
    access or modify its own credentials.
    
    A mutex (cred_replace_mutex) is added to the task_struct to control the effect
    of PTRACE_ATTACHED on credential calculations, particularly with respect to
    execve().
    
    With this patch, the contents of an active credentials struct may not be
    changed directly; rather a new set of credentials must be prepared, modified
    and committed using something like the following sequence of events:
    
            struct cred *new = prepare_creds();
            int ret = blah(new);
            if (ret < 0) {
                    abort_creds(new);
                    return ret;
            }
            return commit_creds(new);
    
    There are some exceptions to this rule: the keyrings pointed to by the active
    credentials may be instantiated - keyrings violate the COW rule as managing
    COW keyrings is tricky, given that it is possible for a task to directly alter
    the keys in a keyring in use by another task.
    
    To help enforce this, various pointers to sets of credentials, such as those in
    the task_struct, are declared const.  The purpose of this is compile-time
    discouragement of altering credentials through those pointers.  Once a set of
    credentials has been made public through one of these pointers, it may not be
    modified, except under special circumstances:
    
      (1) Its reference count may incremented and decremented.
    
      (2) The keyrings to which it points may be modified, but not replaced.
    
    The only safe way to modify anything else is to create a replacement and commit
    using the functions described in Documentation/credentials.txt (which will be
    added by a later patch).
    
    This patch and the preceding patches have been tested with the LTP SELinux
    testsuite.
    
    This patch makes several logical sets of alteration:
    
     (1) execve().
    
         This now prepares and commits credentials in various places in the
         security code rather than altering the current creds directly.
    
     (2) Temporary credential overrides.
    
         do_coredump() and sys_faccessat() now prepare their own credentials and
         temporarily override the ones currently on the acting thread, whilst
         preventing interference from other threads by holding cred_replace_mutex
         on the thread being dumped.
    
         This will be replaced in a future patch by something that hands down the
         credentials directly to the functions being called, rather than altering
         the task's objective credentials.
    
     (3) LSM interface.
    
         A number of functions have been changed, added or removed:
    
         (*) security_capset_check(), ->capset_check()
         (*) security_capset_set(), ->capset_set()
    
             Removed in favour of security_capset().
    
         (*) security_capset(), ->capset()
    
             New.  This is passed a pointer to the new creds, a pointer to the old
             creds and the proposed capability sets.  It should fill in the new
             creds or return an error.  All pointers, barring the pointer to the
             new creds, are now const.
    
         (*) security_bprm_apply_creds(), ->bprm_apply_creds()
    
             Changed; now returns a value, which will cause the process to be
             killed if it's an error.
    
         (*) security_task_alloc(), ->task_alloc_security()
    
             Removed in favour of security_prepare_creds().
    
         (*) security_cred_free(), ->cred_free()
    
             New.  Free security data attached to cred->security.
    
         (*) security_prepare_creds(), ->cred_prepare()
    
             New. Duplicate any security data attached to cred->security.
    
         (*) security_commit_creds(), ->cred_commit()
    
             New. Apply any security effects for the upcoming installation of new
             security by commit_creds().
    
         (*) security_task_post_setuid(), ->task_post_setuid()
    
             Removed in favour of security_task_fix_setuid().
    
         (*) security_task_fix_setuid(), ->task_fix_setuid()
    
             Fix up the proposed new credentials for setuid().  This is used by
             cap_set_fix_setuid() to implicitly adjust capabilities in line with
             setuid() changes.  Changes are made to the new credentials, rather
             than the task itself as in security_task_post_setuid().
    
         (*) security_task_reparent_to_init(), ->task_reparent_to_init()
    
             Removed.  Instead the task being reparented to init is referred
             directly to init's credentials.
    
             NOTE!  This results in the loss of some state: SELinux's osid no
             longer records the sid of the thread that forked it.
    
         (*) security_key_alloc(), ->key_alloc()
         (*) security_key_permission(), ->key_permission()
    
             Changed.  These now take cred pointers rather than task pointers to
             refer to the security context.
    
     (4) sys_capset().
    
         This has been simplified and uses less locking.  The LSM functions it
         calls have been merged.
    
     (5) reparent_to_kthreadd().
    
         This gives the current thread the same credentials as init by simply using
         commit_thread() to point that way.
    
     (6) __sigqueue_alloc() and switch_uid()
    
         __sigqueue_alloc() can't stop the target task from changing its creds
         beneath it, so this function gets a reference to the currently applicable
         user_struct which it then passes into the sigqueue struct it returns if
         successful.
    
         switch_uid() is now called from commit_creds(), and possibly should be
         folded into that.  commit_creds() should take care of protecting
         __sigqueue_alloc().
    
     (7) [sg]et[ug]id() and co and [sg]et_current_groups.
    
         The set functions now all use prepare_creds(), commit_creds() and
         abort_creds() to build and check a new set of credentials before applying
         it.
    
         security_task_set[ug]id() is called inside the prepared section.  This
         guarantees that nothing else will affect the creds until we've finished.
    
         The calling of set_dumpable() has been moved into commit_creds().
    
         Much of the functionality of set_user() has been moved into
         commit_creds().
    
         The get functions all simply access the data directly.
    
     (8) security_task_prctl() and cap_task_prctl().
    
         security_task_prctl() has been modified to return -ENOSYS if it doesn't
         want to handle a function, or otherwise return the return value directly
         rather than through an argument.
    
         Additionally, cap_task_prctl() now prepares a new set of credentials, even
         if it doesn't end up using it.
    
     (9) Keyrings.
    
         A number of changes have been made to the keyrings code:
    
         (a) switch_uid_keyring(), copy_keys(), exit_keys() and suid_keys() have
             all been dropped and built in to the credentials functions directly.
             They may want separating out again later.
    
         (b) key_alloc() and search_process_keyrings() now take a cred pointer
             rather than a task pointer to specify the security context.
    
         (c) copy_creds() gives a new thread within the same thread group a new
             thread keyring if its parent had one, otherwise it discards the thread
             keyring.
    
         (d) The authorisation key now points directly to the credentials to extend
             the search into rather pointing to the task that carries them.
    
         (e) Installing thread, process or session keyrings causes a new set of
             credentials to be created, even though it's not strictly necessary for
             process or session keyrings (they're shared).
    
    (10) Usermode helper.
    
         The usermode helper code now carries a cred struct pointer in its
         subprocess_info struct instead of a new session keyring pointer.  This set
         of credentials is derived from init_cred and installed on the new process
         after it has been cloned.
    
         call_usermodehelper_setup() allocates the new credentials and
         call_usermodehelper_freeinfo() discards them if they haven't been used.  A
         special cred function (prepare_usermodeinfo_creds()) is provided
         specifically for call_usermodehelper_setup() to call.
    
         call_usermodehelper_setkeys() adjusts the credentials to sport the
         supplied keyring as the new session keyring.
    
    (11) SELinux.
    
         SELinux has a number of changes, in addition to those to support the LSM
         interface changes mentioned above:
    
         (a) selinux_setprocattr() no longer does its check for whether the
             current ptracer can access processes with the new SID inside the lock
             that covers getting the ptracer's SID.  Whilst this lock ensures that
             the check is done with the ptracer pinned, the result is only valid
             until the lock is released, so there's no point doing it inside the
             lock.
    
    (12) is_single_threaded().
    
         This function has been extracted from selinux_setprocattr() and put into
         a file of its own in the lib/ directory as join_session_keyring() now
         wants to use it too.
    
         The code in SELinux just checked to see whether a task shared mm_structs
         with other tasks (CLONE_VM), but that isn't good enough.  We really want
         to know if they're part of the same thread group (CLONE_THREAD).
    
    (13) nfsd.
    
         The NFS server daemon now has to use the COW credentials to set the
         credentials it is going to use.  It really needs to pass the credentials
         down to the functions it calls, but it can't do that until other patches
         in this series have been applied.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: James Morris <jmorris@namei.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 62b9e532422d..eaf6fa695a04 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -84,6 +84,8 @@ struct thread_group_cred {
 	struct key	*process_keyring;	/* keyring private to this process */
 	struct rcu_head	rcu;			/* RCU deletion hook */
 };
+
+extern void release_tgcred(struct cred *cred);
 #endif
 
 /*
@@ -137,11 +139,30 @@ struct cred {
 	struct user_struct *user;	/* real user ID subscription */
 	struct group_info *group_info;	/* supplementary groups for euid/fsgid */
 	struct rcu_head	rcu;		/* RCU deletion hook */
-	spinlock_t	lock;		/* lock for pointer changes */
 };
 
 extern void __put_cred(struct cred *);
 extern int copy_creds(struct task_struct *, unsigned long);
+extern struct cred *prepare_creds(void);
+extern struct cred *prepare_usermodehelper_creds(void);
+extern int commit_creds(struct cred *);
+extern void abort_creds(struct cred *);
+extern const struct cred *override_creds(const struct cred *) __deprecated;
+extern void revert_creds(const struct cred *) __deprecated;
+extern void __init cred_init(void);
+
+/**
+ * get_new_cred - Get a reference on a new set of credentials
+ * @cred: The new credentials to reference
+ *
+ * Get a reference on the specified set of new credentials.  The caller must
+ * release the reference.
+ */
+static inline struct cred *get_new_cred(struct cred *cred)
+{
+	atomic_inc(&cred->usage);
+	return cred;
+}
 
 /**
  * get_cred - Get a reference on a set of credentials
@@ -150,10 +171,9 @@ extern int copy_creds(struct task_struct *, unsigned long);
  * Get a reference on the specified set of credentials.  The caller must
  * release the reference.
  */
-static inline struct cred *get_cred(struct cred *cred)
+static inline const struct cred *get_cred(const struct cred *cred)
 {
-	atomic_inc(&cred->usage);
-	return cred;
+	return get_new_cred((struct cred *) cred);
 }
 
 /**
@@ -166,6 +186,8 @@ static inline struct cred *get_cred(struct cred *cred)
 static inline void put_cred(const struct cred *_cred)
 {
 	struct cred *cred = (struct cred *) _cred;
+
+	BUG_ON(atomic_read(&(cred)->usage) <= 0);
 	if (atomic_dec_and_test(&(cred)->usage))
 		__put_cred(cred);
 }
@@ -250,13 +272,13 @@ static inline void put_cred(const struct cred *_cred)
 	__groups;					\
 })
 
-#define task_cred_xxx(task, xxx)		\
-({						\
-	__typeof__(task->cred->xxx) ___val;	\
-	rcu_read_lock();			\
-	___val = __task_cred((task))->xxx;	\
-	rcu_read_unlock();			\
-	___val;					\
+#define task_cred_xxx(task, xxx)			\
+({							\
+	__typeof__(((struct cred *)NULL)->xxx) ___val;	\
+	rcu_read_lock();				\
+	___val = __task_cred((task))->xxx;		\
+	rcu_read_unlock();				\
+	___val;						\
 })
 
 #define task_uid(task)		(task_cred_xxx((task), uid))

commit bb952bb98a7e479262c7eb25d5592545a3af147d
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:20 2008 +1100

    CRED: Separate per-task-group keyrings from signal_struct
    
    Separate per-task-group keyrings from signal_struct and dangle their anchor
    from the cred struct rather than the signal_struct.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: James Morris <jmorris@namei.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 166ce4ddba64..62b9e532422d 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -71,6 +71,21 @@ extern int groups_search(const struct group_info *, gid_t);
 extern int in_group_p(gid_t);
 extern int in_egroup_p(gid_t);
 
+/*
+ * The common credentials for a thread group
+ * - shared by CLONE_THREAD
+ */
+#ifdef CONFIG_KEYS
+struct thread_group_cred {
+	atomic_t	usage;
+	pid_t		tgid;			/* thread group process ID */
+	spinlock_t	lock;
+	struct key	*session_keyring;	/* keyring inherited over fork */
+	struct key	*process_keyring;	/* keyring private to this process */
+	struct rcu_head	rcu;			/* RCU deletion hook */
+};
+#endif
+
 /*
  * The security context of a task
  *
@@ -114,6 +129,7 @@ struct cred {
 					 * keys to */
 	struct key	*thread_keyring; /* keyring private to this thread */
 	struct key	*request_key_auth; /* assumed request_key authority */
+	struct thread_group_cred *tgcred; /* thread-group shared credentials */
 #endif
 #ifdef CONFIG_SECURITY
 	void		*security;	/* subjective LSM security */

commit c69e8d9c01db2adc503464993c358901c9af9de4
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:19 2008 +1100

    CRED: Use RCU to access another task's creds and to release a task's own creds
    
    Use RCU to access another task's creds and to release a task's own creds.
    This means that it will be possible for the credentials of a task to be
    replaced without another task (a) requiring a full lock to read them, and (b)
    seeing deallocated memory.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: James Morris <jmorris@namei.org>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 4221ec6000c1..166ce4ddba64 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -147,8 +147,9 @@ static inline struct cred *get_cred(struct cred *cred)
  * Release a reference to a set of credentials, deleting them when the last ref
  * is released.
  */
-static inline void put_cred(struct cred *cred)
+static inline void put_cred(const struct cred *_cred)
 {
+	struct cred *cred = (struct cred *) _cred;
 	if (atomic_dec_and_test(&(cred)->usage))
 		__put_cred(cred);
 }

commit 86a264abe542cfececb4df129bc45a0338d8cdb9
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:18 2008 +1100

    CRED: Wrap current->cred and a few other accessors
    
    Wrap current->cred and a few other accessors to hide their actual
    implementation.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: James Morris <jmorris@namei.org>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index a7a686074cb0..4221ec6000c1 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -37,15 +37,16 @@ struct group_info {
  * get_group_info - Get a reference to a group info structure
  * @group_info: The group info to reference
  *
- * This must be called with the owning task locked (via task_lock()) when task
- * != current.  The reason being that the vast majority of callers are looking
- * at current->group_info, which can not be changed except by the current task.
- * Changing current->group_info requires the task lock, too.
+ * This gets a reference to a set of supplementary groups.
+ *
+ * If the caller is accessing a task's credentials, they must hold the RCU read
+ * lock when reading.
  */
-#define get_group_info(group_info)		\
-do {						\
-	atomic_inc(&(group_info)->usage);	\
-} while (0)
+static inline struct group_info *get_group_info(struct group_info *gi)
+{
+	atomic_inc(&gi->usage);
+	return gi;
+}
 
 /**
  * put_group_info - Release a reference to a group info structure
@@ -61,7 +62,7 @@ extern struct group_info *groups_alloc(int);
 extern void groups_free(struct group_info *);
 extern int set_current_groups(struct group_info *);
 extern int set_groups(struct cred *, struct group_info *);
-extern int groups_search(struct group_info *, gid_t);
+extern int groups_search(const struct group_info *, gid_t);
 
 /* access the groups "array" with this macro */
 #define GROUP_AT(gi, i) \
@@ -123,41 +124,6 @@ struct cred {
 	spinlock_t	lock;		/* lock for pointer changes */
 };
 
-#define get_current_user()	(get_uid(current->cred->user))
-
-#define task_uid(task)		((task)->cred->uid)
-#define task_gid(task)		((task)->cred->gid)
-#define task_euid(task)		((task)->cred->euid)
-#define task_egid(task)		((task)->cred->egid)
-
-#define current_uid()		(current->cred->uid)
-#define current_gid()		(current->cred->gid)
-#define current_euid()		(current->cred->euid)
-#define current_egid()		(current->cred->egid)
-#define current_suid()		(current->cred->suid)
-#define current_sgid()		(current->cred->sgid)
-#define current_fsuid()		(current->cred->fsuid)
-#define current_fsgid()		(current->cred->fsgid)
-#define current_cap()		(current->cred->cap_effective)
-
-#define current_uid_gid(_uid, _gid)		\
-do {						\
-	*(_uid) = current->cred->uid;		\
-	*(_gid) = current->cred->gid;		\
-} while(0)
-
-#define current_euid_egid(_uid, _gid)		\
-do {						\
-	*(_uid) = current->cred->euid;		\
-	*(_gid) = current->cred->egid;		\
-} while(0)
-
-#define current_fsuid_fsgid(_uid, _gid)		\
-do {						\
-	*(_uid) = current->cred->fsuid;		\
-	*(_gid) = current->cred->fsgid;		\
-} while(0)
-
 extern void __put_cred(struct cred *);
 extern int copy_creds(struct task_struct *, unsigned long);
 
@@ -187,4 +153,137 @@ static inline void put_cred(struct cred *cred)
 		__put_cred(cred);
 }
 
+/**
+ * current_cred - Access the current task's credentials
+ *
+ * Access the credentials of the current task.
+ */
+#define current_cred() \
+	(current->cred)
+
+/**
+ * __task_cred - Access another task's credentials
+ * @task: The task to query
+ *
+ * Access the credentials of another task.  The caller must hold the
+ * RCU readlock.
+ *
+ * The caller must make sure task doesn't go away, either by holding a ref on
+ * task or by holding tasklist_lock to prevent it from being unlinked.
+ */
+#define __task_cred(task) \
+	((const struct cred *)(rcu_dereference((task)->cred)))
+
+/**
+ * get_task_cred - Get another task's credentials
+ * @task: The task to query
+ *
+ * Get the credentials of a task, pinning them so that they can't go away.
+ * Accessing a task's credentials directly is not permitted.
+ *
+ * The caller must make sure task doesn't go away, either by holding a ref on
+ * task or by holding tasklist_lock to prevent it from being unlinked.
+ */
+#define get_task_cred(task)				\
+({							\
+	struct cred *__cred;				\
+	rcu_read_lock();				\
+	__cred = (struct cred *) __task_cred((task));	\
+	get_cred(__cred);				\
+	rcu_read_unlock();				\
+	__cred;						\
+})
+
+/**
+ * get_current_cred - Get the current task's credentials
+ *
+ * Get the credentials of the current task, pinning them so that they can't go
+ * away.  Accessing the current task's credentials directly is not permitted.
+ */
+#define get_current_cred()				\
+	(get_cred(current_cred()))
+
+/**
+ * get_current_user - Get the current task's user_struct
+ *
+ * Get the user record of the current task, pinning it so that it can't go
+ * away.
+ */
+#define get_current_user()				\
+({							\
+	struct user_struct *__u;			\
+	struct cred *__cred;				\
+	__cred = (struct cred *) current_cred();	\
+	__u = get_uid(__cred->user);			\
+	__u;						\
+})
+
+/**
+ * get_current_groups - Get the current task's supplementary group list
+ *
+ * Get the supplementary group list of the current task, pinning it so that it
+ * can't go away.
+ */
+#define get_current_groups()				\
+({							\
+	struct group_info *__groups;			\
+	struct cred *__cred;				\
+	__cred = (struct cred *) current_cred();	\
+	__groups = get_group_info(__cred->group_info);	\
+	__groups;					\
+})
+
+#define task_cred_xxx(task, xxx)		\
+({						\
+	__typeof__(task->cred->xxx) ___val;	\
+	rcu_read_lock();			\
+	___val = __task_cred((task))->xxx;	\
+	rcu_read_unlock();			\
+	___val;					\
+})
+
+#define task_uid(task)		(task_cred_xxx((task), uid))
+#define task_euid(task)		(task_cred_xxx((task), euid))
+
+#define current_cred_xxx(xxx)			\
+({						\
+	current->cred->xxx;			\
+})
+
+#define current_uid()		(current_cred_xxx(uid))
+#define current_gid()		(current_cred_xxx(gid))
+#define current_euid()		(current_cred_xxx(euid))
+#define current_egid()		(current_cred_xxx(egid))
+#define current_suid()		(current_cred_xxx(suid))
+#define current_sgid()		(current_cred_xxx(sgid))
+#define current_fsuid() 	(current_cred_xxx(fsuid))
+#define current_fsgid() 	(current_cred_xxx(fsgid))
+#define current_cap()		(current_cred_xxx(cap_effective))
+#define current_user()		(current_cred_xxx(user))
+#define current_security()	(current_cred_xxx(security))
+
+#define current_uid_gid(_uid, _gid)		\
+do {						\
+	const struct cred *__cred;		\
+	__cred = current_cred();		\
+	*(_uid) = __cred->uid;			\
+	*(_gid) = __cred->gid;			\
+} while(0)
+
+#define current_euid_egid(_euid, _egid)		\
+do {						\
+	const struct cred *__cred;		\
+	__cred = current_cred();		\
+	*(_euid) = __cred->euid;		\
+	*(_egid) = __cred->egid;		\
+} while(0)
+
+#define current_fsuid_fsgid(_fsuid, _fsgid)	\
+do {						\
+	const struct cred *__cred;		\
+	__cred = current_cred();		\
+	*(_fsuid) = __cred->fsuid;		\
+	*(_fsgid) = __cred->fsgid;		\
+} while(0)
+
 #endif /* _LINUX_CRED_H */

commit f1752eec6145c97163dbce62d17cf5d928e28a27
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:17 2008 +1100

    CRED: Detach the credentials from task_struct
    
    Detach the credentials from task_struct, duplicating them in copy_process()
    and releasing them in __put_task_struct().
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: James Morris <jmorris@namei.org>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index 3e65587a72e5..a7a686074cb0 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -158,4 +158,33 @@ do {						\
 	*(_gid) = current->cred->fsgid;		\
 } while(0)
 
+extern void __put_cred(struct cred *);
+extern int copy_creds(struct task_struct *, unsigned long);
+
+/**
+ * get_cred - Get a reference on a set of credentials
+ * @cred: The credentials to reference
+ *
+ * Get a reference on the specified set of credentials.  The caller must
+ * release the reference.
+ */
+static inline struct cred *get_cred(struct cred *cred)
+{
+	atomic_inc(&cred->usage);
+	return cred;
+}
+
+/**
+ * put_cred - Release a reference to a set of credentials
+ * @cred: The credentials to release
+ *
+ * Release a reference to a set of credentials, deleting them when the last ref
+ * is released.
+ */
+static inline void put_cred(struct cred *cred)
+{
+	if (atomic_dec_and_test(&(cred)->usage))
+		__put_cred(cred);
+}
+
 #endif /* _LINUX_CRED_H */

commit b6dff3ec5e116e3af6f537d4caedcad6b9e5082a
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:16 2008 +1100

    CRED: Separate task security context from task_struct
    
    Separate the task security context from task_struct.  At this point, the
    security data is temporarily embedded in the task_struct with two pointers
    pointing to it.
    
    Note that the Alpha arch is altered as it refers to (E)UID and (E)GID in
    entry.S via asm-offsets.
    
    With comment fixes Signed-off-by: Marc Dionne <marc.c.dionne@gmail.com>
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: James Morris <jmorris@namei.org>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
index b69222cc1fd2..3e65587a72e5 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -12,39 +12,150 @@
 #ifndef _LINUX_CRED_H
 #define _LINUX_CRED_H
 
-#define get_current_user()	(get_uid(current->user))
-
-#define task_uid(task)		((task)->uid)
-#define task_gid(task)		((task)->gid)
-#define task_euid(task)		((task)->euid)
-#define task_egid(task)		((task)->egid)
-
-#define current_uid()		(current->uid)
-#define current_gid()		(current->gid)
-#define current_euid()		(current->euid)
-#define current_egid()		(current->egid)
-#define current_suid()		(current->suid)
-#define current_sgid()		(current->sgid)
-#define current_fsuid()		(current->fsuid)
-#define current_fsgid()		(current->fsgid)
-#define current_cap()		(current->cap_effective)
+#include <linux/capability.h>
+#include <linux/key.h>
+#include <asm/atomic.h>
+
+struct user_struct;
+struct cred;
+
+/*
+ * COW Supplementary groups list
+ */
+#define NGROUPS_SMALL		32
+#define NGROUPS_PER_BLOCK	((unsigned int)(PAGE_SIZE / sizeof(gid_t)))
+
+struct group_info {
+	atomic_t	usage;
+	int		ngroups;
+	int		nblocks;
+	gid_t		small_block[NGROUPS_SMALL];
+	gid_t		*blocks[0];
+};
+
+/**
+ * get_group_info - Get a reference to a group info structure
+ * @group_info: The group info to reference
+ *
+ * This must be called with the owning task locked (via task_lock()) when task
+ * != current.  The reason being that the vast majority of callers are looking
+ * at current->group_info, which can not be changed except by the current task.
+ * Changing current->group_info requires the task lock, too.
+ */
+#define get_group_info(group_info)		\
+do {						\
+	atomic_inc(&(group_info)->usage);	\
+} while (0)
+
+/**
+ * put_group_info - Release a reference to a group info structure
+ * @group_info: The group info to release
+ */
+#define put_group_info(group_info)			\
+do {							\
+	if (atomic_dec_and_test(&(group_info)->usage))	\
+		groups_free(group_info);		\
+} while (0)
+
+extern struct group_info *groups_alloc(int);
+extern void groups_free(struct group_info *);
+extern int set_current_groups(struct group_info *);
+extern int set_groups(struct cred *, struct group_info *);
+extern int groups_search(struct group_info *, gid_t);
+
+/* access the groups "array" with this macro */
+#define GROUP_AT(gi, i) \
+	((gi)->blocks[(i) / NGROUPS_PER_BLOCK][(i) % NGROUPS_PER_BLOCK])
+
+extern int in_group_p(gid_t);
+extern int in_egroup_p(gid_t);
+
+/*
+ * The security context of a task
+ *
+ * The parts of the context break down into two categories:
+ *
+ *  (1) The objective context of a task.  These parts are used when some other
+ *	task is attempting to affect this one.
+ *
+ *  (2) The subjective context.  These details are used when the task is acting
+ *	upon another object, be that a file, a task, a key or whatever.
+ *
+ * Note that some members of this structure belong to both categories - the
+ * LSM security pointer for instance.
+ *
+ * A task has two security pointers.  task->real_cred points to the objective
+ * context that defines that task's actual details.  The objective part of this
+ * context is used whenever that task is acted upon.
+ *
+ * task->cred points to the subjective context that defines the details of how
+ * that task is going to act upon another object.  This may be overridden
+ * temporarily to point to another security context, but normally points to the
+ * same context as task->real_cred.
+ */
+struct cred {
+	atomic_t	usage;
+	uid_t		uid;		/* real UID of the task */
+	gid_t		gid;		/* real GID of the task */
+	uid_t		suid;		/* saved UID of the task */
+	gid_t		sgid;		/* saved GID of the task */
+	uid_t		euid;		/* effective UID of the task */
+	gid_t		egid;		/* effective GID of the task */
+	uid_t		fsuid;		/* UID for VFS ops */
+	gid_t		fsgid;		/* GID for VFS ops */
+	unsigned	securebits;	/* SUID-less security management */
+	kernel_cap_t	cap_inheritable; /* caps our children can inherit */
+	kernel_cap_t	cap_permitted;	/* caps we're permitted */
+	kernel_cap_t	cap_effective;	/* caps we can actually use */
+	kernel_cap_t	cap_bset;	/* capability bounding set */
+#ifdef CONFIG_KEYS
+	unsigned char	jit_keyring;	/* default keyring to attach requested
+					 * keys to */
+	struct key	*thread_keyring; /* keyring private to this thread */
+	struct key	*request_key_auth; /* assumed request_key authority */
+#endif
+#ifdef CONFIG_SECURITY
+	void		*security;	/* subjective LSM security */
+#endif
+	struct user_struct *user;	/* real user ID subscription */
+	struct group_info *group_info;	/* supplementary groups for euid/fsgid */
+	struct rcu_head	rcu;		/* RCU deletion hook */
+	spinlock_t	lock;		/* lock for pointer changes */
+};
+
+#define get_current_user()	(get_uid(current->cred->user))
+
+#define task_uid(task)		((task)->cred->uid)
+#define task_gid(task)		((task)->cred->gid)
+#define task_euid(task)		((task)->cred->euid)
+#define task_egid(task)		((task)->cred->egid)
+
+#define current_uid()		(current->cred->uid)
+#define current_gid()		(current->cred->gid)
+#define current_euid()		(current->cred->euid)
+#define current_egid()		(current->cred->egid)
+#define current_suid()		(current->cred->suid)
+#define current_sgid()		(current->cred->sgid)
+#define current_fsuid()		(current->cred->fsuid)
+#define current_fsgid()		(current->cred->fsgid)
+#define current_cap()		(current->cred->cap_effective)
 
 #define current_uid_gid(_uid, _gid)		\
 do {						\
-	*(_uid) = current->uid;			\
-	*(_gid) = current->gid;			\
+	*(_uid) = current->cred->uid;		\
+	*(_gid) = current->cred->gid;		\
 } while(0)
 
 #define current_euid_egid(_uid, _gid)		\
 do {						\
-	*(_uid) = current->euid;		\
-	*(_gid) = current->egid;		\
+	*(_uid) = current->cred->euid;		\
+	*(_gid) = current->cred->egid;		\
 } while(0)
 
 #define current_fsuid_fsgid(_uid, _gid)		\
 do {						\
-	*(_uid) = current->fsuid;		\
-	*(_gid) = current->fsgid;		\
+	*(_uid) = current->cred->fsuid;		\
+	*(_gid) = current->cred->fsgid;		\
 } while(0)
 
 #endif /* _LINUX_CRED_H */

commit 9e2b2dc4133f65272a6d3c5dcb2ce63f8a87cae9
Author: David Howells <dhowells@redhat.com>
Date:   Wed Aug 13 16:20:04 2008 +0100

    CRED: Introduce credential access wrappers
    
    The patches that are intended to introduce copy-on-write credentials for 2.6.28
    require abstraction of access to some fields of the task structure,
    particularly for the case of one task accessing another's credentials where RCU
    will have to be observed.
    
    Introduced here are trivial no-op versions of the desired accessors for current
    and other tasks so that other subsystems can start to be converted over more
    easily.
    
    Wrappers are introduced into a new header (linux/cred.h) for UID/GID,
    EUID/EGID, SUID/SGID, FSUID/FSGID, cap_effective and current's subscribed
    user_struct.  These wrappers are macros because the ordering between header
    files mitigates against making them inline functions.
    
    linux/cred.h is #included from linux/sched.h.
    
    Further, XFS is modified such that it no longer defines and uses parameterised
    versions of current_fs[ug]id(), thus getting rid of the namespace collision
    otherwise incurred.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/cred.h b/include/linux/cred.h
new file mode 100644
index 000000000000..b69222cc1fd2
--- /dev/null
+++ b/include/linux/cred.h
@@ -0,0 +1,50 @@
+/* Credentials management
+ *
+ * Copyright (C) 2008 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public Licence
+ * as published by the Free Software Foundation; either version
+ * 2 of the Licence, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_CRED_H
+#define _LINUX_CRED_H
+
+#define get_current_user()	(get_uid(current->user))
+
+#define task_uid(task)		((task)->uid)
+#define task_gid(task)		((task)->gid)
+#define task_euid(task)		((task)->euid)
+#define task_egid(task)		((task)->egid)
+
+#define current_uid()		(current->uid)
+#define current_gid()		(current->gid)
+#define current_euid()		(current->euid)
+#define current_egid()		(current->egid)
+#define current_suid()		(current->suid)
+#define current_sgid()		(current->sgid)
+#define current_fsuid()		(current->fsuid)
+#define current_fsgid()		(current->fsgid)
+#define current_cap()		(current->cap_effective)
+
+#define current_uid_gid(_uid, _gid)		\
+do {						\
+	*(_uid) = current->uid;			\
+	*(_gid) = current->gid;			\
+} while(0)
+
+#define current_euid_egid(_uid, _gid)		\
+do {						\
+	*(_uid) = current->euid;		\
+	*(_gid) = current->egid;		\
+} while(0)
+
+#define current_fsuid_fsgid(_uid, _gid)		\
+do {						\
+	*(_uid) = current->fsuid;		\
+	*(_gid) = current->fsgid;		\
+} while(0)
+
+#endif /* _LINUX_CRED_H */
