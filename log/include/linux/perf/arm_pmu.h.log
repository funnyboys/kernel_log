commit 8673e02e58410e6c4cefa499efa846286e45a991
Author: Andrew Murray <andrew.murray@arm.com>
Date:   Mon Mar 2 18:17:52 2020 +0000

    arm64: perf: Add support for ARMv8.5-PMU 64-bit counters
    
    At present ARMv8 event counters are limited to 32-bits, though by
    using the CHAIN event it's possible to combine adjacent counters to
    achieve 64-bits. The perf config1:0 bit can be set to use such a
    configuration.
    
    With the introduction of ARMv8.5-PMU support, all event counters can
    now be used as 64-bit counters.
    
    Let's enable 64-bit event counters where support exists. Unless the
    user sets config1:0 we will adjust the counter value such that it
    overflows upon 32-bit overflow. This follows the same behaviour as
    the cycle counter which has always been (and remains) 64-bits.
    
    Signed-off-by: Andrew Murray <andrew.murray@arm.com>
    Reviewed-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    [Mark: fix ID field names, compare with 8.5 value]
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index 71f525a35ac2..5b616dde9a4c 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -80,6 +80,7 @@ struct arm_pmu {
 	struct pmu	pmu;
 	cpumask_t	supported_cpus;
 	char		*name;
+	int		pmuver;
 	irqreturn_t	(*handle_irq)(struct arm_pmu *pmu);
 	void		(*enable)(struct perf_event *event);
 	void		(*disable)(struct perf_event *event);

commit dfd437a257924484b144ee750e60affc95562c6d
Merge: 0ecfebd2b524 0c61efd322b7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 09:54:55 2019 -0700

    Merge tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux
    
    Pull arm64 updates from Catalin Marinas:
    
     - arm64 support for syscall emulation via PTRACE_SYSEMU{,_SINGLESTEP}
    
     - Wire up VM_FLUSH_RESET_PERMS for arm64, allowing the core code to
       manage the permissions of executable vmalloc regions more strictly
    
     - Slight performance improvement by keeping softirqs enabled while
       touching the FPSIMD/SVE state (kernel_neon_begin/end)
    
     - Expose a couple of ARMv8.5 features to user (HWCAP): CondM (new
       XAFLAG and AXFLAG instructions for floating point comparison flags
       manipulation) and FRINT (rounding floating point numbers to integers)
    
     - Re-instate ARM64_PSEUDO_NMI support which was previously marked as
       BROKEN due to some bugs (now fixed)
    
     - Improve parking of stopped CPUs and implement an arm64-specific
       panic_smp_self_stop() to avoid warning on not being able to stop
       secondary CPUs during panic
    
     - perf: enable the ARM Statistical Profiling Extensions (SPE) on ACPI
       platforms
    
     - perf: DDR performance monitor support for iMX8QXP
    
     - cache_line_size() can now be set from DT or ACPI/PPTT if provided to
       cope with a system cache info not exposed via the CPUID registers
    
     - Avoid warning on hardware cache line size greater than
       ARCH_DMA_MINALIGN if the system is fully coherent
    
     - arm64 do_page_fault() and hugetlb cleanups
    
     - Refactor set_pte_at() to avoid redundant READ_ONCE(*ptep)
    
     - Ignore ACPI 5.1 FADTs reported as 5.0 (infer from the
       'arm_boot_flags' introduced in 5.1)
    
     - CONFIG_RANDOMIZE_BASE now enabled in defconfig
    
     - Allow the selection of ARM64_MODULE_PLTS, currently only done via
       RANDOMIZE_BASE (and an erratum workaround), allowing modules to spill
       over into the vmalloc area
    
     - Make ZONE_DMA32 configurable
    
    * tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux: (54 commits)
      perf: arm_spe: Enable ACPI/Platform automatic module loading
      arm_pmu: acpi: spe: Add initial MADT/SPE probing
      ACPI/PPTT: Add function to return ACPI 6.3 Identical tokens
      ACPI/PPTT: Modify node flag detection to find last IDENTICAL
      x86/entry: Simplify _TIF_SYSCALL_EMU handling
      arm64: rename dump_instr as dump_kernel_instr
      arm64/mm: Drop [PTE|PMD]_TYPE_FAULT
      arm64: Implement panic_smp_self_stop()
      arm64: Improve parking of stopped CPUs
      arm64: Expose FRINT capabilities to userspace
      arm64: Expose ARMv8.5 CondM capability to userspace
      arm64: defconfig: enable CONFIG_RANDOMIZE_BASE
      arm64: ARM64_MODULES_PLTS must depend on MODULES
      arm64: bpf: do not allocate executable memory
      arm64/kprobes: set VM_FLUSH_RESET_PERMS on kprobe instruction pages
      arm64/mm: wire up CONFIG_ARCH_HAS_SET_DIRECT_MAP
      arm64: module: create module allocations without exec permissions
      arm64: Allow user selection of ARM64_MODULE_PLTS
      acpi/arm64: ignore 5.1 FADTs that are reported as 5.0
      arm64: Allow selecting Pseudo-NMI again
      ...

commit d24a0c7099b32b6981d7f126c45348e381718350
Author: Jeremy Linton <jeremy.linton@arm.com>
Date:   Wed Jun 26 16:37:17 2019 -0500

    arm_pmu: acpi: spe: Add initial MADT/SPE probing
    
    ACPI 6.3 adds additional fields to the MADT GICC
    structure to describe SPE PPI's. We pick these out
    of the cached reference to the madt_gicc structure
    similarly to the core PMU code. We then create a platform
    device referring to the IRQ and let the user/module loader
    decide whether to load the SPE driver.
    
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Sudeep Holla <sudeep.holla@arm.com>
    Reviewed-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Jeremy Linton <jeremy.linton@arm.com>
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index 4641e850b204..784bc58f165a 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -175,4 +175,6 @@ void armpmu_free_irq(int irq, int cpu);
 
 #endif /* CONFIG_ARM_PMU */
 
+#define ARMV8_SPE_PDEV_NAME "arm,spe-v1"
+
 #endif /* __ARM_PMU_H__ */

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index 4641e850b204..a9b0ee408fbd 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -1,12 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  *  linux/arch/arm/include/asm/pmu.h
  *
  *  Copyright (C) 2009 picoChip Designs Ltd, Jamie Iles
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  */
 
 #ifndef __ARM_PMU_H__

commit 342e53bd8548e07c6a734d2d3a6437ad6e6d3b09
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Oct 5 13:28:07 2018 +0100

    arm64: perf: Add support for Armv8.1 PMCEID register format
    
    Armv8.1 allocated the upper 32-bits of the PMCEID registers to describe
    the common architectural and microarchitecture events beginning at 0x4000.
    
    Add support for these registers to our probing code, so that we can
    advertise the SPE events when they are supported by the CPU.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index bf309ff6f244..4641e850b204 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -102,8 +102,10 @@ struct arm_pmu {
 	int		(*filter_match)(struct perf_event *event);
 	int		num_events;
 	bool		secure_access; /* 32-bit ARM only */
-#define ARMV8_PMUV3_MAX_COMMON_EVENTS 0x40
+#define ARMV8_PMUV3_MAX_COMMON_EVENTS		0x40
 	DECLARE_BITMAP(pmceid_bitmap, ARMV8_PMUV3_MAX_COMMON_EVENTS);
+#define ARMV8_PMUV3_EXT_COMMON_EVENT_BASE	0x4000
+	DECLARE_BITMAP(pmceid_ext_bitmap, ARMV8_PMUV3_MAX_COMMON_EVENTS);
 	struct platform_device	*plat_device;
 	struct pmu_hw_events	__percpu *hw_events;
 	struct hlist_node	node;

commit ca2b497253ad01c80061a1f3ee9eb91b5d54a849
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Oct 5 13:24:36 2018 +0100

    arm64: perf: Reject stand-alone CHAIN events for PMUv3
    
    It doesn't make sense for a perf event to be configured as a CHAIN event
    in isolation, so extend the arm_pmu structure with a ->filter_match()
    function to allow the backend PMU implementation to reject CHAIN events
    early.
    
    Cc: <stable@vger.kernel.org>
    Reviewed-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index 10f92e1d8e7b..bf309ff6f244 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -99,6 +99,7 @@ struct arm_pmu {
 	void		(*stop)(struct arm_pmu *);
 	void		(*reset)(void *);
 	int		(*map_event)(struct perf_event *event);
+	int		(*filter_match)(struct perf_event *event);
 	int		num_events;
 	bool		secure_access; /* 32-bit ARM only */
 #define ARMV8_PMUV3_MAX_COMMON_EVENTS 0x40

commit e2da97d328d4951d25f6634eda7213f7257417b6
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Tue Jul 10 09:58:00 2018 +0100

    arm_pmu: Add support for 64bit event counters
    
    Each PMU has a set of 32bit event counters. But in some
    special cases, the events could be counted using counters
    which are effectively 64bit wide.
    
    e.g, Arm V8 PMUv3 has a 64 bit cycle counter which can count
    only the CPU cycles. Also, the PMU can chain the event counters
    to effectively count as a 64bit counter.
    
    Add support for tracking the events that uses 64bit counters.
    This only affects the periods set for each counter in the core
    driver.
    
    Cc: Will Deacon <will.deacon@arm.com>
    Reviewed-by: Julien Thierry <julien.thierry@arm.com>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index f7126a21df30..10f92e1d8e7b 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -25,6 +25,12 @@
  */
 #define ARMPMU_MAX_HWEVENTS		32
 
+/*
+ * ARM PMU hw_event flags
+ */
+/* Event uses a 64bit counter */
+#define ARMPMU_EVT_64BIT		1
+
 #define HW_OP_UNSUPPORTED		0xFFFF
 #define C(_x)				PERF_COUNT_HW_CACHE_##_x
 #define CACHE_OP_UNSUPPORTED		0xFFFF

commit 3a95200d3f89afd8b67f39d88d36cc7ec96ce385
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Tue Jul 10 09:57:59 2018 +0100

    arm_pmu: Change API to support 64bit counter values
    
    Convert the {read/write}_counter APIs to handle 64bit values
    to enable supporting chained event counters. The backends still
    use 32bit values and we pass them 32bit values only. So in effect
    there are no functional changes.
    
    Cc: Will Deacon <will.deacon@arm.com>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Reviewed-by: Julien Thierry <julien.thierry@arm.com>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index 12c30a22fc8d..f7126a21df30 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -87,8 +87,8 @@ struct arm_pmu {
 					 struct perf_event *event);
 	int		(*set_event_filter)(struct hw_perf_event *evt,
 					    struct perf_event_attr *attr);
-	u32		(*read_counter)(struct perf_event *event);
-	void		(*write_counter)(struct perf_event *event, u32 val);
+	u64		(*read_counter)(struct perf_event *event);
+	void		(*write_counter)(struct perf_event *event, u64 val);
 	void		(*start)(struct arm_pmu *);
 	void		(*stop)(struct arm_pmu *);
 	void		(*reset)(void *);

commit 8d3e994241e6bcc7ead2b918c4f15b7683afa90a
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Tue Jul 10 09:57:58 2018 +0100

    arm_pmu: Clean up maximum period handling
    
    Each PMU defines their max_period of the counter as the maximum
    value that can be counted. Since all the PMU backends support
    32bit counters by default, let us remove the redundant field.
    
    No functional changes.
    
    Cc: Will Deacon <will.deacon@arm.com>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Reviewed-by: Julien Thierry <julien.thierry@arm.com>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index ad5444491975..12c30a22fc8d 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -94,7 +94,6 @@ struct arm_pmu {
 	void		(*reset)(void *);
 	int		(*map_event)(struct perf_event *event);
 	int		num_events;
-	u64		max_period;
 	bool		secure_access; /* 32-bit ARM only */
 #define ARMV8_PMUV3_MAX_COMMON_EVENTS 0x40
 	DECLARE_BITMAP(pmceid_bitmap, ARMV8_PMUV3_MAX_COMMON_EVENTS);

commit 0788f1e97324d8378e860dc2560699ddc6f3aef9
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Thu May 10 11:35:15 2018 +0100

    arm_pmu: simplify arm_pmu::handle_irq
    
    The arm_pmu::handle_irq() callback has the same prototype as a generic
    IRQ handler, taking the IRQ number and a void pointer argument which it
    must convert to an arm_pmu pointer.
    
    This means that all arm_pmu::handle_irq() take an IRQ number they never
    use, and all must explicitly cast the void pointer to an arm_pmu
    pointer.
    
    Instead, let's change arm_pmu::handle_irq to take an arm_pmu pointer,
    allowing these casts to be removed. The redundant IRQ number parameter
    is also removed.
    
    Suggested-by: Hoeun Ryu <hoeun.ryu@lge.com>
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index 40036a57d072..ad5444491975 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -78,7 +78,7 @@ struct arm_pmu {
 	struct pmu	pmu;
 	cpumask_t	supported_cpus;
 	char		*name;
-	irqreturn_t	(*handle_irq)(int irq_num, void *dev);
+	irqreturn_t	(*handle_irq)(struct arm_pmu *pmu);
 	void		(*enable)(struct perf_event *event);
 	void		(*disable)(struct perf_event *event);
 	int		(*get_event_idx)(struct pmu_hw_events *hw_events,

commit 167e61438da0664cab87c825a6c0cb83510d578e
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Oct 9 17:09:05 2017 +0100

    arm_pmu: acpi: request IRQs up-front
    
    We can't request IRQs in atomic context, so for ACPI systems we'll have
    to request them up-front, and later associate them with CPUs.
    
    This patch reorganises the arm_pmu code to do so. As we no longer have
    the arm_pmu structure at probe time, a number of prototypes need to be
    adjusted, requiring changes to the common arm_pmu code and arm_pmu
    platform code.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index feec9e7e85db..40036a57d072 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -14,6 +14,7 @@
 
 #include <linux/interrupt.h>
 #include <linux/perf_event.h>
+#include <linux/platform_device.h>
 #include <linux/sysfs.h>
 #include <asm/cputype.h>
 
@@ -159,8 +160,8 @@ struct arm_pmu *armpmu_alloc(void);
 struct arm_pmu *armpmu_alloc_atomic(void);
 void armpmu_free(struct arm_pmu *pmu);
 int armpmu_register(struct arm_pmu *pmu);
-int armpmu_request_irq(struct arm_pmu *armpmu, int cpu);
-void armpmu_free_irq(struct arm_pmu *armpmu, int cpu);
+int armpmu_request_irq(int irq, int cpu);
+void armpmu_free_irq(int irq, int cpu);
 
 #define ARMV8_PMU_PDEV_NAME "armv8-pmu"
 

commit 84b4be57ae17f8c0b3c1d8629e10f23910838fd7
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Tue Dec 12 16:56:06 2017 +0000

    arm_pmu: note IRQs and PMUs per-cpu
    
    To support ACPI systems, we need to request IRQs before we know the
    associated PMU, and thus we need some percpu variable that the IRQ
    handler can find the PMU from.
    
    As we're going to request IRQs without the PMU, we can't rely on the
    arm_pmu::active_irqs mask, and similarly need to track requested IRQs
    with a percpu variable.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    [will: made armpmu_count_irq_users static]
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index 1f8bb83ef42f..feec9e7e85db 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -75,7 +75,6 @@ enum armpmu_attr_groups {
 
 struct arm_pmu {
 	struct pmu	pmu;
-	cpumask_t	active_irqs;
 	cpumask_t	supported_cpus;
 	char		*name;
 	irqreturn_t	(*handle_irq)(int irq_num, void *dev);

commit 0dc1a1851af1d593eee248b94c1277c7c7ccbbce
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Feb 5 16:41:58 2018 +0000

    arm_pmu: add armpmu_alloc_atomic()
    
    In ACPI systems, we don't know the makeup of CPUs until we hotplug them
    on, and thus have to allocate the PMU datastructures at hotplug time.
    Thus, we must use GFP_ATOMIC allocations.
    
    Let's add an armpmu_alloc_atomic() that we can use in this case.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index 899bc7ef0881..1f8bb83ef42f 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -157,6 +157,7 @@ static inline int arm_pmu_acpi_probe(armpmu_init_fn init_fn) { return 0; }
 
 /* Internal functions only for core arm_pmu code */
 struct arm_pmu *armpmu_alloc(void);
+struct arm_pmu *armpmu_alloc_atomic(void);
 void armpmu_free(struct arm_pmu *pmu);
 int armpmu_register(struct arm_pmu *pmu);
 int armpmu_request_irq(struct arm_pmu *armpmu, int cpu);

commit d3d5aac206b4e9e569a22fe1811c909dde17587c
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Feb 5 16:41:57 2018 +0000

    arm_pmu: fold platform helpers into platform code
    
    The armpmu_{request,free}_irqs() helpers are only used by
    arm_pmu_platform.c, so let's fold them in and make them static.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index 712764b35c6a..899bc7ef0881 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -159,8 +159,6 @@ static inline int arm_pmu_acpi_probe(armpmu_init_fn init_fn) { return 0; }
 struct arm_pmu *armpmu_alloc(void);
 void armpmu_free(struct arm_pmu *pmu);
 int armpmu_register(struct arm_pmu *pmu);
-int armpmu_request_irqs(struct arm_pmu *armpmu);
-void armpmu_free_irqs(struct arm_pmu *armpmu);
 int armpmu_request_irq(struct arm_pmu *armpmu, int cpu);
 void armpmu_free_irq(struct arm_pmu *armpmu, int cpu);
 

commit c0248c96631f38f02d58762fc018e316843acac8
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Feb 5 16:41:56 2018 +0000

    arm_pmu: kill arm_pmu_platdata
    
    Now that we have no platforms passing platform data to the arm_pmu code,
    we can get rid of the platdata and associated hooks, paving the way for
    rework of our IRQ handling.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index af0f44effd44..712764b35c6a 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -17,23 +17,6 @@
 #include <linux/sysfs.h>
 #include <asm/cputype.h>
 
-/*
- * struct arm_pmu_platdata - ARM PMU platform data
- *
- * @handle_irq: an optional handler which will be called from the
- *	interrupt and passed the address of the low level handler,
- *	and can be used to implement any platform specific handling
- *	before or after calling it.
- *
- * @irq_flags: if non-zero, these flags will be passed to request_irq
- *             when requesting interrupts for this PMU device.
- */
-struct arm_pmu_platdata {
-	irqreturn_t (*handle_irq)(int irq, void *dev,
-				  irq_handler_t pmu_handler);
-	unsigned long irq_flags;
-};
-
 #ifdef CONFIG_ARM_PMU
 
 /*

commit a3287c41ff405025bc57b165a0f6cd698bbbc1be
Author: Will Deacon <will.deacon@arm.com>
Date:   Tue Jul 25 16:30:34 2017 +0100

    drivers/perf: arm_pmu: Request PMU SPIs with IRQF_PER_CPU
    
    Since the PMU register interface is banked per CPU, CPU PMU interrrupts
    cannot be handled by a CPU other than the one with the PMU asserting the
    interrupt. This means that migrating PMU SPIs, as we do during a CPU
    hotplug operation doesn't make any sense and can lead to the IRQ being
    disabled entirely if we route a spurious IRQ to the new affinity target.
    
    This has been observed in practice on AMD Seattle, where CPUs on the
    non-boot cluster appear to take a spurious PMU IRQ when coming online,
    which is routed to CPU0 where it cannot be handled.
    
    This patch passes IRQF_PERCPU for PMU SPIs and forcefully sets their
    affinity prior to requesting them, ensuring that they cannot
    be migrated during hotplug events. This interacts badly with the DB8500
    erratum workaround that ping-pongs the interrupt affinity from the handler,
    so we avoid passing IRQF_PERCPU in that case by allowing the IRQ flags
    to be overridden in the platdata.
    
    Fixes: 3cf7ee98b848 ("drivers/perf: arm_pmu: move irq request/free into probe")
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index 1360dd6d5e61..af0f44effd44 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -24,10 +24,14 @@
  *	interrupt and passed the address of the low level handler,
  *	and can be used to implement any platform specific handling
  *	before or after calling it.
+ *
+ * @irq_flags: if non-zero, these flags will be passed to request_irq
+ *             when requesting interrupts for this PMU device.
  */
 struct arm_pmu_platdata {
 	irqreturn_t (*handle_irq)(int irq, void *dev,
 				  irq_handler_t pmu_handler);
+	unsigned long irq_flags;
 };
 
 #ifdef CONFIG_ARM_PMU

commit 45736a72fb79b204c1fbdb08a1e1a2aa52c7281a
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Tue Apr 11 09:39:55 2017 +0100

    drivers/perf: arm_pmu: add ACPI framework
    
    This patch adds framework code to handle parsing PMU data out of the
    MADT, sanity checking this, and managing the association of CPUs (and
    their interrupts) with appropriate logical PMUs.
    
    For the time being, we expect that only one PMU driver (PMUv3) will make
    use of this, and we simply pass in a single probe function.
    
    This is based on an earlier patch from Jeremy Linton.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Tested-by: Jeremy Linton <jeremy.linton@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index 25556ebb1c7b..1360dd6d5e61 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -117,6 +117,9 @@ struct arm_pmu {
 	struct notifier_block	cpu_pm_nb;
 	/* the attr_groups array must be NULL-terminated */
 	const struct attribute_group *attr_groups[ARMPMU_NR_ATTR_GROUPS + 1];
+
+	/* Only to be used by ACPI probing code */
+	unsigned long acpi_cpuid;
 };
 
 #define to_arm_pmu(p) (container_of(p, struct arm_pmu, pmu))
@@ -159,12 +162,20 @@ int arm_pmu_device_probe(struct platform_device *pdev,
 			 const struct of_device_id *of_table,
 			 const struct pmu_probe_info *probe_table);
 
+#ifdef CONFIG_ACPI
+int arm_pmu_acpi_probe(armpmu_init_fn init_fn);
+#else
+static inline int arm_pmu_acpi_probe(armpmu_init_fn init_fn) { return 0; }
+#endif
+
 /* Internal functions only for core arm_pmu code */
 struct arm_pmu *armpmu_alloc(void);
 void armpmu_free(struct arm_pmu *pmu);
 int armpmu_register(struct arm_pmu *pmu);
 int armpmu_request_irqs(struct arm_pmu *armpmu);
 void armpmu_free_irqs(struct arm_pmu *armpmu);
+int armpmu_request_irq(struct arm_pmu *armpmu, int cpu);
+void armpmu_free_irq(struct arm_pmu *armpmu, int cpu);
 
 #define ARMV8_PMU_PDEV_NAME "armv8-pmu"
 

commit 18bfcfe51b8f60b69ab012888dea8061a9cd3381
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Tue Apr 11 09:39:53 2017 +0100

    drivers/perf: arm_pmu: split out platform device probe logic
    
    Now that we've split the pdev and DT probing logic from the runtime
    management, let's move the former into its own file. We gain a few lines
    due to the copyright header and includes, but this should keep the logic
    clearly separated, and paves the way for adding ACPI support in a
    similar fashion.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Tested-by: Jeremy Linton <jeremy.linton@arm.com>
    [will: rename nr_irqs to avoid conflict with global variable]
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index 4249914315a4..25556ebb1c7b 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -159,6 +159,13 @@ int arm_pmu_device_probe(struct platform_device *pdev,
 			 const struct of_device_id *of_table,
 			 const struct pmu_probe_info *probe_table);
 
+/* Internal functions only for core arm_pmu code */
+struct arm_pmu *armpmu_alloc(void);
+void armpmu_free(struct arm_pmu *pmu);
+int armpmu_register(struct arm_pmu *pmu);
+int armpmu_request_irqs(struct arm_pmu *armpmu);
+void armpmu_free_irqs(struct arm_pmu *armpmu);
+
 #define ARMV8_PMU_PDEV_NAME "armv8-pmu"
 
 #endif /* CONFIG_ARM_PMU */

commit 083c52144a19c69b7956aa53c913ba621f7c5ae2
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Tue Apr 11 09:39:45 2017 +0100

    drivers/perf: arm_pmu: define armpmu_init_fn
    
    We expect an ARM PMU's init function to have a particular prototype,
    which we open-code in a few places. This is less than ideal, considering
    that we cast a void value to this type in one location, and a mismatch
    could easily be missed.
    
    Add a typedef so that we can ensure this is consistent.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Tested-by: Jeremy Linton <jeremy.linton@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index 44f43fcf2524..4249914315a4 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -132,10 +132,12 @@ int armpmu_map_event(struct perf_event *event,
 						[PERF_COUNT_HW_CACHE_RESULT_MAX],
 		     u32 raw_event_mask);
 
+typedef int (*armpmu_init_fn)(struct arm_pmu *);
+
 struct pmu_probe_info {
 	unsigned int cpuid;
 	unsigned int mask;
-	int (*init)(struct arm_pmu *);
+	armpmu_init_fn init;
 };
 
 #define PMU_PROBE(_cpuid, _mask, _fn)	\

commit c09adab01e4aeecfa3dfae0946409844400c5901
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Fri Mar 10 10:46:15 2017 +0000

    drivers/perf: arm_pmu: split irq request from enable
    
    For historical reasons, we lazily request and free interrupts in the
    arm pmu driver. This requires us to refcount use of the pmu (by way of
    counting the active events) in order to request/free interrupts at the
    correct times, which complicates the driver somewhat.
    
    The existing logic is flawed, as it only considers currently online CPUs
    when requesting, freeing, or managing the affinity of interrupts.
    Intervening hotplug events can result in erroneous IRQ affinity, online
    CPUs for which interrupts have not been requested, or offline CPUs whose
    interrupts are still requested.
    
    To fix this, this patch splits the requesting of interrupts from any
    per-cpu management (i.e. per-cpu enable/disable, and configuration of
    cpu affinity). We now request all interrupts up-front at probe time (and
    never free them, since we never unregister PMUs).
    
    The management of affinity, and per-cpu enable/disable now happens in
    our cpu hotplug callback, ensuring it occurs consistently. This means
    that we must now invoke the CPU hotplug callback at boot time in order
    to configure IRQs, and since the callback also resets the PMU hardware,
    we can remove the duplicate reset in the probe path.
    
    This rework renders our event refcounting unnecessary, so this is
    removed.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    [will: make armpmu_get_cpu_irq static]
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index 05a3eb447fc8..44f43fcf2524 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -105,12 +105,8 @@ struct arm_pmu {
 	void		(*start)(struct arm_pmu *);
 	void		(*stop)(struct arm_pmu *);
 	void		(*reset)(void *);
-	int		(*request_irq)(struct arm_pmu *, irq_handler_t handler);
-	void		(*free_irq)(struct arm_pmu *);
 	int		(*map_event)(struct perf_event *event);
 	int		num_events;
-	atomic_t	active_events;
-	struct mutex	reserve_mutex;
 	u64		max_period;
 	bool		secure_access; /* 32-bit ARM only */
 #define ARMV8_PMUV3_MAX_COMMON_EVENTS 0x40

commit 7ed98e0168bd23d8ea3294e95254cc5b4000c948
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Fri Mar 10 10:46:14 2017 +0000

    drivers/perf: arm_pmu: manage interrupts per-cpu
    
    When requesting or freeing interrupts, we use platform_get_irq() to find
    relevant irqs, backing this up with additional information in an
    optional irq_affinity table.
    
    This means that our irq request and free paths are tied to a
    platform_device, and our request path must jump through a number of
    hoops in order to determine the required affinity of each interrupt.
    
    Given that the affinity must be static, we can compute the affinity once
    up-front at probe time, simplifying the irq request and free paths. By
    recording interrupts in a per-cpu data structure, we simplify a few
    paths, and permit a subsequent rework of the request and free paths.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    [will: rename local nr_irqs variable to avoid conflict with global]
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index 8462da266089..05a3eb447fc8 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -75,6 +75,8 @@ struct pmu_hw_events {
 	 * already have to allocate this struct per cpu.
 	 */
 	struct arm_pmu		*percpu_pmu;
+
+	int irq;
 };
 
 enum armpmu_attr_groups {
@@ -88,7 +90,6 @@ struct arm_pmu {
 	struct pmu	pmu;
 	cpumask_t	active_irqs;
 	cpumask_t	supported_cpus;
-	int		*irq_affinity;
 	char		*name;
 	irqreturn_t	(*handle_irq)(int irq_num, void *dev);
 	void		(*enable)(struct perf_event *event);

commit 597f03f9d133e9837d00965016170271d4f87dcf
Merge: 999dcbe2414e 0bf71e4d02ff
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 3 19:43:08 2016 -0700

    Merge branch 'smp-hotplug-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull CPU hotplug updates from Thomas Gleixner:
     "Yet another batch of cpu hotplug core updates and conversions:
    
       - Provide core infrastructure for multi instance drivers so the
         drivers do not have to keep custom lists.
    
       - Convert custom lists to the new infrastructure. The block-mq custom
         list conversion comes through the block tree and makes the diffstat
         tip over to more lines removed than added.
    
       - Handle unbalanced hotplug enable/disable calls more gracefully.
    
       - Remove the obsolete CPU_STARTING/DYING notifier support.
    
       - Convert another batch of notifier users.
    
       The relayfs changes which conflicted with the conversion have been
       shipped to me by Andrew.
    
       The remaining lot is targeted for 4.10 so that we finally can remove
       the rest of the notifiers"
    
    * 'smp-hotplug-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (46 commits)
      cpufreq: Fix up conversion to hotplug state machine
      blk/mq: Reserve hotplug states for block multiqueue
      x86/apic/uv: Convert to hotplug state machine
      s390/mm/pfault: Convert to hotplug state machine
      mips/loongson/smp: Convert to hotplug state machine
      mips/octeon/smp: Convert to hotplug state machine
      fault-injection/cpu: Convert to hotplug state machine
      padata: Convert to hotplug state machine
      cpufreq: Convert to hotplug state machine
      ACPI/processor: Convert to hotplug state machine
      virtio scsi: Convert to hotplug state machine
      oprofile/timer: Convert to hotplug state machine
      block/softirq: Convert to hotplug state machine
      lib/irq_poll: Convert to hotplug state machine
      x86/microcode: Convert to hotplug state machine
      sh/SH-X3 SMP: Convert to hotplug state machine
      ia64/mca: Convert to hotplug state machine
      ARM/OMAP/wakeupgen: Convert to hotplug state machine
      ARM/shmobile: Convert to hotplug state machine
      arm64/FP/SIMD: Convert to hotplug state machine
      ...

commit 85023b2e1325826edf5d226a9cb4d809ed1e2024
Author: Jeremy Linton <jeremy.linton@arm.com>
Date:   Wed Sep 14 17:32:31 2016 -0500

    arm64: pmu: Hoist pmu platform device name
    
    Move the PMU name into a common header file so it may
    be referenced by other users.
    
    Signed-off-by: Jeremy Linton <jeremy.linton@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index dc1f2f30c961..9ff07d3fc8de 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -160,6 +160,8 @@ int arm_pmu_device_probe(struct platform_device *pdev,
 			 const struct of_device_id *of_table,
 			 const struct pmu_probe_info *probe_table);
 
+#define ARMV8_PMU_PDEV_NAME "armv8-pmu"
+
 #endif /* CONFIG_ARM_PMU */
 
 #endif /* __ARM_PMU_H__ */

commit 48538b5863d8e8f8d567fc9a1d27a68623e0a0ff
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Fri Sep 9 14:08:30 2016 +0100

    drivers/perf: arm_pmu: expose a cpumask in sysfs
    
    In systems with heterogeneous CPUs, there are multiple logical CPU PMUs,
    each of which covers a subset of CPUs in the system. In some cases
    userspace needs to know which CPUs a given logical PMU covers, so we'd
    like to expose a cpumask under sysfs, similar to what is done for uncore
    PMUs.
    
    Unfortunately, prior to commit 00e727bb389359c8 ("perf stat: Balance
    opening and reading events"), perf stat only correctly handled a cpumask
    holding a single CPU, and only when profiling in system-wide mode. In
    other cases, the presence of a cpumask file could cause perf stat to
    behave erratically.
    
    Thus, exposing a cpumask file would break older perf binaries in cases
    where they would otherwise work.
    
    To avoid this issue while still providing userspace with the information
    it needs, this patch exposes a differently-named file (cpus) under
    sysfs. New tools can look for this and operate correctly, while older
    tools will not be adversely affected by its presence.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index 268bc63f1358..dc1f2f30c961 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -78,6 +78,7 @@ struct pmu_hw_events {
 };
 
 enum armpmu_attr_groups {
+	ARMPMU_ATTR_GROUP_COMMON,
 	ARMPMU_ATTR_GROUP_EVENTS,
 	ARMPMU_ATTR_GROUP_FORMATS,
 	ARMPMU_NR_ATTR_GROUPS

commit 86cdd72af936860503f392825410d1b60a3e474e
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Fri Sep 9 14:08:26 2016 +0100

    drivers/perf: arm_pmu: add common attr group fields
    
    In preparation for adding common attribute groups, add an array of
    attribute group pointers to arm_pmu, which will be used if the
    backend hasn't already set pmu::attr_groups.
    
    Subsequent patches will move backends over to using these, before adding
    common fields.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index e18843809eec..268bc63f1358 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -14,7 +14,7 @@
 
 #include <linux/interrupt.h>
 #include <linux/perf_event.h>
-
+#include <linux/sysfs.h>
 #include <asm/cputype.h>
 
 /*
@@ -77,6 +77,12 @@ struct pmu_hw_events {
 	struct arm_pmu		*percpu_pmu;
 };
 
+enum armpmu_attr_groups {
+	ARMPMU_ATTR_GROUP_EVENTS,
+	ARMPMU_ATTR_GROUP_FORMATS,
+	ARMPMU_NR_ATTR_GROUPS
+};
+
 struct arm_pmu {
 	struct pmu	pmu;
 	cpumask_t	active_irqs;
@@ -111,6 +117,8 @@ struct arm_pmu {
 	struct pmu_hw_events	__percpu *hw_events;
 	struct list_head	entry;
 	struct notifier_block	cpu_pm_nb;
+	/* the attr_groups array must be NULL-terminated */
+	const struct attribute_group *attr_groups[ARMPMU_NR_ATTR_GROUPS + 1];
 };
 
 #define to_arm_pmu(p) (container_of(p, struct arm_pmu, pmu))

commit 6e103c0cfeb9ab8d40822a015da9769595096411
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed Aug 17 19:14:20 2016 +0200

    arm/perf: Use multi instance instead of custom list
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: rt@linutronix.de
    Link: http://lkml.kernel.org/r/20160817171420.sdwk2qivxunzryz4@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index e18843809eec..4ad1b408c0bb 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -109,7 +109,7 @@ struct arm_pmu {
 	DECLARE_BITMAP(pmceid_bitmap, ARMV8_PMUV3_MAX_COMMON_EVENTS);
 	struct platform_device	*plat_device;
 	struct pmu_hw_events	__percpu *hw_events;
-	struct list_head	entry;
+	struct hlist_node	node;
 	struct notifier_block	cpu_pm_nb;
 };
 

commit 37b502f121adab26ccc2769c3063f0e1272be7de
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed Jul 20 09:51:11 2016 +0200

    arm/perf: Fix hotplug state machine conversion
    
    Mark Rutland pointed out that this commit is incomplete:
    
      7d88eb695a1f ("arm/perf: Convert to hotplug state machine")
    
    The problem is that:
    
     > We may have multiple PMUs (e.g. two in big.LITTLE systems), and
     > __oprofile_cpu_pmu only contains one of these. So this conversion is not
     > correct.
     >
     > We were relying on the notifier list implicitly containing a list of
     > those PMUs. It seems like we need an explicit list here.
     >
     > We keep __oprofile_cpu_pmu around for legacy 32-bit users of OProfile
     > (on non-hetereogeneous systems), and that's all that the variable should
     > be used for.
    
    Introduce arm_pmu_list to correctly handle multiple PMUs in the system.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-tip-commits@vger.kernel.org
    Cc: rt@linutronix.de
    Link: http://lkml.kernel.org/r/20160719111733.GA22911@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index e6ed34eb2b2b..e18843809eec 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -109,6 +109,7 @@ struct arm_pmu {
 	DECLARE_BITMAP(pmceid_bitmap, ARMV8_PMUV3_MAX_COMMON_EVENTS);
 	struct platform_device	*plat_device;
 	struct pmu_hw_events	__percpu *hw_events;
+	struct list_head	entry;
 	struct notifier_block	cpu_pm_nb;
 };
 

commit 7d88eb695a1f5f67820e02999b949d5cfa080442
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 13 17:16:36 2016 +0000

    arm/perf: Convert to hotplug state machine
    
    Straight forward conversion w/o bells and whistles.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Reviewed-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: rt@linutronix.de
    Link: http://lkml.kernel.org/r/20160713153335.794097159@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index d28ac05c7f92..e6ed34eb2b2b 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -109,7 +109,6 @@ struct arm_pmu {
 	DECLARE_BITMAP(pmceid_bitmap, ARMV8_PMUV3_MAX_COMMON_EVENTS);
 	struct platform_device	*plat_device;
 	struct pmu_hw_events	__percpu *hw_events;
-	struct notifier_block	hotplug_nb;
 	struct notifier_block	cpu_pm_nb;
 };
 

commit 4b1a9e6934ec6e38138c66c2f73cf6f3695a9c6c
Author: Ashok Kumar <ashoks@broadcom.com>
Date:   Thu Apr 21 05:58:44 2016 -0700

    arm64/perf: Filter common events based on PMCEIDn_EL0
    
    The complete common architectural and micro-architectural
    event number structure is filtered based on PMCEIDn_EL0 and
    exposed to /sys using is_visibile function pointer in events
    attribute_group.
    To filter the events in is_visible function, pmceid based bitmap
    is stored in arm_pmu structure and the id field from
    perf_pmu_events_attr is used to check against the bitmap.
    
    The function which derives event bitmap from PMCEIDn_EL0 is
    executed in the cpus, which has the pmu being initialized,
    for heterogeneous pmu support.
    
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Ashok Kumar <ashoks@broadcom.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index 4196c90a3c88..d28ac05c7f92 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -105,6 +105,8 @@ struct arm_pmu {
 	struct mutex	reserve_mutex;
 	u64		max_period;
 	bool		secure_access; /* 32-bit ARM only */
+#define ARMV8_PMUV3_MAX_COMMON_EVENTS 0x40
+	DECLARE_BITMAP(pmceid_bitmap, ARMV8_PMUV3_MAX_COMMON_EVENTS);
 	struct platform_device	*plat_device;
 	struct pmu_hw_events	__percpu *hw_events;
 	struct notifier_block	hotplug_nb;

commit da4e4f18afe0f3729d68f3785c5802f786d36e34
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Tue Feb 23 18:22:39 2016 +0000

    drivers/perf: arm_pmu: implement CPU_PM notifier
    
    When a CPU is suspended (either through suspend-to-RAM or CPUidle),
    its PMU registers content can be lost, which means that counters
    registers values that were initialized on power down entry have to be
    reprogrammed on power-up to make sure the counters set-up is preserved
    (ie on power-up registers take the reset values on Cold or Warm reset,
    which can be architecturally UNKNOWN).
    
    To guarantee seamless profiling conditions across a core power down
    this patch adds a CPU PM notifier to ARM pmus, that upon CPU PM
    entry/exit from low-power states saves/restores the pmu registers
    set-up (by using the ARM perf API), so that the power-down/up cycle does
    not affect the perf behaviour (apart from a black-out period between
    power-up/down CPU PM notifications that is unavoidable).
    
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Acked-by: Ashwin Chaugule <ashwin.chaugule@linaro.org>
    Acked-by: Kevin Hilman <khilman@baylibre.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index 2d5eaaa90078..4196c90a3c88 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -108,6 +108,7 @@ struct arm_pmu {
 	struct platform_device	*plat_device;
 	struct pmu_hw_events	__percpu *hw_events;
 	struct notifier_block	hotplug_nb;
+	struct notifier_block	cpu_pm_nb;
 };
 
 #define to_arm_pmu(p) (container_of(p, struct arm_pmu, pmu))

commit 8d1a0ae724ad74ef7946a45e3b2d3e01f39df02b
Author: Martin Fuzzey <mfuzzey@parkeon.com>
Date:   Wed Jan 13 23:36:26 2016 -0500

    ARM: perf: Set ARMv7 SDER SUNIDEN bit
    
    ARMv7 counters other than the CPU cycle counter only work if the Secure
    Debug Enable Register (SDER) SUNIDEN bit is set.
    
    Since access to the SDER is only possible in secure state, it will
    only be done if the device tree property "secure-reg-access" is set.
    
    Without this:
    
     Performance counter stats for 'sleep 1':
    
              14606094 cycles                    #    0.000 GHz
                     0 instructions              #    0.00  insns per cycle
    
    After applying:
    
     Performance counter stats for 'sleep 1':
    
               5843809 cycles
               2566484 instructions              #    0.44  insns per cycle
    
           1.020144000 seconds time elapsed
    
    Some platforms (eg i.MX53) may also need additional platform specific
    setup.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Martin Fuzzey <mfuzzey@parkeon.com>
    Signed-off-by: Pooya Keshavarzi <Pooya.Keshavarzi@de.bosch.com>
    Signed-off-by: George G. Davis <george_davis@mentor.com>
    [will: add warning if property is found on arm64]
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index 83b5e34c6580..2d5eaaa90078 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -104,6 +104,7 @@ struct arm_pmu {
 	atomic_t	active_events;
 	struct mutex	reserve_mutex;
 	u64		max_period;
+	bool		secure_access; /* 32-bit ARM only */
 	struct platform_device	*plat_device;
 	struct pmu_hw_events	__percpu *hw_events;
 	struct notifier_block	hotplug_nb;

commit b916b785af99088916a122cb37de1bda3fa7f70e
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Wed Oct 28 12:32:17 2015 +0000

    drivers/perf: kill armpmu_register
    
    Nothing outside of drivers/perf/arm_pmu.c should call armpmu_register
    any more, so it no longer needs to be in include/linux/perf/arm_pmu.h.
    Additionally, by folding it in to arm_pmu_device_probe we can allow
    drivers to override struct pmu fields without getting blatted by the
    armpmu code.
    
    This patch folds armpmu_register into arm_pmu_device_probe. The logging
    to the console is moved to after the PMU is successfully registered with
    the core perf code.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Suggested-by: Will Deacon <will.deacon@arm.com>
    Cc: Drew Richardson <drew.richardson@arm.com>
    Cc: Pawel Moll <pawel.moll@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
index bfa673bb822d..83b5e34c6580 100644
--- a/include/linux/perf/arm_pmu.h
+++ b/include/linux/perf/arm_pmu.h
@@ -111,8 +111,6 @@ struct arm_pmu {
 
 #define to_arm_pmu(p) (container_of(p, struct arm_pmu, pmu))
 
-int armpmu_register(struct arm_pmu *armpmu, int type);
-
 u64 armpmu_event_update(struct perf_event *event);
 
 int armpmu_event_set_period(struct perf_event *event);

commit fa8ad7889d83bcf0a6cdbf6d3622f3ec019cde14
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Jul 6 12:23:53 2015 +0100

    arm: perf: factor arm_pmu core out to drivers
    
    To enable sharing of the arm_pmu code with arm64, this patch factors it
    out to drivers/perf/. A new drivers/perf directory is added for
    performance monitor drivers to live under.
    
    MAINTAINERS is updated accordingly. Files added previously without a
    corresponsing MAINTAINERS update (perf_regs.c, perf_callchain.c, and
    perf_event.h) are also added.
    
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    [will: augmented Kconfig help slightly]
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/perf/arm_pmu.h b/include/linux/perf/arm_pmu.h
new file mode 100644
index 000000000000..bfa673bb822d
--- /dev/null
+++ b/include/linux/perf/arm_pmu.h
@@ -0,0 +1,154 @@
+/*
+ *  linux/arch/arm/include/asm/pmu.h
+ *
+ *  Copyright (C) 2009 picoChip Designs Ltd, Jamie Iles
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __ARM_PMU_H__
+#define __ARM_PMU_H__
+
+#include <linux/interrupt.h>
+#include <linux/perf_event.h>
+
+#include <asm/cputype.h>
+
+/*
+ * struct arm_pmu_platdata - ARM PMU platform data
+ *
+ * @handle_irq: an optional handler which will be called from the
+ *	interrupt and passed the address of the low level handler,
+ *	and can be used to implement any platform specific handling
+ *	before or after calling it.
+ */
+struct arm_pmu_platdata {
+	irqreturn_t (*handle_irq)(int irq, void *dev,
+				  irq_handler_t pmu_handler);
+};
+
+#ifdef CONFIG_ARM_PMU
+
+/*
+ * The ARMv7 CPU PMU supports up to 32 event counters.
+ */
+#define ARMPMU_MAX_HWEVENTS		32
+
+#define HW_OP_UNSUPPORTED		0xFFFF
+#define C(_x)				PERF_COUNT_HW_CACHE_##_x
+#define CACHE_OP_UNSUPPORTED		0xFFFF
+
+#define PERF_MAP_ALL_UNSUPPORTED					\
+	[0 ... PERF_COUNT_HW_MAX - 1] = HW_OP_UNSUPPORTED
+
+#define PERF_CACHE_MAP_ALL_UNSUPPORTED					\
+[0 ... C(MAX) - 1] = {							\
+	[0 ... C(OP_MAX) - 1] = {					\
+		[0 ... C(RESULT_MAX) - 1] = CACHE_OP_UNSUPPORTED,	\
+	},								\
+}
+
+/* The events for a given PMU register set. */
+struct pmu_hw_events {
+	/*
+	 * The events that are active on the PMU for the given index.
+	 */
+	struct perf_event	*events[ARMPMU_MAX_HWEVENTS];
+
+	/*
+	 * A 1 bit for an index indicates that the counter is being used for
+	 * an event. A 0 means that the counter can be used.
+	 */
+	DECLARE_BITMAP(used_mask, ARMPMU_MAX_HWEVENTS);
+
+	/*
+	 * Hardware lock to serialize accesses to PMU registers. Needed for the
+	 * read/modify/write sequences.
+	 */
+	raw_spinlock_t		pmu_lock;
+
+	/*
+	 * When using percpu IRQs, we need a percpu dev_id. Place it here as we
+	 * already have to allocate this struct per cpu.
+	 */
+	struct arm_pmu		*percpu_pmu;
+};
+
+struct arm_pmu {
+	struct pmu	pmu;
+	cpumask_t	active_irqs;
+	cpumask_t	supported_cpus;
+	int		*irq_affinity;
+	char		*name;
+	irqreturn_t	(*handle_irq)(int irq_num, void *dev);
+	void		(*enable)(struct perf_event *event);
+	void		(*disable)(struct perf_event *event);
+	int		(*get_event_idx)(struct pmu_hw_events *hw_events,
+					 struct perf_event *event);
+	void		(*clear_event_idx)(struct pmu_hw_events *hw_events,
+					 struct perf_event *event);
+	int		(*set_event_filter)(struct hw_perf_event *evt,
+					    struct perf_event_attr *attr);
+	u32		(*read_counter)(struct perf_event *event);
+	void		(*write_counter)(struct perf_event *event, u32 val);
+	void		(*start)(struct arm_pmu *);
+	void		(*stop)(struct arm_pmu *);
+	void		(*reset)(void *);
+	int		(*request_irq)(struct arm_pmu *, irq_handler_t handler);
+	void		(*free_irq)(struct arm_pmu *);
+	int		(*map_event)(struct perf_event *event);
+	int		num_events;
+	atomic_t	active_events;
+	struct mutex	reserve_mutex;
+	u64		max_period;
+	struct platform_device	*plat_device;
+	struct pmu_hw_events	__percpu *hw_events;
+	struct notifier_block	hotplug_nb;
+};
+
+#define to_arm_pmu(p) (container_of(p, struct arm_pmu, pmu))
+
+int armpmu_register(struct arm_pmu *armpmu, int type);
+
+u64 armpmu_event_update(struct perf_event *event);
+
+int armpmu_event_set_period(struct perf_event *event);
+
+int armpmu_map_event(struct perf_event *event,
+		     const unsigned (*event_map)[PERF_COUNT_HW_MAX],
+		     const unsigned (*cache_map)[PERF_COUNT_HW_CACHE_MAX]
+						[PERF_COUNT_HW_CACHE_OP_MAX]
+						[PERF_COUNT_HW_CACHE_RESULT_MAX],
+		     u32 raw_event_mask);
+
+struct pmu_probe_info {
+	unsigned int cpuid;
+	unsigned int mask;
+	int (*init)(struct arm_pmu *);
+};
+
+#define PMU_PROBE(_cpuid, _mask, _fn)	\
+{					\
+	.cpuid = (_cpuid),		\
+	.mask = (_mask),		\
+	.init = (_fn),			\
+}
+
+#define ARM_PMU_PROBE(_cpuid, _fn) \
+	PMU_PROBE(_cpuid, ARM_CPU_PART_MASK, _fn)
+
+#define ARM_PMU_XSCALE_MASK	((0xff << 24) | ARM_CPU_XSCALE_ARCH_MASK)
+
+#define XSCALE_PMU_PROBE(_version, _fn) \
+	PMU_PROBE(ARM_CPU_IMP_INTEL << 24 | _version, ARM_PMU_XSCALE_MASK, _fn)
+
+int arm_pmu_device_probe(struct platform_device *pdev,
+			 const struct of_device_id *of_table,
+			 const struct pmu_probe_info *probe_table);
+
+#endif /* CONFIG_ARM_PMU */
+
+#endif /* __ARM_PMU_H__ */
