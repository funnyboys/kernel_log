commit 2cce09eb11228386260a1b73133aee41f4bb33b1
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sat Dec 28 23:26:15 2019 +0100

    mfd: dbx500-prcmu: Drop DSI pll clock functions
    
    The DSI PLLs are handled by the generic clock framework
    since ages, this code is completely unused and misleading.
    Delete it.
    
    Cc: Stephan Gerhold <stephan@gerhold.net>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index 812b6c3c4ef6..e6ee2ec35de9 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -321,16 +321,6 @@ static inline bool prcmu_is_ac_wake_requested(void)
 	return db8500_prcmu_is_ac_wake_requested();
 }
 
-static inline int prcmu_disable_dsipll(void)
-{
-	return db8500_prcmu_disable_dsipll();
-}
-
-static inline int prcmu_enable_dsipll(void)
-{
-	return db8500_prcmu_enable_dsipll();
-}
-
 static inline int prcmu_config_esram0_deep_sleep(u8 state)
 {
 	return db8500_prcmu_config_esram0_deep_sleep(state);
@@ -506,16 +496,6 @@ static inline bool prcmu_is_ac_wake_requested(void)
 	return false;
 }
 
-static inline int prcmu_disable_dsipll(void)
-{
-	return 0;
-}
-
-static inline int prcmu_enable_dsipll(void)
-{
-	return 0;
-}
-
 static inline int prcmu_config_esram0_deep_sleep(u8 state)
 {
 	return 0;

commit f41810921bdca37161a63f689cdcb36155f0fad6
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sat Dec 28 23:26:14 2019 +0100

    mfd: dbx500-prcmu: Drop set_display_clocks()
    
    The display clocks are handled by the generic clock framework
    since ages, this code is completely unused and misleading.
    Delete it.
    
    Cc: Stephan Gerhold <stephan@gerhold.net>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index e2571040c7e8..812b6c3c4ef6 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -321,11 +321,6 @@ static inline bool prcmu_is_ac_wake_requested(void)
 	return db8500_prcmu_is_ac_wake_requested();
 }
 
-static inline int prcmu_set_display_clocks(void)
-{
-	return db8500_prcmu_set_display_clocks();
-}
-
 static inline int prcmu_disable_dsipll(void)
 {
 	return db8500_prcmu_disable_dsipll();
@@ -511,11 +506,6 @@ static inline bool prcmu_is_ac_wake_requested(void)
 	return false;
 }
 
-static inline int prcmu_set_display_clocks(void)
-{
-	return 0;
-}
-
 static inline int prcmu_disable_dsipll(void)
 {
 	return 0;

commit 22fb3ad0cc5f578398953ddcab9c8239a08caccd
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sat Oct 26 23:47:32 2019 +0200

    mfd: db8500-prcmu: Support U8420-sysclk firmware
    
    There is a distinct version of the Ux500 U8420 variant
    with "sysclk", as can be seen from the vendor code that
    didn't make it upstream, this firmware lacks the
    ULPPLL (ultra-low power phase locked loop) which in
    effect means that the timer clock is instead wired to
    the 32768 Hz always-on clock.
    
    This has some repercussions when enabling the timer
    clock as the code as it stands will disable the timer
    clock on these platforms (lacking the so-called
    "doze mode") and obtaining the wrong rate of the timer
    clock.
    
    The timer frequency is of course needed very early in
    the boot, and as a consequence, we need to shuffle
    around the early PRCMU init code: whereas in the past
    we did not need to look up the PRCMU firmware version
    in the early init, but now we need to know the version
    before the core system timers are registered so we
    restructure the platform callbacks to the PRCMU so as
    not to take any arguments and instead look up the
    resources it needs directly from the device tree
    when initializing.
    
    As we do not yet support any platforms using this
    firmware it is not a regression, but as PostmarketOS
    is starting to support products with this firmware we
    need to fix this up.
    
    The low rate of 32kHz also makes the MTU timer unsuitable
    as delay timer but this needs to be fixed in a separate
    patch.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Stephan Gerhold <stephan@gerhold.net>
    Acked-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index 238401a50d0b..e2571040c7e8 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -190,6 +190,7 @@ enum ddr_pwrst {
 #define PRCMU_FW_PROJECT_U8500_MBL2	12 /* Customer specific */
 #define PRCMU_FW_PROJECT_U8520		13
 #define PRCMU_FW_PROJECT_U8420		14
+#define PRCMU_FW_PROJECT_U8420_SYSCLK	17
 #define PRCMU_FW_PROJECT_A9420		20
 /* [32..63] 9540 and derivatives */
 #define PRCMU_FW_PROJECT_U9540		32
@@ -211,9 +212,9 @@ struct prcmu_fw_version {
 
 #if defined(CONFIG_UX500_SOC_DB8500)
 
-static inline void prcmu_early_init(u32 phy_base, u32 size)
+static inline void prcmu_early_init(void)
 {
-	return db8500_prcmu_early_init(phy_base, size);
+	return db8500_prcmu_early_init();
 }
 
 static inline int prcmu_set_power_state(u8 state, bool keep_ulp_clk,
@@ -401,7 +402,7 @@ static inline int prcmu_config_a9wdog(u8 num, bool sleep_auto_off)
 }
 #else
 
-static inline void prcmu_early_init(u32 phy_base, u32 size) {}
+static inline void prcmu_early_init(void) {}
 
 static inline int prcmu_set_power_state(u8 state, bool keep_ulp_clk,
 	bool keep_ap_pll)

commit 0376148f303c7e87ff3577dac7d76b93e3a5779a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:24 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 197
    
    Based on 1 normalized pattern(s):
    
      license terms gnu general public license v2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 37 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170027.724130665@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index 2e2c6a63a065..238401a50d0b 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -1,8 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (C) ST Ericsson SA 2011
  *
- * License Terms: GNU General Public License v2
- *
  * STE Ux500 PRCMU API
  */
 #ifndef __MACH_PRCMU_H

commit 45ff2b685a6e8588ed637ba711b9a42ad1963066
Author: Lee Jones <lee.jones@linaro.org>
Date:   Wed Sep 14 11:51:42 2016 +0100

    mfd: db8500-prcmu: Remove unused *prcmu_set_ddr_opp() calls
    
    There are no call sites for these functions.  Strip them out.
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index 5d374601404c..2e2c6a63a065 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -269,10 +269,6 @@ unsigned long prcmu_clock_rate(u8 clock);
 long prcmu_round_clock_rate(u8 clock, unsigned long rate);
 int prcmu_set_clock_rate(u8 clock, unsigned long rate);
 
-static inline int prcmu_set_ddr_opp(u8 opp)
-{
-	return db8500_prcmu_set_ddr_opp(opp);
-}
 static inline int prcmu_get_ddr_opp(void)
 {
 	return db8500_prcmu_get_ddr_opp();
@@ -489,11 +485,6 @@ static inline int prcmu_get_arm_opp(void)
 	return ARM_100_OPP;
 }
 
-static inline int prcmu_set_ddr_opp(u8 opp)
-{
-	return 0;
-}
-
 static inline int prcmu_get_ddr_opp(void)
 {
 	return DDR_100_OPP;

commit 4e657946cbf68998b51b331375a1209e90792fe4
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Mar 18 16:53:31 2016 +0100

    mfd: db8500 stop passing around platform data
    
    Except for the constant DB8500_PRCMU_FW_VERSION_OFFSET number, nothing
    is ever passed through the platform data and used in a driver, so we
    can simply stop passing it around.
    
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index bf5109d38a26..5d374601404c 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -178,16 +178,6 @@ enum ddr_pwrst {
 
 #define DB8500_PRCMU_LEGACY_OFFSET		0xDD4
 
-struct prcmu_pdata
-{
-	bool enable_set_ddr_opp;
-	bool enable_ape_opp_100_voltage;
-	struct ab8500_platform_data *ab_platdata;
-	u32 version_offset;
-	u32 legacy_offset;
-	u32 adt_offset;
-};
-
 #define PRCMU_FW_PROJECT_U8500		2
 #define PRCMU_FW_PROJECT_U8400		3
 #define PRCMU_FW_PROJECT_U9500		4 /* Customer specific */

commit f864c46aae4cb6aed09e98615c427fcc4f1de104
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Feb 4 00:35:56 2014 +0100

    mfd: dbx500/abx500: root out hardcoded IRQ assignments
    
    The DBx500 and ABx500 should be getting their IRQs from the
    device tree and nowhere else. Get rid of all the static assignments
    everywhere, delete it from the driver, platform data and the
    board files in one swift strike.
    
    Lots of cross-dependencies in the MFD drivers for PRCMU and
    AB8500 makes it necessary to strike everywhere at once to
    eradicate IRQs passed as resources and platform data to the left
    and right around the platform.
    
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Samuel Ortiz <sameo@linux.intel.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index 060e11256fbc..bf5109d38a26 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -183,8 +183,6 @@ struct prcmu_pdata
 	bool enable_set_ddr_opp;
 	bool enable_ape_opp_100_voltage;
 	struct ab8500_platform_data *ab_platdata;
-	int ab_irq;
-	int irq_base;
 	u32 version_offset;
 	u32 legacy_offset;
 	u32 adt_offset;

commit 67f13daadccebf95c04f73db7b78cead844540bd
Author: Lee Jones <lee.jones@linaro.org>
Date:   Thu Jun 6 11:50:47 2013 +0100

    mfd: dbx500-prcmu: Move PRCMU numerical clock identifiers into DT include file
    
    These are required to request DBx500 PRCMU clocks from Device Tree. The
    numbers used are taken directly from the Hardware Specification document.
    We're moving them from the DBx500 PRCMU include file into the DT include
    directory and referencing them from the former via a #include.
    
    Acked-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index 87667d48602b..060e11256fbc 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -12,6 +12,8 @@
 #include <linux/notifier.h>
 #include <linux/err.h>
 
+#include <dt-bindings/mfd/dbx500-prcmu.h> /* For clock identifiers */
+
 /* Offset for the firmware version within the TCPM */
 #define DB8500_PRCMU_FW_VERSION_OFFSET 0xA4
 #define DBX540_PRCMU_FW_VERSION_OFFSET 0xA8
@@ -94,81 +96,6 @@ enum prcmu_wakeup_index {
 #define PRCMU_CLKSRC_ARMCLKFIX		0x46
 #define PRCMU_CLKSRC_HDMICLK		0x47
 
-/*
- * Clock identifiers.
- */
-#define ARMCLK			0
-#define PRCMU_ACLK		1
-#define PRCMU_SVAMMCSPCLK 	2
-#define PRCMU_SDMMCHCLK 	2  /* DBx540 only. */
-#define PRCMU_SIACLK 		3
-#define PRCMU_SIAMMDSPCLK 	3  /* DBx540 only. */
-#define PRCMU_SGACLK 		4
-#define PRCMU_UARTCLK 		5
-#define PRCMU_MSP02CLK 		6
-#define PRCMU_MSP1CLK 		7
-#define PRCMU_I2CCLK 		8
-#define PRCMU_SDMMCCLK 		9
-#define PRCMU_SLIMCLK 		10
-#define PRCMU_CAMCLK 		10 /* DBx540 only. */
-#define PRCMU_PER1CLK 		11
-#define PRCMU_PER2CLK 		12
-#define PRCMU_PER3CLK 		13
-#define PRCMU_PER5CLK 		14
-#define PRCMU_PER6CLK 		15
-#define PRCMU_PER7CLK 		16
-#define PRCMU_LCDCLK 		17
-#define PRCMU_BMLCLK 		18
-#define PRCMU_HSITXCLK 		19
-#define PRCMU_HSIRXCLK 		20
-#define PRCMU_HDMICLK		21
-#define PRCMU_APEATCLK 		22
-#define PRCMU_APETRACECLK 	23
-#define PRCMU_MCDECLK  	 	24
-#define PRCMU_IPI2CCLK  	25
-#define PRCMU_DSIALTCLK  	26
-#define PRCMU_DMACLK  	 	27
-#define PRCMU_B2R2CLK  	 	28
-#define PRCMU_TVCLK  	 	29
-#define SPARE_UNIPROCLK  	30
-#define PRCMU_SSPCLK  	 	31
-#define PRCMU_RNGCLK  	 	32
-#define PRCMU_UICCCLK  	 	33
-#define PRCMU_G1CLK             34 /* DBx540 only. */
-#define PRCMU_HVACLK            35 /* DBx540 only. */
-#define PRCMU_SPARE1CLK	 	36
-#define PRCMU_SPARE2CLK	 	37
-
-#define PRCMU_NUM_REG_CLOCKS  	38
-
-#define PRCMU_RTCCLK  	 	PRCMU_NUM_REG_CLOCKS
-#define PRCMU_SYSCLK  	 	39
-#define PRCMU_CDCLK  	 	40
-#define PRCMU_TIMCLK  	 	41
-#define PRCMU_PLLSOC0  	 	42
-#define PRCMU_PLLSOC1  	 	43
-#define PRCMU_ARMSS  	 	44
-#define PRCMU_PLLDDR  	 	45
-#define PRCMU_BML8580CLK        46
-
-/* DSI Clocks */
-#define PRCMU_PLLDSI  	 	47
-#define PRCMU_DSI0CLK 	  	48
-#define PRCMU_DSI1CLK  	 	49
-#define PRCMU_DSI0ESCCLK  	50
-#define PRCMU_DSI1ESCCLK  	51
-#define PRCMU_DSI2ESCCLK  	52
-
-/* LCD DSI PLL - Ux540 only */
-#define PRCMU_PLLDSI_LCD        53
-#define PRCMU_DSI0CLK_LCD       54
-#define PRCMU_DSI1CLK_LCD       55
-#define PRCMU_DSI0ESCCLK_LCD    56
-#define PRCMU_DSI1ESCCLK_LCD    57
-#define PRCMU_DSI2ESCCLK_LCD    58
-
-#define PRCMU_NUM_CLKS  	59
-
 /**
  * enum prcmu_wdog_id - PRCMU watchdog IDs
  * @PRCMU_WDOG_ALL: use all timers

commit b0f4fe1edf6abbc81500d661f730cebd653a838c
Author: Lee Jones <lee.jones@linaro.org>
Date:   Thu Jun 6 11:57:27 2013 +0100

    mfd: dbx500-prcmu: Correctly reorder PRCMU clock identifiers
    
    ... as stipulated by the Hardware Specification document.
    
    Acked-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index ca0790fba2f5..87667d48602b 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -97,70 +97,77 @@ enum prcmu_wakeup_index {
 /*
  * Clock identifiers.
  */
-enum prcmu_clock {
-	PRCMU_SGACLK,
-	PRCMU_UARTCLK,
-	PRCMU_MSP02CLK,
-	PRCMU_MSP1CLK,
-	PRCMU_I2CCLK,
-	PRCMU_SDMMCCLK,
-	PRCMU_SPARE1CLK,
-	PRCMU_SLIMCLK,
-	PRCMU_PER1CLK,
-	PRCMU_PER2CLK,
-	PRCMU_PER3CLK,
-	PRCMU_PER5CLK,
-	PRCMU_PER6CLK,
-	PRCMU_PER7CLK,
-	PRCMU_LCDCLK,
-	PRCMU_BMLCLK,
-	PRCMU_HSITXCLK,
-	PRCMU_HSIRXCLK,
-	PRCMU_HDMICLK,
-	PRCMU_APEATCLK,
-	PRCMU_APETRACECLK,
-	PRCMU_MCDECLK,
-	PRCMU_IPI2CCLK,
-	PRCMU_DSIALTCLK,
-	PRCMU_DMACLK,
-	PRCMU_B2R2CLK,
-	PRCMU_TVCLK,
-	PRCMU_SSPCLK,
-	PRCMU_RNGCLK,
-	PRCMU_UICCCLK,
-	PRCMU_PWMCLK,
-	PRCMU_IRDACLK,
-	PRCMU_IRRCCLK,
-	PRCMU_SIACLK,
-	PRCMU_SVACLK,
-	PRCMU_ACLK,
-	PRCMU_HVACLK, /* Ux540 only */
-	PRCMU_G1CLK, /* Ux540 only */
-	PRCMU_SDMMCHCLK,
-	PRCMU_CAMCLK,
-	PRCMU_BML8580CLK,
-	PRCMU_NUM_REG_CLOCKS,
-	PRCMU_SYSCLK = PRCMU_NUM_REG_CLOCKS,
-	PRCMU_CDCLK,
-	PRCMU_TIMCLK,
-	PRCMU_PLLSOC0,
-	PRCMU_PLLSOC1,
-	PRCMU_ARMSS,
-	PRCMU_PLLDDR,
-	PRCMU_PLLDSI,
-	PRCMU_DSI0CLK,
-	PRCMU_DSI1CLK,
-	PRCMU_DSI0ESCCLK,
-	PRCMU_DSI1ESCCLK,
-	PRCMU_DSI2ESCCLK,
-	/* LCD DSI PLL - Ux540 only */
-	PRCMU_PLLDSI_LCD,
-	PRCMU_DSI0CLK_LCD,
-	PRCMU_DSI1CLK_LCD,
-	PRCMU_DSI0ESCCLK_LCD,
-	PRCMU_DSI1ESCCLK_LCD,
-	PRCMU_DSI2ESCCLK_LCD,
-};
+#define ARMCLK			0
+#define PRCMU_ACLK		1
+#define PRCMU_SVAMMCSPCLK 	2
+#define PRCMU_SDMMCHCLK 	2  /* DBx540 only. */
+#define PRCMU_SIACLK 		3
+#define PRCMU_SIAMMDSPCLK 	3  /* DBx540 only. */
+#define PRCMU_SGACLK 		4
+#define PRCMU_UARTCLK 		5
+#define PRCMU_MSP02CLK 		6
+#define PRCMU_MSP1CLK 		7
+#define PRCMU_I2CCLK 		8
+#define PRCMU_SDMMCCLK 		9
+#define PRCMU_SLIMCLK 		10
+#define PRCMU_CAMCLK 		10 /* DBx540 only. */
+#define PRCMU_PER1CLK 		11
+#define PRCMU_PER2CLK 		12
+#define PRCMU_PER3CLK 		13
+#define PRCMU_PER5CLK 		14
+#define PRCMU_PER6CLK 		15
+#define PRCMU_PER7CLK 		16
+#define PRCMU_LCDCLK 		17
+#define PRCMU_BMLCLK 		18
+#define PRCMU_HSITXCLK 		19
+#define PRCMU_HSIRXCLK 		20
+#define PRCMU_HDMICLK		21
+#define PRCMU_APEATCLK 		22
+#define PRCMU_APETRACECLK 	23
+#define PRCMU_MCDECLK  	 	24
+#define PRCMU_IPI2CCLK  	25
+#define PRCMU_DSIALTCLK  	26
+#define PRCMU_DMACLK  	 	27
+#define PRCMU_B2R2CLK  	 	28
+#define PRCMU_TVCLK  	 	29
+#define SPARE_UNIPROCLK  	30
+#define PRCMU_SSPCLK  	 	31
+#define PRCMU_RNGCLK  	 	32
+#define PRCMU_UICCCLK  	 	33
+#define PRCMU_G1CLK             34 /* DBx540 only. */
+#define PRCMU_HVACLK            35 /* DBx540 only. */
+#define PRCMU_SPARE1CLK	 	36
+#define PRCMU_SPARE2CLK	 	37
+
+#define PRCMU_NUM_REG_CLOCKS  	38
+
+#define PRCMU_RTCCLK  	 	PRCMU_NUM_REG_CLOCKS
+#define PRCMU_SYSCLK  	 	39
+#define PRCMU_CDCLK  	 	40
+#define PRCMU_TIMCLK  	 	41
+#define PRCMU_PLLSOC0  	 	42
+#define PRCMU_PLLSOC1  	 	43
+#define PRCMU_ARMSS  	 	44
+#define PRCMU_PLLDDR  	 	45
+#define PRCMU_BML8580CLK        46
+
+/* DSI Clocks */
+#define PRCMU_PLLDSI  	 	47
+#define PRCMU_DSI0CLK 	  	48
+#define PRCMU_DSI1CLK  	 	49
+#define PRCMU_DSI0ESCCLK  	50
+#define PRCMU_DSI1ESCCLK  	51
+#define PRCMU_DSI2ESCCLK  	52
+
+/* LCD DSI PLL - Ux540 only */
+#define PRCMU_PLLDSI_LCD        53
+#define PRCMU_DSI0CLK_LCD       54
+#define PRCMU_DSI1CLK_LCD       55
+#define PRCMU_DSI0ESCCLK_LCD    56
+#define PRCMU_DSI1ESCCLK_LCD    57
+#define PRCMU_DSI2ESCCLK_LCD    58
+
+#define PRCMU_NUM_CLKS  	59
 
 /**
  * enum prcmu_wdog_id - PRCMU watchdog IDs

commit 54e300339cce6d4be665e6bbd736123dd0f15888
Author: Philippe Begnic <philippe.begnic@st.com>
Date:   Mon May 27 14:41:31 2013 +0200

    mfd: db8500: Update BML clock register for db8580
    
    BML clock register address in DB8580 has changed.Defined a new address
    under different name for DB8580.
    
    Signed-off-by: Philippe Begnic <philippe.begnic@st.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index d0ba355cc55f..ca0790fba2f5 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -138,6 +138,7 @@ enum prcmu_clock {
 	PRCMU_G1CLK, /* Ux540 only */
 	PRCMU_SDMMCHCLK,
 	PRCMU_CAMCLK,
+	PRCMU_BML8580CLK,
 	PRCMU_NUM_REG_CLOCKS,
 	PRCMU_SYSCLK = PRCMU_NUM_REG_CLOCKS,
 	PRCMU_CDCLK,

commit 852bbba96773777efc2b932f2c5939c6fbf252da
Author: Philippe Begnic <philippe.begnic@st.com>
Date:   Mon May 27 14:41:30 2013 +0200

    mfd: db8500: Update register definition for u8540 clock
    
    PRCMU and ab8500 registers updated for u8540
    
    Signed-off-by: Philippe Begnic <philippe.begnic@st.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index 689e6a0d9c99..d0ba355cc55f 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -134,6 +134,10 @@ enum prcmu_clock {
 	PRCMU_SIACLK,
 	PRCMU_SVACLK,
 	PRCMU_ACLK,
+	PRCMU_HVACLK, /* Ux540 only */
+	PRCMU_G1CLK, /* Ux540 only */
+	PRCMU_SDMMCHCLK,
+	PRCMU_CAMCLK,
 	PRCMU_NUM_REG_CLOCKS,
 	PRCMU_SYSCLK = PRCMU_NUM_REG_CLOCKS,
 	PRCMU_CDCLK,
@@ -148,6 +152,13 @@ enum prcmu_clock {
 	PRCMU_DSI0ESCCLK,
 	PRCMU_DSI1ESCCLK,
 	PRCMU_DSI2ESCCLK,
+	/* LCD DSI PLL - Ux540 only */
+	PRCMU_PLLDSI_LCD,
+	PRCMU_DSI0CLK_LCD,
+	PRCMU_DSI1CLK_LCD,
+	PRCMU_DSI0ESCCLK_LCD,
+	PRCMU_DSI1ESCCLK_LCD,
+	PRCMU_DSI2ESCCLK_LCD,
 };
 
 /**

commit 55b175d7e6327939df82592ef279c534da323354
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Mar 21 22:51:07 2013 +0100

    ARM: ux500: split out prcmu initialization
    
    This untangles the final bits of the prcmu code from the platform
    code:
    
    * The IRQ_PRCMU_* definitions move from irqs-db8500.h into prcmu.c
      because they are only of local significance.
    * u8500_thsens_device goes into the prcmu, because it uses a PRCMU
      IRQ that the platform does not see.
    * IRQ_DB8500_AB8500 and IRQ_PRCMU_BASE go into the platform data
      because the PRCMU does not see it.
    
    Acked-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    [Fixed a oneliner bug]
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index fc43cecc9449..689e6a0d9c99 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -237,6 +237,8 @@ struct prcmu_pdata
 	bool enable_set_ddr_opp;
 	bool enable_ape_opp_100_voltage;
 	struct ab8500_platform_data *ab_platdata;
+	int ab_irq;
+	int irq_base;
 	u32 version_offset;
 	u32 legacy_offset;
 	u32 adt_offset;

commit 1e22a8c614a5d8c29d0882de21ce327673b71fca
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Mar 19 15:36:12 2013 +0100

    ARM: ux500: move PM-related PRCMU functions to machine
    
    We are trying to decompose and decentralize the code in
    the DB8500 PRCMU out into subdrivers. The code moved in
    this patch concerns a group of functions used for
    decoupling and recoupling the IRQs from the GIC. During
    sleep and idle the Ux500 system will transfer all IRQ
    handling to the PRCMU using these functions.
    
    Basically we are left with the two alternatives of code
    placement as:
    
    - arch/arm/mach-ux500/pm.c - this because the code is
      closely related to the GIC, and takes ownership of
      some of the registers from the PRCMU related to this
      PM functionality.
    
    - drivers/mfd/db8500-prcmu-pm.c - because the code is
      affecting stuff in the PRCMU register range. But then
      this code needs to remap and handle GIC registers.
    
    This patch implementation is taking the first approach.
    
    Currently the cpuidle driver is the only piece of code
    using this set of functions, but it will later also be
    used by the suspend/resume code which is currently under
    review.
    
    The header file is moved to:
    <linux/platform_data/arm-ux500-pm.h>
    The function prototypes need to be placed in a globally
    visible header since the CPUidle code is planned to move
    out to drivers/cpuidle.
    
    Acked-by: Samuel Ortiz <sameo@linux.intel.com>
    Acked-by: Rickard Andersson <rickard.andersson@stericsson.com>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index 8c546cbcb9a6..fc43cecc9449 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -293,36 +293,6 @@ static inline u8 prcmu_get_power_state_result(void)
 	return db8500_prcmu_get_power_state_result();
 }
 
-static inline int prcmu_gic_decouple(void)
-{
-	return db8500_prcmu_gic_decouple();
-}
-
-static inline int prcmu_gic_recouple(void)
-{
-	return db8500_prcmu_gic_recouple();
-}
-
-static inline bool prcmu_gic_pending_irq(void)
-{
-	return db8500_prcmu_gic_pending_irq();
-}
-
-static inline bool prcmu_is_cpu_in_wfi(int cpu)
-{
-	return db8500_prcmu_is_cpu_in_wfi(cpu);
-}
-
-static inline int prcmu_copy_gic_settings(void)
-{
-	return db8500_prcmu_copy_gic_settings();
-}
-
-static inline bool prcmu_pending_irq(void)
-{
-	return db8500_prcmu_pending_irq();
-}
-
 static inline int prcmu_set_epod(u16 epod_id, u8 epod_state)
 {
 	return db8500_prcmu_set_epod(epod_id, epod_state);

commit 9a47a8dccf8866b497bd80809da1c665e7b07c2c
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Mar 21 12:27:25 2013 +0100

    mfd: prcmu: pass a base and size with the early initcall
    
    This patch will make an early remapping of the PRCMU, to be
    used when setting up the clocks, that will call down into parts
    of the PRCMU driver before it is probed.
    
    Going forward this will be removed like this:
    
    - The mailbox subsystem need to be merged.
      http://marc.info/?l=linux-kernel&m=136314559201983&w=2
    
    - At this point the PRCMU clock code can be moved over to the
      ux500 clock driver in drivers/clk/ux500/* and maintained
      there in a decentralized manner.
    
    - This early initcall and PRCMU base parameters become part of
      the ux500_clk_init() call instead.
    
    Cc: Suman Anna <s-anna@ti.com>
    Cc: Loic Pallardy <loic.pallardy@st.com>
    Acked-by: Samuel Ortiz <sameo@linux.intel.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index 3abcca91eecd..8c546cbcb9a6 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -276,9 +276,9 @@ struct prcmu_fw_version {
 
 #if defined(CONFIG_UX500_SOC_DB8500)
 
-static inline void __init prcmu_early_init(void)
+static inline void prcmu_early_init(u32 phy_base, u32 size)
 {
-	return db8500_prcmu_early_init();
+	return db8500_prcmu_early_init(phy_base, size);
 }
 
 static inline int prcmu_set_power_state(u8 state, bool keep_ulp_clk,
@@ -500,7 +500,7 @@ static inline int prcmu_config_a9wdog(u8 num, bool sleep_auto_off)
 }
 #else
 
-static inline void __init prcmu_early_init(void) {}
+static inline void prcmu_early_init(u32 phy_base, u32 size) {}
 
 static inline int prcmu_set_power_state(u8 state, bool keep_ulp_clk,
 	bool keep_ap_pll)

commit ab7826595e9ec51a51f622c5fc91e2f59440481a
Merge: 21fbd5809ad1 ff7109fa6326
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 24 20:00:58 2013 -0800

    Merge tag 'mfd-3.9-1' of git://git.kernel.org/pub/scm/linux/kernel/git/sameo/mfd-2.6
    
    Pull MFS updates from Samuel Ortiz:
     "This is the MFD pull request for the 3.9 merge window.
    
      No new drivers this time, but a bunch of fairly big cleanups:
    
       - Roger Quadros worked on a OMAP USBHS and TLL platform data
         consolidation, OMAP5 support and clock management code cleanup.
    
       - The first step of a major sync for the ab8500 driver from Lee
         Jones.  In particular, the debugfs and the sysct interfaces got
         extended and improved.
    
       - Peter Ujfalusi sent a nice patchset for cleaning and fixing the
         twl-core driver, with a much needed module id lookup code
         improvement.
    
       - The regular wm5102 and arizona cleanups and fixes from Mark Brown.
    
       - Laxman Dewangan extended the palmas APIs in order to implement the
         palmas GPIO and rt drivers.
    
       - Laxman also added DT support for the tps65090 driver.
    
       - The Intel SCH and ICH drivers got a couple fixes from Aaron Sierra
         and Darren Hart.
    
       - Linus Walleij patchset for the ab8500 driver allowed ab8500 and
         ab9540 based devices to switch to the new abx500 pin-ctrl driver.
    
       - The max8925 now has device tree and irqdomain support thanks to
         Qing Xu.
    
       - The recently added rtsx driver got a few cleanups and fixes for a
         better card detection code path and now also supports the RTS5227
         chipset, thanks to Wei Wang and Roger Tseng."
    
    * tag 'mfd-3.9-1' of git://git.kernel.org/pub/scm/linux/kernel/git/sameo/mfd-2.6: (109 commits)
      mfd: lpc_ich: Use devres API to allocate private data
      mfd: lpc_ich: Add Device IDs for Intel Wellsburg PCH
      mfd: lpc_sch: Accomodate partial population of the MFD devices
      mfd: da9052-i2c: Staticize da9052_i2c_fix()
      mfd: syscon: Fix sparse warning
      mfd: twl-core: Fix kernel panic on boot
      mfd: rtsx: Fix issue that booting OS with SD card inserted
      mfd: ab8500: Fix compile error
      mfd: Add missing GENERIC_HARDIRQS dependecies
      Documentation: Add docs for max8925 dt
      mfd: max8925: Add dts
      mfd: max8925: Support dt for backlight
      mfd: max8925: Fix onkey driver irq base
      mfd: max8925: Fix mfd device register failure
      mfd: max8925: Add irqdomain for dt
      mfd: vexpress: Allow vexpress-sysreg to self-initialise
      mfd: rtsx: Support RTS5227
      mfd: rtsx: Implement driving adjustment to device-dependent callbacks
      mfd: vexpress: Add pseudo-GPIO based LEDs
      mfd: ab8500: Rename ab8500 to abx500 for hwmon driver
      ...

commit 98c60a0d3afc8f68e6e4b85b93df14e238fec3cb
Author: Fabio Baltieri <fabio.baltieri@linaro.org>
Date:   Fri Jan 18 12:40:11 2013 +0100

    mfd: dbx500-prcmu: Add watchdog ID definitions
    
    Add definition of watchdog IDs to be used by ux500_wdt driver.
    
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Fabio Baltieri <fabio.baltieri@linaro.org>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index c202d6c4d879..c6e0608a21b5 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -146,6 +146,18 @@ enum prcmu_clock {
 	PRCMU_DSI2ESCCLK,
 };
 
+/**
+ * enum prcmu_wdog_id - PRCMU watchdog IDs
+ * @PRCMU_WDOG_ALL: use all timers
+ * @PRCMU_WDOG_CPU1: use first CPU timer only
+ * @PRCMU_WDOG_CPU2: use second CPU timer conly
+ */
+enum prcmu_wdog_id {
+	PRCMU_WDOG_ALL = 0x00,
+	PRCMU_WDOG_CPU1 = 0x01,
+	PRCMU_WDOG_CPU2 = 0x02,
+};
+
 /**
  * enum ape_opp - APE OPP states definition
  * @APE_OPP_INIT:

commit 05ec260edecaf3dc214cff49d43b1ad9b2cbb710
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Feb 7 10:17:31 2013 +0100

    mfd: db8500-prcmu: update resource passing
    
    When trying to get rid of the cross-includes of <mach/id.h>
    from different drivers, so we can localize ASIC/CPU detection
    to the mach-ux500 folder, we run into the way the PRCMU
    handles base addresses and firmware detection.
    
    This patch updates the firmware version detection to pass
    the required information as platform data instead of
    relying on cpu_is_* macros.
    
    Now the PRCMU base address, the secondary TCDM area, the
    TCPM area and the IRQ are passed as resources instead of
    being grabbed from <mach/*> files. Incidentally this also
    removes part of the reliance on <mach/irqs.h>.
    
    Further it updates the firmware version detection, since the
    location of the firmware ID bytes in the designated memory
    are is now passed from the platform data instead. There is
    no reason not to include the nice split-off of a struct to
    hold the firmware information and a separate function to
    populate it.
    
    The patch actually rids the need to use the external
    db8500_prcmu_early_init call at all, but I'm keepin back
    that removal as I don't want the patch to be too big.
    
    Cc: arm@kernel.org
    Cc: Michel Jaoen <michel.jaouen@stericsson.com>
    Cc: Lee Jones <lee.jones@linaro.org>
    Acked-by: Samuel Ortiz <sameo@linux.intel.com>
    Acked-by: Loic Pallardy <loic.pallardy@stericsson.com>
    Acked-by: Fabio Baltieri <fabio.baltieri@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index 155280642583..f8bac7cfc25f 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -12,6 +12,10 @@
 #include <linux/notifier.h>
 #include <linux/err.h>
 
+/* Offset for the firmware version within the TCPM */
+#define DB8500_PRCMU_FW_VERSION_OFFSET 0xA4
+#define DBX540_PRCMU_FW_VERSION_OFFSET 0xA8
+
 /* PRCMU Wakeup defines */
 enum prcmu_wakeup_index {
 	PRCMU_WAKEUP_INDEX_RTC,
@@ -214,6 +218,48 @@ enum ddr_pwrst {
 	DDR_PWR_STATE_OFFHIGHLAT    = 0x03
 };
 
+#define DB8500_PRCMU_LEGACY_OFFSET		0xDD4
+
+struct prcmu_pdata
+{
+	bool enable_set_ddr_opp;
+	bool enable_ape_opp_100_voltage;
+	struct ab8500_platform_data *ab_platdata;
+	u32 version_offset;
+	u32 legacy_offset;
+	u32 adt_offset;
+};
+
+#define PRCMU_FW_PROJECT_U8500		2
+#define PRCMU_FW_PROJECT_U8400		3
+#define PRCMU_FW_PROJECT_U9500		4 /* Customer specific */
+#define PRCMU_FW_PROJECT_U8500_MBB	5
+#define PRCMU_FW_PROJECT_U8500_C1	6
+#define PRCMU_FW_PROJECT_U8500_C2	7
+#define PRCMU_FW_PROJECT_U8500_C3	8
+#define PRCMU_FW_PROJECT_U8500_C4	9
+#define PRCMU_FW_PROJECT_U9500_MBL	10
+#define PRCMU_FW_PROJECT_U8500_MBL	11 /* Customer specific */
+#define PRCMU_FW_PROJECT_U8500_MBL2	12 /* Customer specific */
+#define PRCMU_FW_PROJECT_U8520		13
+#define PRCMU_FW_PROJECT_U8420		14
+#define PRCMU_FW_PROJECT_A9420		20
+/* [32..63] 9540 and derivatives */
+#define PRCMU_FW_PROJECT_U9540		32
+/* [64..95] 8540 and derivatives */
+#define PRCMU_FW_PROJECT_L8540		64
+/* [96..126] 8580 and derivatives */
+#define PRCMU_FW_PROJECT_L8580		96
+
+#define PRCMU_FW_PROJECT_NAME_LEN	20
+struct prcmu_fw_version {
+	u32 project; /* Notice, project shifted with 8 on ux540 */
+	u8 api_version;
+	u8 func_version;
+	u8 errata;
+	char project_name[PRCMU_FW_PROJECT_NAME_LEN];
+};
+
 #include <linux/mfd/db8500-prcmu.h>
 
 #if defined(CONFIG_UX500_SOC_DB8500)

commit 7a4f26097d389c16c9956bc03b81532698d97d64
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Sep 19 19:31:19 2012 +0200

    ARM: ux500: de-globalize <mach/id.h>
    
    This removes the file <mach/id.h> from the global kernel include
    scope, making it a pure mach-ux500 detail. All ASIC specifics
    needed by drivers shall henceforth be passed from either platform
    data or the device tree.
    
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index ac601470962c..155280642583 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -218,8 +218,6 @@ enum ddr_pwrst {
 
 #if defined(CONFIG_UX500_SOC_DB8500)
 
-#include <mach/id.h>
-
 static inline void __init prcmu_early_init(void)
 {
 	return db8500_prcmu_early_init();

commit 222e8500f5e75d578ce1cc38c0349f89646319c4
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Jan 7 09:06:16 2013 +0100

    mfd: prcmu: delete pin control helpers
    
    These static inlines are duplicating the task now done by the
    Nomadik pinctrl drivers, so delete them from the prcmu static
    inlines, also delete the register definitions as these should
    only be known by the pinctrl driver.
    
    Cc: Loic Pallardy <loic.pallardy@st.com>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: Michel Jaouen <michel.jaouen@st.com>
    Acked-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index c202d6c4d879..ac601470962c 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -626,85 +626,6 @@ static inline void prcmu_clear(unsigned int reg, u32 bits)
 	prcmu_write_masked(reg, bits, 0);
 }
 
-#if defined(CONFIG_UX500_SOC_DB8500)
-
-/**
- * prcmu_enable_spi2 - Enables pin muxing for SPI2 on OtherAlternateC1.
- */
-static inline void prcmu_enable_spi2(void)
-{
-	if (cpu_is_u8500())
-		prcmu_set(DB8500_PRCM_GPIOCR, DB8500_PRCM_GPIOCR_SPI2_SELECT);
-}
-
-/**
- * prcmu_disable_spi2 - Disables pin muxing for SPI2 on OtherAlternateC1.
- */
-static inline void prcmu_disable_spi2(void)
-{
-	if (cpu_is_u8500())
-		prcmu_clear(DB8500_PRCM_GPIOCR, DB8500_PRCM_GPIOCR_SPI2_SELECT);
-}
-
-/**
- * prcmu_enable_stm_mod_uart - Enables pin muxing for STMMOD
- * and UARTMOD on OtherAlternateC3.
- */
-static inline void prcmu_enable_stm_mod_uart(void)
-{
-	if (cpu_is_u8500()) {
-		prcmu_set(DB8500_PRCM_GPIOCR,
-			(DB8500_PRCM_GPIOCR_DBG_STM_MOD_CMD1 |
-			 DB8500_PRCM_GPIOCR_DBG_UARTMOD_CMD0));
-	}
-}
-
-/**
- * prcmu_disable_stm_mod_uart - Disables pin muxing for STMMOD
- * and UARTMOD on OtherAlternateC3.
- */
-static inline void prcmu_disable_stm_mod_uart(void)
-{
-	if (cpu_is_u8500()) {
-		prcmu_clear(DB8500_PRCM_GPIOCR,
-			(DB8500_PRCM_GPIOCR_DBG_STM_MOD_CMD1 |
-			 DB8500_PRCM_GPIOCR_DBG_UARTMOD_CMD0));
-	}
-}
-
-/**
- * prcmu_enable_stm_ape - Enables pin muxing for STM APE on OtherAlternateC1.
- */
-static inline void prcmu_enable_stm_ape(void)
-{
-	if (cpu_is_u8500()) {
-		prcmu_set(DB8500_PRCM_GPIOCR,
-			DB8500_PRCM_GPIOCR_DBG_STM_APE_CMD);
-	}
-}
-
-/**
- * prcmu_disable_stm_ape - Disables pin muxing for STM APE on OtherAlternateC1.
- */
-static inline void prcmu_disable_stm_ape(void)
-{
-	if (cpu_is_u8500()) {
-		prcmu_clear(DB8500_PRCM_GPIOCR,
-			DB8500_PRCM_GPIOCR_DBG_STM_APE_CMD);
-	}
-}
-
-#else
-
-static inline void prcmu_enable_spi2(void) {}
-static inline void prcmu_disable_spi2(void) {}
-static inline void prcmu_enable_stm_mod_uart(void) {}
-static inline void prcmu_disable_stm_mod_uart(void) {}
-static inline void prcmu_enable_stm_ape(void) {}
-static inline void prcmu_disable_stm_ape(void) {}
-
-#endif
-
 /* PRCMU QoS APE OPP class */
 #define PRCMU_QOS_APE_OPP 1
 #define PRCMU_QOS_DDR_OPP 2

commit 686f871b7109e7e253a7a1cef542c00d0ed1a323
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Sep 24 16:43:17 2012 +0200

    mfd: dbx500: Export prmcu_request_ape_opp_100_voltage
    
    This function needs to be exported to let clients be able to
    request the ape opp 100 voltage.
    
    Cc: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index c410d99bd667..c202d6c4d879 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -336,6 +336,11 @@ static inline int prcmu_get_ape_opp(void)
 	return db8500_prcmu_get_ape_opp();
 }
 
+static inline int prcmu_request_ape_opp_100_voltage(bool enable)
+{
+	return db8500_prcmu_request_ape_opp_100_voltage(enable);
+}
+
 static inline void prcmu_system_reset(u16 reset_code)
 {
 	return db8500_prcmu_system_reset(reset_code);
@@ -507,6 +512,11 @@ static inline int prcmu_get_ape_opp(void)
 	return APE_100_OPP;
 }
 
+static inline int prcmu_request_ape_opp_100_voltage(bool enable)
+{
+	return 0;
+}
+
 static inline int prcmu_set_arm_opp(u8 opp)
 {
 	return 0;

commit 20aee5b6d7738206bfd37b352a97c75627d6fa6d
Author: Michel Jaouen <michel.jaouen@stericsson.com>
Date:   Fri Aug 31 14:21:30 2012 +0200

    mfd: dbx500: Provide a more accurate smp_twd clock
    
    The local timer clock is based on ARM subsystem clock. This patch
    obtains a more exact value of that clock by reading PRCMU registers.
    Using this increases the accuracy of the local timer events.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rickard Andersson <rickard.andersson@stericsson.com>
    Signed-off-by: Michel Jaouen <michel.jaouen@stericsson.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index 5b90e94399e1..c410d99bd667 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -136,6 +136,7 @@ enum prcmu_clock {
 	PRCMU_TIMCLK,
 	PRCMU_PLLSOC0,
 	PRCMU_PLLSOC1,
+	PRCMU_ARMSS,
 	PRCMU_PLLDDR,
 	PRCMU_PLLDSI,
 	PRCMU_DSI0CLK,

commit 5261e101198e7ef31a60d3aa97815a49c8b8fa20
Author: Arun Murthy <arun.murthy@stericsson.com>
Date:   Mon May 21 14:28:21 2012 +0530

    mfd: Update db8500-prmcu hostport_access enable
    
    Force the Modem wakeup by asserting the CaWakeReq signal before the
    hostaccess_req/ack ping-pong sequence. The Awake_req signal is de-asserted
    asserted at the same time than the hostaccess_req. Return error on failure
    case so that the client using this can take appropiate steps.
    
    Signed-off-by: Arun Murthy <arun.murthy@stericsson.com>
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index 5a13f93d8f1c..5b90e94399e1 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -345,7 +345,7 @@ static inline u16 prcmu_get_reset_code(void)
 	return db8500_prcmu_get_reset_code();
 }
 
-void prcmu_ac_wake_req(void);
+int prcmu_ac_wake_req(void);
 void prcmu_ac_sleep_req(void);
 static inline void prcmu_modem_reset(void)
 {
@@ -533,7 +533,10 @@ static inline u16 prcmu_get_reset_code(void)
 	return 0;
 }
 
-static inline void prcmu_ac_wake_req(void) {}
+static inline int prcmu_ac_wake_req(void)
+{
+	return 0;
+}
 
 static inline void prcmu_ac_sleep_req(void) {}
 

commit dece3709b71a704e810134056f1990922e574da1
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Apr 13 14:01:39 2012 +0200

    mfd/db5500-prcmu: delete DB5500 PRCMU support
    
    This platform has been obsoleted and was only available inside of
    ST-Ericsson, no users of this code are left in the world. This
    deletes the core U5500 support entirely in the same manner as the
    obsoleted U8500 silicon was previously deleted.
    
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Rabin Vincent <rabin.vincent@stericsson.com>
    Cc: Jonas Aberg <jonas.aberg@stericsson.com>
    Cc: Per Forlin <per.forlin@stericsson.com>
    Cc: Ulf Hansson <ulf.hansson@stericsson.com>
    Acked-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index d7674eb7305f..5a13f93d8f1c 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -54,17 +54,6 @@ enum prcmu_wakeup_index {
 #define EPOD_ID_ESRAM34		7
 #define NUM_EPOD_ID		8
 
-/*
- * DB5500 EPODs
- */
-#define DB5500_EPOD_ID_BASE 0x0100
-#define DB5500_EPOD_ID_SGA (DB5500_EPOD_ID_BASE + 0)
-#define DB5500_EPOD_ID_HVA (DB5500_EPOD_ID_BASE + 1)
-#define DB5500_EPOD_ID_SIA (DB5500_EPOD_ID_BASE + 2)
-#define DB5500_EPOD_ID_DISP (DB5500_EPOD_ID_BASE + 3)
-#define DB5500_EPOD_ID_ESRAM12 (DB5500_EPOD_ID_BASE + 6)
-#define DB5500_NUM_EPOD_ID 7
-
 /*
  * state definition for EPOD (power domain)
  * - EPOD_STATE_NO_CHANGE: The EPOD should remain unchanged
@@ -80,29 +69,6 @@ enum prcmu_wakeup_index {
 #define EPOD_STATE_ON_CLK_OFF	0x03
 #define EPOD_STATE_ON		0x04
 
-/* DB5500 CLKOUT IDs */
-enum {
-	DB5500_CLKOUT0 = 0,
-	DB5500_CLKOUT1,
-};
-
-/* DB5500 CLKOUTx sources */
-enum {
-	DB5500_CLKOUT_REF_CLK_SEL0,
-	DB5500_CLKOUT_RTC_CLK0_SEL0,
-	DB5500_CLKOUT_ULP_CLK_SEL0,
-	DB5500_CLKOUT_STATIC0,
-	DB5500_CLKOUT_REFCLK,
-	DB5500_CLKOUT_ULPCLK,
-	DB5500_CLKOUT_ARMCLK,
-	DB5500_CLKOUT_SYSACC0CLK,
-	DB5500_CLKOUT_SOC0PLLCLK,
-	DB5500_CLKOUT_SOC1PLLCLK,
-	DB5500_CLKOUT_DDRPLLCLK,
-	DB5500_CLKOUT_TVCLK,
-	DB5500_CLKOUT_IRDACLK,
-};
-
 /*
  * CLKOUT sources
  */
@@ -248,101 +214,66 @@ enum ddr_pwrst {
 };
 
 #include <linux/mfd/db8500-prcmu.h>
-#include <linux/mfd/db5500-prcmu.h>
 
-#if defined(CONFIG_UX500_SOC_DB8500) || defined(CONFIG_UX500_SOC_DB5500)
+#if defined(CONFIG_UX500_SOC_DB8500)
 
 #include <mach/id.h>
 
 static inline void __init prcmu_early_init(void)
 {
-	if (cpu_is_u5500())
-		return db5500_prcmu_early_init();
-	else
-		return db8500_prcmu_early_init();
+	return db8500_prcmu_early_init();
 }
 
 static inline int prcmu_set_power_state(u8 state, bool keep_ulp_clk,
 		bool keep_ap_pll)
 {
-	if (cpu_is_u5500())
-		return db5500_prcmu_set_power_state(state, keep_ulp_clk,
-			keep_ap_pll);
-	else
-		return db8500_prcmu_set_power_state(state, keep_ulp_clk,
-			keep_ap_pll);
+	return db8500_prcmu_set_power_state(state, keep_ulp_clk,
+		keep_ap_pll);
 }
 
 static inline u8 prcmu_get_power_state_result(void)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_get_power_state_result();
+	return db8500_prcmu_get_power_state_result();
 }
 
 static inline int prcmu_gic_decouple(void)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_gic_decouple();
+	return db8500_prcmu_gic_decouple();
 }
 
 static inline int prcmu_gic_recouple(void)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_gic_recouple();
+	return db8500_prcmu_gic_recouple();
 }
 
 static inline bool prcmu_gic_pending_irq(void)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_gic_pending_irq();
+	return db8500_prcmu_gic_pending_irq();
 }
 
 static inline bool prcmu_is_cpu_in_wfi(int cpu)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_is_cpu_in_wfi(cpu);
+	return db8500_prcmu_is_cpu_in_wfi(cpu);
 }
 
 static inline int prcmu_copy_gic_settings(void)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_copy_gic_settings();
+	return db8500_prcmu_copy_gic_settings();
 }
 
 static inline bool prcmu_pending_irq(void)
 {
-        if (cpu_is_u5500())
-                return -EINVAL;
-        else
-                return db8500_prcmu_pending_irq();
+	return db8500_prcmu_pending_irq();
 }
 
 static inline int prcmu_set_epod(u16 epod_id, u8 epod_state)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_set_epod(epod_id, epod_state);
+	return db8500_prcmu_set_epod(epod_id, epod_state);
 }
 
 static inline void prcmu_enable_wakeups(u32 wakeups)
 {
-	if (cpu_is_u5500())
-		db5500_prcmu_enable_wakeups(wakeups);
-	else
-		db8500_prcmu_enable_wakeups(wakeups);
+	db8500_prcmu_enable_wakeups(wakeups);
 }
 
 static inline void prcmu_disable_wakeups(void)
@@ -352,18 +283,12 @@ static inline void prcmu_disable_wakeups(void)
 
 static inline void prcmu_config_abb_event_readout(u32 abb_events)
 {
-	if (cpu_is_u5500())
-		db5500_prcmu_config_abb_event_readout(abb_events);
-	else
-		db8500_prcmu_config_abb_event_readout(abb_events);
+	db8500_prcmu_config_abb_event_readout(abb_events);
 }
 
 static inline void prcmu_get_abb_event_buffer(void __iomem **buf)
 {
-	if (cpu_is_u5500())
-		db5500_prcmu_get_abb_event_buffer(buf);
-	else
-		db8500_prcmu_get_abb_event_buffer(buf);
+	db8500_prcmu_get_abb_event_buffer(buf);
 }
 
 int prcmu_abb_read(u8 slave, u8 reg, u8 *value, u8 size);
@@ -374,10 +299,7 @@ int prcmu_config_clkout(u8 clkout, u8 source, u8 div);
 
 static inline int prcmu_request_clock(u8 clock, bool enable)
 {
-	if (cpu_is_u5500())
-		return db5500_prcmu_request_clock(clock, enable);
-	else
-		return db8500_prcmu_request_clock(clock, enable);
+	return db8500_prcmu_request_clock(clock, enable);
 }
 
 unsigned long prcmu_clock_rate(u8 clock);
@@ -386,211 +308,133 @@ int prcmu_set_clock_rate(u8 clock, unsigned long rate);
 
 static inline int prcmu_set_ddr_opp(u8 opp)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_set_ddr_opp(opp);
+	return db8500_prcmu_set_ddr_opp(opp);
 }
 static inline int prcmu_get_ddr_opp(void)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_get_ddr_opp();
+	return db8500_prcmu_get_ddr_opp();
 }
 
 static inline int prcmu_set_arm_opp(u8 opp)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_set_arm_opp(opp);
+	return db8500_prcmu_set_arm_opp(opp);
 }
 
 static inline int prcmu_get_arm_opp(void)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_get_arm_opp();
+	return db8500_prcmu_get_arm_opp();
 }
 
 static inline int prcmu_set_ape_opp(u8 opp)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_set_ape_opp(opp);
+	return db8500_prcmu_set_ape_opp(opp);
 }
 
 static inline int prcmu_get_ape_opp(void)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_get_ape_opp();
+	return db8500_prcmu_get_ape_opp();
 }
 
 static inline void prcmu_system_reset(u16 reset_code)
 {
-	if (cpu_is_u5500())
-		return db5500_prcmu_system_reset(reset_code);
-	else
-		return db8500_prcmu_system_reset(reset_code);
+	return db8500_prcmu_system_reset(reset_code);
 }
 
 static inline u16 prcmu_get_reset_code(void)
 {
-	if (cpu_is_u5500())
-		return db5500_prcmu_get_reset_code();
-	else
-		return db8500_prcmu_get_reset_code();
+	return db8500_prcmu_get_reset_code();
 }
 
 void prcmu_ac_wake_req(void);
 void prcmu_ac_sleep_req(void);
 static inline void prcmu_modem_reset(void)
 {
-	if (cpu_is_u5500())
-		return;
-	else
-		return db8500_prcmu_modem_reset();
+	return db8500_prcmu_modem_reset();
 }
 
 static inline bool prcmu_is_ac_wake_requested(void)
 {
-	if (cpu_is_u5500())
-		return db5500_prcmu_is_ac_wake_requested();
-	else
-		return db8500_prcmu_is_ac_wake_requested();
+	return db8500_prcmu_is_ac_wake_requested();
 }
 
 static inline int prcmu_set_display_clocks(void)
 {
-	if (cpu_is_u5500())
-		return db5500_prcmu_set_display_clocks();
-	else
-		return db8500_prcmu_set_display_clocks();
+	return db8500_prcmu_set_display_clocks();
 }
 
 static inline int prcmu_disable_dsipll(void)
 {
-	if (cpu_is_u5500())
-		return db5500_prcmu_disable_dsipll();
-	else
-		return db8500_prcmu_disable_dsipll();
+	return db8500_prcmu_disable_dsipll();
 }
 
 static inline int prcmu_enable_dsipll(void)
 {
-	if (cpu_is_u5500())
-		return db5500_prcmu_enable_dsipll();
-	else
-		return db8500_prcmu_enable_dsipll();
+	return db8500_prcmu_enable_dsipll();
 }
 
 static inline int prcmu_config_esram0_deep_sleep(u8 state)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_config_esram0_deep_sleep(state);
+	return db8500_prcmu_config_esram0_deep_sleep(state);
 }
 
 static inline int prcmu_config_hotdog(u8 threshold)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_config_hotdog(threshold);
+	return db8500_prcmu_config_hotdog(threshold);
 }
 
 static inline int prcmu_config_hotmon(u8 low, u8 high)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_config_hotmon(low, high);
+	return db8500_prcmu_config_hotmon(low, high);
 }
 
 static inline int prcmu_start_temp_sense(u16 cycles32k)
 {
-	if (cpu_is_u5500())
-		return  -EINVAL;
-	else
-		return  db8500_prcmu_start_temp_sense(cycles32k);
+	return  db8500_prcmu_start_temp_sense(cycles32k);
 }
 
 static inline int prcmu_stop_temp_sense(void)
 {
-	if (cpu_is_u5500())
-		return  -EINVAL;
-	else
-		return  db8500_prcmu_stop_temp_sense();
+	return  db8500_prcmu_stop_temp_sense();
 }
 
 static inline u32 prcmu_read(unsigned int reg)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_read(reg);
+	return db8500_prcmu_read(reg);
 }
 
 static inline void prcmu_write(unsigned int reg, u32 value)
 {
-	if (cpu_is_u5500())
-		return;
-	else
-		db8500_prcmu_write(reg, value);
+	db8500_prcmu_write(reg, value);
 }
 
 static inline void prcmu_write_masked(unsigned int reg, u32 mask, u32 value)
 {
-	if (cpu_is_u5500())
-		return;
-	else
-		db8500_prcmu_write_masked(reg, mask, value);
+	db8500_prcmu_write_masked(reg, mask, value);
 }
 
 static inline int prcmu_enable_a9wdog(u8 id)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_enable_a9wdog(id);
+	return db8500_prcmu_enable_a9wdog(id);
 }
 
 static inline int prcmu_disable_a9wdog(u8 id)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_disable_a9wdog(id);
+	return db8500_prcmu_disable_a9wdog(id);
 }
 
 static inline int prcmu_kick_a9wdog(u8 id)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_kick_a9wdog(id);
+	return db8500_prcmu_kick_a9wdog(id);
 }
 
 static inline int prcmu_load_a9wdog(u8 id, u32 timeout)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_load_a9wdog(id, timeout);
+	return db8500_prcmu_load_a9wdog(id, timeout);
 }
 
 static inline int prcmu_config_a9wdog(u8 num, bool sleep_auto_off)
 {
-	if (cpu_is_u5500())
-		return -EINVAL;
-	else
-		return db8500_prcmu_config_a9wdog(num, sleep_auto_off);
+	return db8500_prcmu_config_a9wdog(num, sleep_auto_off);
 }
 #else
 
@@ -768,7 +612,7 @@ static inline void prcmu_clear(unsigned int reg, u32 bits)
 	prcmu_write_masked(reg, bits, 0);
 }
 
-#if defined(CONFIG_UX500_SOC_DB8500) || defined(CONFIG_UX500_SOC_DB5500)
+#if defined(CONFIG_UX500_SOC_DB8500)
 
 /**
  * prcmu_enable_spi2 - Enables pin muxing for SPI2 on OtherAlternateC1.

commit 3c3e489831b601e566f6bc47e711f5847fb93dff
Author: Mattias Nilsson <mattias.i.nilsson@stericsson.com>
Date:   Thu Mar 8 14:02:05 2012 +0100

    mfd: Add a prcmu_abb_write_masked routine to db8500-prcmu
    
    This patch adds driver support for the I2C read-modify-write
    service in the U8500 PRCMU firmware.
    
    Signed-off-by: Mattias Nilsson <mattias.i.nilsson@stericsson.com>
    Reviewed-by: Jonas ABERG <jonas.aberg@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index eaa99a021785..d7674eb7305f 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -368,6 +368,7 @@ static inline void prcmu_get_abb_event_buffer(void __iomem **buf)
 
 int prcmu_abb_read(u8 slave, u8 reg, u8 *value, u8 size);
 int prcmu_abb_write(u8 slave, u8 reg, u8 *value, u8 size);
+int prcmu_abb_write_masked(u8 slave, u8 reg, u8 *value, u8 *mask, u8 size);
 
 int prcmu_config_clkout(u8 clkout, u8 source, u8 div);
 
@@ -620,6 +621,12 @@ static inline int prcmu_abb_write(u8 slave, u8 reg, u8 *value, u8 size)
 	return -ENOSYS;
 }
 
+static inline int prcmu_abb_write_masked(u8 slave, u8 reg, u8 *value, u8 *mask,
+	u8 size)
+{
+	return -ENOSYS;
+}
+
 static inline int prcmu_config_clkout(u8 clkout, u8 source, u8 div)
 {
 	return 0;

commit 34fe6f107eab096ac2f70a51763e9978b4abbeb6
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Tue Feb 28 22:46:09 2012 +0100

    mfd : Check if the other db8500 core is in WFI
    
    This patch allows to check if the other core is in WFI
    mode. It is the last check the idle routine has to do before
    entering into the retention state.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index 5c72c07e20e4..eaa99a021785 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -305,6 +305,14 @@ static inline bool prcmu_gic_pending_irq(void)
 		return db8500_prcmu_gic_pending_irq();
 }
 
+static inline bool prcmu_is_cpu_in_wfi(int cpu)
+{
+	if (cpu_is_u5500())
+		return -EINVAL;
+	else
+		return db8500_prcmu_is_cpu_in_wfi(cpu);
+}
+
 static inline int prcmu_copy_gic_settings(void)
 {
 	if (cpu_is_u5500())

commit 9ab492e12d588af7b05892c3744e8bdc2eace6d0
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Tue Feb 28 22:46:08 2012 +0100

    mfd : Check if the db8500 prcmu has pending irq
    
    This patch allows to check if there are some pending irqs
    on the prcmu.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index f8429cad0db7..5c72c07e20e4 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -313,6 +313,14 @@ static inline int prcmu_copy_gic_settings(void)
 		return db8500_prcmu_copy_gic_settings();
 }
 
+static inline bool prcmu_pending_irq(void)
+{
+        if (cpu_is_u5500())
+                return -EINVAL;
+        else
+                return db8500_prcmu_pending_irq();
+}
+
 static inline int prcmu_set_epod(u16 epod_id, u8 epod_state)
 {
 	if (cpu_is_u5500())

commit 9f60d33e1811e0aa696a3152050d6e3e4c3195aa
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Tue Feb 28 22:46:07 2012 +0100

    mfd : Copy the db8500 gic setting to the prcmu
    
    In the case we go to the retention mode, we decoupled the gic
    in order to have the A9 core to reach a stable WFI state.
    But we want the prcmu to wake up the A9 when the gic has a pending
    irq which is done by copying the gic settings to the to the prcmu.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index 16418747dad1..f8429cad0db7 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -305,6 +305,14 @@ static inline bool prcmu_gic_pending_irq(void)
 		return db8500_prcmu_gic_pending_irq();
 }
 
+static inline int prcmu_copy_gic_settings(void)
+{
+	if (cpu_is_u5500())
+		return -EINVAL;
+	else
+		return db8500_prcmu_copy_gic_settings();
+}
+
 static inline int prcmu_set_epod(u16 epod_id, u8 epod_state)
 {
 	if (cpu_is_u5500())

commit cc9a0f68d1f8b9bfd9c0c2ada13db64d63f63db3
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Tue Feb 28 22:46:06 2012 +0100

    mfd : Check if there are pending irq on the db8500 gic
    
    This patch introduces a routine to check if there are some
    irqs pending on the gic. Usually this check is not relevant because
    it appears racy (an irq can arrive right after this check), but in
    the ux500 it makes sense because the prcmu decouples the gic from
    the A9 cores.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index 5bf5c4f0132c..16418747dad1 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -297,6 +297,14 @@ static inline int prcmu_gic_recouple(void)
 		return db8500_prcmu_gic_recouple();
 }
 
+static inline bool prcmu_gic_pending_irq(void)
+{
+	if (cpu_is_u5500())
+		return -EINVAL;
+	else
+		return db8500_prcmu_gic_pending_irq();
+}
+
 static inline int prcmu_set_epod(u16 epod_id, u8 epod_state)
 {
 	if (cpu_is_u5500())

commit 485540dce01cf4b4d3629141399678e35e66b711
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Mon Feb 20 12:30:26 2012 +0100

    mfd: Decouple/recouple gic from the ux500 PRCMU
    
    This patch allows to decouple and recouple the gic from the PRCMU.
    This is needed to put the A9 core in retention mode with the cpuidle
    driver.
    
    It is based on top of the "DB8500 PRCMU update" patchset.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Rickard Andersson <rickard.andersson@stericsson.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index b3b5adfa9e41..5bf5c4f0132c 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -281,6 +281,22 @@ static inline u8 prcmu_get_power_state_result(void)
 		return db8500_prcmu_get_power_state_result();
 }
 
+static inline int prcmu_gic_decouple(void)
+{
+	if (cpu_is_u5500())
+		return -EINVAL;
+	else
+		return db8500_prcmu_gic_decouple();
+}
+
+static inline int prcmu_gic_recouple(void)
+{
+	if (cpu_is_u5500())
+		return -EINVAL;
+	else
+		return db8500_prcmu_gic_recouple();
+}
+
 static inline int prcmu_set_epod(u16 epod_id, u8 epod_state)
 {
 	if (cpu_is_u5500())

commit b4a6dbd5b7bad00ee4004443287468abddb96538
Author: Mattias Nilsson <mattias.i.nilsson@stericsson.com>
Date:   Fri Jan 13 16:21:00 2012 +0100

    mfd: Add initial db8500 prcmu register access api
    
    This patch adds an initial PRCMU register access API, which
    for now should only be used for a very limited set of registers.
    
    The idea about this API is that we split the PRCMU driver in
    one part that deals with interaction with the PRCMU firmware
    and one part that simply provide write accessors in the PRCMU
    register range. The latter are just a collection of registers
    exposed in the PRCMU register range for various purposes and
    not related to the PRCMU firmware.
    
    Currently we support some limited GPIO, SPI and UART settings
    through this API.
    
    Signed-off-by: Mattias Nilsson <mattias.i.nilsson@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index 432a2d3fc198..b3b5adfa9e41 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -480,6 +480,30 @@ static inline int prcmu_stop_temp_sense(void)
 		return  db8500_prcmu_stop_temp_sense();
 }
 
+static inline u32 prcmu_read(unsigned int reg)
+{
+	if (cpu_is_u5500())
+		return -EINVAL;
+	else
+		return db8500_prcmu_read(reg);
+}
+
+static inline void prcmu_write(unsigned int reg, u32 value)
+{
+	if (cpu_is_u5500())
+		return;
+	else
+		db8500_prcmu_write(reg, value);
+}
+
+static inline void prcmu_write_masked(unsigned int reg, u32 mask, u32 value)
+{
+	if (cpu_is_u5500())
+		return;
+	else
+		db8500_prcmu_write_masked(reg, mask, value);
+}
+
 static inline int prcmu_enable_a9wdog(u8 id)
 {
 	if (cpu_is_u5500())
@@ -668,6 +692,104 @@ static inline int prcmu_stop_temp_sense(void)
 	return 0;
 }
 
+static inline u32 prcmu_read(unsigned int reg)
+{
+	return 0;
+}
+
+static inline void prcmu_write(unsigned int reg, u32 value) {}
+
+static inline void prcmu_write_masked(unsigned int reg, u32 mask, u32 value) {}
+
+#endif
+
+static inline void prcmu_set(unsigned int reg, u32 bits)
+{
+	prcmu_write_masked(reg, bits, bits);
+}
+
+static inline void prcmu_clear(unsigned int reg, u32 bits)
+{
+	prcmu_write_masked(reg, bits, 0);
+}
+
+#if defined(CONFIG_UX500_SOC_DB8500) || defined(CONFIG_UX500_SOC_DB5500)
+
+/**
+ * prcmu_enable_spi2 - Enables pin muxing for SPI2 on OtherAlternateC1.
+ */
+static inline void prcmu_enable_spi2(void)
+{
+	if (cpu_is_u8500())
+		prcmu_set(DB8500_PRCM_GPIOCR, DB8500_PRCM_GPIOCR_SPI2_SELECT);
+}
+
+/**
+ * prcmu_disable_spi2 - Disables pin muxing for SPI2 on OtherAlternateC1.
+ */
+static inline void prcmu_disable_spi2(void)
+{
+	if (cpu_is_u8500())
+		prcmu_clear(DB8500_PRCM_GPIOCR, DB8500_PRCM_GPIOCR_SPI2_SELECT);
+}
+
+/**
+ * prcmu_enable_stm_mod_uart - Enables pin muxing for STMMOD
+ * and UARTMOD on OtherAlternateC3.
+ */
+static inline void prcmu_enable_stm_mod_uart(void)
+{
+	if (cpu_is_u8500()) {
+		prcmu_set(DB8500_PRCM_GPIOCR,
+			(DB8500_PRCM_GPIOCR_DBG_STM_MOD_CMD1 |
+			 DB8500_PRCM_GPIOCR_DBG_UARTMOD_CMD0));
+	}
+}
+
+/**
+ * prcmu_disable_stm_mod_uart - Disables pin muxing for STMMOD
+ * and UARTMOD on OtherAlternateC3.
+ */
+static inline void prcmu_disable_stm_mod_uart(void)
+{
+	if (cpu_is_u8500()) {
+		prcmu_clear(DB8500_PRCM_GPIOCR,
+			(DB8500_PRCM_GPIOCR_DBG_STM_MOD_CMD1 |
+			 DB8500_PRCM_GPIOCR_DBG_UARTMOD_CMD0));
+	}
+}
+
+/**
+ * prcmu_enable_stm_ape - Enables pin muxing for STM APE on OtherAlternateC1.
+ */
+static inline void prcmu_enable_stm_ape(void)
+{
+	if (cpu_is_u8500()) {
+		prcmu_set(DB8500_PRCM_GPIOCR,
+			DB8500_PRCM_GPIOCR_DBG_STM_APE_CMD);
+	}
+}
+
+/**
+ * prcmu_disable_stm_ape - Disables pin muxing for STM APE on OtherAlternateC1.
+ */
+static inline void prcmu_disable_stm_ape(void)
+{
+	if (cpu_is_u8500()) {
+		prcmu_clear(DB8500_PRCM_GPIOCR,
+			DB8500_PRCM_GPIOCR_DBG_STM_APE_CMD);
+	}
+}
+
+#else
+
+static inline void prcmu_enable_spi2(void) {}
+static inline void prcmu_disable_spi2(void) {}
+static inline void prcmu_enable_stm_mod_uart(void) {}
+static inline void prcmu_disable_stm_mod_uart(void) {}
+static inline void prcmu_enable_stm_ape(void) {}
+static inline void prcmu_disable_stm_ape(void) {}
+
 #endif
 
 /* PRCMU QoS APE OPP class */

commit 4d64d2e34bc415b05eb77a2732a3164313cf6de3
Author: Mattias Nilsson <mattias.i.nilsson@stericsson.com>
Date:   Fri Jan 13 16:20:43 2012 +0100

    mfd: db8500 OPP and sleep handling update
    
    This updates the operating point handling code by:
    
    - Supporting the DDR OPP retention state.
    - Supporting another low operating point named
      APE_50_PARTLY_25_OPP
    - Adding an interface to figure out if the sleep state change
      was properly achieved.
    
    Signed-off-by: Shreshtha Kumar Sahu <shreshthakumar.sahu@stericsson.com>
    Signed-off-by: Rabin Vincent <rabin.vincent@stericsson.com>
    Signed-off-by: Mattias Nilsson <mattias.i.nilsson@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index 8470c7d7121f..432a2d3fc198 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -185,12 +185,14 @@ enum prcmu_clock {
  * @APE_NO_CHANGE: The APE operating point is unchanged
  * @APE_100_OPP: The new APE operating point is ape100opp
  * @APE_50_OPP: 50%
+ * @APE_50_PARTLY_25_OPP: 50%, except some clocks at 25%.
  */
 enum ape_opp {
 	APE_OPP_INIT = 0x00,
 	APE_NO_CHANGE = 0x01,
 	APE_100_OPP = 0x02,
-	APE_50_OPP = 0x03
+	APE_50_OPP = 0x03,
+	APE_50_PARTLY_25_OPP = 0xFF,
 };
 
 /**
@@ -271,6 +273,14 @@ static inline int prcmu_set_power_state(u8 state, bool keep_ulp_clk,
 			keep_ap_pll);
 }
 
+static inline u8 prcmu_get_power_state_result(void)
+{
+	if (cpu_is_u5500())
+		return -EINVAL;
+	else
+		return db8500_prcmu_get_power_state_result();
+}
+
 static inline int prcmu_set_epod(u16 epod_id, u8 epod_state)
 {
 	if (cpu_is_u5500())
@@ -663,9 +673,10 @@ static inline int prcmu_stop_temp_sense(void)
 /* PRCMU QoS APE OPP class */
 #define PRCMU_QOS_APE_OPP 1
 #define PRCMU_QOS_DDR_OPP 2
+#define PRCMU_QOS_ARM_OPP 3
 #define PRCMU_QOS_DEFAULT_VALUE -1
 
-#ifdef CONFIG_UX500_PRCMU_QOS_POWER
+#ifdef CONFIG_DBX500_PRCMU_QOS_POWER
 
 unsigned long prcmu_qos_get_cpufreq_opp_delay(void);
 void prcmu_qos_set_cpufreq_opp_delay(unsigned long);

commit 6b6fae2b890826c99f9e62cceec4f859c98ee575
Author: Mattias Nilsson <mattias.i.nilsson@stericsson.com>
Date:   Fri Jan 13 16:20:28 2012 +0100

    mfd: db8500 clock handling update
    
    This updates the clock handling in the DB8500 PRCMU driver with
    the latest findings and API changes related to changes in the
    backing firmware in the PRCMU.
    
    - Add the necessary interfaces to get the frequencies of the
      clocks and set the rate of some of the clocks.
    - Add support for controlling the clocks PLLSOC0, PLLDSI,
      DSI0, DSI1 and DSI escape clocks (DSInESCCLK).
    - Correct the PLLSDI enable/disable sequence by using the
      DSIPLL_CLAMPI bit.
    
    After this we will have the interfaces and code to implement the
    U8500 clock framework properly.
    
    Reviewed-by: Jonas Aberg <jonas.aberg@stericsson.com>
    Signed-off-by: Mattias Nilsson <mattias.i.nilsson@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index f73b9d9d2a24..8470c7d7121f 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -80,6 +80,29 @@ enum prcmu_wakeup_index {
 #define EPOD_STATE_ON_CLK_OFF	0x03
 #define EPOD_STATE_ON		0x04
 
+/* DB5500 CLKOUT IDs */
+enum {
+	DB5500_CLKOUT0 = 0,
+	DB5500_CLKOUT1,
+};
+
+/* DB5500 CLKOUTx sources */
+enum {
+	DB5500_CLKOUT_REF_CLK_SEL0,
+	DB5500_CLKOUT_RTC_CLK0_SEL0,
+	DB5500_CLKOUT_ULP_CLK_SEL0,
+	DB5500_CLKOUT_STATIC0,
+	DB5500_CLKOUT_REFCLK,
+	DB5500_CLKOUT_ULPCLK,
+	DB5500_CLKOUT_ARMCLK,
+	DB5500_CLKOUT_SYSACC0CLK,
+	DB5500_CLKOUT_SOC0PLLCLK,
+	DB5500_CLKOUT_SOC1PLLCLK,
+	DB5500_CLKOUT_DDRPLLCLK,
+	DB5500_CLKOUT_TVCLK,
+	DB5500_CLKOUT_IRDACLK,
+};
+
 /*
  * CLKOUT sources
  */
@@ -111,6 +134,7 @@ enum prcmu_clock {
 	PRCMU_MSP1CLK,
 	PRCMU_I2CCLK,
 	PRCMU_SDMMCCLK,
+	PRCMU_SPARE1CLK,
 	PRCMU_SLIMCLK,
 	PRCMU_PER1CLK,
 	PRCMU_PER2CLK,
@@ -139,12 +163,20 @@ enum prcmu_clock {
 	PRCMU_IRRCCLK,
 	PRCMU_SIACLK,
 	PRCMU_SVACLK,
+	PRCMU_ACLK,
 	PRCMU_NUM_REG_CLOCKS,
 	PRCMU_SYSCLK = PRCMU_NUM_REG_CLOCKS,
+	PRCMU_CDCLK,
 	PRCMU_TIMCLK,
 	PRCMU_PLLSOC0,
 	PRCMU_PLLSOC1,
 	PRCMU_PLLDDR,
+	PRCMU_PLLDSI,
+	PRCMU_DSI0CLK,
+	PRCMU_DSI1CLK,
+	PRCMU_DSI0ESCCLK,
+	PRCMU_DSI1ESCCLK,
+	PRCMU_DSI2ESCCLK,
 };
 
 /**
@@ -516,6 +548,21 @@ static inline int prcmu_request_clock(u8 clock, bool enable)
 	return 0;
 }
 
+static inline long prcmu_round_clock_rate(u8 clock, unsigned long rate)
+{
+	return 0;
+}
+
+static inline int prcmu_set_clock_rate(u8 clock, unsigned long rate)
+{
+	return 0;
+}
+
+static inline unsigned long prcmu_clock_rate(u8 clock)
+{
+	return 0;
+}
+
 static inline int prcmu_set_ape_opp(u8 opp)
 {
 	return 0;

commit 0508901ca794d411efb09befb88b8194d8387428
Author: Mattias Nilsson <mattias.i.nilsson@stericsson.com>
Date:   Fri Jan 13 16:20:20 2012 +0100

    mfd: Update abstract dbx500 interface
    
    This prefixes a number of accessor functions with db8500_* since
    they are DB8500-specific and we need to move to this naming
    scheme.
    
    We also replace numerous instances of machine_is() with cpu_is()
    which covers the right type of ASICs rather than entire machines
    i.e. boards.
    
    Signed-off-by: Mattias Nilsson <mattias.i.nilsson@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index bac942f959c1..f73b9d9d2a24 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -10,7 +10,7 @@
 
 #include <linux/interrupt.h>
 #include <linux/notifier.h>
-#include <asm/mach-types.h>
+#include <linux/err.h>
 
 /* PRCMU Wakeup defines */
 enum prcmu_wakeup_index {
@@ -218,9 +218,11 @@ enum ddr_pwrst {
 
 #if defined(CONFIG_UX500_SOC_DB8500) || defined(CONFIG_UX500_SOC_DB5500)
 
+#include <mach/id.h>
+
 static inline void __init prcmu_early_init(void)
 {
-	if (machine_is_u5500())
+	if (cpu_is_u5500())
 		return db5500_prcmu_early_init();
 	else
 		return db8500_prcmu_early_init();
@@ -229,7 +231,7 @@ static inline void __init prcmu_early_init(void)
 static inline int prcmu_set_power_state(u8 state, bool keep_ulp_clk,
 		bool keep_ap_pll)
 {
-	if (machine_is_u5500())
+	if (cpu_is_u5500())
 		return db5500_prcmu_set_power_state(state, keep_ulp_clk,
 			keep_ap_pll);
 	else
@@ -239,7 +241,7 @@ static inline int prcmu_set_power_state(u8 state, bool keep_ulp_clk,
 
 static inline int prcmu_set_epod(u16 epod_id, u8 epod_state)
 {
-	if (machine_is_u5500())
+	if (cpu_is_u5500())
 		return -EINVAL;
 	else
 		return db8500_prcmu_set_epod(epod_id, epod_state);
@@ -247,7 +249,7 @@ static inline int prcmu_set_epod(u16 epod_id, u8 epod_state)
 
 static inline void prcmu_enable_wakeups(u32 wakeups)
 {
-	if (machine_is_u5500())
+	if (cpu_is_u5500())
 		db5500_prcmu_enable_wakeups(wakeups);
 	else
 		db8500_prcmu_enable_wakeups(wakeups);
@@ -260,7 +262,7 @@ static inline void prcmu_disable_wakeups(void)
 
 static inline void prcmu_config_abb_event_readout(u32 abb_events)
 {
-	if (machine_is_u5500())
+	if (cpu_is_u5500())
 		db5500_prcmu_config_abb_event_readout(abb_events);
 	else
 		db8500_prcmu_config_abb_event_readout(abb_events);
@@ -268,7 +270,7 @@ static inline void prcmu_config_abb_event_readout(u32 abb_events)
 
 static inline void prcmu_get_abb_event_buffer(void __iomem **buf)
 {
-	if (machine_is_u5500())
+	if (cpu_is_u5500())
 		db5500_prcmu_get_abb_event_buffer(buf);
 	else
 		db8500_prcmu_get_abb_event_buffer(buf);
@@ -281,20 +283,34 @@ int prcmu_config_clkout(u8 clkout, u8 source, u8 div);
 
 static inline int prcmu_request_clock(u8 clock, bool enable)
 {
-	if (machine_is_u5500())
+	if (cpu_is_u5500())
 		return db5500_prcmu_request_clock(clock, enable);
 	else
 		return db8500_prcmu_request_clock(clock, enable);
 }
 
-int prcmu_set_ape_opp(u8 opp);
-int prcmu_get_ape_opp(void);
-int prcmu_set_ddr_opp(u8 opp);
-int prcmu_get_ddr_opp(void);
+unsigned long prcmu_clock_rate(u8 clock);
+long prcmu_round_clock_rate(u8 clock, unsigned long rate);
+int prcmu_set_clock_rate(u8 clock, unsigned long rate);
+
+static inline int prcmu_set_ddr_opp(u8 opp)
+{
+	if (cpu_is_u5500())
+		return -EINVAL;
+	else
+		return db8500_prcmu_set_ddr_opp(opp);
+}
+static inline int prcmu_get_ddr_opp(void)
+{
+	if (cpu_is_u5500())
+		return -EINVAL;
+	else
+		return db8500_prcmu_get_ddr_opp();
+}
 
 static inline int prcmu_set_arm_opp(u8 opp)
 {
-	if (machine_is_u5500())
+	if (cpu_is_u5500())
 		return -EINVAL;
 	else
 		return db8500_prcmu_set_arm_opp(opp);
@@ -302,15 +318,31 @@ static inline int prcmu_set_arm_opp(u8 opp)
 
 static inline int prcmu_get_arm_opp(void)
 {
-	if (machine_is_u5500())
+	if (cpu_is_u5500())
 		return -EINVAL;
 	else
 		return db8500_prcmu_get_arm_opp();
 }
 
+static inline int prcmu_set_ape_opp(u8 opp)
+{
+	if (cpu_is_u5500())
+		return -EINVAL;
+	else
+		return db8500_prcmu_set_ape_opp(opp);
+}
+
+static inline int prcmu_get_ape_opp(void)
+{
+	if (cpu_is_u5500())
+		return -EINVAL;
+	else
+		return db8500_prcmu_get_ape_opp();
+}
+
 static inline void prcmu_system_reset(u16 reset_code)
 {
-	if (machine_is_u5500())
+	if (cpu_is_u5500())
 		return db5500_prcmu_system_reset(reset_code);
 	else
 		return db8500_prcmu_system_reset(reset_code);
@@ -318,7 +350,7 @@ static inline void prcmu_system_reset(u16 reset_code)
 
 static inline u16 prcmu_get_reset_code(void)
 {
-	if (machine_is_u5500())
+	if (cpu_is_u5500())
 		return db5500_prcmu_get_reset_code();
 	else
 		return db8500_prcmu_get_reset_code();
@@ -326,10 +358,17 @@ static inline u16 prcmu_get_reset_code(void)
 
 void prcmu_ac_wake_req(void);
 void prcmu_ac_sleep_req(void);
-void prcmu_modem_reset(void);
+static inline void prcmu_modem_reset(void)
+{
+	if (cpu_is_u5500())
+		return;
+	else
+		return db8500_prcmu_modem_reset();
+}
+
 static inline bool prcmu_is_ac_wake_requested(void)
 {
-	if (machine_is_u5500())
+	if (cpu_is_u5500())
 		return db5500_prcmu_is_ac_wake_requested();
 	else
 		return db8500_prcmu_is_ac_wake_requested();
@@ -337,7 +376,7 @@ static inline bool prcmu_is_ac_wake_requested(void)
 
 static inline int prcmu_set_display_clocks(void)
 {
-	if (machine_is_u5500())
+	if (cpu_is_u5500())
 		return db5500_prcmu_set_display_clocks();
 	else
 		return db8500_prcmu_set_display_clocks();
@@ -345,7 +384,7 @@ static inline int prcmu_set_display_clocks(void)
 
 static inline int prcmu_disable_dsipll(void)
 {
-	if (machine_is_u5500())
+	if (cpu_is_u5500())
 		return db5500_prcmu_disable_dsipll();
 	else
 		return db8500_prcmu_disable_dsipll();
@@ -353,7 +392,7 @@ static inline int prcmu_disable_dsipll(void)
 
 static inline int prcmu_enable_dsipll(void)
 {
-	if (machine_is_u5500())
+	if (cpu_is_u5500())
 		return db5500_prcmu_enable_dsipll();
 	else
 		return db8500_prcmu_enable_dsipll();
@@ -361,11 +400,83 @@ static inline int prcmu_enable_dsipll(void)
 
 static inline int prcmu_config_esram0_deep_sleep(u8 state)
 {
-	if (machine_is_u5500())
+	if (cpu_is_u5500())
 		return -EINVAL;
 	else
 		return db8500_prcmu_config_esram0_deep_sleep(state);
 }
+
+static inline int prcmu_config_hotdog(u8 threshold)
+{
+	if (cpu_is_u5500())
+		return -EINVAL;
+	else
+		return db8500_prcmu_config_hotdog(threshold);
+}
+
+static inline int prcmu_config_hotmon(u8 low, u8 high)
+{
+	if (cpu_is_u5500())
+		return -EINVAL;
+	else
+		return db8500_prcmu_config_hotmon(low, high);
+}
+
+static inline int prcmu_start_temp_sense(u16 cycles32k)
+{
+	if (cpu_is_u5500())
+		return  -EINVAL;
+	else
+		return  db8500_prcmu_start_temp_sense(cycles32k);
+}
+
+static inline int prcmu_stop_temp_sense(void)
+{
+	if (cpu_is_u5500())
+		return  -EINVAL;
+	else
+		return  db8500_prcmu_stop_temp_sense();
+}
+
+static inline int prcmu_enable_a9wdog(u8 id)
+{
+	if (cpu_is_u5500())
+		return -EINVAL;
+	else
+		return db8500_prcmu_enable_a9wdog(id);
+}
+
+static inline int prcmu_disable_a9wdog(u8 id)
+{
+	if (cpu_is_u5500())
+		return -EINVAL;
+	else
+		return db8500_prcmu_disable_a9wdog(id);
+}
+
+static inline int prcmu_kick_a9wdog(u8 id)
+{
+	if (cpu_is_u5500())
+		return -EINVAL;
+	else
+		return db8500_prcmu_kick_a9wdog(id);
+}
+
+static inline int prcmu_load_a9wdog(u8 id, u32 timeout)
+{
+	if (cpu_is_u5500())
+		return -EINVAL;
+	else
+		return db8500_prcmu_load_a9wdog(id, timeout);
+}
+
+static inline int prcmu_config_a9wdog(u8 num, bool sleep_auto_off)
+{
+	if (cpu_is_u5500())
+		return -EINVAL;
+	else
+		return db8500_prcmu_config_a9wdog(num, sleep_auto_off);
+}
 #else
 
 static inline void __init prcmu_early_init(void) {}
@@ -480,6 +591,26 @@ static inline void prcmu_get_abb_event_buffer(void __iomem **buf)
 	*buf = NULL;
 }
 
+static inline int prcmu_config_hotdog(u8 threshold)
+{
+	return 0;
+}
+
+static inline int prcmu_config_hotmon(u8 low, u8 high)
+{
+	return 0;
+}
+
+static inline int prcmu_start_temp_sense(u16 cycles32k)
+{
+	return 0;
+}
+
+static inline int prcmu_stop_temp_sense(void)
+{
+	return 0;
+}
+
 #endif
 
 /* PRCMU QoS APE OPP class */

commit 73180f85f4ffbb66843f8248811b2ade29b22df2
Author: Mattias Nilsson <mattias.i.nilsson@stericsson.com>
Date:   Fri Aug 12 10:28:10 2011 +0200

    mfd: Move to the new db500 PRCMU API
    
    Now that we have a shared API between the DB8500 and DB5500
    PRCMU's, switch to using this neutral API instead. We delete the
    parts of db8500-prcmu.h that is now PRCMU-neutral, and calls will
    be diverted to respective driver. Common registers are in
    dbx500-prcmu-regs.h and common accessors and defines in
    <linux/mfd/dbx500-prcmu.h> This way we get a a lot more
    abstraction and code reuse.
    
    Signed-off-by: Mattias Nilsson <mattias.i.nilsson@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
index 6c7584d69d8f..bac942f959c1 100644
--- a/include/linux/mfd/dbx500-prcmu.h
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -240,7 +240,7 @@ static inline int prcmu_set_power_state(u8 state, bool keep_ulp_clk,
 static inline int prcmu_set_epod(u16 epod_id, u8 epod_state)
 {
 	if (machine_is_u5500())
-		return db5500_prcmu_set_epod(epod_id, epod_state);
+		return -EINVAL;
 	else
 		return db8500_prcmu_set_epod(epod_id, epod_state);
 }
@@ -295,7 +295,7 @@ int prcmu_get_ddr_opp(void);
 static inline int prcmu_set_arm_opp(u8 opp)
 {
 	if (machine_is_u5500())
-		return db5500_prcmu_set_arm_opp(opp);
+		return -EINVAL;
 	else
 		return db8500_prcmu_set_arm_opp(opp);
 }
@@ -303,7 +303,7 @@ static inline int prcmu_set_arm_opp(u8 opp)
 static inline int prcmu_get_arm_opp(void)
 {
 	if (machine_is_u5500())
-		return db5500_prcmu_get_arm_opp();
+		return -EINVAL;
 	else
 		return db8500_prcmu_get_arm_opp();
 }
@@ -362,7 +362,7 @@ static inline int prcmu_enable_dsipll(void)
 static inline int prcmu_config_esram0_deep_sleep(u8 state)
 {
 	if (machine_is_u5500())
-		return db5500_prcmu_config_esram0_deep_sleep(state);
+		return -EINVAL;
 	else
 		return db8500_prcmu_config_esram0_deep_sleep(state);
 }

commit fea799e3d3ab84ac675de7e48a13a79fb76b6e63
Author: Mattias Nilsson <mattias.i.nilsson@stericsson.com>
Date:   Fri Aug 12 10:28:02 2011 +0200

    mfd: Create a common interface for dbx500 PRCMU drivers
    
    This adds a header file that contains the set of functions and
    definitions that will be shared between the DB8500 and DB5500
    PRCMU drivers.
    
    Signed-off-by: Mattias Nilsson <mattias.i.nilsson@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/linux/mfd/dbx500-prcmu.h b/include/linux/mfd/dbx500-prcmu.h
new file mode 100644
index 000000000000..6c7584d69d8f
--- /dev/null
+++ b/include/linux/mfd/dbx500-prcmu.h
@@ -0,0 +1,549 @@
+/*
+ * Copyright (C) ST Ericsson SA 2011
+ *
+ * License Terms: GNU General Public License v2
+ *
+ * STE Ux500 PRCMU API
+ */
+#ifndef __MACH_PRCMU_H
+#define __MACH_PRCMU_H
+
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <asm/mach-types.h>
+
+/* PRCMU Wakeup defines */
+enum prcmu_wakeup_index {
+	PRCMU_WAKEUP_INDEX_RTC,
+	PRCMU_WAKEUP_INDEX_RTT0,
+	PRCMU_WAKEUP_INDEX_RTT1,
+	PRCMU_WAKEUP_INDEX_HSI0,
+	PRCMU_WAKEUP_INDEX_HSI1,
+	PRCMU_WAKEUP_INDEX_USB,
+	PRCMU_WAKEUP_INDEX_ABB,
+	PRCMU_WAKEUP_INDEX_ABB_FIFO,
+	PRCMU_WAKEUP_INDEX_ARM,
+	PRCMU_WAKEUP_INDEX_CD_IRQ,
+	NUM_PRCMU_WAKEUP_INDICES
+};
+#define PRCMU_WAKEUP(_name) (BIT(PRCMU_WAKEUP_INDEX_##_name))
+
+/* EPOD (power domain) IDs */
+
+/*
+ * DB8500 EPODs
+ * - EPOD_ID_SVAMMDSP: power domain for SVA MMDSP
+ * - EPOD_ID_SVAPIPE: power domain for SVA pipe
+ * - EPOD_ID_SIAMMDSP: power domain for SIA MMDSP
+ * - EPOD_ID_SIAPIPE: power domain for SIA pipe
+ * - EPOD_ID_SGA: power domain for SGA
+ * - EPOD_ID_B2R2_MCDE: power domain for B2R2 and MCDE
+ * - EPOD_ID_ESRAM12: power domain for ESRAM 1 and 2
+ * - EPOD_ID_ESRAM34: power domain for ESRAM 3 and 4
+ * - NUM_EPOD_ID: number of power domains
+ *
+ * TODO: These should be prefixed.
+ */
+#define EPOD_ID_SVAMMDSP	0
+#define EPOD_ID_SVAPIPE		1
+#define EPOD_ID_SIAMMDSP	2
+#define EPOD_ID_SIAPIPE		3
+#define EPOD_ID_SGA		4
+#define EPOD_ID_B2R2_MCDE	5
+#define EPOD_ID_ESRAM12		6
+#define EPOD_ID_ESRAM34		7
+#define NUM_EPOD_ID		8
+
+/*
+ * DB5500 EPODs
+ */
+#define DB5500_EPOD_ID_BASE 0x0100
+#define DB5500_EPOD_ID_SGA (DB5500_EPOD_ID_BASE + 0)
+#define DB5500_EPOD_ID_HVA (DB5500_EPOD_ID_BASE + 1)
+#define DB5500_EPOD_ID_SIA (DB5500_EPOD_ID_BASE + 2)
+#define DB5500_EPOD_ID_DISP (DB5500_EPOD_ID_BASE + 3)
+#define DB5500_EPOD_ID_ESRAM12 (DB5500_EPOD_ID_BASE + 6)
+#define DB5500_NUM_EPOD_ID 7
+
+/*
+ * state definition for EPOD (power domain)
+ * - EPOD_STATE_NO_CHANGE: The EPOD should remain unchanged
+ * - EPOD_STATE_OFF: The EPOD is switched off
+ * - EPOD_STATE_RAMRET: The EPOD is switched off with its internal RAM in
+ *                         retention
+ * - EPOD_STATE_ON_CLK_OFF: The EPOD is switched on, clock is still off
+ * - EPOD_STATE_ON: Same as above, but with clock enabled
+ */
+#define EPOD_STATE_NO_CHANGE	0x00
+#define EPOD_STATE_OFF		0x01
+#define EPOD_STATE_RAMRET	0x02
+#define EPOD_STATE_ON_CLK_OFF	0x03
+#define EPOD_STATE_ON		0x04
+
+/*
+ * CLKOUT sources
+ */
+#define PRCMU_CLKSRC_CLK38M		0x00
+#define PRCMU_CLKSRC_ACLK		0x01
+#define PRCMU_CLKSRC_SYSCLK		0x02
+#define PRCMU_CLKSRC_LCDCLK		0x03
+#define PRCMU_CLKSRC_SDMMCCLK		0x04
+#define PRCMU_CLKSRC_TVCLK		0x05
+#define PRCMU_CLKSRC_TIMCLK		0x06
+#define PRCMU_CLKSRC_CLK009		0x07
+/* These are only valid for CLKOUT1: */
+#define PRCMU_CLKSRC_SIAMMDSPCLK	0x40
+#define PRCMU_CLKSRC_I2CCLK		0x41
+#define PRCMU_CLKSRC_MSP02CLK		0x42
+#define PRCMU_CLKSRC_ARMPLL_OBSCLK	0x43
+#define PRCMU_CLKSRC_HSIRXCLK		0x44
+#define PRCMU_CLKSRC_HSITXCLK		0x45
+#define PRCMU_CLKSRC_ARMCLKFIX		0x46
+#define PRCMU_CLKSRC_HDMICLK		0x47
+
+/*
+ * Clock identifiers.
+ */
+enum prcmu_clock {
+	PRCMU_SGACLK,
+	PRCMU_UARTCLK,
+	PRCMU_MSP02CLK,
+	PRCMU_MSP1CLK,
+	PRCMU_I2CCLK,
+	PRCMU_SDMMCCLK,
+	PRCMU_SLIMCLK,
+	PRCMU_PER1CLK,
+	PRCMU_PER2CLK,
+	PRCMU_PER3CLK,
+	PRCMU_PER5CLK,
+	PRCMU_PER6CLK,
+	PRCMU_PER7CLK,
+	PRCMU_LCDCLK,
+	PRCMU_BMLCLK,
+	PRCMU_HSITXCLK,
+	PRCMU_HSIRXCLK,
+	PRCMU_HDMICLK,
+	PRCMU_APEATCLK,
+	PRCMU_APETRACECLK,
+	PRCMU_MCDECLK,
+	PRCMU_IPI2CCLK,
+	PRCMU_DSIALTCLK,
+	PRCMU_DMACLK,
+	PRCMU_B2R2CLK,
+	PRCMU_TVCLK,
+	PRCMU_SSPCLK,
+	PRCMU_RNGCLK,
+	PRCMU_UICCCLK,
+	PRCMU_PWMCLK,
+	PRCMU_IRDACLK,
+	PRCMU_IRRCCLK,
+	PRCMU_SIACLK,
+	PRCMU_SVACLK,
+	PRCMU_NUM_REG_CLOCKS,
+	PRCMU_SYSCLK = PRCMU_NUM_REG_CLOCKS,
+	PRCMU_TIMCLK,
+	PRCMU_PLLSOC0,
+	PRCMU_PLLSOC1,
+	PRCMU_PLLDDR,
+};
+
+/**
+ * enum ape_opp - APE OPP states definition
+ * @APE_OPP_INIT:
+ * @APE_NO_CHANGE: The APE operating point is unchanged
+ * @APE_100_OPP: The new APE operating point is ape100opp
+ * @APE_50_OPP: 50%
+ */
+enum ape_opp {
+	APE_OPP_INIT = 0x00,
+	APE_NO_CHANGE = 0x01,
+	APE_100_OPP = 0x02,
+	APE_50_OPP = 0x03
+};
+
+/**
+ * enum arm_opp - ARM OPP states definition
+ * @ARM_OPP_INIT:
+ * @ARM_NO_CHANGE: The ARM operating point is unchanged
+ * @ARM_100_OPP: The new ARM operating point is arm100opp
+ * @ARM_50_OPP: The new ARM operating point is arm50opp
+ * @ARM_MAX_OPP: Operating point is "max" (more than 100)
+ * @ARM_MAX_FREQ100OPP: Set max opp if available, else 100
+ * @ARM_EXTCLK: The new ARM operating point is armExtClk
+ */
+enum arm_opp {
+	ARM_OPP_INIT = 0x00,
+	ARM_NO_CHANGE = 0x01,
+	ARM_100_OPP = 0x02,
+	ARM_50_OPP = 0x03,
+	ARM_MAX_OPP = 0x04,
+	ARM_MAX_FREQ100OPP = 0x05,
+	ARM_EXTCLK = 0x07
+};
+
+/**
+ * enum ddr_opp - DDR OPP states definition
+ * @DDR_100_OPP: The new DDR operating point is ddr100opp
+ * @DDR_50_OPP: The new DDR operating point is ddr50opp
+ * @DDR_25_OPP: The new DDR operating point is ddr25opp
+ */
+enum ddr_opp {
+	DDR_100_OPP = 0x00,
+	DDR_50_OPP = 0x01,
+	DDR_25_OPP = 0x02,
+};
+
+/*
+ * Definitions for controlling ESRAM0 in deep sleep.
+ */
+#define ESRAM0_DEEP_SLEEP_STATE_OFF 1
+#define ESRAM0_DEEP_SLEEP_STATE_RET 2
+
+/**
+ * enum ddr_pwrst - DDR power states definition
+ * @DDR_PWR_STATE_UNCHANGED: SDRAM and DDR controller state is unchanged
+ * @DDR_PWR_STATE_ON:
+ * @DDR_PWR_STATE_OFFLOWLAT:
+ * @DDR_PWR_STATE_OFFHIGHLAT:
+ */
+enum ddr_pwrst {
+	DDR_PWR_STATE_UNCHANGED     = 0x00,
+	DDR_PWR_STATE_ON            = 0x01,
+	DDR_PWR_STATE_OFFLOWLAT     = 0x02,
+	DDR_PWR_STATE_OFFHIGHLAT    = 0x03
+};
+
+#include <linux/mfd/db8500-prcmu.h>
+#include <linux/mfd/db5500-prcmu.h>
+
+#if defined(CONFIG_UX500_SOC_DB8500) || defined(CONFIG_UX500_SOC_DB5500)
+
+static inline void __init prcmu_early_init(void)
+{
+	if (machine_is_u5500())
+		return db5500_prcmu_early_init();
+	else
+		return db8500_prcmu_early_init();
+}
+
+static inline int prcmu_set_power_state(u8 state, bool keep_ulp_clk,
+		bool keep_ap_pll)
+{
+	if (machine_is_u5500())
+		return db5500_prcmu_set_power_state(state, keep_ulp_clk,
+			keep_ap_pll);
+	else
+		return db8500_prcmu_set_power_state(state, keep_ulp_clk,
+			keep_ap_pll);
+}
+
+static inline int prcmu_set_epod(u16 epod_id, u8 epod_state)
+{
+	if (machine_is_u5500())
+		return db5500_prcmu_set_epod(epod_id, epod_state);
+	else
+		return db8500_prcmu_set_epod(epod_id, epod_state);
+}
+
+static inline void prcmu_enable_wakeups(u32 wakeups)
+{
+	if (machine_is_u5500())
+		db5500_prcmu_enable_wakeups(wakeups);
+	else
+		db8500_prcmu_enable_wakeups(wakeups);
+}
+
+static inline void prcmu_disable_wakeups(void)
+{
+	prcmu_enable_wakeups(0);
+}
+
+static inline void prcmu_config_abb_event_readout(u32 abb_events)
+{
+	if (machine_is_u5500())
+		db5500_prcmu_config_abb_event_readout(abb_events);
+	else
+		db8500_prcmu_config_abb_event_readout(abb_events);
+}
+
+static inline void prcmu_get_abb_event_buffer(void __iomem **buf)
+{
+	if (machine_is_u5500())
+		db5500_prcmu_get_abb_event_buffer(buf);
+	else
+		db8500_prcmu_get_abb_event_buffer(buf);
+}
+
+int prcmu_abb_read(u8 slave, u8 reg, u8 *value, u8 size);
+int prcmu_abb_write(u8 slave, u8 reg, u8 *value, u8 size);
+
+int prcmu_config_clkout(u8 clkout, u8 source, u8 div);
+
+static inline int prcmu_request_clock(u8 clock, bool enable)
+{
+	if (machine_is_u5500())
+		return db5500_prcmu_request_clock(clock, enable);
+	else
+		return db8500_prcmu_request_clock(clock, enable);
+}
+
+int prcmu_set_ape_opp(u8 opp);
+int prcmu_get_ape_opp(void);
+int prcmu_set_ddr_opp(u8 opp);
+int prcmu_get_ddr_opp(void);
+
+static inline int prcmu_set_arm_opp(u8 opp)
+{
+	if (machine_is_u5500())
+		return db5500_prcmu_set_arm_opp(opp);
+	else
+		return db8500_prcmu_set_arm_opp(opp);
+}
+
+static inline int prcmu_get_arm_opp(void)
+{
+	if (machine_is_u5500())
+		return db5500_prcmu_get_arm_opp();
+	else
+		return db8500_prcmu_get_arm_opp();
+}
+
+static inline void prcmu_system_reset(u16 reset_code)
+{
+	if (machine_is_u5500())
+		return db5500_prcmu_system_reset(reset_code);
+	else
+		return db8500_prcmu_system_reset(reset_code);
+}
+
+static inline u16 prcmu_get_reset_code(void)
+{
+	if (machine_is_u5500())
+		return db5500_prcmu_get_reset_code();
+	else
+		return db8500_prcmu_get_reset_code();
+}
+
+void prcmu_ac_wake_req(void);
+void prcmu_ac_sleep_req(void);
+void prcmu_modem_reset(void);
+static inline bool prcmu_is_ac_wake_requested(void)
+{
+	if (machine_is_u5500())
+		return db5500_prcmu_is_ac_wake_requested();
+	else
+		return db8500_prcmu_is_ac_wake_requested();
+}
+
+static inline int prcmu_set_display_clocks(void)
+{
+	if (machine_is_u5500())
+		return db5500_prcmu_set_display_clocks();
+	else
+		return db8500_prcmu_set_display_clocks();
+}
+
+static inline int prcmu_disable_dsipll(void)
+{
+	if (machine_is_u5500())
+		return db5500_prcmu_disable_dsipll();
+	else
+		return db8500_prcmu_disable_dsipll();
+}
+
+static inline int prcmu_enable_dsipll(void)
+{
+	if (machine_is_u5500())
+		return db5500_prcmu_enable_dsipll();
+	else
+		return db8500_prcmu_enable_dsipll();
+}
+
+static inline int prcmu_config_esram0_deep_sleep(u8 state)
+{
+	if (machine_is_u5500())
+		return db5500_prcmu_config_esram0_deep_sleep(state);
+	else
+		return db8500_prcmu_config_esram0_deep_sleep(state);
+}
+#else
+
+static inline void __init prcmu_early_init(void) {}
+
+static inline int prcmu_set_power_state(u8 state, bool keep_ulp_clk,
+	bool keep_ap_pll)
+{
+	return 0;
+}
+
+static inline int prcmu_set_epod(u16 epod_id, u8 epod_state)
+{
+	return 0;
+}
+
+static inline void prcmu_enable_wakeups(u32 wakeups) {}
+
+static inline void prcmu_disable_wakeups(void) {}
+
+static inline int prcmu_abb_read(u8 slave, u8 reg, u8 *value, u8 size)
+{
+	return -ENOSYS;
+}
+
+static inline int prcmu_abb_write(u8 slave, u8 reg, u8 *value, u8 size)
+{
+	return -ENOSYS;
+}
+
+static inline int prcmu_config_clkout(u8 clkout, u8 source, u8 div)
+{
+	return 0;
+}
+
+static inline int prcmu_request_clock(u8 clock, bool enable)
+{
+	return 0;
+}
+
+static inline int prcmu_set_ape_opp(u8 opp)
+{
+	return 0;
+}
+
+static inline int prcmu_get_ape_opp(void)
+{
+	return APE_100_OPP;
+}
+
+static inline int prcmu_set_arm_opp(u8 opp)
+{
+	return 0;
+}
+
+static inline int prcmu_get_arm_opp(void)
+{
+	return ARM_100_OPP;
+}
+
+static inline int prcmu_set_ddr_opp(u8 opp)
+{
+	return 0;
+}
+
+static inline int prcmu_get_ddr_opp(void)
+{
+	return DDR_100_OPP;
+}
+
+static inline void prcmu_system_reset(u16 reset_code) {}
+
+static inline u16 prcmu_get_reset_code(void)
+{
+	return 0;
+}
+
+static inline void prcmu_ac_wake_req(void) {}
+
+static inline void prcmu_ac_sleep_req(void) {}
+
+static inline void prcmu_modem_reset(void) {}
+
+static inline bool prcmu_is_ac_wake_requested(void)
+{
+	return false;
+}
+
+static inline int prcmu_set_display_clocks(void)
+{
+	return 0;
+}
+
+static inline int prcmu_disable_dsipll(void)
+{
+	return 0;
+}
+
+static inline int prcmu_enable_dsipll(void)
+{
+	return 0;
+}
+
+static inline int prcmu_config_esram0_deep_sleep(u8 state)
+{
+	return 0;
+}
+
+static inline void prcmu_config_abb_event_readout(u32 abb_events) {}
+
+static inline void prcmu_get_abb_event_buffer(void __iomem **buf)
+{
+	*buf = NULL;
+}
+
+#endif
+
+/* PRCMU QoS APE OPP class */
+#define PRCMU_QOS_APE_OPP 1
+#define PRCMU_QOS_DDR_OPP 2
+#define PRCMU_QOS_DEFAULT_VALUE -1
+
+#ifdef CONFIG_UX500_PRCMU_QOS_POWER
+
+unsigned long prcmu_qos_get_cpufreq_opp_delay(void);
+void prcmu_qos_set_cpufreq_opp_delay(unsigned long);
+void prcmu_qos_force_opp(int, s32);
+int prcmu_qos_requirement(int pm_qos_class);
+int prcmu_qos_add_requirement(int pm_qos_class, char *name, s32 value);
+int prcmu_qos_update_requirement(int pm_qos_class, char *name, s32 new_value);
+void prcmu_qos_remove_requirement(int pm_qos_class, char *name);
+int prcmu_qos_add_notifier(int prcmu_qos_class,
+			   struct notifier_block *notifier);
+int prcmu_qos_remove_notifier(int prcmu_qos_class,
+			      struct notifier_block *notifier);
+
+#else
+
+static inline unsigned long prcmu_qos_get_cpufreq_opp_delay(void)
+{
+	return 0;
+}
+
+static inline void prcmu_qos_set_cpufreq_opp_delay(unsigned long n) {}
+
+static inline void prcmu_qos_force_opp(int prcmu_qos_class, s32 i) {}
+
+static inline int prcmu_qos_requirement(int prcmu_qos_class)
+{
+	return 0;
+}
+
+static inline int prcmu_qos_add_requirement(int prcmu_qos_class,
+					    char *name, s32 value)
+{
+	return 0;
+}
+
+static inline int prcmu_qos_update_requirement(int prcmu_qos_class,
+					       char *name, s32 new_value)
+{
+	return 0;
+}
+
+static inline void prcmu_qos_remove_requirement(int prcmu_qos_class, char *name)
+{
+}
+
+static inline int prcmu_qos_add_notifier(int prcmu_qos_class,
+					 struct notifier_block *notifier)
+{
+	return 0;
+}
+static inline int prcmu_qos_remove_notifier(int prcmu_qos_class,
+					    struct notifier_block *notifier)
+{
+	return 0;
+}
+
+#endif
+
+#endif /* __MACH_PRCMU_H */
