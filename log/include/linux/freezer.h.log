commit 05d658b5b57214944067fb4f62bce59200bf496f
Merge: 794c33555f70 2dd9789c76ff
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 13 01:41:20 2017 +0100

    Merge branch 'pm-sleep'
    
    * pm-sleep:
      freezer: Fix typo in freezable_schedule_timeout() comment
      PM / s2idle: Clear the events_check_enabled flag
      PM / sleep: Remove pm_complete_with_resume_check()
      PM: ARM: locomo: Drop suspend and resume bus type callbacks
      PM: Use a more common logging style
      PM: Document rules on using pm_runtime_resume() in system suspend callbacks

commit 2dd9789c76ffde05d5f4c56f45c3cb71b3936694
Author: Himanshu Jha <himanshujha199640@gmail.com>
Date:   Sun Nov 5 03:27:32 2017 +0530

    freezer: Fix typo in freezable_schedule_timeout() comment
    
    Signed-off-by: Himanshu Jha <himanshujha199640@gmail.com>
    Acked-by: Luis R. Rodriguez <mcgrof@kernel.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index dd03e837ebb7..5b2cf48b2a7c 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -181,7 +181,7 @@ static inline void freezable_schedule_unsafe(void)
 }
 
 /*
- * Like freezable_schedule_timeout(), but should not block the freezer.  Do not
+ * Like schedule_timeout(), but should not block the freezer.  Do not
  * call this with locks held.
  */
 static inline long freezable_schedule_timeout(long timeout)

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index dd03e837ebb7..3995df1d068f 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /* Freezer declarations */
 
 #ifndef FREEZER_H_INCLUDED

commit da8b44d5a9f8bf26da637b7336508ca534d6b319
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Mar 17 14:20:51 2016 -0700

    timer: convert timer_slack_ns from unsigned long to u64
    
    This patchset introduces a /proc/<pid>/timerslack_ns interface which
    would allow controlling processes to be able to set the timerslack value
    on other processes in order to save power by avoiding wakeups (Something
    Android currently does via out-of-tree patches).
    
    The first patch tries to fix the internal timer_slack_ns usage which was
    defined as a long, which limits the slack range to ~4 seconds on 32bit
    systems.  It converts it to a u64, which provides the same basically
    unlimited slack (500 years) on both 32bit and 64bit machines.
    
    The second patch introduces the /proc/<pid>/timerslack_ns interface
    which allows the full 64bit slack range for a task to be read or set on
    both 32bit and 64bit machines.
    
    With these two patches, on a 32bit machine, after setting the slack on
    bash to 10 seconds:
    
    $ time sleep 1
    
    real    0m10.747s
    user    0m0.001s
    sys     0m0.005s
    
    The first patch is a little ugly, since I had to chase the slack delta
    arguments through a number of functions converting them to u64s.  Let me
    know if it makes sense to break that up more or not.
    
    Other than that things are fairly straightforward.
    
    This patch (of 2):
    
    The timer_slack_ns value in the task struct is currently a unsigned
    long.  This means that on 32bit applications, the maximum slack is just
    over 4 seconds.  However, on 64bit machines, its much much larger (~500
    years).
    
    This disparity could make application development a little (as well as
    the default_slack) to a u64.  This means both 32bit and 64bit systems
    have the same effective internal slack range.
    
    Now the existing ABI via PR_GET_TIMERSLACK and PR_SET_TIMERSLACK specify
    the interface as a unsigned long, so we preserve that limitation on
    32bit systems, where SET_TIMERSLACK can only set the slack to a unsigned
    long value, and GET_TIMERSLACK will return ULONG_MAX if the slack is
    actually larger then what can be stored by an unsigned long.
    
    This patch also modifies hrtimer functions which specified the slack
    delta as a unsigned long.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Oren Laadan <orenl@cellrox.com>
    Cc: Ruchi Kandoi <kandoiruchi@google.com>
    Cc: Rom Lemarchand <romlem@android.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Android Kernel Team <kernel-team@android.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 6b7fd9cf5ea2..dd03e837ebb7 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -231,7 +231,7 @@ static inline long freezable_schedule_timeout_killable_unsafe(long timeout)
  * call this with locks held.
  */
 static inline int freezable_schedule_hrtimeout_range(ktime_t *expires,
-		unsigned long delta, const enum hrtimer_mode mode)
+		u64 delta, const enum hrtimer_mode mode)
 {
 	int __retval;
 	freezer_do_not_count();

commit 5d4d56582467f3c08dfedd0d995ce2092f384ecc
Author: Peter Zijlstra (Intel) <peterz@infradead.org>
Date:   Wed Oct 29 14:48:13 2014 +0100

    sched/wait: Remove wait_event_freezekillable()
    
    There is no user.. make it go away.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: oleg@redhat.com
    Cc: Rafael Wysocki <rjw@rjwysocki.net>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: linux-pm@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index e203665c0faa..6b7fd9cf5ea2 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -246,15 +246,6 @@ static inline int freezable_schedule_hrtimeout_range(ktime_t *expires,
  * defined in <linux/wait.h>
  */
 
-#define wait_event_freezekillable(wq, condition)			\
-({									\
-	int __retval;							\
-	freezer_do_not_count();						\
-	__retval = wait_event_killable(wq, (condition));		\
-	freezer_count();						\
-	__retval;							\
-})
-
 /* DO NOT ADD ANY NEW CALLERS OF THIS FUNCTION */
 #define wait_event_freezekillable_unsafe(wq, condition)			\
 ({									\
@@ -302,9 +293,6 @@ static inline void set_freezable(void) {}
 #define freezable_schedule_hrtimeout_range(expires, delta, mode)	\
 	schedule_hrtimeout_range(expires, delta, mode)
 
-#define wait_event_freezekillable(wq, condition)		\
-		wait_event_killable(wq, condition)
-
 #define wait_event_freezekillable_unsafe(wq, condition)			\
 		wait_event_killable(wq, condition)
 

commit 36df04bc5273a046f53b5e359febc1225f85aa7b
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Wed Oct 29 12:21:57 2014 +0100

    sched/wait: Reimplement wait_event_freezable()
    
    Provide better implementations of wait_event_freezable() APIs.
    
    The problem is with freezer_do_not_count(), it hides the thread from
    the freezer, even though this thread might not actually freeze/sleep
    at all.
    
    Cc: oleg@redhat.com
    Cc: Rafael Wysocki <rjw@rjwysocki.net>
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: linux-pm@vger.kernel.org
    Link: http://lkml.kernel.org/n/tip-d86fz1jmso9wjxa8jfpinp8o@git.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 7fd81b8c4897..e203665c0faa 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -265,35 +265,6 @@ static inline int freezable_schedule_hrtimeout_range(ktime_t *expires,
 	__retval;							\
 })
 
-#define wait_event_freezable(wq, condition)				\
-({									\
-	int __retval;							\
-	freezer_do_not_count();						\
-	__retval = wait_event_interruptible(wq, (condition));		\
-	freezer_count();						\
-	__retval;							\
-})
-
-#define wait_event_freezable_timeout(wq, condition, timeout)		\
-({									\
-	long __retval = timeout;					\
-	freezer_do_not_count();						\
-	__retval = wait_event_interruptible_timeout(wq,	(condition),	\
-				__retval);				\
-	freezer_count();						\
-	__retval;							\
-})
-
-#define wait_event_freezable_exclusive(wq, condition)			\
-({									\
-	int __retval;							\
-	freezer_do_not_count();						\
-	__retval = wait_event_interruptible_exclusive(wq, condition);	\
-	freezer_count();						\
-	__retval;							\
-})
-
-
 #else /* !CONFIG_FREEZER */
 static inline bool frozen(struct task_struct *p) { return false; }
 static inline bool freezing(struct task_struct *p) { return false; }
@@ -331,15 +302,6 @@ static inline void set_freezable(void) {}
 #define freezable_schedule_hrtimeout_range(expires, delta, mode)	\
 	schedule_hrtimeout_range(expires, delta, mode)
 
-#define wait_event_freezable(wq, condition)				\
-		wait_event_interruptible(wq, condition)
-
-#define wait_event_freezable_timeout(wq, condition, timeout)		\
-		wait_event_interruptible_timeout(wq, condition, timeout)
-
-#define wait_event_freezable_exclusive(wq, condition)			\
-		wait_event_interruptible_exclusive(wq, condition)
-
 #define wait_event_freezekillable(wq, condition)		\
 		wait_event_killable(wq, condition)
 

commit dd5ec0f4e72bed3d0e589e21fdf46eedafc106b7
Author: Colin Cross <ccross@android.com>
Date:   Mon May 6 23:50:14 2013 +0000

    freezer: add new freezable helpers using freezer_do_not_count()
    
    Freezing tasks will wake up almost every userspace task from
    where it is blocking and force it to run until it hits a
    call to try_to_sleep(), generally on the exit path from the syscall
    it is blocking in.  On resume each task will run again, usually
    restarting the syscall and running until it hits the same
    blocking call as it was originally blocked in.
    
    To allow tasks to avoid running on every suspend/resume cycle,
    this patch adds additional freezable wrappers around blocking calls
    that call freezer_do_not_count().  Combined with the previous patch,
    these tasks will not run during suspend or resume unless they wake
    up for another reason, in which case they will run until they hit
    the try_to_freeze() in freezer_count(), and then continue processing
    the wakeup after tasks are thawed.
    
    Additional patches will convert the most common locations that
    userspace blocks in to use freezable helpers.
    
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Colin Cross <ccross@android.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 8430d4c51ece..7fd81b8c4897 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -180,6 +180,32 @@ static inline void freezable_schedule_unsafe(void)
 	freezer_count_unsafe();
 }
 
+/*
+ * Like freezable_schedule_timeout(), but should not block the freezer.  Do not
+ * call this with locks held.
+ */
+static inline long freezable_schedule_timeout(long timeout)
+{
+	long __retval;
+	freezer_do_not_count();
+	__retval = schedule_timeout(timeout);
+	freezer_count();
+	return __retval;
+}
+
+/*
+ * Like schedule_timeout_interruptible(), but should not block the freezer.  Do not
+ * call this with locks held.
+ */
+static inline long freezable_schedule_timeout_interruptible(long timeout)
+{
+	long __retval;
+	freezer_do_not_count();
+	__retval = schedule_timeout_interruptible(timeout);
+	freezer_count();
+	return __retval;
+}
+
 /* Like schedule_timeout_killable(), but should not block the freezer. */
 static inline long freezable_schedule_timeout_killable(long timeout)
 {
@@ -200,6 +226,20 @@ static inline long freezable_schedule_timeout_killable_unsafe(long timeout)
 	return __retval;
 }
 
+/*
+ * Like schedule_hrtimeout_range(), but should not block the freezer.  Do not
+ * call this with locks held.
+ */
+static inline int freezable_schedule_hrtimeout_range(ktime_t *expires,
+		unsigned long delta, const enum hrtimer_mode mode)
+{
+	int __retval;
+	freezer_do_not_count();
+	__retval = schedule_hrtimeout_range(expires, delta, mode);
+	freezer_count();
+	return __retval;
+}
+
 /*
  * Freezer-friendly wrappers around wait_event_interruptible(),
  * wait_event_killable() and wait_event_interruptible_timeout(), originally
@@ -244,6 +284,16 @@ static inline long freezable_schedule_timeout_killable_unsafe(long timeout)
 	__retval;							\
 })
 
+#define wait_event_freezable_exclusive(wq, condition)			\
+({									\
+	int __retval;							\
+	freezer_do_not_count();						\
+	__retval = wait_event_interruptible_exclusive(wq, condition);	\
+	freezer_count();						\
+	__retval;							\
+})
+
+
 #else /* !CONFIG_FREEZER */
 static inline bool frozen(struct task_struct *p) { return false; }
 static inline bool freezing(struct task_struct *p) { return false; }
@@ -267,18 +317,29 @@ static inline void set_freezable(void) {}
 
 #define freezable_schedule_unsafe()  schedule()
 
+#define freezable_schedule_timeout(timeout)  schedule_timeout(timeout)
+
+#define freezable_schedule_timeout_interruptible(timeout)		\
+	schedule_timeout_interruptible(timeout)
+
 #define freezable_schedule_timeout_killable(timeout)			\
 	schedule_timeout_killable(timeout)
 
 #define freezable_schedule_timeout_killable_unsafe(timeout)		\
 	schedule_timeout_killable(timeout)
 
+#define freezable_schedule_hrtimeout_range(expires, delta, mode)	\
+	schedule_hrtimeout_range(expires, delta, mode)
+
 #define wait_event_freezable(wq, condition)				\
 		wait_event_interruptible(wq, condition)
 
 #define wait_event_freezable_timeout(wq, condition, timeout)		\
 		wait_event_interruptible_timeout(wq, condition, timeout)
 
+#define wait_event_freezable_exclusive(wq, condition)			\
+		wait_event_interruptible_exclusive(wq, condition)
+
 #define wait_event_freezekillable(wq, condition)		\
 		wait_event_killable(wq, condition)
 

commit 8ee492d6595573a0d4be168ebda1c7ceb4ec509d
Author: Colin Cross <ccross@android.com>
Date:   Mon May 6 23:50:13 2013 +0000

    freezer: convert freezable helpers to static inline where possible
    
    Some of the freezable helpers have to be macros because their
    condition argument needs to get evaluated every time through
    the wait loop.  Convert the others to static inline to make
    future changes easier.
    
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Colin Cross <ccross@android.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index c71337af9bbd..8430d4c51ece 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -159,46 +159,46 @@ static inline bool freezer_should_skip(struct task_struct *p)
 }
 
 /*
- * These macros are intended to be used whenever you want allow a sleeping
+ * These functions are intended to be used whenever you want allow a sleeping
  * task to be frozen. Note that neither return any clear indication of
  * whether a freeze event happened while in this function.
  */
 
 /* Like schedule(), but should not block the freezer. */
-#define freezable_schedule()						\
-({									\
-	freezer_do_not_count();						\
-	schedule();							\
-	freezer_count();						\
-})
+static inline void freezable_schedule(void)
+{
+	freezer_do_not_count();
+	schedule();
+	freezer_count();
+}
 
 /* DO NOT ADD ANY NEW CALLERS OF THIS FUNCTION */
-#define freezable_schedule_unsafe()					\
-({									\
-	freezer_do_not_count();						\
-	schedule();							\
-	freezer_count_unsafe();						\
-})
+static inline void freezable_schedule_unsafe(void)
+{
+	freezer_do_not_count();
+	schedule();
+	freezer_count_unsafe();
+}
 
 /* Like schedule_timeout_killable(), but should not block the freezer. */
-#define freezable_schedule_timeout_killable(timeout)			\
-({									\
-	long __retval;							\
-	freezer_do_not_count();						\
-	__retval = schedule_timeout_killable(timeout);			\
-	freezer_count();						\
-	__retval;							\
-})
+static inline long freezable_schedule_timeout_killable(long timeout)
+{
+	long __retval;
+	freezer_do_not_count();
+	__retval = schedule_timeout_killable(timeout);
+	freezer_count();
+	return __retval;
+}
 
 /* DO NOT ADD ANY NEW CALLERS OF THIS FUNCTION */
-#define freezable_schedule_timeout_killable_unsafe(timeout)		\
-({									\
-	long __retval;							\
-	freezer_do_not_count();						\
-	__retval = schedule_timeout_killable(timeout);			\
-	freezer_count_unsafe();						\
-	__retval;							\
-})
+static inline long freezable_schedule_timeout_killable_unsafe(long timeout)
+{
+	long __retval;
+	freezer_do_not_count();
+	__retval = schedule_timeout_killable(timeout);
+	freezer_count_unsafe();
+	return __retval;
+}
 
 /*
  * Freezer-friendly wrappers around wait_event_interruptible(),

commit b01235861b84c0f6107d3f9da189c9898fc3caaf
Author: Colin Cross <ccross@android.com>
Date:   Mon May 6 23:50:12 2013 +0000

    freezer: convert freezable helpers to freezer_do_not_count()
    
    Freezing tasks will wake up almost every userspace task from
    where it is blocking and force it to run until it hits a
    call to try_to_sleep(), generally on the exit path from the syscall
    it is blocking in.  On resume each task will run again, usually
    restarting the syscall and running until it hits the same
    blocking call as it was originally blocked in.
    
    Convert the existing wait_event_freezable* wrappers to use
    freezer_do_not_count().  Combined with a previous patch,
    these tasks will not run during suspend or resume unless they wake
    up for another reason, in which case they will run until they hit
    the try_to_freeze() in freezer_count(), and then continue processing
    the wakeup after tasks are thawed.
    
    This results in a small change in behavior, previously a race
    between freezing and a normal wakeup would be won by the wakeup,
    now the task will freeze and then handle the wakeup after thawing.
    
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Colin Cross <ccross@android.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index bcf9e651cc85..c71337af9bbd 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -228,27 +228,19 @@ static inline bool freezer_should_skip(struct task_struct *p)
 #define wait_event_freezable(wq, condition)				\
 ({									\
 	int __retval;							\
-	for (;;) {							\
-		__retval = wait_event_interruptible(wq, 		\
-				(condition) || freezing(current));	\
-		if (__retval || (condition))				\
-			break;						\
-		try_to_freeze();					\
-	}								\
+	freezer_do_not_count();						\
+	__retval = wait_event_interruptible(wq, (condition));		\
+	freezer_count();						\
 	__retval;							\
 })
 
 #define wait_event_freezable_timeout(wq, condition, timeout)		\
 ({									\
 	long __retval = timeout;					\
-	for (;;) {							\
-		__retval = wait_event_interruptible_timeout(wq,		\
-				(condition) || freezing(current),	\
-				__retval); 				\
-		if (__retval <= 0 || (condition))			\
-			break;						\
-		try_to_freeze();					\
-	}								\
+	freezer_do_not_count();						\
+	__retval = wait_event_interruptible_timeout(wq,	(condition),	\
+				__retval);				\
+	freezer_count();						\
 	__retval;							\
 })
 

commit 0f9548ca10916dec166eaf74c816bded7d8e611d
Author: Mandeep Singh Baines <msb@chromium.org>
Date:   Mon May 6 23:50:09 2013 +0000

    lockdep: check that no locks held at freeze time
    
    We shouldn't try_to_freeze if locks are held.  Holding a lock can cause a
    deadlock if the lock is later acquired in the suspend or hibernate path
    (e.g.  by dpm).  Holding a lock can also cause a deadlock in the case of
    cgroup_freezer if a lock is held inside a frozen cgroup that is later
    acquired by a process outside that group.
    
    History:
    This patch was originally applied as 6aa9707099c and reverted in
    dbf520a9d7d4 because NFS was freezing with locks held.  It was
    deemed better to keep the bad freeze point in NFS to allow laptops
    to suspend consistently.  The previous patch in this series converts
    NFS to call _unsafe versions of the freezable helpers so that
    lockdep doesn't complain about them until a more correct fix
    can be applied.
    
    [akpm@linux-foundation.org: export debug_check_no_locks_held]
    Signed-off-by: Mandeep Singh Baines <msb@chromium.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Colin Cross <ccross@android.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index d3c038ec9a88..bcf9e651cc85 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -3,6 +3,7 @@
 #ifndef FREEZER_H_INCLUDED
 #define FREEZER_H_INCLUDED
 
+#include <linux/debug_locks.h>
 #include <linux/sched.h>
 #include <linux/wait.h>
 #include <linux/atomic.h>
@@ -60,6 +61,8 @@ static inline bool try_to_freeze_unsafe(void)
 
 static inline bool try_to_freeze(void)
 {
+	if (!(current->flags & PF_NOFREEZE))
+		debug_check_no_locks_held();
 	return try_to_freeze_unsafe();
 }
 

commit 5853cc2a89f726e21d51ca0fd75757a03126a84b
Author: Colin Cross <ccross@android.com>
Date:   Tue May 7 17:52:05 2013 +0000

    freezer: add unsafe versions of freezable helpers for CIFS
    
    CIFS calls wait_event_freezekillable_unsafe with a VFS lock held,
    which is unsafe and will cause lockdep warnings when 6aa9707
    "lockdep: check that no locks held at freeze time" is reapplied
    (it was reverted in dbf520a).  CIFS shouldn't be doing this, but
    it has long-running syscalls that must hold a lock but also
    shouldn't block suspend.  Until CIFS freeze handling is rewritten
    to use a signal to exit out of the critical section, add a new
    wait_event_freezekillable_unsafe helper that will not run the
    lockdep test when 6aa9707 is reapplied, and call it from CIFS.
    
    In practice the likley result of holding the lock while freezing
    is that a second task blocked on the lock will never freeze,
    aborting suspend, but it is possible to manufacture a case using
    the cgroup freezer, the lock, and the suspend freezer to create
    a deadlock.  Silencing the lockdep warning here will allow
    problems to be found in other drivers that may have a more
    serious deadlock risk, and prevent new problems from being added.
    
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Acked-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Colin Cross <ccross@android.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 5b31e21c485f..d3c038ec9a88 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -212,6 +212,16 @@ static inline bool freezer_should_skip(struct task_struct *p)
 	__retval;							\
 })
 
+/* DO NOT ADD ANY NEW CALLERS OF THIS FUNCTION */
+#define wait_event_freezekillable_unsafe(wq, condition)			\
+({									\
+	int __retval;							\
+	freezer_do_not_count();						\
+	__retval = wait_event_killable(wq, (condition));		\
+	freezer_count_unsafe();						\
+	__retval;							\
+})
+
 #define wait_event_freezable(wq, condition)				\
 ({									\
 	int __retval;							\
@@ -277,6 +287,9 @@ static inline void set_freezable(void) {}
 #define wait_event_freezekillable(wq, condition)		\
 		wait_event_killable(wq, condition)
 
+#define wait_event_freezekillable_unsafe(wq, condition)			\
+		wait_event_killable(wq, condition)
+
 #endif /* !CONFIG_FREEZER */
 
 #endif	/* FREEZER_H_INCLUDED */

commit 416ad3c9c0066405b83ec875b75496523549be09
Author: Colin Cross <ccross@android.com>
Date:   Mon May 6 23:50:06 2013 +0000

    freezer: add unsafe versions of freezable helpers for NFS
    
    NFS calls the freezable helpers with locks held, which is unsafe
    and will cause lockdep warnings when 6aa9707 "lockdep: check
    that no locks held at freeze time" is reapplied (it was reverted
    in dbf520a).  NFS shouldn't be doing this, but it has
    long-running syscalls that must hold a lock but also shouldn't
    block suspend.  Until NFS freeze handling is rewritten to use a
    signal to exit out of the critical section, add new *_unsafe
    versions of the helpers that will not run the lockdep test when
    6aa9707 is reapplied, and call them from NFS.
    
    In practice the likley result of holding the lock while freezing
    is that a second task blocked on the lock will never freeze,
    aborting suspend, but it is possible to manufacture a case using
    the cgroup freezer, the lock, and the suspend freezer to create
    a deadlock.  Silencing the lockdep warning here will allow
    problems to be found in other drivers that may have a more
    serious deadlock risk, and prevent new problems from being added.
    
    Signed-off-by: Colin Cross <ccross@android.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index e70df40d84f6..5b31e21c485f 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -46,7 +46,11 @@ extern int freeze_kernel_threads(void);
 extern void thaw_processes(void);
 extern void thaw_kernel_threads(void);
 
-static inline bool try_to_freeze(void)
+/*
+ * DO NOT ADD ANY NEW CALLERS OF THIS FUNCTION
+ * If try_to_freeze causes a lockdep warning it means the caller may deadlock
+ */
+static inline bool try_to_freeze_unsafe(void)
 {
 	might_sleep();
 	if (likely(!freezing(current)))
@@ -54,6 +58,11 @@ static inline bool try_to_freeze(void)
 	return __refrigerator(false);
 }
 
+static inline bool try_to_freeze(void)
+{
+	return try_to_freeze_unsafe();
+}
+
 extern bool freeze_task(struct task_struct *p);
 extern bool set_freezable(void);
 
@@ -115,6 +124,14 @@ static inline void freezer_count(void)
 	try_to_freeze();
 }
 
+/* DO NOT ADD ANY NEW CALLERS OF THIS FUNCTION */
+static inline void freezer_count_unsafe(void)
+{
+	current->flags &= ~PF_FREEZER_SKIP;
+	smp_mb();
+	try_to_freeze_unsafe();
+}
+
 /**
  * freezer_should_skip - whether to skip a task when determining frozen
  *			 state is reached
@@ -152,6 +169,14 @@ static inline bool freezer_should_skip(struct task_struct *p)
 	freezer_count();						\
 })
 
+/* DO NOT ADD ANY NEW CALLERS OF THIS FUNCTION */
+#define freezable_schedule_unsafe()					\
+({									\
+	freezer_do_not_count();						\
+	schedule();							\
+	freezer_count_unsafe();						\
+})
+
 /* Like schedule_timeout_killable(), but should not block the freezer. */
 #define freezable_schedule_timeout_killable(timeout)			\
 ({									\
@@ -162,6 +187,16 @@ static inline bool freezer_should_skip(struct task_struct *p)
 	__retval;							\
 })
 
+/* DO NOT ADD ANY NEW CALLERS OF THIS FUNCTION */
+#define freezable_schedule_timeout_killable_unsafe(timeout)		\
+({									\
+	long __retval;							\
+	freezer_do_not_count();						\
+	__retval = schedule_timeout_killable(timeout);			\
+	freezer_count_unsafe();						\
+	__retval;							\
+})
+
 /*
  * Freezer-friendly wrappers around wait_event_interruptible(),
  * wait_event_killable() and wait_event_interruptible_timeout(), originally
@@ -225,9 +260,14 @@ static inline void set_freezable(void) {}
 
 #define freezable_schedule()  schedule()
 
+#define freezable_schedule_unsafe()  schedule()
+
 #define freezable_schedule_timeout_killable(timeout)			\
 	schedule_timeout_killable(timeout)
 
+#define freezable_schedule_timeout_killable_unsafe(timeout)		\
+	schedule_timeout_killable(timeout)
+
 #define wait_event_freezable(wq, condition)				\
 		wait_event_interruptible(wq, condition)
 

commit dbf520a9d7d4d5ba28d2947be11e34099a5e3e20
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Mar 31 00:04:40 2013 +0000

    Revert "lockdep: check that no locks held at freeze time"
    
    This reverts commit 6aa9707099c4b25700940eb3d016f16c4434360d.
    
    Commit 6aa9707099c4 ("lockdep: check that no locks held at freeze time")
    causes problems with NFS root filesystems.  The failures were noticed on
    OMAP2 and 3 boards during kernel init:
    
      [ BUG: swapper/0/1 still has locks held! ]
      3.9.0-rc3-00344-ga937536 #1 Not tainted
      -------------------------------------
      1 lock held by swapper/0/1:
       #0:  (&type->s_umount_key#13/1){+.+.+.}, at: [<c011e84c>] sget+0x248/0x574
    
      stack backtrace:
        rpc_wait_bit_killable
        __wait_on_bit
        out_of_line_wait_on_bit
        __rpc_execute
        rpc_run_task
        rpc_call_sync
        nfs_proc_get_root
        nfs_get_root
        nfs_fs_mount_common
        nfs_try_mount
        nfs_fs_mount
        mount_fs
        vfs_kern_mount
        do_mount
        sys_mount
        do_mount_root
        mount_root
        prepare_namespace
        kernel_init_freeable
        kernel_init
    
    Although the rootfs mounts, the system is unstable.  Here's a transcript
    from a PM test:
    
      http://www.pwsan.com/omap/testlogs/test_v3.9-rc3/20130317194234/pm/37xxevm/37xxevm_log.txt
    
    Here's what the test log should look like:
    
      http://www.pwsan.com/omap/testlogs/test_v3.8/20130218214403/pm/37xxevm/37xxevm_log.txt
    
    Mailing list discussion is here:
    
      http://lkml.org/lkml/2013/3/4/221
    
    Deal with this for v3.9 by reverting the problem commit, until folks can
    figure out the right long-term course of action.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Mandeep Singh Baines <msb@chromium.org>
    Cc: Jeff Layton <jlayton@redhat.com>
    Cc: Shawn Guo <shawn.guo@linaro.org>
    Cc: <maciej.rutecki@gmail.com>
    Cc: Fengguang Wu <fengguang.wu@intel.com>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ben Chan <benchan@chromium.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 043a5cf8b5ba..e70df40d84f6 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -3,7 +3,6 @@
 #ifndef FREEZER_H_INCLUDED
 #define FREEZER_H_INCLUDED
 
-#include <linux/debug_locks.h>
 #include <linux/sched.h>
 #include <linux/wait.h>
 #include <linux/atomic.h>
@@ -49,8 +48,6 @@ extern void thaw_kernel_threads(void);
 
 static inline bool try_to_freeze(void)
 {
-	if (!(current->flags & PF_NOFREEZE))
-		debug_check_no_locks_held();
 	might_sleep();
 	if (likely(!freezing(current)))
 		return false;

commit 6aa9707099c4b25700940eb3d016f16c4434360d
Author: Mandeep Singh Baines <msb@chromium.org>
Date:   Wed Feb 27 17:03:18 2013 -0800

    lockdep: check that no locks held at freeze time
    
    We shouldn't try_to_freeze if locks are held.  Holding a lock can cause a
    deadlock if the lock is later acquired in the suspend or hibernate path
    (e.g.  by dpm).  Holding a lock can also cause a deadlock in the case of
    cgroup_freezer if a lock is held inside a frozen cgroup that is later
    acquired by a process outside that group.
    
    [akpm@linux-foundation.org: export debug_check_no_locks_held]
    Signed-off-by: Mandeep Singh Baines <msb@chromium.org>
    Cc: Ben Chan <benchan@chromium.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Ingo Molnar <mingo@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index e70df40d84f6..043a5cf8b5ba 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -3,6 +3,7 @@
 #ifndef FREEZER_H_INCLUDED
 #define FREEZER_H_INCLUDED
 
+#include <linux/debug_locks.h>
 #include <linux/sched.h>
 #include <linux/wait.h>
 #include <linux/atomic.h>
@@ -48,6 +49,8 @@ extern void thaw_kernel_threads(void);
 
 static inline bool try_to_freeze(void)
 {
+	if (!(current->flags & PF_NOFREEZE))
+		debug_check_no_locks_held();
 	might_sleep();
 	if (likely(!freezing(current)))
 		return false;

commit 957d1282bb8c07e682e142b9237cd9fcb8348a0b
Author: Li Fei <fei.li@intel.com>
Date:   Fri Feb 1 08:56:03 2013 +0000

    suspend: enable freeze timeout configuration through sys
    
    At present, the value of timeout for freezing is 20s, which is
    meaningless in case that one thread is frozen with mutex locked
    and another thread is trying to lock the mutex, as this time of
    freezing will fail unavoidably.
    And if there is no new wakeup event registered, the system will
    waste at most 20s for such meaningless trying of freezing.
    
    With this patch, the value of timeout can be configured to smaller
    value, so such meaningless trying of freezing will be aborted in
    earlier time, and later freezing can be also triggered in earlier
    time. And more power will be saved.
    In normal case on mobile phone, it costs real little time to freeze
    processes. On some platform, it only costs about 20ms to freeze
    user space processes and 10ms to freeze kernel freezable threads.
    
    Signed-off-by: Liu Chuansheng <chuansheng.liu@intel.com>
    Signed-off-by: Li Fei <fei.li@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index e4238ceaa4d6..e70df40d84f6 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -12,6 +12,11 @@ extern atomic_t system_freezing_cnt;	/* nr of freezing conds in effect */
 extern bool pm_freezing;		/* PM freezing in effect */
 extern bool pm_nosig_freezing;		/* PM nosig freezing in effect */
 
+/*
+ * Timeout for stopping processes
+ */
+extern unsigned int freeze_timeout_msecs;
+
 /*
  * Check if a process has been frozen
  */

commit d206e09036d6201f90b2719484c8a59526c46125
Merge: fef3ff2eb777 15ef4ffaa797
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 12 08:18:24 2012 -0800

    Merge branch 'for-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/cgroup
    
    Pull cgroup changes from Tejun Heo:
     "A lot of activities on cgroup side.  The big changes are focused on
      making cgroup hierarchy handling saner.
    
       - cgroup_rmdir() had peculiar semantics - it allowed cgroup
         destruction to be vetoed by individual controllers and tried to
         drain refcnt synchronously.  The vetoing never worked properly and
         caused good deal of contortions in cgroup.  memcg was the last
         reamining user.  Michal Hocko removed the usage and cgroup_rmdir()
         path has been simplified significantly.  This was done in a
         separate branch so that the memcg people can base further memcg
         changes on top.
    
       - The above allowed cleaning up cgroup lifecycle management and
         implementation of generic cgroup iterators which are used to
         improve hierarchy support.
    
       - cgroup_freezer updated to allow migration in and out of a frozen
         cgroup and handle hierarchy.  If a cgroup is frozen, all descendant
         cgroups are frozen.
    
       - netcls_cgroup and netprio_cgroup updated to handle hierarchy
         properly.
    
       - Various fixes and cleanups.
    
       - Two merge commits.  One to pull in memcg and rmdir cleanups (needed
         to build iterators).  The other pulled in cgroup/for-3.7-fixes for
         device_cgroup fixes so that further device_cgroup patches can be
         stacked on top."
    
    Fixed up a trivial conflict in mm/memcontrol.c as per Tejun (due to
    commit bea8c150a7 ("memcg: fix hotplugged memory zone oops") in master
    touching code close to commit 2ef37d3fe4 ("memcg: Simplify
    mem_cgroup_force_empty_list error handling") in for-3.8)
    
    * 'for-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/cgroup: (65 commits)
      cgroup: update Documentation/cgroups/00-INDEX
      cgroup_rm_file: don't delete the uncreated files
      cgroup: remove subsystem files when remounting cgroup
      cgroup: use cgroup_addrm_files() in cgroup_clear_directory()
      cgroup: warn about broken hierarchies only after css_online
      cgroup: list_del_init() on removed events
      cgroup: fix lockdep warning for event_control
      cgroup: move list add after list head initilization
      netprio_cgroup: allow nesting and inherit config on cgroup creation
      netprio_cgroup: implement netprio[_set]_prio() helpers
      netprio_cgroup: use cgroup->id instead of cgroup_netprio_state->prioidx
      netprio_cgroup: reimplement priomap expansion
      netprio_cgroup: shorten variable names in extend_netdev_table()
      netprio_cgroup: simplify write_priomap()
      netcls_cgroup: move config inheritance to ->css_online() and remove .broken_hierarchy marking
      cgroup: remove obsolete guarantee from cgroup_task_migrate.
      cgroup: add cgroup->id
      cgroup, cpuset: remove cgroup_subsys->post_clone()
      cgroup: s/CGRP_CLONE_CHILDREN/CGRP_CPUSET_CLONE_CHILDREN/
      cgroup: rename ->create/post_create/pre_destroy/destroy() to ->css_alloc/online/offline/free()
      ...

commit e5f5762177be52fde50ccba88938d66b5103c8e0
Author: Li Haifeng <omycle@gmail.com>
Date:   Fri Nov 23 21:55:19 2012 +0100

    PM / Freezer: Fixup compile error of try_to_freeze_nowarn()
    
    If FREEZER is not defined, the error as following will be throw
    when compiled.
    arch/arm/kernel/signal.c:645: error: implicit declaration of function
    'try_to_freeze_nowarn'
    
    Signed-off-by: Haifeng Li <omycle@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index d09af4b67cf1..b90091af5798 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -177,6 +177,7 @@ static inline int freeze_kernel_threads(void) { return -ENOSYS; }
 static inline void thaw_processes(void) {}
 static inline void thaw_kernel_threads(void) {}
 
+static inline bool try_to_freeze_nowarn(void) { return false; }
 static inline bool try_to_freeze(void) { return false; }
 
 static inline void freezer_do_not_count(void) {}

commit 5d8f72b55c275677865de670fa147ed318191d81
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Fri Oct 26 19:46:06 2012 +0200

    freezer: change ptrace_stop/do_signal_stop to use freezable_schedule()
    
    try_to_freeze_tasks() and cgroup_freezer rely on scheduler locks
    to ensure that a task doing STOPPED/TRACED -> RUNNING transition
    can't escape freezing. This mostly works, but ptrace_stop() does
    not necessarily call schedule(), it can change task->state back to
    RUNNING and check freezing() without any lock/barrier in between.
    
    We could add the necessary barrier, but this patch changes
    ptrace_stop() and do_signal_stop() to use freezable_schedule().
    This fixes the race, freezer_count() and freezer_should_skip()
    carefully avoid the race.
    
    And this simplifies the code, try_to_freeze_tasks/update_if_frozen
    no longer need to use task_is_stopped_or_traced() checks with the
    non trivial assumptions. We can rely on the mechanism which was
    specially designed to mark the sleeping task as "frozen enough".
    
    v2: As Tejun pointed out, we can also change get_signal_to_deliver()
    and move try_to_freeze() up before 'relock' label.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index ee899329e65a..8039893bc3ec 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -134,10 +134,9 @@ static inline bool freezer_should_skip(struct task_struct *p)
 }
 
 /*
- * These macros are intended to be used whenever you want allow a task that's
- * sleeping in TASK_UNINTERRUPTIBLE or TASK_KILLABLE state to be frozen. Note
- * that neither return any clear indication of whether a freeze event happened
- * while in this function.
+ * These macros are intended to be used whenever you want allow a sleeping
+ * task to be frozen. Note that neither return any clear indication of
+ * whether a freeze event happened while in this function.
  */
 
 /* Like schedule(), but should not block the freezer. */

commit dd67d32dbc5de299d70cc9e10c6c1e29ffa56b92
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Oct 16 15:03:14 2012 -0700

    freezer: add missing mb's to freezer_count() and freezer_should_skip()
    
    A task is considered frozen enough between freezer_do_not_count() and
    freezer_count() and freezers use freezer_should_skip() to test this
    condition.  This supposedly works because freezer_count() always calls
    try_to_freezer() after clearing %PF_FREEZER_SKIP.
    
    However, there currently is nothing which guarantees that
    freezer_count() sees %true freezing() after clearing %PF_FREEZER_SKIP
    when freezing is in progress, and vice-versa.  A task can escape the
    freezing condition in effect by freezer_count() seeing !freezing() and
    freezer_should_skip() seeing %PF_FREEZER_SKIP.
    
    This patch adds smp_mb()'s to freezer_count() and
    freezer_should_skip() such that either %true freezing() is visible to
    freezer_count() or !PF_FREEZER_SKIP is visible to
    freezer_should_skip().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: stable@vger.kernel.org

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index d09af4b67cf1..ee899329e65a 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -75,28 +75,62 @@ static inline bool cgroup_freezing(struct task_struct *task)
  */
 
 
-/* Tell the freezer not to count the current task as freezable. */
+/**
+ * freezer_do_not_count - tell freezer to ignore %current
+ *
+ * Tell freezers to ignore the current task when determining whether the
+ * target frozen state is reached.  IOW, the current task will be
+ * considered frozen enough by freezers.
+ *
+ * The caller shouldn't do anything which isn't allowed for a frozen task
+ * until freezer_cont() is called.  Usually, freezer[_do_not]_count() pair
+ * wrap a scheduling operation and nothing much else.
+ */
 static inline void freezer_do_not_count(void)
 {
 	current->flags |= PF_FREEZER_SKIP;
 }
 
-/*
- * Tell the freezer to count the current task as freezable again and try to
- * freeze it.
+/**
+ * freezer_count - tell freezer to stop ignoring %current
+ *
+ * Undo freezer_do_not_count().  It tells freezers that %current should be
+ * considered again and tries to freeze if freezing condition is already in
+ * effect.
  */
 static inline void freezer_count(void)
 {
 	current->flags &= ~PF_FREEZER_SKIP;
+	/*
+	 * If freezing is in progress, the following paired with smp_mb()
+	 * in freezer_should_skip() ensures that either we see %true
+	 * freezing() or freezer_should_skip() sees !PF_FREEZER_SKIP.
+	 */
+	smp_mb();
 	try_to_freeze();
 }
 
-/*
- * Check if the task should be counted as freezable by the freezer
+/**
+ * freezer_should_skip - whether to skip a task when determining frozen
+ *			 state is reached
+ * @p: task in quesion
+ *
+ * This function is used by freezers after establishing %true freezing() to
+ * test whether a task should be skipped when determining the target frozen
+ * state is reached.  IOW, if this function returns %true, @p is considered
+ * frozen enough.
  */
-static inline int freezer_should_skip(struct task_struct *p)
+static inline bool freezer_should_skip(struct task_struct *p)
 {
-	return !!(p->flags & PF_FREEZER_SKIP);
+	/*
+	 * The following smp_mb() paired with the one in freezer_count()
+	 * ensures that either freezer_count() sees %true freezing() or we
+	 * see cleared %PF_FREEZER_SKIP and return %false.  This makes it
+	 * impossible for a task to slip frozen state testing after
+	 * clearing %PF_FREEZER_SKIP.
+	 */
+	smp_mb();
+	return p->flags & PF_FREEZER_SKIP;
 }
 
 /*

commit 181e9bdef37bfcaa41f3ab6c948a2a0d60a268b5
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jan 29 20:35:52 2012 +0100

    PM / Hibernate: Fix s2disk regression related to freezing workqueues
    
    Commit 2aede851ddf08666f68ffc17be446420e9d2a056
    
      PM / Hibernate: Freeze kernel threads after preallocating memory
    
    introduced a mechanism by which kernel threads were frozen after
    the preallocation of hibernate image memory to avoid problems with
    frozen kernel threads not responding to memory freeing requests.
    However, it overlooked the s2disk code path in which the
    SNAPSHOT_CREATE_IMAGE ioctl was run directly after SNAPSHOT_FREE,
    which caused freeze_workqueues_begin() to BUG(), because it saw
    that worqueues had been already frozen.
    
    Although in principle this issue might be addressed by removing
    the relevant BUG_ON() from freeze_workqueues_begin(), that would
    reintroduce the very problem that commit 2aede851ddf08666f68ffc17be4
    attempted to avoid into that particular code path.  For this reason,
    to fix the issue at hand, introduce thaw_kernel_threads() and make
    the SNAPSHOT_FREE ioctl execute it.
    
    Special thanks to Srivatsa S. Bhat for detailed analysis of the
    problem.
    
    Reported-and-tested-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Cc: stable@kernel.org

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 0ab54e16a91f..d09af4b67cf1 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -39,6 +39,7 @@ extern bool __refrigerator(bool check_kthr_stop);
 extern int freeze_processes(void);
 extern int freeze_kernel_threads(void);
 extern void thaw_processes(void);
+extern void thaw_kernel_threads(void);
 
 static inline bool try_to_freeze(void)
 {
@@ -174,6 +175,7 @@ static inline bool __refrigerator(bool check_kthr_stop) { return false; }
 static inline int freeze_processes(void) { return -ENOSYS; }
 static inline int freeze_kernel_threads(void) { return -ENOSYS; }
 static inline void thaw_processes(void) {}
+static inline void thaw_kernel_threads(void) {}
 
 static inline bool try_to_freeze(void) { return false; }
 

commit b3b73ec0d7fe5bf8f950232aa58dfa0416a62372
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Dec 26 00:29:55 2011 +0100

    PM / Freezer: fix return value of freezable_schedule_timeout_killable()
    
    ...it should return the return code from schedule_timeout_killable(),
    not the one from freezer_count().
    
    All of the current callers ignore the return code so the bug is
    harmless but it's worth fixing.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 7bcfe73d999b..0ab54e16a91f 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -116,9 +116,11 @@ static inline int freezer_should_skip(struct task_struct *p)
 /* Like schedule_timeout_killable(), but should not block the freezer. */
 #define freezable_schedule_timeout_killable(timeout)			\
 ({									\
+	long __retval;							\
 	freezer_do_not_count();						\
-	schedule_timeout_killable(timeout);				\
+	__retval = schedule_timeout_killable(timeout);			\
 	freezer_count();						\
+	__retval;							\
 })
 
 /*

commit 467de1fc67d1bd2954eaac7019c564f28fa2b6a5
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Tue Dec 6 23:17:51 2011 +0100

    PM / Freezer: Remove the "userspace only" constraint from freezer[_do_not]_count()
    
    At present, the functions freezer_count() and freezer_do_not_count()
    impose the restriction that they are effective only for userspace processes.
    However, now, these functions have found more utility than originally
    intended by the commit which introduced it: ba96a0c8 (freezer:
    fix vfork problem). And moreover, even the vfork issue actually does not
    need the above restriction in these functions.
    
    So, modify these functions to make them work even for kernel threads, so
    that they can be used at other places in the kernel, where the userspace
    restriction doesn't apply.
    
    Suggested-by: Oleg Nesterov <oleg@redhat.com>
    Suggested-by: Tejun Heo <tj@kernel.org>
    Acked-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 30f06c220467..7bcfe73d999b 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -67,33 +67,27 @@ static inline bool cgroup_freezing(struct task_struct *task)
  * appropriately in case the child has exited before the freezing of tasks is
  * complete.  However, we don't want kernel threads to be frozen in unexpected
  * places, so we allow them to block freeze_processes() instead or to set
- * PF_NOFREEZE if needed and PF_FREEZER_SKIP is only set for userland vfork
- * parents.  Fortunately, in the ____call_usermodehelper() case the parent won't
- * really block freeze_processes(), since ____call_usermodehelper() (the child)
- * does a little before exec/exit and it can't be frozen before waking up the
- * parent.
+ * PF_NOFREEZE if needed. Fortunately, in the ____call_usermodehelper() case the
+ * parent won't really block freeze_processes(), since ____call_usermodehelper()
+ * (the child) does a little before exec/exit and it can't be frozen before
+ * waking up the parent.
  */
 
-/*
- * If the current task is a user space one, tell the freezer not to count it as
- * freezable.
- */
+
+/* Tell the freezer not to count the current task as freezable. */
 static inline void freezer_do_not_count(void)
 {
-	if (current->mm)
-		current->flags |= PF_FREEZER_SKIP;
+	current->flags |= PF_FREEZER_SKIP;
 }
 
 /*
- * If the current task is a user space one, tell the freezer to count it as
- * freezable again and try to freeze it.
+ * Tell the freezer to count the current task as freezable again and try to
+ * freeze it.
  */
 static inline void freezer_count(void)
 {
-	if (current->mm) {
-		current->flags &= ~PF_FREEZER_SKIP;
-		try_to_freeze();
-	}
+	current->flags &= ~PF_FREEZER_SKIP;
+	try_to_freeze();
 }
 
 /*

commit d310310cbff18ec385c6ab4d58f33b100192a96a
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Dec 1 22:44:39 2011 +0100

    Freezer / sunrpc / NFS: don't allow TASK_KILLABLE sleeps to block the freezer
    
    Allow the freezer to skip wait_on_bit_killable sleeps in the sunrpc
    layer. This should allow suspend and hibernate events to proceed, even
    when there are RPC's pending on the wire.
    
    Also, wrap the TASK_KILLABLE sleeps in NFS layer in freezer_do_not_count
    and freezer_count calls. This allows the freezer to skip tasks that are
    sleeping while looping on EJUKEBOX or NFS4ERR_DELAY sorts of errors.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index c1ee2833655e..30f06c220467 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -104,6 +104,29 @@ static inline int freezer_should_skip(struct task_struct *p)
 	return !!(p->flags & PF_FREEZER_SKIP);
 }
 
+/*
+ * These macros are intended to be used whenever you want allow a task that's
+ * sleeping in TASK_UNINTERRUPTIBLE or TASK_KILLABLE state to be frozen. Note
+ * that neither return any clear indication of whether a freeze event happened
+ * while in this function.
+ */
+
+/* Like schedule(), but should not block the freezer. */
+#define freezable_schedule()						\
+({									\
+	freezer_do_not_count();						\
+	schedule();							\
+	freezer_count();						\
+})
+
+/* Like schedule_timeout_killable(), but should not block the freezer. */
+#define freezable_schedule_timeout_killable(timeout)			\
+({									\
+	freezer_do_not_count();						\
+	schedule_timeout_killable(timeout);				\
+	freezer_count();						\
+})
+
 /*
  * Freezer-friendly wrappers around wait_event_interruptible(),
  * wait_event_killable() and wait_event_interruptible_timeout(), originally
@@ -163,6 +186,11 @@ static inline void freezer_count(void) {}
 static inline int freezer_should_skip(struct task_struct *p) { return 0; }
 static inline void set_freezable(void) {}
 
+#define freezable_schedule()  schedule()
+
+#define freezable_schedule_timeout_killable(timeout)			\
+	schedule_timeout_killable(timeout)
+
 #define wait_event_freezable(wq, condition)				\
 		wait_event_interruptible(wq, condition)
 

commit 62c9ea6b120688d800b4d892eaf737c20a73e86b
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Fri Nov 25 00:44:55 2011 +0100

    Freezer: fix more fallout from the thaw_process rename
    
    Commit 944e192db53c "freezer: rename thaw_process() to __thaw_task()
    and simplify the implementation" did not create a !CONFIG_FREEZER version
    of __thaw_task().
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 09570ac22be6..c1ee2833655e 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -149,6 +149,7 @@ static inline int freezer_should_skip(struct task_struct *p)
 #else /* !CONFIG_FREEZER */
 static inline bool frozen(struct task_struct *p) { return false; }
 static inline bool freezing(struct task_struct *p) { return false; }
+static inline void __thaw_task(struct task_struct *t) {}
 
 static inline bool __refrigerator(bool check_kthr_stop) { return false; }
 static inline int freeze_processes(void) { return -ENOSYS; }

commit 24b7ead3fb0bae267c2ee50898eb4c13aedd1e9f
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Wed Nov 23 09:28:17 2011 -0800

    freezer: fix wait_event_freezable/__thaw_task races
    
    wait_event_freezable() and friends stop the waiting if try_to_freeze()
    fails. This is not right, we can race with __thaw_task() and in this
    case
    
            - wait_event_freezable() returns the wrong ERESTARTSYS
    
            - wait_event_freezable_timeout() can return the positive
              value while condition == F
    
    Change the code to always check __retval/condition before return.
    
    Note: with or without this patch the timeout logic looks strange,
    probably we should recalc timeout if try_to_freeze() returns T.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index a33550fc05c5..09570ac22be6 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -122,28 +122,30 @@ static inline int freezer_should_skip(struct task_struct *p)
 #define wait_event_freezable(wq, condition)				\
 ({									\
 	int __retval;							\
-	do {								\
+	for (;;) {							\
 		__retval = wait_event_interruptible(wq, 		\
 				(condition) || freezing(current));	\
-		if (__retval && !freezing(current))			\
+		if (__retval || (condition))				\
 			break;						\
-		else if (!(condition))					\
-			__retval = -ERESTARTSYS;			\
-	} while (try_to_freeze());					\
+		try_to_freeze();					\
+	}								\
 	__retval;							\
 })
 
-
 #define wait_event_freezable_timeout(wq, condition, timeout)		\
 ({									\
 	long __retval = timeout;					\
-	do {								\
+	for (;;) {							\
 		__retval = wait_event_interruptible_timeout(wq,		\
 				(condition) || freezing(current),	\
 				__retval); 				\
-	} while (try_to_freeze());					\
+		if (__retval <= 0 || (condition))			\
+			break;						\
+		try_to_freeze();					\
+	}								\
 	__retval;							\
 })
+
 #else /* !CONFIG_FREEZER */
 static inline bool frozen(struct task_struct *p) { return false; }
 static inline bool freezing(struct task_struct *p) { return false; }

commit 34b087e48367c252e343c2f8de65676a78af1e4a
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Nov 23 09:28:17 2011 -0800

    freezer: kill unused set_freezable_with_signal()
    
    There's no in-kernel user of set_freezable_with_signal() left.  Mixing
    TIF_SIGPENDING with kernel threads can lead to nasty corner cases as
    kernel threads never travel signal delivery path on their own.
    
    e.g. the current implementation is buggy in the cancelation path of
    __thaw_task().  It calls recalc_sigpending_and_wake() in an attempt to
    clear TIF_SIGPENDING but the function never clears it regardless of
    sigpending state.  This means that signallable freezable kthreads may
    continue executing with !freezing() && stuck TIF_SIGPENDING, which can
    be troublesome.
    
    This patch removes set_freezable_with_signal() along with
    PF_FREEZER_NOSIG and recalc_sigpending*() calls in freezer.  User
    tasks get TIF_SIGPENDING, kernel tasks get woken up and the spurious
    sigpending is dealt with in the usual signal delivery path.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Oleg Nesterov <oleg@redhat.com>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index a28842e588f4..a33550fc05c5 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -49,7 +49,7 @@ static inline bool try_to_freeze(void)
 }
 
 extern bool freeze_task(struct task_struct *p);
-extern bool __set_freezable(bool with_signal);
+extern bool set_freezable(void);
 
 #ifdef CONFIG_CGROUP_FREEZER
 extern bool cgroup_freezing(struct task_struct *task);
@@ -104,23 +104,6 @@ static inline int freezer_should_skip(struct task_struct *p)
 	return !!(p->flags & PF_FREEZER_SKIP);
 }
 
-/*
- * Tell the freezer that the current task should be frozen by it
- */
-static inline bool set_freezable(void)
-{
-	return __set_freezable(false);
-}
-
-/*
- * Tell the freezer that the current task should be frozen by it and that it
- * should send a fake signal to the task to freeze it.
- */
-static inline bool set_freezable_with_signal(void)
-{
-	return __set_freezable(true);
-}
-
 /*
  * Freezer-friendly wrappers around wait_event_interruptible(),
  * wait_event_killable() and wait_event_interruptible_timeout(), originally
@@ -176,7 +159,6 @@ static inline void freezer_do_not_count(void) {}
 static inline void freezer_count(void) {}
 static inline int freezer_should_skip(struct task_struct *p) { return 0; }
 static inline void set_freezable(void) {}
-static inline void set_freezable_with_signal(void) {}
 
 #define wait_event_freezable(wq, condition)				\
 		wait_event_interruptible(wq, condition)

commit 839e3407d90a810318d17c17ceb3d5928a910704
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 21 12:32:26 2011 -0800

    freezer: remove unused @sig_only from freeze_task()
    
    After "freezer: make freezing() test freeze conditions in effect
    instead of TIF_FREEZE", freezing() returns authoritative answer on
    whether the current task should freeze or not and freeze_task()
    doesn't need or use @sig_only.  Remove it.
    
    While at it, rewrite function comment for freeze_task() and rename
    @sig_only to @user_only in try_to_freeze_tasks().
    
    This patch doesn't cause any functional change.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Oleg Nesterov <oleg@redhat.com>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index a0f1b3a3604f..a28842e588f4 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -48,7 +48,7 @@ static inline bool try_to_freeze(void)
 	return __refrigerator(false);
 }
 
-extern bool freeze_task(struct task_struct *p, bool sig_only);
+extern bool freeze_task(struct task_struct *p);
 extern bool __set_freezable(bool with_signal);
 
 #ifdef CONFIG_CGROUP_FREEZER

commit 96ee6d8539c9fc6742908d85eb9723abb5c91854
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 21 12:32:25 2011 -0800

    freezer: fix set_freezable[_with_signal]() race
    
    A kthread doing set_freezable*() may race with on-going PM freeze and
    the freezer might think all tasks are frozen while the new freezable
    kthread is merrily proceeding to execute code paths which aren't
    supposed to be executing during PM freeze.
    
    Reimplement set_freezable[_with_signal]() using __set_freezable() such
    that freezable PF flags are modified under freezer_lock and
    try_to_freeze() is called afterwards.  This eliminates race condition
    against freezing.
    
    Note: Separated out from larger patch to resolve fix order dependency
          Oleg pointed out.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Oleg Nesterov <oleg@redhat.com>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 3d50913d39d0..a0f1b3a3604f 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -49,6 +49,7 @@ static inline bool try_to_freeze(void)
 }
 
 extern bool freeze_task(struct task_struct *p, bool sig_only);
+extern bool __set_freezable(bool with_signal);
 
 #ifdef CONFIG_CGROUP_FREEZER
 extern bool cgroup_freezing(struct task_struct *task);
@@ -106,18 +107,18 @@ static inline int freezer_should_skip(struct task_struct *p)
 /*
  * Tell the freezer that the current task should be frozen by it
  */
-static inline void set_freezable(void)
+static inline bool set_freezable(void)
 {
-	current->flags &= ~PF_NOFREEZE;
+	return __set_freezable(false);
 }
 
 /*
  * Tell the freezer that the current task should be frozen by it and that it
  * should send a fake signal to the task to freeze it.
  */
-static inline void set_freezable_with_signal(void)
+static inline bool set_freezable_with_signal(void)
 {
-	current->flags &= ~(PF_NOFREEZE | PF_FREEZER_NOSIG);
+	return __set_freezable(true);
 }
 
 /*

commit 948246f70a811c872b9d93bb4a8ab5823c4c79e0
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 21 12:32:25 2011 -0800

    freezer: remove should_send_signal() and update frozen()
    
    should_send_signal() is only used in freezer.c.  Exporting them only
    increases chance of abuse.  Open code the two users and remove it.
    
    Update frozen() to return bool.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 8e29f2b7ce11..3d50913d39d0 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -15,7 +15,7 @@ extern bool pm_nosig_freezing;		/* PM nosig freezing in effect */
 /*
  * Check if a process has been frozen
  */
-static inline int frozen(struct task_struct *p)
+static inline bool frozen(struct task_struct *p)
 {
 	return p->flags & PF_FROZEN;
 }
@@ -32,11 +32,6 @@ static inline bool freezing(struct task_struct *p)
 	return freezing_slow_path(p);
 }
 
-static inline bool should_send_signal(struct task_struct *p)
-{
-	return !(p->flags & PF_FREEZER_NOSIG);
-}
-
 /* Takes and releases task alloc lock using task_lock() */
 extern void __thaw_task(struct task_struct *t);
 
@@ -166,7 +161,7 @@ static inline void set_freezable_with_signal(void)
 	__retval;							\
 })
 #else /* !CONFIG_FREEZER */
-static inline int frozen(struct task_struct *p) { return 0; }
+static inline bool frozen(struct task_struct *p) { return false; }
 static inline bool freezing(struct task_struct *p) { return false; }
 
 static inline bool __refrigerator(bool check_kthr_stop) { return false; }

commit a3201227f803ad7fd43180c5195dbe5a2bf998aa
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 21 12:32:25 2011 -0800

    freezer: make freezing() test freeze conditions in effect instead of TIF_FREEZE
    
    Using TIF_FREEZE for freezing worked when there was only single
    freezing condition (the PM one); however, now there is also the
    cgroup_freezer and single bit flag is getting clumsy.
    thaw_processes() is already testing whether cgroup freezing in in
    effect to avoid thawing tasks which were frozen by both PM and cgroup
    freezers.
    
    This is racy (nothing prevents race against cgroup freezing) and
    fragile.  A much simpler way is to test actual freeze conditions from
    freezing() - ie. directly test whether PM or cgroup freezing is in
    effect.
    
    This patch adds variables to indicate whether and what type of
    freezing conditions are in effect and reimplements freezing() such
    that it directly tests whether any of the two freezing conditions is
    active and the task should freeze.  On fast path, freezing() is still
    very cheap - it only tests system_freezing_cnt.
    
    This makes the clumsy dancing aroung TIF_FREEZE unnecessary and
    freeze/thaw operations more usual - updating state variables for the
    new state and nudging target tasks so that they notice the new state
    and comply.  As long as the nudging happens after state update, it's
    race-free.
    
    * This allows use of freezing() in freeze_task().  Replace the open
      coded tests with freezing().
    
    * p != current test is added to warning printing conditions in
      try_to_freeze_tasks() failure path.  This is necessary as freezing()
      is now true for the task which initiated freezing too.
    
    -v2: Oleg pointed out that re-freezing FROZEN cgroup could increment
         system_freezing_cnt.  Fixed.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Paul Menage <paul@paulmenage.org>  (for the cgroup portions)

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index b2b4abc5a739..8e29f2b7ce11 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -5,8 +5,13 @@
 
 #include <linux/sched.h>
 #include <linux/wait.h>
+#include <linux/atomic.h>
 
 #ifdef CONFIG_FREEZER
+extern atomic_t system_freezing_cnt;	/* nr of freezing conds in effect */
+extern bool pm_freezing;		/* PM freezing in effect */
+extern bool pm_nosig_freezing;		/* PM nosig freezing in effect */
+
 /*
  * Check if a process has been frozen
  */
@@ -15,28 +20,16 @@ static inline int frozen(struct task_struct *p)
 	return p->flags & PF_FROZEN;
 }
 
-/*
- * Check if there is a request to freeze a process
- */
-static inline int freezing(struct task_struct *p)
-{
-	return test_tsk_thread_flag(p, TIF_FREEZE);
-}
+extern bool freezing_slow_path(struct task_struct *p);
 
 /*
- * Request that a process be frozen
- */
-static inline void set_freeze_flag(struct task_struct *p)
-{
-	set_tsk_thread_flag(p, TIF_FREEZE);
-}
-
-/*
- * Sometimes we may need to cancel the previous 'freeze' request
+ * Check if there is a request to freeze a process
  */
-static inline void clear_freeze_flag(struct task_struct *p)
+static inline bool freezing(struct task_struct *p)
 {
-	clear_tsk_thread_flag(p, TIF_FREEZE);
+	if (likely(!atomic_read(&system_freezing_cnt)))
+		return false;
+	return freezing_slow_path(p);
 }
 
 static inline bool should_send_signal(struct task_struct *p)
@@ -174,9 +167,7 @@ static inline void set_freezable_with_signal(void)
 })
 #else /* !CONFIG_FREEZER */
 static inline int frozen(struct task_struct *p) { return 0; }
-static inline int freezing(struct task_struct *p) { return 0; }
-static inline void set_freeze_flag(struct task_struct *p) {}
-static inline void clear_freeze_flag(struct task_struct *p) {}
+static inline bool freezing(struct task_struct *p) { return false; }
 
 static inline bool __refrigerator(bool check_kthr_stop) { return false; }
 static inline int freeze_processes(void) { return -ENOSYS; }

commit 22b4e111fa01a1147aa562ceaf18a752a928ef4e
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 21 12:32:25 2011 -0800

    cgroup_freezer: prepare for removal of TIF_FREEZE
    
    TIF_FREEZE will be removed soon and freezing() will directly test
    whether any freezing condition is in effect.  Make the following
    changes in preparation.
    
    * Rename cgroup_freezing_or_frozen() to cgroup_freezing() and make it
      return bool.
    
    * Make cgroup_freezing() access task_freezer() under rcu read lock
      instead of task_lock().  This makes the state dereferencing racy
      against task moving to another cgroup; however, it was already racy
      without this change as ->state dereference wasn't synchronized.
      This will be later dealt with using attach hooks.
    
    * freezer->state is now set before trying to push tasks into the
      target state.
    
    -v2: Oleg pointed out that freeze_change_state() was setting
         freeze->state incorrectly to CGROUP_FROZEN instead of
         CGROUP_FREEZING.  Fixed.
    
    -v3: Matt pointed out that setting CGROUP_FROZEN used to always invoke
         try_to_freeze_cgroup() regardless of the current state.  Patch
         updated such that the actual freeze/thaw operations are always
         performed on invocation.  This shouldn't make any difference
         unless something is broken.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Paul Menage <paul@paulmenage.org>
    Cc: Li Zefan <lizf@cn.fujitsu.com>
    Cc: Oleg Nesterov <oleg@redhat.com>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 93f411a52872..b2b4abc5a739 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -63,11 +63,11 @@ static inline bool try_to_freeze(void)
 extern bool freeze_task(struct task_struct *p, bool sig_only);
 
 #ifdef CONFIG_CGROUP_FREEZER
-extern int cgroup_freezing_or_frozen(struct task_struct *task);
+extern bool cgroup_freezing(struct task_struct *task);
 #else /* !CONFIG_CGROUP_FREEZER */
-static inline int cgroup_freezing_or_frozen(struct task_struct *task)
+static inline bool cgroup_freezing(struct task_struct *task)
 {
-	return 0;
+	return false;
 }
 #endif /* !CONFIG_CGROUP_FREEZER */
 

commit 03afed8bc296fa70186ba832c1126228bb992465
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 21 12:32:24 2011 -0800

    freezer: clean up freeze_processes() failure path
    
    freeze_processes() failure path is rather messy.  Freezing is canceled
    for workqueues and tasks which aren't frozen yet but frozen tasks are
    left alone and should be thawed by the caller and of course some
    callers (xen and kexec) didn't do it.
    
    This patch updates __thaw_task() to handle cancelation correctly and
    makes freeze_processes() and freeze_kernel_threads() call
    thaw_processes() on failure instead so that the system is fully thawed
    on failure.  Unnecessary [suspend_]thaw_processes() calls are removed
    from kernel/power/hibernate.c, suspend.c and user.c.
    
    While at it, restructure error checking if clause in suspend_prepare()
    to be less weird.
    
    -v2: Srivatsa spotted missing removal of suspend_thaw_processes() in
         suspend_prepare() and error in commit message.  Updated.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index ba4f512d2938..93f411a52872 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -61,7 +61,6 @@ static inline bool try_to_freeze(void)
 }
 
 extern bool freeze_task(struct task_struct *p, bool sig_only);
-extern void cancel_freezing(struct task_struct *p);
 
 #ifdef CONFIG_CGROUP_FREEZER
 extern int cgroup_freezing_or_frozen(struct task_struct *task);

commit a5be2d0d1a8746e7be5210e3d6b904455000443c
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 21 12:32:23 2011 -0800

    freezer: rename thaw_process() to __thaw_task() and simplify the implementation
    
    thaw_process() now has only internal users - system and cgroup
    freezers.  Remove the unnecessary return value, rename, unexport and
    collapse __thaw_process() into it.  This will help further updates to
    the freezer code.
    
    -v3: oom_kill grew a use of thaw_process() while this patch was
         pending.  Convert it to use __thaw_task() for now.  In the longer
         term, this should be handled by allowing tasks to die if killed
         even if it's frozen.
    
    -v2: minor style update as suggested by Matt.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Paul Menage <menage@google.com>
    Cc: Matt Helsley <matthltc@us.ibm.com>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index d02b78448b0f..ba4f512d2938 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -45,7 +45,7 @@ static inline bool should_send_signal(struct task_struct *p)
 }
 
 /* Takes and releases task alloc lock using task_lock() */
-extern int thaw_process(struct task_struct *p);
+extern void __thaw_task(struct task_struct *t);
 
 extern bool __refrigerator(bool check_kthr_stop);
 extern int freeze_processes(void);
@@ -178,7 +178,6 @@ static inline int frozen(struct task_struct *p) { return 0; }
 static inline int freezing(struct task_struct *p) { return 0; }
 static inline void set_freeze_flag(struct task_struct *p) {}
 static inline void clear_freeze_flag(struct task_struct *p) {}
-static inline int thaw_process(struct task_struct *p) { return 1; }
 
 static inline bool __refrigerator(bool check_kthr_stop) { return false; }
 static inline int freeze_processes(void) { return -ENOSYS; }

commit 8a32c441c1609f80e55df75422324a1151208f40
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 21 12:32:23 2011 -0800

    freezer: implement and use kthread_freezable_should_stop()
    
    Writeback and thinkpad_acpi have been using thaw_process() to prevent
    deadlock between the freezer and kthread_stop(); unfortunately, this
    is inherently racy - nothing prevents freezing from happening between
    thaw_process() and kthread_stop().
    
    This patch implements kthread_freezable_should_stop() which enters
    refrigerator if necessary but is guaranteed to return if
    kthread_stop() is invoked.  Both thaw_process() users are converted to
    use the new function.
    
    Note that this deadlock condition exists for many of freezable
    kthreads.  They need to be converted to use the new should_stop or
    freezable workqueue.
    
    Tested with synthetic test case.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Henrique de Moraes Holschuh <ibm-acpi@hmh.eng.br>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Oleg Nesterov <oleg@redhat.com>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 7a9427e9fe47..d02b78448b0f 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -47,7 +47,7 @@ static inline bool should_send_signal(struct task_struct *p)
 /* Takes and releases task alloc lock using task_lock() */
 extern int thaw_process(struct task_struct *p);
 
-extern bool __refrigerator(void);
+extern bool __refrigerator(bool check_kthr_stop);
 extern int freeze_processes(void);
 extern int freeze_kernel_threads(void);
 extern void thaw_processes(void);
@@ -57,7 +57,7 @@ static inline bool try_to_freeze(void)
 	might_sleep();
 	if (likely(!freezing(current)))
 		return false;
-	return __refrigerator();
+	return __refrigerator(false);
 }
 
 extern bool freeze_task(struct task_struct *p, bool sig_only);
@@ -180,7 +180,7 @@ static inline void set_freeze_flag(struct task_struct *p) {}
 static inline void clear_freeze_flag(struct task_struct *p) {}
 static inline int thaw_process(struct task_struct *p) { return 1; }
 
-static inline bool __refrigerator(void) { return false; }
+static inline bool __refrigerator(bool check_kthr_stop) { return false; }
 static inline int freeze_processes(void) { return -ENOSYS; }
 static inline int freeze_kernel_threads(void) { return -ENOSYS; }
 static inline void thaw_processes(void) {}

commit a0acae0e886d44bd5ce6d2f173c1ace0fcf0d9f6
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 21 12:32:22 2011 -0800

    freezer: unexport refrigerator() and update try_to_freeze() slightly
    
    There is no reason to export two functions for entering the
    refrigerator.  Calling refrigerator() instead of try_to_freeze()
    doesn't save anything noticeable or removes any race condition.
    
    * Rename refrigerator() to __refrigerator() and make it return bool
      indicating whether it scheduled out for freezing.
    
    * Update try_to_freeze() to return bool and relay the return value of
      __refrigerator() if freezing().
    
    * Convert all refrigerator() users to try_to_freeze().
    
    * Update documentation accordingly.
    
    * While at it, add might_sleep() to try_to_freeze().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Samuel Ortiz <samuel@sortiz.org>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: KONISHI Ryusuke <konishi.ryusuke@lab.ntt.co.jp>
    Cc: Christoph Hellwig <hch@infradead.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index a5386e3ee756..7a9427e9fe47 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -47,18 +47,17 @@ static inline bool should_send_signal(struct task_struct *p)
 /* Takes and releases task alloc lock using task_lock() */
 extern int thaw_process(struct task_struct *p);
 
-extern void refrigerator(void);
+extern bool __refrigerator(void);
 extern int freeze_processes(void);
 extern int freeze_kernel_threads(void);
 extern void thaw_processes(void);
 
-static inline int try_to_freeze(void)
+static inline bool try_to_freeze(void)
 {
-	if (freezing(current)) {
-		refrigerator();
-		return 1;
-	} else
-		return 0;
+	might_sleep();
+	if (likely(!freezing(current)))
+		return false;
+	return __refrigerator();
 }
 
 extern bool freeze_task(struct task_struct *p, bool sig_only);
@@ -181,12 +180,12 @@ static inline void set_freeze_flag(struct task_struct *p) {}
 static inline void clear_freeze_flag(struct task_struct *p) {}
 static inline int thaw_process(struct task_struct *p) { return 1; }
 
-static inline void refrigerator(void) {}
+static inline bool __refrigerator(void) { return false; }
 static inline int freeze_processes(void) { return -ENOSYS; }
 static inline int freeze_kernel_threads(void) { return -ENOSYS; }
 static inline void thaw_processes(void) {}
 
-static inline int try_to_freeze(void) { return 0; }
+static inline bool try_to_freeze(void) { return false; }
 
 static inline void freezer_do_not_count(void) {}
 static inline void freezer_count(void) {}

commit 6f35c4abd7f0294166a5e0ab0401fe7949b33034
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Thu Nov 3 16:07:49 2011 -0700

    PM / Freezer: Reimplement wait_event_freezekillable using freezer_do_not_count/freezer_count
    
    Commit 27920651fe "PM / Freezer: Make fake_signal_wake_up() wake
    TASK_KILLABLE tasks too" updated fake_signal_wake_up() used by freezer
    to wake up KILLABLE tasks.  Sending unsolicited wakeups to tasks in
    killable sleep is dangerous as there are code paths which depend on
    tasks not waking up spuriously from KILLABLE sleep.
    
    For example. sys_read() or page can sleep in TASK_KILLABLE assuming
    that wait/down/whatever _killable can only fail if we can not return
    to the usermode.  TASK_TRACED is another obvious example.
    
    The offending commit was to resolve freezer hang during system PM
    operations caused by KILLABLE sleeps in network filesystems.
    wait_event_freezekillable(), which depends on the spurious KILLABLE
    wakeup, was added by f06ac72e92 "cifs, freezer: add
    wait_event_freezekillable and have cifs use it" to be used to
    implement killable & freezable sleeps in network filesystems.
    
    To prepare for reverting of 27920651fe, this patch reimplements
    wait_event_freezekillable() using freezer_do_not_count/freezer_count()
    so that it doesn't depend on the spurious KILLABLE wakeup.  This isn't
    very nice but should do for now.
    
    [tj: Refreshed patch to apply to linus/master and updated commit
        description on Rafael's request.]
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index a49b52934c55..a5386e3ee756 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -143,14 +143,9 @@ static inline void set_freezable_with_signal(void)
 #define wait_event_freezekillable(wq, condition)			\
 ({									\
 	int __retval;							\
-	do {								\
-		__retval = wait_event_killable(wq,			\
-				(condition) || freezing(current));	\
-		if (__retval && !freezing(current))			\
-			break;						\
-		else if (!(condition))					\
-			__retval = -ERESTARTSYS;			\
-	} while (try_to_freeze());					\
+	freezer_do_not_count();						\
+	__retval = wait_event_killable(wq, (condition));		\
+	freezer_count();						\
 	__retval;							\
 })
 

commit dabcbb1bae0f55378060b285062b20f6ec648c6a
Merge: 5619a693965b e0c8ea1a6941
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 28 10:43:32 2011 -0700

    Merge branch '3.2-without-smb2' of git://git.samba.org/sfrench/cifs-2.6
    
    * '3.2-without-smb2' of git://git.samba.org/sfrench/cifs-2.6: (52 commits)
      Fix build break when freezer not configured
      Add definition for share encryption
      CIFS: Make cifs_push_locks send as many locks at once as possible
      CIFS: Send as many mandatory unlock ranges at once as possible
      CIFS: Implement caching mechanism for posix brlocks
      CIFS: Implement caching mechanism for mandatory brlocks
      CIFS: Fix DFS handling in cifs_get_file_info
      CIFS: Fix error handling in cifs_readv_complete
      [CIFS] Fixup trivial checkpatch warning
      [CIFS] Show nostrictsync and noperm mount options in /proc/mounts
      cifs, freezer: add wait_event_freezekillable and have cifs use it
      cifs: allow cifs_max_pending to be readable under /sys/module/cifs/parameters
      cifs: tune bdi.ra_pages in accordance with the rsize
      cifs: allow for larger rsize= options and change defaults
      cifs: convert cifs_readpages to use async reads
      cifs: add cifs_async_readv
      cifs: fix protocol definition for READ_RSP
      cifs: add a callback function to receive the rest of the frame
      cifs: break out 3rd receive phase into separate function
      cifs: find mid earlier in receive codepath
      ...

commit e0c8ea1a69410ef44043646938a6a4175f5307e4
Author: Steve French <smfrench@gmail.com>
Date:   Tue Oct 25 10:02:53 2011 -0500

    Fix build break when freezer not configured
    
    fs/cifs/transport.c: In function 'wait_for_response':
    fs/cifs/transport.c:328: error: implicit declaration of function 'wait_event_freezekillable'
    
    Caused by commit f06ac72e9291 ("cifs, freezer: add
    wait_event_freezekillable and have cifs use it").  In this config,
    CONFIG_FREEZER is not set.
    
    Reviewed-by: Shirish Pargaonkar <shirishp@us.ibm.com>
    CC: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index a1555618801d..5989883d7763 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -203,6 +203,9 @@ static inline void set_freezable_with_signal(void) {}
 #define wait_event_freezable_timeout(wq, condition, timeout)		\
 		wait_event_interruptible_timeout(wq, condition, timeout)
 
+#define wait_event_freezekillable(wq, condition)		\
+		wait_event_killable(wq, condition)
+
 #endif /* !CONFIG_FREEZER */
 
 #endif	/* FREEZER_H_INCLUDED */

commit b957ae9c53d5715a07f8bac644d8ff0a407c7e07
Author: Steve French <smfrench@gmail.com>
Date:   Wed Oct 19 21:27:11 2011 -0500

    [CIFS] Fixup trivial checkpatch warning
    
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 3672f731f03a..a1555618801d 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -143,7 +143,7 @@ static inline void set_freezable_with_signal(void)
 ({									\
 	int __retval;							\
 	do {								\
-		__retval = wait_event_killable(wq, 			\
+		__retval = wait_event_killable(wq,			\
 				(condition) || freezing(current));	\
 		if (__retval && !freezing(current))			\
 			break;						\

commit f06ac72e929115f2772c29727152ba0832d641e4
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Oct 19 15:30:40 2011 -0400

    cifs, freezer: add wait_event_freezekillable and have cifs use it
    
    CIFS currently uses wait_event_killable to put tasks to sleep while
    they await replies from the server. That function though does not
    allow the freezer to run. In many cases, the network interface may
    be going down anyway, in which case the reply will never come. The
    client then ends up blocking the computer from suspending.
    
    Fix this by adding a new wait_event_freezable variant --
    wait_event_freezekillable. The idea is to combine the behavior of
    wait_event_killable and wait_event_freezable -- put the task to
    sleep and only allow it to be awoken by fatal signals, but also
    allow the freezer to do its job.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 1effc8b56b4e..3672f731f03a 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -134,10 +134,25 @@ static inline void set_freezable_with_signal(void)
 }
 
 /*
- * Freezer-friendly wrappers around wait_event_interruptible() and
- * wait_event_interruptible_timeout(), originally defined in <linux/wait.h>
+ * Freezer-friendly wrappers around wait_event_interruptible(),
+ * wait_event_killable() and wait_event_interruptible_timeout(), originally
+ * defined in <linux/wait.h>
  */
 
+#define wait_event_freezekillable(wq, condition)			\
+({									\
+	int __retval;							\
+	do {								\
+		__retval = wait_event_killable(wq, 			\
+				(condition) || freezing(current));	\
+		if (__retval && !freezing(current))			\
+			break;						\
+		else if (!(condition))					\
+			__retval = -ERESTARTSYS;			\
+	} while (try_to_freeze());					\
+	__retval;							\
+})
+
 #define wait_event_freezable(wq, condition)				\
 ({									\
 	int __retval;							\

commit 2aede851ddf08666f68ffc17be446420e9d2a056
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Sep 26 20:32:27 2011 +0200

    PM / Hibernate: Freeze kernel threads after preallocating memory
    
    There is a problem with the current ordering of hibernate code which
    leads to deadlocks in some filesystems' memory shrinkers.  Namely,
    some filesystems use freezable kernel threads that are inactive when
    the hibernate memory preallocation is carried out.  Those same
    filesystems use memory shrinkers that may be triggered by the
    hibernate memory preallocation.  If those memory shrinkers wait for
    the frozen kernel threads, the hibernate process deadlocks (this
    happens with XFS, for one example).
    
    Apparently, it is not technically viable to redesign the filesystems
    in question to avoid the situation described above, so the only
    possible solution of this issue is to defer the freezing of kernel
    threads until the hibernate memory preallocation is done, which is
    implemented by this change.
    
    Unfortunately, this requires the memory preallocation to be done
    before the "prepare" stage of device freeze, so after this change the
    only way drivers can allocate additional memory for their freeze
    routines in a clean way is to use PM notifiers.
    
    Reported-by: Christoph <cr2005@u-club.de>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 1effc8b56b4e..aa56cf31f7ff 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -49,6 +49,7 @@ extern int thaw_process(struct task_struct *p);
 
 extern void refrigerator(void);
 extern int freeze_processes(void);
+extern int freeze_kernel_threads(void);
 extern void thaw_processes(void);
 
 static inline int try_to_freeze(void)
@@ -171,7 +172,8 @@ static inline void clear_freeze_flag(struct task_struct *p) {}
 static inline int thaw_process(struct task_struct *p) { return 1; }
 
 static inline void refrigerator(void) {}
-static inline int freeze_processes(void) { BUG(); return 0; }
+static inline int freeze_processes(void) { return -ENOSYS; }
+static inline int freeze_kernel_threads(void) { return -ENOSYS; }
 static inline void thaw_processes(void) {}
 
 static inline int try_to_freeze(void) { return 0; }

commit 58a69cb47ec6991bf006a3e5d202e8571b0327a4
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Feb 16 09:25:31 2011 +0100

    workqueue, freezer: unify spelling of 'freeze' + 'able' to 'freezable'
    
    There are two spellings in use for 'freeze' + 'able' - 'freezable' and
    'freezeable'.  The former is the more prominent one.  The latter is
    mostly used by workqueue and in a few other odd places.  Unify the
    spelling to 'freezable'.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Dmitry Torokhov <dtor@mail.ru>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Alex Dubov <oakad@yahoo.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index da7e52b099f3..1effc8b56b4e 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -109,7 +109,7 @@ static inline void freezer_count(void)
 }
 
 /*
- * Check if the task should be counted as freezeable by the freezer
+ * Check if the task should be counted as freezable by the freezer
  */
 static inline int freezer_should_skip(struct task_struct *p)
 {

commit 5a7aadfe2fcb0f69e2acc1fbefe22a096e792fc9
Author: Matt Helsley <matthltc@us.ibm.com>
Date:   Fri Mar 26 23:51:44 2010 +0100

    Freezer: Fix buggy resume test for tasks frozen with cgroup freezer
    
    When the cgroup freezer is used to freeze tasks we do not want to thaw
    those tasks during resume. Currently we test the cgroup freezer
    state of the resuming tasks to see if the cgroup is FROZEN.  If so
    then we don't thaw the task. However, the FREEZING state also indicates
    that the task should remain frozen.
    
    This also avoids a problem pointed out by Oren Ladaan: the freezer state
    transition from FREEZING to FROZEN is updated lazily when userspace reads
    or writes the freezer.state file in the cgroup filesystem. This means that
    resume will thaw tasks in cgroups which should be in the FROZEN state if
    there is no read/write of the freezer.state file to trigger this
    transition before suspend.
    
    NOTE: Another "simple" solution would be to always update the cgroup
    freezer state during resume. However it's a bad choice for several reasons:
    Updating the cgroup freezer state is somewhat expensive because it requires
    walking all the tasks in the cgroup and checking if they are each frozen.
    Worse, this could easily make resume run in N^2 time where N is the number
    of tasks in the cgroup. Finally, updating the freezer state from this code
    path requires trickier locking because of the way locks must be ordered.
    
    Instead of updating the freezer state we rely on the fact that lazy
    updates only manage the transition from FREEZING to FROZEN. We know that
    a cgroup with the FREEZING state may actually be FROZEN so test for that
    state too. This makes sense in the resume path even for partially-frozen
    cgroups -- those that really are FREEZING but not FROZEN.
    
    Reported-by: Oren Ladaan <orenl@cs.columbia.edu>
    Signed-off-by: Matt Helsley <matthltc@us.ibm.com>
    Cc: stable@kernel.org
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 5a361f85cfec..da7e52b099f3 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -64,9 +64,12 @@ extern bool freeze_task(struct task_struct *p, bool sig_only);
 extern void cancel_freezing(struct task_struct *p);
 
 #ifdef CONFIG_CGROUP_FREEZER
-extern int cgroup_frozen(struct task_struct *task);
+extern int cgroup_freezing_or_frozen(struct task_struct *task);
 #else /* !CONFIG_CGROUP_FREEZER */
-static inline int cgroup_frozen(struct task_struct *task) { return 0; }
+static inline int cgroup_freezing_or_frozen(struct task_struct *task)
+{
+	return 0;
+}
 #endif /* !CONFIG_CGROUP_FREEZER */
 
 /*

commit 00c2e63c31d0f431952ff2a671c5c6997dd4f8b2
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Wed Oct 29 14:00:53 2008 -0700

    freezer_cg: use thaw_process() in unfreeze_cgroup()
    
    Don't duplicate the implementation of thaw_process().
    
    [akpm@linux-foundation.org: make __thaw_process() static]
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Cc: Cedric Le Goater <clg@fr.ibm.com>
    Acked-by: Matt Helsley <matthltc@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 8f225339eee9..5a361f85cfec 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -44,11 +44,6 @@ static inline bool should_send_signal(struct task_struct *p)
 	return !(p->flags & PF_FREEZER_NOSIG);
 }
 
-/*
- * Wake up a frozen process
- */
-extern int __thaw_process(struct task_struct *p);
-
 /* Takes and releases task alloc lock using task_lock() */
 extern int thaw_process(struct task_struct *p);
 

commit dc52ddc0e6f45b04780b26fc0813509f8e798c42
Author: Matt Helsley <matthltc@us.ibm.com>
Date:   Sat Oct 18 20:27:21 2008 -0700

    container freezer: implement freezer cgroup subsystem
    
    This patch implements a new freezer subsystem in the control groups
    framework.  It provides a way to stop and resume execution of all tasks in
    a cgroup by writing in the cgroup filesystem.
    
    The freezer subsystem in the container filesystem defines a file named
    freezer.state.  Writing "FROZEN" to the state file will freeze all tasks
    in the cgroup.  Subsequently writing "RUNNING" will unfreeze the tasks in
    the cgroup.  Reading will return the current state.
    
    * Examples of usage :
    
       # mkdir /containers/freezer
       # mount -t cgroup -ofreezer freezer  /containers
       # mkdir /containers/0
       # echo $some_pid > /containers/0/tasks
    
    to get status of the freezer subsystem :
    
       # cat /containers/0/freezer.state
       RUNNING
    
    to freeze all tasks in the container :
    
       # echo FROZEN > /containers/0/freezer.state
       # cat /containers/0/freezer.state
       FREEZING
       # cat /containers/0/freezer.state
       FROZEN
    
    to unfreeze all tasks in the container :
    
       # echo RUNNING > /containers/0/freezer.state
       # cat /containers/0/freezer.state
       RUNNING
    
    This is the basic mechanism which should do the right thing for user space
    task in a simple scenario.
    
    It's important to note that freezing can be incomplete.  In that case we
    return EBUSY.  This means that some tasks in the cgroup are busy doing
    something that prevents us from completely freezing the cgroup at this
    time.  After EBUSY, the cgroup will remain partially frozen -- reflected
    by freezer.state reporting "FREEZING" when read.  The state will remain
    "FREEZING" until one of these things happens:
    
            1) Userspace cancels the freezing operation by writing "RUNNING" to
                    the freezer.state file
            2) Userspace retries the freezing operation by writing "FROZEN" to
                    the freezer.state file (writing "FREEZING" is not legal
                    and returns EIO)
            3) The tasks that blocked the cgroup from entering the "FROZEN"
                    state disappear from the cgroup's set of tasks.
    
    [akpm@linux-foundation.org: coding-style fixes]
    [akpm@linux-foundation.org: export thaw_process]
    Signed-off-by: Cedric Le Goater <clg@fr.ibm.com>
    Signed-off-by: Matt Helsley <matthltc@us.ibm.com>
    Acked-by: Serge E. Hallyn <serue@us.ibm.com>
    Tested-by: Matt Helsley <matthltc@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 17e3bb42dd3c..8f225339eee9 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -46,26 +46,11 @@ static inline bool should_send_signal(struct task_struct *p)
 
 /*
  * Wake up a frozen process
- *
- * task_lock() is taken to prevent the race with refrigerator() which may
- * occur if the freezing of tasks fails.  Namely, without the lock, if the
- * freezing of tasks failed, thaw_tasks() might have run before a task in
- * refrigerator() could call frozen_process(), in which case the task would be
- * frozen and no one would thaw it.
  */
-static inline int thaw_process(struct task_struct *p)
-{
-	task_lock(p);
-	if (frozen(p)) {
-		p->flags &= ~PF_FROZEN;
-		task_unlock(p);
-		wake_up_process(p);
-		return 1;
-	}
-	clear_freeze_flag(p);
-	task_unlock(p);
-	return 0;
-}
+extern int __thaw_process(struct task_struct *p);
+
+/* Takes and releases task alloc lock using task_lock() */
+extern int thaw_process(struct task_struct *p);
 
 extern void refrigerator(void);
 extern int freeze_processes(void);
@@ -83,6 +68,12 @@ static inline int try_to_freeze(void)
 extern bool freeze_task(struct task_struct *p, bool sig_only);
 extern void cancel_freezing(struct task_struct *p);
 
+#ifdef CONFIG_CGROUP_FREEZER
+extern int cgroup_frozen(struct task_struct *task);
+#else /* !CONFIG_CGROUP_FREEZER */
+static inline int cgroup_frozen(struct task_struct *task) { return 0; }
+#endif /* !CONFIG_CGROUP_FREEZER */
+
 /*
  * The PF_FREEZER_SKIP flag should be set by a vfork parent right before it
  * calls wait_for_completion(&vfork) and reset right after it returns from this

commit 8174f1503f4bf7e9a14b3fbbfdb30c6be6e29f77
Author: Matt Helsley <matthltc@us.ibm.com>
Date:   Sat Oct 18 20:27:19 2008 -0700

    container freezer: make refrigerator always available
    
    Now that the TIF_FREEZE flag is available in all architectures, extract
    the refrigerator() and freeze_task() from kernel/power/process.c and make
    it available to all.
    
    The refrigerator() can now be used in a control group subsystem
    implementing a control group freezer.
    
    Signed-off-by: Cedric Le Goater <clg@fr.ibm.com>
    Signed-off-by: Matt Helsley <matthltc@us.ibm.com>
    Acked-by: Serge E. Hallyn <serue@us.ibm.com>
    Tested-by: Matt Helsley <matthltc@us.ibm.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index deddeedf3257..17e3bb42dd3c 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -6,7 +6,7 @@
 #include <linux/sched.h>
 #include <linux/wait.h>
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_FREEZER
 /*
  * Check if a process has been frozen
  */
@@ -39,6 +39,11 @@ static inline void clear_freeze_flag(struct task_struct *p)
 	clear_tsk_thread_flag(p, TIF_FREEZE);
 }
 
+static inline bool should_send_signal(struct task_struct *p)
+{
+	return !(p->flags & PF_FREEZER_NOSIG);
+}
+
 /*
  * Wake up a frozen process
  *
@@ -75,6 +80,9 @@ static inline int try_to_freeze(void)
 		return 0;
 }
 
+extern bool freeze_task(struct task_struct *p, bool sig_only);
+extern void cancel_freezing(struct task_struct *p);
+
 /*
  * The PF_FREEZER_SKIP flag should be set by a vfork parent right before it
  * calls wait_for_completion(&vfork) and reset right after it returns from this
@@ -166,7 +174,7 @@ static inline void set_freezable_with_signal(void)
 	} while (try_to_freeze());					\
 	__retval;							\
 })
-#else /* !CONFIG_PM_SLEEP */
+#else /* !CONFIG_FREEZER */
 static inline int frozen(struct task_struct *p) { return 0; }
 static inline int freezing(struct task_struct *p) { return 0; }
 static inline void set_freeze_flag(struct task_struct *p) {}
@@ -191,6 +199,6 @@ static inline void set_freezable_with_signal(void) {}
 #define wait_event_freezable_timeout(wq, condition, timeout)		\
 		wait_event_interruptible_timeout(wq, condition, timeout)
 
-#endif /* !CONFIG_PM_SLEEP */
+#endif /* !CONFIG_FREEZER */
 
 #endif	/* FREEZER_H_INCLUDED */

commit ebb12db51f6c13b30752fcf506baad4c617b153c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jun 11 22:04:29 2008 +0200

    Freezer: Introduce PF_FREEZER_NOSIG
    
    The freezer currently attempts to distinguish kernel threads from
    user space tasks by checking if their mm pointer is unset and it
    does not send fake signals to kernel threads.  However, there are
    kernel threads, mostly related to networking, that behave like
    user space tasks and may want to be sent a fake signal to be frozen.
    
    Introduce the new process flag PF_FREEZER_NOSIG that will be set
    by default for all kernel threads and make the freezer only send
    fake signals to the tasks having PF_FREEZER_NOSIG unset.  Provide
    the set_freezable_with_signal() function to be called by the kernel
    threads that want to be sent a fake signal for freezing.
    
    This patch should not change the freezer's observable behavior.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 08934995c7ab..deddeedf3257 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -127,6 +127,15 @@ static inline void set_freezable(void)
 	current->flags &= ~PF_NOFREEZE;
 }
 
+/*
+ * Tell the freezer that the current task should be frozen by it and that it
+ * should send a fake signal to the task to freeze it.
+ */
+static inline void set_freezable_with_signal(void)
+{
+	current->flags &= ~(PF_NOFREEZE | PF_FREEZER_NOSIG);
+}
+
 /*
  * Freezer-friendly wrappers around wait_event_interruptible() and
  * wait_event_interruptible_timeout(), originally defined in <linux/wait.h>
@@ -174,6 +183,7 @@ static inline void freezer_do_not_count(void) {}
 static inline void freezer_count(void) {}
 static inline int freezer_should_skip(struct task_struct *p) { return 0; }
 static inline void set_freezable(void) {}
+static inline void set_freezable_with_signal(void) {}
 
 #define wait_event_freezable(wq, condition)				\
 		wait_event_interruptible(wq, condition)

commit e42837bcd35b75bb59ae5d3e62f87be1aeeb05c3
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Oct 18 03:04:45 2007 -0700

    freezer: introduce freezer-friendly waiting macros
    
    Introduce freezer-friendly wrappers around wait_event_interruptible() and
    wait_event_interruptible_timeout(), originally defined in <linux/wait.h>, to
    be used in freezable kernel threads.  Make some of the freezable kernel
    threads use them.
    
    This is necessary for the freezer to stop sending signals to kernel threads,
    which is implemented in the next patch.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@nigel.suspend2.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index efded00ad08c..08934995c7ab 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -4,6 +4,7 @@
 #define FREEZER_H_INCLUDED
 
 #include <linux/sched.h>
+#include <linux/wait.h>
 
 #ifdef CONFIG_PM_SLEEP
 /*
@@ -126,6 +127,36 @@ static inline void set_freezable(void)
 	current->flags &= ~PF_NOFREEZE;
 }
 
+/*
+ * Freezer-friendly wrappers around wait_event_interruptible() and
+ * wait_event_interruptible_timeout(), originally defined in <linux/wait.h>
+ */
+
+#define wait_event_freezable(wq, condition)				\
+({									\
+	int __retval;							\
+	do {								\
+		__retval = wait_event_interruptible(wq, 		\
+				(condition) || freezing(current));	\
+		if (__retval && !freezing(current))			\
+			break;						\
+		else if (!(condition))					\
+			__retval = -ERESTARTSYS;			\
+	} while (try_to_freeze());					\
+	__retval;							\
+})
+
+
+#define wait_event_freezable_timeout(wq, condition, timeout)		\
+({									\
+	long __retval = timeout;					\
+	do {								\
+		__retval = wait_event_interruptible_timeout(wq,		\
+				(condition) || freezing(current),	\
+				__retval); 				\
+	} while (try_to_freeze());					\
+	__retval;							\
+})
 #else /* !CONFIG_PM_SLEEP */
 static inline int frozen(struct task_struct *p) { return 0; }
 static inline int freezing(struct task_struct *p) { return 0; }
@@ -143,6 +174,13 @@ static inline void freezer_do_not_count(void) {}
 static inline void freezer_count(void) {}
 static inline int freezer_should_skip(struct task_struct *p) { return 0; }
 static inline void set_freezable(void) {}
+
+#define wait_event_freezable(wq, condition)				\
+		wait_event_interruptible(wq, condition)
+
+#define wait_event_freezable_timeout(wq, condition, timeout)		\
+		wait_event_interruptible_timeout(wq, condition, timeout)
+
 #endif /* !CONFIG_PM_SLEEP */
 
 #endif	/* FREEZER_H_INCLUDED */

commit 296699de6bdc717189a331ab6bbe90e05c94db06
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jul 29 23:27:18 2007 +0200

    Introduce CONFIG_SUSPEND for suspend-to-Ram and standby
    
    Introduce CONFIG_SUSPEND representing the ability to enter system sleep
    states, such as the ACPI S3 state, and allow the user to choose SUSPEND
    and HIBERNATION independently of each other.
    
    Make HOTPLUG_CPU be selected automatically if SUSPEND or HIBERNATION has
    been chosen and the kernel is intended for SMP systems.
    
    Also, introduce CONFIG_PM_SLEEP which is automatically selected if
    CONFIG_SUSPEND or CONFIG_HIBERNATION is set and use it to select the
    code needed for both suspend and hibernation.
    
    The top-level power management headers and the ACPI code related to
    suspend and hibernation are modified to use the new definitions (the
    changes in drivers/acpi/sleep/main.c are, mostly, moving code to reduce
    the number of ifdefs).
    
    There are many other files in which CONFIG_PM can be replaced with
    CONFIG_PM_SLEEP or even with CONFIG_SUSPEND, but they can be updated in
    the future.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index c8e02de737f6..efded00ad08c 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -5,7 +5,7 @@
 
 #include <linux/sched.h>
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 /*
  * Check if a process has been frozen
  */
@@ -126,7 +126,7 @@ static inline void set_freezable(void)
 	current->flags &= ~PF_NOFREEZE;
 }
 
-#else
+#else /* !CONFIG_PM_SLEEP */
 static inline int frozen(struct task_struct *p) { return 0; }
 static inline int freezing(struct task_struct *p) { return 0; }
 static inline void set_freeze_flag(struct task_struct *p) {}
@@ -143,6 +143,6 @@ static inline void freezer_do_not_count(void) {}
 static inline void freezer_count(void) {}
 static inline int freezer_should_skip(struct task_struct *p) { return 0; }
 static inline void set_freezable(void) {}
-#endif
+#endif /* !CONFIG_PM_SLEEP */
 
 #endif	/* FREEZER_H_INCLUDED */

commit 0c1eecfb345401629aa57c9d3b077273e56c45a7
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 19 01:47:33 2007 -0700

    Freezer: avoid freezing kernel threads prematurely
    
    Kernel threads should not have TIF_FREEZE set when user space processes are
    being frozen, since otherwise some of them might be frozen prematurely.
    To prevent this from happening we can (1) make exit_mm() unset TIF_FREEZE
    unconditionally just after clearing tsk->mm and (2) make try_to_freeze_tasks()
    check if p->mm is different from zero and PF_BORROWED_MM is unset in p->flags
    when user space processes are to be frozen.
    
    Namely, when user space processes are being frozen, we only should set
    TIF_FREEZE for tasks that have p->mm different from NULL and don't have
    PF_BORROWED_MM set in p->flags.  For this reason task_lock() must be used to
    prevent try_to_freeze_tasks() from racing with use_mm()/unuse_mm(), in which
    p->mm and p->flags.PF_BORROWED_MM are changed under task_lock(p).  Also, we
    need to prevent the following scenario from happening:
    
    * daemonize() is called by a task spawned from a user space code path
    * freezer checks if the task has p->mm set and the result is positive
    * task enters exit_mm() and clears its TIF_FREEZE
    * freezer sets TIF_FREEZE for the task
    * task calls try_to_freeze() and goes to the refrigerator, which is wrong at
      that point
    
    This requires us to acquire task_lock(p) before p->flags.PF_BORROWED_MM and
    p->mm are examined and release it after TIF_FREEZE is set for p (or it turns
    out that TIF_FREEZE should not be set).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Gautham R Shenoy <ego@in.ibm.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@nigel.suspend2.net>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 2d38b1a74662..c8e02de737f6 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -25,7 +25,7 @@ static inline int freezing(struct task_struct *p)
 /*
  * Request that a process be frozen
  */
-static inline void freeze(struct task_struct *p)
+static inline void set_freeze_flag(struct task_struct *p)
 {
 	set_tsk_thread_flag(p, TIF_FREEZE);
 }
@@ -33,7 +33,7 @@ static inline void freeze(struct task_struct *p)
 /*
  * Sometimes we may need to cancel the previous 'freeze' request
  */
-static inline void do_not_freeze(struct task_struct *p)
+static inline void clear_freeze_flag(struct task_struct *p)
 {
 	clear_tsk_thread_flag(p, TIF_FREEZE);
 }
@@ -56,7 +56,7 @@ static inline int thaw_process(struct task_struct *p)
 		wake_up_process(p);
 		return 1;
 	}
-	clear_tsk_thread_flag(p, TIF_FREEZE);
+	clear_freeze_flag(p);
 	task_unlock(p);
 	return 0;
 }
@@ -129,7 +129,8 @@ static inline void set_freezable(void)
 #else
 static inline int frozen(struct task_struct *p) { return 0; }
 static inline int freezing(struct task_struct *p) { return 0; }
-static inline void freeze(struct task_struct *p) { BUG(); }
+static inline void set_freeze_flag(struct task_struct *p) {}
+static inline void clear_freeze_flag(struct task_struct *p) {}
 static inline int thaw_process(struct task_struct *p) { return 1; }
 
 static inline void refrigerator(void) {}

commit 831441862956fffa17b9801db37e6ea1650b0f69
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jul 17 04:03:35 2007 -0700

    Freezer: make kernel threads nonfreezable by default
    
    Currently, the freezer treats all tasks as freezable, except for the kernel
    threads that explicitly set the PF_NOFREEZE flag for themselves.  This
    approach is problematic, since it requires every kernel thread to either
    set PF_NOFREEZE explicitly, or call try_to_freeze(), even if it doesn't
    care for the freezing of tasks at all.
    
    It seems better to only require the kernel threads that want to or need to
    be frozen to use some freezer-related code and to remove any
    freezer-related code from the other (nonfreezable) kernel threads, which is
    done in this patch.
    
    The patch causes all kernel threads to be nonfreezable by default (ie.  to
    have PF_NOFREEZE set by default) and introduces the set_freezable()
    function that should be called by the freezable kernel threads in order to
    unset PF_NOFREEZE.  It also makes all of the currently freezable kernel
    threads call set_freezable(), so it shouldn't cause any (intentional)
    change of behaviour to appear.  Additionally, it updates documentation to
    describe the freezing of tasks more accurately.
    
    [akpm@linux-foundation.org: build fixes]
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Nigel Cunningham <nigel@nigel.suspend2.net>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: Gautham R Shenoy <ego@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 4631086f5060..2d38b1a74662 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -1,5 +1,8 @@
 /* Freezer declarations */
 
+#ifndef FREEZER_H_INCLUDED
+#define FREEZER_H_INCLUDED
+
 #include <linux/sched.h>
 
 #ifdef CONFIG_PM
@@ -115,6 +118,14 @@ static inline int freezer_should_skip(struct task_struct *p)
 	return !!(p->flags & PF_FREEZER_SKIP);
 }
 
+/*
+ * Tell the freezer that the current task should be frozen by it
+ */
+static inline void set_freezable(void)
+{
+	current->flags &= ~PF_NOFREEZE;
+}
+
 #else
 static inline int frozen(struct task_struct *p) { return 0; }
 static inline int freezing(struct task_struct *p) { return 0; }
@@ -130,4 +141,7 @@ static inline int try_to_freeze(void) { return 0; }
 static inline void freezer_do_not_count(void) {}
 static inline void freezer_count(void) {}
 static inline int freezer_should_skip(struct task_struct *p) { return 0; }
+static inline void set_freezable(void) {}
 #endif
+
+#endif	/* FREEZER_H_INCLUDED */

commit 88f18ba028b5939bb6f77bd690e5ad8d01bb24cc
Author: Gautham R Shenoy <ego@in.ibm.com>
Date:   Wed May 23 13:57:29 2007 -0700

    freezer: move frozen_process() to kernel/power/process.c
    
    Other than refrigerator, no one else calls frozen_process().  So move it from
    include/linux/freezer.h to kernel/power/process.c.
    
    Also, since a task can be marked as frozen by itself, we don't need to pass
    the (struct task_struct *p) parameter to frozen_process().
    
    Signed-off-by: Gautham R Shenoy <ego@in.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 1045ee9c0bb4..4631086f5060 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -58,18 +58,6 @@ static inline int thaw_process(struct task_struct *p)
 	return 0;
 }
 
-/*
- * freezing is complete, mark process as frozen
- */
-static inline void frozen_process(struct task_struct *p)
-{
-	if (!unlikely(p->flags & PF_NOFREEZE)) {
-		p->flags |= PF_FROZEN;
-		wmb();
-	}
-	clear_tsk_thread_flag(p, TIF_FREEZE);
-}
-
 extern void refrigerator(void);
 extern int freeze_processes(void);
 extern void thaw_processes(void);
@@ -132,7 +120,6 @@ static inline int frozen(struct task_struct *p) { return 0; }
 static inline int freezing(struct task_struct *p) { return 0; }
 static inline void freeze(struct task_struct *p) { BUG(); }
 static inline int thaw_process(struct task_struct *p) { return 1; }
-static inline void frozen_process(struct task_struct *p) { BUG(); }
 
 static inline void refrigerator(void) {}
 static inline int freeze_processes(void) { BUG(); return 0; }

commit 5fcc57f2d5d558056668159f9153bf21d2c53d16
Author: Gautham R Shenoy <ego@in.ibm.com>
Date:   Wed May 23 13:57:28 2007 -0700

    freezer: fix PF_NOFREEZE vs freezeable race
    
    This patch fixes the race pointed out by Oleg Nesterov.
    
    * Freezer marks a thread as freezeable.
    * The thread now marks itself PF_NOFREEZE, but it will be frozen on
      on calling try_to_freeze(). Thus the task is frozen, even though it doesn't
      want to.
    * Subsequent thaw_processes() will also fail to thaw the task since it is
      marked PF_NOFREEZE.
    
    Avoid this problem by checking the task's PF_NOFREEZE status in
    frozen_processes() before marking the task as frozen.
    
    Signed-off-by: Gautham R Shenoy <ego@in.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index c9435252e8e4..1045ee9c0bb4 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -63,8 +63,10 @@ static inline int thaw_process(struct task_struct *p)
  */
 static inline void frozen_process(struct task_struct *p)
 {
-	p->flags |= PF_FROZEN;
-	wmb();
+	if (!unlikely(p->flags & PF_NOFREEZE)) {
+		p->flags |= PF_FROZEN;
+		wmb();
+	}
 	clear_tsk_thread_flag(p, TIF_FREEZE);
 }
 

commit ba96a0c88098697a63e80157718b7440414ed24d
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed May 23 13:57:25 2007 -0700

    freezer: fix vfork problem
    
    Currently try_to_freeze_tasks() has to wait until all of the vforked processes
    exit and for this reason every user can make it fail.  To fix this problem we
    can introduce the additional process flag PF_FREEZER_SKIP to be used by tasks
    that do not want to be counted as freezable by the freezer and want to have
    TIF_FREEZE set nevertheless.  Then, this flag can be set by tasks using
    sys_vfork() before they call wait_for_completion(&vfork) and cleared after
    they have woken up.  After clearing it, the tasks should call try_to_freeze()
    as soon as possible.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Gautham R Shenoy <ego@in.ibm.com>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index db5423eae24d..c9435252e8e4 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -81,7 +81,49 @@ static inline int try_to_freeze(void)
 		return 0;
 }
 
-extern void thaw_some_processes(int all);
+/*
+ * The PF_FREEZER_SKIP flag should be set by a vfork parent right before it
+ * calls wait_for_completion(&vfork) and reset right after it returns from this
+ * function.  Next, the parent should call try_to_freeze() to freeze itself
+ * appropriately in case the child has exited before the freezing of tasks is
+ * complete.  However, we don't want kernel threads to be frozen in unexpected
+ * places, so we allow them to block freeze_processes() instead or to set
+ * PF_NOFREEZE if needed and PF_FREEZER_SKIP is only set for userland vfork
+ * parents.  Fortunately, in the ____call_usermodehelper() case the parent won't
+ * really block freeze_processes(), since ____call_usermodehelper() (the child)
+ * does a little before exec/exit and it can't be frozen before waking up the
+ * parent.
+ */
+
+/*
+ * If the current task is a user space one, tell the freezer not to count it as
+ * freezable.
+ */
+static inline void freezer_do_not_count(void)
+{
+	if (current->mm)
+		current->flags |= PF_FREEZER_SKIP;
+}
+
+/*
+ * If the current task is a user space one, tell the freezer to count it as
+ * freezable again and try to freeze it.
+ */
+static inline void freezer_count(void)
+{
+	if (current->mm) {
+		current->flags &= ~PF_FREEZER_SKIP;
+		try_to_freeze();
+	}
+}
+
+/*
+ * Check if the task should be counted as freezeable by the freezer
+ */
+static inline int freezer_should_skip(struct task_struct *p)
+{
+	return !!(p->flags & PF_FREEZER_SKIP);
+}
 
 #else
 static inline int frozen(struct task_struct *p) { return 0; }
@@ -96,5 +138,7 @@ static inline void thaw_processes(void) {}
 
 static inline int try_to_freeze(void) { return 0; }
 
-
+static inline void freezer_do_not_count(void) {}
+static inline void freezer_count(void) {}
+static inline int freezer_should_skip(struct task_struct *p) { return 0; }
 #endif

commit 33e1c288da62a6a5aa9077a6b7bfa690b1b02cf4
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed May 23 13:57:24 2007 -0700

    freezer: close potential race between refrigerator and thaw_tasks
    
    If the freezing of tasks fails and a task is preempted in refrigerator()
    before calling frozen_process(), then thaw_tasks() may run before this task is
    frozen.  In that case the task will freeze and no one will thaw it.
    
    To fix this race we can call freezing(current) in refrigerator() along with
    frozen_process(current) under the task_lock() which also should be taken in
    the error path of try_to_freeze_tasks() as well as in thaw_process().
    Moreover, if thaw_process() additionally clears TIF_FREEZE for tasks that are
    not frozen, we can be sure that all tasks are thawed and there are no pending
    "freeze" requests after thaw_tasks() has run.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Gautham R Shenoy <ego@in.ibm.com>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 5e75e26d4787..db5423eae24d 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -37,14 +37,24 @@ static inline void do_not_freeze(struct task_struct *p)
 
 /*
  * Wake up a frozen process
+ *
+ * task_lock() is taken to prevent the race with refrigerator() which may
+ * occur if the freezing of tasks fails.  Namely, without the lock, if the
+ * freezing of tasks failed, thaw_tasks() might have run before a task in
+ * refrigerator() could call frozen_process(), in which case the task would be
+ * frozen and no one would thaw it.
  */
 static inline int thaw_process(struct task_struct *p)
 {
+	task_lock(p);
 	if (frozen(p)) {
 		p->flags &= ~PF_FROZEN;
+		task_unlock(p);
 		wake_up_process(p);
 		return 1;
 	}
+	clear_tsk_thread_flag(p, TIF_FREEZE);
+	task_unlock(p);
 	return 0;
 }
 

commit 8a102eed9c4e1d21bad07a8fd97bd4fbf125d966
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Dec 13 00:34:30 2006 -0800

    [PATCH] PM: Fix SMP races in the freezer
    
    Currently, to tell a task that it should go to the refrigerator, we set the
    PF_FREEZE flag for it and send a fake signal to it.  Unfortunately there
    are two SMP-related problems with this approach.  First, a task running on
    another CPU may be updating its flags while the freezer attempts to set
    PF_FREEZE for it and this may leave the task's flags in an inconsistent
    state.  Second, there is a potential race between freeze_process() and
    refrigerator() in which freeze_process() running on one CPU is reading a
    task's PF_FREEZE flag while refrigerator() running on another CPU has just
    set PF_FROZEN for the same task and attempts to reset PF_FREEZE for it.  If
    the refrigerator wins the race, freeze_process() will state that PF_FREEZE
    hasn't been set for the task and will set it unnecessarily, so the task
    will go to the refrigerator once again after it's been thawed.
    
    To solve first of these problems we need to stop using PF_FREEZE to tell
    tasks that they should go to the refrigerator.  Instead, we can introduce a
    special TIF_*** flag and use it for this purpose, since it is allowed to
    change the other tasks' TIF_*** flags and there are special calls for it.
    
    To avoid the freeze_process()-refrigerator() race we can make
    freeze_process() to always check the task's PF_FROZEN flag after it's read
    its "freeze" flag.  We should also make sure that refrigerator() will
    always reset the task's "freeze" flag after it's set PF_FROZEN for it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Andi Kleen <ak@muc.de>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 393063096134..5e75e26d4787 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -16,16 +16,15 @@ static inline int frozen(struct task_struct *p)
  */
 static inline int freezing(struct task_struct *p)
 {
-	return p->flags & PF_FREEZE;
+	return test_tsk_thread_flag(p, TIF_FREEZE);
 }
 
 /*
  * Request that a process be frozen
- * FIXME: SMP problem. We may not modify other process' flags!
  */
 static inline void freeze(struct task_struct *p)
 {
-	p->flags |= PF_FREEZE;
+	set_tsk_thread_flag(p, TIF_FREEZE);
 }
 
 /*
@@ -33,7 +32,7 @@ static inline void freeze(struct task_struct *p)
  */
 static inline void do_not_freeze(struct task_struct *p)
 {
-	p->flags &= ~PF_FREEZE;
+	clear_tsk_thread_flag(p, TIF_FREEZE);
 }
 
 /*
@@ -54,7 +53,9 @@ static inline int thaw_process(struct task_struct *p)
  */
 static inline void frozen_process(struct task_struct *p)
 {
-	p->flags = (p->flags & ~PF_FREEZE) | PF_FROZEN;
+	p->flags |= PF_FROZEN;
+	wmb();
+	clear_tsk_thread_flag(p, TIF_FREEZE);
 }
 
 extern void refrigerator(void);

commit 5c543eff6cc658f46241f1ccb77436d65abbf445
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Sun Dec 10 02:18:58 2006 -0800

    [PATCH] freezer.h uses task_struct fields
    
    freezer.h uses task_struct fields so it should include sched.h.
    
      CC [M]  fs/jfs/jfs_txnmgr.o
    In file included from fs/jfs/jfs_txnmgr.c:49:
    include/linux/freezer.h: In function 'frozen':
    include/linux/freezer.h:9: error: dereferencing pointer to incomplete type
    include/linux/freezer.h:9: error: 'PF_FROZEN' undeclared (first use in this function)
    include/linux/freezer.h:9: error: (Each undeclared identifier is reported only once
    include/linux/freezer.h:9: error: for each function it appears in.)
    include/linux/freezer.h: In function 'freezing':
    include/linux/freezer.h:17: error: dereferencing pointer to incomplete type
    include/linux/freezer.h:17: error: 'PF_FREEZE' undeclared (first use in this function)
    include/linux/freezer.h: In function 'freeze':
    include/linux/freezer.h:26: error: dereferencing pointer to incomplete type
    include/linux/freezer.h:26: error: 'PF_FREEZE' undeclared (first use in this function)
    include/linux/freezer.h: In function 'do_not_freeze':
    include/linux/freezer.h:34: error: dereferencing pointer to incomplete type
    include/linux/freezer.h:34: error: 'PF_FREEZE' undeclared (first use in this function)
    include/linux/freezer.h: In function 'thaw_process':
    include/linux/freezer.h:43: error: dereferencing pointer to incomplete type
    include/linux/freezer.h:43: error: 'PF_FROZEN' undeclared (first use in this function)
    include/linux/freezer.h:44: warning: implicit declaration of function 'wake_up_process'
    include/linux/freezer.h: In function 'frozen_process':
    include/linux/freezer.h:55: error: dereferencing pointer to incomplete type
    include/linux/freezer.h:55: error: dereferencing pointer to incomplete type
    include/linux/freezer.h:55: error: 'PF_FREEZE' undeclared (first use in this function)
    include/linux/freezer.h:55: error: 'PF_FROZEN' undeclared (first use in this function)
    fs/jfs/jfs_txnmgr.c: In function 'freezing':
    include/linux/freezer.h:18: warning: control reaches end of non-void function
    make[2]: *** [fs/jfs/jfs_txnmgr.o] Error 1
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Acked-by: Dave Kleikamp <shaggy@linux.vnet.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 6e05e3e7ce39..393063096134 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -1,5 +1,7 @@
 /* Freezer declarations */
 
+#include <linux/sched.h>
+
 #ifdef CONFIG_PM
 /*
  * Check if a process has been frozen

commit a9b6f562f14dc28fb4b2415f0f275cede0abe9b5
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Dec 6 20:34:37 2006 -0800

    [PATCH] swsusp: Untangle thaw_processes
    
    Move the loop from thaw_processes() to a separate function and call it
    independently for kernel threads and user space processes so that the order
    of thawing tasks is clearly visible.
    
    Drop thaw_kernel_threads() which is never used.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@suspend2.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 294ebea859c9..6e05e3e7ce39 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -1,8 +1,5 @@
 /* Freezer declarations */
 
-#define FREEZER_KERNEL_THREADS 0
-#define FREEZER_ALL_THREADS 1
-
 #ifdef CONFIG_PM
 /*
  * Check if a process has been frozen
@@ -60,8 +57,7 @@ static inline void frozen_process(struct task_struct *p)
 
 extern void refrigerator(void);
 extern int freeze_processes(void);
-#define thaw_processes() do { thaw_some_processes(FREEZER_ALL_THREADS); } while(0)
-#define thaw_kernel_threads() do { thaw_some_processes(FREEZER_KERNEL_THREADS); } while(0)
+extern void thaw_processes(void);
 
 static inline int try_to_freeze(void)
 {

commit ff39593ad0ff7a79a3717edac6634407aa8200c2
Author: Nigel Cunningham <ncunningham@linuxmail.org>
Date:   Wed Dec 6 20:34:28 2006 -0800

    [PATCH] swsusp: thaw userspace and kernel space separately
    
    Modify process thawing so that we can thaw kernel space without thawing
    userspace, and thaw kernelspace first.  This will be useful in later
    patches, where I intend to get swsusp thawing kernel threads only before
    seeking to free memory.
    
    Signed-off-by: Nigel Cunningham <nigel@suspend2.net>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 266373f74445..294ebea859c9 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -1,5 +1,8 @@
 /* Freezer declarations */
 
+#define FREEZER_KERNEL_THREADS 0
+#define FREEZER_ALL_THREADS 1
+
 #ifdef CONFIG_PM
 /*
  * Check if a process has been frozen
@@ -57,7 +60,8 @@ static inline void frozen_process(struct task_struct *p)
 
 extern void refrigerator(void);
 extern int freeze_processes(void);
-extern void thaw_processes(void);
+#define thaw_processes() do { thaw_some_processes(FREEZER_ALL_THREADS); } while(0)
+#define thaw_kernel_threads() do { thaw_some_processes(FREEZER_KERNEL_THREADS); } while(0)
 
 static inline int try_to_freeze(void)
 {
@@ -67,6 +71,9 @@ static inline int try_to_freeze(void)
 	} else
 		return 0;
 }
+
+extern void thaw_some_processes(int all);
+
 #else
 static inline int frozen(struct task_struct *p) { return 0; }
 static inline int freezing(struct task_struct *p) { return 0; }

commit 7dfb71030f7636a0d65200158113c37764552f93
Author: Nigel Cunningham <ncunningham@linuxmail.org>
Date:   Wed Dec 6 20:34:23 2006 -0800

    [PATCH] Add include/linux/freezer.h and move definitions from sched.h
    
    Move process freezing functions from include/linux/sched.h to freezer.h, so
    that modifications to the freezer or the kernel configuration don't require
    recompiling just about everything.
    
    [akpm@osdl.org: fix ueagle driver]
    Signed-off-by: Nigel Cunningham <nigel@suspend2.net>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/freezer.h b/include/linux/freezer.h
new file mode 100644
index 000000000000..266373f74445
--- /dev/null
+++ b/include/linux/freezer.h
@@ -0,0 +1,84 @@
+/* Freezer declarations */
+
+#ifdef CONFIG_PM
+/*
+ * Check if a process has been frozen
+ */
+static inline int frozen(struct task_struct *p)
+{
+	return p->flags & PF_FROZEN;
+}
+
+/*
+ * Check if there is a request to freeze a process
+ */
+static inline int freezing(struct task_struct *p)
+{
+	return p->flags & PF_FREEZE;
+}
+
+/*
+ * Request that a process be frozen
+ * FIXME: SMP problem. We may not modify other process' flags!
+ */
+static inline void freeze(struct task_struct *p)
+{
+	p->flags |= PF_FREEZE;
+}
+
+/*
+ * Sometimes we may need to cancel the previous 'freeze' request
+ */
+static inline void do_not_freeze(struct task_struct *p)
+{
+	p->flags &= ~PF_FREEZE;
+}
+
+/*
+ * Wake up a frozen process
+ */
+static inline int thaw_process(struct task_struct *p)
+{
+	if (frozen(p)) {
+		p->flags &= ~PF_FROZEN;
+		wake_up_process(p);
+		return 1;
+	}
+	return 0;
+}
+
+/*
+ * freezing is complete, mark process as frozen
+ */
+static inline void frozen_process(struct task_struct *p)
+{
+	p->flags = (p->flags & ~PF_FREEZE) | PF_FROZEN;
+}
+
+extern void refrigerator(void);
+extern int freeze_processes(void);
+extern void thaw_processes(void);
+
+static inline int try_to_freeze(void)
+{
+	if (freezing(current)) {
+		refrigerator();
+		return 1;
+	} else
+		return 0;
+}
+#else
+static inline int frozen(struct task_struct *p) { return 0; }
+static inline int freezing(struct task_struct *p) { return 0; }
+static inline void freeze(struct task_struct *p) { BUG(); }
+static inline int thaw_process(struct task_struct *p) { return 1; }
+static inline void frozen_process(struct task_struct *p) { BUG(); }
+
+static inline void refrigerator(void) {}
+static inline int freeze_processes(void) { BUG(); return 0; }
+static inline void thaw_processes(void) {}
+
+static inline int try_to_freeze(void) { return 0; }
+
+
+#endif
