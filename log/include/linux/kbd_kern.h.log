commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kbd_kern.h b/include/linux/kbd_kern.h
index cbfb171bbcba..bb2246c8ec13 100644
--- a/include/linux/kbd_kern.h
+++ b/include/linux/kbd_kern.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _KBD_KERN_H
 #define _KBD_KERN_H
 

commit cf940ebe98e693aec2d10f9af2fb84eb55234e3c
Author: Andreas Platschek <andi.platschek@gmail.com>
Date:   Fri Jul 26 06:46:37 2013 +0200

    tty: Remove dead code
    
    -> The ledptrs[] array is never initialized.
    -> There is no place where kbd->ledmode is set to LED_SHOW_MEM therefore the if
       statement does not make much sense.
    -> Since LED_SHOW_MEM is not used, it can be removed from the header file as well.
    
    Signed-off-by: Andreas Platschek <andi.platschek@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kbd_kern.h b/include/linux/kbd_kern.h
index b7c8cdc1d422..cbfb171bbcba 100644
--- a/include/linux/kbd_kern.h
+++ b/include/linux/kbd_kern.h
@@ -36,10 +36,9 @@ struct kbd_struct {
 #define VC_CTRLRLOCK	KG_CTRLR 	/* ctrlr lock mode */
 	unsigned char slockstate; 	/* for `sticky' Shift, Ctrl, etc. */
 
-	unsigned char ledmode:2; 	/* one 2-bit value */
+	unsigned char ledmode:1;
 #define LED_SHOW_FLAGS 0        /* traditional state */
 #define LED_SHOW_IOCTL 1        /* only change leds upon ioctl */
-#define LED_SHOW_MEM 2          /* `heartbeat': peek into memory */
 
 	unsigned char ledflagstate:4;	/* flags, not lights */
 	unsigned char default_ledflagstate:4;

commit 3db1ddb725dcd9a2bb32be2b64d0688c3e1c4579
Author: Alan Cox <alan@linux.intel.com>
Date:   Tue Jul 17 17:06:41 2012 +0100

    vt: fix the keyboard/led locking
    
    We touch the LED from both keyboard callback and direct paths. In
    one case we've got the lock held way up the call chain and in the
    other we haven't. This leads to complete insanity so fix it by giving
    the LED bits their own lock.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kbd_kern.h b/include/linux/kbd_kern.h
index af9137db3035..b7c8cdc1d422 100644
--- a/include/linux/kbd_kern.h
+++ b/include/linux/kbd_kern.h
@@ -65,7 +65,6 @@ struct kbd_struct {
 
 extern int kbd_init(void);
 
-extern unsigned char getledstate(void);
 extern void setledstate(struct kbd_struct *kbd, unsigned int led);
 
 extern int do_poke_blanked_console;

commit 4c2ef53d3bfb36659c47ba589f35bcab24f425c7
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Mon Jun 4 13:35:31 2012 +0200

    TTY: vt, remove con_schedule_flip
    
    This is identical to tty_schedule_flip. So let us use that instead.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kbd_kern.h b/include/linux/kbd_kern.h
index daf4a3a40ee0..af9137db3035 100644
--- a/include/linux/kbd_kern.h
+++ b/include/linux/kbd_kern.h
@@ -145,16 +145,4 @@ void compute_shiftstate(void);
 
 extern unsigned int keymap_count;
 
-/* console.c */
-
-static inline void con_schedule_flip(struct tty_struct *t)
-{
-	unsigned long flags;
-	spin_lock_irqsave(&t->buf.lock, flags);
-	if (t->buf.tail != NULL)
-		t->buf.tail->commit = t->buf.tail->used;
-	spin_unlock_irqrestore(&t->buf.lock, flags);
-	schedule_work(&t->buf.work);
-}
-
 #endif

commit 079c9534a96da9a85a2a2f9715851050fbfbf749
Author: Alan Cox <alan@linux.intel.com>
Date:   Tue Feb 28 14:49:23 2012 +0000

    vt:tackle kbd_table
    
    Keyboard struct lifetime is easy, but the locking is not and is completely
    ignored by the existing code. Tackle this one head on
    
    - Make the kbd_table private so we can run down all direct users
    - Hoick the relevant ioctl handlers into the keyboard layer
    - Lock them with the keyboard lock so they don't change mid keypress
    - Add helpers for things like console stop/start so we isolate the poking
      around properly
    - Tweak the braille console so it still builds
    
    There are a couple of FIXME locking cases left for ioctls that are so hideous
    they should be addressed in a later patch. After this patch the kbd_table is
    private and all the keyboard jiggery pokery is in one place.
    
    This update fixes speakup and also a memory leak in the original.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kbd_kern.h b/include/linux/kbd_kern.h
index ec2d17bc1f1e..daf4a3a40ee0 100644
--- a/include/linux/kbd_kern.h
+++ b/include/linux/kbd_kern.h
@@ -7,8 +7,6 @@
 
 extern struct tasklet_struct keyboard_tasklet;
 
-extern int shift_state;
-
 extern char *func_table[MAX_NR_FUNC];
 extern char func_buf[];
 extern char *funcbufptr;
@@ -65,8 +63,6 @@ struct kbd_struct {
 #define VC_META		4	/* 0 - meta, 1 - meta=prefix with ESC */
 };
 
-extern struct kbd_struct kbd_table[];
-
 extern int kbd_init(void);
 
 extern unsigned char getledstate(void);
@@ -79,6 +75,7 @@ extern void (*kbd_ledfunc)(unsigned int led);
 extern int set_console(int nr);
 extern void schedule_console_callback(void);
 
+/* FIXME: review locking for vt.c callers */
 static inline void set_leds(void)
 {
 	tasklet_schedule(&keyboard_tasklet);
@@ -142,8 +139,6 @@ static inline void chg_vc_kbd_led(struct kbd_struct * kbd, int flag)
 
 struct console;
 
-int getkeycode(unsigned int scancode);
-int setkeycode(unsigned int scancode, unsigned int keycode);
 void compute_shiftstate(void);
 
 /* defkeymap.c */

commit f23eb2b2b28547fc70df82dd5049eb39bec5ba12
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 22 16:17:32 2011 -0700

    tty: stop using "delayed_work" in the tty layer
    
    Using delayed-work for tty flip buffers ends up causing us to wait for
    the next tick to complete some actions.  That's usually not all that
    noticeable, but for certain latency-critical workloads it ends up being
    totally unacceptable.
    
    As an extreme case of this, passing a token back-and-forth over a pty
    will take two ticks per iteration, so even just a thousand iterations
    will take 8 seconds assuming a common 250Hz configuration.
    
    Avoiding the whole delayed work issue brings that ping-pong test-case
    down to 0.009s on my machine.
    
    In more practical terms, this latency has been a performance problem for
    things like dive computer simulators (simulating the serial interface
    using the ptys) and for other environments (Alan mentions a CP/M emulator).
    
    Reported-by: Jef Driesen <jefdriesen@telenet.be>
    Acked-by: Greg KH <gregkh@suse.de>
    Acked-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/kbd_kern.h b/include/linux/kbd_kern.h
index 4b0761cc7dd9..ec2d17bc1f1e 100644
--- a/include/linux/kbd_kern.h
+++ b/include/linux/kbd_kern.h
@@ -159,7 +159,7 @@ static inline void con_schedule_flip(struct tty_struct *t)
 	if (t->buf.tail != NULL)
 		t->buf.tail->commit = t->buf.tail->used;
 	spin_unlock_irqrestore(&t->buf.lock, flags);
-	schedule_delayed_work(&t->buf.work, 0);
+	schedule_work(&t->buf.work);
 }
 
 #endif

commit 9fc3de9c83565fcaa23df74c2fc414bb6e7efb0a
Author: Arthur Taylor <art@ified.ca>
Date:   Fri Feb 4 13:55:50 2011 -0800

    vt: Add virtual console keyboard mode OFF
    
    virtual console: add keyboard mode OFF
    
    Add a new mode for the virtual console keyboard OFF in which all input
    other than shift keys is ignored. Prevents vt input buffers from
    overflowing when a program opens but doesn't read from a tty, like X11
    using evdev for input.
    
    Signed-off-by: Arthur Taylor <art@ified.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/kbd_kern.h b/include/linux/kbd_kern.h
index 506ad20c18f8..4b0761cc7dd9 100644
--- a/include/linux/kbd_kern.h
+++ b/include/linux/kbd_kern.h
@@ -50,11 +50,12 @@ struct kbd_struct {
 #define VC_CAPSLOCK	2	/* capslock mode */
 #define VC_KANALOCK	3	/* kanalock mode */
 
-	unsigned char kbdmode:2;	/* one 2-bit value */
+	unsigned char kbdmode:3;	/* one 3-bit value */
 #define VC_XLATE	0	/* translate keycodes using keymap */
 #define VC_MEDIUMRAW	1	/* medium raw (keycode) mode */
 #define VC_RAW		2	/* raw (scancode) mode */
 #define VC_UNICODE	3	/* Unicode mode */
+#define VC_OFF		4	/* disabled mode */
 
 	unsigned char modeflags:5;
 #define VC_APPLIC	0	/* application key mode */

commit 99b089c3c38a83ebaeb1cc4584ddcde841626467
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Sat Jan 30 00:53:29 2010 -0800

    Input: Mac button emulation - implement as an input filter
    
    Current implementation of Mac mouse button emulation plugs into legacy
    keyboard driver, converts certain keys into button events on a separate
    device, and suppresses the real events from reaching tty. This worked
    well enough until user space started using evdev which was completely
    unaware of this arrangement and kept sending original key presses to
    its users. Change the implementation to use newly added input filter
    framework so that original key presses are not transmitted to any
    handlers.
    
    As a bonus remove SYSCTL dependencies from the code and use Kconfig
    instead; also do not create the emulated mouse device until user
    activates emulation.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/include/linux/kbd_kern.h b/include/linux/kbd_kern.h
index 8bdb16bfe5fb..506ad20c18f8 100644
--- a/include/linux/kbd_kern.h
+++ b/include/linux/kbd_kern.h
@@ -161,7 +161,4 @@ static inline void con_schedule_flip(struct tty_struct *t)
 	schedule_delayed_work(&t->buf.work, 0);
 }
 
-/* mac_hid.c */
-extern int mac_hid_mouse_emulate_buttons(int, unsigned int, int);
-
 #endif

commit 2301060e2b19aa4830060524ef66abdf32b26a26
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Aug 22 14:01:35 2007 -0700

    m68k/mac: Make mac_hid_mouse_emulate_buttons() declaration visible
    
    m68k/mac: Make mac_hid_mouse_emulate_buttons() declaration visible
    
    drivers/char/keyboard.c: In function 'kbd_keycode':
    drivers/char/keyboard.c:1142: error: implicit declaration of function 'mac_hid_mouse_emulate_buttons'
    
    The forward declaration of mac_hid_mouse_emulate_buttons() is not visible on
    m68k because it's hidden in the middle of a big #ifdef block.
    
    Move it to <linux/kbd_kern.h>, correct the type of the second parameter, and
    include <linux/kbd_kern.h> where needed.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/kbd_kern.h b/include/linux/kbd_kern.h
index 506ad20c18f8..8bdb16bfe5fb 100644
--- a/include/linux/kbd_kern.h
+++ b/include/linux/kbd_kern.h
@@ -161,4 +161,7 @@ static inline void con_schedule_flip(struct tty_struct *t)
 	schedule_delayed_work(&t->buf.work, 0);
 }
 
+/* mac_hid.c */
+extern int mac_hid_mouse_emulate_buttons(int, unsigned int, int);
+
 #endif

commit b257bc051f06607beb3004d9a1c297085e728bec
Author: Andrew Johnson <ajohnson@intrinsyc.com>
Date:   Fri Mar 16 13:38:24 2007 -0800

    [PATCH] swsusp: fix suspend when console is in VT_AUTO+KD_GRAPHICS mode
    
    When the console is in VT_AUTO+KD_GRAPHICS mode, switching to the
    SUSPEND_CONSOLE fails, resulting in vt_waitactive() waiting indefinitely or
    until the task is interrupted.  This patch tests if a console switch can
    occur in set_console() and returns early if a console switch is not
    possible.
    
    [akpm@linux-foundation.org: cleanup]
    Signed-off-by: Andrew Johnson <ajohnson@intrinsyc.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/kbd_kern.h b/include/linux/kbd_kern.h
index 06c58c423fe1..506ad20c18f8 100644
--- a/include/linux/kbd_kern.h
+++ b/include/linux/kbd_kern.h
@@ -75,7 +75,7 @@ extern int do_poke_blanked_console;
 
 extern void (*kbd_ledfunc)(unsigned int led);
 
-extern void set_console(int nr);
+extern int set_console(int nr);
 extern void schedule_console_callback(void);
 
 static inline void set_leds(void)

commit 52bad64d95bd89e08c49ec5a071fa6dcbe5a1a9c
Author: David Howells <dhowells@redhat.com>
Date:   Wed Nov 22 14:54:01 2006 +0000

    WorkStruct: Separate delayable and non-delayable events.
    
    Separate delayable work items from non-delayable work items be splitting them
    into a separate structure (delayed_work), which incorporates a work_struct and
    the timer_list removed from work_struct.
    
    The work_struct struct is huge, and this limits it's usefulness.  On a 64-bit
    architecture it's nearly 100 bytes in size.  This reduces that by half for the
    non-delayable type of event.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/include/linux/kbd_kern.h b/include/linux/kbd_kern.h
index efe0ee4cc80b..06c58c423fe1 100644
--- a/include/linux/kbd_kern.h
+++ b/include/linux/kbd_kern.h
@@ -158,7 +158,7 @@ static inline void con_schedule_flip(struct tty_struct *t)
 	if (t->buf.tail != NULL)
 		t->buf.tail->commit = t->buf.tail->used;
 	spin_unlock_irqrestore(&t->buf.lock, flags);
-	schedule_work(&t->buf.work);
+	schedule_delayed_work(&t->buf.work, 0);
 }
 
 #endif

commit 33b37a33c242542fac2980b8ccd90977388b7a8d
Author: Paul Fulghum <paulkf@microgate.com>
Date:   Wed Jun 28 04:26:49 2006 -0700

    [PATCH] remove active field from tty buffer structure
    
    Remove 'active' field from tty buffer structure.  This was added in 2.6.16
    as part of a patch to make the new tty buffering SMP safe.  This field is
    unnecessary with the more intelligently written flush_to_ldisc that adds
    receive_room handling.
    
    Removing this field reverts to simpler logic where the tail buffer is
    always the 'active' buffer, which should not be freed by flush_to_ldisc.
    (active == buffer being filled with new data)
    
    The result is simpler, smaller, and faster tty buffer code.
    
    Signed-off-by: Paul Fulghum <paulkf@microgate.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/kbd_kern.h b/include/linux/kbd_kern.h
index 4eb851ece080..efe0ee4cc80b 100644
--- a/include/linux/kbd_kern.h
+++ b/include/linux/kbd_kern.h
@@ -155,10 +155,8 @@ static inline void con_schedule_flip(struct tty_struct *t)
 {
 	unsigned long flags;
 	spin_lock_irqsave(&t->buf.lock, flags);
-	if (t->buf.tail != NULL) {
-		t->buf.tail->active = 0;
+	if (t->buf.tail != NULL)
 		t->buf.tail->commit = t->buf.tail->used;
-	}
 	spin_unlock_irqrestore(&t->buf.lock, flags);
 	schedule_work(&t->buf.work);
 }

commit b9ec4e109d7a342e83e1210e05797222e36555c3
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Sun Apr 2 00:10:28 2006 -0500

    Input: add support for Braille devices
    
    - Add KEY_BRL_* input keys and K_BRL_* keycodes;
    - Add emulation of how braille keyboards usually combine braille dots
      to the console keyboard driver;
    - Add handling of unicode U+28xy diacritics.
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/include/linux/kbd_kern.h b/include/linux/kbd_kern.h
index e87c32a5c86a..4eb851ece080 100644
--- a/include/linux/kbd_kern.h
+++ b/include/linux/kbd_kern.h
@@ -135,6 +135,8 @@ static inline void chg_vc_kbd_led(struct kbd_struct * kbd, int flag)
 
 #define U(x) ((x) ^ 0xf000)
 
+#define BRL_UC_ROW 0x2800
+
 /* keyboard.c */
 
 struct console;

commit 8977d929e49021d9a6e031310aab01fa72f849c2
Author: Paul Fulghum <paulkf@microgate.com>
Date:   Fri Feb 10 01:51:14 2006 -0800

    [PATCH] tty buffering stall fix
    
    Prevent stalled processing of received data when a driver allocates tty
    buffer space but does not immediately follow the allocation with more data
    and a call to schedule receive tty processing.  (example: hvc_console) This
    bug was introduced by the first locking patch for the new tty buffering.
    
    Signed-off-by: Paul Fulghum <paulkf@microgate.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/kbd_kern.h b/include/linux/kbd_kern.h
index 3aed37314ab8..e87c32a5c86a 100644
--- a/include/linux/kbd_kern.h
+++ b/include/linux/kbd_kern.h
@@ -153,8 +153,10 @@ static inline void con_schedule_flip(struct tty_struct *t)
 {
 	unsigned long flags;
 	spin_lock_irqsave(&t->buf.lock, flags);
-	if (t->buf.tail != NULL)
+	if (t->buf.tail != NULL) {
 		t->buf.tail->active = 0;
+		t->buf.tail->commit = t->buf.tail->used;
+	}
 	spin_unlock_irqrestore(&t->buf.lock, flags);
 	schedule_work(&t->buf.work);
 }

commit 808249ceba49cdb3054c0aa5b75a61862d6cab94
Author: Paul Fulghum <paulkf@microgate.com>
Date:   Fri Feb 3 03:04:41 2006 -0800

    [PATCH] new tty buffering locking fix
    
    Change locking in the new tty buffering facility from using tty->read_lock,
    which is currently ignored by drivers and thus ineffective.  New locking
    uses a new tty buffering specific lock enforced centrally in the tty
    buffering code.
    
    Two drivers (esp and cyclades) are updated to use the tty buffering
    functions instead of accessing tty buffering internals directly.  This is
    required for the new locking to work.
    
    Minor checks for NULL buffers added to
    tty_prepare_flip_string/tty_prepare_flip_string_flags
    
    Signed-off-by: Paul Fulghum <paulkf@microgate.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/kbd_kern.h b/include/linux/kbd_kern.h
index 45f625d7d0b2..3aed37314ab8 100644
--- a/include/linux/kbd_kern.h
+++ b/include/linux/kbd_kern.h
@@ -151,6 +151,11 @@ extern unsigned int keymap_count;
 
 static inline void con_schedule_flip(struct tty_struct *t)
 {
+	unsigned long flags;
+	spin_lock_irqsave(&t->buf.lock, flags);
+	if (t->buf.tail != NULL)
+		t->buf.tail->active = 0;
+	spin_unlock_irqrestore(&t->buf.lock, flags);
 	schedule_work(&t->buf.work);
 }
 

commit 33f0f88f1c51ae5c2d593d26960c760ea154c2e2
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Jan 9 20:54:13 2006 -0800

    [PATCH] TTY layer buffering revamp
    
    The API and code have been through various bits of initial review by
    serial driver people but they definitely need to live somewhere for a
    while so the unconverted drivers can get knocked into shape, existing
    drivers that have been updated can be better tuned and bugs whacked out.
    
    This replaces the tty flip buffers with kmalloc objects in rings. In the
    normal situation for an IRQ driven serial port at typical speeds the
    behaviour is pretty much the same, two buffers end up allocated and the
    kernel cycles between them as before.
    
    When there are delays or at high speed we now behave far better as the
    buffer pool can grow a bit rather than lose characters. This also means
    that we can operate at higher speeds reliably.
    
    For drivers that receive characters in blocks (DMA based, USB and
    especially virtualisation) the layer allows a lot of driver specific
    code that works around the tty layer with private secondary queues to be
    removed. The IBM folks need this sort of layer, the smart serial port
    people do, the virtualisers do (because a virtualised tty typically
    operates at infinite speed rather than emulating 9600 baud).
    
    Finally many drivers had invalid and unsafe attempts to avoid buffer
    overflows by directly invoking tty methods extracted out of the innards
    of work queue structs. These are no longer needed and all go away. That
    fixes various random hangs with serial ports on overflow.
    
    The other change in here is to optimise the receive_room path that is
    used by some callers. It turns out that only one ldisc uses receive room
    except asa constant and it updates it far far less than the value is
    read. We thus make it a variable not a function call.
    
    I expect the code to contain bugs due to the size alone but I'll be
    watching and squashing them and feeding out new patches as it goes.
    
    Because the buffers now dynamically expand you should only run out of
    buffering when the kernel runs out of memory for real.  That means a lot of
    the horrible hacks high performance drivers used to do just aren't needed any
    more.
    
    Description:
    
    tty_insert_flip_char is an old API and continues to work as before, as does
    tty_flip_buffer_push() [this is why many drivers dont need modification].  It
    does now also return the number of chars inserted
    
    There are also
    
    tty_buffer_request_room(tty, len)
    
    which asks for a buffer block of the length requested and returns the space
    found.  This improves efficiency with hardware that knows how much to
    transfer.
    
    and tty_insert_flip_string_flags(tty, str, flags, len)
    
    to insert a string of characters and flags
    
    For a smart interface the usual code is
    
        len = tty_request_buffer_room(tty, amount_hardware_says);
        tty_insert_flip_string(tty, buffer_from_card, len);
    
    More description!
    
    At the moment tty buffers are attached directly to the tty.  This is causing a
    lot of the problems related to tty layer locking, also problems at high speed
    and also with bursty data (such as occurs in virtualised environments)
    
    I'm working on ripping out the flip buffers and replacing them with a pool of
    dynamically allocated buffers.  This allows both for old style "byte I/O"
    devices and also helps virtualisation and smart devices where large blocks of
    data suddenely materialise and need storing.
    
    So far so good.  Lots of drivers reference tty->flip.*.  Several of them also
    call directly and unsafely into function pointers it provides.  This will all
    break.  Most drivers can use tty_insert_flip_char which can be kept as an API
    but others need more.
    
    At the moment I've added the following interfaces, if people think more will
    be needed now is a good time to say
    
     int tty_buffer_request_room(tty, size)
    
    Try and ensure at least size bytes are available, returns actual room (may be
    zero).  At the moment it just uses the flipbuf space but that will change.
    Repeated calls without characters being added are not cumulative.  (ie if you
    call it with 1, 1, 1, and then 4 you'll have four characters of space.  The
    other functions will also try and grow buffers in future but this will be a
    more efficient way when you know block sizes.
    
     int tty_insert_flip_char(tty, ch, flag)
    
    As before insert a character if there is room.  Now returns 1 for success, 0
    for failure.
    
     int tty_insert_flip_string(tty, str, len)
    
    Insert a block of non error characters.  Returns the number inserted.
    
     int tty_prepare_flip_string(tty, strptr, len)
    
    Adjust the buffer to allow len characters to be added.  Returns a buffer
    pointer in strptr and the length available.  This allows for hardware that
    needs to use functions like insl or mencpy_fromio.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Cc: Paul Fulghum <paulkf@microgate.com>
    Signed-off-by: Hirokazu Takata <takata@linux-m32r.org>
    Signed-off-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: John Hawkes <hawkes@sgi.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/kbd_kern.h b/include/linux/kbd_kern.h
index 7428198111eb..45f625d7d0b2 100644
--- a/include/linux/kbd_kern.h
+++ b/include/linux/kbd_kern.h
@@ -151,7 +151,7 @@ extern unsigned int keymap_count;
 
 static inline void con_schedule_flip(struct tty_struct *t)
 {
-	schedule_work(&t->flip.work);
+	schedule_work(&t->buf.work);
 }
 
 #endif

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/kbd_kern.h b/include/linux/kbd_kern.h
new file mode 100644
index 000000000000..7428198111eb
--- /dev/null
+++ b/include/linux/kbd_kern.h
@@ -0,0 +1,157 @@
+#ifndef _KBD_KERN_H
+#define _KBD_KERN_H
+
+#include <linux/tty.h>
+#include <linux/interrupt.h>
+#include <linux/keyboard.h>
+
+extern struct tasklet_struct keyboard_tasklet;
+
+extern int shift_state;
+
+extern char *func_table[MAX_NR_FUNC];
+extern char func_buf[];
+extern char *funcbufptr;
+extern int funcbufsize, funcbufleft;
+
+/*
+ * kbd->xxx contains the VC-local things (flag settings etc..)
+ *
+ * Note: externally visible are LED_SCR, LED_NUM, LED_CAP defined in kd.h
+ *       The code in KDGETLED / KDSETLED depends on the internal and
+ *       external order being the same.
+ *
+ * Note: lockstate is used as index in the array key_map.
+ */
+struct kbd_struct {
+
+	unsigned char lockstate;
+/* 8 modifiers - the names do not have any meaning at all;
+   they can be associated to arbitrarily chosen keys */
+#define VC_SHIFTLOCK	KG_SHIFT	/* shift lock mode */
+#define VC_ALTGRLOCK	KG_ALTGR	/* altgr lock mode */
+#define VC_CTRLLOCK	KG_CTRL 	/* control lock mode */
+#define VC_ALTLOCK	KG_ALT  	/* alt lock mode */
+#define VC_SHIFTLLOCK	KG_SHIFTL	/* shiftl lock mode */
+#define VC_SHIFTRLOCK	KG_SHIFTR	/* shiftr lock mode */
+#define VC_CTRLLLOCK	KG_CTRLL 	/* ctrll lock mode */
+#define VC_CTRLRLOCK	KG_CTRLR 	/* ctrlr lock mode */
+	unsigned char slockstate; 	/* for `sticky' Shift, Ctrl, etc. */
+
+	unsigned char ledmode:2; 	/* one 2-bit value */
+#define LED_SHOW_FLAGS 0        /* traditional state */
+#define LED_SHOW_IOCTL 1        /* only change leds upon ioctl */
+#define LED_SHOW_MEM 2          /* `heartbeat': peek into memory */
+
+	unsigned char ledflagstate:4;	/* flags, not lights */
+	unsigned char default_ledflagstate:4;
+#define VC_SCROLLOCK	0	/* scroll-lock mode */
+#define VC_NUMLOCK	1	/* numeric lock mode */
+#define VC_CAPSLOCK	2	/* capslock mode */
+#define VC_KANALOCK	3	/* kanalock mode */
+
+	unsigned char kbdmode:2;	/* one 2-bit value */
+#define VC_XLATE	0	/* translate keycodes using keymap */
+#define VC_MEDIUMRAW	1	/* medium raw (keycode) mode */
+#define VC_RAW		2	/* raw (scancode) mode */
+#define VC_UNICODE	3	/* Unicode mode */
+
+	unsigned char modeflags:5;
+#define VC_APPLIC	0	/* application key mode */
+#define VC_CKMODE	1	/* cursor key mode */
+#define VC_REPEAT	2	/* keyboard repeat */
+#define VC_CRLF		3	/* 0 - enter sends CR, 1 - enter sends CRLF */
+#define VC_META		4	/* 0 - meta, 1 - meta=prefix with ESC */
+};
+
+extern struct kbd_struct kbd_table[];
+
+extern int kbd_init(void);
+
+extern unsigned char getledstate(void);
+extern void setledstate(struct kbd_struct *kbd, unsigned int led);
+
+extern int do_poke_blanked_console;
+
+extern void (*kbd_ledfunc)(unsigned int led);
+
+extern void set_console(int nr);
+extern void schedule_console_callback(void);
+
+static inline void set_leds(void)
+{
+	tasklet_schedule(&keyboard_tasklet);
+}
+
+static inline int vc_kbd_mode(struct kbd_struct * kbd, int flag)
+{
+	return ((kbd->modeflags >> flag) & 1);
+}
+
+static inline int vc_kbd_led(struct kbd_struct * kbd, int flag)
+{
+	return ((kbd->ledflagstate >> flag) & 1);
+}
+
+static inline void set_vc_kbd_mode(struct kbd_struct * kbd, int flag)
+{
+	kbd->modeflags |= 1 << flag;
+}
+
+static inline void set_vc_kbd_led(struct kbd_struct * kbd, int flag)
+{
+	kbd->ledflagstate |= 1 << flag;
+}
+
+static inline void clr_vc_kbd_mode(struct kbd_struct * kbd, int flag)
+{
+	kbd->modeflags &= ~(1 << flag);
+}
+
+static inline void clr_vc_kbd_led(struct kbd_struct * kbd, int flag)
+{
+	kbd->ledflagstate &= ~(1 << flag);
+}
+
+static inline void chg_vc_kbd_lock(struct kbd_struct * kbd, int flag)
+{
+	kbd->lockstate ^= 1 << flag;
+}
+
+static inline void chg_vc_kbd_slock(struct kbd_struct * kbd, int flag)
+{
+	kbd->slockstate ^= 1 << flag;
+}
+
+static inline void chg_vc_kbd_mode(struct kbd_struct * kbd, int flag)
+{
+	kbd->modeflags ^= 1 << flag;
+}
+
+static inline void chg_vc_kbd_led(struct kbd_struct * kbd, int flag)
+{
+	kbd->ledflagstate ^= 1 << flag;
+}
+
+#define U(x) ((x) ^ 0xf000)
+
+/* keyboard.c */
+
+struct console;
+
+int getkeycode(unsigned int scancode);
+int setkeycode(unsigned int scancode, unsigned int keycode);
+void compute_shiftstate(void);
+
+/* defkeymap.c */
+
+extern unsigned int keymap_count;
+
+/* console.c */
+
+static inline void con_schedule_flip(struct tty_struct *t)
+{
+	schedule_work(&t->flip.work);
+}
+
+#endif
