commit d3c07e5b9939a055fa017f200e535ae947eb22ab
Author: Yuval Mintz <yuvalm@mellanox.com>
Date:   Mon Mar 26 15:01:35 2018 +0300

    ip6mr: Add API for default_rule fib
    
    Add the ability to discern whether a given FIB rule notification relates
    to the default rule inserted when registering ip6mr or a different one.
    
    Would later be used by drivers wishing to offload ipv6 multicast routes
    but unable to offload rules other than the default one.
    
    Signed-off-by: Yuval Mintz <yuvalm@mellanox.com>
    Signed-off-by: Ido Schimmel <idosch@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index 1ac38e6819f5..c4a45859f586 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -8,6 +8,7 @@
 #include <net/net_namespace.h>
 #include <uapi/linux/mroute6.h>
 #include <linux/mroute_base.h>
+#include <net/fib_rules.h>
 
 #ifdef CONFIG_IPV6_MROUTE
 static inline int ip6_mroute_opt(int opt)
@@ -63,6 +64,15 @@ static inline void ip6_mr_cleanup(void)
 }
 #endif
 
+#ifdef CONFIG_IPV6_MROUTE_MULTIPLE_TABLES
+bool ip6mr_rule_default(const struct fib_rule *rule);
+#else
+static inline bool ip6mr_rule_default(const struct fib_rule *rule)
+{
+	return true;
+}
+#endif
+
 #define VIFF_STATIC 0x8000
 
 struct mfc6_cache_cmp_arg {

commit 889cd83cbe411dda854429f3223ab2d31a860a4a
Author: Yuval Mintz <yuvalm@mellanox.com>
Date:   Wed Feb 28 23:29:38 2018 +0200

    ip6mr: Remove MFC_NOTIFY and refactor flags
    
    MFC_NOTIFY exists in ip6mr, probably as some legacy code
    [was already removed for ipmr in commit
    06bd6c0370bb ("net: ipmr: remove unused MFC_NOTIFY flag and make the flags enum").
    Remove it from ip6mr as well, and move the enum into a common file;
    Notice MFC_OFFLOAD is currently only used by ipmr.
    
    Signed-off-by: Yuval Mintz <yuvalm@mellanox.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index 6acf576fc135..1ac38e6819f5 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -81,9 +81,6 @@ struct mfc6_cache {
 	};
 };
 
-#define MFC_STATIC		1
-#define MFC_NOTIFY		2
-
 #define MFC_ASSERT_THRESH (3*HZ)		/* Maximal freq. of asserts */
 
 struct rtmsg;

commit 494fff56379c4ad5b8fe36a5b7ffede4044ca7bb
Author: Yuval Mintz <yuvalm@mellanox.com>
Date:   Wed Feb 28 23:29:34 2018 +0200

    ipmr, ip6mr: Make mfc_cache a common structure
    
    mfc_cache and mfc6_cache are almost identical - the main difference is
    in the origin/group addresses and comparison-key. Make a common
    structure encapsulating most of the multicast routing logic  - mr_mfc
    and convert both ipmr and ip6mr into using it.
    
    For easy conversion [casting, in this case] mr_mfc has to be the first
    field inside every multicast routing abstraction utilizing it.
    
    Signed-off-by: Yuval Mintz <yuvalm@mellanox.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index d5c8dc155a42..6acf576fc135 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -71,7 +71,7 @@ struct mfc6_cache_cmp_arg {
 };
 
 struct mfc6_cache {
-	struct rhlist_head mnode;
+	struct mr_mfc _c;
 	union {
 		struct {
 			struct in6_addr mf6c_mcastgrp;
@@ -79,27 +79,6 @@ struct mfc6_cache {
 		};
 		struct mfc6_cache_cmp_arg cmparg;
 	};
-	mifi_t mf6c_parent;			/* Source interface		*/
-	int mfc_flags;				/* Flags on line		*/
-
-	union {
-		struct {
-			unsigned long expires;
-			struct sk_buff_head unresolved;	/* Unresolved buffers		*/
-		} unres;
-		struct {
-			unsigned long last_assert;
-			int minvif;
-			int maxvif;
-			unsigned long bytes;
-			unsigned long pkt;
-			unsigned long wrong_if;
-			unsigned long lastuse;
-			unsigned char ttls[MAXMIFS];	/* TTL thresholds		*/
-		} res;
-	} mfc_un;
-	struct list_head list;
-	struct rcu_head rcu;
 };
 
 #define MFC_STATIC		1

commit b70432f7319eb75b24ca57dde8146c5e27244780
Author: Yuval Mintz <yuvalm@mellanox.com>
Date:   Wed Feb 28 23:29:32 2018 +0200

    mroute*: Make mr_table a common struct
    
    Following previous changes to ip6mr, mr_table and mr6_table are
    basically the same [up to mr6_table having additional '6' suffixes to
    its variable names].
    Move the common structure definition into a common header; This
    requires renaming all references in ip6mr to variables that had the
    distinct suffix.
    
    Signed-off-by: Yuval Mintz <yuvalm@mellanox.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index e2dac199861e..d5c8dc155a42 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -8,7 +8,6 @@
 #include <net/net_namespace.h>
 #include <uapi/linux/mroute6.h>
 #include <linux/mroute_base.h>
-#include <linux/rhashtable.h>
 
 #ifdef CONFIG_IPV6_MROUTE
 static inline int ip6_mroute_opt(int opt)

commit 87c418bf1323d57140f4b448715f64de3fbb7e91
Author: Yuval Mintz <yuvalm@mellanox.com>
Date:   Wed Feb 28 23:29:31 2018 +0200

    ip6mr: Align hash implementation to ipmr
    
    Since commit 8fb472c09b9d ("ipmr: improve hash scalability") ipmr has
    been using rhashtable as a basis for its mfc routes, but ip6mr is
    currently still using the old private MFC hash implementation.
    
    Align ip6mr to the current ipmr implementation.
    
    Signed-off-by: Yuval Mintz <yuvalm@mellanox.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index e1b9fb06e1ea..e2dac199861e 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -8,6 +8,7 @@
 #include <net/net_namespace.h>
 #include <uapi/linux/mroute6.h>
 #include <linux/mroute_base.h>
+#include <linux/rhashtable.h>
 
 #ifdef CONFIG_IPV6_MROUTE
 static inline int ip6_mroute_opt(int opt)
@@ -65,10 +66,20 @@ static inline void ip6_mr_cleanup(void)
 
 #define VIFF_STATIC 0x8000
 
+struct mfc6_cache_cmp_arg {
+	struct in6_addr mf6c_mcastgrp;
+	struct in6_addr mf6c_origin;
+};
+
 struct mfc6_cache {
-	struct list_head list;
-	struct in6_addr mf6c_mcastgrp;			/* Group the entry belongs to 	*/
-	struct in6_addr mf6c_origin;			/* Source of packet 		*/
+	struct rhlist_head mnode;
+	union {
+		struct {
+			struct in6_addr mf6c_mcastgrp;
+			struct in6_addr mf6c_origin;
+		};
+		struct mfc6_cache_cmp_arg cmparg;
+	};
 	mifi_t mf6c_parent;			/* Source interface		*/
 	int mfc_flags;				/* Flags on line		*/
 
@@ -88,22 +99,13 @@ struct mfc6_cache {
 			unsigned char ttls[MAXMIFS];	/* TTL thresholds		*/
 		} res;
 	} mfc_un;
+	struct list_head list;
+	struct rcu_head rcu;
 };
 
 #define MFC_STATIC		1
 #define MFC_NOTIFY		2
 
-#define MFC6_LINES		64
-
-#define MFC6_HASH(a, g) (((__force u32)(a)->s6_addr32[0] ^ \
-			  (__force u32)(a)->s6_addr32[1] ^ \
-			  (__force u32)(a)->s6_addr32[2] ^ \
-			  (__force u32)(a)->s6_addr32[3] ^ \
-			  (__force u32)(g)->s6_addr32[0] ^ \
-			  (__force u32)(g)->s6_addr32[1] ^ \
-			  (__force u32)(g)->s6_addr32[2] ^ \
-			  (__force u32)(g)->s6_addr32[3]) % MFC6_LINES)
-
 #define MFC_ASSERT_THRESH (3*HZ)		/* Maximal freq. of asserts */
 
 struct rtmsg;

commit 8571ab479a6e1ef46ead5ebee567e128a422767c
Author: Yuval Mintz <yuvalm@mellanox.com>
Date:   Wed Feb 28 23:29:30 2018 +0200

    ip6mr: Make mroute_sk rcu-based
    
    In ipmr the mr_table socket is handled under RCU. Introduce the same
    for ip6mr.
    
    Signed-off-by: Yuval Mintz <yuvalm@mellanox.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index e5e5b8282551..e1b9fb06e1ea 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -111,12 +111,12 @@ extern int ip6mr_get_route(struct net *net, struct sk_buff *skb,
 			   struct rtmsg *rtm, u32 portid);
 
 #ifdef CONFIG_IPV6_MROUTE
-extern struct sock *mroute6_socket(struct net *net, struct sk_buff *skb);
+bool mroute6_is_socket(struct net *net, struct sk_buff *skb);
 extern int ip6mr_sk_done(struct sock *sk);
 #else
-static inline struct sock *mroute6_socket(struct net *net, struct sk_buff *skb)
+static inline bool mroute6_is_socket(struct net *net, struct sk_buff *skb)
 {
-	return NULL;
+	return false;
 }
 static inline int ip6mr_sk_done(struct sock *sk)
 {

commit 6853f21f764b04e58df5e44629fec1fb8f3cbf2e
Author: Yuval Mintz <yuvalm@mellanox.com>
Date:   Wed Feb 28 23:29:29 2018 +0200

    ipmr,ipmr6: Define a uniform vif_device
    
    The two implementations have almost identical structures - vif_device and
    mif_device. As a step toward uniforming the mr_tables, eliminate the
    mif_device and relocate the vif_device definition into a new common
    header file.
    
    Also, introduce a common initializing function for setting most of the
    vif_device fields in a new common source file. This requires modifying
    the ipv{4,6] Kconfig and ipv4 makefile as we're introducing a new common
    config option - CONFIG_IP_MROUTE_COMMON.
    
    Signed-off-by: Yuval Mintz <yuvalm@mellanox.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index 3014c52bfd86..e5e5b8282551 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -7,6 +7,7 @@
 #include <linux/skbuff.h>	/* for struct sk_buff_head */
 #include <net/net_namespace.h>
 #include <uapi/linux/mroute6.h>
+#include <linux/mroute_base.h>
 
 #ifdef CONFIG_IPV6_MROUTE
 static inline int ip6_mroute_opt(int opt)
@@ -62,16 +63,6 @@ static inline void ip6_mr_cleanup(void)
 }
 #endif
 
-struct mif_device {
-	struct net_device 	*dev;			/* Device we are using */
-	unsigned long	bytes_in,bytes_out;
-	unsigned long	pkt_in,pkt_out;		/* Statistics 			*/
-	unsigned long	rate_limit;		/* Traffic shaping (NI) 	*/
-	unsigned char	threshold;		/* TTL threshold 		*/
-	unsigned short	flags;			/* Control flags 		*/
-	int		link;			/* Physical interface index	*/
-};
-
 #define VIFF_STATIC 0x8000
 
 struct mfc6_cache {

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index ce44e3e96d27..3014c52bfd86 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __LINUX_MROUTE6_H
 #define __LINUX_MROUTE6_H
 

commit fd61c6ba313de6758aeeab58fe03bd9fbbc8cea9
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Tue Jan 17 15:51:07 2017 -0800

    net: ipv6: remove nowait arg to rt6_fill_node
    
    All callers of rt6_fill_node pass 0 for nowait arg. Remove the arg and
    simplify rt6_fill_node accordingly.
    
    rt6_fill_node passes the nowait of 0 to ip6mr_get_route. Remove the
    nowait arg from it as well.
    
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index 19a1c0c2993b..ce44e3e96d27 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -116,7 +116,7 @@ struct mfc6_cache {
 
 struct rtmsg;
 extern int ip6mr_get_route(struct net *net, struct sk_buff *skb,
-			   struct rtmsg *rtm, int nowait, u32 portid);
+			   struct rtmsg *rtm, u32 portid);
 
 #ifdef CONFIG_IPV6_MROUTE
 extern struct sock *mroute6_socket(struct net *net, struct sk_buff *skb);

commit 2cf750704bb6d7ed8c7d732e071dd1bc890ea5e8
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Sun Sep 25 23:08:31 2016 +0200

    ipmr, ip6mr: fix scheduling while atomic and a deadlock with ipmr_get_route
    
    Since the commit below the ipmr/ip6mr rtnl_unicast() code uses the portid
    instead of the previous dst_pid which was copied from in_skb's portid.
    Since the skb is new the portid is 0 at that point so the packets are sent
    to the kernel and we get scheduling while atomic or a deadlock (depending
    on where it happens) by trying to acquire rtnl two times.
    Also since this is RTM_GETROUTE, it can be triggered by a normal user.
    
    Here's the sleeping while atomic trace:
    [ 7858.212557] BUG: sleeping function called from invalid context at kernel/locking/mutex.c:620
    [ 7858.212748] in_atomic(): 1, irqs_disabled(): 0, pid: 0, name: swapper/0
    [ 7858.212881] 2 locks held by swapper/0/0:
    [ 7858.213013]  #0:  (((&mrt->ipmr_expire_timer))){+.-...}, at: [<ffffffff810fbbf5>] call_timer_fn+0x5/0x350
    [ 7858.213422]  #1:  (mfc_unres_lock){+.....}, at: [<ffffffff8161e005>] ipmr_expire_process+0x25/0x130
    [ 7858.213807] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.8.0-rc7+ #179
    [ 7858.213934] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.7.5-20140531_083030-gandalf 04/01/2014
    [ 7858.214108]  0000000000000000 ffff88005b403c50 ffffffff813a7804 0000000000000000
    [ 7858.214412]  ffffffff81a1338e ffff88005b403c78 ffffffff810a4a72 ffffffff81a1338e
    [ 7858.214716]  000000000000026c 0000000000000000 ffff88005b403ca8 ffffffff810a4b9f
    [ 7858.215251] Call Trace:
    [ 7858.215412]  <IRQ>  [<ffffffff813a7804>] dump_stack+0x85/0xc1
    [ 7858.215662]  [<ffffffff810a4a72>] ___might_sleep+0x192/0x250
    [ 7858.215868]  [<ffffffff810a4b9f>] __might_sleep+0x6f/0x100
    [ 7858.216072]  [<ffffffff8165bea3>] mutex_lock_nested+0x33/0x4d0
    [ 7858.216279]  [<ffffffff815a7a5f>] ? netlink_lookup+0x25f/0x460
    [ 7858.216487]  [<ffffffff8157474b>] rtnetlink_rcv+0x1b/0x40
    [ 7858.216687]  [<ffffffff815a9a0c>] netlink_unicast+0x19c/0x260
    [ 7858.216900]  [<ffffffff81573c70>] rtnl_unicast+0x20/0x30
    [ 7858.217128]  [<ffffffff8161cd39>] ipmr_destroy_unres+0xa9/0xf0
    [ 7858.217351]  [<ffffffff8161e06f>] ipmr_expire_process+0x8f/0x130
    [ 7858.217581]  [<ffffffff8161dfe0>] ? ipmr_net_init+0x180/0x180
    [ 7858.217785]  [<ffffffff8161dfe0>] ? ipmr_net_init+0x180/0x180
    [ 7858.217990]  [<ffffffff810fbc95>] call_timer_fn+0xa5/0x350
    [ 7858.218192]  [<ffffffff810fbbf5>] ? call_timer_fn+0x5/0x350
    [ 7858.218415]  [<ffffffff8161dfe0>] ? ipmr_net_init+0x180/0x180
    [ 7858.218656]  [<ffffffff810fde10>] run_timer_softirq+0x260/0x640
    [ 7858.218865]  [<ffffffff8166379b>] ? __do_softirq+0xbb/0x54f
    [ 7858.219068]  [<ffffffff816637c8>] __do_softirq+0xe8/0x54f
    [ 7858.219269]  [<ffffffff8107a948>] irq_exit+0xb8/0xc0
    [ 7858.219463]  [<ffffffff81663452>] smp_apic_timer_interrupt+0x42/0x50
    [ 7858.219678]  [<ffffffff816625bc>] apic_timer_interrupt+0x8c/0xa0
    [ 7858.219897]  <EOI>  [<ffffffff81055f16>] ? native_safe_halt+0x6/0x10
    [ 7858.220165]  [<ffffffff810d64dd>] ? trace_hardirqs_on+0xd/0x10
    [ 7858.220373]  [<ffffffff810298e3>] default_idle+0x23/0x190
    [ 7858.220574]  [<ffffffff8102a20f>] arch_cpu_idle+0xf/0x20
    [ 7858.220790]  [<ffffffff810c9f8c>] default_idle_call+0x4c/0x60
    [ 7858.221016]  [<ffffffff810ca33b>] cpu_startup_entry+0x39b/0x4d0
    [ 7858.221257]  [<ffffffff8164f995>] rest_init+0x135/0x140
    [ 7858.221469]  [<ffffffff81f83014>] start_kernel+0x50e/0x51b
    [ 7858.221670]  [<ffffffff81f82120>] ? early_idt_handler_array+0x120/0x120
    [ 7858.221894]  [<ffffffff81f8243f>] x86_64_start_reservations+0x2a/0x2c
    [ 7858.222113]  [<ffffffff81f8257c>] x86_64_start_kernel+0x13b/0x14a
    
    Fixes: 2942e9005056 ("[RTNETLINK]: Use rtnl_unicast() for rtnetlink unicasts")
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index 3987b64040c5..19a1c0c2993b 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -116,7 +116,7 @@ struct mfc6_cache {
 
 struct rtmsg;
 extern int ip6mr_get_route(struct net *net, struct sk_buff *skb,
-			   struct rtmsg *rtm, int nowait);
+			   struct rtmsg *rtm, int nowait, u32 portid);
 
 #ifdef CONFIG_IPV6_MROUTE
 extern struct sock *mroute6_socket(struct net *net, struct sk_buff *skb);

commit 43b9e127406079d187794a5140a2411fbc6df2df
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Thu Jul 14 19:28:27 2016 +0300

    net: ipmr/ip6mr: add support for keeping an entry age
    
    In preparation for hardware offloading of ipmr/ip6mr we need an
    interface that allows to check (and later update) the age of entries.
    Relying on stats alone can show activity but not actual age of the entry,
    furthermore when there're tens of thousands of entries a lot of the
    hardware implementations only support "hit" bits which are cleared on
    read to denote that the entry was active and shouldn't be aged out,
    these can then be naturally translated into age timestamp and will be
    compatible with the software forwarding age. Using a lastuse entry doesn't
    affect performance because the members in that cache line are written to
    along with the age.
    Since all new users are encouraged to use ipmr via netlink, this is
    exported via the RTA_EXPIRES attribute.
    Also do a minor local variable declaration style adjustment - arrange them
    longest to shortest.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    CC: Roopa Prabhu <roopa@cumulusnetworks.com>
    CC: Shrijeet Mukherjee <shm@cumulusnetworks.com>
    CC: Satish Ashok <sashok@cumulusnetworks.com>
    CC: Donald Sharp <sharpd@cumulusnetworks.com>
    CC: David S. Miller <davem@davemloft.net>
    CC: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
    CC: James Morris <jmorris@namei.org>
    CC: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>
    CC: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index 66982e764051..3987b64040c5 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -92,6 +92,7 @@ struct mfc6_cache {
 			unsigned long bytes;
 			unsigned long pkt;
 			unsigned long wrong_if;
+			unsigned long lastuse;
 			unsigned char ttls[MAXMIFS];	/* TTL thresholds		*/
 		} res;
 	} mfc_un;

commit bbb923a4c2d17ebd5ec34755fe19a33914cbd86f
Author: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Date:   Mon Jan 21 06:00:25 2013 +0000

    mcast: define and use MRT[6]_MAX in ip[6]_mroute_opt()
    
    This will ease further addition of new MRT[6]_* values and avoid to update
    in6.h each time.
    Note that we reduce the maximum value from 210 to 209, but 210 does not match
    any known value in ip[6]_mroute_setsockopt().
    
    Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Acked-by: David L Stevens <dlstevens@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index a223561ba12e..66982e764051 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -10,7 +10,7 @@
 #ifdef CONFIG_IPV6_MROUTE
 static inline int ip6_mroute_opt(int opt)
 {
-	return (opt >= MRT6_BASE) && (opt <= MRT6_BASE + 10);
+	return (opt >= MRT6_BASE) && (opt <= MRT6_MAX);
 }
 #else
 static inline int ip6_mroute_opt(int opt)

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index 6d8c7251eb8d..a223561ba12e 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -1,123 +1,11 @@
 #ifndef __LINUX_MROUTE6_H
 #define __LINUX_MROUTE6_H
 
-#include <linux/types.h>
-#include <linux/sockios.h>
-
-/*
- *	Based on the MROUTING 3.5 defines primarily to keep
- *	source compatibility with BSD.
- *
- *	See the pim6sd code for the original history.
- *
- *      Protocol Independent Multicast (PIM) data structures included
- *      Carlos Picoto (cap@di.fc.ul.pt)
- *
- */
-
-#define MRT6_BASE	200
-#define MRT6_INIT	(MRT6_BASE)	/* Activate the kernel mroute code 	*/
-#define MRT6_DONE	(MRT6_BASE+1)	/* Shutdown the kernel mroute		*/
-#define MRT6_ADD_MIF	(MRT6_BASE+2)	/* Add a virtual interface		*/
-#define MRT6_DEL_MIF	(MRT6_BASE+3)	/* Delete a virtual interface		*/
-#define MRT6_ADD_MFC	(MRT6_BASE+4)	/* Add a multicast forwarding entry	*/
-#define MRT6_DEL_MFC	(MRT6_BASE+5)	/* Delete a multicast forwarding entry	*/
-#define MRT6_VERSION	(MRT6_BASE+6)	/* Get the kernel multicast version	*/
-#define MRT6_ASSERT	(MRT6_BASE+7)	/* Activate PIM assert mode		*/
-#define MRT6_PIM	(MRT6_BASE+8)	/* enable PIM code			*/
-#define MRT6_TABLE	(MRT6_BASE+9)	/* Specify mroute table ID		*/
-
-#define SIOCGETMIFCNT_IN6	SIOCPROTOPRIVATE	/* IP protocol privates */
-#define SIOCGETSGCNT_IN6	(SIOCPROTOPRIVATE+1)
-#define SIOCGETRPF	(SIOCPROTOPRIVATE+2)
-
-#define MAXMIFS		32
-typedef unsigned long mifbitmap_t;	/* User mode code depends on this lot */
-typedef unsigned short mifi_t;
-#define ALL_MIFS	((mifi_t)(-1))
-
-#ifndef IF_SETSIZE
-#define IF_SETSIZE	256
-#endif
-
-typedef	__u32		if_mask;
-#define NIFBITS (sizeof(if_mask) * 8)        /* bits per mask */
-
-#if !defined(__KERNEL__)
-#if !defined(DIV_ROUND_UP)
-#define	DIV_ROUND_UP(x,y)	(((x) + ((y) - 1)) / (y))
-#endif
-#endif
-
-typedef struct if_set {
-	if_mask ifs_bits[DIV_ROUND_UP(IF_SETSIZE, NIFBITS)];
-} if_set;
-
-#define IF_SET(n, p)    ((p)->ifs_bits[(n)/NIFBITS] |= (1 << ((n) % NIFBITS)))
-#define IF_CLR(n, p)    ((p)->ifs_bits[(n)/NIFBITS] &= ~(1 << ((n) % NIFBITS)))
-#define IF_ISSET(n, p)  ((p)->ifs_bits[(n)/NIFBITS] & (1 << ((n) % NIFBITS)))
-#define IF_COPY(f, t)   bcopy(f, t, sizeof(*(f)))
-#define IF_ZERO(p)      bzero(p, sizeof(*(p)))
-
-/*
- *	Passed by mrouted for an MRT_ADD_MIF - again we use the
- *	mrouted 3.6 structures for compatibility
- */
-
-struct mif6ctl {
-	mifi_t	mif6c_mifi;		/* Index of MIF */
-	unsigned char mif6c_flags;	/* MIFF_ flags */
-	unsigned char vifc_threshold;	/* ttl limit */
-	__u16	 mif6c_pifi;		/* the index of the physical IF */
-	unsigned int vifc_rate_limit;	/* Rate limiter values (NI) */
-};
-
-#define MIFF_REGISTER	0x1	/* register vif	*/
-
-/*
- *	Cache manipulation structures for mrouted and PIMd
- */
-
-struct mf6cctl {
-	struct sockaddr_in6 mf6cc_origin;		/* Origin of mcast	*/
-	struct sockaddr_in6 mf6cc_mcastgrp;		/* Group in question	*/
-	mifi_t	mf6cc_parent;			/* Where it arrived	*/
-	struct if_set mf6cc_ifset;		/* Where it is going */
-};
-
-/*
- *	Group count retrieval for pim6sd
- */
-
-struct sioc_sg_req6 {
-	struct sockaddr_in6 src;
-	struct sockaddr_in6 grp;
-	unsigned long pktcnt;
-	unsigned long bytecnt;
-	unsigned long wrong_if;
-};
-
-/*
- *	To get vif packet counts
- */
-
-struct sioc_mif_req6 {
-	mifi_t	mifi;		/* Which iface */
-	unsigned long icount;	/* In packets */
-	unsigned long ocount;	/* Out packets */
-	unsigned long ibytes;	/* In bytes */
-	unsigned long obytes;	/* Out bytes */
-};
-
-/*
- *	That's all usermode folks
- */
-
-#ifdef __KERNEL__
 
 #include <linux/pim.h>
 #include <linux/skbuff.h>	/* for struct sk_buff_head */
 #include <net/net_namespace.h>
+#include <uapi/linux/mroute6.h>
 
 #ifdef CONFIG_IPV6_MROUTE
 static inline int ip6_mroute_opt(int opt)
@@ -225,9 +113,6 @@ struct mfc6_cache {
 
 #define MFC_ASSERT_THRESH (3*HZ)		/* Maximal freq. of asserts */
 
-#endif
-
-#ifdef __KERNEL__
 struct rtmsg;
 extern int ip6mr_get_route(struct net *net, struct sk_buff *skb,
 			   struct rtmsg *rtm, int nowait);
@@ -246,24 +131,3 @@ static inline int ip6mr_sk_done(struct sock *sk)
 }
 #endif
 #endif
-
-/*
- * Structure used to communicate from kernel to multicast router.
- * We'll overlay the structure onto an MLD header (not an IPv6 heder like igmpmsg{}
- * used for IPv4 implementation). This is because this structure will be passed via an
- * IPv6 raw socket, on which an application will only receiver the payload i.e the data after
- * the IPv6 header and all the extension headers. (See section 3 of RFC 3542)
- */
-
-struct mrt6msg {
-#define MRT6MSG_NOCACHE		1
-#define MRT6MSG_WRONGMIF	2
-#define MRT6MSG_WHOLEPKT	3		/* used for use level encap */
-	__u8		im6_mbz;		/* must be zero		   */
-	__u8		im6_msgtype;		/* what type of message    */
-	__u16		im6_mif;		/* mif rec'd on		   */
-	__u32		im6_pad;		/* padding for 64 bit arch */
-	struct in6_addr	im6_src, im6_dst;
-};
-
-#endif

commit 1632b9e2a14ce9f4e08faf6c4380431d63319bd3
Author: David Howells <dhowells@redhat.com>
Date:   Tue Dec 13 15:07:49 2011 +0000

    UAPI: Split trivial #if defined(__KERNEL__) && X conditionals
    
    Split trivial #if defined(__KERNEL__) && X conditionals to make automated
    disintegration easier.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index a3759cb0ac10..6d8c7251eb8d 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -43,9 +43,11 @@ typedef unsigned short mifi_t;
 typedef	__u32		if_mask;
 #define NIFBITS (sizeof(if_mask) * 8)        /* bits per mask */
 
-#if !defined(__KERNEL__) && !defined(DIV_ROUND_UP)
+#if !defined(__KERNEL__)
+#if !defined(DIV_ROUND_UP)
 #define	DIV_ROUND_UP(x,y)	(((x) + ((y) - 1)) / (y))
 #endif
+#endif
 
 typedef struct if_set {
 	if_mask ifs_bits[DIV_ROUND_UP(IF_SETSIZE, NIFBITS)];

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index 9d2deb200f54..a3759cb0ac10 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -249,7 +249,7 @@ static inline int ip6mr_sk_done(struct sock *sk)
  * Structure used to communicate from kernel to multicast router.
  * We'll overlay the structure onto an MLD header (not an IPv6 heder like igmpmsg{}
  * used for IPv4 implementation). This is because this structure will be passed via an
- * IPv6 raw socket, on wich an application will only receiver the payload i.e the data after
+ * IPv6 raw socket, on which an application will only receiver the payload i.e the data after
  * the IPv6 header and all the extension headers. (See section 3 of RFC 3542)
  */
 

commit e2d57766e6744f2956975dd2086d82957187b0f6
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Feb 3 17:59:32 2011 -0800

    net: Provide compat support for SIOCGETMIFCNT_IN6 and SIOCGETSGCNT_IN6.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index 6091ab77f388..9d2deb200f54 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -136,6 +136,7 @@ extern int ip6_mroute_setsockopt(struct sock *, int, char __user *, unsigned int
 extern int ip6_mroute_getsockopt(struct sock *, int, char __user *, int __user *);
 extern int ip6_mr_input(struct sk_buff *skb);
 extern int ip6mr_ioctl(struct sock *sk, int cmd, void __user *arg);
+extern int ip6mr_compat_ioctl(struct sock *sk, unsigned int cmd, void __user *arg);
 extern int ip6_mr_init(void);
 extern void ip6_mr_cleanup(void);
 #else

commit d1db275dd3f6e4182c4c4b4a1ac6287925d60569
Author: Patrick McHardy <kaber@trash.net>
Date:   Tue May 11 14:40:55 2010 +0200

    ipv6: ip6mr: support multiple tables
    
    This patch adds support for multiple independant multicast routing instances,
    named "tables".
    
    Userspace multicast routing daemons can bind to a specific table instance by
    issuing a setsockopt call using a new option MRT6_TABLE. The table number is
    stored in the raw socket data and affects all following ip6mr setsockopt(),
    getsockopt() and ioctl() calls. By default, a single table (RT6_TABLE_DFLT)
    is created with a default routing rule pointing to it. Newly created pim6reg
    devices have the table number appended ("pim6regX"), with the exception of
    devices created in the default table, which are named just "pim6reg" for
    compatibility reasons.
    
    Packets are directed to a specific table instance using routing rules,
    similar to how regular routing rules work. Currently iif, oif and mark
    are supported as keys, source and destination addresses could be supported
    additionally.
    
    Example usage:
    
    - bind pimd/xorp/... to a specific table:
    
    uint32_t table = 123;
    setsockopt(fd, SOL_IPV6, MRT6_TABLE, &table, sizeof(table));
    
    - create routing rules directing packets to the new table:
    
    # ip -6 mrule add iif eth0 lookup 123
    # ip -6 mrule add oif eth0 lookup 123
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index 0370dd4f2389..6091ab77f388 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -24,7 +24,8 @@
 #define MRT6_DEL_MFC	(MRT6_BASE+5)	/* Delete a multicast forwarding entry	*/
 #define MRT6_VERSION	(MRT6_BASE+6)	/* Get the kernel multicast version	*/
 #define MRT6_ASSERT	(MRT6_BASE+7)	/* Activate PIM assert mode		*/
-#define MRT6_PIM	(MRT6_BASE+8)	/* enable PIM code	*/
+#define MRT6_PIM	(MRT6_BASE+8)	/* enable PIM code			*/
+#define MRT6_TABLE	(MRT6_BASE+9)	/* Specify mroute table ID		*/
 
 #define SIOCGETMIFCNT_IN6	SIOCPROTOPRIVATE	/* IP protocol privates */
 #define SIOCGETSGCNT_IN6	(SIOCPROTOPRIVATE+1)
@@ -229,11 +230,17 @@ extern int ip6mr_get_route(struct net *net, struct sk_buff *skb,
 			   struct rtmsg *rtm, int nowait);
 
 #ifdef CONFIG_IPV6_MROUTE
-extern struct sock *mroute6_socket(struct net *net);
+extern struct sock *mroute6_socket(struct net *net, struct sk_buff *skb);
 extern int ip6mr_sk_done(struct sock *sk);
 #else
-static inline struct sock *mroute6_socket(struct net *net) { return NULL; }
-static inline int ip6mr_sk_done(struct sock *sk) { return 0; }
+static inline struct sock *mroute6_socket(struct net *net, struct sk_buff *skb)
+{
+	return NULL;
+}
+static inline int ip6mr_sk_done(struct sock *sk)
+{
+	return 0;
+}
 #endif
 #endif
 

commit 6bd521433942d85e80f7a731a88cc91a327f38e0
Author: Patrick McHardy <kaber@trash.net>
Date:   Tue May 11 14:40:53 2010 +0200

    ipv6: ip6mr: move mroute data into seperate structure
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index 94a0cb521ca9..0370dd4f2389 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -229,10 +229,7 @@ extern int ip6mr_get_route(struct net *net, struct sk_buff *skb,
 			   struct rtmsg *rtm, int nowait);
 
 #ifdef CONFIG_IPV6_MROUTE
-static inline struct sock *mroute6_socket(struct net *net)
-{
-	return net->ipv6.mroute6_sk;
-}
+extern struct sock *mroute6_socket(struct net *net);
 extern int ip6mr_sk_done(struct sock *sk);
 #else
 static inline struct sock *mroute6_socket(struct net *net) { return NULL; }

commit f30a77842129b5656360cc1f5db48a3fcfb64528
Author: Patrick McHardy <kaber@trash.net>
Date:   Tue May 11 14:40:51 2010 +0200

    ipv6: ip6mr: convert struct mfc_cache to struct list_head
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index 04e2e54d0404..94a0cb521ca9 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -182,7 +182,7 @@ struct mif_device {
 #define VIFF_STATIC 0x8000
 
 struct mfc6_cache {
-	struct mfc6_cache *next;		/* Next entry on cache line 	*/
+	struct list_head list;
 	struct in6_addr mf6c_mcastgrp;			/* Group the entry belongs to 	*/
 	struct in6_addr mf6c_origin;			/* Source of packet 		*/
 	mifi_t mf6c_parent;			/* Source interface		*/

commit b5aa30b19121de49021fba57aa1f6e4c787fcf67
Author: Patrick McHardy <kaber@trash.net>
Date:   Tue May 11 14:40:50 2010 +0200

    ipv6: ip6mr: remove net pointer from struct mfc6_cache
    
    Now that cache entries in unres_queue don't need to be distinguished by their
    network namespace pointer anymore, we can remove it from struct mfc6_cache
    add pass the namespace as function argument to the functions that need it.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index 2caa1a8e525d..04e2e54d0404 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -183,9 +183,6 @@ struct mif_device {
 
 struct mfc6_cache {
 	struct mfc6_cache *next;		/* Next entry on cache line 	*/
-#ifdef CONFIG_NET_NS
-	struct net *mfc6_net;
-#endif
 	struct in6_addr mf6c_mcastgrp;			/* Group the entry belongs to 	*/
 	struct in6_addr mf6c_origin;			/* Source of packet 		*/
 	mifi_t mf6c_parent;			/* Source interface		*/
@@ -208,18 +205,6 @@ struct mfc6_cache {
 	} mfc_un;
 };
 
-static inline
-struct net *mfc6_net(const struct mfc6_cache *mfc)
-{
-	return read_pnet(&mfc->mfc6_net);
-}
-
-static inline
-void mfc6_net_set(struct mfc6_cache *mfc, struct net *net)
-{
-	write_pnet(&mfc->mfc6_net, hold_net(net));
-}
-
 #define MFC_STATIC		1
 #define MFC_NOTIFY		2
 

commit d94d9fee9fa4e66a0b91640a694b8b10177075b3
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Wed Nov 4 09:50:58 2009 -0800

    net: cleanup include/linux
    
    This cleanup patch puts struct/union/enum opening braces,
    in first line to ease grep games.
    
    struct something
    {
    
    becomes :
    
    struct something {
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index b191865a6ca3..2caa1a8e525d 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -75,8 +75,7 @@ struct mif6ctl {
  *	Cache manipulation structures for mrouted and PIMd
  */
 
-struct mf6cctl
-{
+struct mf6cctl {
 	struct sockaddr_in6 mf6cc_origin;		/* Origin of mcast	*/
 	struct sockaddr_in6 mf6cc_mcastgrp;		/* Group in question	*/
 	mifi_t	mf6cc_parent;			/* Where it arrived	*/
@@ -87,8 +86,7 @@ struct mf6cctl
  *	Group count retrieval for pim6sd
  */
 
-struct sioc_sg_req6
-{
+struct sioc_sg_req6 {
 	struct sockaddr_in6 src;
 	struct sockaddr_in6 grp;
 	unsigned long pktcnt;
@@ -100,8 +98,7 @@ struct sioc_sg_req6
  *	To get vif packet counts
  */
 
-struct sioc_mif_req6
-{
+struct sioc_mif_req6 {
 	mifi_t	mifi;		/* Which iface */
 	unsigned long icount;	/* In packets */
 	unsigned long ocount;	/* Out packets */
@@ -172,8 +169,7 @@ static inline void ip6_mr_cleanup(void)
 }
 #endif
 
-struct mif_device
-{
+struct mif_device {
 	struct net_device 	*dev;			/* Device we are using */
 	unsigned long	bytes_in,bytes_out;
 	unsigned long	pkt_in,pkt_out;		/* Statistics 			*/
@@ -185,8 +181,7 @@ struct mif_device
 
 #define VIFF_STATIC 0x8000
 
-struct mfc6_cache
-{
+struct mfc6_cache {
 	struct mfc6_cache *next;		/* Next entry on cache line 	*/
 #ifdef CONFIG_NET_NS
 	struct net *mfc6_net;

commit b7058842c940ad2c08dd829b21e5c92ebe3b8758
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Sep 30 16:12:20 2009 -0700

    net: Make setsockopt() optlen be unsigned.
    
    This provides safety against negative optlen at the type
    level instead of depending upon (sometimes non-trivial)
    checks against this sprinkled all over the the place, in
    each and every implementation.
    
    Based upon work done by Arjan van de Ven and feedback
    from Linus Torvalds.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index 43dc97e32183..b191865a6ca3 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -134,7 +134,7 @@ static inline int ip6_mroute_opt(int opt)
 struct sock;
 
 #ifdef CONFIG_IPV6_MROUTE
-extern int ip6_mroute_setsockopt(struct sock *, int, char __user *, int);
+extern int ip6_mroute_setsockopt(struct sock *, int, char __user *, unsigned int);
 extern int ip6_mroute_getsockopt(struct sock *, int, char __user *, int __user *);
 extern int ip6_mr_input(struct sk_buff *skb);
 extern int ip6mr_ioctl(struct sock *sk, int cmd, void __user *arg);
@@ -143,7 +143,7 @@ extern void ip6_mr_cleanup(void);
 #else
 static inline
 int ip6_mroute_setsockopt(struct sock *sock,
-			  int optname, char __user *optval, int optlen)
+			  int optname, char __user *optval, unsigned int optlen)
 {
 	return -ENOPROTOOPT;
 }

commit 85efde6f4e0de9577256c5f0030088d3fd4347c1
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Feb 26 00:51:39 2009 +0100

    make exported headers use strict posix types
    
    A number of standard posix types are used in exported headers, which
    is not allowed if __STRICT_KERNEL_NAMES is defined. In order to
    get rid of the non-__STRICT_KERNEL_NAMES part and to make sane headers
    the default, we have to change them all to safe types.
    
    There are also still some leftovers in reiserfs_fs.h, elfcore.h
    and coda.h, but these files have not compiled in user space for
    a long time.
    
    This leaves out the various integer types ({u_,u,}int{8,16,32,64}_t),
    which we take care of separately.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Cc: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Cc: netdev@vger.kernel.org
    Cc: linux-ppp@vger.kernel.org
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index 5375faca1f72..43dc97e32183 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -65,7 +65,7 @@ struct mif6ctl {
 	mifi_t	mif6c_mifi;		/* Index of MIF */
 	unsigned char mif6c_flags;	/* MIFF_ flags */
 	unsigned char vifc_threshold;	/* ttl limit */
-	u_short	 mif6c_pifi;		/* the index of the physical IF */
+	__u16	 mif6c_pifi;		/* the index of the physical IF */
 	unsigned int vifc_rate_limit;	/* Rate limiter values (NI) */
 };
 

commit 8229efdaef1e7913ae1712c0ba752f267e5fcd5e
Author: Benjamin Thery <benjamin.thery@bull.net>
Date:   Wed Dec 10 16:30:15 2008 -0800

    netns: ip6mr: enable namespace support in ipv6 multicast forwarding code
    
    This last patch makes the appropriate changes to use and propagate the
    network namespace where needed in IPv6 multicast forwarding code.
    
    This consists mainly in replacing all the remaining init_net occurences
    with current netns pointer retrieved from sockets, net devices or
    mfc6_caches depending on the routines' contexts.
    
    Some routines receive a new 'struct net' parameter to propagate the current
    netns:
    * ip6mr_get_route
    * ip6mr_cache_report
    * ip6mr_cache_find
    * ip6mr_cache_unresolved
    * mif6_add/mif6_delete
    * ip6mr_mfc_add/ip6mr_mfc_delete
    * ip6mr_reg_vif
    
    All the IPv6 multicast forwarding variables moved to struct netns_ipv6 by
    the previous patches are now referenced in the correct namespace.
    
    Changelog:
    ==========
    * Take into account the net associated to mfc6_cache when matching entries in
      mfc_unres_queue list.
    * Call mroute_clean_tables() in ip6mr_net_exit() to free memory allocated
      per-namespace.
    * Call dev_net_set() in ip6mr_reg_vif() to initialize dev->nd_net
      correctly.
    
    Signed-off-by: Benjamin Thery <benjamin.thery@bull.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index 15d85fe12bbd..5375faca1f72 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -245,7 +245,8 @@ void mfc6_net_set(struct mfc6_cache *mfc, struct net *net)
 
 #ifdef __KERNEL__
 struct rtmsg;
-extern int ip6mr_get_route(struct sk_buff *skb, struct rtmsg *rtm, int nowait);
+extern int ip6mr_get_route(struct net *net, struct sk_buff *skb,
+			   struct rtmsg *rtm, int nowait);
 
 #ifdef CONFIG_IPV6_MROUTE
 static inline struct sock *mroute6_socket(struct net *net)

commit 58701ad41105638baa0b38ffe9ac5b10469c1fd3
Author: Benjamin Thery <benjamin.thery@bull.net>
Date:   Wed Dec 10 16:22:34 2008 -0800

    netns: ip6mr: store netns in struct mfc6_cache
    
    This patch stores into struct mfc6_cache the network namespace each
    mfc6_cache belongs to. The new member is mfc6_net.
    
    mfc6_net is assigned at cache allocation and doesn't change during
    the rest of the cache entry life.
    
    This will help to retrieve the current netns around the IPv6 multicast
    forwarding code.
    
    At the moment, all mfc6_cache are allocated in init_net.
    
    Changelog:
    ==========
    * Use write_pnet()/read_pnet() to set and get mfc6_net.
    
    Signed-off-by: Benjamin Thery <benjamin.thery@bull.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index 2cd9901ee5c7..15d85fe12bbd 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -188,6 +188,9 @@ struct mif_device
 struct mfc6_cache
 {
 	struct mfc6_cache *next;		/* Next entry on cache line 	*/
+#ifdef CONFIG_NET_NS
+	struct net *mfc6_net;
+#endif
 	struct in6_addr mf6c_mcastgrp;			/* Group the entry belongs to 	*/
 	struct in6_addr mf6c_origin;			/* Source of packet 		*/
 	mifi_t mf6c_parent;			/* Source interface		*/
@@ -210,6 +213,18 @@ struct mfc6_cache
 	} mfc_un;
 };
 
+static inline
+struct net *mfc6_net(const struct mfc6_cache *mfc)
+{
+	return read_pnet(&mfc->mfc6_net);
+}
+
+static inline
+void mfc6_net_set(struct mfc6_cache *mfc, struct net *net)
+{
+	write_pnet(&mfc->mfc6_net, hold_net(net));
+}
+
 #define MFC_STATIC		1
 #define MFC_NOTIFY		2
 

commit bd91b8bf372911c1e4d66d6bb44fe409349a6791
Author: Benjamin Thery <benjamin.thery@bull.net>
Date:   Wed Dec 10 16:07:08 2008 -0800

    netns: ip6mr: allocate mroute6_socket per-namespace.
    
    Preliminary work to make IPv6 multicast forwarding netns-aware.
    
    Make IPv6 multicast forwarding mroute6_socket per-namespace,
    moves it into struct netns_ipv6.
    
    At the moment, mroute6_socket is only referenced in init_net.
    
    Signed-off-by: Benjamin Thery <benjamin.thery@bull.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index 6f4c180179e2..2cd9901ee5c7 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -117,6 +117,7 @@ struct sioc_mif_req6
 
 #include <linux/pim.h>
 #include <linux/skbuff.h>	/* for struct sk_buff_head */
+#include <net/net_namespace.h>
 
 #ifdef CONFIG_IPV6_MROUTE
 static inline int ip6_mroute_opt(int opt)
@@ -232,10 +233,13 @@ struct rtmsg;
 extern int ip6mr_get_route(struct sk_buff *skb, struct rtmsg *rtm, int nowait);
 
 #ifdef CONFIG_IPV6_MROUTE
-extern struct sock *mroute6_socket;
+static inline struct sock *mroute6_socket(struct net *net)
+{
+	return net->ipv6.mroute6_sk;
+}
 extern int ip6mr_sk_done(struct sock *sk);
 #else
-#define mroute6_socket NULL
+static inline struct sock *mroute6_socket(struct net *net) { return NULL; }
 static inline int ip6mr_sk_done(struct sock *sk) { return 0; }
 #endif
 #endif

commit 7c19a3d280297d43ef5ff7c6b205dc208a16d3d1
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Aug 29 14:37:23 2008 -0700

    net: Unbreak userspace usage of linux/mroute.h
    
    Nothing in linux/pim.h should be exported to userspace.
    
    This should fix the XORP build failure reported by
    Jose Calhariz, the debain package maintainer.
    
    Nothing originally in linux/mroute.h was exported to userspace
    ever, but some of this stuff started to be when it was moved into
    this new linux/pim.h, and that was wrong.  If we didn't provide these
    definitions for 10 years we can reasonably expect that applications
    defined this stuff locally or used GLIBC headers providing the
    protocol definitions.  And as such the only result of this can
    be conflict and userland build breakage.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index 5cf50473a10f..6f4c180179e2 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -115,6 +115,7 @@ struct sioc_mif_req6
 
 #ifdef __KERNEL__
 
+#include <linux/pim.h>
 #include <linux/skbuff.h>	/* for struct sk_buff_head */
 
 #ifdef CONFIG_IPV6_MROUTE

commit e0835f8fa56d2d308486f8a34cf1c4480cd27f4e
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Thu Jul 3 16:51:22 2008 +0900

    ipv4,ipv6 mroute: Add some helper inline functions to remove ugly ifdefs.
    
    ip{,v6}_mroute_{set,get}sockopt() should not matter by optimization but
    it would be better not to depend on optimization semantically.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index 4c4d6f57d5c5..5cf50473a10f 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -131,12 +131,44 @@ static inline int ip6_mroute_opt(int opt)
 
 struct sock;
 
+#ifdef CONFIG_IPV6_MROUTE
 extern int ip6_mroute_setsockopt(struct sock *, int, char __user *, int);
 extern int ip6_mroute_getsockopt(struct sock *, int, char __user *, int __user *);
 extern int ip6_mr_input(struct sk_buff *skb);
 extern int ip6mr_ioctl(struct sock *sk, int cmd, void __user *arg);
 extern int ip6_mr_init(void);
 extern void ip6_mr_cleanup(void);
+#else
+static inline
+int ip6_mroute_setsockopt(struct sock *sock,
+			  int optname, char __user *optval, int optlen)
+{
+	return -ENOPROTOOPT;
+}
+
+static inline
+int ip6_mroute_getsockopt(struct sock *sock,
+			  int optname, char __user *optval, int __user *optlen)
+{
+	return -ENOPROTOOPT;
+}
+
+static inline
+int ip6mr_ioctl(struct sock *sk, int cmd, void __user *arg)
+{
+	return -ENOIOCTLCMD;
+}
+
+static inline int ip6_mr_init(void)
+{
+	return 0;
+}
+
+static inline void ip6_mr_cleanup(void)
+{
+	return;
+}
+#endif
 
 struct mif_device
 {

commit 623d1a1af77bd52a389c6eda5920e28eb2ee468b
Author: Wang Chen <wangchen@cn.fujitsu.com>
Date:   Thu Jul 3 12:13:30 2008 +0800

    ipv6: Do cleanup for ip6_mr_init.
    
    If do not do it, we will get following issues:
    1. Leaving junks after inet6_init failing halfway.
    2. Leaving proc and notifier junks after ipv6 modules unloading.
    
    Signed-off-by: Wang Chen <wangchen@cn.fujitsu.com>
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index e7989593142b..4c4d6f57d5c5 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -135,7 +135,8 @@ extern int ip6_mroute_setsockopt(struct sock *, int, char __user *, int);
 extern int ip6_mroute_getsockopt(struct sock *, int, char __user *, int __user *);
 extern int ip6_mr_input(struct sk_buff *skb);
 extern int ip6mr_ioctl(struct sock *sk, int cmd, void __user *arg);
-extern void ip6_mr_init(void);
+extern int ip6_mr_init(void);
+extern void ip6_mr_cleanup(void);
 
 struct mif_device
 {

commit cee8947338d46bccece54c752bf6cd4043035f05
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Sun Apr 13 23:21:16 2008 -0700

    [IPV6] MROUTE: Do not call ipv6_find_idev() directly.
    
    Since NETDEV_REGISTER notifier chain is responsible for creating
    inet6_dev{}, we do not need to call ipv6_find_idev() directly here.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index f6469fb90840..e7989593142b 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -117,9 +117,6 @@ struct sioc_mif_req6
 
 #include <linux/skbuff.h>	/* for struct sk_buff_head */
 
-struct net_device;
-struct inet6_dev *ipv6_find_idev(struct net_device *dev);
-
 #ifdef CONFIG_IPV6_MROUTE
 static inline int ip6_mroute_opt(int opt)
 {

commit 14fb64e1f449ef6666f1c3a3fa4e13aec669b98d
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Thu Apr 3 09:22:54 2008 +0900

    [IPV6] MROUTE: Support PIM-SM (SSM).
    
    Based on ancient patch by Mickael Hoerdt
    <hoerdt@clarinet.u-strasbg.fr>, which is available at
    <http://www-r2.u-strasbg.fr/~hoerdt/dev/linux_ipv6_mforwarding/patch-linux-ipv6-mforwarding-0.1a>.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index b92190304e0b..f6469fb90840 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -23,6 +23,8 @@
 #define MRT6_ADD_MFC	(MRT6_BASE+4)	/* Add a multicast forwarding entry	*/
 #define MRT6_DEL_MFC	(MRT6_BASE+5)	/* Delete a multicast forwarding entry	*/
 #define MRT6_VERSION	(MRT6_BASE+6)	/* Get the kernel multicast version	*/
+#define MRT6_ASSERT	(MRT6_BASE+7)	/* Activate PIM assert mode		*/
+#define MRT6_PIM	(MRT6_BASE+8)	/* enable PIM code	*/
 
 #define SIOCGETMIFCNT_IN6	SIOCPROTOPRIVATE	/* IP protocol privates */
 #define SIOCGETSGCNT_IN6	(SIOCPROTOPRIVATE+1)
@@ -217,6 +219,8 @@ static inline int ip6mr_sk_done(struct sock *sk) { return 0; }
 
 struct mrt6msg {
 #define MRT6MSG_NOCACHE		1
+#define MRT6MSG_WRONGMIF	2
+#define MRT6MSG_WHOLEPKT	3		/* used for use level encap */
 	__u8		im6_mbz;		/* must be zero		   */
 	__u8		im6_msgtype;		/* what type of message    */
 	__u16		im6_mif;		/* mif rec'd on		   */

commit 7bc570c8b4f75ddb3fd5dbeb38127cdc4acbcc9c
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Thu Apr 3 09:22:53 2008 +0900

    [IPV6] MROUTE: Support multicast forwarding.
    
    Based on ancient patch by Mickael Hoerdt
    <hoerdt@clarinet.u-strasbg.fr>, which is available at
    <http://www-r2.u-strasbg.fr/~hoerdt/dev/linux_ipv6_mforwarding/patch-linux-ipv6-mforwarding-0.1a>.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
new file mode 100644
index 000000000000..b92190304e0b
--- /dev/null
+++ b/include/linux/mroute6.h
@@ -0,0 +1,227 @@
+#ifndef __LINUX_MROUTE6_H
+#define __LINUX_MROUTE6_H
+
+#include <linux/types.h>
+#include <linux/sockios.h>
+
+/*
+ *	Based on the MROUTING 3.5 defines primarily to keep
+ *	source compatibility with BSD.
+ *
+ *	See the pim6sd code for the original history.
+ *
+ *      Protocol Independent Multicast (PIM) data structures included
+ *      Carlos Picoto (cap@di.fc.ul.pt)
+ *
+ */
+
+#define MRT6_BASE	200
+#define MRT6_INIT	(MRT6_BASE)	/* Activate the kernel mroute code 	*/
+#define MRT6_DONE	(MRT6_BASE+1)	/* Shutdown the kernel mroute		*/
+#define MRT6_ADD_MIF	(MRT6_BASE+2)	/* Add a virtual interface		*/
+#define MRT6_DEL_MIF	(MRT6_BASE+3)	/* Delete a virtual interface		*/
+#define MRT6_ADD_MFC	(MRT6_BASE+4)	/* Add a multicast forwarding entry	*/
+#define MRT6_DEL_MFC	(MRT6_BASE+5)	/* Delete a multicast forwarding entry	*/
+#define MRT6_VERSION	(MRT6_BASE+6)	/* Get the kernel multicast version	*/
+
+#define SIOCGETMIFCNT_IN6	SIOCPROTOPRIVATE	/* IP protocol privates */
+#define SIOCGETSGCNT_IN6	(SIOCPROTOPRIVATE+1)
+#define SIOCGETRPF	(SIOCPROTOPRIVATE+2)
+
+#define MAXMIFS		32
+typedef unsigned long mifbitmap_t;	/* User mode code depends on this lot */
+typedef unsigned short mifi_t;
+#define ALL_MIFS	((mifi_t)(-1))
+
+#ifndef IF_SETSIZE
+#define IF_SETSIZE	256
+#endif
+
+typedef	__u32		if_mask;
+#define NIFBITS (sizeof(if_mask) * 8)        /* bits per mask */
+
+#if !defined(__KERNEL__) && !defined(DIV_ROUND_UP)
+#define	DIV_ROUND_UP(x,y)	(((x) + ((y) - 1)) / (y))
+#endif
+
+typedef struct if_set {
+	if_mask ifs_bits[DIV_ROUND_UP(IF_SETSIZE, NIFBITS)];
+} if_set;
+
+#define IF_SET(n, p)    ((p)->ifs_bits[(n)/NIFBITS] |= (1 << ((n) % NIFBITS)))
+#define IF_CLR(n, p)    ((p)->ifs_bits[(n)/NIFBITS] &= ~(1 << ((n) % NIFBITS)))
+#define IF_ISSET(n, p)  ((p)->ifs_bits[(n)/NIFBITS] & (1 << ((n) % NIFBITS)))
+#define IF_COPY(f, t)   bcopy(f, t, sizeof(*(f)))
+#define IF_ZERO(p)      bzero(p, sizeof(*(p)))
+
+/*
+ *	Passed by mrouted for an MRT_ADD_MIF - again we use the
+ *	mrouted 3.6 structures for compatibility
+ */
+
+struct mif6ctl {
+	mifi_t	mif6c_mifi;		/* Index of MIF */
+	unsigned char mif6c_flags;	/* MIFF_ flags */
+	unsigned char vifc_threshold;	/* ttl limit */
+	u_short	 mif6c_pifi;		/* the index of the physical IF */
+	unsigned int vifc_rate_limit;	/* Rate limiter values (NI) */
+};
+
+#define MIFF_REGISTER	0x1	/* register vif	*/
+
+/*
+ *	Cache manipulation structures for mrouted and PIMd
+ */
+
+struct mf6cctl
+{
+	struct sockaddr_in6 mf6cc_origin;		/* Origin of mcast	*/
+	struct sockaddr_in6 mf6cc_mcastgrp;		/* Group in question	*/
+	mifi_t	mf6cc_parent;			/* Where it arrived	*/
+	struct if_set mf6cc_ifset;		/* Where it is going */
+};
+
+/*
+ *	Group count retrieval for pim6sd
+ */
+
+struct sioc_sg_req6
+{
+	struct sockaddr_in6 src;
+	struct sockaddr_in6 grp;
+	unsigned long pktcnt;
+	unsigned long bytecnt;
+	unsigned long wrong_if;
+};
+
+/*
+ *	To get vif packet counts
+ */
+
+struct sioc_mif_req6
+{
+	mifi_t	mifi;		/* Which iface */
+	unsigned long icount;	/* In packets */
+	unsigned long ocount;	/* Out packets */
+	unsigned long ibytes;	/* In bytes */
+	unsigned long obytes;	/* Out bytes */
+};
+
+/*
+ *	That's all usermode folks
+ */
+
+#ifdef __KERNEL__
+
+#include <linux/skbuff.h>	/* for struct sk_buff_head */
+
+struct net_device;
+struct inet6_dev *ipv6_find_idev(struct net_device *dev);
+
+#ifdef CONFIG_IPV6_MROUTE
+static inline int ip6_mroute_opt(int opt)
+{
+	return (opt >= MRT6_BASE) && (opt <= MRT6_BASE + 10);
+}
+#else
+static inline int ip6_mroute_opt(int opt)
+{
+	return 0;
+}
+#endif
+
+struct sock;
+
+extern int ip6_mroute_setsockopt(struct sock *, int, char __user *, int);
+extern int ip6_mroute_getsockopt(struct sock *, int, char __user *, int __user *);
+extern int ip6_mr_input(struct sk_buff *skb);
+extern int ip6mr_ioctl(struct sock *sk, int cmd, void __user *arg);
+extern void ip6_mr_init(void);
+
+struct mif_device
+{
+	struct net_device 	*dev;			/* Device we are using */
+	unsigned long	bytes_in,bytes_out;
+	unsigned long	pkt_in,pkt_out;		/* Statistics 			*/
+	unsigned long	rate_limit;		/* Traffic shaping (NI) 	*/
+	unsigned char	threshold;		/* TTL threshold 		*/
+	unsigned short	flags;			/* Control flags 		*/
+	int		link;			/* Physical interface index	*/
+};
+
+#define VIFF_STATIC 0x8000
+
+struct mfc6_cache
+{
+	struct mfc6_cache *next;		/* Next entry on cache line 	*/
+	struct in6_addr mf6c_mcastgrp;			/* Group the entry belongs to 	*/
+	struct in6_addr mf6c_origin;			/* Source of packet 		*/
+	mifi_t mf6c_parent;			/* Source interface		*/
+	int mfc_flags;				/* Flags on line		*/
+
+	union {
+		struct {
+			unsigned long expires;
+			struct sk_buff_head unresolved;	/* Unresolved buffers		*/
+		} unres;
+		struct {
+			unsigned long last_assert;
+			int minvif;
+			int maxvif;
+			unsigned long bytes;
+			unsigned long pkt;
+			unsigned long wrong_if;
+			unsigned char ttls[MAXMIFS];	/* TTL thresholds		*/
+		} res;
+	} mfc_un;
+};
+
+#define MFC_STATIC		1
+#define MFC_NOTIFY		2
+
+#define MFC6_LINES		64
+
+#define MFC6_HASH(a, g) (((__force u32)(a)->s6_addr32[0] ^ \
+			  (__force u32)(a)->s6_addr32[1] ^ \
+			  (__force u32)(a)->s6_addr32[2] ^ \
+			  (__force u32)(a)->s6_addr32[3] ^ \
+			  (__force u32)(g)->s6_addr32[0] ^ \
+			  (__force u32)(g)->s6_addr32[1] ^ \
+			  (__force u32)(g)->s6_addr32[2] ^ \
+			  (__force u32)(g)->s6_addr32[3]) % MFC6_LINES)
+
+#define MFC_ASSERT_THRESH (3*HZ)		/* Maximal freq. of asserts */
+
+#endif
+
+#ifdef __KERNEL__
+struct rtmsg;
+extern int ip6mr_get_route(struct sk_buff *skb, struct rtmsg *rtm, int nowait);
+
+#ifdef CONFIG_IPV6_MROUTE
+extern struct sock *mroute6_socket;
+extern int ip6mr_sk_done(struct sock *sk);
+#else
+#define mroute6_socket NULL
+static inline int ip6mr_sk_done(struct sock *sk) { return 0; }
+#endif
+#endif
+
+/*
+ * Structure used to communicate from kernel to multicast router.
+ * We'll overlay the structure onto an MLD header (not an IPv6 heder like igmpmsg{}
+ * used for IPv4 implementation). This is because this structure will be passed via an
+ * IPv6 raw socket, on wich an application will only receiver the payload i.e the data after
+ * the IPv6 header and all the extension headers. (See section 3 of RFC 3542)
+ */
+
+struct mrt6msg {
+#define MRT6MSG_NOCACHE		1
+	__u8		im6_mbz;		/* must be zero		   */
+	__u8		im6_msgtype;		/* what type of message    */
+	__u16		im6_mif;		/* mif rec'd on		   */
+	__u32		im6_pad;		/* padding for 64 bit arch */
+	struct in6_addr	im6_src, im6_dst;
+};
+
+#endif
