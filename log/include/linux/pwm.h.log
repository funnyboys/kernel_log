commit 3ad1f3a33286dc67d595f6fab3a3a9e583bc738a
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Mon Feb 10 22:35:18 2020 +0100

    pwm: Implement some checks for lowlevel drivers
    
    There are some expectations which the callbacks provided by lowlevel
    drivers should fulfill. Implement checks that help driver authors to get
    these semantics right. As these have some overhead the checks can be
    disabled using a Kconfig setting.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 0ef808d925bb..2635b2a55090 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -71,7 +71,8 @@ struct pwm_state {
  * @chip: PWM chip providing this PWM device
  * @chip_data: chip-private data associated with the PWM device
  * @args: PWM arguments
- * @state: curent PWM channel state
+ * @state: last applied state
+ * @last: last implemented state (for PWM_DEBUG)
  */
 struct pwm_device {
 	const char *label;
@@ -83,6 +84,7 @@ struct pwm_device {
 
 	struct pwm_args args;
 	struct pwm_state state;
+	struct pwm_state last;
 };
 
 /**

commit 27938fd8ba78b4c7f9a2385b7b52cca19ab891b8
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Fri Oct 4 15:32:07 2019 +0200

    pwm: Update comment on struct pwm_ops::apply
    
    Commit 71523d1812ac (pwm: Ensure pwm_apply_state() doesn't modify the
    state argument) updated the kernel-doc for pwm_apply_state(), but not
    for the ->apply callback in the pwm_ops struct.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Reviewed-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index b2c9c460947d..0ef808d925bb 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -243,10 +243,7 @@ pwm_set_relative_duty_cycle(struct pwm_state *state, unsigned int duty_cycle,
  * @request: optional hook for requesting a PWM
  * @free: optional hook for freeing a PWM
  * @capture: capture and report PWM signal
- * @apply: atomically apply a new PWM config. The state argument
- *	   should be adjusted with the real hardware config (if the
- *	   approximate the period or duty_cycle value, state should
- *	   reflect it)
+ * @apply: atomically apply a new PWM config
  * @get_state: get the current PWM state. This function is only
  *	       called once per PWM device when the PWM chip is
  *	       registered.

commit 71523d1812aca61e32e742e87ec064e3d8c615e1
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Sat Aug 24 17:37:07 2019 +0200

    pwm: Ensure pwm_apply_state() doesn't modify the state argument
    
    It is surprising for a PWM consumer when the variable holding the
    requested state is modified by pwm_apply_state(). Consider for example a
    driver doing:
    
            #define PERIOD 5000000
            #define DUTY_LITTLE 10
            ...
            struct pwm_state state = {
                    .period = PERIOD,
                    .duty_cycle = DUTY_LITTLE,
                    .polarity = PWM_POLARITY_NORMAL,
                    .enabled = true,
            };
    
            pwm_apply_state(mypwm, &state);
            ...
            state.duty_cycle = PERIOD / 2;
            pwm_apply_state(mypwm, &state);
    
    For sure the second call to pwm_apply_state() should still have
    state.period = PERIOD and not something the hardware driver chose for a
    reason that doesn't necessarily apply to the second call.
    
    So declare the state argument as a pointer to a const type and adapt all
    drivers' .apply callbacks.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 24632a7a7d11..b2c9c460947d 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -262,7 +262,7 @@ struct pwm_ops {
 	int (*capture)(struct pwm_chip *chip, struct pwm_device *pwm,
 		       struct pwm_capture *result, unsigned long timeout);
 	int (*apply)(struct pwm_chip *chip, struct pwm_device *pwm,
-		     struct pwm_state *state);
+		     const struct pwm_state *state);
 	void (*get_state)(struct pwm_chip *chip, struct pwm_device *pwm,
 			  struct pwm_state *state);
 	struct module *owner;
@@ -316,7 +316,7 @@ struct pwm_capture {
 /* PWM user APIs */
 struct pwm_device *pwm_request(int pwm_id, const char *label);
 void pwm_free(struct pwm_device *pwm);
-int pwm_apply_state(struct pwm_device *pwm, struct pwm_state *state);
+int pwm_apply_state(struct pwm_device *pwm, const struct pwm_state *state);
 int pwm_adjust_config(struct pwm_device *pwm);
 
 /**

commit 4a6ef8e37c4d9a40f09438068da1734fd965bd75
Author: Nikolaus Voss <nikolaus.voss@loewensteinmedical.de>
Date:   Wed Jun 12 10:36:07 2019 +0200

    pwm: Add support referencing PWMs from ACPI
    
    In analogy to referencing a GPIO using the "gpios" property from ACPI,
    support referencing a PWM using the "pwms" property.
    
    ACPI entries must look like
     Package () {"pwms", Package ()
         { <PWM device reference>, <PWM index>, <PWM period> [, <PWM flags>]}}
    
    In contrast to the DT implementation, only _one_ PWM entry in the "pwms"
    property is supported. As a consequence "pwm-names"-property and
    con_id lookup aren't supported.
    
    Support for ACPI is added via the firmware-node framework which is an
    abstraction layer on top of ACPI/DT. To keep this patch clean, DT and
    ACPI paths are kept separate. The firmware-node framework could be used
    to unify both paths in a future patch.
    
    To support leds-pwm driver, an additional method devm_fwnode_pwm_get()
    which supports both ACPI and DT configuration is exported.
    
    Signed-off-by: Nikolaus Voss <nikolaus.voss@loewensteinmedical.de>
    [thierry.reding@gmail.com: fix build failures for !ACPI]
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 8bf5d5f6267d..24632a7a7d11 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -412,6 +412,9 @@ void pwm_put(struct pwm_device *pwm);
 struct pwm_device *devm_pwm_get(struct device *dev, const char *con_id);
 struct pwm_device *devm_of_pwm_get(struct device *dev, struct device_node *np,
 				   const char *con_id);
+struct pwm_device *devm_fwnode_pwm_get(struct device *dev,
+				       struct fwnode_handle *fwnode,
+				       const char *con_id);
 void devm_pwm_put(struct device *dev, struct pwm_device *pwm);
 #else
 static inline struct pwm_device *pwm_request(int pwm_id, const char *label)
@@ -518,6 +521,13 @@ static inline struct pwm_device *devm_of_pwm_get(struct device *dev,
 	return ERR_PTR(-ENODEV);
 }
 
+static inline struct pwm_device *
+devm_fwnode_pwm_get(struct device *dev, struct fwnode_handle *fwnode,
+		    const char *con_id)
+{
+	return ERR_PTR(-ENODEV);
+}
+
 static inline void devm_pwm_put(struct device *dev, struct pwm_device *pwm)
 {
 }

commit b2c200e3f2fd1158f5f1c93ccb2e0a27d96c4a7a
Author: Fabrice Gasnier <fabrice.gasnier@st.com>
Date:   Thu Apr 18 11:37:47 2019 +0200

    pwm: Add consumer device link
    
    Add a device link between the PWM consumer and the PWM provider. This
    enforces the PWM user to get suspended before the PWM provider. It
    allows proper synchronization of suspend/resume sequences: the PWM user
    is responsible for properly stopping PWM, before the provider gets
    suspended: see [1]. Add the device link in:
    - of_pwm_get()
    - pwm_get()
    - devm_*pwm_get() variants
    as it requires a reference to the device for the PWM consumer.
    
    [1] https://lkml.org/lkml/2019/2/5/770
    
    Suggested-by: Thierry Reding <thierry.reding@gmail.com>
    Acked-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Fabrice Gasnier <fabrice.gasnier@st.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index eaa5c6e3fc9f..8bf5d5f6267d 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -405,7 +405,8 @@ struct pwm_device *of_pwm_xlate_with_flags(struct pwm_chip *pc,
 		const struct of_phandle_args *args);
 
 struct pwm_device *pwm_get(struct device *dev, const char *con_id);
-struct pwm_device *of_pwm_get(struct device_node *np, const char *con_id);
+struct pwm_device *of_pwm_get(struct device *dev, struct device_node *np,
+			      const char *con_id);
 void pwm_put(struct pwm_device *pwm);
 
 struct pwm_device *devm_pwm_get(struct device *dev, const char *con_id);
@@ -493,7 +494,8 @@ static inline struct pwm_device *pwm_get(struct device *dev,
 	return ERR_PTR(-ENODEV);
 }
 
-static inline struct pwm_device *of_pwm_get(struct device_node *np,
+static inline struct pwm_device *of_pwm_get(struct device *dev,
+					    struct device_node *np,
 					    const char *con_id)
 {
 	return ERR_PTR(-ENODEV);

commit 347ab9480313737c0f1aaa08e8f2e1a791235535
Author: Phong Hoang <phong.hoang.wz@renesas.com>
Date:   Tue Mar 19 19:40:08 2019 +0900

    pwm: Fix deadlock warning when removing PWM device
    
    This patch fixes deadlock warning if removing PWM device
    when CONFIG_PROVE_LOCKING is enabled.
    
    This issue can be reproceduced by the following steps on
    the R-Car H3 Salvator-X board if the backlight is disabled:
    
     # cd /sys/class/pwm/pwmchip0
     # echo 0 > export
     # ls
     device  export  npwm  power  pwm0  subsystem  uevent  unexport
     # cd device/driver
     # ls
     bind  e6e31000.pwm  uevent  unbind
     # echo e6e31000.pwm > unbind
    
    [   87.659974] ======================================================
    [   87.666149] WARNING: possible circular locking dependency detected
    [   87.672327] 5.0.0 #7 Not tainted
    [   87.675549] ------------------------------------------------------
    [   87.681723] bash/2986 is trying to acquire lock:
    [   87.686337] 000000005ea0e178 (kn->count#58){++++}, at: kernfs_remove_by_name_ns+0x50/0xa0
    [   87.694528]
    [   87.694528] but task is already holding lock:
    [   87.700353] 000000006313b17c (pwm_lock){+.+.}, at: pwmchip_remove+0x28/0x13c
    [   87.707405]
    [   87.707405] which lock already depends on the new lock.
    [   87.707405]
    [   87.715574]
    [   87.715574] the existing dependency chain (in reverse order) is:
    [   87.723048]
    [   87.723048] -> #1 (pwm_lock){+.+.}:
    [   87.728017]        __mutex_lock+0x70/0x7e4
    [   87.732108]        mutex_lock_nested+0x1c/0x24
    [   87.736547]        pwm_request_from_chip.part.6+0x34/0x74
    [   87.741940]        pwm_request_from_chip+0x20/0x40
    [   87.746725]        export_store+0x6c/0x1f4
    [   87.750820]        dev_attr_store+0x18/0x28
    [   87.754998]        sysfs_kf_write+0x54/0x64
    [   87.759175]        kernfs_fop_write+0xe4/0x1e8
    [   87.763615]        __vfs_write+0x40/0x184
    [   87.767619]        vfs_write+0xa8/0x19c
    [   87.771448]        ksys_write+0x58/0xbc
    [   87.775278]        __arm64_sys_write+0x18/0x20
    [   87.779721]        el0_svc_common+0xd0/0x124
    [   87.783986]        el0_svc_compat_handler+0x1c/0x24
    [   87.788858]        el0_svc_compat+0x8/0x18
    [   87.792947]
    [   87.792947] -> #0 (kn->count#58){++++}:
    [   87.798260]        lock_acquire+0xc4/0x22c
    [   87.802353]        __kernfs_remove+0x258/0x2c4
    [   87.806790]        kernfs_remove_by_name_ns+0x50/0xa0
    [   87.811836]        remove_files.isra.1+0x38/0x78
    [   87.816447]        sysfs_remove_group+0x48/0x98
    [   87.820971]        sysfs_remove_groups+0x34/0x4c
    [   87.825583]        device_remove_attrs+0x6c/0x7c
    [   87.830197]        device_del+0x11c/0x33c
    [   87.834201]        device_unregister+0x14/0x2c
    [   87.838638]        pwmchip_sysfs_unexport+0x40/0x4c
    [   87.843509]        pwmchip_remove+0xf4/0x13c
    [   87.847773]        rcar_pwm_remove+0x28/0x34
    [   87.852039]        platform_drv_remove+0x24/0x64
    [   87.856651]        device_release_driver_internal+0x18c/0x21c
    [   87.862391]        device_release_driver+0x14/0x1c
    [   87.867175]        unbind_store+0xe0/0x124
    [   87.871265]        drv_attr_store+0x20/0x30
    [   87.875442]        sysfs_kf_write+0x54/0x64
    [   87.879618]        kernfs_fop_write+0xe4/0x1e8
    [   87.884055]        __vfs_write+0x40/0x184
    [   87.888057]        vfs_write+0xa8/0x19c
    [   87.891887]        ksys_write+0x58/0xbc
    [   87.895716]        __arm64_sys_write+0x18/0x20
    [   87.900154]        el0_svc_common+0xd0/0x124
    [   87.904417]        el0_svc_compat_handler+0x1c/0x24
    [   87.909289]        el0_svc_compat+0x8/0x18
    [   87.913378]
    [   87.913378] other info that might help us debug this:
    [   87.913378]
    [   87.921374]  Possible unsafe locking scenario:
    [   87.921374]
    [   87.927286]        CPU0                    CPU1
    [   87.931808]        ----                    ----
    [   87.936331]   lock(pwm_lock);
    [   87.939293]                                lock(kn->count#58);
    [   87.945120]                                lock(pwm_lock);
    [   87.950599]   lock(kn->count#58);
    [   87.953908]
    [   87.953908]  *** DEADLOCK ***
    [   87.953908]
    [   87.959821] 4 locks held by bash/2986:
    [   87.963563]  #0: 00000000ace7bc30 (sb_writers#6){.+.+}, at: vfs_write+0x188/0x19c
    [   87.971044]  #1: 00000000287991b2 (&of->mutex){+.+.}, at: kernfs_fop_write+0xb4/0x1e8
    [   87.978872]  #2: 00000000f739d016 (&dev->mutex){....}, at: device_release_driver_internal+0x40/0x21c
    [   87.988001]  #3: 000000006313b17c (pwm_lock){+.+.}, at: pwmchip_remove+0x28/0x13c
    [   87.995481]
    [   87.995481] stack backtrace:
    [   87.999836] CPU: 0 PID: 2986 Comm: bash Not tainted 5.0.0 #7
    [   88.005489] Hardware name: Renesas Salvator-X board based on r8a7795 ES1.x (DT)
    [   88.012791] Call trace:
    [   88.015235]  dump_backtrace+0x0/0x190
    [   88.018891]  show_stack+0x14/0x1c
    [   88.022204]  dump_stack+0xb0/0xec
    [   88.025514]  print_circular_bug.isra.32+0x1d0/0x2e0
    [   88.030385]  __lock_acquire+0x1318/0x1864
    [   88.034388]  lock_acquire+0xc4/0x22c
    [   88.037958]  __kernfs_remove+0x258/0x2c4
    [   88.041874]  kernfs_remove_by_name_ns+0x50/0xa0
    [   88.046398]  remove_files.isra.1+0x38/0x78
    [   88.050487]  sysfs_remove_group+0x48/0x98
    [   88.054490]  sysfs_remove_groups+0x34/0x4c
    [   88.058580]  device_remove_attrs+0x6c/0x7c
    [   88.062671]  device_del+0x11c/0x33c
    [   88.066154]  device_unregister+0x14/0x2c
    [   88.070070]  pwmchip_sysfs_unexport+0x40/0x4c
    [   88.074421]  pwmchip_remove+0xf4/0x13c
    [   88.078163]  rcar_pwm_remove+0x28/0x34
    [   88.081906]  platform_drv_remove+0x24/0x64
    [   88.085996]  device_release_driver_internal+0x18c/0x21c
    [   88.091215]  device_release_driver+0x14/0x1c
    [   88.095478]  unbind_store+0xe0/0x124
    [   88.099048]  drv_attr_store+0x20/0x30
    [   88.102704]  sysfs_kf_write+0x54/0x64
    [   88.106359]  kernfs_fop_write+0xe4/0x1e8
    [   88.110275]  __vfs_write+0x40/0x184
    [   88.113757]  vfs_write+0xa8/0x19c
    [   88.117065]  ksys_write+0x58/0xbc
    [   88.120374]  __arm64_sys_write+0x18/0x20
    [   88.124291]  el0_svc_common+0xd0/0x124
    [   88.128034]  el0_svc_compat_handler+0x1c/0x24
    [   88.132384]  el0_svc_compat+0x8/0x18
    
    The sysfs unexport in pwmchip_remove() is completely asymmetric
    to what we do in pwmchip_add_with_polarity() and commit 0733424c9ba9
    ("pwm: Unexport children before chip removal") is a strong indication
    that this was wrong to begin with. We should just move
    pwmchip_sysfs_unexport() where it belongs, which is right after
    pwmchip_sysfs_unexport_children(). In that case, we do not need
    separate functions anymore either.
    
    We also really want to remove sysfs irrespective of whether or not
    the chip will be removed as a result of pwmchip_remove(). We can only
    assume that the driver will be gone after that, so we shouldn't leave
    any dangling sysfs files around.
    
    This warning disappears if we move pwmchip_sysfs_unexport() to
    the top of pwmchip_remove(), pwmchip_sysfs_unexport_children().
    That way it is also outside of the pwm_lock section, which indeed
    doesn't seem to be needed.
    
    Moving the pwmchip_sysfs_export() call outside of that section also
    seems fine and it'd be perfectly symmetric with pwmchip_remove() again.
    
    So, this patch fixes them.
    
    Signed-off-by: Phong Hoang <phong.hoang.wz@renesas.com>
    [shimoda: revise the commit log and code]
    Fixes: 76abbdde2d95 ("pwm: Add sysfs interface")
    Fixes: 0733424c9ba9 ("pwm: Unexport children before chip removal")
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Tested-by: Hoan Nguyen An <na-hoan@jinso.co.jp>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Reviewed-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index b628abfffacc..eaa5c6e3fc9f 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -596,7 +596,6 @@ static inline void pwm_remove_table(struct pwm_lookup *table, size_t num)
 #ifdef CONFIG_PWM_SYSFS
 void pwmchip_sysfs_export(struct pwm_chip *chip);
 void pwmchip_sysfs_unexport(struct pwm_chip *chip);
-void pwmchip_sysfs_unexport_children(struct pwm_chip *chip);
 #else
 static inline void pwmchip_sysfs_export(struct pwm_chip *chip)
 {
@@ -605,10 +604,6 @@ static inline void pwmchip_sysfs_export(struct pwm_chip *chip)
 static inline void pwmchip_sysfs_unexport(struct pwm_chip *chip)
 {
 }
-
-static inline void pwmchip_sysfs_unexport_children(struct pwm_chip *chip)
-{
-}
 #endif /* CONFIG_PWM_SYSFS */
 
 #endif /* __LINUX_PWM_H */

commit 5d0a4c11896e8b83f816f135c24b184d4ba57741
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Mon Jan 7 20:49:41 2019 +0100

    pwm: Rearrange structures to group members by purpose
    
    In pwm_ops there are a few callbacks that are not supposed to be used by
    new drivers. Group them at the end of the structure and add a comment.
    
    Similarily for struct pwm_chip group the members that drivers shouldn't
    care about at the end and mark them as internal with another comment.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 6a544cb89de4..b628abfffacc 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -242,11 +242,7 @@ pwm_set_relative_duty_cycle(struct pwm_state *state, unsigned int duty_cycle,
  * struct pwm_ops - PWM controller operations
  * @request: optional hook for requesting a PWM
  * @free: optional hook for freeing a PWM
- * @config: configure duty cycles and period length for this PWM
- * @set_polarity: configure the polarity of this PWM
  * @capture: capture and report PWM signal
- * @enable: enable PWM output toggling
- * @disable: disable PWM output toggling
  * @apply: atomically apply a new PWM config. The state argument
  *	   should be adjusted with the real hardware config (if the
  *	   approximate the period or duty_cycle value, state should
@@ -255,48 +251,55 @@ pwm_set_relative_duty_cycle(struct pwm_state *state, unsigned int duty_cycle,
  *	       called once per PWM device when the PWM chip is
  *	       registered.
  * @owner: helps prevent removal of modules exporting active PWMs
+ * @config: configure duty cycles and period length for this PWM
+ * @set_polarity: configure the polarity of this PWM
+ * @enable: enable PWM output toggling
+ * @disable: disable PWM output toggling
  */
 struct pwm_ops {
 	int (*request)(struct pwm_chip *chip, struct pwm_device *pwm);
 	void (*free)(struct pwm_chip *chip, struct pwm_device *pwm);
-	int (*config)(struct pwm_chip *chip, struct pwm_device *pwm,
-		      int duty_ns, int period_ns);
-	int (*set_polarity)(struct pwm_chip *chip, struct pwm_device *pwm,
-			    enum pwm_polarity polarity);
 	int (*capture)(struct pwm_chip *chip, struct pwm_device *pwm,
 		       struct pwm_capture *result, unsigned long timeout);
-	int (*enable)(struct pwm_chip *chip, struct pwm_device *pwm);
-	void (*disable)(struct pwm_chip *chip, struct pwm_device *pwm);
 	int (*apply)(struct pwm_chip *chip, struct pwm_device *pwm,
 		     struct pwm_state *state);
 	void (*get_state)(struct pwm_chip *chip, struct pwm_device *pwm,
 			  struct pwm_state *state);
 	struct module *owner;
+
+	/* Only used by legacy drivers */
+	int (*config)(struct pwm_chip *chip, struct pwm_device *pwm,
+		      int duty_ns, int period_ns);
+	int (*set_polarity)(struct pwm_chip *chip, struct pwm_device *pwm,
+			    enum pwm_polarity polarity);
+	int (*enable)(struct pwm_chip *chip, struct pwm_device *pwm);
+	void (*disable)(struct pwm_chip *chip, struct pwm_device *pwm);
 };
 
 /**
  * struct pwm_chip - abstract a PWM controller
  * @dev: device providing the PWMs
- * @list: list node for internal use
  * @ops: callbacks for this PWM controller
  * @base: number of first PWM controlled by this chip
  * @npwm: number of PWMs controlled by this chip
- * @pwms: array of PWM devices allocated by the framework
  * @of_xlate: request a PWM device given a device tree PWM specifier
  * @of_pwm_n_cells: number of cells expected in the device tree PWM specifier
+ * @list: list node for internal use
+ * @pwms: array of PWM devices allocated by the framework
  */
 struct pwm_chip {
 	struct device *dev;
-	struct list_head list;
 	const struct pwm_ops *ops;
 	int base;
 	unsigned int npwm;
 
-	struct pwm_device *pwms;
-
 	struct pwm_device * (*of_xlate)(struct pwm_chip *pc,
 					const struct of_phandle_args *args);
 	unsigned int of_pwm_n_cells;
+
+	/* only used internally by the PWM framework */
+	struct list_head list;
+	struct pwm_device *pwms;
 };
 
 /**

commit cc2d22477779f189595db5c515bd5ef9c75a1f35
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Mon Jan 7 20:49:39 2019 +0100

    pwm: Drop per-chip dbg_show callback
    
    This callback was introduced in commit 62099abf67a2 ("pwm: Add debugfs
    interface") in 2012 and up to now there is not a single user. So drop
    this unused code.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    [thierry.reding@gmail.com: remove kerneldoc for ->dbg_show()]
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index d5199b507d79..6a544cb89de4 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -254,7 +254,6 @@ pwm_set_relative_duty_cycle(struct pwm_state *state, unsigned int duty_cycle,
  * @get_state: get the current PWM state. This function is only
  *	       called once per PWM device when the PWM chip is
  *	       registered.
- * @dbg_show: optional routine to show contents in debugfs
  * @owner: helps prevent removal of modules exporting active PWMs
  */
 struct pwm_ops {
@@ -272,9 +271,6 @@ struct pwm_ops {
 		     struct pwm_state *state);
 	void (*get_state)(struct pwm_chip *chip, struct pwm_device *pwm,
 			  struct pwm_state *state);
-#ifdef CONFIG_DEBUG_FS
-	void (*dbg_show)(struct pwm_chip *chip, struct seq_file *s);
-#endif
 	struct module *owner;
 };
 

commit a36b2606795800a15f6f33ee4c283ad66e1d7bfe
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Mon Oct 15 10:21:52 2018 +0200

    pwm: Drop legacy wrapper for changing polarity
    
    The API to configure a PWM using pwm_enable(), pwm_disable(),
    pwm_config() and pwm_set_polarity() is superseeded by atomically setting
    the parameters using pwm_apply_state(). To get forward with deprecating
    the former set of functions use the opportunity that there is no current
    user of pwm_set_polarity() and remove it.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 56518adc31dd..d5199b507d79 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -348,42 +348,6 @@ static inline int pwm_config(struct pwm_device *pwm, int duty_ns,
 	return pwm_apply_state(pwm, &state);
 }
 
-/**
- * pwm_set_polarity() - configure the polarity of a PWM signal
- * @pwm: PWM device
- * @polarity: new polarity of the PWM signal
- *
- * Note that the polarity cannot be configured while the PWM device is
- * enabled.
- *
- * Returns: 0 on success or a negative error code on failure.
- */
-static inline int pwm_set_polarity(struct pwm_device *pwm,
-				   enum pwm_polarity polarity)
-{
-	struct pwm_state state;
-
-	if (!pwm)
-		return -EINVAL;
-
-	pwm_get_state(pwm, &state);
-	if (state.polarity == polarity)
-		return 0;
-
-	/*
-	 * Changing the polarity of a running PWM without adjusting the
-	 * dutycycle/period value is a bit risky (can introduce glitches).
-	 * Return -EBUSY in this case.
-	 * Note that this is allowed when using pwm_apply_state() because
-	 * the user specifies all the parameters.
-	 */
-	if (state.enabled)
-		return -EBUSY;
-
-	state.polarity = polarity;
-	return pwm_apply_state(pwm, &state);
-}
-
 /**
  * pwm_enable() - start a PWM output toggling
  * @pwm: PWM device
@@ -483,12 +447,6 @@ static inline int pwm_capture(struct pwm_device *pwm,
 	return -EINVAL;
 }
 
-static inline int pwm_set_polarity(struct pwm_device *pwm,
-				   enum pwm_polarity polarity)
-{
-	return -ENOTSUPP;
-}
-
 static inline int pwm_enable(struct pwm_device *pwm)
 {
 	return -EINVAL;

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 08fad7c6a471..56518adc31dd 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __LINUX_PWM_H
 #define __LINUX_PWM_H
 

commit b526a314263ea217b8fa9758dca5dc245fd49997
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Jan 22 17:14:08 2017 +0100

    pwm: Try to load modules during pwm_get()
    
    Add a module name string to the pwm_lookup struct and if specified try
    to load the module using request_module() if pwmchip_find_by_name() is
    unable to find the PWM chip.
    
    This is a last resort to work around drivers that can't - and can't be
    made to - deal with deferred probe.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    [thierry.reding@gmail.com: rename new macro, reword commit message]
    [thierry.reding@gmail.com: add comment explaining use-case]
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index eae215ef1b2c..08fad7c6a471 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -603,18 +603,25 @@ struct pwm_lookup {
 	const char *con_id;
 	unsigned int period;
 	enum pwm_polarity polarity;
+	const char *module; /* optional, may be NULL */
 };
 
-#define PWM_LOOKUP(_provider, _index, _dev_id, _con_id, _period, _polarity) \
-	{						\
-		.provider = _provider,			\
-		.index = _index,			\
-		.dev_id = _dev_id,			\
-		.con_id = _con_id,			\
-		.period = _period,			\
-		.polarity = _polarity			\
+#define PWM_LOOKUP_WITH_MODULE(_provider, _index, _dev_id, _con_id,	\
+			       _period, _polarity, _module)		\
+	{								\
+		.provider = _provider,					\
+		.index = _index,					\
+		.dev_id = _dev_id,					\
+		.con_id = _con_id,					\
+		.period = _period,					\
+		.polarity = _polarity,					\
+		.module = _module,					\
 	}
 
+#define PWM_LOOKUP(_provider, _index, _dev_id, _con_id, _period, _polarity) \
+	PWM_LOOKUP_WITH_MODULE(_provider, _index, _dev_id, _con_id, _period, \
+			       _polarity, NULL)
+
 #if IS_ENABLED(CONFIG_PWM)
 void pwm_add_table(struct pwm_lookup *table, size_t num);
 void pwm_remove_table(struct pwm_lookup *table, size_t num);

commit 8c0216f377406c7613b67bd18755889026284192
Author: Thierry Reding <thierry.reding@gmail.com>
Date:   Wed Jan 4 09:40:54 2017 +0100

    pwm: Remove .can_sleep from struct pwm_chip
    
    All PWM devices have been marked as "might sleep" since v4.5, there is
    no longer a need to differentiate on a per-chip basis.
    
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index e15fd3ce6502..eae215ef1b2c 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -287,8 +287,6 @@ struct pwm_ops {
  * @pwms: array of PWM devices allocated by the framework
  * @of_xlate: request a PWM device given a device tree PWM specifier
  * @of_pwm_n_cells: number of cells expected in the device tree PWM specifier
- * @can_sleep: must be true if the .config(), .enable() or .disable()
- *             operations may sleep
  */
 struct pwm_chip {
 	struct device *dev;
@@ -302,7 +300,6 @@ struct pwm_chip {
 	struct pwm_device * (*of_xlate)(struct pwm_chip *pc,
 					const struct of_phandle_args *args);
 	unsigned int of_pwm_n_cells;
-	bool can_sleep;
 };
 
 /**

commit fe2858c8c6d167df33a839591ebe63ea05a69d06
Author: Thierry Reding <thierry.reding@gmail.com>
Date:   Wed Jan 4 09:39:52 2017 +0100

    pwm: Remove pwm_can_sleep()
    
    The last user of this function has been removed, so it is no longer
    needed.
    
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 2c6c5114c089..e15fd3ce6502 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -451,8 +451,6 @@ struct pwm_device *devm_pwm_get(struct device *dev, const char *con_id);
 struct pwm_device *devm_of_pwm_get(struct device *dev, struct device_node *np,
 				   const char *con_id);
 void devm_pwm_put(struct device *dev, struct pwm_device *pwm);
-
-bool pwm_can_sleep(struct pwm_device *pwm);
 #else
 static inline struct pwm_device *pwm_request(int pwm_id, const char *label)
 {
@@ -566,11 +564,6 @@ static inline struct pwm_device *devm_of_pwm_get(struct device *dev,
 static inline void devm_pwm_put(struct device *dev, struct pwm_device *pwm)
 {
 }
-
-static inline bool pwm_can_sleep(struct pwm_device *pwm)
-{
-	return false;
-}
 #endif
 
 static inline void pwm_apply_args(struct pwm_device *pwm)

commit 0733424c9ba9f42242409d1ece780777272f7ea1
Author: David Hsu <davidhsu@google.com>
Date:   Tue Aug 9 14:57:46 2016 -0700

    pwm: Unexport children before chip removal
    
    Exported pwm channels aren't removed before the pwmchip and are
    leaked. This results in invalid sysfs files. This fix removes
    all exported pwm channels before chip removal.
    
    Signed-off-by: David Hsu <davidhsu@google.com>
    Fixes: 76abbdde2d95 ("pwm: Add sysfs interface")
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index f1bbae014889..2c6c5114c089 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -641,6 +641,7 @@ static inline void pwm_remove_table(struct pwm_lookup *table, size_t num)
 #ifdef CONFIG_PWM_SYSFS
 void pwmchip_sysfs_export(struct pwm_chip *chip);
 void pwmchip_sysfs_unexport(struct pwm_chip *chip);
+void pwmchip_sysfs_unexport_children(struct pwm_chip *chip);
 #else
 static inline void pwmchip_sysfs_export(struct pwm_chip *chip)
 {
@@ -649,6 +650,10 @@ static inline void pwmchip_sysfs_export(struct pwm_chip *chip)
 static inline void pwmchip_sysfs_unexport(struct pwm_chip *chip)
 {
 }
+
+static inline void pwmchip_sysfs_unexport_children(struct pwm_chip *chip)
+{
+}
 #endif /* CONFIG_PWM_SYSFS */
 
 #endif /* __LINUX_PWM_H */

commit bd2686122d3b45db1398776921bd47fedfd6d6a5
Merge: 489babeae6b9 1a366fe9153f
Author: Thierry Reding <thierry.reding@gmail.com>
Date:   Mon Jul 25 16:23:39 2016 +0200

    Merge branch 'for-4.8/capture' into for-next

commit ef8e26bb6610848197b0795dbca6b0b1afed30dd
Merge: bcedaba104ce 2b77487f2e8f
Author: Thierry Reding <thierry.reding@gmail.com>
Date:   Mon Jul 25 16:23:37 2016 +0200

    Merge branch 'for-4.8/core' into for-next

commit 2b77487f2e8ff7e6496a7f5a08839de9bbb39ab3
Author: Thierry Reding <thierry.reding@gmail.com>
Date:   Fri Jun 10 15:49:53 2016 +0200

    pwm: Remove gratuitous blank line
    
    Commit 5ec803edcb70 ("pwm: Add core infrastructure to allow atomic
    updates") introduced this double blank line by mistake.
    
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index fd1092729ed6..83d8bcb7e1de 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -408,7 +408,6 @@ static inline void pwm_disable(struct pwm_device *pwm)
 	pwm_apply_state(pwm, &state);
 }
 
-
 /* PWM provider APIs */
 int pwm_set_chip_data(struct pwm_device *pwm, void *data);
 void *pwm_get_chip_data(struct pwm_device *pwm);

commit f6f3bddf7b2b994a927808fcc5a3d07069c35956
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Tue Jun 14 11:13:10 2016 +0200

    pwm: Add relative duty cycle manipulation helpers
    
    The PWM framework expects PWM users to configure the duty cycle in nano-
    seconds, but many users want to express the duty cycle relatively to the
    period value (i.e. duty_cycle = 33% of the period).
    
    Add the pwm_{get,set}_relative_duty_cycle() helpers to ease this kind of
    conversion.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index a100f6e80738..fd1092729ed6 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -180,6 +180,61 @@ static inline void pwm_init_state(const struct pwm_device *pwm,
 	state->duty_cycle = 0;
 }
 
+/**
+ * pwm_get_relative_duty_cycle() - Get a relative duty cycle value
+ * @state: PWM state to extract the duty cycle from
+ * @scale: target scale of the relative duty cycle
+ *
+ * This functions converts the absolute duty cycle stored in @state (expressed
+ * in nanosecond) into a value relative to the period.
+ *
+ * For example if you want to get the duty_cycle expressed in percent, call:
+ *
+ * pwm_get_state(pwm, &state);
+ * duty = pwm_get_relative_duty_cycle(&state, 100);
+ */
+static inline unsigned int
+pwm_get_relative_duty_cycle(const struct pwm_state *state, unsigned int scale)
+{
+	if (!state->period)
+		return 0;
+
+	return DIV_ROUND_CLOSEST_ULL((u64)state->duty_cycle * scale,
+				     state->period);
+}
+
+/**
+ * pwm_set_relative_duty_cycle() - Set a relative duty cycle value
+ * @state: PWM state to fill
+ * @duty_cycle: relative duty cycle value
+ * @scale: scale in which @duty_cycle is expressed
+ *
+ * This functions converts a relative into an absolute duty cycle (expressed
+ * in nanoseconds), and puts the result in state->duty_cycle.
+ *
+ * For example if you want to configure a 50% duty cycle, call:
+ *
+ * pwm_init_state(pwm, &state);
+ * pwm_set_relative_duty_cycle(&state, 50, 100);
+ * pwm_apply_state(pwm, &state);
+ *
+ * This functions returns -EINVAL if @duty_cycle and/or @scale are
+ * inconsistent (@scale == 0 or @duty_cycle > @scale).
+ */
+static inline int
+pwm_set_relative_duty_cycle(struct pwm_state *state, unsigned int duty_cycle,
+			    unsigned int scale)
+{
+	if (!scale || duty_cycle > scale)
+		return -EINVAL;
+
+	state->duty_cycle = DIV_ROUND_CLOSEST_ULL((u64)duty_cycle *
+						  state->period,
+						  scale);
+
+	return 0;
+}
+
 /**
  * struct pwm_ops - PWM controller operations
  * @request: optional hook for requesting a PWM

commit a6a0dbbcfa469cf3e5c4d9522106c0b7b9e9e373
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Tue Jun 14 11:13:09 2016 +0200

    pwm: Add a helper to prepare a new PWM state
    
    The pwm_init_state() helper prepares a new state object containing the
    current PWM state except for the polarity and period fields which are
    set to the reference values (those in struct pwm_args).
    
    This is particularly useful for PWM users who want to apply a new duty-
    cycle expressed relatively to the reference period without changing the
    enable state.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 17018f3c066e..a100f6e80738 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -147,6 +147,39 @@ static inline void pwm_get_args(const struct pwm_device *pwm,
 	*args = pwm->args;
 }
 
+/**
+ * pwm_init_state() - prepare a new state to be applied with pwm_apply_state()
+ * @pwm: PWM device
+ * @state: state to fill with the prepared PWM state
+ *
+ * This functions prepares a state that can later be tweaked and applied
+ * to the PWM device with pwm_apply_state(). This is a convenient function
+ * that first retrieves the current PWM state and the replaces the period
+ * and polarity fields with the reference values defined in pwm->args.
+ * Once the function returns, you can adjust the ->enabled and ->duty_cycle
+ * fields according to your needs before calling pwm_apply_state().
+ *
+ * ->duty_cycle is initially set to zero to avoid cases where the current
+ * ->duty_cycle value exceed the pwm_args->period one, which would trigger
+ * an error if the user calls pwm_apply_state() without adjusting ->duty_cycle
+ * first.
+ */
+static inline void pwm_init_state(const struct pwm_device *pwm,
+				  struct pwm_state *state)
+{
+	struct pwm_args args;
+
+	/* First get the current state. */
+	pwm_get_state(pwm, state);
+
+	/* Then fill it with the reference config */
+	pwm_get_args(pwm, &args);
+
+	state->period = args.period;
+	state->polarity = args.polarity;
+	state->duty_cycle = 0;
+}
+
 /**
  * struct pwm_ops - PWM controller operations
  * @request: optional hook for requesting a PWM

commit 33cdcee04be3b4482be97393167e7561b2584e1e
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Wed Jun 22 09:25:14 2016 +0200

    pwm: Fix pwm_apply_args()
    
    Commit 5ec803edcb70 ("pwm: Add core infrastructure to allow atomic
    updates"), implemented pwm_disable() as a wrapper around
    pwm_apply_state(), and then, commit ef2bf4997f7d ("pwm: Improve args
    checking in pwm_apply_state()") added missing checks on the ->period
    value in pwm_apply_state() to ensure we were not passing inappropriate
    values to the ->config() or ->apply() methods.
    
    The conjunction of these 2 commits led to a case where pwm_disable()
    was no longer succeeding, thus preventing the polarity setting done
    in pwm_apply_args().
    
    Set a valid period in pwm_apply_args() to ensure polarity setting
    won't be rejected.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Suggested-by: Brian Norris <briannorris@chromium.org>
    Fixes: 5ec803edcb70 ("pwm: Add core infrastructure to allow atomic updates")
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Brian Norris <briannorris@chromium.org>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 908b67c847cd..c038ae36b10e 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -464,6 +464,8 @@ static inline bool pwm_can_sleep(struct pwm_device *pwm)
 
 static inline void pwm_apply_args(struct pwm_device *pwm)
 {
+	struct pwm_state state = { };
+
 	/*
 	 * PWM users calling pwm_apply_args() expect to have a fresh config
 	 * where the polarity and period are set according to pwm_args info.
@@ -476,18 +478,20 @@ static inline void pwm_apply_args(struct pwm_device *pwm)
 	 * at startup (even if they are actually enabled), thus authorizing
 	 * polarity setting.
 	 *
-	 * Instead of setting ->enabled to false, we call pwm_disable()
-	 * before pwm_set_polarity() to ensure that everything is configured
-	 * as expected, and the PWM is really disabled when the user request
-	 * it.
+	 * To fulfill this requirement, we apply a new state which disables
+	 * the PWM device and set the reference period and polarity config.
 	 *
 	 * Note that PWM users requiring a smooth handover between the
 	 * bootloader and the kernel (like critical regulators controlled by
 	 * PWM devices) will have to switch to the atomic API and avoid calling
 	 * pwm_apply_args().
 	 */
-	pwm_disable(pwm);
-	pwm_set_polarity(pwm, pwm->args.polarity);
+
+	state.enabled = false;
+	state.polarity = pwm->args.polarity;
+	state.period = pwm->args.period;
+
+	pwm_apply_state(pwm, &state);
 }
 
 struct pwm_lookup {

commit 3a3d1a4e32ab47323d7b8c8b7631a8d36a3098b2
Author: Lee Jones <lee.jones@linaro.org>
Date:   Wed Jun 8 10:21:23 2016 +0100

    pwm: Add PWM capture support
    
    Supply a PWM capture callback op in order to pass back information
    obtained by running analysis on a PWM signal. This would normally (at
    least during testing) be called from the sysfs routines with a view to
    printing out PWM capture data which has been encoded into a string.
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    [thierry.reding@gmail.com: make capture data unsigned int for symmetry]
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 17018f3c066e..8402b5dd3e06 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -5,7 +5,9 @@
 #include <linux/mutex.h>
 #include <linux/of.h>
 
+struct pwm_capture;
 struct seq_file;
+
 struct pwm_chip;
 
 /**
@@ -153,6 +155,7 @@ static inline void pwm_get_args(const struct pwm_device *pwm,
  * @free: optional hook for freeing a PWM
  * @config: configure duty cycles and period length for this PWM
  * @set_polarity: configure the polarity of this PWM
+ * @capture: capture and report PWM signal
  * @enable: enable PWM output toggling
  * @disable: disable PWM output toggling
  * @apply: atomically apply a new PWM config. The state argument
@@ -172,6 +175,8 @@ struct pwm_ops {
 		      int duty_ns, int period_ns);
 	int (*set_polarity)(struct pwm_chip *chip, struct pwm_device *pwm,
 			    enum pwm_polarity polarity);
+	int (*capture)(struct pwm_chip *chip, struct pwm_device *pwm,
+		       struct pwm_capture *result, unsigned long timeout);
 	int (*enable)(struct pwm_chip *chip, struct pwm_device *pwm);
 	void (*disable)(struct pwm_chip *chip, struct pwm_device *pwm);
 	int (*apply)(struct pwm_chip *chip, struct pwm_device *pwm,
@@ -212,6 +217,16 @@ struct pwm_chip {
 	bool can_sleep;
 };
 
+/**
+ * struct pwm_capture - PWM capture data
+ * @period: period of the PWM signal (in nanoseconds)
+ * @duty_cycle: duty cycle of the PWM signal (in nanoseconds)
+ */
+struct pwm_capture {
+	unsigned int period;
+	unsigned int duty_cycle;
+};
+
 #if IS_ENABLED(CONFIG_PWM)
 /* PWM user APIs */
 struct pwm_device *pwm_request(int pwm_id, const char *label);
@@ -322,6 +337,8 @@ static inline void pwm_disable(struct pwm_device *pwm)
 
 
 /* PWM provider APIs */
+int pwm_capture(struct pwm_device *pwm, struct pwm_capture *result,
+		unsigned long timeout);
 int pwm_set_chip_data(struct pwm_device *pwm, void *data);
 void *pwm_get_chip_data(struct pwm_device *pwm);
 
@@ -373,6 +390,13 @@ static inline int pwm_config(struct pwm_device *pwm, int duty_ns,
 	return -EINVAL;
 }
 
+static inline int pwm_capture(struct pwm_device *pwm,
+			      struct pwm_capture *result,
+			      unsigned long timeout)
+{
+	return -EINVAL;
+}
+
 static inline int pwm_set_polarity(struct pwm_device *pwm,
 				   enum pwm_polarity polarity)
 {

commit ef2bf4997f7da6efa8540d9cf726c44bf2b863af
Author: Brian Norris <briannorris@chromium.org>
Date:   Fri May 27 09:45:49 2016 -0700

    pwm: Improve args checking in pwm_apply_state()
    
    It seems like in the process of refactoring pwm_config() to utilize the
    newly-introduced pwm_apply_state() API, some args/bounds checking was
    dropped.
    
    In particular, I noted that we are now allowing invalid period
    selections, e.g.:
    
      # echo 1 > /sys/class/pwm/pwmchip0/export
      # cat /sys/class/pwm/pwmchip0/pwm1/period
      100
      # echo 101 > /sys/class/pwm/pwmchip0/pwm1/duty_cycle
      [... driver may or may not reject the value, or trigger some logic bug ...]
    
    It's better to see:
    
      # echo 1 > /sys/class/pwm/pwmchip0/export
      # cat /sys/class/pwm/pwmchip0/pwm1/period
      100
      # echo 101 > /sys/class/pwm/pwmchip0/pwm1/duty_cycle
      -bash: echo: write error: Invalid argument
    
    This patch reintroduces some bounds checks in both pwm_config() (for its
    signed parameters; we don't want to convert negative values into large
    unsigned values) and in pwm_apply_state() (which fix the above described
    behavior, as well as other potential API misuses).
    
    Fixes: 5ec803edcb70 ("pwm: Add core infrastructure to allow atomic updates")
    Signed-off-by: Brian Norris <briannorris@chromium.org>
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 17018f3c066e..908b67c847cd 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -235,6 +235,9 @@ static inline int pwm_config(struct pwm_device *pwm, int duty_ns,
 	if (!pwm)
 		return -EINVAL;
 
+	if (duty_ns < 0 || period_ns < 0)
+		return -EINVAL;
+
 	pwm_get_state(pwm, &state);
 	if (state.duty_cycle == duty_ns && state.period == period_ns)
 		return 0;

commit 5ec803edcb703fe379836f13560b79dfac79b01d
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Thu Apr 14 21:17:41 2016 +0200

    pwm: Add core infrastructure to allow atomic updates
    
    Add an ->apply() method to the pwm_ops struct to allow PWM drivers to
    implement atomic updates. This method is preferred over the ->enable(),
    ->disable() and ->config() methods if available.
    
    Add the pwm_apply_state() function to the PWM user API.
    
    Note that the pwm_apply_state() does not guarantee the atomicity of the
    update operation, it all depends on the availability and implementation
    of the ->apply() method.
    
    pwm_enable/disable/set_polarity/config() are now implemented as wrappers
    around the pwm_apply_state() function.
    
    pwm_adjust_config() is allowing smooth handover between the bootloader
    and the kernel. This function tries to adapt the current PWM state to
    the PWM arguments coming from a PWM lookup table or a DT definition
    without changing the duty_cycle/period proportion.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    [thierry.reding@gmail.com: fix a couple of typos]
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 33f8decd9f38..17018f3c066e 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -5,59 +5,7 @@
 #include <linux/mutex.h>
 #include <linux/of.h>
 
-struct pwm_device;
 struct seq_file;
-
-#if IS_ENABLED(CONFIG_PWM)
-/*
- * pwm_request - request a PWM device
- */
-struct pwm_device *pwm_request(int pwm_id, const char *label);
-
-/*
- * pwm_free - free a PWM device
- */
-void pwm_free(struct pwm_device *pwm);
-
-/*
- * pwm_config - change a PWM device configuration
- */
-int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns);
-
-/*
- * pwm_enable - start a PWM output toggling
- */
-int pwm_enable(struct pwm_device *pwm);
-
-/*
- * pwm_disable - stop a PWM output toggling
- */
-void pwm_disable(struct pwm_device *pwm);
-#else
-static inline struct pwm_device *pwm_request(int pwm_id, const char *label)
-{
-	return ERR_PTR(-ENODEV);
-}
-
-static inline void pwm_free(struct pwm_device *pwm)
-{
-}
-
-static inline int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns)
-{
-	return -EINVAL;
-}
-
-static inline int pwm_enable(struct pwm_device *pwm)
-{
-	return -EINVAL;
-}
-
-static inline void pwm_disable(struct pwm_device *pwm)
-{
-}
-#endif
-
 struct pwm_chip;
 
 /**
@@ -184,11 +132,6 @@ static inline unsigned int pwm_get_duty_cycle(const struct pwm_device *pwm)
 	return state.duty_cycle;
 }
 
-/*
- * pwm_set_polarity - configure the polarity of a PWM signal
- */
-int pwm_set_polarity(struct pwm_device *pwm, enum pwm_polarity polarity);
-
 static inline enum pwm_polarity pwm_get_polarity(const struct pwm_device *pwm)
 {
 	struct pwm_state state;
@@ -204,34 +147,6 @@ static inline void pwm_get_args(const struct pwm_device *pwm,
 	*args = pwm->args;
 }
 
-static inline void pwm_apply_args(struct pwm_device *pwm)
-{
-	/*
-	 * PWM users calling pwm_apply_args() expect to have a fresh config
-	 * where the polarity and period are set according to pwm_args info.
-	 * The problem is, polarity can only be changed when the PWM is
-	 * disabled.
-	 *
-	 * PWM drivers supporting hardware readout may declare the PWM device
-	 * as enabled, and prevent polarity setting, which changes from the
-	 * existing behavior, where all PWM devices are declared as disabled
-	 * at startup (even if they are actually enabled), thus authorizing
-	 * polarity setting.
-	 *
-	 * Instead of setting ->enabled to false, we call pwm_disable()
-	 * before pwm_set_polarity() to ensure that everything is configured
-	 * as expected, and the PWM is really disabled when the user request
-	 * it.
-	 *
-	 * Note that PWM users requiring a smooth handover between the
-	 * bootloader and the kernel (like critical regulators controlled by
-	 * PWM devices) will have to switch to the atomic API and avoid calling
-	 * pwm_apply_args().
-	 */
-	pwm_disable(pwm);
-	pwm_set_polarity(pwm, pwm->args.polarity);
-}
-
 /**
  * struct pwm_ops - PWM controller operations
  * @request: optional hook for requesting a PWM
@@ -240,6 +155,10 @@ static inline void pwm_apply_args(struct pwm_device *pwm)
  * @set_polarity: configure the polarity of this PWM
  * @enable: enable PWM output toggling
  * @disable: disable PWM output toggling
+ * @apply: atomically apply a new PWM config. The state argument
+ *	   should be adjusted with the real hardware config (if the
+ *	   approximate the period or duty_cycle value, state should
+ *	   reflect it)
  * @get_state: get the current PWM state. This function is only
  *	       called once per PWM device when the PWM chip is
  *	       registered.
@@ -255,6 +174,8 @@ struct pwm_ops {
 			    enum pwm_polarity polarity);
 	int (*enable)(struct pwm_chip *chip, struct pwm_device *pwm);
 	void (*disable)(struct pwm_chip *chip, struct pwm_device *pwm);
+	int (*apply)(struct pwm_chip *chip, struct pwm_device *pwm,
+		     struct pwm_state *state);
 	void (*get_state)(struct pwm_chip *chip, struct pwm_device *pwm,
 			  struct pwm_state *state);
 #ifdef CONFIG_DEBUG_FS
@@ -292,6 +213,115 @@ struct pwm_chip {
 };
 
 #if IS_ENABLED(CONFIG_PWM)
+/* PWM user APIs */
+struct pwm_device *pwm_request(int pwm_id, const char *label);
+void pwm_free(struct pwm_device *pwm);
+int pwm_apply_state(struct pwm_device *pwm, struct pwm_state *state);
+int pwm_adjust_config(struct pwm_device *pwm);
+
+/**
+ * pwm_config() - change a PWM device configuration
+ * @pwm: PWM device
+ * @duty_ns: "on" time (in nanoseconds)
+ * @period_ns: duration (in nanoseconds) of one cycle
+ *
+ * Returns: 0 on success or a negative error code on failure.
+ */
+static inline int pwm_config(struct pwm_device *pwm, int duty_ns,
+			     int period_ns)
+{
+	struct pwm_state state;
+
+	if (!pwm)
+		return -EINVAL;
+
+	pwm_get_state(pwm, &state);
+	if (state.duty_cycle == duty_ns && state.period == period_ns)
+		return 0;
+
+	state.duty_cycle = duty_ns;
+	state.period = period_ns;
+	return pwm_apply_state(pwm, &state);
+}
+
+/**
+ * pwm_set_polarity() - configure the polarity of a PWM signal
+ * @pwm: PWM device
+ * @polarity: new polarity of the PWM signal
+ *
+ * Note that the polarity cannot be configured while the PWM device is
+ * enabled.
+ *
+ * Returns: 0 on success or a negative error code on failure.
+ */
+static inline int pwm_set_polarity(struct pwm_device *pwm,
+				   enum pwm_polarity polarity)
+{
+	struct pwm_state state;
+
+	if (!pwm)
+		return -EINVAL;
+
+	pwm_get_state(pwm, &state);
+	if (state.polarity == polarity)
+		return 0;
+
+	/*
+	 * Changing the polarity of a running PWM without adjusting the
+	 * dutycycle/period value is a bit risky (can introduce glitches).
+	 * Return -EBUSY in this case.
+	 * Note that this is allowed when using pwm_apply_state() because
+	 * the user specifies all the parameters.
+	 */
+	if (state.enabled)
+		return -EBUSY;
+
+	state.polarity = polarity;
+	return pwm_apply_state(pwm, &state);
+}
+
+/**
+ * pwm_enable() - start a PWM output toggling
+ * @pwm: PWM device
+ *
+ * Returns: 0 on success or a negative error code on failure.
+ */
+static inline int pwm_enable(struct pwm_device *pwm)
+{
+	struct pwm_state state;
+
+	if (!pwm)
+		return -EINVAL;
+
+	pwm_get_state(pwm, &state);
+	if (state.enabled)
+		return 0;
+
+	state.enabled = true;
+	return pwm_apply_state(pwm, &state);
+}
+
+/**
+ * pwm_disable() - stop a PWM output toggling
+ * @pwm: PWM device
+ */
+static inline void pwm_disable(struct pwm_device *pwm)
+{
+	struct pwm_state state;
+
+	if (!pwm)
+		return;
+
+	pwm_get_state(pwm, &state);
+	if (!state.enabled)
+		return;
+
+	state.enabled = false;
+	pwm_apply_state(pwm, &state);
+}
+
+
+/* PWM provider APIs */
 int pwm_set_chip_data(struct pwm_device *pwm, void *data);
 void *pwm_get_chip_data(struct pwm_device *pwm);
 
@@ -317,6 +347,47 @@ void devm_pwm_put(struct device *dev, struct pwm_device *pwm);
 
 bool pwm_can_sleep(struct pwm_device *pwm);
 #else
+static inline struct pwm_device *pwm_request(int pwm_id, const char *label)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline void pwm_free(struct pwm_device *pwm)
+{
+}
+
+static inline int pwm_apply_state(struct pwm_device *pwm,
+				  const struct pwm_state *state)
+{
+	return -ENOTSUPP;
+}
+
+static inline int pwm_adjust_config(struct pwm_device *pwm)
+{
+	return -ENOTSUPP;
+}
+
+static inline int pwm_config(struct pwm_device *pwm, int duty_ns,
+			     int period_ns)
+{
+	return -EINVAL;
+}
+
+static inline int pwm_set_polarity(struct pwm_device *pwm,
+				   enum pwm_polarity polarity)
+{
+	return -ENOTSUPP;
+}
+
+static inline int pwm_enable(struct pwm_device *pwm)
+{
+	return -EINVAL;
+}
+
+static inline void pwm_disable(struct pwm_device *pwm)
+{
+}
+
 static inline int pwm_set_chip_data(struct pwm_device *pwm, void *data)
 {
 	return -EINVAL;
@@ -388,6 +459,34 @@ static inline bool pwm_can_sleep(struct pwm_device *pwm)
 }
 #endif
 
+static inline void pwm_apply_args(struct pwm_device *pwm)
+{
+	/*
+	 * PWM users calling pwm_apply_args() expect to have a fresh config
+	 * where the polarity and period are set according to pwm_args info.
+	 * The problem is, polarity can only be changed when the PWM is
+	 * disabled.
+	 *
+	 * PWM drivers supporting hardware readout may declare the PWM device
+	 * as enabled, and prevent polarity setting, which changes from the
+	 * existing behavior, where all PWM devices are declared as disabled
+	 * at startup (even if they are actually enabled), thus authorizing
+	 * polarity setting.
+	 *
+	 * Instead of setting ->enabled to false, we call pwm_disable()
+	 * before pwm_set_polarity() to ensure that everything is configured
+	 * as expected, and the PWM is really disabled when the user request
+	 * it.
+	 *
+	 * Note that PWM users requiring a smooth handover between the
+	 * bootloader and the kernel (like critical regulators controlled by
+	 * PWM devices) will have to switch to the atomic API and avoid calling
+	 * pwm_apply_args().
+	 */
+	pwm_disable(pwm);
+	pwm_set_polarity(pwm, pwm->args.polarity);
+}
+
 struct pwm_lookup {
 	struct list_head list;
 	const char *provider;

commit 15fa8a43c147213a9563903c87b29671035eb6e8
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Thu Apr 14 21:17:40 2016 +0200

    pwm: Add hardware readout infrastructure
    
    Add a ->get_state() function to the pwm_ops struct to let PWM drivers
    initialize the PWM state attached to a PWM device.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 150563a806d6..33f8decd9f38 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -206,6 +206,29 @@ static inline void pwm_get_args(const struct pwm_device *pwm,
 
 static inline void pwm_apply_args(struct pwm_device *pwm)
 {
+	/*
+	 * PWM users calling pwm_apply_args() expect to have a fresh config
+	 * where the polarity and period are set according to pwm_args info.
+	 * The problem is, polarity can only be changed when the PWM is
+	 * disabled.
+	 *
+	 * PWM drivers supporting hardware readout may declare the PWM device
+	 * as enabled, and prevent polarity setting, which changes from the
+	 * existing behavior, where all PWM devices are declared as disabled
+	 * at startup (even if they are actually enabled), thus authorizing
+	 * polarity setting.
+	 *
+	 * Instead of setting ->enabled to false, we call pwm_disable()
+	 * before pwm_set_polarity() to ensure that everything is configured
+	 * as expected, and the PWM is really disabled when the user request
+	 * it.
+	 *
+	 * Note that PWM users requiring a smooth handover between the
+	 * bootloader and the kernel (like critical regulators controlled by
+	 * PWM devices) will have to switch to the atomic API and avoid calling
+	 * pwm_apply_args().
+	 */
+	pwm_disable(pwm);
 	pwm_set_polarity(pwm, pwm->args.polarity);
 }
 
@@ -217,6 +240,9 @@ static inline void pwm_apply_args(struct pwm_device *pwm)
  * @set_polarity: configure the polarity of this PWM
  * @enable: enable PWM output toggling
  * @disable: disable PWM output toggling
+ * @get_state: get the current PWM state. This function is only
+ *	       called once per PWM device when the PWM chip is
+ *	       registered.
  * @dbg_show: optional routine to show contents in debugfs
  * @owner: helps prevent removal of modules exporting active PWMs
  */
@@ -229,6 +255,8 @@ struct pwm_ops {
 			    enum pwm_polarity polarity);
 	int (*enable)(struct pwm_chip *chip, struct pwm_device *pwm);
 	void (*disable)(struct pwm_chip *chip, struct pwm_device *pwm);
+	void (*get_state)(struct pwm_chip *chip, struct pwm_device *pwm,
+			  struct pwm_state *state);
 #ifdef CONFIG_DEBUG_FS
 	void (*dbg_show)(struct pwm_chip *chip, struct seq_file *s);
 #endif

commit 09a7e4a3d9fcb95ade2cb02167e85fbeb8315ce0
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Thu Apr 14 21:17:39 2016 +0200

    pwm: Move the enabled/disabled info into pwm_state
    
    Prepare the transition to PWM atomic update by moving the enabled and
    disabled state into the pwm_state struct. This way we can easily update
    the whole PWM state by copying the new state in the ->state field.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 51d4005418f9..150563a806d6 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -94,8 +94,7 @@ struct pwm_args {
 
 enum {
 	PWMF_REQUESTED = 1 << 0,
-	PWMF_ENABLED = 1 << 1,
-	PWMF_EXPORTED = 1 << 2,
+	PWMF_EXPORTED = 1 << 1,
 };
 
 /*
@@ -103,11 +102,13 @@ enum {
  * @period: PWM period (in nanoseconds)
  * @duty_cycle: PWM duty cycle (in nanoseconds)
  * @polarity: PWM polarity
+ * @enabled: PWM enabled status
  */
 struct pwm_state {
 	unsigned int period;
 	unsigned int duty_cycle;
 	enum pwm_polarity polarity;
+	bool enabled;
 };
 
 /**
@@ -146,7 +147,11 @@ static inline void pwm_get_state(const struct pwm_device *pwm,
 
 static inline bool pwm_is_enabled(const struct pwm_device *pwm)
 {
-	return test_bit(PWMF_ENABLED, &pwm->flags);
+	struct pwm_state state;
+
+	pwm_get_state(pwm, &state);
+
+	return state.enabled;
 }
 
 static inline void pwm_set_period(struct pwm_device *pwm, unsigned int period)

commit 43a276b003ed2e03de9d94b02a1ba49c1849b931
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Thu Apr 14 21:17:38 2016 +0200

    pwm: Introduce the pwm_state concept
    
    The PWM state, represented by its period, duty_cycle and polarity is
    currently directly stored in the PWM device. Declare a pwm_state
    structure embedding those field so that we can later use this struct
    to atomically update all the PWM parameters at once.
    
    All pwm_get_xxx() helpers are now implemented as wrappers around
    pwm_get_state().
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 7caf549f720e..51d4005418f9 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -98,6 +98,18 @@ enum {
 	PWMF_EXPORTED = 1 << 2,
 };
 
+/*
+ * struct pwm_state - state of a PWM channel
+ * @period: PWM period (in nanoseconds)
+ * @duty_cycle: PWM duty cycle (in nanoseconds)
+ * @polarity: PWM polarity
+ */
+struct pwm_state {
+	unsigned int period;
+	unsigned int duty_cycle;
+	enum pwm_polarity polarity;
+};
+
 /**
  * struct pwm_device - PWM channel object
  * @label: name of the PWM device
@@ -106,10 +118,8 @@ enum {
  * @pwm: global index of the PWM device
  * @chip: PWM chip providing this PWM device
  * @chip_data: chip-private data associated with the PWM device
- * @period: period of the PWM signal (in nanoseconds)
- * @duty_cycle: duty cycle of the PWM signal (in nanoseconds)
- * @polarity: polarity of the PWM signal
  * @args: PWM arguments
+ * @state: curent PWM channel state
  */
 struct pwm_device {
 	const char *label;
@@ -119,13 +129,21 @@ struct pwm_device {
 	struct pwm_chip *chip;
 	void *chip_data;
 
-	unsigned int period;
-	unsigned int duty_cycle;
-	enum pwm_polarity polarity;
-
 	struct pwm_args args;
+	struct pwm_state state;
 };
 
+/**
+ * pwm_get_state() - retrieve the current PWM state
+ * @pwm: PWM device
+ * @state: state to fill with the current PWM state
+ */
+static inline void pwm_get_state(const struct pwm_device *pwm,
+				 struct pwm_state *state)
+{
+	*state = pwm->state;
+}
+
 static inline bool pwm_is_enabled(const struct pwm_device *pwm)
 {
 	return test_bit(PWMF_ENABLED, &pwm->flags);
@@ -134,23 +152,31 @@ static inline bool pwm_is_enabled(const struct pwm_device *pwm)
 static inline void pwm_set_period(struct pwm_device *pwm, unsigned int period)
 {
 	if (pwm)
-		pwm->period = period;
+		pwm->state.period = period;
 }
 
 static inline unsigned int pwm_get_period(const struct pwm_device *pwm)
 {
-	return pwm ? pwm->period : 0;
+	struct pwm_state state;
+
+	pwm_get_state(pwm, &state);
+
+	return state.period;
 }
 
 static inline void pwm_set_duty_cycle(struct pwm_device *pwm, unsigned int duty)
 {
 	if (pwm)
-		pwm->duty_cycle = duty;
+		pwm->state.duty_cycle = duty;
 }
 
 static inline unsigned int pwm_get_duty_cycle(const struct pwm_device *pwm)
 {
-	return pwm ? pwm->duty_cycle : 0;
+	struct pwm_state state;
+
+	pwm_get_state(pwm, &state);
+
+	return state.duty_cycle;
 }
 
 /*
@@ -160,7 +186,11 @@ int pwm_set_polarity(struct pwm_device *pwm, enum pwm_polarity polarity);
 
 static inline enum pwm_polarity pwm_get_polarity(const struct pwm_device *pwm)
 {
-	return pwm ? pwm->polarity : PWM_POLARITY_NORMAL;
+	struct pwm_state state;
+
+	pwm_get_state(pwm, &state);
+
+	return state.polarity;
 }
 
 static inline void pwm_get_args(const struct pwm_device *pwm,

commit a8c3862551e063344f80c3e05d595f9d8836f355
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Thu Apr 14 21:17:37 2016 +0200

    pwm: Keep PWM state in sync with hardware state
    
    Before the introduction of pwm_args, the core was resetting the PWM
    period and polarity states to the reference values (those provided
    through the DT, a PWM lookup table or hardcoded in the driver).
    
    Now that all PWM users are correctly using pwm_args to configure their
    PWM device, we can safely remove the pwm_apply_args() call in pwm_get()
    and of_pwm_get().
    
    We can also get rid of the pwm_set_period() call in pwm_apply_args(),
    because PWM users are now directly using pargs->period instead of
    pwm_get_period(). By doing that we avoid messing with the current PWM
    period.
    
    The only remaining bit in pwm_apply_args() is the initial polarity
    setting, and it should go away when all PWM users have been patched to
    use the atomic API (with this API the polarity will be set along with
    other PWM arguments when configuring the PWM).
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index d2e7430ccedb..7caf549f720e 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -171,7 +171,6 @@ static inline void pwm_get_args(const struct pwm_device *pwm,
 
 static inline void pwm_apply_args(struct pwm_device *pwm)
 {
-	pwm_set_period(pwm, pwm->args.period);
 	pwm_set_polarity(pwm, pwm->args.polarity);
 }
 

commit 459a25afe97cb3d7f978b90c881f4d7aac8fb755
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Wed Mar 30 22:03:27 2016 +0200

    pwm: Get rid of pwm->lock
    
    PWM devices are not protected against concurrent accesses. The lock in
    struct pwm_device might let PWM users think it is, but it's actually
    only protecting the enabled state.
    
    Removing this lock should be fine as long as all PWM users are aware
    that accesses to the PWM device have to be serialized, which seems to be
    the case for all of them except the sysfs interface. Patch the sysfs
    code by adding a lock to the pwm_export struct and making sure it's
    taken for all relevant accesses to the exported PWM device.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index b78d27c42629..d2e7430ccedb 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -106,7 +106,6 @@ enum {
  * @pwm: global index of the PWM device
  * @chip: PWM chip providing this PWM device
  * @chip_data: chip-private data associated with the PWM device
- * @lock: used to serialize accesses to the PWM device where necessary
  * @period: period of the PWM signal (in nanoseconds)
  * @duty_cycle: duty cycle of the PWM signal (in nanoseconds)
  * @polarity: polarity of the PWM signal
@@ -119,7 +118,6 @@ struct pwm_device {
 	unsigned int pwm;
 	struct pwm_chip *chip;
 	void *chip_data;
-	struct mutex lock;
 
 	unsigned int period;
 	unsigned int duty_cycle;

commit e39c0df1be5a97e0910b09af1530bdf3de057a06
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Thu Apr 14 21:17:21 2016 +0200

    pwm: Introduce the pwm_args concept
    
    Currently the PWM core mixes the current PWM state with the per-platform
    reference config (specified through the PWM lookup table, DT definition
    or directly hardcoded in PWM drivers).
    
    Create a struct pwm_args to store this reference configuration, so that
    PWM users can differentiate between the current and reference
    configurations.
    
    Patch all places where pwm->args should be initialized. We keep the
    pwm_set_polarity/period() calls until all PWM users are patched to use
    pwm_args instead of pwm_get_period/polarity().
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    [thierry.reding@gmail.com: reword kerneldoc comments]
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index cfc3ed46cad2..b78d27c42629 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -74,6 +74,24 @@ enum pwm_polarity {
 	PWM_POLARITY_INVERSED,
 };
 
+/**
+ * struct pwm_args - board-dependent PWM arguments
+ * @period: reference period
+ * @polarity: reference polarity
+ *
+ * This structure describes board-dependent arguments attached to a PWM
+ * device. These arguments are usually retrieved from the PWM lookup table or
+ * device tree.
+ *
+ * Do not confuse this with the PWM state: PWM arguments represent the initial
+ * configuration that users want to use on this PWM device rather than the
+ * current PWM hardware state.
+ */
+struct pwm_args {
+	unsigned int period;
+	enum pwm_polarity polarity;
+};
+
 enum {
 	PWMF_REQUESTED = 1 << 0,
 	PWMF_ENABLED = 1 << 1,
@@ -92,6 +110,7 @@ enum {
  * @period: period of the PWM signal (in nanoseconds)
  * @duty_cycle: duty cycle of the PWM signal (in nanoseconds)
  * @polarity: polarity of the PWM signal
+ * @args: PWM arguments
  */
 struct pwm_device {
 	const char *label;
@@ -105,6 +124,8 @@ struct pwm_device {
 	unsigned int period;
 	unsigned int duty_cycle;
 	enum pwm_polarity polarity;
+
+	struct pwm_args args;
 };
 
 static inline bool pwm_is_enabled(const struct pwm_device *pwm)
@@ -144,6 +165,18 @@ static inline enum pwm_polarity pwm_get_polarity(const struct pwm_device *pwm)
 	return pwm ? pwm->polarity : PWM_POLARITY_NORMAL;
 }
 
+static inline void pwm_get_args(const struct pwm_device *pwm,
+				struct pwm_args *args)
+{
+	*args = pwm->args;
+}
+
+static inline void pwm_apply_args(struct pwm_device *pwm)
+{
+	pwm_set_period(pwm, pwm->args.period);
+	pwm_set_polarity(pwm, pwm->args.polarity);
+}
+
 /**
  * struct pwm_ops - PWM controller operations
  * @request: optional hook for requesting a PWM

commit d1cd21427747f15920cd726f5f67a07880e7dee4
Author: Jonathan Richardson <jonathar@broadcom.com>
Date:   Fri Oct 16 17:40:58 2015 -0700

    pwm: Set enable state properly on failed call to enable
    
    The pwm_enable() function didn't clear the enabled bit if a call to the
    driver's ->enable() callback returned an error. The result was that the
    state of the PWM core was wrong. Clearing the bit when enable returns
    an error ensures the state is properly set.
    
    Tested-by: Jonathan Richardson <jonathar@broadcom.com>
    Reviewed-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Jonathan Richardson <jonathar@broadcom.com>
    [thierry.reding@gmail.com: add missing kerneldoc for the lock]
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index d681f6875aef..cfc3ed46cad2 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -2,6 +2,7 @@
 #define __LINUX_PWM_H
 
 #include <linux/err.h>
+#include <linux/mutex.h>
 #include <linux/of.h>
 
 struct pwm_device;
@@ -87,6 +88,7 @@ enum {
  * @pwm: global index of the PWM device
  * @chip: PWM chip providing this PWM device
  * @chip_data: chip-private data associated with the PWM device
+ * @lock: used to serialize accesses to the PWM device where necessary
  * @period: period of the PWM signal (in nanoseconds)
  * @duty_cycle: duty cycle of the PWM signal (in nanoseconds)
  * @polarity: polarity of the PWM signal
@@ -98,6 +100,7 @@ struct pwm_device {
 	unsigned int pwm;
 	struct pwm_chip *chip;
 	void *chip_data;
+	struct mutex lock;
 
 	unsigned int period;
 	unsigned int duty_cycle;

commit 048838027667872a75d3af40c51a22088bafd968
Author: Thierry Reding <thierry.reding@gmail.com>
Date:   Mon Jul 27 11:58:32 2015 +0200

    pwm: Clean up kerneldoc
    
    Clean up kerneldoc in preparation for including the PWM documentation in
    DocBook.
    
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 7c4b6f35241d..d681f6875aef 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -79,6 +79,18 @@ enum {
 	PWMF_EXPORTED = 1 << 2,
 };
 
+/**
+ * struct pwm_device - PWM channel object
+ * @label: name of the PWM device
+ * @flags: flags associated with the PWM device
+ * @hwpwm: per-chip relative index of the PWM device
+ * @pwm: global index of the PWM device
+ * @chip: PWM chip providing this PWM device
+ * @chip_data: chip-private data associated with the PWM device
+ * @period: period of the PWM signal (in nanoseconds)
+ * @duty_cycle: duty cycle of the PWM signal (in nanoseconds)
+ * @polarity: polarity of the PWM signal
+ */
 struct pwm_device {
 	const char *label;
 	unsigned long flags;
@@ -163,6 +175,8 @@ struct pwm_ops {
  * @base: number of first PWM controlled by this chip
  * @npwm: number of PWMs controlled by this chip
  * @pwms: array of PWM devices allocated by the framework
+ * @of_xlate: request a PWM device given a device tree PWM specifier
+ * @of_pwm_n_cells: number of cells expected in the device tree PWM specifier
  * @can_sleep: must be true if the .config(), .enable() or .disable()
  *             operations may sleep
  */

commit 6bc7064a69fc5b1f774771ea9e2c50e497311766
Author: Thierry Reding <thierry.reding@gmail.com>
Date:   Mon Jul 27 11:57:28 2015 +0200

    pwm: Remove useless whitespace
    
    Remove useless tabs used for padding in structure definitions as well as
    some blank lines.
    
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 6f286df30021..7c4b6f35241d 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -80,16 +80,16 @@ enum {
 };
 
 struct pwm_device {
-	const char		*label;
-	unsigned long		flags;
-	unsigned int		hwpwm;
-	unsigned int		pwm;
-	struct pwm_chip		*chip;
-	void			*chip_data;
-
-	unsigned int		period; 	/* in nanoseconds */
-	unsigned int		duty_cycle;	/* in nanoseconds */
-	enum pwm_polarity	polarity;
+	const char *label;
+	unsigned long flags;
+	unsigned int hwpwm;
+	unsigned int pwm;
+	struct pwm_chip *chip;
+	void *chip_data;
+
+	unsigned int period;
+	unsigned int duty_cycle;
+	enum pwm_polarity polarity;
 };
 
 static inline bool pwm_is_enabled(const struct pwm_device *pwm)
@@ -141,25 +141,18 @@ static inline enum pwm_polarity pwm_get_polarity(const struct pwm_device *pwm)
  * @owner: helps prevent removal of modules exporting active PWMs
  */
 struct pwm_ops {
-	int			(*request)(struct pwm_chip *chip,
-					   struct pwm_device *pwm);
-	void			(*free)(struct pwm_chip *chip,
-					struct pwm_device *pwm);
-	int			(*config)(struct pwm_chip *chip,
-					  struct pwm_device *pwm,
-					  int duty_ns, int period_ns);
-	int			(*set_polarity)(struct pwm_chip *chip,
-					  struct pwm_device *pwm,
-					  enum pwm_polarity polarity);
-	int			(*enable)(struct pwm_chip *chip,
-					  struct pwm_device *pwm);
-	void			(*disable)(struct pwm_chip *chip,
-					   struct pwm_device *pwm);
+	int (*request)(struct pwm_chip *chip, struct pwm_device *pwm);
+	void (*free)(struct pwm_chip *chip, struct pwm_device *pwm);
+	int (*config)(struct pwm_chip *chip, struct pwm_device *pwm,
+		      int duty_ns, int period_ns);
+	int (*set_polarity)(struct pwm_chip *chip, struct pwm_device *pwm,
+			    enum pwm_polarity polarity);
+	int (*enable)(struct pwm_chip *chip, struct pwm_device *pwm);
+	void (*disable)(struct pwm_chip *chip, struct pwm_device *pwm);
 #ifdef CONFIG_DEBUG_FS
-	void			(*dbg_show)(struct pwm_chip *chip,
-					    struct seq_file *s);
+	void (*dbg_show)(struct pwm_chip *chip, struct seq_file *s);
 #endif
-	struct module		*owner;
+	struct module *owner;
 };
 
 /**
@@ -174,18 +167,18 @@ struct pwm_ops {
  *             operations may sleep
  */
 struct pwm_chip {
-	struct device		*dev;
-	struct list_head	list;
-	const struct pwm_ops	*ops;
-	int			base;
-	unsigned int		npwm;
-
-	struct pwm_device	*pwms;
-
-	struct pwm_device *	(*of_xlate)(struct pwm_chip *pc,
-					    const struct of_phandle_args *args);
-	unsigned int		of_pwm_n_cells;
-	bool			can_sleep;
+	struct device *dev;
+	struct list_head list;
+	const struct pwm_ops *ops;
+	int base;
+	unsigned int npwm;
+
+	struct pwm_device *pwms;
+
+	struct pwm_device * (*of_xlate)(struct pwm_chip *pc,
+					const struct of_phandle_args *args);
+	unsigned int of_pwm_n_cells;
+	bool can_sleep;
 };
 
 #if IS_ENABLED(CONFIG_PWM)

commit 011e76314818b6a24d5347b2d83b8a577e6aaae6
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Wed Jul 1 10:21:49 2015 +0200

    pwm: Add pwm_get_polarity() helper function
    
    Some drivers are directly accessing the ->polarity field in pwm_device.
    Add a helper to retrieve the current polarity so that we can easily move
    this field elsewhere (required to support atomic update).
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index d8f691339a45..6f286df30021 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -124,6 +124,11 @@ static inline unsigned int pwm_get_duty_cycle(const struct pwm_device *pwm)
  */
 int pwm_set_polarity(struct pwm_device *pwm, enum pwm_polarity polarity);
 
+static inline enum pwm_polarity pwm_get_polarity(const struct pwm_device *pwm)
+{
+	return pwm ? pwm->polarity : PWM_POLARITY_NORMAL;
+}
+
 /**
  * struct pwm_ops - PWM controller operations
  * @request: optional hook for requesting a PWM

commit a1cf42171a2e3c33cbc12bb037795caf0589149b
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Wed Jul 1 10:21:48 2015 +0200

    pwm: Constify PWM device where possible
    
    The PWM argument is not modified in PWM property accessors, make it a
    const argument so that the accessors can be used from sysfs.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index ec34f4d9a9ee..d8f691339a45 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -103,7 +103,7 @@ static inline void pwm_set_period(struct pwm_device *pwm, unsigned int period)
 		pwm->period = period;
 }
 
-static inline unsigned int pwm_get_period(struct pwm_device *pwm)
+static inline unsigned int pwm_get_period(const struct pwm_device *pwm)
 {
 	return pwm ? pwm->period : 0;
 }
@@ -114,7 +114,7 @@ static inline void pwm_set_duty_cycle(struct pwm_device *pwm, unsigned int duty)
 		pwm->duty_cycle = duty;
 }
 
-static inline unsigned int pwm_get_duty_cycle(struct pwm_device *pwm)
+static inline unsigned int pwm_get_duty_cycle(const struct pwm_device *pwm)
 {
 	return pwm ? pwm->duty_cycle : 0;
 }

commit 5c31252c4a86dc591c23f1a951edd52ad791ef0e
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Wed Jul 1 10:21:47 2015 +0200

    pwm: Add the pwm_is_enabled() helper
    
    Some PWM drivers are testing the PWMF_ENABLED flag. Create a helper
    function to hide the logic behind enabled test. This will allow us to
    smoothly move from the current approach to an atomic PWM update
    approach.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 36262d08a9da..ec34f4d9a9ee 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -92,6 +92,11 @@ struct pwm_device {
 	enum pwm_polarity	polarity;
 };
 
+static inline bool pwm_is_enabled(const struct pwm_device *pwm)
+{
+	return test_bit(PWMF_ENABLED, &pwm->flags);
+}
+
 static inline void pwm_set_period(struct pwm_device *pwm, unsigned int period)
 {
 	if (pwm)

commit b6a00fae9760a49114016e4764d09e522a5ba5b6
Author: Tim Kryger <tim.kryger@gmail.com>
Date:   Tue May 26 13:08:16 2015 -0700

    pwm: Add pwmchip_add_with_polarity() API
    
    Add a new function to register a PWM chip with channels that have their
    initial polarity as specified by an additional parameter. This benefits
    drivers of controllers that by default operate with inversed polarity
    by removing the need to modify the polarity during initialization.
    
    Signed-off-by: Tim Kryger <tim.kryger@gmail.com>
    Signed-off-by: Jonathan Richardson <jonathar@broadcom.com>
    [thierry.reding@gmail.com: export pwmchip_add_with_polarity()]
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index cfe2d8df5be0..36262d08a9da 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -182,6 +182,8 @@ struct pwm_chip {
 int pwm_set_chip_data(struct pwm_device *pwm, void *data);
 void *pwm_get_chip_data(struct pwm_device *pwm);
 
+int pwmchip_add_with_polarity(struct pwm_chip *chip,
+			      enum pwm_polarity polarity);
 int pwmchip_add(struct pwm_chip *chip);
 int pwmchip_remove(struct pwm_chip *chip);
 struct pwm_device *pwm_request_from_chip(struct pwm_chip *chip,
@@ -217,6 +219,11 @@ static inline int pwmchip_add(struct pwm_chip *chip)
 	return -EINVAL;
 }
 
+static inline int pwmchip_add_inversed(struct pwm_chip *chip)
+{
+	return -EINVAL;
+}
+
 static inline int pwmchip_remove(struct pwm_chip *chip)
 {
 	return -EINVAL;

commit efb0de55b6a2ec15fc424e660601f22ae2fa487a
Author: Shobhit Kumar <shobhit.kumar@intel.com>
Date:   Tue May 5 15:04:18 2015 +0530

    pwm: Add support to remove registered consumer lookup tables
    
    In case some drivers are unloading, they can remove lookup tables which
    they had registered during their load time to avoid redundant entries if
    loaded again.
    
    CC: Samuel Ortiz <sameo@linux.intel.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Alexandre Courbot <gnurou@gmail.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Signed-off-by: Shobhit Kumar <shobhit.kumar@intel.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index e90628cac8fa..cfe2d8df5be0 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -290,10 +290,15 @@ struct pwm_lookup {
 
 #if IS_ENABLED(CONFIG_PWM)
 void pwm_add_table(struct pwm_lookup *table, size_t num);
+void pwm_remove_table(struct pwm_lookup *table, size_t num);
 #else
 static inline void pwm_add_table(struct pwm_lookup *table, size_t num)
 {
 }
+
+static inline void pwm_remove_table(struct pwm_lookup *table, size_t num)
+{
+}
 #endif
 
 #ifdef CONFIG_PWM_SYSFS

commit 4284402924cc55e182008ca7e9d4fb1e891ff5ae
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Mon May 19 22:42:37 2014 +0200

    pwm: modify PWM_LOOKUP to initialize all struct pwm_lookup members
    
    Now that PWM_LOOKUP is not used anymore, modify it to initialize all the
    members of struct pwm_lookup.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 2f45e2fe5b93..e90628cac8fa 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -278,12 +278,14 @@ struct pwm_lookup {
 	enum pwm_polarity polarity;
 };
 
-#define PWM_LOOKUP(_provider, _index, _dev_id, _con_id)	\
+#define PWM_LOOKUP(_provider, _index, _dev_id, _con_id, _period, _polarity) \
 	{						\
 		.provider = _provider,			\
 		.index = _index,			\
 		.dev_id = _dev_id,			\
 		.con_id = _con_id,			\
+		.period = _period,			\
+		.polarity = _polarity			\
 	}
 
 #if IS_ENABLED(CONFIG_PWM)

commit 3796ce1d4d4b330a75005c5eda105603ce9d4071
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Mon May 19 22:42:32 2014 +0200

    pwm: add period and polarity to struct pwm_lookup
    
    Add period and polarity members to struct pwm_lookup so that platforms
    using the lookup table can be treated the same way as those using the
    device tree.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 4717f54051cb..2f45e2fe5b93 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -274,6 +274,8 @@ struct pwm_lookup {
 	unsigned int index;
 	const char *dev_id;
 	const char *con_id;
+	unsigned int period;
+	enum pwm_polarity polarity;
 };
 
 #define PWM_LOOKUP(_provider, _index, _dev_id, _con_id)	\

commit 557fe99d9d490fe01c7aa87494313078c4ff939c
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Fri Jan 24 08:54:16 2014 +0100

    pwm: Remove obsolete HAVE_PWM Kconfig symbol
    
    Before we had the PWM framework we used to have a barebone PWM api. The
    HAVE_PWM Kconfig symbol used to be selected by the PWM drivers to specify
    the PWM API is present in the kernel. Since the last legacy driver is gone
    the HAVE_PWM symbol can go aswell.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: linux-pwm@vger.kernel.orig
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index f0feafd184a0..4717f54051cb 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -7,7 +7,7 @@
 struct pwm_device;
 struct seq_file;
 
-#if IS_ENABLED(CONFIG_PWM) || IS_ENABLED(CONFIG_HAVE_PWM)
+#if IS_ENABLED(CONFIG_PWM)
 /*
  * pwm_request - request a PWM device
  */

commit 76abbdde2d95a3807d0dc6bf9f84d03d0dbd4f3d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 11 10:38:59 2013 -0700

    pwm: Add sysfs interface
    
    Add a simple sysfs interface to the generic PWM framework.
    
      /sys/class/pwm/
      `-- pwmchipN/           for each PWM chip
          |-- export          (w/o) ask the kernel to export a PWM channel
          |-- npwm            (r/o) number of PWM channels in this PWM chip
          |-- pwmX/           for each exported PWM channel
          |   |-- duty_cycle  (r/w) duty cycle (in nanoseconds)
          |   |-- enable      (r/w) enable/disable PWM
          |   |-- period      (r/w) period (in nanoseconds)
          |   `-- polarity    (r/w) polarity of PWM (normal/inversed)
          `-- unexport        (w/o) return a PWM channel to the kernel
    
    Based on work by Lars Poeschel.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Lars Poeschel <poeschel@lemonage.de>
    Cc: Ryan Mallon <rmallon@gmail.com>
    Cc: Rob Landley <rob@landley.net>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index a4df2042b79c..f0feafd184a0 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -76,6 +76,7 @@ enum pwm_polarity {
 enum {
 	PWMF_REQUESTED = 1 << 0,
 	PWMF_ENABLED = 1 << 1,
+	PWMF_EXPORTED = 1 << 2,
 };
 
 struct pwm_device {
@@ -86,7 +87,9 @@ struct pwm_device {
 	struct pwm_chip		*chip;
 	void			*chip_data;
 
-	unsigned int		period; /* in nanoseconds */
+	unsigned int		period; 	/* in nanoseconds */
+	unsigned int		duty_cycle;	/* in nanoseconds */
+	enum pwm_polarity	polarity;
 };
 
 static inline void pwm_set_period(struct pwm_device *pwm, unsigned int period)
@@ -100,6 +103,17 @@ static inline unsigned int pwm_get_period(struct pwm_device *pwm)
 	return pwm ? pwm->period : 0;
 }
 
+static inline void pwm_set_duty_cycle(struct pwm_device *pwm, unsigned int duty)
+{
+	if (pwm)
+		pwm->duty_cycle = duty;
+}
+
+static inline unsigned int pwm_get_duty_cycle(struct pwm_device *pwm)
+{
+	return pwm ? pwm->duty_cycle : 0;
+}
+
 /*
  * pwm_set_polarity - configure the polarity of a PWM signal
  */
@@ -278,4 +292,17 @@ static inline void pwm_add_table(struct pwm_lookup *table, size_t num)
 }
 #endif
 
+#ifdef CONFIG_PWM_SYSFS
+void pwmchip_sysfs_export(struct pwm_chip *chip);
+void pwmchip_sysfs_unexport(struct pwm_chip *chip);
+#else
+static inline void pwmchip_sysfs_export(struct pwm_chip *chip)
+{
+}
+
+static inline void pwmchip_sysfs_unexport(struct pwm_chip *chip)
+{
+}
+#endif /* CONFIG_PWM_SYSFS */
+
 #endif /* __LINUX_PWM_H */

commit 3eb05225ee8efb81fe50558f5f9d94e7477ade8f
Merge: ed5dc2372dba 30f786170352
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 26 09:34:29 2013 -0800

    Merge tag 'for-3.9-rc1' of git://gitorious.org/linux-pwm/linux-pwm
    
    Pull PWM changes from Thierry Reding:
     "A new driver has been added to support the PWM mode of the timer
      counter blocks found on Atmel AT91 SoCs.  The VT8500 driver now
      supports changing the PWM signal polarity and the TI drivers (EHRPWM
      and ECAP) gained suspend and resume functionality.
    
      User drivers can now query the core for whether access to a PWM device
      will sleep (if the PWM chip is on a slow bus such as I2C or SPI).
    
      The pwm-backlight driver now handles the backlight BL_CORE_FBBLANK
      state in addition to the FB layer's blanking states.
    
      To round things off, a few fixes and cleanups are also included"
    
    * tag 'for-3.9-rc1' of git://gitorious.org/linux-pwm/linux-pwm:
      pwm: twl: Use to_twl() instead of container_of()
      pwm: tegra: assume CONFIG_OF
      pwm_backlight: Validate dft_brightness in main probe function
      pwm: Export pwm_{set,get}_chip_data()
      pwm: Make Kconfig entries more consistent
      pwm: Add can_sleep property to drivers
      pwm: Add pwm_can_sleep() as exported API to users
      pwm-backlight: handle BL_CORE_FBBLANK state
      pwm: pwm-tiecap: Low power sleep support
      pwm: pwm-tiehrpwm: Low power sleep support
      pwm: pwm-tiehrpwm: Update the clock handling of pwm-tiehrpwm driver
      pwm: vt8500: Add polarity support
      pwm: vt8500: Register write busy test performed incorrectly
      pwm: atmel: add Timer Counter Block PWM driver

commit 261a5edd3ac77ecb4b33310a1dd1ed8d656f0569
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Fri Dec 21 01:43:59 2012 -0800

    pwm: Add devm_of_pwm_get() as exported API for users
    
    When booted with DT users can use devm version of of_pwm_get() to benefit
    from automatic resource release.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Thierry Reding <thierry.reding@avionic-design.de>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 76a1959f2b23..70655a205b74 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -179,6 +179,8 @@ struct pwm_device *of_pwm_get(struct device_node *np, const char *con_id);
 void pwm_put(struct pwm_device *pwm);
 
 struct pwm_device *devm_pwm_get(struct device *dev, const char *con_id);
+struct pwm_device *devm_of_pwm_get(struct device *dev, struct device_node *np,
+				   const char *con_id);
 void devm_pwm_put(struct device *dev, struct pwm_device *pwm);
 #else
 static inline int pwm_set_chip_data(struct pwm_device *pwm, void *data)
@@ -230,6 +232,13 @@ static inline struct pwm_device *devm_pwm_get(struct device *dev,
 	return ERR_PTR(-ENODEV);
 }
 
+static inline struct pwm_device *devm_of_pwm_get(struct device *dev,
+						 struct device_node *np,
+						 const char *con_id)
+{
+	return ERR_PTR(-ENODEV);
+}
+
 static inline void devm_pwm_put(struct device *dev, struct pwm_device *pwm)
 {
 }

commit 8eb9612799605a7988d1c97cdc5980a5b8f04c56
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Fri Dec 21 01:43:58 2012 -0800

    pwm: core: Rename of_pwm_request() to of_pwm_get() and export it
    
    Allow client driver to use of_pwm_get() to get the PWM they need. This
    is needed for drivers which handle more than one PWM separately, like
    leds-pwm driver, which have:
    
    pwmleds {
            compatible = "pwm-leds";
            kpad {
                    label = "omap4::keypad";
                    pwms = <&twl_pwm 0 7812500>;
                    max-brightness = <127>;
            };
    
            charging {
                    label = "omap4:green:chrg";
                    pwms = <&twl_pwmled 0 7812500>;
                    max-brightness = <255>;
            };
    };
    
    in the dts files.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Thierry Reding <thierry.reding@avionic-design.de>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index cc908a5396f8..76a1959f2b23 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -175,6 +175,7 @@ struct pwm_device *of_pwm_xlate_with_flags(struct pwm_chip *pc,
 		const struct of_phandle_args *args);
 
 struct pwm_device *pwm_get(struct device *dev, const char *con_id);
+struct pwm_device *of_pwm_get(struct device_node *np, const char *con_id);
 void pwm_put(struct pwm_device *pwm);
 
 struct pwm_device *devm_pwm_get(struct device *dev, const char *con_id);
@@ -213,6 +214,12 @@ static inline struct pwm_device *pwm_get(struct device *dev,
 	return ERR_PTR(-ENODEV);
 }
 
+static inline struct pwm_device *of_pwm_get(struct device_node *np,
+					    const char *con_id)
+{
+	return ERR_PTR(-ENODEV);
+}
+
 static inline void pwm_put(struct pwm_device *pwm)
 {
 }

commit d4c0c4705bef1134339b038872ece3705a2783e0
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Fri Dec 21 01:43:57 2012 -0800

    pwm: Correct parameter name in header for *pwm_get() functions
    
    To synchronize the header file definition and the actual code. In the code
    the consumer parameter is named as con_id, change the header file and replace
    consumer -> con_id in the parameter list.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Ackedy-by: Thierry Reding <thierry.reding@avionic-design.de>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 6d661f32e0e4..cc908a5396f8 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -174,10 +174,10 @@ struct pwm_device *pwm_request_from_chip(struct pwm_chip *chip,
 struct pwm_device *of_pwm_xlate_with_flags(struct pwm_chip *pc,
 		const struct of_phandle_args *args);
 
-struct pwm_device *pwm_get(struct device *dev, const char *consumer);
+struct pwm_device *pwm_get(struct device *dev, const char *con_id);
 void pwm_put(struct pwm_device *pwm);
 
-struct pwm_device *devm_pwm_get(struct device *dev, const char *consumer);
+struct pwm_device *devm_pwm_get(struct device *dev, const char *con_id);
 void devm_pwm_put(struct device *dev, struct pwm_device *pwm);
 #else
 static inline int pwm_set_chip_data(struct pwm_device *pwm, void *data)

commit 6e69ab1361c44e3ee1398158b56d114b1aef8179
Author: Florian Vaussard <florian.vaussard@epfl.ch>
Date:   Mon Jan 28 15:00:57 2013 +0100

    pwm: Add pwm_can_sleep() as exported API to users
    
    Calls to some external PWM chips can sleep. To help users,
    add pwm_can_sleep() API.
    
    Cc: Thierry Reding <thierry.reding@avionic-design.de>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Florian Vaussard <florian.vaussard@epfl.ch>
    Reviewed-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 6d661f32e0e4..3fef47733ea3 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -146,6 +146,8 @@ struct pwm_ops {
  * @base: number of first PWM controlled by this chip
  * @npwm: number of PWMs controlled by this chip
  * @pwms: array of PWM devices allocated by the framework
+ * @can_sleep: must be true if the .config(), .enable() or .disable()
+ *             operations may sleep
  */
 struct pwm_chip {
 	struct device		*dev;
@@ -159,6 +161,7 @@ struct pwm_chip {
 	struct pwm_device *	(*of_xlate)(struct pwm_chip *pc,
 					    const struct of_phandle_args *args);
 	unsigned int		of_pwm_n_cells;
+	bool			can_sleep;
 };
 
 #if IS_ENABLED(CONFIG_PWM)
@@ -179,6 +182,8 @@ void pwm_put(struct pwm_device *pwm);
 
 struct pwm_device *devm_pwm_get(struct device *dev, const char *consumer);
 void devm_pwm_put(struct device *dev, struct pwm_device *pwm);
+
+bool pwm_can_sleep(struct pwm_device *pwm);
 #else
 static inline int pwm_set_chip_data(struct pwm_device *pwm, void *data)
 {
@@ -226,6 +231,11 @@ static inline struct pwm_device *devm_pwm_get(struct device *dev,
 static inline void devm_pwm_put(struct device *dev, struct pwm_device *pwm)
 {
 }
+
+static inline bool pwm_can_sleep(struct pwm_device *pwm)
+{
+	return false;
+}
 #endif
 
 struct pwm_lookup {

commit 83af24027b3df1af5c5a9aa9adcdcfeb3429d3be
Author: Philip, Avinash <avinashphilip@ti.com>
Date:   Wed Nov 21 13:10:44 2012 +0530

    pwm: Device tree support for PWM polarity
    
    Add support for encoding PWM properties in bit encoded form with
    of_pwm_xlate_with_flags() function support. Platforms require platform
    specific PWM properties has to populate in 3rd cell of the pwm-specifier
    and PWM driver should also set .of_xlate support with this function.
    Currently PWM property polarity encoded in bit position 0 of the third
    cell in pwm-specifier.
    
    Signed-off-by: Philip, Avinash <avinashphilip@ti.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 112b31436848..6d661f32e0e4 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -171,6 +171,9 @@ struct pwm_device *pwm_request_from_chip(struct pwm_chip *chip,
 					 unsigned int index,
 					 const char *label);
 
+struct pwm_device *of_pwm_xlate_with_flags(struct pwm_chip *pc,
+		const struct of_phandle_args *args);
+
 struct pwm_device *pwm_get(struct device *dev, const char *consumer);
 void pwm_put(struct pwm_device *pwm);
 

commit 0bcf168b024871c64eb5df157739efd2ae9b0bdf
Author: Tushar Behera <tushar.behera@linaro.org>
Date:   Wed Sep 12 15:31:46 2012 +0530

    pwm: Fix compilation error when CONFIG_PWM is not defined
    
    Add dummy implemention of public symbols for compilation-safe inclusion
    of include/linux/pwm.h file when CONFIG_PWM is not defined.
    
    Reported-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Tushar Behera <tushar.behera@linaro.org>
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 40c764318957..112b31436848 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -1,11 +1,13 @@
 #ifndef __LINUX_PWM_H
 #define __LINUX_PWM_H
 
+#include <linux/err.h>
 #include <linux/of.h>
 
 struct pwm_device;
 struct seq_file;
 
+#if IS_ENABLED(CONFIG_PWM) || IS_ENABLED(CONFIG_HAVE_PWM)
 /*
  * pwm_request - request a PWM device
  */
@@ -30,8 +32,31 @@ int pwm_enable(struct pwm_device *pwm);
  * pwm_disable - stop a PWM output toggling
  */
 void pwm_disable(struct pwm_device *pwm);
+#else
+static inline struct pwm_device *pwm_request(int pwm_id, const char *label)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline void pwm_free(struct pwm_device *pwm)
+{
+}
+
+static inline int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns)
+{
+	return -EINVAL;
+}
+
+static inline int pwm_enable(struct pwm_device *pwm)
+{
+	return -EINVAL;
+}
+
+static inline void pwm_disable(struct pwm_device *pwm)
+{
+}
+#endif
 
-#ifdef CONFIG_PWM
 struct pwm_chip;
 
 /**
@@ -136,6 +161,7 @@ struct pwm_chip {
 	unsigned int		of_pwm_n_cells;
 };
 
+#if IS_ENABLED(CONFIG_PWM)
 int pwm_set_chip_data(struct pwm_device *pwm, void *data);
 void *pwm_get_chip_data(struct pwm_device *pwm);
 
@@ -150,6 +176,54 @@ void pwm_put(struct pwm_device *pwm);
 
 struct pwm_device *devm_pwm_get(struct device *dev, const char *consumer);
 void devm_pwm_put(struct device *dev, struct pwm_device *pwm);
+#else
+static inline int pwm_set_chip_data(struct pwm_device *pwm, void *data)
+{
+	return -EINVAL;
+}
+
+static inline void *pwm_get_chip_data(struct pwm_device *pwm)
+{
+	return NULL;
+}
+
+static inline int pwmchip_add(struct pwm_chip *chip)
+{
+	return -EINVAL;
+}
+
+static inline int pwmchip_remove(struct pwm_chip *chip)
+{
+	return -EINVAL;
+}
+
+static inline struct pwm_device *pwm_request_from_chip(struct pwm_chip *chip,
+						       unsigned int index,
+						       const char *label)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline struct pwm_device *pwm_get(struct device *dev,
+					 const char *consumer)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline void pwm_put(struct pwm_device *pwm)
+{
+}
+
+static inline struct pwm_device *devm_pwm_get(struct device *dev,
+					      const char *consumer)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline void devm_pwm_put(struct device *dev, struct pwm_device *pwm)
+{
+}
+#endif
 
 struct pwm_lookup {
 	struct list_head list;
@@ -167,8 +241,12 @@ struct pwm_lookup {
 		.con_id = _con_id,			\
 	}
 
+#if IS_ENABLED(CONFIG_PWM)
 void pwm_add_table(struct pwm_lookup *table, size_t num);
-
+#else
+static inline void pwm_add_table(struct pwm_lookup *table, size_t num)
+{
+}
 #endif
 
 #endif /* __LINUX_PWM_H */

commit 6354316dbe5a13b25bea15d7ffc891be025eb267
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Wed Aug 1 19:20:58 2012 +0900

    pwm: add devm_pwm_get() and devm_pwm_put()
    
    Add resource managed variants of pwm_get() and pwm_put() for
    convenience. Code is largely inspired by the equivalent devm functions
    of the regulator framework.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 354764cf5f7a..40c764318957 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -148,6 +148,9 @@ struct pwm_device *pwm_request_from_chip(struct pwm_chip *chip,
 struct pwm_device *pwm_get(struct device *dev, const char *consumer);
 void pwm_put(struct pwm_device *pwm);
 
+struct pwm_device *devm_pwm_get(struct device *dev, const char *consumer);
+void devm_pwm_put(struct device *dev, struct pwm_device *pwm);
+
 struct pwm_lookup {
 	struct list_head list;
 	const char *provider;

commit 0aa0869c3c9b10338dd92a20fa4a9b6959f177b5
Author: Philip, Avinash <avinashphilip@ti.com>
Date:   Tue Jul 24 19:35:32 2012 +0530

    pwm: Add support for configuring the PWM polarity
    
    Some hardware supports inverting the polarity of the PWM signal. This
    commit adds support to the PWM framework to allow users of the PWM API
    to configure the polarity. Note that in order to reduce complexity,
    changing the polarity of a PWM signal is only allowed while the PWM is
    disabled.
    
    A practical example where this can prove useful is to simulate inversion
    of the duty cycle. While inversion of polarity and duty cycle are not
    exactly the same, the differences for most use-cases are negligible.
    
    Signed-off-by: Philip, Avinash <avinashphilip@ti.com>
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 21d076c5089e..354764cf5f7a 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -34,6 +34,20 @@ void pwm_disable(struct pwm_device *pwm);
 #ifdef CONFIG_PWM
 struct pwm_chip;
 
+/**
+ * enum pwm_polarity - polarity of a PWM signal
+ * @PWM_POLARITY_NORMAL: a high signal for the duration of the duty-
+ * cycle, followed by a low signal for the remainder of the pulse
+ * period
+ * @PWM_POLARITY_INVERSED: a low signal for the duration of the duty-
+ * cycle, followed by a high signal for the remainder of the pulse
+ * period
+ */
+enum pwm_polarity {
+	PWM_POLARITY_NORMAL,
+	PWM_POLARITY_INVERSED,
+};
+
 enum {
 	PWMF_REQUESTED = 1 << 0,
 	PWMF_ENABLED = 1 << 1,
@@ -61,11 +75,17 @@ static inline unsigned int pwm_get_period(struct pwm_device *pwm)
 	return pwm ? pwm->period : 0;
 }
 
+/*
+ * pwm_set_polarity - configure the polarity of a PWM signal
+ */
+int pwm_set_polarity(struct pwm_device *pwm, enum pwm_polarity polarity);
+
 /**
  * struct pwm_ops - PWM controller operations
  * @request: optional hook for requesting a PWM
  * @free: optional hook for freeing a PWM
  * @config: configure duty cycles and period length for this PWM
+ * @set_polarity: configure the polarity of this PWM
  * @enable: enable PWM output toggling
  * @disable: disable PWM output toggling
  * @dbg_show: optional routine to show contents in debugfs
@@ -79,6 +99,9 @@ struct pwm_ops {
 	int			(*config)(struct pwm_chip *chip,
 					  struct pwm_device *pwm,
 					  int duty_ns, int period_ns);
+	int			(*set_polarity)(struct pwm_chip *chip,
+					  struct pwm_device *pwm,
+					  enum pwm_polarity polarity);
 	int			(*enable)(struct pwm_chip *chip,
 					  struct pwm_device *pwm);
 	void			(*disable)(struct pwm_chip *chip,

commit 7299ab70e68e20e70cb45fe4ab4b6029fe964acd
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Wed Dec 14 11:10:32 2011 +0100

    pwm: Add device tree support
    
    This patch adds helpers to support device tree bindings for the generic
    PWM API. Device tree binding documentation for PWM controllers is also
    provided.
    
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 2947a4fea6ad..21d076c5089e 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -1,6 +1,8 @@
 #ifndef __LINUX_PWM_H
 #define __LINUX_PWM_H
 
+#include <linux/of.h>
+
 struct pwm_device;
 struct seq_file;
 
@@ -105,6 +107,10 @@ struct pwm_chip {
 	unsigned int		npwm;
 
 	struct pwm_device	*pwms;
+
+	struct pwm_device *	(*of_xlate)(struct pwm_chip *pc,
+					    const struct of_phandle_args *args);
+	unsigned int		of_pwm_n_cells;
 };
 
 int pwm_set_chip_data(struct pwm_device *pwm, void *data);

commit 8138d2ddbcca2a100482dac390133f83c5a60f94
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Mon Mar 26 08:42:48 2012 +0200

    pwm: Add table-based lookup for static mappings
    
    In order to get rid of the global namespace for PWM devices, this commit
    provides an alternative method, similar to that of the regulator or
    clock frameworks, for registering a static mapping for PWM devices. This
    works by providing a table with a provider/consumer map in the board
    setup code.
    
    With the new pwm_get() and pwm_put() functions available, usage of
    pwm_request() and pwm_free() becomes deprecated.
    
    Reviewed-by: Shawn Guo <shawn.guo@linaro.org>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 047cd5351a3b..2947a4fea6ad 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -115,6 +115,28 @@ int pwmchip_remove(struct pwm_chip *chip);
 struct pwm_device *pwm_request_from_chip(struct pwm_chip *chip,
 					 unsigned int index,
 					 const char *label);
+
+struct pwm_device *pwm_get(struct device *dev, const char *consumer);
+void pwm_put(struct pwm_device *pwm);
+
+struct pwm_lookup {
+	struct list_head list;
+	const char *provider;
+	unsigned int index;
+	const char *dev_id;
+	const char *con_id;
+};
+
+#define PWM_LOOKUP(_provider, _index, _dev_id, _con_id)	\
+	{						\
+		.provider = _provider,			\
+		.index = _index,			\
+		.dev_id = _dev_id,			\
+		.con_id = _con_id,			\
+	}
+
+void pwm_add_table(struct pwm_lookup *table, size_t num);
+
 #endif
 
 #endif /* __LINUX_PWM_H */

commit 62099abf67a20cfb98d4c031fb1925e10a78ee1b
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Mon Mar 26 09:31:48 2012 +0200

    pwm: Add debugfs interface
    
    This commit adds a debugfs interface that can be used to list the
    current internal state of the PWM devices registered with the PWM
    framework.
    
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reviewed-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 57103911f4c7..047cd5351a3b 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -2,6 +2,7 @@
 #define __LINUX_PWM_H
 
 struct pwm_device;
+struct seq_file;
 
 /*
  * pwm_request - request a PWM device
@@ -65,6 +66,7 @@ static inline unsigned int pwm_get_period(struct pwm_device *pwm)
  * @config: configure duty cycles and period length for this PWM
  * @enable: enable PWM output toggling
  * @disable: disable PWM output toggling
+ * @dbg_show: optional routine to show contents in debugfs
  * @owner: helps prevent removal of modules exporting active PWMs
  */
 struct pwm_ops {
@@ -79,6 +81,10 @@ struct pwm_ops {
 					  struct pwm_device *pwm);
 	void			(*disable)(struct pwm_chip *chip,
 					   struct pwm_device *pwm);
+#ifdef CONFIG_DEBUG_FS
+	void			(*dbg_show)(struct pwm_chip *chip,
+					    struct seq_file *s);
+#endif
 	struct module		*owner;
 };
 

commit f051c466cf690ac661d713d3ceb56b4efcecc853
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Wed Dec 14 11:12:23 2011 +0100

    pwm: Allow chips to support multiple PWMs
    
    Many PWM controllers provide access to more than a single PWM output and
    may even share some resource among them. Allowing a PWM chip to provide
    multiple PWM devices enables better sharing of those resources. As a
    side-effect this change allows easy integration with the device tree
    where a given PWM can be looked up based on the PWM chip's phandle and a
    corresponding index.
    
    This commit modifies the PWM core to support multiple PWMs per struct
    pwm_chip. It achieves this in a similar way to how gpiolib works, by
    allowing PWM ranges to be requested dynamically (pwm_chip.base == -1) or
    starting at a given offset (pwm_chip.base >= 0). A chip specifies how
    many PWMs it controls using the npwm member. Each of the functions in
    the pwm_ops structure gets an additional argument that specified the PWM
    number (it can be converted to a per-chip index by subtracting the
    chip's base).
    
    The total maximum number of PWM devices is currently fixed to 1024 while
    the data is actually stored in a radix tree, thus saving resources if
    not all of them are used.
    
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reviewed-by: Shawn Guo <shawn.guo@linaro.org>
    [eric@eukrea.com: fix error handling in pwmchip_add]
    Signed-off-by: Eric Bénard <eric@eukrea.com>
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 1f308a13105f..57103911f4c7 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -31,6 +31,33 @@ void pwm_disable(struct pwm_device *pwm);
 #ifdef CONFIG_PWM
 struct pwm_chip;
 
+enum {
+	PWMF_REQUESTED = 1 << 0,
+	PWMF_ENABLED = 1 << 1,
+};
+
+struct pwm_device {
+	const char		*label;
+	unsigned long		flags;
+	unsigned int		hwpwm;
+	unsigned int		pwm;
+	struct pwm_chip		*chip;
+	void			*chip_data;
+
+	unsigned int		period; /* in nanoseconds */
+};
+
+static inline void pwm_set_period(struct pwm_device *pwm, unsigned int period)
+{
+	if (pwm)
+		pwm->period = period;
+}
+
+static inline unsigned int pwm_get_period(struct pwm_device *pwm)
+{
+	return pwm ? pwm->period : 0;
+}
+
 /**
  * struct pwm_ops - PWM controller operations
  * @request: optional hook for requesting a PWM
@@ -41,29 +68,47 @@ struct pwm_chip;
  * @owner: helps prevent removal of modules exporting active PWMs
  */
 struct pwm_ops {
-	int			(*request)(struct pwm_chip *chip);
-	void			(*free)(struct pwm_chip *chip);
-	int			(*config)(struct pwm_chip *chip, int duty_ns,
-						int period_ns);
-	int			(*enable)(struct pwm_chip *chip);
-	void			(*disable)(struct pwm_chip *chip);
+	int			(*request)(struct pwm_chip *chip,
+					   struct pwm_device *pwm);
+	void			(*free)(struct pwm_chip *chip,
+					struct pwm_device *pwm);
+	int			(*config)(struct pwm_chip *chip,
+					  struct pwm_device *pwm,
+					  int duty_ns, int period_ns);
+	int			(*enable)(struct pwm_chip *chip,
+					  struct pwm_device *pwm);
+	void			(*disable)(struct pwm_chip *chip,
+					   struct pwm_device *pwm);
 	struct module		*owner;
 };
 
 /**
- * struct pwm_chip - abstract a PWM
- * @pwm_id: global PWM device index
- * @label: PWM device label
- * @ops: controller operations
+ * struct pwm_chip - abstract a PWM controller
+ * @dev: device providing the PWMs
+ * @list: list node for internal use
+ * @ops: callbacks for this PWM controller
+ * @base: number of first PWM controlled by this chip
+ * @npwm: number of PWMs controlled by this chip
+ * @pwms: array of PWM devices allocated by the framework
  */
 struct pwm_chip {
-	int			pwm_id;
-	const char		*label;
-	struct pwm_ops		*ops;
+	struct device		*dev;
+	struct list_head	list;
+	const struct pwm_ops	*ops;
+	int			base;
+	unsigned int		npwm;
+
+	struct pwm_device	*pwms;
 };
 
+int pwm_set_chip_data(struct pwm_device *pwm, void *data);
+void *pwm_get_chip_data(struct pwm_device *pwm);
+
 int pwmchip_add(struct pwm_chip *chip);
 int pwmchip_remove(struct pwm_chip *chip);
+struct pwm_device *pwm_request_from_chip(struct pwm_chip *chip,
+					 unsigned int index,
+					 const char *label);
 #endif
 
 #endif /* __LINUX_PWM_H */

commit 0c2498f1660878339350bea8d18550b1b87ca055
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Fri Jan 28 09:40:40 2011 +0100

    pwm: Add PWM framework support
    
    This patch adds framework support for PWM (pulse width modulation) devices.
    
    The is a barebone PWM API already in the kernel under include/linux/pwm.h,
    but it does not allow for multiple drivers as each of them implements the
    pwm_*() functions.
    
    There are other PWM framework patches around from Bill Gatliff. Unlike
    his framework this one does not change the existing API for PWMs so that
    this framework can act as a drop in replacement for the existing API.
    
    Why another framework?
    
    Several people argue that there should not be another framework for PWMs
    but they should be integrated into one of the existing frameworks like led
    or hwmon. Unlike these frameworks the PWM framework is agnostic to the
    purpose of the PWM. In fact, a PWM can drive a LED, but this makes the
    LED framework a user of a PWM, like already done in leds-pwm.c. The gpio
    framework also is not suitable for PWMs. Every gpio could be turned into
    a PWM using timer based toggling, but on the other hand not every PWM hardware
    device can be turned into a gpio due to the lack of hardware capabilities.
    
    This patch does not try to improve the PWM API yet, this could be done in
    subsequent patches.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Kurt Van Dijck <kurt.van.dijck@eia.be>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Matthias Kaehlcke <matthias@kaehlcke.net>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reviewed-by: Shawn Guo <shawn.guo@linaro.org>
    [thierry.reding@avionic-design.de: fixup typos, kerneldoc comments]
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 7c775751392c..1f308a13105f 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -28,4 +28,42 @@ int pwm_enable(struct pwm_device *pwm);
  */
 void pwm_disable(struct pwm_device *pwm);
 
+#ifdef CONFIG_PWM
+struct pwm_chip;
+
+/**
+ * struct pwm_ops - PWM controller operations
+ * @request: optional hook for requesting a PWM
+ * @free: optional hook for freeing a PWM
+ * @config: configure duty cycles and period length for this PWM
+ * @enable: enable PWM output toggling
+ * @disable: disable PWM output toggling
+ * @owner: helps prevent removal of modules exporting active PWMs
+ */
+struct pwm_ops {
+	int			(*request)(struct pwm_chip *chip);
+	void			(*free)(struct pwm_chip *chip);
+	int			(*config)(struct pwm_chip *chip, int duty_ns,
+						int period_ns);
+	int			(*enable)(struct pwm_chip *chip);
+	void			(*disable)(struct pwm_chip *chip);
+	struct module		*owner;
+};
+
+/**
+ * struct pwm_chip - abstract a PWM
+ * @pwm_id: global PWM device index
+ * @label: PWM device label
+ * @ops: controller operations
+ */
+struct pwm_chip {
+	int			pwm_id;
+	const char		*label;
+	struct pwm_ops		*ops;
+};
+
+int pwmchip_add(struct pwm_chip *chip);
+int pwmchip_remove(struct pwm_chip *chip);
+#endif
+
 #endif /* __LINUX_PWM_H */

commit 5243ef8b54a927cae23216253e4e3f03af6f1446
Author: Mark Vels <mark.vels@team-embedded.nl>
Date:   Sun Jan 18 18:42:45 2009 +0100

    trivial: PWM: fix of #endif comment
    
    Signed-off-by: Mark Vels <mark.vels@team-embedded.nl>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 3945f803d514..7c775751392c 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -28,4 +28,4 @@ int pwm_enable(struct pwm_device *pwm);
  */
 void pwm_disable(struct pwm_device *pwm);
 
-#endif /* __ASM_ARCH_PWM_H */
+#endif /* __LINUX_PWM_H */

commit 1a189b97190d3f0f8cf0379a799d3555b2d648bb
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Apr 13 21:41:55 2008 +0100

    [ARM] pxa: Add bare bones PWM API
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/pwm.h b/include/linux/pwm.h
new file mode 100644
index 000000000000..3945f803d514
--- /dev/null
+++ b/include/linux/pwm.h
@@ -0,0 +1,31 @@
+#ifndef __LINUX_PWM_H
+#define __LINUX_PWM_H
+
+struct pwm_device;
+
+/*
+ * pwm_request - request a PWM device
+ */
+struct pwm_device *pwm_request(int pwm_id, const char *label);
+
+/*
+ * pwm_free - free a PWM device
+ */
+void pwm_free(struct pwm_device *pwm);
+
+/*
+ * pwm_config - change a PWM device configuration
+ */
+int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns);
+
+/*
+ * pwm_enable - start a PWM output toggling
+ */
+int pwm_enable(struct pwm_device *pwm);
+
+/*
+ * pwm_disable - stop a PWM output toggling
+ */
+void pwm_disable(struct pwm_device *pwm);
+
+#endif /* __ASM_ARCH_PWM_H */
