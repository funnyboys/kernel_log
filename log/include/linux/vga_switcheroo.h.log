commit 37a3a98ef601f89100e3bb657fb0e190b857028c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Sep 10 16:20:25 2018 +0200

    ALSA: hda - Enable runtime PM only for discrete GPU
    
    The recent change of vga_switcheroo allowed the runtime PM for
    HD-audio on AMD GPUs, but this also resulted in a regression.  When
    the HD-audio controller driver gets runtime-suspended, HD-audio link
    is turned off, and the hotplug notification is ignored.  This leads to
    the inconsistent audio state (the connection isn't notified and ELD is
    ignored).
    
    The best fix would be to implement the proper ELD notification via the
    audio component, but it's still not ready.  As a quick workaround,
    this patch adds the check of runtime_idle and allows the runtime
    suspend only when the vga_switcheroo is bound with discrete GPU.
    That is, a system with a single GPU and APU would be again without
    runtime PM to keep the HD-audio link for the hotplug notification and
    ELD read out.
    
    Also, the codec->auto_runtime_pm flag is set only for the discrete GPU
    at the time GPU gets bound via vga_switcheroo (i.e. only dGPU is
    forcibly runtime-PM enabled), so that APU can still get the ELD
    notification.
    
    For identifying which GPU is bound, a new vga_switcheroo client
    callback, gpu_bound, is implemented.  The vga_switcheroo simply calls
    this when GPU is bound, and tells whether it's dGPU or APU.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=200945
    Fixes: 07f4f97d7b4b ("vga_switcheroo: Use device link for HDA controller")
    Reported-by: Jian-Hong Pan <jian-hong@endlessm.com>
    Tested-by: Jian-Hong Pan <jian-hong@endlessm.com>
    Acked-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index a34539b7f750..7e6ac0114d55 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -133,15 +133,18 @@ struct vga_switcheroo_handler {
  * @can_switch: check if the device is in a position to switch now.
  * 	Mandatory. The client should return false if a user space process
  * 	has one of its device files open
+ * @gpu_bound: notify the client id to audio client when the GPU is bound.
  *
  * Client callbacks. A client can be either a GPU or an audio device on a GPU.
  * The @set_gpu_state and @can_switch methods are mandatory, @reprobe may be
  * set to NULL. For audio clients, the @reprobe member is bogus.
+ * OTOH, @gpu_bound is only for audio clients, and not used for GPU clients.
  */
 struct vga_switcheroo_client_ops {
 	void (*set_gpu_state)(struct pci_dev *dev, enum vga_switcheroo_state);
 	void (*reprobe)(struct pci_dev *dev);
 	bool (*can_switch)(struct pci_dev *dev);
+	void (*gpu_bound)(struct pci_dev *dev, enum vga_switcheroo_client_id);
 };
 
 #if defined(CONFIG_VGA_SWITCHEROO)

commit 4aaf448fa9754e2d5ee188d32327b24ffc15ca4d
Author: Jim Qu <Jim.Qu@amd.com>
Date:   Tue Jul 17 16:20:50 2018 +0800

    vga_switcheroo: set audio client id according to bound GPU id
    
    On modern laptop, there are more and more platforms
    have two GPUs, and each of them maybe have audio codec
    for HDMP/DP output. For some dGPU which is no output,
    audio codec usually is disabled.
    
    In currect HDA audio driver, it will set all codec as
    VGA_SWITCHEROO_DIS, the audio which is binded to UMA
    will be suspended if user use debugfs to contorl power
    
    In HDA driver side, it is difficult to know which GPU
    the audio has binded to. So set the bound gpu pci dev
    to vga_switcheroo.
    
    if the audio client is not the third registration, audio
    id will set in vga_switcheroo enable function. if the
    audio client is the last registration when vga_switcheroo
    _ready() get true, we should get audio client id from bound
    GPU directly.
    
    Signed-off-by: Jim Qu <Jim.Qu@amd.com>
    Reviewed-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index 77f0f0af3a71..a34539b7f750 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -84,8 +84,8 @@ enum vga_switcheroo_state {
  * Client identifier. Audio clients use the same identifier & 0x100.
  */
 enum vga_switcheroo_client_id {
-	VGA_SWITCHEROO_UNKNOWN_ID = -1,
-	VGA_SWITCHEROO_IGD,
+	VGA_SWITCHEROO_UNKNOWN_ID = 0x1000,
+	VGA_SWITCHEROO_IGD = 0,
 	VGA_SWITCHEROO_DIS,
 	VGA_SWITCHEROO_MAX_CLIENTS,
 };
@@ -151,7 +151,7 @@ int vga_switcheroo_register_client(struct pci_dev *dev,
 				   bool driver_power_control);
 int vga_switcheroo_register_audio_client(struct pci_dev *pdev,
 					 const struct vga_switcheroo_client_ops *ops,
-					 enum vga_switcheroo_client_id id);
+					 struct pci_dev *vga_dev);
 
 void vga_switcheroo_client_fb_set(struct pci_dev *dev,
 				  struct fb_info *info);
@@ -180,7 +180,7 @@ static inline int vga_switcheroo_register_handler(const struct vga_switcheroo_ha
 		enum vga_switcheroo_handler_flags_t handler_flags) { return 0; }
 static inline int vga_switcheroo_register_audio_client(struct pci_dev *pdev,
 	const struct vga_switcheroo_client_ops *ops,
-	enum vga_switcheroo_client_id id) { return 0; }
+	struct pci_dev *vga_dev) { return 0; }
 static inline void vga_switcheroo_unregister_handler(void) {}
 static inline enum vga_switcheroo_handler_flags_t vga_switcheroo_handler_flags(void) { return 0; }
 static inline int vga_switcheroo_lock_ddc(struct pci_dev *pdev) { return -ENODEV; }

commit 07f4f97d7b4bf325d9f558c5b58230387e4e57e0
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Mar 3 10:53:24 2018 +0100

    vga_switcheroo: Use device link for HDA controller
    
    Back in 2013, runtime PM for GPUs with integrated HDA controller was
    introduced with commits 0d69704ae348 ("gpu/vga_switcheroo: add driver
    control power feature. (v3)") and 246efa4a072f ("snd/hda: add runtime
    suspend/resume on optimus support (v4)").
    
    Briefly, the idea was that the HDA controller is forced on and off in
    unison with the GPU.
    
    The original code is mostly still in place even though it was never a
    100% perfect solution:  E.g. on access to the HDA controller, the GPU
    is powered up via vga_switcheroo_runtime_resume_hdmi_audio() but there
    are no provisions to keep it resumed until access to the HDA controller
    has ceased:  The GPU autosuspends after 5 seconds, rendering the HDA
    controller inaccessible.
    
    Additionally, a kludge is required when hda_intel.c probes:  It has to
    check whether the GPU is powered down (check_hdmi_disabled()) and defer
    probing if so.
    
    However in the meantime (in v4.10) the driver core has gained a feature
    called device links which promises to solve such issues in a clean way:
    It allows us to declare a dependency from the HDA controller (consumer)
    to the GPU (supplier).  The PM core then automagically ensures that the
    GPU is runtime resumed as long as the HDA controller's ->probe hook is
    executed and whenever the HDA controller is accessed.
    
    By default, the HDA controller has a dependency on its parent, a PCIe
    Root Port.  Adding a device link creates another dependency on its
    sibling:
    
                                PCIe Root Port
                                 ^          ^
                                 |          |
                                 |          |
                                HDA  ===>  GPU
    
    The device link is not only used for runtime PM, it also guarantees that
    on system sleep, the HDA controller suspends before the GPU and resumes
    after the GPU, and on system shutdown the HDA controller's ->shutdown
    hook is executed before the one of the GPU.  It is a complete solution.
    
    Using this functionality is as simple as calling device_link_add(),
    which results in a dmesg entry like this:
    
            pci 0000:01:00.1: Linked as a consumer to 0000:01:00.0
    
    The code for the GPU-governed audio power management can thus be removed
    (except where it's still needed for legacy manual power control).
    
    The device link is added in a PCI quirk rather than in hda_intel.c.
    It is therefore legal for the GPU to runtime suspend to D3cold even if
    the HDA controller is not bound to a driver or if CONFIG_SND_HDA_INTEL
    is not enabled, for accesses to the HDA controller will cause the GPU to
    wake up regardless if they're occurring outside of hda_intel.c (think
    config space readout via sysfs).
    
    Contrary to the previous implementation, the HDA controller's power
    state is now self-governed, rather than GPU-governed, whereas the GPU's
    power state is no longer fully self-governed.  (The HDA controller needs
    to runtime suspend before the GPU can.)
    
    It is thus crucial that runtime PM is always activated on the HDA
    controller even if CONFIG_SND_HDA_POWER_SAVE_DEFAULT is set to 0 (which
    is the default), lest the GPU stays awake.  This is achieved by setting
    the auto_runtime_pm flag on every codec and the AZX_DCAPS_PM_RUNTIME
    flag on the HDA controller.
    
    A side effect is that power consumption might be reduced if the GPU is
    in use but the HDA controller is not, because the HDA controller is now
    allowed to go to D3hot.  Before, it was forced to stay in D0 as long as
    the GPU was in use.  (There is no reduction in power consumption on my
    Nvidia GK107, but there might be on other chips.)
    
    The code paths for legacy manual power control are adjusted such that
    runtime PM is disabled during power off, thereby preventing the PM core
    from resuming the HDA controller.
    
    Note that the device link is not only added on vga_switcheroo capable
    systems, but for *any* GPU with integrated HDA controller.  The idea is
    that the HDA controller streams audio via connectors located on the GPU,
    so the GPU needs to be on for the HDA controller to do anything useful.
    
    This commit implicitly fixes an unbalanced runtime PM ref upon unbind of
    hda_intel.c:  On ->probe, a runtime PM ref was previously released under
    the condition "azx_has_pm_runtime(chip) || hda->use_vga_switcheroo", but
    on ->remove a runtime PM ref was only acquired under the first of those
    conditions.  Thus, binding and unbinding the driver twice on a
    vga_switcheroo capable system caused the runtime PM refcount to drop
    below zero.  The issue is resolved because the AZX_DCAPS_PM_RUNTIME flag
    is now always set if use_vga_switcheroo is true.
    
    For more information on device links please refer to:
    https://www.kernel.org/doc/html/latest/driver-api/device_link.html
    Documentation/driver-api/device_link.rst
    
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Reviewed-by: Peter Wu <peter@lekensteyn.nl>
    Tested-by: Kai Heng Feng <kai.heng.feng@canonical.com> # AMD PowerXpress
    Tested-by: Mike Lothian <mike@fireburn.co.uk>          # AMD PowerXpress
    Tested-by: Denis Lisov <dennis.lissov@gmail.com>       # Nvidia Optimus
    Tested-by: Peter Wu <peter@lekensteyn.nl>              # Nvidia Optimus
    Tested-by: Lukas Wunner <lukas@wunner.de>              # MacBook Pro
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/51bd38360ff502a8c42b1ebf4405ee1d3f27118d.1520068884.git.lukas@wunner.de

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index 960bedbdec87..77f0f0af3a71 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -168,11 +168,8 @@ int vga_switcheroo_process_delayed_switch(void);
 bool vga_switcheroo_client_probe_defer(struct pci_dev *pdev);
 enum vga_switcheroo_state vga_switcheroo_get_client_state(struct pci_dev *dev);
 
-void vga_switcheroo_set_dynamic_switch(struct pci_dev *pdev, enum vga_switcheroo_state dynamic);
-
 int vga_switcheroo_init_domain_pm_ops(struct device *dev, struct dev_pm_domain *domain);
 void vga_switcheroo_fini_domain_pm_ops(struct device *dev);
-int vga_switcheroo_init_domain_pm_optimus_hdmi_audio(struct device *dev, struct dev_pm_domain *domain);
 #else
 
 static inline void vga_switcheroo_unregister_client(struct pci_dev *dev) {}
@@ -192,11 +189,8 @@ static inline int vga_switcheroo_process_delayed_switch(void) { return 0; }
 static inline bool vga_switcheroo_client_probe_defer(struct pci_dev *pdev) { return false; }
 static inline enum vga_switcheroo_state vga_switcheroo_get_client_state(struct pci_dev *dev) { return VGA_SWITCHEROO_ON; }
 
-static inline void vga_switcheroo_set_dynamic_switch(struct pci_dev *pdev, enum vga_switcheroo_state dynamic) {}
-
 static inline int vga_switcheroo_init_domain_pm_ops(struct device *dev, struct dev_pm_domain *domain) { return -EINVAL; }
 static inline void vga_switcheroo_fini_domain_pm_ops(struct device *dev) {}
-static inline int vga_switcheroo_init_domain_pm_optimus_hdmi_audio(struct device *dev, struct dev_pm_domain *domain) { return -EINVAL; }
 
 #endif
 #endif /* _LINUX_VGA_SWITCHEROO_H_ */

commit b00e5334ab1bb2e41187fb964a1a2304871fb4ff
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue May 31 11:13:27 2016 +0200

    vga_switcheroo: Add helper for deferred probing
    
    So far we've got one condition when DRM drivers need to defer probing
    on a dual GPU system and it's coded separately into each of the relevant
    drivers. As suggested by Daniel Vetter, deduplicate that code in the
    drivers and move it to a new vga_switcheroo helper. This yields better
    encapsulation of concepts and lets us add further checks in a central
    place. (The existing check pertains to pre-retina MacBook Pros and an
    additional check is expected to be needed for retinas.)
    
    One might be tempted to check deferred probing conditions in
    vga_switcheroo_register_client(), but this is usually called fairly late
    during driver load. The GPU is fully brought up and ready for switching
    at that point. On boot the ->probe hook is potentially called dozens of
    times until it finally succeeds, and each time we'd repeat bringup and
    teardown of the GPU, lengthening boot time considerably and cluttering
    logfiles. A separate helper is therefore needed which can be called
    right at the beginning of the ->probe hook.
    
    Note that amdgpu currently does not call this helper as the AMD GPUs
    built into MacBook Pros are only supported by radeon so far.
    
    v2: This helper could eventually be used by audio clients as well,
        so rephrase kerneldoc to refer to "client" instead of "GPU"
        and move the single existing check in an if block specific
        to PCI_CLASS_DISPLAY_VGA devices. Move documentation on
        that check from kerneldoc to a comment. (Daniel Vetter)
    
    v3: Mandate in kerneldoc that registration of client shall only
        happen after calling this helper. (Daniel Vetter)
    
    v4: Rebase on 412c8f7de011 ("drm/radeon: Return -EPROBE_DEFER when
        amdkfd not loaded")
    
    v5: Some Optimus GPUs use PCI_CLASS_DISPLAY_3D, make sure those are
        matched as well. (Emil Velikov)
    
    v6: The if-condition referring to PCI_BASE_CLASS_DISPLAY may be
        considered a functional change. Move to a separate commit to
        keep this a pure refactoring change. (Emil Velikov, Jani Nikula)
    
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/575885fd440c2b13c3f19ddf44360cfbbff35f50.1464685538.git.lukas@wunner.de

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index b39a5f3153bd..960bedbdec87 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -165,6 +165,7 @@ int vga_switcheroo_unlock_ddc(struct pci_dev *pdev);
 
 int vga_switcheroo_process_delayed_switch(void);
 
+bool vga_switcheroo_client_probe_defer(struct pci_dev *pdev);
 enum vga_switcheroo_state vga_switcheroo_get_client_state(struct pci_dev *dev);
 
 void vga_switcheroo_set_dynamic_switch(struct pci_dev *pdev, enum vga_switcheroo_state dynamic);
@@ -188,6 +189,7 @@ static inline enum vga_switcheroo_handler_flags_t vga_switcheroo_handler_flags(v
 static inline int vga_switcheroo_lock_ddc(struct pci_dev *pdev) { return -ENODEV; }
 static inline int vga_switcheroo_unlock_ddc(struct pci_dev *pdev) { return -ENODEV; }
 static inline int vga_switcheroo_process_delayed_switch(void) { return 0; }
+static inline bool vga_switcheroo_client_probe_defer(struct pci_dev *pdev) { return false; }
 static inline enum vga_switcheroo_state vga_switcheroo_get_client_state(struct pci_dev *dev) { return VGA_SWITCHEROO_ON; }
 
 static inline void vga_switcheroo_set_dynamic_switch(struct pci_dev *pdev, enum vga_switcheroo_state dynamic) {}

commit e4cb81d7e49c806fa557cf0ff4f3f40bd7a9cb7c
Author: Lukas Wunner <lukas@wunner.de>
Date:   Mon Jan 11 20:09:20 2016 +0100

    vga_switcheroo: Add support for switching only the DDC
    
    Originally by Seth Forshee <seth.forshee@canonical.com>, 2012-10-04:
        During graphics driver initialization it's useful to be able to mux
        only the DDC to the inactive client in order to read the EDID. Add
        a switch_ddc callback to allow capable handlers to provide this
        functionality, and add vga_switcheroo_switch_ddc() to allow DRM
        to mux only the DDC.
    
    Modified by Dave Airlie <airlied@gmail.com>, 2012-12-22:
        I can't figure out why I didn't like this, but I rewrote this [...]
        to lock/unlock the ddc lines [...]. I think I'd prefer something
        like that otherwise the interface got really ugly.
    
    Modified by Lukas Wunner <lukas@wunner.de>, 2015-04 - 2015-10:
        Change semantics of ->switch_ddc handler callback to return previous
        DDC owner. Original version tried to determine previous DDC owner
        with find_active_client() but this fails if the inactive client
        registers before the active client.
    
        Don't lock vgasr_mutex in _lock_ddc() / _unlock_ddc(), it can cause
        deadlocks because (a) during switch (with vgasr_mutex already held),
        GPU is woken and probes its outputs, tries to re-acquire vgasr_mutex
        to lock DDC lines; (b) Likewise during switch, GPU is suspended and
        calls cancel_delayed_work_sync() to stop output polling, if poll
        task is running at this moment we may wait forever for it to finish.
    
        Instead, lock mux_hw_lock when unregistering the handler because
        the only reason why we'd want to lock vgasr_mutex in _lock_ddc() /
        _unlock_ddc() is to block the handler from disappearing while DDC
        lines are switched.
    
        Also acquire mux_hw_lock in stage2 to avoid race condition where
        reading the EDID and switching happens simultaneously. Likewise on
        MIGD / MDIS commands and on runtime suspend.
    
        v2.1: Overhaul locking, squash commits (Daniel Vetter)
    
        v2.2: Readability improvements (Thierry Reding)
    
        v2.3: Overhaul locking once more
    
        v2.4: Retain semantics of ->switchto handler callback to switch all
              pins, including DDC (Daniel Vetter)
    
        v5:   Rename ddc_lock to mux_hw_lock: Since we acquire this both
              when calling ->switch_ddc and ->switchto, it protects not just
              access to the DDC lines but to the mux in general. This is in
              line with the DRM convention to use low-level locks to avoid
              concurrent hw access (e.g. i2c, dp_aux) which are often called
              hw_lock (Daniel Vetter)
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=88861
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=61115
    Tested-by: Lukas Wunner <lukas@wunner.de>
        [MBP  9,1 2012  intel IVB + nvidia GK107  pre-retina  15"]
    Cc: Seth Forshee <seth.forshee@canonical.com>
    Cc: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/e81ae9722b84c5ed591805fee3ea6dbf5dc6c4b3.1452525860.git.lukas@wunner.de

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index a745f4f0f729..b39a5f3153bd 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -102,6 +102,9 @@ enum vga_switcheroo_client_id {
  * 	Mandatory. For muxless machines this should be a no-op. Returning 0
  * 	denotes success, anything else failure (in which case the switch is
  * 	aborted)
+ * @switch_ddc: switch DDC lines to given client.
+ * 	Optional. Should return the previous DDC owner on success or a
+ * 	negative int on failure
  * @power_state: cut or reinstate power of given client.
  * 	Optional. The return value is ignored
  * @get_client_id: determine if given pci device is integrated or discrete GPU.
@@ -113,6 +116,7 @@ enum vga_switcheroo_client_id {
 struct vga_switcheroo_handler {
 	int (*init)(void);
 	int (*switchto)(enum vga_switcheroo_client_id id);
+	int (*switch_ddc)(enum vga_switcheroo_client_id id);
 	int (*power_state)(enum vga_switcheroo_client_id id,
 			   enum vga_switcheroo_state state);
 	enum vga_switcheroo_client_id (*get_client_id)(struct pci_dev *pdev);
@@ -156,6 +160,8 @@ int vga_switcheroo_register_handler(const struct vga_switcheroo_handler *handler
 				    enum vga_switcheroo_handler_flags_t handler_flags);
 void vga_switcheroo_unregister_handler(void);
 enum vga_switcheroo_handler_flags_t vga_switcheroo_handler_flags(void);
+int vga_switcheroo_lock_ddc(struct pci_dev *pdev);
+int vga_switcheroo_unlock_ddc(struct pci_dev *pdev);
 
 int vga_switcheroo_process_delayed_switch(void);
 
@@ -179,6 +185,8 @@ static inline int vga_switcheroo_register_audio_client(struct pci_dev *pdev,
 	enum vga_switcheroo_client_id id) { return 0; }
 static inline void vga_switcheroo_unregister_handler(void) {}
 static inline enum vga_switcheroo_handler_flags_t vga_switcheroo_handler_flags(void) { return 0; }
+static inline int vga_switcheroo_lock_ddc(struct pci_dev *pdev) { return -ENODEV; }
+static inline int vga_switcheroo_unlock_ddc(struct pci_dev *pdev) { return -ENODEV; }
 static inline int vga_switcheroo_process_delayed_switch(void) { return 0; }
 static inline enum vga_switcheroo_state vga_switcheroo_get_client_state(struct pci_dev *dev) { return VGA_SWITCHEROO_ON; }
 

commit 156d7d4120e1c860fde667fc30eeae84bc3e7a25
Author: Lukas Wunner <lukas@wunner.de>
Date:   Mon Jan 11 20:09:20 2016 +0100

    vga_switcheroo: Add handler flags infrastructure
    
    Allow handlers to declare their capabilities and allow clients to
    obtain that information. So far we have these use cases:
    
    * If the handler is able to switch DDC separately, clients need to
      probe EDID with drm_get_edid_switcheroo(). We should allow them
      to detect a capable handler to ensure this function only gets
      called when needed.
    
    * Likewise if the handler is unable to switch AUX separately, the active
      client needs to communicate link training parameters to the inactive
      client, which may then skip the AUX handshake and set up its output
      with these pre-calibrated values (DisplayPort specification v1.1a,
      section 2.5.3.3). Clients need a way to recognize such a situation.
    
    The flags for the radeon_atpx_handler and amdgpu_atpx_handler are
    initially set to 0, this can later on be amended with
      handler_flags |= VGA_SWITCHEROO_CAN_SWITCH_DDC;
    when a ->switch_ddc callback is added.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=88861
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=61115
    Tested-by: Lukas Wunner <lukas@wunner.de>
        [MBP  9,1 2012  intel IVB + nvidia GK107  pre-retina  15"]
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Reviewed-by: Darren Hart <dvhart@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/2b0d93ed6e511ca09e95e45e0b35627f330fabce.1452525860.git.lukas@wunner.de

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index 69e1d4a1f1b3..a745f4f0f729 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -35,6 +35,26 @@
 
 struct pci_dev;
 
+/**
+ * enum vga_switcheroo_handler_flags_t - handler flags bitmask
+ * @VGA_SWITCHEROO_CAN_SWITCH_DDC: whether the handler is able to switch the
+ * 	DDC lines separately. This signals to clients that they should call
+ * 	drm_get_edid_switcheroo() to probe the EDID
+ * @VGA_SWITCHEROO_NEEDS_EDP_CONFIG: whether the handler is unable to switch
+ * 	the AUX channel separately. This signals to clients that the active
+ * 	GPU needs to train the link and communicate the link parameters to the
+ * 	inactive GPU (mediated by vga_switcheroo). The inactive GPU may then
+ * 	skip the AUX handshake and set up its output with these pre-calibrated
+ * 	values (DisplayPort specification v1.1a, section 2.5.3.3)
+ *
+ * Handler flags bitmask. Used by handlers to declare their capabilities upon
+ * registering with vga_switcheroo.
+ */
+enum vga_switcheroo_handler_flags_t {
+	VGA_SWITCHEROO_CAN_SWITCH_DDC	= (1 << 0),
+	VGA_SWITCHEROO_NEEDS_EDP_CONFIG	= (1 << 1),
+};
+
 /**
  * enum vga_switcheroo_state - client power state
  * @VGA_SWITCHEROO_OFF: off
@@ -132,8 +152,10 @@ int vga_switcheroo_register_audio_client(struct pci_dev *pdev,
 void vga_switcheroo_client_fb_set(struct pci_dev *dev,
 				  struct fb_info *info);
 
-int vga_switcheroo_register_handler(const struct vga_switcheroo_handler *handler);
+int vga_switcheroo_register_handler(const struct vga_switcheroo_handler *handler,
+				    enum vga_switcheroo_handler_flags_t handler_flags);
 void vga_switcheroo_unregister_handler(void);
+enum vga_switcheroo_handler_flags_t vga_switcheroo_handler_flags(void);
 
 int vga_switcheroo_process_delayed_switch(void);
 
@@ -150,11 +172,13 @@ static inline void vga_switcheroo_unregister_client(struct pci_dev *dev) {}
 static inline int vga_switcheroo_register_client(struct pci_dev *dev,
 		const struct vga_switcheroo_client_ops *ops, bool driver_power_control) { return 0; }
 static inline void vga_switcheroo_client_fb_set(struct pci_dev *dev, struct fb_info *info) {}
-static inline int vga_switcheroo_register_handler(const struct vga_switcheroo_handler *handler) { return 0; }
+static inline int vga_switcheroo_register_handler(const struct vga_switcheroo_handler *handler,
+		enum vga_switcheroo_handler_flags_t handler_flags) { return 0; }
 static inline int vga_switcheroo_register_audio_client(struct pci_dev *pdev,
 	const struct vga_switcheroo_client_ops *ops,
 	enum vga_switcheroo_client_id id) { return 0; }
 static inline void vga_switcheroo_unregister_handler(void) {}
+static inline enum vga_switcheroo_handler_flags_t vga_switcheroo_handler_flags(void) { return 0; }
 static inline int vga_switcheroo_process_delayed_switch(void) { return 0; }
 static inline enum vga_switcheroo_state vga_switcheroo_get_client_state(struct pci_dev *dev) { return VGA_SWITCHEROO_ON; }
 

commit e02328f47bd75fde9decf9657ec7d769b370f857
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Sep 8 14:17:47 2015 +0200

    vga_switcheroo: Drop client power state VGA_SWITCHEROO_INIT
    
    hda_intel.c:azx_probe() defers initialization of an audio controller
    on the discrete GPU if the GPU is powered off. The power state of the
    GPU is determined by calling vga_switcheroo_get_client_state().
    
    vga_switcheroo_get_client_state() returns VGA_SWITCHEROO_INIT if
    vga_switcheroo is not enabled, i.e. if no second GPU or no handler
    has registered.
    
    This can go wrong in the following scenario:
    - Driver for the integrated GPU is not loaded.
    - Driver for the discrete GPU registers with vga_switcheroo, uses driver
      power control to power down the GPU, handler cuts power to the GPU.
    - Driver for the audio controller gets loaded after the GPU was powered
      down, calls vga_switcheroo_get_client_state() which returns
      VGA_SWITCHEROO_INIT instead of VGA_SWITCHEROO_OFF.
    - Consequence: azx_probe() tries to initialize the audio controller even
      though the GPU is powered down.
    
    The power state VGA_SWITCHEROO_INIT was introduced by c8e9cf7bb240
    ("vga_switcheroo: Add a helper function to get the client state").
    It is not apparent what its benefit might be. The idea seems to
    be to initialize the audio controller even if the power state is
    VGA_SWITCHEROO_OFF (were vga_switcheroo enabled), but as shown
    above this can fail.
    
    Drop VGA_SWITCHEROO_INIT to solve this.
    
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index 786bc931dbd1..69e1d4a1f1b3 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -39,10 +39,6 @@ struct pci_dev;
  * enum vga_switcheroo_state - client power state
  * @VGA_SWITCHEROO_OFF: off
  * @VGA_SWITCHEROO_ON: on
- * @VGA_SWITCHEROO_INIT: client has registered with vga_switcheroo but
- * 	vga_switcheroo is not enabled, i.e. no second client or no handler
- * 	has registered. Only used in vga_switcheroo_get_client_state() which
- * 	in turn is only called from hda_intel.c
  * @VGA_SWITCHEROO_NOT_FOUND: client has not registered with vga_switcheroo.
  * 	Only used in vga_switcheroo_get_client_state() which in turn is only
  * 	called from hda_intel.c
@@ -53,7 +49,6 @@ enum vga_switcheroo_state {
 	VGA_SWITCHEROO_OFF,
 	VGA_SWITCHEROO_ON,
 	/* below are referred only from vga_switcheroo_get_client_state() */
-	VGA_SWITCHEROO_INIT,
 	VGA_SWITCHEROO_NOT_FOUND,
 };
 

commit 5d170139eb10ae12e1bd076245c42b35453d8324
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Oct 18 13:05:40 2015 +0200

    vga_switcheroo: Constify vga_switcheroo_handler
    
    vga_switcheroo_client_ops has always been declared const since its
    introduction with 26ec685ff9d9 ("vga_switcheroo: Introduce struct
    vga_switcheroo_client_ops").
    
    Do so for vga_switcheroo_handler as well.
    
     drivers/gpu/drm/amd/amdgpu/amdgpu.ko:
       6 .rodata       00009888
    - 19 .data         00001f00
    + 19 .data         00001ee0
     drivers/gpu/drm/nouveau/nouveau.ko:
       6 .rodata       000460b8
      17 .data         00018fe0
     drivers/gpu/drm/radeon/radeon.ko:
    -  7 .rodata       00030944
    +  7 .rodata       00030964
    - 21 .data         0000d6a0
    + 21 .data         0000d678
     drivers/platform/x86/apple-gmux.ko:
    -  7 .rodata       00000140
    +  7 .rodata       00000160
    - 11 .data         000000e0
    + 11 .data         000000b8
    
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Darren Hart <dvhart@linux.intel.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Reviewed-by: Christian König <christian.koenig@amd.com>.
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index c55751155631..786bc931dbd1 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -137,7 +137,7 @@ int vga_switcheroo_register_audio_client(struct pci_dev *pdev,
 void vga_switcheroo_client_fb_set(struct pci_dev *dev,
 				  struct fb_info *info);
 
-int vga_switcheroo_register_handler(struct vga_switcheroo_handler *handler);
+int vga_switcheroo_register_handler(const struct vga_switcheroo_handler *handler);
 void vga_switcheroo_unregister_handler(void);
 
 int vga_switcheroo_process_delayed_switch(void);
@@ -155,7 +155,7 @@ static inline void vga_switcheroo_unregister_client(struct pci_dev *dev) {}
 static inline int vga_switcheroo_register_client(struct pci_dev *dev,
 		const struct vga_switcheroo_client_ops *ops, bool driver_power_control) { return 0; }
 static inline void vga_switcheroo_client_fb_set(struct pci_dev *dev, struct fb_info *info) {}
-static inline int vga_switcheroo_register_handler(struct vga_switcheroo_handler *handler) { return 0; }
+static inline int vga_switcheroo_register_handler(const struct vga_switcheroo_handler *handler) { return 0; }
 static inline int vga_switcheroo_register_audio_client(struct pci_dev *pdev,
 	const struct vga_switcheroo_client_ops *ops,
 	enum vga_switcheroo_client_id id) { return 0; }

commit fa3e967fffaf267ccab7959429722da34e45ad77
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Aug 28 12:54:07 2015 +0200

    vga_switcheroo: Use enum vga_switcheroo_client_id instead of int
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index 88909a865b72..c55751155631 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -100,7 +100,7 @@ struct vga_switcheroo_handler {
 	int (*switchto)(enum vga_switcheroo_client_id id);
 	int (*power_state)(enum vga_switcheroo_client_id id,
 			   enum vga_switcheroo_state state);
-	int (*get_client_id)(struct pci_dev *pdev);
+	enum vga_switcheroo_client_id (*get_client_id)(struct pci_dev *pdev);
 };
 
 /**
@@ -132,7 +132,7 @@ int vga_switcheroo_register_client(struct pci_dev *dev,
 				   bool driver_power_control);
 int vga_switcheroo_register_audio_client(struct pci_dev *pdev,
 					 const struct vga_switcheroo_client_ops *ops,
-					 int id);
+					 enum vga_switcheroo_client_id id);
 
 void vga_switcheroo_client_fb_set(struct pci_dev *dev,
 				  struct fb_info *info);
@@ -158,7 +158,7 @@ static inline void vga_switcheroo_client_fb_set(struct pci_dev *dev, struct fb_i
 static inline int vga_switcheroo_register_handler(struct vga_switcheroo_handler *handler) { return 0; }
 static inline int vga_switcheroo_register_audio_client(struct pci_dev *pdev,
 	const struct vga_switcheroo_client_ops *ops,
-	int id) { return 0; }
+	enum vga_switcheroo_client_id id) { return 0; }
 static inline void vga_switcheroo_unregister_handler(void) {}
 static inline int vga_switcheroo_process_delayed_switch(void) { return 0; }
 static inline enum vga_switcheroo_state vga_switcheroo_get_client_state(struct pci_dev *dev) { return VGA_SWITCHEROO_ON; }

commit 21c5ba8c1ee02f204e556c26703cebaf9c4019e0
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Aug 28 13:30:32 2015 +0200

    vga_switcheroo: Use VGA_SWITCHEROO_UNKNOWN_ID instead of -1
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index e63661757505..88909a865b72 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -59,6 +59,9 @@ enum vga_switcheroo_state {
 
 /**
  * enum vga_switcheroo_client_id - client identifier
+ * @VGA_SWITCHEROO_UNKNOWN_ID: initial identifier assigned to vga clients.
+ * 	Determining the id requires the handler, so GPUs are given their
+ * 	true id in a delayed fashion in vga_switcheroo_enable()
  * @VGA_SWITCHEROO_IGD: integrated graphics device
  * @VGA_SWITCHEROO_DIS: discrete graphics device
  * @VGA_SWITCHEROO_MAX_CLIENTS: currently no more than two GPUs are supported
@@ -66,6 +69,7 @@ enum vga_switcheroo_state {
  * Client identifier. Audio clients use the same identifier & 0x100.
  */
 enum vga_switcheroo_client_id {
+	VGA_SWITCHEROO_UNKNOWN_ID = -1,
 	VGA_SWITCHEROO_IGD,
 	VGA_SWITCHEROO_DIS,
 	VGA_SWITCHEROO_MAX_CLIENTS,

commit 203d027de4d7068c607b60d4310a1599dec8839f
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Aug 28 11:56:26 2015 +0200

    vga_switcheroo: Use enum vga_switcheroo_state instead of int
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index 376499197717..e63661757505 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -138,7 +138,7 @@ void vga_switcheroo_unregister_handler(void);
 
 int vga_switcheroo_process_delayed_switch(void);
 
-int vga_switcheroo_get_client_state(struct pci_dev *dev);
+enum vga_switcheroo_state vga_switcheroo_get_client_state(struct pci_dev *dev);
 
 void vga_switcheroo_set_dynamic_switch(struct pci_dev *pdev, enum vga_switcheroo_state dynamic);
 
@@ -157,7 +157,7 @@ static inline int vga_switcheroo_register_audio_client(struct pci_dev *pdev,
 	int id) { return 0; }
 static inline void vga_switcheroo_unregister_handler(void) {}
 static inline int vga_switcheroo_process_delayed_switch(void) { return 0; }
-static inline int vga_switcheroo_get_client_state(struct pci_dev *dev) { return VGA_SWITCHEROO_ON; }
+static inline enum vga_switcheroo_state vga_switcheroo_get_client_state(struct pci_dev *dev) { return VGA_SWITCHEROO_ON; }
 
 static inline void vga_switcheroo_set_dynamic_switch(struct pci_dev *pdev, enum vga_switcheroo_state dynamic) {}
 

commit 21b45676b7c4b79334d8fe3c5a112af0517b66e9
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Aug 27 16:43:43 2015 +0200

    vga_switcheroo: Set active attribute to false for audio clients
    
    The active attribute in struct vga_switcheroo_client denotes whether
    the outputs are currently switched to this client. The attribute is
    only meaningful for vga clients. It is never used for audio clients.
    
    The function vga_switcheroo_register_audio_client() misuses this
    attribute to store whether the audio device is fully initialized.
    Most likely there was a misunderstanding about the meaning of
    "active" when this was added.
    
    Comment from Takashi's review:
    
    "Not really.  The full initialization of audio was meant that the audio
    is active indeed.  Admittedly, though, the active flag for each audio
    client doesn't play any role because the audio always follows the gfx
    state changes, and the value passed there doesn't reflect the actual
    state due to the later change.  So, I agree with the removal of the
    flag itself -- or let the audio active flag following the
    corresponding gfx flag.  The latter will make the proc output more
    consistent while the former is certainly more reduction of code."
    
    Set the active attribute to false for audio clients. Remove the
    active parameter from vga_switcheroo_register_audio_client() and
    its sole caller, hda_intel.c:register_vga_switcheroo().
    
    vga_switcheroo_register_audio_client() was introduced by 3e9e63dbd374
    ("vga_switcheroo: Add the support for audio clients"). Its use in
    hda_intel.c was introduced by a82d51ed24bb ("ALSA: hda - Support
    VGA-switcheroo").
    
    v1.1: The changes above imply that in find_active_client() the call
    to client_is_vga() is now superfluous. Drop it.
    
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    [danvet: Add Takashi's clarification to the commit message.]
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index fe90bfc3b510..376499197717 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -128,7 +128,7 @@ int vga_switcheroo_register_client(struct pci_dev *dev,
 				   bool driver_power_control);
 int vga_switcheroo_register_audio_client(struct pci_dev *pdev,
 					 const struct vga_switcheroo_client_ops *ops,
-					 int id, bool active);
+					 int id);
 
 void vga_switcheroo_client_fb_set(struct pci_dev *dev,
 				  struct fb_info *info);
@@ -154,7 +154,7 @@ static inline void vga_switcheroo_client_fb_set(struct pci_dev *dev, struct fb_i
 static inline int vga_switcheroo_register_handler(struct vga_switcheroo_handler *handler) { return 0; }
 static inline int vga_switcheroo_register_audio_client(struct pci_dev *pdev,
 	const struct vga_switcheroo_client_ops *ops,
-	int id, bool active) { return 0; }
+	int id) { return 0; }
 static inline void vga_switcheroo_unregister_handler(void) {}
 static inline int vga_switcheroo_process_delayed_switch(void) { return 0; }
 static inline int vga_switcheroo_get_client_state(struct pci_dev *dev) { return VGA_SWITCHEROO_ON; }

commit a645654b817feba05e5156345325d19fc85ebc9f
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Aug 23 15:18:55 2015 +0200

    vga_switcheroo: Document _ALL_ the things!
    
    This adds an "Overview" DOC section plus two DOC sections for the modes
    of use ("Manual switching and manual power control" and "Driver power
    control").
    
    Also included is kernel-doc for all public functions, structs and enums.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index b483abd34493..fe90bfc3b510 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -1,10 +1,31 @@
 /*
+ * vga_switcheroo.h - Support for laptop with dual GPU using one set of outputs
+ *
  * Copyright (c) 2010 Red Hat Inc.
  * Author : Dave Airlie <airlied@redhat.com>
  *
- * Licensed under GPLv2
+ * Copyright (c) 2015 Lukas Wunner <lukas@wunner.de>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS
+ * IN THE SOFTWARE.
  *
- * vga_switcheroo.h - Support for laptop with dual GPU using one set of outputs
  */
 
 #ifndef _LINUX_VGA_SWITCHEROO_H_
@@ -14,6 +35,20 @@
 
 struct pci_dev;
 
+/**
+ * enum vga_switcheroo_state - client power state
+ * @VGA_SWITCHEROO_OFF: off
+ * @VGA_SWITCHEROO_ON: on
+ * @VGA_SWITCHEROO_INIT: client has registered with vga_switcheroo but
+ * 	vga_switcheroo is not enabled, i.e. no second client or no handler
+ * 	has registered. Only used in vga_switcheroo_get_client_state() which
+ * 	in turn is only called from hda_intel.c
+ * @VGA_SWITCHEROO_NOT_FOUND: client has not registered with vga_switcheroo.
+ * 	Only used in vga_switcheroo_get_client_state() which in turn is only
+ * 	called from hda_intel.c
+ *
+ * Client power state.
+ */
 enum vga_switcheroo_state {
 	VGA_SWITCHEROO_OFF,
 	VGA_SWITCHEROO_ON,
@@ -22,20 +57,64 @@ enum vga_switcheroo_state {
 	VGA_SWITCHEROO_NOT_FOUND,
 };
 
+/**
+ * enum vga_switcheroo_client_id - client identifier
+ * @VGA_SWITCHEROO_IGD: integrated graphics device
+ * @VGA_SWITCHEROO_DIS: discrete graphics device
+ * @VGA_SWITCHEROO_MAX_CLIENTS: currently no more than two GPUs are supported
+ *
+ * Client identifier. Audio clients use the same identifier & 0x100.
+ */
 enum vga_switcheroo_client_id {
 	VGA_SWITCHEROO_IGD,
 	VGA_SWITCHEROO_DIS,
 	VGA_SWITCHEROO_MAX_CLIENTS,
 };
 
+/**
+ * struct vga_switcheroo_handler - handler callbacks
+ * @init: initialize handler.
+ * 	Optional. This gets called when vga_switcheroo is enabled, i.e. when
+ * 	two vga clients have registered. It allows the handler to perform
+ * 	some delayed initialization that depends on the existence of the
+ * 	vga clients. Currently only the radeon and amdgpu drivers use this.
+ * 	The return value is ignored
+ * @switchto: switch outputs to given client.
+ * 	Mandatory. For muxless machines this should be a no-op. Returning 0
+ * 	denotes success, anything else failure (in which case the switch is
+ * 	aborted)
+ * @power_state: cut or reinstate power of given client.
+ * 	Optional. The return value is ignored
+ * @get_client_id: determine if given pci device is integrated or discrete GPU.
+ * 	Mandatory
+ *
+ * Handler callbacks. The multiplexer itself. The @switchto and @get_client_id
+ * methods are mandatory, all others may be set to NULL.
+ */
 struct vga_switcheroo_handler {
+	int (*init)(void);
 	int (*switchto)(enum vga_switcheroo_client_id id);
 	int (*power_state)(enum vga_switcheroo_client_id id,
 			   enum vga_switcheroo_state state);
-	int (*init)(void);
 	int (*get_client_id)(struct pci_dev *pdev);
 };
 
+/**
+ * struct vga_switcheroo_client_ops - client callbacks
+ * @set_gpu_state: do the equivalent of suspend/resume for the card.
+ * 	Mandatory. This should not cut power to the discrete GPU,
+ * 	which is the job of the handler
+ * @reprobe: poll outputs.
+ * 	Optional. This gets called after waking the GPU and switching
+ * 	the outputs to it
+ * @can_switch: check if the device is in a position to switch now.
+ * 	Mandatory. The client should return false if a user space process
+ * 	has one of its device files open
+ *
+ * Client callbacks. A client can be either a GPU or an audio device on a GPU.
+ * The @set_gpu_state and @can_switch methods are mandatory, @reprobe may be
+ * set to NULL. For audio clients, the @reprobe member is bogus.
+ */
 struct vga_switcheroo_client_ops {
 	void (*set_gpu_state)(struct pci_dev *dev, enum vga_switcheroo_state);
 	void (*reprobe)(struct pci_dev *dev);

commit 766a53d059d1500c9755c8af017bd411bd8f1b20
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Sep 12 17:51:29 2014 -0400

    vgaswitcheroo: add vga_switcheroo_fini_domain_pm_ops
    
    Drivers should call this on unload to unregister pmops.
    
    Bug:
    https://bugzilla.kernel.org/show_bug.cgi?id=84431
    
    Reviewed-by: Ben Skeggs <bskeggs@redhat.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Pali Rohár <pali.rohar@gmail.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index 502073a53dd3..b483abd34493 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -64,6 +64,7 @@ int vga_switcheroo_get_client_state(struct pci_dev *dev);
 void vga_switcheroo_set_dynamic_switch(struct pci_dev *pdev, enum vga_switcheroo_state dynamic);
 
 int vga_switcheroo_init_domain_pm_ops(struct device *dev, struct dev_pm_domain *domain);
+void vga_switcheroo_fini_domain_pm_ops(struct device *dev);
 int vga_switcheroo_init_domain_pm_optimus_hdmi_audio(struct device *dev, struct dev_pm_domain *domain);
 #else
 
@@ -82,6 +83,7 @@ static inline int vga_switcheroo_get_client_state(struct pci_dev *dev) { return
 static inline void vga_switcheroo_set_dynamic_switch(struct pci_dev *pdev, enum vga_switcheroo_state dynamic) {}
 
 static inline int vga_switcheroo_init_domain_pm_ops(struct device *dev, struct dev_pm_domain *domain) { return -EINVAL; }
+static inline void vga_switcheroo_fini_domain_pm_ops(struct device *dev) {}
 static inline int vga_switcheroo_init_domain_pm_optimus_hdmi_audio(struct device *dev, struct dev_pm_domain *domain) { return -EINVAL; }
 
 #endif

commit 0d69704ae348c03bc216b01e32a0e9a2372be419
Author: Dave Airlie <airlied@dhcp-40-90.bne.redhat.com>
Date:   Mon Sep 10 12:28:36 2012 +1000

    gpu/vga_switcheroo: add driver control power feature. (v3)
    
    For optimus and powerxpress muxless we really want the GPU
    driver deciding when to power up/down the GPU, not userspace.
    
    This adds the ability for a driver to dynamically power up/down
    the GPU and remove the switcheroo from controlling it, the
    switcheroo reports the dynamic state to userspace also.
    
    It also adds 2 power domains, one for machine where the power
    switch is controlled outside the GPU D3 state, so the powerdown
    ordering is done correctly, and the second for the hdmi audio
    device to make sure it can resume for PCI config space accesses.
    
    v1.1: fix build with switcheroo off
    
    v2: add power domain support for radeon and v1 nvidia dsms
    v2.1: fix typo in off case
    
    v3: add audio power domain for hdmi audio + misc audio fixes
    
    v4: use PCI_SLOT macro, drop power reference on hdmi audio resume
    failure also.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index ddb419cf4530..502073a53dd3 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -45,7 +45,8 @@ struct vga_switcheroo_client_ops {
 #if defined(CONFIG_VGA_SWITCHEROO)
 void vga_switcheroo_unregister_client(struct pci_dev *dev);
 int vga_switcheroo_register_client(struct pci_dev *dev,
-				   const struct vga_switcheroo_client_ops *ops);
+				   const struct vga_switcheroo_client_ops *ops,
+				   bool driver_power_control);
 int vga_switcheroo_register_audio_client(struct pci_dev *pdev,
 					 const struct vga_switcheroo_client_ops *ops,
 					 int id, bool active);
@@ -60,11 +61,15 @@ int vga_switcheroo_process_delayed_switch(void);
 
 int vga_switcheroo_get_client_state(struct pci_dev *dev);
 
+void vga_switcheroo_set_dynamic_switch(struct pci_dev *pdev, enum vga_switcheroo_state dynamic);
+
+int vga_switcheroo_init_domain_pm_ops(struct device *dev, struct dev_pm_domain *domain);
+int vga_switcheroo_init_domain_pm_optimus_hdmi_audio(struct device *dev, struct dev_pm_domain *domain);
 #else
 
 static inline void vga_switcheroo_unregister_client(struct pci_dev *dev) {}
 static inline int vga_switcheroo_register_client(struct pci_dev *dev,
-		const struct vga_switcheroo_client_ops *ops) { return 0; }
+		const struct vga_switcheroo_client_ops *ops, bool driver_power_control) { return 0; }
 static inline void vga_switcheroo_client_fb_set(struct pci_dev *dev, struct fb_info *info) {}
 static inline int vga_switcheroo_register_handler(struct vga_switcheroo_handler *handler) { return 0; }
 static inline int vga_switcheroo_register_audio_client(struct pci_dev *pdev,
@@ -74,6 +79,10 @@ static inline void vga_switcheroo_unregister_handler(void) {}
 static inline int vga_switcheroo_process_delayed_switch(void) { return 0; }
 static inline int vga_switcheroo_get_client_state(struct pci_dev *dev) { return VGA_SWITCHEROO_ON; }
 
+static inline void vga_switcheroo_set_dynamic_switch(struct pci_dev *pdev, enum vga_switcheroo_state dynamic) {}
+
+static inline int vga_switcheroo_init_domain_pm_ops(struct device *dev, struct dev_pm_domain *domain) { return -EINVAL; }
+static inline int vga_switcheroo_init_domain_pm_optimus_hdmi_audio(struct device *dev, struct dev_pm_domain *domain) { return -EINVAL; }
 
 #endif
 #endif /* _LINUX_VGA_SWITCHEROO_H_ */

commit d3decf3a0c1d28c80c76be170373f4c7a7217f09
Author: Ozan Çağlayan <ozancag@gmail.com>
Date:   Thu Jun 14 15:02:35 2012 +0300

    vga_switcheroo: Add include guard
    
    Guard vga_switcheroo.h against multiple inclusion.
    
    Signed-off-by: Ozan Çağlayan <ozancag@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index d844b7790ea6..ddb419cf4530 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -7,6 +7,9 @@
  * vga_switcheroo.h - Support for laptop with dual GPU using one set of outputs
  */
 
+#ifndef _LINUX_VGA_SWITCHEROO_H_
+#define _LINUX_VGA_SWITCHEROO_H_
+
 #include <linux/fb.h>
 
 struct pci_dev;
@@ -73,3 +76,4 @@ static inline int vga_switcheroo_get_client_state(struct pci_dev *dev) { return
 
 
 #endif
+#endif /* _LINUX_VGA_SWITCHEROO_H_ */

commit f8fee8f5acb5c3f82e02f2ae139a6f1e7b4eb583
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Fri Jun 15 12:46:17 2012 -0700

    vga_switcheroo.h: fix pci_dev warning
    
    Fix warnings on some architectures/configs (not on x86):
    
    include/linux/vga_switcheroo.h:28:30: warning: 'struct pci_dev' declared inside parameter list [enabled by default]
    include/linux/vga_switcheroo.h:28:30: warning: its scope is only this definition or declaration, which is probably not what you want [enabled by default]
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Cc:     Takashi Iwai <tiwai@suse.de>
    Reported-by:    Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index 60da41fe9dc2..d844b7790ea6 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -9,6 +9,8 @@
 
 #include <linux/fb.h>
 
+struct pci_dev;
+
 enum vga_switcheroo_state {
 	VGA_SWITCHEROO_OFF,
 	VGA_SWITCHEROO_ON,

commit 505cff00de9c303b95c204eb4544066e3e707911
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 8 12:49:17 2012 +0200

    vga_switcheroo: Fix error without CONFIG_VGA_SWITCHEROO
    
    Fix a typo that is built only when CONFIG_VGA_SWITCHEROO=n.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index b176342ca031..60da41fe9dc2 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -67,7 +67,7 @@ static inline int vga_switcheroo_register_audio_client(struct pci_dev *pdev,
 	int id, bool active) { return 0; }
 static inline void vga_switcheroo_unregister_handler(void) {}
 static inline int vga_switcheroo_process_delayed_switch(void) { return 0; }
-static inline int vga_switcheroo_get_client_state(struct pci_dev *dev) { return VGA_SWITCHEROO_CLIENT_ON; }
+static inline int vga_switcheroo_get_client_state(struct pci_dev *dev) { return VGA_SWITCHEROO_ON; }
 
 
 #endif

commit c8e9cf7bb240049117d2fa64d1540476c289396d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jun 7 12:15:15 2012 +0200

    vga_switcheroo: Add a helper function to get the client state
    
    Add vga_switcheroo_get_client_state() to get the current state of the
    client.  This is necessary to determine the proper initial state of
    audio clients in HD-audio driver.
    
    Acked-by: Dave Airlie <airlied@redhat.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index b455c7c212eb..b176342ca031 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -12,6 +12,9 @@
 enum vga_switcheroo_state {
 	VGA_SWITCHEROO_OFF,
 	VGA_SWITCHEROO_ON,
+	/* below are referred only from vga_switcheroo_get_client_state() */
+	VGA_SWITCHEROO_INIT,
+	VGA_SWITCHEROO_NOT_FOUND,
 };
 
 enum vga_switcheroo_client_id {
@@ -50,6 +53,8 @@ void vga_switcheroo_unregister_handler(void);
 
 int vga_switcheroo_process_delayed_switch(void);
 
+int vga_switcheroo_get_client_state(struct pci_dev *dev);
+
 #else
 
 static inline void vga_switcheroo_unregister_client(struct pci_dev *dev) {}
@@ -62,5 +67,7 @@ static inline int vga_switcheroo_register_audio_client(struct pci_dev *pdev,
 	int id, bool active) { return 0; }
 static inline void vga_switcheroo_unregister_handler(void) {}
 static inline int vga_switcheroo_process_delayed_switch(void) { return 0; }
+static inline int vga_switcheroo_get_client_state(struct pci_dev *dev) { return VGA_SWITCHEROO_CLIENT_ON; }
+
 
 #endif

commit 3e9e63dbd3745ba9ea10f0f86c93f4086c89d5b8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Apr 26 14:29:48 2012 +0200

    vga_switcheroo: Add the support for audio clients
    
    Add the support for audio clients to VGA-switcheroo for handling the
    HDMI audio controller together with VGA switching.  The id of the
    audio controller should be given explicitly at registration time
    unlike the video controller.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=43155
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index 3c54ebc2e529..b455c7c212eb 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -38,6 +38,9 @@ struct vga_switcheroo_client_ops {
 void vga_switcheroo_unregister_client(struct pci_dev *dev);
 int vga_switcheroo_register_client(struct pci_dev *dev,
 				   const struct vga_switcheroo_client_ops *ops);
+int vga_switcheroo_register_audio_client(struct pci_dev *pdev,
+					 const struct vga_switcheroo_client_ops *ops,
+					 int id, bool active);
 
 void vga_switcheroo_client_fb_set(struct pci_dev *dev,
 				  struct fb_info *info);
@@ -54,6 +57,9 @@ static inline int vga_switcheroo_register_client(struct pci_dev *dev,
 		const struct vga_switcheroo_client_ops *ops) { return 0; }
 static inline void vga_switcheroo_client_fb_set(struct pci_dev *dev, struct fb_info *info) {}
 static inline int vga_switcheroo_register_handler(struct vga_switcheroo_handler *handler) { return 0; }
+static inline int vga_switcheroo_register_audio_client(struct pci_dev *pdev,
+	const struct vga_switcheroo_client_ops *ops,
+	int id, bool active) { return 0; }
 static inline void vga_switcheroo_unregister_handler(void) {}
 static inline int vga_switcheroo_process_delayed_switch(void) { return 0; }
 

commit 26ec685ff9d9c16525d8ec4c97e52fcdb187b302
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri May 11 07:51:17 2012 +0200

    vga_switcheroo: Introduce struct vga_switcheroo_client_ops
    
    This changes the API as a clean-up.  Instead of passing multiple
    function pointers at each time, introduce a new struct holding the
    whole callback functions and pass it to the registration.
    
    The same struct will be used for the upcoming audio client
    registration, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index 4b9a7f596f92..3c54ebc2e529 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -28,13 +28,16 @@ struct vga_switcheroo_handler {
 	int (*get_client_id)(struct pci_dev *pdev);
 };
 
+struct vga_switcheroo_client_ops {
+	void (*set_gpu_state)(struct pci_dev *dev, enum vga_switcheroo_state);
+	void (*reprobe)(struct pci_dev *dev);
+	bool (*can_switch)(struct pci_dev *dev);
+};
 
 #if defined(CONFIG_VGA_SWITCHEROO)
 void vga_switcheroo_unregister_client(struct pci_dev *dev);
 int vga_switcheroo_register_client(struct pci_dev *dev,
-				   void (*set_gpu_state)(struct pci_dev *dev, enum vga_switcheroo_state),
-				   void (*reprobe)(struct pci_dev *dev),
-				   bool (*can_switch)(struct pci_dev *dev));
+				   const struct vga_switcheroo_client_ops *ops);
 
 void vga_switcheroo_client_fb_set(struct pci_dev *dev,
 				  struct fb_info *info);
@@ -48,9 +51,7 @@ int vga_switcheroo_process_delayed_switch(void);
 
 static inline void vga_switcheroo_unregister_client(struct pci_dev *dev) {}
 static inline int vga_switcheroo_register_client(struct pci_dev *dev,
-					  void (*set_gpu_state)(struct pci_dev *dev, enum vga_switcheroo_state),
-					  void (*reprobe)(struct pci_dev *dev),
-					  bool (*can_switch)(struct pci_dev *dev)) { return 0; }
+		const struct vga_switcheroo_client_ops *ops) { return 0; }
 static inline void vga_switcheroo_client_fb_set(struct pci_dev *dev, struct fb_info *info) {}
 static inline int vga_switcheroo_register_handler(struct vga_switcheroo_handler *handler) { return 0; }
 static inline void vga_switcheroo_unregister_handler(void) {}

commit af5dd83b873efd4e1477f2265b6fa15a825aff26
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jan 6 13:04:32 2011 +1000

    vga_switcheroo: fix build with non switcheroo enabled path.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index f80fa9de5b82..4b9a7f596f92 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -49,6 +49,7 @@ int vga_switcheroo_process_delayed_switch(void);
 static inline void vga_switcheroo_unregister_client(struct pci_dev *dev) {}
 static inline int vga_switcheroo_register_client(struct pci_dev *dev,
 					  void (*set_gpu_state)(struct pci_dev *dev, enum vga_switcheroo_state),
+					  void (*reprobe)(struct pci_dev *dev),
 					  bool (*can_switch)(struct pci_dev *dev)) { return 0; }
 static inline void vga_switcheroo_client_fb_set(struct pci_dev *dev, struct fb_info *info) {}
 static inline int vga_switcheroo_register_handler(struct vga_switcheroo_handler *handler) { return 0; }

commit 8d608aa6295242fe4c4b6105b8c59c6a5b232d89
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Dec 7 08:57:57 2010 +1000

    vga_switcheroo: add reprobe hook for fbcon to recheck connected outputs.
    
    This adds a hook after the mux is switched for the driver to reprobe
    the connected outputs.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index ae9ab13b963d..f80fa9de5b82 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -33,6 +33,7 @@ struct vga_switcheroo_handler {
 void vga_switcheroo_unregister_client(struct pci_dev *dev);
 int vga_switcheroo_register_client(struct pci_dev *dev,
 				   void (*set_gpu_state)(struct pci_dev *dev, enum vga_switcheroo_state),
+				   void (*reprobe)(struct pci_dev *dev),
 				   bool (*can_switch)(struct pci_dev *dev));
 
 void vga_switcheroo_client_fb_set(struct pci_dev *dev,

commit 8edb381d6705811b278527907a5ae2a9c4db8074
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Mar 1 21:50:01 2010 +1100

    vga_switcheroo: fix build on platforms with no ACPI
    
    radeon was always including the atpx code unnecessarily, also core
    switcheroo was including acpi headers.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
index 4b58ab1e8612..ae9ab13b963d 100644
--- a/include/linux/vga_switcheroo.h
+++ b/include/linux/vga_switcheroo.h
@@ -7,7 +7,6 @@
  * vga_switcheroo.h - Support for laptop with dual GPU using one set of outputs
  */
 
-#include <acpi/acpi.h>
 #include <linux/fb.h>
 
 enum vga_switcheroo_state {

commit 6a9ee8af344e3bd7dbd61e67037096cdf7f83289
Author: Dave Airlie <airlied@linux.ie>
Date:   Mon Feb 1 15:38:10 2010 +1000

    vga_switcheroo: initial implementation (v15)
    
    Many new laptops now come with 2 gpus, one to be used for low power
    modes and one for gaming/on-ac applications. These GPUs are typically
    wired to the laptop panel and VGA ports via a multiplexer unit which
    is controlled via ACPI methods.
    
    4 combinations of systems typically exist - with 2 ACPI methods.
    Intel/ATI - Lenovo W500/T500 - use ATPX ACPI method
    ATI/ATI - some ASUS - use ATPX ACPI Method
    Intel/Nvidia - - use _DSM ACPI method
    Nvidia/Nvidia -  - use _DSM ACPI method.
    
    TODO:
    This patch adds support for the ATPX method and initial bits
    for the _DSM methods that need to written by someone with
    access to the hardware.
    Add a proper non-debugfs interface - need to get some proper
    testing first.
    
    v2: add power up/down support for both devices
    on W500 puts i915/radeon into D3 and cuts power to radeon.
    
    v3: redo probing methods, no DMI list, drm devices call to
    register with switcheroo, it tries to find an ATPX method on
    any device and once there is two devices + ATPX it inits the
    switcher.
    
    v4: ATPX msg handling using buffers - should work on more machines
    
    v5: rearchitect after more mjg59 discussion - move ATPX handling to
        radeon driver.
    
    v6: add file headers + initial nouveau bits (to be filled out).
    
    v7: merge delayed switcher code.
    
    v8: avoid suspend/resume of gpu that is off
    
    v9: rearchitect - mjg59 is always right. - move all ATPX code to
    radeon, should allow simpler DSM also proper ATRM handling
    
    v10: add ATRM support for radeon BIOS, add mutex to lock vgasr_priv
    
    v11: fix bug in resuming Intel for 2nd time.
    
    v12: start fixing up nvidia code blindly.
    
    v13: blindly guess at finishing nvidia code
    
    v14: remove radeon audio hacks - fix up intel resume more like upstream
    
    v15: clean up printks + remove unnecessary igd/dis pointers
    
    mount debugfs
    
    /sys/kernel/debug/vgaswitcheroo/switch - should exist if ATPX detected
     + 2 cards.
    
    DIS - immediate change to discrete
    IGD - immediate change to IGD
    DDIS - delayed change to discrete
    DIGD - delayed change to IGD
    ON - turn on not in use
    OFF - turn off not in use
    
    Tested on W500 (Intel/ATI) and T500 (Intel/ATI)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/linux/vga_switcheroo.h b/include/linux/vga_switcheroo.h
new file mode 100644
index 000000000000..4b58ab1e8612
--- /dev/null
+++ b/include/linux/vga_switcheroo.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2010 Red Hat Inc.
+ * Author : Dave Airlie <airlied@redhat.com>
+ *
+ * Licensed under GPLv2
+ *
+ * vga_switcheroo.h - Support for laptop with dual GPU using one set of outputs
+ */
+
+#include <acpi/acpi.h>
+#include <linux/fb.h>
+
+enum vga_switcheroo_state {
+	VGA_SWITCHEROO_OFF,
+	VGA_SWITCHEROO_ON,
+};
+
+enum vga_switcheroo_client_id {
+	VGA_SWITCHEROO_IGD,
+	VGA_SWITCHEROO_DIS,
+	VGA_SWITCHEROO_MAX_CLIENTS,
+};
+
+struct vga_switcheroo_handler {
+	int (*switchto)(enum vga_switcheroo_client_id id);
+	int (*power_state)(enum vga_switcheroo_client_id id,
+			   enum vga_switcheroo_state state);
+	int (*init)(void);
+	int (*get_client_id)(struct pci_dev *pdev);
+};
+
+
+#if defined(CONFIG_VGA_SWITCHEROO)
+void vga_switcheroo_unregister_client(struct pci_dev *dev);
+int vga_switcheroo_register_client(struct pci_dev *dev,
+				   void (*set_gpu_state)(struct pci_dev *dev, enum vga_switcheroo_state),
+				   bool (*can_switch)(struct pci_dev *dev));
+
+void vga_switcheroo_client_fb_set(struct pci_dev *dev,
+				  struct fb_info *info);
+
+int vga_switcheroo_register_handler(struct vga_switcheroo_handler *handler);
+void vga_switcheroo_unregister_handler(void);
+
+int vga_switcheroo_process_delayed_switch(void);
+
+#else
+
+static inline void vga_switcheroo_unregister_client(struct pci_dev *dev) {}
+static inline int vga_switcheroo_register_client(struct pci_dev *dev,
+					  void (*set_gpu_state)(struct pci_dev *dev, enum vga_switcheroo_state),
+					  bool (*can_switch)(struct pci_dev *dev)) { return 0; }
+static inline void vga_switcheroo_client_fb_set(struct pci_dev *dev, struct fb_info *info) {}
+static inline int vga_switcheroo_register_handler(struct vga_switcheroo_handler *handler) { return 0; }
+static inline void vga_switcheroo_unregister_handler(void) {}
+static inline int vga_switcheroo_process_delayed_switch(void) { return 0; }
+
+#endif
