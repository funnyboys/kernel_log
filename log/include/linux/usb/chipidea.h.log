commit d755cdb1b9d7e1b645e176b97eb137194bbe8cf9
Author: Peter Chen <peter.chen@nxp.com>
Date:   Thu Jan 23 14:00:26 2020 +0800

    usb: chipidea: introduce CI_HDRC_CONTROLLER_VBUS_EVENT glue layer use
    
    Some vendors glue layer need to handle some events for vbus, eg,
    some i.mx platforms (imx7d, imx8mm, imx8mn, etc) needs vbus event
    to handle charger detection, its charger detection is finished at
    glue layer code, but not at USB PHY driver.
    
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index edd89b7c8f18..54167a2d28ea 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -67,6 +67,7 @@ struct ci_hdrc_platform_data {
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1
 #define CI_HDRC_IMX_HSIC_ACTIVE_EVENT		2
 #define CI_HDRC_IMX_HSIC_SUSPEND_EVENT		3
+#define CI_HDRC_CONTROLLER_VBUS_EVENT		4
 	int	(*notify_event) (struct ci_hdrc *ci, unsigned event);
 	struct regulator	*reg_vbus;
 	struct usb_otg_caps	ci_otg_caps;

commit d1609c312d42f3bdfe7df9d4dd9d5b2c7ace90f4
Author: Peter Chen <peter.chen@nxp.com>
Date:   Sun Apr 28 10:35:31 2019 +0800

    usb: chipidea: imx: add imx7ulp support
    
    In this commit, we add CI_HDRC_PMQOS to avoid system entering idle,
    at imx7ulp, if the system enters idle, the DMA will stop, so the USB
    transfer can't work at this case.
    
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index 911e05af671e..edd89b7c8f18 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -61,6 +61,7 @@ struct ci_hdrc_platform_data {
 #define CI_HDRC_OVERRIDE_PHY_CONTROL	BIT(12) /* Glue layer manages phy */
 #define CI_HDRC_REQUIRES_ALIGNED_DMA	BIT(13)
 #define CI_HDRC_IMX_IS_HSIC		BIT(14)
+#define CI_HDRC_PMQOS			BIT(15)
 	enum usb_dr_mode	dr_mode;
 #define CI_HDRC_CONTROLLER_RESET_EVENT		0
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1

commit 014abe34a9095daaa6cbb2693ee90bbb54674693
Author: Peter Chen <peter.chen@nxp.com>
Date:   Mon Oct 15 17:02:57 2018 +0800

    usb: chipidea: add flag for imx hsic implementation
    
    NXP (Freecale) imx HSIC design has some special requirements, add
    some flags at host code to handle them.
    
    Reviewed-by: Frieder Schrempf <frieder.schrempf@kontron.de>
    Tested-by: Frieder Schrempf <frieder.schrempf@kontron.de>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index 63758c399e4e..911e05af671e 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -60,9 +60,12 @@ struct ci_hdrc_platform_data {
 #define CI_HDRC_OVERRIDE_RX_BURST	BIT(11)
 #define CI_HDRC_OVERRIDE_PHY_CONTROL	BIT(12) /* Glue layer manages phy */
 #define CI_HDRC_REQUIRES_ALIGNED_DMA	BIT(13)
+#define CI_HDRC_IMX_IS_HSIC		BIT(14)
 	enum usb_dr_mode	dr_mode;
 #define CI_HDRC_CONTROLLER_RESET_EVENT		0
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1
+#define CI_HDRC_IMX_HSIC_ACTIVE_EVENT		2
+#define CI_HDRC_IMX_HSIC_SUSPEND_EVENT		3
 	int	(*notify_event) (struct ci_hdrc *ci, unsigned event);
 	struct regulator	*reg_vbus;
 	struct usb_otg_caps	ci_otg_caps;

commit 16caf1fa37db4722d8d8c7bc26177279949d75a6
Author: Loic Poulain <loic.poulain@linaro.org>
Date:   Tue Sep 4 17:18:55 2018 +0200

    usb: chipidea: Add dynamic pinctrl selection
    
    Some hardware implementations require to configure pins differently
    according to the USB role (host/device), this can be an update of the
    pins routing or a simple GPIO value change.
    
    This patch introduces new optional "host" and "device" pinctrls.
    If these pinctrls are defined by the device, they are respectively
    selected on host/device role start.
    
    If a default pinctrl exist, it is restored on host/device role stop.
    
    Signed-off-by: Loic Poulain <loic.poulain@linaro.org>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index 07f99362bc90..63758c399e4e 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -77,6 +77,12 @@ struct ci_hdrc_platform_data {
 	struct ci_hdrc_cable		vbus_extcon;
 	struct ci_hdrc_cable		id_extcon;
 	u32			phy_clkgate_delay_us;
+
+	/* pins */
+	struct pinctrl *pctl;
+	struct pinctrl_state *pins_default;
+	struct pinctrl_state *pins_host;
+	struct pinctrl_state *pins_device;
 };
 
 /* Default offset of capability registers */

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index d725cff7268d..07f99362bc90 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Platform data for the chipidea USB dual role controller
  */

commit 581821ae7f7e2c4547945c65f1bcd357f5915aa5
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Wed Aug 16 13:32:39 2017 +0300

    usb: chipidea: udc: Support SKB alignment quirk
    
    NVIDIA Tegra20 UDC can't cope with unaligned DMA and require a USB gadget
    quirk that avoids SKB buffer alignment to be set in order to make Ethernet
    Gadget working. Later Tegra generations do not require that quirk. Let's
    add a new platform data flag that allows to enable USB gadget quirk for
    platforms that require it.
    
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Acked-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index c5fdfcf99828..d725cff7268d 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -58,6 +58,7 @@ struct ci_hdrc_platform_data {
 #define CI_HDRC_OVERRIDE_TX_BURST	BIT(10)
 #define CI_HDRC_OVERRIDE_RX_BURST	BIT(11)
 #define CI_HDRC_OVERRIDE_PHY_CONTROL	BIT(12) /* Glue layer manages phy */
+#define CI_HDRC_REQUIRES_ALIGNED_DMA	BIT(13)
 	enum usb_dr_mode	dr_mode;
 #define CI_HDRC_CONTROLLER_RESET_EVENT		0
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1

commit 11893dae63da0f5b251cf7f9a24d64c8ff4771ff
Author: Stephen Boyd <stephen.boyd@linaro.org>
Date:   Wed Dec 28 14:57:06 2016 -0800

    usb: chipidea: msm: Handle phy power states
    
    The ULPI phy on qcom platforms needs to be initialized and
    powered on after a USB reset and before we toggle the run/stop
    bit. Otherwise, the phy locks up and doesn't work properly. Hook
    the phy initialization into the RESET event and the phy power off
    into the STOPPED event.
    
    Acked-by: Peter Chen <peter.chen@nxp.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Stephen Boyd <stephen.boyd@linaro.org>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index 7e3daa37cf60..c5fdfcf99828 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -61,7 +61,7 @@ struct ci_hdrc_platform_data {
 	enum usb_dr_mode	dr_mode;
 #define CI_HDRC_CONTROLLER_RESET_EVENT		0
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1
-	void	(*notify_event) (struct ci_hdrc *ci, unsigned event);
+	int	(*notify_event) (struct ci_hdrc *ci, unsigned event);
 	struct regulator	*reg_vbus;
 	struct usb_otg_caps	ci_otg_caps;
 	bool			tpl_support;

commit 5cc49268995a1f063a7a569299393e4cf9d06923
Author: Stephen Boyd <stephen.boyd@linaro.org>
Date:   Fri Jan 20 15:11:55 2017 +0800

    usb: chipidea: Consolidate extcon notifiers
    
    The two extcon notifiers are almost the same except for the
    variable name for the cable structure and the id notifier inverts
    the cable->state logic. Make it the same and replace two
    functions with one to save some lines. This also makes it so that
    the id cable state is true when the id pin is pulled low, so we
    change the name of ->state to ->connected to properly reflect
    that we're interested in the cable being connected.
    
    Acked-by: Peter Chen <peter.chen@nxp.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Ivan T. Ivanov" <iivanov.xz@gmail.com>
    Signed-off-by: Stephen Boyd <stephen.boyd@linaro.org>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index d07b162073f7..7e3daa37cf60 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -12,7 +12,7 @@ struct ci_hdrc;
 
 /**
  * struct ci_hdrc_cable - structure for external connector cable state tracking
- * @state: current state of the line
+ * @connected: true if cable is connected, false otherwise
  * @changed: set to true when extcon event happen
  * @enabled: set to true if we've enabled the vbus or id interrupt
  * @edev: device which generate events
@@ -21,7 +21,7 @@ struct ci_hdrc;
  * @conn: used for notification registration
  */
 struct ci_hdrc_cable {
-	bool				state;
+	bool				connected;
 	bool				changed;
 	bool				enabled;
 	struct extcon_dev		*edev;

commit 8feb3680bd0363a8d784fa0d065e0a6cdc9e0cff
Author: Stephen Boyd <stephen.boyd@linaro.org>
Date:   Wed Dec 28 14:56:52 2016 -0800

    usb: chipidea: Add platform flag for wrapper phy management
    
    The ULPI phy on qcom platforms needs to be initialized and
    powered on after a USB reset and before we toggle the run/stop
    bit. Otherwise, the phy locks up and doesn't work properly.
    Therefore, add a flag to skip any phy power management in the
    core layer, leaving it up to the glue driver to manage.
    
    Acked-by: Peter Chen <peter.chen@nxp.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Stephen Boyd <stephen.boyd@linaro.org>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index f9be467d6695..d07b162073f7 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -57,6 +57,7 @@ struct ci_hdrc_platform_data {
 #define CI_HDRC_OVERRIDE_AHB_BURST	BIT(9)
 #define CI_HDRC_OVERRIDE_TX_BURST	BIT(10)
 #define CI_HDRC_OVERRIDE_RX_BURST	BIT(11)
+#define CI_HDRC_OVERRIDE_PHY_CONTROL	BIT(12) /* Glue layer manages phy */
 	enum usb_dr_mode	dr_mode;
 #define CI_HDRC_CONTROLLER_RESET_EVENT		0
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1

commit a89b94b53371bbfa582787c2fa3378000ea4263d
Author: Stephen Boyd <stephen.boyd@linaro.org>
Date:   Wed Dec 28 14:56:51 2016 -0800

    usb: chipidea: Handle extcon events properly
    
    We're currently emulating the vbus and id interrupts in the OTGSC
    read API, but we also need to make sure that if we're handling
    the events with extcon that we don't enable the interrupts for
    those events in the hardware. Therefore, properly emulate this
    register if we're using extcon, but don't enable the interrupts.
    This allows me to get my cable connect/disconnect working
    properly without getting spurious interrupts on my device that
    uses an extcon for these two events.
    
    Acked-by: Peter Chen <peter.chen@nxp.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Ivan T. Ivanov" <iivanov.xz@gmail.com>
    Fixes: 3ecb3e09b042 ("usb: chipidea: Use extcon framework for VBUS and ID detect")
    Signed-off-by: Stephen Boyd <stephen.boyd@linaro.org>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index 5dd75fa47dd8..f9be467d6695 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -14,6 +14,7 @@ struct ci_hdrc;
  * struct ci_hdrc_cable - structure for external connector cable state tracking
  * @state: current state of the line
  * @changed: set to true when extcon event happen
+ * @enabled: set to true if we've enabled the vbus or id interrupt
  * @edev: device which generate events
  * @ci: driver state of the chipidea device
  * @nb: hold event notification callback
@@ -22,6 +23,7 @@ struct ci_hdrc;
 struct ci_hdrc_cable {
 	bool				state;
 	bool				changed;
+	bool				enabled;
 	struct extcon_dev		*edev;
 	struct ci_hdrc			*ci;
 	struct notifier_block		nb;

commit 1fbf46280eb6866c762de5ec8ba35f09097b0d53
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Tue Sep 8 22:18:14 2015 -0300

    usb: chipidea: Add support for 'phy-clkgate-delay-us' property
    
    Add support for the optional 'phy-clkgate-delay-us' property that is
    used to describe the delay time between putting PHY into low power mode
    and turning off the PHY clock.
    
    Signed-off-by: Li Jun <jun.li@freescale.com>
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index c5cddc6901d0..5dd75fa47dd8 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -71,6 +71,7 @@ struct ci_hdrc_platform_data {
 	/* VBUS and ID signal state tracking, using extcon framework */
 	struct ci_hdrc_cable		vbus_extcon;
 	struct ci_hdrc_cable		id_extcon;
+	u32			phy_clkgate_delay_us;
 };
 
 /* Default offset of capability registers */

commit 3ecb3e09b042e70799ff3a1ff464a5ecaa7547d9
Author: Ivan T. Ivanov <ivan.ivanov@linaro.org>
Date:   Mon Sep 7 14:45:25 2015 +0300

    usb: chipidea: Use extcon framework for VBUS and ID detect
    
    On recent Qualcomm platforms VBUS and ID lines are not routed to
    USB PHY LINK controller. Use extcon framework to receive connect
    and disconnect ID and VBUS notification.
    
    Signed-off-by: Ivan T. Ivanov <ivan.ivanov@linaro.org>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index a41833cd184c..c5cddc6901d0 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -5,9 +5,28 @@
 #ifndef __LINUX_USB_CHIPIDEA_H
 #define __LINUX_USB_CHIPIDEA_H
 
+#include <linux/extcon.h>
 #include <linux/usb/otg.h>
 
 struct ci_hdrc;
+
+/**
+ * struct ci_hdrc_cable - structure for external connector cable state tracking
+ * @state: current state of the line
+ * @changed: set to true when extcon event happen
+ * @edev: device which generate events
+ * @ci: driver state of the chipidea device
+ * @nb: hold event notification callback
+ * @conn: used for notification registration
+ */
+struct ci_hdrc_cable {
+	bool				state;
+	bool				changed;
+	struct extcon_dev		*edev;
+	struct ci_hdrc			*ci;
+	struct notifier_block		nb;
+};
+
 struct ci_hdrc_platform_data {
 	const char	*name;
 	/* offset of the capability registers */
@@ -48,6 +67,10 @@ struct ci_hdrc_platform_data {
 	u32			ahb_burst_config;
 	u32			tx_burst_size;
 	u32			rx_burst_size;
+
+	/* VBUS and ID signal state tracking, using extcon framework */
+	struct ci_hdrc_cable		vbus_extcon;
+	struct ci_hdrc_cable		id_extcon;
 };
 
 /* Default offset of capability registers */

commit 37a842d36f63a047d94be2603d40d4407c949f1b
Merge: a3fbedf98fe9 96625eadca1b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Aug 14 16:43:09 2015 -0700

    Merge tag 'usb-ci-v4.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/peter.chen/usb into usb-next
    
    Peter writes:
    
    USB: chipidea updates for v4.3-rc1
    
    The main changes are adding several system interfaces for
    tuning performance, and each vendors can adjust them according
    to their design configurations.
    
    Others are tiny improvements, like more well siTD supports,
    USB_DEVICE_A_HNP_SUPPORT supports, etc.

commit 96625eadca1bb8832fb502f0899a543695f1ba35
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Mar 17 17:32:45 2015 +0800

    usb: chipidea: add tx/rx burst size configuration interface
    
    The user can adjust it through dts or platform data
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index cd7fcad49017..575eaf0ebac1 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -34,6 +34,8 @@ struct ci_hdrc_platform_data {
 #define CI_HDRC_TURN_VBUS_EARLY_ON	BIT(7)
 #define CI_HDRC_SET_NON_ZERO_TTHA	BIT(8)
 #define CI_HDRC_OVERRIDE_AHB_BURST	BIT(9)
+#define CI_HDRC_OVERRIDE_TX_BURST	BIT(10)
+#define CI_HDRC_OVERRIDE_RX_BURST	BIT(11)
 	enum usb_dr_mode	dr_mode;
 #define CI_HDRC_CONTROLLER_RESET_EVENT		0
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1
@@ -43,6 +45,8 @@ struct ci_hdrc_platform_data {
 	/* interrupt threshold setting */
 	u32			itc_setting;
 	u32			ahb_burst_config;
+	u32			tx_burst_size;
+	u32			rx_burst_size;
 };
 
 /* Default offset of capability registers */

commit 65668718f2c5b76d5f4513564a3c56672bb07892
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Mar 17 14:21:00 2015 +0800

    usb: chipidea: add ahb burst configuration interface
    
    The users can change it through dts or platform data if they
    want to change the default value.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index 4d34a8612e85..cd7fcad49017 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -33,6 +33,7 @@ struct ci_hdrc_platform_data {
 #define CI_HDRC_FORCE_FULLSPEED		BIT(6)
 #define CI_HDRC_TURN_VBUS_EARLY_ON	BIT(7)
 #define CI_HDRC_SET_NON_ZERO_TTHA	BIT(8)
+#define CI_HDRC_OVERRIDE_AHB_BURST	BIT(9)
 	enum usb_dr_mode	dr_mode;
 #define CI_HDRC_CONTROLLER_RESET_EVENT		0
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1
@@ -41,6 +42,7 @@ struct ci_hdrc_platform_data {
 	bool			tpl_support;
 	/* interrupt threshold setting */
 	u32			itc_setting;
+	u32			ahb_burst_config;
 };
 
 /* Default offset of capability registers */

commit 8022d3d51c6fb14736e26fd13caca91a38e07580
Author: Peter Chen <peter.chen@freescale.com>
Date:   Thu Oct 30 09:15:15 2014 +0800

    usb: chipidea: define stream mode disable for both roles
    
    The system bus and chipidea IP have different limitations for
    both host and device mode.
    For example, with below errata, we need to enable SDIS(Stream Disable
    Mode) at host mode. But we don't want it for device mode at the
    same system.
    
    TAR 9000378958
    Title: Non-Double Word Aligned Buffer Address Sometimes Causes Host to
    Hang on OUT Retry
    Impacted Configuration: Host mode, all transfer types
    Description:
    The host core operating in streaming mode may under run while sending
    the data packet of an OUT transaction. This under run can occur if
    there are unexpected system delays in fetching the remaining packet
    data from memory. The host forces a bad CRC on the packet, the device
    detects the error and discards the packet. The host then retries a Bulk,
    Interrupt, or Control transfer if an under run occurs according to the
    USB specification. During simulations, it was found that the host does
    not issue the retry of the failed bulk OUT. It does not issue any other
    transactions except SOF packets that have incorrect frame numbers.
    
    The second failure mode occurs if the under run occurs on an ISO OUT
    transaction and the next ISO transaction is a zero byte packet. The host
    does not issue any transactions (including SOFs). The device detects a
    Suspend condition, reverts to full speed, and waits for resume signaling.
    
    A third failure mode occurs when the host under runs on an ISO OUT and
    the next ISO in the schedule is an ISO OUT with two max packets of 1024
    bytes each. The host should issue MDATA for the first OUT followed by
    DATA1 for the second. However, it drops the MDATA transaction, and
    issues the DATA1 transaction.
    
    The system impact of this bug is the same regardless of the failure mode
    observed. The host core hangs, the ehci_ctrl state machine waits for the
    protocol engine to send the completion status for the corrupted
    transaction, which never occurs. No indication is sent to the host
    controller driver, no register bits change and no interrupts occur.
    Eventually the requesting application times out.
    
    Detailed internal behavior:
    The EHCI control state machine (ehci_ctrl) in the DMA block is responsible
    for parsing the schedules and initiating all transactions. The ehci_ctrl
    state machine passes the transaction details to the protocol block by
    writing the transaction information in to the TxFIFO. It then asserts
    the pe_hst_run_pkt signal to inform the host protocol state machine
    (pe_hst_state) that there is a packet in the TxFIFO.
    A tag of 0x0 indicates a start of packet with the data providing the
    following information:
    
    35:32 Tag
    31:30 Reserved
    29:23 Endpoint (lowest 4 bits)
    22:16 Address
    15:10 Reserved
    9:8 Endpoint speed
    7:6 Endpoint type
    5:6 Data Toggle
    3:0 PID
    The pe_hst_state reads the packet information and constructs the packet
    and issues it to the PHY interface.
    The ehci_ctrl state machine writes the start transaction information in
    to the TxFIFO as 0x03002910c for the OUT packet that had the under run
    error. However, it writes 0xC3002910C for the retry of the Out
    transaction, which is incorrect.
    The pe_hst_state enters a bus timeout state after sending the bad CRC
    for the packet that under ran. It then purges any data that was back
    filled in to the TxFIFO for the packet that under ran. The pe_hst_state
    machine stops purging the TxFIFO when it is empty or if it reads a
    location that has a tag of 0x0, indicating a start of packet command.
    
    The pe_hst_state reads 0xC3002910C and discards it as it does not decode
    to a start of packet command. It continues to purge the OUT data that
    has been pre-buffered for the OUT retry . The pe_hst_state detects the
    hst_packet_run signal and attempts to read the PID and address
    information from the TxFIFO. This location has packet data and so does
    not decode to a valid PID and so falls through to the PE_HST_SOF_LOAD
    state where the frame_num_counter is updated. The frame_num_counter
    is updated with the data in the TxFIFO. In this case, the data is
    incorrect as the ehci_ctrl state machine did not initiate the load.
    The hst_pe_state machine detects the SOF request signal and sends an
    SOF with the bad frame number. Meanwhile, the ehci_ctrl state machine
    waits indefinitely in the run_pkt state waiting for the completion
    status from pe_hst_state machine, which will never happen.
    
    The ISO failure case is similar except that there is no retry for ISO.
    The ehci_ctrl state machine moves to the next transfer in the periodic
    schedule. If the under run occurs on the last entry of the periodic
    list then it moves to the Async schedule.
    
    In the case of ISO OUT simulations, the next ISO is a zero byte OUT
    and again the start of packet command gets corrupted. The TxFIFO is
    empty when the hst_pe_state attempts to read the Address and PID
    information as the transaction is a zero byte packet. This results
    in the hst_pe_state machine staying in the GET_PID state, which means
    that it does not issue any transactions (including SOFs). The device
    detects a Suspend condition and reverts to full speed mode and waits
    for a Resume or Reset signal.
    
    The EHCI specification allows a Non-DoubleWord (32 bits) offset to
    be used as a current offset for Buffer Pointer Page 0 of the qTD.
    In Non-DoubleWord aligned cases, the core reads the packet data
    from the AHB memory, performs the alignment operation before writing
    it in to the TxFIFO as a 32 bit data word. An End Of Packet tag (EOP)
    is written to the TxFIFO after all the packet data has been written
    in to the TxFIFO. The alignment function is reset to Idle by the EOP
    tag. The corruption of the start of packet command arises because the
    packet buffer for the OUT transaction that under ran is not aligned
    to a DoubleWord, and hence no EOP tag is written to the TxFIFO. The
    alignment function is still active when the start packet information
    is written in to the TxFIFO for the retry of the bulk packet or for
    the next transaction in the case of an under run on an ISO. This
    results in the corruption of the start tag and the transaction
    information.
    
    Click for waveform showing the command 0x 0000300291 being written in
    to the TX FIFO for the Out that under ran.
    Click for waveform showing the command 0xC3002910C written to the
    TxFIFO instead of 0x 0000300291
    Versions affected: Versions 2.10a and previous versions
    How discovered: Customer simulation
    
    Workaround:
    1- The EHCI specification allows a non-DoubleWord offset to be used
    as a current offset for Buffer Pointer Page 0 of the qTD. However,
    if a DoubleWord offset is used then this issue does not arise.
    2- Use non streaming mode to eliminate under runs.
    
    Resolution:
    The fix involves changes to the traffic state machine in the
    vusb_hs_dma_traf block. The ehci_ctrl state machine updates the context
    information by encoding the transaction results on the
    hst_op_context_update signals at the end of a transaction. The signal
    hst_op_context_update is added to the traffic state machine, and the
    tx_fifo_under_ran_r signal is generated if the transaction results in
    an under run error. Click for waveform
    
    The traffic state machine then traverses to the do_eop states if the
    tx_fifo_under_ran error is asserted. Thus an EOP tag is written in to
    the TxFIFO as shown in this waveform .
    
    The EOP tag resets the align state machine to the Idle state ensuring
    that the next command written by the echi_ctrl state machine does not
    get corrupted.
    
    File(s) modified:
    RTL code fixed: â€¦..
    Method of reproducing: This failure cannot be reproduced in the current
    test bench.
    Date Found: March 2010
    Date Fixed: June 2010
    Update information:
    Added the RTL code fix
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index 1c5d7763990a..4d34a8612e85 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -19,8 +19,11 @@ struct ci_hdrc_platform_data {
 	enum usb_phy_interface phy_mode;
 	unsigned long	 flags;
 #define CI_HDRC_REGS_SHARED		BIT(0)
+#define CI_HDRC_DISABLE_DEVICE_STREAMING	BIT(1)
 #define CI_HDRC_SUPPORTS_RUNTIME_PM	BIT(2)
-#define CI_HDRC_DISABLE_STREAMING	BIT(3)
+#define CI_HDRC_DISABLE_HOST_STREAMING	BIT(3)
+#define CI_HDRC_DISABLE_STREAMING (CI_HDRC_DISABLE_DEVICE_STREAMING |	\
+		CI_HDRC_DISABLE_HOST_STREAMING)
 	/*
 	 * Only set it when DCCPARAMS.DC==1 and DCCPARAMS.HC==1,
 	 * but otg is not supported (no register otgsc).

commit df96ed8dced21426c54c7f69cf7513e75280957a
Author: Peter Chen <peter.chen@freescale.com>
Date:   Mon Sep 22 16:45:39 2014 +0800

    usb: chipidea: introduce ITC tuning interface
    
    ITC (Interrupt Threshold Control) is used to set the maximum rate at which
    the host/device controller will issue interrupts. The default value is 8 (1ms)
    for it. EHCI core will modify it to 1, but device mode keeps it as default
    value.
    
    In some use cases like Android ADB, it only has one usb request for each
    direction, and maximum payload data is only 4KB, so the speed is 4MB/s
    at most, it needs controller to trigger interrupt as fast as possible
    to increase the speed. The USB performance will be better if the interrupt
    can be triggered faster.
    
    Reduce ITC value is benefit for USB performance, but the interrupt number
    is increased at the same time, it may increase cpu utilization too.
    Most of use case cares about performance, but some may care about
    cpu utilization, so, we leave a platform interface for user.
    We set ITC as 1 (1 micro-frame) as default value which is aligned
    with ehci core default value.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index d1e1285a971d..1c5d7763990a 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -36,6 +36,8 @@ struct ci_hdrc_platform_data {
 	void	(*notify_event) (struct ci_hdrc *ci, unsigned event);
 	struct regulator	*reg_vbus;
 	bool			tpl_support;
+	/* interrupt threshold setting */
+	u32			itc_setting;
 };
 
 /* Default offset of capability registers */

commit 28362673129e7d4510a5a92a8b68ee47f282210b
Author: Peter Chen <peter.chen@freescale.com>
Date:   Thu Jun 18 11:51:53 2015 +0800

    usb: chipidea: add ttctrl.ttha control interface
    
    The register of ttctrl.ttha describes like below:
    - Internal TT Hub Address Representation
    - RW
    - Default = 0000000b
    This field is used to match against the Hub Address field in QH & siTD
    to determine if the packet is routed to the internal TT for directly
    attached FS/LS devices. If the Hub Address in the QH or siTD does not
    match this address then the packet will be broadcast on the High Speed
    ports destined for a downstream High Speed hub with the address in the QH/siTD.
    
    In silicon RTL, this entry only affects QH and siTD, and the hub.addr at
    both QH and siTD are 0 in ehci core for chipidea (with hcd->has_tt = 1).
    
    So, for QH, if the "usage_tt" flag at RTL is 0, set CI_HDRC_SET_NON_ZERO_TTHA
    will not affect QH (with non-hs device); for siTD, set this flag
    will change remaining space requirement for the last transaction from 1023
    bytes to 188 bytes, it can increase the number of transactions within one
    frame, ehci periodic schedule code will not queue the packet if the frame space
    is full, so it is safe to set this flag for siTD.
    
    With this flag, it can fix the problem Alan Stern reported below:
    http://www.spinics.net/lists/linux-usb/msg123125.html
    And may fix Michael Tessier's problem too.
    http://www.spinics.net/lists/linux-usb/msg118679.html
    
    CC: stern@rowland.harvard.edu
    CC: michael.tessier@axiontech.ca
    Signed-off-by: Peter Chen <peter.chen@freescale.com>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index ab94f78c4dd1..d1e1285a971d 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -29,6 +29,7 @@ struct ci_hdrc_platform_data {
 #define CI_HDRC_IMX28_WRITE_FIX		BIT(5)
 #define CI_HDRC_FORCE_FULLSPEED		BIT(6)
 #define CI_HDRC_TURN_VBUS_EARLY_ON	BIT(7)
+#define CI_HDRC_SET_NON_ZERO_TTHA	BIT(8)
 	enum usb_dr_mode	dr_mode;
 #define CI_HDRC_CONTROLLER_RESET_EVENT		0
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1

commit 79742351c89b76ebcf82b73103aed50f98ac2ee4
Author: Li Jun <jun.li@freescale.com>
Date:   Thu Jul 9 15:18:45 2015 +0800

    usb: chipidea: set usb otg capabilities
    
    Init and update otg capabilities by DT, set gadget's otg capabilities
    accordingly.
    
    Acked-by: Peter Chen <peter.chen@freescale.com>
    Reviewed-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Li Jun <jun.li@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index ab94f78c4dd1..e10cefc721ad 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -34,6 +34,7 @@ struct ci_hdrc_platform_data {
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1
 	void	(*notify_event) (struct ci_hdrc *ci, unsigned event);
 	struct regulator	*reg_vbus;
+	struct usb_otg_caps	ci_otg_caps;
 	bool			tpl_support;
 };
 

commit 6adb9b7b5fb64be3c3e4d57578ea1446da91a8f9
Author: Li Jun <b47624@freescale.com>
Date:   Wed Feb 11 12:45:01 2015 +0800

    usb: chipidea: add a flag for turn on vbus early for host
    
    Some usb PHYs need power supply from vbus to make it work, eg mxs-phy, if
    there is no vbus, USB PHY will not in correct state when the controller starts
    to work, for host, this requires vbus should be turned on before setting port
    power(PP) of ehci, to work with this kind of USB PHY design, this patch adds
    a flag CI_HDRC_TURN_VBUS_EARLY_ON, can be checked by host driver to turn on
    vbus while start host.
    
    Signed-off-by: Li Jun <jun.li@freescale.com>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index 39ba00f0d1d5..ab94f78c4dd1 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -28,6 +28,7 @@ struct ci_hdrc_platform_data {
 #define CI_HDRC_DUAL_ROLE_NOT_OTG	BIT(4)
 #define CI_HDRC_IMX28_WRITE_FIX		BIT(5)
 #define CI_HDRC_FORCE_FULLSPEED		BIT(6)
+#define CI_HDRC_TURN_VBUS_EARLY_ON	BIT(7)
 	enum usb_dr_mode	dr_mode;
 #define CI_HDRC_CONTROLLER_RESET_EVENT		0
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1

commit 1f874edcb7318c5dd71025df9f3849715b4e4f71
Author: Peter Chen <peter.chen@freescale.com>
Date:   Wed Feb 11 12:44:45 2015 +0800

    usb: chipidea: add runtime power management support
    
    Add runtime power management support.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index 535997a6681b..39ba00f0d1d5 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -19,6 +19,7 @@ struct ci_hdrc_platform_data {
 	enum usb_phy_interface phy_mode;
 	unsigned long	 flags;
 #define CI_HDRC_REGS_SHARED		BIT(0)
+#define CI_HDRC_SUPPORTS_RUNTIME_PM	BIT(2)
 #define CI_HDRC_DISABLE_STREAMING	BIT(3)
 	/*
 	 * Only set it when DCCPARAMS.DC==1 and DCCPARAMS.HC==1,

commit 947c88592f17bd299ff677049c3cda36cc6f93dd
Author: Peter Chen <peter.chen@freescale.com>
Date:   Wed Nov 26 13:44:31 2014 +0800

    usb: chipidea: remove flag CI_HDRC_REQUIRE_TRANSCEIVER
    
    Now, USB PHY is mandatory for chipidea core, the flag
    CI_HDRC_REQUIRE_TRANSCEIVER is useless.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index c01bf4ea27b9..535997a6681b 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -19,7 +19,6 @@ struct ci_hdrc_platform_data {
 	enum usb_phy_interface phy_mode;
 	unsigned long	 flags;
 #define CI_HDRC_REGS_SHARED		BIT(0)
-#define CI_HDRC_REQUIRE_TRANSCEIVER	BIT(1)
 #define CI_HDRC_DISABLE_STREAMING	BIT(3)
 	/*
 	 * Only set it when DCCPARAMS.DC==1 and DCCPARAMS.HC==1,

commit 1e5e2d3d055436c114e2f16145b83339aed024ff
Author: Antoine Tenart <antoine.tenart@free-electrons.com>
Date:   Thu Oct 30 18:41:19 2014 +0100

    usb: chipidea: add support to the generic PHY framework
    
    This patch adds support of the PHY framework for ChipIdea drivers.
    Changes are done in both the ChipIdea common code and in the drivers
    accessing the PHY. This is done by adding a new PHY member in
    ChipIdea's structures and by taking care of it in the code.
    
    Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
    Acked-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index 4fe161a84c7d..c01bf4ea27b9 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -13,6 +13,8 @@ struct ci_hdrc_platform_data {
 	/* offset of the capability registers */
 	uintptr_t	 capoffset;
 	unsigned	 power_budget;
+	struct phy	*phy;
+	/* old usb_phy interface */
 	struct usb_phy	*usb_phy;
 	enum usb_phy_interface phy_mode;
 	unsigned long	 flags;

commit ef44cb4226d132146e44f8ea562a16b27ff61126
Author: Antoine Tenart <antoine.tenart@free-electrons.com>
Date:   Thu Oct 30 18:41:16 2014 +0100

    usb: allow to supply the PHY in the drivers when using HCD
    
    This patch modify the generic code handling PHYs to allow them to be
    supplied from the drivers. This adds checks to ensure no PHY was already
    there when looking for one in the generic code. This also makes sure we
    do not modify its state in the generic HCD functions, it was provided by
    the driver.
    
    Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index e14c09a45c5a..4fe161a84c7d 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -13,7 +13,7 @@ struct ci_hdrc_platform_data {
 	/* offset of the capability registers */
 	uintptr_t	 capoffset;
 	unsigned	 power_budget;
-	struct usb_phy	*phy;
+	struct usb_phy	*usb_phy;
 	enum usb_phy_interface phy_mode;
 	unsigned long	 flags;
 #define CI_HDRC_REGS_SHARED		BIT(0)

commit f6a9ff07832a9d30d457e976e6233b4351cd4cdf
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Aug 19 09:51:56 2014 +0800

    usb: chipidea: add TPL support for targeted hosts
    
    For OTG and Embedded hosts, they may need TPL (Targeted Peripheral List)
    for usb certification and other vender specific requirements, the
    platform can tell chipidea core driver if it supports tpl through DT
    or platform data.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index bbe779f640be..e14c09a45c5a 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -31,6 +31,7 @@ struct ci_hdrc_platform_data {
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1
 	void	(*notify_event) (struct ci_hdrc *ci, unsigned event);
 	struct regulator	*reg_vbus;
+	bool			tpl_support;
 };
 
 /* Default offset of capability registers */

commit 4f6743d5ca97ac66831add302cc5467db4ee3809
Author: Michael Grzeschik <m.grzeschik@pengutronix.de>
Date:   Wed Feb 19 13:41:43 2014 +0800

    usb: chipidea: udc: add maximum-speed = full-speed option
    
    This patch makes it possible to set the chipidea udc into full-speed only mode.
    It is set by the oftree property "maximum-speed = full-speed".
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index 708bd119627f..bbe779f640be 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -25,6 +25,7 @@ struct ci_hdrc_platform_data {
 	 */
 #define CI_HDRC_DUAL_ROLE_NOT_OTG	BIT(4)
 #define CI_HDRC_IMX28_WRITE_FIX		BIT(5)
+#define CI_HDRC_FORCE_FULLSPEED		BIT(6)
 	enum usb_dr_mode	dr_mode;
 #define CI_HDRC_CONTROLLER_RESET_EVENT		0
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1

commit ed8f8318d2ef3e5f9e4ddf79349508c116b68d7f
Author: Peter Chen <peter.chen@freescale.com>
Date:   Fri Jan 10 13:51:27 2014 +0800

    usb: chipidea: add freescale imx28 special write register method
    
    According to Freescale imx28 Errata, "ENGR119653 USB: ARM to USB
    register error issue", All USB register write operations must
    use the ARM SWP instruction. So, we implement special hw_write
    and hw_test_and_clear for imx28.
    
    Discussion for it at below:
    http://marc.info/?l=linux-usb&m=137996395529294&w=2
    
    This patch is needed for stable tree 3.11+.
    
    Cc: stable@vger.kernel.org
    Cc: robert.hodaszi@digi.com
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Tested-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index 7d399671a566..708bd119627f 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -24,6 +24,7 @@ struct ci_hdrc_platform_data {
 	 * but otg is not supported (no register otgsc).
 	 */
 #define CI_HDRC_DUAL_ROLE_NOT_OTG	BIT(4)
+#define CI_HDRC_IMX28_WRITE_FIX		BIT(5)
 	enum usb_dr_mode	dr_mode;
 #define CI_HDRC_CONTROLLER_RESET_EVENT		0
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1

commit d268e9bc23f5df4a2f4167da246d277c2a468d3d
Author: Peter Chen <peter.chen@freescale.com>
Date:   Wed Aug 14 12:44:14 2013 +0300

    usb: chipidea: retire flag CI_HDRC_PULLUP_ON_VBUS
    
    Currently, the controller only runs when the ci->vbus_active is true.
    So the flag CI_HDRC_PULLUP_ON_VBUS is useless no longer.
    If the user doesn't have otgsc, he/she needs to change ci_handle_vbus_change
    to update ci->vbus_active.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index 10a607ce9090..7d399671a566 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -18,7 +18,6 @@ struct ci_hdrc_platform_data {
 	unsigned long	 flags;
 #define CI_HDRC_REGS_SHARED		BIT(0)
 #define CI_HDRC_REQUIRE_TRANSCEIVER	BIT(1)
-#define CI_HDRC_PULLUP_ON_VBUS		BIT(2)
 #define CI_HDRC_DISABLE_STREAMING	BIT(3)
 	/*
 	 * Only set it when DCCPARAMS.DC==1 and DCCPARAMS.HC==1,

commit 577b232fc9caba1b6f7a3bb9901c00b10e0ca1ba
Author: Peter Chen <peter.chen@freescale.com>
Date:   Wed Aug 14 12:44:08 2013 +0300

    usb: chipidea: add flag CI_HDRC_DUAL_ROLE_NOT_OTG
    
    Since we need otgsc to know vbus's status at some chipidea
    controllers even it is peripheral-only mode. Besides, some
    SoCs (eg, AR9331 SoC) don't have otgsc register even
    the DCCPARAMS_DC and DCCPARAMS_HC are both 1 at CAP_DCCPARAMS.
    
    We inroduce flag CI_HDRC_DUAL_ROLE_NOT_OTG to indicate if the
    controller is dual role, but not supports OTG. If this flag is
    not set, we follow the rule that if DCCPARAMS_DC and DCCPARAMS_HC
    are both 1 at CAP_DCCPARAMS, then this controller is otg capable.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index ce4e1aa071b3..10a607ce9090 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -20,6 +20,11 @@ struct ci_hdrc_platform_data {
 #define CI_HDRC_REQUIRE_TRANSCEIVER	BIT(1)
 #define CI_HDRC_PULLUP_ON_VBUS		BIT(2)
 #define CI_HDRC_DISABLE_STREAMING	BIT(3)
+	/*
+	 * Only set it when DCCPARAMS.DC==1 and DCCPARAMS.HC==1,
+	 * but otg is not supported (no register otgsc).
+	 */
+#define CI_HDRC_DUAL_ROLE_NOT_OTG	BIT(4)
 	enum usb_dr_mode	dr_mode;
 #define CI_HDRC_CONTROLLER_RESET_EVENT		0
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1

commit 1542d9c35d8166c54e0616574954a0f48449f331
Author: Peter Chen <peter.chen@freescale.com>
Date:   Wed Aug 14 12:44:03 2013 +0300

    usb: chipidea: move vbus regulator operation to core
    
    The vbus regulator is a common element for USB vbus operation,
    So, move it from glue layer to core.
    
    Tested-by: Marek Vasut <marex@denx.de>
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index 25629948c842..ce4e1aa071b3 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -24,6 +24,7 @@ struct ci_hdrc_platform_data {
 #define CI_HDRC_CONTROLLER_RESET_EVENT		0
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1
 	void	(*notify_event) (struct ci_hdrc *ci, unsigned event);
+	struct regulator	*reg_vbus;
 };
 
 /* Default offset of capability registers */

commit 8e22978c57087aac4d88693278db1cc3e94f1253
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Mon Jun 24 14:46:36 2013 +0300

    usb: chipidea: drop "13xxx" infix
    
    "ci13xxx" is bad for at least the following reasons:
      * people often mistype it
      * it doesn't add any informational value to the names it's used in
      * it needlessly attracts mail filters
    
    This patch replaces it with "ci_hdrc", "ci_udc" or "ci_hw", depending
    on the situation. Modules with ci13xxx prefix are also renamed accordingly
    and aliases are added for compatibility. Otherwise, no functional changes.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index b3146476be5c..25629948c842 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -7,8 +7,8 @@
 
 #include <linux/usb/otg.h>
 
-struct ci13xxx;
-struct ci13xxx_platform_data {
+struct ci_hdrc;
+struct ci_hdrc_platform_data {
 	const char	*name;
 	/* offset of the capability registers */
 	uintptr_t	 capoffset;
@@ -16,24 +16,24 @@ struct ci13xxx_platform_data {
 	struct usb_phy	*phy;
 	enum usb_phy_interface phy_mode;
 	unsigned long	 flags;
-#define CI13XXX_REGS_SHARED		BIT(0)
-#define CI13XXX_REQUIRE_TRANSCEIVER	BIT(1)
-#define CI13XXX_PULLUP_ON_VBUS		BIT(2)
-#define CI13XXX_DISABLE_STREAMING	BIT(3)
+#define CI_HDRC_REGS_SHARED		BIT(0)
+#define CI_HDRC_REQUIRE_TRANSCEIVER	BIT(1)
+#define CI_HDRC_PULLUP_ON_VBUS		BIT(2)
+#define CI_HDRC_DISABLE_STREAMING	BIT(3)
 	enum usb_dr_mode	dr_mode;
-#define CI13XXX_CONTROLLER_RESET_EVENT		0
-#define CI13XXX_CONTROLLER_STOPPED_EVENT	1
-	void	(*notify_event) (struct ci13xxx *ci, unsigned event);
+#define CI_HDRC_CONTROLLER_RESET_EVENT		0
+#define CI_HDRC_CONTROLLER_STOPPED_EVENT	1
+	void	(*notify_event) (struct ci_hdrc *ci, unsigned event);
 };
 
 /* Default offset of capability registers */
 #define DEF_CAPOFFSET		0x100
 
-/* Add ci13xxx device */
-struct platform_device *ci13xxx_add_device(struct device *dev,
+/* Add ci hdrc device */
+struct platform_device *ci_hdrc_add_device(struct device *dev,
 			struct resource *res, int nres,
-			struct ci13xxx_platform_data *platdata);
-/* Remove ci13xxx device */
-void ci13xxx_remove_device(struct platform_device *pdev);
+			struct ci_hdrc_platform_data *platdata);
+/* Remove ci hdrc device */
+void ci_hdrc_remove_device(struct platform_device *pdev);
 
 #endif

commit 691962d1593a16d5c8c9a5bb60b586ac3e54acc8
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Thu Jun 13 17:59:57 2013 +0300

    usb: chipidea: introduce dual role mode pdata flags
    
    Even if a chipidea core is otg capable the board may not be. This allows
    to explicitly set the core to host/peripheral mode. Without these flags
    the driver falls back to the old behaviour.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index 1a2aa1848804..b3146476be5c 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -20,7 +20,7 @@ struct ci13xxx_platform_data {
 #define CI13XXX_REQUIRE_TRANSCEIVER	BIT(1)
 #define CI13XXX_PULLUP_ON_VBUS		BIT(2)
 #define CI13XXX_DISABLE_STREAMING	BIT(3)
-
+	enum usb_dr_mode	dr_mode;
 #define CI13XXX_CONTROLLER_RESET_EVENT		0
 #define CI13XXX_CONTROLLER_STOPPED_EVENT	1
 	void	(*notify_event) (struct ci13xxx *ci, unsigned event);

commit 40dcd0e8067b35e247f74409d79443634daf35ac
Author: Michael Grzeschik <m.grzeschik@pengutronix.de>
Date:   Thu Jun 13 17:59:56 2013 +0300

    usb: chipidea: add PTW, PTS and STS handling
    
    This patch makes it possible to configure the PTW, PTS and STS bits
    inside the portsc register for host and device mode before the driver
    starts and the phy can be addressed as hardware implementation is
    designed.
    
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index 544825dde823..1a2aa1848804 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -14,6 +14,7 @@ struct ci13xxx_platform_data {
 	uintptr_t	 capoffset;
 	unsigned	 power_budget;
 	struct usb_phy	*phy;
+	enum usb_phy_interface phy_mode;
 	unsigned long	 flags;
 #define CI13XXX_REGS_SHARED		BIT(0)
 #define CI13XXX_REQUIRE_TRANSCEIVER	BIT(1)

commit a2c3d6902f6f9916b5376c44baa8c1d08bf92a27
Author: Richard Zhao <richard.zhao@freescale.com>
Date:   Sat Jul 7 22:56:46 2012 +0800

    usb: chipidea: permit driver bindings pass phy pointer
    
    Sometimes, the driver bindings may know what phy they use.
    For example, when using device tree, the usb controller may have a
    phandler pointing to usb phy.
    
    Signed-off-by: Richard Zhao <richard.zhao@freescale.com>
    Reviewed-by: Marek Vasut <marex@denx.de>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Tested-by: Subodh Nijsure <snijsure@grid-net.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index be078f0bfde2..544825dde823 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -5,12 +5,15 @@
 #ifndef __LINUX_USB_CHIPIDEA_H
 #define __LINUX_USB_CHIPIDEA_H
 
+#include <linux/usb/otg.h>
+
 struct ci13xxx;
 struct ci13xxx_platform_data {
 	const char	*name;
 	/* offset of the capability registers */
 	uintptr_t	 capoffset;
 	unsigned	 power_budget;
+	struct usb_phy	*phy;
 	unsigned long	 flags;
 #define CI13XXX_REGS_SHARED		BIT(0)
 #define CI13XXX_REQUIRE_TRANSCEIVER	BIT(1)

commit cbc6dc2af39e1395564445fd71cfcc1c70a96277
Author: Richard Zhao <richard.zhao@freescale.com>
Date:   Sat Jul 7 22:56:41 2012 +0800

    USB: Chipidea: add unified ci13xxx_{add,remove}_device for platform drivers
    
    Platform drivers do the similar things to add/remove ci13xxx device, so
    create a unified one.
    
    Signed-off-by: Richard Zhao <richard.zhao@freescale.com>
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index d2f7e494f5c0..be078f0bfde2 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -25,4 +25,11 @@ struct ci13xxx_platform_data {
 /* Default offset of capability registers */
 #define DEF_CAPOFFSET		0x100
 
+/* Add ci13xxx device */
+struct platform_device *ci13xxx_add_device(struct device *dev,
+			struct resource *res, int nres,
+			struct ci13xxx_platform_data *platdata);
+/* Remove ci13xxx device */
+void ci13xxx_remove_device(struct platform_device *pdev);
+
 #endif

commit 26c696c678c4ce180599330999e895cded0f625b
Author: Richard Zhao <richard.zhao@freescale.com>
Date:   Sat Jul 7 22:56:40 2012 +0800

    USB: Chipidea: rename struct ci13xxx variables from udc to ci
    
    struct ci13xxx represent the controller, which may be device or host,
    so name its variables as ci.
    
    Signed-off-by: Richard Zhao <richard.zhao@freescale.com>
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Reviewed-by: Marek Vasut <marex@denx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index d4cf970656fb..d2f7e494f5c0 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -19,7 +19,7 @@ struct ci13xxx_platform_data {
 
 #define CI13XXX_CONTROLLER_RESET_EVENT		0
 #define CI13XXX_CONTROLLER_STOPPED_EVENT	1
-	void	(*notify_event) (struct ci13xxx *udc, unsigned event);
+	void	(*notify_event) (struct ci13xxx *ci, unsigned event);
 };
 
 /* Default offset of capability registers */

commit 77c4400f2f0fd8384ab5cbe41d81ccc664896b2d
Author: Richard Zhao <richard.zhao@freescale.com>
Date:   Fri Jun 29 17:48:53 2012 +0800

    USB: Chipidea: rename struct ci13xxx_udc_driver to struct ci13xxx_platform_data
    
    This patch rename struct ci13xxx_udc_driver and var with the type.
    
    ci13xxx_platform_data reflect it's passed from platfrom driver.
    
    Signed-off-by: Richard Zhao <richard.zhao@freescale.com>
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index edb90d6cfd12..d4cf970656fb 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -6,7 +6,7 @@
 #define __LINUX_USB_CHIPIDEA_H
 
 struct ci13xxx;
-struct ci13xxx_udc_driver {
+struct ci13xxx_platform_data {
 	const char	*name;
 	/* offset of the capability registers */
 	uintptr_t	 capoffset;

commit bd841986e4e1fe60fe97da45be5139f173c5188e
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Fri May 11 17:25:55 2012 +0300

    usb: chipidea: add power_budget limit for ehci to platform data
    
    Some implementations need this limitation to work correctly.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index 86273ce5f554..edb90d6cfd12 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -10,6 +10,7 @@ struct ci13xxx_udc_driver {
 	const char	*name;
 	/* offset of the capability registers */
 	uintptr_t	 capoffset;
+	unsigned	 power_budget;
 	unsigned long	 flags;
 #define CI13XXX_REGS_SHARED		BIT(0)
 #define CI13XXX_REQUIRE_TRANSCEIVER	BIT(1)

commit e443b333629f82ca0da91a05ca638050943bbedd
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Fri May 11 17:25:46 2012 +0300

    usb: chipidea: split the driver code into units
    
    Split the driver into the following parts:
      * core  -- resources, register access, capabilities, etc;
      * udc   -- device controller functionality;
      * debug -- logging events.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
new file mode 100644
index 000000000000..86273ce5f554
--- /dev/null
+++ b/include/linux/usb/chipidea.h
@@ -0,0 +1,27 @@
+/*
+ * Platform data for the chipidea USB dual role controller
+ */
+
+#ifndef __LINUX_USB_CHIPIDEA_H
+#define __LINUX_USB_CHIPIDEA_H
+
+struct ci13xxx;
+struct ci13xxx_udc_driver {
+	const char	*name;
+	/* offset of the capability registers */
+	uintptr_t	 capoffset;
+	unsigned long	 flags;
+#define CI13XXX_REGS_SHARED		BIT(0)
+#define CI13XXX_REQUIRE_TRANSCEIVER	BIT(1)
+#define CI13XXX_PULLUP_ON_VBUS		BIT(2)
+#define CI13XXX_DISABLE_STREAMING	BIT(3)
+
+#define CI13XXX_CONTROLLER_RESET_EVENT		0
+#define CI13XXX_CONTROLLER_STOPPED_EVENT	1
+	void	(*notify_event) (struct ci13xxx *udc, unsigned event);
+};
+
+/* Default offset of capability registers */
+#define DEF_CAPOFFSET		0x100
+
+#endif
