commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 67929df86df5..69f1b6328532 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /* USB OTG (On The Go) defines */
 /*
  *

commit 06e7114f0d8297278eb24f4e9bee3393a94bd8ce
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Mon Sep 21 11:14:34 2015 +0300

    usb: common: of_usb_get_dr_mode to usb_get_dr_mode
    
    By using the unified device property interface, the function
    can be made available for all platforms and not just the
    ones using DT.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index bd1dcf816100..67929df86df5 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -119,4 +119,13 @@ enum usb_dr_mode {
 	USB_DR_MODE_OTG,
 };
 
+/**
+ * usb_get_dr_mode - Get dual role mode for given device
+ * @dev: Pointer to the given device
+ *
+ * The function gets phy interface string from property 'dr_mode',
+ * and returns the correspondig enum usb_dr_mode
+ */
+extern enum usb_dr_mode usb_get_dr_mode(struct device *dev);
+
 #endif /* __LINUX_USB_OTG_H */

commit 6a88bbe8e30d4beb2320b5a7452242a1fe7889c5
Author: Li Jun <jun.li@freescale.com>
Date:   Thu Jul 9 15:18:40 2015 +0800

    usb: otg: add usb_otg_caps structure for otg capabilities
    
    This patch adds a structure usb_otg_caps to cover all otg related
    capabilities of the device, including otg revision, and if hnp/srp/adp
    is supported.
    
    Signed-off-by: Li Jun <jun.li@freescale.com>
    Reviewed-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 52661c5da690..bd1dcf816100 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -41,6 +41,21 @@ struct usb_otg {
 
 };
 
+/**
+ * struct usb_otg_caps - describes the otg capabilities of the device
+ * @otg_rev: The OTG revision number the device is compliant with, it's
+ *		in binary-coded decimal (i.e. 2.0 is 0200H).
+ * @hnp_support: Indicates if the device supports HNP.
+ * @srp_support: Indicates if the device supports SRP.
+ * @adp_support: Indicates if the device supports ADP.
+ */
+struct usb_otg_caps {
+	u16 otg_rev;
+	bool hnp_support;
+	bool srp_support;
+	bool adp_support;
+};
+
 extern const char *usb_otg_state_string(enum usb_otg_state state);
 
 /* Context: can sleep */

commit 48bcc18076df4e07ef86226ac6ce795f64c84f7f
Author: Antoine Tenart <antoine.tenart@free-electrons.com>
Date:   Thu Oct 30 18:41:15 2014 +0100

    usb: add support to the generic PHY framework in OTG
    
    This patch adds support of the PHY framework in OTG and keeps the USB
    PHY compatibility. Here the only modification is to add PHY member in
    the OTG structure, along with the USB PHY one.
    
    Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 978fbbb0e266..52661c5da690 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -9,11 +9,14 @@
 #ifndef __LINUX_USB_OTG_H
 #define __LINUX_USB_OTG_H
 
+#include <linux/phy/phy.h>
 #include <linux/usb/phy.h>
 
 struct usb_otg {
 	u8			default_a;
 
+	struct phy		*phy;
+	/* old usb_phy interface */
 	struct usb_phy		*usb_phy;
 	struct usb_bus		*host;
 	struct usb_gadget	*gadget;

commit 19c1eac2685b62640ca2386a0a885ac2152668c8
Author: Antoine Tenart <antoine.tenart@free-electrons.com>
Date:   Thu Oct 30 18:41:14 2014 +0100

    usb: rename phy to usb_phy in OTG
    
    This patch prepares the introduction of the generic PHY support in the
    USB OTG common functions. The USB PHY member of the OTG structure is
    renamed to 'usb_phy' and modifications are done in all drivers accessing
    it. Renaming this pointer will allow to keep the compatibility for USB
    PHY drivers.
    
    Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 33d3480c9cda..978fbbb0e266 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -14,7 +14,7 @@
 struct usb_otg {
 	u8			default_a;
 
-	struct usb_phy		*phy;
+	struct usb_phy		*usb_phy;
 	struct usb_bus		*host;
 	struct usb_gadget	*gadget;
 

commit e47d92545c2972bcf3711e7db80f481e402163c7
Author: Antoine Tenart <antoine.tenart@free-electrons.com>
Date:   Thu Oct 30 18:41:13 2014 +0100

    usb: move the OTG state from the USB PHY to the OTG structure
    
    Before using the PHY framework instead of the USB PHY one, we need to
    move the OTG state into another place, since it won't be available when
    USB PHY isn't used. This patch moves the OTG state into the OTG
    structure, and makes all the needed modifications in the drivers
    using the OTG state.
    
    [ balbi@ti.com : fix build regressions with phy-tahvo.c, musb_dsps.c,
                    phy-isp1301-omap, and chipidea's debug.c ]
    
    Acked-by: Kishon Vijay Abraham I <kishon@ti.com>
    Acked-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 154332b7c8c0..33d3480c9cda 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -18,6 +18,8 @@ struct usb_otg {
 	struct usb_bus		*host;
 	struct usb_gadget	*gadget;
 
+	enum usb_otg_state	state;
+
 	/* bind/unbind the host controller */
 	int	(*set_host)(struct usb_otg *otg, struct usb_bus *host);
 

commit 1c9af65357a309b60d78a442bd61d27cad458d00
Author: Michael Grzeschik <m.grzeschik@pengutronix.de>
Date:   Thu Jun 13 17:59:55 2013 +0300

    usb: add devicetree helpers for determining dr_mode and phy_type
    
    This adds two little devicetree helper functions for determining the
    dr_mode (host, peripheral, otg) and phy_type (utmi, ulpi,...) from
    the devicetree.
    
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 291e01ba32e5..154332b7c8c0 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -92,4 +92,11 @@ otg_start_srp(struct usb_otg *otg)
 /* for OTG controller drivers (and maybe other stuff) */
 extern int usb_bus_start_enum(struct usb_bus *bus, unsigned port_num);
 
+enum usb_dr_mode {
+	USB_DR_MODE_UNKNOWN,
+	USB_DR_MODE_HOST,
+	USB_DR_MODE_PERIPHERAL,
+	USB_DR_MODE_OTG,
+};
+
 #endif /* __LINUX_USB_OTG_H */

commit 7009bdd7f31ed6e769af0f76e2368bb6033be572
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Mar 7 10:45:56 2013 +0200

    usb: otg: move usb_otg_state_string to usb-common.c
    
    otg.c only had a single function definition
    which might make more sense to be placed in
    usb-common.c. While doing that, we also delete
    otg.c since it's now empty.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 9f9fb3927b0a..291e01ba32e5 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -36,14 +36,7 @@ struct usb_otg {
 
 };
 
-#ifdef CONFIG_USB_OTG_UTILS
 extern const char *usb_otg_state_string(enum usb_otg_state state);
-#else
-static inline const char *usb_otg_state_string(enum usb_otg_state state)
-{
-	return NULL;
-}
-#endif
 
 /* Context: can sleep */
 static inline int

commit 42c0bf1ce7c067bbc3e77d5626f102a16bc4fb6b
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Mar 7 10:39:57 2013 +0200

    usb: otg: prefix otg_state_string with usb_
    
    all other functions under drivers/usb/ start
    with usb_, let's do the same thing.
    
    This patch is in preparation for moving otg_state_string
    to usb-common.c and deleting otg.c completely.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index e8a5fe87c6bd..9f9fb3927b0a 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -37,9 +37,9 @@ struct usb_otg {
 };
 
 #ifdef CONFIG_USB_OTG_UTILS
-extern const char *otg_state_string(enum usb_otg_state state);
+extern const char *usb_otg_state_string(enum usb_otg_state state);
 #else
-static inline const char *otg_state_string(enum usb_otg_state state)
+static inline const char *usb_otg_state_string(enum usb_otg_state state)
 {
 	return NULL;
 }

commit a4c3ddec5c5293953d8472eb151c48a3205b738b
Author: Venu Byravarasu <vbyravarasu@nvidia.com>
Date:   Thu Sep 6 10:42:15 2012 +0530

    usb: phy: fix build break
    
    During phy interface separation from otg.h, as the enum "usb_otg_state"
    was having multiple otg states info and removal of member 'state'
    of this enum type from usb_phy struct did not generate any compilation
    issues, I removed member state from struct usb_phy.
    
    As this is causing build break in musb code, adding member 'state'
    to usb_phy structure.
    
    Signed-off-by: Venu Byravarasu <vbyravarasu@nvidia.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 65a2b6afe020..e8a5fe87c6bd 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -11,30 +11,6 @@
 
 #include <linux/usb/phy.h>
 
-/* OTG defines lots of enumeration states before device reset */
-enum usb_otg_state {
-	OTG_STATE_UNDEFINED = 0,
-
-	/* single-role peripheral, and dual-role default-b */
-	OTG_STATE_B_IDLE,
-	OTG_STATE_B_SRP_INIT,
-	OTG_STATE_B_PERIPHERAL,
-
-	/* extra dual-role default-b states */
-	OTG_STATE_B_WAIT_ACON,
-	OTG_STATE_B_HOST,
-
-	/* dual-role default-a */
-	OTG_STATE_A_IDLE,
-	OTG_STATE_A_WAIT_VRISE,
-	OTG_STATE_A_WAIT_BCON,
-	OTG_STATE_A_HOST,
-	OTG_STATE_A_SUSPEND,
-	OTG_STATE_A_PERIPHERAL,
-	OTG_STATE_A_WAIT_VFALL,
-	OTG_STATE_A_VBUS_ERR,
-};
-
 struct usb_otg {
 	u8			default_a;
 

commit de4217d90fed1b1714a270ceb5d092f7314e8bda
Author: Venu Byravarasu <vbyravarasu@nvidia.com>
Date:   Tue Sep 4 14:25:58 2012 +0530

    usb: otg: Move phy interface to separate file.
    
    As otg.h is containing lots of phy interface related
    stuff, moving all phy interface related stuff to new
    file named phy.h
    
    Signed-off-by: Venu Byravarasu <vbyravarasu@nvidia.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 16dc520dfbad..65a2b6afe020 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -9,7 +9,7 @@
 #ifndef __LINUX_USB_OTG_H
 #define __LINUX_USB_OTG_H
 
-#include <linux/notifier.h>
+#include <linux/usb/phy.h>
 
 /* OTG defines lots of enumeration states before device reset */
 enum usb_otg_state {
@@ -35,31 +35,6 @@ enum usb_otg_state {
 	OTG_STATE_A_VBUS_ERR,
 };
 
-enum usb_phy_events {
-	USB_EVENT_NONE,         /* no events or cable disconnected */
-	USB_EVENT_VBUS,         /* vbus valid event */
-	USB_EVENT_ID,           /* id was grounded */
-	USB_EVENT_CHARGER,      /* usb dedicated charger */
-	USB_EVENT_ENUMERATED,   /* gadget driver enumerated */
-};
-
-/* associate a type with PHY */
-enum usb_phy_type {
-	USB_PHY_TYPE_UNDEFINED,
-	USB_PHY_TYPE_USB2,
-	USB_PHY_TYPE_USB3,
-};
-
-struct usb_phy;
-
-/* for transceivers connected thru an ULPI interface, the user must
- * provide access ops
- */
-struct usb_phy_io_ops {
-	int (*read)(struct usb_phy *x, u32 reg);
-	int (*write)(struct usb_phy *x, u32 val, u32 reg);
-};
-
 struct usb_otg {
 	u8			default_a;
 
@@ -85,120 +60,9 @@ struct usb_otg {
 
 };
 
-/*
- * the otg driver needs to interact with both device side and host side
- * usb controllers.  it decides which controller is active at a given
- * moment, using the transceiver, ID signal, HNP and sometimes static
- * configuration information (including "board isn't wired for otg").
- */
-struct usb_phy {
-	struct device		*dev;
-	const char		*label;
-	unsigned int		 flags;
-
-	enum usb_phy_type	type;
-	enum usb_otg_state	state;
-	enum usb_phy_events	last_event;
-
-	struct usb_otg		*otg;
-
-	struct device		*io_dev;
-	struct usb_phy_io_ops	*io_ops;
-	void __iomem		*io_priv;
-
-	/* for notification of usb_phy_events */
-	struct atomic_notifier_head	notifier;
-
-	/* to pass extra port status to the root hub */
-	u16			port_status;
-	u16			port_change;
-
-	/* to support controllers that have multiple transceivers */
-	struct list_head	head;
-
-	/* initialize/shutdown the OTG controller */
-	int	(*init)(struct usb_phy *x);
-	void	(*shutdown)(struct usb_phy *x);
-
-	/* effective for B devices, ignored for A-peripheral */
-	int	(*set_power)(struct usb_phy *x,
-				unsigned mA);
-
-	/* for non-OTG B devices: set transceiver into suspend mode */
-	int	(*set_suspend)(struct usb_phy *x,
-				int suspend);
-
-	/* notify phy connect status change */
-	int	(*notify_connect)(struct usb_phy *x, int port);
-	int	(*notify_disconnect)(struct usb_phy *x, int port);
-};
-
-
-/* for board-specific init logic */
-extern int usb_add_phy(struct usb_phy *, enum usb_phy_type type);
-extern void usb_remove_phy(struct usb_phy *);
-
-/* helpers for direct access thru low-level io interface */
-static inline int usb_phy_io_read(struct usb_phy *x, u32 reg)
-{
-	if (x->io_ops && x->io_ops->read)
-		return x->io_ops->read(x, reg);
-
-	return -EINVAL;
-}
-
-static inline int usb_phy_io_write(struct usb_phy *x, u32 val, u32 reg)
-{
-	if (x->io_ops && x->io_ops->write)
-		return x->io_ops->write(x, val, reg);
-
-	return -EINVAL;
-}
-
-static inline int
-usb_phy_init(struct usb_phy *x)
-{
-	if (x->init)
-		return x->init(x);
-
-	return 0;
-}
-
-static inline void
-usb_phy_shutdown(struct usb_phy *x)
-{
-	if (x->shutdown)
-		x->shutdown(x);
-}
-
-/* for usb host and peripheral controller drivers */
 #ifdef CONFIG_USB_OTG_UTILS
-extern struct usb_phy *usb_get_phy(enum usb_phy_type type);
-extern struct usb_phy *devm_usb_get_phy(struct device *dev,
-	enum usb_phy_type type);
-extern void usb_put_phy(struct usb_phy *);
-extern void devm_usb_put_phy(struct device *dev, struct usb_phy *x);
 extern const char *otg_state_string(enum usb_otg_state state);
 #else
-static inline struct usb_phy *usb_get_phy(enum usb_phy_type type)
-{
-	return NULL;
-}
-
-static inline struct usb_phy *devm_usb_get_phy(struct device *dev,
-	enum usb_phy_type type)
-{
-	return NULL;
-}
-
-static inline void usb_put_phy(struct usb_phy *x)
-{
-}
-
-static inline void devm_usb_put_phy(struct device *dev, struct usb_phy *x)
-{
-}
-
 static inline const char *otg_state_string(enum usb_otg_state state)
 {
 	return NULL;
@@ -247,42 +111,6 @@ otg_set_peripheral(struct usb_otg *otg, struct usb_gadget *periph)
 	return -ENOTSUPP;
 }
 
-static inline int
-usb_phy_set_power(struct usb_phy *x, unsigned mA)
-{
-	if (x && x->set_power)
-		return x->set_power(x, mA);
-	return 0;
-}
-
-/* Context: can sleep */
-static inline int
-usb_phy_set_suspend(struct usb_phy *x, int suspend)
-{
-	if (x->set_suspend != NULL)
-		return x->set_suspend(x, suspend);
-	else
-		return 0;
-}
-
-static inline int
-usb_phy_notify_connect(struct usb_phy *x, int port)
-{
-	if (x->notify_connect)
-		return x->notify_connect(x, port);
-	else
-		return 0;
-}
-
-static inline int
-usb_phy_notify_disconnect(struct usb_phy *x, int port)
-{
-	if (x->notify_disconnect)
-		return x->notify_disconnect(x, port);
-	else
-		return 0;
-}
-
 static inline int
 otg_start_srp(struct usb_otg *otg)
 {
@@ -292,31 +120,7 @@ otg_start_srp(struct usb_otg *otg)
 	return -ENOTSUPP;
 }
 
-/* notifiers */
-static inline int
-usb_register_notifier(struct usb_phy *x, struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&x->notifier, nb);
-}
-
-static inline void
-usb_unregister_notifier(struct usb_phy *x, struct notifier_block *nb)
-{
-	atomic_notifier_chain_unregister(&x->notifier, nb);
-}
-
 /* for OTG controller drivers (and maybe other stuff) */
 extern int usb_bus_start_enum(struct usb_bus *bus, unsigned port_num);
 
-static inline const char *usb_phy_type_string(enum usb_phy_type type)
-{
-	switch (type) {
-	case USB_PHY_TYPE_USB2:
-		return "USB2 PHY";
-	case USB_PHY_TYPE_USB3:
-		return "USB3 PHY";
-	default:
-		return "UNKNOWN PHY TYPE";
-	}
-}
 #endif /* __LINUX_USB_OTG_H */

commit 78c289f8769aaefcc52d26ca53c8b2ee545fb332
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Jul 19 13:32:15 2012 +0300

    usb: xceiv: create nop-usb-xceiv.h and avoid pollution on otg.h
    
    nop-usb-xceiv was polluting otg.h with its own
    function prototypes. Move those prototypes to
    a nop-usb-xceiv.h header.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 45824be0a2f9..16dc520dfbad 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -138,20 +138,6 @@ struct usb_phy {
 extern int usb_add_phy(struct usb_phy *, enum usb_phy_type type);
 extern void usb_remove_phy(struct usb_phy *);
 
-#if defined(CONFIG_NOP_USB_XCEIV) || (defined(CONFIG_NOP_USB_XCEIV_MODULE) && defined(MODULE))
-/* sometimes transceivers are accessed only through e.g. ULPI */
-extern void usb_nop_xceiv_register(void);
-extern void usb_nop_xceiv_unregister(void);
-#else
-static inline void usb_nop_xceiv_register(void)
-{
-}
-
-static inline void usb_nop_xceiv_unregister(void)
-{
-}
-#endif
-
 /* helpers for direct access thru low-level io interface */
 static inline int usb_phy_io_read(struct usb_phy *x, u32 reg)
 {

commit 526c51382d59144a3704970ab111d668e604a10f
Author: Richard Zhao <richard.zhao@freescale.com>
Date:   Sat Jul 7 22:56:44 2012 +0800

    usb: otg: add notify_connect/notify_disconnect callback
    
    This let usb phy driver has a chance to change hw settings when connect
    status change.
    
    Signed-off-by: Richard Zhao <richard.zhao@freescale.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Tested-by: Subodh Nijsure <snijsure@grid-net.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 0cb2ec2e50c0..45824be0a2f9 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -128,6 +128,9 @@ struct usb_phy {
 	int	(*set_suspend)(struct usb_phy *x,
 				int suspend);
 
+	/* notify phy connect status change */
+	int	(*notify_connect)(struct usb_phy *x, int port);
+	int	(*notify_disconnect)(struct usb_phy *x, int port);
 };
 
 
@@ -276,6 +279,24 @@ usb_phy_set_suspend(struct usb_phy *x, int suspend)
 		return 0;
 }
 
+static inline int
+usb_phy_notify_connect(struct usb_phy *x, int port)
+{
+	if (x->notify_connect)
+		return x->notify_connect(x, port);
+	else
+		return 0;
+}
+
+static inline int
+usb_phy_notify_disconnect(struct usb_phy *x, int port)
+{
+	if (x->notify_disconnect)
+		return x->notify_disconnect(x, port);
+	else
+		return 0;
+}
+
 static inline int
 otg_start_srp(struct usb_otg *otg)
 {

commit 410219dcd2ba8d8b4bcfa9c232f35bf505bc021a
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Fri Jun 22 17:02:47 2012 +0530

    usb: otg: utils: devres: Add API's to associate a device with the phy
    
    Used devres API's to associate the phy with a device so that on
    driver detach, release function is invoked on the devres data(usb_phy)
    and devres data(usb_phy) is released.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 1def65fb57d0..0cb2ec2e50c0 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -185,7 +185,10 @@ usb_phy_shutdown(struct usb_phy *x)
 /* for usb host and peripheral controller drivers */
 #ifdef CONFIG_USB_OTG_UTILS
 extern struct usb_phy *usb_get_phy(enum usb_phy_type type);
+extern struct usb_phy *devm_usb_get_phy(struct device *dev,
+	enum usb_phy_type type);
 extern void usb_put_phy(struct usb_phy *);
+extern void devm_usb_put_phy(struct device *dev, struct usb_phy *x);
 extern const char *otg_state_string(enum usb_otg_state state);
 #else
 static inline struct usb_phy *usb_get_phy(enum usb_phy_type type)
@@ -193,10 +196,20 @@ static inline struct usb_phy *usb_get_phy(enum usb_phy_type type)
 	return NULL;
 }
 
+static inline struct usb_phy *devm_usb_get_phy(struct device *dev,
+	enum usb_phy_type type)
+{
+	return NULL;
+}
+
 static inline void usb_put_phy(struct usb_phy *x)
 {
 }
 
+static inline void devm_usb_put_phy(struct device *dev, struct usb_phy *x)
+{
+}
+
 static inline const char *otg_state_string(enum usb_otg_state state)
 {
 	return NULL;

commit 662dca54ca67c92b7aa14b9a2ec54acacf33ce45
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Fri Jun 22 17:02:46 2012 +0530

    usb: otg: support for multiple transceivers by a single controller
    
    Add a linked list for keeping multiple PHY instances with different
    types so that we can have separate USB2 and USB3 PHYs on one single
    board. _get_phy_ has been changed so that the controller gets
    the transceiver by type. _remove_phy_ has been added to let the phy
    be removed from the phy list.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 0e739c810525..1def65fb57d0 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -43,6 +43,13 @@ enum usb_phy_events {
 	USB_EVENT_ENUMERATED,   /* gadget driver enumerated */
 };
 
+/* associate a type with PHY */
+enum usb_phy_type {
+	USB_PHY_TYPE_UNDEFINED,
+	USB_PHY_TYPE_USB2,
+	USB_PHY_TYPE_USB3,
+};
+
 struct usb_phy;
 
 /* for transceivers connected thru an ULPI interface, the user must
@@ -89,6 +96,7 @@ struct usb_phy {
 	const char		*label;
 	unsigned int		 flags;
 
+	enum usb_phy_type	type;
 	enum usb_otg_state	state;
 	enum usb_phy_events	last_event;
 
@@ -105,6 +113,9 @@ struct usb_phy {
 	u16			port_status;
 	u16			port_change;
 
+	/* to support controllers that have multiple transceivers */
+	struct list_head	head;
+
 	/* initialize/shutdown the OTG controller */
 	int	(*init)(struct usb_phy *x);
 	void	(*shutdown)(struct usb_phy *x);
@@ -121,7 +132,8 @@ struct usb_phy {
 
 
 /* for board-specific init logic */
-extern int usb_add_phy(struct usb_phy *);
+extern int usb_add_phy(struct usb_phy *, enum usb_phy_type type);
+extern void usb_remove_phy(struct usb_phy *);
 
 #if defined(CONFIG_NOP_USB_XCEIV) || (defined(CONFIG_NOP_USB_XCEIV_MODULE) && defined(MODULE))
 /* sometimes transceivers are accessed only through e.g. ULPI */
@@ -172,11 +184,11 @@ usb_phy_shutdown(struct usb_phy *x)
 
 /* for usb host and peripheral controller drivers */
 #ifdef CONFIG_USB_OTG_UTILS
-extern struct usb_phy *usb_get_phy(void);
+extern struct usb_phy *usb_get_phy(enum usb_phy_type type);
 extern void usb_put_phy(struct usb_phy *);
 extern const char *otg_state_string(enum usb_otg_state state);
 #else
-static inline struct usb_phy *usb_get_phy(void)
+static inline struct usb_phy *usb_get_phy(enum usb_phy_type type)
 {
 	return NULL;
 }
@@ -276,4 +288,15 @@ usb_unregister_notifier(struct usb_phy *x, struct notifier_block *nb)
 /* for OTG controller drivers (and maybe other stuff) */
 extern int usb_bus_start_enum(struct usb_bus *bus, unsigned port_num);
 
+static inline const char *usb_phy_type_string(enum usb_phy_type type)
+{
+	switch (type) {
+	case USB_PHY_TYPE_USB2:
+		return "USB2 PHY";
+	case USB_PHY_TYPE_USB3:
+		return "USB3 PHY";
+	default:
+		return "UNKNOWN PHY TYPE";
+	}
+}
 #endif /* __LINUX_USB_OTG_H */

commit 721002ec1dd55a52425455826af49cf8853b2d4f
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Fri Jun 22 17:02:45 2012 +0530

    usb: otg: utils: rename function name in OTG utils
    
    _transceiver() in otg.c is replaced with _phy. usb_set_transceiver is
    replaced with usb_add_phy to make it similar to other usb standard
    function names like usb_add_hcd.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 38ab3f46346f..0e739c810525 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -121,7 +121,7 @@ struct usb_phy {
 
 
 /* for board-specific init logic */
-extern int usb_set_transceiver(struct usb_phy *);
+extern int usb_add_phy(struct usb_phy *);
 
 #if defined(CONFIG_NOP_USB_XCEIV) || (defined(CONFIG_NOP_USB_XCEIV_MODULE) && defined(MODULE))
 /* sometimes transceivers are accessed only through e.g. ULPI */
@@ -172,16 +172,16 @@ usb_phy_shutdown(struct usb_phy *x)
 
 /* for usb host and peripheral controller drivers */
 #ifdef CONFIG_USB_OTG_UTILS
-extern struct usb_phy *usb_get_transceiver(void);
-extern void usb_put_transceiver(struct usb_phy *);
+extern struct usb_phy *usb_get_phy(void);
+extern void usb_put_phy(struct usb_phy *);
 extern const char *otg_state_string(enum usb_otg_state state);
 #else
-static inline struct usb_phy *usb_get_transceiver(void)
+static inline struct usb_phy *usb_get_phy(void)
 {
 	return NULL;
 }
 
-static inline void usb_put_transceiver(struct usb_phy *x)
+static inline void usb_put_phy(struct usb_phy *x)
 {
 }
 

commit bf070bc14178f1458e7eccd76316ac24f76f1890
Author: Grazvydas Ignotas <notasas@gmail.com>
Date:   Wed Mar 21 16:35:52 2012 +0200

    usb: musb: wake the device before ulpi transfers
    
    musb can be suspended at the time some other driver wants to do ulpi
    transfers using usb_phy_io_* functions, and that can cause data abort,
    as it happened with isp1704_charger:
    http://article.gmane.org/gmane.linux.kernel/1226122
    
    Add pm_runtime to ulpi functions to rectify this. This also adds io_dev
    to usb_phy so that pm_runtime_* functions can be used.
    
    Cc: Felipe Contreras <felipe.contreras@gmail.com>
    Signed-off-by: Grazvydas Ignotas <notasas@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index f67810f8f21b..38ab3f46346f 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -94,6 +94,7 @@ struct usb_phy {
 
 	struct usb_otg		*otg;
 
+	struct device		*io_dev;
 	struct usb_phy_io_ops	*io_ops;
 	void __iomem		*io_priv;
 

commit 6e13c6505cdff9766d5268ffb8c972c1a2f996e6
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Mon Feb 13 13:24:20 2012 +0200

    usb: otg: Convert all users to pass struct usb_otg for OTG functions
    
    This changes the otg functions so that they receive struct
    otg instead of struct usb_phy as parameter and
    converts all users of these functions to pass the otg member
    of their usb_phy.
    
    Includes fixes to IMX code from Sascha Hauer.
    
    [ balbi@ti.com : fixed a compile warning on ehci-mv.c ]
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Igor Grinberg <grinberg@compulab.co.il>
    Acked-by: Pavankumar Kondeti <pkondeti@codeaurora.org>
    Acked-by: Li Yang <leoli@freescale.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Reviewed-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index de89342098e4..f67810f8f21b 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -192,30 +192,30 @@ static inline const char *otg_state_string(enum usb_otg_state state)
 
 /* Context: can sleep */
 static inline int
-otg_start_hnp(struct usb_phy *x)
+otg_start_hnp(struct usb_otg *otg)
 {
-	if (x->otg && x->otg->start_hnp)
-		return x->otg->start_hnp(x->otg);
+	if (otg && otg->start_hnp)
+		return otg->start_hnp(otg);
 
 	return -ENOTSUPP;
 }
 
 /* Context: can sleep */
 static inline int
-otg_set_vbus(struct usb_phy *x, bool enabled)
+otg_set_vbus(struct usb_otg *otg, bool enabled)
 {
-	if (x->otg && x->otg->set_vbus)
-		return x->otg->set_vbus(x->otg, enabled);
+	if (otg && otg->set_vbus)
+		return otg->set_vbus(otg, enabled);
 
 	return -ENOTSUPP;
 }
 
 /* for HCDs */
 static inline int
-otg_set_host(struct usb_phy *x, struct usb_bus *host)
+otg_set_host(struct usb_otg *otg, struct usb_bus *host)
 {
-	if (x->otg && x->otg->set_host)
-		return x->otg->set_host(x->otg, host);
+	if (otg && otg->set_host)
+		return otg->set_host(otg, host);
 
 	return -ENOTSUPP;
 }
@@ -224,10 +224,10 @@ otg_set_host(struct usb_phy *x, struct usb_bus *host)
 
 /* Context: can sleep */
 static inline int
-otg_set_peripheral(struct usb_phy *x, struct usb_gadget *periph)
+otg_set_peripheral(struct usb_otg *otg, struct usb_gadget *periph)
 {
-	if (x->otg && x->otg->set_peripheral)
-		return x->otg->set_peripheral(x->otg, periph);
+	if (otg && otg->set_peripheral)
+		return otg->set_peripheral(otg, periph);
 
 	return -ENOTSUPP;
 }
@@ -251,10 +251,10 @@ usb_phy_set_suspend(struct usb_phy *x, int suspend)
 }
 
 static inline int
-otg_start_srp(struct usb_phy *x)
+otg_start_srp(struct usb_otg *otg)
 {
-	if (x->otg && x->otg->start_srp)
-		return x->otg->start_srp(x->otg);
+	if (otg && otg->start_srp)
+		return otg->start_srp(otg);
 
 	return -ENOTSUPP;
 }

commit 136ced891ad2762dfe5ba476103e82ea2b9aff41
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Mon Feb 13 13:24:19 2012 +0200

    usb: otg: Remove OTG specific members from usb_phy
    
    All the drivers are now converted to use struct usb_otg, so
    removing the OTG specific members from struct usb_phy.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Reviewed-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 5c1cfbc73555..de89342098e4 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -89,15 +89,11 @@ struct usb_phy {
 	const char		*label;
 	unsigned int		 flags;
 
-	u8			default_a;
 	enum usb_otg_state	state;
 	enum usb_phy_events	last_event;
 
 	struct usb_otg		*otg;
 
-	struct usb_bus		*host;
-	struct usb_gadget	*gadget;
-
 	struct usb_phy_io_ops	*io_ops;
 	void __iomem		*io_priv;
 
@@ -112,32 +108,14 @@ struct usb_phy {
 	int	(*init)(struct usb_phy *x);
 	void	(*shutdown)(struct usb_phy *x);
 
-	/* bind/unbind the host controller */
-	int	(*set_host)(struct usb_phy *x,
-				struct usb_bus *host);
-
-	/* bind/unbind the peripheral controller */
-	int	(*set_peripheral)(struct usb_phy *x,
-				struct usb_gadget *gadget);
-
 	/* effective for B devices, ignored for A-peripheral */
 	int	(*set_power)(struct usb_phy *x,
 				unsigned mA);
 
-	/* effective for A-peripheral, ignored for B devices */
-	int	(*set_vbus)(struct usb_phy *x,
-				bool enabled);
-
 	/* for non-OTG B devices: set transceiver into suspend mode */
 	int	(*set_suspend)(struct usb_phy *x,
 				int suspend);
 
-	/* for B devices only:  start session with A-Host */
-	int	(*start_srp)(struct usb_phy *x);
-
-	/* start or continue HNP role switch */
-	int	(*start_hnp)(struct usb_phy *x);
-
 };
 
 
@@ -219,7 +197,7 @@ otg_start_hnp(struct usb_phy *x)
 	if (x->otg && x->otg->start_hnp)
 		return x->otg->start_hnp(x->otg);
 
-	return x->start_hnp(x);
+	return -ENOTSUPP;
 }
 
 /* Context: can sleep */
@@ -229,7 +207,7 @@ otg_set_vbus(struct usb_phy *x, bool enabled)
 	if (x->otg && x->otg->set_vbus)
 		return x->otg->set_vbus(x->otg, enabled);
 
-	return x->set_vbus(x, enabled);
+	return -ENOTSUPP;
 }
 
 /* for HCDs */
@@ -239,7 +217,7 @@ otg_set_host(struct usb_phy *x, struct usb_bus *host)
 	if (x->otg && x->otg->set_host)
 		return x->otg->set_host(x->otg, host);
 
-	return x->set_host(x, host);
+	return -ENOTSUPP;
 }
 
 /* for usb peripheral controller drivers */
@@ -251,7 +229,7 @@ otg_set_peripheral(struct usb_phy *x, struct usb_gadget *periph)
 	if (x->otg && x->otg->set_peripheral)
 		return x->otg->set_peripheral(x->otg, periph);
 
-	return x->set_peripheral(x, periph);
+	return -ENOTSUPP;
 }
 
 static inline int
@@ -278,7 +256,7 @@ otg_start_srp(struct usb_phy *x)
 	if (x->otg && x->otg->start_srp)
 		return x->otg->start_srp(x->otg);
 
-	return x->start_srp(x);
+	return -ENOTSUPP;
 }
 
 /* notifiers */
@@ -297,22 +275,4 @@ usb_unregister_notifier(struct usb_phy *x, struct notifier_block *nb)
 /* for OTG controller drivers (and maybe other stuff) */
 extern int usb_bus_start_enum(struct usb_bus *bus, unsigned port_num);
 
-/* Temporary aliases for transceiver functions */
-#define otg_set_transceiver(x) usb_set_transceiver(x)
-#define otg_get_transceiver() usb_get_transceiver()
-#define otg_put_transceiver(x) usb_put_transceiver(x)
-
-#define otg_io_read(x, a) usb_phy_io_read(x, a)
-#define otg_io_write(x, a, b) usb_phy_io_write(x, a, b)
-
-#define otg_init(x) usb_phy_init(x)
-#define otg_shutdown(x) usb_phy_shutdown(x)
-#define otg_set_power(x, a) usb_phy_set_power(x, a)
-#define otg_set_suspend(x, a) usb_phy_set_suspend(x, a)
-
-#define otg_register_notifier(x, a) usb_register_notifier(x, a)
-#define otg_unregister_notifier(x, a) usb_unregiser_notifier(x, a)
-
-#define otg_io_access_ops usb_phy_io_ops
-
 #endif /* __LINUX_USB_OTG_H */

commit 7a8a3a9bec7432eedcb32b54a3940d0593246060
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Mon Feb 13 13:24:04 2012 +0200

    usb: otg: Separate otg members from usb_phy
    
    Introducing struct otg and collecting otg specific members
    to it from struct usb_phy. There are no changes to
    struct usb_phy at this stage. This also renames
    transceiver specific functions, and offers aliases for the
    old otg ones.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Reviewed-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 723a000146f8..5c1cfbc73555 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -48,11 +48,36 @@ struct usb_phy;
 /* for transceivers connected thru an ULPI interface, the user must
  * provide access ops
  */
-struct otg_io_access_ops {
+struct usb_phy_io_ops {
 	int (*read)(struct usb_phy *x, u32 reg);
 	int (*write)(struct usb_phy *x, u32 val, u32 reg);
 };
 
+struct usb_otg {
+	u8			default_a;
+
+	struct usb_phy		*phy;
+	struct usb_bus		*host;
+	struct usb_gadget	*gadget;
+
+	/* bind/unbind the host controller */
+	int	(*set_host)(struct usb_otg *otg, struct usb_bus *host);
+
+	/* bind/unbind the peripheral controller */
+	int	(*set_peripheral)(struct usb_otg *otg,
+					struct usb_gadget *gadget);
+
+	/* effective for A-peripheral, ignored for B devices */
+	int	(*set_vbus)(struct usb_otg *otg, bool enabled);
+
+	/* for B devices only:  start session with A-Host */
+	int	(*start_srp)(struct usb_otg *otg);
+
+	/* start or continue HNP role switch */
+	int	(*start_hnp)(struct usb_otg *otg);
+
+};
+
 /*
  * the otg driver needs to interact with both device side and host side
  * usb controllers.  it decides which controller is active at a given
@@ -68,11 +93,13 @@ struct usb_phy {
 	enum usb_otg_state	state;
 	enum usb_phy_events	last_event;
 
+	struct usb_otg		*otg;
+
 	struct usb_bus		*host;
 	struct usb_gadget	*gadget;
 
-	struct otg_io_access_ops	*io_ops;
-	void __iomem			*io_priv;
+	struct usb_phy_io_ops	*io_ops;
+	void __iomem		*io_priv;
 
 	/* for notification of usb_phy_events */
 	struct atomic_notifier_head	notifier;
@@ -115,7 +142,7 @@ struct usb_phy {
 
 
 /* for board-specific init logic */
-extern int otg_set_transceiver(struct usb_phy *);
+extern int usb_set_transceiver(struct usb_phy *);
 
 #if defined(CONFIG_NOP_USB_XCEIV) || (defined(CONFIG_NOP_USB_XCEIV_MODULE) && defined(MODULE))
 /* sometimes transceivers are accessed only through e.g. ULPI */
@@ -132,7 +159,7 @@ static inline void usb_nop_xceiv_unregister(void)
 #endif
 
 /* helpers for direct access thru low-level io interface */
-static inline int otg_io_read(struct usb_phy *x, u32 reg)
+static inline int usb_phy_io_read(struct usb_phy *x, u32 reg)
 {
 	if (x->io_ops && x->io_ops->read)
 		return x->io_ops->read(x, reg);
@@ -140,7 +167,7 @@ static inline int otg_io_read(struct usb_phy *x, u32 reg)
 	return -EINVAL;
 }
 
-static inline int otg_io_write(struct usb_phy *x, u32 val, u32 reg)
+static inline int usb_phy_io_write(struct usb_phy *x, u32 val, u32 reg)
 {
 	if (x->io_ops && x->io_ops->write)
 		return x->io_ops->write(x, val, reg);
@@ -149,7 +176,7 @@ static inline int otg_io_write(struct usb_phy *x, u32 val, u32 reg)
 }
 
 static inline int
-otg_init(struct usb_phy *x)
+usb_phy_init(struct usb_phy *x)
 {
 	if (x->init)
 		return x->init(x);
@@ -158,7 +185,7 @@ otg_init(struct usb_phy *x)
 }
 
 static inline void
-otg_shutdown(struct usb_phy *x)
+usb_phy_shutdown(struct usb_phy *x)
 {
 	if (x->shutdown)
 		x->shutdown(x);
@@ -166,16 +193,16 @@ otg_shutdown(struct usb_phy *x)
 
 /* for usb host and peripheral controller drivers */
 #ifdef CONFIG_USB_OTG_UTILS
-extern struct usb_phy *otg_get_transceiver(void);
-extern void otg_put_transceiver(struct usb_phy *);
+extern struct usb_phy *usb_get_transceiver(void);
+extern void usb_put_transceiver(struct usb_phy *);
 extern const char *otg_state_string(enum usb_otg_state state);
 #else
-static inline struct usb_phy *otg_get_transceiver(void)
+static inline struct usb_phy *usb_get_transceiver(void)
 {
 	return NULL;
 }
 
-static inline void otg_put_transceiver(struct usb_phy *x)
+static inline void usb_put_transceiver(struct usb_phy *x)
 {
 }
 
@@ -189,6 +216,9 @@ static inline const char *otg_state_string(enum usb_otg_state state)
 static inline int
 otg_start_hnp(struct usb_phy *x)
 {
+	if (x->otg && x->otg->start_hnp)
+		return x->otg->start_hnp(x->otg);
+
 	return x->start_hnp(x);
 }
 
@@ -196,6 +226,9 @@ otg_start_hnp(struct usb_phy *x)
 static inline int
 otg_set_vbus(struct usb_phy *x, bool enabled)
 {
+	if (x->otg && x->otg->set_vbus)
+		return x->otg->set_vbus(x->otg, enabled);
+
 	return x->set_vbus(x, enabled);
 }
 
@@ -203,6 +236,9 @@ otg_set_vbus(struct usb_phy *x, bool enabled)
 static inline int
 otg_set_host(struct usb_phy *x, struct usb_bus *host)
 {
+	if (x->otg && x->otg->set_host)
+		return x->otg->set_host(x->otg, host);
+
 	return x->set_host(x, host);
 }
 
@@ -212,18 +248,23 @@ otg_set_host(struct usb_phy *x, struct usb_bus *host)
 static inline int
 otg_set_peripheral(struct usb_phy *x, struct usb_gadget *periph)
 {
+	if (x->otg && x->otg->set_peripheral)
+		return x->otg->set_peripheral(x->otg, periph);
+
 	return x->set_peripheral(x, periph);
 }
 
 static inline int
-otg_set_power(struct usb_phy *x, unsigned mA)
+usb_phy_set_power(struct usb_phy *x, unsigned mA)
 {
-	return x->set_power(x, mA);
+	if (x && x->set_power)
+		return x->set_power(x, mA);
+	return 0;
 }
 
 /* Context: can sleep */
 static inline int
-otg_set_suspend(struct usb_phy *x, int suspend)
+usb_phy_set_suspend(struct usb_phy *x, int suspend)
 {
 	if (x->set_suspend != NULL)
 		return x->set_suspend(x, suspend);
@@ -234,18 +275,21 @@ otg_set_suspend(struct usb_phy *x, int suspend)
 static inline int
 otg_start_srp(struct usb_phy *x)
 {
+	if (x->otg && x->otg->start_srp)
+		return x->otg->start_srp(x->otg);
+
 	return x->start_srp(x);
 }
 
 /* notifiers */
 static inline int
-otg_register_notifier(struct usb_phy *x, struct notifier_block *nb)
+usb_register_notifier(struct usb_phy *x, struct notifier_block *nb)
 {
 	return atomic_notifier_chain_register(&x->notifier, nb);
 }
 
 static inline void
-otg_unregister_notifier(struct usb_phy *x, struct notifier_block *nb)
+usb_unregister_notifier(struct usb_phy *x, struct notifier_block *nb)
 {
 	atomic_notifier_chain_unregister(&x->notifier, nb);
 }
@@ -253,4 +297,22 @@ otg_unregister_notifier(struct usb_phy *x, struct notifier_block *nb)
 /* for OTG controller drivers (and maybe other stuff) */
 extern int usb_bus_start_enum(struct usb_bus *bus, unsigned port_num);
 
+/* Temporary aliases for transceiver functions */
+#define otg_set_transceiver(x) usb_set_transceiver(x)
+#define otg_get_transceiver() usb_get_transceiver()
+#define otg_put_transceiver(x) usb_put_transceiver(x)
+
+#define otg_io_read(x, a) usb_phy_io_read(x, a)
+#define otg_io_write(x, a, b) usb_phy_io_write(x, a, b)
+
+#define otg_init(x) usb_phy_init(x)
+#define otg_shutdown(x) usb_phy_shutdown(x)
+#define otg_set_power(x, a) usb_phy_set_power(x, a)
+#define otg_set_suspend(x, a) usb_phy_set_suspend(x, a)
+
+#define otg_register_notifier(x, a) usb_register_notifier(x, a)
+#define otg_unregister_notifier(x, a) usb_unregiser_notifier(x, a)
+
+#define otg_io_access_ops usb_phy_io_ops
+
 #endif /* __LINUX_USB_OTG_H */

commit de07e18c00c403d5076a5a697d83fe3ced73bc30
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Mon Feb 13 13:24:03 2012 +0200

    usb: otg: Rename usb_xceiv_event to usb_phy_event
    
    Convert all users.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Reviewed-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index e0bc55702a89..723a000146f8 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -35,7 +35,7 @@ enum usb_otg_state {
 	OTG_STATE_A_VBUS_ERR,
 };
 
-enum usb_xceiv_events {
+enum usb_phy_events {
 	USB_EVENT_NONE,         /* no events or cable disconnected */
 	USB_EVENT_VBUS,         /* vbus valid event */
 	USB_EVENT_ID,           /* id was grounded */
@@ -66,7 +66,7 @@ struct usb_phy {
 
 	u8			default_a;
 	enum usb_otg_state	state;
-	enum usb_xceiv_events	last_event;
+	enum usb_phy_events	last_event;
 
 	struct usb_bus		*host;
 	struct usb_gadget	*gadget;
@@ -74,7 +74,7 @@ struct usb_phy {
 	struct otg_io_access_ops	*io_ops;
 	void __iomem			*io_priv;
 
-	/* for notification of usb_xceiv_events */
+	/* for notification of usb_phy_events */
 	struct atomic_notifier_head	notifier;
 
 	/* to pass extra port status to the root hub */

commit 8675381109b0eb1c948a423c2b35e3f4509cb25e
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Mon Feb 13 13:24:02 2012 +0200

    usb: otg: Rename otg_transceiver to usb_phy
    
    This is the first step in separating USB transceivers from
    USB OTG utilities.
    
    Includes fixes to IMX code from Sascha Hauer.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Pavankumar Kondeti <pkondeti@codeaurora.org>
    Acked-by: Li Yang <leoli@freescale.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Igor Grinberg <grinberg@compulab.co.il>
    Reviewed-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index d87f44f5b04e..e0bc55702a89 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -43,14 +43,14 @@ enum usb_xceiv_events {
 	USB_EVENT_ENUMERATED,   /* gadget driver enumerated */
 };
 
-struct otg_transceiver;
+struct usb_phy;
 
 /* for transceivers connected thru an ULPI interface, the user must
  * provide access ops
  */
 struct otg_io_access_ops {
-	int (*read)(struct otg_transceiver *otg, u32 reg);
-	int (*write)(struct otg_transceiver *otg, u32 val, u32 reg);
+	int (*read)(struct usb_phy *x, u32 reg);
+	int (*write)(struct usb_phy *x, u32 val, u32 reg);
 };
 
 /*
@@ -59,7 +59,7 @@ struct otg_io_access_ops {
  * moment, using the transceiver, ID signal, HNP and sometimes static
  * configuration information (including "board isn't wired for otg").
  */
-struct otg_transceiver {
+struct usb_phy {
 	struct device		*dev;
 	const char		*label;
 	unsigned int		 flags;
@@ -82,40 +82,40 @@ struct otg_transceiver {
 	u16			port_change;
 
 	/* initialize/shutdown the OTG controller */
-	int	(*init)(struct otg_transceiver *otg);
-	void	(*shutdown)(struct otg_transceiver *otg);
+	int	(*init)(struct usb_phy *x);
+	void	(*shutdown)(struct usb_phy *x);
 
 	/* bind/unbind the host controller */
-	int	(*set_host)(struct otg_transceiver *otg,
+	int	(*set_host)(struct usb_phy *x,
 				struct usb_bus *host);
 
 	/* bind/unbind the peripheral controller */
-	int	(*set_peripheral)(struct otg_transceiver *otg,
+	int	(*set_peripheral)(struct usb_phy *x,
 				struct usb_gadget *gadget);
 
 	/* effective for B devices, ignored for A-peripheral */
-	int	(*set_power)(struct otg_transceiver *otg,
+	int	(*set_power)(struct usb_phy *x,
 				unsigned mA);
 
 	/* effective for A-peripheral, ignored for B devices */
-	int	(*set_vbus)(struct otg_transceiver *otg,
+	int	(*set_vbus)(struct usb_phy *x,
 				bool enabled);
 
 	/* for non-OTG B devices: set transceiver into suspend mode */
-	int	(*set_suspend)(struct otg_transceiver *otg,
+	int	(*set_suspend)(struct usb_phy *x,
 				int suspend);
 
 	/* for B devices only:  start session with A-Host */
-	int	(*start_srp)(struct otg_transceiver *otg);
+	int	(*start_srp)(struct usb_phy *x);
 
 	/* start or continue HNP role switch */
-	int	(*start_hnp)(struct otg_transceiver *otg);
+	int	(*start_hnp)(struct usb_phy *x);
 
 };
 
 
 /* for board-specific init logic */
-extern int otg_set_transceiver(struct otg_transceiver *);
+extern int otg_set_transceiver(struct usb_phy *);
 
 #if defined(CONFIG_NOP_USB_XCEIV) || (defined(CONFIG_NOP_USB_XCEIV_MODULE) && defined(MODULE))
 /* sometimes transceivers are accessed only through e.g. ULPI */
@@ -132,50 +132,50 @@ static inline void usb_nop_xceiv_unregister(void)
 #endif
 
 /* helpers for direct access thru low-level io interface */
-static inline int otg_io_read(struct otg_transceiver *otg, u32 reg)
+static inline int otg_io_read(struct usb_phy *x, u32 reg)
 {
-	if (otg->io_ops && otg->io_ops->read)
-		return otg->io_ops->read(otg, reg);
+	if (x->io_ops && x->io_ops->read)
+		return x->io_ops->read(x, reg);
 
 	return -EINVAL;
 }
 
-static inline int otg_io_write(struct otg_transceiver *otg, u32 val, u32 reg)
+static inline int otg_io_write(struct usb_phy *x, u32 val, u32 reg)
 {
-	if (otg->io_ops && otg->io_ops->write)
-		return otg->io_ops->write(otg, val, reg);
+	if (x->io_ops && x->io_ops->write)
+		return x->io_ops->write(x, val, reg);
 
 	return -EINVAL;
 }
 
 static inline int
-otg_init(struct otg_transceiver *otg)
+otg_init(struct usb_phy *x)
 {
-	if (otg->init)
-		return otg->init(otg);
+	if (x->init)
+		return x->init(x);
 
 	return 0;
 }
 
 static inline void
-otg_shutdown(struct otg_transceiver *otg)
+otg_shutdown(struct usb_phy *x)
 {
-	if (otg->shutdown)
-		otg->shutdown(otg);
+	if (x->shutdown)
+		x->shutdown(x);
 }
 
 /* for usb host and peripheral controller drivers */
 #ifdef CONFIG_USB_OTG_UTILS
-extern struct otg_transceiver *otg_get_transceiver(void);
-extern void otg_put_transceiver(struct otg_transceiver *);
+extern struct usb_phy *otg_get_transceiver(void);
+extern void otg_put_transceiver(struct usb_phy *);
 extern const char *otg_state_string(enum usb_otg_state state);
 #else
-static inline struct otg_transceiver *otg_get_transceiver(void)
+static inline struct usb_phy *otg_get_transceiver(void)
 {
 	return NULL;
 }
 
-static inline void otg_put_transceiver(struct otg_transceiver *x)
+static inline void otg_put_transceiver(struct usb_phy *x)
 {
 }
 
@@ -187,67 +187,67 @@ static inline const char *otg_state_string(enum usb_otg_state state)
 
 /* Context: can sleep */
 static inline int
-otg_start_hnp(struct otg_transceiver *otg)
+otg_start_hnp(struct usb_phy *x)
 {
-	return otg->start_hnp(otg);
+	return x->start_hnp(x);
 }
 
 /* Context: can sleep */
 static inline int
-otg_set_vbus(struct otg_transceiver *otg, bool enabled)
+otg_set_vbus(struct usb_phy *x, bool enabled)
 {
-	return otg->set_vbus(otg, enabled);
+	return x->set_vbus(x, enabled);
 }
 
 /* for HCDs */
 static inline int
-otg_set_host(struct otg_transceiver *otg, struct usb_bus *host)
+otg_set_host(struct usb_phy *x, struct usb_bus *host)
 {
-	return otg->set_host(otg, host);
+	return x->set_host(x, host);
 }
 
 /* for usb peripheral controller drivers */
 
 /* Context: can sleep */
 static inline int
-otg_set_peripheral(struct otg_transceiver *otg, struct usb_gadget *periph)
+otg_set_peripheral(struct usb_phy *x, struct usb_gadget *periph)
 {
-	return otg->set_peripheral(otg, periph);
+	return x->set_peripheral(x, periph);
 }
 
 static inline int
-otg_set_power(struct otg_transceiver *otg, unsigned mA)
+otg_set_power(struct usb_phy *x, unsigned mA)
 {
-	return otg->set_power(otg, mA);
+	return x->set_power(x, mA);
 }
 
 /* Context: can sleep */
 static inline int
-otg_set_suspend(struct otg_transceiver *otg, int suspend)
+otg_set_suspend(struct usb_phy *x, int suspend)
 {
-	if (otg->set_suspend != NULL)
-		return otg->set_suspend(otg, suspend);
+	if (x->set_suspend != NULL)
+		return x->set_suspend(x, suspend);
 	else
 		return 0;
 }
 
 static inline int
-otg_start_srp(struct otg_transceiver *otg)
+otg_start_srp(struct usb_phy *x)
 {
-	return otg->start_srp(otg);
+	return x->start_srp(x);
 }
 
 /* notifiers */
 static inline int
-otg_register_notifier(struct otg_transceiver *otg, struct notifier_block *nb)
+otg_register_notifier(struct usb_phy *x, struct notifier_block *nb)
 {
-	return atomic_notifier_chain_register(&otg->notifier, nb);
+	return atomic_notifier_chain_register(&x->notifier, nb);
 }
 
 static inline void
-otg_unregister_notifier(struct otg_transceiver *otg, struct notifier_block *nb)
+otg_unregister_notifier(struct usb_phy *x, struct notifier_block *nb)
 {
-	atomic_notifier_chain_unregister(&otg->notifier, nb);
+	atomic_notifier_chain_unregister(&x->notifier, nb);
 }
 
 /* for OTG controller drivers (and maybe other stuff) */

commit 3df004532582d0cc721da0df28311bcedd639724
Author: Anatolij Gustschin <agust@denx.de>
Date:   Thu May 5 12:11:21 2011 +0200

    usb: fix building musb drivers
    
    Commit 3dacdf11 "usb: factor out state_string() on otg drivers"
    broke building musb drivers since there is already another
    otg_state_string() function in musb drivers, but with different
    prototype. Fix musb drivers to use common otg_state_string(), too.
    
    Also provide a nop for otg_state_string() if CONFIG_USB_OTG_UTILS
    is not defined.
    
    Signed-off-by: Anatolij Gustschin <agust@denx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index bc84858b3a4d..d87f44f5b04e 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -168,6 +168,7 @@ otg_shutdown(struct otg_transceiver *otg)
 #ifdef CONFIG_USB_OTG_UTILS
 extern struct otg_transceiver *otg_get_transceiver(void);
 extern void otg_put_transceiver(struct otg_transceiver *);
+extern const char *otg_state_string(enum usb_otg_state state);
 #else
 static inline struct otg_transceiver *otg_get_transceiver(void)
 {
@@ -177,6 +178,11 @@ static inline struct otg_transceiver *otg_get_transceiver(void)
 static inline void otg_put_transceiver(struct otg_transceiver *x)
 {
 }
+
+static inline const char *otg_state_string(enum usb_otg_state state)
+{
+	return NULL;
+}
 #endif
 
 /* Context: can sleep */
@@ -246,6 +252,5 @@ otg_unregister_notifier(struct otg_transceiver *otg, struct notifier_block *nb)
 
 /* for OTG controller drivers (and maybe other stuff) */
 extern int usb_bus_start_enum(struct usb_bus *bus, unsigned port_num);
-extern const char *otg_state_string(enum usb_otg_state state);
 
 #endif /* __LINUX_USB_OTG_H */

commit 3dacdf11f1f82b98d301d5e1d42cdaea9a39968a
Author: Anatolij Gustschin <agust@denx.de>
Date:   Fri Apr 15 16:18:38 2011 +0200

    usb: factor out state_string() on otg drivers
    
    Provide common otg_state_string() and use
    it in drivers.
    
    Signed-off-by: Anatolij Gustschin <agust@denx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 6e40718f5abe..bc84858b3a4d 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -246,5 +246,6 @@ otg_unregister_notifier(struct otg_transceiver *otg, struct notifier_block *nb)
 
 /* for OTG controller drivers (and maybe other stuff) */
 extern int usb_bus_start_enum(struct usb_bus *bus, unsigned port_num);
+extern const char *otg_state_string(enum usb_otg_state state);
 
 #endif /* __LINUX_USB_OTG_H */

commit cccad6d4b103e53fb3d1fc1467f654ecb572d047
Author: Felipe Balbi <balbi@ti.com>
Date:   Wed Sep 29 10:55:49 2010 +0300

    usb: otg: notifier: switch to atomic notifier
    
    most of our notifications, will be called from IRQ
    context, so an atomic notifier suits the job better.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index da511eec3cb8..6e40718f5abe 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -75,7 +75,7 @@ struct otg_transceiver {
 	void __iomem			*io_priv;
 
 	/* for notification of usb_xceiv_events */
-	struct blocking_notifier_head	notifier;
+	struct atomic_notifier_head	notifier;
 
 	/* to pass extra port status to the root hub */
 	u16			port_status;
@@ -235,13 +235,13 @@ otg_start_srp(struct otg_transceiver *otg)
 static inline int
 otg_register_notifier(struct otg_transceiver *otg, struct notifier_block *nb)
 {
-	return blocking_notifier_chain_register(&otg->notifier, nb);
+	return atomic_notifier_chain_register(&otg->notifier, nb);
 }
 
 static inline void
 otg_unregister_notifier(struct otg_transceiver *otg, struct notifier_block *nb)
 {
-	blocking_notifier_chain_unregister(&otg->notifier, nb);
+	atomic_notifier_chain_unregister(&otg->notifier, nb);
 }
 
 /* for OTG controller drivers (and maybe other stuff) */

commit 647b2d9c61fe9a842dd89eb01b5f01e9d437993c
Author: Hema HK <hemahk@ti.com>
Date:   Thu Feb 17 12:06:09 2011 +0530

    usb: otg: TWL6030 Save the last event in otg_transceiver
    
    Save the last event in the otg_transceiver so that it can used in the
    musb driver and gadget driver to configure the musb and enable the
    vbus for host mode and OTG mode, if the device is connected during boot.
    
    Signed-off-by: Hema HK <hemahk@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index a1a1e7a73ec9..da511eec3cb8 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -66,6 +66,7 @@ struct otg_transceiver {
 
 	u8			default_a;
 	enum usb_otg_state	state;
+	enum usb_xceiv_events	last_event;
 
 	struct usb_bus		*host;
 	struct usb_gadget	*gadget;

commit 352a337832774a6929c16b569abe9cedc3db01cc
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Thu Dec 9 22:46:29 2010 +0100

    USB: otg: fix link breakage, when the NOP USB Xceiver is a module
    
    If the NOP USB OTG transceiver driver is built as a module, the otg.h
    header declares external functions, but if they are referenced from the
    kernel proper, as, e.g., in the OMAP3 case, where the omap3evm board is
    calling the usb_nop_xceiv_register() function, linkage breaks. This patch
    fixes this problem.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 0a5b3711e502..a1a1e7a73ec9 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -116,7 +116,7 @@ struct otg_transceiver {
 /* for board-specific init logic */
 extern int otg_set_transceiver(struct otg_transceiver *);
 
-#if defined(CONFIG_NOP_USB_XCEIV) || defined(CONFIG_NOP_USB_XCEIV_MODULE)
+#if defined(CONFIG_NOP_USB_XCEIV) || (defined(CONFIG_NOP_USB_XCEIV_MODULE) && defined(MODULE))
 /* sometimes transceivers are accessed only through e.g. ULPI */
 extern void usb_nop_xceiv_register(void);
 extern void usb_nop_xceiv_unregister(void);

commit 748eee0986f0d51c7bc39f194d515a8d8248ebdd
Author: Grazvydas Ignotas <notasas@gmail.com>
Date:   Mon Sep 27 15:17:18 2010 +0300

    USB: Add more empty functions in otg.h
    
    Add empty functions for get/put transceiver functions too, so that
    drivers that optionally use them can call them without worrying that
    they might not exist, eliminating ifdefs.
    
    Signed-off-by: Grazvydas Ignotas <notasas@gmail.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 545cba73ccaf..0a5b3711e502 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -164,8 +164,19 @@ otg_shutdown(struct otg_transceiver *otg)
 }
 
 /* for usb host and peripheral controller drivers */
+#ifdef CONFIG_USB_OTG_UTILS
 extern struct otg_transceiver *otg_get_transceiver(void);
 extern void otg_put_transceiver(struct otg_transceiver *);
+#else
+static inline struct otg_transceiver *otg_get_transceiver(void)
+{
+	return NULL;
+}
+
+static inline void otg_put_transceiver(struct otg_transceiver *x)
+{
+}
+#endif
 
 /* Context: can sleep */
 static inline int

commit 13dd0c9767349b280cf131c34461f85e5effc42a
Author: Igor Grinberg <grinberg@compulab.co.il>
Date:   Thu Jul 15 16:00:16 2010 +0300

    USB: otg/ulpi: extend the generic ulpi driver.
    
    1) Introduce ulpi specific flags for control of the ulpi phy
    2) Extend the generic ulpi driver with support for Function and
    Interface control of upli phy
    3) Update the platforms using the generic ulpi driver with new ulpi
    flags
    4) Remove the otg control flags not in use
    
    Signed-off-by: Igor Grinberg <grinberg@compulab.co.il>
    Signed-off-by: Mike Rapoport <mike@compulab.co.il>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 54b2c5e48b9d..545cba73ccaf 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -43,13 +43,6 @@ enum usb_xceiv_events {
 	USB_EVENT_ENUMERATED,   /* gadget driver enumerated */
 };
 
-#define USB_OTG_PULLUP_ID		(1 << 0)
-#define USB_OTG_PULLDOWN_DP		(1 << 1)
-#define USB_OTG_PULLDOWN_DM		(1 << 2)
-#define USB_OTG_EXT_VBUS_INDICATOR	(1 << 3)
-#define USB_OTG_DRV_VBUS		(1 << 4)
-#define USB_OTG_DRV_VBUS_EXT		(1 << 5)
-
 struct otg_transceiver;
 
 /* for transceivers connected thru an ULPI interface, the user must

commit 6e1c3b467ffd9d6eb725dda544f6fd10e471ea71
Author: Igor Grinberg <grinberg@compulab.co.il>
Date:   Thu May 27 09:32:13 2010 +0300

    USB: otg.h: Fix the mixup in parameters order.
    
    otg_io_write() function does not follow the declaration of
    struct otg_io_access_ops.
    
    Signed-off-by: Igor Grinberg <grinberg@compulab.co.il>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index f8302d036a76..54b2c5e48b9d 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -146,10 +146,10 @@ static inline int otg_io_read(struct otg_transceiver *otg, u32 reg)
 	return -EINVAL;
 }
 
-static inline int otg_io_write(struct otg_transceiver *otg, u32 reg, u32 val)
+static inline int otg_io_write(struct otg_transceiver *otg, u32 val, u32 reg)
 {
 	if (otg->io_ops && otg->io_ops->write)
-		return otg->io_ops->write(otg, reg, val);
+		return otg->io_ops->write(otg, val, reg);
 
 	return -EINVAL;
 }

commit 7f5b09c15ab989ed5ce4adda0be42c1302df70b7
Merge: 944680802201 cedf8a784219
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 3 08:48:58 2010 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6: (220 commits)
      USB: backlight, appledisplay: fix incomplete registration failure handling
      USB: pl2303: remove unnecessary reset of usb_device in urbs
      USB: ftdi_sio: remove obsolete check in unthrottle
      USB: ftdi_sio: remove unused tx_bytes counter
      USB: qcaux: driver for auxiliary serial ports on Qualcomm devices
      USB: pl2303: initial TIOCGSERIAL support
      USB: option: add Longcheer/Longsung vendor ID
      USB: fix I2C API usage in ohci-pnx4008.
      USB: usbmon: mask seconds properly in text API
      USB: sisusbvga: no unnecessary GFP_ATOMIC
      USB: storage: onetouch: unnecessary GFP_ATOMIC
      USB: serial: ftdi: add CONTEC vendor and product id
      USB: remove references to port->port.count from the serial drivers
      USB: tty: Prune uses of tty_request_room in the USB layer
      USB: tty: Add a function to insert a string of characters with the same flag
      USB: don't read past config->interface[] if usb_control_msg() fails in usb_reset_configuration()
      USB: tty: kill request_room for USB ACM class
      USB: tty: sort out the request_room handling for whiteheat
      USB: storage: fix misplaced parenthesis
      USB: vstusb.c: removal of driver for Vernier Software & Technology, Inc., devices and spectrometers
      ...

commit e9a20171dfa0aa134d2211126d1310f2daea52cf
Author: Felipe Balbi <felipe.balbi@nokia.com>
Date:   Thu Dec 17 13:01:36 2009 +0200

    USB: otg: add notifier support
    
    The notifier will be used to communicate usb events
    to other drivers like the charger chip.
    
    This can be used as source of information to kick
    usb charger detection as described by the USB
    Battery Charging Specification 1.1 and/or to
    pass bMaxPower field of selected usb_configuration
    to charger chip in order to use that information
    as input current on the charging profile
    setup.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 52bb917641f0..6c0b676b27d8 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -9,6 +9,8 @@
 #ifndef __LINUX_USB_OTG_H
 #define __LINUX_USB_OTG_H
 
+#include <linux/notifier.h>
+
 /* OTG defines lots of enumeration states before device reset */
 enum usb_otg_state {
 	OTG_STATE_UNDEFINED = 0,
@@ -33,6 +35,14 @@ enum usb_otg_state {
 	OTG_STATE_A_VBUS_ERR,
 };
 
+enum usb_xceiv_events {
+	USB_EVENT_NONE,         /* no events or cable disconnected */
+	USB_EVENT_VBUS,         /* vbus valid event */
+	USB_EVENT_ID,           /* id was grounded */
+	USB_EVENT_CHARGER,      /* usb dedicated charger */
+	USB_EVENT_ENUMERATED,   /* gadget driver enumerated */
+};
+
 #define USB_OTG_PULLUP_ID		(1 << 0)
 #define USB_OTG_PULLDOWN_DP		(1 << 1)
 #define USB_OTG_PULLDOWN_DM		(1 << 2)
@@ -70,6 +80,9 @@ struct otg_transceiver {
 	struct otg_io_access_ops	*io_ops;
 	void __iomem			*io_priv;
 
+	/* for notification of usb_xceiv_events */
+	struct blocking_notifier_head	notifier;
+
 	/* to pass extra port status to the root hub */
 	u16			port_status;
 	u16			port_change;
@@ -203,6 +216,18 @@ otg_start_srp(struct otg_transceiver *otg)
 	return otg->start_srp(otg);
 }
 
+/* notifiers */
+static inline int
+otg_register_notifier(struct otg_transceiver *otg, struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&otg->notifier, nb);
+}
+
+static inline void
+otg_unregister_notifier(struct otg_transceiver *otg, struct notifier_block *nb)
+{
+	blocking_notifier_chain_unregister(&otg->notifier, nb);
+}
 
 /* for OTG controller drivers (and maybe other stuff) */
 extern int usb_bus_start_enum(struct usb_bus *bus, unsigned port_num);

commit 224e1542b6ca2d38dc0c7ea65fb6760c082b1309
Author: Maulik Mankad <x0082077@ti.com>
Date:   Wed Feb 17 14:09:29 2010 -0800

    USB: Add empty functions in otg.h
    
    Add empty functions for usb_nop_xceiv_register()
    and usb_nop_xceiv_unregister() in otg.h so that
    these functions can be called even when
    CONFIG_NOP_USB_XCEIV is not enabled.
    
    It allows to remove ifdef's from board file.
    
    Signed-off-by: Maulik Mankad <x0082077@ti.com>
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Ajay Kumar Gupta <ajay.gupta@ti.com>
    Acked-by: Olof Johansson <olof@lixom.net>
    Acked-by: Felipe Balbi <felipe.balbi@nokia.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 52bb917641f0..fef0972c8146 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -110,9 +110,19 @@ struct otg_transceiver {
 /* for board-specific init logic */
 extern int otg_set_transceiver(struct otg_transceiver *);
 
+#if defined(CONFIG_NOP_USB_XCEIV) || defined(CONFIG_NOP_USB_XCEIV_MODULE)
 /* sometimes transceivers are accessed only through e.g. ULPI */
 extern void usb_nop_xceiv_register(void);
 extern void usb_nop_xceiv_unregister(void);
+#else
+static inline void usb_nop_xceiv_register(void)
+{
+}
+
+static inline void usb_nop_xceiv_unregister(void)
+{
+}
+#endif
 
 /* helpers for direct access thru low-level io interface */
 static inline int otg_io_read(struct otg_transceiver *otg, u32 reg)

commit 91c8a5a9985d5bf9c55f6f82f183f57b050b2a3a
Author: Daniel Mack <daniel@caiaq.de>
Date:   Thu Oct 15 17:09:34 2009 +0300

    USB OTG: add support for ulpi connected external transceivers
    
    This adds support for OTG transceivers directly connected to the ULPI
    interface. In particular, the following details are added
    
    - a struct for low level io functions (read/write)
    - a priv field to be used as 'viewport' by low level access functions
    - an (*init) and (*shutdown) callbacks, along with static inline helpers
    - a (*set_vbus) callback to switch the port power on and off
    - a flags field for per-transceiver settings
    - some defines for the flags bitmask to configure platform specific
      details
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Cc: Heikki Krogerus <ext-heikki.krogerus@nokia.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 2443c0e7a80c..52bb917641f0 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -33,6 +33,23 @@ enum usb_otg_state {
 	OTG_STATE_A_VBUS_ERR,
 };
 
+#define USB_OTG_PULLUP_ID		(1 << 0)
+#define USB_OTG_PULLDOWN_DP		(1 << 1)
+#define USB_OTG_PULLDOWN_DM		(1 << 2)
+#define USB_OTG_EXT_VBUS_INDICATOR	(1 << 3)
+#define USB_OTG_DRV_VBUS		(1 << 4)
+#define USB_OTG_DRV_VBUS_EXT		(1 << 5)
+
+struct otg_transceiver;
+
+/* for transceivers connected thru an ULPI interface, the user must
+ * provide access ops
+ */
+struct otg_io_access_ops {
+	int (*read)(struct otg_transceiver *otg, u32 reg);
+	int (*write)(struct otg_transceiver *otg, u32 val, u32 reg);
+};
+
 /*
  * the otg driver needs to interact with both device side and host side
  * usb controllers.  it decides which controller is active at a given
@@ -42,6 +59,7 @@ enum usb_otg_state {
 struct otg_transceiver {
 	struct device		*dev;
 	const char		*label;
+	unsigned int		 flags;
 
 	u8			default_a;
 	enum usb_otg_state	state;
@@ -49,10 +67,17 @@ struct otg_transceiver {
 	struct usb_bus		*host;
 	struct usb_gadget	*gadget;
 
+	struct otg_io_access_ops	*io_ops;
+	void __iomem			*io_priv;
+
 	/* to pass extra port status to the root hub */
 	u16			port_status;
 	u16			port_change;
 
+	/* initialize/shutdown the OTG controller */
+	int	(*init)(struct otg_transceiver *otg);
+	void	(*shutdown)(struct otg_transceiver *otg);
+
 	/* bind/unbind the host controller */
 	int	(*set_host)(struct otg_transceiver *otg,
 				struct usb_bus *host);
@@ -65,6 +90,10 @@ struct otg_transceiver {
 	int	(*set_power)(struct otg_transceiver *otg,
 				unsigned mA);
 
+	/* effective for A-peripheral, ignored for B devices */
+	int	(*set_vbus)(struct otg_transceiver *otg,
+				bool enabled);
+
 	/* for non-OTG B devices: set transceiver into suspend mode */
 	int	(*set_suspend)(struct otg_transceiver *otg,
 				int suspend);
@@ -85,6 +114,38 @@ extern int otg_set_transceiver(struct otg_transceiver *);
 extern void usb_nop_xceiv_register(void);
 extern void usb_nop_xceiv_unregister(void);
 
+/* helpers for direct access thru low-level io interface */
+static inline int otg_io_read(struct otg_transceiver *otg, u32 reg)
+{
+	if (otg->io_ops && otg->io_ops->read)
+		return otg->io_ops->read(otg, reg);
+
+	return -EINVAL;
+}
+
+static inline int otg_io_write(struct otg_transceiver *otg, u32 reg, u32 val)
+{
+	if (otg->io_ops && otg->io_ops->write)
+		return otg->io_ops->write(otg, reg, val);
+
+	return -EINVAL;
+}
+
+static inline int
+otg_init(struct otg_transceiver *otg)
+{
+	if (otg->init)
+		return otg->init(otg);
+
+	return 0;
+}
+
+static inline void
+otg_shutdown(struct otg_transceiver *otg)
+{
+	if (otg->shutdown)
+		otg->shutdown(otg);
+}
 
 /* for usb host and peripheral controller drivers */
 extern struct otg_transceiver *otg_get_transceiver(void);
@@ -97,6 +158,12 @@ otg_start_hnp(struct otg_transceiver *otg)
 	return otg->start_hnp(otg);
 }
 
+/* Context: can sleep */
+static inline int
+otg_set_vbus(struct otg_transceiver *otg, bool enabled)
+{
+	return otg->set_vbus(otg, enabled);
+}
 
 /* for HCDs */
 static inline int
@@ -105,7 +172,6 @@ otg_set_host(struct otg_transceiver *otg, struct usb_bus *host)
 	return otg->set_host(otg, host);
 }
 
-
 /* for usb peripheral controller drivers */
 
 /* Context: can sleep */

commit cc835e321a9f3fa5e083436872e198095f4805b9
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Tue Mar 31 12:28:31 2009 -0700

    USB: nop-usb-xceiv: behave when linked as a module
    
    The NOP OTG transceiver driver needs to be usable from modules.
    Make sure its symbols are always accessible at both compile and
    link time, and make sure the device instance is allocated from
    the heap so that device lifetime rules are obeyed.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 1aaa826396a1..2443c0e7a80c 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -80,10 +80,10 @@ struct otg_transceiver {
 
 /* for board-specific init logic */
 extern int otg_set_transceiver(struct otg_transceiver *);
-#ifdef CONFIG_NOP_USB_XCEIV
+
+/* sometimes transceivers are accessed only through e.g. ULPI */
 extern void usb_nop_xceiv_register(void);
 extern void usb_nop_xceiv_unregister(void);
-#endif
 
 
 /* for usb host and peripheral controller drivers */

commit f6d92a05c86754d62eabc84856d2035d0de3ddc3
Author: Ajay Kumar Gupta <ajay.gupta@ti.com>
Date:   Fri Feb 6 17:32:35 2009 +0530

    USB: otg: adding nop usb transceiver
    
    NOP transceiver is used by all the usb transceiver which are mostly
    autonomous and doesn't require any programming or which are built
    into the usb ip itself.NOP transceiver only allocates the memory
    for struct xceiv and calls otg_set_transceiver() so function call
    to otg_get_transceiver() will return a valid transceiver.
    
    NOP transceiver device should be registered by calling
    usb_nop_xceiv_register() from platform files.
    
    Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
    Cc: Felipe Balbi <felipe.balbi@nokia.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 60a52576fd5c..1aaa826396a1 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -80,6 +80,10 @@ struct otg_transceiver {
 
 /* for board-specific init logic */
 extern int otg_set_transceiver(struct otg_transceiver *);
+#ifdef CONFIG_NOP_USB_XCEIV
+extern void usb_nop_xceiv_register(void);
+extern void usb_nop_xceiv_unregister(void);
+#endif
 
 
 /* for usb host and peripheral controller drivers */

commit c2344f13b59e007d782a3e591ebc551bc583a8b7
Author: Robert Jarzmik <robert.jarzmik@free.fr>
Date:   Sat Jan 24 23:54:31 2009 -0800

    USB: gpio_vbus: add delayed vbus_session calls
    
    Call usb_gadget_vbus_connect() and ...disconnect() from a
    workqueue rather than from an irq handler, allowing msleep()
    calls in vbus_session.  Update kerneldoc to match.
    
    [ dbrownell@users.sourceforge.net: more kerneldoc updates ]
    
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 94df4fe6c6c0..60a52576fd5c 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -86,6 +86,7 @@ extern int otg_set_transceiver(struct otg_transceiver *);
 extern struct otg_transceiver *otg_get_transceiver(void);
 extern void otg_put_transceiver(struct otg_transceiver *);
 
+/* Context: can sleep */
 static inline int
 otg_start_hnp(struct otg_transceiver *otg)
 {
@@ -102,6 +103,8 @@ otg_set_host(struct otg_transceiver *otg, struct usb_bus *host)
 
 
 /* for usb peripheral controller drivers */
+
+/* Context: can sleep */
 static inline int
 otg_set_peripheral(struct otg_transceiver *otg, struct usb_gadget *periph)
 {
@@ -114,6 +117,7 @@ otg_set_power(struct otg_transceiver *otg, unsigned mA)
 	return otg->set_power(otg, mA);
 }
 
+/* Context: can sleep */
 static inline int
 otg_set_suspend(struct otg_transceiver *otg, int suspend)
 {

commit 68144e0cc92125f41157ede7b060f83367bc4fe7
Author: Philipp Zabel <philipp.zabel@gmail.com>
Date:   Mon Nov 24 12:01:17 2008 -0800

    USB: otg: add otg_put_transceiver()
    
    As Russell King points out, calling put_device(otg_transceiver->dev)
    directly in driver cleanup paths makes assumptions about otg_transceiver
    internals.
    
    Signed-off-by: Philipp Zabel <philipp.zabel@gmail.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 1db25d152ad8..94df4fe6c6c0 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -84,6 +84,7 @@ extern int otg_set_transceiver(struct otg_transceiver *);
 
 /* for usb host and peripheral controller drivers */
 extern struct otg_transceiver *otg_get_transceiver(void);
+extern void otg_put_transceiver(struct otg_transceiver *);
 
 static inline int
 otg_start_hnp(struct otg_transceiver *otg)

commit dda43a0e03a33dd716fb34f812b1af614f74daff
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Fri Mar 7 13:45:32 2008 -0500

    USB: Standardize inclusion protection and add where missing.
    
    For the header files in include/linux/usb, add missing multiple
    inclusion protection and standardize what's already there.  The
    apparent standards:
    
      * macro name of __LINUX_USB_headerfile_H
      * inclusion protection placed after leading comment block
      * macro name added as a comment on the final #endif
      * any obvious trivial whitespace cleanup associated with the above
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index e007074ebe41..1db25d152ad8 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -1,11 +1,13 @@
 /* USB OTG (On The Go) defines */
-
 /*
+ *
  * These APIs may be used between USB controllers.  USB device drivers
  * (for either host or peripheral roles) don't use these calls; they
  * continue to use just usb_device and usb_gadget.
  */
 
+#ifndef __LINUX_USB_OTG_H
+#define __LINUX_USB_OTG_H
 
 /* OTG defines lots of enumeration states before device reset */
 enum usb_otg_state {
@@ -129,3 +131,5 @@ otg_start_srp(struct otg_transceiver *otg)
 
 /* for OTG controller drivers (and maybe other stuff) */
 extern int usb_bus_start_enum(struct usb_bus *bus, unsigned port_num);
+
+#endif /* __LINUX_USB_OTG_H */

commit 41dceed51f0e6105ca2bf45c3835a7cd9eaa077b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Jan 30 15:21:33 2008 -0800

    USB: fix codingstyle issues in include/linux/usb/
    
    Fixes a number of coding style issues in the USB public header files.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 9897f7a818c5..e007074ebe41 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -1,4 +1,4 @@
-// include/linux/usb/otg.h
+/* USB OTG (On The Go) defines */
 
 /*
  * These APIs may be used between USB controllers.  USB device drivers

commit 3a16f7b4a75d68364c3278523f51ac141a12758a
Author: David Brownell <david-b@pacbell.net>
Date:   Thu Jun 29 12:27:23 2006 -0700

    USB: move <linux/usb_otg.h> to <linux/usb/otg.h>
    
    Move <linux/usb_otg.h> to <linux/usb/otg.h>.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
new file mode 100644
index 000000000000..9897f7a818c5
--- /dev/null
+++ b/include/linux/usb/otg.h
@@ -0,0 +1,131 @@
+// include/linux/usb/otg.h
+
+/*
+ * These APIs may be used between USB controllers.  USB device drivers
+ * (for either host or peripheral roles) don't use these calls; they
+ * continue to use just usb_device and usb_gadget.
+ */
+
+
+/* OTG defines lots of enumeration states before device reset */
+enum usb_otg_state {
+	OTG_STATE_UNDEFINED = 0,
+
+	/* single-role peripheral, and dual-role default-b */
+	OTG_STATE_B_IDLE,
+	OTG_STATE_B_SRP_INIT,
+	OTG_STATE_B_PERIPHERAL,
+
+	/* extra dual-role default-b states */
+	OTG_STATE_B_WAIT_ACON,
+	OTG_STATE_B_HOST,
+
+	/* dual-role default-a */
+	OTG_STATE_A_IDLE,
+	OTG_STATE_A_WAIT_VRISE,
+	OTG_STATE_A_WAIT_BCON,
+	OTG_STATE_A_HOST,
+	OTG_STATE_A_SUSPEND,
+	OTG_STATE_A_PERIPHERAL,
+	OTG_STATE_A_WAIT_VFALL,
+	OTG_STATE_A_VBUS_ERR,
+};
+
+/*
+ * the otg driver needs to interact with both device side and host side
+ * usb controllers.  it decides which controller is active at a given
+ * moment, using the transceiver, ID signal, HNP and sometimes static
+ * configuration information (including "board isn't wired for otg").
+ */
+struct otg_transceiver {
+	struct device		*dev;
+	const char		*label;
+
+	u8			default_a;
+	enum usb_otg_state	state;
+
+	struct usb_bus		*host;
+	struct usb_gadget	*gadget;
+
+	/* to pass extra port status to the root hub */
+	u16			port_status;
+	u16			port_change;
+
+	/* bind/unbind the host controller */
+	int	(*set_host)(struct otg_transceiver *otg,
+				struct usb_bus *host);
+
+	/* bind/unbind the peripheral controller */
+	int	(*set_peripheral)(struct otg_transceiver *otg,
+				struct usb_gadget *gadget);
+
+	/* effective for B devices, ignored for A-peripheral */
+	int	(*set_power)(struct otg_transceiver *otg,
+				unsigned mA);
+
+	/* for non-OTG B devices: set transceiver into suspend mode */
+	int	(*set_suspend)(struct otg_transceiver *otg,
+				int suspend);
+
+	/* for B devices only:  start session with A-Host */
+	int	(*start_srp)(struct otg_transceiver *otg);
+
+	/* start or continue HNP role switch */
+	int	(*start_hnp)(struct otg_transceiver *otg);
+
+};
+
+
+/* for board-specific init logic */
+extern int otg_set_transceiver(struct otg_transceiver *);
+
+
+/* for usb host and peripheral controller drivers */
+extern struct otg_transceiver *otg_get_transceiver(void);
+
+static inline int
+otg_start_hnp(struct otg_transceiver *otg)
+{
+	return otg->start_hnp(otg);
+}
+
+
+/* for HCDs */
+static inline int
+otg_set_host(struct otg_transceiver *otg, struct usb_bus *host)
+{
+	return otg->set_host(otg, host);
+}
+
+
+/* for usb peripheral controller drivers */
+static inline int
+otg_set_peripheral(struct otg_transceiver *otg, struct usb_gadget *periph)
+{
+	return otg->set_peripheral(otg, periph);
+}
+
+static inline int
+otg_set_power(struct otg_transceiver *otg, unsigned mA)
+{
+	return otg->set_power(otg, mA);
+}
+
+static inline int
+otg_set_suspend(struct otg_transceiver *otg, int suspend)
+{
+	if (otg->set_suspend != NULL)
+		return otg->set_suspend(otg, suspend);
+	else
+		return 0;
+}
+
+static inline int
+otg_start_srp(struct otg_transceiver *otg)
+{
+	return otg->start_srp(otg);
+}
+
+
+/* for OTG controller drivers (and maybe other stuff) */
+extern int usb_bus_start_enum(struct usb_bus *bus, unsigned port_num);
