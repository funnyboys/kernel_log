commit ff4c65ca48f08f4781accfb1d224acd7c897070e
Author: Vinod Koul <vkoul@kernel.org>
Date:   Thu May 14 17:50:36 2020 +0530

    usb: hci: add hc_driver as argument for usb_hcd_pci_probe
    
    usb_hcd_pci_probe expects users to call this with driver_data set as
    hc_driver, that limits the possibility of using the driver_data for
    driver data.
    
    Add hc_driver as argument to usb_hcd_pci_probe and modify the callers
    ehci/ohci/xhci/uhci to pass hc_driver as argument and freeup the
    driver_data used
    
    Tested xhci driver on Dragon-board RB3, compile tested ehci, ohci and
    uhci.
    
    [For all but the xHCI parts]
    [For the xhci part]
    
    Suggested-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Link: https://lore.kernel.org/r/20200514122039.300417-2-vkoul@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index e12105ed3834..3dbb42c637c1 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -479,7 +479,8 @@ extern void usb_hcd_platform_shutdown(struct platform_device *dev);
 struct pci_dev;
 struct pci_device_id;
 extern int usb_hcd_pci_probe(struct pci_dev *dev,
-				const struct pci_device_id *id);
+			     const struct pci_device_id *id,
+			     const struct hc_driver *driver);
 extern void usb_hcd_pci_remove(struct pci_dev *dev);
 extern void usb_hcd_pci_shutdown(struct pci_dev *dev);
 

commit 6bc3f3979edce0b11deb685a4c817abb7d74b227
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Feb 20 07:20:17 2020 -0600

    USB: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Link: https://lore.kernel.org/r/20200220132017.GA29262@embeddedor
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 712b2a603645..e12105ed3834 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -228,7 +228,7 @@ struct usb_hcd {
 	/* The HC driver's private data is stored at the end of
 	 * this structure.
 	 */
-	unsigned long hcd_priv[0]
+	unsigned long hcd_priv[]
 			__attribute__ ((aligned(sizeof(s64))));
 };
 

commit 96e46dcfb8534494859936b3da4f3018de53a53f
Merge: b2fcb285ade3 18a93cd38be3
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Sep 2 19:20:57 2019 +0200

    Merge tag 'usb-for-v5.4' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    Felipe writes:
    
    USB: Changes for v5.4 merge window
    
    With only 45 non-merge commits, we have a small merge window from the
    Gadget perspective.
    
    The biggest change here is the addition of the Cadence USB3 DRD
    Driver. All other changes are small, non-critical fixes or smaller new
    features like the improvement to BESL handling in dwc3.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    
    * tag 'usb-for-v5.4' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb: (45 commits)
      usb: gadget: net2280: Add workaround for AB chip Errata 11
      usb: gadget: net2280: Move all "ll" registers in one structure
      usb: dwc3: gadget: Workaround Mirosoft's BESL check
      usb:cdns3 Fix for stuck packets in on-chip OUT buffer.
      usb: cdns3: Add Cadence USB3 DRD Driver
      usb: common: Simplify usb_decode_get_set_descriptor function.
      usb: common: Patch simplify usb_decode_set_clear_feature function.
      usb: common: Separated decoding functions from dwc3 driver.
      dt-bindings: add binding for USBSS-DRD controller.
      usb: gadget: composite: Set recommended BESL values
      usb: dwc3: gadget: Set BESL config parameter
      usb: dwc3: Separate field holding multiple properties
      usb: gadget: Export recommended BESL values
      usb: phy: phy-fsl-usb: Make structure fsl_otg_initdata constant
      usb: udc: lpc32xx: silence fall-through warning
      usb: dwc3: meson-g12a: fix suspend resume regulator unbalanced disables
      usb: udc: lpc32xx: remove set but not used 3 variables
      usb: gadget: udc: core: Fix segfault if udc_bind_to_driver() for pending driver fails
      usb: dwc3: st: Add of_dev_put() in probe function
      usb: dwc3: st: Add of_node_put() before return in probe function
      ...

commit 7b81cb6bddd2c4f2489506771070924bd0ae9902
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Aug 16 08:24:32 2019 +0200

    usb: add a HCD_DMA flag instead of guestimating DMA capabilities
    
    The usb core is the only major place in the kernel that checks for
    a non-NULL device dma_mask to see if a device is DMA capable.  This
    is generally a bad idea, as all major busses always set up a DMA mask,
    even if the device is not DMA capable - in fact bus layers like PCI
    can't even know if a device is DMA capable at enumeration time.  This
    leads to lots of workaround in HCD drivers, and also prevented us from
    setting up a DMA mask for platform devices by default last time we
    tried.
    
    Replace this guess with an explicit HCD_DMA that is set by drivers that
    appear to have DMA support.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Link: https://lore.kernel.org/r/20190816062435.881-4-hch@lst.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index a20e7815d814..8d3869c7de85 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -256,6 +256,7 @@ struct hc_driver {
 
 	int	flags;
 #define	HCD_MEMORY	0x0001		/* HC regs use memory (else I/O) */
+#define	HCD_DMA		0x0002		/* HC uses DMA */
 #define	HCD_SHARED	0x0004		/* Two (or more) usb_hcds share HW */
 #define	HCD_USB11	0x0010		/* USB 1.1 */
 #define	HCD_USB2	0x0020		/* USB 2.0 */
@@ -422,8 +423,10 @@ static inline bool hcd_periodic_completion_in_progress(struct usb_hcd *hcd,
 	return hcd->high_prio_bh.completing_ep == ep;
 }
 
-#define hcd_uses_dma(hcd) \
-	(IS_ENABLED(CONFIG_HAS_DMA) && (hcd)->self.uses_dma)
+static inline bool hcd_uses_dma(struct usb_hcd *hcd)
+{
+	return IS_ENABLED(CONFIG_HAS_DMA) && (hcd->driver->flags & HCD_DMA);
+}
 
 extern int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb);
 extern int usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,

commit edfbcb321faf07ca970e4191abe061deeb7d3788
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Aug 11 10:05:16 2019 +0200

    usb: add a hcd_uses_dma helper
    
    The USB buffer allocation code is the only place in the usb core (and in
    fact the whole kernel) that uses is_device_dma_capable, while the URB
    mapping code uses the uses_dma flag in struct usb_bus.  Switch the buffer
    allocation to use the uses_dma flag used by the rest of the USB code,
    and create a helper in hcd.h that checks this flag as well as the
    CONFIG_HAS_DMA to simplify the caller a bit.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Link: https://lore.kernel.org/r/20190811080520.21712-3-hch@lst.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index bab27ccc8ff5..a20e7815d814 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -422,6 +422,9 @@ static inline bool hcd_periodic_completion_in_progress(struct usb_hcd *hcd,
 	return hcd->high_prio_bh.completing_ep == ep;
 }
 
+#define hcd_uses_dma(hcd) \
+	(IS_ENABLED(CONFIG_HAS_DMA) && (hcd)->self.uses_dma)
+
 extern int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb);
 extern int usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,
 		int status);

commit 22a5d3ce0d032d843e36d431e78e6a7dd0efa193
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Jul 26 15:05:38 2019 +1000

    usb: Add definitions for the USB2.0 hub TT requests
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index bab27ccc8ff5..367f9b39ac56 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -591,6 +591,10 @@ extern void usb_ep0_reinit(struct usb_device *);
 #define GetPortStatus		HUB_CLASS_REQ(USB_DIR_IN, USB_RT_PORT, USB_REQ_GET_STATUS)
 #define SetHubFeature		HUB_CLASS_REQ(USB_DIR_OUT, USB_RT_HUB, USB_REQ_SET_FEATURE)
 #define SetPortFeature		HUB_CLASS_REQ(USB_DIR_OUT, USB_RT_PORT, USB_REQ_SET_FEATURE)
+#define ClearTTBuffer		HUB_CLASS_REQ(USB_DIR_OUT, USB_RT_PORT, HUB_CLEAR_TT_BUFFER)
+#define ResetTT			HUB_CLASS_REQ(USB_DIR_OUT, USB_RT_PORT, HUB_RESET_TT)
+#define GetTTState		HUB_CLASS_REQ(USB_DIR_IN, USB_RT_PORT, HUB_GET_TT_STATE)
+#define StopTT			HUB_CLASS_REQ(USB_DIR_OUT, USB_RT_PORT, HUB_STOP_TT)
 
 
 /*-------------------------------------------------------------------------*/

commit 2d7a3dc3e24f43504b1f25eae8195e600f4cce8b
Author: Laurentiu Tudor <laurentiu.tudor@nxp.com>
Date:   Wed May 29 13:28:43 2019 +0300

    USB: drop HCD_LOCAL_MEM flag
    
    With the addition of the local memory allocator, the HCD_LOCAL_MEM
    flag can be dropped and the checks against it replaced with a check
    for the localmem_pool ptr being initialized.
    
    Signed-off-by: Laurentiu Tudor <laurentiu.tudor@nxp.com>
    Tested-by: Fredrik Noring <noring@nocrew.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 127560a4bfa0..bab27ccc8ff5 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -256,7 +256,6 @@ struct hc_driver {
 
 	int	flags;
 #define	HCD_MEMORY	0x0001		/* HC regs use memory (else I/O) */
-#define	HCD_LOCAL_MEM	0x0002		/* HC needs local memory */
 #define	HCD_SHARED	0x0004		/* Two (or more) usb_hcds share HW */
 #define	HCD_USB11	0x0010		/* USB 1.1 */
 #define	HCD_USB2	0x0020		/* USB 2.0 */

commit b0310c2f09bbe8aebefb97ed67949a3a7092aca6
Author: Laurentiu Tudor <laurentiu.tudor@nxp.com>
Date:   Wed May 29 13:28:40 2019 +0300

    USB: use genalloc for USB HCs with local memory
    
    For HCs that have local memory, replace the current DMA API usage with
    a genalloc generic allocator to manage the mappings for these devices.
    To help users, introduce a new HCD API, usb_hcd_setup_local_mem() that
    will setup up the genalloc backing up the device local memory. It will
    be used in subsequent patches.  This is in preparation for dropping
    the existing "coherent" dma mem declaration APIs.  The current
    implementation was relying on a short circuit in the DMA API that in
    the end, was acting as an allocator for these type of devices.
    
    Signed-off-by: Laurentiu Tudor <laurentiu.tudor@nxp.com>
    Tested-by: Fredrik Noring <noring@nocrew.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index bb57b5af4700..127560a4bfa0 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -216,6 +216,9 @@ struct usb_hcd {
 #define	HC_IS_RUNNING(state) ((state) & __ACTIVE)
 #define	HC_IS_SUSPENDED(state) ((state) & __SUSPEND)
 
+	/* memory pool for HCs having local memory, or %NULL */
+	struct gen_pool         *localmem_pool;
+
 	/* more shared queuing code would be good; it should support
 	 * smarter scheduling, handle transaction translators, etc;
 	 * input size of periodic table to an interrupt scheduler.
@@ -461,6 +464,8 @@ extern int usb_add_hcd(struct usb_hcd *hcd,
 		unsigned int irqnum, unsigned long irqflags);
 extern void usb_remove_hcd(struct usb_hcd *hcd);
 extern int usb_hcd_find_raw_port_number(struct usb_hcd *hcd, int port1);
+int usb_hcd_setup_local_mem(struct usb_hcd *hcd, phys_addr_t phys_addr,
+			    dma_addr_t dma, size_t size);
 
 struct platform_device;
 extern void usb_hcd_platform_shutdown(struct platform_device *dev);

commit 3515468a87a47781f6af818773650513ff14656a
Merge: 12456e509be2 2e487d280525
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri May 3 18:05:27 2019 +0200

    Merge tag 'usb-for-v5.2' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    Felipe writes:
    
    USB: changes for v5.2 merge window
    
    With a total of 50 non-merge commits, this is not a large pull
    request. Most of the changes are, again, in dwc2 (37%) and dwc3 (32%)
    with the rest of it scattered among other UDCs, function drivers and
    device-tree bindings.
    
    No really big feature this time around apart from support to Amlogic
    being added to both dwc3 and dwc2 drivers.
    
    * tag 'usb-for-v5.2' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb: (50 commits)
      usb: dwc3: Rename DWC3_DCTL_LPM_ERRATA
      usb: dwc3: Fix default lpm_nyet_threshold value
      usb: dwc3: debug: Print GET_STATUS(device) tracepoint
      usb: dwc3: Do core validation early on probe
      usb: dwc3: gadget: Set lpm_capable
      usb: gadget: atmel: tie wake lock to running clock
      usb: gadget: atmel: support USB suspend
      usb: gadget: atmel_usba_udc: simplify setting of interrupt-enabled mask
      dwc2: gadget: Fix completed transfer size calculation in DDMA
      usb: dwc2: Set lpm mode parameters depend on HW configuration
      usb: dwc2: Fix channel disable flow
      usb: dwc2: Set actual frame number for completed ISOC transfer
      usb: gadget: do not use __constant_cpu_to_le16
      usb: dwc2: gadget: Increase descriptors count for ISOC's
      usb: introduce usb_ep_type_string() function
      usb: dwc3: move synchronize_irq() out of the spinlock protected block
      usb: dwc3: Free resource immediately after use
      usb: dwc3: of-simple: Convert to bulk clk API
      usb: dwc2: Delayed status support
      usb: gadget: udc: lpc32xx: rework interrupt handling
      ...

commit 7a6127e39a16c97b505f13352238567fdc3f79a2
Author: Douglas Anderson <dianders@chromium.org>
Date:   Wed Apr 17 17:13:53 2019 -0700

    USB: Export usb_wakeup_enabled_descendants()
    
    In (e583d9d USB: global suspend and remote wakeup don't mix) we
    introduced wakeup_enabled_descendants() as a static function.  We'd
    like to use this function in USB controller drivers to know if we
    should keep the controller on during suspend time, since doing so has
    a power impact.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 695931b03684..ed4fbbd1b35f 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -652,11 +652,16 @@ extern wait_queue_head_t usb_kill_urb_queue;
 #define usb_endpoint_out(ep_dir)	(!((ep_dir) & USB_DIR_IN))
 
 #ifdef CONFIG_PM
+extern unsigned usb_wakeup_enabled_descendants(struct usb_device *udev);
 extern void usb_root_hub_lost_power(struct usb_device *rhdev);
 extern int hcd_bus_suspend(struct usb_device *rhdev, pm_message_t msg);
 extern int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg);
 extern void usb_hcd_resume_root_hub(struct usb_hcd *hcd);
 #else
+static inline unsigned usb_wakeup_enabled_descendants(struct usb_device *udev)
+{
+	return 0;
+}
 static inline void usb_hcd_resume_root_hub(struct usb_hcd *hcd)
 {
 	return;

commit a4d6a2989dc3f2f2bcd25ca53dd187a1de68ffac
Author: Raul E Rangel <rrangel@chromium.org>
Date:   Fri Apr 19 09:30:22 2019 -0600

    usb/hcd: Send a uevent signaling that the host controller had died
    
    This change will send an OFFLINE event to udev with the ERROR=DEAD
    environment variable set when the HC dies.
    
    By notifying user space the appropriate policies can be applied.
    i.e.,
     * Collect error logs.
     * Notify the user that USB is no longer functional.
     * Perform a graceful reboot.
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Raul E Rangel <rrangel@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 695931b03684..66a24b13e2ab 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -98,6 +98,7 @@ struct usb_hcd {
 #ifdef CONFIG_PM
 	struct work_struct	wakeup_work;	/* for remote wakeup */
 #endif
+	struct work_struct	died_work;	/* for when the device dies */
 
 	/*
 	 * hardware info/state

commit 7bae0432a64aa7569dbd0feb2927fd3ff913901f
Author: Dmitry Torokhov <dtor@chromium.org>
Date:   Sat Feb 16 23:21:51 2019 -0800

    usb: core: add option of only authorizing internal devices
    
    On Chrome OS we want to use USBguard to potentially limit access to USB
    devices based on policy. We however to do not want to wait for userspace to
    come up before initializing fixed USB devices to not regress our boot
    times.
    
    This patch adds option to instruct the kernel to only authorize devices
    connected to the internal ports. Previously we could either authorize
    all or none (or, by default, we'd only authorize wired devices).
    
    The behavior is controlled via usbcore.authorized_default command line
    option.
    
    Signed-off-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 7dc3a411bece..695931b03684 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -72,6 +72,12 @@ struct giveback_urb_bh {
 	struct usb_host_endpoint *completing_ep;
 };
 
+enum usb_dev_authorize_policy {
+	USB_DEVICE_AUTHORIZE_NONE	= 0,
+	USB_DEVICE_AUTHORIZE_ALL	= 1,
+	USB_DEVICE_AUTHORIZE_INTERNAL	= 2,
+};
+
 struct usb_hcd {
 
 	/*
@@ -117,7 +123,6 @@ struct usb_hcd {
 #define HCD_FLAG_RH_RUNNING		5	/* root hub is running? */
 #define HCD_FLAG_DEAD			6	/* controller has died? */
 #define HCD_FLAG_INTF_AUTHORIZED	7	/* authorize interfaces? */
-#define HCD_FLAG_DEV_AUTHORIZED		8	/* authorize devices? */
 
 	/* The flags can be tested using these macros; they are likely to
 	 * be slightly faster than test_bit().
@@ -142,8 +147,7 @@ struct usb_hcd {
 	 * or they require explicit user space authorization; this bit is
 	 * settable through /sys/class/usb_host/X/authorized_default
 	 */
-#define HCD_DEV_AUTHORIZED(hcd) \
-	((hcd)->flags & (1U << HCD_FLAG_DEV_AUTHORIZED))
+	enum usb_dev_authorize_policy dev_policy;
 
 	/* Flags that get set only during HCD registration or removal. */
 	unsigned		rh_registered:1;/* is root hub registered? */

commit 4c96499c39e31b5a12f37c2396a5f81d1b6be1ab
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Nov 9 19:39:03 2018 +0100

    USB: remove the unused struct hcd_timeout definition
    
    No users of this type anywhere in the tree.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 97e2ddec18b1..7dc3a411bece 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -235,11 +235,6 @@ static inline struct usb_hcd *bus_to_hcd(struct usb_bus *bus)
 	return container_of(bus, struct usb_hcd, self);
 }
 
-struct hcd_timeout {	/* timeouts we allocate */
-	struct list_head	timeout_list;
-	struct timer_list	timer;
-};
-
 /*-------------------------------------------------------------------------*/
 
 

commit 379cacc5e566f7197bdeb1ea3e99219d3e880c0a
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jun 8 16:59:37 2018 -0400

    USB: Report wakeup events on root-hub ports
    
    When a USB device attached to a root-hub port sends a wakeup request
    to a sleeping system, we do not report the wakeup event to the PM
    core.  This is because a system resume involves waking up all
    suspended USB ports as quickly as possible; without the normal
    USB_RESUME_TIMEOUT delay, the host controller driver doesn't set the
    USB_PORT_STAT_C_SUSPEND flag and so usb_port_resume() doesn't realize
    that a wakeup request was received.
    
    However, some environments (such as Chrome OS) want to have all wakeup
    events reported so they can be ascribed to the appropriate device.  To
    accommodate these environments, this patch adds a new routine to the
    hub driver and a corresponding new HCD method to be used when a root
    hub resumes.  The HCD method returns a bitmap of ports that have
    initiated a wakeup signal but not yet completed resuming.  The hub
    driver can then report to the PM core that the child devices attached
    to these ports initiated a wakeup event.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Suggested-by: Anshuman Gupta <anshuman.gupta@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 34a6ded6f319..97e2ddec18b1 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -322,6 +322,7 @@ struct hc_driver {
 	int	(*bus_suspend)(struct usb_hcd *);
 	int	(*bus_resume)(struct usb_hcd *);
 	int	(*start_port_reset)(struct usb_hcd *, unsigned port_num);
+	unsigned long	(*get_resuming_ports)(struct usb_hcd *);
 
 		/* force handover of high-speed port to full-speed companion */
 	void	(*relinquish_port)(struct usb_hcd *, int);

commit ffe95371d2a84f3ad8085656d4fcb2fc926ff7a1
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Apr 19 19:05:50 2018 +0300

    usb: define HCD_USB32 speed option for hosts that support USB 3.2 dual-lane
    
    Hosts that support USB 3.2 Enhaned SuperSpeed can set their hcd speed
    to HCD_USB32 to let usb core and host drivers know that the controller
    supports new USB 3.2 dual-lane features.
    
    make sure usb core handle HCD_USB32 hosts correctly, for now similar
    to HCD_USB32.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index e33009c77840..34a6ded6f319 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -260,6 +260,7 @@ struct hc_driver {
 #define	HCD_USB25	0x0030		/* Wireless USB 1.0 (USB 2.5)*/
 #define	HCD_USB3	0x0040		/* USB 3.0 */
 #define	HCD_USB31	0x0050		/* USB 3.1 */
+#define	HCD_USB32	0x0060		/* USB 3.2 */
 #define	HCD_MASK	0x0070
 #define	HCD_BH		0x0100		/* URB complete in BH context */
 

commit bc40f53417410be18298c5b5dbf5bcae9588d84f
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Apr 18 11:26:20 2018 +0200

    USB: core: hcd: drop support for legacy phys
    
    Drop support for looking up and initialising legacy phys in USB core,
    something which hasn't been used by a mainline kernel since commit
    9080b8dc761a ("ARM: OMAP2+: Remove legacy usb-host.c platform init
    code"). Specifically, since that commit usb_get_phy_dev() have always
    returned -ENODEV and consequently this code has not been used.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index aef50cb2ed1b..e33009c77840 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -150,7 +150,6 @@ struct usb_hcd {
 	unsigned		rh_pollable:1;	/* may we poll the root hub? */
 	unsigned		msix_enabled:1;	/* driver has MSI-X enabled? */
 	unsigned		msi_enabled:1;	/* driver has MSI enabled? */
-	unsigned		remove_phy:1;	/* auto-remove USB phy */
 	/*
 	 * do not manage the PHY state in the HCD core, instead let the driver
 	 * handle this (for example if the PHY can only be turned on after a

commit ad70f937e9d0bdc580e390db3a047f9e58863b6e
Author: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
Date:   Sat Mar 3 22:43:09 2018 +0100

    usb: core: hcd: remove support for initializing a single PHY
    
    With the new PHY wrapper in place we can now handle multiple PHYs.
    Remove the code which handles only one generic PHY as this is now
    covered (with support for multiple PHYs as well as suspend/resume
    support) by the new PHY wrapper.
    
    Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Tested-by: Neil Armstrong <narmstrong@baylibre.con>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index a042675e03ba..aef50cb2ed1b 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -103,7 +103,6 @@ struct usb_hcd {
 	 * other external phys should be software-transparent
 	 */
 	struct usb_phy		*usb_phy;
-	struct phy		*phy;
 	struct usb_phy_roothub	*phy_roothub;
 
 	/* Flags that need to be manipulated atomically because they can

commit 178a0bce05cbc17a27f9cba78258c5d12adc980c
Author: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
Date:   Sat Mar 3 22:43:05 2018 +0100

    usb: core: hcd: integrate the PHY wrapper into the HCD core
    
    This integrates the PHY wrapper into the core hcd infrastructure.
    Multiple PHYs which are part of the HCD's device tree node are now
    managed (= powered on/off when needed), by the new usb_phy_roothub code.
    
    Suspend and resume is also supported, however not for
    runtime/auto-suspend (which is triggered for example when no devices are
    connected to the USB bus). This is needed on some SoCs (for example
    Amlogic Meson GXL) because if the PHYs are disabled during auto-suspend
    then devices which are plugged in afterwards are not seen by the host.
    
    One example where this is required is the Amlogic GXL and GXM SoCs:
    They are using a dwc3 USB controller with up to three ports enabled on
    the internal roothub. Each port has it's own PHY which must be enabled
    (if one of the PHYs is left disabled then none of the USB ports works at
    all).
    The new logic works on the Amlogic GXL and GXM SoCs because the dwc3
    driver internally creates a xhci-hcd which then registers a HCD which
    then triggers our new PHY wrapper.
    
    USB controller drivers can opt out of this by setting
    "skip_phy_initialization" in struct usb_hcd to true. This is identical
    to how it works for a single USB PHY, so the "multiple PHY" handling is
    disabled for drivers that opted out of the management logic of a single
    PHY.
    
    Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Chunfeng Yun <chunfeng.yun@mediatek.com>
    Tested-by: Yixun Lan <yixun.lan@amlogic.com>
    Tested-by: Neil Armstrong <narmstrong@baylibre.con>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 693502c84c04..a042675e03ba 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -104,6 +104,7 @@ struct usb_hcd {
 	 */
 	struct usb_phy		*usb_phy;
 	struct phy		*phy;
+	struct usb_phy_roothub	*phy_roothub;
 
 	/* Flags that need to be manipulated atomically because they can
 	 * change while the host controller is running.  Always use

commit 4e88d4c083016454f179686529ae65d70b933b58
Author: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
Date:   Sat Mar 3 22:43:03 2018 +0100

    usb: add a flag to skip PHY initialization to struct usb_hcd
    
    The USB HCD core driver parses the device-tree node for "phys" and
    "usb-phys" properties. It also manages the power state of these PHYs
    automatically.
    However, drivers may opt-out of this behavior by setting "phy" or
    "usb_phy" in struct usb_hcd to a non-null value. An example where this
    is required is the "Qualcomm USB2 controller", implemented by the
    chipidea driver. The hardware requires that the PHY is only powered on
    after the "reset completed" event from the controller is received.
    
    A follow-up patch will allow the USB HCD core driver to manage more than
    one PHY. Add a new "skip_phy_initialization" bitflag to struct usb_hcd
    so drivers can opt-out of any PHY management provided by the USB HCD
    core driver.
    
    This also updates the existing drivers so they use the new flag if they
    want to opt out of the PHY management provided by the USB HCD core
    driver. This means that for these drivers the new "multiple PHY"
    handling (which will be added in a follow-up patch) will be disabled as
    well.
    
    Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Acked-by: Peter Chen <peter.chen@nxp.com>
    Tested-by: Neil Armstrong <narmstrong@baylibre.con>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 176900528822..693502c84c04 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -151,6 +151,12 @@ struct usb_hcd {
 	unsigned		msix_enabled:1;	/* driver has MSI-X enabled? */
 	unsigned		msi_enabled:1;	/* driver has MSI enabled? */
 	unsigned		remove_phy:1;	/* auto-remove USB phy */
+	/*
+	 * do not manage the PHY state in the HCD core, instead let the driver
+	 * handle this (for example if the PHY can only be turned on after a
+	 * specific event)
+	 */
+	unsigned		skip_phy_initialization:1;
 
 	/* The next flag is a stopgap, to be removed when all the HCDs
 	 * support the new root-hub polling mechanism. */

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index a1f03ebfde47..176900528822 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright (c) 2001-2002 by David Brownell
  *

commit 7cf916bd639bd26db7214f2205bccdb4b9306256
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jun 13 16:01:13 2017 +1000

    usb: Fix typo in the definition of Endpoint[out]Request
    
    The current definition is wrong. This breaks my upcoming
    Aspeed virtual hub driver.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 50398b69ca44..a1f03ebfde47 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -565,9 +565,9 @@ extern void usb_ep0_reinit(struct usb_device *);
 	((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_INTERFACE)<<8)
 
 #define EndpointRequest \
-	((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_INTERFACE)<<8)
+	((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_ENDPOINT)<<8)
 #define EndpointOutRequest \
-	((USB_DIR_OUT|USB_TYPE_STANDARD|USB_RECIP_INTERFACE)<<8)
+	((USB_DIR_OUT|USB_TYPE_STANDARD|USB_RECIP_ENDPOINT)<<8)
 
 /* class requests from the USB 2.0 hub spec, table 11-15 */
 #define HUB_CLASS_REQ(dir, type, request) ((((dir) | (type)) << 8) | (request))

commit 6a29beef9d1b16c762e469d77e28c3de3f5c3dbb
Author: Peter Chen <peter.chen@nxp.com>
Date:   Wed May 17 18:32:02 2017 +0300

    usb: host: xhci-ring: don't need to clear interrupt pending for MSI enabled hcd
    
    According to xHCI spec Figure 30: Interrupt Throttle Flow Diagram
    
            If PCI Message Signaled Interrupts (MSI or MSI-X) are enabled,
            then the assertion of the Interrupt Pending (IP) flag in Figure 30
            generates a PCI Dword write. The IP flag is automatically cleared
            by the completion of the PCI write.
    
    the MSI enabled HCs don't need to clear interrupt pending bit, but
    hcd->irq = 0 doesn't equal to MSI enabled HCD. At some Dual-role
    controller software designs, it sets hcd->irq as 0 to avoid HCD
    requesting interrupt, and they want to decide when to call usb_hcd_irq
    by software.
    
    Signed-off-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index a469999a106d..50398b69ca44 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -148,6 +148,7 @@ struct usb_hcd {
 	unsigned		rh_registered:1;/* is root hub registered? */
 	unsigned		rh_pollable:1;	/* may we poll the root hub? */
 	unsigned		msix_enabled:1;	/* driver has MSI-X enabled? */
+	unsigned		msi_enabled:1;	/* driver has MSI enabled? */
 	unsigned		remove_phy:1;	/* auto-remove USB phy */
 
 	/* The next flag is a stopgap, to be removed when all the HCDs

commit a8c06e407ef969461b7f51ec72839fe382dd3c29
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Mar 13 10:18:41 2017 +0800

    usb: separate out sysdev pointer from usb_bus
    
    For xhci-hcd platform device, all the DMA parameters are not
    configured properly, notably dma ops for dwc3 devices.
    
    The idea here is that you pass in the parent of_node along with
    the child device pointer, so it would behave exactly like the
    parent already does. The difference is that it also handles all
    the other attributes besides the mask.
    
    sysdev will represent the physical device, as seen from firmware
    or bus.Splitting the usb_bus->controller field into the
    Linux-internal device (used for the sysfs hierarchy, for printks
    and for power management) and a new pointer (used for DMA,
    DT enumeration and phy lookup) probably covers all that we really
    need.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Sriram Dash <sriram.dash@nxp.com>
    Tested-by: Baolin Wang <baolin.wang@linaro.org>
    Tested-by: Brian Norris <briannorris@chromium.org>
    Tested-by: Alexander Sverdlin <alexander.sverdlin@nokia.com>
    Tested-by: Vivek Gautam <vivek.gautam@codeaurora.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>
    Cc: Felipe Balbi <felipe.balbi@linux.intel.com>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Sinjan Kumar <sinjank@codeaurora.org>
    Cc: David Fisher <david.fisher1@synopsys.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: "Thang Q. Nguyen" <tqnguyen@apm.com>
    Cc: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: Ming Lei <tom.leiming@gmail.com>
    Cc: Jon Masters <jcm@redhat.com>
    Cc: Dann Frazier <dann.frazier@canonical.com>
    Cc: Peter Chen <peter.chen@nxp.com>
    Cc: Leo Li <pku.leo@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index dff130151235..a469999a106d 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -437,6 +437,9 @@ extern int usb_hcd_alloc_bandwidth(struct usb_device *udev,
 		struct usb_host_interface *new_alt);
 extern int usb_hcd_get_frame_number(struct usb_device *udev);
 
+struct usb_hcd *__usb_create_hcd(const struct hc_driver *driver,
+		struct device *sysdev, struct device *dev, const char *bus_name,
+		struct usb_hcd *primary_hcd);
 extern struct usb_hcd *usb_create_hcd(const struct hc_driver *driver,
 		struct device *dev, const char *bus_name);
 extern struct usb_hcd *usb_create_shared_hcd(const struct hc_driver *driver,

commit 2c93e790e8253552227bf9b46a8d49dca3f71b06
Author: yuan linyu <Linyu.Yuan@alcatel-sbell.com.cn>
Date:   Sat Feb 25 19:20:55 2017 +0800

    usb: add CONFIG_USB_PCI for system have both PCI HW and non-PCI based USB HW
    
    a lot of embeded system SOC (e.g. freescale T2080) have both
    PCI and USB modules. But USB module is controlled by registers directly,
    it have no relationship with PCI module.
    
    when say N here it will not build PCI related code in USB driver.
    
    Signed-off-by: yuan linyu <Linyu.Yuan@alcatel-sbell.com.cn>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 40edf6a8533e..dff130151235 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -453,7 +453,7 @@ extern int usb_hcd_find_raw_port_number(struct usb_hcd *hcd, int port1);
 struct platform_device;
 extern void usb_hcd_platform_shutdown(struct platform_device *dev);
 
-#ifdef CONFIG_PCI
+#ifdef CONFIG_USB_PCI
 struct pci_dev;
 struct pci_device_id;
 extern int usb_hcd_pci_probe(struct pci_dev *dev,
@@ -466,7 +466,7 @@ extern int usb_hcd_amd_remote_wakeup_quirk(struct pci_dev *dev);
 #ifdef CONFIG_PM
 extern const struct dev_pm_ops usb_hcd_pci_pm_ops;
 #endif
-#endif /* CONFIG_PCI */
+#endif /* CONFIG_USB_PCI */
 
 /* pci-ish (pdev null is ok) buffer alloc/mapping support */
 void usb_init_pool_max(void);

commit b9c2a2a39898d55b9fe13aa1fe15891e37bc9087
Author: Tal Shorer <tal.shorer@gmail.com>
Date:   Fri Nov 18 14:17:26 2016 +0200

    usb: hcd.h: construct hub class request constants from simpler constants
    
    Currently, each hub class request constant is defined by a line like:
    #define ClearHubFeature         (0x2000 | USB_REQ_CLEAR_FEATURE)
    
    The "magic" number for the high byte is one of 0x20, 0xa0, 0x23, 0xa3.
    The 0x80 bit that changes inditace USB_DIR_IN, and the 0x03 that
    pops up is the difference between USB_RECIP_DEVICE (0x00) and
    USB_RECIP_OTHER (0x03). The constant 0x20 bit is USB_TYPE_CLASS.
    
    This patch eliminates those magic numbers by defining a macro to help
    construct these hub class request from simpler constants.
    Note that USB_RT_HUB is defined as (USB_TYPE_CLASS | USB_RECIP_DEVICE)
    and that USB_RT_PORT is defined as (USB_TYPE_CLASS | USB_RECIP_OTHER).
    
    Signed-off-by: Tal Shorer <tal.shorer@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 66fc13705ab7..40edf6a8533e 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -566,21 +566,22 @@ extern void usb_ep0_reinit(struct usb_device *);
 	((USB_DIR_OUT|USB_TYPE_STANDARD|USB_RECIP_INTERFACE)<<8)
 
 /* class requests from the USB 2.0 hub spec, table 11-15 */
+#define HUB_CLASS_REQ(dir, type, request) ((((dir) | (type)) << 8) | (request))
 /* GetBusState and SetHubDescriptor are optional, omitted */
-#define ClearHubFeature		(0x2000 | USB_REQ_CLEAR_FEATURE)
-#define ClearPortFeature	(0x2300 | USB_REQ_CLEAR_FEATURE)
-#define GetHubDescriptor	(0xa000 | USB_REQ_GET_DESCRIPTOR)
-#define GetHubStatus		(0xa000 | USB_REQ_GET_STATUS)
-#define GetPortStatus		(0xa300 | USB_REQ_GET_STATUS)
-#define SetHubFeature		(0x2000 | USB_REQ_SET_FEATURE)
-#define SetPortFeature		(0x2300 | USB_REQ_SET_FEATURE)
+#define ClearHubFeature		HUB_CLASS_REQ(USB_DIR_OUT, USB_RT_HUB, USB_REQ_CLEAR_FEATURE)
+#define ClearPortFeature	HUB_CLASS_REQ(USB_DIR_OUT, USB_RT_PORT, USB_REQ_CLEAR_FEATURE)
+#define GetHubDescriptor	HUB_CLASS_REQ(USB_DIR_IN, USB_RT_HUB, USB_REQ_GET_DESCRIPTOR)
+#define GetHubStatus		HUB_CLASS_REQ(USB_DIR_IN, USB_RT_HUB, USB_REQ_GET_STATUS)
+#define GetPortStatus		HUB_CLASS_REQ(USB_DIR_IN, USB_RT_PORT, USB_REQ_GET_STATUS)
+#define SetHubFeature		HUB_CLASS_REQ(USB_DIR_OUT, USB_RT_HUB, USB_REQ_SET_FEATURE)
+#define SetPortFeature		HUB_CLASS_REQ(USB_DIR_OUT, USB_RT_PORT, USB_REQ_SET_FEATURE)
 
 
 /*-------------------------------------------------------------------------*/
 
 /* class requests from USB 3.1 hub spec, table 10-7 */
-#define SetHubDepth		(0x2000 | HUB_SET_DEPTH)
-#define GetPortErrorCount	(0xa300 | HUB_GET_PORT_ERR_COUNT)
+#define SetHubDepth		HUB_CLASS_REQ(USB_DIR_OUT, USB_RT_HUB, HUB_SET_DEPTH)
+#define GetPortErrorCount	HUB_CLASS_REQ(USB_DIR_IN, USB_RT_PORT, HUB_GET_PORT_ERR_COUNT)
 
 /*
  * Generic bandwidth allocation constants/support

commit feb26ac31a2a5cb88d86680d9a94916a6343e9e6
Author: Chris Bainbridge <chris.bainbridge@gmail.com>
Date:   Mon Apr 25 13:48:38 2016 +0100

    usb: core: hub: hub_port_init lock controller instead of bus
    
    The XHCI controller presents two USB buses to the system - one for USB2
    and one for USB3. The hub init code (hub_port_init) is reentrant but
    only locks one bus per thread, leading to a race condition failure when
    two threads attempt to simultaneously initialise a USB2 and USB3 device:
    
    [    8.034843] xhci_hcd 0000:00:14.0: Timeout while waiting for setup device command
    [   13.183701] usb 3-3: device descriptor read/all, error -110
    
    On a test system this failure occurred on 6% of all boots.
    
    The call traces at the point of failure are:
    
    Call Trace:
     [<ffffffff81b9bab7>] schedule+0x37/0x90
     [<ffffffff817da7cd>] usb_kill_urb+0x8d/0xd0
     [<ffffffff8111e5e0>] ? wake_up_atomic_t+0x30/0x30
     [<ffffffff817dafbe>] usb_start_wait_urb+0xbe/0x150
     [<ffffffff817db10c>] usb_control_msg+0xbc/0xf0
     [<ffffffff817d07de>] hub_port_init+0x51e/0xb70
     [<ffffffff817d4697>] hub_event+0x817/0x1570
     [<ffffffff810f3e6f>] process_one_work+0x1ff/0x620
     [<ffffffff810f3dcf>] ? process_one_work+0x15f/0x620
     [<ffffffff810f4684>] worker_thread+0x64/0x4b0
     [<ffffffff810f4620>] ? rescuer_thread+0x390/0x390
     [<ffffffff810fa7f5>] kthread+0x105/0x120
     [<ffffffff810fa6f0>] ? kthread_create_on_node+0x200/0x200
     [<ffffffff81ba183f>] ret_from_fork+0x3f/0x70
     [<ffffffff810fa6f0>] ? kthread_create_on_node+0x200/0x200
    
    Call Trace:
     [<ffffffff817fd36d>] xhci_setup_device+0x53d/0xa40
     [<ffffffff817fd87e>] xhci_address_device+0xe/0x10
     [<ffffffff817d047f>] hub_port_init+0x1bf/0xb70
     [<ffffffff811247ed>] ? trace_hardirqs_on+0xd/0x10
     [<ffffffff817d4697>] hub_event+0x817/0x1570
     [<ffffffff810f3e6f>] process_one_work+0x1ff/0x620
     [<ffffffff810f3dcf>] ? process_one_work+0x15f/0x620
     [<ffffffff810f4684>] worker_thread+0x64/0x4b0
     [<ffffffff810f4620>] ? rescuer_thread+0x390/0x390
     [<ffffffff810fa7f5>] kthread+0x105/0x120
     [<ffffffff810fa6f0>] ? kthread_create_on_node+0x200/0x200
     [<ffffffff81ba183f>] ret_from_fork+0x3f/0x70
     [<ffffffff810fa6f0>] ? kthread_create_on_node+0x200/0x200
    
    Which results from the two call chains:
    
    hub_port_init
     usb_get_device_descriptor
      usb_get_descriptor
       usb_control_msg
        usb_internal_control_msg
         usb_start_wait_urb
          usb_submit_urb / wait_for_completion_timeout / usb_kill_urb
    
    hub_port_init
     hub_set_address
      xhci_address_device
       xhci_setup_device
    
    Mathias Nyman explains the current behaviour violates the XHCI spec:
    
     hub_port_reset() will end up moving the corresponding xhci device slot
     to default state.
    
     As hub_port_reset() is called several times in hub_port_init() it
     sounds reasonable that we could end up with two threads having their
     xhci device slots in default state at the same time, which according to
     xhci 4.5.3 specs still is a big no no:
    
     "Note: Software shall not transition more than one Device Slot to the
      Default State at a time"
    
     So both threads fail at their next task after this.
     One fails to read the descriptor, and the other fails addressing the
     device.
    
    Fix this in hub_port_init by locking the USB controller (instead of an
    individual bus) to prevent simultaneous initialisation of both buses.
    
    Fixes: 638139eb95d2 ("usb: hub: allow to process more usb hub events in parallel")
    Link: https://lkml.org/lkml/2016/2/8/312
    Link: https://lkml.org/lkml/2016/2/4/748
    Signed-off-by: Chris Bainbridge <chris.bainbridge@gmail.com>
    Cc: stable <stable@vger.kernel.org>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index b98f831dcda3..66fc13705ab7 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -181,6 +181,7 @@ struct usb_hcd {
 	 * bandwidth_mutex should be dropped after a successful control message
 	 * to the device, or resetting the bandwidth after a failed attempt.
 	 */
+	struct mutex		*address0_mutex;
 	struct mutex		*bandwidth_mutex;
 	struct usb_hcd		*shared_hcd;
 	struct usb_hcd		*primary_hcd;

commit a4b5d606b957c6a58e991de63fe999492de1ab92
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Feb 3 23:35:23 2016 +0100

    usb: core: rename mutex usb_bus_list_lock to usb_bus_idr_lock
    
    Now that usb_bus_list has been removed and switched to idr
    rename the related mutex accordingly.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index c293dd044599..b98f831dcda3 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -632,7 +632,7 @@ extern void usb_set_device_state(struct usb_device *udev,
 /* exported only within usbcore */
 
 extern struct idr usb_bus_idr;
-extern struct mutex usb_bus_list_lock;
+extern struct mutex usb_bus_idr_lock;
 extern wait_queue_head_t usb_kill_urb_queue;
 
 

commit 5363de75307e333d89df7531f9dd8310d973ecdb
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Mon Jan 25 20:30:30 2016 +0100

    usb: core: switch bus numbering to using idr
    
    USB bus numbering is based on directly dealing with bitmaps and
    defines a separate list of busses.
    This can be simplified and unified by using existing idr functionality.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 4dcf8446dbcd..c293dd044599 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -23,6 +23,7 @@
 
 #include <linux/rwsem.h>
 #include <linux/interrupt.h>
+#include <linux/idr.h>
 
 #define MAX_TOPO_LEVEL		6
 
@@ -630,7 +631,7 @@ extern void usb_set_device_state(struct usb_device *udev,
 
 /* exported only within usbcore */
 
-extern struct list_head usb_bus_list;
+extern struct idr usb_bus_idr;
 extern struct mutex usb_bus_list_lock;
 extern wait_queue_head_t usb_kill_urb_queue;
 

commit 6fb8ac81cb3125aafc7136f2ef0145da792bab94
Author: Julia Lawall <julia.lawall@lip6.fr>
Date:   Sat Nov 28 16:07:10 2015 +0100

    USB: constify usb_mon_operations structure
    
    The usb_mon_operations structure is never modified, so declare it as const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index f89c24bd53a4..4dcf8446dbcd 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -660,7 +660,7 @@ struct usb_mon_operations {
 	/* void (*urb_unlink)(struct usb_bus *bus, struct urb *urb); */
 };
 
-extern struct usb_mon_operations *mon_ops;
+extern const struct usb_mon_operations *mon_ops;
 
 static inline void usbmon_urb_submit(struct usb_bus *bus, struct urb *urb)
 {
@@ -682,7 +682,7 @@ static inline void usbmon_urb_complete(struct usb_bus *bus, struct urb *urb,
 		(*mon_ops->urb_complete)(bus, urb, status);
 }
 
-int usb_mon_register(struct usb_mon_operations *ops);
+int usb_mon_register(const struct usb_mon_operations *ops);
 void usb_mon_deregister(void);
 
 #else

commit 7117522520b9101af7a0602d6b0d1e67d689fc6b
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Oct 1 18:40:37 2015 +0300

    usb: define HCD_USB31 speed option for hosts that support USB 3.1 features
    
    Hosts that support USB 3.1 Enhaned SuperSpeed can set their speed to
    HCD_USB31 to let usb core and host drivers know that the controller
    supports new USB 3.1 features.
    
    make sure usb core handle HCD_USB31 hosts correctly, for now similar
    to HCD_USB3.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 4d147277b30d..f89c24bd53a4 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -250,6 +250,7 @@ struct hc_driver {
 #define	HCD_USB2	0x0020		/* USB 2.0 */
 #define	HCD_USB25	0x0030		/* Wireless USB 1.0 (USB 2.5)*/
 #define	HCD_USB3	0x0040		/* USB 3.0 */
+#define	HCD_USB31	0x0050		/* USB 3.1 */
 #define	HCD_MASK	0x0070
 #define	HCD_BH		0x0100		/* URB complete in BH context */
 

commit ff8e2c560eca32043ed097099debac488a4bd99f
Author: Stefan Koch <stefan.koch10@gmail.com>
Date:   Tue Aug 25 21:10:11 2015 +0200

    usb: interface authorization: Use a flag for the default device authorization
    
    With this patch a flag instead of a variable
    is used for the default device authorization.
    
    Signed-off-by: Stefan Koch <stefan.koch10@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 36ce3d215cad..4d147277b30d 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -58,12 +58,6 @@
  *
  * Since "struct usb_bus" is so thin, you can't share much code in it.
  * This framework is a layer over that, and should be more sharable.
- *
- * @authorized_default: Specifies if new devices are authorized to
- *                      connect by default or they require explicit
- *                      user space authorization; this bit is settable
- *                      through /sys/class/usb_host/X/authorized_default.
- *                      For the rest is RO, so we don't lock to r/w it.
  */
 
 /*-------------------------------------------------------------------------*/
@@ -121,6 +115,7 @@ struct usb_hcd {
 #define HCD_FLAG_RH_RUNNING		5	/* root hub is running? */
 #define HCD_FLAG_DEAD			6	/* controller has died? */
 #define HCD_FLAG_INTF_AUTHORIZED	7	/* authorize interfaces? */
+#define HCD_FLAG_DEV_AUTHORIZED		8	/* authorize devices? */
 
 	/* The flags can be tested using these macros; they are likely to
 	 * be slightly faster than test_bit().
@@ -140,6 +135,14 @@ struct usb_hcd {
 #define HCD_INTF_AUTHORIZED(hcd) \
 	((hcd)->flags & (1U << HCD_FLAG_INTF_AUTHORIZED))
 
+	/*
+	 * Specifies if devices are authorized by default
+	 * or they require explicit user space authorization; this bit is
+	 * settable through /sys/class/usb_host/X/authorized_default
+	 */
+#define HCD_DEV_AUTHORIZED(hcd) \
+	((hcd)->flags & (1U << HCD_FLAG_DEV_AUTHORIZED))
+
 	/* Flags that get set only during HCD registration or removal. */
 	unsigned		rh_registered:1;/* is root hub registered? */
 	unsigned		rh_pollable:1;	/* may we poll the root hub? */
@@ -150,7 +153,6 @@ struct usb_hcd {
 	 * support the new root-hub polling mechanism. */
 	unsigned		uses_new_polling:1;
 	unsigned		wireless:1;	/* Wireless USB HCD */
-	unsigned		authorized_default:1;
 	unsigned		has_tt:1;	/* Integrated TT in root hub */
 	unsigned		amd_resume_bug:1; /* AMD remote wakeup quirk */
 	unsigned		can_do_streams:1; /* HC supports streams */

commit 6b2bd3c8c69c4817a9a2feb4597021d486c105f4
Author: Stefan Koch <stefan.koch10@gmail.com>
Date:   Tue Aug 25 21:10:06 2015 +0200

    usb: interface authorization: Introduces the default interface authorization
    
    Interfaces are allowed per default.
    This can disabled or enabled (again) by writing 0 or 1 to
    /sys/bus/usb/devices/usbX/interface_authorized_default
    
    Signed-off-by: Stefan Koch <stefan.koch10@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index d2784c10bfe2..36ce3d215cad 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -120,6 +120,7 @@ struct usb_hcd {
 #define HCD_FLAG_WAKEUP_PENDING		4	/* root hub is resuming? */
 #define HCD_FLAG_RH_RUNNING		5	/* root hub is running? */
 #define HCD_FLAG_DEAD			6	/* controller has died? */
+#define HCD_FLAG_INTF_AUTHORIZED	7	/* authorize interfaces? */
 
 	/* The flags can be tested using these macros; they are likely to
 	 * be slightly faster than test_bit().
@@ -131,6 +132,14 @@ struct usb_hcd {
 #define HCD_RH_RUNNING(hcd)	((hcd)->flags & (1U << HCD_FLAG_RH_RUNNING))
 #define HCD_DEAD(hcd)		((hcd)->flags & (1U << HCD_FLAG_DEAD))
 
+	/*
+	 * Specifies if interfaces are authorized by default
+	 * or they require explicit user space authorization; this bit is
+	 * settable through /sys/class/usb_host/X/interface_authorized_default
+	 */
+#define HCD_INTF_AUTHORIZED(hcd) \
+	((hcd)->flags & (1U << HCD_FLAG_INTF_AUTHORIZED))
+
 	/* Flags that get set only during HCD registration or removal. */
 	unsigned		rh_registered:1;/* is root hub registered? */
 	unsigned		rh_pollable:1;	/* may we poll the root hub? */

commit 12e1a6a0f16168346cb8f33aff135ed523a9f097
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Aug 18 09:58:45 2015 -0700

    Revert "usb: interface authorization: Introduces the default interface authorization"
    
    This reverts commit 1d958bef45030acfc5578263e9de3bb07032b8da as the
    signed-off-by address is invalid.
    
    Cc: Stefan Koch <stefan.koch10@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 36ce3d215cad..d2784c10bfe2 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -120,7 +120,6 @@ struct usb_hcd {
 #define HCD_FLAG_WAKEUP_PENDING		4	/* root hub is resuming? */
 #define HCD_FLAG_RH_RUNNING		5	/* root hub is running? */
 #define HCD_FLAG_DEAD			6	/* controller has died? */
-#define HCD_FLAG_INTF_AUTHORIZED	7	/* authorize interfaces? */
 
 	/* The flags can be tested using these macros; they are likely to
 	 * be slightly faster than test_bit().
@@ -132,14 +131,6 @@ struct usb_hcd {
 #define HCD_RH_RUNNING(hcd)	((hcd)->flags & (1U << HCD_FLAG_RH_RUNNING))
 #define HCD_DEAD(hcd)		((hcd)->flags & (1U << HCD_FLAG_DEAD))
 
-	/*
-	 * Specifies if interfaces are authorized by default
-	 * or they require explicit user space authorization; this bit is
-	 * settable through /sys/class/usb_host/X/interface_authorized_default
-	 */
-#define HCD_INTF_AUTHORIZED(hcd) \
-	((hcd)->flags & (1U << HCD_FLAG_INTF_AUTHORIZED))
-
 	/* Flags that get set only during HCD registration or removal. */
 	unsigned		rh_registered:1;/* is root hub registered? */
 	unsigned		rh_pollable:1;	/* may we poll the root hub? */

commit a1b93ab71587b8b44d45d114937cb4e75f9a5f27
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Aug 18 09:56:04 2015 -0700

    Revert "usb: interface authorization: Use a flag for the default device authorization"
    
    This reverts commit 3cf1fc80655d3af7083ea4b3615e5f8532543be7 as the
    signed-off-by address is invalid.
    
    Cc: Stefan Koch <stefan.koch10@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 4d147277b30d..36ce3d215cad 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -58,6 +58,12 @@
  *
  * Since "struct usb_bus" is so thin, you can't share much code in it.
  * This framework is a layer over that, and should be more sharable.
+ *
+ * @authorized_default: Specifies if new devices are authorized to
+ *                      connect by default or they require explicit
+ *                      user space authorization; this bit is settable
+ *                      through /sys/class/usb_host/X/authorized_default.
+ *                      For the rest is RO, so we don't lock to r/w it.
  */
 
 /*-------------------------------------------------------------------------*/
@@ -115,7 +121,6 @@ struct usb_hcd {
 #define HCD_FLAG_RH_RUNNING		5	/* root hub is running? */
 #define HCD_FLAG_DEAD			6	/* controller has died? */
 #define HCD_FLAG_INTF_AUTHORIZED	7	/* authorize interfaces? */
-#define HCD_FLAG_DEV_AUTHORIZED		8	/* authorize devices? */
 
 	/* The flags can be tested using these macros; they are likely to
 	 * be slightly faster than test_bit().
@@ -135,14 +140,6 @@ struct usb_hcd {
 #define HCD_INTF_AUTHORIZED(hcd) \
 	((hcd)->flags & (1U << HCD_FLAG_INTF_AUTHORIZED))
 
-	/*
-	 * Specifies if devices are authorized by default
-	 * or they require explicit user space authorization; this bit is
-	 * settable through /sys/class/usb_host/X/authorized_default
-	 */
-#define HCD_DEV_AUTHORIZED(hcd) \
-	((hcd)->flags & (1U << HCD_FLAG_DEV_AUTHORIZED))
-
 	/* Flags that get set only during HCD registration or removal. */
 	unsigned		rh_registered:1;/* is root hub registered? */
 	unsigned		rh_pollable:1;	/* may we poll the root hub? */
@@ -153,6 +150,7 @@ struct usb_hcd {
 	 * support the new root-hub polling mechanism. */
 	unsigned		uses_new_polling:1;
 	unsigned		wireless:1;	/* Wireless USB HCD */
+	unsigned		authorized_default:1;
 	unsigned		has_tt:1;	/* Integrated TT in root hub */
 	unsigned		amd_resume_bug:1; /* AMD remote wakeup quirk */
 	unsigned		can_do_streams:1; /* HC supports streams */

commit 3cf1fc80655d3af7083ea4b3615e5f8532543be7
Author: Stefan Koch <stefan.koch10@gmail.com>
Date:   Sat Aug 8 11:32:56 2015 +0200

    usb: interface authorization: Use a flag for the default device authorization
    
    With this patch a flag instead of a variable
    is used for the default device authorization.
    
    Signed-off-by: Stefan Koch <skoch@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 36ce3d215cad..4d147277b30d 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -58,12 +58,6 @@
  *
  * Since "struct usb_bus" is so thin, you can't share much code in it.
  * This framework is a layer over that, and should be more sharable.
- *
- * @authorized_default: Specifies if new devices are authorized to
- *                      connect by default or they require explicit
- *                      user space authorization; this bit is settable
- *                      through /sys/class/usb_host/X/authorized_default.
- *                      For the rest is RO, so we don't lock to r/w it.
  */
 
 /*-------------------------------------------------------------------------*/
@@ -121,6 +115,7 @@ struct usb_hcd {
 #define HCD_FLAG_RH_RUNNING		5	/* root hub is running? */
 #define HCD_FLAG_DEAD			6	/* controller has died? */
 #define HCD_FLAG_INTF_AUTHORIZED	7	/* authorize interfaces? */
+#define HCD_FLAG_DEV_AUTHORIZED		8	/* authorize devices? */
 
 	/* The flags can be tested using these macros; they are likely to
 	 * be slightly faster than test_bit().
@@ -140,6 +135,14 @@ struct usb_hcd {
 #define HCD_INTF_AUTHORIZED(hcd) \
 	((hcd)->flags & (1U << HCD_FLAG_INTF_AUTHORIZED))
 
+	/*
+	 * Specifies if devices are authorized by default
+	 * or they require explicit user space authorization; this bit is
+	 * settable through /sys/class/usb_host/X/authorized_default
+	 */
+#define HCD_DEV_AUTHORIZED(hcd) \
+	((hcd)->flags & (1U << HCD_FLAG_DEV_AUTHORIZED))
+
 	/* Flags that get set only during HCD registration or removal. */
 	unsigned		rh_registered:1;/* is root hub registered? */
 	unsigned		rh_pollable:1;	/* may we poll the root hub? */
@@ -150,7 +153,6 @@ struct usb_hcd {
 	 * support the new root-hub polling mechanism. */
 	unsigned		uses_new_polling:1;
 	unsigned		wireless:1;	/* Wireless USB HCD */
-	unsigned		authorized_default:1;
 	unsigned		has_tt:1;	/* Integrated TT in root hub */
 	unsigned		amd_resume_bug:1; /* AMD remote wakeup quirk */
 	unsigned		can_do_streams:1; /* HC supports streams */

commit 1d958bef45030acfc5578263e9de3bb07032b8da
Author: Stefan Koch <stefan.koch10@gmail.com>
Date:   Sat Aug 8 11:32:51 2015 +0200

    usb: interface authorization: Introduces the default interface authorization
    
    Interfaces are allowed per default.
    This can disabled or enabled (again) by writing 0 or 1 to
    /sys/bus/usb/devices/usbX/interface_authorized_default
    
    Signed-off-by: Stefan Koch <skoch@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index d2784c10bfe2..36ce3d215cad 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -120,6 +120,7 @@ struct usb_hcd {
 #define HCD_FLAG_WAKEUP_PENDING		4	/* root hub is resuming? */
 #define HCD_FLAG_RH_RUNNING		5	/* root hub is running? */
 #define HCD_FLAG_DEAD			6	/* controller has died? */
+#define HCD_FLAG_INTF_AUTHORIZED	7	/* authorize interfaces? */
 
 	/* The flags can be tested using these macros; they are likely to
 	 * be slightly faster than test_bit().
@@ -131,6 +132,14 @@ struct usb_hcd {
 #define HCD_RH_RUNNING(hcd)	((hcd)->flags & (1U << HCD_FLAG_RH_RUNNING))
 #define HCD_DEAD(hcd)		((hcd)->flags & (1U << HCD_FLAG_DEAD))
 
+	/*
+	 * Specifies if interfaces are authorized by default
+	 * or they require explicit user space authorization; this bit is
+	 * settable through /sys/class/usb_host/X/interface_authorized_default
+	 */
+#define HCD_INTF_AUTHORIZED(hcd) \
+	((hcd)->flags & (1U << HCD_FLAG_INTF_AUTHORIZED))
+
 	/* Flags that get set only during HCD registration or removal. */
 	unsigned		rh_registered:1;/* is root hub registered? */
 	unsigned		rh_pollable:1;	/* may we poll the root hub? */

commit 7e34d70a7163b236f520ef4fc0d7c50093dd3746
Author: Tal Shorer <tal.shorer@gmail.com>
Date:   Fri Aug 7 22:35:51 2015 +0300

    usb: hcd.h: Fix the values of SetHubDepth and GetPortErrorCount to match USB 3.1 specification
    
    >From the usb 3.1 spec available at http://www.usb.org/developers/docs/
    table 10-7 (Hub Class Requests) specifies the values for SetHubDepth and
    GetPortErrorCount as:
    
    Request                 bmRequestType   bRequest                wValue          wIndex  wLength Data
    SetHubDepth             00100000B       SET_HUB_DEPTH           Hub Depth       Zero    Zero    None
    GetPortErrorCount       10100011B       GET_PORT_ERR_COUNT      Zero            Port    Two     Number of Link Errors on this port
    
    Fix these two values to match the spec.
    
    Signed-off-by: Tal Shorer <tal.shorer@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index c9aa7792de10..d2784c10bfe2 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -564,9 +564,9 @@ extern void usb_ep0_reinit(struct usb_device *);
 
 /*-------------------------------------------------------------------------*/
 
-/* class requests from USB 3.0 hub spec, table 10-5 */
-#define SetHubDepth		(0x3000 | HUB_SET_DEPTH)
-#define GetPortErrorCount	(0x8000 | HUB_GET_PORT_ERR_COUNT)
+/* class requests from USB 3.1 hub spec, table 10-7 */
+#define SetHubDepth		(0x2000 | HUB_SET_DEPTH)
+#define GetPortErrorCount	(0xa300 | HUB_GET_PORT_ERR_COUNT)
 
 /*
  * Generic bandwidth allocation constants/support

commit f0e6a326deec8b51ee12f82a34057efd3d0979b8
Author: Abhishek Bist <ishubist@gmail.com>
Date:   Wed May 27 23:54:19 2015 +0530

    USB: hcd.h : Removed an unnecessary function prototype usb_find_interface_driver()
    
    This function is used to call in early version of linux kernel in order
    to find out the interface used by a usb device. But now it's use is
    completely abolished. So,it would be relevant to remove this obselete
    function from kernel mainline.
    
    Signed-off-by: Abhishek Bist <ishubist@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 68b1e836dff1..c9aa7792de10 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -622,8 +622,6 @@ extern struct list_head usb_bus_list;
 extern struct mutex usb_bus_list_lock;
 extern wait_queue_head_t usb_kill_urb_queue;
 
-extern int usb_find_interface_driver(struct usb_device *dev,
-	struct usb_interface *interface);
 
 #define usb_endpoint_out(ep_dir)	(!((ep_dir) & USB_DIR_IN))
 

commit 074f9dd55f9cab1b82690ed7e44bcf38b9616ce0
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Jan 29 15:05:04 2015 -0500

    USB: add flag for HCDs that can't receive wakeup requests (isp1760-hcd)
    
    Currently the USB stack assumes that all host controller drivers are
    capable of receiving wakeup requests from downstream devices.
    However, this isn't true for the isp1760-hcd driver, which means that
    it isn't safe to do a runtime suspend of any device attached to a
    root-hub port if the device requires wakeup.
    
    This patch adds a "cant_recv_wakeups" flag to the usb_hcd structure
    and sets the flag in isp1760-hcd.  The core is modified to prevent a
    direct child of the root hub from being put into runtime suspend with
    wakeup enabled if the flag is set.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Nicolas Pitre <nico@linaro.org>
    CC: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 8968f616e414..68b1e836dff1 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -146,6 +146,8 @@ struct usb_hcd {
 	unsigned		amd_resume_bug:1; /* AMD remote wakeup quirk */
 	unsigned		can_do_streams:1; /* HC supports streams */
 	unsigned		tpl_support:1; /* OTG & EH TPL support */
+	unsigned		cant_recv_wakeups:1;
+			/* wakeup requests from downstream aren't received */
 
 	unsigned int		irq;		/* irq allocated */
 	void __iomem		*regs;		/* device memory/io */

commit 5efd2ea8c9f4f12916ffc8ba636792ce052f6911
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Fri Dec 5 15:13:54 2014 +0100

    usb: core: buffer: smallest buffer should start at ARCH_DMA_MINALIGN
    
    the following error pops up during "testusb -a -t 10"
    | musb-hdrc musb-hdrc.1.auto: dma_pool_free buffer-128, f134e000/be842000 (bad dma)
    hcd_buffer_create() creates a few buffers, the smallest has 32 bytes of
    size. ARCH_KMALLOC_MINALIGN is set to 64 bytes. This combo results in
    hcd_buffer_alloc() returning memory which is 32 bytes aligned and it
    might by identified by buffer_offset() as another buffer. This means the
    buffer which is on a 32 byte boundary will not get freed, instead it
    tries to free another buffer with the error message.
    
    This patch fixes the issue by creating the smallest DMA buffer with the
    size of ARCH_KMALLOC_MINALIGN (or 32 in case ARCH_KMALLOC_MINALIGN is
    smaller). This might be 32, 64 or even 128 bytes. The next three pools
    will have the size 128, 512 and 2048.
    In case the smallest pool is 128 bytes then we have only three pools
    instead of four (and zero the first entry in the array).
    The last pool size is always 2048 bytes which is the assumed PAGE_SIZE /
    2 of 4096. I doubt it makes sense to continue using PAGE_SIZE / 2 where
    we would end up with 8KiB buffer in case we have 16KiB pages.
    Instead I think it makes sense to have a common size(s) and extend them
    if there is need to.
    There is a BUILD_BUG_ON() now in case someone has a minalign of more than
    128 bytes.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 086bf13307e6..8968f616e414 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -453,6 +453,7 @@ extern const struct dev_pm_ops usb_hcd_pci_pm_ops;
 #endif /* CONFIG_PCI */
 
 /* pci-ish (pdev null is ok) buffer alloc/mapping support */
+void usb_init_pool_max(void);
 int hcd_buffer_create(struct usb_hcd *hcd);
 void hcd_buffer_destroy(struct usb_hcd *hcd);
 

commit e7cf773d431a63a2417902696fcc9e0ebdc83bbe
Merge: 7a02d089695a 81e1dadfb5b2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 14:57:16 2014 -0800

    Merge tag 'usb-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb
    
    Pull USB updates from Greg KH:
     "Here's the big set of USB and PHY patches for 3.19-rc1.
    
      The normal churn in the USB gadget area is in here, as well as xhci
      and other individual USB driver updates.  The PHY tree is also in
      here, as there were dependancies on the USB tree.
    
      All of these have been in linux-next"
    
    * tag 'usb-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb: (351 commits)
      arm: omap3: twl: remove usb phy init data
      usbip: fix error handling in stub_probe()
      usb: gadget: udc: missing curly braces
      USB: mos7720: delete some unneeded code
      wusb: replace memset by memzero_explicit
      usbip: remove unneeded structure
      usb: xhci: fix comment for PORT_DEV_REMOVE
      xhci: don't use the same variable for stopped and halted rings current TD
      xhci: clear extra bits from slot context when setting max exit latency
      xhci: cleanup finish_td function
      USB: adutux: NULL dereferences on disconnect
      usb: chipidea: fix platform_no_drv_owner.cocci warnings
      usb: chipidea: Fixed a few typos in comments
      Documentation: bindings: add doc for the USB2 ChipIdea USB driver
      usb: chipidea: add a usb2 driver for ci13xxx
      usb: chipidea: fix phy handling
      usb: chipidea: remove duplicate dev_set_drvdata for host_start
      usb: chipidea: parameter 'mode' isn't needed for hw_device_reset
      usb: chipidea: add controller reset API
      usb: chipidea: remove flag CI_HDRC_REQUIRE_TRANSCEIVER
      ...

commit ceb6c9c862c86423f41c1e20ecf8d454f837f519
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Nov 29 23:47:05 2014 +0100

    USB / PM: Drop CONFIG_PM_RUNTIME from the USB core
    
    After commit b2b49ccbdd54 (PM: Kconfig: Set PM_RUNTIME if PM_SLEEP is
    selected) PM_RUNTIME is always set if PM is set, so quite a few
    depend on CONFIG_PM (or even dropped in some cases).
    
    Replace CONFIG_PM_RUNTIME with CONFIG_PM in the USB core code
    and documentation.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index cd96a2bc3388..668898e29d0e 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -93,7 +93,7 @@ struct usb_hcd {
 
 	struct timer_list	rh_timer;	/* drives root-hub polling */
 	struct urb		*status_urb;	/* the current status urb */
-#ifdef CONFIG_PM_RUNTIME
+#ifdef CONFIG_PM
 	struct work_struct	wakeup_work;	/* for remote wakeup */
 #endif
 
@@ -625,16 +625,13 @@ extern int usb_find_interface_driver(struct usb_device *dev,
 extern void usb_root_hub_lost_power(struct usb_device *rhdev);
 extern int hcd_bus_suspend(struct usb_device *rhdev, pm_message_t msg);
 extern int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg);
-#endif /* CONFIG_PM */
-
-#ifdef CONFIG_PM_RUNTIME
 extern void usb_hcd_resume_root_hub(struct usb_hcd *hcd);
 #else
 static inline void usb_hcd_resume_root_hub(struct usb_hcd *hcd)
 {
 	return;
 }
-#endif /* CONFIG_PM_RUNTIME */
+#endif /* CONFIG_PM */
 
 /*-------------------------------------------------------------------------*/
 

commit 11a7e59405148c855e0a9d13588930ccec02c150
Author: Michael Grzeschik <m.grzeschik@pengutronix.de>
Date:   Mon Oct 13 09:53:03 2014 +0800

    usb: ehci: add ehci_port_power interface
    
    The current EHCI implementation is prepared to toggle the
    PORT_POWER bit to enable or disable a USB-Port. In some
    cases this port power can not be just toggled by the PORT_POWER
    bit, and the gpio-regulator is needed to be toggled too.
    
    This patch defines a port power control interface ehci_port_power for
    ehci core use, it toggles PORT_POWER bit as well as calls platform
    defined .port_power if it is defined.
    
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Acked-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index cd96a2bc3388..9cf7e3594609 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -379,6 +379,9 @@ struct hc_driver {
 	int	(*disable_usb3_lpm_timeout)(struct usb_hcd *,
 			struct usb_device *, enum usb3_link_state state);
 	int	(*find_raw_port_number)(struct usb_hcd *, int);
+	/* Call for power on/off the port if necessary */
+	int	(*port_power)(struct usb_hcd *hcd, int portnum, bool enable);
+
 };
 
 static inline int hcd_giveback_urb_in_bh(struct usb_hcd *hcd)

commit 0043325495222139daa0696db736f67658dc7770
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Wed Sep 24 23:09:44 2014 +0400

    usb: hcd: add generic PHY support
    
    Add the generic PHY support, analogous to the USB PHY support. Intended it to be
    used with the PCI EHCI/OHCI drivers and the xHCI platform driver.
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 788059a108e5..cd96a2bc3388 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -107,6 +107,7 @@ struct usb_hcd {
 	 * other external phys should be software-transparent
 	 */
 	struct usb_phy		*usb_phy;
+	struct phy		*phy;
 
 	/* Flags that need to be manipulated atomically because they can
 	 * change while the host controller is running.  Always use

commit 3d46e73dfdb840f460e5b06416965d132570ec33
Author: Antoine Tenart <antoine.tenart@free-electrons.com>
Date:   Wed Sep 24 23:05:50 2014 +0400

    usb: rename phy to usb_phy in HCD
    
    The USB PHY member of the HCD structure is renamed to 'usb_phy' and
    modifications are done in all drivers accessing it.
    This is in preparation to adding the generic PHY support.
    
    Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
    [Sergei: added missing 'drivers/usb/misc/lvstest.c' file, resolved rejects,
    updated changelog.]
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index a48c89e96988..788059a108e5 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -106,7 +106,7 @@ struct usb_hcd {
 	 * OTG and some Host controllers need software interaction with phys;
 	 * other external phys should be software-transparent
 	 */
-	struct usb_phy	*phy;
+	struct usb_phy		*usb_phy;
 
 	/* Flags that need to be manipulated atomically because they can
 	 * change while the host controller is running.  Always use

commit f2693b430b33d9554daa0f21fbcae57633f8d4f1
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Aug 19 09:51:52 2014 +0800

    usb: hcd: add TPL support flag
    
    The targeted hosts (non-PC hosts) need to have TPL (Targeted Peripheral List)
    for USB OTG & EH certification and other vendor specific requirements.
    
    The platform who needs TPL feature should set this flag at usb host
    controller driver.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 485cd5e2100c..a48c89e96988 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -144,6 +144,7 @@ struct usb_hcd {
 	unsigned		has_tt:1;	/* Integrated TT in root hub */
 	unsigned		amd_resume_bug:1; /* AMD remote wakeup quirk */
 	unsigned		can_do_streams:1; /* HC supports streams */
+	unsigned		tpl_support:1; /* OTG & EH TPL support */
 
 	unsigned int		irq;		/* irq allocated */
 	void __iomem		*regs;		/* device memory/io */

commit 14aec589327a6fc4035f5327d90ac5548f501c4c
Author: Oliver Neukum <oneukum@suse.de>
Date:   Tue Feb 11 20:36:04 2014 +0100

    storage: accept some UAS devices if streams are unavailable
    
    On some older XHCIs streams are not supported and the UAS driver
    will fail at probe time. For those devices storage should try
    to bind to UAS devices.
    This patch adds a flag for stream support to HCDs and evaluates
    it.
    
    [Note: Sarah fixed a bug where the USB 2.0 root hub, not USB 3.0 root
    hub would get marked as being able to support streams.]
    
    Signed-off-by: Oliver Neukum <oliver@neukum.org>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Acked-by: Hans de Goede <hdegoede@redhat.com>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index efe8d8a7c7ad..485cd5e2100c 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -143,6 +143,7 @@ struct usb_hcd {
 	unsigned		authorized_default:1;
 	unsigned		has_tt:1;	/* Integrated TT in root hub */
 	unsigned		amd_resume_bug:1; /* AMD remote wakeup quirk */
+	unsigned		can_do_streams:1; /* HC supports streams */
 
 	unsigned int		irq;		/* irq allocated */
 	void __iomem		*regs;		/* device memory/io */

commit 48fc7dbd52c0559647291f33a10ccdc6cdbe4c72
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Dec 5 17:07:27 2013 -0800

    usb: xhci: change enumeration scheme to 'new scheme' by default
    
    Change the default enumeration scheme for xhci attached non-SuperSpeed
    devices from:
    
       Reset
       SetAddress [xhci address-device BSR = 0]
       GetDescriptor(8)
       GetDescriptor(18)
    
    ...to:
    
       Reset
       [xhci address-device BSR = 1]
       GetDescriptor(64)
       Reset
       SetAddress [xhci address-device BSR = 0]
       GetDescriptor(18)
    
    ...as some devices misbehave when encountering a SetAddress command
    prior to GetDescriptor.  There are known legacy devices that require
    this scheme, but testing has found at least one USB3 device that fails
    enumeration when presented with this ordering.  For now, follow the ehci
    case and enable 'new scheme' by default for non-SuperSpeed devices.
    
    To support this enumeration scheme on xhci the AddressDevice operation
    needs to be performed twice.  The first instance of the command enables
    the HC's device and slot context info for the device, but omits sending
    the device a SetAddress command (BSR == block set address request).
    Then, after GetDescriptor completes, follow up with the full
    AddressDevice+SetAddress operation.
    
    As mentioned before, this ordering of events with USB3 devices causes an
    extra state transition to be exposed to xhci.  Previously USB3 devices
    would transition directly from 'enabled' to 'addressed' and never need
    to underrun responses to 'get descriptor'. We do see the 64-byte
    descriptor fetch the correct data, but the following 18-byte descriptor
    read after the reset gets:
    
    bLength            = 0
    bDescriptorType    = 0
    bcdUSB             = 0
    bDeviceClass       = 0
    bDeviceSubClass    = 0
    bDeviceProtocol    = 0
    bMaxPacketSize0    = 9
    
    instead of:
    
    bLength            = 12
    bDescriptorType    = 1
    bcdUSB             = 300
    bDeviceClass       = 0
    bDeviceSubClass    = 0
    bDeviceProtocol    = 0
    bMaxPacketSize0    = 9
    
    which results in the discovery process looping until falling back to
    'old scheme' enumeration.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: David Moore <david.moore@gmail.com>
    Suggested-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 758ce80d085f..efe8d8a7c7ad 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -353,6 +353,8 @@ struct hc_driver {
 	void	(*reset_bandwidth)(struct usb_hcd *, struct usb_device *);
 		/* Returns the hardware-chosen device address */
 	int	(*address_device)(struct usb_hcd *, struct usb_device *udev);
+		/* prepares the hardware to send commands to the device */
+	int	(*enable_device)(struct usb_hcd *, struct usb_device *udev);
 		/* Notifies the HCD after a hub descriptor is fetched.
 		 * Will block.
 		 */

commit 103e127d1f8f985e8a662da6537ebc5e08902ee3
Author: Valentine Barshak <valentine.barshak@cogentembedded.com>
Date:   Wed Dec 4 01:42:21 2013 +0400

    usb: hcd: Remove USB phy if needed
    
    This adds remove_phy flag to the HCD structure. If the flag is
    set and if hcd->phy is valid, the phy is shutdown and released
    whenever usb_add_hcd fails or usb_hcd_remove is called.
    This can be used by the HCD drivers to auto-remove
    the external USB phy when it is no longer needed.
    
    Signed-off-by: Valentine Barshak <valentine.barshak@cogentembedded.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index b8aba196f7f1..758ce80d085f 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -134,6 +134,7 @@ struct usb_hcd {
 	unsigned		rh_registered:1;/* is root hub registered? */
 	unsigned		rh_pollable:1;	/* may we poll the root hub? */
 	unsigned		msix_enabled:1;	/* driver has MSI-X enabled? */
+	unsigned		remove_phy:1;	/* auto-remove USB phy */
 
 	/* The next flag is a stopgap, to be removed when all the HCDs
 	 * support the new root-hub polling mechanism. */

commit 7c4bb942986fc2aa7ca4fccfed665d24525a0e21
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Oct 11 11:29:22 2013 -0400

    USB: add a private-data pointer to struct usb_tt
    
    For improved scheduling of transfers through a Transaction Translator,
    ehci-hcd will need to store a bunch of information associated with the
    FS/LS bus on the downstream side of the TT.  This patch adds a pointer
    for such HCD-private data to the usb_tt structure.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index dbe3cd19ffd8..b8aba196f7f1 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -506,6 +506,7 @@ struct usb_tt {
 	struct usb_device	*hub;	/* upstream highspeed hub */
 	int			multi;	/* true means one TT per port */
 	unsigned		think_time;	/* think time in ns */
+	void			*hcpriv;	/* HCD private data */
 
 	/* for control/bulk error recovery (CLEAR_TT_BUFFER) */
 	spinlock_t		lock;

commit 63fb3a280061c5a1d9190015e5a074213f9d23c0
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Oct 11 11:28:02 2013 -0400

    USB: NS_TO_US should round up
    
    Host controller drivers use the NS_TO_US macro to convert transaction
    times, which are computed in nanoseconds, to microseconds for
    scheduling.  Periodic scheduling requires worst-case estimates, but
    the macro does its conversion using round-to-nearest.  This patch
    changes it to use round-up, giving a correct worst-case value.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index fc64b6825f5e..dbe3cd19ffd8 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -564,9 +564,8 @@ extern void usb_ep0_reinit(struct usb_device *);
 		 * of (7/6 * 8 * bytecount) = 9.33 * bytecount */
 		/* bytecount = data payload byte count */
 
-#define NS_TO_US(ns)	((ns + 500L) / 1000L)
-			/* convert & round nanoseconds to microseconds */
-
+#define NS_TO_US(ns)	DIV_ROUND_UP(ns, 1000L)
+			/* convert nanoseconds to microseconds, rounding up */
 
 /*
  * Full/low speed bandwidth allocation constants/support.

commit 7868943db1668fba898cf71bed1506c19d6958aa
Author: Huang Rui <ray.huang@amd.com>
Date:   Mon Sep 16 23:47:28 2013 +0800

    usb: core: implement AMD remote wakeup quirk
    
    The following patch is required to resolve remote wake issues with
    certain devices.
    
    Issue description:
    If the remote wake is issued from the device in a specific timing
    condition while the system is entering sleep state then it may cause
    system to auto wake on subsequent sleep cycle.
    
    Root cause:
    Host controller rebroadcasts the Resume signal > 100 seconds after
    receiving the original resume event from the device. For proper
    function, some devices may require the rebroadcast of resume event
    within the USB spec of 100S.
    
    Workaroud:
    1. Filter the AMD platforms with Yangtze chipset, then judge of all the usb
    devices are mouse or not. And get out the port id which attached a mouse
    with Pixart controller.
    2. Then reset the port which attached issue device during system resume
    from S3.
    
    [Q] Why the special devices are only mice? Would high speed devices
    such as 3G modem or USB Bluetooth adapter trigger this issue?
    - Current this sensitivity is only confined to devices that use Pixart
      controllers. This controller is designed for use with LS mouse
    devices only. We have not observed any other devices failing. There
    may be a small risk for other devices also but this patch (reset
    device in resume phase) will cover the cases if required.
    
    [Q] Shouldnt the resume signal be sent within 100 us for every
    device?
    - The Host controller may not send the resume signal within 100us,
      this our host controller specification change. This is why we
    require the patch to prevent side effects on certain known devices.
    
    [Q] Why would clicking mouse INTENSELY to wake the system up trigger
    this issue?
    - This behavior is specific to the devices that use Pixart controller.
      It is timing dependent on when the resume event is triggered during
    the sleep state.
    
    [Q] Is it a host controller issue or mouse?
    - It is the host controller behavior during resume that triggers the
      device incorrect behavior on the next resume.
    
    This patch sets USB_QUIRK_RESET_RESUME flag for these Pixart-based mice
    when they attached to platforms with AMD Yangtze chipset.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 8c865134c881..fc64b6825f5e 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -141,6 +141,7 @@ struct usb_hcd {
 	unsigned		wireless:1;	/* Wireless USB HCD */
 	unsigned		authorized_default:1;
 	unsigned		has_tt:1;	/* Integrated TT in root hub */
+	unsigned		amd_resume_bug:1; /* AMD remote wakeup quirk */
 
 	unsigned int		irq;		/* irq allocated */
 	void __iomem		*regs;		/* device memory/io */
@@ -435,6 +436,8 @@ extern int usb_hcd_pci_probe(struct pci_dev *dev,
 extern void usb_hcd_pci_remove(struct pci_dev *dev);
 extern void usb_hcd_pci_shutdown(struct pci_dev *dev);
 
+extern int usb_hcd_amd_remote_wakeup_quirk(struct pci_dev *dev);
+
 #ifdef CONFIG_PM
 extern const struct dev_pm_ops usb_hcd_pci_pm_ops;
 #endif

commit c7ccde6eac6d3c4bc6110cc3fd76ef3823bc0831
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Sep 3 13:58:43 2013 -0400

    USB: see if URB comes from a completion handler
    
    Now that URBs can be completed inside tasklets, we need a way of
    determining whether a completion handler for a given endpoint is
    currently running.  Otherwise it's not possible to maintain the API
    guarantee about keeping isochronous streams synchronous when an
    underrun occurs.
    
    This patch adds a field and a routine to check whether a completion
    handler for a periodic endpoint is running.  At the moment no
    analogous routine appears to be necessary for async endpoints, but one
    can always be added.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 75efc45eaa2f..8c865134c881 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -73,6 +73,7 @@ struct giveback_urb_bh {
 	spinlock_t lock;
 	struct list_head  head;
 	struct tasklet_struct bh;
+	struct usb_host_endpoint *completing_ep;
 };
 
 struct usb_hcd {
@@ -378,6 +379,12 @@ static inline int hcd_giveback_urb_in_bh(struct usb_hcd *hcd)
 	return hcd->driver->flags & HCD_BH;
 }
 
+static inline bool hcd_periodic_completion_in_progress(struct usb_hcd *hcd,
+		struct usb_host_endpoint *ep)
+{
+	return hcd->high_prio_bh.completing_ep == ep;
+}
+
 extern int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb);
 extern int usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,
 		int status);

commit 9d8924297cd9c256c23c02abae40202563452453
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Aug 30 10:46:00 2013 -0400

    USB: fix build error when CONFIG_PM_SLEEP isn't enabled
    
    This patch fixes a build error that occurs when CONFIG_PM is enabled
    and CONFIG_PM_SLEEP isn't:
    
    >> drivers/usb/host/ohci-pci.c:294:10: error: 'usb_hcd_pci_pm_ops' undeclared here (not in a function)
          .pm = &usb_hcd_pci_pm_ops
    
    Since the usb_hcd_pci_pm_ops structure is defined and used when
    CONFIG_PM is enabled, its declaration should not be protected by
    CONFIG_PM_SLEEP.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    CC: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index a9c7d44bd2ed..75efc45eaa2f 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -428,7 +428,7 @@ extern int usb_hcd_pci_probe(struct pci_dev *dev,
 extern void usb_hcd_pci_remove(struct pci_dev *dev);
 extern void usb_hcd_pci_shutdown(struct pci_dev *dev);
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM
 extern const struct dev_pm_ops usb_hcd_pci_pm_ops;
 #endif
 #endif /* CONFIG_PCI */

commit 94dfd7edfd5c9b605caf7b562de7a813d216e011
Author: Ming Lei <ming.lei@canonical.com>
Date:   Wed Jul 3 22:53:07 2013 +0800

    USB: HCD: support giveback of URB in tasklet context
    
    This patch implements the mechanism of giveback of URB in
    tasklet context, so that hardware interrupt handling time for
    usb host controller can be saved much, and HCD interrupt handling
    can be simplified.
    
    Motivations:
    
    1), on some arch(such as ARM), DMA mapping/unmapping is a bit
    time-consuming, for example: when accessing usb mass storage
    via EHCI on pandaboard, the common length of transfer buffer is 120KB,
    the time consumed on DMA unmapping may reach hundreds of microseconds;
    even on A15 based box, the time is still about scores of microseconds
    
    2), on some arch, reading DMA coherent memoery is very time-consuming,
    the most common example is usb video class driver[1]
    
    3), driver's complete() callback may do much things which is driver
    specific, so the time is consumed unnecessarily in hardware irq context.
    
    4), running driver's complete() callback in hardware irq context causes
    that host controller driver has to release its lock in interrupt handler,
    so reacquiring the lock after return may busy wait a while and increase
    interrupt handling time. More seriously, releasing the HCD lock makes
    HCD becoming quite complicated to deal with introduced races.
    
    So the patch proposes to run giveback of URB in tasklet context, then
    time consumed in HCD irq handling doesn't depend on drivers' complete and
    DMA mapping/unmapping any more, also we can simplify HCD since the HCD
    lock isn't needed to be released during irq handling.
    
    The patch should be reasonable and doable:
    
    1), for drivers, they don't care if the complete() is called in hard irq
    context or softirq context
    
    2), the biggest change is the situation in which usb_submit_urb() is called
    in complete() callback, so the introduced tasklet schedule delay might be a
    con, but it shouldn't be a big deal:
    
            - control/bulk asynchronous transfer isn't sensitive to schedule
              delay
    
            - the patch schedules giveback of periodic URBs using
              tasklet_hi_schedule, so the introduced delay should be very
              small
    
            - for ISOC transfer, generally, drivers submit several URBs
              concurrently to avoid interrupt delay, so it is OK with the
              little schedule delay.
    
            - for interrupt transfer, generally, drivers only submit one URB
              at the same time, but interrupt transfer is often used in event
              report, polling, ... situations, and a little delay should be OK.
    
    Considered that HCDs may optimize on submitting URB in complete(), the
    patch may cause the optimization not working, so introduces one flag to mark
    if the HCD supports to run giveback URB in tasklet context. When all HCDs
    are ready, the flag can be removed.
    
    [1], http://marc.info/?t=136438111600010&r=1&w=2
    
    Cc: Oliver Neukum <oliver@neukum.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 1e88377e22f4..a9c7d44bd2ed 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -22,6 +22,7 @@
 #ifdef __KERNEL__
 
 #include <linux/rwsem.h>
+#include <linux/interrupt.h>
 
 #define MAX_TOPO_LEVEL		6
 
@@ -67,6 +68,13 @@
 
 /*-------------------------------------------------------------------------*/
 
+struct giveback_urb_bh {
+	bool running;
+	spinlock_t lock;
+	struct list_head  head;
+	struct tasklet_struct bh;
+};
+
 struct usb_hcd {
 
 	/*
@@ -139,6 +147,9 @@ struct usb_hcd {
 	resource_size_t		rsrc_len;	/* memory/io resource length */
 	unsigned		power_budget;	/* in mA, 0 = no limit */
 
+	struct giveback_urb_bh  high_prio_bh;
+	struct giveback_urb_bh  low_prio_bh;
+
 	/* bandwidth_mutex should be taken before adding or removing
 	 * any new bus bandwidth constraints:
 	 *   1. Before adding a configuration for a new device.
@@ -221,6 +232,7 @@ struct hc_driver {
 #define	HCD_USB25	0x0030		/* Wireless USB 1.0 (USB 2.5)*/
 #define	HCD_USB3	0x0040		/* USB 3.0 */
 #define	HCD_MASK	0x0070
+#define	HCD_BH		0x0100		/* URB complete in BH context */
 
 	/* called to init HCD and root hub */
 	int	(*reset) (struct usb_hcd *hcd);
@@ -361,6 +373,11 @@ struct hc_driver {
 	int	(*find_raw_port_number)(struct usb_hcd *, int);
 };
 
+static inline int hcd_giveback_urb_in_bh(struct usb_hcd *hcd)
+{
+	return hcd->driver->flags & HCD_BH;
+}
+
 extern int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb);
 extern int usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,
 		int status);

commit 1a81f8814cbc79125fe50456de6adf048101af9b
Author: Thomas Pugliese <thomas.pugliese@gmail.com>
Date:   Fri May 31 14:16:13 2013 -0500

    Allow the USB HCD to create Wireless USB root hubs
    
    This patch adds Wireless USB root hub support to the USB HCD.  It allows
    the HWA to create its root hub which previously failed because the HCD
    treated wireless root hubs the same as USB2 high speed hubs.  The creation
    of the root hub would fail in that case due to lack of TTs which wireless
    root hubs do not support.
    
    Signed-off-by: Thomas Pugliese <thomas.pugliese@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index f5f5c7dfda90..1e88377e22f4 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -218,6 +218,7 @@ struct hc_driver {
 #define	HCD_SHARED	0x0004		/* Two (or more) usb_hcds share HW */
 #define	HCD_USB11	0x0010		/* USB 1.1 */
 #define	HCD_USB2	0x0020		/* USB 2.0 */
+#define	HCD_USB25	0x0030		/* Wireless USB 1.0 (USB 2.5)*/
 #define	HCD_USB3	0x0040		/* USB 3.0 */
 #define	HCD_MASK	0x0070
 

commit 84ebc10294a3d7be4c66f51070b7aedbaa24de9b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Mar 27 16:14:46 2013 -0400

    USB: remove CONFIG_USB_SUSPEND option
    
    This patch (as1675) removes the CONFIG_USB_SUSPEND option, essentially
    replacing it everywhere with CONFIG_PM_RUNTIME (except for one place
    in hub.c, where it is replaced with CONFIG_PM because the code needs
    to be used in both runtime and system PM).  The net result is code
    shrinkage and simplification.
    
    There's very little point in keeping CONFIG_USB_SUSPEND because almost
    everybody enables it.  The few that don't will find that the usbcore
    module has gotten somewhat bigger and they will have to take active
    measures if they want to prevent hubs from being runtime suspended.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 59694b5e5e90..f5f5c7dfda90 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -84,7 +84,7 @@ struct usb_hcd {
 
 	struct timer_list	rh_timer;	/* drives root-hub polling */
 	struct urb		*status_urb;	/* the current status urb */
-#ifdef CONFIG_USB_SUSPEND
+#ifdef CONFIG_PM_RUNTIME
 	struct work_struct	wakeup_work;	/* for remote wakeup */
 #endif
 
@@ -593,14 +593,14 @@ extern int hcd_bus_suspend(struct usb_device *rhdev, pm_message_t msg);
 extern int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg);
 #endif /* CONFIG_PM */
 
-#ifdef CONFIG_USB_SUSPEND
+#ifdef CONFIG_PM_RUNTIME
 extern void usb_hcd_resume_root_hub(struct usb_hcd *hcd);
 #else
 static inline void usb_hcd_resume_root_hub(struct usb_hcd *hcd)
 {
 	return;
 }
-#endif /* CONFIG_USB_SUSPEND */
+#endif /* CONFIG_PM_RUNTIME */
 
 /*-------------------------------------------------------------------------*/
 

commit 3f5eb14135ba9d97ba4b8514fc7ef5e0dac2abf4
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Tue Mar 19 16:48:12 2013 +0800

    usb: add find_raw_port_number callback to struct hc_driver()
    
    xhci driver divides the root hub into two logical hubs which work
    respectively for usb 2.0 and usb 3.0 devices. They are independent
    devices in the usb core. But in the ACPI table, it's one device node
    and all usb2.0 and usb3.0 ports are under it. Binding usb port with
    its acpi node needs the raw port number which is reflected in the xhci
    extended capabilities table. This patch is to add find_raw_port_number
    callback to struct hc_driver(), fill it with xhci_find_raw_port_number()
    which will return raw port number and add a wrap usb_hcd_find_raw_port_number().
    
    Otherwise, refactor xhci_find_real_port_number(). Using
    xhci_find_raw_port_number() to get real index in the HW port status
    registers instead of scanning through the xHCI roothub port array.
    This can help to speed up.
    
    All addresses in xhci->usb2_ports and xhci->usb3_ports array are
    kown good ports and don't include following bad ports in the extended
    capabilities talbe.
         (1) root port that doesn't have an entry
         (2) root port with unknown speed
         (3) root port that is listed twice and with different speeds.
    
    So xhci_find_raw_port_number() will only return port num of good ones
    and never touch bad ports above.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 0a78df5f6cfd..59694b5e5e90 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -357,6 +357,7 @@ struct hc_driver {
 		 */
 	int	(*disable_usb3_lpm_timeout)(struct usb_hcd *,
 			struct usb_device *, enum usb3_link_state state);
+	int	(*find_raw_port_number)(struct usb_hcd *, int);
 };
 
 extern int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb);
@@ -396,6 +397,7 @@ extern int usb_hcd_is_primary_hcd(struct usb_hcd *hcd);
 extern int usb_add_hcd(struct usb_hcd *hcd,
 		unsigned int irqnum, unsigned long irqflags);
 extern void usb_remove_hcd(struct usb_hcd *hcd);
+extern int usb_hcd_find_raw_port_number(struct usb_hcd *hcd, int port1);
 
 struct platform_device;
 extern void usb_hcd_platform_shutdown(struct platform_device *dev);

commit da0aa7169b97d90f4af39a9dc84d58bbe19d7e78
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jan 25 17:09:42 2013 -0500

    USB: add usb_hcd_{start,end}_port_resume
    
    This patch (as1649) adds a mechanism for host controller drivers to
    inform usbcore when they have begun or ended resume signalling on a
    particular root-hub port.  The core will then make sure that the root
    hub does not get runtime-suspended while the port resume is going on.
    
    Since commit 596d789a211d134dc5f94d1e5957248c204ef850 (USB: set hub's
    default autosuspend delay as 0), the system tries to suspend hubs
    whenever they aren't in use.  While a root-hub port is being resumed,
    the root hub does not appear to be in use.  Attempted runtime suspends
    fail because of the ongoing port resume, but the PM core just keeps on
    trying over and over again.  We want to prevent this wasteful effort.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 608050b2545f..0a78df5f6cfd 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -430,6 +430,9 @@ extern void usb_hcd_poll_rh_status(struct usb_hcd *hcd);
 extern void usb_wakeup_notification(struct usb_device *hdev,
 		unsigned int portnum);
 
+extern void usb_hcd_start_port_resume(struct usb_bus *bus, int portnum);
+extern void usb_hcd_end_port_resume(struct usb_bus *bus, int portnum);
+
 /* The D0/D1 toggle bits ... USE WITH CAUTION (they're almost hcd-internal) */
 #define usb_gettoggle(dev, ep, out) (((dev)->toggle[out] >> (ep)) & 1)
 #define	usb_dotoggle(dev, ep, out)  ((dev)->toggle[out] ^= (1 << (ep)))

commit 26f944b2716717aa243f16cd2181f80441153f0d
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Thu Aug 16 18:24:19 2012 +0530

    usb: hcd: use *resource_size_t* for specifying resource data
    
    Changed the type of rsrc_start and rsrc_len from u64 to resource_size_t
    so that it behaves well with resource API's like *resource_size()* on both
    32bit and 64bit devices.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index c5fdb148fc02..608050b2545f 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -135,8 +135,8 @@ struct usb_hcd {
 
 	unsigned int		irq;		/* irq allocated */
 	void __iomem		*regs;		/* device memory/io */
-	u64			rsrc_start;	/* memory/io resource start */
-	u64			rsrc_len;	/* memory/io resource length */
+	resource_size_t		rsrc_start;	/* memory/io resource start */
+	resource_size_t		rsrc_len;	/* memory/io resource length */
 	unsigned		power_budget;	/* in mA, 0 = no limit */
 
 	/* bandwidth_mutex should be taken before adding or removing

commit e17f8af316525c2a795bb314dfcc23201fb51ef4
Merge: a276400d14bb 0b84704a2d6f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jun 13 15:22:54 2012 -0700

    Merge branch 'usb-linus' into usb-next
    
    This is to pick up the changes to the option driver, which are needed
    for follow-on patches from Johan.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c2fb8a3fa25513de8fedb38509b1f15a5bbee47b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jun 13 11:20:19 2012 -0400

    USB: add NO_D3_DURING_SLEEP flag and revert 151b61284776be2
    
    This patch (as1558) fixes a problem affecting several ASUS computers:
    The machine crashes or corrupts memory when going into suspend if the
    ehci-hcd driver is bound to any controllers.  Users have been forced
    to unbind or unload ehci-hcd before putting their systems to sleep.
    
    After extensive testing, it was determined that the machines don't
    like going into suspend when any EHCI controllers are in the PCI D3
    power state.  Presumably this is a firmware bug, but there's nothing
    we can do about it except to avoid putting the controllers in D3
    during system sleep.
    
    The patch adds a new flag to indicate whether the problem is present,
    and avoids changing the controller's power state if the flag is set.
    Runtime suspend is unaffected; this matters only for system suspend.
    However as a side effect, the controller will not respond to remote
    wakeup requests while the system is asleep.  Hence USB wakeup is not
    functional -- but of course, this is already true in the current state
    of affairs.
    
    A similar patch has already been applied as commit
    151b61284776be2d6f02d48c23c3625678960b97 (USB: EHCI: fix crash during
    suspend on ASUS computers).  The patch supersedes that one and reverts
    it.  There are two differences:
    
            The old patch added the flag at the USB level; this patch
            adds it at the PCI level.
    
            The old patch applied to all chipsets with the same vendor,
            subsystem vendor, and product IDs; this patch makes an
            exception for a known-good system (based on DMI information).
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Dniel Fraga <fragabr@gmail.com>
    Tested-by: Andrey Rahmatullin <wrar@wrar.name>
    Tested-by: Steven Rostedt <rostedt@goodmis.org>
    Cc: stable <stable@vger.kernel.org>
    Reviewed-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 7f855d50cdf5..49b3ac29726a 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -126,8 +126,6 @@ struct usb_hcd {
 	unsigned		wireless:1;	/* Wireless USB HCD */
 	unsigned		authorized_default:1;
 	unsigned		has_tt:1;	/* Integrated TT in root hub */
-	unsigned		broken_pci_sleep:1;	/* Don't put the
-			controller in PCI-D3 for system sleep */
 
 	unsigned int		irq;		/* irq allocated */
 	void __iomem		*regs;		/* device memory/io */

commit c2e935a7db6e7354e9dd138b7f6f4c53affc09d9
Author: Richard Zhao <richard.zhao@freescale.com>
Date:   Wed Jun 13 20:34:12 2012 +0800

    USB: move transceiver from ehci_hcd and ohci_hcd to hcd and rename it as phy
    
     - to decrease redundant since both ehci_hcd and ohci_hcd have the same variable
     - it helps access phy in usb core code
     - phy is more meaningful than transceiver
    
    Signed-off-by: Richard Zhao <richard.zhao@freescale.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 7f855d50cdf5..c532cbeabfbc 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -93,6 +93,12 @@ struct usb_hcd {
 	 */
 	const struct hc_driver	*driver;	/* hw-specific hooks */
 
+	/*
+	 * OTG and some Host controllers need software interaction with phys;
+	 * other external phys should be software-transparent
+	 */
+	struct usb_phy	*phy;
+
 	/* Flags that need to be manipulated atomically because they can
 	 * change while the host controller is running.  Always use
 	 * set_bit() or clear_bit() to change their values.

commit 1ea7e0e8e3d0f50901d335ea4178ab2aa8c88201
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue Apr 24 17:21:50 2012 -0700

    USB: Add support to enable/disable USB3 link states.
    
    There are various functions within the USB core that will need to
    disable USB 3.0 link power states.  For example, when a USB device
    driver is being bound to an interface, we need to disable USB 3.0 LPM
    until we know if the driver will allow hub-initiated LPM transitions.
    Another example is when the USB core is switching alternate interface
    settings.  The USB 3.0 timeout values are dependent on what endpoints
    are enabled, so we want to ensure that LPM is disabled until the new alt
    setting is fully installed.
    
    Multiple functions need to disable LPM, and those functions can even be
    nested.  For example, usb_bind_interface() could disable LPM, and then
    call into the driver probe function, which may attempt to switch to a
    different alt setting.  Therefore, we need to keep a count of the number
    of functions that require LPM to be disabled at any point in time.
    
    Introduce two new USB core API calls, usb_disable_lpm() and
    usb_enable_lpm().  These functions increment and decrement a new
    variable in the usb_device, lpm_disable_count.  If usb_disable_lpm()
    fails, it will call usb_enable_lpm() in order to balance the
    lpm_disable_count.
    
    These two new functions must be called with the bandwidth_mutex locked.
    If the bandwidth_mutex is not already held by the caller, it should
    instead call usb_unlocked_disable_lpm() and usb_enable_lpm(), which take
    the bandwidth_mutex before calling usb_disable_lpm() and
    usb_enable_lpm(), respectively.
    
    Introduce a new variable (timeout) in the usb3_lpm_params structure to
    keep track of the currently enabled U1/U2 timeout values.  When
    usb_disable_lpm() is called, and the USB device has the U1 or U2
    timeouts set to a non-zero value (meaning either device-initiated or
    hub-initiated LPM is enabled), attempt to disable LPM, regardless of the
    state of the lpm_disable_count.  We want to ensure that all callers can
    be guaranteed that LPM is disabled if usb_disable_lpm() returns zero.
    
    Otherwise the following scenario could occur:
    
    1. Driver A is being bound to interface 1.  usb_probe_interface()
    disables LPM.  Driver A doesn't care if hub-initiated LPM is enabled, so
    even though usb_disable_lpm() fails, the probe of the driver continues,
    and the bandwidth mutex is dropped.
    
    2. Meanwhile, Driver B is being bound to interface 2.
    usb_probe_interface() grabs the bandwidth mutex and calls
    usb_disable_lpm().  That call should attempt to disable LPM, even
    though the lpm_disable_count is set to 1 by Driver A.
    
    For usb_enable_lpm(), we attempt to enable LPM only when the
    lpm_disable_count is zero.  If some step in enabling LPM fails, it will
    only have a minimal impact on power consumption, and all USB device
    drivers should still work properly.  Therefore don't bother to return
    any error codes.
    
    Don't enable device-initiated LPM if the device is unconfigured.  The
    USB device will only accept the U1/U2_ENABLE control transfers in the
    configured state.  Do enable hub-initiated LPM in that case, since
    devices are allowed to accept the LGO_Ux link commands in any state.
    
    Don't enable or disable LPM if the device is marked as not being LPM
    capable.  This can happen if:
     - the USB device doesn't have a SS BOS descriptor,
     - the device's parent hub has a zeroed bHeaderDecodeLatency value, or
     - the xHCI host doesn't support LPM.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Andiry Xu <andiry.xu@amd.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index bbb946437070..7f855d50cdf5 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -344,6 +344,15 @@ struct hc_driver {
 		 */
 	int	(*update_device)(struct usb_hcd *, struct usb_device *);
 	int	(*set_usb2_hw_lpm)(struct usb_hcd *, struct usb_device *, int);
+	/* USB 3.0 Link Power Management */
+		/* Returns the USB3 hub-encoded value for the U1/U2 timeout. */
+	int	(*enable_usb3_lpm_timeout)(struct usb_hcd *,
+			struct usb_device *, enum usb3_link_state state);
+		/* The xHCI host controller can still fail the command to
+		 * disable the LPM timeouts, so this can return an error code.
+		 */
+	int	(*disable_usb3_lpm_timeout)(struct usb_hcd *,
+			struct usb_device *, enum usb3_link_state state);
 };
 
 extern int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb);

commit 61906313bd41cde2f9aaa14e461e6108d3e71aaa
Merge: 3aa2ae74ba63 d48b97b403d2
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 7 09:03:39 2012 -0700

    Merge 3.4-rc6 into usb-next
    
    This resolves the conflict with:
            drivers/usb/host/ehci-tegra.c
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fb28d58b72aa9215b26f1d5478462af394a4d253
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Apr 25 17:15:29 2012 -0700

    USB: remove CONFIG_USB_DEVICEFS
    
    This option has been deprecated for many years now, and no userspace
    tools use it anymore, so it should be safe to finally remove it.
    
    Reported-by: Kay Sievers <kay@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 5de415707c23..159a08a4a78e 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -582,29 +582,6 @@ static inline void usb_hcd_resume_root_hub(struct usb_hcd *hcd)
 }
 #endif /* CONFIG_USB_SUSPEND */
 
-
-/*
- * USB device fs stuff
- */
-
-#ifdef CONFIG_USB_DEVICEFS
-
-/*
- * these are expected to be called from the USB core/hub thread
- * with the kernel lock held
- */
-extern void usbfs_update_special(void);
-extern int usbfs_init(void);
-extern void usbfs_cleanup(void);
-
-#else /* CONFIG_USB_DEVICEFS */
-
-static inline void usbfs_update_special(void) {}
-static inline int usbfs_init(void) { return 0; }
-static inline void usbfs_cleanup(void) { }
-
-#endif /* CONFIG_USB_DEVICEFS */
-
 /*-------------------------------------------------------------------------*/
 
 #if defined(CONFIG_USB_MON) || defined(CONFIG_USB_MON_MODULE)

commit 151b61284776be2d6f02d48c23c3625678960b97
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Apr 24 14:07:22 2012 -0400

    USB: EHCI: fix crash during suspend on ASUS computers
    
    This patch (as1545) fixes a problem affecting several ASUS computers:
    The machine crashes or corrupts memory when going into suspend if the
    ehci-hcd driver is bound to any controllers.  Users have been forced
    to unbind or unload ehci-hcd before putting their systems to sleep.
    
    After extensive testing, it was determined that the machines don't
    like going into suspend when any EHCI controllers are in the PCI D3
    power state.  Presumably this is a firmware bug, but there's nothing
    we can do about it except to avoid putting the controllers in D3
    during system sleep.
    
    The patch adds a new flag to indicate whether the problem is present,
    and avoids changing the controller's power state if the flag is set.
    Runtime suspend is unaffected; this matters only for system suspend.
    However as a side effect, the controller will not respond to remote
    wakeup requests while the system is asleep.  Hence USB wakeup is not
    functional -- but of course, this is already true in the current state
    of affairs.
    
    This fixes Bugzilla #42728.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Steven Rostedt <rostedt@goodmis.org>
    Tested-by: Andrey Rahmatullin <wrar@wrar.name>
    Tested-by: Oleksij Rempel (fishor) <bug-track@fisher-privat.net>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 5de415707c23..d28cc78a38e4 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -126,6 +126,8 @@ struct usb_hcd {
 	unsigned		wireless:1;	/* Wireless USB HCD */
 	unsigned		authorized_default:1;
 	unsigned		has_tt:1;	/* Integrated TT in root hub */
+	unsigned		broken_pci_sleep:1;	/* Don't put the
+			controller in PCI-D3 for system sleep */
 
 	unsigned int		irq;		/* irq allocated */
 	void __iomem		*regs;		/* device memory/io */

commit cd70469d084fde198dc07c1a31b8463562228a5a
Author: Felipe Balbi <balbi@ti.com>
Date:   Wed Feb 29 16:46:23 2012 +0200

    usb: core: hcd: make hcd->irq unsigned
    
    There's really no point in having hcd->irq as a
    signed integer when we consider the fact that
    IRQ 0 means NO_IRQ. In order to avoid confusion,
    make hcd->irq unsigned and fix users who were
    passing -1 as the IRQ number to usb_add_hcd.
    
    Tested-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 2e6071efbfb7..5de415707c23 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -127,7 +127,7 @@ struct usb_hcd {
 	unsigned		authorized_default:1;
 	unsigned		has_tt:1;	/* Integrated TT in root hub */
 
-	int			irq;		/* irq allocated */
+	unsigned int		irq;		/* irq allocated */
 	void __iomem		*regs;		/* device memory/io */
 	u64			rsrc_start;	/* memory/io resource start */
 	u64			rsrc_len;	/* memory/io resource length */

commit 4ee823b83bc9851743fab756c76b27d6a1e2472b
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Nov 14 18:00:01 2011 -0800

    USB/xHCI: Support device-initiated USB 3.0 resume.
    
    USB 3.0 hubs don't have a port suspend change bit (that bit is now
    reserved).  Instead, when a host-initiated resume finishes, the hub sets
    the port link state change bit.
    
    When a USB 3.0 device initiates remote wakeup, the parent hubs with
    their upstream links in U3 will pass the LFPS up the chain.  The first
    hub that has an upstream link in U0 (which may be the roothub) will
    reflect that LFPS back down the path to the device.
    
    However, the parent hubs in the resumed path will not set their link
    state change bit.  Instead, the device that initiated the resume has to
    send an asynchronous "Function Wake" Device Notification up to the host
    controller.  Therefore, we need a way to notify the USB core of a device
    resume without going through the normal hub URB completion method.
    
    First, make the xHCI roothub act like an external USB 3.0 hub and not
    pass up the port link state change bit when a device-initiated resume
    finishes.  Introduce a new xHCI bit field, port_remote_wakeup, so that
    we can tell the difference between a port coming out of the U3Exit state
    (host-initiated resume) and the RExit state (ending state of
    device-initiated resume).
    
    Since the USB core can't tell whether a port on a hub has resumed by
    looking at the Hub Status buffer, we need to introduce a bitfield,
    wakeup_bits, that indicates which ports have resumed.  When the xHCI
    driver notices a port finishing a device-initiated resume, we call into
    a new USB core function, usb_wakeup_notification(), that will set
    the right bit in wakeup_bits, and kick khubd for that hub.
    
    We also call usb_wakeup_notification() when the Function Wake Device
    Notification is received by the xHCI driver.  This covers the case where
    the link between the roothub and the first-tier hub is in U0, and the
    hub reflects the resume signaling back to the device without giving any
    indication it has done so until the device sends the Function Wake
    notification.
    
    Change the code in khubd that handles the remote wakeup to look at the
    state the USB core thinks the device is in, and handle the remote wakeup
    if the port's wakeup bit is set.
    
    This patch only takes care of the case where the device is attached
    directly to the roothub, or the USB 3.0 hub that is attached to the root
    hub is the device sending the Function Wake Device Notification (e.g.
    because a new USB device was attached).  The other cases will be covered
    in a second patch.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index b2f62f3a32af..2e6071efbfb7 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -412,6 +412,8 @@ extern irqreturn_t usb_hcd_irq(int irq, void *__hcd);
 
 extern void usb_hc_died(struct usb_hcd *hcd);
 extern void usb_hcd_poll_rh_status(struct usb_hcd *hcd);
+extern void usb_wakeup_notification(struct usb_device *hdev,
+		unsigned int portnum);
 
 /* The D0/D1 toggle bits ... USE WITH CAUTION (they're almost hcd-internal) */
 #define usb_gettoggle(dev, ep, out) (((dev)->toggle[out] >> (ep)) & 1)

commit 968b822c0023861ef6e4e15bb68582b36e89ad29
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Nov 3 12:03:38 2011 -0400

    USB: Remove the SAW_IRQ hcd flag
    
    The HCD_FLAG_SAW_IRQ flag was introduced in order to catch IRQ routing
    errors: If an URB was unlinked and the host controller hadn't gotten
    any IRQs, it seemed likely that the IRQs were directed to the wrong
    vector.
    
    This warning hasn't come up in many years, as far as I know; interrupt
    routing now seems to be well under control.  Therefore there's no
    reason to keep the flag around any more.  This patch (as1495) finally
    removes it.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 03354d557b79..b2f62f3a32af 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -99,7 +99,6 @@ struct usb_hcd {
 	 */
 	unsigned long		flags;
 #define HCD_FLAG_HW_ACCESSIBLE		0	/* at full power */
-#define HCD_FLAG_SAW_IRQ		1
 #define HCD_FLAG_POLL_RH		2	/* poll for rh status? */
 #define HCD_FLAG_POLL_PENDING		3	/* status has changed? */
 #define HCD_FLAG_WAKEUP_PENDING		4	/* root hub is resuming? */
@@ -110,7 +109,6 @@ struct usb_hcd {
 	 * be slightly faster than test_bit().
 	 */
 #define HCD_HW_ACCESSIBLE(hcd)	((hcd)->flags & (1U << HCD_FLAG_HW_ACCESSIBLE))
-#define HCD_SAW_IRQ(hcd)	((hcd)->flags & (1U << HCD_FLAG_SAW_IRQ))
 #define HCD_POLL_RH(hcd)	((hcd)->flags & (1U << HCD_FLAG_POLL_RH))
 #define HCD_POLL_PENDING(hcd)	((hcd)->flags & (1U << HCD_FLAG_POLL_PENDING))
 #define HCD_WAKEUP_PENDING(hcd)	((hcd)->flags & (1U << HCD_FLAG_WAKEUP_PENDING))

commit 276532ba9666b36974cbe16f303fc8be99c9da17
Author: Harro Haan <hrhaan@gmail.com>
Date:   Mon Oct 10 14:38:27 2011 +0200

    USB: fix ehci alignment error
    
    The Kirkwood gave an unaligned memory access error on
    line 742 of drivers/usb/host/echi-hcd.c:
    "ehci->last_periodic_enable = ktime_get_real();"
    
    Signed-off-by: Harro Haan <hrhaan@gmail.com>
    Cc: stable <stable@kernel.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index a4cd6c58870a..03354d557b79 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -178,7 +178,7 @@ struct usb_hcd {
 	 * this structure.
 	 */
 	unsigned long hcd_priv[0]
-			__attribute__ ((aligned(sizeof(unsigned long))));
+			__attribute__ ((aligned(sizeof(s64))));
 };
 
 /* 2.4 does this a bit differently ... */

commit 65580b4321eb36f16ae8b5987bfa1bb948fc5112
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Fri Sep 23 14:19:52 2011 -0700

    xHCI: set USB2 hardware LPM
    
    If the device pass the USB2 software LPM and the host supports hardware
    LPM, enable hardware LPM for the device to let the host decide when to
    put the link into lower power state.
    
    If hardware LPM is enabled for a port and driver wants to put it into
    suspend, it must first disable hardware LPM, resume the port into U0,
    and then suspend the port.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 0097136ba45d..a4cd6c58870a 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -343,6 +343,7 @@ struct hc_driver {
 		 * address is set
 		 */
 	int	(*update_device)(struct usb_hcd *, struct usb_device *);
+	int	(*set_usb2_hw_lpm)(struct usb_hcd *, struct usb_device *, int);
 };
 
 extern int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb);

commit c56354378426e550aaf6ddf3983f502a8fddeab5
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Oct 28 15:40:26 2010 -0700

    usb: Make core allocate resources per PCI-device.
    
    Introduce the notion of a PCI device that may be associated with more than
    one USB host controller driver (struct usb_hcd).  This patch is the start
    of the work to separate the xHCI host controller into two roothubs: a USB
    3.0 roothub with SuperSpeed-only ports, and a USB 2.0 roothub with
    HS/FS/LS ports.
    
    One usb_hcd structure is designated to be the "primary HCD", and a pointer
    is added to the usb_hcd structure to keep track of that.  A new function
    call, usb_hcd_is_primary_hcd() is added to check whether the USB hcd is
    marked as the primary HCD (or if it is not part of a roothub pair).  To
    allow the USB core and xHCI driver to access either roothub in a pair, a
    "shared_hcd" pointer is added to the usb_hcd structure.
    
    Add a new function, usb_create_shared_hcd(), that does roothub allocation
    for paired roothubs.  It will act just like usb_create_hcd() did if the
    primary_hcd pointer argument is NULL.  If it is passed a non-NULL
    primary_hcd pointer, it sets usb_hcd->shared_hcd and usb_hcd->primary_hcd
    fields.  It will also skip the bandwidth_mutex allocation, and set the
    secondary hcd's bandwidth_mutex pointer to the primary HCD's mutex.
    
    IRQs are only allocated once for the primary roothub.
    
    Introduce a new usb_hcd driver flag that indicates the host controller
    driver wants to create two roothubs.  If the HCD_SHARED flag is set, then
    the USB core PCI probe methods will allocate a second roothub, and make
    sure that second roothub gets freed during rmmod and in initialization
    error paths.
    
    When usb_hc_died() is called with the primary HCD, make sure that any
    roothubs that share that host controller are also marked as being dead.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index b8bb6934f30b..0097136ba45d 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -147,6 +147,8 @@ struct usb_hcd {
 	 * to the device, or resetting the bandwidth after a failed attempt.
 	 */
 	struct mutex		*bandwidth_mutex;
+	struct usb_hcd		*shared_hcd;
+	struct usb_hcd		*primary_hcd;
 
 
 #define HCD_BUFFER_POOLS	4
@@ -209,6 +211,7 @@ struct hc_driver {
 	int	flags;
 #define	HCD_MEMORY	0x0001		/* HC regs use memory (else I/O) */
 #define	HCD_LOCAL_MEM	0x0002		/* HC needs local memory */
+#define	HCD_SHARED	0x0004		/* Two (or more) usb_hcds share HW */
 #define	HCD_USB11	0x0010		/* USB 1.1 */
 #define	HCD_USB2	0x0020		/* USB 2.0 */
 #define	HCD_USB3	0x0040		/* USB 3.0 */
@@ -370,8 +373,12 @@ extern int usb_hcd_get_frame_number(struct usb_device *udev);
 
 extern struct usb_hcd *usb_create_hcd(const struct hc_driver *driver,
 		struct device *dev, const char *bus_name);
+extern struct usb_hcd *usb_create_shared_hcd(const struct hc_driver *driver,
+		struct device *dev, const char *bus_name,
+		struct usb_hcd *shared_hcd);
 extern struct usb_hcd *usb_get_hcd(struct usb_hcd *hcd);
 extern void usb_put_hcd(struct usb_hcd *hcd);
+extern int usb_hcd_is_primary_hcd(struct usb_hcd *hcd);
 extern int usb_add_hcd(struct usb_hcd *hcd,
 		unsigned int irqnum, unsigned long irqflags);
 extern void usb_remove_hcd(struct usb_hcd *hcd);

commit 83de4b2b90887b5b317d8313864fe4cc5db35280
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Dec 2 14:45:18 2010 -0800

    usb: Store bus type in usb_hcd, not in driver flags.
    
    The xHCI driver essentially has both a USB 2.0 and a USB 3.0 roothub.  So
    setting the HCD_USB3 bits in the hcd->driver->flags is a bit misleading.
    Add a new field to usb_hcd, bcdUSB.  Store the result of
    hcd->driver->flags & HCD_MASK in it.  Later, when we have the xHCI driver
    register the two roothubs, we'll set the usb_hcd->bcdUSB field to HCD_USB2
    for the USB 2.0 roothub, and HCD_USB3 for the USB 3.0 roothub.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 836aaa91ee15..b8bb6934f30b 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -76,6 +76,10 @@ struct usb_hcd {
 	struct kref		kref;		/* reference counter */
 
 	const char		*product_desc;	/* product/vendor string */
+	int			speed;		/* Speed for this roothub.
+						 * May be different from
+						 * hcd->driver->flags & HCD_MASK
+						 */
 	char			irq_descr[24];	/* driver + bus # */
 
 	struct timer_list	rh_timer;	/* drives root-hub polling */

commit d673bfcbfffdeb56064a6b1ee047b85590bed76c
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Oct 15 08:55:24 2010 -0700

    usb: Change usb_hcd->bandwidth_mutex to a pointer.
    
    Change the bandwith_mutex in struct usb_hcd to a pointer.  This will allow
    the pointer to be shared across usb_hcds for the upcoming work to split
    the xHCI driver roothub into a USB 2.0/1.1 and a USB 3.0 bus.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 0be61970074e..836aaa91ee15 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -142,7 +142,7 @@ struct usb_hcd {
 	 * bandwidth_mutex should be dropped after a successful control message
 	 * to the device, or resetting the bandwidth after a failed attempt.
 	 */
-	struct mutex		bandwidth_mutex;
+	struct mutex		*bandwidth_mutex;
 
 
 #define HCD_BUFFER_POOLS	4

commit da13051cc756756f10b2da8ea97b05bdf84bd7bb
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue Nov 30 15:55:51 2010 -0800

    USB: Remove bitmap #define from hcd.h
    
    Using a #define to redefine a common variable name is a bad thing,
    especially when the #define is in a header.  include/linux/usb/hcd.h
    redefined bitmap to DeviceRemovable to avoid typing a long field in the
    hub descriptor.  This has unintended side effects for files like
    drivers/usb/core/devio.c that include that file, since another header
    included after hcd.h has different variables named bitmap.
    
    Remove the bitmap #define and replace instances of it in the host
    controller code.  Cleanup the spaces around function calls and square
    brackets while we're at it.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Nobuhiro Iwamatsu <nobuhiro.iwamatsu.yj@renesas.com>
    Cc: Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>
    Cc: Tony Olech <tony.olech@elandigitalsystems.com>
    Cc: "Robert P. J. Day" <rpjday@crashcourse.ca>
    Cc: Max Vozeler <mvz@vozeler.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Cc: Rodolfo Giometti <giometti@linux.it>
    Cc: Mike Frysinger <vapier@gentoo.org>
    Cc: Anton Vorontsov <avorontsov@mvista.com>
    Cc: Sebastian Siewior <bigeasy@linutronix.de>
    Cc: Lothar Wassmann <LW@KARO-electronics.de>
    Cc: Olav Kongas <ok@artecdesign.ee>
    Cc: Martin Fuzzey <mfuzzey@gmail.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: David Brownell <dbrownell@users.sourceforge.net>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 8b65068c6af9..0be61970074e 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -639,13 +639,6 @@ static inline void usbmon_urb_complete(struct usb_bus *bus, struct urb *urb,
 
 #endif /* CONFIG_USB_MON || CONFIG_USB_MON_MODULE */
 
-/*-------------------------------------------------------------------------*/
-
-/* hub.h ... DeviceRemovable in 2.4.2-ac11, gone in 2.4.10 */
-/* bleech -- resurfaced in 2.4.11 or 2.4.12 */
-#define bitmap	DeviceRemovable
-
-
 /*-------------------------------------------------------------------------*/
 
 /* random stuff */

commit 9b37596a2e860404503a3f2a6513db60c296bfdc
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Mar 7 11:11:52 2011 -0500

    USB: move usbcore away from hcd->state
    
    The hcd->state variable is a disaster.  It's not clearly owned by
    either usbcore or the host controller drivers, and they both change it
    from time to time, potentially stepping on each other's toes.  It's
    not protected by any locks.  And there's no mechanism to prevent it
    from going through an invalid transition.
    
    This patch (as1451) takes a first step toward fixing these problems.
    As it turns out, usbcore uses hcd->state for essentially only two
    things: checking whether the controller's root hub is running and
    checking whether the controller has died.  Therefore the patch adds
    two new atomic bitflags to the hcd structure, to store these pieces of
    information.  The new flags are used only by usbcore, and a private
    spinlock prevents invalid combinations (a dead controller's root hub
    cannot be running).
    
    The patch does not change the places where usbcore sets hcd->state,
    since HCDs may depend on them.  Furthermore, there is one place in
    usb_hcd_irq() where usbcore still must use hcd->state: An HCD's
    interrupt handler can implicitly indicate that the controller died by
    setting hcd->state to HC_STATE_HALT.  Nevertheless, the new code is a
    big improvement over the current code.
    
    The patch makes one other change.  The hcd_bus_suspend() and
    hcd_bus_resume() routines now check first whether the host controller
    has died; if it has then they return immediately without calling the
    HCD's bus_suspend or bus_resume methods.
    
    This fixes the major problem reported in Bugzilla #29902: The system
    fails to suspend after a host controller dies during system resume.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Alex Terekhov <a.terekhov@gmail.com>
    CC: <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 9cfba4f2457b..8b65068c6af9 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -99,6 +99,8 @@ struct usb_hcd {
 #define HCD_FLAG_POLL_RH		2	/* poll for rh status? */
 #define HCD_FLAG_POLL_PENDING		3	/* status has changed? */
 #define HCD_FLAG_WAKEUP_PENDING		4	/* root hub is resuming? */
+#define HCD_FLAG_RH_RUNNING		5	/* root hub is running? */
+#define HCD_FLAG_DEAD			6	/* controller has died? */
 
 	/* The flags can be tested using these macros; they are likely to
 	 * be slightly faster than test_bit().
@@ -108,6 +110,8 @@ struct usb_hcd {
 #define HCD_POLL_RH(hcd)	((hcd)->flags & (1U << HCD_FLAG_POLL_RH))
 #define HCD_POLL_PENDING(hcd)	((hcd)->flags & (1U << HCD_FLAG_POLL_PENDING))
 #define HCD_WAKEUP_PENDING(hcd)	((hcd)->flags & (1U << HCD_FLAG_WAKEUP_PENDING))
+#define HCD_RH_RUNNING(hcd)	((hcd)->flags & (1U << HCD_FLAG_RH_RUNNING))
+#define HCD_DEAD(hcd)		((hcd)->flags & (1U << HCD_FLAG_DEAD))
 
 	/* Flags that get set only during HCD registration or removal. */
 	unsigned		rh_registered:1;/* is root hub registered? */

commit 66b0835e2bb3d345f060a47bb8c8f883bd25ec2b
Merge: 479b46b5599b 85e2efbb1db9
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Feb 17 09:56:40 2011 -0800

    Merge 2.6.38-rc5 into usb-next
    
    This is needed to resolve some merge conflicts that were found
    in the USB host controller patches, and reported by Stephen Rothwell.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 2694a48d9007a8bdf1731c1b97d4942c9cc49296
Author: Robert Morell <rmorell@nvidia.com>
Date:   Wed Jan 26 19:06:48 2011 -0800

    USB: HCD: Add driver hooks for (un)?map_urb_for_dma
    
    Provide optional hooks for the host controller driver to override the
    default DMA mapping and unmapping routines.  In general, these shouldn't
    be necessary unless the host controller has special DMA requirements,
    such as alignment contraints.  If these are not specified, the
    general usb_hcd_(un)?map_urb_for_dma functions will be used instead.
    Also, pass the status to unmap_urb_for_dma so it can know whether the
    DMA buffer has been overwritten.
    
    Finally, add a flag to be used by these implementations if they
    allocated a temporary buffer so it can be freed properly when unmapping.
    
    Signed-off-by: Robert Morell <rmorell@nvidia.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 395704bdf5cc..92b96fe39307 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -233,6 +233,19 @@ struct hc_driver {
 	int	(*urb_dequeue)(struct usb_hcd *hcd,
 				struct urb *urb, int status);
 
+	/*
+	 * (optional) these hooks allow an HCD to override the default DMA
+	 * mapping and unmapping routines.  In general, they shouldn't be
+	 * necessary unless the host controller has special DMA requirements,
+	 * such as alignment contraints.  If these are not specified, the
+	 * general usb_hcd_(un)?map_urb_for_dma functions will be used instead
+	 * (and it may be a good idea to call these functions in your HCD
+	 * implementation)
+	 */
+	int	(*map_urb_for_dma)(struct usb_hcd *hcd, struct urb *urb,
+				   gfp_t mem_flags);
+	void    (*unmap_urb_for_dma)(struct usb_hcd *hcd, struct urb *urb);
+
 	/* hw synch, freeing endpoint resources that urb_dequeue can't */
 	void	(*endpoint_disable)(struct usb_hcd *hcd,
 			struct usb_host_endpoint *ep);
@@ -329,6 +342,8 @@ extern int usb_hcd_submit_urb(struct urb *urb, gfp_t mem_flags);
 extern int usb_hcd_unlink_urb(struct urb *urb, int status);
 extern void usb_hcd_giveback_urb(struct usb_hcd *hcd, struct urb *urb,
 		int status);
+extern int usb_hcd_map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,
+		gfp_t mem_flags);
 extern void usb_hcd_unmap_urb_setup_for_dma(struct usb_hcd *, struct urb *);
 extern void usb_hcd_unmap_urb_for_dma(struct usb_hcd *, struct urb *);
 extern void usb_hcd_flush_endpoint(struct usb_device *udev,

commit c8cf203a1d228fa001b95534f639ffb7a23d5386
Author: Robert Morell <rmorell@nvidia.com>
Date:   Wed Jan 26 19:06:47 2011 -0800

    USB: HCD: Add usb_hcd prefix to exported functions
    
    The convention is to prefix symbols exported from the USB HCD core with
    "usb_hcd".  This change makes unmap_urb_setup_for_dma() and
    unmap_urb_for_dma() consistent with that.
    
    Signed-off-by: Robert Morell <rmorell@nvidia.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index dd6ee49a0844..395704bdf5cc 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -329,8 +329,8 @@ extern int usb_hcd_submit_urb(struct urb *urb, gfp_t mem_flags);
 extern int usb_hcd_unlink_urb(struct urb *urb, int status);
 extern void usb_hcd_giveback_urb(struct usb_hcd *hcd, struct urb *urb,
 		int status);
-extern void unmap_urb_setup_for_dma(struct usb_hcd *, struct urb *);
-extern void unmap_urb_for_dma(struct usb_hcd *, struct urb *);
+extern void usb_hcd_unmap_urb_setup_for_dma(struct usb_hcd *, struct urb *);
+extern void usb_hcd_unmap_urb_for_dma(struct usb_hcd *, struct urb *);
 extern void usb_hcd_flush_endpoint(struct usb_device *udev,
 		struct usb_host_endpoint *ep);
 extern void usb_hcd_disable_endpoint(struct usb_device *udev,

commit 0029227f1bc30b6c809ae751f9e7af6cef900997
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Mon Dec 27 17:39:02 2010 +0800

    xHCI: synchronize irq in xhci_suspend()
    
    Synchronize the interrupts instead of free them in xhci_suspend(). This will
    prevent a double free when the host is suspended and then the card removed.
    
    Set the flag hcd->msix_enabled when using MSI-X, and check the flag in
    suspend_common(). MSI-X synchronization will be handled by xhci_suspend(),
    and MSI/INTx will be synchronized in suspend_common().
    
    This patch should be queued for the 2.6.37 stable tree.
    
    Reported-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@kernel.org

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index dd6ee49a0844..a854fe89484e 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -112,6 +112,7 @@ struct usb_hcd {
 	/* Flags that get set only during HCD registration or removal. */
 	unsigned		rh_registered:1;/* is root hub registered? */
 	unsigned		rh_pollable:1;	/* may we poll the root hub? */
+	unsigned		msix_enabled:1;	/* driver has MSI-X enabled? */
 
 	/* The next flag is a stopgap, to be removed when all the HCDs
 	 * support the new root-hub polling mechanism. */

commit 0eadcc09203349b11ca477ec367079b23d32ab91
Author: Tatyana Brokhman <tlinder@codeaurora.org>
Date:   Mon Nov 1 18:18:24 2010 +0200

    usb: USB3.0 ch11 definitions
    
    Adding hub SuperSpeed usb definitions as defined by ch10 of the USB3.0
    spec.
    
    Signed-off-by: Tatyana Brokhman <tlinder@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 0b6e751ea0b1..dd6ee49a0844 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -471,6 +471,10 @@ extern void usb_ep0_reinit(struct usb_device *);
 
 /*-------------------------------------------------------------------------*/
 
+/* class requests from USB 3.0 hub spec, table 10-5 */
+#define SetHubDepth		(0x3000 | HUB_SET_DEPTH)
+#define GetPortErrorCount	(0x8000 | HUB_GET_PORT_ERR_COUNT)
+
 /*
  * Generic bandwidth allocation constants/support
  */

commit 1dae423dd9b247b048eda00cb598c755e5933213
Author: Martin Fuzzey <mfuzzey@gmail.com>
Date:   Fri Oct 1 00:21:55 2010 +0200

    USB: introduce unmap_urb_setup_for_dma()
    
    Split unmap_urb_for_dma() to allow just the setup buffer
    to be unmapped. This allows HCDs to use PIO for the setup
    buffer if it is not suitable for DMA.
    
    Signed-off-by: Martin Fuzzey <mfuzzey@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index fe89f7c298aa..0b6e751ea0b1 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -329,6 +329,7 @@ extern int usb_hcd_submit_urb(struct urb *urb, gfp_t mem_flags);
 extern int usb_hcd_unlink_urb(struct urb *urb, int status);
 extern void usb_hcd_giveback_urb(struct usb_hcd *hcd, struct urb *urb,
 		int status);
+extern void unmap_urb_setup_for_dma(struct usb_hcd *, struct urb *);
 extern void unmap_urb_for_dma(struct usb_hcd *, struct urb *);
 extern void usb_hcd_flush_endpoint(struct usb_device *udev,
 		struct usb_host_endpoint *ep);

commit 496dda704bca1208e08773ba39b29a69536f5381
Author: Maulik Mankad <x0082077@ti.com>
Date:   Fri Sep 24 13:44:06 2010 +0300

    usb: musb: host: unmap the buffer for PIO data transfers
    
    The USB stack maps the buffer for DMA if the controller supports DMA.
    MUSB controller can perform DMA as well as PIO transfers.
    The buffer needs to be unmapped before CPU can perform
    PIO data transfers.
    
    Export unmap_urb_for_dma() so that drivers can perform
    the DMA unmapping in a sane way.
    
    Signed-off-by: Maulik Mankad <x0082077@ti.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 3b571f1ffbb3..fe89f7c298aa 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -329,6 +329,7 @@ extern int usb_hcd_submit_urb(struct urb *urb, gfp_t mem_flags);
 extern int usb_hcd_unlink_urb(struct urb *urb, int status);
 extern void usb_hcd_giveback_urb(struct usb_hcd *hcd, struct urb *urb,
 		int status);
+extern void unmap_urb_for_dma(struct usb_hcd *, struct urb *);
 extern void usb_hcd_flush_endpoint(struct usb_device *udev,
 		struct usb_host_endpoint *ep);
 extern void usb_hcd_disable_endpoint(struct usb_device *udev,

commit ff2f07874362d34684296f2bd5547a099f33c6d4
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jun 25 14:02:35 2010 -0400

    USB: fix race between root-hub wakeup & controller suspend
    
    This patch (as1395) adds code to hcd_pci_suspend() for handling wakeup
    races.  This is another general race pattern, similar to the "open
    vs. unregister" race we're all familiar with.  Here, the race is
    between suspending a device and receiving a wakeup request from one of
    the device's suspended children.
    
    In particular, if a root-hub wakeup is requested at about the same
    time as the corresponding USB controller is suspended, and if the
    controller is enabled for wakeup, then the controller should either
    fail to suspend or else wake right back up again.
    
    During system sleep this won't happen very much, especially since host
    controllers generally aren't enabled for wakeup during sleep.  However
    it is definitely an issue for runtime PM.  Something like this will be
    needed to prevent the controller from autosuspending while waiting for
    a root-hub resume to take place.  (That is, in fact, the common case,
    for which there is an extra test.)
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index ae10020b4023..3b571f1ffbb3 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -98,6 +98,7 @@ struct usb_hcd {
 #define HCD_FLAG_SAW_IRQ		1
 #define HCD_FLAG_POLL_RH		2	/* poll for rh status? */
 #define HCD_FLAG_POLL_PENDING		3	/* status has changed? */
+#define HCD_FLAG_WAKEUP_PENDING		4	/* root hub is resuming? */
 
 	/* The flags can be tested using these macros; they are likely to
 	 * be slightly faster than test_bit().
@@ -106,6 +107,7 @@ struct usb_hcd {
 #define HCD_SAW_IRQ(hcd)	((hcd)->flags & (1U << HCD_FLAG_SAW_IRQ))
 #define HCD_POLL_RH(hcd)	((hcd)->flags & (1U << HCD_FLAG_POLL_RH))
 #define HCD_POLL_PENDING(hcd)	((hcd)->flags & (1U << HCD_FLAG_POLL_PENDING))
+#define HCD_WAKEUP_PENDING(hcd)	((hcd)->flags & (1U << HCD_FLAG_WAKEUP_PENDING))
 
 	/* Flags that get set only during HCD registration or removal. */
 	unsigned		rh_registered:1;/* is root hub registered? */

commit 4147200d25c423e627ab4487530b3d9f2ef829c8
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jun 25 14:02:14 2010 -0400

    USB: add do_wakeup parameter for PCI HCD suspend
    
    This patch (as1385) adds a "do_wakeup" parameter to the pci_suspend
    method used by PCI-based host controller drivers.  ehci-hcd in
    particular needs to know whether or not to enable wakeup when
    suspending a controller.  Although that information is currently
    available through device_may_wakeup(), when support is added for
    runtime suspend this will no longer be true.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index f8f8fa7a56e8..ae10020b4023 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -211,7 +211,7 @@ struct hc_driver {
 	 * a whole, not just the root hub; they're for PCI bus glue.
 	 */
 	/* called after suspending the hub, before entering D3 etc */
-	int	(*pci_suspend)(struct usb_hcd *hcd);
+	int	(*pci_suspend)(struct usb_hcd *hcd, bool do_wakeup);
 
 	/* called after entering D0 (etc), before resuming the hub */
 	int	(*pci_resume)(struct usb_hcd *hcd, bool hibernated);

commit 541c7d432f76771079e7c295d596ea47cc6a3030
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jun 22 16:39:10 2010 -0400

    USB: convert usb_hcd bitfields into atomic flags
    
    This patch (as1393) converts several of the single-bit fields in
    struct usb_hcd to atomic flags.  This is for safety's sake; not all
    CPUs can update bitfield values atomically, and these flags are used
    in multiple contexts.
    
    The flag fields that are set only during registration or removal can
    remain as they are, since non-atomic accesses at those times will not
    cause any problems.
    
    (Strictly speaking, the authorized_default flag should become atomic
    as well.  I didn't bother with it because it gets changed only via
    sysfs.  It can be done later, if anyone wants.)
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 9b867e64a0f4..f8f8fa7a56e8 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -89,19 +89,31 @@ struct usb_hcd {
 	 */
 	const struct hc_driver	*driver;	/* hw-specific hooks */
 
-	/* Flags that need to be manipulated atomically */
+	/* Flags that need to be manipulated atomically because they can
+	 * change while the host controller is running.  Always use
+	 * set_bit() or clear_bit() to change their values.
+	 */
 	unsigned long		flags;
-#define HCD_FLAG_HW_ACCESSIBLE	0x00000001
-#define HCD_FLAG_SAW_IRQ	0x00000002
+#define HCD_FLAG_HW_ACCESSIBLE		0	/* at full power */
+#define HCD_FLAG_SAW_IRQ		1
+#define HCD_FLAG_POLL_RH		2	/* poll for rh status? */
+#define HCD_FLAG_POLL_PENDING		3	/* status has changed? */
+
+	/* The flags can be tested using these macros; they are likely to
+	 * be slightly faster than test_bit().
+	 */
+#define HCD_HW_ACCESSIBLE(hcd)	((hcd)->flags & (1U << HCD_FLAG_HW_ACCESSIBLE))
+#define HCD_SAW_IRQ(hcd)	((hcd)->flags & (1U << HCD_FLAG_SAW_IRQ))
+#define HCD_POLL_RH(hcd)	((hcd)->flags & (1U << HCD_FLAG_POLL_RH))
+#define HCD_POLL_PENDING(hcd)	((hcd)->flags & (1U << HCD_FLAG_POLL_PENDING))
 
+	/* Flags that get set only during HCD registration or removal. */
 	unsigned		rh_registered:1;/* is root hub registered? */
 	unsigned		rh_pollable:1;	/* may we poll the root hub? */
 
 	/* The next flag is a stopgap, to be removed when all the HCDs
 	 * support the new root-hub polling mechanism. */
 	unsigned		uses_new_polling:1;
-	unsigned		poll_rh:1;	/* poll for rh status? */
-	unsigned		poll_pending:1;	/* status has changed? */
 	unsigned		wireless:1;	/* Wireless USB HCD */
 	unsigned		authorized_default:1;
 	unsigned		has_tt:1;	/* Integrated TT in root hub */

commit 48f24970144479c29b8cee6d2e1dbedf6dcf9cfb
Author: Alek Du <alek.du@intel.com>
Date:   Fri Jun 4 15:47:55 2010 +0800

    USB: EHCI: EHCI 1.1 addendum: Basic LPM feature support
    
    With this patch, the LPM capable EHCI host controller can put device
    into L1 sleep state which is a mode that can enter/exit quickly, and
    reduce power consumption.
    
    Signed-off-by: Jacob Pan <jacob.jun.pan@intel.com>
    Signed-off-by: Alek Du <alek.du@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 11b638195901..9b867e64a0f4 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -300,6 +300,10 @@ struct hc_driver {
 	int	(*update_hub_device)(struct usb_hcd *, struct usb_device *hdev,
 			struct usb_tt *tt, gfp_t mem_flags);
 	int	(*reset_device)(struct usb_hcd *, struct usb_device *);
+		/* Notifies the HCD after a device is connected and its
+		 * address is set
+		 */
+	int	(*update_device)(struct usb_hcd *, struct usb_device *);
 };
 
 extern int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb);

commit 6d88e6792574497bfac9a81403cc47712040636f
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jun 9 17:34:17 2010 -0400

    USB: don't stop root-hub status polls too soon
    
    This patch (as1390) fixes a problem that crops up when a UHCI host
    controller is unbound from uhci-hcd while there are still some active
    URBs.  The URBs have to be unlinked when the root hub is unregistered,
    and uhci-hcd relies upon root-hub status polls as part of its
    unlinking procedure.  But usb_hcd_poll_rh_status() won't make those
    status calls if hcd->rh_registered is clear, and the flag is cleared
    _before_ the unregistration takes place.
    
    Since hcd->rh_registered is used for other things and needs to be
    cleared early, the solution is to add a new flag (rh_pollable) and use
    it instead.  It gets cleared _after_ the root hub is unregistered.
    
    Now that the status polls don't end too soon, we have to make sure
    they also don't occur too late -- after the root hub's usb_device
    structure or the HCD's private structures are deallocated.  Therefore
    the patch adds usb_get_device() and usb_put_device() calls to protect
    the root hub structure, and it adds an extra del_timer_sync() to
    prevent the root-hub timer from causing an unexpected status poll.
    
    This additional complexity would not be needed if the HCD framework
    had provided separate stop() and release() callbacks instead of just
    stop().  This lack could be fixed at some future time (although it
    would require changes to every host controller driver); when that
    happens this patch won't be needed any more.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 2e3a4ea1a3da..11b638195901 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -95,6 +95,7 @@ struct usb_hcd {
 #define HCD_FLAG_SAW_IRQ	0x00000002
 
 	unsigned		rh_registered:1;/* is root hub registered? */
+	unsigned		rh_pollable:1;	/* may we poll the root hub? */
 
 	/* The next flag is a stopgap, to be removed when all the HCDs
 	 * support the new root-hub polling mechanism. */

commit 0858a3a52f659dabf2860f350e5a6a61f069e851
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon May 17 10:58:12 2010 -0700

    USB: include/usb/*.h checkpatch cleanup
    
    Lots of minor formatting cleanups in includes/usb/ to make checkpatch
    happier.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index aca73a5c3af7..2e3a4ea1a3da 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -126,7 +126,7 @@ struct usb_hcd {
 
 
 #define HCD_BUFFER_POOLS	4
-	struct dma_pool		*pool [HCD_BUFFER_POOLS];
+	struct dma_pool		*pool[HCD_BUFFER_POOLS];
 
 	int			state;
 #	define	__ACTIVE		0x01
@@ -219,12 +219,12 @@ struct hc_driver {
 				struct urb *urb, int status);
 
 	/* hw synch, freeing endpoint resources that urb_dequeue can't */
-	void 	(*endpoint_disable)(struct usb_hcd *hcd,
+	void	(*endpoint_disable)(struct usb_hcd *hcd,
 			struct usb_host_endpoint *ep);
 
 	/* (optional) reset any endpoint state such as sequence number
 	   and current window */
-	void 	(*endpoint_reset)(struct usb_hcd *hcd,
+	void	(*endpoint_reset)(struct usb_hcd *hcd,
 			struct usb_host_endpoint *ep);
 
 	/* root hub support */
@@ -265,16 +265,18 @@ struct hc_driver {
 	/* Note that add_endpoint() can only be called once per endpoint before
 	 * check_bandwidth() or reset_bandwidth() must be called.
 	 * drop_endpoint() can only be called once per endpoint also.
-	 * A call to xhci_drop_endpoint() followed by a call to xhci_add_endpoint() will
-	 * add the endpoint to the schedule with possibly new parameters denoted by a
-	 * different endpoint descriptor in usb_host_endpoint.
-	 * A call to xhci_add_endpoint() followed by a call to xhci_drop_endpoint() is
-	 * not allowed.
+	 * A call to xhci_drop_endpoint() followed by a call to
+	 * xhci_add_endpoint() will add the endpoint to the schedule with
+	 * possibly new parameters denoted by a different endpoint descriptor
+	 * in usb_host_endpoint.  A call to xhci_add_endpoint() followed by a
+	 * call to xhci_drop_endpoint() is not allowed.
 	 */
 		/* Allocate endpoint resources and add them to a new schedule */
-	int 	(*add_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
+	int	(*add_endpoint)(struct usb_hcd *, struct usb_device *,
+				struct usb_host_endpoint *);
 		/* Drop an endpoint from a new schedule */
-	int 	(*drop_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
+	int	(*drop_endpoint)(struct usb_hcd *, struct usb_device *,
+				 struct usb_host_endpoint *);
 		/* Check that a new hardware configuration, set using
 		 * endpoint_enable and endpoint_disable, does not exceed bus
 		 * bandwidth.  This must be called before any set configuration
@@ -484,8 +486,8 @@ extern void usb_ep0_reinit(struct usb_device *);
 #define HS_NSECS_ISO(bytes) (((38 * 8 * 2083) \
 	+ (2083UL * (3 + BitTime(bytes))))/1000 \
 	+ USB2_HOST_DELAY)
-#define HS_USECS(bytes) NS_TO_US (HS_NSECS(bytes))
-#define HS_USECS_ISO(bytes) NS_TO_US (HS_NSECS_ISO(bytes))
+#define HS_USECS(bytes)		NS_TO_US(HS_NSECS(bytes))
+#define HS_USECS_ISO(bytes)	NS_TO_US(HS_NSECS_ISO(bytes))
 
 extern long usb_calc_bus_time(int speed, int is_input,
 			int isoc, int bytecount);
@@ -596,7 +598,7 @@ static inline void usbmon_urb_complete(struct usb_bus *bus, struct urb *urb,
 
 /* hub.h ... DeviceRemovable in 2.4.2-ac11, gone in 2.4.10 */
 /* bleech -- resurfaced in 2.4.11 or 2.4.12 */
-#define bitmap 	DeviceRemovable
+#define bitmap	DeviceRemovable
 
 
 /*-------------------------------------------------------------------------*/

commit eab1cafc3b524b714b0567ab98fc75ace09db98c
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 5 10:55:58 2010 -0700

    USB: Support for allocating USB 3.0 streams.
    
    Bulk endpoint streams were added in the USB 3.0 specification.  Streams
    allow a device driver to overload a bulk endpoint so that multiple
    transfers can be queued at once.
    
    The device then decides which transfer it wants to work on first, and can
    queue part of a transfer before it switches to a new stream.  All this
    switching is invisible to the device driver, which just gets a completion
    for the URB.  Drivers that use streams must be able to handle URBs
    completing in a different order than they were submitted to the endpoint.
    
    This requires adding new API to set up xHCI data structures to support
    multiple queues ("stream rings") per endpoint.  Drivers will allocate a
    number of stream IDs before enqueueing URBs to the bulk endpoints of the
    device, and free the stream IDs in their disconnect function.  See
    Documentation/usb/bulk-streams.txt for details.
    
    The new mass storage device class, USB Attached SCSI Protocol (UASP), uses
    these streams API.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index d268415b7a40..aca73a5c3af7 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -250,6 +250,16 @@ struct hc_driver {
 	int	(*alloc_dev)(struct usb_hcd *, struct usb_device *);
 		/* Called by usb_disconnect to free HC device structures */
 	void	(*free_dev)(struct usb_hcd *, struct usb_device *);
+	/* Change a group of bulk endpoints to support multiple stream IDs */
+	int	(*alloc_streams)(struct usb_hcd *hcd, struct usb_device *udev,
+		struct usb_host_endpoint **eps, unsigned int num_eps,
+		unsigned int num_streams, gfp_t mem_flags);
+	/* Reverts a group of bulk endpoints back to not using stream IDs.
+	 * Can fail if we run out of memory.
+	 */
+	int	(*free_streams)(struct usb_hcd *hcd, struct usb_device *udev,
+		struct usb_host_endpoint **eps, unsigned int num_eps,
+		gfp_t mem_flags);
 
 	/* Bandwidth computation functions */
 	/* Note that add_endpoint() can only be called once per endpoint before

commit d20db4b4e938aa8e4e5735b5a1b202de5800400e
Author: Eric Lescouet <Eric.Lescouet@virtuallogix.com>
Date:   Sat Apr 24 23:38:17 2010 +0200

    USB: split hub.h into ch11.h and merge-in hcd.h
    
    Base on inputs from Alan Stern, split the hub.h header into:
    - new ch11.h header (most of it) containing constants and
      structures from chapter 11 of the USB 2.0 spec.
    - a small remaining part being merged into hcd.h.
    
    Signed-of-by: Eric Lescouet <eric@lescouet.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index ca228f00b826..d268415b7a40 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -374,7 +374,42 @@ extern void usb_destroy_configuration(struct usb_device *dev);
  * HCD Root Hub support
  */
 
-#include <linux/usb/hub.h>
+#include <linux/usb/ch11.h>
+
+/*
+ * As of USB 2.0, full/low speed devices are segregated into trees.
+ * One type grows from USB 1.1 host controllers (OHCI, UHCI etc).
+ * The other type grows from high speed hubs when they connect to
+ * full/low speed devices using "Transaction Translators" (TTs).
+ *
+ * TTs should only be known to the hub driver, and high speed bus
+ * drivers (only EHCI for now).  They affect periodic scheduling and
+ * sometimes control/bulk error recovery.
+ */
+
+struct usb_device;
+
+struct usb_tt {
+	struct usb_device	*hub;	/* upstream highspeed hub */
+	int			multi;	/* true means one TT per port */
+	unsigned		think_time;	/* think time in ns */
+
+	/* for control/bulk error recovery (CLEAR_TT_BUFFER) */
+	spinlock_t		lock;
+	struct list_head	clear_list;	/* of usb_tt_clear */
+	struct work_struct	clear_work;
+};
+
+struct usb_tt_clear {
+	struct list_head	clear_list;
+	unsigned		tt;
+	u16			devinfo;
+	struct usb_hcd		*hcd;
+	struct usb_host_endpoint	*ep;
+};
+
+extern int usb_hub_clear_tt_buffer(struct urb *urb);
+extern void usb_ep0_reinit(struct usb_device *);
 
 /* (shifted) direction/type/recipient from the USB 2.0 spec, table 9.2 */
 #define DeviceRequest \

commit d65d7e7ef3dc5e61e4dfaac54ec6d3e97f9a1108
Author: Eric Lescouet <Eric.Lescouet@virtuallogix.com>
Date:   Sat Apr 24 23:34:27 2010 +0200

    USB: make hub.h public (drivers dependency)
    
    The usbcore headers: hcd.h and hub.h are shared between usbcore,
    HCDs and a couple of other drivers (e.g. USBIP modules).
    So, it makes sense to move them into a more public location and
    to cleanup dependency of those modules on kernel internal headers.
    This patch moves hub.h from drivers/usb/core into include/linux/usb/
    
    Signed-of-by: Eric Lescouet <eric@lescouet.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index c7e575cb3149..ca228f00b826 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -374,7 +374,7 @@ extern void usb_destroy_configuration(struct usb_device *dev);
  * HCD Root Hub support
  */
 
-#include <linux/../../drivers/usb/core/hub.h>
+#include <linux/usb/hub.h>
 
 /* (shifted) direction/type/recipient from the USB 2.0 spec, table 9.2 */
 #define DeviceRequest \

commit 27729aadd31dafddaaf64c24f8ef6d0ff750f3aa
Author: Eric Lescouet <Eric.Lescouet@virtuallogix.com>
Date:   Sat Apr 24 23:21:52 2010 +0200

    USB: make hcd.h public (drivers dependency)
    
    The usbcore headers: hcd.h and hub.h are shared between usbcore,
    HCDs and a couple of other drivers (e.g. USBIP modules).
    So, it makes sense to move them into a more public location and
    to cleanup dependency of those modules on kernel internal headers.
    This patch moves hcd.h from drivers/usb/core into include/linux/usb/
    
    Signed-of-by: Eric Lescouet <eric@lescouet.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
new file mode 100644
index 000000000000..c7e575cb3149
--- /dev/null
+++ b/include/linux/usb/hcd.h
@@ -0,0 +1,578 @@
+/*
+ * Copyright (c) 2001-2002 by David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __USB_CORE_HCD_H
+#define __USB_CORE_HCD_H
+
+#ifdef __KERNEL__
+
+#include <linux/rwsem.h>
+
+#define MAX_TOPO_LEVEL		6
+
+/* This file contains declarations of usbcore internals that are mostly
+ * used or exposed by Host Controller Drivers.
+ */
+
+/*
+ * USB Packet IDs (PIDs)
+ */
+#define USB_PID_EXT			0xf0	/* USB 2.0 LPM ECN */
+#define USB_PID_OUT			0xe1
+#define USB_PID_ACK			0xd2
+#define USB_PID_DATA0			0xc3
+#define USB_PID_PING			0xb4	/* USB 2.0 */
+#define USB_PID_SOF			0xa5
+#define USB_PID_NYET			0x96	/* USB 2.0 */
+#define USB_PID_DATA2			0x87	/* USB 2.0 */
+#define USB_PID_SPLIT			0x78	/* USB 2.0 */
+#define USB_PID_IN			0x69
+#define USB_PID_NAK			0x5a
+#define USB_PID_DATA1			0x4b
+#define USB_PID_PREAMBLE		0x3c	/* Token mode */
+#define USB_PID_ERR			0x3c	/* USB 2.0: handshake mode */
+#define USB_PID_SETUP			0x2d
+#define USB_PID_STALL			0x1e
+#define USB_PID_MDATA			0x0f	/* USB 2.0 */
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * USB Host Controller Driver (usb_hcd) framework
+ *
+ * Since "struct usb_bus" is so thin, you can't share much code in it.
+ * This framework is a layer over that, and should be more sharable.
+ *
+ * @authorized_default: Specifies if new devices are authorized to
+ *                      connect by default or they require explicit
+ *                      user space authorization; this bit is settable
+ *                      through /sys/class/usb_host/X/authorized_default.
+ *                      For the rest is RO, so we don't lock to r/w it.
+ */
+
+/*-------------------------------------------------------------------------*/
+
+struct usb_hcd {
+
+	/*
+	 * housekeeping
+	 */
+	struct usb_bus		self;		/* hcd is-a bus */
+	struct kref		kref;		/* reference counter */
+
+	const char		*product_desc;	/* product/vendor string */
+	char			irq_descr[24];	/* driver + bus # */
+
+	struct timer_list	rh_timer;	/* drives root-hub polling */
+	struct urb		*status_urb;	/* the current status urb */
+#ifdef CONFIG_USB_SUSPEND
+	struct work_struct	wakeup_work;	/* for remote wakeup */
+#endif
+
+	/*
+	 * hardware info/state
+	 */
+	const struct hc_driver	*driver;	/* hw-specific hooks */
+
+	/* Flags that need to be manipulated atomically */
+	unsigned long		flags;
+#define HCD_FLAG_HW_ACCESSIBLE	0x00000001
+#define HCD_FLAG_SAW_IRQ	0x00000002
+
+	unsigned		rh_registered:1;/* is root hub registered? */
+
+	/* The next flag is a stopgap, to be removed when all the HCDs
+	 * support the new root-hub polling mechanism. */
+	unsigned		uses_new_polling:1;
+	unsigned		poll_rh:1;	/* poll for rh status? */
+	unsigned		poll_pending:1;	/* status has changed? */
+	unsigned		wireless:1;	/* Wireless USB HCD */
+	unsigned		authorized_default:1;
+	unsigned		has_tt:1;	/* Integrated TT in root hub */
+
+	int			irq;		/* irq allocated */
+	void __iomem		*regs;		/* device memory/io */
+	u64			rsrc_start;	/* memory/io resource start */
+	u64			rsrc_len;	/* memory/io resource length */
+	unsigned		power_budget;	/* in mA, 0 = no limit */
+
+	/* bandwidth_mutex should be taken before adding or removing
+	 * any new bus bandwidth constraints:
+	 *   1. Before adding a configuration for a new device.
+	 *   2. Before removing the configuration to put the device into
+	 *      the addressed state.
+	 *   3. Before selecting a different configuration.
+	 *   4. Before selecting an alternate interface setting.
+	 *
+	 * bandwidth_mutex should be dropped after a successful control message
+	 * to the device, or resetting the bandwidth after a failed attempt.
+	 */
+	struct mutex		bandwidth_mutex;
+
+
+#define HCD_BUFFER_POOLS	4
+	struct dma_pool		*pool [HCD_BUFFER_POOLS];
+
+	int			state;
+#	define	__ACTIVE		0x01
+#	define	__SUSPEND		0x04
+#	define	__TRANSIENT		0x80
+
+#	define	HC_STATE_HALT		0
+#	define	HC_STATE_RUNNING	(__ACTIVE)
+#	define	HC_STATE_QUIESCING	(__SUSPEND|__TRANSIENT|__ACTIVE)
+#	define	HC_STATE_RESUMING	(__SUSPEND|__TRANSIENT)
+#	define	HC_STATE_SUSPENDED	(__SUSPEND)
+
+#define	HC_IS_RUNNING(state) ((state) & __ACTIVE)
+#define	HC_IS_SUSPENDED(state) ((state) & __SUSPEND)
+
+	/* more shared queuing code would be good; it should support
+	 * smarter scheduling, handle transaction translators, etc;
+	 * input size of periodic table to an interrupt scheduler.
+	 * (ohci 32, uhci 1024, ehci 256/512/1024).
+	 */
+
+	/* The HC driver's private data is stored at the end of
+	 * this structure.
+	 */
+	unsigned long hcd_priv[0]
+			__attribute__ ((aligned(sizeof(unsigned long))));
+};
+
+/* 2.4 does this a bit differently ... */
+static inline struct usb_bus *hcd_to_bus(struct usb_hcd *hcd)
+{
+	return &hcd->self;
+}
+
+static inline struct usb_hcd *bus_to_hcd(struct usb_bus *bus)
+{
+	return container_of(bus, struct usb_hcd, self);
+}
+
+struct hcd_timeout {	/* timeouts we allocate */
+	struct list_head	timeout_list;
+	struct timer_list	timer;
+};
+
+/*-------------------------------------------------------------------------*/
+
+
+struct hc_driver {
+	const char	*description;	/* "ehci-hcd" etc */
+	const char	*product_desc;	/* product/vendor string */
+	size_t		hcd_priv_size;	/* size of private data */
+
+	/* irq handler */
+	irqreturn_t	(*irq) (struct usb_hcd *hcd);
+
+	int	flags;
+#define	HCD_MEMORY	0x0001		/* HC regs use memory (else I/O) */
+#define	HCD_LOCAL_MEM	0x0002		/* HC needs local memory */
+#define	HCD_USB11	0x0010		/* USB 1.1 */
+#define	HCD_USB2	0x0020		/* USB 2.0 */
+#define	HCD_USB3	0x0040		/* USB 3.0 */
+#define	HCD_MASK	0x0070
+
+	/* called to init HCD and root hub */
+	int	(*reset) (struct usb_hcd *hcd);
+	int	(*start) (struct usb_hcd *hcd);
+
+	/* NOTE:  these suspend/resume calls relate to the HC as
+	 * a whole, not just the root hub; they're for PCI bus glue.
+	 */
+	/* called after suspending the hub, before entering D3 etc */
+	int	(*pci_suspend)(struct usb_hcd *hcd);
+
+	/* called after entering D0 (etc), before resuming the hub */
+	int	(*pci_resume)(struct usb_hcd *hcd, bool hibernated);
+
+	/* cleanly make HCD stop writing memory and doing I/O */
+	void	(*stop) (struct usb_hcd *hcd);
+
+	/* shutdown HCD */
+	void	(*shutdown) (struct usb_hcd *hcd);
+
+	/* return current frame number */
+	int	(*get_frame_number) (struct usb_hcd *hcd);
+
+	/* manage i/o requests, device state */
+	int	(*urb_enqueue)(struct usb_hcd *hcd,
+				struct urb *urb, gfp_t mem_flags);
+	int	(*urb_dequeue)(struct usb_hcd *hcd,
+				struct urb *urb, int status);
+
+	/* hw synch, freeing endpoint resources that urb_dequeue can't */
+	void 	(*endpoint_disable)(struct usb_hcd *hcd,
+			struct usb_host_endpoint *ep);
+
+	/* (optional) reset any endpoint state such as sequence number
+	   and current window */
+	void 	(*endpoint_reset)(struct usb_hcd *hcd,
+			struct usb_host_endpoint *ep);
+
+	/* root hub support */
+	int	(*hub_status_data) (struct usb_hcd *hcd, char *buf);
+	int	(*hub_control) (struct usb_hcd *hcd,
+				u16 typeReq, u16 wValue, u16 wIndex,
+				char *buf, u16 wLength);
+	int	(*bus_suspend)(struct usb_hcd *);
+	int	(*bus_resume)(struct usb_hcd *);
+	int	(*start_port_reset)(struct usb_hcd *, unsigned port_num);
+
+		/* force handover of high-speed port to full-speed companion */
+	void	(*relinquish_port)(struct usb_hcd *, int);
+		/* has a port been handed over to a companion? */
+	int	(*port_handed_over)(struct usb_hcd *, int);
+
+		/* CLEAR_TT_BUFFER completion callback */
+	void	(*clear_tt_buffer_complete)(struct usb_hcd *,
+				struct usb_host_endpoint *);
+
+	/* xHCI specific functions */
+		/* Called by usb_alloc_dev to alloc HC device structures */
+	int	(*alloc_dev)(struct usb_hcd *, struct usb_device *);
+		/* Called by usb_disconnect to free HC device structures */
+	void	(*free_dev)(struct usb_hcd *, struct usb_device *);
+
+	/* Bandwidth computation functions */
+	/* Note that add_endpoint() can only be called once per endpoint before
+	 * check_bandwidth() or reset_bandwidth() must be called.
+	 * drop_endpoint() can only be called once per endpoint also.
+	 * A call to xhci_drop_endpoint() followed by a call to xhci_add_endpoint() will
+	 * add the endpoint to the schedule with possibly new parameters denoted by a
+	 * different endpoint descriptor in usb_host_endpoint.
+	 * A call to xhci_add_endpoint() followed by a call to xhci_drop_endpoint() is
+	 * not allowed.
+	 */
+		/* Allocate endpoint resources and add them to a new schedule */
+	int 	(*add_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
+		/* Drop an endpoint from a new schedule */
+	int 	(*drop_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
+		/* Check that a new hardware configuration, set using
+		 * endpoint_enable and endpoint_disable, does not exceed bus
+		 * bandwidth.  This must be called before any set configuration
+		 * or set interface requests are sent to the device.
+		 */
+	int	(*check_bandwidth)(struct usb_hcd *, struct usb_device *);
+		/* Reset the device schedule to the last known good schedule,
+		 * which was set from a previous successful call to
+		 * check_bandwidth().  This reverts any add_endpoint() and
+		 * drop_endpoint() calls since that last successful call.
+		 * Used for when a check_bandwidth() call fails due to resource
+		 * or bandwidth constraints.
+		 */
+	void	(*reset_bandwidth)(struct usb_hcd *, struct usb_device *);
+		/* Returns the hardware-chosen device address */
+	int	(*address_device)(struct usb_hcd *, struct usb_device *udev);
+		/* Notifies the HCD after a hub descriptor is fetched.
+		 * Will block.
+		 */
+	int	(*update_hub_device)(struct usb_hcd *, struct usb_device *hdev,
+			struct usb_tt *tt, gfp_t mem_flags);
+	int	(*reset_device)(struct usb_hcd *, struct usb_device *);
+};
+
+extern int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb);
+extern int usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,
+		int status);
+extern void usb_hcd_unlink_urb_from_ep(struct usb_hcd *hcd, struct urb *urb);
+
+extern int usb_hcd_submit_urb(struct urb *urb, gfp_t mem_flags);
+extern int usb_hcd_unlink_urb(struct urb *urb, int status);
+extern void usb_hcd_giveback_urb(struct usb_hcd *hcd, struct urb *urb,
+		int status);
+extern void usb_hcd_flush_endpoint(struct usb_device *udev,
+		struct usb_host_endpoint *ep);
+extern void usb_hcd_disable_endpoint(struct usb_device *udev,
+		struct usb_host_endpoint *ep);
+extern void usb_hcd_reset_endpoint(struct usb_device *udev,
+		struct usb_host_endpoint *ep);
+extern void usb_hcd_synchronize_unlinks(struct usb_device *udev);
+extern int usb_hcd_alloc_bandwidth(struct usb_device *udev,
+		struct usb_host_config *new_config,
+		struct usb_host_interface *old_alt,
+		struct usb_host_interface *new_alt);
+extern int usb_hcd_get_frame_number(struct usb_device *udev);
+
+extern struct usb_hcd *usb_create_hcd(const struct hc_driver *driver,
+		struct device *dev, const char *bus_name);
+extern struct usb_hcd *usb_get_hcd(struct usb_hcd *hcd);
+extern void usb_put_hcd(struct usb_hcd *hcd);
+extern int usb_add_hcd(struct usb_hcd *hcd,
+		unsigned int irqnum, unsigned long irqflags);
+extern void usb_remove_hcd(struct usb_hcd *hcd);
+
+struct platform_device;
+extern void usb_hcd_platform_shutdown(struct platform_device *dev);
+
+#ifdef CONFIG_PCI
+struct pci_dev;
+struct pci_device_id;
+extern int usb_hcd_pci_probe(struct pci_dev *dev,
+				const struct pci_device_id *id);
+extern void usb_hcd_pci_remove(struct pci_dev *dev);
+extern void usb_hcd_pci_shutdown(struct pci_dev *dev);
+
+#ifdef CONFIG_PM_SLEEP
+extern const struct dev_pm_ops usb_hcd_pci_pm_ops;
+#endif
+#endif /* CONFIG_PCI */
+
+/* pci-ish (pdev null is ok) buffer alloc/mapping support */
+int hcd_buffer_create(struct usb_hcd *hcd);
+void hcd_buffer_destroy(struct usb_hcd *hcd);
+
+void *hcd_buffer_alloc(struct usb_bus *bus, size_t size,
+	gfp_t mem_flags, dma_addr_t *dma);
+void hcd_buffer_free(struct usb_bus *bus, size_t size,
+	void *addr, dma_addr_t dma);
+
+/* generic bus glue, needed for host controllers that don't use PCI */
+extern irqreturn_t usb_hcd_irq(int irq, void *__hcd);
+
+extern void usb_hc_died(struct usb_hcd *hcd);
+extern void usb_hcd_poll_rh_status(struct usb_hcd *hcd);
+
+/* The D0/D1 toggle bits ... USE WITH CAUTION (they're almost hcd-internal) */
+#define usb_gettoggle(dev, ep, out) (((dev)->toggle[out] >> (ep)) & 1)
+#define	usb_dotoggle(dev, ep, out)  ((dev)->toggle[out] ^= (1 << (ep)))
+#define usb_settoggle(dev, ep, out, bit) \
+		((dev)->toggle[out] = ((dev)->toggle[out] & ~(1 << (ep))) | \
+		 ((bit) << (ep)))
+
+/* -------------------------------------------------------------------------- */
+
+/* Enumeration is only for the hub driver, or HCD virtual root hubs */
+extern struct usb_device *usb_alloc_dev(struct usb_device *parent,
+					struct usb_bus *, unsigned port);
+extern int usb_new_device(struct usb_device *dev);
+extern void usb_disconnect(struct usb_device **);
+
+extern int usb_get_configuration(struct usb_device *dev);
+extern void usb_destroy_configuration(struct usb_device *dev);
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * HCD Root Hub support
+ */
+
+#include <linux/../../drivers/usb/core/hub.h>
+
+/* (shifted) direction/type/recipient from the USB 2.0 spec, table 9.2 */
+#define DeviceRequest \
+	((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_DEVICE)<<8)
+#define DeviceOutRequest \
+	((USB_DIR_OUT|USB_TYPE_STANDARD|USB_RECIP_DEVICE)<<8)
+
+#define InterfaceRequest \
+	((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_INTERFACE)<<8)
+
+#define EndpointRequest \
+	((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_INTERFACE)<<8)
+#define EndpointOutRequest \
+	((USB_DIR_OUT|USB_TYPE_STANDARD|USB_RECIP_INTERFACE)<<8)
+
+/* class requests from the USB 2.0 hub spec, table 11-15 */
+/* GetBusState and SetHubDescriptor are optional, omitted */
+#define ClearHubFeature		(0x2000 | USB_REQ_CLEAR_FEATURE)
+#define ClearPortFeature	(0x2300 | USB_REQ_CLEAR_FEATURE)
+#define GetHubDescriptor	(0xa000 | USB_REQ_GET_DESCRIPTOR)
+#define GetHubStatus		(0xa000 | USB_REQ_GET_STATUS)
+#define GetPortStatus		(0xa300 | USB_REQ_GET_STATUS)
+#define SetHubFeature		(0x2000 | USB_REQ_SET_FEATURE)
+#define SetPortFeature		(0x2300 | USB_REQ_SET_FEATURE)
+
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * Generic bandwidth allocation constants/support
+ */
+#define FRAME_TIME_USECS	1000L
+#define BitTime(bytecount) (7 * 8 * bytecount / 6) /* with integer truncation */
+		/* Trying not to use worst-case bit-stuffing
+		 * of (7/6 * 8 * bytecount) = 9.33 * bytecount */
+		/* bytecount = data payload byte count */
+
+#define NS_TO_US(ns)	((ns + 500L) / 1000L)
+			/* convert & round nanoseconds to microseconds */
+
+
+/*
+ * Full/low speed bandwidth allocation constants/support.
+ */
+#define BW_HOST_DELAY	1000L		/* nanoseconds */
+#define BW_HUB_LS_SETUP	333L		/* nanoseconds */
+			/* 4 full-speed bit times (est.) */
+
+#define FRAME_TIME_BITS			12000L	/* frame = 1 millisecond */
+#define FRAME_TIME_MAX_BITS_ALLOC	(90L * FRAME_TIME_BITS / 100L)
+#define FRAME_TIME_MAX_USECS_ALLOC	(90L * FRAME_TIME_USECS / 100L)
+
+/*
+ * Ceiling [nano/micro]seconds (typical) for that many bytes at high speed
+ * ISO is a bit less, no ACK ... from USB 2.0 spec, 5.11.3 (and needed
+ * to preallocate bandwidth)
+ */
+#define USB2_HOST_DELAY	5	/* nsec, guess */
+#define HS_NSECS(bytes) (((55 * 8 * 2083) \
+	+ (2083UL * (3 + BitTime(bytes))))/1000 \
+	+ USB2_HOST_DELAY)
+#define HS_NSECS_ISO(bytes) (((38 * 8 * 2083) \
+	+ (2083UL * (3 + BitTime(bytes))))/1000 \
+	+ USB2_HOST_DELAY)
+#define HS_USECS(bytes) NS_TO_US (HS_NSECS(bytes))
+#define HS_USECS_ISO(bytes) NS_TO_US (HS_NSECS_ISO(bytes))
+
+extern long usb_calc_bus_time(int speed, int is_input,
+			int isoc, int bytecount);
+
+/*-------------------------------------------------------------------------*/
+
+extern void usb_set_device_state(struct usb_device *udev,
+		enum usb_device_state new_state);
+
+/*-------------------------------------------------------------------------*/
+
+/* exported only within usbcore */
+
+extern struct list_head usb_bus_list;
+extern struct mutex usb_bus_list_lock;
+extern wait_queue_head_t usb_kill_urb_queue;
+
+extern int usb_find_interface_driver(struct usb_device *dev,
+	struct usb_interface *interface);
+
+#define usb_endpoint_out(ep_dir)	(!((ep_dir) & USB_DIR_IN))
+
+#ifdef CONFIG_PM
+extern void usb_root_hub_lost_power(struct usb_device *rhdev);
+extern int hcd_bus_suspend(struct usb_device *rhdev, pm_message_t msg);
+extern int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg);
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_USB_SUSPEND
+extern void usb_hcd_resume_root_hub(struct usb_hcd *hcd);
+#else
+static inline void usb_hcd_resume_root_hub(struct usb_hcd *hcd)
+{
+	return;
+}
+#endif /* CONFIG_USB_SUSPEND */
+
+
+/*
+ * USB device fs stuff
+ */
+
+#ifdef CONFIG_USB_DEVICEFS
+
+/*
+ * these are expected to be called from the USB core/hub thread
+ * with the kernel lock held
+ */
+extern void usbfs_update_special(void);
+extern int usbfs_init(void);
+extern void usbfs_cleanup(void);
+
+#else /* CONFIG_USB_DEVICEFS */
+
+static inline void usbfs_update_special(void) {}
+static inline int usbfs_init(void) { return 0; }
+static inline void usbfs_cleanup(void) { }
+
+#endif /* CONFIG_USB_DEVICEFS */
+
+/*-------------------------------------------------------------------------*/
+
+#if defined(CONFIG_USB_MON) || defined(CONFIG_USB_MON_MODULE)
+
+struct usb_mon_operations {
+	void (*urb_submit)(struct usb_bus *bus, struct urb *urb);
+	void (*urb_submit_error)(struct usb_bus *bus, struct urb *urb, int err);
+	void (*urb_complete)(struct usb_bus *bus, struct urb *urb, int status);
+	/* void (*urb_unlink)(struct usb_bus *bus, struct urb *urb); */
+};
+
+extern struct usb_mon_operations *mon_ops;
+
+static inline void usbmon_urb_submit(struct usb_bus *bus, struct urb *urb)
+{
+	if (bus->monitored)
+		(*mon_ops->urb_submit)(bus, urb);
+}
+
+static inline void usbmon_urb_submit_error(struct usb_bus *bus, struct urb *urb,
+    int error)
+{
+	if (bus->monitored)
+		(*mon_ops->urb_submit_error)(bus, urb, error);
+}
+
+static inline void usbmon_urb_complete(struct usb_bus *bus, struct urb *urb,
+		int status)
+{
+	if (bus->monitored)
+		(*mon_ops->urb_complete)(bus, urb, status);
+}
+
+int usb_mon_register(struct usb_mon_operations *ops);
+void usb_mon_deregister(void);
+
+#else
+
+static inline void usbmon_urb_submit(struct usb_bus *bus, struct urb *urb) {}
+static inline void usbmon_urb_submit_error(struct usb_bus *bus, struct urb *urb,
+    int error) {}
+static inline void usbmon_urb_complete(struct usb_bus *bus, struct urb *urb,
+		int status) {}
+
+#endif /* CONFIG_USB_MON || CONFIG_USB_MON_MODULE */
+
+/*-------------------------------------------------------------------------*/
+
+/* hub.h ... DeviceRemovable in 2.4.2-ac11, gone in 2.4.10 */
+/* bleech -- resurfaced in 2.4.11 or 2.4.12 */
+#define bitmap 	DeviceRemovable
+
+
+/*-------------------------------------------------------------------------*/
+
+/* random stuff */
+
+#define	RUN_CONTEXT (in_irq() ? "in_irq" \
+		: (in_interrupt() ? "in_interrupt" : "can sleep"))
+
+
+/* This rwsem is for use only by the hub driver and ehci-hcd.
+ * Nobody else should touch it.
+ */
+extern struct rw_semaphore ehci_cf_port_reset_rwsem;
+
+/* Keep track of which host controller drivers are loaded */
+#define USB_UHCI_LOADED		0
+#define USB_OHCI_LOADED		1
+#define USB_EHCI_LOADED		2
+extern unsigned long usb_hcds_loaded;
+
+#endif /* __KERNEL__ */
+
+#endif /* __USB_CORE_HCD_H */
