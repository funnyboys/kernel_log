commit 80ed53707bb3ec92c331ca33f45c113338ee434d
Author: Johan Hovold <johan@kernel.org>
Date:   Fri Apr 26 08:01:32 2019 +0200

    USB: serial: drop unused iflag macro
    
    Drop the RELEVANT_IFLAG() macro which essentially hasn't been used for
    over a decade except in some remnant debug printks that were recently
    removed.
    
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index d8bdab8f3c26..14cac4a1ae8f 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -23,9 +23,6 @@
 /* The maximum number of ports one device can grab at once */
 #define MAX_NUM_PORTS		16
 
-/* parity check flag */
-#define RELEVANT_IFLAG(iflag)	(iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
-
 /* USB serial flags */
 #define USB_SERIAL_WRITE_BUSY	0
 #define USB_SERIAL_THROTTLED	1

commit a8d78d9f385642696723fcb9c52c2c2805fa4249
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Apr 25 18:05:37 2019 +0200

    USB: serial: clean up throttle handling
    
    Clean up the throttle implementation by dropping the redundant
    throttle_req flag which was a remnant from back when there was only a
    single read URB.
    
    Also convert the throttled flag to an atomic bit flag.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 1c19f77ed541..d8bdab8f3c26 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -28,6 +28,7 @@
 
 /* USB serial flags */
 #define USB_SERIAL_WRITE_BUSY	0
+#define USB_SERIAL_THROTTLED	1
 
 /**
  * usb_serial_port: structure for the specific ports of a device.
@@ -67,8 +68,6 @@
  * @flags: usb serial port flags
  * @write_wait: a wait_queue_head_t used by the port.
  * @work: work queue entry for the line discipline waking up.
- * @throttled: nonzero if the read urb is inactive to throttle the device
- * @throttle_req: nonzero if the tty wants to throttle us
  * @dev: pointer to the serial device
  *
  * This structure is used by the usb-serial core and drivers for the specific
@@ -115,8 +114,6 @@ struct usb_serial_port {
 	unsigned long		flags;
 	wait_queue_head_t	write_wait;
 	struct work_struct	work;
-	char			throttled;
-	char			throttle_req;
 	unsigned long		sysrq; /* sysrq timeout */
 	struct device		dev;
 };

commit 81732b26e05994552f347746eb11762e986079a0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Sep 11 23:28:07 2018 -0400

    usb-serial: begin switching to ->[sg]et_serial()
    
    add such methods for usb_serial_driver, provide tty_operations
    ->[sg]et_serial() calling those.  For now the lack of methods
    in driver means ENOIOCTLCMD from usb-serial ->[sg]et_serial(),
    making tty_ioctl() fall back to calling ->ioctl().  Once all
    drivers are converted, we'll be returning -ENOTTY instead,
    completing the switchover.
    
    Reviewed-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 106551a5616e..1c19f77ed541 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -285,6 +285,8 @@ struct usb_serial_driver {
 	int  (*write_room)(struct tty_struct *tty);
 	int  (*ioctl)(struct tty_struct *tty,
 		      unsigned int cmd, unsigned long arg);
+	int  (*get_serial)(struct tty_struct *tty, struct serial_struct *ss);
+	int  (*set_serial)(struct tty_struct *tty, struct serial_struct *ss);
 	void (*set_termios)(struct tty_struct *tty,
 			struct usb_serial_port *port, struct ktermios *old);
 	void (*break_ctl)(struct tty_struct *tty, int break_state);

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index e2f0ab07eea5..106551a5616e 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * USB Serial Converter stuff
  *

commit a794499b261b8487a984783ccc864975e1bcc7bf
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Mar 16 17:13:32 2017 +0100

    USB: serial: add calc_num_ports callback to generic driver
    
    Add a calc_num_ports callback to the generic driver and verify that the
    device has the required endpoints there instead of in core.
    
    Note that the generic driver num_ports field was never used.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index da528818cfd8..e2f0ab07eea5 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -379,7 +379,6 @@ extern void usb_serial_handle_dcd_change(struct usb_serial_port *usb_port,
 extern int usb_serial_bus_register(struct usb_serial_driver *device);
 extern void usb_serial_bus_deregister(struct usb_serial_driver *device);
 
-extern struct usb_serial_driver usb_serial_generic_device;
 extern struct bus_type usb_serial_bus_type;
 extern struct tty_driver *usb_serial_tty_driver;
 

commit 07814246dd5530860ef758fd9b2b5f2e26472aa2
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Mar 16 17:13:30 2017 +0100

    USB: serial: allow subdrivers to modify port-endpoint mapping
    
    Allow subdrivers to modify the port-endpoint mapping by passing the
    endpoint descriptors to calc_num_ports.
    
    The callback can now also be used to verify that the required endpoints
    exists and abort probing otherwise.
    
    This will allow us to get rid of a few hacks in subdrivers that are
    already modifying the port-endpoint mapping (or aborting probe due to
    missing endpoints), but only after the port structures have been setup.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index f1b8a8493762..da528818cfd8 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -181,6 +181,17 @@ static inline void usb_set_serial_data(struct usb_serial *serial, void *data)
 	serial->private = data;
 }
 
+struct usb_serial_endpoints {
+	unsigned char num_bulk_in;
+	unsigned char num_bulk_out;
+	unsigned char num_interrupt_in;
+	unsigned char num_interrupt_out;
+	struct usb_endpoint_descriptor *bulk_in[MAX_NUM_PORTS];
+	struct usb_endpoint_descriptor *bulk_out[MAX_NUM_PORTS];
+	struct usb_endpoint_descriptor *interrupt_in[MAX_NUM_PORTS];
+	struct usb_endpoint_descriptor *interrupt_out[MAX_NUM_PORTS];
+};
+
 /**
  * usb_serial_driver - describes a usb serial driver
  * @description: pointer to a string that describes this driver.  This string
@@ -196,8 +207,9 @@ static inline void usb_set_serial_data(struct usb_serial *serial, void *data)
  *	(0 = end-point size)
  * @bulk_out_size: bytes to allocate for bulk-out buffer (0 = end-point size)
  * @calc_num_ports: pointer to a function to determine how many ports this
- *	device has dynamically.  It will be called after the probe()
- *	callback is called, but before attach()
+ *	device has dynamically. It can also be used to verify the number of
+ *	endpoints or to modify the port-endpoint mapping. It will be called
+ *	after the probe() callback is called, but before attach().
  * @probe: pointer to the driver's probe function.
  *	This will be called when the device is inserted into the system,
  *	but before the device has been fully initialized by the usb_serial
@@ -249,7 +261,8 @@ struct usb_serial_driver {
 
 	int (*probe)(struct usb_serial *serial, const struct usb_device_id *id);
 	int (*attach)(struct usb_serial *serial);
-	int (*calc_num_ports) (struct usb_serial *serial);
+	int (*calc_num_ports)(struct usb_serial *serial,
+			struct usb_serial_endpoints *epds);
 
 	void (*disconnect)(struct usb_serial *serial);
 	void (*release)(struct usb_serial *serial);

commit 92e6b2c675e1d247317ec41a078f49aaade7f716
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Mar 2 12:51:19 2017 +0100

    USB: serial: add endpoint sanity check to core
    
    Allow drivers to specify a minimum number of endpoints per type, which
    USB serial core will verify after subdriver probe has returned (where
    the current alternate setting may have been changed).
    
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index ee4394d8932f..f1b8a8493762 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -188,6 +188,10 @@ static inline void usb_set_serial_data(struct usb_serial *serial, void *data)
  * @id_table: pointer to a list of usb_device_id structures that define all
  *	of the devices this structure can support.
  * @num_ports: the number of different ports this device will have.
+ * @num_bulk_in: minimum number of bulk-in endpoints
+ * @num_bulk_out: minimum number of bulk-out endpoints
+ * @num_interrupt_in: minimum number of interrupt-in endpoints
+ * @num_interrupt_out: minimum number of interrupt-out endpoints
  * @bulk_in_size: minimum number of bytes to allocate for bulk-in buffer
  *	(0 = end-point size)
  * @bulk_out_size: bytes to allocate for bulk-out buffer (0 = end-point size)
@@ -235,6 +239,11 @@ struct usb_serial_driver {
 
 	unsigned char		num_ports;
 
+	unsigned char		num_bulk_in;
+	unsigned char		num_bulk_out;
+	unsigned char		num_interrupt_in;
+	unsigned char		num_interrupt_out;
+
 	size_t			bulk_in_size;
 	size_t			bulk_out_size;
 

commit ff0c5703a4b11fca86886e5b7ce40c396bef8381
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Mar 2 12:51:17 2017 +0100

    USB: serial: allow up to 16 ports per device
    
    Raise the arbitrary limit of how many ports a single device can claim
    from eight to 16.
    
    This specifically enables the upper eight ports of some mxuport devices.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 85b475933848..ee4394d8932f 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -20,7 +20,7 @@
 #include <linux/kfifo.h>
 
 /* The maximum number of ports one device can grab at once */
-#define MAX_NUM_PORTS		8
+#define MAX_NUM_PORTS		16
 
 /* parity check flag */
 #define RELEVANT_IFLAG(iflag)	(iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))

commit ef88f33fc1ee0a12a1e5eee7e4f70b7743100a19
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Mar 2 12:51:15 2017 +0100

    USB: serial: clean up endpoint and port-counter types
    
    Use unsigned-char type for the endpoint and port counters.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 704a1ab8240c..85b475933848 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -159,10 +159,10 @@ struct usb_serial {
 	unsigned char			minors_reserved:1;
 	unsigned char			num_ports;
 	unsigned char			num_port_pointers;
-	char				num_interrupt_in;
-	char				num_interrupt_out;
-	char				num_bulk_in;
-	char				num_bulk_out;
+	unsigned char			num_interrupt_in;
+	unsigned char			num_interrupt_out;
+	unsigned char			num_bulk_in;
+	unsigned char			num_bulk_out;
 	struct usb_serial_port		*port[MAX_NUM_PORTS];
 	struct kref			kref;
 	struct mutex			disc_mutex;
@@ -227,13 +227,14 @@ static inline void usb_set_serial_data(struct usb_serial *serial, void *data)
 struct usb_serial_driver {
 	const char *description;
 	const struct usb_device_id *id_table;
-	char	num_ports;
 
 	struct list_head	driver_list;
 	struct device_driver	driver;
 	struct usb_driver	*usb_driver;
 	struct usb_dynids	dynids;
 
+	unsigned char		num_ports;
+
 	size_t			bulk_in_size;
 	size_t			bulk_out_size;
 

commit bc4b1f486fe69b86769e07c8edce472327a8462b
Author: Johan Hovold <johan@kernel.org>
Date:   Sun Feb 15 11:57:53 2015 +0700

    Revert "USB: serial: make bulk_out_size a lower limit"
    
    This reverts commit 5083fd7bdfe6760577235a724cf6dccae13652c2.
    
    A bulk-out size smaller than the end-point size is indeed valid. The
    offending commit broke the usb-debug driver for EHCI debug devices,
    which use 8-byte buffers.
    
    Fixes: 5083fd7bdfe6 ("USB: serial: make bulk_out_size a lower limit")
    Reported-by: "Li, Elvin" <elvin.li@intel.com>
    Cc: stable <stable@vger.kernel.org>     # v3.15
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 9bb547c7bce7..704a1ab8240c 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -190,8 +190,7 @@ static inline void usb_set_serial_data(struct usb_serial *serial, void *data)
  * @num_ports: the number of different ports this device will have.
  * @bulk_in_size: minimum number of bytes to allocate for bulk-in buffer
  *	(0 = end-point size)
- * @bulk_out_size: minimum number of bytes to allocate for bulk-out buffer
- *	(0 = end-point size)
+ * @bulk_out_size: bytes to allocate for bulk-out buffer (0 = end-point size)
  * @calc_num_ports: pointer to a function to determine how many ports this
  *	device has dynamically.  It will be called after the probe()
  *	callback is called, but before attach()

commit 5083fd7bdfe6760577235a724cf6dccae13652c2
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Mar 12 19:09:38 2014 +0100

    USB: serial: make bulk_out_size a lower limit
    
    Drivers are allowed to override the default bulk-out buffer size
    (endpoint maximum packet size) in order to increase throughput, but it
    does not make much sense to allow buffers smaller than the default.
    
    Note that this is already how bulk_in_size is defined.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 704a1ab8240c..9bb547c7bce7 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -190,7 +190,8 @@ static inline void usb_set_serial_data(struct usb_serial *serial, void *data)
  * @num_ports: the number of different ports this device will have.
  * @bulk_in_size: minimum number of bytes to allocate for bulk-in buffer
  *	(0 = end-point size)
- * @bulk_out_size: bytes to allocate for bulk-out buffer (0 = end-point size)
+ * @bulk_out_size: minimum number of bytes to allocate for bulk-out buffer
+ *	(0 = end-point size)
  * @calc_num_ports: pointer to a function to determine how many ports this
  *	device has dynamically.  It will be called after the probe()
  *	callback is called, but before attach()

commit 706cd17e8559c96dc883ba692c931f1ef31fbc5c
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Oct 9 17:01:12 2013 +0200

    USB: serial: export usb_serial_generic_write_start
    
    Export usb_serial_generic_write_start which is needed when implementing
    a custom resume function while still relying on the generic write
    implementation.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index d528b8045150..704a1ab8240c 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -320,6 +320,8 @@ extern struct usb_serial_port *usb_serial_port_get_by_minor(unsigned int minor);
 extern void usb_serial_put(struct usb_serial *serial);
 extern int usb_serial_generic_open(struct tty_struct *tty,
 	struct usb_serial_port *port);
+extern int usb_serial_generic_write_start(struct usb_serial_port *port,
+							gfp_t mem_flags);
 extern int usb_serial_generic_write(struct tty_struct *tty,
 	struct usb_serial_port *port, const unsigned char *buf, int count);
 extern void usb_serial_generic_close(struct usb_serial_port *port);

commit 455b4f7e18e741c0603f9030f9a1897f4c5150c1
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jun 6 10:31:35 2013 -0700

    USB: serial: increase the number of devices we support
    
    We had the limit of 255 USB to serial devices on one system for almost
    15 years, with no complaints.  But now it's time to move on from these
    tiny "baby" systems, and bump the number up to 512, which should last
    us a few more years:
            "512 is a nice number" -- Tobias Winter
    
    Note, this is still a static value, and uses up tty core memory with
    this many tty devices allocated.  Converting the driver to use
    TTY_DRIVER_DYNAMIC_DEV is the next thing to do in order to remove this
    limitation.
    
    Reported-by: Tobias Winter <tobias@linuxdingsda.de>
    Tested-by: Tobias Winter <tobias@linuxdingsda.de>
    Reviewed-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 9254c80a1cf8..d528b8045150 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -19,9 +19,6 @@
 #include <linux/sysrq.h>
 #include <linux/kfifo.h>
 
-#define SERIAL_TTY_MAJOR	188	/* Nice legal number now */
-#define SERIAL_TTY_MINORS	254	/* loads of devices :) */
-
 /* The maximum number of ports one device can grab at once */
 #define MAX_NUM_PORTS		8
 

commit e5b1e2062e0535e8ffef79bb34d857e21380d101
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jun 7 11:04:28 2013 -0700

    USB: serial: make minor allocation dynamic
    
    This moves the allocation of minor device numbers from a static array to
    be dynamic, using the idr interface.  This means that you could
    potentially get "gaps" in a minor number range for a single USB serial
    device with multiple ports, but all should still work properly.
    
    We remove the 'minor' field from the usb_serial structure, as it no
    longer makes any sense for it (use the field in the usb_serial_port
    structure if you really want to know this number), and take the fact
    that we were overloading a number in this field to determine if we had
    initialized the minor numbers or not, and just use a flag variable
    instead.
    
    Note, we still have the limitation of 255 USB to serial devices in the
    system, as that is all we are registering with the TTY layer at this
    point in time.
    
    Tested-by: Tobias Winter <tobias@linuxdingsda.de>
    Reviewed-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 3fa68b615ac1..9254c80a1cf8 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -21,7 +21,6 @@
 
 #define SERIAL_TTY_MAJOR	188	/* Nice legal number now */
 #define SERIAL_TTY_MINORS	254	/* loads of devices :) */
-#define SERIAL_TTY_NO_MINOR	255	/* No minor was assigned */
 
 /* The maximum number of ports one device can grab at once */
 #define MAX_NUM_PORTS		8
@@ -142,7 +141,6 @@ static inline void usb_set_serial_port_data(struct usb_serial_port *port,
  * @dev: pointer to the struct usb_device for this device
  * @type: pointer to the struct usb_serial_driver for this device
  * @interface: pointer to the struct usb_interface for this device
- * @minor: the starting minor number for this device
  * @num_ports: the number of ports this device has
  * @num_interrupt_in: number of interrupt in endpoints we have
  * @num_interrupt_out: number of interrupt out endpoints we have
@@ -161,7 +159,7 @@ struct usb_serial {
 	unsigned char			disconnected:1;
 	unsigned char			suspending:1;
 	unsigned char			attached:1;
-	unsigned char			minor;
+	unsigned char			minors_reserved:1;
 	unsigned char			num_ports;
 	unsigned char			num_port_pointers;
 	char				num_interrupt_in;
@@ -321,7 +319,7 @@ static inline void usb_serial_console_disconnect(struct usb_serial *serial) {}
 #endif
 
 /* Functions needed by other parts of the usbserial core */
-extern struct usb_serial *usb_serial_get_by_index(unsigned int minor);
+extern struct usb_serial_port *usb_serial_port_get_by_minor(unsigned int minor);
 extern void usb_serial_put(struct usb_serial *serial);
 extern int usb_serial_generic_open(struct tty_struct *tty,
 	struct usb_serial_port *port);

commit 1143832eca8f1d64da7d85642c956ae9d25c69e1
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jun 6 10:32:00 2013 -0700

    USB: serial: ports: add minor and port number
    
    The usb_serial_port structure had the number field, which was the minor
    number for the port, which almost no one really cared about.  They
    really wanted the number of the port within the device, which you had to
    subtract from the minor of the parent usb_serial_device structure.  To
    clean this up, provide the real minor number of the port, and the number
    of the port within the serial device separately, as these numbers might
    not be related in the future.
    
    Bonus is that this cleans up a lot of logic in the drivers, and saves
    lines overall.
    
    Tested-by: Tobias Winter <tobias@linuxdingsda.de>
    Reviewed-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    
    --
     drivers/staging/serqt_usb2/serqt_usb2.c |   21 +++--------
     drivers/usb/serial/ark3116.c            |    2 -
     drivers/usb/serial/bus.c                |    6 +--
     drivers/usb/serial/console.c            |    2 -
     drivers/usb/serial/cp210x.c             |    2 -
     drivers/usb/serial/cypress_m8.c         |    4 +-
     drivers/usb/serial/digi_acceleport.c    |    6 ---
     drivers/usb/serial/f81232.c             |    5 +-
     drivers/usb/serial/garmin_gps.c         |    6 +--
     drivers/usb/serial/io_edgeport.c        |   58 ++++++++++++--------------------
     drivers/usb/serial/io_ti.c              |   21 ++++-------
     drivers/usb/serial/keyspan.c            |   29 +++++++---------
     drivers/usb/serial/metro-usb.c          |    4 +-
     drivers/usb/serial/mos7720.c            |   37 +++++++++-----------
     drivers/usb/serial/mos7840.c            |   52 +++++++++-------------------
     drivers/usb/serial/opticon.c            |    2 -
     drivers/usb/serial/pl2303.c             |    2 -
     drivers/usb/serial/quatech2.c           |    7 +--
     drivers/usb/serial/sierra.c             |    2 -
     drivers/usb/serial/ti_usb_3410_5052.c   |   10 ++---
     drivers/usb/serial/usb-serial.c         |    7 ++-
     drivers/usb/serial/usb_wwan.c           |    2 -
     drivers/usb/serial/whiteheat.c          |   20 +++++------
     include/linux/usb/serial.h              |    6 ++-
     24 files changed, 133 insertions(+), 180 deletions(-)

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 302ddf55d2da..3fa68b615ac1 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -37,7 +37,8 @@
  * @serial: pointer back to the struct usb_serial owner of this port.
  * @port: pointer to the corresponding tty_port for this port.
  * @lock: spinlock to grab when updating portions of this structure.
- * @number: the number of the port (the minor number).
+ * @minor: the minor number of the port
+ * @port_number: the struct usb_serial port number of this port (starts at 0)
  * @interrupt_in_buffer: pointer to the interrupt in buffer for this port.
  * @interrupt_in_urb: pointer to the interrupt in struct urb for this port.
  * @interrupt_in_endpointAddress: endpoint address for the interrupt in pipe
@@ -80,7 +81,8 @@ struct usb_serial_port {
 	struct usb_serial	*serial;
 	struct tty_port		port;
 	spinlock_t		lock;
-	unsigned char		number;
+	u32			minor;
+	u8			port_number;
 
 	unsigned char		*interrupt_in_buffer;
 	struct urb		*interrupt_in_urb;

commit dcf0105039660e951dfea348d317043d17988dfc
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed May 8 17:51:43 2013 +0200

    USB: serial: add generic wait_until_sent implementation
    
    Add generic wait_until_sent implementation which polls for empty
    hardware buffers using the new port-operation tx_empty.
    
    The generic implementation will be used for all sub-drivers that
    implement tx_empty but does not define wait_until_sent.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index afbb7eeaac5f..302ddf55d2da 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -269,6 +269,7 @@ struct usb_serial_driver {
 	void (*break_ctl)(struct tty_struct *tty, int break_state);
 	int  (*chars_in_buffer)(struct tty_struct *tty);
 	void (*wait_until_sent)(struct tty_struct *tty, long timeout);
+	bool (*tx_empty)(struct usb_serial_port *port);
 	void (*throttle)(struct tty_struct *tty);
 	void (*unthrottle)(struct tty_struct *tty);
 	int  (*tiocmget)(struct tty_struct *tty);
@@ -328,6 +329,8 @@ extern void usb_serial_generic_close(struct usb_serial_port *port);
 extern int usb_serial_generic_resume(struct usb_serial *serial);
 extern int usb_serial_generic_write_room(struct tty_struct *tty);
 extern int usb_serial_generic_chars_in_buffer(struct tty_struct *tty);
+extern void usb_serial_generic_wait_until_sent(struct tty_struct *tty,
+								long timeout);
 extern void usb_serial_generic_read_bulk_callback(struct urb *urb);
 extern void usb_serial_generic_write_bulk_callback(struct urb *urb);
 extern void usb_serial_generic_throttle(struct tty_struct *tty);

commit 0693196fe7bbb5e6cafd255dfce91ff6d10bc18f
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun May 5 20:32:27 2013 +0200

    USB: serial: add wait_until_sent operation
    
    Add wait_until_sent operation which can be used to wait for hardware
    buffers to drain.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index b9b0f7b4e43b..afbb7eeaac5f 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -268,6 +268,7 @@ struct usb_serial_driver {
 			struct usb_serial_port *port, struct ktermios *old);
 	void (*break_ctl)(struct tty_struct *tty, int break_state);
 	int  (*chars_in_buffer)(struct tty_struct *tty);
+	void (*wait_until_sent)(struct tty_struct *tty, long timeout);
 	void (*throttle)(struct tty_struct *tty);
 	void (*unthrottle)(struct tty_struct *tty);
 	int  (*tiocmget)(struct tty_struct *tty);

commit 53ab34dc50ad99366257d34cdb8a84f24250d611
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Mar 21 12:37:35 2013 +0100

    USB: serial: remove unused MSR-wait queue
    
    Remove the port MSR-wait queue now that all drivers have been migrated
    to the tty-port queue.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index c786ee7fca8f..b9b0f7b4e43b 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -68,7 +68,6 @@
  *	port.
  * @flags: usb serial port flags
  * @write_wait: a wait_queue_head_t used by the port.
- * @delta_msr_wait: modem-status-change wait queue
  * @work: work queue entry for the line discipline waking up.
  * @throttled: nonzero if the read urb is inactive to throttle the device
  * @throttle_req: nonzero if the tty wants to throttle us
@@ -116,7 +115,6 @@ struct usb_serial_port {
 
 	unsigned long		flags;
 	wait_queue_head_t	write_wait;
-	wait_queue_head_t	delta_msr_wait;
 	struct work_struct	work;
 	char			throttled;
 	char			throttle_req;

commit befefcda4bddc52d29248931801961a72aeef28b
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Mar 21 12:36:54 2013 +0100

    USB: serial: add generic get_icount implementation
    
    Add generic get_icount implementation that subdrivers relying on the
    port interrupt counters can use.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 47c8d2c506c8..c786ee7fca8f 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -335,6 +335,8 @@ extern void usb_serial_generic_throttle(struct tty_struct *tty);
 extern void usb_serial_generic_unthrottle(struct tty_struct *tty);
 extern int usb_serial_generic_tiocmiwait(struct tty_struct *tty,
 							unsigned long arg);
+extern int usb_serial_generic_get_icount(struct tty_struct *tty,
+					struct serial_icounter_struct *icount);
 extern int usb_serial_generic_register(void);
 extern void usb_serial_generic_deregister(void);
 extern int usb_serial_generic_submit_read_urbs(struct usb_serial_port *port,

commit 980373b7918b8023be6b7df03857f494ae124d0b
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Mar 21 12:36:52 2013 +0100

    USB: serial: add generic TIOCMIWAIT implementation
    
    Add generic TIOCMIWAIT implementation which correctly handles hangup,
    USB-device disconnect, does not rely on the deprecated sleep_on
    functions and hence does not suffer from the races currently affecting
    several usb-serial drivers.
    
    This makes it much easier to add TIOCMIWAIT support to subdrivers as the
    tricky details related to hangup and disconnect (e.g. atomicity, that
    the private port data may have been freed when woken up, and waking up
    processes at disconnect) have been handled once and for all.
    
    To add support to a subdriver, simply set the tiocmiwait-port-operation
    field, update the port icount fields and wake up any process sleeping on
    the tty-port modem-status-change wait queue on changes.
    
    Note that the tty-port initialised flag can be used to detect
    disconnected as the port will be hung up as part of disconnect (and
    cannot be reactivated due to the disconnected flag). However, as the
    tty-port implementation currently wakes up processes before calling port
    shutdown, the tty-hupping flag must also be checked to detect hangup for
    now.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 9c8b53f80f48..47c8d2c506c8 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -15,6 +15,7 @@
 
 #include <linux/kref.h>
 #include <linux/mutex.h>
+#include <linux/serial.h>
 #include <linux/sysrq.h>
 #include <linux/kfifo.h>
 
@@ -61,6 +62,7 @@
  * @bulk_out_buffers: pointers to the bulk out buffers for this port
  * @write_urbs: pointers to the bulk out urbs for this port
  * @write_urbs_free: status bitmap the for bulk out urbs
+ * @icount: interrupt counters
  * @tx_bytes: number of bytes currently in host stack queues
  * @bulk_out_endpointAddress: endpoint address for the bulk out pipe for this
  *	port.
@@ -109,6 +111,7 @@ struct usb_serial_port {
 	unsigned long		write_urbs_free;
 	__u8			bulk_out_endpointAddress;
 
+	struct async_icount	icount;
 	int			tx_bytes;
 
 	unsigned long		flags;
@@ -330,6 +333,8 @@ extern void usb_serial_generic_read_bulk_callback(struct urb *urb);
 extern void usb_serial_generic_write_bulk_callback(struct urb *urb);
 extern void usb_serial_generic_throttle(struct tty_struct *tty);
 extern void usb_serial_generic_unthrottle(struct tty_struct *tty);
+extern int usb_serial_generic_tiocmiwait(struct tty_struct *tty,
+							unsigned long arg);
 extern int usb_serial_generic_register(void);
 extern void usb_serial_generic_deregister(void);
 extern int usb_serial_generic_submit_read_urbs(struct usb_serial_port *port,

commit 143d9d961608b737d90a813deaaf91affb41c83c
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Mar 21 12:36:51 2013 +0100

    USB: serial: add tiocmiwait subdriver operation
    
    Add tiocmiwait operation to struct usb_serial_driver.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 3f8f5e3c76d5..9c8b53f80f48 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -272,6 +272,7 @@ struct usb_serial_driver {
 	int  (*tiocmget)(struct tty_struct *tty);
 	int  (*tiocmset)(struct tty_struct *tty,
 			 unsigned int set, unsigned int clear);
+	int  (*tiocmiwait)(struct tty_struct *tty, unsigned long arg);
 	int  (*get_icount)(struct tty_struct *tty,
 			struct serial_icounter_struct *icount);
 	/* Called by the tty layer for port level work. There may or may not

commit 79b80b8a1141ba0605e917a6fc12d44383ab29b8
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Mar 21 12:36:43 2013 +0100

    USB: serial: remove generic release callback
    
    Remove empty generic release implementation and make the release
    callback non-mandatory (like attach, probe and disconnect).
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 437dfd6787f9..3f8f5e3c76d5 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -329,7 +329,6 @@ extern void usb_serial_generic_read_bulk_callback(struct urb *urb);
 extern void usb_serial_generic_write_bulk_callback(struct urb *urb);
 extern void usb_serial_generic_throttle(struct tty_struct *tty);
 extern void usb_serial_generic_unthrottle(struct tty_struct *tty);
-extern void usb_serial_generic_release(struct usb_serial *serial);
 extern int usb_serial_generic_register(void);
 extern void usb_serial_generic_deregister(void);
 extern int usb_serial_generic_submit_read_urbs(struct usb_serial_port *port,

commit 0f16cfe39eeef47c91aa3c3bf2b49954d5313a58
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Mar 21 12:36:42 2013 +0100

    USB: serial: remove generic disconnect callback
    
    Remove the now empty generic disconnect callback and make the disconnect
    callback non-mandatory.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 1819b59aab2a..437dfd6787f9 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -329,7 +329,6 @@ extern void usb_serial_generic_read_bulk_callback(struct urb *urb);
 extern void usb_serial_generic_write_bulk_callback(struct urb *urb);
 extern void usb_serial_generic_throttle(struct tty_struct *tty);
 extern void usb_serial_generic_unthrottle(struct tty_struct *tty);
-extern void usb_serial_generic_disconnect(struct usb_serial *serial);
 extern void usb_serial_generic_release(struct usb_serial *serial);
 extern int usb_serial_generic_register(void);
 extern void usb_serial_generic_deregister(void);

commit e5b33dc9d16053c2ae4c2c669cf008829530364b
Author: Johan Hovold <jhovold@gmail.com>
Date:   Tue Mar 19 09:21:10 2013 +0100

    USB: serial: add modem-status-change wait queue
    
    Add modem-status-change wait queue to struct usb_serial_port that
    subdrivers can use to implement TIOCMIWAIT.
    
    Currently subdrivers use a private wait queue which may have been
    released when waking up after device disconnected.
    
    Note that we're adding a new wait queue rather than reusing the tty-port
    one as we do not want to get woken up at hangup (yet).
    
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index ef9be7e1e190..1819b59aab2a 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -66,6 +66,7 @@
  *	port.
  * @flags: usb serial port flags
  * @write_wait: a wait_queue_head_t used by the port.
+ * @delta_msr_wait: modem-status-change wait queue
  * @work: work queue entry for the line discipline waking up.
  * @throttled: nonzero if the read urb is inactive to throttle the device
  * @throttle_req: nonzero if the tty wants to throttle us
@@ -112,6 +113,7 @@ struct usb_serial_port {
 
 	unsigned long		flags;
 	wait_queue_head_t	write_wait;
+	wait_queue_head_t	delta_msr_wait;
 	struct work_struct	work;
 	char			throttled;
 	char			throttle_req;

commit cc183e2a5ebfdddc8d3498149cae6b4c40551a68
Author: Rene Buergel <rene.buergel@sohard.de>
Date:   Tue Sep 18 09:00:41 2012 +0200

    USB: ezusb: add support for Cypress FX2LP
    
    This Patch adds support for the newer Cypress FX2LP. It also adapts
    three drivers currently using ezusb to the interface change. (whiteheat
    and keyspan[_pda])
    
    Signed-off-by: René Bürgel <rene.buergel@sohard.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 5808713aa492..ef9be7e1e190 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -301,10 +301,6 @@ extern void usb_serial_port_softint(struct usb_serial_port *port);
 extern int usb_serial_suspend(struct usb_interface *intf, pm_message_t message);
 extern int usb_serial_resume(struct usb_interface *intf);
 
-extern int ezusb_writememory(struct usb_device *dev, int address,
-			     unsigned char *data, int length, __u8 bRequest);
-extern int ezusb_set_reset(struct usb_device *dev, unsigned char reset_bit);
-
 /* USB Serial console functions */
 #ifdef CONFIG_USB_SERIAL_CONSOLE
 extern void usb_serial_console_init(int minor);

commit 3033bc8d74c1a9d9104b9f231283e780e6dd8de7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Sep 18 16:05:17 2012 +0100

    USB: Serial: usb-serial: remove debug module parameter
    
    Now that all usb-serial modules are only using dev_dbg()
    the debug module parameter does not do anything at all, so
    remove it to reduce any confusion if someone were to try
    to use it.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index b2b6d159b26b..5808713aa492 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -307,11 +307,11 @@ extern int ezusb_set_reset(struct usb_device *dev, unsigned char reset_bit);
 
 /* USB Serial console functions */
 #ifdef CONFIG_USB_SERIAL_CONSOLE
-extern void usb_serial_console_init(int debug, int minor);
+extern void usb_serial_console_init(int minor);
 extern void usb_serial_console_exit(void);
 extern void usb_serial_console_disconnect(struct usb_serial *serial);
 #else
-static inline void usb_serial_console_init(int debug, int minor) { }
+static inline void usb_serial_console_init(int minor) { }
 static inline void usb_serial_console_exit(void) { }
 static inline void usb_serial_console_disconnect(struct usb_serial *serial) {}
 #endif
@@ -333,7 +333,7 @@ extern void usb_serial_generic_throttle(struct tty_struct *tty);
 extern void usb_serial_generic_unthrottle(struct tty_struct *tty);
 extern void usb_serial_generic_disconnect(struct usb_serial *serial);
 extern void usb_serial_generic_release(struct usb_serial *serial);
-extern int usb_serial_generic_register(int debug);
+extern int usb_serial_generic_register(void);
 extern void usb_serial_generic_deregister(void);
 extern int usb_serial_generic_submit_read_urbs(struct usb_serial_port *port,
 						 gfp_t mem_flags);

commit 59d33f2fc2d63796296b1b76143e039d6e7cf532
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Sep 18 09:58:57 2012 +0100

    USB: serial: remove debug parameter from usb_serial_debug_data()
    
    We should use dev_dbg() for usb_serial_debug_data() like all of the rest
    of the usb-serial drivers use, so remove the debug parameter as it's not
    needed.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index e71bc5ef234a..b2b6d159b26b 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -355,14 +355,12 @@ extern struct usb_serial_driver usb_serial_generic_device;
 extern struct bus_type usb_serial_bus_type;
 extern struct tty_driver *usb_serial_tty_driver;
 
-static inline void usb_serial_debug_data(int debug,
-					 struct device *dev,
+static inline void usb_serial_debug_data(struct device *dev,
 					 const char *function, int size,
 					 const unsigned char *data)
 {
-	if (debug)
-		dev_printk(KERN_DEBUG, dev, "%s - length = %d, data = %*ph\n",
-			   function, size, size, data);
+	dev_dbg(dev, "%s - length = %d, data = %*ph\n",
+		function, size, size, data);
 }
 
 /*

commit 82760526e6d2e1d1e815abaf3eae42b8bb82968c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Sep 18 09:38:33 2012 +0100

    USB: serial: remove dbg() from usb/serial.h
    
    Now that all in-kernel users of the dbg() macro are gone, we can remove
    it from the include/linux/usb/serial.h file.
    
    Good riddance.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 6bed6db619b2..e71bc5ef234a 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -365,14 +365,6 @@ static inline void usb_serial_debug_data(int debug,
 			   function, size, size, data);
 }
 
-/* Use our own dbg macro */
-#undef dbg
-#define dbg(format, arg...)						\
-do {									\
-	if (debug)							\
-		printk(KERN_DEBUG "%s: " format "\n", __FILE__, ##arg);	\
-} while (0)
-
 /*
  * Macro for reporting errors in write path to avoid inifinite loop
  * when port is used as a console.

commit 99495c7061892f0312c0119725b550bb221634ce
Author: Rene Buergel <rene.buergel@sohard.de>
Date:   Thu Sep 13 22:14:38 2012 +0200

    USB: ezusb: remove dependancy on usb_serial
    
    This patch removes the dependency on the usb_serial interface and names
    some magic constants
    
    Signed-off-by: René Bürgel <rene.buergel@sohard.de>
    --
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 9e9a0a8991e4..6bed6db619b2 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -301,9 +301,9 @@ extern void usb_serial_port_softint(struct usb_serial_port *port);
 extern int usb_serial_suspend(struct usb_interface *intf, pm_message_t message);
 extern int usb_serial_resume(struct usb_interface *intf);
 
-extern int ezusb_writememory(struct usb_serial *serial, int address,
+extern int ezusb_writememory(struct usb_device *dev, int address,
 			     unsigned char *data, int length, __u8 bRequest);
-extern int ezusb_set_reset(struct usb_serial *serial, unsigned char reset_bit);
+extern int ezusb_set_reset(struct usb_device *dev, unsigned char reset_bit);
 
 /* USB Serial console functions */
 #ifdef CONFIG_USB_SERIAL_CONSOLE

commit 1db9e45c340213d3b19d456fbf678406c1334959
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Sep 13 09:19:05 2012 -0700

    USB: serial: move usb_serial_debug_data to use %*ph
    
    Now that we have a printk modifier for data streams, use it instead of
    rolling our own.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 86c0b451745d..9e9a0a8991e4 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -360,15 +360,9 @@ static inline void usb_serial_debug_data(int debug,
 					 const char *function, int size,
 					 const unsigned char *data)
 {
-	int i;
-
-	if (debug) {
-		dev_printk(KERN_DEBUG, dev, "%s - length = %d, data = ",
-			   function, size);
-		for (i = 0; i < size; ++i)
-			printk("%.2x ", data[i]);
-		printk("\n");
-	}
+	if (debug)
+		dev_printk(KERN_DEBUG, dev, "%s - length = %d, data = %*ph\n",
+			   function, size, size, data);
 }
 
 /* Use our own dbg macro */

commit 7186364e46c3800635c283924bf25433d0a556a2
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue May 15 15:40:00 2012 -0700

    USB: serial: hook up reset_resume callback
    
    The callback is now hooked up for any USB to serial driver that wants
    it.  We only register the callback if any of the usb-serial structures
    want it, this keeps the USB core happy.
    
    Thanks to Alan Stern for the ideas on how to do this.
    
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index c9f65146a039..86c0b451745d 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -1,7 +1,7 @@
 /*
  * USB Serial Converter stuff
  *
- *	Copyright (C) 1999 - 2005
+ *	Copyright (C) 1999 - 2012
  *	    Greg Kroah-Hartman (greg@kroah.com)
  *
  *	This program is free software; you can redistribute it and/or modify
@@ -249,6 +249,7 @@ struct usb_serial_driver {
 
 	int (*suspend)(struct usb_serial *serial, pm_message_t message);
 	int (*resume)(struct usb_serial *serial);
+	int (*reset_resume)(struct usb_serial *serial);
 
 	/* serial function calls */
 	/* Called by console and by the tty layer */

commit 68e24113457e437b1576670f2419b77ed0531e9e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue May 8 15:46:14 2012 -0700

    USB: serial: rework usb_serial_register/deregister_drivers()
    
    This reworks the usb_serial_register_drivers() and
    usb_serial_deregister_drivers() to not need a pointer to a struct
    usb_driver anymore.  The usb_driver structure is now created dynamically
    and registered and unregistered as needed.
    
    This saves lines of code in each usb-serial driver.  All in-kernel users
    of these functions were also fixed up at this time.  The pl2303 driver
    was tested that everything worked properly.
    
    Thanks for the idea to do this from Alan Stern.
    
    Cc: Adhir Ramjiawan <adhirramjiawan0@gmail.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Al Borchers <alborchers@steinerpoint.com>
    Cc: Aleksey Babahin <tamerlan311@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andrew Worsley <amworsley@gmail.com>
    Cc: Bart Hartgers <bart.hartgers@gmail.com>
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Dan Carpenter <error27@gmail.com>
    Cc: Dan Williams <dcbw@redhat.com>
    Cc: Donald Lee <donald@asix.com.tw>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Gary Brubaker <xavyer@ix.netcom.com>
    Cc: Jesper Juhl <jj@chaosbits.net>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Kautuk Consul <consul.kautuk@gmail.com>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Lonnie Mendez <dignome@gmail.com>
    Cc: Matthias Bruestle and Harald Welte <support@reiner-sct.com>
    Cc: Matthias Urlichs <smurf@smurf.noris.de>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Michal Sroczynski <msroczyn@gmail.com>
    Cc: "Michał Wróbel" <michal.wrobel@flytronic.pl>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Peter Berger <pberger@brimson.com>
    Cc: Preston Fick <preston.fick@silabs.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Rigbert Hamisch <rigbert@gmx.de>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Simon Arlott <simon@fire.lp0.eu>
    Cc: Support Department <support@connecttech.com>
    Cc: Thomas Tuttle <ttuttle@chromium.org>
    Cc: Uwe Bonnes <bon@elektron.ikp.physik.tu-darmstadt.de>
    Cc: Wang YanQing <Udknight@gmail.com>
    Cc: William Greathouse <wgreathouse@smva.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 749836f2890c..c9f65146a039 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -292,10 +292,9 @@ struct usb_serial_driver {
 #define to_usb_serial_driver(d) \
 	container_of(d, struct usb_serial_driver, driver)
 
-extern int usb_serial_register_drivers(struct usb_driver *udriver,
-		struct usb_serial_driver * const serial_drivers[]);
-extern void usb_serial_deregister_drivers(struct usb_driver *udriver,
-		struct usb_serial_driver * const serial_drivers[]);
+extern int usb_serial_register_drivers(struct usb_serial_driver *const serial_drivers[],
+		const char *name, const struct usb_device_id *id_table);
+extern void usb_serial_deregister_drivers(struct usb_serial_driver *const serial_drivers[]);
 extern void usb_serial_port_softint(struct usb_serial_port *port);
 
 extern int usb_serial_suspend(struct usb_interface *intf, pm_message_t message);
@@ -396,8 +395,8 @@ do {									\
 
 /*
  * module_usb_serial_driver() - Helper macro for registering a USB Serial driver
- * @__usb_driver: usb_driver struct to register
  * @__serial_drivers: list of usb_serial drivers to register
+ * @__ids: all device ids that @__serial_drivers bind to
  *
  * Helper macro for USB serial drivers which do not do anything special
  * in module init/exit. This eliminates a lot of boilerplate. Each
@@ -405,9 +404,21 @@ do {									\
  * module_init() and module_exit()
  *
  */
-#define module_usb_serial_driver(__usb_driver, __serial_drivers)	\
-	module_driver(__usb_driver, usb_serial_register_drivers,	\
-		       usb_serial_deregister_drivers, __serial_drivers)
+#define usb_serial_module_driver(__name, __serial_drivers, __ids)	\
+static int __init usb_serial_module_init(void)				\
+{									\
+	return usb_serial_register_drivers(__serial_drivers,		\
+					   __name, __ids);		\
+}									\
+module_init(usb_serial_module_init);					\
+static void __exit usb_serial_module_exit(void)				\
+{									\
+	usb_serial_deregister_drivers(__serial_drivers);		\
+}									\
+module_exit(usb_serial_module_exit);
+
+#define module_usb_serial_driver(__serial_drivers, __ids)		\
+	usb_serial_module_driver(KBUILD_MODNAME, __serial_drivers, __ids)
 
 #endif /* __LINUX_USB_SERIAL_H */
 

commit 2edd284bd752e58ccb312f3d623267fb79857db3
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 7 14:46:48 2012 -0700

    USB: serial: remove bizarre generic_serial probe function
    
    I can't remember why I wrote it like this many many years ago, but it's
    not needed at all, let's rely on the usb-serial core for this function,
    especially as it is being overridden by it anyway.
    
    This lets us make usb_serial_probe() a static function, which it should
    be.
    
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 17e9746bbeb0..749836f2890c 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -298,9 +298,6 @@ extern void usb_serial_deregister_drivers(struct usb_driver *udriver,
 		struct usb_serial_driver * const serial_drivers[]);
 extern void usb_serial_port_softint(struct usb_serial_port *port);
 
-extern int usb_serial_probe(struct usb_interface *iface,
-			    const struct usb_device_id *id);
-
 extern int usb_serial_suspend(struct usb_interface *intf, pm_message_t message);
 extern int usb_serial_resume(struct usb_interface *intf);
 

commit 32078f915d1acab356080b144aa89fe3487f3979
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 7 14:02:13 2012 -0700

    USB: serial: remove usb_serial_disconnect call in all drivers
    
    This is now set by the usb-serial core, no need for the driver to
    individually set it.
    
    Thanks to Alan Stern for the idea to get rid of it.
    
    Cc: William Greathouse <wgreathouse@smva.com>
    Cc: Matthias Bruestle and Harald Welte <support@reiner-sct.com>
    Cc: Lonnie Mendez <dignome@gmail.com>
    Cc: Peter Berger <pberger@brimson.com>
    Cc: Al Borchers <alborchers@steinerpoint.com>
    Cc: Gary Brubaker <xavyer@ix.netcom.com>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: Matthias Urlichs <smurf@smurf.noris.de>
    Cc: Support Department <support@connecttech.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Kautuk Consul <consul.kautuk@gmail.com>
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Bart Hartgers <bart.hartgers@gmail.com>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Preston Fick <preston.fick@silabs.com>
    Cc: Uwe Bonnes <bon@elektron.ikp.physik.tu-darmstadt.de>
    Cc: Simon Arlott <simon@fire.lp0.eu>
    Cc: Andrew Worsley <amworsley@gmail.com>
    Cc: "Michał Wróbel" <michal.wrobel@flytronic.pl>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Aleksey Babahin <tamerlan311@gmail.com>
    Cc: Dan Carpenter <error27@gmail.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Donald Lee <donald@asix.com.tw>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Michal Sroczynski <msroczyn@gmail.com>
    Cc: Wang YanQing <Udknight@gmail.com>
    Cc: Dan Williams <dcbw@redhat.com>
    Cc: Thomas Tuttle <ttuttle@chromium.org>
    Cc: Rigbert Hamisch <rigbert@gmx.de>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Jesper Juhl <jj@chaosbits.net>
    Cc: Adhir Ramjiawan <adhirramjiawan0@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 474283888233..17e9746bbeb0 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -300,7 +300,6 @@ extern void usb_serial_port_softint(struct usb_serial_port *port);
 
 extern int usb_serial_probe(struct usb_interface *iface,
 			    const struct usb_device_id *id);
-extern void usb_serial_disconnect(struct usb_interface *iface);
 
 extern int usb_serial_suspend(struct usb_interface *intf, pm_message_t message);
 extern int usb_serial_resume(struct usb_interface *intf);

commit 891a3b1fddb24b4b53426685bd0390bb74c9b5b3
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Mar 28 16:10:49 2012 -0400

    USB: fix bug in serial driver unregistration
    
    This patch (as1536) fixes a bug in the USB serial core.  Unloading and
    reloading a serial driver while a serial device is plugged in causes
    errors because of the code in usb_serial_disconnect() that tries to
    make sure the port_remove method is called.  With the new order of
    driver registration introduced in the 3.4 kernel, this is definitely
    not the right thing to do (if indeed it ever was).
    
    The patch removes that whole section code, along with the mechanism
    for keeping track of each port's registration state, which is no
    longer needed.  The driver core can handle all that stuff for us.
    
    Note: This has been tested only with one or two USB serial drivers.
    In theory, other drivers might still run into trouble.  But if they
    do, it will be the fault of the drivers, not of this patch -- that is,
    the drivers will need to be fixed.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-and-tested-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index fbb666b1b670..474283888233 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -28,13 +28,6 @@
 /* parity check flag */
 #define RELEVANT_IFLAG(iflag)	(iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
 
-enum port_dev_state {
-	PORT_UNREGISTERED,
-	PORT_REGISTERING,
-	PORT_REGISTERED,
-	PORT_UNREGISTERING,
-};
-
 /* USB serial flags */
 #define USB_SERIAL_WRITE_BUSY	0
 
@@ -124,7 +117,6 @@ struct usb_serial_port {
 	char			throttle_req;
 	unsigned long		sysrq; /* sysrq timeout */
 	struct device		dev;
-	enum port_dev_state	dev_state;
 };
 #define to_usb_serial_port(d) container_of(d, struct usb_serial_port, dev)
 

commit b790f5d1260b4c962bd066cd34ae982943c27fe1
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Mar 9 16:38:14 2012 -0800

    USB: serial: use module_driver() macro
    
    Now that module_driver() can handle varargs, use it instead of rolling
    our own version.
    
    Cc: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 7b1db841e2a8..fbb666b1b670 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -416,23 +416,10 @@ do {									\
  * module may only use this macro once, and calling it replaces
  * module_init() and module_exit()
  *
- * Note, we can't use the generic module_driver() call here, due to the
- * two parameters in the usb_serial_* functions, so we roll our own here
- * :(
  */
 #define module_usb_serial_driver(__usb_driver, __serial_drivers)	\
-static int __init usb_serial_driver_init(void)				\
-{									\
-	return usb_serial_register_drivers(&(__usb_driver),		\
-					   (__serial_drivers));		\
-}									\
-module_init(usb_serial_driver_init);					\
-static void __exit usb_serial_driver_exit(void)				\
-{									\
-	return usb_serial_deregister_drivers(&(__usb_driver),		\
-					     (__serial_drivers));	\
-}									\
-module_exit(usb_serial_driver_exit);
+	module_driver(__usb_driver, usb_serial_register_drivers,	\
+		       usb_serial_deregister_drivers, __serial_drivers)
 
 #endif /* __LINUX_USB_SERIAL_H */
 

commit d1cddb4a8e9b09c33158acae05c48069d74fa4d0
Author: Greg KH <gregkh@linuxfoundation.org>
Date:   Fri Feb 24 15:38:14 2012 -0800

    USB: create module_usb_serial_driver macro
    
    Now that Alan Stern has cleaned up the usb serial driver registration,
    we have the ability to create a module_usb_serial_driver macro to make
    things a bit simpler, like the other *_driver macros created.
    
    But, as we need two functions here, we can't reuse the existing
    module_driver() macro, so we need to roll our own.
    
    Here's a patch implementing module_usb_serial_driver() and it converts
    the pl2303 driver to use it, showing a nice cleanup.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 34c06a723dcc..7b1db841e2a8 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -406,5 +406,33 @@ do {									\
 	}								\
 } while (0)
 
+/*
+ * module_usb_serial_driver() - Helper macro for registering a USB Serial driver
+ * @__usb_driver: usb_driver struct to register
+ * @__serial_drivers: list of usb_serial drivers to register
+ *
+ * Helper macro for USB serial drivers which do not do anything special
+ * in module init/exit. This eliminates a lot of boilerplate. Each
+ * module may only use this macro once, and calling it replaces
+ * module_init() and module_exit()
+ *
+ * Note, we can't use the generic module_driver() call here, due to the
+ * two parameters in the usb_serial_* functions, so we roll our own here
+ * :(
+ */
+#define module_usb_serial_driver(__usb_driver, __serial_drivers)	\
+static int __init usb_serial_driver_init(void)				\
+{									\
+	return usb_serial_register_drivers(&(__usb_driver),		\
+					   (__serial_drivers));		\
+}									\
+module_init(usb_serial_driver_init);					\
+static void __exit usb_serial_driver_exit(void)				\
+{									\
+	return usb_serial_deregister_drivers(&(__usb_driver),		\
+					     (__serial_drivers));	\
+}									\
+module_exit(usb_serial_driver_exit);
+
 #endif /* __LINUX_USB_SERIAL_H */
 

commit f799e7678390029e322ae2dc3cda389b11f38124
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Feb 24 12:50:30 2012 -0800

    USB: serial: remove usb_serial_register and usb_serial_deregister
    
    No one uses them anymore, they should be using the safer
    usb_serial_register_drivers() and usb_serial_deregister_drivers()
    functions instead.
    
    Thanks to Alan Stern for writing these functions and porting all
    in-kernel users to them.
    
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 8c8dbf9c5b89..34c06a723dcc 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -300,13 +300,6 @@ struct usb_serial_driver {
 #define to_usb_serial_driver(d) \
 	container_of(d, struct usb_serial_driver, driver)
 
-/*
- * These two routines are kept only for backward compatibility.
- * Don't use them; call usb_serial_{de}register_drivers() instead.
- */
-extern int  usb_serial_register(struct usb_serial_driver *driver);
-extern void usb_serial_deregister(struct usb_serial_driver *driver);
-
 extern int usb_serial_register_drivers(struct usb_driver *udriver,
 		struct usb_serial_driver * const serial_drivers[]);
 extern void usb_serial_deregister_drivers(struct usb_driver *udriver,

commit 765e0ba62613fb90f09c1b5926750df0aa56f349
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Feb 23 14:55:59 2012 -0500

    usb-serial: new API for driver registration
    
    This patch (as1522) adds two new routines to the usb-serial core, for
    registering and unregistering serial drivers.  Instead of registering
    the usb_driver and usb_serial_drivers separately, with error checking
    for each one, the drivers can all be registered and unregistered by a
    single function call.  This reduces duplicated code.
    
    More importantly, the new core routines change the order in which the
    drivers are registered.  Currently the usb-serial drivers are all
    registered first and the usb_driver is done last, which leaves a
    window for problems.  A udev script may quickly add a new dynamic-ID
    for a usb-serial driver, causing the corresponding usb_driver to be
    probed.  If the usb_driver hasn't been registered yet then an oops
    will occur.
    
    The new routine prevents such problems by registering the usb_driver
    first.  To insure that it gets probed properly for already-attached
    serial devices, we call driver_attach() after all the usb-serial
    drivers have been registered.
    
    Along with adding the new routines, the patch modifies the "generic"
    serial driver to use them.  Further patches will similarly modify all
    the other in-tree USB serial drivers.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 10cb74d2ad1d..8c8dbf9c5b89 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -300,8 +300,17 @@ struct usb_serial_driver {
 #define to_usb_serial_driver(d) \
 	container_of(d, struct usb_serial_driver, driver)
 
+/*
+ * These two routines are kept only for backward compatibility.
+ * Don't use them; call usb_serial_{de}register_drivers() instead.
+ */
 extern int  usb_serial_register(struct usb_serial_driver *driver);
 extern void usb_serial_deregister(struct usb_serial_driver *driver);
+
+extern int usb_serial_register_drivers(struct usb_driver *udriver,
+		struct usb_serial_driver * const serial_drivers[]);
+extern void usb_serial_deregister_drivers(struct usb_driver *udriver,
+		struct usb_serial_driver * const serial_drivers[]);
 extern void usb_serial_port_softint(struct usb_serial_port *port);
 
 extern int usb_serial_probe(struct usb_interface *iface,

commit e688355bfeadf17ef522b1e62cc12f8e88e69667
Author: Johan Hovold <jhovold@gmail.com>
Date:   Mon Feb 6 19:22:19 2012 +0100

    USB: serial: add macro for console error reporting
    
    Add macro which prints an error message only once if port is used a
    console.
    
    Reporting errors in a write path when port is used as a console could
    otherwise result in an infinite loop.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 4267a9c717ba..10cb74d2ad1d 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -389,5 +389,20 @@ do {									\
 		printk(KERN_DEBUG "%s: " format "\n", __FILE__, ##arg);	\
 } while (0)
 
+/*
+ * Macro for reporting errors in write path to avoid inifinite loop
+ * when port is used as a console.
+ */
+#define dev_err_console(usport, fmt, ...)				\
+do {									\
+	static bool __print_once;					\
+	struct usb_serial_port *__port = (usport);			\
+									\
+	if (!__port->port.console || !__print_once) {			\
+		__print_once = true;					\
+		dev_err(&__port->dev, fmt, ##__VA_ARGS__);		\
+	}								\
+} while (0)
+
 #endif /* __LINUX_USB_SERIAL_H */
 

commit d83b405383c965498923f3561c3321e2b5df5727
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Nov 6 19:06:37 2011 +0100

    USB: serial: add support for multiple read urbs
    
    Add support for multiple read urbs to generic read implementation.
    
    Use a static array of two read urbs for now which is enough to get a
    50% throughput increase in one test setup.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 8ccd405e9005..4267a9c717ba 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -58,6 +58,9 @@ enum port_dev_state {
  * @read_urb: pointer to the bulk in struct urb for this port.
  * @bulk_in_endpointAddress: endpoint address for the bulk in pipe for this
  *	port.
+ * @bulk_in_buffers: pointers to the bulk in buffers for this port
+ * @read_urbs: pointers to the bulk in urbs for this port
+ * @read_urbs_free: status bitmap the for bulk in urbs
  * @bulk_out_buffer: pointer to the bulk out buffer for this port.
  * @bulk_out_size: the size of the bulk_out_buffer, in bytes.
  * @write_urb: pointer to the bulk out struct urb for this port.
@@ -98,6 +101,10 @@ struct usb_serial_port {
 	struct urb		*read_urb;
 	__u8			bulk_in_endpointAddress;
 
+	unsigned char		*bulk_in_buffers[2];
+	struct urb		*read_urbs[2];
+	unsigned long		read_urbs_free;
+
 	unsigned char		*bulk_out_buffer;
 	int			bulk_out_size;
 	struct urb		*write_urb;
@@ -338,7 +345,7 @@ extern void usb_serial_generic_disconnect(struct usb_serial *serial);
 extern void usb_serial_generic_release(struct usb_serial *serial);
 extern int usb_serial_generic_register(int debug);
 extern void usb_serial_generic_deregister(void);
-extern int usb_serial_generic_submit_read_urb(struct usb_serial_port *port,
+extern int usb_serial_generic_submit_read_urbs(struct usb_serial_port *port,
 						 gfp_t mem_flags);
 extern void usb_serial_generic_process_read_urb(struct urb *urb);
 extern int usb_serial_generic_prepare_write_buffer(struct usb_serial_port *port,

commit 4556143cab73e013d0c3fa00f0f4f4373882399e
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Nov 6 19:06:25 2011 +0100

    USB: serial: remove write_urb_busy field from usb_serial_port
    
    Remove no longer used write_urb_busy field from struct usb_serial_port.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index b29f70b2ecae..8ccd405e9005 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -62,7 +62,6 @@ enum port_dev_state {
  * @bulk_out_size: the size of the bulk_out_buffer, in bytes.
  * @write_urb: pointer to the bulk out struct urb for this port.
  * @write_fifo: kfifo used to buffer outgoing data
- * @write_urb_busy: port`s writing status
  * @bulk_out_buffers: pointers to the bulk out buffers for this port
  * @write_urbs: pointers to the bulk out urbs for this port
  * @write_urbs_free: status bitmap the for bulk out urbs
@@ -103,7 +102,6 @@ struct usb_serial_port {
 	int			bulk_out_size;
 	struct urb		*write_urb;
 	struct kfifo		write_fifo;
-	int			write_urb_busy;
 
 	unsigned char		*bulk_out_buffers[2];
 	struct urb		*write_urbs[2];

commit e6bee325e49f17c65c1fd66e9e8b348c85788341
Merge: a5e6b135bdff 6ae705b23be8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 16 15:11:04 2011 -0700

    Merge branch 'tty-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty-2.6
    
    * 'tty-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty-2.6: (76 commits)
      pch_uart: reference clock on CM-iTC
      pch_phub: add new device ML7213
      n_gsm: fix UIH control byte : P bit should be 0
      n_gsm: add a documentation
      serial: msm_serial_hs: Add MSM high speed UART driver
      tty_audit: fix tty_audit_add_data live lock on audit disabled
      tty: move cd1865.h to drivers/staging/tty/
      Staging: tty: fix build with epca.c driver
      pcmcia: synclink_cs: fix prototype for mgslpc_ioctl()
      Staging: generic_serial: fix double locking bug
      nozomi: don't use flush_scheduled_work()
      tty/serial: Relax the device_type restriction from of_serial
      MAINTAINERS: Update HVC file patterns
      tty: phase out of ioctl file pointer for tty3270 as well
      tty: forgot to remove ipwireless from drivers/char/pcmcia/Makefile
      pch_uart: Fix DMA channel miss-setting issue.
      pch_uart: fix exclusive access issue
      pch_uart: fix auto flow control miss-setting issue
      pch_uart: fix uart clock setting issue
      pch_uart : Use dev_xxx not pr_xxx
      ...
    
    Fix up trivial conflicts in drivers/misc/pch_phub.c (same patch applied
    twice, then changes to the same area in one branch)

commit 969e3033ae7733a0af8f7742ca74cd16c0857e71
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Feb 23 15:28:18 2011 -0500

    USB: serial drivers need to use larger bulk-in buffers
    
    When a driver doesn't know how much data a device is going to send,
    the buffer size should be at least as big as the endpoint's maxpacket
    value.  The serial drivers don't follow this rule; many of them
    request only 256-byte bulk-in buffers.  As a result, they suffer
    overflow errors if a high-speed device wants to send a lot of data,
    because high-speed bulk endpoints are required to have a maxpacket
    size of 512.
    
    This patch (as1450) fixes the problem by using the driver's
    bulk_in_size value as a minimum, always allocating buffers no smaller
    than the endpoint's maxpacket size.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Flynn Marquardt <flynn@flynnux.de>
    CC: <stable@kernel.org> [after .39-rc1 is out]
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index c9049139a7a5..45f3b9db4258 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -191,7 +191,8 @@ static inline void usb_set_serial_data(struct usb_serial *serial, void *data)
  * @id_table: pointer to a list of usb_device_id structures that define all
  *	of the devices this structure can support.
  * @num_ports: the number of different ports this device will have.
- * @bulk_in_size: bytes to allocate for bulk-in buffer (0 = end-point size)
+ * @bulk_in_size: minimum number of bytes to allocate for bulk-in buffer
+ *	(0 = end-point size)
  * @bulk_out_size: bytes to allocate for bulk-out buffer (0 = end-point size)
  * @calc_num_ports: pointer to a function to determine how many ports this
  *	device has dynamically.  It will be called after the probe()

commit 00a0d0d65b61241a718d0aee96f46b9a2d93bf26
Author: Alan Cox <alan@linux.intel.com>
Date:   Mon Feb 14 16:27:06 2011 +0000

    tty: remove filp from the USB tty ioctls
    
    We don't use it so we can trim it from here as we try and stamp the file
    object dependencies out of the serial code.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index c1aa1b243ba3..00e98ee5fba0 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -260,7 +260,7 @@ struct usb_serial_driver {
 			const unsigned char *buf, int count);
 	/* Called only by the tty layer */
 	int  (*write_room)(struct tty_struct *tty);
-	int  (*ioctl)(struct tty_struct *tty, struct file *file,
+	int  (*ioctl)(struct tty_struct *tty,
 		      unsigned int cmd, unsigned long arg);
 	void (*set_termios)(struct tty_struct *tty,
 			struct usb_serial_port *port, struct ktermios *old);

commit 20b9d17715017ae4dd4ec87fabc36d33b9de708e
Author: Alan Cox <alan@linux.intel.com>
Date:   Mon Feb 14 16:26:50 2011 +0000

    tiocmset: kill the file pointer argument
    
    Doing tiocmget was such fun we should do tiocmset as well for the same
    reasons
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 30b945397d19..c1aa1b243ba3 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -269,7 +269,7 @@ struct usb_serial_driver {
 	void (*throttle)(struct tty_struct *tty);
 	void (*unthrottle)(struct tty_struct *tty);
 	int  (*tiocmget)(struct tty_struct *tty);
-	int  (*tiocmset)(struct tty_struct *tty, struct file *file,
+	int  (*tiocmset)(struct tty_struct *tty,
 			 unsigned int set, unsigned int clear);
 	int  (*get_icount)(struct tty_struct *tty,
 			struct serial_icounter_struct *icount);

commit 60b33c133ca0b7c0b6072c87234b63fee6e80558
Author: Alan Cox <alan@linux.intel.com>
Date:   Mon Feb 14 16:26:14 2011 +0000

    tiocmget: kill off the passing of the struct file
    
    We don't actually need this and it causes problems for internal use of
    this functionality. Currently there is a single use of the FILE * pointer.
    That is the serial core which uses it to check tty_hung_up_p. However if
    that is true then IO_ERROR is also already set so the check may be removed.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index c9049139a7a5..30b945397d19 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -268,7 +268,7 @@ struct usb_serial_driver {
 	int  (*chars_in_buffer)(struct tty_struct *tty);
 	void (*throttle)(struct tty_struct *tty);
 	void (*unthrottle)(struct tty_struct *tty);
-	int  (*tiocmget)(struct tty_struct *tty, struct file *file);
+	int  (*tiocmget)(struct tty_struct *tty);
 	int  (*tiocmset)(struct tty_struct *tty, struct file *file,
 			 unsigned int set, unsigned int clear);
 	int  (*get_icount)(struct tty_struct *tty,

commit d14fc1a74e846d7851f24fc9519fe87dc12a1231
Author: Libor Pechacek <lpechacek@suse.cz>
Date:   Fri Jan 14 14:30:21 2011 +0100

    USB: serial: handle Data Carrier Detect changes
    
    Alan's commit 335f8514f200e63d689113d29cb7253a5c282967 introduced
    .carrier_raised function in several drivers.  That also means
    tty_port_block_til_ready can now suspend the process trying to open the serial
    port when Carrier Detect is low and put it into tty_port.open_wait queue.  We
    need to wake up the process when Carrier Detect goes high and trigger TTY
    hangup when CD goes low.
    
    Some of the devices do not report modem status line changes, or at least we
    don't understand the status message, so for those we remove .carrier_raised
    again.
    
    Signed-off-by: Libor Pechacek <lpechacek@suse.cz>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 16d682f4f7c3..c9049139a7a5 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -347,6 +347,9 @@ extern int usb_serial_generic_prepare_write_buffer(struct usb_serial_port *port,
 extern int usb_serial_handle_sysrq_char(struct usb_serial_port *port,
 					unsigned int ch);
 extern int usb_serial_handle_break(struct usb_serial_port *port);
+extern void usb_serial_handle_dcd_change(struct usb_serial_port *usb_port,
+					 struct tty_struct *tty,
+					 unsigned int status);
 
 
 extern int usb_serial_bus_register(struct usb_serial_driver *device);

commit d281da7ff6f70efca0553c288bb883e8605b3862
Author: Alan Cox <alan@linux.intel.com>
Date:   Thu Sep 16 18:21:24 2010 +0100

    tty: Make tiocgicount a handler
    
    Dan Rosenberg noted that various drivers return the struct with uncleared
    fields. Instead of spending forever trying to stomp all the drivers that
    get it wrong (and every new driver) do the job in one place.
    
    This first patch adds the needed operations and hooks them up, including
    the needed USB midlayer and serial core plumbing.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 55675b1efb28..16d682f4f7c3 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -271,6 +271,8 @@ struct usb_serial_driver {
 	int  (*tiocmget)(struct tty_struct *tty, struct file *file);
 	int  (*tiocmset)(struct tty_struct *tty, struct file *file,
 			 unsigned int set, unsigned int clear);
+	int  (*get_icount)(struct tty_struct *tty,
+			struct serial_icounter_struct *icount);
 	/* Called by the tty layer for port level work. There may or may not
 	   be an attached tty at this point */
 	void (*dtr_rts)(struct usb_serial_port *port, int on);

commit 6ee9f4b4affe751d313d2538999aeec134d413a6
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Aug 17 21:15:47 2010 -0700

    USB: drop tty argument from usb_serial_handle_sysrq_char()
    
    Since handle_sysrq() does not take tty as argument anymore we can
    drop it from usb_serial_handle_sysrq_char() as well.
    
    Acked-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Acked-by: Jason Wessel <jason.wessel@windriver.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 84a4c44c208b..55675b1efb28 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -342,8 +342,7 @@ extern int usb_serial_generic_submit_read_urb(struct usb_serial_port *port,
 extern void usb_serial_generic_process_read_urb(struct urb *urb);
 extern int usb_serial_generic_prepare_write_buffer(struct usb_serial_port *port,
 						void *dest, size_t size);
-extern int usb_serial_handle_sysrq_char(struct tty_struct *tty,
-					struct usb_serial_port *port,
+extern int usb_serial_handle_sysrq_char(struct usb_serial_port *port,
 					unsigned int ch);
 extern int usb_serial_handle_break(struct usb_serial_port *port);
 

commit 0858a3a52f659dabf2860f350e5a6a61f069e851
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon May 17 10:58:12 2010 -0700

    USB: include/usb/*.h checkpatch cleanup
    
    Lots of minor formatting cleanups in includes/usb/ to make checkpatch
    happier.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 061c997ae0cf..84a4c44c208b 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -52,7 +52,7 @@ enum port_dev_state {
  * @interrupt_out_size: the size of the interrupt_out_buffer, in bytes.
  * @interrupt_out_urb: pointer to the interrupt out struct urb for this port.
  * @interrupt_out_endpointAddress: endpoint address for the interrupt out pipe
- * 	for this port.
+ *	for this port.
  * @bulk_in_buffer: pointer to the bulk in buffer for this port.
  * @bulk_in_size: the size of the bulk_in_buffer, in bytes.
  * @read_urb: pointer to the bulk in struct urb for this port.

commit c23e5fc1f7dba228558b4a46e68f7af89515b13c
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed May 5 23:58:13 2010 +0200

    USB: serial: remove multi-urb write from generic driver
    
    Remove multi-urb write from the generic driver and simplify the
    prepare_write_buffer prototype:
    
            int (*prepare_write_buffer)(struct usb_serial_port *port,
                                                    void *dest, size_t size);
    
    The default implementation simply fills dest with data from port write
    fifo but drivers can override it if they need to process the outgoing
    data (e.g. add headers).
    
    Turn ftdi_sio into a generic fifo-based driver, which lowers CPU usage
    significantly for small writes while retaining maximum throughput.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 70b6d6b28997..061c997ae0cf 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -67,7 +67,6 @@ enum port_dev_state {
  * @write_urbs: pointers to the bulk out urbs for this port
  * @write_urbs_free: status bitmap the for bulk out urbs
  * @tx_bytes: number of bytes currently in host stack queues
- * @tx_urbs: number of urbs currently in host stack queues
  * @bulk_out_endpointAddress: endpoint address for the bulk out pipe for this
  *	port.
  * @flags: usb serial port flags
@@ -112,7 +111,6 @@ struct usb_serial_port {
 	__u8			bulk_out_endpointAddress;
 
 	int			tx_bytes;
-	int			tx_urbs;
 
 	unsigned long		flags;
 	wait_queue_head_t	write_wait;
@@ -238,8 +236,6 @@ struct usb_serial_driver {
 	struct usb_driver	*usb_driver;
 	struct usb_dynids	dynids;
 
-	unsigned char		multi_urb_write:1;
-
 	size_t			bulk_in_size;
 	size_t			bulk_out_size;
 
@@ -291,7 +287,7 @@ struct usb_serial_driver {
 	void (*process_read_urb)(struct urb *urb);
 	/* Called by the generic write implementation */
 	int (*prepare_write_buffer)(struct usb_serial_port *port,
-		void **dest, size_t size, const void *src, size_t count);
+						void *dest, size_t size);
 };
 #define to_usb_serial_driver(d) \
 	container_of(d, struct usb_serial_driver, driver)
@@ -345,7 +341,7 @@ extern int usb_serial_generic_submit_read_urb(struct usb_serial_port *port,
 						 gfp_t mem_flags);
 extern void usb_serial_generic_process_read_urb(struct urb *urb);
 extern int usb_serial_generic_prepare_write_buffer(struct usb_serial_port *port,
-		void **dest, size_t size, const void *src, size_t count);
+						void *dest, size_t size);
 extern int usb_serial_handle_sysrq_char(struct tty_struct *tty,
 					struct usb_serial_port *port,
 					unsigned int ch);

commit 27c7acf22047fbe4ec4cc36b7c2610dba227697c
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed May 5 23:57:37 2010 +0200

    USB: serial: reimplement generic fifo-based writes
    
    Reimplement fifo-based writes in the generic driver using a multiple
    pre-allocated urb scheme.
    
    In contrast to multi-urb writes, no allocations (of urbs or buffers) are
    made during run-time and there is less pressure on the host stack
    queues as currently only two urbs are used (implementation is generic
    and can handle more than two urbs as well, though).
    
    Initial tests using ftdi_sio show that the implementation achieves the
    same (maximum) throughput at high baudrates as multi-urb writes. The CPU
    usage is much lower than for multi-urb writes for small write requests
    and only slightly higher for large (e.g. 2k) requests (due to extra copy
    via fifo?).
    
    Also outperforms multi-urb writes for small write requests on an
    embedded arm-9 system, where multi-urb writes are CPU-bound at high
    baudrates (perf reveals that a lot of time is spent in the host stack
    enqueue function -- could perhaps be a bug as well).
    
    Keeping the original write_urb, buffer and flag for now as there are
    other drivers depending on them.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index a4c99ea390e7..70b6d6b28997 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -35,6 +35,9 @@ enum port_dev_state {
 	PORT_UNREGISTERING,
 };
 
+/* USB serial flags */
+#define USB_SERIAL_WRITE_BUSY	0
+
 /**
  * usb_serial_port: structure for the specific ports of a device.
  * @serial: pointer back to the struct usb_serial owner of this port.
@@ -60,10 +63,14 @@ enum port_dev_state {
  * @write_urb: pointer to the bulk out struct urb for this port.
  * @write_fifo: kfifo used to buffer outgoing data
  * @write_urb_busy: port`s writing status
+ * @bulk_out_buffers: pointers to the bulk out buffers for this port
+ * @write_urbs: pointers to the bulk out urbs for this port
+ * @write_urbs_free: status bitmap the for bulk out urbs
  * @tx_bytes: number of bytes currently in host stack queues
  * @tx_urbs: number of urbs currently in host stack queues
  * @bulk_out_endpointAddress: endpoint address for the bulk out pipe for this
  *	port.
+ * @flags: usb serial port flags
  * @write_wait: a wait_queue_head_t used by the port.
  * @work: work queue entry for the line discipline waking up.
  * @throttled: nonzero if the read urb is inactive to throttle the device
@@ -98,11 +105,16 @@ struct usb_serial_port {
 	struct urb		*write_urb;
 	struct kfifo		write_fifo;
 	int			write_urb_busy;
+
+	unsigned char		*bulk_out_buffers[2];
+	struct urb		*write_urbs[2];
+	unsigned long		write_urbs_free;
 	__u8			bulk_out_endpointAddress;
 
 	int			tx_bytes;
 	int			tx_urbs;
 
+	unsigned long		flags;
 	wait_queue_head_t	write_wait;
 	struct work_struct	work;
 	char			throttled;

commit eaa3bcb06aed1ac1d6d9e3edd3b5f72ea57a6ac0
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Mar 17 23:06:08 2010 +0100

    USB: serial: generalise write buffer preparation
    
    Generalise write buffer preparation.
    
    This allows for drivers to manipulate (e.g. add headers) to bulk out
    data before it is sent.
    
    This adds a new function pointer to usb_serial_driver:
    
    int (*prepare_write_buffer)(struct usb_serial_port *port,
                    void **dest, size_t size, const void *src, size_t count);
    
    The function is generic and can be used with either kfifo-based or
    multi-urb writes:
    
    If *dest is NULL the implementation should allocate dest.
    If src is NULL the implementation should use the port write fifo.
    
    If not set, a generic implementation is used which simply uses memcpy or
    kfifo_out.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 2a3283761600..a4c99ea390e7 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -277,6 +277,9 @@ struct usb_serial_driver {
 	void (*write_bulk_callback)(struct urb *urb);
 	/* Called by the generic read bulk callback */
 	void (*process_read_urb)(struct urb *urb);
+	/* Called by the generic write implementation */
+	int (*prepare_write_buffer)(struct usb_serial_port *port,
+		void **dest, size_t size, const void *src, size_t count);
 };
 #define to_usb_serial_driver(d) \
 	container_of(d, struct usb_serial_driver, driver)
@@ -329,6 +332,8 @@ extern void usb_serial_generic_deregister(void);
 extern int usb_serial_generic_submit_read_urb(struct usb_serial_port *port,
 						 gfp_t mem_flags);
 extern void usb_serial_generic_process_read_urb(struct urb *urb);
+extern int usb_serial_generic_prepare_write_buffer(struct usb_serial_port *port,
+		void **dest, size_t size, const void *src, size_t count);
 extern int usb_serial_handle_sysrq_char(struct tty_struct *tty,
 					struct usb_serial_port *port,
 					unsigned int ch);

commit 25d514ca227e1ac81d0906a4ccf2aa171f50a600
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Mar 17 23:06:07 2010 +0100

    USB: serial: re-implement multi-urb writes in generic driver
    
    Use dynamic transfer buffer sizes since it is more efficient to let the
    host controller do the partitioning to fit endpoint size. This way we
    also do not use more than one urb per write request.
    
    Replace max_in_flight_urbs with multi_urb_write flag in struct
    usb_serial_driver to enable multi-urb writes.
    
    Use MAX_TX_URBS=40 and a max buffer size of PAGE_SIZE to prevent DoS
    attacks.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index ff8872eba3ac..2a3283761600 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -60,6 +60,8 @@ enum port_dev_state {
  * @write_urb: pointer to the bulk out struct urb for this port.
  * @write_fifo: kfifo used to buffer outgoing data
  * @write_urb_busy: port`s writing status
+ * @tx_bytes: number of bytes currently in host stack queues
+ * @tx_urbs: number of urbs currently in host stack queues
  * @bulk_out_endpointAddress: endpoint address for the bulk out pipe for this
  *	port.
  * @write_wait: a wait_queue_head_t used by the port.
@@ -98,8 +100,8 @@ struct usb_serial_port {
 	int			write_urb_busy;
 	__u8			bulk_out_endpointAddress;
 
-	int			tx_bytes_flight;
-	int			urbs_in_flight;
+	int			tx_bytes;
+	int			tx_urbs;
 
 	wait_queue_head_t	write_wait;
 	struct work_struct	work;
@@ -223,7 +225,8 @@ struct usb_serial_driver {
 	struct device_driver	driver;
 	struct usb_driver	*usb_driver;
 	struct usb_dynids	dynids;
-	int			max_in_flight_urbs;
+
+	unsigned char		multi_urb_write:1;
 
 	size_t			bulk_in_size;
 	size_t			bulk_out_size;

commit 231543206452f5c42bace54b5c13dfe5a0313812
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Mar 17 23:05:57 2010 +0100

    USB: serial: generalise generic read implementation
    
    Add process_read_urb to usb_serial_driver so that a driver can rely on
    the generic read (and throttle) mechanism but still do device specific
    processing of incoming data (such as adding tty_flags before pushing to
    line discipline).
    
    The default generic implementation handles sysrq for consoles but
    otherwise simply pushes to tty.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 53f6dc65e87e..ff8872eba3ac 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -272,6 +272,8 @@ struct usb_serial_driver {
 	void (*write_int_callback)(struct urb *urb);
 	void (*read_bulk_callback)(struct urb *urb);
 	void (*write_bulk_callback)(struct urb *urb);
+	/* Called by the generic read bulk callback */
+	void (*process_read_urb)(struct urb *urb);
 };
 #define to_usb_serial_driver(d) \
 	container_of(d, struct usb_serial_driver, driver)
@@ -323,6 +325,7 @@ extern int usb_serial_generic_register(int debug);
 extern void usb_serial_generic_deregister(void);
 extern int usb_serial_generic_submit_read_urb(struct usb_serial_port *port,
 						 gfp_t mem_flags);
+extern void usb_serial_generic_process_read_urb(struct urb *urb);
 extern int usb_serial_handle_sysrq_char(struct tty_struct *tty,
 					struct usb_serial_port *port,
 					unsigned int ch);

commit 41bd72f9041def8e3334d3e3693862d078f5cb9a
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Mar 17 23:05:53 2010 +0100

    USB: serial: refactor read urb submission in generic driver
    
    Use the already exported function for submitting the read urb associated
    with a usb_serial_port.
    
    Make sure it returns the result of usb_submit_urb and rename to the
    more descriptive usb_serial_generic_submit_read_urb.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index ab311dab3383..53f6dc65e87e 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -321,7 +321,7 @@ extern void usb_serial_generic_disconnect(struct usb_serial *serial);
 extern void usb_serial_generic_release(struct usb_serial *serial);
 extern int usb_serial_generic_register(int debug);
 extern void usb_serial_generic_deregister(void);
-extern void usb_serial_generic_resubmit_read_urb(struct usb_serial_port *port,
+extern int usb_serial_generic_submit_read_urb(struct usb_serial_port *port,
 						 gfp_t mem_flags);
 extern int usb_serial_handle_sysrq_char(struct tty_struct *tty,
 					struct usb_serial_port *port,

commit bbcb2b907415a90334521a31a8767cd77462c716
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Mar 17 23:00:37 2010 +0100

    USB: serial: allow drivers to define bulk buffer sizes
    
    Allow drivers to define custom bulk in/out buffer sizes in struct
    usb_serial_driver. If not set, fall back to the default buffer size
    which matches the endpoint size.
    
    Three drivers are currently freeing the pre-allocated buffers and
    allocating larger ones to achieve this at port probe (ftdi_sio) or even
    at port open (ipaq and iuu_phoenix), which needless to say is suboptimal.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index b7682fed1d9c..ab311dab3383 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -179,6 +179,8 @@ static inline void usb_set_serial_data(struct usb_serial *serial, void *data)
  * @id_table: pointer to a list of usb_device_id structures that define all
  *	of the devices this structure can support.
  * @num_ports: the number of different ports this device will have.
+ * @bulk_in_size: bytes to allocate for bulk-in buffer (0 = end-point size)
+ * @bulk_out_size: bytes to allocate for bulk-out buffer (0 = end-point size)
  * @calc_num_ports: pointer to a function to determine how many ports this
  *	device has dynamically.  It will be called after the probe()
  *	callback is called, but before attach()
@@ -223,6 +225,9 @@ struct usb_serial_driver {
 	struct usb_dynids	dynids;
 	int			max_in_flight_urbs;
 
+	size_t			bulk_in_size;
+	size_t			bulk_out_size;
+
 	int (*probe)(struct usb_serial *serial, const struct usb_device_id *id);
 	int (*attach)(struct usb_serial *serial);
 	int (*calc_num_ports) (struct usb_serial *serial);

commit bd5afa9eac6daa408412a31a6c69e87e8bd28c7e
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Mon Mar 8 21:50:12 2010 -0600

    usb-serial: Use tty_port version console instead of usb_serial_port
    
    Replace all instances of using the console variable in struct
    usb_serial_port with the struct tty_port version.
    
    CC: Alan Cox <alan@linux.intel.com>
    CC: Alan Stern <stern@rowland.harvard.edu>
    CC: Oliver Neukum <oliver@neukum.org>
    CC: Andrew Morton <akpm@linux-foundation.org>
    CC: linux-usb@vger.kernel.org
    CC: linux-kernel@vger.kernel.org
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 0a458b861933..b7682fed1d9c 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -66,7 +66,6 @@ enum port_dev_state {
  * @work: work queue entry for the line discipline waking up.
  * @throttled: nonzero if the read urb is inactive to throttle the device
  * @throttle_req: nonzero if the tty wants to throttle us
- * @console: attached usb serial console
  * @dev: pointer to the serial device
  *
  * This structure is used by the usb-serial core and drivers for the specific
@@ -106,7 +105,6 @@ struct usb_serial_port {
 	struct work_struct	work;
 	char			throttled;
 	char			throttle_req;
-	char			console;
 	unsigned long		sysrq; /* sysrq timeout */
 	struct device		dev;
 	enum port_dev_state	dev_state;

commit efcbd3df079a6f8a8a2d5207c4e8429e02356c79
Author: Joe Perches <joe@perches.com>
Date:   Fri Feb 5 18:09:49 2010 -0800

    USB: Extend and neaten dbg macros
    
    Add format/argument validation for #ifndef DEBUG dbg macro
    Neaten dbg macro definitions
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 1819396ed501..0a458b861933 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -351,14 +351,11 @@ static inline void usb_serial_debug_data(int debug,
 
 /* Use our own dbg macro */
 #undef dbg
-#define dbg(format, arg...) \
-	do { \
-		if (debug) \
-			printk(KERN_DEBUG "%s: " format "\n" , __FILE__ , \
-				## arg); \
-	} while (0)
-
-
+#define dbg(format, arg...)						\
+do {									\
+	if (debug)							\
+		printk(KERN_DEBUG "%s: " format "\n", __FILE__, ##arg);	\
+} while (0)
 
 #endif /* __LINUX_USB_SERIAL_H */
 

commit 119eecc831a42bd090543568932e440c6831f1bb
Author: Stefani Seibold <stefani@seibold.net>
Date:   Wed Dec 23 09:10:48 2009 +0100

    Fix usb_serial_probe() problem introduced by the recent kfifo changes
    
    The USB serial code was a new user of the kfifo API, and it was missed
    when porting things to the new kfifo API.
    
    Please make the write_fifo in place.  Here is my patch to fix the
    regression and full ported version.
    
    Signed-off-by: Stefani Seibold <stefani@seibold.net>
    Reported-and-tested-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Greg KH <greg@kroah.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index acf6e457c04b..1819396ed501 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -16,6 +16,7 @@
 #include <linux/kref.h>
 #include <linux/mutex.h>
 #include <linux/sysrq.h>
+#include <linux/kfifo.h>
 
 #define SERIAL_TTY_MAJOR	188	/* Nice legal number now */
 #define SERIAL_TTY_MINORS	254	/* loads of devices :) */
@@ -94,7 +95,7 @@ struct usb_serial_port {
 	unsigned char		*bulk_out_buffer;
 	int			bulk_out_size;
 	struct urb		*write_urb;
-	struct kfifo		*write_fifo;
+	struct kfifo		write_fifo;
 	int			write_urb_busy;
 	__u8			bulk_out_endpointAddress;
 

commit 82fc5943430e3cbf15033ed4186a73f90906345d
Author: Alan Cox <alan@linux.intel.com>
Date:   Tue Oct 6 16:06:46 2009 +0100

    usb_serial: Kill port mutex
    
    The tty port has a port mutex used for all the port related locking so we
    don't need the one in the USB serial layer any more.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Oliver Neukum <oliver@neukum.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index ce911ebf91e8..acf6e457c04b 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -39,8 +39,6 @@ enum port_dev_state {
  * @serial: pointer back to the struct usb_serial owner of this port.
  * @port: pointer to the corresponding tty_port for this port.
  * @lock: spinlock to grab when updating portions of this structure.
- * @mutex: mutex used to synchronize serial_open() and serial_close()
- *	access for this port.
  * @number: the number of the port (the minor number).
  * @interrupt_in_buffer: pointer to the interrupt in buffer for this port.
  * @interrupt_in_urb: pointer to the interrupt in struct urb for this port.
@@ -77,7 +75,6 @@ struct usb_serial_port {
 	struct usb_serial	*serial;
 	struct tty_port		port;
 	spinlock_t		lock;
-	struct mutex            mutex;
 	unsigned char		number;
 
 	unsigned char		*interrupt_in_buffer;

commit a4720c650b68a5fe7faed2edeb0ad12645f7ae63
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Oct 9 12:43:12 2009 -0400

    USB: serial: don't call release without attach
    
    This patch (as1295) fixes a recently-added bug in the USB serial core.
    If certain kinds of errors occur during probing, the core may call a
    serial driver's release method without previously calling the attach
    method.  This causes some drivers (io_ti in particular) to perform an
    invalid memory access.
    
    The patch adds a new flag to keep track of whether or not attach has
    been called.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Jean-Denis Girard <jd.girard@sysnux.pf>
    CC: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index c17eb64d7213..ce911ebf91e8 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -150,6 +150,7 @@ struct usb_serial {
 	struct usb_interface		*interface;
 	unsigned char			disconnected:1;
 	unsigned char			suspending:1;
+	unsigned char			attached:1;
 	unsigned char			minor;
 	unsigned char			num_ports;
 	unsigned char			num_port_pointers;

commit 8e8dce065088833fc418bfa5fbf035cb0726c04c
Author: David VomLehn <dvomlehn@cisco.com>
Date:   Fri Aug 28 12:54:27 2009 -0700

    USB: use kfifo to buffer usb-generic serial writes
    
    When do_output_char() attempts to write a carriage return/line feed sequence,
    it first checks to see how much buffer room is available. If there are at least
    two characters free, it will write the carriage return/line feed with two calls
    to tty_put_char(). It calls the tty_operation functions write() for devices that
    don't support the tty_operations function put_char(). If the USB generic serial
    device's write URB is not in use, it will return the buffer size when asked how
    much room is available. The write() of the carriage return will cause it to mark
    the write URB busy, so the subsequent write() of the line feed will be ignored.
    
    This patch uses the kfifo infrastructure to implement a write FIFO that
    accurately returns the amount of space available in the buffer.
    
    Signed-off-by: David VomLehn <dvomlehn@cisco.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 7b85e327af91..c17eb64d7213 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -59,6 +59,7 @@ enum port_dev_state {
  * @bulk_out_buffer: pointer to the bulk out buffer for this port.
  * @bulk_out_size: the size of the bulk_out_buffer, in bytes.
  * @write_urb: pointer to the bulk out struct urb for this port.
+ * @write_fifo: kfifo used to buffer outgoing data
  * @write_urb_busy: port`s writing status
  * @bulk_out_endpointAddress: endpoint address for the bulk out pipe for this
  *	port.
@@ -96,6 +97,7 @@ struct usb_serial_port {
 	unsigned char		*bulk_out_buffer;
 	int			bulk_out_size;
 	struct urb		*write_urb;
+	struct kfifo		*write_fifo;
 	int			write_urb_busy;
 	__u8			bulk_out_endpointAddress;
 

commit fe1ae7fdd2ee603f2d95f04e09a68f7f79045127
Author: Alan Cox <alan@linux.intel.com>
Date:   Sat Sep 19 13:13:33 2009 -0700

    tty: USB serial termios bits
    
    Various drivers have hacks to mangle termios structures. This stems from
    the fact there is no nice setup hook for configuring the termios settings
    when the port is created
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 1cbaf4a6b449..7b85e327af91 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -260,6 +260,9 @@ struct usb_serial_driver {
 	   be an attached tty at this point */
 	void (*dtr_rts)(struct usb_serial_port *port, int on);
 	int  (*carrier_raised)(struct usb_serial_port *port);
+	/* Called by the usb serial hooks to allow the user to rework the
+	   termios state */
+	void (*init_termios)(struct tty_struct *tty);
 	/* USB events */
 	void (*read_int_callback)(struct urb *urb);
 	void (*write_int_callback)(struct urb *urb);

commit a509a7e478e4766114d69f12d19d644ac63e9765
Author: Alan Cox <alan@linux.intel.com>
Date:   Sat Sep 19 13:13:26 2009 -0700

    tty: USB does not need the filp argument in the drivers
    
    And indeed none of them use it. Clean this up as it will make moving to a
    standard open method rather easier.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 0ec50ba62139..1cbaf4a6b449 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -238,9 +238,8 @@ struct usb_serial_driver {
 	int (*resume)(struct usb_serial *serial);
 
 	/* serial function calls */
-	/* Called by console with tty = NULL and by tty */
-	int  (*open)(struct tty_struct *tty,
-			struct usb_serial_port *port, struct file *filp);
+	/* Called by console and by the tty layer */
+	int  (*open)(struct tty_struct *tty, struct usb_serial_port *port);
 	void (*close)(struct usb_serial_port *port);
 	int  (*write)(struct tty_struct *tty, struct usb_serial_port *port,
 			const unsigned char *buf, int count);
@@ -300,7 +299,7 @@ static inline void usb_serial_console_disconnect(struct usb_serial *serial) {}
 extern struct usb_serial *usb_serial_get_by_index(unsigned int minor);
 extern void usb_serial_put(struct usb_serial *serial);
 extern int usb_serial_generic_open(struct tty_struct *tty,
-		struct usb_serial_port *port, struct file *filp);
+	struct usb_serial_port *port);
 extern int usb_serial_generic_write(struct tty_struct *tty,
 	struct usb_serial_port *port, const unsigned char *buf, int count);
 extern void usb_serial_generic_close(struct usb_serial_port *port);

commit 24a15a62dcb1968bf4ffdae55c88fa934d971180
Author: Alan Cox <alan@linux.intel.com>
Date:   Thu Jul 9 13:36:22 2009 +0100

    tty: Fix USB kref leak
    
    The sysrq code acquired a kref leak. Fix it by passing the tty separately
    from the caller (thus effectively using the callers kref which all the
    callers hold anyway)
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 44801d26a37a..0ec50ba62139 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -317,7 +317,8 @@ extern int usb_serial_generic_register(int debug);
 extern void usb_serial_generic_deregister(void);
 extern void usb_serial_generic_resubmit_read_urb(struct usb_serial_port *port,
 						 gfp_t mem_flags);
-extern int usb_serial_handle_sysrq_char(struct usb_serial_port *port,
+extern int usb_serial_handle_sysrq_char(struct tty_struct *tty,
+					struct usb_serial_port *port,
 					unsigned int ch);
 extern int usb_serial_handle_break(struct usb_serial_port *port);
 

commit f9c99bb8b3a1ec81af68d484a551307326c2e933
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jun 2 11:53:55 2009 -0400

    USB: usb-serial: replace shutdown with disconnect, release
    
    This patch (as1254) splits up the shutdown method of usb_serial_driver
    into a disconnect and a release method.
    
    The problem is that the usb-serial core was calling shutdown during
    disconnect handling, but drivers didn't expect it to be called until
    after all the open file references had been closed.  The result was an
    oops when the close method tried to use memory that had been
    deallocated by shutdown.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index ed4aa0fa7ed8..44801d26a37a 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -194,8 +194,10 @@ static inline void usb_set_serial_data(struct usb_serial *serial, void *data)
  *	This will be called when the struct usb_serial structure is fully set
  *	set up.  Do any local initialization of the device, or any private
  *	memory structure allocation at this point in time.
- * @shutdown: pointer to the driver's shutdown function.  This will be
- *	called when the device is removed from the system.
+ * @disconnect: pointer to the driver's disconnect function.  This will be
+ *	called when the device is unplugged or unbound from the driver.
+ * @release: pointer to the driver's release function.  This will be called
+ *	when the usb_serial data structure is about to be destroyed.
  * @usb_driver: pointer to the struct usb_driver that controls this
  *	device.  This is necessary to allow dynamic ids to be added to
  *	the driver from sysfs.
@@ -226,7 +228,8 @@ struct usb_serial_driver {
 	int (*attach)(struct usb_serial *serial);
 	int (*calc_num_ports) (struct usb_serial *serial);
 
-	void (*shutdown)(struct usb_serial *serial);
+	void (*disconnect)(struct usb_serial *serial);
+	void (*release)(struct usb_serial *serial);
 
 	int (*port_probe)(struct usb_serial_port *port);
 	int (*port_remove)(struct usb_serial_port *port);
@@ -308,7 +311,8 @@ extern void usb_serial_generic_read_bulk_callback(struct urb *urb);
 extern void usb_serial_generic_write_bulk_callback(struct urb *urb);
 extern void usb_serial_generic_throttle(struct tty_struct *tty);
 extern void usb_serial_generic_unthrottle(struct tty_struct *tty);
-extern void usb_serial_generic_shutdown(struct usb_serial *serial);
+extern void usb_serial_generic_disconnect(struct usb_serial *serial);
+extern void usb_serial_generic_release(struct usb_serial *serial);
 extern int usb_serial_generic_register(int debug);
 extern void usb_serial_generic_deregister(void);
 extern void usb_serial_generic_resubmit_read_urb(struct usb_serial_port *port,

commit c706ebdfc8955b850e477255a8c0f93f9f14712d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jun 2 11:54:11 2009 -0400

    USB: usb-serial: call port_probe and port_remove at the right times
    
    This patch (as1253) prevents the usb-serial core from calling a
    driver's port_probe and port_remove methods more than once per port.
    It also removes some unnecessary try_module_get() calls and adds a
    missing port_remove method call in a failure path.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index e29ebcf3287b..ed4aa0fa7ed8 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -27,6 +27,13 @@
 /* parity check flag */
 #define RELEVANT_IFLAG(iflag)	(iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
 
+enum port_dev_state {
+	PORT_UNREGISTERED,
+	PORT_REGISTERING,
+	PORT_REGISTERED,
+	PORT_UNREGISTERING,
+};
+
 /**
  * usb_serial_port: structure for the specific ports of a device.
  * @serial: pointer back to the struct usb_serial owner of this port.
@@ -102,6 +109,7 @@ struct usb_serial_port {
 	char			console;
 	unsigned long		sysrq; /* sysrq timeout */
 	struct device		dev;
+	enum port_dev_state	dev_state;
 };
 #define to_usb_serial_port(d) container_of(d, struct usb_serial_port, dev)
 

commit 98fcb5f78165b8a3d93870ad7afd4d9ebbb8b43a
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Mon May 11 15:24:09 2009 -0500

    USB: serial: usb_debug,usb_generic_serial: implement sysrq and serial break
    
    The usb_debug driver was modified to implement serial break handling
    by using a "magic" data packet comprised of the sequence:
    
           0x00 0xff 0x01 0xfe   0x00 0xfe 0x01 0xff
    
    When the tty layer requests a serial break the usb_debug driver sends
    the magic packet.  On the receiving side the magic packet is thrown
    away or a sysrq is activated depending on what kernel .config options
    have been set.
    
    The generic serial driver was modified as well as the usb serial
    headers to generically implement sysrq processing in the same way the
    non usb uart based drivers implement the sysrq handling.  This will
    allow other usb serial devices to implement sysrq handling as desired.
    
    The new usb serial functions are named similarly and implemented
    similarly to the uart functions as follows:
    
    usb_serial_handle_break <-> uart_handle_break
    usb_serial_handle_sysrq_char <-> uart_handle_sysrq_char
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index e2938fd179e2..e29ebcf3287b 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -15,6 +15,7 @@
 
 #include <linux/kref.h>
 #include <linux/mutex.h>
+#include <linux/sysrq.h>
 
 #define SERIAL_TTY_MAJOR	188	/* Nice legal number now */
 #define SERIAL_TTY_MINORS	254	/* loads of devices :) */
@@ -99,6 +100,7 @@ struct usb_serial_port {
 	char			throttled;
 	char			throttle_req;
 	char			console;
+	unsigned long		sysrq; /* sysrq timeout */
 	struct device		dev;
 };
 #define to_usb_serial_port(d) container_of(d, struct usb_serial_port, dev)
@@ -301,6 +303,12 @@ extern void usb_serial_generic_unthrottle(struct tty_struct *tty);
 extern void usb_serial_generic_shutdown(struct usb_serial *serial);
 extern int usb_serial_generic_register(int debug);
 extern void usb_serial_generic_deregister(void);
+extern void usb_serial_generic_resubmit_read_urb(struct usb_serial_port *port,
+						 gfp_t mem_flags);
+extern int usb_serial_handle_sysrq_char(struct usb_serial_port *port,
+					unsigned int ch);
+extern int usb_serial_handle_break(struct usb_serial_port *port);
+
 
 extern int usb_serial_bus_register(struct usb_serial_driver *device);
 extern void usb_serial_bus_deregister(struct usb_serial_driver *device);

commit 715b1dc01fe44537e8fce9566e4bb48d6821d84b
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Mon May 11 15:24:07 2009 -0500

    USB: usb_debug, usb_generic_serial: implement multi urb write
    
    The usb_debug driver, when used as the console, will always fail to
    insert the carriage return and new line sequence as well as randomly
    drop console output.  This is a result of only having the single
    write_urb and that the tty layer will have a lock that prevents the
    processing of the back to back urb requests.
    
    The solution is to allow more than one urb to be outstanding and have
    a slightly deeper transmit queue.  The idea and some code is borrowed
    from the ftdi_sio usb driver.
    
    The generic usb serial driver was modified so as to allow the classic
    method of 1 write urb, or a multi write urb scheme with N allowed
    outstanding urbs where N is controlled by max_in_flight_urbs.  When
    max_in_flight_urbs in a "struct usb_serial_driver" is non zero the
    multi write urb scheme will be used.
    
    The size of 4000 was selected for the usb_debug driver so that the
    driver lowers possibility of losing the queued console messages during
    the kernel startup.
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 8cdfed738fe4..e2938fd179e2 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -91,6 +91,9 @@ struct usb_serial_port {
 	int			write_urb_busy;
 	__u8			bulk_out_endpointAddress;
 
+	int			tx_bytes_flight;
+	int			urbs_in_flight;
+
 	wait_queue_head_t	write_wait;
 	struct work_struct	work;
 	char			throttled;
@@ -207,6 +210,7 @@ struct usb_serial_driver {
 	struct device_driver	driver;
 	struct usb_driver	*usb_driver;
 	struct usb_dynids	dynids;
+	int			max_in_flight_urbs;
 
 	int (*probe)(struct usb_serial *serial, const struct usb_device_id *id);
 	int (*attach)(struct usb_serial *serial);

commit 335f8514f200e63d689113d29cb7253a5c282967
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Thu Jun 11 12:26:29 2009 +0100

    tty: Bring the usb tty port structure into more use
    
    This allows us to clean stuff up, but is probably also going to cause
    some app breakage with buggy apps as we now implement proper POSIX behaviour
    for USB ports matching all the other ports. This does also mean other apps
    that break on USB will now work properly.
    
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 625e9e4639c6..8cdfed738fe4 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -224,8 +224,7 @@ struct usb_serial_driver {
 	/* Called by console with tty = NULL and by tty */
 	int  (*open)(struct tty_struct *tty,
 			struct usb_serial_port *port, struct file *filp);
-	void (*close)(struct tty_struct *tty,
-			struct usb_serial_port *port, struct file *filp);
+	void (*close)(struct usb_serial_port *port);
 	int  (*write)(struct tty_struct *tty, struct usb_serial_port *port,
 			const unsigned char *buf, int count);
 	/* Called only by the tty layer */
@@ -241,6 +240,10 @@ struct usb_serial_driver {
 	int  (*tiocmget)(struct tty_struct *tty, struct file *file);
 	int  (*tiocmset)(struct tty_struct *tty, struct file *file,
 			 unsigned int set, unsigned int clear);
+	/* Called by the tty layer for port level work. There may or may not
+	   be an attached tty at this point */
+	void (*dtr_rts)(struct usb_serial_port *port, int on);
+	int  (*carrier_raised)(struct usb_serial_port *port);
 	/* USB events */
 	void (*read_int_callback)(struct urb *urb);
 	void (*write_int_callback)(struct urb *urb);
@@ -283,8 +286,7 @@ extern int usb_serial_generic_open(struct tty_struct *tty,
 		struct usb_serial_port *port, struct file *filp);
 extern int usb_serial_generic_write(struct tty_struct *tty,
 	struct usb_serial_port *port, const unsigned char *buf, int count);
-extern void usb_serial_generic_close(struct tty_struct *tty,
-			struct usb_serial_port *port, struct file *filp);
+extern void usb_serial_generic_close(struct usb_serial_port *port);
 extern int usb_serial_generic_resume(struct usb_serial *serial);
 extern int usb_serial_generic_write_room(struct tty_struct *tty);
 extern int usb_serial_generic_chars_in_buffer(struct tty_struct *tty);

commit 78c5b82ee68207a176ad5ca5eabdb2dbe5cfbfd3
Author: Leandro Dorileo <ldorileo@gmail.com>
Date:   Tue Apr 14 14:59:51 2009 +0100

    tty: Update some of the USB kernel doc
    
    Updates some usb_serial_port members documentation.
    
    Signed-off-by: Leandro Dorileo <ldorileo@gmail.com>
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index b95842542590..625e9e4639c6 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -29,7 +29,7 @@
 /**
  * usb_serial_port: structure for the specific ports of a device.
  * @serial: pointer back to the struct usb_serial owner of this port.
- * @tty: pointer to the corresponding tty for this port.
+ * @port: pointer to the corresponding tty_port for this port.
  * @lock: spinlock to grab when updating portions of this structure.
  * @mutex: mutex used to synchronize serial_open() and serial_close()
  *	access for this port.
@@ -44,19 +44,22 @@
  * @interrupt_out_endpointAddress: endpoint address for the interrupt out pipe
  * 	for this port.
  * @bulk_in_buffer: pointer to the bulk in buffer for this port.
+ * @bulk_in_size: the size of the bulk_in_buffer, in bytes.
  * @read_urb: pointer to the bulk in struct urb for this port.
  * @bulk_in_endpointAddress: endpoint address for the bulk in pipe for this
  *	port.
  * @bulk_out_buffer: pointer to the bulk out buffer for this port.
  * @bulk_out_size: the size of the bulk_out_buffer, in bytes.
  * @write_urb: pointer to the bulk out struct urb for this port.
+ * @write_urb_busy: port`s writing status
  * @bulk_out_endpointAddress: endpoint address for the bulk out pipe for this
  *	port.
  * @write_wait: a wait_queue_head_t used by the port.
  * @work: work queue entry for the line discipline waking up.
- * @open_count: number of times this port has been opened.
  * @throttled: nonzero if the read urb is inactive to throttle the device
  * @throttle_req: nonzero if the tty wants to throttle us
+ * @console: attached usb serial console
+ * @dev: pointer to the serial device
  *
  * This structure is used by the usb-serial core and drivers for the specific
  * ports of a device.

commit f8bece8d91f9ed9cff3c98920802f1b3046b7560
Author: Oliver Neukum <oliver@neukum.org>
Date:   Thu Feb 5 16:54:25 2009 +0100

    USB: serial: introduce a flag into the usb serial layer to tell drivers that their URBs are killed due to suspension
    
    This patch introduces a flag into the usb serial layer to tell drivers
    that their URBs are killed due to suspension. That is necessary to let
    drivers know whether they should report an error back.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    
    Hi Greg,
    
    this is for 2.6.30. Patches to use this in drivers are under development.
    
            Regards
                    Oliver

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 0b8617a9176d..b95842542590 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -130,7 +130,8 @@ struct usb_serial {
 	struct usb_device		*dev;
 	struct usb_serial_driver	*type;
 	struct usb_interface		*interface;
-	unsigned char			disconnected;
+	unsigned char			disconnected:1;
+	unsigned char			suspending:1;
 	unsigned char			minor;
 	unsigned char			num_ports;
 	unsigned char			num_port_pointers;

commit 0b14c3881d4b91272b779f4037e263d392de058f
Author: Geoff Levand <geoff@infradead.org>
Date:   Sat Sep 20 14:41:47 2008 -0700

    USB: Fix spelling in usb/serial.h
    
    Fixes a minor typo in the comments for usb_set_serial_data.
    
    Signed-off-by: Geoff Levand <geoff@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 655341d0f534..0b8617a9176d 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -192,7 +192,7 @@ static inline void usb_set_serial_data(struct usb_serial *serial, void *data)
  * The driver.owner field should be set to the module owner of this driver.
  * The driver.name field should be set to the name of this driver (remember
  * it will show up in sysfs, so it needs to be short and to the point.
- * Useing the module name is a good idea.)
+ * Using the module name is a good idea.)
  */
 struct usb_serial_driver {
 	const char *description;

commit 0282b7f2a874e72c18fcd5a112ccf67f71ba7f5c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jul 29 12:01:04 2008 -0400

    usb-serial: don't release unregistered minors
    
    This patch (as1121) fixes a bug in the USB serial core.  When a device
    is unregistered, the core will give back its minors -- even if the
    device hasn't been assigned any!
    
    The patch reserves the highest minor value (255) to mean that no minor
    was assigned.  It also removes some dead code and does a small style
    fixup.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 09a3e6a7518f..655341d0f534 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -17,7 +17,8 @@
 #include <linux/mutex.h>
 
 #define SERIAL_TTY_MAJOR	188	/* Nice legal number now */
-#define SERIAL_TTY_MINORS	255	/* loads of devices :) */
+#define SERIAL_TTY_MINORS	254	/* loads of devices :) */
+#define SERIAL_TTY_NO_MINOR	255	/* No minor was assigned */
 
 /* The maximum number of ports one device can grab at once */
 #define MAX_NUM_PORTS		8

commit 95da310e66ee8090119596c70ca8432e57f9a97f
Author: Alan Cox <alan@redhat.com>
Date:   Tue Jul 22 11:09:07 2008 +0100

    usb_serial: API all change
    
    USB serial likes to use port->tty back pointers for the real work it does and
    to do so without any actual locking. Unfortunately when you consider hangup
    events, hangup/parallel reopen or even worse hangup followed by parallel close
    events the tty->port and port->tty pointers are not guaranteed to be the same
    as port->tty is the active tty while tty->port is the port the tty may or
    may not still be attached to.
    
    So rework the entire API to pass the tty struct. For console cases we need
    to pass both for now. This shows up multiple drivers that immediately crash
    with USB console some of which have been fixed in the process.
    
    Longer term we need a proper tty as console abstraction
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 8f891cbaf9ab..09a3e6a7518f 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -62,7 +62,7 @@
  */
 struct usb_serial_port {
 	struct usb_serial	*serial;
-	struct tty_struct	*tty;
+	struct tty_port		port;
 	spinlock_t		lock;
 	struct mutex            mutex;
 	unsigned char		number;
@@ -89,7 +89,6 @@ struct usb_serial_port {
 
 	wait_queue_head_t	write_wait;
 	struct work_struct	work;
-	int			open_count;
 	char			throttled;
 	char			throttle_req;
 	char			console;
@@ -217,22 +216,27 @@ struct usb_serial_driver {
 	int (*resume)(struct usb_serial *serial);
 
 	/* serial function calls */
-	int  (*open)(struct usb_serial_port *port, struct file *filp);
-	void (*close)(struct usb_serial_port *port, struct file *filp);
-	int  (*write)(struct usb_serial_port *port, const unsigned char *buf,
-		      int count);
-	int  (*write_room)(struct usb_serial_port *port);
-	int  (*ioctl)(struct usb_serial_port *port, struct file *file,
+	/* Called by console with tty = NULL and by tty */
+	int  (*open)(struct tty_struct *tty,
+			struct usb_serial_port *port, struct file *filp);
+	void (*close)(struct tty_struct *tty,
+			struct usb_serial_port *port, struct file *filp);
+	int  (*write)(struct tty_struct *tty, struct usb_serial_port *port,
+			const unsigned char *buf, int count);
+	/* Called only by the tty layer */
+	int  (*write_room)(struct tty_struct *tty);
+	int  (*ioctl)(struct tty_struct *tty, struct file *file,
 		      unsigned int cmd, unsigned long arg);
-	void (*set_termios)(struct usb_serial_port *port, struct ktermios *old);
-	void (*break_ctl)(struct usb_serial_port *port, int break_state);
-	int  (*chars_in_buffer)(struct usb_serial_port *port);
-	void (*throttle)(struct usb_serial_port *port);
-	void (*unthrottle)(struct usb_serial_port *port);
-	int  (*tiocmget)(struct usb_serial_port *port, struct file *file);
-	int  (*tiocmset)(struct usb_serial_port *port, struct file *file,
+	void (*set_termios)(struct tty_struct *tty,
+			struct usb_serial_port *port, struct ktermios *old);
+	void (*break_ctl)(struct tty_struct *tty, int break_state);
+	int  (*chars_in_buffer)(struct tty_struct *tty);
+	void (*throttle)(struct tty_struct *tty);
+	void (*unthrottle)(struct tty_struct *tty);
+	int  (*tiocmget)(struct tty_struct *tty, struct file *file);
+	int  (*tiocmset)(struct tty_struct *tty, struct file *file,
 			 unsigned int set, unsigned int clear);
-
+	/* USB events */
 	void (*read_int_callback)(struct urb *urb);
 	void (*write_int_callback)(struct urb *urb);
 	void (*read_bulk_callback)(struct urb *urb);
@@ -270,19 +274,19 @@ static inline void usb_serial_console_disconnect(struct usb_serial *serial) {}
 /* Functions needed by other parts of the usbserial core */
 extern struct usb_serial *usb_serial_get_by_index(unsigned int minor);
 extern void usb_serial_put(struct usb_serial *serial);
-extern int usb_serial_generic_open(struct usb_serial_port *port,
-				   struct file *filp);
-extern int usb_serial_generic_write(struct usb_serial_port *port,
-				    const unsigned char *buf, int count);
-extern void usb_serial_generic_close(struct usb_serial_port *port,
-				     struct file *filp);
+extern int usb_serial_generic_open(struct tty_struct *tty,
+		struct usb_serial_port *port, struct file *filp);
+extern int usb_serial_generic_write(struct tty_struct *tty,
+	struct usb_serial_port *port, const unsigned char *buf, int count);
+extern void usb_serial_generic_close(struct tty_struct *tty,
+			struct usb_serial_port *port, struct file *filp);
 extern int usb_serial_generic_resume(struct usb_serial *serial);
-extern int usb_serial_generic_write_room(struct usb_serial_port *port);
-extern int usb_serial_generic_chars_in_buffer(struct usb_serial_port *port);
+extern int usb_serial_generic_write_room(struct tty_struct *tty);
+extern int usb_serial_generic_chars_in_buffer(struct tty_struct *tty);
 extern void usb_serial_generic_read_bulk_callback(struct urb *urb);
 extern void usb_serial_generic_write_bulk_callback(struct urb *urb);
-extern void usb_serial_generic_throttle(struct usb_serial_port *port);
-extern void usb_serial_generic_unthrottle(struct usb_serial_port *port);
+extern void usb_serial_generic_throttle(struct tty_struct *tty);
+extern void usb_serial_generic_unthrottle(struct tty_struct *tty);
 extern void usb_serial_generic_shutdown(struct usb_serial *serial);
 extern int usb_serial_generic_register(int debug);
 extern void usb_serial_generic_deregister(void);

commit 9aebfd6bda789891e6d296bb49b5fb32d1057f18
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Apr 16 09:17:38 2008 -0700

    USB: serial: remove endpoints setting checks from core and header
    
    Remove the unused check for num_interrupt and friends as well as remove
    them from the header file because no usb-serial drivers no longer
    reference them.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index f1b7434a96bf..8f891cbaf9ab 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -145,8 +145,6 @@ struct usb_serial {
 };
 #define to_usb_serial(d) container_of(d, struct usb_serial, kref)
 
-#define NUM_DONT_CARE	99
-
 /* get and set the serial private data pointer helper functions */
 static inline void *usb_get_serial_data(struct usb_serial *serial)
 {
@@ -164,18 +162,6 @@ static inline void usb_set_serial_data(struct usb_serial *serial, void *data)
  *	used in the syslog messages when a device is inserted or removed.
  * @id_table: pointer to a list of usb_device_id structures that define all
  *	of the devices this structure can support.
- * @num_interrupt_in: If a device doesn't have this many interrupt-in
- *	endpoints, it won't be sent to the driver's attach() method.
- *	(But it might still be sent to the probe() method.)
- * @num_interrupt_out: If a device doesn't have this many interrupt-out
- *	endpoints, it won't be sent to the driver's attach() method.
- *	(But it might still be sent to the probe() method.)
- * @num_bulk_in: If a device doesn't have this many bulk-in
- *	endpoints, it won't be sent to the driver's attach() method.
- *	(But it might still be sent to the probe() method.)
- * @num_bulk_out: If a device doesn't have this many bulk-out
- *	endpoints, it won't be sent to the driver's attach() method.
- *	(But it might still be sent to the probe() method.)
  * @num_ports: the number of different ports this device will have.
  * @calc_num_ports: pointer to a function to determine how many ports this
  *	device has dynamically.  It will be called after the probe()
@@ -211,10 +197,6 @@ static inline void usb_set_serial_data(struct usb_serial *serial, void *data)
 struct usb_serial_driver {
 	const char *description;
 	const struct usb_device_id *id_table;
-	char	num_interrupt_in;
-	char	num_interrupt_out;
-	char	num_bulk_in;
-	char	num_bulk_out;
 	char	num_ports;
 
 	struct list_head	driver_list;

commit dda43a0e03a33dd716fb34f812b1af614f74daff
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Fri Mar 7 13:45:32 2008 -0500

    USB: Standardize inclusion protection and add where missing.
    
    For the header files in include/linux/usb, add missing multiple
    inclusion protection and standardize what's already there.  The
    apparent standards:
    
      * macro name of __LINUX_USB_headerfile_H
      * inclusion protection placed after leading comment block
      * macro name added as a comment on the final #endif
      * any obvious trivial whitespace cleanup associated with the above
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 21b4a1c6f585..f1b7434a96bf 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -10,7 +10,6 @@
  *
  */
 
-
 #ifndef __LINUX_USB_SERIAL_H
 #define __LINUX_USB_SERIAL_H
 
@@ -340,5 +339,5 @@ static inline void usb_serial_debug_data(int debug,
 
 
 
-#endif	/* ifdef __LINUX_USB_SERIAL_H */
+#endif /* __LINUX_USB_SERIAL_H */
 

commit 41dceed51f0e6105ca2bf45c3835a7cd9eaa077b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Jan 30 15:21:33 2008 -0800

    USB: fix codingstyle issues in include/linux/usb/
    
    Fixes a number of coding style issues in the USB public header files.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 63b29b5332e6..21b4a1c6f585 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -20,7 +20,8 @@
 #define SERIAL_TTY_MAJOR	188	/* Nice legal number now */
 #define SERIAL_TTY_MINORS	255	/* loads of devices :) */
 
-#define MAX_NUM_PORTS		8	/* The maximum number of ports one device can grab at once */
+/* The maximum number of ports one device can grab at once */
+#define MAX_NUM_PORTS		8
 
 /* parity check flag */
 #define RELEVANT_IFLAG(iflag)	(iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
@@ -61,29 +62,29 @@
  * ports of a device.
  */
 struct usb_serial_port {
-	struct usb_serial *	serial;
-	struct tty_struct *	tty;
+	struct usb_serial	*serial;
+	struct tty_struct	*tty;
 	spinlock_t		lock;
 	struct mutex            mutex;
 	unsigned char		number;
 
-	unsigned char *		interrupt_in_buffer;
-	struct urb *		interrupt_in_urb;
+	unsigned char		*interrupt_in_buffer;
+	struct urb		*interrupt_in_urb;
 	__u8			interrupt_in_endpointAddress;
 
-	unsigned char *		interrupt_out_buffer;
+	unsigned char		*interrupt_out_buffer;
 	int			interrupt_out_size;
-	struct urb *		interrupt_out_urb;
+	struct urb		*interrupt_out_urb;
 	__u8			interrupt_out_endpointAddress;
 
-	unsigned char *		bulk_in_buffer;
+	unsigned char		*bulk_in_buffer;
 	int			bulk_in_size;
-	struct urb *		read_urb;
+	struct urb		*read_urb;
 	__u8			bulk_in_endpointAddress;
 
-	unsigned char *		bulk_out_buffer;
+	unsigned char		*bulk_out_buffer;
 	int			bulk_out_size;
-	struct urb *		write_urb;
+	struct urb		*write_urb;
 	int			write_urb_busy;
 	__u8			bulk_out_endpointAddress;
 
@@ -98,12 +99,13 @@ struct usb_serial_port {
 #define to_usb_serial_port(d) container_of(d, struct usb_serial_port, dev)
 
 /* get and set the port private data pointer helper functions */
-static inline void *usb_get_serial_port_data (struct usb_serial_port *port)
+static inline void *usb_get_serial_port_data(struct usb_serial_port *port)
 {
 	return dev_get_drvdata(&port->dev);
 }
 
-static inline void usb_set_serial_port_data (struct usb_serial_port *port, void *data)
+static inline void usb_set_serial_port_data(struct usb_serial_port *port,
+					    void *data)
 {
 	dev_set_drvdata(&port->dev, data);
 }
@@ -126,9 +128,9 @@ static inline void usb_set_serial_port_data (struct usb_serial_port *port, void
  *	usb_set_serial_data() to access this.
  */
 struct usb_serial {
-	struct usb_device *		dev;
-	struct usb_serial_driver *	type;
-	struct usb_interface *		interface;
+	struct usb_device		*dev;
+	struct usb_serial_driver	*type;
+	struct usb_interface		*interface;
 	unsigned char			disconnected;
 	unsigned char			minor;
 	unsigned char			num_ports;
@@ -137,30 +139,30 @@ struct usb_serial {
 	char				num_interrupt_out;
 	char				num_bulk_in;
 	char				num_bulk_out;
-	struct usb_serial_port *	port[MAX_NUM_PORTS];
+	struct usb_serial_port		*port[MAX_NUM_PORTS];
 	struct kref			kref;
 	struct mutex			disc_mutex;
-	void *				private;
+	void				*private;
 };
 #define to_usb_serial(d) container_of(d, struct usb_serial, kref)
 
 #define NUM_DONT_CARE	99
 
 /* get and set the serial private data pointer helper functions */
-static inline void *usb_get_serial_data (struct usb_serial *serial)
+static inline void *usb_get_serial_data(struct usb_serial *serial)
 {
 	return serial->private;
 }
 
-static inline void usb_set_serial_data (struct usb_serial *serial, void *data)
+static inline void usb_set_serial_data(struct usb_serial *serial, void *data)
 {
 	serial->private = data;
 }
 
 /**
  * usb_serial_driver - describes a usb serial driver
- * @description: pointer to a string that describes this driver.  This string used
- *	in the syslog messages when a device is inserted or removed.
+ * @description: pointer to a string that describes this driver.  This string
+ *	used in the syslog messages when a device is inserted or removed.
  * @id_table: pointer to a list of usb_device_id structures that define all
  *	of the devices this structure can support.
  * @num_interrupt_in: If a device doesn't have this many interrupt-in
@@ -221,82 +223,91 @@ struct usb_serial_driver {
 	struct usb_driver	*usb_driver;
 	struct usb_dynids	dynids;
 
-	int (*probe) (struct usb_serial *serial, const struct usb_device_id *id);
-	int (*attach) (struct usb_serial *serial);
+	int (*probe)(struct usb_serial *serial, const struct usb_device_id *id);
+	int (*attach)(struct usb_serial *serial);
 	int (*calc_num_ports) (struct usb_serial *serial);
 
-	void (*shutdown) (struct usb_serial *serial);
+	void (*shutdown)(struct usb_serial *serial);
 
-	int (*port_probe) (struct usb_serial_port *port);
-	int (*port_remove) (struct usb_serial_port *port);
+	int (*port_probe)(struct usb_serial_port *port);
+	int (*port_remove)(struct usb_serial_port *port);
 
-	int (*suspend) (struct usb_serial *serial, pm_message_t message);
-	int (*resume) (struct usb_serial *serial);
+	int (*suspend)(struct usb_serial *serial, pm_message_t message);
+	int (*resume)(struct usb_serial *serial);
 
 	/* serial function calls */
-	int  (*open)		(struct usb_serial_port *port, struct file * filp);
-	void (*close)		(struct usb_serial_port *port, struct file * filp);
-	int  (*write)		(struct usb_serial_port *port, const unsigned char *buf, int count);
-	int  (*write_room)	(struct usb_serial_port *port);
-	int  (*ioctl)		(struct usb_serial_port *port, struct file * file, unsigned int cmd, unsigned long arg);
-	void (*set_termios)	(struct usb_serial_port *port, struct ktermios * old);
-	void (*break_ctl)	(struct usb_serial_port *port, int break_state);
-	int  (*chars_in_buffer)	(struct usb_serial_port *port);
-	void (*throttle)	(struct usb_serial_port *port);
-	void (*unthrottle)	(struct usb_serial_port *port);
-	int  (*tiocmget)	(struct usb_serial_port *port, struct file *file);
-	int  (*tiocmset)	(struct usb_serial_port *port, struct file *file, unsigned int set, unsigned int clear);
+	int  (*open)(struct usb_serial_port *port, struct file *filp);
+	void (*close)(struct usb_serial_port *port, struct file *filp);
+	int  (*write)(struct usb_serial_port *port, const unsigned char *buf,
+		      int count);
+	int  (*write_room)(struct usb_serial_port *port);
+	int  (*ioctl)(struct usb_serial_port *port, struct file *file,
+		      unsigned int cmd, unsigned long arg);
+	void (*set_termios)(struct usb_serial_port *port, struct ktermios *old);
+	void (*break_ctl)(struct usb_serial_port *port, int break_state);
+	int  (*chars_in_buffer)(struct usb_serial_port *port);
+	void (*throttle)(struct usb_serial_port *port);
+	void (*unthrottle)(struct usb_serial_port *port);
+	int  (*tiocmget)(struct usb_serial_port *port, struct file *file);
+	int  (*tiocmset)(struct usb_serial_port *port, struct file *file,
+			 unsigned int set, unsigned int clear);
 
 	void (*read_int_callback)(struct urb *urb);
 	void (*write_int_callback)(struct urb *urb);
 	void (*read_bulk_callback)(struct urb *urb);
 	void (*write_bulk_callback)(struct urb *urb);
 };
-#define to_usb_serial_driver(d) container_of(d, struct usb_serial_driver, driver)
+#define to_usb_serial_driver(d) \
+	container_of(d, struct usb_serial_driver, driver)
 
 extern int  usb_serial_register(struct usb_serial_driver *driver);
 extern void usb_serial_deregister(struct usb_serial_driver *driver);
 extern void usb_serial_port_softint(struct usb_serial_port *port);
 
-extern int usb_serial_probe(struct usb_interface *iface, const struct usb_device_id *id);
+extern int usb_serial_probe(struct usb_interface *iface,
+			    const struct usb_device_id *id);
 extern void usb_serial_disconnect(struct usb_interface *iface);
 
 extern int usb_serial_suspend(struct usb_interface *intf, pm_message_t message);
 extern int usb_serial_resume(struct usb_interface *intf);
 
-extern int ezusb_writememory (struct usb_serial *serial, int address, unsigned char *data, int length, __u8 bRequest);
-extern int ezusb_set_reset (struct usb_serial *serial, unsigned char reset_bit);
+extern int ezusb_writememory(struct usb_serial *serial, int address,
+			     unsigned char *data, int length, __u8 bRequest);
+extern int ezusb_set_reset(struct usb_serial *serial, unsigned char reset_bit);
 
 /* USB Serial console functions */
 #ifdef CONFIG_USB_SERIAL_CONSOLE
-extern void usb_serial_console_init (int debug, int minor);
-extern void usb_serial_console_exit (void);
+extern void usb_serial_console_init(int debug, int minor);
+extern void usb_serial_console_exit(void);
 extern void usb_serial_console_disconnect(struct usb_serial *serial);
 #else
-static inline void usb_serial_console_init (int debug, int minor) { }
-static inline void usb_serial_console_exit (void) { }
+static inline void usb_serial_console_init(int debug, int minor) { }
+static inline void usb_serial_console_exit(void) { }
 static inline void usb_serial_console_disconnect(struct usb_serial *serial) {}
 #endif
 
 /* Functions needed by other parts of the usbserial core */
-extern struct usb_serial *usb_serial_get_by_index (unsigned int minor);
+extern struct usb_serial *usb_serial_get_by_index(unsigned int minor);
 extern void usb_serial_put(struct usb_serial *serial);
-extern int usb_serial_generic_open (struct usb_serial_port *port, struct file *filp);
-extern int usb_serial_generic_write (struct usb_serial_port *port, const unsigned char *buf, int count);
-extern void usb_serial_generic_close (struct usb_serial_port *port, struct file *filp);
-extern int usb_serial_generic_resume (struct usb_serial *serial);
-extern int usb_serial_generic_write_room (struct usb_serial_port *port);
-extern int usb_serial_generic_chars_in_buffer (struct usb_serial_port *port);
-extern void usb_serial_generic_read_bulk_callback (struct urb *urb);
-extern void usb_serial_generic_write_bulk_callback (struct urb *urb);
-extern void usb_serial_generic_throttle (struct usb_serial_port *port);
-extern void usb_serial_generic_unthrottle (struct usb_serial_port *port);
-extern void usb_serial_generic_shutdown (struct usb_serial *serial);
-extern int usb_serial_generic_register (int debug);
-extern void usb_serial_generic_deregister (void);
-
-extern int usb_serial_bus_register (struct usb_serial_driver *device);
-extern void usb_serial_bus_deregister (struct usb_serial_driver *device);
+extern int usb_serial_generic_open(struct usb_serial_port *port,
+				   struct file *filp);
+extern int usb_serial_generic_write(struct usb_serial_port *port,
+				    const unsigned char *buf, int count);
+extern void usb_serial_generic_close(struct usb_serial_port *port,
+				     struct file *filp);
+extern int usb_serial_generic_resume(struct usb_serial *serial);
+extern int usb_serial_generic_write_room(struct usb_serial_port *port);
+extern int usb_serial_generic_chars_in_buffer(struct usb_serial_port *port);
+extern void usb_serial_generic_read_bulk_callback(struct urb *urb);
+extern void usb_serial_generic_write_bulk_callback(struct urb *urb);
+extern void usb_serial_generic_throttle(struct usb_serial_port *port);
+extern void usb_serial_generic_unthrottle(struct usb_serial_port *port);
+extern void usb_serial_generic_shutdown(struct usb_serial *serial);
+extern int usb_serial_generic_register(int debug);
+extern void usb_serial_generic_deregister(void);
+
+extern int usb_serial_bus_register(struct usb_serial_driver *device);
+extern void usb_serial_bus_deregister(struct usb_serial_driver *device);
 
 extern struct usb_serial_driver usb_serial_generic_device;
 extern struct bus_type usb_serial_bus_type;
@@ -310,16 +321,22 @@ static inline void usb_serial_debug_data(int debug,
 	int i;
 
 	if (debug) {
-		dev_printk(KERN_DEBUG, dev, "%s - length = %d, data = ", function, size);
+		dev_printk(KERN_DEBUG, dev, "%s - length = %d, data = ",
+			   function, size);
 		for (i = 0; i < size; ++i)
-			printk ("%.2x ", data[i]);
-		printk ("\n");
+			printk("%.2x ", data[i]);
+		printk("\n");
 	}
 }
 
 /* Use our own dbg macro */
 #undef dbg
-#define dbg(format, arg...) do { if (debug) printk(KERN_DEBUG "%s: " format "\n" , __FILE__ , ## arg); } while (0)
+#define dbg(format, arg...) \
+	do { \
+		if (debug) \
+			printk(KERN_DEBUG "%s: " format "\n" , __FILE__ , \
+				## arg); \
+	} while (0)
 
 
 

commit a1cd7e99b343543af2be4c8c5755e26f6bfd725a
Author: Oliver Neukum <oliver@neukum.org>
Date:   Wed Jan 16 17:18:52 2008 +0100

    USB: stop io performed by mos7720 upon close()
    
    This fixes a problem where the mos7720 driver will make io to a device from
    which it has been logically disconnected. It does so by introducing a flag by
    which the generic usb serial code can signal the subdrivers their
    disconnection and appropriate locking.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index ef1e430f7bfa..63b29b5332e6 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -129,6 +129,7 @@ struct usb_serial {
 	struct usb_device *		dev;
 	struct usb_serial_driver *	type;
 	struct usb_interface *		interface;
+	unsigned char			disconnected;
 	unsigned char			minor;
 	unsigned char			num_ports;
 	unsigned char			num_port_pointers;
@@ -138,6 +139,7 @@ struct usb_serial {
 	char				num_bulk_out;
 	struct usb_serial_port *	port[MAX_NUM_PORTS];
 	struct kref			kref;
+	struct mutex			disc_mutex;
 	void *				private;
 };
 #define to_usb_serial(d) container_of(d, struct usb_serial, kref)

commit 9a6b1efa6fd1ee022fdf42c91a9868c589cc95b7
Author: Aristeu Rozanski <aris@ruivo.org>
Date:   Mon Nov 12 15:15:02 2007 -0500

    USB: usb_serial: clean tty reference in the last close
    
    When a usb serial adapter is used as console, the usb serial console
    driver bumps the open_count on the port struct used but doesn't attach
    a real tty to it (only a fake one temporaly). If this port is opened later
    using the regular character device interface, the open method won't
    initialize the port, which is the expected, and will receive a brand new
    tty struct created by tty layer, which will be stored in port->tty.
    
    When the last close is issued, open_count won't be 0 because of the
    console usage and the port->tty will still contain the old tty value. This
    is the last ttyUSB<n> close so the allocated tty will be freed by the
    tty layer. The usb_serial and usb_serial_port are still in use by the
    console, so port_free() won't be called (serial_close() ->
    usb_serial_put() -> destroy_serial() -> port_free()), so the scheduled
    work (port->work, usb_serial_port_work()) will still run. And
    usb_serial_port_work() does:
    (...)
            tty = port->tty;
            if (!tty)
                    return;
    
            tty_wakeup(tty);
    which causes (manually copied):
    
    Faulting instruction address: 0x6b6b6b68
    Oops: Kernel access of bad area, sig: 11 [#1]
    PREEMPT PowerMac
    Modules linked in: binfmt_misc ipv6 nfs lockd nfs_acl sunrpc dm_snapshot dm_mirror dm_mod hfsplus uinput ams input_polldev genrtc cpufreq_powersave i2c_powermac therm_adt746x snd_aoa_codec_tas snd_aoa_fabric_layout snd_aoa joydev snd_aoa_i2sbus snd_pcm_oss snd_mixer_oss snd_pcm snd_timer snd_page_alloc pmac_zilog serial_core evdev ide_cd cdrom snd appletouch soundcore snd_aoa_soundbus bcm43xx firmware_class usbhid ieee80211softmac ff_memless firewire_ohci firewire_core ieee80211 ieee80211_crypt crc_itu_t sungem sungem_phy uninorth_agp agpart ssb
    NIP: 6b6b6b68 LR: c01b2108 CTR: 6b6b6b6b
    REGS: c106de80 TRAP: 0400   Not tainted  (2.6.24-rc2)
    MSR: 40009032 <EE,ME,IR,DR>  CR: 82004024  XER: 00000000
    TASK = c106b4c0[5] 'events/0' THREAD: c106c000
    GPR00: 6b6b6b6b c106df30 c106b4c0 c2d613a0 00009032 00000001 00001a00 00000001
    GPR08: 00000008 00000000 00000000 c106c000 42004028 00000000 016ffbe0 0171a724
    GPR16: 016ffcf4 00240e24 00240e70 016fee68 016ff9a4 c03046c4 c0327f50 c03046fc
    GPR24: c106b6b9 c106b4c0 c101d610 c106c000 c02160fc c1eac1dc c2d613ac c2d613a0
    NIP [6b6b6b68] 0x6b6b6b68
    LR [c01b2108] tty_wakeup+0x6c/0x9c
    Call Trace:
    [c106df30] [c01b20e8] tty_wakeup+0x4c/0x9c (unreliable)
    [c106df40] [c0216138] usb_serial_port_work+0x3c/0x78
    [c106df50] [c00432e8] run_workqueue+0xc4/0x15c
    [c106df90] [c0043798] worker_thread+0xa0/0x124
    [c106dfd0] [c0048224] kthread+0x48/0x84
    [c106dff0] [c00129bc] kernel_thread+0x44/0x60
    Instruction dump:
    XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
    XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
    Slab corruption: size-2048 start=c2d613a0, len=2048
    Redzone: 0x9f911029d74e35b/0x9f911029d74e35b.
    Last user: [<c01b16d8>](release_one_tty+0xbc/0xf4)
    050: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b
    Prev obj: start=c2d60b88, len=2048
    Redzone: 0x9f911029d74e35b/0x9f911029d74e35b.
    Last user: [<c00f30ec>](show_stat+0x410/0x428)
    000: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b
    010: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b
    
    This patch avoids this, clearing port->tty considering if the port is
    used as serial console or not
    
    Signed-off-by: Aristeu Rozanski <arozansk@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 488ce128885c..ef1e430f7bfa 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -92,6 +92,7 @@ struct usb_serial_port {
 	int			open_count;
 	char			throttled;
 	char			throttle_req;
+	char			console;
 	struct device		dev;
 };
 #define to_usb_serial_port(d) container_of(d, struct usb_serial_port, dev)

commit 063a2da8f01806906f7d7b1a1424b9afddebc443
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Oct 10 16:24:06 2007 -0400

    USB: serial core should respect driver requirements
    
    This patch (as997) fixes a bug in the USB serial core.  The core needs
    to pay attention to drivers' requirements regarding the number and
    type of endpoints a device has.
    
    At the same time, the patch changes the NUM_DONT_CARE constant (which
    is stored in a single-byte field) from -1 to a safer, unsigned value.
    It also improves the kerneldoc for several fields in the
    usb_serial_driver structure.
    
    Finally, the patch replaces a list_for_each() with list_for_each_entry().
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index e8b8928232c8..488ce128885c 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -141,7 +141,7 @@ struct usb_serial {
 };
 #define to_usb_serial(d) container_of(d, struct usb_serial, kref)
 
-#define NUM_DONT_CARE	(-1)
+#define NUM_DONT_CARE	99
 
 /* get and set the serial private data pointer helper functions */
 static inline void *usb_get_serial_data (struct usb_serial *serial)
@@ -160,12 +160,18 @@ static inline void usb_set_serial_data (struct usb_serial *serial, void *data)
  *	in the syslog messages when a device is inserted or removed.
  * @id_table: pointer to a list of usb_device_id structures that define all
  *	of the devices this structure can support.
- * @num_interrupt_in: the number of interrupt in endpoints this device will
- *	have.
- * @num_interrupt_out: the number of interrupt out endpoints this device will
- *	have.
- * @num_bulk_in: the number of bulk in endpoints this device will have.
- * @num_bulk_out: the number of bulk out endpoints this device will have.
+ * @num_interrupt_in: If a device doesn't have this many interrupt-in
+ *	endpoints, it won't be sent to the driver's attach() method.
+ *	(But it might still be sent to the probe() method.)
+ * @num_interrupt_out: If a device doesn't have this many interrupt-out
+ *	endpoints, it won't be sent to the driver's attach() method.
+ *	(But it might still be sent to the probe() method.)
+ * @num_bulk_in: If a device doesn't have this many bulk-in
+ *	endpoints, it won't be sent to the driver's attach() method.
+ *	(But it might still be sent to the probe() method.)
+ * @num_bulk_out: If a device doesn't have this many bulk-out
+ *	endpoints, it won't be sent to the driver's attach() method.
+ *	(But it might still be sent to the probe() method.)
  * @num_ports: the number of different ports this device will have.
  * @calc_num_ports: pointer to a function to determine how many ports this
  *	device has dynamically.  It will be called after the probe()

commit ec22559e0b7a05283a3413bda5d177e42c950e23
Author: Oliver Neukum <oneukum@suse.de>
Date:   Fri Apr 27 20:54:57 2007 +0200

    USB: suspend support for usb serial
    
    this implements generic support for suspend/resume for usb serial.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 32acbae28d24..e8b8928232c8 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -221,6 +221,9 @@ struct usb_serial_driver {
 	int (*port_probe) (struct usb_serial_port *port);
 	int (*port_remove) (struct usb_serial_port *port);
 
+	int (*suspend) (struct usb_serial *serial, pm_message_t message);
+	int (*resume) (struct usb_serial *serial);
+
 	/* serial function calls */
 	int  (*open)		(struct usb_serial_port *port, struct file * filp);
 	void (*close)		(struct usb_serial_port *port, struct file * filp);
@@ -249,6 +252,9 @@ extern void usb_serial_port_softint(struct usb_serial_port *port);
 extern int usb_serial_probe(struct usb_interface *iface, const struct usb_device_id *id);
 extern void usb_serial_disconnect(struct usb_interface *iface);
 
+extern int usb_serial_suspend(struct usb_interface *intf, pm_message_t message);
+extern int usb_serial_resume(struct usb_interface *intf);
+
 extern int ezusb_writememory (struct usb_serial *serial, int address, unsigned char *data, int length, __u8 bRequest);
 extern int ezusb_set_reset (struct usb_serial *serial, unsigned char reset_bit);
 
@@ -269,6 +275,7 @@ extern void usb_serial_put(struct usb_serial *serial);
 extern int usb_serial_generic_open (struct usb_serial_port *port, struct file *filp);
 extern int usb_serial_generic_write (struct usb_serial_port *port, const unsigned char *buf, int count);
 extern void usb_serial_generic_close (struct usb_serial_port *port, struct file *filp);
+extern int usb_serial_generic_resume (struct usb_serial *serial);
 extern int usb_serial_generic_write_room (struct usb_serial_port *port);
 extern int usb_serial_generic_chars_in_buffer (struct usb_serial_port *port);
 extern void usb_serial_generic_read_bulk_callback (struct urb *urb);

commit 253ca923281aec6975ec4028ddbc58e865d8d13d
Author: Joris van Rantwijk <jorispubl@xs4all.nl>
Date:   Thu Feb 1 20:08:18 2007 +0100

    USB: add flow control to usb-serial generic driver.
    
    I added two fields to struct usb_serial_port to keep track of the
    throttle state. Other usb-serial drivers typically use private data for
    such things, but the generic driver can not really do that because some
    of its code is also used by other drivers (which may have their own
    private data needs).
    
    As it is, I am not sure that this patch is useful in all scenarios.
    It is certainly helpful for low-bandwidth devices that can hold their
    data in response to throttling. But for devices that pump data in
    real-time as fast as possible (webcam, A/D converter, etc), throttling
    may actually cause more data loss.
    
    From: Joris van Rantwijk <jorispubl@xs4all.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 33dcd8576696..32acbae28d24 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -54,6 +54,8 @@
  * @write_wait: a wait_queue_head_t used by the port.
  * @work: work queue entry for the line discipline waking up.
  * @open_count: number of times this port has been opened.
+ * @throttled: nonzero if the read urb is inactive to throttle the device
+ * @throttle_req: nonzero if the tty wants to throttle us
  *
  * This structure is used by the usb-serial core and drivers for the specific
  * ports of a device.
@@ -88,6 +90,8 @@ struct usb_serial_port {
 	wait_queue_head_t	write_wait;
 	struct work_struct	work;
 	int			open_count;
+	char			throttled;
+	char			throttle_req;
 	struct device		dev;
 };
 #define to_usb_serial_port(d) container_of(d, struct usb_serial_port, dev)
@@ -269,6 +273,8 @@ extern int usb_serial_generic_write_room (struct usb_serial_port *port);
 extern int usb_serial_generic_chars_in_buffer (struct usb_serial_port *port);
 extern void usb_serial_generic_read_bulk_callback (struct urb *urb);
 extern void usb_serial_generic_write_bulk_callback (struct urb *urb);
+extern void usb_serial_generic_throttle (struct usb_serial_port *port);
+extern void usb_serial_generic_unthrottle (struct usb_serial_port *port);
 extern void usb_serial_generic_shutdown (struct usb_serial *serial);
 extern int usb_serial_generic_register (int debug);
 extern void usb_serial_generic_deregister (void);

commit 93bacefc4cc0b53e1cb6a336d43847154fdf6886
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Sun Dec 17 21:50:23 2006 +0100

    USB serial: add dynamic id support to usb-serial core
    
    Thanks to Johannes Hölzl <johannes.hoelzl@gmx.de> for fixing a few
    things and getting it all working properly.
    
    This adds support for dynamic usb ids to the usb serial core.  The file
    "new_id" will show up under the usb serial driver, not the usb driver
    associated with the usb-serial driver (yeah, it can be a bit confusing
    at first glance...)
    
    This patch also modifies the USB core to allow the usb-serial core to
    reuse much of the dynamic id logic.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Johannes Hölzl <johannes.hoelzl@gmx.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 10f99e5f1a97..33dcd8576696 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -179,6 +179,9 @@ static inline void usb_set_serial_data (struct usb_serial *serial, void *data)
  *	memory structure allocation at this point in time.
  * @shutdown: pointer to the driver's shutdown function.  This will be
  *	called when the device is removed from the system.
+ * @usb_driver: pointer to the struct usb_driver that controls this
+ *	device.  This is necessary to allow dynamic ids to be added to
+ *	the driver from sysfs.
  *
  * This structure is defines a USB Serial driver.  It provides all of
  * the information that the USB serial core code needs.  If the function
@@ -202,6 +205,8 @@ struct usb_serial_driver {
 
 	struct list_head	driver_list;
 	struct device_driver	driver;
+	struct usb_driver	*usb_driver;
+	struct usb_dynids	dynids;
 
 	int (*probe) (struct usb_serial *serial, const struct usb_device_id *id);
 	int (*attach) (struct usb_serial *serial);

commit 606d099cdd1080bbb50ea50dc52d98252f8f10a1
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Fri Dec 8 02:38:45 2006 -0800

    [PATCH] tty: switch to ktermios
    
    This is the grungy swap all the occurrences in the right places patch that
    goes with the updates.  At this point we have the same functionality as
    before (except that sgttyb() returns speeds not zero) and are ready to
    begin turning new stuff on providing nobody reports lots of bugs
    
    If you are a tty driver author converting an out of tree driver the only
    impact should be termios->ktermios name changes for the speed/property
    setting functions from your upper layers.
    
    If you are implementing your own TCGETS function before then your driver
    was broken already and its about to get a whole lot more painful for you so
    please fix it 8)
    
    Also fill in c_ispeed/ospeed on init for most devices, although the current
    code will do this for you anyway but I'd like eventually to lose that extra
    paranoia
    
    [akpm@osdl.org: bluetooth fix]
    [mp3@de.ibm.com: sclp fix]
    [mp3@de.ibm.com: warning fix for tty3270]
    [hugh@veritas.com: fix tty_ioctl powerpc build]
    [jdike@addtoit.com: uml: fix ->set_termios declaration]
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Martin Peschke <mp3@de.ibm.com>
    Acked-by: Peter Oberparleiter <oberpar@de.ibm.com>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Hugh Dickins <hugh@veritas.com>
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 91b3ea2bbb14..10f99e5f1a97 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -218,7 +218,7 @@ struct usb_serial_driver {
 	int  (*write)		(struct usb_serial_port *port, const unsigned char *buf, int count);
 	int  (*write_room)	(struct usb_serial_port *port);
 	int  (*ioctl)		(struct usb_serial_port *port, struct file * file, unsigned int cmd, unsigned long arg);
-	void (*set_termios)	(struct usb_serial_port *port, struct termios * old);
+	void (*set_termios)	(struct usb_serial_port *port, struct ktermios * old);
 	void (*break_ctl)	(struct usb_serial_port *port, int break_state);
 	int  (*chars_in_buffer)	(struct usb_serial_port *port);
 	void (*throttle)	(struct usb_serial_port *port);

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 91c983eef899..91b3ea2bbb14 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -226,10 +226,10 @@ struct usb_serial_driver {
 	int  (*tiocmget)	(struct usb_serial_port *port, struct file *file);
 	int  (*tiocmset)	(struct usb_serial_port *port, struct file *file, unsigned int set, unsigned int clear);
 
-	void (*read_int_callback)(struct urb *urb, struct pt_regs *regs);
-	void (*write_int_callback)(struct urb *urb, struct pt_regs *regs);
-	void (*read_bulk_callback)(struct urb *urb, struct pt_regs *regs);
-	void (*write_bulk_callback)(struct urb *urb, struct pt_regs *regs);
+	void (*read_int_callback)(struct urb *urb);
+	void (*write_int_callback)(struct urb *urb);
+	void (*read_bulk_callback)(struct urb *urb);
+	void (*write_bulk_callback)(struct urb *urb);
 };
 #define to_usb_serial_driver(d) container_of(d, struct usb_serial_driver, driver)
 
@@ -262,8 +262,8 @@ extern int usb_serial_generic_write (struct usb_serial_port *port, const unsigne
 extern void usb_serial_generic_close (struct usb_serial_port *port, struct file *filp);
 extern int usb_serial_generic_write_room (struct usb_serial_port *port);
 extern int usb_serial_generic_chars_in_buffer (struct usb_serial_port *port);
-extern void usb_serial_generic_read_bulk_callback (struct urb *urb, struct pt_regs *regs);
-extern void usb_serial_generic_write_bulk_callback (struct urb *urb, struct pt_regs *regs);
+extern void usb_serial_generic_read_bulk_callback (struct urb *urb);
+extern void usb_serial_generic_write_bulk_callback (struct urb *urb);
 extern void usb_serial_generic_shutdown (struct usb_serial *serial);
 extern int usb_serial_generic_register (int debug);
 extern void usb_serial_generic_deregister (void);

commit a969888ce91673c7f4b86520d851a6f0d5a5fa7d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Jul 11 21:22:58 2006 -0700

    [PATCH] USB: move usb-serial.h to include/linux/usb/
    
    USB serial outside of the kernel tree can not build properly due to
    usb-serial.h being buried down in the source tree.  This patch moves the
    location of the file to include/linux/usb and fixes up all of the usb
    serial drivers to handle the move properly.
    
    Cc: Sergei Organov <osv@javad.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
new file mode 100644
index 000000000000..91c983eef899
--- /dev/null
+++ b/include/linux/usb/serial.h
@@ -0,0 +1,300 @@
+/*
+ * USB Serial Converter stuff
+ *
+ *	Copyright (C) 1999 - 2005
+ *	    Greg Kroah-Hartman (greg@kroah.com)
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; version 2 of the License.
+ *
+ */
+
+
+#ifndef __LINUX_USB_SERIAL_H
+#define __LINUX_USB_SERIAL_H
+
+#include <linux/kref.h>
+#include <linux/mutex.h>
+
+#define SERIAL_TTY_MAJOR	188	/* Nice legal number now */
+#define SERIAL_TTY_MINORS	255	/* loads of devices :) */
+
+#define MAX_NUM_PORTS		8	/* The maximum number of ports one device can grab at once */
+
+/* parity check flag */
+#define RELEVANT_IFLAG(iflag)	(iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
+
+/**
+ * usb_serial_port: structure for the specific ports of a device.
+ * @serial: pointer back to the struct usb_serial owner of this port.
+ * @tty: pointer to the corresponding tty for this port.
+ * @lock: spinlock to grab when updating portions of this structure.
+ * @mutex: mutex used to synchronize serial_open() and serial_close()
+ *	access for this port.
+ * @number: the number of the port (the minor number).
+ * @interrupt_in_buffer: pointer to the interrupt in buffer for this port.
+ * @interrupt_in_urb: pointer to the interrupt in struct urb for this port.
+ * @interrupt_in_endpointAddress: endpoint address for the interrupt in pipe
+ *	for this port.
+ * @interrupt_out_buffer: pointer to the interrupt out buffer for this port.
+ * @interrupt_out_size: the size of the interrupt_out_buffer, in bytes.
+ * @interrupt_out_urb: pointer to the interrupt out struct urb for this port.
+ * @interrupt_out_endpointAddress: endpoint address for the interrupt out pipe
+ * 	for this port.
+ * @bulk_in_buffer: pointer to the bulk in buffer for this port.
+ * @read_urb: pointer to the bulk in struct urb for this port.
+ * @bulk_in_endpointAddress: endpoint address for the bulk in pipe for this
+ *	port.
+ * @bulk_out_buffer: pointer to the bulk out buffer for this port.
+ * @bulk_out_size: the size of the bulk_out_buffer, in bytes.
+ * @write_urb: pointer to the bulk out struct urb for this port.
+ * @bulk_out_endpointAddress: endpoint address for the bulk out pipe for this
+ *	port.
+ * @write_wait: a wait_queue_head_t used by the port.
+ * @work: work queue entry for the line discipline waking up.
+ * @open_count: number of times this port has been opened.
+ *
+ * This structure is used by the usb-serial core and drivers for the specific
+ * ports of a device.
+ */
+struct usb_serial_port {
+	struct usb_serial *	serial;
+	struct tty_struct *	tty;
+	spinlock_t		lock;
+	struct mutex            mutex;
+	unsigned char		number;
+
+	unsigned char *		interrupt_in_buffer;
+	struct urb *		interrupt_in_urb;
+	__u8			interrupt_in_endpointAddress;
+
+	unsigned char *		interrupt_out_buffer;
+	int			interrupt_out_size;
+	struct urb *		interrupt_out_urb;
+	__u8			interrupt_out_endpointAddress;
+
+	unsigned char *		bulk_in_buffer;
+	int			bulk_in_size;
+	struct urb *		read_urb;
+	__u8			bulk_in_endpointAddress;
+
+	unsigned char *		bulk_out_buffer;
+	int			bulk_out_size;
+	struct urb *		write_urb;
+	int			write_urb_busy;
+	__u8			bulk_out_endpointAddress;
+
+	wait_queue_head_t	write_wait;
+	struct work_struct	work;
+	int			open_count;
+	struct device		dev;
+};
+#define to_usb_serial_port(d) container_of(d, struct usb_serial_port, dev)
+
+/* get and set the port private data pointer helper functions */
+static inline void *usb_get_serial_port_data (struct usb_serial_port *port)
+{
+	return dev_get_drvdata(&port->dev);
+}
+
+static inline void usb_set_serial_port_data (struct usb_serial_port *port, void *data)
+{
+	dev_set_drvdata(&port->dev, data);
+}
+
+/**
+ * usb_serial - structure used by the usb-serial core for a device
+ * @dev: pointer to the struct usb_device for this device
+ * @type: pointer to the struct usb_serial_driver for this device
+ * @interface: pointer to the struct usb_interface for this device
+ * @minor: the starting minor number for this device
+ * @num_ports: the number of ports this device has
+ * @num_interrupt_in: number of interrupt in endpoints we have
+ * @num_interrupt_out: number of interrupt out endpoints we have
+ * @num_bulk_in: number of bulk in endpoints we have
+ * @num_bulk_out: number of bulk out endpoints we have
+ * @port: array of struct usb_serial_port structures for the different ports.
+ * @private: place to put any driver specific information that is needed.  The
+ *	usb-serial driver is required to manage this data, the usb-serial core
+ *	will not touch this.  Use usb_get_serial_data() and
+ *	usb_set_serial_data() to access this.
+ */
+struct usb_serial {
+	struct usb_device *		dev;
+	struct usb_serial_driver *	type;
+	struct usb_interface *		interface;
+	unsigned char			minor;
+	unsigned char			num_ports;
+	unsigned char			num_port_pointers;
+	char				num_interrupt_in;
+	char				num_interrupt_out;
+	char				num_bulk_in;
+	char				num_bulk_out;
+	struct usb_serial_port *	port[MAX_NUM_PORTS];
+	struct kref			kref;
+	void *				private;
+};
+#define to_usb_serial(d) container_of(d, struct usb_serial, kref)
+
+#define NUM_DONT_CARE	(-1)
+
+/* get and set the serial private data pointer helper functions */
+static inline void *usb_get_serial_data (struct usb_serial *serial)
+{
+	return serial->private;
+}
+
+static inline void usb_set_serial_data (struct usb_serial *serial, void *data)
+{
+	serial->private = data;
+}
+
+/**
+ * usb_serial_driver - describes a usb serial driver
+ * @description: pointer to a string that describes this driver.  This string used
+ *	in the syslog messages when a device is inserted or removed.
+ * @id_table: pointer to a list of usb_device_id structures that define all
+ *	of the devices this structure can support.
+ * @num_interrupt_in: the number of interrupt in endpoints this device will
+ *	have.
+ * @num_interrupt_out: the number of interrupt out endpoints this device will
+ *	have.
+ * @num_bulk_in: the number of bulk in endpoints this device will have.
+ * @num_bulk_out: the number of bulk out endpoints this device will have.
+ * @num_ports: the number of different ports this device will have.
+ * @calc_num_ports: pointer to a function to determine how many ports this
+ *	device has dynamically.  It will be called after the probe()
+ *	callback is called, but before attach()
+ * @probe: pointer to the driver's probe function.
+ *	This will be called when the device is inserted into the system,
+ *	but before the device has been fully initialized by the usb_serial
+ *	subsystem.  Use this function to download any firmware to the device,
+ *	or any other early initialization that might be needed.
+ *	Return 0 to continue on with the initialization sequence.  Anything
+ *	else will abort it.
+ * @attach: pointer to the driver's attach function.
+ *	This will be called when the struct usb_serial structure is fully set
+ *	set up.  Do any local initialization of the device, or any private
+ *	memory structure allocation at this point in time.
+ * @shutdown: pointer to the driver's shutdown function.  This will be
+ *	called when the device is removed from the system.
+ *
+ * This structure is defines a USB Serial driver.  It provides all of
+ * the information that the USB serial core code needs.  If the function
+ * pointers are defined, then the USB serial core code will call them when
+ * the corresponding tty port functions are called.  If they are not
+ * called, the generic serial function will be used instead.
+ *
+ * The driver.owner field should be set to the module owner of this driver.
+ * The driver.name field should be set to the name of this driver (remember
+ * it will show up in sysfs, so it needs to be short and to the point.
+ * Useing the module name is a good idea.)
+ */
+struct usb_serial_driver {
+	const char *description;
+	const struct usb_device_id *id_table;
+	char	num_interrupt_in;
+	char	num_interrupt_out;
+	char	num_bulk_in;
+	char	num_bulk_out;
+	char	num_ports;
+
+	struct list_head	driver_list;
+	struct device_driver	driver;
+
+	int (*probe) (struct usb_serial *serial, const struct usb_device_id *id);
+	int (*attach) (struct usb_serial *serial);
+	int (*calc_num_ports) (struct usb_serial *serial);
+
+	void (*shutdown) (struct usb_serial *serial);
+
+	int (*port_probe) (struct usb_serial_port *port);
+	int (*port_remove) (struct usb_serial_port *port);
+
+	/* serial function calls */
+	int  (*open)		(struct usb_serial_port *port, struct file * filp);
+	void (*close)		(struct usb_serial_port *port, struct file * filp);
+	int  (*write)		(struct usb_serial_port *port, const unsigned char *buf, int count);
+	int  (*write_room)	(struct usb_serial_port *port);
+	int  (*ioctl)		(struct usb_serial_port *port, struct file * file, unsigned int cmd, unsigned long arg);
+	void (*set_termios)	(struct usb_serial_port *port, struct termios * old);
+	void (*break_ctl)	(struct usb_serial_port *port, int break_state);
+	int  (*chars_in_buffer)	(struct usb_serial_port *port);
+	void (*throttle)	(struct usb_serial_port *port);
+	void (*unthrottle)	(struct usb_serial_port *port);
+	int  (*tiocmget)	(struct usb_serial_port *port, struct file *file);
+	int  (*tiocmset)	(struct usb_serial_port *port, struct file *file, unsigned int set, unsigned int clear);
+
+	void (*read_int_callback)(struct urb *urb, struct pt_regs *regs);
+	void (*write_int_callback)(struct urb *urb, struct pt_regs *regs);
+	void (*read_bulk_callback)(struct urb *urb, struct pt_regs *regs);
+	void (*write_bulk_callback)(struct urb *urb, struct pt_regs *regs);
+};
+#define to_usb_serial_driver(d) container_of(d, struct usb_serial_driver, driver)
+
+extern int  usb_serial_register(struct usb_serial_driver *driver);
+extern void usb_serial_deregister(struct usb_serial_driver *driver);
+extern void usb_serial_port_softint(struct usb_serial_port *port);
+
+extern int usb_serial_probe(struct usb_interface *iface, const struct usb_device_id *id);
+extern void usb_serial_disconnect(struct usb_interface *iface);
+
+extern int ezusb_writememory (struct usb_serial *serial, int address, unsigned char *data, int length, __u8 bRequest);
+extern int ezusb_set_reset (struct usb_serial *serial, unsigned char reset_bit);
+
+/* USB Serial console functions */
+#ifdef CONFIG_USB_SERIAL_CONSOLE
+extern void usb_serial_console_init (int debug, int minor);
+extern void usb_serial_console_exit (void);
+extern void usb_serial_console_disconnect(struct usb_serial *serial);
+#else
+static inline void usb_serial_console_init (int debug, int minor) { }
+static inline void usb_serial_console_exit (void) { }
+static inline void usb_serial_console_disconnect(struct usb_serial *serial) {}
+#endif
+
+/* Functions needed by other parts of the usbserial core */
+extern struct usb_serial *usb_serial_get_by_index (unsigned int minor);
+extern void usb_serial_put(struct usb_serial *serial);
+extern int usb_serial_generic_open (struct usb_serial_port *port, struct file *filp);
+extern int usb_serial_generic_write (struct usb_serial_port *port, const unsigned char *buf, int count);
+extern void usb_serial_generic_close (struct usb_serial_port *port, struct file *filp);
+extern int usb_serial_generic_write_room (struct usb_serial_port *port);
+extern int usb_serial_generic_chars_in_buffer (struct usb_serial_port *port);
+extern void usb_serial_generic_read_bulk_callback (struct urb *urb, struct pt_regs *regs);
+extern void usb_serial_generic_write_bulk_callback (struct urb *urb, struct pt_regs *regs);
+extern void usb_serial_generic_shutdown (struct usb_serial *serial);
+extern int usb_serial_generic_register (int debug);
+extern void usb_serial_generic_deregister (void);
+
+extern int usb_serial_bus_register (struct usb_serial_driver *device);
+extern void usb_serial_bus_deregister (struct usb_serial_driver *device);
+
+extern struct usb_serial_driver usb_serial_generic_device;
+extern struct bus_type usb_serial_bus_type;
+extern struct tty_driver *usb_serial_tty_driver;
+
+static inline void usb_serial_debug_data(int debug,
+					 struct device *dev,
+					 const char *function, int size,
+					 const unsigned char *data)
+{
+	int i;
+
+	if (debug) {
+		dev_printk(KERN_DEBUG, dev, "%s - length = %d, data = ", function, size);
+		for (i = 0; i < size; ++i)
+			printk ("%.2x ", data[i]);
+		printk ("\n");
+	}
+}
+
+/* Use our own dbg macro */
+#undef dbg
+#define dbg(format, arg...) do { if (debug) printk(KERN_DEBUG "%s: " format "\n" , __FILE__ , ## arg); } while (0)
+
+
+
+#endif	/* ifdef __LINUX_USB_SERIAL_H */
+
