commit 0290bd291cc0e0488e35e66bf39efcd7d9d9122b
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Tue Dec 10 09:23:51 2019 -0500

    netdev: pass the stuck queue to the timeout handler
    
    This allows incrementing the correct timeout statistic without any mess.
    Down the road, devices can learn to reset just the specific queue.
    
    The patch was generated with the following script:
    
    use strict;
    use warnings;
    
    our $^I = '.bak';
    
    my @work = (
    ["arch/m68k/emu/nfeth.c", "nfeth_tx_timeout"],
    ["arch/um/drivers/net_kern.c", "uml_net_tx_timeout"],
    ["arch/um/drivers/vector_kern.c", "vector_net_tx_timeout"],
    ["arch/xtensa/platforms/iss/network.c", "iss_net_tx_timeout"],
    ["drivers/char/pcmcia/synclink_cs.c", "hdlcdev_tx_timeout"],
    ["drivers/infiniband/ulp/ipoib/ipoib_main.c", "ipoib_timeout"],
    ["drivers/infiniband/ulp/ipoib/ipoib_main.c", "ipoib_timeout"],
    ["drivers/message/fusion/mptlan.c", "mpt_lan_tx_timeout"],
    ["drivers/misc/sgi-xp/xpnet.c", "xpnet_dev_tx_timeout"],
    ["drivers/net/appletalk/cops.c", "cops_timeout"],
    ["drivers/net/arcnet/arcdevice.h", "arcnet_timeout"],
    ["drivers/net/arcnet/arcnet.c", "arcnet_timeout"],
    ["drivers/net/arcnet/com20020.c", "arcnet_timeout"],
    ["drivers/net/ethernet/3com/3c509.c", "el3_tx_timeout"],
    ["drivers/net/ethernet/3com/3c515.c", "corkscrew_timeout"],
    ["drivers/net/ethernet/3com/3c574_cs.c", "el3_tx_timeout"],
    ["drivers/net/ethernet/3com/3c589_cs.c", "el3_tx_timeout"],
    ["drivers/net/ethernet/3com/3c59x.c", "vortex_tx_timeout"],
    ["drivers/net/ethernet/3com/3c59x.c", "vortex_tx_timeout"],
    ["drivers/net/ethernet/3com/typhoon.c", "typhoon_tx_timeout"],
    ["drivers/net/ethernet/8390/8390.h", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/8390.h", "eip_tx_timeout"],
    ["drivers/net/ethernet/8390/8390.c", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/8390p.c", "eip_tx_timeout"],
    ["drivers/net/ethernet/8390/ax88796.c", "ax_ei_tx_timeout"],
    ["drivers/net/ethernet/8390/axnet_cs.c", "axnet_tx_timeout"],
    ["drivers/net/ethernet/8390/etherh.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/8390/hydra.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/8390/mac8390.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/8390/mcf8390.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/8390/lib8390.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/8390/ne2k-pci.c", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/pcnet_cs.c", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/smc-ultra.c", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/wd.c", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/zorro8390.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/adaptec/starfire.c", "tx_timeout"],
    ["drivers/net/ethernet/agere/et131x.c", "et131x_tx_timeout"],
    ["drivers/net/ethernet/allwinner/sun4i-emac.c", "emac_timeout"],
    ["drivers/net/ethernet/alteon/acenic.c", "ace_watchdog"],
    ["drivers/net/ethernet/amazon/ena/ena_netdev.c", "ena_tx_timeout"],
    ["drivers/net/ethernet/amd/7990.h", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/7990.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/a2065.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/am79c961a.c", "am79c961_timeout"],
    ["drivers/net/ethernet/amd/amd8111e.c", "amd8111e_tx_timeout"],
    ["drivers/net/ethernet/amd/ariadne.c", "ariadne_tx_timeout"],
    ["drivers/net/ethernet/amd/atarilance.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/au1000_eth.c", "au1000_tx_timeout"],
    ["drivers/net/ethernet/amd/declance.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/lance.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/mvme147.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/ni65.c", "ni65_timeout"],
    ["drivers/net/ethernet/amd/nmclan_cs.c", "mace_tx_timeout"],
    ["drivers/net/ethernet/amd/pcnet32.c", "pcnet32_tx_timeout"],
    ["drivers/net/ethernet/amd/sunlance.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/xgbe/xgbe-drv.c", "xgbe_tx_timeout"],
    ["drivers/net/ethernet/apm/xgene-v2/main.c", "xge_timeout"],
    ["drivers/net/ethernet/apm/xgene/xgene_enet_main.c", "xgene_enet_timeout"],
    ["drivers/net/ethernet/apple/macmace.c", "mace_tx_timeout"],
    ["drivers/net/ethernet/atheros/ag71xx.c", "ag71xx_tx_timeout"],
    ["drivers/net/ethernet/atheros/alx/main.c", "alx_tx_timeout"],
    ["drivers/net/ethernet/atheros/atl1c/atl1c_main.c", "atl1c_tx_timeout"],
    ["drivers/net/ethernet/atheros/atl1e/atl1e_main.c", "atl1e_tx_timeout"],
    ["drivers/net/ethernet/atheros/atlx/atl.c", "atlx_tx_timeout"],
    ["drivers/net/ethernet/atheros/atlx/atl1.c", "atlx_tx_timeout"],
    ["drivers/net/ethernet/atheros/atlx/atl2.c", "atl2_tx_timeout"],
    ["drivers/net/ethernet/broadcom/b44.c", "b44_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bcmsysport.c", "bcm_sysport_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bnx2.c", "bnx2_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h", "bnx2x_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c", "bnx2x_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c", "bnx2x_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bnxt/bnxt.c", "bnxt_tx_timeout"],
    ["drivers/net/ethernet/broadcom/genet/bcmgenet.c", "bcmgenet_timeout"],
    ["drivers/net/ethernet/broadcom/sb1250-mac.c", "sbmac_tx_timeout"],
    ["drivers/net/ethernet/broadcom/tg3.c", "tg3_tx_timeout"],
    ["drivers/net/ethernet/calxeda/xgmac.c", "xgmac_tx_timeout"],
    ["drivers/net/ethernet/cavium/liquidio/lio_main.c", "liquidio_tx_timeout"],
    ["drivers/net/ethernet/cavium/liquidio/lio_vf_main.c", "liquidio_tx_timeout"],
    ["drivers/net/ethernet/cavium/liquidio/lio_vf_rep.c", "lio_vf_rep_tx_timeout"],
    ["drivers/net/ethernet/cavium/thunder/nicvf_main.c", "nicvf_tx_timeout"],
    ["drivers/net/ethernet/cirrus/cs89x0.c", "net_timeout"],
    ["drivers/net/ethernet/cisco/enic/enic_main.c", "enic_tx_timeout"],
    ["drivers/net/ethernet/cisco/enic/enic_main.c", "enic_tx_timeout"],
    ["drivers/net/ethernet/cortina/gemini.c", "gmac_tx_timeout"],
    ["drivers/net/ethernet/davicom/dm9000.c", "dm9000_timeout"],
    ["drivers/net/ethernet/dec/tulip/de2104x.c", "de_tx_timeout"],
    ["drivers/net/ethernet/dec/tulip/tulip_core.c", "tulip_tx_timeout"],
    ["drivers/net/ethernet/dec/tulip/winbond-840.c", "tx_timeout"],
    ["drivers/net/ethernet/dlink/dl2k.c", "rio_tx_timeout"],
    ["drivers/net/ethernet/dlink/sundance.c", "tx_timeout"],
    ["drivers/net/ethernet/emulex/benet/be_main.c", "be_tx_timeout"],
    ["drivers/net/ethernet/ethoc.c", "ethoc_tx_timeout"],
    ["drivers/net/ethernet/faraday/ftgmac100.c", "ftgmac100_tx_timeout"],
    ["drivers/net/ethernet/fealnx.c", "fealnx_tx_timeout"],
    ["drivers/net/ethernet/freescale/dpaa/dpaa_eth.c", "dpaa_tx_timeout"],
    ["drivers/net/ethernet/freescale/fec_main.c", "fec_timeout"],
    ["drivers/net/ethernet/freescale/fec_mpc52xx.c", "mpc52xx_fec_tx_timeout"],
    ["drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c", "fs_timeout"],
    ["drivers/net/ethernet/freescale/gianfar.c", "gfar_timeout"],
    ["drivers/net/ethernet/freescale/ucc_geth.c", "ucc_geth_timeout"],
    ["drivers/net/ethernet/fujitsu/fmvj18x_cs.c", "fjn_tx_timeout"],
    ["drivers/net/ethernet/google/gve/gve_main.c", "gve_tx_timeout"],
    ["drivers/net/ethernet/hisilicon/hip04_eth.c", "hip04_timeout"],
    ["drivers/net/ethernet/hisilicon/hix5hd2_gmac.c", "hix5hd2_net_timeout"],
    ["drivers/net/ethernet/hisilicon/hns/hns_enet.c", "hns_nic_net_timeout"],
    ["drivers/net/ethernet/hisilicon/hns3/hns3_enet.c", "hns3_nic_net_timeout"],
    ["drivers/net/ethernet/huawei/hinic/hinic_main.c", "hinic_tx_timeout"],
    ["drivers/net/ethernet/i825xx/82596.c", "i596_tx_timeout"],
    ["drivers/net/ethernet/i825xx/ether1.c", "ether1_timeout"],
    ["drivers/net/ethernet/i825xx/lib82596.c", "i596_tx_timeout"],
    ["drivers/net/ethernet/i825xx/sun3_82586.c", "sun3_82586_timeout"],
    ["drivers/net/ethernet/ibm/ehea/ehea_main.c", "ehea_tx_watchdog"],
    ["drivers/net/ethernet/ibm/emac/core.c", "emac_tx_timeout"],
    ["drivers/net/ethernet/ibm/emac/core.c", "emac_tx_timeout"],
    ["drivers/net/ethernet/ibm/ibmvnic.c", "ibmvnic_tx_timeout"],
    ["drivers/net/ethernet/intel/e100.c", "e100_tx_timeout"],
    ["drivers/net/ethernet/intel/e1000/e1000_main.c", "e1000_tx_timeout"],
    ["drivers/net/ethernet/intel/e1000e/netdev.c", "e1000_tx_timeout"],
    ["drivers/net/ethernet/intel/fm10k/fm10k_netdev.c", "fm10k_tx_timeout"],
    ["drivers/net/ethernet/intel/i40e/i40e_main.c", "i40e_tx_timeout"],
    ["drivers/net/ethernet/intel/iavf/iavf_main.c", "iavf_tx_timeout"],
    ["drivers/net/ethernet/intel/ice/ice_main.c", "ice_tx_timeout"],
    ["drivers/net/ethernet/intel/ice/ice_main.c", "ice_tx_timeout"],
    ["drivers/net/ethernet/intel/igb/igb_main.c", "igb_tx_timeout"],
    ["drivers/net/ethernet/intel/igbvf/netdev.c", "igbvf_tx_timeout"],
    ["drivers/net/ethernet/intel/ixgb/ixgb_main.c", "ixgb_tx_timeout"],
    ["drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c", "adapter->netdev->netdev_ops->ndo_tx_timeout(adapter->netdev);"],
    ["drivers/net/ethernet/intel/ixgbe/ixgbe_main.c", "ixgbe_tx_timeout"],
    ["drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c", "ixgbevf_tx_timeout"],
    ["drivers/net/ethernet/jme.c", "jme_tx_timeout"],
    ["drivers/net/ethernet/korina.c", "korina_tx_timeout"],
    ["drivers/net/ethernet/lantiq_etop.c", "ltq_etop_tx_timeout"],
    ["drivers/net/ethernet/marvell/mv643xx_eth.c", "mv643xx_eth_tx_timeout"],
    ["drivers/net/ethernet/marvell/pxa168_eth.c", "pxa168_eth_tx_timeout"],
    ["drivers/net/ethernet/marvell/skge.c", "skge_tx_timeout"],
    ["drivers/net/ethernet/marvell/sky2.c", "sky2_tx_timeout"],
    ["drivers/net/ethernet/marvell/sky2.c", "sky2_tx_timeout"],
    ["drivers/net/ethernet/mediatek/mtk_eth_soc.c", "mtk_tx_timeout"],
    ["drivers/net/ethernet/mellanox/mlx4/en_netdev.c", "mlx4_en_tx_timeout"],
    ["drivers/net/ethernet/mellanox/mlx4/en_netdev.c", "mlx4_en_tx_timeout"],
    ["drivers/net/ethernet/mellanox/mlx5/core/en_main.c", "mlx5e_tx_timeout"],
    ["drivers/net/ethernet/micrel/ks8842.c", "ks8842_tx_timeout"],
    ["drivers/net/ethernet/micrel/ksz884x.c", "netdev_tx_timeout"],
    ["drivers/net/ethernet/microchip/enc28j60.c", "enc28j60_tx_timeout"],
    ["drivers/net/ethernet/microchip/encx24j600.c", "encx24j600_tx_timeout"],
    ["drivers/net/ethernet/natsemi/sonic.h", "sonic_tx_timeout"],
    ["drivers/net/ethernet/natsemi/sonic.c", "sonic_tx_timeout"],
    ["drivers/net/ethernet/natsemi/jazzsonic.c", "sonic_tx_timeout"],
    ["drivers/net/ethernet/natsemi/macsonic.c", "sonic_tx_timeout"],
    ["drivers/net/ethernet/natsemi/natsemi.c", "ns_tx_timeout"],
    ["drivers/net/ethernet/natsemi/ns83820.c", "ns83820_tx_timeout"],
    ["drivers/net/ethernet/natsemi/xtsonic.c", "sonic_tx_timeout"],
    ["drivers/net/ethernet/neterion/s2io.h", "s2io_tx_watchdog"],
    ["drivers/net/ethernet/neterion/s2io.c", "s2io_tx_watchdog"],
    ["drivers/net/ethernet/neterion/vxge/vxge-main.c", "vxge_tx_watchdog"],
    ["drivers/net/ethernet/netronome/nfp/nfp_net_common.c", "nfp_net_tx_timeout"],
    ["drivers/net/ethernet/nvidia/forcedeth.c", "nv_tx_timeout"],
    ["drivers/net/ethernet/nvidia/forcedeth.c", "nv_tx_timeout"],
    ["drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c", "pch_gbe_tx_timeout"],
    ["drivers/net/ethernet/packetengines/hamachi.c", "hamachi_tx_timeout"],
    ["drivers/net/ethernet/packetengines/yellowfin.c", "yellowfin_tx_timeout"],
    ["drivers/net/ethernet/pensando/ionic/ionic_lif.c", "ionic_tx_timeout"],
    ["drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c", "netxen_tx_timeout"],
    ["drivers/net/ethernet/qlogic/qla3xxx.c", "ql3xxx_tx_timeout"],
    ["drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c", "qlcnic_tx_timeout"],
    ["drivers/net/ethernet/qualcomm/emac/emac.c", "emac_tx_timeout"],
    ["drivers/net/ethernet/qualcomm/qca_spi.c", "qcaspi_netdev_tx_timeout"],
    ["drivers/net/ethernet/qualcomm/qca_uart.c", "qcauart_netdev_tx_timeout"],
    ["drivers/net/ethernet/rdc/r6040.c", "r6040_tx_timeout"],
    ["drivers/net/ethernet/realtek/8139cp.c", "cp_tx_timeout"],
    ["drivers/net/ethernet/realtek/8139too.c", "rtl8139_tx_timeout"],
    ["drivers/net/ethernet/realtek/atp.c", "tx_timeout"],
    ["drivers/net/ethernet/realtek/r8169_main.c", "rtl8169_tx_timeout"],
    ["drivers/net/ethernet/renesas/ravb_main.c", "ravb_tx_timeout"],
    ["drivers/net/ethernet/renesas/sh_eth.c", "sh_eth_tx_timeout"],
    ["drivers/net/ethernet/renesas/sh_eth.c", "sh_eth_tx_timeout"],
    ["drivers/net/ethernet/samsung/sxgbe/sxgbe_main.c", "sxgbe_tx_timeout"],
    ["drivers/net/ethernet/seeq/ether3.c", "ether3_timeout"],
    ["drivers/net/ethernet/seeq/sgiseeq.c", "timeout"],
    ["drivers/net/ethernet/sfc/efx.c", "efx_watchdog"],
    ["drivers/net/ethernet/sfc/falcon/efx.c", "ef4_watchdog"],
    ["drivers/net/ethernet/sgi/ioc3-eth.c", "ioc3_timeout"],
    ["drivers/net/ethernet/sgi/meth.c", "meth_tx_timeout"],
    ["drivers/net/ethernet/silan/sc92031.c", "sc92031_tx_timeout"],
    ["drivers/net/ethernet/sis/sis190.c", "sis190_tx_timeout"],
    ["drivers/net/ethernet/sis/sis900.c", "sis900_tx_timeout"],
    ["drivers/net/ethernet/smsc/epic100.c", "epic_tx_timeout"],
    ["drivers/net/ethernet/smsc/smc911x.c", "smc911x_timeout"],
    ["drivers/net/ethernet/smsc/smc9194.c", "smc_timeout"],
    ["drivers/net/ethernet/smsc/smc91c92_cs.c", "smc_tx_timeout"],
    ["drivers/net/ethernet/smsc/smc91x.c", "smc_timeout"],
    ["drivers/net/ethernet/stmicro/stmmac/stmmac_main.c", "stmmac_tx_timeout"],
    ["drivers/net/ethernet/sun/cassini.c", "cas_tx_timeout"],
    ["drivers/net/ethernet/sun/ldmvsw.c", "sunvnet_tx_timeout_common"],
    ["drivers/net/ethernet/sun/niu.c", "niu_tx_timeout"],
    ["drivers/net/ethernet/sun/sunbmac.c", "bigmac_tx_timeout"],
    ["drivers/net/ethernet/sun/sungem.c", "gem_tx_timeout"],
    ["drivers/net/ethernet/sun/sunhme.c", "happy_meal_tx_timeout"],
    ["drivers/net/ethernet/sun/sunqe.c", "qe_tx_timeout"],
    ["drivers/net/ethernet/sun/sunvnet.c", "sunvnet_tx_timeout_common"],
    ["drivers/net/ethernet/sun/sunvnet_common.c", "sunvnet_tx_timeout_common"],
    ["drivers/net/ethernet/sun/sunvnet_common.h", "sunvnet_tx_timeout_common"],
    ["drivers/net/ethernet/synopsys/dwc-xlgmac-net.c", "xlgmac_tx_timeout"],
    ["drivers/net/ethernet/ti/cpmac.c", "cpmac_tx_timeout"],
    ["drivers/net/ethernet/ti/cpsw.c", "cpsw_ndo_tx_timeout"],
    ["drivers/net/ethernet/ti/cpsw_priv.c", "cpsw_ndo_tx_timeout"],
    ["drivers/net/ethernet/ti/cpsw_priv.h", "cpsw_ndo_tx_timeout"],
    ["drivers/net/ethernet/ti/davinci_emac.c", "emac_dev_tx_timeout"],
    ["drivers/net/ethernet/ti/netcp_core.c", "netcp_ndo_tx_timeout"],
    ["drivers/net/ethernet/ti/tlan.c", "tlan_tx_timeout"],
    ["drivers/net/ethernet/toshiba/ps3_gelic_net.h", "gelic_net_tx_timeout"],
    ["drivers/net/ethernet/toshiba/ps3_gelic_net.c", "gelic_net_tx_timeout"],
    ["drivers/net/ethernet/toshiba/ps3_gelic_wireless.c", "gelic_net_tx_timeout"],
    ["drivers/net/ethernet/toshiba/spider_net.c", "spider_net_tx_timeout"],
    ["drivers/net/ethernet/toshiba/tc35815.c", "tc35815_tx_timeout"],
    ["drivers/net/ethernet/via/via-rhine.c", "rhine_tx_timeout"],
    ["drivers/net/ethernet/wiznet/w5100.c", "w5100_tx_timeout"],
    ["drivers/net/ethernet/wiznet/w5300.c", "w5300_tx_timeout"],
    ["drivers/net/ethernet/xilinx/xilinx_emaclite.c", "xemaclite_tx_timeout"],
    ["drivers/net/ethernet/xircom/xirc2ps_cs.c", "xirc_tx_timeout"],
    ["drivers/net/fjes/fjes_main.c", "fjes_tx_retry"],
    ["drivers/net/slip/slip.c", "sl_tx_timeout"],
    ["include/linux/usb/usbnet.h", "usbnet_tx_timeout"],
    ["drivers/net/usb/aqc111.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/asix_devices.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/asix_devices.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/asix_devices.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/ax88172a.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/ax88179_178a.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/catc.c", "catc_tx_timeout"],
    ["drivers/net/usb/cdc_mbim.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/cdc_ncm.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/dm9601.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/hso.c", "hso_net_tx_timeout"],
    ["drivers/net/usb/int51x1.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/ipheth.c", "ipheth_tx_timeout"],
    ["drivers/net/usb/kaweth.c", "kaweth_tx_timeout"],
    ["drivers/net/usb/lan78xx.c", "lan78xx_tx_timeout"],
    ["drivers/net/usb/mcs7830.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/pegasus.c", "pegasus_tx_timeout"],
    ["drivers/net/usb/qmi_wwan.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/r8152.c", "rtl8152_tx_timeout"],
    ["drivers/net/usb/rndis_host.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/rtl8150.c", "rtl8150_tx_timeout"],
    ["drivers/net/usb/sierra_net.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/smsc75xx.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/smsc95xx.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/sr9700.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/sr9800.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/usbnet.c", "usbnet_tx_timeout"],
    ["drivers/net/vmxnet3/vmxnet3_drv.c", "vmxnet3_tx_timeout"],
    ["drivers/net/wan/cosa.c", "cosa_net_timeout"],
    ["drivers/net/wan/farsync.c", "fst_tx_timeout"],
    ["drivers/net/wan/fsl_ucc_hdlc.c", "uhdlc_tx_timeout"],
    ["drivers/net/wan/lmc/lmc_main.c", "lmc_driver_timeout"],
    ["drivers/net/wan/x25_asy.c", "x25_asy_timeout"],
    ["drivers/net/wimax/i2400m/netdev.c", "i2400m_tx_timeout"],
    ["drivers/net/wireless/intel/ipw2x00/ipw2100.c", "ipw2100_tx_timeout"],
    ["drivers/net/wireless/intersil/hostap/hostap_main.c", "prism2_tx_timeout"],
    ["drivers/net/wireless/intersil/hostap/hostap_main.c", "prism2_tx_timeout"],
    ["drivers/net/wireless/intersil/hostap/hostap_main.c", "prism2_tx_timeout"],
    ["drivers/net/wireless/intersil/orinoco/main.c", "orinoco_tx_timeout"],
    ["drivers/net/wireless/intersil/orinoco/orinoco_usb.c", "orinoco_tx_timeout"],
    ["drivers/net/wireless/intersil/orinoco/orinoco.h", "orinoco_tx_timeout"],
    ["drivers/net/wireless/intersil/prism54/islpci_dev.c", "islpci_eth_tx_timeout"],
    ["drivers/net/wireless/intersil/prism54/islpci_eth.c", "islpci_eth_tx_timeout"],
    ["drivers/net/wireless/intersil/prism54/islpci_eth.h", "islpci_eth_tx_timeout"],
    ["drivers/net/wireless/marvell/mwifiex/main.c", "mwifiex_tx_timeout"],
    ["drivers/net/wireless/quantenna/qtnfmac/core.c", "qtnf_netdev_tx_timeout"],
    ["drivers/net/wireless/quantenna/qtnfmac/core.h", "qtnf_netdev_tx_timeout"],
    ["drivers/net/wireless/rndis_wlan.c", "usbnet_tx_timeout"],
    ["drivers/net/wireless/wl3501_cs.c", "wl3501_tx_timeout"],
    ["drivers/net/wireless/zydas/zd1201.c", "zd1201_tx_timeout"],
    ["drivers/s390/net/qeth_core.h", "qeth_tx_timeout"],
    ["drivers/s390/net/qeth_core_main.c", "qeth_tx_timeout"],
    ["drivers/s390/net/qeth_l2_main.c", "qeth_tx_timeout"],
    ["drivers/s390/net/qeth_l2_main.c", "qeth_tx_timeout"],
    ["drivers/s390/net/qeth_l3_main.c", "qeth_tx_timeout"],
    ["drivers/s390/net/qeth_l3_main.c", "qeth_tx_timeout"],
    ["drivers/staging/ks7010/ks_wlan_net.c", "ks_wlan_tx_timeout"],
    ["drivers/staging/qlge/qlge_main.c", "qlge_tx_timeout"],
    ["drivers/staging/rtl8192e/rtl8192e/rtl_core.c", "_rtl92e_tx_timeout"],
    ["drivers/staging/rtl8192u/r8192U_core.c", "tx_timeout"],
    ["drivers/staging/unisys/visornic/visornic_main.c", "visornic_xmit_timeout"],
    ["drivers/staging/wlan-ng/p80211netdev.c", "p80211knetdev_tx_timeout"],
    ["drivers/tty/n_gsm.c", "gsm_mux_net_tx_timeout"],
    ["drivers/tty/synclink.c", "hdlcdev_tx_timeout"],
    ["drivers/tty/synclink_gt.c", "hdlcdev_tx_timeout"],
    ["drivers/tty/synclinkmp.c", "hdlcdev_tx_timeout"],
    ["net/atm/lec.c", "lec_tx_timeout"],
    ["net/bluetooth/bnep/netdev.c", "bnep_net_timeout"]
    );
    
    for my $p (@work) {
            my @pair = @$p;
            my $file = $pair[0];
            my $func = $pair[1];
            print STDERR $file , ": ", $func,"\n";
            our @ARGV = ($file);
            while (<ARGV>) {
                    if (m/($func\s*\(struct\s+net_device\s+\*[A-Za-z_]?[A-Za-z-0-9_]*)(\))/) {
                            print STDERR "found $1+$2 in $file\n";
                    }
                    if (s/($func\s*\(struct\s+net_device\s+\*[A-Za-z_]?[A-Za-z-0-9_]*)(\))/$1, unsigned int txqueue$2/) {
                            print STDERR "$func found in $file\n";
                    }
                    print;
            }
    }
    
    where the list of files and functions is simply from:
    
    git grep ndo_tx_timeout, with manual addition of headers
    in the rare cases where the function is from a header,
    then manually changing the few places which actually
    call ndo_tx_timeout.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Acked-by: Heiner Kallweit <hkallweit1@gmail.com>
    Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Acked-by: Shannon Nelson <snelson@pensando.io>
    Reviewed-by: Martin Habets <mhabets@solarflare.com>
    
    changes from v9:
            fixup a forward declaration
    changes from v9:
            more leftovers from v3 change
    changes from v8:
            fix up a missing direct call to timeout
            rebased on net-next
    changes from v7:
            fixup leftovers from v3 change
    changes from v6:
            fix typo in rtl driver
    changes from v5:
            add missing files (allow any net device argument name)
    changes from v4:
            add a missing driver header
    changes from v3:
            change queue # to unsigned
    Changes from v2:
            added headers
    Changes from v1:
            Fix errors found by kbuild:
            generalize the pattern a bit, to pick up
            a couple of instances missed by the previous
            version.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index d8860f2d0976..b0bff3083278 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -253,7 +253,7 @@ extern int usbnet_open(struct net_device *net);
 extern int usbnet_stop(struct net_device *net);
 extern netdev_tx_t usbnet_start_xmit(struct sk_buff *skb,
 				     struct net_device *net);
-extern void usbnet_tx_timeout(struct net_device *net);
+extern void usbnet_tx_timeout(struct net_device *net, unsigned int txqueue);
 extern int usbnet_change_mtu(struct net_device *net, int new_mtu);
 
 extern int usbnet_get_endpoints(struct usbnet *, struct usb_interface *);

commit f3edc2dbe0ad0bbbd8450cd37328f99acf215fd8
Author: Ben Dooks <ben-linux@fluff.org>
Date:   Mon Oct 1 17:02:43 2018 +0100

    net: usbnet: make driver_info const
    
    The driver_info field that is used for describing each of the usb-net
    drivers using the usbnet.c core all declare their information as const
    and the usbnet.c itself does not try and modify the struct.
    
    It is therefore a good idea to make this const in the usbnet.c structure
    in case anyone tries to modify it.
    
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index e2ec3582e549..d8860f2d0976 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -28,7 +28,7 @@ struct usbnet {
 	/* housekeeping */
 	struct usb_device	*udev;
 	struct usb_interface	*intf;
-	struct driver_info	*driver_info;
+	const struct driver_info *driver_info;
 	const char		*driver_name;
 	void			*driver_priv;
 	wait_queue_head_t	wait;

commit a4abd7a80addb4a9547f7dfc7812566b60ec505c
Author: Bjørn Mork <bjorn@mork.no>
Date:   Wed Dec 6 20:21:24 2017 +0100

    usbnet: fix alignment for frames with no ethernet header
    
    The qmi_wwan minidriver support a 'raw-ip' mode where frames are
    received without any ethernet header. This causes alignment issues
    because the skbs allocated by usbnet are "IP aligned".
    
    Fix by allowing minidrivers to disable the additional alignment
    offset. This is implemented using a per-device flag, since the same
    minidriver also supports 'ethernet' mode.
    
    Fixes: 32f7adf633b9 ("net: qmi_wwan: support "raw IP" mode")
    Reported-and-tested-by: Jay Foster <jay@systech.com>
    Signed-off-by: Bjørn Mork <bjorn@mork.no>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index a69877734c4e..e2ec3582e549 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -82,6 +82,7 @@ struct usbnet {
 #		define EVENT_RX_KILL	10
 #		define EVENT_LINK_CHANGE	11
 #		define EVENT_SET_RX_MODE	12
+#		define EVENT_NO_IP_ALIGN	13
 };
 
 static inline struct usb_driver *driver_of(struct usb_interface *intf)

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 97116379db5f..a69877734c4e 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * USB Networking Link Interface
  *

commit 7f65b1f5adc5f8496ca8bec4947de66fefe36220
Author: Oliver Neukum <oneukum@suse.com>
Date:   Mon May 22 14:50:30 2017 +0200

    cdc-ether: divorce initialisation with a filter reset and a generic method
    
    Some devices need their multicast filter reset but others are crashed by that.
    So the methods need to be separated.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.com>
    Reported-by: "Ridgway, Keith" <kridgway@harris.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 7dffa5624ea6..97116379db5f 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -206,6 +206,7 @@ struct cdc_state {
 };
 
 extern int usbnet_generic_cdc_bind(struct usbnet *, struct usb_interface *);
+extern int usbnet_ether_cdc_bind(struct usbnet *dev, struct usb_interface *intf);
 extern int usbnet_cdc_bind(struct usbnet *, struct usb_interface *);
 extern void usbnet_cdc_unbind(struct usbnet *, struct usb_interface *);
 extern void usbnet_cdc_status(struct usbnet *, struct urb *);

commit c8b5d129ee293bcf972e7279ac996bb8a138505c
Author: Greg Ungerer <gerg@linux-m68k.org>
Date:   Mon Apr 3 15:50:03 2017 +1000

    net: usbnet: support 64bit stats
    
    Add support for the net stats64 counters to the usbnet core. With that
    in place put the hooks into every usbnet driver to use it.
    
    This is a strait forward addition of 64bit counters for RX and TX packet
    and byte counts. It is done in the same style as for the other net drivers
    that support stats64. Note that the other stats fields remain as 32bit
    sized values (error counts, etc).
    
    The motivation to add this is that it is not particularly difficult to
    get the RX and TX byte counts to wrap on 32bit platforms.
    
    Signed-off-by: Greg Ungerer <gerg@linux-m68k.org>
    Acked-by: Bjørn Mork <bjorn@mork.no>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index e2b56917450f..7dffa5624ea6 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -64,6 +64,8 @@ struct usbnet {
 	struct usb_anchor	deferred;
 	struct tasklet_struct	bh;
 
+	struct pcpu_sw_netstats __percpu *stats64;
+
 	struct work_struct	kevent;
 	unsigned long		flags;
 #		define EVENT_TX_HALT	0
@@ -278,5 +280,7 @@ extern int usbnet_status_start(struct usbnet *dev, gfp_t mem_flags);
 extern void usbnet_status_stop(struct usbnet *dev);
 
 extern void usbnet_update_max_qlen(struct usbnet *dev);
+extern void usbnet_get_stats64(struct net_device *dev,
+			       struct rtnl_link_stats64 *stats);
 
 #endif /* __LINUX_USB_USBNET_H */

commit bde87ad64c4cee7a1d5b41d217b440e21050813e
Author: Philippe Reynes <tremyfr@gmail.com>
Date:   Thu Mar 16 23:18:57 2017 +0100

    net: usb: usb: remove old api ethtool_{get|set}_settings
    
    The function usbnet_{get|set}_settings is no longer used,
    so we remove it.
    
    Signed-off-by: Philippe Reynes <tremyfr@gmail.com>
    Acked-by: Oliver Neukum <oneukum@suse.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 5bd80078b7fe..e2b56917450f 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -261,10 +261,6 @@ extern void usbnet_pause_rx(struct usbnet *);
 extern void usbnet_resume_rx(struct usbnet *);
 extern void usbnet_purge_paused_rxq(struct usbnet *);
 
-extern int usbnet_get_settings(struct net_device *net,
-			       struct ethtool_cmd *cmd);
-extern int usbnet_set_settings(struct net_device *net,
-			       struct ethtool_cmd *cmd);
 extern int usbnet_get_link_ksettings(struct net_device *net,
 				     struct ethtool_link_ksettings *cmd);
 extern int usbnet_set_link_ksettings(struct net_device *net,

commit 8bae3551e93de4e8a5b959c495b06de9264be0d5
Author: Philippe Reynes <tremyfr@gmail.com>
Date:   Thu Mar 16 23:18:47 2017 +0100

    net: usb: usbnet: add new api ethtool_{get|set}_link_ksettings
    
    The ethtool api {get|set}_settings is deprecated.
    We add the new api {get|set}_link_ksettings to this driver.
    
    As I don't have the hardware, I'd be very pleased if
    someone may test this patch.
    
    Signed-off-by: Philippe Reynes <tremyfr@gmail.com>
    Acked-by: Oliver Neukum <oneukum@suse.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 6e0ce8c7b8cb..5bd80078b7fe 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -265,6 +265,10 @@ extern int usbnet_get_settings(struct net_device *net,
 			       struct ethtool_cmd *cmd);
 extern int usbnet_set_settings(struct net_device *net,
 			       struct ethtool_cmd *cmd);
+extern int usbnet_get_link_ksettings(struct net_device *net,
+				     struct ethtool_link_ksettings *cmd);
+extern int usbnet_set_link_ksettings(struct net_device *net,
+				     const struct ethtool_link_ksettings *cmd);
 extern u32 usbnet_get_link(struct net_device *net);
 extern u32 usbnet_get_msglevel(struct net_device *);
 extern void usbnet_set_msglevel(struct net_device *, u32);

commit 7a1e890e2168e33fb62d84528e996b8b4b478fea
Author: Ben Hutchings <ben.hutchings@codethink.co.uk>
Date:   Wed Mar 25 21:41:33 2015 +0100

    usbnet: Fix tx_bytes statistic running backward in cdc_ncm
    
    cdc_ncm disagrees with usbnet about how much framing overhead should
    be counted in the tx_bytes statistics, and tries 'fix' this by
    decrementing tx_bytes on the transmit path.  But statistics must never
    be decremented except due to roll-over; this will thoroughly confuse
    user-space.  Also, tx_bytes is only incremented by usbnet in the
    completion path.
    
    Fix this by requiring drivers that set FLAG_MULTI_FRAME to set a
    tx_bytes delta along with the tx_packets count.
    
    Fixes: beeecd42c3b4 ("net: cdc_ncm/cdc_mbim: adding NCM protocol statistics")
    Signed-off-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Signed-off-by: Bjørn Mork <bjorn@mork.no>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index ff3fb2bd0e90..6e0ce8c7b8cb 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -227,7 +227,7 @@ struct skb_data {	/* skb->cb is one of these */
 	struct urb		*urb;
 	struct usbnet		*dev;
 	enum skb_state		state;
-	size_t			length;
+	long			length;
 	unsigned long		packets;
 };
 
@@ -235,11 +235,13 @@ struct skb_data {	/* skb->cb is one of these */
  * tx_fixup method before returning an skb.
  */
 static inline void
-usbnet_set_skb_tx_stats(struct sk_buff *skb, unsigned long packets)
+usbnet_set_skb_tx_stats(struct sk_buff *skb,
+			unsigned long packets, long bytes_delta)
 {
 	struct skb_data *entry = (struct skb_data *) skb->cb;
 
 	entry->packets = packets;
+	entry->length = bytes_delta;
 }
 
 extern int usbnet_open(struct net_device *net);

commit 1e9e39f4a29857a396ac7b669d109f697f66695e
Author: Ben Hutchings <ben.hutchings@codethink.co.uk>
Date:   Thu Feb 26 19:34:37 2015 +0000

    usbnet: Fix tx_packets stat for FLAG_MULTI_FRAME drivers
    
    Currently the usbnet core does not update the tx_packets statistic for
    drivers with FLAG_MULTI_PACKET and there is no hook in the TX
    completion path where they could do this.
    
    cdc_ncm and dependent drivers are bumping tx_packets stat on the
    transmit path while asix and sr9800 aren't updating it at all.
    
    Add a packet count in struct skb_data so these drivers can fill it
    in, initialise it to 1 for other drivers, and add the packet count
    to the tx_packets statistic on completion.
    
    Signed-off-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Tested-by: Bjørn Mork <bjorn@mork.no>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index d9a4905e01d0..ff3fb2bd0e90 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -228,8 +228,20 @@ struct skb_data {	/* skb->cb is one of these */
 	struct usbnet		*dev;
 	enum skb_state		state;
 	size_t			length;
+	unsigned long		packets;
 };
 
+/* Drivers that set FLAG_MULTI_PACKET must call this in their
+ * tx_fixup method before returning an skb.
+ */
+static inline void
+usbnet_set_skb_tx_stats(struct sk_buff *skb, unsigned long packets)
+{
+	struct skb_data *entry = (struct skb_data *) skb->cb;
+
+	entry->packets = packets;
+}
+
 extern int usbnet_open(struct net_device *net);
 extern int usbnet_stop(struct net_device *net);
 extern netdev_tx_t usbnet_start_xmit(struct sk_buff *skb,

commit 1efed2d06c703489342ab6af2951683e07509c99
Author: Olivier Blin <olivier.blin@softathome.com>
Date:   Fri Oct 24 19:43:00 2014 +0200

    usbnet: add a callback for set_rx_mode
    
    To delegate promiscuous mode and multicast filtering to the subdriver.
    
    Signed-off-by: Olivier Blin <olivier.blin@softathome.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 26088feb6608..d9a4905e01d0 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -78,6 +78,7 @@ struct usbnet {
 #		define EVENT_NO_RUNTIME_PM	9
 #		define EVENT_RX_KILL	10
 #		define EVENT_LINK_CHANGE	11
+#		define EVENT_SET_RX_MODE	12
 };
 
 static inline struct usb_driver *driver_of(struct usb_interface *intf)
@@ -159,6 +160,9 @@ struct driver_info {
 	/* called by minidriver when receiving indication */
 	void	(*indication)(struct usbnet *dev, void *ind, int indlen);
 
+	/* rx mode change (device changes address list filtering) */
+	void	(*set_rx_mode)(struct usbnet *dev);
+
 	/* for new devices, use the descriptor-reading code instead */
 	int		in;		/* rx endpoint */
 	int		out;		/* tx endpoint */

commit dbcdd4d58c7230bea3157d56d6ef77c493b3865b
Author: Oliver Neukum <oneukum@suse.de>
Date:   Fri Aug 1 14:01:51 2014 +0200

    cdc_subset: deal with a device that needs reset for timeout
    
    This device needs to be reset to recover from a timeout.
    Unfortunately this can be handled only at the level of
    the subdrivers.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 0662e98fef72..26088feb6608 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -148,6 +148,9 @@ struct driver_info {
 	struct sk_buff	*(*tx_fixup)(struct usbnet *dev,
 				struct sk_buff *skb, gfp_t flags);
 
+	/* recover from timeout */
+	void	(*recover)(struct usbnet *dev);
+
 	/* early initialization code, can sleep. This is for minidrivers
 	 * having 'subminidrivers' that need to do extra initialization
 	 * right after minidriver have initialized hardware. */

commit 1d8fcba1de632d7a43349788ad534c5a32c5a44c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 30 08:56:23 2014 -0700

    Revert "cdc_subset: deal with a device that needs reset for timeout"
    
    This reverts commit 20fbe3ae990fd54fc7d1f889d61958bc8b38f254.
    
    As reported by Stephen Rothwell, it causes compile failures in certain
    configurations:
    
      drivers/net/usb/cdc_subset.c:360:15: error: 'dummy_prereset' undeclared here (not in a function)
        .pre_reset = dummy_prereset,
                     ^
      drivers/net/usb/cdc_subset.c:361:16: error: 'dummy_postreset' undeclared here (not in a function)
        .post_reset = dummy_postreset,
                      ^
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: David Miller <davem@davemloft.net>
    Cc: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 26088feb6608..0662e98fef72 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -148,9 +148,6 @@ struct driver_info {
 	struct sk_buff	*(*tx_fixup)(struct usbnet *dev,
 				struct sk_buff *skb, gfp_t flags);
 
-	/* recover from timeout */
-	void	(*recover)(struct usbnet *dev);
-
 	/* early initialization code, can sleep. This is for minidrivers
 	 * having 'subminidrivers' that need to do extra initialization
 	 * right after minidriver have initialized hardware. */

commit 20fbe3ae990fd54fc7d1f889d61958bc8b38f254
Author: Oliver Neukum <oneukum@suse.de>
Date:   Mon Jul 28 10:12:34 2014 +0200

    cdc_subset: deal with a device that needs reset for timeout
    
    This device needs to be reset to recover from a timeout.
    Unfortunately this can be handled only at the level of
    the subdrivers.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 0662e98fef72..26088feb6608 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -148,6 +148,9 @@ struct driver_info {
 	struct sk_buff	*(*tx_fixup)(struct usbnet *dev,
 				struct sk_buff *skb, gfp_t flags);
 
+	/* recover from timeout */
+	void	(*recover)(struct usbnet *dev);
+
 	/* early initialization code, can sleep. This is for minidrivers
 	 * having 'subminidrivers' that need to do extra initialization
 	 * right after minidriver have initialized hardware. */

commit 14a0d635d18d0fb552dcc979d6d25106e6541f2e
Author: Oliver Neukum <oneukum@suse.de>
Date:   Wed Mar 26 14:32:51 2014 +0100

    usbnet: include wait queue head in device structure
    
    This fixes a race which happens by freeing an object on the stack.
    Quoting Julius:
    > The issue is
    > that it calls usbnet_terminate_urbs() before that, which temporarily
    > installs a waitqueue in dev->wait in order to be able to wait on the
    > tasklet to run and finish up some queues. The waiting itself looks
    > okay, but the access to 'dev->wait' is totally unprotected and can
    > race arbitrarily. I think in this case usbnet_bh() managed to succeed
    > it's dev->wait check just before usbnet_terminate_urbs() sets it back
    > to NULL. The latter then finishes and the waitqueue_t structure on its
    > stack gets overwritten by other functions halfway through the
    > wake_up() call in usbnet_bh().
    
    The fix is to just not allocate the data structure on the stack.
    As dev->wait is abused as a flag it also takes a runtime PM change
    to fix this bug.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Reported-by: Grant Grundler <grundler@google.com>
    Tested-by: Grant Grundler <grundler@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index e303eef94dd5..0662e98fef72 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -30,7 +30,7 @@ struct usbnet {
 	struct driver_info	*driver_info;
 	const char		*driver_name;
 	void			*driver_priv;
-	wait_queue_head_t	*wait;
+	wait_queue_head_t	wait;
 	struct mutex		phy_mutex;
 	unsigned char		suspend_count;
 	unsigned char		pkt_cnt, pkt_err;

commit 60e453a940ac678565b6641d65f8c18541bb9f28
Author: Ming Lei <ming.lei@canonical.com>
Date:   Mon Sep 23 20:59:35 2013 +0800

    USBNET: fix handling padding packet
    
    Commit 638c5115a7949(USBNET: support DMA SG) introduces DMA SG
    if the usb host controller is capable of building packet from
    discontinuous buffers, but missed handling padding packet when
    building DMA SG.
    
    This patch attachs the pre-allocated padding packet at the
    end of the sg list, so padding packet can be sent to device
    if drivers require that.
    
    Reported-by: David Laight <David.Laight@aculab.com>
    Acked-by: Oliver Neukum <oliver@neukum.org>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 9cb2fe8ca944..e303eef94dd5 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -42,6 +42,7 @@ struct usbnet {
 	struct usb_host_endpoint *status;
 	unsigned		maxpacket;
 	struct timer_list	delay;
+	const char		*padding_pkt;
 
 	/* protocol/interface state */
 	struct net_device	*net;

commit cc998ff8811530be521f6b316f37ab7676a07938
Merge: 57d730924d5c 0d40f75bdab2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 5 14:54:29 2013 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next
    
    Pull networking changes from David Miller:
     "Noteworthy changes this time around:
    
       1) Multicast rejoin support for team driver, from Jiri Pirko.
    
       2) Centralize and simplify TCP RTT measurement handling in order to
          reduce the impact of bad RTO seeding from SYN/ACKs.  Also, when
          both timestamps and local RTT measurements are available prefer
          the later because there are broken middleware devices which
          scramble the timestamp.
    
          From Yuchung Cheng.
    
       3) Add TCP_NOTSENT_LOWAT socket option to limit the amount of kernel
          memory consumed to queue up unsend user data.  From Eric Dumazet.
    
       4) Add a "physical port ID" abstraction for network devices, from
          Jiri Pirko.
    
       5) Add a "suppress" operation to influence fib_rules lookups, from
          Stefan Tomanek.
    
       6) Add a networking development FAQ, from Paul Gortmaker.
    
       7) Extend the information provided by tcp_probe and add ipv6 support,
          from Daniel Borkmann.
    
       8) Use RCU locking more extensively in openvswitch data paths, from
          Pravin B Shelar.
    
       9) Add SCTP support to openvswitch, from Joe Stringer.
    
      10) Add EF10 chip support to SFC driver, from Ben Hutchings.
    
      11) Add new SYNPROXY netfilter target, from Patrick McHardy.
    
      12) Compute a rate approximation for sending in TCP sockets, and use
          this to more intelligently coalesce TSO frames.  Furthermore, add
          a new packet scheduler which takes advantage of this estimate when
          available.  From Eric Dumazet.
    
      13) Allow AF_PACKET fanouts with random selection, from Daniel
          Borkmann.
    
      14) Add ipv6 support to vxlan driver, from Cong Wang"
    
    Resolved conflicts as per discussion.
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next: (1218 commits)
      openvswitch: Fix alignment of struct sw_flow_key.
      netfilter: Fix build errors with xt_socket.c
      tcp: Add missing braces to do_tcp_setsockopt
      caif: Add missing braces to multiline if in cfctrl_linkup_request
      bnx2x: Add missing braces in bnx2x:bnx2x_link_initialize
      vxlan: Fix kernel panic on device delete.
      net: mvneta: implement ->ndo_do_ioctl() to support PHY ioctls
      net: mvneta: properly disable HW PHY polling and ensure adjust_link() works
      icplus: Use netif_running to determine device state
      ethernet/arc/arc_emac: Fix huge delays in large file copies
      tuntap: orphan frags before trying to set tx timestamp
      tuntap: purge socket error queue on detach
      qlcnic: use standard NAPI weights
      ipv6:introduce function to find route for redirect
      bnx2x: VF RSS support - VF side
      bnx2x: VF RSS support - PF side
      vxlan: Notify drivers for listening UDP port changes
      net: usbnet: update addr_assign_type if appropriate
      driver/net: enic: update enic maintainers and driver
      driver/net: enic: Exposing symbols for Cisco's low latency driver
      ...

commit 638c5115a794981441246fa8fa5d95c1875af5ba
Author: Ming Lei <ming.lei@canonical.com>
Date:   Thu Aug 8 21:48:24 2013 +0800

    USBNET: support DMA SG
    
    This patch introduces support of DMA SG if the USB host controller
    which usbnet device is attached to is capable of building packet from
    discontinuous buffers.
    
    The patch supports passing the skb fragment buffers to usb stack directly
    via urb->sg.
    
    Cc: Ben Hutchings <bhutchings@solarflare.com>
    Cc: Grant Grundler <grundler@google.com>
    Cc: Freddy Xin <freddy@asix.com.tw>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Reviewed-by: Eric Dumazet <edumazet@google.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index f18d64129f99..2b47e6364e36 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -34,6 +34,7 @@ struct usbnet {
 	struct mutex		phy_mutex;
 	unsigned char		suspend_count;
 	unsigned char		pkt_cnt, pkt_err;
+	unsigned		can_dma_sg:1;
 
 	/* i/o info: pipes etc */
 	unsigned		in, out;

commit a88c32ae15f25fcf0a3c9fadd92f840a1abf0e43
Author: Ming Lei <ming.lei@canonical.com>
Date:   Thu Jul 25 13:47:53 2013 +0800

    USBNET: centralize computing of max rx/tx qlen
    
    This patch centralizes computing of max rx/tx qlen, because:
    
    - RX_QLEN()/TX_QLEN() is called in hot path
    - computing depends on device's usb speed, now we have ls/fs, hs, ss,
    so more checks need to be involved
    - in fact, max rx/tx qlen should not only depend on device USB
    speed, but also depend on ethernet link speed, so we need to
    consider that in future.
    - if SG support is done, max tx qlen may need change too
    
    Generally, hard_mtu and rx_urb_size are changed in bind(), reset()
    and link_reset() callback, and change mtu network operation, this
    patches introduces the API of usbnet_update_max_qlen(), and calls
    it in above path.
    
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index f18d64129f99..8fbc008e183e 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -34,6 +34,7 @@ struct usbnet {
 	struct mutex		phy_mutex;
 	unsigned char		suspend_count;
 	unsigned char		pkt_cnt, pkt_err;
+	unsigned short		rx_qlen, tx_qlen;
 
 	/* i/o info: pipes etc */
 	unsigned		in, out;
@@ -253,4 +254,6 @@ extern void usbnet_link_change(struct usbnet *, bool, bool);
 extern int usbnet_status_start(struct usbnet *dev, gfp_t mem_flags);
 extern void usbnet_status_stop(struct usbnet *dev);
 
+extern void usbnet_update_max_qlen(struct usbnet *dev);
+
 #endif /* __LINUX_USB_USBNET_H */

commit 6eecdc5f95a393cb558503123eae9a9a6642e835
Author: Dan Williams <dcbw@redhat.com>
Date:   Mon May 6 11:29:23 2013 +0000

    usbnet: allow status interrupt URB to always be active
    
    Some drivers (sierra_net) need the status interrupt URB
    active even when the device is closed, because they receive
    custom indications from firmware.  Add functions to refcount
    the status interrupt URB submit/kill operation so that
    sub-drivers and the generic driver don't fight over whether
    the status interrupt URB is active or not.
    
    A sub-driver can call usbnet_status_start() at any time, but
    the URB is only submitted the first time the function is
    called.  Likewise, when the sub-driver is done with the URB,
    it calls usbnet_status_stop() but the URB is only killed when
    all users have stopped it.  The URB is still killed and
    re-submitted for suspend/resume, as before, with the same
    refcount it had at suspend.
    
    Signed-off-by: Dan Williams <dcbw@redhat.com>
    Acked-by: Oliver Neukum <oliver@neukum.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index da46327fca17..f18d64129f99 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -56,6 +56,8 @@ struct usbnet {
 	struct sk_buff_head	done;
 	struct sk_buff_head	rxq_pause;
 	struct urb		*interrupt;
+	unsigned		interrupt_count;
+	struct mutex		interrupt_mutex;
 	struct usb_anchor	deferred;
 	struct tasklet_struct	bh;
 
@@ -248,4 +250,7 @@ extern int usbnet_nway_reset(struct net_device *net);
 extern int usbnet_manage_power(struct usbnet *, int);
 extern void usbnet_link_change(struct usbnet *, bool, bool);
 
+extern int usbnet_status_start(struct usbnet *dev, gfp_t mem_flags);
+extern void usbnet_status_stop(struct usbnet *dev);
+
 #endif /* __LINUX_USB_USBNET_H */

commit 4b49f58fff00e6e9b24eaa31d4c6324393d76b0a
Author: Ming Lei <ming.lei@canonical.com>
Date:   Thu Apr 11 04:40:40 2013 +0000

    usbnet: handle link change
    
    The link change is detected via the interrupt pipe, and bulk
    pipes are responsible for transfering packets, so it is reasonable
    to stop bulk transfer after link is reported as off.
    
    Two adavantages may be obtained with stopping bulk transfer
    after link becomes off:
    
    - USB bus bandwidth is saved(USB bus is shared bus except for
    USB3.0), for example, lots of 'IN' token packets and 'NYET'
    handshake packets is transfered on 2.0 bus.
    
    - probabaly power might be saved for usb host controller since
    cancelling bulk transfer may disable the asynchronous schedule of
    host controller.
    
    With this patch, when link becomes off, about ~10% performance
    boost can be found on bulk transfer of anther usb device which
    is attached to same bus with the usbnet device, see below
    test on next-20130410:
    
    - read from usb mass storage(Sandisk Extreme USB 3.0) on pandaboard
    with below command after unplugging ethernet cable:
    
            dd if=/dev/sda iflag=direct of=/dev/null bs=1M count=800
    
    - without the patch
    1, 838860800 bytes (839 MB) copied, 36.2216 s, 23.2 MB/s
    2, 838860800 bytes (839 MB) copied, 35.8368 s, 23.4 MB/s
    3, 838860800 bytes (839 MB) copied, 35.823 s, 23.4 MB/s
    4, 838860800 bytes (839 MB) copied, 35.937 s, 23.3 MB/s
    5, 838860800 bytes (839 MB) copied, 35.7365 s, 23.5 MB/s
    average: 23.6MB/s
    
    - with the patch
    1, 838860800 bytes (839 MB) copied, 32.3817 s, 25.9 MB/s
    2, 838860800 bytes (839 MB) copied, 31.7389 s, 26.4 MB/s
    3, 838860800 bytes (839 MB) copied, 32.438 s, 25.9 MB/s
    4, 838860800 bytes (839 MB) copied, 32.5492 s, 25.8 MB/s
    5, 838860800 bytes (839 MB) copied, 31.6178 s, 26.5 MB/s
    average: 26.1MB/s
    
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index eb021b8f53bd..da46327fca17 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -72,6 +72,7 @@ struct usbnet {
 #		define EVENT_DEVICE_REPORT_IDLE	8
 #		define EVENT_NO_RUNTIME_PM	9
 #		define EVENT_RX_KILL	10
+#		define EVENT_LINK_CHANGE	11
 };
 
 static inline struct usb_driver *driver_of(struct usb_interface *intf)

commit ac64995da872c8ae6f74a5556fdad565829985b0
Author: Ming Lei <ming.lei@canonical.com>
Date:   Thu Apr 11 04:40:30 2013 +0000

    usbnet: introduce usbnet_link_change API
    
    This patch introduces the API of usbnet_link_change, so that
    usbnet can handle link change centrally, which may help to
    implement killing traffic URBs for saving USB bus bandwidth
    and host controller power.
    
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 0e5ac93bab10..eb021b8f53bd 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -245,5 +245,6 @@ extern void usbnet_get_drvinfo(struct net_device *, struct ethtool_drvinfo *);
 extern int usbnet_nway_reset(struct net_device *net);
 
 extern int usbnet_manage_power(struct usbnet *, int);
+extern void usbnet_link_change(struct usbnet *, bool, bool);
 
 #endif /* __LINUX_USB_USBNET_H */

commit 9c79330d930b5774aed8eb323daebecedce2e245
Author: Lucas Stach <dev@lynxeye.de>
Date:   Thu Feb 7 16:18:39 2013 +0000

    net: usb: fix regression from FLAG_NOARP code
    
    In commit 6509141f9c2ba74df6cc72ec35cd1865276ae3a4 ("usbnet: add new
    flag FLAG_NOARP for usb net devices"), the newly added flag NOARP was
    using an already defined value, which broke drivers using flag
    MULTI_PACKET.
    
    Signed-off-by: Lucas Stach <dev@lynxeye.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 0de078d4cdb9..0e5ac93bab10 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -102,7 +102,6 @@ struct driver_info {
 #define FLAG_LINK_INTR	0x0800		/* updates link (carrier) status */
 
 #define FLAG_POINTTOPOINT 0x1000	/* possibly use "usb%d" names */
-#define FLAG_NOARP	0x2000		/* device can't do ARP */
 
 /*
  * Indicates to usbnet, that USB driver accumulates multiple IP packets.
@@ -110,6 +109,7 @@ struct driver_info {
  */
 #define FLAG_MULTI_PACKET	0x2000
 #define FLAG_RX_ASSEMBLE	0x4000	/* rx packets may span >1 frames */
+#define FLAG_NOARP		0x8000	/* device can't do ARP */
 
 	/* init device ... can sleep, or cause probe() failure */
 	int	(*bind)(struct usbnet *, struct usb_interface *);

commit 70c37bf97f2a91accba76080db69144f3b69f736
Author: Bjørn Mork <bjorn@mork.no>
Date:   Mon Jan 28 23:51:28 2013 +0000

    net: usbnet: prevent buggy devices from killing us
    
    A device sending 0 length frames as fast as it can has been
    observed killing the host system due to the resulting memory
    pressure.
    
    Temporarily disable RX skb allocation and URB submission when
    the current error ratio is high, preventing us from trying to
    allocate an infinite number of skbs.  Reenable as soon as we
    are finished processing the done queue, allowing the device
    to continue working after short error bursts.
    
    Signed-off-by: Bjørn Mork <bjorn@mork.no>
    Acked-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 5de7a220e986..0de078d4cdb9 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -33,6 +33,7 @@ struct usbnet {
 	wait_queue_head_t	*wait;
 	struct mutex		phy_mutex;
 	unsigned char		suspend_count;
+	unsigned char		pkt_cnt, pkt_err;
 
 	/* i/o info: pipes etc */
 	unsigned		in, out;
@@ -70,6 +71,7 @@ struct usbnet {
 #		define EVENT_DEV_OPEN	7
 #		define EVENT_DEVICE_REPORT_IDLE	8
 #		define EVENT_NO_RUNTIME_PM	9
+#		define EVENT_RX_KILL	10
 };
 
 static inline struct usb_driver *driver_of(struct usb_interface *intf)

commit 6509141f9c2ba74df6cc72ec35cd1865276ae3a4
Author: Wei Shuai <cpuwolf@gmail.com>
Date:   Mon Jan 21 06:00:31 2013 +0000

    usbnet: add new flag FLAG_NOARP for usb net devices
    
    We do have some USB net devices, which cannot do ARP.
    so we can introduce a new flag FLAG_NOARP, then client drivers
    can easily handle this kind of devices
    
    Signed-off-by: Wei Shuai <cpuwolf@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index bd45eb7bedc8..5de7a220e986 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -100,6 +100,7 @@ struct driver_info {
 #define FLAG_LINK_INTR	0x0800		/* updates link (carrier) status */
 
 #define FLAG_POINTTOPOINT 0x1000	/* possibly use "usb%d" names */
+#define FLAG_NOARP	0x2000		/* device can't do ARP */
 
 /*
  * Indicates to usbnet, that USB driver accumulates multiple IP packets.

commit 2dd7c8cf29769f6b66f26b501db2364640c2c9d0
Author: Oliver Neukum <oliver@neukum.org>
Date:   Tue Dec 18 04:45:52 2012 +0000

    usbnet: generic manage_power()
    
    Centralise common code for manage_power() in usbnet
    by making a generic simple implementation
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 288b32aadab2..bd45eb7bedc8 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -241,4 +241,6 @@ extern void usbnet_set_msglevel(struct net_device *, u32);
 extern void usbnet_get_drvinfo(struct net_device *, struct ethtool_drvinfo *);
 extern int usbnet_nway_reset(struct net_device *net);
 
+extern int usbnet_manage_power(struct usbnet *, int);
+
 #endif /* __LINUX_USB_USBNET_H */

commit a1c088e01b71d90852b0df5a77cdae46bd0e0c05
Author: Oliver Neukum <oliver@neukum.org>
Date:   Tue Dec 18 04:45:29 2012 +0000

    usbnet: handle PM failure gracefully
    
    If a device fails to do remote wakeup, this is no reason
    to abort an open totally. This patch just continues without
    runtime PM.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 9bbeabf66c54..288b32aadab2 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -69,6 +69,7 @@ struct usbnet {
 #		define EVENT_DEV_ASLEEP 6
 #		define EVENT_DEV_OPEN	7
 #		define EVENT_DEVICE_REPORT_IDLE	8
+#		define EVENT_NO_RUNTIME_PM	9
 };
 
 static inline struct usb_driver *driver_of(struct usb_interface *intf)

commit 0547fad2dd7ccaaf3c914ba49073fa37e4e241eb
Author: Ming Lei <ming.lei@canonical.com>
Date:   Tue Nov 6 04:53:04 2012 +0000

    usbnet: introduce usbnet_{read|write}_cmd_nopm
    
    This patch introduces the below two helpers to prepare for solving
    the usbnet runtime PM problem, which may cause some network utilities
    (ifconfig, ethtool,...) touch a suspended device.
    
            usbnet_read_cmd_nopm()
            usbnet_write_cmd_nopm()
    
    The above two helpers should be called by usbnet resume/suspend
    callback to avoid deadlock.
    
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 4410e4166c6c..9bbeabf66c54 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -167,6 +167,10 @@ extern int usbnet_read_cmd(struct usbnet *dev, u8 cmd, u8 reqtype,
 		    u16 value, u16 index, void *data, u16 size);
 extern int usbnet_write_cmd(struct usbnet *dev, u8 cmd, u8 reqtype,
 		    u16 value, u16 index, const void *data, u16 size);
+extern int usbnet_read_cmd_nopm(struct usbnet *dev, u8 cmd, u8 reqtype,
+		    u16 value, u16 index, void *data, u16 size);
+extern int usbnet_write_cmd_nopm(struct usbnet *dev, u8 cmd, u8 reqtype,
+		    u16 value, u16 index, const void *data, u16 size);
 extern int usbnet_write_cmd_async(struct usbnet *dev, u8 cmd, u8 reqtype,
 		    u16 value, u16 index, const void *data, u16 size);
 

commit 877bd862f32b815d54ab5fc10a4fd903d7bf3012
Author: Ming Lei <ming.lei@canonical.com>
Date:   Wed Oct 24 19:46:54 2012 +0000

    usbnet: introduce usbnet 3 command helpers
    
    This patch introduces the below 3 usb command helpers:
    
            usbnet_read_cmd / usbnet_write_cmd / usbnet_write_cmd_async
    
    so that each low level driver doesn't need to implement them
    by itself, and the dma buffer allocation for usb transfer and
    runtime PM things can be handled just in one place.
    
    Acked-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index ddbbb7de894b..4410e4166c6c 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -163,6 +163,12 @@ extern int usbnet_resume(struct usb_interface *);
 extern void usbnet_disconnect(struct usb_interface *);
 extern void usbnet_device_suggests_idle(struct usbnet *dev);
 
+extern int usbnet_read_cmd(struct usbnet *dev, u8 cmd, u8 reqtype,
+		    u16 value, u16 index, void *data, u16 size);
+extern int usbnet_write_cmd(struct usbnet *dev, u8 cmd, u8 reqtype,
+		    u16 value, u16 index, const void *data, u16 size);
+extern int usbnet_write_cmd_async(struct usbnet *dev, u8 cmd, u8 reqtype,
+		    u16 value, u16 index, const void *data, u16 size);
 
 /* Drivers that reuse some of the standard USB CDC infrastructure
  * (notably, using multiple interfaces according to the CDC

commit 5d9d01a30204c99edf99189018953ee84c5f5017
Author: Oliver Neukum <oliver@neukum.org>
Date:   Thu Oct 11 02:50:10 2012 +0000

    usbnet: Support devices reporting idleness
    
    Some device types support a form of power management in which
    the device suggests to the host that the device may be suspended
    now. Support for that is best located in usbnet.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index f87cf622317f..ddbbb7de894b 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -68,6 +68,7 @@ struct usbnet {
 #		define EVENT_RX_PAUSED	5
 #		define EVENT_DEV_ASLEEP 6
 #		define EVENT_DEV_OPEN	7
+#		define EVENT_DEVICE_REPORT_IDLE	8
 };
 
 static inline struct usb_driver *driver_of(struct usb_interface *intf)
@@ -160,6 +161,7 @@ extern int usbnet_probe(struct usb_interface *, const struct usb_device_id *);
 extern int usbnet_suspend(struct usb_interface *, pm_message_t);
 extern int usbnet_resume(struct usb_interface *);
 extern void usbnet_disconnect(struct usb_interface *);
+extern void usbnet_device_suggests_idle(struct usbnet *dev);
 
 
 /* Drivers that reuse some of the standard USB CDC infrastructure

commit 4a5a14d39e8164b5c77f1bf42851a58a69a6c7b2
Author: tom.leiming@gmail.com <tom.leiming@gmail.com>
Date:   Mon Jun 11 15:19:43 2012 +0000

    usbnet: remove flag of EVENT_DEV_WAKING
    
    The flag of EVENT_DEV_WAKING is not used any more, so just remove it.
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 76f439647c4b..f87cf622317f 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -66,9 +66,8 @@ struct usbnet {
 #		define EVENT_STS_SPLIT	3
 #		define EVENT_LINK_RESET	4
 #		define EVENT_RX_PAUSED	5
-#		define EVENT_DEV_WAKING 6
-#		define EVENT_DEV_ASLEEP 7
-#		define EVENT_DEV_OPEN	8
+#		define EVENT_DEV_ASLEEP 6
+#		define EVENT_DEV_OPEN	7
 };
 
 static inline struct usb_driver *driver_of(struct usb_interface *intf)

commit 5b6e9bcdeb65634b4ad604eb4536404bbfc62cfa
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Thu Apr 26 11:33:46 2012 +0800

    usbnet: fix skb traversing races during unlink(v2)
    
    Commit 4231d47e6fe69f061f96c98c30eaf9fb4c14b96d(net/usbnet: avoid
    recursive locking in usbnet_stop()) fixes the recursive locking
    problem by releasing the skb queue lock before unlink, but may
    cause skb traversing races:
            - after URB is unlinked and the queue lock is released,
            the refered skb and skb->next may be moved to done queue,
            even be released
            - in skb_queue_walk_safe, the next skb is still obtained
            by next pointer of the last skb
            - so maybe trigger oops or other problems
    
    This patch extends the usage of entry->state to describe 'start_unlink'
    state, so always holding the queue(rx/tx) lock to change the state if
    the referd skb is in rx or tx queue because we need to know if the
    refered urb has been started unlinking in unlink_urbs.
    
    The other part of this patch is based on Huajun's patch:
    always traverse from head of the tx/rx queue to get skb which is
    to be unlinked but not been started unlinking.
    
    Signed-off-by: Huajun Li <huajun.li.lee@gmail.com>
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Cc: Oliver Neukum <oneukum@suse.de>
    Cc: stable@kernel.org
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 605b0aa8d852..76f439647c4b 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -191,7 +191,8 @@ extern void usbnet_cdc_status(struct usbnet *, struct urb *);
 enum skb_state {
 	illegal = 0,
 	tx_start, tx_done,
-	rx_start, rx_done, rx_cleanup
+	rx_start, rx_done, rx_cleanup,
+	unlink_start
 };
 
 struct skb_data {	/* skb->cb is one of these */

commit 68972efa657040f891c7eda07c7da8c8dd576788
Author: Paul Stewart <pstew@chromium.org>
Date:   Thu Apr 28 05:43:37 2011 +0000

    usbnet: Resubmit interrupt URB if device is open
    
    Resubmit interrupt URB if device is open.  Use a flag set in
    usbnet_open() to determine this state.  Also kill and free
    interrupt URB in usbnet_disconnect().
    
    [Rebased off git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git]
    
    Signed-off-by: Paul Stewart <pstew@chromium.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 0e1855079fbb..605b0aa8d852 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -68,6 +68,7 @@ struct usbnet {
 #		define EVENT_RX_PAUSED	5
 #		define EVENT_DEV_WAKING 6
 #		define EVENT_DEV_ASLEEP 7
+#		define EVENT_DEV_OPEN	8
 };
 
 static inline struct usb_driver *driver_of(struct usb_interface *intf)

commit 38a2f37258f9e2ae3f6e4241e01088be8dfaf4e9
Author: huajun li <huajun.li.lee@gmail.com>
Date:   Wed Apr 13 15:43:32 2011 +0000

    usbnet: Fix up 'FLAG_POINTTOPOINT' and 'FLAG_MULTI_PACKET' overlaps.
    
    USB tethering does not work anymore since 2.6.39-rc2, but it's okay in
    -rc1. The root cause is the new added mask code 'FLAG_POINTTOPOINT'
    overlaps 'FLAG_MULTI_PACKET'  in  include/linux/usb/usbnet.h, this
    causes logic issue in  rx_process(). This patch cleans up the overlap.
    
    Reported-and-Tested-by: Gottfried Haider <gottfried.haider@gmail.com>
    Signed-off-by:  Huajun Li <huajun.li.lee@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 3c7329b8ea0e..0e1855079fbb 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -103,8 +103,8 @@ struct driver_info {
  * Indicates to usbnet, that USB driver accumulates multiple IP packets.
  * Affects statistic (counters) and short packet handling.
  */
-#define FLAG_MULTI_PACKET	0x1000
-#define FLAG_RX_ASSEMBLE	0x2000	/* rx packets may span >1 frames */
+#define FLAG_MULTI_PACKET	0x2000
+#define FLAG_RX_ASSEMBLE	0x4000	/* rx packets may span >1 frames */
 
 	/* init device ... can sleep, or cause probe() failure */
 	int	(*bind)(struct usbnet *, struct usb_interface *);

commit c261344d3ce3edac781f9d3c7eabe2e96d8e8fe8
Author: Arnd Bergmann <arnd.bergmann@linaro.org>
Date:   Fri Apr 1 20:12:02 2011 -0700

    usbnet: use eth%d name for known ethernet devices
    
    The documentation for the USB ethernet devices suggests that
    only some devices are supposed to use usb0 as the network interface
    name instead of eth0. The logic used there, and documented in
    Kconfig for CDC is that eth0 will be used when the mac address
    is a globally assigned one, but usb0 is used for the locally
    managed range that is typically used on point-to-point links.
    
    Unfortunately, this has caused a lot of pain on the smsc95xx
    device that is used on the popular pandaboard without an
    EEPROM to store the MAC address, which causes the driver to
    call random_ether_address().
    
    Obviously, there should be a proper MAC addressed assigned to
    the device, and discussions are ongoing about how to solve
    this, but this patch at least makes sure that the default
    interface naming gets a little saner and matches what the
    user can expect based on the documentation, including for
    new devices.
    
    The approach taken here is to flag whether a device might be a
    point-to-point link with the new FLAG_POINTTOPOINT setting in
    the usbnet driver_info. A driver can set both FLAG_POINTTOPOINT
    and FLAG_ETHER if it is not sure (e.g. cdc_ether), or just one
    of the two.  The usbnet framework only looks at the MAC address
    for device naming if both flags are set, otherwise it trusts the
    flag.
    
    Signed-off-by: Arnd Bergmann <arnd.bergmann@linaro.org>
    Tested-by: Andy Green <andy.green@linaro.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 201f2228f731..3c7329b8ea0e 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -97,6 +97,8 @@ struct driver_info {
 
 #define FLAG_LINK_INTR	0x0800		/* updates link (carrier) status */
 
+#define FLAG_POINTTOPOINT 0x1000	/* possibly use "usb%d" names */
+
 /*
  * Indicates to usbnet, that USB driver accumulates multiple IP packets.
  * Affects statistic (counters) and short packet handling.

commit 7a635ea989991d7f12d57a12f2ba7cb6d211e083
Author: Andrzej Zaborowski <andrew.zaborowski@intel.com>
Date:   Mon Mar 28 12:56:33 2011 +0000

    net/usb: Ethernet quirks for the LG-VL600 4G modem
    
    This adds a driver for the CDC Ethernet part of this modem.  The
    device's ID is blacklisted in cdc_ether.c and is white-listed in
    this new driver because of the quirks needed to make it useful.
    The modem's firmware exposes a CDC ACM port for modem control and a
    CDC Ethernet port for network data.  The descriptors look fine but
    both ports actually are some sort of multiplexers requiring non-
    standard headers added/removed from every packet or they get
    ignored.  All information is based on a usb traffic log from a
    Windows machine.
    
    On the Verizon 4G network I've seen speeds up to 1.1MB/s so far with
    this driver, a speed-o-meter site reports 16.2Mbps/10.5Mbps.
    Userspace scripts are required to talk to the CDC ACM port.
    
    Signed-off-by: Andrzej Zaborowski <balrogg@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 44842c8d38c0..201f2228f731 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -102,6 +102,7 @@ struct driver_info {
  * Affects statistic (counters) and short packet handling.
  */
 #define FLAG_MULTI_PACKET	0x1000
+#define FLAG_RX_ASSEMBLE	0x2000	/* rx packets may span >1 frames */
 
 	/* init device ... can sleep, or cause probe() failure */
 	int	(*bind)(struct usbnet *, struct usb_interface *);
@@ -172,7 +173,9 @@ struct cdc_state {
 };
 
 extern int usbnet_generic_cdc_bind(struct usbnet *, struct usb_interface *);
+extern int usbnet_cdc_bind(struct usbnet *, struct usb_interface *);
 extern void usbnet_cdc_unbind(struct usbnet *, struct usb_interface *);
+extern void usbnet_cdc_status(struct usbnet *, struct urb *);
 
 /* CDC and RNDIS support the same host-chosen packet filters for IN transfers */
 #define	DEFAULT_FILTER	(USB_CDC_PACKET_TYPE_BROADCAST \

commit 073285fd392f6dc901da7c698d46e1e2a7e26436
Author: Alexey Orishko <alexey.orishko@gmail.com>
Date:   Mon Nov 29 23:23:27 2010 +0000

    usbnet: changes for upcoming cdc_ncm driver
    
    Changes:
    include/linux/usb/usbnet.h:
    - a new flag to indicate driver's capability to accumulate IP packets in Tx
     direction and extract several packets from single skb in Rx direction.
    drivers/net/usb/usbnet.c:
    - the procedure of counting packets in usbnet was updated due to the
     accumulating of IP packets in the driver
    - no short packets are sent if indicated by the flag in driver_info
     structure
    
    Signed-off-by: Alexey Orishko <alexey.orishko@stericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 7ae27a473818..44842c8d38c0 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -97,6 +97,12 @@ struct driver_info {
 
 #define FLAG_LINK_INTR	0x0800		/* updates link (carrier) status */
 
+/*
+ * Indicates to usbnet, that USB driver accumulates multiple IP packets.
+ * Affects statistic (counters) and short packet handling.
+ */
+#define FLAG_MULTI_PACKET	0x1000
+
 	/* init device ... can sleep, or cause probe() failure */
 	int	(*bind)(struct usbnet *, struct usb_interface *);
 

commit 0858a3a52f659dabf2860f350e5a6a61f069e851
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon May 17 10:58:12 2010 -0700

    USB: include/usb/*.h checkpatch cleanup
    
    Lots of minor formatting cleanups in includes/usb/ to make checkpatch
    happier.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index df1e83dd9a54..7ae27a473818 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -43,7 +43,7 @@ struct usbnet {
 	/* protocol/interface state */
 	struct net_device	*net;
 	int			msg_enable;
-	unsigned long		data [5];
+	unsigned long		data[5];
 	u32			xid;
 	u32			hard_mtu;	/* count any extra framing */
 	size_t			rx_urb_size;	/* size for rx urbs */
@@ -148,8 +148,8 @@ struct driver_info {
  * much everything except custom framing and chip-specific stuff.
  */
 extern int usbnet_probe(struct usb_interface *, const struct usb_device_id *);
-extern int usbnet_suspend (struct usb_interface *, pm_message_t );
-extern int usbnet_resume (struct usb_interface *);
+extern int usbnet_suspend(struct usb_interface *, pm_message_t);
+extern int usbnet_resume(struct usb_interface *);
 extern void usbnet_disconnect(struct usb_interface *);
 
 
@@ -165,8 +165,8 @@ struct cdc_state {
 	struct usb_interface		*data;
 };
 
-extern int usbnet_generic_cdc_bind (struct usbnet *, struct usb_interface *);
-extern void usbnet_cdc_unbind (struct usbnet *, struct usb_interface *);
+extern int usbnet_generic_cdc_bind(struct usbnet *, struct usb_interface *);
+extern void usbnet_cdc_unbind(struct usbnet *, struct usb_interface *);
 
 /* CDC and RNDIS support the same host-chosen packet filters for IN transfers */
 #define	DEFAULT_FILTER	(USB_CDC_PACKET_TYPE_BROADCAST \
@@ -189,29 +189,31 @@ struct skb_data {	/* skb->cb is one of these */
 	size_t			length;
 };
 
-extern int usbnet_open (struct net_device *net);
-extern int usbnet_stop (struct net_device *net);
-extern netdev_tx_t usbnet_start_xmit (struct sk_buff *skb,
-				      struct net_device *net);
-extern void usbnet_tx_timeout (struct net_device *net);
-extern int usbnet_change_mtu (struct net_device *net, int new_mtu);
+extern int usbnet_open(struct net_device *net);
+extern int usbnet_stop(struct net_device *net);
+extern netdev_tx_t usbnet_start_xmit(struct sk_buff *skb,
+				     struct net_device *net);
+extern void usbnet_tx_timeout(struct net_device *net);
+extern int usbnet_change_mtu(struct net_device *net, int new_mtu);
 
 extern int usbnet_get_endpoints(struct usbnet *, struct usb_interface *);
 extern int usbnet_get_ethernet_addr(struct usbnet *, int);
-extern void usbnet_defer_kevent (struct usbnet *, int);
-extern void usbnet_skb_return (struct usbnet *, struct sk_buff *);
+extern void usbnet_defer_kevent(struct usbnet *, int);
+extern void usbnet_skb_return(struct usbnet *, struct sk_buff *);
 extern void usbnet_unlink_rx_urbs(struct usbnet *);
 
 extern void usbnet_pause_rx(struct usbnet *);
 extern void usbnet_resume_rx(struct usbnet *);
 extern void usbnet_purge_paused_rxq(struct usbnet *);
 
-extern int usbnet_get_settings (struct net_device *net, struct ethtool_cmd *cmd);
-extern int usbnet_set_settings (struct net_device *net, struct ethtool_cmd *cmd);
-extern u32 usbnet_get_link (struct net_device *net);
-extern u32 usbnet_get_msglevel (struct net_device *);
-extern void usbnet_set_msglevel (struct net_device *, u32);
-extern void usbnet_get_drvinfo (struct net_device *, struct ethtool_drvinfo *);
+extern int usbnet_get_settings(struct net_device *net,
+			       struct ethtool_cmd *cmd);
+extern int usbnet_set_settings(struct net_device *net,
+			       struct ethtool_cmd *cmd);
+extern u32 usbnet_get_link(struct net_device *net);
+extern u32 usbnet_get_msglevel(struct net_device *);
+extern void usbnet_set_msglevel(struct net_device *, u32);
+extern void usbnet_get_drvinfo(struct net_device *, struct ethtool_drvinfo *);
 extern int usbnet_nway_reset(struct net_device *net);
 
 #endif /* __LINUX_USB_USBNET_H */

commit 60b86755929e1a7e9038c8d860a8491cfdf8d93a
Author: Joe Perches <joe@perches.com>
Date:   Wed Feb 17 10:30:23 2010 +0000

    usbnet: Convert dev(dbg|err|warn|info) macros to netdev_<level>
    
    These macros are too similar to the dev_<level> equivalents
    but take a usbnet * argument.  Convert them to the recently
    introduced netdev_<level> macros and remove the old macros.
    
    The old macros had "\n" appended to the format string.
    Add the "\n" to the converted uses.
    
    Some existing uses of the dev<foo> macros in cdc_eem.c
    probably mistakenly had trailing "\n".  No "\n" added there.
    
    Fix net1080 this/other log message inversion.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 8ce61359bf73..df1e83dd9a54 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -214,25 +214,4 @@ extern void usbnet_set_msglevel (struct net_device *, u32);
 extern void usbnet_get_drvinfo (struct net_device *, struct ethtool_drvinfo *);
 extern int usbnet_nway_reset(struct net_device *net);
 
-/* messaging support includes the interface name, so it must not be
- * used before it has one ... notably, in minidriver bind() calls.
- */
-#ifdef DEBUG
-#define devdbg(usbnet, fmt, arg...) \
-	printk(KERN_DEBUG "%s: " fmt "\n" , (usbnet)->net->name , ## arg)
-#else
-#define devdbg(usbnet, fmt, arg...) \
-	({ if (0) printk(KERN_DEBUG "%s: " fmt "\n" , (usbnet)->net->name , \
-		## arg); 0; })
-#endif
-
-#define deverr(usbnet, fmt, arg...) \
-	printk(KERN_ERR "%s: " fmt "\n" , (usbnet)->net->name , ## arg)
-#define devwarn(usbnet, fmt, arg...) \
-	printk(KERN_WARNING "%s: " fmt "\n" , (usbnet)->net->name , ## arg)
-
-#define devinfo(usbnet, fmt, arg...) \
-	printk(KERN_INFO "%s: " fmt "\n" , (usbnet)->net->name , ## arg); \
-
-
 #endif /* __LINUX_USB_USBNET_H */

commit 69ee472f2706371ca639de49b06df91615c07d8d
Author: Oliver Neukum <oliver@neukum.org>
Date:   Thu Dec 3 15:31:18 2009 -0800

    usbnet & cdc-ether: Autosuspend for online devices
    
    Using remote wakeup and delayed transmission to allow
    online device to go into usb autosuspend.
    Minimal alternate support for devices that don't support
    remote wakeup.
    
    Signed-off-by: Oliver Neukum <oliver@neukum.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 8c84881f8478..8ce61359bf73 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -55,6 +55,7 @@ struct usbnet {
 	struct sk_buff_head	done;
 	struct sk_buff_head	rxq_pause;
 	struct urb		*interrupt;
+	struct usb_anchor	deferred;
 	struct tasklet_struct	bh;
 
 	struct work_struct	kevent;
@@ -65,6 +66,8 @@ struct usbnet {
 #		define EVENT_STS_SPLIT	3
 #		define EVENT_LINK_RESET	4
 #		define EVENT_RX_PAUSED	5
+#		define EVENT_DEV_WAKING 6
+#		define EVENT_DEV_ASLEEP 7
 };
 
 static inline struct usb_driver *driver_of(struct usb_interface *intf)
@@ -109,6 +112,9 @@ struct driver_info {
 	/* see if peer is connected ... can sleep */
 	int	(*check_connect)(struct usbnet *);
 
+	/* (dis)activate runtime power management */
+	int	(*manage_power)(struct usbnet *, int);
+
 	/* for status polling */
 	void	(*status)(struct usbnet *, struct urb *);
 

commit 37e8273cd30592d3a82bcb70cbb1bdc4eaeb6b71
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Wed Nov 4 15:29:52 2009 +0000

    usbnet: Set link down initially for drivers that update link state
    
    Some usbnet drivers update link state while others do not due to
    hardware limitations.  Add a flag to distinguish those that do, and
    set the link down initially for their devices.
    
    This is intended to fix this bug: http://bugs.debian.org/444043
    
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 86c31b753266..8c84881f8478 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -92,6 +92,7 @@ struct driver_info {
 #define FLAG_SEND_ZLP	0x0200		/* hw requires ZLPs are sent */
 #define FLAG_WWAN	0x0400		/* use "wwan%d" names */
 
+#define FLAG_LINK_INTR	0x0800		/* updates link (carrier) status */
 
 	/* init device ... can sleep, or cause probe() failure */
 	int	(*bind)(struct usbnet *, struct usb_interface *);

commit e1e499eef2200c2a7120c9ebf297d48b195cf887
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Oct 2 05:15:25 2009 +0000

    usbnet: Use wwan%d interface name for mobile broadband devices
    
    Add support for usbnet based devices like CDC-Ether to indicate that they
    are actually mobile broadband devices. In that case use wwan%d as default
    interface name.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index f81473052059..86c31b753266 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -90,6 +90,7 @@ struct driver_info {
 #define FLAG_WLAN	0x0080		/* use "wlan%d" names */
 #define FLAG_AVOID_UNLINK_URBS 0x0100	/* don't unlink urbs at usbnet_stop() */
 #define FLAG_SEND_ZLP	0x0200		/* hw requires ZLPs are sent */
+#define FLAG_WWAN	0x0400		/* use "wwan%d" names */
 
 
 	/* init device ... can sleep, or cause probe() failure */

commit ec4756238239f1a331d9fb95bad8b281dad56855
Author: Steve Glendinning <steve.glendinning@smsc.com>
Date:   Tue Sep 22 04:00:27 2009 +0000

    smsc95xx: fix transmission where ZLP is expected
    
    Usbnet framework assumes USB hardware doesn't handle zero length
    packets, but SMSC LAN95xx requires these to be sent for correct
    operation.
    
    This patch fixes an easily reproducible tx lockup when sending a frame
    that results in exactly 512 bytes in a USB transmission (e.g. a UDP
    frame with 458 data bytes, due to IP headers and our USB headers).  It
    adds an extra flag to usbnet for the hardware driver to indicate that
    it can handle and requires the zero length packets.
    
    This patch should not affect other usbnet users, please also consider
    for -stable.
    
    Signed-off-by: Steve Glendinning <steve.glendinning@smsc.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index bb69e256cd16..f81473052059 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -89,6 +89,7 @@ struct driver_info {
 #define FLAG_FRAMING_AX 0x0040		/* AX88772/178 packets */
 #define FLAG_WLAN	0x0080		/* use "wlan%d" names */
 #define FLAG_AVOID_UNLINK_URBS 0x0100	/* don't unlink urbs at usbnet_stop() */
+#define FLAG_SEND_ZLP	0x0200		/* hw requires ZLPs are sent */
 
 
 	/* init device ... can sleep, or cause probe() failure */

commit 25a79c41ce0ce88a4288adf278e9b0e00f228383
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Mon Aug 31 19:50:45 2009 +0000

    usbnet: convert to netdev_tx_t
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 09514252d84e..bb69e256cd16 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -182,7 +182,8 @@ struct skb_data {	/* skb->cb is one of these */
 
 extern int usbnet_open (struct net_device *net);
 extern int usbnet_stop (struct net_device *net);
-extern int usbnet_start_xmit (struct sk_buff *skb, struct net_device *net);
+extern netdev_tx_t usbnet_start_xmit (struct sk_buff *skb,
+				      struct net_device *net);
 extern void usbnet_tx_timeout (struct net_device *net);
 extern int usbnet_change_mtu (struct net_device *net, int new_mtu);
 

commit 7834ddbcc7a097443761b0722e8c9fb8511b95b1
Author: Jussi Kivilinna <jussi.kivilinna@mbnet.fi>
Date:   Tue Aug 11 22:57:16 2009 +0300

    usbnet: add rx queue pausing
    
    Add rx queue pausing to usbnet. This is needed by rndis_wlan so that it can
    control rx queue and prevent received packets from being send forward before
    rndis_wlan receives and handles 'media connect'-indication. Without this
    establishing WPA connections is hard and fail often.
    
    [v2] - removed unneeded use of skb_clone
    
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Jussi Kivilinna <jussi.kivilinna@mbnet.fi>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index de8b4b18961b..09514252d84e 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -53,6 +53,7 @@ struct usbnet {
 	struct sk_buff_head	rxq;
 	struct sk_buff_head	txq;
 	struct sk_buff_head	done;
+	struct sk_buff_head	rxq_pause;
 	struct urb		*interrupt;
 	struct tasklet_struct	bh;
 
@@ -63,6 +64,7 @@ struct usbnet {
 #		define EVENT_RX_MEMORY	2
 #		define EVENT_STS_SPLIT	3
 #		define EVENT_LINK_RESET	4
+#		define EVENT_RX_PAUSED	5
 };
 
 static inline struct usb_driver *driver_of(struct usb_interface *intf)
@@ -190,6 +192,10 @@ extern void usbnet_defer_kevent (struct usbnet *, int);
 extern void usbnet_skb_return (struct usbnet *, struct sk_buff *);
 extern void usbnet_unlink_rx_urbs(struct usbnet *);
 
+extern void usbnet_pause_rx(struct usbnet *);
+extern void usbnet_resume_rx(struct usbnet *);
+extern void usbnet_purge_paused_rxq(struct usbnet *);
+
 extern int usbnet_get_settings (struct net_device *net, struct ethtool_cmd *cmd);
 extern int usbnet_set_settings (struct net_device *net, struct ethtool_cmd *cmd);
 extern u32 usbnet_get_link (struct net_device *net);

commit 2a4901bcbe9c122bd56e1f6c337fcb4ad75fafb7
Author: Jussi Kivilinna <jussi.kivilinna@mbnet.fi>
Date:   Thu Jul 30 19:41:52 2009 +0300

    rndis_host: allow rndis_wlan to see all indications
    
    Allow rndis_wlan to see all indications. Currently rndis_host lets rndis_wlan to
    know about link state changes only, but there is whole set of other
    802.11-specific indications that rndis_wlan should handle properly. So rename
    link_change() to indication() and convert rndis_wlan to use it.
    
    Signed-off-by: Jussi Kivilinna <jussi.kivilinna@mbnet.fi>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index c642f78dd9cf..de8b4b18961b 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -122,9 +122,8 @@ struct driver_info {
 	 * right after minidriver have initialized hardware. */
 	int	(*early_init)(struct usbnet *dev);
 
-	/* called by minidriver when link state changes, state: 0=disconnect,
-	 * 1=connect */
-	void	(*link_change)(struct usbnet *dev, int state);
+	/* called by minidriver when receiving indication */
+	void	(*indication)(struct usbnet *dev, void *ind, int indlen);
 
 	/* for new devices, use the descriptor-reading code instead */
 	int		in;		/* rx endpoint */

commit 1487cd5e76337555737cbc55d7d83f41460d198f
Author: Jussi Kivilinna <jussi.kivilinna@mbnet.fi>
Date:   Thu Jul 30 19:41:20 2009 +0300

    usbnet: allow "minidriver" to prevent urb unlinking on usbnet_stop
    
    rndis_wlan devices freeze after running usbnet_stop several times. It appears
    that firmware freezes in state where it does not respond to any RNDIS commands
    and device have to be physically unplugged/replugged. This patch lets
    minidrivers to disable unlink_urbs on usbnet_stop through new info flag.
    
    Signed-off-by: Jussi Kivilinna <jussi.kivilinna@mbnet.fi>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 7c17b2efba86..c642f78dd9cf 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -86,6 +86,7 @@ struct driver_info {
 
 #define FLAG_FRAMING_AX 0x0040		/* AX88772/178 packets */
 #define FLAG_WLAN	0x0080		/* use "wlan%d" names */
+#define FLAG_AVOID_UNLINK_URBS 0x0100	/* don't unlink urbs at usbnet_stop() */
 
 
 	/* init device ... can sleep, or cause probe() failure */

commit a33e9e7f35ef6dcab528e0327f29188475f60691
Author: Jussi Kivilinna <jussi.kivilinna@mbnet.fi>
Date:   Tue Jun 16 17:17:27 2009 +0300

    usbnet: Add stop function pointer to 'struct rndis_data'.
    
    Allow minidriver to know that netdev has stopped. This is to let
    wireless turn off radio when usbnet dev is stopped.
    
    Signed-off-by: Jussi Kivilinna <jussi.kivilinna@mbnet.fi>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 310e18a880ff..7c17b2efba86 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -97,6 +97,9 @@ struct driver_info {
 	/* reset device ... can sleep */
 	int	(*reset)(struct usbnet *);
 
+	/* stop device ... can sleep */
+	int	(*stop)(struct usbnet *);
+
 	/* see if peer is connected ... can sleep */
 	int	(*check_connect)(struct usbnet *);
 

commit d9d62f3f2c6fa609883714f6fd6cd710a83d307f
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Mon Jun 29 16:54:12 2009 +0000

    usbnet: Remove private stats structure
    
    Now that nothing uses the private stats structure we can remove it.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 5d44059f6d63..310e18a880ff 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -42,7 +42,6 @@ struct usbnet {
 
 	/* protocol/interface state */
 	struct net_device	*net;
-	struct net_device_stats	stats;
 	int			msg_enable;
 	unsigned long		data [5];
 	u32			xid;

commit 03ad032bb78b2732b607ed198e951240e1d21e59
Author: Peter Holik <peter@holik.at>
Date:   Sat Apr 18 07:24:17 2009 +0000

    export usbnet_get_ethernet_addr from usbnet and fixed cdc_ether.c
    
    because of using the same function get_ethernet_addr as cdc_ether.c
    i export usbnet_get_ethernet_addr from usbnet and fixed cdc_ether
    (suggested by Oliver Neukum).
    
    Signed-off-by: Peter Holik <peter@holik.at>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 36fabb95c7d3..5d44059f6d63 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -183,6 +183,7 @@ extern void usbnet_tx_timeout (struct net_device *net);
 extern int usbnet_change_mtu (struct net_device *net, int new_mtu);
 
 extern int usbnet_get_endpoints(struct usbnet *, struct usb_interface *);
+extern int usbnet_get_ethernet_addr(struct usbnet *, int);
 extern void usbnet_defer_kevent (struct usbnet *, int);
 extern void usbnet_skb_return (struct usbnet *, struct sk_buff *);
 extern void usbnet_unlink_rx_urbs(struct usbnet *);

commit 777baa4711c6b8373f4e03a3a558d44a6b046d7a
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Fri Mar 20 19:35:54 2009 +0000

    usbnet: support net_device_ops
    
    Use net_device_ops for usbnet device, and export for use
    by other derived drivers.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 7d3822243074..36fabb95c7d3 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -176,6 +176,11 @@ struct skb_data {	/* skb->cb is one of these */
 	size_t			length;
 };
 
+extern int usbnet_open (struct net_device *net);
+extern int usbnet_stop (struct net_device *net);
+extern int usbnet_start_xmit (struct sk_buff *skb, struct net_device *net);
+extern void usbnet_tx_timeout (struct net_device *net);
+extern int usbnet_change_mtu (struct net_device *net, int new_mtu);
 
 extern int usbnet_get_endpoints(struct usbnet *, struct usb_interface *);
 extern void usbnet_defer_kevent (struct usbnet *, int);

commit 0b491eee46012772cbf029450d123e933c2e7940
Author: Steve Glendinning <steve.glendinning@smsc.com>
Date:   Wed Jan 21 12:35:43 2009 -0800

    usbnet: allow type check of devdbg arguments in non-debug build
    
    Improve usbnet's devdbg to always type-check diagnostic arguments,
    like dev_dbg (device.h).  This makes no change to the resulting size of
    usbnet modules.
    
    This patch also removes an #ifdef DEBUG directive from rndis_wlan so
    it's devdbg statements are always type-checked at compile time.
    
    Signed-off-by: Steve Glendinning <steve.glendinning@smsc.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index ba09fe88adda..7d3822243074 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -197,7 +197,9 @@ extern int usbnet_nway_reset(struct net_device *net);
 #define devdbg(usbnet, fmt, arg...) \
 	printk(KERN_DEBUG "%s: " fmt "\n" , (usbnet)->net->name , ## arg)
 #else
-#define devdbg(usbnet, fmt, arg...) do {} while(0)
+#define devdbg(usbnet, fmt, arg...) \
+	({ if (0) printk(KERN_DEBUG "%s: " fmt "\n" , (usbnet)->net->name , \
+		## arg); 0; })
 #endif
 
 #define deverr(usbnet, fmt, arg...) \

commit dda43a0e03a33dd716fb34f812b1af614f74daff
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Fri Mar 7 13:45:32 2008 -0500

    USB: Standardize inclusion protection and add where missing.
    
    For the header files in include/linux/usb, add missing multiple
    inclusion protection and standardize what's already there.  The
    apparent standards:
    
      * macro name of __LINUX_USB_headerfile_H
      * inclusion protection placed after leading comment block
      * macro name added as a comment on the final #endif
      * any obvious trivial whitespace cleanup associated with the above
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index e0501da3dd11..ba09fe88adda 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -19,10 +19,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-
-#ifndef	__USBNET_H
-#define	__USBNET_H
-
+#ifndef	__LINUX_USB_USBNET_H
+#define	__LINUX_USB_USBNET_H
 
 /* interface from usbnet core to each USB networking link we handle */
 struct usbnet {
@@ -211,4 +209,4 @@ extern int usbnet_nway_reset(struct net_device *net);
 	printk(KERN_INFO "%s: " fmt "\n" , (usbnet)->net->name , ## arg); \
 
 
-#endif	/* __USBNET_H */
+#endif /* __LINUX_USB_USBNET_H */

commit 3692e94f1559523b84a5a0e65929ee84b276e83f
Author: Jussi Kivilinna <jussi.kivilinna@mbnet.fi>
Date:   Sat Jan 26 00:51:45 2008 +0200

    Move usbnet.h and rndis_host.h to include/linux/usb
    
    Move headers usbnet.h and rndis_host.h to include/linux/usb and fix includes
    for drivers/net/usb modules. Headers are moved because rndis_wlan will be
    outside drivers/net/usb in drivers/net/wireless and yet need these headers.
    
    Signed-off-by: Jussi Kivilinna <jussi.kivilinna@mbnet.fi>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
new file mode 100644
index 000000000000..e0501da3dd11
--- /dev/null
+++ b/include/linux/usb/usbnet.h
@@ -0,0 +1,214 @@
+/*
+ * USB Networking Link Interface
+ *
+ * Copyright (C) 2000-2005 by David Brownell <dbrownell@users.sourceforge.net>
+ * Copyright (C) 2003-2005 David Hollis <dhollis@davehollis.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#ifndef	__USBNET_H
+#define	__USBNET_H
+
+
+/* interface from usbnet core to each USB networking link we handle */
+struct usbnet {
+	/* housekeeping */
+	struct usb_device	*udev;
+	struct usb_interface	*intf;
+	struct driver_info	*driver_info;
+	const char		*driver_name;
+	void			*driver_priv;
+	wait_queue_head_t	*wait;
+	struct mutex		phy_mutex;
+	unsigned char		suspend_count;
+
+	/* i/o info: pipes etc */
+	unsigned		in, out;
+	struct usb_host_endpoint *status;
+	unsigned		maxpacket;
+	struct timer_list	delay;
+
+	/* protocol/interface state */
+	struct net_device	*net;
+	struct net_device_stats	stats;
+	int			msg_enable;
+	unsigned long		data [5];
+	u32			xid;
+	u32			hard_mtu;	/* count any extra framing */
+	size_t			rx_urb_size;	/* size for rx urbs */
+	struct mii_if_info	mii;
+
+	/* various kinds of pending driver work */
+	struct sk_buff_head	rxq;
+	struct sk_buff_head	txq;
+	struct sk_buff_head	done;
+	struct urb		*interrupt;
+	struct tasklet_struct	bh;
+
+	struct work_struct	kevent;
+	unsigned long		flags;
+#		define EVENT_TX_HALT	0
+#		define EVENT_RX_HALT	1
+#		define EVENT_RX_MEMORY	2
+#		define EVENT_STS_SPLIT	3
+#		define EVENT_LINK_RESET	4
+};
+
+static inline struct usb_driver *driver_of(struct usb_interface *intf)
+{
+	return to_usb_driver(intf->dev.driver);
+}
+
+/* interface from the device/framing level "minidriver" to core */
+struct driver_info {
+	char		*description;
+
+	int		flags;
+/* framing is CDC Ethernet, not writing ZLPs (hw issues), or optionally: */
+#define FLAG_FRAMING_NC	0x0001		/* guard against device dropouts */
+#define FLAG_FRAMING_GL	0x0002		/* genelink batches packets */
+#define FLAG_FRAMING_Z	0x0004		/* zaurus adds a trailer */
+#define FLAG_FRAMING_RN	0x0008		/* RNDIS batches, plus huge header */
+
+#define FLAG_NO_SETINT	0x0010		/* device can't set_interface() */
+#define FLAG_ETHER	0x0020		/* maybe use "eth%d" names */
+
+#define FLAG_FRAMING_AX 0x0040		/* AX88772/178 packets */
+#define FLAG_WLAN	0x0080		/* use "wlan%d" names */
+
+
+	/* init device ... can sleep, or cause probe() failure */
+	int	(*bind)(struct usbnet *, struct usb_interface *);
+
+	/* cleanup device ... can sleep, but can't fail */
+	void	(*unbind)(struct usbnet *, struct usb_interface *);
+
+	/* reset device ... can sleep */
+	int	(*reset)(struct usbnet *);
+
+	/* see if peer is connected ... can sleep */
+	int	(*check_connect)(struct usbnet *);
+
+	/* for status polling */
+	void	(*status)(struct usbnet *, struct urb *);
+
+	/* link reset handling, called from defer_kevent */
+	int	(*link_reset)(struct usbnet *);
+
+	/* fixup rx packet (strip framing) */
+	int	(*rx_fixup)(struct usbnet *dev, struct sk_buff *skb);
+
+	/* fixup tx packet (add framing) */
+	struct sk_buff	*(*tx_fixup)(struct usbnet *dev,
+				struct sk_buff *skb, gfp_t flags);
+
+	/* early initialization code, can sleep. This is for minidrivers
+	 * having 'subminidrivers' that need to do extra initialization
+	 * right after minidriver have initialized hardware. */
+	int	(*early_init)(struct usbnet *dev);
+
+	/* called by minidriver when link state changes, state: 0=disconnect,
+	 * 1=connect */
+	void	(*link_change)(struct usbnet *dev, int state);
+
+	/* for new devices, use the descriptor-reading code instead */
+	int		in;		/* rx endpoint */
+	int		out;		/* tx endpoint */
+
+	unsigned long	data;		/* Misc driver specific data */
+};
+
+/* Minidrivers are just drivers using the "usbnet" core as a powerful
+ * network-specific subroutine library ... that happens to do pretty
+ * much everything except custom framing and chip-specific stuff.
+ */
+extern int usbnet_probe(struct usb_interface *, const struct usb_device_id *);
+extern int usbnet_suspend (struct usb_interface *, pm_message_t );
+extern int usbnet_resume (struct usb_interface *);
+extern void usbnet_disconnect(struct usb_interface *);
+
+
+/* Drivers that reuse some of the standard USB CDC infrastructure
+ * (notably, using multiple interfaces according to the CDC
+ * union descriptor) get some helper code.
+ */
+struct cdc_state {
+	struct usb_cdc_header_desc	*header;
+	struct usb_cdc_union_desc	*u;
+	struct usb_cdc_ether_desc	*ether;
+	struct usb_interface		*control;
+	struct usb_interface		*data;
+};
+
+extern int usbnet_generic_cdc_bind (struct usbnet *, struct usb_interface *);
+extern void usbnet_cdc_unbind (struct usbnet *, struct usb_interface *);
+
+/* CDC and RNDIS support the same host-chosen packet filters for IN transfers */
+#define	DEFAULT_FILTER	(USB_CDC_PACKET_TYPE_BROADCAST \
+			|USB_CDC_PACKET_TYPE_ALL_MULTICAST \
+			|USB_CDC_PACKET_TYPE_PROMISCUOUS \
+			|USB_CDC_PACKET_TYPE_DIRECTED)
+
+
+/* we record the state for each of our queued skbs */
+enum skb_state {
+	illegal = 0,
+	tx_start, tx_done,
+	rx_start, rx_done, rx_cleanup
+};
+
+struct skb_data {	/* skb->cb is one of these */
+	struct urb		*urb;
+	struct usbnet		*dev;
+	enum skb_state		state;
+	size_t			length;
+};
+
+
+extern int usbnet_get_endpoints(struct usbnet *, struct usb_interface *);
+extern void usbnet_defer_kevent (struct usbnet *, int);
+extern void usbnet_skb_return (struct usbnet *, struct sk_buff *);
+extern void usbnet_unlink_rx_urbs(struct usbnet *);
+
+extern int usbnet_get_settings (struct net_device *net, struct ethtool_cmd *cmd);
+extern int usbnet_set_settings (struct net_device *net, struct ethtool_cmd *cmd);
+extern u32 usbnet_get_link (struct net_device *net);
+extern u32 usbnet_get_msglevel (struct net_device *);
+extern void usbnet_set_msglevel (struct net_device *, u32);
+extern void usbnet_get_drvinfo (struct net_device *, struct ethtool_drvinfo *);
+extern int usbnet_nway_reset(struct net_device *net);
+
+/* messaging support includes the interface name, so it must not be
+ * used before it has one ... notably, in minidriver bind() calls.
+ */
+#ifdef DEBUG
+#define devdbg(usbnet, fmt, arg...) \
+	printk(KERN_DEBUG "%s: " fmt "\n" , (usbnet)->net->name , ## arg)
+#else
+#define devdbg(usbnet, fmt, arg...) do {} while(0)
+#endif
+
+#define deverr(usbnet, fmt, arg...) \
+	printk(KERN_ERR "%s: " fmt "\n" , (usbnet)->net->name , ## arg)
+#define devwarn(usbnet, fmt, arg...) \
+	printk(KERN_WARNING "%s: " fmt "\n" , (usbnet)->net->name , ## arg)
+
+#define devinfo(usbnet, fmt, arg...) \
+	printk(KERN_INFO "%s: " fmt "\n" , (usbnet)->net->name , ## arg); \
+
+
+#endif	/* __USBNET_H */
