commit c3c0ac70c77d34c03e9600170932b2c28478795f
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Apr 18 11:26:24 2018 +0200

    USB: phy: drop legacy board-file support
    
    The legacy interface for associating controllers with phys from board
    files and platform code has been unused since commit 9080b8dc761a ("ARM:
    OMAP2+: Remove legacy usb-host.c platform init code"). Since then, all
    calls to usb_get_phy_dev() and its devres version have been returning
    -ENODEV.
    
    Now that the final calls to these functions have been removed, we can
    drop this legacy lookup interface altogether.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index ac5a079161e1..e4de6bc1f69b 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -157,22 +157,6 @@ struct usb_phy {
 	enum usb_charger_type (*charger_detect)(struct usb_phy *x);
 };
 
-/**
- * struct usb_phy_bind - represent the binding for the phy
- * @dev_name: the device name of the device that will bind to the phy
- * @phy_dev_name: the device name of the phy
- * @index: used if a single controller uses multiple phys
- * @phy: reference to the phy
- * @list: to maintain a linked list of the binding information
- */
-struct usb_phy_bind {
-	const char	*dev_name;
-	const char	*phy_dev_name;
-	u8		index;
-	struct usb_phy	*phy;
-	struct list_head list;
-};
-
 /* for board-specific init logic */
 extern int usb_add_phy(struct usb_phy *, enum usb_phy_type type);
 extern int usb_add_phy_dev(struct usb_phy *);
@@ -234,8 +218,6 @@ usb_phy_vbus_off(struct usb_phy *x)
 extern struct usb_phy *usb_get_phy(enum usb_phy_type type);
 extern struct usb_phy *devm_usb_get_phy(struct device *dev,
 	enum usb_phy_type type);
-extern struct usb_phy *usb_get_phy_dev(struct device *dev, u8 index);
-extern struct usb_phy *devm_usb_get_phy_dev(struct device *dev, u8 index);
 extern struct usb_phy *devm_usb_get_phy_by_phandle(struct device *dev,
 	const char *phandle, u8 index);
 extern struct usb_phy *devm_usb_get_phy_by_node(struct device *dev,
@@ -261,16 +243,6 @@ static inline struct usb_phy *devm_usb_get_phy(struct device *dev,
 	return ERR_PTR(-ENXIO);
 }
 
-static inline struct usb_phy *usb_get_phy_dev(struct device *dev, u8 index)
-{
-	return ERR_PTR(-ENXIO);
-}
-
-static inline struct usb_phy *devm_usb_get_phy_dev(struct device *dev, u8 index)
-{
-	return ERR_PTR(-ENXIO);
-}
-
 static inline struct usb_phy *devm_usb_get_phy_by_phandle(struct device *dev,
 	const char *phandle, u8 index)
 {

commit 60b9f942bc059913bcdac90d5b225f557438b5c5
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Apr 18 11:26:19 2018 +0200

    USB: phy: drop unused legacy controller-phy bind helper
    
    Drop the unused legacy usb_bind_phy() helper whose last user was removed
    in 2016 when OMAP moved to device-tree boot (9080b8dc761a ("ARM: OMAP2+:
    Remove legacy usb-host.c platform init code")).
    
    Note that this means that for the last couple of years the phy_bind_list
    has been empty (when using mainline kernels) and that consequently all
    phy lookups using the usb_get_phy_dev() interface have failed with
    -ENODEV. This helper along with its current users will be removed by
    follow-on patches.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index b7a2625947f5..ac5a079161e1 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -242,8 +242,6 @@ extern struct usb_phy *devm_usb_get_phy_by_node(struct device *dev,
 	struct device_node *node, struct notifier_block *nb);
 extern void usb_put_phy(struct usb_phy *);
 extern void devm_usb_put_phy(struct device *dev, struct usb_phy *x);
-extern int usb_bind_phy(const char *dev_name, u8 index,
-				const char *phy_dev_name);
 extern void usb_phy_set_event(struct usb_phy *x, unsigned long event);
 extern void usb_phy_set_charger_current(struct usb_phy *usb_phy,
 					unsigned int mA);
@@ -293,12 +291,6 @@ static inline void devm_usb_put_phy(struct device *dev, struct usb_phy *x)
 {
 }
 
-static inline int usb_bind_phy(const char *dev_name, u8 index,
-				const char *phy_dev_name)
-{
-	return -EOPNOTSUPP;
-}
-
 static inline void usb_phy_set_event(struct usb_phy *x, unsigned long event)
 {
 }

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index 8c6914873a16..b7a2625947f5 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * USB PHY defines
  *

commit eb3c74de28b24f5a36d12d6c84f1fceb25d12c4f
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Mon Aug 28 19:02:41 2017 +0800

    usb: phy: Avoid unchecked dereference warning
    
    Move the USB phy NULL checking before issuing usb_phy_set_charger_current()
    to avoid unchecked dereference warning.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index de881b171ba9..8c6914873a16 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -322,9 +322,12 @@ static inline void usb_phy_set_charger_state(struct usb_phy *usb_phy,
 static inline int
 usb_phy_set_power(struct usb_phy *x, unsigned mA)
 {
+	if (!x)
+		return 0;
+
 	usb_phy_set_charger_current(x, mA);
 
-	if (x && x->set_power)
+	if (x->set_power)
 		return x->set_power(x, mA);
 	return 0;
 }

commit a9081a008f84819ab2f3da596bf89afa16beea94
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Tue Aug 15 19:07:54 2017 +0800

    usb: phy: Add USB charger support
    
    This patch introduces the usb charger support based on usb phy that
    makes an enhancement to a power driver. The basic conception of the
    usb charger is that, when one usb charger is added or removed by
    reporting from the extcon device state change, the usb charger will
    report to power user to set the current limitation.
    
    Power user can register a notifiee on the usb phy by issuing
    usb_register_notifier() to get notified by charger status changes
    or charger current changes.
    
    we can notify what current to be drawn to power user according to
    different charger type, and now we have 2 methods to get charger type.
    One is get charger type from extcon subsystem, which also means the
    charger state changes. Another is we can get the charger type from
    USB controller detecting or PMIC detecting, and the charger state
    changes should be told by issuing usb_phy_set_charger_state().
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index 299245105610..de881b171ba9 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -12,6 +12,7 @@
 #include <linux/extcon.h>
 #include <linux/notifier.h>
 #include <linux/usb.h>
+#include <uapi/linux/usb/charger.h>
 
 enum usb_phy_interface {
 	USBPHY_INTERFACE_MODE_UNKNOWN,
@@ -72,6 +73,17 @@ struct usb_phy_io_ops {
 	int (*write)(struct usb_phy *x, u32 val, u32 reg);
 };
 
+struct usb_charger_current {
+	unsigned int sdp_min;
+	unsigned int sdp_max;
+	unsigned int dcp_min;
+	unsigned int dcp_max;
+	unsigned int cdp_min;
+	unsigned int cdp_max;
+	unsigned int aca_min;
+	unsigned int aca_max;
+};
+
 struct usb_phy {
 	struct device		*dev;
 	const char		*label;
@@ -91,6 +103,13 @@ struct usb_phy {
 	struct extcon_dev	*id_edev;
 	struct notifier_block	vbus_nb;
 	struct notifier_block	id_nb;
+	struct notifier_block	type_nb;
+
+	/* Support USB charger */
+	enum usb_charger_type	chg_type;
+	enum usb_charger_state	chg_state;
+	struct usb_charger_current	chg_cur;
+	struct work_struct		chg_work;
 
 	/* for notification of usb_phy_events */
 	struct atomic_notifier_head	notifier;
@@ -129,6 +148,12 @@ struct usb_phy {
 			enum usb_device_speed speed);
 	int	(*notify_disconnect)(struct usb_phy *x,
 			enum usb_device_speed speed);
+
+	/*
+	 * Charger detection method can be implemented if you need to
+	 * manually detect the charger type.
+	 */
+	enum usb_charger_type (*charger_detect)(struct usb_phy *x);
 };
 
 /**
@@ -219,6 +244,12 @@ extern void devm_usb_put_phy(struct device *dev, struct usb_phy *x);
 extern int usb_bind_phy(const char *dev_name, u8 index,
 				const char *phy_dev_name);
 extern void usb_phy_set_event(struct usb_phy *x, unsigned long event);
+extern void usb_phy_set_charger_current(struct usb_phy *usb_phy,
+					unsigned int mA);
+extern void usb_phy_get_charger_current(struct usb_phy *usb_phy,
+					unsigned int *min, unsigned int *max);
+extern void usb_phy_set_charger_state(struct usb_phy *usb_phy,
+				      enum usb_charger_state state);
 #else
 static inline struct usb_phy *usb_get_phy(enum usb_phy_type type)
 {
@@ -270,11 +301,29 @@ static inline int usb_bind_phy(const char *dev_name, u8 index,
 static inline void usb_phy_set_event(struct usb_phy *x, unsigned long event)
 {
 }
+
+static inline void usb_phy_set_charger_current(struct usb_phy *usb_phy,
+					       unsigned int mA)
+{
+}
+
+static inline void usb_phy_get_charger_current(struct usb_phy *usb_phy,
+					       unsigned int *min,
+					       unsigned int *max)
+{
+}
+
+static inline void usb_phy_set_charger_state(struct usb_phy *usb_phy,
+					     enum usb_charger_state state)
+{
+}
 #endif
 
 static inline int
 usb_phy_set_power(struct usb_phy *x, unsigned mA)
 {
+	usb_phy_set_charger_current(x, mA);
+
 	if (x && x->set_power)
 		return x->set_power(x, mA);
 	return 0;

commit 7d21114dc6a2d53babef43a84a8d8db2905d283d
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Fri May 5 14:12:24 2017 +0800

    usb: phy: Introduce one extcon device into usb phy
    
    Usually usb phy need register one extcon device to get the connection
    notifications. It will remove some duplicate code if the extcon device
    is registered using common code instead of each phy driver having its
    own related extcon APIs. So we add one pointer of extcon device into
    usb phy structure, and some other helper functions to register extcon.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index 31a8068c42a5..299245105610 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -9,6 +9,7 @@
 #ifndef __LINUX_USB_PHY_H
 #define __LINUX_USB_PHY_H
 
+#include <linux/extcon.h>
 #include <linux/notifier.h>
 #include <linux/usb.h>
 
@@ -85,6 +86,12 @@ struct usb_phy {
 	struct usb_phy_io_ops	*io_ops;
 	void __iomem		*io_priv;
 
+	/* to support extcon device */
+	struct extcon_dev	*edev;
+	struct extcon_dev	*id_edev;
+	struct notifier_block	vbus_nb;
+	struct notifier_block	id_nb;
+
 	/* for notification of usb_phy_events */
 	struct atomic_notifier_head	notifier;
 

commit 58efd4b06df4a421652cb2c8a850a9697a37915c
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Sep 22 15:31:34 2015 +0800

    usb: phy: change some comments
    
    - Replace all "transceiver" with "phy"
    - Replace one "OTG controller" with "phy"
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index e39f251cf861..31a8068c42a5 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -63,7 +63,7 @@ enum usb_otg_state {
 struct usb_phy;
 struct usb_otg;
 
-/* for transceivers connected thru an ULPI interface, the user must
+/* for phys connected thru an ULPI interface, the user must
  * provide access ops
  */
 struct usb_phy_io_ops {
@@ -92,10 +92,10 @@ struct usb_phy {
 	u16			port_status;
 	u16			port_change;
 
-	/* to support controllers that have multiple transceivers */
+	/* to support controllers that have multiple phys */
 	struct list_head	head;
 
-	/* initialize/shutdown the OTG controller */
+	/* initialize/shutdown the phy */
 	int	(*init)(struct usb_phy *x);
 	void	(*shutdown)(struct usb_phy *x);
 
@@ -106,7 +106,7 @@ struct usb_phy {
 	int	(*set_power)(struct usb_phy *x,
 				unsigned mA);
 
-	/* Set transceiver into suspend mode */
+	/* Set phy into suspend mode */
 	int	(*set_suspend)(struct usb_phy *x,
 				int suspend);
 

commit 307c858bc245da5229b30186546590e1d472fc8f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu May 28 16:08:02 2015 +0200

    usb: phy: add static inline wrapper for devm_usb_get_phy_by_node
    
    The newly introduced devm_usb_get_phy_by_node function only has
    an extern declaration, but no alternative for the case that
    CONFIG_USB_PHY is disabled, which leads to a build error when
    it is used anyway:
    
    drivers/power/twl4030_charger.c: In function 'twl4030_bci_probe':
    drivers/power/twl4030_charger.c:648:23: error: implicit declaration of function 'devm_usb_get_phy_by_node' [-Werror=implicit-function-declaration]
        bci->transceiver = devm_usb_get_phy_by_node(
    
    This adds the wrapper in the same way that we have one for
    all other usb-phy API functions.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Fixes: e842b84c8e7 ("usb: phy: Add interface to get phy give of device_node.")
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index 8ed1e29ef329..e39f251cf861 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -240,6 +240,12 @@ static inline struct usb_phy *devm_usb_get_phy_by_phandle(struct device *dev,
 	return ERR_PTR(-ENXIO);
 }
 
+static inline struct usb_phy *devm_usb_get_phy_by_node(struct device *dev,
+	struct device_node *node, struct notifier_block *nb)
+{
+	return ERR_PTR(-ENXIO);
+}
+
 static inline void usb_put_phy(struct usb_phy *x)
 {
 }

commit e842b84c8e7221c45c8dbd7de09185c6149e1cf9
Author: NeilBrown <neilb@suse.de>
Date:   Mon Mar 23 09:52:48 2015 +1100

    usb: phy: Add interface to get phy give of device_node.
    
    Split the "get phy from device_node" functionality out of
    "get phy by phandle" so it can be used directly.
    
    This is useful when a battery-charger is intimately associated with a
    particular phy but handled by a separate driver.  The charger
    can find the device_node based on sibling relationships
    without the need for a redundant declaration in the devicetree
    description.
    
    As a peripheral that gets a phy will often want to register a
    notifier block, and de-register it later, that functionality
    is included so the de-registration is automatic.
    
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index bc91b5d380fd..8ed1e29ef329 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -205,6 +205,8 @@ extern struct usb_phy *usb_get_phy_dev(struct device *dev, u8 index);
 extern struct usb_phy *devm_usb_get_phy_dev(struct device *dev, u8 index);
 extern struct usb_phy *devm_usb_get_phy_by_phandle(struct device *dev,
 	const char *phandle, u8 index);
+extern struct usb_phy *devm_usb_get_phy_by_node(struct device *dev,
+	struct device_node *node, struct notifier_block *nb);
 extern void usb_put_phy(struct usb_phy *);
 extern void devm_usb_put_phy(struct device *dev, struct usb_phy *x);
 extern int usb_bind_phy(const char *dev_name, u8 index,

commit 07673204777abe893092cc6e42ea04e5c0ac8cb7
Author: Peter Chen <peter.chen@freescale.com>
Date:   Tue Dec 30 14:02:28 2014 +0800

    usb: phy: change some comments
    
    - Delete the OTG stuffs
    - .set_suspend is for controller, not for A-device or B-device.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index f499c23e6342..bc91b5d380fd 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -1,5 +1,5 @@
-/* USB OTG (On The Go) defines */
 /*
+ * USB PHY defines
  *
  * These APIs may be used between USB controllers.  USB device drivers
  * (for either host or peripheral roles) don't use these calls; they
@@ -106,7 +106,7 @@ struct usb_phy {
 	int	(*set_power)(struct usb_phy *x,
 				unsigned mA);
 
-	/* for non-OTG B devices: set transceiver into suspend mode */
+	/* Set transceiver into suspend mode */
 	int	(*set_suspend)(struct usb_phy *x,
 				int suspend);
 

commit df9f7b311db1edae7ec5e2c78aa92fce7b9dd34d
Author: Kiran Raparthy <kiran.kumar@linaro.org>
Date:   Fri Nov 21 11:31:20 2014 +0530

    usb: phy: introduce usb_phy_set_event interface
    
    PHY drivers require a generic interface to handle per-PHY events.
    
    usb_phy_set_event interface sets event to phy event.
    PHY drivers call this interface for each phy event.
    
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-usb@vger.kernel.org
    Cc: Android Kernel Team <kernel-team@android.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Sumit Semwal <sumit.semwal@linaro.org>
    Cc: Arve Hj�nnev�g <arve@android.com>
    Cc: Benoit Goby <benoit@android.com>
    [Original patch in Android from Todd]
    Cc: Todd Poynor <toddpoynor@google.com>
    Signed-off-by: Kiran Raparthy <kiran.kumar@linaro.org>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index ac7d7913694f..f499c23e6342 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -209,6 +209,7 @@ extern void usb_put_phy(struct usb_phy *);
 extern void devm_usb_put_phy(struct device *dev, struct usb_phy *x);
 extern int usb_bind_phy(const char *dev_name, u8 index,
 				const char *phy_dev_name);
+extern void usb_phy_set_event(struct usb_phy *x, unsigned long event);
 #else
 static inline struct usb_phy *usb_get_phy(enum usb_phy_type type)
 {
@@ -250,6 +251,10 @@ static inline int usb_bind_phy(const char *dev_name, u8 index,
 {
 	return -EOPNOTSUPP;
 }
+
+static inline void usb_phy_set_event(struct usb_phy *x, unsigned long event)
+{
+}
 #endif
 
 static inline int

commit e47d92545c2972bcf3711e7db80f481e402163c7
Author: Antoine Tenart <antoine.tenart@free-electrons.com>
Date:   Thu Oct 30 18:41:13 2014 +0100

    usb: move the OTG state from the USB PHY to the OTG structure
    
    Before using the PHY framework instead of the USB PHY one, we need to
    move the OTG state into another place, since it won't be available when
    USB PHY isn't used. This patch moves the OTG state into the OTG
    structure, and makes all the needed modifications in the drivers
    using the OTG state.
    
    [ balbi@ti.com : fix build regressions with phy-tahvo.c, musb_dsps.c,
                    phy-isp1301-omap, and chipidea's debug.c ]
    
    Acked-by: Kishon Vijay Abraham I <kishon@ti.com>
    Acked-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index 353053a33f21..ac7d7913694f 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -77,7 +77,6 @@ struct usb_phy {
 	unsigned int		 flags;
 
 	enum usb_phy_type	type;
-	enum usb_otg_state	state;
 	enum usb_phy_events	last_event;
 
 	struct usb_otg		*otg;

commit 57bf9b09a6ad517b0c790b786845660ec5604774
Author: Peter Chen <peter.chen@freescale.com>
Date:   Mon Feb 24 10:21:01 2014 +0800

    usb: phy: Add set_wakeup API
    
    This API is used to set wakeup enable at PHY registers, in that
    case, the PHY can be waken up from suspend due to external events,
    like vbus change, dp/dm change and id change.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index 6c0b1c513db7..353053a33f21 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -111,6 +111,13 @@ struct usb_phy {
 	int	(*set_suspend)(struct usb_phy *x,
 				int suspend);
 
+	/*
+	 * Set wakeup enable for PHY, in that case, the PHY can be
+	 * woken up from suspend status due to external events,
+	 * like vbus change, dp/dm change and id.
+	 */
+	int	(*set_wakeup)(struct usb_phy *x, bool enabled);
+
 	/* notify phy connect status change */
 	int	(*notify_connect)(struct usb_phy *x,
 			enum usb_device_speed speed);
@@ -264,6 +271,15 @@ usb_phy_set_suspend(struct usb_phy *x, int suspend)
 		return 0;
 }
 
+static inline int
+usb_phy_set_wakeup(struct usb_phy *x, bool enabled)
+{
+	if (x && x->set_wakeup)
+		return x->set_wakeup(x, enabled);
+	else
+		return 0;
+}
+
 static inline int
 usb_phy_notify_connect(struct usb_phy *x, enum usb_device_speed speed)
 {

commit 410aee70f06da60dd8f78c3ec3346cc74c9bed46
Author: Felipe Balbi <balbi@ti.com>
Date:   Sun Jun 30 15:27:26 2013 +0300

    usb: phy: protect against NULL phy pointers
    
    In order to decrease the amount of work done
    by PHY users, allow NULL phy pointers to be
    passed.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index 44036808bf0f..6c0b1c513db7 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -142,7 +142,7 @@ extern void usb_remove_phy(struct usb_phy *);
 /* helpers for direct access thru low-level io interface */
 static inline int usb_phy_io_read(struct usb_phy *x, u32 reg)
 {
-	if (x->io_ops && x->io_ops->read)
+	if (x && x->io_ops && x->io_ops->read)
 		return x->io_ops->read(x, reg);
 
 	return -EINVAL;
@@ -150,7 +150,7 @@ static inline int usb_phy_io_read(struct usb_phy *x, u32 reg)
 
 static inline int usb_phy_io_write(struct usb_phy *x, u32 val, u32 reg)
 {
-	if (x->io_ops && x->io_ops->write)
+	if (x && x->io_ops && x->io_ops->write)
 		return x->io_ops->write(x, val, reg);
 
 	return -EINVAL;
@@ -159,7 +159,7 @@ static inline int usb_phy_io_write(struct usb_phy *x, u32 val, u32 reg)
 static inline int
 usb_phy_init(struct usb_phy *x)
 {
-	if (x->init)
+	if (x && x->init)
 		return x->init(x);
 
 	return 0;
@@ -168,14 +168,14 @@ usb_phy_init(struct usb_phy *x)
 static inline void
 usb_phy_shutdown(struct usb_phy *x)
 {
-	if (x->shutdown)
+	if (x && x->shutdown)
 		x->shutdown(x);
 }
 
 static inline int
 usb_phy_vbus_on(struct usb_phy *x)
 {
-	if (!x->set_vbus)
+	if (!x || !x->set_vbus)
 		return 0;
 
 	return x->set_vbus(x, true);
@@ -184,7 +184,7 @@ usb_phy_vbus_on(struct usb_phy *x)
 static inline int
 usb_phy_vbus_off(struct usb_phy *x)
 {
-	if (!x->set_vbus)
+	if (!x || !x->set_vbus)
 		return 0;
 
 	return x->set_vbus(x, false);
@@ -258,7 +258,7 @@ usb_phy_set_power(struct usb_phy *x, unsigned mA)
 static inline int
 usb_phy_set_suspend(struct usb_phy *x, int suspend)
 {
-	if (x->set_suspend != NULL)
+	if (x && x->set_suspend != NULL)
 		return x->set_suspend(x, suspend);
 	else
 		return 0;
@@ -267,7 +267,7 @@ usb_phy_set_suspend(struct usb_phy *x, int suspend)
 static inline int
 usb_phy_notify_connect(struct usb_phy *x, enum usb_device_speed speed)
 {
-	if (x->notify_connect)
+	if (x && x->notify_connect)
 		return x->notify_connect(x, speed);
 	else
 		return 0;
@@ -276,7 +276,7 @@ usb_phy_notify_connect(struct usb_phy *x, enum usb_device_speed speed)
 static inline int
 usb_phy_notify_disconnect(struct usb_phy *x, enum usb_device_speed speed)
 {
-	if (x->notify_disconnect)
+	if (x && x->notify_disconnect)
 		return x->notify_disconnect(x, speed);
 	else
 		return 0;

commit 1c9af65357a309b60d78a442bd61d27cad458d00
Author: Michael Grzeschik <m.grzeschik@pengutronix.de>
Date:   Thu Jun 13 17:59:55 2013 +0300

    usb: add devicetree helpers for determining dr_mode and phy_type
    
    This adds two little devicetree helper functions for determining the
    dr_mode (host, peripheral, otg) and phy_type (utmi, ulpi,...) from
    the devicetree.
    
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index 6b5978f57633..44036808bf0f 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -12,6 +12,15 @@
 #include <linux/notifier.h>
 #include <linux/usb.h>
 
+enum usb_phy_interface {
+	USBPHY_INTERFACE_MODE_UNKNOWN,
+	USBPHY_INTERFACE_MODE_UTMI,
+	USBPHY_INTERFACE_MODE_UTMIW,
+	USBPHY_INTERFACE_MODE_ULPI,
+	USBPHY_INTERFACE_MODE_SERIAL,
+	USBPHY_INTERFACE_MODE_HSIC,
+};
+
 enum usb_phy_events {
 	USB_EVENT_NONE,         /* no events or cable disconnected */
 	USB_EVENT_VBUS,         /* vbus valid event */

commit b7fa5c2aec5be083eb2719b405089703608e9bc6
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Mar 14 17:59:06 2013 +0200

    usb: phy: return -ENXIO when PHY layer isn't enabled
    
    in cases where PHY layer isn't enabled, we want
    to still return an error code (actually an error
    pointer) so that our users don't need to cope with
    either error pointer of NULL.
    
    This will simplify users as below:
    
    -       return IS_ERR(phy) ? PTR_ERR(phy) : -ENODEV;
    +       return PTR_ERR(phy);
    
    Acked-by: Kishon Vijay Abraham I <kishon@ti.com>
    Reported-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index b7c2217c585f..6b5978f57633 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -197,29 +197,29 @@ extern int usb_bind_phy(const char *dev_name, u8 index,
 #else
 static inline struct usb_phy *usb_get_phy(enum usb_phy_type type)
 {
-	return NULL;
+	return ERR_PTR(-ENXIO);
 }
 
 static inline struct usb_phy *devm_usb_get_phy(struct device *dev,
 	enum usb_phy_type type)
 {
-	return NULL;
+	return ERR_PTR(-ENXIO);
 }
 
 static inline struct usb_phy *usb_get_phy_dev(struct device *dev, u8 index)
 {
-	return NULL;
+	return ERR_PTR(-ENXIO);
 }
 
 static inline struct usb_phy *devm_usb_get_phy_dev(struct device *dev, u8 index)
 {
-	return NULL;
+	return ERR_PTR(-ENXIO);
 }
 
 static inline struct usb_phy *devm_usb_get_phy_by_phandle(struct device *dev,
 	const char *phandle, u8 index)
 {
-	return NULL;
+	return ERR_PTR(-ENXIO);
 }
 
 static inline void usb_put_phy(struct usb_phy *x)

commit b774212ea5f13911a5e0211a7088e42dad46b4c8
Author: Felipe Balbi <balbi@ti.com>
Date:   Fri Mar 8 13:22:58 2013 +0200

    usb: phy: introduce ->set_vbus() method
    
    this method will be used to enable or disable
    the charge pump.
    
    Whenever we have DRD devices, we need to be
    able to turn VBUS on or off whenever we want.
    
    Note that in the ideal case, this would be
    controlled by the ID-pin Interrupt, but not
    all devices have ID-pin properly routed since
    manufacturers can choose to save that trace
    if they're building a host-only product out
    of a DRD IP.
    
    This is also useful during debugging where
    we might not have the proper cable hanging
    around.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index b001dc3d6354..b7c2217c585f 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -91,6 +91,9 @@ struct usb_phy {
 	int	(*init)(struct usb_phy *x);
 	void	(*shutdown)(struct usb_phy *x);
 
+	/* enable/disable VBUS */
+	int	(*set_vbus)(struct usb_phy *x, int on);
+
 	/* effective for B devices, ignored for A-peripheral */
 	int	(*set_power)(struct usb_phy *x,
 				unsigned mA);
@@ -160,6 +163,24 @@ usb_phy_shutdown(struct usb_phy *x)
 		x->shutdown(x);
 }
 
+static inline int
+usb_phy_vbus_on(struct usb_phy *x)
+{
+	if (!x->set_vbus)
+		return 0;
+
+	return x->set_vbus(x, true);
+}
+
+static inline int
+usb_phy_vbus_off(struct usb_phy *x)
+{
+	if (!x->set_vbus)
+		return 0;
+
+	return x->set_vbus(x, false);
+}
+
 /* for usb host and peripheral controller drivers */
 #if IS_ENABLED(CONFIG_USB_PHY)
 extern struct usb_phy *usb_get_phy(enum usb_phy_type type);

commit edc7cb2e955f222fe51cd44c1cf9c94d58017344
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Mar 7 11:13:43 2013 +0200

    usb: phy: make it a menuconfig
    
    We already have a considerable amount of USB
    PHY drivers, making it a menuconfig just
    prevents us from adding too much churn to
    USB's menuconfig.
    
    While at that, also select USB_OTG_UTILS from
    this new menuconfig just to keep backwards
    compatibility until we manage to remove
    that symbol.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index 15847cbdb512..b001dc3d6354 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -161,7 +161,7 @@ usb_phy_shutdown(struct usb_phy *x)
 }
 
 /* for usb host and peripheral controller drivers */
-#ifdef CONFIG_USB_OTG_UTILS
+#if IS_ENABLED(CONFIG_USB_PHY)
 extern struct usb_phy *usb_get_phy(enum usb_phy_type type);
 extern struct usb_phy *devm_usb_get_phy(struct device *dev,
 	enum usb_phy_type type);

commit 5d3c28b5a42df5ceaa854901ba2cccb76883c77e
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Fri Jan 25 08:03:25 2013 +0530

    usb: otg: add device tree support to otg library
    
    Added an API devm_usb_get_phy_by_phandle(), to get usb phy by passing a
    device node phandle value. This function will return a pointer to
    the phy on success, -EPROBE_DEFER if there is a device_node for the phandle,
    but the phy has not been added, or a ERR_PTR() otherwise.
    
    Cc: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index 359db7de61e4..15847cbdb512 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -167,6 +167,8 @@ extern struct usb_phy *devm_usb_get_phy(struct device *dev,
 	enum usb_phy_type type);
 extern struct usb_phy *usb_get_phy_dev(struct device *dev, u8 index);
 extern struct usb_phy *devm_usb_get_phy_dev(struct device *dev, u8 index);
+extern struct usb_phy *devm_usb_get_phy_by_phandle(struct device *dev,
+	const char *phandle, u8 index);
 extern void usb_put_phy(struct usb_phy *);
 extern void devm_usb_put_phy(struct device *dev, struct usb_phy *x);
 extern int usb_bind_phy(const char *dev_name, u8 index,
@@ -193,6 +195,12 @@ static inline struct usb_phy *devm_usb_get_phy_dev(struct device *dev, u8 index)
 	return NULL;
 }
 
+static inline struct usb_phy *devm_usb_get_phy_by_phandle(struct device *dev,
+	const char *phandle, u8 index)
+{
+	return NULL;
+}
+
 static inline void usb_put_phy(struct usb_phy *x)
 {
 }

commit 0fa4fab4ee46470ccd463c83be95434936942e05
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Fri Jan 25 08:03:22 2013 +0530

    usb: otg: utils: add facilities in phy lib to support multiple PHYs of same type
    
    In order to add support for multipe PHY's of the same type, new API's
    for adding PHY and getting PHY has been added. Now the binding
    information for the PHY and controller should be done in platform file
    using usb_bind_phy API. And for getting a PHY, the device pointer of the
    USB controller and an index should be passed. Based on the binding
    information that is added in the platform file, usb_get_phy_dev will return the
    appropriate PHY.
    Already existing API's to add and get phy by type is not removed. These
    API's are deprecated and will be removed once all the platforms start to
    use the new API.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index a812ed5a1691..359db7de61e4 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -124,6 +124,7 @@ struct usb_phy_bind {
 
 /* for board-specific init logic */
 extern int usb_add_phy(struct usb_phy *, enum usb_phy_type type);
+extern int usb_add_phy_dev(struct usb_phy *);
 extern void usb_remove_phy(struct usb_phy *);
 
 /* helpers for direct access thru low-level io interface */
@@ -164,6 +165,8 @@ usb_phy_shutdown(struct usb_phy *x)
 extern struct usb_phy *usb_get_phy(enum usb_phy_type type);
 extern struct usb_phy *devm_usb_get_phy(struct device *dev,
 	enum usb_phy_type type);
+extern struct usb_phy *usb_get_phy_dev(struct device *dev, u8 index);
+extern struct usb_phy *devm_usb_get_phy_dev(struct device *dev, u8 index);
 extern void usb_put_phy(struct usb_phy *);
 extern void devm_usb_put_phy(struct device *dev, struct usb_phy *x);
 extern int usb_bind_phy(const char *dev_name, u8 index,
@@ -180,6 +183,16 @@ static inline struct usb_phy *devm_usb_get_phy(struct device *dev,
 	return NULL;
 }
 
+static inline struct usb_phy *usb_get_phy_dev(struct device *dev, u8 index)
+{
+	return NULL;
+}
+
+static inline struct usb_phy *devm_usb_get_phy_dev(struct device *dev, u8 index)
+{
+	return NULL;
+}
+
 static inline void usb_put_phy(struct usb_phy *x)
 {
 }

commit b4a83e4df1bc864e89d3bb90e97f9caab656545d
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Fri Jan 25 08:03:21 2013 +0530

    usb: otg: add an api to bind the usb controller and phy
    
    In order to support platforms which has multiple PHY's (of same type) and
    which has multiple USB controllers, a new design is adopted wherin the binding
    information (between the PHY and the USB controller) should be passed to the
    PHY library from platform specific file (board file).
    So added a new API to pass the binding information.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index a29ae1eb9346..a812ed5a1691 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -106,6 +106,21 @@ struct usb_phy {
 			enum usb_device_speed speed);
 };
 
+/**
+ * struct usb_phy_bind - represent the binding for the phy
+ * @dev_name: the device name of the device that will bind to the phy
+ * @phy_dev_name: the device name of the phy
+ * @index: used if a single controller uses multiple phys
+ * @phy: reference to the phy
+ * @list: to maintain a linked list of the binding information
+ */
+struct usb_phy_bind {
+	const char	*dev_name;
+	const char	*phy_dev_name;
+	u8		index;
+	struct usb_phy	*phy;
+	struct list_head list;
+};
 
 /* for board-specific init logic */
 extern int usb_add_phy(struct usb_phy *, enum usb_phy_type type);
@@ -151,6 +166,8 @@ extern struct usb_phy *devm_usb_get_phy(struct device *dev,
 	enum usb_phy_type type);
 extern void usb_put_phy(struct usb_phy *);
 extern void devm_usb_put_phy(struct device *dev, struct usb_phy *x);
+extern int usb_bind_phy(const char *dev_name, u8 index,
+				const char *phy_dev_name);
 #else
 static inline struct usb_phy *usb_get_phy(enum usb_phy_type type)
 {
@@ -171,6 +188,11 @@ static inline void devm_usb_put_phy(struct device *dev, struct usb_phy *x)
 {
 }
 
+static inline int usb_bind_phy(const char *dev_name, u8 index,
+				const char *phy_dev_name)
+{
+	return -EOPNOTSUPP;
+}
 #endif
 
 static inline int

commit ac96511bb5cf92bad97ffc2249f75e45eb70301d
Author: Peter Chen <peter.chen@freescale.com>
Date:   Fri Nov 9 09:44:44 2012 +0800

    usb: phy: change phy notify connect/disconnect API
    
    The old parameter "port" is useless for phy notify, as one usb
    phy is only for one usb port. New parameter "speed" stands for
    the device's speed which is on the port, this "speed" parameter
    is needed at some platforms which will do some phy operations
    according to device's speed.
    
    Signed-off-by: Peter Chen <peter.chen@freescale.com>
    Tested-by: Mike Thompson <mpthompson@gmail.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index 06b5bae35b29..a29ae1eb9346 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -10,6 +10,7 @@
 #define __LINUX_USB_PHY_H
 
 #include <linux/notifier.h>
+#include <linux/usb.h>
 
 enum usb_phy_events {
 	USB_EVENT_NONE,         /* no events or cable disconnected */
@@ -99,8 +100,10 @@ struct usb_phy {
 				int suspend);
 
 	/* notify phy connect status change */
-	int	(*notify_connect)(struct usb_phy *x, int port);
-	int	(*notify_disconnect)(struct usb_phy *x, int port);
+	int	(*notify_connect)(struct usb_phy *x,
+			enum usb_device_speed speed);
+	int	(*notify_disconnect)(struct usb_phy *x,
+			enum usb_device_speed speed);
 };
 
 
@@ -189,19 +192,19 @@ usb_phy_set_suspend(struct usb_phy *x, int suspend)
 }
 
 static inline int
-usb_phy_notify_connect(struct usb_phy *x, int port)
+usb_phy_notify_connect(struct usb_phy *x, enum usb_device_speed speed)
 {
 	if (x->notify_connect)
-		return x->notify_connect(x, port);
+		return x->notify_connect(x, speed);
 	else
 		return 0;
 }
 
 static inline int
-usb_phy_notify_disconnect(struct usb_phy *x, int port)
+usb_phy_notify_disconnect(struct usb_phy *x, enum usb_device_speed speed)
 {
 	if (x->notify_disconnect)
-		return x->notify_disconnect(x, port);
+		return x->notify_disconnect(x, speed);
 	else
 		return 0;
 }

commit a4c3ddec5c5293953d8472eb151c48a3205b738b
Author: Venu Byravarasu <vbyravarasu@nvidia.com>
Date:   Thu Sep 6 10:42:15 2012 +0530

    usb: phy: fix build break
    
    During phy interface separation from otg.h, as the enum "usb_otg_state"
    was having multiple otg states info and removal of member 'state'
    of this enum type from usb_phy struct did not generate any compilation
    issues, I removed member state from struct usb_phy.
    
    As this is causing build break in musb code, adding member 'state'
    to usb_phy structure.
    
    Signed-off-by: Venu Byravarasu <vbyravarasu@nvidia.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index 88fc16062e77..06b5bae35b29 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -26,6 +26,30 @@ enum usb_phy_type {
 	USB_PHY_TYPE_USB3,
 };
 
+/* OTG defines lots of enumeration states before device reset */
+enum usb_otg_state {
+	OTG_STATE_UNDEFINED = 0,
+
+	/* single-role peripheral, and dual-role default-b */
+	OTG_STATE_B_IDLE,
+	OTG_STATE_B_SRP_INIT,
+	OTG_STATE_B_PERIPHERAL,
+
+	/* extra dual-role default-b states */
+	OTG_STATE_B_WAIT_ACON,
+	OTG_STATE_B_HOST,
+
+	/* dual-role default-a */
+	OTG_STATE_A_IDLE,
+	OTG_STATE_A_WAIT_VRISE,
+	OTG_STATE_A_WAIT_BCON,
+	OTG_STATE_A_HOST,
+	OTG_STATE_A_SUSPEND,
+	OTG_STATE_A_PERIPHERAL,
+	OTG_STATE_A_WAIT_VFALL,
+	OTG_STATE_A_VBUS_ERR,
+};
+
 struct usb_phy;
 struct usb_otg;
 
@@ -43,6 +67,7 @@ struct usb_phy {
 	unsigned int		 flags;
 
 	enum usb_phy_type	type;
+	enum usb_otg_state	state;
 	enum usb_phy_events	last_event;
 
 	struct usb_otg		*otg;

commit de4217d90fed1b1714a270ceb5d092f7314e8bda
Author: Venu Byravarasu <vbyravarasu@nvidia.com>
Date:   Tue Sep 4 14:25:58 2012 +0530

    usb: otg: Move phy interface to separate file.
    
    As otg.h is containing lots of phy interface related
    stuff, moving all phy interface related stuff to new
    file named phy.h
    
    Signed-off-by: Venu Byravarasu <vbyravarasu@nvidia.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
new file mode 100644
index 000000000000..88fc16062e77
--- /dev/null
+++ b/include/linux/usb/phy.h
@@ -0,0 +1,208 @@
+/* USB OTG (On The Go) defines */
+/*
+ *
+ * These APIs may be used between USB controllers.  USB device drivers
+ * (for either host or peripheral roles) don't use these calls; they
+ * continue to use just usb_device and usb_gadget.
+ */
+
+#ifndef __LINUX_USB_PHY_H
+#define __LINUX_USB_PHY_H
+
+#include <linux/notifier.h>
+
+enum usb_phy_events {
+	USB_EVENT_NONE,         /* no events or cable disconnected */
+	USB_EVENT_VBUS,         /* vbus valid event */
+	USB_EVENT_ID,           /* id was grounded */
+	USB_EVENT_CHARGER,      /* usb dedicated charger */
+	USB_EVENT_ENUMERATED,   /* gadget driver enumerated */
+};
+
+/* associate a type with PHY */
+enum usb_phy_type {
+	USB_PHY_TYPE_UNDEFINED,
+	USB_PHY_TYPE_USB2,
+	USB_PHY_TYPE_USB3,
+};
+
+struct usb_phy;
+struct usb_otg;
+
+/* for transceivers connected thru an ULPI interface, the user must
+ * provide access ops
+ */
+struct usb_phy_io_ops {
+	int (*read)(struct usb_phy *x, u32 reg);
+	int (*write)(struct usb_phy *x, u32 val, u32 reg);
+};
+
+struct usb_phy {
+	struct device		*dev;
+	const char		*label;
+	unsigned int		 flags;
+
+	enum usb_phy_type	type;
+	enum usb_phy_events	last_event;
+
+	struct usb_otg		*otg;
+
+	struct device		*io_dev;
+	struct usb_phy_io_ops	*io_ops;
+	void __iomem		*io_priv;
+
+	/* for notification of usb_phy_events */
+	struct atomic_notifier_head	notifier;
+
+	/* to pass extra port status to the root hub */
+	u16			port_status;
+	u16			port_change;
+
+	/* to support controllers that have multiple transceivers */
+	struct list_head	head;
+
+	/* initialize/shutdown the OTG controller */
+	int	(*init)(struct usb_phy *x);
+	void	(*shutdown)(struct usb_phy *x);
+
+	/* effective for B devices, ignored for A-peripheral */
+	int	(*set_power)(struct usb_phy *x,
+				unsigned mA);
+
+	/* for non-OTG B devices: set transceiver into suspend mode */
+	int	(*set_suspend)(struct usb_phy *x,
+				int suspend);
+
+	/* notify phy connect status change */
+	int	(*notify_connect)(struct usb_phy *x, int port);
+	int	(*notify_disconnect)(struct usb_phy *x, int port);
+};
+
+
+/* for board-specific init logic */
+extern int usb_add_phy(struct usb_phy *, enum usb_phy_type type);
+extern void usb_remove_phy(struct usb_phy *);
+
+/* helpers for direct access thru low-level io interface */
+static inline int usb_phy_io_read(struct usb_phy *x, u32 reg)
+{
+	if (x->io_ops && x->io_ops->read)
+		return x->io_ops->read(x, reg);
+
+	return -EINVAL;
+}
+
+static inline int usb_phy_io_write(struct usb_phy *x, u32 val, u32 reg)
+{
+	if (x->io_ops && x->io_ops->write)
+		return x->io_ops->write(x, val, reg);
+
+	return -EINVAL;
+}
+
+static inline int
+usb_phy_init(struct usb_phy *x)
+{
+	if (x->init)
+		return x->init(x);
+
+	return 0;
+}
+
+static inline void
+usb_phy_shutdown(struct usb_phy *x)
+{
+	if (x->shutdown)
+		x->shutdown(x);
+}
+
+/* for usb host and peripheral controller drivers */
+#ifdef CONFIG_USB_OTG_UTILS
+extern struct usb_phy *usb_get_phy(enum usb_phy_type type);
+extern struct usb_phy *devm_usb_get_phy(struct device *dev,
+	enum usb_phy_type type);
+extern void usb_put_phy(struct usb_phy *);
+extern void devm_usb_put_phy(struct device *dev, struct usb_phy *x);
+#else
+static inline struct usb_phy *usb_get_phy(enum usb_phy_type type)
+{
+	return NULL;
+}
+
+static inline struct usb_phy *devm_usb_get_phy(struct device *dev,
+	enum usb_phy_type type)
+{
+	return NULL;
+}
+
+static inline void usb_put_phy(struct usb_phy *x)
+{
+}
+
+static inline void devm_usb_put_phy(struct device *dev, struct usb_phy *x)
+{
+}
+
+#endif
+
+static inline int
+usb_phy_set_power(struct usb_phy *x, unsigned mA)
+{
+	if (x && x->set_power)
+		return x->set_power(x, mA);
+	return 0;
+}
+
+/* Context: can sleep */
+static inline int
+usb_phy_set_suspend(struct usb_phy *x, int suspend)
+{
+	if (x->set_suspend != NULL)
+		return x->set_suspend(x, suspend);
+	else
+		return 0;
+}
+
+static inline int
+usb_phy_notify_connect(struct usb_phy *x, int port)
+{
+	if (x->notify_connect)
+		return x->notify_connect(x, port);
+	else
+		return 0;
+}
+
+static inline int
+usb_phy_notify_disconnect(struct usb_phy *x, int port)
+{
+	if (x->notify_disconnect)
+		return x->notify_disconnect(x, port);
+	else
+		return 0;
+}
+
+/* notifiers */
+static inline int
+usb_register_notifier(struct usb_phy *x, struct notifier_block *nb)
+{
+	return atomic_notifier_chain_register(&x->notifier, nb);
+}
+
+static inline void
+usb_unregister_notifier(struct usb_phy *x, struct notifier_block *nb)
+{
+	atomic_notifier_chain_unregister(&x->notifier, nb);
+}
+
+static inline const char *usb_phy_type_string(enum usb_phy_type type)
+{
+	switch (type) {
+	case USB_PHY_TYPE_USB2:
+		return "USB2 PHY";
+	case USB_PHY_TYPE_USB3:
+		return "USB3 PHY";
+	default:
+		return "UNKNOWN PHY TYPE";
+	}
+}
+#endif /* __LINUX_USB_PHY_H */
