commit e311edbc45de6163a278fd5a8be0dabe2efd9b9b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 3 07:45:00 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 244
    
    Based on 1 normalized pattern(s):
    
      this file is rleased under the gpl v2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 1 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190602204654.725819457@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/klist.h b/include/linux/klist.h
index 953f283f8451..b0f238f20dbb 100644
--- a/include/linux/klist.h
+++ b/include/linux/klist.h
@@ -1,12 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  *	klist.h - Some generic list helpers, extending struct list_head a bit.
  *
  *	Implementations are found in lib/klist.c
  *
- *
  *	Copyright (C) 2005 Patrick Mochel
- *
- *	This file is rleased under the GPL v2.
  */
 
 #ifndef _LINUX_KLIST_H

commit 2e0fed7f7cdc41679e209c5636ad7537dc6210a9
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jul 27 18:03:59 2015 +0300

    klist: implement klist_prev()
    
    klist_prev() gets the previous element in the list. It is useful to traverse
    through the list in reverse order, for example, to provide LIFO (last in first
    out) variant of access.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/include/linux/klist.h b/include/linux/klist.h
index 61e5b723ae73..953f283f8451 100644
--- a/include/linux/klist.h
+++ b/include/linux/klist.h
@@ -63,6 +63,7 @@ extern void klist_iter_init(struct klist *k, struct klist_iter *i);
 extern void klist_iter_init_node(struct klist *k, struct klist_iter *i,
 				 struct klist_node *n);
 extern void klist_iter_exit(struct klist_iter *i);
+extern struct klist_node *klist_prev(struct klist_iter *i);
 extern struct klist_node *klist_next(struct klist_iter *i);
 
 #endif

commit 0f9859ca92c9182bcb8f18c55cae1a04627cbb59
Author: Ken Helias <kenhelias@firemail.de>
Date:   Wed Aug 6 16:09:18 2014 -0700

    klist: use same naming scheme as hlist for klist_add_after()
    
    The name was modified from hlist_add_after() to hlist_add_behind() when
    adjusting the order of arguments to match the one with
    klist_add_after().  This is necessary to break old code when it would
    use it the wrong way.
    
    Make klist follow this naming scheme for consistency.
    
    Signed-off-by: Ken Helias <kenhelias@firemail.de>
    Cc: "Paul E. McKenney" <paulmck@linux.vnet.ibm.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/klist.h b/include/linux/klist.h
index a370ce57cf1d..61e5b723ae73 100644
--- a/include/linux/klist.h
+++ b/include/linux/klist.h
@@ -44,7 +44,7 @@ struct klist_node {
 
 extern void klist_add_tail(struct klist_node *n, struct klist *k);
 extern void klist_add_head(struct klist_node *n, struct klist *k);
-extern void klist_add_after(struct klist_node *n, struct klist_node *pos);
+extern void klist_add_behind(struct klist_node *n, struct klist_node *pos);
 extern void klist_add_before(struct klist_node *n, struct klist_node *pos);
 
 extern void klist_del(struct klist_node *n);

commit 795abaf1e4e188c4171e3cd3dbb11a9fcacaf505
Author: David Miller <davem@davemloft.net>
Date:   Sun Feb 13 16:37:07 2011 -0800

    klist: Fix object alignment on 64-bit.
    
    Commit c0e69a5bbc6f ("klist.c: bit 0 in pointer can't be used as flag")
    intended to make sure that all klist objects were at least pointer size
    aligned, but used the constant "4" which only works on 32-bit.
    
    Use "sizeof(void *)" which is correct in all cases.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Acked-by: Jesper Nilsson <jesper.nilsson@axis.com>
    Cc: stable <stable@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/klist.h b/include/linux/klist.h
index e91a4e59b771..a370ce57cf1d 100644
--- a/include/linux/klist.h
+++ b/include/linux/klist.h
@@ -22,7 +22,7 @@ struct klist {
 	struct list_head	k_list;
 	void			(*get)(struct klist_node *);
 	void			(*put)(struct klist_node *);
-} __attribute__ ((aligned (4)));
+} __attribute__ ((aligned (sizeof(void *))));
 
 #define KLIST_INIT(_name, _get, _put)					\
 	{ .k_lock	= __SPIN_LOCK_UNLOCKED(_name.k_lock),		\

commit c0e69a5bbc6fc74184aa043aadb9a53bc58f953b
Author: Jesper Nilsson <Jesper.Nilsson@axis.com>
Date:   Wed Jan 14 11:19:08 2009 +0100

    klist.c: bit 0 in pointer can't be used as flag
    
    The commit a1ed5b0cffe4b16a93a6a3390e8cee0fbef94f86
    (klist: don't iterate over deleted entries) introduces use of the
    low bit in a pointer to indicate if the knode is dead or not,
    assuming that this bit is always free.
    
    This is not true for all architectures, CRIS for example may align data
    on byte borders.
    
    The result is a bunch of warnings on bootup, devices not being
    added correctly etc, reported by Hinko Kocevar <hinko.kocevar@cetrtapot.si>:
    
    ------------[ cut here ]------------
    WARNING: at lib/klist.c:62 ()
    Modules linked in:
    
    Stack from c1fe1cf0:
           c01cc7f4 c1fe1d11 c000eb4e c000e4de 00000000 00000000 c1f4f78f c1f50c2d
           c01d008c c1fdd1a0 c1fdd1a0 c1fe1d38 c0192954 c1fe0000 00000000 c1fe1dc0
           00000002 7fffffff c1fe1da8 c0192d50 c1fe1dc0 00000002 7fffffff c1ff9fcc
    Call Trace: [<c000eb4e>] [<c000e4de>] [<c0192954>] [<c0192d50>] [<c001d49e>] [<c000b688>] [<c0192a3c>]
           [<c000b63e>] [<c000b63e>] [<c001a542>] [<c00b55b0>] [<c00411c0>] [<c00b559c>] [<c01918e6>] [<c0191988>]
           [<c01919d0>] [<c00cd9c8>] [<c00cdd6a>] [<c0034178>] [<c000409a>] [<c0015576>] [<c0029130>] [<c0029078>]
           [<c0029170>] [<c0012336>] [<c00b4076>] [<c00b4770>] [<c006d6e4>] [<c006d974>] [<c006dca0>] [<c0028d6c>]
           [<c0028e12>] [<c0006424>] <4>---[ end trace 4eaa2a86a8e2da22 ]---
    ------------[ cut here ]------------
    Repeat ad nauseam.
    
    Wed, Jan 14, 2009 at 12:11:32AM +0100, Bastien ROUCARIES wrote:
    > Perhaps using a pointerhackalign trick on this structure where
    > #define pointerhackalign(x) __attribute__ ((aligned (x)))
    > and declare
    > struct klist_node {
    > ...
    > }  pointerhackalign(2);
    >
    > Because  __attribute__ ((aligned (x))) could only increase alignment
    > it will safe to do that and serve as documentation purpose :)
    
    That works, but we need to do it not for the struct klist_node,
    but for the struct we insert into the void * in klist_node,
    which is struct klist.
    
    Reported-by: Hinko Kocevar <hinko.kocevar@cetrtapot.si
    Cc: Bastien ROUCARIES <roucaries.bastien@gmail.com>
    Signed-off-by: Jesper Nilsson <jesper.nilsson@axis.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/klist.h b/include/linux/klist.h
index d5a27af9dba5..e91a4e59b771 100644
--- a/include/linux/klist.h
+++ b/include/linux/klist.h
@@ -22,7 +22,7 @@ struct klist {
 	struct list_head	k_list;
 	void			(*get)(struct klist_node *);
 	void			(*put)(struct klist_node *);
-};
+} __attribute__ ((aligned (4)));
 
 #define KLIST_INIT(_name, _get, _put)					\
 	{ .k_lock	= __SPIN_LOCK_UNLOCKED(_name.k_lock),		\

commit 210272a28465a7a31bcd580d2f9529f924965aa5
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Thu Oct 16 14:57:54 2008 -0600

    driver core: Remove completion from struct klist_node
    
    Removing the completion from klist_node reduces its size from 64 bytes
    to 28 on x86-64.  To maintain the semantics of klist_remove(), we add
    a single list of klist nodes which are pending deletion and scan them.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/klist.h b/include/linux/klist.h
index 8ea98db223e5..d5a27af9dba5 100644
--- a/include/linux/klist.h
+++ b/include/linux/klist.h
@@ -13,7 +13,6 @@
 #define _LINUX_KLIST_H
 
 #include <linux/spinlock.h>
-#include <linux/completion.h>
 #include <linux/kref.h>
 #include <linux/list.h>
 
@@ -41,7 +40,6 @@ struct klist_node {
 	void			*n_klist;	/* never access directly */
 	struct list_head	n_node;
 	struct kref		n_ref;
-	struct completion	n_removed;
 };
 
 extern void klist_add_tail(struct klist_node *n, struct klist *k);

commit a1ed5b0cffe4b16a93a6a3390e8cee0fbef94f86
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Aug 25 19:50:16 2008 +0200

    klist: don't iterate over deleted entries
    
    A klist entry is kept on the list till all its current iterations are
    finished; however, a new iteration after deletion also iterates over
    deleted entries as long as their reference count stays above zero.
    This causes problems for cases where there are users which iterate
    over the list while synchronized against list manipulations and
    natuarally expect already deleted entries to not show up during
    iteration.
    
    This patch implements dead flag which gets set on deletion so that
    iteration can skip already deleted entries.  The dead flag piggy backs
    on the lowest bit of knode->n_klist and only visible to klist
    implementation proper.
    
    While at it, drop klist_iter->i_head as it's redundant and doesn't
    offer anything in semantics or performance wise as klist_iter->i_klist
    is dereferenced on every iteration anyway.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/klist.h b/include/linux/klist.h
index 06c338ef7f1b..8ea98db223e5 100644
--- a/include/linux/klist.h
+++ b/include/linux/klist.h
@@ -38,7 +38,7 @@ extern void klist_init(struct klist *k, void (*get)(struct klist_node *),
 		       void (*put)(struct klist_node *));
 
 struct klist_node {
-	struct klist		*n_klist;
+	void			*n_klist;	/* never access directly */
 	struct list_head	n_node;
 	struct kref		n_ref;
 	struct completion	n_removed;
@@ -57,7 +57,6 @@ extern int klist_node_attached(struct klist_node *n);
 
 struct klist_iter {
 	struct klist		*i_klist;
-	struct list_head	*i_head;
 	struct klist_node	*i_cur;
 };
 

commit c3bb7fadaf52de3637b834002dac27f6250b4b49
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Apr 30 16:43:45 2008 -0700

    klist: fix coding style errors in klist.h and klist.c
    
    Finally clean up the odd spacing in these files.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/klist.h b/include/linux/klist.h
index b49385f13419..06c338ef7f1b 100644
--- a/include/linux/klist.h
+++ b/include/linux/klist.h
@@ -34,38 +34,38 @@ struct klist {
 #define DEFINE_KLIST(_name, _get, _put)					\
 	struct klist _name = KLIST_INIT(_name, _get, _put)
 
-extern void klist_init(struct klist * k, void (*get)(struct klist_node *),
+extern void klist_init(struct klist *k, void (*get)(struct klist_node *),
 		       void (*put)(struct klist_node *));
 
 struct klist_node {
-	struct klist		* n_klist;
+	struct klist		*n_klist;
 	struct list_head	n_node;
 	struct kref		n_ref;
 	struct completion	n_removed;
 };
 
-extern void klist_add_tail(struct klist_node * n, struct klist * k);
-extern void klist_add_head(struct klist_node * n, struct klist * k);
+extern void klist_add_tail(struct klist_node *n, struct klist *k);
+extern void klist_add_head(struct klist_node *n, struct klist *k);
 extern void klist_add_after(struct klist_node *n, struct klist_node *pos);
 extern void klist_add_before(struct klist_node *n, struct klist_node *pos);
 
-extern void klist_del(struct klist_node * n);
-extern void klist_remove(struct klist_node * n);
+extern void klist_del(struct klist_node *n);
+extern void klist_remove(struct klist_node *n);
 
-extern int klist_node_attached(struct klist_node * n);
+extern int klist_node_attached(struct klist_node *n);
 
 
 struct klist_iter {
-	struct klist		* i_klist;
-	struct list_head	* i_head;
-	struct klist_node	* i_cur;
+	struct klist		*i_klist;
+	struct list_head	*i_head;
+	struct klist_node	*i_cur;
 };
 
 
-extern void klist_iter_init(struct klist * k, struct klist_iter * i);
-extern void klist_iter_init_node(struct klist * k, struct klist_iter * i, 
-				 struct klist_node * n);
-extern void klist_iter_exit(struct klist_iter * i);
-extern struct klist_node * klist_next(struct klist_iter * i);
+extern void klist_iter_init(struct klist *k, struct klist_iter *i);
+extern void klist_iter_init_node(struct klist *k, struct klist_iter *i,
+				 struct klist_node *n);
+extern void klist_iter_exit(struct klist_iter *i);
+extern struct klist_node *klist_next(struct klist_iter *i);
 
 #endif

commit 93dd40013f4f7f4b18d19d0d77855f025bcc57c3
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Apr 22 18:58:46 2008 +0900

    klist: implement klist_add_{after|before}()
    
    Add klist_add_after() and klist_add_before() which puts a new node
    after and before an existing node, respectively.  This is useful for
    callers which need to keep klist ordered.  Note that synchronizing
    between simultaneous additions for ordering is the caller's
    responsibility.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/klist.h b/include/linux/klist.h
index a119c0da8977..b49385f13419 100644
--- a/include/linux/klist.h
+++ b/include/linux/klist.h
@@ -46,6 +46,8 @@ struct klist_node {
 
 extern void klist_add_tail(struct klist_node * n, struct klist * k);
 extern void klist_add_head(struct klist_node * n, struct klist * k);
+extern void klist_add_after(struct klist_node *n, struct klist_node *pos);
+extern void klist_add_before(struct klist_node *n, struct klist_node *pos);
 
 extern void klist_del(struct klist_node * n);
 extern void klist_remove(struct klist_node * n);

commit 1da43e4a9ee942c9c967dbe8839476571df0c3ed
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Apr 26 03:16:04 2008 +0900

    klist: implement KLIST_INIT() and DEFINE_KLIST()
    
    klist is missing static initializers and definition helper.  Add them.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/klist.h b/include/linux/klist.h
index 74071254c9d3..a119c0da8977 100644
--- a/include/linux/klist.h
+++ b/include/linux/klist.h
@@ -25,6 +25,14 @@ struct klist {
 	void			(*put)(struct klist_node *);
 };
 
+#define KLIST_INIT(_name, _get, _put)					\
+	{ .k_lock	= __SPIN_LOCK_UNLOCKED(_name.k_lock),		\
+	  .k_list	= LIST_HEAD_INIT(_name.k_list),			\
+	  .get		= _get,						\
+	  .put		= _put, }
+
+#define DEFINE_KLIST(_name, _get, _put)					\
+	struct klist _name = KLIST_INIT(_name, _get, _put)
 
 extern void klist_init(struct klist * k, void (*get)(struct klist_node *),
 		       void (*put)(struct klist_node *));

commit 34bb61f9ddabd7a7f909cbfb05592eb775f6662a
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Sep 6 16:56:51 2005 -0700

    [PATCH] fix klist semantics for lists which have elements removed on traversal
    
    The problem is that klists claim to provide semantics for safe traversal of
    lists which are being modified.  The failure case is when traversal of a
    list causes element removal (a fairly common case).  The issue is that
    although the list node is refcounted, if it is embedded in an object (which
    is universally the case), then the object will be freed regardless of the
    klist refcount leading to slab corruption because the klist iterator refers
    to the prior element to get the next.
    
    The solution is to make the klist take and release references to the
    embedding object meaning that the embedding object won't be released until
    the list relinquishes the reference to it.
    
    (akpm: fast-track this because it's needed for the 2.6.13 scsi merge)
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/klist.h b/include/linux/klist.h
index c4d1fae4dd89..74071254c9d3 100644
--- a/include/linux/klist.h
+++ b/include/linux/klist.h
@@ -17,15 +17,17 @@
 #include <linux/kref.h>
 #include <linux/list.h>
 
-
+struct klist_node;
 struct klist {
 	spinlock_t		k_lock;
 	struct list_head	k_list;
+	void			(*get)(struct klist_node *);
+	void			(*put)(struct klist_node *);
 };
 
 
-extern void klist_init(struct klist * k);
-
+extern void klist_init(struct klist * k, void (*get)(struct klist_node *),
+		       void (*put)(struct klist_node *));
 
 struct klist_node {
 	struct klist		* n_klist;

commit d856f1e337782326c638c70c0b4df2b909350dec
Author: James Bottomley <James.Bottomley@SteelEye.com>
Date:   Fri Aug 19 09:14:01 2005 -0400

    [PATCH] klist: fix klist to have the same klist_add semantics as list_head
    
    at the moment, the list_head semantics are
    
    list_add(node, head)
    
    whereas current klist semantics are
    
    klist_add(head, node)
    
    This is bound to cause confusion, and since klist is the newcomer, it
    should follow the list_head semantics.
    
    I also added missing include guards to klist.h
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/klist.h b/include/linux/klist.h
index eebf5e5696ec..c4d1fae4dd89 100644
--- a/include/linux/klist.h
+++ b/include/linux/klist.h
@@ -9,6 +9,9 @@
  *	This file is rleased under the GPL v2.
  */
 
+#ifndef _LINUX_KLIST_H
+#define _LINUX_KLIST_H
+
 #include <linux/spinlock.h>
 #include <linux/completion.h>
 #include <linux/kref.h>
@@ -31,8 +34,8 @@ struct klist_node {
 	struct completion	n_removed;
 };
 
-extern void klist_add_tail(struct klist * k, struct klist_node * n);
-extern void klist_add_head(struct klist * k, struct klist_node * n);
+extern void klist_add_tail(struct klist_node * n, struct klist * k);
+extern void klist_add_head(struct klist_node * n, struct klist * k);
 
 extern void klist_del(struct klist_node * n);
 extern void klist_remove(struct klist_node * n);
@@ -53,3 +56,4 @@ extern void klist_iter_init_node(struct klist * k, struct klist_iter * i,
 extern void klist_iter_exit(struct klist_iter * i);
 extern struct klist_node * klist_next(struct klist_iter * i);
 
+#endif

commit 8b0c250be489dcbf1a3a33bb4ec4c7f33735a365
Author: mochel@digitalimplant.org <mochel@digitalimplant.org>
Date:   Thu Mar 24 12:58:57 2005 -0800

    [PATCH] add klist_node_attached() to determine if a node is on a list or not.
    
    Signed-off-by: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
    diff -Nru a/include/linux/klist.h b/include/linux/klist.h

diff --git a/include/linux/klist.h b/include/linux/klist.h
index fb52f9d9d611..eebf5e5696ec 100644
--- a/include/linux/klist.h
+++ b/include/linux/klist.h
@@ -37,6 +37,8 @@ extern void klist_add_head(struct klist * k, struct klist_node * n);
 extern void klist_del(struct klist_node * n);
 extern void klist_remove(struct klist_node * n);
 
+extern int klist_node_attached(struct klist_node * n);
+
 
 struct klist_iter {
 	struct klist		* i_klist;

commit 9a19fea43616066561e221359596ce532e631395
Author: mochel@digitalimplant.org <mochel@digitalimplant.org>
Date:   Mon Mar 21 11:45:16 2005 -0800

    [PATCH] Add initial implementation of klist helpers.
    
    This klist interface provides a couple of structures that wrap around
    struct list_head to provide explicit list "head" (struct klist) and
    list "node" (struct klist_node) objects. For struct klist, a spinlock
    is included that protects access to the actual list itself. struct
    klist_node provides a pointer to the klist that owns it and a kref
    reference count that indicates the number of current users of that node
    in the list.
    
    The entire point is to provide an interface for iterating over a list
    that is safe and allows for modification of the list during the
    iteration (e.g. insertion and removal), including modification of the
    current node on the list.
    
    It works using a 3rd object type - struct klist_iter - that is declared
    and initialized before an iteration. klist_next() is used to acquire the
    next element in the list. It returns NULL if there are no more items.
    This klist interface provides a couple of structures that wrap around
    struct list_head to provide explicit list "head" (struct klist) and
    list "node" (struct klist_node) objects. For struct klist, a spinlock
    is included that protects access to the actual list itself. struct
    klist_node provides a pointer to the klist that owns it and a kref
    reference count that indicates the number of current users of that node
    in the list.
    
    The entire point is to provide an interface for iterating over a list
    that is safe and allows for modification of the list during the
    iteration (e.g. insertion and removal), including modification of the
    current node on the list.
    
    It works using a 3rd object type - struct klist_iter - that is declared
    and initialized before an iteration. klist_next() is used to acquire the
    next element in the list. It returns NULL if there are no more items.
    Internally, that routine takes the klist's lock, decrements the reference
    count of the previous klist_node and increments the count of the next
    klist_node. It then drops the lock and returns.
    
    There are primitives for adding and removing nodes to/from a klist.
    When deleting, klist_del() will simply decrement the reference count.
    Only when the count goes to 0 is the node removed from the list.
    klist_remove() will try to delete the node from the list and block
    until it is actually removed. This is useful for objects (like devices)
    that have been removed from the system and must be freed (but must wait
    until all accessors have finished).
    
    Internally, that routine takes the klist's lock, decrements the reference
    count of the previous klist_node and increments the count of the next
    klist_node. It then drops the lock and returns.
    
    There are primitives for adding and removing nodes to/from a klist.
    When deleting, klist_del() will simply decrement the reference count.
    Only when the count goes to 0 is the node removed from the list.
    klist_remove() will try to delete the node from the list and block
    until it is actually removed. This is useful for objects (like devices)
    that have been removed from the system and must be freed (but must wait
    until all accessors have finished).
    
    Signed-off-by: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
    diff -Nru a/include/linux/klist.h b/include/linux/klist.h

diff --git a/include/linux/klist.h b/include/linux/klist.h
new file mode 100644
index 000000000000..fb52f9d9d611
--- /dev/null
+++ b/include/linux/klist.h
@@ -0,0 +1,53 @@
+/*
+ *	klist.h - Some generic list helpers, extending struct list_head a bit.
+ *
+ *	Implementations are found in lib/klist.c
+ *
+ *
+ *	Copyright (C) 2005 Patrick Mochel
+ *
+ *	This file is rleased under the GPL v2.
+ */
+
+#include <linux/spinlock.h>
+#include <linux/completion.h>
+#include <linux/kref.h>
+#include <linux/list.h>
+
+
+struct klist {
+	spinlock_t		k_lock;
+	struct list_head	k_list;
+};
+
+
+extern void klist_init(struct klist * k);
+
+
+struct klist_node {
+	struct klist		* n_klist;
+	struct list_head	n_node;
+	struct kref		n_ref;
+	struct completion	n_removed;
+};
+
+extern void klist_add_tail(struct klist * k, struct klist_node * n);
+extern void klist_add_head(struct klist * k, struct klist_node * n);
+
+extern void klist_del(struct klist_node * n);
+extern void klist_remove(struct klist_node * n);
+
+
+struct klist_iter {
+	struct klist		* i_klist;
+	struct list_head	* i_head;
+	struct klist_node	* i_cur;
+};
+
+
+extern void klist_iter_init(struct klist * k, struct klist_iter * i);
+extern void klist_iter_init_node(struct klist * k, struct klist_iter * i, 
+				 struct klist_node * n);
+extern void klist_iter_exit(struct klist_iter * i);
+extern struct klist_node * klist_next(struct klist_iter * i);
+
