commit f3b0a18bb6cb07a9abb75e21b1f08eeaefa78e81
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Mon Oct 21 18:47:58 2019 +0000

    net: remove unnecessary variables and callback
    
    This patch removes variables and callback these are related to the nested
    device structure.
    devices that can be nested have their own nest_level variable that
    represents the depth of nested devices.
    In the previous patch, new {lower/upper}_level variables are added and
    they replace old private nest_level variable.
    So, this patch removes all 'nest_level' variables.
    
    In order to avoid lockdep warning, ->ndo_get_lock_subclass() was added
    to get lockdep subclass value, which is actually lower nested depth value.
    But now, they use the dynamic lockdep key to avoid lockdep warning instead
    of the subclass.
    So, this patch removes ->ndo_get_lock_subclass() callback.
    
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 2e55e4cdbd8a..a367ead4bf4b 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -29,7 +29,6 @@ struct macvlan_dev {
 	netdev_features_t	set_features;
 	enum macvlan_mode	mode;
 	u16			flags;
-	int			nest_level;
 	unsigned int		macaddr_count;
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	struct netpoll		*netpoll;

commit 53cd4d8e4dfb231fa5ba125b6c0666b82a0504fa
Author: Alexander Duyck <alexander.h.duyck@intel.com>
Date:   Tue Apr 3 17:16:30 2018 -0400

    macvlan: Provide function for interfaces to release HW offload
    
    This patch provides a basic function to allow a lower device to disable
    macvlan offload if it was previously enabled on a given macvlan. The idea
    here is to allow for recovery from failure should the lowerdev run out of
    resources.
    
    Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 0221390668a0..2e55e4cdbd8a 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -97,4 +97,12 @@ static inline bool macvlan_supports_dest_filter(struct net_device *dev)
 	       macvlan->mode == MACVLAN_MODE_VEPA ||
 	       macvlan->mode == MACVLAN_MODE_BRIDGE;
 }
+
+static inline int macvlan_release_l2fw_offload(struct net_device *dev)
+{
+	struct macvlan_dev *macvlan = netdev_priv(dev);
+
+	macvlan->accel_priv = NULL;
+	return dev_uc_add(macvlan->lowerdev, dev->dev_addr);
+}
 #endif /* _LINUX_IF_MACVLAN_H */

commit 6cb1937d4eff6936089139169377fda208a2701a
Author: Alexander Duyck <alexander.h.duyck@intel.com>
Date:   Tue Apr 3 17:16:25 2018 -0400

    macvlan: Add function to test for destination filtering support
    
    This patch adds a function indicating if a given macvlan can fully supports
    destination filtering, especially as it relates to unicast traffic. For
    those macvlan interfaces that do not support destination filtering such
    passthru or source mode filtering we should not be enabling offload
    support.
    
    Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 80089d6c5a0a..0221390668a0 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -88,4 +88,13 @@ static inline void *macvlan_accel_priv(struct net_device *dev)
 
 	return macvlan->accel_priv;
 }
+
+static inline bool macvlan_supports_dest_filter(struct net_device *dev)
+{
+	struct macvlan_dev *macvlan = netdev_priv(dev);
+
+	return macvlan->mode == MACVLAN_MODE_PRIVATE ||
+	       macvlan->mode == MACVLAN_MODE_VEPA ||
+	       macvlan->mode == MACVLAN_MODE_BRIDGE;
+}
 #endif /* _LINUX_IF_MACVLAN_H */

commit a222311283641c9a476426ccacb2a3c82bfe5aaa
Author: Alexander Duyck <alexander.h.duyck@intel.com>
Date:   Tue Apr 3 17:16:19 2018 -0400

    macvlan: macvlan_count_rx shouldn't be static inline AND extern
    
    It doesn't make sense to define macvlan_count_rx as a static inline and
    then add a forward declaration after that as an extern. I am dropping the
    extern declaration since it seems like it is something that likely got
    missed when the function was made an inline.
    
    Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index c5106ce8273a..80089d6c5a0a 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -61,10 +61,6 @@ extern int macvlan_common_newlink(struct net *src_net, struct net_device *dev,
 				  struct nlattr *tb[], struct nlattr *data[],
 				  struct netlink_ext_ack *extack);
 
-extern void macvlan_count_rx(const struct macvlan_dev *vlan,
-			     unsigned int len, bool success,
-			     bool multicast);
-
 extern void macvlan_dellink(struct net_device *dev, struct list_head *head);
 
 extern int macvlan_link_register(struct rtnl_link_ops *ops);

commit 7d775f63470c3b6ddf34c770c973293ab925a7bb
Author: Alexander Duyck <alexander.h.duyck@intel.com>
Date:   Tue Apr 3 17:16:03 2018 -0400

    macvlan: Rename fwd_priv to accel_priv and add accessor function
    
    This change renames the fwd_priv member to accel_priv as this more
    accurately reflects the actual purpose of this value. In addition I am
    adding an accessor which will allow us to further abstract this in the
    future if needed.
    
    Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 4cb7aeeafce0..c5106ce8273a 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -21,7 +21,7 @@ struct macvlan_dev {
 	struct hlist_node	hlist;
 	struct macvlan_port	*port;
 	struct net_device	*lowerdev;
-	void			*fwd_priv;
+	void			*accel_priv;
 	struct vlan_pcpu_stats __percpu *pcpu_stats;
 
 	DECLARE_BITMAP(mc_filter, MACVLAN_MC_FILTER_SZ);
@@ -86,4 +86,10 @@ macvlan_dev_real_dev(const struct net_device *dev)
 }
 #endif
 
+static inline void *macvlan_accel_priv(struct net_device *dev)
+{
+	struct macvlan_dev *macvlan = netdev_priv(dev);
+
+	return macvlan->accel_priv;
+}
 #endif /* _LINUX_IF_MACVLAN_H */

commit 5e54b3c1202765ae62de24a160f1eaf6b0ebf9d4
Author: Girish Moodalbail <girish.moodalbail@oracle.com>
Date:   Fri Dec 8 06:03:26 2017 -0800

    macvlan: fix memory hole in macvlan_dev
    
    Move 'macaddr_count' from after 'netpoll' to after 'nest_level' to pack
    and reduce a memory hole.
    
    Fixes: 88ca59d1aaf28c25 (macvlan: remove unused fields in struct macvlan_dev)
    Signed-off-by: Girish Moodalbail <girish.moodalbail@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index bedf54b6f943..4cb7aeeafce0 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -30,10 +30,10 @@ struct macvlan_dev {
 	enum macvlan_mode	mode;
 	u16			flags;
 	int			nest_level;
+	unsigned int		macaddr_count;
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	struct netpoll		*netpoll;
 #endif
-	unsigned int		macaddr_count;
 };
 
 static inline void macvlan_count_rx(const struct macvlan_dev *vlan,

commit 2a171788ba7bb61995e98e8163204fc7880f63b2
Merge: bf5345882bd1 d4c2e9fca5b7
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Nov 4 09:26:51 2017 +0900

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Files removed in 'net-next' had their license header updated
    in 'net'.  We take the remove from 'net-next'.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index c9ec1343d187..0e2c60efad2d 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _LINUX_IF_MACVLAN_H
 #define _LINUX_IF_MACVLAN_H
 

commit 88ca59d1aaf28c25b47a9f933090e480ba6dc92a
Author: Girish Moodalbail <girish.moodalbail@oracle.com>
Date:   Wed Oct 25 12:26:43 2017 -0700

    macvlan: remove unused fields in struct macvlan_dev
    
    commit 635b8c8ecdd2 ("tap: Renaming tap related APIs, data structures,
    macros") captured all the tap related fields into a new struct tap_dev.
    However, it failed to remove those fields from struct macvlan_dev.
    Those fields are currently unused and must be removed. While there
    I moved the comment for MAX_TAP_QUEUES to the right place.
    
    Fixes: 635b8c8ecdd27142 (tap: Renaming tap related APIs, data structures, macros)
    Signed-off-by: Girish Moodalbail <girish.moodalbail@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 10e319f41fb1..e13b369df02b 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -10,13 +10,6 @@
 #include <linux/u64_stats_sync.h>
 
 struct macvlan_port;
-struct macvtap_queue;
-
-/*
- * Maximum times a macvtap device can be opened. This can be used to
- * configure the number of receive queue, e.g. for multiqueue virtio.
- */
-#define MAX_TAP_QUEUES	256
 
 #define MACVLAN_MC_FILTER_BITS	8
 #define MACVLAN_MC_FILTER_SZ	(1 << MACVLAN_MC_FILTER_BITS)
@@ -35,14 +28,6 @@ struct macvlan_dev {
 	netdev_features_t	set_features;
 	enum macvlan_mode	mode;
 	u16			flags;
-	/* This array tracks active taps. */
-	struct tap_queue	__rcu *taps[MAX_TAP_QUEUES];
-	/* This list tracks all taps (both enabled and disabled) */
-	struct list_head	queue_list;
-	int			numvtaps;
-	int			numqueues;
-	netdev_features_t	tap_features;
-	int			minor;
 	int			nest_level;
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	struct netpoll		*netpoll;

commit 42ab19ee90292993370a30ad242599d75a3b749e
Author: David Ahern <dsahern@gmail.com>
Date:   Wed Oct 4 17:48:47 2017 -0700

    net: Add extack to upper device linking
    
    Add extack arg to netdev_upper_dev_link and netdev_master_upper_dev_link
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index c9ec1343d187..10e319f41fb1 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -72,7 +72,8 @@ static inline void macvlan_count_rx(const struct macvlan_dev *vlan,
 extern void macvlan_common_setup(struct net_device *dev);
 
 extern int macvlan_common_newlink(struct net *src_net, struct net_device *dev,
-				  struct nlattr *tb[], struct nlattr *data[]);
+				  struct nlattr *tb[], struct nlattr *data[],
+				  struct netlink_ext_ack *extack);
 
 extern void macvlan_count_rx(const struct macvlan_dev *vlan,
 			     unsigned int len, bool success,

commit 635b8c8ecdd27142d7fdab0df334b2e9201481cf
Author: Sainath Grandhi <sainath.grandhi@intel.com>
Date:   Fri Feb 10 16:03:47 2017 -0800

    tap: Renaming tap related APIs, data structures, macros
    
    Renaming tap related APIs, data structures and macros in tap.c from macvtap_.* to tap_.*
    
    Signed-off-by: Sainath Grandhi <sainath.grandhi@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index a4ccc3122f93..c9ec1343d187 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -9,19 +9,6 @@
 #include <net/netlink.h>
 #include <linux/u64_stats_sync.h>
 
-#if IS_ENABLED(CONFIG_MACVTAP)
-struct socket *macvtap_get_socket(struct file *);
-#else
-#include <linux/err.h>
-#include <linux/errno.h>
-struct file;
-struct socket;
-static inline struct socket *macvtap_get_socket(struct file *f)
-{
-	return ERR_PTR(-EINVAL);
-}
-#endif /* CONFIG_MACVTAP */
-
 struct macvlan_port;
 struct macvtap_queue;
 
@@ -29,7 +16,7 @@ struct macvtap_queue;
  * Maximum times a macvtap device can be opened. This can be used to
  * configure the number of receive queue, e.g. for multiqueue virtio.
  */
-#define MAX_MACVTAP_QUEUES	256
+#define MAX_TAP_QUEUES	256
 
 #define MACVLAN_MC_FILTER_BITS	8
 #define MACVLAN_MC_FILTER_SZ	(1 << MACVLAN_MC_FILTER_BITS)
@@ -49,7 +36,7 @@ struct macvlan_dev {
 	enum macvlan_mode	mode;
 	u16			flags;
 	/* This array tracks active taps. */
-	struct macvtap_queue	__rcu *taps[MAX_MACVTAP_QUEUES];
+	struct tap_queue	__rcu *taps[MAX_TAP_QUEUES];
 	/* This list tracks all taps (both enabled and disabled) */
 	struct list_head	queue_list;
 	int			numvtaps;

commit dfe816c5e37272f2f3c1311f0e9934e1b4229261
Author: Pankaj Gupta <pagupta@redhat.com>
Date:   Fri Jun 19 19:47:53 2015 +0530

    macvtap: Increase limit of macvtap queues
    
    Macvtap should be compatible with tuntap for
    maximum number of queues.
    
    commit 'baf71c5c1f80d82e92924050a60b5baaf97e3094 (tuntap:
    Increase the number of queues in tun.)' removes
    the limitations and increases number of queues in tuntap.
    Now, Its safe to increase number of queues in Macvtap as well.
    
    This patch also modifies 'macvtap_del_queues' function
    to avoid extra memory allocation in stack.
    
    Changes from v1->v2 :
    Michael S. Tsirkin, Jason Wang  :
                      Better way to use linked list to
    avoid use of extra memory in stack.
    Sergei Shtylyov : Specify dependent commit's summary.
    
    Signed-off-by: Pankaj Gupta <pagupta@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 6f6929ea8a0c..a4ccc3122f93 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -29,7 +29,7 @@ struct macvtap_queue;
  * Maximum times a macvtap device can be opened. This can be used to
  * configure the number of receive queue, e.g. for multiqueue virtio.
  */
-#define MAX_MACVTAP_QUEUES	16
+#define MAX_MACVTAP_QUEUES	256
 
 #define MACVLAN_MC_FILTER_BITS	8
 #define MACVLAN_MC_FILTER_SZ	(1 << MACVLAN_MC_FILTER_BITS)

commit 79cf79abce71eb7dbc40e2f3121048ca5405cb47
Author: Michael Braun <michael-dev@fami-braun.de>
Date:   Thu Sep 25 16:31:08 2014 +0200

    macvlan: add source mode
    
    This patch adds a new mode of operation to macvlan, called "source".
    It allows one to set a list of allowed mac address, which is used
    to match against source mac address from received frames on underlying
    interface.
    This enables creating mac based VLAN associations, instead of standard
    port or tag based. The feature is useful to deploy 802.1x mac based
    behavior, where drivers of underlying interfaces doesn't allows that.
    
    Configuration is done through the netlink interface using e.g.:
     ip link add link eth0 name macvlan0 type macvlan mode source
     ip link add link eth0 name macvlan1 type macvlan mode source
     ip link set link dev macvlan0 type macvlan macaddr add 00:11:11:11:11:11
     ip link set link dev macvlan0 type macvlan macaddr add 00:22:22:22:22:22
     ip link set link dev macvlan0 type macvlan macaddr add 00:33:33:33:33:33
     ip link set link dev macvlan1 type macvlan macaddr add 00:33:33:33:33:33
     ip link set link dev macvlan1 type macvlan macaddr add 00:44:44:44:44:44
    
    This allows clients with MAC addresses 00:11:11:11:11:11,
    00:22:22:22:22:22 to be part of only VLAN associated with macvlan0
    interface. Clients with MAC addresses 00:44:44:44:44:44 with only VLAN
    associated with macvlan1 interface. And client with MAC address
    00:33:33:33:33:33 to be associated with both VLANs.
    
    Based on work of Stefan Gula <steweg@gmail.com>
    
    v8: last version of Stefan Gula for Kernel 3.2.1
    v9: rework onto linux-next 2014-03-12 by Michael Braun
        add MACADDR_SET command, enable to configure mac for source mode
        while creating interface
    v10:
      - reduce indention level
      - rename source_list to source_entry
      - use aligned 64bit ether address
      - use hash_64 instead of addr[5]
    v11:
      - rebase for 3.14 / linux-next 20.04.2014
    v12
      - rebase for linux-next 2014-09-25
    
    Signed-off-by: Michael Braun <michael-dev@fami-braun.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 6b2c7cf352a5..6f6929ea8a0c 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -60,6 +60,7 @@ struct macvlan_dev {
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	struct netpoll		*netpoll;
 #endif
+	unsigned int		macaddr_count;
 };
 
 static inline void macvlan_count_rx(const struct macvlan_dev *vlan,

commit 688cea83f4396fa98b77a126ed278b89daccccdc
Author: dingtianhong <dingtianhong@huawei.com>
Date:   Fri May 30 16:00:56 2014 +0800

    macvlan: add netpoll support
    
    Add netpoll support to macvlan devices. Based on the netpoll support in the 802.1q vlan code.
    
    Tested and macvlan could work well with netconsole.
    
    Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index a9a53b12397b..6b2c7cf352a5 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -57,6 +57,9 @@ struct macvlan_dev {
 	netdev_features_t	tap_features;
 	int			minor;
 	int			nest_level;
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	struct netpoll		*netpoll;
+#endif
 };
 
 static inline void macvlan_count_rx(const struct macvlan_dev *vlan,

commit c674ac30c549596295eb0a5af7f4714c0b905b6f
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Fri May 16 17:04:56 2014 -0400

    macvlan: Fix lockdep warnings with stacked macvlan devices
    
    Macvlan devices try to avoid stacking, but that's not always
    successfull or even desired.  As an example, the following
    configuration is perefectly legal and valid:
    
    eth0 <--- macvlan0 <---- vlan0.10 <--- macvlan1
    
    However, this configuration produces the following lockdep
    trace:
    [  115.620418] ======================================================
    [  115.620477] [ INFO: possible circular locking dependency detected ]
    [  115.620516] 3.15.0-rc1+ #24 Not tainted
    [  115.620540] -------------------------------------------------------
    [  115.620577] ip/1704 is trying to acquire lock:
    [  115.620604]  (&vlan_netdev_addr_lock_key/1){+.....}, at: [<ffffffff815df49c>] dev_uc_sync+0x3c/0x80
    [  115.620686]
    but task is already holding lock:
    [  115.620723]  (&macvlan_netdev_addr_lock_key){+.....}, at: [<ffffffff815da5be>] dev_set_rx_mode+0x1e/0x40
    [  115.620795]
    which lock already depends on the new lock.
    
    [  115.620853]
    the existing dependency chain (in reverse order) is:
    [  115.620894]
    -> #1 (&macvlan_netdev_addr_lock_key){+.....}:
    [  115.620935]        [<ffffffff810d57f2>] lock_acquire+0xa2/0x130
    [  115.620974]        [<ffffffff816f62e7>] _raw_spin_lock_nested+0x37/0x50
    [  115.621019]        [<ffffffffa07296c3>] vlan_dev_set_rx_mode+0x53/0x110 [8021q]
    [  115.621066]        [<ffffffff815da557>] __dev_set_rx_mode+0x57/0xa0
    [  115.621105]        [<ffffffff815da5c6>] dev_set_rx_mode+0x26/0x40
    [  115.621143]        [<ffffffff815da6be>] __dev_open+0xde/0x140
    [  115.621174]        [<ffffffff815da9ad>] __dev_change_flags+0x9d/0x170
    [  115.621174]        [<ffffffff815daaa9>] dev_change_flags+0x29/0x60
    [  115.621174]        [<ffffffff815e7f11>] do_setlink+0x321/0x9a0
    [  115.621174]        [<ffffffff815ea59f>] rtnl_newlink+0x51f/0x730
    [  115.621174]        [<ffffffff815e6e75>] rtnetlink_rcv_msg+0x95/0x250
    [  115.621174]        [<ffffffff81608b19>] netlink_rcv_skb+0xa9/0xc0
    [  115.621174]        [<ffffffff815e6dca>] rtnetlink_rcv+0x2a/0x40
    [  115.621174]        [<ffffffff81608150>] netlink_unicast+0xf0/0x1c0
    [  115.621174]        [<ffffffff8160851f>] netlink_sendmsg+0x2ff/0x740
    [  115.621174]        [<ffffffff815bc9db>] sock_sendmsg+0x8b/0xc0
    [  115.621174]        [<ffffffff815bd4b9>] ___sys_sendmsg+0x369/0x380
    [  115.621174]        [<ffffffff815bdbb2>] __sys_sendmsg+0x42/0x80
    [  115.621174]        [<ffffffff815bdc02>] SyS_sendmsg+0x12/0x20
    [  115.621174]        [<ffffffff816ffd69>] system_call_fastpath+0x16/0x1b
    [  115.621174]
    -> #0 (&vlan_netdev_addr_lock_key/1){+.....}:
    [  115.621174]        [<ffffffff810d4d43>] __lock_acquire+0x1773/0x1a60
    [  115.621174]        [<ffffffff810d57f2>] lock_acquire+0xa2/0x130
    [  115.621174]        [<ffffffff816f62e7>] _raw_spin_lock_nested+0x37/0x50
    [  115.621174]        [<ffffffff815df49c>] dev_uc_sync+0x3c/0x80
    [  115.621174]        [<ffffffffa0696d2a>] macvlan_set_mac_lists+0xca/0x110 [macvlan]
    [  115.621174]        [<ffffffff815da557>] __dev_set_rx_mode+0x57/0xa0
    [  115.621174]        [<ffffffff815da5c6>] dev_set_rx_mode+0x26/0x40
    [  115.621174]        [<ffffffff815da6be>] __dev_open+0xde/0x140
    [  115.621174]        [<ffffffff815da9ad>] __dev_change_flags+0x9d/0x170
    [  115.621174]        [<ffffffff815daaa9>] dev_change_flags+0x29/0x60
    [  115.621174]        [<ffffffff815e7f11>] do_setlink+0x321/0x9a0
    [  115.621174]        [<ffffffff815ea59f>] rtnl_newlink+0x51f/0x730
    [  115.621174]        [<ffffffff815e6e75>] rtnetlink_rcv_msg+0x95/0x250
    [  115.621174]        [<ffffffff81608b19>] netlink_rcv_skb+0xa9/0xc0
    [  115.621174]        [<ffffffff815e6dca>] rtnetlink_rcv+0x2a/0x40
    [  115.621174]        [<ffffffff81608150>] netlink_unicast+0xf0/0x1c0
    [  115.621174]        [<ffffffff8160851f>] netlink_sendmsg+0x2ff/0x740
    [  115.621174]        [<ffffffff815bc9db>] sock_sendmsg+0x8b/0xc0
    [  115.621174]        [<ffffffff815bd4b9>] ___sys_sendmsg+0x369/0x380
    [  115.621174]        [<ffffffff815bdbb2>] __sys_sendmsg+0x42/0x80
    [  115.621174]        [<ffffffff815bdc02>] SyS_sendmsg+0x12/0x20
    [  115.621174]        [<ffffffff816ffd69>] system_call_fastpath+0x16/0x1b
    [  115.621174]
    other info that might help us debug this:
    
    [  115.621174]  Possible unsafe locking scenario:
    
    [  115.621174]        CPU0                    CPU1
    [  115.621174]        ----                    ----
    [  115.621174]   lock(&macvlan_netdev_addr_lock_key);
    [  115.621174]                                lock(&vlan_netdev_addr_lock_key/1);
    [  115.621174]                                lock(&macvlan_netdev_addr_lock_key);
    [  115.621174]   lock(&vlan_netdev_addr_lock_key/1);
    [  115.621174]
     *** DEADLOCK ***
    
    [  115.621174] 2 locks held by ip/1704:
    [  115.621174]  #0:  (rtnl_mutex){+.+.+.}, at: [<ffffffff815e6dbb>] rtnetlink_rcv+0x1b/0x40
    [  115.621174]  #1:  (&macvlan_netdev_addr_lock_key){+.....}, at: [<ffffffff815da5be>] dev_set_rx_mode+0x1e/0x40
    [  115.621174]
    stack backtrace:
    [  115.621174] CPU: 3 PID: 1704 Comm: ip Not tainted 3.15.0-rc1+ #24
    [  115.621174] Hardware name: Hewlett-Packard HP xw8400 Workstation/0A08h, BIOS 786D5 v02.38 10/25/2010
    [  115.621174]  ffffffff82339ae0 ffff880465f79568 ffffffff816ee20c ffffffff82339ae0
    [  115.621174]  ffff880465f795a8 ffffffff816e9e1b ffff880465f79600 ffff880465b019c8
    [  115.621174]  0000000000000001 0000000000000002 ffff880465b019c8 ffff880465b01230
    [  115.621174] Call Trace:
    [  115.621174]  [<ffffffff816ee20c>] dump_stack+0x4d/0x66
    [  115.621174]  [<ffffffff816e9e1b>] print_circular_bug+0x200/0x20e
    [  115.621174]  [<ffffffff810d4d43>] __lock_acquire+0x1773/0x1a60
    [  115.621174]  [<ffffffff810d3172>] ? trace_hardirqs_on_caller+0xb2/0x1d0
    [  115.621174]  [<ffffffff810d57f2>] lock_acquire+0xa2/0x130
    [  115.621174]  [<ffffffff815df49c>] ? dev_uc_sync+0x3c/0x80
    [  115.621174]  [<ffffffff816f62e7>] _raw_spin_lock_nested+0x37/0x50
    [  115.621174]  [<ffffffff815df49c>] ? dev_uc_sync+0x3c/0x80
    [  115.621174]  [<ffffffff815df49c>] dev_uc_sync+0x3c/0x80
    [  115.621174]  [<ffffffffa0696d2a>] macvlan_set_mac_lists+0xca/0x110 [macvlan]
    [  115.621174]  [<ffffffff815da557>] __dev_set_rx_mode+0x57/0xa0
    [  115.621174]  [<ffffffff815da5c6>] dev_set_rx_mode+0x26/0x40
    [  115.621174]  [<ffffffff815da6be>] __dev_open+0xde/0x140
    [  115.621174]  [<ffffffff815da9ad>] __dev_change_flags+0x9d/0x170
    [  115.621174]  [<ffffffff815daaa9>] dev_change_flags+0x29/0x60
    [  115.621174]  [<ffffffff811e1db1>] ? mem_cgroup_bad_page_check+0x21/0x30
    [  115.621174]  [<ffffffff815e7f11>] do_setlink+0x321/0x9a0
    [  115.621174]  [<ffffffff810d394c>] ? __lock_acquire+0x37c/0x1a60
    [  115.621174]  [<ffffffff815ea59f>] rtnl_newlink+0x51f/0x730
    [  115.621174]  [<ffffffff815ea169>] ? rtnl_newlink+0xe9/0x730
    [  115.621174]  [<ffffffff815e6e75>] rtnetlink_rcv_msg+0x95/0x250
    [  115.621174]  [<ffffffff810d329d>] ? trace_hardirqs_on+0xd/0x10
    [  115.621174]  [<ffffffff815e6dbb>] ? rtnetlink_rcv+0x1b/0x40
    [  115.621174]  [<ffffffff815e6de0>] ? rtnetlink_rcv+0x40/0x40
    [  115.621174]  [<ffffffff81608b19>] netlink_rcv_skb+0xa9/0xc0
    [  115.621174]  [<ffffffff815e6dca>] rtnetlink_rcv+0x2a/0x40
    [  115.621174]  [<ffffffff81608150>] netlink_unicast+0xf0/0x1c0
    [  115.621174]  [<ffffffff8160851f>] netlink_sendmsg+0x2ff/0x740
    [  115.621174]  [<ffffffff815bc9db>] sock_sendmsg+0x8b/0xc0
    [  115.621174]  [<ffffffff8119d4af>] ? might_fault+0x5f/0xb0
    [  115.621174]  [<ffffffff8119d4f8>] ? might_fault+0xa8/0xb0
    [  115.621174]  [<ffffffff8119d4af>] ? might_fault+0x5f/0xb0
    [  115.621174]  [<ffffffff815cb51e>] ? verify_iovec+0x5e/0xe0
    [  115.621174]  [<ffffffff815bd4b9>] ___sys_sendmsg+0x369/0x380
    [  115.621174]  [<ffffffff816faa0d>] ? __do_page_fault+0x11d/0x570
    [  115.621174]  [<ffffffff810cfe9f>] ? up_read+0x1f/0x40
    [  115.621174]  [<ffffffff816fab04>] ? __do_page_fault+0x214/0x570
    [  115.621174]  [<ffffffff8120a10b>] ? mntput_no_expire+0x6b/0x1c0
    [  115.621174]  [<ffffffff8120a0b7>] ? mntput_no_expire+0x17/0x1c0
    [  115.621174]  [<ffffffff8120a284>] ? mntput+0x24/0x40
    [  115.621174]  [<ffffffff815bdbb2>] __sys_sendmsg+0x42/0x80
    [  115.621174]  [<ffffffff815bdc02>] SyS_sendmsg+0x12/0x20
    [  115.621174]  [<ffffffff816ffd69>] system_call_fastpath+0x16/0x1b
    
    Fix this by correctly providing macvlan lockdep class.
    
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 7c8b20b120ea..a9a53b12397b 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -56,6 +56,7 @@ struct macvlan_dev {
 	int			numqueues;
 	netdev_features_t	tap_features;
 	int			minor;
+	int			nest_level;
 };
 
 static inline void macvlan_count_rx(const struct macvlan_dev *vlan,

commit cdf3e274cf1b36e9a2fef2d175cabc566af841b2
Author: Li RongQing <roy.qing.li@gmail.com>
Date:   Sat Jan 4 14:22:34 2014 +0800

    macvlan: unify macvlan_pcpu_stats and vlan_pcpu_stats
    
    They are same, so unify them as one; since macvlan is a kind of vlan,
    vlan_pcpu_stats should be a proper name for vlan and macvlan.
    
    Signed-off-by: Li RongQing <roy.qing.li@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 551bdd3722a2..7c8b20b120ea 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -2,6 +2,7 @@
 #define _LINUX_IF_MACVLAN_H
 
 #include <linux/if_link.h>
+#include <linux/if_vlan.h>
 #include <linux/list.h>
 #include <linux/netdevice.h>
 #include <linux/netlink.h>
@@ -24,28 +25,6 @@ static inline struct socket *macvtap_get_socket(struct file *f)
 struct macvlan_port;
 struct macvtap_queue;
 
-/**
- *	struct macvlan_pcpu_stats - MACVLAN percpu stats
- *	@rx_packets: number of received packets
- *	@rx_bytes: number of received bytes
- *	@rx_multicast: number of received multicast packets
- *	@tx_packets: number of transmitted packets
- *	@tx_bytes: number of transmitted bytes
- *	@syncp: synchronization point for 64bit counters
- *	@rx_errors: number of rx errors
- *	@tx_dropped: number of tx dropped packets
- */
-struct macvlan_pcpu_stats {
-	u64			rx_packets;
-	u64			rx_bytes;
-	u64			rx_multicast;
-	u64			tx_packets;
-	u64			tx_bytes;
-	struct u64_stats_sync	syncp;
-	u32			rx_errors;
-	u32			tx_dropped;
-};
-
 /*
  * Maximum times a macvtap device can be opened. This can be used to
  * configure the number of receive queue, e.g. for multiqueue virtio.
@@ -62,7 +41,7 @@ struct macvlan_dev {
 	struct macvlan_port	*port;
 	struct net_device	*lowerdev;
 	void			*fwd_priv;
-	struct macvlan_pcpu_stats __percpu *pcpu_stats;
+	struct vlan_pcpu_stats __percpu *pcpu_stats;
 
 	DECLARE_BITMAP(mc_filter, MACVLAN_MC_FILTER_SZ);
 
@@ -84,7 +63,7 @@ static inline void macvlan_count_rx(const struct macvlan_dev *vlan,
 				    bool multicast)
 {
 	if (likely(success)) {
-		struct macvlan_pcpu_stats *pcpu_stats;
+		struct vlan_pcpu_stats *pcpu_stats;
 
 		pcpu_stats = this_cpu_ptr(vlan->pcpu_stats);
 		u64_stats_update_begin(&pcpu_stats->syncp);

commit 0db901bd33f09b0dbf39d12261f689812e343c26
Author: stephen hemminger <stephen@networkplumber.org>
Date:   Fri Dec 27 12:06:46 2013 -0800

    macvlan: make start_xmit local
    
    Only used in one file, no need to expose
    
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index ea22721ba269..551bdd3722a2 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -111,9 +111,6 @@ extern void macvlan_dellink(struct net_device *dev, struct list_head *head);
 
 extern int macvlan_link_register(struct rtnl_link_ops *ops);
 
-extern netdev_tx_t macvlan_start_xmit(struct sk_buff *skb,
-				      struct net_device *dev);
-
 #if IS_ENABLED(CONFIG_MACVLAN)
 static inline struct net_device *
 macvlan_dev_real_dev(const struct net_device *dev)

commit 2f6a1b6607fd6b0eb9501843a40e0c7555f37b4a
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Wed Dec 11 13:27:11 2013 -0500

    macvlan: Remove custom recieve and forward handlers
    
    Since now macvlan and macvtap use the same receive and
    forward handlers, we can remove them completely and use
    netif_rx and dev_forward_skb() directly.
    
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 84ba5ac39e03..ea22721ba269 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -69,8 +69,6 @@ struct macvlan_dev {
 	netdev_features_t	set_features;
 	enum macvlan_mode	mode;
 	u16			flags;
-	int (*receive)(struct sk_buff *skb);
-	int (*forward)(struct net_device *dev, struct sk_buff *skb);
 	/* This array tracks active taps. */
 	struct macvtap_queue	__rcu *taps[MAX_MACVTAP_QUEUES];
 	/* This list tracks all taps (both enabled and disabled) */
@@ -103,10 +101,7 @@ static inline void macvlan_count_rx(const struct macvlan_dev *vlan,
 extern void macvlan_common_setup(struct net_device *dev);
 
 extern int macvlan_common_newlink(struct net *src_net, struct net_device *dev,
-				  struct nlattr *tb[], struct nlattr *data[],
-				  int (*receive)(struct sk_buff *skb),
-				  int (*forward)(struct net_device *dev,
-						 struct sk_buff *skb));
+				  struct nlattr *tb[], struct nlattr *data[]);
 
 extern void macvlan_count_rx(const struct macvlan_dev *vlan,
 			     unsigned int len, bool success,

commit be9eac48274a2d9b142d6dd8567b9b2362939346
Author: Michal Kubeček <mkubecek@suse.cz>
Date:   Fri Nov 15 06:18:40 2013 +0100

    macvlan: introduce macvlan_dev_real_dev() helper function
    
    Introduce helper function macvlan_dev_real_dev which returns the
    underlying device of a macvlan device, similar to vlan_dev_real_dev()
    for 802.1q VLAN devices.
    
    v2: IFF_MACVLAN flag and equivalent of is_macvlan_dev() were
    introduced in the meantime
    
    v3: do BUG() if compiled without macvlan support
    
    Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index c2702856295e..84ba5ac39e03 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -119,4 +119,21 @@ extern int macvlan_link_register(struct rtnl_link_ops *ops);
 extern netdev_tx_t macvlan_start_xmit(struct sk_buff *skb,
 				      struct net_device *dev);
 
+#if IS_ENABLED(CONFIG_MACVLAN)
+static inline struct net_device *
+macvlan_dev_real_dev(const struct net_device *dev)
+{
+	struct macvlan_dev *macvlan = netdev_priv(dev);
+
+	return macvlan->lowerdev;
+}
+#else
+static inline struct net_device *
+macvlan_dev_real_dev(const struct net_device *dev)
+{
+	BUG();
+	return NULL;
+}
+#endif
+
 #endif /* _LINUX_IF_MACVLAN_H */

commit a6cc0cfa72e0b6d9f2c8fd858aacc32313c4f272
Author: John Fastabend <john.r.fastabend@intel.com>
Date:   Wed Nov 6 09:54:46 2013 -0800

    net: Add layer 2 hardware acceleration operations for macvlan devices
    
    Add a operations structure that allows a network interface to export
    the fact that it supports package forwarding in hardware between
    physical interfaces and other mac layer devices assigned to it (such
    as macvlans). This operaions structure can be used by virtual mac
    devices to bypass software switching so that forwarding can be done
    in hardware more efficiently.
    
    Signed-off-by: John Fastabend <john.r.fastabend@intel.com>
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    CC: Andy Gospodarek <andy@greyhouse.net>
    CC: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index ddd33fd5904d..c2702856295e 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -61,6 +61,7 @@ struct macvlan_dev {
 	struct hlist_node	hlist;
 	struct macvlan_port	*port;
 	struct net_device	*lowerdev;
+	void			*fwd_priv;
 	struct macvlan_pcpu_stats __percpu *pcpu_stats;
 
 	DECLARE_BITMAP(mc_filter, MACVLAN_MC_FILTER_SZ);

commit 2be5c76794b0e570aa87b012df5ac864ce668a74
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Tue Jun 25 16:04:21 2013 -0400

    macvtap: Let TUNSETOFFLOAD actually controll offload features.
    
    When the user issues TUNSETOFFLOAD ioctl, macvtap does not do
    anything other then to verify arguments.  This patch adds
    functionality to allow users to actually control offload features.
    NETIF_F_GSO and NETIF_F_GRO are always on, but the rest of the
    features can be controlled.
    
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index f49a9f66c3d9..ddd33fd5904d 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -65,6 +65,7 @@ struct macvlan_dev {
 
 	DECLARE_BITMAP(mc_filter, MACVLAN_MC_FILTER_SZ);
 
+	netdev_features_t	set_features;
 	enum macvlan_mode	mode;
 	u16			flags;
 	int (*receive)(struct sk_buff *skb);
@@ -75,6 +76,7 @@ struct macvlan_dev {
 	struct list_head	queue_list;
 	int			numvtaps;
 	int			numqueues;
+	netdev_features_t	tap_features;
 	int			minor;
 };
 

commit d9a90a3105eb6ca89aab74223e6526ab4a5e44b5
Author: Jason Wang <jasowang@redhat.com>
Date:   Thu Jun 13 14:23:35 2013 +0800

    macvtap: slient sparse warnings
    
    This patch silents the following sparse warnings:
    
    drivers/net/macvtap.c:98:9: warning: incorrect type in assignment (different
    address spaces)
    drivers/net/macvtap.c:98:9:    expected struct macvtap_queue *<noident>
    drivers/net/macvtap.c:98:9:    got struct macvtap_queue [noderef]
    <asn:4>*<noident>
    drivers/net/macvtap.c:120:9: warning: incorrect type in assignment (different
    address spaces)
    drivers/net/macvtap.c:120:9:    expected struct macvtap_queue *<noident>
    drivers/net/macvtap.c:120:9:    got struct macvtap_queue [noderef]
    <asn:4>*<noident>
    drivers/net/macvtap.c:151:22: error: incompatible types in comparison expression
    (different address spaces)
    drivers/net/macvtap.c:233:23: error: incompatible types in comparison expression
    (different address spaces)
    drivers/net/macvtap.c:243:23: error: incompatible types in comparison expression
    (different address spaces)
    drivers/net/macvtap.c:247:15: error: incompatible types in comparison expression
    (different address spaces)
      CC [M]  drivers/net/macvtap.o
    drivers/net/macvlan.c:232:24: error: incompatible types in comparison expression
    (different address spaces)
    
    Signed-off-by: Jason Wang <jasowang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 19121331a5ed..f49a9f66c3d9 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -70,7 +70,7 @@ struct macvlan_dev {
 	int (*receive)(struct sk_buff *skb);
 	int (*forward)(struct net_device *dev, struct sk_buff *skb);
 	/* This array tracks active taps. */
-	struct macvtap_queue	*taps[MAX_MACVTAP_QUEUES];
+	struct macvtap_queue	__rcu *taps[MAX_MACVTAP_QUEUES];
 	/* This list tracks all taps (both enabled and disabled) */
 	struct list_head	queue_list;
 	int			numvtaps;

commit 815f236d622721b54f3963ba59dad98b02cdeabf
Author: Jason Wang <jasowang@redhat.com>
Date:   Wed Jun 5 23:54:39 2013 +0000

    macvtap: add TUNSETQUEUE ioctl
    
    This patch adds TUNSETQUEUE ioctl to let userspace can temporarily disable or
    enable a queue of macvtap. This is used to be compatible at API layer of tuntap
    to simplify the userspace to manage the queues. This is done through introducing
    a linked list to track all taps while using vlan->taps array to only track
    active taps.
    
    Signed-off-by: Jason Wang <jasowang@redhat.com>
    Acked-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 62d8bda67874..19121331a5ed 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -69,8 +69,12 @@ struct macvlan_dev {
 	u16			flags;
 	int (*receive)(struct sk_buff *skb);
 	int (*forward)(struct net_device *dev, struct sk_buff *skb);
+	/* This array tracks active taps. */
 	struct macvtap_queue	*taps[MAX_MACVTAP_QUEUES];
+	/* This list tracks all taps (both enabled and disabled) */
+	struct list_head	queue_list;
 	int			numvtaps;
+	int			numqueues;
 	int			minor;
 };
 

commit f0afce01aa639e5164cf73f063b81a8b95619c3a
Author: Jason Wang <jasowang@redhat.com>
Date:   Wed Jun 5 23:54:37 2013 +0000

    macvlan: change the max number of queues to 16
    
    Macvtap should be at least compatible with tap, so change the max number to 16.
    
    Signed-off-by: Jason Wang <jasowang@redhat.com>
    Acked-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index e47ad46a477c..62d8bda67874 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -50,7 +50,7 @@ struct macvlan_pcpu_stats {
  * Maximum times a macvtap device can be opened. This can be used to
  * configure the number of receive queue, e.g. for multiqueue virtio.
  */
-#define MAX_MACVTAP_QUEUES	(NR_CPUS < 16 ? NR_CPUS : 16)
+#define MAX_MACVTAP_QUEUES	16
 
 #define MACVLAN_MC_FILTER_BITS	8
 #define MACVLAN_MC_FILTER_SZ	(1 << MACVLAN_MC_FILTER_BITS)

commit 1d2f41ed23343e083566339574807ca7ea75dbba
Author: Jason Wang <jasowang@redhat.com>
Date:   Wed Jun 5 23:54:35 2013 +0000

    macvlan: switch to use IS_ENABLED()
    
    Acked-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Jason Wang <jasowang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 84dde1dd1da4..e47ad46a477c 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -8,7 +8,7 @@
 #include <net/netlink.h>
 #include <linux/u64_stats_sync.h>
 
-#if defined(CONFIG_MACVTAP) || defined(CONFIG_MACVTAP_MODULE)
+#if IS_ENABLED(CONFIG_MACVTAP)
 struct socket *macvtap_get_socket(struct file *);
 #else
 #include <linux/err.h>

commit cd431e738509e74726055390c9e5e81e8e7e03ec
Author: Eric Dumazet <edumazet@google.com>
Date:   Tue Feb 5 20:22:50 2013 +0000

    macvlan: add multicast filter
    
    Setting up IPv6 addresses on configurations with many macvlans
    is not really working, as many multicast messages are dropped.
    
    Add a multicast filter to macvlan to reduce the amount of cloned
    skbs and overhead.
    
    Successfully tested with 1024 macvlans on one ethernet device.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ben Greear <greearb@candelatech.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index f65e8d250f7e..84dde1dd1da4 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -52,6 +52,9 @@ struct macvlan_pcpu_stats {
  */
 #define MAX_MACVTAP_QUEUES	(NR_CPUS < 16 ? NR_CPUS : 16)
 
+#define MACVLAN_MC_FILTER_BITS	8
+#define MACVLAN_MC_FILTER_SZ	(1 << MACVLAN_MC_FILTER_BITS)
+
 struct macvlan_dev {
 	struct net_device	*dev;
 	struct list_head	list;
@@ -59,6 +62,9 @@ struct macvlan_dev {
 	struct macvlan_port	*port;
 	struct net_device	*lowerdev;
 	struct macvlan_pcpu_stats __percpu *pcpu_stats;
+
+	DECLARE_BITMAP(mc_filter, MACVLAN_MC_FILTER_SZ);
+
 	enum macvlan_mode	mode;
 	u16			flags;
 	int (*receive)(struct sk_buff *skb);

commit df8ef8f3aaa6692970a436204c4429210addb23a
Author: John Fastabend <john.r.fastabend@intel.com>
Date:   Sun Apr 15 06:44:37 2012 +0000

    macvlan: add FDB bridge ops and macvlan flags
    
    This adds FDB bridge ops to the macvlan device passthru mode.
    Additionally a flags field was added and a NOPROMISC bit to
    allow users to use passthru mode without the driver calling
    dev_set_promiscuity(). The flags field is a u16 placed in a
    4 byte hole (consuming 2 bytes) of the macvlan_dev struct.
    
    We want to do this so that the macvlan driver or stack
    above the macvlan driver does not have to process every
    packet. For the use case where we know all the MAC addresses
    of the endstations above us this works well.
    
    This patch is a result of Roopa Prabhu's work. Follow up
    patches are needed for VEPA and VEB macvlan modes.
    
    v2: Change from distinct nopromisc mode to a flags field to
        configure this. This avoids the tendency to add a new
        mode every time we need some slightly different behavior.
    v3: fix error in dev_set_promiscuity and add change and get
        link attributes for flags.
    
    CC: Roopa Prabhu <roprabhu@cisco.com>
    CC: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: John Fastabend <john.r.fastabend@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index d103dca5c563..f65e8d250f7e 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -60,6 +60,7 @@ struct macvlan_dev {
 	struct net_device	*lowerdev;
 	struct macvlan_pcpu_stats __percpu *pcpu_stats;
 	enum macvlan_mode	mode;
+	u16			flags;
 	int (*receive)(struct sk_buff *skb);
 	int (*forward)(struct net_device *dev, struct sk_buff *skb);
 	struct macvtap_queue	*taps[MAX_MACVTAP_QUEUES];

commit e09eff7fc1c6f011f7bdb304e10d2ceef08c88ab
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Oct 20 04:29:24 2011 +0000

    macvtap: Fix the minor device number allocation
    
    On systems that create and delete lots of dynamic devices the
    31bit linux ifindex fails to fit in the 16bit macvtap minor,
    resulting in unusable macvtap devices.  I have systems running
    automated tests that that hit this condition in just a few days.
    
    Use a linux idr allocator to track which mavtap minor numbers
    are available and and to track the association between macvtap
    minor numbers and macvtap network devices.
    
    Remove the unnecessary unneccessary check to see if the network
    device we have found is indeed a macvtap device.  With macvtap
    specific data structures it is impossible to find any other
    kind of networking device.
    
    Increase the macvtap minor range from 65536 to the full 20 bits
    that is supported by linux device numbers.  It doesn't solve the
    original problem but there is no penalty for a larger minor
    device range.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index e28b2e4959d4..d103dca5c563 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -64,6 +64,7 @@ struct macvlan_dev {
 	int (*forward)(struct net_device *dev, struct sk_buff *skb);
 	struct macvtap_queue	*taps[MAX_MACVTAP_QUEUES];
 	int			numvtaps;
+	int			minor;
 };
 
 static inline void macvlan_count_rx(const struct macvlan_dev *vlan,

commit 8ffab51b3dfc54876f145f15b351c41f3f703195
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Wed Nov 10 21:14:04 2010 +0000

    macvlan: lockless tx path
    
    macvlan is a stacked device, like tunnels. We should use the lockless
    mechanism we are using in tunnels and loopback.
    
    This patch completely removes locking in TX path.
    
    tx stat counters are added into existing percpu stat structure, renamed
    from rx_stats to pcpu_stats.
    
    Note : this reverts commit 2c11455321f37 (macvlan: add multiqueue
    capability)
    
    Note : rx_errors converted to a 32bit counter, like tx_dropped, since
    they dont need 64bit range.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Patrick McHardy <kaber@trash.net>
    Cc: Ben Greear <greearb@candelatech.com>
    Cc: Ben Hutchings <bhutchings@solarflare.com>
    Acked-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index ac96a2d76291..e28b2e4959d4 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -25,19 +25,25 @@ struct macvlan_port;
 struct macvtap_queue;
 
 /**
- *	struct macvlan_rx_stats - MACVLAN percpu rx stats
+ *	struct macvlan_pcpu_stats - MACVLAN percpu stats
  *	@rx_packets: number of received packets
  *	@rx_bytes: number of received bytes
  *	@rx_multicast: number of received multicast packets
+ *	@tx_packets: number of transmitted packets
+ *	@tx_bytes: number of transmitted bytes
  *	@syncp: synchronization point for 64bit counters
- *	@rx_errors: number of errors
+ *	@rx_errors: number of rx errors
+ *	@tx_dropped: number of tx dropped packets
  */
-struct macvlan_rx_stats {
+struct macvlan_pcpu_stats {
 	u64			rx_packets;
 	u64			rx_bytes;
 	u64			rx_multicast;
+	u64			tx_packets;
+	u64			tx_bytes;
 	struct u64_stats_sync	syncp;
-	unsigned long		rx_errors;
+	u32			rx_errors;
+	u32			tx_dropped;
 };
 
 /*
@@ -52,7 +58,7 @@ struct macvlan_dev {
 	struct hlist_node	hlist;
 	struct macvlan_port	*port;
 	struct net_device	*lowerdev;
-	struct macvlan_rx_stats __percpu *rx_stats;
+	struct macvlan_pcpu_stats __percpu *pcpu_stats;
 	enum macvlan_mode	mode;
 	int (*receive)(struct sk_buff *skb);
 	int (*forward)(struct net_device *dev, struct sk_buff *skb);
@@ -64,18 +70,18 @@ static inline void macvlan_count_rx(const struct macvlan_dev *vlan,
 				    unsigned int len, bool success,
 				    bool multicast)
 {
-	struct macvlan_rx_stats *rx_stats;
-
-	rx_stats = this_cpu_ptr(vlan->rx_stats);
 	if (likely(success)) {
-		u64_stats_update_begin(&rx_stats->syncp);
-		rx_stats->rx_packets++;
-		rx_stats->rx_bytes += len;
+		struct macvlan_pcpu_stats *pcpu_stats;
+
+		pcpu_stats = this_cpu_ptr(vlan->pcpu_stats);
+		u64_stats_update_begin(&pcpu_stats->syncp);
+		pcpu_stats->rx_packets++;
+		pcpu_stats->rx_bytes += len;
 		if (multicast)
-			rx_stats->rx_multicast++;
-		u64_stats_update_end(&rx_stats->syncp);
+			pcpu_stats->rx_multicast++;
+		u64_stats_update_end(&pcpu_stats->syncp);
 	} else {
-		rx_stats->rx_errors++;
+		this_cpu_inc(vlan->pcpu_stats->rx_errors);
 	}
 }
 

commit c59504ebc5baa628706d10c2d3c7e1f4bc3c2147
Author: Joe Perches <joe@perches.com>
Date:   Sun Nov 14 17:04:57 2010 +0000

    include/linux/if_macvlan.h: Remove unnecessary semicolons
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 8a2fd66a8b5f..ac96a2d76291 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -69,7 +69,7 @@ static inline void macvlan_count_rx(const struct macvlan_dev *vlan,
 	rx_stats = this_cpu_ptr(vlan->rx_stats);
 	if (likely(success)) {
 		u64_stats_update_begin(&rx_stats->syncp);
-		rx_stats->rx_packets++;;
+		rx_stats->rx_packets++;
 		rx_stats->rx_bytes += len;
 		if (multicast)
 			rx_stats->rx_multicast++;

commit 1565c7c1c4c8e931bdba66abc8aa6f141a406872
Author: Krishna Kumar <krkumar2@in.ibm.com>
Date:   Wed Aug 4 06:15:59 2010 +0000

    macvtap: Implement multiqueue for macvtap driver
    
    Implement multiqueue facility for macvtap driver. The idea is that
    a macvtap device can be opened multiple times and the fd's can be
    used to register eg, as backend for vhost.
    
    Signed-off-by: Krishna Kumar <krkumar2@in.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 35280b302290..8a2fd66a8b5f 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -40,6 +40,12 @@ struct macvlan_rx_stats {
 	unsigned long		rx_errors;
 };
 
+/*
+ * Maximum times a macvtap device can be opened. This can be used to
+ * configure the number of receive queue, e.g. for multiqueue virtio.
+ */
+#define MAX_MACVTAP_QUEUES	(NR_CPUS < 16 ? NR_CPUS : 16)
+
 struct macvlan_dev {
 	struct net_device	*dev;
 	struct list_head	list;
@@ -50,7 +56,8 @@ struct macvlan_dev {
 	enum macvlan_mode	mode;
 	int (*receive)(struct sk_buff *skb);
 	int (*forward)(struct net_device *dev, struct sk_buff *skb);
-	struct macvtap_queue	*tap;
+	struct macvtap_queue	*taps[MAX_MACVTAP_QUEUES];
+	int			numvtaps;
 };
 
 static inline void macvlan_count_rx(const struct macvlan_dev *vlan,

commit bb7e95c8fd859922c6cf3ebbb3a8546007df1748
Merge: b8bc0421ab7f 5447080cfa3c
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jul 27 21:01:35 2010 -0700

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
            drivers/net/bnx2x_main.c
    
    Merge bnx2x bug fixes in by hand... :-/
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 8a35747a5d13b99e076b0222729e0caa48cb69b6
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Wed Jul 21 21:44:31 2010 +0000

    macvtap: Limit packet queue length
    
    Mark Wagner reported OOM symptoms when sending UDP traffic over
    a macvtap link to a kvm receiver.
    
    This appears to be caused by the fact that macvtap packet queues
    are unlimited in length.  This means that if the receiver can't
    keep up with the rate of flow, then we will hit OOM. Of course
    it gets worse if the OOM killer then decides to kill the receiver.
    
    This patch imposes a cap on the packet queue length, in the same
    way as the tuntap driver, using the device TX queue length.
    
    Please note that macvtap currently has no way of giving congestion
    notification, that means the software device TX queue cannot be
    used and packets will always be dropped once the macvtap driver
    queue fills up.
    
    This shouldn't be a great problem for the scenario where macvtap
    is used to feed a kvm receiver, as the traffic is most likely
    external in origin so congestion notification can't be applied
    anyway.
    
    Of course, if anybody decides to complain about guest-to-guest
    UDP packet loss down the track, then we may have to revisit this.
    
    Incidentally, this patch also fixes a real memory leak when
    macvtap_get_queue fails.
    
    Chris Wright noticed that for this patch to work, we need a
    non-zero TX queue length.  This patch includes his work to change
    the default macvtap TX queue length to 500.
    
    Reported-by: Mark Wagner <mwagner@redhat.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Acked-by: Chris Wright <chrisw@sous-sol.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 9ea047aca795..1ffaeffeff74 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -67,6 +67,8 @@ static inline void macvlan_count_rx(const struct macvlan_dev *vlan,
 	}
 }
 
+extern void macvlan_common_setup(struct net_device *dev);
+
 extern int macvlan_common_newlink(struct net *src_net, struct net_device *dev,
 				  struct nlattr *tb[], struct nlattr *data[],
 				  int (*receive)(struct sk_buff *skb),

commit bc66154efe163a80f269d448572f7906756e9338
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Thu Jun 24 00:54:21 2010 +0000

    macvlan: 64 bit rx counters
    
    Use u64_stats_sync infrastructure to implement 64bit stats.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index c26a0e4f0ce8..e24ce6ea1fa3 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -6,6 +6,7 @@
 #include <linux/netdevice.h>
 #include <linux/netlink.h>
 #include <net/netlink.h>
+#include <linux/u64_stats_sync.h>
 
 #if defined(CONFIG_MACVTAP) || defined(CONFIG_MACVTAP_MODULE)
 struct socket *macvtap_get_socket(struct file *);
@@ -27,14 +28,16 @@ struct macvtap_queue;
  *	struct macvlan_rx_stats - MACVLAN percpu rx stats
  *	@rx_packets: number of received packets
  *	@rx_bytes: number of received bytes
- *	@multicast: number of received multicast packets
+ *	@rx_multicast: number of received multicast packets
+ *	@syncp: synchronization point for 64bit counters
  *	@rx_errors: number of errors
  */
 struct macvlan_rx_stats {
-	unsigned long rx_packets;
-	unsigned long rx_bytes;
-	unsigned long multicast;
-	unsigned long rx_errors;
+	u64			rx_packets;
+	u64			rx_bytes;
+	u64			rx_multicast;
+	struct u64_stats_sync	syncp;
+	unsigned long		rx_errors;
 };
 
 struct macvlan_dev {
@@ -56,12 +59,14 @@ static inline void macvlan_count_rx(const struct macvlan_dev *vlan,
 {
 	struct macvlan_rx_stats *rx_stats;
 
-	rx_stats = per_cpu_ptr(vlan->rx_stats, smp_processor_id());
+	rx_stats = this_cpu_ptr(vlan->rx_stats);
 	if (likely(success)) {
+		u64_stats_update_begin(&rx_stats->syncp);
 		rx_stats->rx_packets++;;
 		rx_stats->rx_bytes += len;
 		if (multicast)
-			rx_stats->multicast++;
+			rx_stats->rx_multicast++;
+		u64_stats_update_end(&rx_stats->syncp);
 	} else {
 		rx_stats->rx_errors++;
 	}

commit ab95bfe01f9872459c8678572ccadbf646badad0
Author: Jiri Pirko <jpirko@redhat.com>
Date:   Tue Jun 1 21:52:08 2010 +0000

    net: replace hooks in __netif_receive_skb V5
    
    What this patch does is it removes two receive frame hooks (for bridge and for
    macvlan) from __netif_receive_skb. These are replaced them with a single
    hook for both. It only supports one hook per device because it makes no
    sense to do bridging and macvlan on the same device.
    
    Then a network driver (of virtual netdev like macvlan or bridge) can register
    an rx_handler for needed net device.
    
    Signed-off-by: Jiri Pirko <jpirko@redhat.com>
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 9ea047aca795..c26a0e4f0ce8 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -84,8 +84,4 @@ extern int macvlan_link_register(struct rtnl_link_ops *ops);
 extern netdev_tx_t macvlan_start_xmit(struct sk_buff *skb,
 				      struct net_device *dev);
 
-
-extern struct sk_buff *(*macvlan_handle_frame_hook)(struct macvlan_port *,
-						    struct sk_buff *);
-
 #endif /* _LINUX_IF_MACVLAN_H */

commit a14462f1bd4d3962994f518459102000438665aa
Author: Jiri Pirko <jpirko@redhat.com>
Date:   Thu May 6 01:33:53 2010 +0000

    net: adjust handle_macvlan to pass port struct to hook
    
    Now there's null check here and also again in the hook. Looking at bridge bits
    which are simmilar, port structure is rcu_dereferenced right away in
    handle_bridge and passed to hook. Looks nicer.
    
    Signed-off-by: Jiri Pirko <jpirko@redhat.com>
    Acked-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index b78a712247da..9ea047aca795 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -85,6 +85,7 @@ extern netdev_tx_t macvlan_start_xmit(struct sk_buff *skb,
 				      struct net_device *dev);
 
 
-extern struct sk_buff *(*macvlan_handle_frame_hook)(struct sk_buff *);
+extern struct sk_buff *(*macvlan_handle_frame_hook)(struct macvlan_port *,
+						    struct sk_buff *);
 
 #endif /* _LINUX_IF_MACVLAN_H */

commit 501c774cb13c3ef8fb7fc5f08fa19473f7d9a0db
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Feb 18 05:46:50 2010 +0000

    net/macvtap: add vhost support
    
    This adds support for passing a macvtap file descriptor into
    vhost-net, much like we already do for tun/tap.
    
    Most of the new code is taken from the respective patch
    in the tun driver and may get consolidated in the future.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index f9cb9ba1475d..b78a712247da 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -7,6 +7,19 @@
 #include <linux/netlink.h>
 #include <net/netlink.h>
 
+#if defined(CONFIG_MACVTAP) || defined(CONFIG_MACVTAP_MODULE)
+struct socket *macvtap_get_socket(struct file *);
+#else
+#include <linux/err.h>
+#include <linux/errno.h>
+struct file;
+struct socket;
+static inline struct socket *macvtap_get_socket(struct file *f)
+{
+	return ERR_PTR(-EINVAL);
+}
+#endif /* CONFIG_MACVTAP */
+
 struct macvlan_port;
 struct macvtap_queue;
 

commit 47d742752df4c1088589d4424840bc761613ab2a
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Feb 16 15:21:08 2010 +0000

    percpu: add __percpu sparse annotations to net drivers
    
    Add __percpu sparse annotations to net drivers.
    
    These annotations are to make sparse consider percpu variables to be
    in a different address space and warn if accessed without going
    through percpu accessors.  This patch doesn't affect normal builds.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: David S. Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 51f1512045e9..f9cb9ba1475d 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -30,7 +30,7 @@ struct macvlan_dev {
 	struct hlist_node	hlist;
 	struct macvlan_port	*port;
 	struct net_device	*lowerdev;
-	struct macvlan_rx_stats *rx_stats;
+	struct macvlan_rx_stats __percpu *rx_stats;
 	enum macvlan_mode	mode;
 	int (*receive)(struct sk_buff *skb);
 	int (*forward)(struct net_device *dev, struct sk_buff *skb);

commit 20d29d7a916a47bf533b5709437fe735b6b5b79e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Jan 30 12:24:26 2010 +0000

    net: macvtap driver
    
    In order to use macvlan with qemu and other tools that require
    a tap file descriptor, the macvtap driver adds a small backend
    with a character device with the same interface as the tun
    driver, with a minimum set of features.
    
    Macvtap interfaces are created in the same way as macvlan
    interfaces using ip link, but the netif is just used as a
    handle for configuration and accounting, while the data
    goes through the chardev. Each macvtap interface has its
    own character device, simplifying permission management
    significantly over the generic tun/tap driver.
    
    Cc: Patrick McHardy <kaber@trash.net>
    Cc: Stephen Hemminger <shemminger@linux-foundation.org>
    Cc: David S. Miller" <davem@davemloft.net>
    Cc: "Michael S. Tsirkin" <mst@redhat.com>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Or Gerlitz <ogerlitz@voltaire.com>
    Cc: netdev@vger.kernel.org
    Cc: bridge@lists.linux-foundation.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 9a11544bb0b1..51f1512045e9 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -34,6 +34,7 @@ struct macvlan_dev {
 	enum macvlan_mode	mode;
 	int (*receive)(struct sk_buff *skb);
 	int (*forward)(struct net_device *dev, struct sk_buff *skb);
+	struct macvtap_queue	*tap;
 };
 
 static inline void macvlan_count_rx(const struct macvlan_dev *vlan,

commit fc0663d6b5e6d8e9b57f872a644c0aafd82361b7
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Jan 30 12:23:40 2010 +0000

    macvlan: allow multiple driver backends
    
    This makes it possible to hook into the macvlan driver
    from another kernel module. In particular, the goal is
    to extend it with the macvtap backend that provides
    a tun/tap compatible interface directly on the macvlan
    device.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 5f200bac3749..9a11544bb0b1 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -1,6 +1,76 @@
 #ifndef _LINUX_IF_MACVLAN_H
 #define _LINUX_IF_MACVLAN_H
 
+#include <linux/if_link.h>
+#include <linux/list.h>
+#include <linux/netdevice.h>
+#include <linux/netlink.h>
+#include <net/netlink.h>
+
+struct macvlan_port;
+struct macvtap_queue;
+
+/**
+ *	struct macvlan_rx_stats - MACVLAN percpu rx stats
+ *	@rx_packets: number of received packets
+ *	@rx_bytes: number of received bytes
+ *	@multicast: number of received multicast packets
+ *	@rx_errors: number of errors
+ */
+struct macvlan_rx_stats {
+	unsigned long rx_packets;
+	unsigned long rx_bytes;
+	unsigned long multicast;
+	unsigned long rx_errors;
+};
+
+struct macvlan_dev {
+	struct net_device	*dev;
+	struct list_head	list;
+	struct hlist_node	hlist;
+	struct macvlan_port	*port;
+	struct net_device	*lowerdev;
+	struct macvlan_rx_stats *rx_stats;
+	enum macvlan_mode	mode;
+	int (*receive)(struct sk_buff *skb);
+	int (*forward)(struct net_device *dev, struct sk_buff *skb);
+};
+
+static inline void macvlan_count_rx(const struct macvlan_dev *vlan,
+				    unsigned int len, bool success,
+				    bool multicast)
+{
+	struct macvlan_rx_stats *rx_stats;
+
+	rx_stats = per_cpu_ptr(vlan->rx_stats, smp_processor_id());
+	if (likely(success)) {
+		rx_stats->rx_packets++;;
+		rx_stats->rx_bytes += len;
+		if (multicast)
+			rx_stats->multicast++;
+	} else {
+		rx_stats->rx_errors++;
+	}
+}
+
+extern int macvlan_common_newlink(struct net *src_net, struct net_device *dev,
+				  struct nlattr *tb[], struct nlattr *data[],
+				  int (*receive)(struct sk_buff *skb),
+				  int (*forward)(struct net_device *dev,
+						 struct sk_buff *skb));
+
+extern void macvlan_count_rx(const struct macvlan_dev *vlan,
+			     unsigned int len, bool success,
+			     bool multicast);
+
+extern void macvlan_dellink(struct net_device *dev, struct list_head *head);
+
+extern int macvlan_link_register(struct rtnl_link_ops *ops);
+
+extern netdev_tx_t macvlan_start_xmit(struct sk_buff *skb,
+				      struct net_device *dev);
+
+
 extern struct sk_buff *(*macvlan_handle_frame_hook)(struct sk_buff *);
 
 #endif /* _LINUX_IF_MACVLAN_H */

commit 735643ee6cc5249bfac07fcad0946a5e7aff4423
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Wed Apr 30 00:55:12 2008 -0700

    Remove "#ifdef __KERNEL__" checks from unexported headers
    
    Remove the "#ifdef __KERNEL__" tests from unexported header files in
    linux/include whose entire contents are wrapped in that preprocessor
    test.
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 0d9d7ea2c1cc..5f200bac3749 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -1,9 +1,6 @@
 #ifndef _LINUX_IF_MACVLAN_H
 #define _LINUX_IF_MACVLAN_H
 
-#ifdef __KERNEL__
-
 extern struct sk_buff *(*macvlan_handle_frame_hook)(struct sk_buff *);
 
-#endif /* __KERNEL__ */
 #endif /* _LINUX_IF_MACVLAN_H */

commit b863ceb7ddcea8c55fcf1d7b2ac591d50aa7ed53
Author: Patrick McHardy <kaber@trash.net>
Date:   Sat Jul 14 18:55:06 2007 -0700

    [NET]: Add macvlan driver
    
    Add macvlan driver, which allows to create virtual ethernet devices
    based on MAC address.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
new file mode 100644
index 000000000000..0d9d7ea2c1cc
--- /dev/null
+++ b/include/linux/if_macvlan.h
@@ -0,0 +1,9 @@
+#ifndef _LINUX_IF_MACVLAN_H
+#define _LINUX_IF_MACVLAN_H
+
+#ifdef __KERNEL__
+
+extern struct sk_buff *(*macvlan_handle_frame_hook)(struct sk_buff *);
+
+#endif /* __KERNEL__ */
+#endif /* _LINUX_IF_MACVLAN_H */
