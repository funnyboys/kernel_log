commit ad89c8852fde7ab0c4007f5b753517cf508d12be
Author: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
Date:   Tue Apr 14 18:48:44 2020 +0200

    docs: spi: spi.h: fix a doc building warning
    
    We need to add a blank line to avoid this warning:
    
            ./include/linux/spi/spi.h:401: WARNING: Unexpected indentation.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
    Link: https://lore.kernel.org/r/1c701b3ac903dc0bc304dca958fbdee53bd38dc3.1586881715.git.mchehab+huawei@kernel.org
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 38286de779e3..aac57b5b7c21 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -394,6 +394,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *                   for example doing DMA mapping.  Called from threaded
  *                   context.
  * @transfer_one: transfer a single spi_transfer.
+ *
  *                  - return 0 if the transfer is finished,
  *                  - return 1 if the transfer is still in progress. When
  *                    the driver is finished with this transfer it must

commit 7a86a419ff62c69f91544ea95f4ae6ef83880dcc
Author: Qiujun Huang <hqjagain@gmail.com>
Date:   Tue Mar 10 01:16:19 2020 +0800

    spi: update the structure documentation
    
    some members were not described in documentation.
    
    Signed-off-by: Qiujun Huang <hqjagain@gmail.com>
    Link: https://lore.kernel.org/r/1583774179-30736-1-git-send-email-hqjagain@gmail.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 87105272879b..38286de779e3 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -135,6 +135,8 @@ extern int spi_delay_exec(struct spi_delay *_delay, struct spi_transfer *xfer);
  * @modalias: Name of the driver to use with this device, or an alias
  *	for that name.  This appears in the sysfs "modalias" attribute
  *	for driver coldplugging, and in uevents used for hotplugging
+ * @driver_override: If the name of a driver is written to this attribute, then
+ *	the device will bind to the named driver and only the named driver.
  * @cs_gpio: LEGACY: gpio number of the chipselect line (optional, -ENOENT when
  *	not using a GPIO line) use cs_gpiod in new drivers by opting in on
  *	the spi_master.
@@ -443,6 +445,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *	@spi_transfer->ptp_sts_word_post were transmitted.
  *	If the driver does not set this, the SPI core takes the snapshot as
  *	close to the driver hand-over as possible.
+ * @irq_flags: Interrupt enable state during PTP system timestamping
  *
  * Each SPI controller can communicate with one or more @spi_device
  * children.  These make a small bus, sharing MOSI, MISO and SCK signals

commit 6a726824aaa3adaaf3bcfca3b471408e225f33d6
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Thu Mar 5 00:00:39 2020 +0200

    spi: Do spi_take_timestamp_pre for as many times as necessary
    
    When dealing with a SPI controller driver that is sending more than 1
    byte at once (or the entire buffer at once), and the SPI peripheral
    driver has requested timestamping for a byte in the middle of the
    buffer, we find that spi_take_timestamp_pre never records a "pre"
    timestamp.
    
    This happens because the function currently expects to be called with
    the "progress" argument >= to what the peripheral has requested to be
    timestamped. But clearly there are cases when that isn't going to fly.
    
    And since we can't change the past when we realize that the opportunity
    to take a "pre" timestamp has just passed and there isn't going to be
    another one, the approach taken is to keep recording the "pre" timestamp
    on each call, overwriting the previously recorded one until the "post"
    timestamp is also taken.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Link: https://lore.kernel.org/r/20200304220044.11193-8-olteanv@gmail.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 600e3793303e..87105272879b 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -933,8 +933,7 @@ struct spi_transfer {
 
 	struct ptp_system_timestamp *ptp_sts;
 
-	bool		timestamped_pre;
-	bool		timestamped_post;
+	bool		timestamped;
 
 	struct list_head transfer_list;
 };

commit ea23578611dce2eeaf31dcfe12cd7130cf3d1411
Author: John Garry <john.garry@huawei.com>
Date:   Fri Feb 28 23:18:49 2020 +0800

    spi: Allow SPI controller override device buswidth
    
    Currently ACPI firmware description for a SPI device does not have any
    method to describe the data buswidth on the board.
    
    So even through the controller and device may support higher modes than
    standard SPI, it cannot be assumed that the board does - as such, that
    device is limited to standard SPI in such a circumstance.
    
    As a workaround, allow the controller driver supply buswidth override bits,
    which are used inform the core code that the controller driver knows the
    buswidth supported on that board for that device.
    
    A host controller driver might know this info from DMI tables, for example.
    
    Signed-off-by: John Garry <john.garry@huawei.com>
    Link: https://lore.kernel.org/r/1582903131-160033-2-git-send-email-john.garry@huawei.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 6d16ba01ff5a..600e3793303e 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -481,6 +481,9 @@ struct spi_controller {
 	/* spi_device.mode flags understood by this controller driver */
 	u32			mode_bits;
 
+	/* spi_device.mode flags override flags for this controller */
+	u32			buswidth_override_bits;
+
 	/* bitmask of supported bits_per_word for transfers */
 	u32			bits_per_word_mask;
 #define SPI_BPW_MASK(bits) BIT((bits) - 1)

commit 754a36a58c29718bf5e28b8789b17bffbb60e8a6
Merge: 7265e8fc5108 a5362b84bdff
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Jan 23 12:37:18 2020 +0000

    Merge branch 'spi-5.6' into spi-next

commit 7d93aecdb58d47e8ed90b4a44c0fc9ffb8de941c
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Jan 2 14:38:17 2020 +0100

    spi: Add generic support for unused native cs with cs-gpios
    
    Some SPI master controllers always drive a native chip select when
    performing a transfer.  Hence when using both native and GPIO chip
    selects, at least one native chip select must be left unused, to be
    driven when performing transfers with slave devices using GPIO chip
    selects.
    
    Currently, to find an unused native chip select, SPI controller drivers
    need to parse and process cs-gpios theirselves.  This is not only
    duplicated in each driver that needs it, but also duplicates part of the
    work done later at SPI controller registration time.  Note that this
    cannot be done after spi_register_controller() returns, as at that time,
    slave devices may have been probed already.
    
    Hence add generic support to the SPI subsystem for finding an unused
    native chip select.  Optionally, this unused native chip select, and all
    other in-use native chip selects, can be validated against the maximum
    number of native chip selects available on the controller hardware.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Link: https://lore.kernel.org/r/20200102133822.29346-2-geert+renesas@glider.be
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 98fe8663033a..e4011b852fc3 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -423,6 +423,12 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *	GPIO descriptors rather than using global GPIO numbers grabbed by the
  *	driver. This will fill in @cs_gpiods and @cs_gpios should not be used,
  *	and SPI devices will have the cs_gpiod assigned rather than cs_gpio.
+ * @unused_native_cs: When cs_gpiods is used, spi_register_controller() will
+ *	fill in this field with the first unused native CS, to be used by SPI
+ *	controller drivers that need to drive a native CS when using GPIO CS.
+ * @max_native_cs: When cs_gpiods is used, and this field is filled in,
+ *	spi_register_controller() will validate all native CS (including the
+ *	unused native CS) against this value.
  * @statistics: statistics for the spi_controller
  * @dma_tx: DMA transmit channel
  * @dma_rx: DMA receive channel
@@ -624,6 +630,8 @@ struct spi_controller {
 	int			*cs_gpios;
 	struct gpio_desc	**cs_gpiods;
 	bool			use_gpio_descriptors;
+	u8			unused_native_cs;
+	u8			max_native_cs;
 
 	/* statistics */
 	struct spi_statistics	statistics;

commit 862dd2a946aa1417f013fb748e2aa0f4349b405b
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Fri Dec 27 03:24:17 2019 +0200

    spi: Don't look at TX buffer for PTP system timestamping
    
    The API for PTP system timestamping (associating a SPI transaction with
    the system time at which it was transferred) is flawed: it assumes that
    the xfer->tx_buf pointer will always be present.
    
    This is, of course, not always the case.
    
    So introduce a "progress" variable that denotes how many word have been
    transferred.
    
    Fix the Freescale DSPI driver, the only user of the API so far, in the
    same patch.
    
    Fixes: b42faeee718c ("spi: Add a PTP system timestamp to the transfer structure")
    Fixes: d6b71dfaeeba ("spi: spi-fsl-dspi: Implement the PTP system timestamping for TCFQ mode")
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Link: https://lore.kernel.org/r/20191227012417.1057-1-olteanv@gmail.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 98fe8663033a..3a67a7e45633 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -689,10 +689,10 @@ extern void spi_finalize_current_transfer(struct spi_controller *ctlr);
 /* Helper calls for driver to timestamp transfer */
 void spi_take_timestamp_pre(struct spi_controller *ctlr,
 			    struct spi_transfer *xfer,
-			    const void *tx, bool irqs_off);
+			    size_t progress, bool irqs_off);
 void spi_take_timestamp_post(struct spi_controller *ctlr,
 			     struct spi_transfer *xfer,
-			     const void *tx, bool irqs_off);
+			     size_t progress, bool irqs_off);
 
 /* the spi driver core manages memory for the spi_controller classdev */
 extern struct spi_controller *__spi_alloc_controller(struct device *host,

commit a3470c1829c0c856a19c10af58f8e7792ae27d7a
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Wed Oct 23 10:00:46 2019 +0300

    spi: document CS setup, hold & inactive times in header
    
    This change documents the CS setup, host & inactive times. They were
    omitted when the fields were added, and were caught by one of the build
    bots.
    
    Fixes: 25093bdeb6bc ("spi: implement SW control for CS times")
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20191023070046.12478-1-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index c40d6af2bf07..98fe8663033a 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -407,6 +407,11 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *	     controller has native support for memory like operations.
  * @unprepare_message: undo any work done by prepare_message().
  * @slave_abort: abort the ongoing transfer request on an SPI slave controller
+ * @cs_setup: delay to be introduced by the controller after CS is asserted
+ * @cs_hold: delay to be introduced by the controller before CS is deasserted
+ * @cs_inactive: delay to be introduced by the controller after CS is
+ *	deasserted. If @cs_change_delay is used from @spi_transfer, then the
+ *	two delays will be added up.
  * @cs_gpios: LEGACY: array of GPIO descs to use as chip select lines; one per
  *	CS number. Any individual value may be -ENOENT for CS lines that
  *	are not GPIOs (driven by the SPI controller itself). Use the cs_gpiods

commit 3984d39b0e41ac4de8b4530ae3911ccf52ed4bbf
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Sep 26 13:51:44 2019 +0300

    spi: spi-fsl-espi: convert transfer delay to `spi_delay` format
    
    The way the max delay is computed for this controller, it looks like it is
    searching for the max delay from an SPI message a using that.
    
    No idea if this is valid. But this change should support both `delay_usecs`
    and the new `delay` data which is of `spi_delay` type.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20190926105147.7839-17-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index cfd87b18f077..c40d6af2bf07 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -103,6 +103,7 @@ struct spi_delay {
 	u8	unit;
 };
 
+extern int spi_delay_to_ns(struct spi_delay *_delay, struct spi_transfer *xfer);
 extern int spi_delay_exec(struct spi_delay *_delay, struct spi_transfer *xfer);
 
 /**

commit 25093bdeb6bcae728e12e3795261dbd3677060a9
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Sep 26 13:51:43 2019 +0300

    spi: implement SW control for CS times
    
    This change implements CS control for setup, hold & inactive delays.
    
    The `cs_setup` delay is completely new, and can help with cases where
    asserting the CS, also brings the device out of power-sleep, where there
    needs to be a longer (than usual), before transferring data.
    
    The `cs_hold` time can overlap with the `delay` (or `delay_usecs`) from an
    SPI transfer. The main difference is that `cs_hold` implies that CS will be
    de-asserted.
    
    The `cs_inactive` delay does not have a clear use-case yet. It has been
    implemented mostly because the `spi_set_cs_timing()` function implements
    it. To some degree, this could overlap or replace `cs_change_delay`, but
    this will require more consideration/investigation in the future.
    
    All these delays have been added to the `spi_controller` struct, as they
    would typically be configured by calling `spi_set_cs_timing()` after an
    `spi_setup()` call.
    
    Software-mode for CS control, implies that the `set_cs_timing()` hook has
    not been provided for the `spi_controller` object.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20190926105147.7839-16-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index f9b4ba2db08d..cfd87b18f077 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -609,6 +609,11 @@ struct spi_controller {
 	/* Optimized handlers for SPI memory-like operations. */
 	const struct spi_controller_mem_ops *mem_ops;
 
+	/* CS delays */
+	struct spi_delay	cs_setup;
+	struct spi_delay	cs_hold;
+	struct spi_delay	cs_inactive;
+
 	/* gpio chip select */
 	int			*cs_gpios;
 	struct gpio_desc	**cs_gpiods;

commit 8105936684681195d9073880b06a123b2e316811
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Sep 26 13:51:42 2019 +0300

    spi: tegra114: change format for `spi_set_cs_timing()` function
    
    The initial version of `spi_set_cs_timing()` was implemented with
    consideration only for clock-cycles as delay.
    
    For cases like `CS setup` time, it's sometimes needed that micro-seconds
    (or nano-seconds) are required, or sometimes even longer delays, for cases
    where the device needs a little longer to start transferring that after CS
    is asserted.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20190926105147.7839-15-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index fe5b85df2c79..f9b4ba2db08d 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -524,8 +524,8 @@ struct spi_controller {
 	 * to configure specific CS timing through spi_set_cs_timing() after
 	 * spi_setup().
 	 */
-	void (*set_cs_timing)(struct spi_device *spi, u8 setup_clk_cycles,
-			      u8 hold_clk_cycles, u8 inactive_clk_cycles);
+	int (*set_cs_timing)(struct spi_device *spi, struct spi_delay *setup,
+			     struct spi_delay *hold, struct spi_delay *inactive);
 
 	/* bidirectional bulk transfers
 	 *
@@ -1068,7 +1068,10 @@ static inline void spi_message_free(struct spi_message *m)
 	kfree(m);
 }
 
-extern void spi_set_cs_timing(struct spi_device *spi, u8 setup, u8 hold, u8 inactive_dly);
+extern int spi_set_cs_timing(struct spi_device *spi,
+			     struct spi_delay *setup,
+			     struct spi_delay *hold,
+			     struct spi_delay *inactive);
 
 extern int spi_setup(struct spi_device *spi);
 extern int spi_async(struct spi_device *spi, struct spi_message *message);

commit bebcfd272df648542c458d28fbd6a8f9428b5310
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Sep 26 13:51:36 2019 +0300

    spi: introduce `delay` field for `spi_transfer` + spi_transfer_delay_exec()
    
    The change introduces the `delay` field to the `spi_transfer` struct as an
    `struct spi_delay` type.
    This intends to eventually replace `delay_usecs`.
    
    But, since there are many users of `delay_usecs`, this needs some
    intermediate work.
    A helper called `spi_transfer_delay_exec()` is also added, which maintains
    backwards compatibility with `delay_usecs`, by assigning the value to
    `delay` if non-zero.
    This should maintain backwards compatibility with current users of
    `udelay_usecs`.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20190926105147.7839-9-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index ebeb272aeb0f..fe5b85df2c79 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -778,6 +778,9 @@ extern void spi_res_release(struct spi_controller *ctlr,
  * @cs_change: affects chipselect after this transfer completes
  * @cs_change_delay: delay between cs deassert and assert when
  *      @cs_change is set and @spi_transfer is not the last in @spi_message
+ * @delay: delay to be introduced after this transfer before
+ *	(optionally) changing the chipselect status, then starting
+ *	the next transfer or completing this @spi_message.
  * @delay_usecs: microseconds to delay after this transfer before
  *	(optionally) changing the chipselect status, then starting
  *	the next transfer or completing this @spi_message.
@@ -896,6 +899,7 @@ struct spi_transfer {
 #define	SPI_NBITS_QUAD		0x04 /* 4bits transfer */
 	u8		bits_per_word;
 	u16		delay_usecs;
+	struct spi_delay	delay;
 	struct spi_delay	cs_change_delay;
 	struct spi_delay	word_delay;
 	u32		speed_hz;
@@ -1003,6 +1007,20 @@ spi_transfer_del(struct spi_transfer *t)
 	list_del(&t->transfer_list);
 }
 
+static inline int
+spi_transfer_delay_exec(struct spi_transfer *t)
+{
+	struct spi_delay d;
+
+	if (t->delay_usecs) {
+		d.value = t->delay_usecs;
+		d.unit = SPI_DELAY_UNIT_USECS;
+		return spi_delay_exec(&d, NULL);
+	}
+
+	return spi_delay_exec(&t->delay, t);
+}
+
 /**
  * spi_message_init_with_transfers - Initialize spi_message and append transfers
  * @m: spi_message to be initialized

commit 6c613f68aabf33385c01e949204ac5ed30887161
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Sep 26 13:51:35 2019 +0300

    spi: core,atmel: convert `word_delay_usecs` -> `word_delay` for spi_device
    
    This change does a conversion from the `word_delay_usecs` -> `word_delay`
    for the `spi_device` struct.
    
    This allows users to specify inter-word delays in other unit types
    (nano-seconds or clock cycles), depending on how users want.
    
    The Atmel SPI driver is the only current user of the `word_delay_usecs`
    field (from the `spi_device` struct).
    So, it needed a slight conversion to use the `word_delay` as an `spi_delay`
    struct.
    
    In SPI core, the only required mechanism is to update the `word_delay`
    information per `spi_transfer`. This requires a bit more logic than before,
    because it needs that both delays be converted to a common unit
    (nano-seconds) for comparison.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20190926105147.7839-8-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 6cb67ad53ffa..ebeb272aeb0f 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -139,7 +139,7 @@ extern int spi_delay_exec(struct spi_delay *_delay, struct spi_transfer *xfer);
  *	the spi_master.
  * @cs_gpiod: gpio descriptor of the chipselect line (optional, NULL when
  *	not using a GPIO line)
- * @word_delay_usecs: microsecond delay to be inserted between consecutive
+ * @word_delay: delay to be inserted between consecutive
  *	words of a transfer
  *
  * @statistics: statistics for the spi_device
@@ -189,7 +189,7 @@ struct spi_device {
 	const char		*driver_override;
 	int			cs_gpio;	/* LEGACY: chip select gpio */
 	struct gpio_desc	*cs_gpiod;	/* chip select gpio desc */
-	uint8_t			word_delay_usecs; /* inter-word delay */
+	struct spi_delay	word_delay; /* inter-word delay */
 
 	/* the statistics */
 	struct spi_statistics	statistics;
@@ -781,8 +781,6 @@ extern void spi_res_release(struct spi_controller *ctlr,
  * @delay_usecs: microseconds to delay after this transfer before
  *	(optionally) changing the chipselect status, then starting
  *	the next transfer or completing this @spi_message.
- * @word_delay_usecs: microseconds to inter word delay after each word size
- *	(set by bits_per_word) transmission.
  * @word_delay: inter word delay to be introduced after each word size
  *	(set by bits_per_word) transmission.
  * @effective_speed_hz: the effective SCK-speed that was used to
@@ -897,7 +895,6 @@ struct spi_transfer {
 #define	SPI_NBITS_DUAL		0x02 /* 2bits transfer */
 #define	SPI_NBITS_QUAD		0x04 /* 4bits transfer */
 	u8		bits_per_word;
-	u8		word_delay_usecs;
 	u16		delay_usecs;
 	struct spi_delay	cs_change_delay;
 	struct spi_delay	word_delay;

commit 84593a131c3af21d686d05c4b4432290a415d399
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Sep 26 13:51:32 2019 +0300

    spi: sprd: convert transfer word delay to spi_delay struct
    
    The Spreadtrum SPI driver is the only user of the `word_delay` field in
    the `spi_transfer` struct.
    
    This change converts the field to use the `spi_delay` struct. This also
    enforces the users to specify the delay unit to be `SPI_DELAY_UNIT_SCK`.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20190926105147.7839-5-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 7670be934643..6cb67ad53ffa 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -783,7 +783,7 @@ extern void spi_res_release(struct spi_controller *ctlr,
  *	the next transfer or completing this @spi_message.
  * @word_delay_usecs: microseconds to inter word delay after each word size
  *	(set by bits_per_word) transmission.
- * @word_delay: clock cycles to inter word delay after each word size
+ * @word_delay: inter word delay to be introduced after each word size
  *	(set by bits_per_word) transmission.
  * @effective_speed_hz: the effective SCK-speed that was used to
  *      transfer this transfer. Set to 0 if the spi bus driver does
@@ -900,8 +900,8 @@ struct spi_transfer {
 	u8		word_delay_usecs;
 	u16		delay_usecs;
 	struct spi_delay	cs_change_delay;
+	struct spi_delay	word_delay;
 	u32		speed_hz;
-	u16		word_delay;
 
 	u32		effective_speed_hz;
 

commit 329f0dac4cad9fa4b1439a88180d91bcb5c4eaf8
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Sep 26 13:51:31 2019 +0300

    spi: make `cs_change_delay` the first user of the `spi_delay` logic
    
    Since the logic for `spi_delay` struct + `spi_delay_exec()` has been copied
    from the `cs_change_delay` logic, it's natural to make this delay, the
    first user.
    
    The `cs_change_delay` logic requires that the default remain 10 uS, in case
    it is unspecified/unconfigured. So, there is some special handling needed
    to do that.
    
    The ADIS library is one of the few users of the new `cs_change_delay`
    parameter for an spi_transfer.
    
    The introduction of the `spi_delay` struct, requires that the users of of
    `cs_change_delay` get an update. This change also updates the ADIS library.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20190926105147.7839-4-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 8f643de3197b..7670be934643 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -778,7 +778,6 @@ extern void spi_res_release(struct spi_controller *ctlr,
  * @cs_change: affects chipselect after this transfer completes
  * @cs_change_delay: delay between cs deassert and assert when
  *      @cs_change is set and @spi_transfer is not the last in @spi_message
- * @cs_change_delay_unit: unit of cs_change_delay
  * @delay_usecs: microseconds to delay after this transfer before
  *	(optionally) changing the chipselect status, then starting
  *	the next transfer or completing this @spi_message.
@@ -900,8 +899,7 @@ struct spi_transfer {
 	u8		bits_per_word;
 	u8		word_delay_usecs;
 	u16		delay_usecs;
-	u16		cs_change_delay;
-	u8		cs_change_delay_unit;
+	struct spi_delay	cs_change_delay;
 	u32		speed_hz;
 	u16		word_delay;
 

commit b2c98153f45fc17b9fcb241000f2d131ddea6030
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Sep 26 13:51:30 2019 +0300

    spi: introduce spi_delay struct as "value + unit" & spi_delay_exec()
    
    There are plenty of delays that have been introduced in SPI core. Most of
    them are in micro-seconds, some need to be in nano-seconds, and some in
    clock-cycles.
    
    For some of these delays (related to transfers & CS timing) it may make
    sense to have a `spi_delay` struct that abstracts these a bit.
    
    The important element of these delays [for unification] seems to be the
    `unit` of the delay.
    It looks like micro-seconds is good enough for most people, but every-once
    in a while, some delays seem to require other units of measurement.
    
    This change adds the `spi_delay` struct & a `spi_delay_exec()` function
    that processes a `spi_delay` object/struct to execute the delay.
    It's a copy of the `cs_change_delay` mechanism, but without the default
    for 10 uS.
    
    The clock-cycle delay unit is a bit special, as it needs to be bound to an
    `spi_transfer` object to execute.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20190926105147.7839-3-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 27f6b046cf92..8f643de3197b 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -90,6 +90,21 @@ void spi_statistics_add_transfer_stats(struct spi_statistics *stats,
 #define SPI_STATISTICS_INCREMENT_FIELD(stats, field)	\
 	SPI_STATISTICS_ADD_TO_FIELD(stats, field, 1)
 
+/**
+ * struct spi_delay - SPI delay information
+ * @value: Value for the delay
+ * @unit: Unit for the delay
+ */
+struct spi_delay {
+#define SPI_DELAY_UNIT_USECS	0
+#define SPI_DELAY_UNIT_NSECS	1
+#define SPI_DELAY_UNIT_SCK	2
+	u16	value;
+	u8	unit;
+};
+
+extern int spi_delay_exec(struct spi_delay *_delay, struct spi_transfer *xfer);
+
 /**
  * struct spi_device - Controller side proxy for an SPI slave device
  * @dev: Driver model representation of the device.
@@ -887,9 +902,6 @@ struct spi_transfer {
 	u16		delay_usecs;
 	u16		cs_change_delay;
 	u8		cs_change_delay_unit;
-#define SPI_DELAY_UNIT_USECS	0
-#define SPI_DELAY_UNIT_NSECS	1
-#define SPI_DELAY_UNIT_SCK	2
 	u32		speed_hz;
 	u16		word_delay;
 

commit b42faeee718ce13ef6eb99c24880b58deb54c8fa
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Thu Sep 5 04:01:12 2019 +0300

    spi: Add a PTP system timestamp to the transfer structure
    
    SPI is one of the interfaces used to access devices which have a POSIX
    clock driver (real time clocks, 1588 timers etc). The fact that the SPI
    bus is slow is not what the main problem is, but rather the fact that
    drivers don't take a constant amount of time in transferring data over
    SPI. When there is a high delay in the readout of time, there will be
    uncertainty in the value that has been read out of the peripheral.
    When that delay is constant, the uncertainty can at least be
    approximated with a certain accuracy which is fine more often than not.
    
    Timing jitter occurs all over in the kernel code, and is mainly caused
    by having to let go of the CPU for various reasons such as preemption,
    servicing interrupts, going to sleep, etc. Another major reason is CPU
    dynamic frequency scaling.
    
    It turns out that the problem of retrieving time from a SPI peripheral
    with high accuracy can be solved by the use of "PTP system
    timestamping" - a mechanism to correlate the time when the device has
    snapshotted its internal time counter with the Linux system time at that
    same moment. This is sufficient for having a precise time measurement -
    it is not necessary for the whole SPI transfer to be transmitted "as
    fast as possible", or "as low-jitter as possible". The system has to be
    low-jitter for a very short amount of time to be effective.
    
    This patch introduces a PTP system timestamping mechanism in struct
    spi_transfer. This is to be used by SPI device drivers when they need to
    know the exact time at which the underlying device's time was
    snapshotted. More often than not, SPI peripherals have a very exact
    timing for when their SPI-to-interconnect bridge issues a transaction
    for snapshotting and reading the time register, and that will be
    dependent on when the SPI-to-interconnect bridge figures out that this
    is what it should do, aka as soon as it sees byte N of the SPI transfer.
    Since spi_device drivers are the ones who'd know best how the peripheral
    behaves in this regard, expose a mechanism in spi_transfer which allows
    them to specify which word (or word range) from the transfer should be
    timestamped.
    
    Add a default implementation of the PTP system timestamping in the SPI
    core. This is not going to be satisfactory performance-wise, but should
    at least increase the likelihood that SPI device drivers will use PTP
    system timestamping in the future.
    There are 3 entry points from the core towards the SPI controller
    drivers:
    
    - transfer_one: The driver is passed individual spi_transfers to
      execute. This is the easiest to timestamp.
    
    - transfer_one_message: The core passes the driver an entire spi_message
      (a potential batch of spi_transfers). The core puts the same pre and
      post timestamp to all transfers within a message. This is not ideal,
      but nothing better can be done by default anyway, since the core has
      no insight into how the driver batches the transfers.
    
    - transfer: Like transfer_one_message, but for unqueued drivers (i.e.
      the driver implements its own queue scheduling).
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Link: https://lore.kernel.org/r/20190905010114.26718-3-olteanv@gmail.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index af4f265d0f67..27f6b046cf92 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -13,6 +13,7 @@
 #include <linux/completion.h>
 #include <linux/scatterlist.h>
 #include <linux/gpio/consumer.h>
+#include <linux/ptp_clock_kernel.h>
 
 struct dma_chan;
 struct property_entry;
@@ -409,6 +410,12 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @fw_translate_cs: If the boot firmware uses different numbering scheme
  *	what Linux expects, this optional hook can be used to translate
  *	between the two.
+ * @ptp_sts_supported: If the driver sets this to true, it must provide a
+ *	time snapshot in @spi_transfer->ptp_sts as close as possible to the
+ *	moment in time when @spi_transfer->ptp_sts_word_pre and
+ *	@spi_transfer->ptp_sts_word_post were transmitted.
+ *	If the driver does not set this, the SPI core takes the snapshot as
+ *	close to the driver hand-over as possible.
  *
  * Each SPI controller can communicate with one or more @spi_device
  * children.  These make a small bus, sharing MOSI, MISO and SCK signals
@@ -604,6 +611,15 @@ struct spi_controller {
 	void			*dummy_tx;
 
 	int (*fw_translate_cs)(struct spi_controller *ctlr, unsigned cs);
+
+	/*
+	 * Driver sets this field to indicate it is able to snapshot SPI
+	 * transfers (needed e.g. for reading the time of POSIX clocks)
+	 */
+	bool			ptp_sts_supported;
+
+	/* Interrupt enable state during PTP system timestamping */
+	unsigned long		irq_flags;
 };
 
 static inline void *spi_controller_get_devdata(struct spi_controller *ctlr)
@@ -644,6 +660,14 @@ extern struct spi_message *spi_get_next_queued_message(struct spi_controller *ct
 extern void spi_finalize_current_message(struct spi_controller *ctlr);
 extern void spi_finalize_current_transfer(struct spi_controller *ctlr);
 
+/* Helper calls for driver to timestamp transfer */
+void spi_take_timestamp_pre(struct spi_controller *ctlr,
+			    struct spi_transfer *xfer,
+			    const void *tx, bool irqs_off);
+void spi_take_timestamp_post(struct spi_controller *ctlr,
+			     struct spi_transfer *xfer,
+			     const void *tx, bool irqs_off);
+
 /* the spi driver core manages memory for the spi_controller classdev */
 extern struct spi_controller *__spi_alloc_controller(struct device *host,
 						unsigned int size, bool slave);
@@ -753,6 +777,35 @@ extern void spi_res_release(struct spi_controller *ctlr,
  * @transfer_list: transfers are sequenced through @spi_message.transfers
  * @tx_sg: Scatterlist for transmit, currently not for client use
  * @rx_sg: Scatterlist for receive, currently not for client use
+ * @ptp_sts_word_pre: The word (subject to bits_per_word semantics) offset
+ *	within @tx_buf for which the SPI device is requesting that the time
+ *	snapshot for this transfer begins. Upon completing the SPI transfer,
+ *	this value may have changed compared to what was requested, depending
+ *	on the available snapshotting resolution (DMA transfer,
+ *	@ptp_sts_supported is false, etc).
+ * @ptp_sts_word_post: See @ptp_sts_word_post. The two can be equal (meaning
+ *	that a single byte should be snapshotted).
+ *	If the core takes care of the timestamp (if @ptp_sts_supported is false
+ *	for this controller), it will set @ptp_sts_word_pre to 0, and
+ *	@ptp_sts_word_post to the length of the transfer. This is done
+ *	purposefully (instead of setting to spi_transfer->len - 1) to denote
+ *	that a transfer-level snapshot taken from within the driver may still
+ *	be of higher quality.
+ * @ptp_sts: Pointer to a memory location held by the SPI slave device where a
+ *	PTP system timestamp structure may lie. If drivers use PIO or their
+ *	hardware has some sort of assist for retrieving exact transfer timing,
+ *	they can (and should) assert @ptp_sts_supported and populate this
+ *	structure using the ptp_read_system_*ts helper functions.
+ *	The timestamp must represent the time at which the SPI slave device has
+ *	processed the word, i.e. the "pre" timestamp should be taken before
+ *	transmitting the "pre" word, and the "post" timestamp after receiving
+ *	transmit confirmation from the controller for the "post" word.
+ * @timestamped_pre: Set by the SPI controller driver to denote it has acted
+ *	upon the @ptp_sts request. Not set when the SPI core has taken care of
+ *	the task. SPI device drivers are free to print a warning if this comes
+ *	back unset and they need the better resolution.
+ * @timestamped_post: See above. The reason why both exist is that these
+ *	booleans are also used to keep state in the core SPI logic.
  *
  * SPI transfers always write the same number of bytes as they read.
  * Protocol drivers should always provide @rx_buf and/or @tx_buf.
@@ -842,6 +895,14 @@ struct spi_transfer {
 
 	u32		effective_speed_hz;
 
+	unsigned int	ptp_sts_word_pre;
+	unsigned int	ptp_sts_word_post;
+
+	struct ptp_system_timestamp *ptp_sts;
+
+	bool		timestamped_pre;
+	bool		timestamped_post;
+
 	struct list_head transfer_list;
 };
 

commit 26ac56506b0ea598bd0b52dcbd2d697282af98ed
Merge: 106dbe24d414 924b5867e7bd
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Jul 4 17:35:11 2019 +0100

    Merge remote-tracking branch 'spi/topic/pump-rt' into spi-next

commit 36f34737ff48f66c8a19b8788311e4b40d4adf80
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Sat Jun 15 20:47:37 2019 +0300

    spi: Add a prototype for exported spi_set_cs_timing()
    
    Compiler is not happy about spi_set_cs_timing() prototype.
    
    drivers/spi/spi.c:3016:6: warning: no previous prototype for ‘spi_set_cs_timing’ [-Wmissing-prototypes]
     void spi_set_cs_timing(struct spi_device *spi, u8 setup, u8 hold,
          ^~~~~~~~~~~~~~~~~
    
    Let's add it to the header.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index d0c5ba746e01..0ec11f2911af 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -980,6 +980,8 @@ static inline void spi_message_free(struct spi_message *m)
 	kfree(m);
 }
 
+extern void spi_set_cs_timing(struct spi_device *spi, u8 setup, u8 hold, u8 inactive_dly);
+
 extern int spi_setup(struct spi_device *spi);
 extern int spi_async(struct spi_device *spi, struct spi_message *message);
 extern int spi_async_locked(struct spi_device *spi,

commit 924b5867e7bd6a6a98014f0517b747465b108011
Author: Douglas Anderson <dianders@chromium.org>
Date:   Wed May 15 09:48:12 2019 -0700

    spi: Allow SPI devices to request the pumping thread be realtime
    
    Right now the only way to get the SPI pumping thread bumped up to
    realtime priority is for the controller to request it.  However it may
    be that the controller works fine with the normal priority but
    communication to a particular SPI device on the bus needs realtime
    priority.
    
    Let's add a way for devices to request realtime priority when they set
    themselves up.
    
    NOTE: this will just affect the priority of transfers that end up on
    the SPI core's pumping thread.  In many cases transfers happen in the
    context of the caller so if you need realtime priority for all
    transfers you should ensure the calling context is also realtime
    priority.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Guenter Roeck <groeck@chromium.org>
    Tested-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 053abd22ad31..15505c2485d6 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -109,6 +109,7 @@ void spi_statistics_add_transfer_stats(struct spi_statistics *stats,
  *	This may be changed by the device's driver, or left at the
  *	default (0) indicating protocol words are eight bit bytes.
  *	The spi_transfer.bits_per_word can override this for each transfer.
+ * @rt: Make the pump thread real time priority.
  * @irq: Negative, or the number passed to request_irq() to receive
  *	interrupts from this device.
  * @controller_state: Controller's runtime state
@@ -143,6 +144,7 @@ struct spi_device {
 	u32			max_speed_hz;
 	u8			chip_select;
 	u8			bits_per_word;
+	bool			rt;
 	u32			mode;
 #define	SPI_CPHA	0x01			/* clock phase */
 #define	SPI_CPOL	0x02			/* clock polarity */

commit 5d7e2b5ed5858fe739d4cb8ad22dcce7bd9dbe7b
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Sat Feb 23 08:49:49 2019 +0000

    spi: core: allow reporting the effectivly used speed_hz for a transfer
    
    Provide a means for the spi bus driver to report the effectively used
    spi clock frequency used for each spi_transfer.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index f55b20254612..d0c5ba746e01 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -745,6 +745,9 @@ extern void spi_res_release(struct spi_controller *ctlr,
  *	(set by bits_per_word) transmission.
  * @word_delay: clock cycles to inter word delay after each word size
  *	(set by bits_per_word) transmission.
+ * @effective_speed_hz: the effective SCK-speed that was used to
+ *      transfer this transfer. Set to 0 if the spi bus driver does
+ *      not support it.
  * @transfer_list: transfers are sequenced through @spi_message.transfers
  * @tx_sg: Scatterlist for transmit, currently not for client use
  * @rx_sg: Scatterlist for receive, currently not for client use
@@ -835,6 +838,8 @@ struct spi_transfer {
 	u32		speed_hz;
 	u16		word_delay;
 
+	u32		effective_speed_hz;
+
 	struct list_head transfer_list;
 };
 

commit e727d4cbc785e9c1b4d239eef274dc63bc1aff24
Merge: 47300728fb21 e6f3f7e4dc76
Author: Mark Brown <broonie@kernel.org>
Date:   Sun May 12 12:08:03 2019 +0900

    Merge tag 'spi-bpw-is-supported' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi into spi-5.3
    
    spi: Add spi_is_bpw_supported()
    
    Lets client drivers check and potentially handle issues.

commit d5864e5bed96db7230da45463d6ae7af5b3b4399
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Sat Feb 23 08:49:50 2019 +0000

    spi: core: allow defining time that cs is deasserted as a multiple of SCK
    
    Support setting a delay between cs assert and deassert as
    a multiple of spi clock length.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 023beb9e9e4b..e552a036cb4d 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -831,6 +831,7 @@ struct spi_transfer {
 	u8		cs_change_delay_unit;
 #define SPI_DELAY_UNIT_USECS	0
 #define SPI_DELAY_UNIT_NSECS	1
+#define SPI_DELAY_UNIT_SCK	2
 	u32		speed_hz;
 	u16		word_delay;
 

commit 0ff2de8bb163551ec4230a5a6f3c40c1f6adec4f
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Sat Feb 23 08:49:48 2019 +0000

    spi: core: allow defining time that cs is deasserted
    
    For some SPI devices that support speed_hz > 1MHz the default 10 us delay
    when cs_change = 1 is typically way to long and may result in poor spi bus
    utilization.
    
    This patch makes it possible to control the delay at micro or nano second
    resolution on a per spi_transfer basis. It even allows an "as fast as
    possible" mode with:
        xfer.cs_change_delay_unit = SPI_DELAY_UNIT_NSECS;
        xfer.cs_change_delay = 0;
    
    The delay code is shared between delay_usecs and cs_change_delay for
    consistency and reuse, so in the future this change_delay_unit could also
    apply to delay_usec as well.
    
    Note that on slower SOCs/CPU actually reaching ns deasserts on cs is not
    realistic as the gpio overhead alone (without any delays added ) may
    already leave cs deasserted for more than 1us - at least on a raspberry pi.
    But at the very least this way we can keep it as short as possible.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 053abd22ad31..023beb9e9e4b 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -735,6 +735,9 @@ extern void spi_res_release(struct spi_controller *ctlr,
  * @bits_per_word: select a bits_per_word other than the device default
  *      for this transfer. If 0 the default (from @spi_device) is used.
  * @cs_change: affects chipselect after this transfer completes
+ * @cs_change_delay: delay between cs deassert and assert when
+ *      @cs_change is set and @spi_transfer is not the last in @spi_message
+ * @cs_change_delay_unit: unit of cs_change_delay
  * @delay_usecs: microseconds to delay after this transfer before
  *	(optionally) changing the chipselect status, then starting
  *	the next transfer or completing this @spi_message.
@@ -824,6 +827,10 @@ struct spi_transfer {
 	u8		bits_per_word;
 	u8		word_delay_usecs;
 	u16		delay_usecs;
+	u16		cs_change_delay;
+	u8		cs_change_delay_unit;
+#define SPI_DELAY_UNIT_USECS	0
+#define SPI_DELAY_UNIT_NSECS	1
 	u32		speed_hz;
 	u16		word_delay;
 

commit 937e6d756422637eeb212c645ded69569a67fabc
Author: Sowjanya Komatineni <skomatineni@nvidia.com>
Date:   Mon Apr 15 14:30:27 2019 -0700

    spi: expand mode support
    
    This patch changes mode and mode_bits from u16 to u32 to allow more
    mode configurations.
    
    Signed-off-by: Sowjanya Komatineni <skomatineni@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 589f9dc9ac2b..053abd22ad31 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -143,7 +143,7 @@ struct spi_device {
 	u32			max_speed_hz;
 	u8			chip_select;
 	u8			bits_per_word;
-	u16			mode;
+	u32			mode;
 #define	SPI_CPHA	0x01			/* clock phase */
 #define	SPI_CPOL	0x02			/* clock polarity */
 #define	SPI_MODE_0	(0|0)			/* (original MicroWire) */
@@ -443,7 +443,7 @@ struct spi_controller {
 	u16			dma_alignment;
 
 	/* spi_device.mode flags understood by this controller driver */
-	u16			mode_bits;
+	u32			mode_bits;
 
 	/* bitmask of supported bits_per_word for transfers */
 	u32			bits_per_word_mask;
@@ -1291,7 +1291,7 @@ struct spi_board_info {
 	/* mode becomes spi_device.mode, and is essential for chips
 	 * where the default of SPI_CS_HIGH = 0 is wrong.
 	 */
-	u16		mode;
+	u32		mode;
 
 	/* ... may need additional spi_device chip config data here.
 	 * avoid stuff protocol drivers can set; but include stuff

commit e6f3f7e4dc76eb8d8a546dc66621a02c5c84f4ac
Author: Noralf Trønnes <noralf@tronnes.org>
Date:   Fri Apr 12 11:41:30 2019 +0200

    spi: Add spi_is_bpw_supported()
    
    This let SPI clients check if the controller supports a particular word
    width. drivers/gpu/drm/tinydrm/mipi-dbi.c will use this to determine if
    the controller supports 16-bit for RGB565 pixels. If it doesn't it will
    swap the bytes before transfer on little endian machines.
    
    Signed-off-by: Noralf Trønnes <noralf@tronnes.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 662b336aa2e4..b30e3d13a5ac 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -983,6 +983,26 @@ spi_max_transfer_size(struct spi_device *spi)
 	return min(tr_max, msg_max);
 }
 
+/**
+ * spi_is_bpw_supported - Check if bits per word is supported
+ * @spi: SPI device
+ * @bpw: Bits per word
+ *
+ * This function checks to see if the SPI controller supports @bpw.
+ *
+ * Returns:
+ * True if @bpw is supported, false otherwise.
+ */
+static inline bool spi_is_bpw_supported(struct spi_device *spi, u32 bpw)
+{
+	u32 bpw_mask = spi->master->bits_per_word_mask;
+
+	if (bpw == 8 || (bpw <= 32 && bpw_mask & SPI_BPW_MASK(bpw)))
+		return true;
+
+	return false;
+}
+
 /*---------------------------------------------------------------------------*/
 
 /* SPI transfer replacement methods which make use of spi_res */

commit f1ca9992ced71029735784de138f53446363087f
Author: Sowjanya Komatineni <skomatineni@nvidia.com>
Date:   Thu Apr 4 17:14:16 2019 -0700

    spi: add a method for configuring CS timing
    
    This patch creates set_cs_timing SPI master optional method for
    SPI masters to implement configuring CS timing if applicable.
    
    This patch also creates spi_cs_timing accessory for SPI clients to
    use for requesting SPI master controllers to configure device requested
    CS setup time, hold time and inactive delay.
    
    Signed-off-by: Sowjanya Komatineni <skomatineni@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index a0975cf76cf6..589f9dc9ac2b 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -330,6 +330,9 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *	must fail if an unrecognized or unsupported mode is requested.
  *	It's always safe to call this unless transfers are pending on
  *	the device whose settings are being modified.
+ * @set_cs_timing: optional hook for SPI devices to request SPI master
+ * controller for configuring specific CS setup time, hold time and inactive
+ * delay interms of clock counts
  * @transfer: adds a message to the controller's transfer queue.
  * @cleanup: frees controller-specific state
  * @can_dma: determine whether this controller supports DMA
@@ -363,6 +366,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @unprepare_transfer_hardware: there are currently no more messages on the
  *	queue so the subsystem notifies the driver that it may relax the
  *	hardware by issuing this call
+ *
  * @set_cs: set the logic level of the chip select line.  May be called
  *          from interrupt context.
  * @prepare_message: set up the controller to transfer a single message,
@@ -488,6 +492,17 @@ struct spi_controller {
 	 */
 	int			(*setup)(struct spi_device *spi);
 
+	/*
+	 * set_cs_timing() method is for SPI controllers that supports
+	 * configuring CS timing.
+	 *
+	 * This hook allows SPI client drivers to request SPI controllers
+	 * to configure specific CS timing through spi_set_cs_timing() after
+	 * spi_setup().
+	 */
+	void (*set_cs_timing)(struct spi_device *spi, u8 setup_clk_cycles,
+			      u8 hold_clk_cycles, u8 inactive_clk_cycles);
+
 	/* bidirectional bulk transfers
 	 *
 	 * + The transfer() method may not sleep; its main role is

commit 6d85028134d3f4f946924e2f9f0aaff47d9de840
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Mar 13 22:00:34 2019 +0100

    spi: fix SPI_BPW_RANGE_MASK() regression
    
    Geert points out that I confused the min/max arguments that are
    reversed between SPI_BPW_RANGE_MASK() and GENMASK(). This time
    I have verified the result of the macro after fixing the arguments.
    
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Fixes: eefffb42f665 ("spi: work around clang bug in SPI_BPW_RANGE_MASK()")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index b27386450089..a0975cf76cf6 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -444,7 +444,7 @@ struct spi_controller {
 	/* bitmask of supported bits_per_word for transfers */
 	u32			bits_per_word_mask;
 #define SPI_BPW_MASK(bits) BIT((bits) - 1)
-#define SPI_BPW_RANGE_MASK(min, max) GENMASK((min) - 1, (max) - 1)
+#define SPI_BPW_RANGE_MASK(min, max) GENMASK((max) - 1, (min) - 1)
 
 	/* limits on transfer speed */
 	u32			min_speed_hz;

commit eefffb42f6659c9510105f3e4ebf2a8499d56936
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Mar 7 16:54:21 2019 +0100

    spi: work around clang bug in SPI_BPW_RANGE_MASK()
    
    Clang-8 evaluates both sides of a ?: expression to check for
    valid arithmetic even in the side that is never taken. This
    results in a build warning:
    
    drivers/spi/spi-sh-msiof.c:1052:24: error: shift count >= width of type [-Werror,-Wshift-count-overflow]
            .bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 32),
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~
    
    Change the implementation to use the GENMASK() macro that does
    what we want here but does not have a problem with the shift
    count overflow.
    
    Link: https://bugs.llvm.org/show_bug.cgi?id=38789
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 662b336aa2e4..b27386450089 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -444,8 +444,7 @@ struct spi_controller {
 	/* bitmask of supported bits_per_word for transfers */
 	u32			bits_per_word_mask;
 #define SPI_BPW_MASK(bits) BIT((bits) - 1)
-#define SPI_BIT_MASK(bits) (((bits) == 32) ? ~0U : (BIT(bits) - 1))
-#define SPI_BPW_RANGE_MASK(min, max) (SPI_BIT_MASK(max) - SPI_BIT_MASK(min - 1))
+#define SPI_BPW_RANGE_MASK(min, max) GENMASK((min) - 1, (max) - 1)
 
 	/* limits on transfer speed */
 	u32			min_speed_hz;

commit b7bb367afa4bf9de60830683305c63030c3e581d
Author: Jonas Bonn <jonas@norrbonn.se>
Date:   Wed Jan 30 09:40:04 2019 +0100

    spi: support inter-word delay requirement for devices
    
    Some devices are slow and cannot keep up with the SPI bus and therefore
    require a short delay between words of the SPI transfer.
    
    The example of this that I'm looking at is a SAMA5D2 with a minimum SPI
    clock of 400kHz talking to an AVR-based SPI slave.  The AVR cannot put
    bytes on the bus fast enough to keep up with the SoC's SPI controller
    even at the lowest bus speed.
    
    This patch introduces the ability to specify a required inter-word
    delay for SPI devices.  It is up to the controller driver to configure
    itself accordingly in order to introduce the requested delay.
    
    Note that, for spi_transfer, there is already a field word_delay that
    provides similar functionality.  This field, however, is specified in
    clock cycles (and worse, SPI controller cycles, not SCK cycles); that
    makes this value dependent on the master clock instead of the device
    clock for which the delay is intended to provide some relief.  This
    patch leaves this old word_delay in place and provides a time-based
    word_delay_us alongside it; the new field fits in the struct padding
    so struct size is constant.  There is only one in-kernel user of the
    word_delay field and presumably that driver could be reworked to use
    the time-based value instead.
    
    The time-based delay is limited to 8 bits as these delays are intended
    to be short.  The SAMA5D2 that I've tested this on limits delays to a
    maximum of ~100us, which is already many word-transfer periods even at
    the minimum transfer speed supported by the controller.
    
    Signed-off-by: Jonas Bonn <jonas@norrbonn.se>
    CC: Mark Brown <broonie@kernel.org>
    CC: Rob Herring <robh+dt@kernel.org>
    CC: Mark Rutland <mark.rutland@arm.com>
    CC: linux-spi@vger.kernel.org
    CC: devicetree@vger.kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 916bba47d156..662b336aa2e4 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -122,6 +122,8 @@ void spi_statistics_add_transfer_stats(struct spi_statistics *stats,
  *	the spi_master.
  * @cs_gpiod: gpio descriptor of the chipselect line (optional, NULL when
  *	not using a GPIO line)
+ * @word_delay_usecs: microsecond delay to be inserted between consecutive
+ *	words of a transfer
  *
  * @statistics: statistics for the spi_device
  *
@@ -169,6 +171,7 @@ struct spi_device {
 	const char		*driver_override;
 	int			cs_gpio;	/* LEGACY: chip select gpio */
 	struct gpio_desc	*cs_gpiod;	/* chip select gpio desc */
+	uint8_t			word_delay_usecs; /* inter-word delay */
 
 	/* the statistics */
 	struct spi_statistics	statistics;
@@ -721,6 +724,8 @@ extern void spi_res_release(struct spi_controller *ctlr,
  * @delay_usecs: microseconds to delay after this transfer before
  *	(optionally) changing the chipselect status, then starting
  *	the next transfer or completing this @spi_message.
+ * @word_delay_usecs: microseconds to inter word delay after each word size
+ *	(set by bits_per_word) transmission.
  * @word_delay: clock cycles to inter word delay after each word size
  *	(set by bits_per_word) transmission.
  * @transfer_list: transfers are sequenced through @spi_message.transfers
@@ -803,6 +808,7 @@ struct spi_transfer {
 #define	SPI_NBITS_DUAL		0x02 /* 2bits transfer */
 #define	SPI_NBITS_QUAD		0x04 /* 4bits transfer */
 	u8		bits_per_word;
+	u8		word_delay_usecs;
 	u16		delay_usecs;
 	u32		speed_hz;
 	u16		word_delay;

commit f0125f1a559be1033055f44e511174aaa75b60cc
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Jan 23 17:29:53 2019 +0000

    spi: Go back to immediate teardown
    
    Commit 412e6037324 ("spi: core: avoid waking pump thread from spi_sync
    instead run teardown delayed") introduced regressions on some boards,
    apparently connected to spi_mem not triggering shutdown properly any
    more.  Since we've thus far been unable to figure out exactly where the
    breakage is revert the optimisation for now.
    
    Reported-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: kernel@martin.sperl.org

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 79ad62e2487c..916bba47d156 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -334,7 +334,6 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @kworker: thread struct for message pump
  * @kworker_task: pointer to task for message pump kworker thread
  * @pump_messages: work struct for scheduling work to the message pump
- * @pump_idle_teardown: work structure for scheduling a teardown delayed
  * @queue_lock: spinlock to syncronise access to message queue
  * @queue: message queue
  * @idling: the device is entering idle state
@@ -533,7 +532,6 @@ struct spi_controller {
 	struct kthread_worker		kworker;
 	struct task_struct		*kworker_task;
 	struct kthread_work		pump_messages;
-	struct kthread_delayed_work     pump_idle_teardown;
 	spinlock_t			queue_lock;
 	struct list_head		queue;
 	struct spi_message		*cur_msg;

commit 412e60373245fd1dfae8d4d44c5d1406b3d90971
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Tue Jan 8 12:13:45 2019 +0000

    spi: core: avoid waking pump thread from spi_sync instead run teardown delayed
    
    When spi_sync is running alone with no other spi devices connected
    to the bus the worker thread is woken during spi_finalize_current_message
    to run the teardown code every time.
    
    This is totally unnecessary in the case that there is no message queued.
    
    On a multi-core system this results in one wakeup of the thread for each
    spi_message processed via spi_sync where in most cases the teardown does
    not happen as the hw is already in use.
    
    This patch now delays the teardown by 1 second by using a separate
    kthread_delayed_work for the teardown.
    
    This avoids waking the kthread too often.
    
    For spi_sync transfers in a tight loop (say 40k messages/s) this
    avoids the penalty of waking the worker thread 40k times/s.
    On a rasperry pi 3 with 4 cores the results in 32% of a single core
    only to find out that there is nothing in the queue and it can go back
    to sleep.
    
    With this patch applied the spi-worker is woken exactly once: after
    the load finishes and the spi bus is idle for 1 second.
    
    I believe I have also seen situations where during a spi_sync loop
    the worker thread (triggered by the last message finished) is slightly
    faster and _wins_ the race to process the message, so we are actually
    running the kthread and letting it do some work...
    
    This is also no longer observed with this patch applied as.
    
    Tested with a new CAN controller driver for the mcp2517fd which
    uses spi_sync for interrupt handling and spi_async for scheduling
    of can frames for transmission (in a different thread)
    
    Some statistics when receiving 100000 CAN frames with the mcp25xxfd driver
    on a Raspberry pi 3:
    
    without the patch:
    ------------------
    root@raspcm3:~# for x in $(pgrep spi0) $(pgrep irq/94-mcp25xxf) ; do awk '{printf "%-20s %6i\n", $2,$15}' /proc/$x/stat; done
    (spi0)                    5
    (irq/94-mcp25xxf)         0
    root@raspcm3:~# vmstat 1
    procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
     r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
     1  0      0 821960  13592  50848    0    0    80     2 1986  105  1  2 97  0  0
     0  0      0 821968  13592  50876    0    0     0     0 8046   30  0  0 100  0  0
     0  0      0 821936  13592  50876    0    0     0     0 8032   24  0  0 100  0  0
     0  0      0 821936  13592  50876    0    0     0     0 8035   30  0  0 100  0  0
     0  0      0 821936  13592  50876    0    0     0     0 8033   22  0  0 100  0  0
     2  0      0 821936  13592  50876    0    0     0     0 11598 7129  0  3 97  0  0
     1  0      0 821872  13592  50876    0    0     0     0 37741 59003  0 31 69  0  0
     2  0      0 821840  13592  50876    0    0     0     0 37762 59078  0 29 71  0  0
     2  0      0 821776  13592  50876    0    0     0     0 37593 58792  0 28 72  0  0
     1  0      0 821744  13592  50876    0    0     0     0 37642 58881  0 30 70  0  0
     2  0      0 821680  13592  50876    0    0     0     0 37490 58602  0 27 73  0  0
     1  0      0 821648  13592  50876    0    0     0     0 37412 58418  0 29 71  0  0
     1  0      0 821584  13592  50876    0    0     0     0 37337 58288  0 27 73  0  0
     1  0      0 821552  13592  50876    0    0     0     0 37584 58774  0 27 73  0  0
     0  0      0 821520  13592  50876    0    0     0     0 18363 20566  0  9 91  0  0
     0  0      0 821520  13592  50876    0    0     0     0 8037   32  0  0 100  0  0
     0  0      0 821520  13592  50876    0    0     0     0 8031   23  0  0 100  0  0
     0  0      0 821520  13592  50876    0    0     0     0 8034   26  0  0 100  0  0
     0  0      0 821520  13592  50876    0    0     0     0 8033   24  0  0 100  0  0
    ^C
    root@raspcm3:~# for x in $(pgrep spi0) $(pgrep irq/94-mcp25xxf) ; do awk '{printf "%-20s %6i\n", $2,$15}' /proc/$x/stat; done
    (spi0)                  228
    (irq/94-mcp25xxf)       794
    root@raspcm3:~# cat /proc/interrupts
               CPU0       CPU1       CPU2       CPU3
     17:         34          0          0          0  ARMCTRL-level   1 Edge      3f00b880.mailbox
     27:          1          0          0          0  ARMCTRL-level  35 Edge      timer
     33:    1416870          0          0          0  ARMCTRL-level  41 Edge      3f980000.usb, dwc2_hsotg:usb1
     34:          1          0          0          0  ARMCTRL-level  42 Edge      vc4
     35:          0          0          0          0  ARMCTRL-level  43 Edge      3f004000.txp
     40:       1753          0          0          0  ARMCTRL-level  48 Edge      DMA IRQ
     42:         11          0          0          0  ARMCTRL-level  50 Edge      DMA IRQ
     44:         11          0          0          0  ARMCTRL-level  52 Edge      DMA IRQ
     45:          0          0          0          0  ARMCTRL-level  53 Edge      DMA IRQ
     66:          0          0          0          0  ARMCTRL-level  74 Edge      vc4 crtc
     69:          0          0          0          0  ARMCTRL-level  77 Edge      vc4 crtc
     70:          0          0          0          0  ARMCTRL-level  78 Edge      vc4 crtc
     77:         20          0          0          0  ARMCTRL-level  85 Edge      3f205000.i2c, 3f804000.i2c, 3f805000.i2c
     78:       6346          0          0          0  ARMCTRL-level  86 Edge      3f204000.spi
     80:        205          0          0          0  ARMCTRL-level  88 Edge      mmc0
     81:        493          0          0          0  ARMCTRL-level  89 Edge      uart-pl011
     89:          0          0          0          0  bcm2836-timer   0 Edge      arch_timer
     90:       4291       3821       2180       1649  bcm2836-timer   1 Edge      arch_timer
     94:      14289          0          0          0  pinctrl-bcm2835  16 Level     mcp25xxfd
    IPI0:          0          0          0          0  CPU wakeup interrupts
    IPI1:          0          0          0          0  Timer broadcast interrupts
    IPI2:       3645     242371       7919       1328  Rescheduling interrupts
    IPI3:        112        543        273        194  Function call interrupts
    IPI4:          0          0          0          0  CPU stop interrupts
    IPI5:          1          0          0          0  IRQ work interrupts
    IPI6:          0          0          0          0  completion interrupts
    Err:          0
    
    top shows 93% for the mcp25xxfd interrupt handler, 31% for spi0.
    
    with the patch:
    ---------------
    root@raspcm3:~# for x in $(pgrep spi0) $(pgrep irq/94-mcp25xxf) ; do awk '{printf "%-20s %6i\n", $2,$15}' /proc/$x/stat; done
    (spi0)                    0
    (irq/94-mcp25xxf)         0
    root@raspcm3:~# vmstat 1
    procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
     0  0      0 804768  13584  62628    0    0     0     0 8038   24  0  0 100  0  0
     0  0      0 804768  13584  62628    0    0     0     0 8042   25  0  0 100  0  0
     1  0      0 804704  13584  62628    0    0     0     0 9603 2967  0 20 80  0  0
     1  0      0 804672  13584  62628    0    0     0     0 9828 3380  0 24 76  0  0
     1  0      0 804608  13584  62628    0    0     0     0 9823 3375  0 23 77  0  0
     1  0      0 804608  13584  62628    0    0     0    12 9829 3394  0 23 77  0  0
     1  0      0 804544  13584  62628    0    0     0     0 9816 3362  0 22 78  0  0
     1  0      0 804512  13584  62628    0    0     0     0 9817 3367  0 23 77  0  0
     1  0      0 804448  13584  62628    0    0     0     0 9822 3370  0 22 78  0  0
     1  0      0 804416  13584  62628    0    0     0     0 9815 3367  0 23 77  0  0
     0  0      0 804352  13584  62628    0    0     0    84 9222 2250  0 14 86  0  0
     0  0      0 804352  13592  62620    0    0     0    24 8131  209  0  0 93  7  0
     0  0      0 804320  13592  62628    0    0     0     0 8041   27  0  0 100  0  0
     0  0      0 804352  13592  62628    0    0     0     0 8040   26  0  0 100  0  0
    root@raspcm3:~# for x in $(pgrep spi0) $(pgrep irq/94-mcp25xxf) ; do awk '{printf "%-20s %6i\n", $2,$15}' /proc/$x/stat; done
    (spi0)                    0
    (irq/94-mcp25xxf)       767
    root@raspcm3:~# cat /proc/interrupts
               CPU0       CPU1       CPU2       CPU3
     17:         29          0          0          0  ARMCTRL-level   1 Edge      3f00b880.mailbox
     27:          1          0          0          0  ARMCTRL-level  35 Edge      timer
     33:    1024412          0          0          0  ARMCTRL-level  41 Edge      3f980000.usb, dwc2_hsotg:usb1
     34:          1          0          0          0  ARMCTRL-level  42 Edge      vc4
     35:          0          0          0          0  ARMCTRL-level  43 Edge      3f004000.txp
     40:       1773          0          0          0  ARMCTRL-level  48 Edge      DMA IRQ
     42:         11          0          0          0  ARMCTRL-level  50 Edge      DMA IRQ
     44:         11          0          0          0  ARMCTRL-level  52 Edge      DMA IRQ
     45:          0          0          0          0  ARMCTRL-level  53 Edge      DMA IRQ
     66:          0          0          0          0  ARMCTRL-level  74 Edge      vc4 crtc
     69:          0          0          0          0  ARMCTRL-level  77 Edge      vc4 crtc
     70:          0          0          0          0  ARMCTRL-level  78 Edge      vc4 crtc
     77:         20          0          0          0  ARMCTRL-level  85 Edge      3f205000.i2c, 3f804000.i2c, 3f805000.i2c
     78:       6417          0          0          0  ARMCTRL-level  86 Edge      3f204000.spi
     80:        237          0          0          0  ARMCTRL-level  88 Edge      mmc0
     81:        489          0          0          0  ARMCTRL-level  89 Edge      uart-pl011
     89:          0          0          0          0  bcm2836-timer   0 Edge      arch_timer
     90:       4048       3704       2383       1892  bcm2836-timer   1 Edge      arch_timer
     94:      14287          0          0          0  pinctrl-bcm2835  16 Level     mcp25xxfd
    IPI0:          0          0          0          0  CPU wakeup interrupts
    IPI1:          0          0          0          0  Timer broadcast interrupts
    IPI2:       2361       2948       7890       1616  Rescheduling interrupts
    IPI3:         65        617        301        166  Function call interrupts
    IPI4:          0          0          0          0  CPU stop interrupts
    IPI5:          1          0          0          0  IRQ work interrupts
    IPI6:          0          0          0          0  completion interrupts
    Err:          0
    top shows 91% for the mcp25xxfd interrupt handler, 0% for spi0
    
    So we see that spi0 is no longer getting scheduled wasting CPU cycles
    There are a lot less context switches and corresponding Rescheduling interrupts
    All of these show that this improves efficiency of the system and reduces
    CPU utilization.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 916bba47d156..79ad62e2487c 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -334,6 +334,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @kworker: thread struct for message pump
  * @kworker_task: pointer to task for message pump kworker thread
  * @pump_messages: work struct for scheduling work to the message pump
+ * @pump_idle_teardown: work structure for scheduling a teardown delayed
  * @queue_lock: spinlock to syncronise access to message queue
  * @queue: message queue
  * @idling: the device is entering idle state
@@ -532,6 +533,7 @@ struct spi_controller {
 	struct kthread_worker		kworker;
 	struct task_struct		*kworker_task;
 	struct kthread_work		pump_messages;
+	struct kthread_delayed_work     pump_idle_teardown;
 	spinlock_t			queue_lock;
 	struct list_head		queue;
 	struct spi_message		*cur_msg;

commit f3186dd876697e696d07136623d5cf0a6fb0bc0f
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Jan 7 16:51:50 2019 +0100

    spi: Optionally use GPIO descriptors for CS GPIOs
    
    This augments the SPI core to optionally use GPIO descriptors
    for chip select on a per-master-driver opt-in basis.
    
    Drivers using this will rely on the SPI core to look up
    GPIO descriptors associated with the device, such as
    when using device tree or board files with GPIO descriptor
    tables.
    
    When getting descriptors from the device tree, this will in
    turn activate the code in gpiolib that was
    added in commit 6953c57ab172
    ("gpio: of: Handle SPI chipselect legacy bindings")
    which means that these descriptors are aware of the active
    low semantics that is the default for SPI CS GPIO lines
    and we can assume that all of these are "active high" and
    thus assign SPI_CS_HIGH to all CS lines on the DT path.
    
    The previously used gpio_set_value() would call down into
    gpiod_set_raw_value() and ignore the polarity inversion
    semantics.
    
    It seems like many drivers go to great lengths to set up the
    CS GPIO line as non-asserted, respecting SPI_CS_HIGH. We pull
    this out of the SPI drivers and into the core, and by simply
    requesting the line as GPIOD_OUT_LOW when retrieveing it from
    the device and relying on the gpiolib to handle any inversion
    semantics. This way a lot of code can be simplified and
    removed in each converted driver.
    
    The end goal after dealing with each driver in turn, is to
    delete the non-descriptor path (of_spi_register_master() for
    example) and let the core deal with only descriptors.
    
    The different SPI drivers have complex interactions with the
    core so we cannot simply change them all over, we need to use
    a stepwise, bisectable approach so that each driver can be
    converted and fixed in isolation.
    
    This patch has the intended side effect of adding support for
    ACPI GPIOs as it starts relying on gpiod_get_*() to get
    the GPIO handle associated with the device.
    
    Cc: Linuxarm <linuxarm@huawei.com>
    Acked-by: Jonathan Cameron <jonathan.cameron@huawei.com>
    Tested-by: Fangjian (Turing) <f.fangjian@huawei.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 314d922ca607..916bba47d156 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -12,6 +12,7 @@
 #include <linux/kthread.h>
 #include <linux/completion.h>
 #include <linux/scatterlist.h>
+#include <linux/gpio/consumer.h>
 
 struct dma_chan;
 struct property_entry;
@@ -116,7 +117,10 @@ void spi_statistics_add_transfer_stats(struct spi_statistics *stats,
  * @modalias: Name of the driver to use with this device, or an alias
  *	for that name.  This appears in the sysfs "modalias" attribute
  *	for driver coldplugging, and in uevents used for hotplugging
- * @cs_gpio: gpio number of the chipselect line (optional, -ENOENT when
+ * @cs_gpio: LEGACY: gpio number of the chipselect line (optional, -ENOENT when
+ *	not using a GPIO line) use cs_gpiod in new drivers by opting in on
+ *	the spi_master.
+ * @cs_gpiod: gpio descriptor of the chipselect line (optional, NULL when
  *	not using a GPIO line)
  *
  * @statistics: statistics for the spi_device
@@ -163,7 +167,8 @@ struct spi_device {
 	void			*controller_data;
 	char			modalias[SPI_NAME_SIZE];
 	const char		*driver_override;
-	int			cs_gpio;	/* chip select gpio */
+	int			cs_gpio;	/* LEGACY: chip select gpio */
+	struct gpio_desc	*cs_gpiod;	/* chip select gpio desc */
 
 	/* the statistics */
 	struct spi_statistics	statistics;
@@ -376,9 +381,17 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *	     controller has native support for memory like operations.
  * @unprepare_message: undo any work done by prepare_message().
  * @slave_abort: abort the ongoing transfer request on an SPI slave controller
- * @cs_gpios: Array of GPIOs to use as chip select lines; one per CS
- *	number. Any individual value may be -ENOENT for CS lines that
+ * @cs_gpios: LEGACY: array of GPIO descs to use as chip select lines; one per
+ *	CS number. Any individual value may be -ENOENT for CS lines that
+ *	are not GPIOs (driven by the SPI controller itself). Use the cs_gpiods
+ *	in new drivers.
+ * @cs_gpiods: Array of GPIO descs to use as chip select lines; one per CS
+ *	number. Any individual value may be NULL for CS lines that
  *	are not GPIOs (driven by the SPI controller itself).
+ * @use_gpio_descriptors: Turns on the code in the SPI core to parse and grab
+ *	GPIO descriptors rather than using global GPIO numbers grabbed by the
+ *	driver. This will fill in @cs_gpiods and @cs_gpios should not be used,
+ *	and SPI devices will have the cs_gpiod assigned rather than cs_gpio.
  * @statistics: statistics for the spi_controller
  * @dma_tx: DMA transmit channel
  * @dma_rx: DMA receive channel
@@ -557,6 +570,8 @@ struct spi_controller {
 
 	/* gpio chip select */
 	int			*cs_gpios;
+	struct gpio_desc	**cs_gpiods;
+	bool			use_gpio_descriptors;
 
 	/* statistics */
 	struct spi_statistics	statistics;

commit ae218f7847fcf32e75ba82b1f3ab01fe53731d7a
Merge: 32215a6c6beb 5132b3d28371
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Dec 4 17:31:49 2018 +0000

    Merge branch 'topic/3wire-gpio' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi into spi-4.21 mode conflict

commit 6b03061f882de49b83ccf44beb3a12c920a2da1b
Author: Yogesh Narayan Gaur <yogeshnarayan.gaur@nxp.com>
Date:   Mon Dec 3 08:39:06 2018 +0000

    spi: add support for octal mode I/O data transfer
    
    Add flags for Octal mode I/O data transfer
    Required for the SPI controller which can do the data transfer (TX/RX)
    on 8 data lines e.g. NXP FlexSPI controller.
     SPI_TX_OCTAL: transmit with 8 wires
     SPI_RX_OCTAL: receive with 8 wires
    
    Signed-off-by: Yogesh Gaur <yogeshnarayan.gaur@nxp.com>
    Reviewed-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 6be77fa5ab90..0c1ca5dedbb4 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -154,7 +154,9 @@ struct spi_device {
 #define	SPI_TX_QUAD	0x200			/* transmit with 4 wires */
 #define	SPI_RX_DUAL	0x400			/* receive with 2 wires */
 #define	SPI_RX_QUAD	0x800			/* receive with 4 wires */
-#define SPI_CS_WORD	0x1000			/* toggle cs after each word */
+#define	SPI_CS_WORD	0x1000			/* toggle cs after each word */
+#define	SPI_TX_OCTAL	0x2000			/* transmit with 8 wires */
+#define	SPI_RX_OCTAL	0x4000			/* receive with 8 wires */
 	int			irq;
 	void			*controller_state;
 	void			*controller_data;

commit 5132b3d283710d196cd8af99b5585507e8b30709
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Nov 1 22:25:04 2018 +0100

    spi: gpio: Support 3WIRE high-impedance turn-around
    
    Some devices such as the TPO TPG110 display panel require
    a "high-impedance turn-around", in effect a clock cycle after
    switching the line from output to input mode.
    
    Support this in the GPIO driver to begin with. Other driver
    may implement it if they can, it is unclear if this can
    be achieved with anything else than GPIO bit-banging.
    
    Cc: Andrzej Hajda <a.hajda@samsung.com>
    Acked-by: Lorenzo Bianconi <lorenzo.bianconi@redhat.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 6be77fa5ab90..3ced58eebe1b 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -155,6 +155,7 @@ struct spi_device {
 #define	SPI_RX_DUAL	0x400			/* receive with 2 wires */
 #define	SPI_RX_QUAD	0x800			/* receive with 4 wires */
 #define SPI_CS_WORD	0x1000			/* toggle cs after each word */
+#define	SPI_3WIRE_HIZ	0x2000			/* high impedance turnaround */
 	int			irq;
 	void			*controller_state;
 	void			*controller_data;

commit 7b9734dbc5b042bb8d8d930797f346b280057c4e
Merge: 4b51c747e4a5 5f143af7501e
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Oct 21 17:00:17 2018 +0100

    Merge remote-tracking branch 'spi/topic/of' into spi-next

commit 5039563e7c25eccd7fec1de6706011009d1c5665
Author: Trent Piepho <tpiepho@impinj.com>
Date:   Thu Sep 20 19:18:32 2018 +0000

    spi: Add driver_override SPI device attribute
    
    This attribute works the same was as the identically named attribute
    for PCI, AMBA, and platform devices.  For reference, see:
    
    commit 3cf385713460 ("ARM: 8256/1: driver coamba: add device binding
    path 'driver_override'")
    commit 3d713e0e382e ("driver core: platform: add device binding path
    'driver_override'")
    commit 782a985d7af2 ("PCI: Introduce new device binding path using
    pci_dev.driver_override")
    
    If the name of a driver is written to this attribute, then the device
    will bind to the named driver and only the named driver.
    
    The device will bind to the driver even if the driver does not list the
    device in its id table.  This behavior is different than the driver's
    bind attribute, which only allows binding to devices that are listed as
    supported by the driver.
    
    It can be used to bind a generic driver, like spidev, to a device.
    
    Signed-off-by: Trent Piepho <tpiepho@impinj.com>
    Reviewed-by: Jan KundrÃ¡t <jan.kundrat@cesnet.cz>
    Tested-by: Jan KundrÃ¡t <jan.kundrat@cesnet.cz>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index f08824ea1968..3de9958ca28b 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -159,6 +159,7 @@ struct spi_device {
 	void			*controller_state;
 	void			*controller_data;
 	char			modalias[SPI_NAME_SIZE];
+	const char		*driver_override;
 	int			cs_gpio;	/* chip select gpio */
 
 	/* the statistics */

commit 5f143af7501e7c435c56e181a655493edaa92509
Author: Marco Felsch <m.felsch@pengutronix.de>
Date:   Tue Sep 25 11:42:29 2018 +0200

    spi: make OF helper available for others
    
    The of_find_spi_device_by_node() helper function is useful for other
    modules too. Export the funciton as GPL like all other spi helper
    functions and make it available if CONFIG_OF is enabled, because it isn't
    related to the CONFIG_OF_DYNAMIC context. Finally add a stub if
    CONFIG_OF isn't enabled, so others must not care about it.
    
    Signed-off-by: Marco Felsch <m.felsch@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index a64235e05321..e9ebfcd2e932 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -1277,7 +1277,6 @@ spi_register_board_info(struct spi_board_info const *info, unsigned n)
 	{ return 0; }
 #endif
 
-
 /* If you're hotplugging an adapter with devices (parport, usb, etc)
  * use spi_new_device() to describe each device.  You can also call
  * spi_unregister_device() to start making that device vanish, but
@@ -1309,6 +1308,22 @@ spi_transfer_is_last(struct spi_controller *ctlr, struct spi_transfer *xfer)
 	return list_is_last(&xfer->transfer_list, &ctlr->cur_msg->transfers);
 }
 
+/* OF support code */
+#if IS_ENABLED(CONFIG_OF)
+
+/* must call put_device() when done with returned spi_device device */
+extern struct spi_device *
+of_find_spi_device_by_node(struct device_node *node);
+
+#else
+
+static inline struct spi_device *
+of_find_spi_device_by_node(struct device_node *node)
+{
+	return NULL;
+}
+
+#endif /* IS_ENABLED(CONFIG_OF) */
 
 /* Compatibility layer */
 #define spi_master			spi_controller

commit b445bfcb9081ae90fec90b828f3aacc565776901
Author: Marco Felsch <m.felsch@pengutronix.de>
Date:   Tue Sep 25 11:42:28 2018 +0200

    spi: switch to SPDX license identifier
    
    Use the appropriate SPDX license identifier and drop the previous
    license text.
    
    Signed-off-by: Marco Felsch <m.felsch@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 7bb36145e2ba..f08824ea1968 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -1,15 +1,6 @@
-/*
- * Copyright (C) 2005 David Brownell
+/* SPDX-License-Identifier: GPL-2.0-or-later
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * Copyright (C) 2005 David Brownell
  */
 
 #ifndef __LINUX_SPI_H

commit 926369667732577cd7ca85f28ced8ef8d0964285
Merge: 3356d9f4cb45 cbaa62e0094a
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Sep 17 14:17:30 2018 -0700

    Merge tag 'spi-cs-word' into spi-4.20
    
    spi: Provide SPI_CS_WORD
    
    This provides a SPI operation mode which changes chip select after every
    word, used by some devices such as ADCs and DACs.

commit 0baf9eb25572eea0cf48249c1d152d8373956a7c
Author: David Lechner <david@lechnology.com>
Date:   Wed Sep 12 19:39:17 2018 -0500

    spi: add new SPI_CS_WORD flag
    
    This adds a new SPI mode flag, SPI_CS_WORD, that is used to indicate
    that a SPI device requires the chip select to be toggled after each
    word that is transferred.
    
    Signed-off-by: David Lechner <david@lechnology.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index a64235e05321..7cc1466111f5 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -163,6 +163,7 @@ struct spi_device {
 #define	SPI_TX_QUAD	0x200			/* transmit with 4 wires */
 #define	SPI_RX_DUAL	0x400			/* receive with 2 wires */
 #define	SPI_RX_QUAD	0x800			/* receive with 4 wires */
+#define SPI_CS_WORD	0x1000			/* toggle cs after each word */
 	int			irq;
 	void			*controller_state;
 	void			*controller_data;
@@ -177,7 +178,6 @@ struct spi_device {
 	 * the controller talks to each chip, like:
 	 *  - memory packing (12 bit samples into low bits, others zeroed)
 	 *  - priority
-	 *  - drop chipselect after each word
 	 *  - chipselect delays
 	 *  - ...
 	 */

commit eeaceb8b7d1fb64b6030249ca0dd1d902ef3069e
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Thu Aug 16 20:54:49 2018 +0800

    spi: Introduce one new field to set word delay
    
    For some SPI controllers, after each word size (specified by bits_per_word)
    transimission, the hardware need some delay to make sure the slave has enough
    time to receive the whole data.
    
    So introducing one new 'word_delay' field of struct spi_tansfer for slave
    devices to set this inter word delay time.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index a64235e05321..d698f9db3484 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -711,6 +711,8 @@ extern void spi_res_release(struct spi_controller *ctlr,
  * @delay_usecs: microseconds to delay after this transfer before
  *	(optionally) changing the chipselect status, then starting
  *	the next transfer or completing this @spi_message.
+ * @word_delay: clock cycles to inter word delay after each word size
+ *	(set by bits_per_word) transmission.
  * @transfer_list: transfers are sequenced through @spi_message.transfers
  * @tx_sg: Scatterlist for transmit, currently not for client use
  * @rx_sg: Scatterlist for receive, currently not for client use
@@ -793,6 +795,7 @@ struct spi_transfer {
 	u8		bits_per_word;
 	u16		delay_usecs;
 	u32		speed_hz;
+	u16		word_delay;
 
 	struct list_head transfer_list;
 };

commit c1f5ba70decfc2f35edcc10505e3e78fb528d212
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Thu Apr 26 18:18:20 2018 +0200

    spi: Get rid of the spi_flash_read() API
    
    This API has been replaced by the spi_mem_xx() one, its only user
    (spi-nor) has been converted to spi_mem_xx() and all SPI controller
    drivers that were implementing the ->spi_flash_xxx() hooks are also
    implementing the spi_mem ones. So we can safely get rid of this API.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Frieder Schrempf <frieder.schrempf@exceet.de>
    Tested-by: Frieder Schrempf <frieder.schrempf@exceet.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index a7e0bbed738c..a64235e05321 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -26,7 +26,6 @@ struct dma_chan;
 struct property_entry;
 struct spi_controller;
 struct spi_transfer;
-struct spi_flash_read_message;
 struct spi_controller_mem_ops;
 
 /*
@@ -382,11 +381,6 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *	     controller has native support for memory like operations.
  * @unprepare_message: undo any work done by prepare_message().
  * @slave_abort: abort the ongoing transfer request on an SPI slave controller
- * @spi_flash_read: to support spi-controller hardwares that provide
- *                  accelerated interface to read from flash devices.
- * @spi_flash_can_dma: analogous to can_dma() interface, but for
- *		       controllers implementing spi_flash_read.
- * @flash_read_supported: spi device supports flash read
  * @cs_gpios: Array of GPIOs to use as chip select lines; one per CS
  *	number. Any individual value may be -ENOENT for CS lines that
  *	are not GPIOs (driven by the SPI controller itself).
@@ -552,11 +546,6 @@ struct spi_controller {
 	int (*unprepare_message)(struct spi_controller *ctlr,
 				 struct spi_message *message);
 	int (*slave_abort)(struct spi_controller *ctlr);
-	int (*spi_flash_read)(struct  spi_device *spi,
-			      struct spi_flash_read_message *msg);
-	bool (*spi_flash_can_dma)(struct spi_device *spi,
-				  struct spi_flash_read_message *msg);
-	bool (*flash_read_supported)(struct spi_device *spi);
 
 	/*
 	 * These hooks are for drivers that use a generic implementation
@@ -1190,48 +1179,6 @@ static inline ssize_t spi_w8r16be(struct spi_device *spi, u8 cmd)
 	return be16_to_cpu(result);
 }
 
-/**
- * struct spi_flash_read_message - flash specific information for
- * spi-masters that provide accelerated flash read interfaces
- * @buf: buffer to read data
- * @from: offset within the flash from where data is to be read
- * @len: length of data to be read
- * @retlen: actual length of data read
- * @read_opcode: read_opcode to be used to communicate with flash
- * @addr_width: number of address bytes
- * @dummy_bytes: number of dummy bytes
- * @opcode_nbits: number of lines to send opcode
- * @addr_nbits: number of lines to send address
- * @data_nbits: number of lines for data
- * @rx_sg: Scatterlist for receive data read from flash
- * @cur_msg_mapped: message has been mapped for DMA
- */
-struct spi_flash_read_message {
-	void *buf;
-	loff_t from;
-	size_t len;
-	size_t retlen;
-	u8 read_opcode;
-	u8 addr_width;
-	u8 dummy_bytes;
-	u8 opcode_nbits;
-	u8 addr_nbits;
-	u8 data_nbits;
-	struct sg_table rx_sg;
-	bool cur_msg_mapped;
-};
-
-/* SPI core interface for flash read support */
-static inline bool spi_flash_read_supported(struct spi_device *spi)
-{
-	return spi->controller->spi_flash_read &&
-	       (!spi->controller->flash_read_supported ||
-	       spi->controller->flash_read_supported(spi));
-}
-
-int spi_flash_read(struct spi_device *spi,
-		   struct spi_flash_read_message *msg);
-
 /*---------------------------------------------------------------------------*/
 
 /*

commit c36ff266dc82f4ae797a6f3513c6ffa344f7f1c7
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Thu Apr 26 18:18:14 2018 +0200

    spi: Extend the core to ease integration of SPI memory controllers
    
    Some controllers are exposing high-level interfaces to access various
    kind of SPI memories. Unfortunately they do not fit in the current
    spi_controller model and usually have drivers placed in
    drivers/mtd/spi-nor which are only supporting SPI NORs and not SPI
    memories in general.
    
    This is an attempt at defining a SPI memory interface which works for
    all kinds of SPI memories (NORs, NANDs, SRAMs).
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Frieder Schrempf <frieder.schrempf@exceet.de>
    Tested-by: Frieder Schrempf <frieder.schrempf@exceet.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index bc6bb325d1bf..a7e0bbed738c 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -27,6 +27,7 @@ struct property_entry;
 struct spi_controller;
 struct spi_transfer;
 struct spi_flash_read_message;
+struct spi_controller_mem_ops;
 
 /*
  * INTERFACES between SPI master-side drivers and SPI slave protocol handlers,
@@ -376,6 +377,9 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *                    transfer_one callback.
  * @handle_err: the subsystem calls the driver to handle an error that occurs
  *		in the generic implementation of transfer_one_message().
+ * @mem_ops: optimized/dedicated operations for interactions with SPI memory.
+ *	     This field is optional and should only be implemented if the
+ *	     controller has native support for memory like operations.
  * @unprepare_message: undo any work done by prepare_message().
  * @slave_abort: abort the ongoing transfer request on an SPI slave controller
  * @spi_flash_read: to support spi-controller hardwares that provide
@@ -564,6 +568,9 @@ struct spi_controller {
 	void (*handle_err)(struct spi_controller *ctlr,
 			   struct spi_message *message);
 
+	/* Optimized handlers for SPI memory-like operations. */
+	const struct spi_controller_mem_ops *mem_ops;
+
 	/* gpio chip select */
 	int			*cs_gpios;
 

commit 8d26fdfcb45dc420115b267ac9d6b3ac13457f1b
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Nov 30 14:35:08 2017 +0100

    spi: Fix double "when"
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 7b2170bfd6e7..bc6bb325d1bf 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -126,7 +126,7 @@ void spi_statistics_add_transfer_stats(struct spi_statistics *stats,
  *	for that name.  This appears in the sysfs "modalias" attribute
  *	for driver coldplugging, and in uevents used for hotplugging
  * @cs_gpio: gpio number of the chipselect line (optional, -ENOENT when
- *	when not using a GPIO line)
+ *	not using a GPIO line)
  *
  * @statistics: statistics for the spi_device
  *

commit 8caab75fd2c2a92667cbb1cd315720bede3feaa9
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Jun 13 13:23:52 2017 +0200

    spi: Generalize SPI "master" to "controller"
    
    Now struct spi_master is used for both SPI master and slave controllers,
    it makes sense to rename it to struct spi_controller, and replace
    "master" by "controller" where appropriate.
    
    For now this conversion is done for SPI core infrastructure only.
    Wrappers are provided for backwards compatibility, until all SPI drivers
    have been converted.
    
    Noteworthy details:
      - SPI_MASTER_GPIO_SS is retained, as it only makes sense for SPI
        master controllers,
      - spi_busnum_to_master() is retained, as it looks up masters only,
      - A new field spi_device.controller is added, but spi_device.master is
        retained for compatibility (both are always initialized by
        spi_alloc_device()),
      - spi_flash_read() is used by SPI masters only.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 0a78745e5766..7b2170bfd6e7 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -24,7 +24,7 @@
 
 struct dma_chan;
 struct property_entry;
-struct spi_master;
+struct spi_controller;
 struct spi_transfer;
 struct spi_flash_read_message;
 
@@ -84,7 +84,7 @@ struct spi_statistics {
 
 void spi_statistics_add_transfer_stats(struct spi_statistics *stats,
 				       struct spi_transfer *xfer,
-				       struct spi_master *master);
+				       struct spi_controller *ctlr);
 
 #define SPI_STATISTICS_ADD_TO_FIELD(stats, field, count)	\
 	do {							\
@@ -98,13 +98,14 @@ void spi_statistics_add_transfer_stats(struct spi_statistics *stats,
 	SPI_STATISTICS_ADD_TO_FIELD(stats, field, 1)
 
 /**
- * struct spi_device - Master side proxy for an SPI slave device
+ * struct spi_device - Controller side proxy for an SPI slave device
  * @dev: Driver model representation of the device.
- * @master: SPI controller used with the device.
+ * @controller: SPI controller used with the device.
+ * @master: Copy of controller, for backwards compatibility.
  * @max_speed_hz: Maximum clock rate to be used with this chip
  *	(on this board); may be changed by the device's driver.
  *	The spi_transfer.speed_hz can override this for each transfer.
- * @chip_select: Chipselect, distinguishing chips handled by @master.
+ * @chip_select: Chipselect, distinguishing chips handled by @controller.
  * @mode: The spi mode defines how data is clocked out and in.
  *	This may be changed by the device's driver.
  *	The "active low" default for chipselect mode can be overridden
@@ -140,7 +141,8 @@ void spi_statistics_add_transfer_stats(struct spi_statistics *stats,
  */
 struct spi_device {
 	struct device		dev;
-	struct spi_master	*master;
+	struct spi_controller	*controller;
+	struct spi_controller	*master;	/* compatibility layer */
 	u32			max_speed_hz;
 	u8			chip_select;
 	u8			bits_per_word;
@@ -198,7 +200,7 @@ static inline void spi_dev_put(struct spi_device *spi)
 		put_device(&spi->dev);
 }
 
-/* ctldata is for the bus_master driver's runtime state */
+/* ctldata is for the bus_controller driver's runtime state */
 static inline void *spi_get_ctldata(struct spi_device *spi)
 {
 	return spi->controller_state;
@@ -292,9 +294,9 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
 			spi_unregister_driver)
 
 /**
- * struct spi_master - interface to SPI master controller
+ * struct spi_controller - interface to SPI master or slave controller
  * @dev: device interface to this driver
- * @list: link with the global spi_master list
+ * @list: link with the global spi_controller list
  * @bus_num: board-specific (and often SOC-specific) identifier for a
  *	given SPI controller.
  * @num_chipselect: chipselects are used to distinguish individual
@@ -327,8 +329,8 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *	the device whose settings are being modified.
  * @transfer: adds a message to the controller's transfer queue.
  * @cleanup: frees controller-specific state
- * @can_dma: determine whether this master supports DMA
- * @queued: whether this master is providing an internal message queue
+ * @can_dma: determine whether this controller supports DMA
+ * @queued: whether this controller is providing an internal message queue
  * @kworker: thread struct for message pump
  * @kworker_task: pointer to task for message pump kworker thread
  * @pump_messages: work struct for scheduling work to the message pump
@@ -384,7 +386,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @cs_gpios: Array of GPIOs to use as chip select lines; one per CS
  *	number. Any individual value may be -ENOENT for CS lines that
  *	are not GPIOs (driven by the SPI controller itself).
- * @statistics: statistics for the spi_master
+ * @statistics: statistics for the spi_controller
  * @dma_tx: DMA transmit channel
  * @dma_rx: DMA receive channel
  * @dummy_rx: dummy receive buffer for full-duplex devices
@@ -393,7 +395,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *	what Linux expects, this optional hook can be used to translate
  *	between the two.
  *
- * Each SPI master controller can communicate with one or more @spi_device
+ * Each SPI controller can communicate with one or more @spi_device
  * children.  These make a small bus, sharing MOSI, MISO and SCK signals
  * but not chip select signals.  Each device may be configured to use a
  * different clock rate, since those shared signals are ignored unless
@@ -404,7 +406,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * an SPI slave device.  For each such message it queues, it calls the
  * message's completion function when the transaction completes.
  */
-struct spi_master {
+struct spi_controller {
 	struct device	dev;
 
 	struct list_head list;
@@ -442,12 +444,13 @@ struct spi_master {
 
 	/* other constraints relevant to this driver */
 	u16			flags;
-#define SPI_MASTER_HALF_DUPLEX	BIT(0)		/* can't do full duplex */
-#define SPI_MASTER_NO_RX	BIT(1)		/* can't do buffer read */
-#define SPI_MASTER_NO_TX	BIT(2)		/* can't do buffer write */
-#define SPI_MASTER_MUST_RX      BIT(3)		/* requires rx */
-#define SPI_MASTER_MUST_TX      BIT(4)		/* requires tx */
-#define SPI_MASTER_GPIO_SS      BIT(5)		/* GPIO CS must select slave */
+#define SPI_CONTROLLER_HALF_DUPLEX	BIT(0)	/* can't do full duplex */
+#define SPI_CONTROLLER_NO_RX		BIT(1)	/* can't do buffer read */
+#define SPI_CONTROLLER_NO_TX		BIT(2)	/* can't do buffer write */
+#define SPI_CONTROLLER_MUST_RX		BIT(3)	/* requires rx */
+#define SPI_CONTROLLER_MUST_TX		BIT(4)	/* requires tx */
+
+#define SPI_MASTER_GPIO_SS		BIT(5)	/* GPIO CS must select slave */
 
 	/* flag indicating this is an SPI slave controller */
 	bool			slave;
@@ -485,8 +488,8 @@ struct spi_master {
 	 *   any other request management
 	 * + To a given spi_device, message queueing is pure fifo
 	 *
-	 * + The master's main job is to process its message queue,
-	 *   selecting a chip then transferring data
+	 * + The controller's main job is to process its message queue,
+	 *   selecting a chip (for masters), then transferring data
 	 * + If there are multiple spi_device children, the i/o queue
 	 *   arbitration algorithm is unspecified (round robin, fifo,
 	 *   priority, reservations, preemption, etc)
@@ -499,7 +502,7 @@ struct spi_master {
 	int			(*transfer)(struct spi_device *spi,
 						struct spi_message *mesg);
 
-	/* called on release() to free memory provided by spi_master */
+	/* called on release() to free memory provided by spi_controller */
 	void			(*cleanup)(struct spi_device *spi);
 
 	/*
@@ -509,13 +512,13 @@ struct spi_master {
 	 * not modify or store xfer and dma_tx and dma_rx must be set
 	 * while the device is prepared.
 	 */
-	bool			(*can_dma)(struct spi_master *master,
+	bool			(*can_dma)(struct spi_controller *ctlr,
 					   struct spi_device *spi,
 					   struct spi_transfer *xfer);
 
 	/*
 	 * These hooks are for drivers that want to use the generic
-	 * master transfer queueing mechanism. If these are used, the
+	 * controller transfer queueing mechanism. If these are used, the
 	 * transfer() function above must NOT be specified by the driver.
 	 * Over time we expect SPI drivers to be phased over to this API.
 	 */
@@ -536,15 +539,15 @@ struct spi_master {
 	struct completion               xfer_completion;
 	size_t				max_dma_len;
 
-	int (*prepare_transfer_hardware)(struct spi_master *master);
-	int (*transfer_one_message)(struct spi_master *master,
+	int (*prepare_transfer_hardware)(struct spi_controller *ctlr);
+	int (*transfer_one_message)(struct spi_controller *ctlr,
 				    struct spi_message *mesg);
-	int (*unprepare_transfer_hardware)(struct spi_master *master);
-	int (*prepare_message)(struct spi_master *master,
+	int (*unprepare_transfer_hardware)(struct spi_controller *ctlr);
+	int (*prepare_message)(struct spi_controller *ctlr,
 			       struct spi_message *message);
-	int (*unprepare_message)(struct spi_master *master,
+	int (*unprepare_message)(struct spi_controller *ctlr,
 				 struct spi_message *message);
-	int (*slave_abort)(struct spi_master *spi);
+	int (*slave_abort)(struct spi_controller *ctlr);
 	int (*spi_flash_read)(struct  spi_device *spi,
 			      struct spi_flash_read_message *msg);
 	bool (*spi_flash_can_dma)(struct spi_device *spi,
@@ -556,9 +559,9 @@ struct spi_master {
 	 * of transfer_one_message() provied by the core.
 	 */
 	void (*set_cs)(struct spi_device *spi, bool enable);
-	int (*transfer_one)(struct spi_master *master, struct spi_device *spi,
+	int (*transfer_one)(struct spi_controller *ctlr, struct spi_device *spi,
 			    struct spi_transfer *transfer);
-	void (*handle_err)(struct spi_master *master,
+	void (*handle_err)(struct spi_controller *ctlr,
 			   struct spi_message *message);
 
 	/* gpio chip select */
@@ -575,58 +578,59 @@ struct spi_master {
 	void			*dummy_rx;
 	void			*dummy_tx;
 
-	int (*fw_translate_cs)(struct spi_master *master, unsigned cs);
+	int (*fw_translate_cs)(struct spi_controller *ctlr, unsigned cs);
 };
 
-static inline void *spi_master_get_devdata(struct spi_master *master)
+static inline void *spi_controller_get_devdata(struct spi_controller *ctlr)
 {
-	return dev_get_drvdata(&master->dev);
+	return dev_get_drvdata(&ctlr->dev);
 }
 
-static inline void spi_master_set_devdata(struct spi_master *master, void *data)
+static inline void spi_controller_set_devdata(struct spi_controller *ctlr,
+					      void *data)
 {
-	dev_set_drvdata(&master->dev, data);
+	dev_set_drvdata(&ctlr->dev, data);
 }
 
-static inline struct spi_master *spi_master_get(struct spi_master *master)
+static inline struct spi_controller *spi_controller_get(struct spi_controller *ctlr)
 {
-	if (!master || !get_device(&master->dev))
+	if (!ctlr || !get_device(&ctlr->dev))
 		return NULL;
-	return master;
+	return ctlr;
 }
 
-static inline void spi_master_put(struct spi_master *master)
+static inline void spi_controller_put(struct spi_controller *ctlr)
 {
-	if (master)
-		put_device(&master->dev);
+	if (ctlr)
+		put_device(&ctlr->dev);
 }
 
-static inline bool spi_controller_is_slave(struct spi_master *ctlr)
+static inline bool spi_controller_is_slave(struct spi_controller *ctlr)
 {
 	return IS_ENABLED(CONFIG_SPI_SLAVE) && ctlr->slave;
 }
 
 /* PM calls that need to be issued by the driver */
-extern int spi_master_suspend(struct spi_master *master);
-extern int spi_master_resume(struct spi_master *master);
+extern int spi_controller_suspend(struct spi_controller *ctlr);
+extern int spi_controller_resume(struct spi_controller *ctlr);
 
 /* Calls the driver make to interact with the message queue */
-extern struct spi_message *spi_get_next_queued_message(struct spi_master *master);
-extern void spi_finalize_current_message(struct spi_master *master);
-extern void spi_finalize_current_transfer(struct spi_master *master);
+extern struct spi_message *spi_get_next_queued_message(struct spi_controller *ctlr);
+extern void spi_finalize_current_message(struct spi_controller *ctlr);
+extern void spi_finalize_current_transfer(struct spi_controller *ctlr);
 
-/* the spi driver core manages memory for the spi_master classdev */
-extern struct spi_master *__spi_alloc_controller(struct device *host,
-						 unsigned int size, bool slave);
+/* the spi driver core manages memory for the spi_controller classdev */
+extern struct spi_controller *__spi_alloc_controller(struct device *host,
+						unsigned int size, bool slave);
 
-static inline struct spi_master *spi_alloc_master(struct device *host,
-						  unsigned int size)
+static inline struct spi_controller *spi_alloc_master(struct device *host,
+						      unsigned int size)
 {
 	return __spi_alloc_controller(host, size, false);
 }
 
-static inline struct spi_master *spi_alloc_slave(struct device *host,
-						 unsigned int size)
+static inline struct spi_controller *spi_alloc_slave(struct device *host,
+						     unsigned int size)
 {
 	if (!IS_ENABLED(CONFIG_SPI_SLAVE))
 		return NULL;
@@ -634,18 +638,18 @@ static inline struct spi_master *spi_alloc_slave(struct device *host,
 	return __spi_alloc_controller(host, size, true);
 }
 
-extern int spi_register_master(struct spi_master *master);
-extern int devm_spi_register_master(struct device *dev,
-				    struct spi_master *master);
-extern void spi_unregister_master(struct spi_master *master);
+extern int spi_register_controller(struct spi_controller *ctlr);
+extern int devm_spi_register_controller(struct device *dev,
+					struct spi_controller *ctlr);
+extern void spi_unregister_controller(struct spi_controller *ctlr);
 
-extern struct spi_master *spi_busnum_to_master(u16 busnum);
+extern struct spi_controller *spi_busnum_to_master(u16 busnum);
 
 /*
  * SPI resource management while processing a SPI message
  */
 
-typedef void (*spi_res_release_t)(struct spi_master *master,
+typedef void (*spi_res_release_t)(struct spi_controller *ctlr,
 				  struct spi_message *msg,
 				  void *res);
 
@@ -670,7 +674,7 @@ extern void *spi_res_alloc(struct spi_device *spi,
 extern void spi_res_add(struct spi_message *message, void *res);
 extern void spi_res_free(void *res);
 
-extern void spi_res_release(struct spi_master *master,
+extern void spi_res_release(struct spi_controller *ctlr,
 			    struct spi_message *message);
 
 /*---------------------------------------------------------------------------*/
@@ -854,7 +858,7 @@ struct spi_message {
 
 	/* for optional use by whatever driver currently owns the
 	 * spi_message ...  between calls to spi_async and then later
-	 * complete(), that's the spi_master controller driver.
+	 * complete(), that's the spi_controller controller driver.
 	 */
 	struct list_head	queue;
 	void			*state;
@@ -943,21 +947,22 @@ extern int spi_slave_abort(struct spi_device *spi);
 static inline size_t
 spi_max_message_size(struct spi_device *spi)
 {
-	struct spi_master *master = spi->master;
-	if (!master->max_message_size)
+	struct spi_controller *ctlr = spi->controller;
+
+	if (!ctlr->max_message_size)
 		return SIZE_MAX;
-	return master->max_message_size(spi);
+	return ctlr->max_message_size(spi);
 }
 
 static inline size_t
 spi_max_transfer_size(struct spi_device *spi)
 {
-	struct spi_master *master = spi->master;
+	struct spi_controller *ctlr = spi->controller;
 	size_t tr_max = SIZE_MAX;
 	size_t msg_max = spi_max_message_size(spi);
 
-	if (master->max_transfer_size)
-		tr_max = master->max_transfer_size(spi);
+	if (ctlr->max_transfer_size)
+		tr_max = ctlr->max_transfer_size(spi);
 
 	/* transfer size limit must not be greater than messsage size limit */
 	return min(tr_max, msg_max);
@@ -968,7 +973,7 @@ spi_max_transfer_size(struct spi_device *spi)
 /* SPI transfer replacement methods which make use of spi_res */
 
 struct spi_replaced_transfers;
-typedef void (*spi_replaced_release_t)(struct spi_master *master,
+typedef void (*spi_replaced_release_t)(struct spi_controller *ctlr,
 				       struct spi_message *msg,
 				       struct spi_replaced_transfers *res);
 /**
@@ -1012,7 +1017,7 @@ extern struct spi_replaced_transfers *spi_replace_transfers(
 
 /* SPI transfer transformation methods */
 
-extern int spi_split_transfers_maxsize(struct spi_master *master,
+extern int spi_split_transfers_maxsize(struct spi_controller *ctlr,
 				       struct spi_message *msg,
 				       size_t maxsize,
 				       gfp_t gfp);
@@ -1026,8 +1031,8 @@ extern int spi_split_transfers_maxsize(struct spi_master *master,
 
 extern int spi_sync(struct spi_device *spi, struct spi_message *message);
 extern int spi_sync_locked(struct spi_device *spi, struct spi_message *message);
-extern int spi_bus_lock(struct spi_master *master);
-extern int spi_bus_unlock(struct spi_master *master);
+extern int spi_bus_lock(struct spi_controller *ctlr);
+extern int spi_bus_unlock(struct spi_controller *ctlr);
 
 /**
  * spi_sync_transfer - synchronous SPI data transfer
@@ -1212,9 +1217,9 @@ struct spi_flash_read_message {
 /* SPI core interface for flash read support */
 static inline bool spi_flash_read_supported(struct spi_device *spi)
 {
-	return spi->master->spi_flash_read &&
-	       (!spi->master->flash_read_supported ||
-	       spi->master->flash_read_supported(spi));
+	return spi->controller->spi_flash_read &&
+	       (!spi->controller->flash_read_supported ||
+	       spi->controller->flash_read_supported(spi));
 }
 
 int spi_flash_read(struct spi_device *spi,
@@ -1247,7 +1252,7 @@ int spi_flash_read(struct spi_device *spi,
  * @irq: Initializes spi_device.irq; depends on how the board is wired.
  * @max_speed_hz: Initializes spi_device.max_speed_hz; based on limits
  *	from the chip datasheet and board-specific signal quality issues.
- * @bus_num: Identifies which spi_master parents the spi_device; unused
+ * @bus_num: Identifies which spi_controller parents the spi_device; unused
  *	by spi_new_device(), and otherwise depends on board wiring.
  * @chip_select: Initializes spi_device.chip_select; depends on how
  *	the board is wired.
@@ -1288,7 +1293,7 @@ struct spi_board_info {
 
 
 	/* bus_num is board specific and matches the bus_num of some
-	 * spi_master that will probably be registered later.
+	 * spi_controller that will probably be registered later.
 	 *
 	 * chip_select reflects how this chip is wired to that master;
 	 * it's less than num_chipselect.
@@ -1322,7 +1327,7 @@ spi_register_board_info(struct spi_board_info const *info, unsigned n)
 /* If you're hotplugging an adapter with devices (parport, usb, etc)
  * use spi_new_device() to describe each device.  You can also call
  * spi_unregister_device() to start making that device vanish, but
- * normally that would be handled by spi_unregister_master().
+ * normally that would be handled by spi_unregister_controller().
  *
  * You can also use spi_alloc_device() and spi_add_device() to use a two
  * stage registration sequence for each spi_device.  This gives the caller
@@ -1331,13 +1336,13 @@ spi_register_board_info(struct spi_board_info const *info, unsigned n)
  * be defined using the board info.
  */
 extern struct spi_device *
-spi_alloc_device(struct spi_master *master);
+spi_alloc_device(struct spi_controller *ctlr);
 
 extern int
 spi_add_device(struct spi_device *spi);
 
 extern struct spi_device *
-spi_new_device(struct spi_master *, struct spi_board_info *);
+spi_new_device(struct spi_controller *, struct spi_board_info *);
 
 extern void spi_unregister_device(struct spi_device *spi);
 
@@ -1345,9 +1350,32 @@ extern const struct spi_device_id *
 spi_get_device_id(const struct spi_device *sdev);
 
 static inline bool
-spi_transfer_is_last(struct spi_master *master, struct spi_transfer *xfer)
+spi_transfer_is_last(struct spi_controller *ctlr, struct spi_transfer *xfer)
 {
-	return list_is_last(&xfer->transfer_list, &master->cur_msg->transfers);
+	return list_is_last(&xfer->transfer_list, &ctlr->cur_msg->transfers);
 }
 
+
+/* Compatibility layer */
+#define spi_master			spi_controller
+
+#define SPI_MASTER_HALF_DUPLEX		SPI_CONTROLLER_HALF_DUPLEX
+#define SPI_MASTER_NO_RX		SPI_CONTROLLER_NO_RX
+#define SPI_MASTER_NO_TX		SPI_CONTROLLER_NO_TX
+#define SPI_MASTER_MUST_RX		SPI_CONTROLLER_MUST_RX
+#define SPI_MASTER_MUST_TX		SPI_CONTROLLER_MUST_TX
+
+#define spi_master_get_devdata(_ctlr)	spi_controller_get_devdata(_ctlr)
+#define spi_master_set_devdata(_ctlr, _data)	\
+	spi_controller_set_devdata(_ctlr, _data)
+#define spi_master_get(_ctlr)		spi_controller_get(_ctlr)
+#define spi_master_put(_ctlr)		spi_controller_put(_ctlr)
+#define spi_master_suspend(_ctlr)	spi_controller_suspend(_ctlr)
+#define spi_master_resume(_ctlr)	spi_controller_resume(_ctlr)
+
+#define spi_register_master(_ctlr)	spi_register_controller(_ctlr)
+#define devm_spi_register_master(_dev, _ctlr) \
+	devm_spi_register_controller(_dev, _ctlr)
+#define spi_unregister_master(_ctlr)	spi_unregister_controller(_ctlr)
+
 #endif /* __LINUX_SPI_H */

commit 6c364062bfed3c34490e85bea52ff6e2d4f0f281
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon May 22 15:11:41 2017 +0200

    spi: core: Add support for registering SPI slave controllers
    
    Add support for registering SPI slave controllers using the existing SPI
    master framework:
      - SPI slave controllers must use spi_alloc_slave() instead of
        spi_alloc_master(), and should provide an additional callback
        "slave_abort" to abort an ongoing SPI transfer request,
      - SPI slave controllers are added to a new "spi_slave" device class,
      - SPI slave handlers can be bound to the SPI slave device represented
        by an SPI slave controller using a DT child node named "slave",
      - Alternatively, (un)binding an SPI slave handler to the SPI slave
        device represented by an SPI slave controller can be done by
        (un)registering the slave device through a sysfs virtual file named
        "slave".
    
    From the point of view of an SPI slave protocol handler, an SPI slave
    controller looks almost like an ordinary SPI master controller. The only
    exception is that a transfer request will block on the remote SPI
    master, and may be cancelled using spi_slave_abort().
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 935bd2854ff1..0a78745e5766 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -29,8 +29,8 @@ struct spi_transfer;
 struct spi_flash_read_message;
 
 /*
- * INTERFACES between SPI master-side drivers and SPI infrastructure.
- * (There's no SPI slave support for Linux yet...)
+ * INTERFACES between SPI master-side drivers and SPI slave protocol handlers,
+ * and SPI infrastructure.
  */
 extern struct bus_type spi_bus_type;
 
@@ -311,6 +311,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @min_speed_hz: Lowest supported transfer speed
  * @max_speed_hz: Highest supported transfer speed
  * @flags: other constraints relevant to this driver
+ * @slave: indicates that this is an SPI slave controller
  * @max_transfer_size: function that returns the max transfer size for
  *	a &spi_device; may be %NULL, so the default %SIZE_MAX will be used.
  * @max_message_size: function that returns the max message size for
@@ -374,6 +375,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @handle_err: the subsystem calls the driver to handle an error that occurs
  *		in the generic implementation of transfer_one_message().
  * @unprepare_message: undo any work done by prepare_message().
+ * @slave_abort: abort the ongoing transfer request on an SPI slave controller
  * @spi_flash_read: to support spi-controller hardwares that provide
  *                  accelerated interface to read from flash devices.
  * @spi_flash_can_dma: analogous to can_dma() interface, but for
@@ -447,6 +449,9 @@ struct spi_master {
 #define SPI_MASTER_MUST_TX      BIT(4)		/* requires tx */
 #define SPI_MASTER_GPIO_SS      BIT(5)		/* GPIO CS must select slave */
 
+	/* flag indicating this is an SPI slave controller */
+	bool			slave;
+
 	/*
 	 * on some hardware transfer / message size may be constrained
 	 * the limit may depend on device transfer settings
@@ -539,6 +544,7 @@ struct spi_master {
 			       struct spi_message *message);
 	int (*unprepare_message)(struct spi_master *master,
 				 struct spi_message *message);
+	int (*slave_abort)(struct spi_master *spi);
 	int (*spi_flash_read)(struct  spi_device *spi,
 			      struct spi_flash_read_message *msg);
 	bool (*spi_flash_can_dma)(struct spi_device *spi,
@@ -595,6 +601,11 @@ static inline void spi_master_put(struct spi_master *master)
 		put_device(&master->dev);
 }
 
+static inline bool spi_controller_is_slave(struct spi_master *ctlr)
+{
+	return IS_ENABLED(CONFIG_SPI_SLAVE) && ctlr->slave;
+}
+
 /* PM calls that need to be issued by the driver */
 extern int spi_master_suspend(struct spi_master *master);
 extern int spi_master_resume(struct spi_master *master);
@@ -605,8 +616,23 @@ extern void spi_finalize_current_message(struct spi_master *master);
 extern void spi_finalize_current_transfer(struct spi_master *master);
 
 /* the spi driver core manages memory for the spi_master classdev */
-extern struct spi_master *
-spi_alloc_master(struct device *host, unsigned size);
+extern struct spi_master *__spi_alloc_controller(struct device *host,
+						 unsigned int size, bool slave);
+
+static inline struct spi_master *spi_alloc_master(struct device *host,
+						  unsigned int size)
+{
+	return __spi_alloc_controller(host, size, false);
+}
+
+static inline struct spi_master *spi_alloc_slave(struct device *host,
+						 unsigned int size)
+{
+	if (!IS_ENABLED(CONFIG_SPI_SLAVE))
+		return NULL;
+
+	return __spi_alloc_controller(host, size, true);
+}
 
 extern int spi_register_master(struct spi_master *master);
 extern int devm_spi_register_master(struct device *dev,
@@ -912,6 +938,7 @@ extern int spi_setup(struct spi_device *spi);
 extern int spi_async(struct spi_device *spi, struct spi_message *message);
 extern int spi_async_locked(struct spi_device *spi,
 			    struct spi_message *message);
+extern int spi_slave_abort(struct spi_device *spi);
 
 static inline size_t
 spi_max_message_size(struct spi_device *spi)

commit 282ec0ea65dab88fda51b5b9b649958ae42f4ac0
Merge: d8f520727f76 c687c46e9e45 251831bd4f49
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Apr 26 15:58:22 2017 +0100

    Merge remote-tracking branches 'spi/topic/ti-qspi' and 'spi/topic/xlp' into spi-next

commit a2d5eda07224680cb711677eff014ea15d809aae
Merge: 2536374352ab f974cf57b1b9 500a32abaf81 fbad6c24396b f72efa7e690a a5b0443c9bf4
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Apr 26 15:58:04 2017 +0100

    Merge remote-tracking branches 'spi/topic/devprop', 'spi/topic/fsl', 'spi/topic/fsl-dspi', 'spi/topic/imx' and 'spi/topic/lantiq' into spi-next

commit 2bca34455b257d75080d87e800ae14afe49001bf
Author: Vignesh R <vigneshr@ti.com>
Date:   Tue Apr 11 17:22:24 2017 +0530

    spi: Add can_dma like interface for spi_flash_read
    
    Add an interface analogous to ->can_dma() for spi_flash_read()
    interface. This will enable SPI controller drivers to inform SPI core
    when not to do DMA mappings.
    
    Signed-off-by: Vignesh R <vigneshr@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 75c6bd0ac605..cd8ae65568e3 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -375,6 +375,8 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @unprepare_message: undo any work done by prepare_message().
  * @spi_flash_read: to support spi-controller hardwares that provide
  *                  accelerated interface to read from flash devices.
+ * @spi_flash_can_dma: analogous to can_dma() interface, but for
+ *		       controllers implementing spi_flash_read.
  * @flash_read_supported: spi device supports flash read
  * @cs_gpios: Array of GPIOs to use as chip select lines; one per CS
  *	number. Any individual value may be -ENOENT for CS lines that
@@ -538,6 +540,8 @@ struct spi_master {
 				 struct spi_message *message);
 	int (*spi_flash_read)(struct  spi_device *spi,
 			      struct spi_flash_read_message *msg);
+	bool (*spi_flash_can_dma)(struct spi_device *spi,
+				  struct spi_flash_read_message *msg);
 	bool (*flash_read_supported)(struct spi_device *spi);
 
 	/*

commit ed77d6bcafd75d247cf3c6ad685aa221cda1b8ba
Author: Emiliano Ingrassia <ingrassia@epigenesys.com>
Date:   Tue Mar 28 09:49:29 2017 +0200

    spi: dynamycally allocated message initialization
    
    Invoke the proper function while initializing
    a dynamically allocated spi_message to avoid
    NULL pointer dereference during resources deallocation.
    
    Signed-off-by: Emiliano Ingrassia <ingrassia@epigenesys.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 75c6bd0ac605..3b0070695375 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -891,7 +891,7 @@ static inline struct spi_message *spi_message_alloc(unsigned ntrans, gfp_t flags
 		unsigned i;
 		struct spi_transfer *t = (struct spi_transfer *)(m + 1);
 
-		INIT_LIST_HEAD(&m->transfers);
+		spi_message_init_no_memset(m);
 		for (i = 0; i < ntrans; i++, t++)
 			spi_message_add_tail(t, m);
 	}

commit 826cf175ed705f70a49d04aca832c1cc9ff048d8
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Feb 28 14:25:18 2017 -0800

    spi: allow attaching device properties to SPI board info
    
    Generic device properties support statically defined property sets. For
    them to be usable, we need to attach these property sets before devices
    are registered and probed. Allowing to attach property list to
    spi_board_info structure will allow non-ACPI non-DT boards switch to using
    generic properties and get rid of custom platform data.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 75c6bd0ac605..5a8c4b24f2dc 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -23,6 +23,7 @@
 #include <linux/scatterlist.h>
 
 struct dma_chan;
+struct property_entry;
 struct spi_master;
 struct spi_transfer;
 struct spi_flash_read_message;
@@ -1209,6 +1210,7 @@ int spi_flash_read(struct spi_device *spi,
  * @modalias: Initializes spi_device.modalias; identifies the driver.
  * @platform_data: Initializes spi_device.platform_data; the particular
  *	data stored there is driver-specific.
+ * @properties: Additional device properties for the device.
  * @controller_data: Initializes spi_device.controller_data; some
  *	controllers need hints about hardware setup, e.g. for DMA.
  * @irq: Initializes spi_device.irq; depends on how the board is wired.
@@ -1241,10 +1243,12 @@ struct spi_board_info {
 	 *
 	 * platform_data goes to spi_device.dev.platform_data,
 	 * controller_data goes to spi_device.controller_data,
+	 * device properties are copied and attached to spi_device,
 	 * irq is copied too
 	 */
 	char		modalias[SPI_NAME_SIZE];
 	const void	*platform_data;
+	const struct property_entry *properties;
 	void		*controller_data;
 	int		irq;
 

commit 8eee6b9dd30d5b20a4c31886057a68bb6a2736c9
Author: Thor Thayer <tthayer@opensource.altera.com>
Date:   Mon Oct 10 09:25:24 2016 -0500

    spi: Add Flag to Enable Slave Select with GPIO Chip Select.
    
    Some SPI masters require slave selection before the transfer
    can begin [1]. The SPI framework currently selects the chip using
    either 1) the internal CS mechanism or 2) the GPIO CS, but not both.
    
    This patch adds a new master->flags define to indicate both the GPIO
    CS and the internal chip select mechanism should be used.
    
    Tested On:
        Altera CycloneV development kit
        Compile tested for build errors on x86_64 (allyesconfigs)
    
    [1] DesignWare dw_apb_ssi Databook, Version 3.20a (page 39)
    
    Signed-off-by: Thor Thayer <tthayer@opensource.altera.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 4b743ac35396..75c6bd0ac605 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -442,6 +442,7 @@ struct spi_master {
 #define SPI_MASTER_NO_TX	BIT(2)		/* can't do buffer write */
 #define SPI_MASTER_MUST_RX      BIT(3)		/* requires rx */
 #define SPI_MASTER_MUST_TX      BIT(4)		/* requires tx */
+#define SPI_MASTER_GPIO_SS      BIT(5)		/* GPIO CS must select slave */
 
 	/*
 	 * on some hardware transfer / message size may be constrained

commit e2df04ed3be123fb53740303779e13748b9f8b65
Merge: a931a189d4f6 604042af7697 446576f9ea53 f75529fd712c dc34b89a8c61 2f58ea64bd89
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Sep 30 09:14:10 2016 -0700

    Merge remote-tracking branches 'spi/topic/fsl-espi', 'spi/topic/imx', 'spi/topic/jcore', 'spi/topic/loopback' and 'spi/topic/meson' into spi-next

commit 323117ab60156d5ef021eeef260c4e7e0a7f520e
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Sep 13 15:38:25 2016 +0200

    spi: core: Use spi_sync_transfer() in spi_write()/spi_read()
    
    Simplify spi_write() and spi_read() using the spi_sync_transfer()
    helper.
    
    This requires moving spi_sync_transfer() up.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 072cb2aa2413..74278c7d0f52 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -979,6 +979,30 @@ extern int spi_sync_locked(struct spi_device *spi, struct spi_message *message);
 extern int spi_bus_lock(struct spi_master *master);
 extern int spi_bus_unlock(struct spi_master *master);
 
+/**
+ * spi_sync_transfer - synchronous SPI data transfer
+ * @spi: device with which data will be exchanged
+ * @xfers: An array of spi_transfers
+ * @num_xfers: Number of items in the xfer array
+ * Context: can sleep
+ *
+ * Does a synchronous SPI data transfer of the given spi_transfer array.
+ *
+ * For more specific semantics see spi_sync().
+ *
+ * Return: Return: zero on success, else a negative error code.
+ */
+static inline int
+spi_sync_transfer(struct spi_device *spi, struct spi_transfer *xfers,
+	unsigned int num_xfers)
+{
+	struct spi_message msg;
+
+	spi_message_init_with_transfers(&msg, xfers, num_xfers);
+
+	return spi_sync(spi, &msg);
+}
+
 /**
  * spi_write - SPI synchronous write
  * @spi: device to which data will be written
@@ -998,11 +1022,8 @@ spi_write(struct spi_device *spi, const void *buf, size_t len)
 			.tx_buf		= buf,
 			.len		= len,
 		};
-	struct spi_message	m;
 
-	spi_message_init(&m);
-	spi_message_add_tail(&t, &m);
-	return spi_sync(spi, &m);
+	return spi_sync_transfer(spi, &t, 1);
 }
 
 /**
@@ -1024,35 +1045,8 @@ spi_read(struct spi_device *spi, void *buf, size_t len)
 			.rx_buf		= buf,
 			.len		= len,
 		};
-	struct spi_message	m;
 
-	spi_message_init(&m);
-	spi_message_add_tail(&t, &m);
-	return spi_sync(spi, &m);
-}
-
-/**
- * spi_sync_transfer - synchronous SPI data transfer
- * @spi: device with which data will be exchanged
- * @xfers: An array of spi_transfers
- * @num_xfers: Number of items in the xfer array
- * Context: can sleep
- *
- * Does a synchronous SPI data transfer of the given spi_transfer array.
- *
- * For more specific semantics see spi_sync().
- *
- * Return: Return: zero on success, else a negative error code.
- */
-static inline int
-spi_sync_transfer(struct spi_device *spi, struct spi_transfer *xfers,
-	unsigned int num_xfers)
-{
-	struct spi_message msg;
-
-	spi_message_init_with_transfers(&msg, xfers, num_xfers);
-
-	return spi_sync(spi, &msg);
+	return spi_sync_transfer(spi, &t, 1);
 }
 
 /* this copies txbuf and rxbuf data; for small transfers only! */

commit 5090cc6ae2f79ee779e5faf7c8a28edf42b7d738
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Aug 17 21:08:01 2016 +0200

    spi: introduce max_message_size hook in spi_master
    
    Recently a maximum transfer size was was introduced in struct spi_master.
    However there are also spi controllers with a maximum message size, e.g.
    fsl-espi has a max message size of 64KB.
    Introduce a hook max_message_size to deal with such limitations.
    
    Also make sure that spi_max_transfer_size doesn't return greater values
    than spi_max_message_size, even if hook max_transfer_size is not set.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 072cb2aa2413..f2d3960cc3c3 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -312,6 +312,8 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @flags: other constraints relevant to this driver
  * @max_transfer_size: function that returns the max transfer size for
  *	a &spi_device; may be %NULL, so the default %SIZE_MAX will be used.
+ * @max_message_size: function that returns the max message size for
+ *	a &spi_device; may be %NULL, so the default %SIZE_MAX will be used.
  * @io_mutex: mutex for physical bus access
  * @bus_lock_spinlock: spinlock for SPI bus locking
  * @bus_lock_mutex: mutex for exclusion of multiple callers
@@ -442,10 +444,11 @@ struct spi_master {
 #define SPI_MASTER_MUST_TX      BIT(4)		/* requires tx */
 
 	/*
-	 * on some hardware transfer size may be constrained
+	 * on some hardware transfer / message size may be constrained
 	 * the limit may depend on device transfer settings
 	 */
 	size_t (*max_transfer_size)(struct spi_device *spi);
+	size_t (*max_message_size)(struct spi_device *spi);
 
 	/* I/O mutex */
 	struct mutex		io_mutex;
@@ -905,12 +908,26 @@ extern int spi_async_locked(struct spi_device *spi,
 			    struct spi_message *message);
 
 static inline size_t
-spi_max_transfer_size(struct spi_device *spi)
+spi_max_message_size(struct spi_device *spi)
 {
 	struct spi_master *master = spi->master;
-	if (!master->max_transfer_size)
+	if (!master->max_message_size)
 		return SIZE_MAX;
-	return master->max_transfer_size(spi);
+	return master->max_message_size(spi);
+}
+
+static inline size_t
+spi_max_transfer_size(struct spi_device *spi)
+{
+	struct spi_master *master = spi->master;
+	size_t tr_max = SIZE_MAX;
+	size_t msg_max = spi_max_message_size(spi);
+
+	if (master->max_transfer_size)
+		tr_max = master->max_transfer_size(spi);
+
+	/* transfer size limit must not be greater than messsage size limit */
+	return min(tr_max, msg_max);
 }
 
 /*---------------------------------------------------------------------------*/

commit ef4d96ec4ad947360f48677b6007a4c77953b090
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Jul 21 23:53:31 2016 +0100

    spi: Split bus and I/O locking
    
    The current SPI code attempts to use bus_lock_mutex for two purposes. One
    is to implement spi_bus_lock() which grants exclusive access to the bus.
    The other is to serialize access to the physical hardware. This duplicate
    purpose causes confusion which leads to cases where access is not locked
    when a caller holds the bus lock mutex. Fix this by splitting out the I/O
    functionality into a new io_mutex.
    
    This means taking both mutexes in the DMA path, replacing the existing
    mutex with the new I/O one in the message pump (the mutex now always
    being taken in the message pump) and taking the bus lock mutex in
    spi_sync(), allowing __spi_sync() to have no mutex handling.
    
    While we're at it hoist the mutex further up the message pump before we
    power up the device so that all power up/down of the block is covered by
    it and there are no races with in-line pumping of messages.
    
    Reported-by: Rich Felker <dalias@libc.org>
    Tested-by: Rich Felker <dalias@libc.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 7b53af4ba5f8..072cb2aa2413 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -312,8 +312,9 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @flags: other constraints relevant to this driver
  * @max_transfer_size: function that returns the max transfer size for
  *	a &spi_device; may be %NULL, so the default %SIZE_MAX will be used.
+ * @io_mutex: mutex for physical bus access
  * @bus_lock_spinlock: spinlock for SPI bus locking
- * @bus_lock_mutex: mutex for SPI bus locking
+ * @bus_lock_mutex: mutex for exclusion of multiple callers
  * @bus_lock_flag: indicates that the SPI bus is locked for exclusive use
  * @setup: updates the device mode and clocking records used by a
  *	device's SPI controller; protocol code may call this.  This
@@ -446,6 +447,9 @@ struct spi_master {
 	 */
 	size_t (*max_transfer_size)(struct spi_device *spi);
 
+	/* I/O mutex */
+	struct mutex		io_mutex;
+
 	/* lock and mutex for SPI bus locking */
 	spinlock_t		bus_lock_spinlock;
 	struct mutex		bus_lock_mutex;

commit f4502dd1da9b060a49d539eb754ff86cb97b89f0
Author: Vignesh R <vigneshr@ti.com>
Date:   Wed Jun 8 12:18:31 2016 +0530

    spi: Add DMA support for spi_flash_read()
    
    Few SPI devices provide accelerated read interfaces to read from
    SPI-NOR flash devices. These hardwares also support DMA to transfer data
    from flash to memory either via mem-to-mem DMA or dedicated slave DMA
    channels. Hence, add support for DMA in order to improve throughput and
    reduce CPU load.
    Use spi_map_buf() to get sg table for the buffer and pass it to SPI
    driver.
    
    Signed-off-by: Vignesh R <vigneshr@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 1f03483f61e5..7b53af4ba5f8 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -1143,6 +1143,8 @@ static inline ssize_t spi_w8r16be(struct spi_device *spi, u8 cmd)
  * @opcode_nbits: number of lines to send opcode
  * @addr_nbits: number of lines to send address
  * @data_nbits: number of lines for data
+ * @rx_sg: Scatterlist for receive data read from flash
+ * @cur_msg_mapped: message has been mapped for DMA
  */
 struct spi_flash_read_message {
 	void *buf;
@@ -1155,6 +1157,8 @@ struct spi_flash_read_message {
 	u8 opcode_nbits;
 	u8 addr_nbits;
 	u8 data_nbits;
+	struct sg_table rx_sg;
+	bool cur_msg_mapped;
 };
 
 /* SPI core interface for flash read support */

commit 7ba2f2757d84eae533679306f03c93c118437a87
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sat Apr 23 22:47:08 2016 +0200

    spi: core: add hook flash_read_supported to spi_master
    
    If hook spi_flash_read is implemented the fast flash read feature
    is enabled for all devices attached to the respective master.
    
    In most cases there is just one flash chip, however there are also
    devices with more than one flash chip, namely some WiFi routers.
    Then the fast flash read feature can be used for the first chip only.
    OpenWRT implemented an own handling of this case, using controller_data
    element of spi_device to hold the information whether fast flash read
    can be used for a device.
    
    This patch adds hook flash_read_supported to spi_master which is
    used to extend spi_flash_read_supported() by checking whether the
    fast flash read feature can be used for a specific spi_device.
    
    If the hook is not implemented the default behavior is to allow
    fast flash read for all devices (if spi_flash_read is implemented).
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 857a9a1d82b5..1f03483f61e5 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -372,6 +372,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @unprepare_message: undo any work done by prepare_message().
  * @spi_flash_read: to support spi-controller hardwares that provide
  *                  accelerated interface to read from flash devices.
+ * @flash_read_supported: spi device supports flash read
  * @cs_gpios: Array of GPIOs to use as chip select lines; one per CS
  *	number. Any individual value may be -ENOENT for CS lines that
  *	are not GPIOs (driven by the SPI controller itself).
@@ -529,6 +530,7 @@ struct spi_master {
 				 struct spi_message *message);
 	int (*spi_flash_read)(struct  spi_device *spi,
 			      struct spi_flash_read_message *msg);
+	bool (*flash_read_supported)(struct spi_device *spi);
 
 	/*
 	 * These hooks are for drivers that use a generic implementation
@@ -1158,7 +1160,9 @@ struct spi_flash_read_message {
 /* SPI core interface for flash read support */
 static inline bool spi_flash_read_supported(struct spi_device *spi)
 {
-	return spi->master->spi_flash_read ? true : false;
+	return spi->master->spi_flash_read &&
+	       (!spi->master->flash_read_supported ||
+	       spi->master->flash_read_supported(spi));
 }
 
 int spi_flash_read(struct spi_device *spi,

commit c508709bcffb644afbf5e5016fc7c90bf80c30ff
Merge: b9facea19b63 d6497816836d 108b5c8bba6b 3aec3166739e 4dea6c9b0b64 82b3aea65f9f
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Mar 11 14:28:53 2016 +0700

    Merge remote-tracking branches 'spi/topic/res', 'spi/topic/rockchip', 'spi/topic/sh', 'spi/topic/ti-qspi' and 'spi/topic/xilinx' into spi-next

commit b9facea19b6382b3f24edd25ec5d9a84f93e9f3b
Merge: f91c75d6faef 14a20428e2e0 10f11a2238d4 22640c8a2736 590745017ef3
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Mar 11 14:28:43 2016 +0700

    Merge remote-tracking branches 'spi/topic/lp8841', 'spi/topic/msg', 'spi/topic/pl022' and 'spi/topic/pxa2xx' into spi-next

commit f91c75d6faefdded97d2ecbe8c4f9cf197f68110
Merge: 6beb9fecbde4 ee7683a31683 2f6fdefb3503 49023d2e4ead
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Mar 11 14:28:35 2016 +0700

    Merge remote-tracking branches 'spi/topic/doc', 'spi/topic/dw' and 'spi/topic/flash' into spi-next

commit 6beb9fecbde45f09ea79a67ed5fd8d17e3bf6213
Merge: ce7fb74f546c a0a90718f182 b1353d1c1d45 763dedfcda5f e9dd4edcc985
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Mar 11 14:28:25 2016 +0700

    Merge remote-tracking branches 'spi/topic/acpi', 'spi/topic/axi-engine', 'spi/topic/bcm2835' and 'spi/topic/bcm2835aux' into spi-next

commit c76d9ae415f1a80489a76ea41620c3f17383b7fb
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Thu Mar 10 15:01:13 2016 -0300

    spi: Fix htmldocs build error due struct spi_replaced_transfers
    
    The kernel-doc has to be just before the structure definition but the one
    for struct spi_replaced_transfers was before a structure declaration and
    that confuses kernel-doc which complains with the following build error:
    
    .//include/linux/spi/spi.h:933: error: Cannot parse struct or union!
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 3c02b4d06268..1fc33db4347f 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -898,6 +898,10 @@ spi_max_transfer_size(struct spi_device *spi)
 
 /* SPI transfer replacement methods which make use of spi_res */
 
+struct spi_replaced_transfers;
+typedef void (*spi_replaced_release_t)(struct spi_master *master,
+				       struct spi_message *msg,
+				       struct spi_replaced_transfers *res);
 /**
  * struct spi_replaced_transfers - structure describing the spi_transfer
  *                                 replacements that have occurred
@@ -917,10 +921,6 @@ spi_max_transfer_size(struct spi_device *spi)
  * if some extra allocation is requested, so alignment will be the same
  * as for spi_transfers
  */
-struct spi_replaced_transfers;
-typedef void (*spi_replaced_release_t)(struct spi_master *master,
-				       struct spi_message *msg,
-				       struct spi_replaced_transfers *res);
 struct spi_replaced_transfers {
 	spi_replaced_release_t release;
 	void *extradata;

commit d6497816836da321a46c0e8575c4fa3d0c672bda
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Thu Feb 18 15:53:10 2016 +0000

    spi: docbook: fix parsing error
    
    Fixes docbook parsing error because documentation
    is not directly followed by the structure, but typedef
    used in structure.
    
    Reordering should solve that issue.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 38204b584dc5..5396ee5fc51f 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -586,6 +586,10 @@ extern struct spi_master *spi_busnum_to_master(u16 busnum);
  * SPI resource management while processing a SPI message
  */
 
+typedef void (*spi_res_release_t)(struct spi_master *master,
+				  struct spi_message *msg,
+				  void *res);
+
 /**
  * struct spi_res - spi resource management structure
  * @entry:   list entry
@@ -595,9 +599,6 @@ extern struct spi_master *spi_busnum_to_master(u16 busnum);
  * this is based on ideas from devres, but focused on life-cycle
  * management during spi_message processing
  */
-typedef void (*spi_res_release_t)(struct spi_master *master,
-				  struct spi_message *msg,
-				  void *res);
 struct spi_res {
 	struct list_head        entry;
 	spi_res_release_t       release;

commit 556351f14e74db4cd3ddde386457edce7bf0b27f
Author: Vignesh R <vigneshr@ti.com>
Date:   Fri Dec 11 09:39:56 2015 +0530

    spi: introduce accelerated read support for spi flash devices
    
    In addition to providing direct access to SPI bus, some spi controller
    hardwares (like ti-qspi) provide special port (like memory mapped port)
    that are optimized to improve SPI flash read performance.
    This means the controller can automatically send the SPI signals
    required to read data from the SPI flash device.
    For this, SPI controller needs to know flash specific information like
    read command to use, dummy bytes and address width.
    
    Introduce spi_flash_read() interface to support accelerated read
    over SPI flash devices. SPI master drivers can implement this callback to
    support interfaces such as memory mapped read etc. m25p80 flash driver
    and other flash drivers can call this make use of such interfaces. The
    interface should only be used with SPI flashes and cannot be used with
    other SPI devices.
    
    Signed-off-by: Vignesh R <vigneshr@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 53be3a4c60cb..ba0dee9d05a3 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -25,6 +25,7 @@
 struct dma_chan;
 struct spi_master;
 struct spi_transfer;
+struct spi_flash_read_message;
 
 /*
  * INTERFACES between SPI master-side drivers and SPI infrastructure.
@@ -361,6 +362,8 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @handle_err: the subsystem calls the driver to handle an error that occurs
  *		in the generic implementation of transfer_one_message().
  * @unprepare_message: undo any work done by prepare_message().
+ * @spi_flash_read: to support spi-controller hardwares that provide
+ *                  accelerated interface to read from flash devices.
  * @cs_gpios: Array of GPIOs to use as chip select lines; one per CS
  *	number. Any individual value may be -ENOENT for CS lines that
  *	are not GPIOs (driven by the SPI controller itself).
@@ -513,6 +516,8 @@ struct spi_master {
 			       struct spi_message *message);
 	int (*unprepare_message)(struct spi_master *master,
 				 struct spi_message *message);
+	int (*spi_flash_read)(struct  spi_device *spi,
+			      struct spi_flash_read_message *msg);
 
 	/*
 	 * These hooks are for drivers that use a generic implementation
@@ -1019,6 +1024,42 @@ static inline ssize_t spi_w8r16be(struct spi_device *spi, u8 cmd)
 	return be16_to_cpu(result);
 }
 
+/**
+ * struct spi_flash_read_message - flash specific information for
+ * spi-masters that provide accelerated flash read interfaces
+ * @buf: buffer to read data
+ * @from: offset within the flash from where data is to be read
+ * @len: length of data to be read
+ * @retlen: actual length of data read
+ * @read_opcode: read_opcode to be used to communicate with flash
+ * @addr_width: number of address bytes
+ * @dummy_bytes: number of dummy bytes
+ * @opcode_nbits: number of lines to send opcode
+ * @addr_nbits: number of lines to send address
+ * @data_nbits: number of lines for data
+ */
+struct spi_flash_read_message {
+	void *buf;
+	loff_t from;
+	size_t len;
+	size_t retlen;
+	u8 read_opcode;
+	u8 addr_width;
+	u8 dummy_bytes;
+	u8 opcode_nbits;
+	u8 addr_nbits;
+	u8 data_nbits;
+};
+
+/* SPI core interface for flash read support */
+static inline bool spi_flash_read_supported(struct spi_device *spi)
+{
+	return spi->master->spi_flash_read ? true : false;
+}
+
+int spi_flash_read(struct spi_device *spi,
+		   struct spi_flash_read_message *msg);
+
 /*---------------------------------------------------------------------------*/
 
 /*

commit d9f1212272818420fcde611a940c1ad611a8b785
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Mon Dec 14 15:20:20 2015 +0000

    spi: core: add spi_split_transfers_maxsize
    
    Add spi_split_transfers_maxsize method that splits
    spi_transfers transparently into multiple transfers
    that are below the given max-size.
    
    This makes use of the spi_res framework via
    spi_replace_transfers to allocate/free the extra
    transfers as well as reverting back the changes applied
    while processing the spi_message.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index d71385756fee..3c02b4d06268 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -53,6 +53,10 @@ extern struct bus_type spi_bus_type;
  *
  * @transfer_bytes_histo:
  *                 transfer bytes histogramm
+ *
+ * @transfers_split_maxsize:
+ *                 number of transfers that have been split because of
+ *                 maxsize limit
  */
 struct spi_statistics {
 	spinlock_t		lock; /* lock for the whole structure */
@@ -72,6 +76,8 @@ struct spi_statistics {
 
 #define SPI_STATISTICS_HISTO_SIZE 17
 	unsigned long transfer_bytes_histo[SPI_STATISTICS_HISTO_SIZE];
+
+	unsigned long transfers_split_maxsize;
 };
 
 void spi_statistics_add_transfer_stats(struct spi_statistics *stats,
@@ -935,6 +941,15 @@ extern struct spi_replaced_transfers *spi_replace_transfers(
 
 /*---------------------------------------------------------------------------*/
 
+/* SPI transfer transformation methods */
+
+extern int spi_split_transfers_maxsize(struct spi_master *master,
+				       struct spi_message *msg,
+				       size_t maxsize,
+				       gfp_t gfp);
+
+/*---------------------------------------------------------------------------*/
+
 /* All these synchronous SPI transfer routines are utilities layered
  * over the core async transfer primitive.  Here, "synchronous" means
  * they will sleep uninterruptibly until the async transfer completes.

commit 523baf5a0609690cb742b3662b7ccac0ea0b2ef2
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Mon Dec 14 15:20:19 2015 +0000

    spi: core: add spi_replace_transfers method
    
    Add the spi_replace_transfers method that can get used
    to replace some spi_transfers from a spi_message with other
    transfers.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 38204b584dc5..d71385756fee 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -890,6 +890,51 @@ spi_max_transfer_size(struct spi_device *spi)
 
 /*---------------------------------------------------------------------------*/
 
+/* SPI transfer replacement methods which make use of spi_res */
+
+/**
+ * struct spi_replaced_transfers - structure describing the spi_transfer
+ *                                 replacements that have occurred
+ *                                 so that they can get reverted
+ * @release:            some extra release code to get executed prior to
+ *                      relasing this structure
+ * @extradata:          pointer to some extra data if requested or NULL
+ * @replaced_transfers: transfers that have been replaced and which need
+ *                      to get restored
+ * @replaced_after:     the transfer after which the @replaced_transfers
+ *                      are to get re-inserted
+ * @inserted:           number of transfers inserted
+ * @inserted_transfers: array of spi_transfers of array-size @inserted,
+ *                      that have been replacing replaced_transfers
+ *
+ * note: that @extradata will point to @inserted_transfers[@inserted]
+ * if some extra allocation is requested, so alignment will be the same
+ * as for spi_transfers
+ */
+struct spi_replaced_transfers;
+typedef void (*spi_replaced_release_t)(struct spi_master *master,
+				       struct spi_message *msg,
+				       struct spi_replaced_transfers *res);
+struct spi_replaced_transfers {
+	spi_replaced_release_t release;
+	void *extradata;
+	struct list_head replaced_transfers;
+	struct list_head *replaced_after;
+	size_t inserted;
+	struct spi_transfer inserted_transfers[];
+};
+
+extern struct spi_replaced_transfers *spi_replace_transfers(
+	struct spi_message *msg,
+	struct spi_transfer *xfer_first,
+	size_t remove,
+	size_t insert,
+	spi_replaced_release_t release,
+	size_t extradatasize,
+	gfp_t gfp);
+
+/*---------------------------------------------------------------------------*/
+
 /* All these synchronous SPI transfer routines are utilities layered
  * over the core async transfer primitive.  Here, "synchronous" means
  * they will sleep uninterruptibly until the async transfer completes.

commit d780c3711d9df9bacd56b71cf23443b895a331ca
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Mon Dec 14 15:20:18 2015 +0000

    spi: core: added spi_resource management
    
    SPI resource management framework used while processing a spi_message
    via the spi-core.
    
    The basic idea is taken from devres, but as the allocation may happen
    fairly frequently, some provisioning (in the form of an unused spi_device
    pointer argument to spi_res_alloc) has been made so that at a later stage
    we may implement reuse objects allocated earlier avoiding the repeated
    allocation by keeping a cache of objects that we can reuse.
    
    This framework can get used for:
    * rewriting spi_messages
      * to fullfill alignment requirements of the spi_master HW
      * to fullfill transfer length requirements
        (e.g: transfers need to be less than 64k)
      * consolidate spi_messages with multiple transfers into a single transfer
      when the total transfer length is below a threshold.
    * reimplement spi_unmap_buf without explicitly needing to check if it has
      been mapped
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 53be3a4c60cb..38204b584dc5 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -582,6 +582,37 @@ extern void spi_unregister_master(struct spi_master *master);
 
 extern struct spi_master *spi_busnum_to_master(u16 busnum);
 
+/*
+ * SPI resource management while processing a SPI message
+ */
+
+/**
+ * struct spi_res - spi resource management structure
+ * @entry:   list entry
+ * @release: release code called prior to freeing this resource
+ * @data:    extra data allocated for the specific use-case
+ *
+ * this is based on ideas from devres, but focused on life-cycle
+ * management during spi_message processing
+ */
+typedef void (*spi_res_release_t)(struct spi_master *master,
+				  struct spi_message *msg,
+				  void *res);
+struct spi_res {
+	struct list_head        entry;
+	spi_res_release_t       release;
+	unsigned long long      data[]; /* guarantee ull alignment */
+};
+
+extern void *spi_res_alloc(struct spi_device *spi,
+			   spi_res_release_t release,
+			   size_t size, gfp_t gfp);
+extern void spi_res_add(struct spi_message *message, void *res);
+extern void spi_res_free(void *res);
+
+extern void spi_res_release(struct spi_master *master,
+			    struct spi_message *message);
+
 /*---------------------------------------------------------------------------*/
 
 /*
@@ -720,6 +751,7 @@ struct spi_transfer {
  * @status: zero for success, else negative errno
  * @queue: for use by whichever driver currently owns the message
  * @state: for use by whichever driver currently owns the message
+ * @resources: for resource management when the spi message is processed
  *
  * A @spi_message is used to execute an atomic sequence of data transfers,
  * each represented by a struct spi_transfer.  The sequence is "atomic"
@@ -766,11 +798,15 @@ struct spi_message {
 	 */
 	struct list_head	queue;
 	void			*state;
+
+	/* list of spi_res reources when the spi message is processed */
+	struct list_head        resources;
 };
 
 static inline void spi_message_init_no_memset(struct spi_message *m)
 {
 	INIT_LIST_HEAD(&m->transfers);
+	INIT_LIST_HEAD(&m->resources);
 }
 
 static inline void spi_message_init(struct spi_message *m)

commit a0a90718f18264dc904d34a580f332006f5561e9
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Feb 8 17:14:28 2016 +0200

    spi: Let drivers translate ACPI DeviceSelection to suitable Linux chip select
    
    In Windows it is up to the SPI host controller driver to handle the ACPI
    DeviceSelection as it likes. The SPI core does not take any part in it.
    This is different in Linux because we always expect to have chip select in
    range of 0 .. master->num_chipselect - 1.
    
    In order to support this in Linux we need a way to allow the driver to
    translate between ACPI DeviceSelection field and Linux chip select number
    so provide a new optional hook ->fw_translate_cs() that can be used by a
    driver to handle translation and call this hook if set during SPI slave
    ACPI enumeration.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 53be3a4c60cb..8a25e6c2fb56 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -369,6 +369,9 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @dma_rx: DMA receive channel
  * @dummy_rx: dummy receive buffer for full-duplex devices
  * @dummy_tx: dummy transmit buffer for full-duplex devices
+ * @fw_translate_cs: If the boot firmware uses different numbering scheme
+ *	what Linux expects, this optional hook can be used to translate
+ *	between the two.
  *
  * Each SPI master controller can communicate with one or more @spi_device
  * children.  These make a small bus, sharing MOSI, MISO and SCK signals
@@ -537,6 +540,8 @@ struct spi_master {
 	/* dummy data for full duplex devices */
 	void			*dummy_rx;
 	void			*dummy_tx;
+
+	int (*fw_translate_cs)(struct spi_master *master, unsigned cs);
 };
 
 static inline void *spi_master_get_devdata(struct spi_master *master)

commit ee7683a31683c6368a66a83c555600dfd704e543
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Fri Feb 5 17:31:39 2016 -0800

    spi: Document max_transfer_size
    
    Fix kernel-doc warning for missing struct field notation.
    
    ..//include/linux/spi/spi.h:540: warning: No description found for parameter 'max_transfer_size'
    
    [Meaningful subject -- broonie]
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 53be3a4c60cb..e9290c335cc4 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -303,6 +303,8 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @min_speed_hz: Lowest supported transfer speed
  * @max_speed_hz: Highest supported transfer speed
  * @flags: other constraints relevant to this driver
+ * @max_transfer_size: function that returns the max transfer size for
+ *	a &spi_device; may be %NULL, so the default %SIZE_MAX will be used.
  * @bus_lock_spinlock: spinlock for SPI bus locking
  * @bus_lock_mutex: mutex for SPI bus locking
  * @bus_lock_flag: indicates that the SPI bus is locked for exclusive use

commit 4f9530705b7b9c977044accb035682d9f7df1cdd
Merge: 41d5a700514f bd6c1644a2f6 d599af65fda3 cc023478dc8a ec7f9eb4bea2 edd3899c8cd2
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Jan 11 16:48:35 2016 +0000

    Merge remote-tracking branches 'spi/topic/overlay', 'spi/topic/pxa2xx', 'spi/topic/s3c64xx', 'spi/topic/sh-msiof' and 'spi/topic/spidev' into spi-next

commit 41d5a700514f133991db0d9d135e597b88b09775
Merge: 635b9b2e6e17 22de54a9b929 8caad1da223c 15bcdefdc71a 2f538c017e1a
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Jan 11 16:48:33 2016 +0000

    Merge remote-tracking branches 'spi/topic/lm70llp', 'spi/topic/loopback', 'spi/topic/mtk' and 'spi/topic/omap2-mcspi' into spi-next

commit 4acad4aae10d1fa79a075b38b5c73772c44f576c
Author: Michal Suchanek <hramrach@gmail.com>
Date:   Wed Dec 2 10:38:21 2015 +0000

    spi: expose master transfer size limitation.
    
    On some SPI controllers it is not feasible to transfer arbitrary amount
    of data at once.
    
    When the limit on transfer size is a few kilobytes at least it makes
    sense to use the SPI hardware rather than reverting to gpio driver.
    
    The protocol drivers need a way to check that they do not sent overly
    long messages, though.
    
    Signed-off-by: Michal Suchanek <hramrach@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index cce80e6dc7d1..3eebc6c235fb 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -425,6 +425,12 @@ struct spi_master {
 #define SPI_MASTER_MUST_RX      BIT(3)		/* requires rx */
 #define SPI_MASTER_MUST_TX      BIT(4)		/* requires tx */
 
+	/*
+	 * on some hardware transfer size may be constrained
+	 * the limit may depend on device transfer settings
+	 */
+	size_t (*max_transfer_size)(struct spi_device *spi);
+
 	/* lock and mutex for SPI bus locking */
 	spinlock_t		bus_lock_spinlock;
 	struct mutex		bus_lock_mutex;
@@ -832,6 +838,15 @@ extern int spi_async(struct spi_device *spi, struct spi_message *message);
 extern int spi_async_locked(struct spi_device *spi,
 			    struct spi_message *message);
 
+static inline size_t
+spi_max_transfer_size(struct spi_device *spi)
+{
+	struct spi_master *master = spi->master;
+	if (!master->max_transfer_size)
+		return SIZE_MAX;
+	return master->max_transfer_size(spi);
+}
+
 /*---------------------------------------------------------------------------*/
 
 /* All these synchronous SPI transfer routines are utilities layered

commit 49ddedf3bfcb59a562c7db0e50aecd1422e9cdc9
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Fri Nov 27 13:56:03 2015 +0000

    spi: add spi_message_init_no_memset to avoid zeroing the spi_message
    
    In the spi_loopback_test driver there is the need to initialize
    a spi_message that is filled with values from a static structure.
    
    Applying spi_message_init to such a prefilled structure results in
    all the settings getting reset to zero, which is not what we want.
    Copying each field of spi_message separately instead always includes
    the risk that some new fields have not been implemented in the copying
    code.
    
    So here we introduce a version of spi_message_init called
    spi_message_init_no_memset that does not fill the structure
    with zero first, but only initializes the relevant list_heads.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index cce80e6dc7d1..4c54d4744107 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -762,10 +762,15 @@ struct spi_message {
 	void			*state;
 };
 
+static inline void spi_message_init_no_memset(struct spi_message *m)
+{
+	INIT_LIST_HEAD(&m->transfers);
+}
+
 static inline void spi_message_init(struct spi_message *m)
 {
 	memset(m, 0, sizeof *m);
-	INIT_LIST_HEAD(&m->transfers);
+	spi_message_init_no_memset(m);
 }
 
 static inline void

commit 3b1884c24c98dada51fc4b05735773f0078711d2
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Nov 30 15:28:06 2015 +0100

    spi: Uninline spi_unregister_device()
    
    Uninline spi_unregister_device() in preparation of adding more code to
    it. Add kerneldoc documentation while we're at it.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index cce80e6dc7d1..075bede66521 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -1115,12 +1115,7 @@ spi_add_device(struct spi_device *spi);
 extern struct spi_device *
 spi_new_device(struct spi_master *, struct spi_board_info *);
 
-static inline void
-spi_unregister_device(struct spi_device *spi)
-{
-	if (spi)
-		device_unregister(&spi->dev);
-}
+extern void spi_unregister_device(struct spi_device *spi);
 
 extern const struct spi_device_id *
 spi_get_device_id(const struct spi_device *sdev);

commit 4c84518523f888994c618585021c76fa499d465e
Merge: fc579056af0b 76f67ea9bf27 160f8d069165 3821a065f567 54bf4505bd64 0db642151ad8
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Nov 4 11:02:12 2015 +0000

    Merge remote-tracking branches 'spi/topic/omap-100k', 'spi/topic/omap-uwire', 'spi/topic/owner', 'spi/topic/pxa' and 'spi/topic/pxa2xx' into spi-next

commit ca5d24854210dd02548a080d4271560e926c4fcb
Author: Andrew F. Davis <afd@ti.com>
Date:   Fri Oct 23 08:59:10 2015 -0500

    spi: Add THIS_MODULE to spi_driver in SPI core
    
    Add spi_register_driver helper macro that adds THIS_MODULE to
    spi_driver for the registering driver. We rename and modify
    the existing spi_register_driver to enable this.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 269e8afd3e2a..e2da17b5900e 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -250,7 +250,7 @@ static inline struct spi_driver *to_spi_driver(struct device_driver *drv)
 	return drv ? container_of(drv, struct spi_driver, driver) : NULL;
 }
 
-extern int spi_register_driver(struct spi_driver *sdrv);
+extern int __spi_register_driver(struct module *owner, struct spi_driver *sdrv);
 
 /**
  * spi_unregister_driver - reverse effect of spi_register_driver
@@ -263,6 +263,10 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
 		driver_unregister(&sdrv->driver);
 }
 
+/* use a define to avoid include chaining to get THIS_MODULE */
+#define spi_register_driver(driver) \
+	__spi_register_driver(THIS_MODULE, driver)
+
 /**
  * module_spi_driver() - Helper macro for registering a SPI driver
  * @__spi_driver: spi_driver struct

commit a1fdeaa71c95e5c6eba40245f84f762202dc69bb
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Thu Oct 22 18:59:22 2015 +0200

    spi: fix kernel-doc warnings about missing return desc in spi.h
    
    When building docs with make htmldocs, warnings about not having
    a description for the return value are reported, i.e:
    
    warning: No description found for return value of 'spi_write'
    
    Fix these by following the kernel-doc conventions explained in
    Documentation/kernel-doc-nano-HOWTO.txt.
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index e1f21778cb54..635bff60eda5 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -847,8 +847,10 @@ extern int spi_bus_unlock(struct spi_master *master);
  * @len: data buffer size
  * Context: can sleep
  *
- * This writes the buffer and returns zero or a negative error code.
+ * This function writes the buffer @buf.
  * Callable only from contexts that can sleep.
+ *
+ * Return: zero on success, else a negative error code.
  */
 static inline int
 spi_write(struct spi_device *spi, const void *buf, size_t len)
@@ -871,8 +873,10 @@ spi_write(struct spi_device *spi, const void *buf, size_t len)
  * @len: data buffer size
  * Context: can sleep
  *
- * This reads the buffer and returns zero or a negative error code.
+ * This function reads the buffer @buf.
  * Callable only from contexts that can sleep.
+ *
+ * Return: zero on success, else a negative error code.
  */
 static inline int
 spi_read(struct spi_device *spi, void *buf, size_t len)
@@ -899,7 +903,7 @@ spi_read(struct spi_device *spi, void *buf, size_t len)
  *
  * For more specific semantics see spi_sync().
  *
- * It returns zero on success, else a negative error code.
+ * Return: Return: zero on success, else a negative error code.
  */
 static inline int
 spi_sync_transfer(struct spi_device *spi, struct spi_transfer *xfers,
@@ -923,9 +927,10 @@ extern int spi_write_then_read(struct spi_device *spi,
  * @cmd: command to be written before data is read back
  * Context: can sleep
  *
- * This returns the (unsigned) eight bit number returned by the
- * device, or else a negative error code.  Callable only from
- * contexts that can sleep.
+ * Callable only from contexts that can sleep.
+ *
+ * Return: the (unsigned) eight bit number returned by the
+ * device, or else a negative error code.
  */
 static inline ssize_t spi_w8r8(struct spi_device *spi, u8 cmd)
 {
@@ -944,12 +949,13 @@ static inline ssize_t spi_w8r8(struct spi_device *spi, u8 cmd)
  * @cmd: command to be written before data is read back
  * Context: can sleep
  *
- * This returns the (unsigned) sixteen bit number returned by the
- * device, or else a negative error code.  Callable only from
- * contexts that can sleep.
- *
  * The number is returned in wire-order, which is at least sometimes
  * big-endian.
+ *
+ * Callable only from contexts that can sleep.
+ *
+ * Return: the (unsigned) sixteen bit number returned by the
+ * device, or else a negative error code.
  */
 static inline ssize_t spi_w8r16(struct spi_device *spi, u8 cmd)
 {
@@ -968,13 +974,13 @@ static inline ssize_t spi_w8r16(struct spi_device *spi, u8 cmd)
  * @cmd: command to be written before data is read back
  * Context: can sleep
  *
- * This returns the (unsigned) sixteen bit number returned by the device in cpu
- * endianness, or else a negative error code. Callable only from contexts that
- * can sleep.
- *
  * This function is similar to spi_w8r16, with the exception that it will
  * convert the read 16 bit data word from big-endian to native endianness.
  *
+ * Callable only from contexts that can sleep.
+ *
+ * Return: the (unsigned) sixteen bit number returned by the device in cpu
+ * endianness, or else a negative error code.
  */
 static inline ssize_t spi_w8r16be(struct spi_device *spi, u8 cmd)
 

commit 0dc9631221c95cc5ba31c115bf21c9b156aab253
Merge: 7379047d5585 243f07be2423 6b7bc0618ff1
Author: Mark Brown <broonie@kernel.org>
Date:   Sat Oct 24 01:28:29 2015 +0900

    Merge branches 'topic/core' and 'topic/stats' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi into spi-doc

commit 6b7bc0618ff1a333d2265131b124e966335d5dee
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Mon Jun 22 13:02:04 2015 +0000

    spi: add transfer histogram statistics via sysfs
    
    report transfer sizes as a histogram via the following files:
      /sys/class/spi_master/spi*/statistics/transfer_bytes_histo_*
      /sys/class/spi_master/spi*/spi*.*/statistics/transfer_bytes_histo_*
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 269e8afd3e2a..5b6fdc48eba7 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -51,6 +51,8 @@ extern struct bus_type spi_bus_type;
  * @bytes_tx:      number of bytes sent to device
  * @bytes_rx:      number of bytes received from device
  *
+ * @transfer_bytes_histo:
+ *                 transfer bytes histogramm
  */
 struct spi_statistics {
 	spinlock_t		lock; /* lock for the whole structure */
@@ -68,6 +70,8 @@ struct spi_statistics {
 	unsigned long long	bytes_rx;
 	unsigned long long	bytes_tx;
 
+#define SPI_STATISTICS_HISTO_SIZE 17
+	unsigned long transfer_bytes_histo[SPI_STATISTICS_HISTO_SIZE];
 };
 
 void spi_statistics_add_transfer_stats(struct spi_statistics *stats,

commit 0243ed44ad4a25dbd2e92ad97e5e12a1a6c72d6c
Author: Geliang Tang <geliangtang@163.com>
Date:   Tue Sep 15 04:59:21 2015 -0700

    spi: fix kernel-doc warnings in spi.h
    
    Fix the following 'make htmldocs' warnings:
    
      .//include/linux/spi/spi.h:71: warning: No description found for parameter 'lock'
      .//include/linux/spi/spi.h:71: warning: Excess struct/union/enum/typedef member 'clock' description in 'spi_statistics'
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 269e8afd3e2a..6b00f18f5e6b 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -34,7 +34,7 @@ extern struct bus_type spi_bus_type;
 
 /**
  * struct spi_statistics - statistics for spi transfers
- * @clock:         lock protecting this structure
+ * @lock:          lock protecting this structure
  *
  * @messages:      number of spi-messages handled
  * @transfers:     number of spi_transfers handled

commit eca2ebc7e007c9e2b8f5ecfcfc74b53fbe68e42b
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Mon Jun 22 13:00:36 2015 +0000

    spi: expose spi_master and spi_device statistics via sysfs
    
    per spi-master statistics accessible as:
      /sys/class/spi_master/spi*/statistics/*
    
    per spi-device statistics accessible via:
      /sys/class/spi_master/spi*/spi*.*/statistics/*
    
    The following statistics are exposed as separate "files" inside
    these directories:
    * messages              number of spi_messages
    * transfers             number of spi_transfers
    * bytes                 number of bytes transferred
    * bytes_rx              number of bytes transmitted
    * bytes_tx              number of bytes received
    * errors                number of errors encounterd
    * timedout              number of messages that have timed out
    * spi_async             number of spi_messages submitted using spi_async
    * spi_sync              number of spi_messages submitted using spi_sync
    * spi_sync_immediate    number of spi_messages submitted using spi_sync,
                            that are handled immediately without a context switch
                            to the spi_pump worker-thread
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index d673072346f2..269e8afd3e2a 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -23,6 +23,8 @@
 #include <linux/scatterlist.h>
 
 struct dma_chan;
+struct spi_master;
+struct spi_transfer;
 
 /*
  * INTERFACES between SPI master-side drivers and SPI infrastructure.
@@ -30,6 +32,59 @@ struct dma_chan;
  */
 extern struct bus_type spi_bus_type;
 
+/**
+ * struct spi_statistics - statistics for spi transfers
+ * @clock:         lock protecting this structure
+ *
+ * @messages:      number of spi-messages handled
+ * @transfers:     number of spi_transfers handled
+ * @errors:        number of errors during spi_transfer
+ * @timedout:      number of timeouts during spi_transfer
+ *
+ * @spi_sync:      number of times spi_sync is used
+ * @spi_sync_immediate:
+ *                 number of times spi_sync is executed immediately
+ *                 in calling context without queuing and scheduling
+ * @spi_async:     number of times spi_async is used
+ *
+ * @bytes:         number of bytes transferred to/from device
+ * @bytes_tx:      number of bytes sent to device
+ * @bytes_rx:      number of bytes received from device
+ *
+ */
+struct spi_statistics {
+	spinlock_t		lock; /* lock for the whole structure */
+
+	unsigned long		messages;
+	unsigned long		transfers;
+	unsigned long		errors;
+	unsigned long		timedout;
+
+	unsigned long		spi_sync;
+	unsigned long		spi_sync_immediate;
+	unsigned long		spi_async;
+
+	unsigned long long	bytes;
+	unsigned long long	bytes_rx;
+	unsigned long long	bytes_tx;
+
+};
+
+void spi_statistics_add_transfer_stats(struct spi_statistics *stats,
+				       struct spi_transfer *xfer,
+				       struct spi_master *master);
+
+#define SPI_STATISTICS_ADD_TO_FIELD(stats, field, count)	\
+	do {							\
+		unsigned long flags;				\
+		spin_lock_irqsave(&(stats)->lock, flags);	\
+		(stats)->field += count;			\
+		spin_unlock_irqrestore(&(stats)->lock, flags);	\
+	} while (0)
+
+#define SPI_STATISTICS_INCREMENT_FIELD(stats, field)	\
+	SPI_STATISTICS_ADD_TO_FIELD(stats, field, 1)
+
 /**
  * struct spi_device - Master side proxy for an SPI slave device
  * @dev: Driver model representation of the device.
@@ -60,6 +115,8 @@ extern struct bus_type spi_bus_type;
  * @cs_gpio: gpio number of the chipselect line (optional, -ENOENT when
  *	when not using a GPIO line)
  *
+ * @statistics: statistics for the spi_device
+ *
  * A @spi_device is used to interchange data between an SPI slave
  * (usually a discrete chip) and CPU memory.
  *
@@ -98,6 +155,9 @@ struct spi_device {
 	char			modalias[SPI_NAME_SIZE];
 	int			cs_gpio;	/* chip select gpio */
 
+	/* the statistics */
+	struct spi_statistics	statistics;
+
 	/*
 	 * likely need more hooks for more protocol options affecting how
 	 * the controller talks to each chip, like:
@@ -296,6 +356,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @cs_gpios: Array of GPIOs to use as chip select lines; one per CS
  *	number. Any individual value may be -ENOENT for CS lines that
  *	are not GPIOs (driven by the SPI controller itself).
+ * @statistics: statistics for the spi_master
  * @dma_tx: DMA transmit channel
  * @dma_rx: DMA receive channel
  * @dummy_rx: dummy receive buffer for full-duplex devices
@@ -452,6 +513,9 @@ struct spi_master {
 	/* gpio chip select */
 	int			*cs_gpios;
 
+	/* statistics */
+	struct spi_statistics	statistics;
+
 	/* DMA channels for use with core dmaengine helpers */
 	struct dma_chan		*dma_tx;
 	struct dma_chan		*dma_rx;

commit 8afba181b90fbad372c420c302a57c0c4f9fdae4
Merge: 35fbf8452ce6 db91841b58f9 d4f9dcd1ac94 7183d1ebda47 ea022bbb0090 eecacf73a40f
Author: Mark Brown <broonie@kernel.org>
Date:   Sat Apr 11 23:09:18 2015 +0100

    Merge remote-tracking branches 'spi/topic/omap-100k', 'spi/topic/omap-uwire', 'spi/topic/pl022', 'spi/topic/pm' and 'spi/topic/pxa2xx' into spi-next

commit 431959c0793e0d399303a061424dbaa1b33eb940
Merge: f9de73426c69 057f6061a197 38b6484e5b7b 207cda93f044 ff61eb422024
Author: Mark Brown <broonie@kernel.org>
Date:   Sat Apr 11 23:09:09 2015 +0100

    Merge remote-tracking branches 'spi/topic/blackfin', 'spi/topic/cadence', 'spi/topic/dw' and 'spi/topic/err' into spi-next

commit f9de73426c69ec3357c31a10af5f5acb037dbbaa
Merge: 19655dd08329 ea467326e36b b716c4ffc6a2 704f32d48af2 b3e7766bc459 232a5adc5199
Author: Mark Brown <broonie@kernel.org>
Date:   Sat Apr 11 23:09:03 2015 +0100

    Merge remote-tracking branches 'spi/topic/atmel', 'spi/topic/bcm2385', 'spi/topic/bcm2835', 'spi/topic/bcm53xx' and 'spi/topic/bitbang' into spi-next

commit ff61eb422024a4614f898c1c73625e222b219a5d
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Apr 7 20:39:19 2015 +0200

    spi: Make master->handle_err() callback optional to avoid crashes
    
    If a driver doesn't implement the master->handle_err() callback and an
    SPI transfer fails, the kernel will crash with a NULL pointer
    dereference:
    
        Unable to handle kernel NULL pointer dereference at virtual address 00000000
        pgd = c0003000
        [00000000] *pgd=80000040004003, *pmd=00000000
        Internal error: Oops: 80000206 [#1] SMP ARM
        Modules linked in:
        CPU: 1 PID: 1 Comm: swapper/0 Not tainted 4.0.0-rc7-koelsch-05861-g1fc9fdd4add4f783 #1046
        Hardware name: Generic R8A7791 (Flattened Device Tree)
        task: eec359c0 ti: eec54000 task.ti: eec54000
        PC is at 0x0
        LR is at spi_transfer_one_message+0x1cc/0x1f0
    
    Make the master->handle_err() callback optional to avoid the crash.
    
    Also fix a spelling mistake in the callback documentation while we're at
    it.
    
    Fixes: b716c4ffc6a2b0bf ("spi: introduce master->handle_err() callback")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 4eaac3a5227b..5685af84a64d 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -294,7 +294,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *                    transfer_one_message are mutually exclusive; when both
  *                    are set, the generic subsystem does not call your
  *                    transfer_one callback.
- * @handle_err: the subsystem calls the driver to handle and error that occurs
+ * @handle_err: the subsystem calls the driver to handle an error that occurs
  *		in the generic implementation of transfer_one_message().
  * @unprepare_message: undo any work done by prepare_message().
  * @cs_gpios: Array of GPIOs to use as chip select lines; one per CS

commit ea022bbb0090975a21c581d8405fbe90043a6eda
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sun Mar 8 14:56:38 2015 +0100

    spi: Remove support for legacy PM
    
    All SPI drivers have been converted from legacy suspend/resume callbacks to
    dev_pm_ops. So we can finally remove support for legacy PM from the SPI
    core.
    
    Since there aren't any special bus specific things to do during
    suspend/resume and since the PM core will automatically fallback directly to
    using the device's PM ops if no bus PM ops are specified there is no need to
    have any special SPI bus PM ops.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index ed9489d893a4..9f6b481e8672 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -162,8 +162,6 @@ struct spi_transfer;
  * @remove: Unbinds this driver from the spi device
  * @shutdown: Standard shutdown callback used during system state
  *	transitions such as powerdown/halt and kexec
- * @suspend: Standard suspend callback used during system state transitions
- * @resume: Standard resume callback used during system state transitions
  * @driver: SPI device drivers should initialize the name and owner
  *	field of this structure.
  *
@@ -184,8 +182,6 @@ struct spi_driver {
 	int			(*probe)(struct spi_device *spi);
 	int			(*remove)(struct spi_device *spi);
 	void			(*shutdown)(struct spi_device *spi);
-	int			(*suspend)(struct spi_device *spi, pm_message_t mesg);
-	int			(*resume)(struct spi_device *spi);
 	struct device_driver	driver;
 };
 

commit b716c4ffc6a2b0bfbcf9619880f335be11b65708
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Feb 27 17:34:15 2015 +0200

    spi: introduce master->handle_err() callback
    
    This callback would be useful to handle an error that occurs in the generic
    implementation of transfer_one_message(). The good candidate for this is to
    drain FIFO and / or to terminate DMA transfers when timeout happened.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index ed9489d893a4..4eaac3a5227b 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -294,6 +294,8 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *                    transfer_one_message are mutually exclusive; when both
  *                    are set, the generic subsystem does not call your
  *                    transfer_one callback.
+ * @handle_err: the subsystem calls the driver to handle and error that occurs
+ *		in the generic implementation of transfer_one_message().
  * @unprepare_message: undo any work done by prepare_message().
  * @cs_gpios: Array of GPIOs to use as chip select lines; one per CS
  *	number. Any individual value may be -ENOENT for CS lines that
@@ -448,6 +450,8 @@ struct spi_master {
 	void (*set_cs)(struct spi_device *spi, bool enable);
 	int (*transfer_one)(struct spi_master *master, struct spi_device *spi,
 			    struct spi_transfer *transfer);
+	void (*handle_err)(struct spi_master *master,
+			   struct spi_message *message);
 
 	/* gpio chip select */
 	int			*cs_gpios;

commit c6331ba3d2d68758f36dbc3e09e648d312c24d97
Author: Marcin Bis <marcin@bis.org.pl>
Date:   Sun Mar 1 13:49:32 2015 +0100

    spi: fix a typo in comment.
    
    alway -> always
    
    Signed-off-by: Marcin Bis <marcin@bis.org.pl>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index ed9489d893a4..856d34dde79b 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -649,7 +649,7 @@ struct spi_transfer {
  * sequence completes.  On some systems, many such sequences can execute as
  * as single programmed DMA transfer.  On all systems, these messages are
  * queued, and might complete after transactions to other devices.  Messages
- * sent to a given spi_device are alway executed in FIFO order.
+ * sent to a given spi_device are always executed in FIFO order.
  *
  * The code that submits an spi_message (and its spi_transfers)
  * to the lower layers is responsible for managing its memory.

commit 8328509c4bdf28b83fd7104ca9da01bf3b58c7b0
Merge: d6cd09bea9e4 549858ce76e3 56536a7ff59c fc9e0f71f2d7 9caf5067b9cb f2234691d7d7
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Feb 8 11:16:52 2015 +0800

    Merge remote-tracking branches 'spi/topic/img-spfi', 'spi/topic/imx', 'spi/topic/inline', 'spi/topic/meson' and 'spi/topic/mxs' into spi-next

commit 2c658e212ce7e40ace56d9441c8c5634d4d420e3
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Thu Dec 18 16:12:08 2014 +0200

    spi: Remove FSF mailing addresses
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index a6ef2a8e6de4..6e2664a17114 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -10,10 +10,6 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #ifndef __LINUX_SPI_H

commit 0461a4149836c792d186027c8c859637a4cfb11a
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Dec 9 21:38:05 2014 +0000

    spi: Pump transfers inside calling context for spi_sync()
    
    If we are using the standard SPI message pump (which all drivers should be
    transitioning over to) then special case the message enqueue and instead of
    starting the worker thread to push messages to the hardware do so in the
    context of the caller if the controller is idle. This avoids a context
    switch in the common case where the controller has a single user in a
    single thread, for short PIO transfers there may be no need to context
    switch away from the calling context to complete the transfer.
    
    The code is a bit more complex than is desirable in part due to the need
    to handle drivers not using the standard queue and in part due to handling
    the various combinations of bus locking and asynchronous submission in
    interrupt context.
    
    It is still suboptimal since it will still wake the message pump for each
    transfer in order to schedule idling of the hardware and if multiple
    contexts are using the controller simultaneously a caller may end up
    pumping a message for some random other thread rather than for itself,
    and if the thread ends up deferring due to another context idling the
    hardware then it will just busy wait.  It can, however, have the benefit
    of aggregating power up and down of the hardware when a caller performs
    a series of transfers back to back without any need for the use of
    spi_async().
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index a6ef2a8e6de4..4e6db75e9469 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -260,6 +260,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @pump_messages: work struct for scheduling work to the message pump
  * @queue_lock: spinlock to syncronise access to message queue
  * @queue: message queue
+ * @idling: the device is entering idle state
  * @cur_msg: the currently in-flight message
  * @cur_msg_prepared: spi_prepare_message was called for the currently
  *                    in-flight message
@@ -425,6 +426,7 @@ struct spi_master {
 	spinlock_t			queue_lock;
 	struct list_head		queue;
 	struct spi_message		*cur_msg;
+	bool				idling;
 	bool				busy;
 	bool				running;
 	bool				rt;

commit b671358ad7916beb7ca9e5c304ae88afc7da4557
Author: Beniamino Galvani <b.galvani@gmail.com>
Date:   Sat Nov 22 16:21:39 2014 +0100

    spi: core: Add spi_transfer_is_last() helper
    
    This adds the function spi_transfer_is_last() which can be used by
    drivers to know whether a given transfer is the last one in the
    current message.
    
    Signed-off-by: Beniamino Galvani <b.galvani@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 46d188a9947c..a6ef2a8e6de4 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -1049,4 +1049,10 @@ spi_unregister_device(struct spi_device *spi)
 extern const struct spi_device_id *
 spi_get_device_id(const struct spi_device *sdev);
 
+static inline bool
+spi_transfer_is_last(struct spi_master *master, struct spi_transfer *xfer)
+{
+	return list_is_last(&xfer->transfer_list, &master->cur_msg->transfers);
+}
+
 #endif /* __LINUX_SPI_H */

commit 2c67568903d6ae1b8cfa343c649029180239418e
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Aug 8 13:02:36 2014 +0200

    spi: Add missing kerneldoc bits
    
    These are all arguments or fields that got added without updating the
    kerneldoc comments.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index e713543336f1..46d188a9947c 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -253,6 +253,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *	the device whose settings are being modified.
  * @transfer: adds a message to the controller's transfer queue.
  * @cleanup: frees controller-specific state
+ * @can_dma: determine whether this master supports DMA
  * @queued: whether this master is providing an internal message queue
  * @kworker: thread struct for message pump
  * @kworker_task: pointer to task for message pump kworker thread
@@ -262,6 +263,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @cur_msg: the currently in-flight message
  * @cur_msg_prepared: spi_prepare_message was called for the currently
  *                    in-flight message
+ * @cur_msg_mapped: message has been mapped for DMA
  * @xfer_completion: used by core transfer_one_message()
  * @busy: message pump is busy
  * @running: message pump is running
@@ -299,6 +301,10 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @cs_gpios: Array of GPIOs to use as chip select lines; one per CS
  *	number. Any individual value may be -ENOENT for CS lines that
  *	are not GPIOs (driven by the SPI controller itself).
+ * @dma_tx: DMA transmit channel
+ * @dma_rx: DMA receive channel
+ * @dummy_rx: dummy receive buffer for full-duplex devices
+ * @dummy_tx: dummy transmit buffer for full-duplex devices
  *
  * Each SPI master controller can communicate with one or more @spi_device
  * children.  These make a small bus, sharing MOSI, MISO and SCK signals
@@ -632,6 +638,7 @@ struct spi_transfer {
  *	addresses for each transfer buffer
  * @complete: called to report transaction completions
  * @context: the argument to complete() when it's called
+ * @frame_length: the total number of bytes in the message
  * @actual_length: the total number of bytes that were transferred in all
  *	successful segments
  * @status: zero for success, else negative errno

commit 159d8133d0b54a501a41a66fe3a0e7d16405e36d
Merge: 05bf58ca4b8f c800bcd5f53f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 2 16:23:38 2014 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    Pull trivial tree updates from Jiri Kosina:
     "Usual rocket science -- mostly documentation and comment updates"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial:
      sparse: fix comment
      doc: fix double words
      isdn: capi: fix "CAPI_VERSION" comment
      doc: DocBook: Fix typos in xml and template file
      Bluetooth: add module name for btwilink
      driver core: unexport static function create_syslog_header
      mmc: core: typo fix in printk specifier
      ARM: spear: clean up editing mistake
      net-sysfs: fix comment typo 'CONFIG_SYFS'
      doc: Insert MODULE_ in module-signing macros
      Documentation: update URL to hfsplus Technote 1150
      gpio: update path to documentation
      ixgbe: Fix format string in ixgbe_fcoe.
      Kconfig: Remove useless "default N" lines
      user_namespace.c: Remove duplicated word in comment
      CREDITS: fix formatting
      treewide: Fix typo in Documentation/DocBook
      mm: Fix warning on make htmldocs caused by slab.c
      ata: ata-samsung_cf: cleanup in header file
      idr: remove unused prototype of idr_free()

commit a78389844ea95f18aadda79246587c707586ce89
Merge: 5d0eb26ce836 513273538a6c
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Mar 30 00:50:56 2014 +0000

    Merge remote-tracking branch 'spi/topic/dma' into spi-next

commit d4263348f796f29546f90802177865dd4379dd0a
Merge: be873ac782f5 6d0abeca3242
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Feb 20 14:54:28 2014 +0100

    Merge branch 'master' into for-next

commit e227867f12302633737bd2a48a10a9a72c0630cb
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Tue Feb 18 22:54:36 2014 +0900

    treewide: Fix typo in Documentation/DocBook
    
    This patch fix spelling typo in Documentation/DocBook.
    It is because .html and .xml files are generated by make htmldocs,
    I have to fix a typo within the source files.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 8c62ba74dd91..8d3a37bc6110 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -234,7 +234,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @mode_bits: flags understood by this controller driver
  * @bits_per_word_mask: A mask indicating which values of bits_per_word are
  *	supported by the driver. Bit n indicates that a bits_per_word n+1 is
- *	suported. If set, the SPI core will reject any transfer with an
+ *	supported. If set, the SPI core will reject any transfer with an
  *	unsupported bits_per_word. If not set, this value is simply ignored,
  *	and it's up to the individual driver to perform any validation.
  * @min_speed_hz: Lowest supported transfer speed
@@ -259,7 +259,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @cur_msg: the currently in-flight message
  * @cur_msg_prepared: spi_prepare_message was called for the currently
  *                    in-flight message
- * @xfer_completion: used by core tranfer_one_message()
+ * @xfer_completion: used by core transfer_one_message()
  * @busy: message pump is busy
  * @running: message pump is running
  * @rt: whether this queue is set to run as a realtime task
@@ -493,7 +493,7 @@ extern struct spi_master *spi_busnum_to_master(u16 busnum);
  * @rx_buf: data to be read (dma-safe memory), or NULL
  * @tx_dma: DMA address of tx_buf, if @spi_message.is_dma_mapped
  * @rx_dma: DMA address of rx_buf, if @spi_message.is_dma_mapped
- * @tx_nbits: number of bits used for writting. If 0 the default
+ * @tx_nbits: number of bits used for writing. If 0 the default
  *      (SPI_NBITS_SINGLE) is used.
  * @rx_nbits: number of bits used for reading. If 0 the default
  *      (SPI_NBITS_SINGLE) is used.
@@ -551,7 +551,7 @@ extern struct spi_master *spi_busnum_to_master(u16 busnum);
  * by the results of previous messages and where the whole transaction
  * ends when the chipselect goes intactive.
  *
- * When SPI can transfer in 1x,2x or 4x. It can get this tranfer information
+ * When SPI can transfer in 1x,2x or 4x. It can get this transfer information
  * from device through @tx_nbits and @rx_nbits. In Bi-direction, these
  * two should both be set. User can set transfer mode with SPI_NBITS_SINGLE(1x)
  * SPI_NBITS_DUAL(2x) and SPI_NBITS_QUAD(4x) to support these three transfer.

commit 6ad45a27cbe343ec8d7888e5edf6335499a4b555
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Feb 2 13:47:47 2014 +0000

    spi: Make core DMA mapping functions generate scatterlists
    
    We cannot unconditionally use dma_map_single() to map data for use with
    SPI since transfers may exceed a page and virtual addresses may not be
    provided with physically contiguous pages. Further, addresses allocated
    using vmalloc() need to be mapped differently to other addresses.
    
    Currently only the MXS driver handles all this, a few drivers do handle
    the possibility that buffers may not be physically contiguous which is
    the main potential problem but many don't even do that. Factoring this
    out into the core will make it easier for drivers to do a good job so if
    the driver is using the core DMA code then generate a scatterlist
    instead of mapping to a single address so do that.
    
    This code is mainly based on a combination of the existing code in the MXS
    and PXA2xx drivers. In future we should be able to extend it to allow the
    core to concatenate adjacent transfers if they are compatible, improving
    performance.
    
    Currently for simplicity clients are not allowed to use the scatterlist
    when they do DMA mapping, in the future the existing single address
    mappings will be replaced with use of the scatterlist most likely as
    part of pre-verifying transfers.
    
    This change makes it mandatory to use scatterlists when using the core DMA
    mapping so update the s3c64xx driver to do this when used with dmaengine.
    Doing so makes the code more ugly but it is expected that the old s3c-dma
    code can be removed very soon.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 31a5b0ee93ec..0c23c835d48b 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -24,6 +24,7 @@
 #include <linux/slab.h>
 #include <linux/kthread.h>
 #include <linux/completion.h>
+#include <linux/scatterlist.h>
 
 struct dma_chan;
 
@@ -268,6 +269,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @auto_runtime_pm: the core should ensure a runtime PM reference is held
  *                   while the hardware is prepared, using the parent
  *                   device for the spidev
+ * @max_dma_len: Maximum length of a DMA transfer for the device.
  * @prepare_transfer_hardware: a message will soon arrive from the queue
  *	so the subsystem requests the driver to prepare the transfer hardware
  *	by issuing this call
@@ -421,6 +423,7 @@ struct spi_master {
 	bool                            cur_msg_prepared;
 	bool				cur_msg_mapped;
 	struct completion               xfer_completion;
+	size_t				max_dma_len;
 
 	int (*prepare_transfer_hardware)(struct spi_master *master);
 	int (*transfer_one_message)(struct spi_master *master,
@@ -533,6 +536,8 @@ extern struct spi_master *spi_busnum_to_master(u16 busnum);
  *	(optionally) changing the chipselect status, then starting
  *	the next transfer or completing this @spi_message.
  * @transfer_list: transfers are sequenced through @spi_message.transfers
+ * @tx_sg: Scatterlist for transmit, currently not for client use
+ * @rx_sg: Scatterlist for receive, currently not for client use
  *
  * SPI transfers always write the same number of bytes as they read.
  * Protocol drivers should always provide @rx_buf and/or @tx_buf.
@@ -600,6 +605,8 @@ struct spi_transfer {
 
 	dma_addr_t	tx_dma;
 	dma_addr_t	rx_dma;
+	struct sg_table tx_sg;
+	struct sg_table rx_sg;
 
 	unsigned	cs_change:1;
 	unsigned	tx_nbits:3;

commit 3a2eba9bd0a6447dfbc01635e4cd0689f5f2bdad
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Jan 28 20:17:03 2014 +0000

    spi: Provide core support for full duplex devices
    
    It is fairly common for SPI devices to require that one or both transfer
    directions is always active. Currently drivers open code this in various
    ways with varying degrees of efficiency. Start factoring this out by
    providing flags SPI_MASTER_MUST_TX and SPI_MASTER_MUST_RX. These will cause
    the core to provide buffers for the requested direction if none are
    specified in the underlying transfer.
    
    Currently this is fairly inefficient since we actually allocate a data
    buffer which may get large, support for mapping transfers using a
    scatterlist will allow us to avoid this for DMA based transfers.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index b354dcbed55b..31a5b0ee93ec 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -347,6 +347,8 @@ struct spi_master {
 #define SPI_MASTER_HALF_DUPLEX	BIT(0)		/* can't do full duplex */
 #define SPI_MASTER_NO_RX	BIT(1)		/* can't do buffer read */
 #define SPI_MASTER_NO_TX	BIT(2)		/* can't do buffer write */
+#define SPI_MASTER_MUST_RX      BIT(3)		/* requires rx */
+#define SPI_MASTER_MUST_TX      BIT(4)		/* requires tx */
 
 	/* lock and mutex for SPI bus locking */
 	spinlock_t		bus_lock_spinlock;
@@ -443,6 +445,10 @@ struct spi_master {
 	/* DMA channels for use with core dmaengine helpers */
 	struct dma_chan		*dma_tx;
 	struct dma_chan		*dma_rx;
+
+	/* dummy data for full duplex devices */
+	void			*dummy_rx;
+	void			*dummy_tx;
 };
 
 static inline void *spi_master_get_devdata(struct spi_master *master)

commit 99adef310f682d6343cb40c1f6c9c25a4b3a450d
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Jan 16 12:22:43 2014 +0000

    spi: Provide core support for DMA mapping transfers
    
    The process of DMA mapping buffers for SPI transfers does not vary between
    devices so in order to save duplication of code in drivers this can be
    factored out into the core, allowing it to be integrated with the work that
    is being done on factoring out the common elements from the data path
    including more sharing of dmaengine code.
    
    In order to use this masters need to provide a can_dma() operation and while
    the hardware is prepared they should ensure that DMA channels are provided
    in tx_dma and rx_dma. The core will then ensure that the buffers are mapped
    for DMA prior to calling transfer_one_message().
    
    Currently the cleanup on error is not complete, this needs to be improved.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index a1d4ca290862..b354dcbed55b 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -25,6 +25,8 @@
 #include <linux/kthread.h>
 #include <linux/completion.h>
 
+struct dma_chan;
+
 /*
  * INTERFACES between SPI master-side drivers and SPI infrastructure.
  * (There's no SPI slave support for Linux yet...)
@@ -386,6 +388,17 @@ struct spi_master {
 	/* called on release() to free memory provided by spi_master */
 	void			(*cleanup)(struct spi_device *spi);
 
+	/*
+	 * Used to enable core support for DMA handling, if can_dma()
+	 * exists and returns true then the transfer will be mapped
+	 * prior to transfer_one() being called.  The driver should
+	 * not modify or store xfer and dma_tx and dma_rx must be set
+	 * while the device is prepared.
+	 */
+	bool			(*can_dma)(struct spi_master *master,
+					   struct spi_device *spi,
+					   struct spi_transfer *xfer);
+
 	/*
 	 * These hooks are for drivers that want to use the generic
 	 * master transfer queueing mechanism. If these are used, the
@@ -404,6 +417,7 @@ struct spi_master {
 	bool				rt;
 	bool				auto_runtime_pm;
 	bool                            cur_msg_prepared;
+	bool				cur_msg_mapped;
 	struct completion               xfer_completion;
 
 	int (*prepare_transfer_hardware)(struct spi_master *master);
@@ -425,6 +439,10 @@ struct spi_master {
 
 	/* gpio chip select */
 	int			*cs_gpios;
+
+	/* DMA channels for use with core dmaengine helpers */
+	struct dma_chan		*dma_tx;
+	struct dma_chan		*dma_rx;
 };
 
 static inline void *spi_master_get_devdata(struct spi_master *master)

commit e9305331f64ab9e5210baa4307355635c5e849f4
Author: Baruch Siach <baruch@tkos.co.il>
Date:   Sat Jan 25 22:36:15 2014 +0200

    spi: correct the transfer_one_message documentation wording
    
    The transfer_one_message callback handles messages, not transfers.
    
    Signed-off-by: Baruch Siach <baruch@tkos.co.il>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index ad050f0dd39d..4203c66d8803 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -273,7 +273,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *	message while queuing transfers that arrive in the meantime. When the
  *	driver is finished with this message, it must call
  *	spi_finalize_current_message() so the subsystem can issue the next
- *	transfer
+ *	message
  * @unprepare_transfer_hardware: there are currently no more messages on the
  *	queue so the subsystem notifies the driver that it may relax the
  *	hardware by issuing this call

commit 6e5f52674ff0756e61a8879f6232b9ac33735cba
Author: Baruch Siach <baruch@tkos.co.il>
Date:   Sat Jan 25 22:36:13 2014 +0200

    spi: spi.h: clarify the documentation of transfer_one
    
    Explicitly note the transfer_one and transfer_one_message are mutually
    exclusive, to make the text a little more newcomers friendly.
    
    Signed-off-by: Baruch Siach <baruch@tkos.co.il>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index a1d4ca290862..ad050f0dd39d 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -287,7 +287,10 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *                  - return 1 if the transfer is still in progress. When
  *                    the driver is finished with this transfer it must
  *                    call spi_finalize_current_transfer() so the subsystem
- *                    can issue the next transfer
+ *                    can issue the next transfer. Note: transfer_one and
+ *                    transfer_one_message are mutually exclusive; when both
+ *                    are set, the generic subsystem does not call your
+ *                    transfer_one callback.
  * @unprepare_message: undo any work done by prepare_message().
  * @cs_gpios: Array of GPIOs to use as chip select lines; one per CS
  *	number. Any individual value may be -ENOENT for CS lines that

commit 3c1039745ef2925aceed53d38af0cddac8e36f31
Merge: 7e2c225d585c 1afd9989a6a2
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Jan 23 13:07:01 2014 +0000

    Merge remote-tracking branch 'spi/topic/core' into spi-linus

commit bd6857a0c630207484a03ddc470fab34b23f80bb
Author: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
Date:   Tue Jan 21 16:10:07 2014 +0100

    spi: Correct set_cs() documentation
    
    The documentation for spi_master.set_cs() says:
    
        assert or deassert chip select, true to assert
    
    i.e. its "enable" parameter uses assertion-level logic.
    
    This does not match the implementation of spi_set_cs(), which calls
    spi_master.set_cs() with the wanted logic level of the chip select line,
    which depends on the polarity of the chip select signal.
    
    Correct the documentation to match the implementation.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index e766e0e2fe58..9f5242df9311 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -277,7 +277,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @unprepare_transfer_hardware: there are currently no more messages on the
  *	queue so the subsystem notifies the driver that it may relax the
  *	hardware by issuing this call
- * @set_cs: assert or deassert chip select, true to assert.  May be called
+ * @set_cs: set the logic level of the chip select line.  May be called
  *          from interrupt context.
  * @prepare_message: set up the controller to transfer a single message,
  *                   for example doing DMA mapping.  Called from threaded

commit 0516712c6548e252adf7aebf70d67842cd734483
Author: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
Date:   Tue Jan 21 16:10:06 2014 +0100

    spi: Clarify transfer_one() w.r.t. spi_finalize_current_transfer()
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 8c62ba74dd91..e766e0e2fe58 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -282,10 +282,12 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @prepare_message: set up the controller to transfer a single message,
  *                   for example doing DMA mapping.  Called from threaded
  *                   context.
- * @transfer_one: transfer a single spi_transfer. When the
- *	          driver is finished with this transfer it must call
- *	          spi_finalize_current_transfer() so the subsystem can issue
- *                the next transfer
+ * @transfer_one: transfer a single spi_transfer.
+ *                  - return 0 if the transfer is finished,
+ *                  - return 1 if the transfer is still in progress. When
+ *                    the driver is finished with this transfer it must
+ *                    call spi_finalize_current_transfer() so the subsystem
+ *                    can issue the next transfer
  * @unprepare_message: undo any work done by prepare_message().
  * @cs_gpios: Array of GPIOs to use as chip select lines; one per CS
  *	number. Any individual value may be -ENOENT for CS lines that

commit 269ccca8ec1a3991e07eaf5f90326134bd17781a
Author: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
Date:   Sun Jan 12 13:59:06 2014 +0100

    spi: Kill superfluous cast in spi_w8r16()
    
    spi_write_then_read() takes a "void *" for rxbuf, so there's no need to
    cast the buffer pointer to "u8 *".
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 77b529e418d5..21a7251d85ee 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -847,7 +847,7 @@ static inline ssize_t spi_w8r16(struct spi_device *spi, u8 cmd)
 	ssize_t			status;
 	u16			result;
 
-	status = spi_write_then_read(spi, &cmd, 1, (u8 *) &result, 2);
+	status = spi_write_then_read(spi, &cmd, 1, &result, 2);
 
 	/* return negative errno or unsigned value */
 	return (status < 0) ? status : result;

commit d3fbd457013c0f6d96de461ce0a9cb1f8b73cd0b
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Jan 10 17:09:53 2014 +0000

    spi: Use bitfields for multiple data lines
    
    Trent Piepho observed that since the current realistic maximum number of
    data lines is four we can pack the spi_transfer struct more efficiently
    if we use a bitfield for the number of bits, allowing the fields to fit
    in a single byte along with cs_change.
    
    If space becomes an issue further optimiation is possible by only using
    the constants and packing the values chosen for them.
    
    Reported-by: Trent Piepho <tpiepho@gmail.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 27a882978c15..77b529e418d5 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -576,8 +576,8 @@ struct spi_transfer {
 	dma_addr_t	rx_dma;
 
 	unsigned	cs_change:1;
-	u8		tx_nbits;
-	u8		rx_nbits;
+	unsigned	tx_nbits:3;
+	unsigned	rx_nbits:3;
 #define	SPI_NBITS_SINGLE	0x01 /* 1bit transfer */
 #define	SPI_NBITS_DUAL		0x02 /* 2bits transfer */
 #define	SPI_NBITS_QUAD		0x04 /* 4bits transfer */

commit 89c1f60746106755e29dcc3db9f22e37000891ef
Author: Trent Piepho <tpiepho@gmail.com>
Date:   Fri Dec 13 18:27:44 2013 -0800

    spi: Order fields in spi_device for better packing
    
    Now that spi_device->mode is a u16, the chip_select, bits_per_mode,
    and mode fields pack poorly, taking 8 bytes:  four data and four
    padding.  By moving (u8)bits_per_word up one position, to after
    (u8)chip_select, they pack better and only use 4 bytes.
    
    Signed-off-by: Trent Piepho <tpiepho@gmail.com>
    Reviewed-by: Sourav Poddar <sourav.poddar@ti.com>
    Tested-by: Sourav Poddar <sourav.poddar@ti.com>g
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 8c62ba74dd91..27a882978c15 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -75,6 +75,7 @@ struct spi_device {
 	struct spi_master	*master;
 	u32			max_speed_hz;
 	u8			chip_select;
+	u8			bits_per_word;
 	u16			mode;
 #define	SPI_CPHA	0x01			/* clock phase */
 #define	SPI_CPOL	0x02			/* clock polarity */
@@ -92,7 +93,6 @@ struct spi_device {
 #define	SPI_TX_QUAD	0x200			/* transmit with 4 wires */
 #define	SPI_RX_DUAL	0x400			/* receive with 2 wires */
 #define	SPI_RX_QUAD	0x800			/* receive with 4 wires */
-	u8			bits_per_word;
 	int			irq;
 	void			*controller_state;
 	void			*controller_data;

commit 82f85cf98f0eb60093e8b3d606711c2d49538478
Merge: 344a85117d9c 235907422548
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Oct 25 09:51:41 2013 +0100

    Merge remote-tracking branch 'spi/topic/wr' into spi-next

commit 2cc6e2e0c8157b9e6ed8dbe5c7284865f6afbd46
Merge: b158935f70b9 ebd805cc14be
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Oct 11 20:10:13 2013 +0100

    Merge remote-tracking branch 'spi/topic/s3c64xx' into spi-loop

commit b158935f70b9c156903338053216dd0adf7ce31c
Author: Mark Brown <broonie@linaro.org>
Date:   Sat Oct 5 11:50:40 2013 +0100

    spi: Provide common spi_message processing loop
    
    The loops which SPI controller drivers use to process the list of transfers
    in a spi_message are typically very similar and have some error prone areas
    such as the handling of /CS. Help simplify drivers by factoring this code
    out into the core - if drivers provide a transfer_one() function instead
    of a transfer_one_message() function the core will handle processing at the
    message level.
    
    /CS can be controlled by either setting cs_gpio or providing a set_cs
    function. If this is not possible for hardware reasons then both can be
    omitted and the driver should continue to implement manual /CS handling.
    
    This is a first step in refactoring and it is expected that there will be
    further enhancements, for example factoring out of the mapping of transfers
    for DMA and the initiation and completion of interrupt driven transfers.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 000b50bee6c0..da371ab5ebeb 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -23,6 +23,7 @@
 #include <linux/mod_devicetable.h>
 #include <linux/slab.h>
 #include <linux/kthread.h>
+#include <linux/completion.h>
 
 /*
  * INTERFACES between SPI master-side drivers and SPI infrastructure.
@@ -150,8 +151,7 @@ static inline void *spi_get_drvdata(struct spi_device *spi)
 }
 
 struct spi_message;
-
-
+struct spi_transfer;
 
 /**
  * struct spi_driver - Host side "protocol" driver
@@ -259,6 +259,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @cur_msg: the currently in-flight message
  * @cur_msg_prepared: spi_prepare_message was called for the currently
  *                    in-flight message
+ * @xfer_completion: used by core tranfer_one_message()
  * @busy: message pump is busy
  * @running: message pump is running
  * @rt: whether this queue is set to run as a realtime task
@@ -276,9 +277,15 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @unprepare_transfer_hardware: there are currently no more messages on the
  *	queue so the subsystem notifies the driver that it may relax the
  *	hardware by issuing this call
+ * @set_cs: assert or deassert chip select, true to assert.  May be called
+ *          from interrupt context.
  * @prepare_message: set up the controller to transfer a single message,
  *                   for example doing DMA mapping.  Called from threaded
  *                   context.
+ * @transfer_one: transfer a single spi_transfer. When the
+ *	          driver is finished with this transfer it must call
+ *	          spi_finalize_current_transfer() so the subsystem can issue
+ *                the next transfer
  * @unprepare_message: undo any work done by prepare_message().
  * @cs_gpios: Array of GPIOs to use as chip select lines; one per CS
  *	number. Any individual value may be -ENOENT for CS lines that
@@ -395,6 +402,7 @@ struct spi_master {
 	bool				rt;
 	bool				auto_runtime_pm;
 	bool                            cur_msg_prepared;
+	struct completion               xfer_completion;
 
 	int (*prepare_transfer_hardware)(struct spi_master *master);
 	int (*transfer_one_message)(struct spi_master *master,
@@ -405,6 +413,14 @@ struct spi_master {
 	int (*unprepare_message)(struct spi_master *master,
 				 struct spi_message *message);
 
+	/*
+	 * These hooks are for drivers that use a generic implementation
+	 * of transfer_one_message() provied by the core.
+	 */
+	void (*set_cs)(struct spi_device *spi, bool enable);
+	int (*transfer_one)(struct spi_master *master, struct spi_device *spi,
+			    struct spi_transfer *transfer);
+
 	/* gpio chip select */
 	int			*cs_gpios;
 };
@@ -439,6 +455,7 @@ extern int spi_master_resume(struct spi_master *master);
 /* Calls the driver make to interact with the message queue */
 extern struct spi_message *spi_get_next_queued_message(struct spi_master *master);
 extern void spi_finalize_current_message(struct spi_master *master);
+extern void spi_finalize_current_transfer(struct spi_master *master);
 
 /* the spi driver core manages memory for the spi_master classdev */
 extern struct spi_master *

commit 2841a5fc375e9c573d10b82db30fa8a4cc25301c
Author: Mark Brown <broonie@linaro.org>
Date:   Sat Oct 5 00:23:12 2013 +0100

    spi: Provide per-message prepare and unprepare operations
    
    Many SPI drivers perform setup and tear down on every message, usually
    doing things like DMA mapping the message. Provide hooks for them to use
    to provide such operations.
    
    This is of limited value for drivers that implement transfer_one_message()
    but will be of much greater utility with future factoring out of standard
    implementations of that function.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 887116dbce2c..000b50bee6c0 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -257,6 +257,8 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @queue_lock: spinlock to syncronise access to message queue
  * @queue: message queue
  * @cur_msg: the currently in-flight message
+ * @cur_msg_prepared: spi_prepare_message was called for the currently
+ *                    in-flight message
  * @busy: message pump is busy
  * @running: message pump is running
  * @rt: whether this queue is set to run as a realtime task
@@ -274,6 +276,10 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @unprepare_transfer_hardware: there are currently no more messages on the
  *	queue so the subsystem notifies the driver that it may relax the
  *	hardware by issuing this call
+ * @prepare_message: set up the controller to transfer a single message,
+ *                   for example doing DMA mapping.  Called from threaded
+ *                   context.
+ * @unprepare_message: undo any work done by prepare_message().
  * @cs_gpios: Array of GPIOs to use as chip select lines; one per CS
  *	number. Any individual value may be -ENOENT for CS lines that
  *	are not GPIOs (driven by the SPI controller itself).
@@ -388,11 +394,16 @@ struct spi_master {
 	bool				running;
 	bool				rt;
 	bool				auto_runtime_pm;
+	bool                            cur_msg_prepared;
 
 	int (*prepare_transfer_hardware)(struct spi_master *master);
 	int (*transfer_one_message)(struct spi_master *master,
 				    struct spi_message *mesg);
 	int (*unprepare_transfer_hardware)(struct spi_master *master);
+	int (*prepare_message)(struct spi_master *master,
+			       struct spi_message *message);
+	int (*unprepare_message)(struct spi_master *master,
+				 struct spi_message *message);
 
 	/* gpio chip select */
 	int			*cs_gpios;

commit 05071aa864e84000759191438a4a9ff7ba2c360e
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Sep 27 16:34:27 2013 +0200

    spi: Add a spi_w8r16be() helper
    
    This patch adds a new spi_w8r16be() helper, which is similar to spi_w8r16()
    except that it converts the read data word from big endian to native endianness
    before returning it. The reason for introducing this new helper is that for SPI
    slave devices it is quite common that the read 16 bit data word is in big
    endian. So users of spi_w8r16() have to convert the result to native endianness
    manually. A second reason is that in this case the endianness of the return
    value of spi_w8r16() depends on its sign. If it is negative (i.e. a error code)
    it is already in native endianness, if it is positive it is in big endian. The
    sparse code checker doesn't like this kind of mixed endianness and special
    annotations are necessary to keep it quiet (E.g. casting to be16 using __force).
    Doing the conversion to native endianness in the helper function does not
    require such annotations since we are not mixing different endiannesses in the
    same variable.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 887116dbce2c..0e0aebdeb56b 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -823,6 +823,33 @@ static inline ssize_t spi_w8r16(struct spi_device *spi, u8 cmd)
 	return (status < 0) ? status : result;
 }
 
+/**
+ * spi_w8r16be - SPI synchronous 8 bit write followed by 16 bit big-endian read
+ * @spi: device with which data will be exchanged
+ * @cmd: command to be written before data is read back
+ * Context: can sleep
+ *
+ * This returns the (unsigned) sixteen bit number returned by the device in cpu
+ * endianness, or else a negative error code. Callable only from contexts that
+ * can sleep.
+ *
+ * This function is similar to spi_w8r16, with the exception that it will
+ * convert the read 16 bit data word from big-endian to native endianness.
+ *
+ */
+static inline ssize_t spi_w8r16be(struct spi_device *spi, u8 cmd)
+
+{
+	ssize_t status;
+	__be16 result;
+
+	status = spi_write_then_read(spi, &cmd, 1, &result, 2);
+	if (status < 0)
+		return status;
+
+	return be16_to_cpu(result);
+}
+
 /*---------------------------------------------------------------------------*/
 
 /*

commit 666d5b4c742ba666eb68b467d777b7862f362ae5
Author: Mark Brown <broonie@linaro.org>
Date:   Sat Aug 31 18:50:52 2013 +0100

    spi: core: Add devm_spi_register_master()
    
    Help simplify the cleanup code for SPI master drivers by providing a
    managed master registration function, ensuring that the master is
    automatically unregistered whenever the device is unbound.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 887116dbce2c..4d634d66ba0b 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -434,6 +434,8 @@ extern struct spi_master *
 spi_alloc_master(struct device *host, unsigned size);
 
 extern int spi_register_master(struct spi_master *master);
+extern int devm_spi_register_master(struct device *dev,
+				    struct spi_master *master);
 extern void spi_unregister_master(struct spi_master *master);
 
 extern struct spi_master *spi_busnum_to_master(u16 busnum);

commit 85cac431329bd09f7d30d489591d7af0d658b008
Merge: 793b3cb6acc0 b6460366fbad
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Sep 1 13:49:06 2013 +0100

    Merge remote-tracking branch 'spi/topic/qspi' into spi-next

commit 9020b75467ff81b2ae257bbf19acff462854d4ab
Merge: 84c86edab3a3 078726ce6d56
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Sep 1 13:48:58 2013 +0100

    Merge remote-tracking branch 'spi/topic/msglen' into spi-next

commit db04e17055c2d912a847f02a10deee1d82f96300
Merge: 788a73967658 56ede94a000b
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Sep 1 13:48:48 2013 +0100

    Merge remote-tracking branch 'spi/topic/checks' into spi-next

commit 21e34a3306e7f0399cc0e10c24cb0e7790dfbcac
Merge: 505a14954e2d db90a44177ac
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Aug 23 12:00:15 2013 +0100

    Merge remote-tracking branch 'spi/topic/quad' into spi-qspi

commit f477b7fb13df2b843997559ff34e87d054ba6538
Author: wangyuhang <wangyuhang2014@gmail.com>
Date:   Sun Aug 11 18:15:17 2013 +0800

    spi: DUAL and QUAD support
    
    fix the previous patch some mistake below:
    1. DT in slave node, use "spi-tx-nbits = <1/2/4>" in place of using
       "spi-tx-dual, spi-tx-quad" directly, same to rx. So correct the
       previous way to get the property in @of_register_spi_devices().
    2. Change the value of transfer bit macro(SPI_NBITS_SINGLE, SPI_NBITS_DUAL
       SPI_NBITS_QUAD) to 0x01, 0x02 and 0x04 to match the actual wires.
    3. Add the following check
       (1)keep the tx_nbits and rx_nbits in spi_transfer is not beyond the
          single, dual and quad.
       (2)keep tx_nbits and rx_nbits are contained by @spi_device->mode
          example: if @spi_device->mode = DUAL, then tx/rx_nbits can not be set
                   to QUAD(SPI_NBITS_QUAD)
       (3)if "@spi_device->mode & SPI_3WIRE", then tx/rx_nbits should be in
          single(SPI_NBITS_SINGLE)
    
    Signed-off-by: wangyuhang <wangyuhang2014@gmail.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index cdf668156154..ccd7840c4507 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -74,7 +74,7 @@ struct spi_device {
 	struct spi_master	*master;
 	u32			max_speed_hz;
 	u8			chip_select;
-	u8			mode;
+	u16			mode;
 #define	SPI_CPHA	0x01			/* clock phase */
 #define	SPI_CPOL	0x02			/* clock polarity */
 #define	SPI_MODE_0	(0|0)			/* (original MicroWire) */
@@ -87,6 +87,10 @@ struct spi_device {
 #define	SPI_LOOP	0x20			/* loopback mode */
 #define	SPI_NO_CS	0x40			/* 1 dev/bus, no chipselect */
 #define	SPI_READY	0x80			/* slave pulls low to pause */
+#define	SPI_TX_DUAL	0x100			/* transmit with 2 wires */
+#define	SPI_TX_QUAD	0x200			/* transmit with 4 wires */
+#define	SPI_RX_DUAL	0x400			/* receive with 2 wires */
+#define	SPI_RX_QUAD	0x800			/* receive with 4 wires */
 	u8			bits_per_word;
 	int			irq;
 	void			*controller_state;
@@ -454,6 +458,10 @@ extern struct spi_master *spi_busnum_to_master(u16 busnum);
  * @rx_buf: data to be read (dma-safe memory), or NULL
  * @tx_dma: DMA address of tx_buf, if @spi_message.is_dma_mapped
  * @rx_dma: DMA address of rx_buf, if @spi_message.is_dma_mapped
+ * @tx_nbits: number of bits used for writting. If 0 the default
+ *      (SPI_NBITS_SINGLE) is used.
+ * @rx_nbits: number of bits used for reading. If 0 the default
+ *      (SPI_NBITS_SINGLE) is used.
  * @len: size of rx and tx buffers (in bytes)
  * @speed_hz: Select a speed other than the device default for this
  *      transfer. If 0 the default (from @spi_device) is used.
@@ -508,6 +516,11 @@ extern struct spi_master *spi_busnum_to_master(u16 busnum);
  * by the results of previous messages and where the whole transaction
  * ends when the chipselect goes intactive.
  *
+ * When SPI can transfer in 1x,2x or 4x. It can get this tranfer information
+ * from device through @tx_nbits and @rx_nbits. In Bi-direction, these
+ * two should both be set. User can set transfer mode with SPI_NBITS_SINGLE(1x)
+ * SPI_NBITS_DUAL(2x) and SPI_NBITS_QUAD(4x) to support these three transfer.
+ *
  * The code that submits an spi_message (and its spi_transfers)
  * to the lower layers is responsible for managing its memory.
  * Zero-initialize every field you don't set up explicitly, to
@@ -528,6 +541,11 @@ struct spi_transfer {
 	dma_addr_t	rx_dma;
 
 	unsigned	cs_change:1;
+	u8		tx_nbits;
+	u8		rx_nbits;
+#define	SPI_NBITS_SINGLE	0x01 /* 1bit transfer */
+#define	SPI_NBITS_DUAL		0x02 /* 2bits transfer */
+#define	SPI_NBITS_QUAD		0x04 /* 4bits transfer */
 	u8		bits_per_word;
 	u16		delay_usecs;
 	u32		speed_hz;
@@ -875,7 +893,7 @@ struct spi_board_info {
 	/* mode becomes spi_device.mode, and is essential for chips
 	 * where the default of SPI_CS_HIGH = 0 is wrong.
 	 */
-	u8		mode;
+	u16		mode;
 
 	/* ... may need additional spi_device chip config data here.
 	 * avoid stuff protocol drivers can set; but include stuff

commit b6aa23ccaea1548cfb404b41129717f13443bccf
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Aug 1 16:08:57 2013 -0600

    spi: fix SPI_BIT_MASK so it always fits into 32-bits
    
    On a 64-bit platform, ~0UL fills 64-bits, which causes SPI_BIT_MASK(32)
    not to fit into 32 bits. This causes a warning when the result is assigned
    to a 32-bit variable. Use ~0U instead to prevent this. This fixes:
    
    drivers/spi/spi-gpio.c: In function 'spi_gpio_probe':
    drivers/spi/spi-gpio.c:446:2: warning: large integer implicitly truncated to unsigned type [-Woverflow]
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 28e440be1c07..c920c2f4dad5 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -309,7 +309,7 @@ struct spi_master {
 	/* bitmask of supported bits_per_word for transfers */
 	u32			bits_per_word_mask;
 #define SPI_BPW_MASK(bits) BIT((bits) - 1)
-#define SPI_BIT_MASK(bits) (((bits) == 32) ? ~0UL : (BIT(bits) - 1))
+#define SPI_BIT_MASK(bits) (((bits) == 32) ? ~0U : (BIT(bits) - 1))
 #define SPI_BPW_RANGE_MASK(min, max) (SPI_BIT_MASK(max) - SPI_BIT_MASK(min - 1))
 
 	/* other constraints relevant to this driver */

commit 49834de234f3cf592c3d242c889ca603db8e7050
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Jul 28 14:47:02 2013 +0100

    spi: Provide core support for runtime PM during transfers
    
    Most SPI drivers that implement runtime PM support use identical code to
    do so: they acquire a runtime PM lock in prepare_transfer_hardware() and
    then they release it in unprepare_transfer_hardware(). The variations in
    this are mostly missing error checking and the choice to use autosuspend.
    
    Since these runtime PM calls are normally the only thing in the prepare
    and unprepare callbacks and the autosuspend API transparently does the
    right thing on devices with autosuspend disabled factor all of this out
    into the core with a flag to enable the behaviour.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Reviewed-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 28e440be1c07..bf0204c00053 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -254,6 +254,9 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @busy: message pump is busy
  * @running: message pump is running
  * @rt: whether this queue is set to run as a realtime task
+ * @auto_runtime_pm: the core should ensure a runtime PM reference is held
+ *                   while the hardware is prepared, using the parent
+ *                   device for the spidev
  * @prepare_transfer_hardware: a message will soon arrive from the queue
  *	so the subsystem requests the driver to prepare the transfer hardware
  *	by issuing this call
@@ -374,11 +377,13 @@ struct spi_master {
 	bool				busy;
 	bool				running;
 	bool				rt;
+	bool				auto_runtime_pm;
 
 	int (*prepare_transfer_hardware)(struct spi_master *master);
 	int (*transfer_one_message)(struct spi_master *master,
 				    struct spi_message *mesg);
 	int (*unprepare_transfer_hardware)(struct spi_master *master);
+
 	/* gpio chip select */
 	int			*cs_gpios;
 };

commit 078726ce6d56a767533064e0f2f2100d7cb6fc22
Author: Sourav Poddar <sourav.poddar@ti.com>
Date:   Thu Jul 18 15:31:25 2013 +0530

    driver: spi: Modify core to compute the message length
    
    Make spi core calculate the message length while
    populating the other transfer parameters.
    
    Usecase, driver can use it to populate framelength filed in their
    controller.
    
    Signed-off-by: Sourav Poddar <sourav.poddar@ti.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 28e440be1c07..aadd0a885a0f 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -578,6 +578,7 @@ struct spi_message {
 	/* completion is reported through a callback */
 	void			(*complete)(void *context);
 	void			*context;
+	unsigned		frame_length;
 	unsigned		actual_length;
 	int			status;
 

commit a2fd4f9fa3b9f051550b36c4dfa74bc32bda24ee
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Jul 10 14:57:26 2013 +0100

    spi: Support transfer speed checking in the core
    
    Allow drivers to avoid implementing their own checks for simple rates by
    specifying the limits in the master structure.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 28e440be1c07..cdf668156154 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -233,6 +233,8 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *	suported. If set, the SPI core will reject any transfer with an
  *	unsupported bits_per_word. If not set, this value is simply ignored,
  *	and it's up to the individual driver to perform any validation.
+ * @min_speed_hz: Lowest supported transfer speed
+ * @max_speed_hz: Highest supported transfer speed
  * @flags: other constraints relevant to this driver
  * @bus_lock_spinlock: spinlock for SPI bus locking
  * @bus_lock_mutex: mutex for SPI bus locking
@@ -312,6 +314,10 @@ struct spi_master {
 #define SPI_BIT_MASK(bits) (((bits) == 32) ? ~0UL : (BIT(bits) - 1))
 #define SPI_BPW_RANGE_MASK(min, max) (SPI_BIT_MASK(max) - SPI_BIT_MASK(min - 1))
 
+	/* limits on transfer speed */
+	u32			min_speed_hz;
+	u32			max_speed_hz;
+
 	/* other constraints relevant to this driver */
 	u16			flags;
 #define SPI_MASTER_HALF_DUPLEX	BIT(0)		/* can't do full duplex */

commit eca8960a8e0f48dc62c1063bcc33a626455d766e
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu May 30 09:59:40 2013 -0600

    spi: fix incorrect handling of min param in SPI_BPW_RANGE_MASK
    
    SPI_BPW_RANGE_MASK is intended to work by calculating two masks; one
    representing support for all bits up-to-and-including the "max" supported
    value, and one representing support for all bits up-to-but-not-including
    the "min" supported value, and then taking the difference between the
    two, resulting in a mask representing support for all bits between
    (inclusive) the min and max values.
    
    However, the second mask ended up representing all bits up-to-and-
    including rather up-to-but-not-including. Fix this bug.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 3e9479134d9d..28e440be1c07 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -310,7 +310,7 @@ struct spi_master {
 	u32			bits_per_word_mask;
 #define SPI_BPW_MASK(bits) BIT((bits) - 1)
 #define SPI_BIT_MASK(bits) (((bits) == 32) ? ~0UL : (BIT(bits) - 1))
-#define SPI_BPW_RANGE_MASK(min, max) (SPI_BIT_MASK(max) - SPI_BIT_MASK(min))
+#define SPI_BPW_RANGE_MASK(min, max) (SPI_BIT_MASK(max) - SPI_BIT_MASK(min - 1))
 
 	/* other constraints relevant to this driver */
 	u16			flags;

commit 4dd9572abc224019a042b662fb0eececca283cb9
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu May 30 09:59:39 2013 -0600

    spi: fix undefined behaviour in SPI_BPW_RANGE_MASK
    
    The parameters to SPI_BPW_RANGE_MASK() are in the range 1..32. If 32 is
    used as a parameter, part of the expression is "1 << 32". Since 32 is >=
    the size of the type in use, such a shift is undefined behaviour. Add
    macro SPI_BIT_MASK to Implement a special case and thus avoid undefined
    behaviour. Use this new macro rather than BIT() when implementing
    SPI_BPW_RANGE_MASK().
    
    This fixes build warnings such as:
    drivers/spi/spi-gpio.c:446:2: warning: left shift count >= width of type [enabled by default]
    
    SPI_BPW_MASK() already avoids this, since its parameter is also in range
    1..32, yet it only shifts by up to one less than the input parameter.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 173725622252..3e9479134d9d 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -309,7 +309,8 @@ struct spi_master {
 	/* bitmask of supported bits_per_word for transfers */
 	u32			bits_per_word_mask;
 #define SPI_BPW_MASK(bits) BIT((bits) - 1)
-#define SPI_BPW_RANGE_MASK(min, max) ((BIT(max) - 1) - (BIT(min) - 1))
+#define SPI_BIT_MASK(bits) (((bits) == 32) ? ~0UL : (BIT(bits) - 1))
+#define SPI_BPW_RANGE_MASK(min, max) (SPI_BIT_MASK(max) - SPI_BIT_MASK(min))
 
 	/* other constraints relevant to this driver */
 	u16			flags;

commit 2922a8de996956893bb98e4aa91be9774c958336
Author: Stephen Warren <swarren@wwwdotorg.org>
Date:   Tue May 21 20:36:34 2013 -0600

    spi: introduce macros to set bits_per_word_mask
    
    Introduce two macros to make setting up spi_master.bits_per_word_mask
    easier, and avoid mistakes like writing BIT(n) instead of BIT(n - 1).
    
    SPI_BPW_MASK is for a single supported value of bits_per_word_mask.
    
    SPI_BPW_RANGE_MASK represents a contiguous set of bit lengths.
    
    Signed-off-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 6ff26c8db7b9..173725622252 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -308,6 +308,8 @@ struct spi_master {
 
 	/* bitmask of supported bits_per_word for transfers */
 	u32			bits_per_word_mask;
+#define SPI_BPW_MASK(bits) BIT((bits) - 1)
+#define SPI_BPW_RANGE_MASK(min, max) ((BIT(max) - 1) - (BIT(min) - 1))
 
 	/* other constraints relevant to this driver */
 	u16			flags;

commit 88b0357dde1c2721a64268e4601d1c2dec1158b0
Merge: 0faa3146f172 3086c9f64821
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon May 13 18:27:18 2013 +0400

    Merge remote-tracking branch 'spi/fix/grant' into spi-linus

commit 446411e18b2cb17d153e45f634a3c9a79ada3ac2
Author: Andreas Larsson <andreas@gaisler.com>
Date:   Wed Feb 13 14:20:25 2013 +0100

    spi: Initialize cs_gpio and cs_gpios with -ENOENT
    
    The return value from of_get_named_gpio is -ENOENT when the given index
    matches a hole in the "cs-gpios" property phandle list. However, the
    default value of cs_gpio in struct spi_device and entries of cs_gpios in
    struct spi_master is -EINVAL, which is documented to indicate that a
    GPIO line should not be used for the given spi_device.
    
    This sets the default value of cs_gpio in struct spi_device and entries
    of cs_gpios in struct spi_master to -ENOENT. Thus, -ENOENT is the only
    value used to indicate that no GPIO line should be used.
    
    Signed-off-by: Andreas Larsson <andreas@gaisler.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 38c2b925923d..c395f32b53b3 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -57,7 +57,7 @@ extern struct bus_type spi_bus_type;
  * @modalias: Name of the driver to use with this device, or an alias
  *	for that name.  This appears in the sysfs "modalias" attribute
  *	for driver coldplugging, and in uevents used for hotplugging
- * @cs_gpio: gpio number of the chipselect line (optional, -EINVAL when
+ * @cs_gpio: gpio number of the chipselect line (optional, -ENOENT when
  *	when not using a GPIO line)
  *
  * A @spi_device is used to interchange data between an SPI slave
@@ -261,7 +261,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *	queue so the subsystem notifies the driver that it may relax the
  *	hardware by issuing this call
  * @cs_gpios: Array of GPIOs to use as chip select lines; one per CS
- *	number. Any individual value may be -EINVAL for CS lines that
+ *	number. Any individual value may be -ENOENT for CS lines that
  *	are not GPIOs (driven by the SPI controller itself).
  *
  * Each SPI master controller can communicate with one or more @spi_device

commit 543bb255a1987836e64f5b7a63664ead8b32b042
Author: Stephen Warren <swarren@wwwdotorg.org>
Date:   Tue Mar 26 20:37:57 2013 -0600

    spi: add ability to validate xfer->bits_per_word in SPI core
    
    Allow SPI masters to define the set of bits_per_word values they support.
    If they do this, then the SPI core will reject transfers that attempt to
    use an unsupported bits_per_word value. This eliminates the need for each
    SPI driver to implement this checking in most cases.
    
    Signed-off-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 38c2b925923d..733eb5ee31c5 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -228,6 +228,11 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *	every chipselect is connected to a slave.
  * @dma_alignment: SPI controller constraint on DMA buffers alignment.
  * @mode_bits: flags understood by this controller driver
+ * @bits_per_word_mask: A mask indicating which values of bits_per_word are
+ *	supported by the driver. Bit n indicates that a bits_per_word n+1 is
+ *	suported. If set, the SPI core will reject any transfer with an
+ *	unsupported bits_per_word. If not set, this value is simply ignored,
+ *	and it's up to the individual driver to perform any validation.
  * @flags: other constraints relevant to this driver
  * @bus_lock_spinlock: spinlock for SPI bus locking
  * @bus_lock_mutex: mutex for SPI bus locking
@@ -301,6 +306,9 @@ struct spi_master {
 	/* spi_device.mode flags understood by this controller driver */
 	u16			mode_bits;
 
+	/* bitmask of supported bits_per_word for transfers */
+	u32			bits_per_word_mask;
+
 	/* other constraints relevant to this driver */
 	u16			flags;
 #define SPI_MASTER_HALF_DUPLEX	BIT(0)		/* can't do full duplex */

commit b5c78e04dd061b776978dad61dd85357081147b0
Merge: 06991c28f37a 951348b37738
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 21 12:11:44 2013 -0800

    Merge tag 'staging-3.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging tree update from Greg Kroah-Hartman:
     "Here's the big staging tree merge for 3.9-rc1
    
      Lots of cleanups and updates for drivers all through the staging tree.
      We are pretty much "code neutral" here, adding just about as many
      lines as we removed.
    
      All of these have been in linux-next for a while."
    
    * tag 'staging-3.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (804 commits)
      staging: comedi: vmk80xx: wait for URBs to complete
      staging: comedi: drivers: addi-data: hwdrv_apci3200.c: Add a missing semicolon
      staging: et131x: Update TODO list
      staging: et131x: Remove assignment of skb->dev
      staging: wlan-ng: hfa384x.h: fix for error reported by smatch
      staging/zache checkpatch ERROR: spaces prohibited around that
      staging/ozwpan: Mark read only parameters and structs as const
      staging/ozwpan: Remove empty and unused function oz_cdev_heartbeat
      staging/ozwpan: Mark local functions as static (fix sparse warnings)
      staging/ozwpan: Add missing header includes
      staging/usbip: Mark local functions as static (fix sparse warnings)
      staging/xgifb: Remove duplicated code in loops.
      staging/xgifb: Consolidate return paths
      staging/xgifb: Remove code without effect
      staging/xgifb: Remove unnecessary casts
      staging/xgifb: Consolidate if/else if with identical code branches
      staging: vt6656: replaced custom TRUE definition with true
      staging: vt6656: replaced custom FALSE definition with false
      staging: vt6656: replace custom BOOL definition with bool
      staging/rtl8187se: Mark functions as static to silence sparse
      ...

commit 095c3752e673c0ba039a2f67fd867297fde75ae7
Author: Andreas Larsson <andreas@gaisler.com>
Date:   Tue Jan 29 15:53:41 2013 +0100

    spi: Document cs_gpios and cs_gpio in kernel-doc
    
    This adds missing kernel-doc entries for cs_gpios in struct spi_master and
    cs_gpio in struct spi_device.
    
    Signed-off-by: Andreas Larsson <andreas@gaisler.com>
    [grant.likely: tweaked the language of the descriptions]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index f62918946d86..30e9c50a5e20 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -57,6 +57,8 @@ extern struct bus_type spi_bus_type;
  * @modalias: Name of the driver to use with this device, or an alias
  *	for that name.  This appears in the sysfs "modalias" attribute
  *	for driver coldplugging, and in uevents used for hotplugging
+ * @cs_gpio: gpio number of the chipselect line (optional, -EINVAL when
+ *	when not using a GPIO line)
  *
  * A @spi_device is used to interchange data between an SPI slave
  * (usually a discrete chip) and CPU memory.
@@ -258,6 +260,9 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @unprepare_transfer_hardware: there are currently no more messages on the
  *	queue so the subsystem notifies the driver that it may relax the
  *	hardware by issuing this call
+ * @cs_gpios: Array of GPIOs to use as chip select lines; one per CS
+ *	number. Any individual value may be -EINVAL for CS lines that
+ *	are not GPIOs (driven by the SPI controller itself).
  *
  * Each SPI master controller can communicate with one or more @spi_device
  * children.  These make a small bus, sharing MOSI, MISO and SCK signals

commit 6d9eecd418afb2c12e5db5be3d72f0f1df43bdd9
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Jan 9 17:31:00 2013 +0000

    spi: Add helper functions for setting up transfers
    
    Quite often the pattern used for setting up and transferring a synchronous SPI
    transaction looks very much like the following:
    
            struct spi_message msg;
            struct spi_transfer xfers[] = {
                    ...
            };
    
            spi_message_init(&msg);
            spi_message_add_tail(&xfers[0], &msg);
            ...
            spi_message_add_tail(&xfers[ARRAY_SIZE(xfers) - 1], &msg);
    
            ret = spi_sync(&msg);
    
    This patch adds two new helper functions for handling this case. The first
    helper function spi_message_init_with_transfers() takes a spi_message and an
    array of spi_transfers. It will initialize the message and then call
    spi_message_add_tail() for each transfer in the array. E.g. the following
    
            spi_message_init(&msg);
            spi_message_add_tail(&xfers[0], &msg);
            ...
            spi_message_add_tail(&xfers[ARRAY_SIZE(xfers) - 1], &msg);
    
    can be rewritten as
    
            spi_message_init_with_transfers(&msg, xfers, ARRAY_SIZE(xfers));
    
    The second function spi_sync_transfer() takes a SPI device and an array of
    spi_transfers. It will allocate a new spi_message (on the stack) and add all
    transfers in the array to the message. Finally it will call spi_sync() on the
    message.
    
    E.g. the follwing
    
            struct spi_message msg;
            struct spi_transfer xfers[] = {
                    ...
            };
    
            spi_message_init(&msg);
            spi_message_add_tail(&xfers[0], &msg);
            ...
            spi_message_add_tail(&xfers[ARRAY_SIZE(xfers) - 1], &msg);
    
            ret = spi_sync(spi, &msg);
    
    can be rewritten as
    
            struct spi_transfer xfers[] = {
                    ...
            };
    
            ret = spi_sync_transfer(spi, xfers, ARRAY_SIZE(xfers));
    
    A coccinelle script to find such instances will follow.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index f62918946d86..7dbe58642525 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -591,6 +591,26 @@ spi_transfer_del(struct spi_transfer *t)
 	list_del(&t->transfer_list);
 }
 
+/**
+ * spi_message_init_with_transfers - Initialize spi_message and append transfers
+ * @m: spi_message to be initialized
+ * @xfers: An array of spi transfers
+ * @num_xfers: Number of items in the xfer array
+ *
+ * This function initializes the given spi_message and adds each spi_transfer in
+ * the given array to the message.
+ */
+static inline void
+spi_message_init_with_transfers(struct spi_message *m,
+struct spi_transfer *xfers, unsigned int num_xfers)
+{
+	unsigned int i;
+
+	spi_message_init(m);
+	for (i = 0; i < num_xfers; ++i)
+		spi_message_add_tail(&xfers[i], m);
+}
+
 /* It's fine to embed message and transaction structures in other data
  * structures so long as you don't free them while they're in use.
  */
@@ -683,6 +703,30 @@ spi_read(struct spi_device *spi, void *buf, size_t len)
 	return spi_sync(spi, &m);
 }
 
+/**
+ * spi_sync_transfer - synchronous SPI data transfer
+ * @spi: device with which data will be exchanged
+ * @xfers: An array of spi_transfers
+ * @num_xfers: Number of items in the xfer array
+ * Context: can sleep
+ *
+ * Does a synchronous SPI data transfer of the given spi_transfer array.
+ *
+ * For more specific semantics see spi_sync().
+ *
+ * It returns zero on success, else a negative error code.
+ */
+static inline int
+spi_sync_transfer(struct spi_device *spi, struct spi_transfer *xfers,
+	unsigned int num_xfers)
+{
+	struct spi_message msg;
+
+	spi_message_init_with_transfers(&msg, xfers, num_xfers);
+
+	return spi_sync(spi, &msg);
+}
+
 /* this copies txbuf and rxbuf data; for small transfers only! */
 extern int spi_write_then_read(struct spi_device *spi,
 		const void *txbuf, unsigned n_tx,

commit 743179849015dc71bb2ea63d8cd4bfa7fdfb4bc6
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Thu Nov 15 20:19:57 2012 +0100

    of_spi: add generic binding support to specify cs gpio
    
    This will allow to use gpio for chip select with no modification in the
    driver binding
    
    When use the cs-gpios, the gpio number will be passed via the cs_gpio field
    and the number of chip select will automatically increased with max(hw cs, gpio cs).
    
    So if for example the controller has 2 CS lines, and the cs-gpios
    property looks like this:
    
    cs-gpios = <&gpio1 0 0> <0> <&gpio1 1 0> <&gpio1 2 0>;
    
    Then it should be configured so that num_chipselect = 4 with the
    following mapping:
    
    cs0 : &gpio1 0 0
    cs1 : native
    cs2 : &gpio1 1 0
    cs3 : &gpio1 2 0
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Cc: devicetree-discuss@lists.ozlabs.org
    Cc: spi-devel-general@lists.sourceforge.net
    Signed-off-by: Richard Genoud <richard.genoud@gmail.com>
    [grant.likely: fixed up type of cs count so min() can do type checking]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index fa702aeb5038..f62918946d86 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -90,6 +90,7 @@ struct spi_device {
 	void			*controller_state;
 	void			*controller_data;
 	char			modalias[SPI_NAME_SIZE];
+	int			cs_gpio;	/* chip select gpio */
 
 	/*
 	 * likely need more hooks for more protocol options affecting how
@@ -362,6 +363,8 @@ struct spi_master {
 	int (*transfer_one_message)(struct spi_master *master,
 				    struct spi_message *mesg);
 	int (*unprepare_transfer_hardware)(struct spi_master *master);
+	/* gpio chip select */
+	int			*cs_gpios;
 };
 
 static inline void *spi_master_get_devdata(struct spi_master *master)

commit dbabe0d659d3cfe42830a779909ab3cd42f7b027
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Tue Apr 17 17:03:50 2012 -0700

    spi: fix spi.h kernel-doc warning
    
    Fix kernel-doc warning in spi.h (copy/paste):
    
    Warning(include/linux/spi/spi.h:365): No description found for parameter 'unprepare_transfer_hardware'
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 98679b061b63..fa702aeb5038 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -254,7 +254,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *	driver is finished with this message, it must call
  *	spi_finalize_current_message() so the subsystem can issue the next
  *	transfer
- * @prepare_transfer_hardware: there are currently no more messages on the
+ * @unprepare_transfer_hardware: there are currently no more messages on the
  *	queue so the subsystem notifies the driver that it may relax the
  *	hardware by issuing this call
  *

commit 8f53602be555e500cfcd957955bb40fac19f2a6b
Author: Shubhrajyoti D <shubhrajyoti@ti.com>
Date:   Mon Feb 27 19:29:05 2012 +0530

    spi: Trivial warning fix
    
    The loop count i traverses for ntrans which is unsigned
    so make the loop count i also unsigned.
    
    Fix the below warning
    In file included from drivers/spi/spi-omap2-mcspi.c:38:
    include/linux/spi/spi.h: In function 'spi_message_alloc':
    include/linux/spi/spi.h:556: warning: comparison between signed and unsigned integer expressions
    
    Cc: Vitaly Wool <vwool@ru.mvista.com>
    Signed-off-by: Shubhrajyoti D <shubhrajyoti@ti.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index f9e30a5b3543..98679b061b63 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -600,7 +600,7 @@ static inline struct spi_message *spi_message_alloc(unsigned ntrans, gfp_t flags
 			+ ntrans * sizeof(struct spi_transfer),
 			flags);
 	if (m) {
-		int i;
+		unsigned i;
 		struct spi_transfer *t = (struct spi_transfer *)(m + 1);
 
 		INIT_LIST_HEAD(&m->transfers);

commit ffbbdd21329f3e15eeca6df2d4bc11c04d9d91c0
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Feb 22 10:05:38 2012 +0100

    spi: create a message queueing infrastructure
    
    This rips the message queue in the PL022 driver out and pushes
    it into (optional) common infrastructure. Drivers that want to
    use the message pumping thread will need to define the new
    per-messags transfer methods and leave the deprecated transfer()
    method as NULL.
    
    Most of the design is described in the documentation changes that
    are included in this patch.
    
    Since there is a queue that need to be stopped when the system
    is suspending/resuming, two new calls are implemented for the
    device drivers to call in their suspend()/resume() functions:
    spi_master_suspend() and spi_master_resume().
    
    ChangeLog v1->v2:
    - Remove Kconfig entry and do not make the queue support optional
      at all, instead be more agressive and have it as part of the
      compulsory infrastructure.
    - If the .transfer() method is implemented, delete print a small
      deprecation notice and do not start the transfer pump.
    - Fix a bitrotted comment.
    ChangeLog v2->v3:
    - Fix up a problematic sequence courtesy of Chris Blair.
    - Stop rather than destroy the queue on suspend() courtesy of
      Chris Blair.
    
    Signed-off-by: Chris Blair <chris.blair@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 176fce9cc6b1..f9e30a5b3543 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -22,6 +22,7 @@
 #include <linux/device.h>
 #include <linux/mod_devicetable.h>
 #include <linux/slab.h>
+#include <linux/kthread.h>
 
 /*
  * INTERFACES between SPI master-side drivers and SPI infrastructure.
@@ -235,6 +236,27 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *	the device whose settings are being modified.
  * @transfer: adds a message to the controller's transfer queue.
  * @cleanup: frees controller-specific state
+ * @queued: whether this master is providing an internal message queue
+ * @kworker: thread struct for message pump
+ * @kworker_task: pointer to task for message pump kworker thread
+ * @pump_messages: work struct for scheduling work to the message pump
+ * @queue_lock: spinlock to syncronise access to message queue
+ * @queue: message queue
+ * @cur_msg: the currently in-flight message
+ * @busy: message pump is busy
+ * @running: message pump is running
+ * @rt: whether this queue is set to run as a realtime task
+ * @prepare_transfer_hardware: a message will soon arrive from the queue
+ *	so the subsystem requests the driver to prepare the transfer hardware
+ *	by issuing this call
+ * @transfer_one_message: the subsystem calls the driver to transfer a single
+ *	message while queuing transfers that arrive in the meantime. When the
+ *	driver is finished with this message, it must call
+ *	spi_finalize_current_message() so the subsystem can issue the next
+ *	transfer
+ * @prepare_transfer_hardware: there are currently no more messages on the
+ *	queue so the subsystem notifies the driver that it may relax the
+ *	hardware by issuing this call
  *
  * Each SPI master controller can communicate with one or more @spi_device
  * children.  These make a small bus, sharing MOSI, MISO and SCK signals
@@ -318,6 +340,28 @@ struct spi_master {
 
 	/* called on release() to free memory provided by spi_master */
 	void			(*cleanup)(struct spi_device *spi);
+
+	/*
+	 * These hooks are for drivers that want to use the generic
+	 * master transfer queueing mechanism. If these are used, the
+	 * transfer() function above must NOT be specified by the driver.
+	 * Over time we expect SPI drivers to be phased over to this API.
+	 */
+	bool				queued;
+	struct kthread_worker		kworker;
+	struct task_struct		*kworker_task;
+	struct kthread_work		pump_messages;
+	spinlock_t			queue_lock;
+	struct list_head		queue;
+	struct spi_message		*cur_msg;
+	bool				busy;
+	bool				running;
+	bool				rt;
+
+	int (*prepare_transfer_hardware)(struct spi_master *master);
+	int (*transfer_one_message)(struct spi_master *master,
+				    struct spi_message *mesg);
+	int (*unprepare_transfer_hardware)(struct spi_master *master);
 };
 
 static inline void *spi_master_get_devdata(struct spi_master *master)
@@ -343,6 +387,13 @@ static inline void spi_master_put(struct spi_master *master)
 		put_device(&master->dev);
 }
 
+/* PM calls that need to be issued by the driver */
+extern int spi_master_suspend(struct spi_master *master);
+extern int spi_master_resume(struct spi_master *master);
+
+/* Calls the driver make to interact with the message queue */
+extern struct spi_message *spi_get_next_queued_message(struct spi_master *master);
+extern void spi_finalize_current_message(struct spi_master *master);
 
 /* the spi driver core manages memory for the spi_master classdev */
 extern struct spi_master *

commit 3acbb0142d48713a8f65cde678a54f419801c189
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Nov 16 10:13:37 2011 +0100

    SPI: Add helper macro for spi_driver boilerplate
    
    This patch introduces the module_spi_driver macro which is a convenience macro
    for SPI driver modules similar to module_platform_driver. It is intended to be
    used by drivers which init/exit section does nothing but register/unregister
    the SPI driver. By using this macro it is possible to eliminate a few lines of
    boilerplate code per SPI driver.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index bb4f5fbbbd8e..176fce9cc6b1 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -200,6 +200,17 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
 		driver_unregister(&sdrv->driver);
 }
 
+/**
+ * module_spi_driver() - Helper macro for registering a SPI driver
+ * @__spi_driver: spi_driver struct
+ *
+ * Helper macro for SPI drivers which do not do anything special in module
+ * init/exit. This eliminates a lot of boilerplate. Each module may only
+ * use this macro once, and calling it replaces module_init() and module_exit()
+ */
+#define module_spi_driver(__spi_driver) \
+	module_driver(__spi_driver, spi_register_driver, \
+			spi_unregister_driver)
 
 /**
  * struct spi_master - interface to SPI master controller

commit 0c4a1590189b426814748d2e03b95541852b3af6
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed May 11 00:09:30 2011 +0200

    spi: Use void pointers for data in simple SPI I/O operations
    
    Currently the simple SPI I/O operations all take pointers to u8 * buffers
    to operate on. This creates needless type compatibility issues and the
    underlying spi_transfer structure uses void pointers anyway so convert the
    API over to take void pointers too.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index b4d7710bc38d..bb4f5fbbbd8e 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -581,7 +581,7 @@ extern int spi_bus_unlock(struct spi_master *master);
  * Callable only from contexts that can sleep.
  */
 static inline int
-spi_write(struct spi_device *spi, const u8 *buf, size_t len)
+spi_write(struct spi_device *spi, const void *buf, size_t len)
 {
 	struct spi_transfer	t = {
 			.tx_buf		= buf,
@@ -605,7 +605,7 @@ spi_write(struct spi_device *spi, const u8 *buf, size_t len)
  * Callable only from contexts that can sleep.
  */
 static inline int
-spi_read(struct spi_device *spi, u8 *buf, size_t len)
+spi_read(struct spi_device *spi, void *buf, size_t len)
 {
 	struct spi_transfer	t = {
 			.rx_buf		= buf,
@@ -620,8 +620,8 @@ spi_read(struct spi_device *spi, u8 *buf, size_t len)
 
 /* this copies txbuf and rxbuf data; for small transfers only! */
 extern int spi_write_then_read(struct spi_device *spi,
-		const u8 *txbuf, unsigned n_tx,
-		u8 *rxbuf, unsigned n_rx);
+		const void *txbuf, unsigned n_tx,
+		void *rxbuf, unsigned n_rx);
 
 /**
  * spi_w8r8 - SPI synchronous 8 bit write followed by 8 bit read

commit 2b9603a0d7e395fb844af90fba71448bc8019077
Author: Feng Tang <feng.tang@intel.com>
Date:   Mon Aug 2 15:52:15 2010 +0800

    spi: enable spi_board_info to be registered after spi_master
    
    Currently spi_register_board_info() has to be called before its related
    spi_master be registered, otherwise these board info will be just ignored.
    
    This patch will remove this order limit, it adds a global spi master list
    like the existing global board info listr. Whenever a board info or a
    spi_master is registered, the spi master list or board info list
    will be scanned, and a new spi device will be created if there is a
    master-board info match.
    
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 92e52a1e6af3..b4d7710bc38d 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -204,6 +204,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
 /**
  * struct spi_master - interface to SPI master controller
  * @dev: device interface to this driver
+ * @list: link with the global spi_master list
  * @bus_num: board-specific (and often SOC-specific) identifier for a
  *	given SPI controller.
  * @num_chipselect: chipselects are used to distinguish individual
@@ -238,6 +239,8 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
 struct spi_master {
 	struct device	dev;
 
+	struct list_head list;
+
 	/* other than negative (== assign one dynamically), bus_num is fully
 	 * board-specific.  usually that simplifies to being SOC-specific.
 	 * example:  one SOC has three SPI controllers, numbered 0..2,

commit 5c79a5ae23e72fa12f1c7c528f62bf3ea35da0dc
Author: Ernst Schwab <eschwab@online.de>
Date:   Mon Aug 16 15:10:11 2010 +0200

    spi.h: missing kernel-doc notation, please fix
    
    Added comments in kernel-doc notation for previously added struct fields.
    
    Signed-off-by: Ernst Schwab <eschwab@online.de>
    Acked-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index ae0a5286f558..92e52a1e6af3 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -213,6 +213,9 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @dma_alignment: SPI controller constraint on DMA buffers alignment.
  * @mode_bits: flags understood by this controller driver
  * @flags: other constraints relevant to this driver
+ * @bus_lock_spinlock: spinlock for SPI bus locking
+ * @bus_lock_mutex: mutex for SPI bus locking
+ * @bus_lock_flag: indicates that the SPI bus is locked for exclusive use
  * @setup: updates the device mode and clocking records used by a
  *	device's SPI controller; protocol code may call this.  This
  *	must fail if an unrecognized or unsupported mode is requested.

commit cf32b71e981ca63e8f349d8585ca2a3583b556e0
Author: Ernst Schwab <eschwab@online.de>
Date:   Mon Jun 28 17:49:29 2010 -0700

    spi/mmc_spi: SPI bus locking API, using mutex
    
    SPI bus locking API to allow exclusive access to the SPI bus, especially, but
    not limited to, for the mmc_spi driver.
    
    Coded according to an outline from Grant Likely; here is his
    specification (accidentally swapped function names corrected):
    
    It requires 3 things to be added to struct spi_master.
    - 1 Mutex
    - 1 spin lock
    - 1 flag.
    
    The mutex protects spi_sync, and provides sleeping "for free"
    The spinlock protects the atomic spi_async call.
    The flag is set when the lock is obtained, and checked while holding
    the spinlock in spi_async().  If the flag is checked, then spi_async()
    must fail immediately.
    
    The current runtime API looks like this:
    spi_async(struct spi_device*, struct spi_message*);
    spi_sync(struct spi_device*, struct spi_message*);
    
    The API needs to be extended to this:
    spi_async(struct spi_device*, struct spi_message*)
    spi_sync(struct spi_device*, struct spi_message*)
    spi_bus_lock(struct spi_master*)  /* although struct spi_device* might
    be easier */
    spi_bus_unlock(struct spi_master*)
    spi_async_locked(struct spi_device*, struct spi_message*)
    spi_sync_locked(struct spi_device*, struct spi_message*)
    
    Drivers can only call the last two if they already hold the spi_master_lock().
    
    spi_bus_lock() obtains the mutex, obtains the spin lock, sets the
    flag, and releases the spin lock before returning.  It doesn't even
    need to sleep while waiting for "in-flight" spi_transactions to
    complete because its purpose is to guarantee no additional
    transactions are added.  It does not guarantee that the bus is idle.
    
    spi_bus_unlock() clears the flag and releases the mutex, which will
    wake up any waiters.
    
    The difference between spi_async() and spi_async_locked() is that the
    locked version bypasses the check of the lock flag.  Both versions
    need to obtain the spinlock.
    
    The difference between spi_sync() and spi_sync_locked() is that
    spi_sync() must hold the mutex while enqueuing a new transfer.
    spi_sync_locked() doesn't because the mutex is already held.  Note
    however that spi_sync must *not* continue to hold the mutex while
    waiting for the transfer to complete, otherwise only one transfer
    could be queued up at a time!
    
    Almost no code needs to be written.  The current spi_async() and
    spi_sync() can probably be renamed to __spi_async() and __spi_sync()
    so that spi_async(), spi_sync(), spi_async_locked() and
    spi_sync_locked() can just become wrappers around the common code.
    
    spi_sync() is protected by a mutex because it can sleep
    spi_async() needs to be protected with a flag and a spinlock because
    it can be called atomically and must not sleep
    
    Signed-off-by: Ernst Schwab <eschwab@online.de>
    [grant.likely@secretlab.ca: use spin_lock_irqsave()]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Tested-by: Matt Fleming <matt@console-pimps.org>
    Tested-by: Antonio Ospite <ospite@studenti.unina.it>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index af56071b06f9..ae0a5286f558 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -262,6 +262,13 @@ struct spi_master {
 #define SPI_MASTER_NO_RX	BIT(1)		/* can't do buffer read */
 #define SPI_MASTER_NO_TX	BIT(2)		/* can't do buffer write */
 
+	/* lock and mutex for SPI bus locking */
+	spinlock_t		bus_lock_spinlock;
+	struct mutex		bus_lock_mutex;
+
+	/* flag indicating that the SPI bus is locked for exclusive use */
+	bool			bus_lock_flag;
+
 	/* Setup mode and clock, etc (spi driver may call many times).
 	 *
 	 * IMPORTANT:  this may be called when transfers to another
@@ -542,6 +549,8 @@ static inline void spi_message_free(struct spi_message *m)
 
 extern int spi_setup(struct spi_device *spi);
 extern int spi_async(struct spi_device *spi, struct spi_message *message);
+extern int spi_async_locked(struct spi_device *spi,
+			    struct spi_message *message);
 
 /*---------------------------------------------------------------------------*/
 
@@ -551,6 +560,9 @@ extern int spi_async(struct spi_device *spi, struct spi_message *message);
  */
 
 extern int spi_sync(struct spi_device *spi, struct spi_message *message);
+extern int spi_sync_locked(struct spi_device *spi, struct spi_message *message);
+extern int spi_bus_lock(struct spi_master *master);
+extern int spi_bus_unlock(struct spi_master *master);
 
 /**
  * spi_write - SPI synchronous write

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 97b60b37f445..af56071b06f9 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -21,6 +21,7 @@
 
 #include <linux/device.h>
 #include <linux/mod_devicetable.h>
+#include <linux/slab.h>
 
 /*
  * INTERFACES between SPI master-side drivers and SPI infrastructure.

commit 568d0697f42771425ae9f1e9a3db769fef7e10b6
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Tue Sep 22 16:46:18 2009 -0700

    spi: handle TX-only/RX-only
    
    Support two new half-duplex SPI implementation restrictions, for links
    that talk to TX-only or RX-only devices.  (Existing half-duplex flavors
    support both transfer directions, just not at the same time.)
    
    Move spi_async() into the spi.c core, and stop inlining it.  Then make
    that function perform error checks and reject messages that demand more
    than the underlying controller can support.
    
    Based on a patch from Marek Szyprowski which did this only for the
    bitbanged GPIO driver.
    
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index e2051f39f6a8..97b60b37f445 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -258,6 +258,8 @@ struct spi_master {
 	/* other constraints relevant to this driver */
 	u16			flags;
 #define SPI_MASTER_HALF_DUPLEX	BIT(0)		/* can't do full duplex */
+#define SPI_MASTER_NO_RX	BIT(1)		/* can't do buffer read */
+#define SPI_MASTER_NO_TX	BIT(2)		/* can't do buffer write */
 
 	/* Setup mode and clock, etc (spi driver may call many times).
 	 *
@@ -538,42 +540,7 @@ static inline void spi_message_free(struct spi_message *m)
 }
 
 extern int spi_setup(struct spi_device *spi);
-
-/**
- * spi_async - asynchronous SPI transfer
- * @spi: device with which data will be exchanged
- * @message: describes the data transfers, including completion callback
- * Context: any (irqs may be blocked, etc)
- *
- * This call may be used in_irq and other contexts which can't sleep,
- * as well as from task contexts which can sleep.
- *
- * The completion callback is invoked in a context which can't sleep.
- * Before that invocation, the value of message->status is undefined.
- * When the callback is issued, message->status holds either zero (to
- * indicate complete success) or a negative error code.  After that
- * callback returns, the driver which issued the transfer request may
- * deallocate the associated memory; it's no longer in use by any SPI
- * core or controller driver code.
- *
- * Note that although all messages to a spi_device are handled in
- * FIFO order, messages may go to different devices in other orders.
- * Some device might be higher priority, or have various "hard" access
- * time requirements, for example.
- *
- * On detection of any fault during the transfer, processing of
- * the entire message is aborted, and the device is deselected.
- * Until returning from the associated message completion callback,
- * no other spi_message queued to that device will be processed.
- * (This rule applies equally to all the synchronous transfer calls,
- * which are wrappers around this core asynchronous primitive.)
- */
-static inline int
-spi_async(struct spi_device *spi, struct spi_message *message)
-{
-	message->spi = spi;
-	return spi->master->transfer(spi, message);
-}
+extern int spi_async(struct spi_device *spi, struct spi_message *message);
 
 /*---------------------------------------------------------------------------*/
 

commit 75368bf6c2876d8f33abfe77aa3864869a3893eb
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Tue Sep 22 16:46:04 2009 -0700

    spi: add support for device table matching
    
    With this patch spi drivers can use standard spi_driver.id_table and
    MODULE_DEVICE_TABLE() mechanisms to bind against the devices.  Just like
    we do with I2C drivers.
    
    This is useful when a single driver supports several variants of devices
    but it is not possible to detect them in run-time (like non-JEDEC chips
    probing in drivers/mtd/devices/m25p80.c), and when platform_data usage is
    overkill.
    
    This patch also makes life a lot easier on OpenFirmware platforms, since
    with OF we extensively use proper device IDs in modaliases.
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Jean Delvare <khali@linux-fr.org>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index eb25cedb995b..e2051f39f6a8 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -20,6 +20,7 @@
 #define __LINUX_SPI_H
 
 #include <linux/device.h>
+#include <linux/mod_devicetable.h>
 
 /*
  * INTERFACES between SPI master-side drivers and SPI infrastructure.
@@ -86,7 +87,7 @@ struct spi_device {
 	int			irq;
 	void			*controller_state;
 	void			*controller_data;
-	char			modalias[32];
+	char			modalias[SPI_NAME_SIZE];
 
 	/*
 	 * likely need more hooks for more protocol options affecting how
@@ -145,6 +146,7 @@ struct spi_message;
 
 /**
  * struct spi_driver - Host side "protocol" driver
+ * @id_table: List of SPI devices supported by this driver
  * @probe: Binds this driver to the spi device.  Drivers can verify
  *	that the device is actually present, and may need to configure
  *	characteristics (such as bits_per_word) which weren't needed for
@@ -170,6 +172,7 @@ struct spi_message;
  * MMC, RTC, filesystem character device nodes, and hardware monitoring.
  */
 struct spi_driver {
+	const struct spi_device_id *id_table;
 	int			(*probe)(struct spi_device *spi);
 	int			(*remove)(struct spi_device *spi);
 	void			(*shutdown)(struct spi_device *spi);
@@ -734,7 +737,7 @@ struct spi_board_info {
 	 * controller_data goes to spi_device.controller_data,
 	 * irq is copied too
 	 */
-	char		modalias[32];
+	char		modalias[SPI_NAME_SIZE];
 	const void	*platform_data;
 	void		*controller_data;
 	int		irq;
@@ -802,4 +805,7 @@ spi_unregister_device(struct spi_device *spi)
 		device_unregister(&spi->dev);
 }
 
+extern const struct spi_device_id *
+spi_get_device_id(const struct spi_device *sdev);
+
 #endif /* __LINUX_SPI_H */

commit b73b255956119111dc18fa063d1e3a0bb3f06328
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue Sep 22 16:46:00 2009 -0700

    spi.h: add missing kernel-doc for struct spi_master
    
    Add missing kernel-doc notation in spi.h for struct spi_master:
    
    Warning(include/linux/spi/spi.h:289): No description found for parameter 'mode_bits'
    Warning(include/linux/spi/spi.h:289): No description found for parameter 'flags'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index c47c4b4da97e..eb25cedb995b 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -207,6 +207,8 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *	each slave has a chipselect signal, but it's common that not
  *	every chipselect is connected to a slave.
  * @dma_alignment: SPI controller constraint on DMA buffers alignment.
+ * @mode_bits: flags understood by this controller driver
+ * @flags: other constraints relevant to this driver
  * @setup: updates the device mode and clocking records used by a
  *	device's SPI controller; protocol code may call this.  This
  *	must fail if an unrecognized or unsupported mode is requested.

commit 70d6027ff2bc8bab180273b77e7ab3e8a62cca51
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Tue Jun 30 11:41:27 2009 -0700

    spi: add spi_master flag word
    
    Add a new spi_master.flags word listing constraints relevant to that
    controller.  Define the first constraint bit: a half duplex restriction.
    Include that constraint in the OMAP1 MicroWire controller driver.
    
    Have the mmc_spi host be the first customer of this flag.  Its coding
    relies heavily on full duplex transfers, so it must fail when the
    underlying controller driver won't perform them.
    
    (The spi_write_then_read routine could use it too: use the
    temporarily-withdrawn full-duplex speedup unless this flag is set, in
    which case the existing code applies.  Similarly, any spi_master
    implementing only SPI_3WIRE should set the flag.)
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 743c933ac4e7..c47c4b4da97e 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -250,6 +250,10 @@ struct spi_master {
 	/* spi_device.mode flags understood by this controller driver */
 	u16			mode_bits;
 
+	/* other constraints relevant to this driver */
+	u16			flags;
+#define SPI_MASTER_HALF_DUPLEX	BIT(0)		/* can't do full duplex */
+
 	/* Setup mode and clock, etc (spi driver may call many times).
 	 *
 	 * IMPORTANT:  this may be called when transfers to another

commit b55f627feeb9d48fdbde3835e18afbc76712e49b
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Tue Jun 30 11:41:26 2009 -0700

    spi: new spi->mode bits
    
    Add two new spi_device.mode bits to accomodate more protocol options, and
    pass them through to usermode drivers:
    
     * SPI_NO_CS ... a second 3-wire variant, where the chipselect
       line is removed instead of a data line; transfers are still
       full duplex.
    
       This obviously has STRONG protocol implications since the
       chipselect transitions can't be used to synchronize state
       transitions with the SPI master.
    
     * SPI_READY ... defines open drain signal that's pulled low
       to pause the clock.  This defines a 5-wire variant (normal
       4-wire SPI plus READY) and two 4-wire variants (READY plus
       each of the 3-wire flavors).
    
       Such hardware flow control can be a big win.  There are ADC
       converters and flash chips that expose READY signals, but not
       many host controllers support it today.
    
    The spi_bitbang code should be changed to use SPI_NO_CS instead of its
    current nonportable hack.  That's a mode most hardware can easily support
    (unlike SPI_READY).
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: "Paulraj, Sandeep" <s-paulraj@ti.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 9c4cd27f4685..743c933ac4e7 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -80,6 +80,8 @@ struct spi_device {
 #define	SPI_LSB_FIRST	0x08			/* per-word bits-on-wire */
 #define	SPI_3WIRE	0x10			/* SI/SO signals shared */
 #define	SPI_LOOP	0x20			/* loopback mode */
+#define	SPI_NO_CS	0x40			/* 1 dev/bus, no chipselect */
+#define	SPI_READY	0x80			/* slave pulls low to pause */
 	u8			bits_per_word;
 	int			irq;
 	void			*controller_state;

commit e7db06b5d5afcef15c4c3e61c3a7441ed7ad1407
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Jun 17 16:26:04 2009 -0700

    spi: move more spi_setup() functionality into core
    
    Move some common spi_setup() error checks into the SPI framework from the
    spi_master controller drivers:
    
     - Add a new "mode_bits" field to spi_master
    
     - Use that in spi_setup to validate the spi->mode value being
       requested.  Setting this new field is now mandatory for any
       controller supporting more than vanilla SPI_MODE_0.
    
     - Update all spi_master drivers to:
    
         * Initialize that field
         * Remove current spi_setup() checks using that value.
    
    This is a net minor code shrink.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 0db5d64fc5e8..9c4cd27f4685 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -245,6 +245,9 @@ struct spi_master {
 	 */
 	u16			dma_alignment;
 
+	/* spi_device.mode flags understood by this controller driver */
+	u16			mode_bits;
+
 	/* Setup mode and clock, etc (spi driver may call many times).
 	 *
 	 * IMPORTANT:  this may be called when transfers to another

commit 7d0771970c51e736758525dd71fb82dd036b823a
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Jun 17 16:26:03 2009 -0700

    spi: move common spi_setup() functionality into core
    
    Start moving some spi_setup() functionality into the SPI core from the
    various spi_master controller drivers:
    
     - Make that function stop being an inline;
    
     - Move two common idioms from drivers into that new function:
        * Default bits_per_word to 8 if that field isn't set
        * Issue a standardized dev_dbg() message
    
    This is a net minor source code shrink, and supports enhancments found in
    some follow-up patches.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index a0faa18f7b1b..0db5d64fc5e8 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -523,30 +523,7 @@ static inline void spi_message_free(struct spi_message *m)
 	kfree(m);
 }
 
-/**
- * spi_setup - setup SPI mode and clock rate
- * @spi: the device whose settings are being modified
- * Context: can sleep, and no requests are queued to the device
- *
- * SPI protocol drivers may need to update the transfer mode if the
- * device doesn't work with its default.  They may likewise need
- * to update clock rates or word sizes from initial values.  This function
- * changes those settings, and must be called from a context that can sleep.
- * Except for SPI_CS_HIGH, which takes effect immediately, the changes take
- * effect the next time the device is selected and data is transferred to
- * or from it.  When this function returns, the spi device is deselected.
- *
- * Note that this call will fail if the protocol driver specifies an option
- * that the underlying controller or its driver does not support.  For
- * example, not all hardware supports wire transfers using nine bit words,
- * LSB-first wire encoding, or active-high chipselects.
- */
-static inline int
-spi_setup(struct spi_device *spi)
-{
-	return spi->master->setup(spi);
-}
-
+extern int spi_setup(struct spi_device *spi);
 
 /**
  * spi_async - asynchronous SPI transfer

commit 6e538aaf50ae782a890cbc02c27950448d8193e1
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Tue Apr 21 12:24:49 2009 -0700

    spi: documentation: emphasise spi_master.setup() semantics
    
    This is a doc-only patch which I hope will reduce the number of
    spi_master controller driver patches starting out with a common
    implementation bug.
    
    (As in: almost every spi_master driver I see starts out with its
    version of this bug.  Sigh.)
    
    It just re-emphasizes that the setup() method may be called for one
    device while a transfer is active on another ...  which means that most
    driver implementations shouldn't touch any registers.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 2cc43fa380cb..a0faa18f7b1b 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -245,7 +245,12 @@ struct spi_master {
 	 */
 	u16			dma_alignment;
 
-	/* setup mode and clock, etc (spi driver may call many times) */
+	/* Setup mode and clock, etc (spi driver may call many times).
+	 *
+	 * IMPORTANT:  this may be called when transfers to another
+	 * device are active.  DO NOT UPDATE SHARED REGISTERS in ways
+	 * which could break those transfers.
+	 */
 	int			(*setup)(struct spi_device *spi);
 
 	/* bidirectional bulk transfers

commit fd5e191e7610eb7ecb5e35b2045ceb6554bea15a
Author: Mike Rapoport <mike@compulab.co.il>
Date:   Mon Apr 6 19:00:56 2009 -0700

    SPI: add dma_alignment field to spi_master
    
    Some SPI controllers have restrictions on DMAable buffers alignemt.
    Currently if the buffer supplied by protocol driver is not properly
    aligned, the controller silently performs transfer in PIO mode.  Addition
    of dma_alignment field to spi_master allows protocol drivers to perform
    proper alignment.
    
    Signed-off-by: Mike Rapoport <mike@compulab.co.il>
    Cc: Bryan Wu <bryan.wu@analog.com>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 68bb1c501d0d..2cc43fa380cb 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -204,6 +204,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *	SPI slaves, and are numbered from zero to num_chipselects.
  *	each slave has a chipselect signal, but it's common that not
  *	every chipselect is connected to a slave.
+ * @dma_alignment: SPI controller constraint on DMA buffers alignment.
  * @setup: updates the device mode and clocking records used by a
  *	device's SPI controller; protocol code may call this.  This
  *	must fail if an unrecognized or unsupported mode is requested.
@@ -239,6 +240,11 @@ struct spi_master {
 	 */
 	u16			num_chipselect;
 
+	/* some SPI controllers pose alignment requirements on DMAable
+	 * buffers; let protocol drivers know about these requirements.
+	 */
+	u16			dma_alignment;
+
 	/* setup mode and clock, etc (spi driver may call many times) */
 	int			(*setup)(struct spi_device *spi);
 

commit 025dfdafe77f20b3890981a394774baab7b9c827
Author: Frederik Schwarzer <schwarzerf@gmail.com>
Date:   Thu Oct 16 19:02:37 2008 +0200

    trivial: fix then -> than typos in comments and documentation
    
    - (better, more, bigger ...) then -> (...) than
    
    Signed-off-by: Frederik Schwarzer <schwarzerf@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 82229317753d..68bb1c501d0d 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -327,9 +327,9 @@ extern struct spi_master *spi_busnum_to_master(u16 busnum);
  * @tx_dma: DMA address of tx_buf, if @spi_message.is_dma_mapped
  * @rx_dma: DMA address of rx_buf, if @spi_message.is_dma_mapped
  * @len: size of rx and tx buffers (in bytes)
- * @speed_hz: Select a speed other then the device default for this
+ * @speed_hz: Select a speed other than the device default for this
  *      transfer. If 0 the default (from @spi_device) is used.
- * @bits_per_word: select a bits_per_word other then the device default
+ * @bits_per_word: select a bits_per_word other than the device default
  *      for this transfer. If 0 the default (from @spi_device) is used.
  * @cs_change: affects chipselect after this transfer completes
  * @delay_usecs: microseconds to delay after this transfer before

commit 0a30c5cefa53cbac429dcb2de906c0637b646253
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Sun Jan 4 12:00:47 2009 -0800

    spi.h uses/needs device.h
    
    Include header files as used/needed:
    
      In file included from drivers/leds/leds-dac124s085.c:16:
      include/linux/spi/spi.h:66: error: field 'dev' has incomplete type
      include/linux/spi/spi.h: In function 'to_spi_device':
      include/linux/spi/spi.h:100: warning: type defaults to 'int' in declaration of '__mptr'
      ...
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 4be01bb44377..82229317753d 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -19,6 +19,8 @@
 #ifndef __LINUX_SPI_H
 #define __LINUX_SPI_H
 
+#include <linux/device.h>
+
 /*
  * INTERFACES between SPI master-side drivers and SPI infrastructure.
  * (There's no SPI slave support for Linux yet...)

commit dc87c98e8f635a718f1abb2c3e15fc77c0001651
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu May 15 16:50:22 2008 -0600

    spi: split up spi_new_device() to allow two stage registration.
    
    spi_new_device() allocates and registers an spi device all in one swoop.
    If the driver needs to add extra data to the spi_device before it is
    registered, then this causes problems.  This is needed for OF device
    tree support so that the SPI device tree helper can add a pointer to
    the device node after the device is allocated, but before the device
    is registered.  OF aware SPI devices can then retrieve data out of the
    device node to populate a platform data structure.
    
    This patch splits the allocation and registration portions of code out
    of spi_new_device() and creates two new functions; spi_alloc_device()
    and spi_register_device().  spi_new_device() is modified to use the new
    functions for allocation and registration.  None of the existing users
    of spi_new_device() should be affected by this change.
    
    Drivers using the new API can forego the use of spi_board_info
    structure to describe the device layout and populate data into the
    spi_device structure directly.
    
    This change is in preparation for adding an OF device tree parser to
    generate spi_devices based on data in the device tree.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index a9cc29d46653..4be01bb44377 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -778,7 +778,19 @@ spi_register_board_info(struct spi_board_info const *info, unsigned n)
  * use spi_new_device() to describe each device.  You can also call
  * spi_unregister_device() to start making that device vanish, but
  * normally that would be handled by spi_unregister_master().
+ *
+ * You can also use spi_alloc_device() and spi_add_device() to use a two
+ * stage registration sequence for each spi_device.  This gives the caller
+ * some more control over the spi_device structure before it is registered,
+ * but requires that caller to initialize fields that would otherwise
+ * be defined using the board info.
  */
+extern struct spi_device *
+spi_alloc_device(struct spi_master *master);
+
+extern int
+spi_add_device(struct spi_device *spi);
+
 extern struct spi_device *
 spi_new_device(struct spi_master *, struct spi_board_info *);
 

commit 102eb97564c73ea73645b38599c5cbe6f54b030c
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed Jul 23 21:29:55 2008 -0700

    spi: make spi_board_info.modalias a char array
    
    Currently, 'modalias' in the spi_device structure is a 'const char *'.
    The spi_new_device() function fills in the modalias value from a passed in
    spi_board_info data block.  Since it is a pointer copy, the new spi_device
    remains dependent on the spi_board_info structure after the new spi_device
    is registered (no other fields in spi_device directly depend on the
    spi_board_info structure; all of the other data is copied).
    
    This causes a problem when dynamically propulating the list of attached
    SPI devices.  For example, in arch/powerpc, the list of SPI devices can be
    populated from data in the device tree.  With the current code, the device
    tree adapter must kmalloc() a new spi_board_info structure for each new
    SPI device it finds in the device tree, and there is no simple mechanism
    in place for keeping track of these allocations.
    
    This patch changes modalias from a 'const char *' to a fixed char array.
    By copying the modalias string instead of referencing it, the dependency
    on the spi_board_info structure is eliminated and an outside caller does
    not need to maintain a separate spi_board_info allocation for each device.
    
    If searched through the code to the best of my ability for any references
    to modalias which may be affected by this change and haven't found
    anything.  It has been tested with the lite5200b platform in arch/powerpc.
    
    [dbrownell@users.sourceforge.net: cope with linux-next changes: KOBJ_NAME_LEN obliterated, etc]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index b9a76c972084..a9cc29d46653 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -82,7 +82,7 @@ struct spi_device {
 	int			irq;
 	void			*controller_state;
 	void			*controller_data;
-	const char		*modalias;
+	char			modalias[32];
 
 	/*
 	 * likely need more hooks for more protocol options affecting how

commit aab0de245150c09e61c30962feb16aacde508dc3
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Fri May 2 06:02:41 2008 +0200

    driver core: remove KOBJ_NAME_LEN define
    
    Kobjects do not have a limit in name size since a while, so stop
    pretending that they do.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 387e428f1cdf..b9a76c972084 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -733,7 +733,7 @@ struct spi_board_info {
 	 * controller_data goes to spi_device.controller_data,
 	 * irq is copied too
 	 */
-	char		modalias[KOBJ_NAME_LEN];
+	char		modalias[32];
 	const void	*platform_data;
 	void		*controller_data;
 	int		irq;

commit 49dce689ad4ef0fd1f970ef762168e4bd46f69a3
Author: Tony Jones <tonyj@suse.de>
Date:   Tue Oct 16 01:27:48 2007 -0700

    spi doesn't need class_device
    
    Make the SPI framework and drivers stop using class_device.  Update docs
    accordingly ...  highlighting just which sysfs paths should be
    "safe"/stable.
    
    Signed-off-by: Tony Jones <tonyj@suse.de>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 002a3cddbdd5..387e428f1cdf 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -195,7 +195,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
 
 /**
  * struct spi_master - interface to SPI master controller
- * @cdev: class interface to this driver
+ * @dev: device interface to this driver
  * @bus_num: board-specific (and often SOC-specific) identifier for a
  *	given SPI controller.
  * @num_chipselect: chipselects are used to distinguish individual
@@ -222,7 +222,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * message's completion function when the transaction completes.
  */
 struct spi_master {
-	struct class_device	cdev;
+	struct device	dev;
 
 	/* other than negative (== assign one dynamically), bus_num is fully
 	 * board-specific.  usually that simplifies to being SOC-specific.
@@ -268,17 +268,17 @@ struct spi_master {
 
 static inline void *spi_master_get_devdata(struct spi_master *master)
 {
-	return class_get_devdata(&master->cdev);
+	return dev_get_drvdata(&master->dev);
 }
 
 static inline void spi_master_set_devdata(struct spi_master *master, void *data)
 {
-	class_set_devdata(&master->cdev, data);
+	dev_set_drvdata(&master->dev, data);
 }
 
 static inline struct spi_master *spi_master_get(struct spi_master *master)
 {
-	if (!master || !class_device_get(&master->cdev))
+	if (!master || !get_device(&master->dev))
 		return NULL;
 	return master;
 }
@@ -286,7 +286,7 @@ static inline struct spi_master *spi_master_get(struct spi_master *master)
 static inline void spi_master_put(struct spi_master *master)
 {
 	if (master)
-		class_device_put(&master->cdev);
+		put_device(&master->dev);
 }
 
 

commit 2604288f45605d1b2844f001dc3141149667b3d1
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Jul 31 00:39:44 2007 -0700

    spi kerneldoc update
    
    This adds kerneldoc to the SPI framework.  The "spi_driver" and
    "spi_board_info" structs were previously not described.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index e180615ed25a..002a3cddbdd5 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -139,6 +139,32 @@ struct spi_message;
 
 
 
+/**
+ * struct spi_driver - Host side "protocol" driver
+ * @probe: Binds this driver to the spi device.  Drivers can verify
+ *	that the device is actually present, and may need to configure
+ *	characteristics (such as bits_per_word) which weren't needed for
+ *	the initial configuration done during system setup.
+ * @remove: Unbinds this driver from the spi device
+ * @shutdown: Standard shutdown callback used during system state
+ *	transitions such as powerdown/halt and kexec
+ * @suspend: Standard suspend callback used during system state transitions
+ * @resume: Standard resume callback used during system state transitions
+ * @driver: SPI device drivers should initialize the name and owner
+ *	field of this structure.
+ *
+ * This represents the kind of device driver that uses SPI messages to
+ * interact with the hardware at the other end of a SPI link.  It's called
+ * a "protocol" driver because it works through messages rather than talking
+ * directly to SPI hardware (which is what the underlying SPI controller
+ * driver does to pass those messages).  These protocols are defined in the
+ * specification for the device(s) supported by the driver.
+ *
+ * As a rule, those device protocols represent the lowest level interface
+ * supported by a driver, and it will support upper level interfaces too.
+ * Examples of such upper levels include frameworks like MTD, networking,
+ * MMC, RTC, filesystem character device nodes, and hardware monitoring.
+ */
 struct spi_driver {
 	int			(*probe)(struct spi_device *spi);
 	int			(*remove)(struct spi_device *spi);
@@ -668,7 +694,37 @@ static inline ssize_t spi_w8r16(struct spi_device *spi, u8 cmd)
  * parport adapters, or microcontrollers acting as USB-to-SPI bridges.
  */
 
-/* board-specific information about each SPI device */
+/**
+ * struct spi_board_info - board-specific template for a SPI device
+ * @modalias: Initializes spi_device.modalias; identifies the driver.
+ * @platform_data: Initializes spi_device.platform_data; the particular
+ *	data stored there is driver-specific.
+ * @controller_data: Initializes spi_device.controller_data; some
+ *	controllers need hints about hardware setup, e.g. for DMA.
+ * @irq: Initializes spi_device.irq; depends on how the board is wired.
+ * @max_speed_hz: Initializes spi_device.max_speed_hz; based on limits
+ *	from the chip datasheet and board-specific signal quality issues.
+ * @bus_num: Identifies which spi_master parents the spi_device; unused
+ *	by spi_new_device(), and otherwise depends on board wiring.
+ * @chip_select: Initializes spi_device.chip_select; depends on how
+ *	the board is wired.
+ * @mode: Initializes spi_device.mode; based on the chip datasheet, board
+ *	wiring (some devices support both 3WIRE and standard modes), and
+ *	possibly presence of an inverter in the chipselect path.
+ *
+ * When adding new SPI devices to the device tree, these structures serve
+ * as a partial device template.  They hold information which can't always
+ * be determined by drivers.  Information that probe() can establish (such
+ * as the default transfer wordsize) is not included here.
+ *
+ * These structures are used in two places.  Their primary role is to
+ * be stored in tables of board-specific device descriptors, which are
+ * declared early in board initialization and then used (much later) to
+ * populate a controller's device tree after the that controller's driver
+ * initializes.  A secondary (and atypical) role is as a parameter to
+ * spi_new_device() call, which happens after those controller drivers
+ * are active in some dynamic board configuration models.
+ */
 struct spi_board_info {
 	/* the device name and module name are coupled, like platform_bus;
 	 * "modalias" is normally the driver name.

commit 4ef7af50373778ee248a2493c9cf62a2299806a8
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Tue Jul 31 00:38:43 2007 -0700

    SPI loopback mode definition
    
    Loopback mode is supported by various controllers.  This mode can be
    useful for testing, especially in conjunction with spidev driver.
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 302b81d1d117..e180615ed25a 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -77,6 +77,7 @@ struct spi_device {
 #define	SPI_CS_HIGH	0x04			/* chipselect active high? */
 #define	SPI_LSB_FIRST	0x08			/* per-word bits-on-wire */
 #define	SPI_3WIRE	0x10			/* SI/SO signals shared */
+#define	SPI_LOOP	0x20			/* loopback mode */
 	u8			bits_per_word;
 	int			irq;
 	void			*controller_state;

commit c06e677aed0c86480b01faa894967daa8aa3568a
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Jul 17 04:04:03 2007 -0700

    SPI: add 3wire mode flag
    
    Add a new spi->mode bit: SPI_3WIRE, for chips where the SI and SO signals
    are shared (and which are thus only half duplex).  Update the LM70 driver
    to require support for that hardware mode from the controller.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 1be5ea059477..302b81d1d117 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -76,6 +76,7 @@ struct spi_device {
 #define	SPI_MODE_3	(SPI_CPOL|SPI_CPHA)
 #define	SPI_CS_HIGH	0x04			/* chipselect active high? */
 #define	SPI_LSB_FIRST	0x08			/* per-word bits-on-wire */
+#define	SPI_3WIRE	0x10			/* SI/SO signals shared */
 	u8			bits_per_word;
 	int			irq;
 	void			*controller_state;

commit f5a9c77df45b113d21b64cbc2bf6c72a0da48998
Author: David Brownell <david-b@pacbell.net>
Date:   Sat Jun 16 10:16:08 2007 -0700

    spi doc updates
    
    Update two points in the SPI interface documentation:
    
    - Update description of the "chip stays selected after message ends"
      mode.  In some cases it's required for correctness; it isn't just a
      performance tweak.  (Yes: to use this mode on mult-device busses, another
      programming interface will be needed.  One draft has been circulated
      already.)
    
    - Clarify spi_setup(), highlighting that callers must ensure that no
      requests are queued (can't change configuration except between I/Os), and
      that the device must be deselected when this returns (which is a key part
      of why it's called during device init).
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index b6bedc3ee95c..1be5ea059477 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -341,9 +341,14 @@ extern struct spi_master *spi_busnum_to_master(u16 busnum);
  * chip transactions together.
  *
  * (ii) When the transfer is the last one in the message, the chip may
- * stay selected until the next transfer.  This is purely a performance
- * hint; the controller driver may need to select a different device
- * for the next message.
+ * stay selected until the next transfer.  On multi-device SPI busses
+ * with nothing blocking messages going to other devices, this is just
+ * a performance hint; starting a message to another device deselects
+ * this one.  But in other cases, this can be used to ensure correctness.
+ * Some devices need protocol transactions to be built from a series of
+ * spi_message submissions, where the content of one message is determined
+ * by the results of previous messages and where the whole transaction
+ * ends when the chipselect goes intactive.
  *
  * The code that submits an spi_message (and its spi_transfers)
  * to the lower layers is responsible for managing its memory.
@@ -480,14 +485,15 @@ static inline void spi_message_free(struct spi_message *m)
 /**
  * spi_setup - setup SPI mode and clock rate
  * @spi: the device whose settings are being modified
- * Context: can sleep
+ * Context: can sleep, and no requests are queued to the device
  *
  * SPI protocol drivers may need to update the transfer mode if the
- * device doesn't work with the mode 0 default.  They may likewise need
+ * device doesn't work with its default.  They may likewise need
  * to update clock rates or word sizes from initial values.  This function
  * changes those settings, and must be called from a context that can sleep.
- * The changes take effect the next time the device is selected and data
- * is transferred to or from it.
+ * Except for SPI_CS_HIGH, which takes effect immediately, the changes take
+ * effect the next time the device is selected and data is transferred to
+ * or from it.  When this function returns, the spi device is deselected.
  *
  * Note that this call will fail if the protocol driver specifies an option
  * that the underlying controller or its driver does not support.  For

commit 33e34dc6ee2cb2cf2d50e65c5b825d9ebb8b9e66
Author: David Brownell <david-b@pacbell.net>
Date:   Tue May 8 00:32:21 2007 -0700

    SPI kerneldoc
    
    Various documentation updates for the SPI infrastructure, to clarify things
    that may not have been clear, to cope with lack of editing, and fix
    omissions.
    
    Also, plug SPI into the kernel-api DocBook template, and fix all the
    resulting glitches in document generation.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: "Randy.Dunlap" <rdunlap@xenotime.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 4f0f8c2e58a5..b6bedc3ee95c 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -32,11 +32,12 @@ extern struct bus_type spi_bus_type;
  * @max_speed_hz: Maximum clock rate to be used with this chip
  *	(on this board); may be changed by the device's driver.
  *	The spi_transfer.speed_hz can override this for each transfer.
- * @chip-select: Chipselect, distinguishing chips handled by "master".
+ * @chip_select: Chipselect, distinguishing chips handled by @master.
  * @mode: The spi mode defines how data is clocked out and in.
  *	This may be changed by the device's driver.
- *	The "active low" default for chipselect mode can be overridden,
- *	as can the "MSB first" default for each word in a transfer.
+ *	The "active low" default for chipselect mode can be overridden
+ *	(by specifying SPI_CS_HIGH) as can the "MSB first" default for
+ *	each word in a transfer (by specifying SPI_LSB_FIRST).
  * @bits_per_word: Data transfers involve one or more words; word sizes
  *	like eight or 12 bits are common.  In-memory wordsizes are
  *	powers of two bytes (e.g. 20 bit samples use 32 bits).
@@ -48,14 +49,18 @@ extern struct bus_type spi_bus_type;
  * @controller_state: Controller's runtime state
  * @controller_data: Board-specific definitions for controller, such as
  *	FIFO initialization parameters; from board_info.controller_data
+ * @modalias: Name of the driver to use with this device, or an alias
+ *	for that name.  This appears in the sysfs "modalias" attribute
+ *	for driver coldplugging, and in uevents used for hotplugging
  *
- * An spi_device is used to interchange data between an SPI slave
+ * A @spi_device is used to interchange data between an SPI slave
  * (usually a discrete chip) and CPU memory.
  *
- * In "dev", the platform_data is used to hold information about this
+ * In @dev, the platform_data is used to hold information about this
  * device that's meaningful to the device's protocol driver, but not
  * to its controller.  One example might be an identifier for a chip
- * variant with slightly different functionality.
+ * variant with slightly different functionality; another might be
+ * information about how this particular board wires the chip's pins.
  */
 struct spi_device {
 	struct device		dev;
@@ -77,13 +82,15 @@ struct spi_device {
 	void			*controller_data;
 	const char		*modalias;
 
-	// likely need more hooks for more protocol options affecting how
-	// the controller talks to each chip, like:
-	//  - memory packing (12 bit samples into low bits, others zeroed)
-	//  - priority
-	//  - drop chipselect after each word
-	//  - chipselect delays
-	//  - ...
+	/*
+	 * likely need more hooks for more protocol options affecting how
+	 * the controller talks to each chip, like:
+	 *  - memory packing (12 bit samples into low bits, others zeroed)
+	 *  - priority
+	 *  - drop chipselect after each word
+	 *  - chipselect delays
+	 *  - ...
+	 */
 };
 
 static inline struct spi_device *to_spi_device(struct device *dev)
@@ -146,6 +153,11 @@ static inline struct spi_driver *to_spi_driver(struct device_driver *drv)
 
 extern int spi_register_driver(struct spi_driver *sdrv);
 
+/**
+ * spi_unregister_driver - reverse effect of spi_register_driver
+ * @sdrv: the driver to unregister
+ * Context: can sleep
+ */
 static inline void spi_unregister_driver(struct spi_driver *sdrv)
 {
 	if (sdrv)
@@ -165,18 +177,20 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * @setup: updates the device mode and clocking records used by a
  *	device's SPI controller; protocol code may call this.  This
  *	must fail if an unrecognized or unsupported mode is requested.
+ *	It's always safe to call this unless transfers are pending on
+ *	the device whose settings are being modified.
  * @transfer: adds a message to the controller's transfer queue.
  * @cleanup: frees controller-specific state
  *
- * Each SPI master controller can communicate with one or more spi_device
+ * Each SPI master controller can communicate with one or more @spi_device
  * children.  These make a small bus, sharing MOSI, MISO and SCK signals
  * but not chip select signals.  Each device may be configured to use a
  * different clock rate, since those shared signals are ignored unless
  * the chip is selected.
  *
  * The driver for an SPI controller manages access to those devices through
- * a queue of spi_message transactions, copyin data between CPU memory and
- * an SPI slave device).  For each such message it queues, it calls the
+ * a queue of spi_message transactions, copying data between CPU memory and
+ * an SPI slave device.  For each such message it queues, it calls the
  * message's completion function when the transaction completes.
  */
 struct spi_master {
@@ -280,27 +294,27 @@ extern struct spi_master *spi_busnum_to_master(u16 busnum);
  * struct spi_transfer - a read/write buffer pair
  * @tx_buf: data to be written (dma-safe memory), or NULL
  * @rx_buf: data to be read (dma-safe memory), or NULL
- * @tx_dma: DMA address of tx_buf, if spi_message.is_dma_mapped
- * @rx_dma: DMA address of rx_buf, if spi_message.is_dma_mapped
+ * @tx_dma: DMA address of tx_buf, if @spi_message.is_dma_mapped
+ * @rx_dma: DMA address of rx_buf, if @spi_message.is_dma_mapped
  * @len: size of rx and tx buffers (in bytes)
  * @speed_hz: Select a speed other then the device default for this
- *      transfer. If 0 the default (from spi_device) is used.
+ *      transfer. If 0 the default (from @spi_device) is used.
  * @bits_per_word: select a bits_per_word other then the device default
- *      for this transfer. If 0 the default (from spi_device) is used.
+ *      for this transfer. If 0 the default (from @spi_device) is used.
  * @cs_change: affects chipselect after this transfer completes
  * @delay_usecs: microseconds to delay after this transfer before
  *	(optionally) changing the chipselect status, then starting
- *	the next transfer or completing this spi_message.
- * @transfer_list: transfers are sequenced through spi_message.transfers
+ *	the next transfer or completing this @spi_message.
+ * @transfer_list: transfers are sequenced through @spi_message.transfers
  *
  * SPI transfers always write the same number of bytes as they read.
- * Protocol drivers should always provide rx_buf and/or tx_buf.
+ * Protocol drivers should always provide @rx_buf and/or @tx_buf.
  * In some cases, they may also want to provide DMA addresses for
  * the data being transferred; that may reduce overhead, when the
  * underlying driver uses dma.
  *
  * If the transmit buffer is null, zeroes will be shifted out
- * while filling rx_buf.  If the receive buffer is null, the data
+ * while filling @rx_buf.  If the receive buffer is null, the data
  * shifted in will be discarded.  Only "len" bytes shift out (or in).
  * It's an error to try to shift out a partial word.  (For example, by
  * shifting out three bytes with word size of sixteen or twenty bits;
@@ -309,7 +323,7 @@ extern struct spi_master *spi_busnum_to_master(u16 busnum);
  * In-memory data values are always in native CPU byte order, translated
  * from the wire byte order (big-endian except with SPI_LSB_FIRST).  So
  * for example when bits_per_word is sixteen, buffers are 2N bytes long
- * and hold N sixteen bit words in CPU byte order.
+ * (@len = 2N) and hold N sixteen bit words in CPU byte order.
  *
  * When the word size of the SPI transfer is not a power-of-two multiple
  * of eight bits, those in-memory words include extra bits.  In-memory
@@ -318,7 +332,7 @@ extern struct spi_master *spi_busnum_to_master(u16 busnum);
  *
  * All SPI transfers start with the relevant chipselect active.  Normally
  * it stays selected until after the last transfer in a message.  Drivers
- * can affect the chipselect signal using cs_change:
+ * can affect the chipselect signal using cs_change.
  *
  * (i) If the transfer isn't the last one in the message, this flag is
  * used to make the chipselect briefly go inactive in the middle of the
@@ -372,7 +386,7 @@ struct spi_transfer {
  * @queue: for use by whichever driver currently owns the message
  * @state: for use by whichever driver currently owns the message
  *
- * An spi_message is used to execute an atomic sequence of data transfers,
+ * A @spi_message is used to execute an atomic sequence of data transfers,
  * each represented by a struct spi_transfer.  The sequence is "atomic"
  * in the sense that no other spi_message may use that SPI bus until that
  * sequence completes.  On some systems, many such sequences can execute as
@@ -464,8 +478,9 @@ static inline void spi_message_free(struct spi_message *m)
 }
 
 /**
- * spi_setup -- setup SPI mode and clock rate
+ * spi_setup - setup SPI mode and clock rate
  * @spi: the device whose settings are being modified
+ * Context: can sleep
  *
  * SPI protocol drivers may need to update the transfer mode if the
  * device doesn't work with the mode 0 default.  They may likewise need
@@ -474,7 +489,7 @@ static inline void spi_message_free(struct spi_message *m)
  * The changes take effect the next time the device is selected and data
  * is transferred to or from it.
  *
- * Note that this call wil fail if the protocol driver specifies an option
+ * Note that this call will fail if the protocol driver specifies an option
  * that the underlying controller or its driver does not support.  For
  * example, not all hardware supports wire transfers using nine bit words,
  * LSB-first wire encoding, or active-high chipselects.
@@ -487,9 +502,10 @@ spi_setup(struct spi_device *spi)
 
 
 /**
- * spi_async -- asynchronous SPI transfer
+ * spi_async - asynchronous SPI transfer
  * @spi: device with which data will be exchanged
  * @message: describes the data transfers, including completion callback
+ * Context: any (irqs may be blocked, etc)
  *
  * This call may be used in_irq and other contexts which can't sleep,
  * as well as from task contexts which can sleep.
@@ -535,6 +551,7 @@ extern int spi_sync(struct spi_device *spi, struct spi_message *message);
  * @spi: device to which data will be written
  * @buf: data buffer
  * @len: data buffer size
+ * Context: can sleep
  *
  * This writes the buffer and returns zero or a negative error code.
  * Callable only from contexts that can sleep.
@@ -558,8 +575,9 @@ spi_write(struct spi_device *spi, const u8 *buf, size_t len)
  * @spi: device from which data will be read
  * @buf: data buffer
  * @len: data buffer size
+ * Context: can sleep
  *
- * This writes the buffer and returns zero or a negative error code.
+ * This reads the buffer and returns zero or a negative error code.
  * Callable only from contexts that can sleep.
  */
 static inline int
@@ -585,6 +603,7 @@ extern int spi_write_then_read(struct spi_device *spi,
  * spi_w8r8 - SPI synchronous 8 bit write followed by 8 bit read
  * @spi: device with which data will be exchanged
  * @cmd: command to be written before data is read back
+ * Context: can sleep
  *
  * This returns the (unsigned) eight bit number returned by the
  * device, or else a negative error code.  Callable only from
@@ -605,6 +624,7 @@ static inline ssize_t spi_w8r8(struct spi_device *spi, u8 cmd)
  * spi_w8r16 - SPI synchronous 8 bit write followed by 16 bit read
  * @spi: device with which data will be exchanged
  * @cmd: command to be written before data is read back
+ * Context: can sleep
  *
  * This returns the (unsigned) sixteen bit number returned by the
  * device, or else a negative error code.  Callable only from

commit 802245611adea5e5877d8c5d9a20f94d8131bfdd
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Feb 12 00:52:46 2007 -0800

    [PATCH] SPI doc clarifications
    
    This clarifies some aspects of the SPI programming interface, based on
    feedback from Hans-Peter Nilsson.  The in-memory representation of words is
    right-aligned, so for example a twelve bit word is stored using sixteen bits
    with four undefined bits in the MSB.  And controller drivers must reject
    protocol tweaking modes they do not support.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 9d8d63109a8f..4f0f8c2e58a5 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -163,7 +163,8 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  *	each slave has a chipselect signal, but it's common that not
  *	every chipselect is connected to a slave.
  * @setup: updates the device mode and clocking records used by a
- *	device's SPI controller; protocol code may call this.
+ *	device's SPI controller; protocol code may call this.  This
+ *	must fail if an unrecognized or unsupported mode is requested.
  * @transfer: adds a message to the controller's transfer queue.
  * @cleanup: frees controller-specific state
  *
@@ -305,6 +306,16 @@ extern struct spi_master *spi_busnum_to_master(u16 busnum);
  * shifting out three bytes with word size of sixteen or twenty bits;
  * the former uses two bytes per word, the latter uses four bytes.)
  *
+ * In-memory data values are always in native CPU byte order, translated
+ * from the wire byte order (big-endian except with SPI_LSB_FIRST).  So
+ * for example when bits_per_word is sixteen, buffers are 2N bytes long
+ * and hold N sixteen bit words in CPU byte order.
+ *
+ * When the word size of the SPI transfer is not a power-of-two multiple
+ * of eight bits, those in-memory words include extra bits.  In-memory
+ * words are always seen by protocol drivers as right-justified, so the
+ * undefined (rx) or unused (tx) bits are always the most significant bits.
+ *
  * All SPI transfers start with the relevant chipselect active.  Normally
  * it stays selected until after the last transfer in a message.  Drivers
  * can affect the chipselect signal using cs_change:
@@ -462,6 +473,11 @@ static inline void spi_message_free(struct spi_message *m)
  * changes those settings, and must be called from a context that can sleep.
  * The changes take effect the next time the device is selected and data
  * is transferred to or from it.
+ *
+ * Note that this call wil fail if the protocol driver specifies an option
+ * that the underlying controller or its driver does not support.  For
+ * example, not all hardware supports wire transfers using nine bit words,
+ * LSB-first wire encoding, or active-high chipselects.
  */
 static inline int
 spi_setup(struct spi_device *spi)

commit 0ffa0285052607513a29f529ddb5061c907fd8a6
Author: Hans-Peter Nilsson <hans-peter.nilsson@axis.com>
Date:   Mon Feb 12 00:52:45 2007 -0800

    [PATCH] SPI cleanup() method param becomes non-const
    
    I'd like to assign NULL to kfree()d members of a structure.  I can't do
    that without ugly casting (see the PXA patch) when the structure pointed to
    is const-qualified.  I don't really see a reason why the cleanup method
    isn't allowed to alter the object it should clean up.  :-)
    
    No, I didn't test the PXA patch, but I verified that the NULL-assignment
    doesn't stop me from doing rmmod/insmodding my own spi_bitbang-based
    driver.
    
    Signed-off-by: Hans-Peter Nilsson <hp@axis.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 851b25d6e82b..9d8d63109a8f 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -220,7 +220,7 @@ struct spi_master {
 						struct spi_message *mesg);
 
 	/* called on release() to free memory provided by spi_master */
-	void			(*cleanup)(const struct spi_device *spi);
+	void			(*cleanup)(struct spi_device *spi);
 };
 
 static inline void *spi_master_get_devdata(struct spi_master *master)

commit ddc1e9753106cedcca7944d2b068baa2e14640b1
Author: Ben Dooks <ben@fluff.org>
Date:   Mon Feb 12 00:52:43 2007 -0800

    [PATCH] spi: remove return in spi_unregister_driver()
    
    Make the spi_unregister_driver() code fit in with the rest of the header
    file, and only do the action if the driver passed is non-NULL.
    
    This also makes the code a line smaller.
    
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index e25fcae89d3b..851b25d6e82b 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -148,13 +148,11 @@ extern int spi_register_driver(struct spi_driver *sdrv);
 
 static inline void spi_unregister_driver(struct spi_driver *sdrv)
 {
-	if (!sdrv)
-		return;
-	driver_unregister(&sdrv->driver);
+	if (sdrv)
+		driver_unregister(&sdrv->driver);
 }
 
 
-
 /**
  * struct spi_master - interface to SPI master controller
  * @cdev: class interface to this driver

commit 9b40ff4d729f4a7a9f832c67aa5de0dfa8ad45c0
Author: Ben Dooks <ben@fluff.org>
Date:   Mon Feb 12 00:52:41 2007 -0800

    [PATCH] spi: add spi_set_drvdata() and spi_get_drvdata()
    
    Add wrappers for getting and setting the driver data using spi_device
    instead of using dev_{get|set}_drvdata with &spi->dev, to mirror the
    platform_{get|set}_drvdata.
    
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 176f6e36dbfa..e25fcae89d3b 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -114,6 +114,17 @@ static inline void spi_set_ctldata(struct spi_device *spi, void *state)
 	spi->controller_state = state;
 }
 
+/* device driver data */
+
+static inline void spi_set_drvdata(struct spi_device *spi, void *data)
+{
+	dev_set_drvdata(&spi->dev, data);
+}
+
+static inline void *spi_get_drvdata(struct spi_device *spi)
+{
+	return dev_get_drvdata(&spi->dev);
+}
 
 struct spi_message;
 

commit 07b2463046247ce580ff9b37e91394f2f6424768
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Feb 7 21:34:08 2007 -0800

    Revert "Driver core: convert SPI code to use struct device"
    
    This reverts commit 2943ecf2ed32632473c06f1975db47a7aa98c10f.
    
    This should go through the SPI maintainer, it was my fault that it did
    not.  Especially as it conflicts with other patches he has pending.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 8c2edd82a073..176f6e36dbfa 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -170,7 +170,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * message's completion function when the transaction completes.
  */
 struct spi_master {
-	struct device		dev;
+	struct class_device	cdev;
 
 	/* other than negative (== assign one dynamically), bus_num is fully
 	 * board-specific.  usually that simplifies to being SOC-specific.
@@ -216,17 +216,17 @@ struct spi_master {
 
 static inline void *spi_master_get_devdata(struct spi_master *master)
 {
-	return dev_get_drvdata(&master->dev);
+	return class_get_devdata(&master->cdev);
 }
 
 static inline void spi_master_set_devdata(struct spi_master *master, void *data)
 {
-	dev_set_drvdata(&master->dev, data);
+	class_set_devdata(&master->cdev, data);
 }
 
 static inline struct spi_master *spi_master_get(struct spi_master *master)
 {
-	if (!master || !get_device(&master->dev))
+	if (!master || !class_device_get(&master->cdev))
 		return NULL;
 	return master;
 }
@@ -234,7 +234,7 @@ static inline struct spi_master *spi_master_get(struct spi_master *master)
 static inline void spi_master_put(struct spi_master *master)
 {
 	if (master)
-		put_device(&master->dev);
+		class_device_put(&master->cdev);
 }
 
 

commit 2943ecf2ed32632473c06f1975db47a7aa98c10f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jan 22 13:45:38 2007 -0800

    Driver core: convert SPI code to use struct device
    
    Converts from using struct "class_device" to "struct device" making
    everything show up properly in /sys/devices/ with symlinks from the
    /sys/class directory.
    
    Cc: <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 176f6e36dbfa..8c2edd82a073 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -170,7 +170,7 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * message's completion function when the transaction completes.
  */
 struct spi_master {
-	struct class_device	cdev;
+	struct device		dev;
 
 	/* other than negative (== assign one dynamically), bus_num is fully
 	 * board-specific.  usually that simplifies to being SOC-specific.
@@ -216,17 +216,17 @@ struct spi_master {
 
 static inline void *spi_master_get_devdata(struct spi_master *master)
 {
-	return class_get_devdata(&master->cdev);
+	return dev_get_drvdata(&master->dev);
 }
 
 static inline void spi_master_set_devdata(struct spi_master *master, void *data)
 {
-	class_set_devdata(&master->cdev, data);
+	dev_set_drvdata(&master->dev, data);
 }
 
 static inline struct spi_master *spi_master_get(struct spi_master *master)
 {
-	if (!master || !class_device_get(&master->cdev))
+	if (!master || !get_device(&master->dev))
 		return NULL;
 	return master;
 }
@@ -234,7 +234,7 @@ static inline struct spi_master *spi_master_get(struct spi_master *master)
 static inline void spi_master_put(struct spi_master *master)
 {
 	if (master)
-		class_device_put(&master->cdev);
+		put_device(&master->dev);
 }
 
 

commit 4b1badf5d9ddfc46ad075ca5bfc465972c85cc7c
Author: David Brownell <david-b@pacbell.net>
Date:   Fri Dec 29 16:48:39 2006 -0800

    [PATCH] SPI: define null tx_buf to mean "shift out zeroes"
    
    Some issues were recently turned up with the current specification of what
    it means for spi_transfer.tx_buf to be null, as part of transfers which are
    (from the SPI protocol driver perspective) pure reads.
    
    Specifically, that it seems better to change the TX behaviour there from
    "undefined" to "will shift zeroes".  This lets protocol drivers (like the
    ads7846 driver) depend on that behavior.  It's what most controller drivers
    in the tree are already doing (with one exception and one case of driver
    wanting-to-oops), it's what Microwire hardware will necessarily be doing,
    and it removes an issue whereby certain security audits would need to
    define such a value anyway as part of removing covert channels.
    
    This patch changes the specification to require shifting zeroes, and
    updates all currently merged SPI controller drivers to do so.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index c8bb68099eb9..176f6e36dbfa 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -289,7 +289,7 @@ extern struct spi_master *spi_busnum_to_master(u16 busnum);
  * the data being transferred; that may reduce overhead, when the
  * underlying driver uses dma.
  *
- * If the transmit buffer is null, undefined data will be shifted out
+ * If the transmit buffer is null, zeroes will be shifted out
  * while filling rx_buf.  If the receive buffer is null, the data
  * shifted in will be discarded.  Only "len" bytes shift out (or in).
  * It's an error to try to shift out a partial word.  (For example, by

commit 980a01c9bfb090cb8a991e39e56ac379c30c61b8
Author: David Brownell <david-b@pacbell.net>
Date:   Wed Jun 28 07:47:15 2006 -0700

    [PATCH] SPI: infrastructure to initialize spi_device.mode early
    
    This patch adds earlier initialization of spi_device.mode, as needed
    on boards using nondefault chipselect polarity.  An example would be
    ones using the RS5C348 RTC without an external signal inverter between
    the RTC chipselect and the SPI controller.
    
    Without this mechanism, the first setup() call for that chip would
    wrongly enable chips, corrupting transfers to/from other chips sharing
    that SPI bus.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index e928c0dcc297..c8bb68099eb9 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -642,10 +642,14 @@ struct spi_board_info {
 	u16		bus_num;
 	u16		chip_select;
 
+	/* mode becomes spi_device.mode, and is essential for chips
+	 * where the default of SPI_CS_HIGH = 0 is wrong.
+	 */
+	u8		mode;
+
 	/* ... may need additional spi_device chip config data here.
 	 * avoid stuff protocol drivers can set; but include stuff
 	 * needed to behave without being bound to a driver:
-	 *  - chipselect polarity
 	 *  - quirks like clock rate mattering when not selected
 	 */
 };

commit a020ed7521a9737bcf3e34eb880867c60c3c68d0
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Apr 3 15:49:04 2006 -0700

    [PATCH] SPI: busnum == 0 needs to work
    
    We need to be able to have a "SPI bus 0" matching chip numbering; but
    that number was wrongly used to flag dynamic allocation of a bus number.
    
    This patch resolves that issue; now negative numbers trigger dynamic alloc.
    
    It also updates the how-to-write-a-controller-driver overview to mention
    this stuff.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 77add901691d..e928c0dcc297 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -172,13 +172,13 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
 struct spi_master {
 	struct class_device	cdev;
 
-	/* other than zero (== assign one dynamically), bus_num is fully
+	/* other than negative (== assign one dynamically), bus_num is fully
 	 * board-specific.  usually that simplifies to being SOC-specific.
-	 * example:  one SOC has three SPI controllers, numbered 1..3,
+	 * example:  one SOC has three SPI controllers, numbered 0..2,
 	 * and one board's schematics might show it using SPI-2.  software
 	 * would normally use bus_num=2 for that controller.
 	 */
-	u16			bus_num;
+	s16			bus_num;
 
 	/* chipselects will be integral to many controllers; some others
 	 * might use board-specific GPIOs.

commit ccf77cc4af5b048e20cfd9327fcc286cb69c34cc
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Apr 3 15:46:22 2006 -0700

    [PATCH] SPI: devices can require LSB-first encodings
    
    Add spi_device hook for LSB-first word encoding, and update all the
    (in-tree) controller drivers to reject such devices.  Eventually,
    some controller drivers will be updated to support lsb-first encodings
    on the wire; no current drivers need this.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 082006714b85..77add901691d 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -35,10 +35,13 @@ extern struct bus_type spi_bus_type;
  * @chip-select: Chipselect, distinguishing chips handled by "master".
  * @mode: The spi mode defines how data is clocked out and in.
  *	This may be changed by the device's driver.
+ *	The "active low" default for chipselect mode can be overridden,
+ *	as can the "MSB first" default for each word in a transfer.
  * @bits_per_word: Data transfers involve one or more words; word sizes
  *	like eight or 12 bits are common.  In-memory wordsizes are
  *	powers of two bytes (e.g. 20 bit samples use 32 bits).
- *	This may be changed by the device's driver.
+ *	This may be changed by the device's driver, or left at the
+ *	default (0) indicating protocol words are eight bit bytes.
  *	The spi_transfer.bits_per_word can override this for each transfer.
  * @irq: Negative, or the number passed to request_irq() to receive
  *	interrupts from this device.
@@ -67,6 +70,7 @@ struct spi_device {
 #define	SPI_MODE_2	(SPI_CPOL|0)
 #define	SPI_MODE_3	(SPI_CPOL|SPI_CPHA)
 #define	SPI_CS_HIGH	0x04			/* chipselect active high? */
+#define	SPI_LSB_FIRST	0x08			/* per-word bits-on-wire */
 	u8			bits_per_word;
 	int			irq;
 	void			*controller_state;
@@ -75,7 +79,6 @@ struct spi_device {
 
 	// likely need more hooks for more protocol options affecting how
 	// the controller talks to each chip, like:
-	//  - bit order (default is wordwise msb-first)
 	//  - memory packing (12 bit samples into low bits, others zeroed)
 	//  - priority
 	//  - drop chipselect after each word

commit 747d844ee9a183ff3067bb1181f2a25c50649538
Author: David Brownell <david-b@pacbell.net>
Date:   Sun Apr 2 10:33:37 2006 -0800

    [PATCH] SPI: spi whitespace fixes
    
    This removes superfluous whitespace in the <linux/spi/spi.h> header.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index caa4665e3fa2..082006714b85 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -36,15 +36,15 @@ extern struct bus_type spi_bus_type;
  * @mode: The spi mode defines how data is clocked out and in.
  *	This may be changed by the device's driver.
  * @bits_per_word: Data transfers involve one or more words; word sizes
- * 	like eight or 12 bits are common.  In-memory wordsizes are
+ *	like eight or 12 bits are common.  In-memory wordsizes are
  *	powers of two bytes (e.g. 20 bit samples use 32 bits).
  *	This may be changed by the device's driver.
  *	The spi_transfer.bits_per_word can override this for each transfer.
  * @irq: Negative, or the number passed to request_irq() to receive
- * 	interrupts from this device.
+ *	interrupts from this device.
  * @controller_state: Controller's runtime state
  * @controller_data: Board-specific definitions for controller, such as
- * 	FIFO initialization parameters; from board_info.controller_data
+ *	FIFO initialization parameters; from board_info.controller_data
  *
  * An spi_device is used to interchange data between an SPI slave
  * (usually a discrete chip) and CPU memory.
@@ -145,13 +145,13 @@ static inline void spi_unregister_driver(struct spi_driver *sdrv)
  * struct spi_master - interface to SPI master controller
  * @cdev: class interface to this driver
  * @bus_num: board-specific (and often SOC-specific) identifier for a
- * 	given SPI controller.
+ *	given SPI controller.
  * @num_chipselect: chipselects are used to distinguish individual
- * 	SPI slaves, and are numbered from zero to num_chipselects.
- * 	each slave has a chipselect signal, but it's common that not
- * 	every chipselect is connected to a slave.
+ *	SPI slaves, and are numbered from zero to num_chipselects.
+ *	each slave has a chipselect signal, but it's common that not
+ *	every chipselect is connected to a slave.
  * @setup: updates the device mode and clocking records used by a
- * 	device's SPI controller; protocol code may call this.
+ *	device's SPI controller; protocol code may call this.
  * @transfer: adds a message to the controller's transfer queue.
  * @cleanup: frees controller-specific state
  *
@@ -276,8 +276,8 @@ extern struct spi_master *spi_busnum_to_master(u16 busnum);
  *      for this transfer. If 0 the default (from spi_device) is used.
  * @cs_change: affects chipselect after this transfer completes
  * @delay_usecs: microseconds to delay after this transfer before
- * 	(optionally) changing the chipselect status, then starting
- * 	the next transfer or completing this spi_message.
+ *	(optionally) changing the chipselect status, then starting
+ *	the next transfer or completing this spi_message.
  * @transfer_list: transfers are sequenced through spi_message.transfers
  *
  * SPI transfers always write the same number of bytes as they read.
@@ -364,7 +364,7 @@ struct spi_transfer {
  * and its transfers, ignore them until its completion callback.
  */
 struct spi_message {
-	struct list_head 	transfers;
+	struct list_head	transfers;
 
 	struct spi_device	*spi;
 
@@ -382,7 +382,7 @@ struct spi_message {
 	 */
 
 	/* completion is reported through a callback */
-	void 			(*complete)(void *context);
+	void			(*complete)(void *context);
 	void			*context;
 	unsigned		actual_length;
 	int			status;

commit 4cff33f94fefcce1b3c01a9d1da6bb85fe3cbdfa
Author: Imre Deak <imre.deak@nokia.com>
Date:   Fri Feb 17 10:02:18 2006 -0800

    [PATCH] SPI: per-transfer overrides for wordsize and clocking
    
    Some protocols (like one for some bitmap displays) require different clock
    speed or word size settings for each transfer in an SPI message. This adds
    those parameters to struct spi_transfer.  They are to be used when they are
    nonzero; otherwise the defaults from spi_device are to be used.
    
    The patch also adds a setup_transfer callback to spi_bitbang, uses it for
    messages that use those overrides, and implements it so that the pure
    bitbanging code can help resolve any questions about how it should work.
    
    Signed-off-by: Imre Deak <imre.deak@nokia.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index b05f1463a267..caa4665e3fa2 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -31,6 +31,7 @@ extern struct bus_type spi_bus_type;
  * @master: SPI controller used with the device.
  * @max_speed_hz: Maximum clock rate to be used with this chip
  *	(on this board); may be changed by the device's driver.
+ *	The spi_transfer.speed_hz can override this for each transfer.
  * @chip-select: Chipselect, distinguishing chips handled by "master".
  * @mode: The spi mode defines how data is clocked out and in.
  *	This may be changed by the device's driver.
@@ -38,6 +39,7 @@ extern struct bus_type spi_bus_type;
  * 	like eight or 12 bits are common.  In-memory wordsizes are
  *	powers of two bytes (e.g. 20 bit samples use 32 bits).
  *	This may be changed by the device's driver.
+ *	The spi_transfer.bits_per_word can override this for each transfer.
  * @irq: Negative, or the number passed to request_irq() to receive
  * 	interrupts from this device.
  * @controller_state: Controller's runtime state
@@ -268,6 +270,10 @@ extern struct spi_master *spi_busnum_to_master(u16 busnum);
  * @tx_dma: DMA address of tx_buf, if spi_message.is_dma_mapped
  * @rx_dma: DMA address of rx_buf, if spi_message.is_dma_mapped
  * @len: size of rx and tx buffers (in bytes)
+ * @speed_hz: Select a speed other then the device default for this
+ *      transfer. If 0 the default (from spi_device) is used.
+ * @bits_per_word: select a bits_per_word other then the device default
+ *      for this transfer. If 0 the default (from spi_device) is used.
  * @cs_change: affects chipselect after this transfer completes
  * @delay_usecs: microseconds to delay after this transfer before
  * 	(optionally) changing the chipselect status, then starting
@@ -322,7 +328,9 @@ struct spi_transfer {
 	dma_addr_t	rx_dma;
 
 	unsigned	cs_change:1;
+	u8		bits_per_word;
 	u16		delay_usecs;
+	u32		speed_hz;
 
 	struct list_head transfer_list;
 };

commit 5d870c8e216f121307445c71caa72e7e10a20061
Author: Andrew Morton <akpm@osdl.org>
Date:   Wed Jan 11 11:23:49 2006 -0800

    [PATCH] spi: remove fastcall crap
    
    gcc4 generates warnings when a non-FASTCALL function pointer is assigned to a
    FASTCALL one.  Perhaps it has taste.
    
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 939afd3a2e72..b05f1463a267 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -374,7 +374,7 @@ struct spi_message {
 	 */
 
 	/* completion is reported through a callback */
-	void 			FASTCALL((*complete)(void *context));
+	void 			(*complete)(void *context);
 	void			*context;
 	unsigned		actual_length;
 	int			status;

commit 8275c642ccdce09a2146d0a9eb022e3698ee927e
Author: Vitaly Wool <vwool@ru.mvista.com>
Date:   Sun Jan 8 13:34:28 2006 -0800

    [PATCH] spi: use linked lists rather than an array
    
    This makes the SPI core and its users access transfers in the SPI message
    structure as linked list not as an array, as discussed on LKML.
    
    From: David Brownell <dbrownell@users.sourceforge.net>
    
      Updates including doc, bugfixes to the list code, add
      spi_message_add_tail().  Plus, initialize things _before_ grabbing the
      locks in some cases (in case it grows more expensive).  This also merges
      some bitbang updates of mine that didn't yet make it into the mm tree.
    
    Signed-off-by: Vitaly Wool <vwool@ru.mvista.com>
    Signed-off-by: Dmitry Pervushin <dpervushin@gmail.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 6a41e2650b2e..939afd3a2e72 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -263,15 +263,16 @@ extern struct spi_master *spi_busnum_to_master(u16 busnum);
 
 /**
  * struct spi_transfer - a read/write buffer pair
- * @tx_buf: data to be written (dma-safe address), or NULL
- * @rx_buf: data to be read (dma-safe address), or NULL
- * @tx_dma: DMA address of buffer, if spi_message.is_dma_mapped
- * @rx_dma: DMA address of buffer, if spi_message.is_dma_mapped
+ * @tx_buf: data to be written (dma-safe memory), or NULL
+ * @rx_buf: data to be read (dma-safe memory), or NULL
+ * @tx_dma: DMA address of tx_buf, if spi_message.is_dma_mapped
+ * @rx_dma: DMA address of rx_buf, if spi_message.is_dma_mapped
  * @len: size of rx and tx buffers (in bytes)
  * @cs_change: affects chipselect after this transfer completes
  * @delay_usecs: microseconds to delay after this transfer before
  * 	(optionally) changing the chipselect status, then starting
  * 	the next transfer or completing this spi_message.
+ * @transfer_list: transfers are sequenced through spi_message.transfers
  *
  * SPI transfers always write the same number of bytes as they read.
  * Protocol drivers should always provide rx_buf and/or tx_buf.
@@ -279,11 +280,16 @@ extern struct spi_master *spi_busnum_to_master(u16 busnum);
  * the data being transferred; that may reduce overhead, when the
  * underlying driver uses dma.
  *
- * All SPI transfers start with the relevant chipselect active.  Drivers
- * can change behavior of the chipselect after the transfer finishes
- * (including any mandatory delay).  The normal behavior is to leave it
- * selected, except for the last transfer in a message.  Setting cs_change
- * allows two additional behavior options:
+ * If the transmit buffer is null, undefined data will be shifted out
+ * while filling rx_buf.  If the receive buffer is null, the data
+ * shifted in will be discarded.  Only "len" bytes shift out (or in).
+ * It's an error to try to shift out a partial word.  (For example, by
+ * shifting out three bytes with word size of sixteen or twenty bits;
+ * the former uses two bytes per word, the latter uses four bytes.)
+ *
+ * All SPI transfers start with the relevant chipselect active.  Normally
+ * it stays selected until after the last transfer in a message.  Drivers
+ * can affect the chipselect signal using cs_change:
  *
  * (i) If the transfer isn't the last one in the message, this flag is
  * used to make the chipselect briefly go inactive in the middle of the
@@ -299,7 +305,8 @@ extern struct spi_master *spi_busnum_to_master(u16 busnum);
  * The code that submits an spi_message (and its spi_transfers)
  * to the lower layers is responsible for managing its memory.
  * Zero-initialize every field you don't set up explicitly, to
- * insulate against future API updates.
+ * insulate against future API updates.  After you submit a message
+ * and its transfers, ignore them until its completion callback.
  */
 struct spi_transfer {
 	/* it's ok if tx_buf == rx_buf (right?)
@@ -316,12 +323,13 @@ struct spi_transfer {
 
 	unsigned	cs_change:1;
 	u16		delay_usecs;
+
+	struct list_head transfer_list;
 };
 
 /**
  * struct spi_message - one multi-segment SPI transaction
- * @transfers: the segements of the transaction
- * @n_transfer: how many segments
+ * @transfers: list of transfer segments in this transaction
  * @spi: SPI device to which the transaction is queued
  * @is_dma_mapped: if true, the caller provided both dma and cpu virtual
  *	addresses for each transfer buffer
@@ -333,14 +341,22 @@ struct spi_transfer {
  * @queue: for use by whichever driver currently owns the message
  * @state: for use by whichever driver currently owns the message
  *
+ * An spi_message is used to execute an atomic sequence of data transfers,
+ * each represented by a struct spi_transfer.  The sequence is "atomic"
+ * in the sense that no other spi_message may use that SPI bus until that
+ * sequence completes.  On some systems, many such sequences can execute as
+ * as single programmed DMA transfer.  On all systems, these messages are
+ * queued, and might complete after transactions to other devices.  Messages
+ * sent to a given spi_device are alway executed in FIFO order.
+ *
  * The code that submits an spi_message (and its spi_transfers)
  * to the lower layers is responsible for managing its memory.
  * Zero-initialize every field you don't set up explicitly, to
- * insulate against future API updates.
+ * insulate against future API updates.  After you submit a message
+ * and its transfers, ignore them until its completion callback.
  */
 struct spi_message {
-	struct spi_transfer	*transfers;
-	unsigned		n_transfer;
+	struct list_head 	transfers;
 
 	struct spi_device	*spi;
 
@@ -371,6 +387,24 @@ struct spi_message {
 	void			*state;
 };
 
+static inline void spi_message_init(struct spi_message *m)
+{
+	memset(m, 0, sizeof *m);
+	INIT_LIST_HEAD(&m->transfers);
+}
+
+static inline void
+spi_message_add_tail(struct spi_transfer *t, struct spi_message *m)
+{
+	list_add_tail(&t->transfer_list, &m->transfers);
+}
+
+static inline void
+spi_transfer_del(struct spi_transfer *t)
+{
+	list_del(&t->transfer_list);
+}
+
 /* It's fine to embed message and transaction structures in other data
  * structures so long as you don't free them while they're in use.
  */
@@ -383,8 +417,12 @@ static inline struct spi_message *spi_message_alloc(unsigned ntrans, gfp_t flags
 			+ ntrans * sizeof(struct spi_transfer),
 			flags);
 	if (m) {
-		m->transfers = (void *)(m + 1);
-		m->n_transfer = ntrans;
+		int i;
+		struct spi_transfer *t = (struct spi_transfer *)(m + 1);
+
+		INIT_LIST_HEAD(&m->transfers);
+		for (i = 0; i < ntrans; i++, t++)
+			spi_message_add_tail(t, m);
 	}
 	return m;
 }
@@ -402,6 +440,8 @@ static inline void spi_message_free(struct spi_message *m)
  * device doesn't work with the mode 0 default.  They may likewise need
  * to update clock rates or word sizes from initial values.  This function
  * changes those settings, and must be called from a context that can sleep.
+ * The changes take effect the next time the device is selected and data
+ * is transferred to or from it.
  */
 static inline int
 spi_setup(struct spi_device *spi)
@@ -468,15 +508,12 @@ spi_write(struct spi_device *spi, const u8 *buf, size_t len)
 {
 	struct spi_transfer	t = {
 			.tx_buf		= buf,
-			.rx_buf		= NULL,
 			.len		= len,
-			.cs_change	= 0,
-		};
-	struct spi_message	m = {
-			.transfers	= &t,
-			.n_transfer	= 1,
 		};
+	struct spi_message	m;
 
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
 	return spi_sync(spi, &m);
 }
 
@@ -493,16 +530,13 @@ static inline int
 spi_read(struct spi_device *spi, u8 *buf, size_t len)
 {
 	struct spi_transfer	t = {
-			.tx_buf		= NULL,
 			.rx_buf		= buf,
 			.len		= len,
-			.cs_change	= 0,
-		};
-	struct spi_message	m = {
-			.transfers	= &t,
-			.n_transfer	= 1,
 		};
+	struct spi_message	m;
 
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
 	return spi_sync(spi, &m);
 }
 

commit 0c868461fcb8413cb9f691d68e5b99b0fd3c0737
Author: David Brownell <david-b@pacbell.net>
Date:   Sun Jan 8 13:34:25 2006 -0800

    [PATCH] SPI core tweaks, bugfix
    
    This includes various updates to the SPI core:
    
      - Fixes a driver model refcount bug in spi_unregister_master() paths.
    
      - The spi_master structures now have wrappers which help keep drivers
        from needing class-level get/put for device data or for refcounts.
    
      - Check for a few setup errors that would cause oopsing later.
    
      - Docs say more about memory management.  Highlights the use of DMA-safe
        i/o buffers, and zero-initializing spi_message and such metadata.
    
      - Provide a simple alloc/free for spi_message and its spi_transfer;
        this is only one of the possible memory management policies.
    
    Nothing to break code that already works.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index c851b3d13208..6a41e2650b2e 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -60,8 +60,8 @@ struct spi_device {
 	u8			mode;
 #define	SPI_CPHA	0x01			/* clock phase */
 #define	SPI_CPOL	0x02			/* clock polarity */
-#define	SPI_MODE_0	(0|0)
-#define	SPI_MODE_1	(0|SPI_CPHA)		/* (original MicroWire) */
+#define	SPI_MODE_0	(0|0)			/* (original MicroWire) */
+#define	SPI_MODE_1	(0|SPI_CPHA)
 #define	SPI_MODE_2	(SPI_CPOL|0)
 #define	SPI_MODE_3	(SPI_CPOL|SPI_CPHA)
 #define	SPI_CS_HIGH	0x04			/* chipselect active high? */
@@ -209,6 +209,30 @@ struct spi_master {
 	void			(*cleanup)(const struct spi_device *spi);
 };
 
+static inline void *spi_master_get_devdata(struct spi_master *master)
+{
+	return class_get_devdata(&master->cdev);
+}
+
+static inline void spi_master_set_devdata(struct spi_master *master, void *data)
+{
+	class_set_devdata(&master->cdev, data);
+}
+
+static inline struct spi_master *spi_master_get(struct spi_master *master)
+{
+	if (!master || !class_device_get(&master->cdev))
+		return NULL;
+	return master;
+}
+
+static inline void spi_master_put(struct spi_master *master)
+{
+	if (master)
+		class_device_put(&master->cdev);
+}
+
+
 /* the spi driver core manages memory for the spi_master classdev */
 extern struct spi_master *
 spi_alloc_master(struct device *host, unsigned size);
@@ -271,11 +295,17 @@ extern struct spi_master *spi_busnum_to_master(u16 busnum);
  * stay selected until the next transfer.  This is purely a performance
  * hint; the controller driver may need to select a different device
  * for the next message.
+ *
+ * The code that submits an spi_message (and its spi_transfers)
+ * to the lower layers is responsible for managing its memory.
+ * Zero-initialize every field you don't set up explicitly, to
+ * insulate against future API updates.
  */
 struct spi_transfer {
 	/* it's ok if tx_buf == rx_buf (right?)
 	 * for MicroWire, one buffer must be null
-	 * buffers must work with dma_*map_single() calls
+	 * buffers must work with dma_*map_single() calls, unless
+	 *   spi_message.is_dma_mapped reports a pre-existing mapping
 	 */
 	const void	*tx_buf;
 	void		*rx_buf;
@@ -302,6 +332,11 @@ struct spi_transfer {
  * @status: zero for success, else negative errno
  * @queue: for use by whichever driver currently owns the message
  * @state: for use by whichever driver currently owns the message
+ *
+ * The code that submits an spi_message (and its spi_transfers)
+ * to the lower layers is responsible for managing its memory.
+ * Zero-initialize every field you don't set up explicitly, to
+ * insulate against future API updates.
  */
 struct spi_message {
 	struct spi_transfer	*transfers;
@@ -336,6 +371,29 @@ struct spi_message {
 	void			*state;
 };
 
+/* It's fine to embed message and transaction structures in other data
+ * structures so long as you don't free them while they're in use.
+ */
+
+static inline struct spi_message *spi_message_alloc(unsigned ntrans, gfp_t flags)
+{
+	struct spi_message *m;
+
+	m = kzalloc(sizeof(struct spi_message)
+			+ ntrans * sizeof(struct spi_transfer),
+			flags);
+	if (m) {
+		m->transfers = (void *)(m + 1);
+		m->n_transfer = ntrans;
+	}
+	return m;
+}
+
+static inline void spi_message_free(struct spi_message *m)
+{
+	kfree(m);
+}
+
 /**
  * spi_setup -- setup SPI mode and clock rate
  * @spi: the device whose settings are being modified
@@ -363,7 +421,10 @@ spi_setup(struct spi_device *spi)
  * The completion callback is invoked in a context which can't sleep.
  * Before that invocation, the value of message->status is undefined.
  * When the callback is issued, message->status holds either zero (to
- * indicate complete success) or a negative error code.
+ * indicate complete success) or a negative error code.  After that
+ * callback returns, the driver which issued the transfer request may
+ * deallocate the associated memory; it's no longer in use by any SPI
+ * core or controller driver code.
  *
  * Note that although all messages to a spi_device are handled in
  * FIFO order, messages may go to different devices in other orders.
@@ -445,6 +506,7 @@ spi_read(struct spi_device *spi, u8 *buf, size_t len)
 	return spi_sync(spi, &m);
 }
 
+/* this copies txbuf and rxbuf data; for small transfers only! */
 extern int spi_write_then_read(struct spi_device *spi,
 		const u8 *txbuf, unsigned n_tx,
 		u8 *rxbuf, unsigned n_rx);
@@ -555,8 +617,9 @@ spi_register_board_info(struct spi_board_info const *info, unsigned n)
 
 
 /* If you're hotplugging an adapter with devices (parport, usb, etc)
- * use spi_new_device() to describe each device.  You would then call
- * spi_unregister_device() to start making that device vanish.
+ * use spi_new_device() to describe each device.  You can also call
+ * spi_unregister_device() to start making that device vanish, but
+ * normally that would be handled by spi_unregister_master().
  */
 extern struct spi_device *
 spi_new_device(struct spi_master *, struct spi_board_info *);

commit b885244eb2628e0b8206e7edaaa6a314da78e9a4
Author: David Brownell <david-b@pacbell.net>
Date:   Sun Jan 8 13:34:23 2006 -0800

    [PATCH] spi: add spi_driver to SPI framework
    
    This is a refresh of the "Simple SPI Framework" found in 2.6.15-rc3-mm1
    which makes the following changes:
    
      * There's now a "struct spi_driver".  This increase the footprint
        of the core a bit, since it now includes code to do what the driver
        core was previously handling directly.  Documentation and comments
        were updated to match.
    
      * spi_alloc_master() now does class_device_initialize(), so it can
        at least be refcounted before spi_register_master().  To match,
        spi_register_master() switched over to class_device_add().
    
      * States explicitly that after transfer errors, spi_devices will be
        deselected.  We want fault recovery procedures to work the same
        for all controller drivers.
    
      * Minor tweaks:  controller_data no longer points to readonly data;
        prevent some potential cast-from-null bugs with container_of calls;
        clarifies some existing kerneldoc,
    
    And a few small cleanups.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 51a6769114df..c851b3d13208 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -20,13 +20,8 @@
 #define __LINUX_SPI_H
 
 /*
- * INTERFACES between SPI master drivers and infrastructure
+ * INTERFACES between SPI master-side drivers and SPI infrastructure.
  * (There's no SPI slave support for Linux yet...)
- *
- * A "struct device_driver" for an spi_device uses "spi_bus_type" and
- * needs no special API wrappers (much like platform_bus).  These drivers
- * are bound to devices based on their names (much like platform_bus),
- * and are available in dev->driver.
  */
 extern struct bus_type spi_bus_type;
 
@@ -46,8 +41,8 @@ extern struct bus_type spi_bus_type;
  * @irq: Negative, or the number passed to request_irq() to receive
  * 	interrupts from this device.
  * @controller_state: Controller's runtime state
- * @controller_data: Static board-specific definitions for controller, such
- * 	as FIFO initialization parameters; from board_info.controller_data
+ * @controller_data: Board-specific definitions for controller, such as
+ * 	FIFO initialization parameters; from board_info.controller_data
  *
  * An spi_device is used to interchange data between an SPI slave
  * (usually a discrete chip) and CPU memory.
@@ -63,31 +58,32 @@ struct spi_device {
 	u32			max_speed_hz;
 	u8			chip_select;
 	u8			mode;
-#define	SPI_CPHA	0x01		/* clock phase */
-#define	SPI_CPOL	0x02		/* clock polarity */
+#define	SPI_CPHA	0x01			/* clock phase */
+#define	SPI_CPOL	0x02			/* clock polarity */
 #define	SPI_MODE_0	(0|0)
-#define	SPI_MODE_1	(0|SPI_CPHA)
+#define	SPI_MODE_1	(0|SPI_CPHA)		/* (original MicroWire) */
 #define	SPI_MODE_2	(SPI_CPOL|0)
 #define	SPI_MODE_3	(SPI_CPOL|SPI_CPHA)
-#define	SPI_CS_HIGH	0x04		/* chipselect active high? */
+#define	SPI_CS_HIGH	0x04			/* chipselect active high? */
 	u8			bits_per_word;
 	int			irq;
 	void			*controller_state;
-	const void		*controller_data;
+	void			*controller_data;
 	const char		*modalias;
 
 	// likely need more hooks for more protocol options affecting how
-	// the controller talks to its chips, like:
+	// the controller talks to each chip, like:
 	//  - bit order (default is wordwise msb-first)
 	//  - memory packing (12 bit samples into low bits, others zeroed)
 	//  - priority
+	//  - drop chipselect after each word
 	//  - chipselect delays
 	//  - ...
 };
 
 static inline struct spi_device *to_spi_device(struct device *dev)
 {
-	return container_of(dev, struct spi_device, dev);
+	return dev ? container_of(dev, struct spi_device, dev) : NULL;
 }
 
 /* most drivers won't need to care about device refcounting */
@@ -117,12 +113,38 @@ static inline void spi_set_ctldata(struct spi_device *spi, void *state)
 struct spi_message;
 
 
+
+struct spi_driver {
+	int			(*probe)(struct spi_device *spi);
+	int			(*remove)(struct spi_device *spi);
+	void			(*shutdown)(struct spi_device *spi);
+	int			(*suspend)(struct spi_device *spi, pm_message_t mesg);
+	int			(*resume)(struct spi_device *spi);
+	struct device_driver	driver;
+};
+
+static inline struct spi_driver *to_spi_driver(struct device_driver *drv)
+{
+	return drv ? container_of(drv, struct spi_driver, driver) : NULL;
+}
+
+extern int spi_register_driver(struct spi_driver *sdrv);
+
+static inline void spi_unregister_driver(struct spi_driver *sdrv)
+{
+	if (!sdrv)
+		return;
+	driver_unregister(&sdrv->driver);
+}
+
+
+
 /**
  * struct spi_master - interface to SPI master controller
  * @cdev: class interface to this driver
  * @bus_num: board-specific (and often SOC-specific) identifier for a
  * 	given SPI controller.
- * @num_chipselects: chipselects are used to distinguish individual
+ * @num_chipselect: chipselects are used to distinguish individual
  * 	SPI slaves, and are numbered from zero to num_chipselects.
  * 	each slave has a chipselect signal, but it's common that not
  * 	every chipselect is connected to a slave.
@@ -275,7 +297,8 @@ struct spi_transfer {
  *	addresses for each transfer buffer
  * @complete: called to report transaction completions
  * @context: the argument to complete() when it's called
- * @actual_length: how many bytes were transferd
+ * @actual_length: the total number of bytes that were transferred in all
+ *	successful segments
  * @status: zero for success, else negative errno
  * @queue: for use by whichever driver currently owns the message
  * @state: for use by whichever driver currently owns the message
@@ -295,7 +318,7 @@ struct spi_message {
 	 *
 	 * Some controller drivers (message-at-a-time queue processing)
 	 * could provide that as their default scheduling algorithm.  But
-	 * others (with multi-message pipelines) would need a flag to
+	 * others (with multi-message pipelines) could need a flag to
 	 * tell them about such special cases.
 	 */
 
@@ -346,6 +369,13 @@ spi_setup(struct spi_device *spi)
  * FIFO order, messages may go to different devices in other orders.
  * Some device might be higher priority, or have various "hard" access
  * time requirements, for example.
+ *
+ * On detection of any fault during the transfer, processing of
+ * the entire message is aborted, and the device is deselected.
+ * Until returning from the associated message completion callback,
+ * no other spi_message queued to that device will be processed.
+ * (This rule applies equally to all the synchronous transfer calls,
+ * which are wrappers around this core asynchronous primitive.)
  */
 static inline int
 spi_async(struct spi_device *spi, struct spi_message *message)
@@ -484,12 +514,12 @@ struct spi_board_info {
 	 * "modalias" is normally the driver name.
 	 *
 	 * platform_data goes to spi_device.dev.platform_data,
-	 * controller_data goes to spi_device.platform_data,
+	 * controller_data goes to spi_device.controller_data,
 	 * irq is copied too
 	 */
 	char		modalias[KOBJ_NAME_LEN];
 	const void	*platform_data;
-	const void	*controller_data;
+	void		*controller_data;
 	int		irq;
 
 	/* slower signaling on noisy or low voltage boards */
@@ -525,9 +555,8 @@ spi_register_board_info(struct spi_board_info const *info, unsigned n)
 
 
 /* If you're hotplugging an adapter with devices (parport, usb, etc)
- * use spi_new_device() to describe each device.  You can also call
- * spi_unregister_device() to get start making that device vanish,
- * but normally that would be handled by spi_unregister_master().
+ * use spi_new_device() to describe each device.  You would then call
+ * spi_unregister_device() to start making that device vanish.
  */
 extern struct spi_device *
 spi_new_device(struct spi_master *, struct spi_board_info *);

commit 8ae12a0d85987dc138f8c944cb78a92bf466cea0
Author: David Brownell <david-b@pacbell.net>
Date:   Sun Jan 8 13:34:19 2006 -0800

    [PATCH] spi: simple SPI framework
    
    This is the core of a small SPI framework, implementing the model of a
    queue of messages which complete asynchronously (with thin synchronous
    wrappers on top).
    
      - It's still less than 2KB of ".text" (ARM).  If there's got to be a
        mid-layer for something so simple, that's the right size budget.  :)
    
      - The guts use board-specific SPI device tables to build the driver
        model tree.  (Hardware probing is rarely an option.)
    
      - This version of Kconfig includes no drivers.  At this writing there
        are two known master controller drivers (PXA/SSP, OMAP MicroWire)
        and three protocol drivers (CS8415a, ADS7846, DataFlash) with LKML
        mentions of other drivers in development.
    
      - No userspace API.  There are several implementations to compare.
        Implement them like any other driver, and bind them with sysfs.
    
    The changes from last version posted to LKML (on 11-Nov-2005) are minor,
    and include:
    
      - One bugfix (removes a FIXME), with the visible effect of making device
        names be "spiB.C" where B is the bus number and C is the chipselect.
    
      - The "caller provides DMA mappings" mechanism now has kerneldoc, for
        DMA drivers that want to be fancy.
    
      - Hey, the framework init can be subsys_init.  Even though board init
        logic fires earlier, at arch_init ... since the framework init is
        for driver support, and the board init support uses static init.
    
      - Various additional spec/doc clarifications based on discussions
        with other folk.  It adds a brief "thank you" at the end, for folk
        who've helped nudge this framework into existence.
    
    As I've said before, I think that "protocol tweaking" is the main support
    that this driver framework will need to evolve.
    
    From: Mark Underwood <basicmark@yahoo.com>
    
      Update the SPI framework to remove a potential priority inversion case by
      reverting to kmalloc if the pre-allocated DMA-safe buffer isn't available.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
new file mode 100644
index 000000000000..51a6769114df
--- /dev/null
+++ b/include/linux/spi/spi.h
@@ -0,0 +1,542 @@
+/*
+ * Copyright (C) 2005 David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __LINUX_SPI_H
+#define __LINUX_SPI_H
+
+/*
+ * INTERFACES between SPI master drivers and infrastructure
+ * (There's no SPI slave support for Linux yet...)
+ *
+ * A "struct device_driver" for an spi_device uses "spi_bus_type" and
+ * needs no special API wrappers (much like platform_bus).  These drivers
+ * are bound to devices based on their names (much like platform_bus),
+ * and are available in dev->driver.
+ */
+extern struct bus_type spi_bus_type;
+
+/**
+ * struct spi_device - Master side proxy for an SPI slave device
+ * @dev: Driver model representation of the device.
+ * @master: SPI controller used with the device.
+ * @max_speed_hz: Maximum clock rate to be used with this chip
+ *	(on this board); may be changed by the device's driver.
+ * @chip-select: Chipselect, distinguishing chips handled by "master".
+ * @mode: The spi mode defines how data is clocked out and in.
+ *	This may be changed by the device's driver.
+ * @bits_per_word: Data transfers involve one or more words; word sizes
+ * 	like eight or 12 bits are common.  In-memory wordsizes are
+ *	powers of two bytes (e.g. 20 bit samples use 32 bits).
+ *	This may be changed by the device's driver.
+ * @irq: Negative, or the number passed to request_irq() to receive
+ * 	interrupts from this device.
+ * @controller_state: Controller's runtime state
+ * @controller_data: Static board-specific definitions for controller, such
+ * 	as FIFO initialization parameters; from board_info.controller_data
+ *
+ * An spi_device is used to interchange data between an SPI slave
+ * (usually a discrete chip) and CPU memory.
+ *
+ * In "dev", the platform_data is used to hold information about this
+ * device that's meaningful to the device's protocol driver, but not
+ * to its controller.  One example might be an identifier for a chip
+ * variant with slightly different functionality.
+ */
+struct spi_device {
+	struct device		dev;
+	struct spi_master	*master;
+	u32			max_speed_hz;
+	u8			chip_select;
+	u8			mode;
+#define	SPI_CPHA	0x01		/* clock phase */
+#define	SPI_CPOL	0x02		/* clock polarity */
+#define	SPI_MODE_0	(0|0)
+#define	SPI_MODE_1	(0|SPI_CPHA)
+#define	SPI_MODE_2	(SPI_CPOL|0)
+#define	SPI_MODE_3	(SPI_CPOL|SPI_CPHA)
+#define	SPI_CS_HIGH	0x04		/* chipselect active high? */
+	u8			bits_per_word;
+	int			irq;
+	void			*controller_state;
+	const void		*controller_data;
+	const char		*modalias;
+
+	// likely need more hooks for more protocol options affecting how
+	// the controller talks to its chips, like:
+	//  - bit order (default is wordwise msb-first)
+	//  - memory packing (12 bit samples into low bits, others zeroed)
+	//  - priority
+	//  - chipselect delays
+	//  - ...
+};
+
+static inline struct spi_device *to_spi_device(struct device *dev)
+{
+	return container_of(dev, struct spi_device, dev);
+}
+
+/* most drivers won't need to care about device refcounting */
+static inline struct spi_device *spi_dev_get(struct spi_device *spi)
+{
+	return (spi && get_device(&spi->dev)) ? spi : NULL;
+}
+
+static inline void spi_dev_put(struct spi_device *spi)
+{
+	if (spi)
+		put_device(&spi->dev);
+}
+
+/* ctldata is for the bus_master driver's runtime state */
+static inline void *spi_get_ctldata(struct spi_device *spi)
+{
+	return spi->controller_state;
+}
+
+static inline void spi_set_ctldata(struct spi_device *spi, void *state)
+{
+	spi->controller_state = state;
+}
+
+
+struct spi_message;
+
+
+/**
+ * struct spi_master - interface to SPI master controller
+ * @cdev: class interface to this driver
+ * @bus_num: board-specific (and often SOC-specific) identifier for a
+ * 	given SPI controller.
+ * @num_chipselects: chipselects are used to distinguish individual
+ * 	SPI slaves, and are numbered from zero to num_chipselects.
+ * 	each slave has a chipselect signal, but it's common that not
+ * 	every chipselect is connected to a slave.
+ * @setup: updates the device mode and clocking records used by a
+ * 	device's SPI controller; protocol code may call this.
+ * @transfer: adds a message to the controller's transfer queue.
+ * @cleanup: frees controller-specific state
+ *
+ * Each SPI master controller can communicate with one or more spi_device
+ * children.  These make a small bus, sharing MOSI, MISO and SCK signals
+ * but not chip select signals.  Each device may be configured to use a
+ * different clock rate, since those shared signals are ignored unless
+ * the chip is selected.
+ *
+ * The driver for an SPI controller manages access to those devices through
+ * a queue of spi_message transactions, copyin data between CPU memory and
+ * an SPI slave device).  For each such message it queues, it calls the
+ * message's completion function when the transaction completes.
+ */
+struct spi_master {
+	struct class_device	cdev;
+
+	/* other than zero (== assign one dynamically), bus_num is fully
+	 * board-specific.  usually that simplifies to being SOC-specific.
+	 * example:  one SOC has three SPI controllers, numbered 1..3,
+	 * and one board's schematics might show it using SPI-2.  software
+	 * would normally use bus_num=2 for that controller.
+	 */
+	u16			bus_num;
+
+	/* chipselects will be integral to many controllers; some others
+	 * might use board-specific GPIOs.
+	 */
+	u16			num_chipselect;
+
+	/* setup mode and clock, etc (spi driver may call many times) */
+	int			(*setup)(struct spi_device *spi);
+
+	/* bidirectional bulk transfers
+	 *
+	 * + The transfer() method may not sleep; its main role is
+	 *   just to add the message to the queue.
+	 * + For now there's no remove-from-queue operation, or
+	 *   any other request management
+	 * + To a given spi_device, message queueing is pure fifo
+	 *
+	 * + The master's main job is to process its message queue,
+	 *   selecting a chip then transferring data
+	 * + If there are multiple spi_device children, the i/o queue
+	 *   arbitration algorithm is unspecified (round robin, fifo,
+	 *   priority, reservations, preemption, etc)
+	 *
+	 * + Chipselect stays active during the entire message
+	 *   (unless modified by spi_transfer.cs_change != 0).
+	 * + The message transfers use clock and SPI mode parameters
+	 *   previously established by setup() for this device
+	 */
+	int			(*transfer)(struct spi_device *spi,
+						struct spi_message *mesg);
+
+	/* called on release() to free memory provided by spi_master */
+	void			(*cleanup)(const struct spi_device *spi);
+};
+
+/* the spi driver core manages memory for the spi_master classdev */
+extern struct spi_master *
+spi_alloc_master(struct device *host, unsigned size);
+
+extern int spi_register_master(struct spi_master *master);
+extern void spi_unregister_master(struct spi_master *master);
+
+extern struct spi_master *spi_busnum_to_master(u16 busnum);
+
+/*---------------------------------------------------------------------------*/
+
+/*
+ * I/O INTERFACE between SPI controller and protocol drivers
+ *
+ * Protocol drivers use a queue of spi_messages, each transferring data
+ * between the controller and memory buffers.
+ *
+ * The spi_messages themselves consist of a series of read+write transfer
+ * segments.  Those segments always read the same number of bits as they
+ * write; but one or the other is easily ignored by passing a null buffer
+ * pointer.  (This is unlike most types of I/O API, because SPI hardware
+ * is full duplex.)
+ *
+ * NOTE:  Allocation of spi_transfer and spi_message memory is entirely
+ * up to the protocol driver, which guarantees the integrity of both (as
+ * well as the data buffers) for as long as the message is queued.
+ */
+
+/**
+ * struct spi_transfer - a read/write buffer pair
+ * @tx_buf: data to be written (dma-safe address), or NULL
+ * @rx_buf: data to be read (dma-safe address), or NULL
+ * @tx_dma: DMA address of buffer, if spi_message.is_dma_mapped
+ * @rx_dma: DMA address of buffer, if spi_message.is_dma_mapped
+ * @len: size of rx and tx buffers (in bytes)
+ * @cs_change: affects chipselect after this transfer completes
+ * @delay_usecs: microseconds to delay after this transfer before
+ * 	(optionally) changing the chipselect status, then starting
+ * 	the next transfer or completing this spi_message.
+ *
+ * SPI transfers always write the same number of bytes as they read.
+ * Protocol drivers should always provide rx_buf and/or tx_buf.
+ * In some cases, they may also want to provide DMA addresses for
+ * the data being transferred; that may reduce overhead, when the
+ * underlying driver uses dma.
+ *
+ * All SPI transfers start with the relevant chipselect active.  Drivers
+ * can change behavior of the chipselect after the transfer finishes
+ * (including any mandatory delay).  The normal behavior is to leave it
+ * selected, except for the last transfer in a message.  Setting cs_change
+ * allows two additional behavior options:
+ *
+ * (i) If the transfer isn't the last one in the message, this flag is
+ * used to make the chipselect briefly go inactive in the middle of the
+ * message.  Toggling chipselect in this way may be needed to terminate
+ * a chip command, letting a single spi_message perform all of group of
+ * chip transactions together.
+ *
+ * (ii) When the transfer is the last one in the message, the chip may
+ * stay selected until the next transfer.  This is purely a performance
+ * hint; the controller driver may need to select a different device
+ * for the next message.
+ */
+struct spi_transfer {
+	/* it's ok if tx_buf == rx_buf (right?)
+	 * for MicroWire, one buffer must be null
+	 * buffers must work with dma_*map_single() calls
+	 */
+	const void	*tx_buf;
+	void		*rx_buf;
+	unsigned	len;
+
+	dma_addr_t	tx_dma;
+	dma_addr_t	rx_dma;
+
+	unsigned	cs_change:1;
+	u16		delay_usecs;
+};
+
+/**
+ * struct spi_message - one multi-segment SPI transaction
+ * @transfers: the segements of the transaction
+ * @n_transfer: how many segments
+ * @spi: SPI device to which the transaction is queued
+ * @is_dma_mapped: if true, the caller provided both dma and cpu virtual
+ *	addresses for each transfer buffer
+ * @complete: called to report transaction completions
+ * @context: the argument to complete() when it's called
+ * @actual_length: how many bytes were transferd
+ * @status: zero for success, else negative errno
+ * @queue: for use by whichever driver currently owns the message
+ * @state: for use by whichever driver currently owns the message
+ */
+struct spi_message {
+	struct spi_transfer	*transfers;
+	unsigned		n_transfer;
+
+	struct spi_device	*spi;
+
+	unsigned		is_dma_mapped:1;
+
+	/* REVISIT:  we might want a flag affecting the behavior of the
+	 * last transfer ... allowing things like "read 16 bit length L"
+	 * immediately followed by "read L bytes".  Basically imposing
+	 * a specific message scheduling algorithm.
+	 *
+	 * Some controller drivers (message-at-a-time queue processing)
+	 * could provide that as their default scheduling algorithm.  But
+	 * others (with multi-message pipelines) would need a flag to
+	 * tell them about such special cases.
+	 */
+
+	/* completion is reported through a callback */
+	void 			FASTCALL((*complete)(void *context));
+	void			*context;
+	unsigned		actual_length;
+	int			status;
+
+	/* for optional use by whatever driver currently owns the
+	 * spi_message ...  between calls to spi_async and then later
+	 * complete(), that's the spi_master controller driver.
+	 */
+	struct list_head	queue;
+	void			*state;
+};
+
+/**
+ * spi_setup -- setup SPI mode and clock rate
+ * @spi: the device whose settings are being modified
+ *
+ * SPI protocol drivers may need to update the transfer mode if the
+ * device doesn't work with the mode 0 default.  They may likewise need
+ * to update clock rates or word sizes from initial values.  This function
+ * changes those settings, and must be called from a context that can sleep.
+ */
+static inline int
+spi_setup(struct spi_device *spi)
+{
+	return spi->master->setup(spi);
+}
+
+
+/**
+ * spi_async -- asynchronous SPI transfer
+ * @spi: device with which data will be exchanged
+ * @message: describes the data transfers, including completion callback
+ *
+ * This call may be used in_irq and other contexts which can't sleep,
+ * as well as from task contexts which can sleep.
+ *
+ * The completion callback is invoked in a context which can't sleep.
+ * Before that invocation, the value of message->status is undefined.
+ * When the callback is issued, message->status holds either zero (to
+ * indicate complete success) or a negative error code.
+ *
+ * Note that although all messages to a spi_device are handled in
+ * FIFO order, messages may go to different devices in other orders.
+ * Some device might be higher priority, or have various "hard" access
+ * time requirements, for example.
+ */
+static inline int
+spi_async(struct spi_device *spi, struct spi_message *message)
+{
+	message->spi = spi;
+	return spi->master->transfer(spi, message);
+}
+
+/*---------------------------------------------------------------------------*/
+
+/* All these synchronous SPI transfer routines are utilities layered
+ * over the core async transfer primitive.  Here, "synchronous" means
+ * they will sleep uninterruptibly until the async transfer completes.
+ */
+
+extern int spi_sync(struct spi_device *spi, struct spi_message *message);
+
+/**
+ * spi_write - SPI synchronous write
+ * @spi: device to which data will be written
+ * @buf: data buffer
+ * @len: data buffer size
+ *
+ * This writes the buffer and returns zero or a negative error code.
+ * Callable only from contexts that can sleep.
+ */
+static inline int
+spi_write(struct spi_device *spi, const u8 *buf, size_t len)
+{
+	struct spi_transfer	t = {
+			.tx_buf		= buf,
+			.rx_buf		= NULL,
+			.len		= len,
+			.cs_change	= 0,
+		};
+	struct spi_message	m = {
+			.transfers	= &t,
+			.n_transfer	= 1,
+		};
+
+	return spi_sync(spi, &m);
+}
+
+/**
+ * spi_read - SPI synchronous read
+ * @spi: device from which data will be read
+ * @buf: data buffer
+ * @len: data buffer size
+ *
+ * This writes the buffer and returns zero or a negative error code.
+ * Callable only from contexts that can sleep.
+ */
+static inline int
+spi_read(struct spi_device *spi, u8 *buf, size_t len)
+{
+	struct spi_transfer	t = {
+			.tx_buf		= NULL,
+			.rx_buf		= buf,
+			.len		= len,
+			.cs_change	= 0,
+		};
+	struct spi_message	m = {
+			.transfers	= &t,
+			.n_transfer	= 1,
+		};
+
+	return spi_sync(spi, &m);
+}
+
+extern int spi_write_then_read(struct spi_device *spi,
+		const u8 *txbuf, unsigned n_tx,
+		u8 *rxbuf, unsigned n_rx);
+
+/**
+ * spi_w8r8 - SPI synchronous 8 bit write followed by 8 bit read
+ * @spi: device with which data will be exchanged
+ * @cmd: command to be written before data is read back
+ *
+ * This returns the (unsigned) eight bit number returned by the
+ * device, or else a negative error code.  Callable only from
+ * contexts that can sleep.
+ */
+static inline ssize_t spi_w8r8(struct spi_device *spi, u8 cmd)
+{
+	ssize_t			status;
+	u8			result;
+
+	status = spi_write_then_read(spi, &cmd, 1, &result, 1);
+
+	/* return negative errno or unsigned value */
+	return (status < 0) ? status : result;
+}
+
+/**
+ * spi_w8r16 - SPI synchronous 8 bit write followed by 16 bit read
+ * @spi: device with which data will be exchanged
+ * @cmd: command to be written before data is read back
+ *
+ * This returns the (unsigned) sixteen bit number returned by the
+ * device, or else a negative error code.  Callable only from
+ * contexts that can sleep.
+ *
+ * The number is returned in wire-order, which is at least sometimes
+ * big-endian.
+ */
+static inline ssize_t spi_w8r16(struct spi_device *spi, u8 cmd)
+{
+	ssize_t			status;
+	u16			result;
+
+	status = spi_write_then_read(spi, &cmd, 1, (u8 *) &result, 2);
+
+	/* return negative errno or unsigned value */
+	return (status < 0) ? status : result;
+}
+
+/*---------------------------------------------------------------------------*/
+
+/*
+ * INTERFACE between board init code and SPI infrastructure.
+ *
+ * No SPI driver ever sees these SPI device table segments, but
+ * it's how the SPI core (or adapters that get hotplugged) grows
+ * the driver model tree.
+ *
+ * As a rule, SPI devices can't be probed.  Instead, board init code
+ * provides a table listing the devices which are present, with enough
+ * information to bind and set up the device's driver.  There's basic
+ * support for nonstatic configurations too; enough to handle adding
+ * parport adapters, or microcontrollers acting as USB-to-SPI bridges.
+ */
+
+/* board-specific information about each SPI device */
+struct spi_board_info {
+	/* the device name and module name are coupled, like platform_bus;
+	 * "modalias" is normally the driver name.
+	 *
+	 * platform_data goes to spi_device.dev.platform_data,
+	 * controller_data goes to spi_device.platform_data,
+	 * irq is copied too
+	 */
+	char		modalias[KOBJ_NAME_LEN];
+	const void	*platform_data;
+	const void	*controller_data;
+	int		irq;
+
+	/* slower signaling on noisy or low voltage boards */
+	u32		max_speed_hz;
+
+
+	/* bus_num is board specific and matches the bus_num of some
+	 * spi_master that will probably be registered later.
+	 *
+	 * chip_select reflects how this chip is wired to that master;
+	 * it's less than num_chipselect.
+	 */
+	u16		bus_num;
+	u16		chip_select;
+
+	/* ... may need additional spi_device chip config data here.
+	 * avoid stuff protocol drivers can set; but include stuff
+	 * needed to behave without being bound to a driver:
+	 *  - chipselect polarity
+	 *  - quirks like clock rate mattering when not selected
+	 */
+};
+
+#ifdef	CONFIG_SPI
+extern int
+spi_register_board_info(struct spi_board_info const *info, unsigned n);
+#else
+/* board init code may ignore whether SPI is configured or not */
+static inline int
+spi_register_board_info(struct spi_board_info const *info, unsigned n)
+	{ return 0; }
+#endif
+
+
+/* If you're hotplugging an adapter with devices (parport, usb, etc)
+ * use spi_new_device() to describe each device.  You can also call
+ * spi_unregister_device() to get start making that device vanish,
+ * but normally that would be handled by spi_unregister_master().
+ */
+extern struct spi_device *
+spi_new_device(struct spi_master *, struct spi_board_info *);
+
+static inline void
+spi_unregister_device(struct spi_device *spi)
+{
+	if (spi)
+		device_unregister(&spi->dev);
+}
+
+#endif /* __LINUX_SPI_H */
