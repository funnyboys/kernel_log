commit b5881b153bc81d63a5a7e82a35e8a4bdbe1f8c73
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Wed Apr 10 21:18:28 2019 +0800

    spi: spi-mem: Make spi_mem_default_supports_op() static inline
    
    Stub helper spi_mem_default_supports_op() should
    be set to static inline
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi-mem.h b/include/linux/spi/spi-mem.h
index 1941b845aa15..af9ff2f0f1b2 100644
--- a/include/linux/spi/spi-mem.h
+++ b/include/linux/spi/spi-mem.h
@@ -315,6 +315,7 @@ spi_controller_dma_unmap_mem_op_data(struct spi_controller *ctlr,
 {
 }
 
+static inline
 bool spi_mem_default_supports_op(struct spi_mem *mem,
 				 const struct spi_mem_op *op)
 {

commit 72e6841608b9ce7e04515ed43693b2878936c93a
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Mon Apr 8 22:39:49 2019 +0800

    spi: spi-mem: Fix build error without CONFIG_SPI_MEM
    
    When building with CONFIG_SPI_MEM is not set
    gc warns this:
    
    drivers/spi/spi-zynq-qspi.o: In function `zynq_qspi_supports_op':
    spi-zynq-qspi.c:(.text+0x1da): undefined reference to `spi_mem_default_supports_op'
    
    Fixes: 67dca5e580f1 ("spi: spi-mem: Add support for Zynq QSPI controller")
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi-mem.h b/include/linux/spi/spi-mem.h
index c845cd6e22ba..1941b845aa15 100644
--- a/include/linux/spi/spi-mem.h
+++ b/include/linux/spi/spi-mem.h
@@ -295,6 +295,10 @@ int spi_controller_dma_map_mem_op_data(struct spi_controller *ctlr,
 void spi_controller_dma_unmap_mem_op_data(struct spi_controller *ctlr,
 					  const struct spi_mem_op *op,
 					  struct sg_table *sg);
+
+bool spi_mem_default_supports_op(struct spi_mem *mem,
+				 const struct spi_mem_op *op);
+
 #else
 static inline int
 spi_controller_dma_map_mem_op_data(struct spi_controller *ctlr,
@@ -310,6 +314,13 @@ spi_controller_dma_unmap_mem_op_data(struct spi_controller *ctlr,
 				     struct sg_table *sg)
 {
 }
+
+bool spi_mem_default_supports_op(struct spi_mem *mem,
+				 const struct spi_mem_op *op)
+{
+	return false;
+}
+
 #endif /* CONFIG_SPI_MEM */
 
 int spi_mem_adjust_op_size(struct spi_mem *mem, struct spi_mem_op *op);
@@ -341,9 +352,6 @@ int spi_mem_driver_register_with_owner(struct spi_mem_driver *drv,
 
 void spi_mem_driver_unregister(struct spi_mem_driver *drv);
 
-bool spi_mem_default_supports_op(struct spi_mem *mem,
-				 const struct spi_mem_op *op);
-
 #define spi_mem_driver_register(__drv)                                  \
 	spi_mem_driver_register_with_owner(__drv, THIS_MODULE)
 

commit 46109648052fe778c75f199d72255c899578d6f7
Author: Naga Sureshkumar Relli <naga.sureshkumar.relli@xilinx.com>
Date:   Mon Apr 1 13:29:00 2019 +0530

    spi: spi-mem: export spi_mem_default_supports_op()
    
    Export spi_mem_default_supports_op(), so that controller drivers
    can use this.
    spi-mem driver already exports this using EXPORT_SYMBOL,
    but not declared it in spi-mem.h.
    This patch declares spi_mem_default_supports_op() in spi-mem.h and
    also removes the static from the function prototype.
    
    Signed-off-by: Naga Sureshkumar Relli <naga.sureshkumar.relli@xilinx.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi-mem.h b/include/linux/spi/spi-mem.h
index 3703d0dcac2e..c845cd6e22ba 100644
--- a/include/linux/spi/spi-mem.h
+++ b/include/linux/spi/spi-mem.h
@@ -341,6 +341,9 @@ int spi_mem_driver_register_with_owner(struct spi_mem_driver *drv,
 
 void spi_mem_driver_unregister(struct spi_mem_driver *drv);
 
+bool spi_mem_default_supports_op(struct spi_mem *mem,
+				 const struct spi_mem_op *op);
+
 #define spi_mem_driver_register(__drv)                                  \
 	spi_mem_driver_register_with_owner(__drv, THIS_MODULE)
 

commit 1fc1b63638da1accb27264a507b23aa6863c3852
Author: Boris Brezillon <bbrezillon@kernel.org>
Date:   Sat Jan 19 16:04:12 2019 +0100

    spi: spi-mem: Add devm_spi_mem_dirmap_{create,destroy}()
    
    Since direct mapping descriptors usually the same lifetime as the SPI
    MEM device adding devm_ variants of the spi_mem_dirmap_{create,destroy}()
    should greatly simplify error/remove path of spi-mem drivers making use
    of the direct mapping API.
    
    Signed-off-by: Boris Brezillon <bbrezillon@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi-mem.h b/include/linux/spi/spi-mem.h
index 3fe24500c5ee..3703d0dcac2e 100644
--- a/include/linux/spi/spi-mem.h
+++ b/include/linux/spi/spi-mem.h
@@ -330,6 +330,11 @@ ssize_t spi_mem_dirmap_read(struct spi_mem_dirmap_desc *desc,
 			    u64 offs, size_t len, void *buf);
 ssize_t spi_mem_dirmap_write(struct spi_mem_dirmap_desc *desc,
 			     u64 offs, size_t len, const void *buf);
+struct spi_mem_dirmap_desc *
+devm_spi_mem_dirmap_create(struct device *dev, struct spi_mem *mem,
+			   const struct spi_mem_dirmap_info *info);
+void devm_spi_mem_dirmap_destroy(struct device *dev,
+				 struct spi_mem_dirmap_desc *desc);
 
 int spi_mem_driver_register_with_owner(struct spi_mem_driver *drv,
 				       struct module *owner);

commit aa167f3fed0c37e0e4c707d4331d827661f46644
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Tue Nov 6 17:05:33 2018 +0100

    spi: spi-mem: Add a new API to support direct mapping
    
    Most modern SPI controllers can directly map a SPI memory (or a portion
    of the SPI memory) in the CPU address space. Most of the time this
    brings significant performance improvements as it automates the whole
    process of sending SPI memory operations every time a new region is
    accessed.
    
    This new API allows SPI memory drivers to create direct mappings and
    then use them to access the memory instead of using spi_mem_exec_op().
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi-mem.h b/include/linux/spi/spi-mem.h
index 250b6f5c47c2..3fe24500c5ee 100644
--- a/include/linux/spi/spi-mem.h
+++ b/include/linux/spi/spi-mem.h
@@ -124,6 +124,49 @@ struct spi_mem_op {
 		.data = __data,					\
 	}
 
+/**
+ * struct spi_mem_dirmap_info - Direct mapping information
+ * @op_tmpl: operation template that should be used by the direct mapping when
+ *	     the memory device is accessed
+ * @offset: absolute offset this direct mapping is pointing to
+ * @length: length in byte of this direct mapping
+ *
+ * These information are used by the controller specific implementation to know
+ * the portion of memory that is directly mapped and the spi_mem_op that should
+ * be used to access the device.
+ * A direct mapping is only valid for one direction (read or write) and this
+ * direction is directly encoded in the ->op_tmpl.data.dir field.
+ */
+struct spi_mem_dirmap_info {
+	struct spi_mem_op op_tmpl;
+	u64 offset;
+	u64 length;
+};
+
+/**
+ * struct spi_mem_dirmap_desc - Direct mapping descriptor
+ * @mem: the SPI memory device this direct mapping is attached to
+ * @info: information passed at direct mapping creation time
+ * @nodirmap: set to 1 if the SPI controller does not implement
+ *	      ->mem_ops->dirmap_create() or when this function returned an
+ *	      error. If @nodirmap is true, all spi_mem_dirmap_{read,write}()
+ *	      calls will use spi_mem_exec_op() to access the memory. This is a
+ *	      degraded mode that allows spi_mem drivers to use the same code
+ *	      no matter whether the controller supports direct mapping or not
+ * @priv: field pointing to controller specific data
+ *
+ * Common part of a direct mapping descriptor. This object is created by
+ * spi_mem_dirmap_create() and controller implementation of ->create_dirmap()
+ * can create/attach direct mapping resources to the descriptor in the ->priv
+ * field.
+ */
+struct spi_mem_dirmap_desc {
+	struct spi_mem *mem;
+	struct spi_mem_dirmap_info info;
+	unsigned int nodirmap;
+	void *priv;
+};
+
 /**
  * struct spi_mem - describes a SPI memory device
  * @spi: the underlying SPI device
@@ -179,10 +222,32 @@ static inline void *spi_mem_get_drvdata(struct spi_mem *mem)
  *	      Note that if the implementation of this function allocates memory
  *	      dynamically, then it should do so with devm_xxx(), as we don't
  *	      have a ->free_name() function.
+ * @dirmap_create: create a direct mapping descriptor that can later be used to
+ *		   access the memory device. This method is optional
+ * @dirmap_destroy: destroy a memory descriptor previous created by
+ *		    ->dirmap_create()
+ * @dirmap_read: read data from the memory device using the direct mapping
+ *		 created by ->dirmap_create(). The function can return less
+ *		 data than requested (for example when the request is crossing
+ *		 the currently mapped area), and the caller of
+ *		 spi_mem_dirmap_read() is responsible for calling it again in
+ *		 this case.
+ * @dirmap_write: write data to the memory device using the direct mapping
+ *		  created by ->dirmap_create(). The function can return less
+ *		  data than requested (for example when the request is crossing
+ *		  the currently mapped area), and the caller of
+ *		  spi_mem_dirmap_write() is responsible for calling it again in
+ *		  this case.
  *
  * This interface should be implemented by SPI controllers providing an
  * high-level interface to execute SPI memory operation, which is usually the
  * case for QSPI controllers.
+ *
+ * Note on ->dirmap_{read,write}(): drivers should avoid accessing the direct
+ * mapping from the CPU because doing that can stall the CPU waiting for the
+ * SPI mem transaction to finish, and this will make real-time maintainers
+ * unhappy and might make your system less reactive. Instead, drivers should
+ * use DMA to access this direct mapping.
  */
 struct spi_controller_mem_ops {
 	int (*adjust_op_size)(struct spi_mem *mem, struct spi_mem_op *op);
@@ -191,6 +256,12 @@ struct spi_controller_mem_ops {
 	int (*exec_op)(struct spi_mem *mem,
 		       const struct spi_mem_op *op);
 	const char *(*get_name)(struct spi_mem *mem);
+	int (*dirmap_create)(struct spi_mem_dirmap_desc *desc);
+	void (*dirmap_destroy)(struct spi_mem_dirmap_desc *desc);
+	ssize_t (*dirmap_read)(struct spi_mem_dirmap_desc *desc,
+			       u64 offs, size_t len, void *buf);
+	ssize_t (*dirmap_write)(struct spi_mem_dirmap_desc *desc,
+				u64 offs, size_t len, const void *buf);
 };
 
 /**
@@ -251,6 +322,15 @@ int spi_mem_exec_op(struct spi_mem *mem,
 
 const char *spi_mem_get_name(struct spi_mem *mem);
 
+struct spi_mem_dirmap_desc *
+spi_mem_dirmap_create(struct spi_mem *mem,
+		      const struct spi_mem_dirmap_info *info);
+void spi_mem_dirmap_destroy(struct spi_mem_dirmap_desc *desc);
+ssize_t spi_mem_dirmap_read(struct spi_mem_dirmap_desc *desc,
+			    u64 offs, size_t len, void *buf);
+ssize_t spi_mem_dirmap_write(struct spi_mem_dirmap_desc *desc,
+			     u64 offs, size_t len, const void *buf);
+
 int spi_mem_driver_register_with_owner(struct spi_mem_driver *drv,
 				       struct module *owner);
 

commit 0ebb261a0b2d090de618a383d2378d4a00834958
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Tue Nov 6 17:05:31 2018 +0100

    spi: spi-mem: Add SPI_MEM_NO_DATA to the spi_mem_data_dir enum
    
    When defining spi_mem_op templates we don't necessarily know the size
    that will be passed when the template is actually used, and basing the
    supports_op() check on op->data.nbytes to know whether there will be
    data transferred for a specific operation is this not possible.
    
    Add SPI_MEM_NO_DATA to the spi_mem_data_dir enum so that we can base
    our checks on op->data.dir instead of op->data.nbytes.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi-mem.h b/include/linux/spi/spi-mem.h
index 867839cc69a7..250b6f5c47c2 100644
--- a/include/linux/spi/spi-mem.h
+++ b/include/linux/spi/spi-mem.h
@@ -57,10 +57,12 @@
 /**
  * enum spi_mem_data_dir - describes the direction of a SPI memory data
  *			   transfer from the controller perspective
+ * @SPI_MEM_NO_DATA: no data transferred
  * @SPI_MEM_DATA_IN: data coming from the SPI memory
  * @SPI_MEM_DATA_OUT: data sent to the SPI memory
  */
 enum spi_mem_data_dir {
+	SPI_MEM_NO_DATA,
 	SPI_MEM_DATA_IN,
 	SPI_MEM_DATA_OUT,
 };

commit 6afe76a6723975391d06c42a422370a588395f84
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Tue Nov 6 17:05:30 2018 +0100

    spi: spi-mem: Add missing word in the SPI_MEM_DATA_OUT description
    
    Missing 'to' in the SPI_MEM_DATA_OUT description.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi-mem.h b/include/linux/spi/spi-mem.h
index 69ee30456864..867839cc69a7 100644
--- a/include/linux/spi/spi-mem.h
+++ b/include/linux/spi/spi-mem.h
@@ -58,7 +58,7 @@
  * enum spi_mem_data_dir - describes the direction of a SPI memory data
  *			   transfer from the controller perspective
  * @SPI_MEM_DATA_IN: data coming from the SPI memory
- * @SPI_MEM_DATA_OUT: data sent the SPI memory
+ * @SPI_MEM_DATA_OUT: data sent to the SPI memory
  */
 enum spi_mem_data_dir {
 	SPI_MEM_DATA_IN,

commit 2f19e7a7e63a04f4bbaf327d9d0e69ac800b2b8f
Merge: 8f0566118e2d c949a8e8b43f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Sep 28 18:04:06 2018 -0700

    Merge tag 'spi-fix-v4.19-rc5' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi
    
    Mark writes:
      "spi: Fixes for v4.19
    
       Quite a few fixes for the Renesas drivers in here, plus a fix for the
       Tegra driver and some documentation fixes for the recently added
       spi-mem code.  The Tegra fix is relatively large but fairly
       straightforward and mechanical, it runs on probe so it's been
       reasonably well covered in -next testing."
    
    * tag 'spi-fix-v4.19-rc5' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi:
      spi: spi-mem: Move the DMA-able constraint doc to the kerneldoc header
      spi: spi-mem: Add missing description for data.nbytes field
      spi: rspi: Fix interrupted DMA transfers
      spi: rspi: Fix invalid SPI use during system suspend
      spi: sh-msiof: Fix handling of write value for SISTR register
      spi: sh-msiof: Fix invalid SPI use during system suspend
      spi: gpio: Fix copy-and-paste error
      spi: tegra20-slink: explicitly enable/disable clock

commit c949a8e8b43f2c75567269bcc9a50d704ae3c420
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Thu Sep 20 09:31:11 2018 +0200

    spi: spi-mem: Move the DMA-able constraint doc to the kerneldoc header
    
    We'd better have that documented in the kerneldoc header, so that it's
    exposed to the doc generated by Sphinx.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi-mem.h b/include/linux/spi/spi-mem.h
index 0cfbb1ad8d96..7195fbc234aa 100644
--- a/include/linux/spi/spi-mem.h
+++ b/include/linux/spi/spi-mem.h
@@ -81,8 +81,8 @@ enum spi_mem_data_dir {
  * @data.dir: direction of the transfer
  * @data.nbytes: number of data bytes to send/receive. Can be zero if the
  *		 operation does not involve transferring data
- * @data.buf.in: input buffer
- * @data.buf.out: output buffer
+ * @data.buf.in: input buffer (must be DMA-able)
+ * @data.buf.out: output buffer (must be DMA-able)
  */
 struct spi_mem_op {
 	struct {
@@ -105,7 +105,6 @@ struct spi_mem_op {
 		u8 buswidth;
 		enum spi_mem_data_dir dir;
 		unsigned int nbytes;
-		/* buf.{in,out} must be DMA-able. */
 		union {
 			void *in;
 			const void *out;

commit 60489f085574157c343fc62a32f997fe7346a659
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Thu Sep 20 09:31:10 2018 +0200

    spi: spi-mem: Add missing description for data.nbytes field
    
    Add a description for spi_mem_op.data.nbytes to the kerneldoc header.
    
    Fixes: c36ff266dc82 ("spi: Extend the core to ease integration of SPI memory controllers")
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi-mem.h b/include/linux/spi/spi-mem.h
index 62722fb7472d..0cfbb1ad8d96 100644
--- a/include/linux/spi/spi-mem.h
+++ b/include/linux/spi/spi-mem.h
@@ -79,6 +79,8 @@ enum spi_mem_data_dir {
  * @dummy.buswidth: number of IO lanes used to transmit the dummy bytes
  * @data.buswidth: number of IO lanes used to send/receive the data
  * @data.dir: direction of the transfer
+ * @data.nbytes: number of data bytes to send/receive. Can be zero if the
+ *		 operation does not involve transferring data
  * @data.buf.in: input buffer
  * @data.buf.out: output buffer
  */

commit 010b0e708e08727d38b82accb21832b63fe2c250
Merge: 792adb90fa72 c1acb21b32a3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 14 12:01:08 2018 -0700

    Merge tag 'spi-v4.19' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi
    
    Pull spi updates from Mark Brown:
     "Quite an active release for the SPI subsystem, lots of small updates
      and fixes scattered about with highlights including:
    
       - 3-wire support in the GPIO driver.
    
       - support for setting a custom memory name in the memory mapped flash
         drivers.
    
       - support for extended mode in the Freescale DSPI controller.
    
       - support for the non-standard integration with the Microsemi Ocelot
         platform in the DesignWare driver.
    
       - new driver for the SocioNext UniPhier"
    
    * tag 'spi-v4.19' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi: (47 commits)
      spi: davinci: fix a NULL pointer dereference
      spi: spi-mem: Constify spi_mem->name
      mtd: m25p80: Call spi_mem_get_name() to let controller set a custom name
      spi: spi-mem: Extend the SPI mem interface to set a custom memory name
      spi: spi-mem: Fix a typo in the documentation of struct spi_mem
      spi: uniphier: remove unnecessary include headers
      spi: spi-gpio: add SPI_3WIRE support
      spi: add flags parameter to txrx_word function pointers
      spi: add SPI controller driver for UniPhier SoC
      spi: add DT bindings for UniPhier SPI controller
      spi: dw: document Microsemi integration
      spi: img-spfi: Set device select bits for SPFI port state
      spi: omap2-mcspi: remove several redundant variables
      spi: dw-mmio: add MSCC Ocelot support
      spi: dw: export dw_spi_set_cs
      spi: spi-fsl-espi: Log fifo counters on error
      spi: imx: Use the longuest possible burst size when in dynamic_burst
      spi: imx: remove unnecessary check in spi_imx_can_dma
      spi: imx: Use correct number of bytes per words
      spi: imx: Use dynamic bursts only when bits_per_word is 8, 16 or 32
      ...

commit 401c0d7712eb3189023efc9c0708a2ac984ed62e
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Fri Aug 3 11:50:39 2018 +0200

    spi: spi-mem: Constify spi_mem->name
    
    There is no reason to make spi_mem->name modifiable. Moreover,
    spi_mem_ops->get_name() returns a const char *, which generates a gcc
    warning when assigning the value returned by spi_mem_ops->get_name()
    to spi_mem->name.
    
    Fixes: 5d27a9c8ea9e ("spi: spi-mem: Extend the SPI mem interface to set a custom memory name")
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi-mem.h b/include/linux/spi/spi-mem.h
index 0d64ccc4e584..62722fb7472d 100644
--- a/include/linux/spi/spi-mem.h
+++ b/include/linux/spi/spi-mem.h
@@ -134,7 +134,7 @@ struct spi_mem_op {
 struct spi_mem {
 	struct spi_device *spi;
 	void *drvpriv;
-	char *name;
+	const char *name;
 };
 
 /**

commit 5d27a9c8ea9e967d00b92a76d4bb242bf7692f2b
Author: Frieder Schrempf <frieder.schrempf@exceet.de>
Date:   Thu Aug 2 14:53:53 2018 +0200

    spi: spi-mem: Extend the SPI mem interface to set a custom memory name
    
    When porting (Q)SPI controller drivers from the MTD layer to the SPI
    layer, the naming scheme for the memory devices changes. To be able
    to keep compatibility with the old drivers naming scheme, a name
    field is added to struct spi_mem and a hook is added to let controller
    drivers set a custom name for the memory device.
    
    Example for the FSL QSPI driver:
    
    Name with the old driver: 21e0000.qspi,
    or with multiple devices: 21e0000.qspi-0, 21e0000.qspi-1, ...
    
    Name with the new driver without spi_mem_get_name: spi4.0
    
    Suggested-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Signed-off-by: Frieder Schrempf <frieder.schrempf@exceet.de>
    Reviewed-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi-mem.h b/include/linux/spi/spi-mem.h
index 951a2e949d5f..0d64ccc4e584 100644
--- a/include/linux/spi/spi-mem.h
+++ b/include/linux/spi/spi-mem.h
@@ -123,6 +123,7 @@ struct spi_mem_op {
  * struct spi_mem - describes a SPI memory device
  * @spi: the underlying SPI device
  * @drvpriv: spi_mem_driver private data
+ * @name: name of the SPI memory device
  *
  * Extra information that describe the SPI memory device and may be needed by
  * the controller to properly handle this device should be placed here.
@@ -133,6 +134,7 @@ struct spi_mem_op {
 struct spi_mem {
 	struct spi_device *spi;
 	void *drvpriv;
+	char *name;
 };
 
 /**
@@ -165,6 +167,13 @@ static inline void *spi_mem_get_drvdata(struct spi_mem *mem)
  *		    limitations)
  * @supports_op: check if an operation is supported by the controller
  * @exec_op: execute a SPI memory operation
+ * @get_name: get a custom name for the SPI mem device from the controller.
+ *	      This might be needed if the controller driver has been ported
+ *	      to use the SPI mem layer and a custom name is used to keep
+ *	      mtdparts compatible.
+ *	      Note that if the implementation of this function allocates memory
+ *	      dynamically, then it should do so with devm_xxx(), as we don't
+ *	      have a ->free_name() function.
  *
  * This interface should be implemented by SPI controllers providing an
  * high-level interface to execute SPI memory operation, which is usually the
@@ -176,6 +185,7 @@ struct spi_controller_mem_ops {
 			    const struct spi_mem_op *op);
 	int (*exec_op)(struct spi_mem *mem,
 		       const struct spi_mem_op *op);
+	const char *(*get_name)(struct spi_mem *mem);
 };
 
 /**
@@ -234,6 +244,8 @@ bool spi_mem_supports_op(struct spi_mem *mem,
 int spi_mem_exec_op(struct spi_mem *mem,
 		    const struct spi_mem_op *op);
 
+const char *spi_mem_get_name(struct spi_mem *mem);
+
 int spi_mem_driver_register_with_owner(struct spi_mem_driver *drv,
 				       struct module *owner);
 

commit 06bcb5168d7d49aa3ed449ff13a6d13c30afc3f0
Author: Frieder Schrempf <frieder.schrempf@exceet.de>
Date:   Thu Aug 2 14:53:52 2018 +0200

    spi: spi-mem: Fix a typo in the documentation of struct spi_mem
    
    Fix a typo in the @drvpriv description.
    
    Signed-off-by: Frieder Schrempf <frieder.schrempf@exceet.de>
    Acked-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi-mem.h b/include/linux/spi/spi-mem.h
index bb4bd15ae1f6..951a2e949d5f 100644
--- a/include/linux/spi/spi-mem.h
+++ b/include/linux/spi/spi-mem.h
@@ -122,7 +122,7 @@ struct spi_mem_op {
 /**
  * struct spi_mem - describes a SPI memory device
  * @spi: the underlying SPI device
- * @drvpriv: spi_mem_drviver private data
+ * @drvpriv: spi_mem_driver private data
  *
  * Extra information that describe the SPI memory device and may be needed by
  * the controller to properly handle this device should be placed here.

commit 7529df4652482c33ae1a99ee8189401146f13cb7
Author: Peter Pan <peterpandong@micron.com>
Date:   Fri Jun 22 14:28:23 2018 +0200

    mtd: nand: Add core infrastructure to support SPI NANDs
    
    Add a SPI NAND framework based on the generic NAND framework and the
    spi-mem infrastructure.
    
    In its current state, this framework supports the following features:
    
    - single/dual/quad IO modes
    - on-die ECC
    
    Signed-off-by: Peter Pan <peterpandong@micron.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>

diff --git a/include/linux/spi/spi-mem.h b/include/linux/spi/spi-mem.h
index bb4bd15ae1f6..4fa34a227a0f 100644
--- a/include/linux/spi/spi-mem.h
+++ b/include/linux/spi/spi-mem.h
@@ -3,7 +3,9 @@
  * Copyright (C) 2018 Exceet Electronics GmbH
  * Copyright (C) 2018 Bootlin
  *
- * Author: Boris Brezillon <boris.brezillon@bootlin.com>
+ * Author:
+ *	Peter Pan <peterpandong@micron.com>
+ *	Boris Brezillon <boris.brezillon@bootlin.com>
  */
 
 #ifndef __LINUX_SPI_MEM_H

commit c36ff266dc82f4ae797a6f3513c6ffa344f7f1c7
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Thu Apr 26 18:18:14 2018 +0200

    spi: Extend the core to ease integration of SPI memory controllers
    
    Some controllers are exposing high-level interfaces to access various
    kind of SPI memories. Unfortunately they do not fit in the current
    spi_controller model and usually have drivers placed in
    drivers/mtd/spi-nor which are only supporting SPI NORs and not SPI
    memories in general.
    
    This is an attempt at defining a SPI memory interface which works for
    all kinds of SPI memories (NORs, NANDs, SRAMs).
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Frieder Schrempf <frieder.schrempf@exceet.de>
    Tested-by: Frieder Schrempf <frieder.schrempf@exceet.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/linux/spi/spi-mem.h b/include/linux/spi/spi-mem.h
new file mode 100644
index 000000000000..bb4bd15ae1f6
--- /dev/null
+++ b/include/linux/spi/spi-mem.h
@@ -0,0 +1,249 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2018 Exceet Electronics GmbH
+ * Copyright (C) 2018 Bootlin
+ *
+ * Author: Boris Brezillon <boris.brezillon@bootlin.com>
+ */
+
+#ifndef __LINUX_SPI_MEM_H
+#define __LINUX_SPI_MEM_H
+
+#include <linux/spi/spi.h>
+
+#define SPI_MEM_OP_CMD(__opcode, __buswidth)			\
+	{							\
+		.buswidth = __buswidth,				\
+		.opcode = __opcode,				\
+	}
+
+#define SPI_MEM_OP_ADDR(__nbytes, __val, __buswidth)		\
+	{							\
+		.nbytes = __nbytes,				\
+		.val = __val,					\
+		.buswidth = __buswidth,				\
+	}
+
+#define SPI_MEM_OP_NO_ADDR	{ }
+
+#define SPI_MEM_OP_DUMMY(__nbytes, __buswidth)			\
+	{							\
+		.nbytes = __nbytes,				\
+		.buswidth = __buswidth,				\
+	}
+
+#define SPI_MEM_OP_NO_DUMMY	{ }
+
+#define SPI_MEM_OP_DATA_IN(__nbytes, __buf, __buswidth)		\
+	{							\
+		.dir = SPI_MEM_DATA_IN,				\
+		.nbytes = __nbytes,				\
+		.buf.in = __buf,				\
+		.buswidth = __buswidth,				\
+	}
+
+#define SPI_MEM_OP_DATA_OUT(__nbytes, __buf, __buswidth)	\
+	{							\
+		.dir = SPI_MEM_DATA_OUT,			\
+		.nbytes = __nbytes,				\
+		.buf.out = __buf,				\
+		.buswidth = __buswidth,				\
+	}
+
+#define SPI_MEM_OP_NO_DATA	{ }
+
+/**
+ * enum spi_mem_data_dir - describes the direction of a SPI memory data
+ *			   transfer from the controller perspective
+ * @SPI_MEM_DATA_IN: data coming from the SPI memory
+ * @SPI_MEM_DATA_OUT: data sent the SPI memory
+ */
+enum spi_mem_data_dir {
+	SPI_MEM_DATA_IN,
+	SPI_MEM_DATA_OUT,
+};
+
+/**
+ * struct spi_mem_op - describes a SPI memory operation
+ * @cmd.buswidth: number of IO lines used to transmit the command
+ * @cmd.opcode: operation opcode
+ * @addr.nbytes: number of address bytes to send. Can be zero if the operation
+ *		 does not need to send an address
+ * @addr.buswidth: number of IO lines used to transmit the address cycles
+ * @addr.val: address value. This value is always sent MSB first on the bus.
+ *	      Note that only @addr.nbytes are taken into account in this
+ *	      address value, so users should make sure the value fits in the
+ *	      assigned number of bytes.
+ * @dummy.nbytes: number of dummy bytes to send after an opcode or address. Can
+ *		  be zero if the operation does not require dummy bytes
+ * @dummy.buswidth: number of IO lanes used to transmit the dummy bytes
+ * @data.buswidth: number of IO lanes used to send/receive the data
+ * @data.dir: direction of the transfer
+ * @data.buf.in: input buffer
+ * @data.buf.out: output buffer
+ */
+struct spi_mem_op {
+	struct {
+		u8 buswidth;
+		u8 opcode;
+	} cmd;
+
+	struct {
+		u8 nbytes;
+		u8 buswidth;
+		u64 val;
+	} addr;
+
+	struct {
+		u8 nbytes;
+		u8 buswidth;
+	} dummy;
+
+	struct {
+		u8 buswidth;
+		enum spi_mem_data_dir dir;
+		unsigned int nbytes;
+		/* buf.{in,out} must be DMA-able. */
+		union {
+			void *in;
+			const void *out;
+		} buf;
+	} data;
+};
+
+#define SPI_MEM_OP(__cmd, __addr, __dummy, __data)		\
+	{							\
+		.cmd = __cmd,					\
+		.addr = __addr,					\
+		.dummy = __dummy,				\
+		.data = __data,					\
+	}
+
+/**
+ * struct spi_mem - describes a SPI memory device
+ * @spi: the underlying SPI device
+ * @drvpriv: spi_mem_drviver private data
+ *
+ * Extra information that describe the SPI memory device and may be needed by
+ * the controller to properly handle this device should be placed here.
+ *
+ * One example would be the device size since some controller expose their SPI
+ * mem devices through a io-mapped region.
+ */
+struct spi_mem {
+	struct spi_device *spi;
+	void *drvpriv;
+};
+
+/**
+ * struct spi_mem_set_drvdata() - attach driver private data to a SPI mem
+ *				  device
+ * @mem: memory device
+ * @data: data to attach to the memory device
+ */
+static inline void spi_mem_set_drvdata(struct spi_mem *mem, void *data)
+{
+	mem->drvpriv = data;
+}
+
+/**
+ * struct spi_mem_get_drvdata() - get driver private data attached to a SPI mem
+ *				  device
+ * @mem: memory device
+ *
+ * Return: the data attached to the mem device.
+ */
+static inline void *spi_mem_get_drvdata(struct spi_mem *mem)
+{
+	return mem->drvpriv;
+}
+
+/**
+ * struct spi_controller_mem_ops - SPI memory operations
+ * @adjust_op_size: shrink the data xfer of an operation to match controller's
+ *		    limitations (can be alignment of max RX/TX size
+ *		    limitations)
+ * @supports_op: check if an operation is supported by the controller
+ * @exec_op: execute a SPI memory operation
+ *
+ * This interface should be implemented by SPI controllers providing an
+ * high-level interface to execute SPI memory operation, which is usually the
+ * case for QSPI controllers.
+ */
+struct spi_controller_mem_ops {
+	int (*adjust_op_size)(struct spi_mem *mem, struct spi_mem_op *op);
+	bool (*supports_op)(struct spi_mem *mem,
+			    const struct spi_mem_op *op);
+	int (*exec_op)(struct spi_mem *mem,
+		       const struct spi_mem_op *op);
+};
+
+/**
+ * struct spi_mem_driver - SPI memory driver
+ * @spidrv: inherit from a SPI driver
+ * @probe: probe a SPI memory. Usually where detection/initialization takes
+ *	   place
+ * @remove: remove a SPI memory
+ * @shutdown: take appropriate action when the system is shutdown
+ *
+ * This is just a thin wrapper around a spi_driver. The core takes care of
+ * allocating the spi_mem object and forwarding the probe/remove/shutdown
+ * request to the spi_mem_driver. The reason we use this wrapper is because
+ * we might have to stuff more information into the spi_mem struct to let
+ * SPI controllers know more about the SPI memory they interact with, and
+ * having this intermediate layer allows us to do that without adding more
+ * useless fields to the spi_device object.
+ */
+struct spi_mem_driver {
+	struct spi_driver spidrv;
+	int (*probe)(struct spi_mem *mem);
+	int (*remove)(struct spi_mem *mem);
+	void (*shutdown)(struct spi_mem *mem);
+};
+
+#if IS_ENABLED(CONFIG_SPI_MEM)
+int spi_controller_dma_map_mem_op_data(struct spi_controller *ctlr,
+				       const struct spi_mem_op *op,
+				       struct sg_table *sg);
+
+void spi_controller_dma_unmap_mem_op_data(struct spi_controller *ctlr,
+					  const struct spi_mem_op *op,
+					  struct sg_table *sg);
+#else
+static inline int
+spi_controller_dma_map_mem_op_data(struct spi_controller *ctlr,
+				   const struct spi_mem_op *op,
+				   struct sg_table *sg)
+{
+	return -ENOTSUPP;
+}
+
+static inline void
+spi_controller_dma_unmap_mem_op_data(struct spi_controller *ctlr,
+				     const struct spi_mem_op *op,
+				     struct sg_table *sg)
+{
+}
+#endif /* CONFIG_SPI_MEM */
+
+int spi_mem_adjust_op_size(struct spi_mem *mem, struct spi_mem_op *op);
+
+bool spi_mem_supports_op(struct spi_mem *mem,
+			 const struct spi_mem_op *op);
+
+int spi_mem_exec_op(struct spi_mem *mem,
+		    const struct spi_mem_op *op);
+
+int spi_mem_driver_register_with_owner(struct spi_mem_driver *drv,
+				       struct module *owner);
+
+void spi_mem_driver_unregister(struct spi_mem_driver *drv);
+
+#define spi_mem_driver_register(__drv)                                  \
+	spi_mem_driver_register_with_owner(__drv, THIS_MODULE)
+
+#define module_spi_mem_driver(__drv)                                    \
+	module_driver(__drv, spi_mem_driver_register,                   \
+		      spi_mem_driver_unregister)
+
+#endif /* __LINUX_SPI_MEM_H */
