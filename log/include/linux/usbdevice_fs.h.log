commit 6bc3f3979edce0b11deb685a4c817abb7d74b227
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Feb 20 07:20:17 2020 -0600

    USB: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Link: https://lore.kernel.org/r/20200220132017.GA29262@embeddedor
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index 79aab0065ec8..14ea197ce37f 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -69,7 +69,7 @@ struct usbdevfs_urb32 {
 	compat_int_t error_count;
 	compat_uint_t signr;
 	compat_caddr_t usercontext; /* unused */
-	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
+	struct usbdevfs_iso_packet_desc iso_frame_desc[];
 };
 
 struct usbdevfs_ioctl32 {

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index 04a26285416c..79aab0065ec8 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*****************************************************************************/
 
 /*

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index 4abe28e41cbc..04a26285416c 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -25,126 +25,11 @@
  */
 
 /*****************************************************************************/
-
 #ifndef _LINUX_USBDEVICE_FS_H
 #define _LINUX_USBDEVICE_FS_H
 
-#include <linux/types.h>
-#include <linux/magic.h>
-
-/* --------------------------------------------------------------------- */
-
-/* usbdevfs ioctl codes */
-
-struct usbdevfs_ctrltransfer {
-	__u8 bRequestType;
-	__u8 bRequest;
-	__u16 wValue;
-	__u16 wIndex;
-	__u16 wLength;
-	__u32 timeout;  /* in milliseconds */
- 	void __user *data;
-};
-
-struct usbdevfs_bulktransfer {
-	unsigned int ep;
-	unsigned int len;
-	unsigned int timeout; /* in milliseconds */
-	void __user *data;
-};
-
-struct usbdevfs_setinterface {
-	unsigned int interface;
-	unsigned int altsetting;
-};
-
-struct usbdevfs_disconnectsignal {
-	unsigned int signr;
-	void __user *context;
-};
-
-#define USBDEVFS_MAXDRIVERNAME 255
-
-struct usbdevfs_getdriver {
-	unsigned int interface;
-	char driver[USBDEVFS_MAXDRIVERNAME + 1];
-};
-
-struct usbdevfs_connectinfo {
-	unsigned int devnum;
-	unsigned char slow;
-};
-
-#define USBDEVFS_URB_SHORT_NOT_OK	0x01
-#define USBDEVFS_URB_ISO_ASAP		0x02
-#define USBDEVFS_URB_BULK_CONTINUATION	0x04
-#define USBDEVFS_URB_NO_FSBR		0x20
-#define USBDEVFS_URB_ZERO_PACKET	0x40
-#define USBDEVFS_URB_NO_INTERRUPT	0x80
-
-#define USBDEVFS_URB_TYPE_ISO		   0
-#define USBDEVFS_URB_TYPE_INTERRUPT	   1
-#define USBDEVFS_URB_TYPE_CONTROL	   2
-#define USBDEVFS_URB_TYPE_BULK		   3
+#include <uapi/linux/usbdevice_fs.h>
 
-struct usbdevfs_iso_packet_desc {
-	unsigned int length;
-	unsigned int actual_length;
-	unsigned int status;
-};
-
-struct usbdevfs_urb {
-	unsigned char type;
-	unsigned char endpoint;
-	int status;
-	unsigned int flags;
-	void __user *buffer;
-	int buffer_length;
-	int actual_length;
-	int start_frame;
-	int number_of_packets;
-	int error_count;
-	unsigned int signr;	/* signal to be sent on completion,
-				  or 0 if none should be sent. */
-	void __user *usercontext;
-	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
-};
-
-/* ioctls for talking directly to drivers */
-struct usbdevfs_ioctl {
-	int	ifno;		/* interface 0..N ; negative numbers reserved */
-	int	ioctl_code;	/* MUST encode size + direction of data so the
-				 * macros in <asm/ioctl.h> give correct values */
-	void __user *data;	/* param buffer (in, or out) */
-};
-
-/* You can do most things with hubs just through control messages,
- * except find out what device connects to what port. */
-struct usbdevfs_hub_portinfo {
-	char nports;		/* number of downstream ports in this hub */
-	char port [127];	/* e.g. port 3 connects to device 27 */
-};
-
-/* Device capability flags */
-#define USBDEVFS_CAP_ZERO_PACKET		0x01
-#define USBDEVFS_CAP_BULK_CONTINUATION		0x02
-#define USBDEVFS_CAP_NO_PACKET_SIZE_LIM		0x04
-#define USBDEVFS_CAP_BULK_SCATTER_GATHER	0x08
-
-/* USBDEVFS_DISCONNECT_CLAIM flags & struct */
-
-/* disconnect-and-claim if the driver matches the driver field */
-#define USBDEVFS_DISCONNECT_CLAIM_IF_DRIVER	0x01
-/* disconnect-and-claim except when the driver matches the driver field */
-#define USBDEVFS_DISCONNECT_CLAIM_EXCEPT_DRIVER	0x02
-
-struct usbdevfs_disconnect_claim {
-	unsigned int interface;
-	unsigned int flags;
-	char driver[USBDEVFS_MAXDRIVERNAME + 1];
-};
-
-#ifdef __KERNEL__
 #ifdef CONFIG_COMPAT
 #include <linux/compat.h>
 
@@ -192,38 +77,4 @@ struct usbdevfs_ioctl32 {
 	compat_caddr_t data;
 };
 #endif
-#endif /* __KERNEL__ */
-
-#define USBDEVFS_CONTROL           _IOWR('U', 0, struct usbdevfs_ctrltransfer)
-#define USBDEVFS_CONTROL32           _IOWR('U', 0, struct usbdevfs_ctrltransfer32)
-#define USBDEVFS_BULK              _IOWR('U', 2, struct usbdevfs_bulktransfer)
-#define USBDEVFS_BULK32              _IOWR('U', 2, struct usbdevfs_bulktransfer32)
-#define USBDEVFS_RESETEP           _IOR('U', 3, unsigned int)
-#define USBDEVFS_SETINTERFACE      _IOR('U', 4, struct usbdevfs_setinterface)
-#define USBDEVFS_SETCONFIGURATION  _IOR('U', 5, unsigned int)
-#define USBDEVFS_GETDRIVER         _IOW('U', 8, struct usbdevfs_getdriver)
-#define USBDEVFS_SUBMITURB         _IOR('U', 10, struct usbdevfs_urb)
-#define USBDEVFS_SUBMITURB32       _IOR('U', 10, struct usbdevfs_urb32)
-#define USBDEVFS_DISCARDURB        _IO('U', 11)
-#define USBDEVFS_REAPURB           _IOW('U', 12, void *)
-#define USBDEVFS_REAPURB32         _IOW('U', 12, __u32)
-#define USBDEVFS_REAPURBNDELAY     _IOW('U', 13, void *)
-#define USBDEVFS_REAPURBNDELAY32   _IOW('U', 13, __u32)
-#define USBDEVFS_DISCSIGNAL        _IOR('U', 14, struct usbdevfs_disconnectsignal)
-#define USBDEVFS_DISCSIGNAL32      _IOR('U', 14, struct usbdevfs_disconnectsignal32)
-#define USBDEVFS_CLAIMINTERFACE    _IOR('U', 15, unsigned int)
-#define USBDEVFS_RELEASEINTERFACE  _IOR('U', 16, unsigned int)
-#define USBDEVFS_CONNECTINFO       _IOW('U', 17, struct usbdevfs_connectinfo)
-#define USBDEVFS_IOCTL             _IOWR('U', 18, struct usbdevfs_ioctl)
-#define USBDEVFS_IOCTL32           _IOWR('U', 18, struct usbdevfs_ioctl32)
-#define USBDEVFS_HUB_PORTINFO      _IOR('U', 19, struct usbdevfs_hub_portinfo)
-#define USBDEVFS_RESET             _IO('U', 20)
-#define USBDEVFS_CLEAR_HALT        _IOR('U', 21, unsigned int)
-#define USBDEVFS_DISCONNECT        _IO('U', 22)
-#define USBDEVFS_CONNECT           _IO('U', 23)
-#define USBDEVFS_CLAIM_PORT        _IOR('U', 24, unsigned int)
-#define USBDEVFS_RELEASE_PORT      _IOR('U', 25, unsigned int)
-#define USBDEVFS_GET_CAPABILITIES  _IOR('U', 26, __u32)
-#define USBDEVFS_DISCONNECT_CLAIM  _IOR('U', 27, struct usbdevfs_disconnect_claim)
-
 #endif /* _LINUX_USBDEVICE_FS_H */

commit 0837e7e5270bd5547ba5763f11611dc43f677b3d
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Sep 8 20:02:05 2012 +0200

    usbfs: Add a new disconnect-and-claim ioctl (v2)
    
    Apps which deal with devices which also have a kernel driver, need to do
    the following:
    1) Check which driver is attached, so as to not detach the wrong driver
       (ie detaching usbfs while another instance of the app is using the device)
    2) Detach the kernel driver
    3) Claim the interface
    
    Where moving from one step to the next for both 1-2 and 2-3 consists of
    a (small) race window. So currently such apps are racy and people just live
    with it.
    
    This patch adds a new ioctl which makes it possible for apps to do this
    in a race free manner. For flexibility apps can choose to:
    1) Specify the driver to disconnect
    2) Specify to disconnect any driver except for the one named by the app
    3) Disconnect any driver
    
    Note that if there is no driver attached, the ioctl will just act like the
    regular claim-interface ioctl, this is by design, as returning an error for
    this condition would open a new bag of race-conditions.
    
    Changes in v2:
    -Fix indentation of if blocks where the condition spans multiple lines
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index 3b74666be027..4abe28e41cbc 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -131,6 +131,19 @@ struct usbdevfs_hub_portinfo {
 #define USBDEVFS_CAP_NO_PACKET_SIZE_LIM		0x04
 #define USBDEVFS_CAP_BULK_SCATTER_GATHER	0x08
 
+/* USBDEVFS_DISCONNECT_CLAIM flags & struct */
+
+/* disconnect-and-claim if the driver matches the driver field */
+#define USBDEVFS_DISCONNECT_CLAIM_IF_DRIVER	0x01
+/* disconnect-and-claim except when the driver matches the driver field */
+#define USBDEVFS_DISCONNECT_CLAIM_EXCEPT_DRIVER	0x02
+
+struct usbdevfs_disconnect_claim {
+	unsigned int interface;
+	unsigned int flags;
+	char driver[USBDEVFS_MAXDRIVERNAME + 1];
+};
+
 #ifdef __KERNEL__
 #ifdef CONFIG_COMPAT
 #include <linux/compat.h>
@@ -211,5 +224,6 @@ struct usbdevfs_ioctl32 {
 #define USBDEVFS_CLAIM_PORT        _IOR('U', 24, unsigned int)
 #define USBDEVFS_RELEASE_PORT      _IOR('U', 25, unsigned int)
 #define USBDEVFS_GET_CAPABILITIES  _IOR('U', 26, __u32)
+#define USBDEVFS_DISCONNECT_CLAIM  _IOR('U', 27, struct usbdevfs_disconnect_claim)
 
 #endif /* _LINUX_USBDEVICE_FS_H */

commit 3d97ff63f8997761f12c8fbe8082996c6eeaba1a
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Jul 4 09:18:03 2012 +0200

    usbdevfs: Use scatter-gather lists for large bulk transfers
    
    When using urb->transfer_buffer we need to allocate physical contiguous buffers
    for the entire transfer, which is pretty much guaranteed to fail with large
    transfers.
    
    Currently userspace works around this by breaking large transfers into multiple
    urbs. For large bulk transfers this leads to all kind of complications.
    
    This patch makes it possible for userspace to reliable submit large bulk
    transfers to scatter-gather capable host controllers in one go, by using a
    scatterlist to break the transfer up in managable chunks.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index 07b2ceaaad70..3b74666be027 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -129,6 +129,7 @@ struct usbdevfs_hub_portinfo {
 #define USBDEVFS_CAP_ZERO_PACKET		0x01
 #define USBDEVFS_CAP_BULK_CONTINUATION		0x02
 #define USBDEVFS_CAP_NO_PACKET_SIZE_LIM		0x04
+#define USBDEVFS_CAP_BULK_SCATTER_GATHER	0x08
 
 #ifdef __KERNEL__
 #ifdef CONFIG_COMPAT

commit 19181bc50e1b8e92a7a3b3d78637c6dc5c0b5a1b
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Jul 4 09:18:02 2012 +0200

    usbdevfs: Add a USBDEVFS_GET_CAPABILITIES ioctl
    
    There are a few (new) usbdevfs capabilities which an application cannot
    discover in any other way then checking the kernel version. There are 3
    problems with this:
    1) It is just not very pretty.
    2) Given the tendency of enterprise distros to backport stuff it is not
    reliable.
    3) As discussed in length on the mailinglist, USBDEVFS_URB_BULK_CONTINUATION
    does not work as it should when combined with USBDEVFS_URB_SHORT_NOT_OK
    (which is its intended use) on devices attached to an XHCI controller.
    So the availability of these features can be host controller dependent,
    making depending on them based on the kernel version not a good idea.
    
    This patch besides adding the new ioctl also adds flags for the following
    existing capabilities:
    
    USBDEVFS_CAP_ZERO_PACKET,        available since 2.6.31
    USBDEVFS_CAP_BULK_CONTINUATION,  available since 2.6.32, except for XHCI
    USBDEVFS_CAP_NO_PACKET_SIZE_LIM, available since 3.3
    
    Note that this patch only does not advertise the USBDEVFS_URB_BULK_CONTINUATION
    cap for XHCI controllers, bulk transfers with this flag set will still be
    accepted when submitted to XHCI controllers.
    
    Returning -EINVAL for them would break existing apps, and in most cases the
    troublesome scenario wrt USBDEVFS_URB_SHORT_NOT_OK urbs on XHCI controllers
    will never get hit, so this would break working use cases.
    
    The disadvantage of not returning -EINVAL is that cases were it is causing
    real trouble may go undetected / the cause of the trouble may be unclear,
    but this is the best we can do.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index 15591d2ea400..07b2ceaaad70 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -125,6 +125,11 @@ struct usbdevfs_hub_portinfo {
 	char port [127];	/* e.g. port 3 connects to device 27 */
 };
 
+/* Device capability flags */
+#define USBDEVFS_CAP_ZERO_PACKET		0x01
+#define USBDEVFS_CAP_BULK_CONTINUATION		0x02
+#define USBDEVFS_CAP_NO_PACKET_SIZE_LIM		0x04
+
 #ifdef __KERNEL__
 #ifdef CONFIG_COMPAT
 #include <linux/compat.h>
@@ -204,4 +209,6 @@ struct usbdevfs_ioctl32 {
 #define USBDEVFS_CONNECT           _IO('U', 23)
 #define USBDEVFS_CLAIM_PORT        _IOR('U', 24, unsigned int)
 #define USBDEVFS_RELEASE_PORT      _IOR('U', 25, unsigned int)
+#define USBDEVFS_GET_CAPABILITIES  _IOR('U', 26, __u32)
+
 #endif /* _LINUX_USBDEVICE_FS_H */

commit 637e8a60a7aaf4ef7d46cfdf83bcfac9cf6f0fbd
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Nov 14 02:28:05 2009 +0100

    usbdevfs: move compat_ioctl handling to devio.c
    
    Half the compat_ioctl handling is in devio.c, the other
    half is in fs/compat_ioctl.c. This moves everything into
    one place for consistency.
    
    As a positive side-effect, push down the BKL into the
    ioctl methods.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Oliver Neukum <oliver@neukum.org>
    Cc: Alon Bar-Lev <alon.barlev@gmail.com>
    Cc: David Vrabel <david.vrabel@csr.com>
    Cc: linux-usb@vger.kernel.org

diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index b2a7d8ba6ee3..15591d2ea400 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -128,6 +128,29 @@ struct usbdevfs_hub_portinfo {
 #ifdef __KERNEL__
 #ifdef CONFIG_COMPAT
 #include <linux/compat.h>
+
+struct usbdevfs_ctrltransfer32 {
+        u8 bRequestType;
+        u8 bRequest;
+        u16 wValue;
+        u16 wIndex;
+        u16 wLength;
+        u32 timeout;  /* in milliseconds */
+        compat_caddr_t data;
+};
+
+struct usbdevfs_bulktransfer32 {
+        compat_uint_t ep;
+        compat_uint_t len;
+        compat_uint_t timeout; /* in milliseconds */
+        compat_caddr_t data;
+};
+
+struct usbdevfs_disconnectsignal32 {
+        compat_int_t signr;
+        compat_caddr_t context;
+};
+
 struct usbdevfs_urb32 {
 	unsigned char type;
 	unsigned char endpoint;
@@ -153,7 +176,9 @@ struct usbdevfs_ioctl32 {
 #endif /* __KERNEL__ */
 
 #define USBDEVFS_CONTROL           _IOWR('U', 0, struct usbdevfs_ctrltransfer)
+#define USBDEVFS_CONTROL32           _IOWR('U', 0, struct usbdevfs_ctrltransfer32)
 #define USBDEVFS_BULK              _IOWR('U', 2, struct usbdevfs_bulktransfer)
+#define USBDEVFS_BULK32              _IOWR('U', 2, struct usbdevfs_bulktransfer32)
 #define USBDEVFS_RESETEP           _IOR('U', 3, unsigned int)
 #define USBDEVFS_SETINTERFACE      _IOR('U', 4, struct usbdevfs_setinterface)
 #define USBDEVFS_SETCONFIGURATION  _IOR('U', 5, unsigned int)
@@ -166,6 +191,7 @@ struct usbdevfs_ioctl32 {
 #define USBDEVFS_REAPURBNDELAY     _IOW('U', 13, void *)
 #define USBDEVFS_REAPURBNDELAY32   _IOW('U', 13, __u32)
 #define USBDEVFS_DISCSIGNAL        _IOR('U', 14, struct usbdevfs_disconnectsignal)
+#define USBDEVFS_DISCSIGNAL32      _IOR('U', 14, struct usbdevfs_disconnectsignal32)
 #define USBDEVFS_CLAIMINTERFACE    _IOR('U', 15, unsigned int)
 #define USBDEVFS_RELEASEINTERFACE  _IOR('U', 16, unsigned int)
 #define USBDEVFS_CONNECTINFO       _IOW('U', 17, struct usbdevfs_connectinfo)

commit 01c6460f968d7b57fc6f98adb587952628c6e099
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Sep 1 11:09:56 2009 -0400

    USB: usbfs: add USBDEVFS_URB_BULK_CONTINUATION flag
    
    This patch (as1283) adds a new flag, USBDEVFS_URB_BULK_CONTINUATION,
    to usbfs.  It is intended for userspace libraries such as libusb and
    openusb.  When they have to break up a single usbfs bulk transfer into
    multiple URBs, they will set the flag on all but the first URB of the
    series.
    
    If an error other than an unlink occurs, the kernel will automatically
    cancel all the following URBs for the same endpoint and refuse to
    accept new submissions, until an URB is encountered that is not marked
    as a BULK_CONTINUATION.  Such an URB would indicate the start of a new
    transfer or the presence of an older library, so the kernel returns to
    normal operation.
    
    This enables libraries to delimit bulk transfers correctly, even in
    the presence of early termination as indicated by short packets.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index 00ceebeb9e5c..b2a7d8ba6ee3 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -77,6 +77,7 @@ struct usbdevfs_connectinfo {
 
 #define USBDEVFS_URB_SHORT_NOT_OK	0x01
 #define USBDEVFS_URB_ISO_ASAP		0x02
+#define USBDEVFS_URB_BULK_CONTINUATION	0x04
 #define USBDEVFS_URB_NO_FSBR		0x20
 #define USBDEVFS_URB_ZERO_PACKET	0x40
 #define USBDEVFS_URB_NO_INTERRUPT	0x80

commit 7cbe5dca399a50ce8aa74314b1d276e2fb904e1b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jun 29 10:56:54 2009 -0400

    USB: add API for userspace drivers to "claim" ports
    
    This patch (as1258) implements a feature that users have been asking
    for: It gives programs the ability to "claim" a port on a hub, via a
    new usbfs ioctl.  A device plugged into a "claimed" port will not be
    touched by the kernel beyond the immediate necessities of
    initialization and enumeration.
    
    In particular, when a device is plugged into a "claimed" port, the
    kernel will not select and install a configuration.  And when a config
    is installed by usbfs or sysfs, the kernel will not probe any drivers
    for any of the interfaces.  (However the kernel will fetch various
    string descriptors during enumeration.  One could argue that this
    isn't really necessary, but the strings are exported in sysfs.)
    
    The patch does not guarantee exclusive access to these devices; it is
    still possible for more than one program to open the device file
    concurrently.  Programs are responsible for coordinating access among
    themselves.
    
    A demonstration program showing how to use the new interface can be
    found in an attachment to
    
            http://marc.info/?l=linux-usb&m=124345857431452&w=2
    
    The patch also makes a small simplification to the hub driver,
    replacing a bunch of more-or-less useless variants of "out of memory"
    with a single message.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index 0044d9b4cb85..00ceebeb9e5c 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -175,4 +175,6 @@ struct usbdevfs_ioctl32 {
 #define USBDEVFS_CLEAR_HALT        _IOR('U', 21, unsigned int)
 #define USBDEVFS_DISCONNECT        _IO('U', 22)
 #define USBDEVFS_CONNECT           _IO('U', 23)
+#define USBDEVFS_CLAIM_PORT        _IOR('U', 24, unsigned int)
+#define USBDEVFS_RELEASE_PORT      _IOR('U', 25, unsigned int)
 #endif /* _LINUX_USBDEVICE_FS_H */

commit ea05af61a874ffbc158d9cf06df8a9396f299f38
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue May 20 01:00:46 2008 +0300

    USB: remove CVS keywords
    
    This patch removes CVS keywords that weren't updated for a long time
    from comments.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index 3118ede2c67b..0044d9b4cb85 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -22,8 +22,6 @@
  *
  *  History:
  *   0.1  04.01.2000  Created
- *
- *  $Id: usbdevice_fs.h,v 1.1 2000/01/06 18:40:41 tom Exp $
  */
 
 /*****************************************************************************/

commit 14722ef4acedc643f0b78b7165ceff2d300dae4d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Apr 17 10:18:11 2008 -0400

    USB: usbfs: export the URB_NO_INTERRUPT flag to userspace
    
    This patch (as1079) cleans up the way URB_* flags are exported in
    usbfs.
    
            The URB_NO_INTERRUPT flag is now exported (this is the
            only behavioral change).
    
            USBDEVFS_URB_* macros are added for URB_NO_FSBR,
            URB_ZERO_PACKET, and URB_NO_INTERRUPT, making explicit the
            fact that the kernel accepts them.
    
            The flag matching takes into account that the URB_* values
            may change as the kernel evolves, whereas the USBDEVFS_URB_*
            values must remain fixed since they are a user API.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index 17cb108b7db0..3118ede2c67b 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -77,8 +77,11 @@ struct usbdevfs_connectinfo {
 	unsigned char slow;
 };
 
-#define USBDEVFS_URB_SHORT_NOT_OK          1
-#define USBDEVFS_URB_ISO_ASAP              2
+#define USBDEVFS_URB_SHORT_NOT_OK	0x01
+#define USBDEVFS_URB_ISO_ASAP		0x02
+#define USBDEVFS_URB_NO_FSBR		0x20
+#define USBDEVFS_URB_ZERO_PACKET	0x40
+#define USBDEVFS_URB_NO_INTERRUPT	0x80
 
 #define USBDEVFS_URB_TYPE_ISO		   0
 #define USBDEVFS_URB_TYPE_INTERRUPT	   1

commit 7f9705b04c1638b3682f63ece7931384f4542f17
Author: Marcin Slusarz <marcin.slusarz@gmail.com>
Date:   Sun Dec 16 03:23:20 2007 +0100

    USB: usbdevfs_urb: __user annotation
    
    fix warning:
    drivers/usb/core/devio.c:1226:20: warning: incorrect type in assignment (different address spaces)
    drivers/usb/core/devio.c:1226:20:    expected void *usercontext
    drivers/usb/core/devio.c:1226:20:    got void [noderef] <asn:1>*
    
    Signed-off-by: Marcin Slusarz <marcin.slusarz@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index 8ca5a7fbc9ec..17cb108b7db0 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -104,7 +104,7 @@ struct usbdevfs_urb {
 	int error_count;
 	unsigned int signr;	/* signal to be sent on completion,
 				  or 0 if none should be sent. */
-	void *usercontext;
+	void __user *usercontext;
 	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
 };
 

commit bc59462b80c694670fbb5d0bb1a8450ffc353080
Author: Phil Endecott <spam_from_usb_devel@chezphil.org>
Date:   Mon Oct 29 20:40:30 2007 +0000

    USB: Fix signr comment in usbdevice_fs.h
    
    This trivial documentation patch corrects a comment in usbdevice_fs.h; it
    previously suggested that the signal would only be sent on error, but I am
    told that it is sent on both successful and unsuccessful completion, and
    that zero indicates that no signal should be sent.
    
    Signed-off-by: Phil Endecott <spam_from_usb_devel@chezphil.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index 342dd5a7e8bb..8ca5a7fbc9ec 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -102,7 +102,8 @@ struct usbdevfs_urb {
 	int start_frame;
 	int number_of_packets;
 	int error_count;
-	unsigned int signr;  /* signal to be sent on error, -1 if none should be sent */
+	unsigned int signr;	/* signal to be sent on completion,
+				  or 0 if none should be sent. */
 	void *usercontext;
 	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
 };

commit fc8d91912694859d3e598839af2427ec1287741c
Author: Mike Frysinger <vapier@gentoo.org>
Date:   Mon Feb 5 16:41:03 2007 -0800

    USB: use __u32 rather than u32 in userspace ioctls in usbdevice_fs.h
    
    Use __u32 rather than u32 in userspace ioctl defines.
    
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index 617d8a1c59ae..342dd5a7e8bb 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -159,9 +159,9 @@ struct usbdevfs_ioctl32 {
 #define USBDEVFS_SUBMITURB32       _IOR('U', 10, struct usbdevfs_urb32)
 #define USBDEVFS_DISCARDURB        _IO('U', 11)
 #define USBDEVFS_REAPURB           _IOW('U', 12, void *)
-#define USBDEVFS_REAPURB32         _IOW('U', 12, u32)
+#define USBDEVFS_REAPURB32         _IOW('U', 12, __u32)
 #define USBDEVFS_REAPURBNDELAY     _IOW('U', 13, void *)
-#define USBDEVFS_REAPURBNDELAY32   _IOW('U', 13, u32)
+#define USBDEVFS_REAPURBNDELAY32   _IOW('U', 13, __u32)
 #define USBDEVFS_DISCSIGNAL        _IOR('U', 14, struct usbdevfs_disconnectsignal)
 #define USBDEVFS_CLAIMINTERFACE    _IOR('U', 15, unsigned int)
 #define USBDEVFS_RELEASEINTERFACE  _IOR('U', 16, unsigned int)

commit e18fa700c9a31360bc8f193aa543b7ef7b39a06b
Author: Jeff Garzik <jeff@garzik.org>
Date:   Sun Sep 24 11:13:19 2006 -0400

    Move several *_SUPER_MAGIC symbols to include/linux/magic.h.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index 7b7aadb69092..617d8a1c59ae 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -32,11 +32,10 @@
 #define _LINUX_USBDEVICE_FS_H
 
 #include <linux/types.h>
+#include <linux/magic.h>
 
 /* --------------------------------------------------------------------- */
 
-#define USBDEVICE_SUPER_MAGIC 0x9fa2
-
 /* usbdevfs ioctl codes */
 
 struct usbdevfs_ctrltransfer {

commit eae19a762de975e109394b1edcba6587323c7d1a
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Tue Apr 25 15:14:50 2006 +0100

    Don't export CONFIG_COMPAT stuff in linux/usbdevice_fs.h to userspace
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index 8859f0b41543..7b7aadb69092 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -123,6 +123,7 @@ struct usbdevfs_hub_portinfo {
 	char port [127];	/* e.g. port 3 connects to device 27 */
 };
 
+#ifdef __KERNEL__
 #ifdef CONFIG_COMPAT
 #include <linux/compat.h>
 struct usbdevfs_urb32 {
@@ -147,6 +148,7 @@ struct usbdevfs_ioctl32 {
 	compat_caddr_t data;
 };
 #endif
+#endif /* __KERNEL__ */
 
 #define USBDEVFS_CONTROL           _IOWR('U', 0, struct usbdevfs_ctrltransfer)
 #define USBDEVFS_BULK              _IOWR('U', 2, struct usbdevfs_bulktransfer)

commit c36fc889b5a4fd66cfd9ba80d9e038745d349567
Author: Pete Zaitcev <zaitcev@redhat.com>
Date:   Mon Oct 17 18:15:54 2005 -0700

    [PATCH] usb: Patch for USBDEVFS_IOCTL from 32-bit programs
    
    Dell supplied me with the following test:
    
    #include<stdio.h>
    #include<errno.h>
    #include<sys/ioctl.h>
    #include<fcntl.h>
    #include<linux/usbdevice_fs.h>
    
    main(int argc,char*argv[])
    {
       struct usbdevfs_hub_portinfo hubPortInfo = {0};
       struct usbdevfs_ioctl command = {0};
       command.ifno = 0;
       command.ioctl_code = USBDEVFS_HUB_PORTINFO;
       command.data = (void*)&hubPortInfo;
       int fd, ret;
       if(argc != 2) {
         fprintf(stderr,"Usage: %s /proc/bus/usb/<BusNo>/<HubID>\n",argv[0]);
         fprintf(stderr,"Example: %s /proc/bus/usb/001/001\n",argv[0]);
         exit(1);
       }
       errno = 0;
       fd = open(argv[1],O_RDWR);
       if(fd < 0) {
         perror("open failed:");
         exit(errno);
       }
       errno = 0;
       ret = ioctl(fd,USBDEVFS_IOCTL,&command);
       printf("IOCTL return status:%d\n",ret);
       if(ret<0) {
         perror("IOCTL failed:");
         close(fd);
         exit(3);
       } else {
           printf("IOCTL passed:Num of ports %d\n",hubPortInfo.nports);
           close(fd);
           exit(0);
       }
       return 0;
    }
    
    I have verified that it breaks if built in 32 bit mode on x86_64 and that
    the patch below fixes it.
    
    Signed-off-by: Pete Zaitcev <zaitcev@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index 9facf733800c..8859f0b41543 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -140,6 +140,12 @@ struct usbdevfs_urb32 {
 	compat_caddr_t usercontext; /* unused */
 	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
 };
+
+struct usbdevfs_ioctl32 {
+	s32 ifno;
+	s32 ioctl_code;
+	compat_caddr_t data;
+};
 #endif
 
 #define USBDEVFS_CONTROL           _IOWR('U', 0, struct usbdevfs_ctrltransfer)
@@ -160,6 +166,7 @@ struct usbdevfs_urb32 {
 #define USBDEVFS_RELEASEINTERFACE  _IOR('U', 16, unsigned int)
 #define USBDEVFS_CONNECTINFO       _IOW('U', 17, struct usbdevfs_connectinfo)
 #define USBDEVFS_IOCTL             _IOWR('U', 18, struct usbdevfs_ioctl)
+#define USBDEVFS_IOCTL32           _IOWR('U', 18, struct usbdevfs_ioctl32)
 #define USBDEVFS_HUB_PORTINFO      _IOR('U', 19, struct usbdevfs_hub_portinfo)
 #define USBDEVFS_RESET             _IO('U', 20)
 #define USBDEVFS_CLEAR_HALT        _IOR('U', 21, unsigned int)

commit ce441594e965e32965432404cfaba73e8fbc6ff7
Author: Harald Welte <laforge@gnumonks.org>
Date:   Sat Sep 3 11:27:08 2005 +0200

    [PATCH] USB: fix usbdevice_fs header breakage
    
    [USBDEVFS] fix inclusion of <linux/compat.h> to avoud header mess
    
    Without moving the include of compat.h down, userspace programs that use
    usbdevice_fs.h end up including half the kernel includes (and eventually
    fail to compile).
    
    Signed-off-by: Harald Welte <laforge@netfilter.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index fb57c2217468..9facf733800c 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -32,7 +32,6 @@
 #define _LINUX_USBDEVICE_FS_H
 
 #include <linux/types.h>
-#include <linux/compat.h>
 
 /* --------------------------------------------------------------------- */
 
@@ -125,6 +124,7 @@ struct usbdevfs_hub_portinfo {
 };
 
 #ifdef CONFIG_COMPAT
+#include <linux/compat.h>
 struct usbdevfs_urb32 {
 	unsigned char type;
 	unsigned char endpoint;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
new file mode 100644
index 000000000000..fb57c2217468
--- /dev/null
+++ b/include/linux/usbdevice_fs.h
@@ -0,0 +1,168 @@
+/*****************************************************************************/
+
+/*
+ *	usbdevice_fs.h  --  USB device file system.
+ *
+ *	Copyright (C) 2000
+ *          Thomas Sailer (sailer@ife.ee.ethz.ch)
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *	GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  History:
+ *   0.1  04.01.2000  Created
+ *
+ *  $Id: usbdevice_fs.h,v 1.1 2000/01/06 18:40:41 tom Exp $
+ */
+
+/*****************************************************************************/
+
+#ifndef _LINUX_USBDEVICE_FS_H
+#define _LINUX_USBDEVICE_FS_H
+
+#include <linux/types.h>
+#include <linux/compat.h>
+
+/* --------------------------------------------------------------------- */
+
+#define USBDEVICE_SUPER_MAGIC 0x9fa2
+
+/* usbdevfs ioctl codes */
+
+struct usbdevfs_ctrltransfer {
+	__u8 bRequestType;
+	__u8 bRequest;
+	__u16 wValue;
+	__u16 wIndex;
+	__u16 wLength;
+	__u32 timeout;  /* in milliseconds */
+ 	void __user *data;
+};
+
+struct usbdevfs_bulktransfer {
+	unsigned int ep;
+	unsigned int len;
+	unsigned int timeout; /* in milliseconds */
+	void __user *data;
+};
+
+struct usbdevfs_setinterface {
+	unsigned int interface;
+	unsigned int altsetting;
+};
+
+struct usbdevfs_disconnectsignal {
+	unsigned int signr;
+	void __user *context;
+};
+
+#define USBDEVFS_MAXDRIVERNAME 255
+
+struct usbdevfs_getdriver {
+	unsigned int interface;
+	char driver[USBDEVFS_MAXDRIVERNAME + 1];
+};
+
+struct usbdevfs_connectinfo {
+	unsigned int devnum;
+	unsigned char slow;
+};
+
+#define USBDEVFS_URB_SHORT_NOT_OK          1
+#define USBDEVFS_URB_ISO_ASAP              2
+
+#define USBDEVFS_URB_TYPE_ISO		   0
+#define USBDEVFS_URB_TYPE_INTERRUPT	   1
+#define USBDEVFS_URB_TYPE_CONTROL	   2
+#define USBDEVFS_URB_TYPE_BULK		   3
+
+struct usbdevfs_iso_packet_desc {
+	unsigned int length;
+	unsigned int actual_length;
+	unsigned int status;
+};
+
+struct usbdevfs_urb {
+	unsigned char type;
+	unsigned char endpoint;
+	int status;
+	unsigned int flags;
+	void __user *buffer;
+	int buffer_length;
+	int actual_length;
+	int start_frame;
+	int number_of_packets;
+	int error_count;
+	unsigned int signr;  /* signal to be sent on error, -1 if none should be sent */
+	void *usercontext;
+	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
+};
+
+/* ioctls for talking directly to drivers */
+struct usbdevfs_ioctl {
+	int	ifno;		/* interface 0..N ; negative numbers reserved */
+	int	ioctl_code;	/* MUST encode size + direction of data so the
+				 * macros in <asm/ioctl.h> give correct values */
+	void __user *data;	/* param buffer (in, or out) */
+};
+
+/* You can do most things with hubs just through control messages,
+ * except find out what device connects to what port. */
+struct usbdevfs_hub_portinfo {
+	char nports;		/* number of downstream ports in this hub */
+	char port [127];	/* e.g. port 3 connects to device 27 */
+};
+
+#ifdef CONFIG_COMPAT
+struct usbdevfs_urb32 {
+	unsigned char type;
+	unsigned char endpoint;
+	compat_int_t status;
+	compat_uint_t flags;
+	compat_caddr_t buffer;
+	compat_int_t buffer_length;
+	compat_int_t actual_length;
+	compat_int_t start_frame;
+	compat_int_t number_of_packets;
+	compat_int_t error_count;
+	compat_uint_t signr;
+	compat_caddr_t usercontext; /* unused */
+	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
+};
+#endif
+
+#define USBDEVFS_CONTROL           _IOWR('U', 0, struct usbdevfs_ctrltransfer)
+#define USBDEVFS_BULK              _IOWR('U', 2, struct usbdevfs_bulktransfer)
+#define USBDEVFS_RESETEP           _IOR('U', 3, unsigned int)
+#define USBDEVFS_SETINTERFACE      _IOR('U', 4, struct usbdevfs_setinterface)
+#define USBDEVFS_SETCONFIGURATION  _IOR('U', 5, unsigned int)
+#define USBDEVFS_GETDRIVER         _IOW('U', 8, struct usbdevfs_getdriver)
+#define USBDEVFS_SUBMITURB         _IOR('U', 10, struct usbdevfs_urb)
+#define USBDEVFS_SUBMITURB32       _IOR('U', 10, struct usbdevfs_urb32)
+#define USBDEVFS_DISCARDURB        _IO('U', 11)
+#define USBDEVFS_REAPURB           _IOW('U', 12, void *)
+#define USBDEVFS_REAPURB32         _IOW('U', 12, u32)
+#define USBDEVFS_REAPURBNDELAY     _IOW('U', 13, void *)
+#define USBDEVFS_REAPURBNDELAY32   _IOW('U', 13, u32)
+#define USBDEVFS_DISCSIGNAL        _IOR('U', 14, struct usbdevfs_disconnectsignal)
+#define USBDEVFS_CLAIMINTERFACE    _IOR('U', 15, unsigned int)
+#define USBDEVFS_RELEASEINTERFACE  _IOR('U', 16, unsigned int)
+#define USBDEVFS_CONNECTINFO       _IOW('U', 17, struct usbdevfs_connectinfo)
+#define USBDEVFS_IOCTL             _IOWR('U', 18, struct usbdevfs_ioctl)
+#define USBDEVFS_HUB_PORTINFO      _IOR('U', 19, struct usbdevfs_hub_portinfo)
+#define USBDEVFS_RESET             _IO('U', 20)
+#define USBDEVFS_CLEAR_HALT        _IOR('U', 21, unsigned int)
+#define USBDEVFS_DISCONNECT        _IO('U', 22)
+#define USBDEVFS_CONNECT           _IO('U', 23)
+#endif /* _LINUX_USBDEVICE_FS_H */
