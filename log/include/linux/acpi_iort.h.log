commit 3b20eb23724d493eca79f02b1e062bd5432e29d0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:35 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 320
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms and conditions of the gnu general public license
      version 2 as published by the free software foundation this program
      is distributed in the hope it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 59 temple place suite 330 boston ma 02111
      1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 33 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000435.254582722@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/acpi_iort.h b/include/linux/acpi_iort.h
index 723e4dfa1c14..8e7e2ec37f1b 100644
--- a/include/linux/acpi_iort.h
+++ b/include/linux/acpi_iort.h
@@ -1,19 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (C) 2016, Semihalf
  *	Author: Tomasz Nowicki <tn@semihalf.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
- * Place - Suite 330, Boston, MA 02111-1307 USA.
  */
 
 #ifndef __ACPI_IORT_H__

commit 24062fe85860debfdae0eeaa495f27c9971ec163
Author: Shameer Kolothum <shameerali.kolothum.thodi@huawei.com>
Date:   Tue Mar 26 15:17:53 2019 +0000

    perf/smmuv3: Enable HiSilicon Erratum 162001800 quirk
    
    HiSilicon erratum 162001800 describes the limitation of
    SMMUv3 PMCG implementation on HiSilicon Hip08 platforms.
    
    On these platforms, the PMCG event counter registers
    (SMMU_PMCG_EVCNTRn) are read only and as a result it
    is not possible to set the initial counter period value
    on event monitor start.
    
    To work around this, the current value of the counter
    is read and used for delta calculations. OEM information
    from ACPI header is used to identify the affected hardware
    platforms.
    
    Signed-off-by: Shameer Kolothum <shameerali.kolothum.thodi@huawei.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    [will: update silicon-errata.txt and add reason string to acpi match]
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/acpi_iort.h b/include/linux/acpi_iort.h
index 052ef7b9f985..723e4dfa1c14 100644
--- a/include/linux/acpi_iort.h
+++ b/include/linux/acpi_iort.h
@@ -32,6 +32,7 @@
  * do with hardware or with IORT specification.
  */
 #define IORT_SMMU_V3_PMCG_GENERIC        0x00000000 /* Generic SMMUv3 PMCG */
+#define IORT_SMMU_V3_PMCG_HISI_HIP08     0x00000001 /* HiSilicon HIP08 PMCG */
 
 int iort_register_domain_token(int trans_id, phys_addr_t base,
 			       struct fwnode_handle *fw_node);

commit 24e516049360eda85cf3fe9903221d43886c2689
Author: Neil Leeder <nleeder@codeaurora.org>
Date:   Tue Mar 26 15:17:50 2019 +0000

    ACPI/IORT: Add support for PMCG
    
    Add support for the SMMU Performance Monitor Counter Group
    information from ACPI. This is in preparation for its use
    in the SMMUv3 PMU driver.
    
    Signed-off-by: Neil Leeder <nleeder@codeaurora.org>
    Signed-off-by: Hanjun Guo <guohanjun@huawei.com>
    Signed-off-by: Shameer Kolothum <shameerali.kolothum.thodi@huawei.com>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/acpi_iort.h b/include/linux/acpi_iort.h
index 38cd77b39a64..052ef7b9f985 100644
--- a/include/linux/acpi_iort.h
+++ b/include/linux/acpi_iort.h
@@ -26,6 +26,13 @@
 #define IORT_IRQ_MASK(irq)		(irq & 0xffffffffULL)
 #define IORT_IRQ_TRIGGER_MASK(irq)	((irq >> 32) & 0xffffffffULL)
 
+/*
+ * PMCG model identifiers for use in smmu pmu driver. Please note
+ * that this is purely for the use of software and has nothing to
+ * do with hardware or with IORT specification.
+ */
+#define IORT_SMMU_V3_PMCG_GENERIC        0x00000000 /* Generic SMMUv3 PMCG */
+
 int iort_register_domain_token(int trans_id, phys_addr_t base,
 			       struct fwnode_handle *fw_node);
 void iort_deregister_domain_token(int trans_id);

commit 8b4282e6b8e239d8ce68ab884c89335cc6fdd7c7
Author: Shameer Kolothum <shameerali.kolothum.thodi@huawei.com>
Date:   Tue Feb 13 15:20:50 2018 +0000

    ACPI/IORT: Add msi address regions reservation helper
    
    On some platforms msi parent address regions have to be excluded from
    normal IOVA allocation in that they are detected and decoded in a HW
    specific way by system components and so they cannot be considered normal
    IOVA address space.
    
    Add a helper function that retrieves ITS address regions - the msi
    parent - through IORT device <-> ITS mappings and reserves it so that
    these regions will not be translated by IOMMU and will be excluded from
    IOVA allocations. The function checks for the smmu model number and
    only applies the msi reservation if the platform requires it.
    
    Signed-off-by: Shameer Kolothum <shameerali.kolothum.thodi@huawei.com>
    Reviewed-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    [For the ITS part]
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/acpi_iort.h b/include/linux/acpi_iort.h
index 2f7a29242b87..38cd77b39a64 100644
--- a/include/linux/acpi_iort.h
+++ b/include/linux/acpi_iort.h
@@ -26,7 +26,8 @@
 #define IORT_IRQ_MASK(irq)		(irq & 0xffffffffULL)
 #define IORT_IRQ_TRIGGER_MASK(irq)	((irq >> 32) & 0xffffffffULL)
 
-int iort_register_domain_token(int trans_id, struct fwnode_handle *fw_node);
+int iort_register_domain_token(int trans_id, phys_addr_t base,
+			       struct fwnode_handle *fw_node);
 void iort_deregister_domain_token(int trans_id);
 struct fwnode_handle *iort_find_domain_token(int trans_id);
 #ifdef CONFIG_ACPI_IORT
@@ -38,6 +39,7 @@ int iort_pmsi_get_dev_id(struct device *dev, u32 *dev_id);
 /* IOMMU interface */
 void iort_dma_setup(struct device *dev, u64 *dma_addr, u64 *size);
 const struct iommu_ops *iort_iommu_configure(struct device *dev);
+int iort_iommu_msi_get_resv_regions(struct device *dev, struct list_head *head);
 #else
 static inline void acpi_iort_init(void) { }
 static inline u32 iort_msi_map_rid(struct device *dev, u32 req_id)
@@ -52,6 +54,9 @@ static inline void iort_dma_setup(struct device *dev, u64 *dma_addr,
 static inline const struct iommu_ops *iort_iommu_configure(
 				      struct device *dev)
 { return NULL; }
+static inline
+int iort_iommu_msi_get_resv_regions(struct device *dev, struct list_head *head)
+{ return 0; }
 #endif
 
 #endif /* __ACPI_IORT_H__ */

commit e3d4939267925ab66f39123744ffb4bc74a13149
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Thu Sep 28 14:03:33 2017 +0100

    ACPI/IORT: Improve functions return type/storage class specifier indentation
    
    Some functions definition indentations are using a style that is frowned
    upon with return value type/storage class specifier in a separate line.
    
    Reindent the function definitions to fix them.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/include/linux/acpi_iort.h b/include/linux/acpi_iort.h
index 8d3f0bf80379..2f7a29242b87 100644
--- a/include/linux/acpi_iort.h
+++ b/include/linux/acpi_iort.h
@@ -49,8 +49,8 @@ static inline void acpi_configure_pmsi_domain(struct device *dev) { }
 /* IOMMU interface */
 static inline void iort_dma_setup(struct device *dev, u64 *dma_addr,
 				  u64 *size) { }
-static inline
-const struct iommu_ops *iort_iommu_configure(struct device *dev)
+static inline const struct iommu_ops *iort_iommu_configure(
+				      struct device *dev)
 { return NULL; }
 #endif
 

commit 7ad4263980826e8b02e121af22f4f4c9103fe86d
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Aug 7 11:29:49 2017 +0100

    ACPI: Make acpi_dma_configure() DMA regions aware
    
    Current ACPI DMA configuration set-up device DMA capabilities through
    kernel defaults that do not take into account platform specific DMA
    configurations reported by firmware.
    
    By leveraging the ACPI acpi_dev_get_dma_resources() API, add code
    in acpi_dma_configure() to retrieve the DMA regions to correctly
    set-up PCI devices DMA parameters.
    
    Rework the ACPI IORT kernel API to make sure they can accommodate
    the DMA set-up required by firmware. By making PCI devices DMA set-up
    ACPI IORT specific, the kernel is shielded from unwanted regressions
    that could be triggered by parsing DMA resources on arches that were
    previously ignoring them (ie x86/ia64), leaving kernel behaviour
    unchanged on those arches.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Tested-by: Nate Watterson <nwatters@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/acpi_iort.h b/include/linux/acpi_iort.h
index 8379d406ad2e..8d3f0bf80379 100644
--- a/include/linux/acpi_iort.h
+++ b/include/linux/acpi_iort.h
@@ -36,7 +36,7 @@ struct irq_domain *iort_get_device_domain(struct device *dev, u32 req_id);
 void acpi_configure_pmsi_domain(struct device *dev);
 int iort_pmsi_get_dev_id(struct device *dev, u32 *dev_id);
 /* IOMMU interface */
-void iort_set_dma_mask(struct device *dev);
+void iort_dma_setup(struct device *dev, u64 *dma_addr, u64 *size);
 const struct iommu_ops *iort_iommu_configure(struct device *dev);
 #else
 static inline void acpi_iort_init(void) { }
@@ -47,7 +47,8 @@ static inline struct irq_domain *iort_get_device_domain(struct device *dev,
 { return NULL; }
 static inline void acpi_configure_pmsi_domain(struct device *dev) { }
 /* IOMMU interface */
-static inline void iort_set_dma_mask(struct device *dev) { }
+static inline void iort_dma_setup(struct device *dev, u64 *dma_addr,
+				  u64 *size) { }
 static inline
 const struct iommu_ops *iort_iommu_configure(struct device *dev)
 { return NULL; }

commit 91e0bf81258c07aad27a4833368569ce873cd83e
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Jun 14 17:37:13 2017 +0100

    ACPI/IORT: Remove iort_node_match()
    
    Commit 316ca8804ea8 ("ACPI/IORT: Remove linker section for IORT entries
    probing") removed the linker section for IORT entries probing.
    
    Since those IORT entries were the only iort_node_match() interface
    users, the iort_node_match() became obsolete and can then be removed.
    
    Remove the ACPI IORT iort_node_match() interface from the kernel.
    
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/acpi_iort.h b/include/linux/acpi_iort.h
index 3ff9acea8616..8379d406ad2e 100644
--- a/include/linux/acpi_iort.h
+++ b/include/linux/acpi_iort.h
@@ -31,7 +31,6 @@ void iort_deregister_domain_token(int trans_id);
 struct fwnode_handle *iort_find_domain_token(int trans_id);
 #ifdef CONFIG_ACPI_IORT
 void acpi_iort_init(void);
-bool iort_node_match(u8 type);
 u32 iort_msi_map_rid(struct device *dev, u32 req_id);
 struct irq_domain *iort_get_device_domain(struct device *dev, u32 req_id);
 void acpi_configure_pmsi_domain(struct device *dev);
@@ -41,7 +40,6 @@ void iort_set_dma_mask(struct device *dev);
 const struct iommu_ops *iort_iommu_configure(struct device *dev);
 #else
 static inline void acpi_iort_init(void) { }
-static inline bool iort_node_match(u8 type) { return false; }
 static inline u32 iort_msi_map_rid(struct device *dev, u32 req_id)
 { return req_id; }
 static inline struct irq_domain *iort_get_device_domain(struct device *dev,

commit 28b47809b2171a6cfbab839936b24280639c9f85
Merge: 4a1e31c68e9f 2c0248d68880
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 9 15:15:47 2017 -0700

    Merge tag 'iommu-updates-v4.12' of git://git.kernel.org/pub/scm/linux/kernel/git/joro/iommu
    
    Pull IOMMU updates from Joerg Roedel:
    
     - code optimizations for the Intel VT-d driver
    
     - ability to switch off a previously enabled Intel IOMMU
    
     - support for 'struct iommu_device' for OMAP, Rockchip and Mediatek
       IOMMUs
    
     - header optimizations for IOMMU core code headers and a few fixes that
       became necessary in other parts of the kernel because of that
    
     - ACPI/IORT updates and fixes
    
     - Exynos IOMMU optimizations
    
     - updates for the IOMMU dma-api code to bring it closer to use per-cpu
       iova caches
    
     - new command-line option to set default domain type allocated by the
       iommu core code
    
     - another command line option to allow the Intel IOMMU switched off in
       a tboot environment
    
     - ARM/SMMU: TLB sync optimisations for SMMUv2, Support for using an
       IDENTITY domain in conjunction with DMA ops, Support for SMR masking,
       Support for 16-bit ASIDs (was previously broken)
    
     - various other small fixes and improvements
    
    * tag 'iommu-updates-v4.12' of git://git.kernel.org/pub/scm/linux/kernel/git/joro/iommu: (63 commits)
      soc/qbman: Move dma-mapping.h include to qman_priv.h
      soc/qbman: Fix implicit header dependency now causing build fails
      iommu: Remove trace-events include from iommu.h
      iommu: Remove pci.h include from trace/events/iommu.h
      arm: dma-mapping: Don't override dma_ops in arch_setup_dma_ops()
      ACPI/IORT: Fix CONFIG_IOMMU_API dependency
      iommu/vt-d: Don't print the failure message when booting non-kdump kernel
      iommu: Move report_iommu_fault() to iommu.c
      iommu: Include device.h in iommu.h
      x86, iommu/vt-d: Add an option to disable Intel IOMMU force on
      iommu/arm-smmu: Return IOVA in iova_to_phys when SMMU is bypassed
      iommu/arm-smmu: Correct sid to mask
      iommu/amd: Fix incorrect error handling in amd_iommu_bind_pasid()
      iommu: Make iommu_bus_notifier return NOTIFY_DONE rather than error code
      omap3isp: Remove iommu_group related code
      iommu/omap: Add iommu-group support
      iommu/omap: Make use of 'struct iommu_device'
      iommu/omap: Store iommu_dev pointer in arch_data
      iommu/omap: Move data structures to omap-iommu.h
      iommu/omap: Drop legacy-style device support
      ...

commit 316ca8804ea84a782d5ba2163711ebb22116ff5a
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Apr 10 16:51:06 2017 +0530

    ACPI/IORT: Remove linker section for IORT entries probing
    
    The IORT linker section introduced by commit 34ceea275f62
    ("ACPI/IORT: Introduce linker section for IORT entries probing")
    was needed to make sure SMMU drivers are registered (and therefore
    probed) in the kernel before devices using the SMMU have a chance
    to probe in turn.
    
    Through the introduction of deferred IOMMU configuration the linker
    section based IORT probing infrastructure is not needed any longer, in
    that device/SMMU probe dependencies are managed through the probe
    deferral mechanism, making the IORT linker section infrastructure
    unused, so that it can be removed.
    
    Remove the unused IORT linker section probing infrastructure
    from the kernel to complete the ACPI IORT IOMMU configure probe
    deferral mechanism implementation.
    
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Sricharan R <sricharan@codeaurora.org>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/acpi_iort.h b/include/linux/acpi_iort.h
index 77e08099e554..f167e1d045ff 100644
--- a/include/linux/acpi_iort.h
+++ b/include/linux/acpi_iort.h
@@ -52,7 +52,4 @@ const struct iommu_ops *iort_iommu_configure(struct device *dev)
 { return NULL; }
 #endif
 
-#define IORT_ACPI_DECLARE(name, table_id, fn)		\
-	ACPI_DECLARE_PROBE_ENTRY(iort, name, table_id, 0, NULL, 0, fn)
-
 #endif /* __ACPI_IORT_H__ */

commit d4f54a186667ffd19eac8e3f48c51d940a9b9784
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Tue Mar 7 20:40:06 2017 +0800

    ACPI: platform: setup MSI domain for ACPI based platform device
    
    By allowing platform MSI domain to be created on ACPI platforms,
    a platform device MSI domain can be set-up when it is probed.
    
    In order to do that, the MSI domain the platform device connects
    to should be retrieved, so the iort_get_platform_device_domain() is
    introduced to retrieve the domain from the IORT kernel layer.
    
    With the domain retrieved, we need a proper way to set the
    domain to platform device.
    
    Given that some platform devices (irqchips) require the MSI irqdomain
    to be their interrupt parent domain, the MSI irqdomain should be
    determined before platform device is probed but after the platform
    device is allocated which means that the code setting up the MSI
    irqdomain, ie acpi_configure_pmsi_domain() should be called in
    acpi_platform_notify() (that is triggered after adding a device but
    before the respective driver is probed) for the platform MSI domain
    code set-up path to work properly.
    
    Acked-by: Rafael J. Wysocki <rafael@kernel.org> [for glue.c]
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    [lorenzo.pieralisi@arm.com: rewrote commit log]
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Tested-by: Ming Lei <ming.lei@canonical.com>
    Tested-by: Wei Xu <xuwei5@hisilicon.com>
    Tested-by: Sinan Kaya <okaya@codeaurora.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Tomasz Nowicki <tn@semihalf.com>

diff --git a/include/linux/acpi_iort.h b/include/linux/acpi_iort.h
index fd8b9698e1d1..26e25d85eb3e 100644
--- a/include/linux/acpi_iort.h
+++ b/include/linux/acpi_iort.h
@@ -34,6 +34,7 @@ void acpi_iort_init(void);
 bool iort_node_match(u8 type);
 u32 iort_msi_map_rid(struct device *dev, u32 req_id);
 struct irq_domain *iort_get_device_domain(struct device *dev, u32 req_id);
+void acpi_configure_pmsi_domain(struct device *dev);
 int iort_pmsi_get_dev_id(struct device *dev, u32 *dev_id);
 /* IOMMU interface */
 void iort_set_dma_mask(struct device *dev);
@@ -46,6 +47,7 @@ static inline u32 iort_msi_map_rid(struct device *dev, u32 req_id)
 static inline struct irq_domain *iort_get_device_domain(struct device *dev,
 							u32 req_id)
 { return NULL; }
+static inline void acpi_configure_pmsi_domain(struct device *dev) { }
 /* IOMMU interface */
 static inline void iort_set_dma_mask(struct device *dev) { }
 static inline

commit ae7c18380495ac5c14a614fdb6c452c3bf9148ac
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Tue Mar 7 20:40:05 2017 +0800

    ACPI: platform-msi: retrieve devid from IORT
    
    For devices connecting to an ITS, the devices need to identify themself
    through a devid; this devid is represented in the IORT table in named
    component node [1] for platform devices, so this patch adds code that
    scans the IORT table to retrieve the devices devid.
    
    Add an IORT interface to collect ITS devices devid to carry out platform
    devices MSI mappings with IORT tables.
    
    [1]: https://static.docs.arm.com/den0049/b/DEN0049B_IO_Remapping_Table.pdf
    
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    [lorenzo.pieralisi@arm.com: rewrote commit log/dropped ITS changes]
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Tested-by: Ming Lei <ming.lei@canonical.com>
    Tested-by: Wei Xu <xuwei5@hisilicon.com>
    Tested-by: Sinan Kaya <okaya@codeaurora.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Tomasz Nowicki <tn@semihalf.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/acpi_iort.h b/include/linux/acpi_iort.h
index 77e08099e554..fd8b9698e1d1 100644
--- a/include/linux/acpi_iort.h
+++ b/include/linux/acpi_iort.h
@@ -34,6 +34,7 @@ void acpi_iort_init(void);
 bool iort_node_match(u8 type);
 u32 iort_msi_map_rid(struct device *dev, u32 req_id);
 struct irq_domain *iort_get_device_domain(struct device *dev, u32 req_id);
+int iort_pmsi_get_dev_id(struct device *dev, u32 *dev_id);
 /* IOMMU interface */
 void iort_set_dma_mask(struct device *dev);
 const struct iommu_ops *iort_iommu_configure(struct device *dev);

commit 18b709beb503bfc9a96a2e4b93d3cae4f5b17df0
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Tue Dec 6 14:20:11 2016 +0000

    ACPI/IORT: Make dma masks set-up IORT specific
    
    The introduction of acpi_dma_configure() allows to configure DMA
    and related IOMMU for any device that is DMA capable. To achieve
    that goal it ensures DMA masks are set-up to sane default values
    before proceeding with IOMMU and DMA ops configuration.
    
    On x86/ia64 systems, through acpi_bind_one(), acpi_dma_configure() is
    called for every device that has an ACPI companion, in that every device
    is considered DMA capable on x86/ia64 systems (ie acpi_get_dma_attr() API),
    which has the side effect of initializing dma masks also for
    pseudo-devices (eg CPUs and memory nodes) and potentially for devices
    whose dma masks were not set-up before the acpi_dma_configure() API was
    introduced, which may have noxious side effects.
    
    Therefore, in preparation for IORT firmware specific DMA masks set-up,
    wrap the default DMA masks set-up in acpi_dma_configure() inside an IORT
    specific wrapper that reverts to a NOP on x86/ia64 systems, restoring the
    default expected behaviour on x86/ia64 systems and keeping DMA default
    masks set-up on IORT based (ie ARM) arch configurations.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Cc: Tomasz Nowicki <tn@semihalf.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Sricharan R <sricharan@codeaurora.org>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/acpi_iort.h b/include/linux/acpi_iort.h
index dcb2b601e152..77e08099e554 100644
--- a/include/linux/acpi_iort.h
+++ b/include/linux/acpi_iort.h
@@ -35,6 +35,7 @@ bool iort_node_match(u8 type);
 u32 iort_msi_map_rid(struct device *dev, u32 req_id);
 struct irq_domain *iort_get_device_domain(struct device *dev, u32 req_id);
 /* IOMMU interface */
+void iort_set_dma_mask(struct device *dev);
 const struct iommu_ops *iort_iommu_configure(struct device *dev);
 #else
 static inline void acpi_iort_init(void) { }
@@ -45,6 +46,7 @@ static inline struct irq_domain *iort_get_device_domain(struct device *dev,
 							u32 req_id)
 { return NULL; }
 /* IOMMU interface */
+static inline void iort_set_dma_mask(struct device *dev) { }
 static inline
 const struct iommu_ops *iort_iommu_configure(struct device *dev)
 { return NULL; }

commit 643b8e4d86f8b1a62cf5cd9ea221e9bc0d531d18
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Nov 21 10:01:48 2016 +0000

    ACPI/IORT: Introduce iort_iommu_configure
    
    DT based systems have a generic kernel API to configure IOMMUs
    for devices (ie of_iommu_configure()).
    
    On ARM based ACPI systems, the of_iommu_configure() equivalent can
    be implemented atop ACPI IORT kernel API, with the corresponding
    functions to map device identifiers to IOMMUs and retrieve the
    corresponding IOMMU operations necessary for DMA operations set-up.
    
    By relying on the iommu_fwspec generic kernel infrastructure,
    implement the IORT based IOMMU configuration for ARM ACPI systems
    and hook it up in the ACPI kernel layer that implements DMA
    configuration for a device.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com> [ACPI core]
    Reviewed-by: Tomasz Nowicki <tn@semihalf.com>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Tomasz Nowicki <tn@semihalf.com>
    Cc: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Tomasz Nowicki <tn@semihalf.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/acpi_iort.h b/include/linux/acpi_iort.h
index 79ba1bb50950..dcb2b601e152 100644
--- a/include/linux/acpi_iort.h
+++ b/include/linux/acpi_iort.h
@@ -34,6 +34,8 @@ void acpi_iort_init(void);
 bool iort_node_match(u8 type);
 u32 iort_msi_map_rid(struct device *dev, u32 req_id);
 struct irq_domain *iort_get_device_domain(struct device *dev, u32 req_id);
+/* IOMMU interface */
+const struct iommu_ops *iort_iommu_configure(struct device *dev);
 #else
 static inline void acpi_iort_init(void) { }
 static inline bool iort_node_match(u8 type) { return false; }
@@ -42,6 +44,10 @@ static inline u32 iort_msi_map_rid(struct device *dev, u32 req_id)
 static inline struct irq_domain *iort_get_device_domain(struct device *dev,
 							u32 req_id)
 { return NULL; }
+/* IOMMU interface */
+static inline
+const struct iommu_ops *iort_iommu_configure(struct device *dev)
+{ return NULL; }
 #endif
 
 #define IORT_ACPI_DECLARE(name, table_id, fn)		\

commit d6fcd3b149f3eab3b94cc107ca846bea8461cc2f
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Nov 21 10:01:45 2016 +0000

    iommu/arm-smmu: Add IORT configuration
    
    In ACPI based systems, in order to be able to create platform
    devices and initialize them for ARM SMMU components, the IORT
    kernel implementation requires a set of static functions to be
    used by the IORT kernel layer to configure platform devices for
    ARM SMMU components.
    
    Add static configuration functions to the IORT kernel layer for
    the ARM SMMU components, so that the ARM SMMU driver can
    initialize its respective platform device by relying on the IORT
    kernel infrastructure and by adding a corresponding ACPI device
    early probe section entry.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Reviewed-by: Tomasz Nowicki <tn@semihalf.com>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Tomasz Nowicki <tn@semihalf.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/acpi_iort.h b/include/linux/acpi_iort.h
index 17bb078073de..79ba1bb50950 100644
--- a/include/linux/acpi_iort.h
+++ b/include/linux/acpi_iort.h
@@ -23,6 +23,9 @@
 #include <linux/fwnode.h>
 #include <linux/irqdomain.h>
 
+#define IORT_IRQ_MASK(irq)		(irq & 0xffffffffULL)
+#define IORT_IRQ_TRIGGER_MASK(irq)	((irq >> 32) & 0xffffffffULL)
+
 int iort_register_domain_token(int trans_id, struct fwnode_handle *fw_node);
 void iort_deregister_domain_token(int trans_id);
 struct fwnode_handle *iort_find_domain_token(int trans_id);

commit bdca0c077fc5c2a7bb405281263270070c67f917
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Nov 21 10:01:40 2016 +0000

    ACPI/IORT: Add node match function
    
    Device drivers (eg ARM SMMU) need to know if a specific component
    is part of the IORT table, so that kernel data structures are not
    initialized at initcalls time if the respective component is not
    part of the IORT table.
    
    To this end, this patch adds a trivial function that allows detecting
    if a given IORT node type is present or not in the ACPI table, providing
    an ACPI IORT equivalent for of_find_matching_node().
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Reviewed-by: Tomasz Nowicki <tn@semihalf.com>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Tomasz Nowicki <tn@semihalf.com>
    Acked-by: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Tomasz Nowicki <tn@semihalf.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/acpi_iort.h b/include/linux/acpi_iort.h
index d16fddaf230e..17bb078073de 100644
--- a/include/linux/acpi_iort.h
+++ b/include/linux/acpi_iort.h
@@ -28,10 +28,12 @@ void iort_deregister_domain_token(int trans_id);
 struct fwnode_handle *iort_find_domain_token(int trans_id);
 #ifdef CONFIG_ACPI_IORT
 void acpi_iort_init(void);
+bool iort_node_match(u8 type);
 u32 iort_msi_map_rid(struct device *dev, u32 req_id);
 struct irq_domain *iort_get_device_domain(struct device *dev, u32 req_id);
 #else
 static inline void acpi_iort_init(void) { }
+static inline bool iort_node_match(u8 type) { return false; }
 static inline u32 iort_msi_map_rid(struct device *dev, u32 req_id)
 { return req_id; }
 static inline struct irq_domain *iort_get_device_domain(struct device *dev,

commit 34ceea275f626ae624b55f2b388a07f806988a55
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Nov 21 10:01:34 2016 +0000

    ACPI/IORT: Introduce linker section for IORT entries probing
    
    Since commit e647b532275b ("ACPI: Add early device probing
    infrastructure") the kernel has gained the infrastructure that allows
    adding linker script section entries to execute ACPI driver callbacks
    (ie probe routines) for all subsystems that register a table entry
    in the respective kernel section (eg clocksource, irqchip).
    
    Since ARM IOMMU devices data is described through IORT tables when
    booting with ACPI, the ARM IOMMU drivers must be made able to hook ACPI
    callback routines that are called to probe IORT entries and initialize
    the respective IOMMU devices.
    
    To avoid adding driver specific hooks into IORT table initialization
    code (breaking therefore code modularity - ie ACPI IORT code must be made
    aware of ARM SMMU drivers ACPI init callbacks), this patch adds code
    that allows ARM SMMU drivers to take advantage of the ACPI early probing
    infrastructure, so that they can add linker script section entries
    containing drivers callback to be executed on IORT tables detection.
    
    Since IORT nodes are differentiated by a type, the callback routines
    can easily parse the IORT table entries, check the IORT nodes and
    carry out some actions whenever the IORT node type associated with
    the driver specific callback is matched.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Tomasz Nowicki <tn@semihalf.com>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Tomasz Nowicki <tn@semihalf.com>
    Cc: Tomasz Nowicki <tn@semihalf.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/acpi_iort.h b/include/linux/acpi_iort.h
index 0e32dac8fd03..d16fddaf230e 100644
--- a/include/linux/acpi_iort.h
+++ b/include/linux/acpi_iort.h
@@ -39,4 +39,7 @@ static inline struct irq_domain *iort_get_device_domain(struct device *dev,
 { return NULL; }
 #endif
 
+#define IORT_ACPI_DECLARE(name, table_id, fn)		\
+	ACPI_DECLARE_PROBE_ENTRY(iort, name, table_id, 0, NULL, 0, fn)
+
 #endif /* __ACPI_IORT_H__ */

commit 4bf2efd26d7624372fb7adff8745b4c2e8407004
Author: Tomasz Nowicki <tn@semihalf.com>
Date:   Mon Sep 12 20:32:21 2016 +0200

    ACPI: Add new IORT functions to support MSI domain handling
    
    For ITS, MSI functionality consists on building domain stack and
    during that process we need to reference to domain stack components
    e.g. before we create new DOMAIN_BUS_PCI_MSI domain we need to specify
    its DOMAIN_BUS_NEXUS parent domain. In order to manage that process
    properly, maintain list which elements contain domain token
    (unique for MSI domain stack) and ITS ID: iort_register_domain_token()
    and iort_deregister_domain_token(). Then retrieve domain token
    any time later with ITS ID being key off: iort_find_domain_token().
    With domain token and domain type we are able to find corresponding
    IRQ domain.
    
    Since IORT is prepared to describe MSI domain on a per-device basis,
    use existing IORT helpers and implement two calls:
    1. iort_msi_map_rid() to map MSI RID for a device
    2. iort_get_device_domain() to find domain token for a device
    
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Acked-by: Rafael J. Wysocki <rjw@rjwysocki.net>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/acpi_iort.h b/include/linux/acpi_iort.h
index fcacaf7ed64d..0e32dac8fd03 100644
--- a/include/linux/acpi_iort.h
+++ b/include/linux/acpi_iort.h
@@ -20,11 +20,23 @@
 #define __ACPI_IORT_H__
 
 #include <linux/acpi.h>
+#include <linux/fwnode.h>
+#include <linux/irqdomain.h>
 
+int iort_register_domain_token(int trans_id, struct fwnode_handle *fw_node);
+void iort_deregister_domain_token(int trans_id);
+struct fwnode_handle *iort_find_domain_token(int trans_id);
 #ifdef CONFIG_ACPI_IORT
 void acpi_iort_init(void);
+u32 iort_msi_map_rid(struct device *dev, u32 req_id);
+struct irq_domain *iort_get_device_domain(struct device *dev, u32 req_id);
 #else
 static inline void acpi_iort_init(void) { }
+static inline u32 iort_msi_map_rid(struct device *dev, u32 req_id)
+{ return req_id; }
+static inline struct irq_domain *iort_get_device_domain(struct device *dev,
+							u32 req_id)
+{ return NULL; }
 #endif
 
 #endif /* __ACPI_IORT_H__ */

commit 88ef16d888a094587b2ac77de60927df5da5d56d
Author: Tomasz Nowicki <tn@semihalf.com>
Date:   Mon Sep 12 20:54:20 2016 +0200

    ACPI: I/O Remapping Table (IORT) initial support
    
    IORT shows representation of IO topology for ARM based systems.
    It describes how various components are connected together on
    parent-child basis e.g. PCI RC -> SMMU -> ITS. Also see IORT spec.
    http://infocenter.arm.com/help/topic/com.arm.doc.den0049b/DEN0049B_IO_Remapping_Table.pdf
    
    Initial support allows to detect IORT table presence and save its
    root pointer obtained through acpi_get_table(). The pointer validity
    depends on acpi_gbl_permanent_mmap because if acpi_gbl_permanent_mmap
    is not set while using IORT nodes we would dereference unmapped pointers.
    
    For the aforementioned reason call acpi_iort_init() from acpi_init()
    which guarantees acpi_gbl_permanent_mmap to be set at that point.
    
    Add generic helpers which are helpful for scanning and retrieving
    information from IORT table content. List of the most important helpers:
    - iort_find_dev_node() finds IORT node for a given device
    - iort_node_map_rid() maps device RID and returns IORT node which provides
      final translation
    
    IORT support is placed under drivers/acpi/arm64/ new directory due to its
    ARM64 specific nature. The code there is considered only for ARM64.
    The long term plan is to keep all ARM64 specific tables support
    in this place e.g. GTDT table.
    
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Acked-by: Rafael J. Wysocki <rjw@rjwysocki.net>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/acpi_iort.h b/include/linux/acpi_iort.h
new file mode 100644
index 000000000000..fcacaf7ed64d
--- /dev/null
+++ b/include/linux/acpi_iort.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2016, Semihalf
+ *	Author: Tomasz Nowicki <tn@semihalf.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ */
+
+#ifndef __ACPI_IORT_H__
+#define __ACPI_IORT_H__
+
+#include <linux/acpi.h>
+
+#ifdef CONFIG_ACPI_IORT
+void acpi_iort_init(void);
+#else
+static inline void acpi_iort_init(void) { }
+#endif
+
+#endif /* __ACPI_IORT_H__ */
