commit f4f20d6897b1c047c5d38b2cfc50928e83d8fd83
Author: Gustavo A. R. Silva <gustavoars@kernel.org>
Date:   Thu May 7 14:22:18 2020 -0500

    memstick: Replace zero-length array with flexible-array
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    sizeof(flexible-array-member) triggers a warning because flexible array
    members have incomplete type[1]. There are some instances of code in
    which the sizeof operator is being incorrectly/erroneously applied to
    zero-length arrays and the result is zero. Such instances may be hiding
    some bugs. So, this work (flexible-array member conversions) will also
    help to get completely rid of those sorts of issues.
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>
    Link: https://lore.kernel.org/r/20200507192218.GA16315@embeddedor
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/memstick.h b/include/linux/memstick.h
index 216a713bef7f..da4c65f9435f 100644
--- a/include/linux/memstick.h
+++ b/include/linux/memstick.h
@@ -288,7 +288,7 @@ struct memstick_host {
 	int                 (*set_param)(struct memstick_host *host,
 					 enum memstick_param param,
 					 int value);
-	unsigned long       private[0] ____cacheline_aligned;
+	unsigned long       private[] ____cacheline_aligned;
 };
 
 struct memstick_driver {

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/memstick.h b/include/linux/memstick.h
index 690c35a9d4cc..216a713bef7f 100644
--- a/include/linux/memstick.h
+++ b/include/linux/memstick.h
@@ -1,12 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  *  Sony MemoryStick support
  *
  *  Copyright (C) 2007 Alex Dubov <oakad@yahoo.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  */
 
 #ifndef _MEMSTICK_H

commit 69347a236b22c3962ea812511495e502dedfd50c
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Fri Jan 9 16:40:56 2009 -0800

    memstick: annotate endianness of attribute structs
    
    The code was shifting the endianness appropriately everywhere, annotate
    the structs to avoid the sparse warnings when assigning the endian types
    to the struct members, or passing them to be[16|32]_to_cpu:
    
    drivers/memstick/core/mspro_block.c:331:4: warning: cast to restricted __be16
    drivers/memstick/core/mspro_block.c:333:4: warning: cast to restricted __be16
    drivers/memstick/core/mspro_block.c:335:4: warning: cast to restricted __be16
    drivers/memstick/core/mspro_block.c:337:4: warning: cast to restricted __be16
    drivers/memstick/core/mspro_block.c:341:4: warning: cast to restricted __be16
    drivers/memstick/core/mspro_block.c:347:4: warning: cast to restricted __be32
    drivers/memstick/core/mspro_block.c:356:4: warning: cast to restricted __be16
    drivers/memstick/core/mspro_block.c:358:4: warning: cast to restricted __be16
    drivers/memstick/core/mspro_block.c:364:4: warning: cast to restricted __be16
    drivers/memstick/core/mspro_block.c:367:4: warning: cast to restricted __be16
    drivers/memstick/core/mspro_block.c:369:4: warning: cast to restricted __be16
    drivers/memstick/core/mspro_block.c:371:4: warning: cast to restricted __be16
    drivers/memstick/core/mspro_block.c:377:4: warning: cast to restricted __be16
    drivers/memstick/core/mspro_block.c:478:4: warning: cast to restricted __be16
    drivers/memstick/core/mspro_block.c:480:4: warning: cast to restricted __be16
    drivers/memstick/core/mspro_block.c:482:4: warning: cast to restricted __be16
    drivers/memstick/core/mspro_block.c:484:4: warning: cast to restricted __be16
    drivers/memstick/core/mspro_block.c:486:4: warning: cast to restricted __be16
    drivers/memstick/core/mspro_block.c:689:22:    expected unsigned int [unsigned] [assigned] data_address
    drivers/memstick/core/mspro_block.c:689:22:    got restricted __be32 [usertype] <noident>
    drivers/memstick/core/mspro_block.c:697:3: warning: cast to restricted __be32
    drivers/memstick/core/mspro_block.c:960:17: warning: incorrect type in initializer (different base types)
    drivers/memstick/core/mspro_block.c:960:17:    expected unsigned short [unsigned] data_count
    drivers/memstick/core/mspro_block.c:960:17:    got restricted __be16 [usertype] <noident>
    drivers/memstick/core/mspro_block.c:993:6: warning: cast to restricted __be16
    drivers/memstick/core/mspro_block.c:995:28: warning: cast to restricted __be16
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: Alex Dubov <oakad@yahoo.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memstick.h b/include/linux/memstick.h
index d0c37e682234..690c35a9d4cc 100644
--- a/include/linux/memstick.h
+++ b/include/linux/memstick.h
@@ -100,8 +100,8 @@ struct mspro_param_register {
 #define MEMSTICK_SYS_PAR8   0x40
 #define MEMSTICK_SYS_SERIAL 0x80
 
-	unsigned short data_count;
-	unsigned int   data_address;
+	__be16 data_count;
+	__be32 data_address;
 	unsigned char  tpc_param;
 } __attribute__((packed));
 

commit 8e82f8c34b1759ae0d80fe96101746ec51fb1ba4
Author: Alex Dubov <oakad@yahoo.com>
Date:   Sat Sep 13 02:33:26 2008 -0700

    memstick: fix MSProHG 8-bit interface mode support
    
    - 8-bit interface mode never worked properly.  The only adapter I have
      which supports the 8b mode (the Jmicron) had some problems with its
      clock wiring and they discovered it only now.  We also discovered that
      ProHG media is more sensitive to the ordering of initialization
      commands.
    
    - Make the driver fall back to highest supported mode instead of always
      falling back to serial.  The driver will attempt the switch to 8b mode
      for any new MSPro card, but not all of them support it.  Previously,
      these new cards ended up in serial mode, which is not the best idea
      (they work fine with 4b, after all).
    
    - Edit some macros for better conformance to Sony documentation
    
    Signed-off-by: Alex Dubov <oakad@yahoo.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memstick.h b/include/linux/memstick.h
index a9f998a3f48b..d0c37e682234 100644
--- a/include/linux/memstick.h
+++ b/include/linux/memstick.h
@@ -21,30 +21,30 @@
 struct ms_status_register {
 	unsigned char reserved;
 	unsigned char interrupt;
-#define MEMSTICK_INT_CMDNAK             0x0001
-#define MEMSTICK_INT_IOREQ              0x0008
-#define MEMSTICK_INT_IOBREQ             0x0010
-#define MEMSTICK_INT_BREQ               0x0020
-#define MEMSTICK_INT_ERR                0x0040
-#define MEMSTICK_INT_CED                0x0080
+#define MEMSTICK_INT_CMDNAK 0x01
+#define MEMSTICK_INT_IOREQ  0x08
+#define MEMSTICK_INT_IOBREQ 0x10
+#define MEMSTICK_INT_BREQ   0x20
+#define MEMSTICK_INT_ERR    0x40
+#define MEMSTICK_INT_CED    0x80
 
 	unsigned char status0;
-#define MEMSTICK_STATUS0_WP             0x0001
-#define MEMSTICK_STATUS0_SL             0x0002
-#define MEMSTICK_STATUS0_BF             0x0010
-#define MEMSTICK_STATUS0_BE             0x0020
-#define MEMSTICK_STATUS0_FB0            0x0040
-#define MEMSTICK_STATUS0_MB             0x0080
+#define MEMSTICK_STATUS0_WP  0x01
+#define MEMSTICK_STATUS0_SL  0x02
+#define MEMSTICK_STATUS0_BF  0x10
+#define MEMSTICK_STATUS0_BE  0x20
+#define MEMSTICK_STATUS0_FB0 0x40
+#define MEMSTICK_STATUS0_MB  0x80
 
 	unsigned char status1;
-#define MEMSTICK_STATUS1_UCFG           0x0001
-#define MEMSTICK_STATUS1_FGER           0x0002
-#define MEMSTICK_STATUS1_UCEX           0x0004
-#define MEMSTICK_STATUS1_EXER           0x0008
-#define MEMSTICK_STATUS1_UCDT           0x0010
-#define MEMSTICK_STATUS1_DTER           0x0020
-#define MEMSTICK_STATUS1_FBI            0x0040
-#define MEMSTICK_STATUS1_MB             0x0080
+#define MEMSTICK_STATUS1_UCFG 0x01
+#define MEMSTICK_STATUS1_FGER 0x02
+#define MEMSTICK_STATUS1_UCEX 0x04
+#define MEMSTICK_STATUS1_EXER 0x08
+#define MEMSTICK_STATUS1_UCDT 0x10
+#define MEMSTICK_STATUS1_DTER 0x20
+#define MEMSTICK_STATUS1_FB1  0x40
+#define MEMSTICK_STATUS1_MB   0x80
 } __attribute__((packed));
 
 struct ms_id_register {
@@ -56,32 +56,32 @@ struct ms_id_register {
 
 struct ms_param_register {
 	unsigned char system;
-#define MEMSTICK_SYS_ATEN 0xc0
-#define MEMSTICK_SYS_BAMD 0x80
 #define MEMSTICK_SYS_PAM  0x08
+#define MEMSTICK_SYS_BAMD 0x80
 
 	unsigned char block_address_msb;
 	unsigned short block_address;
 	unsigned char cp;
-#define MEMSTICK_CP_BLOCK               0x0000
-#define MEMSTICK_CP_PAGE                0x0020
-#define MEMSTICK_CP_EXTRA               0x0040
-#define MEMSTICK_CP_OVERWRITE           0x0080
+#define MEMSTICK_CP_BLOCK     0x00
+#define MEMSTICK_CP_PAGE      0x20
+#define MEMSTICK_CP_EXTRA     0x40
+#define MEMSTICK_CP_OVERWRITE 0x80
 
 	unsigned char page_address;
 } __attribute__((packed));
 
 struct ms_extra_data_register {
 	unsigned char  overwrite_flag;
-#define MEMSTICK_OVERWRITE_UPDATA       0x0010
-#define MEMSTICK_OVERWRITE_PAGE         0x0060
-#define MEMSTICK_OVERWRITE_BLOCK        0x0080
+#define MEMSTICK_OVERWRITE_UDST  0x10
+#define MEMSTICK_OVERWRITE_PGST1 0x20
+#define MEMSTICK_OVERWRITE_PGST0 0x40
+#define MEMSTICK_OVERWRITE_BKST  0x80
 
 	unsigned char  management_flag;
-#define MEMSTICK_MANAGEMENT_SYSTEM      0x0004
-#define MEMSTICK_MANAGEMENT_TRANS_TABLE 0x0008
-#define MEMSTICK_MANAGEMENT_COPY        0x0010
-#define MEMSTICK_MANAGEMENT_ACCESS      0x0020
+#define MEMSTICK_MANAGEMENT_SYSFLG 0x04
+#define MEMSTICK_MANAGEMENT_ATFLG  0x08
+#define MEMSTICK_MANAGEMENT_SCMS1  0x10
+#define MEMSTICK_MANAGEMENT_SCMS0  0x20
 
 	unsigned short logical_address;
 } __attribute__((packed));
@@ -96,9 +96,9 @@ struct ms_register {
 
 struct mspro_param_register {
 	unsigned char  system;
-#define MEMSTICK_SYS_SERIAL 0x80
 #define MEMSTICK_SYS_PAR4   0x00
 #define MEMSTICK_SYS_PAR8   0x40
+#define MEMSTICK_SYS_SERIAL 0x80
 
 	unsigned short data_count;
 	unsigned int   data_address;
@@ -147,7 +147,7 @@ struct ms_register_addr {
 	unsigned char w_length;
 } __attribute__((packed));
 
-enum {
+enum memstick_tpc {
 	MS_TPC_READ_MG_STATUS   = 0x01,
 	MS_TPC_READ_LONG_DATA   = 0x02,
 	MS_TPC_READ_SHORT_DATA  = 0x03,
@@ -167,7 +167,7 @@ enum {
 	MS_TPC_SET_CMD          = 0x0e
 };
 
-enum {
+enum memstick_command {
 	MS_CMD_BLOCK_END       = 0x33,
 	MS_CMD_RESET           = 0x3c,
 	MS_CMD_BLOCK_WRITE     = 0x55,
@@ -201,8 +201,6 @@ enum {
 
 /*** Driver structures and functions ***/
 
-#define MEMSTICK_PART_SHIFT 3
-
 enum memstick_param { MEMSTICK_POWER = 1, MEMSTICK_INTERFACE };
 
 #define MEMSTICK_POWER_OFF 0
@@ -215,24 +213,27 @@ enum memstick_param { MEMSTICK_POWER = 1, MEMSTICK_INTERFACE };
 struct memstick_host;
 struct memstick_driver;
 
+struct memstick_device_id {
+	unsigned char match_flags;
 #define MEMSTICK_MATCH_ALL            0x01
 
+	unsigned char type;
 #define MEMSTICK_TYPE_LEGACY          0xff
 #define MEMSTICK_TYPE_DUO             0x00
 #define MEMSTICK_TYPE_PRO             0x01
 
+	unsigned char category;
 #define MEMSTICK_CATEGORY_STORAGE     0xff
 #define MEMSTICK_CATEGORY_STORAGE_DUO 0x00
+#define MEMSTICK_CATEGORY_IO          0x01
+#define MEMSTICK_CATEGORY_IO_PRO      0x10
 
-#define MEMSTICK_CLASS_GENERIC        0xff
-#define MEMSTICK_CLASS_GENERIC_DUO    0x00
-
-
-struct memstick_device_id {
-	unsigned char match_flags;
-	unsigned char type;
-	unsigned char category;
 	unsigned char class;
+#define MEMSTICK_CLASS_FLASH          0xff
+#define MEMSTICK_CLASS_DUO            0x00
+#define MEMSTICK_CLASS_ROM            0x01
+#define MEMSTICK_CLASS_RO             0x02
+#define MEMSTICK_CLASS_WP             0x03
 };
 
 struct memstick_request {
@@ -319,9 +320,9 @@ void memstick_suspend_host(struct memstick_host *host);
 void memstick_resume_host(struct memstick_host *host);
 
 void memstick_init_req_sg(struct memstick_request *mrq, unsigned char tpc,
-			  struct scatterlist *sg);
+			  const struct scatterlist *sg);
 void memstick_init_req(struct memstick_request *mrq, unsigned char tpc,
-		       void *buf, size_t length);
+		       const void *buf, size_t length);
 int memstick_next_req(struct memstick_host *host,
 		      struct memstick_request **mrq);
 void memstick_new_req(struct memstick_host *host);

commit 17017d8d2c005734d7088d8281ce2daab8fcb097
Author: Alex Dubov <oakad@yahoo.com>
Date:   Fri Jul 25 19:45:01 2008 -0700

    memstick: add "start" and "stop" methods to memstick device
    
    In some cases it may be desirable to ensure that associated driver is not
    going to access the media in some period of time.  "start" and "stop"
    methods are provided therefore to allow it.
    
    Signed-off-by: Alex Dubov <oakad@yahoo.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memstick.h b/include/linux/memstick.h
index 2fe599c66d52..a9f998a3f48b 100644
--- a/include/linux/memstick.h
+++ b/include/linux/memstick.h
@@ -263,6 +263,10 @@ struct memstick_dev {
 	/* Get next request from the media driver.                         */
 	int                      (*next_request)(struct memstick_dev *card,
 						 struct memstick_request **mrq);
+	/* Tell the media driver to stop doing things                      */
+	void                     (*stop)(struct memstick_dev *card);
+	/* Allow the media driver to continue                              */
+	void                     (*start)(struct memstick_dev *card);
 
 	struct device            dev;
 };

commit b77899985bdfd85a8e5a6e485033a9b4713d2471
Author: Alex Dubov <oakad@yahoo.com>
Date:   Fri Jul 25 19:45:00 2008 -0700

    memstick: allow "set_param" method to return an error code
    
    Some controllers (Jmicron, for instance) can report temporal failure
    condition during power-on.  It is desirable to account for this using a
    return value of "set_param" device method.  The return value can also be
    handy to distinguish between supported and unsupported device parameters
    in run time.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Alex Dubov <oakad@yahoo.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memstick.h b/include/linux/memstick.h
index 37a5cdb03918..2fe599c66d52 100644
--- a/include/linux/memstick.h
+++ b/include/linux/memstick.h
@@ -284,7 +284,7 @@ struct memstick_host {
 	/* Notify the host that some requests are pending. */
 	void                (*request)(struct memstick_host *host);
 	/* Set host IO parameters (power, clock, etc).     */
-	void                (*set_param)(struct memstick_host *host,
+	int                 (*set_param)(struct memstick_host *host,
 					 enum memstick_param param,
 					 int value);
 	unsigned long       private[0] ____cacheline_aligned;

commit c4c66cf1787d408066fbfc69209185701f5df15f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Mar 4 00:13:36 2008 +0100

    memstick: convert struct class_device to struct device
    
    struct class_device is going away, struct device should be used instead.
    
    Signed-off-by: Tony Jones <tonyj@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Alex Dubov <oakad@yahoo.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/memstick.h b/include/linux/memstick.h
index 3e686ec6a967..37a5cdb03918 100644
--- a/include/linux/memstick.h
+++ b/include/linux/memstick.h
@@ -276,7 +276,7 @@ struct memstick_host {
 #define MEMSTICK_CAP_PAR8          4
 
 	struct work_struct  media_checker;
-	struct class_device cdev;
+	struct device       dev;
 
 	struct memstick_dev *card;
 	unsigned int        retries;

commit ead70773608a5d97f81cb492f117d20b5e9f323e
Author: Alex Dubov <oakad@yahoo.com>
Date:   Wed Mar 19 17:01:06 2008 -0700

    memstick: automatically retrieve "INT" value from command response
    
    MemoryStick storage cards, when in parallel mode, send several meaningful bits
    of their "INT" register as part of command response.  This data is stored by
    host and can be used to spare invocation of "GET_INT" TPC on each data page
    transferred between host and card.
    
    Signed-off-by: Alex Dubov <oakad@yahoo.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memstick.h b/include/linux/memstick.h
index b7ee25888836..3e686ec6a967 100644
--- a/include/linux/memstick.h
+++ b/include/linux/memstick.h
@@ -239,7 +239,6 @@ struct memstick_request {
 	unsigned char tpc;
 	unsigned char data_dir:1,
 		      need_card_int:1,
-		      get_int_reg:1,
 		      long_data:1;
 	unsigned char int_reg;
 	int           error;

commit d114ad54ffb020dc781b6159c1c2f391c6ec418f
Author: Alex Dubov <oakad@yahoo.com>
Date:   Mon Mar 10 11:43:38 2008 -0700

    memstick: add memstick_suspend/resume_host methods
    
    Bus driver may need to be informed that host is being suspended/resumed.
    
    Signed-off-by: Alex Dubov <oakad@yahoo.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memstick.h b/include/linux/memstick.h
index c104e722de06..b7ee25888836 100644
--- a/include/linux/memstick.h
+++ b/include/linux/memstick.h
@@ -312,6 +312,8 @@ int memstick_add_host(struct memstick_host *host);
 void memstick_remove_host(struct memstick_host *host);
 void memstick_free_host(struct memstick_host *host);
 void memstick_detect_change(struct memstick_host *host);
+void memstick_suspend_host(struct memstick_host *host);
+void memstick_resume_host(struct memstick_host *host);
 
 void memstick_init_req_sg(struct memstick_request *mrq, unsigned char tpc,
 			  struct scatterlist *sg);

commit e1f19995f55294fbb00ea22ba85d7b0d80ba3813
Author: Alex Dubov <oakad@yahoo.com>
Date:   Mon Mar 10 11:43:37 2008 -0700

    memstick: introduce correct definitions in the header
    
    Thanks to some input from kind people at JMicron it is now possible to have
    more correct definitions of protocol structures and bit field semantics.
    
    Signed-off-by: Alex Dubov <oakad@yahoo.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memstick.h b/include/linux/memstick.h
index 334d059d6794..c104e722de06 100644
--- a/include/linux/memstick.h
+++ b/include/linux/memstick.h
@@ -22,6 +22,8 @@ struct ms_status_register {
 	unsigned char reserved;
 	unsigned char interrupt;
 #define MEMSTICK_INT_CMDNAK             0x0001
+#define MEMSTICK_INT_IOREQ              0x0008
+#define MEMSTICK_INT_IOBREQ             0x0010
 #define MEMSTICK_INT_BREQ               0x0020
 #define MEMSTICK_INT_ERR                0x0040
 #define MEMSTICK_INT_CED                0x0080
@@ -47,13 +49,17 @@ struct ms_status_register {
 
 struct ms_id_register {
 	unsigned char type;
-	unsigned char reserved;
+	unsigned char if_mode;
 	unsigned char category;
 	unsigned char class;
 } __attribute__((packed));
 
 struct ms_param_register {
 	unsigned char system;
+#define MEMSTICK_SYS_ATEN 0xc0
+#define MEMSTICK_SYS_BAMD 0x80
+#define MEMSTICK_SYS_PAM  0x08
+
 	unsigned char block_address_msb;
 	unsigned short block_address;
 	unsigned char cp;
@@ -90,16 +96,48 @@ struct ms_register {
 
 struct mspro_param_register {
 	unsigned char  system;
+#define MEMSTICK_SYS_SERIAL 0x80
+#define MEMSTICK_SYS_PAR4   0x00
+#define MEMSTICK_SYS_PAR8   0x40
+
+	unsigned short data_count;
+	unsigned int   data_address;
+	unsigned char  tpc_param;
+} __attribute__((packed));
+
+struct mspro_io_info_register {
+	unsigned char version;
+	unsigned char io_category;
+	unsigned char current_req;
+	unsigned char card_opt_info;
+	unsigned char rdy_wait_time;
+} __attribute__((packed));
+
+struct mspro_io_func_register {
+	unsigned char func_enable;
+	unsigned char func_select;
+	unsigned char func_intmask;
+	unsigned char transfer_mode;
+} __attribute__((packed));
+
+struct mspro_io_cmd_register {
+	unsigned short tpc_param;
 	unsigned short data_count;
 	unsigned int   data_address;
-	unsigned char  cmd_param;
 } __attribute__((packed));
 
 struct mspro_register {
-	struct ms_status_register    status;
-	struct ms_id_register        id;
-	unsigned char                reserved[8];
-	struct mspro_param_register  param;
+	struct ms_status_register     status;
+	struct ms_id_register         id;
+	unsigned char                 reserved0[8];
+	struct mspro_param_register   param;
+	unsigned char                 reserved1[8];
+	struct mspro_io_info_register io_info;
+	struct mspro_io_func_register io_func;
+	unsigned char                 reserved2[7];
+	struct mspro_io_cmd_register  io_cmd;
+	unsigned char                 io_int;
+	unsigned char                 io_int_func;
 } __attribute__((packed));
 
 struct ms_register_addr {
@@ -110,49 +148,55 @@ struct ms_register_addr {
 } __attribute__((packed));
 
 enum {
+	MS_TPC_READ_MG_STATUS   = 0x01,
 	MS_TPC_READ_LONG_DATA   = 0x02,
 	MS_TPC_READ_SHORT_DATA  = 0x03,
+	MS_TPC_READ_MG_DATA     = 0x03,
 	MS_TPC_READ_REG         = 0x04,
-	MS_TPC_READ_IO_DATA     = 0x05, /* unverified */
+	MS_TPC_READ_QUAD_DATA   = 0x05,
+	MS_TPC_READ_IO_DATA     = 0x05,
 	MS_TPC_GET_INT          = 0x07,
 	MS_TPC_SET_RW_REG_ADRS  = 0x08,
 	MS_TPC_EX_SET_CMD       = 0x09,
-	MS_TPC_WRITE_IO_DATA    = 0x0a, /* unverified */
+	MS_TPC_WRITE_QUAD_DATA  = 0x0a,
+	MS_TPC_WRITE_IO_DATA    = 0x0a,
 	MS_TPC_WRITE_REG        = 0x0b,
 	MS_TPC_WRITE_SHORT_DATA = 0x0c,
+	MS_TPC_WRITE_MG_DATA    = 0x0c,
 	MS_TPC_WRITE_LONG_DATA  = 0x0d,
 	MS_TPC_SET_CMD          = 0x0e
 };
 
 enum {
-	MS_CMD_BLOCK_END     = 0x33,
-	MS_CMD_RESET         = 0x3c,
-	MS_CMD_BLOCK_WRITE   = 0x55,
-	MS_CMD_SLEEP         = 0x5a,
-	MS_CMD_BLOCK_ERASE   = 0x99,
-	MS_CMD_BLOCK_READ    = 0xaa,
-	MS_CMD_CLEAR_BUF     = 0xc3,
-	MS_CMD_FLASH_STOP    = 0xcc,
-	MSPRO_CMD_FORMAT     = 0x10,
-	MSPRO_CMD_SLEEP      = 0x11,
-	MSPRO_CMD_READ_DATA  = 0x20,
-	MSPRO_CMD_WRITE_DATA = 0x21,
-	MSPRO_CMD_READ_ATRB  = 0x24,
-	MSPRO_CMD_STOP       = 0x25,
-	MSPRO_CMD_ERASE      = 0x26,
-	MSPRO_CMD_SET_IBA    = 0x46,
-	MSPRO_CMD_SET_IBD    = 0x47
-/*
-	MSPRO_CMD_RESET
-	MSPRO_CMD_WAKEUP
-	MSPRO_CMD_IN_IO_DATA
-	MSPRO_CMD_OUT_IO_DATA
-	MSPRO_CMD_READ_IO_ATRB
-	MSPRO_CMD_IN_IO_FIFO
-	MSPRO_CMD_OUT_IO_FIFO
-	MSPRO_CMD_IN_IOM
-	MSPRO_CMD_OUT_IOM
-*/
+	MS_CMD_BLOCK_END       = 0x33,
+	MS_CMD_RESET           = 0x3c,
+	MS_CMD_BLOCK_WRITE     = 0x55,
+	MS_CMD_SLEEP           = 0x5a,
+	MS_CMD_BLOCK_ERASE     = 0x99,
+	MS_CMD_BLOCK_READ      = 0xaa,
+	MS_CMD_CLEAR_BUF       = 0xc3,
+	MS_CMD_FLASH_STOP      = 0xcc,
+	MS_CMD_LOAD_ID         = 0x60,
+	MS_CMD_CMP_ICV         = 0x7f,
+	MSPRO_CMD_FORMAT       = 0x10,
+	MSPRO_CMD_SLEEP        = 0x11,
+	MSPRO_CMD_WAKEUP       = 0x12,
+	MSPRO_CMD_READ_DATA    = 0x20,
+	MSPRO_CMD_WRITE_DATA   = 0x21,
+	MSPRO_CMD_READ_ATRB    = 0x24,
+	MSPRO_CMD_STOP         = 0x25,
+	MSPRO_CMD_ERASE        = 0x26,
+	MSPRO_CMD_READ_QUAD    = 0x27,
+	MSPRO_CMD_WRITE_QUAD   = 0x28,
+	MSPRO_CMD_SET_IBD      = 0x46,
+	MSPRO_CMD_GET_IBD      = 0x47,
+	MSPRO_CMD_IN_IO_DATA   = 0xb0,
+	MSPRO_CMD_OUT_IO_DATA  = 0xb1,
+	MSPRO_CMD_READ_IO_ATRB = 0xb2,
+	MSPRO_CMD_IN_IO_FIFO   = 0xb3,
+	MSPRO_CMD_OUT_IO_FIFO  = 0xb4,
+	MSPRO_CMD_IN_IOM       = 0xb5,
+	MSPRO_CMD_OUT_IOM      = 0xb6,
 };
 
 /*** Driver structures and functions ***/
@@ -165,7 +209,8 @@ enum memstick_param { MEMSTICK_POWER = 1, MEMSTICK_INTERFACE };
 #define MEMSTICK_POWER_ON  1
 
 #define MEMSTICK_SERIAL   0
-#define MEMSTICK_PARALLEL 1
+#define MEMSTICK_PAR4     1
+#define MEMSTICK_PAR8     2
 
 struct memstick_host;
 struct memstick_driver;
@@ -195,11 +240,7 @@ struct memstick_request {
 	unsigned char data_dir:1,
 		      need_card_int:1,
 		      get_int_reg:1,
-		      io_type:2;
-#define               MEMSTICK_IO_NONE 0
-#define               MEMSTICK_IO_VAL  1
-#define               MEMSTICK_IO_SG   2
-
+		      long_data:1;
 	unsigned char int_reg;
 	int           error;
 	union {
@@ -231,8 +272,9 @@ struct memstick_host {
 	struct mutex        lock;
 	unsigned int        id;
 	unsigned int        caps;
-#define MEMSTICK_CAP_PARALLEL      1
-#define MEMSTICK_CAP_AUTO_GET_INT  2
+#define MEMSTICK_CAP_AUTO_GET_INT  1
+#define MEMSTICK_CAP_PAR4          2
+#define MEMSTICK_CAP_PAR8          4
 
 	struct work_struct  media_checker;
 	struct class_device cdev;

commit baf8532a147d5b76681ce040e2c8f25a3f0e718d
Author: Alex Dubov <oakad@yahoo.com>
Date:   Sat Feb 9 10:20:54 2008 -0800

    memstick: initial commit for Sony MemoryStick support
    
    Sony MemoryStick cards are used in many products manufactured by Sony.
    They are available both as storage and as IO expansion cards.  Currently,
    only MemoryStick Pro storage cards are supported via TI FlashMedia
    MemoryStick interface.
    
    [mboton@gmail.com: biuld fix]
    [akpm@linux-foundation.org: build fix]
    Signed-off-by: Alex Dubov <oakad@yahoo.com>
    Signed-off-by: Miguel Boton <mboton@gmail.co>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memstick.h b/include/linux/memstick.h
new file mode 100644
index 000000000000..334d059d6794
--- /dev/null
+++ b/include/linux/memstick.h
@@ -0,0 +1,299 @@
+/*
+ *  Sony MemoryStick support
+ *
+ *  Copyright (C) 2007 Alex Dubov <oakad@yahoo.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef _MEMSTICK_H
+#define _MEMSTICK_H
+
+#include <linux/workqueue.h>
+#include <linux/scatterlist.h>
+#include <linux/device.h>
+
+/*** Hardware based structures ***/
+
+struct ms_status_register {
+	unsigned char reserved;
+	unsigned char interrupt;
+#define MEMSTICK_INT_CMDNAK             0x0001
+#define MEMSTICK_INT_BREQ               0x0020
+#define MEMSTICK_INT_ERR                0x0040
+#define MEMSTICK_INT_CED                0x0080
+
+	unsigned char status0;
+#define MEMSTICK_STATUS0_WP             0x0001
+#define MEMSTICK_STATUS0_SL             0x0002
+#define MEMSTICK_STATUS0_BF             0x0010
+#define MEMSTICK_STATUS0_BE             0x0020
+#define MEMSTICK_STATUS0_FB0            0x0040
+#define MEMSTICK_STATUS0_MB             0x0080
+
+	unsigned char status1;
+#define MEMSTICK_STATUS1_UCFG           0x0001
+#define MEMSTICK_STATUS1_FGER           0x0002
+#define MEMSTICK_STATUS1_UCEX           0x0004
+#define MEMSTICK_STATUS1_EXER           0x0008
+#define MEMSTICK_STATUS1_UCDT           0x0010
+#define MEMSTICK_STATUS1_DTER           0x0020
+#define MEMSTICK_STATUS1_FBI            0x0040
+#define MEMSTICK_STATUS1_MB             0x0080
+} __attribute__((packed));
+
+struct ms_id_register {
+	unsigned char type;
+	unsigned char reserved;
+	unsigned char category;
+	unsigned char class;
+} __attribute__((packed));
+
+struct ms_param_register {
+	unsigned char system;
+	unsigned char block_address_msb;
+	unsigned short block_address;
+	unsigned char cp;
+#define MEMSTICK_CP_BLOCK               0x0000
+#define MEMSTICK_CP_PAGE                0x0020
+#define MEMSTICK_CP_EXTRA               0x0040
+#define MEMSTICK_CP_OVERWRITE           0x0080
+
+	unsigned char page_address;
+} __attribute__((packed));
+
+struct ms_extra_data_register {
+	unsigned char  overwrite_flag;
+#define MEMSTICK_OVERWRITE_UPDATA       0x0010
+#define MEMSTICK_OVERWRITE_PAGE         0x0060
+#define MEMSTICK_OVERWRITE_BLOCK        0x0080
+
+	unsigned char  management_flag;
+#define MEMSTICK_MANAGEMENT_SYSTEM      0x0004
+#define MEMSTICK_MANAGEMENT_TRANS_TABLE 0x0008
+#define MEMSTICK_MANAGEMENT_COPY        0x0010
+#define MEMSTICK_MANAGEMENT_ACCESS      0x0020
+
+	unsigned short logical_address;
+} __attribute__((packed));
+
+struct ms_register {
+	struct ms_status_register     status;
+	struct ms_id_register         id;
+	unsigned char                 reserved[8];
+	struct ms_param_register      param;
+	struct ms_extra_data_register extra_data;
+} __attribute__((packed));
+
+struct mspro_param_register {
+	unsigned char  system;
+	unsigned short data_count;
+	unsigned int   data_address;
+	unsigned char  cmd_param;
+} __attribute__((packed));
+
+struct mspro_register {
+	struct ms_status_register    status;
+	struct ms_id_register        id;
+	unsigned char                reserved[8];
+	struct mspro_param_register  param;
+} __attribute__((packed));
+
+struct ms_register_addr {
+	unsigned char r_offset;
+	unsigned char r_length;
+	unsigned char w_offset;
+	unsigned char w_length;
+} __attribute__((packed));
+
+enum {
+	MS_TPC_READ_LONG_DATA   = 0x02,
+	MS_TPC_READ_SHORT_DATA  = 0x03,
+	MS_TPC_READ_REG         = 0x04,
+	MS_TPC_READ_IO_DATA     = 0x05, /* unverified */
+	MS_TPC_GET_INT          = 0x07,
+	MS_TPC_SET_RW_REG_ADRS  = 0x08,
+	MS_TPC_EX_SET_CMD       = 0x09,
+	MS_TPC_WRITE_IO_DATA    = 0x0a, /* unverified */
+	MS_TPC_WRITE_REG        = 0x0b,
+	MS_TPC_WRITE_SHORT_DATA = 0x0c,
+	MS_TPC_WRITE_LONG_DATA  = 0x0d,
+	MS_TPC_SET_CMD          = 0x0e
+};
+
+enum {
+	MS_CMD_BLOCK_END     = 0x33,
+	MS_CMD_RESET         = 0x3c,
+	MS_CMD_BLOCK_WRITE   = 0x55,
+	MS_CMD_SLEEP         = 0x5a,
+	MS_CMD_BLOCK_ERASE   = 0x99,
+	MS_CMD_BLOCK_READ    = 0xaa,
+	MS_CMD_CLEAR_BUF     = 0xc3,
+	MS_CMD_FLASH_STOP    = 0xcc,
+	MSPRO_CMD_FORMAT     = 0x10,
+	MSPRO_CMD_SLEEP      = 0x11,
+	MSPRO_CMD_READ_DATA  = 0x20,
+	MSPRO_CMD_WRITE_DATA = 0x21,
+	MSPRO_CMD_READ_ATRB  = 0x24,
+	MSPRO_CMD_STOP       = 0x25,
+	MSPRO_CMD_ERASE      = 0x26,
+	MSPRO_CMD_SET_IBA    = 0x46,
+	MSPRO_CMD_SET_IBD    = 0x47
+/*
+	MSPRO_CMD_RESET
+	MSPRO_CMD_WAKEUP
+	MSPRO_CMD_IN_IO_DATA
+	MSPRO_CMD_OUT_IO_DATA
+	MSPRO_CMD_READ_IO_ATRB
+	MSPRO_CMD_IN_IO_FIFO
+	MSPRO_CMD_OUT_IO_FIFO
+	MSPRO_CMD_IN_IOM
+	MSPRO_CMD_OUT_IOM
+*/
+};
+
+/*** Driver structures and functions ***/
+
+#define MEMSTICK_PART_SHIFT 3
+
+enum memstick_param { MEMSTICK_POWER = 1, MEMSTICK_INTERFACE };
+
+#define MEMSTICK_POWER_OFF 0
+#define MEMSTICK_POWER_ON  1
+
+#define MEMSTICK_SERIAL   0
+#define MEMSTICK_PARALLEL 1
+
+struct memstick_host;
+struct memstick_driver;
+
+#define MEMSTICK_MATCH_ALL            0x01
+
+#define MEMSTICK_TYPE_LEGACY          0xff
+#define MEMSTICK_TYPE_DUO             0x00
+#define MEMSTICK_TYPE_PRO             0x01
+
+#define MEMSTICK_CATEGORY_STORAGE     0xff
+#define MEMSTICK_CATEGORY_STORAGE_DUO 0x00
+
+#define MEMSTICK_CLASS_GENERIC        0xff
+#define MEMSTICK_CLASS_GENERIC_DUO    0x00
+
+
+struct memstick_device_id {
+	unsigned char match_flags;
+	unsigned char type;
+	unsigned char category;
+	unsigned char class;
+};
+
+struct memstick_request {
+	unsigned char tpc;
+	unsigned char data_dir:1,
+		      need_card_int:1,
+		      get_int_reg:1,
+		      io_type:2;
+#define               MEMSTICK_IO_NONE 0
+#define               MEMSTICK_IO_VAL  1
+#define               MEMSTICK_IO_SG   2
+
+	unsigned char int_reg;
+	int           error;
+	union {
+		struct scatterlist sg;
+		struct {
+			unsigned char data_len;
+			unsigned char data[15];
+		};
+	};
+};
+
+struct memstick_dev {
+	struct memstick_device_id id;
+	struct memstick_host     *host;
+	struct ms_register_addr  reg_addr;
+	struct completion        mrq_complete;
+	struct memstick_request  current_mrq;
+
+	/* Check that media driver is still willing to operate the device. */
+	int                      (*check)(struct memstick_dev *card);
+	/* Get next request from the media driver.                         */
+	int                      (*next_request)(struct memstick_dev *card,
+						 struct memstick_request **mrq);
+
+	struct device            dev;
+};
+
+struct memstick_host {
+	struct mutex        lock;
+	unsigned int        id;
+	unsigned int        caps;
+#define MEMSTICK_CAP_PARALLEL      1
+#define MEMSTICK_CAP_AUTO_GET_INT  2
+
+	struct work_struct  media_checker;
+	struct class_device cdev;
+
+	struct memstick_dev *card;
+	unsigned int        retries;
+
+	/* Notify the host that some requests are pending. */
+	void                (*request)(struct memstick_host *host);
+	/* Set host IO parameters (power, clock, etc).     */
+	void                (*set_param)(struct memstick_host *host,
+					 enum memstick_param param,
+					 int value);
+	unsigned long       private[0] ____cacheline_aligned;
+};
+
+struct memstick_driver {
+	struct memstick_device_id *id_table;
+	int                       (*probe)(struct memstick_dev *card);
+	void                      (*remove)(struct memstick_dev *card);
+	int                       (*suspend)(struct memstick_dev *card,
+					     pm_message_t state);
+	int                       (*resume)(struct memstick_dev *card);
+
+	struct device_driver      driver;
+};
+
+int memstick_register_driver(struct memstick_driver *drv);
+void memstick_unregister_driver(struct memstick_driver *drv);
+
+struct memstick_host *memstick_alloc_host(unsigned int extra,
+					  struct device *dev);
+
+int memstick_add_host(struct memstick_host *host);
+void memstick_remove_host(struct memstick_host *host);
+void memstick_free_host(struct memstick_host *host);
+void memstick_detect_change(struct memstick_host *host);
+
+void memstick_init_req_sg(struct memstick_request *mrq, unsigned char tpc,
+			  struct scatterlist *sg);
+void memstick_init_req(struct memstick_request *mrq, unsigned char tpc,
+		       void *buf, size_t length);
+int memstick_next_req(struct memstick_host *host,
+		      struct memstick_request **mrq);
+void memstick_new_req(struct memstick_host *host);
+
+int memstick_set_rw_addr(struct memstick_dev *card);
+
+static inline void *memstick_priv(struct memstick_host *host)
+{
+	return (void *)host->private;
+}
+
+static inline void *memstick_get_drvdata(struct memstick_dev *card)
+{
+	return dev_get_drvdata(&card->dev);
+}
+
+static inline void memstick_set_drvdata(struct memstick_dev *card, void *data)
+{
+	dev_set_drvdata(&card->dev, data);
+}
+
+#endif
