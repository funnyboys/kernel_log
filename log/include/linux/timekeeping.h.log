commit f097eb38f71391ff2cf078788bad5a00eb3bd96a
Author: Kurt Kanzenbach <kurt@linutronix.de>
Date:   Tue Jun 9 10:17:26 2020 +0200

    timekeeping: Fix kerneldoc system_device_crosststamp & al
    
    Make kernel doc comments actually work and fix the syncronized typo.
    
    [ tglx: Added the missing /** and fixed up formatting ]
    
    Signed-off-by: Kurt Kanzenbach <kurt@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20200609081726.5657-1-kurt@linutronix.de

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index b27e2ffa96c1..d5471d6fa778 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -222,9 +222,9 @@ extern bool timekeeping_rtc_skipresume(void);
 
 extern void timekeeping_inject_sleeptime64(const struct timespec64 *delta);
 
-/*
+/**
  * struct system_time_snapshot - simultaneous raw/real time capture with
- *	counter value
+ *				 counter value
  * @cycles:	Clocksource counter value to produce the system times
  * @real:	Realtime system time
  * @raw:	Monotonic raw system time
@@ -239,9 +239,9 @@ struct system_time_snapshot {
 	u8		cs_was_changed_seq;
 };
 
-/*
+/**
  * struct system_device_crosststamp - system/device cross-timestamp
- *	(syncronized capture)
+ *				      (synchronized capture)
  * @device:		Device time
  * @sys_realtime:	Realtime simultaneous with device time
  * @sys_monoraw:	Monotonic raw simultaneous with device time
@@ -252,12 +252,12 @@ struct system_device_crosststamp {
 	ktime_t sys_monoraw;
 };
 
-/*
+/**
  * struct system_counterval_t - system counter value with the pointer to the
- *	corresponding clocksource
+ *				corresponding clocksource
  * @cycles:	System counter value
  * @cs:		Clocksource corresponding to system counter value. Used by
- *	timekeeping code to verify comparibility of two cycle values
+ *		timekeeping code to verify comparibility of two cycle values
  */
 struct system_counterval_t {
 	u64			cycles;

commit d48e0cd8fcaf314175a15d3076d7a1e71bd4e628
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Jun 24 11:15:39 2019 +0200

    timekeeping: Boot should be boottime for coarse ns accessor
    
    Somewhere in all the patchsets before, this cleanup got lost.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Link: https://lkml.kernel.org/r/20190624091539.13512-1-Jason@zx2c4.com

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index dcffc00755f2..b27e2ffa96c1 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -131,7 +131,7 @@ static inline u64 ktime_get_coarse_real_ns(void)
 	return ktime_to_ns(ktime_get_coarse_real());
 }
 
-static inline u64 ktime_get_coarse_boot_ns(void)
+static inline u64 ktime_get_coarse_boottime_ns(void)
 {
 	return ktime_to_ns(ktime_get_coarse_boottime());
 }

commit 4c54294d01e605a9f992361b924c5d8b12822a6d
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jun 21 22:32:49 2019 +0200

    timekeeping: Add missing _ns functions for coarse accessors
    
    This further unifies the accessors for the fast and coarse functions, so
    that the same types of functions are available for each. There was also
    a bit of confusion with the documentation, which prior advertised a
    function that has never existed. Finally, the vanilla ktime_get_coarse()
    was omitted from the API originally, so this fills this oversight.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Link: https://lkml.kernel.org/r/20190621203249.3909-3-Jason@zx2c4.com

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index fd6123722ea8..dcffc00755f2 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -113,6 +113,34 @@ static inline ktime_t ktime_get_coarse_clocktai(void)
 	return ktime_get_coarse_with_offset(TK_OFFS_TAI);
 }
 
+static inline ktime_t ktime_get_coarse(void)
+{
+	struct timespec64 ts;
+
+	ktime_get_coarse_ts64(&ts);
+	return timespec64_to_ktime(ts);
+}
+
+static inline u64 ktime_get_coarse_ns(void)
+{
+	return ktime_to_ns(ktime_get_coarse());
+}
+
+static inline u64 ktime_get_coarse_real_ns(void)
+{
+	return ktime_to_ns(ktime_get_coarse_real());
+}
+
+static inline u64 ktime_get_coarse_boot_ns(void)
+{
+	return ktime_to_ns(ktime_get_coarse_boottime());
+}
+
+static inline u64 ktime_get_coarse_clocktai_ns(void)
+{
+	return ktime_to_ns(ktime_get_coarse_clocktai());
+}
+
 /**
  * ktime_mono_to_real - Convert monotonic time to clock realtime
  */

commit 9285ec4c8b61d4930a575081abeba2cd4f449a74
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jun 21 22:32:48 2019 +0200

    timekeeping: Use proper clock specifier names in functions
    
    This makes boot uniformly boottime and tai uniformly clocktai, to
    address the remaining oversights.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Link: https://lkml.kernel.org/r/20190621203249.3909-2-Jason@zx2c4.com

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index a8ab0f143ac4..fd6123722ea8 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -131,12 +131,12 @@ static inline u64 ktime_get_real_ns(void)
 	return ktime_to_ns(ktime_get_real());
 }
 
-static inline u64 ktime_get_boot_ns(void)
+static inline u64 ktime_get_boottime_ns(void)
 {
 	return ktime_to_ns(ktime_get_boottime());
 }
 
-static inline u64 ktime_get_tai_ns(void)
+static inline u64 ktime_get_clocktai_ns(void)
 {
 	return ktime_to_ns(ktime_get_clocktai());
 }

commit e4b92b108c6cd6b311e4b6e85d6a87a34599a6e3
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Dec 7 13:45:54 2018 +0100

    timekeeping: remove obsolete time accessors
    
    There are no more remaining users of these deprecated wrappers, so
    let's remove them before new users have a chance to make it in.
    
    See Documentation/core-api/timekeeping.rst for replacements when
    porting old drivers that contain calls to this function.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 29975e93fcb8..a8ab0f143ac4 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -262,18 +262,4 @@ void read_persistent_wall_and_boot_offset(struct timespec64 *wall_clock,
 					  struct timespec64 *boot_offset);
 extern int update_persistent_clock64(struct timespec64 now);
 
-/*
- * deprecated aliases, don't use in new code
- */
-#define getnstimeofday64(ts)		ktime_get_real_ts64(ts)
-
-static inline struct timespec64 current_kernel_time64(void)
-{
-	struct timespec64 ts;
-
-	ktime_get_coarse_real_ts64(&ts);
-
-	return ts;
-}
-
 #endif

commit 4dcb9239dad6cee17c538482619a5b659774ee51
Merge: 3acbd2de6bc3 d59e0ba19481
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 25 11:14:36 2018 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timekeeping updates from Thomas Gleixner:
     "The timers and timekeeping departement provides:
    
       - Another large y2038 update with further preparations for providing
         the y2038 safe timespecs closer to the syscalls.
    
       - An overhaul of the SHCMT clocksource driver
    
       - SPDX license identifier updates
    
       - Small cleanups and fixes all over the place"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (31 commits)
      tick/sched : Remove redundant cpu_online() check
      clocksource/drivers/dw_apb: Add reset control
      clocksource: Remove obsolete CLOCKSOURCE_OF_DECLARE
      clocksource/drivers: Unify the names to timer-* format
      clocksource/drivers/sh_cmt: Add R-Car gen3 support
      dt-bindings: timer: renesas: cmt: document R-Car gen3 support
      clocksource/drivers/sh_cmt: Properly line-wrap sh_cmt_of_table[] initializer
      clocksource/drivers/sh_cmt: Fix clocksource width for 32-bit machines
      clocksource/drivers/sh_cmt: Fixup for 64-bit machines
      clocksource/drivers/sh_tmu: Convert to SPDX identifiers
      clocksource/drivers/sh_mtu2: Convert to SPDX identifiers
      clocksource/drivers/sh_cmt: Convert to SPDX identifiers
      clocksource/drivers/renesas-ostm: Convert to SPDX identifiers
      clocksource: Convert to using %pOFn instead of device_node.name
      tick/broadcast: Remove redundant check
      RISC-V: Request newstat syscalls
      y2038: signal: Change rt_sigtimedwait to use __kernel_timespec
      y2038: socket: Change recvmmsg to use __kernel_timespec
      y2038: sched: Change sched_rr_get_interval to use __kernel_timespec
      y2038: utimes: Rework #ifdef guards for compat syscalls
      ...

commit c43c5e9f524ec914e7e202f9c5ab91779629ccc6
Author: Christian Borntraeger <borntraeger@de.ibm.com>
Date:   Mon Sep 3 10:15:33 2018 +0200

    timekeeping: Fix declaration of read_persistent_wall_and_boot_offset()
    
    It is read_persistent_wall_and_boot_offset() and not
    read_persistent_clock_and_boot_offset()
    
    Fixes: 3eca993740b8eb40f51 ("timekeeping: Replace read_boot_clock64() with read_persistent_wall_and_boot_offset()")
    Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Pavel Tatashin <pasha.tatashin@oracle.com>
    Link: https://lkml.kernel.org/r/20180903081533.34366-1-borntraeger@de.ibm.com

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 5d738804e3d6..a5a3cfc3c2fa 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -258,8 +258,8 @@ extern void ktime_get_snapshot(struct system_time_snapshot *systime_snapshot);
 extern int persistent_clock_is_local;
 
 extern void read_persistent_clock64(struct timespec64 *ts);
-void read_persistent_clock_and_boot_offset(struct timespec64 *wall_clock,
-					   struct timespec64 *boot_offset);
+void read_persistent_wall_and_boot_offset(struct timespec64 *wall_clock,
+					  struct timespec64 *boot_offset);
 extern int update_persistent_clock64(struct timespec64 now);
 
 /*

commit 976516404ff3fab2a8caa8bd6f5efc1437fed0b8
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Aug 14 14:02:57 2018 +0200

    y2038: remove unused time interfaces
    
    After many small patches, at least some of the deprecated interfaces
    have no remaining users any more and can be removed:
    
      current_kernel_time
      do_settimeofday
      get_monotonic_boottime
      get_monotonic_boottime64
      get_monotonic_coarse
      get_monotonic_coarse64
      getrawmonotonic64
      ktime_get_real_ts
      timekeeping_clocktai
      timespec_trunc
      timespec_valid_strict
      time_to_tm
    
    For many of the remaining time functions, we are missing one or
    two patches that failed to make it into 4.19, they will be removed
    in the following merge window.
    
    The replacement functions for the removed interfaces are documented in
    Documentation/core-api/timekeeping.rst.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 5d738804e3d6..3faba06411aa 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -266,9 +266,6 @@ extern int update_persistent_clock64(struct timespec64 now);
  * deprecated aliases, don't use in new code
  */
 #define getnstimeofday64(ts)		ktime_get_real_ts64(ts)
-#define get_monotonic_boottime64(ts)	ktime_get_boottime_ts64(ts)
-#define getrawmonotonic64(ts)		ktime_get_raw_ts64(ts)
-#define timekeeping_clocktai64(ts)	ktime_get_clocktai_ts64(ts)
 
 static inline struct timespec64 current_kernel_time64(void)
 {
@@ -279,13 +276,4 @@ static inline struct timespec64 current_kernel_time64(void)
 	return ts;
 }
 
-static inline struct timespec64 get_monotonic_coarse64(void)
-{
-	struct timespec64 ts;
-
-	ktime_get_coarse_ts64(&ts);
-
-	return ts;
-}
-
 #endif

commit e6ecec342fefc2df01438cb0b8bacdd8641a6418
Merge: 747f62305dfb 3d83d3188460
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 14 14:29:31 2018 -0700

    Merge tag 'docs-4.19' of git://git.lwn.net/linux
    
    Pull documentation update from Jonathan Corbet:
     "This was a moderately busy cycle for docs, with the usual collection
      of small fixes and updates.
    
      We also have new ktime_get_*() docs from Arnd, some kernel-doc fixes,
      a new set of Italian translations (non so se vale la pena, ma non fa
      male - speriamo bene), and some extensive early memory-management
      documentation improvements from Mike Rapoport"
    
    * tag 'docs-4.19' of git://git.lwn.net/linux: (52 commits)
      Documentation: corrections to console/console.txt
      Documentation: add ioctl number entry for v4l2-subdev.h
      Remove gendered language from management style documentation
      scripts/kernel-doc: Escape all literal braces in regexes
      docs/mm: add description of boot time memory management
      docs/mm: memblock: add overview documentation
      docs/mm: memblock: add kernel-doc description for memblock types
      docs/mm: memblock: add kernel-doc comments for memblock_add[_node]
      docs/mm: memblock: update kernel-doc comments
      mm/memblock: add a name for memblock flags enumeration
      docs/mm: bootmem: add overview documentation
      docs/mm: bootmem: add kernel-doc description of 'struct bootmem_data'
      docs/mm: bootmem: fix kernel-doc warnings
      docs/mm: nobootmem: fixup kernel-doc comments
      mm/bootmem: drop duplicated kernel-doc comments
      Documentation: vm.txt: Adding 'nr_hugepages_mempolicy' parameter description.
      doc:it_IT: translation for kernel-hacking
      docs: Fix the reference labels in Locking.rst
      doc: tracing: Fix a typo of trace_stat
      mm: Introduce new type vm_fault_t
      ...

commit 13e091b6dd0e78a518a7d8756607d3acb8215768
Merge: eac341194426 1088c6eef261
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 13 18:28:19 2018 -0700

    Merge branch 'x86-timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 timer updates from Thomas Gleixner:
     "Early TSC based time stamping to allow better boot time analysis.
    
      This comes with a general cleanup of the TSC calibration code which
      grew warts and duct taping over the years and removes 250 lines of
      code. Initiated and mostly implemented by Pavel with help from various
      folks"
    
    * 'x86-timers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (37 commits)
      x86/kvmclock: Mark kvm_get_preset_lpj() as __init
      x86/tsc: Consolidate init code
      sched/clock: Disable interrupts when calling generic_sched_clock_init()
      timekeeping: Prevent false warning when persistent clock is not available
      sched/clock: Close a hole in sched_clock_init()
      x86/tsc: Make use of tsc_calibrate_cpu_early()
      x86/tsc: Split native_calibrate_cpu() into early and late parts
      sched/clock: Use static key for sched_clock_running
      sched/clock: Enable sched clock early
      sched/clock: Move sched clock initialization and merge with generic clock
      x86/tsc: Use TSC as sched clock early
      x86/tsc: Initialize cyc2ns when tsc frequency is determined
      x86/tsc: Calibrate tsc only once
      ARM/time: Remove read_boot_clock64()
      s390/time: Remove read_boot_clock64()
      timekeeping: Default boot time offset to local_clock()
      timekeeping: Replace read_boot_clock64() with read_persistent_wall_and_boot_offset()
      s390/time: Add read_persistent_wall_and_boot_offset()
      x86/xen/time: Output xen sched_clock time from 0
      x86/xen/time: Initialize pv xen time in init_hypervisor_platform()
      ...

commit 0e3fd810c4f41dbd63fb7caddc11684959176727
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jul 10 16:46:41 2018 +0200

    Documentation: document ktime_get_*() APIs
    
    As Dave Chinner points out, we don't have a proper documentation for the
    ktime_get() family of interfaces, making it rather unclear which of the
    over 30 (!) interfaces one should actually use in a driver or elsewhere
    in the kernel.
    
    I wrote up an explanation from how I personally see the interfaces,
    documenting what each of the functions do and hopefully making it a bit
    clearer which should be used where.
    
    This is the first time I tried writing .rst format documentation, so
    in addition to any mistakes in the content, I probably also introduce
    nonstandard formatting ;-)
    
    I first tried to add an extra section to
    Documentation/timers/timekeeping.txt, but this is currently not included
    in the generated API, and it seems useful to have the API docs as part
    of what gets generated in
    https://www.kernel.org/doc/html/latest/core-api/index.html#core-utilities
    instead, so I started a new file there.
    
    I also considered adding the documentation inline in the
    include/linux/timekeeping.h header, but couldn't figure out how to do
    that in a way that would result both in helpful inline comments as
    well as readable html output, so I settled for the latter, with
    a small note pointing to it from the header.
    
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Tested-by: Randy Dunlap <rdunlap@infradead.org>
    Reviewed-by: Randy Dunlap <rdunlap@infradead.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 86bc2026efce..947b1b8d2d01 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -20,6 +20,21 @@ extern int do_settimeofday64(const struct timespec64 *ts);
 extern int do_sys_settimeofday64(const struct timespec64 *tv,
 				 const struct timezone *tz);
 
+/*
+ * ktime_get() family: read the current time in a multitude of ways,
+ *
+ * The default time reference is CLOCK_MONOTONIC, starting at
+ * boot time but not counting the time spent in suspend.
+ * For other references, use the functions with "real", "clocktai",
+ * "boottime" and "raw" suffixes.
+ *
+ * To get the time in a different format, use the ones wit
+ * "ns", "ts64" and "seconds" suffix.
+ *
+ * See Documentation/core-api/timekeeping.rst for more details.
+ */
+
+
 /*
  * timespec64 based interfaces
  */

commit 985e695074d35768cb04d65f58bca45f7bf1a99d
Author: Ondrej Mosnacek <omosnace@redhat.com>
Date:   Fri Jul 13 14:06:42 2018 +0200

    timekeeping/ntp: Constify some function arguments
    
    Add 'const' to some function arguments and variables to make it easier
    to read the code.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
    [jstultz: Also fixup pre-existing checkpatch warnings for
     prototype arguments with no variable name]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 86bc2026efce..edace6b656e9 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -177,7 +177,7 @@ static inline time64_t ktime_get_clocktai_seconds(void)
 extern bool timekeeping_rtc_skipsuspend(void);
 extern bool timekeeping_rtc_skipresume(void);
 
-extern void timekeeping_inject_sleeptime64(struct timespec64 *delta);
+extern void timekeeping_inject_sleeptime64(const struct timespec64 *delta);
 
 /*
  * struct system_time_snapshot - simultaneous raw/real time capture with

commit 3eca993740b8eb40f514b90b1877a4dbcf0a6710
Author: Pavel Tatashin <pasha.tatashin@oracle.com>
Date:   Thu Jul 19 16:55:34 2018 -0400

    timekeeping: Replace read_boot_clock64() with read_persistent_wall_and_boot_offset()
    
    If architecture does not support exact boot time, it is challenging to
    estimate boot time without having a reference to the current persistent
    clock value. Yet, it cannot read the persistent clock time again, because
    this may lead to math discrepancies with the caller of read_boot_clock64()
    who have read the persistent clock at a different time.
    
    This is why it is better to provide two values simultaneously: the
    persistent clock value, and the boot time.
    
    Replace read_boot_clock64() with:
    read_persistent_wall_and_boot_offset(wall_time, boot_offset)
    
    Where wall_time is returned by read_persistent_clock() And boot_offset is
    wall_time - boot time, which defaults to 0.
    
    Signed-off-by: Pavel Tatashin <pasha.tatashin@oracle.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: steven.sistare@oracle.com
    Cc: daniel.m.jordan@oracle.com
    Cc: linux@armlinux.org.uk
    Cc: schwidefsky@de.ibm.com
    Cc: heiko.carstens@de.ibm.com
    Cc: john.stultz@linaro.org
    Cc: sboyd@codeaurora.org
    Cc: hpa@zytor.com
    Cc: douly.fnst@cn.fujitsu.com
    Cc: peterz@infradead.org
    Cc: prarit@redhat.com
    Cc: feng.tang@intel.com
    Cc: pmladek@suse.com
    Cc: gnomes@lxorguk.ukuu.org.uk
    Cc: linux-s390@vger.kernel.org
    Cc: boris.ostrovsky@oracle.com
    Cc: jgross@suse.com
    Cc: pbonzini@redhat.com
    Link: https://lkml.kernel.org/r/20180719205545.16512-16-pasha.tatashin@oracle.com

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 86bc2026efce..686bc27acef0 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -243,7 +243,8 @@ extern void ktime_get_snapshot(struct system_time_snapshot *systime_snapshot);
 extern int persistent_clock_is_local;
 
 extern void read_persistent_clock64(struct timespec64 *ts);
-extern void read_boot_clock64(struct timespec64 *ts);
+void read_persistent_clock_and_boot_offset(struct timespec64 *wall_clock,
+					   struct timespec64 *boot_offset);
 extern int update_persistent_clock64(struct timespec64 now);
 
 /*

commit 06aa376903b6e8c8741395a4702d78d47c7c27c6
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Apr 27 15:40:16 2018 +0200

    timekeeping: Add more coarse clocktai/boottime interfaces
    
    The set of APIs we provide has a few holes for coarse times, e.g. we
    provide ktime_get_coarse_boottime() and ktime_get_boottime_ts64(),
    but not the combination of the two.
    
    This adds four new functions:
    
    ktime_get_coarse_boottime_ts64()
    ktime_get_boottime_seconds()
    ktime_get_coarse_clocktai_ts64()
    ktime_get_clocktai_seconds()
    
    to fill in some of the missing pieces. I have missed only the
    ktime_get_boottime_seconds() accessor in a few occasions in
    the past, but it seems better to just provide all four together,
    as there is very little cost to having them.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: y2038@lists.linaro.org
    Cc: John Stultz <john.stultz@linaro.org>
    Link: https://lkml.kernel.org/r/20180427134016.2525989-6-arnd@arndb.de

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 42f71f4b658a..86bc2026efce 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -137,18 +137,40 @@ extern u64 ktime_get_boot_fast_ns(void);
 extern u64 ktime_get_real_fast_ns(void);
 
 /*
- * timespec64 interfaces utilizing the ktime based ones
+ * timespec64/time64_t interfaces utilizing the ktime based ones
+ * for API completeness, these could be implemented more efficiently
+ * if needed.
  */
 static inline void ktime_get_boottime_ts64(struct timespec64 *ts)
 {
 	*ts = ktime_to_timespec64(ktime_get_boottime());
 }
 
+static inline void ktime_get_coarse_boottime_ts64(struct timespec64 *ts)
+{
+	*ts = ktime_to_timespec64(ktime_get_coarse_boottime());
+}
+
+static inline time64_t ktime_get_boottime_seconds(void)
+{
+	return ktime_divns(ktime_get_coarse_boottime(), NSEC_PER_SEC);
+}
+
 static inline void ktime_get_clocktai_ts64(struct timespec64 *ts)
 {
 	*ts = ktime_to_timespec64(ktime_get_clocktai());
 }
 
+static inline void ktime_get_coarse_clocktai_ts64(struct timespec64 *ts)
+{
+	*ts = ktime_to_timespec64(ktime_get_coarse_clocktai());
+}
+
+static inline time64_t ktime_get_clocktai_seconds(void)
+{
+	return ktime_divns(ktime_get_coarse_clocktai(), NSEC_PER_SEC);
+}
+
 /*
  * RTC specific
  */

commit b9ff604cff1135cc576cf952d394ed9401aa234b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Apr 27 15:40:15 2018 +0200

    timekeeping: Add ktime_get_coarse_with_offset
    
    I have run into a couple of drivers using current_kernel_time()
    suffering from the y2038 problem, and they could be converted
    to using ktime_t, but don't have interfaces that skip the nanosecond
    calculation at the moment.
    
    This introduces ktime_get_coarse_with_offset() as a simpler
    variant of ktime_get_with_offset(), and adds wrappers for the
    three time domains we support with the existing function.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: y2038@lists.linaro.org
    Cc: John Stultz <john.stultz@linaro.org>
    Link: https://lkml.kernel.org/r/20180427134016.2525989-5-arnd@arndb.de

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 3ef9791d7d75..42f71f4b658a 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -51,6 +51,7 @@ enum tk_offsets {
 
 extern ktime_t ktime_get(void);
 extern ktime_t ktime_get_with_offset(enum tk_offsets offs);
+extern ktime_t ktime_get_coarse_with_offset(enum tk_offsets offs);
 extern ktime_t ktime_mono_to_any(ktime_t tmono, enum tk_offsets offs);
 extern ktime_t ktime_get_raw(void);
 extern u32 ktime_get_resolution_ns(void);
@@ -63,6 +64,11 @@ static inline ktime_t ktime_get_real(void)
 	return ktime_get_with_offset(TK_OFFS_REAL);
 }
 
+static inline ktime_t ktime_get_coarse_real(void)
+{
+	return ktime_get_coarse_with_offset(TK_OFFS_REAL);
+}
+
 /**
  * ktime_get_boottime - Returns monotonic time since boot in ktime_t format
  *
@@ -74,6 +80,11 @@ static inline ktime_t ktime_get_boottime(void)
 	return ktime_get_with_offset(TK_OFFS_BOOT);
 }
 
+static inline ktime_t ktime_get_coarse_boottime(void)
+{
+	return ktime_get_coarse_with_offset(TK_OFFS_BOOT);
+}
+
 /**
  * ktime_get_clocktai - Returns the TAI time of day in ktime_t format
  */
@@ -82,6 +93,11 @@ static inline ktime_t ktime_get_clocktai(void)
 	return ktime_get_with_offset(TK_OFFS_TAI);
 }
 
+static inline ktime_t ktime_get_coarse_clocktai(void)
+{
+	return ktime_get_coarse_with_offset(TK_OFFS_TAI);
+}
+
 /**
  * ktime_mono_to_real - Convert monotonic time to clock realtime
  */

commit fb7fcc96a86cfaef0f6dcc0665516aa68611e736
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Apr 27 15:40:14 2018 +0200

    timekeeping: Standardize on ktime_get_*() naming
    
    The current_kernel_time64, get_monotonic_coarse64, getrawmonotonic64,
    get_monotonic_boottime64 and timekeeping_clocktai64 interfaces have
    rather inconsistent naming, and they differ in the calling conventions
    by passing the output either by reference or as a return value.
    
    Rename them to ktime_get_coarse_real_ts64, ktime_get_coarse_ts64,
    ktime_get_raw_ts64, ktime_get_boottime_ts64 and ktime_get_clocktai_ts64
    respectively, and provide the interfaces with macros or inline
    functions as needed.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: y2038@lists.linaro.org
    Cc: John Stultz <john.stultz@linaro.org>
    Link: https://lkml.kernel.org/r/20180427134016.2525989-4-arnd@arndb.de

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 415dae6bf1f5..3ef9791d7d75 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -19,25 +19,25 @@ extern void xtime_update(unsigned long ticks);
 extern int do_settimeofday64(const struct timespec64 *ts);
 extern int do_sys_settimeofday64(const struct timespec64 *tv,
 				 const struct timezone *tz);
-/*
- * Kernel time accessors
- */
-struct timespec64 current_kernel_time64(void);
 
 /*
  * timespec64 based interfaces
  */
-struct timespec64 get_monotonic_coarse64(void);
-extern void getrawmonotonic64(struct timespec64 *ts);
+extern void ktime_get_raw_ts64(struct timespec64 *ts);
 extern void ktime_get_ts64(struct timespec64 *ts);
 extern void ktime_get_real_ts64(struct timespec64 *tv);
+extern void ktime_get_coarse_ts64(struct timespec64 *ts);
+extern void ktime_get_coarse_real_ts64(struct timespec64 *ts);
+
+void getboottime64(struct timespec64 *ts);
+
+/*
+ * time64_t base interfaces
+ */
 extern time64_t ktime_get_seconds(void);
 extern time64_t __ktime_get_real_seconds(void);
 extern time64_t ktime_get_real_seconds(void);
 
-extern void getboottime64(struct timespec64 *ts);
-
-
 /*
  * ktime_t based interfaces
  */
@@ -123,12 +123,12 @@ extern u64 ktime_get_real_fast_ns(void);
 /*
  * timespec64 interfaces utilizing the ktime based ones
  */
-static inline void get_monotonic_boottime64(struct timespec64 *ts)
+static inline void ktime_get_boottime_ts64(struct timespec64 *ts)
 {
 	*ts = ktime_to_timespec64(ktime_get_boottime());
 }
 
-static inline void timekeeping_clocktai64(struct timespec64 *ts)
+static inline void ktime_get_clocktai_ts64(struct timespec64 *ts)
 {
 	*ts = ktime_to_timespec64(ktime_get_clocktai());
 }
@@ -212,5 +212,26 @@ extern int update_persistent_clock64(struct timespec64 now);
  * deprecated aliases, don't use in new code
  */
 #define getnstimeofday64(ts)		ktime_get_real_ts64(ts)
+#define get_monotonic_boottime64(ts)	ktime_get_boottime_ts64(ts)
+#define getrawmonotonic64(ts)		ktime_get_raw_ts64(ts)
+#define timekeeping_clocktai64(ts)	ktime_get_clocktai_ts64(ts)
+
+static inline struct timespec64 current_kernel_time64(void)
+{
+	struct timespec64 ts;
+
+	ktime_get_coarse_real_ts64(&ts);
+
+	return ts;
+}
+
+static inline struct timespec64 get_monotonic_coarse64(void)
+{
+	struct timespec64 ts;
+
+	ktime_get_coarse_ts64(&ts);
+
+	return ts;
+}
 
 #endif

commit edca71fecb77e2697337d192cbfe96f513407761
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Apr 27 15:40:13 2018 +0200

    timekeeping: Clean up ktime_get_real_ts64
    
    In a move to make ktime_get_*() the preferred driver interface into the
    timekeeping code, sanitizes ktime_get_real_ts64() to be a proper exported
    symbol rather than an alias for getnstimeofday64().
    
    The internal __getnstimeofday64() is no longer used, so remove that
    and merge it into ktime_get_real_ts64().
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: y2038@lists.linaro.org
    Cc: John Stultz <john.stultz@linaro.org>
    Link: https://lkml.kernel.org/r/20180427134016.2525989-3-arnd@arndb.de

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 588a0e4b1ab9..415dae6bf1f5 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -30,15 +30,13 @@ struct timespec64 current_kernel_time64(void);
 struct timespec64 get_monotonic_coarse64(void);
 extern void getrawmonotonic64(struct timespec64 *ts);
 extern void ktime_get_ts64(struct timespec64 *ts);
+extern void ktime_get_real_ts64(struct timespec64 *tv);
 extern time64_t ktime_get_seconds(void);
 extern time64_t __ktime_get_real_seconds(void);
 extern time64_t ktime_get_real_seconds(void);
 
-extern int __getnstimeofday64(struct timespec64 *tv);
-extern void getnstimeofday64(struct timespec64 *tv);
 extern void getboottime64(struct timespec64 *ts);
 
-#define ktime_get_real_ts64(ts)	getnstimeofday64(ts)
 
 /*
  * ktime_t based interfaces
@@ -210,5 +208,9 @@ extern void read_persistent_clock64(struct timespec64 *ts);
 extern void read_boot_clock64(struct timespec64 *ts);
 extern int update_persistent_clock64(struct timespec64 now);
 
+/*
+ * deprecated aliases, don't use in new code
+ */
+#define getnstimeofday64(ts)		ktime_get_real_ts64(ts)
 
 #endif

commit a3ed0e4393d6885b4af7ce84b437dc696490a530
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Apr 25 15:33:38 2018 +0200

    Revert: Unify CLOCK_MONOTONIC and CLOCK_BOOTTIME
    
    Revert commits
    
    92af4dcb4e1c ("tracing: Unify the "boot" and "mono" tracing clocks")
    127bfa5f4342 ("hrtimer: Unify MONOTONIC and BOOTTIME clock behavior")
    7250a4047aa6 ("posix-timers: Unify MONOTONIC and BOOTTIME clock behavior")
    d6c7270e913d ("timekeeping: Remove boot time specific code")
    f2d6fdbfd238 ("Input: Evdev - unify MONOTONIC and BOOTTIME clock behavior")
    d6ed449afdb3 ("timekeeping: Make the MONOTONIC clock behave like the BOOTTIME clock")
    72199320d49d ("timekeeping: Add the new CLOCK_MONOTONIC_ACTIVE clock")
    
    As stated in the pull request for the unification of CLOCK_MONOTONIC and
    CLOCK_BOOTTIME, it was clear that we might have to revert the change.
    
    As reported by several folks systemd and other applications rely on the
    documented behaviour of CLOCK_MONOTONIC on Linux and break with the above
    changes. After resume daemons time out and other timeout related issues are
    observed. Rafael compiled this list:
    
    * systemd kills daemons on resume, after >WatchdogSec seconds
      of suspending (Genki Sky).  [Verified that that's because systemd uses
      CLOCK_MONOTONIC and expects it to not include the suspend time.]
    
    * systemd-journald misbehaves after resume:
      systemd-journald[7266]: File /var/log/journal/016627c3c4784cd4812d4b7e96a34226/system.journal
    corrupted or uncleanly shut down, renaming and replacing.
      (Mike Galbraith).
    
    * NetworkManager reports "networking disabled" and networking is broken
      after resume 50% of the time (Pavel).  [May be because of systemd.]
    
    * MATE desktop dims the display and starts the screensaver right after
      system resume (Pavel).
    
    * Full system hang during resume (me).  [May be due to systemd or NM or both.]
    
    That happens on debian and open suse systems.
    
    It's sad, that these problems were neither catched in -next nor by those
    folks who expressed interest in this change.
    
    Reported-by: Rafael J. Wysocki <rjw@rjwysocki.net>
    Reported-by: Genki Sky <sky@genki.is>,
    Reported-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Kevin Easton <kevin@guarana.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mark Salyzyn <salyzyn@android.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 9737fbec7019..588a0e4b1ab9 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -33,25 +33,20 @@ extern void ktime_get_ts64(struct timespec64 *ts);
 extern time64_t ktime_get_seconds(void);
 extern time64_t __ktime_get_real_seconds(void);
 extern time64_t ktime_get_real_seconds(void);
-extern void ktime_get_active_ts64(struct timespec64 *ts);
 
 extern int __getnstimeofday64(struct timespec64 *tv);
 extern void getnstimeofday64(struct timespec64 *tv);
 extern void getboottime64(struct timespec64 *ts);
 
-#define ktime_get_real_ts64(ts)		getnstimeofday64(ts)
-
-/* Clock BOOTTIME compatibility wrappers */
-static inline void get_monotonic_boottime64(struct timespec64 *ts)
-{
-	ktime_get_ts64(ts);
-}
+#define ktime_get_real_ts64(ts)	getnstimeofday64(ts)
 
 /*
  * ktime_t based interfaces
  */
+
 enum tk_offsets {
 	TK_OFFS_REAL,
+	TK_OFFS_BOOT,
 	TK_OFFS_TAI,
 	TK_OFFS_MAX,
 };
@@ -62,10 +57,6 @@ extern ktime_t ktime_mono_to_any(ktime_t tmono, enum tk_offsets offs);
 extern ktime_t ktime_get_raw(void);
 extern u32 ktime_get_resolution_ns(void);
 
-/* Clock BOOTTIME compatibility wrappers */
-static inline ktime_t ktime_get_boottime(void) { return ktime_get(); }
-static inline u64 ktime_get_boot_ns(void) { return ktime_get(); }
-
 /**
  * ktime_get_real - get the real (wall-) time in ktime_t format
  */
@@ -74,6 +65,17 @@ static inline ktime_t ktime_get_real(void)
 	return ktime_get_with_offset(TK_OFFS_REAL);
 }
 
+/**
+ * ktime_get_boottime - Returns monotonic time since boot in ktime_t format
+ *
+ * This is similar to CLOCK_MONTONIC/ktime_get, but also includes the
+ * time spent in suspend.
+ */
+static inline ktime_t ktime_get_boottime(void)
+{
+	return ktime_get_with_offset(TK_OFFS_BOOT);
+}
+
 /**
  * ktime_get_clocktai - Returns the TAI time of day in ktime_t format
  */
@@ -100,6 +102,11 @@ static inline u64 ktime_get_real_ns(void)
 	return ktime_to_ns(ktime_get_real());
 }
 
+static inline u64 ktime_get_boot_ns(void)
+{
+	return ktime_to_ns(ktime_get_boottime());
+}
+
 static inline u64 ktime_get_tai_ns(void)
 {
 	return ktime_to_ns(ktime_get_clocktai());
@@ -112,11 +119,17 @@ static inline u64 ktime_get_raw_ns(void)
 
 extern u64 ktime_get_mono_fast_ns(void);
 extern u64 ktime_get_raw_fast_ns(void);
+extern u64 ktime_get_boot_fast_ns(void);
 extern u64 ktime_get_real_fast_ns(void);
 
 /*
  * timespec64 interfaces utilizing the ktime based ones
  */
+static inline void get_monotonic_boottime64(struct timespec64 *ts)
+{
+	*ts = ktime_to_timespec64(ktime_get_boottime());
+}
+
 static inline void timekeeping_clocktai64(struct timespec64 *ts)
 {
 	*ts = ktime_to_timespec64(ktime_get_clocktai());

commit cb098d50ecc0a4729507ddcc7f4ae98c3703fadd
Merge: 07820c3bf178 2cf2f0d5b91f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 12 10:21:19 2018 -0700

    Merge tag 'for_linus-4.16' of git://git.kernel.org/pub/scm/linux/kernel/git/jwessel/kgdb
    
    Pull kdb updates from Jason Wessel:
    
     - fix 2032 time access issues and new compiler warnings
    
     - minor regression test cleanup
    
     - formatting fixes for end user use of kdb
    
    * tag 'for_linus-4.16' of git://git.kernel.org/pub/scm/linux/kernel/git/jwessel/kgdb:
      kdb: use memmove instead of overlapping memcpy
      kdb: use ktime_get_mono_fast_ns() instead of ktime_get_ts()
      kdb: bl: don't use tab character in output
      kdb: drop newline in unknown command output
      kdb: make "mdr" command repeat
      kdb: use __ktime_get_real_seconds instead of __current_kernel_time
      misc: kgdbts: Display progress of asynchronous tests

commit 92af4dcb4e1c5f58dc337bc97bdffd4e853dbc93
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 1 17:33:38 2018 +0100

    tracing: Unify the "boot" and "mono" tracing clocks
    
    Unify the "boot" and "mono" tracing clocks and document the new behaviour.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Kevin Easton <kevin@guarana.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mark Salyzyn <salyzyn@android.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/20180301165150.489635255@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index abb396731332..82c219dfd3bb 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -113,12 +113,6 @@ extern u64 ktime_get_mono_fast_ns(void);
 extern u64 ktime_get_raw_fast_ns(void);
 extern u64 ktime_get_real_fast_ns(void);
 
-/* Clock BOOTTIME compatibility wrappers */
-static inline u64 ktime_get_boot_fast_ns(void)
-{
-	return ktime_get_mono_fast_ns();
-}
-
 /*
  * timespec64 interfaces utilizing the ktime based ones
  */

commit d6c7270e913db75ca5fdc79915ba780e97ae2857
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 1 17:33:35 2018 +0100

    timekeeping: Remove boot time specific code
    
    Now that the MONOTONIC and BOOTTIME clocks are the same, remove all the
    special handling from timekeeping. Keep wrappers for the existing users of
    the *boot* timekeeper interfaces.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Kevin Easton <kevin@guarana.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mark Salyzyn <salyzyn@android.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/20180301165150.236279497@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 440b1935d3a5..abb396731332 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -38,15 +38,19 @@ extern int __getnstimeofday64(struct timespec64 *tv);
 extern void getnstimeofday64(struct timespec64 *tv);
 extern void getboottime64(struct timespec64 *ts);
 
-#define ktime_get_real_ts64(ts)	getnstimeofday64(ts)
+#define ktime_get_real_ts64(ts)		getnstimeofday64(ts)
+
+/* Clock BOOTTIME compatibility wrappers */
+static inline void get_monotonic_boottime64(struct timespec64 *ts)
+{
+	ktime_get_ts64(ts);
+}
 
 /*
  * ktime_t based interfaces
  */
-
 enum tk_offsets {
 	TK_OFFS_REAL,
-	TK_OFFS_BOOT,
 	TK_OFFS_TAI,
 	TK_OFFS_MAX,
 };
@@ -57,6 +61,10 @@ extern ktime_t ktime_mono_to_any(ktime_t tmono, enum tk_offsets offs);
 extern ktime_t ktime_get_raw(void);
 extern u32 ktime_get_resolution_ns(void);
 
+/* Clock BOOTTIME compatibility wrappers */
+static inline ktime_t ktime_get_boottime(void) { return ktime_get(); }
+static inline u64 ktime_get_boot_ns(void) { return ktime_get(); }
+
 /**
  * ktime_get_real - get the real (wall-) time in ktime_t format
  */
@@ -65,17 +73,6 @@ static inline ktime_t ktime_get_real(void)
 	return ktime_get_with_offset(TK_OFFS_REAL);
 }
 
-/**
- * ktime_get_boottime - Returns monotonic time since boot in ktime_t format
- *
- * This is similar to CLOCK_MONTONIC/ktime_get, but also includes the
- * time spent in suspend.
- */
-static inline ktime_t ktime_get_boottime(void)
-{
-	return ktime_get_with_offset(TK_OFFS_BOOT);
-}
-
 /**
  * ktime_get_clocktai - Returns the TAI time of day in ktime_t format
  */
@@ -102,11 +99,6 @@ static inline u64 ktime_get_real_ns(void)
 	return ktime_to_ns(ktime_get_real());
 }
 
-static inline u64 ktime_get_boot_ns(void)
-{
-	return ktime_to_ns(ktime_get_boottime());
-}
-
 static inline u64 ktime_get_tai_ns(void)
 {
 	return ktime_to_ns(ktime_get_clocktai());
@@ -119,17 +111,17 @@ static inline u64 ktime_get_raw_ns(void)
 
 extern u64 ktime_get_mono_fast_ns(void);
 extern u64 ktime_get_raw_fast_ns(void);
-extern u64 ktime_get_boot_fast_ns(void);
 extern u64 ktime_get_real_fast_ns(void);
 
-/*
- * timespec64 interfaces utilizing the ktime based ones
- */
-static inline void get_monotonic_boottime64(struct timespec64 *ts)
+/* Clock BOOTTIME compatibility wrappers */
+static inline u64 ktime_get_boot_fast_ns(void)
 {
-	*ts = ktime_to_timespec64(ktime_get_boottime());
+	return ktime_get_mono_fast_ns();
 }
 
+/*
+ * timespec64 interfaces utilizing the ktime based ones
+ */
 static inline void timekeeping_clocktai64(struct timespec64 *ts)
 {
 	*ts = ktime_to_timespec64(ktime_get_clocktai());

commit 72199320d49dbafa1a99f94f1cd60dc90035c154
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 1 17:33:32 2018 +0100

    timekeeping: Add the new CLOCK_MONOTONIC_ACTIVE clock
    
    The planned change to unify the behaviour of the MONOTONIC and BOOTTIME
    clocks vs. suspend removes the ability to retrieve the active
    non-suspended time of a system.
    
    Provide a new CLOCK_MONOTONIC_ACTIVE clock which returns the active
    non-suspended time of the system via clock_gettime().
    
    This preserves the old behaviour of CLOCK_MONOTONIC before the
    BOOTTIME/MONOTONIC unification.
    
    This new clock also allows applications to detect programmatically that
    the MONOTONIC and BOOTTIME clocks are identical.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Kevin Easton <kevin@guarana.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mark Salyzyn <salyzyn@android.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/20180301165149.965235774@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index b17bcce58bc4..440b1935d3a5 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -32,6 +32,7 @@ extern void getrawmonotonic64(struct timespec64 *ts);
 extern void ktime_get_ts64(struct timespec64 *ts);
 extern time64_t ktime_get_seconds(void);
 extern time64_t ktime_get_real_seconds(void);
+extern void ktime_get_active_ts64(struct timespec64 *ts);
 
 extern int __getnstimeofday64(struct timespec64 *tv);
 extern void getnstimeofday64(struct timespec64 *tv);

commit 6909e29fdefbb7aa643021279daef6ed10c81528
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Oct 12 16:06:11 2017 +0200

    kdb: use __ktime_get_real_seconds instead of __current_kernel_time
    
    kdb is the only user of the __current_kernel_time() interface, which is
    not y2038 safe and should be removed at some point.
    
    The kdb code also goes to great lengths to print the time in a
    human-readable format from 'struct timespec', again using a non-y2038-safe
    re-implementation of the generic time_to_tm() code.
    
    Using __current_kernel_time() here is necessary since the regular
    accessors that require a sequence lock might hang when called during the
    xtime update. However, this is safe in the particular case since kdb is
    only interested in the tv_sec field that is updated atomically.
    
    In order to make this y2038-safe, I'm converting the code to the generic
    time64_to_tm helper, but that introduces the problem that we have no
    interface like __current_kernel_time() that provides a 64-bit timestamp
    in a lockless, safe and architecture-independent way. I have multiple
    ideas for how to solve that:
    
    - __ktime_get_real_seconds() is lockless, but can return
      incorrect results on 32-bit architectures in the special case that
      we are in the process of changing the time across the epoch, either
      during the timer tick that overflows the seconds in 2038, or while
      calling settimeofday.
    
    - ktime_get_real_fast_ns() would work in this context, but does
      require a call into the clocksource driver to return a high-resolution
      timestamp. This may have undesired side-effects in the debugger,
      since we want to limit the interactions with the rest of the kernel.
    
    - Adding a ktime_get_real_fast_seconds() based on tk_fast_mono
      plus tkr->base_real without the tk_clock_read() delta. Not sure about
      the value of adding yet another interface here.
    
    - Changing the existing ktime_get_real_seconds() to use
      tk_fast_mono on 32-bit architectures rather than xtime_sec.  I think
      this could work, but am not entirely sure if this is an improvement.
    
    I picked the first of those for simplicity here. It's technically
    not correct but probably good enough as the time is only used for the
    debugging output and the race will likely never be hit in practice.
    Another downside is having to move the declaration into a public header
    file.
    
    Let me know if anyone has a different preference.
    
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://patchwork.kernel.org/patch/9775309/
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index b17bcce58bc4..588a0e4b1ab9 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -31,6 +31,7 @@ struct timespec64 get_monotonic_coarse64(void);
 extern void getrawmonotonic64(struct timespec64 *ts);
 extern void ktime_get_ts64(struct timespec64 *ts);
 extern time64_t ktime_get_seconds(void);
+extern time64_t __ktime_get_real_seconds(void);
 extern time64_t ktime_get_real_seconds(void);
 
 extern int __getnstimeofday64(struct timespec64 *tv);

commit d4bfeabe9ff7967f4b8c24aabf2de1ce3a909cd9
Merge: 8a7a8e1eab92 b29c6ef7bb12
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Nov 14 10:01:49 2017 +0100

    Merge branch 'linus' into timers/urgent
    
    Get upstream changes so dependent patches can be applied.

commit 2bcc673101268dc50e52b83226c5bbf38391e16d
Merge: 670310dfbae0 b24591e2fcf8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 13 17:56:58 2017 -0800

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "Yet another big pile of changes:
    
       - More year 2038 work from Arnd slowly reaching the point where we
         need to think about the syscalls themself.
    
       - A new timer function which allows to conditionally (re)arm a timer
         only when it's either not running or the new expiry time is sooner
         than the armed expiry time. This allows to use a single timer for
         multiple timeout requirements w/o caring about the first expiry
         time at the call site.
    
       - A new NMI safe accessor to clock real time for the printk timestamp
         work. Can be used by tracing, perf as well if required.
    
       - A large number of timer setup conversions from Kees which got
         collected here because either maintainers requested so or they
         simply got ignored. As Kees pointed out already there are a few
         trivial merge conflicts and some redundant commits which was
         unavoidable due to the size of this conversion effort.
    
       - Avoid a redundant iteration in the timer wheel softirq processing.
    
       - Provide a mechanism to treat RTC implementations depending on their
         hardware properties, i.e. don't inflict the write at the 0.5
         seconds boundary which originates from the PC CMOS RTC to all RTCs.
         No functional change as drivers need to be updated separately.
    
       - The usual small updates to core code clocksource drivers. Nothing
         really exciting"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (111 commits)
      timers: Add a function to start/reduce a timer
      pstore: Use ktime_get_real_fast_ns() instead of __getnstimeofday()
      timer: Prepare to change all DEFINE_TIMER() callbacks
      netfilter: ipvs: Convert timers to use timer_setup()
      scsi: qla2xxx: Convert timers to use timer_setup()
      block/aoe: discover_timer: Convert timers to use timer_setup()
      ide: Convert timers to use timer_setup()
      drbd: Convert timers to use timer_setup()
      mailbox: Convert timers to use timer_setup()
      crypto: Convert timers to use timer_setup()
      drivers/pcmcia: omap1: Fix error in automated timer conversion
      ARM: footbridge: Fix typo in timer conversion
      drivers/sgi-xp: Convert timers to use timer_setup()
      drivers/pcmcia: Convert timers to use timer_setup()
      drivers/memstick: Convert timers to use timer_setup()
      drivers/macintosh: Convert timers to use timer_setup()
      hwrng/xgene-rng: Convert timers to use timer_setup()
      auxdisplay: Convert timers to use timer_setup()
      sparc/led: Convert timers to use timer_setup()
      mips: ip22/32: Convert timers to use timer_setup()
      ...

commit 8a7a8e1eab929eb3a5b735a788a23b9731139046
Author: Dou Liyang <douly.fnst@cn.fujitsu.com>
Date:   Mon Nov 13 13:49:04 2017 +0800

    timekeeping: Eliminate the stale declaration of ktime_get_raw_and_real_ts64()
    
    Commit ba26621e63ce got rid of ktime_get_raw_and_real_ts64(), but left its
    declaration behind.
    
    Remove it.
    
    Fixes: ba26621e63ce ("time: Remove duplicated code in ktime_get_raw_and_real()")
    Signed-off-by: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Christopher S. Hall <christopher.s.hall@intel.com>
    Cc: joelaf@google.com
    Cc: arnd@arndb.de
    Cc: gregkh@linuxfoundation.org
    Cc: john.stultz@linaro.org
    Cc: deepa.kernel@gmail.com
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/1510552144-20831-1-git-send-email-douly.fnst@cn.fujitsu.com

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 0021575fe871..51293e1aa4da 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -272,12 +272,6 @@ extern bool timekeeping_rtc_skipresume(void);
 
 extern void timekeeping_inject_sleeptime64(struct timespec64 *delta);
 
-/*
- * PPS accessor
- */
-extern void ktime_get_raw_and_real_ts64(struct timespec64 *ts_raw,
-				        struct timespec64 *ts_real);
-
 /*
  * struct system_time_snapshot - simultaneous raw/real time capture with
  *	counter value

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index ddc229ff6d1e..0021575fe871 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _LINUX_TIMEKEEPING_H
 #define _LINUX_TIMEKEEPING_H
 

commit fb56d689fb1c8f13d4d7168abf3838657b042885
Merge: 6c1e272f962d 6546911ed369
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Oct 31 23:17:28 2017 +0100

    Merge branch 'fortglx/4.15/time' of https://git.linaro.org/people/john.stultz/linux into timers/core
    
    Pull timekeeping updates from John Stultz:
    
     - More y2038 work from Arnd Bergmann
    
     - A new mechanism to allow RTC drivers to specify the resolution of the
       RTC so the suspend/resume code can make informed decisions whether to
       inject the suspended time or not in case of fast suspend/resume cycles.

commit 6546911ed369af8d747215ff8b6144618e91c6ab
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Oct 19 13:14:49 2017 +0200

    time: Move old timekeeping interfaces to timekeeping32.h
    
    The interfaces based on 'struct timespec' and 'unsigned long' seconds
    are no longer recommended for new code, and we are trying to migrate to
    ktime_t based interfaces and other y2038-safe variants.
    
    This moves all the legacy interfaces from linux/timekeeping.h into a
    new timekeeping32.h to better document this.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index ddc229ff6d1e..405beea4e71b 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -15,27 +15,16 @@ extern void xtime_update(unsigned long ticks);
 /*
  * Get and set timeofday
  */
-extern void do_gettimeofday(struct timeval *tv);
 extern int do_settimeofday64(const struct timespec64 *ts);
 extern int do_sys_settimeofday64(const struct timespec64 *tv,
 				 const struct timezone *tz);
 /*
  * Kernel time accessors
  */
-unsigned long get_seconds(void);
 struct timespec64 current_kernel_time64(void);
-/* does not take xtime_lock */
-struct timespec __current_kernel_time(void);
-
-static inline struct timespec current_kernel_time(void)
-{
-	struct timespec64 now = current_kernel_time64();
-
-	return timespec64_to_timespec(now);
-}
 
 /*
- * timespec based interfaces
+ * timespec64 based interfaces
  */
 struct timespec64 get_monotonic_coarse64(void);
 extern void getrawmonotonic64(struct timespec64 *ts);
@@ -47,116 +36,6 @@ extern int __getnstimeofday64(struct timespec64 *tv);
 extern void getnstimeofday64(struct timespec64 *tv);
 extern void getboottime64(struct timespec64 *ts);
 
-#if BITS_PER_LONG == 64
-/**
- * Deprecated. Use do_settimeofday64().
- */
-static inline int do_settimeofday(const struct timespec *ts)
-{
-	return do_settimeofday64(ts);
-}
-
-static inline int __getnstimeofday(struct timespec *ts)
-{
-	return __getnstimeofday64(ts);
-}
-
-static inline void getnstimeofday(struct timespec *ts)
-{
-	getnstimeofday64(ts);
-}
-
-static inline void ktime_get_ts(struct timespec *ts)
-{
-	ktime_get_ts64(ts);
-}
-
-static inline void ktime_get_real_ts(struct timespec *ts)
-{
-	getnstimeofday64(ts);
-}
-
-static inline void getrawmonotonic(struct timespec *ts)
-{
-	getrawmonotonic64(ts);
-}
-
-static inline struct timespec get_monotonic_coarse(void)
-{
-	return get_monotonic_coarse64();
-}
-
-static inline void getboottime(struct timespec *ts)
-{
-	return getboottime64(ts);
-}
-#else
-/**
- * Deprecated. Use do_settimeofday64().
- */
-static inline int do_settimeofday(const struct timespec *ts)
-{
-	struct timespec64 ts64;
-
-	ts64 = timespec_to_timespec64(*ts);
-	return do_settimeofday64(&ts64);
-}
-
-static inline int __getnstimeofday(struct timespec *ts)
-{
-	struct timespec64 ts64;
-	int ret = __getnstimeofday64(&ts64);
-
-	*ts = timespec64_to_timespec(ts64);
-	return ret;
-}
-
-static inline void getnstimeofday(struct timespec *ts)
-{
-	struct timespec64 ts64;
-
-	getnstimeofday64(&ts64);
-	*ts = timespec64_to_timespec(ts64);
-}
-
-static inline void ktime_get_ts(struct timespec *ts)
-{
-	struct timespec64 ts64;
-
-	ktime_get_ts64(&ts64);
-	*ts = timespec64_to_timespec(ts64);
-}
-
-static inline void ktime_get_real_ts(struct timespec *ts)
-{
-	struct timespec64 ts64;
-
-	getnstimeofday64(&ts64);
-	*ts = timespec64_to_timespec(ts64);
-}
-
-static inline void getrawmonotonic(struct timespec *ts)
-{
-	struct timespec64 ts64;
-
-	getrawmonotonic64(&ts64);
-	*ts = timespec64_to_timespec(ts64);
-}
-
-static inline struct timespec get_monotonic_coarse(void)
-{
-	return timespec64_to_timespec(get_monotonic_coarse64());
-}
-
-static inline void getboottime(struct timespec *ts)
-{
-	struct timespec64 ts64;
-
-	getboottime64(&ts64);
-	*ts = timespec64_to_timespec(ts64);
-}
-#endif
-
 #define ktime_get_real_ts64(ts)	getnstimeofday64(ts)
 
 /*
@@ -241,23 +120,13 @@ extern u64 ktime_get_raw_fast_ns(void);
 extern u64 ktime_get_boot_fast_ns(void);
 
 /*
- * Timespec interfaces utilizing the ktime based ones
+ * timespec64 interfaces utilizing the ktime based ones
  */
-static inline void get_monotonic_boottime(struct timespec *ts)
-{
-	*ts = ktime_to_timespec(ktime_get_boottime());
-}
-
 static inline void get_monotonic_boottime64(struct timespec64 *ts)
 {
 	*ts = ktime_to_timespec64(ktime_get_boottime());
 }
 
-static inline void timekeeping_clocktai(struct timespec *ts)
-{
-	*ts = ktime_to_timespec(ktime_get_clocktai());
-}
-
 static inline void timekeeping_clocktai64(struct timespec64 *ts)
 {
 	*ts = ktime_to_timespec64(ktime_get_clocktai());
@@ -340,10 +209,8 @@ extern void ktime_get_snapshot(struct system_time_snapshot *systime_snapshot);
  */
 extern int persistent_clock_is_local;
 
-extern void read_persistent_clock(struct timespec *ts);
 extern void read_persistent_clock64(struct timespec64 *ts);
 extern void read_boot_clock64(struct timespec64 *ts);
-extern int update_persistent_clock(struct timespec now);
 extern int update_persistent_clock64(struct timespec64 now);
 
 

commit 4c3711d7fb4763c63b2654f2d07cbe21ca5aadd4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 31 17:12:48 2017 +0200

    timekeeping: Provide NMI safe access to clock realtime
    
    The configurable printk timestamping wants access to clock realtime. Right
    now there is no ktime_get_real_fast_ns() accessor because reading the
    monotonic base and the realtime offset cannot be done atomically. Contrary
    to boot time this offset can change during runtime and cause half updated
    readouts.
    
    struct tk_read_base was fully packed when the fast timekeeper access was
    implemented. commit ceea5e3771ed ("time: Fix clock->read(clock) race around
    clocksource changes") removed the 'read' function pointer from the
    structure, but of course left the comment stale.
    
    So now the structure can fit a new 64bit member w/o violating the cache
    line constraints.
    
    Add real_base to tk_read_base and update it in the fast timekeeper update
    sequence.
    
    Implement an accessor which follows the same scheme as the accessor to
    clock monotonic, but uses the new real_base to access clock real time.
    
    The runtime overhead for updating real_base is minimal as it just adds two
    cache hot values and stores them into an already dirtied cache line along
    with the other fast timekeeper updates.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead,org>
    Link: https://lkml.kernel.org/r/1505757060-2004-3-git-send-email-prarit@redhat.com

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index ddc229ff6d1e..eb98cbdbb323 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -239,6 +239,7 @@ static inline u64 ktime_get_raw_ns(void)
 extern u64 ktime_get_mono_fast_ns(void);
 extern u64 ktime_get_raw_fast_ns(void);
 extern u64 ktime_get_boot_fast_ns(void);
+extern u64 ktime_get_real_fast_ns(void);
 
 /*
  * Timespec interfaces utilizing the ktime based ones

commit 3c9c12f4b4610dba864038c7822b427816f5893c
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Sun Mar 26 12:04:14 2017 -0700

    time: Change k_clock clock_get() to use timespec64
    
    struct timespec is not y2038 safe on 32 bit machines.  Replace uses of
    struct timespec with struct timespec64 in the kernel.
    
    The syscall interfaces themselves will be changed in a separate series.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Cc: y2038@lists.linaro.org
    Cc: john.stultz@linaro.org
    Cc: arnd@arndb.de
    Link: http://lkml.kernel.org/r/1490555058-4603-4-git-send-email-deepa.kernel@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 3617a78897bb..ddc229ff6d1e 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -258,6 +258,11 @@ static inline void timekeeping_clocktai(struct timespec *ts)
 	*ts = ktime_to_timespec(ktime_get_clocktai());
 }
 
+static inline void timekeeping_clocktai64(struct timespec64 *ts)
+{
+	*ts = ktime_to_timespec64(ktime_get_clocktai());
+}
+
 /*
  * RTC specific
  */

commit 2ac00f17b2e110c67ed2af3713bc04aec62e4608
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Sun Mar 26 12:04:12 2017 -0700

    time: Delete do_sys_setimeofday()
    
    struct timespec is not y2038 safe on 32 bit machines and needs to be
    replaced with struct timespec64.
    
    do_sys_timeofday() is just a wrapper function.  Replace all calls to this
    function with direct calls to do_sys_timeofday64() instead and delete
    do_sys_timeofday().
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Cc: y2038@lists.linaro.org
    Cc: john.stultz@linaro.org
    Cc: arnd@arndb.de
    Cc: linux-alpha@vger.kernel.org
    Link: http://lkml.kernel.org/r/1490555058-4603-2-git-send-email-deepa.kernel@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index b598cbc7b576..3617a78897bb 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -19,21 +19,6 @@ extern void do_gettimeofday(struct timeval *tv);
 extern int do_settimeofday64(const struct timespec64 *ts);
 extern int do_sys_settimeofday64(const struct timespec64 *tv,
 				 const struct timezone *tz);
-static inline int do_sys_settimeofday(const struct timespec *tv,
-				      const struct timezone *tz)
-{
-	struct timespec64 ts64;
-
-	if (!tv)
-		return do_sys_settimeofday64(NULL, tz);
-
-	if (!timespec_valid(tv))
-		return -EINVAL;
-
-	ts64 = timespec_to_timespec64(*tv);
-	return do_sys_settimeofday64(&ts64, tz);
-}
-
 /*
  * Kernel time accessors
  */

commit 93b5a9a7051e51ce50109046af0235268a261ba0
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sun Feb 5 14:53:36 2017 +0100

    sched/headers, timekeeping: Move the timer tick function prototypes to <linux/timekeeping.h>
    
    Move the update_process_times() and xtime_update() prototypes to <linux/timekeeping.h>.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index d2e804e15c3e..b598cbc7b576 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -8,6 +8,10 @@
 void timekeeping_init(void);
 extern int timekeeping_suspended;
 
+/* Architecture timer tick functions: */
+extern void update_process_times(int user);
+extern void xtime_update(unsigned long ticks);
+
 /*
  * Get and set timeofday
  */

commit a5a1d1c2914b5316924c7893eb683a5420ebd3be
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Dec 21 20:32:01 2016 +0100

    clocksource: Use a plain u64 instead of cycle_t
    
    There is no point in having an extra type for extra confusion. u64 is
    unambiguous.
    
    Conversion was done with the following coccinelle script:
    
    @rem@
    @@
    -typedef u64 cycle_t;
    
    @fix@
    typedef cycle_t;
    @@
    -cycle_t
    +u64
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 361f8bf1429d..d2e804e15c3e 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -293,7 +293,7 @@ extern void ktime_get_raw_and_real_ts64(struct timespec64 *ts_raw,
  * @cs_was_changed_seq:	The sequence number of clocksource change events
  */
 struct system_time_snapshot {
-	cycle_t		cycles;
+	u64		cycles;
 	ktime_t		real;
 	ktime_t		raw;
 	unsigned int	clock_was_set_seq;
@@ -321,7 +321,7 @@ struct system_device_crosststamp {
  *	timekeeping code to verify comparibility of two cycle values
  */
 struct system_counterval_t {
-	cycle_t			cycles;
+	u64			cycles;
 	struct clocksource	*cs;
 };
 

commit 948a5312f41658f7b76a598a139ef1f4dea09ca9
Author: Joel Fernandes <joelaf@google.com>
Date:   Mon Nov 28 14:35:22 2016 -0800

    timekeeping: Add a fast and NMI safe boot clock
    
    This boot clock can be used as a tracing clock and will account for
    suspend time.
    
    To keep it NMI safe since we're accessing from tracing, we're not using a
    separate timekeeper with updates to monotonic clock and boot offset
    protected with seqlocks. This has the following minor side effects:
    
    (1) Its possible that a timestamp be taken after the boot offset is updated
    but before the timekeeper is updated. If this happens, the new boot offset
    is added to the old timekeeping making the clock appear to update slightly
    earlier:
       CPU 0                                        CPU 1
       timekeeping_inject_sleeptime64()
       __timekeeping_inject_sleeptime(tk, delta);
                                                    timestamp();
       timekeeping_update(tk, TK_CLEAR_NTP...);
    
    (2) On 32-bit systems, the 64-bit boot offset (tk->offs_boot) may be
    partially updated.  Since the tk->offs_boot update is a rare event, this
    should be a rare occurrence which postprocessing should be able to handle.
    
    Signed-off-by: Joel Fernandes <joelaf@google.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/1480372524-15181-6-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 09168c52ab64..361f8bf1429d 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -249,6 +249,7 @@ static inline u64 ktime_get_raw_ns(void)
 
 extern u64 ktime_get_mono_fast_ns(void);
 extern u64 ktime_get_raw_fast_ns(void);
+extern u64 ktime_get_boot_fast_ns(void);
 
 /*
  * Timespec interfaces utilizing the ktime based ones

commit b536fd587044af02183b3c02690431b93154f0fa
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Sep 22 07:48:17 2016 -0700

    timekeeping: Include the correct header for errno definitions
    
    asm-generic headers are only defaults for architectures.  We need to get
    the proper defintion, which goes through <linux/errno.h> and <asm/errno.h>.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: john.stultz@linaro.org
    Link: http://lkml.kernel.org/r/1474555697-8206-1-git-send-email-hch@lst.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 816b7543f81b..09168c52ab64 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -1,7 +1,7 @@
 #ifndef _LINUX_TIMEKEEPING_H
 #define _LINUX_TIMEKEEPING_H
 
-#include <asm-generic/errno-base.h>
+#include <linux/errno.h>
 
 /* Included from linux/ktime.h */
 

commit dfc2507b26af22b0bbc85251b8545b36d8bc5d72
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Jun 1 11:53:26 2016 -0700

    time: Make settimeofday error checking work again
    
    In commit 86d3473224b0 some of the checking for a valid timeval
    was subtley changed which caused -EINVAL to be returned whenever
    the timeval was null.
    
    However, it is possible to set the timezone data while specifying
    a NULL timeval, which is usually done to handle systems where the
    RTC keeps local time instead of UTC. Thus the patch causes such
    systems to have the time incorrectly set.
    
    This patch addresses the issue by handling the error conditionals
    in the same way as was done previously.
    
    Fixes: 86d3473224b0 "time: Introduce do_sys_settimeofday64()"
    Reported-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Baolin Wang <baolin.wang@linaro.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Link: http://lkml.kernel.org/r/1464807207-16530-2-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 37dbacf84849..816b7543f81b 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -21,6 +21,9 @@ static inline int do_sys_settimeofday(const struct timespec *tv,
 	struct timespec64 ts64;
 
 	if (!tv)
+		return do_sys_settimeofday64(NULL, tz);
+
+	if (!timespec_valid(tv))
 		return -EINVAL;
 
 	ts64 = timespec_to_timespec64(*tv);

commit 86d3473224b004f920c107206d181d37db735145
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Fri Apr 8 14:02:12 2016 +0800

    time: Introduce do_sys_settimeofday64()
    
    The do_sys_settimeofday() function uses a timespec, which is not year
    2038 safe on 32bit systems.
    
    Thus this patch introduces do_sys_settimeofday64(), which allows us to
    transition users of do_sys_settimeofday() to using 64bit time types.
    
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    [jstultz: Include errno-base.h to avoid build issue on some arches]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 96f37bee3bc1..37dbacf84849 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -1,6 +1,8 @@
 #ifndef _LINUX_TIMEKEEPING_H
 #define _LINUX_TIMEKEEPING_H
 
+#include <asm-generic/errno-base.h>
+
 /* Included from linux/ktime.h */
 
 void timekeeping_init(void);
@@ -11,8 +13,19 @@ extern int timekeeping_suspended;
  */
 extern void do_gettimeofday(struct timeval *tv);
 extern int do_settimeofday64(const struct timespec64 *ts);
-extern int do_sys_settimeofday(const struct timespec *tv,
-			       const struct timezone *tz);
+extern int do_sys_settimeofday64(const struct timespec64 *tv,
+				 const struct timezone *tz);
+static inline int do_sys_settimeofday(const struct timespec *tv,
+				      const struct timezone *tz)
+{
+	struct timespec64 ts64;
+
+	if (!tv)
+		return -EINVAL;
+
+	ts64 = timespec_to_timespec64(*tv);
+	return do_sys_settimeofday64(&ts64, tz);
+}
 
 /*
  * Kernel time accessors

commit 2c756feb18d9ec258dbb3a3d11c47e28820690d7
Author: Christopher S. Hall <christopher.s.hall@intel.com>
Date:   Mon Feb 22 03:15:23 2016 -0800

    time: Add history to cross timestamp interface supporting slower devices
    
    Another representative use case of time sync and the correlated
    clocksource (in addition to PTP noted above) is PTP synchronized
    audio.
    
    In a streaming application, as an example, samples will be sent and/or
    received by multiple devices with a presentation time that is in terms
    of the PTP master clock. Synchronizing the audio output on these
    devices requires correlating the audio clock with the PTP master
    clock. The more precise this correlation is, the better the audio
    quality (i.e. out of sync audio sounds bad).
    
    From an application standpoint, to correlate the PTP master clock with
    the audio device clock, the system clock is used as a intermediate
    timebase. The transforms such an application would perform are:
    
        System Clock <-> Audio clock
        System Clock <-> Network Device Clock [<-> PTP Master Clock]
    
    Modern Intel platforms can perform a more accurate cross timestamp in
    hardware (ART,audio device clock).  The audio driver requires
    ART->system time transforms -- the same as required for the network
    driver. These platforms offload audio processing (including
    cross-timestamps) to a DSP which to ensure uninterrupted audio
    processing, communicates and response to the host only once every
    millsecond. As a result is takes up to a millisecond for the DSP to
    receive a request, the request is processed by the DSP, the audio
    output hardware is polled for completion, the result is copied into
    shared memory, and the host is notified. All of these operation occur
    on a millisecond cadence.  This transaction requires about 2 ms, but
    under heavier workloads it may take up to 4 ms.
    
    Adding a history allows these slow devices the option of providing an
    ART value outside of the current interval. In this case, the callback
    provided is an accessor function for the previously obtained counter
    value. If get_system_device_crosststamp() receives a counter value
    previous to cycle_last, it consults the history provided as an
    argument in history_ref and interpolates the realtime and monotonic
    raw system time using the provided counter value. If there are any
    clock discontinuities, e.g. from calling settimeofday(), the monotonic
    raw time is interpolated in the usual way, but the realtime clock time
    is adjusted by scaling the monotonic raw adjustment.
    
    When an accessor function is used a history argument *must* be
    provided. The history is initialized using ktime_get_snapshot() and
    must be called before the counter values are read.
    
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: kevin.b.stanton@intel.com
    Cc: kevin.j.clarke@intel.com
    Cc: hpa@zytor.com
    Cc: jeffrey.t.kirsher@intel.com
    Cc: netdev@vger.kernel.org
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Christopher S. Hall <christopher.s.hall@intel.com>
    [jstultz: Fixed up cycles_t/cycle_t type confusion]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 4a2ca65fc778..96f37bee3bc1 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -272,11 +272,15 @@ extern void ktime_get_raw_and_real_ts64(struct timespec64 *ts_raw,
  * @cycles:	Clocksource counter value to produce the system times
  * @real:	Realtime system time
  * @raw:	Monotonic raw system time
+ * @clock_was_set_seq:	The sequence number of clock was set events
+ * @cs_was_changed_seq:	The sequence number of clocksource change events
  */
 struct system_time_snapshot {
 	cycle_t		cycles;
 	ktime_t		real;
 	ktime_t		raw;
+	unsigned int	clock_was_set_seq;
+	u8		cs_was_changed_seq;
 };
 
 /*
@@ -312,6 +316,7 @@ extern int get_device_system_crosststamp(
 				struct system_counterval_t *system_counterval,
 				void *ctx),
 			void *ctx,
+			struct system_time_snapshot *history,
 			struct system_device_crosststamp *xtstamp);
 
 /*

commit 8006c24595cab106bcb9da12d35e32e14ff492df
Author: Christopher S. Hall <christopher.s.hall@intel.com>
Date:   Mon Feb 22 03:15:22 2016 -0800

    time: Add driver cross timestamp interface for higher precision time synchronization
    
    ACKNOWLEDGMENT: cross timestamp code was developed by Thomas Gleixner
    <tglx@linutronix.de>. It has changed considerably and any mistakes are
    mine.
    
    The precision with which events on multiple networked systems can be
    synchronized using, as an example, PTP (IEEE 1588, 802.1AS) is limited
    by the precision of the cross timestamps between the system clock and
    the device (timestamp) clock. Precision here is the degree of
    simultaneity when capturing the cross timestamp.
    
    Currently the PTP cross timestamp is captured in software using the
    PTP device driver ioctl PTP_SYS_OFFSET. Reads of the device clock are
    interleaved with reads of the realtime clock. At best, the precision
    of this cross timestamp is on the order of several microseconds due to
    software latencies. Sub-microsecond precision is required for
    industrial control and some media applications. To achieve this level
    of precision hardware supported cross timestamping is needed.
    
    The function get_device_system_crosstimestamp() allows device drivers
    to return a cross timestamp with system time properly scaled to
    nanoseconds.  The realtime value is needed to discipline that clock
    using PTP and the monotonic raw value is used for applications that
    don't require a "real" time, but need an unadjusted clock time.  The
    get_device_system_crosstimestamp() code calls back into the driver to
    ensure that the system counter is within the current timekeeping
    update interval.
    
    Modern Intel hardware provides an Always Running Timer (ART) which is
    exactly related to TSC through a known frequency ratio. The ART is
    routed to devices on the system and is used to precisely and
    simultaneously capture the device clock with the ART.
    
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: kevin.b.stanton@intel.com
    Cc: kevin.j.clarke@intel.com
    Cc: hpa@zytor.com
    Cc: jeffrey.t.kirsher@intel.com
    Cc: netdev@vger.kernel.org
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Christopher S. Hall <christopher.s.hall@intel.com>
    [jstultz: Reworked to remove extra structures and simplify calling]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 7817591af46f..4a2ca65fc778 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -279,6 +279,41 @@ struct system_time_snapshot {
 	ktime_t		raw;
 };
 
+/*
+ * struct system_device_crosststamp - system/device cross-timestamp
+ *	(syncronized capture)
+ * @device:		Device time
+ * @sys_realtime:	Realtime simultaneous with device time
+ * @sys_monoraw:	Monotonic raw simultaneous with device time
+ */
+struct system_device_crosststamp {
+	ktime_t device;
+	ktime_t sys_realtime;
+	ktime_t sys_monoraw;
+};
+
+/*
+ * struct system_counterval_t - system counter value with the pointer to the
+ *	corresponding clocksource
+ * @cycles:	System counter value
+ * @cs:		Clocksource corresponding to system counter value. Used by
+ *	timekeeping code to verify comparibility of two cycle values
+ */
+struct system_counterval_t {
+	cycle_t			cycles;
+	struct clocksource	*cs;
+};
+
+/*
+ * Get cross timestamp between system clock and device clock
+ */
+extern int get_device_system_crosststamp(
+			int (*get_time_fn)(ktime_t *device_time,
+				struct system_counterval_t *system_counterval,
+				void *ctx),
+			void *ctx,
+			struct system_device_crosststamp *xtstamp);
+
 /*
  * Simultaneously snapshot realtime and monotonic raw clocks
  */

commit 9da0f49c8767cc0ef6101cb21156cf4380ed50dd
Author: Christopher S. Hall <christopher.s.hall@intel.com>
Date:   Mon Feb 22 03:15:20 2016 -0800

    time: Add timekeeping snapshot code capturing system time and counter
    
    In the current timekeeping code there isn't any interface to
    atomically capture the current relationship between the system counter
    and system time. ktime_get_snapshot() returns this triple (counter,
    monotonic raw, realtime) in the system_time_snapshot struct.
    
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: kevin.b.stanton@intel.com
    Cc: kevin.j.clarke@intel.com
    Cc: hpa@zytor.com
    Cc: jeffrey.t.kirsher@intel.com
    Cc: netdev@vger.kernel.org
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Christopher S. Hall <christopher.s.hall@intel.com>
    [jstultz: Moved structure definitions around to clean things up,
     fixed cycles_t/cycle_t confusion.]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index ec89d846324c..7817591af46f 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -266,6 +266,24 @@ extern void timekeeping_inject_sleeptime64(struct timespec64 *delta);
 extern void ktime_get_raw_and_real_ts64(struct timespec64 *ts_raw,
 				        struct timespec64 *ts_real);
 
+/*
+ * struct system_time_snapshot - simultaneous raw/real time capture with
+ *	counter value
+ * @cycles:	Clocksource counter value to produce the system times
+ * @real:	Realtime system time
+ * @raw:	Monotonic raw system time
+ */
+struct system_time_snapshot {
+	cycle_t		cycles;
+	ktime_t		real;
+	ktime_t		raw;
+};
+
+/*
+ * Simultaneously snapshot realtime and monotonic raw clocks
+ */
+extern void ktime_get_snapshot(struct system_time_snapshot *systime_snapshot);
+
 /*
  * Persistent clock related interfaces
  */

commit 071eee45b1650d53d21c636d344bdcebd4577ed2
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Sep 28 22:21:29 2015 +0200

    ntp/pps: replace getnstime_raw_and_real with 64-bit version
    
    There is exactly one caller of getnstime_raw_and_real in the kernel,
    which is the pps_get_ts function. This changes the caller and
    the implementation to work on timespec64 types rather than timespec,
    to avoid the time_t overflow on 32-bit architectures.
    
    For consistency with the other new functions (ktime_get_seconds,
    ktime_get_real_*, ...), I'm renaming the function to
    ktime_get_raw_and_real_ts64.
    
    We still need to convert from the internal 64-bit type to 32 bit
    types in the caller, but this conversion is now pushed out from
    getnstime_raw_and_real to pps_get_ts. A follow-up patch changes
    the remaining pps code to completely avoid the conversion.
    
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index ba0ae09cbb21..ec89d846324c 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -263,8 +263,8 @@ extern void timekeeping_inject_sleeptime64(struct timespec64 *delta);
 /*
  * PPS accessor
  */
-extern void getnstime_raw_and_real(struct timespec *ts_raw,
-				   struct timespec *ts_real);
+extern void ktime_get_raw_and_real_ts64(struct timespec64 *ts_raw,
+				        struct timespec64 *ts_real);
 
 /*
  * Persistent clock related interfaces

commit 05ddaa4d6d3806bebdf14f7c5de742a6e0e3b689
Merge: b48362d8aaf3 9ca308506062
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 20 21:13:22 2015 +0200

    Merge branch 'fortglx/4.3/time' of https://git.linaro.org/people/john.stultz/linux into timers/core
    
    - A handful or y2038 related items
    - A walltime to monotonic limit
    - Small fixes for timespec_trunc() and timer_list output

commit 8758a240e2d74c5932ab51a73377e6507b7fd441
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Wed Jul 29 20:09:43 2015 +0800

    time: Introduce current_kernel_time64()
    
    The current_kernel_time() is not year 2038 safe on 32bit systems
    since it returns a timespec value. Introduce current_kernel_time64()
    which returns a timespec64 value.
    
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 3aa72e648650..657ea03fff40 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -18,10 +18,17 @@ extern int do_sys_settimeofday(const struct timespec *tv,
  * Kernel time accessors
  */
 unsigned long get_seconds(void);
-struct timespec current_kernel_time(void);
+struct timespec64 current_kernel_time64(void);
 /* does not take xtime_lock */
 struct timespec __current_kernel_time(void);
 
+static inline struct timespec current_kernel_time(void)
+{
+	struct timespec64 now = current_kernel_time64();
+
+	return timespec64_to_timespec(now);
+}
+
 /*
  * timespec based interfaces
  */

commit 1f6823faa8c563431a94e614d2b63ce16bb6f658
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jul 9 10:51:46 2015 +0200

    time: Get rid of do_posix_clock_monotonic_gettime
    
    All users gone. Remove it before we get another one.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 3aa72e648650..6e191e4e6ab6 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -145,7 +145,6 @@ static inline void getboottime(struct timespec *ts)
 }
 #endif
 
-#define do_posix_clock_monotonic_gettime(ts) ktime_get_ts(ts)
 #define ktime_get_real_ts64(ts)	getnstimeofday64(ts)
 
 /*

commit e83d0a4106d81dd08b70318f078f3bad6acdc110
Author: Xunlei Pang <pang.xunlei@linaro.org>
Date:   Thu Apr 9 09:04:42 2015 +0800

    time: Remove read_boot_clock()
    
    Now that we have a read_boot_clock64() function available on every
    architecture, and converted all the users to it, it's time to remove
    the (now unused) read_boot_clock() completely from the kernel.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Xunlei Pang <pang.xunlei@linaro.org>
    [jstultz: Minor commit message tweak suggested by Ingo]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 9af5c1214682..3aa72e648650 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -267,7 +267,6 @@ extern int persistent_clock_is_local;
 
 extern void read_persistent_clock(struct timespec *ts);
 extern void read_persistent_clock64(struct timespec64 *ts);
-extern void read_boot_clock(struct timespec *ts);
 extern void read_boot_clock64(struct timespec64 *ts);
 extern int update_persistent_clock(struct timespec now);
 extern int update_persistent_clock64(struct timespec64 now);

commit 6374f9124efea5fae9cba263108583c39e22f86b
Author: Harald Geyer <harald@ccbib.org>
Date:   Tue Apr 7 11:12:35 2015 +0000

    timekeeping: Provide new API to get the current time resolution
    
    This patch series introduces a new function
    u32 ktime_get_resolution_ns(void)
    which allows to clean up some driver code.
    
    In particular the IIO subsystem has a function to provide timestamps for
    events but no means to get their resolution. So currently the dht11 driver
    tries to guess the resolution in a rather messy and convoluted way. We
    can do much better with the new code.
    
    This API is not designed to be exposed to user space.
    
    This has been tested on i386, sunxi and mxs.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Harald Geyer <harald@ccbib.org>
    [jstultz: Tweaked to make it build after upstream changes]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 99176af216af..9af5c1214682 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -163,6 +163,7 @@ extern ktime_t ktime_get(void);
 extern ktime_t ktime_get_with_offset(enum tk_offsets offs);
 extern ktime_t ktime_mono_to_any(ktime_t tmono, enum tk_offsets offs);
 extern ktime_t ktime_get_raw(void);
+extern u32 ktime_get_resolution_ns(void);
 
 /**
  * ktime_get_real - get the real (wall-) time in ktime_t format

commit 0fa88cb4b82b5cf7429bc1cef9db006ca035754e
Author: Xunlei Pang <pang.xunlei@linaro.org>
Date:   Wed Apr 1 20:34:38 2015 -0700

    time, drivers/rtc: Don't bother with rtc_resume() for the nonstop clocksource
    
    If a system does not provide a persistent_clock(), the time
    will be updated on resume by rtc_resume(). With the addition
    of the non-stop clocksources for suspend timing, those systems
    set the time on resume in timekeeping_resume(), but may not
    provide a valid persistent_clock().
    
    This results in the rtc_resume() logic thinking no one has set
    the time and it then will over-write the suspend time again,
    which is not necessary and only increases clock error.
    
    So, fix this for rtc_resume().
    
    This patch also improves the name of persistent_clock_exist to
    make it more grammatical.
    
    Signed-off-by: Xunlei Pang <pang.xunlei@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1427945681-29972-19-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 7a2369d5b3f4..99176af216af 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -248,6 +248,9 @@ static inline void timekeeping_clocktai(struct timespec *ts)
 /*
  * RTC specific
  */
+extern bool timekeeping_rtc_skipsuspend(void);
+extern bool timekeeping_rtc_skipresume(void);
+
 extern void timekeeping_inject_sleeptime64(struct timespec64 *delta);
 
 /*
@@ -259,14 +262,8 @@ extern void getnstime_raw_and_real(struct timespec *ts_raw,
 /*
  * Persistent clock related interfaces
  */
-extern bool persistent_clock_exist;
 extern int persistent_clock_is_local;
 
-static inline bool has_persistent_clock(void)
-{
-	return persistent_clock_exist;
-}
-
 extern void read_persistent_clock(struct timespec *ts);
 extern void read_persistent_clock64(struct timespec64 *ts);
 extern void read_boot_clock(struct timespec *ts);

commit 3c00a1fe8496ff29ab62764bb3f4ce4b48089004
Author: Xunlei Pang <pang.xunlei@linaro.org>
Date:   Wed Apr 1 20:34:23 2015 -0700

    time: Add y2038 safe update_persistent_clock64()
    
    As part of addressing in-kernel y2038 issues, this patch adds
    update_persistent_clock64() and replaces all the call sites of
    update_persistent_clock() with this function. This is a __weak
    implementation, which simply calls the existing y2038 unsafe
    update_persistent_clock().
    
    This allows architecture specific implementations to be
    converted independently, and eventually y2038-unsafe
    update_persistent_clock() can be removed after all its
    architecture specific implementations have been converted to
    update_persistent_clock64().
    
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Xunlei Pang <pang.xunlei@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1427945681-29972-4-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 4c0f76f4616c..7a2369d5b3f4 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -272,6 +272,7 @@ extern void read_persistent_clock64(struct timespec64 *ts);
 extern void read_boot_clock(struct timespec *ts);
 extern void read_boot_clock64(struct timespec64 *ts);
 extern int update_persistent_clock(struct timespec now);
+extern int update_persistent_clock64(struct timespec64 now);
 
 
 #endif

commit 2ee966320028ac846654eba5344540eeb4dc228d
Author: Xunlei Pang <pang.xunlei@linaro.org>
Date:   Wed Apr 1 20:34:22 2015 -0700

    time: Add y2038 safe read_persistent_clock64()
    
    As part of addressing in-kernel y2038 issues, this patch adds
    read_persistent_clock64() and replaces all the call sites of
    read_persistent_clock() with this function. This is a __weak
    implementation, which simply calls the existing y2038 unsafe
    read_persistent_clock().
    
    This allows architecture specific implementations to be
    converted independently, and eventually the y2038 unsafe
    read_persistent_clock() can be removed after all its
    architecture specific implementations have been converted to
    read_persistent_clock64().
    
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Xunlei Pang <pang.xunlei@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1427945681-29972-3-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 18d27a3f72ca..4c0f76f4616c 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -268,6 +268,7 @@ static inline bool has_persistent_clock(void)
 }
 
 extern void read_persistent_clock(struct timespec *ts);
+extern void read_persistent_clock64(struct timespec64 *ts);
 extern void read_boot_clock(struct timespec *ts);
 extern void read_boot_clock64(struct timespec64 *ts);
 extern int update_persistent_clock(struct timespec now);

commit 9a806ddbb9a18c510e4acdcc828b9a87f5fd3aef
Author: Xunlei Pang <pang.xunlei@linaro.org>
Date:   Wed Apr 1 20:34:21 2015 -0700

    time: Add y2038 safe read_boot_clock64()
    
    As part of addressing in-kernel y2038 issues, this patch adds
    read_boot_clock64() and replaces all the call sites of
    read_boot_clock() with this function. This is a __weak
    implementation, which simply calls the existing y2038 unsafe
    read_boot_clock().
    
    This allows architecture specific implementations to be
    converted independently, and eventually the y2038 unsafe
    read_boot_clock() can be removed after all its architecture
    specific implementations have been converted to
    read_boot_clock64().
    
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Xunlei Pang <pang.xunlei@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1427945681-29972-2-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 5047b83483d6..18d27a3f72ca 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -269,6 +269,7 @@ static inline bool has_persistent_clock(void)
 
 extern void read_persistent_clock(struct timespec *ts);
 extern void read_boot_clock(struct timespec *ts);
+extern void read_boot_clock64(struct timespec64 *ts);
 extern int update_persistent_clock(struct timespec now);
 
 

commit fe5fba05b46c791c95a9f34228ac495f81f72fc0
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Tue Mar 17 12:39:10 2015 +0100

    time: Add ktime_get_tai_ns()
    
    Because it was the only clock for which we didn't have a _ns()
    accessor yet.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index f36b1edf3f73..5047b83483d6 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -214,6 +214,11 @@ static inline u64 ktime_get_boot_ns(void)
 	return ktime_to_ns(ktime_get_boottime());
 }
 
+static inline u64 ktime_get_tai_ns(void)
+{
+	return ktime_to_ns(ktime_get_clocktai());
+}
+
 static inline u64 ktime_get_raw_ns(void)
 {
 	return ktime_to_ns(ktime_get_raw());

commit f09cb9a1808e35ad7502ea39b6bfb443c7fa0f19
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Thu Mar 19 09:39:08 2015 +0100

    time: Introduce tk_fast_raw
    
    Add the NMI safe CLOCK_MONOTONIC_RAW accessor..
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20150319093400.562746929@infradead.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 3eaae4754275..f36b1edf3f73 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -220,6 +220,7 @@ static inline u64 ktime_get_raw_ns(void)
 }
 
 extern u64 ktime_get_mono_fast_ns(void);
+extern u64 ktime_get_raw_fast_ns(void);
 
 /*
  * Timespec interfaces utilizing the ktime based ones

commit 2e0c78ee5ba4d777ecf22c8f40cc968b4308ca88
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Dec 18 18:04:34 2014 -0800

    time: Expose get_monotonic_boottime64 for in-kernel use
    
    As part of the 2038 conversion process, add a
    get_monotonic_boottime64 accessor so we can depracate
    get_monotonic_boottime.
    
    Cc: pang.xunlei <pang.xunlei@linaro.org>
    Cc: Arnd Bergmann <arnd.bergmann@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 91480137aa39..3eaae4754275 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -229,6 +229,11 @@ static inline void get_monotonic_boottime(struct timespec *ts)
 	*ts = ktime_to_timespec(ktime_get_boottime());
 }
 
+static inline void get_monotonic_boottime64(struct timespec64 *ts)
+{
+	*ts = ktime_to_timespec64(ktime_get_boottime());
+}
+
 static inline void timekeeping_clocktai(struct timespec *ts)
 {
 	*ts = ktime_to_timespec(ktime_get_clocktai());

commit d08c0cdd26d48751c15aa2b4479a410594fee9ac
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Dec 8 12:00:09 2014 -0800

    time: Expose getboottime64 for in-kernel uses
    
    Adds a timespec64 based getboottime64() implementation
    that can be used as we convert internal users of
    getboottime away from using timespecs.
    
    Cc: pang.xunlei <pang.xunlei@linaro.org>
    Cc: Arnd Bergmann <arnd.bergmann@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 9b63d13ba82b..91480137aa39 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -33,6 +33,7 @@ extern time64_t ktime_get_real_seconds(void);
 
 extern int __getnstimeofday64(struct timespec64 *tv);
 extern void getnstimeofday64(struct timespec64 *tv);
+extern void getboottime64(struct timespec64 *ts);
 
 #if BITS_PER_LONG == 64
 /**
@@ -72,6 +73,11 @@ static inline struct timespec get_monotonic_coarse(void)
 {
 	return get_monotonic_coarse64();
 }
+
+static inline void getboottime(struct timespec *ts)
+{
+	return getboottime64(ts);
+}
 #else
 /**
  * Deprecated. Use do_settimeofday64().
@@ -129,9 +135,15 @@ static inline struct timespec get_monotonic_coarse(void)
 {
 	return timespec64_to_timespec(get_monotonic_coarse64());
 }
-#endif
 
-extern void getboottime(struct timespec *ts);
+static inline void getboottime(struct timespec *ts)
+{
+	struct timespec64 ts64;
+
+	getboottime64(&ts64);
+	*ts = timespec64_to_timespec(ts64);
+}
+#endif
 
 #define do_posix_clock_monotonic_gettime(ts) ktime_get_ts(ts)
 #define ktime_get_real_ts64(ts)	getnstimeofday64(ts)

commit d82012695ef29e4e1c8153ccf43098ec8e50369e
Merge: 3eb5b893ebec dbe7aa622db9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 10 10:13:28 2014 -0800

    Merge branch 'timers-2038-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull more 2038 timer work from Thomas Gleixner:
     "Two more patches for the ongoing 2038 work:
    
       - New accessors to clock MONOTONIC and REALTIME seconds
    
      This is a seperate branch as Arnd has follow up work depending on
      this"
    
    * 'timers-2038-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      timekeeping: Provide y2038 safe accessor to the seconds portion of CLOCK_REALTIME
      timekeeping: Provide fast accessor to the seconds part of CLOCK_MONOTONIC

commit 21b6c0512e8aca75ce76365e1aef9fb16e007100
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Nov 20 21:19:15 2014 -0800

    time: Remove timekeeping_inject_sleeptime()
    
    Since all users have been converted to using the 64bit
    timekeeping_inject_sleeptime64(), remove the old y2038
    problematic timekeeping_inject_sleeptime().
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 8cab4b754be7..961fea373f83 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -225,17 +225,6 @@ static inline void timekeeping_clocktai(struct timespec *ts)
  */
 extern void timekeeping_inject_sleeptime64(struct timespec64 *delta);
 
-/**
- * Deprecated. Use timekeeping_inject_sleeptime64().
- */
-static inline void timekeeping_inject_sleeptime(struct timespec *delta)
-{
-	struct timespec64 delta64;
-
-	delta64 = timespec_to_timespec64(*delta);
-	timekeeping_inject_sleeptime64(&delta64);
-}
-
 /*
  * PPS accessor
  */

commit 334334b5f577a2255e29d2352d53197d9b796511
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Nov 7 11:20:40 2014 -0800

    time: Expose get_monotonic_coarse64() for in-kernel uses
    
    Adds a timespec64 based get_monotonic_coarse64() implementation
    that can be used as we convert internal users of
    get_monotonic_coarse away from using timespecs.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index e40a8d60fb21..8cab4b754be7 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -25,7 +25,7 @@ struct timespec __current_kernel_time(void);
 /*
  * timespec based interfaces
  */
-struct timespec get_monotonic_coarse(void);
+struct timespec64 get_monotonic_coarse64(void);
 extern void getrawmonotonic64(struct timespec64 *ts);
 extern void ktime_get_ts64(struct timespec64 *ts);
 
@@ -66,6 +66,10 @@ static inline void getrawmonotonic(struct timespec *ts)
 	getrawmonotonic64(ts);
 }
 
+static inline struct timespec get_monotonic_coarse(void)
+{
+	return get_monotonic_coarse64();
+}
 #else
 /**
  * Deprecated. Use do_settimeofday64().
@@ -118,6 +122,11 @@ static inline void getrawmonotonic(struct timespec *ts)
 	getrawmonotonic64(&ts64);
 	*ts = timespec64_to_timespec(ts64);
 }
+
+static inline struct timespec get_monotonic_coarse(void)
+{
+	return timespec64_to_timespec(get_monotonic_coarse64());
+}
 #endif
 
 extern void getboottime(struct timespec *ts);

commit cdba2ec538d9843c42cac15ff4ec54dc2ac53f8a
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Nov 7 11:03:20 2014 -0800

    time: Expose getrawmonotonic64 for in-kernel uses
    
    Adds a timespec64 based getrawmonotonic64() implementation
    that can be used as we convert internal users of
    getrawmonotonic away from using timespecs.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 6d76c6502892..e40a8d60fb21 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -26,7 +26,7 @@ struct timespec __current_kernel_time(void);
  * timespec based interfaces
  */
 struct timespec get_monotonic_coarse(void);
-extern void getrawmonotonic(struct timespec *ts);
+extern void getrawmonotonic64(struct timespec64 *ts);
 extern void ktime_get_ts64(struct timespec64 *ts);
 
 extern int __getnstimeofday64(struct timespec64 *tv);
@@ -61,6 +61,11 @@ static inline void ktime_get_real_ts(struct timespec *ts)
 	getnstimeofday64(ts);
 }
 
+static inline void getrawmonotonic(struct timespec *ts)
+{
+	getrawmonotonic64(ts);
+}
+
 #else
 /**
  * Deprecated. Use do_settimeofday64().
@@ -105,6 +110,14 @@ static inline void ktime_get_real_ts(struct timespec *ts)
 	getnstimeofday64(&ts64);
 	*ts = timespec64_to_timespec(ts64);
 }
+
+static inline void getrawmonotonic(struct timespec *ts)
+{
+	struct timespec64 ts64;
+
+	getrawmonotonic64(&ts64);
+	*ts = timespec64_to_timespec(ts64);
+}
 #endif
 
 extern void getboottime(struct timespec *ts);

commit 04d9089086a8231ddc69a9f3f25e971a3c1d25e6
Author: pang.xunlei <pang.xunlei@linaro.org>
Date:   Tue Nov 18 19:15:17 2014 +0800

    time: Provide y2038 safe timekeeping_inject_sleeptime() replacement
    
    As part of addressing "y2038 problem" for in-kernel uses, this
    patch adds timekeeping_inject_sleeptime64() using timespec64.
    
    After this patch, timekeeping_inject_sleeptime() is deprecated
    and all its call sites will be fixed using the new interface,
    after that it can be removed.
    
    NOTE: timekeeping_inject_sleeptime() is safe actually, but we
    want to eliminate timespec eventually, so comes this patch.
    
    Signed-off-by: pang.xunlei <pang.xunlei@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 071ad7e0c981..6d76c6502892 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -201,7 +201,18 @@ static inline void timekeeping_clocktai(struct timespec *ts)
 /*
  * RTC specific
  */
-extern void timekeeping_inject_sleeptime(struct timespec *delta);
+extern void timekeeping_inject_sleeptime64(struct timespec64 *delta);
+
+/**
+ * Deprecated. Use timekeeping_inject_sleeptime64().
+ */
+static inline void timekeeping_inject_sleeptime(struct timespec *delta)
+{
+	struct timespec64 delta64;
+
+	delta64 = timespec_to_timespec64(*delta);
+	timekeeping_inject_sleeptime64(&delta64);
+}
 
 /*
  * PPS accessor

commit 21f7eca555ad14e7c7b2cb59a6c6252e74ee5c8b
Author: pang.xunlei <pang.xunlei@linaro.org>
Date:   Tue Nov 18 19:15:16 2014 +0800

    time: Provide y2038 safe do_settimeofday() replacement
    
    The kernel uses 32-bit signed value(time_t) for seconds elapsed
    1970-01-01:00:00:00, thus it will overflow at 2038-01-19 03:14:08
    on 32-bit systems. This is widely known as the y2038 problem.
    
    As part of addressing "y2038 problem" for in-kernel uses, this patch
    adds safe do_settimeofday64() using timespec64.
    
    After this patch, do_settimeofday() is deprecated and all its call
    sites will be fixed using do_settimeofday64(), after that it can be
    removed.
    
    Signed-off-by: pang.xunlei <pang.xunlei@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 1caa6b04fdc5..071ad7e0c981 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -10,7 +10,7 @@ extern int timekeeping_suspended;
  * Get and set timeofday
  */
 extern void do_gettimeofday(struct timeval *tv);
-extern int do_settimeofday(const struct timespec *tv);
+extern int do_settimeofday64(const struct timespec64 *ts);
 extern int do_sys_settimeofday(const struct timespec *tv,
 			       const struct timezone *tz);
 
@@ -33,6 +33,14 @@ extern int __getnstimeofday64(struct timespec64 *tv);
 extern void getnstimeofday64(struct timespec64 *tv);
 
 #if BITS_PER_LONG == 64
+/**
+ * Deprecated. Use do_settimeofday64().
+ */
+static inline int do_settimeofday(const struct timespec *ts)
+{
+	return do_settimeofday64(ts);
+}
+
 static inline int __getnstimeofday(struct timespec *ts)
 {
 	return __getnstimeofday64(ts);
@@ -54,6 +62,17 @@ static inline void ktime_get_real_ts(struct timespec *ts)
 }
 
 #else
+/**
+ * Deprecated. Use do_settimeofday64().
+ */
+static inline int do_settimeofday(const struct timespec *ts)
+{
+	struct timespec64 ts64;
+
+	ts64 = timespec_to_timespec64(*ts);
+	return do_settimeofday64(&ts64);
+}
+
 static inline int __getnstimeofday(struct timespec *ts)
 {
 	struct timespec64 ts64;

commit dbe7aa622db96b5cd601f59d09c4f00b98b76079
Author: Heena Sirwani <heenasirwani@gmail.com>
Date:   Wed Oct 29 16:01:50 2014 +0530

    timekeeping: Provide y2038 safe accessor to the seconds portion of CLOCK_REALTIME
    
    ktime_get_real_seconds() is the replacement function for get_seconds()
    returning the seconds portion of CLOCK_REALTIME in a time64_t. For
    64bit the function is equivivalent to get_seconds(), but for 32bit it
    protects the readout with the timekeeper sequence count. This is
    required because 32-bit machines cannot access 64-bit tk->xtime_sec
    variable atomically.
    
    [tglx: Massaged changelog and added docbook comment ]
    
    Signed-off-by: Heena Sirwani <heenasirwani@gmail.com>
    Reviewed-by: Arnd Bergman <arnd@arndb.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: opw-kernel@googlegroups.com
    Link: http://lkml.kernel.org/r/7adcfaa8962b8ad58785d9a2456c3f77d93c0ffb.1414578445.git.heenasirwani@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 115d55e11bc9..91454dea2bc6 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -29,6 +29,7 @@ struct timespec get_monotonic_coarse(void);
 extern void getrawmonotonic(struct timespec *ts);
 extern void ktime_get_ts64(struct timespec64 *ts);
 extern time64_t ktime_get_seconds(void);
+extern time64_t ktime_get_real_seconds(void);
 
 extern int __getnstimeofday64(struct timespec64 *tv);
 extern void getnstimeofday64(struct timespec64 *tv);

commit 9e3680b1750b9a62680b0262c9f438de98b77655
Author: Heena Sirwani <heenasirwani@gmail.com>
Date:   Wed Oct 29 16:01:16 2014 +0530

    timekeeping: Provide fast accessor to the seconds part of CLOCK_MONOTONIC
    
    This is the counterpart to get_seconds() based on CLOCK_MONOTONIC. The
    use case for this interface are kernel internal coarse grained
    timestamps which do neither require the nanoseconds fraction of
    current time nor the CLOCK_REALTIME properties. Such timestamps can
    currently only retrieved by calling ktime_get_ts64() and using the
    tv_sec field of the returned timespec64. That's inefficient as it
    involves the read of the clocksource, math operations and must be
    protected by the timekeeper sequence counter.
    
    To avoid the sequence counter protection we restrict the return value
    to unsigned 32bit on 32bit machines. This covers ~136 years of uptime
    and therefor an overflow is not expected to hit anytime soon.
    
    To avoid math in the function we calculate the current seconds portion
    of CLOCK_MONOTONIC when the timekeeper gets updated in
    tk_update_ktime_data() similar to the CLOCK_REALTIME counterpart
    xtime_sec.
    
    [ tglx: Massaged changelog, simplified and commented the update
            function, added docbook comment ]
    
    Signed-off-by: Heena Sirwani <heenasirwani@gmail.com>
    Reviewed-by: Arnd Bergman <arnd@arndb.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: opw-kernel@googlegroups.com
    Link: http://lkml.kernel.org/r/da0b63f4bdf3478909f92becb35861197da3a905.1414578445.git.heenasirwani@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 1caa6b04fdc5..115d55e11bc9 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -28,6 +28,7 @@ struct timespec __current_kernel_time(void);
 struct timespec get_monotonic_coarse(void);
 extern void getrawmonotonic(struct timespec *ts);
 extern void ktime_get_ts64(struct timespec64 *ts);
+extern time64_t ktime_get_seconds(void);
 
 extern int __getnstimeofday64(struct timespec64 *tv);
 extern void getnstimeofday64(struct timespec64 *tv);

commit 4396e058c52e167729729cf64ea3dfa229637086
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:05:23 2014 +0000

    timekeeping: Provide fast and NMI safe access to CLOCK_MONOTONIC
    
    Tracers want a correlated time between the kernel instrumentation and
    user space. We really do not want to export sched_clock() to user
    space, so we need to provide something sensible for this.
    
    Using separate data structures with an non blocking sequence count
    based update mechanism allows us to do that. The data structure
    required for the readout has a sequence counter and two copies of the
    timekeeping data.
    
    On the update side:
    
      smp_wmb();
      tkf->seq++;
      smp_wmb();
      update(tkf->base[0], tk);
      smp_wmb();
      tkf->seq++;
      smp_wmb();
      update(tkf->base[1], tk);
    
    On the reader side:
    
      do {
         seq = tkf->seq;
         smp_rmb();
         idx = seq & 0x01;
         now = now(tkf->base[idx]);
         smp_rmb();
      } while (seq != tkf->seq)
    
    So if a NMI hits the update of base[0] it will use base[1] which is
    still consistent, but this timestamp is not guaranteed to be monotonic
    across an update.
    
    The timestamp is calculated by:
    
            now = base_mono + clock_delta * slope
    
    So if the update lowers the slope, readers who are forced to the
    not yet updated second array are still using the old steeper slope.
    
     tmono
     ^
     |    o  n
     |   o n
     |  u
     | o
     |o
     |12345678---> reader order
    
     o = old slope
     u = update
     n = new slope
    
    So reader 6 will observe time going backwards versus reader 5.
    
    While other CPUs are likely to be able observe that, the only way
    for a CPU local observation is when an NMI hits in the middle of
    the update. Timestamps taken from that NMI context might be ahead
    of the following timestamps. Callers need to be aware of that and
    deal with it.
    
    V2: Got rid of clock monotonic raw and reorganized the data
        structures. Folded in the barrier fix from Mathieu.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 58ad7eff83ff..1caa6b04fdc5 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -164,6 +164,8 @@ static inline u64 ktime_get_raw_ns(void)
 	return ktime_to_ns(ktime_get_raw());
 }
 
+extern u64 ktime_get_mono_fast_ns(void);
+
 /*
  * Timespec interfaces utilizing the ktime based ones
  */

commit f519b1a2e08c913375324a927992bb328387f169
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:05:04 2014 +0000

    timekeeping: Provide ktime_get_raw()
    
    Provide a ktime_t based interface for raw monotonic time.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index f0f12a84a31b..58ad7eff83ff 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -107,6 +107,7 @@ enum tk_offsets {
 extern ktime_t ktime_get(void);
 extern ktime_t ktime_get_with_offset(enum tk_offsets offs);
 extern ktime_t ktime_mono_to_any(ktime_t tmono, enum tk_offsets offs);
+extern ktime_t ktime_get_raw(void);
 
 /**
  * ktime_get_real - get the real (wall-) time in ktime_t format
@@ -158,6 +159,11 @@ static inline u64 ktime_get_boot_ns(void)
 	return ktime_to_ns(ktime_get_boottime());
 }
 
+static inline u64 ktime_get_raw_ns(void)
+{
+	return ktime_to_ns(ktime_get_raw());
+}
+
 /*
  * Timespec interfaces utilizing the ktime based ones
  */

commit 61edec81d260bc96a73c878bbdb4c614460346da
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:05:01 2014 +0000

    timekeeping: Simplify timekeeping_clocktai()
    
    timekeeping_clocktai() is not used in fast pathes, so the extra
    timespec conversion is not problematic.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 7b8f20007871..f0f12a84a31b 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -166,6 +166,11 @@ static inline void get_monotonic_boottime(struct timespec *ts)
 	*ts = ktime_to_timespec(ktime_get_boottime());
 }
 
+static inline void timekeeping_clocktai(struct timespec *ts)
+{
+	*ts = ktime_to_timespec(ktime_get_clocktai());
+}
+
 /*
  * RTC specific
  */

commit 48f18fd6addc199f330d838d54fe7b0a0892adaa
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:57 2014 +0000

    timekeeping: Use ktime_get_boottime() for get_monotonic_boottime()
    
    get_monotonic_boottime() is not used in fast pathes, so the extra
    timespec conversion is not problematic.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 8ea3ca1b0ee5..7b8f20007871 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -27,7 +27,6 @@ struct timespec __current_kernel_time(void);
  */
 struct timespec get_monotonic_coarse(void);
 extern void getrawmonotonic(struct timespec *ts);
-extern void get_monotonic_boottime(struct timespec *ts);
 extern void ktime_get_ts64(struct timespec64 *ts);
 
 extern int __getnstimeofday64(struct timespec64 *tv);
@@ -159,6 +158,14 @@ static inline u64 ktime_get_boot_ns(void)
 	return ktime_to_ns(ktime_get_boottime());
 }
 
+/*
+ * Timespec interfaces utilizing the ktime based ones
+ */
+static inline void get_monotonic_boottime(struct timespec *ts)
+{
+	*ts = ktime_to_timespec(ktime_get_boottime());
+}
+
 /*
  * RTC specific
  */

commit 250fade8af2ac5dda8d5106ea06738b6f9e768a7
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:55 2014 +0000

    timekeeping: Remove monotonic_to_bootbased
    
    No more users.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 903ecc10fcff..8ea3ca1b0ee5 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -27,7 +27,6 @@ struct timespec __current_kernel_time(void);
  */
 struct timespec get_monotonic_coarse(void);
 extern void getrawmonotonic(struct timespec *ts);
-extern void monotonic_to_bootbased(struct timespec *ts);
 extern void get_monotonic_boottime(struct timespec *ts);
 extern void ktime_get_ts64(struct timespec64 *ts);
 

commit 897994e32b2b0a41ce4222c3b38a05bd2d1ee9fa
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:29 2014 +0000

    timekeeping: Provide ktime_get[*]_ns() helpers
    
    A lot of code converts either timespecs or ktime_t to
    nanoseconds. Provide helper functions.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 64c81f367866..903ecc10fcff 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -145,6 +145,21 @@ static inline ktime_t ktime_mono_to_real(ktime_t mono)
 	return ktime_mono_to_any(mono, TK_OFFS_REAL);
 }
 
+static inline u64 ktime_get_ns(void)
+{
+	return ktime_to_ns(ktime_get());
+}
+
+static inline u64 ktime_get_real_ns(void)
+{
+	return ktime_to_ns(ktime_get_real());
+}
+
+static inline u64 ktime_get_boot_ns(void)
+{
+	return ktime_to_ns(ktime_get_boottime());
+}
+
 /*
  * RTC specific
  */

commit dcaab54e348c5b66cca4802815ceebd37059e70c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:28 2014 +0000

    timekeeping: Remove ktime_get_monotonic_offset()
    
    No more users.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 910a98ef2154..64c81f367866 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -108,7 +108,6 @@ enum tk_offsets {
 
 extern ktime_t ktime_get(void);
 extern ktime_t ktime_get_with_offset(enum tk_offsets offs);
-extern ktime_t ktime_get_monotonic_offset(void);
 extern ktime_t ktime_mono_to_any(ktime_t tmono, enum tk_offsets offs);
 
 /**

commit 9a6b51976ea3a326b6de534beec3fd87275f4ef6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:22 2014 +0000

    timekeeping: Provide ktime_mono_to_any()
    
    ktime based conversion function to map a monotonic time stamp to a
    different CLOCK.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 3050a7d0a5a9..910a98ef2154 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -109,6 +109,7 @@ enum tk_offsets {
 extern ktime_t ktime_get(void);
 extern ktime_t ktime_get_with_offset(enum tk_offsets offs);
 extern ktime_t ktime_get_monotonic_offset(void);
+extern ktime_t ktime_mono_to_any(ktime_t tmono, enum tk_offsets offs);
 
 /**
  * ktime_get_real - get the real (wall-) time in ktime_t format
@@ -137,6 +138,14 @@ static inline ktime_t ktime_get_clocktai(void)
 	return ktime_get_with_offset(TK_OFFS_TAI);
 }
 
+/**
+ * ktime_mono_to_real - Convert monotonic time to clock realtime
+ */
+static inline ktime_t ktime_mono_to_real(ktime_t mono)
+{
+	return ktime_mono_to_any(mono, TK_OFFS_REAL);
+}
+
 /*
  * RTC specific
  */

commit afab07c0e91ecf098abf34573ccfcd86d6be26f9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:17 2014 +0000

    timekeeping: Use ktime_t based data for ktime_get_clocktai()
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 2fc606203c8c..3050a7d0a5a9 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -109,7 +109,6 @@ enum tk_offsets {
 extern ktime_t ktime_get(void);
 extern ktime_t ktime_get_with_offset(enum tk_offsets offs);
 extern ktime_t ktime_get_monotonic_offset(void);
-extern ktime_t ktime_get_clocktai(void);
 
 /**
  * ktime_get_real - get the real (wall-) time in ktime_t format
@@ -130,6 +129,14 @@ static inline ktime_t ktime_get_boottime(void)
 	return ktime_get_with_offset(TK_OFFS_BOOT);
 }
 
+/**
+ * ktime_get_clocktai - Returns the TAI time of day in ktime_t format
+ */
+static inline ktime_t ktime_get_clocktai(void)
+{
+	return ktime_get_with_offset(TK_OFFS_TAI);
+}
+
 /*
  * RTC specific
  */

commit b82c817e2d16e818c472eb71019de521816000a3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:16 2014 +0000

    timekeeping; Use ktime_t based data for ktime_get_boottime()
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 68e6678a743b..2fc606203c8c 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -108,7 +108,6 @@ enum tk_offsets {
 
 extern ktime_t ktime_get(void);
 extern ktime_t ktime_get_with_offset(enum tk_offsets offs);
-extern ktime_t ktime_get_boottime(void);
 extern ktime_t ktime_get_monotonic_offset(void);
 extern ktime_t ktime_get_clocktai(void);
 
@@ -120,6 +119,17 @@ static inline ktime_t ktime_get_real(void)
 	return ktime_get_with_offset(TK_OFFS_REAL);
 }
 
+/**
+ * ktime_get_boottime - Returns monotonic time since boot in ktime_t format
+ *
+ * This is similar to CLOCK_MONTONIC/ktime_get, but also includes the
+ * time spent in suspend.
+ */
+static inline ktime_t ktime_get_boottime(void)
+{
+	return ktime_get_with_offset(TK_OFFS_BOOT);
+}
+
 /*
  * RTC specific
  */

commit f5264d5d5a0729306cc792d84432b97785d2662a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:14 2014 +0000

    timekeeping: Use ktime_t based data for ktime_get_real()
    
    Speed up the readout.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index a58e4b1879db..68e6678a743b 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -108,11 +108,18 @@ enum tk_offsets {
 
 extern ktime_t ktime_get(void);
 extern ktime_t ktime_get_with_offset(enum tk_offsets offs);
-extern ktime_t ktime_get_real(void);
 extern ktime_t ktime_get_boottime(void);
 extern ktime_t ktime_get_monotonic_offset(void);
 extern ktime_t ktime_get_clocktai(void);
 
+/**
+ * ktime_get_real - get the real (wall-) time in ktime_t format
+ */
+static inline ktime_t ktime_get_real(void)
+{
+	return ktime_get_with_offset(TK_OFFS_REAL);
+}
+
 /*
  * RTC specific
  */

commit 0077dc60f274b9a7e9aa705a34784fefb87e0eee
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:13 2014 +0000

    timekeeping: Provide ktime_get_with_offset()
    
    Provide a helper function which lets us implement ktime_t based
    interfaces for real, boot and tai clocks.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 3eb19e34cc20..a58e4b1879db 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -98,7 +98,16 @@ extern void getboottime(struct timespec *ts);
 /*
  * ktime_t based interfaces
  */
+
+enum tk_offsets {
+	TK_OFFS_REAL,
+	TK_OFFS_BOOT,
+	TK_OFFS_TAI,
+	TK_OFFS_MAX,
+};
+
 extern ktime_t ktime_get(void);
+extern ktime_t ktime_get_with_offset(enum tk_offsets offs);
 extern ktime_t ktime_get_real(void);
 extern ktime_t ktime_get_boottime(void);
 extern ktime_t ktime_get_monotonic_offset(void);

commit d6d29896c665dfd50e6e0be7a9039901640433a3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:04 2014 +0000

    timekeeping: Provide timespec64 based interfaces
    
    To convert callers of the core code to timespec64 we need to provide
    the proper interfaces.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index e81c35b71da7..3eb19e34cc20 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -29,15 +29,71 @@ struct timespec get_monotonic_coarse(void);
 extern void getrawmonotonic(struct timespec *ts);
 extern void monotonic_to_bootbased(struct timespec *ts);
 extern void get_monotonic_boottime(struct timespec *ts);
-extern void ktime_get_ts(struct timespec *ts);
+extern void ktime_get_ts64(struct timespec64 *ts);
+
+extern int __getnstimeofday64(struct timespec64 *tv);
+extern void getnstimeofday64(struct timespec64 *tv);
+
+#if BITS_PER_LONG == 64
+static inline int __getnstimeofday(struct timespec *ts)
+{
+	return __getnstimeofday64(ts);
+}
+
+static inline void getnstimeofday(struct timespec *ts)
+{
+	getnstimeofday64(ts);
+}
+
+static inline void ktime_get_ts(struct timespec *ts)
+{
+	ktime_get_ts64(ts);
+}
+
+static inline void ktime_get_real_ts(struct timespec *ts)
+{
+	getnstimeofday64(ts);
+}
+
+#else
+static inline int __getnstimeofday(struct timespec *ts)
+{
+	struct timespec64 ts64;
+	int ret = __getnstimeofday64(&ts64);
+
+	*ts = timespec64_to_timespec(ts64);
+	return ret;
+}
+
+static inline void getnstimeofday(struct timespec *ts)
+{
+	struct timespec64 ts64;
+
+	getnstimeofday64(&ts64);
+	*ts = timespec64_to_timespec(ts64);
+}
+
+static inline void ktime_get_ts(struct timespec *ts)
+{
+	struct timespec64 ts64;
+
+	ktime_get_ts64(&ts64);
+	*ts = timespec64_to_timespec(ts64);
+}
+
+static inline void ktime_get_real_ts(struct timespec *ts)
+{
+	struct timespec64 ts64;
+
+	getnstimeofday64(&ts64);
+	*ts = timespec64_to_timespec(ts64);
+}
+#endif
 
-extern int __getnstimeofday(struct timespec *tv);
-extern void getnstimeofday(struct timespec *tv);
 extern void getboottime(struct timespec *ts);
 
 #define do_posix_clock_monotonic_gettime(ts) ktime_get_ts(ts)
-#define ktime_get_real_ts(ts)	getnstimeofday(ts)
-
+#define ktime_get_real_ts64(ts)	getnstimeofday64(ts)
 
 /*
  * ktime_t based interfaces

commit 8b094cd03b4a3793220d8d8d86a173bfea8c285b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:02 2014 +0000

    time: Consolidate the time accessor prototypes
    
    Right now we have time related prototypes in 3 different header
    files. Move it to a single timekeeping header file and move the core
    internal stuff into a core private header.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
new file mode 100644
index 000000000000..e81c35b71da7
--- /dev/null
+++ b/include/linux/timekeeping.h
@@ -0,0 +1,78 @@
+#ifndef _LINUX_TIMEKEEPING_H
+#define _LINUX_TIMEKEEPING_H
+
+/* Included from linux/ktime.h */
+
+void timekeeping_init(void);
+extern int timekeeping_suspended;
+
+/*
+ * Get and set timeofday
+ */
+extern void do_gettimeofday(struct timeval *tv);
+extern int do_settimeofday(const struct timespec *tv);
+extern int do_sys_settimeofday(const struct timespec *tv,
+			       const struct timezone *tz);
+
+/*
+ * Kernel time accessors
+ */
+unsigned long get_seconds(void);
+struct timespec current_kernel_time(void);
+/* does not take xtime_lock */
+struct timespec __current_kernel_time(void);
+
+/*
+ * timespec based interfaces
+ */
+struct timespec get_monotonic_coarse(void);
+extern void getrawmonotonic(struct timespec *ts);
+extern void monotonic_to_bootbased(struct timespec *ts);
+extern void get_monotonic_boottime(struct timespec *ts);
+extern void ktime_get_ts(struct timespec *ts);
+
+extern int __getnstimeofday(struct timespec *tv);
+extern void getnstimeofday(struct timespec *tv);
+extern void getboottime(struct timespec *ts);
+
+#define do_posix_clock_monotonic_gettime(ts) ktime_get_ts(ts)
+#define ktime_get_real_ts(ts)	getnstimeofday(ts)
+
+
+/*
+ * ktime_t based interfaces
+ */
+extern ktime_t ktime_get(void);
+extern ktime_t ktime_get_real(void);
+extern ktime_t ktime_get_boottime(void);
+extern ktime_t ktime_get_monotonic_offset(void);
+extern ktime_t ktime_get_clocktai(void);
+
+/*
+ * RTC specific
+ */
+extern void timekeeping_inject_sleeptime(struct timespec *delta);
+
+/*
+ * PPS accessor
+ */
+extern void getnstime_raw_and_real(struct timespec *ts_raw,
+				   struct timespec *ts_real);
+
+/*
+ * Persistent clock related interfaces
+ */
+extern bool persistent_clock_exist;
+extern int persistent_clock_is_local;
+
+static inline bool has_persistent_clock(void)
+{
+	return persistent_clock_exist;
+}
+
+extern void read_persistent_clock(struct timespec *ts);
+extern void read_boot_clock(struct timespec *ts);
+extern int update_persistent_clock(struct timespec now);
+
+
+#endif
