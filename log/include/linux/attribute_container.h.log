commit 7c1ef338705fb5c53e6f574ae5eb19fdfacb3d26
Author: Gabriel Krisman Bertazi <krisman@collabora.com>
Date:   Mon Jan 6 13:58:15 2020 -0500

    scsi: drivers: base: Support atomic version of attribute_container_device_trigger
    
    attribute_container_device_trigger invokes callbacks that may fail for one
    or more classdevs, for instance, the transport_add_class_device callback,
    called during transport creation, does memory allocation.  This
    information, though, is not propagated to upper layers, and any driver
    using the attribute_container_device_trigger API will not know whether any,
    some, or all callbacks succeeded.
    
    This patch implements a safe version of this dispatcher, to either succeed
    all the callbacks or revert to the original state.
    
    Link: https://lore.kernel.org/r/20200106185817.640331-2-krisman@collabora.com
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Gabriel Krisman Bertazi <krisman@collabora.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/linux/attribute_container.h b/include/linux/attribute_container.h
index d12bb2153cd6..e4004d1e6725 100644
--- a/include/linux/attribute_container.h
+++ b/include/linux/attribute_container.h
@@ -54,6 +54,13 @@ void attribute_container_device_trigger(struct device *dev,
 					int (*fn)(struct attribute_container *,
 						  struct device *,
 						  struct device *));
+int attribute_container_device_trigger_safe(struct device *dev,
+					    int (*fn)(struct attribute_container *,
+						      struct device *,
+						      struct device *),
+					    int (*undo)(struct attribute_container *,
+							struct device *,
+							struct device *));
 void attribute_container_trigger(struct device *dev, 
 				 int (*fn)(struct attribute_container *,
 					   struct device *));

commit 82664963ee5f03b5c604f4c593a5e43f26193610
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:51 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 437
    
    Based on 1 normalized pattern(s):
    
      this file is licensed under gplv2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 22 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190115.129548190@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/attribute_container.h b/include/linux/attribute_container.h
index 896c6892f327..d12bb2153cd6 100644
--- a/include/linux/attribute_container.h
+++ b/include/linux/attribute_container.h
@@ -1,9 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * attribute_container.h - a generic container for all classes
  *
  * Copyright (c) 2005 - James Bottomley <James.Bottomley@steeleye.com>
- *
- * This file is licensed under GPLv2
  */
 
 #ifndef _ATTRIBUTE_CONTAINER_H_

commit 313162d0b83836e2f57e51b9b8650fb4b9c396ea
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jan 30 11:46:54 2012 -0500

    device.h: audit and cleanup users in main include dir
    
    The <linux/device.h> header includes a lot of stuff, and
    it in turn gets a lot of use just for the basic "struct device"
    which appears so often.
    
    Clean up the users as follows:
    
    1) For those headers only needing "struct device" as a pointer
    in fcn args, replace the include with exactly that.
    
    2) For headers not really using anything from device.h, simply
    delete the include altogether.
    
    3) For headers relying on getting device.h implicitly before
    being included themselves, now explicitly include device.h
    
    4) For files in which doing #1 or #2 uncovers an implicit
    dependency on some other header, fix by explicitly adding
    the required header(s).
    
    Any C files that were implicitly relying on device.h to be
    present have already been dealt with in advance.
    
    Total removals from #1 and #2: 51.  Total additions coming
    from #3: 9.  Total other implicit dependencies from #4: 7.
    
    As of 3.3-rc1, there were 110, so a net removal of 42 gives
    about a 38% reduction in device.h presence in include/*
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/linux/attribute_container.h b/include/linux/attribute_container.h
index c3ab81428c66..896c6892f327 100644
--- a/include/linux/attribute_container.h
+++ b/include/linux/attribute_container.h
@@ -9,10 +9,11 @@
 #ifndef _ATTRIBUTE_CONTAINER_H_
 #define _ATTRIBUTE_CONTAINER_H_
 
-#include <linux/device.h>
 #include <linux/list.h>
 #include <linux/klist.h>
 
+struct device;
+
 struct attribute_container {
 	struct list_head	node;
 	struct klist		containers;

commit a4dbd6740df0872cdf0a86841f75beec8381964d
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Jun 24 10:06:31 2009 -0700

    driver model: constify attribute groups
    
    Let attribute group vectors be declared "const".  We'd
    like to let most attribute metadata live in read-only
    sections... this is a start.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/attribute_container.h b/include/linux/attribute_container.h
index 794ad74b1d61..c3ab81428c66 100644
--- a/include/linux/attribute_container.h
+++ b/include/linux/attribute_container.h
@@ -17,7 +17,7 @@ struct attribute_container {
 	struct list_head	node;
 	struct klist		containers;
 	struct class		*class;
-	struct attribute_group	*grp;
+	const struct attribute_group *grp;
 	struct device_attribute **attrs;
 	int (*match)(struct attribute_container *, struct device *);
 #define	ATTRIBUTE_CONTAINER_NO_CLASSDEVS	0x01

commit ee959b00c335d7780136c5abda37809191fe52c3
Author: Tony Jones <tonyj@suse.de>
Date:   Fri Feb 22 00:13:36 2008 +0100

    SCSI: convert struct class_device to struct device
    
    It's big, but there doesn't seem to be a way to split it up smaller...
    
    Signed-off-by: Tony Jones <tonyj@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Roland Dreier <rolandd@cisco.com>
    Cc: Sean Hefty <sean.hefty@intel.com>
    Cc: Hal Rosenstock <hal.rosenstock@gmail.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/attribute_container.h b/include/linux/attribute_container.h
index 574b201b99d8..794ad74b1d61 100644
--- a/include/linux/attribute_container.h
+++ b/include/linux/attribute_container.h
@@ -1,5 +1,5 @@
 /*
- * class_container.h - a generic container for all classes
+ * attribute_container.h - a generic container for all classes
  *
  * Copyright (c) 2005 - James Bottomley <James.Bottomley@steeleye.com>
  *
@@ -18,7 +18,7 @@ struct attribute_container {
 	struct klist		containers;
 	struct class		*class;
 	struct attribute_group	*grp;
-	struct class_device_attribute **attrs;
+	struct device_attribute **attrs;
 	int (*match)(struct attribute_container *, struct device *);
 #define	ATTRIBUTE_CONTAINER_NO_CLASSDEVS	0x01
 	unsigned long		flags;
@@ -41,31 +41,31 @@ int __must_check attribute_container_unregister(struct attribute_container *cont
 void attribute_container_create_device(struct device *dev,
 				       int (*fn)(struct attribute_container *,
 						 struct device *,
-						 struct class_device *));
+						 struct device *));
 void attribute_container_add_device(struct device *dev,
 				    int (*fn)(struct attribute_container *,
 					      struct device *,
-					      struct class_device *));
+					      struct device *));
 void attribute_container_remove_device(struct device *dev,
 				       void (*fn)(struct attribute_container *,
 						  struct device *,
-						  struct class_device *));
+						  struct device *));
 void attribute_container_device_trigger(struct device *dev, 
 					int (*fn)(struct attribute_container *,
 						  struct device *,
-						  struct class_device *));
+						  struct device *));
 void attribute_container_trigger(struct device *dev, 
 				 int (*fn)(struct attribute_container *,
 					   struct device *));
-int attribute_container_add_attrs(struct class_device *classdev);
-int attribute_container_add_class_device(struct class_device *classdev);
+int attribute_container_add_attrs(struct device *classdev);
+int attribute_container_add_class_device(struct device *classdev);
 int attribute_container_add_class_device_adapter(struct attribute_container *cont,
 						 struct device *dev,
-						 struct class_device *classdev);
-void attribute_container_remove_attrs(struct class_device *classdev);
-void attribute_container_class_device_del(struct class_device *classdev);
-struct attribute_container *attribute_container_classdev_to_container(struct class_device *);
-struct class_device *attribute_container_find_class_device(struct attribute_container *, struct device *);
-struct class_device_attribute **attribute_container_classdev_to_attrs(const struct class_device *classdev);
+						 struct device *classdev);
+void attribute_container_remove_attrs(struct device *classdev);
+void attribute_container_class_device_del(struct device *classdev);
+struct attribute_container *attribute_container_classdev_to_container(struct device *);
+struct device *attribute_container_find_class_device(struct attribute_container *, struct device *);
+struct device_attribute **attribute_container_classdev_to_attrs(const struct device *classdev);
 
 #endif

commit 2f3edc6936e3f6be3f1df1e89c141ae028fa605e
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Wed Apr 2 10:05:48 2008 -0500

    [SCSI] transport_class: BUG if we can't release the attribute container
    
    Every current transport class calls transport_container_release but
    ignores the return value.  This is catastrophic if it returns an error
    because the containers are part of a global list and the next action of
    almost every transport class is to free the memory used by the
    container.
    
    Fix this by making transport_container_release a void, but making it BUG
    if attribute_container_release returns an error ... this catches the
    root cause of a system panic much earlier.  If we don't do this, we get
    an eventual BUG when the attribute container list notices the corruption
    caused by the freed memory it's still referencing.
    
    Also made attribute_container_release __must_check as a reminder.
    
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/linux/attribute_container.h b/include/linux/attribute_container.h
index f5582332af04..574b201b99d8 100644
--- a/include/linux/attribute_container.h
+++ b/include/linux/attribute_container.h
@@ -37,7 +37,7 @@ attribute_container_set_no_classdevs(struct attribute_container *atc)
 }
 
 int attribute_container_register(struct attribute_container *cont);
-int attribute_container_unregister(struct attribute_container *cont);
+int __must_check attribute_container_unregister(struct attribute_container *cont);
 void attribute_container_create_device(struct device *dev,
 				       int (*fn)(struct attribute_container *,
 						 struct device *,

commit fd1109711d7f76126e7cef947999f139b198dc15
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Wed Jan 2 18:48:47 2008 -0600

    [SCSI] attribute_container: update to use the group interface
    
    This patch is the beginning of moving the attribute_containers to use
    attribute groups exclusively.  The attr element is now deprecated and
    will eventually be removed (along with all the hand rolled code for
    doing exactly what attribute groups do) when all the consumers are
    converted to attribute groups.
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/linux/attribute_container.h b/include/linux/attribute_container.h
index 8ff274933948..f5582332af04 100644
--- a/include/linux/attribute_container.h
+++ b/include/linux/attribute_container.h
@@ -17,6 +17,7 @@ struct attribute_container {
 	struct list_head	node;
 	struct klist		containers;
 	struct class		*class;
+	struct attribute_group	*grp;
 	struct class_device_attribute **attrs;
 	int (*match)(struct attribute_container *, struct device *);
 #define	ATTRIBUTE_CONTAINER_NO_CLASSDEVS	0x01

commit 0a3021f4e249fbdb5f30d614707b5e02022e4c9b
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Sun Jul 15 23:39:57 2007 -0700

    Remove unnecessary includes of spinlock.h under include/linux
    
    Remove the obviously unnecessary includes of <linux/spinlock.h> under the
    include/linux/ directory, and fix the couple errors that are introduced as
    a result of that.
    
    Signed-off-by: Robert P. J. Day <rpjday@mindspring.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/attribute_container.h b/include/linux/attribute_container.h
index 93bfb0beb62a..8ff274933948 100644
--- a/include/linux/attribute_container.h
+++ b/include/linux/attribute_container.h
@@ -12,7 +12,6 @@
 #include <linux/device.h>
 #include <linux/list.h>
 #include <linux/klist.h>
-#include <linux/spinlock.h>
 
 struct attribute_container {
 	struct list_head	node;

commit 53c165e0a6c8a4ff7df316557528fa7a52d20711
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Mon Aug 22 10:06:19 2005 -0500

    [SCSI] correct attribute_container list usage
    
    One of the changes in the attribute_container code in the scsi-misc tree
    was to add a lock to protect the list of devices per container.  This,
    unfortunately, leads to potential scheduling while atomic problems if
    there's a sleep in the function called by a trigger.
    
    The correct solution is to use the kernel klist infrastructure instead
    which allows lockless traversal of a list.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/linux/attribute_container.h b/include/linux/attribute_container.h
index ee83fe64a102..93bfb0beb62a 100644
--- a/include/linux/attribute_container.h
+++ b/include/linux/attribute_container.h
@@ -11,12 +11,12 @@
 
 #include <linux/device.h>
 #include <linux/list.h>
+#include <linux/klist.h>
 #include <linux/spinlock.h>
 
 struct attribute_container {
 	struct list_head	node;
-	struct list_head	containers;
-	spinlock_t		containers_lock;
+	struct klist		containers;
 	struct class		*class;
 	struct class_device_attribute **attrs;
 	int (*match)(struct attribute_container *, struct device *);

commit caca1779870b1bcc0fb07e48ebd2403901f356b8
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Tue Aug 16 17:26:10 2005 -0500

    [SCSI] add missing attribute container function prototype
    
    attribute_container_classdev_to_container is an exported function of the
    attribute_container.c file.  However, there's no prototype for it.  Now
    I actually want to use it, so add one.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/linux/attribute_container.h b/include/linux/attribute_container.h
index f54b05b052b3..ee83fe64a102 100644
--- a/include/linux/attribute_container.h
+++ b/include/linux/attribute_container.h
@@ -64,6 +64,7 @@ int attribute_container_add_class_device_adapter(struct attribute_container *con
 						 struct class_device *classdev);
 void attribute_container_remove_attrs(struct class_device *classdev);
 void attribute_container_class_device_del(struct class_device *classdev);
+struct attribute_container *attribute_container_classdev_to_container(struct class_device *);
 struct class_device *attribute_container_find_class_device(struct attribute_container *, struct device *);
 struct class_device_attribute **attribute_container_classdev_to_attrs(const struct class_device *classdev);
 

commit d0a7e574007fd547d72ec693bfa35778623d0738
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Sun Aug 14 17:09:01 2005 -0500

    [SCSI] correct transport class abstraction to work outside SCSI
    
    I recently tried to construct a totally generic transport class and
    found there were certain features missing from the current abstract
    transport class.  Most notable is that you have to hang the data on the
    class_device but most of the API is framed in terms of the generic
    device, not the class_device.
    
    These changes are two fold
    
    - Provide the class_device to all of the setup and configure APIs
    - Provide and extra API to take the device and the attribute class and
      return the corresponding class_device
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/linux/attribute_container.h b/include/linux/attribute_container.h
index af1010b6dab7..f54b05b052b3 100644
--- a/include/linux/attribute_container.h
+++ b/include/linux/attribute_container.h
@@ -11,10 +11,12 @@
 
 #include <linux/device.h>
 #include <linux/list.h>
+#include <linux/spinlock.h>
 
 struct attribute_container {
 	struct list_head	node;
 	struct list_head	containers;
+	spinlock_t		containers_lock;
 	struct class		*class;
 	struct class_device_attribute **attrs;
 	int (*match)(struct attribute_container *, struct device *);
@@ -62,12 +64,7 @@ int attribute_container_add_class_device_adapter(struct attribute_container *con
 						 struct class_device *classdev);
 void attribute_container_remove_attrs(struct class_device *classdev);
 void attribute_container_class_device_del(struct class_device *classdev);
-
-
-
-
-
-
+struct class_device *attribute_container_find_class_device(struct attribute_container *, struct device *);
 struct class_device_attribute **attribute_container_classdev_to_attrs(const struct class_device *classdev);
 
 #endif

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/attribute_container.h b/include/linux/attribute_container.h
new file mode 100644
index 000000000000..af1010b6dab7
--- /dev/null
+++ b/include/linux/attribute_container.h
@@ -0,0 +1,73 @@
+/*
+ * class_container.h - a generic container for all classes
+ *
+ * Copyright (c) 2005 - James Bottomley <James.Bottomley@steeleye.com>
+ *
+ * This file is licensed under GPLv2
+ */
+
+#ifndef _ATTRIBUTE_CONTAINER_H_
+#define _ATTRIBUTE_CONTAINER_H_
+
+#include <linux/device.h>
+#include <linux/list.h>
+
+struct attribute_container {
+	struct list_head	node;
+	struct list_head	containers;
+	struct class		*class;
+	struct class_device_attribute **attrs;
+	int (*match)(struct attribute_container *, struct device *);
+#define	ATTRIBUTE_CONTAINER_NO_CLASSDEVS	0x01
+	unsigned long		flags;
+};
+
+static inline int
+attribute_container_no_classdevs(struct attribute_container *atc)
+{
+	return atc->flags & ATTRIBUTE_CONTAINER_NO_CLASSDEVS;
+}
+
+static inline void
+attribute_container_set_no_classdevs(struct attribute_container *atc)
+{
+	atc->flags |= ATTRIBUTE_CONTAINER_NO_CLASSDEVS;
+}
+
+int attribute_container_register(struct attribute_container *cont);
+int attribute_container_unregister(struct attribute_container *cont);
+void attribute_container_create_device(struct device *dev,
+				       int (*fn)(struct attribute_container *,
+						 struct device *,
+						 struct class_device *));
+void attribute_container_add_device(struct device *dev,
+				    int (*fn)(struct attribute_container *,
+					      struct device *,
+					      struct class_device *));
+void attribute_container_remove_device(struct device *dev,
+				       void (*fn)(struct attribute_container *,
+						  struct device *,
+						  struct class_device *));
+void attribute_container_device_trigger(struct device *dev, 
+					int (*fn)(struct attribute_container *,
+						  struct device *,
+						  struct class_device *));
+void attribute_container_trigger(struct device *dev, 
+				 int (*fn)(struct attribute_container *,
+					   struct device *));
+int attribute_container_add_attrs(struct class_device *classdev);
+int attribute_container_add_class_device(struct class_device *classdev);
+int attribute_container_add_class_device_adapter(struct attribute_container *cont,
+						 struct device *dev,
+						 struct class_device *classdev);
+void attribute_container_remove_attrs(struct class_device *classdev);
+void attribute_container_class_device_del(struct class_device *classdev);
+
+
+
+
+
+
+struct class_device_attribute **attribute_container_classdev_to_attrs(const struct class_device *classdev);
+
+#endif
