commit 71a8508402b570127d6500c1ad456bbd33ccf187
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Wed Jan 9 02:25:10 2019 +0900

    net: bpfilter: disallow to remove bpfilter module while being used
    
    The bpfilter.ko module can be removed while functions of the bpfilter.ko
    are executing. so panic can occurred. in order to protect that, locks can
    be used. a bpfilter_lock protects routines in the
    __bpfilter_process_sockopt() but it's not enough because __exit routine
    can be executed concurrently.
    
    Now, the bpfilter_umh can not run in parallel.
    So, the module do not removed while it's being used and it do not
    double-create UMH process.
    The members of the umh_info and the bpfilter_umh_ops are protected by
    the bpfilter_umh_ops.lock.
    
    test commands:
       while :
       do
            iptables -I FORWARD -m string --string ap --algo kmp &
            modprobe -rv bpfilter &
       done
    
    splat looks like:
    [  298.623435] BUG: unable to handle kernel paging request at fffffbfff807440b
    [  298.628512] #PF error: [normal kernel read fault]
    [  298.633018] PGD 124327067 P4D 124327067 PUD 11c1a3067 PMD 119eb2067 PTE 0
    [  298.638859] Oops: 0000 [#1] SMP DEBUG_PAGEALLOC KASAN PTI
    [  298.638859] CPU: 0 PID: 2997 Comm: iptables Not tainted 4.20.0+ #154
    [  298.638859] RIP: 0010:__mutex_lock+0x6b9/0x16a0
    [  298.638859] Code: c0 00 00 e8 89 82 ff ff 80 bd 8f fc ff ff 00 0f 85 d9 05 00 00 48 8b 85 80 fc ff ff 48 bf 00 00 00 00 00 fc ff df 48 c1 e8 03 <80> 3c 38 00 0f 85 1d 0e 00 00 48 8b 85 c8 fc ff ff 49 39 47 58 c6
    [  298.638859] RSP: 0018:ffff88810e7777a0 EFLAGS: 00010202
    [  298.638859] RAX: 1ffffffff807440b RBX: ffff888111bd4d80 RCX: 0000000000000000
    [  298.638859] RDX: 1ffff110235ff806 RSI: ffff888111bd5538 RDI: dffffc0000000000
    [  298.638859] RBP: ffff88810e777b30 R08: 0000000080000002 R09: 0000000000000000
    [  298.638859] R10: 0000000000000000 R11: 0000000000000000 R12: fffffbfff168a42c
    [  298.638859] R13: ffff888111bd4d80 R14: ffff8881040e9a05 R15: ffffffffc03a2000
    [  298.638859] FS:  00007f39e3758700(0000) GS:ffff88811ae00000(0000) knlGS:0000000000000000
    [  298.638859] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  298.638859] CR2: fffffbfff807440b CR3: 000000011243e000 CR4: 00000000001006f0
    [  298.638859] Call Trace:
    [  298.638859]  ? mutex_lock_io_nested+0x1560/0x1560
    [  298.638859]  ? kasan_kmalloc+0xa0/0xd0
    [  298.638859]  ? kmem_cache_alloc+0x1c2/0x260
    [  298.638859]  ? __alloc_file+0x92/0x3c0
    [  298.638859]  ? alloc_empty_file+0x43/0x120
    [  298.638859]  ? alloc_file_pseudo+0x220/0x330
    [  298.638859]  ? sock_alloc_file+0x39/0x160
    [  298.638859]  ? __sys_socket+0x113/0x1d0
    [  298.638859]  ? __x64_sys_socket+0x6f/0xb0
    [  298.638859]  ? do_syscall_64+0x138/0x560
    [  298.638859]  ? entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  298.638859]  ? __alloc_file+0x92/0x3c0
    [  298.638859]  ? init_object+0x6b/0x80
    [  298.638859]  ? cyc2ns_read_end+0x10/0x10
    [  298.638859]  ? cyc2ns_read_end+0x10/0x10
    [  298.638859]  ? hlock_class+0x140/0x140
    [  298.638859]  ? sched_clock_local+0xd4/0x140
    [  298.638859]  ? sched_clock_local+0xd4/0x140
    [  298.638859]  ? check_flags.part.37+0x440/0x440
    [  298.638859]  ? __lock_acquire+0x4f90/0x4f90
    [  298.638859]  ? set_rq_offline.part.89+0x140/0x140
    [ ... ]
    
    Fixes: d2ba09c17a06 ("net: add skeleton of bpfilter kernel module")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/bpfilter.h b/include/linux/bpfilter.h
index 8ebcbdd70bdc..d815622cd31e 100644
--- a/include/linux/bpfilter.h
+++ b/include/linux/bpfilter.h
@@ -12,6 +12,8 @@ int bpfilter_ip_get_sockopt(struct sock *sk, int optname, char __user *optval,
 			    int __user *optlen);
 struct bpfilter_umh_ops {
 	struct umh_info info;
+	/* since ip_getsockopt() can run in parallel, serialize access to umh */
+	struct mutex lock;
 	int (*sockopt)(struct sock *sk, int optname,
 		       char __user *optval,
 		       unsigned int optlen, bool is_set);

commit 61fbf5933d42b02f552123af5a87a06335a3b4db
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Wed Jan 9 02:24:53 2019 +0900

    net: bpfilter: restart bpfilter_umh when error occurred
    
    The bpfilter_umh will be stopped via __stop_umh() when the bpfilter
    error occurred.
    The bpfilter_umh() couldn't start again because there is no restart
    routine.
    
    The section of the bpfilter_umh_{start/end} is no longer .init.rodata
    because these area should be reused in the restart routine. hence
    the section name is changed to .bpfilter_umh.
    
    The bpfilter_ops->start() is restart callback. it will be called when
    bpfilter_umh is stopped.
    The stop bit means bpfilter_umh is stopped. this bit is set by both
    start and stop routine.
    
    Before this patch,
    Test commands:
       $ iptables -vnL
       $ kill -9 <pid of bpfilter_umh>
       $ iptables -vnL
       [  480.045136] bpfilter: write fail -32
       $ iptables -vnL
    
    All iptables commands will fail.
    
    After this patch,
    Test commands:
       $ iptables -vnL
       $ kill -9 <pid of bpfilter_umh>
       $ iptables -vnL
       $ iptables -vnL
    
    Now, all iptables commands will work.
    
    Fixes: d2ba09c17a06 ("net: add skeleton of bpfilter kernel module")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/bpfilter.h b/include/linux/bpfilter.h
index 70ffeed280e9..8ebcbdd70bdc 100644
--- a/include/linux/bpfilter.h
+++ b/include/linux/bpfilter.h
@@ -15,6 +15,8 @@ struct bpfilter_umh_ops {
 	int (*sockopt)(struct sock *sk, int optname,
 		       char __user *optval,
 		       unsigned int optlen, bool is_set);
+	int (*start)(void);
+	bool stop;
 };
 extern struct bpfilter_umh_ops bpfilter_ops;
 #endif

commit 5b4cb650e569db2e6a09d2fa0ef8eb789a0ac5d8
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Wed Jan 9 02:24:34 2019 +0900

    net: bpfilter: use cleanup callback to release umh_info
    
    Now, UMH process is killed, do_exit() calls the umh_info->cleanup callback
    to release members of the umh_info.
    This patch makes bpfilter_umh's cleanup routine to use the
    umh_info->cleanup callback.
    
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/bpfilter.h b/include/linux/bpfilter.h
index f02cee0225d4..70ffeed280e9 100644
--- a/include/linux/bpfilter.h
+++ b/include/linux/bpfilter.h
@@ -3,13 +3,18 @@
 #define _LINUX_BPFILTER_H
 
 #include <uapi/linux/bpfilter.h>
+#include <linux/umh.h>
 
 struct sock;
 int bpfilter_ip_set_sockopt(struct sock *sk, int optname, char __user *optval,
 			    unsigned int optlen);
 int bpfilter_ip_get_sockopt(struct sock *sk, int optname, char __user *optval,
 			    int __user *optlen);
-extern int (*bpfilter_process_sockopt)(struct sock *sk, int optname,
-				       char __user *optval,
-				       unsigned int optlen, bool is_set);
+struct bpfilter_umh_ops {
+	struct umh_info info;
+	int (*sockopt)(struct sock *sk, int optname,
+		       char __user *optval,
+		       unsigned int optlen, bool is_set);
+};
+extern struct bpfilter_umh_ops bpfilter_ops;
 #endif

commit f95de8aa9f824d96421cb7ca81552b4ad8768a31
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Thu Jul 19 15:56:59 2018 +0800

    bpfilter: Fix mismatch in function argument types
    
    Fix following warning:
    net/ipv4/bpfilter/sockopt.c:28:5: error: symbol 'bpfilter_ip_set_sockopt' redeclared with different type
    net/ipv4/bpfilter/sockopt.c:34:5: error: symbol 'bpfilter_ip_get_sockopt' redeclared with different type
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Acked-by: Daniel Borkmann <daniel@iogearbox.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/bpfilter.h b/include/linux/bpfilter.h
index 687b1760bb9f..f02cee0225d4 100644
--- a/include/linux/bpfilter.h
+++ b/include/linux/bpfilter.h
@@ -5,10 +5,10 @@
 #include <uapi/linux/bpfilter.h>
 
 struct sock;
-int bpfilter_ip_set_sockopt(struct sock *sk, int optname, char *optval,
+int bpfilter_ip_set_sockopt(struct sock *sk, int optname, char __user *optval,
 			    unsigned int optlen);
-int bpfilter_ip_get_sockopt(struct sock *sk, int optname, char *optval,
-			    int *optlen);
+int bpfilter_ip_get_sockopt(struct sock *sk, int optname, char __user *optval,
+			    int __user *optlen);
 extern int (*bpfilter_process_sockopt)(struct sock *sk, int optname,
 				       char __user *optval,
 				       unsigned int optlen, bool is_set);

commit d2ba09c17a0647f899d6c20a11bab9e6d3382f07
Author: Alexei Starovoitov <ast@kernel.org>
Date:   Mon May 21 19:22:30 2018 -0700

    net: add skeleton of bpfilter kernel module
    
    bpfilter.ko consists of bpfilter_kern.c (normal kernel module code)
    and user mode helper code that is embedded into bpfilter.ko
    
    The steps to build bpfilter.ko are the following:
    - main.c is compiled by HOSTCC into the bpfilter_umh elf executable file
    - with quite a bit of objcopy and Makefile magic the bpfilter_umh elf file
      is converted into bpfilter_umh.o object file
      with _binary_net_bpfilter_bpfilter_umh_start and _end symbols
      Example:
      $ nm ./bld_x64/net/bpfilter/bpfilter_umh.o
      0000000000004cf8 T _binary_net_bpfilter_bpfilter_umh_end
      0000000000004cf8 A _binary_net_bpfilter_bpfilter_umh_size
      0000000000000000 T _binary_net_bpfilter_bpfilter_umh_start
    - bpfilter_umh.o and bpfilter_kern.o are linked together into bpfilter.ko
    
    bpfilter_kern.c is a normal kernel module code that calls
    the fork_usermode_blob() helper to execute part of its own data
    as a user mode process.
    
    Notice that _binary_net_bpfilter_bpfilter_umh_start - end
    is placed into .init.rodata section, so it's freed as soon as __init
    function of bpfilter.ko is finished.
    As part of __init the bpfilter.ko does first request/reply action
    via two unix pipe provided by fork_usermode_blob() helper to
    make sure that umh is healthy. If not it will kill it via pid.
    
    Later bpfilter_process_sockopt() will be called from bpfilter hooks
    in get/setsockopt() to pass iptable commands into umh via bpfilter.ko
    
    If admin does 'rmmod bpfilter' the __exit code bpfilter.ko will
    kill umh as well.
    
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/bpfilter.h b/include/linux/bpfilter.h
new file mode 100644
index 000000000000..687b1760bb9f
--- /dev/null
+++ b/include/linux/bpfilter.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _LINUX_BPFILTER_H
+#define _LINUX_BPFILTER_H
+
+#include <uapi/linux/bpfilter.h>
+
+struct sock;
+int bpfilter_ip_set_sockopt(struct sock *sk, int optname, char *optval,
+			    unsigned int optlen);
+int bpfilter_ip_get_sockopt(struct sock *sk, int optname, char *optval,
+			    int *optlen);
+extern int (*bpfilter_process_sockopt)(struct sock *sk, int optname,
+				       char __user *optval,
+				       unsigned int optlen, bool is_set);
+#endif
