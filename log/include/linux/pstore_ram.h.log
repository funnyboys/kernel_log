commit 791205e3ec6081a8da6f00621e3453d622dc41e7
Author: Kees Cook <keescook@chromium.org>
Date:   Wed May 13 14:35:03 2020 -0700

    pstore/ram: Introduce max_reason and convert dump_oops
    
    Now that pstore_register() can correctly pass max_reason to the kmesg
    dump facility, introduce a new "max_reason" module parameter and
    "max-reason" Device Tree field.
    
    The "dump_oops" module parameter and "dump-oops" Device
    Tree field are now considered deprecated, but are now automatically
    converted to their corresponding max_reason values when present, though
    the new max_reason setting has precedence.
    
    For struct ramoops_platform_data, the "dump_oops" member is entirely
    replaced by a new "max_reason" member, with the only existing user
    updated in place.
    
    Additionally remove the "reason" filter logic from ramoops_pstore_write(),
    as that is not specifically needed anymore, though technically
    this is a change in behavior for any ramoops users also setting the
    printk.always_kmsg_dump boot param, which will cause ramoops to behave as
    if max_reason was set to KMSG_DUMP_MAX.
    
    Co-developed-by: Pavel Tatashin <pasha.tatashin@soleen.com>
    Signed-off-by: Pavel Tatashin <pasha.tatashin@soleen.com>
    Link: https://lore.kernel.org/lkml/20200515184434.8470-6-keescook@chromium.org/
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index 9cb9b9067298..9f16afec7290 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -133,7 +133,7 @@ struct ramoops_platform_data {
 	unsigned long	console_size;
 	unsigned long	ftrace_size;
 	unsigned long	pmsg_size;
-	int		dump_oops;
+	int		max_reason;
 	u32		flags;
 	struct persistent_ram_ecc_info ecc_info;
 };

commit 9c92ab61914157664a2fbdf926df0eb937838e45
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:56 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 282
    
    Based on 1 normalized pattern(s):
    
      this software is licensed under the terms of the gnu general public
      license version 2 as published by the free software foundation and
      may be copied distributed and modified under those terms this
      program is distributed in the hope that it will be useful but
      without any warranty without even the implied warranty of
      merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 285 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.642774971@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index 337971c41980..9cb9b9067298 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -1,17 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (C) 2010 Marco Stornelli <marco.stornelli@gmail.com>
  * Copyright (C) 2011 Kees Cook <keescook@chromium.org>
  * Copyright (C) 2011 Google, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  */
 
 #ifndef __LINUX_PSTORE_RAM_H__

commit f0f23e5469dc80b482d985898a930be0e249a162
Author: Joel Fernandes (Google) <joel@joelfernandes.org>
Date:   Sat Nov 3 16:38:16 2018 -0700

    pstore: Map PSTORE_TYPE_* to strings
    
    In later patches we will need to map types to names, so create a
    constant table for that which can also be used in different parts of
    old and new code. This saves the type in the PRZ which will be useful
    in later patches.
    
    Instead of having an explicit PSTORE_TYPE_UNKNOWN, just use ..._MAX.
    
    This includes removing the now redundant filename templates which can use
    a single format string. Also, there's no reason to limit the "is it still
    compressed?" test to only PSTORE_TYPE_DMESG when building the pstorefs
    filename. Records are zero-initialized, so a backend would need to have
    explicitly set compressed=1.
    
    Signed-off-by: Joel Fernandes (Google) <joel@joelfernandes.org>
    Co-developed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index 5d10ad51c1c4..337971c41980 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -22,6 +22,7 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/list.h>
+#include <linux/pstore.h>
 #include <linux/types.h>
 
 /*
@@ -54,6 +55,7 @@ struct persistent_ram_ecc_info {
  * @paddr:	physical address of the mapped RAM area
  * @size:	size of mapping
  * @label:	unique name of this PRZ
+ * @type:	frontend type for this PRZ
  * @flags:	holds PRZ_FLAGS_* bits
  *
  * @buffer_lock:
@@ -88,6 +90,7 @@ struct persistent_ram_zone {
 	size_t size;
 	void *vaddr;
 	char *label;
+	enum pstore_type_id type;
 	u32 flags;
 
 	raw_spinlock_t buffer_lock;

commit c208f7d4b037e1c71e5c839bb5dfcc3e0df19890
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Nov 1 15:11:47 2018 -0700

    pstore/ram: Add kern-doc for struct persistent_ram_zone
    
    The struct persistent_ram_zone wasn't well documented. This adds kern-doc
    for it.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index 6e94980357d2..5d10ad51c1c4 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -30,6 +30,10 @@
  * PRZ_FLAG_NO_LOCK is used. For all other cases, locking is required.
  */
 #define PRZ_FLAG_NO_LOCK	BIT(0)
+/*
+ * If a PRZ should only have a single-boot lifetime, this marks it as
+ * getting wiped after its contents get copied out after boot.
+ */
 #define PRZ_FLAG_ZAP_OLD	BIT(1)
 
 struct persistent_ram_buffer;
@@ -43,17 +47,53 @@ struct persistent_ram_ecc_info {
 	uint16_t *par;
 };
 
+/**
+ * struct persistent_ram_zone - Details of a persistent RAM zone (PRZ)
+ *                              used as a pstore backend
+ *
+ * @paddr:	physical address of the mapped RAM area
+ * @size:	size of mapping
+ * @label:	unique name of this PRZ
+ * @flags:	holds PRZ_FLAGS_* bits
+ *
+ * @buffer_lock:
+ *	locks access to @buffer "size" bytes and "start" offset
+ * @buffer:
+ *	pointer to actual RAM area managed by this PRZ
+ * @buffer_size:
+ *	bytes in @buffer->data (not including any trailing ECC bytes)
+ *
+ * @par_buffer:
+ *	pointer into @buffer->data containing ECC bytes for @buffer->data
+ * @par_header:
+ *	pointer into @buffer->data containing ECC bytes for @buffer header
+ *	(i.e. all fields up to @data)
+ * @rs_decoder:
+ *	RSLIB instance for doing ECC calculations
+ * @corrected_bytes:
+ *	ECC corrected bytes accounting since boot
+ * @bad_blocks:
+ *	ECC uncorrectable bytes accounting since boot
+ * @ecc_info:
+ *	ECC configuration details
+ *
+ * @old_log:
+ *	saved copy of @buffer->data prior to most recent wipe
+ * @old_log_size:
+ *	bytes contained in @old_log
+ *
+ */
 struct persistent_ram_zone {
 	phys_addr_t paddr;
 	size_t size;
 	void *vaddr;
 	char *label;
-	struct persistent_ram_buffer *buffer;
-	size_t buffer_size;
 	u32 flags;
+
 	raw_spinlock_t buffer_lock;
+	struct persistent_ram_buffer *buffer;
+	size_t buffer_size;
 
-	/* ECC correction */
 	char *par_buffer;
 	char *par_header;
 	struct rs_control *rs_decoder;

commit 7684bd334d9d4ca4f09873e88d9c0131a2cf6c3b
Author: Peng Wang <wangpeng15@xiaomi.com>
Date:   Tue Oct 30 15:52:34 2018 +0800

    pstore: Avoid duplicate call of persistent_ram_zap()
    
    When initialing a prz, if invalid data is found (no PERSISTENT_RAM_SIG),
    the function call path looks like this:
    
    ramoops_init_prz ->
        persistent_ram_new -> persistent_ram_post_init -> persistent_ram_zap
        persistent_ram_zap
    
    As we can see, persistent_ram_zap() is called twice.
    We can avoid this by adding an option to persistent_ram_new(), and
    only call persistent_ram_zap() when it is needed.
    
    Signed-off-by: Peng Wang <wangpeng15@xiaomi.com>
    [kees: minor tweak to exit path and commit log]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index 602d64725222..6e94980357d2 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -30,6 +30,7 @@
  * PRZ_FLAG_NO_LOCK is used. For all other cases, locking is required.
  */
 #define PRZ_FLAG_NO_LOCK	BIT(0)
+#define PRZ_FLAG_ZAP_OLD	BIT(1)
 
 struct persistent_ram_buffer;
 struct rs_control;

commit 1227daa43bce1318ff6fb54e6cd862b4f60245c7
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 17 17:20:35 2018 -0700

    pstore/ram: Clarify resource reservation labels
    
    When ramoops reserved a memory region in the kernel, it had an unhelpful
    label of "persistent_memory". When reading /proc/iomem, it would be
    repeated many times, did not hint that it was ramoops in particular,
    and didn't clarify very much about what each was used for:
    
    400000000-407ffffff : Persistent Memory (legacy)
      400000000-400000fff : persistent_memory
      400001000-400001fff : persistent_memory
    ...
      4000ff000-4000fffff : persistent_memory
    
    Instead, this adds meaningful labels for how the various regions are
    being used:
    
    400000000-407ffffff : Persistent Memory (legacy)
      400000000-400000fff : ramoops:dump(0/252)
      400001000-400001fff : ramoops:dump(1/252)
    ...
      4000fc000-4000fcfff : ramoops:dump(252/252)
      4000fd000-4000fdfff : ramoops:console
      4000fe000-4000fe3ff : ramoops:ftrace(0/3)
      4000fe400-4000fe7ff : ramoops:ftrace(1/3)
      4000fe800-4000febff : ramoops:ftrace(2/3)
      4000fec00-4000fefff : ramoops:ftrace(3/3)
      4000ff000-4000fffff : ramoops:pmsg
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Joel Fernandes (Google) <joel@joelfernandes.org>
    Tested-by: Sai Prakash Ranjan <saiprakash.ranjan@codeaurora.org>
    Tested-by: Guenter Roeck <groeck@chromium.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index e6d226464838..602d64725222 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -46,6 +46,7 @@ struct persistent_ram_zone {
 	phys_addr_t paddr;
 	size_t size;
 	void *vaddr;
+	char *label;
 	struct persistent_ram_buffer *buffer;
 	size_t buffer_size;
 	u32 flags;
@@ -65,7 +66,7 @@ struct persistent_ram_zone {
 
 struct persistent_ram_zone *persistent_ram_new(phys_addr_t start, size_t size,
 			u32 sig, struct persistent_ram_ecc_info *ecc_info,
-			unsigned int memtype, u32 flags);
+			unsigned int memtype, u32 flags, char *label);
 void persistent_ram_free(struct persistent_ram_zone *prz);
 void persistent_ram_zap(struct persistent_ram_zone *prz);
 

commit f2531f1976d98a7a4328da7f3cbf31b7c1927738
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Mar 7 12:18:33 2018 -0800

    pstore/ram: Do not use stack VLA for parity workspace
    
    Instead of using a stack VLA for the parity workspace, preallocate a
    memory region. The preallocation is done to keep from needing to perform
    allocations during crash dump writing, etc. This also fixes a missed
    release of librs on free.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index 9395f06e8372..e6d226464838 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -39,6 +39,7 @@ struct persistent_ram_ecc_info {
 	int ecc_size;
 	int symsize;
 	int poly;
+	uint16_t *par;
 };
 
 struct persistent_ram_zone {

commit a1cf53ac6d156721afa86453d5e8423461881231
Author: Joel Fernandes <joelaf@google.com>
Date:   Thu Oct 20 00:34:04 2016 -0700

    ramoops: Split ftrace buffer space into per-CPU zones
    
    If the RAMOOPS_FLAG_FTRACE_PER_CPU flag is passed to ramoops pdata, split
    the ftrace space into multiple zones depending on the number of CPUs.
    
    This speeds up the performance of function tracing by about 280% in my
    tests as we avoid the locking. The trade off being lesser space available
    per CPU. Let the ramoops user decide which option they want based on pdata
    flag.
    
    Signed-off-by: Joel Fernandes <joelaf@google.com>
    [kees: added max_ftrace_cnt to track size, added DT logic and docs]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index 4058bf991868..9395f06e8372 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -86,6 +86,8 @@ ssize_t persistent_ram_ecc_string(struct persistent_ram_zone *prz,
  * @mem_address	physical memory address to contain ramoops
  */
 
+#define RAMOOPS_FLAG_FTRACE_PER_CPU	BIT(0)
+
 struct ramoops_platform_data {
 	unsigned long	mem_size;
 	phys_addr_t	mem_address;
@@ -95,6 +97,7 @@ struct ramoops_platform_data {
 	unsigned long	ftrace_size;
 	unsigned long	pmsg_size;
 	int		dump_oops;
+	u32		flags;
 	struct persistent_ram_ecc_info ecc_info;
 };
 

commit 663deb47880f2283809669563c5a52ac7c6aef1a
Author: Joel Fernandes <joelaf@google.com>
Date:   Thu Oct 20 00:34:01 2016 -0700

    pstore: Allow prz to control need for locking
    
    In preparation of not locking at all for certain buffers depending on if
    there's contention, make locking optional depending on the initialization
    of the prz.
    
    Signed-off-by: Joel Fernandes <joelaf@google.com>
    [kees: moved locking flag into prz instead of via caller arguments]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index 244d2423dbaf..4058bf991868 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -24,6 +24,13 @@
 #include <linux/list.h>
 #include <linux/types.h>
 
+/*
+ * Choose whether access to the RAM zone requires locking or not.  If a zone
+ * can be written to from different CPUs like with ftrace for example, then
+ * PRZ_FLAG_NO_LOCK is used. For all other cases, locking is required.
+ */
+#define PRZ_FLAG_NO_LOCK	BIT(0)
+
 struct persistent_ram_buffer;
 struct rs_control;
 
@@ -40,6 +47,7 @@ struct persistent_ram_zone {
 	void *vaddr;
 	struct persistent_ram_buffer *buffer;
 	size_t buffer_size;
+	u32 flags;
 	raw_spinlock_t buffer_lock;
 
 	/* ECC correction */
@@ -56,7 +64,7 @@ struct persistent_ram_zone {
 
 struct persistent_ram_zone *persistent_ram_new(phys_addr_t start, size_t size,
 			u32 sig, struct persistent_ram_ecc_info *ecc_info,
-			unsigned int memtype);
+			unsigned int memtype, u32 flags);
 void persistent_ram_free(struct persistent_ram_zone *prz);
 void persistent_ram_zap(struct persistent_ram_zone *prz);
 

commit 109704492ef637956265ec2eb72ae7b3b39eb6f4
Author: Joel Fernandes <joelaf@google.com>
Date:   Thu Oct 20 00:34:00 2016 -0700

    pstore: Make spinlock per zone instead of global
    
    Currently pstore has a global spinlock for all zones. Since the zones
    are independent and modify different areas of memory, there's no need
    to have a global lock, so we should use a per-zone lock as introduced
    here. Also, when ramoops's ftrace use-case has a FTRACE_PER_CPU flag
    introduced later, which splits the ftrace memory area into a single zone
    per CPU, it will eliminate the need for locking. In preparation for this,
    make the locking optional.
    
    Signed-off-by: Joel Fernandes <joelaf@google.com>
    [kees: updated commit message]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index c668c861c96c..244d2423dbaf 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -40,6 +40,7 @@ struct persistent_ram_zone {
 	void *vaddr;
 	struct persistent_ram_buffer *buffer;
 	size_t buffer_size;
+	raw_spinlock_t buffer_lock;
 
 	/* ECC correction */
 	char *par_buffer;

commit 5bf6d1b92715f224ef6e1c3abca5dd63eeb4915d
Author: Mark Salyzyn <salyzyn@android.com>
Date:   Thu Sep 1 08:13:46 2016 -0700

    pstore/pmsg: drop bounce buffer
    
    Removing a bounce buffer copy operation in the pmsg driver path is
    always better. We also gain in overall performance by not requesting
    a vmalloc on every write as this can cause precious RT tasks, such
    as user facing media operation, to stall while memory is being
    reclaimed. Added a write_buf_user to the pstore functions, a backup
    platform write_buf_user that uses the small buffer that is part of
    the instance, and implemented a ramoops write_buf_user that only
    supports PSTORE_TYPE_PMSG.
    
    Signed-off-by: Mark Salyzyn <salyzyn@android.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index 4660aaa3195e..c668c861c96c 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -17,11 +17,12 @@
 #ifndef __LINUX_PSTORE_RAM_H__
 #define __LINUX_PSTORE_RAM_H__
 
+#include <linux/compiler.h>
 #include <linux/device.h>
+#include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/list.h>
 #include <linux/types.h>
-#include <linux/init.h>
 
 struct persistent_ram_buffer;
 struct rs_control;
@@ -59,7 +60,9 @@ void persistent_ram_free(struct persistent_ram_zone *prz);
 void persistent_ram_zap(struct persistent_ram_zone *prz);
 
 int persistent_ram_write(struct persistent_ram_zone *prz, const void *s,
-	unsigned int count);
+			 unsigned int count);
+int persistent_ram_write_user(struct persistent_ram_zone *prz,
+			      const void __user *s, unsigned int count);
 
 void persistent_ram_save_old(struct persistent_ram_zone *prz);
 size_t persistent_ram_old_size(struct persistent_ram_zone *prz);

commit 764fd639d794a1c0b0d203b19d1bef0451c23fb1
Author: Wiebe, Wladislav (Nokia - DE/Ulm) <wladislav.wiebe@nokia.com>
Date:   Fri Nov 13 12:10:05 2015 +0000

    pstore: Add support for 64 Bit address space
    
    Some architectures have their reserved RAM in 64 Bit address space.
    Therefore convert mem_address module parameter to ullong.
    
    Signed-off-by: Wladislav Wiebe <wladislav.wiebe@nokia.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index 9c9d6c154c8e..4660aaa3195e 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -76,7 +76,7 @@ ssize_t persistent_ram_ecc_string(struct persistent_ram_zone *prz,
 
 struct ramoops_platform_data {
 	unsigned long	mem_size;
-	unsigned long	mem_address;
+	phys_addr_t	mem_address;
 	unsigned int	mem_type;
 	unsigned long	record_size;
 	unsigned long	console_size;

commit 9d5438f462abd6398cdb7b3211bdcec271873a3b
Author: Mark Salyzyn <salyzyn@android.com>
Date:   Fri Jan 16 16:01:10 2015 -0800

    pstore: Add pmsg - user-space accessible pstore object
    
    A secured user-space accessible pstore object. Writes
    to /dev/pmsg0 are appended to the buffer, on reboot
    the persistent contents are available in
    /sys/fs/pstore/pmsg-ramoops-[ID].
    
    One possible use is syslogd, or other daemon, can
    write messages, then on reboot provides a means to
    triage user-space activities leading up to a panic
    as a companion to the pstore dmesg or console logs.
    
    Signed-off-by: Mark Salyzyn <salyzyn@android.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index 4af3fdc85b01..9c9d6c154c8e 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -81,6 +81,7 @@ struct ramoops_platform_data {
 	unsigned long	record_size;
 	unsigned long	console_size;
 	unsigned long	ftrace_size;
+	unsigned long	pmsg_size;
 	int		dump_oops;
 	struct persistent_ram_ecc_info ecc_info;
 };

commit 027bc8b08242c59e19356b4b2c189f2d849ab660
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Sep 16 13:50:01 2014 -0700

    pstore-ram: Allow optional mapping with pgprot_noncached
    
    On some ARMs the memory can be mapped pgprot_noncached() and still
    be working for atomic operations. As pointed out by Colin Cross
    <ccross@android.com>, in some cases you do want to use
    pgprot_noncached() if the SoC supports it to see a debug printk
    just before a write hanging the system.
    
    On ARMs, the atomic operations on strongly ordered memory are
    implementation defined. So let's provide an optional kernel parameter
    for configuring pgprot_noncached(), and use pgprot_writecombine() by
    default.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Rob Herring <robherring2@gmail.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Anton Vorontsov <anton@enomsg.org>
    Cc: Colin Cross <ccross@android.com>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: stable@vger.kernel.org
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index 9974975d40db..4af3fdc85b01 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -53,7 +53,8 @@ struct persistent_ram_zone {
 };
 
 struct persistent_ram_zone *persistent_ram_new(phys_addr_t start, size_t size,
-			u32 sig, struct persistent_ram_ecc_info *ecc_info);
+			u32 sig, struct persistent_ram_ecc_info *ecc_info,
+			unsigned int memtype);
 void persistent_ram_free(struct persistent_ram_zone *prz);
 void persistent_ram_zap(struct persistent_ram_zone *prz);
 
@@ -76,6 +77,7 @@ ssize_t persistent_ram_ecc_string(struct persistent_ram_zone *prz,
 struct ramoops_platform_data {
 	unsigned long	mem_size;
 	unsigned long	mem_address;
+	unsigned int	mem_type;
 	unsigned long	record_size;
 	unsigned long	console_size;
 	unsigned long	ftrace_size;

commit c31ad081e8734aab3fb45d2f32e9969994dd076e
Author: Arve Hjønnevåg <arve@android.com>
Date:   Tue May 22 16:33:23 2012 -0700

    pstore/ram: Allow specifying ecc parameters in platform data
    
    Allow specifying ecc parameters in platform data
    
    Signed-off-by: Arve Hjønnevåg <arve@android.com>
    [jstultz: Tweaked commit subject & add commit message]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Anton Vorontsov <anton@enomsg.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index cb6ab5feab67..9974975d40db 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -26,6 +26,13 @@
 struct persistent_ram_buffer;
 struct rs_control;
 
+struct persistent_ram_ecc_info {
+	int block_size;
+	int ecc_size;
+	int symsize;
+	int poly;
+};
+
 struct persistent_ram_zone {
 	phys_addr_t paddr;
 	size_t size;
@@ -39,15 +46,14 @@ struct persistent_ram_zone {
 	struct rs_control *rs_decoder;
 	int corrected_bytes;
 	int bad_blocks;
-	int ecc_block_size;
-	int ecc_size;
+	struct persistent_ram_ecc_info ecc_info;
 
 	char *old_log;
 	size_t old_log_size;
 };
 
 struct persistent_ram_zone *persistent_ram_new(phys_addr_t start, size_t size,
-					       u32 sig, int ecc_size);
+			u32 sig, struct persistent_ram_ecc_info *ecc_info);
 void persistent_ram_free(struct persistent_ram_zone *prz);
 void persistent_ram_zap(struct persistent_ram_zone *prz);
 
@@ -74,7 +80,7 @@ struct ramoops_platform_data {
 	unsigned long	console_size;
 	unsigned long	ftrace_size;
 	int		dump_oops;
-	int		ecc_size;
+	struct persistent_ram_ecc_info ecc_info;
 };
 
 #endif

commit f568f6ca811fe681ecfd11c4ce78b6aa488020c0
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 15:02:05 2012 -0800

    pstore: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit from the pstore filesystem.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Anton Vorontsov <cbouatmailru@gmail.com>
    Cc: Colin Cross <ccross@android.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index 098d2a838296..cb6ab5feab67 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -46,9 +46,8 @@ struct persistent_ram_zone {
 	size_t old_log_size;
 };
 
-struct persistent_ram_zone * __devinit persistent_ram_new(phys_addr_t start,
-							  size_t size, u32 sig,
-							  int ecc_size);
+struct persistent_ram_zone *persistent_ram_new(phys_addr_t start, size_t size,
+					       u32 sig, int ecc_size);
 void persistent_ram_free(struct persistent_ram_zone *prz);
 void persistent_ram_zap(struct persistent_ram_zone *prz);
 

commit cbe7cbf5a666ad9dfe2e0c276066131af73769ab
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Tue Jul 17 12:11:12 2012 -0700

    pstore/ram: Make tracing log versioned
    
    Decoding the binary trace w/ a different kernel might be troublesome
    since we convert addresses to symbols. For kernels with minimal changes,
    the mappings would probably match, but it's not guaranteed at all.
    (But still we could convert the addresses by hand, since we do print
    raw addresses.)
    
    If we use modules, the symbols could be loaded at different addresses
    from the previously booted kernel, and so this would also fail, but
    there's nothing we can do about it.
    
    Also, the binary data format that pstore/ram is using in its ringbuffer
    may change between the kernels, so here we too must ensure that we're
    running the same kernel.
    
    So, there are two questions really:
    
    1. How to compute the unique kernel tag;
    2. Where to store it.
    
    In this patch we're using LINUX_VERSION_CODE, just as hibernation
    (suspend-to-disk) does. This way we are protecting from the kernel
    version mismatch, making sure that we're running the same kernel
    version and patch level. We could use CRC of a symbol table (as
    suggested by Tony Luck), but for now let's not be that strict.
    
    And as for storing, we are using a small trick here. Instead of
    allocating a dedicated buffer for the tag (i.e. another prz), or
    hacking ram_core routines to "reserve" some control data in the
    buffer, we are just encoding the tag into the buffer signature
    (and XOR'ing it with the actual signature value, so that buffers
    not needing a tag can just pass zero, which will result into the
    plain old PRZ signature).
    
    Suggested-by: Steven Rostedt <rostedt@goodmis.org>
    Suggested-by: Tony Luck <tony.luck@intel.com>
    Suggested-by: Colin Cross <ccross@android.com>
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index ba2b211aaa81..098d2a838296 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -47,7 +47,7 @@ struct persistent_ram_zone {
 };
 
 struct persistent_ram_zone * __devinit persistent_ram_new(phys_addr_t start,
-							  size_t size,
+							  size_t size, u32 sig,
 							  int ecc_size);
 void persistent_ram_free(struct persistent_ram_zone *prz);
 void persistent_ram_zap(struct persistent_ram_zone *prz);

commit 67a101f573b0cb1043c8c305112113450cb9fdbf
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Tue Jul 17 11:37:07 2012 -0700

    pstore: Headers should include all stuff they use
    
    Headers should really include all the needed prototypes, types, defines
    etc. to be self-contained. This is a long-standing issue, but apparently
    the new tracing code unearthed it (SMP=n is also a prerequisite):
    
    In file included from fs/pstore/internal.h:4:0,
                     from fs/pstore/ftrace.c:21:
    include/linux/pstore.h:43:15: error: field ‘read_mutex’ has incomplete type
    
    While at it, I also added the following:
    
    linux/types.h -> size_t, phys_addr_t, uXX and friends
    linux/spinlock.h -> spinlock_t
    linux/errno.h -> Exxxx
    linux/time.h -> struct timespec (struct passed by value)
    struct module and rs_control forward declaration (passed via pointers).
    
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index af848e1593b9..ba2b211aaa81 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -24,6 +24,7 @@
 #include <linux/init.h>
 
 struct persistent_ram_buffer;
+struct rs_control;
 
 struct persistent_ram_zone {
 	phys_addr_t paddr;

commit a694d1b5916a486ce25fb5f2b39f2627f7afd5f3
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Mon Jul 9 17:10:44 2012 -0700

    pstore/ram: Add ftrace messages handling
    
    The ftrace log size is configurable via ramoops.ftrace_size
    module option, and the log itself is available via
    <pstore-mount>/ftrace-ramoops file.
    
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index dcf805f56bc6..af848e1593b9 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -72,6 +72,7 @@ struct ramoops_platform_data {
 	unsigned long	mem_address;
 	unsigned long	record_size;
 	unsigned long	console_size;
+	unsigned long	ftrace_size;
 	int		dump_oops;
 	int		ecc_size;
 };

commit c1743cbc8d20d208bb1d2b10598204f2d89b144c
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Mon Jul 9 17:03:20 2012 -0700

    pstore/ram_core: Get rid of prz->ecc enable/disable flag
    
    Nowadays we can use prz->ecc_size as a flag, no need for the special
    member in the prz struct.
    
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index 94b79f173365..dcf805f56bc6 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -33,7 +33,6 @@ struct persistent_ram_zone {
 	size_t buffer_size;
 
 	/* ECC correction */
-	bool ecc;
 	char *par_buffer;
 	char *par_header;
 	struct rs_control *rs_decoder;

commit 5ca5d4e61d0cac15f36160ab48425c6e43bf2e2f
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Mon Jul 9 17:03:19 2012 -0700

    pstore/ram: Make ECC size configurable
    
    This is now pretty straightforward: instead of using bool, just pass
    an integer. For backwards compatibility ramoops.ecc=1 means 16 bytes
    ECC (using 1 byte for ECC isn't much of use anyway).
    
    Suggested-by: Arve Hjønnevåg <arve@android.com>
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index a0975c02194a..94b79f173365 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -48,7 +48,7 @@ struct persistent_ram_zone {
 
 struct persistent_ram_zone * __devinit persistent_ram_new(phys_addr_t start,
 							  size_t size,
-							  bool ecc);
+							  int ecc_size);
 void persistent_ram_free(struct persistent_ram_zone *prz);
 void persistent_ram_zap(struct persistent_ram_zone *prz);
 
@@ -74,7 +74,7 @@ struct ramoops_platform_data {
 	unsigned long	record_size;
 	unsigned long	console_size;
 	int		dump_oops;
-	bool		ecc;
+	int		ecc_size;
 };
 
 #endif

commit 4a53ffae6afc94bab803087245b3b45e712c21c8
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Mon Jul 9 17:03:18 2012 -0700

    pstore/ram_core: Get rid of prz->ecc_symsize and prz->ecc_poly
    
    The struct members were never used anywhere outside of
    persistent_ram_init_ecc(), so there's actually no need for them
    to be in the struct.
    
    If we ever want to make polynomial or symbol size configurable,
    it would make more sense to just pass initialized rs_decoder
    to the persistent_ram init functions.
    
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index e681af92c04b..a0975c02194a 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -41,8 +41,6 @@ struct persistent_ram_zone {
 	int bad_blocks;
 	int ecc_block_size;
 	int ecc_size;
-	int ecc_symsize;
-	int ecc_poly;
 
 	char *old_log;
 	size_t old_log_size;

commit 924d37118f9e18825294b2012a10c6245d6c25e1
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Mon Jun 18 19:15:50 2012 -0700

    pstore/ram: Probe as early as possible
    
    Registering the platform driver before module_init allows us to log oopses
    that happen during device probing.
    
    This requires changing module_init to postcore_initcall, and switching
    from platform_driver_probe to platform_driver_register because the
    platform device is not registered when the platform driver is registered;
    and because we use driver_register, now can't use create_bundle() (since
    it will try to register the same driver once again), so we have to switch
    to platform_device_register_data().
    
    Also, some __init -> __devinit changes were needed.
    
    Overall, the registration logic is now much clearer, since we have only
    one driver registration point, and just an optional dummy device, which
    is created from the module parameters.
    
    Suggested-by: Colin Cross <ccross@android.com>
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index 2470bb591434..e681af92c04b 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -48,9 +48,9 @@ struct persistent_ram_zone {
 	size_t old_log_size;
 };
 
-struct persistent_ram_zone * __init persistent_ram_new(phys_addr_t start,
-						       size_t size,
-						       bool ecc);
+struct persistent_ram_zone * __devinit persistent_ram_new(phys_addr_t start,
+							  size_t size,
+							  bool ecc);
 void persistent_ram_free(struct persistent_ram_zone *prz);
 void persistent_ram_zap(struct persistent_ram_zone *prz);
 

commit b8587daa756141da776e3d4c3a5a315f5af78708
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Sat May 26 06:20:27 2012 -0700

    pstore/ram_core: Remove now unused code
    
    The code tried to maintain the global list of persistent ram zones,
    which isn't a great idea overall, plus since Android's ram_console
    is no longer there, we can remove some unused functions.
    
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Colin Cross <ccross@android.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index 9385d41cb1c3..2470bb591434 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -25,21 +25,6 @@
 
 struct persistent_ram_buffer;
 
-struct persistent_ram_descriptor {
-	const char	*name;
-	phys_addr_t	size;
-};
-
-struct persistent_ram {
-	phys_addr_t	start;
-	phys_addr_t	size;
-
-	int					num_descs;
-	struct persistent_ram_descriptor	*descs;
-
-	struct list_head node;
-};
-
 struct persistent_ram_zone {
 	phys_addr_t paddr;
 	size_t size;
@@ -63,15 +48,11 @@ struct persistent_ram_zone {
 	size_t old_log_size;
 };
 
-int persistent_ram_early_init(struct persistent_ram *ram);
-
 struct persistent_ram_zone * __init persistent_ram_new(phys_addr_t start,
 						       size_t size,
 						       bool ecc);
 void persistent_ram_free(struct persistent_ram_zone *prz);
 void persistent_ram_zap(struct persistent_ram_zone *prz);
-struct persistent_ram_zone *persistent_ram_init_ringbuffer(struct device *dev,
-		bool ecc);
 
 int persistent_ram_write(struct persistent_ram_zone *prz, const void *s,
 	unsigned int count);

commit b5d38e9bf1b0c4db19e336b59b38dfb5d28bf1bf
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Sat May 26 06:20:23 2012 -0700

    pstore/ram: Add console messages handling
    
    The console log size is configurable via ramoops.console_size
    module option, and the log itself is available via
    <pstore-mount>/console-ramoops file.
    
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index 3b823d49a85a..9385d41cb1c3 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -93,6 +93,7 @@ struct ramoops_platform_data {
 	unsigned long	mem_size;
 	unsigned long	mem_address;
 	unsigned long	record_size;
+	unsigned long	console_size;
 	int		dump_oops;
 	bool		ecc;
 };

commit fce397930475f7efc712a1345dc0dad269a10544
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Sat May 26 06:07:51 2012 -0700

    pstore/ram_core: Factor persistent_ram_zap() out of post_init()
    
    A handy function that we will use outside of ram_core soon. But
    so far just factor it out and start using it in post_init().
    
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index 4491e8ff36e6..3b823d49a85a 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -69,6 +69,7 @@ struct persistent_ram_zone * __init persistent_ram_new(phys_addr_t start,
 						       size_t size,
 						       bool ecc);
 void persistent_ram_free(struct persistent_ram_zone *prz);
+void persistent_ram_zap(struct persistent_ram_zone *prz);
 struct persistent_ram_zone *persistent_ram_init_ringbuffer(struct device *dev,
 		bool ecc);
 

commit 201e4aca5aa179e6c69a4dcd36a3562e56b8d670
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Sat May 26 06:07:49 2012 -0700

    pstore/ram: Should update old dmesg buffer before reading
    
    Without the update, we'll only see the new dmesg buffer after the
    reboot, but previously we could see it right away. Making an oops
    visible in pstore filesystem before reboot is a somewhat dubious
    feature, but removing it wasn't an intentional change, so let's
    restore it.
    
    For this we have to make persistent_ram_save_old() safe for calling
    multiple times, and also extern it.
    
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index 7ed7fd4dba49..4491e8ff36e6 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -75,6 +75,7 @@ struct persistent_ram_zone *persistent_ram_init_ringbuffer(struct device *dev,
 int persistent_ram_write(struct persistent_ram_zone *prz, const void *s,
 	unsigned int count);
 
+void persistent_ram_save_old(struct persistent_ram_zone *prz);
 size_t persistent_ram_old_size(struct persistent_ram_zone *prz);
 void *persistent_ram_old(struct persistent_ram_zone *prz);
 void persistent_ram_free_old(struct persistent_ram_zone *prz);

commit 39eb7e9791866973dbb7a3a6d2061d70356c7d90
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Thu May 17 00:15:34 2012 -0700

    pstore/ram: Add ECC support
    
    This is now straightforward: just introduce a module parameter and pass
    the needed value to persistent_ram_new().
    
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Acked-by: Marco Stornelli <marco.stornelli@gmail.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index ffe24a52c5af..7ed7fd4dba49 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -92,6 +92,7 @@ struct ramoops_platform_data {
 	unsigned long	mem_address;
 	unsigned long	record_size;
 	int		dump_oops;
+	bool		ecc;
 };
 
 #endif

commit cddb8751c80348df75149f44fc3bf38d3dd1f3e6
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Thu May 17 00:15:08 2012 -0700

    staging: android: persistent_ram: Move to fs/pstore/ram_core.c
    
    This is a first step for adding ECC support for pstore RAM backend: we
    will use the persistent_ram routines, kindly provided by Google.
    
    Basically, persistent_ram is a set of helper routines to deal with the
    [optionally] ECC-protected persistent ram regions.
    
    A bit of Makefile, Kconfig and header files adjustments were needed
    because of the move.
    
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
index fa4cb02da413..ffe24a52c5af 100644
--- a/include/linux/pstore_ram.h
+++ b/include/linux/pstore_ram.h
@@ -1,6 +1,86 @@
+/*
+ * Copyright (C) 2010 Marco Stornelli <marco.stornelli@gmail.com>
+ * Copyright (C) 2011 Kees Cook <keescook@chromium.org>
+ * Copyright (C) 2011 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
 #ifndef __LINUX_PSTORE_RAM_H__
 #define __LINUX_PSTORE_RAM_H__
 
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/init.h>
+
+struct persistent_ram_buffer;
+
+struct persistent_ram_descriptor {
+	const char	*name;
+	phys_addr_t	size;
+};
+
+struct persistent_ram {
+	phys_addr_t	start;
+	phys_addr_t	size;
+
+	int					num_descs;
+	struct persistent_ram_descriptor	*descs;
+
+	struct list_head node;
+};
+
+struct persistent_ram_zone {
+	phys_addr_t paddr;
+	size_t size;
+	void *vaddr;
+	struct persistent_ram_buffer *buffer;
+	size_t buffer_size;
+
+	/* ECC correction */
+	bool ecc;
+	char *par_buffer;
+	char *par_header;
+	struct rs_control *rs_decoder;
+	int corrected_bytes;
+	int bad_blocks;
+	int ecc_block_size;
+	int ecc_size;
+	int ecc_symsize;
+	int ecc_poly;
+
+	char *old_log;
+	size_t old_log_size;
+};
+
+int persistent_ram_early_init(struct persistent_ram *ram);
+
+struct persistent_ram_zone * __init persistent_ram_new(phys_addr_t start,
+						       size_t size,
+						       bool ecc);
+void persistent_ram_free(struct persistent_ram_zone *prz);
+struct persistent_ram_zone *persistent_ram_init_ringbuffer(struct device *dev,
+		bool ecc);
+
+int persistent_ram_write(struct persistent_ram_zone *prz, const void *s,
+	unsigned int count);
+
+size_t persistent_ram_old_size(struct persistent_ram_zone *prz);
+void *persistent_ram_old(struct persistent_ram_zone *prz);
+void persistent_ram_free_old(struct persistent_ram_zone *prz);
+ssize_t persistent_ram_ecc_string(struct persistent_ram_zone *prz,
+	char *str, size_t len);
+
 /*
  * Ramoops platform data
  * @mem_size	memory size for ramoops

commit 1894a253db97059bc299b834b76f665bc6586b1d
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Wed May 16 05:43:08 2012 -0700

    ramoops: Move to fs/pstore/ram.c
    
    Since ramoops was converted to pstore, it has nothing to do with character
    devices nowadays. Instead, today it is just a RAM backend for pstore.
    
    The patch just moves things around. There are a few changes were needed
    because of the move:
    
    1. Kconfig and Makefiles fixups, of course.
    
    2. In pstore/ram.c we have to play a bit with MODULE_PARAM_PREFIX, this
       is needed to keep user experience the same as with ramoops driver
       (i.e. so that ramoops.foo kernel command line arguments would still
       work).
    
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Acked-by: Marco Stornelli <marco.stornelli@gmail.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h
new file mode 100644
index 000000000000..fa4cb02da413
--- /dev/null
+++ b/include/linux/pstore_ram.h
@@ -0,0 +1,17 @@
+#ifndef __LINUX_PSTORE_RAM_H__
+#define __LINUX_PSTORE_RAM_H__
+
+/*
+ * Ramoops platform data
+ * @mem_size	memory size for ramoops
+ * @mem_address	physical memory address to contain ramoops
+ */
+
+struct ramoops_platform_data {
+	unsigned long	mem_size;
+	unsigned long	mem_address;
+	unsigned long	record_size;
+	int		dump_oops;
+};
+
+#endif
