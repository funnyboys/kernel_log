commit e31a50162feb352147d3fc87b9e036703c8f2636
Author: Alex Elder <elder@linaro.org>
Date:   Thu Mar 12 11:44:27 2020 -0500

    bitfield.h: add FIELD_MAX() and field_max()
    
    Define FIELD_MAX(), which supplies the maximum value that can be
    represented by a field value.  Define field_max() as well, to go
    along with the lower-case forms of the field mask functions.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Acked-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/bitfield.h b/include/linux/bitfield.h
index 4bbb5f1c8b5b..48ea093ff04c 100644
--- a/include/linux/bitfield.h
+++ b/include/linux/bitfield.h
@@ -55,6 +55,19 @@
 					      (1ULL << __bf_shf(_mask))); \
 	})
 
+/**
+ * FIELD_MAX() - produce the maximum value representable by a field
+ * @_mask: shifted mask defining the field's length and position
+ *
+ * FIELD_MAX() returns the maximum value that can be held in the field
+ * specified by @_mask.
+ */
+#define FIELD_MAX(_mask)						\
+	({								\
+		__BF_FIELD_CHECK(_mask, 0ULL, 0ULL, "FIELD_MAX: ");	\
+		(typeof(_mask))((_mask) >> __bf_shf(_mask));		\
+	})
+
 /**
  * FIELD_FIT() - check if value fits in the field
  * @_mask: shifted mask defining the field's length and position
@@ -110,6 +123,7 @@ static __always_inline u64 field_mask(u64 field)
 {
 	return field / field_multiplier(field);
 }
+#define field_max(field)	((typeof(field))field_mask(field))
 #define ____MAKE_OP(type,base,to,from)					\
 static __always_inline __##type type##_encode_bits(base v, base field)	\
 {									\

commit 1802d0beecafe581ad584634ba92f8a471d8a63a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:21 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 174
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 655 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.575739538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/bitfield.h b/include/linux/bitfield.h
index 3f1ef4450a7c..4bbb5f1c8b5b 100644
--- a/include/linux/bitfield.h
+++ b/include/linux/bitfield.h
@@ -1,15 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (C) 2014 Felix Fietkau <nbd@nbd.name>
  * Copyright (C) 2004 - 2009 Ivo van Doorn <IvDoorn@gmail.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #ifndef _LINUX_BITFIELD_H

commit e36488c83b6d871b35dd555afb2d434bd61687cf
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Aug 17 15:43:36 2018 -0700

    bitfield: avoid gcc-8 -Wint-in-bool-context warning
    
    Passing an enum into FIELD_GET() produces a long but harmless warning on
    newer compilers:
    
                       from include/linux/linkage.h:7,
                       from include/linux/kernel.h:7,
                       from include/linux/skbuff.h:17,
                       from include/linux/if_ether.h:23,
                       from include/linux/etherdevice.h:25,
                       from drivers/net/wireless/intel/iwlwifi/mvm/rxmq.c:63:
      drivers/net/wireless/intel/iwlwifi/mvm/rxmq.c: In function 'iwl_mvm_rx_mpdu_mq':
      include/linux/bitfield.h:56:20: error: enum constant in boolean context [-Werror=int-in-bool-context]
         BUILD_BUG_ON_MSG(!(_mask), _pfx "mask is zero"); \
                          ^
      ...
      include/linux/bitfield.h:103:3: note: in expansion of macro '__BF_FIELD_CHECK'
         __BF_FIELD_CHECK(_mask, _reg, 0U, "FIELD_GET: "); \
         ^~~~~~~~~~~~~~~~
      drivers/net/wireless/intel/iwlwifi/mvm/rxmq.c:1025:21: note: in expansion of macro 'FIELD_GET'
          le16_encode_bits(FIELD_GET(IWL_RX_HE_PHY_SIBG_SYM_OR_USER_NUM_MASK,
    
    The problem here is that the caller has no idea how the macro gets
    expanding, leading to a false-positive.  It can be trivially avoided by
    doing a comparison against zero.
    
    This only recently started appearing as the iwlwifi driver was patched
    to use FIELD_GET.
    
    Link: http://lkml.kernel.org/r/20180813220950.194841-1-arnd@arndb.de
    Fixes: 514c30696fbc ("iwlwifi: add support for IEEE802.11ax")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: Jakub Kicinski <jakub.kicinski@netronome.com>
    Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: David Laight <David.Laight@ACULAB.COM>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/bitfield.h b/include/linux/bitfield.h
index 65a6981eef7b..3f1ef4450a7c 100644
--- a/include/linux/bitfield.h
+++ b/include/linux/bitfield.h
@@ -53,7 +53,7 @@
 	({								\
 		BUILD_BUG_ON_MSG(!__builtin_constant_p(_mask),		\
 				 _pfx "mask is not constant");		\
-		BUILD_BUG_ON_MSG(!(_mask), _pfx "mask is zero");	\
+		BUILD_BUG_ON_MSG((_mask) == 0, _pfx "mask is zero");	\
 		BUILD_BUG_ON_MSG(__builtin_constant_p(_val) ?		\
 				 ~((_mask) >> __bf_shf(_mask)) & (_val) : 0, \
 				 _pfx "value too large for the field"); \

commit 37a3862e1238262e9866d5d66e5f5f9069cee3a1
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed Jun 20 08:58:29 2018 +0200

    bitfield: add u8 helpers
    
    There's no reason why we shouldn't pack/unpack bits into/from
    u8 values/registers/etc., so add u8 helpers.
    
    Use the ____MAKE_OP() macro directly to avoid having nonsense
    le8_encode_bits() and similar functions.
    
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/include/linux/bitfield.h b/include/linux/bitfield.h
index 147a7bb341dd..65a6981eef7b 100644
--- a/include/linux/bitfield.h
+++ b/include/linux/bitfield.h
@@ -143,6 +143,7 @@ static __always_inline base type##_get_bits(__##type v, base field)	\
 	____MAKE_OP(le##size,u##size,cpu_to_le##size,le##size##_to_cpu)	\
 	____MAKE_OP(be##size,u##size,cpu_to_be##size,be##size##_to_cpu)	\
 	____MAKE_OP(u##size,u##size,,)
+____MAKE_OP(u8,u8,,)
 __MAKE_OP(16)
 __MAKE_OP(32)
 __MAKE_OP(64)

commit e7d4a95da86e0b048702765bbdcdc968aaf312e7
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed Jun 20 08:58:28 2018 +0200

    bitfield: fix *_encode_bits()
    
    There's a bug in *_encode_bits() in using ~field_multiplier() for
    the check whether or not the constant value fits into the field,
    this is wrong and clearly ~field_mask() was intended. This was
    triggering for me for both constant and non-constant values.
    
    Additionally, make this case actually into an compile error.
    Declaring the extern function that will never exist with just a
    warning is pointless as then later we'll just get a link error.
    
    While at it, also fix the indentation in those lines I'm touching.
    
    Finally, as suggested by Andy Shevchenko, add some tests and for
    that introduce also u8 helpers. The tests don't compile without
    the fix, showing that it's necessary.
    
    Fixes: 00b0c9b82663 ("Add primitives for manipulating bitfields both in host- and fixed-endian.")
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/include/linux/bitfield.h b/include/linux/bitfield.h
index cf2588d81148..147a7bb341dd 100644
--- a/include/linux/bitfield.h
+++ b/include/linux/bitfield.h
@@ -104,7 +104,7 @@
 		(typeof(_mask))(((_reg) & (_mask)) >> __bf_shf(_mask));	\
 	})
 
-extern void __compiletime_warning("value doesn't fit into mask")
+extern void __compiletime_error("value doesn't fit into mask")
 __field_overflow(void);
 extern void __compiletime_error("bad bitfield mask")
 __bad_mask(void);
@@ -121,8 +121,8 @@ static __always_inline u64 field_mask(u64 field)
 #define ____MAKE_OP(type,base,to,from)					\
 static __always_inline __##type type##_encode_bits(base v, base field)	\
 {									\
-        if (__builtin_constant_p(v) &&	(v & ~field_multiplier(field)))	\
-			    __field_overflow();				\
+	if (__builtin_constant_p(v) && (v & ~field_mask(field)))	\
+		__field_overflow();					\
 	return to((v & field_mask(field)) * field_multiplier(field));	\
 }									\
 static __always_inline __##type type##_replace_bits(__##type old,	\

commit 00b0c9b82663ac42e5a09f58ce960f81f29d64ee
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 14 21:27:55 2017 -0500

    Add primitives for manipulating bitfields both in host- and fixed-endian.
    
    The following primitives are defined in linux/bitfield.h:
    
    * u32 le32_get_bits(__le32 val, u32 field) extracts the contents of the
      bitfield specified by @field in little-endian 32bit object @val and
      converts it to host-endian.
    
    * void le32p_replace_bits(__le32 *p, u32 v, u32 field) replaces
      the contents of the bitfield specified by @field in little-endian
      32bit object pointed to by @p with the value of @v.  New value is
      given in host-endian and stored as little-endian.
    
    * __le32 le32_replace_bits(__le32 old, u32 v, u32 field) is equivalent to
      ({__le32 tmp = old; le32p_replace_bits(&tmp, v, field); tmp;})
      In other words, instead of modifying an object in memory, it takes
      the initial value and returns the modified one.
    
    * __le32 le32_encode_bits(u32 v, u32 field) is equivalent to
      le32_replace_bits(0, v, field).  In other words, it returns a little-endian
      32bit object with the bitfield specified by @field containing the
      value of @v and all bits outside that bitfield being zero.
    
    Such set of helpers is defined for each of little-, big- and host-endian
    types; e.g. u64_get_bits(val, field) will return the contents of the bitfield
    specified by @field in host-endian 64bit object @val, etc.  Of course, for
    host-endian no conversion is involved.
    
    Fields to access are specified as GENMASK() values - an N-bit field
    starting at bit #M is encoded as GENMASK(M + N - 1, M).  Note that
    bit numbers refer to endianness of the object we are working with -
    e.g. GENMASK(11, 0) in __be16 refers to the second byte and the lower
    4 bits of the first byte.  In __le16 it would refer to the first byte
    and the lower 4 bits of the second byte, etc.
    
    Field specification must be a constant; __builtin_constant_p() doesn't
    have to be true for it, but compiler must be able to evaluate it at
    build time.  If it cannot or if the value does not encode any bitfield,
    the build will fail.
    
    If the value being stored in a bitfield is a constant that does not fit
    into that bitfield, a warning will be generated at compile time.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/bitfield.h b/include/linux/bitfield.h
index 1030651f8309..cf2588d81148 100644
--- a/include/linux/bitfield.h
+++ b/include/linux/bitfield.h
@@ -16,6 +16,7 @@
 #define _LINUX_BITFIELD_H
 
 #include <linux/build_bug.h>
+#include <asm/byteorder.h>
 
 /*
  * Bitfield access macros
@@ -103,4 +104,49 @@
 		(typeof(_mask))(((_reg) & (_mask)) >> __bf_shf(_mask));	\
 	})
 
+extern void __compiletime_warning("value doesn't fit into mask")
+__field_overflow(void);
+extern void __compiletime_error("bad bitfield mask")
+__bad_mask(void);
+static __always_inline u64 field_multiplier(u64 field)
+{
+	if ((field | (field - 1)) & ((field | (field - 1)) + 1))
+		__bad_mask();
+	return field & -field;
+}
+static __always_inline u64 field_mask(u64 field)
+{
+	return field / field_multiplier(field);
+}
+#define ____MAKE_OP(type,base,to,from)					\
+static __always_inline __##type type##_encode_bits(base v, base field)	\
+{									\
+        if (__builtin_constant_p(v) &&	(v & ~field_multiplier(field)))	\
+			    __field_overflow();				\
+	return to((v & field_mask(field)) * field_multiplier(field));	\
+}									\
+static __always_inline __##type type##_replace_bits(__##type old,	\
+					base val, base field)		\
+{									\
+	return (old & ~to(field)) | type##_encode_bits(val, field);	\
+}									\
+static __always_inline void type##p_replace_bits(__##type *p,		\
+					base val, base field)		\
+{									\
+	*p = (*p & ~to(field)) | type##_encode_bits(val, field);	\
+}									\
+static __always_inline base type##_get_bits(__##type v, base field)	\
+{									\
+	return (from(v) & field)/field_multiplier(field);		\
+}
+#define __MAKE_OP(size)							\
+	____MAKE_OP(le##size,u##size,cpu_to_le##size,le##size##_to_cpu)	\
+	____MAKE_OP(be##size,u##size,cpu_to_be##size,be##size##_to_cpu)	\
+	____MAKE_OP(u##size,u##size,,)
+__MAKE_OP(16)
+__MAKE_OP(32)
+__MAKE_OP(64)
+#undef __MAKE_OP
+#undef ____MAKE_OP
+
 #endif

commit 8001541cc333b1a3c2c38e3b34475fa446b053da
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 17 15:27:49 2017 -0800

    include/linux/bitfield.h: include <linux/build_bug.h> instead of <linux/bug.h>
    
    Since commit bc6245e5efd7 ("bug: split BUILD_BUG stuff out into
    <linux/build_bug.h>"), #include <linux/build_bug.h> is better to pull
    minimal headers needed for BUILG_BUG() family.
    
    Link: http://lkml.kernel.org/r/1505700775-19826-1-git-send-email-yamada.masahiro@socionext.com
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Cc: Dinan Gunawardena <dinan.gunawardena@netronome.com>
    Cc: Kalle Valo <kvalo@codeaurora.org>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/bitfield.h b/include/linux/bitfield.h
index f2deb71958b2..1030651f8309 100644
--- a/include/linux/bitfield.h
+++ b/include/linux/bitfield.h
@@ -15,7 +15,7 @@
 #ifndef _LINUX_BITFIELD_H
 #define _LINUX_BITFIELD_H
 
-#include <linux/bug.h>
+#include <linux/build_bug.h>
 
 /*
  * Bitfield access macros

commit 7240767450d6d8380fb153e2998a1bb4ede7b029
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Oct 3 16:16:04 2017 -0700

    include/linux/bitfield.h: remove 32bit from FIELD_GET comment block
    
    I do not see anything that restricts this macro to 32 bit width.
    
    Link: http://lkml.kernel.org/r/1505921975-23379-1-git-send-email-yamada.masahiro@socionext.com
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/bitfield.h b/include/linux/bitfield.h
index 8b9d6fff002d..f2deb71958b2 100644
--- a/include/linux/bitfield.h
+++ b/include/linux/bitfield.h
@@ -92,7 +92,7 @@
 /**
  * FIELD_GET() - extract a bitfield element
  * @_mask: shifted mask defining the field's length and position
- * @_reg:  32bit value of entire bitfield
+ * @_reg:  value of entire bitfield
  *
  * FIELD_GET() extracts the field specified by @_mask from the
  * bitfield passed in as @_reg by masking and shifting it down.

commit 1697599ee301a52cded6499a09bd609f7f63fd06
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Thu Feb 9 09:17:27 2017 -0800

    bitfield.h: add FIELD_FIT() helper
    
    Add a helper for checking at runtime that a value will fit inside
    a specified field/mask.
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/bitfield.h b/include/linux/bitfield.h
index f6505d83069d..8b9d6fff002d 100644
--- a/include/linux/bitfield.h
+++ b/include/linux/bitfield.h
@@ -62,6 +62,19 @@
 					      (1ULL << __bf_shf(_mask))); \
 	})
 
+/**
+ * FIELD_FIT() - check if value fits in the field
+ * @_mask: shifted mask defining the field's length and position
+ * @_val:  value to test against the field
+ *
+ * Return: true if @_val can fit inside @_mask, false if @_val is too big.
+ */
+#define FIELD_FIT(_mask, _val)						\
+	({								\
+		__BF_FIELD_CHECK(_mask, 0ULL, _val, "FIELD_FIT: ");	\
+		!((((typeof(_mask))_val) << __bf_shf(_mask)) & ~(_mask)); \
+	})
+
 /**
  * FIELD_PREP() - prepare a bitfield element
  * @_mask: shifted mask defining the field's length and position

commit 3e9b3112ec74f192eaab976c3889e34255cae940
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Wed Aug 31 12:46:44 2016 +0100

    add basic register-field manipulation macros
    
    Common approach to accessing register fields is to define
    structures or sets of macros containing mask and shift pair.
    Operations on the register are then performed as follows:
    
     field = (reg >> shift) & mask;
    
     reg &= ~(mask << shift);
     reg |= (field & mask) << shift;
    
    Defining shift and mask separately is tedious.  Ivo van Doorn
    came up with an idea of computing them at compilation time
    based on a single shifted mask (later refined by Felix) which
    can be used like this:
    
     #define REG_FIELD 0x000ff000
    
     field = FIELD_GET(REG_FIELD, reg);
    
     reg &= ~REG_FIELD;
     reg |= FIELD_PREP(REG_FIELD, field);
    
    FIELD_{GET,PREP} macros take care of finding out what the
    appropriate shift is based on compilation time ffs operation.
    
    GENMASK can be used to define registers (which is usually
    less error-prone and easier to match with datasheets).
    
    This approach is the most convenient I've seen so to limit code
    multiplication let's move the macros to a global header file.
    Attempts to use static inlines instead of macros failed due
    to false positive triggering of BUILD_BUG_ON()s, especially with
    GCC < 6.0.
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Dinan Gunawardena <dinan.gunawardena@netronome.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/include/linux/bitfield.h b/include/linux/bitfield.h
new file mode 100644
index 000000000000..f6505d83069d
--- /dev/null
+++ b/include/linux/bitfield.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2014 Felix Fietkau <nbd@nbd.name>
+ * Copyright (C) 2004 - 2009 Ivo van Doorn <IvDoorn@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _LINUX_BITFIELD_H
+#define _LINUX_BITFIELD_H
+
+#include <linux/bug.h>
+
+/*
+ * Bitfield access macros
+ *
+ * FIELD_{GET,PREP} macros take as first parameter shifted mask
+ * from which they extract the base mask and shift amount.
+ * Mask must be a compilation time constant.
+ *
+ * Example:
+ *
+ *  #define REG_FIELD_A  GENMASK(6, 0)
+ *  #define REG_FIELD_B  BIT(7)
+ *  #define REG_FIELD_C  GENMASK(15, 8)
+ *  #define REG_FIELD_D  GENMASK(31, 16)
+ *
+ * Get:
+ *  a = FIELD_GET(REG_FIELD_A, reg);
+ *  b = FIELD_GET(REG_FIELD_B, reg);
+ *
+ * Set:
+ *  reg = FIELD_PREP(REG_FIELD_A, 1) |
+ *	  FIELD_PREP(REG_FIELD_B, 0) |
+ *	  FIELD_PREP(REG_FIELD_C, c) |
+ *	  FIELD_PREP(REG_FIELD_D, 0x40);
+ *
+ * Modify:
+ *  reg &= ~REG_FIELD_C;
+ *  reg |= FIELD_PREP(REG_FIELD_C, c);
+ */
+
+#define __bf_shf(x) (__builtin_ffsll(x) - 1)
+
+#define __BF_FIELD_CHECK(_mask, _reg, _val, _pfx)			\
+	({								\
+		BUILD_BUG_ON_MSG(!__builtin_constant_p(_mask),		\
+				 _pfx "mask is not constant");		\
+		BUILD_BUG_ON_MSG(!(_mask), _pfx "mask is zero");	\
+		BUILD_BUG_ON_MSG(__builtin_constant_p(_val) ?		\
+				 ~((_mask) >> __bf_shf(_mask)) & (_val) : 0, \
+				 _pfx "value too large for the field"); \
+		BUILD_BUG_ON_MSG((_mask) > (typeof(_reg))~0ull,		\
+				 _pfx "type of reg too small for mask"); \
+		__BUILD_BUG_ON_NOT_POWER_OF_2((_mask) +			\
+					      (1ULL << __bf_shf(_mask))); \
+	})
+
+/**
+ * FIELD_PREP() - prepare a bitfield element
+ * @_mask: shifted mask defining the field's length and position
+ * @_val:  value to put in the field
+ *
+ * FIELD_PREP() masks and shifts up the value.  The result should
+ * be combined with other fields of the bitfield using logical OR.
+ */
+#define FIELD_PREP(_mask, _val)						\
+	({								\
+		__BF_FIELD_CHECK(_mask, 0ULL, _val, "FIELD_PREP: ");	\
+		((typeof(_mask))(_val) << __bf_shf(_mask)) & (_mask);	\
+	})
+
+/**
+ * FIELD_GET() - extract a bitfield element
+ * @_mask: shifted mask defining the field's length and position
+ * @_reg:  32bit value of entire bitfield
+ *
+ * FIELD_GET() extracts the field specified by @_mask from the
+ * bitfield passed in as @_reg by masking and shifting it down.
+ */
+#define FIELD_GET(_mask, _reg)						\
+	({								\
+		__BF_FIELD_CHECK(_mask, _reg, 0U, "FIELD_GET: ");	\
+		(typeof(_mask))(((_reg) & (_mask)) >> __bf_shf(_mask));	\
+	})
+
+#endif
