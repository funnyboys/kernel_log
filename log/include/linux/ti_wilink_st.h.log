commit 4ea19ecf322c2f98ef87fc980b3851625b082ac2
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Mon Mar 23 19:25:06 2020 -0500

    ti_wilink_st.h: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>

diff --git a/include/linux/ti_wilink_st.h b/include/linux/ti_wilink_st.h
index eb6cbdf10e50..44a7f9169ac6 100644
--- a/include/linux/ti_wilink_st.h
+++ b/include/linux/ti_wilink_st.h
@@ -295,7 +295,7 @@ struct bts_header {
 	u32 magic;
 	u32 version;
 	u8 future[24];
-	u8 actions[0];
+	u8 actions[];
 } __attribute__ ((packed));
 
 /**
@@ -305,7 +305,7 @@ struct bts_header {
 struct bts_action {
 	u16 type;
 	u16 size;
-	u8 data[0];
+	u8 data[];
 } __attribute__ ((packed));
 
 struct bts_action_send {
@@ -315,7 +315,7 @@ struct bts_action_send {
 struct bts_action_wait {
 	u32 msec;
 	u32 size;
-	u8 data[0];
+	u8 data[];
 } __attribute__ ((packed));
 
 struct bts_action_delay {

commit 4505153954fdb1465d2b178288a9bf646f2a2166
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:47 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 333
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 59 temple place suite 330 boston ma 02111
      1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 136 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000436.384967451@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/ti_wilink_st.h b/include/linux/ti_wilink_st.h
index f2293028ab9d..eb6cbdf10e50 100644
--- a/include/linux/ti_wilink_st.h
+++ b/include/linux/ti_wilink_st.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  *  Shared Transport Header file
  *	To be included by the protocol stack drivers for
@@ -6,20 +7,6 @@
  *
  *  Copyright (C) 2009-2010 Texas Instruments
  *  Author: Pavan Savoy <pavan_savoy@ti.com>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
  */
 
 #ifndef TI_WILINK_ST_H

commit 4360fa22ad5b48a1d1e10e31ffb383ed8c977435
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Mon Jun 6 11:02:03 2016 +0200

    drivers: misc: ti-st: Use int instead of fuzzy char for callback status
    
    On mips and parisc:
    
        drivers/bluetooth/btwilink.c: In function 'ti_st_open':
        drivers/bluetooth/btwilink.c:174:21: warning: overflow in implicit constant conversion [-Woverflow]
           hst->reg_status = -EINPROGRESS;
    
        drivers/nfc/nfcwilink.c: In function 'nfcwilink_open':
        drivers/nfc/nfcwilink.c:396:31: warning: overflow in implicit constant conversion [-Woverflow]
          drv->st_register_cb_status = -EINPROGRESS;
    
    There are actually two issues:
      1. Whether "char" is signed or unsigned depends on the architecture.
         As the completion callback data is used to pass a (negative) error
         code, it should always be signed.
      2. EINPROGRESS is 150 on mips, 245 on parisc.
         Hence -EINPROGRESS doesn't fit in a signed 8-bit number.
    
    Change the callback status from "char" to "int" to fix these.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
    Acked-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/linux/ti_wilink_st.h b/include/linux/ti_wilink_st.h
index 0a0d56834c8e..f2293028ab9d 100644
--- a/include/linux/ti_wilink_st.h
+++ b/include/linux/ti_wilink_st.h
@@ -71,7 +71,7 @@ struct st_proto_s {
 	enum proto_type type;
 	long (*recv) (void *, struct sk_buff *);
 	unsigned char (*match_packet) (const unsigned char *data);
-	void (*reg_complete_cb) (void *, char data);
+	void (*reg_complete_cb) (void *, int data);
 	long (*write) (struct sk_buff *skb);
 	void *priv_data;
 

commit b05b7c7cc0324524dcda7fa7c2be1255290ee416
Author: Muhammad Hamza Farooq <mfarooq@visteon.com>
Date:   Fri Sep 11 16:42:38 2015 +0200

    ti-st: use worker instead of calling st_int_write in wake up
    
    The wake up method is called with the port lock held. The st_int_write
    method calls port->ops->write with tries to acquire the lock again,
    causing CPU to wait infinitely. Right way to do is to write data to port
    in worker thread.
    
    Signed-off-by: Muhammad Hamza Farooq <mfarooq@visteon.com>
    Signed-off-by: Jacob Siverskog <jacob@teenage.engineering>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/ti_wilink_st.h b/include/linux/ti_wilink_st.h
index d4217eff489f..0a0d56834c8e 100644
--- a/include/linux/ti_wilink_st.h
+++ b/include/linux/ti_wilink_st.h
@@ -158,6 +158,7 @@ struct st_data_s {
 	unsigned long ll_state;
 	void *kim_data;
 	struct tty_struct *tty;
+	struct work_struct work_write_wakeup;
 };
 
 /*

commit c0bd1b9e58959c51a4c939505f89721dfbc73c44
Author: Rob Herring <robh@kernel.org>
Date:   Wed Jul 22 13:17:15 2015 -0500

    Revert "ti-st: add device tree support"
    
    This reverts commit 46d0d33350e9b32642d745a8b46a954910196b4d.
    
    This binding is horrible and never should have been merged. It is not
    documented nor are there any in tree users, so reverting it will not
    break anything we care about. Lets revert it before we do have users.
    
    The problems with it are:
    
    - It is not documented.
    
    - The GPIO connection is described with a custom property and uses Linux
    GPIO numbering.
    
    - The UART connection is described using the Linux tty device name.
    
    Cc: Gigi Joseph <gigi.joseph@ti.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/ti_wilink_st.h b/include/linux/ti_wilink_st.h
index c78dcfeaf25f..d4217eff489f 100644
--- a/include/linux/ti_wilink_st.h
+++ b/include/linux/ti_wilink_st.h
@@ -86,7 +86,6 @@ struct st_proto_s {
 extern long st_register(struct st_proto_s *);
 extern long st_unregister(struct st_proto_s *);
 
-extern struct ti_st_plat_data   *dt_pdata;
 
 /*
  * header information used by st_core.c

commit 63e144c9d6ffa791c1402f4ee4551c1b9f5a336a
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Jan 15 14:42:27 2015 +0300

    ti-st: clean up data types (fix harmless memory corruption)
    
    The big issue here is:
    
            of_property_read_u32(np, "flow_cntrl", (u32 *)&dt_pdata->flow_cntrl);
    
    "->flow_cntrl" is a char so when we write a 32 bit number to it then it
    corrupts past the end of the char.  It's probably hard to notice because
    the struct has padding so the code works on little endian systems. But
    on a big endian system the code would fail and on a 64 bit, big endian
    systems then "nshutdown_gpio" and "baud_rate" would be buggy as well.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/ti_wilink_st.h b/include/linux/ti_wilink_st.h
index 9072d9f95cff..c78dcfeaf25f 100644
--- a/include/linux/ti_wilink_st.h
+++ b/include/linux/ti_wilink_st.h
@@ -262,7 +262,7 @@ struct kim_data_s {
 	struct completion kim_rcvd, ldisc_installed;
 	char resp_buffer[30];
 	const struct firmware *fw_entry;
-	long nshutdown;
+	unsigned nshutdown;
 	unsigned long rx_state;
 	unsigned long rx_count;
 	struct sk_buff *rx_skb;
@@ -270,8 +270,8 @@ struct kim_data_s {
 	struct chip_version version;
 	unsigned char ldisc_install;
 	unsigned char dev_name[UART_DEV_NAME_LEN + 1];
-	unsigned char flow_cntrl;
-	unsigned long baud_rate;
+	unsigned flow_cntrl;
+	unsigned baud_rate;
 };
 
 /**
@@ -437,10 +437,10 @@ struct gps_event_hdr {
  *
  */
 struct ti_st_plat_data {
-	long nshutdown_gpio;
+	u32 nshutdown_gpio;
 	unsigned char dev_name[UART_DEV_NAME_LEN]; /* uart name */
-	unsigned char flow_cntrl; /* flow control flag */
-	unsigned long baud_rate;
+	u32 flow_cntrl; /* flow control flag */
+	u32 baud_rate;
 	int (*suspend)(struct platform_device *, pm_message_t);
 	int (*resume)(struct platform_device *);
 	int (*chip_enable) (struct kim_data_s *);

commit 46d0d33350e9b32642d745a8b46a954910196b4d
Author: Gigi Joseph <gigi.joseph@gmail.com>
Date:   Fri Jan 9 03:45:02 2015 +0000

    ti-st: add device tree support
    
    When using device tree, driver configuration data need to be read from
    device node.
    Add support for getting the platform data information from the device
    tree information stored in the .dtb file in case it exists.
    
    Signed-off-by: Eyal Reizer <eyalr@ti.com>
    Signed-off-by: bvijay <bvijay@ti.com>
    Diff rendering mode:inlineside by side
    
    Signed-off-by: Gigi Joseph <gigi.joseph@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/ti_wilink_st.h b/include/linux/ti_wilink_st.h
index 884d6263e962..9072d9f95cff 100644
--- a/include/linux/ti_wilink_st.h
+++ b/include/linux/ti_wilink_st.h
@@ -86,6 +86,7 @@ struct st_proto_s {
 extern long st_register(struct st_proto_s *);
 extern long st_unregister(struct st_proto_s *);
 
+extern struct ti_st_plat_data   *dt_pdata;
 
 /*
  * header information used by st_core.c

commit ffdbb715fa0c53203b1ea2a6ecc54bdcc8951612
Author: Lee Jones <lee.jones@linaro.org>
Date:   Thu Aug 28 14:14:09 2014 +0100

    misc: st_kim: Increase size of dev_name buffer to incorporate termination
    
    Calling strncpy with a maximum size argument of 32 bytes on destination
    array kim_gdata->dev_name of size 32 bytes might leave the destination
    string unterminated.
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/ti_wilink_st.h b/include/linux/ti_wilink_st.h
index 932b76392248..884d6263e962 100644
--- a/include/linux/ti_wilink_st.h
+++ b/include/linux/ti_wilink_st.h
@@ -268,7 +268,7 @@ struct kim_data_s {
 	struct st_data_s *core_data;
 	struct chip_version version;
 	unsigned char ldisc_install;
-	unsigned char dev_name[UART_DEV_NAME_LEN];
+	unsigned char dev_name[UART_DEV_NAME_LEN + 1];
 	unsigned char flow_cntrl;
 	unsigned long baud_rate;
 };

commit 27712b3928bec9b1a889d7f60d718a35ca6c23b3
Author: Pavan Savoy <pavan_savoy@ti.com>
Date:   Fri Aug 3 14:49:40 2012 -0500

    drivers/misc/ti-st: remove sparse warnings
    
    remove sparse warnings by assigning right storage specifiers to functions and
    also clean-up the declarations in the include/linux/ti_wilink_st.h
    
    Signed-off-by: Pavan Savoy <pavan_savoy@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/ti_wilink_st.h b/include/linux/ti_wilink_st.h
index 3ca0269dd0b5..932b76392248 100644
--- a/include/linux/ti_wilink_st.h
+++ b/include/linux/ti_wilink_st.h
@@ -281,9 +281,10 @@ struct kim_data_s {
 long st_kim_start(void *);
 long st_kim_stop(void *);
 
-void st_kim_recv(void *, const unsigned char *, long count);
 void st_kim_complete(void *);
 void kim_st_list_protocols(struct st_data_s *, void *);
+void st_kim_recv(void *, const unsigned char *, long);
+
 
 /*
  * BTS headers

commit 9624f615520696ffa845da2de56277197155b48c
Author: Mircea Gherzan <mgherzan@gmail.com>
Date:   Wed May 9 14:19:13 2012 -0700

    ARM: OMAP: WiLink platform data for the PandaBoard
    
    The "uim" deamon requires sysfs entries that are filled in using
    this platform data.
    
    Signed-off-by: Mircea Gherzan <mgherzan@gmail.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/include/linux/ti_wilink_st.h b/include/linux/ti_wilink_st.h
index 2ef4385da6bf..3ca0269dd0b5 100644
--- a/include/linux/ti_wilink_st.h
+++ b/include/linux/ti_wilink_st.h
@@ -25,6 +25,8 @@
 #ifndef TI_WILINK_ST_H
 #define TI_WILINK_ST_H
 
+#include <linux/skbuff.h>
+
 /**
  * enum proto-type - The protocol on WiLink chips which share a
  *	common physical interface like UART.

commit 0d7c5f2572ccfa7bf83292b1506926663f2d164a
Author: Pavan Savoy <pavan_savoy@ti.com>
Date:   Wed Aug 10 10:18:31 2011 -0500

    drivers:misc:ti-st: platform hooks for chip states
    
    Certain platform specific or Host-WiLink Interface specific actions would be
    required to be taken when the chip is being enabled and after the chip is
    disabled such as configuration of the mux modes for the GPIO of host connected
    to the nshutdown of the chip or relinquishing UART after the chip is disabled.
    
    Similar actions can also be taken when the chip is in deep sleep or when the
    chip is awake. Performance enhancements such as configuring the host to run
    faster when chip is awake and slower when chip is asleep can also be made
    here.
    
    Signed-off-by: Pavan Savoy <pavan_savoy@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/ti_wilink_st.h b/include/linux/ti_wilink_st.h
index b004e557caa9..2ef4385da6bf 100644
--- a/include/linux/ti_wilink_st.h
+++ b/include/linux/ti_wilink_st.h
@@ -410,7 +410,28 @@ struct gps_event_hdr {
 	u16 plen;
 } __attribute__ ((packed));
 
-/* platform data */
+/**
+ * struct ti_st_plat_data - platform data shared between ST driver and
+ *	platform specific board file which adds the ST device.
+ * @nshutdown_gpio: Host's GPIO line to which chip's BT_EN is connected.
+ * @dev_name: The UART/TTY name to which chip is interfaced. (eg: /dev/ttyS1)
+ * @flow_cntrl: Should always be 1, since UART's CTS/RTS is used for PM
+ *	purposes.
+ * @baud_rate: The baud rate supported by the Host UART controller, this will
+ *	be shared across with the chip via a HCI VS command from User-Space Init
+ *	Mgr application.
+ * @suspend:
+ * @resume: legacy PM routines hooked to platform specific board file, so as
+ *	to take chip-host interface specific action.
+ * @chip_enable:
+ * @chip_disable: Platform/Interface specific mux mode setting, GPIO
+ *	configuring, Host side PM disabling etc.. can be done here.
+ * @chip_asleep:
+ * @chip_awake: Chip specific deep sleep states is communicated to Host
+ *	specific board-xx.c to take actions such as cut UART clocks when chip
+ *	asleep or run host faster when chip awake etc..
+ *
+ */
 struct ti_st_plat_data {
 	long nshutdown_gpio;
 	unsigned char dev_name[UART_DEV_NAME_LEN]; /* uart name */
@@ -418,6 +439,10 @@ struct ti_st_plat_data {
 	unsigned long baud_rate;
 	int (*suspend)(struct platform_device *, pm_message_t);
 	int (*resume)(struct platform_device *);
+	int (*chip_enable) (struct kim_data_s *);
+	int (*chip_disable) (struct kim_data_s *);
+	int (*chip_asleep) (struct kim_data_s *);
+	int (*chip_awake) (struct kim_data_s *);
 };
 
 #endif /* TI_WILINK_ST_H */

commit 764b0c4b3256ad4431cb52eaf99c0abe6df0a085
Author: Pavan Savoy <pavan_savoy@ti.com>
Date:   Fri Apr 8 04:57:42 2011 -0500

    drivers:misc:ti-st: handle delayed tty receive
    
    When certain technologies shutdown their interface without waiting for
    the acknowledgement from the chip. The receive_buf from the TTY would be
    invoked a while after the relevant technology is unregistered.
    
    This patch introduces a new flag "is_registered" which maintains the
    state of protocols BT, FM or GPS and thereby removes the need to clear
    the protocol data from ST when protocols gets unregistered.
    
    This fixes corner cases when HCI RESET is sent down from bluetooth stack
    and the receive_buf is called from tty after 250ms before which
    bluetooth would have unregistered from the system.
    OR - when FM application decides to close down the device without
    sending a power-off FM command resulting in some RDS data or interrupt
    data coming in after the driver is unregistered.
    
    Signed-off-by: Pavan Savoy <pavan_savoy@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/ti_wilink_st.h b/include/linux/ti_wilink_st.h
index 7071ec5d0118..b004e557caa9 100644
--- a/include/linux/ti_wilink_st.h
+++ b/include/linux/ti_wilink_st.h
@@ -140,12 +140,12 @@ extern long st_unregister(struct st_proto_s *);
  */
 struct st_data_s {
 	unsigned long st_state;
-	struct tty_struct *tty;
 	struct sk_buff *tx_skb;
 #define ST_TX_SENDING	1
 #define ST_TX_WAKEUP	2
 	unsigned long tx_state;
 	struct st_proto_s *list[ST_MAX_CHANNELS];
+	bool is_registered[ST_MAX_CHANNELS];
 	unsigned long rx_state;
 	unsigned long rx_count;
 	struct sk_buff *rx_skb;
@@ -155,6 +155,7 @@ struct st_data_s {
 	unsigned char	protos_registered;
 	unsigned long ll_state;
 	void *kim_data;
+	struct tty_struct *tty;
 };
 
 /*

commit 781a7395d239dbdb59738ca7fe08e71641bf583c
Author: Pavan Savoy <pavan_savoy@ti.com>
Date:   Fri Feb 4 02:23:15 2011 -0600

    drivers:misc: ti-st: remove multiple gpio handling
    
    TI shared transport driver previously intended to expose rfkill
    entries for each of the protocol gpio that the chip would have.
    However now in case such gpios exist, which requires to be enabled
    for a specific protocol, the responsibility lay on protocol driver.
    This patch removes the request/free of multiple gpios, rfkill struct
    references and also removes the chip_toggle function.
    
    Signed-off-by: Pavan Savoy <pavan_savoy@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/ti_wilink_st.h b/include/linux/ti_wilink_st.h
index 7885a779c588..7071ec5d0118 100644
--- a/include/linux/ti_wilink_st.h
+++ b/include/linux/ti_wilink_st.h
@@ -25,15 +25,6 @@
 #ifndef TI_WILINK_ST_H
 #define TI_WILINK_ST_H
 
-/**
- * enum kim_gpio_state - Few protocols such as FM have ACTIVE LOW
- *	gpio states for their chip/core enable gpios
- */
-enum kim_gpio_state {
-	KIM_GPIO_INACTIVE,
-	KIM_GPIO_ACTIVE,
-};
-
 /**
  * enum proto-type - The protocol on WiLink chips which share a
  *	common physical interface like UART.
@@ -252,14 +243,11 @@ struct chip_version {
  *	the ldisc was properly installed.
  * @resp_buffer: data buffer for the .bts fw file name.
  * @fw_entry: firmware class struct to request/release the fw.
- * @gpios: the list of core/chip enable gpios for BT, FM and GPS cores.
  * @rx_state: the rx state for kim's receive func during fw download.
  * @rx_count: the rx count for the kim's receive func during fw download.
  * @rx_skb: all of fw data might not come at once, and hence data storage for
  *	whole of the fw response, only HCI_EVENTs and hence diff from ST's
  *	response.
- * @rfkill: rfkill data for each of the cores to be registered with rfkill.
- * @rf_protos: proto types of the data registered with rfkill sub-system.
  * @core_data: ST core's data, which mainly is the tty's disc_data
  * @version: chip version available via a sysfs entry.
  *
@@ -270,12 +258,10 @@ struct kim_data_s {
 	struct completion kim_rcvd, ldisc_installed;
 	char resp_buffer[30];
 	const struct firmware *fw_entry;
-	long gpios[ST_MAX_CHANNELS];
+	long nshutdown;
 	unsigned long rx_state;
 	unsigned long rx_count;
 	struct sk_buff *rx_skb;
-	struct rfkill *rfkill[ST_MAX_CHANNELS];
-	enum proto_type rf_protos[ST_MAX_CHANNELS];
 	struct st_data_s *core_data;
 	struct chip_version version;
 	unsigned char ldisc_install;
@@ -293,7 +279,6 @@ long st_kim_start(void *);
 long st_kim_stop(void *);
 
 void st_kim_recv(void *, const unsigned char *, long count);
-void st_kim_chip_toggle(enum proto_type, enum kim_gpio_state);
 void st_kim_complete(void *);
 void kim_st_list_protocols(struct st_data_s *, void *);
 
@@ -426,7 +411,7 @@ struct gps_event_hdr {
 
 /* platform data */
 struct ti_st_plat_data {
-	long gpios[ST_MAX_CHANNELS]; /* BT, FM and GPS */
+	long nshutdown_gpio;
 	unsigned char dev_name[UART_DEV_NAME_LEN]; /* uart name */
 	unsigned char flow_cntrl; /* flow control flag */
 	unsigned long baud_rate;

commit ef04d121f030329aae0c2d3ec22beea0c5cbcfd3
Author: Pavan Savoy <pavan_savoy@ti.com>
Date:   Fri Feb 4 02:23:13 2011 -0600

    drivers:misc: ti-st: firmware download optimization
    
    To fasten the process of firmware download, the chip allows
    disabling of the command complete event generation from host.
    In these cases, only few very essential commands would have
    the command complete events and hence the wait associated with
    them.
    
    So now the driver would wait for a command complete event, only
    when it comes across a wait event during firmware parsing.
    This would also mean we need to skip not just the change baud
    rate command but also the wait for it.
    
    Signed-off-by: Pavan Savoy <pavan_savoy@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/ti_wilink_st.h b/include/linux/ti_wilink_st.h
index 010cda7287a0..7885a779c588 100644
--- a/include/linux/ti_wilink_st.h
+++ b/include/linux/ti_wilink_st.h
@@ -166,6 +166,11 @@ struct st_data_s {
 	void *kim_data;
 };
 
+/*
+ * wrapper around tty->ops->write_room to check
+ * availability during firmware download
+ */
+int st_get_uart_wr_room(struct st_data_s *st_gdata);
 /**
  * st_int_write -
  * point this to tty->driver->write or tty->ops->write
@@ -208,6 +213,7 @@ void gps_chrdrv_stub_init(void);
  */
 #define LDISC_TIME	1000
 #define CMD_RESP_TIME	800
+#define CMD_WR_TIME	5000
 #define MAKEWORD(a, b)  ((unsigned short)(((unsigned char)(a)) \
 	| ((unsigned short)((unsigned char)(b))) << 8))
 

commit ec60d0ad20ff8796dc41b30a9dce485478ccd263
Author: Pavan Savoy <pavan_savoy@ti.com>
Date:   Fri Feb 4 02:23:10 2011 -0600

    drivers:misc: ti-st: move from rfkill to sysfs
    
    The communication between ST KIM and UIM was interfaced
    over the /dev/rfkill device node.
    Move the interface to a simpler less abusive sysfs entry
    mechanism and document it in Documentation/ABI/testing/
    under sysfs-platform-kim.
    
    Shared transport driver would now read the UART details
    originally received by bootloader or firmware as platform
    data.
    The data read will be shared over sysfs entries for the user-space
    UIM or other n/w manager/plugins to be read, and assist the driver
    by opening up the UART, setting the baud-rate and installing the
    line discipline.
    
    Signed-off-by: Pavan Savoy <pavan_savoy@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/ti_wilink_st.h b/include/linux/ti_wilink_st.h
index 1674ca7ab86d..010cda7287a0 100644
--- a/include/linux/ti_wilink_st.h
+++ b/include/linux/ti_wilink_st.h
@@ -206,8 +206,8 @@ void gps_chrdrv_stub_init(void);
 /* time in msec to wait for
  * line discipline to be installed
  */
-#define LDISC_TIME	500
-#define CMD_RESP_TIME	500
+#define LDISC_TIME	1000
+#define CMD_RESP_TIME	800
 #define MAKEWORD(a, b)  ((unsigned short)(((unsigned char)(a)) \
 	| ((unsigned short)((unsigned char)(b))) << 8))
 
@@ -230,6 +230,7 @@ struct chip_version {
 	unsigned short maj_ver;
 };
 
+#define UART_DEV_NAME_LEN 32
 /**
  * struct kim_data_s - the KIM internal data, embedded as the
  *	platform's drv data. One for each ST device in the system.
@@ -271,6 +272,10 @@ struct kim_data_s {
 	enum proto_type rf_protos[ST_MAX_CHANNELS];
 	struct st_data_s *core_data;
 	struct chip_version version;
+	unsigned char ldisc_install;
+	unsigned char dev_name[UART_DEV_NAME_LEN];
+	unsigned char flow_cntrl;
+	unsigned long baud_rate;
 };
 
 /**
@@ -413,4 +418,14 @@ struct gps_event_hdr {
 	u16 plen;
 } __attribute__ ((packed));
 
+/* platform data */
+struct ti_st_plat_data {
+	long gpios[ST_MAX_CHANNELS]; /* BT, FM and GPS */
+	unsigned char dev_name[UART_DEV_NAME_LEN]; /* uart name */
+	unsigned char flow_cntrl; /* flow control flag */
+	unsigned long baud_rate;
+	int (*suspend)(struct platform_device *, pm_message_t);
+	int (*resume)(struct platform_device *);
+};
+
 #endif /* TI_WILINK_ST_H */

commit 5c88b02196a99332dacf305c8757674dd7a303ff
Author: Pavan Savoy <pavan_savoy@ti.com>
Date:   Fri Feb 4 02:23:09 2011 -0600

    drivers:misc: ti-st: register with channel IDs
    
    The architecture of shared transport had begun with individual
    protocols like bluetooth, fm and gps telling the shared transport
    what sort of protocol they are and then expecting the ST driver
    to parse the incoming data from chip and forward data only
    relevant to the protocol drivers.
    
    This change would mean each protocol drivers would also send
    information to ST driver as to how to intrepret their protocol
    data coming out of the chip.
    
    Signed-off-by: Pavan Savoy <pavan_savoy@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/ti_wilink_st.h b/include/linux/ti_wilink_st.h
index 4c7be2263011..1674ca7ab86d 100644
--- a/include/linux/ti_wilink_st.h
+++ b/include/linux/ti_wilink_st.h
@@ -42,7 +42,7 @@ enum proto_type {
 	ST_BT,
 	ST_FM,
 	ST_GPS,
-	ST_MAX,
+	ST_MAX_CHANNELS = 16,
 };
 
 /**
@@ -62,6 +62,17 @@ enum proto_type {
  * @priv_data: privdate data holder for the protocol drivers, sent
  *	from the protocol drivers during registration, and sent back on
  *	reg_complete_cb and recv.
+ * @chnl_id: channel id the protocol driver is interested in, the channel
+ *	id is nothing but the 1st byte of the packet in UART frame.
+ * @max_frame_size: size of the largest frame the protocol can receive.
+ * @hdr_len: length of the header structure of the protocol.
+ * @offset_len_in_hdr: this provides the offset of the length field in the
+ *	header structure of the protocol header, to assist ST to know
+ *	how much to receive, if the data is split across UART frames.
+ * @len_size: whether the length field inside the header is 2 bytes
+ *	or 1 byte.
+ * @reserve: the number of bytes ST needs to reserve in the skb being
+ *	prepared for the protocol driver.
  */
 struct st_proto_s {
 	enum proto_type type;
@@ -70,10 +81,17 @@ struct st_proto_s {
 	void (*reg_complete_cb) (void *, char data);
 	long (*write) (struct sk_buff *skb);
 	void *priv_data;
+
+	unsigned char chnl_id;
+	unsigned short max_frame_size;
+	unsigned char hdr_len;
+	unsigned char offset_len_in_hdr;
+	unsigned char len_size;
+	unsigned char reserve;
 };
 
 extern long st_register(struct st_proto_s *);
-extern long st_unregister(enum proto_type);
+extern long st_unregister(struct st_proto_s *);
 
 
 /*
@@ -114,6 +132,7 @@ extern long st_unregister(enum proto_type);
  * @rx_skb: the skb where all data for a protocol gets accumulated,
  *	since tty might not call receive when a complete event packet
  *	is received, the states, count and the skb needs to be maintained.
+ * @rx_chnl: the channel ID for which the data is getting accumalated for.
  * @txq: the list of skbs which needs to be sent onto the TTY.
  * @tx_waitq: if the chip is not in AWAKE state, the skbs needs to be queued
  *	up in here, PM(WAKEUP_IND) data needs to be sent and then the skbs
@@ -135,10 +154,11 @@ struct st_data_s {
 #define ST_TX_SENDING	1
 #define ST_TX_WAKEUP	2
 	unsigned long tx_state;
-	struct st_proto_s *list[ST_MAX];
+	struct st_proto_s *list[ST_MAX_CHANNELS];
 	unsigned long rx_state;
 	unsigned long rx_count;
 	struct sk_buff *rx_skb;
+	unsigned char rx_chnl;
 	struct sk_buff_head txq, tx_waitq;
 	spinlock_t lock;
 	unsigned char	protos_registered;
@@ -243,12 +263,12 @@ struct kim_data_s {
 	struct completion kim_rcvd, ldisc_installed;
 	char resp_buffer[30];
 	const struct firmware *fw_entry;
-	long gpios[ST_MAX];
+	long gpios[ST_MAX_CHANNELS];
 	unsigned long rx_state;
 	unsigned long rx_count;
 	struct sk_buff *rx_skb;
-	struct rfkill *rfkill[ST_MAX];
-	enum proto_type rf_protos[ST_MAX];
+	struct rfkill *rfkill[ST_MAX_CHANNELS];
+	enum proto_type rf_protos[ST_MAX_CHANNELS];
 	struct st_data_s *core_data;
 	struct chip_version version;
 };
@@ -338,12 +358,8 @@ struct hci_command {
 
 /* ST LL receiver states */
 #define ST_W4_PACKET_TYPE       0
-#define ST_BT_W4_EVENT_HDR      1
-#define ST_BT_W4_ACL_HDR        2
-#define ST_BT_W4_SCO_HDR        3
-#define ST_BT_W4_DATA           4
-#define ST_FM_W4_EVENT_HDR      5
-#define ST_GPS_W4_EVENT_HDR	6
+#define ST_W4_HEADER		1
+#define ST_W4_DATA		2
 
 /* ST LL state machines */
 #define ST_LL_ASLEEP               0

commit 73f12e8d3d94828b9efe2b8b8a34b4ad6d14ee47
Author: Pavan Savoy <pavan_savoy@ti.com>
Date:   Tue Oct 12 16:27:38 2010 -0400

    drivers: misc: ti-st: fix review comments
    
    Based on comments from Jiri Slaby, drop the register
    storage specifier, remove the unused code, cleanup
    the const to non-const type casting.
    Also make the line discipline ops structure static, since
    its a singleton, unmodified structure which need not be
    in heap.
    
    Reported-by: Jiri Slaby <jirislaby@gmail.com>
    Signed-off-by: Pavan Savoy <pavan_savoy@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/ti_wilink_st.h b/include/linux/ti_wilink_st.h
index 2a5acf599598..4c7be2263011 100644
--- a/include/linux/ti_wilink_st.h
+++ b/include/linux/ti_wilink_st.h
@@ -101,7 +101,6 @@ extern long st_unregister(enum proto_type);
  *	can occur , where as during other times other events CH8, CH9
  *	can occur.
  * @tty: tty provided by the TTY core for line disciplines.
- * @ldisc_ops: the procedures that this line discipline registers with TTY.
  * @tx_skb: If for some reason the tty's write returns lesser bytes written
  *	then to maintain the rest of data to be written on next instance.
  *	This needs to be protected, hence the lock inside wakeup func.
@@ -132,7 +131,6 @@ extern long st_unregister(enum proto_type);
 struct st_data_s {
 	unsigned long st_state;
 	struct tty_struct *tty;
-	struct tty_ldisc_ops *ldisc_ops;
 	struct sk_buff *tx_skb;
 #define ST_TX_SENDING	1
 #define ST_TX_WAKEUP	2

commit e5558679bbb80788dc8c4c30484ac0a68e971ca5
Author: Pavan Savoy <pavan_savoy@ti.com>
Date:   Thu Sep 30 16:13:30 2010 -0400

    staging: ti-st: mv ti_wilink_st header
    
    Move the header to a standard linux device driver location.
    This should pave the way for other drivers to be moved into the relevant
    directories.
    
    ti_wilink_st.h is a common header file used by the TI's shared transport device
    driver for WiLink chipsets. Each individual protocol drivers like bluetooth
    driver, FM V4L2 driver and GPS drivers will make use of this header.
    
    Signed-off-by: Pavan Savoy <pavan_savoy@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/ti_wilink_st.h b/include/linux/ti_wilink_st.h
new file mode 100644
index 000000000000..2a5acf599598
--- /dev/null
+++ b/include/linux/ti_wilink_st.h
@@ -0,0 +1,402 @@
+/*
+ *  Shared Transport Header file
+ *	To be included by the protocol stack drivers for
+ *	Texas Instruments BT,FM and GPS combo chip drivers
+ *	and also serves the sub-modules of the shared transport driver.
+ *
+ *  Copyright (C) 2009-2010 Texas Instruments
+ *  Author: Pavan Savoy <pavan_savoy@ti.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef TI_WILINK_ST_H
+#define TI_WILINK_ST_H
+
+/**
+ * enum kim_gpio_state - Few protocols such as FM have ACTIVE LOW
+ *	gpio states for their chip/core enable gpios
+ */
+enum kim_gpio_state {
+	KIM_GPIO_INACTIVE,
+	KIM_GPIO_ACTIVE,
+};
+
+/**
+ * enum proto-type - The protocol on WiLink chips which share a
+ *	common physical interface like UART.
+ */
+enum proto_type {
+	ST_BT,
+	ST_FM,
+	ST_GPS,
+	ST_MAX,
+};
+
+/**
+ * struct st_proto_s - Per Protocol structure from BT/FM/GPS to ST
+ * @type: type of the protocol being registered among the
+ *	available proto_type(BT, FM, GPS the protocol which share TTY).
+ * @recv: the receiver callback pointing to a function in the
+ *	protocol drivers called by the ST driver upon receiving
+ *	relevant data.
+ * @match_packet: reserved for future use, to make ST more generic
+ * @reg_complete_cb: callback handler pointing to a function in protocol
+ *	handler called by ST when the pending registrations are complete.
+ *	The registrations are marked pending, in situations when fw
+ *	download is in progress.
+ * @write: pointer to function in ST provided to protocol drivers from ST,
+ *	to be made use when protocol drivers have data to send to TTY.
+ * @priv_data: privdate data holder for the protocol drivers, sent
+ *	from the protocol drivers during registration, and sent back on
+ *	reg_complete_cb and recv.
+ */
+struct st_proto_s {
+	enum proto_type type;
+	long (*recv) (void *, struct sk_buff *);
+	unsigned char (*match_packet) (const unsigned char *data);
+	void (*reg_complete_cb) (void *, char data);
+	long (*write) (struct sk_buff *skb);
+	void *priv_data;
+};
+
+extern long st_register(struct st_proto_s *);
+extern long st_unregister(enum proto_type);
+
+
+/*
+ * header information used by st_core.c
+ */
+
+/* states of protocol list */
+#define ST_NOTEMPTY	1
+#define ST_EMPTY	0
+
+/*
+ * possible st_states
+ */
+#define ST_INITIALIZING		1
+#define ST_REG_IN_PROGRESS	2
+#define ST_REG_PENDING		3
+#define ST_WAITING_FOR_RESP	4
+
+/**
+ * struct st_data_s - ST core internal structure
+ * @st_state: different states of ST like initializing, registration
+ *	in progress, this is mainly used to return relevant err codes
+ *	when protocol drivers are registering. It is also used to track
+ *	the recv function, as in during fw download only HCI events
+ *	can occur , where as during other times other events CH8, CH9
+ *	can occur.
+ * @tty: tty provided by the TTY core for line disciplines.
+ * @ldisc_ops: the procedures that this line discipline registers with TTY.
+ * @tx_skb: If for some reason the tty's write returns lesser bytes written
+ *	then to maintain the rest of data to be written on next instance.
+ *	This needs to be protected, hence the lock inside wakeup func.
+ * @tx_state: if the data is being written onto the TTY and protocol driver
+ *	wants to send more, queue up data and mark that there is
+ *	more data to send.
+ * @list: the list of protocols registered, only MAX can exist, one protocol
+ *	can register only once.
+ * @rx_state: states to be maintained inside st's tty receive
+ * @rx_count: count to be maintained inside st's tty receieve
+ * @rx_skb: the skb where all data for a protocol gets accumulated,
+ *	since tty might not call receive when a complete event packet
+ *	is received, the states, count and the skb needs to be maintained.
+ * @txq: the list of skbs which needs to be sent onto the TTY.
+ * @tx_waitq: if the chip is not in AWAKE state, the skbs needs to be queued
+ *	up in here, PM(WAKEUP_IND) data needs to be sent and then the skbs
+ *	from waitq can be moved onto the txq.
+ *	Needs locking too.
+ * @lock: the lock to protect skbs, queues, and ST states.
+ * @protos_registered: count of the protocols registered, also when 0 the
+ *	chip enable gpio can be toggled, and when it changes to 1 the fw
+ *	needs to be downloaded to initialize chip side ST.
+ * @ll_state: the various PM states the chip can be, the states are notified
+ *	to us, when the chip sends relevant PM packets(SLEEP_IND, WAKE_IND).
+ * @kim_data: reference to the parent encapsulating structure.
+ *
+ */
+struct st_data_s {
+	unsigned long st_state;
+	struct tty_struct *tty;
+	struct tty_ldisc_ops *ldisc_ops;
+	struct sk_buff *tx_skb;
+#define ST_TX_SENDING	1
+#define ST_TX_WAKEUP	2
+	unsigned long tx_state;
+	struct st_proto_s *list[ST_MAX];
+	unsigned long rx_state;
+	unsigned long rx_count;
+	struct sk_buff *rx_skb;
+	struct sk_buff_head txq, tx_waitq;
+	spinlock_t lock;
+	unsigned char	protos_registered;
+	unsigned long ll_state;
+	void *kim_data;
+};
+
+/**
+ * st_int_write -
+ * point this to tty->driver->write or tty->ops->write
+ * depending upon the kernel version
+ */
+int st_int_write(struct st_data_s*, const unsigned char*, int);
+
+/**
+ * st_write -
+ * internal write function, passed onto protocol drivers
+ * via the write function ptr of protocol struct
+ */
+long st_write(struct sk_buff *);
+
+/* function to be called from ST-LL */
+void st_ll_send_frame(enum proto_type, struct sk_buff *);
+
+/* internal wake up function */
+void st_tx_wakeup(struct st_data_s *st_data);
+
+/* init, exit entry funcs called from KIM */
+int st_core_init(struct st_data_s **);
+void st_core_exit(struct st_data_s *);
+
+/* ask for reference from KIM */
+void st_kim_ref(struct st_data_s **, int);
+
+#define GPS_STUB_TEST
+#ifdef GPS_STUB_TEST
+int gps_chrdrv_stub_write(const unsigned char*, int);
+void gps_chrdrv_stub_init(void);
+#endif
+
+/*
+ * header information used by st_kim.c
+ */
+
+/* time in msec to wait for
+ * line discipline to be installed
+ */
+#define LDISC_TIME	500
+#define CMD_RESP_TIME	500
+#define MAKEWORD(a, b)  ((unsigned short)(((unsigned char)(a)) \
+	| ((unsigned short)((unsigned char)(b))) << 8))
+
+#define GPIO_HIGH 1
+#define GPIO_LOW  0
+
+/* the Power-On-Reset logic, requires to attempt
+ * to download firmware onto chip more than once
+ * since the self-test for chip takes a while
+ */
+#define POR_RETRY_COUNT 5
+
+/**
+ * struct chip_version - save the chip version
+ */
+struct chip_version {
+	unsigned short full;
+	unsigned short chip;
+	unsigned short min_ver;
+	unsigned short maj_ver;
+};
+
+/**
+ * struct kim_data_s - the KIM internal data, embedded as the
+ *	platform's drv data. One for each ST device in the system.
+ * @uim_pid: KIM needs to communicate with UIM to request to install
+ *	the ldisc by opening UART when protocol drivers register.
+ * @kim_pdev: the platform device added in one of the board-XX.c file
+ *	in arch/XX/ directory, 1 for each ST device.
+ * @kim_rcvd: completion handler to notify when data was received,
+ *	mainly used during fw download, which involves multiple send/wait
+ *	for each of the HCI-VS commands.
+ * @ldisc_installed: completion handler to notify that the UIM accepted
+ *	the request to install ldisc, notify from tty_open which suggests
+ *	the ldisc was properly installed.
+ * @resp_buffer: data buffer for the .bts fw file name.
+ * @fw_entry: firmware class struct to request/release the fw.
+ * @gpios: the list of core/chip enable gpios for BT, FM and GPS cores.
+ * @rx_state: the rx state for kim's receive func during fw download.
+ * @rx_count: the rx count for the kim's receive func during fw download.
+ * @rx_skb: all of fw data might not come at once, and hence data storage for
+ *	whole of the fw response, only HCI_EVENTs and hence diff from ST's
+ *	response.
+ * @rfkill: rfkill data for each of the cores to be registered with rfkill.
+ * @rf_protos: proto types of the data registered with rfkill sub-system.
+ * @core_data: ST core's data, which mainly is the tty's disc_data
+ * @version: chip version available via a sysfs entry.
+ *
+ */
+struct kim_data_s {
+	long uim_pid;
+	struct platform_device *kim_pdev;
+	struct completion kim_rcvd, ldisc_installed;
+	char resp_buffer[30];
+	const struct firmware *fw_entry;
+	long gpios[ST_MAX];
+	unsigned long rx_state;
+	unsigned long rx_count;
+	struct sk_buff *rx_skb;
+	struct rfkill *rfkill[ST_MAX];
+	enum proto_type rf_protos[ST_MAX];
+	struct st_data_s *core_data;
+	struct chip_version version;
+};
+
+/**
+ * functions called when 1 of the protocol drivers gets
+ * registered, these need to communicate with UIM to request
+ * ldisc installed, read chip_version, download relevant fw
+ */
+long st_kim_start(void *);
+long st_kim_stop(void *);
+
+void st_kim_recv(void *, const unsigned char *, long count);
+void st_kim_chip_toggle(enum proto_type, enum kim_gpio_state);
+void st_kim_complete(void *);
+void kim_st_list_protocols(struct st_data_s *, void *);
+
+/*
+ * BTS headers
+ */
+#define ACTION_SEND_COMMAND     1
+#define ACTION_WAIT_EVENT       2
+#define ACTION_SERIAL           3
+#define ACTION_DELAY            4
+#define ACTION_RUN_SCRIPT       5
+#define ACTION_REMARKS          6
+
+/**
+ * struct bts_header - the fw file is NOT binary which can
+ *	be sent onto TTY as is. The .bts is more a script
+ *	file which has different types of actions.
+ *	Each such action needs to be parsed by the KIM and
+ *	relevant procedure to be called.
+ */
+struct bts_header {
+	u32 magic;
+	u32 version;
+	u8 future[24];
+	u8 actions[0];
+} __attribute__ ((packed));
+
+/**
+ * struct bts_action - Each .bts action has its own type of
+ *	data.
+ */
+struct bts_action {
+	u16 type;
+	u16 size;
+	u8 data[0];
+} __attribute__ ((packed));
+
+struct bts_action_send {
+	u8 data[0];
+} __attribute__ ((packed));
+
+struct bts_action_wait {
+	u32 msec;
+	u32 size;
+	u8 data[0];
+} __attribute__ ((packed));
+
+struct bts_action_delay {
+	u32 msec;
+} __attribute__ ((packed));
+
+struct bts_action_serial {
+	u32 baud;
+	u32 flow_control;
+} __attribute__ ((packed));
+
+/**
+ * struct hci_command - the HCI-VS for intrepreting
+ *	the change baud rate of host-side UART, which
+ *	needs to be ignored, since UIM would do that
+ *	when it receives request from KIM for ldisc installation.
+ */
+struct hci_command {
+	u8 prefix;
+	u16 opcode;
+	u8 plen;
+	u32 speed;
+} __attribute__ ((packed));
+
+/*
+ * header information used by st_ll.c
+ */
+
+/* ST LL receiver states */
+#define ST_W4_PACKET_TYPE       0
+#define ST_BT_W4_EVENT_HDR      1
+#define ST_BT_W4_ACL_HDR        2
+#define ST_BT_W4_SCO_HDR        3
+#define ST_BT_W4_DATA           4
+#define ST_FM_W4_EVENT_HDR      5
+#define ST_GPS_W4_EVENT_HDR	6
+
+/* ST LL state machines */
+#define ST_LL_ASLEEP               0
+#define ST_LL_ASLEEP_TO_AWAKE      1
+#define ST_LL_AWAKE                2
+#define ST_LL_AWAKE_TO_ASLEEP      3
+#define ST_LL_INVALID		   4
+
+/* different PM notifications coming from chip */
+#define LL_SLEEP_IND	0x30
+#define LL_SLEEP_ACK	0x31
+#define LL_WAKE_UP_IND	0x32
+#define LL_WAKE_UP_ACK	0x33
+
+/* initialize and de-init ST LL */
+long st_ll_init(struct st_data_s *);
+long st_ll_deinit(struct st_data_s *);
+
+/**
+ * enable/disable ST LL along with KIM start/stop
+ * called by ST Core
+ */
+void st_ll_enable(struct st_data_s *);
+void st_ll_disable(struct st_data_s *);
+
+/**
+ * various funcs used by ST core to set/get the various PM states
+ * of the chip.
+ */
+unsigned long st_ll_getstate(struct st_data_s *);
+unsigned long st_ll_sleep_state(struct st_data_s *, unsigned char);
+void st_ll_wakeup(struct st_data_s *);
+
+/*
+ * header information used by st_core.c for FM and GPS
+ * packet parsing, the bluetooth headers are already available
+ * at net/bluetooth/
+ */
+
+struct fm_event_hdr {
+	u8 plen;
+} __attribute__ ((packed));
+
+#define FM_MAX_FRAME_SIZE 0xFF	/* TODO: */
+#define FM_EVENT_HDR_SIZE 1	/* size of fm_event_hdr */
+#define ST_FM_CH8_PKT 0x8
+
+/* gps stuff */
+struct gps_event_hdr {
+	u8 opcode;
+	u16 plen;
+} __attribute__ ((packed));
+
+#endif /* TI_WILINK_ST_H */
