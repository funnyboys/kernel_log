commit 2fd2bc7f49324e7b439e3c5584762abd0a9a13bc
Author: Colton Lewis <colton.w.lewis@protonmail.com>
Date:   Sun Jun 14 04:08:04 2020 +0000

    gpu: host1x: Correct trivial kernel-doc inconsistencies
    
    Silence documentation build warnings by adding kernel-doc fields.
    
    ./include/linux/host1x.h:69: warning: Function parameter or member 'parent' not described in 'host1x_client'
    ./include/linux/host1x.h:69: warning: Function parameter or member 'usecount' not described in 'host1x_client'
    ./include/linux/host1x.h:69: warning: Function parameter or member 'lock' not described in 'host1x_client'
    
    Signed-off-by: Colton Lewis <colton.w.lewis@protonmail.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index c230b4e70d75..a3a568bf9686 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -48,6 +48,9 @@ struct host1x_client_ops {
  * @channel: host1x channel associated with this client
  * @syncpts: array of syncpoints requested for this client
  * @num_syncpts: number of syncpoints requested for this client
+ * @parent: pointer to parent structure
+ * @usecount: reference count for this structure
+ * @lock: mutex for mutually exclusive concurrency
  */
 struct host1x_client {
 	struct list_head list;

commit 501be6c1c72417eab05e7413671a38ea991a8ebc
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Mar 25 21:16:03 2020 +0100

    drm/tegra: Fix SMMU support on Tegra124 and Tegra210
    
    When testing whether or not to enable the use of the SMMU, consult the
    supported DMA mask rather than the actually configured DMA mask, since
    the latter might already have been restricted.
    
    Fixes: 2d9384ff9177 ("drm/tegra: Relax IOMMU usage criteria on old Tegra")
    Tested-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index 62d216ff1097..c230b4e70d75 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -17,9 +17,12 @@ enum host1x_class {
 	HOST1X_CLASS_GR3D = 0x60,
 };
 
+struct host1x;
 struct host1x_client;
 struct iommu_group;
 
+u64 host1x_get_dma_mask(struct host1x *host1x);
+
 /**
  * struct host1x_client_ops - host1x client operations
  * @init: host1x client initialization code

commit fd7226fbb25724bbafb236c520f5c02a8a37deec
Merge: 688486a49cf5 033ccdb7f6b1
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Jan 15 16:21:22 2020 +1000

    Merge tag 'drm/tegra/for-5.6-rc1' of git://anongit.freedesktop.org/tegra/linux into drm-next
    
    drm/tegra: Changes for v5.6-rc1
    
    This contains a small set of mostly fixes and some minor improvements.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Thierry Reding <thierry.reding@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200111004835.2412858-1-thierry.reding@gmail.com

commit fd67e9c6ed5af223af0daee093593abe3dbb53d4
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Dec 2 15:29:03 2019 +0100

    drm/tegra: Do not implement runtime PM
    
    The Tegra DRM driver heavily relies on the implementations for runtime
    suspend/resume to be called at specific times. Unfortunately, there are
    some cases where that doesn't work. One example is if the user disables
    runtime PM for a given subdevice. Another example is that the PM core
    acquires a reference to runtime PM during system sleep, effectively
    preventing devices from going into low power modes. This is intentional
    to avoid nasty race conditions, but it also causes system sleep to not
    function properly on all Tegra systems.
    
    Fix this by not implementing runtime PM at all. Instead, a minimal,
    reference-counted suspend/resume infrastructure is added to the host1x
    bus. This has the benefit that it can be used regardless of the system
    power state (or any transitions we might be in), or whether or not the
    user allows runtime PM.
    
    Atomic modesetting guarantees that these functions will end up being
    called at the right point in time, so the pitfalls for the more generic
    runtime PM do not apply here.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index b673d6198e05..325dabe4dd36 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -24,10 +24,14 @@ struct iommu_group;
  * struct host1x_client_ops - host1x client operations
  * @init: host1x client initialization code
  * @exit: host1x client tear down code
+ * @suspend: host1x client suspend code
+ * @resume: host1x client resume code
  */
 struct host1x_client_ops {
 	int (*init)(struct host1x_client *client);
 	int (*exit)(struct host1x_client *client);
+	int (*suspend)(struct host1x_client *client);
+	int (*resume)(struct host1x_client *client);
 };
 
 /**
@@ -55,6 +59,10 @@ struct host1x_client {
 
 	struct host1x_syncpt **syncpts;
 	unsigned int num_syncpts;
+
+	struct host1x_client *parent;
+	unsigned int usecount;
+	struct mutex lock;
 };
 
 /*
@@ -322,6 +330,9 @@ int host1x_device_exit(struct host1x_device *device);
 int host1x_client_register(struct host1x_client *client);
 int host1x_client_unregister(struct host1x_client *client);
 
+int host1x_client_suspend(struct host1x_client *client);
+int host1x_client_resume(struct host1x_client *client);
+
 struct tegra_mipi_device;
 
 struct tegra_mipi_device *tegra_mipi_request(struct device *device);

commit 608f43ad27ab26700677cc4d9ead3b2d9d338a21
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Dec 2 10:51:58 2019 +0100

    gpu: host1x: Rename "parent" to "host"
    
    Rename the host1x clients' parent to "host" because that more closely
    describes what it is. The parent can be confused with the parent device
    in terms of the device hierarchy. Subsequent patches will add a new
    member that refers to the parent in that hierarchy.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index 6f8d772591ba..b673d6198e05 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -33,7 +33,7 @@ struct host1x_client_ops {
 /**
  * struct host1x_client - host1x client structure
  * @list: list node for the host1x client
- * @parent: pointer to struct device representing the host1x controller
+ * @host: pointer to struct device representing the host1x controller
  * @dev: pointer to struct device backing this host1x client
  * @group: IOMMU group that this client is a member of
  * @ops: host1x client operations
@@ -44,7 +44,7 @@ struct host1x_client_ops {
  */
 struct host1x_client {
 	struct list_head list;
-	struct device *parent;
+	struct device *host;
 	struct device *dev;
 	struct iommu_group *group;
 

commit 6c56e8adc0011b3bc01b6b2bab7e41d5ecb43c0f
Merge: d1eef1c61974 2156873f08c7
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Dec 17 13:57:54 2019 +0100

    Merge tag 'drm-misc-next-2019-12-16' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for v5.6:
    
    UAPI Changes:
    - Add support for DMA-BUF HEAPS.
    
    Cross-subsystem Changes:
    - mipi dsi definition updates, pulled into drm-intel as well.
    - Add lockdep annotations for dma_resv vs mmap_sem and fs_reclaim.
    - Remove support for dma-buf kmap/kunmap.
    - Constify fb_ops in all fbdev drivers, including drm drivers and drm-core, and media as well.
    
    Core Changes:
    - Small cleanups to ttm.
    - Fix SCDC definition.
    - Assorted cleanups to core.
    - Add todo to remove load/unload hooks, and use generic fbdev emulation.
    - Assorted documentation updates.
    - Use blocking ww lock in ttm fault handler.
    - Remove drm_fb_helper_fbdev_setup/teardown.
    - Warning fixes with W=1 for atomic.
    - Use drm_debug_enabled() instead of drm_debug flag testing in various drivers.
    - Fallback to nontiled mode in fbdev emulation when not all tiles are present. (Later on reverted)
    - Various kconfig indentation fixes in core and drivers.
    - Fix freeing transactions in dp-mst correctly.
    - Sean Paul is steping down as core maintainer. :-(
    - Add lockdep annotations for atomic locks vs dma-resv.
    - Prevent use-after-free for a bad job in drm_scheduler.
    - Fill out all block sizes in the P01x and P210 definitions.
    - Avoid division by zero in drm/rect, and fix bounds.
    - Add drm/rect selftests.
    - Add aspect ratio and alternate clocks for HDMI 4k modes.
    - Add todo for drm_framebuffer_funcs and fb_create cleanup.
    - Drop DRM_AUTH for prime import/export ioctls.
    - Clear DP-MST payload id tables downstream when initializating.
    - Fix for DSC throughput definition.
    - Add extra FEC definitions.
    - Fix fake offset in drm_gem_object_funs.mmap.
    - Stop using encoder->bridge in core directly
    - Handle bridge chaining slightly better.
    - Add backlight support to drm/panel, and use it in many panel drivers.
    - Increase max number of y420 modes from 128 to 256, as preparation to add the new modes.
    
    Driver Changes:
    - Small fixes all over.
    - Fix documentation in vkms.
    - Fix mmap_sem vs dma_resv in nouveau.
    - Small cleanup in komeda.
    - Add page flip support in gma500 for psb/cdv.
    - Add ddc symlink in the connector sysfs directory for many drivers.
    - Add support for analogic an6345, and fix small bugs in it.
    - Add atomic modesetting support to ast.
    - Fix radeon fault handler VMA race.
    - Switch udl to use generic shmem helpers.
    - Unconditional vblank handling for mcde.
    - Miscellaneous fixes to mcde.
    - Tweak debug output from komeda using debugfs.
    - Add gamma and color transform support to komeda for DOU-IPS.
    - Add support for sony acx424AKP panel.
    - Various small cleanups to gma500.
    - Use generic fbdev emulation in udl, and replace udl_framebuffer with generic implementation.
    - Add support for Logic PD Type 28 panel.
    - Use drm_panel_* wrapper functions in exynos/tegra/msm.
    - Add devicetree bindings for generic DSI panels.
    - Don't include drm_pci.h directly in many drivers.
    - Add support for begin/end_cpu_access in udmabuf.
    - Stop using drm_get_pci_dev in gma500 and mga200.
    - Fixes to UDL damage handling, and use dma_buf_begin/end_cpu_access.
    - Add devfreq thermal support to panfrost.
    - Fix hotplug with daisy chained monitors by removing VCPI when disabling topology manager.
    - meson: Add support for OSD1 plane AFBC commit.
    - Stop displaying garbage when toggling ast primary plane on/off.
    - More cleanups and fixes to UDL.
    - Add D32 suport to komeda.
    - Remove globle copy of drm_dev in gma500.
    - Add support for Boe Himax8279d MIPI-DSI LCD panel.
    - Add support for ingenic JZ4770 panel.
    - Small null pointer deference fix in ingenic.
    - Remove support for the special tfp420 driver, as there is a generic way to do it.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    
    From: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/ba73535a-9334-5302-2e1f-5208bd7390bd@linux.intel.com

commit 35bd71dd1c161e6e89b21138e01e8c04c6347716
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Nov 18 11:35:23 2019 +0100

    drm/tegra: Delete host1x_bo_ops->k(un)map
    
    It doesn't have any callers anymore.
    
    Aside: The ->mmap/munmap hooks have a bit a confusing name, they don't
    do userspace mmaps, but a kernel vmap. I think most places use vmap
    for this, except ttm, which uses kmap for vmap for added confusion.
    mmap seems entirely for userspace mappings set up through mmap(2)
    syscall.
    
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Tested-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Sumit Semwal <sumit.semwal@linaro.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: linux-tegra@vger.kernel.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20191118103536.17675-3-daniel.vetter@ffwll.ch

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index e6eea45e1154..d11e89db7d7f 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -68,8 +68,6 @@ struct host1x_bo_ops {
 	void (*unpin)(struct host1x_bo *bo, struct sg_table *sgt);
 	void *(*mmap)(struct host1x_bo *bo);
 	void (*munmap)(struct host1x_bo *bo, void *addr);
-	void *(*kmap)(struct host1x_bo *bo, unsigned int pagenum);
-	void (*kunmap)(struct host1x_bo *bo, unsigned int pagenum, void *addr);
 };
 
 struct host1x_bo {
@@ -113,17 +111,6 @@ static inline void host1x_bo_munmap(struct host1x_bo *bo, void *addr)
 	bo->ops->munmap(bo, addr);
 }
 
-static inline void *host1x_bo_kmap(struct host1x_bo *bo, unsigned int pagenum)
-{
-	return bo->ops->kmap(bo, pagenum);
-}
-
-static inline void host1x_bo_kunmap(struct host1x_bo *bo,
-				    unsigned int pagenum, void *addr)
-{
-	bo->ops->kunmap(bo, pagenum, addr);
-}
-
 /*
  * host1x syncpoints
  */

commit ab4f81bfc2a8d429130182f8ea3f29a8b1754931
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Oct 28 13:37:11 2019 +0100

    gpu: host1x: Add direction flags to relocations
    
    Add direction flags to host1x relocations performed during job pinning.
    These flags indicate the kinds of accesses that hardware is allowed to
    perform on the relocated buffers.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index 1ba23a6a2021..6f8d772591ba 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -173,6 +173,9 @@ int host1x_job_submit(struct host1x_job *job);
  * host1x job
  */
 
+#define HOST1X_RELOC_READ	(1 << 0)
+#define HOST1X_RELOC_WRITE	(1 << 1)
+
 struct host1x_reloc {
 	struct {
 		struct host1x_bo *bo;
@@ -183,6 +186,7 @@ struct host1x_reloc {
 		unsigned long offset;
 	} target;
 	unsigned long shift;
+	unsigned long flags;
 };
 
 struct host1x_job {

commit 80327ce3d4edaa9abde1c6e1a1785572c7de3750
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Oct 28 13:37:09 2019 +0100

    gpu: host1x: Overhaul host1x_bo_{pin,unpin}() API
    
    The host1x_bo_pin() and host1x_bo_unpin() APIs are used to pin and unpin
    buffers during host1x job submission. Pinning currently returns the SG
    table and the DMA address (an IOVA if an IOMMU is used or a physical
    address if no IOMMU is used) of the buffer. The DMA address is only used
    for buffers that are relocated, whereas the host1x driver will map
    gather buffers into its own IOVA space so that they can be processed by
    the CDMA engine.
    
    This approach has a couple of issues. On one hand it's not very useful
    to return a DMA address for the buffer if host1x doesn't need it. On the
    other hand, returning the SG table of the buffer is suboptimal because a
    single SG table cannot be shared for multiple mappings, because the DMA
    address is stored within the SG table, and the DMA address may be
    different for different devices.
    
    Subsequent patches will move the host1x driver over to the DMA API which
    doesn't work with a single shared SG table. Fix this by returning a new
    SG table each time a buffer is pinned. This allows the buffer to be
    referenced by multiple jobs for different engines.
    
    Change the prototypes of host1x_bo_pin() and host1x_bo_unpin() to take a
    struct device *, specifying the device for which the buffer should be
    pinned. This is required in order to be able to properly construct the
    SG table. While at it, make host1x_bo_pin() return the SG table because
    that allows us to return an ERR_PTR()-encoded error code if we need to,
    or return NULL to signal that we don't need the SG table to be remapped
    and can simply use the DMA address as-is. At the same time, returning
    the DMA address is made optional because in the example of command
    buffers, host1x doesn't need to know the DMA address since it will have
    to create its own mapping anyway.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index df6e613ba715..1ba23a6a2021 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -67,8 +67,9 @@ struct sg_table;
 struct host1x_bo_ops {
 	struct host1x_bo *(*get)(struct host1x_bo *bo);
 	void (*put)(struct host1x_bo *bo);
-	dma_addr_t (*pin)(struct host1x_bo *bo, struct sg_table **sgt);
-	void (*unpin)(struct host1x_bo *bo, struct sg_table *sgt);
+	struct sg_table *(*pin)(struct device *dev, struct host1x_bo *bo,
+				dma_addr_t *phys);
+	void (*unpin)(struct device *dev, struct sg_table *sgt);
 	void *(*mmap)(struct host1x_bo *bo);
 	void (*munmap)(struct host1x_bo *bo, void *addr);
 	void *(*kmap)(struct host1x_bo *bo, unsigned int pagenum);
@@ -95,15 +96,17 @@ static inline void host1x_bo_put(struct host1x_bo *bo)
 	bo->ops->put(bo);
 }
 
-static inline dma_addr_t host1x_bo_pin(struct host1x_bo *bo,
-				       struct sg_table **sgt)
+static inline struct sg_table *host1x_bo_pin(struct device *dev,
+					     struct host1x_bo *bo,
+					     dma_addr_t *phys)
 {
-	return bo->ops->pin(bo, sgt);
+	return bo->ops->pin(dev, bo, phys);
 }
 
-static inline void host1x_bo_unpin(struct host1x_bo *bo, struct sg_table *sgt)
+static inline void host1x_bo_unpin(struct device *dev, struct host1x_bo *bo,
+				   struct sg_table *sgt)
 {
-	bo->ops->unpin(bo, sgt);
+	bo->ops->unpin(dev, sgt);
 }
 
 static inline void *host1x_bo_mmap(struct host1x_bo *bo)

commit aacdf19849734d1be5e407932228ae101ba5b92f
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Feb 8 14:35:13 2019 +0100

    drm/tegra: Move IOMMU group into host1x client
    
    Handling of the IOMMU group attachment is common to all clients, so move
    the group into the client to simplify code.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index 4396cd566a33..df6e613ba715 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -18,6 +18,7 @@ enum host1x_class {
 };
 
 struct host1x_client;
+struct iommu_group;
 
 /**
  * struct host1x_client_ops - host1x client operations
@@ -34,6 +35,7 @@ struct host1x_client_ops {
  * @list: list node for the host1x client
  * @parent: pointer to struct device representing the host1x controller
  * @dev: pointer to struct device backing this host1x client
+ * @group: IOMMU group that this client is a member of
  * @ops: host1x client operations
  * @class: host1x class represented by this client
  * @channel: host1x channel associated with this client
@@ -44,6 +46,7 @@ struct host1x_client {
 	struct list_head list;
 	struct device *parent;
 	struct device *dev;
+	struct iommu_group *group;
 
 	const struct host1x_client_ops *ops;
 

commit caccddcfc4b4de75930df2e8f7fd0c66556b13ff
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Jun 18 14:01:51 2018 +0200

    gpu: host1x: Request channels for clients, not devices
    
    A struct device doesn't carry much information that a channel might be
    interested in, but the client very much does. Request channels for the
    clients rather than their parent devices and store a pointer to them
    in order to have that information available when needed.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index e6eea45e1154..4396cd566a33 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -158,7 +158,7 @@ u32 host1x_syncpt_base_id(struct host1x_syncpt_base *base);
 struct host1x_channel;
 struct host1x_job;
 
-struct host1x_channel *host1x_channel_request(struct device *dev);
+struct host1x_channel *host1x_channel_request(struct host1x_client *client);
 struct host1x_channel *host1x_channel_get(struct host1x_channel *channel);
 void host1x_channel_put(struct host1x_channel *channel);
 int host1x_job_submit(struct host1x_job *job);

commit dfd03396d7b66f90071aa5e8fdc0f3c4a66471c5
Merge: 9b75276e4fb1 eb7cf945a8da
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Jun 25 12:59:35 2019 +1000

    Merge tag 'drm/tegra/for-5.3-rc1' of git://anongit.freedesktop.org/tegra/linux into drm-next
    
    drm/tegra: Changes for v5.3-rc1
    
    This contains a couple of small improvements and cleanups for the Tegra
    DRM driver.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Thierry Reding <thierry.reding@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190621150753.19550-1-thierry.reding@gmail.com

commit 1e390478cfb527e34c9ab89ba57212cb05c33c51
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Jun 5 10:46:05 2019 +0200

    gpu: host1x: Increase maximum DMA segment size
    
    Recent versions of the DMA API debug code have started to warn about
    violations of the maximum DMA segment size. This is because the segment
    size defaults to 64 KiB, which can easily be exceeded in large buffer
    allocations such as used in DRM/KMS for framebuffers.
    
    Technically the Tegra SMMU and ARM SMMU don't have a maximum segment
    size (they map individual pages irrespective of whether they are
    contiguous or not), so the choice of 4 MiB is a bit arbitrary here. The
    maximum segment size is a 32-bit unsigned integer, though, so we can't
    set it to the correct maximum size, which would be the size of the
    aperture.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index 89110d896d72..aef6e2f73802 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -310,6 +310,8 @@ struct host1x_device {
 	struct list_head clients;
 
 	bool registered;
+
+	struct device_dma_parameters dma_parms;
 };
 
 static inline struct host1x_device *to_host1x_device(struct device *dev)

commit 16216333235adf51093d0330a934a7e4a03134fe
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:31 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 1
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      51 franklin street fifth floor boston ma 02110 1301 usa
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option [no]_[pad]_[ctrl] any later version this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 51 franklin street fifth floor boston ma
      02110 1301 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 176 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154040.652910950@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index 89110d896d72..cfff30b9a62e 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -1,19 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Copyright (c) 2009-2013, NVIDIA Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
 #ifndef __LINUX_HOST1X_H

commit 326bbd79fd61716841585a52d5b68f48f4e6644e
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed May 16 17:01:43 2018 +0200

    gpu: host1x: Use not explicitly sized types
    
    The number of words and the offset in a gather don't need to be
    explicitly sized, so make them unsigned int instead.
    
    Reviewed-by: Dmitry Osipenko <digetx@gmail.com>
    Tested-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index dcb6140d39d7..89110d896d72 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -251,8 +251,8 @@ struct host1x_job {
 
 struct host1x_job *host1x_job_alloc(struct host1x_channel *ch,
 				    u32 num_cmdbufs, u32 num_relocs);
-void host1x_job_add_gather(struct host1x_job *job, struct host1x_bo *mem_id,
-			   u32 words, u32 offset);
+void host1x_job_add_gather(struct host1x_job *job, struct host1x_bo *bo,
+			   unsigned int words, unsigned int offset);
 struct host1x_job *host1x_job_get(struct host1x_job *job);
 void host1x_job_put(struct host1x_job *job);
 int host1x_job_pin(struct host1x_job *job, struct device *dev);

commit 06490bb99e1840ab2b6814af7356e8b4ab0e3ee6
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed May 16 16:58:44 2018 +0200

    gpu: host1x: Rename relocarray -> relocs for consistency
    
    All other array variables use a plural, and this is the only one using
    the *array suffix. This is confusing, so rename it for consistency.
    
    Reviewed-by: Dmitry Osipenko <digetx@gmail.com>
    Tested-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index 0632010f47fb..dcb6140d39d7 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -210,7 +210,7 @@ struct host1x_job {
 	unsigned int num_gathers;
 
 	/* Array of handles to be pinned & unpinned */
-	struct host1x_reloc *relocarray;
+	struct host1x_reloc *relocs;
 	unsigned int num_relocs;
 	struct host1x_job_unpin_data *unpins;
 	unsigned int num_unpins;

commit bf3d41ccabb53c57e19fcfc8b81d790043ac2bed
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed May 16 14:12:33 2018 +0200

    gpu: host1x: Store pointer to client in jobs
    
    Rather than storing some identifier derived from the application
    context that can't be used concretely anywhere, store a pointer to the
    client directly so that accesses can be made directly through that
    client object.
    
    Reviewed-by: Dmitry Osipenko <digetx@gmail.com>
    Tested-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index f66bece1e1b7..0632010f47fb 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -202,7 +202,8 @@ struct host1x_job {
 	/* Channel where job is submitted to */
 	struct host1x_channel *channel;
 
-	u32 client;
+	/* client where the job originated */
+	struct host1x_client *client;
 
 	/* Gathers and their memory */
 	struct host1x_job_gather *gathers;

commit 24c94e166dfe89839129b8e0fae208b6af60d6f1
Author: Thierry Reding <treding@nvidia.com>
Date:   Sat May 5 08:45:47 2018 +0200

    gpu: host1x: Remove wait check support
    
    The job submission userspace ABI doesn't support this and there are no
    plans to implement it, so all of this code is dead and can be removed.
    
    Reviewed-by: Dmitry Osipenko <digetx@gmail.com>
    Tested-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index ddf7f9ca86cc..f66bece1e1b7 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -192,13 +192,6 @@ struct host1x_reloc {
 	unsigned long shift;
 };
 
-struct host1x_waitchk {
-	struct host1x_bo *bo;
-	u32 offset;
-	u32 syncpt_id;
-	u32 thresh;
-};
-
 struct host1x_job {
 	/* When refcount goes to zero, job can be freed */
 	struct kref ref;
@@ -215,11 +208,6 @@ struct host1x_job {
 	struct host1x_job_gather *gathers;
 	unsigned int num_gathers;
 
-	/* Wait checks to be processed at submit time */
-	struct host1x_waitchk *waitchk;
-	unsigned int num_waitchk;
-	u32 waitchk_mask;
-
 	/* Array of handles to be pinned & unpinned */
 	struct host1x_reloc *relocarray;
 	unsigned int num_relocs;
@@ -261,8 +249,7 @@ struct host1x_job {
 };
 
 struct host1x_job *host1x_job_alloc(struct host1x_channel *ch,
-				    u32 num_cmdbufs, u32 num_relocs,
-				    u32 num_waitchks);
+				    u32 num_cmdbufs, u32 num_relocs);
 void host1x_job_add_gather(struct host1x_job *job, struct host1x_bo *mem_id,
 			   u32 words, u32 offset);
 struct host1x_job *host1x_job_get(struct host1x_job *job);

commit 617dd7cc490b72345277e2666c8ed34d4f47f0da
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Aug 30 12:48:31 2017 +0200

    gpu: host1x: syncpt: Request syncpoints per client
    
    Rather than request syncpoints for a struct device *, request them for a
    struct host1x_client *. This is important because subsequent patches are
    going to break the assumption that host1x will always be the parent for
    devices requesting a syncpoint. It's also a more natural choice because
    host1x clients are really the only ones that will know how to deal with
    syncpoints.
    
    Note that host1x clients are always guaranteed to be children of host1x,
    regardless of their location in the device tree.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index 630b1a98ab58..ddf7f9ca86cc 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -157,7 +157,7 @@ int host1x_syncpt_incr(struct host1x_syncpt *sp);
 u32 host1x_syncpt_incr_max(struct host1x_syncpt *sp, u32 incrs);
 int host1x_syncpt_wait(struct host1x_syncpt *sp, u32 thresh, long timeout,
 		       u32 *value);
-struct host1x_syncpt *host1x_syncpt_request(struct device *dev,
+struct host1x_syncpt *host1x_syncpt_request(struct host1x_client *client,
 					    unsigned long flags);
 void host1x_syncpt_free(struct host1x_syncpt *sp);
 

commit 8474b02531c4881a762c52ef869c52429e38633f
Author: Mikko Perttunen <mperttunen@nvidia.com>
Date:   Thu Jun 15 02:18:42 2017 +0300

    gpu: host1x: Refactor channel allocation code
    
    This is largely a rewrite of the Host1x channel allocation code, bringing
    several changes:
    
    - The previous code could deadlock due to an interaction
      between the 'reflock' mutex and CDMA timeout handling.
      This gets rid of the mutex.
    - Support for more than 32 channels, required for Tegra186
    - General refactoring, including better encapsulation
      of channel ownership handling into channel.c
    
    Signed-off-by: Mikko Perttunen <mperttunen@nvidia.com>
    Reviewed-by: Dmitry Osipenko <digetx@gmail.com>
    Tested-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index 476da0e06bb2..630b1a98ab58 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -172,7 +172,6 @@ struct host1x_channel;
 struct host1x_job;
 
 struct host1x_channel *host1x_channel_request(struct device *dev);
-void host1x_channel_free(struct host1x_channel *channel);
 struct host1x_channel *host1x_channel_get(struct host1x_channel *channel);
 void host1x_channel_put(struct host1x_channel *channel);
 int host1x_job_submit(struct host1x_job *job);

commit a2b78b0d53f0808ebc2a0368b589a5cb6b672294
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Thu Jun 15 02:18:38 2017 +0300

    gpu: host1x: Correct swapped arguments in the is_addr_reg() definition
    
    Arguments of the .is_addr_reg() are swapped in the definition of the
    function, that is quite confusing.
    
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Reviewed-by: Erik Faye-Lund <kusmabite@gmail.com>
    Reviewed-by: Mikko Perttunen <mperttunen@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index b5358f855d9e..476da0e06bb2 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -249,7 +249,7 @@ struct host1x_job {
 	u8 *gather_copy_mapped;
 
 	/* Check if register is marked as an address reg */
-	int (*is_addr_reg)(struct device *dev, u32 reg, u32 class);
+	int (*is_addr_reg)(struct device *dev, u32 class, u32 reg);
 
 	/* Check if class belongs to the unit */
 	int (*is_valid_class)(u32 class);

commit 0f563a4bf66e5182f0882efee398f7e6bc0bb1be
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Thu Jun 15 02:18:37 2017 +0300

    gpu: host1x: Forbid unrelated SETCLASS opcode in the firewall
    
    Several channels could be made to write the same unit concurrently via
    the SETCLASS opcode, trusting userspace is a bad idea. It should be
    possible to drop the per-client channel reservation and add a per-unit
    locking by inserting MLOCK's to the command stream to re-allow the
    SETCLASS opcode, but it will be much more work. Let's forbid the
    unit-unrelated class changes for now.
    
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Reviewed-by: Erik Faye-Lund <kusmabite@gmail.com>
    Reviewed-by: Mikko Perttunen <mperttunen@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index ba0b245da732..b5358f855d9e 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -251,6 +251,9 @@ struct host1x_job {
 	/* Check if register is marked as an address reg */
 	int (*is_addr_reg)(struct device *dev, u32 reg, u32 class);
 
+	/* Check if class belongs to the unit */
+	int (*is_valid_class)(u32 class);
+
 	/* Request a SETCLASS to this class */
 	u32 class;
 

commit d0fbbdff2e19aabccc1107b7e12ab9f3cbf626ef
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Thu Jun 15 02:18:27 2017 +0300

    drm/tegra: Correct copying of waitchecks and disable them in the 'submit' IOCTL
    
    The waitchecks along with multiple syncpoints per submit are not ready
    for use yet, let's forbid them for now.
    
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Reviewed-by: Mikko Perttunen <mperttunen@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index 840a8ad627b2..ba0b245da732 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -193,6 +193,13 @@ struct host1x_reloc {
 	unsigned long shift;
 };
 
+struct host1x_waitchk {
+	struct host1x_bo *bo;
+	u32 offset;
+	u32 syncpt_id;
+	u32 thresh;
+};
+
 struct host1x_job {
 	/* When refcount goes to zero, job can be freed */
 	struct kref ref;

commit 466749f13e33d892cf9263d7efbc0ea713c23ed7
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Apr 10 12:27:01 2017 +0200

    gpu: host1x: Flesh out kerneldoc
    
    Improve kerneldoc for the public parts of the host1x infrastructure in
    preparation for adding driver-specific part to the GPU documentation.
    
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index 3d04aa1dc83e..840a8ad627b2 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -32,11 +32,27 @@ enum host1x_class {
 
 struct host1x_client;
 
+/**
+ * struct host1x_client_ops - host1x client operations
+ * @init: host1x client initialization code
+ * @exit: host1x client tear down code
+ */
 struct host1x_client_ops {
 	int (*init)(struct host1x_client *client);
 	int (*exit)(struct host1x_client *client);
 };
 
+/**
+ * struct host1x_client - host1x client structure
+ * @list: list node for the host1x client
+ * @parent: pointer to struct device representing the host1x controller
+ * @dev: pointer to struct device backing this host1x client
+ * @ops: host1x client operations
+ * @class: host1x class represented by this client
+ * @channel: host1x channel associated with this client
+ * @syncpts: array of syncpoints requested for this client
+ * @num_syncpts: number of syncpoints requested for this client
+ */
 struct host1x_client {
 	struct list_head list;
 	struct device *parent;
@@ -251,6 +267,15 @@ void host1x_job_unpin(struct host1x_job *job);
 
 struct host1x_device;
 
+/**
+ * struct host1x_driver - host1x logical device driver
+ * @driver: core driver
+ * @subdevs: table of OF device IDs matching subdevices for this driver
+ * @list: list node for the driver
+ * @probe: called when the host1x logical device is probed
+ * @remove: called when the host1x logical device is removed
+ * @shutdown: called when the host1x logical device is shut down
+ */
 struct host1x_driver {
 	struct device_driver driver;
 

commit 0ae797a8ba05a2354db5e81c1d7df04671dd1c25
Author: Arto Merilainen <amerilainen@nvidia.com>
Date:   Wed Dec 14 13:16:13 2016 +0200

    drm/tegra: Add VIC support
    
    This patch adds support for Video Image Compositor engine which
    can be used for 2d operations.
    
    Signed-off-by: Andrew Chew <achew@nvidia.com>
    Signed-off-by: Arto Merilainen <amerilainen@nvidia.com>
    Signed-off-by: Mikko Perttunen <mperttunen@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index 1ffbf2a8cb99..3d04aa1dc83e 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -26,6 +26,7 @@ enum host1x_class {
 	HOST1X_CLASS_HOST1X = 0x1,
 	HOST1X_CLASS_GR2D = 0x51,
 	HOST1X_CLASS_GR2D_SB = 0x52,
+	HOST1X_CLASS_VIC = 0x5D,
 	HOST1X_CLASS_GR3D = 0x60,
 };
 

commit 87904c3e82319cf2bad8d656d79c5030dab9490e
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Aug 12 16:00:53 2016 +0200

    drm/tegra: dsi: Enhance runtime power management
    
    The MIPI DSI output on Tegra SoCs requires some external logic to
    calibrate the MIPI pads before a video signal can be transmitted. This
    MIPI calibration logic requires to be powered on while the MIPI pads are
    being used, which is currently done as part of the DSI driver's probe
    implementation.
    
    This is suboptimal because it will leave the MIPI calibration logic
    powered up even if the DSI output is never used.
    
    On Tegra114 and earlier this behaviour also causes the driver to hang
    while trying to power up the MIPI calibration logic because the power
    partition that contains the MIPI calibration logic will be powered on
    by the display controller at output pipeline configuration time. Thus
    the power up sequence for the MIPI calibration logic happens before
    it's power partition is guaranteed to be enabled.
    
    Fix this by splitting up the API into a request/free pair of functions
    that manage the runtime dependency between the DSI and the calibration
    modules (no registers are accessed) and a set of enable, calibrate and
    disable functions that program the MIPI calibration logic at points in
    time where the power partition is really enabled.
    
    While at it, make sure that the runtime power management also works in
    ganged mode, which is currently also broken.
    
    Reported-by: Jonathan Hunter <jonathanh@nvidia.com>
    Tested-by: Jonathan Hunter <jonathanh@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index d2ba7d334039..1ffbf2a8cb99 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -304,6 +304,8 @@ struct tegra_mipi_device;
 
 struct tegra_mipi_device *tegra_mipi_request(struct device *device);
 void tegra_mipi_free(struct tegra_mipi_device *device);
+int tegra_mipi_enable(struct tegra_mipi_device *device);
+int tegra_mipi_disable(struct tegra_mipi_device *device);
 int tegra_mipi_calibrate(struct tegra_mipi_device *device);
 
 #endif

commit b4a20144e0c0a45431695fa5968ce2ed8c9ce6ca
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Jan 28 14:29:02 2015 +0100

    gpu: host1x: Export host1x_syncpt_read()
    
    This function is used to read the current value of the syncpt and is
    useful in situations where drivers don't schedule work and wait for the
    syncpoint to increment. One particular use-case is using the syncpoint
    as a VBLANK counter.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index 464f33814a94..d2ba7d334039 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -135,6 +135,7 @@ struct host1x_syncpt *host1x_syncpt_get(struct host1x *host, u32 id);
 u32 host1x_syncpt_id(struct host1x_syncpt *sp);
 u32 host1x_syncpt_read_min(struct host1x_syncpt *sp);
 u32 host1x_syncpt_read_max(struct host1x_syncpt *sp);
+u32 host1x_syncpt_read(struct host1x_syncpt *sp);
 int host1x_syncpt_incr(struct host1x_syncpt *sp);
 u32 host1x_syncpt_incr_max(struct host1x_syncpt *sp, u32 incrs);
 int host1x_syncpt_wait(struct host1x_syncpt *sp, u32 thresh, long timeout,

commit f4c5cf88fbd50e4779042268947b2e2f90c20484
Author: Thierry Reding <treding@nvidia.com>
Date:   Thu Dec 18 15:29:14 2014 +0100

    gpu: host1x: Provide a proper struct bus_type
    
    Previously the struct bus_type exported by the host1x infrastructure was
    only a very basic skeleton. Turn that implementation into a more full-
    fledged bus to support proper probe ordering and power management.
    
    Note that the bus infrastructure needs to be available before any of the
    drivers can be registered. This is automatically ensured if all drivers
    are built as loadable modules (via symbol dependencies). If all drivers
    are built-in there are no such guarantees and the link order determines
    the initcall ordering. Adjust drivers/gpu/Makefile to make sure that the
    host1x bus infrastructure is initialized prior to any of its users (only
    drm/tegra currently).
    
    v2: Fix building host1x and tegra-drm as modules
        Reported-by: Dave Airlie <airlied@gmail.com>
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Mark Zhang <markz@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index 7890b553d12e..464f33814a94 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -250,17 +250,29 @@ void host1x_job_unpin(struct host1x_job *job);
 struct host1x_device;
 
 struct host1x_driver {
+	struct device_driver driver;
+
 	const struct of_device_id *subdevs;
 	struct list_head list;
-	const char *name;
 
 	int (*probe)(struct host1x_device *device);
 	int (*remove)(struct host1x_device *device);
+	void (*shutdown)(struct host1x_device *device);
 };
 
-int host1x_driver_register(struct host1x_driver *driver);
+static inline struct host1x_driver *
+to_host1x_driver(struct device_driver *driver)
+{
+	return container_of(driver, struct host1x_driver, driver);
+}
+
+int host1x_driver_register_full(struct host1x_driver *driver,
+				struct module *owner);
 void host1x_driver_unregister(struct host1x_driver *driver);
 
+#define host1x_driver_register(driver) \
+	host1x_driver_register_full(driver, THIS_MODULE)
+
 struct host1x_device {
 	struct host1x_driver *driver;
 	struct list_head list;
@@ -273,7 +285,7 @@ struct host1x_device {
 	struct mutex clients_lock;
 	struct list_head clients;
 
-	bool bound;
+	bool registered;
 };
 
 static inline struct host1x_device *to_host1x_device(struct device *dev)

commit 536e1715226c94037df12f7c6280cbe0f6009f92
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Nov 5 11:43:26 2014 +0100

    gpu: host1x: Call ->remove() only when a device is bound
    
    When a driver's ->probe() function fails, the host1x bus must not call
    its ->remove() function because the driver will already have cleaned up
    in the error handling path in ->probe().
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index bb9840fd1e18..7890b553d12e 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -272,6 +272,8 @@ struct host1x_device {
 
 	struct mutex clients_lock;
 	struct list_head clients;
+
+	bool bound;
 };
 
 static inline struct host1x_device *to_host1x_device(struct device *dev)

commit 961e3beae3b29ae9463631415342244cdaf1cd47
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Jun 10 10:25:00 2014 +0200

    drm/tegra: Make job submission 64-bit safe
    
    Job submission currently relies on the fact that struct drm_tegra_reloc
    and struct host1x_reloc are the same size and uses a simple call to the
    copy_from_user() function to copy them to kernel space. This causes the
    handle to be stored in the buffer object field, which then needs a cast
    to a 32 bit integer to resolve it to a proper buffer object pointer and
    store it back in the buffer object field.
    
    On 64-bit architectures that will no longer work, since pointers are 64
    bits wide whereas handles will remain 32 bits. This causes the sizes of
    both structures to because different and copying will no longer work.
    
    Fix this by adding a new function, host1x_reloc_get_user(), that copies
    the structures field by field.
    
    While at it, use substructures for the command and target buffers in
    struct host1x_reloc for better readability. Also use unsized types to
    make it more obvious that this isn't part of userspace ABI.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index d2b52999e771..bb9840fd1e18 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -164,12 +164,15 @@ int host1x_job_submit(struct host1x_job *job);
  */
 
 struct host1x_reloc {
-	struct host1x_bo *cmdbuf;
-	u32 cmdbuf_offset;
-	struct host1x_bo *target;
-	u32 target_offset;
-	u32 shift;
-	u32 pad;
+	struct {
+		struct host1x_bo *bo;
+		unsigned long offset;
+	} cmdbuf;
+	struct {
+		struct host1x_bo *bo;
+		unsigned long offset;
+	} target;
+	unsigned long shift;
 };
 
 struct host1x_job {

commit 64400c3791d9fcebf23318a289f9da964547a6f3
Author: Bryan Wu <pengw@nvidia.com>
Date:   Wed Feb 19 14:48:36 2014 -0800

    gpu: host1x: export host1x_syncpt_incr_max() function
    
    Tegra V4L2 camera driver needs this function to do frame capture.
    
    Signed-off-by: Bryan Wu <pengw@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index 3af847273277..d2b52999e771 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -136,6 +136,7 @@ u32 host1x_syncpt_id(struct host1x_syncpt *sp);
 u32 host1x_syncpt_read_min(struct host1x_syncpt *sp);
 u32 host1x_syncpt_read_max(struct host1x_syncpt *sp);
 int host1x_syncpt_incr(struct host1x_syncpt *sp);
+u32 host1x_syncpt_incr_max(struct host1x_syncpt *sp, u32 incrs);
 int host1x_syncpt_wait(struct host1x_syncpt *sp, u32 thresh, long timeout,
 		       u32 *value);
 struct host1x_syncpt *host1x_syncpt_request(struct device *dev,

commit 4de6a2d6acb0e2a840f07db17def7e674b9d2bb4
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Sep 2 09:48:53 2013 +0200

    gpu: host1x: Add MIPI pad calibration support
    
    This driver adds support to perform calibration of the MIPI pads for CSI
    and DSI.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index f5b9b87ac9a9..3af847273277 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -281,4 +281,10 @@ int host1x_device_exit(struct host1x_device *device);
 int host1x_client_register(struct host1x_client *client);
 int host1x_client_unregister(struct host1x_client *client);
 
+struct tegra_mipi_device;
+
+struct tegra_mipi_device *tegra_mipi_request(struct device *device);
+void tegra_mipi_free(struct tegra_mipi_device *device);
+int tegra_mipi_calibrate(struct tegra_mipi_device *device);
+
 #endif

commit f5a954fed9b3eb04973ede72c50c66157fa9e15b
Author: Arto Merilainen <amerilainen@nvidia.com>
Date:   Mon Oct 14 15:21:53 2013 +0300

    gpu: host1x: Add syncpoint base support
    
    This patch adds support for hardware syncpoint bases. This creates
    a simple mechanism to stall the command FIFO until an operation is
    completed.
    
    Signed-off-by: Arto Merilainen <amerilainen@nvidia.com>
    Reviewed-by: Terje Bergstrom <tbergstrom@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index eb713dbbae29..f5b9b87ac9a9 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -125,7 +125,9 @@ static inline void host1x_bo_kunmap(struct host1x_bo *bo,
  */
 
 #define HOST1X_SYNCPT_CLIENT_MANAGED	(1 << 0)
+#define HOST1X_SYNCPT_HAS_BASE		(1 << 1)
 
+struct host1x_syncpt_base;
 struct host1x_syncpt;
 struct host1x;
 
@@ -140,6 +142,9 @@ struct host1x_syncpt *host1x_syncpt_request(struct device *dev,
 					    unsigned long flags);
 void host1x_syncpt_free(struct host1x_syncpt *sp);
 
+struct host1x_syncpt_base *host1x_syncpt_get_base(struct host1x_syncpt *sp);
+u32 host1x_syncpt_base_id(struct host1x_syncpt_base *base);
+
 /*
  * host1x channel
  */

commit 8736fe81532182ba0086a371fae0708ea42a2cdf
Author: Arto Merilainen <amerilainen@nvidia.com>
Date:   Mon Oct 14 15:21:52 2013 +0300

    gpu: host1x: Add 'flags' field to syncpt request
    
    Functions host1x_syncpt_request() and _host1x_syncpt_alloc() have
    been taking a separate boolean flag ('client_managed') for indicating
    if the syncpoint value should be tracked by the host1x driver.
    
    This patch converts the field into generic 'flags' field so that
    we can easily add more information while requesting a syncpoint.
    Clients are adapted to use the new interface accordingly.
    
    Signed-off-by: Arto Merilainen <amerilainen@nvidia.com>
    Reviewed-by: Terje Bergstrom <tbergstrom@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index f5dd56fbdc3e..eb713dbbae29 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -124,6 +124,8 @@ static inline void host1x_bo_kunmap(struct host1x_bo *bo,
  * host1x syncpoints
  */
 
+#define HOST1X_SYNCPT_CLIENT_MANAGED	(1 << 0)
+
 struct host1x_syncpt;
 struct host1x;
 
@@ -135,7 +137,7 @@ int host1x_syncpt_incr(struct host1x_syncpt *sp);
 int host1x_syncpt_wait(struct host1x_syncpt *sp, u32 thresh, long timeout,
 		       u32 *value);
 struct host1x_syncpt *host1x_syncpt_request(struct device *dev,
-					    bool client_managed);
+					    unsigned long flags);
 void host1x_syncpt_free(struct host1x_syncpt *sp);
 
 /*

commit 5f60ed0d840d53e9d65aa54e1a5365af8ce2769e
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Thu Feb 28 08:08:01 2013 +0100

    drm/tegra: Add 3D support
    
    Initialize and power the 3D unit on Tegra20, Tegra30 and Tegra114 and
    register a channel with the Tegra DRM driver so that the unit can be
    used from userspace.
    
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index e62c61a4afa9..f5dd56fbdc3e 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -26,6 +26,7 @@ enum host1x_class {
 	HOST1X_CLASS_HOST1X = 0x1,
 	HOST1X_CLASS_GR2D = 0x51,
 	HOST1X_CLASS_GR2D_SB = 0x52,
+	HOST1X_CLASS_GR3D = 0x60,
 };
 
 struct host1x_client;

commit 776dc38403676f499a73d32e2e7c61eb5b42f736
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Oct 14 14:43:22 2013 +0200

    drm/tegra: Move subdevice infrastructure to host1x
    
    The Tegra DRM driver currently uses some infrastructure to defer the DRM
    core initialization until all required devices have registered. The same
    infrastructure can potentially be used by any other driver that requires
    more than a single sub-device of the host1x module.
    
    Make the infrastructure more generic and keep only the DRM specific code
    in the DRM part of the driver. Eventually this will make it easy to move
    the DRM driver part back to the DRM subsystem.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index 7442f2a57039..e62c61a4afa9 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -19,7 +19,7 @@
 #ifndef __LINUX_HOST1X_H
 #define __LINUX_HOST1X_H
 
-#include <linux/kref.h>
+#include <linux/device.h>
 #include <linux/types.h>
 
 enum host1x_class {
@@ -37,6 +37,7 @@ struct host1x_client_ops {
 
 struct host1x_client {
 	struct list_head list;
+	struct device *parent;
 	struct device *dev;
 
 	const struct host1x_client_ops *ops;
@@ -230,4 +231,46 @@ void host1x_job_put(struct host1x_job *job);
 int host1x_job_pin(struct host1x_job *job, struct device *dev);
 void host1x_job_unpin(struct host1x_job *job);
 
+/*
+ * subdevice probe infrastructure
+ */
+
+struct host1x_device;
+
+struct host1x_driver {
+	const struct of_device_id *subdevs;
+	struct list_head list;
+	const char *name;
+
+	int (*probe)(struct host1x_device *device);
+	int (*remove)(struct host1x_device *device);
+};
+
+int host1x_driver_register(struct host1x_driver *driver);
+void host1x_driver_unregister(struct host1x_driver *driver);
+
+struct host1x_device {
+	struct host1x_driver *driver;
+	struct list_head list;
+	struct device dev;
+
+	struct mutex subdevs_lock;
+	struct list_head subdevs;
+	struct list_head active;
+
+	struct mutex clients_lock;
+	struct list_head clients;
+};
+
+static inline struct host1x_device *to_host1x_device(struct device *dev)
+{
+	return container_of(dev, struct host1x_device, dev);
+}
+
+int host1x_device_init(struct host1x_device *device);
+int host1x_device_exit(struct host1x_device *device);
+
+int host1x_client_register(struct host1x_client *client);
+int host1x_client_unregister(struct host1x_client *client);
+
 #endif

commit 35d747a81d7eb824bd0c3476cd0c564b52ad5353
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Sep 24 16:30:32 2013 +0200

    gpu: host1x: Expose syncpt and channel functionality
    
    Expose the buffer objects, syncpoint and channel functionality in the
    public public header so that drivers can use them.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index d429a938ba13..7442f2a57039 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -19,6 +19,9 @@
 #ifndef __LINUX_HOST1X_H
 #define __LINUX_HOST1X_H
 
+#include <linux/kref.h>
+#include <linux/types.h>
+
 enum host1x_class {
 	HOST1X_CLASS_HOST1X = 0x1,
 	HOST1X_CLASS_GR2D = 0x51,
@@ -45,4 +48,186 @@ struct host1x_client {
 	unsigned int num_syncpts;
 };
 
+/*
+ * host1x buffer objects
+ */
+
+struct host1x_bo;
+struct sg_table;
+
+struct host1x_bo_ops {
+	struct host1x_bo *(*get)(struct host1x_bo *bo);
+	void (*put)(struct host1x_bo *bo);
+	dma_addr_t (*pin)(struct host1x_bo *bo, struct sg_table **sgt);
+	void (*unpin)(struct host1x_bo *bo, struct sg_table *sgt);
+	void *(*mmap)(struct host1x_bo *bo);
+	void (*munmap)(struct host1x_bo *bo, void *addr);
+	void *(*kmap)(struct host1x_bo *bo, unsigned int pagenum);
+	void (*kunmap)(struct host1x_bo *bo, unsigned int pagenum, void *addr);
+};
+
+struct host1x_bo {
+	const struct host1x_bo_ops *ops;
+};
+
+static inline void host1x_bo_init(struct host1x_bo *bo,
+				  const struct host1x_bo_ops *ops)
+{
+	bo->ops = ops;
+}
+
+static inline struct host1x_bo *host1x_bo_get(struct host1x_bo *bo)
+{
+	return bo->ops->get(bo);
+}
+
+static inline void host1x_bo_put(struct host1x_bo *bo)
+{
+	bo->ops->put(bo);
+}
+
+static inline dma_addr_t host1x_bo_pin(struct host1x_bo *bo,
+				       struct sg_table **sgt)
+{
+	return bo->ops->pin(bo, sgt);
+}
+
+static inline void host1x_bo_unpin(struct host1x_bo *bo, struct sg_table *sgt)
+{
+	bo->ops->unpin(bo, sgt);
+}
+
+static inline void *host1x_bo_mmap(struct host1x_bo *bo)
+{
+	return bo->ops->mmap(bo);
+}
+
+static inline void host1x_bo_munmap(struct host1x_bo *bo, void *addr)
+{
+	bo->ops->munmap(bo, addr);
+}
+
+static inline void *host1x_bo_kmap(struct host1x_bo *bo, unsigned int pagenum)
+{
+	return bo->ops->kmap(bo, pagenum);
+}
+
+static inline void host1x_bo_kunmap(struct host1x_bo *bo,
+				    unsigned int pagenum, void *addr)
+{
+	bo->ops->kunmap(bo, pagenum, addr);
+}
+
+/*
+ * host1x syncpoints
+ */
+
+struct host1x_syncpt;
+struct host1x;
+
+struct host1x_syncpt *host1x_syncpt_get(struct host1x *host, u32 id);
+u32 host1x_syncpt_id(struct host1x_syncpt *sp);
+u32 host1x_syncpt_read_min(struct host1x_syncpt *sp);
+u32 host1x_syncpt_read_max(struct host1x_syncpt *sp);
+int host1x_syncpt_incr(struct host1x_syncpt *sp);
+int host1x_syncpt_wait(struct host1x_syncpt *sp, u32 thresh, long timeout,
+		       u32 *value);
+struct host1x_syncpt *host1x_syncpt_request(struct device *dev,
+					    bool client_managed);
+void host1x_syncpt_free(struct host1x_syncpt *sp);
+
+/*
+ * host1x channel
+ */
+
+struct host1x_channel;
+struct host1x_job;
+
+struct host1x_channel *host1x_channel_request(struct device *dev);
+void host1x_channel_free(struct host1x_channel *channel);
+struct host1x_channel *host1x_channel_get(struct host1x_channel *channel);
+void host1x_channel_put(struct host1x_channel *channel);
+int host1x_job_submit(struct host1x_job *job);
+
+/*
+ * host1x job
+ */
+
+struct host1x_reloc {
+	struct host1x_bo *cmdbuf;
+	u32 cmdbuf_offset;
+	struct host1x_bo *target;
+	u32 target_offset;
+	u32 shift;
+	u32 pad;
+};
+
+struct host1x_job {
+	/* When refcount goes to zero, job can be freed */
+	struct kref ref;
+
+	/* List entry */
+	struct list_head list;
+
+	/* Channel where job is submitted to */
+	struct host1x_channel *channel;
+
+	u32 client;
+
+	/* Gathers and their memory */
+	struct host1x_job_gather *gathers;
+	unsigned int num_gathers;
+
+	/* Wait checks to be processed at submit time */
+	struct host1x_waitchk *waitchk;
+	unsigned int num_waitchk;
+	u32 waitchk_mask;
+
+	/* Array of handles to be pinned & unpinned */
+	struct host1x_reloc *relocarray;
+	unsigned int num_relocs;
+	struct host1x_job_unpin_data *unpins;
+	unsigned int num_unpins;
+
+	dma_addr_t *addr_phys;
+	dma_addr_t *gather_addr_phys;
+	dma_addr_t *reloc_addr_phys;
+
+	/* Sync point id, number of increments and end related to the submit */
+	u32 syncpt_id;
+	u32 syncpt_incrs;
+	u32 syncpt_end;
+
+	/* Maximum time to wait for this job */
+	unsigned int timeout;
+
+	/* Index and number of slots used in the push buffer */
+	unsigned int first_get;
+	unsigned int num_slots;
+
+	/* Copy of gathers */
+	size_t gather_copy_size;
+	dma_addr_t gather_copy;
+	u8 *gather_copy_mapped;
+
+	/* Check if register is marked as an address reg */
+	int (*is_addr_reg)(struct device *dev, u32 reg, u32 class);
+
+	/* Request a SETCLASS to this class */
+	u32 class;
+
+	/* Add a channel wait for previous ops to complete */
+	bool serialize;
+};
+
+struct host1x_job *host1x_job_alloc(struct host1x_channel *ch,
+				    u32 num_cmdbufs, u32 num_relocs,
+				    u32 num_waitchks);
+void host1x_job_add_gather(struct host1x_job *job, struct host1x_bo *mem_id,
+			   u32 words, u32 offset);
+struct host1x_job *host1x_job_get(struct host1x_job *job);
+void host1x_job_put(struct host1x_job *job);
+int host1x_job_pin(struct host1x_job *job, struct device *dev);
+void host1x_job_unpin(struct host1x_job *job);
+
 #endif

commit 53fa7f7204c97dc0c86b99ff8365ad6a7b2ebd78
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Sep 24 15:35:40 2013 +0200

    drm/tegra: Introduce tegra_drm_client structure
    
    This structure derives from host1x_client. DRM-specific fields are moved
    from host1x_client to this structure, so that host1x_client can remain
    agnostic of DRM.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
index fe09939800bc..d429a938ba13 100644
--- a/include/linux/host1x.h
+++ b/include/linux/host1x.h
@@ -25,4 +25,24 @@ enum host1x_class {
 	HOST1X_CLASS_GR2D_SB = 0x52,
 };
 
+struct host1x_client;
+
+struct host1x_client_ops {
+	int (*init)(struct host1x_client *client);
+	int (*exit)(struct host1x_client *client);
+};
+
+struct host1x_client {
+	struct list_head list;
+	struct device *dev;
+
+	const struct host1x_client_ops *ops;
+
+	enum host1x_class class;
+	struct host1x_channel *channel;
+
+	struct host1x_syncpt **syncpts;
+	unsigned int num_syncpts;
+};
+
 #endif

commit e1e906448d2fc6f5a69e1967e00868f0cbfbb566
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Sep 24 13:59:01 2013 +0200

    gpu: host1x: Make host1x header file public
    
    In preparation to support host1x clients other than DRM, move this
    header into a public location.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/host1x.h b/include/linux/host1x.h
new file mode 100644
index 000000000000..fe09939800bc
--- /dev/null
+++ b/include/linux/host1x.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2009-2013, NVIDIA Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef __LINUX_HOST1X_H
+#define __LINUX_HOST1X_H
+
+enum host1x_class {
+	HOST1X_CLASS_HOST1X = 0x1,
+	HOST1X_CLASS_GR2D = 0x51,
+	HOST1X_CLASS_GR2D_SB = 0x52,
+};
+
+#endif
