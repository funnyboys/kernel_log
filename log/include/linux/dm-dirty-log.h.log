commit 87a8f240e9bcf025ba45e4563c842b0d59c5e8ef
Author: Mikulas Patocka <mpatocka@redhat.com>
Date:   Thu Dec 10 23:52:01 2009 +0000

    dm log: add flush callback fn
    
    Introduce a callback pointer from the log to dm-raid1 layer.
    
    Before some region is set as "in-sync", we need to flush hardware cache on
    all the disks. But the log module doesn't have access to the mirror_set
    structure. So it will use this callback.
    
    So far the callback is unused, it will be used in further patches.
    
    Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
    Signed-off-by: Alasdair G Kergon <agk@redhat.com>

diff --git a/include/linux/dm-dirty-log.h b/include/linux/dm-dirty-log.h
index 5e8b11d88f6f..7084503c3405 100644
--- a/include/linux/dm-dirty-log.h
+++ b/include/linux/dm-dirty-log.h
@@ -21,6 +21,7 @@ struct dm_dirty_log_type;
 
 struct dm_dirty_log {
 	struct dm_dirty_log_type *type;
+	int (*flush_callback_fn)(struct dm_target *ti);
 	void *context;
 };
 
@@ -136,8 +137,9 @@ int dm_dirty_log_type_unregister(struct dm_dirty_log_type *type);
  * type->constructor/destructor() directly.
  */
 struct dm_dirty_log *dm_dirty_log_create(const char *type_name,
-					 struct dm_target *ti,
-					 unsigned argc, char **argv);
+			struct dm_target *ti,
+			int (*flush_callback_fn)(struct dm_target *ti),
+			unsigned argc, char **argv);
 void dm_dirty_log_destroy(struct dm_dirty_log *log);
 
 #endif	/* __KERNEL__ */

commit 7513c2a761d69d2a93f17146b3563527d3618ba0
Author: Jonathan Brassow <jbrassow@redhat.com>
Date:   Thu Apr 2 19:55:30 2009 +0100

    dm raid1: add is_remote_recovering hook for clusters
    
    The logging API needs an extra function to make cluster mirroring
    possible.  This new function allows us to check whether a mirror
    region is being recovered on another machine in the cluster.  This
    helps us prevent simultaneous recovery I/O and process I/O to the
    same locations on disk.
    
    Cluster-aware log modules will implement this function.  Single
    machine log modules will not.  So, there is no performance
    penalty for single machine mirrors.
    
    Signed-off-by: Jonathan Brassow <jbrassow@redhat.com>
    Acked-by: Heinz Mauelshagen <heinzm@redhat.com>
    Signed-off-by: Alasdair G Kergon <agk@redhat.com>

diff --git a/include/linux/dm-dirty-log.h b/include/linux/dm-dirty-log.h
index 727602b686d4..5e8b11d88f6f 100644
--- a/include/linux/dm-dirty-log.h
+++ b/include/linux/dm-dirty-log.h
@@ -116,6 +116,16 @@ struct dm_dirty_log_type {
 	 */
 	int (*status)(struct dm_dirty_log *log, status_type_t status_type,
 		      char *result, unsigned maxlen);
+
+	/*
+	 * is_remote_recovering is necessary for cluster mirroring. It provides
+	 * a way to detect recovery on another node, so we aren't writing
+	 * concurrently.  This function is likely to block (when a cluster log
+	 * is used).
+	 *
+	 * Returns: 0, 1
+	 */
+	int (*is_remote_recovering)(struct dm_dirty_log *log, region_t region);
 };
 
 int dm_dirty_log_type_register(struct dm_dirty_log_type *type);

commit ec44ab9d6681ddf9026b593e866bec9c0e075e1d
Author: Mike Snitzer <snitzer@redhat.com>
Date:   Thu Apr 2 19:55:30 2009 +0100

    dm log: remove struct dm_dirty_log_internal
    
    Remove the 'dm_dirty_log_internal' structure.  The resulting cleanup
    eliminates extra memory allocations.  Therefore exposing the internal
    list_head to the external 'dm_dirty_log_type' structure is a worthwhile
    compromise.
    
    Signed-off-by: Mike Snitzer <snitzer@redhat.com>
    Signed-off-by: Alasdair G Kergon <agk@redhat.com>

diff --git a/include/linux/dm-dirty-log.h b/include/linux/dm-dirty-log.h
index 600c5fb2daad..727602b686d4 100644
--- a/include/linux/dm-dirty-log.h
+++ b/include/linux/dm-dirty-log.h
@@ -28,6 +28,9 @@ struct dm_dirty_log_type {
 	const char *name;
 	struct module *module;
 
+	/* For internal device-mapper use */
+	struct list_head list;
+
 	int (*ctr)(struct dm_dirty_log *log, struct dm_target *ti,
 		   unsigned argc, char **argv);
 	void (*dtr)(struct dm_dirty_log *log);

commit a765e20eeb423d0fa6a02ffab51141e53bbd93cb
Author: Alasdair G Kergon <agk@redhat.com>
Date:   Thu Apr 24 22:02:01 2008 +0100

    dm: move include files
    
    Publish the dm-io, dm-log and dm-kcopyd headers in include/linux.
    
    Signed-off-by: Alasdair G Kergon <agk@redhat.com>

diff --git a/include/linux/dm-dirty-log.h b/include/linux/dm-dirty-log.h
new file mode 100644
index 000000000000..600c5fb2daad
--- /dev/null
+++ b/include/linux/dm-dirty-log.h
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2003 Sistina Software
+ * Copyright (C) 2004-2008 Red Hat, Inc. All rights reserved.
+ *
+ * Device-Mapper dirty region log.
+ *
+ * This file is released under the LGPL.
+ */
+
+#ifndef _LINUX_DM_DIRTY_LOG
+#define _LINUX_DM_DIRTY_LOG
+
+#ifdef __KERNEL__
+
+#include <linux/types.h>
+#include <linux/device-mapper.h>
+
+typedef sector_t region_t;
+
+struct dm_dirty_log_type;
+
+struct dm_dirty_log {
+	struct dm_dirty_log_type *type;
+	void *context;
+};
+
+struct dm_dirty_log_type {
+	const char *name;
+	struct module *module;
+
+	int (*ctr)(struct dm_dirty_log *log, struct dm_target *ti,
+		   unsigned argc, char **argv);
+	void (*dtr)(struct dm_dirty_log *log);
+
+	/*
+	 * There are times when we don't want the log to touch
+	 * the disk.
+	 */
+	int (*presuspend)(struct dm_dirty_log *log);
+	int (*postsuspend)(struct dm_dirty_log *log);
+	int (*resume)(struct dm_dirty_log *log);
+
+	/*
+	 * Retrieves the smallest size of region that the log can
+	 * deal with.
+	 */
+	uint32_t (*get_region_size)(struct dm_dirty_log *log);
+
+	/*
+	 * A predicate to say whether a region is clean or not.
+	 * May block.
+	 */
+	int (*is_clean)(struct dm_dirty_log *log, region_t region);
+
+	/*
+	 *  Returns: 0, 1, -EWOULDBLOCK, < 0
+	 *
+	 * A predicate function to check the area given by
+	 * [sector, sector + len) is in sync.
+	 *
+	 * If -EWOULDBLOCK is returned the state of the region is
+	 * unknown, typically this will result in a read being
+	 * passed to a daemon to deal with, since a daemon is
+	 * allowed to block.
+	 */
+	int (*in_sync)(struct dm_dirty_log *log, region_t region,
+		       int can_block);
+
+	/*
+	 * Flush the current log state (eg, to disk).  This
+	 * function may block.
+	 */
+	int (*flush)(struct dm_dirty_log *log);
+
+	/*
+	 * Mark an area as clean or dirty.  These functions may
+	 * block, though for performance reasons blocking should
+	 * be extremely rare (eg, allocating another chunk of
+	 * memory for some reason).
+	 */
+	void (*mark_region)(struct dm_dirty_log *log, region_t region);
+	void (*clear_region)(struct dm_dirty_log *log, region_t region);
+
+	/*
+	 * Returns: <0 (error), 0 (no region), 1 (region)
+	 *
+	 * The mirrord will need perform recovery on regions of
+	 * the mirror that are in the NOSYNC state.  This
+	 * function asks the log to tell the caller about the
+	 * next region that this machine should recover.
+	 *
+	 * Do not confuse this function with 'in_sync()', one
+	 * tells you if an area is synchronised, the other
+	 * assigns recovery work.
+	*/
+	int (*get_resync_work)(struct dm_dirty_log *log, region_t *region);
+
+	/*
+	 * This notifies the log that the resync status of a region
+	 * has changed.  It also clears the region from the recovering
+	 * list (if present).
+	 */
+	void (*set_region_sync)(struct dm_dirty_log *log,
+				region_t region, int in_sync);
+
+	/*
+	 * Returns the number of regions that are in sync.
+	 */
+	region_t (*get_sync_count)(struct dm_dirty_log *log);
+
+	/*
+	 * Support function for mirror status requests.
+	 */
+	int (*status)(struct dm_dirty_log *log, status_type_t status_type,
+		      char *result, unsigned maxlen);
+};
+
+int dm_dirty_log_type_register(struct dm_dirty_log_type *type);
+int dm_dirty_log_type_unregister(struct dm_dirty_log_type *type);
+
+/*
+ * Make sure you use these two functions, rather than calling
+ * type->constructor/destructor() directly.
+ */
+struct dm_dirty_log *dm_dirty_log_create(const char *type_name,
+					 struct dm_target *ti,
+					 unsigned argc, char **argv);
+void dm_dirty_log_destroy(struct dm_dirty_log *log);
+
+#endif	/* __KERNEL__ */
+#endif	/* _LINUX_DM_DIRTY_LOG_H */
