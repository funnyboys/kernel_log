commit 86403a92c3c5c6c395983fdbfc5e2f29dc39279b
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Tue May 19 17:09:52 2020 +0200

    libceph: decode CRUSH device/bucket types and names
    
    These would be matched with the provided client location to calculate
    the locality value.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@kernel.org>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 38b0e4d50ed9..33c16f2de7f6 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -301,6 +301,12 @@ struct crush_map {
 
 	__u32 *choose_tries;
 #else
+	/* device/bucket type id -> type name (CrushWrapper::type_map) */
+	struct rb_root type_names;
+
+	/* device/bucket id -> name (CrushWrapper::name_map) */
+	struct rb_root names;
+
 	/* CrushWrapper::choose_args */
 	struct rb_root choose_args;
 #endif
@@ -342,4 +348,10 @@ struct crush_work {
 	struct crush_work_bucket **work; /* Per-bucket working store */
 };
 
+#ifdef __KERNEL__
+/* osdmap.c */
+void clear_crush_names(struct rb_root *root);
+void clear_choose_args(struct crush_map *c);
+#endif
+
 #endif

commit 53ab8e7cd2d47594e68951994ac083d30f82fce4
Author: Gustavo A. R. Silva <gustavoars@kernel.org>
Date:   Thu May 7 13:51:38 2020 -0500

    libceph, rbd: replace zero-length array with flexible-array
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    sizeof(flexible-array-member) triggers a warning because flexible array
    members have incomplete type[1]. There are some instances of code in
    which the sizeof operator is being incorrectly/erroneously applied to
    zero-length arrays and the result is zero. Such instances may be hiding
    some bugs. So, this work (flexible-array member conversions) will also
    help to get completely rid of those sorts of issues.
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>
    Reviewed-by: Ilya Dryomov <idryomov@gmail.com>
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 54741295c70b..38b0e4d50ed9 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -87,7 +87,7 @@ struct crush_rule_mask {
 struct crush_rule {
 	__u32 len;
 	struct crush_rule_mask mask;
-	struct crush_rule_step steps[0];
+	struct crush_rule_step steps[];
 };
 
 #define crush_rule_size(len) (sizeof(struct crush_rule) + \

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 07eed95e10c7..54741295c70b 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef CEPH_CRUSH_CRUSH_H
 #define CEPH_CRUSH_CRUSH_H
 

commit e17e8969f5c59a10083af5e260bdad6026872203
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Mon Jul 24 16:43:49 2017 +0200

    libceph: fallback for when there isn't a pool-specific choose_arg
    
    There is now a fallback to a choose_arg index of -1 if there isn't
    a pool-specific choose_arg set.  If you create a per-pool weight-set,
    that works for that pool.  Otherwise we try the compat/default one.  If
    that doesn't exist either, then we use the normal CRUSH weights.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
    Reviewed-by: Sage Weil <sage@redhat.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 92e165d417a6..07eed95e10c7 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -193,7 +193,7 @@ struct crush_choose_arg {
 struct crush_choose_arg_map {
 #ifdef __KERNEL__
 	struct rb_node node;
-	u64 choose_args_index;
+	s64 choose_args_index;
 #endif
 	struct crush_choose_arg *args; /*!< replacement for each bucket
                                             in the crushmap */

commit 5cf9c4a9959b6273675310d14a834ef14fbca37c
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Thu Jun 22 19:44:05 2017 +0200

    libceph, crush: per-pool crush_choose_arg_map for crush_do_rule()
    
    If there is no crush_choose_arg_map for a given pool, a NULL pointer is
    passed to preserve existing crush_do_rule() behavior.
    
    Reflects ceph.git commits 55fb91d64071552ea1bc65ab4ea84d3c8b73ab4b,
                              dbe36e08be00c6519a8c89718dd47b0219c20516.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index d8676e56fa23..92e165d417a6 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -2,6 +2,7 @@
 #define CEPH_CRUSH_CRUSH_H
 
 #ifdef __KERNEL__
+# include <linux/rbtree.h>
 # include <linux/types.h>
 #else
 # include "crush_compat.h"
@@ -190,6 +191,10 @@ struct crush_choose_arg {
  *
  */
 struct crush_choose_arg_map {
+#ifdef __KERNEL__
+	struct rb_node node;
+	u64 choose_args_index;
+#endif
 	struct crush_choose_arg *args; /*!< replacement for each bucket
                                             in the crushmap */
 	__u32 size;                    /*!< size of the __args__ array */
@@ -294,6 +299,9 @@ struct crush_map {
 	__u32 allowed_bucket_algs;
 
 	__u32 *choose_tries;
+#else
+	/* CrushWrapper::choose_args */
+	struct rb_root choose_args;
 #endif
 };
 

commit 069f3222ca96acfe8c59937e98c401bda5475b48
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Thu Jun 22 19:44:05 2017 +0200

    crush: implement weight and id overrides for straw2
    
    bucket_straw2_choose needs to use weights that may be different from
    weight_items. For instance to compensate for an uneven distribution
    caused by a low number of values. Or to fix the probability biais
    introduced by conditional probabilities (see
    http://tracker.ceph.com/issues/15653 for more information).
    
    We introduce a weight_set for each straw2 bucket to set the desired
    weight for a given item at a given position. The weight of a given item
    when picking the first replica (first position) may be different from
    the weight the second replica (second position). For instance the weight
    matrix for a given bucket containing items 3, 7 and 13 could be as
    follows:
    
              position 0   position 1
    
    item 3     0x10000      0x100000
    item 7     0x40000       0x10000
    item 13    0x40000       0x10000
    
    When crush_do_rule picks the first of two replicas (position 0), item 7,
    3 are four times more likely to be choosen by bucket_straw2_choose than
    item 13. When choosing the second replica (position 1), item 3 is ten
    times more likely to be choosen than item 7, 13.
    
    By default the weight_set of each bucket exactly matches the content of
    item_weights for each position to ensure backward compatibility.
    
    bucket_straw2_choose compares items by using their id. The same ids are
    also used to index buckets and they must be unique. For each item in a
    bucket an array of ids can be provided for placement purposes and they
    are used instead of the ids. If no replacement ids are provided, the
    legacy behavior is preserved.
    
    Reflects ceph.git commit 19537a450fd5c5a0bb8b7830947507a76db2ceca.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index fbecbd089d75..d8676e56fa23 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -137,6 +137,64 @@ struct crush_bucket {
 
 };
 
+/** @ingroup API
+ *
+ * Replacement weights for each item in a bucket. The size of the
+ * array must be exactly the size of the straw2 bucket, just as the
+ * item_weights array.
+ *
+ */
+struct crush_weight_set {
+	__u32 *weights; /*!< 16.16 fixed point weights
+                             in the same order as items */
+	__u32 size;     /*!< size of the __weights__ array */
+};
+
+/** @ingroup API
+ *
+ * Replacement weights and ids for a given straw2 bucket, for
+ * placement purposes.
+ *
+ * When crush_do_rule() chooses the Nth item from a straw2 bucket, the
+ * replacement weights found at __weight_set[N]__ are used instead of
+ * the weights from __item_weights__. If __N__ is greater than
+ * __weight_set_size__, the weights found at __weight_set_size-1__ are
+ * used instead. For instance if __weight_set__ is:
+ *
+ *    [ [ 0x10000, 0x20000 ],   // position 0
+ *      [ 0x20000, 0x40000 ] ]  // position 1
+ *
+ * choosing the 0th item will use position 0 weights [ 0x10000, 0x20000 ]
+ * choosing the 1th item will use position 1 weights [ 0x20000, 0x40000 ]
+ * choosing the 2th item will use position 1 weights [ 0x20000, 0x40000 ]
+ * etc.
+ *
+ */
+struct crush_choose_arg {
+	__s32 *ids;            /*!< values to use instead of items */
+	__u32 ids_size;        /*!< size of the __ids__ array */
+	struct crush_weight_set *weight_set; /*!< weight replacements for
+                                                  a given position */
+	__u32 weight_set_size; /*!< size of the __weight_set__ array */
+};
+
+/** @ingroup API
+ *
+ * Replacement weights and ids for each bucket in the crushmap. The
+ * __size__ of the __args__ array must be exactly the same as the
+ * __map->max_buckets__.
+ *
+ * The __crush_choose_arg__ at index N will be used when choosing
+ * an item from the bucket __map->buckets[N]__ bucket, provided it
+ * is a straw2 bucket.
+ *
+ */
+struct crush_choose_arg_map {
+	struct crush_choose_arg *args; /*!< replacement for each bucket
+                                            in the crushmap */
+	__u32 size;                    /*!< size of the __args__ array */
+};
+
 struct crush_bucket_uniform {
 	struct crush_bucket h;
 	__u32 item_weight;  /* 16-bit fixed point; all items equally weighted */

commit 66a0e2d579dbec5c676cfe446234ffebb267c564
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Tue Jan 31 15:55:06 2017 +0100

    crush: remove mutable part of CRUSH map
    
    Then add it to the working state. It would be very nice if we didn't
    have to take a lock to calculate a crush placement. By moving the
    permutation array into the working data, we can treat the CRUSH map as
    immutable.
    
    Reflects ceph.git commit cbcd039651c0569551cb90d26ce27e1432671f2a.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index be8f12b8f195..fbecbd089d75 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -135,13 +135,6 @@ struct crush_bucket {
 	__u32 size;      /* num items */
 	__s32 *items;
 
-	/*
-	 * cached random permutation: used for uniform bucket and for
-	 * the linear search fallback for the other bucket types.
-	 */
-	__u32 perm_x;  /* @x for which *perm is defined */
-	__u32 perm_n;  /* num elements of *perm that are permuted/defined */
-	__u32 *perm;
 };
 
 struct crush_bucket_uniform {
@@ -211,6 +204,21 @@ struct crush_map {
 	 * device fails. */
 	__u8 chooseleaf_stable;
 
+	/*
+	 * This value is calculated after decode or construction by
+	 * the builder. It is exposed here (rather than having a
+	 * 'build CRUSH working space' function) so that callers can
+	 * reserve a static buffer, allocate space on the stack, or
+	 * otherwise avoid calling into the heap allocator if they
+	 * want to. The size of the working space depends on the map,
+	 * while the size of the scratch vector passed to the mapper
+	 * depends on the size of the desired result set.
+	 *
+	 * Nothing stops the caller from allocating both in one swell
+	 * foop and passing in two points, though.
+	 */
+	size_t working_size;
+
 #ifndef __KERNEL__
 	/*
 	 * version 0 (original) of straw_calc has various flaws.  version 1
@@ -248,4 +256,23 @@ static inline int crush_calc_tree_node(int i)
 	return ((i+1) << 1)-1;
 }
 
+/*
+ * These data structures are private to the CRUSH implementation. They
+ * are exposed in this header file because builder needs their
+ * definitions to calculate the total working size.
+ *
+ * Moving this out of the crush map allow us to treat the CRUSH map as
+ * immutable within the mapper and removes the requirement for a CRUSH
+ * map lock.
+ */
+struct crush_work_bucket {
+	__u32 perm_x; /* @x for which *perm is defined */
+	__u32 perm_n; /* num elements of *perm that are permuted/defined */
+	__u32 *perm;  /* Permutation of the bucket's items */
+};
+
+struct crush_work {
+	struct crush_work_bucket **work; /* Per-bucket working store */
+};
+
 #endif

commit dc6ae6d8e7726bad4f1c87244b49cac851746c65
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Sun Jan 31 14:36:07 2016 +0100

    crush: add chooseleaf_stable tunable
    
    Add a tunable to fix the bug that chooseleaf may cause unnecessary pg
    migrations when some device fails.
    
    Reflects ceph.git commit fdb3f664448e80d984470f32f04e2e6f03ab52ec.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
    Reviewed-by: Sage Weil <sage@redhat.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 48b49305716b..be8f12b8f195 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -59,7 +59,8 @@ enum {
 	CRUSH_RULE_SET_CHOOSELEAF_TRIES = 9, /* override chooseleaf_descend_once */
 	CRUSH_RULE_SET_CHOOSE_LOCAL_TRIES = 10,
 	CRUSH_RULE_SET_CHOOSE_LOCAL_FALLBACK_TRIES = 11,
-	CRUSH_RULE_SET_CHOOSELEAF_VARY_R = 12
+	CRUSH_RULE_SET_CHOOSELEAF_VARY_R = 12,
+	CRUSH_RULE_SET_CHOOSELEAF_STABLE = 13
 };
 
 /*
@@ -205,6 +206,11 @@ struct crush_map {
 	 * mappings line up a bit better with previous mappings. */
 	__u8 chooseleaf_vary_r;
 
+	/* if true, it makes chooseleaf firstn to return stable results (if
+	 * no local retry) so that data migrations would be optimal when some
+	 * device fails. */
+	__u8 chooseleaf_stable;
+
 #ifndef __KERNEL__
 	/*
 	 * version 0 (original) of straw_calc has various flaws.  version 1

commit b459be739f97e2062b2ba77cfe8ea198dbd58904
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Fri Jun 12 13:21:07 2015 +0300

    crush: sync up with userspace
    
    .. up to ceph.git commit 1db1abc8328d ("crush: eliminate ad hoc diff
    between kernel and userspace").  This fixes a bunch of recently pulled
    coding style issues and makes includes a bit cleaner.
    
    A patch "crush:Make the function crush_ln static" from Nicholas Krause
    <xerofoify@gmail.com> is folded in as crush_ln() has been made static
    in userspace as well.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 48a1a7d100f1..48b49305716b 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -1,7 +1,11 @@
 #ifndef CEPH_CRUSH_CRUSH_H
 #define CEPH_CRUSH_CRUSH_H
 
-#include <linux/types.h>
+#ifdef __KERNEL__
+# include <linux/types.h>
+#else
+# include "crush_compat.h"
+#endif
 
 /*
  * CRUSH is a pseudo-random data distribution algorithm that
@@ -20,7 +24,11 @@
 #define CRUSH_MAGIC 0x00010000ul   /* for detecting algorithm revisions */
 
 #define CRUSH_MAX_DEPTH 10  /* max crush hierarchy depth */
+#define CRUSH_MAX_RULESET (1<<8)  /* max crush ruleset number */
+#define CRUSH_MAX_RULES CRUSH_MAX_RULESET  /* should be the same as max rulesets */
 
+#define CRUSH_MAX_DEVICE_WEIGHT (100u * 0x10000u)
+#define CRUSH_MAX_BUCKET_WEIGHT (65535u * 0x10000u)
 
 #define CRUSH_ITEM_UNDEF  0x7ffffffe  /* undefined result (internal use only) */
 #define CRUSH_ITEM_NONE   0x7fffffff  /* no result */
@@ -108,6 +116,15 @@ enum {
 };
 extern const char *crush_bucket_alg_name(int alg);
 
+/*
+ * although tree was a legacy algorithm, it has been buggy, so
+ * exclude it.
+ */
+#define CRUSH_LEGACY_ALLOWED_BUCKET_ALGS (	\
+		(1 << CRUSH_BUCKET_UNIFORM) |	\
+		(1 << CRUSH_BUCKET_LIST) |	\
+		(1 << CRUSH_BUCKET_STRAW))
+
 struct crush_bucket {
 	__s32 id;        /* this'll be negative */
 	__u16 type;      /* non-zero; type=0 is reserved for devices */
@@ -174,7 +191,7 @@ struct crush_map {
 	/* choose local attempts using a fallback permutation before
 	 * re-descent */
 	__u32 choose_local_fallback_tries;
-	/* choose attempts before giving up */ 
+	/* choose attempts before giving up */
 	__u32 choose_total_tries;
 	/* attempt chooseleaf inner descent once for firstn mode; on
 	 * reject retry outer descent.  Note that this does *not*
@@ -187,6 +204,25 @@ struct crush_map {
 	 * that want to limit reshuffling, a value of 3 or 4 will make the
 	 * mappings line up a bit better with previous mappings. */
 	__u8 chooseleaf_vary_r;
+
+#ifndef __KERNEL__
+	/*
+	 * version 0 (original) of straw_calc has various flaws.  version 1
+	 * fixes a few of them.
+	 */
+	__u8 straw_calc_version;
+
+	/*
+	 * allowed bucket algs is a bitmask, here the bit positions
+	 * are CRUSH_BUCKET_*.  note that these are *bits* and
+	 * CRUSH_BUCKET_* values are not, so we need to or together (1
+	 * << CRUSH_BUCKET_WHATEVER).  The 0th bit is not used to
+	 * minimize confusion (bucket type values start at 1).
+	 */
+	__u32 allowed_bucket_algs;
+
+	__u32 *choose_tries;
+#endif
 };
 
 

commit 958a27658d94cf212caeb0ffb04ee0b0bc89cc40
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Tue Apr 14 16:54:52 2015 +0300

    crush: straw2 bucket type with an efficient 64-bit crush_ln()
    
    This is an improved straw bucket that correctly avoids any data movement
    between items A and B when neither A nor B's weights are changed.  Said
    differently, if we adjust the weight of item C (including adding it anew
    or removing it completely), we will only see inputs move to or from C,
    never between other items in the bucket.
    
    Notably, there is not intermediate scaling factor that needs to be
    calculated.  The mapping function is a simple function of the item weights.
    
    The below commits were squashed together into this one (mostly to avoid
    adding and then yanking a ~6000 lines worth of crush_ln_table):
    
    - crush: add a straw2 bucket type
    - crush: add crush_ln to calculate nature log efficently
    - crush: improve straw2 adjustment slightly
    - crush: change crush_ln to provide 32 more digits
    - crush: fix crush_get_bucket_item_weight and bucket destroy for straw2
    - crush/mapper: fix divide-by-0 in straw2
      (with div64_s64() for draw = ln / w and INT64_MIN -> S64_MIN - need
       to create a proper compat.h in ceph.git)
    
    Reflects ceph.git commits 242293c908e923d474910f2b8203fa3b41eb5a53,
                              32a1ead92efcd351822d22a5fc37d159c65c1338,
                              6289912418c4a3597a11778bcf29ed5415117ad9,
                              35fcb04e2945717cf5cfe150b9fa89cb3d2303a1,
                              6445d9ee7290938de1e4ee9563912a6ab6d8ee5f,
                              b5921d55d16796e12d66ad2c4add7305f9ce2353.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 4fad5f8ee01d..48a1a7d100f1 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -96,13 +96,15 @@ struct crush_rule {
  *  uniform         O(1)       poor         poor
  *  list            O(n)       optimal      poor
  *  tree            O(log n)   good         good
- *  straw           O(n)       optimal      optimal
+ *  straw           O(n)       better       better
+ *  straw2          O(n)       optimal      optimal
  */
 enum {
 	CRUSH_BUCKET_UNIFORM = 1,
 	CRUSH_BUCKET_LIST = 2,
 	CRUSH_BUCKET_TREE = 3,
-	CRUSH_BUCKET_STRAW = 4
+	CRUSH_BUCKET_STRAW = 4,
+	CRUSH_BUCKET_STRAW2 = 5,
 };
 extern const char *crush_bucket_alg_name(int alg);
 
@@ -149,6 +151,11 @@ struct crush_bucket_straw {
 	__u32 *straws;         /* 16-bit fixed point */
 };
 
+struct crush_bucket_straw2 {
+	struct crush_bucket h;
+	__u32 *item_weights;   /* 16-bit fixed point */
+};
+
 
 
 /*
@@ -189,6 +196,7 @@ extern void crush_destroy_bucket_uniform(struct crush_bucket_uniform *b);
 extern void crush_destroy_bucket_list(struct crush_bucket_list *b);
 extern void crush_destroy_bucket_tree(struct crush_bucket_tree *b);
 extern void crush_destroy_bucket_straw(struct crush_bucket_straw *b);
+extern void crush_destroy_bucket_straw2(struct crush_bucket_straw2 *b);
 extern void crush_destroy_bucket(struct crush_bucket *b);
 extern void crush_destroy_rule(struct crush_rule *r);
 extern void crush_destroy(struct crush_map *map);

commit d83ed858f144e3cfbef883d4bc499113cdddabeb
Author: Ilya Dryomov <ilya.dryomov@inktank.com>
Date:   Wed Mar 19 16:58:37 2014 +0200

    crush: add SET_CHOOSELEAF_VARY_R step
    
    This lets you adjust the vary_r tunable on a per-rule basis.
    
    Reflects ceph.git commit f944ccc20aee60a7d8da7e405ec75ad1cd449fac.
    
    Signed-off-by: Ilya Dryomov <ilya.dryomov@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 75f36a6c7f67..4fad5f8ee01d 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -51,6 +51,7 @@ enum {
 	CRUSH_RULE_SET_CHOOSELEAF_TRIES = 9, /* override chooseleaf_descend_once */
 	CRUSH_RULE_SET_CHOOSE_LOCAL_TRIES = 10,
 	CRUSH_RULE_SET_CHOOSE_LOCAL_FALLBACK_TRIES = 11,
+	CRUSH_RULE_SET_CHOOSELEAF_VARY_R = 12
 };
 
 /*

commit e2b149cc4ba00766aceb87950c6de72ea7fc8b2e
Author: Ilya Dryomov <ilya.dryomov@inktank.com>
Date:   Wed Mar 19 16:58:37 2014 +0200

    crush: add chooseleaf_vary_r tunable
    
    The current crush_choose_firstn code will re-use the same 'r' value for
    the recursive call.  That means that if we are hitting a collision or
    rejection for some reason (say, an OSD that is marked out) and need to
    retry, we will keep making the same (bad) choice in that recursive
    selection.
    
    Introduce a tunable that fixes that behavior by incorporating the parent
    'r' value into the recursive starting point, so that a different path
    will be taken in subsequent placement attempts.
    
    Note that this was done from the get-go for the new crush_choose_indep
    algorithm.
    
    This was exposed by a user who was seeing PGs stuck in active+remapped
    after reweight-by-utilization because the up set mapped to a single OSD.
    
    Reflects ceph.git commit a8e6c9fbf88bad056dd05d3eb790e98a5e43451a.
    
    Signed-off-by: Ilya Dryomov <ilya.dryomov@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index acaa5615d634..75f36a6c7f67 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -173,6 +173,12 @@ struct crush_map {
 	 * apply to a collision: in that case we will retry as we used
 	 * to. */
 	__u32 chooseleaf_descend_once;
+
+	/* if non-zero, feed r into chooseleaf, bit-shifted right by (r-1)
+	 * bits.  a value of 1 is best for new clusters.  for legacy clusters
+	 * that want to limit reshuffling, a value of 3 or 4 will make the
+	 * mappings line up a bit better with previous mappings. */
+	__u8 chooseleaf_vary_r;
 };
 
 

commit f046bf92080cbdc4a94c6e86698c5a3f10716445
Author: Ilya Dryomov <ilya.dryomov@inktank.com>
Date:   Tue Dec 24 21:19:27 2013 +0200

    crush: add set_choose_local_[fallback_]tries steps
    
    This allows all of the tunables to be overridden by a specific rule.
    
    Reflects ceph.git commits d129e09e57fbc61cfd4f492e3ee77d0750c9d292,
                              0497db49e5973b50df26251ed0e3f4ac7578e66e.
    
    Signed-off-by: Ilya Dryomov <ilya.dryomov@inktank.com>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 7b0fc4aba75b..acaa5615d634 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -49,6 +49,8 @@ enum {
 
 	CRUSH_RULE_SET_CHOOSE_TRIES = 8, /* override choose_total_tries */
 	CRUSH_RULE_SET_CHOOSELEAF_TRIES = 9, /* override chooseleaf_descend_once */
+	CRUSH_RULE_SET_CHOOSE_LOCAL_TRIES = 10,
+	CRUSH_RULE_SET_CHOOSE_LOCAL_FALLBACK_TRIES = 11,
 };
 
 /*

commit 917edad5d1d62070436b74ecbf5ea019b651ff69
Author: Ilya Dryomov <ilya.dryomov@inktank.com>
Date:   Tue Dec 24 21:19:26 2013 +0200

    crush: CHOOSE_LEAF -> CHOOSELEAF throughout
    
    This aligns the internal identifier names with the user-visible names in
    the decompiled crush map language.
    
    Reflects ceph.git commit caa0e22e15e4226c3671318ba1f61314bf6da2a6.
    
    Signed-off-by: Ilya Dryomov <ilya.dryomov@inktank.com>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 5f95969347ec..7b0fc4aba75b 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -44,11 +44,11 @@ enum {
 				      /* arg2 = type */
 	CRUSH_RULE_CHOOSE_INDEP = 3,  /* same */
 	CRUSH_RULE_EMIT = 4,          /* no args */
-	CRUSH_RULE_CHOOSE_LEAF_FIRSTN = 6,
-	CRUSH_RULE_CHOOSE_LEAF_INDEP = 7,
+	CRUSH_RULE_CHOOSELEAF_FIRSTN = 6,
+	CRUSH_RULE_CHOOSELEAF_INDEP = 7,
 
 	CRUSH_RULE_SET_CHOOSE_TRIES = 8, /* override choose_total_tries */
-	CRUSH_RULE_SET_CHOOSE_LEAF_TRIES = 9, /* override chooseleaf_descend_once */
+	CRUSH_RULE_SET_CHOOSELEAF_TRIES = 9, /* override chooseleaf_descend_once */
 };
 
 /*

commit cc10df4a3a5c34cb1d5b635ac70dd1fc406153ce
Author: Ilya Dryomov <ilya.dryomov@inktank.com>
Date:   Tue Dec 24 21:19:26 2013 +0200

    crush: add SET_CHOOSE_TRIES rule step
    
    Since we can specify the recursive retries in a rule, we may as well also
    specify the non-recursive tries too for completeness.
    
    Reflects ceph.git commit d1b97462cffccc871914859eaee562f2786abfd1.
    
    Signed-off-by: Ilya Dryomov <ilya.dryomov@inktank.com>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 07b8fd4f81fc..5f95969347ec 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -47,7 +47,8 @@ enum {
 	CRUSH_RULE_CHOOSE_LEAF_FIRSTN = 6,
 	CRUSH_RULE_CHOOSE_LEAF_INDEP = 7,
 
-	CRUSH_RULE_SET_CHOOSE_LEAF_TRIES = 9,
+	CRUSH_RULE_SET_CHOOSE_TRIES = 8, /* override choose_total_tries */
+	CRUSH_RULE_SET_CHOOSE_LEAF_TRIES = 9, /* override chooseleaf_descend_once */
 };
 
 /*

commit f18650ace38ef200dd1578257c75e9407297953c
Author: Ilya Dryomov <ilya.dryomov@inktank.com>
Date:   Tue Dec 24 21:19:26 2013 +0200

    crush: apply chooseleaf_tries to firstn mode too
    
    Parameterize the attempts for the _firstn choose method, and apply the
    rule-specified tries count to firstn mode as well.  Note that we have
    slightly different behavior here than with indep:
    
     If the firstn value is not specified for firstn, we pass through the
     normal attempt count.  This maintains compatibility with legacy behavior.
     Note that this is usually *not* actually N^2 work, though, because of the
     descend_once tunable.  However, descend_once is unfortunately *not* the
     same thing as 1 chooseleaf try because it is only checked on a reject but
     not on a collision.  Sigh.
    
     In contrast, for indep, if tries is not specified we default to 1
     recursive attempt, because that is simply more sane, and we have the
     option to do so.  The descend_once tunable has no effect for indep.
    
    Reflects ceph.git commit 64aeded50d80942d66a5ec7b604ff2fcbf5d7b63.
    
    Signed-off-by: Ilya Dryomov <ilya.dryomov@inktank.com>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 2e50bab91655..07b8fd4f81fc 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -165,7 +165,10 @@ struct crush_map {
 	__u32 choose_local_fallback_tries;
 	/* choose attempts before giving up */ 
 	__u32 choose_total_tries;
-	/* attempt chooseleaf inner descent once; on failure retry outer descent */
+	/* attempt chooseleaf inner descent once for firstn mode; on
+	 * reject retry outer descent.  Note that this does *not*
+	 * apply to a collision: in that case we will retry as we used
+	 * to. */
 	__u32 chooseleaf_descend_once;
 };
 

commit be3226acc5544bcc91e756eb3ee6ca7b74f6f0a8
Author: Ilya Dryomov <ilya.dryomov@inktank.com>
Date:   Tue Dec 24 21:19:26 2013 +0200

    crush: new SET_CHOOSE_LEAF_TRIES command
    
    Explicitly control the number of sample attempts, and allow the number of
    tries in the recursive call to be explicitly controlled via the rule. This
    is important because the amount of time we want to spend looking for a
    solution may be rule dependent (e.g., higher for the wide indep pool than
    the rep pools).
    
    (We should do the same for the other tunables, by the way!)
    
    Reflects ceph.git commit c43c893be872f709c787bc57f46c0e97876ff681.
    
    Signed-off-by: Ilya Dryomov <ilya.dryomov@inktank.com>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 4023b1b52296..2e50bab91655 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -46,6 +46,8 @@ enum {
 	CRUSH_RULE_EMIT = 4,          /* no args */
 	CRUSH_RULE_CHOOSE_LEAF_FIRSTN = 6,
 	CRUSH_RULE_CHOOSE_LEAF_INDEP = 7,
+
+	CRUSH_RULE_SET_CHOOSE_LEAF_TRIES = 9,
 };
 
 /*

commit 9a3b490a20e06368c81d7a81506e99388e733379
Author: Ilya Dryomov <ilya.dryomov@inktank.com>
Date:   Tue Dec 24 21:19:25 2013 +0200

    crush: use breadth-first search for indep mode
    
    Reflects ceph.git commit 86e978036a4ecbac4c875e7c00f6c5bbe37282d3.
    
    Signed-off-by: Ilya Dryomov <ilya.dryomov@inktank.com>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 3d6a12928560..4023b1b52296 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -22,7 +22,8 @@
 #define CRUSH_MAX_DEPTH 10  /* max crush hierarchy depth */
 
 
-#define CRUSH_ITEM_UNDEF  0x7fffffff  /* undefined result */
+#define CRUSH_ITEM_UNDEF  0x7ffffffe  /* undefined result (internal use only) */
+#define CRUSH_ITEM_NONE   0x7fffffff  /* no result */
 
 /*
  * CRUSH uses user-defined "rules" to describe how inputs should be

commit c6d98a603a02594f6ecf16d0a0af989ae9fa7abd
Author: Ilya Dryomov <ilya.dryomov@inktank.com>
Date:   Tue Dec 24 21:19:25 2013 +0200

    crush: return CRUSH_ITEM_UNDEF for failed placements with indep
    
    For firstn mode, if we fail to make a valid placement choice, we just
    continue and return a short result to the caller.  For indep mode, however,
    we need to make the position stable, and return an undefined value on
    failed placements to avoid shifting later results to the left.
    
    Reflects ceph.git commit b1d4dd4eb044875874a1d01c01c7d766db5d0a80.
    
    Signed-off-by: Ilya Dryomov <ilya.dryomov@inktank.com>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 83543c504b5a..3d6a12928560 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -19,10 +19,11 @@
 
 #define CRUSH_MAGIC 0x00010000ul   /* for detecting algorithm revisions */
 
-
 #define CRUSH_MAX_DEPTH 10  /* max crush hierarchy depth */
 
 
+#define CRUSH_ITEM_UNDEF  0x7fffffff  /* undefined result */
+
 /*
  * CRUSH uses user-defined "rules" to describe how inputs should be
  * mapped to devices.  A rule consists of sequence of steps to perform

commit e8ef19c4ad161768e1d8309d5ae18481c098eb81
Author: Ilya Dryomov <ilya.dryomov@inktank.com>
Date:   Tue Dec 24 21:19:24 2013 +0200

    crush: eliminate CRUSH_MAX_SET result size limitation
    
    This is only present to size the temporary scratch arrays that we put on
    the stack.  Let the caller allocate them as they wish and remove the
    limitation.
    
    Reflects ceph.git commit 1cfe140bf2dab99517589a82a916f4c75b9492d1.
    
    Signed-off-by: Ilya Dryomov <ilya.dryomov@inktank.com>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 09561a04c127..83543c504b5a 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -21,7 +21,6 @@
 
 
 #define CRUSH_MAX_DEPTH 10  /* max crush hierarchy depth */
-#define CRUSH_MAX_SET   10  /* max size of a mapping result */
 
 
 /*

commit bfb16d7d69f0272451ad85a6e50aab3c4262fbc0
Author: Ilya Dryomov <ilya.dryomov@inktank.com>
Date:   Tue Dec 24 21:19:24 2013 +0200

    crush: factor out (trivial) crush_destroy_rule()
    
    Reflects ceph.git commit 43a01c9973c4b83f2eaa98be87429941a227ddde.
    
    Signed-off-by: Ilya Dryomov <ilya.dryomov@inktank.com>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 6a1101f24cfb..09561a04c127 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -174,6 +174,7 @@ extern void crush_destroy_bucket_list(struct crush_bucket_list *b);
 extern void crush_destroy_bucket_tree(struct crush_bucket_tree *b);
 extern void crush_destroy_bucket_straw(struct crush_bucket_straw *b);
 extern void crush_destroy_bucket(struct crush_bucket *b);
+extern void crush_destroy_rule(struct crush_rule *r);
 extern void crush_destroy(struct crush_map *map);
 
 static inline int crush_calc_tree_node(int i)

commit 1604f488ac2dcce33c8218e75a000e8c5fb57e61
Author: Jim Schutt <jaschut@sandia.gov>
Date:   Fri Nov 30 09:15:25 2012 -0700

    libceph: for chooseleaf rules, retry CRUSH map descent from root if leaf is failed
    
    Add libceph support for a new CRUSH tunable recently added to Ceph servers.
    
    Consider the CRUSH rule
      step chooseleaf firstn 0 type <node_type>
    
    This rule means that <n> replicas will be chosen in a manner such that
    each chosen leaf's branch will contain a unique instance of <node_type>.
    
    When an object is re-replicated after a leaf failure, if the CRUSH map uses
    a chooseleaf rule the remapped replica ends up under the <node_type> bucket
    that held the failed leaf.  This causes uneven data distribution across the
    storage cluster, to the point that when all the leaves but one fail under a
    particular <node_type> bucket, that remaining leaf holds all the data from
    its failed peers.
    
    This behavior also limits the number of peers that can participate in the
    re-replication of the data held by the failed leaf, which increases the
    time required to re-replicate after a failure.
    
    For a chooseleaf CRUSH rule, the tree descent has two steps: call them the
    inner and outer descents.
    
    If the tree descent down to <node_type> is the outer descent, and the descent
    from <node_type> down to a leaf is the inner descent, the issue is that a
    down leaf is detected on the inner descent, so only the inner descent is
    retried.
    
    In order to disperse re-replicated data as widely as possible across a
    storage cluster after a failure, we want to retry the outer descent. So,
    fix up crush_choose() to allow the inner descent to return immediately on
    choosing a failed leaf.  Wire this up as a new CRUSH tunable.
    
    Note that after this change, for a chooseleaf rule, if the primary OSD
    in a placement group has failed, choosing a replacement may result in
    one of the other OSDs in the PG colliding with the new primary.  This
    requires that OSD's data for that PG to need moving as well.  This
    seems unavoidable but should be relatively rare.
    
    This corresponds to ceph.git commit 88f218181a9e6d2292e2697fc93797d0f6d6e5dc.
    
    Signed-off-by: Jim Schutt <jaschut@sandia.gov>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 25baa287cff7..6a1101f24cfb 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -162,6 +162,8 @@ struct crush_map {
 	__u32 choose_local_fallback_tries;
 	/* choose attempts before giving up */ 
 	__u32 choose_total_tries;
+	/* attempt chooseleaf inner descent once; on failure retry outer descent */
+	__u32 chooseleaf_descend_once;
 };
 
 

commit 546f04ef716dd49521774653d8b032a7d64c05d9
Author: Sage Weil <sage@inktank.com>
Date:   Mon Jul 30 18:15:23 2012 -0700

    libceph: support crush tunables
    
    The server side recently added support for tuning some magic
    crush variables. Decode these variables if they are present, or use the
    default values if they are not present.
    
    Corresponds to ceph.git commit 89af369c25f274fe62ef730e5e8aad0c54f1e5a5.
    
    Signed-off-by: caleb miles <caleb.miles@inktank.com>
    Reviewed-by: Sage Weil <sage@inktank.com>
    Reviewed-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Yehuda Sadeh <yehuda@inktank.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 7c4750811b96..25baa287cff7 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -154,6 +154,14 @@ struct crush_map {
 	__s32 max_buckets;
 	__u32 max_rules;
 	__s32 max_devices;
+
+	/* choose local retries before re-descent */
+	__u32 choose_local_tries;
+	/* choose local attempts using a fallback permutation before
+	 * re-descent */
+	__u32 choose_local_fallback_tries;
+	/* choose attempts before giving up */ 
+	__u32 choose_total_tries;
 };
 
 

commit f671d4cd9b36691ac4ef42cde44c1b7a84e13631
Author: Sage Weil <sage@inktank.com>
Date:   Mon May 7 15:36:49 2012 -0700

    crush: fix tree node weight lookup
    
    Fix the node weight lookup for tree buckets by using a correct accessor.
    
    Reflects ceph.git commit d287ade5bcbdca82a3aef145b92924cf1e856733.
    
    Reviewed-by: Alex Elder <elder@inktank.com>
    Signed-off-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 158a4d25ca83..7c4750811b96 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -166,4 +166,9 @@ extern void crush_destroy_bucket_straw(struct crush_bucket_straw *b);
 extern void crush_destroy_bucket(struct crush_bucket *b);
 extern void crush_destroy(struct crush_map *map);
 
+static inline int crush_calc_tree_node(int i)
+{
+	return ((i+1) << 1)-1;
+}
+
 #endif

commit fc7c3ae5ab9246ad96aab4d0d57f67e9255cfb56
Author: Sage Weil <sage@inktank.com>
Date:   Mon May 7 15:36:35 2012 -0700

    crush: remove parent maps
    
    These were used for the ill-fated forcefeed feature.  Remove them.
    
    Reflects ceph.git commit ebdf80edfecfbd5a842b71fbe5732857994380c1.
    
    Reviewed-by: Alex Elder <elder@inktank.com>
    Signed-off-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 3f50369a50e8..158a4d25ca83 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -151,16 +151,6 @@ struct crush_map {
 	struct crush_bucket **buckets;
 	struct crush_rule **rules;
 
-	/*
-	 * Parent pointers to identify the parent bucket a device or
-	 * bucket in the hierarchy.  If an item appears more than
-	 * once, this is the _last_ time it appeared (where buckets
-	 * are processed in bucket id order, from -1 on down to
-	 * -max_buckets.
-	 */
-	__u32 *bucket_parents;
-	__u32 *device_parents;
-
 	__s32 max_buckets;
 	__u32 max_rules;
 	__s32 max_devices;
@@ -169,7 +159,6 @@ struct crush_map {
 
 /* crush.c */
 extern int crush_get_bucket_item_weight(const struct crush_bucket *b, int pos);
-extern void crush_calc_parents(struct crush_map *map);
 extern void crush_destroy_bucket_uniform(struct crush_bucket_uniform *b);
 extern void crush_destroy_bucket_list(struct crush_bucket_list *b);
 extern void crush_destroy_bucket_tree(struct crush_bucket_tree *b);

commit 8b12d47b80c7a34dffdd98244d99316db490ec58
Author: Sage Weil <sage@inktank.com>
Date:   Mon May 7 15:38:35 2012 -0700

    crush: clean up types, const-ness
    
    Move various types from int -> __u32 (or similar), and add const as
    appropriate.
    
    This reflects changes that have been present in the userland implementation
    for some time.
    
    Reviewed-by: Alex Elder <elder@inktank.com>
    Signed-off-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
index 97e435b191f4..3f50369a50e8 100644
--- a/include/linux/crush/crush.h
+++ b/include/linux/crush/crush.h
@@ -168,7 +168,7 @@ struct crush_map {
 
 
 /* crush.c */
-extern int crush_get_bucket_item_weight(struct crush_bucket *b, int pos);
+extern int crush_get_bucket_item_weight(const struct crush_bucket *b, int pos);
 extern void crush_calc_parents(struct crush_map *map);
 extern void crush_destroy_bucket_uniform(struct crush_bucket_uniform *b);
 extern void crush_destroy_bucket_list(struct crush_bucket_list *b);

commit 3d14c5d2b6e15c21d8e5467dc62d33127c23a644
Author: Yehuda Sadeh <yehuda@hq.newdream.net>
Date:   Tue Apr 6 15:14:15 2010 -0700

    ceph: factor out libceph from Ceph file system
    
    This factors out protocol and low-level storage parts of ceph into a
    separate libceph module living in net/ceph and include/linux/ceph.  This
    is mostly a matter of moving files around.  However, a few key pieces
    of the interface change as well:
    
     - ceph_client becomes ceph_fs_client and ceph_client, where the latter
       captures the mon and osd clients, and the fs_client gets the mds client
       and file system specific pieces.
     - Mount option parsing and debugfs setup is correspondingly broken into
       two pieces.
     - The mon client gets a generic handler callback for otherwise unknown
       messages (mds map, in this case).
     - The basic supported/required feature bits can be expanded (and are by
       ceph_fs_client).
    
    No functional change, aside from some subtle error handling cases that got
    cleaned up in the refactoring process.
    
    Signed-off-by: Sage Weil <sage@newdream.net>

diff --git a/include/linux/crush/crush.h b/include/linux/crush/crush.h
new file mode 100644
index 000000000000..97e435b191f4
--- /dev/null
+++ b/include/linux/crush/crush.h
@@ -0,0 +1,180 @@
+#ifndef CEPH_CRUSH_CRUSH_H
+#define CEPH_CRUSH_CRUSH_H
+
+#include <linux/types.h>
+
+/*
+ * CRUSH is a pseudo-random data distribution algorithm that
+ * efficiently distributes input values (typically, data objects)
+ * across a heterogeneous, structured storage cluster.
+ *
+ * The algorithm was originally described in detail in this paper
+ * (although the algorithm has evolved somewhat since then):
+ *
+ *     http://www.ssrc.ucsc.edu/Papers/weil-sc06.pdf
+ *
+ * LGPL2
+ */
+
+
+#define CRUSH_MAGIC 0x00010000ul   /* for detecting algorithm revisions */
+
+
+#define CRUSH_MAX_DEPTH 10  /* max crush hierarchy depth */
+#define CRUSH_MAX_SET   10  /* max size of a mapping result */
+
+
+/*
+ * CRUSH uses user-defined "rules" to describe how inputs should be
+ * mapped to devices.  A rule consists of sequence of steps to perform
+ * to generate the set of output devices.
+ */
+struct crush_rule_step {
+	__u32 op;
+	__s32 arg1;
+	__s32 arg2;
+};
+
+/* step op codes */
+enum {
+	CRUSH_RULE_NOOP = 0,
+	CRUSH_RULE_TAKE = 1,          /* arg1 = value to start with */
+	CRUSH_RULE_CHOOSE_FIRSTN = 2, /* arg1 = num items to pick */
+				      /* arg2 = type */
+	CRUSH_RULE_CHOOSE_INDEP = 3,  /* same */
+	CRUSH_RULE_EMIT = 4,          /* no args */
+	CRUSH_RULE_CHOOSE_LEAF_FIRSTN = 6,
+	CRUSH_RULE_CHOOSE_LEAF_INDEP = 7,
+};
+
+/*
+ * for specifying choose num (arg1) relative to the max parameter
+ * passed to do_rule
+ */
+#define CRUSH_CHOOSE_N            0
+#define CRUSH_CHOOSE_N_MINUS(x)   (-(x))
+
+/*
+ * The rule mask is used to describe what the rule is intended for.
+ * Given a ruleset and size of output set, we search through the
+ * rule list for a matching rule_mask.
+ */
+struct crush_rule_mask {
+	__u8 ruleset;
+	__u8 type;
+	__u8 min_size;
+	__u8 max_size;
+};
+
+struct crush_rule {
+	__u32 len;
+	struct crush_rule_mask mask;
+	struct crush_rule_step steps[0];
+};
+
+#define crush_rule_size(len) (sizeof(struct crush_rule) + \
+			      (len)*sizeof(struct crush_rule_step))
+
+
+
+/*
+ * A bucket is a named container of other items (either devices or
+ * other buckets).  Items within a bucket are chosen using one of a
+ * few different algorithms.  The table summarizes how the speed of
+ * each option measures up against mapping stability when items are
+ * added or removed.
+ *
+ *  Bucket Alg     Speed       Additions    Removals
+ *  ------------------------------------------------
+ *  uniform         O(1)       poor         poor
+ *  list            O(n)       optimal      poor
+ *  tree            O(log n)   good         good
+ *  straw           O(n)       optimal      optimal
+ */
+enum {
+	CRUSH_BUCKET_UNIFORM = 1,
+	CRUSH_BUCKET_LIST = 2,
+	CRUSH_BUCKET_TREE = 3,
+	CRUSH_BUCKET_STRAW = 4
+};
+extern const char *crush_bucket_alg_name(int alg);
+
+struct crush_bucket {
+	__s32 id;        /* this'll be negative */
+	__u16 type;      /* non-zero; type=0 is reserved for devices */
+	__u8 alg;        /* one of CRUSH_BUCKET_* */
+	__u8 hash;       /* which hash function to use, CRUSH_HASH_* */
+	__u32 weight;    /* 16-bit fixed point */
+	__u32 size;      /* num items */
+	__s32 *items;
+
+	/*
+	 * cached random permutation: used for uniform bucket and for
+	 * the linear search fallback for the other bucket types.
+	 */
+	__u32 perm_x;  /* @x for which *perm is defined */
+	__u32 perm_n;  /* num elements of *perm that are permuted/defined */
+	__u32 *perm;
+};
+
+struct crush_bucket_uniform {
+	struct crush_bucket h;
+	__u32 item_weight;  /* 16-bit fixed point; all items equally weighted */
+};
+
+struct crush_bucket_list {
+	struct crush_bucket h;
+	__u32 *item_weights;  /* 16-bit fixed point */
+	__u32 *sum_weights;   /* 16-bit fixed point.  element i is sum
+				 of weights 0..i, inclusive */
+};
+
+struct crush_bucket_tree {
+	struct crush_bucket h;  /* note: h.size is _tree_ size, not number of
+				   actual items */
+	__u8 num_nodes;
+	__u32 *node_weights;
+};
+
+struct crush_bucket_straw {
+	struct crush_bucket h;
+	__u32 *item_weights;   /* 16-bit fixed point */
+	__u32 *straws;         /* 16-bit fixed point */
+};
+
+
+
+/*
+ * CRUSH map includes all buckets, rules, etc.
+ */
+struct crush_map {
+	struct crush_bucket **buckets;
+	struct crush_rule **rules;
+
+	/*
+	 * Parent pointers to identify the parent bucket a device or
+	 * bucket in the hierarchy.  If an item appears more than
+	 * once, this is the _last_ time it appeared (where buckets
+	 * are processed in bucket id order, from -1 on down to
+	 * -max_buckets.
+	 */
+	__u32 *bucket_parents;
+	__u32 *device_parents;
+
+	__s32 max_buckets;
+	__u32 max_rules;
+	__s32 max_devices;
+};
+
+
+/* crush.c */
+extern int crush_get_bucket_item_weight(struct crush_bucket *b, int pos);
+extern void crush_calc_parents(struct crush_map *map);
+extern void crush_destroy_bucket_uniform(struct crush_bucket_uniform *b);
+extern void crush_destroy_bucket_list(struct crush_bucket_list *b);
+extern void crush_destroy_bucket_tree(struct crush_bucket_tree *b);
+extern void crush_destroy_bucket_straw(struct crush_bucket_straw *b);
+extern void crush_destroy_bucket(struct crush_bucket *b);
+extern void crush_destroy(struct crush_map *map);
+
+#endif
