commit 2d4f545cb14fa2d9865124183f3100d46dc9b3b5
Author: Peter Meerwald <pmeerw@pmeerw.net>
Date:   Mon Jun 4 23:34:06 2018 +0200

    rfkill: Fixes and cleanup of kernel-doc in the header file
    
    Fixes kerneldoc parameter names to match implementation,
    rfkill_set_hw_state(), rfkill_set_sw_state().
    Fix description of rfkill_resume_polling().
    Fix typos in documentation of rfkill_find_type().
    Consistently start kerneldoc description with uppercase
    letter.
    
    Signed-off-by: Peter Meerwald-Stadler <pmeerw@pmeerw.net>
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index e6a0031d1b1f..8ad2487a86d5 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -66,7 +66,7 @@ struct rfkill_ops {
 
 #if defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)
 /**
- * rfkill_alloc - allocate rfkill structure
+ * rfkill_alloc - Allocate rfkill structure
  * @name: name of the struct -- the string is not copied internally
  * @parent: device that has rf switch on it
  * @type: type of the switch (RFKILL_TYPE_*)
@@ -112,7 +112,7 @@ void rfkill_pause_polling(struct rfkill *rfkill);
 /**
  * rfkill_resume_polling(struct rfkill *rfkill)
  *
- * Pause polling -- say transmitter is off for other reasons.
+ * Resume polling
  * NOTE: not necessary for suspend/resume -- in that case the
  * core stops polling anyway
  */
@@ -130,7 +130,7 @@ void rfkill_resume_polling(struct rfkill *rfkill);
 void rfkill_unregister(struct rfkill *rfkill);
 
 /**
- * rfkill_destroy - free rfkill structure
+ * rfkill_destroy - Free rfkill structure
  * @rfkill: rfkill structure to be destroyed
  *
  * Destroys the rfkill structure.
@@ -140,7 +140,7 @@ void rfkill_destroy(struct rfkill *rfkill);
 /**
  * rfkill_set_hw_state - Set the internal rfkill hardware block state
  * @rfkill: pointer to the rfkill class to modify.
- * @state: the current hardware block state to set
+ * @blocked: the current hardware block state to set
  *
  * rfkill drivers that get events when the hard-blocked state changes
  * use this function to notify the rfkill core (and through that also
@@ -161,7 +161,7 @@ bool rfkill_set_hw_state(struct rfkill *rfkill, bool blocked);
 /**
  * rfkill_set_sw_state - Set the internal rfkill software block state
  * @rfkill: pointer to the rfkill class to modify.
- * @state: the current software block state to set
+ * @blocked: the current software block state to set
  *
  * rfkill drivers that get events when the soft-blocked state changes
  * (yes, some platforms directly act on input but allow changing again)
@@ -183,7 +183,7 @@ bool rfkill_set_sw_state(struct rfkill *rfkill, bool blocked);
 /**
  * rfkill_init_sw_state - Initialize persistent software block state
  * @rfkill: pointer to the rfkill class to modify.
- * @state: the current software block state to set
+ * @blocked: the current software block state to set
  *
  * rfkill drivers that preserve their software block state over power off
  * use this function to notify the rfkill core (and through that also
@@ -208,17 +208,17 @@ void rfkill_init_sw_state(struct rfkill *rfkill, bool blocked);
 void rfkill_set_states(struct rfkill *rfkill, bool sw, bool hw);
 
 /**
- * rfkill_blocked - query rfkill block
+ * rfkill_blocked - Query rfkill block state
  *
  * @rfkill: rfkill struct to query
  */
 bool rfkill_blocked(struct rfkill *rfkill);
 
 /**
- * rfkill_find_type - Helpper for finding rfkill type by name
+ * rfkill_find_type - Helper for finding rfkill type by name
  * @name: the name of the type
  *
- * Returns enum rfkill_type that conrresponds the name.
+ * Returns enum rfkill_type that corresponds to the name.
  */
 enum rfkill_type rfkill_find_type(const char *name);
 
@@ -296,7 +296,7 @@ static inline enum rfkill_type rfkill_find_type(const char *name)
 const char *rfkill_get_led_trigger_name(struct rfkill *rfkill);
 
 /**
- * rfkill_set_led_trigger_name -- set the LED trigger name
+ * rfkill_set_led_trigger_name - Set the LED trigger name
  * @rfkill: rfkill struct
  * @name: LED trigger name
  *

commit 648b50dd6abf8e6e5b589bb8e6873a4596389dbe
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Mon Jan 25 12:03:46 2016 +0300

    net: rfkill: add rfkill_find_type function
    
    Helper for finding the type based on name. Useful if the
    type needs to be determined based on device property.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    [modify rfkill_types array and BUILD_BUG_ON to not cause errors]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 7af625f6d226..e6a0031d1b1f 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -213,6 +213,15 @@ void rfkill_set_states(struct rfkill *rfkill, bool sw, bool hw);
  * @rfkill: rfkill struct to query
  */
 bool rfkill_blocked(struct rfkill *rfkill);
+
+/**
+ * rfkill_find_type - Helpper for finding rfkill type by name
+ * @name: the name of the type
+ *
+ * Returns enum rfkill_type that conrresponds the name.
+ */
+enum rfkill_type rfkill_find_type(const char *name);
+
 #else /* !RFKILL */
 static inline struct rfkill * __must_check
 rfkill_alloc(const char *name,
@@ -269,6 +278,12 @@ static inline bool rfkill_blocked(struct rfkill *rfkill)
 {
 	return false;
 }
+
+static inline enum rfkill_type rfkill_find_type(const char *name)
+{
+	return RFKILL_TYPE_ALL;
+}
+
 #endif /* RFKILL || RFKILL_MODULE */
 
 

commit dd21dfc645d5dce0657af78761b3fa11a3a95398
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Jan 20 10:39:23 2016 +0100

    rfkill: disentangle polling pause and suspend
    
    When suspended while polling is paused, polling will erroneously
    resume at resume time. Fix this by tracking pause and suspend in
    separate state variable and adding the necessary checks.
    
    Clarify the documentation on this as well.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index d9010789b4e8..7af625f6d226 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -104,7 +104,8 @@ int __must_check rfkill_register(struct rfkill *rfkill);
  *
  * Pause polling -- say transmitter is off for other reasons.
  * NOTE: not necessary for suspend/resume -- in that case the
- * core stops polling anyway
+ * core stops polling anyway (but will also correctly handle
+ * the case of polling having been paused before suspend.)
  */
 void rfkill_pause_polling(struct rfkill *rfkill);
 

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 0ec590bb3611..d9010789b4e8 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -1,6 +1,3 @@
-#ifndef __RFKILL_H
-#define __RFKILL_H
-
 /*
  * Copyright (C) 2006 - 2007 Ivo van Doorn
  * Copyright (C) 2007 Dmitry Torokhov
@@ -18,92 +15,11 @@
  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
+#ifndef __RFKILL_H
+#define __RFKILL_H
 
-#include <linux/types.h>
-
-/* define userspace visible states */
-#define RFKILL_STATE_SOFT_BLOCKED	0
-#define RFKILL_STATE_UNBLOCKED		1
-#define RFKILL_STATE_HARD_BLOCKED	2
-
-/**
- * enum rfkill_type - type of rfkill switch.
- *
- * @RFKILL_TYPE_ALL: toggles all switches (requests only - not a switch type)
- * @RFKILL_TYPE_WLAN: switch is on a 802.11 wireless network device.
- * @RFKILL_TYPE_BLUETOOTH: switch is on a bluetooth device.
- * @RFKILL_TYPE_UWB: switch is on a ultra wideband device.
- * @RFKILL_TYPE_WIMAX: switch is on a WiMAX device.
- * @RFKILL_TYPE_WWAN: switch is on a wireless WAN device.
- * @RFKILL_TYPE_GPS: switch is on a GPS device.
- * @RFKILL_TYPE_FM: switch is on a FM radio device.
- * @NUM_RFKILL_TYPES: number of defined rfkill types
- */
-enum rfkill_type {
-	RFKILL_TYPE_ALL = 0,
-	RFKILL_TYPE_WLAN,
-	RFKILL_TYPE_BLUETOOTH,
-	RFKILL_TYPE_UWB,
-	RFKILL_TYPE_WIMAX,
-	RFKILL_TYPE_WWAN,
-	RFKILL_TYPE_GPS,
-	RFKILL_TYPE_FM,
-	NUM_RFKILL_TYPES,
-};
-
-/**
- * enum rfkill_operation - operation types
- * @RFKILL_OP_ADD: a device was added
- * @RFKILL_OP_DEL: a device was removed
- * @RFKILL_OP_CHANGE: a device's state changed -- userspace changes one device
- * @RFKILL_OP_CHANGE_ALL: userspace changes all devices (of a type, or all)
- */
-enum rfkill_operation {
-	RFKILL_OP_ADD = 0,
-	RFKILL_OP_DEL,
-	RFKILL_OP_CHANGE,
-	RFKILL_OP_CHANGE_ALL,
-};
-
-/**
- * struct rfkill_event - events for userspace on /dev/rfkill
- * @idx: index of dev rfkill
- * @type: type of the rfkill struct
- * @op: operation code
- * @hard: hard state (0/1)
- * @soft: soft state (0/1)
- *
- * Structure used for userspace communication on /dev/rfkill,
- * used for events from the kernel and control to the kernel.
- */
-struct rfkill_event {
-	__u32 idx;
-	__u8  type;
-	__u8  op;
-	__u8  soft, hard;
-} __attribute__((packed));
-
-/*
- * We are planning to be backward and forward compatible with changes
- * to the event struct, by adding new, optional, members at the end.
- * When reading an event (whether the kernel from userspace or vice
- * versa) we need to accept anything that's at least as large as the
- * version 1 event size, but might be able to accept other sizes in
- * the future.
- *
- * One exception is the kernel -- we already have two event sizes in
- * that we've made the 'hard' member optional since our only option
- * is to ignore it anyway.
- */
-#define RFKILL_EVENT_SIZE_V1	8
-
-/* ioctl for turning off rfkill-input (if present) */
-#define RFKILL_IOC_MAGIC	'R'
-#define RFKILL_IOC_NOINPUT	1
-#define RFKILL_IOCTL_NOINPUT	_IO(RFKILL_IOC_MAGIC, RFKILL_IOC_NOINPUT)
+#include <uapi/linux/rfkill.h>
 
-/* and that's all userspace gets */
-#ifdef __KERNEL__
 /* don't allow anyone to use these in the kernel */
 enum rfkill_user_states {
 	RFKILL_USER_STATE_SOFT_BLOCKED	= RFKILL_STATE_SOFT_BLOCKED,
@@ -385,6 +301,4 @@ rfkill_set_led_trigger_name(struct rfkill *rfkill, const char *name)
 }
 #endif
 
-#endif /* __KERNEL__ */
-
 #endif /* RFKILL_H */

commit 06d7de831dab8b93adb86e039a2f3d36604a9197
Author: AceLan Kao <acelan.kao@canonical.com>
Date:   Thu Jul 26 09:51:08 2012 +0800

    Revert "rfkill: remove dead code"
    
    This reverts commit 2e48928d8a0f38c1b5c81eb3f1294de8a6382c68.
    
    Those functions are needed and should not be removed, or
    there is no way to set the rfkill led trigger name.
    
    Signed-off-by: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 6fdf02737e9d..0ec590bb3611 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -354,6 +354,37 @@ static inline bool rfkill_blocked(struct rfkill *rfkill)
 }
 #endif /* RFKILL || RFKILL_MODULE */
 
+
+#ifdef CONFIG_RFKILL_LEDS
+/**
+ * rfkill_get_led_trigger_name - Get the LED trigger name for the button's LED.
+ * This function might return a NULL pointer if registering of the
+ * LED trigger failed. Use this as "default_trigger" for the LED.
+ */
+const char *rfkill_get_led_trigger_name(struct rfkill *rfkill);
+
+/**
+ * rfkill_set_led_trigger_name -- set the LED trigger name
+ * @rfkill: rfkill struct
+ * @name: LED trigger name
+ *
+ * This function sets the LED trigger name of the radio LED
+ * trigger that rfkill creates. It is optional, but if called
+ * must be called before rfkill_register() to be effective.
+ */
+void rfkill_set_led_trigger_name(struct rfkill *rfkill, const char *name);
+#else
+static inline const char *rfkill_get_led_trigger_name(struct rfkill *rfkill)
+{
+	return NULL;
+}
+
+static inline void
+rfkill_set_led_trigger_name(struct rfkill *rfkill, const char *name)
+{
+}
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* RFKILL_H */

commit 313162d0b83836e2f57e51b9b8650fb4b9c396ea
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jan 30 11:46:54 2012 -0500

    device.h: audit and cleanup users in main include dir
    
    The <linux/device.h> header includes a lot of stuff, and
    it in turn gets a lot of use just for the basic "struct device"
    which appears so often.
    
    Clean up the users as follows:
    
    1) For those headers only needing "struct device" as a pointer
    in fcn args, replace the include with exactly that.
    
    2) For headers not really using anything from device.h, simply
    delete the include altogether.
    
    3) For headers relying on getting device.h implicitly before
    being included themselves, now explicitly include device.h
    
    4) For files in which doing #1 or #2 uncovers an implicit
    dependency on some other header, fix by explicitly adding
    the required header(s).
    
    Any C files that were implicitly relying on device.h to be
    present have already been dealt with in advance.
    
    Total removals from #1 and #2: 51.  Total additions coming
    from #3: 9.  Total other implicit dependencies from #4: 7.
    
    As of 3.3-rc1, there were 110, so a net removal of 42 gives
    about a 38% reduction in device.h presence in include/*
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index c6c608482cba..6fdf02737e9d 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -117,10 +117,10 @@ enum rfkill_user_states {
 #include <linux/kernel.h>
 #include <linux/list.h>
 #include <linux/mutex.h>
-#include <linux/device.h>
 #include <linux/leds.h>
 #include <linux/err.h>
 
+struct device;
 /* this is opaque */
 struct rfkill;
 

commit 2e48928d8a0f38c1b5c81eb3f1294de8a6382c68
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Wed Oct 20 10:16:58 2010 -0700

    rfkill: remove dead code
    
    The following code is defined but never used.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 08c32e4f261a..c6c608482cba 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -354,37 +354,6 @@ static inline bool rfkill_blocked(struct rfkill *rfkill)
 }
 #endif /* RFKILL || RFKILL_MODULE */
 
-
-#ifdef CONFIG_RFKILL_LEDS
-/**
- * rfkill_get_led_trigger_name - Get the LED trigger name for the button's LED.
- * This function might return a NULL pointer if registering of the
- * LED trigger failed. Use this as "default_trigger" for the LED.
- */
-const char *rfkill_get_led_trigger_name(struct rfkill *rfkill);
-
-/**
- * rfkill_set_led_trigger_name -- set the LED trigger name
- * @rfkill: rfkill struct
- * @name: LED trigger name
- *
- * This function sets the LED trigger name of the radio LED
- * trigger that rfkill creates. It is optional, but if called
- * must be called before rfkill_register() to be effective.
- */
-void rfkill_set_led_trigger_name(struct rfkill *rfkill, const char *name);
-#else
-static inline const char *rfkill_get_led_trigger_name(struct rfkill *rfkill)
-{
-	return NULL;
-}
-
-static inline void
-rfkill_set_led_trigger_name(struct rfkill *rfkill, const char *name)
-{
-}
-#endif
-
 #endif /* __KERNEL__ */
 
 #endif /* RFKILL_H */

commit 09cd2b99c6cdd1e14e84c1febca2fb91e9f4e5ba
Author: Changli Gao <xiaosuo@gmail.com>
Date:   Sun Aug 22 17:25:05 2010 +0000

    header: fix broken headers for user space
    
    __packed is only defined in kernel space, so we should use
    __attribute__((packed)) for the code shared between kernel and user space.
    
    Two __attribute() annotations are replaced with __attribute__() too.
    
    Signed-off-by: Changli Gao <xiaosuo@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 4f82326eb294..08c32e4f261a 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -81,7 +81,7 @@ struct rfkill_event {
 	__u8  type;
 	__u8  op;
 	__u8  soft, hard;
-} __packed;
+} __attribute__((packed));
 
 /*
  * We are planning to be backward and forward compatible with changes

commit 3082a2b7b1af1b1508c1c3fa589566064f926f40
Author: Matthew Garrett <mjg@redhat.com>
Date:   Tue Feb 16 16:36:25 2010 -0500

    rfkill: Add support for KEY_RFKILL
    
    Add support for handling KEY_RFKILL in the rfkill input module. This
    simply toggles the state of all rfkill devices. The comment in rfkill.h
    is also updated to reflect that RFKILL_TYPE_ALL may be used inside the
    kernel.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 97059d08a626..4f82326eb294 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -29,7 +29,7 @@
 /**
  * enum rfkill_type - type of rfkill switch.
  *
- * @RFKILL_TYPE_ALL: toggles all switches (userspace only)
+ * @RFKILL_TYPE_ALL: toggles all switches (requests only - not a switch type)
  * @RFKILL_TYPE_WLAN: switch is on a 802.11 wireless network device.
  * @RFKILL_TYPE_BLUETOOTH: switch is on a bluetooth device.
  * @RFKILL_TYPE_UWB: switch is on a ultra wideband device.

commit 875405a7793e9c35fab33819e7e5df7a98b6064c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Nov 18 16:48:01 2009 +0100

    rfkill: Add constant for RFKILL_TYPE_FM radio devices
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Janakiram Sistla <janakiram.sistla@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index a75e9e566ce5..97059d08a626 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -36,6 +36,7 @@
  * @RFKILL_TYPE_WIMAX: switch is on a WiMAX device.
  * @RFKILL_TYPE_WWAN: switch is on a wireless WAN device.
  * @RFKILL_TYPE_GPS: switch is on a GPS device.
+ * @RFKILL_TYPE_FM: switch is on a FM radio device.
  * @NUM_RFKILL_TYPES: number of defined rfkill types
  */
 enum rfkill_type {
@@ -46,6 +47,7 @@ enum rfkill_type {
 	RFKILL_TYPE_WIMAX,
 	RFKILL_TYPE_WWAN,
 	RFKILL_TYPE_GPS,
+	RFKILL_TYPE_FM,
 	NUM_RFKILL_TYPES,
 };
 

commit 0878c3504f92f1bf063d0890a9960d4b9e6c4618
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Nov 18 16:48:00 2009 +0100

    rfkill: Add missing description for RFKILL_TYPE_GPS
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Janakiram Sistla <janakiram.sistla@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 3392c59d2706..a75e9e566ce5 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -35,6 +35,7 @@
  * @RFKILL_TYPE_UWB: switch is on a ultra wideband device.
  * @RFKILL_TYPE_WIMAX: switch is on a WiMAX device.
  * @RFKILL_TYPE_WWAN: switch is on a wireless WAN device.
+ * @RFKILL_TYPE_GPS: switch is on a GPS device.
  * @NUM_RFKILL_TYPES: number of defined rfkill types
  */
 enum rfkill_type {

commit 8bc11b491b6cad75e737f1d38bb4b261bd95b291
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed Aug 26 18:13:17 2009 +0200

    rfkill: relicense header file
    
    This header file is copied into userspace tools that
    need not be GPLv2 licensed, make that easier.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    Acked-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Acked-by: Iñaky Pérez-González <inaky@linux.intel.com>
    Acked-by: Ivo van Doorn <IvDoorn@gmail.com>
    Acked-by: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
    Acked-by: Michael Buesch <mb@bu3sch.de>
    Acked-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 21ca51bf4dd2..3392c59d2706 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -6,20 +6,17 @@
  * Copyright (C) 2007 Dmitry Torokhov
  * Copyright 2009 Johannes Berg <johannes@sipsolutions.net>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the
- * Free Software Foundation, Inc.,
- * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
 #include <linux/types.h>

commit 3ad201496badddd8e1cda87ee6d29e8b3b8e1279
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Sun Aug 2 02:36:49 2009 +0300

    rfkill: add the GPS radio type
    
    Althoug GPS is a technology w/o transmitting radio
    and thus not a primary candidate for rfkill switch,
    rfkill gives unified interface point for devices with
    wireless technology.
    
    The input key is not supplied as it is too be deprecated.
    
    Cc: johannes@sipsolutions.net
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 10202903141a..21ca51bf4dd2 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -47,6 +47,7 @@ enum rfkill_type {
 	RFKILL_TYPE_UWB,
 	RFKILL_TYPE_WIMAX,
 	RFKILL_TYPE_WWAN,
+	RFKILL_TYPE_GPS,
 	NUM_RFKILL_TYPES,
 };
 

commit 74d154189d597b91da4322996dbf4f5c3d1544ab
Merge: 5a6338db3788 ffafa60d496f
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Jul 23 19:03:51 2009 -0700

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
            drivers/net/wireless/iwmc3200wifi/netdev.c
            net/wireless/scan.c

commit e56f0975360369347725c49654ecfe3792710429
Author: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
Date:   Sat Jul 18 19:20:20 2009 +0100

    rfkill: remove too-strict __must_check
    
    Some drivers don't need the return value of rfkill_set_hw_state(),
    so it should not be marked as __must_check.
    
    Signed-off-by: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    Acked-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 2ce29831feb6..278777fa8a3a 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -224,7 +224,7 @@ void rfkill_destroy(struct rfkill *rfkill);
  * should be blocked) so that drivers need not keep track of the soft
  * block state -- which they might not be able to.
  */
-bool __must_check rfkill_set_hw_state(struct rfkill *rfkill, bool blocked);
+bool rfkill_set_hw_state(struct rfkill *rfkill, bool blocked);
 
 /**
  * rfkill_set_sw_state - Set the internal rfkill software block state

commit 1be491fca12ff599c37ceaf7e9042ebee9f0068e
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Sun Jul 5 14:51:06 2009 +0200

    rfkill: prep for rfkill API changes
    
    We've designed the /dev/rfkill API in a way that we
    can increase the event struct by adding members at
    the end, should it become necessary. To validate the
    events, userspace and the kernel need to have the
    proper event size to check for -- when reading from
    the other end they need to verify that it's at least
    version 1 of the event API, with the current struct
    size, so define a constant for that and make the
    code a little more 'future proof'.
    
    Not that I expect that we'll have to change the event
    size any time soon, but it's better to write the code
    in a way that lends itself to extending.
    
    Due to the current size of the event struct, the code
    is currently equivalent, but should the event struct
    ever need to be increased the new code might not need
    changing.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 2ce29831feb6..f3d5812693d6 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -82,6 +82,20 @@ struct rfkill_event {
 	__u8  soft, hard;
 } __packed;
 
+/*
+ * We are planning to be backward and forward compatible with changes
+ * to the event struct, by adding new, optional, members at the end.
+ * When reading an event (whether the kernel from userspace or vice
+ * versa) we need to accept anything that's at least as large as the
+ * version 1 event size, but might be able to accept other sizes in
+ * the future.
+ *
+ * One exception is the kernel -- we already have two event sizes in
+ * that we've made the 'hard' member optional since our only option
+ * is to ignore it anyway.
+ */
+#define RFKILL_EVENT_SIZE_V1	8
+
 /* ioctl for turning off rfkill-input (if present) */
 #define RFKILL_IOC_MAGIC	'R'
 #define RFKILL_IOC_NOINPUT	1

commit 1ce822fa04fd6878f079461a4b8affe4bb5ec27b
Author: Jaswinder Singh Rajput <jaswinder@kernel.org>
Date:   Wed Jul 8 21:25:54 2009 +0530

    includecheck fix: include/linux, rfkill.h
    
    fix the following 'make includecheck' warning:
    
      include/linux/rfkill.h: linux/types.h is included more than once.
    
    Signed-off-by: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index e73e2429a1b1..2ce29831feb6 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -99,7 +99,6 @@ enum rfkill_user_states {
 #undef RFKILL_STATE_UNBLOCKED
 #undef RFKILL_STATE_HARD_BLOCKED
 
-#include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/list.h>
 #include <linux/mutex.h>

commit 464902e812025792c9e33e19e1555c343672d5cf
Author: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
Date:   Tue Jun 16 14:54:04 2009 +0100

    rfkill: export persistent attribute in sysfs
    
    This information allows userspace to implement a hybrid policy where
    it can store the rfkill soft-blocked state in platform non-volatile
    storage if available, and if not then file-based storage can be used.
    
    Some users prefer platform non-volatile storage because of the behaviour
    when dual-booting multiple versions of Linux, or if the rfkill setting
    is changed in the BIOS setting screens, or if the BIOS responds to
    wireless-toggle hotkeys itself before the relevant platform driver has
    been loaded.
    
    Signed-off-by: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    Acked-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index dcac724340d8..e73e2429a1b1 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -259,8 +259,9 @@ bool rfkill_set_sw_state(struct rfkill *rfkill, bool blocked);
  * userspace) of their initial state.  It should only be used before
  * registration.
  *
- * In addition, it marks the device as "persistent".  Persistent devices
- * are expected to preserve preserve their own state when suspended.
+ * In addition, it marks the device as "persistent", an attribute which
+ * can be read by userspace.  Persistent devices are expected to preserve
+ * their own state when suspended.
  */
 void rfkill_init_sw_state(struct rfkill *rfkill, bool blocked);
 

commit 06d5caf47ef4fbd9efdceae33293c42778cb7b0c
Author: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
Date:   Tue Jun 16 15:39:51 2009 +0100

    rfkill: don't restore software blocked state on persistent devices
    
    The setting of the "persistent" flag is also made more explicit using
    a new rfkill_init_sw_state() function, instead of special-casing
    rfkill_set_sw_state() when it is called before registration.
    
    Suspend is a bit of a corner case so we try to get away without adding
    another hack to rfkill-input - it's going to be removed soon.
    If the state does change over suspend, users will simply have to prod
    rfkill-input twice in order to toggle the state.
    
    Userspace policy agents will be able to implement a more consistent user
    experience.  For example, they can avoid the above problem if they
    toggle devices individually.  Then there would be no "global state"
    to get out of sync.
    
    Currently there are only two rfkill drivers with persistent soft-blocked
    state.  thinkpad-acpi already checks the software state on resume.
    eeepc-laptop will require modification.
    
    Signed-off-by: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    CC: Marcel Holtmann <marcel@holtmann.org>
    Acked-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 16e39c7a67fc..dcac724340d8 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -160,8 +160,9 @@ struct rfkill * __must_check rfkill_alloc(const char *name,
  * the rfkill structure. Before calling this function the driver needs
  * to be ready to service method calls from rfkill.
  *
- * If the software blocked state is not set before registration,
- * set_block will be called to initialize it to a default value.
+ * If rfkill_init_sw_state() is not called before registration,
+ * set_block() will be called to initialize the software blocked state
+ * to a default value.
  *
  * If the hardware blocked state is not set before registration,
  * it is assumed to be unblocked.
@@ -234,9 +235,11 @@ bool __must_check rfkill_set_hw_state(struct rfkill *rfkill, bool blocked);
  * rfkill drivers that get events when the soft-blocked state changes
  * (yes, some platforms directly act on input but allow changing again)
  * use this function to notify the rfkill core (and through that also
- * userspace) of the current state.  It is not necessary to notify on
- * resume; since hibernation can always change the soft-blocked state,
- * the rfkill core will unconditionally restore the previous state.
+ * userspace) of the current state.
+ *
+ * Drivers should also call this function after resume if the state has
+ * been changed by the user.  This only makes sense for "persistent"
+ * devices (see rfkill_init_sw_state()).
  *
  * This function can be called in any context, even from within rfkill
  * callbacks.
@@ -246,6 +249,21 @@ bool __must_check rfkill_set_hw_state(struct rfkill *rfkill, bool blocked);
  */
 bool rfkill_set_sw_state(struct rfkill *rfkill, bool blocked);
 
+/**
+ * rfkill_init_sw_state - Initialize persistent software block state
+ * @rfkill: pointer to the rfkill class to modify.
+ * @state: the current software block state to set
+ *
+ * rfkill drivers that preserve their software block state over power off
+ * use this function to notify the rfkill core (and through that also
+ * userspace) of their initial state.  It should only be used before
+ * registration.
+ *
+ * In addition, it marks the device as "persistent".  Persistent devices
+ * are expected to preserve preserve their own state when suspended.
+ */
+void rfkill_init_sw_state(struct rfkill *rfkill, bool blocked);
+
 /**
  * rfkill_set_states - Set the internal rfkill block states
  * @rfkill: pointer to the rfkill class to modify.
@@ -307,6 +325,10 @@ static inline bool rfkill_set_sw_state(struct rfkill *rfkill, bool blocked)
 	return blocked;
 }
 
+static inline void rfkill_init_sw_state(struct rfkill *rfkill, bool blocked)
+{
+}
+
 static inline void rfkill_set_states(struct rfkill *rfkill, bool sw, bool hw)
 {
 }

commit 908209c160da8ecb68052111972b7a21310eac3f
Author: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
Date:   Mon Jun 8 13:12:23 2009 +0100

    rfkill: don't impose global states on resume (just restore the previous states)
    
    Once rfkill-input is disabled, the "global" states will only be used as
    default initial states.
    
    Since the states will always be the same after resume, we shouldn't
    generate events on resume.
    
    Signed-off-by: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index c1dca0b8138b..16e39c7a67fc 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -212,7 +212,7 @@ void rfkill_destroy(struct rfkill *rfkill);
  *
  * rfkill drivers that get events when the hard-blocked state changes
  * use this function to notify the rfkill core (and through that also
- * userspace) of the current state -- they should also use this after
+ * userspace) of the current state.  They should also use this after
  * resume if the state could have changed.
  *
  * You need not (but may) call this function if poll_state is assigned.
@@ -234,8 +234,9 @@ bool __must_check rfkill_set_hw_state(struct rfkill *rfkill, bool blocked);
  * rfkill drivers that get events when the soft-blocked state changes
  * (yes, some platforms directly act on input but allow changing again)
  * use this function to notify the rfkill core (and through that also
- * userspace) of the current state -- they should also use this after
- * resume if the state could have changed.
+ * userspace) of the current state.  It is not necessary to notify on
+ * resume; since hibernation can always change the soft-blocked state,
+ * the rfkill core will unconditionally restore the previous state.
  *
  * This function can be called in any context, even from within rfkill
  * callbacks.

commit b3fa1329eaf2a7b97124dacf5b663fd51346ac19
Author: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
Date:   Mon Jun 8 13:27:27 2009 +0100

    rfkill: remove set_global_sw_state
    
    rfkill_set_global_sw_state() (previously rfkill_set_default()) will no
    longer be exported by the rewritten rfkill core.
    
    Instead, platform drivers which can provide persistent soft-rfkill state
    across power-down/reboot should indicate their initial state by calling
    rfkill_set_sw_state() before registration.  Otherwise, they will be
    initialized to a default value during registration by a set_block call.
    
    We remove existing calls to rfkill_set_sw_state() which happen before
    registration, since these had no effect in the old model.  If these
    drivers do have persistent state, the calls can be put back (subject
    to testing :-).  This affects hp-wmi and acer-wmi.
    
    Drivers with persistent state will affect the global state only if
    rfkill-input is enabled.  This is required, otherwise booting with
    wireless soft-blocked and pressing the wireless-toggle key once would
    have no apparent effect.  This special case will be removed in future
    along with rfkill-input, in favour of a more flexible userspace daemon
    (see Documentation/feature-removal-schedule.txt).
    
    Now rfkill_global_states[n].def is only used to preserve global states
    over EPO, it is renamed to ".sav".
    
    Signed-off-by: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    Acked-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index d7e818ad0bc4..c1dca0b8138b 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -157,8 +157,14 @@ struct rfkill * __must_check rfkill_alloc(const char *name,
  * @rfkill: rfkill structure to be registered
  *
  * This function should be called by the transmitter driver to register
- * the rfkill structure needs to be registered. Before calling this function
- * the driver needs to be ready to service method calls from rfkill.
+ * the rfkill structure. Before calling this function the driver needs
+ * to be ready to service method calls from rfkill.
+ *
+ * If the software blocked state is not set before registration,
+ * set_block will be called to initialize it to a default value.
+ *
+ * If the hardware blocked state is not set before registration,
+ * it is assumed to be unblocked.
  */
 int __must_check rfkill_register(struct rfkill *rfkill);
 
@@ -250,19 +256,6 @@ bool rfkill_set_sw_state(struct rfkill *rfkill, bool blocked);
  */
 void rfkill_set_states(struct rfkill *rfkill, bool sw, bool hw);
 
-/**
- * rfkill_set_global_sw_state - set global sw block default
- * @type: rfkill type to set default for
- * @blocked: default to set
- *
- * This function sets the global default -- use at boot if your platform has
- * an rfkill switch. If not early enough this call may be ignored.
- *
- * XXX: instead of ignoring -- how about just updating all currently
- *	registered drivers?
- */
-void rfkill_set_global_sw_state(const enum rfkill_type type, bool blocked);
-
 /**
  * rfkill_blocked - query rfkill block
  *
@@ -317,11 +310,6 @@ static inline void rfkill_set_states(struct rfkill *rfkill, bool sw, bool hw)
 {
 }
 
-static inline void rfkill_set_global_sw_state(const enum rfkill_type type,
-					      bool blocked)
-{
-}
-
 static inline bool rfkill_blocked(struct rfkill *rfkill)
 {
 	return false;

commit 1506e30b5f25f6c3357167a18f0e4ae6f5662a28
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Jun 9 17:49:06 2009 -0700

    rfkill: include err.h
    
    Since we use ERR_PTR and similar macros, we need to include
    linux/err.h.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index ee3eddea8568..d7e818ad0bc4 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -105,6 +105,7 @@ enum rfkill_user_states {
 #include <linux/mutex.h>
 #include <linux/device.h>
 #include <linux/leds.h>
+#include <linux/err.h>
 
 /* this is opaque */
 struct rfkill;

commit 6081162e2ed78dfcf149b076b047078ab1445cc2
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Jun 2 13:01:40 2009 +0200

    rfkill: add function to query state
    
    Sometimes it is necessary to know how the state is,
    and it is easier to query rfkill than keep track of
    it somewhere else, so add a function for that. This
    could later be expanded to return hard/soft block,
    but so far that isn't necessary.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 7c116f6631b8..ee3eddea8568 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -261,6 +261,13 @@ void rfkill_set_states(struct rfkill *rfkill, bool sw, bool hw);
  *	registered drivers?
  */
 void rfkill_set_global_sw_state(const enum rfkill_type type, bool blocked);
+
+/**
+ * rfkill_blocked - query rfkill block
+ *
+ * @rfkill: rfkill struct to query
+ */
+bool rfkill_blocked(struct rfkill *rfkill);
 #else /* !RFKILL */
 static inline struct rfkill * __must_check
 rfkill_alloc(const char *name,
@@ -313,6 +320,11 @@ static inline void rfkill_set_global_sw_state(const enum rfkill_type type,
 					      bool blocked)
 {
 }
+
+static inline bool rfkill_blocked(struct rfkill *rfkill)
+{
+	return false;
+}
 #endif /* RFKILL || RFKILL_MODULE */
 
 

commit c64fb01627e24725d1f9d535e4426475a4415753
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Jun 2 13:01:38 2009 +0200

    rfkill: create useful userspace interface
    
    The new code added by this patch will make rfkill create
    a misc character device /dev/rfkill that userspace can use
    to control rfkill soft blocks and get status of devices as
    well as events when the status changes.
    
    Using it is very simple -- when you open it you can read
    a number of times to get the initial state, and every
    further read blocks (you can poll) on getting the next
    event from the kernel. The same structure you read is
    also used when writing to it to change the soft block of
    a given device, all devices of a given type, or all
    devices.
    
    This also makes CONFIG_RFKILL_INPUT selectable again in
    order to be able to test without it present since its
    functionality can now be replaced by userspace entirely
    and distros and users may not want the input part of
    rfkill interfering with their userspace code. We will
    also write a userspace daemon to handle all that and
    consequently add the input code to the feature removal
    schedule.
    
    In order to have rfkilld support both kernels with and
    without CONFIG_RFKILL_INPUT (or new kernels after its
    eventual removal) we also add an ioctl (that only exists
    if rfkill-input is present) to disable rfkill-input.
    It is not very efficient, but at least gives the correct
    behaviour in all cases.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 090852c8de7a..7c116f6631b8 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -22,34 +22,17 @@
  * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#include <linux/types.h>
 
 /* define userspace visible states */
 #define RFKILL_STATE_SOFT_BLOCKED	0
 #define RFKILL_STATE_UNBLOCKED		1
 #define RFKILL_STATE_HARD_BLOCKED	2
 
-/* and that's all userspace gets */
-#ifdef __KERNEL__
-/* don't allow anyone to use these in the kernel */
-enum rfkill_user_states {
-	RFKILL_USER_STATE_SOFT_BLOCKED	= RFKILL_STATE_SOFT_BLOCKED,
-	RFKILL_USER_STATE_UNBLOCKED	= RFKILL_STATE_UNBLOCKED,
-	RFKILL_USER_STATE_HARD_BLOCKED	= RFKILL_STATE_HARD_BLOCKED,
-};
-#undef RFKILL_STATE_SOFT_BLOCKED
-#undef RFKILL_STATE_UNBLOCKED
-#undef RFKILL_STATE_HARD_BLOCKED
-
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/list.h>
-#include <linux/mutex.h>
-#include <linux/device.h>
-#include <linux/leds.h>
-
 /**
  * enum rfkill_type - type of rfkill switch.
  *
+ * @RFKILL_TYPE_ALL: toggles all switches (userspace only)
  * @RFKILL_TYPE_WLAN: switch is on a 802.11 wireless network device.
  * @RFKILL_TYPE_BLUETOOTH: switch is on a bluetooth device.
  * @RFKILL_TYPE_UWB: switch is on a ultra wideband device.
@@ -58,6 +41,7 @@ enum rfkill_user_states {
  * @NUM_RFKILL_TYPES: number of defined rfkill types
  */
 enum rfkill_type {
+	RFKILL_TYPE_ALL = 0,
 	RFKILL_TYPE_WLAN,
 	RFKILL_TYPE_BLUETOOTH,
 	RFKILL_TYPE_UWB,
@@ -66,6 +50,62 @@ enum rfkill_type {
 	NUM_RFKILL_TYPES,
 };
 
+/**
+ * enum rfkill_operation - operation types
+ * @RFKILL_OP_ADD: a device was added
+ * @RFKILL_OP_DEL: a device was removed
+ * @RFKILL_OP_CHANGE: a device's state changed -- userspace changes one device
+ * @RFKILL_OP_CHANGE_ALL: userspace changes all devices (of a type, or all)
+ */
+enum rfkill_operation {
+	RFKILL_OP_ADD = 0,
+	RFKILL_OP_DEL,
+	RFKILL_OP_CHANGE,
+	RFKILL_OP_CHANGE_ALL,
+};
+
+/**
+ * struct rfkill_event - events for userspace on /dev/rfkill
+ * @idx: index of dev rfkill
+ * @type: type of the rfkill struct
+ * @op: operation code
+ * @hard: hard state (0/1)
+ * @soft: soft state (0/1)
+ *
+ * Structure used for userspace communication on /dev/rfkill,
+ * used for events from the kernel and control to the kernel.
+ */
+struct rfkill_event {
+	__u32 idx;
+	__u8  type;
+	__u8  op;
+	__u8  soft, hard;
+} __packed;
+
+/* ioctl for turning off rfkill-input (if present) */
+#define RFKILL_IOC_MAGIC	'R'
+#define RFKILL_IOC_NOINPUT	1
+#define RFKILL_IOCTL_NOINPUT	_IO(RFKILL_IOC_MAGIC, RFKILL_IOC_NOINPUT)
+
+/* and that's all userspace gets */
+#ifdef __KERNEL__
+/* don't allow anyone to use these in the kernel */
+enum rfkill_user_states {
+	RFKILL_USER_STATE_SOFT_BLOCKED	= RFKILL_STATE_SOFT_BLOCKED,
+	RFKILL_USER_STATE_UNBLOCKED	= RFKILL_STATE_UNBLOCKED,
+	RFKILL_USER_STATE_HARD_BLOCKED	= RFKILL_STATE_HARD_BLOCKED,
+};
+#undef RFKILL_STATE_SOFT_BLOCKED
+#undef RFKILL_STATE_UNBLOCKED
+#undef RFKILL_STATE_HARD_BLOCKED
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/device.h>
+#include <linux/leds.h>
+
 /* this is opaque */
 struct rfkill;
 
@@ -84,11 +124,7 @@ struct rfkill;
  *	the rfkill core query your driver before setting a requested
  *	block.
  * @set_block: turn the transmitter on (blocked == false) or off
- *	(blocked == true) -- this is called only while the transmitter
- *	is not hard-blocked, but note that the core's view of whether
- *	the transmitter is hard-blocked might differ from your driver's
- *	view due to race conditions, so it is possible that it is still
- *	called at the same time as you are calling rfkill_set_hw_state().
+ *	(blocked == true) -- ignore and return 0 when hard blocked.
  *	This callback must be assigned.
  */
 struct rfkill_ops {

commit 19d337dff95cbf76edd3ad95c0cee2732c3e1ec5
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Jun 2 13:01:37 2009 +0200

    rfkill: rewrite
    
    This patch completely rewrites the rfkill core to address
    the following deficiencies:
    
     * all rfkill drivers need to implement polling where necessary
       rather than having one central implementation
    
     * updating the rfkill state cannot be done from arbitrary
       contexts, forcing drivers to use schedule_work and requiring
       lots of code
    
     * rfkill drivers need to keep track of soft/hard blocked
       internally -- the core should do this
    
     * the rfkill API has many unexpected quirks, for example being
       asymmetric wrt. alloc/free and register/unregister
    
     * rfkill can call back into a driver from within a function the
       driver called -- this is prone to deadlocks and generally
       should be avoided
    
     * rfkill-input pointlessly is a separate module
    
     * drivers need to #ifdef rfkill functions (unless they want to
       depend on or select RFKILL) -- rfkill should provide inlines
       that do nothing if it isn't compiled in
    
     * the rfkill structure is not opaque -- drivers need to initialise
       it correctly (lots of sanity checking code required) -- instead
       force drivers to pass the right variables to rfkill_alloc()
    
     * the documentation is hard to read because it always assumes the
       reader is completely clueless and contains way TOO MANY CAPS
    
     * the rfkill code needlessly uses a lot of locks and atomic
       operations in locked sections
    
     * fix LED trigger to actually change the LED when the radio state
       changes -- this wasn't done before
    
    Tested-by: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    Signed-off-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br> [thinkpad]
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index de18ef227e00..090852c8de7a 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -4,6 +4,7 @@
 /*
  * Copyright (C) 2006 - 2007 Ivo van Doorn
  * Copyright (C) 2007 Dmitry Torokhov
+ * Copyright 2009 Johannes Berg <johannes@sipsolutions.net>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -21,6 +22,24 @@
  * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+
+/* define userspace visible states */
+#define RFKILL_STATE_SOFT_BLOCKED	0
+#define RFKILL_STATE_UNBLOCKED		1
+#define RFKILL_STATE_HARD_BLOCKED	2
+
+/* and that's all userspace gets */
+#ifdef __KERNEL__
+/* don't allow anyone to use these in the kernel */
+enum rfkill_user_states {
+	RFKILL_USER_STATE_SOFT_BLOCKED	= RFKILL_STATE_SOFT_BLOCKED,
+	RFKILL_USER_STATE_UNBLOCKED	= RFKILL_STATE_UNBLOCKED,
+	RFKILL_USER_STATE_HARD_BLOCKED	= RFKILL_STATE_HARD_BLOCKED,
+};
+#undef RFKILL_STATE_SOFT_BLOCKED
+#undef RFKILL_STATE_UNBLOCKED
+#undef RFKILL_STATE_HARD_BLOCKED
+
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/list.h>
@@ -30,109 +49,267 @@
 
 /**
  * enum rfkill_type - type of rfkill switch.
- * RFKILL_TYPE_WLAN: switch is on a 802.11 wireless network device.
- * RFKILL_TYPE_BLUETOOTH: switch is on a bluetooth device.
- * RFKILL_TYPE_UWB: switch is on a ultra wideband device.
- * RFKILL_TYPE_WIMAX: switch is on a WiMAX device.
- * RFKILL_TYPE_WWAN: switch is on a wireless WAN device.
+ *
+ * @RFKILL_TYPE_WLAN: switch is on a 802.11 wireless network device.
+ * @RFKILL_TYPE_BLUETOOTH: switch is on a bluetooth device.
+ * @RFKILL_TYPE_UWB: switch is on a ultra wideband device.
+ * @RFKILL_TYPE_WIMAX: switch is on a WiMAX device.
+ * @RFKILL_TYPE_WWAN: switch is on a wireless WAN device.
+ * @NUM_RFKILL_TYPES: number of defined rfkill types
  */
 enum rfkill_type {
-	RFKILL_TYPE_WLAN ,
+	RFKILL_TYPE_WLAN,
 	RFKILL_TYPE_BLUETOOTH,
 	RFKILL_TYPE_UWB,
 	RFKILL_TYPE_WIMAX,
 	RFKILL_TYPE_WWAN,
-	RFKILL_TYPE_MAX,
+	NUM_RFKILL_TYPES,
 };
 
-enum rfkill_state {
-	RFKILL_STATE_SOFT_BLOCKED = 0,	/* Radio output blocked */
-	RFKILL_STATE_UNBLOCKED    = 1,	/* Radio output allowed */
-	RFKILL_STATE_HARD_BLOCKED = 2,	/* Output blocked, non-overrideable */
-	RFKILL_STATE_MAX,		/* marker for last valid state */
+/* this is opaque */
+struct rfkill;
+
+/**
+ * struct rfkill_ops - rfkill driver methods
+ *
+ * @poll: poll the rfkill block state(s) -- only assign this method
+ *	when you need polling. When called, simply call one of the
+ *	rfkill_set{,_hw,_sw}_state family of functions. If the hw
+ *	is getting unblocked you need to take into account the return
+ *	value of those functions to make sure the software block is
+ *	properly used.
+ * @query: query the rfkill block state(s) and call exactly one of the
+ *	rfkill_set{,_hw,_sw}_state family of functions. Assign this
+ *	method if input events can cause hardware state changes to make
+ *	the rfkill core query your driver before setting a requested
+ *	block.
+ * @set_block: turn the transmitter on (blocked == false) or off
+ *	(blocked == true) -- this is called only while the transmitter
+ *	is not hard-blocked, but note that the core's view of whether
+ *	the transmitter is hard-blocked might differ from your driver's
+ *	view due to race conditions, so it is possible that it is still
+ *	called at the same time as you are calling rfkill_set_hw_state().
+ *	This callback must be assigned.
+ */
+struct rfkill_ops {
+	void	(*poll)(struct rfkill *rfkill, void *data);
+	void	(*query)(struct rfkill *rfkill, void *data);
+	int	(*set_block)(void *data, bool blocked);
 };
 
+#if defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)
 /**
- * struct rfkill - rfkill control structure.
- * @name: Name of the switch.
- * @type: Radio type which the button controls, the value stored
- *	here should be a value from enum rfkill_type.
- * @state: State of the switch, "UNBLOCKED" means radio can operate.
- * @mutex: Guards switch state transitions.  It serializes callbacks
- *	and also protects the state.
- * @data: Pointer to the RF button drivers private data which will be
- *	passed along when toggling radio state.
- * @toggle_radio(): Mandatory handler to control state of the radio.
- *	only RFKILL_STATE_SOFT_BLOCKED and RFKILL_STATE_UNBLOCKED are
- *	valid parameters.
- * @get_state(): handler to read current radio state from hardware,
- *      may be called from atomic context, should return 0 on success.
- *      Either this handler OR judicious use of rfkill_force_state() is
- *      MANDATORY for any driver capable of RFKILL_STATE_HARD_BLOCKED.
- * @led_trigger: A LED trigger for this button's LED.
- * @dev: Device structure integrating the switch into device tree.
- * @node: Used to place switch into list of all switches known to the
- *	the system.
- *
- * This structure represents a RF switch located on a network device.
+ * rfkill_alloc - allocate rfkill structure
+ * @name: name of the struct -- the string is not copied internally
+ * @parent: device that has rf switch on it
+ * @type: type of the switch (RFKILL_TYPE_*)
+ * @ops: rfkill methods
+ * @ops_data: data passed to each method
+ *
+ * This function should be called by the transmitter driver to allocate an
+ * rfkill structure. Returns %NULL on failure.
  */
-struct rfkill {
-	const char *name;
-	enum rfkill_type type;
-
-	/* the mutex serializes callbacks and also protects
-	 * the state */
-	struct mutex mutex;
-	enum rfkill_state state;
-	void *data;
-	int (*toggle_radio)(void *data, enum rfkill_state state);
-	int (*get_state)(void *data, enum rfkill_state *state);
+struct rfkill * __must_check rfkill_alloc(const char *name,
+					  struct device *parent,
+					  const enum rfkill_type type,
+					  const struct rfkill_ops *ops,
+					  void *ops_data);
 
-#ifdef CONFIG_RFKILL_LEDS
-	struct led_trigger led_trigger;
-#endif
+/**
+ * rfkill_register - Register a rfkill structure.
+ * @rfkill: rfkill structure to be registered
+ *
+ * This function should be called by the transmitter driver to register
+ * the rfkill structure needs to be registered. Before calling this function
+ * the driver needs to be ready to service method calls from rfkill.
+ */
+int __must_check rfkill_register(struct rfkill *rfkill);
 
-	struct device dev;
-	struct list_head node;
-	enum rfkill_state state_for_resume;
-};
-#define to_rfkill(d)	container_of(d, struct rfkill, dev)
+/**
+ * rfkill_pause_polling(struct rfkill *rfkill)
+ *
+ * Pause polling -- say transmitter is off for other reasons.
+ * NOTE: not necessary for suspend/resume -- in that case the
+ * core stops polling anyway
+ */
+void rfkill_pause_polling(struct rfkill *rfkill);
 
-struct rfkill * __must_check rfkill_allocate(struct device *parent,
-					     enum rfkill_type type);
-void rfkill_free(struct rfkill *rfkill);
-int __must_check rfkill_register(struct rfkill *rfkill);
+/**
+ * rfkill_resume_polling(struct rfkill *rfkill)
+ *
+ * Pause polling -- say transmitter is off for other reasons.
+ * NOTE: not necessary for suspend/resume -- in that case the
+ * core stops polling anyway
+ */
+void rfkill_resume_polling(struct rfkill *rfkill);
+
+
+/**
+ * rfkill_unregister - Unregister a rfkill structure.
+ * @rfkill: rfkill structure to be unregistered
+ *
+ * This function should be called by the network driver during device
+ * teardown to destroy rfkill structure. Until it returns, the driver
+ * needs to be able to service method calls.
+ */
 void rfkill_unregister(struct rfkill *rfkill);
 
-int rfkill_force_state(struct rfkill *rfkill, enum rfkill_state state);
-int rfkill_set_default(enum rfkill_type type, enum rfkill_state state);
+/**
+ * rfkill_destroy - free rfkill structure
+ * @rfkill: rfkill structure to be destroyed
+ *
+ * Destroys the rfkill structure.
+ */
+void rfkill_destroy(struct rfkill *rfkill);
+
+/**
+ * rfkill_set_hw_state - Set the internal rfkill hardware block state
+ * @rfkill: pointer to the rfkill class to modify.
+ * @state: the current hardware block state to set
+ *
+ * rfkill drivers that get events when the hard-blocked state changes
+ * use this function to notify the rfkill core (and through that also
+ * userspace) of the current state -- they should also use this after
+ * resume if the state could have changed.
+ *
+ * You need not (but may) call this function if poll_state is assigned.
+ *
+ * This function can be called in any context, even from within rfkill
+ * callbacks.
+ *
+ * The function returns the combined block state (true if transmitter
+ * should be blocked) so that drivers need not keep track of the soft
+ * block state -- which they might not be able to.
+ */
+bool __must_check rfkill_set_hw_state(struct rfkill *rfkill, bool blocked);
+
+/**
+ * rfkill_set_sw_state - Set the internal rfkill software block state
+ * @rfkill: pointer to the rfkill class to modify.
+ * @state: the current software block state to set
+ *
+ * rfkill drivers that get events when the soft-blocked state changes
+ * (yes, some platforms directly act on input but allow changing again)
+ * use this function to notify the rfkill core (and through that also
+ * userspace) of the current state -- they should also use this after
+ * resume if the state could have changed.
+ *
+ * This function can be called in any context, even from within rfkill
+ * callbacks.
+ *
+ * The function returns the combined block state (true if transmitter
+ * should be blocked).
+ */
+bool rfkill_set_sw_state(struct rfkill *rfkill, bool blocked);
+
+/**
+ * rfkill_set_states - Set the internal rfkill block states
+ * @rfkill: pointer to the rfkill class to modify.
+ * @sw: the current software block state to set
+ * @hw: the current hardware block state to set
+ *
+ * This function can be called in any context, even from within rfkill
+ * callbacks.
+ */
+void rfkill_set_states(struct rfkill *rfkill, bool sw, bool hw);
 
 /**
- * rfkill_state_complement - return complementar state
- * @state: state to return the complement of
+ * rfkill_set_global_sw_state - set global sw block default
+ * @type: rfkill type to set default for
+ * @blocked: default to set
  *
- * Returns RFKILL_STATE_SOFT_BLOCKED if @state is RFKILL_STATE_UNBLOCKED,
- * returns RFKILL_STATE_UNBLOCKED otherwise.
+ * This function sets the global default -- use at boot if your platform has
+ * an rfkill switch. If not early enough this call may be ignored.
+ *
+ * XXX: instead of ignoring -- how about just updating all currently
+ *	registered drivers?
  */
-static inline enum rfkill_state rfkill_state_complement(enum rfkill_state state)
+void rfkill_set_global_sw_state(const enum rfkill_type type, bool blocked);
+#else /* !RFKILL */
+static inline struct rfkill * __must_check
+rfkill_alloc(const char *name,
+	     struct device *parent,
+	     const enum rfkill_type type,
+	     const struct rfkill_ops *ops,
+	     void *ops_data)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline int __must_check rfkill_register(struct rfkill *rfkill)
+{
+	if (rfkill == ERR_PTR(-ENODEV))
+		return 0;
+	return -EINVAL;
+}
+
+static inline void rfkill_pause_polling(struct rfkill *rfkill)
+{
+}
+
+static inline void rfkill_resume_polling(struct rfkill *rfkill)
+{
+}
+
+static inline void rfkill_unregister(struct rfkill *rfkill)
+{
+}
+
+static inline void rfkill_destroy(struct rfkill *rfkill)
+{
+}
+
+static inline bool rfkill_set_hw_state(struct rfkill *rfkill, bool blocked)
+{
+	return blocked;
+}
+
+static inline bool rfkill_set_sw_state(struct rfkill *rfkill, bool blocked)
+{
+	return blocked;
+}
+
+static inline void rfkill_set_states(struct rfkill *rfkill, bool sw, bool hw)
+{
+}
+
+static inline void rfkill_set_global_sw_state(const enum rfkill_type type,
+					      bool blocked)
 {
-	return (state == RFKILL_STATE_UNBLOCKED) ?
-		RFKILL_STATE_SOFT_BLOCKED : RFKILL_STATE_UNBLOCKED;
 }
+#endif /* RFKILL || RFKILL_MODULE */
+
 
+#ifdef CONFIG_RFKILL_LEDS
 /**
- * rfkill_get_led_name - Get the LED trigger name for the button's LED.
+ * rfkill_get_led_trigger_name - Get the LED trigger name for the button's LED.
  * This function might return a NULL pointer if registering of the
- * LED trigger failed.
- * Use this as "default_trigger" for the LED.
+ * LED trigger failed. Use this as "default_trigger" for the LED.
  */
-static inline char *rfkill_get_led_name(struct rfkill *rfkill)
-{
-#ifdef CONFIG_RFKILL_LEDS
-	return (char *)(rfkill->led_trigger.name);
+const char *rfkill_get_led_trigger_name(struct rfkill *rfkill);
+
+/**
+ * rfkill_set_led_trigger_name -- set the LED trigger name
+ * @rfkill: rfkill struct
+ * @name: LED trigger name
+ *
+ * This function sets the LED trigger name of the radio LED
+ * trigger that rfkill creates. It is optional, but if called
+ * must be called before rfkill_register() to be effective.
+ */
+void rfkill_set_led_trigger_name(struct rfkill *rfkill, const char *name);
 #else
+static inline const char *rfkill_get_led_trigger_name(struct rfkill *rfkill)
+{
 	return NULL;
-#endif
 }
 
+static inline void
+rfkill_set_led_trigger_name(struct rfkill *rfkill, const char *name)
+{
+}
+#endif
+
+#endif /* __KERNEL__ */
+
 #endif /* RFKILL_H */

commit 621cac85297de5ba655e3430b007dd2e0da91da6
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Fri Mar 27 14:14:31 2009 +0100

    rfkill: remove user_claim stuff
    
    Almost all drivers do not support user_claim, so remove it
    completely and always report -EOPNOTSUPP to userspace. Since
    userspace cannot really drive rfkill _anyway_ (due to the
    odd restrictions imposed by the documentation) having this
    code is just pointless.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index e1ec7d9aa49c..de18ef227e00 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -58,9 +58,6 @@ enum rfkill_state {
  * @type: Radio type which the button controls, the value stored
  *	here should be a value from enum rfkill_type.
  * @state: State of the switch, "UNBLOCKED" means radio can operate.
- * @user_claim_unsupported: Whether the hardware supports exclusive
- *	RF-kill control by userspace. Set this before registering.
- * @user_claim: Set when the switch is controlled exlusively by userspace.
  * @mutex: Guards switch state transitions.  It serializes callbacks
  *	and also protects the state.
  * @data: Pointer to the RF button drivers private data which will be
@@ -83,9 +80,6 @@ struct rfkill {
 	const char *name;
 	enum rfkill_type type;
 
-	bool user_claim_unsupported;
-	bool user_claim;
-
 	/* the mutex serializes callbacks and also protects
 	 * the state */
 	struct mutex mutex;

commit c1c6b14b22af0f85d05a70405dc3fba5de840c7b
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Mar 30 11:32:46 2009 +0200

    rfkill: remove deprecated state constants
    
    I only did superficial review, but these constants are stupid
    to have and without proper warnings nobody will review the
    code anyway, no amount of shouting will help.
    
    Also fix wimax to use correct states.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 164332cbb77c..e1ec7d9aa49c 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -52,14 +52,6 @@ enum rfkill_state {
 	RFKILL_STATE_MAX,		/* marker for last valid state */
 };
 
-/*
- * These are DEPRECATED, drivers using them should be verified to
- * comply with the rfkill usage guidelines in Documentation/rfkill.txt
- * and then converted to use the new names for rfkill_state
- */
-#define RFKILL_STATE_OFF RFKILL_STATE_SOFT_BLOCKED
-#define RFKILL_STATE_ON  RFKILL_STATE_UNBLOCKED
-
 /**
  * struct rfkill - rfkill control structure.
  * @name: Name of the switch.

commit 4dec9b807be757780ca3611a959ac22c28d292a7
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed Dec 10 17:48:48 2008 +0100

    rfkill: strip pointless notifier chain
    
    No users, so no reason to have it.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: Ivo van Doorn <IvDoorn@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index f376a93927f7..164332cbb77c 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -149,11 +149,4 @@ static inline char *rfkill_get_led_name(struct rfkill *rfkill)
 #endif
 }
 
-/* rfkill notification chain */
-#define RFKILL_STATE_CHANGED		0x0001	/* state of a normal rfkill
-						   switch has changed */
-
-int register_rfkill_notifier(struct notifier_block *nb);
-int unregister_rfkill_notifier(struct notifier_block *nb);
-
 #endif /* RFKILL_H */

commit f80b5e99c7dac5a9a0d72496cec5075a12cd1476
Author: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
Date:   Fri Nov 21 20:40:09 2008 -0200

    rfkill: preserve state across suspend
    
    The rfkill class API requires that the driver connected to a class
    call rfkill_force_state() on resume to update the real state of the
    rfkill controller, OR that it provides a get_state() hook.
    
    This means there is potentially a hidden call in the resume code flow
    that changes rfkill->state (i.e. rfkill_force_state()), so the
    previous state of the transmitter was being lost.
    
    The simplest and most future-proof way to fix this is to explicitly
    store the pre-sleep state on the rfkill structure, and restore from
    that on resume.
    
    Signed-off-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Acked-by: Ivo van Doorn <IvDoorn@gmail.com>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 4cd64b0d9825..f376a93927f7 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -108,6 +108,7 @@ struct rfkill {
 
 	struct device dev;
 	struct list_head node;
+	enum rfkill_state state_for_resume;
 };
 #define to_rfkill(d)	container_of(d, struct rfkill, dev)
 

commit 96c87607ac8f9b0e641d11ba6e57f8ec0214ea1c
Author: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
Date:   Sat Aug 2 15:11:00 2008 -0300

    rfkill: introduce RFKILL_STATE_MAX
    
    While it is interesting to not add last-enum-markers because it allows gcc
    to warn us of switch() statements missing a valid state, we really should
    be handling memory corruption on a rfkill state with default clauses,
    anyway.
    
    So add RFKILL_STATE_MAX and use it where applicable.  It makes for safer
    code in the long run.
    
    Signed-off-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Acked-by: Ivo van Doorn <IvDoorn@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index e92d8e94bb88..4cd64b0d9825 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -49,6 +49,7 @@ enum rfkill_state {
 	RFKILL_STATE_SOFT_BLOCKED = 0,	/* Radio output blocked */
 	RFKILL_STATE_UNBLOCKED    = 1,	/* Radio output allowed */
 	RFKILL_STATE_HARD_BLOCKED = 2,	/* Output blocked, non-overrideable */
+	RFKILL_STATE_MAX,		/* marker for last valid state */
 };
 
 /*

commit 77fba13ccc3a2a3db100892a4a6cc5e2f8290cc7
Author: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
Date:   Sat Aug 2 15:10:59 2008 -0300

    rfkill: add __must_check annotations
    
    rfkill is not a small, mere detail in wireless support.  Once it starts
    supporting rfkill and users start counting on that support, a wireless
    device is at risk of operating in dangerous conditions should rfkill
    support fail to properly activate.
    
    Therefore, add the required __must_check annotations on some key functions
    of the rfkill API, for which the wireless drivers absolutely MUST handle
    the failure mode safely in order to avoid a potentially dangerous situation
    where the wireless transmitter is left enabled when the user don't want it
    to.
    
    Signed-off-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Acked-by: Ivo van Doorn <IvDoorn@gmail.com>
    Cc: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index aa3c7d5852f6..e92d8e94bb88 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -110,9 +110,10 @@ struct rfkill {
 };
 #define to_rfkill(d)	container_of(d, struct rfkill, dev)
 
-struct rfkill *rfkill_allocate(struct device *parent, enum rfkill_type type);
+struct rfkill * __must_check rfkill_allocate(struct device *parent,
+					     enum rfkill_type type);
 void rfkill_free(struct rfkill *rfkill);
-int rfkill_register(struct rfkill *rfkill);
+int __must_check rfkill_register(struct rfkill *rfkill);
 void rfkill_unregister(struct rfkill *rfkill);
 
 int rfkill_force_state(struct rfkill *rfkill, enum rfkill_state state);

commit 9961920199ec88d6b581d3e38502088935925c04
Author: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
Date:   Sat Aug 2 15:10:58 2008 -0300

    rfkill: add default global states (v2)
    
    Add a second set of global states, "rfkill_default_states", to track the
    state that will be used when the first rfkill class of a given type is
    registered, and also to save "undo" information when rfkill_epo is called.
    
    Add a new exported function, rfkill_set_default(), which can be used by
    platform drivers to restore radio state saved by the platform across
    reboots or shutdown.
    
    Also, fix rfkill_epo to properly update rfkill_states, but still preserve a
    copy of the state so that we can undo the effect of rfkill_epo later if we
    want to.  Add rfkill_restore_states() to restore rfkill_states from the
    copy.
    
    Signed-off-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Acked-by: Ivo van Doorn <IvDoorn@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 741d1a62cc3f..aa3c7d5852f6 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -116,6 +116,7 @@ int rfkill_register(struct rfkill *rfkill);
 void rfkill_unregister(struct rfkill *rfkill);
 
 int rfkill_force_state(struct rfkill *rfkill, enum rfkill_state state);
+int rfkill_set_default(enum rfkill_type type, enum rfkill_state state);
 
 /**
  * rfkill_state_complement - return complementar state

commit f1b23361a0f15497d4c6795a2935b2e98064ddfb
Author: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
Date:   Mon Jul 21 21:18:19 2008 -0300

    rfkill: document the rfkill struct locking (v2)
    
    Reorder fields in struct rfkill and add comments to make it clear
    which fields are protected by rfkill->mutex.
    
    Signed-off-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Acked-by: Ivo van Doorn <IvDoorn@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index c5f6e54ec6ae..741d1a62cc3f 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -68,7 +68,8 @@ enum rfkill_state {
  * @user_claim_unsupported: Whether the hardware supports exclusive
  *	RF-kill control by userspace. Set this before registering.
  * @user_claim: Set when the switch is controlled exlusively by userspace.
- * @mutex: Guards switch state transitions
+ * @mutex: Guards switch state transitions.  It serializes callbacks
+ *	and also protects the state.
  * @data: Pointer to the RF button drivers private data which will be
  *	passed along when toggling radio state.
  * @toggle_radio(): Mandatory handler to control state of the radio.
@@ -89,12 +90,13 @@ struct rfkill {
 	const char *name;
 	enum rfkill_type type;
 
-	enum rfkill_state state;
 	bool user_claim_unsupported;
 	bool user_claim;
 
+	/* the mutex serializes callbacks and also protects
+	 * the state */
 	struct mutex mutex;
-
+	enum rfkill_state state;
 	void *data;
 	int (*toggle_radio)(void *data, enum rfkill_state state);
 	int (*get_state)(void *data, enum rfkill_state *state);

commit 5005657cbd0fd6f277f807c0612a6b6d4396a02c
Author: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
Date:   Mon Jun 23 17:46:42 2008 -0300

    rfkill: rename the rfkill_state states and add block-locked state
    
    The current naming of rfkill_state causes a lot of confusion: not only the
    "kill" in rfkill suggests negative logic, but also the fact that rfkill cannot
    turn anything on (it can just force something off or stop forcing something
    off) is often forgotten.
    
    Rename RFKILL_STATE_OFF to RFKILL_STATE_SOFT_BLOCKED (transmitter is blocked
    and will not operate; state can be changed by a toggle_radio request), and
    RFKILL_STATE_ON to RFKILL_STATE_UNBLOCKED (transmitter is not blocked, and may
    operate).
    
    Also, add a new third state, RFKILL_STATE_HARD_BLOCKED (transmitter is blocked
    and will not operate; state cannot be changed through a toggle_radio request),
    which is used by drivers to indicate a wireless transmiter was blocked by a
    hardware rfkill line that accepts no overrides.
    
    Keep the old names as #defines, but document them as deprecated.  This way,
    drivers can be converted to the new names *and* verified to actually use rfkill
    correctly one by one.
    
    Signed-off-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Acked-by: Ivo van Doorn <IvDoorn@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 98667becdee4..c5f6e54ec6ae 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -46,16 +46,25 @@ enum rfkill_type {
 };
 
 enum rfkill_state {
-	RFKILL_STATE_OFF	= 0,	/* Radio output blocked */
-	RFKILL_STATE_ON		= 1,	/* Radio output active */
+	RFKILL_STATE_SOFT_BLOCKED = 0,	/* Radio output blocked */
+	RFKILL_STATE_UNBLOCKED    = 1,	/* Radio output allowed */
+	RFKILL_STATE_HARD_BLOCKED = 2,	/* Output blocked, non-overrideable */
 };
 
+/*
+ * These are DEPRECATED, drivers using them should be verified to
+ * comply with the rfkill usage guidelines in Documentation/rfkill.txt
+ * and then converted to use the new names for rfkill_state
+ */
+#define RFKILL_STATE_OFF RFKILL_STATE_SOFT_BLOCKED
+#define RFKILL_STATE_ON  RFKILL_STATE_UNBLOCKED
+
 /**
  * struct rfkill - rfkill control structure.
  * @name: Name of the switch.
  * @type: Radio type which the button controls, the value stored
  *	here should be a value from enum rfkill_type.
- * @state: State of the switch, "ON" means radio can operate.
+ * @state: State of the switch, "UNBLOCKED" means radio can operate.
  * @user_claim_unsupported: Whether the hardware supports exclusive
  *	RF-kill control by userspace. Set this before registering.
  * @user_claim: Set when the switch is controlled exlusively by userspace.
@@ -63,8 +72,12 @@ enum rfkill_state {
  * @data: Pointer to the RF button drivers private data which will be
  *	passed along when toggling radio state.
  * @toggle_radio(): Mandatory handler to control state of the radio.
+ *	only RFKILL_STATE_SOFT_BLOCKED and RFKILL_STATE_UNBLOCKED are
+ *	valid parameters.
  * @get_state(): handler to read current radio state from hardware,
  *      may be called from atomic context, should return 0 on success.
+ *      Either this handler OR judicious use of rfkill_force_state() is
+ *      MANDATORY for any driver capable of RFKILL_STATE_HARD_BLOCKED.
  * @led_trigger: A LED trigger for this button's LED.
  * @dev: Device structure integrating the switch into device tree.
  * @node: Used to place switch into list of all switches known to the
@@ -102,6 +115,19 @@ void rfkill_unregister(struct rfkill *rfkill);
 
 int rfkill_force_state(struct rfkill *rfkill, enum rfkill_state state);
 
+/**
+ * rfkill_state_complement - return complementar state
+ * @state: state to return the complement of
+ *
+ * Returns RFKILL_STATE_SOFT_BLOCKED if @state is RFKILL_STATE_UNBLOCKED,
+ * returns RFKILL_STATE_UNBLOCKED otherwise.
+ */
+static inline enum rfkill_state rfkill_state_complement(enum rfkill_state state)
+{
+	return (state == RFKILL_STATE_UNBLOCKED) ?
+		RFKILL_STATE_SOFT_BLOCKED : RFKILL_STATE_UNBLOCKED;
+}
+
 /**
  * rfkill_get_led_name - Get the LED trigger name for the button's LED.
  * This function might return a NULL pointer if registering of the

commit 79399a8d1908f6a406e82d23c5a9937e1722ed3a
Author: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
Date:   Mon Jun 23 17:23:03 2008 -0300

    rfkill: add notifier chains support
    
    Add a notifier chain for use by the rfkill class.  This notifier chain
    signals the following events (more to be added when needed):
    
      1. rfkill: rfkill device state has changed
    
    A pointer to the rfkill struct will be passed as a parameter.
    
    The notifier message types have been added to include/linux/rfkill.h
    instead of to include/linux/notifier.h in order to avoid the madness of
    modifying a header used globally (and that triggers an almost full tree
    rebuild every time it is touched) with information that is of interest only
    to code that includes the rfkill.h header.
    
    Signed-off-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Acked-by: Ivo van Doorn <IvDoorn@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index c0cab7d37828..98667becdee4 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -117,4 +117,11 @@ static inline char *rfkill_get_led_name(struct rfkill *rfkill)
 #endif
 }
 
+/* rfkill notification chain */
+#define RFKILL_STATE_CHANGED		0x0001	/* state of a normal rfkill
+						   switch has changed */
+
+int register_rfkill_notifier(struct notifier_block *nb);
+int unregister_rfkill_notifier(struct notifier_block *nb);
+
 #endif /* RFKILL_H */

commit 477576a073699783abb53ae14993d5d41c66301d
Author: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
Date:   Mon Jun 23 17:23:01 2008 -0300

    rfkill: add the WWAN radio type
    
    Unfortunately, instead of adding a generic Wireless WAN type, a technology-
    specific type (WiMAX) was added.  That's useless for other WWAN devices,
    such as EDGE, UMTS, X-RTT and other such radios.
    
    Add a WWAN rfkill type for generic wireless WAN devices.  No keys are added
    as most devices really want to use KEY_WLAN for WWAN control (in a cycle of
    none, WLAN, WWAN, WLAN+WWAN) and need no specific keycode added.
    
    Signed-off-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Acked-by: Ivo van Doorn <IvDoorn@gmail.com>
    Cc: Iñaky Pérez-González <inaky.perez-gonzalez@intel.com>
    Cc: David S. Miller <davem@davemloft.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 844e96114861..c0cab7d37828 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -34,12 +34,14 @@
  * RFKILL_TYPE_BLUETOOTH: switch is on a bluetooth device.
  * RFKILL_TYPE_UWB: switch is on a ultra wideband device.
  * RFKILL_TYPE_WIMAX: switch is on a WiMAX device.
+ * RFKILL_TYPE_WWAN: switch is on a wireless WAN device.
  */
 enum rfkill_type {
 	RFKILL_TYPE_WLAN ,
 	RFKILL_TYPE_BLUETOOTH,
 	RFKILL_TYPE_UWB,
 	RFKILL_TYPE_WIMAX,
+	RFKILL_TYPE_WWAN,
 	RFKILL_TYPE_MAX,
 };
 

commit 801e49af4c1a9b988ba0d25de2b368c99c3bf2b3
Author: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
Date:   Mon Jun 23 17:23:00 2008 -0300

    rfkill: add read-write rfkill switch support
    
    Currently, rfkill support for read/write rfkill switches is hacked through
    a round-trip over the input layer and rfkill-input to let a driver sync
    rfkill->state to hardware changes.
    
    This is buggy and sub-optimal.  It causes real problems.  It is best to
    think of the rfkill class as supporting only write-only switches at the
    moment.
    
    In order to implement the read/write functionality properly:
    
    Add a get_state() hook that is called by the class every time it needs to
    fetch the current state of the switch.  Add a call to this hook every time
    the *current* state of the radio plays a role in a decision.
    
    Also add a force_state() method that can be used to forcefully syncronize
    the class' idea of the current state of the switch.  This allows for a
    faster implementation of the read/write functionality, as a driver which
    get events on switch changes can avoid the need for a get_state() hook.
    
    If the get_state() hook is left as NULL, current behaviour is maintained,
    so this change is fully backwards compatible with the current rfkill
    drivers.
    
    For hardware that issues events when the rfkill state changes, leave
    get_state() NULL in the rfkill struct, set the initial state properly
    before registering with the rfkill class, and use the force_state() method
    in the driver to keep the rfkill interface up-to-date.
    
    get_state() can be called by the class from atomic context. It must not
    sleep.
    
    Signed-off-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Acked-by: Ivo van Doorn <IvDoorn@gmail.com>
    Cc: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index ca89ae1b0219..844e96114861 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -61,6 +61,8 @@ enum rfkill_state {
  * @data: Pointer to the RF button drivers private data which will be
  *	passed along when toggling radio state.
  * @toggle_radio(): Mandatory handler to control state of the radio.
+ * @get_state(): handler to read current radio state from hardware,
+ *      may be called from atomic context, should return 0 on success.
  * @led_trigger: A LED trigger for this button's LED.
  * @dev: Device structure integrating the switch into device tree.
  * @node: Used to place switch into list of all switches known to the
@@ -80,6 +82,7 @@ struct rfkill {
 
 	void *data;
 	int (*toggle_radio)(void *data, enum rfkill_state state);
+	int (*get_state)(void *data, enum rfkill_state *state);
 
 #ifdef CONFIG_RFKILL_LEDS
 	struct led_trigger led_trigger;
@@ -95,6 +98,8 @@ void rfkill_free(struct rfkill *rfkill);
 int rfkill_register(struct rfkill *rfkill);
 void rfkill_unregister(struct rfkill *rfkill);
 
+int rfkill_force_state(struct rfkill *rfkill, enum rfkill_state state);
+
 /**
  * rfkill_get_led_name - Get the LED trigger name for the button's LED.
  * This function might return a NULL pointer if registering of the

commit f3146aff7f283c8699e0c97df6307a705786eeba
Author: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
Date:   Mon Jun 23 17:22:56 2008 -0300

    rfkill: clarify meaning of rfkill states
    
    rfkill really should have been named rfswitch.  As it is, one can get
    confused whether RFKILL_STATE_ON means the KILL switch is on (and
    therefore, the radio is being *blocked* from operating), or whether it
    means the RADIO rf output is on.
    
    Clearly state that RFKILL_STATE_ON means the radio is *unblocked* from
    operating (i.e. there is no rf killing going on).
    
    Signed-off-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Acked-by: Ivo van Doorn <IvDoorn@gmail.com>
    Cc: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index e3ab21d7fc7f..ca89ae1b0219 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -44,8 +44,8 @@ enum rfkill_type {
 };
 
 enum rfkill_state {
-	RFKILL_STATE_OFF	= 0,
-	RFKILL_STATE_ON		= 1,
+	RFKILL_STATE_OFF	= 0,	/* Radio output blocked */
+	RFKILL_STATE_ON		= 1,	/* Radio output active */
 };
 
 /**
@@ -53,7 +53,7 @@ enum rfkill_state {
  * @name: Name of the switch.
  * @type: Radio type which the button controls, the value stored
  *	here should be a value from enum rfkill_type.
- * @state: State of the switch (on/off).
+ * @state: State of the switch, "ON" means radio can operate.
  * @user_claim_unsupported: Whether the hardware supports exclusive
  *	RF-kill control by userspace. Set this before registering.
  * @user_claim: Set when the switch is controlled exlusively by userspace.

commit 303d9bf6bb64ead8e3f1d7e29904a4025502e591
Author: Iñaky Pérez-González <inaky.perez-gonzalez@intel.com>
Date:   Wed Jan 23 13:40:27 2008 -0800

    rfkill: add the WiMAX radio type
    
    Teach rfkill about wimax radios.
    
    Had to define a KEY_WIMAX as a 'key for disabling only wimax radios',
    as other radio technologies have. This makes sense as hardware has
    specific keys for disabling specific radios.
    
    The RFKILL enabling part is, otherwise, a copy and paste of any other
    radio technology.
    
    Signed-off-by: Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Signed-off-by: Ivo van Doorn <IvDoorn@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 0ce5e0b52dbd..e3ab21d7fc7f 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -33,11 +33,13 @@
  * RFKILL_TYPE_WLAN: switch is on a 802.11 wireless network device.
  * RFKILL_TYPE_BLUETOOTH: switch is on a bluetooth device.
  * RFKILL_TYPE_UWB: switch is on a ultra wideband device.
+ * RFKILL_TYPE_WIMAX: switch is on a WiMAX device.
  */
 enum rfkill_type {
 	RFKILL_TYPE_WLAN ,
 	RFKILL_TYPE_BLUETOOTH,
 	RFKILL_TYPE_UWB,
+	RFKILL_TYPE_WIMAX,
 	RFKILL_TYPE_MAX,
 };
 

commit 20405c08412a4d89357870d7220f9fb1c458b286
Author: Michael Buesch <mb@bu3sch.de>
Date:   Thu Sep 27 21:34:23 2007 +0200

    [RFKILL]: Add support for hardware-only rfkill buttons
    
    Buttons that work directly on hardware cannot support
    the "user_claim" functionality. Add a flag to signal
    this and return -EOPNOTSUPP in this case.
    b43 is such a device.
    
    Signed-off-by: Michael Buesch <mb@bu3sch.de>
    Acked-by: Ivo van Doorn <IvDoorn@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 26fddea12c25..0ce5e0b52dbd 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -52,6 +52,8 @@ enum rfkill_state {
  * @type: Radio type which the button controls, the value stored
  *	here should be a value from enum rfkill_type.
  * @state: State of the switch (on/off).
+ * @user_claim_unsupported: Whether the hardware supports exclusive
+ *	RF-kill control by userspace. Set this before registering.
  * @user_claim: Set when the switch is controlled exlusively by userspace.
  * @mutex: Guards switch state transitions
  * @data: Pointer to the RF button drivers private data which will be
@@ -69,6 +71,7 @@ struct rfkill {
 	enum rfkill_type type;
 
 	enum rfkill_state state;
+	bool user_claim_unsupported;
 	bool user_claim;
 
 	struct mutex mutex;

commit 135900c182c321a4888ec496b014e6707272faca
Author: Michael Buesch <mb@bu3sch.de>
Date:   Thu Sep 27 21:33:12 2007 +0200

    [RFKILL]: Add support for an rfkill LED.
    
    This adds a LED trigger.
    
    Signed-off-by: Michael Buesch <mb@bu3sch.de>
    Acked-by: Ivo van Doorn <IvDoorn@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index d76397ca95ad..26fddea12c25 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -26,6 +26,7 @@
 #include <linux/list.h>
 #include <linux/mutex.h>
 #include <linux/device.h>
+#include <linux/leds.h>
 
 /**
  * enum rfkill_type - type of rfkill switch.
@@ -56,6 +57,7 @@ enum rfkill_state {
  * @data: Pointer to the RF button drivers private data which will be
  *	passed along when toggling radio state.
  * @toggle_radio(): Mandatory handler to control state of the radio.
+ * @led_trigger: A LED trigger for this button's LED.
  * @dev: Device structure integrating the switch into device tree.
  * @node: Used to place switch into list of all switches known to the
  *	the system.
@@ -74,6 +76,10 @@ struct rfkill {
 	void *data;
 	int (*toggle_radio)(void *data, enum rfkill_state state);
 
+#ifdef CONFIG_RFKILL_LEDS
+	struct led_trigger led_trigger;
+#endif
+
 	struct device dev;
 	struct list_head node;
 };
@@ -84,4 +90,19 @@ void rfkill_free(struct rfkill *rfkill);
 int rfkill_register(struct rfkill *rfkill);
 void rfkill_unregister(struct rfkill *rfkill);
 
+/**
+ * rfkill_get_led_name - Get the LED trigger name for the button's LED.
+ * This function might return a NULL pointer if registering of the
+ * LED trigger failed.
+ * Use this as "default_trigger" for the LED.
+ */
+static inline char *rfkill_get_led_name(struct rfkill *rfkill)
+{
+#ifdef CONFIG_RFKILL_LEDS
+	return (char *)(rfkill->led_trigger.name);
+#else
+	return NULL;
+#endif
+}
+
 #endif /* RFKILL_H */

commit fe242cfd3390b1c7d54d60f7ebb6a4054804cd41
Author: Ivo van Doorn <IvDoorn@gmail.com>
Date:   Thu Sep 27 14:57:05 2007 -0700

    [RFKILL]: Move rfkill_switch_all out of global header
    
    rfkill_switch_all shouldn't be called by drivers directly,
    instead they should send a signal over the input device.
    
    To prevent confusion for driver developers, move the
    function into a rfkill private header.
    
    Signed-off-by: Ivo van Doorn <IvDoorn@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 8909682415dc..d76397ca95ad 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -2,7 +2,7 @@
 #define __RFKILL_H
 
 /*
- * Copyright (C) 2006 Ivo van Doorn
+ * Copyright (C) 2006 - 2007 Ivo van Doorn
  * Copyright (C) 2007 Dmitry Torokhov
  *
  * This program is free software; you can redistribute it and/or modify
@@ -84,6 +84,4 @@ void rfkill_free(struct rfkill *rfkill);
 int rfkill_register(struct rfkill *rfkill);
 void rfkill_unregister(struct rfkill *rfkill);
 
-void rfkill_switch_all(enum rfkill_type type, enum rfkill_state state);
-
 #endif /* RFKILL_H */

commit 279632be3f546f4d88bdb086fa71479bcde9d641
Author: Michael Buesch <mb@bu3sch.de>
Date:   Thu Sep 27 14:42:42 2007 +0200

    [PATCH] rfkill: Fix documentation typos
    
    Signed-off-by: Michael Buesch <mb@bu3sch.de>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index f9a50dab4168..8909682415dc 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -29,9 +29,9 @@
 
 /**
  * enum rfkill_type - type of rfkill switch.
- * RFKILL_TYPE_WLAN: switch is no a Wireless network devices.
- * RFKILL_TYPE_BlUETOOTH: switch is on a bluetooth device.
- * RFKILL_TYPE_UWB: switch is on a Ultra wideband device.
+ * RFKILL_TYPE_WLAN: switch is on a 802.11 wireless network device.
+ * RFKILL_TYPE_BLUETOOTH: switch is on a bluetooth device.
+ * RFKILL_TYPE_UWB: switch is on a ultra wideband device.
  */
 enum rfkill_type {
 	RFKILL_TYPE_WLAN ,

commit e0665486b78b8efb9c25019ad29b4a4c9c1e9dfc
Author: Ivo van Doorn <IvDoorn@gmail.com>
Date:   Thu Sep 13 09:21:31 2007 +0200

    [RFKILL]: Add support for ultrawideband
    
    This patch will add support for UWB keys to rfkill,
    support for this has been requested by Inaky.
    
    Signed-off-by: Ivo van Doorn <IvDoorn@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index c4546e15c853..f9a50dab4168 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -31,10 +31,12 @@
  * enum rfkill_type - type of rfkill switch.
  * RFKILL_TYPE_WLAN: switch is no a Wireless network devices.
  * RFKILL_TYPE_BlUETOOTH: switch is on a bluetooth device.
+ * RFKILL_TYPE_UWB: switch is on a Ultra wideband device.
  */
 enum rfkill_type {
 	RFKILL_TYPE_WLAN ,
 	RFKILL_TYPE_BLUETOOTH,
+	RFKILL_TYPE_UWB,
 	RFKILL_TYPE_MAX,
 };
 

commit 234a0ca6f1d67ba4c3c3fc8378bbd98d722468e1
Author: Ivo van Doorn <IvDoorn@gmail.com>
Date:   Thu Sep 13 09:20:42 2007 +0200

    [RFKILL]: Remove IRDA
    
    As Dmitry pointed out earlier, rfkill-input.c
    doesn't support irda because there are no users
    and we shouldn't add unrequired KEY_ defines.
    
    However, RFKILL_TYPE_IRDA was defined in the
    rfkill.h header file and would confuse people
    about whether it is implemented or not.
    
    This patch removes IRDA support completely,
    so it can be added whenever a driver wants the
    feature.
    
    Signed-off-by: Ivo van Doorn <IvDoorn@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index a8a6ea809da0..c4546e15c853 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -31,13 +31,11 @@
  * enum rfkill_type - type of rfkill switch.
  * RFKILL_TYPE_WLAN: switch is no a Wireless network devices.
  * RFKILL_TYPE_BlUETOOTH: switch is on a bluetooth device.
- * RFKILL_TYPE_IRDA: switch is on an infrared devices.
  */
 enum rfkill_type {
-	RFKILL_TYPE_WLAN = 0,
-	RFKILL_TYPE_BLUETOOTH = 1,
-	RFKILL_TYPE_IRDA = 2,
-	RFKILL_TYPE_MAX = 3,
+	RFKILL_TYPE_WLAN ,
+	RFKILL_TYPE_BLUETOOTH,
+	RFKILL_TYPE_MAX,
 };
 
 enum rfkill_state {

commit c36befb52350fa76bf3cb03d13ba2e17dbe8a508
Author: Ivo van Doorn <IvDoorn@gmail.com>
Date:   Tue Jun 5 00:04:46 2007 -0700

    [RFKILL]: Make rfkill->name const
    
    The rfkill name can be made const safely,
    this makes the compiler happy when drivers make
    it point to some const string used elsewhere.
    
    Signed-off-by: Ivo van Doorn <IvDoorn@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index 7c1ffbab7865..a8a6ea809da0 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -63,7 +63,7 @@ enum rfkill_state {
  * This structure represents a RF switch located on a network device.
  */
 struct rfkill {
-	char *name;
+	const char *name;
 	enum rfkill_type type;
 
 	enum rfkill_state state;

commit cf4328cd949c2086091c62c5685f1580fe9b55e4
Author: Ivo van Doorn <IvDoorn@gmail.com>
Date:   Mon May 7 00:34:20 2007 -0700

    [NET]: rfkill: add support for input key to control wireless radio
    
    The RF kill patch that provides infrastructure for implementing
    switches controlling radio states on various network and other cards.
    
    [dtor@insightbb.com: address review comments]
    [akpm@linux-foundation.org: cleanups, build fixes]
    
    Signed-off-by: Ivo van Doorn <IvDoorn@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
new file mode 100644
index 000000000000..7c1ffbab7865
--- /dev/null
+++ b/include/linux/rfkill.h
@@ -0,0 +1,89 @@
+#ifndef __RFKILL_H
+#define __RFKILL_H
+
+/*
+ * Copyright (C) 2006 Ivo van Doorn
+ * Copyright (C) 2007 Dmitry Torokhov
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the
+ * Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/device.h>
+
+/**
+ * enum rfkill_type - type of rfkill switch.
+ * RFKILL_TYPE_WLAN: switch is no a Wireless network devices.
+ * RFKILL_TYPE_BlUETOOTH: switch is on a bluetooth device.
+ * RFKILL_TYPE_IRDA: switch is on an infrared devices.
+ */
+enum rfkill_type {
+	RFKILL_TYPE_WLAN = 0,
+	RFKILL_TYPE_BLUETOOTH = 1,
+	RFKILL_TYPE_IRDA = 2,
+	RFKILL_TYPE_MAX = 3,
+};
+
+enum rfkill_state {
+	RFKILL_STATE_OFF	= 0,
+	RFKILL_STATE_ON		= 1,
+};
+
+/**
+ * struct rfkill - rfkill control structure.
+ * @name: Name of the switch.
+ * @type: Radio type which the button controls, the value stored
+ *	here should be a value from enum rfkill_type.
+ * @state: State of the switch (on/off).
+ * @user_claim: Set when the switch is controlled exlusively by userspace.
+ * @mutex: Guards switch state transitions
+ * @data: Pointer to the RF button drivers private data which will be
+ *	passed along when toggling radio state.
+ * @toggle_radio(): Mandatory handler to control state of the radio.
+ * @dev: Device structure integrating the switch into device tree.
+ * @node: Used to place switch into list of all switches known to the
+ *	the system.
+ *
+ * This structure represents a RF switch located on a network device.
+ */
+struct rfkill {
+	char *name;
+	enum rfkill_type type;
+
+	enum rfkill_state state;
+	bool user_claim;
+
+	struct mutex mutex;
+
+	void *data;
+	int (*toggle_radio)(void *data, enum rfkill_state state);
+
+	struct device dev;
+	struct list_head node;
+};
+#define to_rfkill(d)	container_of(d, struct rfkill, dev)
+
+struct rfkill *rfkill_allocate(struct device *parent, enum rfkill_type type);
+void rfkill_free(struct rfkill *rfkill);
+int rfkill_register(struct rfkill *rfkill);
+void rfkill_unregister(struct rfkill *rfkill);
+
+void rfkill_switch_all(enum rfkill_type type, enum rfkill_state state);
+
+#endif /* RFKILL_H */
