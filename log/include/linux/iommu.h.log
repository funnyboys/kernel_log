commit 4e3a16ee9148e966678bbc713579235422271a63
Merge: 9413b9a690ec 431275afdc71
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 8 11:42:23 2020 -0700

    Merge tag 'iommu-updates-v5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/joro/iommu
    
    Pull iommu updates from Joerg Roedel:
     "A big part of this is a change in how devices get connected to IOMMUs
      in the core code. It contains the change from the old add_device() /
      remove_device() to the new probe_device() / release_device()
      call-backs.
    
      As a result functionality that was previously in the IOMMU drivers has
      been moved to the IOMMU core code, including IOMMU group allocation
      for each device. The reason for this change was to get more robust
      allocation of default domains for the iommu groups.
    
      A couple of fixes were necessary after this was merged into the IOMMU
      tree, but there are no known bugs left. The last fix is applied on-top
      of the merge commit for the topic branches.
    
      Other than that change, we have:
    
       - Removal of the driver private domain handling in the Intel VT-d
         driver. This was fragile code and I am glad it is gone now.
    
       - More Intel VT-d updates from Lu Baolu:
          - Nested Shared Virtual Addressing (SVA) support to the Intel VT-d
            driver
          - Replacement of the Intel SVM interfaces to the common IOMMU SVA
            API
          - SVA Page Request draining support
    
       - ARM-SMMU Updates from Will:
          - Avoid mapping reserved MMIO space on SMMUv3, so that it can be
            claimed by the PMU driver
          - Use xarray to manage ASIDs on SMMUv3
          - Reword confusing shutdown message
          - DT compatible string updates
          - Allow implementations to override the default domain type
    
       - A new IOMMU driver for the Allwinner Sun50i platform
    
       - Support for ATS gets disabled for untrusted devices (like
         Thunderbolt devices). This includes a PCI patch, acked by Bjorn.
    
       - Some cleanups to the AMD IOMMU driver to make more use of IOMMU
         core features.
    
       - Unification of some printk formats in the Intel and AMD IOMMU
         drivers and in the IOVA code.
    
       - Updates for DT bindings
    
       - A number of smaller fixes and cleanups.
    
    * tag 'iommu-updates-v5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/joro/iommu: (109 commits)
      iommu: Check for deferred attach in iommu_group_do_dma_attach()
      iommu/amd: Remove redundant devid checks
      iommu/amd: Store dev_data as device iommu private data
      iommu/amd: Merge private header files
      iommu/amd: Remove PD_DMA_OPS_MASK
      iommu/amd: Consolidate domain allocation/freeing
      iommu/amd: Free page-table in protection_domain_free()
      iommu/amd: Allocate page-table in protection_domain_init()
      iommu/amd: Let free_pagetable() not rely on domain->pt_root
      iommu/amd: Unexport get_dev_data()
      iommu/vt-d: Fix compile warning
      iommu/vt-d: Remove real DMA lookup in find_domain
      iommu/vt-d: Allocate domain info for real DMA sub-devices
      iommu/vt-d: Only clear real DMA device's context entries
      iommu: Remove iommu_sva_ops::mm_exit()
      uacce: Remove mm_exit() op
      iommu/sun50i: Constify sun50i_iommu_ops
      iommu/hyper-v: Constify hyperv_ir_domain_ops
      iommu/vt-d: Use pci_ats_supported()
      iommu/arm-smmu-v3: Use pci_ats_supported()
      ...

commit cc69fc4861705c27c0506d39189015d7404129ed
Merge: 3d77e6a8804a c4e0f3b24004 79074f61c022 0299a1a81ca0 71974cfb6737 9f510d1e4299 edcc40d2ab5f 736c3333e397
Author: Joerg Roedel <jroedel@suse.de>
Date:   Tue Jun 2 10:32:04 2020 +0200

    Merge branches 'arm/msm', 'arm/allwinner', 'arm/smmu', 'x86/vt-d', 'hyper-v', 'core' and 'x86/amd' into next

commit edcc40d2ab5f47f205c2dd2a9aeedd8c77de050a
Author: Jean-Philippe Brucker <jean-philippe@linaro.org>
Date:   Thu Apr 23 14:53:30 2020 +0200

    iommu: Remove iommu_sva_ops::mm_exit()
    
    After binding a device to an mm, device drivers currently need to
    register a mm_exit handler. This function is called when the mm exits,
    to gracefully stop DMA targeting the address space and flush page faults
    to the IOMMU.
    
    This is deemed too complex for the MMU release() notifier, which may be
    triggered by any mmput() invocation, from about 120 callsites [1]. The
    upcoming SVA module has an example of such complexity: the I/O Page
    Fault handler would need to call mmput_async() instead of mmput() after
    handling an IOPF, to avoid triggering the release() notifier which would
    in turn drain the IOPF queue and lock up.
    
    Another concern is the DMA stop function taking too long, up to several
    minutes [2]. For some mmput() callers this may disturb other users. For
    example, if the OOM killer picks the mm bound to a device as the victim
    and that mm's memory is locked, if the release() takes too long, it
    might choose additional innocent victims to kill.
    
    To simplify the MMU release notifier, don't forward the notification to
    device drivers. Since they don't stop DMA on mm exit anymore, the PASID
    lifetime is extended:
    
    (1) The device driver calls bind(). A PASID is allocated.
    
      Here any DMA fault is handled by mm, and on error we don't print
      anything to dmesg. Userspace can easily trigger errors by issuing DMA
      on unmapped buffers.
    
    (2) exit_mmap(), for example the process took a SIGKILL. This step
        doesn't happen during normal operations. Remove the pgd from the
        PASID table, since the page tables are about to be freed. Invalidate
        the IOTLBs.
    
      Here the device may still perform DMA on the address space. Incoming
      transactions are aborted but faults aren't printed out. ATS
      Translation Requests return Successful Translation Completions with
      R=W=0. PRI Page Requests return with Invalid Request.
    
    (3) The device driver stops DMA, possibly following release of a fd, and
        calls unbind(). PASID table is cleared, IOTLB invalidated if
        necessary. The page fault queues are drained, and the PASID is
        freed.
    
      If DMA for that PASID is still running here, something went seriously
      wrong and errors should be reported.
    
    For now remove iommu_sva_ops entirely. We might need to re-introduce
    them at some point, for example to notify device drivers of unhandled
    IOPF.
    
    [1] https://lore.kernel.org/linux-iommu/20200306174239.GM31668@ziepe.ca/
    [2] https://lore.kernel.org/linux-iommu/4d68da96-0ad5-b412-5987-2f7a6aa796c3@amd.com/
    
    Signed-off-by: Jean-Philippe Brucker <jean-philippe@linaro.org>
    Acked-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
    Acked-by: Lu Baolu <baolu.lu@linux.intel.com>
    Link: https://lore.kernel.org/r/20200423125329.782066-3-jean-philippe@linaro.org
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 7cfd2dddb49d..08d3506172a1 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -53,8 +53,6 @@ struct iommu_fault_event;
 
 typedef int (*iommu_fault_handler_t)(struct iommu_domain *,
 			struct device *, unsigned long, int, void *);
-typedef int (*iommu_mm_exit_handler_t)(struct device *dev, struct iommu_sva *,
-				       void *);
 typedef int (*iommu_dev_fault_handler_t)(struct iommu_fault *, void *);
 
 struct iommu_domain_geometry {
@@ -171,25 +169,6 @@ enum iommu_dev_features {
 
 #define IOMMU_PASID_INVALID	(-1U)
 
-/**
- * struct iommu_sva_ops - device driver callbacks for an SVA context
- *
- * @mm_exit: called when the mm is about to be torn down by exit_mmap. After
- *           @mm_exit returns, the device must not issue any more transaction
- *           with the PASID given as argument.
- *
- *           The @mm_exit handler is allowed to sleep. Be careful about the
- *           locks taken in @mm_exit, because they might lead to deadlocks if
- *           they are also held when dropping references to the mm. Consider the
- *           following call chain:
- *           mutex_lock(A); mmput(mm) -> exit_mm() -> @mm_exit() -> mutex_lock(A)
- *           Using mmput_async() prevents this scenario.
- *
- */
-struct iommu_sva_ops {
-	iommu_mm_exit_handler_t mm_exit;
-};
-
 #ifdef CONFIG_IOMMU_API
 
 /**
@@ -616,7 +595,6 @@ struct iommu_fwspec {
  */
 struct iommu_sva {
 	struct device			*dev;
-	const struct iommu_sva_ops	*ops;
 };
 
 int iommu_fwspec_init(struct device *dev, struct fwnode_handle *iommu_fwnode,
@@ -664,8 +642,6 @@ struct iommu_sva *iommu_sva_bind_device(struct device *dev,
 					struct mm_struct *mm,
 					void *drvdata);
 void iommu_sva_unbind_device(struct iommu_sva *handle);
-int iommu_sva_set_ops(struct iommu_sva *handle,
-		      const struct iommu_sva_ops *ops);
 int iommu_sva_get_pasid(struct iommu_sva *handle);
 
 #else /* CONFIG_IOMMU_API */
@@ -1069,12 +1045,6 @@ static inline void iommu_sva_unbind_device(struct iommu_sva *handle)
 {
 }
 
-static inline int iommu_sva_set_ops(struct iommu_sva *handle,
-				    const struct iommu_sva_ops *ops)
-{
-	return -EINVAL;
-}
-
 static inline int iommu_sva_get_pasid(struct iommu_sva *handle)
 {
 	return IOMMU_PASID_INVALID;

commit 69cf449166987d9a041020be6422ee7bf94a7228
Author: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
Date:   Wed May 13 15:47:21 2020 -0700

    iommu: Remove functions that support private domain
    
    After moving iommu_group setup to iommu core code [1][2] and removing
    private domain support in vt-d [3], there are no users for functions such
    as iommu_request_dm_for_dev(), iommu_request_dma_domain_for_dev() and
    request_default_domain_for_dev(). So, remove these functions.
    
    [1] commit dce8d6964ebd ("iommu/amd: Convert to probe/release_device()
        call-backs")
    [2] commit e5d1841f18b2 ("iommu/vt-d: Convert to probe/release_device()
        call-backs")
    [3] commit 327d5b2fee91 ("iommu/vt-d: Allow 32bit devices to uses DMA
        domain")
    
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Lu Baolu <baolu.lu@linux.intel.com>
    Link: https://lore.kernel.org/r/20200513224721.20504-1-sai.praneeth.prakhya@intel.com
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 7cfd2dddb49d..78a26ae5c2b6 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -482,8 +482,6 @@ extern void iommu_get_resv_regions(struct device *dev, struct list_head *list);
 extern void iommu_put_resv_regions(struct device *dev, struct list_head *list);
 extern void generic_iommu_put_resv_regions(struct device *dev,
 					   struct list_head *list);
-extern int iommu_request_dm_for_dev(struct device *dev);
-extern int iommu_request_dma_domain_for_dev(struct device *dev);
 extern void iommu_set_default_passthrough(bool cmd_line);
 extern void iommu_set_default_translated(bool cmd_line);
 extern bool iommu_default_passthrough(void);
@@ -804,16 +802,6 @@ static inline int iommu_get_group_resv_regions(struct iommu_group *group,
 	return -ENODEV;
 }
 
-static inline int iommu_request_dm_for_dev(struct device *dev)
-{
-	return -ENODEV;
-}
-
-static inline int iommu_request_dma_domain_for_dev(struct device *dev)
-{
-	return -ENODEV;
-}
-
 static inline void iommu_set_default_passthrough(bool cmd_line)
 {
 }

commit 48530d9fab0d3bf08827f9167be54acf66d4d457
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Wed May 13 15:32:10 2020 +0200

    iommu: add generic helper for mapping sgtable objects
    
    struct sg_table is a common structure used for describing a memory
    buffer. It consists of a scatterlist with memory pages and DMA addresses
    (sgl entry), as well as the number of scatterlist entries: CPU pages
    (orig_nents entry) and DMA mapped pages (nents entry).
    
    It turned out that it was a common mistake to misuse nents and orig_nents
    entries, calling mapping functions with a wrong number of entries.
    
    To avoid such issues, lets introduce a common wrapper operating directly
    on the struct sg_table objects, which take care of the proper use of
    the nents and orig_nents entries.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Joerg Roedel <jroedel@suse.de>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 7ef8b0bda695..b1bfbe6dff42 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -466,6 +466,22 @@ extern phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain, dma_addr_t io
 extern void iommu_set_fault_handler(struct iommu_domain *domain,
 			iommu_fault_handler_t handler, void *token);
 
+/**
+ * iommu_map_sgtable - Map the given buffer to the IOMMU domain
+ * @domain:	The IOMMU domain to perform the mapping
+ * @iova:	The start address to map the buffer
+ * @sgt:	The sg_table object describing the buffer
+ * @prot:	IOMMU protection bits
+ *
+ * Creates a mapping at @iova for the buffer described by a scatterlist
+ * stored in the given sg_table object in the provided IOMMU domain.
+ */
+static inline size_t iommu_map_sgtable(struct iommu_domain *domain,
+			unsigned long iova, struct sg_table *sgt, int prot)
+{
+	return iommu_map_sg(domain, iova, sgt->sgl, sgt->orig_nents, prot);
+}
+
 extern void iommu_get_resv_regions(struct device *dev, struct list_head *list);
 extern void iommu_put_resv_regions(struct device *dev, struct list_head *list);
 extern void generic_iommu_put_resv_regions(struct device *dev,

commit 1b032ec1ecbce6047af7d11c9db432e237cb17d8
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Apr 29 15:37:12 2020 +0200

    iommu: Unexport iommu_group_get_for_dev()
    
    The function is now only used in IOMMU core code and shouldn't be used
    outside of it anyway, so remove the export for it.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Link: https://lore.kernel.org/r/20200429133712.31431-35-joro@8bytes.org
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index dd076366383f..7cfd2dddb49d 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -527,7 +527,6 @@ extern int iommu_page_response(struct device *dev,
 			       struct iommu_page_response *msg);
 
 extern int iommu_group_id(struct iommu_group *group);
-extern struct iommu_group *iommu_group_get_for_dev(struct device *dev);
 extern struct iommu_domain *iommu_group_default_domain(struct iommu_group *);
 
 extern int iommu_domain_get_attr(struct iommu_domain *domain, enum iommu_attr,

commit 3eeeb45c6d0444b368cdeba9bdafa8bbcf5370d1
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Apr 29 15:37:10 2020 +0200

    iommu: Remove add_device()/remove_device() code-paths
    
    All drivers are converted to use the probe/release_device()
    call-backs, so the add_device/remove_device() pointers are unused and
    the code using them can be removed.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Link: https://lore.kernel.org/r/20200429133712.31431-33-joro@8bytes.org
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index fea1622408ad..dd076366383f 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -223,8 +223,6 @@ struct iommu_iotlb_gather {
  * @iotlb_sync: Flush all queued ranges from the hardware TLBs and empty flush
  *            queue
  * @iova_to_phys: translate iova to physical address
- * @add_device: add device to iommu grouping
- * @remove_device: remove device from iommu grouping
  * @probe_device: Add device to iommu driver handling
  * @release_device: Remove device from iommu driver handling
  * @probe_finalize: Do final setup work after the device is added to an IOMMU
@@ -277,8 +275,6 @@ struct iommu_ops {
 	void (*iotlb_sync)(struct iommu_domain *domain,
 			   struct iommu_iotlb_gather *iotlb_gather);
 	phys_addr_t (*iova_to_phys)(struct iommu_domain *domain, dma_addr_t iova);
-	int (*add_device)(struct device *dev);
-	void (*remove_device)(struct device *dev);
 	struct iommu_device *(*probe_device)(struct device *dev);
 	void (*release_device)(struct device *dev);
 	void (*probe_finalize)(struct device *dev);

commit 5012c3968537e2ffecbdb2eba3479bf9fb9e5597
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Apr 29 15:36:51 2020 +0200

    iommu: Export bus_iommu_probe() and make is safe for re-probing
    
    Add a check to the bus_iommu_probe() call-path to make sure it ignores
    devices which have already been successfully probed. Then export the
    bus_iommu_probe() function so it can be used by IOMMU drivers.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Link: https://lore.kernel.org/r/20200429133712.31431-14-joro@8bytes.org
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 30170d191e5e..fea1622408ad 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -445,6 +445,7 @@ static inline void iommu_iotlb_gather_init(struct iommu_iotlb_gather *gather)
 #define IOMMU_GROUP_NOTIFY_UNBOUND_DRIVER	6 /* Post Driver unbind */
 
 extern int bus_set_iommu(struct bus_type *bus, const struct iommu_ops *ops);
+extern int bus_iommu_probe(struct bus_type *bus);
 extern bool iommu_present(struct bus_type *bus);
 extern bool iommu_capable(struct bus_type *bus, enum iommu_cap cap);
 extern struct iommu_domain *iommu_domain_alloc(struct bus_type *bus);

commit a6a4c7e2c5b8b981d1c546a393ff21f2112468c3
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Apr 29 15:36:45 2020 +0200

    iommu: Add probe_device() and release_device() call-backs
    
    Add call-backs to 'struct iommu_ops' as an alternative to the
    add_device() and remove_device() call-backs, which will be removed when
    all drivers are converted.
    
    The new call-backs will not setup IOMMU groups and domains anymore,
    so also add a probe_finalize() call-back where the IOMMU driver can do
    per-device setup work which require the device to be set up with a
    group and a domain.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Link: https://lore.kernel.org/r/20200429133712.31431-8-joro@8bytes.org
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 1f027b07e499..30170d191e5e 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -225,6 +225,10 @@ struct iommu_iotlb_gather {
  * @iova_to_phys: translate iova to physical address
  * @add_device: add device to iommu grouping
  * @remove_device: remove device from iommu grouping
+ * @probe_device: Add device to iommu driver handling
+ * @release_device: Remove device from iommu driver handling
+ * @probe_finalize: Do final setup work after the device is added to an IOMMU
+ *                  group and attached to the groups domain
  * @device_group: find iommu group for a particular device
  * @domain_get_attr: Query domain attributes
  * @domain_set_attr: Change domain attributes
@@ -275,6 +279,9 @@ struct iommu_ops {
 	phys_addr_t (*iova_to_phys)(struct iommu_domain *domain, dma_addr_t iova);
 	int (*add_device)(struct device *dev);
 	void (*remove_device)(struct device *dev);
+	struct iommu_device *(*probe_device)(struct device *dev);
+	void (*release_device)(struct device *dev);
+	void (*probe_finalize)(struct device *dev);
 	struct iommu_group *(*device_group)(struct device *dev);
 	int (*domain_get_attr)(struct iommu_domain *domain,
 			       enum iommu_attr attr, void *data);
@@ -375,6 +382,7 @@ struct iommu_fault_param {
  *
  * @fault_param: IOMMU detected device fault reporting data
  * @fwspec:	 IOMMU fwspec data
+ * @iommu_dev:	 IOMMU device this device is linked to
  * @priv:	 IOMMU Driver private data
  *
  * TODO: migrate other per device data pointers under iommu_dev_data, e.g.
@@ -384,6 +392,7 @@ struct dev_iommu {
 	struct mutex lock;
 	struct iommu_fault_param	*fault_param;
 	struct iommu_fwspec		*fwspec;
+	struct iommu_device		*iommu_dev;
 	void				*priv;
 };
 

commit 4cbf38511a007867def958872203ae8adb8e2351
Author: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
Date:   Wed Apr 29 15:36:40 2020 +0200

    iommu: Add def_domain_type() callback in iommu_ops
    
    Some devices are reqired to use a specific type (identity or dma)
    of default domain when they are used with a vendor iommu. When the
    system level default domain type is different from it, the vendor
    iommu driver has to request a new default domain with
    iommu_request_dma_domain_for_dev() and iommu_request_dm_for_dev()
    in the add_dev() callback. Unfortunately, these two helpers only
    work when the group hasn't been assigned to any other devices,
    hence, some vendor iommu driver has to use a private domain if
    it fails to request a new default one.
    
    This adds def_domain_type() callback in the iommu_ops, so that
    any special requirement of default domain for a device could be
    aware by the iommu generic layer.
    
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    [ jroedel@suse.de: Added iommu_get_def_domain_type() function and use
                       it to allocate the default domain ]
    Co-developed-by: Joerg Roedel <jroedel@suse.de>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Link: https://lore.kernel.org/r/20200429133712.31431-3-joro@8bytes.org
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 7ef8b0bda695..1f027b07e499 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -248,6 +248,10 @@ struct iommu_iotlb_gather {
  * @cache_invalidate: invalidate translation caches
  * @sva_bind_gpasid: bind guest pasid and mm
  * @sva_unbind_gpasid: unbind guest pasid and mm
+ * @def_domain_type: device default domain type, return value:
+ *		- IOMMU_DOMAIN_IDENTITY: must use an identity domain
+ *		- IOMMU_DOMAIN_DMA: must use a dma domain
+ *		- 0: use the default setting
  * @pgsize_bitmap: bitmap of all possible supported page sizes
  * @owner: Driver module providing these ops
  */
@@ -318,6 +322,8 @@ struct iommu_ops {
 
 	int (*sva_unbind_gpasid)(struct device *dev, int pasid);
 
+	int (*def_domain_type)(struct device *dev);
+
 	unsigned long pgsize_bitmap;
 	struct module *owner;
 };

commit 986d5ecc56999800a5d112a70e88522d9212aefd
Author: Joerg Roedel <jroedel@suse.de>
Date:   Thu Mar 26 16:08:41 2020 +0100

    iommu: Move fwspec->iommu_priv to struct dev_iommu
    
    Move the pointer for iommu private data from struct iommu_fwspec to
    struct dev_iommu.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    Tested-by: Will Deacon <will@kernel.org> # arm-smmu
    Reviewed-by: Jean-Philippe Brucker <jean-philippe@linaro.org>
    Link: https://lore.kernel.org/r/20200326150841.10083-17-joro@8bytes.org

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 49e3173260b3..7ef8b0bda695 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -369,6 +369,7 @@ struct iommu_fault_param {
  *
  * @fault_param: IOMMU detected device fault reporting data
  * @fwspec:	 IOMMU fwspec data
+ * @priv:	 IOMMU Driver private data
  *
  * TODO: migrate other per device data pointers under iommu_dev_data, e.g.
  *	struct iommu_group	*iommu_group;
@@ -377,6 +378,7 @@ struct dev_iommu {
 	struct mutex lock;
 	struct iommu_fault_param	*fault_param;
 	struct iommu_fwspec		*fwspec;
+	void				*priv;
 };
 
 int  iommu_device_register(struct iommu_device *iommu);
@@ -589,7 +591,6 @@ struct iommu_group *fsl_mc_device_group(struct device *dev);
 struct iommu_fwspec {
 	const struct iommu_ops	*ops;
 	struct fwnode_handle	*iommu_fwnode;
-	void			*iommu_priv;
 	u32			flags;
 	u32			num_pasid_bits;
 	unsigned int		num_ids;
@@ -629,12 +630,12 @@ static inline void dev_iommu_fwspec_set(struct device *dev,
 
 static inline void *dev_iommu_priv_get(struct device *dev)
 {
-	return dev->iommu->fwspec->iommu_priv;
+	return dev->iommu->priv;
 }
 
 static inline void dev_iommu_priv_set(struct device *dev, void *priv)
 {
-	dev->iommu->fwspec->iommu_priv = priv;
+	dev->iommu->priv = priv;
 }
 
 int iommu_probe_device(struct device *dev);

commit f9867f416ee721141e1664810516b8ebc2563cdd
Author: Joerg Roedel <jroedel@suse.de>
Date:   Thu Mar 26 16:08:33 2020 +0100

    iommu: Introduce accessors for iommu private data
    
    Add dev_iommu_priv_get/set() functions to access per-device iommu
    private data. This makes it easier to move the pointer to a different
    location.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    Tested-by: Will Deacon <will@kernel.org> # arm-smmu
    Reviewed-by: Jean-Philippe Brucker <jean-philippe@linaro.org>
    Link: https://lore.kernel.org/r/20200326150841.10083-9-joro@8bytes.org

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index d031ddc0596b..49e3173260b3 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -627,6 +627,16 @@ static inline void dev_iommu_fwspec_set(struct device *dev,
 	dev->iommu->fwspec = fwspec;
 }
 
+static inline void *dev_iommu_priv_get(struct device *dev)
+{
+	return dev->iommu->fwspec->iommu_priv;
+}
+
+static inline void dev_iommu_priv_set(struct device *dev, void *priv)
+{
+	dev->iommu->fwspec->iommu_priv = priv;
+}
+
 int iommu_probe_device(struct device *dev);
 void iommu_release_device(struct device *dev);
 

commit 72acd9df18f12420001f901493c54b7364f34d60
Author: Joerg Roedel <jroedel@suse.de>
Date:   Thu Mar 26 16:08:31 2020 +0100

    iommu: Move iommu_fwspec to struct dev_iommu
    
    Move the iommu_fwspec pointer in struct device into struct dev_iommu.
    This is a step in the effort to reduce the iommu related pointers in
    struct device to one.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    Tested-by: Will Deacon <will@kernel.org> # arm-smmu
    Reviewed-by: Jean-Philippe Brucker <jean-philippe@linaro.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Link: https://lore.kernel.org/r/20200326150841.10083-7-joro@8bytes.org

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 843baaa65f10..d031ddc0596b 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -368,14 +368,15 @@ struct iommu_fault_param {
  * struct dev_iommu - Collection of per-device IOMMU data
  *
  * @fault_param: IOMMU detected device fault reporting data
+ * @fwspec:	 IOMMU fwspec data
  *
  * TODO: migrate other per device data pointers under iommu_dev_data, e.g.
  *	struct iommu_group	*iommu_group;
- *	struct iommu_fwspec	*iommu_fwspec;
  */
 struct dev_iommu {
 	struct mutex lock;
-	struct iommu_fault_param *fault_param;
+	struct iommu_fault_param	*fault_param;
+	struct iommu_fwspec		*fwspec;
 };
 
 int  iommu_device_register(struct iommu_device *iommu);
@@ -614,13 +615,16 @@ const struct iommu_ops *iommu_ops_from_fwnode(struct fwnode_handle *fwnode);
 
 static inline struct iommu_fwspec *dev_iommu_fwspec_get(struct device *dev)
 {
-	return dev->iommu_fwspec;
+	if (dev->iommu)
+		return dev->iommu->fwspec;
+	else
+		return NULL;
 }
 
 static inline void dev_iommu_fwspec_set(struct device *dev,
 					struct iommu_fwspec *fwspec)
 {
-	dev->iommu_fwspec = fwspec;
+	dev->iommu->fwspec = fwspec;
 }
 
 int iommu_probe_device(struct device *dev);

commit 045a70426067d6a22e3e5745b55efc18fa75aabf
Author: Joerg Roedel <jroedel@suse.de>
Date:   Thu Mar 26 16:08:30 2020 +0100

    iommu: Rename struct iommu_param to dev_iommu
    
    The term dev_iommu aligns better with other existing structures and
    their accessor functions.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    Tested-by: Will Deacon <will@kernel.org> # arm-smmu
    Reviewed-by: Jean-Philippe Brucker <jean-philippe@linaro.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Link: https://lore.kernel.org/r/20200326150841.10083-6-joro@8bytes.org

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 505163e9702a..843baaa65f10 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -365,7 +365,7 @@ struct iommu_fault_param {
 };
 
 /**
- * struct iommu_param - collection of per-device IOMMU data
+ * struct dev_iommu - Collection of per-device IOMMU data
  *
  * @fault_param: IOMMU detected device fault reporting data
  *
@@ -373,7 +373,7 @@ struct iommu_fault_param {
  *	struct iommu_group	*iommu_group;
  *	struct iommu_fwspec	*iommu_fwspec;
  */
-struct iommu_param {
+struct dev_iommu {
 	struct mutex lock;
 	struct iommu_fault_param *fault_param;
 };

commit 0008d0c3b1ab03b046b04b7bd9d70df1e2fffbfc
Author: Joerg Roedel <jroedel@suse.de>
Date:   Thu Mar 26 16:08:26 2020 +0100

    iommu: Define dev_iommu_fwspec_get() for !CONFIG_IOMMU_API
    
    There are users outside of the IOMMU code that need to call that
    function. Define it for !CONFIG_IOMMU_API too so that compilation does
    not break.
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    Reviewed-by: Jean-Philippe Brucker <jean-philippe@linaro.org>
    Link: https://lore.kernel.org/r/20200326150841.10083-2-joro@8bytes.org

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 4d1ba76c9a64..505163e9702a 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -1073,6 +1073,10 @@ static inline int iommu_sva_unbind_gpasid(struct iommu_domain *domain,
 	return -ENODEV;
 }
 
+static inline struct iommu_fwspec *dev_iommu_fwspec_get(struct device *dev)
+{
+	return NULL;
+}
 #endif /* CONFIG_IOMMU_API */
 
 #ifdef CONFIG_IOMMU_DEBUGFS

commit 098accf2da940189f4d62d3514d17f8bb05dc6e1
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Thu Feb 13 14:00:21 2020 +0000

    iommu: Use C99 flexible array in fwspec
    
    Although the 1-element array was a typical pre-C99 way to implement
    variable-length structures, and indeed is a fundamental construct in the
    APIs of certain other popular platforms, there's no good reason for it
    here (and in particular the sizeof() trick is far too "clever" for its
    own good). We can just as easily implement iommu_fwspec's preallocation
    behaviour using a standard flexible array member, so let's make it look
    the way most readers would expect.
    
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index d1b5f4d98569..4d1ba76c9a64 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -592,7 +592,7 @@ struct iommu_fwspec {
 	u32			flags;
 	u32			num_pasid_bits;
 	unsigned int		num_ids;
-	u32			ids[1];
+	u32			ids[];
 };
 
 /* ATS is supported */

commit e3b5ee0cfb65646f4a915643fe53e0a51829d891
Merge: 8c17bbf6c8f7 6855d1ba7537 154e3a65f404 857f081426e5 c11738cf9d29
Author: Joerg Roedel <jroedel@suse.de>
Date:   Fri Jan 24 15:39:39 2020 +0100

    Merge branches 'iommu/fixes', 'arm/smmu', 'x86/amd', 'x86/vt-d' and 'core' into next

commit 89535821c04256964e266bf585cf224f65e08983
Author: Jean-Philippe Brucker <jean-philippe@linaro.org>
Date:   Wed Jan 15 13:52:29 2020 +0100

    iommu/arm-smmu-v3: Parse PASID devicetree property of platform devices
    
    For platform devices that support SubstreamID (SSID), firmware provides
    the number of supported SSID bits. Restrict it to what the SMMU supports
    and cache it into master->ssid_bits, which will also be used for PCI
    PASID.
    
    Reviewed-by: Eric Auger <eric.auger@redhat.com>
    Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Signed-off-by: Jean-Philippe Brucker <jean-philippe@linaro.org>
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 90007c92ad2d..c1ad15228447 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -579,6 +579,7 @@ struct iommu_group *fsl_mc_device_group(struct device *dev);
  * @ops: ops for this device's IOMMU
  * @iommu_fwnode: firmware handle for this device's IOMMU
  * @iommu_priv: IOMMU driver private data for this device
+ * @num_pasid_bits: number of PASID bits supported by this device
  * @num_ids: number of associated device IDs
  * @ids: IDs which this device may present to the IOMMU
  */
@@ -587,6 +588,7 @@ struct iommu_fwspec {
 	struct fwnode_handle	*iommu_fwnode;
 	void			*iommu_priv;
 	u32			flags;
+	u32			num_pasid_bits;
 	unsigned int		num_ids;
 	u32			ids[1];
 };

commit fc10cca69ee8af49778ad76c1e5fddf83d5026c8
Author: Will Deacon <will@kernel.org>
Date:   Thu Jan 9 14:08:41 2020 +0000

    drivers/iommu: Initialise module 'owner' field in iommu_device_set_ops()
    
    Requiring each IOMMU driver to initialise the 'owner' field of their
    'struct iommu_ops' is error-prone and easily forgotten. Follow the
    example set by PCI and USB by assigning THIS_MODULE automatically when
    registering the ops structure with IOMMU core.
    
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Suggested-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index e9f94d3f7a04..90007c92ad2d 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -388,12 +388,19 @@ void iommu_device_sysfs_remove(struct iommu_device *iommu);
 int  iommu_device_link(struct iommu_device   *iommu, struct device *link);
 void iommu_device_unlink(struct iommu_device *iommu, struct device *link);
 
-static inline void iommu_device_set_ops(struct iommu_device *iommu,
-					const struct iommu_ops *ops)
+static inline void __iommu_device_set_ops(struct iommu_device *iommu,
+					  const struct iommu_ops *ops)
 {
 	iommu->ops = ops;
 }
 
+#define iommu_device_set_ops(iommu, ops)				\
+do {									\
+	struct iommu_ops *__ops = (struct iommu_ops *)(ops);		\
+	__ops->owner = THIS_MODULE;					\
+	__iommu_device_set_ops(iommu, __ops);				\
+} while (0)
+
 static inline void iommu_device_set_fwnode(struct iommu_device *iommu,
 					   struct fwnode_handle *fwnode)
 {

commit f9f6971ebb75f5bc302d77e3380dd6363cc1a0f6
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Dec 18 14:42:01 2019 +0100

    iommu: Implement generic_iommu_put_resv_regions()
    
    Implement a generic function for removing reserved regions. This can be
    used by drivers that don't do anything fancy with these regions other
    than allocating memory for them.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index f2223cbb5fd5..e80b83b8cab8 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -456,6 +456,8 @@ extern void iommu_set_fault_handler(struct iommu_domain *domain,
 
 extern void iommu_get_resv_regions(struct device *dev, struct list_head *list);
 extern void iommu_put_resv_regions(struct device *dev, struct list_head *list);
+extern void generic_iommu_put_resv_regions(struct device *dev,
+					   struct list_head *list);
 extern int iommu_request_dm_for_dev(struct device *dev);
 extern int iommu_request_dma_domain_for_dev(struct device *dev);
 extern void iommu_set_default_passthrough(bool cmd_line);

commit 25f003de987aed630db265ceae9cd978537a3f80
Author: Will Deacon <will@kernel.org>
Date:   Thu Dec 19 12:03:41 2019 +0000

    drivers/iommu: Take a ref to the IOMMU driver prior to ->add_device()
    
    To avoid accidental removal of an active IOMMU driver module, take a
    reference to the driver module in 'iommu_probe_device()' immediately
    prior to invoking the '->add_device()' callback and hold it until the
    after the device has been removed by '->remove_device()'.
    
    Suggested-by: Joerg Roedel <joro@8bytes.org>
    Signed-off-by: Will Deacon <will@kernel.org>
    Tested-by: John Garry <john.garry@huawei.com> # smmu v3
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index f2223cbb5fd5..e9f94d3f7a04 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -246,9 +246,10 @@ struct iommu_iotlb_gather {
  * @sva_get_pasid: Get PASID associated to a SVA handle
  * @page_response: handle page request response
  * @cache_invalidate: invalidate translation caches
- * @pgsize_bitmap: bitmap of all possible supported page sizes
  * @sva_bind_gpasid: bind guest pasid and mm
  * @sva_unbind_gpasid: unbind guest pasid and mm
+ * @pgsize_bitmap: bitmap of all possible supported page sizes
+ * @owner: Driver module providing these ops
  */
 struct iommu_ops {
 	bool (*capable)(enum iommu_cap);
@@ -318,6 +319,7 @@ struct iommu_ops {
 	int (*sva_unbind_gpasid)(struct device *dev, int pasid);
 
 	unsigned long pgsize_bitmap;
+	struct module *owner;
 };
 
 /**

commit 9b3a713feef8db41d4bcccb3b97e86ee906690c8
Merge: 4e7120d79edb da6b05dce2a9 1289f7f15001 5b47748ecf2e c90ae4a63541 96d3ab802e49 34d1b0895dbd 3c124435e8dd 6c3a44ed3c55 c1c8058dfb98 808be0aae53a
Author: Joerg Roedel <jroedel@suse.de>
Date:   Tue Nov 12 17:11:25 2019 +0100

    Merge branches 'iommu/fixes', 'arm/qcom', 'arm/renesas', 'arm/rockchip', 'arm/mediatek', 'arm/tegra', 'arm/smmu', 'x86/amd', 'x86/vt-d', 'virtio' and 'core' into next

commit dd5ddd3c7a8c7ac382a82d15757f0ca3ab2b2dbc
Author: Will Deacon <will@kernel.org>
Date:   Thu Oct 24 16:57:39 2019 +0100

    iommu/io-pgtable-arm: Rename IOMMU_QCOM_SYS_CACHE and improve doc
    
    The 'IOMMU_QCOM_SYS_CACHE' IOMMU protection flag is exposed to all
    users of the IOMMU API. Despite its name, the idea behind it isn't
    especially tied to Qualcomm implementations and could conceivably be
    used by other systems.
    
    Rename it to 'IOMMU_SYS_CACHE_ONLY' and update the comment to describe
    a bit better the idea behind it.
    
    Cc: Robin Murphy <robin.murphy@arm.com>
    Cc: "Isaac J. Manjarres" <isaacm@codeaurora.org>
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 29bac5345563..a86bd21d08a9 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -31,11 +31,11 @@
  */
 #define IOMMU_PRIV	(1 << 5)
 /*
- * Non-coherent masters on few Qualcomm SoCs can use this page protection flag
- * to set correct cacheability attributes to use an outer level of cache -
- * last level cache, aka system cache.
+ * Non-coherent masters can use this page protection flag to set cacheable
+ * memory attributes for only a transparent outer level of cache, also known as
+ * the last-level or system cache.
  */
-#define IOMMU_QCOM_SYS_CACHE	(1 << 6)
+#define IOMMU_SYS_CACHE_ONLY	(1 << 6)
 
 struct iommu_ops;
 struct iommu_group;

commit 808be0aae53a3675337fad9cde616e086bdc8287
Author: Jacob Pan <jacob.jun.pan@linux.intel.com>
Date:   Wed Oct 2 12:42:43 2019 -0700

    iommu: Introduce guest PASID bind function
    
    Guest shared virtual address (SVA) may require host to shadow guest
    PASID tables. Guest PASID can also be allocated from the host via
    enlightened interfaces. In this case, guest needs to bind the guest
    mm, i.e. cr3 in guest physical address to the actual PASID table in
    the host IOMMU. Nesting will be turned on such that guest virtual
    address can go through a two level translation:
    - 1st level translates GVA to GPA
    - 2nd level translates GPA to HPA
    This patch introduces APIs to bind guest PASID data to the assigned
    device entry in the physical IOMMU. See the diagram below for usage
    explanation.
    
        .-------------.  .---------------------------.
        |   vIOMMU    |  | Guest process mm, FL only |
        |             |  '---------------------------'
        .----------------/
        | PASID Entry |--- PASID cache flush -
        '-------------'                       |
        |             |                       V
        |             |                      GP
        '-------------'
    Guest
    ------| Shadow |----------------------- GP->HP* ---------
          v        v                          |
    Host                                      v
        .-------------.  .----------------------.
        |   pIOMMU    |  | Bind FL for GVA-GPA  |
        |             |  '----------------------'
        .----------------/  |
        | PASID Entry |     V (Nested xlate)
        '----------------\.---------------------.
        |             |   |Set SL to GPA-HPA    |
        |             |   '---------------------'
        '-------------'
    
    Where:
     - FL = First level/stage one page tables
     - SL = Second level/stage two page tables
     - GP = Guest PASID
     - HP = Host PASID
    * Conversion needed if non-identity GP-HP mapping option is chosen.
    
    Signed-off-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
    Signed-off-by: Liu Yi L <yi.l.liu@intel.com>
    Reviewed-by: Jean-Philippe Brucker <jean-philippe@linaro.com>
    Reviewed-by: Jean-Philippe Brucker <jean-philippe@linaro.org>
    Reviewed-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 9b22055e6f85..f8959f759e41 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -13,6 +13,7 @@
 #include <linux/errno.h>
 #include <linux/err.h>
 #include <linux/of.h>
+#include <linux/ioasid.h>
 #include <uapi/linux/iommu.h>
 
 #define IOMMU_READ	(1 << 0)
@@ -246,6 +247,8 @@ struct iommu_iotlb_gather {
  * @page_response: handle page request response
  * @cache_invalidate: invalidate translation caches
  * @pgsize_bitmap: bitmap of all possible supported page sizes
+ * @sva_bind_gpasid: bind guest pasid and mm
+ * @sva_unbind_gpasid: unbind guest pasid and mm
  */
 struct iommu_ops {
 	bool (*capable)(enum iommu_cap);
@@ -309,6 +312,10 @@ struct iommu_ops {
 			     struct iommu_page_response *msg);
 	int (*cache_invalidate)(struct iommu_domain *domain, struct device *dev,
 				struct iommu_cache_invalidate_info *inv_info);
+	int (*sva_bind_gpasid)(struct iommu_domain *domain,
+			struct device *dev, struct iommu_gpasid_bind_data *data);
+
+	int (*sva_unbind_gpasid)(struct device *dev, int pasid);
 
 	unsigned long pgsize_bitmap;
 };
@@ -423,6 +430,10 @@ extern void iommu_detach_device(struct iommu_domain *domain,
 extern int iommu_cache_invalidate(struct iommu_domain *domain,
 				  struct device *dev,
 				  struct iommu_cache_invalidate_info *inv_info);
+extern int iommu_sva_bind_gpasid(struct iommu_domain *domain,
+		struct device *dev, struct iommu_gpasid_bind_data *data);
+extern int iommu_sva_unbind_gpasid(struct iommu_domain *domain,
+				struct device *dev, ioasid_t pasid);
 extern struct iommu_domain *iommu_get_domain_for_dev(struct device *dev);
 extern struct iommu_domain *iommu_get_dma_domain(struct device *dev);
 extern int iommu_map(struct iommu_domain *domain, unsigned long iova,
@@ -1018,6 +1029,17 @@ iommu_cache_invalidate(struct iommu_domain *domain,
 {
 	return -ENODEV;
 }
+static inline int iommu_sva_bind_gpasid(struct iommu_domain *domain,
+				struct device *dev, struct iommu_gpasid_bind_data *data)
+{
+	return -ENODEV;
+}
+
+static inline int iommu_sva_unbind_gpasid(struct iommu_domain *domain,
+					   struct device *dev, int pasid)
+{
+	return -ENODEV;
+}
 
 #endif /* CONFIG_IOMMU_API */
 

commit 4c7c171f85b261f91270d405b7c7390aa6ddfb60
Author: Yi L Liu <yi.l.liu@intel.com>
Date:   Wed Oct 2 12:42:40 2019 -0700

    iommu: Introduce cache_invalidate API
    
    In any virtualization use case, when the first translation stage
    is "owned" by the guest OS, the host IOMMU driver has no knowledge
    of caching structure updates unless the guest invalidation activities
    are trapped by the virtualizer and passed down to the host.
    
    Since the invalidation data can be obtained from user space and will be
    written into physical IOMMU, we must allow security check at various
    layers. Therefore, generic invalidation data format are proposed here,
    model specific IOMMU drivers need to convert them into their own format.
    
    Signed-off-by: Yi L Liu <yi.l.liu@intel.com>
    Signed-off-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
    Signed-off-by: Ashok Raj <ashok.raj@intel.com>
    Signed-off-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Jean-Philippe Brucker <jean-philippe@linaro.com>
    Reviewed-by: Jean-Philippe Brucker <jean-philippe@linaro.org>
    Reviewed-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 29bac5345563..9b22055e6f85 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -244,6 +244,7 @@ struct iommu_iotlb_gather {
  * @sva_unbind: Unbind process address space from device
  * @sva_get_pasid: Get PASID associated to a SVA handle
  * @page_response: handle page request response
+ * @cache_invalidate: invalidate translation caches
  * @pgsize_bitmap: bitmap of all possible supported page sizes
  */
 struct iommu_ops {
@@ -306,6 +307,8 @@ struct iommu_ops {
 	int (*page_response)(struct device *dev,
 			     struct iommu_fault_event *evt,
 			     struct iommu_page_response *msg);
+	int (*cache_invalidate)(struct iommu_domain *domain, struct device *dev,
+				struct iommu_cache_invalidate_info *inv_info);
 
 	unsigned long pgsize_bitmap;
 };
@@ -417,6 +420,9 @@ extern int iommu_attach_device(struct iommu_domain *domain,
 			       struct device *dev);
 extern void iommu_detach_device(struct iommu_domain *domain,
 				struct device *dev);
+extern int iommu_cache_invalidate(struct iommu_domain *domain,
+				  struct device *dev,
+				  struct iommu_cache_invalidate_info *inv_info);
 extern struct iommu_domain *iommu_get_domain_for_dev(struct device *dev);
 extern struct iommu_domain *iommu_get_dma_domain(struct device *dev);
 extern int iommu_map(struct iommu_domain *domain, unsigned long iova,
@@ -1005,6 +1011,14 @@ static inline int iommu_sva_get_pasid(struct iommu_sva *handle)
 	return IOMMU_PASID_INVALID;
 }
 
+static inline int
+iommu_cache_invalidate(struct iommu_domain *domain,
+		       struct device *dev,
+		       struct iommu_cache_invalidate_info *inv_info)
+{
+	return -ENODEV;
+}
+
 #endif /* CONFIG_IOMMU_API */
 
 #ifdef CONFIG_IOMMU_DEBUGFS

commit 781ca2de89bae1b1d2c96df9ef33e9a324415995
Author: Tom Murphy <murphyt7@tcd.ie>
Date:   Sun Sep 8 09:56:38 2019 -0700

    iommu: Add gfp parameter to iommu_ops::map
    
    Add a gfp_t parameter to the iommu_ops::map function.
    Remove the needless locking in the AMD iommu driver.
    
    The iommu_ops::map function (or the iommu_map function which calls it)
    was always supposed to be sleepable (according to Joerg's comment in
    this thread: https://lore.kernel.org/patchwork/patch/977520/ ) and so
    should probably have had a "might_sleep()" since it was written. However
    currently the dma-iommu api can call iommu_map in an atomic context,
    which it shouldn't do. This doesn't cause any problems because any iommu
    driver which uses the dma-iommu api uses gfp_atomic in it's
    iommu_ops::map function. But doing this wastes the memory allocators
    atomic pools.
    
    Signed-off-by: Tom Murphy <murphyt7@tcd.ie>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 29bac5345563..6ca3fb2873d7 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -256,7 +256,7 @@ struct iommu_ops {
 	int (*attach_dev)(struct iommu_domain *domain, struct device *dev);
 	void (*detach_dev)(struct iommu_domain *domain, struct device *dev);
 	int (*map)(struct iommu_domain *domain, unsigned long iova,
-		   phys_addr_t paddr, size_t size, int prot);
+		   phys_addr_t paddr, size_t size, int prot, gfp_t gfp);
 	size_t (*unmap)(struct iommu_domain *domain, unsigned long iova,
 		     size_t size, struct iommu_iotlb_gather *iotlb_gather);
 	void (*flush_iotlb_all)(struct iommu_domain *domain);
@@ -421,6 +421,8 @@ extern struct iommu_domain *iommu_get_domain_for_dev(struct device *dev);
 extern struct iommu_domain *iommu_get_dma_domain(struct device *dev);
 extern int iommu_map(struct iommu_domain *domain, unsigned long iova,
 		     phys_addr_t paddr, size_t size, int prot);
+extern int iommu_map_atomic(struct iommu_domain *domain, unsigned long iova,
+			    phys_addr_t paddr, size_t size, int prot);
 extern size_t iommu_unmap(struct iommu_domain *domain, unsigned long iova,
 			  size_t size);
 extern size_t iommu_unmap_fast(struct iommu_domain *domain,
@@ -428,6 +430,9 @@ extern size_t iommu_unmap_fast(struct iommu_domain *domain,
 			       struct iommu_iotlb_gather *iotlb_gather);
 extern size_t iommu_map_sg(struct iommu_domain *domain, unsigned long iova,
 			   struct scatterlist *sg,unsigned int nents, int prot);
+extern size_t iommu_map_sg_atomic(struct iommu_domain *domain,
+				  unsigned long iova, struct scatterlist *sg,
+				  unsigned int nents, int prot);
 extern phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain, dma_addr_t iova);
 extern void iommu_set_fault_handler(struct iommu_domain *domain,
 			iommu_fault_handler_t handler, void *token);
@@ -662,6 +667,13 @@ static inline int iommu_map(struct iommu_domain *domain, unsigned long iova,
 	return -ENODEV;
 }
 
+static inline int iommu_map_atomic(struct iommu_domain *domain,
+				   unsigned long iova, phys_addr_t paddr,
+				   size_t size, int prot)
+{
+	return -ENODEV;
+}
+
 static inline size_t iommu_unmap(struct iommu_domain *domain,
 				 unsigned long iova, size_t size)
 {
@@ -682,6 +694,13 @@ static inline size_t iommu_map_sg(struct iommu_domain *domain,
 	return 0;
 }
 
+static inline size_t iommu_map_sg_atomic(struct iommu_domain *domain,
+				  unsigned long iova, struct scatterlist *sg,
+				  unsigned int nents, int prot)
+{
+	return 0;
+}
+
 static inline void iommu_flush_tlb_all(struct iommu_domain *domain)
 {
 }

commit 8a69961c7f7583742ab9064feab5ea533a6b1b97
Author: Joerg Roedel <jroedel@suse.de>
Date:   Mon Aug 19 15:22:47 2019 +0200

    iommu: Add helpers to set/get default domain type
    
    Add a couple of functions to allow changing the default
    domain type from architecture code and a function for iommu
    drivers to request whether the default domain is
    passthrough.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 64ebaff33455..29bac5345563 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -436,6 +436,9 @@ extern void iommu_get_resv_regions(struct device *dev, struct list_head *list);
 extern void iommu_put_resv_regions(struct device *dev, struct list_head *list);
 extern int iommu_request_dm_for_dev(struct device *dev);
 extern int iommu_request_dma_domain_for_dev(struct device *dev);
+extern void iommu_set_default_passthrough(bool cmd_line);
+extern void iommu_set_default_translated(bool cmd_line);
+extern bool iommu_default_passthrough(void);
 extern struct iommu_resv_region *
 iommu_alloc_resv_region(phys_addr_t start, size_t length, int prot,
 			enum iommu_resv_type type);
@@ -736,6 +739,19 @@ static inline int iommu_request_dma_domain_for_dev(struct device *dev)
 	return -ENODEV;
 }
 
+static inline void iommu_set_default_passthrough(bool cmd_line)
+{
+}
+
+static inline void iommu_set_default_translated(bool cmd_line)
+{
+}
+
+static inline bool iommu_default_passthrough(void)
+{
+	return true;
+}
+
 static inline int iommu_attach_group(struct iommu_domain *domain,
 				     struct iommu_group *group)
 {

commit 56f8af5e9d38f120cba2c2adb0786fa2dbc901a4
Author: Will Deacon <will@kernel.org>
Date:   Tue Jul 2 16:44:06 2019 +0100

    iommu: Pass struct iommu_iotlb_gather to ->unmap() and ->iotlb_sync()
    
    To allow IOMMU drivers to batch up TLB flushing operations and postpone
    them until ->iotlb_sync() is called, extend the prototypes for the
    ->unmap() and ->iotlb_sync() IOMMU ops callbacks to take a pointer to
    the current iommu_iotlb_gather structure.
    
    All affected IOMMU drivers are updated, but there should be no
    functional change since the extra parameter is ignored for now.
    
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index ad41aee55bc6..64ebaff33455 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -258,10 +258,11 @@ struct iommu_ops {
 	int (*map)(struct iommu_domain *domain, unsigned long iova,
 		   phys_addr_t paddr, size_t size, int prot);
 	size_t (*unmap)(struct iommu_domain *domain, unsigned long iova,
-		     size_t size);
+		     size_t size, struct iommu_iotlb_gather *iotlb_gather);
 	void (*flush_iotlb_all)(struct iommu_domain *domain);
 	void (*iotlb_sync_map)(struct iommu_domain *domain);
-	void (*iotlb_sync)(struct iommu_domain *domain);
+	void (*iotlb_sync)(struct iommu_domain *domain,
+			   struct iommu_iotlb_gather *iotlb_gather);
 	phys_addr_t (*iova_to_phys)(struct iommu_domain *domain, dma_addr_t iova);
 	int (*add_device)(struct device *dev);
 	void (*remove_device)(struct device *dev);
@@ -502,7 +503,7 @@ static inline void iommu_tlb_sync(struct iommu_domain *domain,
 				  struct iommu_iotlb_gather *iotlb_gather)
 {
 	if (domain->ops->iotlb_sync)
-		domain->ops->iotlb_sync(domain);
+		domain->ops->iotlb_sync(domain, iotlb_gather);
 
 	iommu_iotlb_gather_init(iotlb_gather);
 }

commit 4fcf8544fc677fc8af135f1d86b3ba69c4ad429d
Author: Will Deacon <will@kernel.org>
Date:   Tue Jul 2 16:43:57 2019 +0100

    iommu: Introduce iommu_iotlb_gather_add_page()
    
    Introduce a helper function for drivers to use when updating an
    iommu_iotlb_gather structure in response to an ->unmap() call, rather
    than having to open-code the logic in every page-table implementation.
    
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index aaf073010a9a..ad41aee55bc6 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -507,6 +507,31 @@ static inline void iommu_tlb_sync(struct iommu_domain *domain,
 	iommu_iotlb_gather_init(iotlb_gather);
 }
 
+static inline void iommu_iotlb_gather_add_page(struct iommu_domain *domain,
+					       struct iommu_iotlb_gather *gather,
+					       unsigned long iova, size_t size)
+{
+	unsigned long start = iova, end = start + size;
+
+	/*
+	 * If the new page is disjoint from the current range or is mapped at
+	 * a different granularity, then sync the TLB so that the gather
+	 * structure can be rewritten.
+	 */
+	if (gather->pgsize != size ||
+	    end < gather->start || start > gather->end) {
+		if (gather->pgsize)
+			iommu_tlb_sync(domain, gather);
+		gather->pgsize = size;
+	}
+
+	if (gather->end < end)
+		gather->end = end;
+
+	if (gather->start > start)
+		gather->start = start;
+}
+
 /* PCI device grouping function */
 extern struct iommu_group *pci_device_group(struct device *dev);
 /* Generic device grouping function */
@@ -847,6 +872,12 @@ static inline void iommu_iotlb_gather_init(struct iommu_iotlb_gather *gather)
 {
 }
 
+static inline void iommu_iotlb_gather_add_page(struct iommu_domain *domain,
+					       struct iommu_iotlb_gather *gather,
+					       unsigned long iova, size_t size)
+{
+}
+
 static inline void iommu_device_unregister(struct iommu_device *iommu)
 {
 }

commit a7d20dc19d9ea7012227be5144353012ffa3ddc4
Author: Will Deacon <will@kernel.org>
Date:   Tue Jul 2 16:43:48 2019 +0100

    iommu: Introduce struct iommu_iotlb_gather for batching TLB flushes
    
    To permit batching of TLB flushes across multiple calls to the IOMMU
    driver's ->unmap() implementation, introduce a new structure for
    tracking the address range to be flushed and the granularity at which
    the flushing is required.
    
    This is hooked into the IOMMU API and its caller are updated to make use
    of the new structure. Subsequent patches will plumb this into the IOMMU
    drivers as well, but for now the gathering information is ignored.
    
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 1e21431262d9..aaf073010a9a 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -191,6 +191,23 @@ struct iommu_sva_ops {
 
 #ifdef CONFIG_IOMMU_API
 
+/**
+ * struct iommu_iotlb_gather - Range information for a pending IOTLB flush
+ *
+ * @start: IOVA representing the start of the range to be flushed
+ * @end: IOVA representing the end of the range to be flushed (exclusive)
+ * @pgsize: The interval at which to perform the flush
+ *
+ * This structure is intended to be updated by multiple calls to the
+ * ->unmap() function in struct iommu_ops before eventually being passed
+ * into ->iotlb_sync().
+ */
+struct iommu_iotlb_gather {
+	unsigned long		start;
+	unsigned long		end;
+	size_t			pgsize;
+};
+
 /**
  * struct iommu_ops - iommu ops and capabilities
  * @capable: check capability
@@ -375,6 +392,13 @@ static inline struct iommu_device *dev_to_iommu_device(struct device *dev)
 	return (struct iommu_device *)dev_get_drvdata(dev);
 }
 
+static inline void iommu_iotlb_gather_init(struct iommu_iotlb_gather *gather)
+{
+	*gather = (struct iommu_iotlb_gather) {
+		.start	= ULONG_MAX,
+	};
+}
+
 #define IOMMU_GROUP_NOTIFY_ADD_DEVICE		1 /* Device added */
 #define IOMMU_GROUP_NOTIFY_DEL_DEVICE		2 /* Pre Device removed */
 #define IOMMU_GROUP_NOTIFY_BIND_DRIVER		3 /* Pre Driver bind */
@@ -399,7 +423,8 @@ extern int iommu_map(struct iommu_domain *domain, unsigned long iova,
 extern size_t iommu_unmap(struct iommu_domain *domain, unsigned long iova,
 			  size_t size);
 extern size_t iommu_unmap_fast(struct iommu_domain *domain,
-			       unsigned long iova, size_t size);
+			       unsigned long iova, size_t size,
+			       struct iommu_iotlb_gather *iotlb_gather);
 extern size_t iommu_map_sg(struct iommu_domain *domain, unsigned long iova,
 			   struct scatterlist *sg,unsigned int nents, int prot);
 extern phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain, dma_addr_t iova);
@@ -473,10 +498,13 @@ static inline void iommu_flush_tlb_all(struct iommu_domain *domain)
 		domain->ops->flush_iotlb_all(domain);
 }
 
-static inline void iommu_tlb_sync(struct iommu_domain *domain)
+static inline void iommu_tlb_sync(struct iommu_domain *domain,
+				  struct iommu_iotlb_gather *iotlb_gather)
 {
 	if (domain->ops->iotlb_sync)
 		domain->ops->iotlb_sync(domain);
+
+	iommu_iotlb_gather_init(iotlb_gather);
 }
 
 /* PCI device grouping function */
@@ -557,6 +585,7 @@ struct iommu_group {};
 struct iommu_fwspec {};
 struct iommu_device {};
 struct iommu_fault_param {};
+struct iommu_iotlb_gather {};
 
 static inline bool iommu_present(struct bus_type *bus)
 {
@@ -611,7 +640,8 @@ static inline size_t iommu_unmap(struct iommu_domain *domain,
 }
 
 static inline size_t iommu_unmap_fast(struct iommu_domain *domain,
-				      unsigned long iova, int gfp_order)
+				      unsigned long iova, int gfp_order,
+				      struct iommu_iotlb_gather *iotlb_gather)
 {
 	return 0;
 }
@@ -627,7 +657,8 @@ static inline void iommu_flush_tlb_all(struct iommu_domain *domain)
 {
 }
 
-static inline void iommu_tlb_sync(struct iommu_domain *domain)
+static inline void iommu_tlb_sync(struct iommu_domain *domain,
+				  struct iommu_iotlb_gather *iotlb_gather)
 {
 }
 
@@ -812,6 +843,10 @@ static inline struct iommu_device *dev_to_iommu_device(struct device *dev)
 	return NULL;
 }
 
+static inline void iommu_iotlb_gather_init(struct iommu_iotlb_gather *gather)
+{
+}
+
 static inline void iommu_device_unregister(struct iommu_device *iommu)
 {
 }

commit 6d1bcb957be2850e0776f24c289e1f87c256baeb
Author: Will Deacon <will@kernel.org>
Date:   Tue Jul 2 16:43:07 2019 +0100

    iommu: Remove empty iommu_tlb_range_add() callback from iommu_ops
    
    Commit add02cfdc9bc ("iommu: Introduce Interface for IOMMU TLB Flushing")
    added three new TLB flushing operations to the IOMMU API so that the
    underlying driver operations can be batched when unmapping large regions
    of IO virtual address space.
    
    However, the ->iotlb_range_add() callback has not been implemented by
    any IOMMU drivers (amd_iommu.c implements it as an empty function, which
    incurs the overhead of an indirect branch). Instead, drivers either flush
    the entire IOTLB in the ->iotlb_sync() callback or perform the necessary
    invalidation during ->unmap().
    
    Attempting to implement ->iotlb_range_add() for arm-smmu-v3.c revealed
    two major issues:
    
      1. The page size used to map the region in the page-table is not known,
         and so it is not generally possible to issue TLB flushes in the most
         efficient manner.
    
      2. The only mutable state passed to the callback is a pointer to the
         iommu_domain, which can be accessed concurrently and therefore
         requires expensive synchronisation to keep track of the outstanding
         flushes.
    
    Remove the callback entirely in preparation for extending ->unmap() and
    ->iotlb_sync() to update a token on the caller's stack.
    
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index fdc355ccc570..1e21431262d9 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -201,7 +201,6 @@ struct iommu_sva_ops {
  * @map: map a physically contiguous memory region to an iommu domain
  * @unmap: unmap a physically contiguous memory region from an iommu domain
  * @flush_iotlb_all: Synchronously flush all hardware TLBs for this domain
- * @iotlb_range_add: Add a given iova range to the flush queue for this domain
  * @iotlb_sync_map: Sync mappings created recently using @map to the hardware
  * @iotlb_sync: Flush all queued ranges from the hardware TLBs and empty flush
  *            queue
@@ -244,8 +243,6 @@ struct iommu_ops {
 	size_t (*unmap)(struct iommu_domain *domain, unsigned long iova,
 		     size_t size);
 	void (*flush_iotlb_all)(struct iommu_domain *domain);
-	void (*iotlb_range_add)(struct iommu_domain *domain,
-				unsigned long iova, size_t size);
 	void (*iotlb_sync_map)(struct iommu_domain *domain);
 	void (*iotlb_sync)(struct iommu_domain *domain);
 	phys_addr_t (*iova_to_phys)(struct iommu_domain *domain, dma_addr_t iova);
@@ -476,13 +473,6 @@ static inline void iommu_flush_tlb_all(struct iommu_domain *domain)
 		domain->ops->flush_iotlb_all(domain);
 }
 
-static inline void iommu_tlb_range_add(struct iommu_domain *domain,
-				       unsigned long iova, size_t size)
-{
-	if (domain->ops->iotlb_range_add)
-		domain->ops->iotlb_range_add(domain, iova, size);
-}
-
 static inline void iommu_tlb_sync(struct iommu_domain *domain)
 {
 	if (domain->ops->iotlb_sync)
@@ -637,11 +627,6 @@ static inline void iommu_flush_tlb_all(struct iommu_domain *domain)
 {
 }
 
-static inline void iommu_tlb_range_add(struct iommu_domain *domain,
-				       unsigned long iova, size_t size)
-{
-}
-
 static inline void iommu_tlb_sync(struct iommu_domain *domain)
 {
 }

commit d95c3885865b71e56d8d60c8617f2ce1f0fa079d
Merge: 0bcfa628f8a3 5cd3f2e98cca 8dd8f005bdd4 9378bfeaafcb ceedd5f74d8c 29fcea8ce7f3
Author: Joerg Roedel <jroedel@suse.de>
Date:   Thu Jul 4 17:26:48 2019 +0200

    Merge branches 'x86/vt-d', 'x86/amd', 'arm/smmu', 'arm/omap', 'generic-dma-ops' and 'core' into next

commit 39debdc1d7e615863b66e5e8c612e4f0e78b1e1b
Merge: 6fbc7275c7a9 9e6ea59f3ff3
Author: Joerg Roedel <jroedel@suse.de>
Date:   Mon Jul 1 13:44:41 2019 +0200

    Merge branch 'for-joerg/arm-smmu/updates' of git://git.kernel.org/pub/scm/linux/kernel/git/will/linux into arm/smmu

commit 90ec7a76cc4ba65bfedeb8621cba09cd5a317d8f
Author: Vivek Gautam <vivek.gautam@codeaurora.org>
Date:   Thu May 16 15:00:20 2019 +0530

    iommu/io-pgtable-arm: Add support to use system cache
    
    Few Qualcomm platforms such as, sdm845 have an additional outer
    cache called as System cache, aka. Last level cache (LLC) that
    allows non-coherent devices to upgrade to using caching.
    This cache sits right before the DDR, and is tightly coupled
    with the memory controller. The clients using this cache request
    their slices from this system cache, make it active, and can then
    start using it.
    
    There is a fundamental assumption that non-coherent devices can't
    access caches. This change adds an exception where they *can* use
    some level of cache despite still being non-coherent overall.
    The coherent devices that use cacheable memory, and CPU make use of
    this system cache by default.
    
    Looking at memory types, we have following -
    a) Normal uncached :- MAIR 0x44, inner non-cacheable,
                          outer non-cacheable;
    b) Normal cached :-   MAIR 0xff, inner read write-back non-transient,
                          outer read write-back non-transient;
                          attribute setting for coherenet I/O devices.
    and, for non-coherent i/o devices that can allocate in system cache
    another type gets added -
    c) Normal sys-cached :- MAIR 0xf4, inner non-cacheable,
                            outer read write-back non-transient
    
    Coherent I/O devices use system cache by marking the memory as
    normal cached.
    Non-coherent I/O devices should mark the memory as normal
    sys-cached in page tables to use system cache.
    
    Acked-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Vivek Gautam <vivek.gautam@codeaurora.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index a815cf6f6f47..8ee3fbaf5855 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -41,6 +41,12 @@
  * if the IOMMU page table format is equivalent.
  */
 #define IOMMU_PRIV	(1 << 5)
+/*
+ * Non-coherent masters on few Qualcomm SoCs can use this page protection flag
+ * to set correct cacheability attributes to use an outer level of cache -
+ * last level cache, aka system cache.
+ */
+#define IOMMU_QCOM_SYS_CACHE	(1 << 6)
 
 struct iommu_ops;
 struct iommu_group;

commit adfd373820906d376c8b643f1a279ac809605b6b
Author: Eric Auger <eric.auger@redhat.com>
Date:   Mon Jun 3 08:53:35 2019 +0200

    iommu: Introduce IOMMU_RESV_DIRECT_RELAXABLE reserved memory regions
    
    Introduce a new type for reserved region. This corresponds
    to directly mapped regions which are known to be relaxable
    in some specific conditions, such as device assignment use
    case. Well known examples are those used by USB controllers
    providing PS/2 keyboard emulation for pre-boot BIOS and
    early BOOT or RMRRs associated to IGD working in legacy mode.
    
    Since commit c875d2c1b808 ("iommu/vt-d: Exclude devices using RMRRs
    from IOMMU API domains") and commit 18436afdc11a ("iommu/vt-d: Allow
    RMRR on graphics devices too"), those regions are currently
    considered "safe" with respect to device assignment use case
    which requires a non direct mapping at IOMMU physical level
    (RAM GPA -> HPA mapping).
    
    Those RMRRs currently exist and sometimes the device is
    attempting to access it but this has not been considered
    an issue until now.
    
    However at the moment, iommu_get_group_resv_regions() is
    not able to make any difference between directly mapped
    regions: those which must be absolutely enforced and those
    like above ones which are known as relaxable.
    
    This is a blocker for reporting severe conflicts between
    non relaxable RMRRs (like MSI doorbells) and guest GPA space.
    
    With this new reserved region type we will be able to use
    iommu_get_group_resv_regions() to enumerate the IOVA space
    that is usable through the IOMMU API without introducing
    regressions with respect to existing device assignment
    use cases (USB and IGD).
    
    Signed-off-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 91af22a344e2..ab7a1c85af75 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -135,6 +135,12 @@ enum iommu_attr {
 enum iommu_resv_type {
 	/* Memory regions which must be mapped 1:1 at all times */
 	IOMMU_RESV_DIRECT,
+	/*
+	 * Memory regions which are advertised to be 1:1 but are
+	 * commonly considered relaxable in some conditions,
+	 * for instance in device assignment use case (USB, Graphics)
+	 */
+	IOMMU_RESV_DIRECT_RELAXABLE,
 	/* Arbitrary "never map this or give it to a device" address ranges */
 	IOMMU_RESV_RESERVED,
 	/* Hardware MSI region (untranslated) */

commit bf3255b3cfe2d06280340dbac3f44b65d3ee6da3
Author: Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
Date:   Mon Jun 3 15:57:49 2019 +0100

    iommu: Add recoverable fault reporting
    
    Some IOMMU hardware features, for example PCI PRI and Arm SMMU Stall,
    enable recoverable I/O page faults. Allow IOMMU drivers to report PRI Page
    Requests and Stall events through the new fault reporting API. The
    consumer of the fault can be either an I/O page fault handler in the host,
    or a guest OS.
    
    Once handled, the fault must be completed by sending a page response back
    to the IOMMU. Add an iommu_page_response() function to complete a page
    fault.
    
    There are two ways to extend the userspace API:
    * Add a field to iommu_page_response and a flag to
      iommu_page_response::flags describing the validity of this field.
    * Introduce a new iommu_page_response_X structure with a different version
      number. The kernel must then support both versions.
    
    Signed-off-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
    Signed-off-by: Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 3e783f5bf472..76c8cda61dfd 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -227,6 +227,7 @@ struct iommu_sva_ops {
  * @sva_bind: Bind process address space to device
  * @sva_unbind: Unbind process address space from device
  * @sva_get_pasid: Get PASID associated to a SVA handle
+ * @page_response: handle page request response
  * @pgsize_bitmap: bitmap of all possible supported page sizes
  */
 struct iommu_ops {
@@ -287,6 +288,10 @@ struct iommu_ops {
 	void (*sva_unbind)(struct iommu_sva *handle);
 	int (*sva_get_pasid)(struct iommu_sva *handle);
 
+	int (*page_response)(struct device *dev,
+			     struct iommu_fault_event *evt,
+			     struct iommu_page_response *msg);
+
 	unsigned long pgsize_bitmap;
 };
 
@@ -311,19 +316,25 @@ struct iommu_device {
  * unrecoverable faults such as DMA or IRQ remapping faults.
  *
  * @fault: fault descriptor
+ * @list: pending fault event list, used for tracking responses
  */
 struct iommu_fault_event {
 	struct iommu_fault fault;
+	struct list_head list;
 };
 
 /**
  * struct iommu_fault_param - per-device IOMMU fault data
  * @handler: Callback function to handle IOMMU faults at device level
  * @data: handler private data
+ * @faults: holds the pending faults which needs response
+ * @lock: protect pending faults list
  */
 struct iommu_fault_param {
 	iommu_dev_fault_handler_t handler;
 	void *data;
+	struct list_head faults;
+	struct mutex lock;
 };
 
 /**
@@ -437,6 +448,8 @@ extern int iommu_unregister_device_fault_handler(struct device *dev);
 
 extern int iommu_report_device_fault(struct device *dev,
 				     struct iommu_fault_event *evt);
+extern int iommu_page_response(struct device *dev,
+			       struct iommu_page_response *msg);
 
 extern int iommu_group_id(struct iommu_group *group);
 extern struct iommu_group *iommu_group_get_for_dev(struct device *dev);
@@ -765,6 +778,12 @@ int iommu_report_device_fault(struct device *dev, struct iommu_fault_event *evt)
 	return -ENODEV;
 }
 
+static inline int iommu_page_response(struct device *dev,
+				      struct iommu_page_response *msg)
+{
+	return -ENODEV;
+}
+
 static inline int iommu_group_id(struct iommu_group *group)
 {
 	return -ENODEV;

commit 0c830e6b32826311fc2b9ea1f4679be0f4ef0933
Author: Jacob Pan <jacob.jun.pan@linux.intel.com>
Date:   Mon Jun 3 15:57:48 2019 +0100

    iommu: Introduce device fault report API
    
    Traditionally, device specific faults are detected and handled within
    their own device drivers. When IOMMU is enabled, faults such as DMA
    related transactions are detected by IOMMU. There is no generic
    reporting mechanism to report faults back to the in-kernel device
    driver or the guest OS in case of assigned devices.
    
    This patch introduces a registration API for device specific fault
    handlers. This differs from the existing iommu_set_fault_handler/
    report_iommu_fault infrastructures in several ways:
    - it allows to report more sophisticated fault events (both
      unrecoverable faults and page request faults) due to the nature
      of the iommu_fault struct
    - it is device specific and not domain specific.
    
    The current iommu_report_device_fault() implementation only handles
    the "shoot and forget" unrecoverable fault case. Handling of page
    request faults or stalled faults will come later.
    
    Signed-off-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
    Signed-off-by: Ashok Raj <ashok.raj@intel.com>
    Signed-off-by: Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
    Signed-off-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 2b05056d5fa7..3e783f5bf472 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -336,6 +336,7 @@ struct iommu_fault_param {
  *	struct iommu_fwspec	*iommu_fwspec;
  */
 struct iommu_param {
+	struct mutex lock;
 	struct iommu_fault_param *fault_param;
 };
 
@@ -428,6 +429,15 @@ extern int iommu_group_register_notifier(struct iommu_group *group,
 					 struct notifier_block *nb);
 extern int iommu_group_unregister_notifier(struct iommu_group *group,
 					   struct notifier_block *nb);
+extern int iommu_register_device_fault_handler(struct device *dev,
+					iommu_dev_fault_handler_t handler,
+					void *data);
+
+extern int iommu_unregister_device_fault_handler(struct device *dev);
+
+extern int iommu_report_device_fault(struct device *dev,
+				     struct iommu_fault_event *evt);
+
 extern int iommu_group_id(struct iommu_group *group);
 extern struct iommu_group *iommu_group_get_for_dev(struct device *dev);
 extern struct iommu_domain *iommu_group_default_domain(struct iommu_group *);
@@ -736,6 +746,25 @@ static inline int iommu_group_unregister_notifier(struct iommu_group *group,
 	return 0;
 }
 
+static inline
+int iommu_register_device_fault_handler(struct device *dev,
+					iommu_dev_fault_handler_t handler,
+					void *data)
+{
+	return -ENODEV;
+}
+
+static inline int iommu_unregister_device_fault_handler(struct device *dev)
+{
+	return 0;
+}
+
+static inline
+int iommu_report_device_fault(struct device *dev, struct iommu_fault_event *evt)
+{
+	return -ENODEV;
+}
+
 static inline int iommu_group_id(struct iommu_group *group)
 {
 	return -ENODEV;

commit 4e32348ba5269aac1165f496b78189201568dd8c
Author: Jacob Pan <jacob.jun.pan@linux.intel.com>
Date:   Mon Jun 3 15:57:47 2019 +0100

    iommu: Introduce device fault data
    
    Device faults detected by IOMMU can be reported outside the IOMMU
    subsystem for further processing. This patch introduces
    a generic device fault data structure.
    
    The fault can be either an unrecoverable fault or a page request,
    also referred to as a recoverable fault.
    
    We only care about non internal faults that are likely to be reported
    to an external subsystem.
    
    Signed-off-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
    Signed-off-by: Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
    Signed-off-by: Liu, Yi L <yi.l.liu@linux.intel.com>
    Signed-off-by: Ashok Raj <ashok.raj@intel.com>
    Signed-off-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index a815cf6f6f47..2b05056d5fa7 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -25,6 +25,7 @@
 #include <linux/errno.h>
 #include <linux/err.h>
 #include <linux/of.h>
+#include <uapi/linux/iommu.h>
 
 #define IOMMU_READ	(1 << 0)
 #define IOMMU_WRITE	(1 << 1)
@@ -49,6 +50,7 @@ struct device;
 struct iommu_domain;
 struct notifier_block;
 struct iommu_sva;
+struct iommu_fault_event;
 
 /* iommu fault flags */
 #define IOMMU_FAULT_READ	0x0
@@ -58,6 +60,7 @@ typedef int (*iommu_fault_handler_t)(struct iommu_domain *,
 			struct device *, unsigned long, int, void *);
 typedef int (*iommu_mm_exit_handler_t)(struct device *dev, struct iommu_sva *,
 				       void *);
+typedef int (*iommu_dev_fault_handler_t)(struct iommu_fault *, void *);
 
 struct iommu_domain_geometry {
 	dma_addr_t aperture_start; /* First address that can be mapped    */
@@ -301,6 +304,41 @@ struct iommu_device {
 	struct device *dev;
 };
 
+/**
+ * struct iommu_fault_event - Generic fault event
+ *
+ * Can represent recoverable faults such as a page requests or
+ * unrecoverable faults such as DMA or IRQ remapping faults.
+ *
+ * @fault: fault descriptor
+ */
+struct iommu_fault_event {
+	struct iommu_fault fault;
+};
+
+/**
+ * struct iommu_fault_param - per-device IOMMU fault data
+ * @handler: Callback function to handle IOMMU faults at device level
+ * @data: handler private data
+ */
+struct iommu_fault_param {
+	iommu_dev_fault_handler_t handler;
+	void *data;
+};
+
+/**
+ * struct iommu_param - collection of per-device IOMMU data
+ *
+ * @fault_param: IOMMU detected device fault reporting data
+ *
+ * TODO: migrate other per device data pointers under iommu_dev_data, e.g.
+ *	struct iommu_group	*iommu_group;
+ *	struct iommu_fwspec	*iommu_fwspec;
+ */
+struct iommu_param {
+	struct iommu_fault_param *fault_param;
+};
+
 int  iommu_device_register(struct iommu_device *iommu);
 void iommu_device_unregister(struct iommu_device *iommu);
 int  iommu_device_sysfs_add(struct iommu_device *iommu,
@@ -504,6 +542,7 @@ struct iommu_ops {};
 struct iommu_group {};
 struct iommu_fwspec {};
 struct iommu_device {};
+struct iommu_fault_param {};
 
 static inline bool iommu_present(struct bus_type *bus)
 {

commit 4505153954fdb1465d2b178288a9bf646f2a2166
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:47 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 333
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 59 temple place suite 330 boston ma 02111
      1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 136 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000436.384967451@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index a815cf6f6f47..e552c3b63f6f 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -1,19 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (C) 2007-2008 Advanced Micro Devices, Inc.
  * Author: Joerg Roedel <joerg.roedel@amd.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #ifndef __LINUX_IOMMU_H

commit 7423e01741dd6a5f1255f589145313f0fb1c8cbe
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Sat May 25 13:41:22 2019 +0800

    iommu: Add API to request DMA domain for device
    
    Normally during iommu probing a device, a default doamin will
    be allocated and attached to the device. The domain type of
    the default domain is statically defined, which results in a
    situation where the allocated default domain isn't suitable
    for the device due to some limitations. We already have API
    iommu_request_dm_for_dev() to replace a DMA domain with an
    identity one. This adds iommu_request_dma_domain_for_dev()
    to request a dma domain if an allocated identity domain isn't
    suitable for the device in question.
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index a815cf6f6f47..91af22a344e2 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -362,6 +362,7 @@ extern void iommu_set_fault_handler(struct iommu_domain *domain,
 extern void iommu_get_resv_regions(struct device *dev, struct list_head *list);
 extern void iommu_put_resv_regions(struct device *dev, struct list_head *list);
 extern int iommu_request_dm_for_dev(struct device *dev);
+extern int iommu_request_dma_domain_for_dev(struct device *dev);
 extern struct iommu_resv_region *
 iommu_alloc_resv_region(phys_addr_t start, size_t length, int prot,
 			enum iommu_resv_type type);
@@ -626,6 +627,11 @@ static inline int iommu_request_dm_for_dev(struct device *dev)
 	return -ENODEV;
 }
 
+static inline int iommu_request_dma_domain_for_dev(struct device *dev)
+{
+	return -ENODEV;
+}
+
 static inline int iommu_attach_group(struct iommu_domain *domain,
 				     struct iommu_group *group)
 {

commit d53bff888f3bca8bb618a4b2723a6cfbde46f7ed
Merge: 26ac2b6ee6c0 26b25a2b98e4
Author: Joerg Roedel <jroedel@suse.de>
Date:   Fri Apr 26 17:11:46 2019 +0200

    Merge branch 'api-features' into arm/smmu

commit 5702ee24182f9b3e33476b74b5c92a4f913ad9bd
Author: Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
Date:   Wed Apr 17 19:24:42 2019 +0100

    ACPI/IORT: Check ATS capability in root complex nodes
    
    Root complex node in IORT has a bit telling whether it supports ATS or
    not. Store this bit in the IOMMU fwspec when setting up a device, so it
    can be accessed later by an IOMMU driver. In the future we'll probably
    want to store this bit at the host bridge or SMMU rather than in each
    endpoint.
    
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index ffbbc7e39cee..6c1b4c900191 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -392,10 +392,14 @@ struct iommu_fwspec {
 	const struct iommu_ops	*ops;
 	struct fwnode_handle	*iommu_fwnode;
 	void			*iommu_priv;
+	u32			flags;
 	unsigned int		num_ids;
 	u32			ids[1];
 };
 
+/* ATS is supported */
+#define IOMMU_FWSPEC_PCI_RC_ATS			(1 << 0)
+
 int iommu_fwspec_init(struct device *dev, struct fwnode_handle *iommu_fwnode,
 		      const struct iommu_ops *ops);
 void iommu_fwspec_free(struct device *dev);

commit 26b25a2b98e45aeb40eedcedc586ad5034cbd984
Author: Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
Date:   Wed Apr 10 16:15:16 2019 +0100

    iommu: Bind process address spaces to devices
    
    Add bind() and unbind() operations to the IOMMU API.
    iommu_sva_bind_device() binds a device to an mm, and returns a handle to
    the bond, which is released by calling iommu_sva_unbind_device().
    
    Each mm bound to devices gets a PASID (by convention, a 20-bit system-wide
    ID representing the address space), which can be retrieved with
    iommu_sva_get_pasid(). When programming DMA addresses, device drivers
    include this PASID in a device-specific manner, to let the device access
    the given address space. Since the process memory may be paged out, device
    and IOMMU must support I/O page faults (e.g. PCI PRI).
    
    Using iommu_sva_set_ops(), device drivers provide an mm_exit() callback
    that is called by the IOMMU driver if the process exits before the device
    driver called unbind(). In mm_exit(), device driver should disable DMA
    from the given context, so that the core IOMMU can reallocate the PASID.
    Whether the process exited or nor, the device driver should always release
    the handle with unbind().
    
    To use these functions, device driver must first enable the
    IOMMU_DEV_FEAT_SVA device feature with iommu_dev_enable_feature().
    
    Signed-off-by: Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 8239ece9fdfc..480921dfbadf 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -48,6 +48,7 @@ struct bus_type;
 struct device;
 struct iommu_domain;
 struct notifier_block;
+struct iommu_sva;
 
 /* iommu fault flags */
 #define IOMMU_FAULT_READ	0x0
@@ -55,6 +56,8 @@ struct notifier_block;
 
 typedef int (*iommu_fault_handler_t)(struct iommu_domain *,
 			struct device *, unsigned long, int, void *);
+typedef int (*iommu_mm_exit_handler_t)(struct device *dev, struct iommu_sva *,
+				       void *);
 
 struct iommu_domain_geometry {
 	dma_addr_t aperture_start; /* First address that can be mapped    */
@@ -159,6 +162,28 @@ struct iommu_resv_region {
 /* Per device IOMMU features */
 enum iommu_dev_features {
 	IOMMU_DEV_FEAT_AUX,	/* Aux-domain feature */
+	IOMMU_DEV_FEAT_SVA,	/* Shared Virtual Addresses */
+};
+
+#define IOMMU_PASID_INVALID	(-1U)
+
+/**
+ * struct iommu_sva_ops - device driver callbacks for an SVA context
+ *
+ * @mm_exit: called when the mm is about to be torn down by exit_mmap. After
+ *           @mm_exit returns, the device must not issue any more transaction
+ *           with the PASID given as argument.
+ *
+ *           The @mm_exit handler is allowed to sleep. Be careful about the
+ *           locks taken in @mm_exit, because they might lead to deadlocks if
+ *           they are also held when dropping references to the mm. Consider the
+ *           following call chain:
+ *           mutex_lock(A); mmput(mm) -> exit_mm() -> @mm_exit() -> mutex_lock(A)
+ *           Using mmput_async() prevents this scenario.
+ *
+ */
+struct iommu_sva_ops {
+	iommu_mm_exit_handler_t mm_exit;
 };
 
 #ifdef CONFIG_IOMMU_API
@@ -196,6 +221,9 @@ enum iommu_dev_features {
  * @dev_feat_enabled: check enabled feature
  * @aux_attach/detach_dev: aux-domain specific attach/detach entries.
  * @aux_get_pasid: get the pasid given an aux-domain
+ * @sva_bind: Bind process address space to device
+ * @sva_unbind: Unbind process address space from device
+ * @sva_get_pasid: Get PASID associated to a SVA handle
  * @pgsize_bitmap: bitmap of all possible supported page sizes
  */
 struct iommu_ops {
@@ -251,6 +279,11 @@ struct iommu_ops {
 	void (*aux_detach_dev)(struct iommu_domain *domain, struct device *dev);
 	int (*aux_get_pasid)(struct iommu_domain *domain, struct device *dev);
 
+	struct iommu_sva *(*sva_bind)(struct device *dev, struct mm_struct *mm,
+				      void *drvdata);
+	void (*sva_unbind)(struct iommu_sva *handle);
+	int (*sva_get_pasid)(struct iommu_sva *handle);
+
 	unsigned long pgsize_bitmap;
 };
 
@@ -417,6 +450,14 @@ struct iommu_fwspec {
 	u32			ids[1];
 };
 
+/**
+ * struct iommu_sva - handle to a device-mm bond
+ */
+struct iommu_sva {
+	struct device			*dev;
+	const struct iommu_sva_ops	*ops;
+};
+
 int iommu_fwspec_init(struct device *dev, struct fwnode_handle *iommu_fwnode,
 		      const struct iommu_ops *ops);
 void iommu_fwspec_free(struct device *dev);
@@ -445,6 +486,14 @@ int iommu_aux_attach_device(struct iommu_domain *domain, struct device *dev);
 void iommu_aux_detach_device(struct iommu_domain *domain, struct device *dev);
 int iommu_aux_get_pasid(struct iommu_domain *domain, struct device *dev);
 
+struct iommu_sva *iommu_sva_bind_device(struct device *dev,
+					struct mm_struct *mm,
+					void *drvdata);
+void iommu_sva_unbind_device(struct iommu_sva *handle);
+int iommu_sva_set_ops(struct iommu_sva *handle,
+		      const struct iommu_sva_ops *ops);
+int iommu_sva_get_pasid(struct iommu_sva *handle);
+
 #else /* CONFIG_IOMMU_API */
 
 struct iommu_ops {};
@@ -770,6 +819,27 @@ iommu_aux_get_pasid(struct iommu_domain *domain, struct device *dev)
 	return -ENODEV;
 }
 
+static inline struct iommu_sva *
+iommu_sva_bind_device(struct device *dev, struct mm_struct *mm, void *drvdata)
+{
+	return NULL;
+}
+
+static inline void iommu_sva_unbind_device(struct iommu_sva *handle)
+{
+}
+
+static inline int iommu_sva_set_ops(struct iommu_sva *handle,
+				    const struct iommu_sva_ops *ops)
+{
+	return -EINVAL;
+}
+
+static inline int iommu_sva_get_pasid(struct iommu_sva *handle)
+{
+	return IOMMU_PASID_INVALID;
+}
+
 #endif /* CONFIG_IOMMU_API */
 
 #ifdef CONFIG_IOMMU_DEBUGFS

commit a3a195929d40b38833ffd0f82b2db2cc898641eb
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Mon Mar 25 09:30:28 2019 +0800

    iommu: Add APIs for multiple domains per device
    
    Sharing a physical PCI device in a finer-granularity way
    is becoming a consensus in the industry. IOMMU vendors
    are also engaging efforts to support such sharing as well
    as possible. Among the efforts, the capability of support
    finer-granularity DMA isolation is a common requirement
    due to the security consideration. With finer-granularity
    DMA isolation, subsets of a PCI function can be isolated
    from each others by the IOMMU. As a result, there is a
    request in software to attach multiple domains to a physical
    PCI device. One example of such use model is the Intel
    Scalable IOV [1] [2]. The Intel vt-d 3.0 spec [3] introduces
    the scalable mode which enables PASID granularity DMA
    isolation.
    
    This adds the APIs to support multiple domains per device.
    In order to ease the discussions, we call it 'a domain in
    auxiliary mode' or simply 'auxiliary domain' when multiple
    domains are attached to a physical device.
    
    The APIs include:
    
    * iommu_dev_has_feature(dev, IOMMU_DEV_FEAT_AUX)
      - Detect both IOMMU and PCI endpoint devices supporting
        the feature (aux-domain here) without the host driver
        dependency.
    
    * iommu_dev_feature_enabled(dev, IOMMU_DEV_FEAT_AUX)
      - Check the enabling status of the feature (aux-domain
        here). The aux-domain interfaces are available only
        if this returns true.
    
    * iommu_dev_enable/disable_feature(dev, IOMMU_DEV_FEAT_AUX)
      - Enable/disable device specific aux-domain feature.
    
    * iommu_aux_attach_device(domain, dev)
      - Attaches @domain to @dev in the auxiliary mode. Multiple
        domains could be attached to a single device in the
        auxiliary mode with each domain representing an isolated
        address space for an assignable subset of the device.
    
    * iommu_aux_detach_device(domain, dev)
      - Detach @domain which has been attached to @dev in the
        auxiliary mode.
    
    * iommu_aux_get_pasid(domain, dev)
      - Return ID used for finer-granularity DMA translation.
        For the Intel Scalable IOV usage model, this will be
        a PASID. The device which supports Scalable IOV needs
        to write this ID to the device register so that DMA
        requests could be tagged with a right PASID prefix.
    
    This has been updated with the latest proposal from Joerg
    posted here [5].
    
    Many people involved in discussions of this design.
    
    Kevin Tian <kevin.tian@intel.com>
    Liu Yi L <yi.l.liu@intel.com>
    Ashok Raj <ashok.raj@intel.com>
    Sanjay Kumar <sanjay.k.kumar@intel.com>
    Jacob Pan <jacob.jun.pan@linux.intel.com>
    Alex Williamson <alex.williamson@redhat.com>
    Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
    Joerg Roedel <joro@8bytes.org>
    
    and some discussions can be found here [4] [5].
    
    [1] https://software.intel.com/en-us/download/intel-scalable-io-virtualization-technical-specification
    [2] https://schd.ws/hosted_files/lc32018/00/LC3-SIOV-final.pdf
    [3] https://software.intel.com/en-us/download/intel-virtualization-technology-for-directed-io-architecture-specification
    [4] https://lkml.org/lkml/2018/7/26/4
    [5] https://www.spinics.net/lists/iommu/msg31874.html
    
    Cc: Ashok Raj <ashok.raj@intel.com>
    Cc: Jacob Pan <jacob.jun.pan@linux.intel.com>
    Cc: Kevin Tian <kevin.tian@intel.com>
    Cc: Liu Yi L <yi.l.liu@intel.com>
    Suggested-by: Kevin Tian <kevin.tian@intel.com>
    Suggested-by: Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
    Suggested-by: Joerg Roedel <jroedel@suse.de>
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Reviewed-by: Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index ffbbc7e39cee..8239ece9fdfc 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -156,6 +156,11 @@ struct iommu_resv_region {
 	enum iommu_resv_type	type;
 };
 
+/* Per device IOMMU features */
+enum iommu_dev_features {
+	IOMMU_DEV_FEAT_AUX,	/* Aux-domain feature */
+};
+
 #ifdef CONFIG_IOMMU_API
 
 /**
@@ -186,6 +191,11 @@ struct iommu_resv_region {
  * @of_xlate: add OF master IDs to iommu grouping
  * @is_attach_deferred: Check if domain attach should be deferred from iommu
  *                      driver init to device driver init (default no)
+ * @dev_has/enable/disable_feat: per device entries to check/enable/disable
+ *                               iommu specific features.
+ * @dev_feat_enabled: check enabled feature
+ * @aux_attach/detach_dev: aux-domain specific attach/detach entries.
+ * @aux_get_pasid: get the pasid given an aux-domain
  * @pgsize_bitmap: bitmap of all possible supported page sizes
  */
 struct iommu_ops {
@@ -230,6 +240,17 @@ struct iommu_ops {
 	int (*of_xlate)(struct device *dev, struct of_phandle_args *args);
 	bool (*is_attach_deferred)(struct iommu_domain *domain, struct device *dev);
 
+	/* Per device IOMMU features */
+	bool (*dev_has_feat)(struct device *dev, enum iommu_dev_features f);
+	bool (*dev_feat_enabled)(struct device *dev, enum iommu_dev_features f);
+	int (*dev_enable_feat)(struct device *dev, enum iommu_dev_features f);
+	int (*dev_disable_feat)(struct device *dev, enum iommu_dev_features f);
+
+	/* Aux-domain specific attach/detach entries */
+	int (*aux_attach_dev)(struct iommu_domain *domain, struct device *dev);
+	void (*aux_detach_dev)(struct iommu_domain *domain, struct device *dev);
+	int (*aux_get_pasid)(struct iommu_domain *domain, struct device *dev);
+
 	unsigned long pgsize_bitmap;
 };
 
@@ -416,6 +437,14 @@ static inline void dev_iommu_fwspec_set(struct device *dev,
 int iommu_probe_device(struct device *dev);
 void iommu_release_device(struct device *dev);
 
+bool iommu_dev_has_feature(struct device *dev, enum iommu_dev_features f);
+int iommu_dev_enable_feature(struct device *dev, enum iommu_dev_features f);
+int iommu_dev_disable_feature(struct device *dev, enum iommu_dev_features f);
+bool iommu_dev_feature_enabled(struct device *dev, enum iommu_dev_features f);
+int iommu_aux_attach_device(struct iommu_domain *domain, struct device *dev);
+void iommu_aux_detach_device(struct iommu_domain *domain, struct device *dev);
+int iommu_aux_get_pasid(struct iommu_domain *domain, struct device *dev);
+
 #else /* CONFIG_IOMMU_API */
 
 struct iommu_ops {};
@@ -700,6 +729,47 @@ const struct iommu_ops *iommu_ops_from_fwnode(struct fwnode_handle *fwnode)
 	return NULL;
 }
 
+static inline bool
+iommu_dev_has_feature(struct device *dev, enum iommu_dev_features feat)
+{
+	return false;
+}
+
+static inline bool
+iommu_dev_feature_enabled(struct device *dev, enum iommu_dev_features feat)
+{
+	return false;
+}
+
+static inline int
+iommu_dev_enable_feature(struct device *dev, enum iommu_dev_features feat)
+{
+	return -ENODEV;
+}
+
+static inline int
+iommu_dev_disable_feature(struct device *dev, enum iommu_dev_features feat)
+{
+	return -ENODEV;
+}
+
+static inline int
+iommu_aux_attach_device(struct iommu_domain *domain, struct device *dev)
+{
+	return -ENODEV;
+}
+
+static inline void
+iommu_aux_detach_device(struct iommu_domain *domain, struct device *dev)
+{
+}
+
+static inline int
+iommu_aux_get_pasid(struct iommu_domain *domain, struct device *dev)
+{
+	return -ENODEV;
+}
+
 #endif /* CONFIG_IOMMU_API */
 
 #ifdef CONFIG_IOMMU_DEBUGFS

commit d05e4c8600c36084ce9de6249bb972c9bdd75b7e
Merge: cffaaf0c8162 ba93c357229f 707223095ccf a947a45f0529 48739afaac2a 5f226da1b1d7 32d5860a9e3c 18b3af4492a0
Author: Joerg Roedel <jroedel@suse.de>
Date:   Fri Mar 1 11:24:51 2019 +0100

    Merge branches 'iommu/fixes', 'arm/msm', 'arm/tegra', 'arm/mediatek', 'x86/vt-d', 'x86/amd', 'hyper-v' and 'core' into next

commit a7055d572c51338bed8673331ead6759cae6b70b
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Feb 20 14:00:53 2019 +0100

    iommu: Document iommu_ops.is_attach_deferred()
    
    Add missing kerneldoc for iommu_ops.is_attach_deferred().
    
    Fixes: e01d1913b0d08171 ("iommu: Add is_attach_deferred call-back to iommu-ops")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 28ad97801032..41fa7958592d 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -184,6 +184,8 @@ struct iommu_resv_region {
  * @domain_window_enable: Configure and enable a particular window for a domain
  * @domain_window_disable: Disable a particular window for a domain
  * @of_xlate: add OF master IDs to iommu grouping
+ * @is_attach_deferred: Check if domain attach should be deferred from iommu
+ *                      driver init to device driver init (default no)
  * @pgsize_bitmap: bitmap of all possible supported page sizes
  */
 struct iommu_ops {

commit 2405bc162583e1d7c40b13bf078e87428d2dfe4e
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Feb 20 14:00:52 2019 +0100

    iommu: Document iommu_ops.iotlb_sync_map()
    
    Add missing kerneldoc for iommu_ops.iotlb_sync_map().
    
    Fixes: 1d7ae53b152dbc5b ("iommu: Introduce iotlb_sync_map callback")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 2b402dcbcf81..28ad97801032 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -169,6 +169,7 @@ struct iommu_resv_region {
  * @unmap: unmap a physically contiguous memory region from an iommu domain
  * @flush_iotlb_all: Synchronously flush all hardware TLBs for this domain
  * @iotlb_range_add: Add a given iova range to the flush queue for this domain
+ * @iotlb_sync_map: Sync mappings created recently using @map to the hardware
  * @iotlb_sync: Flush all queued ranges from the hardware TLBs and empty flush
  *            queue
  * @iova_to_phys: translate iova to physical address

commit db04d4a3d72f0c5ee34609559f535d11ab47303c
Author: Tom Murphy <murphyt7@tcd.ie>
Date:   Mon Feb 11 15:50:33 2019 +0000

    iommu: Fix flush_tlb_all typo
    
    Fix typo, flush_tlb_all should be flush_iotlb_all.
    
    Signed-off-by: Tom Murphy <murphyt7@tcd.ie>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index e90da6b6f3d1..2b402dcbcf81 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -167,7 +167,7 @@ struct iommu_resv_region {
  * @detach_dev: detach device from an iommu domain
  * @map: map a physically contiguous memory region to an iommu domain
  * @unmap: unmap a physically contiguous memory region from an iommu domain
- * @flush_tlb_all: Synchronously flush all hardware TLBs for this domain
+ * @flush_iotlb_all: Synchronously flush all hardware TLBs for this domain
  * @iotlb_range_add: Add a given iova range to the flush queue for this domain
  * @iotlb_sync: Flush all queued ranges from the hardware TLBs and empty flush
  *            queue

commit 1d7ae53b152dbc5ba0a4f6a83ecc42ac66f52d11
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Wed Dec 12 23:38:47 2018 +0300

    iommu: Introduce iotlb_sync_map callback
    
    Introduce iotlb_sync_map() callback that is invoked in the end of
    iommu_map(). This new callback allows IOMMU drivers to avoid syncing
    after mapping of each contiguous chunk and sync only when the whole
    mapping is completed, optimizing performance of the mapping operation.
    
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index e90da6b6f3d1..477ef47c357c 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -201,6 +201,7 @@ struct iommu_ops {
 	void (*flush_iotlb_all)(struct iommu_domain *domain);
 	void (*iotlb_range_add)(struct iommu_domain *domain,
 				unsigned long iova, size_t size);
+	void (*iotlb_sync_map)(struct iommu_domain *domain);
 	void (*iotlb_sync)(struct iommu_domain *domain);
 	phys_addr_t (*iova_to_phys)(struct iommu_domain *domain, dma_addr_t iova);
 	int (*add_device)(struct device *dev);

commit cc5aed44a3a8e4fca721636cf881a52f8d68a098
Author: Joerg Roedel <jroedel@suse.de>
Date:   Fri Nov 30 10:31:59 2018 +0100

    iommu: Consolitate ->add/remove_device() calls
    
    Put them into separate functions and call those where the
    plain ops have been called before.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 26225f762cd7..e90da6b6f3d1 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -409,6 +409,9 @@ static inline void dev_iommu_fwspec_set(struct device *dev,
 	dev->iommu_fwspec = fwspec;
 }
 
+int iommu_probe_device(struct device *dev);
+void iommu_release_device(struct device *dev);
+
 #else /* CONFIG_IOMMU_API */
 
 struct iommu_ops {};

commit b4ef725eeba158f365da9de1f05149094643ddea
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Nov 28 13:35:24 2018 +0100

    iommu: Introduce wrappers around dev->iommu_fwspec
    
    These wrappers will be used to easily change the location of
    the field later when all users are converted.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 11db18b9ffe8..26225f762cd7 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -398,6 +398,17 @@ void iommu_fwspec_free(struct device *dev);
 int iommu_fwspec_add_ids(struct device *dev, u32 *ids, int num_ids);
 const struct iommu_ops *iommu_ops_from_fwnode(struct fwnode_handle *fwnode);
 
+static inline struct iommu_fwspec *dev_iommu_fwspec_get(struct device *dev)
+{
+	return dev->iommu_fwspec;
+}
+
+static inline void dev_iommu_fwspec_set(struct device *dev,
+					struct iommu_fwspec *fwspec)
+{
+	dev->iommu_fwspec = fwspec;
+}
+
 #else /* CONFIG_IOMMU_API */
 
 struct iommu_ops {};

commit 51eb78098ab79bba8b1df24da2304e61deb74629
Author: tom <murphyt7@tcd.ie>
Date:   Tue Dec 4 18:27:34 2018 +0000

    iommu: Change tlb_range_add to iotlb_range_add and tlb_sync to iotlb_sync
    
    Someone forgot to update this comment.
    
    Signed-off-by: Tom Murphy <murphyt7@tcd.ie>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index a1d28f42cb77..11db18b9ffe8 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -168,8 +168,8 @@ struct iommu_resv_region {
  * @map: map a physically contiguous memory region to an iommu domain
  * @unmap: unmap a physically contiguous memory region from an iommu domain
  * @flush_tlb_all: Synchronously flush all hardware TLBs for this domain
- * @tlb_range_add: Add a given iova range to the flush queue for this domain
- * @tlb_sync: Flush all queued ranges from the hardware TLBs and empty flush
+ * @iotlb_range_add: Add a given iova range to the flush queue for this domain
+ * @iotlb_sync: Flush all queued ranges from the hardware TLBs and empty flush
  *            queue
  * @iova_to_phys: translate iova to physical address
  * @add_device: add device to iommu grouping

commit 2f2fbfb71ecc221352d84ae6430b42031ae5b654
Merge: 0238df646e62 a089845b3ed2 5e731073bc0a bc46c229b6af 18f99c9b9dec e84b7cc457f9 35449adce847
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Oct 10 18:09:37 2018 +0200

    Merge branches 'arm/renesas', 'arm/smmu', 'ppc/pamu', 'x86/vt-d', 'x86/amd' and 'core' into next

commit 2da274cdf998a1c12afa6b5975db2df1df01edf1
Author: Zhen Lei <thunder.leizhen@huawei.com>
Date:   Thu Sep 20 17:10:22 2018 +0100

    iommu/dma: Add support for non-strict mode
    
    With the flush queue infrastructure already abstracted into IOVA
    domains, hooking it up in iommu-dma is pretty simple. Since there is a
    degree of dependency on the IOMMU driver knowing what to do to play
    along, we key the whole thing off a domain attribute which will be set
    on default DMA ops domains to request non-strict invalidation. That way,
    drivers can indicate the appropriate support by acknowledging the
    attribute, and we can easily fall back to strict invalidation otherwise.
    
    The flush queue callback needs a handle on the iommu_domain which owns
    our cookie, so we have to add a pointer back to that, but neatly, that's
    also sufficient to indicate whether we're using a flush queue or not,
    and thus which way to release IOVAs. The only slight subtlety is
    switching __iommu_dma_unmap() from calling iommu_unmap() to explicit
    iommu_unmap_fast()/iommu_tlb_sync() so that we can elide the sync
    entirely in non-strict mode.
    
    Signed-off-by: Zhen Lei <thunder.leizhen@huawei.com>
    [rm: convert to domain attribute, tweak comments and commit message]
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 87994c265bf5..decabe8e8dbe 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -124,6 +124,7 @@ enum iommu_attr {
 	DOMAIN_ATTR_FSL_PAMU_ENABLE,
 	DOMAIN_ATTR_FSL_PAMUV1,
 	DOMAIN_ATTR_NESTING,	/* two stages of translation */
+	DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE,
 	DOMAIN_ATTR_MAX,
 };
 

commit 5131e08cd0f8a3faa30c1cdaf53940d6bce1715a
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Wed Sep 19 11:12:58 2018 +0100

    iommu: Remove .domain_{get,set}_windows
    
    Since these are trivially handled by the .domain_{get,set}_attr
    callbacks when relevant, we can streamline struct iommu_ops for
    everyone.
    
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index c783648d4060..c08ba5d2d451 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -181,8 +181,6 @@ struct iommu_resv_region {
  * @apply_resv_region: Temporary helper call-back for iova reserved ranges
  * @domain_window_enable: Configure and enable a particular window for a domain
  * @domain_window_disable: Disable a particular window for a domain
- * @domain_set_windows: Set the number of windows for a domain
- * @domain_get_windows: Return the number of windows for a domain
  * @of_xlate: add OF master IDs to iommu grouping
  * @pgsize_bitmap: bitmap of all possible supported page sizes
  */
@@ -223,10 +221,6 @@ struct iommu_ops {
 	int (*domain_window_enable)(struct iommu_domain *domain, u32 wnd_nr,
 				    phys_addr_t paddr, u64 size, int prot);
 	void (*domain_window_disable)(struct iommu_domain *domain, u32 wnd_nr);
-	/* Set the number of windows per domain */
-	int (*domain_set_windows)(struct iommu_domain *domain, u32 w_count);
-	/* Get the number of windows per domain */
-	u32 (*domain_get_windows)(struct iommu_domain *domain);
 
 	int (*of_xlate)(struct device *dev, struct of_phandle_args *args);
 	bool (*is_attach_deferred)(struct iommu_domain *domain, struct device *dev);

commit 6af588fed39178c8e118fcf9cb6664e58a1fbe88
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Wed Sep 12 16:24:12 2018 +0100

    iommu: Add fast hook for getting DMA domains
    
    While iommu_get_domain_for_dev() is the robust way for arbitrary IOMMU
    API callers to retrieve the domain pointer, for DMA ops domains it
    doesn't scale well for large systems and multi-queue devices, since the
    momentary refcount adjustment will lead to exclusive cacheline contention
    when multiple CPUs are operating in parallel on different mappings for
    the same device.
    
    In the case of DMA ops domains, however, this refcounting is actually
    unnecessary, since they already imply that the group exists and is
    managed by platform code and IOMMU internals (by virtue of
    iommu_group_get_for_dev()) such that a reference will already be held
    for the lifetime of the device. Thus we can avoid the bottleneck by
    providing a fast lookup specifically for the DMA code to retrieve the
    default domain it already knows it has set up - a simple read-only
    dereference plays much nicer with cache-coherency protocols.
    
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Tested-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 87994c265bf5..c783648d4060 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -293,6 +293,7 @@ extern int iommu_attach_device(struct iommu_domain *domain,
 extern void iommu_detach_device(struct iommu_domain *domain,
 				struct device *dev);
 extern struct iommu_domain *iommu_get_domain_for_dev(struct device *dev);
+extern struct iommu_domain *iommu_get_dma_domain(struct device *dev);
 extern int iommu_map(struct iommu_domain *domain, unsigned long iova,
 		     phys_addr_t paddr, size_t size, int prot);
 extern size_t iommu_unmap(struct iommu_domain *domain, unsigned long iova,

commit eab03e2a1a3d9d354943aff5ae5e4254ee1ec967
Author: Nipun Gupta <nipun.gupta@nxp.com>
Date:   Mon Sep 10 19:19:18 2018 +0530

    iommu/arm-smmu: Add support for the fsl-mc bus
    
    Implement bus specific support for the fsl-mc bus including
    registering arm_smmu_ops and bus specific device add operations.
    
    Signed-off-by: Nipun Gupta <nipun.gupta@nxp.com>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 87994c265bf5..70102df4b994 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -377,6 +377,8 @@ static inline void iommu_tlb_sync(struct iommu_domain *domain)
 extern struct iommu_group *pci_device_group(struct device *dev);
 /* Generic device grouping function */
 extern struct iommu_group *generic_device_group(struct device *dev);
+/* FSL-MC device grouping function */
+struct iommu_group *fsl_mc_device_group(struct device *dev);
 
 /**
  * struct iommu_fwspec - per-device IOMMU instance data

commit d88e61faad526a5850e9330c846641b91cf971e7
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jul 30 09:36:26 2018 +0200

    iommu: Remove the ->map_sg indirection
    
    All iommu drivers use the default_iommu_map_sg implementation, and there
    is no good reason to ever override it.  Just expose it as iommu_map_sg
    directly and remove the indirection, specially in our post-spectre world
    where indirect calls are horribly expensive.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 7447b0b0579a..87994c265bf5 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -166,8 +166,6 @@ struct iommu_resv_region {
  * @detach_dev: detach device from an iommu domain
  * @map: map a physically contiguous memory region to an iommu domain
  * @unmap: unmap a physically contiguous memory region from an iommu domain
- * @map_sg: map a scatter-gather list of physically contiguous memory chunks
- *          to an iommu domain
  * @flush_tlb_all: Synchronously flush all hardware TLBs for this domain
  * @tlb_range_add: Add a given iova range to the flush queue for this domain
  * @tlb_sync: Flush all queued ranges from the hardware TLBs and empty flush
@@ -201,8 +199,6 @@ struct iommu_ops {
 		   phys_addr_t paddr, size_t size, int prot);
 	size_t (*unmap)(struct iommu_domain *domain, unsigned long iova,
 		     size_t size);
-	size_t (*map_sg)(struct iommu_domain *domain, unsigned long iova,
-			 struct scatterlist *sg, unsigned int nents, int prot);
 	void (*flush_iotlb_all)(struct iommu_domain *domain);
 	void (*iotlb_range_add)(struct iommu_domain *domain,
 				unsigned long iova, size_t size);
@@ -303,9 +299,8 @@ extern size_t iommu_unmap(struct iommu_domain *domain, unsigned long iova,
 			  size_t size);
 extern size_t iommu_unmap_fast(struct iommu_domain *domain,
 			       unsigned long iova, size_t size);
-extern size_t default_iommu_map_sg(struct iommu_domain *domain, unsigned long iova,
-				struct scatterlist *sg,unsigned int nents,
-				int prot);
+extern size_t iommu_map_sg(struct iommu_domain *domain, unsigned long iova,
+			   struct scatterlist *sg,unsigned int nents, int prot);
 extern phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain, dma_addr_t iova);
 extern void iommu_set_fault_handler(struct iommu_domain *domain,
 			iommu_fault_handler_t handler, void *token);
@@ -378,13 +373,6 @@ static inline void iommu_tlb_sync(struct iommu_domain *domain)
 		domain->ops->iotlb_sync(domain);
 }
 
-static inline size_t iommu_map_sg(struct iommu_domain *domain,
-				  unsigned long iova, struct scatterlist *sg,
-				  unsigned int nents, int prot)
-{
-	return domain->ops->map_sg(domain, iova, sg, nents, prot);
-}
-
 /* PCI device grouping function */
 extern struct iommu_group *pci_device_group(struct device *dev);
 /* Generic device grouping function */

commit bad614b24293ae463e74d2465685f0e4e229baca
Author: Gary R Hook <gary.hook@amd.com>
Date:   Tue Jun 12 16:41:21 2018 -0500

    iommu: Enable debugfs exposure of IOMMU driver internals
    
    Provide base enablement for using debugfs to expose internal data of an
    IOMMU driver. When called, create the /sys/kernel/debug/iommu directory.
    
    Emit a strong warning at boot time to indicate that this feature is
    enabled.
    
    This function is called from iommu_init, and creates the initial DebugFS
    directory. Drivers may then call iommu_debugfs_new_driver_dir() to
    instantiate a device-specific directory to expose internal data.
    It will return a pointer to the new dentry structure created in
    /sys/kernel/debug/iommu, or NULL in the event of a failure.
    
    Since the IOMMU driver can not be removed from the running system, there
    is no need for an "off" function.
    
    Signed-off-by: Gary R Hook <gary.hook@amd.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 19938ee6eb31..7447b0b0579a 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -698,4 +698,11 @@ const struct iommu_ops *iommu_ops_from_fwnode(struct fwnode_handle *fwnode)
 
 #endif /* CONFIG_IOMMU_API */
 
+#ifdef CONFIG_IOMMU_DEBUGFS
+extern	struct dentry *iommu_debugfs_dir;
+void iommu_debugfs_setup(void);
+#else
+static inline void iommu_debugfs_setup(void) {}
+#endif
+
 #endif /* __LINUX_IOMMU_H */

commit c5611a8751e67595e4e7d3feaff3c900b92094b9
Author: Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
Date:   Mon Feb 5 05:45:53 2018 -0500

    iommu: Do not return error code for APIs with size_t return type
    
    Currently, iommu_unmap, iommu_unmap_fast and iommu_map_sg return
    size_t.  However, some of the return values are error codes (< 0),
    which can be misinterpreted as large size. Therefore, returning size 0
    instead to signify failure to map/unmap.
    
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 41b8c5757859..19938ee6eb31 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -465,23 +465,23 @@ static inline int iommu_map(struct iommu_domain *domain, unsigned long iova,
 	return -ENODEV;
 }
 
-static inline int iommu_unmap(struct iommu_domain *domain, unsigned long iova,
-			      size_t size)
+static inline size_t iommu_unmap(struct iommu_domain *domain,
+				 unsigned long iova, size_t size)
 {
-	return -ENODEV;
+	return 0;
 }
 
-static inline int iommu_unmap_fast(struct iommu_domain *domain, unsigned long iova,
-				   int gfp_order)
+static inline size_t iommu_unmap_fast(struct iommu_domain *domain,
+				      unsigned long iova, int gfp_order)
 {
-	return -ENODEV;
+	return 0;
 }
 
 static inline size_t iommu_map_sg(struct iommu_domain *domain,
 				  unsigned long iova, struct scatterlist *sg,
 				  unsigned int nents, int prot)
 {
-	return -ENODEV;
+	return 0;
 }
 
 static inline void iommu_flush_tlb_all(struct iommu_domain *domain)

commit 50ce6312f293e129eedf2affc7bd791c71d8287e
Author: Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
Date:   Tue Sep 26 19:32:52 2017 +0100

    iommu: Fix comment for iommu_ops.map_sg
    
    The definition of map_sg was split during a recent addition to iommu_ops.
    Put it back together.
    
    Fixes: add02cfdc9bc ("iommu: Introduce Interface for IOMMU TLB Flushing")
    Signed-off-by: Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index a7f2ac689d29..41b8c5757859 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -167,11 +167,11 @@ struct iommu_resv_region {
  * @map: map a physically contiguous memory region to an iommu domain
  * @unmap: unmap a physically contiguous memory region from an iommu domain
  * @map_sg: map a scatter-gather list of physically contiguous memory chunks
+ *          to an iommu domain
  * @flush_tlb_all: Synchronously flush all hardware TLBs for this domain
  * @tlb_range_add: Add a given iova range to the flush queue for this domain
  * @tlb_sync: Flush all queued ranges from the hardware TLBs and empty flush
  *            queue
- * to an iommu domain
  * @iova_to_phys: translate iova to physical address
  * @add_device: add device to iommu grouping
  * @remove_device: remove device from iommu grouping

commit 47b59d8e40850a05370ee9198ea5e505d89489f1
Merge: cc4a41fe5541 0b9a36947c6b 8da4af95867e c3aa47424918 bfee0cf0ee1d 419399804382 96302d89a035 6ce5b0f22d60 af6ee6c1c4db 3ff2dcc05894 5082219b6a61 ec62b1ab0f4c cceb84519520 add02cfdc9bc
Author: Joerg Roedel <jroedel@suse.de>
Date:   Fri Sep 1 11:31:42 2017 +0200

    Merge branches 'arm/exynos', 'arm/renesas', 'arm/rockchip', 'arm/omap', 'arm/mediatek', 'arm/tegra', 'arm/qcom', 'arm/smmu', 'ppc/pamu', 'x86/vt-d', 'x86/amd', 's390' and 'core' into next

commit add02cfdc9bc2987b0121861d5bb0c7392865be9
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Aug 23 15:50:04 2017 +0200

    iommu: Introduce Interface for IOMMU TLB Flushing
    
    With the current IOMMU-API the hardware TLBs have to be
    flushed in every iommu_ops->unmap() call-back.
    
    For unmapping large amounts of address space, like it
    happens when a KVM domain with assigned devices is
    destroyed, this causes thousands of unnecessary TLB flushes
    in the IOMMU hardware because the unmap call-back runs for
    every unmapped physical page.
    
    With the TLB Flush Interface and the new iommu_unmap_fast()
    function introduced here the need to clean the hardware TLBs
    is removed from the unmapping code-path. Users of
    iommu_unmap_fast() have to explicitly call the TLB-Flush
    functions to sync the page-table changes to the hardware.
    
    Three functions for TLB-Flushes are introduced:
    
            * iommu_flush_tlb_all() - Flushes all TLB entries
                                      associated with that
                                      domain. TLBs entries are
                                      flushed when this function
                                      returns.
    
            * iommu_tlb_range_add() - This will add a given
                                      range to the flush queue
                                      for this domain.
    
            * iommu_tlb_sync() - Flushes all queued ranges from
                                 the hardware TLBs. Returns when
                                 the flush is finished.
    
    The semantic of this interface is intentionally similar to
    the iommu_gather_ops from the io-pgtable code.
    
    Cc: Alex Williamson <alex.williamson@redhat.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index f1ce8e517d8d..50be4fd338e4 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -167,6 +167,10 @@ struct iommu_resv_region {
  * @map: map a physically contiguous memory region to an iommu domain
  * @unmap: unmap a physically contiguous memory region from an iommu domain
  * @map_sg: map a scatter-gather list of physically contiguous memory chunks
+ * @flush_tlb_all: Synchronously flush all hardware TLBs for this domain
+ * @tlb_range_add: Add a given iova range to the flush queue for this domain
+ * @tlb_sync: Flush all queued ranges from the hardware TLBs and empty flush
+ *            queue
  * to an iommu domain
  * @iova_to_phys: translate iova to physical address
  * @add_device: add device to iommu grouping
@@ -199,6 +203,10 @@ struct iommu_ops {
 		     size_t size);
 	size_t (*map_sg)(struct iommu_domain *domain, unsigned long iova,
 			 struct scatterlist *sg, unsigned int nents, int prot);
+	void (*flush_iotlb_all)(struct iommu_domain *domain);
+	void (*iotlb_range_add)(struct iommu_domain *domain,
+				unsigned long iova, size_t size);
+	void (*iotlb_sync)(struct iommu_domain *domain);
 	phys_addr_t (*iova_to_phys)(struct iommu_domain *domain, dma_addr_t iova);
 	int (*add_device)(struct device *dev);
 	void (*remove_device)(struct device *dev);
@@ -286,7 +294,9 @@ extern struct iommu_domain *iommu_get_domain_for_dev(struct device *dev);
 extern int iommu_map(struct iommu_domain *domain, unsigned long iova,
 		     phys_addr_t paddr, size_t size, int prot);
 extern size_t iommu_unmap(struct iommu_domain *domain, unsigned long iova,
-		       size_t size);
+			  size_t size);
+extern size_t iommu_unmap_fast(struct iommu_domain *domain,
+			       unsigned long iova, size_t size);
 extern size_t default_iommu_map_sg(struct iommu_domain *domain, unsigned long iova,
 				struct scatterlist *sg,unsigned int nents,
 				int prot);
@@ -343,6 +353,25 @@ extern void iommu_domain_window_disable(struct iommu_domain *domain, u32 wnd_nr)
 extern int report_iommu_fault(struct iommu_domain *domain, struct device *dev,
 			      unsigned long iova, int flags);
 
+static inline void iommu_flush_tlb_all(struct iommu_domain *domain)
+{
+	if (domain->ops->flush_iotlb_all)
+		domain->ops->flush_iotlb_all(domain);
+}
+
+static inline void iommu_tlb_range_add(struct iommu_domain *domain,
+				       unsigned long iova, size_t size)
+{
+	if (domain->ops->iotlb_range_add)
+		domain->ops->iotlb_range_add(domain, iova, size);
+}
+
+static inline void iommu_tlb_sync(struct iommu_domain *domain)
+{
+	if (domain->ops->iotlb_sync)
+		domain->ops->iotlb_sync(domain);
+}
+
 static inline size_t iommu_map_sg(struct iommu_domain *domain,
 				  unsigned long iova, struct scatterlist *sg,
 				  unsigned int nents, int prot)
@@ -436,6 +465,12 @@ static inline int iommu_unmap(struct iommu_domain *domain, unsigned long iova,
 	return -ENODEV;
 }
 
+static inline int iommu_unmap_fast(struct iommu_domain *domain, unsigned long iova,
+				   int gfp_order)
+{
+	return -ENODEV;
+}
+
 static inline size_t iommu_map_sg(struct iommu_domain *domain,
 				  unsigned long iova, struct scatterlist *sg,
 				  unsigned int nents, int prot)
@@ -443,6 +478,19 @@ static inline size_t iommu_map_sg(struct iommu_domain *domain,
 	return -ENODEV;
 }
 
+static inline void iommu_flush_tlb_all(struct iommu_domain *domain)
+{
+}
+
+static inline void iommu_tlb_range_add(struct iommu_domain *domain,
+				       unsigned long iova, size_t size)
+{
+}
+
+static inline void iommu_tlb_sync(struct iommu_domain *domain)
+{
+}
+
 static inline int iommu_domain_window_enable(struct iommu_domain *domain,
 					     u32 wnd_nr, phys_addr_t paddr,
 					     u64 size, int prot)

commit e01d1913b0d0817191418381a6fcebaa01abde2a
Author: Baoquan He <bhe@redhat.com>
Date:   Wed Aug 9 16:33:40 2017 +0800

    iommu: Add is_attach_deferred call-back to iommu-ops
    
    This new call-back will be used to check if the domain attach need be
    deferred for now. If yes, the domain attach/detach will return directly.
    
    Signed-off-by: Baoquan He <bhe@redhat.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 2cb54adc4a33..63983c9e6c3a 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -225,6 +225,7 @@ struct iommu_ops {
 	u32 (*domain_get_windows)(struct iommu_domain *domain);
 
 	int (*of_xlate)(struct device *dev, struct of_phandle_args *args);
+	bool (*is_attach_deferred)(struct iommu_domain *domain, struct device *dev);
 
 	unsigned long pgsize_bitmap;
 };

commit 2926a2aa5c14fb2add75e6584845b1c03022235f
Author: Joerg Roedel <jroedel@suse.de>
Date:   Mon Aug 14 17:19:26 2017 +0200

    iommu: Fix wrong freeing of iommu_device->dev
    
    The struct iommu_device has a 'struct device' embedded into
    it, not as a pointer, but the whole struct. In the
    conversion of the iommu drivers to use struct iommu_device
    it was forgotten that the relase function for that struct
    device simply calls kfree() on the pointer.
    
    This frees memory that was never allocated and causes memory
    corruption.
    
    To fix this issue, use a pointer to struct device instead of
    embedding the whole struct. This needs some updates in the
    iommu sysfs code as well as the Intel VT-d and AMD IOMMU
    driver.
    
    Reported-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
    Fixes: 39ab9555c241 ('iommu: Add sysfs bindings for struct iommu_device')
    Cc: stable@vger.kernel.org # >= v4.11
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 2cb54adc4a33..176f7569d874 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -240,7 +240,7 @@ struct iommu_device {
 	struct list_head list;
 	const struct iommu_ops *ops;
 	struct fwnode_handle *fwnode;
-	struct device dev;
+	struct device *dev;
 };
 
 int  iommu_device_register(struct iommu_device *iommu);
@@ -265,6 +265,11 @@ static inline void iommu_device_set_fwnode(struct iommu_device *iommu,
 	iommu->fwnode = fwnode;
 }
 
+static inline struct iommu_device *dev_to_iommu_device(struct device *dev)
+{
+	return (struct iommu_device *)dev_get_drvdata(dev);
+}
+
 #define IOMMU_GROUP_NOTIFY_ADD_DEVICE		1 /* Device added */
 #define IOMMU_GROUP_NOTIFY_DEL_DEVICE		2 /* Pre Device removed */
 #define IOMMU_GROUP_NOTIFY_BIND_DRIVER		3 /* Pre Driver bind */
@@ -589,6 +594,11 @@ static inline void iommu_device_set_fwnode(struct iommu_device *iommu,
 {
 }
 
+static inline struct iommu_device *dev_to_iommu_device(struct device *dev)
+{
+	return NULL;
+}
+
 static inline void iommu_device_unregister(struct iommu_device *iommu)
 {
 }

commit ebae3e830a991116526646f09dd67f68f332b330
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Wed Jul 5 20:27:53 2017 +0300

    iommu: Correct iommu_map / iommu_unmap prototypes
    
    Commit 7d3002cc8c16 ("iommu/core: split mapping to page sizes as supported
    by the hardware") replaced 'int gfp_order' with a 'size_t size' of
    iommu_map / iommu_unmap function arguments, but missed the function
    prototypes for the disabled CONFIG_IOMMU_API case, let's correct them
    for consistency.
    
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 2cb54adc4a33..f1ce8e517d8d 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -425,13 +425,13 @@ static inline struct iommu_domain *iommu_get_domain_for_dev(struct device *dev)
 }
 
 static inline int iommu_map(struct iommu_domain *domain, unsigned long iova,
-			    phys_addr_t paddr, int gfp_order, int prot)
+			    phys_addr_t paddr, size_t size, int prot)
 {
 	return -ENODEV;
 }
 
 static inline int iommu_unmap(struct iommu_domain *domain, unsigned long iova,
-			      int gfp_order)
+			      size_t size)
 {
 	return -ENODEV;
 }

commit 2c0248d68880fc0e783af1048b3367ee5d4412f0
Merge: d5bf739dc762 fd8e2d4b3932 c9d9f2394c6a 6f66ea099fc2 bdf95923086f 26b37b946a5c 8e1218840066 73dbd4a42302 290d638e04e7
Author: Joerg Roedel <jroedel@suse.de>
Date:   Thu May 4 18:06:17 2017 +0200

    Merge branches 'arm/exynos', 'arm/omap', 'arm/rockchip', 'arm/mediatek', 'arm/smmu', 'arm/core', 'x86/vt-d', 'x86/amd' and 'core' into next

commit 208480bb273e15f42711bd47f70dc0fbfa2570b8
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Apr 26 15:49:57 2017 +0200

    iommu: Remove trace-events include from iommu.h
    
    It is not needed there anymore. All places needing it are
    fixed.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index abaa0ca848bc..dda8717545e9 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -26,8 +26,6 @@
 #include <linux/err.h>
 #include <linux/of.h>
 
-#include <trace/events/iommu.h>
-
 #define IOMMU_READ	(1 << 0)
 #define IOMMU_WRITE	(1 << 1)
 #define IOMMU_CACHE	(1 << 2) /* DMA cache coherency */

commit 207c6e36f122ebb1164d611c9f34f128313f47d5
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Apr 26 15:39:28 2017 +0200

    iommu: Move report_iommu_fault() to iommu.c
    
    The function is in no fast-path, there is no need for it to
    be static inline in a header file. This also removes the
    need to include iommu trace-points in iommu.h.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 3b4fe4b79d20..abaa0ca848bc 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -330,46 +330,9 @@ extern int iommu_domain_window_enable(struct iommu_domain *domain, u32 wnd_nr,
 				      phys_addr_t offset, u64 size,
 				      int prot);
 extern void iommu_domain_window_disable(struct iommu_domain *domain, u32 wnd_nr);
-/**
- * report_iommu_fault() - report about an IOMMU fault to the IOMMU framework
- * @domain: the iommu domain where the fault has happened
- * @dev: the device where the fault has happened
- * @iova: the faulting address
- * @flags: mmu fault flags (e.g. IOMMU_FAULT_READ/IOMMU_FAULT_WRITE/...)
- *
- * This function should be called by the low-level IOMMU implementations
- * whenever IOMMU faults happen, to allow high-level users, that are
- * interested in such events, to know about them.
- *
- * This event may be useful for several possible use cases:
- * - mere logging of the event
- * - dynamic TLB/PTE loading
- * - if restarting of the faulting device is required
- *
- * Returns 0 on success and an appropriate error code otherwise (if dynamic
- * PTE/TLB loading will one day be supported, implementations will be able
- * to tell whether it succeeded or not according to this return value).
- *
- * Specifically, -ENOSYS is returned if a fault handler isn't installed
- * (though fault handlers can also return -ENOSYS, in case they want to
- * elicit the default behavior of the IOMMU drivers).
- */
-static inline int report_iommu_fault(struct iommu_domain *domain,
-		struct device *dev, unsigned long iova, int flags)
-{
-	int ret = -ENOSYS;
 
-	/*
-	 * if upper layers showed interest and installed a fault handler,
-	 * invoke it.
-	 */
-	if (domain->handler)
-		ret = domain->handler(domain, dev, iova, flags,
-						domain->handler_token);
-
-	trace_io_page_fault(dev, iova, flags);
-	return ret;
-}
+extern int report_iommu_fault(struct iommu_domain *domain, struct device *dev,
+			      unsigned long iova, int flags);
 
 static inline size_t iommu_map_sg(struct iommu_domain *domain,
 				  unsigned long iova, struct scatterlist *sg,

commit e8245c1b1a3bb8474f91c69ccd13637d3589bb2c
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Apr 26 15:34:06 2017 +0200

    iommu: Include device.h in iommu.h
    
    We make use of 'struct device' in iommu.h, so include
    device.h to make it available explicitly.
    
    Re-order the other headers while at it.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 6a6de187ddc0..3b4fe4b79d20 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -19,11 +19,13 @@
 #ifndef __LINUX_IOMMU_H
 #define __LINUX_IOMMU_H
 
+#include <linux/scatterlist.h>
+#include <linux/device.h>
+#include <linux/types.h>
 #include <linux/errno.h>
 #include <linux/err.h>
 #include <linux/of.h>
-#include <linux/types.h>
-#include <linux/scatterlist.h>
+
 #include <trace/events/iommu.h>
 
 #define IOMMU_READ	(1 << 0)

commit adf5e5168bd51c42332ebaa709351fa6ed65ea73
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Fri Jan 27 12:22:54 2017 +0000

    iommu: Better document the IOMMU_PRIV flag
    
    This is a fairly subtle thing - let's make sure it's described as
    clearly as possible to avoid potential misunderstandings.
    
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 2e4de0deee53..88ec8c6580d3 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -32,10 +32,13 @@
 #define IOMMU_NOEXEC	(1 << 3)
 #define IOMMU_MMIO	(1 << 4) /* e.g. things like MSI doorbells */
 /*
- * This is to make the IOMMU API setup privileged
- * mapppings accessible by the master only at higher
- * privileged execution level and inaccessible at
- * less privileged levels.
+ * Where the bus hardware includes a privilege level as part of its access type
+ * markings, and certain devices are capable of issuing transactions marked as
+ * either 'supervisor' or 'user', the IOMMU_PRIV flag requests that the other
+ * given permission flags only apply to accesses at the higher privilege level,
+ * and that unprivileged transactions should have as little access as possible.
+ * This would usually imply the same permissions as kernel mappings on the CPU,
+ * if the IOMMU page table format is equivalent.
  */
 #define IOMMU_PRIV	(1 << 5)
 

commit 9d3a4de4cb8db8e71730e36736272ef041836f68
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Thu Mar 16 17:00:16 2017 +0000

    iommu: Disambiguate MSI region types
    
    The introduction of reserved regions has left a couple of rough edges
    which we could do with sorting out sooner rather than later. Since we
    are not yet addressing the potential dynamic aspect of software-managed
    reservations and presenting them at arbitrary fixed addresses, it is
    incongruous that we end up displaying hardware vs. software-managed MSI
    regions to userspace differently, especially since ARM-based systems may
    actually require one or the other, or even potentially both at once,
    (which iommu-dma currently has no hope of dealing with at all). Let's
    resolve the former user-visible inconsistency ASAP before the ABI has
    been baked into a kernel release, in a way that also lays the groundwork
    for the latter shortcoming to be addressed by follow-up patches.
    
    For clarity, rename the software-managed type to IOMMU_RESV_SW_MSI, use
    IOMMU_RESV_MSI to describe the hardware type, and document everything a
    little bit. Since the x86 MSI remapping hardware falls squarely under
    this meaning of IOMMU_RESV_MSI, apply that type to their regions as well,
    so that we tell the same story to userspace across all platforms.
    
    Secondly, as the various region types require quite different handling,
    and it really makes little sense to ever try combining them, convert the
    bitfield-esque #defines to a plain enum in the process before anyone
    gets the wrong impression.
    
    Fixes: d30ddcaa7b02 ("iommu: Add a new type field in iommu_resv_region")
    Reviewed-by: Eric Auger <eric.auger@redhat.com>
    CC: Alex Williamson <alex.williamson@redhat.com>
    CC: David Woodhouse <dwmw2@infradead.org>
    CC: kvm@vger.kernel.org
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 6a6de187ddc0..2e4de0deee53 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -125,9 +125,16 @@ enum iommu_attr {
 };
 
 /* These are the possible reserved region types */
-#define IOMMU_RESV_DIRECT	(1 << 0)
-#define IOMMU_RESV_RESERVED	(1 << 1)
-#define IOMMU_RESV_MSI		(1 << 2)
+enum iommu_resv_type {
+	/* Memory regions which must be mapped 1:1 at all times */
+	IOMMU_RESV_DIRECT,
+	/* Arbitrary "never map this or give it to a device" address ranges */
+	IOMMU_RESV_RESERVED,
+	/* Hardware MSI region (untranslated) */
+	IOMMU_RESV_MSI,
+	/* Software-managed MSI translation window */
+	IOMMU_RESV_SW_MSI,
+};
 
 /**
  * struct iommu_resv_region - descriptor for a reserved memory region
@@ -142,7 +149,7 @@ struct iommu_resv_region {
 	phys_addr_t		start;
 	size_t			length;
 	int			prot;
-	int			type;
+	enum iommu_resv_type	type;
 };
 
 #ifdef CONFIG_IOMMU_API
@@ -288,7 +295,8 @@ extern void iommu_get_resv_regions(struct device *dev, struct list_head *list);
 extern void iommu_put_resv_regions(struct device *dev, struct list_head *list);
 extern int iommu_request_dm_for_dev(struct device *dev);
 extern struct iommu_resv_region *
-iommu_alloc_resv_region(phys_addr_t start, size_t length, int prot, int type);
+iommu_alloc_resv_region(phys_addr_t start, size_t length, int prot,
+			enum iommu_resv_type type);
 extern int iommu_get_group_resv_regions(struct iommu_group *group,
 					struct list_head *head);
 

commit 8d2932dd0634ebeb0a42df896976772bdb569bfe
Merge: 99e8ccd3837a fff2fd1a9e4b 3b6bb5b705a4 aac7d39f200d 087a908f533f 2c9f1af528a4 f7116e115acd d0f6f5832603
Author: Joerg Roedel <jroedel@suse.de>
Date:   Fri Feb 10 15:13:10 2017 +0100

    Merge branches 'iommu/fixes', 'arm/exynos', 'arm/renesas', 'arm/smmu', 'arm/mediatek', 'arm/core', 'x86/vt-d' and 'core' into next

commit d0f6f5832603931b0a8da044fb9abe8289e201ee
Author: Joerg Roedel <jroedel@suse.de>
Date:   Thu Feb 2 12:19:12 2017 +0100

    iommu: Remove iommu_register_instance interface
    
    And also move its remaining functionality to
    iommu_device_register() and 'struct iommu_device'.
    
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Cc: devicetree@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 626c935edee1..9e82fc83765e 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -382,8 +382,6 @@ int iommu_fwspec_init(struct device *dev, struct fwnode_handle *iommu_fwnode,
 		      const struct iommu_ops *ops);
 void iommu_fwspec_free(struct device *dev);
 int iommu_fwspec_add_ids(struct device *dev, u32 *ids, int num_ids);
-void iommu_register_instance(struct fwnode_handle *fwnode,
-			     const struct iommu_ops *ops);
 const struct iommu_ops *iommu_ops_from_fwnode(struct fwnode_handle *fwnode);
 
 #else /* CONFIG_IOMMU_API */
@@ -634,11 +632,6 @@ static inline int iommu_fwspec_add_ids(struct device *dev, u32 *ids,
 	return -ENODEV;
 }
 
-static inline void iommu_register_instance(struct fwnode_handle *fwnode,
-					   const struct iommu_ops *ops)
-{
-}
-
 static inline
 const struct iommu_ops *iommu_ops_from_fwnode(struct fwnode_handle *fwnode)
 {

commit c73e1ac8b2bc6ab18d9f9a96b17ee7388b49a0c0
Author: Joerg Roedel <jroedel@suse.de>
Date:   Tue Feb 7 18:18:46 2017 +0100

    iommu: Add iommu_device_set_fwnode() interface
    
    Allow to store a fwnode in 'struct iommu_device';
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index bae3cfc8b4a3..626c935edee1 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -214,6 +214,7 @@ struct iommu_ops {
 struct iommu_device {
 	struct list_head list;
 	const struct iommu_ops *ops;
+	struct fwnode_handle *fwnode;
 	struct device dev;
 };
 
@@ -233,6 +234,12 @@ static inline void iommu_device_set_ops(struct iommu_device *iommu,
 	iommu->ops = ops;
 }
 
+static inline void iommu_device_set_fwnode(struct iommu_device *iommu,
+					   struct fwnode_handle *fwnode)
+{
+	iommu->fwnode = fwnode;
+}
+
 #define IOMMU_GROUP_NOTIFY_ADD_DEVICE		1 /* Device added */
 #define IOMMU_GROUP_NOTIFY_DEL_DEVICE		2 /* Pre Device removed */
 #define IOMMU_GROUP_NOTIFY_BIND_DRIVER		3 /* Pre Driver bind */
@@ -580,6 +587,11 @@ static inline void iommu_device_set_ops(struct iommu_device *iommu,
 {
 }
 
+static inline void iommu_device_set_fwnode(struct iommu_device *iommu,
+					   struct fwnode_handle *fwnode)
+{
+}
+
 static inline void iommu_device_unregister(struct iommu_device *iommu)
 {
 }

commit e3d10af1128b6bc394f21656ff13753130f3c107
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Feb 1 17:23:22 2017 +0100

    iommu: Make iommu_device_link/unlink take a struct iommu_device
    
    This makes the interface more consistent with
    iommu_device_sysfs_add/remove.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index c578ca135bed..bae3cfc8b4a3 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -224,6 +224,8 @@ int  iommu_device_sysfs_add(struct iommu_device *iommu,
 			    const struct attribute_group **groups,
 			    const char *fmt, ...) __printf(4, 5);
 void iommu_device_sysfs_remove(struct iommu_device *iommu);
+int  iommu_device_link(struct iommu_device   *iommu, struct device *link);
+void iommu_device_unlink(struct iommu_device *iommu, struct device *link);
 
 static inline void iommu_device_set_ops(struct iommu_device *iommu,
 					const struct iommu_ops *ops)
@@ -294,8 +296,6 @@ extern int iommu_domain_get_attr(struct iommu_domain *domain, enum iommu_attr,
 				 void *data);
 extern int iommu_domain_set_attr(struct iommu_domain *domain, enum iommu_attr,
 				 void *data);
-int iommu_device_link(struct device *dev, struct device *link);
-void iommu_device_unlink(struct device *dev, struct device *link);
 
 /* Window handling function prototypes */
 extern int iommu_domain_window_enable(struct iommu_domain *domain, u32 wnd_nr,

commit 39ab9555c24110671f8dc671311a26e5c985b592
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Feb 1 16:56:46 2017 +0100

    iommu: Add sysfs bindings for struct iommu_device
    
    There is currently support for iommu sysfs bindings, but
    those need to be implemented in the IOMMU drivers. Add a
    more generic version of this by adding a struct device to
    struct iommu_device and use that for the sysfs bindings.
    
    Also convert the AMD and Intel IOMMU driver to make use of
    it.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 900ddd212364..c578ca135bed 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -209,14 +209,21 @@ struct iommu_ops {
  *			 instance
  * @list: Used by the iommu-core to keep a list of registered iommus
  * @ops: iommu-ops for talking to this iommu
+ * @dev: struct device for sysfs handling
  */
 struct iommu_device {
 	struct list_head list;
 	const struct iommu_ops *ops;
+	struct device dev;
 };
 
 int  iommu_device_register(struct iommu_device *iommu);
 void iommu_device_unregister(struct iommu_device *iommu);
+int  iommu_device_sysfs_add(struct iommu_device *iommu,
+			    struct device *parent,
+			    const struct attribute_group **groups,
+			    const char *fmt, ...) __printf(4, 5);
+void iommu_device_sysfs_remove(struct iommu_device *iommu);
 
 static inline void iommu_device_set_ops(struct iommu_device *iommu,
 					const struct iommu_ops *ops)
@@ -287,10 +294,6 @@ extern int iommu_domain_get_attr(struct iommu_domain *domain, enum iommu_attr,
 				 void *data);
 extern int iommu_domain_set_attr(struct iommu_domain *domain, enum iommu_attr,
 				 void *data);
-struct device *iommu_device_create(struct device *parent, void *drvdata,
-				   const struct attribute_group **groups,
-				   const char *fmt, ...) __printf(4, 5);
-void iommu_device_destroy(struct device *dev);
 int iommu_device_link(struct device *dev, struct device *link);
 void iommu_device_unlink(struct device *dev, struct device *link);
 
@@ -567,29 +570,29 @@ static inline int iommu_domain_set_attr(struct iommu_domain *domain,
 	return -EINVAL;
 }
 
-static inline struct device *iommu_device_create(struct device *parent,
-					void *drvdata,
-					const struct attribute_group **groups,
-					const char *fmt, ...)
+static inline int  iommu_device_register(struct iommu_device *iommu)
 {
-	return ERR_PTR(-ENODEV);
+	return -ENODEV;
 }
 
-static inline void iommu_device_destroy(struct device *dev)
+static inline void iommu_device_set_ops(struct iommu_device *iommu,
+					const struct iommu_ops *ops)
 {
 }
 
-static inline int  iommu_device_register(struct iommu_device *iommu)
+static inline void iommu_device_unregister(struct iommu_device *iommu)
 {
-	return -ENODEV;
 }
 
-static inline void iommu_device_set_ops(struct iommu_device *iommu,
-					const struct iommu_ops *ops)
+static inline int  iommu_device_sysfs_add(struct iommu_device *iommu,
+					  struct device *parent,
+					  const struct attribute_group **groups,
+					  const char *fmt, ...)
 {
+	return -ENODEV;
 }
 
-static inline void iommu_device_unregister(struct iommu_device *iommu)
+static inline void iommu_device_sysfs_remove(struct iommu_device *iommu)
 {
 }
 

commit b0119e870837dcd15a207b4701542ebac5d19b45
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Feb 1 13:23:08 2017 +0100

    iommu: Introduce new 'struct iommu_device'
    
    This struct represents one hardware iommu in the iommu core
    code. For now it only has the iommu-ops associated with it,
    but that will be extended soon.
    
    The register/unregister interface is also added, as well as
    making use of it in the Intel and AMD IOMMU drivers.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 085e1f0e6c07..900ddd212364 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -204,6 +204,26 @@ struct iommu_ops {
 	unsigned long pgsize_bitmap;
 };
 
+/**
+ * struct iommu_device - IOMMU core representation of one IOMMU hardware
+ *			 instance
+ * @list: Used by the iommu-core to keep a list of registered iommus
+ * @ops: iommu-ops for talking to this iommu
+ */
+struct iommu_device {
+	struct list_head list;
+	const struct iommu_ops *ops;
+};
+
+int  iommu_device_register(struct iommu_device *iommu);
+void iommu_device_unregister(struct iommu_device *iommu);
+
+static inline void iommu_device_set_ops(struct iommu_device *iommu,
+					const struct iommu_ops *ops)
+{
+	iommu->ops = ops;
+}
+
 #define IOMMU_GROUP_NOTIFY_ADD_DEVICE		1 /* Device added */
 #define IOMMU_GROUP_NOTIFY_DEL_DEVICE		2 /* Pre Device removed */
 #define IOMMU_GROUP_NOTIFY_BIND_DRIVER		3 /* Pre Driver bind */
@@ -361,6 +381,7 @@ const struct iommu_ops *iommu_ops_from_fwnode(struct fwnode_handle *fwnode);
 struct iommu_ops {};
 struct iommu_group {};
 struct iommu_fwspec {};
+struct iommu_device {};
 
 static inline bool iommu_present(struct bus_type *bus)
 {
@@ -558,6 +579,20 @@ static inline void iommu_device_destroy(struct device *dev)
 {
 }
 
+static inline int  iommu_device_register(struct iommu_device *iommu)
+{
+	return -ENODEV;
+}
+
+static inline void iommu_device_set_ops(struct iommu_device *iommu,
+					const struct iommu_ops *ops)
+{
+}
+
+static inline void iommu_device_unregister(struct iommu_device *iommu)
+{
+}
+
 static inline int iommu_device_link(struct device *dev, struct device *link)
 {
 	return -EINVAL;

commit 534766dfef999f7e7349bbd91cd19c1673792af3
Author: Joerg Roedel <jroedel@suse.de>
Date:   Tue Jan 31 16:58:42 2017 +0100

    iommu: Rename iommu_get_instance()
    
    Rename the function to iommu_ops_from_fwnode(), because that
    is what the function actually does. The new name is much
    more descriptive about what the function does.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 0ff5111f6959..085e1f0e6c07 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -354,7 +354,7 @@ void iommu_fwspec_free(struct device *dev);
 int iommu_fwspec_add_ids(struct device *dev, u32 *ids, int num_ids);
 void iommu_register_instance(struct fwnode_handle *fwnode,
 			     const struct iommu_ops *ops);
-const struct iommu_ops *iommu_get_instance(struct fwnode_handle *fwnode);
+const struct iommu_ops *iommu_ops_from_fwnode(struct fwnode_handle *fwnode);
 
 #else /* CONFIG_IOMMU_API */
 
@@ -590,7 +590,7 @@ static inline void iommu_register_instance(struct fwnode_handle *fwnode,
 }
 
 static inline
-const struct iommu_ops *iommu_get_instance(struct fwnode_handle *fwnode)
+const struct iommu_ops *iommu_ops_from_fwnode(struct fwnode_handle *fwnode)
 {
 	return NULL;
 }

commit ce273db0ff1ae64fea785af25a43977b0b6a4555
Merge: 93fa6cf60aad 14b4dbafa7e7
Author: Joerg Roedel <jroedel@suse.de>
Date:   Mon Jan 30 16:05:18 2017 +0100

    Merge branch 'iommu/iommu-priv' of git://git.kernel.org/pub/scm/linux/kernel/git/will/linux into arm/core

commit 6c65fb318e8bbf21e939e651028b955324f1d873
Author: Eric Auger <eric.auger@redhat.com>
Date:   Thu Jan 19 20:57:51 2017 +0000

    iommu: iommu_get_group_resv_regions
    
    Introduce iommu_get_group_resv_regions whose role consists in
    enumerating all devices from the group and collecting their
    reserved regions. The list is sorted and overlaps between
    regions of the same type are handled by merging the regions.
    
    Signed-off-by: Eric Auger <eric.auger@redhat.com>
    Reviewed-by: Tomasz Nowicki <tomasz.nowicki@caviumnetworks.com>
    Tested-by: Tomasz Nowicki <tomasz.nowicki@caviumnetworks.com>
    Tested-by: Bharat Bhushan <bharat.bhushan@nxp.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index f6bb55d3e606..bec3730dc009 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -246,6 +246,8 @@ extern void iommu_put_resv_regions(struct device *dev, struct list_head *list);
 extern int iommu_request_dm_for_dev(struct device *dev);
 extern struct iommu_resv_region *
 iommu_alloc_resv_region(phys_addr_t start, size_t length, int prot, int type);
+extern int iommu_get_group_resv_regions(struct iommu_group *group,
+					struct list_head *head);
 
 extern int iommu_attach_group(struct iommu_domain *domain,
 			      struct iommu_group *group);
@@ -463,6 +465,12 @@ static inline void iommu_put_resv_regions(struct device *dev,
 {
 }
 
+static inline int iommu_get_group_resv_regions(struct iommu_group *group,
+					       struct list_head *head)
+{
+	return -ENODEV;
+}
+
 static inline int iommu_request_dm_for_dev(struct device *dev)
 {
 	return -ENODEV;

commit 2b20cbba3390a55c511acba2f0f517dd27a528b2
Author: Eric Auger <eric.auger@redhat.com>
Date:   Thu Jan 19 20:57:49 2017 +0000

    iommu: iommu_alloc_resv_region
    
    Introduce a new helper serving the purpose to allocate a reserved
    region. This will be used in iommu driver implementing reserved
    region callbacks.
    
    Signed-off-by: Eric Auger <eric.auger@redhat.com>
    Reviewed-by: Tomasz Nowicki <tomasz.nowicki@caviumnetworks.com>
    Tested-by: Tomasz Nowicki <tomasz.nowicki@caviumnetworks.com>
    Tested-by: Bharat Bhushan <bharat.bhushan@nxp.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 233a6bf093bf..f6bb55d3e606 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -244,6 +244,8 @@ extern void iommu_set_fault_handler(struct iommu_domain *domain,
 extern void iommu_get_resv_regions(struct device *dev, struct list_head *list);
 extern void iommu_put_resv_regions(struct device *dev, struct list_head *list);
 extern int iommu_request_dm_for_dev(struct device *dev);
+extern struct iommu_resv_region *
+iommu_alloc_resv_region(phys_addr_t start, size_t length, int prot, int type);
 
 extern int iommu_attach_group(struct iommu_domain *domain,
 			      struct iommu_group *group);

commit d30ddcaa7b028049cdfee3a40248002d07b2bbf3
Author: Eric Auger <eric.auger@redhat.com>
Date:   Thu Jan 19 20:57:48 2017 +0000

    iommu: Add a new type field in iommu_resv_region
    
    We introduce a new field to differentiate the reserved region
    types and specialize the apply_resv_region implementation.
    
    Legacy direct mapped regions have IOMMU_RESV_DIRECT type.
    We introduce 2 new reserved memory types:
    - IOMMU_RESV_MSI will characterize MSI regions that are mapped
    - IOMMU_RESV_RESERVED characterize regions that cannot by mapped.
    
    Signed-off-by: Eric Auger <eric.auger@redhat.com>
    Tested-by: Tomasz Nowicki <tomasz.nowicki@caviumnetworks.com>
    Tested-by: Bharat Bhushan <bharat.bhushan@nxp.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index bfecb8b74078..233a6bf093bf 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -117,18 +117,25 @@ enum iommu_attr {
 	DOMAIN_ATTR_MAX,
 };
 
+/* These are the possible reserved region types */
+#define IOMMU_RESV_DIRECT	(1 << 0)
+#define IOMMU_RESV_RESERVED	(1 << 1)
+#define IOMMU_RESV_MSI		(1 << 2)
+
 /**
  * struct iommu_resv_region - descriptor for a reserved memory region
  * @list: Linked list pointers
  * @start: System physical start address of the region
  * @length: Length of the region in bytes
  * @prot: IOMMU Protection flags (READ/WRITE/...)
+ * @type: Type of the reserved region
  */
 struct iommu_resv_region {
 	struct list_head	list;
 	phys_addr_t		start;
 	size_t			length;
 	int			prot;
+	int			type;
 };
 
 #ifdef CONFIG_IOMMU_API

commit e5b5234a36ca283158721d3d2e0cddfa324abdf9
Author: Eric Auger <eric.auger@redhat.com>
Date:   Thu Jan 19 20:57:47 2017 +0000

    iommu: Rename iommu_dm_regions into iommu_resv_regions
    
    We want to extend the callbacks used for dm regions and
    use them for reserved regions. Reserved regions can be
    - directly mapped regions
    - regions that cannot be iommu mapped (PCI host bridge windows, ...)
    - MSI regions (because they belong to another address space or because
      they are not translated by the IOMMU and need special handling)
    
    So let's rename the struct and also the callbacks.
    
    Signed-off-by: Eric Auger <eric.auger@redhat.com>
    Acked-by: Robin Murphy <robin.murphy@arm.com>
    Reviewed-by: Tomasz Nowicki <tomasz.nowicki@caviumnetworks.com>
    Tested-by: Tomasz Nowicki <tomasz.nowicki@caviumnetworks.com>
    Tested-by: Bharat Bhushan <bharat.bhushan@nxp.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 0ff5111f6959..bfecb8b74078 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -118,13 +118,13 @@ enum iommu_attr {
 };
 
 /**
- * struct iommu_dm_region - descriptor for a direct mapped memory region
+ * struct iommu_resv_region - descriptor for a reserved memory region
  * @list: Linked list pointers
  * @start: System physical start address of the region
  * @length: Length of the region in bytes
  * @prot: IOMMU Protection flags (READ/WRITE/...)
  */
-struct iommu_dm_region {
+struct iommu_resv_region {
 	struct list_head	list;
 	phys_addr_t		start;
 	size_t			length;
@@ -150,9 +150,9 @@ struct iommu_dm_region {
  * @device_group: find iommu group for a particular device
  * @domain_get_attr: Query domain attributes
  * @domain_set_attr: Change domain attributes
- * @get_dm_regions: Request list of direct mapping requirements for a device
- * @put_dm_regions: Free list of direct mapping requirements for a device
- * @apply_dm_region: Temporary helper call-back for iova reserved ranges
+ * @get_resv_regions: Request list of reserved regions for a device
+ * @put_resv_regions: Free list of reserved regions for a device
+ * @apply_resv_region: Temporary helper call-back for iova reserved ranges
  * @domain_window_enable: Configure and enable a particular window for a domain
  * @domain_window_disable: Disable a particular window for a domain
  * @domain_set_windows: Set the number of windows for a domain
@@ -184,11 +184,12 @@ struct iommu_ops {
 	int (*domain_set_attr)(struct iommu_domain *domain,
 			       enum iommu_attr attr, void *data);
 
-	/* Request/Free a list of direct mapping requirements for a device */
-	void (*get_dm_regions)(struct device *dev, struct list_head *list);
-	void (*put_dm_regions)(struct device *dev, struct list_head *list);
-	void (*apply_dm_region)(struct device *dev, struct iommu_domain *domain,
-				struct iommu_dm_region *region);
+	/* Request/Free a list of reserved regions for a device */
+	void (*get_resv_regions)(struct device *dev, struct list_head *list);
+	void (*put_resv_regions)(struct device *dev, struct list_head *list);
+	void (*apply_resv_region)(struct device *dev,
+				  struct iommu_domain *domain,
+				  struct iommu_resv_region *region);
 
 	/* Window handling functions */
 	int (*domain_window_enable)(struct iommu_domain *domain, u32 wnd_nr,
@@ -233,8 +234,8 @@ extern phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain, dma_addr_t io
 extern void iommu_set_fault_handler(struct iommu_domain *domain,
 			iommu_fault_handler_t handler, void *token);
 
-extern void iommu_get_dm_regions(struct device *dev, struct list_head *list);
-extern void iommu_put_dm_regions(struct device *dev, struct list_head *list);
+extern void iommu_get_resv_regions(struct device *dev, struct list_head *list);
+extern void iommu_put_resv_regions(struct device *dev, struct list_head *list);
 extern int iommu_request_dm_for_dev(struct device *dev);
 
 extern int iommu_attach_group(struct iommu_domain *domain,
@@ -443,12 +444,12 @@ static inline void iommu_set_fault_handler(struct iommu_domain *domain,
 {
 }
 
-static inline void iommu_get_dm_regions(struct device *dev,
+static inline void iommu_get_resv_regions(struct device *dev,
 					struct list_head *list)
 {
 }
 
-static inline void iommu_put_dm_regions(struct device *dev,
+static inline void iommu_put_resv_regions(struct device *dev,
 					struct list_head *list)
 {
 }

commit 579b2a65d245c093d3e63845c320b9321f112b75
Author: Mitchel Humpherys <mitchelh@codeaurora.org>
Date:   Fri Jan 6 18:58:08 2017 +0530

    iommu: add IOMMU_PRIV attribute
    
    Add the IOMMU_PRIV attribute, which is used to indicate privileged
    mappings.
    
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Tested-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Mitchel Humpherys <mitchelh@codeaurora.org>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 0ff5111f6959..69e2417a2965 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -31,6 +31,13 @@
 #define IOMMU_CACHE	(1 << 2) /* DMA cache coherency */
 #define IOMMU_NOEXEC	(1 << 3)
 #define IOMMU_MMIO	(1 << 4) /* e.g. things like MSI doorbells */
+/*
+ * This is to make the IOMMU API setup privileged
+ * mapppings accessible by the master only at higher
+ * privileged execution level and inaccessible at
+ * less privileged levels.
+ */
+#define IOMMU_PRIV	(1 << 5)
 
 struct iommu_ops;
 struct iommu_group;

commit 1465f481460cbfc60dc119873099d89a58f9be4f
Merge: 3e5de27e940d 00c7c81f7b49 18b709beb503 ebcfa2843954 37bad55b784c 24c790fbf5d8 2f5f44f205cc
Author: Joerg Roedel <jroedel@suse.de>
Date:   Tue Dec 6 17:32:16 2016 +0100

    Merge branches 'arm/mediatek', 'arm/smmu', 'x86/amd', 's390', 'core' and 'arm/exynos' into next

commit e4f10ffe4c9b500e545b874b816ffea5e8659b05
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Nov 21 10:01:36 2016 +0000

    iommu: Make of_iommu_set/get_ops() DT agnostic
    
    The of_iommu_{set/get}_ops() API is used to associate a device
    tree node with a specific set of IOMMU operations. The same
    kernel interface is required on systems booting with ACPI, where
    devices are not associated with a device tree node, therefore
    the interface requires generalization.
    
    The struct device fwnode member represents the fwnode token associated
    with the device and the struct it points at is firmware specific;
    regardless, it is initialized on both ACPI and DT systems and makes an
    ideal candidate to use it to associate a set of IOMMU operations to a
    given device, through its struct device.fwnode member pointer, paving
    the way for representing per-device iommu_ops (ie an iommu instance
    associated with a device).
    
    Convert the DT specific of_iommu_{set/get}_ops() interface to
    use struct device.fwnode as a look-up token, making the interface
    usable on ACPI systems and rename the data structures and the
    registration API so that they are made to represent their usage
    more clearly.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Reviewed-by: Tomasz Nowicki <tn@semihalf.com>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Tomasz Nowicki <tn@semihalf.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 436dc21318af..f2960e4de344 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -351,6 +351,9 @@ int iommu_fwspec_init(struct device *dev, struct fwnode_handle *iommu_fwnode,
 		      const struct iommu_ops *ops);
 void iommu_fwspec_free(struct device *dev);
 int iommu_fwspec_add_ids(struct device *dev, u32 *ids, int num_ids);
+void iommu_register_instance(struct fwnode_handle *fwnode,
+			     const struct iommu_ops *ops);
+const struct iommu_ops *iommu_get_instance(struct fwnode_handle *fwnode);
 
 #else /* CONFIG_IOMMU_API */
 
@@ -580,6 +583,17 @@ static inline int iommu_fwspec_add_ids(struct device *dev, u32 *ids,
 	return -ENODEV;
 }
 
+static inline void iommu_register_instance(struct fwnode_handle *fwnode,
+					   const struct iommu_ops *ops)
+{
+}
+
+static inline
+const struct iommu_ops *iommu_get_instance(struct fwnode_handle *fwnode)
+{
+	return NULL;
+}
+
 #endif /* CONFIG_IOMMU_API */
 
 #endif /* __LINUX_IOMMU_H */

commit 13f59a78c6d69a9bf4c8989dd5f3396f54a2fe41
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Fri Nov 11 17:59:21 2016 +0000

    iommu: Allow taking a reference on a group directly
    
    iommu_group_get_for_dev() expects that the IOMMU driver's device_group
    callback return a group with a reference held for the given device.
    Whilst allocating a new group is fine, and pci_device_group() correctly
    handles reusing an existing group, there is no general means for IOMMU
    drivers doing their own group lookup to take additional references on an
    existing group pointer without having to also store device pointers or
    resort to elaborate trickery.
    
    Add an IOMMU-driver-specific function to fill the hole.
    
    Acked-by: Sricharan R <sricharan@codeaurora.org>
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 436dc21318af..431638110c6a 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -253,6 +253,7 @@ extern void iommu_group_remove_device(struct device *dev);
 extern int iommu_group_for_each_dev(struct iommu_group *group, void *data,
 				    int (*fn)(struct device *, void *));
 extern struct iommu_group *iommu_group_get(struct device *dev);
+extern struct iommu_group *iommu_group_ref_get(struct iommu_group *group);
 extern void iommu_group_put(struct iommu_group *group);
 extern int iommu_group_register_notifier(struct iommu_group *group,
 					 struct notifier_block *nb);

commit 57f98d2f61e191ef9d06863c9ce3f8621f3671ef
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Tue Sep 13 10:54:14 2016 +0100

    iommu: Introduce iommu_fwspec
    
    Introduce a common structure to hold the per-device firmware data that
    most IOMMU drivers need to keep track of. This enables us to configure
    much of that data from common firmware code, and consolidate a lot of
    the equivalent implementations, device look-up tables, etc. which are
    currently strewn across IOMMU drivers.
    
    This will also be enable us to address the outstanding "multiple IOMMUs
    on the platform bus" problem by tweaking IOMMU API calls to prefer
    dev->fwspec->ops before falling back to dev->bus->iommu_ops, and thus
    gracefully handle those troublesome systems which we currently cannot.
    
    As the first user, hook up the OF IOMMU configuration mechanism. The
    driver-defined nature of DT cells means that we still need the drivers
    to translate and add the IDs themselves, but future users such as the
    much less free-form ACPI IORT will be much simpler and self-contained.
    
    CC: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Suggested-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index a35fb8b42e1a..436dc21318af 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -331,10 +331,32 @@ extern struct iommu_group *pci_device_group(struct device *dev);
 /* Generic device grouping function */
 extern struct iommu_group *generic_device_group(struct device *dev);
 
+/**
+ * struct iommu_fwspec - per-device IOMMU instance data
+ * @ops: ops for this device's IOMMU
+ * @iommu_fwnode: firmware handle for this device's IOMMU
+ * @iommu_priv: IOMMU driver private data for this device
+ * @num_ids: number of associated device IDs
+ * @ids: IDs which this device may present to the IOMMU
+ */
+struct iommu_fwspec {
+	const struct iommu_ops	*ops;
+	struct fwnode_handle	*iommu_fwnode;
+	void			*iommu_priv;
+	unsigned int		num_ids;
+	u32			ids[1];
+};
+
+int iommu_fwspec_init(struct device *dev, struct fwnode_handle *iommu_fwnode,
+		      const struct iommu_ops *ops);
+void iommu_fwspec_free(struct device *dev);
+int iommu_fwspec_add_ids(struct device *dev, u32 *ids, int num_ids);
+
 #else /* CONFIG_IOMMU_API */
 
 struct iommu_ops {};
 struct iommu_group {};
+struct iommu_fwspec {};
 
 static inline bool iommu_present(struct bus_type *bus)
 {
@@ -541,6 +563,23 @@ static inline void iommu_device_unlink(struct device *dev, struct device *link)
 {
 }
 
+static inline int iommu_fwspec_init(struct device *dev,
+				    struct fwnode_handle *iommu_fwnode,
+				    const struct iommu_ops *ops)
+{
+	return -ENODEV;
+}
+
+static inline void iommu_fwspec_free(struct device *dev)
+{
+}
+
+static inline int iommu_fwspec_add_ids(struct device *dev, u32 *ids,
+				       int num_ids)
+{
+	return -ENODEV;
+}
+
 #endif /* CONFIG_IOMMU_API */
 
 #endif /* __LINUX_IOMMU_H */

commit 33b21a6b203f70e2012b02753134e59c3ab38779
Author: Joerg Roedel <jroedel@suse.de>
Date:   Tue Jul 5 13:07:53 2016 +0200

    iommu: Add apply_dm_region call-back to iommu-ops
    
    This new call-back will be used by the iommu driver to do
    reserve the given dm_region in its iova space before the
    mapping is created.
    
    The call-back is temporary until the dma-ops implementation
    is part of the common iommu code.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 664683aedcce..a35fb8b42e1a 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -152,6 +152,7 @@ struct iommu_dm_region {
  * @domain_set_attr: Change domain attributes
  * @get_dm_regions: Request list of direct mapping requirements for a device
  * @put_dm_regions: Free list of direct mapping requirements for a device
+ * @apply_dm_region: Temporary helper call-back for iova reserved ranges
  * @domain_window_enable: Configure and enable a particular window for a domain
  * @domain_window_disable: Disable a particular window for a domain
  * @domain_set_windows: Set the number of windows for a domain
@@ -186,6 +187,8 @@ struct iommu_ops {
 	/* Request/Free a list of direct mapping requirements for a device */
 	void (*get_dm_regions)(struct device *dev, struct list_head *list);
 	void (*put_dm_regions)(struct device *dev, struct list_head *list);
+	void (*apply_dm_region)(struct device *dev, struct iommu_domain *domain,
+				struct iommu_dm_region *region);
 
 	/* Window handling functions */
 	int (*domain_window_enable)(struct iommu_domain *domain, u32 wnd_nr,

commit 6c0b43df74f900e7f31a49d1844f166df0f8afc6
Merge: e88ccab12a9e 8d7f2d84ed2d a5c0e0b4ac07 3d1a2442d2c0 a0d284d2b1d9 d54663573131 e85e8f69cedb
Author: Joerg Roedel <jroedel@suse.de>
Date:   Mon May 9 19:39:17 2016 +0200

    Merge branches 'arm/io-pgtable', 'arm/rockchip', 'arm/omap', 'x86/vt-d', 'ppc/pamu', 'core' and 'x86/amd' into next

commit d16e0faab911cc0e100a1e8e93635b432566608e
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Thu Apr 7 18:42:06 2016 +0100

    iommu: Allow selecting page sizes per domain
    
    Many IOMMUs support multiple page table formats, meaning that any given
    domain may only support a subset of the hardware page sizes presented in
    iommu_ops->pgsize_bitmap. There are also certain use-cases where the
    creator of a domain may want to control which page sizes are used, for
    example to force the use of hugepage mappings to reduce pagetable walk
    depth.
    
    To this end, add a per-domain pgsize_bitmap to represent the subset of
    page sizes actually in use, to make it possible for domains with
    different requirements to coexist.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    [rm: hijacked and rebased original patch with new commit message]
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 8a2570443b80..7811294bc0f7 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -78,6 +78,7 @@ struct iommu_domain_geometry {
 struct iommu_domain {
 	unsigned type;
 	const struct iommu_ops *ops;
+	unsigned long pgsize_bitmap;	/* Bitmap of page sizes in use */
 	iommu_fault_handler_t handler;
 	void *handler_token;
 	struct iommu_domain_geometry geometry;
@@ -155,7 +156,7 @@ struct iommu_dm_region {
  * @domain_set_windows: Set the number of windows for a domain
  * @domain_get_windows: Return the number of windows for a domain
  * @of_xlate: add OF master IDs to iommu grouping
- * @pgsize_bitmap: bitmap of supported page sizes
+ * @pgsize_bitmap: bitmap of all possible supported page sizes
  */
 struct iommu_ops {
 	bool (*capable)(enum iommu_cap);

commit 3c3e8943ac6f36ca5d18ca61b30634fb560b4ebb
Author: Will Deacon <will.deacon@arm.com>
Date:   Thu Apr 7 18:42:04 2016 +0100

    iommu: remove unused priv field from struct iommu_ops
    
    The priv field from iommu_ops is a hangover from the of_dma_configure
    series and isn't actually used. Remove it before it has chance to
    spread.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index ef7a6ecd8584..8a2570443b80 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -156,7 +156,6 @@ struct iommu_dm_region {
  * @domain_get_windows: Return the number of windows for a domain
  * @of_xlate: add OF master IDs to iommu grouping
  * @pgsize_bitmap: bitmap of supported page sizes
- * @priv: per-instance data private to the iommu driver
  */
 struct iommu_ops {
 	bool (*capable)(enum iommu_cap);
@@ -198,7 +197,6 @@ struct iommu_ops {
 	int (*of_xlate)(struct device *dev, struct of_phandle_args *args);
 
 	unsigned long pgsize_bitmap;
-	void *priv;
 };
 
 #define IOMMU_GROUP_NOTIFY_ADD_DEVICE		1 /* Device added */

commit 31e6850e0fdb3a586363cc4d2f9801cdf9374310
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Tue Apr 5 12:39:30 2016 +0100

    iommu: Add MMIO mapping type
    
    On some platforms, MMIO regions might need slightly different treatment
    compared to mapping regular memory; add the notion of MMIO mappings to
    the IOMMU API's memory type flags, so that callers can let the IOMMU
    drivers know to do the right thing.
    
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index a5c539fa5d2b..34b643227df1 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -30,6 +30,7 @@
 #define IOMMU_WRITE	(1 << 1)
 #define IOMMU_CACHE	(1 << 2) /* DMA cache coherency */
 #define IOMMU_NOEXEC	(1 << 3)
+#define IOMMU_MMIO	(1 << 4) /* e.g. things like MSI doorbells */
 
 struct iommu_ops;
 struct iommu_group;

commit b70bb984489363aadd5ccc94d919629d9e264d36
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Mar 15 22:37:17 2016 +0100

    iommu: provide of_xlate pointer unconditionally
    
    iommu drivers that support the standard DT bindings use a of_xlate
    callback pointer, but that is only part of struct iommu_ops when
    CONFIG_OF_IOMMU is enabled, leading to build errors in randconfig
    builds when that is not provided:
    
    drivers/iommu/mtk_iommu.c:497:2: error: unknown field 'of_xlate' specified in initializer
      .of_xlate = mtk_iommu_of_xlate,
      ^
    drivers/iommu/mtk_iommu.c:497:14: error: initialization from incompatible pointer type [-Werror=incompatible-pointer-types]
      .of_xlate = mtk_iommu_of_xlate,
                  ^~~~~~~~~~~~~~~~~~
    drivers/iommu/mtk_iommu.c:497:14: note: (near initialization for 'mtk_iommu_ops.domain_get_attr')
    
    We can work around it by adding more #ifdefs in each driver, but
    it seems nicer to just allow setting the pointer even if it is
    unused. This makes the driver code look nicer, and it gives better
    compile-time coverage when test building on other architectures.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Fixes: 0df4fabe208d ("iommu/mediatek: Add mt8173 IOMMU driver")
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index a5c539fa5d2b..ef7a6ecd8584 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -195,9 +195,7 @@ struct iommu_ops {
 	/* Get the number of windows per domain */
 	u32 (*domain_get_windows)(struct iommu_domain *domain);
 
-#ifdef CONFIG_OF_IOMMU
 	int (*of_xlate)(struct device *dev, struct of_phandle_args *args);
-#endif
 
 	unsigned long pgsize_bitmap;
 	void *priv;

commit 0d9bacb6c8265e7aa75ac28ae9b5d7748065942f
Author: Magnus Damm <damm+renesas@opensource.se>
Date:   Tue Jan 19 14:28:48 2016 +0900

    iommu: Update struct iommu_ops comments
    
    Update the comments around struct iommu_ops to match
    current state and fix a few typos while at it.
    
    Signed-off-by: Magnus Damm <damm+renesas@opensource.se>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index f28dff313b07..a5c539fa5d2b 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -133,8 +133,9 @@ struct iommu_dm_region {
 
 /**
  * struct iommu_ops - iommu ops and capabilities
- * @domain_init: init iommu domain
- * @domain_destroy: destroy iommu domain
+ * @capable: check capability
+ * @domain_alloc: allocate iommu domain
+ * @domain_free: free iommu domain
  * @attach_dev: attach device to an iommu domain
  * @detach_dev: detach device from an iommu domain
  * @map: map a physically contiguous memory region to an iommu domain
@@ -144,8 +145,15 @@ struct iommu_dm_region {
  * @iova_to_phys: translate iova to physical address
  * @add_device: add device to iommu grouping
  * @remove_device: remove device from iommu grouping
+ * @device_group: find iommu group for a particular device
  * @domain_get_attr: Query domain attributes
  * @domain_set_attr: Change domain attributes
+ * @get_dm_regions: Request list of direct mapping requirements for a device
+ * @put_dm_regions: Free list of direct mapping requirements for a device
+ * @domain_window_enable: Configure and enable a particular window for a domain
+ * @domain_window_disable: Disable a particular window for a domain
+ * @domain_set_windows: Set the number of windows for a domain
+ * @domain_get_windows: Return the number of windows for a domain
  * @of_xlate: add OF master IDs to iommu grouping
  * @pgsize_bitmap: bitmap of supported page sizes
  * @priv: per-instance data private to the iommu driver
@@ -182,9 +190,9 @@ struct iommu_ops {
 	int (*domain_window_enable)(struct iommu_domain *domain, u32 wnd_nr,
 				    phys_addr_t paddr, u64 size, int prot);
 	void (*domain_window_disable)(struct iommu_domain *domain, u32 wnd_nr);
-	/* Set the numer of window per domain */
+	/* Set the number of windows per domain */
 	int (*domain_set_windows)(struct iommu_domain *domain, u32 w_count);
-	/* Get the numer of window per domain */
+	/* Get the number of windows per domain */
 	u32 (*domain_get_windows)(struct iommu_domain *domain);
 
 #ifdef CONFIG_OF_IOMMU

commit 6eab556a40384de94c2d03c8d9d632e5154367f5
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Oct 21 23:51:38 2015 +0200

    iommu: Add generic_device_group() function
    
    This function can be used as a device_group call-back and
    just allocates one iommu-group per device.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index a1a06639a64a..f28dff313b07 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -319,6 +319,8 @@ static inline size_t iommu_map_sg(struct iommu_domain *domain,
 
 /* PCI device grouping function */
 extern struct iommu_group *pci_device_group(struct device *dev);
+/* Generic device grouping function */
+extern struct iommu_group *generic_device_group(struct device *dev);
 
 #else /* CONFIG_IOMMU_API */
 

commit 5e62292bad10cff25ff75d136c54e62b43bfb0fa
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Oct 21 23:51:37 2015 +0200

    iommu: Export and rename iommu_group_get_for_pci_dev()
    
    Rename that function to pci_device_group() and export it, so
    that IOMMU drivers can use it as their device_group
    call-back.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index a1e6e8914c17..a1a06639a64a 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -317,6 +317,9 @@ static inline size_t iommu_map_sg(struct iommu_domain *domain,
 	return domain->ops->map_sg(domain, iova, sg, nents, prot);
 }
 
+/* PCI device grouping function */
+extern struct iommu_group *pci_device_group(struct device *dev);
+
 #else /* CONFIG_IOMMU_API */
 
 struct iommu_ops {};

commit 46c6b2bc88a729366605d0dedb6a35b8cf7cc4f0
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Oct 21 23:51:36 2015 +0200

    iommu: Revive device_group iommu-ops call-back
    
    That call-back is currently unused, change it into a
    call-back function for finding the right IOMMU group for a
    device.
    This is a first step to remove the hard-coded PCI dependency
    in the iommu-group code.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index f174506a5343..a1e6e8914c17 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -168,7 +168,7 @@ struct iommu_ops {
 	phys_addr_t (*iova_to_phys)(struct iommu_domain *domain, dma_addr_t iova);
 	int (*add_device)(struct device *dev);
 	void (*remove_device)(struct device *dev);
-	int (*device_group)(struct device *dev, unsigned int *groupid);
+	struct iommu_group *(*device_group)(struct device *dev);
 	int (*domain_get_attr)(struct iommu_domain *domain,
 			       enum iommu_attr attr, void *data);
 	int (*domain_set_attr)(struct iommu_domain *domain,

commit 0db2e5d18f76a66ca945447d9f610bed0a94ca5a
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Thu Oct 1 20:13:58 2015 +0100

    iommu: Implement common IOMMU ops for DMA mapping
    
    Taking inspiration from the existing arch/arm code, break out some
    generic functions to interface the DMA-API to the IOMMU-API. This will
    do the bulk of the heavy lifting for IOMMU-backed dma-mapping.
    
    Since associating an IOVA allocator with an IOMMU domain is a fairly
    common need, rather than introduce yet another private structure just to
    do this for ourselves, extend the top-level struct iommu_domain with the
    notion. A simple opaque cookie allows reuse by other IOMMU API users
    with their various different incompatible allocator types.
    
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index f9c1b6d0f2e4..f174506a5343 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -81,6 +81,7 @@ struct iommu_domain {
 	iommu_fault_handler_t handler;
 	void *handler_token;
 	struct iommu_domain_geometry geometry;
+	void *iova_cookie;
 };
 
 enum iommu_cap {

commit 8db1486065141e619e4855b84e350ef32064f7e1
Author: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
Date:   Fri Jul 17 16:23:42 2015 -0700

    include, lib: add __printf attributes to several function prototypes
    
    Using __printf attributes helps to detect several format string issues
    at compile time (even though -Wformat-security is currently disabled in
    Makefile).  For example it can detect when formatting a pointer as a
    number, like the issue fixed in commit a3fa71c40f18 ("wl18xx: show
    rx_frames_per_rates as an array as it really is"), or when the arguments
    do not match the format string, c.f.  for example commit 5ce1aca81435
    ("reiserfs: fix __RASSERT format string").
    
    To prevent similar bugs in the future, add a __printf attribute to every
    function prototype which needs one in include/linux/ and lib/.  These
    functions were mostly found by using gcc's -Wsuggest-attribute=format
    flag.
    
    Signed-off-by: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index dc767f7c3704..f9c1b6d0f2e4 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -258,7 +258,7 @@ extern int iommu_domain_set_attr(struct iommu_domain *domain, enum iommu_attr,
 				 void *data);
 struct device *iommu_device_create(struct device *parent, void *drvdata,
 				   const struct attribute_group **groups,
-				   const char *fmt, ...);
+				   const char *fmt, ...) __printf(4, 5);
 void iommu_device_destroy(struct device *dev);
 int iommu_device_link(struct device *dev, struct device *link);
 void iommu_device_unlink(struct device *dev, struct device *link);

commit d290f1e70d85a9a4d124594c6a3d769329960bdc
Author: Joerg Roedel <jroedel@suse.de>
Date:   Thu May 28 18:41:36 2015 +0200

    iommu: Introduce iommu_request_dm_for_dev()
    
    This function can be called by an IOMMU driver to request
    that a device's default domain is direct mapped.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index b944b2be4fa2..dc767f7c3704 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -225,6 +225,7 @@ extern void iommu_set_fault_handler(struct iommu_domain *domain,
 
 extern void iommu_get_dm_regions(struct device *dev, struct list_head *list);
 extern void iommu_put_dm_regions(struct device *dev, struct list_head *list);
+extern int iommu_request_dm_for_dev(struct device *dev);
 
 extern int iommu_attach_group(struct iommu_domain *domain,
 			      struct iommu_group *group);
@@ -411,6 +412,11 @@ static inline void iommu_put_dm_regions(struct device *dev,
 {
 }
 
+static inline int iommu_request_dm_for_dev(struct device *dev)
+{
+	return -ENODEV;
+}
+
 static inline int iommu_attach_group(struct iommu_domain *domain,
 				     struct iommu_group *group)
 {

commit 6827ca83695d5e41ad31b0719788ee65f00ca4b3
Author: Joerg Roedel <jroedel@suse.de>
Date:   Thu May 28 18:41:35 2015 +0200

    iommu: Add function to query the default domain of a group
    
    This will be used to handle unity mappings in the iommu
    drivers.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 689499904166..b944b2be4fa2 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -249,6 +249,7 @@ extern int iommu_group_unregister_notifier(struct iommu_group *group,
 					   struct notifier_block *nb);
 extern int iommu_group_id(struct iommu_group *group);
 extern struct iommu_group *iommu_group_get_for_dev(struct device *dev);
+extern struct iommu_domain *iommu_group_default_domain(struct iommu_group *);
 
 extern int iommu_domain_get_attr(struct iommu_domain *domain, enum iommu_attr,
 				 void *data);

commit a1015c2b99b94cf521603b41debf167114031456
Author: Joerg Roedel <jroedel@suse.de>
Date:   Thu May 28 18:41:33 2015 +0200

    iommu: Introduce direct mapped region handling
    
    Add two new functions to the IOMMU-API to allow the IOMMU
    drivers to export the requirements for direct mapped regions
    per device.
    This is useful for exporting the information in Intel VT-d's
    RMRR entries or AMD-Vi's unity mappings.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 683a1c4b15e7..689499904166 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -114,6 +114,20 @@ enum iommu_attr {
 	DOMAIN_ATTR_MAX,
 };
 
+/**
+ * struct iommu_dm_region - descriptor for a direct mapped memory region
+ * @list: Linked list pointers
+ * @start: System physical start address of the region
+ * @length: Length of the region in bytes
+ * @prot: IOMMU Protection flags (READ/WRITE/...)
+ */
+struct iommu_dm_region {
+	struct list_head	list;
+	phys_addr_t		start;
+	size_t			length;
+	int			prot;
+};
+
 #ifdef CONFIG_IOMMU_API
 
 /**
@@ -159,6 +173,10 @@ struct iommu_ops {
 	int (*domain_set_attr)(struct iommu_domain *domain,
 			       enum iommu_attr attr, void *data);
 
+	/* Request/Free a list of direct mapping requirements for a device */
+	void (*get_dm_regions)(struct device *dev, struct list_head *list);
+	void (*put_dm_regions)(struct device *dev, struct list_head *list);
+
 	/* Window handling functions */
 	int (*domain_window_enable)(struct iommu_domain *domain, u32 wnd_nr,
 				    phys_addr_t paddr, u64 size, int prot);
@@ -205,6 +223,9 @@ extern phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain, dma_addr_t io
 extern void iommu_set_fault_handler(struct iommu_domain *domain,
 			iommu_fault_handler_t handler, void *token);
 
+extern void iommu_get_dm_regions(struct device *dev, struct list_head *list);
+extern void iommu_put_dm_regions(struct device *dev, struct list_head *list);
+
 extern int iommu_attach_group(struct iommu_domain *domain,
 			      struct iommu_group *group);
 extern void iommu_detach_group(struct iommu_domain *domain,
@@ -379,6 +400,16 @@ static inline void iommu_set_fault_handler(struct iommu_domain *domain,
 {
 }
 
+static inline void iommu_get_dm_regions(struct device *dev,
+					struct list_head *list)
+{
+}
+
+static inline void iommu_put_dm_regions(struct device *dev,
+					struct list_head *list)
+{
+}
+
 static inline int iommu_attach_group(struct iommu_domain *domain,
 				     struct iommu_group *group)
 {

commit 2c1296d92ac0367364bcb73a43c12a0bdfbfee75
Author: Joerg Roedel <jroedel@suse.de>
Date:   Thu May 28 18:41:32 2015 +0200

    iommu: Add iommu_get_domain_for_dev function
    
    This function can be used to request the current domain a
    device is attached to.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 0546b8710ce3..683a1c4b15e7 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -193,6 +193,7 @@ extern int iommu_attach_device(struct iommu_domain *domain,
 			       struct device *dev);
 extern void iommu_detach_device(struct iommu_domain *domain,
 				struct device *dev);
+extern struct iommu_domain *iommu_get_domain_for_dev(struct device *dev);
 extern int iommu_map(struct iommu_domain *domain, unsigned long iova,
 		     phys_addr_t paddr, size_t size, int prot);
 extern size_t iommu_unmap(struct iommu_domain *domain, unsigned long iova,
@@ -332,6 +333,11 @@ static inline void iommu_detach_device(struct iommu_domain *domain,
 {
 }
 
+static inline struct iommu_domain *iommu_get_domain_for_dev(struct device *dev)
+{
+	return NULL;
+}
+
 static inline int iommu_map(struct iommu_domain *domain, unsigned long iova,
 			    phys_addr_t paddr, int gfp_order, int prot)
 {

commit 89be34a1ced886880a3219f9d2ba2192dc738ef2
Author: Joerg Roedel <jroedel@suse.de>
Date:   Thu Mar 26 13:43:19 2015 +0100

    iommu: Remove domain_init and domain_free iommu_ops
    
    All drivers have been converted to the new domain_alloc and
    domain_free iommu-ops. So remove the old ones and get rid of
    iommu_domain->priv too, as this is no longer needed when the
    struct iommu_domain is embedded in the private structures of
    the iommu drivers.
    
    Tested-by: Thierry Reding <treding@nvidia.com>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Reviewed-by: Alex Williamson <alex.williamson@redhat.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 72d03fe78cf6..0546b8710ce3 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -78,7 +78,6 @@ struct iommu_domain_geometry {
 struct iommu_domain {
 	unsigned type;
 	const struct iommu_ops *ops;
-	void *priv;
 	iommu_fault_handler_t handler;
 	void *handler_token;
 	struct iommu_domain_geometry geometry;
@@ -138,8 +137,6 @@ enum iommu_attr {
  */
 struct iommu_ops {
 	bool (*capable)(enum iommu_cap);
-	int (*domain_init)(struct iommu_domain *domain);
-	void (*domain_destroy)(struct iommu_domain *domain);
 
 	/* Domain allocation and freeing by the iommu driver */
 	struct iommu_domain *(*domain_alloc)(unsigned iommu_domain_type);

commit 8539c7c16b970258e14761d8a1f7d10fe798031a
Author: Joerg Roedel <jroedel@suse.de>
Date:   Thu Mar 26 13:43:05 2015 +0100

    iommu: Introduce iommu domain types
    
    This allows to handle domains differently based on their
    type in the future. An IOMMU driver can implement certain
    optimizations for DMA-API domains for example.
    
    The domain types can be extended later and some of the
    existing domain attributes can be migrated to become domain
    flags.
    
    Tested-by: Thierry Reding <treding@nvidia.com>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Reviewed-by: Alex Williamson <alex.williamson@redhat.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 69d1d120c0a3..72d03fe78cf6 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -51,7 +51,32 @@ struct iommu_domain_geometry {
 	bool force_aperture;       /* DMA only allowed in mappable range? */
 };
 
+/* Domain feature flags */
+#define __IOMMU_DOMAIN_PAGING	(1U << 0)  /* Support for iommu_map/unmap */
+#define __IOMMU_DOMAIN_DMA_API	(1U << 1)  /* Domain for use in DMA-API
+					      implementation              */
+#define __IOMMU_DOMAIN_PT	(1U << 2)  /* Domain is identity mapped   */
+
+/*
+ * This are the possible domain-types
+ *
+ *	IOMMU_DOMAIN_BLOCKED	- All DMA is blocked, can be used to isolate
+ *				  devices
+ *	IOMMU_DOMAIN_IDENTITY	- DMA addresses are system physical addresses
+ *	IOMMU_DOMAIN_UNMANAGED	- DMA mappings managed by IOMMU-API user, used
+ *				  for VMs
+ *	IOMMU_DOMAIN_DMA	- Internally used for DMA-API implementations.
+ *				  This flag allows IOMMU drivers to implement
+ *				  certain optimizations for these domains
+ */
+#define IOMMU_DOMAIN_BLOCKED	(0U)
+#define IOMMU_DOMAIN_IDENTITY	(__IOMMU_DOMAIN_PT)
+#define IOMMU_DOMAIN_UNMANAGED	(__IOMMU_DOMAIN_PAGING)
+#define IOMMU_DOMAIN_DMA	(__IOMMU_DOMAIN_PAGING |	\
+				 __IOMMU_DOMAIN_DMA_API)
+
 struct iommu_domain {
+	unsigned type;
 	const struct iommu_ops *ops;
 	void *priv;
 	iommu_fault_handler_t handler;
@@ -117,7 +142,7 @@ struct iommu_ops {
 	void (*domain_destroy)(struct iommu_domain *domain);
 
 	/* Domain allocation and freeing by the iommu driver */
-	struct iommu_domain *(*domain_alloc)(void);
+	struct iommu_domain *(*domain_alloc)(unsigned iommu_domain_type);
 	void (*domain_free)(struct iommu_domain *);
 
 	int (*attach_dev)(struct iommu_domain *domain, struct device *dev);

commit 938c470976192590b4adc921b2e10fa31237eddc
Author: Joerg Roedel <jroedel@suse.de>
Date:   Thu Mar 26 13:43:04 2015 +0100

    iommu: Introduce domain_alloc and domain_free iommu_ops
    
    These new call-backs defer the allocation and destruction of
    'struct iommu_domain' to the iommu driver. This allows
    drivers to embed this struct into their private domain
    structures and to get rid of the domain_init and
    domain_destroy call-backs when all drivers have been
    converted.
    
    Tested-by: Thierry Reding <treding@nvidia.com>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Reviewed-by: Alex Williamson <alex.williamson@redhat.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 38daa453f2e5..69d1d120c0a3 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -115,6 +115,11 @@ struct iommu_ops {
 	bool (*capable)(enum iommu_cap);
 	int (*domain_init)(struct iommu_domain *domain);
 	void (*domain_destroy)(struct iommu_domain *domain);
+
+	/* Domain allocation and freeing by the iommu driver */
+	struct iommu_domain *(*domain_alloc)(void);
+	void (*domain_free)(struct iommu_domain *);
+
 	int (*attach_dev)(struct iommu_domain *domain, struct device *dev);
 	void (*detach_dev)(struct iommu_domain *domain, struct device *dev);
 	int (*map)(struct iommu_domain *domain, unsigned long iova,

commit 6f51ee709e4c6b56f2c2a071da2d056a109b9d26
Merge: 205dc205ed3b fd522d279235
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 16 14:53:01 2014 -0800

    Merge tag 'iommu-config-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC/iommu configuration update from Arnd Bergmann:
     "The iomm-config branch contains work from Will Deacon, quoting his
      description:
    
        This series adds automatic IOMMU and DMA-mapping configuration for
        OF-based DMA masters described using the generic IOMMU devicetree
        bindings. Although there is plenty of future work around splitting up
        iommu_ops, adding default IOMMU domains and sorting out automatic IOMMU
        group creation for the platform_bus, this is already useful enough for
        people to port over their IOMMU drivers and start using the new probing
        infrastructure (indeed, Marek has patches queued for the Exynos IOMMU).
    
      The branch touches core ARM and IOMMU driver files, and the respective
      maintainers (Russell King and Joerg Roedel) agreed to have the
      contents merged through the arm-soc tree.
    
      The final version was ready just before the merge window, so we ended
      up delaying it a bit longer than the rest, but we don't expect to see
      regressions because this is just additional infrastructure that will
      get used in drivers starting in 3.20 but is unused so far"
    
    * tag 'iommu-config-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc:
      iommu: store DT-probed IOMMU data privately
      arm: dma-mapping: plumb our iommu mapping ops into arch_setup_dma_ops
      arm: call iommu_init before of_platform_populate
      dma-mapping: detect and configure IOMMU in of_dma_configure
      iommu: fix initialization without 'add_device' callback
      iommu: provide helper function to configure an IOMMU for an of master
      iommu: add new iommu_ops callback for adding an OF device
      dma-mapping: replace set_arch_dma_coherent_ops with arch_setup_dma_ops
      iommu: provide early initialisation hook for IOMMU drivers

commit 76771c938e95ce4106c6e8092f4f614d4d1e0ecc
Merge: 99cb9aee770e 263bc3fd6a8e 11175886daa6 e222d6a4259c 2d565a57f252 cc4f14aa170d 1c51099a427d 18f23409909a
Author: Joerg Roedel <jroedel@suse.de>
Date:   Tue Dec 2 13:07:13 2014 +0100

    Merge branches 'arm/omap', 'arm/msm', 'arm/rockchip', 'arm/renesas', 'arm/smmu', 'x86/vt-d', 'x86/amd' and 'core' into next
    
    Conflicts:
            drivers/iommu/arm-smmu.c

commit d0f60a44f5120a8e1c48995285c7d8d1e4915b35
Author: Will Deacon <will.deacon@arm.com>
Date:   Wed Aug 27 16:15:59 2014 +0100

    iommu: add new iommu_ops callback for adding an OF device
    
    This patch adds a new function to the iommu_ops structure to allow an
    OF device to be added to a specific IOMMU instance using the recently
    merged generic devicetree binding for IOMMUs. The callback (of_xlate)
    takes a struct device representing the master and an of_phandle_args
    representing the IOMMU and the correspondong IDs for the new master.
    
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Joerg Roedel <jroedel@suse.de>
    Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Tested-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 7b83f9f8e11d..415c7613d02c 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -21,6 +21,7 @@
 
 #include <linux/errno.h>
 #include <linux/err.h>
+#include <linux/of.h>
 #include <linux/types.h>
 #include <trace/events/iommu.h>
 
@@ -102,6 +103,7 @@ enum iommu_attr {
  * @remove_device: remove device from iommu grouping
  * @domain_get_attr: Query domain attributes
  * @domain_set_attr: Change domain attributes
+ * @of_xlate: add OF master IDs to iommu grouping
  * @pgsize_bitmap: bitmap of supported page sizes
  * @priv: per-instance data private to the iommu driver
  */
@@ -133,6 +135,10 @@ struct iommu_ops {
 	/* Get the numer of window per domain */
 	u32 (*domain_get_windows)(struct iommu_domain *domain);
 
+#ifdef CONFIG_OF_IOMMU
+	int (*of_xlate)(struct device *dev, struct of_phandle_args *args);
+#endif
+
 	unsigned long pgsize_bitmap;
 	void *priv;
 };

commit 1cd076bf67793942ed921b766f7d461de2ebc0a2
Author: Will Deacon <will.deacon@arm.com>
Date:   Wed Aug 27 14:40:58 2014 +0100

    iommu: provide early initialisation hook for IOMMU drivers
    
    IOMMU drivers must be initialised before any of their upstream devices,
    otherwise the relevant iommu_ops won't be configured for the bus in
    question. To solve this, a number of IOMMU drivers use initcalls to
    initialise the driver before anything has a chance to be probed.
    
    Whilst this solves the immediate problem, it leaves the job of probing
    the IOMMU completely separate from the iommu_ops to configure the IOMMU,
    which are called on a per-bus basis and require the driver to figure out
    exactly which instance of the IOMMU is being requested. In particular,
    the add_device callback simply passes a struct device to the driver,
    which then has to parse firmware tables or probe buses to identify the
    relevant IOMMU instance.
    
    This patch takes the first step in addressing this problem by adding an
    early initialisation pass for IOMMU drivers, giving them the ability to
    store some per-instance data in their iommu_ops structure and store that
    in their of_node. This can later be used when parsing OF masters to
    identify the IOMMU instance in question.
    
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Joerg Roedel <jroedel@suse.de>
    Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Tested-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index e6a7c9ff72f2..7b83f9f8e11d 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -103,6 +103,7 @@ enum iommu_attr {
  * @domain_get_attr: Query domain attributes
  * @domain_set_attr: Change domain attributes
  * @pgsize_bitmap: bitmap of supported page sizes
+ * @priv: per-instance data private to the iommu driver
  */
 struct iommu_ops {
 	bool (*capable)(enum iommu_cap);
@@ -133,6 +134,7 @@ struct iommu_ops {
 	u32 (*domain_get_windows)(struct iommu_domain *domain);
 
 	unsigned long pgsize_bitmap;
+	void *priv;
 };
 
 #define IOMMU_GROUP_NOTIFY_ADD_DEVICE		1 /* Device added */

commit c49866493b1ffb7c0a7963a1e3c0094e78760184
Author: Antonios Motakis <a.motakis@virtualopensystems.com>
Date:   Mon Oct 13 14:06:17 2014 +0100

    iommu: add capability IOMMU_CAP_NOEXEC
    
    Some IOMMUs accept an IOMMU_NOEXEC protection flag in addition to
    IOMMU_READ and IOMMU_WRITE. Expose this as an IOMMU capability.
    
    Signed-off-by: Antonios Motakis <a.motakis@virtualopensystems.com>
    Acked-by: Joerg Roedel <jroedel@suse.de>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index f47383a05d34..e438b30f062b 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -61,6 +61,7 @@ enum iommu_cap {
 	IOMMU_CAP_CACHE_COHERENCY,	/* IOMMU can enforce cache coherent DMA
 					   transactions */
 	IOMMU_CAP_INTR_REMAP,		/* IOMMU supports interrupt isolation */
+	IOMMU_CAP_NOEXEC,		/* IOMMU_NOEXEC flag */
 };
 
 /*

commit a720b41c41f5a7e4c51558cf087882c57331581f
Author: Antonios Motakis <a.motakis@virtualopensystems.com>
Date:   Mon Oct 13 14:06:16 2014 +0100

    iommu/arm-smmu: change IOMMU_EXEC to IOMMU_NOEXEC
    
    Exposing the XN flag of the SMMU driver as IOMMU_NOEXEC instead of
    IOMMU_EXEC makes it enforceable, since for IOMMUs that don't support
    the XN flag pages will always be executable.
    
    Signed-off-by: Antonios Motakis <a.motakis@virtualopensystems.com>
    Acked-by: Joerg Roedel <jroedel@suse.de>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index e6a7c9ff72f2..f47383a05d34 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -27,7 +27,7 @@
 #define IOMMU_READ	(1 << 0)
 #define IOMMU_WRITE	(1 << 1)
 #define IOMMU_CACHE	(1 << 2) /* DMA cache coherency */
-#define IOMMU_EXEC	(1 << 3)
+#define IOMMU_NOEXEC	(1 << 3)
 
 struct iommu_ops;
 struct iommu_group;

commit 315786ebbf4ad6552b6fd8e0e7b2ea220fcbfdbd
Author: Olav Haugan <ohaugan@codeaurora.org>
Date:   Sat Oct 25 09:55:16 2014 -0700

    iommu: Add iommu_map_sg() function
    
    Mapping and unmapping are more often than not in the critical path.
    map_sg allows IOMMU driver implementations to optimize the process
    of mapping buffers into the IOMMU page tables.
    
    Instead of mapping a buffer one page at a time and requiring potentially
    expensive TLB operations for each page, this function allows the driver
    to map all pages in one go and defer TLB maintenance until after all
    pages have been mapped.
    
    Additionally, the mapping operation would be faster in general since
    clients does not have to keep calling map API over and over again for
    each physically contiguous chunk of memory that needs to be mapped to a
    virtually contiguous region.
    
    Signed-off-by: Olav Haugan <ohaugan@codeaurora.org>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index e6a7c9ff72f2..b29a5982e1c3 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -22,6 +22,7 @@
 #include <linux/errno.h>
 #include <linux/err.h>
 #include <linux/types.h>
+#include <linux/scatterlist.h>
 #include <trace/events/iommu.h>
 
 #define IOMMU_READ	(1 << 0)
@@ -97,6 +98,8 @@ enum iommu_attr {
  * @detach_dev: detach device from an iommu domain
  * @map: map a physically contiguous memory region to an iommu domain
  * @unmap: unmap a physically contiguous memory region from an iommu domain
+ * @map_sg: map a scatter-gather list of physically contiguous memory chunks
+ * to an iommu domain
  * @iova_to_phys: translate iova to physical address
  * @add_device: add device to iommu grouping
  * @remove_device: remove device from iommu grouping
@@ -114,6 +117,8 @@ struct iommu_ops {
 		   phys_addr_t paddr, size_t size, int prot);
 	size_t (*unmap)(struct iommu_domain *domain, unsigned long iova,
 		     size_t size);
+	size_t (*map_sg)(struct iommu_domain *domain, unsigned long iova,
+			 struct scatterlist *sg, unsigned int nents, int prot);
 	phys_addr_t (*iova_to_phys)(struct iommu_domain *domain, dma_addr_t iova);
 	int (*add_device)(struct device *dev);
 	void (*remove_device)(struct device *dev);
@@ -156,6 +161,9 @@ extern int iommu_map(struct iommu_domain *domain, unsigned long iova,
 		     phys_addr_t paddr, size_t size, int prot);
 extern size_t iommu_unmap(struct iommu_domain *domain, unsigned long iova,
 		       size_t size);
+extern size_t default_iommu_map_sg(struct iommu_domain *domain, unsigned long iova,
+				struct scatterlist *sg,unsigned int nents,
+				int prot);
 extern phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain, dma_addr_t iova);
 extern void iommu_set_fault_handler(struct iommu_domain *domain,
 			iommu_fault_handler_t handler, void *token);
@@ -241,6 +249,13 @@ static inline int report_iommu_fault(struct iommu_domain *domain,
 	return ret;
 }
 
+static inline size_t iommu_map_sg(struct iommu_domain *domain,
+				  unsigned long iova, struct scatterlist *sg,
+				  unsigned int nents, int prot)
+{
+	return domain->ops->map_sg(domain, iova, sg, nents, prot);
+}
+
 #else /* CONFIG_IOMMU_API */
 
 struct iommu_ops {};
@@ -293,6 +308,13 @@ static inline int iommu_unmap(struct iommu_domain *domain, unsigned long iova,
 	return -ENODEV;
 }
 
+static inline size_t iommu_map_sg(struct iommu_domain *domain,
+				  unsigned long iova, struct scatterlist *sg,
+				  unsigned int nents, int prot)
+{
+	return -ENODEV;
+}
+
 static inline int iommu_domain_window_enable(struct iommu_domain *domain,
 					     u32 wnd_nr, phys_addr_t paddr,
 					     u64 size, int prot)

commit 23971bdffff5f7c904131dfb41c186711dc2c418
Merge: c0fa2373f8cf 09b5269a1b3d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 15 07:23:49 2014 +0200

    Merge tag 'iommu-updates-v3.18' of git://git.kernel.org/pub/scm/linux/kernel/git/joro/iommu
    
    Pull IOMMU updates from Joerg Roedel:
     "This pull-request includes:
    
       - change in the IOMMU-API to convert the former iommu_domain_capable
         function to just iommu_capable
    
       - various fixes in handling RMRR ranges for the VT-d driver (one fix
         requires a device driver core change which was acked by Greg KH)
    
       - the AMD IOMMU driver now assigns and deassigns complete alias
         groups to fix issues with devices using the wrong PCI request-id
    
       - MMU-401 support for the ARM SMMU driver
    
       - multi-master IOMMU group support for the ARM SMMU driver
    
       - various other small fixes all over the place"
    
    * tag 'iommu-updates-v3.18' of git://git.kernel.org/pub/scm/linux/kernel/git/joro/iommu: (41 commits)
      iommu/vt-d: Work around broken RMRR firmware entries
      iommu/vt-d: Store bus information in RMRR PCI device path
      iommu/vt-d: Only remove domain when device is removed
      driver core: Add BUS_NOTIFY_REMOVED_DEVICE event
      iommu/amd: Fix devid mapping for ivrs_ioapic override
      iommu/irq_remapping: Fix the regression of hpet irq remapping
      iommu: Fix bus notifier breakage
      iommu/amd: Split init_iommu_group() from iommu_init_device()
      iommu: Rework iommu_group_get_for_pci_dev()
      iommu: Make of_device_id array const
      amd_iommu: do not dereference a NULL pointer address.
      iommu/omap: Remove omap_iommu unused owner field
      iommu: Remove iommu_domain_has_cap() API function
      IB/usnic: Convert to use new iommu_capable() API function
      vfio: Convert to use new iommu_capable() API function
      kvm: iommu: Convert to use new iommu_capable() API function
      iommu/tegra: Convert to iommu_capable() API function
      iommu/msm: Convert to iommu_capable() API function
      iommu/vt-d: Convert to iommu_capable() API function
      iommu/fsl: Convert to iommu_capable() API function
      ...

commit c02607aad2f9ed478eb288bcec1c00cd9df38b3c
Author: Will Deacon <will.deacon@arm.com>
Date:   Mon Sep 29 10:05:06 2014 -0600

    iommu: introduce domain attribute for nesting IOMMUs
    
    Some IOMMUs, such as the ARM SMMU, support two stages of translation.
    The idea behind such a scheme is to allow a guest operating system to
    use the IOMMU for DMA mappings in the first stage of translation, with
    the hypervisor then installing mappings in the second stage to provide
    isolation of the DMA to the physical range assigned to that virtual
    machine.
    
    In order to allow IOMMU domains to be used for second-stage translation,
    this patch adds a new iommu_attr (IOMMU_ATTR_NESTING) for setting
    second-stage domains prior to device attach. The attribute can also be
    queried to see if a domain is actually making use of nesting.
    
    Acked-by: Joerg Roedel <jroedel@suse.de>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 20f9a527922a..7b02bcc85b9e 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -80,6 +80,7 @@ enum iommu_attr {
 	DOMAIN_ATTR_FSL_PAMU_STASH,
 	DOMAIN_ATTR_FSL_PAMU_ENABLE,
 	DOMAIN_ATTR_FSL_PAMUV1,
+	DOMAIN_ATTR_NESTING,	/* two stages of translation */
 	DOMAIN_ATTR_MAX,
 };
 

commit 24278a24d88ae730229417e5d3bd452d7545fbcc
Author: Joerg Roedel <jroedel@suse.de>
Date:   Fri Sep 5 10:57:11 2014 +0200

    iommu: Remove iommu_domain_has_cap() API function
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index d5534d554693..379a6179fd96 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -97,7 +97,6 @@ enum iommu_attr {
  * @map: map a physically contiguous memory region to an iommu domain
  * @unmap: unmap a physically contiguous memory region from an iommu domain
  * @iova_to_phys: translate iova to physical address
- * @domain_has_cap: domain capabilities query
  * @add_device: add device to iommu grouping
  * @remove_device: remove device from iommu grouping
  * @domain_get_attr: Query domain attributes
@@ -115,8 +114,6 @@ struct iommu_ops {
 	size_t (*unmap)(struct iommu_domain *domain, unsigned long iova,
 		     size_t size);
 	phys_addr_t (*iova_to_phys)(struct iommu_domain *domain, dma_addr_t iova);
-	int (*domain_has_cap)(struct iommu_domain *domain,
-			      unsigned long cap);
 	int (*add_device)(struct device *dev);
 	void (*remove_device)(struct device *dev);
 	int (*device_group)(struct device *dev, unsigned int *groupid);
@@ -159,8 +156,6 @@ extern int iommu_map(struct iommu_domain *domain, unsigned long iova,
 extern size_t iommu_unmap(struct iommu_domain *domain, unsigned long iova,
 		       size_t size);
 extern phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain, dma_addr_t iova);
-extern int iommu_domain_has_cap(struct iommu_domain *domain,
-				enum iommu_cap cap);
 extern void iommu_set_fault_handler(struct iommu_domain *domain,
 			iommu_fault_handler_t handler, void *token);
 
@@ -314,12 +309,6 @@ static inline phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain, dma_ad
 	return 0;
 }
 
-static inline int iommu_domain_has_cap(struct iommu_domain *domain,
-				       enum iommu_cap cap)
-{
-	return 0;
-}
-
 static inline void iommu_set_fault_handler(struct iommu_domain *domain,
 				iommu_fault_handler_t handler, void *token)
 {

commit 3c0e0ca0a4e757159d868c4870556515d66b6c97
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Sep 3 18:47:25 2014 +0200

    iommu: Introduce iommu_capable API function
    
    This function will replace the current iommu_domain_has_cap
    function and clean up the interface while at it.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 98fc126655ae..d5534d554693 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -105,6 +105,7 @@ enum iommu_attr {
  * @pgsize_bitmap: bitmap of supported page sizes
  */
 struct iommu_ops {
+	bool (*capable)(enum iommu_cap);
 	int (*domain_init)(struct iommu_domain *domain);
 	void (*domain_destroy)(struct iommu_domain *domain);
 	int (*attach_dev)(struct iommu_domain *domain, struct device *dev);
@@ -145,6 +146,7 @@ struct iommu_ops {
 
 extern int bus_set_iommu(struct bus_type *bus, const struct iommu_ops *ops);
 extern bool iommu_present(struct bus_type *bus);
+extern bool iommu_capable(struct bus_type *bus, enum iommu_cap cap);
 extern struct iommu_domain *iommu_domain_alloc(struct bus_type *bus);
 extern struct iommu_group *iommu_group_get_by_id(int id);
 extern void iommu_domain_free(struct iommu_domain *domain);
@@ -253,6 +255,11 @@ static inline bool iommu_present(struct bus_type *bus)
 	return false;
 }
 
+static inline bool iommu_capable(struct bus_type *bus, enum iommu_cap cap)
+{
+	return false;
+}
+
 static inline struct iommu_domain *iommu_domain_alloc(struct bus_type *bus)
 {
 	return NULL;

commit 1aed074869a9cbe0a846ea7b254d8fd9a4a4d31f
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Sep 3 18:34:04 2014 +0200

    iommu: Convert iommu-caps from define to enum
    
    Allow compile-time type-checking.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 20f9a527922a..98fc126655ae 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -57,8 +57,11 @@ struct iommu_domain {
 	struct iommu_domain_geometry geometry;
 };
 
-#define IOMMU_CAP_CACHE_COHERENCY	0x1
-#define IOMMU_CAP_INTR_REMAP		0x2	/* isolates device intrs */
+enum iommu_cap {
+	IOMMU_CAP_CACHE_COHERENCY,	/* IOMMU can enforce cache coherent DMA
+					   transactions */
+	IOMMU_CAP_INTR_REMAP,		/* IOMMU supports interrupt isolation */
+};
 
 /*
  * Following constraints are specifc to FSL_PAMUV1:
@@ -155,7 +158,7 @@ extern size_t iommu_unmap(struct iommu_domain *domain, unsigned long iova,
 		       size_t size);
 extern phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain, dma_addr_t iova);
 extern int iommu_domain_has_cap(struct iommu_domain *domain,
-				unsigned long cap);
+				enum iommu_cap cap);
 extern void iommu_set_fault_handler(struct iommu_domain *domain,
 			iommu_fault_handler_t handler, void *token);
 
@@ -305,7 +308,7 @@ static inline phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain, dma_ad
 }
 
 static inline int iommu_domain_has_cap(struct iommu_domain *domain,
-				       unsigned long cap)
+				       enum iommu_cap cap)
 {
 	return 0;
 }

commit e09f8ea560490e941139d23b4c278d3e6e2c871a
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Mon Jul 7 14:31:36 2014 -0600

    iommu: Fix IOMMU sysfs stubs
    
    0-day kernel build testing reports:
    
       arch/x86/kvm/x86.o: In function `iommu_device_destroy':
    >> (.text+0x7a0a): multiple definition of `iommu_device_destroy'
       arch/x86/kvm/../../../virt/kvm/vfio.o:vfio.c:(.text+0x490): first defined here
       arch/x86/kvm/x86.o: In function `iommu_device_link':
    >> (.text+0x7a15): multiple definition of `iommu_device_link'
       arch/x86/kvm/../../../virt/kvm/vfio.o:vfio.c:(.text+0x49b): first defined here
       arch/x86/kvm/x86.o: In function `iommu_device_unlink':
    >> (.text+0x7a25): multiple definition of `iommu_device_unlink'
       arch/x86/kvm/../../../virt/kvm/vfio.o:vfio.c:(.text+0x4ab): first defined here
       arch/x86/kvm/x86.o: In function `iommu_device_create':
    >> (.text+0x79f8): multiple definition of `iommu_device_create'
       arch/x86/kvm/../../../virt/kvm/vfio.o:vfio.c:(.text+0x47e): first defined here
    
    These are due to failing to define the stubs as static inline.  Fix.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index c7097d7f024c..20f9a527922a 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -403,23 +403,24 @@ static inline int iommu_domain_set_attr(struct iommu_domain *domain,
 	return -EINVAL;
 }
 
-struct device *iommu_device_create(struct device *parent, void *drvdata,
-				   const struct attribute_group **groups,
-				   const char *fmt, ...)
+static inline struct device *iommu_device_create(struct device *parent,
+					void *drvdata,
+					const struct attribute_group **groups,
+					const char *fmt, ...)
 {
 	return ERR_PTR(-ENODEV);
 }
 
-void iommu_device_destroy(struct device *dev)
+static inline void iommu_device_destroy(struct device *dev)
 {
 }
 
-int iommu_device_link(struct device *dev, struct device *link)
+static inline int iommu_device_link(struct device *dev, struct device *link)
 {
 	return -EINVAL;
 }
 
-void iommu_device_unlink(struct device *dev, struct device *link)
+static inline void iommu_device_unlink(struct device *dev, struct device *link)
 {
 }
 

commit b22f6434cf48af001330e370e9d781aeb668f98c
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Jun 27 09:03:12 2014 +0200

    iommu: Constify struct iommu_ops
    
    This structure is read-only data and should never be modified.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 7fd16e3d1f25..c7097d7f024c 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -50,7 +50,7 @@ struct iommu_domain_geometry {
 };
 
 struct iommu_domain {
-	struct iommu_ops *ops;
+	const struct iommu_ops *ops;
 	void *priv;
 	iommu_fault_handler_t handler;
 	void *handler_token;
@@ -140,7 +140,7 @@ struct iommu_ops {
 #define IOMMU_GROUP_NOTIFY_UNBIND_DRIVER	5 /* Pre Driver unbind */
 #define IOMMU_GROUP_NOTIFY_UNBOUND_DRIVER	6 /* Post Driver unbind */
 
-extern int bus_set_iommu(struct bus_type *bus, struct iommu_ops *ops);
+extern int bus_set_iommu(struct bus_type *bus, const struct iommu_ops *ops);
 extern bool iommu_present(struct bus_type *bus);
 extern struct iommu_domain *iommu_domain_alloc(struct bus_type *bus);
 extern struct iommu_group *iommu_group_get_by_id(int id);

commit c61959ecbbc6bf9034e65c8e8ef03fa9d1066f05
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Thu Jun 12 16:12:24 2014 -0600

    iommu: Add sysfs support for IOMMUs
    
    IOMMUs currently have no common representation to userspace, most
    seem to have no representation at all aside from a few printks
    on bootup.  There are however features of IOMMUs that are useful
    to know about.  For instance the IOMMU might support superpages,
    making use of processor large/huge pages more important in a device
    assignment scenario.  It's also useful to create cross links between
    devices and IOMMU hardware units, so that users might be able to
    load balance their devices to avoid thrashing a single hardware unit.
    
    This patch adds a device create and destroy interface as well as
    device linking, making it very lightweight for an IOMMU driver to add
    basic support.  IOMMU drivers can provide additional attributes
    automatically by using an attribute_group.
    
    The attributes exposed are expected to be relatively device specific,
    the means to retrieve them certainly are, so there are currently no
    common attributes for the new class created here.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index a2e5843b0a22..7fd16e3d1f25 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -187,6 +187,12 @@ extern int iommu_domain_get_attr(struct iommu_domain *domain, enum iommu_attr,
 				 void *data);
 extern int iommu_domain_set_attr(struct iommu_domain *domain, enum iommu_attr,
 				 void *data);
+struct device *iommu_device_create(struct device *parent, void *drvdata,
+				   const struct attribute_group **groups,
+				   const char *fmt, ...);
+void iommu_device_destroy(struct device *dev);
+int iommu_device_link(struct device *dev, struct device *link);
+void iommu_device_unlink(struct device *dev, struct device *link);
 
 /* Window handling function prototypes */
 extern int iommu_domain_window_enable(struct iommu_domain *domain, u32 wnd_nr,
@@ -397,6 +403,26 @@ static inline int iommu_domain_set_attr(struct iommu_domain *domain,
 	return -EINVAL;
 }
 
+struct device *iommu_device_create(struct device *parent, void *drvdata,
+				   const struct attribute_group **groups,
+				   const char *fmt, ...)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+void iommu_device_destroy(struct device *dev)
+{
+}
+
+int iommu_device_link(struct device *dev, struct device *link)
+{
+	return -EINVAL;
+}
+
+void iommu_device_unlink(struct device *dev, struct device *link)
+{
+}
+
 #endif /* CONFIG_IOMMU_API */
 
 #endif /* __LINUX_IOMMU_H */

commit 104a1c13ac66e40cf8c6ae74d76ff14ff24b9b01
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Thu Jul 3 09:51:18 2014 -0600

    iommu/core: Create central IOMMU group lookup/creation interface
    
    Currently each IOMMU driver that supports IOMMU groups has its own
    code for discovering the base device used in grouping.  This code
    is generally not specific to the IOMMU hardware, but to the bus of
    the devices managed by the IOMMU.  We can therefore create a common
    interface for supporting devices on different buses.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index b96a5b2136e4..a2e5843b0a22 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -181,6 +181,7 @@ extern int iommu_group_register_notifier(struct iommu_group *group,
 extern int iommu_group_unregister_notifier(struct iommu_group *group,
 					   struct notifier_block *nb);
 extern int iommu_group_id(struct iommu_group *group);
+extern struct iommu_group *iommu_group_get_for_dev(struct device *dev);
 
 extern int iommu_domain_get_attr(struct iommu_domain *domain, enum iommu_attr,
 				 void *data);

commit dd1a175695edf662615e422d1c85eae875a411b2
Merge: e2c22d9599ec cbff5634dcb7 9f4c7448f46b e87c621dced1 b82a2272b37a b3eb76d17570 5b5c13996ff1 4c071c7b851b
Author: Joerg Roedel <joro@8bytes.org>
Date:   Thu Jan 9 13:06:59 2014 +0100

    Merge branches 'arm/smmu', 'core', 'x86/vt-d', 'arm/shmobile', 'x86/amd', 'ppc/pamu', 'iommu/fixes' and 'arm/msm' into next

commit 5b5c13996ff115599e13b719fc7e4c39746d3b30
Author: Upinder Malhi (umalhi) <umalhi@cisco.com>
Date:   Wed Dec 11 20:19:56 2013 +0000

    iommu: Rename domain_has_cap to iommu_domain_has_cap
    
    domain_has_cap is a misnomer bc the func name should be
    the same for CONFIG_IOMMU_API and !CONFIG_IOMMU_API.
    
    Signed-off-by: Upinder Malhi <umalhi@cisco.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index a444c790fa72..8876ef982169 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -291,8 +291,8 @@ static inline phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain, dma_ad
 	return 0;
 }
 
-static inline int domain_has_cap(struct iommu_domain *domain,
-				 unsigned long cap)
+static inline int iommu_domain_has_cap(struct iommu_domain *domain,
+				       unsigned long cap)
 {
 	return 0;
 }

commit b62dfd29eeaf12f8bc79a50f680901e84b351851
Author: Alexey Kardashevskiy <aik@ozlabs.ru>
Date:   Thu Nov 21 17:41:14 2013 +1100

    iommu: Add empty stub for iommu_group_get_by_id()
    
    Almost every function in include/linux/iommu.h has an empty stub
    but the iommu_group_get_by_id() did not get one by mistake.
    
    This adds an empty stub for iommu_group_get_by_id() for IOMMU_API
    disabled config.
    
    Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index a444c790fa72..01ed7345f508 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -247,6 +247,11 @@ static inline struct iommu_domain *iommu_domain_alloc(struct bus_type *bus)
 	return NULL;
 }
 
+static inline struct iommu_group *iommu_group_get_by_id(int id)
+{
+	return NULL;
+}
+
 static inline void iommu_domain_free(struct iommu_domain *domain)
 {
 }

commit ca13bb3d4e54f5c30089e55d5b8f4bb80c8f05e2
Author: Will Deacon <will.deacon@arm.com>
Date:   Tue Nov 5 15:59:53 2013 +0000

    iommu: add IOMMU_EXEC flag for safely allowing XN mappings
    
    Whilst most IOMMU mappings should probably be non-executable, there
    may be cases (HSA?) where executable mappings are required.
    
    This patch introduces a new mapping flag, IOMMU_EXEC, to indicate that
    the mapping should be mapped as executable.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index a444c790fa72..709a697c4e02 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -24,9 +24,10 @@
 #include <linux/types.h>
 #include <trace/events/iommu.h>
 
-#define IOMMU_READ	(1)
-#define IOMMU_WRITE	(2)
-#define IOMMU_CACHE	(4) /* DMA cache coherency */
+#define IOMMU_READ	(1 << 0)
+#define IOMMU_WRITE	(1 << 1)
+#define IOMMU_CACHE	(1 << 2) /* DMA cache coherency */
+#define IOMMU_EXEC	(1 << 3)
 
 struct iommu_ops;
 struct iommu_group;

commit 56fa484969c367e3ae43a012a7b99f75bb4f3bdb
Author: Shuah Khan <shuah.kh@samsung.com>
Date:   Tue Sep 24 15:21:20 2013 -0600

    iommu: Change iommu driver to call io_page_fault trace event
    
    Change iommu driver call io_page_fault trace event. This iommu_error class
    event can be enabled to trigger when an iommu error occurs. Trace information
    includes driver name, device name, iova, and flags.
    
    Testing:
    Added trace calls to iommu_prepare_identity_map() for testing some of the
    conditions that are hard to trigger. Here is the trace from the testing:
    
           swapper/0-1     [003] ....     2.003774: io_page_fault: IOMMU:pci 0000:00:02.0 iova=0x00000000cb800000 flags=0x0002
           swapper/0-1     [003] ....     2.004098: io_page_fault: IOMMU:pci 0000:00:1d.0 iova=0x00000000cadc6000 flags=0x0002
           swapper/0-1     [003] ....     2.004115: io_page_fault: IOMMU:pci 0000:00:1a.0 iova=0x00000000cadc6000 flags=0x0002
           swapper/0-1     [003] ....     2.004129: io_page_fault: IOMMU:pci 0000:00:1f.0 iova=0x0000000000000000 flags=0x0002
    
    Signed-off-by: Shuah Khan <shuah.kh@samsung.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 7ea319e95b47..a444c790fa72 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -22,6 +22,7 @@
 #include <linux/errno.h>
 #include <linux/err.h>
 #include <linux/types.h>
+#include <trace/events/iommu.h>
 
 #define IOMMU_READ	(1)
 #define IOMMU_WRITE	(2)
@@ -227,6 +228,7 @@ static inline int report_iommu_fault(struct iommu_domain *domain,
 		ret = domain->handler(domain, dev, iova, flags,
 						domain->handler_token);
 
+	trace_io_page_fault(dev, iova, flags);
 	return ret;
 }
 

commit 7cabf491eb6d52ea7f166b287702890cae0c803d
Author: Varun Sethi <Varun.Sethi@freescale.com>
Date:   Mon Jul 15 10:20:56 2013 +0530

    iommu/fsl: Add additional iommu attributes required by the PAMU driver.
    
    Added the following domain attributes for the FSL PAMU driver:
    1. Added new iommu stash attribute, which allows setting of the
       LIODN specific stash id parameter through IOMMU API.
    2. Added an attribute for enabling/disabling DMA to a particular
       memory window.
    3. Added domain attribute to check for PAMUV1 specific constraints.
    
    Signed-off-by: Varun Sethi <Varun.Sethi@freescale.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 3aeb7305e2f5..7ea319e95b47 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -58,10 +58,26 @@ struct iommu_domain {
 #define IOMMU_CAP_CACHE_COHERENCY	0x1
 #define IOMMU_CAP_INTR_REMAP		0x2	/* isolates device intrs */
 
+/*
+ * Following constraints are specifc to FSL_PAMUV1:
+ *  -aperture must be power of 2, and naturally aligned
+ *  -number of windows must be power of 2, and address space size
+ *   of each window is determined by aperture size / # of windows
+ *  -the actual size of the mapped region of a window must be power
+ *   of 2 starting with 4KB and physical address must be naturally
+ *   aligned.
+ * DOMAIN_ATTR_FSL_PAMUV1 corresponds to the above mentioned contraints.
+ * The caller can invoke iommu_domain_get_attr to check if the underlying
+ * iommu implementation supports these constraints.
+ */
+
 enum iommu_attr {
 	DOMAIN_ATTR_GEOMETRY,
 	DOMAIN_ATTR_PAGING,
 	DOMAIN_ATTR_WINDOWS,
+	DOMAIN_ATTR_FSL_PAMU_STASH,
+	DOMAIN_ATTR_FSL_PAMU_ENABLE,
+	DOMAIN_ATTR_FSL_PAMUV1,
 	DOMAIN_ATTR_MAX,
 };
 

commit 0c4513be3d01a854867446ee793748409cc0ebdf
Merge: ae3e7f3aba44 83ed9c13e37e 80f97f0f73b8 aa16bea929ae 72ca55dbae81
Author: Joerg Roedel <joro@8bytes.org>
Date:   Thu May 2 12:10:19 2013 +0200

    Merge branches 'iommu/fixes', 'x86/vt-d', 'x86/amd', 'ppc/pamu', 'core' and 'arm/tegra' into next

commit aa16bea929aed6ea854b55d2be8306a9fb40e694
Author: Alexey Kardashevskiy <aik@ozlabs.ru>
Date:   Mon Mar 25 10:23:49 2013 +1100

    iommu: Add a function to find an iommu group by id
    
    As IOMMU groups are exposed to the user space by their numbers,
    the user space can use them in various kernel APIs so the kernel
    might need an API to find a group by its ID.
    
    As an example, QEMU VFIO on PPC64 platform needs it to associate
    a logical bus number (LIOBN) with a specific IOMMU group in order
    to support in-kernel handling of DMA map/unmap requests.
    
    The patch adds the iommu_group_get_by_id(id) function which performs
    such search.
    
    v2: fixed reference counting.
    
    Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Acked-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 6a027dc8dbfe..8e1b5be72b02 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -126,6 +126,7 @@ struct iommu_ops {
 extern int bus_set_iommu(struct bus_type *bus, struct iommu_ops *ops);
 extern bool iommu_present(struct bus_type *bus);
 extern struct iommu_domain *iommu_domain_alloc(struct bus_type *bus);
+extern struct iommu_group *iommu_group_get_by_id(int id);
 extern void iommu_domain_free(struct iommu_domain *domain);
 extern int iommu_attach_device(struct iommu_domain *domain,
 			       struct device *dev);

commit 9a08d3766874835f4eba1b3d66938326c069d817
Author: Wang YanQing <udknight@gmail.com>
Date:   Fri Apr 19 09:38:04 2013 +0800

    iommu: Include linux/err.h
    
    The linux/iommu.h header uses ERR_PTR defined
    in linux/err.h but doesn't include it.
    
    Cc:joro@8bytes.org
    Reviewed-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Wang YanQing <udknight@gmail.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index ba3b8a98a049..6a027dc8dbfe 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -20,6 +20,7 @@
 #define __LINUX_IOMMU_H
 
 #include <linux/errno.h>
+#include <linux/err.h>
 #include <linux/types.h>
 
 #define IOMMU_READ	(1)

commit 80f97f0f73b82444f714651ea053838d27779dca
Author: Varun Sethi <Varun.Sethi@freescale.com>
Date:   Fri Mar 29 01:24:00 2013 +0530

    iommu/fsl: Add the window permission flag as a parameter to iommu_window_enable API.
    
    Each iommu window can have access permissions associated with it. Extended the
    window_enable API to incorporate window access permissions.
    
    In case of PAMU each window can have its specific set of permissions.
    
    Signed-off-by: Varun Sethi <Varun.Sethi@freescale.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index bb0a0fc26729..272781073110 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -104,7 +104,7 @@ struct iommu_ops {
 
 	/* Window handling functions */
 	int (*domain_window_enable)(struct iommu_domain *domain, u32 wnd_nr,
-				    phys_addr_t paddr, u64 size);
+				    phys_addr_t paddr, u64 size, int prot);
 	void (*domain_window_disable)(struct iommu_domain *domain, u32 wnd_nr);
 	/* Set the numer of window per domain */
 	int (*domain_set_windows)(struct iommu_domain *domain, u32 w_count);
@@ -169,7 +169,8 @@ extern int iommu_domain_set_attr(struct iommu_domain *domain, enum iommu_attr,
 
 /* Window handling function prototypes */
 extern int iommu_domain_window_enable(struct iommu_domain *domain, u32 wnd_nr,
-				      phys_addr_t offset, u64 size);
+				      phys_addr_t offset, u64 size,
+				      int prot);
 extern void iommu_domain_window_disable(struct iommu_domain *domain, u32 wnd_nr);
 /**
  * report_iommu_fault() - report about an IOMMU fault to the IOMMU framework
@@ -255,7 +256,7 @@ static inline int iommu_unmap(struct iommu_domain *domain, unsigned long iova,
 
 static inline int iommu_domain_window_enable(struct iommu_domain *domain,
 					     u32 wnd_nr, phys_addr_t paddr,
-					     u64 size)
+					     u64 size, int prot)
 {
 	return -ENODEV;
 }

commit bb5547acfcd842950b8a22aa83f84af93388b9f2
Author: Varun Sethi <Varun.Sethi@freescale.com>
Date:   Fri Mar 29 01:23:58 2013 +0530

    iommu/fsl: Make iova dma_addr_t in the iommu_iova_to_phys API.
    
    This is required in case of PAMU, as it can support a window size of up
    to 64G (even on 32bit).
    
    Signed-off-by: Varun Sethi <Varun.Sethi@freescale.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index ba3b8a98a049..bb0a0fc26729 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -91,8 +91,7 @@ struct iommu_ops {
 		   phys_addr_t paddr, size_t size, int prot);
 	size_t (*unmap)(struct iommu_domain *domain, unsigned long iova,
 		     size_t size);
-	phys_addr_t (*iova_to_phys)(struct iommu_domain *domain,
-				    unsigned long iova);
+	phys_addr_t (*iova_to_phys)(struct iommu_domain *domain, dma_addr_t iova);
 	int (*domain_has_cap)(struct iommu_domain *domain,
 			      unsigned long cap);
 	int (*add_device)(struct device *dev);
@@ -134,8 +133,7 @@ extern int iommu_map(struct iommu_domain *domain, unsigned long iova,
 		     phys_addr_t paddr, size_t size, int prot);
 extern size_t iommu_unmap(struct iommu_domain *domain, unsigned long iova,
 		       size_t size);
-extern phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain,
-				      unsigned long iova);
+extern phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain, dma_addr_t iova);
 extern int iommu_domain_has_cap(struct iommu_domain *domain,
 				unsigned long cap);
 extern void iommu_set_fault_handler(struct iommu_domain *domain,
@@ -267,8 +265,7 @@ static inline void iommu_domain_window_disable(struct iommu_domain *domain,
 {
 }
 
-static inline phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain,
-					     unsigned long iova)
+static inline phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain, dma_addr_t iova)
 {
 	return 0;
 }

commit 693567125bde1966a095267a9d8ca1b8d40f59ee
Author: Joerg Roedel <joro@8bytes.org>
Date:   Mon Feb 4 14:00:01 2013 +0100

    iommu: Add DOMAIN_ATTR_WINDOWS domain attribute
    
    This attribute can be used to set and get the number of
    subwindows on IOMMUs that are window-based.
    
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 5ea3d7250917..ba3b8a98a049 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -60,6 +60,7 @@ struct iommu_domain {
 enum iommu_attr {
 	DOMAIN_ATTR_GEOMETRY,
 	DOMAIN_ATTR_PAGING,
+	DOMAIN_ATTR_WINDOWS,
 	DOMAIN_ATTR_MAX,
 };
 
@@ -106,6 +107,10 @@ struct iommu_ops {
 	int (*domain_window_enable)(struct iommu_domain *domain, u32 wnd_nr,
 				    phys_addr_t paddr, u64 size);
 	void (*domain_window_disable)(struct iommu_domain *domain, u32 wnd_nr);
+	/* Set the numer of window per domain */
+	int (*domain_set_windows)(struct iommu_domain *domain, u32 w_count);
+	/* Get the numer of window per domain */
+	u32 (*domain_get_windows)(struct iommu_domain *domain);
 
 	unsigned long pgsize_bitmap;
 };

commit d7787d579cbef9f8079104759a2259fc916c688c
Author: Joerg Roedel <joro@8bytes.org>
Date:   Tue Jan 29 14:26:20 2013 +0100

    iommu: Add domain window handling functions
    
    Add the iommu_domain_window_enable() and iommu_domain_window_disable()
    functions to the IOMMU-API. These functions will be used to setup
    domains that are based on subwindows and not on paging.
    
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 26066f54a849..5ea3d7250917 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -101,6 +101,12 @@ struct iommu_ops {
 			       enum iommu_attr attr, void *data);
 	int (*domain_set_attr)(struct iommu_domain *domain,
 			       enum iommu_attr attr, void *data);
+
+	/* Window handling functions */
+	int (*domain_window_enable)(struct iommu_domain *domain, u32 wnd_nr,
+				    phys_addr_t paddr, u64 size);
+	void (*domain_window_disable)(struct iommu_domain *domain, u32 wnd_nr);
+
 	unsigned long pgsize_bitmap;
 };
 
@@ -158,6 +164,10 @@ extern int iommu_domain_get_attr(struct iommu_domain *domain, enum iommu_attr,
 extern int iommu_domain_set_attr(struct iommu_domain *domain, enum iommu_attr,
 				 void *data);
 
+/* Window handling function prototypes */
+extern int iommu_domain_window_enable(struct iommu_domain *domain, u32 wnd_nr,
+				      phys_addr_t offset, u64 size);
+extern void iommu_domain_window_disable(struct iommu_domain *domain, u32 wnd_nr);
 /**
  * report_iommu_fault() - report about an IOMMU fault to the IOMMU framework
  * @domain: the iommu domain where the fault has happened
@@ -240,6 +250,18 @@ static inline int iommu_unmap(struct iommu_domain *domain, unsigned long iova,
 	return -ENODEV;
 }
 
+static inline int iommu_domain_window_enable(struct iommu_domain *domain,
+					     u32 wnd_nr, phys_addr_t paddr,
+					     u64 size)
+{
+	return -ENODEV;
+}
+
+static inline void iommu_domain_window_disable(struct iommu_domain *domain,
+					       u32 wnd_nr)
+{
+}
+
 static inline phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain,
 					     unsigned long iova)
 {

commit d2e121601619631517409cba34e50db3cbff5852
Author: Joerg Roedel <joro@8bytes.org>
Date:   Tue Jan 29 13:49:04 2013 +0100

    iommu: Implement DOMAIN_ATTR_PAGING attribute
    
    This attribute of a domain can be queried to find out if the
    domain supports setting up page-tables using the iommu_map()
    and iommu_unmap() functions.
    
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 7e6ce7260b1c..26066f54a849 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -59,6 +59,7 @@ struct iommu_domain {
 
 enum iommu_attr {
 	DOMAIN_ATTR_GEOMETRY,
+	DOMAIN_ATTR_PAGING,
 	DOMAIN_ATTR_MAX,
 };
 

commit a8b8a88a9e3042d41326c854272c881664acba1c
Author: Joerg Roedel <joro@8bytes.org>
Date:   Tue Jan 29 14:36:31 2013 +0100

    iommu: Make sure DOMAIN_ATTR_MAX is really the maximum
    
    Move it to the end of the list.
    
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index f3b99e1c1042..7e6ce7260b1c 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -58,8 +58,8 @@ struct iommu_domain {
 #define IOMMU_CAP_INTR_REMAP		0x2	/* isolates device intrs */
 
 enum iommu_attr {
-	DOMAIN_ATTR_MAX,
 	DOMAIN_ATTR_GEOMETRY,
+	DOMAIN_ATTR_MAX,
 };
 
 #ifdef CONFIG_IOMMU_API

commit bef83de5a0e3031ff6ff9584b458611a7ac01b85
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Mon Sep 24 21:23:25 2012 -0600

    iommu: static inline iommu group stub functions
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 7e83370e6fd2..f3b99e1c1042 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -256,72 +256,78 @@ static inline void iommu_set_fault_handler(struct iommu_domain *domain,
 {
 }
 
-int iommu_attach_group(struct iommu_domain *domain, struct iommu_group *group)
+static inline int iommu_attach_group(struct iommu_domain *domain,
+				     struct iommu_group *group)
 {
 	return -ENODEV;
 }
 
-void iommu_detach_group(struct iommu_domain *domain, struct iommu_group *group)
+static inline void iommu_detach_group(struct iommu_domain *domain,
+				      struct iommu_group *group)
 {
 }
 
-struct iommu_group *iommu_group_alloc(void)
+static inline struct iommu_group *iommu_group_alloc(void)
 {
 	return ERR_PTR(-ENODEV);
 }
 
-void *iommu_group_get_iommudata(struct iommu_group *group)
+static inline void *iommu_group_get_iommudata(struct iommu_group *group)
 {
 	return NULL;
 }
 
-void iommu_group_set_iommudata(struct iommu_group *group, void *iommu_data,
-			       void (*release)(void *iommu_data))
+static inline void iommu_group_set_iommudata(struct iommu_group *group,
+					     void *iommu_data,
+					     void (*release)(void *iommu_data))
 {
 }
 
-int iommu_group_set_name(struct iommu_group *group, const char *name)
+static inline int iommu_group_set_name(struct iommu_group *group,
+				       const char *name)
 {
 	return -ENODEV;
 }
 
-int iommu_group_add_device(struct iommu_group *group, struct device *dev)
+static inline int iommu_group_add_device(struct iommu_group *group,
+					 struct device *dev)
 {
 	return -ENODEV;
 }
 
-void iommu_group_remove_device(struct device *dev)
+static inline void iommu_group_remove_device(struct device *dev)
 {
 }
 
-int iommu_group_for_each_dev(struct iommu_group *group, void *data,
-			     int (*fn)(struct device *, void *))
+static inline int iommu_group_for_each_dev(struct iommu_group *group,
+					   void *data,
+					   int (*fn)(struct device *, void *))
 {
 	return -ENODEV;
 }
 
-struct iommu_group *iommu_group_get(struct device *dev)
+static inline struct iommu_group *iommu_group_get(struct device *dev)
 {
 	return NULL;
 }
 
-void iommu_group_put(struct iommu_group *group)
+static inline void iommu_group_put(struct iommu_group *group)
 {
 }
 
-int iommu_group_register_notifier(struct iommu_group *group,
-				  struct notifier_block *nb)
+static inline int iommu_group_register_notifier(struct iommu_group *group,
+						struct notifier_block *nb)
 {
 	return -ENODEV;
 }
 
-int iommu_group_unregister_notifier(struct iommu_group *group,
-				    struct notifier_block *nb)
+static inline int iommu_group_unregister_notifier(struct iommu_group *group,
+						  struct notifier_block *nb)
 {
 	return 0;
 }
 
-int iommu_group_id(struct iommu_group *group)
+static inline int iommu_group_id(struct iommu_group *group)
 {
 	return -ENODEV;
 }

commit ba1eabfade3272596000bf3c62b68ca375e48b08
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Fri Aug 3 15:55:41 2012 +0200

    iommu: Add missing forward declaration in include file
    
    The 'struct notifier_block' is not used in linux/iommu.h but
    not declared anywhere. Add a forward declaration for it.
    
    Reported-by: Thierry Reding <thierry.reding@avionic-design.de>
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 0a85199191b9..7e83370e6fd2 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -31,6 +31,7 @@ struct iommu_group;
 struct bus_type;
 struct device;
 struct iommu_domain;
+struct notifier_block;
 
 /* iommu fault flags */
 #define IOMMU_FAULT_READ	0x0

commit 76582d0a68ab6c46987dd678165c26ad81c44cdb
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Wed Jul 25 16:24:49 2012 +0200

    iommu: Include linux/types.h
    
    The linux/iommu.h header uses types defined in linux/types.h but doesn't
    include it.
    
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 54d6d690073c..0a85199191b9 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -20,6 +20,7 @@
 #define __LINUX_IOMMU_H
 
 #include <linux/errno.h>
+#include <linux/types.h>
 
 #define IOMMU_READ	(1)
 #define IOMMU_WRITE	(2)

commit 395e51f18d3b26619c1c462b7a1c0226846ac0a9
Merge: 28a33cbc24e4 2c9195e99029 2c0ae1720c09 7d43c2e42cb1 8ce44a2174c3 3177bb76a8c5
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Mon Jul 23 12:17:00 2012 +0200

    Merge branches 'iommu/fixes', 'x86/amd', 'groups', 'arm/tegra' and 'api/domain-attr' into next
    
    Conflicts:
            drivers/iommu/iommu.c
            include/linux/iommu.h

commit 0ff64f80e075ae036a4c80c7d7752b1e07fed792
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Thu Jan 26 19:40:53 2012 +0100

    iommu/amd: Implement DOMAIN_ATTR_GEOMETRY attribute
    
    Implement the attribute itself and add the code for the
    AMD IOMMU driver.
    
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 0eef096183e8..f7df4aa527f3 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -37,11 +37,18 @@ struct iommu_domain;
 typedef int (*iommu_fault_handler_t)(struct iommu_domain *,
 			struct device *, unsigned long, int, void *);
 
+struct iommu_domain_geometry {
+	dma_addr_t aperture_start; /* First address that can be mapped    */
+	dma_addr_t aperture_end;   /* Last address that can be mapped     */
+	bool force_aperture;       /* DMA only allowed in mappable range? */
+};
+
 struct iommu_domain {
 	struct iommu_ops *ops;
 	void *priv;
 	iommu_fault_handler_t handler;
 	void *handler_token;
+	struct iommu_domain_geometry geometry;
 };
 
 #define IOMMU_CAP_CACHE_COHERENCY	0x1
@@ -49,6 +56,7 @@ struct iommu_domain {
 
 enum iommu_attr {
 	DOMAIN_ATTR_MAX,
+	DOMAIN_ATTR_GEOMETRY,
 };
 
 #ifdef CONFIG_IOMMU_API

commit 0cd76dd13bdd2f7f02a2dc931e808e92b191082f
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Thu Jan 26 19:40:52 2012 +0100

    iommu: Add domain-attribute handlers
    
    This patch introduces an extension to the iommu-api to get
    and set attributes for an iommu_domain. Two functions are
    introduced for this:
    
            * iommu_domain_get_attr()
            * iommu_domain_set_attr()
    
    These functions will be used to make the iommu-api suitable
    for GART-like IOMMUs and to implement hardware-specifc
    api-extensions.
    
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 450293f6d68b..0eef096183e8 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -47,6 +47,10 @@ struct iommu_domain {
 #define IOMMU_CAP_CACHE_COHERENCY	0x1
 #define IOMMU_CAP_INTR_REMAP		0x2	/* isolates device intrs */
 
+enum iommu_attr {
+	DOMAIN_ATTR_MAX,
+};
+
 #ifdef CONFIG_IOMMU_API
 
 /**
@@ -59,7 +63,8 @@ struct iommu_domain {
  * @unmap: unmap a physically contiguous memory region from an iommu domain
  * @iova_to_phys: translate iova to physical address
  * @domain_has_cap: domain capabilities query
- * @commit: commit iommu domain
+ * @domain_get_attr: Query domain attributes
+ * @domain_set_attr: Change domain attributes
  * @pgsize_bitmap: bitmap of supported page sizes
  */
 struct iommu_ops {
@@ -76,6 +81,10 @@ struct iommu_ops {
 	int (*domain_has_cap)(struct iommu_domain *domain,
 			      unsigned long cap);
 	int (*device_group)(struct device *dev, unsigned int *groupid);
+	int (*domain_get_attr)(struct iommu_domain *domain,
+			       enum iommu_attr attr, void *data);
+	int (*domain_set_attr)(struct iommu_domain *domain,
+			       enum iommu_attr attr, void *data);
 	unsigned long pgsize_bitmap;
 };
 
@@ -99,6 +108,11 @@ extern void iommu_set_fault_handler(struct iommu_domain *domain,
 			iommu_fault_handler_t handler, void *token);
 extern int iommu_device_group(struct device *dev, unsigned int *groupid);
 
+extern int iommu_domain_get_attr(struct iommu_domain *domain, enum iommu_attr,
+				 void *data);
+extern int iommu_domain_set_attr(struct iommu_domain *domain, enum iommu_attr,
+				 void *data);
+
 /**
  * report_iommu_fault() - report about an IOMMU fault to the IOMMU framework
  * @domain: the iommu domain where the fault has happened
@@ -202,6 +216,18 @@ static inline int iommu_device_group(struct device *dev, unsigned int *groupid)
 	return -ENODEV;
 }
 
+static inline int iommu_domain_get_attr(struct iommu_domain *domain,
+					enum iommu_attr attr, void *data)
+{
+	return -EINVAL;
+}
+
+static inline int iommu_domain_set_attr(struct iommu_domain *domain,
+					enum iommu_attr attr, void *data)
+{
+	return -EINVAL;
+}
+
 #endif /* CONFIG_IOMMU_API */
 
 #endif /* __LINUX_IOMMU_H */

commit d72e31c9374627068df29da8085ca18c92ae35d3
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Wed May 30 14:18:53 2012 -0600

    iommu: IOMMU Groups
    
    IOMMU device groups are currently a rather vague associative notion
    with assembly required by the user or user level driver provider to
    do anything useful.  This patch intends to grow the IOMMU group concept
    into something a bit more consumable.
    
    To do this, we first create an object representing the group, struct
    iommu_group.  This structure is allocated (iommu_group_alloc) and
    filled (iommu_group_add_device) by the iommu driver.  The iommu driver
    is free to add devices to the group using it's own set of policies.
    This allows inclusion of devices based on physical hardware or topology
    limitations of the platform, as well as soft requirements, such as
    multi-function trust levels or peer-to-peer protection of the
    interconnects.  Each device may only belong to a single iommu group,
    which is linked from struct device.iommu_group.  IOMMU groups are
    maintained using kobject reference counting, allowing for automatic
    removal of empty, unreferenced groups.  It is the responsibility of
    the iommu driver to remove devices from the group
    (iommu_group_remove_device).
    
    IOMMU groups also include a userspace representation in sysfs under
    /sys/kernel/iommu_groups.  When allocated, each group is given a
    dynamically assign ID (int).  The ID is managed by the core IOMMU group
    code to support multiple heterogeneous iommu drivers, which could
    potentially collide in group naming/numbering.  This also keeps group
    IDs to small, easily managed values.  A directory is created under
    /sys/kernel/iommu_groups for each group.  A further subdirectory named
    "devices" contains links to each device within the group.  The iommu_group
    file in the device's sysfs directory, which formerly contained a group
    number when read, is now a link to the iommu group.  Example:
    
    $ ls -l /sys/kernel/iommu_groups/26/devices/
    total 0
    lrwxrwxrwx. 1 root root 0 Apr 17 12:57 0000:00:1e.0 ->
                    ../../../../devices/pci0000:00/0000:00:1e.0
    lrwxrwxrwx. 1 root root 0 Apr 17 12:57 0000:06:0d.0 ->
                    ../../../../devices/pci0000:00/0000:00:1e.0/0000:06:0d.0
    lrwxrwxrwx. 1 root root 0 Apr 17 12:57 0000:06:0d.1 ->
                    ../../../../devices/pci0000:00/0000:00:1e.0/0000:06:0d.1
    
    $ ls -l  /sys/kernel/iommu_groups/26/devices/*/iommu_group
    [truncating perms/owner/timestamp]
    /sys/kernel/iommu_groups/26/devices/0000:00:1e.0/iommu_group ->
                                            ../../../kernel/iommu_groups/26
    /sys/kernel/iommu_groups/26/devices/0000:06:0d.0/iommu_group ->
                                            ../../../../kernel/iommu_groups/26
    /sys/kernel/iommu_groups/26/devices/0000:06:0d.1/iommu_group ->
                                            ../../../../kernel/iommu_groups/26
    
    Groups also include several exported functions for use by user level
    driver providers, for example VFIO.  These include:
    
    iommu_group_get(): Acquires a reference to a group from a device
    iommu_group_put(): Releases reference
    iommu_group_for_each_dev(): Iterates over group devices using callback
    iommu_group_[un]register_notifier(): Allows notification of device add
            and remove operations relevant to the group
    iommu_group_id(): Return the group number
    
    This patch also extends the IOMMU API to allow attaching groups to
    domains.  This is currently a simple wrapper for iterating through
    devices within a group, but it's expected that the IOMMU API may
    eventually make groups a more integral part of domains.
    
    Groups intentionally do not try to manage group ownership.  A user
    level driver provider must independently acquire ownership for each
    device within a group before making use of the group as a whole.
    This may change in the future if group usage becomes more pervasive
    across both DMA and IOMMU ops.
    
    Groups intentionally do not provide a mechanism for driver locking
    or otherwise manipulating driver matching/probing of devices within
    the group.  Such interfaces are generic to devices and beyond the
    scope of IOMMU groups.  If implemented, user level providers have
    ready access via iommu_group_for_each_dev and group notifiers.
    
    iommu_device_group() is removed here as it has no users.  The
    replacement is:
    
            group = iommu_group_get(dev);
            id = iommu_group_id(group);
            iommu_group_put(group);
    
    AMD-Vi & Intel VT-d support re-added in following patches.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 450293f6d68b..a71df92be992 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -26,6 +26,7 @@
 #define IOMMU_CACHE	(4) /* DMA cache coherency */
 
 struct iommu_ops;
+struct iommu_group;
 struct bus_type;
 struct device;
 struct iommu_domain;
@@ -60,6 +61,8 @@ struct iommu_domain {
  * @iova_to_phys: translate iova to physical address
  * @domain_has_cap: domain capabilities query
  * @commit: commit iommu domain
+ * @add_device: add device to iommu grouping
+ * @remove_device: remove device from iommu grouping
  * @pgsize_bitmap: bitmap of supported page sizes
  */
 struct iommu_ops {
@@ -75,10 +78,18 @@ struct iommu_ops {
 				    unsigned long iova);
 	int (*domain_has_cap)(struct iommu_domain *domain,
 			      unsigned long cap);
-	int (*device_group)(struct device *dev, unsigned int *groupid);
+	int (*add_device)(struct device *dev);
+	void (*remove_device)(struct device *dev);
 	unsigned long pgsize_bitmap;
 };
 
+#define IOMMU_GROUP_NOTIFY_ADD_DEVICE		1 /* Device added */
+#define IOMMU_GROUP_NOTIFY_DEL_DEVICE		2 /* Pre Device removed */
+#define IOMMU_GROUP_NOTIFY_BIND_DRIVER		3 /* Pre Driver bind */
+#define IOMMU_GROUP_NOTIFY_BOUND_DRIVER		4 /* Post Driver bind */
+#define IOMMU_GROUP_NOTIFY_UNBIND_DRIVER	5 /* Pre Driver unbind */
+#define IOMMU_GROUP_NOTIFY_UNBOUND_DRIVER	6 /* Post Driver unbind */
+
 extern int bus_set_iommu(struct bus_type *bus, struct iommu_ops *ops);
 extern bool iommu_present(struct bus_type *bus);
 extern struct iommu_domain *iommu_domain_alloc(struct bus_type *bus);
@@ -97,7 +108,29 @@ extern int iommu_domain_has_cap(struct iommu_domain *domain,
 				unsigned long cap);
 extern void iommu_set_fault_handler(struct iommu_domain *domain,
 			iommu_fault_handler_t handler, void *token);
-extern int iommu_device_group(struct device *dev, unsigned int *groupid);
+
+extern int iommu_attach_group(struct iommu_domain *domain,
+			      struct iommu_group *group);
+extern void iommu_detach_group(struct iommu_domain *domain,
+			       struct iommu_group *group);
+extern struct iommu_group *iommu_group_alloc(void);
+extern void *iommu_group_get_iommudata(struct iommu_group *group);
+extern void iommu_group_set_iommudata(struct iommu_group *group,
+				      void *iommu_data,
+				      void (*release)(void *iommu_data));
+extern int iommu_group_set_name(struct iommu_group *group, const char *name);
+extern int iommu_group_add_device(struct iommu_group *group,
+				  struct device *dev);
+extern void iommu_group_remove_device(struct device *dev);
+extern int iommu_group_for_each_dev(struct iommu_group *group, void *data,
+				    int (*fn)(struct device *, void *));
+extern struct iommu_group *iommu_group_get(struct device *dev);
+extern void iommu_group_put(struct iommu_group *group);
+extern int iommu_group_register_notifier(struct iommu_group *group,
+					 struct notifier_block *nb);
+extern int iommu_group_unregister_notifier(struct iommu_group *group,
+					   struct notifier_block *nb);
+extern int iommu_group_id(struct iommu_group *group);
 
 /**
  * report_iommu_fault() - report about an IOMMU fault to the IOMMU framework
@@ -142,6 +175,7 @@ static inline int report_iommu_fault(struct iommu_domain *domain,
 #else /* CONFIG_IOMMU_API */
 
 struct iommu_ops {};
+struct iommu_group {};
 
 static inline bool iommu_present(struct bus_type *bus)
 {
@@ -197,11 +231,75 @@ static inline void iommu_set_fault_handler(struct iommu_domain *domain,
 {
 }
 
-static inline int iommu_device_group(struct device *dev, unsigned int *groupid)
+int iommu_attach_group(struct iommu_domain *domain, struct iommu_group *group)
+{
+	return -ENODEV;
+}
+
+void iommu_detach_group(struct iommu_domain *domain, struct iommu_group *group)
+{
+}
+
+struct iommu_group *iommu_group_alloc(void)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+void *iommu_group_get_iommudata(struct iommu_group *group)
+{
+	return NULL;
+}
+
+void iommu_group_set_iommudata(struct iommu_group *group, void *iommu_data,
+			       void (*release)(void *iommu_data))
+{
+}
+
+int iommu_group_set_name(struct iommu_group *group, const char *name)
+{
+	return -ENODEV;
+}
+
+int iommu_group_add_device(struct iommu_group *group, struct device *dev)
+{
+	return -ENODEV;
+}
+
+void iommu_group_remove_device(struct device *dev)
+{
+}
+
+int iommu_group_for_each_dev(struct iommu_group *group, void *data,
+			     int (*fn)(struct device *, void *))
+{
+	return -ENODEV;
+}
+
+struct iommu_group *iommu_group_get(struct device *dev)
+{
+	return NULL;
+}
+
+void iommu_group_put(struct iommu_group *group)
+{
+}
+
+int iommu_group_register_notifier(struct iommu_group *group,
+				  struct notifier_block *nb)
 {
 	return -ENODEV;
 }
 
+int iommu_group_unregister_notifier(struct iommu_group *group,
+				    struct notifier_block *nb)
+{
+	return 0;
+}
+
+int iommu_group_id(struct iommu_group *group)
+{
+	return -ENODEV;
+}
 #endif /* CONFIG_IOMMU_API */
 
 #endif /* __LINUX_IOMMU_H */

commit 77ca23323594589ac8cba1c8d59bfe7e85d3cb8b
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Mon May 21 20:20:05 2012 +0300

    iommu/core: pass a user-provided token to fault handlers
    
    Sometimes a single IOMMU user may have to deal with several
    different IOMMU devices (e.g. remoteproc).
    
    When an IOMMU fault happens, such users have to regain their
    context in order to deal with the fault.
    
    Users can't use the private fields of neither the iommu_domain nor
    the IOMMU device, because those are already used by the IOMMU core
    and low level driver (respectively).
    
    This patch just simply allows users to pass a private token (most
    notably their own context pointer) to iommu_set_fault_handler(),
    and then makes sure it is provided back to the users whenever
    an IOMMU fault happens.
    
    The patch also adopts remoteproc to the new fault handling
    interface, but the real functionality using this (recovery of
    remote processors) will only be added later in a subsequent patch
    set.
    
    Cc: Fernando Guzman Lugo <fernando.lugo@ti.com>
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index d937580417ba..450293f6d68b 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -35,12 +35,13 @@ struct iommu_domain;
 #define IOMMU_FAULT_WRITE	0x1
 
 typedef int (*iommu_fault_handler_t)(struct iommu_domain *,
-				struct device *, unsigned long, int);
+			struct device *, unsigned long, int, void *);
 
 struct iommu_domain {
 	struct iommu_ops *ops;
 	void *priv;
 	iommu_fault_handler_t handler;
+	void *handler_token;
 };
 
 #define IOMMU_CAP_CACHE_COHERENCY	0x1
@@ -95,7 +96,7 @@ extern phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain,
 extern int iommu_domain_has_cap(struct iommu_domain *domain,
 				unsigned long cap);
 extern void iommu_set_fault_handler(struct iommu_domain *domain,
-					iommu_fault_handler_t handler);
+			iommu_fault_handler_t handler, void *token);
 extern int iommu_device_group(struct device *dev, unsigned int *groupid);
 
 /**
@@ -132,7 +133,8 @@ static inline int report_iommu_fault(struct iommu_domain *domain,
 	 * invoke it.
 	 */
 	if (domain->handler)
-		ret = domain->handler(domain, dev, iova, flags);
+		ret = domain->handler(domain, dev, iova, flags,
+						domain->handler_token);
 
 	return ret;
 }
@@ -191,7 +193,7 @@ static inline int domain_has_cap(struct iommu_domain *domain,
 }
 
 static inline void iommu_set_fault_handler(struct iommu_domain *domain,
-					iommu_fault_handler_t handler)
+				iommu_fault_handler_t handler, void *token)
 {
 }
 

commit f93ea733878733f3e98475bc3e2ccf789bebcfb8
Merge: 00fb5430f547 95bdaf71ccf2
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Mon Jan 9 13:06:28 2012 +0100

    Merge branches 'iommu/page-sizes' and 'iommu/group-id' into next
    
    Conflicts:
            drivers/iommu/amd_iommu.c
            drivers/iommu/intel-iommu.c
            include/linux/iommu.h

commit 95bdaf71ccf2cb4bba0c9a3d2baea0e7916f466b
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Tue Nov 15 12:48:29 2011 +0100

    iommu: Fix compile error with !IOMMU_API
    
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 93617e7779a1..0f318fd549be 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -181,7 +181,7 @@ static inline void iommu_set_fault_handler(struct iommu_domain *domain,
 {
 }
 
-static inline int iommu_device_group(struct device *dev, unsigned int *groupid);
+static inline int iommu_device_group(struct device *dev, unsigned int *groupid)
 {
 	return -ENODEV;
 }

commit 1460432cb513f0c16136ed132c20ecfbf8ccf942
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Fri Oct 21 15:56:05 2011 -0400

    iommu: Add iommu_device_group callback and iommu_group sysfs entry
    
    An IOMMU group is a set of devices for which the IOMMU cannot
    distinguish transactions.  For PCI devices, a group often occurs
    when a PCI bridge is involved.  Transactions from any device
    behind the bridge appear to be sourced from the bridge itself.
    We leave it to the IOMMU driver to define the grouping restraints
    for their platform.
    
    Using this new interface, the group for a device can be retrieved
    using the iommu_device_group() callback.  Users will compare the
    value returned against the value returned for other devices to
    determine whether they are part of the same group.  Devices with
    no group are not translated by the IOMMU.  There should be no
    expectations about the group numbers as they may be arbitrarily
    assigned by the IOMMU driver and may not be persistent across boots.
    
    We also provide a sysfs interface to the group numbers here so
    that userspace can understand IOMMU dependencies between devices
    for managing safe, userspace drivers.
    
    [Some code changes by Joerg Roedel <joerg.roedel@amd.com>]
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 432acc4c054d..93617e7779a1 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -61,6 +61,7 @@ struct iommu_ops {
 				    unsigned long iova);
 	int (*domain_has_cap)(struct iommu_domain *domain,
 			      unsigned long cap);
+	int (*device_group)(struct device *dev, unsigned int *groupid);
 };
 
 extern int bus_set_iommu(struct bus_type *bus, struct iommu_ops *ops);
@@ -81,6 +82,7 @@ extern int iommu_domain_has_cap(struct iommu_domain *domain,
 				unsigned long cap);
 extern void iommu_set_fault_handler(struct iommu_domain *domain,
 					iommu_fault_handler_t handler);
+extern int iommu_device_group(struct device *dev, unsigned int *groupid);
 
 /**
  * report_iommu_fault() - report about an IOMMU fault to the IOMMU framework
@@ -179,6 +181,11 @@ static inline void iommu_set_fault_handler(struct iommu_domain *domain,
 {
 }
 
+static inline int iommu_device_group(struct device *dev, unsigned int *groupid);
+{
+	return -ENODEV;
+}
+
 #endif /* CONFIG_IOMMU_API */
 
 #endif /* __LINUX_IOMMU_H */

commit 7d3002cc8c160dbda0e6ab9cd66dc6eb401b8b70
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Thu Nov 10 11:32:26 2011 +0200

    iommu/core: split mapping to page sizes as supported by the hardware
    
    When mapping a memory region, split it to page sizes as supported
    by the iommu hardware. Always prefer bigger pages, when possible,
    in order to reduce the TLB pressure.
    
    The logic to do that is now added to the IOMMU core, so neither the iommu
    drivers themselves nor users of the IOMMU API have to duplicate it.
    
    This allows a more lenient granularity of mappings; traditionally the
    IOMMU API took 'order' (of a page) as a mapping size, and directly let
    the low level iommu drivers handle the mapping, but now that the IOMMU
    core can split arbitrary memory regions into pages, we can remove this
    limitation, so users don't have to split those regions by themselves.
    
    Currently the supported page sizes are advertised once and they then
    remain static. That works well for OMAP and MSM but it would probably
    not fly well with intel's hardware, where the page size capabilities
    seem to have the potential to be different between several DMA
    remapping devices.
    
    register_iommu() currently sets a default pgsize behavior, so we can convert
    the IOMMU drivers in subsequent patches. After all the drivers
    are converted, the temporary default settings will be removed.
    
    Mainline users of the IOMMU API (kvm and omap-iovmm) are adopted
    to deal with bytes instead of page order.
    
    Many thanks to Joerg Roedel <Joerg.Roedel@amd.com> for significant review!
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Cc: David Brown <davidb@codeaurora.org>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Joerg Roedel <Joerg.Roedel@amd.com>
    Cc: Stepan Moskovchenko <stepanm@codeaurora.org>
    Cc: KyongHo Cho <pullip.cho@samsung.com>
    Cc: Hiroshi DOYU <hdoyu@nvidia.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: kvm@vger.kernel.org
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index d5ebf3f4dd53..cc26f89c4ee6 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -48,6 +48,19 @@ struct iommu_domain {
 
 #ifdef CONFIG_IOMMU_API
 
+/**
+ * struct iommu_ops - iommu ops and capabilities
+ * @domain_init: init iommu domain
+ * @domain_destroy: destroy iommu domain
+ * @attach_dev: attach device to an iommu domain
+ * @detach_dev: detach device from an iommu domain
+ * @map: map a physically contiguous memory region to an iommu domain
+ * @unmap: unmap a physically contiguous memory region from an iommu domain
+ * @iova_to_phys: translate iova to physical address
+ * @domain_has_cap: domain capabilities query
+ * @commit: commit iommu domain
+ * @pgsize_bitmap: bitmap of supported page sizes
+ */
 struct iommu_ops {
 	int (*domain_init)(struct iommu_domain *domain);
 	void (*domain_destroy)(struct iommu_domain *domain);
@@ -61,6 +74,7 @@ struct iommu_ops {
 				    unsigned long iova);
 	int (*domain_has_cap)(struct iommu_domain *domain,
 			      unsigned long cap);
+	unsigned long pgsize_bitmap;
 };
 
 extern int bus_set_iommu(struct bus_type *bus, struct iommu_ops *ops);
@@ -72,9 +86,9 @@ extern int iommu_attach_device(struct iommu_domain *domain,
 extern void iommu_detach_device(struct iommu_domain *domain,
 				struct device *dev);
 extern int iommu_map(struct iommu_domain *domain, unsigned long iova,
-		     phys_addr_t paddr, int gfp_order, int prot);
-extern int iommu_unmap(struct iommu_domain *domain, unsigned long iova,
-		       int gfp_order);
+		     phys_addr_t paddr, size_t size, int prot);
+extern size_t iommu_unmap(struct iommu_domain *domain, unsigned long iova,
+		       size_t size);
 extern phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain,
 				      unsigned long iova);
 extern int iommu_domain_has_cap(struct iommu_domain *domain,

commit 5009065d38c95455bd2d27c2838313e3dd0c5bc7
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Thu Nov 10 11:32:25 2011 +0200

    iommu/core: stop converting bytes to page order back and forth
    
    Express sizes in bytes rather than in page order, to eliminate the
    size->order->size conversions we have whenever the IOMMU API is calling
    the low level drivers' map/unmap methods.
    
    Adopt all existing drivers.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Cc: David Brown <davidb@codeaurora.org>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Joerg Roedel <Joerg.Roedel@amd.com>
    Cc: Stepan Moskovchenko <stepanm@codeaurora.org>
    Cc: KyongHo Cho <pullip.cho@samsung.com>
    Cc: Hiroshi DOYU <hdoyu@nvidia.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 432acc4c054d..d5ebf3f4dd53 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -54,9 +54,9 @@ struct iommu_ops {
 	int (*attach_dev)(struct iommu_domain *domain, struct device *dev);
 	void (*detach_dev)(struct iommu_domain *domain, struct device *dev);
 	int (*map)(struct iommu_domain *domain, unsigned long iova,
-		   phys_addr_t paddr, int gfp_order, int prot);
-	int (*unmap)(struct iommu_domain *domain, unsigned long iova,
-		     int gfp_order);
+		   phys_addr_t paddr, size_t size, int prot);
+	size_t (*unmap)(struct iommu_domain *domain, unsigned long iova,
+		     size_t size);
 	phys_addr_t (*iova_to_phys)(struct iommu_domain *domain,
 				    unsigned long iova);
 	int (*domain_has_cap)(struct iommu_domain *domain,

commit 1abb4ba596a91a839f82e0c9c837b777d574e83d
Merge: 899e3ee40496 fcd0861db1cf e4efd94bde1a 0ed6d2d27bcc 94441c3bd992
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Fri Oct 21 14:38:55 2011 +0200

    Merge branches 'amd/fixes', 'debug/dma-api', 'arm/omap', 'arm/msm', 'core', 'iommu/fault-reporting' and 'api/iommu-ops-per-bus' into next
    
    Conflicts:
            drivers/iommu/amd_iommu.c
            drivers/iommu/iommu.c

commit 94441c3bd99287b9d84f148a08cc9a44675ec749
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Tue Sep 6 18:58:54 2011 +0200

    iommu/core: Remove global iommu_ops and register_iommu
    
    With all IOMMU drivers being converted to bus_set_iommu the
    global iommu_ops are no longer required. The same is true
    for the deprecated register_iommu function.
    
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index f56e559442a2..609ebf6bbe0c 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -54,7 +54,6 @@ struct iommu_ops {
 			      unsigned long cap);
 };
 
-extern void register_iommu(struct iommu_ops *ops);
 extern int bus_set_iommu(struct bus_type *bus, struct iommu_ops *ops);
 extern bool iommu_present(struct bus_type *bus);
 extern struct iommu_domain *iommu_domain_alloc(struct bus_type *bus);

commit a1b60c1cd913c5ccfb38c717ba0bd22622425fa7
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Tue Sep 6 18:46:34 2011 +0200

    iommu/core: Convert iommu_found to iommu_present
    
    With per-bus iommu_ops the iommu_found function needs to
    work on a bus_type too. This patch adds a bus_type parameter
    to that function and converts all call-places.
    The function is also renamed to iommu_present because the
    function now checks if an iommu is present for a given bus
    and does not check for a global iommu anymore.
    
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index c78d068930b7..f56e559442a2 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -56,7 +56,7 @@ struct iommu_ops {
 
 extern void register_iommu(struct iommu_ops *ops);
 extern int bus_set_iommu(struct bus_type *bus, struct iommu_ops *ops);
-extern bool iommu_found(void);
+extern bool iommu_present(struct bus_type *bus);
 extern struct iommu_domain *iommu_domain_alloc(struct bus_type *bus);
 extern void iommu_domain_free(struct iommu_domain *domain);
 extern int iommu_attach_device(struct iommu_domain *domain,
@@ -76,7 +76,7 @@ extern int iommu_domain_has_cap(struct iommu_domain *domain,
 
 struct iommu_ops {};
 
-static inline bool iommu_found(void)
+static inline bool iommu_present(struct bus_type *bus)
 {
 	return false;
 }

commit 905d66c1e5dc8149e111f04a32bb193f25da1d53
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Tue Sep 6 16:03:26 2011 +0200

    iommu/core: Add bus_type parameter to iommu_domain_alloc
    
    This is necessary to store a pointer to the bus-specific
    iommu_ops in the iommu-domain structure. It will be used
    later to call into bus-specific iommu-ops.
    
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index dca83d3405b1..c78d068930b7 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -25,10 +25,12 @@
 #define IOMMU_WRITE	(2)
 #define IOMMU_CACHE	(4) /* DMA cache coherency */
 
+struct iommu_ops;
 struct bus_type;
 struct device;
 
 struct iommu_domain {
+	struct iommu_ops *ops;
 	void *priv;
 };
 
@@ -55,7 +57,7 @@ struct iommu_ops {
 extern void register_iommu(struct iommu_ops *ops);
 extern int bus_set_iommu(struct bus_type *bus, struct iommu_ops *ops);
 extern bool iommu_found(void);
-extern struct iommu_domain *iommu_domain_alloc(void);
+extern struct iommu_domain *iommu_domain_alloc(struct bus_type *bus);
 extern void iommu_domain_free(struct iommu_domain *domain);
 extern int iommu_attach_device(struct iommu_domain *domain,
 			       struct device *dev);
@@ -79,7 +81,7 @@ static inline bool iommu_found(void)
 	return false;
 }
 
-static inline struct iommu_domain *iommu_domain_alloc(void)
+static inline struct iommu_domain *iommu_domain_alloc(struct bus_type *bus)
 {
 	return NULL;
 }

commit ff21776d12ff7993a6b236b8273ef62777d25dfb
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Fri Aug 26 16:48:26 2011 +0200

    Driver core: Add iommu_ops to bus_type
    
    This is the starting point to make the iommu_ops used for
    the iommu-api a per-bus-type structure. It is required to
    easily implement bus-specific setup in the iommu-layer.
    The first user will be the iommu-group attribute in sysfs.
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 6470cd87b4ea..dca83d3405b1 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -25,6 +25,7 @@
 #define IOMMU_WRITE	(2)
 #define IOMMU_CACHE	(4) /* DMA cache coherency */
 
+struct bus_type;
 struct device;
 
 struct iommu_domain {
@@ -52,6 +53,7 @@ struct iommu_ops {
 };
 
 extern void register_iommu(struct iommu_ops *ops);
+extern int bus_set_iommu(struct bus_type *bus, struct iommu_ops *ops);
 extern bool iommu_found(void);
 extern struct iommu_domain *iommu_domain_alloc(void);
 extern void iommu_domain_free(struct iommu_domain *domain);

commit 39d4ebb95925046863dc0ef2698dfcf2c1f1dcbe
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Tue Sep 6 16:48:40 2011 +0200

    iommu/core: Define iommu_ops and register_iommu only with CONFIG_IOMMU_API
    
    This makes it impossible to compile an iommu driver into the
    kernel without selecting CONFIG_IOMMU_API.
    
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 9940319d6f9d..6470cd87b4ea 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -34,6 +34,8 @@ struct iommu_domain {
 #define IOMMU_CAP_CACHE_COHERENCY	0x1
 #define IOMMU_CAP_INTR_REMAP		0x2	/* isolates device intrs */
 
+#ifdef CONFIG_IOMMU_API
+
 struct iommu_ops {
 	int (*domain_init)(struct iommu_domain *domain);
 	void (*domain_destroy)(struct iommu_domain *domain);
@@ -49,8 +51,6 @@ struct iommu_ops {
 			      unsigned long cap);
 };
 
-#ifdef CONFIG_IOMMU_API
-
 extern void register_iommu(struct iommu_ops *ops);
 extern bool iommu_found(void);
 extern struct iommu_domain *iommu_domain_alloc(void);
@@ -70,9 +70,7 @@ extern int iommu_domain_has_cap(struct iommu_domain *domain,
 
 #else /* CONFIG_IOMMU_API */
 
-static inline void register_iommu(struct iommu_ops *ops)
-{
-}
+struct iommu_ops {};
 
 static inline bool iommu_found(void)
 {

commit 0ed6d2d27bcc2ace454a8c55446e1bc3efd2d529
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Tue Sep 27 07:36:40 2011 -0400

    iommu/core: let drivers know if an iommu fault handler isn't installed
    
    Make report_iommu_fault() return -ENOSYS whenever an iommu fault
    handler isn't installed, so IOMMU drivers can then do their own
    platform-specific default behavior if they wanted.
    
    Fault handlers can still return -ENOSYS in case they want to elicit the
    default behavior of the IOMMU drivers.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index d084e8777e0e..ddad0ae0a433 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -98,11 +98,15 @@ extern void iommu_set_fault_handler(struct iommu_domain *domain,
  * Returns 0 on success and an appropriate error code otherwise (if dynamic
  * PTE/TLB loading will one day be supported, implementations will be able
  * to tell whether it succeeded or not according to this return value).
+ *
+ * Specifically, -ENOSYS is returned if a fault handler isn't installed
+ * (though fault handlers can also return -ENOSYS, in case they want to
+ * elicit the default behavior of the IOMMU drivers).
  */
 static inline int report_iommu_fault(struct iommu_domain *domain,
 		struct device *dev, unsigned long iova, int flags)
 {
-	int ret = 0;
+	int ret = -ENOSYS;
 
 	/*
 	 * if upper layers showed interest and installed a fault handler,

commit 4f3f8d9db359bbc780d482849f2a9c8b12f910b6
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Tue Sep 13 15:25:23 2011 -0400

    iommu/core: Add fault reporting mechanism
    
    Add iommu fault report mechanism to the IOMMU API, so implementations
    could report about mmu faults (translation errors, hardware errors,
    etc..).
    
    Fault reports can be used in several ways:
    - mere logging
    - reset the device that accessed the faulting address (may be necessary
      in case the device is a remote processor for example)
    - implement dynamic PTE/TLB loading
    
    A dedicated iommu_set_fault_handler() API has been added to allow
    users, who are interested to receive such reports, to provide
    their handler.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 9940319d6f9d..d084e8777e0e 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -26,9 +26,18 @@
 #define IOMMU_CACHE	(4) /* DMA cache coherency */
 
 struct device;
+struct iommu_domain;
+
+/* iommu fault flags */
+#define IOMMU_FAULT_READ	0x0
+#define IOMMU_FAULT_WRITE	0x1
+
+typedef int (*iommu_fault_handler_t)(struct iommu_domain *,
+				struct device *, unsigned long, int);
 
 struct iommu_domain {
 	void *priv;
+	iommu_fault_handler_t handler;
 };
 
 #define IOMMU_CAP_CACHE_COHERENCY	0x1
@@ -67,6 +76,43 @@ extern phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain,
 				      unsigned long iova);
 extern int iommu_domain_has_cap(struct iommu_domain *domain,
 				unsigned long cap);
+extern void iommu_set_fault_handler(struct iommu_domain *domain,
+					iommu_fault_handler_t handler);
+
+/**
+ * report_iommu_fault() - report about an IOMMU fault to the IOMMU framework
+ * @domain: the iommu domain where the fault has happened
+ * @dev: the device where the fault has happened
+ * @iova: the faulting address
+ * @flags: mmu fault flags (e.g. IOMMU_FAULT_READ/IOMMU_FAULT_WRITE/...)
+ *
+ * This function should be called by the low-level IOMMU implementations
+ * whenever IOMMU faults happen, to allow high-level users, that are
+ * interested in such events, to know about them.
+ *
+ * This event may be useful for several possible use cases:
+ * - mere logging of the event
+ * - dynamic TLB/PTE loading
+ * - if restarting of the faulting device is required
+ *
+ * Returns 0 on success and an appropriate error code otherwise (if dynamic
+ * PTE/TLB loading will one day be supported, implementations will be able
+ * to tell whether it succeeded or not according to this return value).
+ */
+static inline int report_iommu_fault(struct iommu_domain *domain,
+		struct device *dev, unsigned long iova, int flags)
+{
+	int ret = 0;
+
+	/*
+	 * if upper layers showed interest and installed a fault handler,
+	 * invoke it.
+	 */
+	if (domain->handler)
+		ret = domain->handler(domain, dev, iova, flags);
+
+	return ret;
+}
 
 #else /* CONFIG_IOMMU_API */
 
@@ -123,6 +169,11 @@ static inline int domain_has_cap(struct iommu_domain *domain,
 	return 0;
 }
 
+static inline void iommu_set_fault_handler(struct iommu_domain *domain,
+					iommu_fault_handler_t handler)
+{
+}
+
 #endif /* CONFIG_IOMMU_API */
 
 #endif /* __LINUX_IOMMU_H */

commit 74315cccd2104a953f493acca2c6b0519d6f5c6f
Author: Laura Abbott <lauraa@codeaurora.org>
Date:   Wed Jun 8 17:29:11 2011 -0400

    iommu-api: Add missing header file
    
    If CONFIG_IOMMU_API is not defined some functions will just
    return -ENODEV. Add errno.h for the definition of ENODEV.
    
    Signed-off-by: Laura Abbott <lauraa@codeaurora.org>
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 0a2ba4098996..9940319d6f9d 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -19,6 +19,8 @@
 #ifndef __LINUX_IOMMU_H
 #define __LINUX_IOMMU_H
 
+#include <linux/errno.h>
+
 #define IOMMU_READ	(1)
 #define IOMMU_WRITE	(2)
 #define IOMMU_CACHE	(4) /* DMA cache coherency */

commit 323f99cbc35c52a65dea9d072b3ecf1e662240d2
Author: Tom Lyon <pugs@cisco.com>
Date:   Fri Jul 2 16:56:14 2010 -0400

    iommu-api: Extension to check for interrupt remapping
    
    This patch allows IOMMU users to determine whether the
    hardware and software support safe, isolated interrupt
    remapping.  Not all Intel IOMMUs have the hardware, and the
    software for AMD is not there yet.
    
    Signed-off-by: Tom Lyon <pugs@cisco.com>
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index be22ad83689c..0a2ba4098996 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -30,6 +30,7 @@ struct iommu_domain {
 };
 
 #define IOMMU_CAP_CACHE_COHERENCY	0x1
+#define IOMMU_CAP_INTR_REMAP		0x2	/* isolates device intrs */
 
 struct iommu_ops {
 	int (*domain_init)(struct iommu_domain *domain);

commit 12c7389abe5786349d3ea6da1961cf78d0c1c7cd
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Thu Jan 21 11:50:28 2010 +0100

    iommu-api: Remove iommu_{un}map_range functions
    
    These functions are not longer used and can be removed
    savely. There functionality is now provided by the
    iommu_{un}map functions which are also capable of multiple
    page sizes.
    
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 5a7a3d888dac..be22ad83689c 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -40,10 +40,6 @@ struct iommu_ops {
 		   phys_addr_t paddr, int gfp_order, int prot);
 	int (*unmap)(struct iommu_domain *domain, unsigned long iova,
 		     int gfp_order);
-	int (*map_range)(struct iommu_domain *domain, unsigned long iova,
-			 phys_addr_t paddr, size_t size, int prot);
-	void (*unmap_range)(struct iommu_domain *domain, unsigned long iova,
-			    size_t size);
 	phys_addr_t (*iova_to_phys)(struct iommu_domain *domain,
 				    unsigned long iova);
 	int (*domain_has_cap)(struct iommu_domain *domain,
@@ -60,10 +56,6 @@ extern int iommu_attach_device(struct iommu_domain *domain,
 			       struct device *dev);
 extern void iommu_detach_device(struct iommu_domain *domain,
 				struct device *dev);
-extern int iommu_map_range(struct iommu_domain *domain, unsigned long iova,
-			   phys_addr_t paddr, size_t size, int prot);
-extern void iommu_unmap_range(struct iommu_domain *domain, unsigned long iova,
-			      size_t size);
 extern int iommu_map(struct iommu_domain *domain, unsigned long iova,
 		     phys_addr_t paddr, int gfp_order, int prot);
 extern int iommu_unmap(struct iommu_domain *domain, unsigned long iova,
@@ -104,18 +96,6 @@ static inline void iommu_detach_device(struct iommu_domain *domain,
 {
 }
 
-static inline int iommu_map_range(struct iommu_domain *domain,
-				  unsigned long iova, phys_addr_t paddr,
-				  size_t size, int prot)
-{
-	return -ENODEV;
-}
-
-static inline void iommu_unmap_range(struct iommu_domain *domain,
-				     unsigned long iova, size_t size)
-{
-}
-
 static inline int iommu_map(struct iommu_domain *domain, unsigned long iova,
 			    phys_addr_t paddr, int gfp_order, int prot)
 {

commit 67651786948c360c3122b8a17cb1e59209d50880
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Thu Jan 21 16:32:27 2010 +0100

    iommu-api: Add ->{un}map callbacks to iommu_ops
    
    This patch adds new callbacks for mapping and unmapping
    pages to the iommu_ops structure. These callbacks are aware
    of page sizes which makes them different to the
    ->{un}map_range callbacks.
    
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 6d0035bb1a0c..5a7a3d888dac 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -36,6 +36,10 @@ struct iommu_ops {
 	void (*domain_destroy)(struct iommu_domain *domain);
 	int (*attach_dev)(struct iommu_domain *domain, struct device *dev);
 	void (*detach_dev)(struct iommu_domain *domain, struct device *dev);
+	int (*map)(struct iommu_domain *domain, unsigned long iova,
+		   phys_addr_t paddr, int gfp_order, int prot);
+	int (*unmap)(struct iommu_domain *domain, unsigned long iova,
+		     int gfp_order);
 	int (*map_range)(struct iommu_domain *domain, unsigned long iova,
 			 phys_addr_t paddr, size_t size, int prot);
 	void (*unmap_range)(struct iommu_domain *domain, unsigned long iova,

commit cefc53c7f494240d4813c80154c7617452d1904d
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Fri Jan 8 13:35:09 2010 +0100

    iommu-api: Add iommu_map and iommu_unmap functions
    
    These two functions provide support for mapping and
    unmapping physical addresses to io virtual addresses. The
    difference to the iommu_(un)map_range() is that the new
    functions take a gfp_order parameter instead of a size. This
    allows the IOMMU backend implementations to detect easier if
    a given range can be mapped by larger page sizes.
    These new functions should replace the old ones in the long
    term.
    
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 0f18f37a6503..6d0035bb1a0c 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -60,6 +60,10 @@ extern int iommu_map_range(struct iommu_domain *domain, unsigned long iova,
 			   phys_addr_t paddr, size_t size, int prot);
 extern void iommu_unmap_range(struct iommu_domain *domain, unsigned long iova,
 			      size_t size);
+extern int iommu_map(struct iommu_domain *domain, unsigned long iova,
+		     phys_addr_t paddr, int gfp_order, int prot);
+extern int iommu_unmap(struct iommu_domain *domain, unsigned long iova,
+		       int gfp_order);
 extern phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain,
 				      unsigned long iova);
 extern int iommu_domain_has_cap(struct iommu_domain *domain,
@@ -108,6 +112,18 @@ static inline void iommu_unmap_range(struct iommu_domain *domain,
 {
 }
 
+static inline int iommu_map(struct iommu_domain *domain, unsigned long iova,
+			    phys_addr_t paddr, int gfp_order, int prot)
+{
+	return -ENODEV;
+}
+
+static inline int iommu_unmap(struct iommu_domain *domain, unsigned long iova,
+			      int gfp_order)
+{
+	return -ENODEV;
+}
+
 static inline phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain,
 					     unsigned long iova)
 {

commit 4abc14a733f9002c05623db755aaafdd27fa7a91
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Wed Jan 20 14:52:23 2010 +0100

    iommu-api: Rename ->{un}map function pointers to ->{un}map_range
    
    The new function pointer names match better with the
    top-level functions of the iommu-api which are using them.
    Main intention of this change is to make the ->{un}map
    pointer names free for two new mapping functions.
    
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 3af4ffd591b9..0f18f37a6503 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -36,10 +36,10 @@ struct iommu_ops {
 	void (*domain_destroy)(struct iommu_domain *domain);
 	int (*attach_dev)(struct iommu_domain *domain, struct device *dev);
 	void (*detach_dev)(struct iommu_domain *domain, struct device *dev);
-	int (*map)(struct iommu_domain *domain, unsigned long iova,
-		   phys_addr_t paddr, size_t size, int prot);
-	void (*unmap)(struct iommu_domain *domain, unsigned long iova,
-		      size_t size);
+	int (*map_range)(struct iommu_domain *domain, unsigned long iova,
+			 phys_addr_t paddr, size_t size, int prot);
+	void (*unmap_range)(struct iommu_domain *domain, unsigned long iova,
+			    size_t size);
 	phys_addr_t (*iova_to_phys)(struct iommu_domain *domain,
 				    unsigned long iova);
 	int (*domain_has_cap)(struct iommu_domain *domain,

commit 9cf0669746be19a4906a6c48920060bcf54c708b
Author: Sheng Yang <sheng@linux.intel.com>
Date:   Wed Mar 18 15:33:07 2009 +0800

    intel-iommu: VT-d page table to support snooping control bit
    
    The user can request to enable snooping control through VT-d page table.
    
    Signed-off-by: Sheng Yang <sheng@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 0cf3a4e43f23..3af4ffd591b9 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -21,6 +21,7 @@
 
 #define IOMMU_READ	(1)
 #define IOMMU_WRITE	(2)
+#define IOMMU_CACHE	(4) /* DMA cache coherency */
 
 struct device;
 

commit dbb9fd8630e95b6155aff658a2b5f80e95ca2bc6
Author: Sheng Yang <sheng@linux.intel.com>
Date:   Wed Mar 18 15:33:06 2009 +0800

    iommu: Add domain_has_cap iommu_ops
    
    This iommu_op can tell if domain have a specific capability, like snooping
    control for Intel IOMMU, which can be used by other components of kernel to
    adjust the behaviour.
    
    Signed-off-by: Sheng Yang <sheng@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 8a7bfb1b6ca0..0cf3a4e43f23 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -28,6 +28,8 @@ struct iommu_domain {
 	void *priv;
 };
 
+#define IOMMU_CAP_CACHE_COHERENCY	0x1
+
 struct iommu_ops {
 	int (*domain_init)(struct iommu_domain *domain);
 	void (*domain_destroy)(struct iommu_domain *domain);
@@ -39,6 +41,8 @@ struct iommu_ops {
 		      size_t size);
 	phys_addr_t (*iova_to_phys)(struct iommu_domain *domain,
 				    unsigned long iova);
+	int (*domain_has_cap)(struct iommu_domain *domain,
+			      unsigned long cap);
 };
 
 #ifdef CONFIG_IOMMU_API
@@ -57,6 +61,8 @@ extern void iommu_unmap_range(struct iommu_domain *domain, unsigned long iova,
 			      size_t size);
 extern phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain,
 				      unsigned long iova);
+extern int iommu_domain_has_cap(struct iommu_domain *domain,
+				unsigned long cap);
 
 #else /* CONFIG_IOMMU_API */
 
@@ -107,6 +113,12 @@ static inline phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain,
 	return 0;
 }
 
+static inline int domain_has_cap(struct iommu_domain *domain,
+				 unsigned long cap)
+{
+	return 0;
+}
+
 #endif /* CONFIG_IOMMU_API */
 
 #endif /* __LINUX_IOMMU_H */

commit 4a77a6cf6d9bf9f5c74b27f62bd2bfe6dcc88392
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Wed Nov 26 17:02:33 2008 +0100

    introcude linux/iommu.h for an iommu api
    
    This patch introduces the API to abstract the exported VT-d functions
    for KVM into a generic API. This way the AMD IOMMU implementation can
    plug into this API later.
    
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/iommu.h b/include/linux/iommu.h
new file mode 100644
index 000000000000..8a7bfb1b6ca0
--- /dev/null
+++ b/include/linux/iommu.h
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2007-2008 Advanced Micro Devices, Inc.
+ * Author: Joerg Roedel <joerg.roedel@amd.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#ifndef __LINUX_IOMMU_H
+#define __LINUX_IOMMU_H
+
+#define IOMMU_READ	(1)
+#define IOMMU_WRITE	(2)
+
+struct device;
+
+struct iommu_domain {
+	void *priv;
+};
+
+struct iommu_ops {
+	int (*domain_init)(struct iommu_domain *domain);
+	void (*domain_destroy)(struct iommu_domain *domain);
+	int (*attach_dev)(struct iommu_domain *domain, struct device *dev);
+	void (*detach_dev)(struct iommu_domain *domain, struct device *dev);
+	int (*map)(struct iommu_domain *domain, unsigned long iova,
+		   phys_addr_t paddr, size_t size, int prot);
+	void (*unmap)(struct iommu_domain *domain, unsigned long iova,
+		      size_t size);
+	phys_addr_t (*iova_to_phys)(struct iommu_domain *domain,
+				    unsigned long iova);
+};
+
+#ifdef CONFIG_IOMMU_API
+
+extern void register_iommu(struct iommu_ops *ops);
+extern bool iommu_found(void);
+extern struct iommu_domain *iommu_domain_alloc(void);
+extern void iommu_domain_free(struct iommu_domain *domain);
+extern int iommu_attach_device(struct iommu_domain *domain,
+			       struct device *dev);
+extern void iommu_detach_device(struct iommu_domain *domain,
+				struct device *dev);
+extern int iommu_map_range(struct iommu_domain *domain, unsigned long iova,
+			   phys_addr_t paddr, size_t size, int prot);
+extern void iommu_unmap_range(struct iommu_domain *domain, unsigned long iova,
+			      size_t size);
+extern phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain,
+				      unsigned long iova);
+
+#else /* CONFIG_IOMMU_API */
+
+static inline void register_iommu(struct iommu_ops *ops)
+{
+}
+
+static inline bool iommu_found(void)
+{
+	return false;
+}
+
+static inline struct iommu_domain *iommu_domain_alloc(void)
+{
+	return NULL;
+}
+
+static inline void iommu_domain_free(struct iommu_domain *domain)
+{
+}
+
+static inline int iommu_attach_device(struct iommu_domain *domain,
+				      struct device *dev)
+{
+	return -ENODEV;
+}
+
+static inline void iommu_detach_device(struct iommu_domain *domain,
+				       struct device *dev)
+{
+}
+
+static inline int iommu_map_range(struct iommu_domain *domain,
+				  unsigned long iova, phys_addr_t paddr,
+				  size_t size, int prot)
+{
+	return -ENODEV;
+}
+
+static inline void iommu_unmap_range(struct iommu_domain *domain,
+				     unsigned long iova, size_t size)
+{
+}
+
+static inline phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain,
+					     unsigned long iova)
+{
+	return 0;
+}
+
+#endif /* CONFIG_IOMMU_API */
+
+#endif /* __LINUX_IOMMU_H */
