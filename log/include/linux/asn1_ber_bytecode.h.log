commit b4d0d230ccfb5d1a9ea85da64aa584df7c148ee9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 19:08:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 36
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public licence as published by
      the free software foundation either version 2 of the licence or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 114 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520170857.552531963@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/asn1_ber_bytecode.h b/include/linux/asn1_ber_bytecode.h
index ab3a6c002f7b..b38361953a48 100644
--- a/include/linux/asn1_ber_bytecode.h
+++ b/include/linux/asn1_ber_bytecode.h
@@ -1,12 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /* ASN.1 BER/DER/CER parsing state machine internal definitions
  *
  * Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public Licence
- * as published by the Free Software Foundation; either version
- * 2 of the Licence, or (at your option) any later version.
  */
 
 #ifndef _LINUX_ASN1_BER_BYTECODE_H

commit 233ce79db4b23a174bcf30bde5d6ad913d5f46d3
Author: David Howells <dhowells@redhat.com>
Date:   Wed Aug 5 12:54:46 2015 +0100

    ASN.1: Handle 'ANY OPTIONAL' in grammar
    
    An ANY object in an ASN.1 grammar that is marked OPTIONAL should be skipped
    if there is no more data to be had.
    
    This can be tested by editing X.509 certificates or PKCS#7 messages to
    remove the NULL from subobjects that look like the following:
    
            SEQUENCE {
              OBJECT(2a864886f70d01010b);
              NULL();
            }
    
    This is an algorithm identifier plus an optional parameter.
    
    The modified DER can be passed to one of:
    
            keyctl padd asymmetric "" @s </tmp/modified.x509
            keyctl padd pkcs7_test foo @s </tmp/modified.pkcs7
    
    It should work okay with the patch and produce EBADMSG without.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/asn1_ber_bytecode.h b/include/linux/asn1_ber_bytecode.h
index 27f35780aecf..ab3a6c002f7b 100644
--- a/include/linux/asn1_ber_bytecode.h
+++ b/include/linux/asn1_ber_bytecode.h
@@ -45,24 +45,27 @@ enum asn1_opcode {
 	ASN1_OP_MATCH_JUMP		= 0x04,
 	ASN1_OP_MATCH_JUMP_OR_SKIP	= 0x05,
 	ASN1_OP_MATCH_ANY		= 0x08,
+	ASN1_OP_MATCH_ANY_OR_SKIP	= 0x09,
 	ASN1_OP_MATCH_ANY_ACT		= 0x0a,
+	ASN1_OP_MATCH_ANY_ACT_OR_SKIP	= 0x0b,
 	/* Everything before here matches unconditionally */
 
 	ASN1_OP_COND_MATCH_OR_SKIP	= 0x11,
 	ASN1_OP_COND_MATCH_ACT_OR_SKIP	= 0x13,
 	ASN1_OP_COND_MATCH_JUMP_OR_SKIP	= 0x15,
 	ASN1_OP_COND_MATCH_ANY		= 0x18,
+	ASN1_OP_COND_MATCH_ANY_OR_SKIP	= 0x19,
 	ASN1_OP_COND_MATCH_ANY_ACT	= 0x1a,
+	ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP = 0x1b,
 
 	/* Everything before here will want a tag from the data */
-#define ASN1_OP__MATCHES_TAG ASN1_OP_COND_MATCH_ANY_ACT
+#define ASN1_OP__MATCHES_TAG ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP
 
 	/* These are here to help fill up space */
-	ASN1_OP_COND_FAIL		= 0x1b,
-	ASN1_OP_COMPLETE		= 0x1c,
-	ASN1_OP_ACT			= 0x1d,
-	ASN1_OP_MAYBE_ACT		= 0x1e,
-	ASN1_OP_RETURN			= 0x1f,
+	ASN1_OP_COND_FAIL		= 0x1c,
+	ASN1_OP_COMPLETE		= 0x1d,
+	ASN1_OP_ACT			= 0x1e,
+	ASN1_OP_MAYBE_ACT		= 0x1f,
 
 	/* The following eight have bit 0 -> SET, 1 -> OF, 2 -> ACT */
 	ASN1_OP_END_SEQ			= 0x20,
@@ -77,6 +80,8 @@ enum asn1_opcode {
 #define ASN1_OP_END__OF			  0x02
 #define ASN1_OP_END__ACT		  0x04
 
+	ASN1_OP_RETURN			= 0x28,
+
 	ASN1_OP__NR
 };
 

commit 3f3af97d8225a58ecdcde7217c030b17e5198226
Author: David Howells <dhowells@redhat.com>
Date:   Wed Aug 5 12:54:46 2015 +0100

    ASN.1: Fix actions on CHOICE elements with IMPLICIT tags
    
    In an ASN.1 description where there is a CHOICE construct that contains
    elements with IMPLICIT tags that refer to constructed types, actions to be
    taken on those elements should be conditional on the corresponding element
    actually being matched.  Currently, however, such actions are performed
    unconditionally in the middle of processing the CHOICE.
    
    For example, look at elements 'b' and 'e' here:
    
            A ::= SEQUENCE {
                            CHOICE {
                            b [0] IMPLICIT B ({ do_XXXXXXXXXXXX_b }),
                            c [1] EXPLICIT C ({ do_XXXXXXXXXXXX_c }),
                            d [2] EXPLICIT B ({ do_XXXXXXXXXXXX_d }),
                            e [3] IMPLICIT C ({ do_XXXXXXXXXXXX_e }),
                            f [4] IMPLICIT INTEGER ({ do_XXXXXXXXXXXX_f })
                            }
                    } ({ do_XXXXXXXXXXXX_A })
    
            B ::= SET OF OBJECT IDENTIFIER ({ do_XXXXXXXXXXXX_oid })
    
            C ::= SET OF INTEGER ({ do_XXXXXXXXXXXX_int })
    
    They each have an action (do_XXXXXXXXXXXX_b and do_XXXXXXXXXXXX_e) that
    should only be processed if that element is matched.
    
    The problem is that there's no easy place to hang the action off in the
    subclause (type B for element 'b' and type C for element 'e') because
    subclause opcode sequences can be shared.
    
    To fix this, introduce a conditional action opcode(ASN1_OP_MAYBE_ACT) that
    the decoder only processes if the preceding match was successful.  This can
    be seen in an excerpt from the output of the fixed ASN.1 compiler for the
    above ASN.1 description:
    
            [  13] =  ASN1_OP_COND_MATCH_JUMP_OR_SKIP,              // e
            [  14] =  _tagn(CONT, CONS,  3),
            [  15] =  _jump_target(45),             // --> C
            [  16] =  ASN1_OP_MAYBE_ACT,
            [  17] =  _action(ACT_do_XXXXXXXXXXXX_e),
    
    In this, if the op at [13] is matched (ie. element 'e' above) then the
    action at [16] will be performed.  However, if the op at [13] doesn't match
    or is skipped because it is conditional and some previous op matched, then
    the action at [16] will be ignored.
    
    Note that to make this work in the decoder, the ASN1_OP_RETURN op must set
    the flag to indicate that a match happened.  This is necessary because the
    _jump_target() seen above introduces a subclause (in this case an object of
    type 'C') which is likely to alter the flag.  Setting the flag here is okay
    because to process a subclause, a match must have happened and caused a
    jump.
    
    This cannot be tested with the code as it stands, but rather affects future
    code.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/asn1_ber_bytecode.h b/include/linux/asn1_ber_bytecode.h
index 945d44ae529c..27f35780aecf 100644
--- a/include/linux/asn1_ber_bytecode.h
+++ b/include/linux/asn1_ber_bytecode.h
@@ -61,7 +61,8 @@ enum asn1_opcode {
 	ASN1_OP_COND_FAIL		= 0x1b,
 	ASN1_OP_COMPLETE		= 0x1c,
 	ASN1_OP_ACT			= 0x1d,
-	ASN1_OP_RETURN			= 0x1e,
+	ASN1_OP_MAYBE_ACT		= 0x1e,
+	ASN1_OP_RETURN			= 0x1f,
 
 	/* The following eight have bit 0 -> SET, 1 -> OF, 2 -> ACT */
 	ASN1_OP_END_SEQ			= 0x20,

commit 4520c6a49af833c83de6c74525ce8e07bbe6d783
Author: David Howells <dhowells@redhat.com>
Date:   Fri Sep 21 23:31:13 2012 +0100

    X.509: Add simple ASN.1 grammar compiler
    
    Add a simple ASN.1 grammar compiler.  This produces a bytecode output that can
    be fed to a decoder to inform the decoder how to interpret the ASN.1 stream it
    is trying to parse.
    
    Action functions can be specified in the grammar by interpolating:
    
            ({ foo })
    
    after a type, for example:
    
            SubjectPublicKeyInfo ::= SEQUENCE {
                    algorithm               AlgorithmIdentifier,
                    subjectPublicKey        BIT STRING ({ do_key_data })
                    }
    
    The decoder is expected to call these after matching this type and parsing the
    contents if it is a constructed type.
    
    The grammar compiler does not currently support the SET type (though it does
    support SET OF) as I can't see a good way of tracking which members have been
    encountered yet without using up extra stack space.
    
    Currently, the grammar compiler will fail if more than 256 bytes of bytecode
    would be produced or more than 256 actions have been specified as it uses
    8-bit jump values and action indices to keep space usage down.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/include/linux/asn1_ber_bytecode.h b/include/linux/asn1_ber_bytecode.h
new file mode 100644
index 000000000000..945d44ae529c
--- /dev/null
+++ b/include/linux/asn1_ber_bytecode.h
@@ -0,0 +1,87 @@
+/* ASN.1 BER/DER/CER parsing state machine internal definitions
+ *
+ * Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public Licence
+ * as published by the Free Software Foundation; either version
+ * 2 of the Licence, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_ASN1_BER_BYTECODE_H
+#define _LINUX_ASN1_BER_BYTECODE_H
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#endif
+#include <linux/asn1.h>
+
+typedef int (*asn1_action_t)(void *context,
+			     size_t hdrlen, /* In case of ANY type */
+			     unsigned char tag, /* In case of ANY type */
+			     const void *value, size_t vlen);
+
+struct asn1_decoder {
+	const unsigned char *machine;
+	size_t machlen;
+	const asn1_action_t *actions;
+};
+
+enum asn1_opcode {
+	/* The tag-matching ops come first and the odd-numbered slots
+	 * are for OR_SKIP ops.
+	 */
+#define ASN1_OP_MATCH__SKIP		  0x01
+#define ASN1_OP_MATCH__ACT		  0x02
+#define ASN1_OP_MATCH__JUMP		  0x04
+#define ASN1_OP_MATCH__ANY		  0x08
+#define ASN1_OP_MATCH__COND		  0x10
+
+	ASN1_OP_MATCH			= 0x00,
+	ASN1_OP_MATCH_OR_SKIP		= 0x01,
+	ASN1_OP_MATCH_ACT		= 0x02,
+	ASN1_OP_MATCH_ACT_OR_SKIP	= 0x03,
+	ASN1_OP_MATCH_JUMP		= 0x04,
+	ASN1_OP_MATCH_JUMP_OR_SKIP	= 0x05,
+	ASN1_OP_MATCH_ANY		= 0x08,
+	ASN1_OP_MATCH_ANY_ACT		= 0x0a,
+	/* Everything before here matches unconditionally */
+
+	ASN1_OP_COND_MATCH_OR_SKIP	= 0x11,
+	ASN1_OP_COND_MATCH_ACT_OR_SKIP	= 0x13,
+	ASN1_OP_COND_MATCH_JUMP_OR_SKIP	= 0x15,
+	ASN1_OP_COND_MATCH_ANY		= 0x18,
+	ASN1_OP_COND_MATCH_ANY_ACT	= 0x1a,
+
+	/* Everything before here will want a tag from the data */
+#define ASN1_OP__MATCHES_TAG ASN1_OP_COND_MATCH_ANY_ACT
+
+	/* These are here to help fill up space */
+	ASN1_OP_COND_FAIL		= 0x1b,
+	ASN1_OP_COMPLETE		= 0x1c,
+	ASN1_OP_ACT			= 0x1d,
+	ASN1_OP_RETURN			= 0x1e,
+
+	/* The following eight have bit 0 -> SET, 1 -> OF, 2 -> ACT */
+	ASN1_OP_END_SEQ			= 0x20,
+	ASN1_OP_END_SET			= 0x21,
+	ASN1_OP_END_SEQ_OF		= 0x22,
+	ASN1_OP_END_SET_OF		= 0x23,
+	ASN1_OP_END_SEQ_ACT		= 0x24,
+	ASN1_OP_END_SET_ACT		= 0x25,
+	ASN1_OP_END_SEQ_OF_ACT		= 0x26,
+	ASN1_OP_END_SET_OF_ACT		= 0x27,
+#define ASN1_OP_END__SET		  0x01
+#define ASN1_OP_END__OF			  0x02
+#define ASN1_OP_END__ACT		  0x04
+
+	ASN1_OP__NR
+};
+
+#define _tag(CLASS, CP, TAG) ((ASN1_##CLASS << 6) | (ASN1_##CP << 5) | ASN1_##TAG)
+#define _tagn(CLASS, CP, TAG) ((ASN1_##CLASS << 6) | (ASN1_##CP << 5) | TAG)
+#define _jump_target(N) (N)
+#define _action(N) (N)
+
+#endif /* _LINUX_ASN1_BER_BYTECODE_H */
