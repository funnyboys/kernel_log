commit 2a55280a3675203496d302463b941834228b9875
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Sun Jun 7 15:41:35 2020 +0200

    efi/libstub: arm: Print CPU boot mode and MMU state at boot
    
    On 32-bit ARM, we may boot at HYP mode, or with the MMU and caches off
    (or both), even though the EFI spec does not actually support this.
    While booting at HYP mode is something we might tolerate, fiddling
    with the caches is a more serious issue, as disabling the caches is
    tricky to do safely from C code, and running without the Dcache makes
    it impossible to support unaligned memory accesses, which is another
    explicit requirement imposed by the EFI spec.
    
    So take note of the CPU mode and MMU state in the EFI stub diagnostic
    output so that we can easily diagnose any issues that may arise from
    this. E.g.,
    
      EFI stub: Entering in SVC mode with MMU enabled
    
    Also, capture the CPSR and SCTLR system register values at EFI stub
    entry, and after ExitBootServices() returns, and check whether the
    MMU and Dcache were disabled at any point. If this is the case, a
    diagnostic message like the following will be emitted:
    
      efi: [Firmware Bug]: EFI stub was entered with MMU and Dcache disabled, please fix your firmware!
      efi: CPSR at EFI stub entry        : 0x600001d3
      efi: SCTLR at EFI stub entry       : 0x00c51838
      efi: CPSR after ExitBootServices() : 0x600001d3
      efi: SCTLR after ExitBootServices(): 0x00c50838
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Reviewed-by: Leif Lindholm <leif@nuviainc.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index c3449c9699d0..bb35f3305e55 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -350,6 +350,7 @@ void efi_native_runtime_setup(void);
  * associated with ConOut
  */
 #define LINUX_EFI_ARM_SCREEN_INFO_TABLE_GUID	EFI_GUID(0xe03fc20a, 0x85dc, 0x406e,  0xb9, 0x0e, 0x4a, 0xb5, 0x02, 0x37, 0x1d, 0x95)
+#define LINUX_EFI_ARM_CPU_STATE_TABLE_GUID	EFI_GUID(0xef79e4aa, 0x3c3d, 0x4989,  0xb9, 0x02, 0x07, 0xa9, 0x43, 0xe5, 0x50, 0xd2)
 #define LINUX_EFI_LOADER_ENTRY_GUID		EFI_GUID(0x4a67b082, 0x0a4c, 0x41cf,  0xb6, 0xc7, 0x44, 0x0b, 0x29, 0xbb, 0x8c, 0x4f)
 #define LINUX_EFI_RANDOM_SEED_TABLE_GUID	EFI_GUID(0x1ce1e5bc, 0x7ceb, 0x42f2,  0x81, 0xe5, 0x8a, 0xad, 0xf1, 0x80, 0xf5, 0x7b)
 #define LINUX_EFI_TPM_EVENT_LOG_GUID		EFI_GUID(0xb7799cb0, 0xeca2, 0x4943,  0x96, 0x67, 0x1f, 0xae, 0x07, 0xb7, 0x47, 0xfa)

commit 2963795122f50b36ed16e3ba880c3ed2de1bda6e
Author: Gustavo A. R. Silva <gustavoars@kernel.org>
Date:   Wed May 27 12:14:25 2020 -0500

    efi: Replace zero-length array and use struct_size() helper
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    sizeof(flexible-array-member) triggers a warning because flexible array
    members have incomplete type[1]. There are some instances of code in
    which the sizeof operator is being incorrectly/erroneously applied to
    zero-length arrays and the result is zero. Such instances may be hiding
    some bugs. So, this work (flexible-array member conversions) will also
    help to get completely rid of those sorts of issues.
    
    Lastly, make use of the sizeof_field() helper instead of an open-coded
    version.
    
    This issue was found with the help of Coccinelle and audited _manually_.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Link: https://lore.kernel.org/r/20200527171425.GA4053@embeddedor
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 2c6495f72f79..c3449c9699d0 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1236,14 +1236,11 @@ struct linux_efi_memreserve {
 	struct {
 		phys_addr_t	base;
 		phys_addr_t	size;
-	} entry[0];
+	} entry[];
 };
 
-#define EFI_MEMRESERVE_SIZE(count) (sizeof(struct linux_efi_memreserve) + \
-	(count) * sizeof(((struct linux_efi_memreserve *)0)->entry[0]))
-
 #define EFI_MEMRESERVE_COUNT(size) (((size) - sizeof(struct linux_efi_memreserve)) \
-	/ sizeof(((struct linux_efi_memreserve *)0)->entry[0]))
+	/ sizeof_field(struct linux_efi_memreserve, entry[0]))
 
 void __init efi_arch_mem_reserve(phys_addr_t addr, u64 size);
 

commit d1343da330f6ff3f40abf1f360d4701af784b85a
Merge: a5d8e55b2c7d 9241dfe7f277
Author: Ingo Molnar <mingo@kernel.org>
Date:   Mon May 25 15:11:14 2020 +0200

    Merge tag 'efi-changes-for-v5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/efi/efi into efi/core
    
    More EFI changes for v5.8:
    
     - Rename pr_efi/pr_efi_err to efi_info/efi_err, and use them consistently
     - Simplify and unify initrd loading
     - Parse the builtin command line on x86 (if provided)
     - Implement printk() support, including support for wide character strings
     - Some fixes for issues introduced by the first batch of v5.8 changes
     - Fix a missing prototypes warning
     - Simplify GDT handling in early mixed mode thunking code
     - Some other minor fixes and cleanups
    
    Conflicts:
            drivers/firmware/efi/libstub/efistub.h
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit a5d8e55b2c7d3d18d7837af0ef8d1477eeeb919c
Merge: 4da0b2b7e675 9cb1fd0efd19
Author: Ingo Molnar <mingo@kernel.org>
Date:   Mon May 25 15:10:37 2020 +0200

    Merge tag 'v5.7-rc7' into efi/core, to refresh the branch and pick up fixes
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 14c574f35cfbc9272fc67b41f074c847db139652
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Mon May 18 15:07:11 2020 -0400

    efi/gop: Add an option to list out the available GOP modes
    
    Add video=efifb:list option to list the modes that are available.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Link: https://lore.kernel.org/r/20200518190716.751506-20-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 974648db0c68..609201bd4682 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -39,6 +39,7 @@
 #define EFI_WRITE_PROTECTED	( 8 | (1UL << (BITS_PER_LONG-1)))
 #define EFI_OUT_OF_RESOURCES	( 9 | (1UL << (BITS_PER_LONG-1)))
 #define EFI_NOT_FOUND		(14 | (1UL << (BITS_PER_LONG-1)))
+#define EFI_TIMEOUT		(18 | (1UL << (BITS_PER_LONG-1)))
 #define EFI_ABORTED		(21 | (1UL << (BITS_PER_LONG-1)))
 #define EFI_SECURITY_VIOLATION	(26 | (1UL << (BITS_PER_LONG-1)))
 

commit 9b47c5275614a16fd64359fab73fe6c736bf57a0
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Mon May 18 15:07:10 2020 -0400

    efi/libstub: Add definitions for console input and events
    
    Add the required typedefs etc for using con_in's simple text input
    protocol, and for using the boottime event services.
    
    Also add the prototype for the "stall" boot service.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Link: https://lore.kernel.org/r/20200518190716.751506-19-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 9b7c7ec319ac..974648db0c68 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -426,6 +426,7 @@ typedef struct {
 	u32 tables;
 } efi_system_table_32_t;
 
+typedef union efi_simple_text_input_protocol efi_simple_text_input_protocol_t;
 typedef union efi_simple_text_output_protocol efi_simple_text_output_protocol_t;
 
 typedef union {
@@ -434,7 +435,7 @@ typedef union {
 		unsigned long fw_vendor;	/* physical addr of CHAR16 vendor string */
 		u32 fw_revision;
 		unsigned long con_in_handle;
-		unsigned long con_in;
+		efi_simple_text_input_protocol_t *con_in;
 		unsigned long con_out_handle;
 		efi_simple_text_output_protocol_t *con_out;
 		unsigned long stderr_handle;

commit e8da08a088236aff4b51d4ec97c750051f9fe417
Author: Benjamin Thiel <b.thiel@posteo.de>
Date:   Sat May 16 15:26:47 2020 +0200

    efi: Pull up arch-specific prototype efi_systab_show_arch()
    
    Pull up arch-specific prototype efi_systab_show_arch() in order to
    fix a -Wmissing-prototypes warning:
    
    arch/x86/platform/efi/efi.c:957:7: warning: no previous prototype for
    ‘efi_systab_show_arch’ [-Wmissing-prototypes]
    char *efi_systab_show_arch(char *str)
    
    Signed-off-by: Benjamin Thiel <b.thiel@posteo.de>
    Link: https://lore.kernel.org/r/20200516132647.14568-1-b.thiel@posteo.de
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 251f1f783cdf..9430d01c0c3d 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1245,4 +1245,6 @@ struct linux_efi_memreserve {
 
 void __init efi_arch_mem_reserve(phys_addr_t addr, u64 size);
 
+char *efi_systab_show_arch(char *str);
+
 #endif /* _LINUX_EFI_H */

commit 4e9a0f73f030e19a9259b69a7079021048e1f904
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Thu Mar 26 09:24:14 2020 +0100

    efi: Clean up config table description arrays
    
    Increase legibility by adding whitespace to the efi_config_table_type_t
    arrays that describe which EFI config tables we look for when going over
    the firmware provided list. While at it, replace the 'name' char pointer
    with a char array, which is more space efficient on relocatable 64-bit
    kernels, as it avoids a 8 byte pointer and the associated relocation
    data (24 bytes when using RELA format)
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 251f1f783cdf..9b7c7ec319ac 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -379,8 +379,8 @@ typedef union {
 
 typedef struct {
 	efi_guid_t guid;
-	const char *name;
 	unsigned long *ptr;
+	const char name[16];
 } efi_config_table_type_t;
 
 #define EFI_SYSTEM_TABLE_SIGNATURE ((u64)0x5453595320494249ULL)

commit fdf5563a720004199324371c08071b8ea27bd994
Merge: 97cddfc34549 a2150327250e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 31 11:04:05 2020 -0700

    Merge branch 'x86-cleanups-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 cleanups from Ingo Molnar:
     "This topic tree contains more commits than usual:
    
       - most of it are uaccess cleanups/reorganization by Al
    
       - there's a bunch of prototype declaration (--Wmissing-prototypes)
         cleanups
    
       - misc other cleanups all around the map"
    
    * 'x86-cleanups-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (36 commits)
      x86/mm/set_memory: Fix -Wmissing-prototypes warnings
      x86/efi: Add a prototype for efi_arch_mem_reserve()
      x86/mm: Mark setup_emu2phys_nid() static
      x86/jump_label: Move 'inline' keyword placement
      x86/platform/uv: Add a missing prototype for uv_bau_message_interrupt()
      kill uaccess_try()
      x86: unsafe_put-style macro for sigmask
      x86: x32_setup_rt_frame(): consolidate uaccess areas
      x86: __setup_rt_frame(): consolidate uaccess areas
      x86: __setup_frame(): consolidate uaccess areas
      x86: setup_sigcontext(): list user_access_{begin,end}() into callers
      x86: get rid of put_user_try in __setup_rt_frame() (both 32bit and 64bit)
      x86: ia32_setup_rt_frame(): consolidate uaccess areas
      x86: ia32_setup_frame(): consolidate uaccess areas
      x86: ia32_setup_sigcontext(): lift user_access_{begin,end}() into the callers
      x86/alternatives: Mark text_poke_loc_init() static
      x86/cpu: Fix a -Wmissing-prototypes warning for init_ia32_feat_ctl()
      x86/mm: Drop pud_mknotpresent()
      x86: Replace setup_irq() by request_irq()
      x86/configs: Slightly reduce defconfigs
      ...

commit 860f89e6182479149bb6c27f5f44989b0628a176
Author: Benjamin Thiel <b.thiel@posteo.de>
Date:   Thu Mar 26 14:50:41 2020 +0100

    x86/efi: Add a prototype for efi_arch_mem_reserve()
    
    ... in order to fix a -Wmissing-ptototypes warning:
    
      arch/x86/platform/efi/quirks.c:245:13: warning:
      no previous prototype for ‘efi_arch_mem_reserve’ [-Wmissing-prototypes] \
              void __init efi_arch_mem_reserve(phys_addr_t addr, u64 size)
    
    Signed-off-by: Benjamin Thiel <b.thiel@posteo.de>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Link: https://lkml.kernel.org/r/20200326135041.3264-1-b.thiel@posteo.de

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 7efd7072cca5..e4b28ae1ba61 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1703,4 +1703,6 @@ struct linux_efi_memreserve {
 
 void efi_pci_disable_bridge_busmaster(void);
 
+void __init efi_arch_mem_reserve(phys_addr_t addr, u64 size);
+
 #endif /* _LINUX_EFI_H */

commit 3be5f0d286dc944dee65fdcbddfc4d314f7d4482
Merge: c98a76eabbb6 f0df68d5bae8
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sun Mar 8 08:59:47 2020 +0100

    Merge tag 'efi-next' of git://git.kernel.org/pub/scm/linux/kernel/git/efi/efi into efi/core
    
    More EFI updates for v5.7
    
     - Incorporate a stable branch with the EFI pieces of Hans's work on
       loading device firmware from EFI boot service memory regions
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit f0df68d5bae8825ee5b62f00af237ae82247f045
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Jan 15 17:35:46 2020 +0100

    efi: Add embedded peripheral firmware support
    
    Just like with PCI options ROMs, which we save in the setup_efi_pci*
    functions from arch/x86/boot/compressed/eboot.c, the EFI code / ROM itself
    sometimes may contain data which is useful/necessary for peripheral drivers
    to have access to.
    
    Specifically the EFI code may contain an embedded copy of firmware which
    needs to be (re)loaded into the peripheral. Normally such firmware would be
    part of linux-firmware, but in some cases this is not feasible, for 2
    reasons:
    
    1) The firmware is customized for a specific use-case of the chipset / use
    with a specific hardware model, so we cannot have a single firmware file
    for the chipset. E.g. touchscreen controller firmwares are compiled
    specifically for the hardware model they are used with, as they are
    calibrated for a specific model digitizer.
    
    2) Despite repeated attempts we have failed to get permission to
    redistribute the firmware. This is especially a problem with customized
    firmwares, these get created by the chip vendor for a specific ODM and the
    copyright may partially belong with the ODM, so the chip vendor cannot
    give a blanket permission to distribute these.
    
    This commit adds support for finding peripheral firmware embedded in the
    EFI code and makes the found firmware available through the new
    efi_get_embedded_fw() function.
    
    Support for loading these firmwares through the standard firmware loading
    mechanism is added in a follow-up commit in this patch-series.
    
    Note we check the EFI_BOOT_SERVICES_CODE for embedded firmware near the end
    of start_kernel(), just before calling rest_init(), this is on purpose
    because the typical EFI_BOOT_SERVICES_CODE memory-segment is too large for
    early_memremap(), so the check must be done after mm_init(). This relies
    on EFI_BOOT_SERVICES_CODE not being free-ed until efi_free_boot_services()
    is called, which means that this will only work on x86 for now.
    
    Reported-by: Dave Olsthoorn <dave@bewaar.me>
    Suggested-by: Peter Jones <pjones@redhat.com>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20200115163554.101315-3-hdegoede@redhat.com
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index a6e1a2d8511e..23392b88bcc0 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1554,6 +1554,12 @@ static inline void
 efi_enable_reset_attack_mitigation(void) { }
 #endif
 
+#ifdef CONFIG_EFI_EMBEDDED_FIRMWARE
+void efi_check_for_embedded_firmwares(void);
+#else
+static inline void efi_check_for_embedded_firmwares(void) { }
+#endif
+
 efi_status_t efi_random_get_seed(void);
 
 void efi_retrieve_tpm2_eventlog(void);

commit 0e72a6a3cfc3a32273f5e99bfaa4407f4917d343
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Jan 15 17:35:45 2020 +0100

    efi: Export boot-services code and data as debugfs-blobs
    
    Sometimes it is useful to be able to dump the efi boot-services code and
    data. This commit adds these as debugfs-blobs to /sys/kernel/debug/efi,
    but only if efi=debug is passed on the kernel-commandline as this requires
    not freeing those memory-regions, which costs 20+ MB of RAM.
    
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20200115163554.101315-2-hdegoede@redhat.com
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 7efd7072cca5..a6e1a2d8511e 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1124,6 +1124,7 @@ extern int __init efi_setup_pcdp_console(char *);
 #define EFI_NX_PE_DATA		9	/* Can runtime data regions be mapped non-executable? */
 #define EFI_MEM_ATTR		10	/* Did firmware publish an EFI_MEMORY_ATTRIBUTES table? */
 #define EFI_MEM_NO_SOFT_RESERVE	11	/* Is the kernel configured to ignore soft reservations? */
+#define EFI_PRESERVE_BS_REGIONS	12	/* Are EFI boot-services memory segments available? */
 
 #ifdef CONFIG_EFI
 /*

commit badc61982adb6018a48ed8fe32087b9754cae14b
Author: Tom Lendacky <thomas.lendacky@amd.com>
Date:   Fri Feb 28 13:14:04 2020 +0100

    efi/x86: Add RNG seed EFI table to unencrypted mapping check
    
    When booting with SME active, EFI tables must be mapped unencrypted since
    they were built by UEFI in unencrypted memory. Update the list of tables
    to be checked during early_memremap() processing to account for the EFI
    RNG seed table.
    
    Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: linux-efi@vger.kernel.org
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: David Hildenbrand <david@redhat.com>
    Cc: Heinrich Schuchardt <xypron.glpk@gmx.de>
    Link: https://lore.kernel.org/r/b64385fc13e5d7ad4b459216524f138e7879234f.1582662842.git.thomas.lendacky@amd.com
    Link: https://lore.kernel.org/r/20200228121408.9075-3-ardb@kernel.org

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 2ab33d5d6ca5..e8a08a499131 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -526,6 +526,8 @@ typedef struct {
 	efi_time_t time_of_revocation;
 } efi_cert_x509_sha256_t;
 
+extern unsigned long __ro_after_init efi_rng_seed;		/* RNG Seed table */
+
 /*
  * All runtime access to EFI goes through this structure:
  */

commit fe4db90a80cd12ebe4efe385d40d6636330149ed
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Thu Jan 23 13:10:25 2020 +0100

    efi: Add support for EFI_RT_PROPERTIES table
    
    Take the newly introduced EFI_RT_PROPERTIES_TABLE configuration table
    into account, which carries a mask of which EFI runtime services are
    still functional after ExitBootServices() has been called by the OS.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 57695f400044..2ab33d5d6ca5 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -334,6 +334,7 @@ void efi_native_runtime_setup(void);
 #define EFI_TCG2_PROTOCOL_GUID			EFI_GUID(0x607f766c, 0x7455, 0x42be,  0x93, 0x0b, 0xe4, 0xd7, 0x6d, 0xb2, 0x72, 0x0f)
 #define EFI_LOAD_FILE_PROTOCOL_GUID		EFI_GUID(0x56ec3091, 0x954c, 0x11d2,  0x8e, 0x3f, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)
 #define EFI_LOAD_FILE2_PROTOCOL_GUID		EFI_GUID(0x4006c0c1, 0xfcb3, 0x403e,  0x99, 0x6d, 0x4a, 0x6c, 0x87, 0x24, 0xe0, 0x6d)
+#define EFI_RT_PROPERTIES_TABLE_GUID		EFI_GUID(0xeb66918a, 0x7eef, 0x402a,  0x84, 0x2e, 0x93, 0x1d, 0x21, 0xc3, 0x8a, 0xe9)
 
 #define EFI_IMAGE_SECURITY_DATABASE_GUID	EFI_GUID(0xd719b2cb, 0x3d3a, 0x4596,  0xa3, 0xbc, 0xda, 0xd0, 0x0e, 0x67, 0x65, 0x6f)
 #define EFI_SHIM_LOCK_GUID			EFI_GUID(0x605dab50, 0xe046, 0x4300,  0xab, 0xb6, 0x3d, 0xd8, 0x10, 0xdd, 0x8b, 0x23)
@@ -486,6 +487,14 @@ typedef struct {
 #define EFI_PROPERTIES_TABLE_VERSION	0x00010000
 #define EFI_PROPERTIES_RUNTIME_MEMORY_PROTECTION_NON_EXECUTABLE_PE_DATA	0x1
 
+typedef struct {
+	u16 version;
+	u16 length;
+	u32 runtime_services_supported;
+} efi_rt_properties_table_t;
+
+#define EFI_RT_PROPERTIES_TABLE_VERSION	0x1
+
 #define EFI_INVALID_TABLE_ADDR		(~0UL)
 
 typedef struct {

commit 96a3dd3dece8134ba19b0ded7e6663136d3107b9
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Jan 21 11:17:47 2020 +0100

    efi: Store mask of supported runtime services in struct efi
    
    Revision 2.8 of the UEFI spec introduces provisions for firmware to
    advertise lack of support for certain runtime services at OS runtime.
    Let's store this mask in struct efi for easy access.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index a0008e3d4e9d..57695f400044 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -523,6 +523,7 @@ typedef struct {
 extern struct efi {
 	const efi_runtime_services_t	*runtime;		/* EFI runtime services table */
 	unsigned int			runtime_version;	/* Runtime services version */
+	unsigned int			runtime_supported_mask;
 
 	unsigned long			acpi;			/* ACPI table  (IA64 ext 0.71) */
 	unsigned long			acpi20;			/* ACPI table  (ACPI 2.0) */
@@ -551,6 +552,26 @@ extern struct efi {
 	unsigned long			flags;
 } efi;
 
+#define EFI_RT_SUPPORTED_GET_TIME 				0x0001
+#define EFI_RT_SUPPORTED_SET_TIME 				0x0002
+#define EFI_RT_SUPPORTED_GET_WAKEUP_TIME			0x0004
+#define EFI_RT_SUPPORTED_SET_WAKEUP_TIME			0x0008
+#define EFI_RT_SUPPORTED_GET_VARIABLE				0x0010
+#define EFI_RT_SUPPORTED_GET_NEXT_VARIABLE_NAME			0x0020
+#define EFI_RT_SUPPORTED_SET_VARIABLE				0x0040
+#define EFI_RT_SUPPORTED_SET_VIRTUAL_ADDRESS_MAP		0x0080
+#define EFI_RT_SUPPORTED_CONVERT_POINTER			0x0100
+#define EFI_RT_SUPPORTED_GET_NEXT_HIGH_MONOTONIC_COUNT		0x0200
+#define EFI_RT_SUPPORTED_RESET_SYSTEM				0x0400
+#define EFI_RT_SUPPORTED_UPDATE_CAPSULE				0x0800
+#define EFI_RT_SUPPORTED_QUERY_CAPSULE_CAPABILITIES		0x1000
+#define EFI_RT_SUPPORTED_QUERY_VARIABLE_INFO			0x2000
+
+#define EFI_RT_SUPPORTED_ALL					0x3fff
+
+#define EFI_RT_SUPPORTED_TIME_SERVICES				0x000f
+#define EFI_RT_SUPPORTED_VARIABLE_SERVICES			0x0070
+
 extern struct mm_struct efi_mm;
 
 static inline int
@@ -761,6 +782,11 @@ static inline bool __pure efi_soft_reserve_enabled(void)
 	return IS_ENABLED(CONFIG_EFI_SOFT_RESERVE)
 		&& __efi_soft_reserve_enabled();
 }
+
+static inline bool efi_rt_services_supported(unsigned int mask)
+{
+	return (efi.runtime_supported_mask & mask) == mask;
+}
 #else
 static inline bool efi_enabled(int feature)
 {
@@ -779,6 +805,11 @@ static inline bool efi_soft_reserve_enabled(void)
 {
 	return false;
 }
+
+static inline bool efi_rt_services_supported(unsigned int mask)
+{
+	return false;
+}
 #endif
 
 extern int efi_status_to_err(efi_status_t status);

commit 3b2e4b4c634cc7dd4730ce3e1c75b8206dcc4b04
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Feb 18 10:19:34 2020 +0100

    efi/arm: Move FDT specific definitions into fdtparams.c
    
    Push the FDT params specific types and definition into fdtparams.c,
    and instead, pass a reference to the memory map data structure and
    populate it directly, and return the system table address as the
    return value.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 575e6aa39514..a0008e3d4e9d 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -477,14 +477,6 @@ struct efi_mem_range {
 	u64 attribute;
 };
 
-struct efi_fdt_params {
-	u64 system_table;
-	u64 mmap;
-	u32 mmap_size;
-	u32 desc_size;
-	u32 desc_ver;
-};
-
 typedef struct {
 	u32 version;
 	u32 length;
@@ -631,7 +623,7 @@ extern void efi_mem_reserve(phys_addr_t addr, u64 size);
 extern int efi_mem_reserve_persistent(phys_addr_t addr, u64 size);
 extern void efi_initialize_iomem_resources(struct resource *code_resource,
 		struct resource *data_resource, struct resource *bss_resource);
-extern int efi_get_fdt_params(struct efi_fdt_params *params);
+extern u64 efi_get_fdt_params(struct efi_memory_map_data *data);
 extern struct kobject *efi_kobj;
 
 extern int efi_reboot_quirk_mode;

commit fd26830423e5f7442001f090cd4a53f4b6c3d9fa
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Jan 21 10:16:32 2020 +0100

    efi/x86: Drop 'systab' member from struct efi
    
    The systab member in struct efi has outlived its usefulness, now that
    we have better ways to access the only piece of information we are
    interested in after init, which is the EFI runtime services table
    address. So instead of instantiating a doctored copy at early boot
    with lots of mangled values, and switching the pointer when switching
    into virtual mode, let's grab the values we need directly, and get
    rid of the systab pointer entirely.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 1f69c4c2dd5c..575e6aa39514 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -530,31 +530,33 @@ typedef struct {
  */
 extern struct efi {
 	const efi_runtime_services_t	*runtime;		/* EFI runtime services table */
-	efi_system_table_t *systab;	/* EFI system table */
-	unsigned int runtime_version;	/* Runtime services version */
-	unsigned long acpi;		/* ACPI table  (IA64 ext 0.71) */
-	unsigned long acpi20;		/* ACPI table  (ACPI 2.0) */
-	unsigned long smbios;		/* SMBIOS table (32 bit entry point) */
-	unsigned long smbios3;		/* SMBIOS table (64 bit entry point) */
-	unsigned long esrt;		/* ESRT table */
-	unsigned long tpm_log;		/* TPM2 Event Log table */
-	unsigned long tpm_final_log;	/* TPM2 Final Events Log table */
-	efi_get_time_t *get_time;
-	efi_set_time_t *set_time;
-	efi_get_wakeup_time_t *get_wakeup_time;
-	efi_set_wakeup_time_t *set_wakeup_time;
-	efi_get_variable_t *get_variable;
-	efi_get_next_variable_t *get_next_variable;
-	efi_set_variable_t *set_variable;
-	efi_set_variable_t *set_variable_nonblocking;
-	efi_query_variable_info_t *query_variable_info;
-	efi_query_variable_info_t *query_variable_info_nonblocking;
-	efi_update_capsule_t *update_capsule;
-	efi_query_capsule_caps_t *query_capsule_caps;
-	efi_get_next_high_mono_count_t *get_next_high_mono_count;
-	efi_reset_system_t *reset_system;
-	struct efi_memory_map memmap;
-	unsigned long flags;
+	unsigned int			runtime_version;	/* Runtime services version */
+
+	unsigned long			acpi;			/* ACPI table  (IA64 ext 0.71) */
+	unsigned long			acpi20;			/* ACPI table  (ACPI 2.0) */
+	unsigned long			smbios;			/* SMBIOS table (32 bit entry point) */
+	unsigned long			smbios3;		/* SMBIOS table (64 bit entry point) */
+	unsigned long			esrt;			/* ESRT table */
+	unsigned long			tpm_log;		/* TPM2 Event Log table */
+	unsigned long			tpm_final_log;		/* TPM2 Final Events Log table */
+
+	efi_get_time_t			*get_time;
+	efi_set_time_t			*set_time;
+	efi_get_wakeup_time_t		*get_wakeup_time;
+	efi_set_wakeup_time_t		*set_wakeup_time;
+	efi_get_variable_t		*get_variable;
+	efi_get_next_variable_t		*get_next_variable;
+	efi_set_variable_t		*set_variable;
+	efi_set_variable_t		*set_variable_nonblocking;
+	efi_query_variable_info_t	*query_variable_info;
+	efi_query_variable_info_t	*query_variable_info_nonblocking;
+	efi_update_capsule_t		*update_capsule;
+	efi_query_capsule_caps_t	*query_capsule_caps;
+	efi_get_next_high_mono_count_t	*get_next_high_mono_count;
+	efi_reset_system_t		*reset_system;
+
+	struct efi_memory_map		memmap;
+	unsigned long			flags;
 } efi;
 
 extern struct mm_struct efi_mm;

commit 59f2a619a2db86111e8bb30f349aebff6eb75baa
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Jan 21 09:44:43 2020 +0100

    efi: Add 'runtime' pointer to struct efi
    
    Instead of going through the EFI system table each time, just copy the
    runtime services table pointer into struct efi directly. This is the
    last use of the system table pointer in struct efi, allowing us to
    drop it in a future patch, along with a fair amount of quirky handling
    of the translated address.
    
    Note that usually, the runtime services pointer changes value during
    the call to SetVirtualAddressMap(), so grab the updated value as soon
    as that call returns. (Mixed mode uses a 1:1 mapping, and kexec boot
    enters with the updated address in the system table, so in those cases,
    we don't need to do anything here)
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index a42045568df3..1f69c4c2dd5c 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -529,6 +529,7 @@ typedef struct {
  * All runtime access to EFI goes through this structure:
  */
 extern struct efi {
+	const efi_runtime_services_t	*runtime;		/* EFI runtime services table */
 	efi_system_table_t *systab;	/* EFI system table */
 	unsigned int runtime_version;	/* Runtime services version */
 	unsigned long acpi;		/* ACPI table  (IA64 ext 0.71) */

commit 9cd437ac0ef4f324a92e2579784b03bb487ae7fb
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Jan 20 17:23:21 2020 +0100

    efi/x86: Make fw_vendor, config_table and runtime sysfs nodes x86 specific
    
    There is some code that exposes physical addresses of certain parts of
    the EFI firmware implementation via sysfs nodes. These nodes are only
    used on x86, and are of dubious value to begin with, so let's move
    their handling into the x86 arch code.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 99a7fcbe5e9b..a42045568df3 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -535,9 +535,6 @@ extern struct efi {
 	unsigned long acpi20;		/* ACPI table  (ACPI 2.0) */
 	unsigned long smbios;		/* SMBIOS table (32 bit entry point) */
 	unsigned long smbios3;		/* SMBIOS table (64 bit entry point) */
-	unsigned long fw_vendor;	/* fw_vendor */
-	unsigned long runtime;		/* runtime table */
-	unsigned long config_table;	/* config tables */
 	unsigned long esrt;		/* ESRT table */
 	unsigned long tpm_log;		/* TPM2 Event Log table */
 	unsigned long tpm_final_log;	/* TPM2 Final Events Log table */

commit 06c0bd93434c5b9b284773f90bb054aff591d5be
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Wed Jan 22 14:40:57 2020 +0100

    efi: Clean up config_parse_tables()
    
    config_parse_tables() is a jumble of pointer arithmetic, due to the
    fact that on x86, we may be dealing with firmware whose native word
    size differs from the kernel's.
    
    This is not a concern on other architectures, and doesn't quite
    justify the state of the code, so let's clean it up by adding a
    non-x86 code path, constifying statically allocated tables and
    replacing preprocessor conditionals with IS_ENABLED() checks.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index d61c25fd5824..99a7fcbe5e9b 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -613,8 +613,9 @@ extern void __init efi_esrt_init(void);
 #else
 static inline void efi_esrt_init(void) { }
 #endif
-extern int efi_config_parse_tables(void *config_tables, int count, int sz,
-				   efi_config_table_type_t *arch_tables);
+extern int efi_config_parse_tables(const efi_config_table_t *config_tables,
+				   int count,
+				   const efi_config_table_type_t *arch_tables);
 extern int efi_systab_check_header(const efi_table_hdr_t *systab_hdr,
 				   int min_major_version);
 extern void efi_systab_report_header(const efi_table_hdr_t *systab_hdr,

commit 3a0701dc7ff8ebe1031a9f64c99c638929cd2d70
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Jan 20 17:17:27 2020 +0100

    efi: Make efi_config_init() x86 only
    
    The efi_config_init() routine is no longer shared with ia64 so let's
    move it into the x86 arch code before making further x86 specific
    changes to it.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 287510e84dfb..d61c25fd5824 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -608,7 +608,6 @@ extern int __init efi_memmap_split_count(efi_memory_desc_t *md,
 extern void __init efi_memmap_insert(struct efi_memory_map *old_memmap,
 				     void *buf, struct efi_mem_range *mem);
 
-extern int efi_config_init(efi_config_table_type_t *arch_tables);
 #ifdef CONFIG_EFI_ESRT
 extern void __init efi_esrt_init(void);
 #else

commit 14fb4209094355928d5a742e35afabdf7b404c17
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Jan 20 10:49:11 2020 +0100

    efi: Merge EFI system table revision and vendor checks
    
    We have three different versions of the code that checks the EFI system
    table revision and copies the firmware vendor string, and they are
    mostly equivalent, with the exception of the use of early_memremap_ro
    vs. __va() and the lowest major revision to warn about. Let's move this
    into common code and factor out the commonalities.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index a5e210abe4ca..287510e84dfb 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -616,6 +616,10 @@ static inline void efi_esrt_init(void) { }
 #endif
 extern int efi_config_parse_tables(void *config_tables, int count, int sz,
 				   efi_config_table_type_t *arch_tables);
+extern int efi_systab_check_header(const efi_table_hdr_t *systab_hdr,
+				   int min_major_version);
+extern void efi_systab_report_header(const efi_table_hdr_t *systab_hdr,
+				     unsigned long fw_vendor);
 extern u64 efi_get_iobase (void);
 extern int efi_mem_type(unsigned long phys_addr);
 extern u64 efi_mem_attributes (unsigned long phys_addr);

commit b7846e6be235c4a19337a32168b27ed836a1504e
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Wed Jan 22 15:06:54 2020 +0100

    efi: Make memreserve table handling local to efi.c
    
    There is no need for struct efi to carry the address of the memreserve
    table and share it with the world. So move it out and make it
    __initdata as well.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index b093fce1cf59..a5e210abe4ca 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -541,7 +541,6 @@ extern struct efi {
 	unsigned long esrt;		/* ESRT table */
 	unsigned long tpm_log;		/* TPM2 Event Log table */
 	unsigned long tpm_final_log;	/* TPM2 Final Events Log table */
-	unsigned long mem_reserve;	/* Linux EFI memreserve table */
 	efi_get_time_t *get_time;
 	efi_set_time_t *set_time;
 	efi_get_wakeup_time_t *get_wakeup_time;

commit a17e809ea573e69474064ba2bbff06d212861e19
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Wed Jan 22 15:05:12 2020 +0100

    efi: Move mem_attr_table out of struct efi
    
    The memory attributes table is only used at init time by the core EFI
    code, so there is no need to carry its address in struct efi that is
    shared with the world. So move it out, and make it __ro_after_init as
    well, considering that the value is set during early boot.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 36380542e054..b093fce1cf59 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -539,7 +539,6 @@ extern struct efi {
 	unsigned long runtime;		/* runtime table */
 	unsigned long config_table;	/* config tables */
 	unsigned long esrt;		/* ESRT table */
-	unsigned long mem_attr_table;	/* memory attributes table */
 	unsigned long tpm_log;		/* TPM2 Event Log table */
 	unsigned long tpm_final_log;	/* TPM2 Final Events Log table */
 	unsigned long mem_reserve;	/* Linux EFI memreserve table */
@@ -641,6 +640,8 @@ extern void __init efi_fake_memmap(void);
 static inline void efi_fake_memmap(void) { }
 #endif
 
+extern unsigned long efi_mem_attr_table;
+
 /*
  * efi_memattr_perm_setter - arch specific callback function passed into
  *                           efi_memattr_apply_permissions() that updates the

commit 5d288dbd88606d8f215c7138b10649115d79cadd
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Wed Jan 22 14:58:15 2020 +0100

    efi: Make rng_seed table handling local to efi.c
    
    Move the rng_seed table address from struct efi into a static global
    variable in efi.c, which is the only place we ever refer to it anyway.
    This reduces the footprint of struct efi, which is a r/w data structure
    that is shared with the world.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index e091f2aff61d..36380542e054 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -540,7 +540,6 @@ extern struct efi {
 	unsigned long config_table;	/* config tables */
 	unsigned long esrt;		/* ESRT table */
 	unsigned long mem_attr_table;	/* memory attributes table */
-	unsigned long rng_seed;		/* UEFI firmware random seed */
 	unsigned long tpm_log;		/* TPM2 Event Log table */
 	unsigned long tpm_final_log;	/* TPM2 Final Events Log table */
 	unsigned long mem_reserve;	/* Linux EFI memreserve table */

commit fd506e0cf9fd4306aa0eb57cbff5f00514da8179
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Sun Jan 19 16:17:59 2020 +0100

    efi: Move UGA and PROP table handling to x86 code
    
    The UGA table is x86 specific (its handling was introduced when the
    EFI support code was modified to accommodate IA32), so there is no
    need to handle it in generic code.
    
    The EFI properties table is not strictly x86 specific, but it was
    deprecated almost immediately after having been introduced, due to
    implementation difficulties. Only x86 takes it into account today,
    and this is not going to change, so make this table x86 only as well.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 45443932104f..e091f2aff61d 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -535,12 +535,10 @@ extern struct efi {
 	unsigned long acpi20;		/* ACPI table  (ACPI 2.0) */
 	unsigned long smbios;		/* SMBIOS table (32 bit entry point) */
 	unsigned long smbios3;		/* SMBIOS table (64 bit entry point) */
-	unsigned long uga;		/* UGA table */
 	unsigned long fw_vendor;	/* fw_vendor */
 	unsigned long runtime;		/* runtime table */
 	unsigned long config_table;	/* config tables */
 	unsigned long esrt;		/* ESRT table */
-	unsigned long properties_table;	/* properties table */
 	unsigned long mem_attr_table;	/* memory attributes table */
 	unsigned long rng_seed;		/* UEFI firmware random seed */
 	unsigned long tpm_log;		/* TPM2 Event Log table */

commit 120540f230d5d2d32846adc0156b58961c8c59d1
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Sun Jan 19 15:43:53 2020 +0100

    efi/ia64: Move HCDP and MPS table handling into IA64 arch code
    
    The HCDP and MPS tables are Itanium specific EFI config tables, so
    move their handling to ia64 arch code.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index c517d3b7986b..45443932104f 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -531,12 +531,10 @@ typedef struct {
 extern struct efi {
 	efi_system_table_t *systab;	/* EFI system table */
 	unsigned int runtime_version;	/* Runtime services version */
-	unsigned long mps;		/* MPS table */
 	unsigned long acpi;		/* ACPI table  (IA64 ext 0.71) */
 	unsigned long acpi20;		/* ACPI table  (ACPI 2.0) */
 	unsigned long smbios;		/* SMBIOS table (32 bit entry point) */
 	unsigned long smbios3;		/* SMBIOS table (64 bit entry point) */
-	unsigned long hcdp;		/* HCDP table */
 	unsigned long uga;		/* UGA table */
 	unsigned long fw_vendor;	/* fw_vendor */
 	unsigned long runtime;		/* runtime table */

commit 50d53c58dd77d3b0b6a5afe391eaac3722fc3153
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Sun Jan 19 15:29:21 2020 +0100

    efi: Drop handling of 'boot_info' configuration table
    
    Some plumbing exists to handle a UEFI configuration table of type
    BOOT_INFO but since we never match it to a GUID anywhere, we never
    actually register such a table, or access it, for that matter. So
    simply drop all mentions of it.
    
    Tested-by: Tony Luck <tony.luck@intel.com> # arch/ia64
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 1bf482daa22d..c517d3b7986b 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -536,7 +536,6 @@ extern struct efi {
 	unsigned long acpi20;		/* ACPI table  (ACPI 2.0) */
 	unsigned long smbios;		/* SMBIOS table (32 bit entry point) */
 	unsigned long smbios3;		/* SMBIOS table (64 bit entry point) */
-	unsigned long boot_info;	/* boot info table */
 	unsigned long hcdp;		/* HCDP table */
 	unsigned long uga;		/* UGA table */
 	unsigned long fw_vendor;	/* fw_vendor */

commit ec93fc371f014a6fb483e3556061ecad4b40735c
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 3 23:45:14 2020 +0000

    efi/libstub: Add support for loading the initrd from a device path
    
    There are currently two ways to specify the initrd to be passed to the
    Linux kernel when booting via the EFI stub:
    - it can be passed as a initrd= command line option when doing a pure PE
      boot (as opposed to the EFI handover protocol that exists for x86)
    - otherwise, the bootloader or firmware can load the initrd into memory,
      and pass the address and size via the bootparams struct (x86) or
      device tree (ARM)
    
    In the first case, we are limited to loading from the same file system
    that the kernel was loaded from, and it is also problematic in a trusted
    boot context, given that we cannot easily protect the command line from
    tampering without either adding complicated white/blacklisting of boot
    arguments or locking down the command line altogether.
    
    In the second case, we force the bootloader to duplicate knowledge about
    the boot protocol which is already encoded in the stub, and which may be
    subject to change over time, e.g., bootparams struct definitions, memory
    allocation/alignment requirements for the placement of the initrd etc etc.
    In the ARM case, it also requires the bootloader to modify the hardware
    description provided by the firmware, as it is passed in the same file.
    On systems where the initrd is measured after loading, it creates a time
    window where the initrd contents might be manipulated in memory before
    handing over to the kernel.
    
    Address these concerns by adding support for loading the initrd into
    memory by invoking the EFI LoadFile2 protocol installed on a vendor
    GUIDed device path that specifically designates a Linux initrd.
    This addresses the above concerns, by putting the EFI stub in charge of
    placement in memory and of passing the base and size to the kernel proper
    (via whatever means it desires) while still leaving it up to the firmware
    or bootloader to obtain the file contents, potentially from other file
    systems than the one the kernel itself was loaded from. On platforms that
    implement measured boot, it permits the firmware to take the measurement
    right before the kernel actually consumes the contents.
    
    Acked-by: Laszlo Ersek <lersek@redhat.com>
    Tested-by: Ilias Apalodimas <ilias.apalodimas@linaro.org>
    Acked-by: Ilias Apalodimas <ilias.apalodimas@linaro.org>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 0976e57b4caa..1bf482daa22d 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -353,6 +353,7 @@ void efi_native_runtime_setup(void);
 #define LINUX_EFI_TPM_EVENT_LOG_GUID		EFI_GUID(0xb7799cb0, 0xeca2, 0x4943,  0x96, 0x67, 0x1f, 0xae, 0x07, 0xb7, 0x47, 0xfa)
 #define LINUX_EFI_TPM_FINAL_LOG_GUID		EFI_GUID(0x1e2ed096, 0x30e2, 0x4254,  0xbd, 0x89, 0x86, 0x3b, 0xbe, 0xf8, 0x23, 0x25)
 #define LINUX_EFI_MEMRESERVE_TABLE_GUID		EFI_GUID(0x888eb0c6, 0x8ede, 0x4ff5,  0xa8, 0xf0, 0x9a, 0xee, 0x5c, 0xb9, 0x77, 0xc2)
+#define LINUX_EFI_INITRD_MEDIA_GUID		EFI_GUID(0x5568e427, 0x68fc, 0x4f3d,  0xac, 0x74, 0xca, 0x55, 0x52, 0x31, 0xcc, 0x68)
 
 /* OEM GUIDs */
 #define DELLEMC_EFI_RCI2_TABLE_GUID		EFI_GUID(0x2d9f28a2, 0xa886, 0x456a,  0x97, 0xa8, 0xf1, 0x1e, 0xf2, 0x4f, 0xf4, 0x55)

commit db8952e7094fde3a397321240d5d57ec111258d8
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 10 08:46:57 2020 +0000

    efi/dev-path-parser: Add struct definition for vendor type device path nodes
    
    In preparation of adding support for loading the initrd via a special
    device path, add the struct definition of a vendor GUIDed device path
    node to efi.h.
    
    Since we will be producing these data structures rather than just
    consumsing the ones instantiated by the firmware, refactor the various
    device path node definitions so we can take the size of each node using
    sizeof() rather than having to resort to opaque arithmetic in the static
    initializers.
    
    While at it, drop the #if IS_ENABLED() check for the declaration of
    efi_get_device_by_path(), which is unnecessary, and constify its first
    argument as well.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 9ccf313fe9de..0976e57b4caa 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -855,30 +855,40 @@ extern int efi_status_to_err(efi_status_t status);
 #define   EFI_DEV_END_ENTIRE			0xFF
 
 struct efi_generic_dev_path {
-	u8 type;
-	u8 sub_type;
-	u16 length;
-} __attribute ((packed));
+	u8				type;
+	u8				sub_type;
+	u16				length;
+} __packed;
+
+struct efi_acpi_dev_path {
+	struct efi_generic_dev_path	header;
+	u32				hid;
+	u32				uid;
+} __packed;
+
+struct efi_pci_dev_path {
+	struct efi_generic_dev_path	header;
+	u8				fn;
+	u8				dev;
+} __packed;
+
+struct efi_vendor_dev_path {
+	struct efi_generic_dev_path	header;
+	efi_guid_t			vendorguid;
+	u8				vendordata[];
+} __packed;
 
 struct efi_dev_path {
-	u8 type;	/* can be replaced with unnamed */
-	u8 sub_type;	/* struct efi_generic_dev_path; */
-	u16 length;	/* once we've moved to -std=c11 */
 	union {
-		struct {
-			u32 hid;
-			u32 uid;
-		} acpi;
-		struct {
-			u8 fn;
-			u8 dev;
-		} pci;
+		struct efi_generic_dev_path	header;
+		struct efi_acpi_dev_path	acpi;
+		struct efi_pci_dev_path		pci;
+		struct efi_vendor_dev_path	vendor;
 	};
-} __attribute ((packed));
+} __packed;
 
-#if IS_ENABLED(CONFIG_EFI_DEV_PATH_PARSER)
-struct device *efi_get_device_by_path(struct efi_dev_path **node, size_t *len);
-#endif
+struct device *efi_get_device_by_path(const struct efi_dev_path **node,
+				      size_t *len);
 
 static inline void memrange_efi_to_native(u64 *addr, u64 *npages)
 {

commit 2931d526d5674940d916a4b513a681ee3562e574
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 10 17:02:48 2020 +0100

    efi/libstub: Make the LoadFile EFI protocol accessible
    
    Add the protocol definitions, GUIDs and mixed mode glue so that
    the EFI loadfile protocol can be used from the stub. This will
    be used in a future patch to load the initrd.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 0e047d2738cd..9ccf313fe9de 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -332,6 +332,8 @@ void efi_native_runtime_setup(void);
 #define EFI_CONSOLE_OUT_DEVICE_GUID		EFI_GUID(0xd3b36f2c, 0xd551, 0x11d4,  0x9a, 0x46, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
 #define APPLE_PROPERTIES_PROTOCOL_GUID		EFI_GUID(0x91bd12fe, 0xf6c3, 0x44fb,  0xa5, 0xb7, 0x51, 0x22, 0xab, 0x30, 0x3a, 0xe0)
 #define EFI_TCG2_PROTOCOL_GUID			EFI_GUID(0x607f766c, 0x7455, 0x42be,  0x93, 0x0b, 0xe4, 0xd7, 0x6d, 0xb2, 0x72, 0x0f)
+#define EFI_LOAD_FILE_PROTOCOL_GUID		EFI_GUID(0x56ec3091, 0x954c, 0x11d2,  0x8e, 0x3f, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)
+#define EFI_LOAD_FILE2_PROTOCOL_GUID		EFI_GUID(0x4006c0c1, 0xfcb3, 0x403e,  0x99, 0x6d, 0x4a, 0x6c, 0x87, 0x24, 0xe0, 0x6d)
 
 #define EFI_IMAGE_SECURITY_DATABASE_GUID	EFI_GUID(0xd719b2cb, 0x3d3a, 0x4596,  0xa3, 0xbc, 0xda, 0xd0, 0x0e, 0x67, 0x65, 0x6f)
 #define EFI_SHIM_LOCK_GUID			EFI_GUID(0x605dab50, 0xe046, 0x4300,  0xab, 0xb6, 0x3d, 0xd8, 0x10, 0xdd, 0x8b, 0x23)

commit 8166ec091573fad528d884ede291fd1ec02d0298
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 10 17:02:38 2020 +0100

    efi/libstub: Move stub specific declarations into efistub.h
    
    Move all the declarations that are only used in stub code from
    linux/efi.h to efistub.h which is only included locally.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 2b228df18407..0e047d2738cd 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -56,19 +56,6 @@ typedef void *efi_handle_t;
 #define __efiapi
 #endif
 
-#define efi_get_handle_at(array, idx)					\
-	(efi_is_native() ? (array)[idx] 				\
-		: (efi_handle_t)(unsigned long)((u32 *)(array))[idx])
-
-#define efi_get_handle_num(size)					\
-	((size) / (efi_is_native() ? sizeof(efi_handle_t) : sizeof(u32)))
-
-#define for_each_efi_handle(handle, array, size, i)			\
-	for (i = 0;							\
-	     i < efi_get_handle_num(size) &&				\
-		((handle = efi_get_handle_at((array), i)) || true);	\
-	     i++)
-
 /*
  * The UEFI spec and EDK2 reference implementation both define EFI_GUID as
  * struct { u32 a; u16; b; u16 c; u8 d[8]; }; and so the implied alignment
@@ -157,15 +144,6 @@ typedef struct {
 	u32 imagesize;
 } efi_capsule_header_t;
 
-struct efi_boot_memmap {
-	efi_memory_desc_t	**map;
-	unsigned long		*map_size;
-	unsigned long		*desc_size;
-	u32			*desc_ver;
-	unsigned long		*key_ptr;
-	unsigned long		*buff_size;
-};
-
 /*
  * EFI capsule flags
  */
@@ -187,14 +165,6 @@ struct capsule_info {
 
 int __efi_capsule_setup_info(struct capsule_info *cap_info);
 
-/*
- * Allocation types for calls to boottime->allocate_pages.
- */
-#define EFI_ALLOCATE_ANY_PAGES		0
-#define EFI_ALLOCATE_MAX_ADDRESS	1
-#define EFI_ALLOCATE_ADDRESS		2
-#define EFI_MAX_ALLOCATE_TYPE		3
-
 typedef int (*efi_freemem_callback_t) (u64 start, u64 end, void *arg);
 
 /*
@@ -224,291 +194,7 @@ typedef struct {
 	u8 sets_to_zero;
 } efi_time_cap_t;
 
-typedef struct {
-	efi_table_hdr_t hdr;
-	u32 raise_tpl;
-	u32 restore_tpl;
-	u32 allocate_pages;
-	u32 free_pages;
-	u32 get_memory_map;
-	u32 allocate_pool;
-	u32 free_pool;
-	u32 create_event;
-	u32 set_timer;
-	u32 wait_for_event;
-	u32 signal_event;
-	u32 close_event;
-	u32 check_event;
-	u32 install_protocol_interface;
-	u32 reinstall_protocol_interface;
-	u32 uninstall_protocol_interface;
-	u32 handle_protocol;
-	u32 __reserved;
-	u32 register_protocol_notify;
-	u32 locate_handle;
-	u32 locate_device_path;
-	u32 install_configuration_table;
-	u32 load_image;
-	u32 start_image;
-	u32 exit;
-	u32 unload_image;
-	u32 exit_boot_services;
-	u32 get_next_monotonic_count;
-	u32 stall;
-	u32 set_watchdog_timer;
-	u32 connect_controller;
-	u32 disconnect_controller;
-	u32 open_protocol;
-	u32 close_protocol;
-	u32 open_protocol_information;
-	u32 protocols_per_handle;
-	u32 locate_handle_buffer;
-	u32 locate_protocol;
-	u32 install_multiple_protocol_interfaces;
-	u32 uninstall_multiple_protocol_interfaces;
-	u32 calculate_crc32;
-	u32 copy_mem;
-	u32 set_mem;
-	u32 create_event_ex;
-} __packed efi_boot_services_32_t;
-
-/*
- * EFI Boot Services table
- */
-typedef union {
-	struct {
-		efi_table_hdr_t hdr;
-		void *raise_tpl;
-		void *restore_tpl;
-		efi_status_t (__efiapi *allocate_pages)(int, int, unsigned long,
-							efi_physical_addr_t *);
-		efi_status_t (__efiapi *free_pages)(efi_physical_addr_t,
-						    unsigned long);
-		efi_status_t (__efiapi *get_memory_map)(unsigned long *, void *,
-							unsigned long *,
-							unsigned long *, u32 *);
-		efi_status_t (__efiapi *allocate_pool)(int, unsigned long,
-						       void **);
-		efi_status_t (__efiapi *free_pool)(void *);
-		void *create_event;
-		void *set_timer;
-		void *wait_for_event;
-		void *signal_event;
-		void *close_event;
-		void *check_event;
-		void *install_protocol_interface;
-		void *reinstall_protocol_interface;
-		void *uninstall_protocol_interface;
-		efi_status_t (__efiapi *handle_protocol)(efi_handle_t,
-							 efi_guid_t *, void **);
-		void *__reserved;
-		void *register_protocol_notify;
-		efi_status_t (__efiapi *locate_handle)(int, efi_guid_t *,
-						       void *, unsigned long *,
-						       efi_handle_t *);
-		void *locate_device_path;
-		efi_status_t (__efiapi *install_configuration_table)(efi_guid_t *,
-								     void *);
-		void *load_image;
-		void *start_image;
-		void *exit;
-		void *unload_image;
-		efi_status_t (__efiapi *exit_boot_services)(efi_handle_t,
-							    unsigned long);
-		void *get_next_monotonic_count;
-		void *stall;
-		void *set_watchdog_timer;
-		void *connect_controller;
-		efi_status_t (__efiapi *disconnect_controller)(efi_handle_t,
-							       efi_handle_t,
-							       efi_handle_t);
-		void *open_protocol;
-		void *close_protocol;
-		void *open_protocol_information;
-		void *protocols_per_handle;
-		void *locate_handle_buffer;
-		efi_status_t (__efiapi *locate_protocol)(efi_guid_t *, void *,
-							 void **);
-		void *install_multiple_protocol_interfaces;
-		void *uninstall_multiple_protocol_interfaces;
-		void *calculate_crc32;
-		void *copy_mem;
-		void *set_mem;
-		void *create_event_ex;
-	};
-	efi_boot_services_32_t mixed_mode;
-} efi_boot_services_t;
-
-typedef enum {
-	EfiPciIoWidthUint8,
-	EfiPciIoWidthUint16,
-	EfiPciIoWidthUint32,
-	EfiPciIoWidthUint64,
-	EfiPciIoWidthFifoUint8,
-	EfiPciIoWidthFifoUint16,
-	EfiPciIoWidthFifoUint32,
-	EfiPciIoWidthFifoUint64,
-	EfiPciIoWidthFillUint8,
-	EfiPciIoWidthFillUint16,
-	EfiPciIoWidthFillUint32,
-	EfiPciIoWidthFillUint64,
-	EfiPciIoWidthMaximum
-} EFI_PCI_IO_PROTOCOL_WIDTH;
-
-typedef enum {
-	EfiPciIoAttributeOperationGet,
-	EfiPciIoAttributeOperationSet,
-	EfiPciIoAttributeOperationEnable,
-	EfiPciIoAttributeOperationDisable,
-	EfiPciIoAttributeOperationSupported,
-    EfiPciIoAttributeOperationMaximum
-} EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION;
-
-typedef struct {
-	u32 read;
-	u32 write;
-} efi_pci_io_protocol_access_32_t;
-
-typedef union efi_pci_io_protocol efi_pci_io_protocol_t;
-
-typedef
-efi_status_t (__efiapi *efi_pci_io_protocol_cfg_t)(efi_pci_io_protocol_t *,
-						   EFI_PCI_IO_PROTOCOL_WIDTH,
-						   u32 offset,
-						   unsigned long count,
-						   void *buffer);
-
-typedef struct {
-	void *read;
-	void *write;
-} efi_pci_io_protocol_access_t;
-
-typedef struct {
-	efi_pci_io_protocol_cfg_t read;
-	efi_pci_io_protocol_cfg_t write;
-} efi_pci_io_protocol_config_access_t;
-
-union efi_pci_io_protocol {
-	struct {
-		void *poll_mem;
-		void *poll_io;
-		efi_pci_io_protocol_access_t mem;
-		efi_pci_io_protocol_access_t io;
-		efi_pci_io_protocol_config_access_t pci;
-		void *copy_mem;
-		void *map;
-		void *unmap;
-		void *allocate_buffer;
-		void *free_buffer;
-		void *flush;
-		efi_status_t (__efiapi *get_location)(efi_pci_io_protocol_t *,
-						      unsigned long *segment_nr,
-						      unsigned long *bus_nr,
-						      unsigned long *device_nr,
-						      unsigned long *func_nr);
-		void *attributes;
-		void *get_bar_attributes;
-		void *set_bar_attributes;
-		uint64_t romsize;
-		void *romimage;
-	};
-	struct {
-		u32 poll_mem;
-		u32 poll_io;
-		efi_pci_io_protocol_access_32_t mem;
-		efi_pci_io_protocol_access_32_t io;
-		efi_pci_io_protocol_access_32_t pci;
-		u32 copy_mem;
-		u32 map;
-		u32 unmap;
-		u32 allocate_buffer;
-		u32 free_buffer;
-		u32 flush;
-		u32 get_location;
-		u32 attributes;
-		u32 get_bar_attributes;
-		u32 set_bar_attributes;
-		u64 romsize;
-		u32 romimage;
-	} mixed_mode;
-};
-
-#define EFI_PCI_IO_ATTRIBUTE_ISA_MOTHERBOARD_IO 0x0001
-#define EFI_PCI_IO_ATTRIBUTE_ISA_IO 0x0002
-#define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO 0x0004
-#define EFI_PCI_IO_ATTRIBUTE_VGA_MEMORY 0x0008
-#define EFI_PCI_IO_ATTRIBUTE_VGA_IO 0x0010
-#define EFI_PCI_IO_ATTRIBUTE_IDE_PRIMARY_IO 0x0020
-#define EFI_PCI_IO_ATTRIBUTE_IDE_SECONDARY_IO 0x0040
-#define EFI_PCI_IO_ATTRIBUTE_MEMORY_WRITE_COMBINE 0x0080
-#define EFI_PCI_IO_ATTRIBUTE_IO 0x0100
-#define EFI_PCI_IO_ATTRIBUTE_MEMORY 0x0200
-#define EFI_PCI_IO_ATTRIBUTE_BUS_MASTER 0x0400
-#define EFI_PCI_IO_ATTRIBUTE_MEMORY_CACHED 0x0800
-#define EFI_PCI_IO_ATTRIBUTE_MEMORY_DISABLE 0x1000
-#define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_DEVICE 0x2000
-#define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_ROM 0x4000
-#define EFI_PCI_IO_ATTRIBUTE_DUAL_ADDRESS_CYCLE 0x8000
-#define EFI_PCI_IO_ATTRIBUTE_ISA_IO_16 0x10000
-#define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO_16 0x20000
-#define EFI_PCI_IO_ATTRIBUTE_VGA_IO_16 0x40000
-
-struct efi_dev_path;
-
-typedef union apple_properties_protocol apple_properties_protocol_t;
-
-union apple_properties_protocol {
-	struct {
-		unsigned long version;
-		efi_status_t (__efiapi *get)(apple_properties_protocol_t *,
-					     struct efi_dev_path *,
-					     efi_char16_t *, void *, u32 *);
-		efi_status_t (__efiapi *set)(apple_properties_protocol_t *,
-					     struct efi_dev_path *,
-					     efi_char16_t *, void *, u32);
-		efi_status_t (__efiapi *del)(apple_properties_protocol_t *,
-					     struct efi_dev_path *,
-					     efi_char16_t *);
-		efi_status_t (__efiapi *get_all)(apple_properties_protocol_t *,
-						 void *buffer, u32 *);
-	};
-	struct {
-		u32 version;
-		u32 get;
-		u32 set;
-		u32 del;
-		u32 get_all;
-	} mixed_mode;
-};
-
-typedef u32 efi_tcg2_event_log_format;
-
-typedef union efi_tcg2_protocol efi_tcg2_protocol_t;
-
-union efi_tcg2_protocol {
-	struct {
-		void *get_capability;
-		efi_status_t (__efiapi *get_event_log)(efi_handle_t,
-						       efi_tcg2_event_log_format,
-						       efi_physical_addr_t *,
-						       efi_physical_addr_t *,
-						       efi_bool_t *);
-		void *hash_log_extend_event;
-		void *submit_command;
-		void *get_active_pcr_banks;
-		void *set_active_pcr_banks;
-		void *get_result_of_set_active_pcr_banks;
-	};
-	struct {
-		u32 get_capability;
-		u32 get_event_log;
-		u32 hash_log_extend_event;
-		u32 submit_command;
-		u32 get_active_pcr_banks;
-		u32 set_active_pcr_banks;
-		u32 get_result_of_set_active_pcr_banks;
-	} mixed_mode;
-};
+typedef union efi_boot_services efi_boot_services_t;
 
 /*
  * Types and defines for EFI ResetSystem
@@ -796,8 +482,6 @@ struct efi_fdt_params {
 	u32 desc_ver;
 };
 
-typedef struct efi_loaded_image efi_loaded_image_t;
-
 typedef struct {
 	u32 version;
 	u32 length;
@@ -1130,13 +814,6 @@ extern int efi_status_to_err(efi_status_t status);
  */
 #define EFI_VARIABLE_GUID_LEN	UUID_STRING_LEN
 
-/*
- * The type of search to perform when calling boottime->locate_handle
- */
-#define EFI_LOCATE_ALL_HANDLES			0
-#define EFI_LOCATE_BY_REGISTER_NOTIFY		1
-#define EFI_LOCATE_BY_PROTOCOL			2
-
 /*
  * EFI Device Path information
  */
@@ -1254,80 +931,6 @@ struct efivar_entry {
 	bool deleting;
 };
 
-union efi_simple_text_output_protocol {
-	struct {
-		void *reset;
-		efi_status_t (__efiapi *output_string)(efi_simple_text_output_protocol_t *,
-						       efi_char16_t *);
-		void *test_string;
-	};
-	struct {
-		u32 reset;
-		u32 output_string;
-		u32 test_string;
-	} mixed_mode;
-};
-
-#define PIXEL_RGB_RESERVED_8BIT_PER_COLOR		0
-#define PIXEL_BGR_RESERVED_8BIT_PER_COLOR		1
-#define PIXEL_BIT_MASK					2
-#define PIXEL_BLT_ONLY					3
-#define PIXEL_FORMAT_MAX				4
-
-typedef struct {
-	u32 red_mask;
-	u32 green_mask;
-	u32 blue_mask;
-	u32 reserved_mask;
-} efi_pixel_bitmask_t;
-
-typedef struct {
-	u32 version;
-	u32 horizontal_resolution;
-	u32 vertical_resolution;
-	int pixel_format;
-	efi_pixel_bitmask_t pixel_information;
-	u32 pixels_per_scan_line;
-} efi_graphics_output_mode_info_t;
-
-typedef union efi_graphics_output_protocol_mode efi_graphics_output_protocol_mode_t;
-
-union efi_graphics_output_protocol_mode {
-	struct {
-		u32 max_mode;
-		u32 mode;
-		efi_graphics_output_mode_info_t *info;
-		unsigned long size_of_info;
-		efi_physical_addr_t frame_buffer_base;
-		unsigned long frame_buffer_size;
-	};
-	struct {
-		u32 max_mode;
-		u32 mode;
-		u32 info;
-		u32 size_of_info;
-		u64 frame_buffer_base;
-		u32 frame_buffer_size;
-	} mixed_mode;
-};
-
-typedef union efi_graphics_output_protocol efi_graphics_output_protocol_t;
-
-union efi_graphics_output_protocol {
-	struct {
-		void *query_mode;
-		void *set_mode;
-		void *blt;
-		efi_graphics_output_protocol_mode_t *mode;
-	};
-	struct {
-		u32 query_mode;
-		u32 set_mode;
-		u32 blt;
-		u32 mode;
-	} mixed_mode;
-};
-
 extern struct list_head efivar_sysfs_list;
 
 static inline void
@@ -1425,52 +1028,6 @@ static inline int efi_runtime_map_copy(void *buf, size_t bufsz)
 
 #endif
 
-/* prototypes shared between arch specific and generic stub code */
-
-void efi_printk(char *str);
-
-void efi_free(unsigned long size, unsigned long addr);
-
-char *efi_convert_cmdline(efi_loaded_image_t *image, int *cmd_line_len);
-
-efi_status_t efi_get_memory_map(struct efi_boot_memmap *map);
-
-efi_status_t efi_low_alloc_above(unsigned long size, unsigned long align,
-				 unsigned long *addr, unsigned long min);
-
-static inline
-efi_status_t efi_low_alloc(unsigned long size, unsigned long align,
-			   unsigned long *addr)
-{
-	/*
-	 * Don't allocate at 0x0. It will confuse code that
-	 * checks pointers against NULL. Skip the first 8
-	 * bytes so we start at a nice even number.
-	 */
-	return efi_low_alloc_above(size, align, addr, 0x8);
-}
-
-efi_status_t efi_allocate_pages(unsigned long size, unsigned long *addr,
-				unsigned long max);
-
-efi_status_t efi_relocate_kernel(unsigned long *image_addr,
-				 unsigned long image_size,
-				 unsigned long alloc_size,
-				 unsigned long preferred_addr,
-				 unsigned long alignment,
-				 unsigned long min_addr);
-
-efi_status_t handle_cmdline_files(efi_loaded_image_t *image,
-				  char *cmd_line, char *option_string,
-				  unsigned long max_addr,
-				  unsigned long *load_addr,
-				  unsigned long *load_size);
-
-efi_status_t efi_parse_options(char const *cmdline);
-
-efi_status_t efi_setup_gop(struct screen_info *si, efi_guid_t *proto,
-			   unsigned long size);
-
 #ifdef CONFIG_EFI
 extern bool efi_runtime_disabled(void);
 #else
@@ -1548,15 +1105,6 @@ void efi_retrieve_tpm2_eventlog(void);
 	arch_efi_call_virt_teardown();					\
 })
 
-typedef efi_status_t (*efi_exit_boot_map_processing)(
-	struct efi_boot_memmap *map,
-	void *priv);
-
-efi_status_t efi_exit_boot_services(void *handle,
-				    struct efi_boot_memmap *map,
-				    void *priv,
-				    efi_exit_boot_map_processing priv_func);
-
 #define EFI_RANDOM_SEED_SIZE		64U
 
 struct linux_efi_random_seed {
@@ -1643,6 +1191,4 @@ struct linux_efi_memreserve {
 #define EFI_MEMRESERVE_COUNT(size) (((size) - sizeof(struct linux_efi_memreserve)) \
 	/ sizeof(((struct linux_efi_memreserve *)0)->entry[0]))
 
-void efi_pci_disable_bridge_busmaster(void);
-
 #endif /* _LINUX_EFI_H */

commit a46a290a01149120f40f83a694d3e6041bcf8f70
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 10 17:02:37 2020 +0100

    efi/libstub: Use consistent type names for file I/O protocols
    
    Align the naming of efi_file_io_interface_t and efi_file_handle_t with
    the UEFI spec, and call them efi_simple_file_system_protocol_t and
    efi_file_protocol_t, respectively, using the same convention we use
    for all other type definitions that originate in the UEFI spec.
    
    While at it, move the definitions to efistub.h, so they are only seen
    by code that needs them.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 7e231c3cfb6f..2b228df18407 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -796,65 +796,7 @@ struct efi_fdt_params {
 	u32 desc_ver;
 };
 
-typedef struct {
-	u32 revision;
-	efi_handle_t parent_handle;
-	efi_system_table_t *system_table;
-	efi_handle_t device_handle;
-	void *file_path;
-	void *reserved;
-	u32 load_options_size;
-	void *load_options;
-	void *image_base;
-	__aligned_u64 image_size;
-	unsigned int image_code_type;
-	unsigned int image_data_type;
-	efi_status_t ( __efiapi *unload)(efi_handle_t image_handle);
-} efi_loaded_image_t;
-
-typedef struct {
-	u64 size;
-	u64 file_size;
-	u64 phys_size;
-	efi_time_t create_time;
-	efi_time_t last_access_time;
-	efi_time_t modification_time;
-	__aligned_u64 attribute;
-	efi_char16_t filename[1];
-} efi_file_info_t;
-
-typedef struct efi_file_handle efi_file_handle_t;
-
-struct efi_file_handle {
-	u64 revision;
-	efi_status_t (__efiapi *open)(efi_file_handle_t *,
-				      efi_file_handle_t **,
-				      efi_char16_t *, u64, u64);
-	efi_status_t (__efiapi *close)(efi_file_handle_t *);
-	void *delete;
-	efi_status_t (__efiapi *read)(efi_file_handle_t *,
-				      unsigned long *, void *);
-	void *write;
-	void *get_position;
-	void *set_position;
-	efi_status_t (__efiapi *get_info)(efi_file_handle_t *,
-					  efi_guid_t *, unsigned long *,
-					  void *);
-	void *set_info;
-	void *flush;
-};
-
-typedef struct efi_file_io_interface efi_file_io_interface_t;
-
-struct efi_file_io_interface {
-	u64 revision;
-	int (__efiapi *open_volume)(efi_file_io_interface_t *,
-				    efi_file_handle_t **);
-};
-
-#define EFI_FILE_MODE_READ	0x0000000000000001
-#define EFI_FILE_MODE_WRITE	0x0000000000000002
-#define EFI_FILE_MODE_CREATE	0x8000000000000000
+typedef struct efi_loaded_image efi_loaded_image_t;
 
 typedef struct {
 	u32 version;

commit a7495c28c86ab3b31508c5754bc5fb717ab1169c
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Mon Feb 10 17:02:35 2020 +0100

    efi/libstub: Simplify efi_high_alloc() and rename to efi_allocate_pages()
    
    The implementation of efi_high_alloc() uses a complicated way of
    traversing the memory map to find an available region that is located
    as close as possible to the provided upper limit, and calls AllocatePages
    subsequently to create the allocation at that exact address.
    
    This is precisely what the EFI_ALLOCATE_MAX_ADDRESS allocation type
    argument to AllocatePages() does, and considering that EFI_ALLOC_ALIGN
    only exceeds EFI_PAGE_SIZE on arm64, let's use AllocatePages() directly
    and implement the alignment using code that the compiler can remove if
    it does not exceed EFI_PAGE_SIZE.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 7efd7072cca5..7e231c3cfb6f 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1508,8 +1508,8 @@ efi_status_t efi_low_alloc(unsigned long size, unsigned long align,
 	return efi_low_alloc_above(size, align, addr, 0x8);
 }
 
-efi_status_t efi_high_alloc(unsigned long size, unsigned long align,
-			    unsigned long *addr, unsigned long max);
+efi_status_t efi_allocate_pages(unsigned long size, unsigned long *addr,
+				unsigned long max);
 
 efi_status_t efi_relocate_kernel(unsigned long *image_addr,
 				 unsigned long image_size,

commit 484a418d075488c6999528247cc711d12c373447
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jan 13 18:22:45 2020 +0100

    efi: Fix handling of multiple efi_fake_mem= entries
    
    Dave noticed that when specifying multiple efi_fake_mem= entries only
    the last entry was successfully being reflected in the efi memory map.
    This is due to the fact that the efi_memmap_insert() is being called
    multiple times, but on successive invocations the insertion should be
    applied to the last new memmap rather than the original map at
    efi_fake_memmap() entry.
    
    Rework efi_fake_memmap() to install the new memory map after each
    efi_fake_mem= entry is parsed.
    
    This also fixes an issue in efi_fake_memmap() that caused it to litter
    emtpy entries into the end of the efi memory map. An empty entry causes
    efi_memmap_insert() to attempt more memmap splits / copies than
    efi_memmap_split_count() accounted for when sizing the new map. When
    that happens efi_memmap_insert() may overrun its allocation, and if you
    are lucky will spill over to an unmapped page leading to crash
    signature like the following rather than silent corruption:
    
        BUG: unable to handle page fault for address: ffffffffff281000
        [..]
        RIP: 0010:efi_memmap_insert+0x11d/0x191
        [..]
        Call Trace:
         ? bgrt_init+0xbe/0xbe
         ? efi_arch_mem_reserve+0x1cb/0x228
         ? acpi_parse_bgrt+0xa/0xd
         ? acpi_table_parse+0x86/0xb8
         ? acpi_boot_init+0x494/0x4e3
         ? acpi_parse_x2apic+0x87/0x87
         ? setup_acpi_sci+0xa2/0xa2
         ? setup_arch+0x8db/0x9e1
         ? start_kernel+0x6a/0x547
         ? secondary_startup_64+0xb6/0xc0
    
    Commit af1648984828 "x86/efi: Update e820 with reserved EFI boot
    services data to fix kexec breakage" introduced more occurrences where
    efi_memmap_insert() is invoked after an efi_fake_mem= configuration has
    been parsed. Previously the side effects of vestigial empty entries were
    benign, but with commit af1648984828 that follow-on efi_memmap_insert()
    invocation triggers efi_memmap_insert() overruns.
    
    Reported-by: Dave Young <dyoung@redhat.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20191231014630.GA24942@dhcp-128-65.nay.redhat.com
    Link: https://lore.kernel.org/r/20200113172245.27925-14-ardb@kernel.org

diff --git a/include/linux/efi.h b/include/linux/efi.h
index adbe421835c1..7efd7072cca5 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -976,6 +976,8 @@ extern void __iomem *efi_lookup_mapped_addr(u64 phys_addr);
 
 extern int __init efi_memmap_alloc(unsigned int num_entries,
 				   struct efi_memory_map_data *data);
+extern void __efi_memmap_free(u64 phys, unsigned long size,
+			      unsigned long flags);
 extern int __init efi_memmap_init_early(struct efi_memory_map_data *data);
 extern int __init efi_memmap_init_late(phys_addr_t addr, unsigned long size);
 extern void __init efi_memmap_unmap(void);

commit 1db91035d01aa8bfa2350c00ccb63d629b4041ad
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jan 13 18:22:43 2020 +0100

    efi: Add tracking for dynamically allocated memmaps
    
    In preparation for fixing efi_memmap_alloc() leaks, add support for
    recording whether the memmap was dynamically allocated from slab,
    memblock, or is the original physical memmap provided by the platform.
    
    Given this tracking is established in efi_memmap_alloc() and needs to be
    carried to efi_memmap_install(), use 'struct efi_memory_map_data' to
    convey the flags.
    
    Some small cleanups result from this reorganization, specifically the
    removal of local variables for 'phys' and 'size' that are already
    tracked in @data.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20200113172245.27925-12-ardb@kernel.org

diff --git a/include/linux/efi.h b/include/linux/efi.h
index f117d68c314e..adbe421835c1 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -759,8 +759,8 @@ typedef union {
 
 /*
  * Architecture independent structure for describing a memory map for the
- * benefit of efi_memmap_init_early(), saving us the need to pass four
- * parameters.
+ * benefit of efi_memmap_init_early(), and for passing context between
+ * efi_memmap_alloc() and efi_memmap_install().
  */
 struct efi_memory_map_data {
 	phys_addr_t phys_map;
@@ -778,6 +778,8 @@ struct efi_memory_map {
 	unsigned long desc_version;
 	unsigned long desc_size;
 #define EFI_MEMMAP_LATE (1UL << 0)
+#define EFI_MEMMAP_MEMBLOCK (1UL << 1)
+#define EFI_MEMMAP_SLAB (1UL << 2)
 	unsigned long flags;
 };
 
@@ -972,11 +974,12 @@ static inline efi_status_t efi_query_variable_store(u32 attributes,
 #endif
 extern void __iomem *efi_lookup_mapped_addr(u64 phys_addr);
 
-extern phys_addr_t __init efi_memmap_alloc(unsigned int num_entries);
+extern int __init efi_memmap_alloc(unsigned int num_entries,
+				   struct efi_memory_map_data *data);
 extern int __init efi_memmap_init_early(struct efi_memory_map_data *data);
 extern int __init efi_memmap_init_late(phys_addr_t addr, unsigned long size);
 extern void __init efi_memmap_unmap(void);
-extern int __init efi_memmap_install(phys_addr_t addr, unsigned int nr_map);
+extern int __init efi_memmap_install(struct efi_memory_map_data *data);
 extern int __init efi_memmap_split_count(efi_memory_desc_t *md,
 					 struct range *range);
 extern void __init efi_memmap_insert(struct efi_memory_map *old_memmap,

commit 26c0e44a213b272abec0e8fba4a5a2801f95208e
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jan 13 18:22:42 2020 +0100

    efi: Add a flags parameter to efi_memory_map
    
    In preparation for garbage collecting dynamically allocated EFI memory
    maps, where the allocation method of memblock vs slab needs to be
    recalled, convert the existing 'late' flag into a 'flags' bitmask.
    
    Arrange for the flag to be passed via 'struct efi_memory_map_data'. This
    structure grows additional flags in follow-on changes.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20200113172245.27925-11-ardb@kernel.org

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 7e8e25b1d11c..f117d68c314e 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -767,6 +767,7 @@ struct efi_memory_map_data {
 	unsigned long size;
 	unsigned long desc_version;
 	unsigned long desc_size;
+	unsigned long flags;
 };
 
 struct efi_memory_map {
@@ -776,7 +777,8 @@ struct efi_memory_map {
 	int nr_map;
 	unsigned long desc_version;
 	unsigned long desc_size;
-	bool late;
+#define EFI_MEMMAP_LATE (1UL << 0)
+	unsigned long flags;
 };
 
 struct efi_mem_range {

commit 4444f8541dad16fefd9b8807ad1451e806ef1d94
Author: Matthew Garrett <matthewgarrett@google.com>
Date:   Fri Jan 3 12:39:50 2020 +0100

    efi: Allow disabling PCI busmastering on bridges during boot
    
    Add an option to disable the busmaster bit in the control register on
    all PCI bridges before calling ExitBootServices() and passing control
    to the runtime kernel. System firmware may configure the IOMMU to prevent
    malicious PCI devices from being able to attack the OS via DMA. However,
    since firmware can't guarantee that the OS is IOMMU-aware, it will tear
    down IOMMU configuration when ExitBootServices() is called. This leaves
    a window between where a hostile device could still cause damage before
    Linux configures the IOMMU again.
    
    If CONFIG_EFI_DISABLE_PCI_DMA is enabled or "efi=disable_early_pci_dma"
    is passed on the command line, the EFI stub will clear the busmaster bit
    on all PCI bridges before ExitBootServices() is called. This will
    prevent any malicious PCI devices from being able to perform DMA until
    the kernel reenables busmastering after configuring the IOMMU.
    
    This option may cause failures with some poorly behaved hardware and
    should not be enabled without testing. The kernel commandline options
    "efi=disable_early_pci_dma" or "efi=no_disable_early_pci_dma" may be
    used to override the default. Note that PCI devices downstream from PCI
    bridges are disconnected from their drivers first, using the UEFI
    driver model API, so that DMA can be disabled safely at the bridge
    level.
    
    [ardb: disconnect PCI I/O handles first, as suggested by Arvind]
    
    Co-developed-by: Matthew Garrett <mjg59@google.com>
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Matthew Garrett <matthewgarrett@google.com>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20200103113953.9571-18-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index ee68ea6f85ff..7e8e25b1d11c 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -319,7 +319,9 @@ typedef union {
 		void *stall;
 		void *set_watchdog_timer;
 		void *connect_controller;
-		void *disconnect_controller;
+		efi_status_t (__efiapi *disconnect_controller)(efi_handle_t,
+							       efi_handle_t,
+							       efi_handle_t);
 		void *open_protocol;
 		void *close_protocol;
 		void *open_protocol_information;
@@ -1692,4 +1694,6 @@ struct linux_efi_memreserve {
 #define EFI_MEMRESERVE_COUNT(size) (((size) - sizeof(struct linux_efi_memreserve)) \
 	/ sizeof(((struct linux_efi_memreserve *)0)->entry[0]))
 
+void efi_pci_disable_bridge_busmaster(void);
+
 #endif /* _LINUX_EFI_H */

commit 33b85447fa61946b94fea93dd4bc24772af14d54
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Fri Jan 3 12:39:44 2020 +0100

    efi/x86: Drop two near identical versions of efi_runtime_init()
    
    The routines efi_runtime_init32() and efi_runtime_init64() are
    almost indistinguishable, and the only relevant difference is
    the offset in the runtime struct from where to obtain the physical
    address of the SetVirtualAddressMap() routine.
    
    However, this address is only used once, when installing the virtual
    address map that the OS will use to invoke EFI runtime services, and
    at the time of the call, we will necessarily be running with a 1:1
    mapping, and so there is no need to do the map/unmap dance here to
    retrieve the address. In fact, in the preceding changes to these users,
    we stopped using the address recorded here entirely.
    
    So let's just get rid of all this code since it no longer serves a
    purpose. While at it, tweak the logic so that we handle unsupported
    and disable EFI runtime services in the same way, and unmap the EFI
    memory map in both cases.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Matthew Garrett <mjg59@google.com>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20200103113953.9571-12-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 952c1659dfd9..ee68ea6f85ff 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -539,24 +539,6 @@ typedef struct {
 	u32 query_variable_info;
 } efi_runtime_services_32_t;
 
-typedef struct {
-	efi_table_hdr_t hdr;
-	u64 get_time;
-	u64 set_time;
-	u64 get_wakeup_time;
-	u64 set_wakeup_time;
-	u64 set_virtual_address_map;
-	u64 convert_pointer;
-	u64 get_variable;
-	u64 get_next_variable;
-	u64 set_variable;
-	u64 get_next_high_mono_count;
-	u64 reset_system;
-	u64 update_capsule;
-	u64 query_capsule_caps;
-	u64 query_variable_info;
-} efi_runtime_services_64_t;
-
 typedef efi_status_t efi_get_time_t (efi_time_t *tm, efi_time_cap_t *tc);
 typedef efi_status_t efi_set_time_t (efi_time_t *tm);
 typedef efi_status_t efi_get_wakeup_time_t (efi_bool_t *enabled, efi_bool_t *pending,
@@ -946,7 +928,6 @@ extern struct efi {
 	efi_query_capsule_caps_t *query_capsule_caps;
 	efi_get_next_high_mono_count_t *get_next_high_mono_count;
 	efi_reset_system_t *reset_system;
-	efi_set_virtual_address_map_t *set_virtual_address_map;
 	struct efi_memory_map memmap;
 	unsigned long flags;
 } efi;

commit 89ed486532c4d155565cc4b7984a918ee3c58f80
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Fri Jan 3 12:39:38 2020 +0100

    efi/x86: Avoid redundant cast of EFI firmware service pointer
    
    All EFI firmware call prototypes have been annotated as __efiapi,
    permitting us to attach attributes regarding the calling convention
    by overriding __efiapi to an architecture specific value.
    
    On 32-bit x86, EFI firmware calls use the plain calling convention
    where all arguments are passed via the stack, and cleaned up by the
    caller. Let's add this to the __efiapi definition so we no longer
    need to cast the function pointers before invoking them.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Matthew Garrett <mjg59@google.com>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20200103113953.9571-6-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 726673e98990..952c1659dfd9 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -48,8 +48,10 @@ typedef u16 efi_char16_t;		/* UNICODE character */
 typedef u64 efi_physical_addr_t;
 typedef void *efi_handle_t;
 
-#ifdef CONFIG_X86_64
+#if defined(CONFIG_X86_64)
 #define __efiapi __attribute__((ms_abi))
+#elif defined(CONFIG_X86_32)
+#define __efiapi __attribute__((regparm(0)))
 #else
 #define __efiapi
 #endif

commit cd33a5c1d53e43bef1683c70dc3b68b6d9e8eca6
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:19 2019 +0100

    efi/libstub: Remove 'sys_table_arg' from all function prototypes
    
    We have a helper efi_system_table() that gives us the address of the
    EFI system table in memory, so there is no longer point in passing
    it around from each function to the next.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-20-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 5b207db6ead0..726673e98990 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1495,22 +1495,17 @@ static inline int efi_runtime_map_copy(void *buf, size_t bufsz)
 
 void efi_printk(char *str);
 
-void efi_free(efi_system_table_t *sys_table_arg, unsigned long size,
-	      unsigned long addr);
+void efi_free(unsigned long size, unsigned long addr);
 
-char *efi_convert_cmdline(efi_system_table_t *sys_table_arg,
-			  efi_loaded_image_t *image, int *cmd_line_len);
+char *efi_convert_cmdline(efi_loaded_image_t *image, int *cmd_line_len);
 
-efi_status_t efi_get_memory_map(efi_system_table_t *sys_table_arg,
-				struct efi_boot_memmap *map);
+efi_status_t efi_get_memory_map(struct efi_boot_memmap *map);
 
-efi_status_t efi_low_alloc_above(efi_system_table_t *sys_table_arg,
-				 unsigned long size, unsigned long align,
+efi_status_t efi_low_alloc_above(unsigned long size, unsigned long align,
 				 unsigned long *addr, unsigned long min);
 
 static inline
-efi_status_t efi_low_alloc(efi_system_table_t *sys_table_arg,
-			   unsigned long size, unsigned long align,
+efi_status_t efi_low_alloc(unsigned long size, unsigned long align,
 			   unsigned long *addr)
 {
 	/*
@@ -1518,23 +1513,20 @@ efi_status_t efi_low_alloc(efi_system_table_t *sys_table_arg,
 	 * checks pointers against NULL. Skip the first 8
 	 * bytes so we start at a nice even number.
 	 */
-	return efi_low_alloc_above(sys_table_arg, size, align, addr, 0x8);
+	return efi_low_alloc_above(size, align, addr, 0x8);
 }
 
-efi_status_t efi_high_alloc(efi_system_table_t *sys_table_arg,
-			    unsigned long size, unsigned long align,
+efi_status_t efi_high_alloc(unsigned long size, unsigned long align,
 			    unsigned long *addr, unsigned long max);
 
-efi_status_t efi_relocate_kernel(efi_system_table_t *sys_table_arg,
-				 unsigned long *image_addr,
+efi_status_t efi_relocate_kernel(unsigned long *image_addr,
 				 unsigned long image_size,
 				 unsigned long alloc_size,
 				 unsigned long preferred_addr,
 				 unsigned long alignment,
 				 unsigned long min_addr);
 
-efi_status_t handle_cmdline_files(efi_system_table_t *sys_table_arg,
-				  efi_loaded_image_t *image,
+efi_status_t handle_cmdline_files(efi_loaded_image_t *image,
 				  char *cmd_line, char *option_string,
 				  unsigned long max_addr,
 				  unsigned long *load_addr,
@@ -1542,8 +1534,7 @@ efi_status_t handle_cmdline_files(efi_system_table_t *sys_table_arg,
 
 efi_status_t efi_parse_options(char const *cmdline);
 
-efi_status_t efi_setup_gop(efi_system_table_t *sys_table_arg,
-			   struct screen_info *si, efi_guid_t *proto,
+efi_status_t efi_setup_gop(struct screen_info *si, efi_guid_t *proto,
 			   unsigned long size);
 
 #ifdef CONFIG_EFI
@@ -1561,18 +1552,18 @@ enum efi_secureboot_mode {
 	efi_secureboot_mode_disabled,
 	efi_secureboot_mode_enabled,
 };
-enum efi_secureboot_mode efi_get_secureboot(efi_system_table_t *sys_table);
+enum efi_secureboot_mode efi_get_secureboot(void);
 
 #ifdef CONFIG_RESET_ATTACK_MITIGATION
-void efi_enable_reset_attack_mitigation(efi_system_table_t *sys_table_arg);
+void efi_enable_reset_attack_mitigation(void);
 #else
 static inline void
-efi_enable_reset_attack_mitigation(efi_system_table_t *sys_table_arg) { }
+efi_enable_reset_attack_mitigation(void) { }
 #endif
 
-efi_status_t efi_random_get_seed(efi_system_table_t *sys_table_arg);
+efi_status_t efi_random_get_seed(void);
 
-void efi_retrieve_tpm2_eventlog(efi_system_table_t *sys_table);
+void efi_retrieve_tpm2_eventlog(void);
 
 /*
  * Arch code can implement the following three template macros, avoiding
@@ -1624,12 +1615,10 @@ void efi_retrieve_tpm2_eventlog(efi_system_table_t *sys_table);
 })
 
 typedef efi_status_t (*efi_exit_boot_map_processing)(
-	efi_system_table_t *sys_table_arg,
 	struct efi_boot_memmap *map,
 	void *priv);
 
-efi_status_t efi_exit_boot_services(efi_system_table_t *sys_table,
-				    void *handle,
+efi_status_t efi_exit_boot_services(void *handle,
 				    struct efi_boot_memmap *map,
 				    void *priv,
 				    efi_exit_boot_map_processing priv_func);

commit 8173ec7905b5b07c989b06a105d171c169dde93b
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:18 2019 +0100

    efi/libstub: Drop sys_table_arg from printk routines
    
    As a first step towards getting rid of the need to pass around a function
    parameter 'sys_table_arg' pointing to the EFI system table, remove the
    references to it in the printing code, which is represents the majority
    of the use cases.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-19-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 14dd08ecf8a7..5b207db6ead0 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1493,7 +1493,7 @@ static inline int efi_runtime_map_copy(void *buf, size_t bufsz)
 
 /* prototypes shared between arch specific and generic stub code */
 
-void efi_printk(efi_system_table_t *sys_table_arg, char *str);
+void efi_printk(char *str);
 
 void efi_free(efi_system_table_t *sys_table_arg, unsigned long size,
 	      unsigned long addr);

commit 14e900c7e4033d6ee3398b9f133e1716cc072401
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:14 2019 +0100

    efi/libstub: Avoid protocol wrapper for file I/O routines
    
    The EFI file I/O routines built on top of the file I/O firmware
    services are incompatible with mixed mode, so there is no need
    to obfuscate them by using protocol wrappers whose only purpose
    is to hide the mixed mode handling. So let's switch to plain
    indirect calls instead.
    
    This also means we can drop the mixed_mode aliases from the various
    types involved.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-15-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 2074b737aa17..14dd08ecf8a7 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -806,40 +806,21 @@ struct efi_fdt_params {
 	u32 desc_ver;
 };
 
-typedef union efi_loaded_image efi_loaded_image_t;
-
-union efi_loaded_image {
-	struct {
-		u32 revision;
-		efi_handle_t parent_handle;
-		efi_system_table_t *system_table;
-		efi_handle_t device_handle;
-		void *file_path;
-		void *reserved;
-		u32 load_options_size;
-		void *load_options;
-		void *image_base;
-		__aligned_u64 image_size;
-		unsigned int image_code_type;
-		unsigned int image_data_type;
-		efi_status_t ( __efiapi *unload)(efi_handle_t image_handle);
-	};
-	struct {
-		u32 revision;
-		u32 parent_handle;
-		u32 system_table;
-		u32 device_handle;
-		u32 file_path;
-		u32 reserved;
-		u32 load_options_size;
-		u32 load_options;
-		u32 image_base;
-		__aligned_u64 image_size;
-		unsigned int image_code_type;
-		unsigned int image_data_type;
-		u32 unload;
-	} mixed_mode;
-};
+typedef struct {
+	u32 revision;
+	efi_handle_t parent_handle;
+	efi_system_table_t *system_table;
+	efi_handle_t device_handle;
+	void *file_path;
+	void *reserved;
+	u32 load_options_size;
+	void *load_options;
+	void *image_base;
+	__aligned_u64 image_size;
+	unsigned int image_code_type;
+	unsigned int image_data_type;
+	efi_status_t ( __efiapi *unload)(efi_handle_t image_handle);
+} efi_loaded_image_t;
 
 typedef struct {
 	u64 size;
@@ -852,54 +833,33 @@ typedef struct {
 	efi_char16_t filename[1];
 } efi_file_info_t;
 
-typedef union efi_file_handle efi_file_handle_t;
-
-union efi_file_handle {
-	struct {
-		u64 revision;
-		efi_status_t (__efiapi *open)(efi_file_handle_t *,
-					      efi_file_handle_t **,
-					      efi_char16_t *, u64, u64);
-		efi_status_t (__efiapi *close)(efi_file_handle_t *);
-		void *delete;
-		efi_status_t (__efiapi *read)(efi_file_handle_t *,
-					      unsigned long *, void *);
-		void *write;
-		void *get_position;
-		void *set_position;
-		efi_status_t (__efiapi *get_info)(efi_file_handle_t *,
-						  efi_guid_t *, unsigned long *,
-						  void *);
-		void *set_info;
-		void *flush;
-	};
-	struct {
-		u64 revision;
-		u32 open;
-		u32 close;
-		u32 delete;
-		u32 read;
-		u32 write;
-		u32 get_position;
-		u32 set_position;
-		u32 get_info;
-		u32 set_info;
-		u32 flush;
-	} mixed_mode;
+typedef struct efi_file_handle efi_file_handle_t;
+
+struct efi_file_handle {
+	u64 revision;
+	efi_status_t (__efiapi *open)(efi_file_handle_t *,
+				      efi_file_handle_t **,
+				      efi_char16_t *, u64, u64);
+	efi_status_t (__efiapi *close)(efi_file_handle_t *);
+	void *delete;
+	efi_status_t (__efiapi *read)(efi_file_handle_t *,
+				      unsigned long *, void *);
+	void *write;
+	void *get_position;
+	void *set_position;
+	efi_status_t (__efiapi *get_info)(efi_file_handle_t *,
+					  efi_guid_t *, unsigned long *,
+					  void *);
+	void *set_info;
+	void *flush;
 };
 
-typedef union efi_file_io_interface efi_file_io_interface_t;
+typedef struct efi_file_io_interface efi_file_io_interface_t;
 
-union efi_file_io_interface {
-	struct {
-		u64 revision;
-		int (__efiapi *open_volume)(efi_file_io_interface_t *,
-					    efi_file_handle_t **);
-	};
-	struct {
-		u64 revision;
-		u32 open_volume;
-	} mixed_mode;
+struct efi_file_io_interface {
+	u64 revision;
+	int (__efiapi *open_volume)(efi_file_io_interface_t *,
+				    efi_file_handle_t **);
 };
 
 #define EFI_FILE_MODE_READ	0x0000000000000001

commit 8f24f8c2fc82f701866419dcb594e2cc1d3f46ba
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:12 2019 +0100

    efi/libstub: Annotate firmware routines as __efiapi
    
    Annotate all the firmware routines (boot services, runtime services and
    protocol methods) called in the boot context as __efiapi, and make
    it expand to __attribute__((ms_abi)) on 64-bit x86. This allows us
    to use the compiler to generate the calls into firmware that use the
    MS calling convention instead of the SysV one.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-13-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 880077639113..2074b737aa17 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -48,6 +48,12 @@ typedef u16 efi_char16_t;		/* UNICODE character */
 typedef u64 efi_physical_addr_t;
 typedef void *efi_handle_t;
 
+#ifdef CONFIG_X86_64
+#define __efiapi __attribute__((ms_abi))
+#else
+#define __efiapi
+#endif
+
 #define efi_get_handle_at(array, idx)					\
 	(efi_is_native() ? (array)[idx] 				\
 		: (efi_handle_t)(unsigned long)((u32 *)(array))[idx])
@@ -272,13 +278,16 @@ typedef union {
 		efi_table_hdr_t hdr;
 		void *raise_tpl;
 		void *restore_tpl;
-		efi_status_t (*allocate_pages)(int, int, unsigned long,
-					       efi_physical_addr_t *);
-		efi_status_t (*free_pages)(efi_physical_addr_t, unsigned long);
-		efi_status_t (*get_memory_map)(unsigned long *, void *, unsigned long *,
-					       unsigned long *, u32 *);
-		efi_status_t (*allocate_pool)(int, unsigned long, void **);
-		efi_status_t (*free_pool)(void *);
+		efi_status_t (__efiapi *allocate_pages)(int, int, unsigned long,
+							efi_physical_addr_t *);
+		efi_status_t (__efiapi *free_pages)(efi_physical_addr_t,
+						    unsigned long);
+		efi_status_t (__efiapi *get_memory_map)(unsigned long *, void *,
+							unsigned long *,
+							unsigned long *, u32 *);
+		efi_status_t (__efiapi *allocate_pool)(int, unsigned long,
+						       void **);
+		efi_status_t (__efiapi *free_pool)(void *);
 		void *create_event;
 		void *set_timer;
 		void *wait_for_event;
@@ -288,18 +297,22 @@ typedef union {
 		void *install_protocol_interface;
 		void *reinstall_protocol_interface;
 		void *uninstall_protocol_interface;
-		efi_status_t (*handle_protocol)(efi_handle_t, efi_guid_t *, void **);
+		efi_status_t (__efiapi *handle_protocol)(efi_handle_t,
+							 efi_guid_t *, void **);
 		void *__reserved;
 		void *register_protocol_notify;
-		efi_status_t (*locate_handle)(int, efi_guid_t *, void *,
-					      unsigned long *, efi_handle_t *);
+		efi_status_t (__efiapi *locate_handle)(int, efi_guid_t *,
+						       void *, unsigned long *,
+						       efi_handle_t *);
 		void *locate_device_path;
-		efi_status_t (*install_configuration_table)(efi_guid_t *, void *);
+		efi_status_t (__efiapi *install_configuration_table)(efi_guid_t *,
+								     void *);
 		void *load_image;
 		void *start_image;
 		void *exit;
 		void *unload_image;
-		efi_status_t (*exit_boot_services)(efi_handle_t, unsigned long);
+		efi_status_t (__efiapi *exit_boot_services)(efi_handle_t,
+							    unsigned long);
 		void *get_next_monotonic_count;
 		void *stall;
 		void *set_watchdog_timer;
@@ -310,7 +323,8 @@ typedef union {
 		void *open_protocol_information;
 		void *protocols_per_handle;
 		void *locate_handle_buffer;
-		efi_status_t (*locate_protocol)(efi_guid_t *, void *, void **);
+		efi_status_t (__efiapi *locate_protocol)(efi_guid_t *, void *,
+							 void **);
 		void *install_multiple_protocol_interfaces;
 		void *uninstall_multiple_protocol_interfaces;
 		void *calculate_crc32;
@@ -354,10 +368,11 @@ typedef struct {
 typedef union efi_pci_io_protocol efi_pci_io_protocol_t;
 
 typedef
-efi_status_t (*efi_pci_io_protocol_cfg_t)(efi_pci_io_protocol_t *,
-					  EFI_PCI_IO_PROTOCOL_WIDTH,
-					  u32 offset, unsigned long count,
-					  void *buffer);
+efi_status_t (__efiapi *efi_pci_io_protocol_cfg_t)(efi_pci_io_protocol_t *,
+						   EFI_PCI_IO_PROTOCOL_WIDTH,
+						   u32 offset,
+						   unsigned long count,
+						   void *buffer);
 
 typedef struct {
 	void *read;
@@ -382,11 +397,11 @@ union efi_pci_io_protocol {
 		void *allocate_buffer;
 		void *free_buffer;
 		void *flush;
-		efi_status_t (*get_location)(efi_pci_io_protocol_t *,
-					     unsigned long *segment_nr,
-					     unsigned long *bus_nr,
-					     unsigned long *device_nr,
-					     unsigned long *function_nr);
+		efi_status_t (__efiapi *get_location)(efi_pci_io_protocol_t *,
+						      unsigned long *segment_nr,
+						      unsigned long *bus_nr,
+						      unsigned long *device_nr,
+						      unsigned long *func_nr);
 		void *attributes;
 		void *get_bar_attributes;
 		void *set_bar_attributes;
@@ -441,16 +456,17 @@ typedef union apple_properties_protocol apple_properties_protocol_t;
 union apple_properties_protocol {
 	struct {
 		unsigned long version;
-		efi_status_t (*get)(apple_properties_protocol_t *,
-				    struct efi_dev_path *, efi_char16_t *,
-				    void *, u32 *);
-		efi_status_t (*set)(apple_properties_protocol_t *,
-				    struct efi_dev_path *, efi_char16_t *,
-				    void *, u32);
-		efi_status_t (*del)(apple_properties_protocol_t *,
-				    struct efi_dev_path *, efi_char16_t *);
-		efi_status_t (*get_all)(apple_properties_protocol_t *,
-					void *buffer, u32 *);
+		efi_status_t (__efiapi *get)(apple_properties_protocol_t *,
+					     struct efi_dev_path *,
+					     efi_char16_t *, void *, u32 *);
+		efi_status_t (__efiapi *set)(apple_properties_protocol_t *,
+					     struct efi_dev_path *,
+					     efi_char16_t *, void *, u32);
+		efi_status_t (__efiapi *del)(apple_properties_protocol_t *,
+					     struct efi_dev_path *,
+					     efi_char16_t *);
+		efi_status_t (__efiapi *get_all)(apple_properties_protocol_t *,
+						 void *buffer, u32 *);
 	};
 	struct {
 		u32 version;
@@ -468,11 +484,11 @@ typedef union efi_tcg2_protocol efi_tcg2_protocol_t;
 union efi_tcg2_protocol {
 	struct {
 		void *get_capability;
-		efi_status_t (*get_event_log)(efi_handle_t,
-					      efi_tcg2_event_log_format,
-					      efi_physical_addr_t *,
-					      efi_physical_addr_t *,
-					      efi_bool_t *);
+		efi_status_t (__efiapi *get_event_log)(efi_handle_t,
+						       efi_tcg2_event_log_format,
+						       efi_physical_addr_t *,
+						       efi_physical_addr_t *,
+						       efi_bool_t *);
 		void *hash_log_extend_event;
 		void *submit_command;
 		void *get_active_pcr_banks;
@@ -575,21 +591,21 @@ typedef efi_status_t efi_query_variable_store_t(u32 attributes,
 
 typedef union {
 	struct {
-		efi_table_hdr_t			hdr;
-		efi_get_time_t			*get_time;
-		efi_set_time_t			*set_time;
-		efi_get_wakeup_time_t		*get_wakeup_time;
-		efi_set_wakeup_time_t		*set_wakeup_time;
-		efi_set_virtual_address_map_t	*set_virtual_address_map;
-		void				*convert_pointer;
-		efi_get_variable_t		*get_variable;
-		efi_get_next_variable_t		*get_next_variable;
-		efi_set_variable_t		*set_variable;
-		efi_get_next_high_mono_count_t	*get_next_high_mono_count;
-		efi_reset_system_t		*reset_system;
-		efi_update_capsule_t		*update_capsule;
-		efi_query_capsule_caps_t	*query_capsule_caps;
-		efi_query_variable_info_t	*query_variable_info;
+		efi_table_hdr_t				hdr;
+		efi_get_time_t __efiapi			*get_time;
+		efi_set_time_t __efiapi			*set_time;
+		efi_get_wakeup_time_t __efiapi		*get_wakeup_time;
+		efi_set_wakeup_time_t __efiapi		*set_wakeup_time;
+		efi_set_virtual_address_map_t __efiapi	*set_virtual_address_map;
+		void					*convert_pointer;
+		efi_get_variable_t __efiapi		*get_variable;
+		efi_get_next_variable_t __efiapi	*get_next_variable;
+		efi_set_variable_t __efiapi		*set_variable;
+		efi_get_next_high_mono_count_t __efiapi	*get_next_high_mono_count;
+		efi_reset_system_t __efiapi		*reset_system;
+		efi_update_capsule_t __efiapi		*update_capsule;
+		efi_query_capsule_caps_t __efiapi	*query_capsule_caps;
+		efi_query_variable_info_t __efiapi	*query_variable_info;
 	};
 	efi_runtime_services_32_t mixed_mode;
 } efi_runtime_services_t;
@@ -806,7 +822,7 @@ union efi_loaded_image {
 		__aligned_u64 image_size;
 		unsigned int image_code_type;
 		unsigned int image_data_type;
-		efi_status_t (*unload)(efi_handle_t image_handle);
+		efi_status_t ( __efiapi *unload)(efi_handle_t image_handle);
 	};
 	struct {
 		u32 revision;
@@ -841,18 +857,19 @@ typedef union efi_file_handle efi_file_handle_t;
 union efi_file_handle {
 	struct {
 		u64 revision;
-		efi_status_t (*open)(efi_file_handle_t *,
-				     efi_file_handle_t **,
-				     efi_char16_t *, u64, u64);
-		efi_status_t (*close)(efi_file_handle_t *);
+		efi_status_t (__efiapi *open)(efi_file_handle_t *,
+					      efi_file_handle_t **,
+					      efi_char16_t *, u64, u64);
+		efi_status_t (__efiapi *close)(efi_file_handle_t *);
 		void *delete;
-		efi_status_t (*read)(efi_file_handle_t *, unsigned long *,
-				     void *);
+		efi_status_t (__efiapi *read)(efi_file_handle_t *,
+					      unsigned long *, void *);
 		void *write;
 		void *get_position;
 		void *set_position;
-		efi_status_t (*get_info)(efi_file_handle_t *, efi_guid_t *,
-				unsigned long *, void *);
+		efi_status_t (__efiapi *get_info)(efi_file_handle_t *,
+						  efi_guid_t *, unsigned long *,
+						  void *);
 		void *set_info;
 		void *flush;
 	};
@@ -876,8 +893,8 @@ typedef union efi_file_io_interface efi_file_io_interface_t;
 union efi_file_io_interface {
 	struct {
 		u64 revision;
-		int (*open_volume)(efi_file_io_interface_t *,
-				   efi_file_handle_t **);
+		int (__efiapi *open_volume)(efi_file_io_interface_t *,
+					    efi_file_handle_t **);
 	};
 	struct {
 		u64 revision;
@@ -1346,8 +1363,8 @@ struct efivar_entry {
 union efi_simple_text_output_protocol {
 	struct {
 		void *reset;
-		efi_status_t (*output_string)(efi_simple_text_output_protocol_t *,
-					      efi_char16_t *);
+		efi_status_t (__efiapi *output_string)(efi_simple_text_output_protocol_t *,
+						       efi_char16_t *);
 		void *test_string;
 	};
 	struct {

commit 960a8d01834eabc4549928c60f8ce0300ad08519
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:11 2019 +0100

    efi/libstub: Use stricter typing for firmware function pointers
    
    We will soon remove another level of pointer casting, so let's make
    sure all type handling involving firmware calls at boot time is correct.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-12-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index d8e987910853..880077639113 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -382,7 +382,11 @@ union efi_pci_io_protocol {
 		void *allocate_buffer;
 		void *free_buffer;
 		void *flush;
-		void *get_location;
+		efi_status_t (*get_location)(efi_pci_io_protocol_t *,
+					     unsigned long *segment_nr,
+					     unsigned long *bus_nr,
+					     unsigned long *device_nr,
+					     unsigned long *function_nr);
 		void *attributes;
 		void *get_bar_attributes;
 		void *set_bar_attributes;
@@ -730,6 +734,8 @@ typedef struct {
 	u32 tables;
 } efi_system_table_32_t;
 
+typedef union efi_simple_text_output_protocol efi_simple_text_output_protocol_t;
+
 typedef union {
 	struct {
 		efi_table_hdr_t hdr;
@@ -738,7 +744,7 @@ typedef union {
 		unsigned long con_in_handle;
 		unsigned long con_in;
 		unsigned long con_out_handle;
-		unsigned long con_out;
+		efi_simple_text_output_protocol_t *con_out;
 		unsigned long stderr_handle;
 		unsigned long stderr;
 		efi_runtime_services_t *runtime;
@@ -1337,8 +1343,6 @@ struct efivar_entry {
 	bool deleting;
 };
 
-typedef union efi_simple_text_output_protocol efi_simple_text_output_protocol_t;
-
 union efi_simple_text_output_protocol {
 	struct {
 		void *reset;

commit e8bd5ddf60eedd6d584fa1e98d0cfe45abe95043
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:10 2019 +0100

    efi/libstub: Drop explicit 32/64-bit protocol definitions
    
    Now that we have incorporated the mixed mode protocol definitions
    into the native ones using unions, we no longer need the separate
    32/64 bit struct definitions, with the exception of the EFI system
    table definition and the boot services, runtime services and
    configuration table definitions. So drop the unused ones.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-11-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index e9d74e9667c0..d8e987910853 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -264,54 +264,6 @@ typedef struct {
 	u32 create_event_ex;
 } __packed efi_boot_services_32_t;
 
-typedef struct {
-	efi_table_hdr_t hdr;
-	u64 raise_tpl;
-	u64 restore_tpl;
-	u64 allocate_pages;
-	u64 free_pages;
-	u64 get_memory_map;
-	u64 allocate_pool;
-	u64 free_pool;
-	u64 create_event;
-	u64 set_timer;
-	u64 wait_for_event;
-	u64 signal_event;
-	u64 close_event;
-	u64 check_event;
-	u64 install_protocol_interface;
-	u64 reinstall_protocol_interface;
-	u64 uninstall_protocol_interface;
-	u64 handle_protocol;
-	u64 __reserved;
-	u64 register_protocol_notify;
-	u64 locate_handle;
-	u64 locate_device_path;
-	u64 install_configuration_table;
-	u64 load_image;
-	u64 start_image;
-	u64 exit;
-	u64 unload_image;
-	u64 exit_boot_services;
-	u64 get_next_monotonic_count;
-	u64 stall;
-	u64 set_watchdog_timer;
-	u64 connect_controller;
-	u64 disconnect_controller;
-	u64 open_protocol;
-	u64 close_protocol;
-	u64 open_protocol_information;
-	u64 protocols_per_handle;
-	u64 locate_handle_buffer;
-	u64 locate_protocol;
-	u64 install_multiple_protocol_interfaces;
-	u64 uninstall_multiple_protocol_interfaces;
-	u64 calculate_crc32;
-	u64 copy_mem;
-	u64 set_mem;
-	u64 create_event_ex;
-} __packed efi_boot_services_64_t;
-
 /*
  * EFI Boot Services table
  */
@@ -399,11 +351,6 @@ typedef struct {
 	u32 write;
 } efi_pci_io_protocol_access_32_t;
 
-typedef struct {
-	u64 read;
-	u64 write;
-} efi_pci_io_protocol_access_64_t;
-
 typedef union efi_pci_io_protocol efi_pci_io_protocol_t;
 
 typedef
@@ -422,46 +369,6 @@ typedef struct {
 	efi_pci_io_protocol_cfg_t write;
 } efi_pci_io_protocol_config_access_t;
 
-typedef struct {
-	u32 poll_mem;
-	u32 poll_io;
-	efi_pci_io_protocol_access_32_t mem;
-	efi_pci_io_protocol_access_32_t io;
-	efi_pci_io_protocol_access_32_t pci;
-	u32 copy_mem;
-	u32 map;
-	u32 unmap;
-	u32 allocate_buffer;
-	u32 free_buffer;
-	u32 flush;
-	u32 get_location;
-	u32 attributes;
-	u32 get_bar_attributes;
-	u32 set_bar_attributes;
-	u64 romsize;
-	u32 romimage;
-} efi_pci_io_protocol_32_t;
-
-typedef struct {
-	u64 poll_mem;
-	u64 poll_io;
-	efi_pci_io_protocol_access_64_t mem;
-	efi_pci_io_protocol_access_64_t io;
-	efi_pci_io_protocol_access_64_t pci;
-	u64 copy_mem;
-	u64 map;
-	u64 unmap;
-	u64 allocate_buffer;
-	u64 free_buffer;
-	u64 flush;
-	u64 get_location;
-	u64 attributes;
-	u64 get_bar_attributes;
-	u64 set_bar_attributes;
-	u64 romsize;
-	u64 romimage;
-} efi_pci_io_protocol_64_t;
-
 union efi_pci_io_protocol {
 	struct {
 		void *poll_mem;
@@ -523,22 +430,6 @@ union efi_pci_io_protocol {
 #define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO_16 0x20000
 #define EFI_PCI_IO_ATTRIBUTE_VGA_IO_16 0x40000
 
-typedef struct {
-	u32 version;
-	u32 get;
-	u32 set;
-	u32 del;
-	u32 get_all;
-} apple_properties_protocol_32_t;
-
-typedef struct {
-	u64 version;
-	u64 get;
-	u64 set;
-	u64 del;
-	u64 get_all;
-} apple_properties_protocol_64_t;
-
 struct efi_dev_path;
 
 typedef union apple_properties_protocol apple_properties_protocol_t;
@@ -566,26 +457,6 @@ union apple_properties_protocol {
 	} mixed_mode;
 };
 
-typedef struct {
-	u32 get_capability;
-	u32 get_event_log;
-	u32 hash_log_extend_event;
-	u32 submit_command;
-	u32 get_active_pcr_banks;
-	u32 set_active_pcr_banks;
-	u32 get_result_of_set_active_pcr_banks;
-} efi_tcg2_protocol_32_t;
-
-typedef struct {
-	u64 get_capability;
-	u64 get_event_log;
-	u64 hash_log_extend_event;
-	u64 submit_command;
-	u64 get_active_pcr_banks;
-	u64 set_active_pcr_banks;
-	u64 get_result_of_set_active_pcr_banks;
-} efi_tcg2_protocol_64_t;
-
 typedef u32 efi_tcg2_event_log_format;
 
 typedef union efi_tcg2_protocol efi_tcg2_protocol_t;
@@ -913,38 +784,6 @@ struct efi_fdt_params {
 	u32 desc_ver;
 };
 
-typedef struct {
-	u32 revision;
-	u32 parent_handle;
-	u32 system_table;
-	u32 device_handle;
-	u32 file_path;
-	u32 reserved;
-	u32 load_options_size;
-	u32 load_options;
-	u32 image_base;
-	__aligned_u64 image_size;
-	unsigned int image_code_type;
-	unsigned int image_data_type;
-	u32 unload;
-} efi_loaded_image_32_t;
-
-typedef struct {
-	u32 revision;
-	u64 parent_handle;
-	u64 system_table;
-	u64 device_handle;
-	u64 file_path;
-	u64 reserved;
-	u32 load_options_size;
-	u64 load_options;
-	u64 image_base;
-	__aligned_u64 image_size;
-	unsigned int image_code_type;
-	unsigned int image_data_type;
-	u64 unload;
-} efi_loaded_image_64_t;
-
 typedef union efi_loaded_image efi_loaded_image_t;
 
 union efi_loaded_image {
@@ -991,34 +830,6 @@ typedef struct {
 	efi_char16_t filename[1];
 } efi_file_info_t;
 
-typedef struct {
-	u64 revision;
-	u32 open;
-	u32 close;
-	u32 delete;
-	u32 read;
-	u32 write;
-	u32 get_position;
-	u32 set_position;
-	u32 get_info;
-	u32 set_info;
-	u32 flush;
-} efi_file_handle_32_t;
-
-typedef struct {
-	u64 revision;
-	u64 open;
-	u64 close;
-	u64 delete;
-	u64 read;
-	u64 write;
-	u64 get_position;
-	u64 set_position;
-	u64 get_info;
-	u64 set_info;
-	u64 flush;
-} efi_file_handle_64_t;
-
 typedef union efi_file_handle efi_file_handle_t;
 
 union efi_file_handle {
@@ -1054,16 +865,6 @@ union efi_file_handle {
 	} mixed_mode;
 };
 
-typedef struct {
-	u64 revision;
-	u32 open_volume;
-} efi_file_io_interface_32_t;
-
-typedef struct {
-	u64 revision;
-	u64 open_volume;
-} efi_file_io_interface_64_t;
-
 typedef union efi_file_io_interface efi_file_io_interface_t;
 
 union efi_file_io_interface {
@@ -1076,7 +877,7 @@ union efi_file_io_interface {
 		u64 revision;
 		u32 open_volume;
 	} mixed_mode;
-} ;
+};
 
 #define EFI_FILE_MODE_READ	0x0000000000000001
 #define EFI_FILE_MODE_WRITE	0x0000000000000002
@@ -1536,18 +1337,6 @@ struct efivar_entry {
 	bool deleting;
 };
 
-typedef struct {
-	u32 reset;
-	u32 output_string;
-	u32 test_string;
-} efi_simple_text_output_protocol_32_t;
-
-typedef struct {
-	u64 reset;
-	u64 output_string;
-	u64 test_string;
-} efi_simple_text_output_protocol_64_t;
-
 typedef union efi_simple_text_output_protocol efi_simple_text_output_protocol_t;
 
 union efi_simple_text_output_protocol {
@@ -1586,24 +1375,6 @@ typedef struct {
 	u32 pixels_per_scan_line;
 } efi_graphics_output_mode_info_t;
 
-typedef struct {
-	u32 max_mode;
-	u32 mode;
-	u32 info;
-	u32 size_of_info;
-	u64 frame_buffer_base;
-	u32 frame_buffer_size;
-} efi_graphics_output_protocol_mode_32_t;
-
-typedef struct {
-	u32 max_mode;
-	u32 mode;
-	u64 info;
-	u64 size_of_info;
-	u64 frame_buffer_base;
-	u64 frame_buffer_size;
-} efi_graphics_output_protocol_mode_64_t;
-
 typedef union efi_graphics_output_protocol_mode efi_graphics_output_protocol_mode_t;
 
 union efi_graphics_output_protocol_mode {
@@ -1625,20 +1396,6 @@ union efi_graphics_output_protocol_mode {
 	} mixed_mode;
 };
 
-typedef struct {
-	u32 query_mode;
-	u32 set_mode;
-	u32 blt;
-	u32 mode;
-} efi_graphics_output_protocol_32_t;
-
-typedef struct {
-	u64 query_mode;
-	u64 set_mode;
-	u64 blt;
-	u64 mode;
-} efi_graphics_output_protocol_64_t;
-
 typedef union efi_graphics_output_protocol efi_graphics_output_protocol_t;
 
 union efi_graphics_output_protocol {

commit f958efe97596837f9504fc38d75ef8e284bc0ebd
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:09 2019 +0100

    efi/libstub: Distinguish between native/mixed not 32/64 bit
    
    Currently, we support mixed mode by casting all boot time firmware
    calls to 64-bit explicitly on native 64-bit systems, and to 32-bit
    on 32-bit systems or 64-bit systems running with 32-bit firmware.
    
    Due to this explicit awareness of the bitness in the code, we do a
    lot of casting even on generic code that is shared with other
    architectures, where mixed mode does not even exist. This casting
    leads to loss of coverage of type checking by the compiler, which
    we should try to avoid.
    
    So instead of distinguishing between 32-bit vs 64-bit, distinguish
    between native vs mixed, and limit all the nasty casting and
    pointer mangling to the code that actually deals with mixed mode.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-10-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 5a220af263b1..e9d74e9667c0 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -49,11 +49,11 @@ typedef u64 efi_physical_addr_t;
 typedef void *efi_handle_t;
 
 #define efi_get_handle_at(array, idx)					\
-	(efi_is_64bit() ? (efi_handle_t)(unsigned long)((u64 *)(array))[idx] \
+	(efi_is_native() ? (array)[idx] 				\
 		: (efi_handle_t)(unsigned long)((u32 *)(array))[idx])
 
 #define efi_get_handle_num(size)					\
-	((size) / (efi_is_64bit() ? sizeof(u64) : sizeof(u32)))
+	((size) / (efi_is_native() ? sizeof(efi_handle_t) : sizeof(u32)))
 
 #define for_each_efi_handle(handle, array, size, i)			\
 	for (i = 0;							\
@@ -805,7 +805,7 @@ typedef struct {
 typedef union {
 	struct {
 		efi_guid_t guid;
-		unsigned long table;
+		void *table;
 	};
 	efi_config_table_32_t mixed_mode;
 } efi_config_table_t;

commit 1786e83011644e18732ed006413339d5323766e9
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:08 2019 +0100

    efi/libstub: Extend native protocol definitions with mixed_mode aliases
    
    In preparation of moving to a native vs. mixed mode split rather than a
    32 vs. 64 bit split when it comes to invoking EFI firmware services,
    update all the native protocol definitions and redefine them as unions
    containing an anonymous struct for the native view and a struct called
    'mixed_mode' describing the 32-bit view of the protocol when called from
    64-bit code.
    
    While at it, flesh out some PCI I/O member definitions that we will be
    needing shortly.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-9-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 8d267715ce22..5a220af263b1 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -315,55 +315,58 @@ typedef struct {
 /*
  * EFI Boot Services table
  */
-typedef struct {
-	efi_table_hdr_t hdr;
-	void *raise_tpl;
-	void *restore_tpl;
-	efi_status_t (*allocate_pages)(int, int, unsigned long,
-				       efi_physical_addr_t *);
-	efi_status_t (*free_pages)(efi_physical_addr_t, unsigned long);
-	efi_status_t (*get_memory_map)(unsigned long *, void *, unsigned long *,
-				       unsigned long *, u32 *);
-	efi_status_t (*allocate_pool)(int, unsigned long, void **);
-	efi_status_t (*free_pool)(void *);
-	void *create_event;
-	void *set_timer;
-	void *wait_for_event;
-	void *signal_event;
-	void *close_event;
-	void *check_event;
-	void *install_protocol_interface;
-	void *reinstall_protocol_interface;
-	void *uninstall_protocol_interface;
-	efi_status_t (*handle_protocol)(efi_handle_t, efi_guid_t *, void **);
-	void *__reserved;
-	void *register_protocol_notify;
-	efi_status_t (*locate_handle)(int, efi_guid_t *, void *,
-				      unsigned long *, efi_handle_t *);
-	void *locate_device_path;
-	efi_status_t (*install_configuration_table)(efi_guid_t *, void *);
-	void *load_image;
-	void *start_image;
-	void *exit;
-	void *unload_image;
-	efi_status_t (*exit_boot_services)(efi_handle_t, unsigned long);
-	void *get_next_monotonic_count;
-	void *stall;
-	void *set_watchdog_timer;
-	void *connect_controller;
-	void *disconnect_controller;
-	void *open_protocol;
-	void *close_protocol;
-	void *open_protocol_information;
-	void *protocols_per_handle;
-	void *locate_handle_buffer;
-	efi_status_t (*locate_protocol)(efi_guid_t *, void *, void **);
-	void *install_multiple_protocol_interfaces;
-	void *uninstall_multiple_protocol_interfaces;
-	void *calculate_crc32;
-	void *copy_mem;
-	void *set_mem;
-	void *create_event_ex;
+typedef union {
+	struct {
+		efi_table_hdr_t hdr;
+		void *raise_tpl;
+		void *restore_tpl;
+		efi_status_t (*allocate_pages)(int, int, unsigned long,
+					       efi_physical_addr_t *);
+		efi_status_t (*free_pages)(efi_physical_addr_t, unsigned long);
+		efi_status_t (*get_memory_map)(unsigned long *, void *, unsigned long *,
+					       unsigned long *, u32 *);
+		efi_status_t (*allocate_pool)(int, unsigned long, void **);
+		efi_status_t (*free_pool)(void *);
+		void *create_event;
+		void *set_timer;
+		void *wait_for_event;
+		void *signal_event;
+		void *close_event;
+		void *check_event;
+		void *install_protocol_interface;
+		void *reinstall_protocol_interface;
+		void *uninstall_protocol_interface;
+		efi_status_t (*handle_protocol)(efi_handle_t, efi_guid_t *, void **);
+		void *__reserved;
+		void *register_protocol_notify;
+		efi_status_t (*locate_handle)(int, efi_guid_t *, void *,
+					      unsigned long *, efi_handle_t *);
+		void *locate_device_path;
+		efi_status_t (*install_configuration_table)(efi_guid_t *, void *);
+		void *load_image;
+		void *start_image;
+		void *exit;
+		void *unload_image;
+		efi_status_t (*exit_boot_services)(efi_handle_t, unsigned long);
+		void *get_next_monotonic_count;
+		void *stall;
+		void *set_watchdog_timer;
+		void *connect_controller;
+		void *disconnect_controller;
+		void *open_protocol;
+		void *close_protocol;
+		void *open_protocol_information;
+		void *protocols_per_handle;
+		void *locate_handle_buffer;
+		efi_status_t (*locate_protocol)(efi_guid_t *, void *, void **);
+		void *install_multiple_protocol_interfaces;
+		void *uninstall_multiple_protocol_interfaces;
+		void *calculate_crc32;
+		void *copy_mem;
+		void *set_mem;
+		void *create_event_ex;
+	};
+	efi_boot_services_32_t mixed_mode;
 } efi_boot_services_t;
 
 typedef enum {
@@ -401,11 +404,24 @@ typedef struct {
 	u64 write;
 } efi_pci_io_protocol_access_64_t;
 
+typedef union efi_pci_io_protocol efi_pci_io_protocol_t;
+
+typedef
+efi_status_t (*efi_pci_io_protocol_cfg_t)(efi_pci_io_protocol_t *,
+					  EFI_PCI_IO_PROTOCOL_WIDTH,
+					  u32 offset, unsigned long count,
+					  void *buffer);
+
 typedef struct {
 	void *read;
 	void *write;
 } efi_pci_io_protocol_access_t;
 
+typedef struct {
+	efi_pci_io_protocol_cfg_t read;
+	efi_pci_io_protocol_cfg_t write;
+} efi_pci_io_protocol_config_access_t;
+
 typedef struct {
 	u32 poll_mem;
 	u32 poll_io;
@@ -446,25 +462,46 @@ typedef struct {
 	u64 romimage;
 } efi_pci_io_protocol_64_t;
 
-typedef struct {
-	void *poll_mem;
-	void *poll_io;
-	efi_pci_io_protocol_access_t mem;
-	efi_pci_io_protocol_access_t io;
-	efi_pci_io_protocol_access_t pci;
-	void *copy_mem;
-	void *map;
-	void *unmap;
-	void *allocate_buffer;
-	void *free_buffer;
-	void *flush;
-	void *get_location;
-	void *attributes;
-	void *get_bar_attributes;
-	void *set_bar_attributes;
-	uint64_t romsize;
-	void *romimage;
-} efi_pci_io_protocol_t;
+union efi_pci_io_protocol {
+	struct {
+		void *poll_mem;
+		void *poll_io;
+		efi_pci_io_protocol_access_t mem;
+		efi_pci_io_protocol_access_t io;
+		efi_pci_io_protocol_config_access_t pci;
+		void *copy_mem;
+		void *map;
+		void *unmap;
+		void *allocate_buffer;
+		void *free_buffer;
+		void *flush;
+		void *get_location;
+		void *attributes;
+		void *get_bar_attributes;
+		void *set_bar_attributes;
+		uint64_t romsize;
+		void *romimage;
+	};
+	struct {
+		u32 poll_mem;
+		u32 poll_io;
+		efi_pci_io_protocol_access_32_t mem;
+		efi_pci_io_protocol_access_32_t io;
+		efi_pci_io_protocol_access_32_t pci;
+		u32 copy_mem;
+		u32 map;
+		u32 unmap;
+		u32 allocate_buffer;
+		u32 free_buffer;
+		u32 flush;
+		u32 get_location;
+		u32 attributes;
+		u32 get_bar_attributes;
+		u32 set_bar_attributes;
+		u64 romsize;
+		u32 romimage;
+	} mixed_mode;
+};
 
 #define EFI_PCI_IO_ATTRIBUTE_ISA_MOTHERBOARD_IO 0x0001
 #define EFI_PCI_IO_ATTRIBUTE_ISA_IO 0x0002
@@ -502,6 +539,33 @@ typedef struct {
 	u64 get_all;
 } apple_properties_protocol_64_t;
 
+struct efi_dev_path;
+
+typedef union apple_properties_protocol apple_properties_protocol_t;
+
+union apple_properties_protocol {
+	struct {
+		unsigned long version;
+		efi_status_t (*get)(apple_properties_protocol_t *,
+				    struct efi_dev_path *, efi_char16_t *,
+				    void *, u32 *);
+		efi_status_t (*set)(apple_properties_protocol_t *,
+				    struct efi_dev_path *, efi_char16_t *,
+				    void *, u32);
+		efi_status_t (*del)(apple_properties_protocol_t *,
+				    struct efi_dev_path *, efi_char16_t *);
+		efi_status_t (*get_all)(apple_properties_protocol_t *,
+					void *buffer, u32 *);
+	};
+	struct {
+		u32 version;
+		u32 get;
+		u32 set;
+		u32 del;
+		u32 get_all;
+	} mixed_mode;
+};
+
 typedef struct {
 	u32 get_capability;
 	u32 get_event_log;
@@ -524,16 +588,32 @@ typedef struct {
 
 typedef u32 efi_tcg2_event_log_format;
 
-typedef struct {
-	void *get_capability;
-	efi_status_t (*get_event_log)(efi_handle_t, efi_tcg2_event_log_format,
-		efi_physical_addr_t *, efi_physical_addr_t *, efi_bool_t *);
-	void *hash_log_extend_event;
-	void *submit_command;
-	void *get_active_pcr_banks;
-	void *set_active_pcr_banks;
-	void *get_result_of_set_active_pcr_banks;
-} efi_tcg2_protocol_t;
+typedef union efi_tcg2_protocol efi_tcg2_protocol_t;
+
+union efi_tcg2_protocol {
+	struct {
+		void *get_capability;
+		efi_status_t (*get_event_log)(efi_handle_t,
+					      efi_tcg2_event_log_format,
+					      efi_physical_addr_t *,
+					      efi_physical_addr_t *,
+					      efi_bool_t *);
+		void *hash_log_extend_event;
+		void *submit_command;
+		void *get_active_pcr_banks;
+		void *set_active_pcr_banks;
+		void *get_result_of_set_active_pcr_banks;
+	};
+	struct {
+		u32 get_capability;
+		u32 get_event_log;
+		u32 hash_log_extend_event;
+		u32 submit_command;
+		u32 get_active_pcr_banks;
+		u32 set_active_pcr_banks;
+		u32 get_result_of_set_active_pcr_banks;
+	} mixed_mode;
+};
 
 /*
  * Types and defines for EFI ResetSystem
@@ -618,22 +698,25 @@ typedef efi_status_t efi_query_variable_store_t(u32 attributes,
 						unsigned long size,
 						bool nonblocking);
 
-typedef struct {
-	efi_table_hdr_t			hdr;
-	efi_get_time_t			*get_time;
-	efi_set_time_t			*set_time;
-	efi_get_wakeup_time_t		*get_wakeup_time;
-	efi_set_wakeup_time_t		*set_wakeup_time;
-	efi_set_virtual_address_map_t	*set_virtual_address_map;
-	void				*convert_pointer;
-	efi_get_variable_t		*get_variable;
-	efi_get_next_variable_t		*get_next_variable;
-	efi_set_variable_t		*set_variable;
-	efi_get_next_high_mono_count_t	*get_next_high_mono_count;
-	efi_reset_system_t		*reset_system;
-	efi_update_capsule_t		*update_capsule;
-	efi_query_capsule_caps_t	*query_capsule_caps;
-	efi_query_variable_info_t	*query_variable_info;
+typedef union {
+	struct {
+		efi_table_hdr_t			hdr;
+		efi_get_time_t			*get_time;
+		efi_set_time_t			*set_time;
+		efi_get_wakeup_time_t		*get_wakeup_time;
+		efi_set_wakeup_time_t		*set_wakeup_time;
+		efi_set_virtual_address_map_t	*set_virtual_address_map;
+		void				*convert_pointer;
+		efi_get_variable_t		*get_variable;
+		efi_get_next_variable_t		*get_next_variable;
+		efi_set_variable_t		*set_variable;
+		efi_get_next_high_mono_count_t	*get_next_high_mono_count;
+		efi_reset_system_t		*reset_system;
+		efi_update_capsule_t		*update_capsule;
+		efi_query_capsule_caps_t	*query_capsule_caps;
+		efi_query_variable_info_t	*query_variable_info;
+	};
+	efi_runtime_services_32_t mixed_mode;
 } efi_runtime_services_t;
 
 void efi_native_runtime_setup(void);
@@ -719,9 +802,12 @@ typedef struct {
 	u32 table;
 } efi_config_table_32_t;
 
-typedef struct {
-	efi_guid_t guid;
-	unsigned long table;
+typedef union {
+	struct {
+		efi_guid_t guid;
+		unsigned long table;
+	};
+	efi_config_table_32_t mixed_mode;
 } efi_config_table_t;
 
 typedef struct {
@@ -773,20 +859,23 @@ typedef struct {
 	u32 tables;
 } efi_system_table_32_t;
 
-typedef struct {
-	efi_table_hdr_t hdr;
-	unsigned long fw_vendor;	/* physical addr of CHAR16 vendor string */
-	u32 fw_revision;
-	unsigned long con_in_handle;
-	unsigned long con_in;
-	unsigned long con_out_handle;
-	unsigned long con_out;
-	unsigned long stderr_handle;
-	unsigned long stderr;
-	efi_runtime_services_t *runtime;
-	efi_boot_services_t *boottime;
-	unsigned long nr_tables;
-	unsigned long tables;
+typedef union {
+	struct {
+		efi_table_hdr_t hdr;
+		unsigned long fw_vendor;	/* physical addr of CHAR16 vendor string */
+		u32 fw_revision;
+		unsigned long con_in_handle;
+		unsigned long con_in;
+		unsigned long con_out_handle;
+		unsigned long con_out;
+		unsigned long stderr_handle;
+		unsigned long stderr;
+		efi_runtime_services_t *runtime;
+		efi_boot_services_t *boottime;
+		unsigned long nr_tables;
+		unsigned long tables;
+	};
+	efi_system_table_32_t mixed_mode;
 } efi_system_table_t;
 
 /*
@@ -856,22 +945,40 @@ typedef struct {
 	u64 unload;
 } efi_loaded_image_64_t;
 
-typedef struct {
-	u32 revision;
-	efi_handle_t parent_handle;
-	efi_system_table_t *system_table;
-	efi_handle_t device_handle;
-	void *file_path;
-	void *reserved;
-	u32 load_options_size;
-	void *load_options;
-	void *image_base;
-	__aligned_u64 image_size;
-	unsigned int image_code_type;
-	unsigned int image_data_type;
-	efi_status_t (*unload)(efi_handle_t image_handle);
-} efi_loaded_image_t;
+typedef union efi_loaded_image efi_loaded_image_t;
 
+union efi_loaded_image {
+	struct {
+		u32 revision;
+		efi_handle_t parent_handle;
+		efi_system_table_t *system_table;
+		efi_handle_t device_handle;
+		void *file_path;
+		void *reserved;
+		u32 load_options_size;
+		void *load_options;
+		void *image_base;
+		__aligned_u64 image_size;
+		unsigned int image_code_type;
+		unsigned int image_data_type;
+		efi_status_t (*unload)(efi_handle_t image_handle);
+	};
+	struct {
+		u32 revision;
+		u32 parent_handle;
+		u32 system_table;
+		u32 device_handle;
+		u32 file_path;
+		u32 reserved;
+		u32 load_options_size;
+		u32 load_options;
+		u32 image_base;
+		__aligned_u64 image_size;
+		unsigned int image_code_type;
+		unsigned int image_data_type;
+		u32 unload;
+	} mixed_mode;
+};
 
 typedef struct {
 	u64 size;
@@ -912,23 +1019,40 @@ typedef struct {
 	u64 flush;
 } efi_file_handle_64_t;
 
-typedef struct _efi_file_handle {
-	u64 revision;
-	efi_status_t (*open)(struct _efi_file_handle *,
-			     struct _efi_file_handle **,
-			     efi_char16_t *, u64, u64);
-	efi_status_t (*close)(struct _efi_file_handle *);
-	void *delete;
-	efi_status_t (*read)(struct _efi_file_handle *, unsigned long *,
-			     void *);
-	void *write;
-	void *get_position;
-	void *set_position;
-	efi_status_t (*get_info)(struct _efi_file_handle *, efi_guid_t *,
-			unsigned long *, void *);
-	void *set_info;
-	void *flush;
-} efi_file_handle_t;
+typedef union efi_file_handle efi_file_handle_t;
+
+union efi_file_handle {
+	struct {
+		u64 revision;
+		efi_status_t (*open)(efi_file_handle_t *,
+				     efi_file_handle_t **,
+				     efi_char16_t *, u64, u64);
+		efi_status_t (*close)(efi_file_handle_t *);
+		void *delete;
+		efi_status_t (*read)(efi_file_handle_t *, unsigned long *,
+				     void *);
+		void *write;
+		void *get_position;
+		void *set_position;
+		efi_status_t (*get_info)(efi_file_handle_t *, efi_guid_t *,
+				unsigned long *, void *);
+		void *set_info;
+		void *flush;
+	};
+	struct {
+		u64 revision;
+		u32 open;
+		u32 close;
+		u32 delete;
+		u32 read;
+		u32 write;
+		u32 get_position;
+		u32 set_position;
+		u32 get_info;
+		u32 set_info;
+		u32 flush;
+	} mixed_mode;
+};
 
 typedef struct {
 	u64 revision;
@@ -940,11 +1064,19 @@ typedef struct {
 	u64 open_volume;
 } efi_file_io_interface_64_t;
 
-typedef struct _efi_file_io_interface {
-	u64 revision;
-	int (*open_volume)(struct _efi_file_io_interface *,
-			   efi_file_handle_t **);
-} efi_file_io_interface_t;
+typedef union efi_file_io_interface efi_file_io_interface_t;
+
+union efi_file_io_interface {
+	struct {
+		u64 revision;
+		int (*open_volume)(efi_file_io_interface_t *,
+				   efi_file_handle_t **);
+	};
+	struct {
+		u64 revision;
+		u32 open_volume;
+	} mixed_mode;
+} ;
 
 #define EFI_FILE_MODE_READ	0x0000000000000001
 #define EFI_FILE_MODE_WRITE	0x0000000000000002
@@ -1416,10 +1548,20 @@ typedef struct {
 	u64 test_string;
 } efi_simple_text_output_protocol_64_t;
 
-struct efi_simple_text_output_protocol {
-	void *reset;
-	efi_status_t (*output_string)(void *, void *);
-	void *test_string;
+typedef union efi_simple_text_output_protocol efi_simple_text_output_protocol_t;
+
+union efi_simple_text_output_protocol {
+	struct {
+		void *reset;
+		efi_status_t (*output_string)(efi_simple_text_output_protocol_t *,
+					      efi_char16_t *);
+		void *test_string;
+	};
+	struct {
+		u32 reset;
+		u32 output_string;
+		u32 test_string;
+	} mixed_mode;
 };
 
 #define PIXEL_RGB_RESERVED_8BIT_PER_COLOR		0
@@ -1462,14 +1604,26 @@ typedef struct {
 	u64 frame_buffer_size;
 } efi_graphics_output_protocol_mode_64_t;
 
-typedef struct {
-	u32 max_mode;
-	u32 mode;
-	efi_graphics_output_mode_info_t *info;
-	unsigned long size_of_info;
-	efi_physical_addr_t frame_buffer_base;
-	unsigned long frame_buffer_size;
-} efi_graphics_output_protocol_mode_t;
+typedef union efi_graphics_output_protocol_mode efi_graphics_output_protocol_mode_t;
+
+union efi_graphics_output_protocol_mode {
+	struct {
+		u32 max_mode;
+		u32 mode;
+		efi_graphics_output_mode_info_t *info;
+		unsigned long size_of_info;
+		efi_physical_addr_t frame_buffer_base;
+		unsigned long frame_buffer_size;
+	};
+	struct {
+		u32 max_mode;
+		u32 mode;
+		u32 info;
+		u32 size_of_info;
+		u64 frame_buffer_base;
+		u32 frame_buffer_size;
+	} mixed_mode;
+};
 
 typedef struct {
 	u32 query_mode;
@@ -1485,12 +1639,22 @@ typedef struct {
 	u64 mode;
 } efi_graphics_output_protocol_64_t;
 
-typedef struct {
-	void *query_mode;
-	void *set_mode;
-	void *blt;
-	efi_graphics_output_protocol_mode_t *mode;
-} efi_graphics_output_protocol_t;
+typedef union efi_graphics_output_protocol efi_graphics_output_protocol_t;
+
+union efi_graphics_output_protocol {
+	struct {
+		void *query_mode;
+		void *set_mode;
+		void *blt;
+		efi_graphics_output_protocol_mode_t *mode;
+	};
+	struct {
+		u32 query_mode;
+		u32 set_mode;
+		u32 blt;
+		u32 mode;
+	} mixed_mode;
+};
 
 extern struct list_head efivar_sysfs_list;
 

commit 2732ea0d5c0a67ec86bfbde2bd68b6152e23ec4e
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 24 16:10:07 2019 +0100

    efi/libstub: Use a helper to iterate over a EFI handle array
    
    Iterating over a EFI handle array is a bit finicky, since we have
    to take mixed mode into account, where handles are only 32-bit
    while the native efi_handle_t type is 64-bit.
    
    So introduce a helper, and replace the various occurrences of
    this pattern.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-8-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 561db9deedae..8d267715ce22 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -48,6 +48,19 @@ typedef u16 efi_char16_t;		/* UNICODE character */
 typedef u64 efi_physical_addr_t;
 typedef void *efi_handle_t;
 
+#define efi_get_handle_at(array, idx)					\
+	(efi_is_64bit() ? (efi_handle_t)(unsigned long)((u64 *)(array))[idx] \
+		: (efi_handle_t)(unsigned long)((u32 *)(array))[idx])
+
+#define efi_get_handle_num(size)					\
+	((size) / (efi_is_64bit() ? sizeof(u64) : sizeof(u32)))
+
+#define for_each_efi_handle(handle, array, size, i)			\
+	for (i = 0;							\
+	     i < efi_get_handle_num(size) &&				\
+		((handle = efi_get_handle_at((array), i)) || true);	\
+	     i++)
+
 /*
  * The UEFI spec and EDK2 reference implementation both define EFI_GUID as
  * struct { u32 a; u16; b; u16 c; u8 d[8]; }; and so the implied alignment

commit 44c84b4ada73b8ff156181fcf6e320459b8daefd
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Tue Dec 24 16:10:03 2019 +0100

    efi/gop: Convert GOP structures to typedef and clean up some types
    
    Use typedef for the GOP structures, in anticipation of unifying
    32/64-bit code. Also use more appropriate types in the non-bitness
    specific structures for the framebuffer address and pointers.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-4-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 9ea81cfe1576..561db9deedae 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1415,69 +1415,69 @@ struct efi_simple_text_output_protocol {
 #define PIXEL_BLT_ONLY					3
 #define PIXEL_FORMAT_MAX				4
 
-struct efi_pixel_bitmask {
+typedef struct {
 	u32 red_mask;
 	u32 green_mask;
 	u32 blue_mask;
 	u32 reserved_mask;
-};
+} efi_pixel_bitmask_t;
 
-struct efi_graphics_output_mode_info {
+typedef struct {
 	u32 version;
 	u32 horizontal_resolution;
 	u32 vertical_resolution;
 	int pixel_format;
-	struct efi_pixel_bitmask pixel_information;
+	efi_pixel_bitmask_t pixel_information;
 	u32 pixels_per_scan_line;
-};
+} efi_graphics_output_mode_info_t;
 
-struct efi_graphics_output_protocol_mode_32 {
+typedef struct {
 	u32 max_mode;
 	u32 mode;
 	u32 info;
 	u32 size_of_info;
 	u64 frame_buffer_base;
 	u32 frame_buffer_size;
-};
+} efi_graphics_output_protocol_mode_32_t;
 
-struct efi_graphics_output_protocol_mode_64 {
+typedef struct {
 	u32 max_mode;
 	u32 mode;
 	u64 info;
 	u64 size_of_info;
 	u64 frame_buffer_base;
 	u64 frame_buffer_size;
-};
+} efi_graphics_output_protocol_mode_64_t;
 
-struct efi_graphics_output_protocol_mode {
+typedef struct {
 	u32 max_mode;
 	u32 mode;
-	unsigned long info;
+	efi_graphics_output_mode_info_t *info;
 	unsigned long size_of_info;
-	u64 frame_buffer_base;
+	efi_physical_addr_t frame_buffer_base;
 	unsigned long frame_buffer_size;
-};
+} efi_graphics_output_protocol_mode_t;
 
-struct efi_graphics_output_protocol_32 {
+typedef struct {
 	u32 query_mode;
 	u32 set_mode;
 	u32 blt;
 	u32 mode;
-};
+} efi_graphics_output_protocol_32_t;
 
-struct efi_graphics_output_protocol_64 {
+typedef struct {
 	u64 query_mode;
 	u64 set_mode;
 	u64 blt;
 	u64 mode;
-};
+} efi_graphics_output_protocol_64_t;
 
-struct efi_graphics_output_protocol {
-	unsigned long query_mode;
-	unsigned long set_mode;
-	unsigned long blt;
-	struct efi_graphics_output_protocol_mode *mode;
-};
+typedef struct {
+	void *query_mode;
+	void *set_mode;
+	void *blt;
+	efi_graphics_output_protocol_mode_t *mode;
+} efi_graphics_output_protocol_t;
 
 extern struct list_head efivar_sysfs_list;
 

commit 6c895c2fca8a8d4e740b5498b48f81111569502a
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Tue Dec 24 16:10:02 2019 +0100

    efi/gop: Remove unused typedef
    
    We have stopped using gop->query_mode(), so remove the unused typedef
    for the function prototype.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-3-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 83a62f5c3fd7..9ea81cfe1576 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1479,10 +1479,6 @@ struct efi_graphics_output_protocol {
 	struct efi_graphics_output_protocol_mode *mode;
 };
 
-typedef efi_status_t (*efi_graphics_output_protocol_query_mode)(
-	struct efi_graphics_output_protocol *, u32, unsigned long *,
-	struct efi_graphics_output_mode_info **);
-
 extern struct list_head efivar_sysfs_list;
 
 static inline void

commit 8d62af1778125bd674cc66e8432305cc6aac5d89
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Tue Dec 24 16:10:01 2019 +0100

    efi/gop: Remove bogus packed attribute from GOP structures
    
    EFI structures are not packed, they follow natural alignment.
    
    The packed attribute doesn't have any effect on the structure layout due
    to the types and order of the members, and we only ever get these
    structures as output from the EFI firmware so alignment issues have not
    come up.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191224151025.32482-2-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index aa54586db7a5..83a62f5c3fd7 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1429,7 +1429,7 @@ struct efi_graphics_output_mode_info {
 	int pixel_format;
 	struct efi_pixel_bitmask pixel_information;
 	u32 pixels_per_scan_line;
-} __packed;
+};
 
 struct efi_graphics_output_protocol_mode_32 {
 	u32 max_mode;
@@ -1438,7 +1438,7 @@ struct efi_graphics_output_protocol_mode_32 {
 	u32 size_of_info;
 	u64 frame_buffer_base;
 	u32 frame_buffer_size;
-} __packed;
+};
 
 struct efi_graphics_output_protocol_mode_64 {
 	u32 max_mode;
@@ -1447,7 +1447,7 @@ struct efi_graphics_output_protocol_mode_64 {
 	u64 size_of_info;
 	u64 frame_buffer_base;
 	u64 frame_buffer_size;
-} __packed;
+};
 
 struct efi_graphics_output_protocol_mode {
 	u32 max_mode;
@@ -1456,7 +1456,7 @@ struct efi_graphics_output_protocol_mode {
 	unsigned long size_of_info;
 	u64 frame_buffer_base;
 	unsigned long frame_buffer_size;
-} __packed;
+};
 
 struct efi_graphics_output_protocol_32 {
 	u32 query_mode;

commit 9fa76ca7b8bdcdf51fc8c7b7b7a7bfc4eccceb58
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Fri Dec 6 16:55:41 2019 +0000

    efi: Fix efi_loaded_image_t::unload type
    
    The ::unload field is a function pointer, so it should be u32 for 32-bit,
    u64 for 64-bit. Add a prototype for it in the native efi_loaded_image_t
    type. Also change type of parent_handle and device_handle from void * to
    efi_handle_t for documentation purposes.
    
    The unload method is not used, so no functional change.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Bhupesh Sharma <bhsharma@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Masayoshi Mizuma <m.mizuma@jp.fujitsu.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191206165542.31469-6-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 99dfea595c8c..aa54586db7a5 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -824,7 +824,7 @@ typedef struct {
 	__aligned_u64 image_size;
 	unsigned int image_code_type;
 	unsigned int image_data_type;
-	unsigned long unload;
+	u32 unload;
 } efi_loaded_image_32_t;
 
 typedef struct {
@@ -840,14 +840,14 @@ typedef struct {
 	__aligned_u64 image_size;
 	unsigned int image_code_type;
 	unsigned int image_data_type;
-	unsigned long unload;
+	u64 unload;
 } efi_loaded_image_64_t;
 
 typedef struct {
 	u32 revision;
-	void *parent_handle;
+	efi_handle_t parent_handle;
 	efi_system_table_t *system_table;
-	void *device_handle;
+	efi_handle_t device_handle;
 	void *file_path;
 	void *reserved;
 	u32 load_options_size;
@@ -856,7 +856,7 @@ typedef struct {
 	__aligned_u64 image_size;
 	unsigned int image_code_type;
 	unsigned int image_data_type;
-	unsigned long unload;
+	efi_status_t (*unload)(efi_handle_t image_handle);
 } efi_loaded_image_t;
 
 

commit 6e9f879684b46331f51d0c76ebee981c788417db
Merge: 9e7a03233e02 782b59711e15
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 26 19:25:25 2019 -0800

    Merge tag 'acpi-5.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI updates from Rafael Wysocki:
     "These update the ACPICA code in the kernel to upstream revision
      20191018, add support for EFI specific purpose memory, update the ACPI
      EC driver to make it work on systems with hardware-reduced ACPI,
      improve ACPI-based device enumeration for some platforms, rework the
      lid blacklist handling in the button driver and add more lid quirks to
      it, unify ACPI _HID/_UID matching, fix assorted issues and clean up
      the code and documentation.
    
      Specifics:
    
       - Update the ACPICA code in the kernel to upstream revision 20191018
         including:
          * Fixes for Clang warnings (Bob Moore)
          * Fix for possible overflow in get_tick_count() (Bob Moore)
          * Introduction of acpi_unload_table() (Bob Moore)
          * Debugger and utilities updates (Erik Schmauss)
          * Fix for unloading tables loaded via configfs (Nikolaus Voss)
    
       - Add support for EFI specific purpose memory to optionally allow
         either application-exclusive or core-kernel-mm managed access to
         differentiated memory (Dan Williams)
    
       - Fix and clean up processing of the HMAT table (Brice Goglin, Qian
         Cai, Tao Xu)
    
       - Update the ACPI EC driver to make it work on systems with
         hardware-reduced ACPI (Daniel Drake)
    
       - Always build in support for the Generic Event Device (GED) to allow
         one kernel binary to work both on systems with full hardware ACPI
         and hardware-reduced ACPI (Arjan van de Ven)
    
       - Fix the table unload mechanism to unregister platform devices
         created when the given table was loaded (Andy Shevchenko)
    
       - Rework the lid blacklist handling in the button driver and add more
         lid quirks to it (Hans de Goede)
    
       - Improve ACPI-based device enumeration for some platforms based on
         Intel BayTrail SoCs (Hans de Goede)
    
       - Add an OpRegion driver for the Cherry Trail Crystal Cove PMIC and
         prevent handlers from being registered for unhandled PMIC OpRegions
         (Hans de Goede)
    
       - Unify ACPI _HID/_UID matching (Andy Shevchenko)
    
       - Clean up documentation and comments (Cao jin, James Pack, Kacper
         Piwiński)"
    
    * tag 'acpi-5.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (52 commits)
      ACPI: OSI: Shoot duplicate word
      ACPI: HMAT: use %u instead of %d to print u32 values
      ACPI: NUMA: HMAT: fix a section mismatch
      ACPI: HMAT: don't mix pxm and nid when setting memory target processor_pxm
      ACPI: NUMA: HMAT: Register "soft reserved" memory as an "hmem" device
      ACPI: NUMA: HMAT: Register HMAT at device_initcall level
      device-dax: Add a driver for "hmem" devices
      dax: Fix alloc_dax_region() compile warning
      lib: Uplevel the pmem "region" ida to a global allocator
      x86/efi: Add efi_fake_mem support for EFI_MEMORY_SP
      arm/efi: EFI soft reservation to memblock
      x86/efi: EFI soft reservation to E820 enumeration
      efi: Common enable/disable infrastructure for EFI soft reservation
      x86/efi: Push EFI_MEMMAP check into leaf routines
      efi: Enumerate EFI_MEMORY_SP
      ACPI: NUMA: Establish a new drivers/acpi/numa/ directory
      ACPICA: Update version to 20191018
      ACPICA: debugger: remove leading whitespaces when converting a string to a buffer
      ACPICA: acpiexec: initialize all simple types and field units from user input
      ACPICA: debugger: add field unit support for acpi_db_get_next_token
      ...

commit b617c5266eedbef2ccbb90931bb9175faa4ae0bc
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Nov 6 17:43:11 2019 -0800

    efi: Common enable/disable infrastructure for EFI soft reservation
    
    UEFI 2.8 defines an EFI_MEMORY_SP attribute bit to augment the
    interpretation of the EFI Memory Types as "reserved for a specific
    purpose".
    
    The proposed Linux behavior for specific purpose memory is that it is
    reserved for direct-access (device-dax) by default and not available for
    any kernel usage, not even as an OOM fallback.  Later, through udev
    scripts or another init mechanism, these device-dax claimed ranges can
    be reconfigured and hot-added to the available System-RAM with a unique
    node identifier. This device-dax management scheme implements "soft" in
    the "soft reserved" designation by allowing some or all of the
    reservation to be recovered as typical memory. This policy can be
    disabled at compile-time with CONFIG_EFI_SOFT_RESERVE=n, or runtime with
    efi=nosoftreserve.
    
    As for this patch, define the common helpers to determine if the
    EFI_MEMORY_SP attribute should be honored. The determination needs to be
    made early to prevent the kernel from being loaded into soft-reserved
    memory, or otherwise allowing early allocations to land there. Follow-on
    changes are needed per architecture to leverage these helpers in their
    respective mem-init paths.
    
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 44c85b559e15..88654910ce29 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1202,6 +1202,7 @@ extern int __init efi_setup_pcdp_console(char *);
 #define EFI_DBG			8	/* Print additional debug info at runtime */
 #define EFI_NX_PE_DATA		9	/* Can runtime data regions be mapped non-executable? */
 #define EFI_MEM_ATTR		10	/* Did firmware publish an EFI_MEMORY_ATTRIBUTES table? */
+#define EFI_MEM_NO_SOFT_RESERVE	11	/* Is the kernel configured to ignore soft reservations? */
 
 #ifdef CONFIG_EFI
 /*
@@ -1212,6 +1213,14 @@ static inline bool efi_enabled(int feature)
 	return test_bit(feature, &efi.flags) != 0;
 }
 extern void efi_reboot(enum reboot_mode reboot_mode, const char *__unused);
+
+bool __pure __efi_soft_reserve_enabled(void);
+
+static inline bool __pure efi_soft_reserve_enabled(void)
+{
+	return IS_ENABLED(CONFIG_EFI_SOFT_RESERVE)
+		&& __efi_soft_reserve_enabled();
+}
 #else
 static inline bool efi_enabled(int feature)
 {
@@ -1225,6 +1234,11 @@ efi_capsule_pending(int *reset_type)
 {
 	return false;
 }
+
+static inline bool efi_soft_reserve_enabled(void)
+{
+	return false;
+}
 #endif
 
 extern int efi_status_to_err(efi_status_t status);

commit 6950e31b35fdf4588cbbdec1813091bb02cf8871
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Nov 6 17:43:05 2019 -0800

    x86/efi: Push EFI_MEMMAP check into leaf routines
    
    In preparation for adding another EFI_MEMMAP dependent call that needs
    to occur before e820__memblock_setup() fixup the existing efi calls to
    check for EFI_MEMMAP internally. This ends up being cleaner than the
    alternative of checking EFI_MEMMAP multiple times in setup_arch().
    
    Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 78c75992b313..44c85b559e15 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1045,7 +1045,6 @@ extern void efi_enter_virtual_mode (void);	/* switch EFI to virtual mode, if pos
 extern efi_status_t efi_query_variable_store(u32 attributes,
 					     unsigned long size,
 					     bool nonblocking);
-extern void efi_find_mirror(void);
 #else
 
 static inline efi_status_t efi_query_variable_store(u32 attributes,

commit fe3e5e65c06edb1c56e64e567f053e243142001f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Nov 6 17:43:00 2019 -0800

    efi: Enumerate EFI_MEMORY_SP
    
    UEFI 2.8 defines an EFI_MEMORY_SP attribute bit to augment the
    interpretation of the EFI Memory Types as "reserved for a specific
    purpose". The intent of this bit is to allow the OS to identify precious
    or scarce memory resources and optionally manage it separately from
    EfiConventionalMemory. As defined older OSes that do not know about this
    attribute are permitted to ignore it and the memory will be handled
    according to the OS default policy for the given memory type.
    
    In other words, this "specific purpose" hint is deliberately weaker than
    EfiReservedMemoryType in that the system continues to operate if the OS
    takes no action on the attribute. The risk of taking no action is
    potentially unwanted / unmovable kernel allocations from the designated
    resource that prevent the full realization of the "specific purpose".
    For example, consider a system with a high-bandwidth memory pool. Older
    kernels are permitted to boot and consume that memory as conventional
    "System-RAM" newer kernels may arrange for that memory to be set aside
    (soft reserved) by the system administrator for a dedicated
    high-bandwidth memory aware application to consume.
    
    Specifically, this mechanism allows for the elimination of scenarios
    where platform firmware tries to game OS policy by lying about ACPI SLIT
    values, i.e. claiming that a precious memory resource has a high
    distance to trigger the OS to avoid it by default. This reservation hint
    allows platform-firmware to instead tell the truth about performance
    characteristics by indicate to OS memory management to put immovable
    allocations elsewhere.
    
    Implement simple detection of the bit for EFI memory table dumps and
    save the kernel policy for a follow-on change.
    
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index d87acf62958e..78c75992b313 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -112,6 +112,7 @@ typedef	struct {
 #define EFI_MEMORY_MORE_RELIABLE \
 				((u64)0x0000000000010000ULL)	/* higher reliability */
 #define EFI_MEMORY_RO		((u64)0x0000000000020000ULL)	/* read-only */
+#define EFI_MEMORY_SP		((u64)0x0000000000040000ULL)	/* soft reserved */
 #define EFI_MEMORY_RUNTIME	((u64)0x8000000000000000ULL)	/* range requires runtime mapping */
 #define EFI_MEMORY_DESCRIPTOR_VERSION	1
 

commit 0d95981438c3bdb53cc99b0fb656d24d7a80e1f3
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Nov 6 08:06:13 2019 +0100

    x86: efi/random: Invoke EFI_RNG_PROTOCOL to seed the UEFI RNG table
    
    Invoke the EFI_RNG_PROTOCOL protocol in the context of the x86 EFI stub,
    same as is done on arm/arm64 since commit 568bc4e87033 ("efi/arm*/libstub:
    Invoke EFI_RNG_PROTOCOL to seed the UEFI RNG table"). Within the stub,
    a Linux-specific RNG seed UEFI config table will be seeded. The EFI routines
    in the core kernel will pick that up later, yet still early during boot,
    to seed the kernel entropy pool. If CONFIG_RANDOM_TRUST_BOOTLOADER, entropy
    is credited for this seed.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index d87acf62958e..028efa7a9f3b 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1645,6 +1645,8 @@ static inline void
 efi_enable_reset_attack_mitigation(efi_system_table_t *sys_table_arg) { }
 #endif
 
+efi_status_t efi_random_get_seed(efi_system_table_t *sys_table_arg);
+
 void efi_retrieve_tpm2_eventlog(efi_system_table_t *sys_table);
 
 /*

commit 220dd7699c46d5940115bd797b01b2ab047c87b8
Author: Kairui Song <kasong@redhat.com>
Date:   Tue Oct 29 18:37:54 2019 +0100

    x86, efi: Never relocate kernel below lowest acceptable address
    
    Currently, kernel fails to boot on some HyperV VMs when using EFI.
    And it's a potential issue on all x86 platforms.
    
    It's caused by broken kernel relocation on EFI systems, when below three
    conditions are met:
    
    1. Kernel image is not loaded to the default address (LOAD_PHYSICAL_ADDR)
       by the loader.
    2. There isn't enough room to contain the kernel, starting from the
       default load address (eg. something else occupied part the region).
    3. In the memmap provided by EFI firmware, there is a memory region
       starts below LOAD_PHYSICAL_ADDR, and suitable for containing the
       kernel.
    
    EFI stub will perform a kernel relocation when condition 1 is met. But
    due to condition 2, EFI stub can't relocate kernel to the preferred
    address, so it fallback to ask EFI firmware to alloc lowest usable memory
    region, got the low region mentioned in condition 3, and relocated
    kernel there.
    
    It's incorrect to relocate the kernel below LOAD_PHYSICAL_ADDR. This
    is the lowest acceptable kernel relocation address.
    
    The first thing goes wrong is in arch/x86/boot/compressed/head_64.S.
    Kernel decompression will force use LOAD_PHYSICAL_ADDR as the output
    address if kernel is located below it. Then the relocation before
    decompression, which move kernel to the end of the decompression buffer,
    will overwrite other memory region, as there is no enough memory there.
    
    To fix it, just don't let EFI stub relocate the kernel to any address
    lower than lowest acceptable address.
    
    [ ardb: introduce efi_low_alloc_above() to reduce the scope of the change ]
    
    Signed-off-by: Kairui Song <kasong@redhat.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191029173755.27149-6-ardb@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index bd3837022307..d87acf62958e 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1579,9 +1579,22 @@ char *efi_convert_cmdline(efi_system_table_t *sys_table_arg,
 efi_status_t efi_get_memory_map(efi_system_table_t *sys_table_arg,
 				struct efi_boot_memmap *map);
 
+efi_status_t efi_low_alloc_above(efi_system_table_t *sys_table_arg,
+				 unsigned long size, unsigned long align,
+				 unsigned long *addr, unsigned long min);
+
+static inline
 efi_status_t efi_low_alloc(efi_system_table_t *sys_table_arg,
 			   unsigned long size, unsigned long align,
-			   unsigned long *addr);
+			   unsigned long *addr)
+{
+	/*
+	 * Don't allocate at 0x0. It will confuse code that
+	 * checks pointers against NULL. Skip the first 8
+	 * bytes so we start at a nice even number.
+	 */
+	return efi_low_alloc_above(sys_table_arg, size, align, addr, 0x8);
+}
 
 efi_status_t efi_high_alloc(efi_system_table_t *sys_table_arg,
 			    unsigned long size, unsigned long align,
@@ -1592,7 +1605,8 @@ efi_status_t efi_relocate_kernel(efi_system_table_t *sys_table_arg,
 				 unsigned long image_size,
 				 unsigned long alloc_size,
 				 unsigned long preferred_addr,
-				 unsigned long alignment);
+				 unsigned long alignment,
+				 unsigned long min_addr);
 
 efi_status_t handle_cmdline_files(efi_system_table_t *sys_table_arg,
 				  efi_loaded_image_t *image,

commit 1c5fecb61255aa12a16c4c06335ab68979865914
Author: Narendra K <Narendra.K@dell.com>
Date:   Wed Jul 10 18:59:15 2019 +0000

    efi: Export Runtime Configuration Interface table to sysfs
    
    System firmware advertises the address of the 'Runtime
    Configuration Interface table version 2 (RCI2)' via
    an EFI Configuration Table entry. This code retrieves the RCI2
    table from the address and exports it to sysfs as a binary
    attribute 'rci2' under /sys/firmware/efi/tables directory.
    The approach adopted is similar to the attribute 'DMI' under
    /sys/firmware/dmi/tables.
    
    RCI2 table contains BIOS HII in XML format and is used to populate
    BIOS setup page in Dell EMC OpenManage Server Administrator tool.
    The BIOS setup page contains BIOS tokens which can be configured.
    
    Signed-off-by: Narendra K <Narendra.K@dell.com>
    Reviewed-by: Mario Limonciello <mario.limonciello@dell.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index f88318b85fb0..bd3837022307 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -692,6 +692,9 @@ void efi_native_runtime_setup(void);
 #define LINUX_EFI_TPM_FINAL_LOG_GUID		EFI_GUID(0x1e2ed096, 0x30e2, 0x4254,  0xbd, 0x89, 0x86, 0x3b, 0xbe, 0xf8, 0x23, 0x25)
 #define LINUX_EFI_MEMRESERVE_TABLE_GUID		EFI_GUID(0x888eb0c6, 0x8ede, 0x4ff5,  0xa8, 0xf0, 0x9a, 0xee, 0x5c, 0xb9, 0x77, 0xc2)
 
+/* OEM GUIDs */
+#define DELLEMC_EFI_RCI2_TABLE_GUID		EFI_GUID(0x2d9f28a2, 0xa886, 0x456a,  0x97, 0xa8, 0xf1, 0x1e, 0xf2, 0x4f, 0xf4, 0x55)
+
 typedef struct {
 	efi_guid_t guid;
 	u64 table;
@@ -1713,6 +1716,8 @@ struct efi_tcg2_final_events_table {
 };
 extern int efi_tpm_final_log_size;
 
+extern unsigned long rci2_table_phys;
+
 /*
  * efi_runtime_service() function identifiers.
  * "NONE" is used by efi_recover_from_page_fault() to check if the page

commit 5828efb95bc43ad6a59f05458d3aed9649dd5a63
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Jun 25 16:28:53 2019 +0200

    efi: ia64: move SAL systab handling out of generic EFI code
    
    The SAL systab is an Itanium specific EFI configuration table, so
    move its handling into arch/ia64 where it belongs.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 171bb1005a10..f88318b85fb0 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -984,7 +984,6 @@ extern struct efi {
 	unsigned long acpi20;		/* ACPI table  (ACPI 2.0) */
 	unsigned long smbios;		/* SMBIOS table (32 bit entry point) */
 	unsigned long smbios3;		/* SMBIOS table (64 bit entry point) */
-	unsigned long sal_systab;	/* SAL system table */
 	unsigned long boot_info;	/* boot info table */
 	unsigned long hcdp;		/* HCDP table */
 	unsigned long uga;		/* UGA table */

commit ec7e1605d79d1d469b25e396f2056e42386f512f
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Jun 25 15:48:35 2019 +0200

    efi/x86: move UV_SYSTAB handling into arch/x86
    
    The SGI UV UEFI machines are tightly coupled to the x86 architecture
    so there is no need to keep any awareness of its existence in the
    generic EFI layer, especially since we already have the infrastructure
    to handle arch-specific configuration tables, and were even already
    using it to some extent.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 60a6242765d8..171bb1005a10 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -988,7 +988,6 @@ extern struct efi {
 	unsigned long boot_info;	/* boot info table */
 	unsigned long hcdp;		/* HCDP table */
 	unsigned long uga;		/* UGA table */
-	unsigned long uv_systab;	/* UV system table */
 	unsigned long fw_vendor;	/* fw_vendor */
 	unsigned long runtime;		/* runtime table */
 	unsigned long config_table;	/* config tables */

commit e55f31a599478fb06a5a5d95e019e963322535cb
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Jun 25 15:36:45 2019 +0200

    efi: x86: move efi_is_table_address() into arch/x86
    
    The function efi_is_table_address() and the associated array of table
    pointers is specific to x86. Since we will be adding some more x86
    specific tables, let's move this code out of the generic code first.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index f87fabea4a85..60a6242765d8 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1211,8 +1211,6 @@ static inline bool efi_enabled(int feature)
 	return test_bit(feature, &efi.flags) != 0;
 }
 extern void efi_reboot(enum reboot_mode reboot_mode, const char *__unused);
-
-extern bool efi_is_table_address(unsigned long phys_addr);
 #else
 static inline bool efi_enabled(int feature)
 {
@@ -1226,11 +1224,6 @@ efi_capsule_pending(int *reset_type)
 {
 	return false;
 }
-
-static inline bool efi_is_table_address(unsigned long phys_addr)
-{
-	return false;
-}
 #endif
 
 extern int efi_status_to_err(efi_status_t status);

commit 166a2809d65b282272c474835ec22c882a39ca1b
Author: Matthew Garrett <matthewgarrett@google.com>
Date:   Fri Jun 7 13:51:47 2019 -0700

    tpm: Don't duplicate events from the final event log in the TCG2 log
    
    After the first call to GetEventLog() on UEFI systems using the TCG2
    crypto agile log format, any further log events (other than those
    triggered by ExitBootServices()) will be logged in both the main log and
    also in the Final Events Log. While the kernel only calls GetEventLog()
    immediately before ExitBootServices(), we can't control whether earlier
    parts of the boot process have done so. This will result in log entries
    that exist in both logs, and so the current approach of simply appending
    the Final Event Log to the main log will result in events being
    duplicated.
    
    We can avoid this problem by looking at the size of the Final Event Log
    just before we call ExitBootServices() and exporting this to the main
    kernel. The kernel can then skip over all events that occured before
    ExitBootServices() and only append events that were not also logged to
    the main log.
    
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Reported-by: Joe Richey <joerichey@google.com>
    Suggested-by: Joe Richey <joerichey@google.com>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index b391263d8ec6..f87fabea4a85 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1708,6 +1708,7 @@ struct linux_efi_random_seed {
 
 struct linux_efi_tpm_eventlog {
 	u32	size;
+	u32	final_events_preboot_size;
 	u8	version;
 	u8	log[];
 };

commit c46f3405692de1ac82240d927b9c7a0f9d6a4a36
Author: Matthew Garrett <mjg59@google.com>
Date:   Mon May 20 13:54:59 2019 -0700

    tpm: Reserve the TPM final events table
    
    UEFI systems provide a boot services protocol for obtaining the TPM
    event log, but this is unusable after ExitBootServices() is called.
    Unfortunately ExitBootServices() itself triggers additional TPM events
    that then can't be obtained using this protocol. The platform provides a
    mechanism for the OS to obtain these events by recording them to a
    separate UEFI configuration table which the OS can then map.
    
    Unfortunately this table isn't self describing in terms of providing its
    length, so we need to parse the events inside it to figure out how long
    it is. Since the table isn't mapped at this point, we need to extend the
    length calculation function to be able to map the event as it goes
    along.
    
    (Fixes by Bartosz Szczepanek <bsz@semihalf.com>)
    
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Bartosz Szczepanek <bsz@semihalf.com>
    Tested-by: Bartosz Szczepanek <bsz@semihalf.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 6ebc2098cfe1..b391263d8ec6 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -689,6 +689,7 @@ void efi_native_runtime_setup(void);
 #define LINUX_EFI_LOADER_ENTRY_GUID		EFI_GUID(0x4a67b082, 0x0a4c, 0x41cf,  0xb6, 0xc7, 0x44, 0x0b, 0x29, 0xbb, 0x8c, 0x4f)
 #define LINUX_EFI_RANDOM_SEED_TABLE_GUID	EFI_GUID(0x1ce1e5bc, 0x7ceb, 0x42f2,  0x81, 0xe5, 0x8a, 0xad, 0xf1, 0x80, 0xf5, 0x7b)
 #define LINUX_EFI_TPM_EVENT_LOG_GUID		EFI_GUID(0xb7799cb0, 0xeca2, 0x4943,  0x96, 0x67, 0x1f, 0xae, 0x07, 0xb7, 0x47, 0xfa)
+#define LINUX_EFI_TPM_FINAL_LOG_GUID		EFI_GUID(0x1e2ed096, 0x30e2, 0x4254,  0xbd, 0x89, 0x86, 0x3b, 0xbe, 0xf8, 0x23, 0x25)
 #define LINUX_EFI_MEMRESERVE_TABLE_GUID		EFI_GUID(0x888eb0c6, 0x8ede, 0x4ff5,  0xa8, 0xf0, 0x9a, 0xee, 0x5c, 0xb9, 0x77, 0xc2)
 
 typedef struct {
@@ -996,6 +997,7 @@ extern struct efi {
 	unsigned long mem_attr_table;	/* memory attributes table */
 	unsigned long rng_seed;		/* UEFI firmware random seed */
 	unsigned long tpm_log;		/* TPM2 Event Log table */
+	unsigned long tpm_final_log;	/* TPM2 Final Events Log table */
 	unsigned long mem_reserve;	/* Linux EFI memreserve table */
 	efi_get_time_t *get_time;
 	efi_set_time_t *set_time;
@@ -1712,6 +1714,13 @@ struct linux_efi_tpm_eventlog {
 
 extern int efi_tpm_eventlog_init(void);
 
+struct efi_tcg2_final_events_table {
+	u64 version;
+	u64 nr_events;
+	u8 events[];
+};
+extern int efi_tpm_final_log_size;
+
 /*
  * efi_runtime_service() function identifiers.
  * "NONE" is used by efi_recover_from_page_fault() to check if the page

commit 0082517fa4bce073e7cf542633439f26538a14cc
Author: Jian-Hong Pan <jian-hong@endlessm.com>
Date:   Fri Apr 12 16:01:53 2019 +0800

    x86/reboot, efi: Use EFI reboot for Acer TravelMate X514-51T
    
    Upon reboot, the Acer TravelMate X514-51T laptop appears to complete the
    shutdown process, but then it hangs in BIOS POST with a black screen.
    
    The problem is intermittent - at some points it has appeared related to
    Secure Boot settings or different kernel builds, but ultimately we have
    not been able to identify the exact conditions that trigger the issue to
    come and go.
    
    Besides, the EFI mode cannot be disabled in the BIOS of this model.
    
    However, after extensive testing, we observe that using the EFI reboot
    method reliably avoids the issue in all cases.
    
    So add a boot time quirk to use EFI reboot on such systems.
    
    Buglink: https://bugzilla.kernel.org/show_bug.cgi?id=203119
    Signed-off-by: Jian-Hong Pan <jian-hong@endlessm.com>
    Signed-off-by: Daniel Drake <drake@endlessm.com>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Cc: linux@endlessm.com
    Link: http://lkml.kernel.org/r/20190412080152.3718-1-jian-hong@endlessm.com
    [ Fix !CONFIG_EFI build failure, clarify the code and the changelog a bit. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 54357a258b35..6ebc2098cfe1 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1611,7 +1611,12 @@ efi_status_t efi_setup_gop(efi_system_table_t *sys_table_arg,
 			   struct screen_info *si, efi_guid_t *proto,
 			   unsigned long size);
 
-bool efi_runtime_disabled(void);
+#ifdef CONFIG_EFI
+extern bool efi_runtime_disabled(void);
+#else
+static inline bool efi_runtime_disabled(void) { return true; }
+#endif
+
 extern void efi_call_virt_check_flags(unsigned long flags, const char *call);
 extern unsigned long efi_call_virt_save_flags(void);
 

commit 3d8dfe75ef69f4dd4ba35c09b20a5aa58b4a5078
Merge: d60752629693 b855b58ac1b7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Mar 10 10:17:23 2019 -0700

    Merge tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux
    
    Pull arm64 updates from Catalin Marinas:
    
     - Pseudo NMI support for arm64 using GICv3 interrupt priorities
    
     - uaccess macros clean-up (unsafe user accessors also merged but
       reverted, waiting for objtool support on arm64)
    
     - ptrace regsets for Pointer Authentication (ARMv8.3) key management
    
     - inX() ordering w.r.t. delay() on arm64 and riscv (acks in place by
       the riscv maintainers)
    
     - arm64/perf updates: PMU bindings converted to json-schema, unused
       variable and misleading comment removed
    
     - arm64/debug fixes to ensure checking of the triggering exception
       level and to avoid the propagation of the UNKNOWN FAR value into the
       si_code for debug signals
    
     - Workaround for Fujitsu A64FX erratum 010001
    
     - lib/raid6 ARM NEON optimisations
    
     - NR_CPUS now defaults to 256 on arm64
    
     - Minor clean-ups (documentation/comments, Kconfig warning, unused
       asm-offsets, clang warnings)
    
     - MAINTAINERS update for list information to the ARM64 ACPI entry
    
    * tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux: (54 commits)
      arm64: mmu: drop paging_init comments
      arm64: debug: Ensure debug handlers check triggering exception level
      arm64: debug: Don't propagate UNKNOWN FAR into si_code for debug signals
      Revert "arm64: uaccess: Implement unsafe accessors"
      arm64: avoid clang warning about self-assignment
      arm64: Kconfig.platforms: fix warning unmet direct dependencies
      lib/raid6: arm: optimize away a mask operation in NEON recovery routine
      lib/raid6: use vdupq_n_u8 to avoid endianness warnings
      arm64: io: Hook up __io_par() for inX() ordering
      riscv: io: Update __io_[p]ar() macros to take an argument
      asm-generic/io: Pass result of I/O accessor to __io_[p]ar()
      arm64: Add workaround for Fujitsu A64FX erratum 010001
      arm64: Rename get_thread_info()
      arm64: Remove documentation about TIF_USEDFPU
      arm64: irqflags: Fix clang build warnings
      arm64: Enable the support of pseudo-NMIs
      arm64: Skip irqflags tracing for NMI in IRQs disabled context
      arm64: Skip preemption when exiting an NMI
      arm64: Handle serror in NMI context
      irqchip/gic-v3: Allow interrupts to be set as pseudo-NMI
      ...

commit c8f5ed6ef972ed4fd10b0c2e2baec3b6803d3c73
Merge: 3717f613f48d 5c418dc789a3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 6 07:13:56 2019 -0800

    Merge branch 'efi-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull EFI updates from Ingo Molnar:
     "The main EFI changes in this cycle were:
    
       - Use 32-bit alignment for efi_guid_t
    
       - Allow the SetVirtualAddressMap() call to be omitted
    
       - Implement earlycon=efifb based on existing earlyprintk code
    
       - Various minor fixes and code cleanups from Sai, Ard and me"
    
    * 'efi-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      efi: Fix build error due to enum collision between efi.h and ima.h
      efi/x86: Convert x86 EFI earlyprintk into generic earlycon implementation
      x86: Make ARCH_USE_MEMREMAP_PROT a generic Kconfig symbol
      efi/arm/arm64: Allow SetVirtualAddressMap() to be omitted
      efi: Replace GPL license boilerplate with SPDX headers
      efi/fdt: Apply more cleanups
      efi: Use 32-bit alignment for efi_guid_t
      efi/memattr: Don't bail on zero VA if it equals the region's PA
      x86/efi: Mark can_free_region() as an __init function

commit 582a32e708823e5957fd73ccd78dc4a9e49d21ea
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Feb 15 13:33:33 2019 +0100

    efi/arm: Revert "Defer persistent reservations until after paging_init()"
    
    This reverts commit eff896288872d687d9662000ec9ae11b6d61766f, which
    deferred the processing of persistent memory reservations to a point
    where the memory may have already been allocated and overwritten,
    defeating the purpose.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20190215123333.21209-3-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 45ff763fba76..28604a8d0aa9 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1198,8 +1198,6 @@ static inline bool efi_enabled(int feature)
 extern void efi_reboot(enum reboot_mode reboot_mode, const char *__unused);
 
 extern bool efi_is_table_address(unsigned long phys_addr);
-
-extern int efi_apply_persistent_mem_reservations(void);
 #else
 static inline bool efi_enabled(int feature)
 {
@@ -1218,11 +1216,6 @@ static inline bool efi_is_table_address(unsigned long phys_addr)
 {
 	return false;
 }
-
-static inline int efi_apply_persistent_mem_reservations(void)
-{
-	return 0;
-}
 #endif
 
 extern int efi_status_to_err(efi_status_t status);

commit 5c418dc789a3898717ebf2caa5716ba91a7150b2
Author: Anders Roxell <anders.roxell@linaro.org>
Date:   Fri Feb 15 17:55:51 2019 +0100

    efi: Fix build error due to enum collision between efi.h and ima.h
    
    The following commit:
    
      a893ea15d764 ("tpm: move tpm_chip definition to include/linux/tpm.h")
    
    introduced a build error when both IMA and EFI are enabled:
    
        In file included from ../security/integrity/ima/ima_fs.c:30:
        ../security/integrity/ima/ima.h:176:7: error: redeclaration of enumerator "NONE"
    
    What happens is that both headers (ima.h and efi.h) defines the same
    'NONE' constant, and it broke when they started getting included from
    the same file:
    
    Rework to prefix the EFI enum with 'EFI_*'.
    
    Signed-off-by: Anders Roxell <anders.roxell@linaro.org>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20190215165551.12220-2-ard.biesheuvel@linaro.org
    [ Cleaned up the changelog a bit. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index be08518c2553..eecd1079617a 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1719,19 +1719,19 @@ extern int efi_tpm_eventlog_init(void);
  * fault happened while executing an efi runtime service.
  */
 enum efi_rts_ids {
-	NONE,
-	GET_TIME,
-	SET_TIME,
-	GET_WAKEUP_TIME,
-	SET_WAKEUP_TIME,
-	GET_VARIABLE,
-	GET_NEXT_VARIABLE,
-	SET_VARIABLE,
-	QUERY_VARIABLE_INFO,
-	GET_NEXT_HIGH_MONO_COUNT,
-	RESET_SYSTEM,
-	UPDATE_CAPSULE,
-	QUERY_CAPSULE_CAPS,
+	EFI_NONE,
+	EFI_GET_TIME,
+	EFI_SET_TIME,
+	EFI_GET_WAKEUP_TIME,
+	EFI_SET_WAKEUP_TIME,
+	EFI_GET_VARIABLE,
+	EFI_GET_NEXT_VARIABLE,
+	EFI_SET_VARIABLE,
+	EFI_QUERY_VARIABLE_INFO,
+	EFI_GET_NEXT_HIGH_MONO_COUNT,
+	EFI_RESET_SYSTEM,
+	EFI_UPDATE_CAPSULE,
+	EFI_QUERY_CAPSULE_CAPS,
 };
 
 /*

commit 13b210ddf474d9f3368766008a89fe82a6f90b48
Author: Julien Thierry <julien.thierry@arm.com>
Date:   Thu Jan 31 14:58:49 2019 +0000

    efi: Let architectures decide the flags that should be saved/restored
    
    Currently, irqflags are saved before calling runtime services and
    checked for mismatch on return.
    
    Provide a pair of overridable macros to save and restore (if needed) the
    state that need to be preserved on return from a runtime service.
    This allows to check for flags that are not necesarly related to
    irqflags.
    
    Signed-off-by: Julien Thierry <julien.thierry@arm.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: linux-efi@vger.kernel.org
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 45ff763fba76..bd80b7ec35db 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1607,6 +1607,7 @@ efi_status_t efi_setup_gop(efi_system_table_t *sys_table_arg,
 
 bool efi_runtime_disabled(void);
 extern void efi_call_virt_check_flags(unsigned long flags, const char *call);
+extern unsigned long efi_call_virt_save_flags(void);
 
 enum efi_secureboot_mode {
 	efi_secureboot_mode_unset,
@@ -1652,7 +1653,7 @@ void efi_retrieve_tpm2_eventlog(efi_system_table_t *sys_table);
 									\
 	arch_efi_call_virt_setup();					\
 									\
-	local_save_flags(__flags);					\
+	__flags = efi_call_virt_save_flags();				\
 	__s = arch_efi_call_virt(p, f, args);				\
 	efi_call_virt_check_flags(__flags, __stringify(f));		\
 									\
@@ -1667,7 +1668,7 @@ void efi_retrieve_tpm2_eventlog(efi_system_table_t *sys_table);
 									\
 	arch_efi_call_virt_setup();					\
 									\
-	local_save_flags(__flags);					\
+	__flags = efi_call_virt_save_flags();				\
 	arch_efi_call_virt(p, f, args);					\
 	efi_call_virt_check_flags(__flags, __stringify(f));		\
 									\

commit 494c704f9af0a0cddf593b381ea44320888733e6
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Sat Feb 2 10:41:13 2019 +0100

    efi: Use 32-bit alignment for efi_guid_t
    
    The UEFI spec and EDK2 reference implementation both define EFI_GUID as
    struct { u32 a; u16; b; u16 c; u8 d[8]; }; and so the implied alignment
    is 32 bits not 8 bits like our guid_t. In some cases (i.e., on 32-bit ARM),
    this means that firmware services invoked by the kernel may assume that
    efi_guid_t* arguments are 32-bit aligned, and use memory accessors that
    do not tolerate misalignment. So let's set the minimum alignment to 32 bits.
    
    Note that the UEFI spec as well as some comments in the EDK2 code base
    suggest that EFI_GUID should be 64-bit aligned, but this appears to be
    a mistake, given that no code seems to exist that actually enforces that
    or relies on it.
    
    Reported-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: AKASHI Takahiro <takahiro.akashi@linaro.org>
    Cc: Alexander Graf <agraf@suse.de>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Lee Jones <lee.jones@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20190202094119.13230-5-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 45ff763fba76..be08518c2553 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -48,7 +48,20 @@ typedef u16 efi_char16_t;		/* UNICODE character */
 typedef u64 efi_physical_addr_t;
 typedef void *efi_handle_t;
 
-typedef guid_t efi_guid_t;
+/*
+ * The UEFI spec and EDK2 reference implementation both define EFI_GUID as
+ * struct { u32 a; u16; b; u16 c; u8 d[8]; }; and so the implied alignment
+ * is 32 bits not 8 bits like our guid_t. In some cases (i.e., on 32-bit ARM),
+ * this means that firmware services invoked by the kernel may assume that
+ * efi_guid_t* arguments are 32-bit aligned, and use memory accessors that
+ * do not tolerate misalignment. So let's set the minimum alignment to 32 bits.
+ *
+ * Note that the UEFI spec as well as some comments in the EDK2 code base
+ * suggest that EFI_GUID should be 64-bit aligned, but this appears to be
+ * a mistake, given that no code seems to exist that actually enforces that
+ * or relies on it.
+ */
+typedef guid_t efi_guid_t __aligned(__alignof__(u32));
 
 #define EFI_GUID(a,b,c,d0,d1,d2,d3,d4,d5,d6,d7) \
 	GUID_INIT(a, b, c, d0, d1, d2, d3, d4, d5, d6, d7)

commit f218a29c25ad8abdb961435d6b8139f462061364
Merge: 8e143b90e4d4 c7f7e58fcbf3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 2 09:43:14 2019 -0800

    Merge branch 'next-integrity' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull integrity updates from James Morris:
     "In Linux 4.19, a new LSM hook named security_kernel_load_data was
      upstreamed, allowing LSMs and IMA to prevent the kexec_load syscall.
      Different signature verification methods exist for verifying the
      kexec'ed kernel image. This adds additional support in IMA to prevent
      loading unsigned kernel images via the kexec_load syscall,
      independently of the IMA policy rules, based on the runtime "secure
      boot" flag. An initial IMA kselftest is included.
    
      In addition, this pull request defines a new, separate keyring named
      ".platform" for storing the preboot/firmware keys needed for verifying
      the kexec'ed kernel image's signature and includes the associated IMA
      kexec usage of the ".platform" keyring.
    
      (David Howell's and Josh Boyer's patches for reading the
      preboot/firmware keys, which were previously posted for a different
      use case scenario, are included here)"
    
    * 'next-integrity' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security:
      integrity: Remove references to module keyring
      ima: Use inode_is_open_for_write
      ima: Support platform keyring for kernel appraisal
      efi: Allow the "db" UEFI variable to be suppressed
      efi: Import certificates from UEFI Secure Boot
      efi: Add an EFI signature blob parser
      efi: Add EFI signature data types
      integrity: Load certs to the platform keyring
      integrity: Define a trusted platform keyring
      selftests/ima: kexec_load syscall test
      ima: don't measure/appraise files on efivarfs
      x86/ima: retry detecting secure boot mode
      docs: Extend trusted keys documentation for TPM 2.0
      x86/ima: define arch_get_ima_policy() for x86
      ima: add support for arch specific policies
      ima: refactor ima_init_policy()
      ima: prevent kexec_load syscall based on runtime secureboot flag
      x86/ima: define arch_ima_get_secureboot
      integrity: support new struct public_key_signature encoding field

commit 5580b4a1a8ca85c53bd5b94c5d302e47dca3e5cb
Merge: 8bd8ea195f6d eed9de3b4f47
Author: James Morris <james.morris@microsoft.com>
Date:   Mon Dec 17 11:26:46 2018 -0800

    Merge branch 'next-integrity' of git://git.kernel.org/pub/scm/linux/kernel/git/zohar/linux-integrity into next-integrity
    
    From Mimi:
    
    In Linux 4.19, a new LSM hook named security_kernel_load_data was
    upstreamed, allowing LSMs and IMA to prevent the kexec_load
    syscall.  Different signature verification methods exist for verifying
    the kexec'ed kernel image.  This pull request adds additional support
    in IMA to prevent loading unsigned kernel images via the kexec_load
    syscall, independently of the IMA policy rules, based on the runtime
    "secure boot" flag.  An initial IMA kselftest is included.
    
    In addition, this pull request defines a new, separate keyring named
    ".platform" for storing the preboot/firmware keys needed for verifying
    the kexec'ed kernel image's signature and includes the associated IMA
    kexec usage of the ".platform" keyring.
    
    (David Howell's and Josh Boyer's patches for reading the
    preboot/firmware keys, which were previously posted for a different
    use case scenario, are included here.)

commit 0bc9ae395b3f3b6557f0c5f0a0b0cd2fd5c00a04
Author: Dave Howells <dhowells@redhat.com>
Date:   Sun Dec 9 01:57:02 2018 +0530

    efi: Add an EFI signature blob parser
    
    Add a function to parse an EFI signature blob looking for elements of
    interest. A list is made up of a series of sublists, where all the
    elements in a sublist are of the same type, but sublists can be of
    different types.
    
    For each sublist encountered, the function pointed to by the
    get_handler_for_guid argument is called with the type specifier GUID and
    returns either a pointer to a function to handle elements of that type or
    NULL if the type is not of interest.
    
    If the sublist is of interest, each element is passed to the handler
    function in turn.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Nayna Jain <nayna@linux.ibm.com>
    Acked-by: Serge Hallyn <serge@hallyn.com>
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 3d3de1673b15..d916311f2a51 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1141,6 +1141,15 @@ extern int efi_memattr_apply_permissions(struct mm_struct *mm,
 char * __init efi_md_typeattr_format(char *buf, size_t size,
 				     const efi_memory_desc_t *md);
 
+
+typedef void (*efi_element_handler_t)(const char *source,
+				      const void *element_data,
+				      size_t element_size);
+extern int __init parse_efi_signature_list(
+	const char *source,
+	const void *data, size_t size,
+	efi_element_handler_t (*get_handler_for_guid)(const efi_guid_t *));
+
 /**
  * efi_range_is_wc - check the WC bit on an address range
  * @start: starting kvirt address

commit 5c126ba22f894427cc770240faa1bf6b02ce7aca
Author: Dave Howells <dhowells@redhat.com>
Date:   Sun Dec 9 01:57:01 2018 +0530

    efi: Add EFI signature data types
    
    Add the data types that are used for containing hashes, keys and
    certificates for cryptographic verification along with their corresponding
    type GUIDs.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Nayna Jain <nayna@linux.ibm.com>
    Acked-by: Serge Hallyn <serge@hallyn.com>
    Reviewed-by: James Morris <james.morris@microsoft.com>
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 845174e113ce..3d3de1673b15 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -663,6 +663,10 @@ void efi_native_runtime_setup(void);
 #define EFI_IMAGE_SECURITY_DATABASE_GUID	EFI_GUID(0xd719b2cb, 0x3d3a, 0x4596,  0xa3, 0xbc, 0xda, 0xd0, 0x0e, 0x67, 0x65, 0x6f)
 #define EFI_SHIM_LOCK_GUID			EFI_GUID(0x605dab50, 0xe046, 0x4300,  0xab, 0xb6, 0x3d, 0xd8, 0x10, 0xdd, 0x8b, 0x23)
 
+#define EFI_CERT_SHA256_GUID			EFI_GUID(0xc1c41626, 0x504c, 0x4092, 0xac, 0xa9, 0x41, 0xf9, 0x36, 0x93, 0x43, 0x28)
+#define EFI_CERT_X509_GUID			EFI_GUID(0xa5c059a1, 0x94e4, 0x4aa7, 0x87, 0xb5, 0xab, 0x15, 0x5c, 0x2b, 0xf0, 0x72)
+#define EFI_CERT_X509_SHA256_GUID		EFI_GUID(0x3bd2a492, 0x96c0, 0x4079, 0xb4, 0x20, 0xfc, 0xf9, 0x8e, 0xf1, 0x03, 0xed)
+
 /*
  * This GUID is used to pass to the kernel proper the struct screen_info
  * structure that was populated by the stub based on the GOP protocol instance
@@ -934,6 +938,27 @@ typedef struct {
 	efi_memory_desc_t entry[0];
 } efi_memory_attributes_table_t;
 
+typedef struct {
+	efi_guid_t signature_owner;
+	u8 signature_data[];
+} efi_signature_data_t;
+
+typedef struct {
+	efi_guid_t signature_type;
+	u32 signature_list_size;
+	u32 signature_header_size;
+	u32 signature_size;
+	u8 signature_header[];
+	/* efi_signature_data_t signatures[][] */
+} efi_signature_list_t;
+
+typedef u8 efi_sha256_hash_t[32];
+
+typedef struct {
+	efi_sha256_hash_t to_be_signed_hash;
+	efi_time_t time_of_revocation;
+} efi_cert_x509_sha256_t;
+
 /*
  * All runtime access to EFI goes through this structure:
  */

commit 80424b02d42bb22f8ff8839cb93a84ade53b39c0
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Thu Nov 29 18:12:29 2018 +0100

    efi: Reduce the amount of memblock reservations for persistent allocations
    
    The current implementation of efi_mem_reserve_persistent() is rather
    naive, in the sense that for each invocation, it creates a separate
    linked list entry to describe the reservation. Since the linked list
    entries themselves need to persist across subsequent kexec reboots,
    every reservation created this way results in two memblock_reserve()
    calls at the next boot.
    
    On arm64 systems with 100s of CPUs, this may result in a excessive
    number of memblock reservations, and needless fragmentation.
    
    So instead, make use of the newly updated struct linux_efi_memreserve
    layout to put multiple reservations into a single linked list entry.
    This should get rid of the numerous tiny memblock reservations, and
    effectively cut the total number of reservations in half on arm64
    systems with many CPUs.
    
     [ mingo: build warning fix. ]
    
    Tested-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Arend van Spriel <arend.vanspriel@broadcom.com>
    Cc: Bhupesh Sharma <bhsharma@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dave Hansen <dave.hansen@intel.com>
    Cc: Eric Snowberg <eric.snowberg@oracle.com>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Jon Hunter <jonathanh@nvidia.com>
    Cc: Julien Thierry <julien.thierry@arm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Nathan Chancellor <natechancellor@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Cc: Sedat Dilek <sedat.dilek@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: YiFei Zhu <zhuyifei1999@gmail.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20181129171230.18699-11-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 4f27640fdcdc..becd5d76a207 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1724,4 +1724,7 @@ struct linux_efi_memreserve {
 #define EFI_MEMRESERVE_SIZE(count) (sizeof(struct linux_efi_memreserve) + \
 	(count) * sizeof(((struct linux_efi_memreserve *)0)->entry[0]))
 
+#define EFI_MEMRESERVE_COUNT(size) (((size) - sizeof(struct linux_efi_memreserve)) \
+	/ sizeof(((struct linux_efi_memreserve *)0)->entry[0]))
+
 #endif /* _LINUX_EFI_H */

commit 5f0b0ecf043a5319e729c11a53bc8294df12dab3
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Thu Nov 29 18:12:28 2018 +0100

    efi: Permit multiple entries in persistent memreserve data structure
    
    In preparation of updating efi_mem_reserve_persistent() to cause less
    fragmentation when dealing with many persistent reservations, update
    the struct definition and the code that handles it currently so it
    can describe an arbitrary number of reservations using a single linked
    list entry. The actual optimization will be implemented in a subsequent
    patch.
    
    Tested-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Arend van Spriel <arend.vanspriel@broadcom.com>
    Cc: Bhupesh Sharma <bhsharma@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dave Hansen <dave.hansen@intel.com>
    Cc: Eric Snowberg <eric.snowberg@oracle.com>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Jon Hunter <jonathanh@nvidia.com>
    Cc: Julien Thierry <julien.thierry@arm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Nathan Chancellor <natechancellor@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Cc: Sedat Dilek <sedat.dilek@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: YiFei Zhu <zhuyifei1999@gmail.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20181129171230.18699-10-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 2b3b33c83b05..4f27640fdcdc 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1712,9 +1712,16 @@ extern struct efi_runtime_work efi_rts_work;
 extern struct workqueue_struct *efi_rts_wq;
 
 struct linux_efi_memreserve {
-	phys_addr_t	next;
-	phys_addr_t	base;
-	phys_addr_t	size;
+	int		size;			// allocated size of the array
+	atomic_t	count;			// number of entries used
+	phys_addr_t	next;			// pa of next struct instance
+	struct {
+		phys_addr_t	base;
+		phys_addr_t	size;
+	} entry[0];
 };
 
+#define EFI_MEMRESERVE_SIZE(count) (sizeof(struct linux_efi_memreserve) + \
+	(count) * sizeof(((struct linux_efi_memreserve *)0)->entry[0]))
+
 #endif /* _LINUX_EFI_H */

commit 47c33a095e1fae376d74b4160a0d73c1a4e73969
Author: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
Date:   Thu Nov 29 18:12:25 2018 +0100

    x86/efi: Move efi_<reserve/free>_boot_services() to arch/x86
    
    efi_<reserve/free>_boot_services() are x86 specific quirks and as such
    should be in asm/efi.h, so move them from linux/efi.h. Also, call
    efi_free_boot_services() from __efi_enter_virtual_mode() as it is x86
    specific call and ideally shouldn't be part of init/main.c
    
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Arend van Spriel <arend.vanspriel@broadcom.com>
    Cc: Bhupesh Sharma <bhsharma@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dave Hansen <dave.hansen@intel.com>
    Cc: Eric Snowberg <eric.snowberg@oracle.com>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Jon Hunter <jonathanh@nvidia.com>
    Cc: Julien Thierry <julien.thierry@arm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Nathan Chancellor <natechancellor@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sedat Dilek <sedat.dilek@gmail.com>
    Cc: YiFei Zhu <zhuyifei1999@gmail.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20181129171230.18699-7-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 100ce4a4aff6..2b3b33c83b05 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1000,13 +1000,11 @@ extern void efi_memmap_walk (efi_freemem_callback_t callback, void *arg);
 extern void efi_gettimeofday (struct timespec64 *ts);
 extern void efi_enter_virtual_mode (void);	/* switch EFI to virtual mode, if possible */
 #ifdef CONFIG_X86
-extern void efi_free_boot_services(void);
 extern efi_status_t efi_query_variable_store(u32 attributes,
 					     unsigned long size,
 					     bool nonblocking);
 extern void efi_find_mirror(void);
 #else
-static inline void efi_free_boot_services(void) {}
 
 static inline efi_status_t efi_query_variable_store(u32 attributes,
 						    unsigned long size,
@@ -1046,7 +1044,6 @@ extern void efi_mem_reserve(phys_addr_t addr, u64 size);
 extern int efi_mem_reserve_persistent(phys_addr_t addr, u64 size);
 extern void efi_initialize_iomem_resources(struct resource *code_resource,
 		struct resource *data_resource, struct resource *bss_resource);
-extern void efi_reserve_boot_services(void);
 extern int efi_get_fdt_params(struct efi_fdt_params *params);
 extern struct kobject *efi_kobj;
 

commit eff896288872d687d9662000ec9ae11b6d61766f
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Nov 14 09:55:43 2018 -0800

    efi/arm: Defer persistent reservations until after paging_init()
    
    The new memory EFI reservation feature we introduced to allow memory
    reservations to persist across kexec may trigger an unbounded number
    of calls to memblock_reserve(). The memblock subsystem can deal with
    this fine, but not before memblock resizing is enabled, which we can
    only do after paging_init(), when the memory we reallocate the array
    into is actually mapped.
    
    So break out the memreserve table processing into a separate routine
    and call it after paging_init() on arm64. On ARM, because of limited
    reviewing bandwidth of the maintainer, we cannot currently fix this,
    so instead, disable the EFI persistent memreserve entirely on ARM so
    we can fix it later.
    
    Tested-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20181114175544.12860-5-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 845174e113ce..100ce4a4aff6 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1167,6 +1167,8 @@ static inline bool efi_enabled(int feature)
 extern void efi_reboot(enum reboot_mode reboot_mode, const char *__unused);
 
 extern bool efi_is_table_address(unsigned long phys_addr);
+
+extern int efi_apply_persistent_mem_reservations(void);
 #else
 static inline bool efi_enabled(int feature)
 {
@@ -1185,6 +1187,11 @@ static inline bool efi_is_table_address(unsigned long phys_addr)
 {
 	return false;
 }
+
+static inline int efi_apply_persistent_mem_reservations(void)
+{
+	return 0;
+}
 #endif
 
 extern int efi_status_to_err(efi_status_t status);

commit 3425d934fc0312f62024163736a7afe4de20c10f
Author: Sai Praneeth <sai.praneeth.prakhya@intel.com>
Date:   Tue Sep 11 12:15:22 2018 -0700

    efi/x86: Handle page faults occurring while running EFI runtime services
    
    Memory accesses performed by UEFI runtime services should be limited to:
    - reading/executing from EFI_RUNTIME_SERVICES_CODE memory regions
    - reading/writing from/to EFI_RUNTIME_SERVICES_DATA memory regions
    - reading/writing by-ref arguments
    - reading/writing from/to the stack.
    
    Accesses outside these regions may cause the kernel to hang because the
    memory region requested by the firmware isn't mapped in efi_pgd, which
    causes a page fault in ring 0 and the kernel fails to handle it, leading
    to die(). To save kernel from hanging, add an EFI specific page fault
    handler which recovers from such faults by
    1. If the efi runtime service is efi_reset_system(), reboot the machine
       through BIOS.
    2. If the efi runtime service is _not_ efi_reset_system(), then freeze
       efi_rts_wq and schedule a new process.
    
    The EFI page fault handler offers us two advantages:
    1. Avoid potential hangs caused by buggy firmware.
    2. Shout loud that the firmware is buggy and hence is not a kernel bug.
    
    Tested-by: Bhupesh Sharma <bhsharma@redhat.com>
    Suggested-by: Matt Fleming <matt@codeblueprint.co.uk>
    Based-on-code-from: Ricardo Neri <ricardo.neri@intel.com>
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    [ardb: clarify commit log]
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index a929d2bf41fa..845174e113ce 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1662,8 +1662,13 @@ struct linux_efi_tpm_eventlog {
 
 extern int efi_tpm_eventlog_init(void);
 
-/* efi_runtime_service() function identifiers */
+/*
+ * efi_runtime_service() function identifiers.
+ * "NONE" is used by efi_recover_from_page_fault() to check if the page
+ * fault happened while executing an efi runtime service.
+ */
 enum efi_rts_ids {
+	NONE,
 	GET_TIME,
 	SET_TIME,
 	GET_WAKEUP_TIME,
@@ -1673,6 +1678,7 @@ enum efi_rts_ids {
 	SET_VARIABLE,
 	QUERY_VARIABLE_INFO,
 	GET_NEXT_HIGH_MONO_COUNT,
+	RESET_SYSTEM,
 	UPDATE_CAPSULE,
 	QUERY_CAPSULE_CAPS,
 };

commit 9dbbedaa6171247c4c7c40b83f05b200a117c2e0
Author: Sai Praneeth <sai.praneeth.prakhya@intel.com>
Date:   Tue Sep 11 12:15:21 2018 -0700

    efi: Make efi_rts_work accessible to efi page fault handler
    
    After the kernel has booted, if any accesses by firmware causes a page
    fault, the efi page fault handler would freeze efi_rts_wq and schedules
    a new process. To do this, the efi page fault handler needs
    efi_rts_work. Hence, make it accessible.
    
    There will be no race conditions in accessing this structure, because
    all the calls to efi runtime services are already serialized.
    
    Tested-by: Bhupesh Sharma <bhsharma@redhat.com>
    Suggested-by: Matt Fleming <matt@codeblueprint.co.uk>
    Based-on-code-from: Ricardo Neri <ricardo.neri@intel.com>
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 22e4de9d3700..a929d2bf41fa 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1662,6 +1662,42 @@ struct linux_efi_tpm_eventlog {
 
 extern int efi_tpm_eventlog_init(void);
 
+/* efi_runtime_service() function identifiers */
+enum efi_rts_ids {
+	GET_TIME,
+	SET_TIME,
+	GET_WAKEUP_TIME,
+	SET_WAKEUP_TIME,
+	GET_VARIABLE,
+	GET_NEXT_VARIABLE,
+	SET_VARIABLE,
+	QUERY_VARIABLE_INFO,
+	GET_NEXT_HIGH_MONO_COUNT,
+	UPDATE_CAPSULE,
+	QUERY_CAPSULE_CAPS,
+};
+
+/*
+ * efi_runtime_work:	Details of EFI Runtime Service work
+ * @arg<1-5>:		EFI Runtime Service function arguments
+ * @status:		Status of executing EFI Runtime Service
+ * @efi_rts_id:		EFI Runtime Service function identifier
+ * @efi_rts_comp:	Struct used for handling completions
+ */
+struct efi_runtime_work {
+	void *arg1;
+	void *arg2;
+	void *arg3;
+	void *arg4;
+	void *arg5;
+	efi_status_t status;
+	struct work_struct work;
+	enum efi_rts_ids efi_rts_id;
+	struct completion efi_rts_comp;
+};
+
+extern struct efi_runtime_work efi_rts_work;
+
 /* Workqueue to queue EFI Runtime Services */
 extern struct workqueue_struct *efi_rts_wq;
 

commit a23d3bb05ccbd815c79293d2207fedede0b3515d
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Sep 21 09:32:46 2018 -0700

    efi: add API to reserve memory persistently across kexec reboot
    
    Add kernel plumbing to reserve memory regions persistently on a EFI
    system by adding entries to the MEMRESERVE linked list.
    
    Tested-by: Jeremy Linton <jeremy.linton@arm.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index a5cb580472c5..22e4de9d3700 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1043,6 +1043,7 @@ extern int __init efi_uart_console_only (void);
 extern u64 efi_mem_desc_end(efi_memory_desc_t *md);
 extern int efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md);
 extern void efi_mem_reserve(phys_addr_t addr, u64 size);
+extern int efi_mem_reserve_persistent(phys_addr_t addr, u64 size);
 extern void efi_initialize_iomem_resources(struct resource *code_resource,
 		struct resource *data_resource, struct resource *bss_resource);
 extern void efi_reserve_boot_services(void);

commit 71e0940d52e107748b270213a01d3b1546657d74
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Sep 21 09:32:44 2018 -0700

    efi: honour memory reservations passed via a linux specific config table
    
    In order to allow the OS to reserve memory persistently across a
    kexec, introduce a Linux-specific UEFI configuration table that
    points to the head of a linked list in memory, allowing each kernel
    to add list items describing memory regions that the next kernel
    should treat as reserved.
    
    This is useful, e.g., for GICv3 based ARM systems that cannot disable
    DMA access to the LPI tables, forcing them to reuse the same memory
    region again after a kexec reboot.
    
    Tested-by: Jeremy Linton <jeremy.linton@arm.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 401e4b254e30..a5cb580472c5 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -672,6 +672,7 @@ void efi_native_runtime_setup(void);
 #define LINUX_EFI_LOADER_ENTRY_GUID		EFI_GUID(0x4a67b082, 0x0a4c, 0x41cf,  0xb6, 0xc7, 0x44, 0x0b, 0x29, 0xbb, 0x8c, 0x4f)
 #define LINUX_EFI_RANDOM_SEED_TABLE_GUID	EFI_GUID(0x1ce1e5bc, 0x7ceb, 0x42f2,  0x81, 0xe5, 0x8a, 0xad, 0xf1, 0x80, 0xf5, 0x7b)
 #define LINUX_EFI_TPM_EVENT_LOG_GUID		EFI_GUID(0xb7799cb0, 0xeca2, 0x4943,  0x96, 0x67, 0x1f, 0xae, 0x07, 0xb7, 0x47, 0xfa)
+#define LINUX_EFI_MEMRESERVE_TABLE_GUID		EFI_GUID(0x888eb0c6, 0x8ede, 0x4ff5,  0xa8, 0xf0, 0x9a, 0xee, 0x5c, 0xb9, 0x77, 0xc2)
 
 typedef struct {
 	efi_guid_t guid;
@@ -957,6 +958,7 @@ extern struct efi {
 	unsigned long mem_attr_table;	/* memory attributes table */
 	unsigned long rng_seed;		/* UEFI firmware random seed */
 	unsigned long tpm_log;		/* TPM2 Event Log table */
+	unsigned long mem_reserve;	/* Linux EFI memreserve table */
 	efi_get_time_t *get_time;
 	efi_set_time_t *set_time;
 	efi_get_wakeup_time_t *get_wakeup_time;
@@ -1662,4 +1664,10 @@ extern int efi_tpm_eventlog_init(void);
 /* Workqueue to queue EFI Runtime Services */
 extern struct workqueue_struct *efi_rts_wq;
 
+struct linux_efi_memreserve {
+	phys_addr_t	next;
+	phys_addr_t	base;
+	phys_addr_t	size;
+};
+
 #endif /* _LINUX_EFI_H */

commit c4db9c1e8c70bc60e392da8a485bcfb035d559c2
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Jul 20 10:47:23 2018 +0900

    efi: Deduplicate efi_open_volume()
    
    There's one ARM, one x86_32 and one x86_64 version of efi_open_volume()
    which can be folded into a single shared version by masking their
    differences with the efi_call_proto() macro introduced by commit:
    
      3552fdf29f01 ("efi: Allow bitness-agnostic protocol calls").
    
    To be able to dereference the device_handle attribute from the
    efi_loaded_image_t table in an arch- and bitness-agnostic manner,
    introduce the efi_table_attr() macro (which already exists for x86)
    to arm and arm64.
    
    No functional change intended.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20180720014726.24031-7-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index e190652f5ef9..401e4b254e30 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -894,6 +894,16 @@ typedef struct _efi_file_handle {
 	void *flush;
 } efi_file_handle_t;
 
+typedef struct {
+	u64 revision;
+	u32 open_volume;
+} efi_file_io_interface_32_t;
+
+typedef struct {
+	u64 revision;
+	u64 open_volume;
+} efi_file_io_interface_64_t;
+
 typedef struct _efi_file_io_interface {
 	u64 revision;
 	int (*open_volume)(struct _efi_file_io_interface *,

commit f5dcc214aae29a68b37b2b4183f7171724e7b02d
Author: Sai Praneeth <sai.praneeth.prakhya@intel.com>
Date:   Wed Jul 11 11:40:37 2018 +0200

    efi: Remove the declaration of efi_late_init() as the function is unused
    
    The following commit:
    
      7b0a911478c74 ("efi/x86: Move the EFI BGRT init code to early init code")
    
    ... removed the implementation and all the references to
    efi_late_init() but the function is still declared at
    include/linux/efi.h.
    
    Hence, remove the unnecessary declaration.
    
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20180711094040.12506-6-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 8ba0cdd244b2..e190652f5ef9 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -988,14 +988,12 @@ extern void efi_memmap_walk (efi_freemem_callback_t callback, void *arg);
 extern void efi_gettimeofday (struct timespec64 *ts);
 extern void efi_enter_virtual_mode (void);	/* switch EFI to virtual mode, if possible */
 #ifdef CONFIG_X86
-extern void efi_late_init(void);
 extern void efi_free_boot_services(void);
 extern efi_status_t efi_query_variable_store(u32 attributes,
 					     unsigned long size,
 					     bool nonblocking);
 extern void efi_find_mirror(void);
 #else
-static inline void efi_late_init(void) {}
 static inline void efi_free_boot_services(void) {}
 
 static inline efi_status_t efi_query_variable_store(u32 attributes,

commit 3eb420e70d879ce0e6bf752accf5cdedb0a59de8
Author: Sai Praneeth <sai.praneeth.prakhya@intel.com>
Date:   Wed Jul 11 11:40:35 2018 +0200

    efi: Use a work queue to invoke EFI Runtime Services
    
    Presently, when a user process requests the kernel to execute any
    UEFI runtime service, the kernel temporarily switches to a separate
    set of page tables that describe the virtual mapping of the UEFI
    runtime services regions in memory. Since UEFI runtime services are
    typically invoked with interrupts enabled, any code that may be called
    during this time, will have an incorrect view of the process's address
    space. Although it is unusual for code running in interrupt context to
    make assumptions about the process context it runs in, there are cases
    (such as the perf subsystem taking samples) where this causes problems.
    
    So let's set up a work queue for calling UEFI runtime services, so that
    the actual calls are made when the work queue items are dispatched by a
    work queue worker running in a separate kernel thread. Such threads are
    not expected to have userland mappings in the first place, and so the
    additional mappings created for the UEFI runtime services can never
    clash with any.
    
    The ResetSystem() runtime service is not covered by the work queue
    handling, since it is not expected to return, and may be called at a
    time when the kernel is torn down to the point where we cannot expect
    work queues to still be operational.
    
    The non-blocking variants of SetVariable() and QueryVariableInfo()
    are also excluded: these are intended to be used from atomic context,
    which obviously rules out waiting for a completion to be signalled by
    another thread. Note that these variants are currently only used for
    UEFI runtime services calls that occur very early in the boot, and
    for ones that occur in critical conditions, e.g., to flush kernel logs
    to UEFI variables via efi-pstore.
    
    Suggested-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    [ardb: exclude ResetSystem() from the workqueue treatment
           merge from 2 separate patches and rewrite commit log]
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20180711094040.12506-4-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 56add823f190..8ba0cdd244b2 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1651,4 +1651,7 @@ struct linux_efi_tpm_eventlog {
 
 extern int efi_tpm_eventlog_init(void);
 
+/* Workqueue to queue EFI Runtime Services */
+extern struct workqueue_struct *efi_rts_wq;
+
 #endif /* _LINUX_EFI_H */

commit cb0ba793525788e40e7a9ee82de8f3b017ca4459
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri May 4 07:59:59 2018 +0200

    efi: Align efi_pci_io_protocol typedefs to type naming convention
    
    In order to use the helper macros that perform type mangling with the
    EFI PCI I/O protocol struct typedefs, align their Linux typenames with
    the convention we use for definitionns that originate in the UEFI spec,
    and add the trailing _t to each.
    
    Tested-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20180504060003.19618-14-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 3016d8c456bc..56add823f190 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -397,7 +397,7 @@ typedef struct {
 	u32 set_bar_attributes;
 	u64 romsize;
 	u32 romimage;
-} efi_pci_io_protocol_32;
+} efi_pci_io_protocol_32_t;
 
 typedef struct {
 	u64 poll_mem;
@@ -417,7 +417,7 @@ typedef struct {
 	u64 set_bar_attributes;
 	u64 romsize;
 	u64 romimage;
-} efi_pci_io_protocol_64;
+} efi_pci_io_protocol_64_t;
 
 typedef struct {
 	void *poll_mem;
@@ -437,7 +437,7 @@ typedef struct {
 	void *set_bar_attributes;
 	uint64_t romsize;
 	void *romimage;
-} efi_pci_io_protocol;
+} efi_pci_io_protocol_t;
 
 #define EFI_PCI_IO_ATTRIBUTE_ISA_MOTHERBOARD_IO 0x0001
 #define EFI_PCI_IO_ATTRIBUTE_ISA_IO 0x0002

commit 0b3225ab9407f557a8e20f23f37aa7236c10a9b1
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri May 4 07:59:58 2018 +0200

    efi: Avoid potential crashes, fix the 'struct efi_pci_io_protocol_32' definition for mixed mode
    
    Mixed mode allows a kernel built for x86_64 to interact with 32-bit
    EFI firmware, but requires us to define all struct definitions carefully
    when it comes to pointer sizes.
    
    'struct efi_pci_io_protocol_32' currently uses a 'void *' for the
    'romimage' field, which will be interpreted as a 64-bit field
    on such kernels, potentially resulting in bogus memory references
    and subsequent crashes.
    
    Tested-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: <stable@vger.kernel.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20180504060003.19618-13-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index f1b7d68ac460..3016d8c456bc 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -395,8 +395,8 @@ typedef struct {
 	u32 attributes;
 	u32 get_bar_attributes;
 	u32 set_bar_attributes;
-	uint64_t romsize;
-	void *romimage;
+	u64 romsize;
+	u32 romimage;
 } efi_pci_io_protocol_32;
 
 typedef struct {
@@ -415,8 +415,8 @@ typedef struct {
 	u64 attributes;
 	u64 get_bar_attributes;
 	u64 set_bar_attributes;
-	uint64_t romsize;
-	void *romimage;
+	u64 romsize;
+	u64 romimage;
 } efi_pci_io_protocol_64;
 
 typedef struct {

commit 7e904a91bf6049071ef9d605a52f863ae774081d
Author: Sai Praneeth <sai.praneeth.prakhya@intel.com>
Date:   Mon Mar 12 08:44:56 2018 +0000

    efi: Use efi_mm in x86 as well as ARM
    
    Presently, only ARM uses mm_struct to manage EFI page tables and EFI
    runtime region mappings. As this is the preferred approach, let's make
    this data structure common across architectures. Specially, for x86,
    using this data structure improves code maintainability and readability.
    
    Tested-by: Bhupesh Sharma <bhsharma@redhat.com>
    [ardb: don't #include the world to get a declaration of struct mm_struct]
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Lee, Chun-Yi <jlee@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Michael S. Tsirkin <mst@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ravi Shankar <ravi.v.shankar@intel.com>
    Cc: Ricardo Neri <ricardo.neri@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20180312084500.10764-2-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index f5083aa72eae..f1b7d68ac460 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -966,6 +966,8 @@ extern struct efi {
 	unsigned long flags;
 } efi;
 
+extern struct mm_struct efi_mm;
+
 static inline int
 efi_guidcmp (efi_guid_t left, efi_guid_t right)
 {

commit ae0cb7be35fe6c7e8bcc816ec4185d0a37748cc1
Merge: 2a7149031457 ebceb1c87c0c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 31 13:12:31 2018 -0800

    Merge branch 'next-tpm' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull tpm updates from James Morris:
    
     - reduce polling delays in tpm_tis
    
     - support retrieving TPM 2.0 Event Log through EFI before
       ExitBootServices
    
     - replace tpm-rng.c with a hwrng device managed by the driver for each
       TPM device
    
     - TPM resource manager synthesizes TPM_RC_COMMAND_CODE response instead
       of returning -EINVAL for unknown TPM commands. This makes user space
       more sound.
    
     - CLKRUN fixes:
    
        * Keep #CLKRUN disable through the entier TPM command/response flow
    
        * Check whether #CLKRUN is enabled before disabling and enabling it
          again because enabling it breaks PS/2 devices on a system where it
          is disabled
    
    * 'next-tpm' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security:
      tpm: remove unused variables
      tpm: remove unused data fields from I2C and OF device ID tables
      tpm: only attempt to disable the LPC CLKRUN if is already enabled
      tpm: follow coding style for variable declaration in tpm_tis_core_init()
      tpm: delete the TPM_TIS_CLK_ENABLE flag
      tpm: Update MAINTAINERS for Jason Gunthorpe
      tpm: Keep CLKRUN enabled throughout the duration of transmit_cmd()
      tpm_tis: Move ilb_base_addr to tpm_tis_data
      tpm2-cmd: allow more attempts for selftest execution
      tpm: return a TPM_RC_COMMAND_CODE response if command is not implemented
      tpm: Move Linux RNG connection to hwrng
      tpm: use struct tpm_chip for tpm_chip_find_get()
      tpm: parse TPM event logs based on EFI table
      efi: call get_event_log before ExitBootServices
      tpm: add event log format version
      tpm: rename event log provider files
      tpm: move tpm_eventlog.h outside of drivers folder
      tpm: use tpm_msleep() value as max delay
      tpm: reduce tpm polling delay in tpm_tis_core
      tpm: move wait_for_tpm_stat() to respective driver files

commit 33b6d03469b2206fb51ecc37f40411a857ad8fff
Author: Thiebaud Weksteen <tweek@google.com>
Date:   Wed Sep 20 10:13:39 2017 +0200

    efi: call get_event_log before ExitBootServices
    
    With TPM 2.0 specification, the event logs may only be accessible by
    calling an EFI Boot Service. Modify the EFI stub to copy the log area to
    a new Linux-specific EFI configuration table so it remains accessible
    once booted.
    
    When calling this service, it is possible to specify the expected format
    of the logs: TPM 1.2 (SHA1) or TPM 2.0 ("Crypto Agile"). For now, only the
    first format is retrieved.
    
    Signed-off-by: Thiebaud Weksteen <tweek@google.com>
    Reviewed-by: Javier Martinez Canillas <javierm@redhat.com>
    Tested-by: Javier Martinez Canillas <javierm@redhat.com>
    Tested-by: Jarkko Sakkinen  <jarkko.sakkinen@linux.intel.com>
    Reviewed-by: Jarkko Sakkinen  <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen  <jarkko.sakkinen@linux.intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index d813f7b04da7..dcea82dc4b89 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -473,6 +473,39 @@ typedef struct {
 	u64 get_all;
 } apple_properties_protocol_64_t;
 
+typedef struct {
+	u32 get_capability;
+	u32 get_event_log;
+	u32 hash_log_extend_event;
+	u32 submit_command;
+	u32 get_active_pcr_banks;
+	u32 set_active_pcr_banks;
+	u32 get_result_of_set_active_pcr_banks;
+} efi_tcg2_protocol_32_t;
+
+typedef struct {
+	u64 get_capability;
+	u64 get_event_log;
+	u64 hash_log_extend_event;
+	u64 submit_command;
+	u64 get_active_pcr_banks;
+	u64 set_active_pcr_banks;
+	u64 get_result_of_set_active_pcr_banks;
+} efi_tcg2_protocol_64_t;
+
+typedef u32 efi_tcg2_event_log_format;
+
+typedef struct {
+	void *get_capability;
+	efi_status_t (*get_event_log)(efi_handle_t, efi_tcg2_event_log_format,
+		efi_physical_addr_t *, efi_physical_addr_t *, efi_bool_t *);
+	void *hash_log_extend_event;
+	void *submit_command;
+	void *get_active_pcr_banks;
+	void *set_active_pcr_banks;
+	void *get_result_of_set_active_pcr_banks;
+} efi_tcg2_protocol_t;
+
 /*
  * Types and defines for EFI ResetSystem
  */
@@ -623,6 +656,7 @@ void efi_native_runtime_setup(void);
 #define EFI_MEMORY_ATTRIBUTES_TABLE_GUID	EFI_GUID(0xdcfa911d, 0x26eb, 0x469f,  0xa2, 0x20, 0x38, 0xb7, 0xdc, 0x46, 0x12, 0x20)
 #define EFI_CONSOLE_OUT_DEVICE_GUID		EFI_GUID(0xd3b36f2c, 0xd551, 0x11d4,  0x9a, 0x46, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
 #define APPLE_PROPERTIES_PROTOCOL_GUID		EFI_GUID(0x91bd12fe, 0xf6c3, 0x44fb,  0xa5, 0xb7, 0x51, 0x22, 0xab, 0x30, 0x3a, 0xe0)
+#define EFI_TCG2_PROTOCOL_GUID			EFI_GUID(0x607f766c, 0x7455, 0x42be,  0x93, 0x0b, 0xe4, 0xd7, 0x6d, 0xb2, 0x72, 0x0f)
 
 #define EFI_IMAGE_SECURITY_DATABASE_GUID	EFI_GUID(0xd719b2cb, 0x3d3a, 0x4596,  0xa3, 0xbc, 0xda, 0xd0, 0x0e, 0x67, 0x65, 0x6f)
 #define EFI_SHIM_LOCK_GUID			EFI_GUID(0x605dab50, 0xe046, 0x4300,  0xab, 0xb6, 0x3d, 0xd8, 0x10, 0xdd, 0x8b, 0x23)
@@ -635,6 +669,7 @@ void efi_native_runtime_setup(void);
 #define LINUX_EFI_ARM_SCREEN_INFO_TABLE_GUID	EFI_GUID(0xe03fc20a, 0x85dc, 0x406e,  0xb9, 0x0e, 0x4a, 0xb5, 0x02, 0x37, 0x1d, 0x95)
 #define LINUX_EFI_LOADER_ENTRY_GUID		EFI_GUID(0x4a67b082, 0x0a4c, 0x41cf,  0xb6, 0xc7, 0x44, 0x0b, 0x29, 0xbb, 0x8c, 0x4f)
 #define LINUX_EFI_RANDOM_SEED_TABLE_GUID	EFI_GUID(0x1ce1e5bc, 0x7ceb, 0x42f2,  0x81, 0xe5, 0x8a, 0xad, 0xf1, 0x80, 0xf5, 0x7b)
+#define LINUX_EFI_TPM_EVENT_LOG_GUID		EFI_GUID(0xb7799cb0, 0xeca2, 0x4943,  0x96, 0x67, 0x1f, 0xae, 0x07, 0xb7, 0x47, 0xfa)
 
 typedef struct {
 	efi_guid_t guid;
@@ -909,6 +944,7 @@ extern struct efi {
 	unsigned long properties_table;	/* properties table */
 	unsigned long mem_attr_table;	/* memory attributes table */
 	unsigned long rng_seed;		/* UEFI firmware random seed */
+	unsigned long tpm_log;		/* TPM2 Event Log table */
 	efi_get_time_t *get_time;
 	efi_set_time_t *set_time;
 	efi_get_wakeup_time_t *get_wakeup_time;
@@ -1534,6 +1570,8 @@ static inline void
 efi_enable_reset_attack_mitigation(efi_system_table_t *sys_table_arg) { }
 #endif
 
+void efi_retrieve_tpm2_eventlog(efi_system_table_t *sys_table);
+
 /*
  * Arch code can implement the following three template macros, avoiding
  * reptition for the void/non-void return cases of {__,}efi_call_virt():
@@ -1601,4 +1639,12 @@ struct linux_efi_random_seed {
 	u8	bits[];
 };
 
+struct linux_efi_tpm_eventlog {
+	u32	size;
+	u8	version;
+	u8	log[];
+};
+
+extern int efi_tpm_eventlog_init(void);
+
 #endif /* _LINUX_EFI_H */

commit f24c4d478013d82bd1b943df566fff3561d52864
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Jan 2 17:21:10 2018 +0000

    efi/capsule-loader: Reinstate virtual capsule mapping
    
    Commit:
    
      82c3768b8d68 ("efi/capsule-loader: Use a cached copy of the capsule header")
    
    ... refactored the capsule loading code that maps the capsule header,
    to avoid having to map it several times.
    
    However, as it turns out, the vmap() call we ended up removing did not
    just map the header, but the entire capsule image, and dropping this
    virtual mapping breaks capsules that are processed by the firmware
    immediately (i.e., without a reboot).
    
    Unfortunately, that change was part of a larger refactor that allowed
    a quirk to be implemented for Quark, which has a non-standard memory
    layout for capsules, and we have slightly painted ourselves into a
    corner by allowing quirk code to mangle the capsule header and memory
    layout.
    
    So we need to fix this without breaking Quark. Fortunately, Quark does
    not appear to care about the virtual mapping, and so we can simply
    do a partial revert of commit:
    
      2a457fb31df6 ("efi/capsule-loader: Use page addresses rather than struct page pointers")
    
    ... and create a vmap() mapping of the entire capsule (including header)
    based on the reinstated struct page array, unless running on Quark, in
    which case we pass the capsule header copy as before.
    
    Reported-by: Ge Song <ge.song@hxt-semitech.com>
    Tested-by: Bryan O'Donoghue <pure.logic@nexus-software.ie>
    Tested-by: Ge Song <ge.song@hxt-semitech.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: <stable@vger.kernel.org>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Fixes: 82c3768b8d68 ("efi/capsule-loader: Use a cached copy of the capsule header")
    Link: http://lkml.kernel.org/r/20180102172110.17018-3-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index d813f7b04da7..29fdf8029cf6 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -140,11 +140,13 @@ struct efi_boot_memmap {
 
 struct capsule_info {
 	efi_capsule_header_t	header;
+	efi_capsule_header_t	*capsule;
 	int			reset_type;
 	long			index;
 	size_t			count;
 	size_t			total_size;
-	phys_addr_t		*pages;
+	struct page		**pages;
+	phys_addr_t		*phys;
 	size_t			page_bytes_remain;
 };
 

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 66f4a4e79f4b..d813f7b04da7 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _LINUX_EFI_H
 #define _LINUX_EFI_H
 

commit ae71948f398eb2572148006bf34f0c6d934206cb
Merge: 7f85565a3f71 c0020756315e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 12 13:27:21 2017 -0700

    Merge tag 'uuid-for-4.14' of git://git.infradead.org/users/hch/uuid
    
    Pull uuid updates from Christoph Hellwig:
     "Just a single conversion to the new UUID API for this merge window"
    
    * tag 'uuid-for-4.14' of git://git.infradead.org/users/hch/uuid:
      efi: switch to use new generic UUID API

commit f92e3da18b7d5941468040af962c201235148301
Merge: 57e88b43b813 6de47a5e371f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 7 09:42:35 2017 -0700

    Merge branch 'efi-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull EFI updates from Ingo Molnar:
     "The main changes in this cycle were:
    
       - Transparently fall back to other poweroff method(s) if EFI poweroff
         fails (and returns)
    
       - Use separate PE/COFF section headers for the RX and RW parts of the
         ARM stub loader so that the firmware can use strict mapping
         permissions
    
       - Add support for requesting the firmware to wipe RAM at warm reboot
    
       - Increase the size of the random seed obtained from UEFI so CRNG
         fast init can complete earlier
    
       - Update the EFI framebuffer address if it points to a BAR that gets
         moved by the PCI resource allocation code
    
       - Enable "reset attack mitigation" of TPM environments: this is
         enabled if the kernel is configured with
         CONFIG_RESET_ATTACK_MITIGATION=y.
    
       - Clang related fixes
    
       - Misc cleanups, constification, refactoring, etc"
    
    * 'efi-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      efi/bgrt: Use efi_mem_type()
      efi: Move efi_mem_type() to common code
      efi/reboot: Make function pointer orig_pm_power_off static
      efi/random: Increase size of firmware supplied randomness
      efi/libstub: Enable reset attack mitigation
      firmware/efi/esrt: Constify attribute_group structures
      firmware/efi: Constify attribute_group structures
      firmware/dcdbas: Constify attribute_group structures
      arm/efi: Split zImage code and data into separate PE/COFF sections
      arm/efi: Replace open coded constants with symbolic ones
      arm/efi: Remove pointless dummy .reloc section
      arm/efi: Remove forbidden values from the PE/COFF header
      drivers/fbdev/efifb: Allow BAR to be moved instead of claiming it
      efi/reboot: Fall back to original power-off method if EFI_RESET_SHUTDOWN returns
      efi/arm/arm64: Add missing assignment of efi.config_table
      efi/libstub/arm64: Set -fpie when building the EFI stub
      efi/libstub/arm64: Force 'hidden' visibility for section markers
      efi/libstub/arm64: Use hidden attribute for struct screen_info reference
      efi/arm: Don't mark ACPI reclaim memory as MEMBLOCK_NOMAP

commit b1b6f83ac938d176742c85757960dec2cf10e468
Merge: 5f82e71a001d 9e52fc2b50de
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Sep 4 12:21:28 2017 -0700

    Merge branch 'x86-mm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 mm changes from Ingo Molnar:
     "PCID support, 5-level paging support, Secure Memory Encryption support
    
      The main changes in this cycle are support for three new, complex
      hardware features of x86 CPUs:
    
       - Add 5-level paging support, which is a new hardware feature on
         upcoming Intel CPUs allowing up to 128 PB of virtual address space
         and 4 PB of physical RAM space - a 512-fold increase over the old
         limits. (Supercomputers of the future forecasting hurricanes on an
         ever warming planet can certainly make good use of more RAM.)
    
         Many of the necessary changes went upstream in previous cycles,
         v4.14 is the first kernel that can enable 5-level paging.
    
         This feature is activated via CONFIG_X86_5LEVEL=y - disabled by
         default.
    
         (By Kirill A. Shutemov)
    
       - Add 'encrypted memory' support, which is a new hardware feature on
         upcoming AMD CPUs ('Secure Memory Encryption', SME) allowing system
         RAM to be encrypted and decrypted (mostly) transparently by the
         CPU, with a little help from the kernel to transition to/from
         encrypted RAM. Such RAM should be more secure against various
         attacks like RAM access via the memory bus and should make the
         radio signature of memory bus traffic harder to intercept (and
         decrypt) as well.
    
         This feature is activated via CONFIG_AMD_MEM_ENCRYPT=y - disabled
         by default.
    
         (By Tom Lendacky)
    
       - Enable PCID optimized TLB flushing on newer Intel CPUs: PCID is a
         hardware feature that attaches an address space tag to TLB entries
         and thus allows to skip TLB flushing in many cases, even if we
         switch mm's.
    
         (By Andy Lutomirski)
    
      All three of these features were in the works for a long time, and
      it's coincidence of the three independent development paths that they
      are all enabled in v4.14 at once"
    
    * 'x86-mm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (65 commits)
      x86/mm: Enable RCU based page table freeing (CONFIG_HAVE_RCU_TABLE_FREE=y)
      x86/mm: Use pr_cont() in dump_pagetable()
      x86/mm: Fix SME encryption stack ptr handling
      kvm/x86: Avoid clearing the C-bit in rsvd_bits()
      x86/CPU: Align CR3 defines
      x86/mm, mm/hwpoison: Clear PRESENT bit for kernel 1:1 mappings of poison pages
      acpi, x86/mm: Remove encryption mask from ACPI page protection type
      x86/mm, kexec: Fix memory corruption with SME on successive kexecs
      x86/mm/pkeys: Fix typo in Documentation/x86/protection-keys.txt
      x86/mm/dump_pagetables: Speed up page tables dump for CONFIG_KASAN=y
      x86/mm: Implement PCID based optimization: try to preserve old TLB entries using PCID
      x86: Enable 5-level paging support via CONFIG_X86_5LEVEL=y
      x86/mm: Allow userspace have mappings above 47-bit
      x86/mm: Prepare to expose larger address space to userspace
      x86/mpx: Do not allow MPX if we have mappings above 47-bit
      x86/mm: Rename tasksize_32bit/64bit to task_size_32bit/64bit()
      x86/xen: Redefine XEN_ELFNOTE_INIT_P2M using PUD_SIZE * PTRS_PER_PUD
      x86/mm/dump_pagetables: Fix printout of p4d level
      x86/mm/dump_pagetables: Generalize address normalization
      x86/boot: Fix memremap() related build failure
      ...

commit c0020756315eebec58310aca42cf9fb73e1322eb
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Jul 19 21:28:52 2017 +0300

    efi: switch to use new generic UUID API
    
    There are new types and helpers that are supposed to be used in new code.
    
    As a preparation to get rid of legacy types and API functions do
    the conversion here.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 8269bcb8ccf7..7a322aed979f 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -47,10 +47,10 @@ typedef u16 efi_char16_t;		/* UNICODE character */
 typedef u64 efi_physical_addr_t;
 typedef void *efi_handle_t;
 
-typedef uuid_le efi_guid_t;
+typedef guid_t efi_guid_t;
 
 #define EFI_GUID(a,b,c,d0,d1,d2,d3,d4,d5,d6,d7) \
-	UUID_LE(a, b, c, d0, d1, d2, d3, d4, d5, d6, d7)
+	GUID_INIT(a, b, c, d0, d1, d2, d3, d4, d5, d6, d7)
 
 /*
  * Generic EFI table header

commit c2ceb5fd4e921506e86208b82fca716a2c3aad59
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Aug 25 16:50:16 2017 +0100

    efi/random: Increase size of firmware supplied randomness
    
    The crng code requires at least 64 bytes (2 * CHACHA20_BLOCK_SIZE)
    to complete the fast boot-time init, so provide that many bytes
    when invoking UEFI protocols to seed the entropy pool. Also, add
    a notice so we can tell from the boot log when the seeding actually
    took place.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20170825155019.6740-3-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index c241acca0b15..33d41df062bc 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1571,6 +1571,8 @@ efi_status_t efi_exit_boot_services(efi_system_table_t *sys_table,
 				    void *priv,
 				    efi_exit_boot_map_processing priv_func);
 
+#define EFI_RANDOM_SEED_SIZE		64U
+
 struct linux_efi_random_seed {
 	u32	size;
 	u8	bits[];

commit ccc829ba3624beb9a703fc995d016b836d9eead8
Author: Matthew Garrett <mjg59@google.com>
Date:   Fri Aug 25 16:50:15 2017 +0100

    efi/libstub: Enable reset attack mitigation
    
    If a machine is reset while secrets are present in RAM, it may be
    possible for code executed after the reboot to extract those secrets
    from untouched memory. The Trusted Computing Group specified a mechanism
    for requesting that the firmware clear all RAM on reset before booting
    another OS. This is done by setting the MemoryOverwriteRequestControl
    variable at startup. If userspace can ensure that all secrets are
    removed as part of a controlled shutdown, it can reset this variable to
    0 before triggering a hardware reboot.
    
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20170825155019.6740-2-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 4e47f78430be..c241acca0b15 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1504,6 +1504,13 @@ enum efi_secureboot_mode {
 };
 enum efi_secureboot_mode efi_get_secureboot(efi_system_table_t *sys_table);
 
+#ifdef CONFIG_RESET_ATTACK_MITIGATION
+void efi_enable_reset_attack_mitigation(efi_system_table_t *sys_table_arg);
+#else
+static inline void
+efi_enable_reset_attack_mitigation(efi_system_table_t *sys_table_arg) { }
+#endif
+
 /*
  * Arch code can implement the following three template macros, avoiding
  * reptition for the void/non-void return cases of {__,}efi_call_virt():

commit 02e43c2dcd3b3cf7244f6dda65a07e8dacadaf8d
Author: Baoquan He <bhe@redhat.com>
Date:   Wed Aug 16 21:46:51 2017 +0800

    efi: Introduce efi_early_memdesc_ptr to get pointer to memmap descriptor
    
    The existing map iteration helper for_each_efi_memory_desc_in_map can
    only be used after the kernel initializes the EFI subsystem to set up
    struct efi_memory_map.
    
    Before that we also need iterate map descriptors which are stored in several
    intermediate structures, like struct efi_boot_memmap for arch independent
    usage and struct efi_info for x86 arch only.
    
    Introduce efi_early_memdesc_ptr() to get pointer to a map descriptor, and
    replace several places where that primitive is open coded.
    
    Signed-off-by: Baoquan He <bhe@redhat.com>
    [ Various improvements to the text. ]
    Acked-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: ard.biesheuvel@linaro.org
    Cc: fanc.fnst@cn.fujitsu.com
    Cc: izumi.taku@jp.fujitsu.com
    Cc: keescook@chromium.org
    Cc: linux-efi@vger.kernel.org
    Cc: n-horiguchi@ah.jp.nec.com
    Cc: thgarnie@google.com
    Link: http://lkml.kernel.org/r/20170816134651.GF21273@x1
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 8269bcb8ccf7..a686ca9a7e5c 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1020,6 +1020,28 @@ extern int efi_memattr_init(void);
 extern int efi_memattr_apply_permissions(struct mm_struct *mm,
 					 efi_memattr_perm_setter fn);
 
+/*
+ * efi_early_memdesc_ptr - get the n-th EFI memmap descriptor
+ * @map: the start of efi memmap
+ * @desc_size: the size of space for each EFI memmap descriptor
+ * @n: the index of efi memmap descriptor
+ *
+ * EFI boot service provides the GetMemoryMap() function to get a copy of the
+ * current memory map which is an array of memory descriptors, each of
+ * which describes a contiguous block of memory. It also gets the size of the
+ * map, and the size of each descriptor, etc.
+ *
+ * Note that per section 6.2 of UEFI Spec 2.6 Errata A, the returned size of
+ * each descriptor might not be equal to sizeof(efi_memory_memdesc_t),
+ * since efi_memory_memdesc_t may be extended in the future. Thus the OS
+ * MUST use the returned size of the descriptor to find the start of each
+ * efi_memory_memdesc_t in the memory map array. This should only be used
+ * during bootup since for_each_efi_memory_desc_xxx() is available after the
+ * kernel initializes the EFI subsystem to set up struct efi_memory_map.
+ */
+#define efi_early_memdesc_ptr(map, desc_size, n)			\
+	(efi_memory_desc_t *)((void *)(map) + ((n) * (desc_size)))
+
 /* Iterate through an efi_memory_map */
 #define for_each_efi_memory_desc_in_map(m, md)				   \
 	for ((md) = (m)->map;						   \

commit f99afd08a45fbbd9ce35a7624ffd1d850a1906c0
Author: Tom Lendacky <thomas.lendacky@amd.com>
Date:   Mon Jul 17 16:10:14 2017 -0500

    efi: Update efi_mem_type() to return an error rather than 0
    
    The efi_mem_type() function currently returns a 0, which maps to
    EFI_RESERVED_TYPE, if the function is unable to find a memmap entry for
    the supplied physical address. Returning EFI_RESERVED_TYPE implies that
    a memmap entry exists, when it doesn't.  Instead of returning 0, change
    the function to return a negative error value when no memmap entry is
    found.
    
    Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brijesh Singh <brijesh.singh@amd.com>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Larry Woodman <lwoodman@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Michael S. Tsirkin <mst@redhat.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Radim Krčmář <rkrcmar@redhat.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Toshimitsu Kani <toshi.kani@hpe.com>
    Cc: kasan-dev@googlegroups.com
    Cc: kvm@vger.kernel.org
    Cc: linux-arch@vger.kernel.org
    Cc: linux-doc@vger.kernel.org
    Cc: linux-efi@vger.kernel.org
    Cc: linux-mm@kvack.org
    Link: http://lkml.kernel.org/r/7fbf40a9dc414d5da849e1ddcd7f7c1285e4e181.1500319216.git.thomas.lendacky@amd.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 8e24f099bd3f..4e47f78430be 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -985,7 +985,7 @@ static inline void efi_esrt_init(void) { }
 extern int efi_config_parse_tables(void *config_tables, int count, int sz,
 				   efi_config_table_type_t *arch_tables);
 extern u64 efi_get_iobase (void);
-extern u32 efi_mem_type (unsigned long phys_addr);
+extern int efi_mem_type(unsigned long phys_addr);
 extern u64 efi_mem_attributes (unsigned long phys_addr);
 extern u64 efi_mem_attribute (unsigned long phys_addr, unsigned long size);
 extern int __init efi_uart_console_only (void);

commit a19d66c56af1c52b8b463bf94d21116ae8c1aa5a
Author: Tom Lendacky <thomas.lendacky@amd.com>
Date:   Mon Jul 17 16:10:13 2017 -0500

    efi: Add an EFI table address match function
    
    Add a function that will determine if a supplied physical address matches
    the address of an EFI table.
    
    Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brijesh Singh <brijesh.singh@amd.com>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Larry Woodman <lwoodman@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Michael S. Tsirkin <mst@redhat.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Radim Krčmář <rkrcmar@redhat.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Toshimitsu Kani <toshi.kani@hpe.com>
    Cc: kasan-dev@googlegroups.com
    Cc: kvm@vger.kernel.org
    Cc: linux-arch@vger.kernel.org
    Cc: linux-doc@vger.kernel.org
    Cc: linux-efi@vger.kernel.org
    Cc: linux-mm@kvack.org
    Link: http://lkml.kernel.org/r/e1e06441d80f44776df391e0e4cb485b345b7518.1500319216.git.thomas.lendacky@amd.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 8269bcb8ccf7..8e24f099bd3f 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1091,6 +1091,8 @@ static inline bool efi_enabled(int feature)
 	return test_bit(feature, &efi.flags) != 0;
 }
 extern void efi_reboot(enum reboot_mode reboot_mode, const char *__unused);
+
+extern bool efi_is_table_address(unsigned long phys_addr);
 #else
 static inline bool efi_enabled(int feature)
 {
@@ -1104,6 +1106,11 @@ efi_capsule_pending(int *reset_type)
 {
 	return false;
 }
+
+static inline bool efi_is_table_address(unsigned long phys_addr)
+{
+	return false;
+}
 #endif
 
 extern int efi_status_to_err(efi_status_t status);

commit 2a457fb31df62c6b482f78e4f74aaed99271f44d
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Jun 2 13:52:03 2017 +0000

    efi/capsule-loader: Use page addresses rather than struct page pointers
    
    To give some leeway to code that handles non-standard capsule headers,
    let's keep an array of page addresses rather than struct page pointers.
    
    This gives special implementations of efi_capsule_setup_info() the
    opportunity to mangle the payload a bit before it is presented to the
    firmware, without putting any knowledge of the nature of such quirks
    into the generic code.
    
    Tested-by: Bryan O'Donoghue <pure.logic@nexus-software.ie>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20170602135207.21708-10-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index a7379a2b5680..8269bcb8ccf7 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -143,7 +143,7 @@ struct capsule_info {
 	long			index;
 	size_t			count;
 	size_t			total_size;
-	struct page		**pages;
+	phys_addr_t		*pages;
 	size_t			page_bytes_remain;
 };
 
@@ -1415,7 +1415,7 @@ extern int efi_capsule_supported(efi_guid_t guid, u32 flags,
 				 size_t size, int *reset);
 
 extern int efi_capsule_update(efi_capsule_header_t *capsule,
-			      struct page **pages);
+			      phys_addr_t *pages);
 
 #ifdef CONFIG_EFI_RUNTIME_MAP
 int efi_runtime_map_init(struct kobject *);

commit 3fabd628d5ea24b02ddb1230ffca1df0f779f84e
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Jun 2 13:52:02 2017 +0000

    efi/capsule-loader: Redirect calls to efi_capsule_setup_info() via weak alias
    
    To allow platform specific code to hook into the capsule loading
    routines, indirect calls to efi_capsule_setup_info() via a weak alias
    of __efi_capsule_setup_info(), allowing platforms to redefine the former
    but still use the latter.
    
    Tested-by: Bryan O'Donoghue <pure.logic@nexus-software.ie>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20170602135207.21708-9-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index ec36f42a2add..a7379a2b5680 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -137,6 +137,18 @@ struct efi_boot_memmap {
 #define EFI_CAPSULE_POPULATE_SYSTEM_TABLE	0x00020000
 #define EFI_CAPSULE_INITIATE_RESET		0x00040000
 
+struct capsule_info {
+	efi_capsule_header_t	header;
+	int			reset_type;
+	long			index;
+	size_t			count;
+	size_t			total_size;
+	struct page		**pages;
+	size_t			page_bytes_remain;
+};
+
+int __efi_capsule_setup_info(struct capsule_info *cap_info);
+
 /*
  * Allocation types for calls to boottime->allocate_pages.
  */

commit eeff7d634f4750306785be709ca444140c29b043
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Apr 4 17:09:09 2017 +0100

    efi/libstub/arm/arm64: Disable debug prints on 'quiet' cmdline arg
    
    The EFI stub currently prints a number of diagnostic messages that do
    not carry a lot of information. Since these prints are not controlled
    by 'loglevel' or other command line parameters, and since they appear on
    the EFI framebuffer as well (if enabled), it would be nice if we could
    turn them off.
    
    So let's add support for the 'quiet' command line parameter in the stub,
    and disable the non-error prints if it is passed.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: bhe@redhat.com
    Cc: bhsharma@redhat.com
    Cc: bp@alien8.de
    Cc: eugene@hp.com
    Cc: evgeny.kalugin@intel.com
    Cc: jhugo@codeaurora.org
    Cc: leif.lindholm@linaro.org
    Cc: linux-efi@vger.kernel.org
    Cc: roy.franz@cavium.com
    Cc: rruigrok@codeaurora.org
    Link: http://lkml.kernel.org/r/20170404160910.28115-2-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index e485e87615d1..ec36f42a2add 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1435,9 +1435,6 @@ static inline int efi_runtime_map_copy(void *buf, size_t bufsz)
 
 /* prototypes shared between arch specific and generic stub code */
 
-#define pr_efi(sys_table, msg)     efi_printk(sys_table, "EFI stub: "msg)
-#define pr_efi_err(sys_table, msg) efi_printk(sys_table, "EFI stub: ERROR: "msg)
-
 void efi_printk(efi_system_table_t *sys_table_arg, char *str);
 
 void efi_free(efi_system_table_t *sys_table_arg, unsigned long size,

commit 60f38de7a8d4e816100ceafd1b382df52527bd50
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Apr 4 17:09:08 2017 +0100

    efi/libstub: Unify command line param parsing
    
    Merge the parsing of the command line carried out in arm-stub.c with
    the handling in efi_parse_options(). Note that this also fixes the
    missing handling of CONFIG_CMDLINE_FORCE=y, in which case the builtin
    command line should supersede the one passed by the firmware.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: bhe@redhat.com
    Cc: bhsharma@redhat.com
    Cc: bp@alien8.de
    Cc: eugene@hp.com
    Cc: evgeny.kalugin@intel.com
    Cc: jhugo@codeaurora.org
    Cc: leif.lindholm@linaro.org
    Cc: linux-efi@vger.kernel.org
    Cc: mark.rutland@arm.com
    Cc: roy.franz@cavium.com
    Cc: rruigrok@codeaurora.org
    Link: http://lkml.kernel.org/r/20170404160910.28115-1-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 94d34e0be24f..e485e87615d1 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1471,7 +1471,7 @@ efi_status_t handle_cmdline_files(efi_system_table_t *sys_table_arg,
 				  unsigned long *load_addr,
 				  unsigned long *load_size);
 
-efi_status_t efi_parse_options(char *cmdline);
+efi_status_t efi_parse_options(char const *cmdline);
 
 efi_status_t efi_setup_gop(efi_system_table_t *sys_table_arg,
 			   struct screen_info *si, efi_guid_t *proto,

commit de8cb458625c164bb3f93c4e415e479afce8fa9d
Author: David Howells <dhowells@redhat.com>
Date:   Mon Feb 6 11:22:43 2017 +0000

    efi: Get and store the secure boot status
    
    Get the firmware's secure-boot status in the kernel boot wrapper and stash
    it somewhere that the main kernel image can find.
    
    The efi_get_secureboot() function is extracted from the ARM stub and (a)
    generalised so that it can be called from x86 and (b) made to use
    efi_call_runtime() so that it can be run in mixed-mode.
    
    For x86, it is stored in boot_params and can be overridden by the boot
    loader or kexec.  This allows secure-boot mode to be passed on to a new
    kernel.
    
    Suggested-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1486380166-31868-5-git-send-email-ard.biesheuvel@linaro.org
    [ Small readability edits. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index d00538a65899..94d34e0be24f 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1480,6 +1480,14 @@ efi_status_t efi_setup_gop(efi_system_table_t *sys_table_arg,
 bool efi_runtime_disabled(void);
 extern void efi_call_virt_check_flags(unsigned long flags, const char *call);
 
+enum efi_secureboot_mode {
+	efi_secureboot_mode_unset,
+	efi_secureboot_mode_unknown,
+	efi_secureboot_mode_disabled,
+	efi_secureboot_mode_enabled,
+};
+enum efi_secureboot_mode efi_get_secureboot(efi_system_table_t *sys_table);
+
 /*
  * Arch code can implement the following three template macros, avoiding
  * reptition for the void/non-void return cases of {__,}efi_call_virt():

commit e58910cdc9f43cda2e52fcdf2fddbdc74e80b2f7
Author: Josh Boyer <jwboyer@fedoraproject.org>
Date:   Mon Feb 6 11:22:42 2017 +0000

    efi: Add SHIM and image security database GUID definitions
    
    Add the definitions for shim and image security database, both of which
    are used widely in various Linux distros.
    
    Signed-off-by: Josh Boyer <jwboyer@fedoraproject.org>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1486380166-31868-4-git-send-email-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 85e9fdaa8d07..d00538a65899 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -611,6 +611,9 @@ void efi_native_runtime_setup(void);
 #define EFI_CONSOLE_OUT_DEVICE_GUID		EFI_GUID(0xd3b36f2c, 0xd551, 0x11d4,  0x9a, 0x46, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
 #define APPLE_PROPERTIES_PROTOCOL_GUID		EFI_GUID(0x91bd12fe, 0xf6c3, 0x44fb,  0xa5, 0xb7, 0x51, 0x22, 0xab, 0x30, 0x3a, 0xe0)
 
+#define EFI_IMAGE_SECURITY_DATABASE_GUID	EFI_GUID(0xd719b2cb, 0x3d3a, 0x4596,  0xa3, 0xbc, 0xda, 0xd0, 0x0e, 0x67, 0x65, 0x6f)
+#define EFI_SHIM_LOCK_GUID			EFI_GUID(0x605dab50, 0xe046, 0x4300,  0xab, 0xb6, 0x3d, 0xd8, 0x10, 0xdd, 0x8b, 0x23)
+
 /*
  * This GUID is used to pass to the kernel proper the struct screen_info
  * structure that was populated by the stub based on the GOP protocol instance

commit c4c39c70c5fef43655019236bec8ba5e7273b868
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Jan 31 13:21:39 2017 +0000

    efi: Use typed function pointers for the runtime services table
    
    Instead of using void pointers, and casting them to correctly typed
    function pointers upon use, declare the runtime services pointers
    as function pointers using their respective prototypes, for which
    typedefs are already available.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1485868902-20401-8-git-send-email-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 5f632bf9969d..85e9fdaa8d07 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -509,24 +509,6 @@ typedef struct {
 	u64 query_variable_info;
 } efi_runtime_services_64_t;
 
-typedef struct {
-	efi_table_hdr_t hdr;
-	void *get_time;
-	void *set_time;
-	void *get_wakeup_time;
-	void *set_wakeup_time;
-	void *set_virtual_address_map;
-	void *convert_pointer;
-	void *get_variable;
-	void *get_next_variable;
-	void *set_variable;
-	void *get_next_high_mono_count;
-	void *reset_system;
-	void *update_capsule;
-	void *query_capsule_caps;
-	void *query_variable_info;
-} efi_runtime_services_t;
-
 typedef efi_status_t efi_get_time_t (efi_time_t *tm, efi_time_cap_t *tc);
 typedef efi_status_t efi_set_time_t (efi_time_t *tm);
 typedef efi_status_t efi_get_wakeup_time_t (efi_bool_t *enabled, efi_bool_t *pending,
@@ -561,6 +543,24 @@ typedef efi_status_t efi_query_variable_store_t(u32 attributes,
 						unsigned long size,
 						bool nonblocking);
 
+typedef struct {
+	efi_table_hdr_t			hdr;
+	efi_get_time_t			*get_time;
+	efi_set_time_t			*set_time;
+	efi_get_wakeup_time_t		*get_wakeup_time;
+	efi_set_wakeup_time_t		*set_wakeup_time;
+	efi_set_virtual_address_map_t	*set_virtual_address_map;
+	void				*convert_pointer;
+	efi_get_variable_t		*get_variable;
+	efi_get_next_variable_t		*get_next_variable;
+	efi_set_variable_t		*set_variable;
+	efi_get_next_high_mono_count_t	*get_next_high_mono_count;
+	efi_reset_system_t		*reset_system;
+	efi_update_capsule_t		*update_capsule;
+	efi_query_capsule_caps_t	*query_capsule_caps;
+	efi_query_variable_info_t	*query_variable_info;
+} efi_runtime_services_t;
+
 void efi_native_runtime_setup(void);
 
 /*

commit a19ebf59e20880c87dd49b6336476307559ac5ba
Author: Sai Praneeth <sai.praneeth.prakhya@intel.com>
Date:   Tue Jan 31 13:21:36 2017 +0000

    efi: Introduce the EFI_MEM_ATTR bit and set it from the memory attributes table
    
    UEFI v2.6 introduces a configuration table called
    EFI_MEMORY_ATTRIBUTES_TABLE which provides additional information about
    EFI runtime regions. Currently this table describes memory protections
    that may be applied to the EFI Runtime code and data regions by the kernel.
    
    Allocate a EFI_XXX bit to keep track of whether this feature is
    published by firmware or not.
    
    Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Lee, Chun-Yi <jlee@suse.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ravi Shankar <ravi.v.shankar@intel.com>
    Cc: Ricardo Neri <ricardo.neri@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1485868902-20401-5-git-send-email-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 6642c4d9d11d..5f632bf9969d 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1065,6 +1065,7 @@ extern int __init efi_setup_pcdp_console(char *);
 #define EFI_ARCH_1		7	/* First arch-specific bit */
 #define EFI_DBG			8	/* Print additional debug info at runtime */
 #define EFI_NX_PE_DATA		9	/* Can runtime data regions be mapped non-executable? */
+#define EFI_MEM_ATTR		10	/* Did firmware publish an EFI_MEMORY_ATTRIBUTES table? */
 
 #ifdef CONFIG_EFI
 /*

commit db4545d9a7881db0a7e18599e6cd1adbcb93db33
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Jan 31 13:21:34 2017 +0000

    x86/efi: Deduplicate efi_char16_printk()
    
    Eliminate the separate 32-bit and 64x- bit code paths by way of the shiny
    new efi_call_proto() macro.
    
    No functional change intended.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1485868902-20401-3-git-send-email-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 5b1af30ece55..6642c4d9d11d 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1240,17 +1240,17 @@ struct efivar_entry {
 	bool deleting;
 };
 
-struct efi_simple_text_output_protocol_32 {
+typedef struct {
 	u32 reset;
 	u32 output_string;
 	u32 test_string;
-};
+} efi_simple_text_output_protocol_32_t;
 
-struct efi_simple_text_output_protocol_64 {
+typedef struct {
 	u64 reset;
 	u64 output_string;
 	u64 test_string;
-};
+} efi_simple_text_output_protocol_64_t;
 
 struct efi_simple_text_output_protocol {
 	void *reset;

commit 0100a3e67a9cef64d72cd3a1da86f3ddbee50363
Author: Peter Jones <pjones@redhat.com>
Date:   Mon Dec 12 18:42:28 2016 -0500

    efi/x86: Prune invalid memory map entries and fix boot regression
    
    Some machines, such as the Lenovo ThinkPad W541 with firmware GNET80WW
    (2.28), include memory map entries with phys_addr=0x0 and num_pages=0.
    
    These machines fail to boot after the following commit,
    
      commit 8e80632fb23f ("efi/esrt: Use efi_mem_reserve() and avoid a kmalloc()")
    
    Fix this by removing such bogus entries from the memory map.
    
    Furthermore, currently the log output for this case (with efi=debug)
    looks like:
    
     [    0.000000] efi: mem45: [Reserved           |   |  |  |  |  |  |  |  |  |  |  |  ] range=[0x0000000000000000-0xffffffffffffffff] (0MB)
    
    This is clearly wrong, and also not as informative as it could be.  This
    patch changes it so that if we find obviously invalid memory map
    entries, we print an error and skip those entries.  It also detects the
    display of the address range calculation overflow, so the new output is:
    
     [    0.000000] efi: [Firmware Bug]: Invalid EFI memory map entries:
     [    0.000000] efi: mem45: [Reserved           |   |  |  |  |  |  |  |   |  |  |  |  ] range=[0x0000000000000000-0x0000000000000000] (invalid)
    
    It also detects memory map sizes that would overflow the physical
    address, for example phys_addr=0xfffffffffffff000 and
    num_pages=0x0200000000000001, and prints:
    
     [    0.000000] efi: [Firmware Bug]: Invalid EFI memory map entries:
     [    0.000000] efi: mem45: [Reserved           |   |  |  |  |  |  |  |   |  |  |  |  ] range=[phys_addr=0xfffffffffffff000-0x20ffffffffffffffff] (invalid)
    
    It then removes these entries from the memory map.
    
    Signed-off-by: Peter Jones <pjones@redhat.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    [ardb: refactor for clarity with no functional changes, avoid PAGE_SHIFT]
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    [Matt: Include bugzilla info in commit log]
    Cc: <stable@vger.kernel.org> # v4.9+
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=191121
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 0c5420208c40..5b1af30ece55 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -103,6 +103,7 @@ typedef	struct {
 
 #define EFI_PAGE_SHIFT		12
 #define EFI_PAGE_SIZE		(1UL << EFI_PAGE_SHIFT)
+#define EFI_PAGES_MAX		(U64_MAX >> EFI_PAGE_SHIFT)
 
 typedef struct {
 	u32 type;

commit 20b1e22d01a4b0b11d3a1066e9feb04be38607ec
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Thu Jan 5 13:51:29 2017 +0100

    x86/efi: Don't allocate memmap through memblock after mm_init()
    
    With the following commit:
    
      4bc9f92e64c8 ("x86/efi-bgrt: Use efi_mem_reserve() to avoid copying image data")
    
    ...  efi_bgrt_init() calls into the memblock allocator through
    efi_mem_reserve() => efi_arch_mem_reserve() *after* mm_init() has been called.
    
    Indeed, KASAN reports a bad read access later on in efi_free_boot_services():
    
      BUG: KASAN: use-after-free in efi_free_boot_services+0xae/0x24c
                at addr ffff88022de12740
      Read of size 4 by task swapper/0/0
      page:ffffea0008b78480 count:0 mapcount:-127
      mapping:          (null) index:0x1 flags: 0x5fff8000000000()
      [...]
      Call Trace:
       dump_stack+0x68/0x9f
       kasan_report_error+0x4c8/0x500
       kasan_report+0x58/0x60
       __asan_load4+0x61/0x80
       efi_free_boot_services+0xae/0x24c
       start_kernel+0x527/0x562
       x86_64_start_reservations+0x24/0x26
       x86_64_start_kernel+0x157/0x17a
       start_cpu+0x5/0x14
    
    The instruction at the given address is the first read from the memmap's
    memory, i.e. the read of md->type in efi_free_boot_services().
    
    Note that the writes earlier in efi_arch_mem_reserve() don't splat because
    they're done through early_memremap()ed addresses.
    
    So, after memblock is gone, allocations should be done through the "normal"
    page allocator. Introduce a helper, efi_memmap_alloc() for this. Use
    it from efi_arch_mem_reserve(), efi_free_boot_services() and, for the sake
    of consistency, from efi_fake_memmap() as well.
    
    Note that for the latter, the memmap allocations cease to be page aligned.
    This isn't needed though.
    
    Tested-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: <stable@vger.kernel.org> # v4.9
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Mika Penttilä <mika.penttila@nextfour.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Fixes: 4bc9f92e64c8 ("x86/efi-bgrt: Use efi_mem_reserve() to avoid copying image data")
    Link: http://lkml.kernel.org/r/20170105125130.2815-1-nicstange@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index a07a476178cd..0c5420208c40 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -950,6 +950,7 @@ static inline efi_status_t efi_query_variable_store(u32 attributes,
 #endif
 extern void __iomem *efi_lookup_mapped_addr(u64 phys_addr);
 
+extern phys_addr_t __init efi_memmap_alloc(unsigned int num_entries);
 extern int __init efi_memmap_init_early(struct efi_memory_map_data *data);
 extern int __init efi_memmap_init_late(phys_addr_t addr, unsigned long size);
 extern void __init efi_memmap_unmap(void);

commit 58c5475aba67706b31d9237808d5d3d54074e5ea
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Nov 12 21:32:36 2016 +0000

    x86/efi: Retrieve and assign Apple device properties
    
    Apple's EFI drivers supply device properties which are needed to support
    Macs optimally. They contain vital information which cannot be obtained
    any other way (e.g. Thunderbolt Device ROM). They're also used to convey
    the current device state so that OS drivers can pick up where EFI
    drivers left (e.g. GPU mode setting).
    
    There's an EFI driver dubbed "AAPL,PathProperties" which implements a
    per-device key/value store. Other EFI drivers populate it using a custom
    protocol. The macOS bootloader /System/Library/CoreServices/boot.efi
    retrieves the properties with the same protocol. The kernel extension
    AppleACPIPlatform.kext subsequently merges them into the I/O Kit
    registry (see ioreg(8)) where they can be queried by other kernel
    extensions and user space.
    
    This commit extends the efistub to retrieve the device properties before
    ExitBootServices is called. It assigns them to devices in an fs_initcall
    so that they can be queried with the API in <linux/property.h>.
    
    Note that the device properties will only be available if the kernel is
    booted with the efistub. Distros should adjust their installers to
    always use the efistub on Macs. grub with the "linux" directive will not
    work unless the functionality of this commit is duplicated in grub.
    (The "linuxefi" directive should work but is not included upstream as of
    this writing.)
    
    The custom protocol has GUID 91BD12FE-F6C3-44FB-A5B7-5122AB303AE0 and
    looks like this:
    
    typedef struct {
            unsigned long version; /* 0x10000 */
            efi_status_t (*get) (
                    IN      struct apple_properties_protocol *this,
                    IN      struct efi_dev_path *device,
                    IN      efi_char16_t *property_name,
                    OUT     void *buffer,
                    IN OUT  u32 *buffer_len);
                    /* EFI_SUCCESS, EFI_NOT_FOUND, EFI_BUFFER_TOO_SMALL */
            efi_status_t (*set) (
                    IN      struct apple_properties_protocol *this,
                    IN      struct efi_dev_path *device,
                    IN      efi_char16_t *property_name,
                    IN      void *property_value,
                    IN      u32 property_value_len);
                    /* allocates copies of property name and value */
                    /* EFI_SUCCESS, EFI_OUT_OF_RESOURCES */
            efi_status_t (*del) (
                    IN      struct apple_properties_protocol *this,
                    IN      struct efi_dev_path *device,
                    IN      efi_char16_t *property_name);
                    /* EFI_SUCCESS, EFI_NOT_FOUND */
            efi_status_t (*get_all) (
                    IN      struct apple_properties_protocol *this,
                    OUT     void *buffer,
                    IN OUT  u32 *buffer_len);
                    /* EFI_SUCCESS, EFI_BUFFER_TOO_SMALL */
    } apple_properties_protocol;
    
    Thanks to Pedro Vilaça for this blog post which was helpful in reverse
    engineering Apple's EFI drivers and bootloader:
    https://reverse.put.as/2016/06/25/apple-efi-firmware-passwords-and-the-scbo-myth/
    
    If someone at Apple is reading this, please note there's a memory leak
    in your implementation of the del() function as the property struct is
    freed but the name and value allocations are not.
    
    Neither the macOS bootloader nor Apple's EFI drivers check the protocol
    version, but we do to avoid breakage if it's ever changed. It's been the
    same since at least OS X 10.6 (2009).
    
    The get_all() function conveniently fills a buffer with all properties
    in marshalled form which can be passed to the kernel as a setup_data
    payload. The number of device properties is dynamic and can change
    between a first invocation of get_all() (to determine the buffer size)
    and a second invocation (to retrieve the actual buffer), hence the
    peculiar loop which does not finish until the buffer size settles.
    The macOS bootloader does the same.
    
    The setup_data payload is later on unmarshalled in an fs_initcall. The
    idea is that most buses instantiate devices in "subsys" initcall level
    and drivers are usually bound to these devices in "device" initcall
    level, so we assign the properties in-between, i.e. in "fs" initcall
    level.
    
    This assumes that devices to which properties pertain are instantiated
    from a "subsys" initcall or earlier. That should always be the case
    since on macOS, AppleACPIPlatformExpert::matchEFIDevicePath() only
    supports ACPI and PCI nodes and we've fully scanned those buses during
    "subsys" initcall level.
    
    The second assumption is that properties are only needed from a "device"
    initcall or later. Seems reasonable to me, but should this ever not work
    out, an alternative approach would be to store the property sets e.g. in
    a btree early during boot. Then whenever device_add() is called, an EFI
    Device Path would have to be constructed for the newly added device,
    and looked up in the btree. That way, the property set could be assigned
    to the device immediately on instantiation. And this would also work for
    devices instantiated in a deferred fashion. It seems like this approach
    would be more complicated and require more code. That doesn't seem
    justified without a specific use case.
    
    For comparison, the strategy on macOS is to assign properties to objects
    in the ACPI namespace (AppleACPIPlatformExpert::mergeEFIProperties()).
    That approach is definitely wrong as it fails for devices not present in
    the namespace: The NHI EFI driver supplies properties for attached
    Thunderbolt devices, yet on Macs with Thunderbolt 1 only one device
    level behind the host controller is described in the namespace.
    Consequently macOS cannot assign properties for chained devices. With
    Thunderbolt 2 they started to describe three device levels behind host
    controllers in the namespace but this grossly inflates the SSDT and
    still fails if the user daisy-chained more than three devices.
    
    We copy the property names and values from the setup_data payload to
    swappable virtual memory and afterwards make the payload available to
    the page allocator. This is just for the sake of good housekeeping, it
    wouldn't occupy a meaningful amount of physical memory (4444 bytes on my
    machine). Only the payload is freed, not the setup_data header since
    otherwise we'd break the list linkage and we cannot safely update the
    predecessor's ->next link because there's no locking for the list.
    
    The payload is currently not passed on to kexec'ed kernels, same for PCI
    ROMs retrieved by setup_efi_pci(). This can be added later if there is
    demand by amending setup_efi_state(). The payload can then no longer be
    made available to the page allocator of course.
    
    Tested-by: Lukas Wunner <lukas@wunner.de> [MacBookPro9,1]
    Tested-by: Pierre Moreau <pierre.morrow@free.fr> [MacBookPro11,3]
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Andreas Noever <andreas.noever@gmail.com>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Pedro Vilaça <reverser@put.as>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: grub-devel@gnu.org
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20161112213237.8804-9-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 261767212c47..a07a476178cd 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -443,6 +443,22 @@ typedef struct {
 #define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO_16 0x20000
 #define EFI_PCI_IO_ATTRIBUTE_VGA_IO_16 0x40000
 
+typedef struct {
+	u32 version;
+	u32 get;
+	u32 set;
+	u32 del;
+	u32 get_all;
+} apple_properties_protocol_32_t;
+
+typedef struct {
+	u64 version;
+	u64 get;
+	u64 set;
+	u64 del;
+	u64 get_all;
+} apple_properties_protocol_64_t;
+
 /*
  * Types and defines for EFI ResetSystem
  */
@@ -592,6 +608,7 @@ void efi_native_runtime_setup(void);
 #define EFI_RNG_ALGORITHM_RAW			EFI_GUID(0xe43176d7, 0xb6e8, 0x4827,  0xb7, 0x84, 0x7f, 0xfd, 0xc4, 0xb6, 0x85, 0x61)
 #define EFI_MEMORY_ATTRIBUTES_TABLE_GUID	EFI_GUID(0xdcfa911d, 0x26eb, 0x469f,  0xa2, 0x20, 0x38, 0xb7, 0xdc, 0x46, 0x12, 0x20)
 #define EFI_CONSOLE_OUT_DEVICE_GUID		EFI_GUID(0xd3b36f2c, 0xd551, 0x11d4,  0x9a, 0x46, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
+#define APPLE_PROPERTIES_PROTOCOL_GUID		EFI_GUID(0x91bd12fe, 0xf6c3, 0x44fb,  0xa5, 0xb7, 0x51, 0x22, 0xab, 0x30, 0x3a, 0xe0)
 
 /*
  * This GUID is used to pass to the kernel proper the struct screen_info

commit 46cd4b75cd0edee76e0096225c2d31f8d90e92a2
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Nov 12 21:32:34 2016 +0000

    efi: Add device path parser
    
    We're about to extended the efistub to retrieve device properties from
    EFI on Apple Macs. The properties use EFI Device Paths to indicate the
    device they belong to. This commit adds a parser which, given an EFI
    Device Path, locates the corresponding struct device and returns a
    reference to it.
    
    Initially only ACPI and PCI Device Path nodes are supported, these are
    the only types needed for Apple device properties (the corresponding
    macOS function AppleACPIPlatformExpert::matchEFIDevicePath() does not
    support any others). Further node types can be added with little to
    moderate effort.
    
    Apple device properties is currently the only use case of this parser,
    but Peter Jones intends to use it to match up devices with the
    ConInDev/ConOutDev/ErrOutDev variables and add sysfs attributes to these
    devices to say the hardware supports using them as console. Thus,
    make this parser a separate component which can be selected with config
    option EFI_DEV_PATH_PARSER. It can in principle be compiled as a module
    if acpi_get_first_physical_node() and acpi_bus_type are exported (and
    efi_get_device_by_path() itself is exported).
    
    The dependency on CONFIG_ACPI is needed for acpi_match_device_ids().
    It can be removed if an empty inline stub is added for that function.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Andreas Noever <andreas.noever@gmail.com>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20161112213237.8804-7-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index f5a821d9b90c..261767212c47 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1148,6 +1148,26 @@ struct efi_generic_dev_path {
 	u16 length;
 } __attribute ((packed));
 
+struct efi_dev_path {
+	u8 type;	/* can be replaced with unnamed */
+	u8 sub_type;	/* struct efi_generic_dev_path; */
+	u16 length;	/* once we've moved to -std=c11 */
+	union {
+		struct {
+			u32 hid;
+			u32 uid;
+		} acpi;
+		struct {
+			u8 fn;
+			u8 dev;
+		} pci;
+	};
+} __attribute ((packed));
+
+#if IS_ENABLED(CONFIG_EFI_DEV_PATH_PARSER)
+struct device *efi_get_device_by_path(struct efi_dev_path **node, size_t *len);
+#endif
+
 static inline void memrange_efi_to_native(u64 *addr, u64 *npages)
 {
 	*npages = PFN_UP(*addr + (*npages<<EFI_PAGE_SHIFT)) - PFN_DOWN(*addr);

commit 568bc4e87033d232c5fd00d5b0cd22a2ccc04944
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Sat Nov 12 21:32:33 2016 +0000

    efi/arm*/libstub: Invoke EFI_RNG_PROTOCOL to seed the UEFI RNG table
    
    Invoke the EFI_RNG_PROTOCOL protocol in the context of the stub and
    install the Linux-specific RNG seed UEFI config table. This will be
    picked up by the EFI routines in the core kernel to seed the kernel
    entropy pool.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20161112213237.8804-6-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 85e28b138cdd..f5a821d9b90c 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -589,6 +589,7 @@ void efi_native_runtime_setup(void);
 #define DEVICE_TREE_GUID			EFI_GUID(0xb1b621d5, 0xf19c, 0x41a5,  0x83, 0x0b, 0xd9, 0x15, 0x2c, 0x69, 0xaa, 0xe0)
 #define EFI_PROPERTIES_TABLE_GUID		EFI_GUID(0x880aaca3, 0x4adc, 0x4a04,  0x90, 0x79, 0xb7, 0x47, 0x34, 0x08, 0x25, 0xe5)
 #define EFI_RNG_PROTOCOL_GUID			EFI_GUID(0x3152bca5, 0xeade, 0x433d,  0x86, 0x2e, 0xc0, 0x1c, 0xdc, 0x29, 0x1f, 0x44)
+#define EFI_RNG_ALGORITHM_RAW			EFI_GUID(0xe43176d7, 0xb6e8, 0x4827,  0xb7, 0x84, 0x7f, 0xfd, 0xc4, 0xb6, 0x85, 0x61)
 #define EFI_MEMORY_ATTRIBUTES_TABLE_GUID	EFI_GUID(0xdcfa911d, 0x26eb, 0x469f,  0xa2, 0x20, 0x38, 0xb7, 0xdc, 0x46, 0x12, 0x20)
 #define EFI_CONSOLE_OUT_DEVICE_GUID		EFI_GUID(0xd3b36f2c, 0xd551, 0x11d4,  0x9a, 0x46, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
 

commit 636259880a7e7d3446a707dddebc799da94bdd0b
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Sat Nov 12 21:32:31 2016 +0000

    efi: Add support for seeding the RNG from a UEFI config table
    
    Specify a Linux specific UEFI configuration table that carries some
    random bits, and use the contents during early boot to seed the kernel's
    random number generator. This allows much strong random numbers to be
    generated early on.
    
    The entropy is fed to the kernel using add_device_randomness(), which is
    documented as being appropriate for being called very early.
    
    Since UEFI configuration tables may also be consumed by kexec'd kernels,
    register a reboot notifier that updates the seed in the table.
    
    Note that the config table could be generated by the EFI stub or by any
    other UEFI driver or application (e.g., GRUB), but the random seed table
    GUID and the associated functionality should be considered an internal
    kernel interface (unless it is promoted to ABI later on)
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20161112213237.8804-4-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 2d089487d2da..85e28b138cdd 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -599,6 +599,7 @@ void efi_native_runtime_setup(void);
  */
 #define LINUX_EFI_ARM_SCREEN_INFO_TABLE_GUID	EFI_GUID(0xe03fc20a, 0x85dc, 0x406e,  0xb9, 0x0e, 0x4a, 0xb5, 0x02, 0x37, 0x1d, 0x95)
 #define LINUX_EFI_LOADER_ENTRY_GUID		EFI_GUID(0x4a67b082, 0x0a4c, 0x41cf,  0xb6, 0xc7, 0x44, 0x0b, 0x29, 0xbb, 0x8c, 0x4f)
+#define LINUX_EFI_RANDOM_SEED_TABLE_GUID	EFI_GUID(0x1ce1e5bc, 0x7ceb, 0x42f2,  0x81, 0xe5, 0x8a, 0xad, 0xf1, 0x80, 0xf5, 0x7b)
 
 typedef struct {
 	efi_guid_t guid;
@@ -872,6 +873,7 @@ extern struct efi {
 	unsigned long esrt;		/* ESRT table */
 	unsigned long properties_table;	/* properties table */
 	unsigned long mem_attr_table;	/* memory attributes table */
+	unsigned long rng_seed;		/* UEFI firmware random seed */
 	efi_get_time_t *get_time;
 	efi_set_time_t *set_time;
 	efi_get_wakeup_time_t *get_wakeup_time;
@@ -1493,4 +1495,10 @@ efi_status_t efi_exit_boot_services(efi_system_table_t *sys_table,
 				    struct efi_boot_memmap *map,
 				    void *priv,
 				    efi_exit_boot_map_processing priv_func);
+
+struct linux_efi_random_seed {
+	u32	size;
+	u8	bits[];
+};
+
 #endif /* _LINUX_EFI_H */

commit 5465fe0fc3316f7cdda66732a7986f4ebe76d949
Merge: cbf2f8a99a23 0a637ee61247
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Sep 13 20:21:55 2016 +0200

    Merge tag 'efi-next' of git://git.kernel.org/pub/scm/linux/kernel/git/mfleming/efi into efi/core
    
    Pull EFI updates from Matt Fleming:
    
    "* Refactor the EFI memory map code into architecture neutral files
       and allow drivers to permanently reserve EFI boot services regions
       on x86, as well as ARM/arm64 - Matt Fleming
    
     * Add ARM support for the EFI esrt driver - Ard Biesheuvel
    
     * Make the EFI runtime services and efivar API interruptible by
       swapping spinlocks for semaphores - Sylvain Chouleur
    
     * Provide the EFI identity mapping for kexec which allows kexec to
       work on SGI/UV platforms with requiring the "noefi" kernel command
       line parameter - Alex Thorlton
    
     * Add debugfs node to dump EFI page tables on arm64 - Ard Biesheuvel
    
     * Merge the EFI test driver being carried out of tree until now in
       the FWTS project - Ivan Hu
    
     * Expand the list of flags for classifying EFI regions as "RAM" on
       arm64 so we align with the UEFI spec - Ard Biesheuvel
    
     * Optimise out the EFI mixed mode if it's unsupported (CONFIG_X86_32)
       or disabled (CONFIG_EFI_MIXED=n) and switch the early EFI boot
       services function table for direct calls, alleviating us from
       having to maintain the custom function table - Lukas Wunner
    
     * Miscellaneous cleanups and fixes"
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit dce48e351c0d42014e5fb16ac3eb099e11b7e716
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Jul 15 21:36:31 2016 +0200

    efi: Replace runtime services spinlock with semaphore
    
    The purpose of the efi_runtime_lock is to prevent concurrent calls into
    the firmware. There is no need to use spinlocks here, as long as we ensure
    that runtime service invocations from an atomic context (i.e., EFI pstore)
    cannot block.
    
    So use a semaphore instead, and use down_trylock() in the nonblocking case.
    We don't use a mutex here because the mutex_trylock() function must not
    be called from interrupt context, whereas the down_trylock() can.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Sylvain Chouleur <sylvain.chouleur@gmail.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 4d6da7b66c19..4c92c0630c45 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -38,6 +38,7 @@
 #define EFI_WRITE_PROTECTED	( 8 | (1UL << (BITS_PER_LONG-1)))
 #define EFI_OUT_OF_RESOURCES	( 9 | (1UL << (BITS_PER_LONG-1)))
 #define EFI_NOT_FOUND		(14 | (1UL << (BITS_PER_LONG-1)))
+#define EFI_ABORTED		(21 | (1UL << (BITS_PER_LONG-1)))
 #define EFI_SECURITY_VIOLATION	(26 | (1UL << (BITS_PER_LONG-1)))
 
 typedef unsigned long efi_status_t;

commit 21b3ddd39feecd2f4d6c52bcd30f0a4fa14f125a
Author: Sylvain Chouleur <sylvain.chouleur@intel.com>
Date:   Fri Jul 15 21:36:30 2016 +0200

    efi: Don't use spinlocks for efi vars
    
    All efivars operations are protected by a spinlock which prevents
    interruptions and preemption. This is too restricted, we just need a
    lock preventing concurrency.
    The idea is to use a semaphore of count 1 and to have two ways of
    locking, depending on the context:
    - In interrupt context, we call down_trylock(), if it fails we return
      an error
    - In normal context, we call down_interruptible()
    
    We don't use a mutex here because the mutex_trylock() function must not
    be called from interrupt context, whereas the down_trylock() can.
    
    Signed-off-by: Sylvain Chouleur <sylvain.chouleur@intel.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Sylvain Chouleur <sylvain.chouleur@gmail.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index deecb2902715..4d6da7b66c19 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1297,8 +1297,8 @@ struct kobject *efivars_kobject(void);
 int efivar_init(int (*func)(efi_char16_t *, efi_guid_t, unsigned long, void *),
 		void *data, bool duplicates, struct list_head *head);
 
-void efivar_entry_add(struct efivar_entry *entry, struct list_head *head);
-void efivar_entry_remove(struct efivar_entry *entry);
+int efivar_entry_add(struct efivar_entry *entry, struct list_head *head);
+int efivar_entry_remove(struct efivar_entry *entry);
 
 int __efivar_entry_delete(struct efivar_entry *entry);
 int efivar_entry_delete(struct efivar_entry *entry);
@@ -1315,7 +1315,7 @@ int efivar_entry_set_get_size(struct efivar_entry *entry, u32 attributes,
 int efivar_entry_set_safe(efi_char16_t *name, efi_guid_t vendor, u32 attributes,
 			  bool block, unsigned long size, void *data);
 
-void efivar_entry_iter_begin(void);
+int efivar_entry_iter_begin(void);
 void efivar_entry_iter_end(void);
 
 int __efivar_entry_iter(int (*func)(struct efivar_entry *, void *),

commit 217b27d4671a0a3f34147f1b341683d36b7457db
Author: Sylvain Chouleur <sylvain.chouleur@intel.com>
Date:   Fri Jul 15 21:36:29 2016 +0200

    efi: Use a file local lock for efivars
    
    This patch replaces the spinlock in the efivars struct with a single lock
    for the whole vars.c file.  The goal of this lock is to protect concurrent
    calls to efi variable services, registering and unregistering. This allows
    us to register new efivars operations without having in-progress call.
    
    Signed-off-by: Sylvain Chouleur <sylvain.chouleur@intel.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Sylvain Chouleur <sylvain.chouleur@gmail.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index d8b555db81c7..deecb2902715 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1157,12 +1157,6 @@ struct efivar_operations {
 };
 
 struct efivars {
-	/*
-	 * ->lock protects two things:
-	 * 1) efivarfs_list and efivars_sysfs_list
-	 * 2) ->ops calls
-	 */
-	spinlock_t lock;
 	struct kset *kset;
 	struct kobject *kobject;
 	const struct efivar_operations *ops;

commit 31ce8cc68180803aa481c0c1daac29d8eaceca9d
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Tue Mar 1 23:02:56 2016 +0000

    efi/runtime-map: Use efi.memmap directly instead of a copy
    
    Now that efi.memmap is available all of the time there's no need to
    allocate and build a separate copy of the EFI memory map.
    
    Furthermore, efi.memmap contains boot services regions but only those
    regions that have been reserved via efi_mem_reserve(). Using
    efi.memmap allows us to pass boot services across kexec reboot so that
    the ESRT and BGRT drivers will now work.
    
    Tested-by: Dave Young <dyoung@redhat.com> [kexec/kdump]
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org> [arm]
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 3fe4f3c47834..d8b555db81c7 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1357,7 +1357,6 @@ extern int efi_capsule_update(efi_capsule_header_t *capsule,
 
 #ifdef CONFIG_EFI_RUNTIME_MAP
 int efi_runtime_map_init(struct kobject *);
-void efi_runtime_map_setup(void *, int, u32);
 int efi_get_runtime_map_size(void);
 int efi_get_runtime_map_desc_size(void);
 int efi_runtime_map_copy(void *buf, size_t bufsz);
@@ -1367,9 +1366,6 @@ static inline int efi_runtime_map_init(struct kobject *kobj)
 	return 0;
 }
 
-static inline void
-efi_runtime_map_setup(void *map, int nr_entries, u32 desc_size) {}
-
 static inline int efi_get_runtime_map_size(void)
 {
 	return 0;

commit 816e76129ed5fadd28e526c43397c79775194b5c
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Mon Feb 29 21:22:52 2016 +0000

    efi: Allow drivers to reserve boot services forever
    
    Today, it is not possible for drivers to reserve EFI boot services for
    access after efi_free_boot_services() has been called on x86. For
    ARM/arm64 it can be done simply by calling memblock_reserve().
    
    Having this ability for all three architectures is desirable for a
    couple of reasons,
    
      1) It saves drivers copying data out of those regions
      2) kexec reboot can now make use of things like ESRT
    
    Instead of using the standard memblock_reserve() which is insufficient
    to reserve the region on x86 (see efi_reserve_boot_services()), a new
    API is introduced in this patch; efi_mem_reserve().
    
    efi.memmap now always represents which EFI memory regions are
    available. On x86 the EFI boot services regions that have not been
    reserved via efi_mem_reserve() will be removed from efi.memmap during
    efi_free_boot_services().
    
    This has implications for kexec, since it is not possible for a newly
    kexec'd kernel to access the same boot services regions that the
    initial boot kernel had access to unless they are reserved by every
    kexec kernel in the chain.
    
    Tested-by: Dave Young <dyoung@redhat.com> [kexec/kdump]
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org> [arm]
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 987c18f6fcae..3fe4f3c47834 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -944,6 +944,7 @@ extern u64 efi_mem_attribute (unsigned long phys_addr, unsigned long size);
 extern int __init efi_uart_console_only (void);
 extern u64 efi_mem_desc_end(efi_memory_desc_t *md);
 extern int efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md);
+extern void efi_mem_reserve(phys_addr_t addr, u64 size);
 extern void efi_initialize_iomem_resources(struct resource *code_resource,
 		struct resource *data_resource, struct resource *bss_resource);
 extern void efi_reserve_boot_services(void);

commit c45f4da33a297f85435f8dccb26a24852ea01bb9
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Wed Jun 22 16:54:00 2016 +0100

    efi: Add efi_memmap_install() for installing new EFI memory maps
    
    While efi_memmap_init_{early,late}() exist for architecture code to
    install memory maps from firmware data and for the virtual memory
    regions respectively, drivers don't care which stage of the boot we're
    at and just want to swap the existing memmap for a modified one.
    
    efi_memmap_install() abstracts the details of how the new memory map
    should be mapped and the existing one unmapped.
    
    Tested-by: Dave Young <dyoung@redhat.com> [kexec/kdump]
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org> [arm]
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 84c8638c7a8b..987c18f6fcae 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -923,6 +923,7 @@ extern void __iomem *efi_lookup_mapped_addr(u64 phys_addr);
 extern int __init efi_memmap_init_early(struct efi_memory_map_data *data);
 extern int __init efi_memmap_init_late(phys_addr_t addr, unsigned long size);
 extern void __init efi_memmap_unmap(void);
+extern int __init efi_memmap_install(phys_addr_t addr, unsigned int nr_map);
 extern int __init efi_memmap_split_count(efi_memory_desc_t *md,
 					 struct range *range);
 extern void __init efi_memmap_insert(struct efi_memory_map *old_memmap,

commit 60863c0d1a96b740048cc7d94a2d00d6f89ba3d8
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Mon Feb 29 20:30:39 2016 +0000

    efi: Split out EFI memory map functions into new file
    
    Also move the functions from the EFI fake mem driver since future
    patches will require access to the memmap insertion code even if
    CONFIG_EFI_FAKE_MEM isn't enabled.
    
    This will be useful when we need to build custom EFI memory maps to
    allow drivers to mark regions as reserved.
    
    Tested-by: Dave Young <dyoung@redhat.com> [kexec/kdump]
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org> [arm]
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index f149676b2fcd..84c8638c7a8b 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -20,6 +20,7 @@
 #include <linux/ioport.h>
 #include <linux/pfn.h>
 #include <linux/pstore.h>
+#include <linux/range.h>
 #include <linux/reboot.h>
 #include <linux/uuid.h>
 #include <linux/screen_info.h>
@@ -691,6 +692,11 @@ struct efi_memory_map {
 	bool late;
 };
 
+struct efi_mem_range {
+	struct range range;
+	u64 attribute;
+};
+
 struct efi_fdt_params {
 	u64 system_table;
 	u64 mmap;
@@ -917,6 +923,10 @@ extern void __iomem *efi_lookup_mapped_addr(u64 phys_addr);
 extern int __init efi_memmap_init_early(struct efi_memory_map_data *data);
 extern int __init efi_memmap_init_late(phys_addr_t addr, unsigned long size);
 extern void __init efi_memmap_unmap(void);
+extern int __init efi_memmap_split_count(efi_memory_desc_t *md,
+					 struct range *range);
+extern void __init efi_memmap_insert(struct efi_memory_map *old_memmap,
+				     void *buf, struct efi_mem_range *mem);
 
 extern int efi_config_init(efi_config_table_type_t *arch_tables);
 #ifdef CONFIG_EFI_ESRT

commit dca0f971ea6fcf2f1bb78f7995adf80da9f4767f
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Sat Feb 27 15:52:50 2016 +0000

    efi: Add efi_memmap_init_late() for permanent EFI memmap
    
    Drivers need a way to access the EFI memory map at runtime. ARM and
    arm64 currently provide this by remapping the EFI memory map into the
    vmalloc space before setting up the EFI virtual mappings.
    
    x86 does not provide this functionality which has resulted in the code
    in efi_mem_desc_lookup() where it will manually map individual EFI
    memmap entries if the memmap has already been torn down on x86,
    
      /*
       * If a driver calls this after efi_free_boot_services,
       * ->map will be NULL, and the target may also not be mapped.
       * So just always get our own virtual map on the CPU.
       *
       */
      md = early_memremap(p, sizeof (*md));
    
    There isn't a good reason for not providing a permanent EFI memory map
    for runtime queries, especially since the EFI regions are not mapped
    into the standard kernel page tables.
    
    Tested-by: Dave Young <dyoung@redhat.com> [kexec/kdump]
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org> [arm]
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index d862d4998580..f149676b2fcd 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -688,6 +688,7 @@ struct efi_memory_map {
 	int nr_map;
 	unsigned long desc_version;
 	unsigned long desc_size;
+	bool late;
 };
 
 struct efi_fdt_params {
@@ -914,6 +915,7 @@ static inline efi_status_t efi_query_variable_store(u32 attributes,
 extern void __iomem *efi_lookup_mapped_addr(u64 phys_addr);
 
 extern int __init efi_memmap_init_early(struct efi_memory_map_data *data);
+extern int __init efi_memmap_init_late(phys_addr_t addr, unsigned long size);
 extern void __init efi_memmap_unmap(void);
 
 extern int efi_config_init(efi_config_table_type_t *arch_tables);

commit 9479c7cebfb568f8b8b424be7f1cac120e9eea95
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Fri Feb 26 21:22:05 2016 +0000

    efi: Refactor efi_memmap_init_early() into arch-neutral code
    
    Every EFI architecture apart from ia64 needs to setup the EFI memory
    map at efi.memmap, and the code for doing that is essentially the same
    across all implementations. Therefore, it makes sense to factor this
    out into the common code under drivers/firmware/efi/.
    
    The only slight variation is the data structure out of which we pull
    the initial memory map information, such as physical address, memory
    descriptor size and version, etc. We can address this by passing a
    generic data structure (struct efi_memory_map_data) as the argument to
    efi_memmap_init_early() which contains the minimum info required for
    initialising the memory map.
    
    In the process, this patch also fixes a few undesirable implementation
    differences:
    
     - ARM and arm64 were failing to clear the EFI_MEMMAP bit when
       unmapping the early EFI memory map. EFI_MEMMAP indicates whether
       the EFI memory map is mapped (not the regions contained within) and
       can be traversed.  It's more correct to set the bit as soon as we
       memremap() the passed in EFI memmap.
    
     - Rename efi_unmmap_memmap() to efi_memmap_unmap() to adhere to the
       regular naming scheme.
    
    This patch also uses a read-write mapping for the memory map instead
    of the read-only mapping currently used on ARM and arm64. x86 needs
    the ability to update the memory map in-place when assigning virtual
    addresses to regions (efi_map_region()) and tagging regions when
    reserving boot services (efi_reserve_boot_services()).
    
    There's no way for the generic fake_mem code to know which mapping to
    use without introducing some arch-specific constant/hook, so just use
    read-write since read-only is of dubious value for the EFI memory map.
    
    Tested-by: Dave Young <dyoung@redhat.com> [kexec/kdump]
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org> [arm]
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 7f5a58225385..d862d4998580 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -669,6 +669,18 @@ typedef struct {
 	unsigned long tables;
 } efi_system_table_t;
 
+/*
+ * Architecture independent structure for describing a memory map for the
+ * benefit of efi_memmap_init_early(), saving us the need to pass four
+ * parameters.
+ */
+struct efi_memory_map_data {
+	phys_addr_t phys_map;
+	unsigned long size;
+	unsigned long desc_version;
+	unsigned long desc_size;
+};
+
 struct efi_memory_map {
 	phys_addr_t phys_map;
 	void *map;
@@ -900,6 +912,10 @@ static inline efi_status_t efi_query_variable_store(u32 attributes,
 }
 #endif
 extern void __iomem *efi_lookup_mapped_addr(u64 phys_addr);
+
+extern int __init efi_memmap_init_early(struct efi_memory_map_data *data);
+extern void __init efi_memmap_unmap(void);
+
 extern int efi_config_init(efi_config_table_type_t *arch_tables);
 #ifdef CONFIG_EFI_ESRT
 extern void __init efi_esrt_init(void);

commit fc07716ba803483be91bc4b2344f9c84985e6f07
Author: Jeffrey Hugo <jhugo@codeaurora.org>
Date:   Mon Aug 29 14:38:52 2016 -0600

    efi/libstub: Introduce ExitBootServices helper
    
    The spec allows ExitBootServices to fail with EFI_INVALID_PARAMETER if a
    race condition has occurred where the EFI has updated the memory map after
    the stub grabbed a reference to the map.  The spec defines a retry
    proceedure with specific requirements to handle this scenario.
    
    This scenario was previously observed on x86 - commit d3768d885c6c ("x86,
    efi: retry ExitBootServices() on failure") but the current fix is not spec
    compliant and the scenario is now observed on the Qualcomm Technologies
    QDF2432 via the FDT stub which does not handle the error and thus causes
    boot failures.  The user will notice the boot failure as the kernel is not
    executed and the system may drop back to a UEFI shell, but will be
    unresponsive to input and the system will require a power cycle to recover.
    
    Add a helper to the stub library that correctly adheres to the spec in the
    case of EFI_INVALID_PARAMETER from ExitBootServices and can be universally
    used across all stub implementations.
    
    Signed-off-by: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 943fee524176..0148a3046b48 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1462,4 +1462,14 @@ extern void efi_call_virt_check_flags(unsigned long flags, const char *call);
 	arch_efi_call_virt_teardown();					\
 })
 
+typedef efi_status_t (*efi_exit_boot_map_processing)(
+	efi_system_table_t *sys_table_arg,
+	struct efi_boot_memmap *map,
+	void *priv);
+
+efi_status_t efi_exit_boot_services(efi_system_table_t *sys_table,
+				    void *handle,
+				    struct efi_boot_memmap *map,
+				    void *priv,
+				    efi_exit_boot_map_processing priv_func);
 #endif /* _LINUX_EFI_H */

commit dadb57abc37499f565b23933dbf49b435c3ba8af
Author: Jeffrey Hugo <jhugo@codeaurora.org>
Date:   Mon Aug 29 14:38:51 2016 -0600

    efi/libstub: Allocate headspace in efi_get_memory_map()
    
    efi_get_memory_map() allocates a buffer to store the memory map that it
    retrieves.  This buffer may need to be reused by the client after
    ExitBootServices() is called, at which point allocations are not longer
    permitted.  To support this usecase, provide the allocated buffer size back
    to the client, and allocate some additional headroom to account for any
    reasonable growth in the map that is likely to happen between the call to
    efi_get_memory_map() and the client reusing the buffer.
    
    Signed-off-by: Jeffrey Hugo <jhugo@codeaurora.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 23cd3ced8c1a..943fee524176 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -118,6 +118,15 @@ typedef struct {
 	u32 imagesize;
 } efi_capsule_header_t;
 
+struct efi_boot_memmap {
+	efi_memory_desc_t	**map;
+	unsigned long		*map_size;
+	unsigned long		*desc_size;
+	u32			*desc_ver;
+	unsigned long		*key_ptr;
+	unsigned long		*buff_size;
+};
+
 /*
  * EFI capsule flags
  */
@@ -1371,11 +1380,7 @@ char *efi_convert_cmdline(efi_system_table_t *sys_table_arg,
 			  efi_loaded_image_t *image, int *cmd_line_len);
 
 efi_status_t efi_get_memory_map(efi_system_table_t *sys_table_arg,
-				efi_memory_desc_t **map,
-				unsigned long *map_size,
-				unsigned long *desc_size,
-				u32 *desc_ver,
-				unsigned long *key_ptr);
+				struct efi_boot_memmap *map);
 
 efi_status_t efi_low_alloc(efi_system_table_t *sys_table_arg,
 			   unsigned long size, unsigned long align,

commit d4c4fed08f31f3746000c46cb1b20bed2959547a
Author: Jan Beulich <JBeulich@suse.com>
Date:   Mon Aug 15 09:05:45 2016 -0600

    efi: Make for_each_efi_memory_desc_in_map() cope with running on Xen
    
    While commit 55f1ea15216 ("efi: Fix for_each_efi_memory_desc_in_map()
    for empty memmaps") made an attempt to deal with empty memory maps, it
    didn't address the case where the map field never gets set, as is
    apparently the case when running under Xen.
    
    Reported-by: <lists@ssl-mail.com>
    Tested-by: <lists@ssl-mail.com>
    Cc: Vitaly Kuznetsov <vkuznets@redhat.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: <stable@vger.kernel.org> # v4.7+
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    [ Guard the loop with a NULL check instead of pointer underflow ]
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 7f5a58225385..23cd3ced8c1a 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -946,7 +946,7 @@ extern int efi_memattr_apply_permissions(struct mm_struct *mm,
 /* Iterate through an efi_memory_map */
 #define for_each_efi_memory_desc_in_map(m, md)				   \
 	for ((md) = (m)->map;						   \
-	     ((void *)(md) + (m)->desc_size) <= (m)->map_end;		   \
+	     (md) && ((void *)(md) + (m)->desc_size) <= (m)->map_end;	   \
 	     (md) = (void *)(md) + (m)->desc_size)
 
 /**

commit e48af7aaf1e6d266414b11540339e6d2dac20ad2
Merge: ed780686de61 fbb0e4da96f4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 1 18:55:31 2016 -0400

    Merge tag 'please-pull-misc-4.8' of git://git.kernel.org/pub/scm/linux/kernel/git/aegl/linux
    
    Pull ia64 updates from Tony Luck:
     "Miscellaneous ia64 cleanups"
    
    * tag 'please-pull-misc-4.8' of git://git.kernel.org/pub/scm/linux/kernel/git/aegl/linux:
      ia64: salinfo: use a waitqueue instead a sema down/up combo
      ia64: efi: use timespec64 for persistent clock

commit 7fb2b43c3252c9177825a0a49138cd16144b6b5e
Author: Ingo Molnar <mingo@kernel.org>
Date:   Mon Jun 27 12:49:20 2016 +0200

    efi: Reorganize the GUID table to make it easier to read
    
    Re-organize the GUID table so that every GUID takes a single line.
    
    This makes each line super long, but if you have a large enough terminal
    (or zoom out of a small terminal) then you can see the structure at
    a glance - which is more readable than it was the case with the
    multi-line layout.
    
    Acked-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/20160627104920.GA9099@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 0174f28ce9b3..7f80a75ee9e3 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -538,9 +538,11 @@ void efi_native_runtime_setup(void);
 /*
  * EFI Configuration Table and GUID definitions
  *
- * These should be formatted roughly like the ones in the UEFI SPEC has
- * them.  It makes them easier to grep for, and they look the same when
- * you're staring at them.  Here's the guide:
+ * These are all defined in a single line to make them easier to
+ * grep for and to see them at a glance - while still having a
+ * similar structure to the definitions in the spec.
+ *
+ * Here's how they are structured:
  *
  * GUID: 12345678-1234-1234-1234-123456789012
  * Spec:
@@ -548,119 +550,44 @@ void efi_native_runtime_setup(void);
  *        {0x12345678,0x1234,0x1234,\
  *          {0x12,0x34,0x12,0x34,0x56,0x78,0x90,0x12}}
  * Here:
- *	#define SOME_PROTOCOL_GUID \
- *		EFI_GUID(0x12345678, 0x1234,  0x1234, \
- *			 0x12, 0x34, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12)
- *      ^ tab   ^tab    ^ space
+ *	#define SOME_PROTOCOL_GUID		EFI_GUID(0x12345678, 0x1234, 0x1234,  0x12, 0x34, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12)
+ *					^ tabs					    ^extra space
+ *
+ * Note that the 'extra space' separates the values at the same place
+ * where the UEFI SPEC breaks the line.
  */
-#define NULL_GUID \
-	EFI_GUID(0x00000000, 0x0000, 0x0000, \
-		 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
-
-#define MPS_TABLE_GUID    \
-	EFI_GUID(0xeb9d2d2f, 0x2d88, 0x11d3, \
-		 0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
-
-#define ACPI_TABLE_GUID    \
-	EFI_GUID(0xeb9d2d30, 0x2d88, 0x11d3, \
-		 0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
-
-#define ACPI_20_TABLE_GUID    \
-	EFI_GUID(0x8868e871, 0xe4f1, 0x11d3, \
-		 0xbc, 0x22, 0x00, 0x80, 0xc7, 0x3c, 0x88, 0x81)
-
-#define SMBIOS_TABLE_GUID    \
-	EFI_GUID(0xeb9d2d31, 0x2d88, 0x11d3, \
-		 0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
-
-#define SMBIOS3_TABLE_GUID    \
-	EFI_GUID(0xf2fd1544, 0x9794, 0x4a2c, \
-		 0x99, 0x2e, 0xe5, 0xbb, 0xcf, 0x20, 0xe3, 0x94)
-
-#define SAL_SYSTEM_TABLE_GUID    \
-	EFI_GUID(0xeb9d2d32, 0x2d88, 0x11d3, \
-		 0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
-
-#define HCDP_TABLE_GUID	\
-	EFI_GUID(0xf951938d, 0x620b, 0x42ef, \
-		 0x82, 0x79, 0xa8, 0x4b, 0x79, 0x61, 0x78, 0x98)
-
-#define UGA_IO_PROTOCOL_GUID \
-	EFI_GUID(0x61a4d49e, 0x6f68, 0x4f1b, \
-		 0xb9, 0x22, 0xa8, 0x6e, 0xed, 0x0b, 0x07, 0xa2)
-
-#define EFI_GLOBAL_VARIABLE_GUID \
-	EFI_GUID(0x8be4df61, 0x93ca, 0x11d2, \
-		 0xaa, 0x0d, 0x00, 0xe0, 0x98, 0x03, 0x2b, 0x8c)
-
-#define UV_SYSTEM_TABLE_GUID \
-	EFI_GUID(0x3b13a7d4, 0x633e, 0x11dd, \
-		 0x93, 0xec, 0xda, 0x25, 0x56, 0xd8, 0x95, 0x93)
-
-#define LINUX_EFI_CRASH_GUID \
-	EFI_GUID(0xcfc8fc79, 0xbe2e, 0x4ddc, \
-		 0x97, 0xf0, 0x9f, 0x98, 0xbf, 0xe2, 0x98, 0xa0)
-
-#define LOADED_IMAGE_PROTOCOL_GUID \
-	EFI_GUID(0x5b1b31a1, 0x9562, 0x11d2, \
-		 0x8e, 0x3f, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)
-
-#define EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID \
-	EFI_GUID(0x9042a9de, 0x23dc, 0x4a38, \
-		 0x96, 0xfb, 0x7a, 0xde, 0xd0, 0x80, 0x51, 0x6a)
-
-#define EFI_UGA_PROTOCOL_GUID \
-	EFI_GUID(0x982c298b, 0xf4fa, 0x41cb, \
-		 0xb8, 0x38, 0x77, 0xaa, 0x68, 0x8f, 0xb8, 0x39)
-
-#define EFI_PCI_IO_PROTOCOL_GUID \
-	EFI_GUID(0x4cf5b200, 0x68b8, 0x4ca5, \
-		 0x9e, 0xec, 0xb2, 0x3e, 0x3f, 0x50, 0x02, 0x9a)
-
-#define EFI_FILE_INFO_ID \
-	EFI_GUID(0x9576e92, 0x6d3f, 0x11d2, \
-		 0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)
-
-#define EFI_SYSTEM_RESOURCE_TABLE_GUID \
-	EFI_GUID(0xb122a263, 0x3661, 0x4f68, \
-		 0x99, 0x29, 0x78, 0xf8, 0xb0, 0xd6, 0x21, 0x80)
-
-#define EFI_FILE_SYSTEM_GUID \
-	EFI_GUID(0x964e5b22, 0x6459, 0x11d2, \
-		 0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)
-
-#define DEVICE_TREE_GUID \
-	EFI_GUID(0xb1b621d5, 0xf19c, 0x41a5, \
-		 0x83, 0x0b, 0xd9, 0x15, 0x2c, 0x69, 0xaa, 0xe0)
-
-#define EFI_PROPERTIES_TABLE_GUID \
-	EFI_GUID(0x880aaca3, 0x4adc, 0x4a04, \
-		 0x90, 0x79, 0xb7, 0x47, 0x34, 0x08, 0x25, 0xe5)
-
-#define EFI_RNG_PROTOCOL_GUID \
-	EFI_GUID(0x3152bca5, 0xeade, 0x433d, \
-		 0x86, 0x2e, 0xc0, 0x1c, 0xdc, 0x29, 0x1f, 0x44)
-
-#define EFI_MEMORY_ATTRIBUTES_TABLE_GUID \
-	EFI_GUID(0xdcfa911d, 0x26eb, 0x469f, \
-		 0xa2, 0x20, 0x38, 0xb7, 0xdc, 0x46, 0x12, 0x20)
-
-#define EFI_CONSOLE_OUT_DEVICE_GUID \
-	EFI_GUID(0xd3b36f2c, 0xd551, 0x11d4, \
-		 0x9a, 0x46, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
+#define NULL_GUID				EFI_GUID(0x00000000, 0x0000, 0x0000,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
+#define MPS_TABLE_GUID				EFI_GUID(0xeb9d2d2f, 0x2d88, 0x11d3,  0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
+#define ACPI_TABLE_GUID				EFI_GUID(0xeb9d2d30, 0x2d88, 0x11d3,  0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
+#define ACPI_20_TABLE_GUID			EFI_GUID(0x8868e871, 0xe4f1, 0x11d3,  0xbc, 0x22, 0x00, 0x80, 0xc7, 0x3c, 0x88, 0x81)
+#define SMBIOS_TABLE_GUID			EFI_GUID(0xeb9d2d31, 0x2d88, 0x11d3,  0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
+#define SMBIOS3_TABLE_GUID			EFI_GUID(0xf2fd1544, 0x9794, 0x4a2c,  0x99, 0x2e, 0xe5, 0xbb, 0xcf, 0x20, 0xe3, 0x94)
+#define SAL_SYSTEM_TABLE_GUID			EFI_GUID(0xeb9d2d32, 0x2d88, 0x11d3,  0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
+#define HCDP_TABLE_GUID				EFI_GUID(0xf951938d, 0x620b, 0x42ef,  0x82, 0x79, 0xa8, 0x4b, 0x79, 0x61, 0x78, 0x98)
+#define UGA_IO_PROTOCOL_GUID			EFI_GUID(0x61a4d49e, 0x6f68, 0x4f1b,  0xb9, 0x22, 0xa8, 0x6e, 0xed, 0x0b, 0x07, 0xa2)
+#define EFI_GLOBAL_VARIABLE_GUID		EFI_GUID(0x8be4df61, 0x93ca, 0x11d2,  0xaa, 0x0d, 0x00, 0xe0, 0x98, 0x03, 0x2b, 0x8c)
+#define UV_SYSTEM_TABLE_GUID			EFI_GUID(0x3b13a7d4, 0x633e, 0x11dd,  0x93, 0xec, 0xda, 0x25, 0x56, 0xd8, 0x95, 0x93)
+#define LINUX_EFI_CRASH_GUID			EFI_GUID(0xcfc8fc79, 0xbe2e, 0x4ddc,  0x97, 0xf0, 0x9f, 0x98, 0xbf, 0xe2, 0x98, 0xa0)
+#define LOADED_IMAGE_PROTOCOL_GUID		EFI_GUID(0x5b1b31a1, 0x9562, 0x11d2,  0x8e, 0x3f, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)
+#define EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID	EFI_GUID(0x9042a9de, 0x23dc, 0x4a38,  0x96, 0xfb, 0x7a, 0xde, 0xd0, 0x80, 0x51, 0x6a)
+#define EFI_UGA_PROTOCOL_GUID			EFI_GUID(0x982c298b, 0xf4fa, 0x41cb,  0xb8, 0x38, 0x77, 0xaa, 0x68, 0x8f, 0xb8, 0x39)
+#define EFI_PCI_IO_PROTOCOL_GUID		EFI_GUID(0x4cf5b200, 0x68b8, 0x4ca5,  0x9e, 0xec, 0xb2, 0x3e, 0x3f, 0x50, 0x02, 0x9a)
+#define EFI_FILE_INFO_ID			EFI_GUID(0x09576e92, 0x6d3f, 0x11d2,  0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)
+#define EFI_SYSTEM_RESOURCE_TABLE_GUID		EFI_GUID(0xb122a263, 0x3661, 0x4f68,  0x99, 0x29, 0x78, 0xf8, 0xb0, 0xd6, 0x21, 0x80)
+#define EFI_FILE_SYSTEM_GUID			EFI_GUID(0x964e5b22, 0x6459, 0x11d2,  0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)
+#define DEVICE_TREE_GUID			EFI_GUID(0xb1b621d5, 0xf19c, 0x41a5,  0x83, 0x0b, 0xd9, 0x15, 0x2c, 0x69, 0xaa, 0xe0)
+#define EFI_PROPERTIES_TABLE_GUID		EFI_GUID(0x880aaca3, 0x4adc, 0x4a04,  0x90, 0x79, 0xb7, 0x47, 0x34, 0x08, 0x25, 0xe5)
+#define EFI_RNG_PROTOCOL_GUID			EFI_GUID(0x3152bca5, 0xeade, 0x433d,  0x86, 0x2e, 0xc0, 0x1c, 0xdc, 0x29, 0x1f, 0x44)
+#define EFI_MEMORY_ATTRIBUTES_TABLE_GUID	EFI_GUID(0xdcfa911d, 0x26eb, 0x469f,  0xa2, 0x20, 0x38, 0xb7, 0xdc, 0x46, 0x12, 0x20)
+#define EFI_CONSOLE_OUT_DEVICE_GUID		EFI_GUID(0xd3b36f2c, 0xd551, 0x11d4,  0x9a, 0x46, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
 
 /*
  * This GUID is used to pass to the kernel proper the struct screen_info
  * structure that was populated by the stub based on the GOP protocol instance
  * associated with ConOut
  */
-#define LINUX_EFI_ARM_SCREEN_INFO_TABLE_GUID \
-	EFI_GUID(0xe03fc20a, 0x85dc, 0x406e, \
-		 0xb9, 0xe, 0x4a, 0xb5, 0x02, 0x37, 0x1d, 0x95)
-
-#define LINUX_EFI_LOADER_ENTRY_GUID \
-	EFI_GUID(0x4a67b082, 0x0a4c, 0x41cf, \
-		 0xb6, 0xc7, 0x44, 0x0b, 0x29, 0xbb, 0x8c, 0x4f)
+#define LINUX_EFI_ARM_SCREEN_INFO_TABLE_GUID	EFI_GUID(0xe03fc20a, 0x85dc, 0x406e,  0xb9, 0x0e, 0x4a, 0xb5, 0x02, 0x37, 0x1d, 0x95)
+#define LINUX_EFI_LOADER_ENTRY_GUID		EFI_GUID(0x4a67b082, 0x0a4c, 0x41cf,  0xb6, 0xc7, 0x44, 0x0b, 0x29, 0xbb, 0x8c, 0x4f)
 
 typedef struct {
 	efi_guid_t guid;

commit b684e9bc750b6349ff59f1b1ab4397cae255765f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Jun 25 08:20:30 2016 +0100

    x86/efi: Remove the unused efi_get_time() function
    
    Nothing calls the efi_get_time() function on x86, but it does suffer
    from the 32-bit time_t overflow in 2038.
    
    This removes the function, we can always put it back in case we need
    it later.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1466839230-12781-8-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 75d148dc9c3f..0174f28ce9b3 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -990,7 +990,6 @@ extern u64 efi_mem_desc_end(efi_memory_desc_t *md);
 extern int efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md);
 extern void efi_initialize_iomem_resources(struct resource *code_resource,
 		struct resource *data_resource, struct resource *bss_resource);
-extern void efi_get_time(struct timespec *now);
 extern void efi_reserve_boot_services(void);
 extern int efi_get_fdt_params(struct efi_fdt_params *params);
 extern struct kobject *efi_kobj;

commit 80e75596079f0a41f905836ad0ccaac68ba33612
Author: Alex Thorlton <athorlton@sgi.com>
Date:   Sat Jun 25 08:20:27 2016 +0100

    efi: Convert efi_call_virt() to efi_call_virt_pointer()
    
    This commit makes a few slight modifications to the efi_call_virt() macro
    to get it to work with function pointers that are stored in locations
    other than efi.systab->runtime, and renames the macro to
    efi_call_virt_pointer().  The majority of the changes here are to pull
    these macros up into header files so that they can be accessed from
    outside of drivers/firmware/efi/runtime-wrappers.c.
    
    The most significant change not directly related to the code move is to
    add an extra "p" argument into the appropriate efi_call macros, and use
    that new argument in place of the, formerly hard-coded,
    efi.systab->runtime pointer.
    
    The last piece of the puzzle was to add an efi_call_virt() macro back into
    drivers/firmware/efi/runtime-wrappers.c to wrap around the new
    efi_call_virt_pointer() macro - this was mainly to keep the code from
    looking too cluttered by adding a bunch of extra references to
    efi.systab->runtime everywhere.
    
    Note that I also broke up the code in the efi_call_virt_pointer() macro a
    bit in the process of moving it.
    
    Signed-off-by: Alex Thorlton <athorlton@sgi.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Roy Franz <roy.franz@linaro.org>
    Cc: Russ Anderson <rja@sgi.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1466839230-12781-5-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 03009695760d..75d148dc9c3f 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1480,4 +1480,55 @@ efi_status_t efi_setup_gop(efi_system_table_t *sys_table_arg,
 			   unsigned long size);
 
 bool efi_runtime_disabled(void);
+extern void efi_call_virt_check_flags(unsigned long flags, const char *call);
+
+/*
+ * Arch code can implement the following three template macros, avoiding
+ * reptition for the void/non-void return cases of {__,}efi_call_virt():
+ *
+ *  * arch_efi_call_virt_setup()
+ *
+ *    Sets up the environment for the call (e.g. switching page tables,
+ *    allowing kernel-mode use of floating point, if required).
+ *
+ *  * arch_efi_call_virt()
+ *
+ *    Performs the call. The last expression in the macro must be the call
+ *    itself, allowing the logic to be shared by the void and non-void
+ *    cases.
+ *
+ *  * arch_efi_call_virt_teardown()
+ *
+ *    Restores the usual kernel environment once the call has returned.
+ */
+
+#define efi_call_virt_pointer(p, f, args...)				\
+({									\
+	efi_status_t __s;						\
+	unsigned long __flags;						\
+									\
+	arch_efi_call_virt_setup();					\
+									\
+	local_save_flags(__flags);					\
+	__s = arch_efi_call_virt(p, f, args);				\
+	efi_call_virt_check_flags(__flags, __stringify(f));		\
+									\
+	arch_efi_call_virt_teardown();					\
+									\
+	__s;								\
+})
+
+#define __efi_call_virt_pointer(p, f, args...)				\
+({									\
+	unsigned long __flags;						\
+									\
+	arch_efi_call_virt_setup();					\
+									\
+	local_save_flags(__flags);					\
+	arch_efi_call_virt(p, f, args);					\
+	efi_call_virt_check_flags(__flags, __stringify(f));		\
+									\
+	arch_efi_call_virt_teardown();					\
+})
+
 #endif /* _LINUX_EFI_H */

commit 54fd11fee59e7d05287bc4eebccc8ec9742f2745
Author: Peter Jones <pjones@redhat.com>
Date:   Sat Jun 25 08:20:25 2016 +0100

    efi: Document #define FOO_PROTOCOL_GUID layout
    
    Add a comment documenting why EFI GUIDs are laid out like they are.
    
    Ideally I'd like to change all the ", " to "," too, but right now the
    format is such that checkpatch won't complain with new ones, and staring
    at checkpatch didn't get me anywhere towards making that work.
    
    Signed-off-by: Peter Jones <pjones@redhat.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1466839230-12781-3-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index f196dd0b0f2f..03009695760d 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -536,7 +536,22 @@ typedef efi_status_t efi_query_variable_store_t(u32 attributes,
 void efi_native_runtime_setup(void);
 
 /*
- *  EFI Configuration Table and GUID definitions
+ * EFI Configuration Table and GUID definitions
+ *
+ * These should be formatted roughly like the ones in the UEFI SPEC has
+ * them.  It makes them easier to grep for, and they look the same when
+ * you're staring at them.  Here's the guide:
+ *
+ * GUID: 12345678-1234-1234-1234-123456789012
+ * Spec:
+ *      #define EFI_SOME_PROTOCOL_GUID \
+ *        {0x12345678,0x1234,0x1234,\
+ *          {0x12,0x34,0x12,0x34,0x56,0x78,0x90,0x12}}
+ * Here:
+ *	#define SOME_PROTOCOL_GUID \
+ *		EFI_GUID(0x12345678, 0x1234,  0x1234, \
+ *			 0x12, 0x34, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12)
+ *      ^ tab   ^tab    ^ space
  */
 #define NULL_GUID \
 	EFI_GUID(0x00000000, 0x0000, 0x0000, \

commit 70f4f9352317ed8bc70cd7fe2bf34a3f9f7f21e3
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jun 17 16:48:17 2016 +0200

    ia64: efi: use timespec64 for persistent clock
    
    We have a generic read_persistent_clock64 interface now, and can
    change the ia64 implementation to provide that instead of
    read_persistent_clock.
    
    The main point of this is to avoid the use of struct timespec
    in the global efi.h, which would cause build errors as soon
    as we want to build a kernel without 'struct timespec' defined
    on 32-bit architectures.
    
    Aside from this, we get a little closer to removing the
    __weak read_persistent_clock() definition, which relies on
    converting all architectures to provide read_persistent_clock64
    instead.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index f196dd0b0f2f..acb6adace01e 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -937,7 +937,7 @@ extern void efi_init (void);
 extern void *efi_get_pal_addr (void);
 extern void efi_map_pal_code (void);
 extern void efi_memmap_walk (efi_freemem_callback_t callback, void *arg);
-extern void efi_gettimeofday (struct timespec *ts);
+extern void efi_gettimeofday (struct timespec64 *ts);
 extern void efi_enter_virtual_mode (void);	/* switch EFI to virtual mode, if possible */
 #ifdef CONFIG_X86
 extern void efi_late_init(void);

commit 55f1ea15216a5a14c96738bd5284100a00ffa9dc
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Tue May 31 11:23:43 2016 +0100

    efi: Fix for_each_efi_memory_desc_in_map() for empty memmaps
    
    Commit:
    
      78ce248faa3c ("efi: Iterate over efi.memmap in for_each_efi_memory_desc()")
    
    introduced a regression for systems booted with the 'noefi' kernel option.
    
    In particular, I observed an early kernel hang in efi_find_mirror()'s
    for_each_efi_memory_desc() call. As we don't have efi memmap on this
    system we enter this iterator with the following parameters:
    
      efi.memmap.map = 0, efi.memmap.map_end = 0, efi.memmap.desc_size = 28
    
    ... then for_each_efi_memory_desc_in_map() does the following comparison:
    
      (md) <= (efi_memory_desc_t *)((m)->map_end - (m)->desc_size);
    
    ... where md = 0, (m)->map_end = 0 and (m)->desc_size = 28 but when we subtract
    something from a NULL pointer wrap around happens and we end up returning
    invalid pointer and crash.
    
    Fix it by using the correct pointer arithmetics.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Fixes: 78ce248faa3c ("efi: Iterate over efi.memmap in for_each_efi_memory_desc()")
    Link: http://lkml.kernel.org/r/1464690224-4503-2-git-send-email-matt@codeblueprint.co.uk
    [ Made the changelog more readable. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index c2db3ca22217..f196dd0b0f2f 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1005,7 +1005,7 @@ extern int efi_memattr_apply_permissions(struct mm_struct *mm,
 /* Iterate through an efi_memory_map */
 #define for_each_efi_memory_desc_in_map(m, md)				   \
 	for ((md) = (m)->map;						   \
-	     (md) <= (efi_memory_desc_t *)((m)->map_end - (m)->desc_size); \
+	     ((void *)(md) + (m)->desc_size) <= (m)->map_end;		   \
 	     (md) = (void *)(md) + (m)->desc_size)
 
 /**

commit ba7e34b1bbd2722685bbc75d168672d5154d8614
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri May 20 17:01:18 2016 -0700

    include/linux/efi.h: redefine type, constant, macro from generic code
    
    Generic UUID library defines structure type, macro to define UUID, and
    the length of the UUID string.  This patch removes duplicate data
    structure definition, UUID string length constant as well as macro for
    UUID handling.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Dmitry Kasatkin <dmitry.kasatkin@gmail.com>
    Cc: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index df7acb51f3cc..c2db3ca22217 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -21,6 +21,7 @@
 #include <linux/pfn.h>
 #include <linux/pstore.h>
 #include <linux/reboot.h>
+#include <linux/uuid.h>
 #include <linux/screen_info.h>
 
 #include <asm/page.h>
@@ -44,17 +45,10 @@ typedef u16 efi_char16_t;		/* UNICODE character */
 typedef u64 efi_physical_addr_t;
 typedef void *efi_handle_t;
 
-
-typedef struct {
-	u8 b[16];
-} efi_guid_t;
+typedef uuid_le efi_guid_t;
 
 #define EFI_GUID(a,b,c,d0,d1,d2,d3,d4,d5,d6,d7) \
-((efi_guid_t) \
-{{ (a) & 0xff, ((a) >> 8) & 0xff, ((a) >> 16) & 0xff, ((a) >> 24) & 0xff, \
-  (b) & 0xff, ((b) >> 8) & 0xff, \
-  (c) & 0xff, ((c) >> 8) & 0xff, \
-  (d0), (d1), (d2), (d3), (d4), (d5), (d6), (d7) }})
+	UUID_LE(a, b, c, d0, d1, d2, d3, d4, d5, d6, d7)
 
 /*
  * Generic EFI table header
@@ -1117,7 +1111,7 @@ extern int efi_status_to_err(efi_status_t status);
  * Length of a GUID string (strlen("aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee"))
  * not including trailing NUL
  */
-#define EFI_VARIABLE_GUID_LEN 36
+#define EFI_VARIABLE_GUID_LEN	UUID_STRING_LEN
 
 /*
  * The type of search to perform when calling boottime->locate_handle

commit 1cfd63166c8e7494a1b457df9bb291a601091c26
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri May 6 22:39:30 2016 +0100

    efi: Merge boolean flag arguments
    
    The parameters atomic and duplicates of efivar_init always have opposite
    values.  Drop the parameter atomic, replace the uses of !atomic with
    duplicates, and update the call sites accordingly.
    
    The code using duplicates is slightly reorganized with an 'else', to avoid
    duplicating the lock code.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Jeremy Kerr <jk@ozlabs.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Saurabh Sengar <saurabh.truth@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Vaishali Thakkar <vaishali.thakkar@oracle.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1462570771-13324-5-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index aa36fb8bea4b..df7acb51f3cc 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1336,8 +1336,7 @@ int efivars_unregister(struct efivars *efivars);
 struct kobject *efivars_kobject(void);
 
 int efivar_init(int (*func)(efi_char16_t *, efi_guid_t, unsigned long, void *),
-		void *data, bool atomic, bool duplicates,
-		struct list_head *head);
+		void *data, bool duplicates, struct list_head *head);
 
 void efivar_entry_add(struct efivar_entry *entry, struct list_head *head);
 void efivar_entry_remove(struct efivar_entry *entry);

commit 87615a34d561ef59bd0cffc73256a21220dfdffd
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Mon Apr 25 21:07:00 2016 +0100

    x86/efi: Force EFI reboot to process pending capsules
    
    If an EFI capsule has been sent to the firmware we must match the type
    of EFI reset against that required by the capsule to ensure it is
    processed correctly.
    
    Force an EFI reboot if a capsule is pending for the next reset.
    
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Kweh Hock Leong <hock.leong.kweh@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: joeyli <jlee@suse.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-29-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index a3b4c1ec38c0..aa36fb8bea4b 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1085,6 +1085,12 @@ static inline bool efi_enabled(int feature)
 }
 static inline void
 efi_reboot(enum reboot_mode reboot_mode, const char *__unused) {}
+
+static inline bool
+efi_capsule_pending(int *reset_type)
+{
+	return false;
+}
 #endif
 
 extern int efi_status_to_err(efi_status_t status);

commit f0133f3c5b8bb34ec4dec50c27e7a655aeee8935
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Mon Apr 25 21:06:59 2016 +0100

    efi: Add 'capsule' update support
    
    The EFI capsule mechanism allows data blobs to be passed to the EFI
    firmware. A common use case is performing firmware updates. This patch
    just introduces the main infrastructure for interacting with the
    firmware, and a driver that allows users to upload capsules will come
    in a later patch.
    
    Once a capsule has been passed to the firmware, the next reboot must
    be performed using the ResetSystem() EFI runtime service, which may
    involve overriding the reboot type specified by reboot=. This ensures
    the reset value returned by QueryCapsuleCapabilities() is used to
    reset the system, which is required for the capsule to be processed.
    efi_capsule_pending() is provided for this purpose.
    
    At the moment we only allow a single capsule blob to be sent to the
    firmware despite the fact that UpdateCapsule() takes a 'CapsuleCount'
    parameter. This simplifies the API and shouldn't result in any
    downside since it is still possible to send multiple capsules by
    repeatedly calling UpdateCapsule().
    
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Bryan O'Donoghue <pure.logic@nexus-software.ie>
    Cc: Kweh Hock Leong <hock.leong.kweh@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: joeyli <jlee@suse.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-28-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index ca47481885c4..a3b4c1ec38c0 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -124,6 +124,13 @@ typedef struct {
 	u32 imagesize;
 } efi_capsule_header_t;
 
+/*
+ * EFI capsule flags
+ */
+#define EFI_CAPSULE_PERSIST_ACROSS_RESET	0x00010000
+#define EFI_CAPSULE_POPULATE_SYSTEM_TABLE	0x00020000
+#define EFI_CAPSULE_INITIATE_RESET		0x00040000
+
 /*
  * Allocation types for calls to boottime->allocate_pages.
  */
@@ -1370,6 +1377,13 @@ int efivars_sysfs_init(void);
 #define EFIVARS_DATA_SIZE_MAX 1024
 
 #endif /* CONFIG_EFI_VARS */
+extern bool efi_capsule_pending(int *reset_type);
+
+extern int efi_capsule_supported(efi_guid_t guid, u32 flags,
+				 size_t size, int *reset);
+
+extern int efi_capsule_update(efi_capsule_header_t *capsule,
+			      struct page **pages);
 
 #ifdef CONFIG_EFI_RUNTIME_MAP
 int efi_runtime_map_init(struct kobject *);

commit 806b0351c9ff9890c1ef0ba2c46237baef49ac79
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Mon Apr 25 21:06:58 2016 +0100

    efi: Move efi_status_to_err() to drivers/firmware/efi/
    
    Move efi_status_to_err() to the architecture independent code as it's
    generally useful in all bits of EFI code where there is a need to
    convert an efi_status_t to a kernel error value.
    
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Kweh Hock Leong <hock.leong.kweh@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: joeyli <jlee@suse.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-27-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 4db7052b2699..ca47481885c4 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1080,6 +1080,8 @@ static inline void
 efi_reboot(enum reboot_mode reboot_mode, const char *__unused) {}
 #endif
 
+extern int efi_status_to_err(efi_status_t status);
+
 /*
  * Variable Attributes
  */

commit 06f7d4a1618dbb086e738c93cd1ef416ab01027d
Author: Compostella, Jeremy <jeremy.compostella@intel.com>
Date:   Mon Apr 25 21:06:57 2016 +0100

    efibc: Add EFI Bootloader Control module
    
    This module installs a reboot callback, such that if reboot() is invoked
    with a string argument NNN, "NNN" is copied to the "LoaderEntryOneShot"
    EFI variable, to be read by the bootloader.
    
    If the string matches one of the boot labels defined in its configuration,
    the bootloader will boot once to that label.  The "LoaderEntryRebootReason"
    EFI variable is set with the reboot reason: "reboot", "shutdown".
    
    The bootloader reads this reboot reason and takes particular action
    according to its policy.
    
    There are reboot implementations that do "reboot <reason>", such as
    Android's reboot command and Upstart's reboot replacement, which pass
    the reason as an argument to the reboot syscall.  There is no
    platform-agnostic way how those could be modified to pass the reason
    to the bootloader, regardless of platform or bootloader.
    
    Signed-off-by: Jeremy Compostella <jeremy.compostella@intel.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stefan Stanacar <stefan.stanacar@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-26-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index e53458842245..4db7052b2699 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -642,6 +642,10 @@ void efi_native_runtime_setup(void);
 	EFI_GUID(0xe03fc20a, 0x85dc, 0x406e, \
 		 0xb9, 0xe, 0x4a, 0xb5, 0x02, 0x37, 0x1d, 0x95)
 
+#define LINUX_EFI_LOADER_ENTRY_GUID \
+	EFI_GUID(0x4a67b082, 0x0a4c, 0x41cf, \
+		 0xb6, 0xc7, 0x44, 0x0b, 0x29, 0xbb, 0x8c, 0x4f)
+
 typedef struct {
 	efi_guid_t guid;
 	u64 table;

commit 801820bee9bccb7c156af2b95c7208f428a06ae7
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Apr 25 21:06:53 2016 +0100

    efi/arm/libstub: Make screen_info accessible to the UEFI stub
    
    In order to hand over the framebuffer described by the GOP protocol and
    discovered by the UEFI stub, make struct screen_info accessible by the
    stub. This involves allocating a loader data buffer and passing it to the
    kernel proper via a UEFI Configuration Table, since the UEFI stub executes
    in the context of the decompressor, and cannot access the kernel's copy of
    struct screen_info directly.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: David Herrmann <dh.herrmann@gmail.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-22-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 9203bbb28887..e53458842245 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -286,7 +286,7 @@ typedef struct {
 	efi_status_t (*locate_handle)(int, efi_guid_t *, void *,
 				      unsigned long *, efi_handle_t *);
 	void *locate_device_path;
-	void *install_configuration_table;
+	efi_status_t (*install_configuration_table)(efi_guid_t *, void *);
 	void *load_image;
 	void *start_image;
 	void *exit;
@@ -633,6 +633,15 @@ void efi_native_runtime_setup(void);
 	EFI_GUID(0xd3b36f2c, 0xd551, 0x11d4, \
 		 0x9a, 0x46, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
 
+/*
+ * This GUID is used to pass to the kernel proper the struct screen_info
+ * structure that was populated by the stub based on the GOP protocol instance
+ * associated with ConOut
+ */
+#define LINUX_EFI_ARM_SCREEN_INFO_TABLE_GUID \
+	EFI_GUID(0xe03fc20a, 0x85dc, 0x406e, \
+		 0xb9, 0xe, 0x4a, 0xb5, 0x02, 0x37, 0x1d, 0x95)
+
 typedef struct {
 	efi_guid_t guid;
 	u64 table;

commit fc37206427ce38eafbeff48099d873235e878450
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Apr 25 21:06:49 2016 +0100

    efi/libstub: Move Graphics Output Protocol handling to generic code
    
    The Graphics Output Protocol code executes in the stub, so create a generic
    version based on the x86 version in libstub so that we can move other archs
    to it in subsequent patches. The new source file gop.c is added to the
    libstub build for all architectures, but only wired up for x86.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: David Herrmann <dh.herrmann@gmail.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-18-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index c2949909339b..9203bbb28887 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -283,7 +283,8 @@ typedef struct {
 	efi_status_t (*handle_protocol)(efi_handle_t, efi_guid_t *, void **);
 	void *__reserved;
 	void *register_protocol_notify;
-	void *locate_handle;
+	efi_status_t (*locate_handle)(int, efi_guid_t *, void *,
+				      unsigned long *, efi_handle_t *);
 	void *locate_device_path;
 	void *install_configuration_table;
 	void *load_image;
@@ -628,6 +629,10 @@ void efi_native_runtime_setup(void);
 	EFI_GUID(0xdcfa911d, 0x26eb, 0x469f, \
 		 0xa2, 0x20, 0x38, 0xb7, 0xdc, 0x46, 0x12, 0x20)
 
+#define EFI_CONSOLE_OUT_DEVICE_GUID \
+	EFI_GUID(0xd3b36f2c, 0xd551, 0x11d4, \
+		 0x9a, 0x46, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
+
 typedef struct {
 	efi_guid_t guid;
 	u64 table;
@@ -1214,6 +1219,80 @@ struct efi_simple_text_output_protocol {
 	void *test_string;
 };
 
+#define PIXEL_RGB_RESERVED_8BIT_PER_COLOR		0
+#define PIXEL_BGR_RESERVED_8BIT_PER_COLOR		1
+#define PIXEL_BIT_MASK					2
+#define PIXEL_BLT_ONLY					3
+#define PIXEL_FORMAT_MAX				4
+
+struct efi_pixel_bitmask {
+	u32 red_mask;
+	u32 green_mask;
+	u32 blue_mask;
+	u32 reserved_mask;
+};
+
+struct efi_graphics_output_mode_info {
+	u32 version;
+	u32 horizontal_resolution;
+	u32 vertical_resolution;
+	int pixel_format;
+	struct efi_pixel_bitmask pixel_information;
+	u32 pixels_per_scan_line;
+} __packed;
+
+struct efi_graphics_output_protocol_mode_32 {
+	u32 max_mode;
+	u32 mode;
+	u32 info;
+	u32 size_of_info;
+	u64 frame_buffer_base;
+	u32 frame_buffer_size;
+} __packed;
+
+struct efi_graphics_output_protocol_mode_64 {
+	u32 max_mode;
+	u32 mode;
+	u64 info;
+	u64 size_of_info;
+	u64 frame_buffer_base;
+	u64 frame_buffer_size;
+} __packed;
+
+struct efi_graphics_output_protocol_mode {
+	u32 max_mode;
+	u32 mode;
+	unsigned long info;
+	unsigned long size_of_info;
+	u64 frame_buffer_base;
+	unsigned long frame_buffer_size;
+} __packed;
+
+struct efi_graphics_output_protocol_32 {
+	u32 query_mode;
+	u32 set_mode;
+	u32 blt;
+	u32 mode;
+};
+
+struct efi_graphics_output_protocol_64 {
+	u64 query_mode;
+	u64 set_mode;
+	u64 blt;
+	u64 mode;
+};
+
+struct efi_graphics_output_protocol {
+	unsigned long query_mode;
+	unsigned long set_mode;
+	unsigned long blt;
+	struct efi_graphics_output_protocol_mode *mode;
+};
+
+typedef efi_status_t (*efi_graphics_output_protocol_query_mode)(
+	struct efi_graphics_output_protocol *, u32, unsigned long *,
+	struct efi_graphics_output_mode_info **);
+
 extern struct list_head efivar_sysfs_list;
 
 static inline void

commit 2c23b73c2d0249c499c4784b6db08dcfc6b7b3b0
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Apr 25 21:06:48 2016 +0100

    x86/efi: Prepare GOP handling code for reuse as generic code
    
    In preparation of moving this code to drivers/firmware/efi and reusing
    it on ARM and arm64, apply any changes that will be required to make this
    code build for other architectures. This should make it easier to track
    down problems that this move may cause to its operation on x86.
    
    Note that the generic version uses slightly different ways of casting the
    protocol methods and some other variables to the correct types, since such
    method calls are not loosely typed on ARM and arm64 as they are on x86.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: David Herrmann <dh.herrmann@gmail.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-17-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index e29a31d0fc35..c2949909339b 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -21,6 +21,7 @@
 #include <linux/pfn.h>
 #include <linux/pstore.h>
 #include <linux/reboot.h>
+#include <linux/screen_info.h>
 
 #include <asm/page.h>
 
@@ -1352,5 +1353,9 @@ efi_status_t handle_cmdline_files(efi_system_table_t *sys_table_arg,
 
 efi_status_t efi_parse_options(char *cmdline);
 
+efi_status_t efi_setup_gop(efi_system_table_t *sys_table_arg,
+			   struct screen_info *si, efi_guid_t *proto,
+			   unsigned long size);
+
 bool efi_runtime_disabled(void);
 #endif /* _LINUX_EFI_H */

commit 10f0d2f57705350bbbe5f28e9292ae3905823c3c
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Apr 25 21:06:45 2016 +0100

    efi: Implement generic support for the Memory Attributes table
    
    This implements shared support for discovering the presence of the
    Memory Attributes table, and for parsing and validating its contents.
    
    The table is validated against the construction rules in the UEFI spec.
    Since this is a new table, it makes sense to complain if we encounter
    a table that does not follow those rules.
    
    The parsing and validation routine takes a callback that can be specified
    per architecture, that gets passed each unique validated region, with the
    virtual address retrieved from the ordinary memory map.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    [ Trim pr_*() strings to 80 cols and use EFI consistently. ]
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-14-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 81af5feba1f7..e29a31d0fc35 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -969,6 +969,19 @@ extern void __init efi_fake_memmap(void);
 static inline void efi_fake_memmap(void) { }
 #endif
 
+/*
+ * efi_memattr_perm_setter - arch specific callback function passed into
+ *                           efi_memattr_apply_permissions() that updates the
+ *                           mapping permissions described by the second
+ *                           argument in the page tables referred to by the
+ *                           first argument.
+ */
+typedef int (*efi_memattr_perm_setter)(struct mm_struct *, efi_memory_desc_t *);
+
+extern int efi_memattr_init(void);
+extern int efi_memattr_apply_permissions(struct mm_struct *mm,
+					 efi_memattr_perm_setter fn);
+
 /* Iterate through an efi_memory_map */
 #define for_each_efi_memory_desc_in_map(m, md)				   \
 	for ((md) = (m)->map;						   \

commit a604af075a3226adaff84b7026876f0c6dfe9f52
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Apr 25 21:06:44 2016 +0100

    efi: Add support for the EFI_MEMORY_ATTRIBUTES_TABLE config table
    
    This declares the GUID and struct typedef for the new memory attributes
    table which contains the permissions that can be used to apply stricter
    permissions to UEFI Runtime Services memory regions.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-13-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index c2c0da49876e..81af5feba1f7 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -623,6 +623,10 @@ void efi_native_runtime_setup(void);
 	EFI_GUID(0x3152bca5, 0xeade, 0x433d, \
 		 0x86, 0x2e, 0xc0, 0x1c, 0xdc, 0x29, 0x1f, 0x44)
 
+#define EFI_MEMORY_ATTRIBUTES_TABLE_GUID \
+	EFI_GUID(0xdcfa911d, 0x26eb, 0x469f, \
+		 0xa2, 0x20, 0x38, 0xb7, 0xdc, 0x46, 0x12, 0x20)
+
 typedef struct {
 	efi_guid_t guid;
 	u64 table;
@@ -847,6 +851,14 @@ typedef struct {
 
 #define EFI_INVALID_TABLE_ADDR		(~0UL)
 
+typedef struct {
+	u32 version;
+	u32 num_entries;
+	u32 desc_size;
+	u32 reserved;
+	efi_memory_desc_t entry[0];
+} efi_memory_attributes_table_t;
+
 /*
  * All runtime access to EFI goes through this structure:
  */
@@ -868,6 +880,7 @@ extern struct efi {
 	unsigned long config_table;	/* config tables */
 	unsigned long esrt;		/* ESRT table */
 	unsigned long properties_table;	/* properties table */
+	unsigned long mem_attr_table;	/* memory attributes table */
 	efi_get_time_t *get_time;
 	efi_set_time_t *set_time;
 	efi_get_wakeup_time_t *get_wakeup_time;

commit 884f4f66ffd6ffe632f3a8be4e6d10a858afdc37
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Mon Apr 25 21:06:39 2016 +0100

    efi: Remove global 'memmap' EFI memory map
    
    Abolish the poorly named EFI memory map, 'memmap'. It is shadowed by a
    bunch of local definitions in various files and having two ways to
    access the EFI memory map ('efi.memmap' vs. 'memmap') is rather
    confusing.
    
    Furthermore, IA64 doesn't even provide this global object, which has
    caused issues when trying to write generic EFI memmap code.
    
    Replace all occurrences with efi.memmap, and convert the remaining
    iterator code to use for_each_efi_mem_desc().
    
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Luck, Tony <tony.luck@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-8-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 17ef4471e603..c2c0da49876e 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -883,7 +883,7 @@ extern struct efi {
 	efi_get_next_high_mono_count_t *get_next_high_mono_count;
 	efi_reset_system_t *reset_system;
 	efi_set_virtual_address_map_t *set_virtual_address_map;
-	struct efi_memory_map *memmap;
+	struct efi_memory_map memmap;
 	unsigned long flags;
 } efi;
 
@@ -945,7 +945,6 @@ extern void efi_initialize_iomem_resources(struct resource *code_resource,
 extern void efi_get_time(struct timespec *now);
 extern void efi_reserve_boot_services(void);
 extern int efi_get_fdt_params(struct efi_fdt_params *params);
-extern struct efi_memory_map memmap;
 extern struct kobject *efi_kobj;
 
 extern int efi_reboot_quirk_mode;
@@ -970,7 +969,7 @@ static inline void efi_fake_memmap(void) { }
  * Once the loop finishes @md must not be accessed.
  */
 #define for_each_efi_memory_desc(md) \
-	for_each_efi_memory_desc_in_map(efi.memmap, md)
+	for_each_efi_memory_desc_in_map(&efi.memmap, md)
 
 /*
  * Format an EFI memory descriptor's type and attributes to a user-provided

commit 78ce248faa3c46e24e9bd42db3ab3650659f16dd
Author: Matt Fleming <matt@codeblueprint.co.uk>
Date:   Mon Apr 25 21:06:38 2016 +0100

    efi: Iterate over efi.memmap in for_each_efi_memory_desc()
    
    Most of the users of for_each_efi_memory_desc() are equally happy
    iterating over the EFI memory map in efi.memmap instead of 'memmap',
    since the former is usually a pointer to the latter.
    
    For those users that want to specify an EFI memory map other than
    efi.memmap, that can be done using for_each_efi_memory_desc_in_map().
    One such example is in the libstub code where the firmware is queried
    directly for the memory map, it gets iterated over, and then freed.
    
    This change goes part of the way toward deleting the global 'memmap'
    variable, which is not universally available on all architectures
    (notably IA64) and is rather poorly named.
    
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-7-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 1545098b0565..17ef4471e603 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -958,11 +958,20 @@ static inline void efi_fake_memmap(void) { }
 #endif
 
 /* Iterate through an efi_memory_map */
-#define for_each_efi_memory_desc(m, md)					   \
+#define for_each_efi_memory_desc_in_map(m, md)				   \
 	for ((md) = (m)->map;						   \
 	     (md) <= (efi_memory_desc_t *)((m)->map_end - (m)->desc_size); \
 	     (md) = (void *)(md) + (m)->desc_size)
 
+/**
+ * for_each_efi_memory_desc - iterate over descriptors in efi.memmap
+ * @md: the efi_memory_desc_t * iterator
+ *
+ * Once the loop finishes @md must not be accessed.
+ */
+#define for_each_efi_memory_desc(md) \
+	for_each_efi_memory_desc_in_map(efi.memmap, md)
+
 /*
  * Format an EFI memory descriptor's type and attributes to a user-provided
  * character buffer, as per snprintf(), and return the buffer.

commit c5b591e96db9d99d0126acf93f24e1fb8b368343
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Apr 25 21:06:33 2016 +0100

    efi: Get rid of the EFI_SYSTEM_TABLES status bit
    
    The EFI_SYSTEM_TABLES status bit is set by all EFI supporting architectures
    upon discovery of the EFI system table, but the bit is never tested in any
    code we have in the tree. So remove it.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Luck, Tony <tony.luck@intel.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-2-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 1626474567ac..1545098b0565 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1000,7 +1000,6 @@ extern int __init efi_setup_pcdp_console(char *);
  * possible, remove EFI-related code altogether.
  */
 #define EFI_BOOT		0	/* Were we booted from EFI? */
-#define EFI_SYSTEM_TABLES	1	/* Can we use EFI system tables? */
 #define EFI_CONFIG_TABLES	2	/* Can we use EFI config tables? */
 #define EFI_RUNTIME_SERVICES	3	/* Can we use runtime services? */
 #define EFI_MEMMAP		4	/* Can we use EFI memory map? */

commit 24b5e20f11a75866bbffc46c30a22fa50612a769
Merge: 26660a4046b1 d367cef0a7f0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Mar 20 18:58:18 2016 -0700

    Merge branch 'efi-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull EFI updates from Ingo Molnar:
     "The main changes are:
    
       - Use separate EFI page tables when executing EFI firmware code.
         This isolates the EFI context from the rest of the kernel, which
         has security and general robustness advantages.  (Matt Fleming)
    
       - Run regular UEFI firmware with interrupts enabled.  This is already
         the status quo under other OSs.  (Ard Biesheuvel)
    
       - Various x86 EFI enhancements, such as the use of non-executable
         attributes for EFI memory mappings.  (Sai Praneeth Prakhya)
    
       - Various arm64 UEFI enhancements.  (Ard Biesheuvel)
    
       - ... various fixes and cleanups.
    
      The separate EFI page tables feature got delayed twice already,
      because it's an intrusive change and we didn't feel confident about
      it - third time's the charm we hope!"
    
    * 'efi-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (37 commits)
      x86/mm/pat: Fix boot crash when 1GB pages are not supported by the CPU
      x86/efi: Only map kernel text for EFI mixed mode
      x86/efi: Map EFI_MEMORY_{XP,RO} memory region bits to EFI page tables
      x86/mm/pat: Don't implicitly allow _PAGE_RW in kernel_map_pages_in_pgd()
      efi/arm*: Perform hardware compatibility check
      efi/arm64: Check for h/w support before booting a >4 KB granular kernel
      efi/arm: Check for LPAE support before booting a LPAE kernel
      efi/arm-init: Use read-only early mappings
      efi/efistub: Prevent __init annotations from being used
      arm64/vmlinux.lds.S: Handle .init.rodata.xxx and .init.bss sections
      efi/arm64: Drop __init annotation from handle_kernel_image()
      x86/mm/pat: Use _PAGE_GLOBAL bit for EFI page table mappings
      efi/runtime-wrappers: Run UEFI Runtime Services with interrupts enabled
      efi: Reformat GUID tables to follow the format in UEFI spec
      efi: Add Persistent Memory type name
      efi: Add NV memory attribute
      x86/efi: Show actual ending addresses in efi_print_memmap
      x86/efi/bgrt: Don't ignore the BGRT if the 'valid' bit is 0
      efivars: Use to_efivar_entry
      efi: Runtime-wrapper: Get rid of the rtc_lock spinlock
      ...

commit 588ab3f9afdfa1a6b1e5761c858b2c4ab6098285
Merge: 3d15cfdb1b77 2776e0e8ef68
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 17 20:03:47 2016 -0700

    Merge tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux
    
    Pull arm64 updates from Catalin Marinas:
     "Here are the main arm64 updates for 4.6.  There are some relatively
      intrusive changes to support KASLR, the reworking of the kernel
      virtual memory layout and initial page table creation.
    
      Summary:
    
       - Initial page table creation reworked to avoid breaking large block
         mappings (huge pages) into smaller ones.  The ARM architecture
         requires break-before-make in such cases to avoid TLB conflicts but
         that's not always possible on live page tables
    
       - Kernel virtual memory layout: the kernel image is no longer linked
         to the bottom of the linear mapping (PAGE_OFFSET) but at the bottom
         of the vmalloc space, allowing the kernel to be loaded (nearly)
         anywhere in physical RAM
    
       - Kernel ASLR: position independent kernel Image and modules being
         randomly mapped in the vmalloc space with the randomness is
         provided by UEFI (efi_get_random_bytes() patches merged via the
         arm64 tree, acked by Matt Fleming)
    
       - Implement relative exception tables for arm64, required by KASLR
         (initial code for ARCH_HAS_RELATIVE_EXTABLE added to lib/extable.c
         but actual x86 conversion to deferred to 4.7 because of the merge
         dependencies)
    
       - Support for the User Access Override feature of ARMv8.2: this
         allows uaccess functions (get_user etc.) to be implemented using
         LDTR/STTR instructions.  Such instructions, when run by the kernel,
         perform unprivileged accesses adding an extra level of protection.
         The set_fs() macro is used to "upgrade" such instruction to
         privileged accesses via the UAO bit
    
       - Half-precision floating point support (part of ARMv8.2)
    
       - Optimisations for CPUs with or without a hardware prefetcher (using
         run-time code patching)
    
       - copy_page performance improvement to deal with 128 bytes at a time
    
       - Sanity checks on the CPU capabilities (via CPUID) to prevent
         incompatible secondary CPUs from being brought up (e.g.  weird
         big.LITTLE configurations)
    
       - valid_user_regs() reworked for better sanity check of the
         sigcontext information (restored pstate information)
    
       - ACPI parking protocol implementation
    
       - CONFIG_DEBUG_RODATA enabled by default
    
       - VDSO code marked as read-only
    
       - DEBUG_PAGEALLOC support
    
       - ARCH_HAS_UBSAN_SANITIZE_ALL enabled
    
       - Erratum workaround Cavium ThunderX SoC
    
       - set_pte_at() fix for PROT_NONE mappings
    
       - Code clean-ups"
    
    * tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux: (99 commits)
      arm64: kasan: Fix zero shadow mapping overriding kernel image shadow
      arm64: kasan: Use actual memory node when populating the kernel image shadow
      arm64: Update PTE_RDONLY in set_pte_at() for PROT_NONE permission
      arm64: Fix misspellings in comments.
      arm64: efi: add missing frame pointer assignment
      arm64: make mrs_s prefixing implicit in read_cpuid
      arm64: enable CONFIG_DEBUG_RODATA by default
      arm64: Rework valid_user_regs
      arm64: mm: check at build time that PAGE_OFFSET divides the VA space evenly
      arm64: KVM: Move kvm_call_hyp back to its original localtion
      arm64: mm: treat memstart_addr as a signed quantity
      arm64: mm: list kernel sections in order
      arm64: lse: deal with clobbered IP registers after branch via PLT
      arm64: mm: dump: Use VA_START directly instead of private LOWEST_ADDR
      arm64: kconfig: add submenu for 8.2 architectural features
      arm64: kernel: acpi: fix ioremap in ACPI parking protocol cpu_postboot
      arm64: Add support for Half precision floating point
      arm64: Remove fixmap include fragility
      arm64: Add workaround for Cavium erratum 27456
      arm64: mm: Mark .rodata as RO
      ...

commit e4fbf4767440472f9d23b0f25a2b905e1c63b6a8
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Sun Jan 10 11:29:07 2016 +0100

    efi: stub: implement efi_get_random_bytes() based on EFI_RNG_PROTOCOL
    
    This exposes the firmware's implementation of EFI_RNG_PROTOCOL via a new
    function efi_get_random_bytes().
    
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 569b5a866bb1..e747eb08b2be 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -299,7 +299,7 @@ typedef struct {
 	void *open_protocol_information;
 	void *protocols_per_handle;
 	void *locate_handle_buffer;
-	void *locate_protocol;
+	efi_status_t (*locate_protocol)(efi_guid_t *, void *, void **);
 	void *install_multiple_protocol_interfaces;
 	void *uninstall_multiple_protocol_interfaces;
 	void *calculate_crc32;
@@ -599,6 +599,10 @@ void efi_native_runtime_setup(void);
 #define EFI_PROPERTIES_TABLE_GUID \
     EFI_GUID(  0x880aaca3, 0x4adc, 0x4a04, 0x90, 0x79, 0xb7, 0x47, 0x34, 0x08, 0x25, 0xe5 )
 
+#define EFI_RNG_PROTOCOL_GUID \
+	EFI_GUID(0x3152bca5, 0xeade, 0x433d, \
+		 0x86, 0x2e, 0xc0, 0x1c, 0xdc, 0x29, 0x1f, 0x44)
+
 typedef struct {
 	efi_guid_t guid;
 	u64 table;

commit 662b1d890c593673964758fe5b6f22067bffba7a
Author: Peter Jones <pjones@redhat.com>
Date:   Wed Feb 17 12:35:54 2016 +0000

    efi: Reformat GUID tables to follow the format in UEFI spec
    
    This makes it much easier to hunt for typos in the GUID definitions.
    
    It also makes checkpatch complain less about efi.h GUID additions, so
    that if you add another one with the same style, checkpatch won't
    complain about it.
    
    Signed-off-by: Peter Jones <pjones@redhat.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1455712566-16727-2-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 1acd72364297..42be9c92fdf0 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -536,67 +536,88 @@ void efi_native_runtime_setup(void);
  *  EFI Configuration Table and GUID definitions
  */
 #define NULL_GUID \
-    EFI_GUID(  0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 )
+	EFI_GUID(0x00000000, 0x0000, 0x0000, \
+		 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
 
 #define MPS_TABLE_GUID    \
-    EFI_GUID(  0xeb9d2d2f, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d )
+	EFI_GUID(0xeb9d2d2f, 0x2d88, 0x11d3, \
+		 0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
 
 #define ACPI_TABLE_GUID    \
-    EFI_GUID(  0xeb9d2d30, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d )
+	EFI_GUID(0xeb9d2d30, 0x2d88, 0x11d3, \
+		 0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
 
 #define ACPI_20_TABLE_GUID    \
-    EFI_GUID(  0x8868e871, 0xe4f1, 0x11d3, 0xbc, 0x22, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 )
+	EFI_GUID(0x8868e871, 0xe4f1, 0x11d3, \
+		 0xbc, 0x22, 0x00, 0x80, 0xc7, 0x3c, 0x88, 0x81)
 
 #define SMBIOS_TABLE_GUID    \
-    EFI_GUID(  0xeb9d2d31, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d )
+	EFI_GUID(0xeb9d2d31, 0x2d88, 0x11d3, \
+		 0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
 
 #define SMBIOS3_TABLE_GUID    \
-    EFI_GUID(  0xf2fd1544, 0x9794, 0x4a2c, 0x99, 0x2e, 0xe5, 0xbb, 0xcf, 0x20, 0xe3, 0x94 )
+	EFI_GUID(0xf2fd1544, 0x9794, 0x4a2c, \
+		 0x99, 0x2e, 0xe5, 0xbb, 0xcf, 0x20, 0xe3, 0x94)
 
 #define SAL_SYSTEM_TABLE_GUID    \
-    EFI_GUID(  0xeb9d2d32, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d )
+	EFI_GUID(0xeb9d2d32, 0x2d88, 0x11d3, \
+		 0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
 
 #define HCDP_TABLE_GUID	\
-    EFI_GUID(  0xf951938d, 0x620b, 0x42ef, 0x82, 0x79, 0xa8, 0x4b, 0x79, 0x61, 0x78, 0x98 )
+	EFI_GUID(0xf951938d, 0x620b, 0x42ef, \
+		 0x82, 0x79, 0xa8, 0x4b, 0x79, 0x61, 0x78, 0x98)
 
 #define UGA_IO_PROTOCOL_GUID \
-    EFI_GUID(  0x61a4d49e, 0x6f68, 0x4f1b, 0xb9, 0x22, 0xa8, 0x6e, 0xed, 0xb, 0x7, 0xa2 )
+	EFI_GUID(0x61a4d49e, 0x6f68, 0x4f1b, \
+		 0xb9, 0x22, 0xa8, 0x6e, 0xed, 0x0b, 0x07, 0xa2)
 
 #define EFI_GLOBAL_VARIABLE_GUID \
-    EFI_GUID(  0x8be4df61, 0x93ca, 0x11d2, 0xaa, 0x0d, 0x00, 0xe0, 0x98, 0x03, 0x2b, 0x8c )
+	EFI_GUID(0x8be4df61, 0x93ca, 0x11d2, \
+		 0xaa, 0x0d, 0x00, 0xe0, 0x98, 0x03, 0x2b, 0x8c)
 
 #define UV_SYSTEM_TABLE_GUID \
-    EFI_GUID(  0x3b13a7d4, 0x633e, 0x11dd, 0x93, 0xec, 0xda, 0x25, 0x56, 0xd8, 0x95, 0x93 )
+	EFI_GUID(0x3b13a7d4, 0x633e, 0x11dd, \
+		 0x93, 0xec, 0xda, 0x25, 0x56, 0xd8, 0x95, 0x93)
 
 #define LINUX_EFI_CRASH_GUID \
-    EFI_GUID(  0xcfc8fc79, 0xbe2e, 0x4ddc, 0x97, 0xf0, 0x9f, 0x98, 0xbf, 0xe2, 0x98, 0xa0 )
+	EFI_GUID(0xcfc8fc79, 0xbe2e, 0x4ddc, \
+		 0x97, 0xf0, 0x9f, 0x98, 0xbf, 0xe2, 0x98, 0xa0)
 
 #define LOADED_IMAGE_PROTOCOL_GUID \
-    EFI_GUID(  0x5b1b31a1, 0x9562, 0x11d2, 0x8e, 0x3f, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b )
+	EFI_GUID(0x5b1b31a1, 0x9562, 0x11d2, \
+		 0x8e, 0x3f, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)
 
 #define EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID \
-    EFI_GUID(  0x9042a9de, 0x23dc, 0x4a38, 0x96, 0xfb, 0x7a, 0xde, 0xd0, 0x80, 0x51, 0x6a )
+	EFI_GUID(0x9042a9de, 0x23dc, 0x4a38, \
+		 0x96, 0xfb, 0x7a, 0xde, 0xd0, 0x80, 0x51, 0x6a)
 
 #define EFI_UGA_PROTOCOL_GUID \
-    EFI_GUID(  0x982c298b, 0xf4fa, 0x41cb, 0xb8, 0x38, 0x77, 0xaa, 0x68, 0x8f, 0xb8, 0x39 )
+	EFI_GUID(0x982c298b, 0xf4fa, 0x41cb, \
+		 0xb8, 0x38, 0x77, 0xaa, 0x68, 0x8f, 0xb8, 0x39)
 
 #define EFI_PCI_IO_PROTOCOL_GUID \
-    EFI_GUID(  0x4cf5b200, 0x68b8, 0x4ca5, 0x9e, 0xec, 0xb2, 0x3e, 0x3f, 0x50, 0x2, 0x9a )
+	EFI_GUID(0x4cf5b200, 0x68b8, 0x4ca5, \
+		 0x9e, 0xec, 0xb2, 0x3e, 0x3f, 0x50, 0x02, 0x9a)
 
 #define EFI_FILE_INFO_ID \
-    EFI_GUID(  0x9576e92, 0x6d3f, 0x11d2, 0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b )
+	EFI_GUID(0x9576e92, 0x6d3f, 0x11d2, \
+		 0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)
 
 #define EFI_SYSTEM_RESOURCE_TABLE_GUID \
-    EFI_GUID(  0xb122a263, 0x3661, 0x4f68, 0x99, 0x29, 0x78, 0xf8, 0xb0, 0xd6, 0x21, 0x80 )
+	EFI_GUID(0xb122a263, 0x3661, 0x4f68, \
+		 0x99, 0x29, 0x78, 0xf8, 0xb0, 0xd6, 0x21, 0x80)
 
 #define EFI_FILE_SYSTEM_GUID \
-    EFI_GUID(  0x964e5b22, 0x6459, 0x11d2, 0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b )
+	EFI_GUID(0x964e5b22, 0x6459, 0x11d2, \
+		 0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)
 
 #define DEVICE_TREE_GUID \
-    EFI_GUID(  0xb1b621d5, 0xf19c, 0x41a5, 0x83, 0x0b, 0xd9, 0x15, 0x2c, 0x69, 0xaa, 0xe0 )
+	EFI_GUID(0xb1b621d5, 0xf19c, 0x41a5, \
+		 0x83, 0x0b, 0xd9, 0x15, 0x2c, 0x69, 0xaa, 0xe0)
 
 #define EFI_PROPERTIES_TABLE_GUID \
-    EFI_GUID(  0x880aaca3, 0x4adc, 0x4a04, 0x90, 0x79, 0xb7, 0x47, 0x34, 0x08, 0x25, 0xe5 )
+	EFI_GUID(0x880aaca3, 0x4adc, 0x4a04, \
+		 0x90, 0x79, 0xb7, 0x47, 0x34, 0x08, 0x25, 0xe5)
 
 typedef struct {
 	efi_guid_t guid;

commit ab876728a91d89e93e4928895529cd5bb4dff6e4
Merge: 35575e0e8ba6 81f70ba233d5
Author: Ingo Molnar <mingo@kernel.org>
Date:   Mon Feb 22 08:26:05 2016 +0100

    Merge tag 'v4.5-rc5' into efi/core, before queueing up new changes
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit ed8b0de5a33d2a2557dce7f9429dca8cb5bc5879
Author: Peter Jones <pjones@redhat.com>
Date:   Mon Feb 8 14:48:15 2016 -0500

    efi: Make efivarfs entries immutable by default
    
    "rm -rf" is bricking some peoples' laptops because of variables being
    used to store non-reinitializable firmware driver data that's required
    to POST the hardware.
    
    These are 100% bugs, and they need to be fixed, but in the mean time it
    shouldn't be easy to *accidentally* brick machines.
    
    We have to have delete working, and picking which variables do and don't
    work for deletion is quite intractable, so instead make everything
    immutable by default (except for a whitelist), and make tools that
    aren't quite so broad-spectrum unset the immutable flag.
    
    Signed-off-by: Peter Jones <pjones@redhat.com>
    Tested-by: Lee, Chun-Yi <jlee@suse.com>
    Acked-by: Matthew Garrett <mjg59@coreos.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 16ca611aabc8..47be3ad7d3e5 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1201,6 +1201,8 @@ struct efivar_entry *efivar_entry_find(efi_char16_t *name, efi_guid_t guid,
 
 bool efivar_validate(efi_guid_t vendor, efi_char16_t *var_name, u8 *data,
 		     unsigned long data_size);
+bool efivar_variable_is_removable(efi_guid_t vendor, const char *name,
+				  size_t len);
 
 extern struct work_struct efivar_work;
 void efivar_run_worker(void);

commit 8282f5d9c17fe15a9e658c06e3f343efae1a2a2f
Author: Peter Jones <pjones@redhat.com>
Date:   Mon Feb 8 14:48:14 2016 -0500

    efi: Make our variable validation list include the guid
    
    All the variables in this list so far are defined to be in the global
    namespace in the UEFI spec, so this just further ensures we're
    validating the variables we think we are.
    
    Including the guid for entries will become more important in future
    patches when we decide whether or not to allow deletion of variables
    based on presence in this list.
    
    Signed-off-by: Peter Jones <pjones@redhat.com>
    Tested-by: Lee, Chun-Yi <jlee@suse.com>
    Acked-by: Matthew Garrett <mjg59@coreos.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 569b5a866bb1..16ca611aabc8 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1199,7 +1199,8 @@ int efivar_entry_iter(int (*func)(struct efivar_entry *, void *),
 struct efivar_entry *efivar_entry_find(efi_char16_t *name, efi_guid_t guid,
 				       struct list_head *head, bool remove);
 
-bool efivar_validate(efi_char16_t *var_name, u8 *data, unsigned long len);
+bool efivar_validate(efi_guid_t vendor, efi_char16_t *var_name, u8 *data,
+		     unsigned long data_size);
 
 extern struct work_struct efivar_work;
 void efivar_run_worker(void);

commit c016ca08f89c6c78ed815f025262bdb87aba3f4c
Author: Robert Elliott <elliott@hpe.com>
Date:   Mon Feb 1 22:07:06 2016 +0000

    efi: Add NV memory attribute
    
    Add the NV memory attribute introduced in UEFI 2.5 and add a
    column for it in the types and attributes string used when
    printing the UEFI memory map.
    
    old:
      efi: mem61: [type=14            |   |  |  |  |  |  | |WB|WT|WC|UC] range=[0x0000000880000000-0x0000000c7fffffff) (16384MB)
    
    new:
      efi: mem61: [type=14            |   |  |NV|  |  |  |  | |WB|WT|WC|UC] range=[0x0000000880000000-0x0000000c7fffffff) (16384MB)
    
    Signed-off-by: Robert Elliott <elliott@hpe.com>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Reviewed-by: Laszlo Ersek <lersek@redhat.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1454364428-494-13-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 09f1559e7525..3c6cbbdae4aa 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -97,6 +97,7 @@ typedef	struct {
 #define EFI_MEMORY_WP		((u64)0x0000000000001000ULL)	/* write-protect */
 #define EFI_MEMORY_RP		((u64)0x0000000000002000ULL)	/* read-protect */
 #define EFI_MEMORY_XP		((u64)0x0000000000004000ULL)	/* execute-protect */
+#define EFI_MEMORY_NV		((u64)0x0000000000008000ULL)	/* non-volatile */
 #define EFI_MEMORY_MORE_RELIABLE \
 				((u64)0x0000000000010000ULL)	/* higher reliability */
 #define EFI_MEMORY_RO		((u64)0x0000000000020000ULL)	/* read-only */

commit ca0e30dcaa53a3fcb2dfdf74252d30bc40603eea
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Feb 1 22:06:58 2016 +0000

    efi: Add nonblocking option to efi_query_variable_store()
    
    The function efi_query_variable_store() may be invoked by
    efivar_entry_set_nonblocking(), which itself takes care to only
    call a non-blocking version of the SetVariable() runtime
    wrapper. However, efi_query_variable_store() may call the
    SetVariable() wrapper directly, as well as the wrapper for
    QueryVariableInfo(), both of which could deadlock in the same
    way we are trying to prevent by calling
    efivar_entry_set_nonblocking() in the first place.
    
    So instead, modify efi_query_variable_store() to use the
    non-blocking variants of QueryVariableInfo() (and give up rather
    than free up space if the available space is below
    EFI_MIN_RESERVE) if invoked with the 'nonblocking' argument set
    to true.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1454364428-494-5-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index ad1e177ba48e..09f1559e7525 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -525,7 +525,9 @@ typedef efi_status_t efi_query_capsule_caps_t(efi_capsule_header_t **capsules,
 					      unsigned long count,
 					      u64 *max_size,
 					      int *reset_type);
-typedef efi_status_t efi_query_variable_store_t(u32 attributes, unsigned long size);
+typedef efi_status_t efi_query_variable_store_t(u32 attributes,
+						unsigned long size,
+						bool nonblocking);
 
 void efi_native_runtime_setup(void);
 
@@ -881,13 +883,17 @@ extern void efi_enter_virtual_mode (void);	/* switch EFI to virtual mode, if pos
 #ifdef CONFIG_X86
 extern void efi_late_init(void);
 extern void efi_free_boot_services(void);
-extern efi_status_t efi_query_variable_store(u32 attributes, unsigned long size);
+extern efi_status_t efi_query_variable_store(u32 attributes,
+					     unsigned long size,
+					     bool nonblocking);
 extern void efi_find_mirror(void);
 #else
 static inline void efi_late_init(void) {}
 static inline void efi_free_boot_services(void) {}
 
-static inline efi_status_t efi_query_variable_store(u32 attributes, unsigned long size)
+static inline efi_status_t efi_query_variable_store(u32 attributes,
+						    unsigned long size,
+						    bool nonblocking)
 {
 	return EFI_SUCCESS;
 }

commit d3cac1f83c631b9fe5edaebcba49f6989bfff089
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Feb 1 22:06:57 2016 +0000

    efi/runtime-wrappers: Add a nonblocking version of QueryVariableInfo()
    
    This introduces a new runtime wrapper for the
    QueryVariableInfo() UEFI Runtime Service, which gives up
    immediately rather than spins on failure to grab the efi_runtime
    spinlock.
    
    This is required in the non-blocking path of the efi-pstore
    code.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1454364428-494-4-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 8706e0aabedc..ad1e177ba48e 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -849,6 +849,7 @@ extern struct efi {
 	efi_set_variable_t *set_variable;
 	efi_set_variable_t *set_variable_nonblocking;
 	efi_query_variable_info_t *query_variable_info;
+	efi_query_variable_info_t *query_variable_info_nonblocking;
 	efi_update_capsule_t *update_capsule;
 	efi_query_capsule_caps_t *query_capsule_caps;
 	efi_get_next_high_mono_count_t *get_next_high_mono_count;

commit 70d2a3cf2f4ae2e93b7a661842d84c2b5132cee7
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Feb 1 22:06:56 2016 +0000

    efi: Remove redundant efi_set_variable_nonblocking() prototype
    
    There is no need for a separate nonblocking prototype definition
    for the SetVariable() UEFI Runtime Service, since it is
    identical to the blocking version.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1454364428-494-3-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 569b5a866bb1..8706e0aabedc 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -507,10 +507,6 @@ typedef efi_status_t efi_get_next_variable_t (unsigned long *name_size, efi_char
 typedef efi_status_t efi_set_variable_t (efi_char16_t *name, efi_guid_t *vendor, 
 					 u32 attr, unsigned long data_size,
 					 void *data);
-typedef efi_status_t
-efi_set_variable_nonblocking_t(efi_char16_t *name, efi_guid_t *vendor,
-			       u32 attr, unsigned long data_size, void *data);
-
 typedef efi_status_t efi_get_next_high_mono_count_t (u32 *count);
 typedef void efi_reset_system_t (int reset_type, efi_status_t status,
 				 unsigned long data_size, efi_char16_t *data);
@@ -851,7 +847,7 @@ extern struct efi {
 	efi_get_variable_t *get_variable;
 	efi_get_next_variable_t *get_next_variable;
 	efi_set_variable_t *set_variable;
-	efi_set_variable_nonblocking_t *set_variable_nonblocking;
+	efi_set_variable_t *set_variable_nonblocking;
 	efi_query_variable_info_t *query_variable_info;
 	efi_update_capsule_t *update_capsule;
 	efi_query_capsule_caps_t *query_capsule_caps;
@@ -1091,7 +1087,7 @@ struct efivar_operations {
 	efi_get_variable_t *get_variable;
 	efi_get_next_variable_t *get_next_variable;
 	efi_set_variable_t *set_variable;
-	efi_set_variable_nonblocking_t *set_variable_nonblocking;
+	efi_set_variable_t *set_variable_nonblocking;
 	efi_query_variable_store_t *query_variable_store;
 };
 

commit 44511fb9e55ada760822b0b0d7be9d150576f17f
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Oct 23 11:48:16 2015 +0200

    efi: Use correct type for struct efi_memory_map::phys_map
    
    We have been getting away with using a void* for the physical
    address of the UEFI memory map, since, even on 32-bit platforms
    with 64-bit physical addresses, no truncation takes place if the
    memory map has been allocated by the firmware (which only uses
    1:1 virtually addressable memory), which is usually the case.
    
    However, commit:
    
      0f96a99dab36 ("efi: Add "efi_fake_mem" boot option")
    
    adds code that clones and modifies the UEFI memory map, and the
    clone may live above 4 GB on 32-bit platforms.
    
    This means our use of void* for struct efi_memory_map::phys_map has
    graduated from 'incorrect but working' to 'incorrect and
    broken', and we need to fix it.
    
    So redefine struct efi_memory_map::phys_map as phys_addr_t, and
    get rid of a bunch of casts that are now unneeded.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: izumi.taku@jp.fujitsu.com
    Cc: kamezawa.hiroyu@jp.fujitsu.com
    Cc: linux-efi@vger.kernel.org
    Cc: matt.fleming@intel.com
    Link: http://lkml.kernel.org/r/1445593697-1342-1-git-send-email-ard.biesheuvel@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 4d01c1033fce..569b5a866bb1 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -680,7 +680,7 @@ typedef struct {
 } efi_system_table_t;
 
 struct efi_memory_map {
-	void *phys_map;
+	phys_addr_t phys_map;
 	void *map;
 	void *map_end;
 	int nr_map;

commit 0f96a99dab366333439e110d6ad253bc7c557c09
Author: Taku Izumi <izumi.taku@jp.fujitsu.com>
Date:   Wed Sep 30 23:01:56 2015 +0900

    efi: Add "efi_fake_mem" boot option
    
    This patch introduces new boot option named "efi_fake_mem".
    By specifying this parameter, you can add arbitrary attribute
    to specific memory range.
    This is useful for debugging of Address Range Mirroring feature.
    
    For example, if "efi_fake_mem=2G@4G:0x10000,2G@0x10a0000000:0x10000"
    is specified, the original (firmware provided) EFI memmap will be
    updated so that the specified memory regions have
    EFI_MEMORY_MORE_RELIABLE attribute (0x10000):
    
     <original>
       efi: mem36: [Conventional Memory|  |  |  |  |  |   |WB|WT|WC|UC] range=[0x0000000100000000-0x00000020a0000000) (129536MB)
    
     <updated>
       efi: mem36: [Conventional Memory|  |MR|  |  |  |   |WB|WT|WC|UC] range=[0x0000000100000000-0x0000000180000000) (2048MB)
       efi: mem37: [Conventional Memory|  |  |  |  |  |   |WB|WT|WC|UC] range=[0x0000000180000000-0x00000010a0000000) (61952MB)
       efi: mem38: [Conventional Memory|  |MR|  |  |  |   |WB|WT|WC|UC] range=[0x00000010a0000000-0x0000001120000000) (2048MB)
       efi: mem39: [Conventional Memory|  |  |  |  |  |   |WB|WT|WC|UC] range=[0x0000001120000000-0x00000020a0000000) (63488MB)
    
    And you will find that the following message is output:
    
       efi: Memory: 4096M/131455M mirrored memory
    
    Signed-off-by: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Xishi Qiu <qiuxishi@huawei.com>
    Cc: Kamezawa Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index fa5106c2f9f5..4d01c1033fce 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -922,6 +922,12 @@ extern struct kobject *efi_kobj;
 extern int efi_reboot_quirk_mode;
 extern bool efi_poweroff_required(void);
 
+#ifdef CONFIG_EFI_FAKE_MEMMAP
+extern void __init efi_fake_memmap(void);
+#else
+static inline void efi_fake_memmap(void) { }
+#endif
+
 /* Iterate through an efi_memory_map */
 #define for_each_efi_memory_desc(m, md)					   \
 	for ((md) = (m)->map;						   \

commit a1041713349d0b823b492d7b4ea4325d0b5666db
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Sep 23 07:29:34 2015 -0700

    efi: Introduce EFI_NX_PE_DATA bit and set it from properties table
    
    UEFI v2.5 introduces a runtime memory protection feature that splits
    PE/COFF runtime images into separate code and data regions. Since this
    may require special handling by the OS, allocate a EFI_xxx bit to
    keep track of whether this feature is currently active or not.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index d6a9bee755f2..fa5106c2f9f5 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -973,6 +973,7 @@ extern int __init efi_setup_pcdp_console(char *);
 #define EFI_PARAVIRT		6	/* Access is via a paravirt interface */
 #define EFI_ARCH_1		7	/* First arch-specific bit */
 #define EFI_DBG			8	/* Print additional debug info at runtime */
+#define EFI_NX_PE_DATA		9	/* Can runtime data regions be mapped non-executable? */
 
 #ifdef CONFIG_EFI
 /*

commit bf924863c9445174c6e118f723dc477e2b6ccc7e
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Sep 9 10:08:15 2015 +0200

    efi: Add support for UEFIv2.5 Properties table
    
    Version 2.5 of the UEFI spec introduces a new configuration table
    called the 'EFI Properties table'. Currently, it is only used to
    convey whether the Memory Protection feature is enabled, which splits
    PE/COFF images into separate code and data memory regions.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Acked-by: Dave Young <dyoung@redhat.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 4677d8a1bfd0..d6a9bee755f2 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -596,6 +596,9 @@ void efi_native_runtime_setup(void);
 #define DEVICE_TREE_GUID \
     EFI_GUID(  0xb1b621d5, 0xf19c, 0x41a5, 0x83, 0x0b, 0xd9, 0x15, 0x2c, 0x69, 0xaa, 0xe0 )
 
+#define EFI_PROPERTIES_TABLE_GUID \
+    EFI_GUID(  0x880aaca3, 0x4adc, 0x4a04, 0x90, 0x79, 0xb7, 0x47, 0x34, 0x08, 0x25, 0xe5 )
+
 typedef struct {
 	efi_guid_t guid;
 	u64 table;
@@ -809,6 +812,15 @@ typedef struct _efi_file_io_interface {
 #define EFI_FILE_MODE_WRITE	0x0000000000000002
 #define EFI_FILE_MODE_CREATE	0x8000000000000000
 
+typedef struct {
+	u32 version;
+	u32 length;
+	u64 memory_protection_attribute;
+} efi_properties_table_t;
+
+#define EFI_PROPERTIES_TABLE_VERSION	0x00010000
+#define EFI_PROPERTIES_RUNTIME_MEMORY_PROTECTION_NON_EXECUTABLE_PE_DATA	0x1
+
 #define EFI_INVALID_TABLE_ADDR		(~0UL)
 
 /*
@@ -831,6 +843,7 @@ extern struct efi {
 	unsigned long runtime;		/* runtime table */
 	unsigned long config_table;	/* config tables */
 	unsigned long esrt;		/* ESRT table */
+	unsigned long properties_table;	/* properties table */
 	efi_get_time_t *get_time;
 	efi_set_time_t *set_time;
 	efi_get_wakeup_time_t *get_wakeup_time;

commit 7968c0e338085eba0ee2f0e0b0d833057a966679
Author: Leif Lindholm <leif.lindholm@linaro.org>
Date:   Wed Aug 26 14:24:58 2015 +0100

    efi/arm64: Clean up efi_get_fdt_params() interface
    
    As we now have a common debug infrastructure between core and arm64 efi,
    drop the bit of the interface passing verbose output flags around.
    
    Signed-off-by: Leif Lindholm <leif.lindholm@linaro.org>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 26ca9e2fd30e..4677d8a1bfd0 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -902,7 +902,7 @@ extern void efi_initialize_iomem_resources(struct resource *code_resource,
 		struct resource *data_resource, struct resource *bss_resource);
 extern void efi_get_time(struct timespec *now);
 extern void efi_reserve_boot_services(void);
-extern int efi_get_fdt_params(struct efi_fdt_params *params, int verbose);
+extern int efi_get_fdt_params(struct efi_fdt_params *params);
 extern struct efi_memory_map memmap;
 extern struct kobject *efi_kobj;
 

commit 87db73aebf55554fefaa3eade0a28f282a1511b8
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Aug 7 09:36:54 2015 +0100

    efi: Add support for EFI_MEMORY_RO attribute introduced by UEFIv2.5
    
    The UEFI spec v2.5 introduces a new memory attribute
    EFI_MEMORY_RO, which is now the preferred attribute to convey
    that the nature of the contents of such a region allows it to be
    mapped read-only (i.e., it contains .text and .rodata only).
    
    The specification of the existing EFI_MEMORY_WP attribute has been
    updated to align more closely with its common use as a
    cacheability attribute rather than a permission attribute.
    
    Add the #define and add the attribute to the memory map dumping
    routine.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Reviewed-by: Laszlo Ersek <lersek@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1438936621-5215-1-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 85ef051ac6fb..26ca9e2fd30e 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -99,6 +99,7 @@ typedef	struct {
 #define EFI_MEMORY_XP		((u64)0x0000000000004000ULL)	/* execute-protect */
 #define EFI_MEMORY_MORE_RELIABLE \
 				((u64)0x0000000000010000ULL)	/* higher reliability */
+#define EFI_MEMORY_RO		((u64)0x0000000000020000ULL)	/* read-only */
 #define EFI_MEMORY_RUNTIME	((u64)0x8000000000000000ULL)	/* range requires runtime mapping */
 #define EFI_MEMORY_DESCRIPTOR_VERSION	1
 

commit 88793e5c774ec69351ef6b5200bb59f532e41bca
Merge: 1bc5e157ed2b 61031952f4c8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 29 10:34:42 2015 -0700

    Merge tag 'libnvdimm-for-4.2' of git://git.kernel.org/pub/scm/linux/kernel/git/djbw/nvdimm
    
    Pull libnvdimm subsystem from Dan Williams:
     "The libnvdimm sub-system introduces, in addition to the
      libnvdimm-core, 4 drivers / enabling modules:
    
      NFIT:
        Instantiates an "nvdimm bus" with the core and registers memory
        devices (NVDIMMs) enumerated by the ACPI 6.0 NFIT (NVDIMM Firmware
        Interface table).
    
        After registering NVDIMMs the NFIT driver then registers "region"
        devices.  A libnvdimm-region defines an access mode and the
        boundaries of persistent memory media.  A region may span multiple
        NVDIMMs that are interleaved by the hardware memory controller.  In
        turn, a libnvdimm-region can be carved into a "namespace" device and
        bound to the PMEM or BLK driver which will attach a Linux block
        device (disk) interface to the memory.
    
      PMEM:
        Initially merged in v4.1 this driver for contiguous spans of
        persistent memory address ranges is re-worked to drive
        PMEM-namespaces emitted by the libnvdimm-core.
    
        In this update the PMEM driver, on x86, gains the ability to assert
        that writes to persistent memory have been flushed all the way
        through the caches and buffers in the platform to persistent media.
        See memcpy_to_pmem() and wmb_pmem().
    
      BLK:
        This new driver enables access to persistent memory media through
        "Block Data Windows" as defined by the NFIT.  The primary difference
        of this driver to PMEM is that only a small window of persistent
        memory is mapped into system address space at any given point in
        time.
    
        Per-NVDIMM windows are reprogrammed at run time, per-I/O, to access
        different portions of the media.  BLK-mode, by definition, does not
        support DAX.
    
      BTT:
        This is a library, optionally consumed by either PMEM or BLK, that
        converts a byte-accessible namespace into a disk with atomic sector
        update semantics (prevents sector tearing on crash or power loss).
    
        The sinister aspect of sector tearing is that most applications do
        not know they have a atomic sector dependency.  At least today's
        disk's rarely ever tear sectors and if they do one almost certainly
        gets a CRC error on access.  NVDIMMs will always tear and always
        silently.  Until an application is audited to be robust in the
        presence of sector-tearing the usage of BTT is recommended.
    
      Thanks to: Ross Zwisler, Jeff Moyer, Vishal Verma, Christoph Hellwig,
      Ingo Molnar, Neil Brown, Boaz Harrosh, Robert Elliott, Matthew Wilcox,
      Andy Rudoff, Linda Knippers, Toshi Kani, Nicholas Moulin, Rafael
      Wysocki, and Bob Moore"
    
    * tag 'libnvdimm-for-4.2' of git://git.kernel.org/pub/scm/linux/kernel/git/djbw/nvdimm: (33 commits)
      arch, x86: pmem api for ensuring durability of persistent memory updates
      libnvdimm: Add sysfs numa_node to NVDIMM devices
      libnvdimm: Set numa_node to NVDIMM devices
      acpi: Add acpi_map_pxm_to_online_node()
      libnvdimm, nfit: handle unarmed dimms, mark namespaces read-only
      pmem: flag pmem block devices as non-rotational
      libnvdimm: enable iostat
      pmem: make_request cleanups
      libnvdimm, pmem: fix up max_hw_sectors
      libnvdimm, blk: add support for blk integrity
      libnvdimm, btt: add support for blk integrity
      fs/block_dev.c: skip rw_page if bdev has integrity
      libnvdimm: Non-Volatile Devices
      tools/testing/nvdimm: libnvdimm unit test infrastructure
      libnvdimm, nfit, nd_blk: driver for BLK-mode access persistent memory
      nd_btt: atomic sector updates
      libnvdimm: infrastructure for btt devices
      libnvdimm: write blk label set
      libnvdimm: write pmem label set
      libnvdimm: blk labels and namespace instantiation
      ...

commit b05b9f5f9dcf593a0e9327676b78e6c17b4218e8
Author: Tony Luck <tony.luck@intel.com>
Date:   Wed Jun 24 16:58:15 2015 -0700

    x86, mirror: x86 enabling - find mirrored memory ranges
    
    UEFI GetMemoryMap() uses a new attribute bit to mark mirrored memory
    address ranges.  See UEFI 2.5 spec pages 157-158:
    
      http://www.uefi.org/sites/default/files/resources/UEFI%202_5.pdf
    
    On EFI enabled systems scan the memory map and tell memblock about any
    mirrored ranges.
    
    Signed-off-by: Tony Luck <tony.luck@intel.com>
    Cc: Xishi Qiu <qiuxishi@huawei.com>
    Cc: Hanjun Guo <guohanjun@huawei.com>
    Cc: Xiexiuqi <xiexiuqi@huawei.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Naoya Horiguchi <nao.horiguchi@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 2092965afca3..5f19efe4eb3f 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -96,6 +96,8 @@ typedef	struct {
 #define EFI_MEMORY_WP		((u64)0x0000000000001000ULL)	/* write-protect */
 #define EFI_MEMORY_RP		((u64)0x0000000000002000ULL)	/* read-protect */
 #define EFI_MEMORY_XP		((u64)0x0000000000004000ULL)	/* execute-protect */
+#define EFI_MEMORY_MORE_RELIABLE \
+				((u64)0x0000000000010000ULL)	/* higher reliability */
 #define EFI_MEMORY_RUNTIME	((u64)0x8000000000000000ULL)	/* range requires runtime mapping */
 #define EFI_MEMORY_DESCRIPTOR_VERSION	1
 
@@ -868,6 +870,7 @@ extern void efi_enter_virtual_mode (void);	/* switch EFI to virtual mode, if pos
 extern void efi_late_init(void);
 extern void efi_free_boot_services(void);
 extern efi_status_t efi_query_variable_store(u32 attributes, unsigned long size);
+extern void efi_find_mirror(void);
 #else
 static inline void efi_late_init(void) {}
 static inline void efi_free_boot_services(void) {}

commit 3846c15820a1841225d0245afda4875af23dfbbe
Author: Peter Jones <pjones@redhat.com>
Date:   Fri Jun 5 15:14:54 2015 -0400

    efi: Work around ia64 build problem with ESRT driver
    
    So, I'm told this problem exists in the world:
    
     > Subject: Build error in -next due to 'efi: Add esrt support'
     >
     > Building ia64:defconfig ... failed
     > --------------
     > Error log:
     >
     > drivers/firmware/efi/esrt.c:28:31: fatal error: asm/early_ioremap.h: No such file or directory
     >
    
    I'm not really sure how it's okay that we have things in asm-generic on
    some platforms but not others - is having it the same everywhere not the
    whole point of asm-generic?
    
    That said, ia64 doesn't have early_ioremap.h .  So instead, since it's
    difficult to imagine new IA64 machines with UEFI 2.5, just don't build
    this code there.
    
    To me this looks like a workaround - doing something like:
    
    generic-y += early_ioremap.h
    
    in arch/ia64/include/asm/Kbuild would appear to be more correct, but
    ia64 has its own early_memremap() decl in arch/ia64/include/asm/io.h ,
    and it's a macro.  So adding the above /and/ requiring that asm/io.h be
    included /after/ asm/early_ioremap.h in all cases would fix it, but
    that's pretty ugly as well.  Since I'm not going to spend the rest of my
    life rectifying ia64 headers vs "generic" headers that aren't generic,
    it's much simpler to just not build there.
    
    Note that I've only actually tried to build this patch on x86_64, but
    esrt.o still gets built there, and that would seem to demonstrate that
    the conditional building is working correctly at all the places the code
    built before.  I no longer have any ia64 machines handy to test that the
    exclusion actually works there.
    
    Signed-off-by: Peter Jones <pjones@redhat.com>
    Acked-by: Tony Luck <tony.luck@intel.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    (Compile-)Tested-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 024c27e7c0fa..2092965afca3 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -879,7 +879,11 @@ static inline efi_status_t efi_query_variable_store(u32 attributes, unsigned lon
 #endif
 extern void __iomem *efi_lookup_mapped_addr(u64 phys_addr);
 extern int efi_config_init(efi_config_table_type_t *arch_tables);
+#ifdef CONFIG_EFI_ESRT
 extern void __init efi_esrt_init(void);
+#else
+static inline void efi_esrt_init(void) { }
+#endif
 extern int efi_config_parse_tables(void *config_tables, int count, int sz,
 				   efi_config_table_type_t *arch_tables);
 extern u64 efi_get_iobase (void);

commit ad5fb870c486d932a1749d7853dd70f436a7e03f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Apr 3 12:05:28 2015 -0400

    e820, efi: add ACPI 6.0 persistent memory types
    
    ACPI 6.0 formalizes e820-type-7 and efi-type-14 as persistent memory.
    Mark it "reserved" and allow it to be claimed by a persistent memory
    device driver.
    
    This definition is in addition to the Linux kernel's existing type-12
    definition that was recently added in support of shipping platforms with
    NVDIMM support that predate ACPI 6.0 (which now classifies type-12 as
    OEM reserved).
    
    Note, /proc/iomem can be consulted for differentiating legacy
    "Persistent Memory (legacy)" E820_PRAM vs standard "Persistent Memory"
    E820_PMEM.
    
    Cc: Boaz Harrosh <boaz@plexistor.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Jens Axboe <axboe@fb.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matthew Wilcox <willy@linux.intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Jeff Moyer <jmoyer@redhat.com>
    Acked-by: Andy Lutomirski <luto@amacapital.net>
    Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index af5be0368dec..825b6e3d69cb 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -85,7 +85,8 @@ typedef	struct {
 #define EFI_MEMORY_MAPPED_IO		11
 #define EFI_MEMORY_MAPPED_IO_PORT_SPACE	12
 #define EFI_PAL_CODE			13
-#define EFI_MAX_MEMORY_TYPE		14
+#define EFI_PERSISTENT_MEMORY		14
+#define EFI_MAX_MEMORY_TYPE		15
 
 /* Attribute values: */
 #define EFI_MEMORY_UC		((u64)0x0000000000000001ULL)	/* uncached */

commit 0bb549052d33f8992544764a6cf1299d06ba7e2f
Author: Peter Jones <pjones@redhat.com>
Date:   Tue Apr 28 18:44:31 2015 -0400

    efi: Add esrt support
    
    Add sysfs files for the EFI System Resource Table (ESRT) under
    /sys/firmware/efi/esrt and for each EFI System Resource Entry under
    entries/ as a subdir.
    
    The EFI System Resource Table (ESRT) provides a read-only catalog of
    system components for which the system accepts firmware upgrades via
    UEFI's "Capsule Update" feature.  This module allows userland utilities
    to evaluate what firmware updates can be applied to this system, and
    potentially arrange for those updates to occur.
    
    The ESRT is described as part of the UEFI specification, in version 2.5
    which should be available from http://uefi.org/specifications in early
    2015.  If you're a member of the UEFI Forum, information about its
    addition to the standard is available as UEFI Mantis 1090.
    
    For some hardware platforms, additional restrictions may be found at
    http://msdn.microsoft.com/en-us/library/windows/hardware/jj128256.aspx ,
    and additional documentation may be found at
    http://download.microsoft.com/download/5/F/5/5F5D16CD-2530-4289-8019-94C6A20BED3C/windows-uefi-firmware-update-platform.docx
    .
    
    Signed-off-by: Peter Jones <pjones@redhat.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index af5be0368dec..024c27e7c0fa 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -583,6 +583,9 @@ void efi_native_runtime_setup(void);
 #define EFI_FILE_INFO_ID \
     EFI_GUID(  0x9576e92, 0x6d3f, 0x11d2, 0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b )
 
+#define EFI_SYSTEM_RESOURCE_TABLE_GUID \
+    EFI_GUID(  0xb122a263, 0x3661, 0x4f68, 0x99, 0x29, 0x78, 0xf8, 0xb0, 0xd6, 0x21, 0x80 )
+
 #define EFI_FILE_SYSTEM_GUID \
     EFI_GUID(  0x964e5b22, 0x6459, 0x11d2, 0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b )
 
@@ -823,6 +826,7 @@ extern struct efi {
 	unsigned long fw_vendor;	/* fw_vendor */
 	unsigned long runtime;		/* runtime table */
 	unsigned long config_table;	/* config tables */
+	unsigned long esrt;		/* ESRT table */
 	efi_get_time_t *get_time;
 	efi_set_time_t *set_time;
 	efi_get_wakeup_time_t *get_wakeup_time;
@@ -875,6 +879,7 @@ static inline efi_status_t efi_query_variable_store(u32 attributes, unsigned lon
 #endif
 extern void __iomem *efi_lookup_mapped_addr(u64 phys_addr);
 extern int efi_config_init(efi_config_table_type_t *arch_tables);
+extern void __init efi_esrt_init(void);
 extern int efi_config_parse_tables(void *config_tables, int count, int sz,
 				   efi_config_table_type_t *arch_tables);
 extern u64 efi_get_iobase (void);
@@ -882,12 +887,15 @@ extern u32 efi_mem_type (unsigned long phys_addr);
 extern u64 efi_mem_attributes (unsigned long phys_addr);
 extern u64 efi_mem_attribute (unsigned long phys_addr, unsigned long size);
 extern int __init efi_uart_console_only (void);
+extern u64 efi_mem_desc_end(efi_memory_desc_t *md);
+extern int efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md);
 extern void efi_initialize_iomem_resources(struct resource *code_resource,
 		struct resource *data_resource, struct resource *bss_resource);
 extern void efi_get_time(struct timespec *now);
 extern void efi_reserve_boot_services(void);
 extern int efi_get_fdt_params(struct efi_fdt_params *params, int verbose);
 extern struct efi_memory_map memmap;
+extern struct kobject *efi_kobj;
 
 extern int efi_reboot_quirk_mode;
 extern bool efi_poweroff_required(void);

commit fed6cefe3b6e862dcc74d07324478caa07e84eaf
Author: Borislav Petkov <bp@suse.de>
Date:   Thu Feb 5 11:44:41 2015 +0100

    x86/efi: Add a "debug" option to the efi= cmdline
    
    ... and hide the memory regions dump behind it. Make it default-off.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Link: http://lkml.kernel.org/r/20141209095843.GA3990@pd.tnic
    Acked-by: Laszlo Ersek <lersek@redhat.com>
    Acked-by: Dave Young <dyoung@redhat.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index cf7e431cbc73..af5be0368dec 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -942,6 +942,7 @@ extern int __init efi_setup_pcdp_console(char *);
 #define EFI_64BIT		5	/* Is the firmware 64-bit? */
 #define EFI_PARAVIRT		6	/* Access is via a paravirt interface */
 #define EFI_ARCH_1		7	/* First arch-specific bit */
+#define EFI_DBG			8	/* Print additional debug info at runtime */
 
 #ifdef CONFIG_EFI
 /*

commit 6b00f7efb5303418c231994c91fb8239f5ada260
Merge: b3d6524ff795 d476d94f180a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 11 18:03:54 2015 -0800

    Merge tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux
    
    Pull arm64 updates from Catalin Marinas:
     "arm64 updates for 3.20:
    
       - reimplementation of the virtual remapping of UEFI Runtime Services
         in a way that is stable across kexec
       - emulation of the "setend" instruction for 32-bit tasks (user
         endianness switching trapped in the kernel, SCTLR_EL1.E0E bit set
         accordingly)
       - compat_sys_call_table implemented in C (from asm) and made it a
         constant array together with sys_call_table
       - export CPU cache information via /sys (like other architectures)
       - DMA API implementation clean-up in preparation for IOMMU support
       - macros clean-up for KVM
       - dropped some unnecessary cache+tlb maintenance
       - CONFIG_ARM64_CPU_SUSPEND clean-up
       - defconfig update (CPU_IDLE)
    
      The EFI changes going via the arm64 tree have been acked by Matt
      Fleming.  There is also a patch adding sys_*stat64 prototypes to
      include/linux/syscalls.h, acked by Andrew Morton"
    
    * tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux: (47 commits)
      arm64: compat: Remove incorrect comment in compat_siginfo
      arm64: Fix section mismatch on alloc_init_p[mu]d()
      arm64: Avoid breakage caused by .altmacro in fpsimd save/restore macros
      arm64: mm: use *_sect to check for section maps
      arm64: drop unnecessary cache+tlb maintenance
      arm64:mm: free the useless initial page table
      arm64: Enable CPU_IDLE in defconfig
      arm64: kernel: remove ARM64_CPU_SUSPEND config option
      arm64: make sys_call_table const
      arm64: Remove asm/syscalls.h
      arm64: Implement the compat_sys_call_table in C
      syscalls: Declare sys_*stat64 prototypes if __ARCH_WANT_(COMPAT_)STAT64
      compat: Declare compat_sys_sigpending and compat_sys_sigprocmask prototypes
      arm64: uapi: expose our struct ucontext to the uapi headers
      smp, ARM64: Kill SMP single function call interrupt
      arm64: Emulate SETEND for AArch32 tasks
      arm64: Consolidate hotplug notifier for instruction emulation
      arm64: Track system support for mixed endian EL0
      arm64: implement generic IOMMU configuration
      arm64: Combine coherent and non-coherent swiotlb dma_ops
      ...

commit 3c01b74e818a7a3b2ee9b0d584cca0bc154a031c
Merge: c59c961ca511 11629305043c
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Jan 29 19:16:40 2015 +0100

    Merge tag 'efi-next' of git://git.kernel.org/pub/scm/linux/kernel/git/mfleming/efi into x86/efi
    
    Pull EFI updates from Matt Fleming:
    
    " - Move efivarfs from the misc filesystem section to pseudo filesystem,
        since that's a more logical and accurate place - Leif Lindholm
    
      - Update efibootmgr URL in Kconfig help - Peter Jones
    
      - Improve accuracy of EFI guid function names - Borislav Petkov
    
      - Expose firmware platform size in sysfs for the benefit of EFI boot
        loader installers and other utilities - Steve McIntyre
    
      - Cleanup __init annotations for arm64/efi code - Ard Biesheuvel
    
      - Mark the UIE as unsupported for rtc-efi - Ard Biesheuvel
    
      - Fix memory leak in error code path of runtime map code - Dan Carpenter
    
      - Improve robustness of get_memory_map() by removing assumptions on the
        size of efi_memory_desc_t (which could change in future spec
        versions) and querying the firmware instead of guessing about the
        memmap size - Ard Biesheuvel
    
      - Remove superfluous guid unparse calls - Ivan Khoronzhuk
    
      - Delete unnecessary chosen@0 DT node FDT code since was duplicated
        from code in drivers/of and is entirely unnecessary - Leif Lindholm
    
       There's nothing super scary, mainly cleanups, and a merge from Ricardo who
       kindly picked up some patches from the linux-efi mailing list while I
       was out on annual leave in December.
    
       Perhaps the biggest risk is the get_memory_map() change from Ard, which
       changes the way that both the arm64 and x86 EFI boot stub build the
       early memory map. It would be good to have it bake in linux-next for a
       while.
    "
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 7bb68410ef22067b08fd52887875b8f337f89dcc
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Sat Oct 18 15:04:15 2014 +0200

    efi: split off remapping code from efi_config_init()
    
    Split of the remapping code from efi_config_init() so that the caller
    can perform its own remapping. This is necessary to correctly handle
    virtually remapped UEFI memory regions under kexec, as efi.systab will
    have been updated to a virtual address.
    
    Acked-by: Matt Fleming <matt.fleming@intel.com>
    Tested-by: Leif Lindholm <leif.lindholm@linaro.org>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 0238d612750e..5ffe5115951f 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -875,6 +875,8 @@ static inline efi_status_t efi_query_variable_store(u32 attributes, unsigned lon
 #endif
 extern void __iomem *efi_lookup_mapped_addr(u64 phys_addr);
 extern int efi_config_init(efi_config_table_type_t *arch_tables);
+extern int efi_config_parse_tables(void *config_tables, int count, int sz,
+				   efi_config_table_type_t *arch_tables);
 extern u64 efi_get_iobase (void);
 extern u32 efi_mem_type (unsigned long phys_addr);
 extern u64 efi_mem_attributes (unsigned long phys_addr);

commit 26e022727f5e88c6e5054e14d954425deacbe56a
Author: Borislav Petkov <bp@suse.de>
Date:   Thu Dec 18 16:02:17 2014 +0100

    efi: Rename efi_guid_unparse to efi_guid_to_str
    
    Call it what it does - "unparse" is plain-misleading.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 0949f9c7e872..d762c81e62a8 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -844,7 +844,7 @@ efi_guidcmp (efi_guid_t left, efi_guid_t right)
 }
 
 static inline char *
-efi_guid_unparse(efi_guid_t *guid, char *out)
+efi_guid_to_str(efi_guid_t *guid, char *out)
 {
 	sprintf(out, "%pUl", guid->b);
         return out;

commit e1ccbbc9d5aa01a6c1c9c78acea6515db4f1be71
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Oct 14 16:34:47 2014 +0200

    efi: dmi: add support for SMBIOS 3.0 UEFI configuration table
    
    This adds support to the UEFI side for detecting the presence of
    a SMBIOS 3.0 64-bit entry point. This allows the actual SMBIOS
    structure table to reside at a physical offset over 4 GB, which
    cannot be supported by the legacy SMBIOS 32-bit entry point.
    
    Since the firmware can legally provide both entry points, store
    the SMBIOS 3.0 entry point in a separate variable, and let the
    DMI decoding layer decide which one will be used.
    
    Tested-by: Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
    Acked-by: Leif Lindholm <leif.lindholm@linaro.org>
    Acked-by: Matt Fleming <matt.fleming@intel.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 0949f9c7e872..0238d612750e 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -547,6 +547,9 @@ void efi_native_runtime_setup(void);
 #define SMBIOS_TABLE_GUID    \
     EFI_GUID(  0xeb9d2d31, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d )
 
+#define SMBIOS3_TABLE_GUID    \
+    EFI_GUID(  0xf2fd1544, 0x9794, 0x4a2c, 0x99, 0x2e, 0xe5, 0xbb, 0xcf, 0x20, 0xe3, 0x94 )
+
 #define SAL_SYSTEM_TABLE_GUID    \
     EFI_GUID(  0xeb9d2d32, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d )
 
@@ -810,7 +813,8 @@ extern struct efi {
 	unsigned long mps;		/* MPS table */
 	unsigned long acpi;		/* ACPI table  (IA64 ext 0.71) */
 	unsigned long acpi20;		/* ACPI table  (ACPI 2.0) */
-	unsigned long smbios;		/* SM BIOS table */
+	unsigned long smbios;		/* SMBIOS table (32 bit entry point) */
+	unsigned long smbios3;		/* SMBIOS table (64 bit entry point) */
 	unsigned long sal_systab;	/* SAL system table */
 	unsigned long boot_info;	/* boot info table */
 	unsigned long hcdp;		/* HCDP table */

commit 6d80dba1c9fe4316ef626980102b92fa30c7845a
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Tue Sep 30 21:58:52 2014 +0100

    efi: Provide a non-blocking SetVariable() operation
    
    There are some circumstances that call for trying to write an EFI
    variable in a non-blocking way. One such scenario is when writing pstore
    data in efi_pstore_write() via the pstore_dump() kdump callback.
    
    Now that we have an EFI runtime spinlock we need a way of aborting if
    there is contention instead of spinning, since when writing pstore data
    from the kdump callback, the runtime lock may already be held by the CPU
    that's running the callback if we crashed in the middle of an EFI
    variable operation.
    
    The situation is sufficiently special that a new EFI variable operation
    is warranted.
    
    Introduce ->set_variable_nonblocking() for this use case. It is an
    optional EFI backend operation, and need only be implemented by those
    backends that usually acquire locks to serialize access to EFI
    variables, as is the case for virt_efi_set_variable() where we now grab
    the EFI runtime spinlock.
    
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 78b29b133e14..0949f9c7e872 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -503,6 +503,10 @@ typedef efi_status_t efi_get_next_variable_t (unsigned long *name_size, efi_char
 typedef efi_status_t efi_set_variable_t (efi_char16_t *name, efi_guid_t *vendor, 
 					 u32 attr, unsigned long data_size,
 					 void *data);
+typedef efi_status_t
+efi_set_variable_nonblocking_t(efi_char16_t *name, efi_guid_t *vendor,
+			       u32 attr, unsigned long data_size, void *data);
+
 typedef efi_status_t efi_get_next_high_mono_count_t (u32 *count);
 typedef void efi_reset_system_t (int reset_type, efi_status_t status,
 				 unsigned long data_size, efi_char16_t *data);
@@ -822,6 +826,7 @@ extern struct efi {
 	efi_get_variable_t *get_variable;
 	efi_get_next_variable_t *get_next_variable;
 	efi_set_variable_t *set_variable;
+	efi_set_variable_nonblocking_t *set_variable_nonblocking;
 	efi_query_variable_info_t *query_variable_info;
 	efi_update_capsule_t *update_capsule;
 	efi_query_capsule_caps_t *query_capsule_caps;
@@ -1042,6 +1047,7 @@ struct efivar_operations {
 	efi_get_variable_t *get_variable;
 	efi_get_next_variable_t *get_next_variable;
 	efi_set_variable_t *set_variable;
+	efi_set_variable_nonblocking_t *set_variable_nonblocking;
 	efi_query_variable_store_t *query_variable_store;
 };
 

commit 98d2a6ca14520904a47c46258d3bad02ffcd3f96
Author: Laszlo Ersek <lersek@redhat.com>
Date:   Wed Sep 3 13:32:20 2014 +0200

    efi: Introduce efi_md_typeattr_format()
    
    At the moment, there are three architectures debug-printing the EFI memory
    map at initialization: x86, ia64, and arm64. They all use different format
    strings, plus the EFI memory type and the EFI memory attributes are
    similarly hard to decode for a human reader.
    
    Introduce a helper __init function that formats the memory type and the
    memory attributes in a unified way, to a user-provided character buffer.
    
    The array "memory_type_name" is copied from the arm64 code, temporarily
    duplicating it. The (otherwise optional) braces around each string literal
    in the initializer list are dropped in order to match the kernel coding
    style more closely. The element size is tightened from 32 to 20 bytes
    (maximum actual string length + 1) so that we can derive the field width
    from the element size.
    
    Signed-off-by: Laszlo Ersek <lersek@redhat.com>
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    [ Dropped useless 'register' keyword, which compiler will ignore ]
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 7464032ae00a..78b29b133e14 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -887,6 +887,13 @@ extern bool efi_poweroff_required(void);
 	     (md) <= (efi_memory_desc_t *)((m)->map_end - (m)->desc_size); \
 	     (md) = (void *)(md) + (m)->desc_size)
 
+/*
+ * Format an EFI memory descriptor's type and attributes to a user-provided
+ * character buffer, as per snprintf(), and return the buffer.
+ */
+char * __init efi_md_typeattr_format(char *buf, size_t size,
+				     const efi_memory_desc_t *md);
+
 /**
  * efi_range_is_wc - check the WC bit on an address range
  * @start: starting kvirt address

commit 9c97e0bdd4b4ae44577a1b1ec949e782084e9a78
Author: Laszlo Ersek <lersek@redhat.com>
Date:   Wed Sep 3 13:32:19 2014 +0200

    efi: Add macro for EFI_MEMORY_UCE memory attribute
    
    Add the following macro from the UEFI spec, for completeness:
    
      EFI_MEMORY_UCE  Memory cacheability attribute: The memory region
                      supports being configured as not cacheable, exported,
                      and supports the "fetch and add" semaphore mechanism.
    
    Signed-off-by: Laszlo Ersek <lersek@redhat.com>
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 4812ed0b0374..7464032ae00a 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -92,6 +92,7 @@ typedef	struct {
 #define EFI_MEMORY_WC		((u64)0x0000000000000002ULL)	/* write-coalescing */
 #define EFI_MEMORY_WT		((u64)0x0000000000000004ULL)	/* write-through */
 #define EFI_MEMORY_WB		((u64)0x0000000000000008ULL)	/* write-back */
+#define EFI_MEMORY_UCE		((u64)0x0000000000000010ULL)	/* uncached, exported */
 #define EFI_MEMORY_WP		((u64)0x0000000000001000ULL)	/* write-protect */
 #define EFI_MEMORY_RP		((u64)0x0000000000002000ULL)	/* read-protect */
 #define EFI_MEMORY_XP		((u64)0x0000000000004000ULL)	/* execute-protect */

commit b2e0a54a1296a91b800f316df7bef7d1905e4fd0
Author: Dave Young <dyoung@redhat.com>
Date:   Thu Aug 14 17:15:26 2014 +0800

    efi: Move noefi early param code out of x86 arch code
    
    noefi param can be used for arches other than X86 later, thus move it
    out of x86 platform code.
    
    Signed-off-by: Dave Young <dyoung@redhat.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 518779fb5e90..4812ed0b0374 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1229,4 +1229,5 @@ efi_status_t handle_cmdline_files(efi_system_table_t *sys_table_arg,
 
 efi_status_t efi_parse_options(char *cmdline);
 
+bool efi_runtime_disabled(void);
 #endif /* _LINUX_EFI_H */

commit 5a17dae422d7de4b776a9753cd4673a343a25b4b
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Tue Aug 5 11:52:11 2014 +0100

    efi: Add efi= parameter parsing to the EFI boot stub
    
    We need a way to customize the behaviour of the EFI boot stub, in
    particular, we need a way to disable the "chunking" workaround, used
    when reading files from the EFI System Partition.
    
    One of my machines doesn't cope well when reading files in 1MB chunks to
    a buffer above the 4GB mark - it appears that the "chunking" bug
    workaround triggers another firmware bug. This was only discovered with
    commit 4bf7111f5016 ("x86/efi: Support initrd loaded above 4G"), and
    that commit is perfectly valid. The symptom I observed was a corrupt
    initrd rather than any kind of crash.
    
    efi= is now used to specify EFI parameters in two very different
    execution environments, the EFI boot stub and during kernel boot.
    
    There is also a slight performance optimization by enabling efi=nochunk,
    but that's offset by the fact that you're more likely to run into
    firmware issues, at least on x86. This is the rationale behind leaving
    the workaround enabled by default.
    
    Also provide some documentation for EFI_READ_CHUNK_SIZE and why we're
    using the current value of 1MB.
    
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Roy Franz <roy.franz@linaro.org>
    Cc: Maarten Lankhorst <m.b.lankhorst@gmail.com>
    Cc: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: Borislav Petkov <bp@suse.de>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 45cb4ffdea62..518779fb5e90 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1227,4 +1227,6 @@ efi_status_t handle_cmdline_files(efi_system_table_t *sys_table_arg,
 				  unsigned long *load_addr,
 				  unsigned long *load_size);
 
+efi_status_t efi_parse_options(char *cmdline);
+
 #endif /* _LINUX_EFI_H */

commit 6a2c20e7d8900ed273dc34a9af9bf02fc478e427
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri Aug 8 14:26:11 2014 -0700

    kexec: support kexec/kdump on EFI systems
    
    This patch does two things.  It passes EFI run time mappings to second
    kernel in bootparams efi_info.  Second kernel parse this info and create
    new mappings in second kernel.  That means mappings in first and second
    kernel will be same.  This paves the way to enable EFI in kexec kernel.
    
    This patch also prepares and passes EFI setup data through bootparams.
    This contains bunch of information about various tables and their
    addresses.
    
    These information gathering and passing has been written along the lines
    of what current kexec-tools is doing to make kexec work with UEFI.
    
    [akpm@linux-foundation.org: s/get_efi/efi_get/g, per Matt]
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Eric Biederman <ebiederm@xmission.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Greg Kroah-Hartman <greg@kroah.com>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: WANG Chao <chaowang@redhat.com>
    Cc: Baoquan He <bhe@redhat.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Matt Fleming <matt@console-pimps.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index efc681fd5895..45cb4ffdea62 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1156,6 +1156,9 @@ int efivars_sysfs_init(void);
 #ifdef CONFIG_EFI_RUNTIME_MAP
 int efi_runtime_map_init(struct kobject *);
 void efi_runtime_map_setup(void *, int, u32);
+int efi_get_runtime_map_size(void);
+int efi_get_runtime_map_desc_size(void);
+int efi_runtime_map_copy(void *buf, size_t bufsz);
 #else
 static inline int efi_runtime_map_init(struct kobject *kobj)
 {
@@ -1164,6 +1167,22 @@ static inline int efi_runtime_map_init(struct kobject *kobj)
 
 static inline void
 efi_runtime_map_setup(void *map, int nr_entries, u32 desc_size) {}
+
+static inline int efi_get_runtime_map_size(void)
+{
+	return 0;
+}
+
+static inline int efi_get_runtime_map_desc_size(void)
+{
+	return 0;
+}
+
+static inline int efi_runtime_map_copy(void *buf, size_t bufsz)
+{
+	return 0;
+}
+
 #endif
 
 /* prototypes shared between arch specific and generic stub code */

commit 82f990a82244f8dfeb7e776186dc4811eb651ed7
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Tue Jul 8 12:28:33 2014 +0100

    efi: Update stale locking comment for struct efivars
    
    The comment describing how struct efivars->lock is used hasn't been
    updated in sync with the code. Fix it.
    
    Reported-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Mike Waychison <mikew@google.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 59c8acfebca7..efc681fd5895 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1040,12 +1040,8 @@ struct efivar_operations {
 struct efivars {
 	/*
 	 * ->lock protects two things:
-	 * 1) ->list - adds, removals, reads, writes
-	 * 2) ops.[gs]et_variable() calls.
-	 * It must not be held when creating sysfs entries or calling kmalloc.
-	 * ops.get_next_variable() is only called from register_efivars()
-	 * or efivar_update_sysfs_entries(),
-	 * which is protected by the BKL, so that path is safe.
+	 * 1) efivarfs_list and efivars_sysfs_list
+	 * 2) ->ops calls
 	 */
 	spinlock_t lock;
 	struct kset *kset;

commit f383d00a0d1f94a7d60c753ec8e3e402889f9622
Author: Daniel Kiper <daniel.kiper@oracle.com>
Date:   Mon Jun 30 19:53:04 2014 +0200

    arch/x86: Remove efi_set_rtc_mmss()
    
    efi_set_rtc_mmss() is never used to set RTC due to bugs found
    on many EFI platforms. It is set directly by mach_set_rtc_mmss().
    Hence, remove unused efi_set_rtc_mmss() function.
    
    Signed-off-by: Daniel Kiper <daniel.kiper@oracle.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index c7a29a26e900..59c8acfebca7 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -873,7 +873,6 @@ extern int __init efi_uart_console_only (void);
 extern void efi_initialize_iomem_resources(struct resource *code_resource,
 		struct resource *data_resource, struct resource *bss_resource);
 extern void efi_get_time(struct timespec *now);
-extern int efi_set_rtc_mmss(const struct timespec *now);
 extern void efi_reserve_boot_services(void);
 extern int efi_get_fdt_params(struct efi_fdt_params *params, int verbose);
 extern struct efi_memory_map memmap;

commit 9f27bc543bdf92e179927037e2ab8ed0261579a9
Author: Daniel Kiper <daniel.kiper@oracle.com>
Date:   Mon Jun 30 19:52:58 2014 +0200

    efi: Introduce EFI_PARAVIRT flag
    
    Introduce EFI_PARAVIRT flag. If it is set then kernel runs
    on EFI platform but it has not direct control on EFI stuff
    like EFI runtime, tables, structures, etc. If not this means
    that Linux Kernel has direct access to EFI infrastructure
    and everything runs as usual.
    
    This functionality is used in Xen dom0 because hypervisor
    has full control on EFI stuff and all calls from dom0 to
    EFI must be requested via special hypercall which in turn
    executes relevant EFI code in behalf of dom0.
    
    Signed-off-by: Daniel Kiper <daniel.kiper@oracle.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index bac0f93dc473..c7a29a26e900 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -922,7 +922,8 @@ extern int __init efi_setup_pcdp_console(char *);
 #define EFI_RUNTIME_SERVICES	3	/* Can we use runtime services? */
 #define EFI_MEMMAP		4	/* Can we use EFI memory map? */
 #define EFI_64BIT		5	/* Is the firmware 64-bit? */
-#define EFI_ARCH_1		6	/* First arch-specific bit */
+#define EFI_PARAVIRT		6	/* Access is via a paravirt interface */
+#define EFI_ARCH_1		7	/* First arch-specific bit */
 
 #ifdef CONFIG_EFI
 /*

commit 44be28e9dd9880dca3e2cbf7a844f2114e67f2cb
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Fri Jun 13 12:39:55 2014 +0100

    x86/reboot: Add EFI reboot quirk for ACPI Hardware Reduced flag
    
    It appears that the BayTrail-T class of hardware requires EFI in order
    to powerdown and reboot and no other reliable method exists.
    
    This quirk is generally applicable to all hardware that has the ACPI
    Hardware Reduced bit set, since usually ACPI would be the preferred
    method.
    
    Cc: Len Brown <len.brown@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 9917f58ee83e..bac0f93dc473 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -878,6 +878,7 @@ extern void efi_reserve_boot_services(void);
 extern int efi_get_fdt_params(struct efi_fdt_params *params, int verbose);
 extern struct efi_memory_map memmap;
 
+extern int efi_reboot_quirk_mode;
 extern bool efi_poweroff_required(void);
 
 /* Iterate through an efi_memory_map */

commit 0c5ed61adbdbf2ca5de934642d5be1e971c498c1
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Fri Jun 13 12:35:21 2014 +0100

    efi/reboot: Allow powering off machines using EFI
    
    Not only can EfiResetSystem() be used to reboot, it can also be used to
    power down machines.
    
    By and large, this functionality doesn't work very well across the range
    of EFI machines in the wild, so it should definitely only be used as a
    last resort. In an ideal world, this wouldn't be needed at all.
    
    Unfortunately, we're starting to see machines where EFI is the *only*
    reliable way to power down, and nothing else, not PCI, not ACPI, works.
    
    efi_poweroff_required() should be implemented on a per-architecture
    basis, since exactly when we should be using EFI runtime services is a
    platform-specific decision. There's no analogue for reboot because each
    architecture handles reboot very differently - the x86 code in
    particular is pretty complex.
    
    Patches to enable this for specific classes of hardware will be
    submitted separately.
    
    Tested-by: Mark Salter <msalter@redhat.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index e6980ba528ec..9917f58ee83e 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -878,6 +878,8 @@ extern void efi_reserve_boot_services(void);
 extern int efi_get_fdt_params(struct efi_fdt_params *params, int verbose);
 extern struct efi_memory_map memmap;
 
+extern bool efi_poweroff_required(void);
+
 /* Iterate through an efi_memory_map */
 #define for_each_efi_memory_desc(m, md)					   \
 	for ((md) = (m)->map;						   \

commit 8562c99cdd30217dea3609e268572f8764f401a5
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Fri Jun 13 12:22:22 2014 +0100

    efi/reboot: Add generic wrapper around EfiResetSystem()
    
    Implement efi_reboot(), which is really just a wrapper around the
    EfiResetSystem() EFI runtime service, but it does at least allow us to
    funnel all callers through a single location.
    
    It also simplifies the callsites since users no longer need to check to
    see whether EFI_RUNTIME_SERVICES are enabled.
    
    Cc: Tony Luck <tony.luck@intel.com>
    Tested-by: Mark Salter <msalter@redhat.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 3a64f2f85821..e6980ba528ec 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -20,6 +20,7 @@
 #include <linux/ioport.h>
 #include <linux/pfn.h>
 #include <linux/pstore.h>
+#include <linux/reboot.h>
 
 #include <asm/page.h>
 
@@ -928,11 +929,14 @@ static inline bool efi_enabled(int feature)
 {
 	return test_bit(feature, &efi.flags) != 0;
 }
+extern void efi_reboot(enum reboot_mode reboot_mode, const char *__unused);
 #else
 static inline bool efi_enabled(int feature)
 {
 	return false;
 }
+static inline void
+efi_reboot(enum reboot_mode reboot_mode, const char *__unused) {}
 #endif
 
 /*

commit bd669475d14e3279a7f96ed917a82df5da6ad52d
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Jul 2 14:54:42 2014 +0200

    efi: efistub: Refactor stub components
    
    In order to move from the #include "../../../xxxxx.c" anti-pattern used
    by both the x86 and arm64 versions of the stub to a static library
    linked into either the kernel proper (arm64) or a separate boot
    executable (x86), there is some prepatory work required.
    
    This patch does the following:
    - move forward declarations of functions shared between the arch
      specific and the generic parts of the stub to include/linux/efi.h
    - move forward declarations of functions shared between various .c files
      of the generic stub code to a new local header file called "efistub.h"
    - add #includes to all .c files which were formerly relying on the
      #includor to include the correct header files
    - remove all static modifiers from functions which will need to be
      externally visible once we move to a static library
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 0ceb816bdfc2..3a64f2f85821 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1163,4 +1163,46 @@ static inline void
 efi_runtime_map_setup(void *map, int nr_entries, u32 desc_size) {}
 #endif
 
+/* prototypes shared between arch specific and generic stub code */
+
+#define pr_efi(sys_table, msg)     efi_printk(sys_table, "EFI stub: "msg)
+#define pr_efi_err(sys_table, msg) efi_printk(sys_table, "EFI stub: ERROR: "msg)
+
+void efi_printk(efi_system_table_t *sys_table_arg, char *str);
+
+void efi_free(efi_system_table_t *sys_table_arg, unsigned long size,
+	      unsigned long addr);
+
+char *efi_convert_cmdline(efi_system_table_t *sys_table_arg,
+			  efi_loaded_image_t *image, int *cmd_line_len);
+
+efi_status_t efi_get_memory_map(efi_system_table_t *sys_table_arg,
+				efi_memory_desc_t **map,
+				unsigned long *map_size,
+				unsigned long *desc_size,
+				u32 *desc_ver,
+				unsigned long *key_ptr);
+
+efi_status_t efi_low_alloc(efi_system_table_t *sys_table_arg,
+			   unsigned long size, unsigned long align,
+			   unsigned long *addr);
+
+efi_status_t efi_high_alloc(efi_system_table_t *sys_table_arg,
+			    unsigned long size, unsigned long align,
+			    unsigned long *addr, unsigned long max);
+
+efi_status_t efi_relocate_kernel(efi_system_table_t *sys_table_arg,
+				 unsigned long *image_addr,
+				 unsigned long image_size,
+				 unsigned long alloc_size,
+				 unsigned long preferred_addr,
+				 unsigned long alignment);
+
+efi_status_t handle_cmdline_files(efi_system_table_t *sys_table_arg,
+				  efi_loaded_image_t *image,
+				  char *cmd_line, char *option_string,
+				  unsigned long max_addr,
+				  unsigned long *load_addr,
+				  unsigned long *load_size);
+
 #endif /* _LINUX_EFI_H */

commit 022ee6c558fc933679e151f00f84332974147fa2
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Thu Jun 26 12:09:05 2014 +0200

    efi/x86: Move UEFI Runtime Services wrappers to generic code
    
    In order for other archs (such as arm64) to be able to reuse the virtual
    mode function call wrappers, move them to drivers/firmware/efi/runtime-wrappers.c.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 41bbf8ba4ba8..0ceb816bdfc2 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -521,6 +521,8 @@ typedef efi_status_t efi_query_capsule_caps_t(efi_capsule_header_t **capsules,
 					      int *reset_type);
 typedef efi_status_t efi_query_variable_store_t(u32 attributes, unsigned long size);
 
+void efi_native_runtime_setup(void);
+
 /*
  *  EFI Configuration Table and GUID definitions
  */

commit 263b4a30bfdb0d756ae9c70c6ff2eef1eb951770
Author: Roy Franz <roy.franz@linaro.org>
Date:   Wed Jan 8 17:54:19 2014 -0800

    efi: Add shared FDT related functions for ARM/ARM64
    
    Both ARM and ARM64 stubs will update the device tree that they pass to
    the kernel.  In both cases they primarily need to add the same UEFI
    related information, so the function can be shared.  Create a new FDT
    related file for this to avoid use of architecture #ifdefs in
    efi-stub-helper.c.
    
    Signed-off-by: Roy Franz <roy.franz@linaro.org>
    [ Fixed memory node deletion code. ]
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Leif Lindholm <leif.lindholm@linaro.org>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index cd0172e796cb..41bbf8ba4ba8 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -575,6 +575,9 @@ typedef efi_status_t efi_query_variable_store_t(u32 attributes, unsigned long si
 #define EFI_FILE_SYSTEM_GUID \
     EFI_GUID(  0x964e5b22, 0x6459, 0x11d2, 0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b )
 
+#define DEVICE_TREE_GUID \
+    EFI_GUID(  0xb1b621d5, 0xf19c, 0x41a5, 0x83, 0x0b, 0xd9, 0x15, 0x2c, 0x69, 0xaa, 0xe0 )
+
 typedef struct {
 	efi_guid_t guid;
 	u64 table;

commit 0302f71c0aa59571ac306f93068fbbfe65ea349b
Author: Mark Salter <msalter@redhat.com>
Date:   Mon Dec 30 12:12:12 2013 -0500

    efi: add helper function to get UEFI params from FDT
    
    ARM and ARM64 architectures use the device tree to pass UEFI parameters
    from stub to kernel. These parameters are things known to the stub but
    not discoverable by the kernel after the stub calls ExitBootSerives().
    There is a helper function in:
    
       drivers/firmware/efi/fdt.c
    
    which the stub uses to add the UEFI parameters to the device tree.
    This patch adds a complimentary helper function which UEFI runtime
    support may use to retrieve the parameters from the device tree.
    If an architecture wants to use this helper, it should select
    CONFIG_EFI_PARAMS_FROM_FDT.
    
    Signed-off-by: Mark Salter <msalter@redhat.com>
    Signed-off-by: Leif Lindholm <leif.lindholm@linaro.org>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 6a4d8e27d1d7..cd0172e796cb 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -664,6 +664,14 @@ struct efi_memory_map {
 	unsigned long desc_size;
 };
 
+struct efi_fdt_params {
+	u64 system_table;
+	u64 mmap;
+	u32 mmap_size;
+	u32 desc_size;
+	u32 desc_ver;
+};
+
 typedef struct {
 	u32 revision;
 	u32 parent_handle;
@@ -861,6 +869,7 @@ extern void efi_initialize_iomem_resources(struct resource *code_resource,
 extern void efi_get_time(struct timespec *now);
 extern int efi_set_rtc_mmss(const struct timespec *now);
 extern void efi_reserve_boot_services(void);
+extern int efi_get_fdt_params(struct efi_fdt_params *params, int verbose);
 extern struct efi_memory_map memmap;
 
 /* Iterate through an efi_memory_map */

commit a5d92ad32dad94fd8f3f61778561d532bb3a2f77
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Mon Mar 17 10:57:00 2014 +0000

    efivars: Stop passing a struct argument to efivar_validate()
    
    In preparation for compat support, we can't assume that user variable
    object is represented by a 'struct efi_variable'. Convert the validation
    functions to take the variable name as an argument, which is the only
    piece of the struct that was ever used anyway.
    
    Cc: Mike Waychison <mikew@google.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 82d0abb2b19f..6a4d8e27d1d7 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1039,8 +1039,10 @@ struct efivars {
  * and we use a page for reading/writing.
  */
 
+#define EFI_VAR_NAME_LEN	1024
+
 struct efi_variable {
-	efi_char16_t  VariableName[1024/sizeof(efi_char16_t)];
+	efi_char16_t  VariableName[EFI_VAR_NAME_LEN/sizeof(efi_char16_t)];
 	efi_guid_t    VendorGuid;
 	unsigned long DataSize;
 	__u8          Data[1024];
@@ -1122,7 +1124,7 @@ int efivar_entry_iter(int (*func)(struct efivar_entry *, void *),
 struct efivar_entry *efivar_entry_find(efi_char16_t *name, efi_guid_t guid,
 				       struct list_head *head, bool remove);
 
-bool efivar_validate(struct efi_variable *var, u8 *data, unsigned long len);
+bool efivar_validate(efi_char16_t *var_name, u8 *data, unsigned long len);
 
 extern struct work_struct efivar_work;
 void efivar_run_worker(void);

commit e885cd805fc6e65ef5150a211c7bac02f925af04
Author: Mark Salter <msalter@redhat.com>
Date:   Fri Jan 10 14:26:06 2014 -0500

    efi: create memory map iteration helper
    
    There are a lot of places in the kernel which iterate through an
    EFI memory map. Most of these places use essentially the same
    for-loop code. This patch adds a for_each_efi_memory_desc()
    helper to clean up all of the existing duplicate code and avoid
    more in the future.
    
    Signed-off-by: Mark Salter <msalter@redhat.com>
    Signed-off-by: Leif Lindholm <leif.lindholm@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 6c100ff0cae4..82d0abb2b19f 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -863,6 +863,12 @@ extern int efi_set_rtc_mmss(const struct timespec *now);
 extern void efi_reserve_boot_services(void);
 extern struct efi_memory_map memmap;
 
+/* Iterate through an efi_memory_map */
+#define for_each_efi_memory_desc(m, md)					   \
+	for ((md) = (m)->map;						   \
+	     (md) <= (efi_memory_desc_t *)((m)->map_end - (m)->desc_size); \
+	     (md) = (void *)(md) + (m)->desc_size)
+
 /**
  * efi_range_is_wc - check the WC bit on an address range
  * @start: starting kvirt address

commit 994448f1afa6689bafbebaf7412b23b541b41ef5
Merge: 4fd69331ad22 18c46461d9e4
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Wed Mar 5 18:15:37 2014 +0000

    Merge remote-tracking branch 'tip/x86/efi-mixed' into efi-for-mingo
    
    Conflicts:
            arch/x86/kernel/setup.c
            arch/x86/platform/efi/efi.c
            arch/x86/platform/efi/efi_64.c

commit 677703cef0a148ba07d37ced649ad25b1cda2f78
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Fri Jan 10 13:47:37 2014 +0000

    efi: Add separate 32-bit/64-bit definitions
    
    The traditional approach of using machine-specific types such as
    'unsigned long' does not allow the kernel to interact with firmware
    running in a different CPU mode, e.g. 64-bit kernel with 32-bit EFI.
    
    Add distinct EFI structure definitions for both 32-bit and 64-bit so
    that we can use them in the 32-bit and 64-bit code paths.
    
    Acked-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 0a819e7a60c9..42c662729e13 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -153,6 +153,102 @@ typedef struct {
 	u8 sets_to_zero;
 } efi_time_cap_t;
 
+typedef struct {
+	efi_table_hdr_t hdr;
+	u32 raise_tpl;
+	u32 restore_tpl;
+	u32 allocate_pages;
+	u32 free_pages;
+	u32 get_memory_map;
+	u32 allocate_pool;
+	u32 free_pool;
+	u32 create_event;
+	u32 set_timer;
+	u32 wait_for_event;
+	u32 signal_event;
+	u32 close_event;
+	u32 check_event;
+	u32 install_protocol_interface;
+	u32 reinstall_protocol_interface;
+	u32 uninstall_protocol_interface;
+	u32 handle_protocol;
+	u32 __reserved;
+	u32 register_protocol_notify;
+	u32 locate_handle;
+	u32 locate_device_path;
+	u32 install_configuration_table;
+	u32 load_image;
+	u32 start_image;
+	u32 exit;
+	u32 unload_image;
+	u32 exit_boot_services;
+	u32 get_next_monotonic_count;
+	u32 stall;
+	u32 set_watchdog_timer;
+	u32 connect_controller;
+	u32 disconnect_controller;
+	u32 open_protocol;
+	u32 close_protocol;
+	u32 open_protocol_information;
+	u32 protocols_per_handle;
+	u32 locate_handle_buffer;
+	u32 locate_protocol;
+	u32 install_multiple_protocol_interfaces;
+	u32 uninstall_multiple_protocol_interfaces;
+	u32 calculate_crc32;
+	u32 copy_mem;
+	u32 set_mem;
+	u32 create_event_ex;
+} __packed efi_boot_services_32_t;
+
+typedef struct {
+	efi_table_hdr_t hdr;
+	u64 raise_tpl;
+	u64 restore_tpl;
+	u64 allocate_pages;
+	u64 free_pages;
+	u64 get_memory_map;
+	u64 allocate_pool;
+	u64 free_pool;
+	u64 create_event;
+	u64 set_timer;
+	u64 wait_for_event;
+	u64 signal_event;
+	u64 close_event;
+	u64 check_event;
+	u64 install_protocol_interface;
+	u64 reinstall_protocol_interface;
+	u64 uninstall_protocol_interface;
+	u64 handle_protocol;
+	u64 __reserved;
+	u64 register_protocol_notify;
+	u64 locate_handle;
+	u64 locate_device_path;
+	u64 install_configuration_table;
+	u64 load_image;
+	u64 start_image;
+	u64 exit;
+	u64 unload_image;
+	u64 exit_boot_services;
+	u64 get_next_monotonic_count;
+	u64 stall;
+	u64 set_watchdog_timer;
+	u64 connect_controller;
+	u64 disconnect_controller;
+	u64 open_protocol;
+	u64 close_protocol;
+	u64 open_protocol_information;
+	u64 protocols_per_handle;
+	u64 locate_handle_buffer;
+	u64 locate_protocol;
+	u64 install_multiple_protocol_interfaces;
+	u64 uninstall_multiple_protocol_interfaces;
+	u64 calculate_crc32;
+	u64 copy_mem;
+	u64 set_mem;
+	u64 create_event_ex;
+} __packed efi_boot_services_64_t;
+
 /*
  * EFI Boot Services table
  */
@@ -231,12 +327,61 @@ typedef enum {
     EfiPciIoAttributeOperationMaximum
 } EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION;
 
+typedef struct {
+	u32 read;
+	u32 write;
+} efi_pci_io_protocol_access_32_t;
+
+typedef struct {
+	u64 read;
+	u64 write;
+} efi_pci_io_protocol_access_64_t;
 
 typedef struct {
 	void *read;
 	void *write;
 } efi_pci_io_protocol_access_t;
 
+typedef struct {
+	u32 poll_mem;
+	u32 poll_io;
+	efi_pci_io_protocol_access_32_t mem;
+	efi_pci_io_protocol_access_32_t io;
+	efi_pci_io_protocol_access_32_t pci;
+	u32 copy_mem;
+	u32 map;
+	u32 unmap;
+	u32 allocate_buffer;
+	u32 free_buffer;
+	u32 flush;
+	u32 get_location;
+	u32 attributes;
+	u32 get_bar_attributes;
+	u32 set_bar_attributes;
+	uint64_t romsize;
+	void *romimage;
+} efi_pci_io_protocol_32;
+
+typedef struct {
+	u64 poll_mem;
+	u64 poll_io;
+	efi_pci_io_protocol_access_64_t mem;
+	efi_pci_io_protocol_access_64_t io;
+	efi_pci_io_protocol_access_64_t pci;
+	u64 copy_mem;
+	u64 map;
+	u64 unmap;
+	u64 allocate_buffer;
+	u64 free_buffer;
+	u64 flush;
+	u64 get_location;
+	u64 attributes;
+	u64 get_bar_attributes;
+	u64 set_bar_attributes;
+	uint64_t romsize;
+	void *romimage;
+} efi_pci_io_protocol_64;
+
 typedef struct {
 	void *poll_mem;
 	void *poll_io;
@@ -290,6 +435,42 @@ typedef struct {
 #define EFI_RUNTIME_SERVICES_SIGNATURE ((u64)0x5652453544e5552ULL)
 #define EFI_RUNTIME_SERVICES_REVISION  0x00010000
 
+typedef struct {
+	efi_table_hdr_t hdr;
+	u32 get_time;
+	u32 set_time;
+	u32 get_wakeup_time;
+	u32 set_wakeup_time;
+	u32 set_virtual_address_map;
+	u32 convert_pointer;
+	u32 get_variable;
+	u32 get_next_variable;
+	u32 set_variable;
+	u32 get_next_high_mono_count;
+	u32 reset_system;
+	u32 update_capsule;
+	u32 query_capsule_caps;
+	u32 query_variable_info;
+} efi_runtime_services_32_t;
+
+typedef struct {
+	efi_table_hdr_t hdr;
+	u64 get_time;
+	u64 set_time;
+	u64 get_wakeup_time;
+	u64 set_wakeup_time;
+	u64 set_virtual_address_map;
+	u64 convert_pointer;
+	u64 get_variable;
+	u64 get_next_variable;
+	u64 set_variable;
+	u64 get_next_high_mono_count;
+	u64 reset_system;
+	u64 update_capsule;
+	u64 query_capsule_caps;
+	u64 query_variable_info;
+} efi_runtime_services_64_t;
+
 typedef struct {
 	efi_table_hdr_t hdr;
 	void *get_time;
@@ -483,6 +664,38 @@ struct efi_memory_map {
 	unsigned long desc_size;
 };
 
+typedef struct {
+	u32 revision;
+	u32 parent_handle;
+	u32 system_table;
+	u32 device_handle;
+	u32 file_path;
+	u32 reserved;
+	u32 load_options_size;
+	u32 load_options;
+	u32 image_base;
+	__aligned_u64 image_size;
+	unsigned int image_code_type;
+	unsigned int image_data_type;
+	unsigned long unload;
+} efi_loaded_image_32_t;
+
+typedef struct {
+	u32 revision;
+	u64 parent_handle;
+	u64 system_table;
+	u64 device_handle;
+	u64 file_path;
+	u64 reserved;
+	u32 load_options_size;
+	u64 load_options;
+	u64 image_base;
+	__aligned_u64 image_size;
+	unsigned int image_code_type;
+	unsigned int image_data_type;
+	unsigned long unload;
+} efi_loaded_image_64_t;
+
 typedef struct {
 	u32 revision;
 	void *parent_handle;
@@ -511,6 +724,34 @@ typedef struct {
 	efi_char16_t filename[1];
 } efi_file_info_t;
 
+typedef struct {
+	u64 revision;
+	u32 open;
+	u32 close;
+	u32 delete;
+	u32 read;
+	u32 write;
+	u32 get_position;
+	u32 set_position;
+	u32 get_info;
+	u32 set_info;
+	u32 flush;
+} efi_file_handle_32_t;
+
+typedef struct {
+	u64 revision;
+	u64 open;
+	u64 close;
+	u64 delete;
+	u64 read;
+	u64 write;
+	u64 get_position;
+	u64 set_position;
+	u64 get_info;
+	u64 set_info;
+	u64 flush;
+} efi_file_handle_64_t;
+
 typedef struct _efi_file_handle {
 	u64 revision;
 	efi_status_t (*open)(struct _efi_file_handle *,
@@ -809,6 +1050,17 @@ struct efivar_entry {
 	bool deleting;
 };
 
+struct efi_simple_text_output_protocol_32 {
+	u32 reset;
+	u32 output_string;
+	u32 test_string;
+};
+
+struct efi_simple_text_output_protocol_64 {
+	u64 reset;
+	u64 output_string;
+	u64 test_string;
+};
 
 struct efi_simple_text_output_protocol {
 	void *reset;

commit 092063808c498eccac8e891973bf143e7b60d723
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Wed Jan 15 13:49:51 2014 +0000

    ia64/efi: Implement efi_enabled()
    
    There's no good reason to keep efi_enabled() under CONFIG_X86 anymore,
    since nothing about the implementation is specific to x86.
    
    Set EFI feature flags in the ia64 boot path instead of claiming to
    support all features. The old behaviour was actually buggy since
    efi.memmap never points to a valid memory map, so we shouldn't be
    claiming to support EFI_MEMMAP.
    
    Fortunately, this bug was never triggered because EFI_MEMMAP isn't used
    outside of arch/x86 currently, but that may not always be the case.
    
    Reviewed-and-tested-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 214833b4a97d..64d532ca890a 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -660,8 +660,6 @@ extern int __init efi_setup_pcdp_console(char *);
 #define EFI_ARCH_1		6	/* First arch-specific bit */
 
 #ifdef CONFIG_EFI
-# ifdef CONFIG_X86
-
 /*
  * Test whether the above EFI_* bits are enabled.
  */
@@ -669,12 +667,6 @@ static inline bool efi_enabled(int feature)
 {
 	return test_bit(feature, &efi.flags) != 0;
 }
-# else
-static inline bool efi_enabled(int feature)
-{
-	return true;
-}
-# endif
 #else
 static inline bool efi_enabled(int feature)
 {

commit 3e909599215456928e6b42a04f11c2517881570b
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Wed Jan 15 13:21:22 2014 +0000

    efi: Move facility flags to struct efi
    
    As we grow support for more EFI architectures they're going to want the
    ability to query which EFI features are available on the running system.
    Instead of storing this information in an architecture-specific place,
    stick it in the global 'struct efi', which is already the central
    location for EFI state.
    
    While we're at it, let's change the return value of efi_enabled() to be
    bool and replace all references to 'facility' with 'feature', which is
    the usual word used to describe the attributes of the running system.
    
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 0a819e7a60c9..214833b4a97d 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -573,6 +573,7 @@ extern struct efi {
 	efi_reset_system_t *reset_system;
 	efi_set_virtual_address_map_t *set_virtual_address_map;
 	struct efi_memory_map *memmap;
+	unsigned long flags;
 } efi;
 
 static inline int
@@ -660,17 +661,24 @@ extern int __init efi_setup_pcdp_console(char *);
 
 #ifdef CONFIG_EFI
 # ifdef CONFIG_X86
-extern int efi_enabled(int facility);
+
+/*
+ * Test whether the above EFI_* bits are enabled.
+ */
+static inline bool efi_enabled(int feature)
+{
+	return test_bit(feature, &efi.flags) != 0;
+}
 # else
-static inline int efi_enabled(int facility)
+static inline bool efi_enabled(int feature)
 {
-	return 1;
+	return true;
 }
 # endif
 #else
-static inline int efi_enabled(int facility)
+static inline bool efi_enabled(int feature)
 {
-	return 0;
+	return false;
 }
 #endif
 

commit ef0b8b9a521c65201bfca9747ee1bf374296133c
Merge: 5c12af0c41e3 d6e0a2dd12f4
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sun Jan 5 12:34:29 2014 +0100

    Merge tag 'v3.13-rc7' into x86/efi-kexec to resolve conflicts
    
    Conflicts:
            arch/x86/platform/efi/efi.c
            drivers/firmware/efi/Kconfig
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 926172d46038d7610b6b8d84e40db727cefb482d
Author: Dave Young <dyoung@redhat.com>
Date:   Fri Dec 20 18:02:18 2013 +0800

    efi: Export EFI runtime memory mapping to sysfs
    
    kexec kernel will need exactly same mapping for EFI runtime memory
    ranges. Thus here export the runtime ranges mapping to sysfs,
    kexec-tools will assemble them and pass to 2nd kernel via setup_data.
    
    Introducing a new directory /sys/firmware/efi/runtime-map just like
    /sys/firmware/memmap. Containing below attribute in each file of that
    directory:
    
    attribute  num_pages  phys_addr  type  virt_addr
    
    Signed-off-by: Dave Young <dyoung@redhat.com>
    Tested-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index fb60b10b7bd9..e64540746c63 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -872,4 +872,17 @@ int efivars_sysfs_init(void);
 
 #endif /* CONFIG_EFI_VARS */
 
+#ifdef CONFIG_EFI_RUNTIME_MAP
+int efi_runtime_map_init(struct kobject *);
+void efi_runtime_map_setup(void *, int, u32);
+#else
+static inline int efi_runtime_map_init(struct kobject *kobj)
+{
+	return 0;
+}
+
+static inline void
+efi_runtime_map_setup(void *map, int nr_entries, u32 desc_size) {}
+#endif
+
 #endif /* _LINUX_EFI_H */

commit a0998eb15afeffbf52a2c2829318f67df9ac57b8
Author: Dave Young <dyoung@redhat.com>
Date:   Fri Dec 20 18:02:17 2013 +0800

    efi: Export more EFI table variables to sysfs
    
    Export fw_vendor, runtime and config table physical addresses to
    /sys/firmware/efi/{fw_vendor,runtime,config_table} because kexec kernels
    need them.
    
    From EFI spec these 3 variables will be updated to virtual address after
    entering virtual mode. But kernel startup code will need the physical
    address.
    
    Signed-off-by: Dave Young <dyoung@redhat.com>
    Tested-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 6c0ca528300c..fb60b10b7bd9 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -556,6 +556,9 @@ extern struct efi {
 	unsigned long hcdp;		/* HCDP table */
 	unsigned long uga;		/* UGA table */
 	unsigned long uv_systab;	/* UV system table */
+	unsigned long fw_vendor;	/* fw_vendor */
+	unsigned long runtime;		/* runtime table */
+	unsigned long config_table;	/* config tables */
 	efi_get_time_t *get_time;
 	efi_set_time_t *set_time;
 	efi_get_wakeup_time_t *get_wakeup_time;

commit e0d59733f6b1796b8d6692642c87d7dd862c3e3a
Author: Seiji Aguchi <seiji.aguchi@hds.com>
Date:   Wed Oct 30 15:27:26 2013 -0400

    efivars, efi-pstore: Hold off deletion of sysfs entry until the scan is completed
    
    Currently, when mounting pstore file system, a read callback of
    efi_pstore driver runs mutiple times as below.
    
    - In the first read callback, scan efivar_sysfs_list from head and pass
      a kmsg buffer of a entry to an upper pstore layer.
    - In the second read callback, rescan efivar_sysfs_list from the entry
      and pass another kmsg buffer to it.
    - Repeat the scan and pass until the end of efivar_sysfs_list.
    
    In this process, an entry is read across the multiple read function
    calls. To avoid race between the read and erasion, the whole process
    above is protected by a spinlock, holding in open() and releasing in
    close().
    
    At the same time, kmemdup() is called to pass the buffer to pstore
    filesystem during it. And then, it causes a following lockdep warning.
    
    To make the dynamic memory allocation runnable without taking spinlock,
    holding off a deletion of sysfs entry if it happens while scanning it
    via efi_pstore, and deleting it after the scan is completed.
    
    To implement it, this patch introduces two flags, scanning and deleting,
    to efivar_entry.
    
    On the code basis, it seems that all the scanning and deleting logic is
    not needed because __efivars->lock are not dropped when reading from the
    EFI variable store.
    
    But, the scanning and deleting logic is still needed because an
    efi-pstore and a pstore filesystem works as follows.
    
    In case an entry(A) is found, the pointer is saved to psi->data.  And
    efi_pstore_read() passes the entry(A) to a pstore filesystem by
    releasing  __efivars->lock.
    
    And then, the pstore filesystem calls efi_pstore_read() again and the
    same entry(A), which is saved to psi->data, is used for resuming to scan
    a sysfs-list.
    
    So, to protect the entry(A), the logic is needed.
    
    [    1.143710] ------------[ cut here ]------------
    [    1.144058] WARNING: CPU: 1 PID: 1 at kernel/lockdep.c:2740 lockdep_trace_alloc+0x104/0x110()
    [    1.144058] DEBUG_LOCKS_WARN_ON(irqs_disabled_flags(flags))
    [    1.144058] Modules linked in:
    [    1.144058] CPU: 1 PID: 1 Comm: systemd Not tainted 3.11.0-rc5 #2
    [    1.144058]  0000000000000009 ffff8800797e9ae0 ffffffff816614a5 ffff8800797e9b28
    [    1.144058]  ffff8800797e9b18 ffffffff8105510d 0000000000000080 0000000000000046
    [    1.144058]  00000000000000d0 00000000000003af ffffffff81ccd0c0 ffff8800797e9b78
    [    1.144058] Call Trace:
    [    1.144058]  [<ffffffff816614a5>] dump_stack+0x54/0x74
    [    1.144058]  [<ffffffff8105510d>] warn_slowpath_common+0x7d/0xa0
    [    1.144058]  [<ffffffff8105517c>] warn_slowpath_fmt+0x4c/0x50
    [    1.144058]  [<ffffffff8131290f>] ? vsscanf+0x57f/0x7b0
    [    1.144058]  [<ffffffff810bbd74>] lockdep_trace_alloc+0x104/0x110
    [    1.144058]  [<ffffffff81192da0>] __kmalloc_track_caller+0x50/0x280
    [    1.144058]  [<ffffffff815147bb>] ? efi_pstore_read_func.part.1+0x12b/0x170
    [    1.144058]  [<ffffffff8115b260>] kmemdup+0x20/0x50
    [    1.144058]  [<ffffffff815147bb>] efi_pstore_read_func.part.1+0x12b/0x170
    [    1.144058]  [<ffffffff81514800>] ? efi_pstore_read_func.part.1+0x170/0x170
    [    1.144058]  [<ffffffff815148b4>] efi_pstore_read_func+0xb4/0xe0
    [    1.144058]  [<ffffffff81512b7b>] __efivar_entry_iter+0xfb/0x120
    [    1.144058]  [<ffffffff8151428f>] efi_pstore_read+0x3f/0x50
    [    1.144058]  [<ffffffff8128d7ba>] pstore_get_records+0x9a/0x150
    [    1.158207]  [<ffffffff812af25c>] ? selinux_d_instantiate+0x1c/0x20
    [    1.158207]  [<ffffffff8128ce30>] ? parse_options+0x80/0x80
    [    1.158207]  [<ffffffff8128ced5>] pstore_fill_super+0xa5/0xc0
    [    1.158207]  [<ffffffff811ae7d2>] mount_single+0xa2/0xd0
    [    1.158207]  [<ffffffff8128ccf8>] pstore_mount+0x18/0x20
    [    1.158207]  [<ffffffff811ae8b9>] mount_fs+0x39/0x1b0
    [    1.158207]  [<ffffffff81160550>] ? __alloc_percpu+0x10/0x20
    [    1.158207]  [<ffffffff811c9493>] vfs_kern_mount+0x63/0xf0
    [    1.158207]  [<ffffffff811cbb0e>] do_mount+0x23e/0xa20
    [    1.158207]  [<ffffffff8115b51b>] ? strndup_user+0x4b/0xf0
    [    1.158207]  [<ffffffff811cc373>] SyS_mount+0x83/0xc0
    [    1.158207]  [<ffffffff81673cc2>] system_call_fastpath+0x16/0x1b
    [    1.158207] ---[ end trace 61981bc62de9f6f4 ]---
    
    Signed-off-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Tested-by: Madper Xie <cxie@redhat.com>
    Cc: stable@kernel.org
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index bc5687d0f315..11ce6784a196 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -801,6 +801,8 @@ struct efivar_entry {
 	struct efi_variable var;
 	struct list_head list;
 	struct kobject kobj;
+	bool scanning;
+	bool deleting;
 };
 
 
@@ -866,6 +868,8 @@ void efivar_run_worker(void);
 #if defined(CONFIG_EFI_VARS) || defined(CONFIG_EFI_VARS_MODULE)
 int efivars_sysfs_init(void);
 
+#define EFIVARS_DATA_SIZE_MAX 1024
+
 #endif /* CONFIG_EFI_VARS */
 
 #endif /* _LINUX_EFI_H */

commit d2f7cbe7b26a74dbbbf8f325b2a6fd01bc34032c
Author: Borislav Petkov <bp@suse.de>
Date:   Thu Oct 31 17:25:08 2013 +0100

    x86/efi: Runtime services virtual mapping
    
    We map the EFI regions needed for runtime services non-contiguously,
    with preserved alignment on virtual addresses starting from -4G down
    for a total max space of 64G. This way, we provide for stable runtime
    services addresses across kernels so that a kexec'd kernel can still use
    them.
    
    Thus, they're mapped in a separate pagetable so that we don't pollute
    the kernel namespace.
    
    Add an efi= kernel command line parameter for passing miscellaneous
    options and chicken bits from the command line.
    
    While at it, add a chicken bit called "efi=old_map" which can be used as
    a fallback to the old runtime services mapping method in case there's
    some b0rkage with a particular EFI implementation (haha, it is hard to
    hold up the sarcasm here...).
    
    Also, add the UEFI RT VA space to Documentation/x86/x86_64/mm.txt.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index bc5687d0f315..6c0ca528300c 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -653,6 +653,7 @@ extern int __init efi_setup_pcdp_console(char *);
 #define EFI_RUNTIME_SERVICES	3	/* Can we use runtime services? */
 #define EFI_MEMMAP		4	/* Can we use EFI memory map? */
 #define EFI_64BIT		5	/* Is the firmware 64-bit? */
+#define EFI_ARCH_1		6	/* First arch-specific bit */
 
 #ifdef CONFIG_EFI
 # ifdef CONFIG_X86

commit ed37ddffe201bfad7be3c45bc08bd65b5298adca
Author: Roy Franz <roy.franz@linaro.org>
Date:   Sun Sep 22 15:45:26 2013 -0700

    efi: Add proper definitions for some EFI function pointers.
    
    The x86/AMD64 EFI stubs must use a call wrapper to convert between
    the Linux and EFI ABIs, so void pointers are sufficient.  For ARM,
    the ABIs are compatible, so we can directly invoke the function
    pointers.  The functions that are used by the ARM stub are updated
    to match the EFI definitions.
    Also add some EFI types used by EFI functions.
    
    Signed-off-by: Roy Franz <roy.franz@linaro.org>
    Acked-by: Mark Salter <msalter@redhat.com>
    Reviewed-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index c084b6d942c3..bc5687d0f315 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -39,6 +39,8 @@
 typedef unsigned long efi_status_t;
 typedef u8 efi_bool_t;
 typedef u16 efi_char16_t;		/* UNICODE character */
+typedef u64 efi_physical_addr_t;
+typedef void *efi_handle_t;
 
 
 typedef struct {
@@ -96,6 +98,7 @@ typedef	struct {
 #define EFI_MEMORY_DESCRIPTOR_VERSION	1
 
 #define EFI_PAGE_SHIFT		12
+#define EFI_PAGE_SIZE		(1UL << EFI_PAGE_SHIFT)
 
 typedef struct {
 	u32 type;
@@ -157,11 +160,13 @@ typedef struct {
 	efi_table_hdr_t hdr;
 	void *raise_tpl;
 	void *restore_tpl;
-	void *allocate_pages;
-	void *free_pages;
-	void *get_memory_map;
-	void *allocate_pool;
-	void *free_pool;
+	efi_status_t (*allocate_pages)(int, int, unsigned long,
+				       efi_physical_addr_t *);
+	efi_status_t (*free_pages)(efi_physical_addr_t, unsigned long);
+	efi_status_t (*get_memory_map)(unsigned long *, void *, unsigned long *,
+				       unsigned long *, u32 *);
+	efi_status_t (*allocate_pool)(int, unsigned long, void **);
+	efi_status_t (*free_pool)(void *);
 	void *create_event;
 	void *set_timer;
 	void *wait_for_event;
@@ -171,7 +176,7 @@ typedef struct {
 	void *install_protocol_interface;
 	void *reinstall_protocol_interface;
 	void *uninstall_protocol_interface;
-	void *handle_protocol;
+	efi_status_t (*handle_protocol)(efi_handle_t, efi_guid_t *, void **);
 	void *__reserved;
 	void *register_protocol_notify;
 	void *locate_handle;
@@ -181,7 +186,7 @@ typedef struct {
 	void *start_image;
 	void *exit;
 	void *unload_image;
-	void *exit_boot_services;
+	efi_status_t (*exit_boot_services)(efi_handle_t, unsigned long);
 	void *get_next_monotonic_count;
 	void *stall;
 	void *set_watchdog_timer;
@@ -494,10 +499,6 @@ typedef struct {
 	unsigned long unload;
 } efi_loaded_image_t;
 
-typedef struct {
-	u64 revision;
-	void *open_volume;
-} efi_file_io_interface_t;
 
 typedef struct {
 	u64 size;
@@ -510,20 +511,30 @@ typedef struct {
 	efi_char16_t filename[1];
 } efi_file_info_t;
 
-typedef struct {
+typedef struct _efi_file_handle {
 	u64 revision;
-	void *open;
-	void *close;
+	efi_status_t (*open)(struct _efi_file_handle *,
+			     struct _efi_file_handle **,
+			     efi_char16_t *, u64, u64);
+	efi_status_t (*close)(struct _efi_file_handle *);
 	void *delete;
-	void *read;
+	efi_status_t (*read)(struct _efi_file_handle *, unsigned long *,
+			     void *);
 	void *write;
 	void *get_position;
 	void *set_position;
-	void *get_info;
+	efi_status_t (*get_info)(struct _efi_file_handle *, efi_guid_t *,
+			unsigned long *, void *);
 	void *set_info;
 	void *flush;
 } efi_file_handle_t;
 
+typedef struct _efi_file_io_interface {
+	u64 revision;
+	int (*open_volume)(struct _efi_file_io_interface *,
+			   efi_file_handle_t **);
+} efi_file_io_interface_t;
+
 #define EFI_FILE_MODE_READ	0x0000000000000001
 #define EFI_FILE_MODE_WRITE	0x0000000000000002
 #define EFI_FILE_MODE_CREATE	0x8000000000000000
@@ -792,6 +803,13 @@ struct efivar_entry {
 	struct kobject kobj;
 };
 
+
+struct efi_simple_text_output_protocol {
+	void *reset;
+	efi_status_t (*output_string)(void *, void *);
+	void *test_string;
+};
+
 extern struct list_head efivar_sysfs_list;
 
 static inline void

commit 258f6fd738221766b512cd8c7120563b78d62829
Author: Leif Lindholm <leif.lindholm@linaro.org>
Date:   Thu Sep 5 11:34:55 2013 +0100

    efi: x86: make efi_lookup_mapped_addr() a common function
    
    efi_lookup_mapped_addr() is a handy utility for other platforms than
    x86. Move it from arch/x86 to drivers/firmware. Add memmap pointer
    to global efi structure, and initialise it on x86.
    
    Signed-off-by: Leif Lindholm <leif.lindholm@linaro.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 09d9e4212799..c084b6d942c3 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -558,6 +558,7 @@ extern struct efi {
 	efi_get_next_high_mono_count_t *get_next_high_mono_count;
 	efi_reset_system_t *reset_system;
 	efi_set_virtual_address_map_t *set_virtual_address_map;
+	struct efi_memory_map *memmap;
 } efi;
 
 static inline int

commit 272686bf46a34f86d270cf192f68769667792026
Author: Leif Lindholm <leif.lindholm@linaro.org>
Date:   Thu Sep 5 11:34:54 2013 +0100

    efi: x86: ia64: provide a generic efi_config_init()
    
    Common to (U)EFI support on all platforms is the global "efi" data
    structure, and the code that parses the System Table to locate
    addresses to populate that structure with.
    
    This patch adds both of these to the global EFI driver code and
    removes the local definition of the global "efi" data structure from
    the x86 and ia64 code.
    
    Squashed into one big patch to avoid breaking bisection.
    
    Signed-off-by: Leif Lindholm <leif.lindholm@linaro.org>
    Acked-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 5f8f176154f7..09d9e4212799 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -404,6 +404,12 @@ typedef struct {
 	unsigned long table;
 } efi_config_table_t;
 
+typedef struct {
+	efi_guid_t guid;
+	const char *name;
+	unsigned long *ptr;
+} efi_config_table_type_t;
+
 #define EFI_SYSTEM_TABLE_SIGNATURE ((u64)0x5453595320494249ULL)
 
 #define EFI_2_30_SYSTEM_TABLE_REVISION  ((2 << 16) | (30))
@@ -587,6 +593,7 @@ static inline efi_status_t efi_query_variable_store(u32 attributes, unsigned lon
 }
 #endif
 extern void __iomem *efi_lookup_mapped_addr(u64 phys_addr);
+extern int efi_config_init(efi_config_table_type_t *arch_tables);
 extern u64 efi_get_iobase (void);
 extern u32 efi_mem_type (unsigned long phys_addr);
 extern u64 efi_mem_attributes (unsigned long phys_addr);

commit 21884a83b2192a00885d7244a1dda32debd2fbc7
Merge: 8b70a90cabaf 73b0cd674ccc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 6 14:09:38 2013 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer core updates from Thomas Gleixner:
     "The timer changes contain:
    
       - posix timer code consolidation and fixes for odd corner cases
    
       - sched_clock implementation moved from ARM to core code to avoid
         duplication by other architectures
    
       - alarm timer updates
    
       - clocksource and clockevents unregistration facilities
    
       - clocksource/events support for new hardware
    
       - precise nanoseconds RTC readout (Xen feature)
    
       - generic support for Xen suspend/resume oddities
    
       - the usual lot of fixes and cleanups all over the place
    
      The parts which touch other areas (ARM/XEN) have been coordinated with
      the relevant maintainers.  Though this results in an handful of
      trivial to solve merge conflicts, which we preferred over nasty cross
      tree merge dependencies.
    
      The patches which have been committed in the last few days are bug
      fixes plus the posix timer lot.  The latter was in akpms queue and
      next for quite some time; they just got forgotten and Frederic
      collected them last minute."
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (59 commits)
      hrtimer: Remove unused variable
      hrtimers: Move SMP function call to thread context
      clocksource: Reselect clocksource when watchdog validated high-res capability
      posix-cpu-timers: don't account cpu timer after stopped thread runtime accounting
      posix_timers: fix racy timer delta caching on task exit
      posix-timers: correctly get dying task time sample in posix_cpu_timer_schedule()
      selftests: add basic posix timers selftests
      posix_cpu_timers: consolidate expired timers check
      posix_cpu_timers: consolidate timer list cleanups
      posix_cpu_timer: consolidate expiry time type
      tick: Sanitize broadcast control logic
      tick: Prevent uncontrolled switch to oneshot mode
      tick: Make oneshot broadcast robust vs. CPU offlining
      x86: xen: Sync the CMOS RTC as well as the Xen wallclock
      x86: xen: Sync the wallclock when the system time is set
      timekeeping: Indicate that clock was set in the pvclock gtod notifier
      timekeeping: Pass flags instead of multiple bools to timekeeping_update()
      xen: Remove clock_was_set() call in the resume path
      hrtimers: Support resuming with two or more CPUs online (but stopped)
      timer: Fix jiffies wrap behavior of round_jiffies_common()
      ...

commit 43ab0476a648053e5998bf081f47f215375a4502
Author: Borislav Petkov <bp@suse.de>
Date:   Sun Jun 2 14:56:07 2013 +0200

    efi: Convert runtime services function ptrs
    
    ... to void * like the boot services and lose all the void * casts. No
    functionality change.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 2bc0ad78d058..21ae6b3c0359 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -287,20 +287,20 @@ typedef struct {
 
 typedef struct {
 	efi_table_hdr_t hdr;
-	unsigned long get_time;
-	unsigned long set_time;
-	unsigned long get_wakeup_time;
-	unsigned long set_wakeup_time;
-	unsigned long set_virtual_address_map;
-	unsigned long convert_pointer;
-	unsigned long get_variable;
-	unsigned long get_next_variable;
-	unsigned long set_variable;
-	unsigned long get_next_high_mono_count;
-	unsigned long reset_system;
-	unsigned long update_capsule;
-	unsigned long query_capsule_caps;
-	unsigned long query_variable_info;
+	void *get_time;
+	void *set_time;
+	void *get_wakeup_time;
+	void *set_wakeup_time;
+	void *set_virtual_address_map;
+	void *convert_pointer;
+	void *get_variable;
+	void *get_next_variable;
+	void *set_variable;
+	void *get_next_high_mono_count;
+	void *reset_system;
+	void *update_capsule;
+	void *query_capsule_caps;
+	void *query_variable_info;
 } efi_runtime_services_t;
 
 typedef efi_status_t efi_get_time_t (efi_time_t *tm, efi_time_cap_t *tc);

commit 3565184ed0c1ea46bea5b792da5f72a83c43e49b
Author: David Vrabel <david.vrabel@citrix.com>
Date:   Mon May 13 18:56:06 2013 +0100

    x86: Increase precision of x86_platform.get/set_wallclock()
    
    All the virtualized platforms (KVM, lguest and Xen) have persistent
    wallclocks that have more than one second of precision.
    
    read_persistent_wallclock() and update_persistent_wallclock() allow
    for nanosecond precision but their implementation on x86 with
    x86_platform.get/set_wallclock() only allows for one second precision.
    This means guests may see a wallclock time that is off by up to 1
    second.
    
    Make set_wallclock() and get_wallclock() take a struct timespec
    parameter (which allows for nanosecond precision) so KVM and Xen
    guests may start with a more accurate wallclock time and a Xen dom0
    can maintain a more accurate wallclock for guests.
    
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 2bc0ad78d058..0068bba6f8b6 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -594,8 +594,8 @@ extern u64 efi_mem_attribute (unsigned long phys_addr, unsigned long size);
 extern int __init efi_uart_console_only (void);
 extern void efi_initialize_iomem_resources(struct resource *code_resource,
 		struct resource *data_resource, struct resource *bss_resource);
-extern unsigned long efi_get_time(void);
-extern int efi_set_rtc_mmss(unsigned long nowtime);
+extern void efi_get_time(struct timespec *now);
+extern int efi_set_rtc_mmss(const struct timespec *now);
 extern void efi_reserve_boot_services(void);
 extern struct efi_memory_map memmap;
 

commit 8a415b8c05f261a52f45f2271b6c4731376fd5b5
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Mon Apr 29 20:08:02 2013 +0100

    efi, pstore: Read data from variable store before memcpy()
    
    Seiji reported getting empty dmesg-* files, because the data was never
    actually read in efi_pstore_read_func(), and so the memcpy() was copying
    garbage data.
    
    This patch necessitated adding __efivar_entry_get() which is callable
    between efivar_entry_iter_{begin,end}(). We can also delete
    __efivar_entry_size() because efi_pstore_read_func() was the only
    caller.
    
    Reported-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Tested-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Matthew Garrett <matthew.garrett@nebula.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 3f7257f1f5e8..2bc0ad78d058 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -808,8 +808,9 @@ void efivar_entry_remove(struct efivar_entry *entry);
 int __efivar_entry_delete(struct efivar_entry *entry);
 int efivar_entry_delete(struct efivar_entry *entry);
 
-int __efivar_entry_size(struct efivar_entry *entry, unsigned long *size);
 int efivar_entry_size(struct efivar_entry *entry, unsigned long *size);
+int __efivar_entry_get(struct efivar_entry *entry, u32 *attributes,
+		       unsigned long *size, void *data);
 int efivar_entry_get(struct efivar_entry *entry, u32 *attributes,
 		     unsigned long *size, void *data);
 int efivar_entry_set(struct efivar_entry *entry, u32 attributes,

commit a614e1923d5389d01f3545ee4a90e39a04d0c90d
Merge: f53f292eeaa2 c1be5a5b1b35
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Tue Apr 30 11:30:24 2013 +0100

    Merge tag 'v3.9' into efi-for-tip2
    
    Resolve conflicts for Ingo.
    
    Conflicts:
            drivers/firmware/Kconfig
            drivers/firmware/efivars.c
    
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

commit a9499fa7cd3fd4824a7202d00c766b269fa3bda6
Author: Tom Gundersen <teg@jklm.no>
Date:   Fri Feb 8 15:37:06 2013 +0000

    efi: split efisubsystem from efivars
    
    This registers /sys/firmware/efi/{,systab,efivars/} whenever EFI is enabled
    and the system is booted with EFI.
    
    This allows
     *) userspace to check for the existence of /sys/firmware/efi as a way
        to determine whether or it is running on an EFI system.
     *) 'mount -t efivarfs none /sys/firmware/efi/efivars' without manually
        loading any modules.
    
    [ Also, move the efivar API into vars.c and unconditionally compile it.
      This allows us to move efivars.c, which now only contains the sysfs
      variable code, into the firmware/efi directory. Note that the efivars.c
      filename is kept to maintain backwards compatability with the old
      efivars.ko module. With this patch it is now possible for efivarfs
      to be built without CONFIG_EFI_VARS - Matt ]
    
    Cc: Seiji Aguchi <seiji.aguchi@hds.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Mike Waychison <mikew@google.com>
    Cc: Kay Sievers <kay@vrfy.org>
    Cc: Jeremy Kerr <jk@ozlabs.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Chun-Yi Lee <jlee@suse.com>
    Cc: Andy Whitcroft <apw@canonical.com>
    Cc: Tobias Powalowski <tpowa@archlinux.org>
    Signed-off-by: Tom Gundersen <teg@jklm.no>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 8ff6ec1ac046..2fc816682714 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -742,7 +742,6 @@ utf16_strlen(efi_char16_t *s)
 	return utf16_strnlen(s, ~0UL);
 }
 
-#if defined(CONFIG_EFI_VARS) || defined(CONFIG_EFI_VARS_MODULE)
 /*
  * Return the number of bytes is the length of this string
  * Note: this is NOT the same as the number of unicode characters
@@ -872,8 +871,10 @@ struct efivar_entry *efivar_entry_find(efi_char16_t *name, efi_guid_t guid,
 
 bool efivar_validate(struct efi_variable *var, u8 *data, unsigned long len);
 
+extern struct work_struct efivar_work;
 void efivar_run_worker(void);
 
+#if defined(CONFIG_EFI_VARS) || defined(CONFIG_EFI_VARS_MODULE)
 int efivars_sysfs_init(void);
 
 #endif /* CONFIG_EFI_VARS */

commit 048517722cde2595a7366d0c3c72b8b1ec142a9c
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Fri Feb 8 15:48:51 2013 +0000

    efivars: Move pstore code into the new EFI directory
    
    efivars.c has grown far too large and needs to be divided up. Create a
    new directory and move the persistence storage code to efi-pstore.c now
    that it uses the new efivar API. This helps us to greatly reduce the
    size of efivars.c and paves the way for moving other code out of
    efivars.c.
    
    Note that because CONFIG_EFI_VARS can be built as a module efi-pstore
    must also include support for building as a module.
    
    Reviewed-by: Tom Gundersen <teg@jklm.no>
    Tested-by: Tom Gundersen <teg@jklm.no>
    Cc: Seiji Aguchi <seiji.aguchi@hds.com>
    Cc: Anton Vorontsov <cbouatmailru@gmail.com>
    Cc: Colin Cross <ccross@android.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index cd561b301e6a..8ff6ec1ac046 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -743,6 +743,34 @@ utf16_strlen(efi_char16_t *s)
 }
 
 #if defined(CONFIG_EFI_VARS) || defined(CONFIG_EFI_VARS_MODULE)
+/*
+ * Return the number of bytes is the length of this string
+ * Note: this is NOT the same as the number of unicode characters
+ */
+static inline unsigned long
+utf16_strsize(efi_char16_t *data, unsigned long maxlength)
+{
+	return utf16_strnlen(data, maxlength/sizeof(efi_char16_t)) * sizeof(efi_char16_t);
+}
+
+static inline int
+utf16_strncmp(const efi_char16_t *a, const efi_char16_t *b, size_t len)
+{
+	while (1) {
+		if (len == 0)
+			return 0;
+		if (*a < *b)
+			return -1;
+		if (*a > *b)
+			return 1;
+		if (*a == 0) /* implies *b == 0 */
+			return 0;
+		a++;
+		b++;
+		len--;
+	}
+}
+
 /*
  * EFI Variable support.
  *
@@ -795,6 +823,14 @@ struct efivar_entry {
 	struct kobject kobj;
 };
 
+extern struct list_head efivar_sysfs_list;
+
+static inline void
+efivar_unregister(struct efivar_entry *var)
+{
+	kobject_put(&var->kobj);
+}
+
 int efivars_register(struct efivars *efivars,
 		     const struct efivar_operations *ops,
 		     struct kobject *kobject);
@@ -836,6 +872,8 @@ struct efivar_entry *efivar_entry_find(efi_char16_t *name, efi_guid_t guid,
 
 bool efivar_validate(struct efi_variable *var, u8 *data, unsigned long len);
 
+void efivar_run_worker(void);
+
 int efivars_sysfs_init(void);
 
 #endif /* CONFIG_EFI_VARS */

commit e14ab23dde12b80db4c94b684a2e485b72b16af3
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Sun Feb 3 20:16:40 2013 +0000

    efivars: efivar_entry API
    
    There isn't really a formal interface for dealing with EFI variables
    or struct efivar_entry. Historically, this has led to various bits of
    code directly accessing the generic EFI variable ops, which inherently
    ties it to specific EFI variable operations instead of indirectly
    using whatever ops were registered with register_efivars(). This lead
    to the efivarfs code only working with the generic EFI variable ops
    and not CONFIG_GOOGLE_SMI.
    
    Encapsulate everything that needs to access '__efivars' inside an
    efivar_entry_* API and use the new API in the pstore, sysfs and
    efivarfs code.
    
    Much of the efivars code had to be rewritten to use this new API. For
    instance, it is now up to the users of the API to build the initial
    list of EFI variables in their efivar_init() callback function. The
    variable list needs to be passed to efivar_init() which allows us to
    keep work arounds for things like implementation bugs in
    GetNextVariable() in a central location.
    
    Allowing users of the API to use a callback function to build the list
    greatly benefits the efivarfs code which needs to allocate inodes and
    dentries for every variable.  It previously did this in a racy way
    because the code ran without holding the variable spinlock. Both the
    sysfs and efivarfs code maintain their own lists which means the two
    interfaces can be running simultaneously without interference, though
    it should be noted that because no synchronisation is performed it is
    very easy to create inconsistencies. efibootmgr doesn't currently use
    efivarfs and users are likely to also require the old sysfs interface,
    so it makes sense to allow both to be built.
    
    Reviewed-by: Tom Gundersen <teg@jklm.no>
    Tested-by: Tom Gundersen <teg@jklm.no>
    Cc: Seiji Aguchi <seiji.aguchi@hds.com>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Jeremy Kerr <jk@ozlabs.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Mike Waychison <mikew@google.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index d1d782a6d34c..cd561b301e6a 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -662,6 +662,12 @@ static inline int efi_enabled(int facility)
 				EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS | \
 				EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS | \
 				EFI_VARIABLE_APPEND_WRITE)
+/*
+ * Length of a GUID string (strlen("aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee"))
+ * not including trailing NUL
+ */
+#define EFI_VARIABLE_GUID_LEN 36
+
 /*
  * The type of search to perform when calling boottime->locate_handle
  */
@@ -762,19 +768,75 @@ struct efivars {
 	 * which is protected by the BKL, so that path is safe.
 	 */
 	spinlock_t lock;
-	struct list_head list;
 	struct kset *kset;
 	struct kobject *kobject;
-	struct bin_attribute *new_var, *del_var;
 	const struct efivar_operations *ops;
-	struct efivar_entry *walk_entry;
-	struct pstore_info efi_pstore_info;
 };
 
-int register_efivars(struct efivars *efivars,
+/*
+ * The maximum size of VariableName + Data = 1024
+ * Therefore, it's reasonable to save that much
+ * space in each part of the structure,
+ * and we use a page for reading/writing.
+ */
+
+struct efi_variable {
+	efi_char16_t  VariableName[1024/sizeof(efi_char16_t)];
+	efi_guid_t    VendorGuid;
+	unsigned long DataSize;
+	__u8          Data[1024];
+	efi_status_t  Status;
+	__u32         Attributes;
+} __attribute__((packed));
+
+struct efivar_entry {
+	struct efi_variable var;
+	struct list_head list;
+	struct kobject kobj;
+};
+
+int efivars_register(struct efivars *efivars,
 		     const struct efivar_operations *ops,
-		     struct kobject *parent_kobj);
-void unregister_efivars(struct efivars *efivars);
+		     struct kobject *kobject);
+int efivars_unregister(struct efivars *efivars);
+struct kobject *efivars_kobject(void);
+
+int efivar_init(int (*func)(efi_char16_t *, efi_guid_t, unsigned long, void *),
+		void *data, bool atomic, bool duplicates,
+		struct list_head *head);
+
+void efivar_entry_add(struct efivar_entry *entry, struct list_head *head);
+void efivar_entry_remove(struct efivar_entry *entry);
+
+int __efivar_entry_delete(struct efivar_entry *entry);
+int efivar_entry_delete(struct efivar_entry *entry);
+
+int __efivar_entry_size(struct efivar_entry *entry, unsigned long *size);
+int efivar_entry_size(struct efivar_entry *entry, unsigned long *size);
+int efivar_entry_get(struct efivar_entry *entry, u32 *attributes,
+		     unsigned long *size, void *data);
+int efivar_entry_set(struct efivar_entry *entry, u32 attributes,
+		     unsigned long size, void *data, struct list_head *head);
+int efivar_entry_set_get_size(struct efivar_entry *entry, u32 attributes,
+			      unsigned long *size, void *data, bool *set);
+int efivar_entry_set_safe(efi_char16_t *name, efi_guid_t vendor, u32 attributes,
+			  bool block, unsigned long size, void *data);
+
+void efivar_entry_iter_begin(void);
+void efivar_entry_iter_end(void);
+
+int __efivar_entry_iter(int (*func)(struct efivar_entry *, void *),
+			struct list_head *head, void *data,
+			struct efivar_entry **prev);
+int efivar_entry_iter(int (*func)(struct efivar_entry *, void *),
+		      struct list_head *head, void *data);
+
+struct efivar_entry *efivar_entry_find(efi_char16_t *name, efi_guid_t guid,
+				       struct list_head *head, bool remove);
+
+bool efivar_validate(struct efi_variable *var, u8 *data, unsigned long len);
+
+int efivars_sysfs_init(void);
 
 #endif /* CONFIG_EFI_VARS */
 

commit d5abc7c1050ab2b9556a4bf21626cd74e83cd086
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Sun Feb 3 19:53:46 2013 +0000

    efi: move utf16 string functions to efi.h
    
    There are currently two implementations of the utf16 string functions.
    Somewhat confusingly, they've got different names.
    
    Centralise the functions in efi.h.
    
    Reviewed-by: Tom Gundersen <teg@jklm.no>
    Tested-by: Tom Gundersen <teg@jklm.no>
    Reviewed-by: Mike Waychison <mikew@google.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 9bf2f1fcae27..d1d782a6d34c 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -719,6 +719,23 @@ static inline void memrange_efi_to_native(u64 *addr, u64 *npages)
 	*addr &= PAGE_MASK;
 }
 
+/* Return the number of unicode characters in data */
+static inline unsigned long
+utf16_strnlen(efi_char16_t *s, size_t maxlength)
+{
+	unsigned long length = 0;
+
+	while (*s++ != 0 && length < maxlength)
+		length++;
+	return length;
+}
+
+static inline unsigned long
+utf16_strlen(efi_char16_t *s)
+{
+	return utf16_strnlen(s, ~0UL);
+}
+
 #if defined(CONFIG_EFI_VARS) || defined(CONFIG_EFI_VARS_MODULE)
 /*
  * EFI Variable support.

commit a6e4d5a03e9e3587e88aba687d8f225f4f04c792
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Mon Mar 25 09:14:30 2013 +0000

    x86, efivars: firmware bug workarounds should be in platform code
    
    Let's not burden ia64 with checks in the common efivars code that we're not
    writing too much data to the variable store. That kind of thing is an x86
    firmware bug, plain and simple.
    
    efi_query_variable_store() provides platforms with a wrapper in which they can
    perform checks and workarounds for EFI variable storage bugs.
    
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 9bf2f1fcae27..3d7df3d32c66 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -333,6 +333,7 @@ typedef efi_status_t efi_query_capsule_caps_t(efi_capsule_header_t **capsules,
 					      unsigned long count,
 					      u64 *max_size,
 					      int *reset_type);
+typedef efi_status_t efi_query_variable_store_t(u32 attributes, unsigned long size);
 
 /*
  *  EFI Configuration Table and GUID definitions
@@ -575,9 +576,15 @@ extern void efi_enter_virtual_mode (void);	/* switch EFI to virtual mode, if pos
 #ifdef CONFIG_X86
 extern void efi_late_init(void);
 extern void efi_free_boot_services(void);
+extern efi_status_t efi_query_variable_store(u32 attributes, unsigned long size);
 #else
 static inline void efi_late_init(void) {}
 static inline void efi_free_boot_services(void) {}
+
+static inline efi_status_t efi_query_variable_store(u32 attributes, unsigned long size)
+{
+	return EFI_SUCCESS;
+}
 #endif
 extern void __iomem *efi_lookup_mapped_addr(u64 phys_addr);
 extern u64 efi_get_iobase (void);
@@ -731,7 +738,7 @@ struct efivar_operations {
 	efi_get_variable_t *get_variable;
 	efi_get_next_variable_t *get_next_variable;
 	efi_set_variable_t *set_variable;
-	efi_query_variable_info_t *query_variable_info;
+	efi_query_variable_store_t *query_variable_store;
 };
 
 struct efivars {

commit 024e4ec1856d57bb78c06ec903d29dcf716f5f47
Merge: 850cb82b754c fb0af3f2b1b6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 21 09:38:18 2013 -0800

    Merge tag 'please-pull-pstore' of git://git.kernel.org/pub/scm/linux/kernel/git/aegl/linux
    
    Pull pstore patches from Tony Luck:
     "A few fixes to reduce places where pstore might hang a system in the
      crash path.  Plus a new mountpoint (/sys/fs/pstore ...  makes more
      sense then /dev/pstore)."
    
    Fix up trivial conflict in drivers/firmware/efivars.c
    
    * tag 'please-pull-pstore' of git://git.kernel.org/pub/scm/linux/kernel/git/aegl/linux:
      pstore: Create a convenient mount point for pstore
      efi_pstore: Introducing workqueue updating sysfs
      efivars: Disable external interrupt while holding efivars->lock
      efi_pstore: Avoid deadlock in non-blocking paths
      pstore: Avoid deadlock in panic and emergency-restart path

commit a93bc0c6e07ed9bac44700280e65e2945d864fd4
Author: Seiji Aguchi <seiji.aguchi@hds.com>
Date:   Tue Feb 12 13:04:41 2013 -0800

    efi_pstore: Introducing workqueue updating sysfs
    
    [Problem]
    efi_pstore creates sysfs entries, which enable users to access to NVRAM,
    in a write callback. If a kernel panic happens in an interrupt context,
    it may fail because it could sleep due to dynamic memory allocations during
    creating sysfs entries.
    
    [Patch Description]
    This patch removes sysfs operations from a write callback by introducing
    a workqueue updating sysfs entries which is scheduled after the write
    callback is called.
    
    Also, the workqueue is kicked in a just oops case.
    A system will go down in other cases such as panic, clean shutdown and emergency
    restart. And we don't need to create sysfs entries because there is no chance for
    users to access to them.
    
    efi_pstore will be robust against a kernel panic in an interrupt context with this patch.
    
    Signed-off-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Acked-by: Matt Fleming <matt.fleming@intel.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 8b84916dc671..d0c68aee0925 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -728,7 +728,8 @@ struct efivars {
 	 * 1) ->list - adds, removals, reads, writes
 	 * 2) ops.[gs]et_variable() calls.
 	 * It must not be held when creating sysfs entries or calling kmalloc.
-	 * ops.get_next_variable() is only called from register_efivars(),
+	 * ops.get_next_variable() is only called from register_efivars()
+	 * or efivar_update_sysfs_entries(),
 	 * which is protected by the BKL, so that path is safe.
 	 */
 	spinlock_t lock;

commit 83e68189745ad931c2afd45d8ee3303929233e7f
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Wed Nov 14 09:42:35 2012 +0000

    efi: Make 'efi_enabled' a function to query EFI facilities
    
    Originally 'efi_enabled' indicated whether a kernel was booted from
    EFI firmware. Over time its semantics have changed, and it now
    indicates whether or not we are booted on an EFI machine with
    bit-native firmware, e.g. 64-bit kernel with 64-bit firmware.
    
    The immediate motivation for this patch is the bug report at,
    
        https://bugs.launchpad.net/ubuntu-cdimage/+bug/1040557
    
    which details how running a platform driver on an EFI machine that is
    designed to run under BIOS can cause the machine to become
    bricked. Also, the following report,
    
        https://bugzilla.kernel.org/show_bug.cgi?id=47121
    
    details how running said driver can also cause Machine Check
    Exceptions. Drivers need a new means of detecting whether they're
    running on an EFI machine, as sadly the expression,
    
        if (!efi_enabled)
    
    hasn't been a sufficient condition for quite some time.
    
    Users actually want to query 'efi_enabled' for different reasons -
    what they really want access to is the list of available EFI
    facilities.
    
    For instance, the x86 reboot code needs to know whether it can invoke
    the ResetSystem() function provided by the EFI runtime services, while
    the ACPI OSL code wants to know whether the EFI config tables were
    mapped successfully. There are also checks in some of the platform
    driver code to simply see if they're running on an EFI machine (which
    would make it a bad idea to do BIOS-y things).
    
    This patch is a prereq for the samsung-laptop fix patch.
    
    Cc: David Airlie <airlied@linux.ie>
    Cc: Corentin Chary <corentincj@iksaif.net>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Dave Jiang <dave.jiang@intel.com>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Colin Ian King <colin.king@canonical.com>
    Cc: Steve Langasek <steve.langasek@canonical.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad@kernel.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 8b84916dc671..7a9498ab3c2d 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -618,18 +618,30 @@ extern int __init efi_setup_pcdp_console(char *);
 #endif
 
 /*
- * We play games with efi_enabled so that the compiler will, if possible, remove
- * EFI-related code altogether.
+ * We play games with efi_enabled so that the compiler will, if
+ * possible, remove EFI-related code altogether.
  */
+#define EFI_BOOT		0	/* Were we booted from EFI? */
+#define EFI_SYSTEM_TABLES	1	/* Can we use EFI system tables? */
+#define EFI_CONFIG_TABLES	2	/* Can we use EFI config tables? */
+#define EFI_RUNTIME_SERVICES	3	/* Can we use runtime services? */
+#define EFI_MEMMAP		4	/* Can we use EFI memory map? */
+#define EFI_64BIT		5	/* Is the firmware 64-bit? */
+
 #ifdef CONFIG_EFI
 # ifdef CONFIG_X86
-   extern int efi_enabled;
-   extern bool efi_64bit;
+extern int efi_enabled(int facility);
 # else
-#  define efi_enabled 1
+static inline int efi_enabled(int facility)
+{
+	return 1;
+}
 # endif
 #else
-# define efi_enabled 0
+static inline int efi_enabled(int facility)
+{
+	return 0;
+}
 #endif
 
 /*

commit 11520e5e7c1855fc3bf202bb3be35a39d9efa034
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 15 15:15:24 2012 -0800

    Revert "x86-64/efi: Use EFI to deal with platform wall clock (again)"
    
    This reverts commit bd52276fa1d4 ("x86-64/efi: Use EFI to deal with
    platform wall clock (again)"), and the two supporting commits:
    
      da5a108d05b4: "x86/kernel: remove tboot 1:1 page table creation code"
    
      185034e72d59: "x86, efi: 1:1 pagetable mapping for virtual EFI calls")
    
    as they all depend semantically on commit 53b87cf088e2 ("x86, mm:
    Include the entire kernel memory map in trampoline_pgd") that got
    reverted earlier due to the problems it caused.
    
    This was pointed out by Yinghai Lu, and verified by me on my Macbook Air
    that uses EFI.
    
    Pointed-out-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 02a69418be18..8b84916dc671 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -587,6 +587,8 @@ extern u64 efi_mem_attribute (unsigned long phys_addr, unsigned long size);
 extern int __init efi_uart_console_only (void);
 extern void efi_initialize_iomem_resources(struct resource *code_resource,
 		struct resource *data_resource, struct resource *bss_resource);
+extern unsigned long efi_get_time(void);
+extern int efi_set_rtc_mmss(unsigned long nowtime);
 extern void efi_reserve_boot_services(void);
 extern struct efi_memory_map memmap;
 

commit d42b3a2906a10b732ea7d7f849d49be79d242ef0
Merge: 18dd0bf22b6f e83af1f18c78
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 14 10:08:40 2012 -0800

    Merge branch 'core-efi-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 EFI update from Peter Anvin:
     "EFI tree, from Matt Fleming.  Most of the patches are the new efivarfs
      filesystem by Matt Garrett & co.  The balance are support for EFI
      wallclock in the absence of a hardware-specific driver, and various
      fixes and cleanups."
    
    * 'core-efi-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (24 commits)
      efivarfs: Make efivarfs_fill_super() static
      x86, efi: Check table header length in efi_bgrt_init()
      efivarfs: Use query_variable_info() to limit kmalloc()
      efivarfs: Fix return value of efivarfs_file_write()
      efivarfs: Return a consistent error when efivarfs_get_inode() fails
      efivarfs: Make 'datasize' unsigned long
      efivarfs: Add unique magic number
      efivarfs: Replace magic number with sizeof(attributes)
      efivarfs: Return an error if we fail to read a variable
      efi: Clarify GUID length calculations
      efivarfs: Implement exclusive access for {get,set}_variable
      efivarfs: efivarfs_fill_super() ensure we clean up correctly on error
      efivarfs: efivarfs_fill_super() ensure we free our temporary name
      efivarfs: efivarfs_fill_super() fix inode reference counts
      efivarfs: efivarfs_create() ensure we drop our reference on inode on error
      efivarfs: efivarfs_file_read ensure we free data in error paths
      x86-64/efi: Use EFI to deal with platform wall clock (again)
      x86/kernel: remove tboot 1:1 page table creation code
      x86, efi: 1:1 pagetable mapping for virtual EFI calls
      x86, mm: Include the entire kernel memory map in trampoline_pgd
      ...

commit 193c0d682525987db59ac3a24531a77e4947aa95
Merge: 8b0cab14951f 1cb73f8c479e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 13 12:14:47 2012 -0800

    Merge tag 'for-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI update from Bjorn Helgaas:
     "Host bridge hotplug:
       - Untangle _PRT from struct pci_bus (Bjorn Helgaas)
       - Request _OSC control before scanning root bus (Taku Izumi)
       - Assign resources when adding host bridge (Yinghai Lu)
       - Remove root bus when removing host bridge (Yinghai Lu)
       - Remove _PRT during hot remove (Yinghai Lu)
    
      SRIOV
        - Add sysfs knobs to control numVFs (Don Dutile)
    
      Power management
       - Notify devices when power resource turned on (Huang Ying)
    
      Bug fixes
       - Work around broken _SEG on HP xw9300 (Bjorn Helgaas)
       - Keep runtime PM enabled for unbound PCI devices (Huang Ying)
       - Fix Optimus dual-GPU runtime D3 suspend issue (Dave Airlie)
       - Fix xen frontend shutdown issue (David Vrabel)
       - Work around PLX PCI 9050 BAR alignment erratum (Ian Abbott)
    
      Miscellaneous
       - Add GPL license for drivers/pci/ioapic (Andrew Cooks)
       - Add standard PCI-X, PCIe ASPM register #defines (Bjorn Helgaas)
       - NumaChip remote PCI support (Daniel Blueman)
       - Fix PCIe Link Capabilities Supported Link Speed definition (Jingoo
         Han)
       - Convert dev_printk() to dev_info(), etc (Joe Perches)
       - Add support for non PCI BAR ROM data (Matthew Garrett)
       - Add x86 support for host bridge translation offset (Mike Yoknis)
       - Report success only when every driver supports AER (Vijay
         Pandarathil)"
    
    Fix up trivial conflicts.
    
    * tag 'for-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (48 commits)
      PCI: Use phys_addr_t for physical ROM address
      x86/PCI: Add NumaChip remote PCI support
      ath9k: Use standard #defines for PCIe Capability ASPM fields
      iwlwifi: Use standard #defines for PCIe Capability ASPM fields
      iwlwifi: collapse wrapper for pcie_capability_read_word()
      iwlegacy: Use standard #defines for PCIe Capability ASPM fields
      iwlegacy: collapse wrapper for pcie_capability_read_word()
      cxgb3: Use standard #defines for PCIe Capability ASPM fields
      PCI: Add standard PCIe Capability Link ASPM field names
      PCI/portdrv: Use PCI Express Capability accessors
      PCI: Use standard PCIe Capability Link register field names
      x86: Use PCI setup data
      PCI: Add support for non-BAR ROMs
      PCI: Add pcibios_add_device
      EFI: Stash ROMs if they're not in the PCI BAR
      PCI: Add and use standard PCI-X Capability register names
      PCI/PM: Keep runtime PM enabled for unbound PCI devices
      xen-pcifront: Handle backend CLOSED without CLOSING
      PCI: SRIOV control and status via sysfs (documentation)
      PCI/AER: Report success only when every device has AER-aware driver
      ...

commit dd5fc854de5fd37adfcef8a366cd21a55aa01d3d
Author: Matthew Garrett <mjg@redhat.com>
Date:   Wed Dec 5 14:33:26 2012 -0700

    EFI: Stash ROMs if they're not in the PCI BAR
    
    EFI provides support for providing PCI ROMs via means other than the ROM
    BAR. This support vanishes after we've exited boot services, so add support
    for stashing copies of the ROMs in setup_data if they're not otherwise
    available.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Tested-by: Seth Forshee <seth.forshee@canonical.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 8670eb1eb8cd..8eb1be17c801 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -196,6 +196,77 @@ typedef struct {
 	void *create_event_ex;
 } efi_boot_services_t;
 
+typedef enum {
+	EfiPciIoWidthUint8,
+	EfiPciIoWidthUint16,
+	EfiPciIoWidthUint32,
+	EfiPciIoWidthUint64,
+	EfiPciIoWidthFifoUint8,
+	EfiPciIoWidthFifoUint16,
+	EfiPciIoWidthFifoUint32,
+	EfiPciIoWidthFifoUint64,
+	EfiPciIoWidthFillUint8,
+	EfiPciIoWidthFillUint16,
+	EfiPciIoWidthFillUint32,
+	EfiPciIoWidthFillUint64,
+	EfiPciIoWidthMaximum
+} EFI_PCI_IO_PROTOCOL_WIDTH;
+
+typedef enum {
+	EfiPciIoAttributeOperationGet,
+	EfiPciIoAttributeOperationSet,
+	EfiPciIoAttributeOperationEnable,
+	EfiPciIoAttributeOperationDisable,
+	EfiPciIoAttributeOperationSupported,
+    EfiPciIoAttributeOperationMaximum
+} EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION;
+
+
+typedef struct {
+	void *read;
+	void *write;
+} efi_pci_io_protocol_access_t;
+
+typedef struct {
+	void *poll_mem;
+	void *poll_io;
+	efi_pci_io_protocol_access_t mem;
+	efi_pci_io_protocol_access_t io;
+	efi_pci_io_protocol_access_t pci;
+	void *copy_mem;
+	void *map;
+	void *unmap;
+	void *allocate_buffer;
+	void *free_buffer;
+	void *flush;
+	void *get_location;
+	void *attributes;
+	void *get_bar_attributes;
+	void *set_bar_attributes;
+	uint64_t romsize;
+	void *romimage;
+} efi_pci_io_protocol;
+
+#define EFI_PCI_IO_ATTRIBUTE_ISA_MOTHERBOARD_IO 0x0001
+#define EFI_PCI_IO_ATTRIBUTE_ISA_IO 0x0002
+#define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO 0x0004
+#define EFI_PCI_IO_ATTRIBUTE_VGA_MEMORY 0x0008
+#define EFI_PCI_IO_ATTRIBUTE_VGA_IO 0x0010
+#define EFI_PCI_IO_ATTRIBUTE_IDE_PRIMARY_IO 0x0020
+#define EFI_PCI_IO_ATTRIBUTE_IDE_SECONDARY_IO 0x0040
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY_WRITE_COMBINE 0x0080
+#define EFI_PCI_IO_ATTRIBUTE_IO 0x0100
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY 0x0200
+#define EFI_PCI_IO_ATTRIBUTE_BUS_MASTER 0x0400
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY_CACHED 0x0800
+#define EFI_PCI_IO_ATTRIBUTE_MEMORY_DISABLE 0x1000
+#define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_DEVICE 0x2000
+#define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_ROM 0x4000
+#define EFI_PCI_IO_ATTRIBUTE_DUAL_ADDRESS_CYCLE 0x8000
+#define EFI_PCI_IO_ATTRIBUTE_ISA_IO_16 0x10000
+#define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO_16 0x20000
+#define EFI_PCI_IO_ATTRIBUTE_VGA_IO_16 0x40000
+
 /*
  * Types and defines for EFI ResetSystem
  */

commit d80a361d779a9f19498943d1ca84243209cd5647
Author: Seiji Aguchi <seiji.aguchi@hds.com>
Date:   Wed Nov 14 20:25:37 2012 +0000

    efi_pstore: Check remaining space with QueryVariableInfo() before writing data
    
    [Issue]
    
    As discussed in a thread below, Running out of space in EFI isn't a well-tested scenario.
    And we wouldn't expect all firmware to handle it gracefully.
    http://marc.info/?l=linux-kernel&m=134305325801789&w=2
    
    On the other hand, current efi_pstore doesn't check a remaining space of storage at writing time.
    Therefore, efi_pstore may not work if it tries to write a large amount of data.
    
    [Patch Description]
    
    To avoid handling the situation above, this patch checks if there is a space enough to log with
    QueryVariableInfo() before writing data.
    
    Signed-off-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Acked-by: Mike Waychison <mikew@google.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 8670eb1eb8cd..c47ec36f3f39 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -643,6 +643,7 @@ struct efivar_operations {
 	efi_get_variable_t *get_variable;
 	efi_get_next_variable_t *get_next_variable;
 	efi_set_variable_t *set_variable;
+	efi_query_variable_info_t *query_variable_info;
 };
 
 struct efivars {

commit 89d16665d388837b30972081d97b814be26d68a2
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Fri Nov 9 21:02:56 2012 +0000

    efivarfs: Use query_variable_info() to limit kmalloc()
    
    We don't want someone who can write EFI variables to be able to
    allocate arbitrarily large amounts of memory, so cap it to something
    sensible like the amount of free space for EFI variables.
    
    Acked-by: Jeremy Kerr <jeremy.kerr@canonical.com>
    Cc: Matthew Garrett <mjg@redhat.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 5e2308d9c6be..f80079cd84f4 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -646,6 +646,7 @@ struct efivar_operations {
 	efi_get_variable_t *get_variable;
 	efi_get_next_variable_t *get_next_variable;
 	efi_set_variable_t *set_variable;
+	efi_query_variable_info_t *query_variable_info;
 };
 
 struct efivars {

commit bd52276fa1d420c3a504b76ffaaa1642cc79d4c4
Author: Jan Beulich <JBeulich@suse.com>
Date:   Fri May 25 16:20:31 2012 +0100

    x86-64/efi: Use EFI to deal with platform wall clock (again)
    
    Other than ix86, x86-64 on EFI so far didn't set the
    {g,s}et_wallclock accessors to the EFI routines, thus
    incorrectly using raw RTC accesses instead.
    
    Simply removing the #ifdef around the respective code isn't
    enough, however: While so far early get-time calls were done in
    physical mode, this doesn't work properly for x86-64, as virtual
    addresses would still need to be set up for all runtime regions
    (which wasn't the case on the system I have access to), so
    instead the patch moves the call to efi_enter_virtual_mode()
    ahead (which in turn allows to drop all code related to calling
    efi-get-time in physical mode).
    
    Additionally the earlier calling of efi_set_executable()
    requires the CPA code to cope, i.e. during early boot it must be
    avoided to call cpa_flush_array(), as the first thing this
    function does is a BUG_ON(irqs_disabled()).
    
    Also make the two EFI functions in question here static -
    they're not being referenced elsewhere.
    
    History:
    
        This commit was originally merged as bacef661acdb ("x86-64/efi:
        Use EFI to deal with platform wall clock") but it resulted in some
        ASUS machines no longer booting due to a firmware bug, and so was
        reverted in f026cfa82f62. A pre-emptive fix for the buggy ASUS
        firmware was merged in 03a1c254975e ("x86, efi: 1:1 pagetable
        mapping for virtual EFI calls") so now this patch can be
        reapplied.
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Tested-by: Matt Fleming <matt.fleming@intel.com>
    Acked-by: Matthew Garrett <mjg@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com> [added commit history]

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 337aefbfb003..5e2308d9c6be 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -516,8 +516,6 @@ extern u64 efi_mem_attribute (unsigned long phys_addr, unsigned long size);
 extern int __init efi_uart_console_only (void);
 extern void efi_initialize_iomem_resources(struct resource *code_resource,
 		struct resource *data_resource, struct resource *bss_resource);
-extern unsigned long efi_get_time(void);
-extern int efi_set_rtc_mmss(unsigned long nowtime);
 extern void efi_reserve_boot_services(void);
 extern struct efi_memory_map memmap;
 

commit 605e70c7aa1b7b0d554baf945630c1d606bbfbc3
Author: Lee, Chun-Yi <joeyli.kernel@gmail.com>
Date:   Fri Oct 5 13:54:56 2012 +0800

    efi: add efivars kobject to efi sysfs folder
    
    UEFI variable filesystem need a new mount point, so this patch add
    efivars kobject to efi_kobj for create a /sys/firmware/efi/efivars
    folder.
    
    Cc: Matthew Garrett <mjg@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Lee, Chun-Yi <jlee@suse.com>
    Signed-off-by: Jeremy Kerr <jeremy.kerr@canonical.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index b2af1571592b..337aefbfb003 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -662,6 +662,7 @@ struct efivars {
 	spinlock_t lock;
 	struct list_head list;
 	struct kset *kset;
+	struct kobject *kobject;
 	struct bin_attribute *new_var, *del_var;
 	const struct efivar_operations *ops;
 	struct efivar_entry *walk_entry;

commit 5d9db883761ad1bc2245fd3018715549b974203d
Author: Matthew Garrett <mjg@redhat.com>
Date:   Fri Oct 5 13:54:56 2012 +0800

    efi: Add support for a UEFI variable filesystem
    
    The existing EFI variables code only supports variables of up to 1024
    bytes. This limitation existed in version 0.99 of the EFI specification,
    but was removed before any full releases. Since variables can now be
    larger than a single page, sysfs isn't the best interface for this. So,
    instead, let's add a filesystem. Variables can be read, written and
    created, with the first 4 bytes of each variable representing its UEFI
    attributes. The create() method doesn't actually commit to flash since
    zero-length variables can't exist per-spec.
    
    Updates from Jeremy Kerr <jeremy.kerr@canonical.com>.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Jeremy Kerr <jeremy.kerr@canonical.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 8670eb1eb8cd..b2af1571592b 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -29,7 +29,12 @@
 #define EFI_UNSUPPORTED		( 3 | (1UL << (BITS_PER_LONG-1)))
 #define EFI_BAD_BUFFER_SIZE     ( 4 | (1UL << (BITS_PER_LONG-1)))
 #define EFI_BUFFER_TOO_SMALL	( 5 | (1UL << (BITS_PER_LONG-1)))
+#define EFI_NOT_READY		( 6 | (1UL << (BITS_PER_LONG-1)))
+#define EFI_DEVICE_ERROR	( 7 | (1UL << (BITS_PER_LONG-1)))
+#define EFI_WRITE_PROTECTED	( 8 | (1UL << (BITS_PER_LONG-1)))
+#define EFI_OUT_OF_RESOURCES	( 9 | (1UL << (BITS_PER_LONG-1)))
 #define EFI_NOT_FOUND		(14 | (1UL << (BITS_PER_LONG-1)))
+#define EFI_SECURITY_VIOLATION	(26 | (1UL << (BITS_PER_LONG-1)))
 
 typedef unsigned long efi_status_t;
 typedef u8 efi_bool_t;

commit 2223af389032425e3d1a70f9cb3a63feaa654ced
Author: Josh Triplett <josh@joshtriplett.org>
Date:   Fri Sep 28 17:57:05 2012 -0700

    efi: Fix the ACPI BGRT driver for images located in EFI boot services memory
    
    The ACPI BGRT driver accesses the BIOS logo image when it initializes.
    However, ACPI 5.0 (which introduces the BGRT) recommends putting the
    logo image in EFI boot services memory, so that the OS can reclaim that
    memory.  Production systems follow this recommendation, breaking the
    ACPI BGRT driver.
    
    Move the bulk of the BGRT code to run during a new EFI late
    initialization phase, which occurs after switching EFI to virtual mode,
    and after initializing ACPI, but before freeing boot services memory.
    Copy the BIOS logo image to kernel memory at that point, and make it
    accessible to the BGRT driver.  Rework the existing ACPI BGRT driver to
    act as a simple wrapper exposing that image (and the properties from the
    BGRT) via sysfs.
    
    Signed-off-by: Josh Triplett <josh@joshtriplett.org>
    Link: http://lkml.kernel.org/r/93ce9f823f1c1f3bb88bdd662cce08eee7a17f5d.1348876882.git.josh@joshtriplett.org
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index fff135d9375e..8670eb1eb8cd 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -497,8 +497,10 @@ extern void efi_memmap_walk (efi_freemem_callback_t callback, void *arg);
 extern void efi_gettimeofday (struct timespec *ts);
 extern void efi_enter_virtual_mode (void);	/* switch EFI to virtual mode, if possible */
 #ifdef CONFIG_X86
+extern void efi_late_init(void);
 extern void efi_free_boot_services(void);
 #else
+static inline void efi_late_init(void) {}
 static inline void efi_free_boot_services(void) {}
 #endif
 extern void __iomem *efi_lookup_mapped_addr(u64 phys_addr);

commit 7bc90e01c3f66c137e7e761f574bbf883087d590
Author: Josh Triplett <josh@joshtriplett.org>
Date:   Fri Sep 28 17:56:08 2012 -0700

    efi: Add a function to look up existing IO memory mappings
    
    The EFI initialization creates virtual mappings for EFI boot services
    memory, so if a driver wants to access EFI boot services memory, it
    cannot call ioremap itself; doing so will trip the WARN about mapping
    RAM twice.  Thus, a driver accessing EFI boot services memory must do so
    via the existing mapping already created during EFI intiialization.
    Since the EFI code already maintains a memory map for that memory, add a
    function efi_lookup_mapped_addr to look up mappings in that memory map.
    
    Signed-off-by: Josh Triplett <josh@joshtriplett.org>
    Link: http://lkml.kernel.org/r/0eb48ae012797912874919110660ad420b90268b.1348876882.git.josh@joshtriplett.org
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 5782114f4838..fff135d9375e 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -501,6 +501,7 @@ extern void efi_free_boot_services(void);
 #else
 static inline void efi_free_boot_services(void) {}
 #endif
+extern void __iomem *efi_lookup_mapped_addr(u64 phys_addr);
 extern u64 efi_get_iobase (void);
 extern u32 efi_mem_type (unsigned long phys_addr);
 extern u64 efi_mem_attributes (unsigned long phys_addr);

commit 785107923a83d8456bbd8564e288a24d84109a46
Author: Josh Triplett <josh@joshtriplett.org>
Date:   Fri Sep 28 17:55:44 2012 -0700

    efi: Defer freeing boot services memory until after ACPI init
    
    Some new ACPI 5.0 tables reference resources stored in boot services
    memory, so keep that memory around until we have ACPI and can extract
    data from it.
    
    Signed-off-by: Josh Triplett <josh@joshtriplett.org>
    Link: http://lkml.kernel.org/r/baaa6d44bdc4eb0c58e5d1b4ccd2c729f854ac55.1348876882.git.josh@joshtriplett.org
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index ec45ccd8708a..5782114f4838 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -496,6 +496,11 @@ extern void efi_map_pal_code (void);
 extern void efi_memmap_walk (efi_freemem_callback_t callback, void *arg);
 extern void efi_gettimeofday (struct timespec *ts);
 extern void efi_enter_virtual_mode (void);	/* switch EFI to virtual mode, if possible */
+#ifdef CONFIG_X86
+extern void efi_free_boot_services(void);
+#else
+static inline void efi_free_boot_services(void) {}
+#endif
 extern u64 efi_get_iobase (void);
 extern u32 efi_mem_type (unsigned long phys_addr);
 extern u64 efi_mem_attributes (unsigned long phys_addr);

commit f026cfa82f628db24b8cea41b9d6202af104cecb
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Tue Aug 14 09:53:38 2012 -0700

    Revert "x86-64/efi: Use EFI to deal with platform wall clock"
    
    This reverts commit bacef661acdb634170a8faddbc1cf28e8f8b9eee.
    
    This commit has been found to cause serious regressions on a number of
    ASUS machines at the least.  We probably need to provide a 1:1 map in
    addition to the EFI virtual memory map in order for this to work.
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>
    Reported-and-bisected-by: Jérôme Carretero <cJ-ko@zougloub.eu>
    Cc: Jan Beulich <jbeulich@suse.com>
    Cc: Matt Fleming <matt.fleming@intel.com>
    Cc: Matthew Garrett <mjg@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/20120805172903.5f8bb24c@zougloub.eu

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 103adc6d7e3a..ec45ccd8708a 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -503,6 +503,8 @@ extern u64 efi_mem_attribute (unsigned long phys_addr, unsigned long size);
 extern int __init efi_uart_console_only (void);
 extern void efi_initialize_iomem_resources(struct resource *code_resource,
 		struct resource *data_resource, struct resource *bss_resource);
+extern unsigned long efi_get_time(void);
+extern int efi_set_rtc_mmss(unsigned long nowtime);
 extern void efi_reserve_boot_services(void);
 extern struct efi_memory_map memmap;
 

commit bacef661acdb634170a8faddbc1cf28e8f8b9eee
Author: Jan Beulich <JBeulich@suse.com>
Date:   Fri May 25 16:20:31 2012 +0100

    x86-64/efi: Use EFI to deal with platform wall clock
    
    Other than ix86, x86-64 on EFI so far didn't set the
    {g,s}et_wallclock accessors to the EFI routines, thus
    incorrectly using raw RTC accesses instead.
    
    Simply removing the #ifdef around the respective code isn't
    enough, however: While so far early get-time calls were done in
    physical mode, this doesn't work properly for x86-64, as virtual
    addresses would still need to be set up for all runtime regions
    (which wasn't the case on the system I have access to), so
    instead the patch moves the call to efi_enter_virtual_mode()
    ahead (which in turn allows to drop all code related to calling
    efi-get-time in physical mode).
    
    Additionally the earlier calling of efi_set_executable()
    requires the CPA code to cope, i.e. during early boot it must be
    avoided to call cpa_flush_array(), as the first thing this
    function does is a BUG_ON(irqs_disabled()).
    
    Also make the two EFI functions in question here static -
    they're not being referenced elsewhere.
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Tested-by: Matt Fleming <matt.fleming@intel.com>
    Acked-by: Matthew Garrett <mjg@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/4FBFBF5F020000780008637F@nat28.tlf.novell.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index ec45ccd8708a..103adc6d7e3a 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -503,8 +503,6 @@ extern u64 efi_mem_attribute (unsigned long phys_addr, unsigned long size);
 extern int __init efi_uart_console_only (void);
 extern void efi_initialize_iomem_resources(struct resource *code_resource,
 		struct resource *data_resource, struct resource *bss_resource);
-extern unsigned long efi_get_time(void);
-extern int efi_set_rtc_mmss(unsigned long nowtime);
 extern void efi_reserve_boot_services(void);
 extern struct efi_memory_map memmap;
 

commit 41b3254c93acc56adc3c4477fef7c9512d47659e
Author: Matthew Garrett <mjg@redhat.com>
Date:   Mon Apr 30 16:11:29 2012 -0400

    efi: Add new variable attributes
    
    More recent versions of the UEFI spec have added new attributes for
    variables. Add them.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 88ec80670d5f..ec45ccd8708a 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -554,7 +554,18 @@ extern int __init efi_setup_pcdp_console(char *);
 #define EFI_VARIABLE_NON_VOLATILE       0x0000000000000001
 #define EFI_VARIABLE_BOOTSERVICE_ACCESS 0x0000000000000002
 #define EFI_VARIABLE_RUNTIME_ACCESS     0x0000000000000004
-
+#define EFI_VARIABLE_HARDWARE_ERROR_RECORD 0x0000000000000008
+#define EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS 0x0000000000000010
+#define EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS 0x0000000000000020
+#define EFI_VARIABLE_APPEND_WRITE	0x0000000000000040
+
+#define EFI_VARIABLE_MASK 	(EFI_VARIABLE_NON_VOLATILE | \
+				EFI_VARIABLE_BOOTSERVICE_ACCESS | \
+				EFI_VARIABLE_RUNTIME_ACCESS | \
+				EFI_VARIABLE_HARDWARE_ERROR_RECORD | \
+				EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS | \
+				EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS | \
+				EFI_VARIABLE_APPEND_WRITE)
 /*
  * The type of search to perform when calling boottime->locate_handle
  */

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 47fbf6b3dc77..88ec80670d5f 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -22,7 +22,6 @@
 #include <linux/pstore.h>
 
 #include <asm/page.h>
-#include <asm/system.h>
 
 #define EFI_SUCCESS		0
 #define EFI_LOAD_ERROR          ( 1 | (1UL << (BITS_PER_LONG-1)))

commit 1adbfa3511ee1c1118e16a9a0246870f12fef4e6
Author: Olof Johansson <olof@lixom.net>
Date:   Sun Feb 12 13:24:29 2012 -0800

    x86, efi: Allow basic init with mixed 32/64-bit efi/kernel
    
    Traditionally the kernel has refused to setup EFI at all if there's been
    a mismatch in 32/64-bit mode between EFI and the kernel.
    
    On some platforms that boot natively through EFI (Chrome OS being one),
    we still need to get at least some of the static data such as memory
    configuration out of EFI. Runtime services aren't as critical, and
    it's a significant amount of work to implement switching between the
    operating modes to call between kernel and firmware for thise cases. So
    I'm ignoring it for now.
    
    v5:
    * Fixed some printk strings based on feedback
    * Renamed 32/64-bit specific types to not have _ prefix
    * Fixed bug in printout of efi runtime disablement
    
    v4:
    * Some of the earlier cleanup was accidentally reverted by this patch, fixed.
    * Reworded some messages to not have to line wrap printk strings
    
    v3:
    * Reorganized to a series of patches to make it easier to review, and
      do some of the cleanups I had left out before.
    
    v2:
    * Added graceful error handling for 32-bit kernel that gets passed
      EFI data above 4GB.
    * Removed some warnings that were missed in first version.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Link: http://lkml.kernel.org/r/1329081869-20779-6-git-send-email-olof@lixom.net
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 37c300712e02..47fbf6b3dc77 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -313,6 +313,16 @@ typedef efi_status_t efi_query_capsule_caps_t(efi_capsule_header_t **capsules,
 #define EFI_FILE_SYSTEM_GUID \
     EFI_GUID(  0x964e5b22, 0x6459, 0x11d2, 0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b )
 
+typedef struct {
+	efi_guid_t guid;
+	u64 table;
+} efi_config_table_64_t;
+
+typedef struct {
+	efi_guid_t guid;
+	u32 table;
+} efi_config_table_32_t;
+
 typedef struct {
 	efi_guid_t guid;
 	unsigned long table;
@@ -327,6 +337,40 @@ typedef struct {
 #define EFI_1_10_SYSTEM_TABLE_REVISION  ((1 << 16) | (10))
 #define EFI_1_02_SYSTEM_TABLE_REVISION  ((1 << 16) | (02))
 
+typedef struct {
+	efi_table_hdr_t hdr;
+	u64 fw_vendor;	/* physical addr of CHAR16 vendor string */
+	u32 fw_revision;
+	u32 __pad1;
+	u64 con_in_handle;
+	u64 con_in;
+	u64 con_out_handle;
+	u64 con_out;
+	u64 stderr_handle;
+	u64 stderr;
+	u64 runtime;
+	u64 boottime;
+	u32 nr_tables;
+	u32 __pad2;
+	u64 tables;
+} efi_system_table_64_t;
+
+typedef struct {
+	efi_table_hdr_t hdr;
+	u32 fw_vendor;	/* physical addr of CHAR16 vendor string */
+	u32 fw_revision;
+	u32 con_in_handle;
+	u32 con_in;
+	u32 con_out_handle;
+	u32 con_out;
+	u32 stderr_handle;
+	u32 stderr;
+	u32 runtime;
+	u32 boottime;
+	u32 nr_tables;
+	u32 tables;
+} efi_system_table_32_t;
+
 typedef struct {
 	efi_table_hdr_t hdr;
 	unsigned long fw_vendor;	/* physical addr of CHAR16 vendor string */
@@ -497,6 +541,7 @@ extern int __init efi_setup_pcdp_console(char *);
 #ifdef CONFIG_EFI
 # ifdef CONFIG_X86
    extern int efi_enabled;
+   extern bool efi_64bit;
 # else
 #  define efi_enabled 1
 # endif

commit 55839d515495e766605d7aaabd9c2758370a8d27
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Thu Aug 11 10:28:06 2011 +0100

    efi: Add EFI file I/O data types
    
    The x86 EFI stub needs to access files, for example when loading
    initrd's. Add the required data types.
    
    Cc: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Link: http://lkml.kernel.org/r/1318848017-12301-1-git-send-email-matt@console-pimps.org
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index d407c88f955f..37c300712e02 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -307,6 +307,12 @@ typedef efi_status_t efi_query_capsule_caps_t(efi_capsule_header_t **capsules,
 #define EFI_PCI_IO_PROTOCOL_GUID \
     EFI_GUID(  0x4cf5b200, 0x68b8, 0x4ca5, 0x9e, 0xec, 0xb2, 0x3e, 0x3f, 0x50, 0x2, 0x9a )
 
+#define EFI_FILE_INFO_ID \
+    EFI_GUID(  0x9576e92, 0x6d3f, 0x11d2, 0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b )
+
+#define EFI_FILE_SYSTEM_GUID \
+    EFI_GUID(  0x964e5b22, 0x6459, 0x11d2, 0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b )
+
 typedef struct {
 	efi_guid_t guid;
 	unsigned long table;
@@ -362,6 +368,40 @@ typedef struct {
 	unsigned long unload;
 } efi_loaded_image_t;
 
+typedef struct {
+	u64 revision;
+	void *open_volume;
+} efi_file_io_interface_t;
+
+typedef struct {
+	u64 size;
+	u64 file_size;
+	u64 phys_size;
+	efi_time_t create_time;
+	efi_time_t last_access_time;
+	efi_time_t modification_time;
+	__aligned_u64 attribute;
+	efi_char16_t filename[1];
+} efi_file_info_t;
+
+typedef struct {
+	u64 revision;
+	void *open;
+	void *close;
+	void *delete;
+	void *read;
+	void *write;
+	void *get_position;
+	void *set_position;
+	void *get_info;
+	void *set_info;
+	void *flush;
+} efi_file_handle_t;
+
+#define EFI_FILE_MODE_READ	0x0000000000000001
+#define EFI_FILE_MODE_WRITE	0x0000000000000002
+#define EFI_FILE_MODE_CREATE	0x8000000000000000
+
 #define EFI_INVALID_TABLE_ADDR		(~0UL)
 
 /*

commit e2527a7cbec073b69a251193f200a88efbced7ad
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Tue Nov 15 12:57:26 2011 +0000

    efi.h: Add boottime->locate_handle search types
    
    The x86 EFI boot stub needs to locate handles for various protocols.
    
    Cc: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Link: http://lkml.kernel.org/r/1318848017-12301-1-git-send-email-matt@console-pimps.org
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index e46d771f87e5..d407c88f955f 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -471,6 +471,13 @@ extern int __init efi_setup_pcdp_console(char *);
 #define EFI_VARIABLE_BOOTSERVICE_ACCESS 0x0000000000000002
 #define EFI_VARIABLE_RUNTIME_ACCESS     0x0000000000000004
 
+/*
+ * The type of search to perform when calling boottime->locate_handle
+ */
+#define EFI_LOCATE_ALL_HANDLES			0
+#define EFI_LOCATE_BY_REGISTER_NOTIFY		1
+#define EFI_LOCATE_BY_PROTOCOL			2
+
 /*
  * EFI Device Path information
  */

commit 0f7c5d477f2ce552997831d80e2c872cca1b9054
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Tue Nov 15 12:57:16 2011 +0000

    efi.h: Add graphics protocol guids
    
    The x86 EFI boot stub uses the Graphics Output Protocol and Universal
    Graphics Adapter (UGA) protocol guids when initialising graphics
    during boot.
    
    Cc: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Link: http://lkml.kernel.org/r/1318848017-12301-1-git-send-email-matt@console-pimps.org
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 378f2cd1f7c3..e46d771f87e5 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -298,6 +298,15 @@ typedef efi_status_t efi_query_capsule_caps_t(efi_capsule_header_t **capsules,
 #define LOADED_IMAGE_PROTOCOL_GUID \
     EFI_GUID(  0x5b1b31a1, 0x9562, 0x11d2, 0x8e, 0x3f, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b )
 
+#define EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID \
+    EFI_GUID(  0x9042a9de, 0x23dc, 0x4a38, 0x96, 0xfb, 0x7a, 0xde, 0xd0, 0x80, 0x51, 0x6a )
+
+#define EFI_UGA_PROTOCOL_GUID \
+    EFI_GUID(  0x982c298b, 0xf4fa, 0x41cb, 0xb8, 0x38, 0x77, 0xaa, 0x68, 0x8f, 0xb8, 0x39 )
+
+#define EFI_PCI_IO_PROTOCOL_GUID \
+    EFI_GUID(  0x4cf5b200, 0x68b8, 0x4ca5, 0x9e, 0xec, 0xb2, 0x3e, 0x3f, 0x50, 0x2, 0x9a )
+
 typedef struct {
 	efi_guid_t guid;
 	unsigned long table;

commit bb05e4ba452ada7966fbced4e829aa029f546445
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Tue Nov 15 12:57:03 2011 +0000

    efi.h: Add allocation types for boottime->allocate_pages()
    
    Add the allocation types detailed in section 6.2 - "AllocatePages()"
    of the UEFI 2.3 specification. These definitions will be used by the
    x86 EFI boot stub which needs to allocate memory during boot.
    
    Cc: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Link: http://lkml.kernel.org/r/1318848017-12301-1-git-send-email-matt@console-pimps.org
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index e35005f451db..378f2cd1f7c3 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -109,6 +109,14 @@ typedef struct {
 	u32 imagesize;
 } efi_capsule_header_t;
 
+/*
+ * Allocation types for calls to boottime->allocate_pages.
+ */
+#define EFI_ALLOCATE_ANY_PAGES		0
+#define EFI_ALLOCATE_MAX_ADDRESS	1
+#define EFI_ALLOCATE_ADDRESS		2
+#define EFI_MAX_ALLOCATE_TYPE		3
+
 typedef int (*efi_freemem_callback_t) (u64 start, u64 end, void *arg);
 
 /*

commit 8e84f345e2f2189a37492c77c566c7494b7b6b23
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Tue Nov 15 12:56:50 2011 +0000

    efi.h: Add efi_image_loaded_t
    
    Add the EFI loaded image structure and protocol guid which are
    required by the x86 EFI boot stub. The EFI boot stub uses the
    structure to figure out where it was loaded in memory and to pass
    command line arguments to the kernel.
    
    Cc: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Link: http://lkml.kernel.org/r/1318848017-12301-1-git-send-email-matt@console-pimps.org
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 9547597ad6be..e35005f451db 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -287,6 +287,9 @@ typedef efi_status_t efi_query_capsule_caps_t(efi_capsule_header_t **capsules,
 #define LINUX_EFI_CRASH_GUID \
     EFI_GUID(  0xcfc8fc79, 0xbe2e, 0x4ddc, 0x97, 0xf0, 0x9f, 0x98, 0xbf, 0xe2, 0x98, 0xa0 )
 
+#define LOADED_IMAGE_PROTOCOL_GUID \
+    EFI_GUID(  0x5b1b31a1, 0x9562, 0x11d2, 0x8e, 0x3f, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b )
+
 typedef struct {
 	efi_guid_t guid;
 	unsigned long table;
@@ -326,6 +329,22 @@ struct efi_memory_map {
 	unsigned long desc_size;
 };
 
+typedef struct {
+	u32 revision;
+	void *parent_handle;
+	efi_system_table_t *system_table;
+	void *device_handle;
+	void *file_path;
+	void *reserved;
+	u32 load_options_size;
+	void *load_options;
+	void *image_base;
+	__aligned_u64 image_size;
+	unsigned int image_code_type;
+	unsigned int image_data_type;
+	unsigned long unload;
+} efi_loaded_image_t;
+
 #define EFI_INVALID_TABLE_ADDR		(~0UL)
 
 /*

commit f30ca6ba0bb2b7d050f24682bb8639c939c79859
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Tue Nov 15 12:56:32 2011 +0000

    efi.h: Add struct definition for boot time services
    
    With the forthcoming efi stub code we're gonna need to access boot
    time services so let's define a struct so we can access the functions.
    
    Cc: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Link: http://lkml.kernel.org/r/1318848017-12301-1-git-send-email-matt@console-pimps.org
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 2362a0bc7f0d..9547597ad6be 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -138,6 +138,57 @@ typedef struct {
 	u8 sets_to_zero;
 } efi_time_cap_t;
 
+/*
+ * EFI Boot Services table
+ */
+typedef struct {
+	efi_table_hdr_t hdr;
+	void *raise_tpl;
+	void *restore_tpl;
+	void *allocate_pages;
+	void *free_pages;
+	void *get_memory_map;
+	void *allocate_pool;
+	void *free_pool;
+	void *create_event;
+	void *set_timer;
+	void *wait_for_event;
+	void *signal_event;
+	void *close_event;
+	void *check_event;
+	void *install_protocol_interface;
+	void *reinstall_protocol_interface;
+	void *uninstall_protocol_interface;
+	void *handle_protocol;
+	void *__reserved;
+	void *register_protocol_notify;
+	void *locate_handle;
+	void *locate_device_path;
+	void *install_configuration_table;
+	void *load_image;
+	void *start_image;
+	void *exit;
+	void *unload_image;
+	void *exit_boot_services;
+	void *get_next_monotonic_count;
+	void *stall;
+	void *set_watchdog_timer;
+	void *connect_controller;
+	void *disconnect_controller;
+	void *open_protocol;
+	void *close_protocol;
+	void *open_protocol_information;
+	void *protocols_per_handle;
+	void *locate_handle_buffer;
+	void *locate_protocol;
+	void *install_multiple_protocol_interfaces;
+	void *uninstall_multiple_protocol_interfaces;
+	void *calculate_crc32;
+	void *copy_mem;
+	void *set_mem;
+	void *create_event_ex;
+} efi_boot_services_t;
+
 /*
  * Types and defines for EFI ResetSystem
  */
@@ -261,7 +312,7 @@ typedef struct {
 	unsigned long stderr_handle;
 	unsigned long stderr;
 	efi_runtime_services_t *runtime;
-	unsigned long boottime;
+	efi_boot_services_t *boottime;
 	unsigned long nr_tables;
 	unsigned long tables;
 } efi_system_table_t;

commit a2d773023552f68baa2db2226dfd6d761c0df5da
Merge: 72f9adfd20e3 7644c16c7e74
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 1 13:40:51 2011 -1000

    Merge branch 'pstore-efi' of git://git.kernel.org/pub/scm/linux/kernel/git/aegl/linux-2.6
    
    * 'pstore-efi' of git://git.kernel.org/pub/scm/linux/kernel/git/aegl/linux-2.6:
      efivars: Introduce PSTORE_EFI_ATTRIBUTES
      efivars: Use string functions in pstore_write
      efivars: introduce utf16_strncmp
      efivars: String functions
      efi: Add support for using efivars as a pstore backend
      pstore: Allow the user to explicitly choose a backend
      pstore: Make "part" unsigned
      pstore: Add extra context for writes and erases
      pstore: Extend API for more flexibility in new backends

commit 5ee9c198a4208d7760275d48e4c4f6c89dcd2ef0
Author: Matthew Garrett <mjg@redhat.com>
Date:   Thu Jul 21 16:57:56 2011 -0400

    efi: Add support for using efivars as a pstore backend
    
    EFI provides an area of nonvolatile storage managed by the firmware. We
    can use this as a pstore backend to maintain copies of oopses, aiding
    diagnosis.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index e376270cd26e..c1f5107338c6 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -19,6 +19,7 @@
 #include <linux/rtc.h>
 #include <linux/ioport.h>
 #include <linux/pfn.h>
+#include <linux/pstore.h>
 
 #include <asm/page.h>
 #include <asm/system.h>
@@ -211,6 +212,9 @@ typedef efi_status_t efi_set_virtual_address_map_t (unsigned long memory_map_siz
 #define UV_SYSTEM_TABLE_GUID \
     EFI_GUID(  0x3b13a7d4, 0x633e, 0x11dd, 0x93, 0xec, 0xda, 0x25, 0x56, 0xd8, 0x95, 0x93 )
 
+#define LINUX_EFI_CRASH_GUID \
+    EFI_GUID(  0xcfc8fc79, 0xbe2e, 0x4ddc, 0x97, 0xf0, 0x9f, 0x98, 0xbf, 0xe2, 0x98, 0xa0 )
+
 typedef struct {
 	efi_guid_t guid;
 	unsigned long table;
@@ -426,6 +430,8 @@ struct efivars {
 	struct kset *kset;
 	struct bin_attribute *new_var, *del_var;
 	const struct efivar_operations *ops;
+	struct efivar_entry *walk_entry;
+	struct pstore_info efi_pstore_info;
 };
 
 int register_efivars(struct efivars *efivars,

commit 3b3702377c576f6624348c7c6fd113bfd934fbd7
Author: Matthew Garrett <mjg@redhat.com>
Date:   Mon Jun 6 15:36:25 2011 -0400

    x86, efi: Add infrastructure for UEFI 2.0 runtime services
    
    We're currently missing support for any of the runtime service calls
    introduced with the UEFI 2.0 spec in 2006. Add the infrastructure for
    supporting them.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Link: http://lkml.kernel.org/r/1307388985-7852-2-git-send-email-mjg@redhat.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 0758753a17a1..ec2572693925 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -101,6 +101,13 @@ typedef struct {
 	u64 attribute;
 } efi_memory_desc_t;
 
+typedef struct {
+	efi_guid_t guid;
+	u32 headersize;
+	u32 flags;
+	u32 imagesize;
+} efi_capsule_header_t;
+
 typedef int (*efi_freemem_callback_t) (u64 start, u64 end, void *arg);
 
 /*
@@ -156,6 +163,9 @@ typedef struct {
 	unsigned long set_variable;
 	unsigned long get_next_high_mono_count;
 	unsigned long reset_system;
+	unsigned long update_capsule;
+	unsigned long query_capsule_caps;
+	unsigned long query_variable_info;
 } efi_runtime_services_t;
 
 typedef efi_status_t efi_get_time_t (efi_time_t *tm, efi_time_cap_t *tc);
@@ -177,6 +187,17 @@ typedef efi_status_t efi_set_virtual_address_map_t (unsigned long memory_map_siz
 						unsigned long descriptor_size,
 						u32 descriptor_version,
 						efi_memory_desc_t *virtual_map);
+typedef efi_status_t efi_query_variable_info_t(u32 attr,
+					       u64 *storage_space,
+					       u64 *remaining_space,
+					       u64 *max_variable_size);
+typedef efi_status_t efi_update_capsule_t(efi_capsule_header_t **capsules,
+					  unsigned long count,
+					  unsigned long sg_list);
+typedef efi_status_t efi_query_capsule_caps_t(efi_capsule_header_t **capsules,
+					      unsigned long count,
+					      u64 *max_size,
+					      int *reset_type);
 
 /*
  *  EFI Configuration Table and GUID definitions
@@ -218,6 +239,13 @@ typedef struct {
 
 #define EFI_SYSTEM_TABLE_SIGNATURE ((u64)0x5453595320494249ULL)
 
+#define EFI_2_30_SYSTEM_TABLE_REVISION  ((2 << 16) | (30))
+#define EFI_2_20_SYSTEM_TABLE_REVISION  ((2 << 16) | (20))
+#define EFI_2_10_SYSTEM_TABLE_REVISION  ((2 << 16) | (10))
+#define EFI_2_00_SYSTEM_TABLE_REVISION  ((2 << 16) | (00))
+#define EFI_1_10_SYSTEM_TABLE_REVISION  ((1 << 16) | (10))
+#define EFI_1_02_SYSTEM_TABLE_REVISION  ((1 << 16) | (02))
+
 typedef struct {
 	efi_table_hdr_t hdr;
 	unsigned long fw_vendor;	/* physical addr of CHAR16 vendor string */
@@ -250,6 +278,7 @@ struct efi_memory_map {
  */
 extern struct efi {
 	efi_system_table_t *systab;	/* EFI system table */
+	unsigned int runtime_version;	/* Runtime services version */
 	unsigned long mps;		/* MPS table */
 	unsigned long acpi;		/* ACPI table  (IA64 ext 0.71) */
 	unsigned long acpi20;		/* ACPI table  (ACPI 2.0) */
@@ -266,6 +295,9 @@ extern struct efi {
 	efi_get_variable_t *get_variable;
 	efi_get_next_variable_t *get_next_variable;
 	efi_set_variable_t *set_variable;
+	efi_query_variable_info_t *query_variable_info;
+	efi_update_capsule_t *update_capsule;
+	efi_query_capsule_caps_t *query_capsule_caps;
 	efi_get_next_high_mono_count_t *get_next_high_mono_count;
 	efi_reset_system_t *reset_system;
 	efi_set_virtual_address_map_t *set_virtual_address_map;

commit f7a2d73fe75c71941fb0a6b4d8fe7da8144f2c7b
Author: Matthew Garrett <mjg@redhat.com>
Date:   Mon Jun 6 15:36:24 2011 -0400

    x86, efi: Fix argument types for SetVariable()
    
    The spec says this takes uint32 for attributes, not uintn.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Link: http://lkml.kernel.org/r/1307388985-7852-1-git-send-email-mjg@redhat.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index e376270cd26e..0758753a17a1 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -168,7 +168,7 @@ typedef efi_status_t efi_get_variable_t (efi_char16_t *name, efi_guid_t *vendor,
 typedef efi_status_t efi_get_next_variable_t (unsigned long *name_size, efi_char16_t *name,
 					      efi_guid_t *vendor);
 typedef efi_status_t efi_set_variable_t (efi_char16_t *name, efi_guid_t *vendor, 
-					 unsigned long attr, unsigned long data_size, 
+					 u32 attr, unsigned long data_size,
 					 void *data);
 typedef efi_status_t efi_get_next_high_mono_count_t (u32 *count);
 typedef void efi_reset_system_t (int reset_type, efi_status_t status,

commit 916f676f8dc016103f983c7ec54c18ecdbb6e349
Author: Matthew Garrett <mjg@redhat.com>
Date:   Wed May 25 09:53:13 2011 -0400

    x86, efi: Retain boot service code until after switching to virtual mode
    
    UEFI stands for "Unified Extensible Firmware Interface", where "Firmware"
    is an ancient African word meaning "Why do something right when you can
    do it so wrong that children will weep and brave adults will cower before
    you", and "UEI" is Celtic for "We missed DOS so we burned it into your
    ROMs". The UEFI specification provides for runtime services (ie, another
    way for the operating system to be forced to depend on the firmware) and
    we rely on these for certain trivial tasks such as setting up the
    bootloader. But some hardware fails to work if we attempt to use these
    runtime services from physical mode, and so we have to switch into virtual
    mode. So far so dreadful.
    
    The specification makes it clear that the operating system is free to do
    whatever it wants with boot services code after ExitBootServices() has been
    called. SetVirtualAddressMap() can't be called until ExitBootServices() has
    been. So, obviously, a whole bunch of EFI implementations call into boot
    services code when we do that. Since we've been charmingly naive and
    trusted that the specification may be somehow relevant to the real world,
    we've already stuffed a picture of a penguin or something in that address
    space. And just to make things more entertaining, we've also marked it
    non-executable.
    
    This patch allocates the boot services regions during EFI init and makes
    sure that they're executable. Then, after SetVirtualAddressMap(), it
    discards them and everyone lives happily ever after. Except for the ones
    who have to work on EFI, who live sad lives haunted by the knowledge that
    someone's eventually going to write yet another firmware specification.
    
    [ hpa: adding this to urgent with a stable tag since it fixes currently-broken
      hardware.  However, I do not know what the dependencies are and so I do
      not know which -stable versions this may be a candidate for. ]
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Link: http://lkml.kernel.org/r/1306331593-28715-1-git-send-email-mjg@redhat.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: <stable@kernel.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 33fa1203024e..e376270cd26e 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -299,6 +299,7 @@ extern void efi_initialize_iomem_resources(struct resource *code_resource,
 		struct resource *data_resource, struct resource *bss_resource);
 extern unsigned long efi_get_time(void);
 extern int efi_set_rtc_mmss(unsigned long nowtime);
+extern void efi_reserve_boot_services(void);
 extern struct efi_memory_map memmap;
 
 /**

commit 4fc756bd9dbf6b84fbf751e3bf495277849c5db7
Author: Mike Waychison <mikew@google.com>
Date:   Fri Mar 11 17:43:27 2011 -0800

    efivars: Expose efivars functionality to external drivers.
    
    Signed-off-by: Mike Waychison <mikew@google.com>
    Cc: Matt Domsch <Matt_Domsch@dell.com>,
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index fb737bc19a8c..33fa1203024e 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -397,4 +397,41 @@ static inline void memrange_efi_to_native(u64 *addr, u64 *npages)
 	*addr &= PAGE_MASK;
 }
 
+#if defined(CONFIG_EFI_VARS) || defined(CONFIG_EFI_VARS_MODULE)
+/*
+ * EFI Variable support.
+ *
+ * Different firmware drivers can expose their EFI-like variables using
+ * the following.
+ */
+
+struct efivar_operations {
+	efi_get_variable_t *get_variable;
+	efi_get_next_variable_t *get_next_variable;
+	efi_set_variable_t *set_variable;
+};
+
+struct efivars {
+	/*
+	 * ->lock protects two things:
+	 * 1) ->list - adds, removals, reads, writes
+	 * 2) ops.[gs]et_variable() calls.
+	 * It must not be held when creating sysfs entries or calling kmalloc.
+	 * ops.get_next_variable() is only called from register_efivars(),
+	 * which is protected by the BKL, so that path is safe.
+	 */
+	spinlock_t lock;
+	struct list_head list;
+	struct kset *kset;
+	struct bin_attribute *new_var, *del_var;
+	const struct efivar_operations *ops;
+};
+
+int register_efivars(struct efivars *efivars,
+		     const struct efivar_operations *ops,
+		     struct kobject *parent_kobj);
+void unregister_efivars(struct efivars *efivars);
+
+#endif /* CONFIG_EFI_VARS */
+
 #endif /* _LINUX_EFI_H */

commit 925ede0bf4ecef96fc2d939b16619530111aa16e
Author: Joe Perches <joe@perches.com>
Date:   Mon Dec 14 18:01:14 2009 -0800

    efi.h: use %pUl to print UUIDs
    
    Shrinks vmlinux
    
    without:
    $ size vmlinux
       text    data     bss     dec     hex filename
    6975863  679652 1359668 9015183  898f8f vmlinux
    
    with:
    $ size vmlinux
       text    data     bss     dec     hex filename
    6975639 679652 1359668 9014959 898eaf vmlinux
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: Jeff Garzik <jgarzik@redhat.com>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index ce4581fbc08b..fb737bc19a8c 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -280,11 +280,7 @@ efi_guidcmp (efi_guid_t left, efi_guid_t right)
 static inline char *
 efi_guid_unparse(efi_guid_t *guid, char *out)
 {
-	sprintf(out, "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
-		guid->b[3], guid->b[2], guid->b[1], guid->b[0],
-		guid->b[5], guid->b[4], guid->b[7], guid->b[6],
-		guid->b[8], guid->b[9], guid->b[10], guid->b[11],
-		guid->b[12], guid->b[13], guid->b[14], guid->b[15]);
+	sprintf(out, "%pUl", guid->b);
         return out;
 }
 

commit e088a4ad7fa53c3dc3c29f930025f41ccf01953e
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Fri May 22 13:49:49 2009 -0700

    [IA64] Convert ia64 to use int-ll64.h
    
    It is generally agreed that it would be beneficial for u64 to be an
    unsigned long long on all architectures.  ia64 (in common with several
    other 64-bit architectures) currently uses unsigned long.  Migrating
    piecemeal is too painful; this giant patch fixes all compilation warnings
    and errors that come as a result of switching to use int-ll64.h.
    
    Note that userspace will still see __u64 defined as unsigned long.  This
    is important as it affects C++ name mangling.
    
    [Updated by Tony Luck to change efi.h:efi_freemem_callback_t to use
     u64 for start/end rather than unsigned long]
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index bb66feb164bd..ce4581fbc08b 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -101,7 +101,7 @@ typedef struct {
 	u64 attribute;
 } efi_memory_desc_t;
 
-typedef int (*efi_freemem_callback_t) (unsigned long start, unsigned long end, void *arg);
+typedef int (*efi_freemem_callback_t) (u64 start, u64 end, void *arg);
 
 /*
  * Types and defines for Time Services

commit a50f70b17541c0060967c6df61133e968bad3652
Author: Russ Anderson <rja@sgi.com>
Date:   Fri Oct 3 11:58:54 2008 -0500

    x86: Add UV EFI table entry v4
    
    Look for a UV entry in the EFI tables.
    
    Signed-off-by: Russ Anderson <rja@sgi.com>
    Signed-off-by: Paul Jackson <pj@sgi.com>
    Acked-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 807373d467f7..bb66feb164bd 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -208,6 +208,9 @@ typedef efi_status_t efi_set_virtual_address_map_t (unsigned long memory_map_siz
 #define EFI_GLOBAL_VARIABLE_GUID \
     EFI_GUID(  0x8be4df61, 0x93ca, 0x11d2, 0xaa, 0x0d, 0x00, 0xe0, 0x98, 0x03, 0x2b, 0x8c )
 
+#define UV_SYSTEM_TABLE_GUID \
+    EFI_GUID(  0x3b13a7d4, 0x633e, 0x11dd, 0x93, 0xec, 0xda, 0x25, 0x56, 0xd8, 0x95, 0x93 )
+
 typedef struct {
 	efi_guid_t guid;
 	unsigned long table;
@@ -255,6 +258,7 @@ extern struct efi {
 	unsigned long boot_info;	/* boot info table */
 	unsigned long hcdp;		/* HCDP table */
 	unsigned long uga;		/* UGA table */
+	unsigned long uv_systab;	/* UV system table */
 	efi_get_time_t *get_time;
 	efi_set_time_t *set_time;
 	efi_get_wakeup_time_t *get_wakeup_time;

commit e9197bf0114661195bee35e7795cfc42164d9b2c
Author: Paul Jackson <pj@sgi.com>
Date:   Wed May 14 08:15:10 2008 -0700

    x86 boot: remove some unused extern function declarations
    
    Remove three extern declarations for routines
    that don't exist.  Fix a typo in a comment.
    
    Signed-off-by: Paul Jackson <pj@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index a5f359a7ad0e..807373d467f7 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -287,7 +287,6 @@ efi_guid_unparse(efi_guid_t *guid, char *out)
 extern void efi_init (void);
 extern void *efi_get_pal_addr (void);
 extern void efi_map_pal_code (void);
-extern void efi_map_memmap(void);
 extern void efi_memmap_walk (efi_freemem_callback_t callback, void *arg);
 extern void efi_gettimeofday (struct timespec *ts);
 extern void efi_enter_virtual_mode (void);	/* switch EFI to virtual mode, if possible */
@@ -295,14 +294,11 @@ extern u64 efi_get_iobase (void);
 extern u32 efi_mem_type (unsigned long phys_addr);
 extern u64 efi_mem_attributes (unsigned long phys_addr);
 extern u64 efi_mem_attribute (unsigned long phys_addr, unsigned long size);
-extern int efi_mem_attribute_range (unsigned long phys_addr, unsigned long size,
-				    u64 attr);
 extern int __init efi_uart_console_only (void);
 extern void efi_initialize_iomem_resources(struct resource *code_resource,
 		struct resource *data_resource, struct resource *bss_resource);
 extern unsigned long efi_get_time(void);
 extern int efi_set_rtc_mmss(unsigned long nowtime);
-extern int is_available_memory(efi_memory_desc_t * md);
 extern struct efi_memory_map memmap;
 
 /**

commit 4a3575fd436aa98957184afd745e4ada8f1542d8
Author: Huang, Ying <ying.huang@intel.com>
Date:   Mon Feb 25 15:18:37 2008 +0800

    x86: EFI_PAGE_SHIFT fix
    
    Make x86 EFI code works when EFI_PAGE_SHIFT != PAGE_SHIFT. The
    memrage_efi_to_native() provided in this patch can be used on other
    EFI platform such as IA64 too.
    
    This patch has been tested on Intel x86_64 platform with EFI 64/32
    firmware.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 14813b595802..a5f359a7ad0e 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -18,6 +18,7 @@
 #include <linux/proc_fs.h>
 #include <linux/rtc.h>
 #include <linux/ioport.h>
+#include <linux/pfn.h>
 
 #include <asm/page.h>
 #include <asm/system.h>
@@ -394,4 +395,10 @@ struct efi_generic_dev_path {
 	u16 length;
 } __attribute ((packed));
 
+static inline void memrange_efi_to_native(u64 *addr, u64 *npages)
+{
+	*npages = PFN_UP(*addr + (*npages<<EFI_PAGE_SHIFT)) - PFN_DOWN(*addr);
+	*addr &= PAGE_MASK;
+}
+
 #endif /* _LINUX_EFI_H */

commit 00bf4098beb15ca174b54f3af1f1e1908d7d18a3
Author: Bernhard Walle <bwalle@suse.de>
Date:   Sun Oct 21 16:42:01 2007 -0700

    kexec: add BSS to resource tree
    
    Add the BSS to the resource tree just as kernel text and kernel data are in
    the resource tree.  The main reason behind this is to avoid crashkernel
    reservation in that area.
    
    While it's not strictly necessary to have the BSS in the resource tree (the
    actual collision detection is done in the reserve_bootmem() function before),
    the usage of the BSS resource should be presented to the user in /proc/iomem
    just as Kernel data and Kernel code.
    
    Note: The patch currently is only implemented for x86 and ia64 (because
    efi_initialize_iomem_resources() has the same signature on i386 and ia64).
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Bernhard Walle <bwalle@suse.de>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Cc: <linux-arch@vger.kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 0b9579a4cd42..14813b595802 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -298,7 +298,7 @@ extern int efi_mem_attribute_range (unsigned long phys_addr, unsigned long size,
 				    u64 attr);
 extern int __init efi_uart_console_only (void);
 extern void efi_initialize_iomem_resources(struct resource *code_resource,
-					struct resource *data_resource);
+		struct resource *data_resource, struct resource *bss_resource);
 extern unsigned long efi_get_time(void);
 extern int efi_set_rtc_mmss(unsigned long nowtime);
 extern int is_available_memory(efi_memory_desc_t * md);

commit 873ec746158403af82c57ce26780166aafc159e1
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue May 8 00:29:57 2007 -0700

    EFI: warn only for pre-1.00 system tables
    
    We used to warn unless the EFI system table major revision was exactly 1.
    But EFI 2.00 firmware is starting to appear, and the 2.00 changes don't
    affect anything in Linux.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Andi Kleen <ak@suse.de>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index f8ebd7c1ddb3..0b9579a4cd42 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -213,7 +213,6 @@ typedef struct {
 } efi_config_table_t;
 
 #define EFI_SYSTEM_TABLE_SIGNATURE ((u64)0x5453595320494249ULL)
-#define EFI_SYSTEM_TABLE_REVISION  ((1 << 16) | 00)
 
 typedef struct {
 	efi_table_hdr_t hdr;

commit 472ba91dd9ce76b586d4d513f7e3448330eec7eb
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Feb 1 13:52:54 2007 +0000

    [PATCH] efi_set_rtc_mmss() is not __init
    
    fix the extern in efi.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index df1c91855f0e..f8ebd7c1ddb3 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -301,7 +301,7 @@ extern int __init efi_uart_console_only (void);
 extern void efi_initialize_iomem_resources(struct resource *code_resource,
 					struct resource *data_resource);
 extern unsigned long efi_get_time(void);
-extern int __init efi_set_rtc_mmss(unsigned long nowtime);
+extern int efi_set_rtc_mmss(unsigned long nowtime);
 extern int is_available_memory(efi_memory_desc_t * md);
 extern struct efi_memory_map memmap;
 

commit bf7e6a196318316e921f357557fca9d11d15f486
Author: Artiom Myaskouvskey <artiom.myaskouvskey@intel.com>
Date:   Thu Dec 7 02:14:11 2006 +0100

    [PATCH] i386: Preserve EFI run time regions with memmap parameter
    
    When using memmap kernel parameter in EFI boot we should also add to memory map
    memory regions of runtime services to enable their mapping later.
    
    AK: merged and cleaned up the patch
    
    Signed-off-by: Artiom Myaskouvskey <artiom.myaskouvskey@intel.com>
    Signed-off-by: Andi Kleen <ak@suse.de>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 91ecf49fbf21..df1c91855f0e 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -302,6 +302,7 @@ extern void efi_initialize_iomem_resources(struct resource *code_resource,
 					struct resource *data_resource);
 extern unsigned long efi_get_time(void);
 extern int __init efi_set_rtc_mmss(unsigned long nowtime);
+extern int is_available_memory(efi_memory_desc_t * md);
 extern struct efi_memory_map memmap;
 
 /**

commit e1cccf48b182dd743c3c83a4fdf8dc570a43b393
Author: Artiom Myaskouvskey <artiom.myaskouvskey@intel.com>
Date:   Thu Dec 7 02:14:11 2006 +0100

    [PATCH] i386: call efi_get_time during suspend
    
    Function efi_get_time called not only during init kernel phase but also
    during suspend (from get_cmos_time).
    
    When it is called from get_cmos_time the corresponding runtime service
    should be called in virtual and not in physical mode.
    
    Signed-off-by: Artiom Myaskouvskey <artiom.myaskouvskey@intel.com>
    Signed-off-by: Andi Kleen <ak@suse.de>
    Cc: "Narayanan, Chandramouli" <chandramouli.narayanan@intel.com>
    Cc: "Jiossy, Rami" <rami.jiossy@intel.com>
    Cc: "Satt, Shai" <shai.satt@intel.com>
    Cc: Andi Kleen <ak@suse.de>
    Cc: Matt Domsch <Matt_Domsch@dell.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 66d621dbcb6c..91ecf49fbf21 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -300,7 +300,7 @@ extern int efi_mem_attribute_range (unsigned long phys_addr, unsigned long size,
 extern int __init efi_uart_console_only (void);
 extern void efi_initialize_iomem_resources(struct resource *code_resource,
 					struct resource *data_resource);
-extern unsigned long __init efi_get_time(void);
+extern unsigned long efi_get_time(void);
 extern int __init efi_set_rtc_mmss(unsigned long nowtime);
 extern struct efi_memory_map memmap;
 

commit 32e62c636a728cb39c0b3bd191286f2ca65d4028
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri May 5 17:19:50 2006 -0600

    [IA64] rework memory attribute aliasing
    
    This closes a couple holes in our attribute aliasing avoidance scheme:
    
      - The current kernel fails mmaps of some /dev/mem MMIO regions because
        they don't appear in the EFI memory map.  This keeps X from working
        on the Intel Tiger box.
    
      - The current kernel allows UC mmap of the 0-1MB region of
        /sys/.../legacy_mem even when the chipset doesn't support UC
        access.  This causes an MCA when starting X on HP rx7620 and rx8620
        boxes in the default configuration.
    
    There's more detail in the Documentation/ia64/aliasing.txt file this
    adds, but the general idea is that if a region might be covered by
    a granule-sized kernel identity mapping, any access via /dev/mem or
    mmap must use the same attribute as the identity mapping.
    
    Otherwise, we fall back to using an attribute that is supported
    according to the EFI memory map, or to using UC if the EFI memory
    map doesn't mention the region.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index e203613d3aec..66d621dbcb6c 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -294,6 +294,7 @@ extern void efi_enter_virtual_mode (void);	/* switch EFI to virtual mode, if pos
 extern u64 efi_get_iobase (void);
 extern u32 efi_mem_type (unsigned long phys_addr);
 extern u64 efi_mem_attributes (unsigned long phys_addr);
+extern u64 efi_mem_attribute (unsigned long phys_addr, unsigned long size);
 extern int efi_mem_attribute_range (unsigned long phys_addr, unsigned long size,
 				    u64 attr);
 extern int __init efi_uart_console_only (void);

commit b2c99e3c70d77fb194df5aa1642030080d28ea48
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Sun Mar 26 01:37:08 2006 -0800

    [PATCH] EFI: keep physical table addresses in efi structure
    
    Almost all users of the table addresses from the EFI system table want
    physical addresses.  So rather than doing the pa->va->pa conversion, just keep
    physical addresses in struct efi.
    
    This fixes a DMI bug: the efi structure contained the physical SMBIOS address
    on x86 but the virtual address on ia64, so dmi_scan_machine() used ioremap()
    on a virtual address on ia64.
    
    This is essentially the same as an earlier patch by Matt Tolentino:
            http://marc.theaimsgroup.com/?l=linux-kernel&m=112130292316281&w=2
    except that this changes all table addresses, not just ACPI addresses.
    
    Matt's original patch was backed out because it caused MCAs on HP sx1000
    systems.  That problem is resolved by the ioremap() attribute checking added
    for ia64.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Matt Domsch <Matt_Domsch@dell.com>
    Cc: "Tolentino, Matthew E" <matthew.e.tolentino@intel.com>
    Cc: "Brown, Len" <len.brown@intel.com>
    Cc: Andi Kleen <ak@muc.de>
    Acked-by: "Luck, Tony" <tony.luck@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index d15725470aa4..e203613d3aec 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -240,19 +240,21 @@ struct efi_memory_map {
 	unsigned long desc_size;
 };
 
+#define EFI_INVALID_TABLE_ADDR		(~0UL)
+
 /*
  * All runtime access to EFI goes through this structure:
  */
 extern struct efi {
 	efi_system_table_t *systab;	/* EFI system table */
-	void *mps;			/* MPS table */
-	void *acpi;			/* ACPI table  (IA64 ext 0.71) */
-	void *acpi20;			/* ACPI table  (ACPI 2.0) */
-	void *smbios;			/* SM BIOS table */
-	void *sal_systab;		/* SAL system table */
-	void *boot_info;		/* boot info table */
-	void *hcdp;			/* HCDP table */
-	void *uga;			/* UGA table */
+	unsigned long mps;		/* MPS table */
+	unsigned long acpi;		/* ACPI table  (IA64 ext 0.71) */
+	unsigned long acpi20;		/* ACPI table  (ACPI 2.0) */
+	unsigned long smbios;		/* SM BIOS table */
+	unsigned long sal_systab;	/* SAL system table */
+	unsigned long boot_info;	/* boot info table */
+	unsigned long hcdp;		/* HCDP table */
+	unsigned long uga;		/* UGA table */
 	efi_get_time_t *get_time;
 	efi_set_time_t *set_time;
 	efi_get_wakeup_time_t *get_wakeup_time;

commit 136939a2b5aa4302281215745ccd567e1df2e8d4
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Sun Mar 26 01:37:05 2006 -0800

    [PATCH] EFI, /dev/mem: simplify efi_mem_attribute_range()
    
    Pass the size, not a pointer to the size, to efi_mem_attribute_range().
    
    This function validates memory regions for the /dev/mem read/write/mmap paths.
    The pointer allows arches to reduce the size of the range, but I think that's
    unnecessary complexity.  Simplifying it will let me use
    efi_mem_attribute_range() to improve the ia64 ioremap() implementation.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Matt Domsch <Matt_Domsch@dell.com>
    Cc: "Tolentino, Matthew E" <matthew.e.tolentino@intel.com>
    Cc: "Brown, Len" <len.brown@intel.com>
    Cc: Andi Kleen <ak@muc.de>
    Acked-by: "Luck, Tony" <tony.luck@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index c7c5dd316182..d15725470aa4 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -292,6 +292,8 @@ extern void efi_enter_virtual_mode (void);	/* switch EFI to virtual mode, if pos
 extern u64 efi_get_iobase (void);
 extern u32 efi_mem_type (unsigned long phys_addr);
 extern u64 efi_mem_attributes (unsigned long phys_addr);
+extern int efi_mem_attribute_range (unsigned long phys_addr, unsigned long size,
+				    u64 attr);
 extern int __init efi_uart_console_only (void);
 extern void efi_initialize_iomem_resources(struct resource *code_resource,
 					struct resource *data_resource);

commit 7ae65fd334232468a9d6b523a4fc141cd6ec5ea4
Author: Matt Tolentino <metolent@snoqualmie.dp.intel.com>
Date:   Sat Sep 3 15:56:27 2005 -0700

    [PATCH] x86: fix EFI memory map parsing
    
    The memory descriptors that comprise the EFI memory map are not fixed in
    stone such that the size could change in the future.  This uses the memory
    descriptor size obtained from EFI to iterate over the memory map entries
    during boot.  This enables the removal of an x86 specific pad (and ifdef)
    in the EFI header.  I also couldn't stomach the broken up nature of the
    function to put EFI runtime calls into virtual mode any longer so I fixed
    that up a bit as well.
    
    For reference, this patch only impacts x86.
    
    Signed-off-by: Matt Tolentino <matthew.e.tolentino@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 73781ec165b4..c7c5dd316182 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -91,11 +91,6 @@ typedef	struct {
 
 #define EFI_PAGE_SHIFT		12
 
-/*
- * For current x86 implementations of EFI, there is
- * additional padding in the mem descriptors.  This is not
- * the case in ia64.  Need to have this fixed in the f/w.
- */
 typedef struct {
 	u32 type;
 	u32 pad;
@@ -103,9 +98,6 @@ typedef struct {
 	u64 virt_addr;
 	u64 num_pages;
 	u64 attribute;
-#if defined (__i386__)
-	u64 pad1;
-#endif
 } efi_memory_desc_t;
 
 typedef int (*efi_freemem_callback_t) (unsigned long start, unsigned long end, void *arg);
@@ -240,10 +232,12 @@ typedef struct {
 } efi_system_table_t;
 
 struct efi_memory_map {
-	efi_memory_desc_t *phys_map;
-	efi_memory_desc_t *map;
+	void *phys_map;
+	void *map;
+	void *map_end;
 	int nr_map;
 	unsigned long desc_version;
+	unsigned long desc_size;
 };
 
 /*

commit 986a80d5c154808cc78170584670324a22fd8219
Author: Jesper Juhl <juhl-lkml@dif.dk>
Date:   Thu Jun 16 15:14:00 2005 -0700

    [PATCH] avoid signed vs unsigned comparison in efi_range_is_wc()
    
    warning when building with gcc -W :
    
     include/linux/efi.h: In function `efi_range_is_wc':
     include/linux/efi.h:320: warning: comparison between signed and unsigned
    
    It looks to me like a significantly large 'len' passed in could cause the
    loop to never end. Isn't it safer to make 'i' an unsigned long as well?
    Like this little patch below (which of course also kills the warning) :
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/include/linux/efi.h b/include/linux/efi.h
index 047e7222df7a..73781ec165b4 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -315,7 +315,7 @@ extern struct efi_memory_map memmap;
  */
 static inline int efi_range_is_wc(unsigned long start, unsigned long len)
 {
-	int i;
+	unsigned long i;
 
 	for (i = 0; i < len; i += (1UL << EFI_PAGE_SHIFT)) {
 		unsigned long paddr = __pa(start + i);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/efi.h b/include/linux/efi.h
new file mode 100644
index 000000000000..047e7222df7a
--- /dev/null
+++ b/include/linux/efi.h
@@ -0,0 +1,398 @@
+#ifndef _LINUX_EFI_H
+#define _LINUX_EFI_H
+
+/*
+ * Extensible Firmware Interface
+ * Based on 'Extensible Firmware Interface Specification' version 0.9, April 30, 1999
+ *
+ * Copyright (C) 1999 VA Linux Systems
+ * Copyright (C) 1999 Walt Drummond <drummond@valinux.com>
+ * Copyright (C) 1999, 2002-2003 Hewlett-Packard Co.
+ *	David Mosberger-Tang <davidm@hpl.hp.com>
+ *	Stephane Eranian <eranian@hpl.hp.com>
+ */
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/time.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/rtc.h>
+#include <linux/ioport.h>
+
+#include <asm/page.h>
+#include <asm/system.h>
+
+#define EFI_SUCCESS		0
+#define EFI_LOAD_ERROR          ( 1 | (1UL << (BITS_PER_LONG-1)))
+#define EFI_INVALID_PARAMETER	( 2 | (1UL << (BITS_PER_LONG-1)))
+#define EFI_UNSUPPORTED		( 3 | (1UL << (BITS_PER_LONG-1)))
+#define EFI_BAD_BUFFER_SIZE     ( 4 | (1UL << (BITS_PER_LONG-1)))
+#define EFI_BUFFER_TOO_SMALL	( 5 | (1UL << (BITS_PER_LONG-1)))
+#define EFI_NOT_FOUND		(14 | (1UL << (BITS_PER_LONG-1)))
+
+typedef unsigned long efi_status_t;
+typedef u8 efi_bool_t;
+typedef u16 efi_char16_t;		/* UNICODE character */
+
+
+typedef struct {
+	u8 b[16];
+} efi_guid_t;
+
+#define EFI_GUID(a,b,c,d0,d1,d2,d3,d4,d5,d6,d7) \
+((efi_guid_t) \
+{{ (a) & 0xff, ((a) >> 8) & 0xff, ((a) >> 16) & 0xff, ((a) >> 24) & 0xff, \
+  (b) & 0xff, ((b) >> 8) & 0xff, \
+  (c) & 0xff, ((c) >> 8) & 0xff, \
+  (d0), (d1), (d2), (d3), (d4), (d5), (d6), (d7) }})
+
+/*
+ * Generic EFI table header
+ */
+typedef	struct {
+	u64 signature;
+	u32 revision;
+	u32 headersize;
+	u32 crc32;
+	u32 reserved;
+} efi_table_hdr_t;
+
+/*
+ * Memory map descriptor:
+ */
+
+/* Memory types: */
+#define EFI_RESERVED_TYPE		 0
+#define EFI_LOADER_CODE			 1
+#define EFI_LOADER_DATA			 2
+#define EFI_BOOT_SERVICES_CODE		 3
+#define EFI_BOOT_SERVICES_DATA		 4
+#define EFI_RUNTIME_SERVICES_CODE	 5
+#define EFI_RUNTIME_SERVICES_DATA	 6
+#define EFI_CONVENTIONAL_MEMORY		 7
+#define EFI_UNUSABLE_MEMORY		 8
+#define EFI_ACPI_RECLAIM_MEMORY		 9
+#define EFI_ACPI_MEMORY_NVS		10
+#define EFI_MEMORY_MAPPED_IO		11
+#define EFI_MEMORY_MAPPED_IO_PORT_SPACE	12
+#define EFI_PAL_CODE			13
+#define EFI_MAX_MEMORY_TYPE		14
+
+/* Attribute values: */
+#define EFI_MEMORY_UC		((u64)0x0000000000000001ULL)	/* uncached */
+#define EFI_MEMORY_WC		((u64)0x0000000000000002ULL)	/* write-coalescing */
+#define EFI_MEMORY_WT		((u64)0x0000000000000004ULL)	/* write-through */
+#define EFI_MEMORY_WB		((u64)0x0000000000000008ULL)	/* write-back */
+#define EFI_MEMORY_WP		((u64)0x0000000000001000ULL)	/* write-protect */
+#define EFI_MEMORY_RP		((u64)0x0000000000002000ULL)	/* read-protect */
+#define EFI_MEMORY_XP		((u64)0x0000000000004000ULL)	/* execute-protect */
+#define EFI_MEMORY_RUNTIME	((u64)0x8000000000000000ULL)	/* range requires runtime mapping */
+#define EFI_MEMORY_DESCRIPTOR_VERSION	1
+
+#define EFI_PAGE_SHIFT		12
+
+/*
+ * For current x86 implementations of EFI, there is
+ * additional padding in the mem descriptors.  This is not
+ * the case in ia64.  Need to have this fixed in the f/w.
+ */
+typedef struct {
+	u32 type;
+	u32 pad;
+	u64 phys_addr;
+	u64 virt_addr;
+	u64 num_pages;
+	u64 attribute;
+#if defined (__i386__)
+	u64 pad1;
+#endif
+} efi_memory_desc_t;
+
+typedef int (*efi_freemem_callback_t) (unsigned long start, unsigned long end, void *arg);
+
+/*
+ * Types and defines for Time Services
+ */
+#define EFI_TIME_ADJUST_DAYLIGHT 0x1
+#define EFI_TIME_IN_DAYLIGHT     0x2
+#define EFI_UNSPECIFIED_TIMEZONE 0x07ff
+
+typedef struct {
+	u16 year;
+	u8 month;
+	u8 day;
+	u8 hour;
+	u8 minute;
+	u8 second;
+	u8 pad1;
+	u32 nanosecond;
+	s16 timezone;
+	u8 daylight;
+	u8 pad2;
+} efi_time_t;
+
+typedef struct {
+	u32 resolution;
+	u32 accuracy;
+	u8 sets_to_zero;
+} efi_time_cap_t;
+
+/*
+ * Types and defines for EFI ResetSystem
+ */
+#define EFI_RESET_COLD 0
+#define EFI_RESET_WARM 1
+#define EFI_RESET_SHUTDOWN 2
+
+/*
+ * EFI Runtime Services table
+ */
+#define EFI_RUNTIME_SERVICES_SIGNATURE ((u64)0x5652453544e5552ULL)
+#define EFI_RUNTIME_SERVICES_REVISION  0x00010000
+
+typedef struct {
+	efi_table_hdr_t hdr;
+	unsigned long get_time;
+	unsigned long set_time;
+	unsigned long get_wakeup_time;
+	unsigned long set_wakeup_time;
+	unsigned long set_virtual_address_map;
+	unsigned long convert_pointer;
+	unsigned long get_variable;
+	unsigned long get_next_variable;
+	unsigned long set_variable;
+	unsigned long get_next_high_mono_count;
+	unsigned long reset_system;
+} efi_runtime_services_t;
+
+typedef efi_status_t efi_get_time_t (efi_time_t *tm, efi_time_cap_t *tc);
+typedef efi_status_t efi_set_time_t (efi_time_t *tm);
+typedef efi_status_t efi_get_wakeup_time_t (efi_bool_t *enabled, efi_bool_t *pending,
+					    efi_time_t *tm);
+typedef efi_status_t efi_set_wakeup_time_t (efi_bool_t enabled, efi_time_t *tm);
+typedef efi_status_t efi_get_variable_t (efi_char16_t *name, efi_guid_t *vendor, u32 *attr,
+					 unsigned long *data_size, void *data);
+typedef efi_status_t efi_get_next_variable_t (unsigned long *name_size, efi_char16_t *name,
+					      efi_guid_t *vendor);
+typedef efi_status_t efi_set_variable_t (efi_char16_t *name, efi_guid_t *vendor, 
+					 unsigned long attr, unsigned long data_size, 
+					 void *data);
+typedef efi_status_t efi_get_next_high_mono_count_t (u32 *count);
+typedef void efi_reset_system_t (int reset_type, efi_status_t status,
+				 unsigned long data_size, efi_char16_t *data);
+typedef efi_status_t efi_set_virtual_address_map_t (unsigned long memory_map_size,
+						unsigned long descriptor_size,
+						u32 descriptor_version,
+						efi_memory_desc_t *virtual_map);
+
+/*
+ *  EFI Configuration Table and GUID definitions
+ */
+#define NULL_GUID \
+    EFI_GUID(  0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 )
+
+#define MPS_TABLE_GUID    \
+    EFI_GUID(  0xeb9d2d2f, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d )
+
+#define ACPI_TABLE_GUID    \
+    EFI_GUID(  0xeb9d2d30, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d )
+
+#define ACPI_20_TABLE_GUID    \
+    EFI_GUID(  0x8868e871, 0xe4f1, 0x11d3, 0xbc, 0x22, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 )
+
+#define SMBIOS_TABLE_GUID    \
+    EFI_GUID(  0xeb9d2d31, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d )
+
+#define SAL_SYSTEM_TABLE_GUID    \
+    EFI_GUID(  0xeb9d2d32, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d )
+
+#define HCDP_TABLE_GUID	\
+    EFI_GUID(  0xf951938d, 0x620b, 0x42ef, 0x82, 0x79, 0xa8, 0x4b, 0x79, 0x61, 0x78, 0x98 )
+
+#define UGA_IO_PROTOCOL_GUID \
+    EFI_GUID(  0x61a4d49e, 0x6f68, 0x4f1b, 0xb9, 0x22, 0xa8, 0x6e, 0xed, 0xb, 0x7, 0xa2 )
+
+#define EFI_GLOBAL_VARIABLE_GUID \
+    EFI_GUID(  0x8be4df61, 0x93ca, 0x11d2, 0xaa, 0x0d, 0x00, 0xe0, 0x98, 0x03, 0x2b, 0x8c )
+
+typedef struct {
+	efi_guid_t guid;
+	unsigned long table;
+} efi_config_table_t;
+
+#define EFI_SYSTEM_TABLE_SIGNATURE ((u64)0x5453595320494249ULL)
+#define EFI_SYSTEM_TABLE_REVISION  ((1 << 16) | 00)
+
+typedef struct {
+	efi_table_hdr_t hdr;
+	unsigned long fw_vendor;	/* physical addr of CHAR16 vendor string */
+	u32 fw_revision;
+	unsigned long con_in_handle;
+	unsigned long con_in;
+	unsigned long con_out_handle;
+	unsigned long con_out;
+	unsigned long stderr_handle;
+	unsigned long stderr;
+	efi_runtime_services_t *runtime;
+	unsigned long boottime;
+	unsigned long nr_tables;
+	unsigned long tables;
+} efi_system_table_t;
+
+struct efi_memory_map {
+	efi_memory_desc_t *phys_map;
+	efi_memory_desc_t *map;
+	int nr_map;
+	unsigned long desc_version;
+};
+
+/*
+ * All runtime access to EFI goes through this structure:
+ */
+extern struct efi {
+	efi_system_table_t *systab;	/* EFI system table */
+	void *mps;			/* MPS table */
+	void *acpi;			/* ACPI table  (IA64 ext 0.71) */
+	void *acpi20;			/* ACPI table  (ACPI 2.0) */
+	void *smbios;			/* SM BIOS table */
+	void *sal_systab;		/* SAL system table */
+	void *boot_info;		/* boot info table */
+	void *hcdp;			/* HCDP table */
+	void *uga;			/* UGA table */
+	efi_get_time_t *get_time;
+	efi_set_time_t *set_time;
+	efi_get_wakeup_time_t *get_wakeup_time;
+	efi_set_wakeup_time_t *set_wakeup_time;
+	efi_get_variable_t *get_variable;
+	efi_get_next_variable_t *get_next_variable;
+	efi_set_variable_t *set_variable;
+	efi_get_next_high_mono_count_t *get_next_high_mono_count;
+	efi_reset_system_t *reset_system;
+	efi_set_virtual_address_map_t *set_virtual_address_map;
+} efi;
+
+static inline int
+efi_guidcmp (efi_guid_t left, efi_guid_t right)
+{
+	return memcmp(&left, &right, sizeof (efi_guid_t));
+}
+
+static inline char *
+efi_guid_unparse(efi_guid_t *guid, char *out)
+{
+	sprintf(out, "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
+		guid->b[3], guid->b[2], guid->b[1], guid->b[0],
+		guid->b[5], guid->b[4], guid->b[7], guid->b[6],
+		guid->b[8], guid->b[9], guid->b[10], guid->b[11],
+		guid->b[12], guid->b[13], guid->b[14], guid->b[15]);
+        return out;
+}
+
+extern void efi_init (void);
+extern void *efi_get_pal_addr (void);
+extern void efi_map_pal_code (void);
+extern void efi_map_memmap(void);
+extern void efi_memmap_walk (efi_freemem_callback_t callback, void *arg);
+extern void efi_gettimeofday (struct timespec *ts);
+extern void efi_enter_virtual_mode (void);	/* switch EFI to virtual mode, if possible */
+extern u64 efi_get_iobase (void);
+extern u32 efi_mem_type (unsigned long phys_addr);
+extern u64 efi_mem_attributes (unsigned long phys_addr);
+extern int __init efi_uart_console_only (void);
+extern void efi_initialize_iomem_resources(struct resource *code_resource,
+					struct resource *data_resource);
+extern unsigned long __init efi_get_time(void);
+extern int __init efi_set_rtc_mmss(unsigned long nowtime);
+extern struct efi_memory_map memmap;
+
+/**
+ * efi_range_is_wc - check the WC bit on an address range
+ * @start: starting kvirt address
+ * @len: length of range
+ *
+ * Consult the EFI memory map and make sure it's ok to set this range WC.
+ * Returns true or false.
+ */
+static inline int efi_range_is_wc(unsigned long start, unsigned long len)
+{
+	int i;
+
+	for (i = 0; i < len; i += (1UL << EFI_PAGE_SHIFT)) {
+		unsigned long paddr = __pa(start + i);
+		if (!(efi_mem_attributes(paddr) & EFI_MEMORY_WC))
+			return 0;
+	}
+	/* The range checked out */
+	return 1;
+}
+
+#ifdef CONFIG_EFI_PCDP
+extern int __init efi_setup_pcdp_console(char *);
+#endif
+
+/*
+ * We play games with efi_enabled so that the compiler will, if possible, remove
+ * EFI-related code altogether.
+ */
+#ifdef CONFIG_EFI
+# ifdef CONFIG_X86
+   extern int efi_enabled;
+# else
+#  define efi_enabled 1
+# endif
+#else
+# define efi_enabled 0
+#endif
+
+/*
+ * Variable Attributes
+ */
+#define EFI_VARIABLE_NON_VOLATILE       0x0000000000000001
+#define EFI_VARIABLE_BOOTSERVICE_ACCESS 0x0000000000000002
+#define EFI_VARIABLE_RUNTIME_ACCESS     0x0000000000000004
+
+/*
+ * EFI Device Path information
+ */
+#define EFI_DEV_HW			0x01
+#define  EFI_DEV_PCI				 1
+#define  EFI_DEV_PCCARD				 2
+#define  EFI_DEV_MEM_MAPPED			 3
+#define  EFI_DEV_VENDOR				 4
+#define  EFI_DEV_CONTROLLER			 5
+#define EFI_DEV_ACPI			0x02
+#define   EFI_DEV_BASIC_ACPI			 1
+#define   EFI_DEV_EXPANDED_ACPI			 2
+#define EFI_DEV_MSG			0x03
+#define   EFI_DEV_MSG_ATAPI			 1
+#define   EFI_DEV_MSG_SCSI			 2
+#define   EFI_DEV_MSG_FC			 3
+#define   EFI_DEV_MSG_1394			 4
+#define   EFI_DEV_MSG_USB			 5
+#define   EFI_DEV_MSG_USB_CLASS			15
+#define   EFI_DEV_MSG_I20			 6
+#define   EFI_DEV_MSG_MAC			11
+#define   EFI_DEV_MSG_IPV4			12
+#define   EFI_DEV_MSG_IPV6			13
+#define   EFI_DEV_MSG_INFINIBAND		 9
+#define   EFI_DEV_MSG_UART			14
+#define   EFI_DEV_MSG_VENDOR			10
+#define EFI_DEV_MEDIA			0x04
+#define   EFI_DEV_MEDIA_HARD_DRIVE		 1
+#define   EFI_DEV_MEDIA_CDROM			 2
+#define   EFI_DEV_MEDIA_VENDOR			 3
+#define   EFI_DEV_MEDIA_FILE			 4
+#define   EFI_DEV_MEDIA_PROTOCOL		 5
+#define EFI_DEV_BIOS_BOOT		0x05
+#define EFI_DEV_END_PATH		0x7F
+#define EFI_DEV_END_PATH2		0xFF
+#define   EFI_DEV_END_INSTANCE			0x01
+#define   EFI_DEV_END_ENTIRE			0xFF
+
+struct efi_generic_dev_path {
+	u8 type;
+	u8 sub_type;
+	u16 length;
+} __attribute ((packed));
+
+#endif /* _LINUX_EFI_H */
