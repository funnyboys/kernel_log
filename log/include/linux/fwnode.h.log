commit 716a7a25969003d82ab738179c3f1068a120ed11
Author: Saravana Kannan <saravanak@google.com>
Date:   Thu May 14 22:34:59 2020 -0700

    driver core: fw_devlink: Add support for batching fwnode parsing
    
    The amount of time spent parsing fwnodes of devices can become really
    high if the devices are added in an non-ideal order. Worst case can be
    O(N^2) when N devices are added. But this can be optimized to O(N) by
    adding all the devices and then parsing all their fwnodes in one batch.
    
    This commit adds fw_devlink_pause() and fw_devlink_resume() to allow
    doing this.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20200515053500.215929-4-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index e0abafbb17f8..9506f8ec0974 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -171,5 +171,7 @@ struct fwnode_operations {
 #define get_dev_from_fwnode(fwnode)	get_device((fwnode)->dev)
 
 extern u32 fw_devlink_get_flags(void);
+void fw_devlink_pause(void);
+void fw_devlink_resume(void);
 
 #endif

commit 8375e74f2bca9802a4ddf431a6d7bd2ab9950f27
Author: Saravana Kannan <saravanak@google.com>
Date:   Fri Feb 21 17:40:35 2020 -0800

    driver core: Add fw_devlink kernel commandline option
    
    fwnode_operations.add_links allows creating device links from
    information provided by firmware.
    
    fwnode_operations.add_links is currently implemented only by
    OF/devicetree code and a specific case of efi. However, there's nothing
    preventing ACPI or other firmware types from implementing it.
    
    The OF implementation is currently controlled by a kernel commandline
    parameter called of_devlink.
    
    Since this feature is generic isn't limited to OF, add a generic
    fw_devlink kernel commandline parameter to control this feature across
    firmware types.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20200222014038.180923-3-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index 8feeb94b8acc..e0abafbb17f8 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -170,4 +170,6 @@ struct fwnode_operations {
 	} while (false)
 #define get_dev_from_fwnode(fwnode)	get_device((fwnode)->dev)
 
+extern u32 fw_devlink_get_flags(void);
+
 #endif

commit 9a3d7fd275be4559277667228902824165153c80
Merge: 0dd09bc02c1b 0e4a459f56c3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 27 11:06:20 2019 -0800

    Merge tag 'driver-core-5.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here is the "big" set of driver core patches for 5.5-rc1
    
      There's a few minor cleanups and fixes in here, but the majority of
      the patches in here fall into two buckets:
    
       - debugfs api cleanups and fixes
    
       - driver core device link support for boot dependancy issues
    
      The debugfs api cleanups are working to slowly refactor the debugfs
      apis so that it is even harder to use incorrectly. That work has been
      happening for the past few kernel releases and will continue over
      time, it's a long-term project/goal
    
      The driver core device link support missed 5.4 by just a bit, so it's
      been sitting and baking for many months now. It's from Saravana Kannan
      to help resolve the problems that DT-based systems have at boot time
      with dependancy graphs and kernel modules. Turns out that no one has
      actually tried to build a generic arm64 kernel with loads of modules
      and have it "just work" for a variety of platforms (like a distro
      kernel). The big problem turned out to be a lack of dependency
      information between different areas of DT entries, and the work here
      resolves that problem and now allows devices to boot properly, and
      quicker than a monolith kernel.
    
      All of these patches have been in linux-next for a long time with no
      reported issues"
    
    * tag 'driver-core-5.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (68 commits)
      tracing: Remove unnecessary DEBUG_FS dependency
      of: property: Add device link support for interrupt-parent, dmas and -gpio(s)
      debugfs: Fix !DEBUG_FS debugfs_create_automount
      of: property: Add device link support for "iommu-map"
      of: property: Fix the semantics of of_is_ancestor_of()
      i2c: of: Populate fwnode in of_i2c_get_board_info()
      drivers: base: Fix Kconfig indentation
      firmware_loader: Fix labels with comma for builtin firmware
      driver core: Allow device link operations inside sync_state()
      driver core: platform: Declare ret variable only once
      cpu-topology: declare parse_acpi_topology in <linux/arch_topology.h>
      crypto: hisilicon: no need to check return value of debugfs_create functions
      driver core: platform: use the correct callback type for bus_find_device
      firmware_class: make firmware caching configurable
      driver core: Clarify documentation for fwnode_operations.add_links()
      mailbox: tegra: Fix superfluous IRQ error message
      net: caif: Fix debugfs on 64-bit platforms
      mac80211: Use debugfs_create_xul() helper
      media: c8sectpfe: no need to check return value of debugfs_create functions
      of: property: Add device link support for iommus, mboxes and io-channels
      ...

commit bee3bbe616a2c8de641a64d874f9206835bd4401
Author: Saravana Kannan <saravanak@google.com>
Date:   Tue Nov 12 18:35:59 2019 -0800

    driver core: Clarify documentation for fwnode_operations.add_links()
    
    The wording was a bit ambiguous. So update it to make it clear.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Link: https://lore.kernel.org/r/20191113023559.62295-2-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index 766ff9bb5876..23df37f85398 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -94,15 +94,16 @@ struct fwnode_reference_args {
  *		available suppliers.
  *
  *		Return 0 if device links have been successfully created to all
- *		the suppliers this device needs to create device links to or if
- *		the supplier information is not known.
+ *		the known suppliers of this device or if the supplier
+ *		information is not known.
  *
- *		Return -ENODEV if and only if the suppliers needed for probing
- *		the device are not yet available to create device links to.
+ *		Return -ENODEV if the suppliers needed for probing this device
+ *		have not been registered yet (because device links can only be
+ *		created to devices registered with the driver core).
  *
- *		Return -EAGAIN if there are suppliers that need to be linked to
- *		that are not yet available but none of those suppliers are
- *		necessary for probing this device.
+ *		Return -EAGAIN if some of the suppliers of this device have not
+ *		been registered yet, but none of those suppliers are necessary
+ *		for probing the device.
  */
 struct fwnode_operations {
 	struct fwnode_handle *(*get)(struct fwnode_handle *fwnode);

commit 03324507e66c7664c754b1ef92c5c3be24c78aa2
Author: Saravana Kannan <saravanak@google.com>
Date:   Mon Oct 28 15:00:24 2019 -0700

    driver core: Allow fwnode_operations.add_links to differentiate errors
    
    When add_links() still has suppliers that it needs to link to in the
    future, this patch allows it to differentiate between suppliers that are
    needed for probing vs suppliers that are needed for sync_state()
    correctness.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20191028220027.251605-4-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index 97223e2410bd..766ff9bb5876 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -94,10 +94,15 @@ struct fwnode_reference_args {
  *		available suppliers.
  *
  *		Return 0 if device links have been successfully created to all
- *		the suppliers of this device or if the supplier information is
- *		not known. Return an error if and only if the supplier
- *		information is known but some of the suppliers are not yet
- *		available to create device links to.
+ *		the suppliers this device needs to create device links to or if
+ *		the supplier information is not known.
+ *
+ *		Return -ENODEV if and only if the suppliers needed for probing
+ *		the device are not yet available to create device links to.
+ *
+ *		Return -EAGAIN if there are suppliers that need to be linked to
+ *		that are not yet available but none of those suppliers are
+ *		necessary for probing this device.
  */
 struct fwnode_operations {
 	struct fwnode_handle *(*get)(struct fwnode_handle *fwnode);

commit 92df01e3601fe29eb3727a82705eafa6209053f5
Author: Saravana Kannan <saravanak@google.com>
Date:   Fri Oct 11 12:15:20 2019 -0700

    driver: core: Improve documentation for fwnode_operations.add_links()
    
    The add_links() ops shouldn't return on the first failed device link
    add. It needs to continue trying to add device links to other suppliers
    that are available. The documentation didn't explain WHY this behavior
    is necessary. So, update the documentation with an example that explains
    why this is necessary.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20191011191521.179614-3-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index 6ae05b9ce359..97223e2410bd 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -71,8 +71,25 @@ struct fwnode_reference_args {
  *		links to all the suppliers of the device that are available at
  *		the time this function is called.  The function must NOT stop
  *		at the first failed device link if other unlinked supplier
- *		devices are present in the system.  If some suppliers are not
- *		yet available, this function will be called again when other
+ *		devices are present in the system.  This is necessary for the
+ *		driver/bus sync_state() callbacks to work correctly.
+ *
+ *		For example, say Device-C depends on suppliers Device-S1 and
+ *		Device-S2 and the dependency is listed in that order in the
+ *		firmware.  Say, S1 gets populated from the firmware after
+ *		late_initcall_sync().  Say S2 is populated and probed way
+ *		before that in device_initcall(). When C is populated, if this
+ *		add_links() function doesn't continue past a "failed linking to
+ *		S1" and continue linking C to S2, then S2 will get a
+ *		sync_state() callback before C is probed. This is because from
+ *		the perspective of S2, C was never a consumer when its
+ *		sync_state() evaluation is done. To avoid this, the add_links()
+ *		function has to go through all available suppliers of the
+ *		device (that corresponds to this fwnode) and link to them
+ *		before returning.
+ *
+ *		If some suppliers are not yet available (indicated by an error
+ *		return value), this function will be called again when other
  *		devices are added to allow creating device links to any newly
  *		available suppliers.
  *

commit 8ed61d36050c57d9eba09511f53d683fd63b04d1
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Tue Oct 8 16:26:06 2019 +0300

    device property: Fix the description of struct fwnode_operations
    
    Adding description for the device_is_available member which
    was missing, and fixing the description of the member
    property_read_int_array.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index a5673c4674cf..9d9dc444d787 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -49,11 +49,11 @@ struct fwnode_reference_args {
  * struct fwnode_operations - Operations for fwnode interface
  * @get: Get a reference to an fwnode.
  * @put: Put a reference to an fwnode.
+ * @device_is_available: Return true if the device is available.
  * @device_get_match_data: Return the device driver match data.
  * @property_present: Return true if a property is present.
- * @property_read_integer_array: Read an array of integer properties. Return
- *				 zero on success, a negative error code
- *				 otherwise.
+ * @property_read_int_array: Read an array of integer properties. Return zero on
+ *			     success, a negative error code otherwise.
  * @property_read_string_array: Read an array of string properties. Return zero
  *				on success, a negative error code otherwise.
  * @get_name: Return the name of an fwnode.

commit e7e242bccb209b5f73455b33928b8680cc6e3319
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Thu Oct 3 15:32:13 2019 +0300

    device property: Add a function to obtain a node's prefix
    
    The prefix is used for printing purpose before a node, and it also works
    as a separator between two nodes.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Acked-by: Rob Herring <robh@kernel.org> (for OF)
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index 2bbf55739a57..a5673c4674cf 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -57,6 +57,7 @@ struct fwnode_reference_args {
  * @property_read_string_array: Read an array of string properties. Return zero
  *				on success, a negative error code otherwise.
  * @get_name: Return the name of an fwnode.
+ * @get_name_prefix: Get a prefix for a node (for printing purposes).
  * @get_parent: Return the parent of an fwnode.
  * @get_next_child_node: Return the next child node in an iteration.
  * @get_named_child_node: Return a child node with a given name.
@@ -84,6 +85,7 @@ struct fwnode_operations {
 				      const char *propname, const char **val,
 				      size_t nval);
 	const char *(*get_name)(const struct fwnode_handle *fwnode);
+	const char *(*get_name_prefix)(const struct fwnode_handle *fwnode);
 	struct fwnode_handle *(*get_parent)(const struct fwnode_handle *fwnode);
 	struct fwnode_handle *
 	(*get_next_child_node)(const struct fwnode_handle *fwnode,

commit bc0500c1e43d95cca5352d2345fb0769f314ba22
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Thu Oct 3 15:32:12 2019 +0300

    device property: Add fwnode_get_name for returning the name of a node
    
    The fwnode framework did not have means to obtain the name of a node. Add
    that now, in form of the fwnode_get_name() function and a corresponding
    get_name fwnode op. OF and ACPI support is included.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Acked-by: Rob Herring <robh@kernel.org> (for OF)
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index ababd6bc82f3..2bbf55739a57 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -56,6 +56,7 @@ struct fwnode_reference_args {
  *				 otherwise.
  * @property_read_string_array: Read an array of string properties. Return zero
  *				on success, a negative error code otherwise.
+ * @get_name: Return the name of an fwnode.
  * @get_parent: Return the parent of an fwnode.
  * @get_next_child_node: Return the next child node in an iteration.
  * @get_named_child_node: Return a child node with a given name.
@@ -82,6 +83,7 @@ struct fwnode_operations {
 	(*property_read_string_array)(const struct fwnode_handle *fwnode_handle,
 				      const char *propname, const char **val,
 				      size_t nval);
+	const char *(*get_name)(const struct fwnode_handle *fwnode);
 	struct fwnode_handle *(*get_parent)(const struct fwnode_handle *fwnode);
 	struct fwnode_handle *
 	(*get_next_child_node)(const struct fwnode_handle *fwnode,

commit e2ae9bcc4aaacda04edb75c4eea93384719efaa5
Author: Saravana Kannan <saravanak@google.com>
Date:   Wed Sep 4 14:11:21 2019 -0700

    driver core: Add support for linking devices during device addition
    
    The firmware corresponding to a device (dev.fwnode) might be able to
    provide functional dependency information between a device and its
    supplier and consumer devices.  Tracking this functional dependency
    allows optimizing device probe order and informing a supplier when all
    its consumers have probed (and thereby actively managing their
    resources).
    
    The existing device links feature allows tracking and using
    supplier-consumer relationships. So, this patch adds the add_links()
    fwnode callback to allow firmware to create device links for each
    device as the device is added.
    
    However, when consumer devices are added, they might not have a supplier
    device to link to despite needing mandatory resources/functionality from
    one or more suppliers. A waiting_for_suppliers list is created to track
    such consumers and retry linking them when new devices get added.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20190904211126.47518-3-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index d8c6d231d577..6ae05b9ce359 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -66,6 +66,21 @@ struct fwnode_reference_args {
  *			       endpoint node.
  * @graph_get_port_parent: Return the parent node of a port node.
  * @graph_parse_endpoint: Parse endpoint for port and endpoint id.
+ * @add_links:	Called after the device corresponding to the fwnode is added
+ *		using device_add(). The function is expected to create device
+ *		links to all the suppliers of the device that are available at
+ *		the time this function is called.  The function must NOT stop
+ *		at the first failed device link if other unlinked supplier
+ *		devices are present in the system.  If some suppliers are not
+ *		yet available, this function will be called again when other
+ *		devices are added to allow creating device links to any newly
+ *		available suppliers.
+ *
+ *		Return 0 if device links have been successfully created to all
+ *		the suppliers of this device or if the supplier information is
+ *		not known. Return an error if and only if the supplier
+ *		information is known but some of the suppliers are not yet
+ *		available to create device links to.
  */
 struct fwnode_operations {
 	struct fwnode_handle *(*get)(struct fwnode_handle *fwnode);
@@ -103,6 +118,8 @@ struct fwnode_operations {
 	(*graph_get_port_parent)(struct fwnode_handle *fwnode);
 	int (*graph_parse_endpoint)(const struct fwnode_handle *fwnode,
 				    struct fwnode_endpoint *endpoint);
+	int (*add_links)(const struct fwnode_handle *fwnode,
+			 struct device *dev);
 };
 
 #define fwnode_has_op(fwnode, op)				\

commit 372a67c0c5ef63f55bd1eb480d9555328d8ec0f2
Author: Saravana Kannan <saravanak@google.com>
Date:   Wed Sep 4 14:11:20 2019 -0700

    driver core: Add fwnode_to_dev() to look up device from fwnode
    
    It's often useful to look up a device that corresponds to a fwnode. So
    add an API to do that irrespective of the bus on which the device has
    been added to.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20190904211126.47518-2-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index ababd6bc82f3..d8c6d231d577 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -17,6 +17,7 @@ struct device;
 struct fwnode_handle {
 	struct fwnode_handle *secondary;
 	const struct fwnode_operations *ops;
+	struct device *dev;
 };
 
 /**
@@ -123,5 +124,6 @@ struct fwnode_operations {
 		if (fwnode_has_op(fwnode, op))				\
 			(fwnode)->ops->op(fwnode, ## __VA_ARGS__);	\
 	} while (false)
+#define get_dev_from_fwnode(fwnode)	get_device((fwnode)->dev)
 
 #endif

commit 149f3b87840e7d292ad059f5fc23f1fa2fc98b9e
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Aug 23 23:32:27 2019 +0300

    device property: Remove duplicate test for NULL
    
    There is no need to check twice for a NULL in fwnode_call_bool_op().
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index a11c8c56c78b..ababd6bc82f3 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -110,10 +110,11 @@ struct fwnode_operations {
 	(fwnode ? (fwnode_has_op(fwnode, op) ?				\
 		   (fwnode)->ops->op(fwnode, ## __VA_ARGS__) : -ENXIO) : \
 	 -EINVAL)
-#define fwnode_call_bool_op(fwnode, op, ...)				\
-	(fwnode ? (fwnode_has_op(fwnode, op) ?				\
-		   (fwnode)->ops->op(fwnode, ## __VA_ARGS__) : false) : \
-	 false)
+
+#define fwnode_call_bool_op(fwnode, op, ...)		\
+	(fwnode_has_op(fwnode, op) ?			\
+	 (fwnode)->ops->op(fwnode, ## __VA_ARGS__) : false)
+
 #define fwnode_call_ptr_op(fwnode, op, ...)		\
 	(fwnode_has_op(fwnode, op) ?			\
 	 (fwnode)->ops->op(fwnode, ## __VA_ARGS__) : NULL)

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index faebf0ca0686..a11c8c56c78b 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -1,12 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * fwnode.h - Firmware device node object handle type definition.
  *
  * Copyright (C) 2015, Intel Corporation
  * Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #ifndef _LINUX_FWNODE_H_

commit 977d5ad39f3ea12ac0bd51d75020cea5ecdca235
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Tue Jul 17 17:19:11 2018 +0300

    ACPI: Convert ACPI reference args to generic fwnode reference args
    
    Convert all users of struct acpi_reference_args to more generic
    fwnode_reference_args. This will
    
     1) avoid an ACPI specific references to device nodes with integer
        arguments as well as
    
     2) allow making references to nodes other than device nodes in ACPI.
    
    As a by-product, convert the fwnode interger arguments to u64. The
    arguments were 64-bit integers on ACPI but the fwnode arguments were
    just 32-bit.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index 4fe8f289b3f6..faebf0ca0686 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -45,7 +45,7 @@ struct fwnode_endpoint {
 struct fwnode_reference_args {
 	struct fwnode_handle *fwnode;
 	unsigned int nargs;
-	unsigned int args[NR_FWNODE_REFERENCE_ARGS];
+	u64 args[NR_FWNODE_REFERENCE_ARGS];
 };
 
 /**

commit 67dcc26d208ca5578f08c3c78cb254418c24e9ec
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Feb 9 17:38:36 2018 +0200

    device property: Constify device_get_match_data()
    
    Constify device_get_match_data() as OF and ACPI variants return
    constant value.
    
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index 4fa1a489efe4..4fe8f289b3f6 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -73,8 +73,8 @@ struct fwnode_operations {
 	struct fwnode_handle *(*get)(struct fwnode_handle *fwnode);
 	void (*put)(struct fwnode_handle *fwnode);
 	bool (*device_is_available)(const struct fwnode_handle *fwnode);
-	void *(*device_get_match_data)(const struct fwnode_handle *fwnode,
-				       const struct device *dev);
+	const void *(*device_get_match_data)(const struct fwnode_handle *fwnode,
+					     const struct device *dev);
 	bool (*property_present)(const struct fwnode_handle *fwnode,
 				 const char *propname);
 	int (*property_read_int_array)(const struct fwnode_handle *fwnode,

commit b283f157611f129f5bbbf7d06f5af860d76797fd
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Wed Dec 13 02:20:49 2017 -0500

    device property: Introduce a common API to fetch device match data
    
    There is an OF/ACPI function to obtain the driver data. We want to hide
    OF/ACPI details from the device drivers and abstract following the device
    family of functions.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index 411a84c6c400..4fa1a489efe4 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -15,6 +15,7 @@
 #include <linux/types.h>
 
 struct fwnode_operations;
+struct device;
 
 struct fwnode_handle {
 	struct fwnode_handle *secondary;
@@ -51,6 +52,7 @@ struct fwnode_reference_args {
  * struct fwnode_operations - Operations for fwnode interface
  * @get: Get a reference to an fwnode.
  * @put: Put a reference to an fwnode.
+ * @device_get_match_data: Return the device driver match data.
  * @property_present: Return true if a property is present.
  * @property_read_integer_array: Read an array of integer properties. Return
  *				 zero on success, a negative error code
@@ -71,6 +73,8 @@ struct fwnode_operations {
 	struct fwnode_handle *(*get)(struct fwnode_handle *fwnode);
 	void (*put)(struct fwnode_handle *fwnode);
 	bool (*device_is_available)(const struct fwnode_handle *fwnode);
+	void *(*device_get_match_data)(const struct fwnode_handle *fwnode,
+				       const struct device *dev);
 	bool (*property_present)(const struct fwnode_handle *fwnode,
 				 const char *propname);
 	int (*property_read_int_array)(const struct fwnode_handle *fwnode,

commit cf89a31ca55272e1dfb9527b5a61eee4d417747a
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Tue Sep 19 12:39:11 2017 +0300

    device property: Make fwnode_handle_get() return the fwnode
    
    The fwnode_handle_get() function is used to obtain a reference to an
    fwnode. A common usage pattern for the OF equivalent of the function is:
    
            mynode = of_node_get(node);
    
    Similarly make fwnode_handle_get() return the fwnode to which the
    reference was obtained.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index 0c35b6caf0f6..411a84c6c400 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -68,7 +68,7 @@ struct fwnode_reference_args {
  * @graph_parse_endpoint: Parse endpoint for port and endpoint id.
  */
 struct fwnode_operations {
-	void (*get)(struct fwnode_handle *fwnode);
+	struct fwnode_handle *(*get)(struct fwnode_handle *fwnode);
 	void (*put)(struct fwnode_handle *fwnode);
 	bool (*device_is_available)(const struct fwnode_handle *fwnode);
 	bool (*property_present)(const struct fwnode_handle *fwnode,

commit 3e3119d3088f41106f3581d39e7694a50ca3fc02
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Fri Jul 21 15:11:49 2017 +0300

    device property: Introduce fwnode_property_get_reference_args
    
    The new fwnode_property_get_reference_args() interface amends the fwnode
    property API with the functionality of both of_parse_phandle_with_args()
    and __acpi_node_get_property_reference().
    
    The semantics is slightly different: the cells property is ignored on ACPI
    as the number of arguments can be explicitly obtained from the firmware
    interface.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index 7b50ee4edcfc..0c35b6caf0f6 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -33,6 +33,20 @@ struct fwnode_endpoint {
 	const struct fwnode_handle *local_fwnode;
 };
 
+#define NR_FWNODE_REFERENCE_ARGS	8
+
+/**
+ * struct fwnode_reference_args - Fwnode reference with additional arguments
+ * @fwnode:- A reference to the base fwnode
+ * @nargs: Number of elements in @args array
+ * @args: Integer arguments on the fwnode
+ */
+struct fwnode_reference_args {
+	struct fwnode_handle *fwnode;
+	unsigned int nargs;
+	unsigned int args[NR_FWNODE_REFERENCE_ARGS];
+};
+
 /**
  * struct fwnode_operations - Operations for fwnode interface
  * @get: Get a reference to an fwnode.
@@ -46,6 +60,7 @@ struct fwnode_endpoint {
  * @get_parent: Return the parent of an fwnode.
  * @get_next_child_node: Return the next child node in an iteration.
  * @get_named_child_node: Return a child node with a given name.
+ * @get_reference_args: Return a reference pointed to by a property, with args
  * @graph_get_next_endpoint: Return an endpoint node in an iteration.
  * @graph_get_remote_endpoint: Return the remote endpoint node of a local
  *			       endpoint node.
@@ -73,6 +88,10 @@ struct fwnode_operations {
 	struct fwnode_handle *
 	(*get_named_child_node)(const struct fwnode_handle *fwnode,
 				const char *name);
+	int (*get_reference_args)(const struct fwnode_handle *fwnode,
+				  const char *prop, const char *nargs_prop,
+				  unsigned int nargs, unsigned int index,
+				  struct fwnode_reference_args *args);
 	struct fwnode_handle *
 	(*graph_get_next_endpoint)(const struct fwnode_handle *fwnode,
 				   struct fwnode_handle *prev);

commit 37ba983cfb47cc7b353146422c437468fcb29c61
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Fri Jul 21 14:39:36 2017 +0300

    device property: Constify fwnode property API
    
    Make fwnode arguments to the fwnode property API const.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index c5dbc48b55dd..7b50ee4edcfc 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -55,30 +55,32 @@ struct fwnode_endpoint {
 struct fwnode_operations {
 	void (*get)(struct fwnode_handle *fwnode);
 	void (*put)(struct fwnode_handle *fwnode);
-	bool (*device_is_available)(struct fwnode_handle *fwnode);
-	bool (*property_present)(struct fwnode_handle *fwnode,
+	bool (*device_is_available)(const struct fwnode_handle *fwnode);
+	bool (*property_present)(const struct fwnode_handle *fwnode,
 				 const char *propname);
-	int (*property_read_int_array)(struct fwnode_handle *fwnode,
+	int (*property_read_int_array)(const struct fwnode_handle *fwnode,
 				       const char *propname,
 				       unsigned int elem_size, void *val,
 				       size_t nval);
-	int (*property_read_string_array)(struct fwnode_handle *fwnode_handle,
-					  const char *propname,
-					  const char **val, size_t nval);
-	struct fwnode_handle *(*get_parent)(struct fwnode_handle *fwnode);
+	int
+	(*property_read_string_array)(const struct fwnode_handle *fwnode_handle,
+				      const char *propname, const char **val,
+				      size_t nval);
+	struct fwnode_handle *(*get_parent)(const struct fwnode_handle *fwnode);
 	struct fwnode_handle *
-	(*get_next_child_node)(struct fwnode_handle *fwnode,
+	(*get_next_child_node)(const struct fwnode_handle *fwnode,
 			       struct fwnode_handle *child);
 	struct fwnode_handle *
-	(*get_named_child_node)(struct fwnode_handle *fwnode, const char *name);
+	(*get_named_child_node)(const struct fwnode_handle *fwnode,
+				const char *name);
 	struct fwnode_handle *
-	(*graph_get_next_endpoint)(struct fwnode_handle *fwnode,
+	(*graph_get_next_endpoint)(const struct fwnode_handle *fwnode,
 				   struct fwnode_handle *prev);
 	struct fwnode_handle *
-	(*graph_get_remote_endpoint)(struct fwnode_handle *fwnode);
+	(*graph_get_remote_endpoint)(const struct fwnode_handle *fwnode);
 	struct fwnode_handle *
 	(*graph_get_port_parent)(struct fwnode_handle *fwnode);
-	int (*graph_parse_endpoint)(struct fwnode_handle *fwnode,
+	int (*graph_parse_endpoint)(const struct fwnode_handle *fwnode,
 				    struct fwnode_endpoint *endpoint);
 };
 

commit db3e50f3234ba1a477413f56a9e5800a73dca786
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Fri Jul 21 14:39:31 2017 +0300

    device property: Get rid of struct fwnode_handle type field
    
    Instead of relying on the struct fwnode_handle type field, define
    fwnode_operations structs for all separate types of fwnodes. To find out
    the type, compare to the ops field to relevant ops structs.
    
    This change has two benefits:
    
    1. it avoids adding the type field to each and every instance of struct
    fwnode_handle, thus saving memory and
    
    2. makes the ops field the single factor that defines both the types of
    the fwnode as well as defines the implementation of its operations,
    decreasing the possibility of bugs when developing code dealing with
    fwnode internals.
    
    Suggested-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index 50893a1646cf..c5dbc48b55dd 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -14,20 +14,9 @@
 
 #include <linux/types.h>
 
-enum fwnode_type {
-	FWNODE_INVALID = 0,
-	FWNODE_OF,
-	FWNODE_ACPI,
-	FWNODE_ACPI_DATA,
-	FWNODE_ACPI_STATIC,
-	FWNODE_PDATA,
-	FWNODE_IRQCHIP
-};
-
 struct fwnode_operations;
 
 struct fwnode_handle {
-	enum fwnode_type type;
 	struct fwnode_handle *secondary;
 	const struct fwnode_operations *ops;
 };

commit e8158b486d5f3f55cf372c5a32b42f263bf7f123
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Tue Jul 11 18:20:20 2017 +0300

    device property: Introduce fwnode_call_bool_op() for ops that return bool
    
    fwnode_call_int_op() isn't suitable for calling ops that return bool
    since it effectively causes the result returned to the user to be
    true when an op hasn't been defined or the fwnode is NULL.
    
    Address this by introducing fwnode_call_bool_op() for calling ops
    that return bool.
    
    Fixes: 3708184afc77 "device property: Move FW type specific functionality to FW specific files"
    Fixes: 2294b3af05e9 "device property: Introduce fwnode_device_is_available()"
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index 9ab375419189..50893a1646cf 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -99,6 +99,10 @@ struct fwnode_operations {
 	(fwnode ? (fwnode_has_op(fwnode, op) ?				\
 		   (fwnode)->ops->op(fwnode, ## __VA_ARGS__) : -ENXIO) : \
 	 -EINVAL)
+#define fwnode_call_bool_op(fwnode, op, ...)				\
+	(fwnode ? (fwnode_has_op(fwnode, op) ?				\
+		   (fwnode)->ops->op(fwnode, ## __VA_ARGS__) : false) : \
+	 false)
 #define fwnode_call_ptr_op(fwnode, op, ...)		\
 	(fwnode_has_op(fwnode, op) ?			\
 	 (fwnode)->ops->op(fwnode, ## __VA_ARGS__) : NULL)

commit 2294b3af05e9b3fe0b84a78971e709037bd7593c
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Tue Jun 6 12:37:39 2017 +0300

    device property: Introduce fwnode_device_is_available()
    
    Add fwnode_device_is_available() to tell whether the device corresponding
    to a certain fwnode_handle is available for use.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index e315d867d631..9ab375419189 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -66,6 +66,7 @@ struct fwnode_endpoint {
 struct fwnode_operations {
 	void (*get)(struct fwnode_handle *fwnode);
 	void (*put)(struct fwnode_handle *fwnode);
+	bool (*device_is_available)(struct fwnode_handle *fwnode);
 	bool (*property_present)(struct fwnode_handle *fwnode,
 				 const char *propname);
 	int (*property_read_int_array)(struct fwnode_handle *fwnode,

commit 3b27d00e7b6d7c889d87fd00df600c495b968e30
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Tue Jun 6 12:37:38 2017 +0300

    device property: Move fwnode graph ops to firmware specific locations
    
    Move firmware specific implementations of the fwnode graph operations to
    firmware specific locations.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index 8f64b3ae9c57..e315d867d631 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -57,6 +57,11 @@ struct fwnode_endpoint {
  * @get_parent: Return the parent of an fwnode.
  * @get_next_child_node: Return the next child node in an iteration.
  * @get_named_child_node: Return a child node with a given name.
+ * @graph_get_next_endpoint: Return an endpoint node in an iteration.
+ * @graph_get_remote_endpoint: Return the remote endpoint node of a local
+ *			       endpoint node.
+ * @graph_get_port_parent: Return the parent node of a port node.
+ * @graph_parse_endpoint: Parse endpoint for port and endpoint id.
  */
 struct fwnode_operations {
 	void (*get)(struct fwnode_handle *fwnode);
@@ -76,6 +81,15 @@ struct fwnode_operations {
 			       struct fwnode_handle *child);
 	struct fwnode_handle *
 	(*get_named_child_node)(struct fwnode_handle *fwnode, const char *name);
+	struct fwnode_handle *
+	(*graph_get_next_endpoint)(struct fwnode_handle *fwnode,
+				   struct fwnode_handle *prev);
+	struct fwnode_handle *
+	(*graph_get_remote_endpoint)(struct fwnode_handle *fwnode);
+	struct fwnode_handle *
+	(*graph_get_port_parent)(struct fwnode_handle *fwnode);
+	int (*graph_parse_endpoint)(struct fwnode_handle *fwnode,
+				    struct fwnode_endpoint *endpoint);
 };
 
 #define fwnode_has_op(fwnode, op)				\

commit 3708184afc77bb67709a67a35d9f367ebd32cbc4
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Tue Jun 6 12:37:37 2017 +0300

    device property: Move FW type specific functionality to FW specific files
    
    The device and fwnode property API supports Devicetree, ACPI and pset
    properties. The implementation of this functionality for each firmware
    type was embedded in the fwnode property core. Move it out to firmware
    type specific locations, making it easier to maintain.
    
    Depends-on: ("of: Move OF property and graph API from base.c to property.c")
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index 3dff2398a5f0..8f64b3ae9c57 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -12,6 +12,8 @@
 #ifndef _LINUX_FWNODE_H_
 #define _LINUX_FWNODE_H_
 
+#include <linux/types.h>
+
 enum fwnode_type {
 	FWNODE_INVALID = 0,
 	FWNODE_OF,
@@ -22,9 +24,12 @@ enum fwnode_type {
 	FWNODE_IRQCHIP
 };
 
+struct fwnode_operations;
+
 struct fwnode_handle {
 	enum fwnode_type type;
 	struct fwnode_handle *secondary;
+	const struct fwnode_operations *ops;
 };
 
 /**
@@ -39,4 +44,53 @@ struct fwnode_endpoint {
 	const struct fwnode_handle *local_fwnode;
 };
 
+/**
+ * struct fwnode_operations - Operations for fwnode interface
+ * @get: Get a reference to an fwnode.
+ * @put: Put a reference to an fwnode.
+ * @property_present: Return true if a property is present.
+ * @property_read_integer_array: Read an array of integer properties. Return
+ *				 zero on success, a negative error code
+ *				 otherwise.
+ * @property_read_string_array: Read an array of string properties. Return zero
+ *				on success, a negative error code otherwise.
+ * @get_parent: Return the parent of an fwnode.
+ * @get_next_child_node: Return the next child node in an iteration.
+ * @get_named_child_node: Return a child node with a given name.
+ */
+struct fwnode_operations {
+	void (*get)(struct fwnode_handle *fwnode);
+	void (*put)(struct fwnode_handle *fwnode);
+	bool (*property_present)(struct fwnode_handle *fwnode,
+				 const char *propname);
+	int (*property_read_int_array)(struct fwnode_handle *fwnode,
+				       const char *propname,
+				       unsigned int elem_size, void *val,
+				       size_t nval);
+	int (*property_read_string_array)(struct fwnode_handle *fwnode_handle,
+					  const char *propname,
+					  const char **val, size_t nval);
+	struct fwnode_handle *(*get_parent)(struct fwnode_handle *fwnode);
+	struct fwnode_handle *
+	(*get_next_child_node)(struct fwnode_handle *fwnode,
+			       struct fwnode_handle *child);
+	struct fwnode_handle *
+	(*get_named_child_node)(struct fwnode_handle *fwnode, const char *name);
+};
+
+#define fwnode_has_op(fwnode, op)				\
+	((fwnode) && (fwnode)->ops && (fwnode)->ops->op)
+#define fwnode_call_int_op(fwnode, op, ...)				\
+	(fwnode ? (fwnode_has_op(fwnode, op) ?				\
+		   (fwnode)->ops->op(fwnode, ## __VA_ARGS__) : -ENXIO) : \
+	 -EINVAL)
+#define fwnode_call_ptr_op(fwnode, op, ...)		\
+	(fwnode_has_op(fwnode, op) ?			\
+	 (fwnode)->ops->op(fwnode, ## __VA_ARGS__) : NULL)
+#define fwnode_call_void_op(fwnode, op, ...)				\
+	do {								\
+		if (fwnode_has_op(fwnode, op))				\
+			(fwnode)->ops->op(fwnode, ## __VA_ARGS__);	\
+	} while (false)
+
 #endif

commit 2bd5452d46df46d99b869b59a1532647e2981d75
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Tue Mar 28 10:52:25 2017 +0300

    device property: Add support for fwnode endpoints
    
    Similar to OF endpoints, endpoint type nodes can be also supported on
    ACPI. In order to make it possible for drivers to ignore the matter,
    add a type for fwnode_endpoint and a function to parse them.
    
    On ACPI, find the child node index instead of relying on the "endpoint"
    property.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index 8bd28ce6d76e..3dff2398a5f0 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -27,4 +27,16 @@ struct fwnode_handle {
 	struct fwnode_handle *secondary;
 };
 
+/**
+ * struct fwnode_endpoint - Fwnode graph endpoint
+ * @port: Port number
+ * @id: Endpoint id
+ * @local_fwnode: reference to the related fwnode
+ */
+struct fwnode_endpoint {
+	unsigned int port;
+	unsigned int id;
+	const struct fwnode_handle *local_fwnode;
+};
+
 #endif

commit 027b25b26447aaf597c8b7729dd3b1fbebc6d5e8
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Nov 21 10:01:33 2016 +0000

    ACPI: Add FWNODE_ACPI_STATIC fwnode type
    
    On systems booting with a device tree, every struct device is associated
    with a struct device_node, that provides its DT firmware representation.
    The device node can be used in generic kernel contexts (eg IRQ
    translation, IOMMU streamid mapping), to retrieve the properties
    associated with the device and carry out kernel operations accordingly.
    Owing to the 1:1 relationship between the device and its device_node,
    the device_node can also be used as a look-up token for the device (eg
    looking up a device through its device_node), to retrieve the device in
    kernel paths where the device_node is available.
    
    On systems booting with ACPI, the same abstraction provided by
    the device_node is required to provide look-up functionality.
    
    The struct acpi_device, that represents firmware objects in the
    ACPI namespace already includes a struct fwnode_handle of
    type FWNODE_ACPI as their member; the same abstraction is missing
    though for devices that are instantiated out of static ACPI tables
    entries (eg ARM SMMU devices).
    
    Add a new fwnode_handle type to associate devices created out
    of static ACPI table entries to the respective firmware components
    and create a simple ACPI core layer interface to dynamically allocate
    and free the corresponding firmware nodes so that kernel subsystems
    can use it to instantiate the nodes and associate them with the
    respective devices.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Tomasz Nowicki <tn@semihalf.com>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Tomasz Nowicki <tn@semihalf.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index 851671742790..8bd28ce6d76e 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -17,8 +17,9 @@ enum fwnode_type {
 	FWNODE_OF,
 	FWNODE_ACPI,
 	FWNODE_ACPI_DATA,
+	FWNODE_ACPI_STATIC,
 	FWNODE_PDATA,
-	FWNODE_IRQCHIP,
+	FWNODE_IRQCHIP
 };
 
 struct fwnode_handle {

commit 0d51ce9ca1116e8f4dc87cb51db8dd250327e9bb
Merge: 41ecf1404b34 1ab68460b1d0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 4 18:10:13 2015 -0800

    Merge tag 'pm+acpi-4.4-rc1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael Wysocki:
     "Quite a new features are included this time.
    
      First off, the Collaborative Processor Performance Control interface
      (version 2) defined by ACPI will now be supported on ARM64 along with
      a cpufreq frontend for CPU performance scaling.
    
      Second, ACPI gets a new infrastructure for the early probing of IRQ
      chips and clock sources (along the lines of the existing similar
      mechanism for DT).
    
      Next, the ACPI core and the generic device properties API will now
      support a recently introduced hierarchical properties extension of the
      _DSD (Device Specific Data) ACPI device configuration object.  If the
      ACPI platform firmware uses that extension to organize device
      properties in a hierarchical way, the kernel will automatically handle
      it and make those properties available to device drivers via the
      generic device properties API.
    
      It also will be possible to build the ACPICA's AML interpreter
      debugger into the kernel now and use that to diagnose AML-related
      problems more efficiently.  In the future, this should make it
      possible to single-step AML execution and do similar things.
      Interesting stuff, although somewhat experimental at this point.
    
      Finally, the PM core gets a new mechanism that can be used by device
      drivers to distinguish between suspend-to-RAM (based on platform
      firmware support) and suspend-to-idle (or other variants of system
      suspend the platform firmware is not involved in) and possibly
      optimize their device suspend/resume handling accordingly.
    
      In addition to that, some existing features are re-organized quite
      substantially.
    
      First, the ACPI-based handling of PCI host bridges on x86 and ia64 is
      unified and the common code goes into the ACPI core (so as to reduce
      code duplication and eliminate non-essential differences between the
      two architectures in that area).
    
      Second, the Operating Performance Points (OPP) framework is
      reorganized to make the code easier to find and follow.
    
      Next, the cpufreq core's sysfs interface is reorganized to get rid of
      the "primary CPU" concept for configurations in which the same
      performance scaling settings are shared between multiple CPUs.
    
      Finally, some interfaces that aren't necessary any more are dropped
      from the generic power domains framework.
    
      On top of the above we have some minor extensions, cleanups and bug
      fixes in multiple places, as usual.
    
      Specifics:
    
       - ACPICA update to upstream revision 20150930 (Bob Moore, Lv Zheng).
    
         The most significant change is to allow the AML debugger to be
         built into the kernel.  On top of that there is an update related
         to the NFIT table (the ACPI persistent memory interface) and a few
         fixes and cleanups.
    
       - ACPI CPPC2 (Collaborative Processor Performance Control v2) support
         along with a cpufreq frontend (Ashwin Chaugule).
    
         This can only be enabled on ARM64 at this point.
    
       - New ACPI infrastructure for the early probing of IRQ chips and
         clock sources (Marc Zyngier).
    
       - Support for a new hierarchical properties extension of the ACPI
         _DSD (Device Specific Data) device configuration object allowing
         the kernel to handle hierarchical properties (provided by the
         platform firmware this way) automatically and make them available
         to device drivers via the generic device properties interface
         (Rafael Wysocki).
    
       - Generic device properties API extension to obtain an index of
         certain string value in an array of strings, along the lines of
         of_property_match_string(), but working for all of the supported
         firmware node types, and support for the "dma-names" device
         property based on it (Mika Westerberg).
    
       - ACPI core fix to parse the MADT (Multiple APIC Description Table)
         entries in the order expected by platform firmware (and mandated by
         the specification) to avoid confusion on systems with more than 255
         logical CPUs (Lukasz Anaczkowski).
    
       - Consolidation of the ACPI-based handling of PCI host bridges on x86
         and ia64 (Jiang Liu).
    
       - ACPI core fixes to ensure that the correct IRQ number is used to
         represent the SCI (System Control Interrupt) in the cases when it
         has been re-mapped (Chen Yu).
    
       - New ACPI backlight quirk for Lenovo IdeaPad S405 (Hans de Goede).
    
       - ACPI EC driver fixes (Lv Zheng).
    
       - Assorted ACPI fixes and cleanups (Dan Carpenter, Insu Yun, Jiri
         Kosina, Rami Rosen, Rasmus Villemoes).
    
       - New mechanism in the PM core allowing drivers to check if the
         platform firmware is going to be involved in the upcoming system
         suspend or if it has been involved in the suspend the system is
         resuming from at the moment (Rafael Wysocki).
    
         This should allow drivers to optimize their suspend/resume handling
         in some cases and the changes include a couple of users of it (the
         i8042 input driver, PCI PM).
    
       - PCI PM fix to prevent runtime-suspended devices with PME enabled
         from being resumed during system suspend even if they aren't
         configured to wake up the system from sleep (Rafael Wysocki).
    
       - New mechanism to report the number of a wakeup IRQ that woke up the
         system from sleep last time (Alexandra Yates).
    
       - Removal of unused interfaces from the generic power domains
         framework and fixes related to latency measurements in that code
         (Ulf Hansson, Daniel Lezcano).
    
       - cpufreq core sysfs interface rework to make it handle CPUs that
         share performance scaling settings (represented by a common cpufreq
         policy object) more symmetrically (Viresh Kumar).
    
         This should help to simplify the CPU offline/online handling among
         other things.
    
       - cpufreq core fixes and cleanups (Viresh Kumar).
    
       - intel_pstate fixes related to the Turbo Activation Ratio (TAR)
         mechanism on client platforms which causes the turbo P-states range
         to vary depending on platform firmware settings (Srinivas
         Pandruvada).
    
       - intel_pstate sysfs interface fix (Prarit Bhargava).
    
       - Assorted cpufreq driver (imx, tegra20, powernv, integrator) fixes
         and cleanups (Bai Ping, Bartlomiej Zolnierkiewicz, Shilpasri G
         Bhat, Luis de Bethencourt).
    
       - cpuidle mvebu driver cleanups (Russell King).
    
       - OPP (Operating Performance Points) framework code reorganization to
         make it more maintainable (Viresh Kumar).
    
       - Intel Broxton support for the RAPL (Running Average Power Limits)
         power capping driver (Amy Wiles).
    
       - Assorted power management code fixes and cleanups (Dan Carpenter,
         Geert Uytterhoeven, Geliang Tang, Luis de Bethencourt, Rasmus
         Villemoes)"
    
    * tag 'pm+acpi-4.4-rc1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (108 commits)
      cpufreq: postfix policy directory with the first CPU in related_cpus
      cpufreq: create cpu/cpufreq/policyX directories
      cpufreq: remove cpufreq_sysfs_{create|remove}_file()
      cpufreq: create cpu/cpufreq at boot time
      cpufreq: Use cpumask_copy instead of cpumask_or to copy a mask
      cpufreq: ondemand: Drop unnecessary locks from update_sampling_rate()
      PM / Domains: Merge measurements for PM QoS device latencies
      PM / Domains: Don't measure ->start|stop() latency in system PM callbacks
      PM / clk: Fix broken build due to non-matching code and header #ifdefs
      ACPI / Documentation: add copy_dsdt to ACPI format options
      ACPI / sysfs: correctly check failing memory allocation
      ACPI / video: Add a quirk to force native backlight on Lenovo IdeaPad S405
      ACPI / CPPC: Fix potential memory leak
      ACPI / CPPC: signedness bug in register_pcc_channel()
      ACPI / PAD: power_saving_thread() is not freezable
      ACPI / PM: Fix incorrect wakeup IRQ setting during suspend-to-idle
      ACPI: Using correct irq when waiting for events
      ACPI: Use correct IRQ when uninstalling ACPI interrupt handler
      cpuidle: mvebu: disable the bind/unbind attributes and use builtin_platform_driver
      cpuidle: mvebu: clean up multiple platform drivers
      ...

commit b145dcc45a6af0abfcf9b4de8006d40559c50fc6
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Oct 13 12:51:36 2015 +0100

    irqdomain: Add a fwnode_handle allocator
    
    In order to be able to reference an irqdomain from ACPI, we need
    to be able to create an identifier, which is usually a struct
    device_node.
    
    This device node does't really fit the ACPI infrastructure, so
    we cunningly allocate a new structure containing a fwnode_handle,
    and return that.
    
    This structure doesn't really point to a device (interrupt
    controllers are not "real" devices in Linux), but as we cannot
    really deny that they exist, we create them with a new fwnode_type
    (FWNODE_IRQCHIP).
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-and-tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Graeme Gregory <graeme@xora.org.uk>
    Cc: Jake Oshins <jakeo@microsoft.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Link: http://lkml.kernel.org/r/1444737105-31573-9-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index 0408545bce42..37ec668546ab 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -17,6 +17,7 @@ enum fwnode_type {
 	FWNODE_OF,
 	FWNODE_ACPI,
 	FWNODE_PDATA,
+	FWNODE_IRQCHIP,
 };
 
 struct fwnode_handle {

commit 445b0eb058f5f31c844a731cb82e7441d0d9e578
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 27 04:36:14 2015 +0200

    ACPI / property: Add support for data-only subnodes
    
    In some cases, the information expressed via device properties is
    hierarchical by nature.  For example, the properties of a composite
    device consisting of multiple semi-dependent components may need
    to be represented in the form of a tree of property data sets
    corresponding to specific components of the device.
    
    Unfortunately, using ACPI device objects for this purpose turns out
    to be problematic, mostly due to the assumption made by some operating
    systems (that platform firmware generally needs to work with) that
    each device object in the ACPI namespace represents a device requiring
    a separate driver.  That assumption leads to complications which
    reportedly are impractically difficult to overcome and a different
    approach is needed for the sake of interoperability.
    
    The approach implemented here is based on extending _DSD via pointers
    (links) to additional ACPI objects returning data packages formatted
    in accordance with the _DSD formatting rules defined by Section 6.2.5
    of ACPI 6.  Those additional objects are referred to as data-only
    subnodes of the device object containing the _DSD pointing to them.
    
    The links to them need to be located in a separate section of the
    _DSD data package following UUID dbb8e3e6-5886-4ba6-8795-1319f52a966b
    referred to as the Hierarchical Data Extension UUID as defined in [1].
    Each of them is represented by a package of two strings.  The first
    string in that package (the key) is regarded as the name of the
    data-only subnode pointed to by the link.  The second string in it
    (the target) is expected to hold the ACPI namespace path (possibly
    utilizing the usual ACPI namespace search rules) of an ACPI object
    evaluating to a data package extending the _DSD.
    
    The device properties initialization code follows those links,
    creates a struct acpi_data_node object for each of them to store
    the data returned by the ACPI object pointed to by it and processes
    those data recursively (which may lead to the creation of more
    struct acpi_data_node objects if the returned data package contains
    the Hierarchical Data Extension UUID section with more links in it).
    
    All of the struct acpi_data_node objects are present until the the
    ACPI device object containing the _DSD with links to them is deleted
    and they are deleted along with that object.
    
    [1]: http://www.uefi.org/sites/default/files/resources/_DSD-hierarchical-data-extension-UUID-v1.pdf
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index 0408545bce42..b08d6ba5c1e6 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -16,6 +16,7 @@ enum fwnode_type {
 	FWNODE_INVALID = 0,
 	FWNODE_OF,
 	FWNODE_ACPI,
+	FWNODE_ACPI_DATA,
 	FWNODE_PDATA,
 };
 

commit 16ba08d5c9ec44f89ec03c67ecf7a9c5e2d204fd
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Apr 3 16:05:11 2015 +0200

    device property: Introduce firmware node type for platform data
    
    Introduce data structures and code allowing "built-in" properties
    to be associated with devices in such a way that they will be used
    by the device_property_* API if no proper firmware node (neither DT
    nor ACPI) is present for the given device.
    
    Each property is to be represented by a property_entry structure.
    An array of property_entry structures (terminated with a null
    entry) can be pointed to by the properties field of struct
    property_set that can be added as a firmware node to a struct
    device using device_add_property_set().  That will cause the
    device_property_* API to use that property_set as the source
    of properties if the given device does not have a DT node or
    an ACPI companion device object associated with it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index fc30b84b532a..0408545bce42 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -16,6 +16,7 @@ enum fwnode_type {
 	FWNODE_INVALID = 0,
 	FWNODE_OF,
 	FWNODE_ACPI,
+	FWNODE_PDATA,
 };
 
 struct fwnode_handle {

commit 97badf873ab60e841243b66133ff9eff2a46ef29
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Apr 3 23:23:37 2015 +0200

    device property: Make it possible to use secondary firmware nodes
    
    Add a secondary pointer to struct fwnode_handle so as to make it
    possible for a device to have two firmware nodes associated with
    it at the same time, for example, an ACPI node and a node with
    a set of properties provided by platform initialization code.
    
    In the future that will allow device property lookup to fall back
    from the primary firmware node to the secondary one if the given
    property is not present there to make it easier to provide defaults
    for device properties used by device drivers.
    
    Introduce two helper routines, set_primary_fwnode() and
    set_secondary_fwnode() allowing callers to add a primary/secondary
    firmware node to the given device in such a way that
    
     (1) If there's only one firmware node for that device, it will be
         pointed to by the device's firmware node pointer.
     (2) If both the primary and secondary firmware nodes are present,
         the primary one will be pointed to by the device's firmware
         node pointer, while the secondary one will be pointed to by the
         primary node's secondary pointer.
     (3) If one of these nodes is removed (by calling one of the new
         nelpers with NULL as the second argument), the other one will
         be preserved.
    
    Make ACPI use set_primary_fwnode() for attaching its firmware nodes
    to devices.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
index 17bb5f039509..fc30b84b532a 100644
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@ -20,6 +20,7 @@ enum fwnode_type {
 
 struct fwnode_handle {
 	enum fwnode_type type;
+	struct fwnode_handle *secondary;
 };
 
 #endif

commit ce793486e23e0162a732c605189c8028e0910e86
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Mar 16 23:49:03 2015 +0100

    driver core / ACPI: Represent ACPI companions using fwnode_handle
    
    Now that we have struct fwnode_handle, we can use that to point to
    ACPI companions from struct device objects instead of pointing to
    struct acpi_device directly.
    
    There are two benefits from that.  First, the somewhat ugly and
    hackish struct acpi_dev_node can be dropped and, second, the same
    struct fwnode_handle pointer can be used in the future to point
    to other (non-ACPI) firmware device node types.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Grant Likely <grant.likely@linaro.org>

diff --git a/include/linux/fwnode.h b/include/linux/fwnode.h
new file mode 100644
index 000000000000..17bb5f039509
--- /dev/null
+++ b/include/linux/fwnode.h
@@ -0,0 +1,25 @@
+/*
+ * fwnode.h - Firmware device node object handle type definition.
+ *
+ * Copyright (C) 2015, Intel Corporation
+ * Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _LINUX_FWNODE_H_
+#define _LINUX_FWNODE_H_
+
+enum fwnode_type {
+	FWNODE_INVALID = 0,
+	FWNODE_OF,
+	FWNODE_ACPI,
+};
+
+struct fwnode_handle {
+	enum fwnode_type type;
+};
+
+#endif
