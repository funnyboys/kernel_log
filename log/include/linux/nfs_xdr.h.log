commit 1ad8dd939a9826ff6f8c69ac13e4e1dbba076703
Author: Gustavo A. R. Silva <gustavoars@kernel.org>
Date:   Thu May 7 14:02:23 2020 -0500

    NFS: Replace zero-length array with flexible-array
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    sizeof(flexible-array-member) triggers a warning because flexible array
    members have incomplete type[1]. There are some instances of code in
    which the sizeof operator is being incorrectly/erroneously applied to
    zero-length arrays and the result is zero. Such instances may be hiding
    some bugs. So, this work (flexible-array member conversions) will also
    help to get completely rid of those sorts of issues.
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index e5f3e7d8d3d5..5fd0a9ef425f 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1227,7 +1227,7 @@ struct nfs4_secinfo4 {
 
 struct nfs4_secinfo_flavors {
 	unsigned int		num_flavors;
-	struct nfs4_secinfo4	flavors[0];
+	struct nfs4_secinfo4	flavors[];
 };
 
 struct nfs4_secinfo_arg {

commit dff58530c4ca8ce7ee5a74db431c6e35362cf682
Author: Olga Kornievskaia <olga.kornievskaia@gmail.com>
Date:   Fri Apr 24 17:45:50 2020 -0400

    NFSv4.1: fix handling of backchannel binding in BIND_CONN_TO_SESSION
    
    Currently, if the client sends BIND_CONN_TO_SESSION with
    NFS4_CDFC4_FORE_OR_BOTH but only gets NFS4_CDFS4_FORE back it ignores
    that it wasn't able to enable a backchannel.
    
    To make sure, the client sends BIND_CONN_TO_SESSION as the first
    operation on the connections (ie., no other session compounds haven't
    been sent before), and if the client's request to bind the backchannel
    is not satisfied, then reset the connection and retry.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Olga Kornievskaia <kolga@netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 440230488025..e5f3e7d8d3d5 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1317,11 +1317,13 @@ struct nfs41_impl_id {
 	struct nfstime4			date;
 };
 
+#define MAX_BIND_CONN_TO_SESSION_RETRIES 3
 struct nfs41_bind_conn_to_session_args {
 	struct nfs_client		*client;
 	struct nfs4_sessionid		sessionid;
 	u32				dir;
 	bool				use_conn_in_rdma_mode;
+	int				retries;
 };
 
 struct nfs41_bind_conn_to_session_res {

commit 04de788e61a576820baf03ff8accc246ca146cb3
Merge: f40f31cadc0e 93ce4af774bc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 7 13:51:39 2020 -0700

    Merge tag 'nfs-for-5.7-1' of git://git.linux-nfs.org/projects/trondmy/linux-nfs
    
    Pull NFS client updates from Trond Myklebust:
     "Highlights include:
    
      Stable fixes:
       - Fix a page leak in nfs_destroy_unlinked_subrequests()
    
       - Fix use-after-free issues in nfs_pageio_add_request()
    
       - Fix new mount code constant_table array definitions
    
       - finish_automount() requires us to hold 2 refs to the mount record
    
      Features:
       - Improve the accuracy of telldir/seekdir by using 64-bit cookies
         when possible.
    
       - Allow one RDMA active connection and several zombie connections to
         prevent blocking if the remote server is unresponsive.
    
       - Limit the size of the NFS access cache by default
    
       - Reduce the number of references to credentials that are taken by
         NFS
    
       - pNFS files and flexfiles drivers now support per-layout segment
         COMMIT lists.
    
       - Enable partial-file layout segments in the pNFS/flexfiles driver.
    
       - Add support for CB_RECALL_ANY to the pNFS flexfiles layout type
    
       - pNFS/flexfiles Report NFS4ERR_DELAY and NFS4ERR_GRACE errors from
         the DS using the layouterror mechanism.
    
      Bugfixes and cleanups:
       - SUNRPC: Fix krb5p regressions
    
       - Don't specify NFS version in "UDP not supported" error
    
       - nfsroot: set tcp as the default transport protocol
    
       - pnfs: Return valid stateids in nfs_layout_find_inode_by_stateid()
    
       - alloc_nfs_open_context() must use the file cred when available
    
       - Fix locking when dereferencing the delegation cred
    
       - Fix memory leaks in O_DIRECT when nfs_get_lock_context() fails
    
       - Various clean ups of the NFS O_DIRECT commit code
    
       - Clean up RDMA connect/disconnect
    
       - Replace zero-length arrays with C99-style flexible arrays"
    
    * tag 'nfs-for-5.7-1' of git://git.linux-nfs.org/projects/trondmy/linux-nfs: (86 commits)
      NFS: Clean up process of marking inode stale.
      SUNRPC: Don't start a timer on an already queued rpc task
      NFS/pnfs: Reference the layout cred in pnfs_prepare_layoutreturn()
      NFS/pnfs: Fix dereference of layout cred in pnfs_layoutcommit_inode()
      NFS: Beware when dereferencing the delegation cred
      NFS: Add a module parameter to set nfs_mountpoint_expiry_timeout
      NFS: finish_automount() requires us to hold 2 refs to the mount record
      NFS: Fix a few constant_table array definitions
      NFS: Try to join page groups before an O_DIRECT retransmission
      NFS: Refactor nfs_lock_and_join_requests()
      NFS: Reverse the submission order of requests in __nfs_pageio_add_request()
      NFS: Clean up nfs_lock_and_join_requests()
      NFS: Remove the redundant function nfs_pgio_has_mirroring()
      NFS: Fix memory leaks in nfs_pageio_stop_mirroring()
      NFS: Fix a request reference leak in nfs_direct_write_clear_reqs()
      NFS: Fix use-after-free issues in nfs_pageio_add_request()
      NFS: Fix races nfs_page_group_destroy() vs nfs_destroy_unlinked_subrequests()
      NFS: Fix a page leak in nfs_destroy_unlinked_subrequests()
      NFS: Remove unused FLUSH_SYNC support in nfs_initiate_pgio()
      pNFS/flexfiles: Specify the layout segment range in LAYOUTGET
      ...

commit 779df6a5480f1307d51b66ea72352be592265cad
Author: Scott Mayhew <smayhew@redhat.com>
Date:   Tue Mar 3 17:58:37 2020 -0500

    NFS: Ensure security label is set for root inode
    
    When using NFSv4.2, the security label for the root inode should be set
    via a call to nfs_setsecurity() during the mount process, otherwise the
    inode will appear as unlabeled for up to acdirmin seconds.  Currently
    the label for the root inode is allocated, retrieved, and freed entirely
    witin nfs4_proc_get_root().
    
    Add a field for the label to the nfs_fattr struct, and allocate & free
    the label in nfs_get_root(), where we also add a call to
    nfs_setsecurity().  Note that for the call to nfs_setsecurity() to
    succeed, it's necessary to also move the logic calling
    security_sb_{set,clone}_security() from nfs_get_tree_common() down into
    nfs_get_root()... otherwise the SBLABEL_MNT flag will not be set in the
    super_block's security flags and nfs_setsecurity() will silently fail.
    
    Reported-by: Richard Haines <richard_c_haines@btinternet.com>
    Signed-off-by: Scott Mayhew <smayhew@redhat.com>
    Acked-by: Stephen Smalley <sds@tycho.nsa.gov>
    Tested-by: Stephen Smalley <sds@tycho.nsa.gov>
    [PM: fixed 80-char line width problems]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 94c77ed55ce1..6838c149f335 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -75,6 +75,7 @@ struct nfs_fattr {
 	struct nfs4_string	*owner_name;
 	struct nfs4_string	*group_name;
 	struct nfs4_threshold	*mdsthreshold;	/* pNFS threshold hints */
+	struct nfs4_label	*label;
 };
 
 #define NFS_ATTR_FATTR_TYPE		(1U << 0)

commit c84bea59449aaa699a0600a50f59d441cc1d4501
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Sun Mar 22 14:47:38 2020 -0400

    NFS/pNFS: Simplify bucket layout segment reference counting
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index adbbeae9ce5b..7bbb1f6fc1b1 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1265,8 +1265,7 @@ struct nfstime4 {
 struct pnfs_commit_bucket {
 	struct list_head written;
 	struct list_head committing;
-	struct pnfs_layout_segment *wlseg;
-	struct pnfs_layout_segment *clseg;
+	struct pnfs_layout_segment *lseg;
 	struct nfs_writeverf direct_verf;
 };
 

commit 9c455a8c1e146dac3a6d1405fe6a7096177b9546
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Sat Mar 21 11:13:05 2020 -0400

    NFS/pNFS: Clean up pNFS commit operations
    
    Move the pNFS commit related operations into a separate structure
    that can be carried by the pnfs_ds_commit_info.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 2903597ec88c..adbbeae9ce5b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1284,6 +1284,7 @@ struct pnfs_ds_commit_info {
 	struct list_head commits;
 	unsigned int nwritten;
 	unsigned int ncommitting;
+	const struct pnfs_commit_ops *ops;
 };
 
 struct nfs41_state_protection {

commit 0aa647b7369dd29de0789c321111b2e4668c46b2
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Sat Mar 21 09:50:05 2020 -0400

    NFS: Remove bucket array from struct pnfs_ds_commit_info
    
    Remove the unused bucket array in struct pnfs_ds_commit_info.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 33be2ee2a248..2903597ec88c 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1284,8 +1284,6 @@ struct pnfs_ds_commit_info {
 	struct list_head commits;
 	unsigned int nwritten;
 	unsigned int ncommitting;
-	unsigned int nbuckets;
-	struct pnfs_commit_bucket *buckets;
 };
 
 struct nfs41_state_protection {
@@ -1396,22 +1394,11 @@ struct nfs41_free_stateid_res {
 	unsigned int			status;
 };
 
-static inline void
-nfs_free_pnfs_ds_cinfo(struct pnfs_ds_commit_info *cinfo)
-{
-	kfree(cinfo->buckets);
-}
-
 #else
 
 struct pnfs_ds_commit_info {
 };
 
-static inline void
-nfs_free_pnfs_ds_cinfo(struct pnfs_ds_commit_info *cinfo)
-{
-}
-
 #endif /* CONFIG_NFS_V4_1 */
 
 #ifdef CONFIG_NFS_V4_2

commit a9901899b649dc80ef75c14d6d78059cae14def7
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Fri Mar 20 16:04:06 2020 -0400

    pNFS: Add infrastructure for cleaning up per-layout commit structures
    
    Ensure that both the file and flexfiles layout types clean up when
    freeing the layout segments.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 9946787eda72..33be2ee2a248 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1275,6 +1275,7 @@ struct pnfs_commit_array {
 	struct list_head lseg_list;
 	struct pnfs_layout_segment *lseg;
 	struct rcu_head rcu;
+	refcount_t refcount;
 	unsigned int nbuckets;
 	struct pnfs_commit_bucket buckets[];
 };

commit c21e7168848d4ff4158120dbd4464f0d5cfb1456
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Thu Mar 19 13:36:36 2020 -0400

    NFSv4/pnfs: Support a list of commit arrays in struct pnfs_ds_commit_info
    
    When we have multiple layout segments with different lists of mirrored
    data, we need to track the commits on a per layout segment basis.
    This patch adds a list to support this tracking in struct
    pnfs_ds_commit_info.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index e91c917c9c1c..9946787eda72 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1280,6 +1280,7 @@ struct pnfs_commit_array {
 };
 
 struct pnfs_ds_commit_info {
+	struct list_head commits;
 	unsigned int nwritten;
 	unsigned int ncommitting;
 	unsigned int nbuckets;

commit d7242c4641fba521a1ea9dbccb11a40cf38cd912
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Wed Mar 18 17:22:47 2020 -0400

    pNFS: Add a helper to allocate the array of buckets
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 94c77ed55ce1..e91c917c9c1c 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1270,10 +1270,19 @@ struct pnfs_commit_bucket {
 	struct nfs_writeverf direct_verf;
 };
 
+struct pnfs_commit_array {
+	struct list_head cinfo_list;
+	struct list_head lseg_list;
+	struct pnfs_layout_segment *lseg;
+	struct rcu_head rcu;
+	unsigned int nbuckets;
+	struct pnfs_commit_bucket buckets[];
+};
+
 struct pnfs_ds_commit_info {
-	int nwritten;
-	int ncommitting;
-	int nbuckets;
+	unsigned int nwritten;
+	unsigned int ncommitting;
+	unsigned int nbuckets;
 	struct pnfs_commit_bucket *buckets;
 };
 

commit f7b37b8b139860ed786bf8ce4358290c6053d94d
Author: Trond Myklebust <trondmy@gmail.com>
Date:   Tue Jan 14 12:06:34 2020 -0500

    NFS: Add softreval behaviour to nfs_lookup_revalidate()
    
    If the server is unavaliable, we want to allow the revalidating
    lookup to time out, and to default to validating the cached dentry
    if the 'softreval' mount option is set.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 0a36c6f62b58..94c77ed55ce1 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1661,7 +1661,7 @@ struct nfs_rpc_ops {
 			    struct inode *);
 	int	(*setattr) (struct dentry *, struct nfs_fattr *,
 			    struct iattr *);
-	int	(*lookup)  (struct inode *, const struct qstr *,
+	int	(*lookup)  (struct inode *, struct dentry *,
 			    struct nfs_fh *, struct nfs_fattr *,
 			    struct nfs4_label *);
 	int	(*lookupp) (struct inode *, struct nfs_fh *,

commit 62a55d088cd87d480a6fd67b0d63b14ccae80838
Author: Scott Mayhew <smayhew@redhat.com>
Date:   Tue Dec 10 07:31:14 2019 -0500

    NFS: Additional refactoring for fs_context conversion
    
    Split out from commit "NFS: Add fs_context support."
    
    This patch adds additional refactoring for the conversion of NFS to use
    fs_context, namely:
    
     (*) Merge nfs_mount_info and nfs_clone_mount into nfs_fs_context.
         nfs_clone_mount has had several fields removed, and nfs_mount_info
         has been removed altogether.
     (*) Various functions now take an fs_context as an argument instead
         of nfs_mount_info, nfs_fs_context, etc.
    
    Signed-off-by: Scott Mayhew <smayhew@redhat.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 574741d5418d..0a36c6f62b58 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1722,7 +1722,7 @@ struct nfs_rpc_ops {
 	struct nfs_client *(*init_client) (struct nfs_client *,
 				const struct nfs_client_initdata *);
 	void	(*free_client) (struct nfs_client *);
-	struct nfs_server *(*create_server)(struct nfs_mount_info *);
+	struct nfs_server *(*create_server)(struct fs_context *);
 	struct nfs_server *(*clone_server)(struct nfs_server *, struct nfs_fh *,
 					   struct nfs_fattr *, rpc_authflavor_t);
 };

commit f2aedb713c284429987dc66c7aaf38decfc8da2a
Author: David Howells <dhowells@redhat.com>
Date:   Tue Dec 10 07:31:13 2019 -0500

    NFS: Add fs_context support.
    
    Add filesystem context support to NFS, parsing the options in advance and
    attaching the information to struct nfs_fs_context.  The highlights are:
    
     (*) Merge nfs_mount_info and nfs_clone_mount into nfs_fs_context.  This
         structure represents NFS's superblock config.
    
     (*) Make use of the VFS's parsing support to split comma-separated lists
    
     (*) Pin the NFS protocol module in the nfs_fs_context.
    
     (*) Attach supplementary error information to fs_context.  This has the
         downside that these strings must be static and can't be formatted.
    
     (*) Remove the auxiliary file_system_type structs since the information
         necessary can be conveyed in the nfs_fs_context struct instead.
    
     (*) Root mounts are made by duplicating the config for the requested mount
         so as to have the same parameters.  Submounts pick up their parameters
         from the parent superblock.
    
    [AV -- retrans is u32, not string]
    [SM -- Renamed cfg to ctx in a few functions in an earlier patch]
    [SM -- Moved fs_context mount option parsing to an earlier patch]
    [SM -- Moved fs_context error logging to a later patch]
    [SM -- Fixed printks in nfs4_try_get_tree() and nfs4_get_referral_tree()]
    [SM -- Added is_remount_fc() helper]
    [SM -- Deferred some refactoring to a later patch]
    [SM -- Fixed referral mounts, which were broken in the original patch]
    [SM -- Fixed leak of nfs_fattr when fs_context is freed]
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Scott Mayhew <smayhew@redhat.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 17527f6e6360..574741d5418d 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1639,6 +1639,7 @@ struct nfs_subversion;
 struct nfs_mount_info;
 struct nfs_client_initdata;
 struct nfs_pageio_descriptor;
+struct fs_context;
 
 /*
  * RPC procedure vector for NFSv2/NFSv3 demuxing
@@ -1653,9 +1654,8 @@ struct nfs_rpc_ops {
 
 	int	(*getroot) (struct nfs_server *, struct nfs_fh *,
 			    struct nfs_fsinfo *);
-	struct vfsmount *(*submount) (struct nfs_server *, struct dentry *,
-				      struct nfs_fh *, struct nfs_fattr *);
-	struct dentry *(*try_mount) (int, const char *, struct nfs_mount_info *);
+	int	(*submount) (struct fs_context *, struct nfs_server *);
+	int	(*try_get_tree) (struct fs_context *);
 	int	(*getattr) (struct nfs_server *, struct nfs_fh *,
 			    struct nfs_fattr *, struct nfs4_label *,
 			    struct inode *);

commit 0c38f2131df9865aa9fb24b7ad30a9657588e0e1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 10 07:31:00 2019 -0500

    nfs: don't pass nfs_subversion to ->create_server()
    
    pick it from mount_info
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 3ee2ad642cbc..17527f6e6360 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1722,7 +1722,7 @@ struct nfs_rpc_ops {
 	struct nfs_client *(*init_client) (struct nfs_client *,
 				const struct nfs_client_initdata *);
 	void	(*free_client) (struct nfs_client *);
-	struct nfs_server *(*create_server)(struct nfs_mount_info *, struct nfs_subversion *);
+	struct nfs_server *(*create_server)(struct nfs_mount_info *);
 	struct nfs_server *(*clone_server)(struct nfs_server *, struct nfs_fh *,
 					   struct nfs_fattr *, rpc_authflavor_t);
 };

commit a55d3297be587c6baa0242ae0fbb92489e576005
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 10 07:30:57 2019 -0500

    nfs: don't bother passing nfs_subversion to ->try_mount() and nfs_fs_mount_common()
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 72d5695c1b47..3ee2ad642cbc 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1655,8 +1655,7 @@ struct nfs_rpc_ops {
 			    struct nfs_fsinfo *);
 	struct vfsmount *(*submount) (struct nfs_server *, struct dentry *,
 				      struct nfs_fh *, struct nfs_fattr *);
-	struct dentry *(*try_mount) (int, const char *, struct nfs_mount_info *,
-				     struct nfs_subversion *);
+	struct dentry *(*try_mount) (int, const char *, struct nfs_mount_info *);
 	int	(*getattr) (struct nfs_server *, struct nfs_fh *,
 			    struct nfs_fattr *, struct nfs4_label *,
 			    struct inode *);

commit 807ce06c24fb1c24c3087a979b664c98eecf7b25
Merge: 66eb3add452a 8dff1df551df
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Tue Nov 5 14:53:29 2019 -0500

    Merge branch 'linux-ssc-for-5.5'

commit 6430b323ae09f146dfc26e6d17c432bfc3d11452
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Fri Oct 4 17:00:02 2019 -0400

    NFSv3: Clean up timespec encode
    
    Simplify the struct iattr timestamp encoding by skipping the step of
    an intermediate struct timespec.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index db5c01001937..22bc6613474e 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -869,7 +869,7 @@ struct nfs3_sattrargs {
 	struct nfs_fh *		fh;
 	struct iattr *		sattr;
 	unsigned int		guard;
-	struct timespec		guardtime;
+	struct timespec64	guardtime;
 };
 
 struct nfs3_diropargs {

commit e86d5a02874c1364c50e1b532481835b54173ed2
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Fri Oct 4 16:38:56 2019 -0400

    NFS: Convert struct nfs_fattr to use struct timespec64
    
    NFSv4 supports 64-bit times, so we should switch to using struct
    timespec64 when decoding attributes.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 9b8324ec08f3..db5c01001937 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -62,14 +62,14 @@ struct nfs_fattr {
 	struct nfs_fsid		fsid;
 	__u64			fileid;
 	__u64			mounted_on_fileid;
-	struct timespec		atime;
-	struct timespec		mtime;
-	struct timespec		ctime;
+	struct timespec64	atime;
+	struct timespec64	mtime;
+	struct timespec64	ctime;
 	__u64			change_attr;	/* NFSv4 change attribute */
 	__u64			pre_change_attr;/* pre-op NFSv4 change attribute */
 	__u64			pre_size;	/* pre_op_attr.size	  */
-	struct timespec		pre_mtime;	/* pre_op_attr.mtime	  */
-	struct timespec		pre_ctime;	/* pre_op_attr.ctime	  */
+	struct timespec64	pre_mtime;	/* pre_op_attr.mtime	  */
+	struct timespec64	pre_ctime;	/* pre_op_attr.ctime	  */
 	unsigned long		time_start;
 	unsigned long		gencount;
 	struct nfs4_string	*owner_name;
@@ -143,7 +143,7 @@ struct nfs_fsinfo {
 	__u32			wtmult;	/* writes should be multiple of this */
 	__u32			dtpref;	/* pref. readdir transfer size */
 	__u64			maxfilesize;
-	struct timespec		time_delta; /* server time granularity */
+	struct timespec64	time_delta; /* server time granularity */
 	__u32			lease_time; /* in seconds */
 	__u32			nlayouttypes; /* number of layouttypes */
 	__u32			layouttype[NFS_MAX_LAYOUT_TYPES]; /* supported pnfs layout driver */

commit 1d38f3f0d70008671f4dc055697ff3c3bb44a284
Author: Olga Kornievskaia <kolga@netapp.com>
Date:   Tue Jun 4 11:54:18 2019 -0400

    NFS: add ca_source_server<> to COPY
    
    Support only one source server address: the same address that
    the client and source server use.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Olga Kornievskaia <kolga@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 0a7af40026d7..008facac8a30 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1435,6 +1435,7 @@ struct nfs42_copy_args {
 
 	u64				count;
 	bool				sync;
+	struct nl4_server		*cp_src;
 };
 
 struct nfs42_write_res {

commit 0491567b51efeca807da1125a1a0d5193875e286
Author: Olga Kornievskaia <kolga@netapp.com>
Date:   Tue Jun 4 16:14:30 2019 -0400

    NFS: add COPY_NOTIFY operation
    
    Try using the delegation stateid, then the open stateid.
    
    Only NL4_NETATTR, No support for NL4_NAME and NL4_URL.
    Allow only one source server address to be returned for now.
    
    To distinguish between same server copy offload ("intra") and
    a copy between different server ("inter"), do a check of server
    owner identity and also make sure server is capable of doing
    a copy offload.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Olga Kornievskaia <kolga@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 9b8324ec08f3..0a7af40026d7 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1463,6 +1463,22 @@ struct nfs42_offload_status_res {
 	int				osr_status;
 };
 
+struct nfs42_copy_notify_args {
+	struct nfs4_sequence_args	cna_seq_args;
+
+	struct nfs_fh		*cna_src_fh;
+	nfs4_stateid		cna_src_stateid;
+	struct nl4_server	cna_dst;
+};
+
+struct nfs42_copy_notify_res {
+	struct nfs4_sequence_res	cnr_seq_res;
+
+	struct nfstime4		cnr_lease_time;
+	nfs4_stateid		cnr_stateid;
+	struct nl4_server	cnr_src;
+};
+
 struct nfs42_seek_args {
 	struct nfs4_sequence_args	seq_args;
 

commit 3eb86093ea400c58f444eac0debcf6c50d617418
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Fri Feb 8 10:31:05 2019 -0500

    NFSv4.2: Add client support for the generic 'layouterror' RPC call
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index b4bd2bf5f585..9b8324ec08f3 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -383,6 +383,41 @@ struct nfs42_layoutstat_data {
 	struct nfs42_layoutstat_res res;
 };
 
+struct nfs42_device_error {
+	struct nfs4_deviceid dev_id;
+	int status;
+	enum nfs_opnum4 opnum;
+};
+
+struct nfs42_layout_error {
+	__u64 offset;
+	__u64 length;
+	nfs4_stateid stateid;
+	struct nfs42_device_error errors[1];
+};
+
+#define NFS42_LAYOUTERROR_MAX 5
+
+struct nfs42_layouterror_args {
+	struct nfs4_sequence_args seq_args;
+	struct inode *inode;
+	unsigned int num_errors;
+	struct nfs42_layout_error errors[NFS42_LAYOUTERROR_MAX];
+};
+
+struct nfs42_layouterror_res {
+	struct nfs4_sequence_res seq_res;
+	unsigned int num_errors;
+	int rpc_status;
+};
+
+struct nfs42_layouterror_data {
+	struct nfs42_layouterror_args args;
+	struct nfs42_layouterror_res res;
+	struct inode *inode;
+	struct pnfs_layout_segment *lseg;
+};
+
 struct nfs42_clone_args {
 	struct nfs4_sequence_args	seq_args;
 	struct nfs_fh			*src_fh;

commit df3accb849607a86278a37c35e6b313635ccc48b
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Wed Feb 13 10:39:39 2019 -0500

    NFS: Pass error information to the pgio error cleanup routine
    
    Allow the caller to pass error information when cleaning up a failed
    I/O request so that we can conditionally take action to cancel the
    request altogether if the error turned out to be fatal.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 441a93ebcac0..b4bd2bf5f585 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1549,7 +1549,7 @@ struct nfs_commit_data {
 };
 
 struct nfs_pgio_completion_ops {
-	void	(*error_cleanup)(struct list_head *head);
+	void	(*error_cleanup)(struct list_head *head, int);
 	void	(*init_hdr)(struct nfs_pgio_header *hdr);
 	void	(*completion)(struct nfs_pgio_header *hdr);
 	void	(*reschedule_io)(struct nfs_pgio_header *hdr);

commit a52458b48af142bcc2b72fe810c0db20cfae7fdd
Author: NeilBrown <neilb@suse.com>
Date:   Mon Dec 3 11:30:31 2018 +1100

    NFS/NFSD/SUNRPC: replace generic creds with 'struct cred'.
    
    SUNRPC has two sorts of credentials, both of which appear as
    "struct rpc_cred".
    There are "generic credentials" which are supplied by clients
    such as NFS and passed in 'struct rpc_message' to indicate
    which user should be used to authorize the request, and there
    are low-level credentials such as AUTH_NULL, AUTH_UNIX, AUTH_GSS
    which describe the credential to be sent over the wires.
    
    This patch replaces all the generic credentials by 'struct cred'
    pointers - the credential structure used throughout Linux.
    
    For machine credentials, there is a special 'struct cred *' pointer
    which is statically allocated and recognized where needed as
    having a special meaning.  A look-up of a low-level cred will
    map this to a machine credential.
    
    Signed-off-by: NeilBrown <neilb@suse.com>
    Acked-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index cd489e2e0979..441a93ebcac0 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -270,7 +270,7 @@ struct nfs4_layoutget_res {
 struct nfs4_layoutget {
 	struct nfs4_layoutget_args args;
 	struct nfs4_layoutget_res res;
-	struct rpc_cred *cred;
+	const struct cred *cred;
 	gfp_t gfp_flags;
 };
 
@@ -309,7 +309,7 @@ struct nfs4_layoutcommit_data {
 	struct rpc_task task;
 	struct nfs_fattr fattr;
 	struct list_head lseg_list;
-	struct rpc_cred *cred;
+	const struct cred *cred;
 	struct inode *inode;
 	struct nfs4_layoutcommit_args args;
 	struct nfs4_layoutcommit_res res;
@@ -334,7 +334,7 @@ struct nfs4_layoutreturn_res {
 struct nfs4_layoutreturn {
 	struct nfs4_layoutreturn_args args;
 	struct nfs4_layoutreturn_res res;
-	struct rpc_cred *cred;
+	const struct cred *cred;
 	struct nfs_client *clp;
 	struct inode *inode;
 	int rpc_status;
@@ -1469,7 +1469,7 @@ enum {
 struct nfs_io_completion;
 struct nfs_pgio_header {
 	struct inode		*inode;
-	struct rpc_cred		*cred;
+	const struct cred		*cred;
 	struct list_head	pages;
 	struct nfs_page		*req;
 	struct nfs_writeverf	verf;		/* Used for writes */
@@ -1529,7 +1529,7 @@ struct nfs_commit_info {
 struct nfs_commit_data {
 	struct rpc_task		task;
 	struct inode		*inode;
-	struct rpc_cred		*cred;
+	const struct cred		*cred;
 	struct nfs_fattr	fattr;
 	struct nfs_writeverf	verf;
 	struct list_head	pages;		/* Coalesced requests we wish to flush */
@@ -1560,7 +1560,7 @@ struct nfs_unlinkdata {
 	struct nfs_removeres res;
 	struct dentry *dentry;
 	wait_queue_head_t wq;
-	struct rpc_cred	*cred;
+	const struct cred *cred;
 	struct nfs_fattr dir_attr;
 	long timeout;
 };
@@ -1568,7 +1568,7 @@ struct nfs_unlinkdata {
 struct nfs_renamedata {
 	struct nfs_renameargs	args;
 	struct nfs_renameres	res;
-	struct rpc_cred		*cred;
+	const struct cred	*cred;
 	struct inode		*old_dir;
 	struct dentry		*old_dentry;
 	struct nfs_fattr	old_fattr;

commit 684f39b4cf5186bb0660e686f94296688b24fb32
Author: NeilBrown <neilb@suse.com>
Date:   Mon Dec 3 11:30:30 2018 +1100

    NFS: struct nfs_open_dir_context: convert rpc_cred pointer to cred.
    
    Use the common 'struct cred' to pass credentials for readdir.
    
    Signed-off-by: NeilBrown <neilb@suse.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 0e016252cfc6..cd489e2e0979 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1634,7 +1634,7 @@ struct nfs_rpc_ops {
 			    unsigned int, struct iattr *);
 	int	(*mkdir)   (struct inode *, struct dentry *, struct iattr *);
 	int	(*rmdir)   (struct inode *, const struct qstr *);
-	int	(*readdir) (struct dentry *, struct rpc_cred *,
+	int	(*readdir) (struct dentry *, const struct cred *,
 			    u64, struct page **, unsigned int, bool);
 	int	(*mknod)   (struct inode *, struct dentry *, struct iattr *,
 			    dev_t);

commit 1c6c4b740df12f2162ae5c3fac337137e2776236
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Tue Sep 25 12:34:43 2018 -0400

    NFS: Remove private spinlock in struct nfs_pgio_header
    
    Now that each struct nfs_pgio_header corresponds to one RPC call, we
    only have one writer to the struct nfs_pgio_header.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 343e44166346..0e016252cfc6 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1482,11 +1482,10 @@ struct nfs_pgio_header {
 	const struct nfs_rw_ops	*rw_ops;
 	struct nfs_io_completion *io_completion;
 	struct nfs_direct_req	*dreq;
-	spinlock_t		lock;
-	/* fields protected by lock */
+
 	int			pnfs_error;
 	int			error;		/* merge with pnfs_error */
-	unsigned long		good_bytes;	/* boundary of good data */
+	unsigned int		good_bytes;	/* boundary of good data */
 	unsigned long		flags;
 
 	/*

commit 28d52235ee25ba7d843242b4cb3c3f27a8828b5a
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Mon Sep 24 13:15:37 2018 -0400

    NFSv4: Save a few bytes in the nfs_pgio_args/res
    
    Save a few bytes by allowing the read/write specific fields of the
    structures to share storage.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 7f5535e5e852..343e44166346 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -608,9 +608,13 @@ struct nfs_pgio_args {
 	__u32			count;
 	unsigned int		pgbase;
 	struct page **		pages;
-	unsigned int		replen;		/* used by read */
-	const u32 *		bitmask;	/* used by write */
-	enum nfs3_stable_how	stable;		/* used by write */
+	union {
+		unsigned int		replen;			/* used by read */
+		struct {
+			const u32 *		bitmask;	/* used by write */
+			enum nfs3_stable_how	stable;		/* used by write */
+		};
+	};
 };
 
 struct nfs_pgio_res {
@@ -618,10 +622,16 @@ struct nfs_pgio_res {
 	struct nfs_fattr *	fattr;
 	__u32			count;
 	__u32			op_status;
-	int			eof;		/* used by read */
-	unsigned int		replen;		/* used by read */
-	struct nfs_writeverf *	verf;		/* used by write */
-	const struct nfs_server *server;	/* used by write */
+	union {
+		struct {
+			unsigned int		replen;		/* used by read */
+			int			eof;		/* used by read */
+		};
+		struct {
+			struct nfs_writeverf *	verf;		/* used by write */
+			const struct nfs_server *server;	/* used by write */
+		};
+	};
 };
 
 /*

commit 8d8928d87960d71f898767185b8c0e4ce3de3cbe
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Mon Mar 5 12:03:00 2018 -0500

    NFSv3: Improve NFSv3 performance when server returns no post-op attributes
    
    When the server fails to return post-op attributes, the client's
    attempt to place read data directly in the page cache fails, and
    so we have to do an extra copy in order to realign the data with
    page borders.
    This patch attempts to detect servers that don't return post-op
    attributes on read (e.g. for pNFS) and adjusts the placement
    calculation accordingly.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index bd1c889a9ed9..7f5535e5e852 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -608,6 +608,7 @@ struct nfs_pgio_args {
 	__u32			count;
 	unsigned int		pgbase;
 	struct page **		pages;
+	unsigned int		replen;		/* used by read */
 	const u32 *		bitmask;	/* used by write */
 	enum nfs3_stable_how	stable;		/* used by write */
 };
@@ -618,9 +619,9 @@ struct nfs_pgio_res {
 	__u32			count;
 	__u32			op_status;
 	int			eof;		/* used by read */
+	unsigned int		replen;		/* used by read */
 	struct nfs_writeverf *	verf;		/* used by write */
 	const struct nfs_server *server;	/* used by write */
-
 };
 
 /*

commit 62164f317972fcd36590578888f33a1994dda519
Author: Olga Kornievskaia <kolga@netapp.com>
Date:   Mon Jul 9 15:13:31 2018 -0400

    NFS add support for asynchronous COPY
    
    Change xdr to always send COPY asynchronously.
    
    Keep the list copies send in a list under a server structure.
    Once copy is sent, it waits on a completion structure that will
    be signalled by the callback thread that receives CB_OFFLOAD.
    
    If CB_OFFLOAD returned an error and even if it returned partial
    bytes, ignore them (as we can't commit without a verifier to
    match) and return an error.
    
    Signed-off-by: Olga Kornievskaia <kolga@netapp.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 06ddfa31cbef..bd1c889a9ed9 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1388,6 +1388,7 @@ struct nfs42_copy_args {
 	u64				dst_pos;
 
 	u64				count;
+	bool				sync;
 };
 
 struct nfs42_write_res {

commit 67aa7444c4beb40aafedd8d2c60bbcc54987adda
Author: Olga Kornievskaia <kolga@netapp.com>
Date:   Mon Jul 9 15:13:30 2018 -0400

    NFS COPY xdr handle async reply
    
    If server returns async reply, it must include a callback stateid,
    wr_callback_id in the write_response4.
    
    Signed-off-by: Olga Kornievskaia <kolga@netapp.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 85e928a56cef..06ddfa31cbef 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1391,6 +1391,7 @@ struct nfs42_copy_args {
 };
 
 struct nfs42_write_res {
+	nfs4_stateid		stateid;
 	u64			count;
 	struct nfs_writeverf	verifier;
 };

commit cb95deea0b4aa5c7c7423f4e075a3ddcd59e710b
Author: Olga Kornievskaia <kolga@netapp.com>
Date:   Mon Jul 9 15:13:29 2018 -0400

    NFS OFFLOAD_CANCEL xdr
    
    Signed-off-by: Olga Kornievskaia <kolga@netapp.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 3b7325cfb291..85e928a56cef 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1403,6 +1403,18 @@ struct nfs42_copy_res {
 	struct nfs_commitres		commit_res;
 };
 
+struct nfs42_offload_status_args {
+	struct nfs4_sequence_args	osa_seq_args;
+	struct nfs_fh			*osa_src_fh;
+	nfs4_stateid			osa_stateid;
+};
+
+struct nfs42_offload_status_res {
+	struct nfs4_sequence_res	osr_seq_res;
+	uint64_t			osr_count;
+	int				osr_status;
+};
+
 struct nfs42_seek_args {
 	struct nfs4_sequence_args	seq_args;
 

commit af9b6d7570ca9afbbc6076ab7920d8f00f7e55c1
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Fri Jun 29 12:45:53 2018 -0400

    pNFS: Parse the results of layoutget on open even if permissions checks fail
    
    Even if the results of the permissions checks failed, we should parse
    the results of the layout on open call so that we can return the
    layout if required.
    Note that we also want to ignore the sequence counter for whether or not
    a layout recall occurred. If the recall pertained to our OPEN, then the
    callback will know, and will attempt to wait for us to finih processing
    anyway.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 712eed156d09..3b7325cfb291 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -271,7 +271,6 @@ struct nfs4_layoutget {
 	struct nfs4_layoutget_args args;
 	struct nfs4_layoutget_res res;
 	struct rpc_cred *cred;
-	unsigned callback_count;
 	gfp_t gfp_flags;
 };
 

commit 42f86b44a4d356edba626171dfe0be061fc695af
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Mon Jun 18 19:07:24 2018 -0400

    pNFS/flexfiles: Don't tie up all the rpciod threads in resends
    
    We do not want to have rpciod threads perform recursive calls into the
    RPC layer since that can deadlock. In particular, having to wait for
    a layoutget can be nasty... We want rather to defer scheduling those
    retries until we're in the rpc_release() callback, since that is
    called from the nfsiod workqueue.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 9dee3c23895d..712eed156d09 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1438,6 +1438,8 @@ enum {
 	NFS_IOHDR_EOF,
 	NFS_IOHDR_REDO,
 	NFS_IOHDR_STAT,
+	NFS_IOHDR_RESEND_PNFS,
+	NFS_IOHDR_RESEND_MDS,
 };
 
 struct nfs_io_completion;

commit a841b54dbd65421726caf7129f8951910c7a8ea6
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Sat Apr 7 13:50:59 2018 -0400

    NFS: Pass the inode down to the getattr() callback
    
    Allow the getattr() callback to check things like whether or not we hold
    a delegation so that it can adjust the attributes that it is asking for.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 09dc14ac5804..9dee3c23895d 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1581,7 +1581,8 @@ struct nfs_rpc_ops {
 	struct dentry *(*try_mount) (int, const char *, struct nfs_mount_info *,
 				     struct nfs_subversion *);
 	int	(*getattr) (struct nfs_server *, struct nfs_fh *,
-			    struct nfs_fattr *, struct nfs4_label *);
+			    struct nfs_fattr *, struct nfs4_label *,
+			    struct inode *);
 	int	(*setattr) (struct dentry *, struct nfs_fattr *,
 			    struct iattr *);
 	int	(*lookup)  (struct inode *, const struct qstr *,

commit c49b5209f99abe082d3d4cd94f0ad924baea34ed
Author: Fred Isaman <fred.isaman@gmail.com>
Date:   Wed Oct 5 09:37:12 2016 -0400

    pnfs: Add barrier to prevent lgopen using LAYOUTGET during recall
    
    Since the LAYOUTGET on OPEN can be sent without prior inode information,
    existing methods to prevent LAYOUTGET from being sent while processing
    CB_LAYOUTRECALL don't work.  Track if a recall occurred while LAYOUTGET
    was being sent, and if so ignore the results.
    
    Signed-off-by: Fred Isaman <fred.isaman@gmail.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index bc235e50415f..09dc14ac5804 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -271,6 +271,7 @@ struct nfs4_layoutget {
 	struct nfs4_layoutget_args args;
 	struct nfs4_layoutget_res res;
 	struct rpc_cred *cred;
+	unsigned callback_count;
 	gfp_t gfp_flags;
 };
 

commit 56f487f8c8fc5d6e582b79a86fc132d050129e15
Author: Fred Isaman <fred.isaman@gmail.com>
Date:   Wed Sep 21 11:43:41 2016 -0400

    pnfs: Add conditional encode/decode of LAYOUTGET within OPEN compound
    
    Signed-off-by: Fred Isaman <fred.isaman@gmail.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index d3aa5eaf99a7..bc235e50415f 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -436,6 +436,7 @@ struct nfs_openargs {
 	enum createmode4	createmode;
 	const struct nfs4_label *label;
 	umode_t			umask;
+	struct nfs4_layoutget_args *lg_args;
 };
 
 struct nfs_openres {
@@ -458,6 +459,7 @@ struct nfs_openres {
 	__u32			access_request;
 	__u32			access_supported;
 	__u32			access_result;
+	struct nfs4_layoutget_res *lg_res;
 };
 
 /*

commit 808ba32abe84b74abef5eb7507b8031f65b8221d
Author: Fred Isaman <fred.isaman@gmail.com>
Date:   Tue Oct 4 15:02:21 2016 -0400

    pnfs: Store return value of decode_layoutget for later processing
    
    This will be needed to seperate return value of OPEN and LAYOUTGET
    when they are combined into a single RPC.
    
    Signed-off-by: Fred Isaman <fred.isaman@gmail.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index d3cefe57c2a3..d3aa5eaf99a7 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -259,6 +259,7 @@ struct nfs4_layoutget_args {
 
 struct nfs4_layoutget_res {
 	struct nfs4_sequence_res seq_res;
+	int status;
 	__u32 return_on_close;
 	struct pnfs_layout_range range;
 	__u32 type;

commit ed7e9ad0908a8c2a502f49ceed940d0ce122fe8b
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Wed May 30 16:11:52 2018 -0400

    NFSv4: Fix sillyrename to return the delegation when appropriate
    
    Ensure that we pass down the inode of the file being deleted so
    that we can return any delegation being held.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 52b481dfd61e..d3cefe57c2a3 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1591,7 +1591,7 @@ struct nfs_rpc_ops {
 	int	(*create)  (struct inode *, struct dentry *,
 			    struct iattr *, int);
 	int	(*remove)  (struct inode *, struct dentry *);
-	void	(*unlink_setup)  (struct rpc_message *, struct dentry *);
+	void	(*unlink_setup)  (struct rpc_message *, struct dentry *, struct inode *);
 	void	(*unlink_rpc_prepare) (struct rpc_task *, struct nfs_unlinkdata *);
 	int	(*unlink_done) (struct rpc_task *, struct inode *);
 	void	(*rename_setup)  (struct rpc_message *msg,

commit e9ae1ee2b2ace7dcc37bc4e486b4410e7702ae57
Author: Anna Schumaker <Anna.Schumaker@Netapp.com>
Date:   Fri May 4 16:22:49 2018 -0400

    NFS: Move call to nfs4_state_protect() to nfs4_commit_setup()
    
    Rather than doing this in the generic NFS client code.  Let's put this
    with the other v4 stuff so it's all in one place.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 1009269e1a49..52b481dfd61e 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1623,7 +1623,8 @@ struct nfs_rpc_ops {
 	void	(*write_setup)(struct nfs_pgio_header *, struct rpc_message *,
 				struct rpc_clnt **);
 	int	(*write_done)(struct rpc_task *, struct nfs_pgio_header *);
-	void	(*commit_setup) (struct nfs_commit_data *, struct rpc_message *);
+	void	(*commit_setup) (struct nfs_commit_data *, struct rpc_message *,
+				struct rpc_clnt **);
 	void	(*commit_rpc_prepare)(struct rpc_task *, struct nfs_commit_data *);
 	int	(*commit_done) (struct rpc_task *, struct nfs_commit_data *);
 	int	(*lock)(struct file *, int, struct file_lock *);

commit fb91fb0ee7b266ed0344515c048f57ac65cdb4b4
Author: Anna Schumaker <Anna.Schumaker@Netapp.com>
Date:   Fri May 4 16:22:48 2018 -0400

    NFS: Move call to nfs4_state_protect_write() to nfs4_write_setup()
    
    This doesn't really need to be in the generic NFS client code, and I
    think it makes more sense to keep the v4 code in one place.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 34d28564ecf3..1009269e1a49 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1620,7 +1620,8 @@ struct nfs_rpc_ops {
 				    struct nfs_pgio_header *);
 	void	(*read_setup)(struct nfs_pgio_header *, struct rpc_message *);
 	int	(*read_done)(struct rpc_task *, struct nfs_pgio_header *);
-	void	(*write_setup)(struct nfs_pgio_header *, struct rpc_message *);
+	void	(*write_setup)(struct nfs_pgio_header *, struct rpc_message *,
+				struct rpc_clnt **);
 	int	(*write_done)(struct rpc_task *, struct nfs_pgio_header *);
 	void	(*commit_setup) (struct nfs_commit_data *, struct rpc_message *);
 	void	(*commit_rpc_prepare)(struct rpc_task *, struct nfs_commit_data *);

commit c135cb39a907b85aef5389c191b6f02cffbadb8a
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Tue Mar 20 16:43:19 2018 -0400

    NFS: Remove the unused return_delegation() callback
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index c4ba58b3c0f8..34d28564ecf3 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1635,7 +1635,6 @@ struct nfs_rpc_ops {
 				struct iattr *iattr,
 				int *);
 	int (*have_delegation)(struct inode *, fmode_t);
-	int (*return_delegation)(struct inode *);
 	struct nfs_client *(*alloc_client) (const struct nfs_client_initdata *);
 	struct nfs_client *(*init_client) (struct nfs_client *,
 				const struct nfs_client_initdata *);

commit 977fcc2b0b41c1fc82e8349995695e207ccb6684
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Tue Mar 20 16:43:17 2018 -0400

    NFS: Add a delegation return into nfs4_proc_unlink_setup()
    
    Ensure that when we do finally delete the file, then we return the
    delegation.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 4b87e2d726b1..c4ba58b3c0f8 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1591,7 +1591,7 @@ struct nfs_rpc_ops {
 	int	(*create)  (struct inode *, struct dentry *,
 			    struct iattr *, int);
 	int	(*remove)  (struct inode *, struct dentry *);
-	void	(*unlink_setup)  (struct rpc_message *, struct inode *dir);
+	void	(*unlink_setup)  (struct rpc_message *, struct dentry *);
 	void	(*unlink_rpc_prepare) (struct rpc_task *, struct nfs_unlinkdata *);
 	int	(*unlink_done) (struct rpc_task *, struct inode *);
 	void	(*rename_setup)  (struct rpc_message *msg,

commit f2c2c552f119db84d85a53a8bd76479f34df02b1
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Tue Mar 20 16:43:16 2018 -0400

    NFS: Move delegation recall into the NFSv4 callback for rename_setup()
    
    Move the delegation recall out of the generic code, and into the NFSv4
    specific callback.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 3ebf14b3bf0b..4b87e2d726b1 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1594,7 +1594,9 @@ struct nfs_rpc_ops {
 	void	(*unlink_setup)  (struct rpc_message *, struct inode *dir);
 	void	(*unlink_rpc_prepare) (struct rpc_task *, struct nfs_unlinkdata *);
 	int	(*unlink_done) (struct rpc_task *, struct inode *);
-	void	(*rename_setup)  (struct rpc_message *msg, struct inode *dir);
+	void	(*rename_setup)  (struct rpc_message *msg,
+			struct dentry *old_dentry,
+			struct dentry *new_dentry);
 	void	(*rename_rpc_prepare)(struct rpc_task *task, struct nfs_renamedata *);
 	int	(*rename_done) (struct rpc_task *task, struct inode *old_dir, struct inode *new_dir);
 	int	(*link)    (struct inode *, struct inode *, const struct qstr *);

commit 912678dbc592db7ad618f383866ad23e43cd51f3
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Tue Mar 20 16:43:15 2018 -0400

    NFS: Move the delegation return down into nfs4_proc_remove()
    
    Move the delegation return out of generic code and down into the
    NFSv4 specific unlink code.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 6959968dc36a..3ebf14b3bf0b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1590,7 +1590,7 @@ struct nfs_rpc_ops {
 			    unsigned int);
 	int	(*create)  (struct inode *, struct dentry *,
 			    struct iattr *, int);
-	int	(*remove)  (struct inode *, const struct qstr *);
+	int	(*remove)  (struct inode *, struct dentry *);
 	void	(*unlink_setup)  (struct rpc_message *, struct inode *dir);
 	void	(*unlink_rpc_prepare) (struct rpc_task *, struct nfs_unlinkdata *);
 	int	(*unlink_done) (struct rpc_task *, struct inode *);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 164d5359d4ab..6959968dc36a 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _LINUX_NFS_XDR_H
 #define _LINUX_NFS_XDR_H
 

commit 5cb953d4b1e70a09084f71594c45d47458346bc2
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Tue Aug 1 17:04:12 2017 -0400

    NFS: Use an atomic_long_t to count the number of commits
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 62cbcb842f99..164d5359d4ab 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1476,7 +1476,7 @@ struct nfs_pgio_header {
 
 struct nfs_mds_commit_info {
 	atomic_t rpcs_out;
-	unsigned long		ncommit;
+	atomic_long_t		ncommit;
 	struct list_head	list;
 };
 

commit fd40559c8657418385e42f797e0b04bfc0add748
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Tue Aug 1 16:02:47 2017 -0400

    NFSv4: Fix EXCHANGE_ID corrupt verifier issue
    
    The verifier is allocated on the stack, but the EXCHANGE_ID RPC call was
    changed to be asynchronous by commit 8d89bd70bc939. If we interrrupt
    the call to rpc_wait_for_completion_task(), we can therefore end up
    transmitting random stack contents in lieu of the verifier.
    
    Fixes: 8d89bd70bc939 ("NFS setup async exchange_id")
    Cc: stable@vger.kernel.org # v4.9+
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index ca3bcc4ed4e5..62cbcb842f99 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1235,7 +1235,7 @@ struct nfs41_state_protection {
 
 struct nfs41_exchange_id_args {
 	struct nfs_client		*client;
-	nfs4_verifier			*verifier;
+	nfs4_verifier			verifier;
 	u32				flags;
 	struct nfs41_state_protection	state_protect;
 };

commit 5b5faaf6df73412af0278997db36dbcb51011d9d
Author: Jeff Layton <jeff.layton@primarydata.com>
Date:   Thu Jun 29 06:34:52 2017 -0700

    nfs4: add NFSv4 LOOKUPP handlers
    
    This will be needed in order to implement the get_parent export op
    for nfsd.
    
    Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 89093341f076..ca3bcc4ed4e5 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1012,7 +1012,6 @@ struct nfs4_link_res {
 	struct nfs_fattr *		dir_attr;
 };
 
-
 struct nfs4_lookup_arg {
 	struct nfs4_sequence_args	seq_args;
 	const struct nfs_fh *		dir_fh;
@@ -1028,6 +1027,20 @@ struct nfs4_lookup_res {
 	struct nfs4_label		*label;
 };
 
+struct nfs4_lookupp_arg {
+	struct nfs4_sequence_args	seq_args;
+	const struct nfs_fh		*fh;
+	const u32			*bitmask;
+};
+
+struct nfs4_lookupp_res {
+	struct nfs4_sequence_res	seq_res;
+	const struct nfs_server		*server;
+	struct nfs_fattr		*fattr;
+	struct nfs_fh			*fh;
+	struct nfs4_label		*label;
+};
+
 struct nfs4_lookup_root_arg {
 	struct nfs4_sequence_args	seq_args;
 	const u32 *			bitmask;
@@ -1569,6 +1582,8 @@ struct nfs_rpc_ops {
 	int	(*lookup)  (struct inode *, const struct qstr *,
 			    struct nfs_fh *, struct nfs_fattr *,
 			    struct nfs4_label *);
+	int	(*lookupp) (struct inode *, struct nfs_fh *,
+			    struct nfs_fattr *, struct nfs4_label *);
 	int	(*access)  (struct inode *, struct nfs_access_entry *);
 	int	(*readlink)(struct inode *, struct page *, unsigned int,
 			    unsigned int);

commit 919e3bd9a87593520a2c5dfda27bd3e6599852ed
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Tue Jun 20 19:35:37 2017 -0400

    NFS: Ensure we commit after writeback is complete
    
    If the page cache is being flushed, then we want to ensure that we
    do start a commit once the pages are done being flushed.
    If we just wait until all I/O is done to that file, we can end up
    livelocking until the balance_dirty_pages() mechanism puts its
    foot down and forces I/O to stop.
    So instead we do more or less the same thing that O_DIRECT does,
    and set up a counter to tell us when the flush is done,
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 7f1e04941763..89093341f076 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1422,6 +1422,7 @@ enum {
 	NFS_IOHDR_STAT,
 };
 
+struct nfs_io_completion;
 struct nfs_pgio_header {
 	struct inode		*inode;
 	struct rpc_cred		*cred;
@@ -1435,6 +1436,7 @@ struct nfs_pgio_header {
 	void (*release) (struct nfs_pgio_header *hdr);
 	const struct nfs_pgio_completion_ops *completion_ops;
 	const struct nfs_rw_ops	*rw_ops;
+	struct nfs_io_completion *io_completion;
 	struct nfs_direct_req	*dreq;
 	spinlock_t		lock;
 	/* fields protected by lock */

commit b5973a8c1ccf375c9ab9e2428e1185e3f799af06
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Tue Jun 20 19:35:36 2017 -0400

    NFS: Remove unused fields in the page I/O structures
    
    Remove the 'layout_private' fields that were only used by the pNFS OSD
    layout driver.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 9463eeff9e3c..7f1e04941763 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1436,7 +1436,6 @@ struct nfs_pgio_header {
 	const struct nfs_pgio_completion_ops *completion_ops;
 	const struct nfs_rw_ops	*rw_ops;
 	struct nfs_direct_req	*dreq;
-	void			*layout_private;
 	spinlock_t		lock;
 	/* fields protected by lock */
 	int			pnfs_error;

commit 818a8dbe83fddff534b814a7d4e0c75b511dff2e
Author: Benjamin Coddington <bcodding@redhat.com>
Date:   Fri Jun 16 11:13:00 2017 -0400

    NFS: nfs_rename() - revalidate directories on -ERESTARTSYS
    
    An interrupted rename will leave the old dentry behind if the rename
    succeeds.  Fix this by forcing a lookup the next time through
    ->d_revalidate.
    
    A previous attempt at solving this problem took the approach to complete
    the work of the rename asynchronously, however that approach was wrong
    since it would allow the d_move() to occur after the directory's i_mutex
    had been dropped by the original process.
    
    Signed-off-by: Benjamin Coddington <bcodding@redhat.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 9b42bffbe07b..9463eeff9e3c 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1533,6 +1533,7 @@ struct nfs_renamedata {
 	struct nfs_fattr	new_fattr;
 	void (*complete)(struct rpc_task *, struct nfs_renamedata *);
 	long timeout;
+	bool cancelled;
 };
 
 struct nfs_access_entry;

commit a7a3b1e971cd806b81ecea3a234d8dae9de0add0
Author: Benjamin Coddington <bcodding@redhat.com>
Date:   Tue Jun 20 08:33:44 2017 -0400

    NFS: convert flags to bool
    
    NFS uses some int, and unsigned int :1, and bool as flags in structs and
    args.  Assert the preference for uniformly replacing these with the bool
    type.
    
    Signed-off-by: Benjamin Coddington <bcodding@redhat.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index b28c83475ee8..9b42bffbe07b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -878,7 +878,7 @@ struct nfs3_readdirargs {
 	struct nfs_fh *		fh;
 	__u64			cookie;
 	__be32			verf[2];
-	int			plus;
+	bool			plus;
 	unsigned int            count;
 	struct page **		pages;
 };
@@ -909,7 +909,7 @@ struct nfs3_linkres {
 struct nfs3_readdirres {
 	struct nfs_fattr *	dir_attr;
 	__be32 *		verf;
-	int			plus;
+	bool			plus;
 };
 
 struct nfs3_getaclres {
@@ -1053,7 +1053,7 @@ struct nfs4_readdir_arg {
 	struct page **			pages;	/* zero-copy data */
 	unsigned int			pgbase;	/* zero-copy data */
 	const u32 *			bitmask;
-	int				plus;
+	bool				plus;
 };
 
 struct nfs4_readdir_res {
@@ -1585,7 +1585,7 @@ struct nfs_rpc_ops {
 	int	(*mkdir)   (struct inode *, struct dentry *, struct iattr *);
 	int	(*rmdir)   (struct inode *, const struct qstr *);
 	int	(*readdir) (struct dentry *, struct rpc_cred *,
-			    u64, struct page **, unsigned int, int);
+			    u64, struct page **, unsigned int, bool);
 	int	(*mknod)   (struct inode *, struct dentry *, struct iattr *,
 			    dev_t);
 	int	(*statfs)  (struct nfs_server *, struct nfs_fh *,
@@ -1595,7 +1595,7 @@ struct nfs_rpc_ops {
 	int	(*pathconf) (struct nfs_server *, struct nfs_fh *,
 			     struct nfs_pathconf *);
 	int	(*set_capabilities)(struct nfs_server *, struct nfs_fh *);
-	int	(*decode_dirent)(struct xdr_stream *, struct nfs_entry *, int);
+	int	(*decode_dirent)(struct xdr_stream *, struct nfs_entry *, bool);
 	int	(*pgio_rpc_prepare)(struct rpc_task *,
 				    struct nfs_pgio_header *);
 	void	(*read_setup)(struct nfs_pgio_header *, struct rpc_message *);

commit e092693443b995c8e3a565a73b5fdb05f1260f9b
Author: Olga Kornievskaia <kolga@netapp.com>
Date:   Mon May 8 18:02:24 2017 -0400

    NFS append COMMIT after synchronous COPY
    
    Instead of messing with the commit path which has been causing issues,
    add a COMMIT op after the COPY and ask for stable copies in the first
    space.
    
    It saves a round trip, since after the COPY, the client sends a COMMIT
    anyway.
    
    Signed-off-by: Olga Kornievskaia <kolga@netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 677c6b91dfcd..b28c83475ee8 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1383,6 +1383,7 @@ struct nfs42_copy_res {
 	struct nfs42_write_res		write_res;
 	bool				consecutive;
 	bool				synchronous;
+	struct nfs_commitres		commit_res;
 };
 
 struct nfs42_seek_args {

commit b1ece737f44f91dca8f4829cf0b442e752e406db
Author: Benjamin Coddington <bcodding@redhat.com>
Date:   Tue Apr 11 12:50:11 2017 -0400

    lockd: Introduce nlmclnt_operations
    
    NFS would enjoy the ability to modify the behavior of the NLM client's
    unlock RPC task in order to delay the transmission of the unlock until IO
    that was submitted under that lock has completed.  This ability can ensure
    that the NLM client will always complete the transmission of an unlock even
    if the waiting caller has been interrupted with fatal signal.
    
    For this purpose, a pointer to a struct nlmclnt_operations can be assigned
    in a nfs_module's nfs_rpc_ops that will install those nlmclnt_operations on
    the nlm_host.  The struct nlmclnt_operations defines three callback
    operations that will be used in a following patch:
    
    nlmclnt_alloc_call - used to call back after a successful allocation of
            a struct nlm_rqst in nlmclnt_proc().
    
    nlmclnt_unlock_prepare - used to call back during NLM unlock's
            rpc_call_prepare.  The NLM client defers calling rpc_call_start()
            until this callback returns false.
    
    nlmclnt_release_call - used to call back when the NLM client's struct
            nlm_rqst is freed.
    
    Signed-off-by: Benjamin Coddington <bcodding@redhat.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 51e27f9746ee..677c6b91dfcd 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1551,6 +1551,7 @@ struct nfs_rpc_ops {
 	const struct inode_operations *dir_inode_ops;
 	const struct inode_operations *file_inode_ops;
 	const struct file_operations *file_ops;
+	const struct nlmclnt_operations *nlmclnt_ops;
 
 	int	(*getroot) (struct nfs_server *, struct nfs_fh *,
 			    struct nfs_fsinfo *);

commit fbe77c30e9abcb3429380dec622439991a718e31
Author: Benjamin Coddington <bcodding@redhat.com>
Date:   Wed Apr 19 10:11:35 2017 -0400

    NFS: move rw_mode to nfs_pageio_header
    
    Let's try to have it in a cacheline in nfs4_proc_pgio_rpc_prepare().
    
    Signed-off-by: Benjamin Coddington <bcodding@redhat.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 348f7c158084..51e27f9746ee 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1427,6 +1427,7 @@ struct nfs_pgio_header {
 	struct list_head	pages;
 	struct nfs_page		*req;
 	struct nfs_writeverf	verf;		/* Used for writes */
+	fmode_t			rw_mode;
 	struct pnfs_layout_segment *lseg;
 	loff_t			io_start;
 	const struct rpc_call_ops *mds_ops;

commit dff25ddb48086afcb434770caa3d6849a4489b85
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Fri Dec 2 22:53:30 2016 -0500

    nfs: add support for the umask attribute
    
    Clients can set the umask attribute when creating files to cause the
    server to apply it always except when inheriting permissions from the
    parent directory.  That way, the new files will end up with the same
    permissions as files created locally.
    
    See https://tools.ietf.org/html/draft-ietf-nfsv4-umask-02 for more details.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 617cfaa20ffc..348f7c158084 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -433,6 +433,7 @@ struct nfs_openargs {
 	enum open_claim_type4	claim;
 	enum createmode4	createmode;
 	const struct nfs4_label *label;
+	umode_t			umask;
 };
 
 struct nfs_openres {
@@ -958,6 +959,7 @@ struct nfs4_create_arg {
 	const struct nfs_fh *		dir_fh;
 	const u32 *			bitmask;
 	const struct nfs4_label		*label;
+	umode_t				umask;
 };
 
 struct nfs4_create_res {

commit 422c93c881a1689b5ad99e231a65ee5c51d3b72a
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Thu Oct 6 17:53:20 2016 -0400

    pNFS/flexfiles: Minor refactoring before adding iostats to layoutreturn
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index b64177d669fd..617cfaa20ffc 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -357,8 +357,7 @@ struct nfs42_layoutstat_devinfo {
 	__u64 write_count;
 	__u64 write_bytes;
 	__u32 layout_type;
-	layoutstats_encode_t layoutstats_encode;
-	void *layout_private;
+	struct nfs4_xdr_opaque_data ld_private;
 };
 
 struct nfs42_layoutstat_args {

commit 4d796d751cefdb942a54c570bd3087d8be3bb893
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Fri Sep 23 11:38:08 2016 -0400

    pNFS: Allow layout drivers to manage private data in struct nfs4_layoutreturn
    
    Cleanup to allow layout drivers to attach private data to layoutreturn,
    and manage the data.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 331a3200eb01..b64177d669fd 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -320,6 +320,7 @@ struct nfs4_layoutreturn_args {
 	struct pnfs_layout_range range;
 	nfs4_stateid stateid;
 	__u32   layout_type;
+	struct nfs4_xdr_opaque_data *ld_private;
 };
 
 struct nfs4_layoutreturn_res {
@@ -335,6 +336,7 @@ struct nfs4_layoutreturn {
 	struct nfs_client *clp;
 	struct inode *inode;
 	int rpc_status;
+	struct nfs4_xdr_opaque_data ld_private;
 };
 
 #define PNFS_LAYOUTSTATS_MAXSIZE 256

commit f8c3cf9d7d7f04718e0d51c28f8430afa6058b3b
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Thu Oct 20 10:12:45 2016 -0400

    NFSv4: Add a generic structure for managing layout-private information
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index bfbd0cace91b..331a3200eb01 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -216,6 +216,20 @@ struct nfs4_get_lease_time_res {
 	struct nfs_fsinfo	       *lr_fsinfo;
 };
 
+struct xdr_stream;
+struct nfs4_xdr_opaque_data;
+
+struct nfs4_xdr_opaque_ops {
+	void (*encode)(struct xdr_stream *, const void *args,
+			const struct nfs4_xdr_opaque_data *);
+	void (*free)(struct nfs4_xdr_opaque_data *);
+};
+
+struct nfs4_xdr_opaque_data {
+	const struct nfs4_xdr_opaque_ops *ops;
+	void *data;
+};
+
 #define PNFS_LAYOUT_MAXSIZE 4096
 
 struct nfs4_layoutdriver_data {

commit 586f1c39daf5c840c742b9be1ec236429f26dc13
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Tue Nov 15 15:03:33 2016 -0500

    NFSv4: Add encode/decode of the layoutreturn op in DELEGRETURN
    
    Add XDR encoding for the layoutreturn op, and storage for the layoutreturn
    arguments to the DELEGRETURN compound.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 44ed64bb66ae..bfbd0cace91b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -552,12 +552,15 @@ struct nfs4_delegreturnargs {
 	const struct nfs_fh *fhandle;
 	const nfs4_stateid *stateid;
 	const u32 * bitmask;
+	struct nfs4_layoutreturn_args *lr_args;
 };
 
 struct nfs4_delegreturnres {
 	struct nfs4_sequence_res	seq_res;
 	struct nfs_fattr * fattr;
 	struct nfs_server *server;
+	struct nfs4_layoutreturn_res *lr_res;
+	int lr_ret;
 };
 
 /*

commit cf80516579ceb87b91205e68fb31d5affd5aea8d
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Tue Nov 15 14:56:07 2016 -0500

    NFSv4: Add encode/decode of the layoutreturn op in CLOSE
    
    Add XDR encoding for the layoutreturn op, and storage for the layoutreturn
    arguments to the CLOSE compound.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index beb1e10f446e..44ed64bb66ae 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -469,6 +469,7 @@ struct nfs_closeargs {
 	fmode_t			fmode;
 	u32			share_access;
 	const u32 *		bitmask;
+	struct nfs4_layoutreturn_args *lr_args;
 };
 
 struct nfs_closeres {
@@ -477,6 +478,8 @@ struct nfs_closeres {
 	struct nfs_fattr *	fattr;
 	struct nfs_seqid *	seqid;
 	const struct nfs_server *server;
+	struct nfs4_layoutreturn_res *lr_res;
+	int lr_ret;
 };
 /*
  *  * Arguments to the lock,lockt, and locku call.

commit ca440c383a588091cae9fbce610b86a6e9d961ad
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Sep 15 14:40:49 2016 -0400

    pnfs: add a new mechanism to select a layout driver according to an ordered list
    
    Currently, the layout driver selection code always chooses the first one
    from the list. That's not really ideal however, as the server can send
    the list of layout types in any order that it likes. It's up to the
    client to select the best one for its needs.
    
    This patch adds an ordered list of preferred driver types and has the
    selection code sort the list of available layout drivers according to it.
    Any unrecognized layout type is sorted to the end of the list.
    
    For now, the order of preference is hardcoded, but it should be possible
    to make this configurable in the future.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: J. Bruce Fields <bfields@fieldses.org>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index f11b26ed001b..beb1e10f446e 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -144,6 +144,7 @@ struct nfs_fsinfo {
 	__u64			maxfilesize;
 	struct timespec		time_delta; /* server time granularity */
 	__u32			lease_time; /* in seconds */
+	__u32			nlayouttypes; /* number of layouttypes */
 	__u32			layouttype[NFS_MAX_LAYOUT_TYPES]; /* supported pnfs layout driver */
 	__u32			blksize; /* preferred pnfs io block size */
 	__u32			clone_blksize; /* granularity of a CLONE operation */

commit 3132e49ecef9dab43d858d8e7066662c6a1efb16
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Aug 10 15:58:24 2016 -0400

    pnfs: track multiple layout types in fsinfo structure
    
    Current NFSv4.1/pNFS client assumes that MDS supports only one layout
    type. While it's true for most existing servers, nevertheless, this can
    be change in the near future.
    
    For now, this patch just plumbs in the ability to track a list of
    layouts in the fsinfo structure. The existing behavior of the client
    is preserved, by having it just select the first entry in the list.
    
    Signed-off-by: Tigran Mkrtchyan <tigran.mkrtchyan@desy.de>
    Signed-off-by: Jeff Layton <jlayton@poochiereds.net>
    Reviewed-by: J. Bruce Fields <bfields@fieldses.org>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 7cc0deee5bde..f11b26ed001b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -124,6 +124,11 @@ struct nfs_fattr {
 		| NFS_ATTR_FATTR_SPACE_USED \
 		| NFS_ATTR_FATTR_V4_SECURITY_LABEL)
 
+/*
+ * Maximal number of supported layout drivers.
+ */
+#define NFS_MAX_LAYOUT_TYPES 8
+
 /*
  * Info on the file system
  */
@@ -139,7 +144,7 @@ struct nfs_fsinfo {
 	__u64			maxfilesize;
 	struct timespec		time_delta; /* server time granularity */
 	__u32			lease_time; /* in seconds */
-	__u32			layouttype; /* supported pnfs layout driver */
+	__u32			layouttype[NFS_MAX_LAYOUT_TYPES]; /* supported pnfs layout driver */
 	__u32			blksize; /* preferred pnfs io block size */
 	__u32			clone_blksize; /* granularity of a CLONE operation */
 };

commit 835c92d43b29eb354abdbd5475308a474d7efdfa
Merge: ce804bf598b5 19a6d89de2f1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 6 09:49:02 2016 -0400

    Merge branch 'work.const-qstr' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull qstr constification updates from Al Viro:
     "Fairly self-contained bunch - surprising lot of places passes struct
      qstr * as an argument when const struct qstr * would suffice; it
      complicates analysis for no good reason.
    
      I'd prefer to feed that separately from the assorted fixes (those are
      in #for-linus and with somewhat trickier topology)"
    
    * 'work.const-qstr' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      qstr: constify instances in adfs
      qstr: constify instances in lustre
      qstr: constify instances in f2fs
      qstr: constify instances in ext2
      qstr: constify instances in vfat
      qstr: constify instances in procfs
      qstr: constify instances in fuse
      qstr constify instances in fs/dcache.c
      qstr: constify instances in nfs
      qstr: constify instances in ocfs2
      qstr: constify instances in autofs4
      qstr: constify instances in hfs
      qstr: constify instances in hfsplus
      qstr: constify instances in logfs
      qstr: constify dentry_init_security

commit a71e36045e1fd5813addad2fce878d96e2827d66
Merge: d58b0d980f0b 2b11885921a4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Aug 4 19:59:06 2016 -0400

    Merge tag 'nfsd-4.8' of git://linux-nfs.org/~bfields/linux
    
    Pull nfsd updates from Bruce Fields:
     "Highlights:
    
       - Trond made a change to the server's tcp logic that allows a fast
         client to better take advantage of high bandwidth networks, but may
         increase the risk that a single client could starve other clients;
         a new sunrpc.svc_rpc_per_connection_limit parameter should help
         mitigate this in the (hopefully unlikely) event this becomes a
         problem in practice.
    
       - Tom Haynes added a minimal flex-layout pnfs server, which is of no
         use in production for now--don't build it unless you're doing
         client testing or further server development"
    
    * tag 'nfsd-4.8' of git://linux-nfs.org/~bfields/linux: (32 commits)
      nfsd: remove some dead code in nfsd_create_locked()
      nfsd: drop unnecessary MAY_EXEC check from create
      nfsd: clean up bad-type check in nfsd_create_locked
      nfsd: remove unnecessary positive-dentry check
      nfsd: reorganize nfsd_create
      nfsd: check d_can_lookup in fh_verify of directories
      nfsd: remove redundant zero-length check from create
      nfsd: Make creates return EEXIST instead of EACCES
      SUNRPC: Detect immediate closure of accepted sockets
      SUNRPC: accept() may return sockets that are still in SYN_RECV
      nfsd: allow nfsd to advertise multiple layout types
      nfsd: Close race between nfsd4_release_lockowner and nfsd4_lock
      nfsd/blocklayout: Make sure calculate signature/designator length aligned
      xfs: abstract block export operations from nfsd layouts
      SUNRPC: Remove unused callback xpo_adjust_wspace()
      SUNRPC: Change TCP socket space reservation
      SUNRPC: Add a server side per-connection limit
      SUNRPC: Micro optimisation for svc_data_ready
      SUNRPC: Call the default socket callbacks instead of open coding
      SUNRPC: lock the socket while detaching it
      ...

commit beffb8feb6e26851165ee927e0eb963d6db334b0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jul 20 16:34:42 2016 -0400

    qstr: constify instances in nfs
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index c304a11b5b1a..890b4aba2711 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1543,7 +1543,7 @@ struct nfs_rpc_ops {
 			    struct nfs_fattr *, struct nfs4_label *);
 	int	(*setattr) (struct dentry *, struct nfs_fattr *,
 			    struct iattr *);
-	int	(*lookup)  (struct inode *, struct qstr *,
+	int	(*lookup)  (struct inode *, const struct qstr *,
 			    struct nfs_fh *, struct nfs_fattr *,
 			    struct nfs4_label *);
 	int	(*access)  (struct inode *, struct nfs_access_entry *);
@@ -1551,18 +1551,18 @@ struct nfs_rpc_ops {
 			    unsigned int);
 	int	(*create)  (struct inode *, struct dentry *,
 			    struct iattr *, int);
-	int	(*remove)  (struct inode *, struct qstr *);
+	int	(*remove)  (struct inode *, const struct qstr *);
 	void	(*unlink_setup)  (struct rpc_message *, struct inode *dir);
 	void	(*unlink_rpc_prepare) (struct rpc_task *, struct nfs_unlinkdata *);
 	int	(*unlink_done) (struct rpc_task *, struct inode *);
 	void	(*rename_setup)  (struct rpc_message *msg, struct inode *dir);
 	void	(*rename_rpc_prepare)(struct rpc_task *task, struct nfs_renamedata *);
 	int	(*rename_done) (struct rpc_task *task, struct inode *old_dir, struct inode *new_dir);
-	int	(*link)    (struct inode *, struct inode *, struct qstr *);
+	int	(*link)    (struct inode *, struct inode *, const struct qstr *);
 	int	(*symlink) (struct inode *, struct dentry *, struct page *,
 			    unsigned int, struct iattr *);
 	int	(*mkdir)   (struct inode *, struct dentry *, struct iattr *);
-	int	(*rmdir)   (struct inode *, struct qstr *);
+	int	(*rmdir)   (struct inode *, const struct qstr *);
 	int	(*readdir) (struct dentry *, struct rpc_cred *,
 			    u64, struct page **, unsigned int, int);
 	int	(*mknod)   (struct inode *, struct dentry *, struct iattr *,

commit 1adf0c5a4451a100cd9253c1d6e3ca77f4a5a98b
Author: Andrew Elble <aweits@rit.edu>
Date:   Wed Jun 15 12:52:07 2016 -0400

    nfs/nfsd: Move useful bitfield ops to a commonly accessible place
    
    So these may be used in nfsd as well
    
    Signed-off-by: Andrew Elble <aweits@rit.edu>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index c304a11b5b1a..e66abc2d1f88 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1185,17 +1185,6 @@ struct pnfs_ds_commit_info {
 	struct pnfs_commit_bucket *buckets;
 };
 
-#define NFS4_OP_MAP_NUM_LONGS \
-	DIV_ROUND_UP(LAST_NFS4_OP, 8 * sizeof(unsigned long))
-#define NFS4_OP_MAP_NUM_WORDS \
-	(NFS4_OP_MAP_NUM_LONGS * sizeof(unsigned long) / sizeof(u32))
-struct nfs4_op_map {
-	union {
-		unsigned long longs[NFS4_OP_MAP_NUM_LONGS];
-		u32 words[NFS4_OP_MAP_NUM_WORDS];
-	} u;
-};
-
 struct nfs41_state_protection {
 	u32 how;
 	struct nfs4_op_map enforce;

commit 5c6e5b60aae4347223f176966455010a5715b863
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Wed Jun 22 14:13:12 2016 -0400

    NFS: Fix an Oops in the pNFS files and flexfiles connection setup to the DS
    
    Chris Worley reports:
     RIP: 0010:[<ffffffffa0245f80>]  [<ffffffffa0245f80>] rpc_new_client+0x2a0/0x2e0 [sunrpc]
     RSP: 0018:ffff880158f6f548  EFLAGS: 00010246
     RAX: 0000000000000000 RBX: ffff880234f8bc00 RCX: 000000000000ea60
     RDX: 0000000000074cc0 RSI: 000000000000ea60 RDI: ffff880234f8bcf0
     RBP: ffff880158f6f588 R08: 000000000001ac80 R09: ffff880237003300
     R10: ffff880201171000 R11: ffffea0000d75200 R12: ffffffffa03afc60
     R13: ffff880230c18800 R14: 0000000000000000 R15: ffff880158f6f680
     FS:  00007f0e32673740(0000) GS:ffff88023fc40000(0000) knlGS:0000000000000000
     CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
     CR2: 0000000000000008 CR3: 0000000234886000 CR4: 00000000001406e0
     Stack:
      ffffffffa047a680 0000000000000000 ffff880158f6f598 ffff880158f6f680
      ffff880158f6f680 ffff880234d11d00 ffff88023357f800 ffff880158f6f7d0
      ffff880158f6f5b8 ffffffffa024660a ffff880158f6f5b8 ffffffffa02492ec
     Call Trace:
      [<ffffffffa024660a>] rpc_create_xprt+0x1a/0xb0 [sunrpc]
      [<ffffffffa02492ec>] ? xprt_create_transport+0x13c/0x240 [sunrpc]
      [<ffffffffa0246766>] rpc_create+0xc6/0x1a0 [sunrpc]
      [<ffffffffa038e695>] nfs_create_rpc_client+0xf5/0x140 [nfs]
      [<ffffffffa038f31a>] nfs_init_client+0x3a/0xd0 [nfs]
      [<ffffffffa038f22f>] nfs_get_client+0x25f/0x310 [nfs]
      [<ffffffffa025cef8>] ? rpc_ntop+0xe8/0x100 [sunrpc]
      [<ffffffffa047512c>] nfs3_set_ds_client+0xcc/0x100 [nfsv3]
      [<ffffffffa041fa10>] nfs4_pnfs_ds_connect+0x120/0x400 [nfsv4]
      [<ffffffffa03d41c7>] nfs4_ff_layout_prepare_ds+0xe7/0x330 [nfs_layout_flexfiles]
      [<ffffffffa03d1b1b>] ff_layout_pg_init_write+0xcb/0x280 [nfs_layout_flexfiles]
      [<ffffffffa03a14dc>] __nfs_pageio_add_request+0x12c/0x490 [nfs]
      [<ffffffffa03a1fa2>] nfs_pageio_add_request+0xc2/0x2a0 [nfs]
      [<ffffffffa03a0365>] ? nfs_pageio_init+0x75/0x120 [nfs]
      [<ffffffffa03a5b50>] nfs_do_writepage+0x120/0x270 [nfs]
      [<ffffffffa03a5d31>] nfs_writepage_locked+0x61/0xc0 [nfs]
      [<ffffffff813d4115>] ? __percpu_counter_add+0x55/0x70
      [<ffffffffa03a6a9f>] nfs_wb_single_page+0xef/0x1c0 [nfs]
      [<ffffffff811ca4a3>] ? __dec_zone_page_state+0x33/0x40
      [<ffffffffa0395b21>] nfs_launder_page+0x41/0x90 [nfs]
      [<ffffffff811baba0>] invalidate_inode_pages2_range+0x340/0x3a0
      [<ffffffff811bac17>] invalidate_inode_pages2+0x17/0x20
      [<ffffffffa039960e>] nfs_release+0x9e/0xb0 [nfs]
      [<ffffffffa0399570>] ? nfs_open+0x60/0x60 [nfs]
      [<ffffffffa0394dad>] nfs_file_release+0x3d/0x60 [nfs]
      [<ffffffff81226e6c>] __fput+0xdc/0x1e0
      [<ffffffff81226fbe>] ____fput+0xe/0x10
      [<ffffffff810bf2e4>] task_work_run+0xc4/0xe0
      [<ffffffff810a4188>] do_exit+0x2e8/0xb30
      [<ffffffff8102471c>] ? do_audit_syscall_entry+0x6c/0x70
      [<ffffffff811464e6>] ? __audit_syscall_exit+0x1e6/0x280
      [<ffffffff810a4a5f>] do_group_exit+0x3f/0xa0
      [<ffffffff810a4ad4>] SyS_exit_group+0x14/0x20
      [<ffffffff8179b76e>] system_call_fastpath+0x12/0x71
    
    Which seems to be due to a call to utsname() when in a task exit context
    in order to determine the hostname to set in rpc_new_client().
    
    In reality, what we want here is not the hostname of the current task, but
    the hostname that was used to set up the metadata server.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index c304a11b5b1a..82b81a1c2438 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1596,9 +1596,8 @@ struct nfs_rpc_ops {
 	int (*have_delegation)(struct inode *, fmode_t);
 	int (*return_delegation)(struct inode *);
 	struct nfs_client *(*alloc_client) (const struct nfs_client_initdata *);
-	struct nfs_client *
-		(*init_client) (struct nfs_client *, const struct rpc_timeout *,
-				const char *);
+	struct nfs_client *(*init_client) (struct nfs_client *,
+				const struct nfs_client_initdata *);
 	void	(*free_client) (struct nfs_client *);
 	struct nfs_server *(*create_server)(struct nfs_mount_info *, struct nfs_subversion *);
 	struct nfs_server *(*clone_server)(struct nfs_server *, struct nfs_fh *,

commit ea8ea737c46cffa5d0ee74309f81e55a7e5e9c2a
Merge: 0b9210c9c86e c7d73af2d249
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 26 10:33:33 2016 -0700

    Merge tag 'nfs-for-4.7-1' of git://git.linux-nfs.org/projects/anna/linux-nfs
    
    Pull NFS client updates from Anna Schumaker:
     "Highlights include:
    
      Features:
       - Add support for the NFS v4.2 COPY operation
       - Add support for NFS/RDMA over IPv6
    
      Bugfixes and cleanups:
       - Avoid race that crashes nfs_init_commit()
       - Fix oops in callback path
       - Fix LOCK/OPEN race when unlinking an open file
       - Choose correct stateids when using delegations in setattr, read and
         write
       - Don't send empty SETATTR after OPEN_CREATE
       - xprtrdma: Prevent server from writing a reply into memory client
         has released
       - xprtrdma: Support using Read list and Reply chunk in one RPC call"
    
    * tag 'nfs-for-4.7-1' of git://git.linux-nfs.org/projects/anna/linux-nfs: (61 commits)
      pnfs: pnfs_update_layout needs to consider if strict iomode checking is on
      nfs/flexfiles: Use the layout segment for reading unless it a IOMODE_RW and reading is disabled
      nfs/flexfiles: Helper function to detect FF_FLAGS_NO_READ_IO
      nfs: avoid race that crashes nfs_init_commit
      NFS: checking for NULL instead of IS_ERR() in nfs_commit_file()
      pnfs: make pnfs_layout_process more robust
      pnfs: rework LAYOUTGET retry handling
      pnfs: lift retry logic from send_layoutget to pnfs_update_layout
      pnfs: fix bad error handling in send_layoutget
      flexfiles: add kerneldoc header to nfs4_ff_layout_prepare_ds
      flexfiles: remove pointless setting of NFS_LAYOUT_RETURN_REQUESTED
      pnfs: only tear down lsegs that precede seqid in LAYOUTRETURN args
      pnfs: keep track of the return sequence number in pnfs_layout_hdr
      pnfs: record sequence in pnfs_layout_segment when it's created
      pnfs: don't merge new ff lsegs with ones that have LAYOUTRETURN bit set
      pNFS/flexfiles: When initing reads or writes, we might have to retry connecting to DSes
      pNFS/flexfiles: When checking for available DSes, conditionally check for MDS io
      pNFS/flexfile: Fix erroneous fall back to read/write through the MDS
      NFS: Reclaim writes via writepage are opportunistic
      NFSv4: Use the right stateid for delegations in setattr, read and write
      ...

commit 183d9e7b112aaed0d19c16ffcf0f8c3a86dc71e0
Author: Jeff Layton <jlayton@poochiereds.net>
Date:   Tue May 17 12:28:47 2016 -0400

    pnfs: rework LAYOUTGET retry handling
    
    There are several problems in the way a stateid is selected for a
    LAYOUTGET operation:
    
    We pick a stateid to use in the RPC prepare op, but that makes
    it difficult to serialize LAYOUTGETs that use the open stateid. That
    serialization is done in pnfs_update_layout, which occurs well before
    the rpc_prepare operation.
    
    Between those two events, the i_lock is dropped and reacquired.
    pnfs_update_layout can find that the list has lsegs in it and not do any
    serialization, but then later pnfs_choose_layoutget_stateid ends up
    choosing the open stateid.
    
    This patch changes the client to select the stateid to use in the
    LAYOUTGET earlier, when we're searching for a usable layout segment.
    This way we can do it all while holding the i_lock the first time, and
    ensure that we serialize any LAYOUTGET call that uses a non-layout
    stateid.
    
    This also means a rework of how LAYOUTGET replies are handled, as we
    must now get the latest stateid if we want to retransmit in response
    to a retryable error.
    
    Most of those errors boil down to the fact that the layout state has
    changed in some fashion. Thus, what we really want to do is to re-search
    for a layout when it fails with a retryable error, so that we can avoid
    reissuing the RPC at all if possible.
    
    While the LAYOUTGET RPC is async, the initiating thread always waits for
    it to complete, so it's effectively synchronous anyway. Currently, when
    we need to retry a LAYOUTGET because of an error, we drive that retry
    via the rpc state machine.
    
    This means that once the call has been submitted, it runs until it
    completes. So, we must move the error handling for this RPC out of the
    rpc_call_done operation and into the caller.
    
    In order to handle errors like NFS4ERR_DELAY properly, we must also
    pass a pointer to the sliding timeout, which is now moved to the stack
    in pnfs_update_layout.
    
    The complicating errors are -NFS4ERR_RECALLCONFLICT and
    -NFS4ERR_LAYOUTTRYLATER, as those involve a timeout after which we give
    up and return NULL back to the caller. So, there is some special
    handling for those errors to ensure that the layers driving the retries
    can handle that appropriately.
    
    Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index e70ed54dad94..ccb2928a0e64 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -233,7 +233,6 @@ struct nfs4_layoutget_args {
 	struct inode *inode;
 	struct nfs_open_context *ctx;
 	nfs4_stateid stateid;
-	unsigned long timestamp;
 	struct nfs4_layoutdriver_data layout;
 };
 
@@ -251,7 +250,6 @@ struct nfs4_layoutget {
 	struct nfs4_layoutget_res res;
 	struct rpc_cred *cred;
 	gfp_t gfp_flags;
-	long timeout;
 };
 
 struct nfs4_getdeviceinfo_args {

commit 2e72448b07dc3ff1b7593e9bfff91db182262857
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 21 16:53:03 2013 -0400

    NFS: Add COPY nfs operation
    
    This adds the copy_range file_ops function pointer used by the
    sys_copy_range() function call.  This patch only implements sync copies,
    so if an async copy happens we decode the stateid and ignore it.
    
    Signed-off-by: Anna Schumaker <bjschuma@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index cb9982d8f38f..e70ed54dad94 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1343,6 +1343,32 @@ struct nfs42_falloc_res {
 	const struct nfs_server		*falloc_server;
 };
 
+struct nfs42_copy_args {
+	struct nfs4_sequence_args	seq_args;
+
+	struct nfs_fh			*src_fh;
+	nfs4_stateid			src_stateid;
+	u64				src_pos;
+
+	struct nfs_fh			*dst_fh;
+	nfs4_stateid			dst_stateid;
+	u64				dst_pos;
+
+	u64				count;
+};
+
+struct nfs42_write_res {
+	u64			count;
+	struct nfs_writeverf	verifier;
+};
+
+struct nfs42_copy_res {
+	struct nfs4_sequence_res	seq_res;
+	struct nfs42_write_res		write_res;
+	bool				consecutive;
+	bool				synchronous;
+};
+
 struct nfs42_seek_args {
 	struct nfs4_sequence_args	seq_args;
 

commit 884be175351e73c515303118150f195dd611787c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Apr 28 23:56:31 2016 -0400

    nfs: per-name sillyunlink exclusion
    
    use d_alloc_parallel() for sillyunlink/lookup exclusion and
    explicit rwsem (nfs_rmdir() being a writer and nfs_call_unlink() -
    a reader) for rmdir/sillyunlink one.
    
    That ought to make lookup/readdir/!O_CREAT atomic_open really
    parallel on NFS.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index d320906cf13e..ee8491dadbf3 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1468,10 +1468,10 @@ struct nfs_pgio_completion_ops {
 };
 
 struct nfs_unlinkdata {
-	struct hlist_node list;
 	struct nfs_removeargs args;
 	struct nfs_removeres res;
-	struct inode *dir;
+	struct dentry *dentry;
+	wait_queue_head_t wq;
 	struct rpc_cred	*cred;
 	struct nfs_fattr dir_attr;
 	long timeout;

commit fe238e601d2519f259103ab65caea3b077ed7b39
Author: Dave Wysochanski <dwysocha@redhat.com>
Date:   Fri Apr 1 13:45:09 2016 -0400

    NFS: Save struct inode * inside nfs_commit_info to clarify usage of i_lock
    
    Commit ea2cf22 created nfs_commit_info and saved &inode->i_lock inside
    this NFS specific structure.  This obscures the usage of i_lock.
    Instead, save struct inode * so later it's clear the spinlock taken is
    i_lock.
    
    Should be no functional change.
    
    Signed-off-by: Dave Wysochanski <dwysocha@redhat.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index d320906cf13e..cb9982d8f38f 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1431,7 +1431,7 @@ struct nfs_commit_completion_ops {
 };
 
 struct nfs_commit_info {
-	spinlock_t			*lock;	/* inode->i_lock */
+	struct inode 			*inode;	/* Needed for inode->i_lock */
 	struct nfs_mds_commit_info	*mds;
 	struct pnfs_ds_commit_info	*ds;
 	struct nfs_direct_req		*dreq;	/* O_DIRECT request */

commit c89757061a4e4017a21ef632dc100449a7bab7dd
Author: Kinglong Mee <kinglongmee@gmail.com>
Date:   Mon Feb 1 09:39:29 2016 +0800

    pnfs/blocklayout: fix a memeory leak when using,vmalloc_to_page
    
    unreferenced object 0xffffc90000abf000 (size 16900):
      comm "fsync02", pid 15765, jiffies 4297431627 (age 423.772s)
      hex dump (first 32 bytes):
        00 00 00 00 00 00 00 00 00 a0 c2 19 00 88 ff ff  ................
        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
      backtrace:
        [<ffffffff8174d54e>] kmemleak_alloc+0x4e/0xb0
        [<ffffffff811b9b91>] __vmalloc_node_range+0x231/0x280
        [<ffffffff811b9c2a>] __vmalloc+0x4a/0x50
        [<ffffffffa02c9ec1>] ext_tree_prepare_commit+0x231/0x2e0 [blocklayoutdriver]
        [<ffffffffa02c700e>] bl_prepare_layoutcommit+0xe/0x10 [blocklayoutdriver]
        [<ffffffffa0596a6c>] pnfs_layoutcommit_inode+0x29c/0x330 [nfsv4]
        [<ffffffffa0596b13>] pnfs_generic_sync+0x13/0x20 [nfsv4]
        [<ffffffffa0585188>] nfs4_file_fsync+0x58/0x150 [nfsv4]
        [<ffffffff81228e5b>] vfs_fsync_range+0x4b/0xb0
        [<ffffffff81228f1d>] do_fsync+0x3d/0x70
        [<ffffffff812291d0>] SyS_fsync+0x10/0x20
        [<ffffffff81757def>] entry_SYSCALL_64_fastpath+0x12/0x76
        [<ffffffffffffffff>] 0xffffffffffffffff
    
    v2, add missing include header
    
    Signed-off-by: Kinglong Mee <kinglongmee@gmail.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 791098a08a87..d320906cf13e 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -275,6 +275,7 @@ struct nfs4_layoutcommit_args {
 	size_t layoutupdate_len;
 	struct page *layoutupdate_page;
 	struct page **layoutupdate_pages;
+	__be32 *start_p;
 };
 
 struct nfs4_layoutcommit_res {

commit 942e3d72a62dcfe5bf1569b179174718bbbcfbc3
Merge: 58baac0ac7cc 506c0d68269e
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Mon Jan 4 13:19:55 2016 -0500

    Merge branch 'pnfs_generic'
    
    * pnfs_generic:
      NFSv4.1/pNFS: Cleanup constify struct pnfs_layout_range arguments
      NFSv4.1/pnfs: Cleanup copying of pnfs_layout_range structures
      NFSv4.1/pNFS: Cleanup pnfs_mark_matching_lsegs_invalid()
      NFSv4.1/pNFS: Fix a race in initiate_file_draining()
      NFSv4.1/pNFS: pnfs_error_mark_layout_for_return() must always return layout
      NFSv4.1/pNFS: pnfs_mark_matching_lsegs_return() should set the iomode
      NFSv4.1/pNFS: Use nfs4_stateid_copy for copying stateids
      NFSv4.1/pNFS: Don't pass stateids by value to pnfs_send_layoutreturn()
      NFS: Relax requirements in nfs_flush_incompatible
      NFSv4.1/pNFS: Don't queue up a new commit if the layout segment is invalid
      NFS: Allow multiple commit requests in flight per file
      NFS/pNFS: Fix up pNFS write reschedule layering violations and bugs
      NFSv4: List stateid information in the callback tracepoints
      NFSv4.1/pNFS: Don't return NFS4ERR_DELAY unnecessarily in CB_LAYOUTRECALL
      NFSv4.1/pNFS: Ensure we enforce RFC5661 Section 12.5.5.2.1
      pNFS: If we have to delay the layout callback, mark the layout for return
      NFSv4.1/pNFS: Add a helper to mark the layout as returned
      pNFS: Ensure nfs4_layoutget_prepare returns the correct error

commit b20135d0b2431900a3a5395970ffb7e4f3767c8b
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Thu Dec 31 09:28:06 2015 -0500

    NFSv4.1/pNFS: Don't queue up a new commit if the layout segment is invalid
    
    If the layout segment is invalid, then we should not be adding more
    write requests to the commit list. Instead, those writes should be
    replayed after requesting a new layout.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index a8905b7d4d7f..bee3e60a7006 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1420,10 +1420,12 @@ struct nfs_mds_commit_info {
 	struct list_head	list;
 };
 
+struct nfs_commit_info;
 struct nfs_commit_data;
 struct nfs_inode;
 struct nfs_commit_completion_ops {
 	void (*completion) (struct nfs_commit_data *data);
+	void (*resched_write) (struct nfs_commit_info *, struct nfs_page *);
 };
 
 struct nfs_commit_info {

commit af7cf057933f01dc7f33ddfb5e436ad598ed17ad
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Tue Sep 29 20:34:05 2015 -0400

    NFS: Allow multiple commit requests in flight per file
    
    Allow synchronous RPC calls to wait for pending RPC calls to finish,
    but also allow asynchronous ones to just fire off another commit.
    
    With this patch, the xfstests generic/074 test completes in 226s
    instead of 242s
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index e89dbb14138c..a8905b7d4d7f 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1423,7 +1423,6 @@ struct nfs_mds_commit_info {
 struct nfs_commit_data;
 struct nfs_inode;
 struct nfs_commit_completion_ops {
-	void (*error_cleanup) (struct nfs_inode *nfsi);
 	void (*completion) (struct nfs_commit_data *data);
 };
 

commit dc602dd706cb64036132a7903ead1c67d9a7bcb9
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Thu Dec 31 11:44:06 2015 -0500

    NFS/pNFS: Fix up pNFS write reschedule layering violations and bugs
    
    The flexfiles layout in particular, seems to want to poke around in the
    O_DIRECT flags when retransmitting.
    This patch sets up an interface to allow it to call back into O_DIRECT
    to handle retransmission correctly. It also fixes a potential bug whereby
    we could change the behaviour of O_DIRECT if an error is already pending.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 11bbae44f4cb..e89dbb14138c 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1460,6 +1460,7 @@ struct nfs_pgio_completion_ops {
 	void	(*error_cleanup)(struct list_head *head);
 	void	(*init_hdr)(struct nfs_pgio_header *hdr);
 	void	(*completion)(struct nfs_pgio_header *hdr);
+	void	(*reschedule_io)(struct nfs_pgio_header *hdr);
 };
 
 struct nfs_unlinkdata {

commit 37e9ed22b1552fa94ee7db2901a5e7d8bdf60b15
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Tue Dec 22 12:30:24 2015 -0500

    pNFS: Add flag to track if we've called nfs4_ff_layout_stat_io_start_read/write
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 11bbae44f4cb..7b30ac0c7def 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1375,6 +1375,7 @@ enum {
 	NFS_IOHDR_ERROR = 0,
 	NFS_IOHDR_EOF,
 	NFS_IOHDR_REDO,
+	NFS_IOHDR_STAT,
 };
 
 struct nfs_pgio_header {
@@ -1454,6 +1455,7 @@ struct nfs_commit_data {
 	const struct rpc_call_ops *mds_ops;
 	const struct nfs_commit_completion_ops *completion_ops;
 	int (*commit_done_cb) (struct rpc_task *task, struct nfs_commit_data *data);
+	unsigned long		flags;
 };
 
 struct nfs_pgio_completion_ops {

commit 91ab4b4d16e6649fbbf65f303c0c4e20ed680bd1
Author: Jeff Layton <jlayton@poochiereds.net>
Date:   Thu Nov 19 14:30:26 2015 -0500

    nfs: use sliding delay when LAYOUTGET gets NFS4ERR_DELAY
    
    When LAYOUTGET gets NFS4ERR_DELAY, we currently will wait 15s before
    retrying the call. That is a _very_ long time, so add a timeout value to
    struct nfs4_layoutget and pass nfs4_async_handle_error a pointer to it.
    This allows the RPC engine to use a sliding delay window, instead of a
    15s delay.
    
    Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 570d630f98ae..11bbae44f4cb 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -251,6 +251,7 @@ struct nfs4_layoutget {
 	struct nfs4_layoutget_res res;
 	struct rpc_cred *cred;
 	gfp_t gfp_flags;
+	long timeout;
 };
 
 struct nfs4_getdeviceinfo_args {

commit 8fbcf237439f841e7e9c4675790e08ea1c295bd3
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Tue Nov 3 18:25:34 2015 +0100

    nfs: Remove unused xdr page offsets in getacl/setacl arguments
    
    The arguments passed around for getacl and setacl xdr encoding, struct
    nfs_setaclargs and struct nfs_getaclargs, both contain an array of
    pages, an offset into the first page, and the length of the page data.
    The offset is unused as it is always zero; remove it.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 4728e7e5fc49..570d630f98ae 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -705,7 +705,6 @@ struct nfs_setaclargs {
 	struct nfs4_sequence_args	seq_args;
 	struct nfs_fh *			fh;
 	size_t				acl_len;
-	unsigned int			acl_pgbase;
 	struct page **			acl_pages;
 };
 
@@ -717,7 +716,6 @@ struct nfs_getaclargs {
 	struct nfs4_sequence_args 	seq_args;
 	struct nfs_fh *			fh;
 	size_t				acl_len;
-	unsigned int			acl_pgbase;
 	struct page **			acl_pages;
 };
 

commit 51e0164ebe374a26245312515af4ceae11bed4ae
Merge: 120bf961b90a b9788a446828
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Wed Oct 21 15:42:20 2015 -0500

    Merge branch 'nfsclone'
    
    * nfsclone:
      nfs: add missing linux/types.h
      NFS: Fix an 'unused variable' complaint when #ifndef CONFIG_NFS_V4_2
      nfs42: add NFS_IOC_CLONE_RANGE ioctl
      nfs42: respect clone_blksize
      nfs: get clone_blksize when probing fsinfo
      nfs42: add NFS_IOC_CLONE ioctl
      nfs42: add CLONE proc functions
      nfs42: add CLONE xdr functions

commit 2a92ee92d4545448066fb664674c0ae5a9d5ea99
Author: Peng Tao <tao.peng@primarydata.com>
Date:   Sat Sep 26 02:24:37 2015 +0800

    nfs: get clone_blksize when probing fsinfo
    
    NFSv42 CLONE operation is supposed to respect it.
    
    Signed-off-by: Peng Tao <tao.peng@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index ac678b7a65ed..92ff445e60a0 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -141,6 +141,7 @@ struct nfs_fsinfo {
 	__u32			lease_time; /* in seconds */
 	__u32			layouttype; /* supported pnfs layout driver */
 	__u32			blksize; /* preferred pnfs io block size */
+	__u32			clone_blksize; /* granularity of a CLONE operation */
 };
 
 struct nfs_fsstat {

commit 36022770de6cf9a403c40a68712ed2d2ea2746be
Author: Peng Tao <tao.peng@primarydata.com>
Date:   Sat Sep 26 02:24:34 2015 +0800

    nfs42: add CLONE xdr functions
    
    xdr definitions per draft-ietf-nfsv4-minorversion2-38.txt
    
    Signed-off-by: Peng Tao <tao.peng@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 52faf7e96c65..ac678b7a65ed 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -359,6 +359,25 @@ struct nfs42_layoutstat_data {
 	struct nfs42_layoutstat_res res;
 };
 
+struct nfs42_clone_args {
+	struct nfs4_sequence_args	seq_args;
+	struct nfs_fh			*src_fh;
+	struct nfs_fh			*dst_fh;
+	nfs4_stateid			src_stateid;
+	nfs4_stateid			dst_stateid;
+	__u64				src_offset;
+	__u64				dst_offset;
+	__u64				count;
+	const u32			*dst_bitmask;
+};
+
+struct nfs42_clone_res {
+	struct nfs4_sequence_res	seq_res;
+	unsigned int			rpc_status;
+	struct nfs_fattr		*dst_fattr;
+	const struct nfs_server		*server;
+};
+
 struct stateowner_id {
 	__u64	create_time;
 	__u32	uniquifier;

commit 516285ebe0efadc40b914a0e61a913a390604810
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Sun Sep 20 16:15:24 2015 -0400

    NFSv4: nfs4_async_handle_error should take a non-const nfs_server
    
    For symmetry with the synchronous handler, and so that we can potentially
    handle errors such as NFS4ERR_BADNAME.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 52faf7e96c65..53f2acc68baf 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -528,7 +528,7 @@ struct nfs4_delegreturnargs {
 struct nfs4_delegreturnres {
 	struct nfs4_sequence_res	seq_res;
 	struct nfs_fattr * fattr;
-	const struct nfs_server *server;
+	struct nfs_server *server;
 };
 
 /*
@@ -601,7 +601,7 @@ struct nfs_removeargs {
 
 struct nfs_removeres {
 	struct nfs4_sequence_res 	seq_res;
-	const struct nfs_server *server;
+	struct nfs_server *server;
 	struct nfs_fattr	*dir_attr;
 	struct nfs4_change_info	cinfo;
 };
@@ -619,7 +619,7 @@ struct nfs_renameargs {
 
 struct nfs_renameres {
 	struct nfs4_sequence_res	seq_res;
-	const struct nfs_server		*server;
+	struct nfs_server		*server;
 	struct nfs4_change_info		old_cinfo;
 	struct nfs_fattr		*old_fattr;
 	struct nfs4_change_info		new_cinfo;

commit 7d160a6c462c2c690e074c173b43aad7204049ad
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Sat Sep 5 19:06:57 2015 -0400

    NFSv4: Express delegation limit in units of pages
    
    Since we're tracking modifications to the page cache on a per-page
    basis, it makes sense to express the limit to how much we may cache
    in units of pages.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index b4392d86d157..52faf7e96c65 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -406,8 +406,8 @@ struct nfs_openres {
 	const struct nfs_server *server;
 	fmode_t			delegation_type;
 	nfs4_stateid		delegation;
+	unsigned long		pagemod_limit;
 	__u32			do_recall;
-	__u64			maxsize;
 	__u32			attrset[NFS4_BITMAP_SIZE];
 	struct nfs4_string	*owner;
 	struct nfs4_string	*group_owner;

commit 5334c5bdac926c5f8d89729beccb46fe88eda9e7
Author: Kinglong Mee <kinglongmee@gmail.com>
Date:   Wed Aug 26 21:13:37 2015 +0800

    NFS: Send attributes in OPEN request for NFS4_CREATE_EXCLUSIVE4_1
    
    Client sends a SETATTR request after OPEN for updating attributes.
    For create file with S_ISGID is set, the S_ISGID in SETATTR will be
    ignored at nfs server as chmod of no PERMISSION.
    
    v3, same as v2.
    
    Signed-off-by: Kinglong Mee <kinglongmee@gmail.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 0d7c832ec415..b4392d86d157 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -379,7 +379,7 @@ struct nfs_openargs {
 	struct stateowner_id	id;
 	union {
 		struct {
-			struct iattr *  attrs;    /* UNCHECKED, GUARDED */
+			struct iattr *  attrs;    /* UNCHECKED, GUARDED, EXCLUSIVE4_1 */
 			nfs4_verifier   verifier; /* EXCLUSIVE */
 		};
 		nfs4_stateid	delegation;		/* CLAIM_DELEGATE_CUR */

commit 8c61282ff61c28d5a12bb53f0eaa221d30fd3ae1
Author: Kinglong Mee <kinglongmee@gmail.com>
Date:   Wed Aug 26 21:12:58 2015 +0800

    NFS: Get suppattr_exclcreat when getting server capabilities
    
    Create file with attributs as NFS4_CREATE_EXCLUSIVE4_1 mode
    depends on suppattr_exclcreat attribut.
    
    v3, same as v2.
    
    Signed-off-by: Kinglong Mee <kinglongmee@gmail.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index b9b530409ff7..0d7c832ec415 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1057,11 +1057,13 @@ struct nfs4_statfs_res {
 struct nfs4_server_caps_arg {
 	struct nfs4_sequence_args	seq_args;
 	struct nfs_fh		       *fhandle;
+	const u32 *			bitmask;
 };
 
 struct nfs4_server_caps_res {
 	struct nfs4_sequence_res	seq_res;
 	u32				attr_bitmask[3];
+	u32				exclcreat_bitmask[3];
 	u32				acl_bitmask;
 	u32				has_links;
 	u32				has_symlinks;

commit 2a606188c55990fa65cba3fd9b64f2b7542b7692
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Wed Aug 19 22:30:00 2015 -0500

    NFSv4: Enable delegated opens even when reboot recovery is pending
    
    Unlike the previous attempt, this takes into account the fact that
    we may be calling it from the recovery thread itself. Detect this
    by looking at what kind of open we're doing, and checking the state
    of the NFS_DELEGATION_NEED_RECLAIM if it turns out we're doing a
    reboot reclaim-type open.
    
    Cc: Olga Kornievskaia <aglo@umich.edu>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 7bbe50504211..b9b530409ff7 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -389,7 +389,7 @@ struct nfs_openargs {
 	const struct nfs_server *server;	 /* Needed for ID mapping */
 	const u32 *		bitmask;
 	const u32 *		open_bitmap;
-	__u32			claim;
+	enum open_claim_type4	claim;
 	enum createmode4	createmode;
 	const struct nfs4_label *label;
 };

commit be3a5d233922d73f27002ce2767f6ec03c3f473d
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Tue Jun 23 19:51:55 2015 +0800

    NFSv.2/pnfs Add a LAYOUTSTATS rpc function
    
    Reviewed-by: Jeff Layton <jeff.layton@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Signed-off-by: Peng Tao <tao.peng@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index c959e7eb5bd4..7bbe50504211 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -316,6 +316,49 @@ struct nfs4_layoutreturn {
 	int rpc_status;
 };
 
+#define PNFS_LAYOUTSTATS_MAXSIZE 256
+
+struct nfs42_layoutstat_args;
+struct nfs42_layoutstat_devinfo;
+typedef	void (*layoutstats_encode_t)(struct xdr_stream *,
+		struct nfs42_layoutstat_args *,
+		struct nfs42_layoutstat_devinfo *);
+
+/* Per file per deviceid layoutstats */
+struct nfs42_layoutstat_devinfo {
+	struct nfs4_deviceid dev_id;
+	__u64 offset;
+	__u64 length;
+	__u64 read_count;
+	__u64 read_bytes;
+	__u64 write_count;
+	__u64 write_bytes;
+	__u32 layout_type;
+	layoutstats_encode_t layoutstats_encode;
+	void *layout_private;
+};
+
+struct nfs42_layoutstat_args {
+	struct nfs4_sequence_args seq_args;
+	struct nfs_fh *fh;
+	struct inode *inode;
+	nfs4_stateid stateid;
+	int num_dev;
+	struct nfs42_layoutstat_devinfo *devinfo;
+};
+
+struct nfs42_layoutstat_res {
+	struct nfs4_sequence_res seq_res;
+	int num_dev;
+	int rpc_status;
+};
+
+struct nfs42_layoutstat_data {
+	struct inode *inode;
+	struct nfs42_layoutstat_args args;
+	struct nfs42_layoutstat_res res;
+};
+
 struct stateowner_id {
 	__u64	create_time;
 	__u32	uniquifier;

commit 873e385116b2cc5c7daca8f51881371fadb90970
Author: Jeff Layton <jlayton@poochiereds.net>
Date:   Tue Jun 9 19:44:00 2015 -0400

    nfs: make nfs4_init_uniform_client_string use a dynamically allocated buffer
    
    Change the uniform client string generator to dynamically allocate the
    NFSv4 client name string buffer. With this patch, we can eliminate the
    buffers that are embedded within the "args" structs and simply use the
    name string that is hanging off the client.
    
    This uniform string case is a little simpler than the nonuniform since
    we don't need to deal with RCU, but we do have two different cases,
    depending on whether there is a uniquifier or not.
    
    Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 6c0b423d781b..c959e7eb5bd4 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -984,11 +984,8 @@ struct nfs4_readlink_res {
 	struct nfs4_sequence_res	seq_res;
 };
 
-#define NFS4_SETCLIENTID_NAMELEN	(127)
 struct nfs4_setclientid {
 	const nfs4_verifier *		sc_verifier;
-	unsigned int			sc_name_len;
-	char				sc_name[NFS4_SETCLIENTID_NAMELEN + 1];
 	u32				sc_prog;
 	unsigned int			sc_netid_len;
 	char				sc_netid[RPCBIND_MAXNETIDLEN + 1];
@@ -1142,12 +1139,9 @@ struct nfs41_state_protection {
 	struct nfs4_op_map allow;
 };
 
-#define NFS4_EXCHANGE_ID_LEN	(127)
 struct nfs41_exchange_id_args {
 	struct nfs_client		*client;
 	nfs4_verifier			*verifier;
-	unsigned int 			id_len;
-	char 				id[NFS4_EXCHANGE_ID_LEN];
 	u32				flags;
 	struct nfs41_state_protection	state_protect;
 };

commit 3a6bb738792500e8b4534c0350c13a132bac0492
Author: Jeff Layton <jlayton@poochiereds.net>
Date:   Tue Jun 9 19:43:57 2015 -0400

    nfs: convert setclientid and exchange_id encoders to use clp->cl_owner_id
    
    ...instead of buffers that are part of their arg structs. We already
    hold a reference to the client, so we might as well use the allocated
    buffer. In the event that we can't allocate the clp->cl_owner_id, then
    just return -ENOMEM.
    
    Note too that we switch from a GFP_KERNEL allocation here to GFP_NOFS.
    It's possible we could end up trying to do a SETCLIENTID or EXCHANGE_ID
    in order to reclaim some memory, and the GFP_KERNEL allocations in the
    existing code could cause recursion back into NFS reclaim.
    
    Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index e9e9a8dcfb47..6c0b423d781b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -994,7 +994,7 @@ struct nfs4_setclientid {
 	char				sc_netid[RPCBIND_MAXNETIDLEN + 1];
 	unsigned int			sc_uaddr_len;
 	char				sc_uaddr[RPCBIND_MAXUADDRLEN + 1];
-	u32				sc_cb_ident;
+	struct nfs_client		*sc_clnt;
 	struct rpc_cred			*sc_cred;
 };
 

commit 764ad8ba8cd4c6f836fca9378f8c5121aece0842
Author: Jeff Layton <jlayton@poochiereds.net>
Date:   Tue Jun 9 19:43:56 2015 -0400

    nfs: increase size of EXCHANGE_ID name string buffer
    
    The current buffer is much too small if you have a relatively long
    hostname. Bring it up to the size of the one that SETCLIENTID has.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Michael Skralivetsky <michael.skralivetsky@primarydata.com>
    Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 93ab6071bbe9..e9e9a8dcfb47 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1142,7 +1142,7 @@ struct nfs41_state_protection {
 	struct nfs4_op_map allow;
 };
 
-#define NFS4_EXCHANGE_ID_LEN	(48)
+#define NFS4_EXCHANGE_ID_LEN	(127)
 struct nfs41_exchange_id_args {
 	struct nfs_client		*client;
 	nfs4_verifier			*verifier;

commit 9a51940bf65bf9fdc93027d70bdecdfc403c5b24
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Mon Mar 16 14:06:23 2015 -0400

    NFS: Don't zap caches on fallocate()
    
    This patch adds a GETATTR to the end of ALLOCATE and DEALLOCATE
    operations so we can set the updated inode size and change attribute
    directly.  DEALLOCATE will still need to release pagecache pages, so
    nfs42_proc_deallocate() now calls truncate_pagecache_range() before
    contacting the server.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 3d88908fd140..93ab6071bbe9 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1273,11 +1273,15 @@ struct nfs42_falloc_args {
 	nfs4_stateid			 falloc_stateid;
 	u64				 falloc_offset;
 	u64				 falloc_length;
+	const u32			*falloc_bitmask;
 };
 
 struct nfs42_falloc_res {
 	struct nfs4_sequence_res	seq_res;
 	unsigned int			status;
+
+	struct nfs_fattr		*falloc_fattr;
+	const struct nfs_server		*falloc_server;
 };
 
 struct nfs42_seek_args {

commit 4e59080397faadee59d39ffa2116dc8607adc9c9
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Mon Mar 9 14:01:25 2015 -0400

    NFSv4.1: Allow getdeviceinfo to return notification info back to caller
    
    We are only allowed to cache deviceinfo if the server supports notifications
    and actually promises to call us back when changes occur. Right now, we
    request those notifications, but then we don't check the server's reply.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 4cb3eaa89cf7..3d88908fd140 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -255,11 +255,13 @@ struct nfs4_layoutget {
 struct nfs4_getdeviceinfo_args {
 	struct nfs4_sequence_args seq_args;
 	struct pnfs_device *pdev;
+	__u32 notify_types;
 };
 
 struct nfs4_getdeviceinfo_res {
 	struct nfs4_sequence_res seq_res;
 	struct pnfs_device *pdev;
+	__u32 notification;
 };
 
 struct nfs4_layoutcommit_args {

commit 71a097c6de9a49afd0f96b3ecef70c4eb04efde7
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Wed Feb 18 09:27:18 2015 -0800

    NFSv4.1: Clean up bind_conn_to_session
    
    We don't need to fake up an entire session in order retrieve the arguments.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 1af12fc16e98..4cb3eaa89cf7 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1167,8 +1167,15 @@ struct nfs41_impl_id {
 	struct nfstime4			date;
 };
 
+struct nfs41_bind_conn_to_session_args {
+	struct nfs_client		*client;
+	struct nfs4_sessionid		sessionid;
+	u32				dir;
+	bool				use_conn_in_rdma_mode;
+};
+
 struct nfs41_bind_conn_to_session_res {
-	struct nfs4_session		*session;
+	struct nfs4_sessionid		sessionid;
 	u32				dir;
 	bool				use_conn_in_rdma_mode;
 };

commit 79969dd12e8756f64a999992c0536ccd91bf6e54
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Wed Feb 18 11:30:18 2015 -0800

    NFSv4.1: Clean up create_session
    
    Don't decode directly into the shared struct session
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 9a39132fda49..1af12fc16e98 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1185,6 +1185,8 @@ struct nfs41_exchange_id_res {
 
 struct nfs41_create_session_args {
 	struct nfs_client	       *client;
+	u64				clientid;
+	uint32_t			seqid;
 	uint32_t			flags;
 	uint32_t			cb_program;
 	struct nfs4_channel_attrs	fc_attrs;	/* Fore Channel */
@@ -1192,7 +1194,11 @@ struct nfs41_create_session_args {
 };
 
 struct nfs41_create_session_res {
-	struct nfs_client	       *client;
+	struct nfs4_sessionid		sessionid;
+	uint32_t			seqid;
+	uint32_t			flags;
+	struct nfs4_channel_attrs	fc_attrs;	/* Fore Channel */
+	struct nfs4_channel_attrs	bc_attrs;	/* Back Channel */
 };
 
 struct nfs41_reclaim_complete_args {

commit f4086a3d789dbe18949862276d83b8f49fce6d2f
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Fri Feb 13 21:03:16 2015 -0500

    NFS: struct nfs_commit_info.lock must always point to inode->i_lock
    
    Commit 411a99adffb4f (nfs: clear_request_commit while holding i_lock)
    assumes that the nfs_commit_info always points to the inode->i_lock.
    For historical reasons, that is not the case for O_DIRECT writes.
    
    Cc: Weston Andros Adamson <dros@primarydata.com>
    Fixes: 411a99adffb4f ("nfs: clear_request_commit while holding i_lock")
    Cc: stable@vger.kernel.org # 3.17.x
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 38d96ba935c2..9a39132fda49 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1351,7 +1351,7 @@ struct nfs_commit_completion_ops {
 };
 
 struct nfs_commit_info {
-	spinlock_t			*lock;
+	spinlock_t			*lock;	/* inode->i_lock */
 	struct nfs_mds_commit_info	*mds;
 	struct pnfs_ds_commit_info	*ds;
 	struct nfs_direct_req		*dreq;	/* O_DIRECT request */

commit 5a0ec8acb945e302ce819b4a9787796ccf284548
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Thu Feb 5 16:35:16 2015 -0500

    NFSv4.1: Pin the inode and super block in asynchronous layoutreturns
    
    If we're sending an asynchronous layoutreturn, then we need to ensure
    that the inode and the super block remain pinned.
    
    Cc: Peng Tao <tao.peng@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Reviewed-by: Peng Tao <tao.peng@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index bb0d56f737e0..38d96ba935c2 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -310,6 +310,7 @@ struct nfs4_layoutreturn {
 	struct nfs4_layoutreturn_res res;
 	struct rpc_cred *cred;
 	struct nfs_client *clp;
+	struct inode *inode;
 	int rpc_status;
 };
 

commit 472e259449819d939b5a5188b6f4c7d59aa4304c
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Thu Feb 5 16:50:30 2015 -0500

    NFSv4.1: Pin the inode and super block in asynchronous layoutcommit
    
    If we're sending an asynchronous layoutcommit, then we need to ensure
    that the inode and the super block remain pinned.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Reviewed-by: Peng Tao <tao.peng@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 2c35e2affa6f..bb0d56f737e0 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -285,6 +285,7 @@ struct nfs4_layoutcommit_data {
 	struct nfs_fattr fattr;
 	struct list_head lseg_list;
 	struct rpc_cred *cred;
+	struct inode *inode;
 	struct nfs4_layoutcommit_args args;
 	struct nfs4_layoutcommit_res res;
 };

commit 6ae373394c4257bad562817aa60464ff7fe8f9c4
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Fri Jan 30 14:21:14 2015 -0500

    NFSv4.1: Ask for no delegation on OPEN if using O_DIRECT
    
    If we're using NFSv4.1, then we have the ability to let the server know
    whether or not we believe that returning a delegation as part of our OPEN
    request would be useful.
    The feature needs to be used with care, since the client sending the request
    doesn't necessarily know how other clients are using that file, and how
    they may be affected by the delegation.
    For this reason, our initial use of the feature will be to let the server
    know when the client believes that handing out a delegation would not be
    useful.
    The first application for this function is when opening the file using
    O_DIRECT.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 81401125ab2d..2c35e2affa6f 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -326,6 +326,7 @@ struct nfs_openargs {
 	struct nfs_seqid *	seqid;
 	int			open_flags;
 	fmode_t			fmode;
+	u32			share_access;
 	u32			access;
 	__u64                   clientid;
 	struct stateowner_id	id;
@@ -393,6 +394,7 @@ struct nfs_closeargs {
 	nfs4_stateid 		stateid;
 	struct nfs_seqid *	seqid;
 	fmode_t			fmode;
+	u32			share_access;
 	const u32 *		bitmask;
 };
 

commit e2c63e091e29786a34ecf42c169e627a3d1d96d7
Merge: cc3ea893cbb3 7c13789e3e6c
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Tue Feb 3 16:01:27 2015 -0500

    Merge branch 'flexfiles'
    
    * flexfiles: (53 commits)
      pnfs: lookup new lseg at lseg boundary
      nfs41: .init_read and .init_write can be called with valid pg_lseg
      pnfs: Update documentation on the Layout Drivers
      pnfs/flexfiles: Add the FlexFile Layout Driver
      nfs: count DIO good bytes correctly with mirroring
      nfs41: wait for LAYOUTRETURN before retrying LAYOUTGET
      nfs: add a helper to set NFS_ODIRECT_RESCHED_WRITES to direct writes
      nfs41: add NFS_LAYOUT_RETRY_LAYOUTGET to layout header flags
      nfs/flexfiles: send layoutreturn before freeing lseg
      nfs41: introduce NFS_LAYOUT_RETURN_BEFORE_CLOSE
      nfs41: allow async version layoutreturn
      nfs41: add range to layoutreturn args
      pnfs: allow LD to ask to resend read through pnfs
      nfs: add nfs_pgio_current_mirror helper
      nfs: only reset desc->pg_mirror_idx when mirroring is supported
      nfs41: add a debug warning if we destroy an unempty layout
      pnfs: fail comparison when bucket verifier not set
      nfs: mirroring support for direct io
      nfs: add mirroring support to pgio layer
      pnfs: pass ds_commit_idx through the commit path
      ...
    
    Conflicts:
            fs/nfs/pnfs.c
            fs/nfs/pnfs.h

commit 15eb67c15342d212b0c8a540b6d6bd2dfad52a63
Author: Peng Tao <tao.peng@primarydata.com>
Date:   Mon Nov 17 09:30:36 2014 +0800

    nfs41: add range to layoutreturn args
    
    So that callers can specify which range to return.
    
    Signed-off-by: Peng Tao <tao.peng@primarydata.com>
    Signed-off-by: Tom Haynes <loghyr@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 6400a1e01aa4..363792356d25 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -293,7 +293,7 @@ struct nfs4_layoutreturn_args {
 	struct nfs4_sequence_args seq_args;
 	struct pnfs_layout_hdr *layout;
 	struct inode *inode;
-	enum pnfs_iomode iomode;
+	struct pnfs_layout_range range;
 	nfs4_stateid stateid;
 	__u32   layout_type;
 };

commit a7d42ddb3099727f58366fa006f850a219cce6c8
Author: Weston Andros Adamson <dros@primarydata.com>
Date:   Fri Sep 19 10:55:07 2014 -0400

    nfs: add mirroring support to pgio layer
    
    This patch adds mirrored write support to the pgio layer. The default
    is to use one mirror, but pgio callers may define callbacks to change
    this to any value up to the (arbitrarily selected) limit of 16.
    
    The basic idea is to break out members of nfs_pageio_descriptor that cannot
    be shared between mirrored DSes and put them in a new structure.
    
    Signed-off-by: Weston Andros Adamson <dros@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 5bc99f04a550..6400a1e01aa4 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1329,6 +1329,7 @@ struct nfs_pgio_header {
 	struct nfs_page_array	page_array;
 	struct nfs_client	*ds_clp;	/* pNFS data server */
 	int			ds_commit_idx;	/* ds index if ds_clp is set */
+	int			pgio_mirror_idx;/* mirror index in pgio layer */
 };
 
 struct nfs_mds_commit_info {

commit 6cccbb6f52dceec5f4faed8846ac05ae830640e6
Author: Weston Andros Adamson <dros@primarydata.com>
Date:   Tue Sep 16 17:35:51 2014 -0400

    nfs: rename pgio header ds_idx to ds_commit_idx
    
    'ds_commit_idx' is a better name - it is used to select the right
    commit bucket for pnfs.
    
    Signed-off-by: Weston Andros Adamson <dros@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 4fd7793d45d1..5bc99f04a550 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1328,7 +1328,7 @@ struct nfs_pgio_header {
 	__u64			mds_offset;	/* Filelayout dense stripe */
 	struct nfs_page_array	page_array;
 	struct nfs_client	*ds_clp;	/* pNFS data server */
-	int			ds_idx;		/* ds index if ds_clp is set */
+	int			ds_commit_idx;	/* ds index if ds_clp is set */
 };
 
 struct nfs_mds_commit_info {

commit 4579d6b897ee1b2557517fd536fb17eeb13481ad
Author: Peng Tao <tao.peng@primarydata.com>
Date:   Sat Sep 6 00:53:21 2014 +0800

    nfs41: pass iomode through layoutreturn args
    
    So that it is possible to return a specific iomode layouts.
    
    Signed-off-by: Peng Tao <tao.peng@primarydata.com>
    Signed-off-by: Tom Haynes <Thomas.Haynes@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 962f461c065d..4fd7793d45d1 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -293,6 +293,7 @@ struct nfs4_layoutreturn_args {
 	struct nfs4_sequence_args seq_args;
 	struct pnfs_layout_hdr *layout;
 	struct inode *inode;
+	enum pnfs_iomode iomode;
 	nfs4_stateid stateid;
 	__u32   layout_type;
 };

commit aabff4ddcac0d36dd26546f5b905c27682e7bf89
Author: Peng Tao <tao.peng@primarydata.com>
Date:   Wed Aug 27 10:47:14 2014 +0800

    nfs: save server READ/WRITE/COMMIT status
    
    Flexfiles layout would want to use them to report DS IO status.
    
    Signed-off-by: Peng Tao <tao.peng@primarydata.com>
    Signed-off-by: Tom Haynes <Thomas.Haynes@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 467c84efb596..962f461c065d 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -513,6 +513,7 @@ struct nfs_pgio_res {
 	struct nfs4_sequence_res	seq_res;
 	struct nfs_fattr *	fattr;
 	__u32			count;
+	__u32			op_status;
 	int			eof;		/* used by read */
 	struct nfs_writeverf *	verf;		/* used by write */
 	const struct nfs_server *server;	/* used by write */
@@ -532,6 +533,7 @@ struct nfs_commitargs {
 
 struct nfs_commitres {
 	struct nfs4_sequence_res	seq_res;
+	__u32			op_status;
 	struct nfs_fattr	*fattr;
 	struct nfs_writeverf	*verf;
 	const struct nfs_server *server;

commit c69899a17ca4836230720e65493942d9582a0424
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Sat Jan 24 16:03:52 2015 -0500

    NFSv4: Update of VFS byte range lock must be atomic with the stateid update
    
    Ensure that we test the lock stateid remained unchanged while we were
    updating the VFS tracking of the byte range lock. Have the process
    replay the lock to the server if we detect that was not the case.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index b6a6953c0f09..e5c3b620a609 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -422,6 +422,7 @@ struct nfs_lock_args {
 	struct nfs_lowner	lock_owner;
 	unsigned char		block : 1;
 	unsigned char		reclaim : 1;
+	unsigned char		new_lock : 1;
 	unsigned char		new_lock_owner : 1;
 };
 

commit 425c1d4e5b6d4bd700eb94ad8318bdb05431fdc7
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Sat Jan 24 14:57:53 2015 -0500

    NFSv4: Fix lock on-wire reordering issues
    
    This patch ensures that the server cannot reorder our LOCK/LOCKU
    requests if they are sent in parallel on the wire.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 7e38d641236e..b6a6953c0f09 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -416,9 +416,9 @@ struct nfs_lock_args {
 	struct nfs_fh *		fh;
 	struct file_lock *	fl;
 	struct nfs_seqid *	lock_seqid;
-	nfs4_stateid *		lock_stateid;
+	nfs4_stateid		lock_stateid;
 	struct nfs_seqid *	open_seqid;
-	nfs4_stateid *		open_stateid;
+	nfs4_stateid		open_stateid;
 	struct nfs_lowner	lock_owner;
 	unsigned char		block : 1;
 	unsigned char		reclaim : 1;
@@ -437,7 +437,7 @@ struct nfs_locku_args {
 	struct nfs_fh *		fh;
 	struct file_lock *	fl;
 	struct nfs_seqid *	seqid;
-	nfs4_stateid *		stateid;
+	nfs4_stateid 		stateid;
 };
 
 struct nfs_locku_res {

commit 566fcec60b7458784d4ed9bca974c5a56dacf214
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Fri Jan 23 15:32:46 2015 -0500

    NFSv4: Fix an atomicity problem in CLOSE
    
    If we are to remove the serialisation of OPEN/CLOSE, then we need to
    ensure that the stateid sent as part of a CLOSE operation does not
    change after we test the state in nfs4_close_prepare.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 467c84efb596..7e38d641236e 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -389,7 +389,7 @@ struct nfs_open_confirmres {
 struct nfs_closeargs {
 	struct nfs4_sequence_args	seq_args;
 	struct nfs_fh *         fh;
-	nfs4_stateid *		stateid;
+	nfs4_stateid 		stateid;
 	struct nfs_seqid *	seqid;
 	fmode_t			fmode;
 	const u32 *		bitmask;

commit f4ac1674f5da420ef17896f0f222c5215ebcde80
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue Nov 25 13:18:15 2014 -0500

    nfs: Add ALLOCATE support
    
    This patch adds support for using the NFS v4.2 operation ALLOCATE to
    preallocate data in a file.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 47ebb4fafd87..467c84efb596 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1243,6 +1243,20 @@ nfs_free_pnfs_ds_cinfo(struct pnfs_ds_commit_info *cinfo)
 #endif /* CONFIG_NFS_V4_1 */
 
 #ifdef CONFIG_NFS_V4_2
+struct nfs42_falloc_args {
+	struct nfs4_sequence_args	seq_args;
+
+	struct nfs_fh			*falloc_fh;
+	nfs4_stateid			 falloc_stateid;
+	u64				 falloc_offset;
+	u64				 falloc_length;
+};
+
+struct nfs42_falloc_res {
+	struct nfs4_sequence_res	seq_res;
+	unsigned int			status;
+};
+
 struct nfs42_seek_args {
 	struct nfs4_sequence_args	seq_args;
 

commit 8c393f9a721c30a030049a680e1bf896669bb279
Author: Peng Tao <tao.peng@primarydata.com>
Date:   Wed Nov 5 22:36:50 2014 +0800

    nfs: fix pnfs direct write memory leak
    
    For pNFS direct writes, layout driver may dynamically allocate ds_cinfo.buckets.
    So we need to take care to free them when freeing dreq.
    
    Ideally this needs to be done inside layout driver where ds_cinfo.buckets
    are allocated. But buckets are attached to dreq and reused across LD IO iterations.
    So I feel it's OK to free them in the generic layer.
    
    Cc: stable@vger.kernel.org [v3.4+]
    Signed-off-by: Peng Tao <tao.peng@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 983876f24aed..47ebb4fafd87 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1224,11 +1224,22 @@ struct nfs41_free_stateid_res {
 	unsigned int			status;
 };
 
+static inline void
+nfs_free_pnfs_ds_cinfo(struct pnfs_ds_commit_info *cinfo)
+{
+	kfree(cinfo->buckets);
+}
+
 #else
 
 struct pnfs_ds_commit_info {
 };
 
+static inline void
+nfs_free_pnfs_ds_cinfo(struct pnfs_ds_commit_info *cinfo)
+{
+}
+
 #endif /* CONFIG_NFS_V4_1 */
 
 #ifdef CONFIG_NFS_V4_2

commit b4b56796fe635484d049960ee06a6d435634ab16
Merge: 72c23f081997 1c6dcbe5ceff
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Tue Sep 30 17:22:02 2014 -0400

    Merge branch 'client-4.2' into linux-next
    
    Merge NFSv4.2 client SEEK implementation from Anna
    
    * client-4.2: (55 commits)
      NFS: Implement SEEK
      NFSD: Implement SEEK
      NFSD: Add generic v4.2 infrastructure
      svcrdma: advertise the correct max payload
      nfsd: introduce nfsd4_callback_ops
      nfsd: split nfsd4_callback initialization and use
      nfsd: introduce a generic nfsd4_cb
      nfsd: remove nfsd4_callback.cb_op
      nfsd: do not clear rpc_resp in nfsd4_cb_done_sequence
      nfsd: fix nfsd4_cb_recall_done error handling
      nfsd4: clarify how grace period ends
      nfsd4: stop grace_time update at end of grace period
      nfsd: skip subsequent UMH "create" operations after the first one for v4.0 clients
      nfsd: set and test NFSD4_CLIENT_STABLE bit to reduce nfsdcltrack upcalls
      nfsd: serialize nfsdcltrack upcalls for a particular client
      nfsd: pass extra info in env vars to upcalls to allow for early grace period end
      nfsd: add a v4_end_grace file to /proc/fs/nfsd
      lockd: add a /proc/fs/lockd/nlm_end_grace file
      nfsd: reject reclaim request when client has already sent RECLAIM_COMPLETE
      nfsd: remove redundant boot_time parm from grace_done client tracking op
      ...

commit 1c6dcbe5ceff81c2cf8d929646af675cd59fe7c0
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Fri Sep 26 13:58:48 2014 -0400

    NFS: Implement SEEK
    
    The SEEK operation is used when an application makes an lseek call with
    either the SEEK_HOLE or SEEK_DATA flags set.  I fall back on
    nfs_file_llseek() if the server does not have SEEK support.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 0040629894df..0051b1ad2b37 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1239,6 +1239,25 @@ struct pnfs_ds_commit_info {
 
 #endif /* CONFIG_NFS_V4_1 */
 
+#ifdef CONFIG_NFS_V4_2
+struct nfs42_seek_args {
+	struct nfs4_sequence_args	seq_args;
+
+	struct nfs_fh			*sa_fh;
+	nfs4_stateid			sa_stateid;
+	u64				sa_offset;
+	u32				sa_what;
+};
+
+struct nfs42_seek_res {
+	struct nfs4_sequence_res	seq_res;
+	unsigned int			status;
+
+	u32	sr_eof;
+	u64	sr_offset;
+};
+#endif
+
 struct nfs_page;
 
 #define NFS_PAGEVEC_SIZE	(8U)

commit 8478eaa16e701ecfe054b62ec764bc1291b79e19
Author: NeilBrown <neilb@suse.de>
Date:   Thu Sep 18 16:09:27 2014 +1000

    NFSv4: use exponential retry on NFS4ERR_DELAY for async requests.
    
    Currently asynchronous NFSv4 request will be retried with
    exponential timeout (from 1/10 to 15 seconds), but async
    requests will always use a 15second retry.
    
    Some "async" requests are really synchronous though.  The
    async mechanism is used to allow the request to continue if
    the requesting process is killed.
    In those cases, an exponential retry is appropriate.
    
    For example, if two different clients both open a file and
    get a READ delegation, and one client then unlinks the file
    (while still holding an open file descriptor), that unlink
    will used the "silly-rename" handling which is async.
    The first rename will result in NFS4ERR_DELAY while the
    delegation is reclaimed from the other client.  The rename
    will not be retried for 15 seconds, causing an unlink to take
    15 seconds rather than 100msec.
    
    This patch only added exponential timeout for async unlink and
    async rename.  Other async calls, such as 'close' are sometimes
    waited for so they might benefit from exponential timeout too.
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 7ae249ccb78d..6951c7d9097d 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1339,6 +1339,7 @@ struct nfs_unlinkdata {
 	struct inode *dir;
 	struct rpc_cred	*cred;
 	struct nfs_fattr dir_attr;
+	long timeout;
 };
 
 struct nfs_renamedata {
@@ -1352,6 +1353,7 @@ struct nfs_renamedata {
 	struct dentry		*new_dentry;
 	struct nfs_fattr	new_fattr;
 	void (*complete)(struct rpc_task *, struct nfs_renamedata *);
+	long timeout;
 };
 
 struct nfs_access_entry;

commit d4b18c3e00b8d18fbd316abe9639b91ad416e1f3
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Sep 10 17:36:31 2014 -0700

    pnfs: remove GETDEVICELIST implementation
    
    The current GETDEVICELIST implementation is buggy in that it doesn't handle
    cursors correctly, and in that it returns an error if the server returns
    NFSERR_NOTSUPP.  Given that there is no actual need for GETDEVICELIST,
    it has various issues and might get removed for NFSv4.2 stop using it in
    the blocklayout driver, and thus the Linux NFS client as whole.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index f4092c6b90fb..7ae249ccb78d 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -252,17 +252,6 @@ struct nfs4_layoutget {
 	gfp_t gfp_flags;
 };
 
-struct nfs4_getdevicelist_args {
-	struct nfs4_sequence_args seq_args;
-	const struct nfs_fh *fh;
-	u32 layoutclass;
-};
-
-struct nfs4_getdevicelist_res {
-	struct nfs4_sequence_res seq_res;
-	struct pnfs_devicelist *devlist;
-};
-
 struct nfs4_getdeviceinfo_args {
 	struct nfs4_sequence_args seq_args;
 	struct pnfs_device *pdev;

commit 5f919c9f10c1cf821ee5f414683214a361a1b98c
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Aug 21 11:09:25 2014 -0500

    pnfs: allow splicing pre-encoded pages into the layoutcommit args
    
    Currently there is no XDR buffer space allocated for the per-layout driver
    layoutcommit payload, which leads to server buffer overflows in the
    blocklayout driver even under simple workloads.  As we can't do per-layout
    sizes for XDR operations we'll have to splice a previously encoded list
    of pages into the XDR stream, similar to how we handle ACL buffers.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index e563b2c976ef..f4092c6b90fb 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -279,6 +279,9 @@ struct nfs4_layoutcommit_args {
 	__u64 lastbytewritten;
 	struct inode *inode;
 	const u32 *bitmask;
+	size_t layoutupdate_len;
+	struct page *layoutupdate_page;
+	struct page **layoutupdate_pages;
 };
 
 struct nfs4_layoutcommit_res {

commit 378520b837cf4da769600b83690d8e825f16a611
Author: Peng Tao <tao.peng@primarydata.com>
Date:   Thu Aug 7 10:15:02 2014 +0800

    nfs41: add a helper function to set layoutcommit after commit
    
    Track lwb in nfs_commit_data so that we can use it to setup
    layoutcommit in commit_done callback.
    
    Signed-off-by: Peng Tao <tao.peng@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 0040629894df..e563b2c976ef 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1328,6 +1328,7 @@ struct nfs_commit_data {
 	struct pnfs_layout_segment *lseg;
 	struct nfs_client	*ds_clp;	/* pNFS data server */
 	int			ds_commit_index;
+	loff_t			lwb;
 	const struct rpc_call_ops *mds_ops;
 	const struct nfs_commit_completion_ops *completion_ops;
 	int (*commit_done_cb) (struct rpc_task *task, struct nfs_commit_data *data);

commit f11b2a1cfbf5dd783eb55cb470509d06e20d1c78
Author: Jeff Layton <jlayton@poochiereds.net>
Date:   Sat Jun 21 20:52:17 2014 -0400

    nfs4: copy acceptor name from context to nfs_client
    
    The current CB_COMPOUND handling code tries to compare the principal
    name of the request with the cl_hostname in the client. This is not
    guaranteed to ever work, particularly if the client happened to mount
    a CNAME of the server or a non-fqdn.
    
    Fix this by instead comparing the cr_principal string with the acceptor
    name that we get from gssd. In the event that gssd didn't send one
    down (i.e. it was too old), then we fall back to trying to use the
    cl_hostname as we do today.
    
    Signed-off-by: Jeff Layton <jlayton@poochiereds.net>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 81cbbf313272..0040629894df 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -993,6 +993,7 @@ struct nfs4_setclientid {
 	unsigned int			sc_uaddr_len;
 	char				sc_uaddr[RPCBIND_MAXUADDRLEN + 1];
 	u32				sc_cb_ident;
+	struct rpc_cred			*sc_cred;
 };
 
 struct nfs4_setclientid_res {

commit 4714fb51fd03a14d8c73001438283e7f7b752f1e
Author: Weston Andros Adamson <dros@primarydata.com>
Date:   Mon Jun 9 11:48:37 2014 -0400

    nfs: remove pgio_header refcount, related cleanup
    
    The refcounting on nfs_pgio_header was related to there being (possibly)
    more than one nfs_pgio_data. Now that nfs_pgio_data has been merged into
    nfs_pgio_header, there is no reason to do this ref counting.  Just call
    the completion callback on nfs_pgio_release/nfs_pgio_error.
    
    Signed-off-by: Weston Andros Adamson <dros@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index e1b7b3b7c40f..81cbbf313272 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1259,7 +1259,6 @@ struct nfs_pgio_header {
 	struct inode		*inode;
 	struct rpc_cred		*cred;
 	struct list_head	pages;
-	atomic_t		refcnt;
 	struct nfs_page		*req;
 	struct nfs_writeverf	verf;		/* Used for writes */
 	struct pnfs_layout_segment *lseg;

commit c65e6254ca4db1584c5bf5f228ee26556477a9fd
Author: Weston Andros Adamson <dros@primarydata.com>
Date:   Mon Jun 9 11:48:36 2014 -0400

    nfs: remove unused writeverf code
    
    Remove duplicate writeverf structure from merge of nfs_pgio_header and
    nfs_pgio_data and remove writeverf related flags and logic to handle
    more than one RPC per nfs_pgio_header.
    
    Signed-off-by: Weston Andros Adamson <dros@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index efeaf7690b51..e1b7b3b7c40f 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1253,8 +1253,6 @@ enum {
 	NFS_IOHDR_ERROR = 0,
 	NFS_IOHDR_EOF,
 	NFS_IOHDR_REDO,
-	NFS_IOHDR_NEED_COMMIT,
-	NFS_IOHDR_NEED_RESCHED,
 };
 
 struct nfs_pgio_header {
@@ -1284,7 +1282,6 @@ struct nfs_pgio_header {
 	 */
 	struct rpc_task		task;
 	struct nfs_fattr	fattr;
-	struct nfs_writeverf	writeverf;	/* Used for writes */
 	struct nfs_pgio_args	args;		/* argument struct */
 	struct nfs_pgio_res	res;		/* result struct */
 	unsigned long		timestamp;	/* For lease renewal */

commit d45f60c67848b9f19160692581d78e5b4757a000
Author: Weston Andros Adamson <dros@primarydata.com>
Date:   Mon Jun 9 11:48:35 2014 -0400

    nfs: merge nfs_pgio_data into _header
    
    struct nfs_pgio_data only exists as a member of nfs_pgio_header, but is
    passed around everywhere, because there used to be multiple _data structs
    per _header. Many of these functions then use the _data to find a pointer
    to the _header.  This patch cleans this up by merging the nfs_pgio_data
    structure into nfs_pgio_header and passing nfs_pgio_header around instead.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Weston Andros Adamson <dros@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index bb18dba1aefe..efeaf7690b51 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1257,27 +1257,10 @@ enum {
 	NFS_IOHDR_NEED_RESCHED,
 };
 
-struct nfs_pgio_data {
-	struct nfs_pgio_header	*header;
-	struct list_head	list;
-	struct rpc_task		task;
-	struct nfs_fattr	fattr;
-	struct nfs_writeverf	writeverf;	/* Used for writes */
-	struct nfs_pgio_args	args;		/* argument struct */
-	struct nfs_pgio_res	res;		/* result struct */
-	unsigned long		timestamp;	/* For lease renewal */
-	int (*pgio_done_cb)(struct rpc_task *task, struct nfs_pgio_data *data);
-	__u64			mds_offset;	/* Filelayout dense stripe */
-	struct nfs_page_array	page_array;
-	struct nfs_client	*ds_clp;	/* pNFS data server */
-	int			ds_idx;		/* ds index if ds_clp is set */
-};
-
 struct nfs_pgio_header {
 	struct inode		*inode;
 	struct rpc_cred		*cred;
 	struct list_head	pages;
-	struct nfs_pgio_data	data;
 	atomic_t		refcnt;
 	struct nfs_page		*req;
 	struct nfs_writeverf	verf;		/* Used for writes */
@@ -1295,6 +1278,21 @@ struct nfs_pgio_header {
 	int			error;		/* merge with pnfs_error */
 	unsigned long		good_bytes;	/* boundary of good data */
 	unsigned long		flags;
+
+	/*
+	 * rpc data
+	 */
+	struct rpc_task		task;
+	struct nfs_fattr	fattr;
+	struct nfs_writeverf	writeverf;	/* Used for writes */
+	struct nfs_pgio_args	args;		/* argument struct */
+	struct nfs_pgio_res	res;		/* result struct */
+	unsigned long		timestamp;	/* For lease renewal */
+	int (*pgio_done_cb)(struct rpc_task *, struct nfs_pgio_header *);
+	__u64			mds_offset;	/* Filelayout dense stripe */
+	struct nfs_page_array	page_array;
+	struct nfs_client	*ds_clp;	/* pNFS data server */
+	int			ds_idx;		/* ds index if ds_clp is set */
 };
 
 struct nfs_mds_commit_info {
@@ -1426,11 +1424,12 @@ struct nfs_rpc_ops {
 			     struct nfs_pathconf *);
 	int	(*set_capabilities)(struct nfs_server *, struct nfs_fh *);
 	int	(*decode_dirent)(struct xdr_stream *, struct nfs_entry *, int);
-	int	(*pgio_rpc_prepare)(struct rpc_task *, struct nfs_pgio_data *);
-	void	(*read_setup)   (struct nfs_pgio_data *, struct rpc_message *);
-	int	(*read_done)  (struct rpc_task *, struct nfs_pgio_data *);
-	void	(*write_setup)  (struct nfs_pgio_data *, struct rpc_message *);
-	int	(*write_done)  (struct rpc_task *, struct nfs_pgio_data *);
+	int	(*pgio_rpc_prepare)(struct rpc_task *,
+				    struct nfs_pgio_header *);
+	void	(*read_setup)(struct nfs_pgio_header *, struct rpc_message *);
+	int	(*read_done)(struct rpc_task *, struct nfs_pgio_header *);
+	void	(*write_setup)(struct nfs_pgio_header *, struct rpc_message *);
+	int	(*write_done)(struct rpc_task *, struct nfs_pgio_header *);
 	void	(*commit_setup) (struct nfs_commit_data *, struct rpc_message *);
 	void	(*commit_rpc_prepare)(struct rpc_task *, struct nfs_commit_data *);
 	int	(*commit_done) (struct rpc_task *, struct nfs_commit_data *);

commit 823b0c9d9800e712374cda89ac3565bd29f6701b
Author: Weston Andros Adamson <dros@primarydata.com>
Date:   Mon Jun 9 11:48:34 2014 -0400

    nfs: rename members of nfs_pgio_data
    
    Rename "verf" to "writeverf" and "pages" to "page_array" to prepare for
    merge of nfs_pgio_data and nfs_pgio_header.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Weston Andros Adamson <dros@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index e1c9437e8aac..bb18dba1aefe 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1262,13 +1262,13 @@ struct nfs_pgio_data {
 	struct list_head	list;
 	struct rpc_task		task;
 	struct nfs_fattr	fattr;
-	struct nfs_writeverf	verf;		/* Used for writes */
+	struct nfs_writeverf	writeverf;	/* Used for writes */
 	struct nfs_pgio_args	args;		/* argument struct */
 	struct nfs_pgio_res	res;		/* result struct */
 	unsigned long		timestamp;	/* For lease renewal */
 	int (*pgio_done_cb)(struct rpc_task *task, struct nfs_pgio_data *data);
 	__u64			mds_offset;	/* Filelayout dense stripe */
-	struct nfs_page_array	pages;
+	struct nfs_page_array	page_array;
 	struct nfs_client	*ds_clp;	/* pNFS data server */
 	int			ds_idx;		/* ds index if ds_clp is set */
 };

commit 1e7f3a485922211b6e4a082ebc6bf05810b0b6ea
Author: Weston Andros Adamson <dros@primarydata.com>
Date:   Mon Jun 9 11:48:33 2014 -0400

    nfs: move nfs_pgio_data and remove nfs_rw_header
    
    nfs_rw_header was used to allocate an nfs_pgio_header along with an
    nfs_pgio_data, because a _header would need at least one _data.
    
    Now there is only ever one nfs_pgio_data for each nfs_pgio_header -- move
    it to nfs_pgio_header and get rid of nfs_rw_header.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Weston Andros Adamson <dros@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 9a1396e70310..e1c9437e8aac 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1257,13 +1257,27 @@ enum {
 	NFS_IOHDR_NEED_RESCHED,
 };
 
-struct nfs_pgio_data;
+struct nfs_pgio_data {
+	struct nfs_pgio_header	*header;
+	struct list_head	list;
+	struct rpc_task		task;
+	struct nfs_fattr	fattr;
+	struct nfs_writeverf	verf;		/* Used for writes */
+	struct nfs_pgio_args	args;		/* argument struct */
+	struct nfs_pgio_res	res;		/* result struct */
+	unsigned long		timestamp;	/* For lease renewal */
+	int (*pgio_done_cb)(struct rpc_task *task, struct nfs_pgio_data *data);
+	__u64			mds_offset;	/* Filelayout dense stripe */
+	struct nfs_page_array	pages;
+	struct nfs_client	*ds_clp;	/* pNFS data server */
+	int			ds_idx;		/* ds index if ds_clp is set */
+};
 
 struct nfs_pgio_header {
 	struct inode		*inode;
 	struct rpc_cred		*cred;
 	struct list_head	pages;
-	struct nfs_pgio_data	*data;
+	struct nfs_pgio_data	data;
 	atomic_t		refcnt;
 	struct nfs_page		*req;
 	struct nfs_writeverf	verf;		/* Used for writes */
@@ -1283,26 +1297,6 @@ struct nfs_pgio_header {
 	unsigned long		flags;
 };
 
-struct nfs_pgio_data {
-	struct nfs_pgio_header	*header;
-	struct rpc_task		task;
-	struct nfs_fattr	fattr;
-	struct nfs_writeverf	verf;		/* Used for writes */
-	struct nfs_pgio_args	args;		/* argument struct */
-	struct nfs_pgio_res	res;		/* result struct */
-	unsigned long		timestamp;	/* For lease renewal */
-	int (*pgio_done_cb) (struct rpc_task *task, struct nfs_pgio_data *data);
-	__u64			mds_offset;	/* Filelayout dense stripe */
-	struct nfs_page_array	pages;
-	struct nfs_client	*ds_clp;	/* pNFS data server */
-	int			ds_idx;		/* ds index if ds_clp is set */
-};
-
-struct nfs_rw_header {
-	struct nfs_pgio_header	header;
-	struct nfs_pgio_data	rpc_data;
-};
-
 struct nfs_mds_commit_info {
 	atomic_t rpcs_out;
 	unsigned long		ncommit;

commit 5002c58639d41b93e800c8a4b7eca49c40d57822
Author: Weston Andros Adamson <dros@primarydata.com>
Date:   Thu May 15 11:56:54 2014 -0400

    pnfs: support multiple verfs per direct req
    
    Support direct requests that span multiple pnfs data servers by
    comparing nfs_pgio_header->verf to a cached verf in pnfs_commit_bucket.
    Continue to use dreq->verf if the MDS is used / non-pNFS.
    
    Signed-off-by: Weston Andros Adamson <dros@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index ae636013fb1f..9a1396e70310 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1112,6 +1112,7 @@ struct pnfs_commit_bucket {
 	struct list_head committing;
 	struct pnfs_layout_segment *wlseg;
 	struct pnfs_layout_segment *clseg;
+	struct nfs_writeverf direct_verf;
 };
 
 struct pnfs_ds_commit_info {
@@ -1294,6 +1295,7 @@ struct nfs_pgio_data {
 	__u64			mds_offset;	/* Filelayout dense stripe */
 	struct nfs_page_array	pages;
 	struct nfs_client	*ds_clp;	/* pNFS data server */
+	int			ds_idx;		/* ds index if ds_clp is set */
 };
 
 struct nfs_rw_header {

commit 7f714720fac03383d687dbe39494cc96b845bd46
Author: Weston Andros Adamson <dros@primarydata.com>
Date:   Thu May 15 11:56:53 2014 -0400

    nfs: remove data list from pgio header
    
    Since the ability to split pages into subpage requests has been added,
    nfs_pgio_header->rpc_list only ever has one pgio data.
    
    Signed-off-by: Weston Andros Adamson <dros@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index adef7bd2d06d..ae636013fb1f 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1256,11 +1256,13 @@ enum {
 	NFS_IOHDR_NEED_RESCHED,
 };
 
+struct nfs_pgio_data;
+
 struct nfs_pgio_header {
 	struct inode		*inode;
 	struct rpc_cred		*cred;
 	struct list_head	pages;
-	struct list_head	rpc_list;
+	struct nfs_pgio_data	*data;
 	atomic_t		refcnt;
 	struct nfs_page		*req;
 	struct nfs_writeverf	verf;		/* Used for writes */
@@ -1282,7 +1284,6 @@ struct nfs_pgio_header {
 
 struct nfs_pgio_data {
 	struct nfs_pgio_header	*header;
-	struct list_head	list;
 	struct rpc_task		task;
 	struct nfs_fattr	fattr;
 	struct nfs_writeverf	verf;		/* Used for writes */

commit a4cdda59111f92000297e0d3edb1e0e08ba3549b
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 6 09:12:31 2014 -0400

    NFS: Create a common pgio_rpc_prepare function
    
    The read and write paths do exactly the same thing for the rpc_prepare
    rpc_op.  This patch combines them together into a single function.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index a1b91b67145e..adef7bd2d06d 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1429,11 +1429,10 @@ struct nfs_rpc_ops {
 			     struct nfs_pathconf *);
 	int	(*set_capabilities)(struct nfs_server *, struct nfs_fh *);
 	int	(*decode_dirent)(struct xdr_stream *, struct nfs_entry *, int);
+	int	(*pgio_rpc_prepare)(struct rpc_task *, struct nfs_pgio_data *);
 	void	(*read_setup)   (struct nfs_pgio_data *, struct rpc_message *);
-	int	(*read_rpc_prepare)(struct rpc_task *, struct nfs_pgio_data *);
 	int	(*read_done)  (struct rpc_task *, struct nfs_pgio_data *);
 	void	(*write_setup)  (struct nfs_pgio_data *, struct rpc_message *);
-	int	(*write_rpc_prepare)(struct rpc_task *, struct nfs_pgio_data *);
 	int	(*write_done)  (struct rpc_task *, struct nfs_pgio_data *);
 	void	(*commit_setup) (struct nfs_commit_data *, struct rpc_message *);
 	void	(*commit_rpc_prepare)(struct rpc_task *, struct nfs_commit_data *);

commit 4a0de55c565a36cac8422b76a948c4634a90781e
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 6 09:12:30 2014 -0400

    NFS: Create a common rw_header_alloc and rw_header_free function
    
    I create a new struct nfs_rw_ops to decide the differences between reads
    and writes.  This struct will be set when initializing a new
    nfs_pgio_descriptor, and then passed on to the nfs_rw_header when a new
    header is allocated.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 965c2aa6b33f..a1b91b67145e 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1269,6 +1269,7 @@ struct nfs_pgio_header {
 	const struct rpc_call_ops *mds_ops;
 	void (*release) (struct nfs_pgio_header *hdr);
 	const struct nfs_pgio_completion_ops *completion_ops;
+	const struct nfs_rw_ops	*rw_ops;
 	struct nfs_direct_req	*dreq;
 	void			*layout_private;
 	spinlock_t		lock;

commit f79d06f544a797d75cbf5256a5d06c4b3d2759cc
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 6 09:12:28 2014 -0400

    NFS: Move the write verifier into the nfs_pgio_header
    
    The header had a pointer to the verifier that was set from the old write
    data struct.  We don't need to keep the pointer around now that we have
    shared structures.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 2d34e0dc1870..965c2aa6b33f 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1263,7 +1263,7 @@ struct nfs_pgio_header {
 	struct list_head	rpc_list;
 	atomic_t		refcnt;
 	struct nfs_page		*req;
-	struct nfs_writeverf	*verf;
+	struct nfs_writeverf	verf;		/* Used for writes */
 	struct pnfs_layout_segment *lseg;
 	loff_t			io_start;
 	const struct rpc_call_ops *mds_ops;
@@ -1297,7 +1297,6 @@ struct nfs_pgio_data {
 struct nfs_rw_header {
 	struct nfs_pgio_header	header;
 	struct nfs_pgio_data	rpc_data;
-	struct nfs_writeverf	verf;
 };
 
 struct nfs_mds_commit_info {

commit c0752cdfbbb691cfe98812f7aed8ce1e766823c4
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 6 09:12:27 2014 -0400

    NFS: Create a common read and write header struct
    
    The only difference is the write verifier field, but we can keep that
    for a little bit longer.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 64f6f1491c0d..2d34e0dc1870 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1294,12 +1294,7 @@ struct nfs_pgio_data {
 	struct nfs_client	*ds_clp;	/* pNFS data server */
 };
 
-struct nfs_read_header {
-	struct nfs_pgio_header	header;
-	struct nfs_pgio_data	rpc_data;
-};
-
-struct nfs_write_header {
+struct nfs_rw_header {
 	struct nfs_pgio_header	header;
 	struct nfs_pgio_data	rpc_data;
 	struct nfs_writeverf	verf;

commit 9c7e1b3d50b56b8d8f6237ed232350b7c6476cd5
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 6 09:12:26 2014 -0400

    NFS: Create a common read and write data struct
    
    At this point, the only difference between nfs_read_data and
    nfs_write_data is the write verifier.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 381f832b03c6..64f6f1491c0d 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1247,20 +1247,6 @@ struct nfs_page_array {
 	struct page		*page_array[NFS_PAGEVEC_SIZE];
 };
 
-struct nfs_read_data {
-	struct nfs_pgio_header	*header;
-	struct list_head	list;
-	struct rpc_task		task;
-	struct nfs_fattr	fattr;	/* fattr storage */
-	struct nfs_pgio_args	args;
-	struct nfs_pgio_res	res;
-	unsigned long		timestamp;	/* For lease renewal */
-	int (*read_done_cb) (struct rpc_task *task, struct nfs_read_data *data);
-	__u64			mds_offset;
-	struct nfs_page_array	pages;
-	struct nfs_client	*ds_clp;	/* pNFS data server */
-};
-
 /* used as flag bits in nfs_pgio_header */
 enum {
 	NFS_IOHDR_ERROR = 0,
@@ -1293,29 +1279,29 @@ struct nfs_pgio_header {
 	unsigned long		flags;
 };
 
-struct nfs_read_header {
-	struct nfs_pgio_header	header;
-	struct nfs_read_data	rpc_data;
-};
-
-struct nfs_write_data {
+struct nfs_pgio_data {
 	struct nfs_pgio_header	*header;
 	struct list_head	list;
 	struct rpc_task		task;
 	struct nfs_fattr	fattr;
-	struct nfs_writeverf	verf;
+	struct nfs_writeverf	verf;		/* Used for writes */
 	struct nfs_pgio_args	args;		/* argument struct */
 	struct nfs_pgio_res	res;		/* result struct */
 	unsigned long		timestamp;	/* For lease renewal */
-	int (*write_done_cb) (struct rpc_task *task, struct nfs_write_data *data);
+	int (*pgio_done_cb) (struct rpc_task *task, struct nfs_pgio_data *data);
 	__u64			mds_offset;	/* Filelayout dense stripe */
 	struct nfs_page_array	pages;
 	struct nfs_client	*ds_clp;	/* pNFS data server */
 };
 
+struct nfs_read_header {
+	struct nfs_pgio_header	header;
+	struct nfs_pgio_data	rpc_data;
+};
+
 struct nfs_write_header {
 	struct nfs_pgio_header	header;
-	struct nfs_write_data	rpc_data;
+	struct nfs_pgio_data	rpc_data;
 	struct nfs_writeverf	verf;
 };
 
@@ -1448,12 +1434,12 @@ struct nfs_rpc_ops {
 			     struct nfs_pathconf *);
 	int	(*set_capabilities)(struct nfs_server *, struct nfs_fh *);
 	int	(*decode_dirent)(struct xdr_stream *, struct nfs_entry *, int);
-	void	(*read_setup)   (struct nfs_read_data *, struct rpc_message *);
-	int	(*read_rpc_prepare)(struct rpc_task *, struct nfs_read_data *);
-	int	(*read_done)  (struct rpc_task *, struct nfs_read_data *);
-	void	(*write_setup)  (struct nfs_write_data *, struct rpc_message *);
-	int	(*write_rpc_prepare)(struct rpc_task *, struct nfs_write_data *);
-	int	(*write_done)  (struct rpc_task *, struct nfs_write_data *);
+	void	(*read_setup)   (struct nfs_pgio_data *, struct rpc_message *);
+	int	(*read_rpc_prepare)(struct rpc_task *, struct nfs_pgio_data *);
+	int	(*read_done)  (struct rpc_task *, struct nfs_pgio_data *);
+	void	(*write_setup)  (struct nfs_pgio_data *, struct rpc_message *);
+	int	(*write_rpc_prepare)(struct rpc_task *, struct nfs_pgio_data *);
+	int	(*write_done)  (struct rpc_task *, struct nfs_pgio_data *);
 	void	(*commit_setup) (struct nfs_commit_data *, struct rpc_message *);
 	void	(*commit_rpc_prepare)(struct rpc_task *, struct nfs_commit_data *);
 	int	(*commit_done) (struct rpc_task *, struct nfs_commit_data *);

commit 9137bdf3d241fc2cbeb2a8ced51d1546150aa6a1
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 6 09:12:25 2014 -0400

    NFS: Create a common results structure for reads and writes
    
    Reads and writes have very similar results.  This patch combines the two
    structs together with comments to show where the differing fields are
    used.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 5875001928f9..381f832b03c6 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -488,16 +488,6 @@ struct nfs4_delegreturnres {
 	const struct nfs_server *server;
 };
 
-/*
- * Arguments to the read call.
- */
-struct nfs_readres {
-	struct nfs4_sequence_res	seq_res;
-	struct nfs_fattr *	fattr;
-	__u32			count;
-	int                     eof;
-};
-
 /*
  * Arguments to the write call.
  */
@@ -510,14 +500,6 @@ struct nfs_writeverf {
 	enum nfs3_stable_how	committed;
 };
 
-struct nfs_writeres {
-	struct nfs4_sequence_res	seq_res;
-	struct nfs_fattr *	fattr;
-	struct nfs_writeverf *	verf;
-	__u32			count;
-	const struct nfs_server *server;
-};
-
 /*
  * Arguments shared by the read and write call.
  */
@@ -535,6 +517,16 @@ struct nfs_pgio_args {
 	enum nfs3_stable_how	stable;		/* used by write */
 };
 
+struct nfs_pgio_res {
+	struct nfs4_sequence_res	seq_res;
+	struct nfs_fattr *	fattr;
+	__u32			count;
+	int			eof;		/* used by read */
+	struct nfs_writeverf *	verf;		/* used by write */
+	const struct nfs_server *server;	/* used by write */
+
+};
+
 /*
  * Arguments to the commit call.
  */
@@ -1261,7 +1253,7 @@ struct nfs_read_data {
 	struct rpc_task		task;
 	struct nfs_fattr	fattr;	/* fattr storage */
 	struct nfs_pgio_args	args;
-	struct nfs_readres  res;
+	struct nfs_pgio_res	res;
 	unsigned long		timestamp;	/* For lease renewal */
 	int (*read_done_cb) (struct rpc_task *task, struct nfs_read_data *data);
 	__u64			mds_offset;
@@ -1313,7 +1305,7 @@ struct nfs_write_data {
 	struct nfs_fattr	fattr;
 	struct nfs_writeverf	verf;
 	struct nfs_pgio_args	args;		/* argument struct */
-	struct nfs_writeres	res;		/* result struct */
+	struct nfs_pgio_res	res;		/* result struct */
 	unsigned long		timestamp;	/* For lease renewal */
 	int (*write_done_cb) (struct rpc_task *task, struct nfs_write_data *data);
 	__u64			mds_offset;	/* Filelayout dense stripe */

commit 3c6b899c49e5e9c2803b59ee553eddaf69cea7f6
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Tue May 6 09:12:24 2014 -0400

    NFS: Create a common argument structure for reads and writes
    
    Reads and writes have very similar arguments.  This patch combines them
    together and documents the few fields used only by write.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 3e8fc1fe585b..5875001928f9 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -491,18 +491,6 @@ struct nfs4_delegreturnres {
 /*
  * Arguments to the read call.
  */
-struct nfs_readargs {
-	struct nfs4_sequence_args	seq_args;
-	struct nfs_fh *		fh;
-	struct nfs_open_context *context;
-	struct nfs_lock_context *lock_context;
-	nfs4_stateid		stateid;
-	__u64			offset;
-	__u32			count;
-	unsigned int		pgbase;
-	struct page **		pages;
-};
-
 struct nfs_readres {
 	struct nfs4_sequence_res	seq_res;
 	struct nfs_fattr *	fattr;
@@ -513,20 +501,6 @@ struct nfs_readres {
 /*
  * Arguments to the write call.
  */
-struct nfs_writeargs {
-	struct nfs4_sequence_args	seq_args;
-	struct nfs_fh *		fh;
-	struct nfs_open_context *context;
-	struct nfs_lock_context *lock_context;
-	nfs4_stateid		stateid;
-	__u64			offset;
-	__u32			count;
-	enum nfs3_stable_how	stable;
-	unsigned int		pgbase;
-	struct page **		pages;
-	const u32 *		bitmask;
-};
-
 struct nfs_write_verifier {
 	char			data[8];
 };
@@ -544,6 +518,23 @@ struct nfs_writeres {
 	const struct nfs_server *server;
 };
 
+/*
+ * Arguments shared by the read and write call.
+ */
+struct nfs_pgio_args {
+	struct nfs4_sequence_args	seq_args;
+	struct nfs_fh *		fh;
+	struct nfs_open_context *context;
+	struct nfs_lock_context *lock_context;
+	nfs4_stateid		stateid;
+	__u64			offset;
+	__u32			count;
+	unsigned int		pgbase;
+	struct page **		pages;
+	const u32 *		bitmask;	/* used by write */
+	enum nfs3_stable_how	stable;		/* used by write */
+};
+
 /*
  * Arguments to the commit call.
  */
@@ -1269,7 +1260,7 @@ struct nfs_read_data {
 	struct list_head	list;
 	struct rpc_task		task;
 	struct nfs_fattr	fattr;	/* fattr storage */
-	struct nfs_readargs args;
+	struct nfs_pgio_args	args;
 	struct nfs_readres  res;
 	unsigned long		timestamp;	/* For lease renewal */
 	int (*read_done_cb) (struct rpc_task *task, struct nfs_read_data *data);
@@ -1321,7 +1312,7 @@ struct nfs_write_data {
 	struct rpc_task		task;
 	struct nfs_fattr	fattr;
 	struct nfs_writeverf	verf;
-	struct nfs_writeargs	args;		/* argument struct */
+	struct nfs_pgio_args	args;		/* argument struct */
 	struct nfs_writeres	res;		/* result struct */
 	unsigned long		timestamp;	/* For lease renewal */
 	int (*write_done_cb) (struct rpc_task *task, struct nfs_write_data *data);

commit fab5fc25d230edcc8ee72367e505955a2fae0cac
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Apr 16 15:07:22 2014 +0200

    nfs: remove ->read_pageio_init from rpc ops
    
    The read_pageio_init method is just a very convoluted way to grab the
    right nfs_pageio_ops vector.  The vector to chose is not a choice of
    protocol version, but just a pNFS vs MDS I/O choice that can simply be
    done inside nfs_pageio_init_read based on the presence of a layout
    driver, and a new force_mds flag to the special case of falling back
    to MDS I/O on a pNFS-capable volume.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 78216f859527..3e8fc1fe585b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1466,8 +1466,6 @@ struct nfs_rpc_ops {
 	int	(*set_capabilities)(struct nfs_server *, struct nfs_fh *);
 	int	(*decode_dirent)(struct xdr_stream *, struct nfs_entry *, int);
 	void	(*read_setup)   (struct nfs_read_data *, struct rpc_message *);
-	void	(*read_pageio_init)(struct nfs_pageio_descriptor *, struct inode *,
-				    const struct nfs_pgio_completion_ops *);
 	int	(*read_rpc_prepare)(struct rpc_task *, struct nfs_read_data *);
 	int	(*read_done)  (struct rpc_task *, struct nfs_read_data *);
 	void	(*write_setup)  (struct nfs_write_data *, struct rpc_message *);

commit a20c93e3160e37ecccc738d8eef085c8507949ed
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Apr 16 15:07:21 2014 +0200

    nfs: remove ->write_pageio_init from rpc ops
    
    The write_pageio_init method is just a very convoluted way to grab the
    right nfs_pageio_ops vector.  The vector to chose is not a choice of
    protocol version, but just a pNFS vs MDS I/O choice that can simply be
    done inside nfs_pageio_init_write based on the presence of a layout
    driver, and a new force_mds flag to the special case of falling back
    to MDS I/O on a pNFS-capable volume.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 6fb5b2335b59..78216f859527 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1471,8 +1471,6 @@ struct nfs_rpc_ops {
 	int	(*read_rpc_prepare)(struct rpc_task *, struct nfs_read_data *);
 	int	(*read_done)  (struct rpc_task *, struct nfs_read_data *);
 	void	(*write_setup)  (struct nfs_write_data *, struct rpc_message *);
-	void	(*write_pageio_init)(struct nfs_pageio_descriptor *, struct inode *, int,
-				     const struct nfs_pgio_completion_ops *);
 	int	(*write_rpc_prepare)(struct rpc_task *, struct nfs_write_data *);
 	int	(*write_done)  (struct rpc_task *, struct nfs_write_data *);
 	void	(*commit_setup) (struct nfs_commit_data *, struct rpc_message *);

commit bd0f725c4c0bd77b6d931f63eda2d51423a22d43
Merge: 2ca310fc4160 fdb63dcdb53a
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Mon Mar 17 15:15:21 2014 -0400

    Merge branch 'devel' into linux-next

commit 33912be816d96e204ed7a93690552daa39c08ea9
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Mar 17 07:06:57 2014 -0400

    nfs: remove synchronous rename code
    
    Now that nfs_rename uses the async infrastructure, we can remove this.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Tested-by: Anna Schumaker <Anna.Schumaker@netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 0534184b65ce..ad88a0a30a18 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1440,8 +1440,6 @@ struct nfs_rpc_ops {
 	void	(*unlink_setup)  (struct rpc_message *, struct inode *dir);
 	void	(*unlink_rpc_prepare) (struct rpc_task *, struct nfs_unlinkdata *);
 	int	(*unlink_done) (struct rpc_task *, struct inode *);
-	int	(*rename)  (struct inode *, struct qstr *,
-			    struct inode *, struct qstr *);
 	void	(*rename_setup)  (struct rpc_message *msg, struct inode *dir);
 	void	(*rename_rpc_prepare)(struct rpc_task *task, struct nfs_renamedata *);
 	int	(*rename_done) (struct rpc_task *task, struct inode *old_dir, struct inode *new_dir);

commit 96f9d8c0740264c5e2975361389ff2c21f2c5a4d
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Mar 17 07:06:54 2014 -0400

    nfs: abstract out code needed to complete a sillyrename
    
    The async rename code is currently "polluted" with some parts that are
    really just for sillyrenames. Add a new "complete" operation vector to
    the nfs_renamedata to separate out the stuff that just needs to be done
    for a sillyrename.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Tested-by: Anna Schumaker <Anna.Schumaker@netapp.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index b2fb167b2e6d..0534184b65ce 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1397,6 +1397,7 @@ struct nfs_renamedata {
 	struct inode		*new_dir;
 	struct dentry		*new_dentry;
 	struct nfs_fattr	new_fattr;
+	void (*complete)(struct rpc_task *, struct nfs_renamedata *);
 };
 
 struct nfs_access_entry;

commit b7e63a1079b266866a732cf699d8c4d61391bbda
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Wed Feb 26 11:19:14 2014 -0800

    NFSv4: Fix another nfs4_sequence corruptor
    
    nfs4_release_lockowner needs to set the rpc_message reply to point to
    the nfs4_sequence_res in order to avoid another Oopsable situation
    in nfs41_assign_slot.
    
    Fixes: fbd4bfd1d9d21 (NFS: Add nfs4_sequence calls for RELEASE_LOCKOWNER)
    Cc: stable@vger.kernel.org # 3.12+
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index b2fb167b2e6d..5624e4e2763c 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -467,9 +467,14 @@ struct nfs_lockt_res {
 };
 
 struct nfs_release_lockowner_args {
+	struct nfs4_sequence_args	seq_args;
 	struct nfs_lowner	lock_owner;
 };
 
+struct nfs_release_lockowner_res {
+	struct nfs4_sequence_res	seq_res;
+};
+
 struct nfs4_delegreturnargs {
 	struct nfs4_sequence_args	seq_args;
 	const struct nfs_fh *fhandle;

commit 17ead6c85c3d0ef57a14d1373f1f1cee2ce60ea8
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Sat Feb 1 14:53:23 2014 -0500

    NFSv4: Fix memory corruption in nfs4_proc_open_confirm
    
    nfs41_wake_and_assign_slot() relies on the task->tk_msg.rpc_argp and
    task->tk_msg.rpc_resp always pointing to the session sequence arguments.
    
    nfs4_proc_open_confirm tries to pull a fast one by reusing the open
    sequence structure, thus causing corruption of the NFSv4 slot table.
    
    Cc: stable@vger.kernel.org # 3.12+
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 3ccfcecf8999..b2fb167b2e6d 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -379,12 +379,14 @@ struct nfs_openres {
  * Arguments to the open_confirm call.
  */
 struct nfs_open_confirmargs {
+	struct nfs4_sequence_args	seq_args;
 	const struct nfs_fh *	fh;
 	nfs4_stateid *		stateid;
 	struct nfs_seqid *	seqid;
 };
 
 struct nfs_open_confirmres {
+	struct nfs4_sequence_res	seq_res;
 	nfs4_stateid            stateid;
 	struct nfs_seqid *	seqid;
 };

commit 4d4b69dd847a098cdca341c45326f6c6f61b8691
Author: Weston Andros Adamson <dros@netapp.com>
Date:   Fri Oct 18 15:15:19 2013 -0400

    NFS: add support for multiple sec= mount options
    
    This patch adds support for multiple security options which can be
    specified using a colon-delimited list of security flavors (the same
    syntax as nfsd's exports file).
    
    This is useful, for instance, when NFSv4.x mounts cross SECINFO
    boundaries. With this patch a user can use "sec=krb5i,krb5p"
    to mount a remote filesystem using krb5i, but can still cross
    into krb5p-only exports.
    
    New mounts will try all security options before failing.  NFSv4.x
    SECINFO results will be compared against the sec= flavors to
    find the first flavor in both lists or if no match is found will
    return -EPERM.
    
    Signed-off-by: Weston Andros Adamson <dros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 658104acf13b..3ccfcecf8999 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -592,9 +592,10 @@ struct nfs_renameres {
 };
 
 /* parsed sec= options */
+#define NFS_AUTH_INFO_MAX_FLAVORS 12 /* see fs/nfs/super.c */
 struct nfs_auth_info {
 	unsigned int            flavor_len;
-	rpc_authflavor_t        flavors[1];
+	rpc_authflavor_t        flavors[NFS_AUTH_INFO_MAX_FLAVORS];
 };
 
 /*

commit a3f73c27afff9590a4432879b7145289cb89cf0a
Author: Weston Andros Adamson <dros@netapp.com>
Date:   Fri Oct 18 15:15:16 2013 -0400

    NFS: separate passed security flavs from selected
    
    When filling parsed_mount_data, store the parsed sec= mount option in
    the new struct nfs_auth_info and the chosen flavor in selected_flavor.
    
    This patch lays the groundwork for supporting multiple sec= options.
    
    Signed-off-by: Weston Andros Adamson <dros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 8fe5b940c5f2..658104acf13b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -591,6 +591,12 @@ struct nfs_renameres {
 	struct nfs_fattr		*new_fattr;
 };
 
+/* parsed sec= options */
+struct nfs_auth_info {
+	unsigned int            flavor_len;
+	rpc_authflavor_t        flavors[1];
+};
+
 /*
  * Argument struct for decode_entry function
  */

commit 44c9993384e9311cd56acf6ead3baffab616ae50
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Thu Oct 17 14:13:30 2013 -0400

    NFS: Add method to detect whether an FSID is still on the server
    
    Introduce a mechanism for probing a server to determine if an FSID
    is present or absent.
    
    The on-the-wire compound is different between minor version 0 and 1.
    Minor version 0 appends a RENEW operation to identify which client
    ID is probing.  Minor version 1 has a SEQUENCE operation in the
    compound which effectively carries the same information.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 405dfadcbc3b..8fe5b940c5f2 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1088,6 +1088,19 @@ struct nfs4_secinfo_res {
 	struct nfs4_secinfo_flavors	*flavors;
 };
 
+struct nfs4_fsid_present_arg {
+	struct nfs4_sequence_args	seq_args;
+	const struct nfs_fh		*fh;
+	clientid4			clientid;
+	unsigned char			renew:1;
+};
+
+struct nfs4_fsid_present_res {
+	struct nfs4_sequence_res	seq_res;
+	struct nfs_fh			*fh;
+	unsigned char			renew:1;
+};
+
 #endif /* CONFIG_NFS_V4 */
 
 struct nfstime4 {

commit b03d735b4ca2375d2251195cd848713bc55e7d79
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Thu Oct 17 14:12:50 2013 -0400

    NFS: Add method to retrieve fs_locations during migration recovery
    
    The nfs4_proc_fs_locations() function is invoked during referral
    processing to perform a GETATTR(fs_locations) on an object's parent
    directory in order to discover the target of the referral.  It
    performs a LOOKUP in the compound, so the client needs to know the
    parent's file handle a priori.
    
    Unfortunately this function is not adequate for handling migration
    recovery.  We need to probe fs_locations information on an FSID, but
    there's no parent directory available for many operations that
    can return NFS4ERR_MOVED.
    
    Another subtlety: recovering from NFS4ERR_LEASE_MOVED is a process
    of walking over a list of known FSIDs that reside on the server, and
    probing whether they have migrated.  Once the server has detected
    that the client has probed all migrated file systems, it stops
    returning NFS4ERR_LEASE_MOVED.
    
    A minor version zero server needs to know what client ID is
    requesting fs_locations information so it can clear the flag that
    forces it to continue returning NFS4ERR_LEASE_MOVED.  This flag is
    set per client ID and per FSID.  However, the client ID is not an
    argument of either the PUTFH or GETATTR operations.  Later minor
    versions have client ID information embedded in the compound's
    SEQUENCE operation.
    
    Therefore, by convention, minor version zero clients send a RENEW
    operation in the same compound as the GETATTR(fs_locations), since
    RENEW's one argument is a clientid4.  This allows a minor version
    zero server to identify correctly the client that is probing for a
    migration.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 49f52c8f4422..405dfadcbc3b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1053,14 +1053,18 @@ struct nfs4_fs_locations {
 struct nfs4_fs_locations_arg {
 	struct nfs4_sequence_args	seq_args;
 	const struct nfs_fh *dir_fh;
+	const struct nfs_fh *fh;
 	const struct qstr *name;
 	struct page *page;
 	const u32 *bitmask;
+	clientid4 clientid;
+	unsigned char migration:1, renew:1;
 };
 
 struct nfs4_fs_locations_res {
 	struct nfs4_sequence_res	seq_res;
 	struct nfs4_fs_locations       *fs_locations;
+	unsigned char			migration:1, renew:1;
 };
 
 struct nfs4_secinfo4 {

commit 5bc2afc2b53fc73f154e6344cd898585628e6d27
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Sep 23 18:01:28 2013 -0400

    NFSv4: Honour the 'opened' parameter in the atomic_open() filesystem method
    
    Determine if we've created a new file by examining the directory change
    attribute and/or the O_EXCL flag.
    
    This fixes a regression when doing a non-exclusive create of a new file.
    If the FILE_CREATED flag is not set, the atomic_open() command will
    perform full file access permissions checks instead of just checking
    for MAY_OPEN.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 01fd84b566f7..49f52c8f4422 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1455,7 +1455,8 @@ struct nfs_rpc_ops {
 	struct inode * (*open_context) (struct inode *dir,
 				struct nfs_open_context *ctx,
 				int open_flags,
-				struct iattr *iattr);
+				struct iattr *iattr,
+				int *);
 	int (*have_delegation)(struct inode *, fmode_t);
 	int (*return_delegation)(struct inode *);
 	struct nfs_client *(*alloc_client) (const struct nfs_client_initdata *);

commit 2031cd1af143f47dacacbb35efbef22f2fd079e6
Author: Weston Andros Adamson <dros@netapp.com>
Date:   Tue Aug 13 16:37:32 2013 -0400

    nfs4.1: Minimal SP4_MACH_CRED implementation
    
    This is a minimal client side implementation of SP4_MACH_CRED.  It will
    attempt to negotiate SP4_MACH_CRED iff the EXCHANGE_ID is using
    krb5i or krb5p auth.  SP4_MACH_CRED will be used if the server supports the
    minimal operations:
    
     BIND_CONN_TO_SESSION
     EXCHANGE_ID
     CREATE_SESSION
     DESTROY_SESSION
     DESTROY_CLIENTID
    
    This patch only includes the EXCHANGE_ID negotiation code because
    the client will already use the machine cred for these operations.
    
    If the server doesn't support SP4_MACH_CRED or doesn't support the minimal
    operations, the exchange id will be resent with SP4_NONE.
    
    Signed-off-by: Weston Andros Adamson <dros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 7c3956d65b3e..01fd84b566f7 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1107,6 +1107,23 @@ struct pnfs_ds_commit_info {
 	struct pnfs_commit_bucket *buckets;
 };
 
+#define NFS4_OP_MAP_NUM_LONGS \
+	DIV_ROUND_UP(LAST_NFS4_OP, 8 * sizeof(unsigned long))
+#define NFS4_OP_MAP_NUM_WORDS \
+	(NFS4_OP_MAP_NUM_LONGS * sizeof(unsigned long) / sizeof(u32))
+struct nfs4_op_map {
+	union {
+		unsigned long longs[NFS4_OP_MAP_NUM_LONGS];
+		u32 words[NFS4_OP_MAP_NUM_WORDS];
+	} u;
+};
+
+struct nfs41_state_protection {
+	u32 how;
+	struct nfs4_op_map enforce;
+	struct nfs4_op_map allow;
+};
+
 #define NFS4_EXCHANGE_ID_LEN	(48)
 struct nfs41_exchange_id_args {
 	struct nfs_client		*client;
@@ -1114,6 +1131,7 @@ struct nfs41_exchange_id_args {
 	unsigned int 			id_len;
 	char 				id[NFS4_EXCHANGE_ID_LEN];
 	u32				flags;
+	struct nfs41_state_protection	state_protect;
 };
 
 struct nfs41_server_owner {
@@ -1146,6 +1164,7 @@ struct nfs41_exchange_id_res {
 	struct nfs41_server_owner	*server_owner;
 	struct nfs41_server_scope	*server_scope;
 	struct nfs41_impl_id		*impl_id;
+	struct nfs41_state_protection	state_protect;
 };
 
 struct nfs41_create_session_args {

commit ef1820f9be27b6ad158f433ab38002ab8131db4d
Author: NeilBrown <neilb@suse.de>
Date:   Wed Sep 4 17:04:49 2013 +1000

    NFSv4: Don't try to recover NFSv4 locks when they are lost.
    
    When an NFSv4 client loses contact with the server it can lose any
    locks that it holds.
    
    Currently when it reconnects to the server it simply tries to reclaim
    those locks.  This might succeed even though some other client has
    held and released a lock in the mean time.  So the first client might
    think the file is unchanged, but it isn't.  This isn't good.
    
    If, when recovery happens, the locks cannot be claimed because some
    other client still holds the lock, then we get a message in the kernel
    logs, but the client can still write.  So two clients can both think
    they have a lock and can both write at the same time.  This is equally
    not good.
    
    There was a patch a while ago
      http://comments.gmane.org/gmane.linux.nfs/41917
    
    which tried to address some of this, but it didn't seem to go
    anywhere.  That patch would also send a signal to the process.  That
    might be useful but for now this patch just causes writes to fail.
    
    For NFSv4 (unlike v2/v3) there is a strong link between the lock and
    the write request so we can fairly easily fail any IO of the lock is
    gone.  While some applications might not expect this, it is still
    safer than allowing the write to succeed.
    
    Because this is a fairly big change in behaviour a module parameter,
    "recover_locks", is introduced which defaults to true (the current
    behaviour) but can be set to "false" to tell the client not to try to
    recover things that were lost.
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index ddc3e32178c3..7c3956d65b3e 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1419,12 +1419,12 @@ struct nfs_rpc_ops {
 	void	(*read_setup)   (struct nfs_read_data *, struct rpc_message *);
 	void	(*read_pageio_init)(struct nfs_pageio_descriptor *, struct inode *,
 				    const struct nfs_pgio_completion_ops *);
-	void	(*read_rpc_prepare)(struct rpc_task *, struct nfs_read_data *);
+	int	(*read_rpc_prepare)(struct rpc_task *, struct nfs_read_data *);
 	int	(*read_done)  (struct rpc_task *, struct nfs_read_data *);
 	void	(*write_setup)  (struct nfs_write_data *, struct rpc_message *);
 	void	(*write_pageio_init)(struct nfs_pageio_descriptor *, struct inode *, int,
 				     const struct nfs_pgio_completion_ops *);
-	void	(*write_rpc_prepare)(struct rpc_task *, struct nfs_write_data *);
+	int	(*write_rpc_prepare)(struct rpc_task *, struct nfs_write_data *);
 	int	(*write_done)  (struct rpc_task *, struct nfs_write_data *);
 	void	(*commit_setup) (struct nfs_commit_data *, struct rpc_message *);
 	void	(*commit_rpc_prepare)(struct rpc_task *, struct nfs_commit_data *);

commit f8407299f61681e9733f06c7214e81002cb459b3
Author: Andy Adamson <andros@netapp.com>
Date:   Wed Jul 24 11:59:49 2013 -0400

    NFS Remove unused authflavour parameter from init_client
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 8651574a305b..ddc3e32178c3 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1442,7 +1442,7 @@ struct nfs_rpc_ops {
 	struct nfs_client *(*alloc_client) (const struct nfs_client_initdata *);
 	struct nfs_client *
 		(*init_client) (struct nfs_client *, const struct rpc_timeout *,
-				const char *, rpc_authflavor_t);
+				const char *);
 	void	(*free_client) (struct nfs_client *);
 	struct nfs_server *(*create_server)(struct nfs_mount_info *, struct nfs_subversion *);
 	struct nfs_server *(*clone_server)(struct nfs_server *, struct nfs_fh *,

commit 959d921f5eb8878ea16049a7f6e9bcbb6dfbcb88
Merge: f112bb48994e 7017310ad737
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Jun 28 16:29:51 2013 -0400

    Merge branch 'labeled-nfs' into linux-next
    
    * labeled-nfs:
      NFS: Apply v4.1 capabilities to v4.2
      NFS: Add in v4.2 callback operation
      NFS: Make callbacks minor version generic
      Kconfig: Add Kconfig entry for Labeled NFS V4 client
      NFS: Extend NFS xattr handlers to accept the security namespace
      NFS: Client implementation of Labeled-NFS
      NFS: Add label lifecycle management
      NFS:Add labels to client function prototypes
      NFSv4: Extend fattr bitmaps to support all 3 words
      NFSv4: Introduce new label structure
      NFSv4: Add label recommended attribute and NFSv4 flags
      NFSv4.2: Added NFS v4.2 support to the NFS client
      SELinux: Add new labeling type native labels
      LSM: Add flags field to security_sb_set_mnt_opts for in kernel mount data.
      Security: Add Hook to test if the particular xattr is part of a MAC model.
      Security: Add hook to calculate context based on a negative dentry.
      NFS: Add NFSv4.2 protocol constants
    
    Conflicts:
            fs/nfs/nfs4proc.c

commit 1775fd3e805b6a852ef376256967de69284d7962
Author: David Quigley <dpquigl@davequigley.com>
Date:   Wed May 22 12:50:42 2013 -0400

    NFS:Add labels to client function prototypes
    
    After looking at all of the nfsv4 operations the label structure has been added
    to the prototypes of the functions which can transmit label data.
    
    Signed-off-by: Matthew N. Dodd <Matthew.Dodd@sparta.com>
    Signed-off-by: Miguel Rodel Felipe <Rodel_FM@dsi.a-star.edu.sg>
    Signed-off-by: Phua Eu Gene <PHUA_Eu_Gene@dsi.a-star.edu.sg>
    Signed-off-by: Khin Mi Mi Aung <Mi_Mi_AUNG@dsi.a-star.edu.sg>
    Signed-off-by: Steve Dickson <steved@redhat.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index d799b9f86820..ed31ba7a6f9e 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1378,11 +1378,12 @@ struct nfs_rpc_ops {
 	struct dentry *(*try_mount) (int, const char *, struct nfs_mount_info *,
 				     struct nfs_subversion *);
 	int	(*getattr) (struct nfs_server *, struct nfs_fh *,
-			    struct nfs_fattr *);
+			    struct nfs_fattr *, struct nfs4_label *);
 	int	(*setattr) (struct dentry *, struct nfs_fattr *,
 			    struct iattr *);
 	int	(*lookup)  (struct inode *, struct qstr *,
-			    struct nfs_fh *, struct nfs_fattr *);
+			    struct nfs_fh *, struct nfs_fattr *,
+			    struct nfs4_label *);
 	int	(*access)  (struct inode *, struct nfs_access_entry *);
 	int	(*readlink)(struct inode *, struct page *, unsigned int,
 			    unsigned int);

commit e058f70b8070608fedfd3e39c2ead935beecb552
Author: Steve Dickson <steved@redhat.com>
Date:   Wed May 22 12:50:40 2013 -0400

    NFSv4: Introduce new label structure
    
    In order to mimic the way that NFSv4 ACLs are implemented we have created a
    structure to be used to pass label data up and down the call chain. This patch
    adds the new structure and new members to the required NFSv4 call structures.
    
    Signed-off-by: Matthew N. Dodd <Matthew.Dodd@sparta.com>
    Signed-off-by: Miguel Rodel Felipe <Rodel_FM@dsi.a-star.edu.sg>
    Signed-off-by: Phua Eu Gene <PHUA_Eu_Gene@dsi.a-star.edu.sg>
    Signed-off-by: Khin Mi Mi Aung <Mi_Mi_AUNG@dsi.a-star.edu.sg>
    Signed-off-by: Steve Dickson <steved@redhat.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index bfdf6e042838..d799b9f86820 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -349,6 +349,7 @@ struct nfs_openargs {
 	const u32 *		open_bitmap;
 	__u32			claim;
 	enum createmode4	createmode;
+	const struct nfs4_label *label;
 };
 
 struct nfs_openres {
@@ -358,6 +359,7 @@ struct nfs_openres {
 	struct nfs4_change_info	cinfo;
 	__u32                   rflags;
 	struct nfs_fattr *      f_attr;
+	struct nfs4_label	*f_label;
 	struct nfs_seqid *	seqid;
 	const struct nfs_server *server;
 	fmode_t			delegation_type;
@@ -600,6 +602,7 @@ struct nfs_entry {
 	int			eof;
 	struct nfs_fh *		fh;
 	struct nfs_fattr *	fattr;
+	struct nfs4_label  *label;
 	unsigned char		d_type;
 	struct nfs_server *	server;
 };
@@ -632,6 +635,7 @@ struct nfs_setattrargs {
 	struct iattr *                  iap;
 	const struct nfs_server *	server; /* Needed for name mapping */
 	const u32 *			bitmask;
+	const struct nfs4_label		*label;
 };
 
 struct nfs_setaclargs {
@@ -667,6 +671,7 @@ struct nfs_getaclres {
 struct nfs_setattrres {
 	struct nfs4_sequence_res	seq_res;
 	struct nfs_fattr *              fattr;
+	struct nfs4_label		*label;
 	const struct nfs_server *	server;
 };
 
@@ -864,6 +869,7 @@ struct nfs4_create_arg {
 	const struct iattr *		attrs;
 	const struct nfs_fh *		dir_fh;
 	const u32 *			bitmask;
+	const struct nfs4_label		*label;
 };
 
 struct nfs4_create_res {
@@ -871,6 +877,7 @@ struct nfs4_create_res {
 	const struct nfs_server *	server;
 	struct nfs_fh *			fh;
 	struct nfs_fattr *		fattr;
+	struct nfs4_label		*label;
 	struct nfs4_change_info		dir_cinfo;
 };
 
@@ -895,6 +902,7 @@ struct nfs4_getattr_res {
 	struct nfs4_sequence_res	seq_res;
 	const struct nfs_server *	server;
 	struct nfs_fattr *		fattr;
+	struct nfs4_label		*label;
 };
 
 struct nfs4_link_arg {
@@ -909,6 +917,7 @@ struct nfs4_link_res {
 	struct nfs4_sequence_res	seq_res;
 	const struct nfs_server *	server;
 	struct nfs_fattr *		fattr;
+	struct nfs4_label		*label;
 	struct nfs4_change_info		cinfo;
 	struct nfs_fattr *		dir_attr;
 };
@@ -926,6 +935,7 @@ struct nfs4_lookup_res {
 	const struct nfs_server *	server;
 	struct nfs_fattr *		fattr;
 	struct nfs_fh *			fh;
+	struct nfs4_label		*label;
 };
 
 struct nfs4_lookup_root_arg {

commit e64a4210f69010d0ff349d5889b50fed51f8bdd0
Author: David Quigley <dpquigl@davequigley.com>
Date:   Wed May 22 12:50:39 2013 -0400

    NFSv4: Add label recommended attribute and NFSv4 flags
    
    This patch adds several new flags to allow the NFS client and server to
    determine if this attribute is supported and if it is being sent over the wire.
    
    Signed-off-by: Matthew N. Dodd <Matthew.Dodd@sparta.com>
    Signed-off-by: Miguel Rodel Felipe <Rodel_FM@dsi.a-star.edu.sg>
    Signed-off-by: Phua Eu Gene <PHUA_Eu_Gene@dsi.a-star.edu.sg>
    Signed-off-by: Khin Mi Mi Aung <Mi_Mi_AUNG@dsi.a-star.edu.sg>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 104b62f23ee0..bfdf6e042838 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -101,6 +101,7 @@ struct nfs_fattr {
 #define NFS_ATTR_FATTR_MOUNTED_ON_FILEID (1U << 22)
 #define NFS_ATTR_FATTR_OWNER_NAME	(1U << 23)
 #define NFS_ATTR_FATTR_GROUP_NAME	(1U << 24)
+#define NFS_ATTR_FATTR_V4_SECURITY_LABEL (1U << 25)
 
 #define NFS_ATTR_FATTR (NFS_ATTR_FATTR_TYPE \
 		| NFS_ATTR_FATTR_MODE \
@@ -120,7 +121,8 @@ struct nfs_fattr {
 #define NFS_ATTR_FATTR_V3 (NFS_ATTR_FATTR \
 		| NFS_ATTR_FATTR_SPACE_USED)
 #define NFS_ATTR_FATTR_V4 (NFS_ATTR_FATTR \
-		| NFS_ATTR_FATTR_SPACE_USED)
+		| NFS_ATTR_FATTR_SPACE_USED \
+		| NFS_ATTR_FATTR_V4_SECURITY_LABEL)
 
 /*
  * Info on the file system

commit 6ab59344d9796eaf1312c12cfa8ad08328d50fde
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon May 20 10:49:34 2013 -0400

    NFSv4.1: Ensure that layoutget is called using the layout credential
    
    Ensure that we use the same credential for layoutget, layoutcommit and
    layoutreturn.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 104b62f23ee0..32c95d64e3aa 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -246,6 +246,7 @@ struct nfs4_layoutget_res {
 struct nfs4_layoutget {
 	struct nfs4_layoutget_args args;
 	struct nfs4_layoutget_res res;
+	struct rpc_cred *cred;
 	gfp_t gfp_flags;
 };
 

commit 7c1d5fae4a87d3cf3e9ffd68bcdbaf6529013009
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri May 3 14:40:01 2013 -0400

    NFSv4: Convert nfs41_free_stateid to use an asynchronous RPC call
    
    The main reason for doing this is will be to allow for an asynchronous
    RPC mode that we can use for freeing lock stateids as per section
    8.2.4 of RFC5661.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 766c5bc9d441..104b62f23ee0 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1176,7 +1176,7 @@ struct nfs41_test_stateid_res {
 
 struct nfs41_free_stateid_args {
 	struct nfs4_sequence_args	seq_args;
-	nfs4_stateid			*stateid;
+	nfs4_stateid			stateid;
 };
 
 struct nfs41_free_stateid_res {

commit bd1d421abcaae1b84ba377ea4c33bba31d654199
Merge: bdeca1b76cd5 79d852bf5e76
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Apr 23 15:40:40 2013 -0400

    Merge branch 'rpcsec_gss-from_cel' into linux-next
    
    * rpcsec_gss-from_cel: (21 commits)
      NFS: Retry SETCLIENTID with AUTH_SYS instead of AUTH_NONE
      NFSv4: Don't clear the machine cred when client establish returns EACCES
      NFSv4: Fix issues in nfs4_discover_server_trunking
      NFSv4: Fix the fallback to AUTH_NULL if krb5i is not available
      NFS: Use server-recommended security flavor by default (NFSv3)
      SUNRPC: Don't recognize RPC_AUTH_MAXFLAVOR
      NFS: Use "krb5i" to establish NFSv4 state whenever possible
      NFS: Try AUTH_UNIX when PUTROOTFH gets NFS4ERR_WRONGSEC
      NFS: Use static list of security flavors during root FH lookup recovery
      NFS: Avoid PUTROOTFH when managing leases
      NFS: Clean up nfs4_proc_get_rootfh
      NFS: Handle missing rpc.gssd when looking up root FH
      SUNRPC: Remove EXPORT_SYMBOL_GPL() from GSS mech switch
      SUNRPC: Make gss_mech_get() static
      SUNRPC: Refactor nfsd4_do_encode_secinfo()
      SUNRPC: Consider qop when looking up pseudoflavors
      SUNRPC: Load GSS kernel module by OID
      SUNRPC: Introduce rpcauth_get_pseudoflavor()
      SUNRPC: Define rpcsec_gss_info structure
      NFS: Remove unneeded forward declaration
      ...

commit 549b19cc9f31e8fdda317625d564bac0052a3328
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Apr 16 18:42:34 2013 -0400

    NFSv4: Record the OPEN create mode used in the nfs4_opendata structure
    
    If we're doing NFSv4.1 against a server that has persistent sessions,
    then we should not need to call SETATTR in order to reset the file
    attributes immediately after doing an exclusive create.
    
    Note that since the create mode depends on the type of session that
    has been negotiated with the server, we should not choose the
    mode until after we've got a session slot.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 90a4aa190b43..bdc100f66dfb 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -349,6 +349,7 @@ struct nfs_openargs {
 	const u32 *		bitmask;
 	const u32 *		open_bitmap;
 	__u32			claim;
+	enum createmode4	createmode;
 };
 
 struct nfs_openres {

commit fb15b26f8ba3ff629a052faf3f4a4744585ca2dc
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Sat Mar 16 15:54:34 2013 -0400

    SUNRPC: Define rpcsec_gss_info structure
    
    The NFSv4 SECINFO procedure returns a list of security flavors.  Any
    GSS flavor also has a GSS tuple containing an OID, a quality-of-
    protection value, and a service value, which specifies a particular
    GSS pseudoflavor.
    
    For simplicity and efficiency, I'd like to return each GSS tuple
    from the NFSv4 SECINFO XDR decoder and pass it straight into the RPC
    client.
    
    Define a data structure that is visible to both the NFS client and
    the RPC client.  Take structure and field names from the relevant
    standards to avoid confusion.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index c1ca1f3f4935..b759467741eb 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1049,25 +1049,14 @@ struct nfs4_fs_locations_res {
 	struct nfs4_fs_locations       *fs_locations;
 };
 
-struct nfs4_secinfo_oid {
-	unsigned int len;
-	char data[GSS_OID_MAX_LEN];
-};
-
-struct nfs4_secinfo_gss {
-	struct nfs4_secinfo_oid sec_oid4;
-	unsigned int qop4;
-	unsigned int service;
-};
-
-struct nfs4_secinfo_flavor {
-	unsigned int 		flavor;
-	struct nfs4_secinfo_gss	gss;
+struct nfs4_secinfo4 {
+	u32			flavor;
+	struct rpcsec_gss_info	flavor_info;
 };
 
 struct nfs4_secinfo_flavors {
-	unsigned int num_flavors;
-	struct nfs4_secinfo_flavor flavors[0];
+	unsigned int		num_flavors;
+	struct nfs4_secinfo4	flavors[0];
 };
 
 struct nfs4_secinfo_arg {

commit 72f4dc117b57e05120aaac6e218b8abc09a5c350
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Sat Mar 16 15:54:25 2013 -0400

    NFS: Remove unneeded forward declaration
    
    I've built with NFSv4 enabled and disabled.  This forward
    declaration does not seem to be required.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 90a4aa190b43..c1ca1f3f4935 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -14,9 +14,6 @@
 #define NFS_DEF_FILE_IO_SIZE	(4096U)
 #define NFS_MIN_FILE_IO_SIZE	(1024U)
 
-/* Forward declaration for NFS v3 */
-struct nfs4_secinfo_flavors;
-
 struct nfs4_string {
 	unsigned int len;
 	char *data;

commit 9b20614988199fb03580b335a28250922e902098
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sun Mar 17 15:52:00 2013 -0400

    NFSv4: The stateid must remain the same for replayed RPC calls
    
    If we replay a READ or WRITE call, we should not be changing the
    stateid. Currently, we may end up doing so, because the stateid
    is only selected at xdr encode time.
    
    This patch ensures that we select the stateid after we get an NFSv4.1
    session slot, and that we keep that same stateid across retries.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 4b993d358dad..90a4aa190b43 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -486,6 +486,7 @@ struct nfs_readargs {
 	struct nfs_fh *		fh;
 	struct nfs_open_context *context;
 	struct nfs_lock_context *lock_context;
+	nfs4_stateid		stateid;
 	__u64			offset;
 	__u32			count;
 	unsigned int		pgbase;
@@ -507,6 +508,7 @@ struct nfs_writeargs {
 	struct nfs_fh *		fh;
 	struct nfs_open_context *context;
 	struct nfs_lock_context *lock_context;
+	nfs4_stateid		stateid;
 	__u64			offset;
 	__u32			count;
 	enum nfs3_stable_how	stable;

commit 8d05b3771da8775799673212b57d62f57c70d68a
Merge: b695188dd391 512e4b291c0e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 2 16:46:07 2013 -0800

    Merge tag 'nfs-for-3.9-2' of git://git.linux-nfs.org/projects/trondmy/linux-nfs
    
    Pull NFS client bugfixes from Trond Myklebust:
     "We've just concluded another Connectathon interoperability testing
      week, and so here are the fixes for the bugs that were discovered:
    
       - Don't allow NFS silly-renamed files to be deleted
       - Don't start the retransmission timer when out of socket space
       - Fix a couple of pnfs-related Oopses.
       - Fix one more NFSv4 state recovery deadlock
       - Don't loop forever when LAYOUTGET returns NFS4ERR_LAYOUTTRYLATER"
    
    * tag 'nfs-for-3.9-2' of git://git.linux-nfs.org/projects/trondmy/linux-nfs:
      SUNRPC: One line comment fix
      NFSv4.1: LAYOUTGET EDELAY loops timeout to the MDS
      SUNRPC: add call to get configured timeout
      PNFS: set the default DS timeout to 60 seconds
      NFSv4: Fix another open/open_recovery deadlock
      nfs: don't allow nfs_find_actor to match inodes of the wrong type
      NFSv4.1: Hold reference to layout hdr in layoutget
      pnfs: fix resend_to_mds for directio
      SUNRPC: Don't start the retransmission timer when out of socket space
      NFS: Don't allow NFS silly-renamed files to be deleted, no signal

commit 3000512137602b84d1ad5fd89d62984993a19bb6
Author: Weston Andros Adamson <dros@netapp.com>
Date:   Thu Feb 28 20:30:10 2013 -0500

    NFSv4.1: LAYOUTGET EDELAY loops timeout to the MDS
    
    The client will currently try LAYOUTGETs forever if a server is returning
    NFS4ERR_LAYOUTTRYLATER or NFS4ERR_RECALLCONFLICT - even if the client no
    longer needs the layout (ie process killed, unmounted).
    
    This patch uses the DS timeout value (module parameter 'dataserver_timeo'
    via rpc layer) to set an upper limit of how long the client tries LATOUTGETs
    in this situation.  Once the timeout is reached, IO is redirected to the MDS.
    
    This also changes how the client checks if a layout is on the clp list
    to avoid a double list_add.
    
    Signed-off-by: Weston Andros Adamson <dros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 29adb12c7ecf..2250cab6fc4b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -233,6 +233,7 @@ struct nfs4_layoutget_args {
 	struct inode *inode;
 	struct nfs_open_context *ctx;
 	nfs4_stateid stateid;
+	unsigned long timestamp;
 	struct nfs4_layoutdriver_data layout;
 };
 

commit 54f834cd5501fb5fc801e4719a3ad0c894a3af2c
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Feb 1 14:16:29 2013 -0800

    nfs: Convert struct nfs_fattr to Use kuid_t and kgid_t
    
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 29adb12c7ecf..13441ddac33d 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -48,8 +48,8 @@ struct nfs_fattr {
 	unsigned int		valid;		/* which fields are valid */
 	umode_t			mode;
 	__u32			nlink;
-	__u32			uid;
-	__u32			gid;
+	kuid_t			uid;
+	kgid_t			gid;
 	dev_t			rdev;
 	__u64			size;
 	union {

commit 8e63b6a8adabb0551124c3b78f7f5f36912c3728
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sat Dec 15 15:21:52 2012 -0500

    NFSv4.1: Move the RPC timestamp out of the slot.
    
    Shave a few bytes off the slot table size by moving the RPC timestamp
    into the sequence results.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index a55abd499c21..29adb12c7ecf 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -194,6 +194,7 @@ struct nfs4_sequence_args {
 
 struct nfs4_sequence_res {
 	struct nfs4_slot	*sr_slot;	/* slot used to send request */
+	unsigned long		sr_timestamp;
 	int			sr_status;	/* sequence operation status */
 	u32			sr_status_flags;
 	u32			sr_highest_slotid;

commit 62ae082d883d167cdaa7895cf2972d85e178228a
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Nov 29 17:10:01 2012 -0500

    NFSv4: Reorder the XDR structures to put sequence at the top, not bottom
    
    Pre-condition for optimising the slot allocation and reintroducing FIFO
    behaviour.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index baa673edb597..a55abd499c21 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -205,8 +205,8 @@ struct nfs4_get_lease_time_args {
 };
 
 struct nfs4_get_lease_time_res {
-	struct nfs_fsinfo	       *lr_fsinfo;
 	struct nfs4_sequence_res	lr_seq_res;
+	struct nfs_fsinfo	       *lr_fsinfo;
 };
 
 #define PNFS_LAYOUT_MAXSIZE 4096
@@ -224,23 +224,23 @@ struct pnfs_layout_range {
 };
 
 struct nfs4_layoutget_args {
+	struct nfs4_sequence_args seq_args;
 	__u32 type;
 	struct pnfs_layout_range range;
 	__u64 minlength;
 	__u32 maxcount;
 	struct inode *inode;
 	struct nfs_open_context *ctx;
-	struct nfs4_sequence_args seq_args;
 	nfs4_stateid stateid;
 	struct nfs4_layoutdriver_data layout;
 };
 
 struct nfs4_layoutget_res {
+	struct nfs4_sequence_res seq_res;
 	__u32 return_on_close;
 	struct pnfs_layout_range range;
 	__u32 type;
 	nfs4_stateid stateid;
-	struct nfs4_sequence_res seq_res;
 	struct nfs4_layoutdriver_data *layoutp;
 };
 
@@ -251,38 +251,38 @@ struct nfs4_layoutget {
 };
 
 struct nfs4_getdevicelist_args {
+	struct nfs4_sequence_args seq_args;
 	const struct nfs_fh *fh;
 	u32 layoutclass;
-	struct nfs4_sequence_args seq_args;
 };
 
 struct nfs4_getdevicelist_res {
-	struct pnfs_devicelist *devlist;
 	struct nfs4_sequence_res seq_res;
+	struct pnfs_devicelist *devlist;
 };
 
 struct nfs4_getdeviceinfo_args {
-	struct pnfs_device *pdev;
 	struct nfs4_sequence_args seq_args;
+	struct pnfs_device *pdev;
 };
 
 struct nfs4_getdeviceinfo_res {
-	struct pnfs_device *pdev;
 	struct nfs4_sequence_res seq_res;
+	struct pnfs_device *pdev;
 };
 
 struct nfs4_layoutcommit_args {
+	struct nfs4_sequence_args seq_args;
 	nfs4_stateid stateid;
 	__u64 lastbytewritten;
 	struct inode *inode;
 	const u32 *bitmask;
-	struct nfs4_sequence_args seq_args;
 };
 
 struct nfs4_layoutcommit_res {
+	struct nfs4_sequence_res seq_res;
 	struct nfs_fattr *fattr;
 	const struct nfs_server *server;
-	struct nfs4_sequence_res seq_res;
 	int status;
 };
 
@@ -296,11 +296,11 @@ struct nfs4_layoutcommit_data {
 };
 
 struct nfs4_layoutreturn_args {
+	struct nfs4_sequence_args seq_args;
 	struct pnfs_layout_hdr *layout;
 	struct inode *inode;
 	nfs4_stateid stateid;
 	__u32   layout_type;
-	struct nfs4_sequence_args seq_args;
 };
 
 struct nfs4_layoutreturn_res {
@@ -326,6 +326,7 @@ struct stateowner_id {
  * Arguments to the open call.
  */
 struct nfs_openargs {
+	struct nfs4_sequence_args	seq_args;
 	const struct nfs_fh *	fh;
 	struct nfs_seqid *	seqid;
 	int			open_flags;
@@ -346,10 +347,10 @@ struct nfs_openargs {
 	const u32 *		bitmask;
 	const u32 *		open_bitmap;
 	__u32			claim;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs_openres {
+	struct nfs4_sequence_res	seq_res;
 	nfs4_stateid            stateid;
 	struct nfs_fh           fh;
 	struct nfs4_change_info	cinfo;
@@ -364,7 +365,6 @@ struct nfs_openres {
 	__u32			attrset[NFS4_BITMAP_SIZE];
 	struct nfs4_string	*owner;
 	struct nfs4_string	*group_owner;
-	struct nfs4_sequence_res	seq_res;
 	__u32			access_request;
 	__u32			access_supported;
 	__u32			access_result;
@@ -388,20 +388,20 @@ struct nfs_open_confirmres {
  * Arguments to the close call.
  */
 struct nfs_closeargs {
+	struct nfs4_sequence_args	seq_args;
 	struct nfs_fh *         fh;
 	nfs4_stateid *		stateid;
 	struct nfs_seqid *	seqid;
 	fmode_t			fmode;
 	const u32 *		bitmask;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs_closeres {
+	struct nfs4_sequence_res	seq_res;
 	nfs4_stateid            stateid;
 	struct nfs_fattr *	fattr;
 	struct nfs_seqid *	seqid;
 	const struct nfs_server *server;
-	struct nfs4_sequence_res	seq_res;
 };
 /*
  *  * Arguments to the lock,lockt, and locku call.
@@ -413,6 +413,7 @@ struct nfs_lowner {
 };
 
 struct nfs_lock_args {
+	struct nfs4_sequence_args	seq_args;
 	struct nfs_fh *		fh;
 	struct file_lock *	fl;
 	struct nfs_seqid *	lock_seqid;
@@ -423,40 +424,39 @@ struct nfs_lock_args {
 	unsigned char		block : 1;
 	unsigned char		reclaim : 1;
 	unsigned char		new_lock_owner : 1;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs_lock_res {
+	struct nfs4_sequence_res	seq_res;
 	nfs4_stateid		stateid;
 	struct nfs_seqid *	lock_seqid;
 	struct nfs_seqid *	open_seqid;
-	struct nfs4_sequence_res	seq_res;
 };
 
 struct nfs_locku_args {
+	struct nfs4_sequence_args	seq_args;
 	struct nfs_fh *		fh;
 	struct file_lock *	fl;
 	struct nfs_seqid *	seqid;
 	nfs4_stateid *		stateid;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs_locku_res {
+	struct nfs4_sequence_res	seq_res;
 	nfs4_stateid		stateid;
 	struct nfs_seqid *	seqid;
-	struct nfs4_sequence_res	seq_res;
 };
 
 struct nfs_lockt_args {
+	struct nfs4_sequence_args	seq_args;
 	struct nfs_fh *		fh;
 	struct file_lock *	fl;
 	struct nfs_lowner	lock_owner;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs_lockt_res {
-	struct file_lock *	denied; /* LOCK, LOCKT failed */
 	struct nfs4_sequence_res	seq_res;
+	struct file_lock *	denied; /* LOCK, LOCKT failed */
 };
 
 struct nfs_release_lockowner_args {
@@ -464,22 +464,23 @@ struct nfs_release_lockowner_args {
 };
 
 struct nfs4_delegreturnargs {
+	struct nfs4_sequence_args	seq_args;
 	const struct nfs_fh *fhandle;
 	const nfs4_stateid *stateid;
 	const u32 * bitmask;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_delegreturnres {
+	struct nfs4_sequence_res	seq_res;
 	struct nfs_fattr * fattr;
 	const struct nfs_server *server;
-	struct nfs4_sequence_res	seq_res;
 };
 
 /*
  * Arguments to the read call.
  */
 struct nfs_readargs {
+	struct nfs4_sequence_args	seq_args;
 	struct nfs_fh *		fh;
 	struct nfs_open_context *context;
 	struct nfs_lock_context *lock_context;
@@ -487,20 +488,20 @@ struct nfs_readargs {
 	__u32			count;
 	unsigned int		pgbase;
 	struct page **		pages;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs_readres {
+	struct nfs4_sequence_res	seq_res;
 	struct nfs_fattr *	fattr;
 	__u32			count;
 	int                     eof;
-	struct nfs4_sequence_res	seq_res;
 };
 
 /*
  * Arguments to the write call.
  */
 struct nfs_writeargs {
+	struct nfs4_sequence_args	seq_args;
 	struct nfs_fh *		fh;
 	struct nfs_open_context *context;
 	struct nfs_lock_context *lock_context;
@@ -510,7 +511,6 @@ struct nfs_writeargs {
 	unsigned int		pgbase;
 	struct page **		pages;
 	const u32 *		bitmask;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs_write_verifier {
@@ -523,65 +523,65 @@ struct nfs_writeverf {
 };
 
 struct nfs_writeres {
+	struct nfs4_sequence_res	seq_res;
 	struct nfs_fattr *	fattr;
 	struct nfs_writeverf *	verf;
 	__u32			count;
 	const struct nfs_server *server;
-	struct nfs4_sequence_res	seq_res;
 };
 
 /*
  * Arguments to the commit call.
  */
 struct nfs_commitargs {
+	struct nfs4_sequence_args	seq_args;
 	struct nfs_fh		*fh;
 	__u64			offset;
 	__u32			count;
 	const u32		*bitmask;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs_commitres {
+	struct nfs4_sequence_res	seq_res;
 	struct nfs_fattr	*fattr;
 	struct nfs_writeverf	*verf;
 	const struct nfs_server *server;
-	struct nfs4_sequence_res	seq_res;
 };
 
 /*
  * Common arguments to the unlink call
  */
 struct nfs_removeargs {
+	struct nfs4_sequence_args	seq_args;
 	const struct nfs_fh	*fh;
 	struct qstr		name;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs_removeres {
+	struct nfs4_sequence_res 	seq_res;
 	const struct nfs_server *server;
 	struct nfs_fattr	*dir_attr;
 	struct nfs4_change_info	cinfo;
-	struct nfs4_sequence_res 	seq_res;
 };
 
 /*
  * Common arguments to the rename call
  */
 struct nfs_renameargs {
+	struct nfs4_sequence_args	seq_args;
 	const struct nfs_fh		*old_dir;
 	const struct nfs_fh		*new_dir;
 	const struct qstr		*old_name;
 	const struct qstr		*new_name;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs_renameres {
+	struct nfs4_sequence_res	seq_res;
 	const struct nfs_server		*server;
 	struct nfs4_change_info		old_cinfo;
 	struct nfs_fattr		*old_fattr;
 	struct nfs4_change_info		new_cinfo;
 	struct nfs_fattr		*new_fattr;
-	struct nfs4_sequence_res	seq_res;
 };
 
 /*
@@ -622,20 +622,20 @@ struct nfs_createargs {
 };
 
 struct nfs_setattrargs {
+	struct nfs4_sequence_args 	seq_args;
 	struct nfs_fh *                 fh;
 	nfs4_stateid                    stateid;
 	struct iattr *                  iap;
 	const struct nfs_server *	server; /* Needed for name mapping */
 	const u32 *			bitmask;
-	struct nfs4_sequence_args 	seq_args;
 };
 
 struct nfs_setaclargs {
+	struct nfs4_sequence_args	seq_args;
 	struct nfs_fh *			fh;
 	size_t				acl_len;
 	unsigned int			acl_pgbase;
 	struct page **			acl_pages;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs_setaclres {
@@ -643,27 +643,27 @@ struct nfs_setaclres {
 };
 
 struct nfs_getaclargs {
+	struct nfs4_sequence_args 	seq_args;
 	struct nfs_fh *			fh;
 	size_t				acl_len;
 	unsigned int			acl_pgbase;
 	struct page **			acl_pages;
-	struct nfs4_sequence_args 	seq_args;
 };
 
 /* getxattr ACL interface flags */
 #define NFS4_ACL_TRUNC		0x0001	/* ACL was truncated */
 struct nfs_getaclres {
+	struct nfs4_sequence_res	seq_res;
 	size_t				acl_len;
 	size_t				acl_data_offset;
 	int				acl_flags;
 	struct page *			acl_scratch;
-	struct nfs4_sequence_res	seq_res;
 };
 
 struct nfs_setattrres {
+	struct nfs4_sequence_res	seq_res;
 	struct nfs_fattr *              fattr;
 	const struct nfs_server *	server;
-	struct nfs4_sequence_res	seq_res;
 };
 
 struct nfs_linkargs {
@@ -828,21 +828,22 @@ struct nfs3_getaclres {
 typedef u64 clientid4;
 
 struct nfs4_accessargs {
+	struct nfs4_sequence_args	seq_args;
 	const struct nfs_fh *		fh;
 	const u32 *			bitmask;
 	u32				access;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_accessres {
+	struct nfs4_sequence_res	seq_res;
 	const struct nfs_server *	server;
 	struct nfs_fattr *		fattr;
 	u32				supported;
 	u32				access;
-	struct nfs4_sequence_res	seq_res;
 };
 
 struct nfs4_create_arg {
+	struct nfs4_sequence_args 	seq_args;
 	u32				ftype;
 	union {
 		struct {
@@ -859,88 +860,88 @@ struct nfs4_create_arg {
 	const struct iattr *		attrs;
 	const struct nfs_fh *		dir_fh;
 	const u32 *			bitmask;
-	struct nfs4_sequence_args 	seq_args;
 };
 
 struct nfs4_create_res {
+	struct nfs4_sequence_res	seq_res;
 	const struct nfs_server *	server;
 	struct nfs_fh *			fh;
 	struct nfs_fattr *		fattr;
 	struct nfs4_change_info		dir_cinfo;
-	struct nfs4_sequence_res	seq_res;
 };
 
 struct nfs4_fsinfo_arg {
+	struct nfs4_sequence_args	seq_args;
 	const struct nfs_fh *		fh;
 	const u32 *			bitmask;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_fsinfo_res {
-	struct nfs_fsinfo	       *fsinfo;
 	struct nfs4_sequence_res	seq_res;
+	struct nfs_fsinfo	       *fsinfo;
 };
 
 struct nfs4_getattr_arg {
+	struct nfs4_sequence_args	seq_args;
 	const struct nfs_fh *		fh;
 	const u32 *			bitmask;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_getattr_res {
+	struct nfs4_sequence_res	seq_res;
 	const struct nfs_server *	server;
 	struct nfs_fattr *		fattr;
-	struct nfs4_sequence_res	seq_res;
 };
 
 struct nfs4_link_arg {
+	struct nfs4_sequence_args 	seq_args;
 	const struct nfs_fh *		fh;
 	const struct nfs_fh *		dir_fh;
 	const struct qstr *		name;
 	const u32 *			bitmask;
-	struct nfs4_sequence_args 	seq_args;
 };
 
 struct nfs4_link_res {
+	struct nfs4_sequence_res	seq_res;
 	const struct nfs_server *	server;
 	struct nfs_fattr *		fattr;
 	struct nfs4_change_info		cinfo;
 	struct nfs_fattr *		dir_attr;
-	struct nfs4_sequence_res	seq_res;
 };
 
 
 struct nfs4_lookup_arg {
+	struct nfs4_sequence_args	seq_args;
 	const struct nfs_fh *		dir_fh;
 	const struct qstr *		name;
 	const u32 *			bitmask;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_lookup_res {
+	struct nfs4_sequence_res	seq_res;
 	const struct nfs_server *	server;
 	struct nfs_fattr *		fattr;
 	struct nfs_fh *			fh;
-	struct nfs4_sequence_res	seq_res;
 };
 
 struct nfs4_lookup_root_arg {
-	const u32 *			bitmask;
 	struct nfs4_sequence_args	seq_args;
+	const u32 *			bitmask;
 };
 
 struct nfs4_pathconf_arg {
+	struct nfs4_sequence_args	seq_args;
 	const struct nfs_fh *		fh;
 	const u32 *			bitmask;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_pathconf_res {
-	struct nfs_pathconf	       *pathconf;
 	struct nfs4_sequence_res	seq_res;
+	struct nfs_pathconf	       *pathconf;
 };
 
 struct nfs4_readdir_arg {
+	struct nfs4_sequence_args	seq_args;
 	const struct nfs_fh *		fh;
 	u64				cookie;
 	nfs4_verifier			verifier;
@@ -949,21 +950,20 @@ struct nfs4_readdir_arg {
 	unsigned int			pgbase;	/* zero-copy data */
 	const u32 *			bitmask;
 	int				plus;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_readdir_res {
+	struct nfs4_sequence_res	seq_res;
 	nfs4_verifier			verifier;
 	unsigned int			pgbase;
-	struct nfs4_sequence_res	seq_res;
 };
 
 struct nfs4_readlink {
+	struct nfs4_sequence_args	seq_args;
 	const struct nfs_fh *		fh;
 	unsigned int			pgbase;
 	unsigned int			pglen;   /* zero-copy data */
 	struct page **			pages;   /* zero-copy data */
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_readlink_res {
@@ -989,28 +989,28 @@ struct nfs4_setclientid_res {
 };
 
 struct nfs4_statfs_arg {
+	struct nfs4_sequence_args	seq_args;
 	const struct nfs_fh *		fh;
 	const u32 *			bitmask;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_statfs_res {
-	struct nfs_fsstat	       *fsstat;
 	struct nfs4_sequence_res	seq_res;
+	struct nfs_fsstat	       *fsstat;
 };
 
 struct nfs4_server_caps_arg {
-	struct nfs_fh		       *fhandle;
 	struct nfs4_sequence_args	seq_args;
+	struct nfs_fh		       *fhandle;
 };
 
 struct nfs4_server_caps_res {
+	struct nfs4_sequence_res	seq_res;
 	u32				attr_bitmask[3];
 	u32				acl_bitmask;
 	u32				has_links;
 	u32				has_symlinks;
 	u32				fh_expire_type;
-	struct nfs4_sequence_res	seq_res;
 };
 
 #define NFS4_PATHNAME_MAXCOMPONENTS 512
@@ -1036,16 +1036,16 @@ struct nfs4_fs_locations {
 };
 
 struct nfs4_fs_locations_arg {
+	struct nfs4_sequence_args	seq_args;
 	const struct nfs_fh *dir_fh;
 	const struct qstr *name;
 	struct page *page;
 	const u32 *bitmask;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_fs_locations_res {
-	struct nfs4_fs_locations       *fs_locations;
 	struct nfs4_sequence_res	seq_res;
+	struct nfs4_fs_locations       *fs_locations;
 };
 
 struct nfs4_secinfo_oid {
@@ -1070,14 +1070,14 @@ struct nfs4_secinfo_flavors {
 };
 
 struct nfs4_secinfo_arg {
+	struct nfs4_sequence_args	seq_args;
 	const struct nfs_fh		*dir_fh;
 	const struct qstr		*name;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_secinfo_res {
-	struct nfs4_secinfo_flavors	*flavors;
 	struct nfs4_sequence_res	seq_res;
+	struct nfs4_secinfo_flavors	*flavors;
 };
 
 #endif /* CONFIG_NFS_V4 */
@@ -1157,9 +1157,9 @@ struct nfs41_create_session_res {
 };
 
 struct nfs41_reclaim_complete_args {
+	struct nfs4_sequence_args	seq_args;
 	/* In the future extend to include curr_fh for use with migration */
 	unsigned char			one_fs:1;
-	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs41_reclaim_complete_res {
@@ -1169,28 +1169,28 @@ struct nfs41_reclaim_complete_res {
 #define SECINFO_STYLE_CURRENT_FH 0
 #define SECINFO_STYLE_PARENT 1
 struct nfs41_secinfo_no_name_args {
-	int				style;
 	struct nfs4_sequence_args	seq_args;
+	int				style;
 };
 
 struct nfs41_test_stateid_args {
-	nfs4_stateid			*stateid;
 	struct nfs4_sequence_args	seq_args;
+	nfs4_stateid			*stateid;
 };
 
 struct nfs41_test_stateid_res {
-	unsigned int			status;
 	struct nfs4_sequence_res	seq_res;
+	unsigned int			status;
 };
 
 struct nfs41_free_stateid_args {
-	nfs4_stateid			*stateid;
 	struct nfs4_sequence_args	seq_args;
+	nfs4_stateid			*stateid;
 };
 
 struct nfs41_free_stateid_res {
-	unsigned int			status;
 	struct nfs4_sequence_res	seq_res;
+	unsigned int			status;
 };
 
 #else

commit 8fe72bac8de784c4059b41a7dd6bb0151a3ae898
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Oct 29 19:02:20 2012 -0400

    NFSv4: Clean up handling of privileged operations
    
    Privileged rpc calls are those that are run by the state recovery thread,
    in cases where we're trying to recover the system after a server reboot
    or a network partition. In those cases, we want to fence off all other
    rpc calls (see nfs4_begin_drain_session()) so that they don't end up
    using stateids or clientids that are in the process of being recovered.
    
    Prior to this patch, we had to set up special callback functions in
    order to declare an rpc call as being privileged.
    By adding a new field to the sequence arguments, this patch simplifies
    things considerably, and allows us to declare the rpc call as privileged
    before it is run.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 2076149db1a4..baa673edb597 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -188,7 +188,8 @@ struct nfs4_channel_attrs {
 struct nfs4_slot;
 struct nfs4_sequence_args {
 	struct nfs4_slot	*sa_slot;
-	u8			sa_cache_this;
+	u8			sa_cache_this : 1,
+				sa_privileged : 1;
 };
 
 struct nfs4_sequence_res {

commit 76e697ba7e8d187f50e385d21a2b2f1709a62c14
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Nov 26 14:20:49 2012 -0500

    NFSv4.1: Move slot table and session struct definitions to nfs4session.h
    
    Clean up. Gather NFSv4.1 slot definitions in fs/nfs/nfs4session.h.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 44d256f6021c..2076149db1a4 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -185,16 +185,7 @@ struct nfs4_channel_attrs {
 	u32			max_reqs;
 };
 
-/* nfs41 sessions slot seqid */
-struct nfs4_slot {
-	struct nfs4_slot_table	*table;
-	struct nfs4_slot	*next;
-	unsigned long		generation;
-	unsigned long		renewal_time;
-	u32			slot_nr;
-	u32		 	seq_nr;
-};
-
+struct nfs4_slot;
 struct nfs4_sequence_args {
 	struct nfs4_slot	*sa_slot;
 	u8			sa_cache_this;

commit 87dda67e7386ba7d2164391ea58b34e028d8157b
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Nov 20 19:49:20 2012 -0500

    NFSv4.1: Allow SEQUENCE to resize the slot table on the fly
    
    Instead of an array of slots, use a singly linked list of slots that
    can be dynamically appended to or shrunk.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 3ddb08fba935..44d256f6021c 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -188,6 +188,7 @@ struct nfs4_channel_attrs {
 /* nfs41 sessions slot seqid */
 struct nfs4_slot {
 	struct nfs4_slot_table	*table;
+	struct nfs4_slot	*next;
 	unsigned long		generation;
 	unsigned long		renewal_time;
 	u32			slot_nr;

commit da0507b7c95ccd4d9c86394eef42fe076032af30
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Nov 20 18:10:30 2012 -0500

    NFSv4.1: Reset the sequence number for slots that have been deallocated
    
    When the server tells us that it is dynamically resizing the session
    replay cache, we should reset the sequence number for those slots
    that have been deallocated.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 08c47db7417f..3ddb08fba935 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -203,6 +203,7 @@ struct nfs4_sequence_res {
 	struct nfs4_slot	*sr_slot;	/* slot used to send request */
 	int			sr_status;	/* sequence operation status */
 	u32			sr_status_flags;
+	u32			sr_highest_slotid;
 	u32			sr_target_highest_slotid;
 };
 

commit 464ee9f966404786ba4c6be35dc8362ee8e6ba4e
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Nov 20 12:49:27 2012 -0500

    NFSv4.1: Ensure that the client tracks the server target_highest_slotid
    
    Dynamic slot allocation in NFSv4.1 depends on the client being able to
    track the server's target value for the highest slotid in the
    slot table.  See the reference in Section 2.10.6.1 of RFC5661.
    
    To avoid ordering problems in the case where 2 SEQUENCE replies contain
    conflicting updates to this target value, we also introduce a generation
    counter, to track whether or not an RPC containing a SEQUENCE operation
    was launched before or after the last update.
    
    Also rename the nfs4_slot_table target_max_slots field to
    'target_highest_slotid' to avoid confusion with a slot
    table size or number of slots.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index deb31bbbb857..08c47db7417f 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -188,6 +188,7 @@ struct nfs4_channel_attrs {
 /* nfs41 sessions slot seqid */
 struct nfs4_slot {
 	struct nfs4_slot_table	*table;
+	unsigned long		generation;
 	unsigned long		renewal_time;
 	u32			slot_nr;
 	u32		 	seq_nr;
@@ -202,6 +203,7 @@ struct nfs4_sequence_res {
 	struct nfs4_slot	*sr_slot;	/* slot used to send request */
 	int			sr_status;	/* sequence operation status */
 	u32			sr_status_flags;
+	u32			sr_target_highest_slotid;
 };
 
 struct nfs4_get_lease_time_args {

commit 2b2fa71723f955d5b4a0f4edd99cf3cd69ceafd1
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Nov 16 12:58:36 2012 -0500

    NFSv4.1: Simplify struct nfs4_sequence_args too
    
    Replace the session pointer + slotid with a pointer to the
    allocated slot.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 9c9b76c94b46..deb31bbbb857 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -194,8 +194,7 @@ struct nfs4_slot {
 };
 
 struct nfs4_sequence_args {
-	struct nfs4_session	*sa_session;
-	u32			sa_slotid;
+	struct nfs4_slot	*sa_slot;
 	u8			sa_cache_this;
 };
 

commit df2fabffbace8988f3265585ec793ff9deccdea7
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Nov 16 12:45:06 2012 -0500

    NFSv4.1: Label each entry in the session slot tables with its slot number
    
    Instead of doing slot table pointer gymnastics every time we want to
    know which slot we're using.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 0fd88ab0e814..9c9b76c94b46 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -189,6 +189,7 @@ struct nfs4_channel_attrs {
 struct nfs4_slot {
 	struct nfs4_slot_table	*table;
 	unsigned long		renewal_time;
+	u32			slot_nr;
 	u32		 	seq_nr;
 };
 

commit e3725ec015dfbbeb896295cf2b3a995f28b0630e
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Nov 16 12:25:01 2012 -0500

    NFSv4.1: Shrink struct nfs4_sequence_res by moving the session pointer
    
    Move the session pointer into the slot table, then have struct nfs4_slot
    point to that slot table.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 9cb1c63a70c2..0fd88ab0e814 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -187,6 +187,7 @@ struct nfs4_channel_attrs {
 
 /* nfs41 sessions slot seqid */
 struct nfs4_slot {
+	struct nfs4_slot_table	*table;
 	unsigned long		renewal_time;
 	u32		 	seq_nr;
 };
@@ -198,7 +199,6 @@ struct nfs4_sequence_args {
 };
 
 struct nfs4_sequence_res {
-	struct nfs4_session	*sr_session;
 	struct nfs4_slot	*sr_slot;	/* slot used to send request */
 	int			sr_status;	/* sequence operation status */
 	u32			sr_status_flags;

commit 933602e368c4452260c9bff4fbb3baba35cf987a
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Nov 16 12:12:38 2012 -0500

    NFSv4.1: Shrink struct nfs4_sequence_res by moving sr_renewal_time
    
    Store the renewal time inside the session slot instead.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index a73ea89789d1..9cb1c63a70c2 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -187,6 +187,7 @@ struct nfs4_channel_attrs {
 
 /* nfs41 sessions slot seqid */
 struct nfs4_slot {
+	unsigned long		renewal_time;
 	u32		 	seq_nr;
 };
 
@@ -200,7 +201,6 @@ struct nfs4_sequence_res {
 	struct nfs4_session	*sr_session;
 	struct nfs4_slot	*sr_slot;	/* slot used to send request */
 	int			sr_status;	/* sequence operation status */
-	unsigned long		sr_renewal_time;
 	u32			sr_status_flags;
 };
 

commit ae2bb03236fc978bdf673c19d39832500793b83c
Author: Weston Andros Adamson <dros@netapp.com>
Date:   Tue Oct 2 14:49:52 2012 -0700

    NFSv4: don't put ACCESS in OPEN compound if O_EXCL
    
    Don't put an ACCESS op in OPEN compound if O_EXCL, because ACCESS
    will return permission denied for all bits until close.
    
    Fixes a regression due to commit 6168f62c (NFSv4: Add ACCESS operation to
    OPEN compound)
    
    Signed-off-by: Weston Andros Adamson <dros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 655490dae953..a73ea89789d1 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -369,6 +369,7 @@ struct nfs_openres {
 	struct nfs4_string	*owner;
 	struct nfs4_string	*group_owner;
 	struct nfs4_sequence_res	seq_res;
+	__u32			access_request;
 	__u32			access_supported;
 	__u32			access_result;
 };

commit 6168f62cbde8dcf4f58255794efbcdb8df603959
Author: Weston Andros Adamson <dros@netapp.com>
Date:   Mon Sep 10 14:00:46 2012 -0400

    NFSv4: Add ACCESS operation to OPEN compound
    
    The OPEN operation has no way to differentiate an open for read and an
    open for execution - both look like read to the server. This allowed
    users to read files that didn't have READ access but did have EXEC access,
    which is obviously wrong.
    
    This patch adds an ACCESS call to the OPEN compound to handle the
    difference between OPENs for reading and execution.  Since we're going
    through the trouble of calling ACCESS, we check all possible access bits
    and cache the results hopefully avoiding an ACCESS call in the future.
    
    Signed-off-by: Weston Andros Adamson <dros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 5da789fdf25b..655490dae953 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -334,6 +334,7 @@ struct nfs_openargs {
 	struct nfs_seqid *	seqid;
 	int			open_flags;
 	fmode_t			fmode;
+	u32			access;
 	__u64                   clientid;
 	struct stateowner_id	id;
 	union {
@@ -368,6 +369,8 @@ struct nfs_openres {
 	struct nfs4_string	*owner;
 	struct nfs4_string	*group_owner;
 	struct nfs4_sequence_res	seq_res;
+	__u32			access_supported;
+	__u32			access_result;
 };
 
 /*

commit a0b0a6e39bd1bb4a0922086feee73627cbd53ba4
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Sep 17 17:12:15 2012 -0400

    NFS: Clean up the pNFS layoutget interface
    
    Ensure that we do return errors from nfs4_proc_layoutget() and that we
    don't mark the layout as having failed if the error was due to a
    signal or resource problem on the client side.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index be9cf3c7e79e..5da789fdf25b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -251,7 +251,6 @@ struct nfs4_layoutget_res {
 struct nfs4_layoutget {
 	struct nfs4_layoutget_args args;
 	struct nfs4_layoutget_res res;
-	struct pnfs_layout_segment **lsegpp;
 	gfp_t gfp_flags;
 };
 

commit 1f1ea6c2d9d8c0be9ec56454b05315273b5de8ce
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sun Aug 26 11:44:43 2012 -0700

    NFSv4: Fix buffer overflow checking in __nfs4_get_acl_uncached
    
    Pass the checks made by decode_getacl back to __nfs4_get_acl_uncached
    so that it knows if the acl has been truncated.
    
    The current overflow checking is broken, resulting in Oopses on
    user-triggered nfs4_getfacl calls, and is opaque to the point
    where several attempts at fixing it have failed.
    This patch tries to clean up the code in addition to fixing the
    Oopses by ensuring that the overflow checks are performed in
    a single place (decode_getacl). If the overflow check failed,
    we will still be able to report the acl length, but at least
    we will no longer attempt to cache the acl or copy the
    truncated contents to user space.
    
    Reported-by: Sachin Prabhu <sprabhu@redhat.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Tested-by: Sachin Prabhu <sprabhu@redhat.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index ac7c8ae254f2..be9cf3c7e79e 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -652,7 +652,7 @@ struct nfs_getaclargs {
 };
 
 /* getxattr ACL interface flags */
-#define NFS4_ACL_LEN_REQUEST	0x0001	/* zero length getxattr buffer */
+#define NFS4_ACL_TRUNC		0x0001	/* ACL was truncated */
 struct nfs_getaclres {
 	size_t				acl_len;
 	size_t				acl_data_offset;

commit f6166384095b7ecf77752b5e9096e6d03d75f7ae
Author: Peng Tao <bergwolf@gmail.com>
Date:   Thu Aug 2 15:36:09 2012 +0300

    NFS41: add pg_layout_private to nfs_pageio_descriptor
    
    To allow layout driver to pass private information around
    pg_init/pg_doio.
    
    Signed-off-by: Peng Tao <tao.peng@emc.com>
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 00485e084394..ac7c8ae254f2 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1248,6 +1248,7 @@ struct nfs_pgio_header {
 	void (*release) (struct nfs_pgio_header *hdr);
 	const struct nfs_pgio_completion_ops *completion_ops;
 	struct nfs_direct_req	*dreq;
+	void			*layout_private;
 	spinlock_t		lock;
 	/* fields protected by lock */
 	int			pnfs_error;

commit 89d77c8fa8e6d1cb7e2cce95b428be30ddcc6f23
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Mon Jul 30 16:05:25 2012 -0400

    NFS: Convert v4 into a module
    
    This patch exports symbols needed by the v4 module.  In addition, I also
    switch over to using IS_ENABLED() to check if CONFIG_NFS_V4 or
    CONFIG_NFS_V4_MODULE are set.
    
    The module (nfs4.ko) will be created in the same directory as nfs.ko and
    will be automatically loaded the first time you try to mount over NFS v4.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 631182062994..00485e084394 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -824,7 +824,7 @@ struct nfs3_getaclres {
 	struct posix_acl *	acl_default;
 };
 
-#ifdef CONFIG_NFS_V4
+#if IS_ENABLED(CONFIG_NFS_V4)
 
 typedef u64 clientid4;
 

commit 1179acc6a3e260bc4edc74fa94f6c7908290eaec
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Mon Jul 30 16:05:19 2012 -0400

    NFS: Only initialize the ACL client in the v3 case
    
    v2 and v4 don't use it, so I create two new nfs_rpc_ops functions to
    initialize the ACL client only when we are using v3.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index bc7415baf44d..631182062994 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1439,6 +1439,9 @@ struct nfs_rpc_ops {
 		(*init_client) (struct nfs_client *, const struct rpc_timeout *,
 				const char *, rpc_authflavor_t);
 	void	(*free_client) (struct nfs_client *);
+	struct nfs_server *(*create_server)(struct nfs_mount_info *, struct nfs_subversion *);
+	struct nfs_server *(*clone_server)(struct nfs_server *, struct nfs_fh *,
+					   struct nfs_fattr *, rpc_authflavor_t);
 };
 
 /*

commit ff9099f26645818563c8d396a154c2ce6ee422eb
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Mon Jul 30 16:05:18 2012 -0400

    NFS: Create a try_mount rpc op
    
    I'm already looking up the nfs subversion in nfs_fs_mount(), so I have
    easy access to rpc_ops that used to be difficult to reach.  This allows
    me to set up a different mount path for NFS v2/3 and NFS v4.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 0e181c2320b7..bc7415baf44d 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1353,6 +1353,8 @@ struct nfs_renamedata {
 struct nfs_access_entry;
 struct nfs_client;
 struct rpc_timeout;
+struct nfs_subversion;
+struct nfs_mount_info;
 struct nfs_client_initdata;
 struct nfs_pageio_descriptor;
 
@@ -1370,6 +1372,8 @@ struct nfs_rpc_ops {
 			    struct nfs_fsinfo *);
 	struct vfsmount *(*submount) (struct nfs_server *, struct dentry *,
 				      struct nfs_fh *, struct nfs_fattr *);
+	struct dentry *(*try_mount) (int, const char *, struct nfs_mount_info *,
+				     struct nfs_subversion *);
 	int	(*getattr) (struct nfs_server *, struct nfs_fh *,
 			    struct nfs_fattr *);
 	int	(*setattr) (struct dentry *, struct nfs_fattr *,

commit 8626e4a42675ff9903f7d4fbf14d8ebc11b5926c
Merge: a8d8f02cf0c3 9249e17fe094
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Jul 16 12:01:42 2012 -0400

    Merge commit '9249e17fe094d853d1ef7475dd559a2cc7e23d42' into nfs-for-3.6
    
    Resolve conflicts with the VFS atomic open and sget changes.
    
    Conflicts:
            fs/nfs/nfs4proc.c

commit 8867fe5899010a0c0ac36dadfdacf1072b1c990c
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Jun 5 15:10:19 2012 +0200

    nfs: clean up ->create in nfs_rpc_ops
    
    Don't pass nfs_open_context() to ->create().  Only the NFS4 implementation
    needed that and only because it wanted to return an open file using open
    intents.  That task has been replaced by ->atomic_open so it is not necessary
    anymore to pass the context to the create rpc operation.
    
    Despite nfs4_proc_create apparently being okay with a NULL context it Oopses
    somewhere down the call chain.  So allocate a context here.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    CC: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 8aadd90b808a..d3b7c18b18f4 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1374,7 +1374,7 @@ struct nfs_rpc_ops {
 	int	(*readlink)(struct inode *, struct page *, unsigned int,
 			    unsigned int);
 	int	(*create)  (struct inode *, struct dentry *,
-			    struct iattr *, int, struct nfs_open_context *);
+			    struct iattr *, int);
 	int	(*remove)  (struct inode *, struct qstr *);
 	void	(*unlink_setup)  (struct rpc_message *, struct inode *dir);
 	void	(*unlink_rpc_prepare) (struct rpc_task *, struct nfs_unlinkdata *);

commit 57208fa7e51ca16cd68de8e8bf482f16b06d3ea1
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Wed Jun 20 15:53:48 2012 -0400

    NFS: Create an write_pageio_init() function
    
    pNFS needs to select a write function based on the layout driver
    currently in use, so I let each NFS version decide how to best handle
    initializing writes.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index e00b8b3c334e..8ed8ec628290 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1413,6 +1413,8 @@ struct nfs_rpc_ops {
 	void	(*read_rpc_prepare)(struct rpc_task *, struct nfs_read_data *);
 	int	(*read_done)  (struct rpc_task *, struct nfs_read_data *);
 	void	(*write_setup)  (struct nfs_write_data *, struct rpc_message *);
+	void	(*write_pageio_init)(struct nfs_pageio_descriptor *, struct inode *, int,
+				     const struct nfs_pgio_completion_ops *);
 	void	(*write_rpc_prepare)(struct rpc_task *, struct nfs_write_data *);
 	int	(*write_done)  (struct rpc_task *, struct nfs_write_data *);
 	void	(*commit_setup) (struct nfs_commit_data *, struct rpc_message *);

commit 1abb50886afe8a126705c93dab2b50c1252a9c19
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Wed Jun 20 15:53:47 2012 -0400

    NFS: Create an read_pageio_init() function
    
    pNFS needs to select a read function based on the layout driver
    currently in use, so I let each NFS version decide how to best handle
    initializing reads.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 4d62b774ddaf..e00b8b3c334e 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1354,6 +1354,7 @@ struct nfs_access_entry;
 struct nfs_client;
 struct rpc_timeout;
 struct nfs_client_initdata;
+struct nfs_pageio_descriptor;
 
 /*
  * RPC procedure vector for NFSv2/NFSv3 demuxing
@@ -1407,6 +1408,8 @@ struct nfs_rpc_ops {
 	int	(*set_capabilities)(struct nfs_server *, struct nfs_fh *);
 	int	(*decode_dirent)(struct xdr_stream *, struct nfs_entry *, int);
 	void	(*read_setup)   (struct nfs_read_data *, struct rpc_message *);
+	void	(*read_pageio_init)(struct nfs_pageio_descriptor *, struct inode *,
+				    const struct nfs_pgio_completion_ops *);
 	void	(*read_rpc_prepare)(struct rpc_task *, struct nfs_read_data *);
 	int	(*read_done)  (struct rpc_task *, struct nfs_read_data *);
 	void	(*write_setup)  (struct nfs_write_data *, struct rpc_message *);

commit 6663ee7f8187708143255c057bc132bbc84c1894
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Wed Jun 20 15:53:46 2012 -0400

    NFS: Create an alloc_client rpc_op
    
    This gives NFS v4 a way to set up callbacks and sessions without v2 or
    v3 having to do them as well.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index e61dc7235d5d..4d62b774ddaf 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1353,6 +1353,7 @@ struct nfs_renamedata {
 struct nfs_access_entry;
 struct nfs_client;
 struct rpc_timeout;
+struct nfs_client_initdata;
 
 /*
  * RPC procedure vector for NFSv2/NFSv3 demuxing
@@ -1424,6 +1425,7 @@ struct nfs_rpc_ops {
 				struct iattr *iattr);
 	int (*have_delegation)(struct inode *, fmode_t);
 	int (*return_delegation)(struct inode *);
+	struct nfs_client *(*alloc_client) (const struct nfs_client_initdata *);
 	struct nfs_client *
 		(*init_client) (struct nfs_client *, const struct rpc_timeout *,
 				const char *, rpc_authflavor_t);

commit cdb7ecedec766861e7c4cc35a203518f92023bff
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Wed Jun 20 15:53:45 2012 -0400

    NFS: Create a free_client rpc_op
    
    NFS v4 needs a way to shut down callbacks and sessions, but v2 and v3
    don't.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 62235be07fb8..e61dc7235d5d 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1427,6 +1427,7 @@ struct nfs_rpc_ops {
 	struct nfs_client *
 		(*init_client) (struct nfs_client *, const struct rpc_timeout *,
 				const char *, rpc_authflavor_t);
+	void	(*free_client) (struct nfs_client *);
 };
 
 /*

commit 57ec14c55dee2733330327499d16e40f8c23219e
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Wed Jun 20 15:53:44 2012 -0400

    NFS: Create a return_delegation rpc op
    
    Delegations are a v4 feature, so push return_delegation out of the
    generic client by creating a new rpc_op and renaming the old function to
    be in the nfs v4 "namespace"
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 8787f77c64b3..62235be07fb8 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1423,6 +1423,7 @@ struct nfs_rpc_ops {
 				int open_flags,
 				struct iattr *iattr);
 	int (*have_delegation)(struct inode *, fmode_t);
+	int (*return_delegation)(struct inode *);
 	struct nfs_client *
 		(*init_client) (struct nfs_client *, const struct rpc_timeout *,
 				const char *, rpc_authflavor_t);

commit 011e2a7fd5e9e0c2fdba6b9466d53fc437f8bfaf
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Wed Jun 20 15:53:43 2012 -0400

    NFS: Create a have_delegation rpc_op
    
    Delegations are a v4 feature, so push them out of the generic code.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 5c0014d1c969..8787f77c64b3 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1422,6 +1422,7 @@ struct nfs_rpc_ops {
 				struct nfs_open_context *ctx,
 				int open_flags,
 				struct iattr *iattr);
+	int (*have_delegation)(struct inode *, fmode_t);
 	struct nfs_client *
 		(*init_client) (struct nfs_client *, const struct rpc_timeout *,
 				const char *, rpc_authflavor_t);

commit 2f2c63bc221c5fcded24de2704575d0abf96b910
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Jun 8 11:56:09 2012 -0400

    NFS: Cleanup - only store the write verifier in struct nfs_page
    
    The 'committed' field is not needed once we have put the struct nfs_page
    on the right list.
    
    Also correct the type of the verifier: it is not an array of __be32, but
    simply an 8 byte long opaque array.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 8aadd90b808a..5c0014d1c969 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -514,9 +514,13 @@ struct nfs_writeargs {
 	struct nfs4_sequence_args	seq_args;
 };
 
+struct nfs_write_verifier {
+	char			data[8];
+};
+
 struct nfs_writeverf {
+	struct nfs_write_verifier verifier;
 	enum nfs3_stable_how	committed;
-	__be32			verifier[2];
 };
 
 struct nfs_writeres {

commit 9bce008bae8b57bc7b007bcc2071d1247a527120
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Jun 5 18:32:03 2012 -0400

    NFS: Fix a commit bug
    
    The new commit code fails to copy the verifier into the wb_verf field
    of _all_ the nfs_page structures; it only copies it into the first entry.
    The consequence is that most requests end up failing to match in
    nfs_commit_release.
    
    Fix is to copy the verifier into the req->wb_verf field in
    nfs_write_completion.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Cc: Fred Isaman <iisaman@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 7519baef025b..8aadd90b808a 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1237,6 +1237,7 @@ struct nfs_pgio_header {
 	struct list_head	rpc_list;
 	atomic_t		refcnt;
 	struct nfs_page		*req;
+	struct nfs_writeverf	*verf;
 	struct pnfs_layout_segment *lseg;
 	loff_t			io_start;
 	const struct rpc_call_ops *mds_ops;
@@ -1274,6 +1275,7 @@ struct nfs_write_data {
 struct nfs_write_header {
 	struct nfs_pgio_header	header;
 	struct nfs_write_data	rpc_data;
+	struct nfs_writeverf	verf;
 };
 
 struct nfs_mds_commit_info {

commit 1549210fcc17e9ae20c09ac8cd4c48a8dfd431bd
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Jun 5 09:16:47 2012 -0400

    NFSv4: Fix an Oops in the open recovery code
    
    The open recovery code does not need to request a new value for the
    mdsthreshold, and so does not allocate a struct nfs4_threshold.
    The problem is that encode_getfattr_open() will still request an
    mdsthreshold, and so we end up Oopsing in decode_attr_mdsthreshold.
    
    This patch fixes encode_getfattr_open so that it doesn't request an
    mdsthreshold when the caller isn't asking for one. It also fixes
    decode_attr_mdsthreshold so that it errors if the server returns
    an mdsthreshold that we didn't ask for (instead of Oopsing).
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Cc: Andy Adamson <andros@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index d1a7bf51c326..7519baef025b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -348,6 +348,7 @@ struct nfs_openargs {
 	const struct qstr *	name;
 	const struct nfs_server *server;	 /* Needed for ID mapping */
 	const u32 *		bitmask;
+	const u32 *		open_bitmap;
 	__u32			claim;
 	struct nfs4_sequence_args	seq_args;
 };

commit 32b0131069c5bebf52368a9fe170f8d58b78fa8d
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sat May 26 13:41:04 2012 -0400

    NFSv4.1: Don't clobber the seqid if exchange_id returns a confirmed clientid
    
    If the EXCHGID4_FLAG_CONFIRMED_R flag is set, the client is in theory
    supposed to already know the correct value of the seqid, in which case
    RFC5661 states that it should ignore the value returned.
    
    Also ensure that if the sanity check in nfs4_check_cl_exchange_flags
    fails, then we must not change the nfs_client fields.
    
    Finally, clean up the code: we don't need to retest the value of
    'status' unless it can change.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 6387fc0097fe..d1a7bf51c326 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1132,7 +1132,8 @@ struct nfs41_bind_conn_to_session_res {
 };
 
 struct nfs41_exchange_id_res {
-	struct nfs_client		*client;
+	u64				clientid;
+	u32				seqid;
 	u32				flags;
 	struct nfs41_server_owner	*server_owner;
 	struct nfs41_server_scope	*server_scope;

commit 7c44f1ae4a21458a1ea3d6482ffb3136f1df6d2b
Author: Weston Andros Adamson <dros@netapp.com>
Date:   Thu May 24 13:22:50 2012 -0400

    nfs4.1: add BIND_CONN_TO_SESSION operation
    
    This patch adds the BIND_CONN_TO_SESSION operation which is needed for
    upcoming SP4_MACH_CRED work and useful for recovering from broken connections
    without destroying the session.
    
    Signed-off-by: Weston Andros Adamson <dros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 201c312152fb..6387fc0097fe 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1125,6 +1125,12 @@ struct nfs41_impl_id {
 	struct nfstime4			date;
 };
 
+struct nfs41_bind_conn_to_session_res {
+	struct nfs4_session		*session;
+	u32				dir;
+	bool				use_conn_in_rdma_mode;
+};
+
 struct nfs41_exchange_id_res {
 	struct nfs_client		*client;
 	u32				flags;

commit 88034c3d88c2c48b215f2cc5eb22e564aa817f9c
Author: Andy Adamson <andros@netapp.com>
Date:   Wed May 23 05:02:34 2012 -0400

    NFSv4.1 mdsthreshold attribute xdr
    
    We only support one layout type per file system, so one threshold_item4 per
    mdsthreshold4.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 0872f32c8eef..201c312152fb 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -35,6 +35,15 @@ static inline int nfs_fsid_equal(const struct nfs_fsid *a, const struct nfs_fsid
 	return a->major == b->major && a->minor == b->minor;
 }
 
+struct nfs4_threshold {
+	__u32	bm;
+	__u32	l_type;
+	__u64	rd_sz;
+	__u64	wr_sz;
+	__u64	rd_io_sz;
+	__u64	wr_io_sz;
+};
+
 struct nfs_fattr {
 	unsigned int		valid;		/* which fields are valid */
 	umode_t			mode;
@@ -67,6 +76,7 @@ struct nfs_fattr {
 	unsigned long		gencount;
 	struct nfs4_string	*owner_name;
 	struct nfs4_string	*group_name;
+	struct nfs4_threshold	*mdsthreshold;	/* pNFS threshold hints */
 };
 
 #define NFS_ATTR_FATTR_TYPE		(1U << 0)

commit acdeb69d9c5934a678a732b4e24770326bf9471e
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon May 21 22:46:16 2012 -0400

    NFS: EXCHANGE_ID should save the server major and minor ID
    
    Save the server major and minor ID results from EXCHANGE_ID, as they
    are needed for detecting server trunking.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 07048c012dec..0872f32c8eef 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1098,7 +1098,7 @@ struct nfs41_exchange_id_args {
 	u32				flags;
 };
 
-struct server_owner {
+struct nfs41_server_owner {
 	uint64_t			minor_id;
 	uint32_t			major_id_sz;
 	char				major_id[NFS4_OPAQUE_LIMIT];
@@ -1118,6 +1118,7 @@ struct nfs41_impl_id {
 struct nfs41_exchange_id_res {
 	struct nfs_client		*client;
 	u32				flags;
+	struct nfs41_server_owner	*server_owner;
 	struct nfs41_server_scope	*server_scope;
 	struct nfs41_impl_id		*impl_id;
 };

commit 4bf590e08f6db3395c181618a4c14f1c39b7c4af
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon May 21 22:46:07 2012 -0400

    NFS: Add nfs_client behavior flags
    
    "noresvport" and "discrtry" can be passed to nfs_create_rpc_client()
    by setting flags in the passed-in nfs_client.  This change makes it
    easy to add new flags.
    
    Note that these settings are now "sticky" over the lifetime of a
    struct nfs_client, and may even be copied when an nfs_client is
    cloned.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 0c521cd496a7..07048c012dec 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1399,7 +1399,7 @@ struct nfs_rpc_ops {
 				struct iattr *iattr);
 	struct nfs_client *
 		(*init_client) (struct nfs_client *, const struct rpc_timeout *,
-				const char *, rpc_authflavor_t, int);
+				const char *, rpc_authflavor_t);
 };
 
 /*

commit 8cab4c390b43fe34c07bd33799c1bc24be648122
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon May 21 22:45:59 2012 -0400

    NFS: Refactor nfs_get_client(): initialize nfs_client
    
    Clean up: Continue to rationalize the locking in nfs_get_client() by
    moving the logic that handles the case where a matching server IP
    address is not found.
    
    When we support server trunking detection, client initialization may
    return a different nfs_client struct than was passed to it.  Change
    the synopsis of the init_client methods to return an nfs_client.
    
    The client initialization logic in nfs_get_client() is not much more
    than a wrapper around ->init_client.  It's simpler to keep the little
    bits of error handling in the version-specific init_client methods.
    
    No behavior change is expected.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index c420b8d60a55..0c521cd496a7 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1397,7 +1397,8 @@ struct nfs_rpc_ops {
 				struct nfs_open_context *ctx,
 				int open_flags,
 				struct iattr *iattr);
-	int	(*init_client) (struct nfs_client *, const struct rpc_timeout *,
+	struct nfs_client *
+		(*init_client) (struct nfs_client *, const struct rpc_timeout *,
 				const char *, rpc_authflavor_t, int);
 };
 

commit 79d4e1f0d8910f0214a57832ca6d589640d572c0
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon May 21 22:44:31 2012 -0400

    NFS: Use proper naming conventions for NFSv4.1 server scope fields
    
    Clean up:  When naming fields and data types, follow established
    conventions to facilitate accurate grep/cscope searches.
    
    Additionally, for consistency, move the scope field into the NFSv4-
    specific part of the nfs_client, and free that memory in the logic
    that shuts down NFSv4 nfs_clients.
    
    Introduced by commit 99fe60d0 "nfs41: exchange_id operation", April
    1 2009.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 2e53a3f1d2ff..c420b8d60a55 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1104,7 +1104,7 @@ struct server_owner {
 	char				major_id[NFS4_OPAQUE_LIMIT];
 };
 
-struct server_scope {
+struct nfs41_server_scope {
 	uint32_t			server_scope_sz;
 	char 				server_scope[NFS4_OPAQUE_LIMIT];
 };
@@ -1118,7 +1118,7 @@ struct nfs41_impl_id {
 struct nfs41_exchange_id_res {
 	struct nfs_client		*client;
 	u32				flags;
-	struct server_scope		*server_scope;
+	struct nfs41_server_scope	*server_scope;
 	struct nfs41_impl_id		*impl_id;
 };
 

commit 778d28172f710184855bcfeadcdd6b46997c4de2
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Apr 27 13:48:19 2012 -0400

    NFSv4: Simplify the NFSv4 REMOVE, LINK and RENAME compounds
    
    Get rid of the post-op GETATTR on the directory in order to reduce
    the amount of processing done on the server.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 696a17e047be..2e53a3f1d2ff 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -540,7 +540,6 @@ struct nfs_commitres {
 struct nfs_removeargs {
 	const struct nfs_fh	*fh;
 	struct qstr		name;
-	const u32 *		bitmask;
 	struct nfs4_sequence_args	seq_args;
 };
 
@@ -559,7 +558,6 @@ struct nfs_renameargs {
 	const struct nfs_fh		*new_dir;
 	const struct qstr		*old_name;
 	const struct qstr		*new_name;
-	const u32			*bitmask;
 	struct nfs4_sequence_args	seq_args;
 };
 

commit 7c317fcfbae773e493ecee1c53738db774b1d0ca
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Apr 27 13:48:18 2012 -0400

    NFSv4: Simplify the NFSv4 CREATE compound
    
    Get rid of the post-op GETATTR on the directory in order to reduce
    the amount of processing done on the server.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 92a929fc97c8..696a17e047be 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -855,7 +855,6 @@ struct nfs4_create_res {
 	struct nfs_fh *			fh;
 	struct nfs_fattr *		fattr;
 	struct nfs4_change_info		dir_cinfo;
-	struct nfs_fattr *		dir_fattr;
 	struct nfs4_sequence_res	seq_res;
 };
 

commit 90ff0c548d1220d31f80e498b587393895705e6c
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Apr 27 13:48:18 2012 -0400

    NFSv4: Simplify the NFSv4 OPEN compound
    
    Get rid of the post-op GETATTR on the directory in order to reduce
    the amount of processing done on the server.
    
    The cost is that if we later need to stat() the directory, then we
    know that the ctime and mtime are likely to be invalid.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index bc3680885428..92a929fc97c8 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -338,7 +338,6 @@ struct nfs_openargs {
 	const struct qstr *	name;
 	const struct nfs_server *server;	 /* Needed for ID mapping */
 	const u32 *		bitmask;
-	const u32 *		dir_bitmask;
 	__u32			claim;
 	struct nfs4_sequence_args	seq_args;
 };
@@ -349,7 +348,6 @@ struct nfs_openres {
 	struct nfs4_change_info	cinfo;
 	__u32                   rflags;
 	struct nfs_fattr *      f_attr;
-	struct nfs_fattr *      dir_attr;
 	struct nfs_seqid *	seqid;
 	const struct nfs_server *server;
 	fmode_t			delegation_type;

commit 3a1556e8662cc425c433b463fcdae138908ca467
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Apr 27 13:48:18 2012 -0400

    NFSv2/v3: Simulate the change attribute
    
    Use the ctime to simulate a change attribute for NFSv2 and NFSv3.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 6deb8f097c42..bc3680885428 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -106,14 +106,14 @@ struct nfs_fattr {
 		| NFS_ATTR_FATTR_FILEID \
 		| NFS_ATTR_FATTR_ATIME \
 		| NFS_ATTR_FATTR_MTIME \
-		| NFS_ATTR_FATTR_CTIME)
+		| NFS_ATTR_FATTR_CTIME \
+		| NFS_ATTR_FATTR_CHANGE)
 #define NFS_ATTR_FATTR_V2 (NFS_ATTR_FATTR \
 		| NFS_ATTR_FATTR_BLOCKS_USED)
 #define NFS_ATTR_FATTR_V3 (NFS_ATTR_FATTR \
 		| NFS_ATTR_FATTR_SPACE_USED)
 #define NFS_ATTR_FATTR_V4 (NFS_ATTR_FATTR \
-		| NFS_ATTR_FATTR_SPACE_USED \
-		| NFS_ATTR_FATTR_CHANGE)
+		| NFS_ATTR_FATTR_SPACE_USED)
 
 /*
  * Info on the file system

commit 4f97615d19c370d1d907ef37f8bcd9c3672851ca
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Apr 30 18:39:20 2012 -0400

    NFS: Fix a compile issue when CONFIG_NFS_V4_1 is undefined
    
    struct nfs_direct_req can't compile when struct pnfs_ds_commit_info
    is undefined.
    
    Reported-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Cc: Fred Isaman <iisaman@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index c940d46eb423..6deb8f097c42 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1176,6 +1176,11 @@ struct nfs41_free_stateid_res {
 	struct nfs4_sequence_res	seq_res;
 };
 
+#else
+
+struct pnfs_ds_commit_info {
+};
+
 #endif /* CONFIG_NFS_V4_1 */
 
 struct nfs_page;

commit 80a16b21a81eb639f0b726549f4c46c0e9aff92e
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Fri Apr 27 13:27:46 2012 -0400

    NFS: Remove extra rpc_clnt argument to proc_lookup
    
    Now that I'm doing secinfo automatically in the v4 code this extra
    argument isn't needed.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 4dada94eba7d..c940d46eb423 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1347,7 +1347,7 @@ struct nfs_rpc_ops {
 			    struct nfs_fattr *);
 	int	(*setattr) (struct dentry *, struct nfs_fattr *,
 			    struct iattr *);
-	int	(*lookup)  (struct rpc_clnt *clnt, struct inode *, struct qstr *,
+	int	(*lookup)  (struct inode *, struct qstr *,
 			    struct nfs_fh *, struct nfs_fattr *);
 	int	(*access)  (struct inode *, struct nfs_access_entry *);
 	int	(*readlink)(struct inode *, struct page *, unsigned int,

commit 281cad46b34db4dbb1d1e603f7b9cfe25d1ae7c9
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Fri Apr 27 13:27:45 2012 -0400

    NFS: Create a submount rpc_op
    
    This simplifies the code for v2 and v3 and gives v4 a chance to decide
    on referrals without needing to modify the generic client.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index eb1f143042f4..4dada94eba7d 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1341,6 +1341,8 @@ struct nfs_rpc_ops {
 
 	int	(*getroot) (struct nfs_server *, struct nfs_fh *,
 			    struct nfs_fsinfo *);
+	struct vfsmount *(*submount) (struct nfs_server *, struct dentry *,
+				      struct nfs_fh *, struct nfs_fattr *);
 	int	(*getattr) (struct nfs_server *, struct nfs_fh *,
 			    struct nfs_fattr *);
 	int	(*setattr) (struct dentry *, struct nfs_fattr *,

commit 2671bfc3beb44e70636bd0208274426db57f73b5
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Fri Apr 27 13:27:44 2012 -0400

    NFS: Remove secinfo knowledge out of the generic client
    
    And also remove the unneeded rpc_op.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 5f563bd113e8..eb1f143042f4 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1397,7 +1397,6 @@ struct nfs_rpc_ops {
 				struct iattr *iattr);
 	int	(*init_client) (struct nfs_client *, const struct rpc_timeout *,
 				const char *, rpc_authflavor_t, int);
-	int	(*secinfo)(struct inode *, const struct qstr *, struct nfs4_secinfo_flavors *);
 };
 
 /*

commit b359f9d09bcbaede09243cfe844172ba055d89fd
Author: Fred Isaman <iisaman@netapp.com>
Date:   Fri Apr 20 14:47:55 2012 -0400

    NFS: add dreq to nfs_commit_info
    
    Need this to pass into nfs_commitdata_init, in order to keep data->dreq
    accurate.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 0e8b88ad9ae2..5f563bd113e8 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1274,6 +1274,7 @@ struct nfs_commit_info {
 	spinlock_t			*lock;
 	struct nfs_mds_commit_info	*mds;
 	struct pnfs_ds_commit_info	*ds;
+	struct nfs_direct_req		*dreq;	/* O_DIRECT request */
 	const struct nfs_commit_completion_ops *completion_ops;
 };
 

commit f453a54a01c7c0453ad9550906e3d2663dd486ac
Author: Fred Isaman <iisaman@netapp.com>
Date:   Fri Apr 20 14:47:54 2012 -0400

    NFS: create nfs_commit_completion_ops
    
    Factors out the code that needs to change when directio
    starts using these code paths.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 224e1e82670c..0e8b88ad9ae2 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1263,10 +1263,18 @@ struct nfs_mds_commit_info {
 	struct list_head	list;
 };
 
+struct nfs_commit_data;
+struct nfs_inode;
+struct nfs_commit_completion_ops {
+	void (*error_cleanup) (struct nfs_inode *nfsi);
+	void (*completion) (struct nfs_commit_data *data);
+};
+
 struct nfs_commit_info {
 	spinlock_t			*lock;
 	struct nfs_mds_commit_info	*mds;
 	struct pnfs_ds_commit_info	*ds;
+	const struct nfs_commit_completion_ops *completion_ops;
 };
 
 struct nfs_commit_data {
@@ -1285,6 +1293,7 @@ struct nfs_commit_data {
 	struct nfs_client	*ds_clp;	/* pNFS data server */
 	int			ds_commit_index;
 	const struct rpc_call_ops *mds_ops;
+	const struct nfs_commit_completion_ops *completion_ops;
 	int (*commit_done_cb) (struct rpc_task *task, struct nfs_commit_data *data);
 };
 

commit ea2cf2282b4278461266013e9c002ee1c66700ff
Author: Fred Isaman <iisaman@netapp.com>
Date:   Fri Apr 20 14:47:53 2012 -0400

    NFS: create struct nfs_commit_info
    
    It is COMMIT that is handled the most differently between
    the paged and direct paths.  Create a structure that encapsulates
    everything either path needs to know about the commit state.
    
    We could use void to hide some of the layout driver stuff, but
    Trond suggests pulling it out to ensure type checking, given the
    huge changes being made, and the fact that it doesn't interfere
    with other drivers.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 38687b87ca9b..224e1e82670c 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1079,6 +1079,21 @@ struct nfstime4 {
 };
 
 #ifdef CONFIG_NFS_V4_1
+
+struct pnfs_commit_bucket {
+	struct list_head written;
+	struct list_head committing;
+	struct pnfs_layout_segment *wlseg;
+	struct pnfs_layout_segment *clseg;
+};
+
+struct pnfs_ds_commit_info {
+	int nwritten;
+	int ncommitting;
+	int nbuckets;
+	struct pnfs_commit_bucket *buckets;
+};
+
 #define NFS4_EXCHANGE_ID_LEN	(48)
 struct nfs41_exchange_id_args {
 	struct nfs_client		*client;
@@ -1242,6 +1257,18 @@ struct nfs_write_header {
 	struct nfs_write_data	rpc_data;
 };
 
+struct nfs_mds_commit_info {
+	atomic_t rpcs_out;
+	unsigned long		ncommit;
+	struct list_head	list;
+};
+
+struct nfs_commit_info {
+	spinlock_t			*lock;
+	struct nfs_mds_commit_info	*mds;
+	struct pnfs_ds_commit_info	*ds;
+};
+
 struct nfs_commit_data {
 	struct rpc_task		task;
 	struct inode		*inode;

commit 584aa810b6240d88c28113a90c5029449814a3b5
Author: Fred Isaman <iisaman@netapp.com>
Date:   Fri Apr 20 14:47:51 2012 -0400

    NFS: rewrite directio read to use async coalesce code
    
    This also has the advantage that it allows directio to use pnfs.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 6fa1d2278c9d..38687b87ca9b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1208,6 +1208,7 @@ struct nfs_pgio_header {
 	const struct rpc_call_ops *mds_ops;
 	void (*release) (struct nfs_pgio_header *hdr);
 	const struct nfs_pgio_completion_ops *completion_ops;
+	struct nfs_direct_req	*dreq;
 	spinlock_t		lock;
 	/* fields protected by lock */
 	int			pnfs_error;
@@ -1221,8 +1222,6 @@ struct nfs_read_header {
 	struct nfs_read_data	rpc_data;
 };
 
-struct nfs_direct_req;
-
 struct nfs_write_data {
 	struct nfs_pgio_header	*header;
 	struct list_head	list;
@@ -1264,6 +1263,7 @@ struct nfs_commit_data {
 
 struct nfs_pgio_completion_ops {
 	void	(*error_cleanup)(struct list_head *head);
+	void	(*init_hdr)(struct nfs_pgio_header *hdr);
 	void	(*completion)(struct nfs_pgio_header *hdr);
 };
 

commit 061ae2edb7375ab6776468b075da71008a098b55
Author: Fred Isaman <iisaman@netapp.com>
Date:   Fri Apr 20 14:47:48 2012 -0400

    NFS: create completion structure to pass into page_init functions
    
    Factors out the code that will need to change when directio
    starts using these code paths.  This will allow directio to use
    the generic pagein and flush routines
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 0d17db7973de..6fa1d2278c9d 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1207,6 +1207,7 @@ struct nfs_pgio_header {
 	loff_t			io_start;
 	const struct rpc_call_ops *mds_ops;
 	void (*release) (struct nfs_pgio_header *hdr);
+	const struct nfs_pgio_completion_ops *completion_ops;
 	spinlock_t		lock;
 	/* fields protected by lock */
 	int			pnfs_error;
@@ -1261,6 +1262,11 @@ struct nfs_commit_data {
 	int (*commit_done_cb) (struct rpc_task *task, struct nfs_commit_data *data);
 };
 
+struct nfs_pgio_completion_ops {
+	void	(*error_cleanup)(struct list_head *head);
+	void	(*completion)(struct nfs_pgio_header *hdr);
+};
+
 struct nfs_unlinkdata {
 	struct hlist_node list;
 	struct nfs_removeargs args;

commit 6c75dc0d498caa402fb17b1bf769835a9db875c8
Author: Fred Isaman <iisaman@netapp.com>
Date:   Fri Apr 20 14:47:47 2012 -0400

    NFS: merge _full and _partial write rpc_ops
    
    Decouple nfs_pgio_header and nfs_write_data, and have (possibly
    multiple) nfs_write_datas each take a refcount on nfs_pgio_header.
    
    For the moment keeps nfs_write_header as a way to preallocate a single
    nfs_write_data with the nfs_pgio_header.  The code doesn't need this,
    and would be prettier without, but given the amount of churn I am
    already introducing I didn't want to play with tuning new mempools.
    
    This also fixes bug in pnfs_ld_handle_write_error.  In the case of
    desc->pg_bsize < PAGE_CACHE_SIZE, the pages list was empty, causing
    replay attempt to do nothing.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 164862148ba0..0d17db7973de 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1192,6 +1192,8 @@ enum {
 	NFS_IOHDR_ERROR = 0,
 	NFS_IOHDR_EOF,
 	NFS_IOHDR_REDO,
+	NFS_IOHDR_NEED_COMMIT,
+	NFS_IOHDR_NEED_RESCHED,
 };
 
 struct nfs_pgio_header {

commit 4db6e0b74c0f6dfc2f9c0690e8df512e3b635983
Author: Fred Isaman <iisaman@netapp.com>
Date:   Fri Apr 20 14:47:46 2012 -0400

    NFS: merge _full and _partial read rpc_ops
    
    Decouple nfs_pgio_header and nfs_read_data, and have (possibly
    multiple) nfs_read_datas each take a refcount on nfs_pgio_header.
    
    For the moment keeps nfs_read_header as a way to preallocate a single
    nfs_read_data with the nfs_pgio_header.  The code doesn't need this,
    and would be prettier without, but given the amount of churn I am
    already introducing I didn't want to play with tuning new mempools.
    
    This also fixes bug in pnfs_ld_handle_read_error.  In the case of
    desc->pg_bsize < PAGE_CACHE_SIZE, the pages list was empty, causing
    replay attempt to do nothing.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index e34beaf86e9c..164862148ba0 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1187,14 +1187,30 @@ struct nfs_read_data {
 	struct nfs_client	*ds_clp;	/* pNFS data server */
 };
 
+/* used as flag bits in nfs_pgio_header */
+enum {
+	NFS_IOHDR_ERROR = 0,
+	NFS_IOHDR_EOF,
+	NFS_IOHDR_REDO,
+};
+
 struct nfs_pgio_header {
 	struct inode		*inode;
 	struct rpc_cred		*cred;
 	struct list_head	pages;
+	struct list_head	rpc_list;
+	atomic_t		refcnt;
 	struct nfs_page		*req;
 	struct pnfs_layout_segment *lseg;
+	loff_t			io_start;
 	const struct rpc_call_ops *mds_ops;
+	void (*release) (struct nfs_pgio_header *hdr);
+	spinlock_t		lock;
+	/* fields protected by lock */
 	int			pnfs_error;
+	int			error;		/* merge with pnfs_error */
+	unsigned long		good_bytes;	/* boundary of good data */
+	unsigned long		flags;
 };
 
 struct nfs_read_header {

commit 30dd374f6fc1b202db3a1b57b61afff1326bad92
Author: Fred Isaman <iisaman@netapp.com>
Date:   Fri Apr 20 14:47:45 2012 -0400

    NFS: create struct nfs_page_array
    
    Both nfs_read_data and nfs_write_data devote several fields which
    can be combined into a single shared struct.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index fee324175391..e34beaf86e9c 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1167,19 +1167,23 @@ struct nfs_page;
 
 #define NFS_PAGEVEC_SIZE	(8U)
 
+struct nfs_page_array {
+	struct page		**pagevec;
+	unsigned int		npages;		/* Max length of pagevec */
+	struct page		*page_array[NFS_PAGEVEC_SIZE];
+};
+
 struct nfs_read_data {
 	struct nfs_pgio_header	*header;
 	struct list_head	list;
 	struct rpc_task		task;
 	struct nfs_fattr	fattr;	/* fattr storage */
-	struct page		**pagevec;
-	unsigned int		npages;	/* Max length of pagevec */
 	struct nfs_readargs args;
 	struct nfs_readres  res;
 	unsigned long		timestamp;	/* For lease renewal */
 	int (*read_done_cb) (struct rpc_task *task, struct nfs_read_data *data);
 	__u64			mds_offset;
-	struct page		*page_array[NFS_PAGEVEC_SIZE];
+	struct nfs_page_array	pages;
 	struct nfs_client	*ds_clp;	/* pNFS data server */
 };
 
@@ -1206,14 +1210,12 @@ struct nfs_write_data {
 	struct rpc_task		task;
 	struct nfs_fattr	fattr;
 	struct nfs_writeverf	verf;
-	struct page		**pagevec;
-	unsigned int		npages;		/* Max length of pagevec */
 	struct nfs_writeargs	args;		/* argument struct */
 	struct nfs_writeres	res;		/* result struct */
 	unsigned long		timestamp;	/* For lease renewal */
 	int (*write_done_cb) (struct rpc_task *task, struct nfs_write_data *data);
 	__u64			mds_offset;	/* Filelayout dense stripe */
-	struct page		*page_array[NFS_PAGEVEC_SIZE];
+	struct nfs_page_array	pages;
 	struct nfs_client	*ds_clp;	/* pNFS data server */
 };
 

commit cd841605f7a721878d8a2d1362484723d8abf569
Author: Fred Isaman <iisaman@netapp.com>
Date:   Fri Apr 20 14:47:44 2012 -0400

    NFS: create common nfs_pgio_header for both read and write
    
    In order to avoid duplicating all the data in nfs_read_data whenever we
    split it up into multiple RPC calls (either due to a short read result
    or due to rsize < PAGE_SIZE), we split out the bits that are the same
    per RPC call into a separate "header" structure.
    
    The goal this patch moves towards is to have a single header
    refcounted by several rpc_data structures.  Thus, want to always refer
    from rpc_data to the header, and not the other way.  This patch comes
    close to that ideal, but the directio code currently needs some
    special casing, isolated in the nfs_direct_[read_write]hdr_release()
    functions.  This will be dealt with in a future patch.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 8fb036a0d489..fee324175391 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1168,52 +1168,58 @@ struct nfs_page;
 #define NFS_PAGEVEC_SIZE	(8U)
 
 struct nfs_read_data {
+	struct nfs_pgio_header	*header;
+	struct list_head	list;
 	struct rpc_task		task;
-	struct inode		*inode;
-	struct rpc_cred		*cred;
 	struct nfs_fattr	fattr;	/* fattr storage */
-	struct list_head	pages;	/* Coalesced read requests */
-	struct list_head	list;	/* lists of struct nfs_read_data */
-	struct nfs_page		*req;	/* multi ops per nfs_page */
 	struct page		**pagevec;
 	unsigned int		npages;	/* Max length of pagevec */
 	struct nfs_readargs args;
 	struct nfs_readres  res;
 	unsigned long		timestamp;	/* For lease renewal */
-	struct pnfs_layout_segment *lseg;
-	struct nfs_client	*ds_clp;	/* pNFS data server */
-	const struct rpc_call_ops *mds_ops;
 	int (*read_done_cb) (struct rpc_task *task, struct nfs_read_data *data);
 	__u64			mds_offset;
-	int			pnfs_error;
 	struct page		*page_array[NFS_PAGEVEC_SIZE];
+	struct nfs_client	*ds_clp;	/* pNFS data server */
+};
+
+struct nfs_pgio_header {
+	struct inode		*inode;
+	struct rpc_cred		*cred;
+	struct list_head	pages;
+	struct nfs_page		*req;
+	struct pnfs_layout_segment *lseg;
+	const struct rpc_call_ops *mds_ops;
+	int			pnfs_error;
+};
+
+struct nfs_read_header {
+	struct nfs_pgio_header	header;
+	struct nfs_read_data	rpc_data;
 };
 
 struct nfs_direct_req;
 
 struct nfs_write_data {
+	struct nfs_pgio_header	*header;
+	struct list_head	list;
 	struct rpc_task		task;
-	struct inode		*inode;
-	struct rpc_cred		*cred;
 	struct nfs_fattr	fattr;
 	struct nfs_writeverf	verf;
-	struct list_head	pages;		/* Coalesced requests we wish to flush */
-	struct list_head	list;		/* lists of struct nfs_write_data */
-	struct nfs_page		*req;		/* multi ops per nfs_page */
 	struct page		**pagevec;
 	unsigned int		npages;		/* Max length of pagevec */
 	struct nfs_writeargs	args;		/* argument struct */
 	struct nfs_writeres	res;		/* result struct */
-	struct pnfs_layout_segment *lseg;
-	struct nfs_client	*ds_clp;	/* pNFS data server */
-	const struct rpc_call_ops *mds_ops;
-	int (*write_done_cb) (struct rpc_task *task, struct nfs_write_data *data);
-#ifdef CONFIG_NFS_V4
 	unsigned long		timestamp;	/* For lease renewal */
-#endif
+	int (*write_done_cb) (struct rpc_task *task, struct nfs_write_data *data);
 	__u64			mds_offset;	/* Filelayout dense stripe */
-	int			pnfs_error;
 	struct page		*page_array[NFS_PAGEVEC_SIZE];
+	struct nfs_client	*ds_clp;	/* pNFS data server */
+};
+
+struct nfs_write_header {
+	struct nfs_pgio_header	header;
+	struct nfs_write_data	rpc_data;
 };
 
 struct nfs_commit_data {

commit 0b7c01533aa9f4a228d07d2768d084acb3a387bc
Author: Fred Isaman <iisaman@netapp.com>
Date:   Fri Apr 20 14:47:39 2012 -0400

    NFS: add a struct nfs_commit_data to replace nfs_write_data in commits
    
    Commits don't need the vectors of pages, etc. that writes do. Split out
    a separate structure for the commit operation.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 7ba3551a0414..8fb036a0d489 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -518,6 +518,24 @@ struct nfs_writeres {
 	struct nfs4_sequence_res	seq_res;
 };
 
+/*
+ * Arguments to the commit call.
+ */
+struct nfs_commitargs {
+	struct nfs_fh		*fh;
+	__u64			offset;
+	__u32			count;
+	const u32		*bitmask;
+	struct nfs4_sequence_args	seq_args;
+};
+
+struct nfs_commitres {
+	struct nfs_fattr	*fattr;
+	struct nfs_writeverf	*verf;
+	const struct nfs_server *server;
+	struct nfs4_sequence_res	seq_res;
+};
+
 /*
  * Common arguments to the unlink call
  */
@@ -1171,6 +1189,8 @@ struct nfs_read_data {
 	struct page		*page_array[NFS_PAGEVEC_SIZE];
 };
 
+struct nfs_direct_req;
+
 struct nfs_write_data {
 	struct rpc_task		task;
 	struct inode		*inode;
@@ -1186,7 +1206,6 @@ struct nfs_write_data {
 	struct nfs_writeres	res;		/* result struct */
 	struct pnfs_layout_segment *lseg;
 	struct nfs_client	*ds_clp;	/* pNFS data server */
-	int			ds_commit_index;
 	const struct rpc_call_ops *mds_ops;
 	int (*write_done_cb) (struct rpc_task *task, struct nfs_write_data *data);
 #ifdef CONFIG_NFS_V4
@@ -1197,6 +1216,25 @@ struct nfs_write_data {
 	struct page		*page_array[NFS_PAGEVEC_SIZE];
 };
 
+struct nfs_commit_data {
+	struct rpc_task		task;
+	struct inode		*inode;
+	struct rpc_cred		*cred;
+	struct nfs_fattr	fattr;
+	struct nfs_writeverf	verf;
+	struct list_head	pages;		/* Coalesced requests we wish to flush */
+	struct list_head	list;		/* lists of struct nfs_write_data */
+	struct nfs_direct_req	*dreq;		/* O_DIRECT request */
+	struct nfs_commitargs	args;		/* argument struct */
+	struct nfs_commitres	res;		/* result struct */
+	struct nfs_open_context *context;
+	struct pnfs_layout_segment *lseg;
+	struct nfs_client	*ds_clp;	/* pNFS data server */
+	int			ds_commit_index;
+	const struct rpc_call_ops *mds_ops;
+	int (*commit_done_cb) (struct rpc_task *task, struct nfs_commit_data *data);
+};
+
 struct nfs_unlinkdata {
 	struct hlist_node list;
 	struct nfs_removeargs args;
@@ -1277,8 +1315,9 @@ struct nfs_rpc_ops {
 	void	(*write_setup)  (struct nfs_write_data *, struct rpc_message *);
 	void	(*write_rpc_prepare)(struct rpc_task *, struct nfs_write_data *);
 	int	(*write_done)  (struct rpc_task *, struct nfs_write_data *);
-	void	(*commit_setup) (struct nfs_write_data *, struct rpc_message *);
-	int	(*commit_done) (struct rpc_task *, struct nfs_write_data *);
+	void	(*commit_setup) (struct nfs_commit_data *, struct rpc_message *);
+	void	(*commit_rpc_prepare)(struct rpc_task *, struct nfs_commit_data *);
+	int	(*commit_done) (struct rpc_task *, struct nfs_commit_data *);
 	int	(*lock)(struct file *, int, struct file_lock *);
 	int	(*lock_check_bounds)(const struct file_lock *);
 	void	(*clear_acl_cache)(struct inode *);

commit 95b72eb0bdef6476b7e73061f0382adf46c5495a
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Apr 20 19:24:51 2012 -0400

    NFSv4: Ensure we do not reuse open owner names
    
    The NFSv4 spec is ambiguous about whether or not it is permissible
    to reuse open owner names, so play it safe. This patch adds a timestamp
    to the state_owner structure, and combines that with the IDA based
    uniquifier.
    Fixes a regression whereby the Linux server returns NFS4ERR_BAD_SEQID.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index bfd0d1bf6707..7ba3551a0414 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -312,6 +312,11 @@ struct nfs4_layoutreturn {
 	int rpc_status;
 };
 
+struct stateowner_id {
+	__u64	create_time;
+	__u32	uniquifier;
+};
+
 /*
  * Arguments to the open call.
  */
@@ -321,7 +326,7 @@ struct nfs_openargs {
 	int			open_flags;
 	fmode_t			fmode;
 	__u64                   clientid;
-	__u64                   id;
+	struct stateowner_id	id;
 	union {
 		struct {
 			struct iattr *  attrs;    /* UNCHECKED, GUARDED */

commit c6bfa1a16377b42496ecc0490a33516c0e414e7b
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Mon Mar 19 14:54:42 2012 -0400

    NFS: Remove nfs4_setup_sequence from generic rename code
    
    This is an NFS v4 specific operation, so it belongs in the NFS v4 code
    and not the generic client.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 8d93e688188d..bfd0d1bf6707 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1201,6 +1201,18 @@ struct nfs_unlinkdata {
 	struct nfs_fattr dir_attr;
 };
 
+struct nfs_renamedata {
+	struct nfs_renameargs	args;
+	struct nfs_renameres	res;
+	struct rpc_cred		*cred;
+	struct inode		*old_dir;
+	struct dentry		*old_dentry;
+	struct nfs_fattr	old_fattr;
+	struct inode		*new_dir;
+	struct dentry		*new_dentry;
+	struct nfs_fattr	new_fattr;
+};
+
 struct nfs_access_entry;
 struct nfs_client;
 struct rpc_timeout;
@@ -1235,6 +1247,7 @@ struct nfs_rpc_ops {
 	int	(*rename)  (struct inode *, struct qstr *,
 			    struct inode *, struct qstr *);
 	void	(*rename_setup)  (struct rpc_message *msg, struct inode *dir);
+	void	(*rename_rpc_prepare)(struct rpc_task *task, struct nfs_renamedata *);
 	int	(*rename_done) (struct rpc_task *task, struct inode *old_dir, struct inode *new_dir);
 	int	(*link)    (struct inode *, struct inode *, struct qstr *);
 	int	(*symlink) (struct inode *, struct dentry *, struct page *,

commit 34e137cc7e3b63c254875e59cd48dcbe6757fe6c
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Mon Mar 19 14:54:41 2012 -0400

    NFS: Remove nfs4_setup_sequence from generic unlink code
    
    This is an NFS v4 specific operation, so it belongs in the NFS v4 code
    and not the generic client.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 286d74dde053..8d93e688188d 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1192,6 +1192,15 @@ struct nfs_write_data {
 	struct page		*page_array[NFS_PAGEVEC_SIZE];
 };
 
+struct nfs_unlinkdata {
+	struct hlist_node list;
+	struct nfs_removeargs args;
+	struct nfs_removeres res;
+	struct inode *dir;
+	struct rpc_cred	*cred;
+	struct nfs_fattr dir_attr;
+};
+
 struct nfs_access_entry;
 struct nfs_client;
 struct rpc_timeout;
@@ -1221,6 +1230,7 @@ struct nfs_rpc_ops {
 			    struct iattr *, int, struct nfs_open_context *);
 	int	(*remove)  (struct inode *, struct qstr *);
 	void	(*unlink_setup)  (struct rpc_message *, struct inode *dir);
+	void	(*unlink_rpc_prepare) (struct rpc_task *, struct nfs_unlinkdata *);
 	int	(*unlink_done) (struct rpc_task *, struct inode *);
 	int	(*rename)  (struct inode *, struct qstr *,
 			    struct inode *, struct qstr *);

commit ea7c330362257c072791aeaf03bae2cebf9fb984
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Mon Mar 19 14:54:40 2012 -0400

    NFS: Remove nfs4_setup_sequence from generic read code
    
    This is an NFS v4 specific operation, so it belongs in the NFS v4 code
    and not the generic client.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index b02a5f9eb217..286d74dde053 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1244,6 +1244,7 @@ struct nfs_rpc_ops {
 	int	(*set_capabilities)(struct nfs_server *, struct nfs_fh *);
 	int	(*decode_dirent)(struct xdr_stream *, struct nfs_entry *, int);
 	void	(*read_setup)   (struct nfs_read_data *, struct rpc_message *);
+	void	(*read_rpc_prepare)(struct rpc_task *, struct nfs_read_data *);
 	int	(*read_done)  (struct rpc_task *, struct nfs_read_data *);
 	void	(*write_setup)  (struct nfs_write_data *, struct rpc_message *);
 	void	(*write_rpc_prepare)(struct rpc_task *, struct nfs_write_data *);

commit c6cb80d00be42f30716ec817b963bcec094433b5
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Mon Mar 19 14:54:39 2012 -0400

    NFS: Remove nfs4_setup_sequence from generic write code
    
    This is an NFS v4 specific operation, so it belongs in the NFS v4 code
    and not the generic client.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index c1cf86cceee4..b02a5f9eb217 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1246,6 +1246,7 @@ struct nfs_rpc_ops {
 	void	(*read_setup)   (struct nfs_read_data *, struct rpc_message *);
 	int	(*read_done)  (struct rpc_task *, struct nfs_read_data *);
 	void	(*write_setup)  (struct nfs_write_data *, struct rpc_message *);
+	void	(*write_rpc_prepare)(struct rpc_task *, struct nfs_write_data *);
 	int	(*write_done)  (struct rpc_task *, struct nfs_write_data *);
 	void	(*commit_setup) (struct nfs_write_data *, struct rpc_message *);
 	int	(*commit_done) (struct rpc_task *, struct nfs_write_data *);

commit 8aa0a410af8011d557877e558f9ff17c082c6840
Merge: 54b50af08955 abe9a6d57b45
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sat Mar 3 15:04:15 2012 -0500

    Merge commit 'nfs-for-3.3-4' into nfs-for-next
    
    Conflicts:
            fs/nfs/nfs4proc.c
    
    Back-merge of the upstream kernel in order to fix a conflict with the
    slotid type conversion and implementation id patches...

commit 264e6351c59d22303582c45d79f0a5735f51d8d1
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Thu Mar 1 17:02:05 2012 -0500

    NFS: Request fh_expire_type attribute in "server caps" operation
    
    The fh_expire_type file attribute is a filesystem wide attribute that
    consists of flags that indicate what characteristics file handles
    on this FSID have.
    
    Our client doesn't support volatile file handles.  It should find
    out early (say, at mount time) whether the server is going to play
    shenanighans with file handles during a migration.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 210da5dc4f17..6f4c35941965 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -977,6 +977,7 @@ struct nfs4_server_caps_res {
 	u32				acl_bitmask;
 	u32				has_links;
 	u32				has_symlinks;
+	u32				fh_expire_type;
 	struct nfs4_sequence_res	seq_res;
 };
 

commit 81934ddb8eb62a85b8015c0f2b824a88510965a2
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Thu Mar 1 17:01:57 2012 -0500

    NFS: Introduce NFS_ATTR_FATTR_V4_LOCATIONS
    
    The Linux NFS client must distinguish between referral events (which
    it currently supports) and migration events (which it does not yet
    support).
    
    In both types of events, an fs_locations array is returned.  But upper
    layers, not the XDR layer, should make the distinction between a
    referral and a migration.  There really isn't a way for an XDR decoder
    function to distinguish the two, in general.
    
    Slightly adjust the FATTR flags returned by decode_fs_locations()
    to set NFS_ATTR_FATTR_V4_LOCATIONS only if a non-empty locations
    array was returned from the server.  Then have logic in nfs4proc.c
    distinguish whether the locations array is for a referral or
    something else.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 046c1bfddc33..210da5dc4f17 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -88,11 +88,12 @@ struct nfs_fattr {
 #define NFS_ATTR_FATTR_PRECTIME		(1U << 16)
 #define NFS_ATTR_FATTR_CHANGE		(1U << 17)
 #define NFS_ATTR_FATTR_PRECHANGE	(1U << 18)
-#define NFS_ATTR_FATTR_V4_REFERRAL	(1U << 19)	/* NFSv4 referral */
-#define NFS_ATTR_FATTR_MOUNTPOINT	(1U << 20)	/* Treat as mountpoint */
-#define NFS_ATTR_FATTR_MOUNTED_ON_FILEID		(1U << 21)
-#define NFS_ATTR_FATTR_OWNER_NAME	(1U << 22)
-#define NFS_ATTR_FATTR_GROUP_NAME	(1U << 23)
+#define NFS_ATTR_FATTR_V4_LOCATIONS	(1U << 19)
+#define NFS_ATTR_FATTR_V4_REFERRAL	(1U << 20)
+#define NFS_ATTR_FATTR_MOUNTPOINT	(1U << 21)
+#define NFS_ATTR_FATTR_MOUNTED_ON_FILEID (1U << 22)
+#define NFS_ATTR_FATTR_OWNER_NAME	(1U << 23)
+#define NFS_ATTR_FATTR_GROUP_NAME	(1U << 24)
 
 #define NFS_ATTR_FATTR (NFS_ATTR_FATTR_TYPE \
 		| NFS_ATTR_FATTR_MODE \

commit 7d2ed9ac22bc6bf0d34e8fd291a5295f373b384e
Author: Weston Andros Adamson <dros@netapp.com>
Date:   Fri Feb 17 15:20:26 2012 -0500

    NFSv4: parse and display server implementation ids
    
    Shows the implementation ids in /proc/self/mountstats.  This doesn't break
    the nfs-utils mountstats tool.
    
    Signed-off-by: Weston Andros Adamson <dros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index adbc84ac345f..046c1bfddc33 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1054,14 +1054,6 @@ struct nfstime4 {
 };
 
 #ifdef CONFIG_NFS_V4_1
-struct nfs_impl_id4 {
-	u32		domain_len;
-	char		*domain;
-	u32		name_len;
-	char		*name;
-	struct nfstime4	date;
-};
-
 #define NFS4_EXCHANGE_ID_LEN	(48)
 struct nfs41_exchange_id_args {
 	struct nfs_client		*client;
@@ -1082,10 +1074,17 @@ struct server_scope {
 	char 				server_scope[NFS4_OPAQUE_LIMIT];
 };
 
+struct nfs41_impl_id {
+	char				domain[NFS4_OPAQUE_LIMIT + 1];
+	char				name[NFS4_OPAQUE_LIMIT + 1];
+	struct nfstime4			date;
+};
+
 struct nfs41_exchange_id_res {
 	struct nfs_client		*client;
 	u32				flags;
 	struct server_scope		*server_scope;
+	struct nfs41_impl_id		*impl_id;
 };
 
 struct nfs41_create_session_args {

commit 45d43c291e9a922d7b432b0dbcb1d8fb70d8410f
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Feb 6 19:38:51 2012 -0500

    NFSv4.1: Convert slotid from u8 to u32
    
    It is perfectly legal to negotiate up to 2^32-1 slots in the protocol,
    and with 10GigE, we are already seeing that 255 slots is far too limiting.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 144419a9cbd3..adbc84ac345f 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -181,7 +181,7 @@ struct nfs4_slot {
 
 struct nfs4_sequence_args {
 	struct nfs4_session	*sa_session;
-	u8			sa_slotid;
+	u32			sa_slotid;
 	u8			sa_cache_this;
 };
 

commit 331818f1c468a24e581aedcbe52af799366a9dfe
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Feb 3 18:30:53 2012 -0500

    NFSv4: Fix an Oops in the NFSv4 getacl code
    
    Commit bf118a342f10dafe44b14451a1392c3254629a1f (NFSv4: include bitmap
    in nfsv4 get acl data) introduces the 'acl_scratch' page for the case
    where we may need to decode multi-page data. However it fails to take
    into account the fact that the variable may be NULL (for the case where
    we're not doing multi-page decode), and it also attaches it to the
    encoding xdr_stream rather than the decoding one.
    
    The immediate result is an Oops in nfs4_xdr_enc_getacl due to the
    call to page_address() with a NULL page pointer.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Cc: Andy Adamson <andros@netapp.com>
    Cc: stable@vger.kernel.org

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index a764cef06b73..d6ba9a12591e 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -614,7 +614,6 @@ struct nfs_getaclargs {
 	size_t				acl_len;
 	unsigned int			acl_pgbase;
 	struct page **			acl_pages;
-	struct page *			acl_scratch;
 	struct nfs4_sequence_args 	seq_args;
 };
 
@@ -624,6 +623,7 @@ struct nfs_getaclres {
 	size_t				acl_len;
 	size_t				acl_data_offset;
 	int				acl_flags;
+	struct page *			acl_scratch;
 	struct nfs4_sequence_res	seq_res;
 };
 

commit a613fa168afc19179a7547fbba45644c5b6912bf
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Jan 20 13:53:56 2012 -0500

    SUNRPC: constify the rpc_program
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index f5188e10ea0e..144419a9cbd3 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1274,11 +1274,11 @@ struct nfs_rpc_ops {
 extern const struct nfs_rpc_ops	nfs_v2_clientops;
 extern const struct nfs_rpc_ops	nfs_v3_clientops;
 extern const struct nfs_rpc_ops	nfs_v4_clientops;
-extern struct rpc_version	nfs_version2;
-extern struct rpc_version	nfs_version3;
-extern struct rpc_version	nfs_version4;
+extern const struct rpc_version nfs_version2;
+extern const struct rpc_version nfs_version3;
+extern const struct rpc_version nfs_version4;
 
-extern struct rpc_version	nfsacl_version3;
-extern struct rpc_program	nfsacl_program;
+extern const struct rpc_version nfsacl_version3;
+extern const struct rpc_program nfsacl_program;
 
 #endif

commit 1313e6034a73a55d6293dbdc62b8853dd067771a
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Jan 17 22:04:24 2012 -0500

    NFS: Remove unnecessary includes from linux/nfs_fs_i.h
    
    Also from linux/nfs_xdr.h.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index a764cef06b73..f5188e10ea0e 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -2,7 +2,6 @@
 #define _LINUX_NFS_XDR_H
 
 #include <linux/nfsacl.h>
-#include <linux/nfs3.h>
 #include <linux/sunrpc/gss_api.h>
 
 /*

commit 6926afd1925a54a13684ebe05987868890665e2b
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sat Jan 7 13:22:46 2012 -0500

    NFSv4: Save the owner/group name string when doing open
    
    ...so that we can do the uid/gid mapping outside the asynchronous RPC
    context.
    This fixes a bug in the current NFSv4 atomic open code where the client
    isn't able to determine what the true uid/gid fields of the file are,
    (because the asynchronous nature of the OPEN call denies it the ability
    to do an upcall) and so fills them with default values, marking the
    inode as needing revalidation.
    Unfortunately, in some cases, the VFS will do some additional sanity
    checks on the file, and may override the server's decision to allow
    the open because it sees the wrong owner/group fields.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 6c898afe6095..a764cef06b73 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -18,6 +18,11 @@
 /* Forward declaration for NFS v3 */
 struct nfs4_secinfo_flavors;
 
+struct nfs4_string {
+	unsigned int len;
+	char *data;
+};
+
 struct nfs_fsid {
 	uint64_t		major;
 	uint64_t		minor;
@@ -61,6 +66,8 @@ struct nfs_fattr {
 	struct timespec		pre_ctime;	/* pre_op_attr.ctime	  */
 	unsigned long		time_start;
 	unsigned long		gencount;
+	struct nfs4_string	*owner_name;
+	struct nfs4_string	*group_name;
 };
 
 #define NFS_ATTR_FATTR_TYPE		(1U << 0)
@@ -85,6 +92,8 @@ struct nfs_fattr {
 #define NFS_ATTR_FATTR_V4_REFERRAL	(1U << 19)	/* NFSv4 referral */
 #define NFS_ATTR_FATTR_MOUNTPOINT	(1U << 20)	/* Treat as mountpoint */
 #define NFS_ATTR_FATTR_MOUNTED_ON_FILEID		(1U << 21)
+#define NFS_ATTR_FATTR_OWNER_NAME	(1U << 22)
+#define NFS_ATTR_FATTR_GROUP_NAME	(1U << 23)
 
 #define NFS_ATTR_FATTR (NFS_ATTR_FATTR_TYPE \
 		| NFS_ATTR_FATTR_MODE \
@@ -324,6 +333,7 @@ struct nfs_openargs {
 	const struct qstr *	name;
 	const struct nfs_server *server;	 /* Needed for ID mapping */
 	const u32 *		bitmask;
+	const u32 *		dir_bitmask;
 	__u32			claim;
 	struct nfs4_sequence_args	seq_args;
 };
@@ -342,6 +352,8 @@ struct nfs_openres {
 	__u32			do_recall;
 	__u64			maxsize;
 	__u32			attrset[NFS4_BITMAP_SIZE];
+	struct nfs4_string	*owner;
+	struct nfs4_string	*group_owner;
 	struct nfs4_sequence_res	seq_res;
 };
 
@@ -778,11 +790,6 @@ struct nfs3_getaclres {
 	struct posix_acl *	acl_default;
 };
 
-struct nfs4_string {
-	unsigned int len;
-	char *data;
-};
-
 #ifdef CONFIG_NFS_V4
 
 typedef u64 clientid4;

commit bf118a342f10dafe44b14451a1392c3254629a1f
Author: Andy Adamson <andros@netapp.com>
Date:   Wed Dec 7 11:55:27 2011 -0500

    NFSv4: include bitmap in nfsv4 get acl data
    
    The NFSv4 bitmap size is unbounded: a server can return an arbitrary
    sized bitmap in an FATTR4_WORD0_ACL request.  Replace using the
    nfs4_fattr_bitmap_maxsz as a guess to the maximum bitmask returned by a server
    with the inclusion of the bitmap (xdr length plus bitmasks) and the acl data
    xdr length to the (cached) acl page data.
    
    This is a general solution to commit e5012d1f "NFSv4.1: update
    nfs4_fattr_bitmap_maxsz" and fixes hitting a BUG_ON in xdr_shrink_bufhead
    when getting ACLs.
    
    Fix a bug in decode_getacl that returned -EINVAL on ACLs > page when getxattr
    was called with a NULL buffer, preventing ACL > PAGE_SIZE from being retrieved.
    
    Cc: stable@kernel.org
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 2a7c533be5dd..6c898afe6095 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -602,11 +602,16 @@ struct nfs_getaclargs {
 	size_t				acl_len;
 	unsigned int			acl_pgbase;
 	struct page **			acl_pages;
+	struct page *			acl_scratch;
 	struct nfs4_sequence_args 	seq_args;
 };
 
+/* getxattr ACL interface flags */
+#define NFS4_ACL_LEN_REQUEST	0x0001	/* zero length getxattr buffer */
 struct nfs_getaclres {
 	size_t				acl_len;
+	size_t				acl_data_offset;
+	int				acl_flags;
 	struct nfs4_sequence_res	seq_res;
 };
 

commit 1788ea6e3b2a58cf4fb00206e362d9caff8d86a7
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Nov 4 13:31:21 2011 -0400

    nfs: when attempting to open a directory, fall back on normal lookup (try #5)
    
    commit d953126 changed how nfs_atomic_lookup handles an -EISDIR return
    from an OPEN call. Prior to that patch, that caused the client to fall
    back to doing a normal lookup. When that patch went in, the code began
    returning that error to userspace. The d_revalidate codepath however
    never had the corresponding change, so it was still possible to end up
    with a NULL ctx->state pointer after that.
    
    That patch caused a regression. When we attempt to open a directory that
    does not have a cached dentry, that open now errors out with EISDIR. If
    you attempt the same open with a cached dentry, it will succeed.
    
    Fix this by reverting the change in nfs_atomic_lookup and allowing
    attempts to open directories to fall back to a normal lookup
    
    Also, add a NFSv4-specific f_ops->open routine that just returns
    -ENOTDIR. This should never be called if things are working properly,
    but if it ever is, then the dprintk may help in debugging.
    
    To facilitate this, a new file_operations field is also added to the
    nfs_rpc_ops struct.
    
    Cc: stable@kernel.org
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index c74595ba7094..2a7c533be5dd 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1192,6 +1192,7 @@ struct nfs_rpc_ops {
 	const struct dentry_operations *dentry_ops;
 	const struct inode_operations *dir_inode_ops;
 	const struct inode_operations *file_inode_ops;
+	const struct file_operations *file_ops;
 
 	int	(*getroot) (struct nfs_server *, struct nfs_fh *,
 			    struct nfs_fsinfo *);

commit b8ef70639b609c5d12c618f1d9ffae6ac13aebe3
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Oct 19 12:17:29 2011 -0700

    NFS: Get rid of the unused nfs_write_data->flags field
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index c1cceb83f709..c74595ba7094 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1155,7 +1155,6 @@ struct nfs_read_data {
 };
 
 struct nfs_write_data {
-	int			flags;
 	struct rpc_task		task;
 	struct inode		*inode;
 	struct rpc_cred		*cred;

commit a1940805d0636c6cdf37636f55b43b9681d53e73
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Oct 19 12:17:29 2011 -0700

    NFS: Get rid of the unused nfs_read_data->flags field
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 1e31e1c8655b..c1cceb83f709 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1133,7 +1133,6 @@ struct nfs_page;
 #define NFS_PAGEVEC_SIZE	(8U)
 
 struct nfs_read_data {
-	int			flags;
 	struct rpc_task		task;
 	struct inode		*inode;
 	struct rpc_cred		*cred;

commit 0c2e53f11a6dae9e3af5f50f5ad0382e7c3e0cfa
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Oct 18 16:11:22 2011 -0700

    NFS: Remove the unused "lookupfh()" version of nfs4_proc_lookup()
    
    ...and also remove the associated nfs_v4_clientops entry.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index abd615d74a29..1e31e1c8655b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1197,9 +1197,6 @@ struct nfs_rpc_ops {
 
 	int	(*getroot) (struct nfs_server *, struct nfs_fh *,
 			    struct nfs_fsinfo *);
-	int	(*lookupfh)(struct nfs_server *, struct nfs_fh *,
-			    struct qstr *, struct nfs_fh *,
-			    struct nfs_fattr *);
 	int	(*getattr) (struct nfs_server *, struct nfs_fh *,
 			    struct nfs_fattr *);
 	int	(*setattr) (struct dentry *, struct nfs_fattr *,

commit c2f340a69cabe0fb7b9f02d1a2495927db225a06
Merge: 3ddcd0569cd6 cf283ade08c4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 6 22:56:03 2011 -0700

    Merge branch 'for-linus' of git://git.open-osd.org/linux-open-osd
    
    * 'for-linus' of git://git.open-osd.org/linux-open-osd:
      ore: Make ore its own module
      exofs: Rename raid engine from exofs/ios.c => ore
      exofs: ios: Move to a per inode components & device-table
      exofs: Move exofs specific osd operations out of ios.c
      exofs: Add offset/length to exofs_get_io_state
      exofs: Fix truncate for the raid-groups case
      exofs: Small cleanup of exofs_fill_super
      exofs: BUG: Avoid sbi realloc
      exofs: Remove pnfs-osd private definitions
      nfs_xdr: Move nfs4_string definition out of #ifdef CONFIG_NFS_V4

commit 655b16128482fd12808f77a6799eea5419c93709
Author: Boaz Harrosh <bharrosh@panasas.com>
Date:   Sun May 29 10:57:47 2011 +0300

    nfs_xdr: Move nfs4_string definition out of #ifdef CONFIG_NFS_V4
    
    exofs file system wants to use pnfs_osd_xdr.h file instead of
    redefining pnfs-objects types in it's private "pnfs.h" headr.
    
    Before we do the switch we must make sure pnfs_osd_xdr.h is
    compilable also under NFS versions smaller than 4.1. Since now
    it is needed regardless of version, by the exofs code.
    
    nfs4_string is not the only nfs4 type out in the global scope.
    
    Ack-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 00848d86ffb2..d9f5e8d6ca84 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -759,6 +759,11 @@ struct nfs3_getaclres {
 	struct posix_acl *	acl_default;
 };
 
+struct nfs4_string {
+	unsigned int len;
+	char *data;
+};
+
 #ifdef CONFIG_NFS_V4
 
 typedef u64 clientid4;
@@ -949,11 +954,6 @@ struct nfs4_server_caps_res {
 	struct nfs4_sequence_res	seq_res;
 };
 
-struct nfs4_string {
-	unsigned int len;
-	char *data;
-};
-
 #define NFS4_PATHNAME_MAXCOMPONENTS 512
 struct nfs4_pathname {
 	unsigned int ncomponents;

commit db29c089094b2e686ebc9ed9f002be4a4f94b1f8
Author: Andy Adamson <andros@netapp.com>
Date:   Sat Jul 30 20:52:38 2011 -0400

    pnfs: cleanup_layoutcommit
    
    This gives layout driver a chance to cleanup structures they put in at
    encode_layoutcommit.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    [fixup layout header pointer for layoutcommit]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Benny Halevy <bhalevy@tonian.com>
    [rm inode and pnfs_layout_hdr args from cleanup_layoutcommit()]
    Signed-off-by: Jim Rees <rees@umich.edu>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 94f27e56df9c..569ea5b76fda 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -269,6 +269,7 @@ struct nfs4_layoutcommit_res {
 	struct nfs_fattr *fattr;
 	const struct nfs_server *server;
 	struct nfs4_sequence_res seq_res;
+	int status;
 };
 
 struct nfs4_layoutcommit_data {

commit dae100c2b1b9463996aab9162f2258145c43f7df
Author: Fred Isaman <iisaman@citi.umich.edu>
Date:   Sat Jul 30 20:52:37 2011 -0400

    pnfs: ask for layout_blksize and save it in nfs_server
    
    Block layout needs it to determine IO size.
    
    Signed-off-by: Fred Isaman <iisaman@citi.umich.edu>
    Signed-off-by: Tao Guo <glorioustao@gmail.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Benny Halevy <bhalevy@tonian.com>
    Signed-off-by: Jim Rees <rees@umich.edu>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 21f333eae3c8..94f27e56df9c 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -122,6 +122,7 @@ struct nfs_fsinfo {
 	struct timespec		time_delta; /* server time granularity */
 	__u32			lease_time; /* in seconds */
 	__u32			layouttype; /* supported pnfs layout driver */
+	__u32			blksize; /* preferred pnfs io block size */
 };
 
 struct nfs_fsstat {
@@ -954,7 +955,7 @@ struct nfs4_server_caps_arg {
 };
 
 struct nfs4_server_caps_res {
-	u32				attr_bitmask[2];
+	u32				attr_bitmask[3];
 	u32				acl_bitmask;
 	u32				has_links;
 	u32				has_symlinks;

commit 7f11d8d38d64739e190581e015a2a2730ff54e2a
Author: Andy Adamson <andros@netapp.com>
Date:   Sat Jul 30 20:52:35 2011 -0400

    pnfs: GETDEVICELIST
    
    The block driver uses GETDEVICELIST
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    [pass struct nfs_server * to getdevicelist]
    [get machince creds for getdevicelist]
    [fix getdevicelist decode sizing]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Benny Halevy <bhalevy@tonian.com>
    Signed-off-by: Jim Rees <rees@umich.edu>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index feb312716c07..21f333eae3c8 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -235,6 +235,17 @@ struct nfs4_layoutget {
 	gfp_t gfp_flags;
 };
 
+struct nfs4_getdevicelist_args {
+	const struct nfs_fh *fh;
+	u32 layoutclass;
+	struct nfs4_sequence_args seq_args;
+};
+
+struct nfs4_getdevicelist_res {
+	struct pnfs_devicelist *devlist;
+	struct nfs4_sequence_res seq_res;
+};
+
 struct nfs4_getdeviceinfo_args {
 	struct pnfs_device *pdev;
 	struct nfs4_sequence_args seq_args;

commit a9bae5666d0510ad69bdb437371c9a3e6b770705
Author: Peng Tao <peng_tao@emc.com>
Date:   Sat Jul 30 20:52:33 2011 -0400

    pnfs: let layoutcommit handle a list of lseg
    
    There can be multiple lseg per file, so layoutcommit should be
    able to handle it.
    
    [Needed in v3.0]
    CC: Stable Tree <stable@kernel.org>
    Signed-off-by: Peng Tao <peng_tao@emc.com>
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    Signed-off-by: Jim Rees <rees@umich.edu>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 5b115956abac..feb312716c07 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -262,7 +262,7 @@ struct nfs4_layoutcommit_res {
 struct nfs4_layoutcommit_data {
 	struct rpc_task task;
 	struct nfs_fattr fattr;
-	struct pnfs_layout_segment *lseg;
+	struct list_head lseg_list;
 	struct rpc_cred *cred;
 	struct nfs4_layoutcommit_args args;
 	struct nfs4_layoutcommit_res res;

commit 6e4efd568574221840ee8dd86f176dc977c1330c
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Jul 12 13:42:02 2011 -0400

    NFS: Clean up nfs_read_rpcsetup and nfs_write_rpcsetup
    
    Split them up into two parts: one which sets up the struct nfs_read/write_data,
    the other which sets up the actual RPC call or pNFS call.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 956d3576df7f..5b115956abac 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1126,6 +1126,7 @@ struct nfs_read_data {
 	struct rpc_cred		*cred;
 	struct nfs_fattr	fattr;	/* fattr storage */
 	struct list_head	pages;	/* Coalesced read requests */
+	struct list_head	list;	/* lists of struct nfs_read_data */
 	struct nfs_page		*req;	/* multi ops per nfs_page */
 	struct page		**pagevec;
 	unsigned int		npages;	/* Max length of pagevec */
@@ -1149,6 +1150,7 @@ struct nfs_write_data {
 	struct nfs_fattr	fattr;
 	struct nfs_writeverf	verf;
 	struct list_head	pages;		/* Coalesced requests we wish to flush */
+	struct list_head	list;		/* lists of struct nfs_write_data */
 	struct nfs_page		*req;		/* multi ops per nfs_page */
 	struct page		**pagevec;
 	unsigned int		npages;		/* Max length of pagevec */

commit a56aaa02b1f723e28b41d339ddff02e958d32d43
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Jun 15 11:59:10 2011 -0400

    NFSv4.1: Clean up layoutreturn
    
    Since we take a reference to it, we really ought to pass the a pointer to
    the layout header in the arguments instead of assuming that
    NFS_I(inode)->layout will forever point to the correct object.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 209455561749..956d3576df7f 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -269,9 +269,10 @@ struct nfs4_layoutcommit_data {
 };
 
 struct nfs4_layoutreturn_args {
-	__u32   layout_type;
+	struct pnfs_layout_hdr *layout;
 	struct inode *inode;
 	nfs4_stateid stateid;
+	__u32   layout_type;
 	struct nfs4_sequence_args seq_args;
 };
 

commit 9aeda35fd643eba683fdb8dba8907fa796a85dda
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Thu Jun 2 14:59:09 2011 -0400

    NFS: added FREE_STATEID call
    
    FREE_STATEID is used to tell the server that we want to free a stateid
    that no longer has any locks associated with it.  This allows the client
    to reclaim locks without encountering edge conditions documented in
    section 8.4.3 of RFC 5661.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index e696c1fb139a..209455561749 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1102,6 +1102,16 @@ struct nfs41_test_stateid_res {
 	struct nfs4_sequence_res	seq_res;
 };
 
+struct nfs41_free_stateid_args {
+	nfs4_stateid			*stateid;
+	struct nfs4_sequence_args	seq_args;
+};
+
+struct nfs41_free_stateid_res {
+	unsigned int			status;
+	struct nfs4_sequence_res	seq_res;
+};
+
 #endif /* CONFIG_NFS_V4_1 */
 
 struct nfs_page;

commit 7d9747947ae66d8f6a9a9a023a3a5e28df6a536e
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Thu Jun 2 14:59:08 2011 -0400

    NFS: Added TEST_STATEID call
    
    This patch adds in the xdr for doing a TEST_STATEID call with a single
    stateid. RFC 5661 allows multiple stateids to be tested in a single
    call, but only testing one keeps things simpler for now.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 7159e1da63b6..e696c1fb139a 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1092,6 +1092,16 @@ struct nfs41_secinfo_no_name_args {
 	struct nfs4_sequence_args	seq_args;
 };
 
+struct nfs41_test_stateid_args {
+	nfs4_stateid			*stateid;
+	struct nfs4_sequence_args	seq_args;
+};
+
+struct nfs41_test_stateid_res {
+	unsigned int			status;
+	struct nfs4_sequence_res	seq_res;
+};
+
 #endif /* CONFIG_NFS_V4_1 */
 
 struct nfs_page;

commit fca78d6d2c77f87d7dbee89bbe4836a44da881e2
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Thu Jun 2 14:59:07 2011 -0400

    NFS: Add SECINFO_NO_NAME procedure
    
    If the client is using NFS v4.1, then we can use SECINFO_NO_NAME to find
    the secflavor for the initial mount.  If the server doesn't support
    SECINFO_NO_NAME then I fall back on the "guess and check" method used
    for v4.0 mounts.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index c4d98df884f3..7159e1da63b6 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1084,6 +1084,14 @@ struct nfs41_reclaim_complete_args {
 struct nfs41_reclaim_complete_res {
 	struct nfs4_sequence_res	seq_res;
 };
+
+#define SECINFO_STYLE_CURRENT_FH 0
+#define SECINFO_STYLE_PARENT 1
+struct nfs41_secinfo_no_name_args {
+	int				style;
+	struct nfs4_sequence_args	seq_args;
+};
+
 #endif /* CONFIG_NFS_V4_1 */
 
 struct nfs_page;

commit 78fe0f41d9937ee62817912ac8d627e06243c269
Author: Weston Andros Adamson <dros@netapp.com>
Date:   Tue May 31 19:05:47 2011 -0400

    NFS: use scope from exchange_id to skip reclaim
    
    can be skipped if the "eir_server_scope" from the exchange_id proc differs from
    previous calls.
    
    Also, in the future server_scope will be useful for determining whether client
    trunking is available
    
    Signed-off-by: Weston Andros Adamson <dros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 00848d86ffb2..c4d98df884f3 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1060,6 +1060,7 @@ struct server_scope {
 struct nfs41_exchange_id_res {
 	struct nfs_client		*client;
 	u32				flags;
+	struct server_scope		*server_scope;
 };
 
 struct nfs41_create_session_args {

commit c9c30dd5f73dccaa326a54dfcf490316946aea87
Author: Benny Halevy <benny@tonian.com>
Date:   Sat Jun 11 17:08:39 2011 -0400

    NFSv4.1: deprecate headerpadsz in CREATE_SESSION
    
    We don't support header padding yet so better off ditching it
    
    Reported-by: Sid Moore <learnmost@gmail.com>
    Signed-off-by: Benny Halevy <benny@tonian.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 5e8444a11adf..00848d86ffb2 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -158,7 +158,6 @@ struct nfs_seqid;
 
 /* nfs41 sessions channel attributes */
 struct nfs4_channel_attrs {
-	u32			headerpadsz;
 	u32			max_rqst_sz;
 	u32			max_resp_sz;
 	u32			max_resp_sz_cached;

commit cbe8260369c9f88eafa035cd327dc3e02fad528c
Author: Benny Halevy <bhalevy@panasas.com>
Date:   Sun May 22 19:52:37 2011 +0300

    pnfs: layoutreturn
    
    NFSv4.1 LAYOUTRETURN implementation
    
    Currently, does not support layout-type payload encoding.
    
    Signed-off-by: Alexandros Batsakis <batsakis@netapp.com>
    Signed-off-by: Andy Adamson <andros@citi.umich.edu>
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Dean Hildebrand <dhildeb@us.ibm.com>
    Signed-off-by: Fred Isaman <iisaman@citi.umich.edu>
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Marc Eshel <eshel@almaden.ibm.com>
    Signed-off-by: Zhang Jingwang <zhangjingwang@nrchpc.ac.cn>
    [call pnfs_return_layout right before pnfs_destroy_layout]
    [remove assert_spin_locked from pnfs_clear_lseg_list]
    [remove wait parameter from the layoutreturn path.]
    [remove return_type field from nfs4_layoutreturn_args]
    [remove range from nfs4_layoutreturn_args]
    [no need to send layoutcommit from _pnfs_return_layout]
    [don't wait on sync layoutreturn]
    [fix layout stateid in layoutreturn args]
    [fixed NULL deref in _pnfs_return_layout]
    [removed recaim member of nfs4_layoutreturn_args]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 7c8ff0984a84..5e8444a11adf 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -269,6 +269,27 @@ struct nfs4_layoutcommit_data {
 	struct nfs4_layoutcommit_res res;
 };
 
+struct nfs4_layoutreturn_args {
+	__u32   layout_type;
+	struct inode *inode;
+	nfs4_stateid stateid;
+	struct nfs4_sequence_args seq_args;
+};
+
+struct nfs4_layoutreturn_res {
+	struct nfs4_sequence_res seq_res;
+	u32 lrs_present;
+	nfs4_stateid stateid;
+};
+
+struct nfs4_layoutreturn {
+	struct nfs4_layoutreturn_args args;
+	struct nfs4_layoutreturn_res res;
+	struct rpc_cred *cred;
+	struct nfs_client *clp;
+	int rpc_status;
+};
+
 /*
  * Arguments to the open call.
  */

commit d20581aa4be11407c9eeeb75992df5ef176bba0f
Author: Benny Halevy <bhalevy@panasas.com>
Date:   Sun May 22 19:52:03 2011 +0300

    pnfs: support for non-rpc layout drivers
    
    Non-rpc layout driver such as for objects and blocks
    implement their own I/O path and error handling logic.
    Therefore bypass NFS-based error handling for these layout drivers.
    
    [fix lseg ref-count bugs, and null de-refs]
    [Fall out from: non-rpc layout drivers]
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    [get rid of PNFS_USE_RPC_CODE]
    [get rid of __nfs4_write_done_cb]
    [revert useless change in nfs4_write_done_cb]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 7e371f7df9c4..7c8ff0984a84 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1087,6 +1087,7 @@ struct nfs_read_data {
 	const struct rpc_call_ops *mds_ops;
 	int (*read_done_cb) (struct rpc_task *task, struct nfs_read_data *data);
 	__u64			mds_offset;
+	int			pnfs_error;
 	struct page		*page_array[NFS_PAGEVEC_SIZE];
 };
 
@@ -1112,6 +1113,7 @@ struct nfs_write_data {
 	unsigned long		timestamp;	/* For lease renewal */
 #endif
 	__u64			mds_offset;	/* Filelayout dense stripe */
+	int			pnfs_error;
 	struct page		*page_array[NFS_PAGEVEC_SIZE];
 };
 

commit a75b9df9d3bfc3cd1083974c045ae31ce5f3434f
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed May 11 18:00:51 2011 -0400

    NFSv4.1: Ensure that layoutget uses the correct gfp modes
    
    Currently, writebacks may end up recursing back into the filesystem due to
    GFP_KERNEL direct reclaims in the pnfs subsystem.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 890dce242639..7e371f7df9c4 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -233,6 +233,7 @@ struct nfs4_layoutget {
 	struct nfs4_layoutget_args args;
 	struct nfs4_layoutget_res res;
 	struct pnfs_layout_segment **lsegpp;
+	gfp_t gfp_flags;
 };
 
 struct nfs4_getdeviceinfo_args {

commit 28331a46d88459788c8fca72dbb0415cd7f514c9
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Apr 27 13:47:52 2011 -0400

    NFSv4: Ensure we request the ordinary fileid when doing readdirplus
    
    When readdir() returns a directory entry for the root of a mounted
    filesystem, Linux follows the old convention of returning the inode
    number of the covered directory (despite newer versions of POSIX declaring
    that this is a bug).
    To ensure this continues to work, the NFSv4 readdir implementation requests
    the 'mounted-on-fileid' from the server.
    
    However, readdirplus also needs to instantiate an inode for this entry, and
    for that, we also need to request the real fileid as per this patch.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 78b101e487ea..890dce242639 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -50,6 +50,7 @@ struct nfs_fattr {
 	} du;
 	struct nfs_fsid		fsid;
 	__u64			fileid;
+	__u64			mounted_on_fileid;
 	struct timespec		atime;
 	struct timespec		mtime;
 	struct timespec		ctime;
@@ -83,6 +84,7 @@ struct nfs_fattr {
 #define NFS_ATTR_FATTR_PRECHANGE	(1U << 18)
 #define NFS_ATTR_FATTR_V4_REFERRAL	(1U << 19)	/* NFSv4 referral */
 #define NFS_ATTR_FATTR_MOUNTPOINT	(1U << 20)	/* Treat as mountpoint */
+#define NFS_ATTR_FATTR_MOUNTED_ON_FILEID		(1U << 21)
 
 #define NFS_ATTR_FATTR (NFS_ATTR_FATTR_TYPE \
 		| NFS_ATTR_FATTR_MODE \

commit 0acd2201920d0968919f4f5797d63f7b6f2b19d4
Merge: 8f70e95f9f41 35124a0994fc
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Mar 24 17:03:14 2011 -0400

    Merge branch 'nfs-for-2.6.39' into nfs-for-next

commit 35124a0994fc02545b14b9fa3aad000b3331f1c0
Author: Weston Andros Adamson <dros@netapp.com>
Date:   Thu Mar 24 16:48:21 2011 -0400

    Cleanup XDR parsing for LAYOUTGET, GETDEVICEINFO
    
    changes LAYOUTGET and GETDEVICEINFO XDR parsing to:
     - not use vmap, which doesn't work on incoherent archs
     - use xdr_stream parsing for all xdr
    
    Signed-off-by: Weston Andros Adamson <dros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 84f3585c5728..a6e21b10f43d 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -190,8 +190,9 @@ struct nfs4_get_lease_time_res {
 #define PNFS_LAYOUT_MAXSIZE 4096
 
 struct nfs4_layoutdriver_data {
+	struct page **pages;
+	__u32 pglen;
 	__u32 len;
-	void *buf;
 };
 
 struct pnfs_layout_range {
@@ -209,6 +210,7 @@ struct nfs4_layoutget_args {
 	struct nfs_open_context *ctx;
 	struct nfs4_sequence_args seq_args;
 	nfs4_stateid stateid;
+	struct nfs4_layoutdriver_data layout;
 };
 
 struct nfs4_layoutget_res {
@@ -216,8 +218,8 @@ struct nfs4_layoutget_res {
 	struct pnfs_layout_range range;
 	__u32 type;
 	nfs4_stateid stateid;
-	struct nfs4_layoutdriver_data layout;
 	struct nfs4_sequence_res seq_res;
+	struct nfs4_layoutdriver_data *layoutp;
 };
 
 struct nfs4_layoutget {

commit 7ebb931598cd95cccea10d4bc4c0123a464ea565
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Thu Mar 24 17:12:30 2011 +0000

    NFS: use secinfo when crossing mountpoints
    
    A submount may use different security than the parent
    mount does.  We should figure out what sec flavor the
    submount uses at mount time.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 3f32bf175840..fa1ba78ca2c8 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -82,6 +82,7 @@ struct nfs_fattr {
 #define NFS_ATTR_FATTR_CHANGE		(1U << 17)
 #define NFS_ATTR_FATTR_PRECHANGE	(1U << 18)
 #define NFS_ATTR_FATTR_V4_REFERRAL	(1U << 19)	/* NFSv4 referral */
+#define NFS_ATTR_FATTR_MOUNTPOINT	(1U << 20)	/* Treat as mountpoint */
 
 #define NFS_ATTR_FATTR (NFS_ATTR_FATTR_TYPE \
 		| NFS_ATTR_FATTR_MODE \

commit 5a5ea0d485c9715c86bf858bbdc5f6d373b3db88
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Thu Mar 24 17:12:29 2011 +0000

    NFS: Add secinfo procedure
    
    This patch adds the nfs4 operation secinfo as a
    valid nfs rpc operation.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 71ee6799db9b..3f32bf175840 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -3,6 +3,7 @@
 
 #include <linux/nfsacl.h>
 #include <linux/nfs3.h>
+#include <linux/sunrpc/gss_api.h>
 
 /*
  * To change the maximum rsize and wsize supported by the NFS client, adjust
@@ -14,6 +15,9 @@
 #define NFS_DEF_FILE_IO_SIZE	(4096U)
 #define NFS_MIN_FILE_IO_SIZE	(1024U)
 
+/* Forward declaration for NFS v3 */
+struct nfs4_secinfo_flavors;
+
 struct nfs_fsid {
 	uint64_t		major;
 	uint64_t		minor;
@@ -936,6 +940,38 @@ struct nfs4_fs_locations_res {
 	struct nfs4_sequence_res	seq_res;
 };
 
+struct nfs4_secinfo_oid {
+	unsigned int len;
+	char data[GSS_OID_MAX_LEN];
+};
+
+struct nfs4_secinfo_gss {
+	struct nfs4_secinfo_oid sec_oid4;
+	unsigned int qop4;
+	unsigned int service;
+};
+
+struct nfs4_secinfo_flavor {
+	unsigned int 		flavor;
+	struct nfs4_secinfo_gss	gss;
+};
+
+struct nfs4_secinfo_flavors {
+	unsigned int num_flavors;
+	struct nfs4_secinfo_flavor flavors[0];
+};
+
+struct nfs4_secinfo_arg {
+	const struct nfs_fh		*dir_fh;
+	const struct qstr		*name;
+	struct nfs4_sequence_args	seq_args;
+};
+
+struct nfs4_secinfo_res {
+	struct nfs4_secinfo_flavors	*flavors;
+	struct nfs4_sequence_res	seq_res;
+};
+
 #endif /* CONFIG_NFS_V4 */
 
 struct nfstime4 {
@@ -1118,6 +1154,7 @@ struct nfs_rpc_ops {
 				struct iattr *iattr);
 	int	(*init_client) (struct nfs_client *, const struct rpc_timeout *,
 				const char *, rpc_authflavor_t, int);
+	int	(*secinfo)(struct inode *, const struct qstr *, struct nfs4_secinfo_flavors *);
 };
 
 /*

commit 7c5130588d691a3b34d02312f1bd1b6d56fe0100
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Thu Mar 24 17:12:24 2011 +0000

    NFS: lookup supports alternate client
    
    A later patch will need to perform a lookup using an
    alternate client with a different security flavor.
    This patch adds support for doing that on NFS v4.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 2c2c67d2eb42..71ee6799db9b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1071,7 +1071,7 @@ struct nfs_rpc_ops {
 			    struct nfs_fattr *);
 	int	(*setattr) (struct dentry *, struct nfs_fattr *,
 			    struct iattr *);
-	int	(*lookup)  (struct inode *, struct qstr *,
+	int	(*lookup)  (struct rpc_clnt *clnt, struct inode *, struct qstr *,
 			    struct nfs_fh *, struct nfs_fattr *);
 	int	(*access)  (struct inode *, struct nfs_access_entry *);
 	int	(*readlink)(struct inode *, struct page *, unsigned int,

commit 863a3c6c686d5773f7192a4818769e15db12ce08
Author: Andy Adamson <andros@netapp.com>
Date:   Wed Mar 23 13:27:54 2011 +0000

    NFSv4.1: layoutcommit
    
    The filelayout driver sends LAYOUTCOMMIT only when COMMIT goes to
    the data server (as opposed to the MDS) and the data server WRITE
    is not NFS_FILE_SYNC.
    
    Only whole file layout support means that there is only one IOMODE_RW layout
    segment.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Alexandros Batsakis <batsakis@netapp.com>
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    Signed-off-by: Dean Hildebrand <dhildeb@us.ibm.com>
    Signed-off-by: Fred Isaman <iisaman@citi.umich.edu>
    Signed-off-by: Mingyang Guo <guomingyang@nrchpc.ac.cn>
    Signed-off-by: Tao Guo <guotao@nrchpc.ac.cn>
    Signed-off-by: Zhang Jingwang <zhangjingwang@nrchpc.ac.cn>
    Tested-by: Boaz Harrosh <bharrosh@panasas.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index ac0c0e51786e..84f3585c5728 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -236,6 +236,29 @@ struct nfs4_getdeviceinfo_res {
 	struct nfs4_sequence_res seq_res;
 };
 
+struct nfs4_layoutcommit_args {
+	nfs4_stateid stateid;
+	__u64 lastbytewritten;
+	struct inode *inode;
+	const u32 *bitmask;
+	struct nfs4_sequence_args seq_args;
+};
+
+struct nfs4_layoutcommit_res {
+	struct nfs_fattr *fattr;
+	const struct nfs_server *server;
+	struct nfs4_sequence_res seq_res;
+};
+
+struct nfs4_layoutcommit_data {
+	struct rpc_task task;
+	struct nfs_fattr fattr;
+	struct pnfs_layout_segment *lseg;
+	struct rpc_cred *cred;
+	struct nfs4_layoutcommit_args args;
+	struct nfs4_layoutcommit_res res;
+};
+
 /*
  * Arguments to the open call.
  */

commit e0c2b3801828aadb65dec9f67f7c6b7a675ad007
Author: Fred Isaman <iisaman@netapp.com>
Date:   Wed Mar 23 13:27:53 2011 +0000

    NFSv4.1: filelayout driver specific code for COMMIT
    
    Implement all the hooks created in the previous patches.
    This requires exporting quite a few functions and adding a few
    structure fields.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 2c2c67d2eb42..ac0c0e51786e 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1040,6 +1040,7 @@ struct nfs_write_data {
 	struct nfs_writeres	res;		/* result struct */
 	struct pnfs_layout_segment *lseg;
 	struct nfs_client	*ds_clp;	/* pNFS data server */
+	int			ds_commit_index;
 	const struct rpc_call_ops *mds_ops;
 	int (*write_done_cb) (struct rpc_task *task, struct nfs_write_data *data);
 #ifdef CONFIG_NFS_V4

commit e0dca7a05df4e23a8f5b07742e99e2a6f7d67db1
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Mar 14 18:20:01 2011 -0400

    NFS: Fix a warning in fs/nfs/idmap.c
    
    Commit 45a52a02072b2a7e265f024cfdb00127e08dd9f2 (NFS move nfs_client
    initialization into nfs_get_client) introduces a new warning in
    fs/nfs/idmap.c:
    
            ‘struct rpc_timeout’ declared inside parameter list
    
    Fix it by adding a forward declaration for the struct rpc_timeout
    in include/linux/nfs_xdr.h
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 3440f5ab0f54..2c2c67d2eb42 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1051,6 +1051,7 @@ struct nfs_write_data {
 
 struct nfs_access_entry;
 struct nfs_client;
+struct rpc_timeout;
 
 /*
  * RPC procedure vector for NFSv2/NFSv3 demuxing

commit a69aef1496726ed88386dad65abfcc8cd3195304
Author: Fred Isaman <iisaman@netapp.com>
Date:   Thu Mar 3 15:13:47 2011 +0000

    NFSv4.1: pnfs filelayout driver write
    
    Allows the pnfs filelayout driver to write to the data servers.
    
    Note that COMMIT to data servers will be implemented in a future
    patch.  To avoid improper behavior, for the moment any WRITE to a data
    server that would also require a COMMIT to the data server is sent
    NFS_FILE_SYNC.
    
    Signed-off-by: Andy Adamson <andros@citi.umich.edu>
    Signed-off-by: Dean Hildebrand <dhildeb@us.ibm.com>
    Signed-off-by: Fred Isaman <iisaman@citi.umich.edu>
    Signed-off-by: Mingyang Guo <guomingyang@nrchpc.ac.cn>
    Signed-off-by: Oleg Drokin <green@linuxhacker.ru>
    Signed-off-by: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index c82ad33cffe1..3440f5ab0f54 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1039,11 +1039,13 @@ struct nfs_write_data {
 	struct nfs_writeargs	args;		/* argument struct */
 	struct nfs_writeres	res;		/* result struct */
 	struct pnfs_layout_segment *lseg;
+	struct nfs_client	*ds_clp;	/* pNFS data server */
 	const struct rpc_call_ops *mds_ops;
 	int (*write_done_cb) (struct rpc_task *task, struct nfs_write_data *data);
 #ifdef CONFIG_NFS_V4
 	unsigned long		timestamp;	/* For lease renewal */
 #endif
+	__u64			mds_offset;	/* Filelayout dense stripe */
 	struct page		*page_array[NFS_PAGEVEC_SIZE];
 };
 

commit 0382b74409c6b9ef12c952b50bb44f557a361a43
Author: Andy Adamson <andros@netapp.com>
Date:   Thu Mar 3 15:13:45 2011 +0000

    NFSv4.1: implement generic pnfs layer write switch
    
    Signed-off-by: Andy Adamson <andros@citi.umich.edu>
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    Signed-off-by: Dean Hildebrand <dhildeb@us.ibm.com>
    Signed-off-by: Fred Isaman <iisaman@citi.umich.edu>
    Signed-off-by: J. Bruce Fields <bfields@fieldses.org>
    Signed-off-by: Mike Sager <sager@netapp.com>
    Signed-off-by: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
    Signed-off-by: Tao Guo <guotao@nrchpc.ac.cn>
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 09d96812d6d0..c82ad33cffe1 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1039,6 +1039,7 @@ struct nfs_write_data {
 	struct nfs_writeargs	args;		/* argument struct */
 	struct nfs_writeres	res;		/* result struct */
 	struct pnfs_layout_segment *lseg;
+	const struct rpc_call_ops *mds_ops;
 	int (*write_done_cb) (struct rpc_task *task, struct nfs_write_data *data);
 #ifdef CONFIG_NFS_V4
 	unsigned long		timestamp;	/* For lease renewal */

commit 5053aa568d4017aeb1fa35247d4ad96be262920f
Author: Fred Isaman <iisaman@netapp.com>
Date:   Thu Mar 3 15:13:43 2011 +0000

    NFSv4.1: Send lseg down into nfs_write_rpcsetup
    
    We grab the lseg sent in from the doio function and attach it to
    each struct nfs_write_data created.  This is how the lseg will be
    sent to the layout driver.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 21cd41ddbca6..09d96812d6d0 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1038,6 +1038,7 @@ struct nfs_write_data {
 	unsigned int		npages;		/* Max length of pagevec */
 	struct nfs_writeargs	args;		/* argument struct */
 	struct nfs_writeres	res;		/* result struct */
+	struct pnfs_layout_segment *lseg;
 	int (*write_done_cb) (struct rpc_task *task, struct nfs_write_data *data);
 #ifdef CONFIG_NFS_V4
 	unsigned long		timestamp;	/* For lease renewal */

commit b029bc9b0880cbaf999f580c0ea8f06dd274fc77
Author: Fred Isaman <iisaman@netapp.com>
Date:   Thu Mar 3 15:13:42 2011 +0000

    NFSv4.1: add callback to nfs4_write_done
    
    Add callback that pnfs layout driver can use to do its own handling
    of data server WRITE response.
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index eb0e87084353..21cd41ddbca6 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1038,6 +1038,7 @@ struct nfs_write_data {
 	unsigned int		npages;		/* Max length of pagevec */
 	struct nfs_writeargs	args;		/* argument struct */
 	struct nfs_writeres	res;		/* result struct */
+	int (*write_done_cb) (struct rpc_task *task, struct nfs_write_data *data);
 #ifdef CONFIG_NFS_V4
 	unsigned long		timestamp;	/* For lease renewal */
 #endif

commit cbdabc7f8bf14ca1d40ab1cb86f64b3bc09716e8
Author: Andy Adamson <andros@netapp.com>
Date:   Tue Mar 1 01:34:20 2011 +0000

    NFSv4.1: filelayout async error handler
    
    Use our own async error handler.
    Mark the layout as failed and retry i/o through the MDS on specified errors.
    
    Update the mds_offset in nfs_readpage_retry so that a failed short-read retry
    to a DS gets correctly resent through the MDS.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index b63faef5052e..eb0e87084353 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1020,6 +1020,7 @@ struct nfs_read_data {
 	struct pnfs_layout_segment *lseg;
 	struct nfs_client	*ds_clp;	/* pNFS data server */
 	const struct rpc_call_ops *mds_ops;
+	int (*read_done_cb) (struct rpc_task *task, struct nfs_read_data *data);
 	__u64			mds_offset;
 	struct page		*page_array[NFS_PAGEVEC_SIZE];
 };

commit dc70d7b3189597f313df7bd2da849cfc39063b15
Author: Andy Adamson <andros@netapp.com>
Date:   Tue Mar 1 01:34:19 2011 +0000

    NFSv4.1: filelayout read
    
    Attempt a pNFS file layout read by setting up the nfs_read_data struct and
    calling nfs_initiate_read with the data server rpc client and the
    filelayout rpc call ops.
    
    Error handling is implemented in a subsequent patch.
    
    Signed-off-by: Andy Adamson <andros@citi.umich.edu>
    Signed-off-by: Dean Hildebrand <dhildeb@us.ibm.com>
    Signed-off-by: Fred Isaman <iisaman@citi.umich.edu>
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Mingyang Guo <guomingyang@nrchpc.ac.cn>
    Signed-off-by: Oleg Drokin <green@linuxhacker.ru>
    Signed-off-by: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
    Tested-by: Guo Mingyang <guomingyang@nrchpc.ac.cn>
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index c66ff7fe1b6b..b63faef5052e 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1020,6 +1020,7 @@ struct nfs_read_data {
 	struct pnfs_layout_segment *lseg;
 	struct nfs_client	*ds_clp;	/* pNFS data server */
 	const struct rpc_call_ops *mds_ops;
+	__u64			mds_offset;
 	struct page		*page_array[NFS_PAGEVEC_SIZE];
 };
 

commit d83217c13531fd59730d77b5c2284e90e56c0a50
Author: Andy Adamson <andros@netapp.com>
Date:   Tue Mar 1 01:34:17 2011 +0000

    NFSv4.1: data server connection
    
    Introduce a data server set_client and init session following the
    nfs4_set_client and  nfs4_init_session convention.
    
    Once a new nfs_client is on the nfs_client_list, the nfs_client cl_cons_state
    serializes access to creating an nfs_client struct with matching properties.
    
    Use the new nfs_get_client() that initializes new clients.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 9d2b9dae277d..c66ff7fe1b6b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1018,6 +1018,7 @@ struct nfs_read_data {
 	struct nfs_readres  res;
 	unsigned long		timestamp;	/* For lease renewal */
 	struct pnfs_layout_segment *lseg;
+	struct nfs_client	*ds_clp;	/* pNFS data server */
 	const struct rpc_call_ops *mds_ops;
 	struct page		*page_array[NFS_PAGEVEC_SIZE];
 };

commit 64419a9b20938d9070fdd8c58c2fa23c911915f8
Author: Andy Adamson <andros@netapp.com>
Date:   Tue Mar 1 01:34:16 2011 +0000

    NFSv4.1: generic read
    
    Separate the rpc run portion of nfs_read_rpcsetup into a new function
    nfs_initiate_read that is called for normal NFS I/O.
    
    Add a pNFS read_pagelist function that is called instead of nfs_intitate_read
    for pNFS reads.
    
    Signed-off-by: Andy Adamson <andros@citi.umich.edu>
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    Signed-off-by: Dean Hildebrand <dhildeb@us.ibm.com>
    Signed-off-by: Fred Isaman <iisaman@citi.umich.edu>
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Mike Sager <sager@netapp.com>
    Signed-off-by: Mingyang Guo <guomingyang@nrchpc.ac.cn>
    Signed-off-by: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
    Signed-off-by: Tao Guo <guotao@nrchpc.ac.cn>
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 560923e28723..9d2b9dae277d 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1018,6 +1018,7 @@ struct nfs_read_data {
 	struct nfs_readres  res;
 	unsigned long		timestamp;	/* For lease renewal */
 	struct pnfs_layout_segment *lseg;
+	const struct rpc_call_ops *mds_ops;
 	struct page		*page_array[NFS_PAGEVEC_SIZE];
 };
 

commit bae724ef95b0d0a1f4518f5451e7c8aabc41f820
Author: Fred Isaman <iisaman@netapp.com>
Date:   Tue Mar 1 01:34:15 2011 +0000

    NFSv4.1: shift pnfs_update_layout locations
    
    Move the pnfs_update_layout call location to nfs_pageio_do_add_request().
    Grab the lseg sent in the doio function to nfs_read_rpcsetup and attach
    it to each nfs_read_data so it can be sent to the layout driver.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Andy Adamson <andros@citi.umich.edu>
    Signed-off-by: Dean Hildebrand <dhildeb@us.ibm.com>
    Signed-off-by: Fred Isaman <iisaman@citi.umich.edu>
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    Signed-off-by: Oleg Drokin <green@linuxhacker.ru>
    Signed-off-by: Tao Guo <guotao@nrchpc.ac.cn>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index d159fe733381..560923e28723 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1017,6 +1017,7 @@ struct nfs_read_data {
 	struct nfs_readargs args;
 	struct nfs_readres  res;
 	unsigned long		timestamp;	/* For lease renewal */
+	struct pnfs_layout_segment *lseg;
 	struct page		*page_array[NFS_PAGEVEC_SIZE];
 };
 

commit 45a52a02072b2a7e265f024cfdb00127e08dd9f2
Author: Andy Adamson <andros@netapp.com>
Date:   Tue Mar 1 01:34:08 2011 +0000

    NFS move nfs_client initialization into nfs_get_client
    
    Now nfs_get_client returns an nfs_client ready to be used no matter if it was
    found or created.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 51bfadbe24e2..d159fe733381 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1040,6 +1040,7 @@ struct nfs_write_data {
 };
 
 struct nfs_access_entry;
+struct nfs_client;
 
 /*
  * RPC procedure vector for NFSv2/NFSv3 demuxing
@@ -1104,6 +1105,8 @@ struct nfs_rpc_ops {
 				struct nfs_open_context *ctx,
 				int open_flags,
 				struct iattr *iattr);
+	int	(*init_client) (struct nfs_client *, const struct rpc_timeout *,
+				const char *, rpc_authflavor_t, int);
 };
 
 /*

commit 6f78befc417dd7122249706b49520da29ba58451
Author: Andy Adamson <andros@netapp.com>
Date:   Tue Mar 1 01:34:06 2011 +0000

    NFSv4: remove CONFIG_NFS_V4 from nfs_read_data
    
    Cleanup nfs_read_data. We also won't use CONFIG_NFS_V4_1 for additional
    NFSv4.1 fields in subsequent patches.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index b0068579bec2..51bfadbe24e2 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1016,9 +1016,7 @@ struct nfs_read_data {
 	unsigned int		npages;	/* Max length of pagevec */
 	struct nfs_readargs args;
 	struct nfs_readres  res;
-#ifdef CONFIG_NFS_V4
 	unsigned long		timestamp;	/* For lease renewal */
-#endif
 	struct page		*page_array[NFS_PAGEVEC_SIZE];
 };
 

commit d035c36c58dd9183ad6aa7875dea89893faedb55
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Dec 21 10:45:27 2010 -0500

    NFSv4: Ensure continued open and lockowner name uniqueness
    
    In order to enable migration support, we will want to move some of the
    structures that are subject to migration into the struct nfs_server.
    In particular, if we are to move the state_owner and state_owner_id to
    being a per-filesystem structure, then we should label the resulting
    open/lock owners with a per-filesytem label to ensure global uniqueness.
    
    This patch does so by adding the super block s_dev to the open/lock owner
    name.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 83d36d3a12e6..b0068579bec2 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -317,6 +317,7 @@ struct nfs_closeres {
 struct nfs_lowner {
 	__u64			clientid;
 	__u64			id;
+	dev_t			s_dev;
 };
 
 struct nfs_lock_args {

commit cf7d63f1f9895713551df2e6d18b006f8af26e91
Author: Fred Isaman <iisaman@netapp.com>
Date:   Thu Jan 6 11:36:25 2011 +0000

    pnfs: serialize LAYOUTGET(openstateid)
    
    We shouldn't send a LAYOUTGET(openstateid) unless all outstanding RPCs
    using the previous stateid are completed.  This requires choosing the
    stateid to encode earlier, so we can abort if one is not available (we
    want to use the open stateid, but a LAYOUTGET is already out using
    it), and adding a count of the number of outstanding rpc calls using
    layout state (which for now consist solely of LAYOUTGETs).
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 8fcc54267bba..83d36d3a12e6 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -208,6 +208,7 @@ struct nfs4_layoutget_args {
 	struct inode *inode;
 	struct nfs_open_context *ctx;
 	struct nfs4_sequence_args seq_args;
+	nfs4_stateid stateid;
 };
 
 struct nfs4_layoutget_res {

commit daaa82d1c72e10dc16cad3a810e225f9188dc7aa
Author: Fred Isaman <iisaman@netapp.com>
Date:   Thu Jan 6 11:36:19 2011 +0000

    pnfs: remove unnecessary field lgp->status
    
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 236e7e4b99a0..8fcc54267bba 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -223,7 +223,6 @@ struct nfs4_layoutget {
 	struct nfs4_layoutget_args args;
 	struct nfs4_layoutget_res res;
 	struct pnfs_layout_segment **lsegpp;
-	int status;
 };
 
 struct nfs4_getdeviceinfo_args {

commit 573c4e1ef53a6b891b73cc2257e1604da754a2e4
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Dec 14 14:58:11 2010 +0000

    NFS: Simplify ->decode_dirent() calling sequence
    
    Clean up.
    
    The pointer returned by ->decode_dirent() is no longer used as a
    pointer.  The only call site (xdr_decode() in fs/nfs/dir.c) simply
    extracts the errno value encoded in the pointer.  Replace the
    returned pointer with a standard integer errno return value.
    
    Also, pass the "server" argument as part of the nfs_entry instead of
    as a separate parameter.  It's faster to derive "server" in
    nfs_readdir_xdr_to_array() since we already have the directory's inode
    handy.  "server" ought to be invariant for a set of entries in the
    same directory, right?
    
    The legacy versions of decode_dirent() don't use "server" anyway, so
    it's wasted work for them to derive and pass "server" for each entry.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Tested-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 80f07198a31a..236e7e4b99a0 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -484,6 +484,7 @@ struct nfs_entry {
 	struct nfs_fh *		fh;
 	struct nfs_fattr *	fattr;
 	unsigned char		d_type;
+	struct nfs_server *	server;
 };
 
 /*
@@ -1089,7 +1090,7 @@ struct nfs_rpc_ops {
 	int	(*pathconf) (struct nfs_server *, struct nfs_fh *,
 			     struct nfs_pathconf *);
 	int	(*set_capabilities)(struct nfs_server *, struct nfs_fh *);
-	__be32 *(*decode_dirent)(struct xdr_stream *, struct nfs_entry *, struct nfs_server *, int plus);
+	int	(*decode_dirent)(struct xdr_stream *, struct nfs_entry *, int);
 	void	(*read_setup)   (struct nfs_read_data *, struct rpc_message *);
 	int	(*read_done)  (struct rpc_task *, struct nfs_read_data *);
 	void	(*write_setup)  (struct nfs_write_data *, struct rpc_message *);

commit 0b26a0bf6ff398185546432420bb772bcfdf8d94
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sat Nov 20 14:26:44 2010 -0500

    NFS: Ensure we return the dirent->d_type when it is known
    
    Store the dirent->d_type in the struct nfs_cache_array_entry so that we
    can use it in getdents() calls.
    
    This fixes a regression with the new readdir code.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index ba6cc8f223c9..80f07198a31a 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -483,6 +483,7 @@ struct nfs_entry {
 	int			eof;
 	struct nfs_fh *		fh;
 	struct nfs_fattr *	fattr;
+	unsigned char		d_type;
 };
 
 /*

commit b1f69b754ee312ec75f2c7ead0e6851cd9598cc2
Author: Andy Adamson <andros@netapp.com>
Date:   Wed Oct 20 00:18:03 2010 -0400

    NFSv4.1: pnfs: add LAYOUTGET and GETDEVICEINFO infrastructure
    
    Add the ability to actually send LAYOUTGET and GETDEVICEINFO.  This also adds
    in the machinery to handle layout state and the deviceid cache.  Note that
    GETDEVICEINFO is not called directly by the generic layer.  Instead it
    is called by the drivers while parsing the LAYOUTGET opaque data in response
    to an unknown device id embedded therein.  RFC 5661 only encodes
    device ids within the driver-specific opaque data.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Dean Hildebrand <dhildebz@umich.edu>
    Signed-off-by: Marc Eshel <eshel@almaden.ibm.com>
    Signed-off-by: Mike Sager <sager@netapp.com>
    Signed-off-by: Ricardo Labiaga <ricardo.labiaga@netapp.com>
    Signed-off-by: Tao Guo <guotao@nrchpc.ac.cn>
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 065f9d105d05..ba6cc8f223c9 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -187,6 +187,55 @@ struct nfs4_get_lease_time_res {
 	struct nfs4_sequence_res	lr_seq_res;
 };
 
+#define PNFS_LAYOUT_MAXSIZE 4096
+
+struct nfs4_layoutdriver_data {
+	__u32 len;
+	void *buf;
+};
+
+struct pnfs_layout_range {
+	u32 iomode;
+	u64 offset;
+	u64 length;
+};
+
+struct nfs4_layoutget_args {
+	__u32 type;
+	struct pnfs_layout_range range;
+	__u64 minlength;
+	__u32 maxcount;
+	struct inode *inode;
+	struct nfs_open_context *ctx;
+	struct nfs4_sequence_args seq_args;
+};
+
+struct nfs4_layoutget_res {
+	__u32 return_on_close;
+	struct pnfs_layout_range range;
+	__u32 type;
+	nfs4_stateid stateid;
+	struct nfs4_layoutdriver_data layout;
+	struct nfs4_sequence_res seq_res;
+};
+
+struct nfs4_layoutget {
+	struct nfs4_layoutget_args args;
+	struct nfs4_layoutget_res res;
+	struct pnfs_layout_segment **lsegpp;
+	int status;
+};
+
+struct nfs4_getdeviceinfo_args {
+	struct pnfs_device *pdev;
+	struct nfs4_sequence_args seq_args;
+};
+
+struct nfs4_getdeviceinfo_res {
+	struct pnfs_device *pdev;
+	struct nfs4_sequence_res seq_res;
+};
+
 /*
  * Arguments to the open call.
  */

commit 504913fbc84c00bba7224d73e4aab525c1731f7d
Author: Andy Adamson <andros@netapp.com>
Date:   Wed Oct 20 00:17:57 2010 -0400

    NFS: ask for layouttypes during v4 fsinfo call
    
    This information will be used to determine which layout driver,
    if any, to use for subsequent IO on this filesystem.  Each driver
    is assigned an integer id, with 0 reserved to indicate no driver.
    
    The server can in theory return multiple ids.  However, our current
    client implementation only notes the first entry and ignores the
    rest.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index da7a1300dc60..065f9d105d05 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -114,6 +114,7 @@ struct nfs_fsinfo {
 	__u64			maxfilesize;
 	struct timespec		time_delta; /* server time granularity */
 	__u32			lease_time; /* in seconds */
+	__u32			layouttype; /* supported pnfs layout driver */
 };
 
 struct nfs_fsstat {

commit 6b96724e507fecc3e6440e86426fe4f44359ed66
Author: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
Date:   Tue Oct 12 16:30:05 2010 -0700

    Revalidate caches on lock
    
    Instead of blindly zapping the caches, attempt to revalidate them if
    the server has indicated that it uses high resolution timestamps.
    
    NFSv4 should be able to always revalidate the cache since the
    protocol requires the update of the change attribute on modification of
    the data.  In reality, there are servers (the Linux NFS server
    for example) that do not obey this requirement and use ctime as the
    basis for change attribute.  Long term, the server needs to be fixed.
    At this time, and to be on the safe side, continue zapping caches if
    the server indicates that it does not have a high resolution timestamp.
    
    Signed-off-by: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index efe2eab8ac94..da7a1300dc60 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -112,6 +112,7 @@ struct nfs_fsinfo {
 	__u32			wtmult;	/* writes should be multiple of this */
 	__u32			dtpref;	/* pref. readdir transfer size */
 	__u64			maxfilesize;
+	struct timespec		time_delta; /* server time granularity */
 	__u32			lease_time; /* in seconds */
 };
 

commit 82f2e5472e2304e531c2fa85e457f4a71070044e
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Thu Oct 21 16:33:18 2010 -0400

    NFS: Readdir plus in v4
    
    By requsting more attributes during a readdir, we can mimic the readdir plus
    operation that was in NFSv3.
    
    To test, I ran the command `ls -lU --color=none` on directories with various
    numbers of files.  Without readdir plus, I see this:
    
    n files |    100    |   1,000   |  10,000   |  100,000  | 1,000,000
    --------+-----------+-----------+-----------+-----------+----------
    real    | 0m00.153s | 0m00.589s | 0m05.601s | 0m56.691s | 9m59.128s
    user    | 0m00.007s | 0m00.007s | 0m00.077s | 0m00.703s | 0m06.800s
    sys     | 0m00.010s | 0m00.070s | 0m00.633s | 0m06.423s | 1m10.005s
    access  | 3         | 1         | 1         | 4         | 31
    getattr | 2         | 1         | 1         | 1         | 1
    lookup  | 104       | 1,003     | 10,003    | 100,003   | 1,000,003
    readdir | 2         | 16        | 158       | 1,575     | 15,749
    total   | 111       | 1,021     | 10,163    | 101,583   | 1,015,784
    
    With readdir plus enabled, I see this:
    
    n files |    100    |   1,000   |  10,000   |  100,000  | 1,000,000
    --------+-----------+-----------+-----------+-----------+----------
    real    | 0m00.115s | 0m00.206s | 0m01.079s | 0m12.521s | 2m07.528s
    user    | 0m00.003s | 0m00.003s | 0m00.040s | 0m00.290s | 0m03.296s
    sys     | 0m00.007s | 0m00.020s | 0m00.120s | 0m01.357s | 0m17.556s
    access  | 3         | 1         | 1         | 1         | 7
    getattr | 2         | 1         | 1         | 1         | 1
    lookup  | 4         | 3         | 3         | 3         | 3
    readdir | 6         | 62        | 630       | 6,300     | 62,993
    total   | 15        | 67        | 635       | 6,305     | 63,004
    
    Readdir plus disabled has about a 16x increase in the number of rpc calls and
    is 4 - 5 times slower on large directories.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 1b9a17a1f235..efe2eab8ac94 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -778,6 +778,7 @@ struct nfs4_readdir_arg {
 	struct page **			pages;	/* zero-copy data */
 	unsigned int			pgbase;	/* zero-copy data */
 	const u32 *			bitmask;
+	int				plus;
 	struct nfs4_sequence_args	seq_args;
 };
 
@@ -1036,7 +1037,7 @@ struct nfs_rpc_ops {
 	int	(*pathconf) (struct nfs_server *, struct nfs_fh *,
 			     struct nfs_pathconf *);
 	int	(*set_capabilities)(struct nfs_server *, struct nfs_fh *);
-	__be32 *(*decode_dirent)(struct xdr_stream *, struct nfs_entry *, int plus);
+	__be32 *(*decode_dirent)(struct xdr_stream *, struct nfs_entry *, struct nfs_server *, int plus);
 	void	(*read_setup)   (struct nfs_read_data *, struct rpc_message *);
 	int	(*read_done)  (struct rpc_task *, struct nfs_read_data *);
 	void	(*write_setup)  (struct nfs_write_data *, struct rpc_message *);

commit 56e4ebf877b6043c289bda32a5a7385b80c17dee
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Wed Oct 20 15:44:37 2010 -0400

    NFS: readdir with vmapped pages
    
    We can use vmapped pages to read more information from the network at once.
    This will reduce the number of calls needed to complete a readdir.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    [trondmy: Added #include for linux/vmalloc.h> in fs/nfs/dir.c]
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index ca0e8fd7feec..1b9a17a1f235 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1026,7 +1026,7 @@ struct nfs_rpc_ops {
 	int	(*mkdir)   (struct inode *, struct dentry *, struct iattr *);
 	int	(*rmdir)   (struct inode *, struct qstr *);
 	int	(*readdir) (struct dentry *, struct rpc_cred *,
-			    u64, struct page *, unsigned int, int);
+			    u64, struct page **, unsigned int, int);
 	int	(*mknod)   (struct inode *, struct dentry *, struct iattr *,
 			    dev_t);
 	int	(*statfs)  (struct nfs_server *, struct nfs_fh *,

commit babddc72a9468884ce1a23db3c3d54b0afa299f0
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Wed Oct 20 15:44:29 2010 -0400

    NFS: decode_dirent should use an xdr_stream
    
    Convert nfs*xdr.c to use an xdr stream in decode_dirent.  This will prevent a
    kernel oops that has been occuring when reading a vmapped page.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 5772b2c2f063..ca0e8fd7feec 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1036,7 +1036,7 @@ struct nfs_rpc_ops {
 	int	(*pathconf) (struct nfs_server *, struct nfs_fh *,
 			     struct nfs_pathconf *);
 	int	(*set_capabilities)(struct nfs_server *, struct nfs_fh *);
-	__be32 *(*decode_dirent)(__be32 *, struct nfs_entry *, int plus);
+	__be32 *(*decode_dirent)(struct xdr_stream *, struct nfs_entry *, int plus);
 	void	(*read_setup)   (struct nfs_read_data *, struct rpc_message *);
 	int	(*read_done)  (struct rpc_task *, struct nfs_read_data *);
 	void	(*write_setup)  (struct nfs_write_data *, struct rpc_message *);

commit dfb4f309830359352539919f23accc59a20a3758
Author: Benny Halevy <bhalevy@panasas.com>
Date:   Fri Sep 24 09:17:01 2010 -0400

    NFSv4.1: keep seq_res.sr_slot as pointer rather than an index
    
    Having to explicitly initialize sr_slotid to NFS4_MAX_SLOT_TABLE
    resulted in numerous bugs.  Keeping the current slot as a pointer
    to the slot table is more straight forward and robust as it's
    implicitly set up to NULL wherever the seq_res member is initialized
    to zeroes.
    
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 172df83ac54b..5772b2c2f063 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -170,7 +170,7 @@ struct nfs4_sequence_args {
 
 struct nfs4_sequence_res {
 	struct nfs4_session	*sr_session;
-	u8			sr_slotid;	/* slot used to send request */
+	struct nfs4_slot	*sr_slot;	/* slot used to send request */
 	int			sr_status;	/* sequence operation status */
 	unsigned long		sr_renewal_time;
 	u32			sr_status_flags;

commit d3d4152a5d59af9e13a73efa9e9c24383fbe307f
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Sep 17 17:31:57 2010 -0400

    nfs: make sillyrename an async operation
    
    A synchronous rename can be interrupted by a SIGKILL. If that happens
    during a sillyrename operation, it's possible for the rename call to
    be sent to the server, but the task exits before processing the
    reply. If this happens, the sillyrenamed file won't get cleaned up
    during nfs_dentry_iput and the server is left with a dangling .nfs* file
    hanging around.
    
    Fix this problem by turning sillyrename into an asynchronous operation
    and have the task doing the sillyrename just wait on the reply. If the
    task is killed before the sillyrename completes, it'll still proceed
    to completion.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 9ad132e13d12..172df83ac54b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1018,6 +1018,8 @@ struct nfs_rpc_ops {
 	int	(*unlink_done) (struct rpc_task *, struct inode *);
 	int	(*rename)  (struct inode *, struct qstr *,
 			    struct inode *, struct qstr *);
+	void	(*rename_setup)  (struct rpc_message *msg, struct inode *dir);
+	int	(*rename_done) (struct rpc_task *task, struct inode *old_dir, struct inode *new_dir);
 	int	(*link)    (struct inode *, struct inode *, struct qstr *);
 	int	(*symlink) (struct inode *, struct dentry *, struct page *,
 			    unsigned int, struct iattr *);

commit e8582a8b96f329083b4da29aa87bc43cc0d80dd1
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Sep 17 17:31:06 2010 -0400

    nfs: standardize the rename response container
    
    Right now, v3 and v4 have their own variants. Create a standard struct
    that will work for v3 and v4. v2 doesn't get anything but a simple error
    and so isn't affected by this.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index acb95fb27bcc..9ad132e13d12 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -411,6 +411,15 @@ struct nfs_renameargs {
 	struct nfs4_sequence_args	seq_args;
 };
 
+struct nfs_renameres {
+	const struct nfs_server		*server;
+	struct nfs4_change_info		old_cinfo;
+	struct nfs_fattr		*old_fattr;
+	struct nfs4_change_info		new_cinfo;
+	struct nfs_fattr		*new_fattr;
+	struct nfs4_sequence_res	seq_res;
+};
+
 /*
  * Argument struct for decode_entry function
  */
@@ -623,11 +632,6 @@ struct nfs3_readlinkargs {
 	struct page **		pages;
 };
 
-struct nfs3_renameres {
-	struct nfs_fattr *	fromattr;
-	struct nfs_fattr *	toattr;
-};
-
 struct nfs3_linkres {
 	struct nfs_fattr *	dir_attr;
 	struct nfs_fattr *	fattr;
@@ -795,15 +799,6 @@ struct nfs4_readlink_res {
 	struct nfs4_sequence_res	seq_res;
 };
 
-struct nfs4_rename_res {
-	const struct nfs_server *	server;
-	struct nfs4_change_info		old_cinfo;
-	struct nfs_fattr *		old_fattr;
-	struct nfs4_change_info		new_cinfo;
-	struct nfs_fattr *		new_fattr;
-	struct nfs4_sequence_res	seq_res;
-};
-
 #define NFS4_SETCLIENTID_NAMELEN	(127)
 struct nfs4_setclientid {
 	const nfs4_verifier *		sc_verifier;

commit 920769f031a8aff87b66bdf49d1a0d0988241ef9
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Sep 17 17:30:25 2010 -0400

    nfs: standardize the rename args container
    
    Each NFS version has its own version of the rename args container.
    Standardize them on a common one that's identical to the one NFSv4
    uses.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 6f345f8af4ae..acb95fb27bcc 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -399,6 +399,18 @@ struct nfs_removeres {
 	struct nfs4_sequence_res 	seq_res;
 };
 
+/*
+ * Common arguments to the rename call
+ */
+struct nfs_renameargs {
+	const struct nfs_fh		*old_dir;
+	const struct nfs_fh		*new_dir;
+	const struct qstr		*old_name;
+	const struct qstr		*new_name;
+	const u32			*bitmask;
+	struct nfs4_sequence_args	seq_args;
+};
+
 /*
  * Argument struct for decode_entry function
  */
@@ -434,15 +446,6 @@ struct nfs_createargs {
 	struct iattr *		sattr;
 };
 
-struct nfs_renameargs {
-	struct nfs_fh *		fromfh;
-	const char *		fromname;
-	unsigned int		fromlen;
-	struct nfs_fh *		tofh;
-	const char *		toname;
-	unsigned int		tolen;
-};
-
 struct nfs_setattrargs {
 	struct nfs_fh *                 fh;
 	nfs4_stateid                    stateid;
@@ -586,15 +589,6 @@ struct nfs3_mknodargs {
 	dev_t			rdev;
 };
 
-struct nfs3_renameargs {
-	struct nfs_fh *		fromfh;
-	const char *		fromname;
-	unsigned int		fromlen;
-	struct nfs_fh *		tofh;
-	const char *		toname;
-	unsigned int		tolen;
-};
-
 struct nfs3_linkargs {
 	struct nfs_fh *		fromfh;
 	struct nfs_fh *		tofh;
@@ -801,15 +795,6 @@ struct nfs4_readlink_res {
 	struct nfs4_sequence_res	seq_res;
 };
 
-struct nfs4_rename_arg {
-	const struct nfs_fh *		old_dir;
-	const struct nfs_fh *		new_dir;
-	const struct qstr *		old_name;
-	const struct qstr *		new_name;
-	const u32 *			bitmask;
-	struct nfs4_sequence_args	seq_args;
-};
-
 struct nfs4_rename_res {
 	const struct nfs_server *	server;
 	struct nfs4_change_info		old_cinfo;

commit 2b484297e48c3fbb1846fc6ea10036d9465273e7
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Sep 17 10:56:51 2010 -0400

    NFS: Add an 'open_context' element to struct nfs_rpc_ops
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index b1484dad7bef..6f345f8af4ae 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1065,6 +1065,10 @@ struct nfs_rpc_ops {
 	int	(*lock_check_bounds)(const struct file_lock *);
 	void	(*clear_acl_cache)(struct inode *);
 	void	(*close_context)(struct nfs_open_context *ctx, int);
+	struct inode * (*open_context) (struct inode *dir,
+				struct nfs_open_context *ctx,
+				int open_flags,
+				struct iattr *iattr);
 };
 
 /*

commit c0204fd2b8fe047b18b67e07e1bf2a03691240cd
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Sep 17 10:56:51 2010 -0400

    NFS: Clean up nfs4_proc_create()
    
    Remove all remaining references to the struct nameidata from the low level
    NFS layers. Again pass down a partially initialised struct nfs_open_context
    when we want to do atomic open+create.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index fc461926c412..b1484dad7bef 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1032,7 +1032,7 @@ struct nfs_rpc_ops {
 	int	(*readlink)(struct inode *, struct page *, unsigned int,
 			    unsigned int);
 	int	(*create)  (struct inode *, struct dentry *,
-			    struct iattr *, int, struct nameidata *);
+			    struct iattr *, int, struct nfs_open_context *);
 	int	(*remove)  (struct inode *, struct qstr *);
 	void	(*unlink_setup)  (struct rpc_message *, struct inode *dir);
 	int	(*unlink_done) (struct rpc_task *, struct inode *);

commit d3c7b7ccc199ee564177ee914c04771d6bc00295
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Jul 1 12:49:01 2010 -0400

    NFSv4: Add support for the RELEASE_LOCKOWNER operation
    
    This is needed by NFSv4.0 servers in order to keep the number of locking
    stateids at a manageable level.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 87202c7026e3..fc461926c412 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -315,6 +315,10 @@ struct nfs_lockt_res {
 	struct nfs4_sequence_res	seq_res;
 };
 
+struct nfs_release_lockowner_args {
+	struct nfs_lowner	lock_owner;
+};
+
 struct nfs4_delegreturnargs {
 	const struct nfs_fh *fhandle;
 	const nfs4_stateid *stateid;

commit f11ac8db5d07b6e99d41ff4aa39d878ee5cef1c5
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Jun 25 16:35:53 2010 -0400

    NFSv4: Ensure that we track the NFSv4 lock state in read/write requests.
    
    This patch fixes bugzilla entry 14501:
      https://bugzilla.kernel.org/show_bug.cgi?id=14501
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index a319cb926abf..87202c7026e3 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -334,6 +334,7 @@ struct nfs4_delegreturnres {
 struct nfs_readargs {
 	struct nfs_fh *		fh;
 	struct nfs_open_context *context;
+	struct nfs_lock_context *lock_context;
 	__u64			offset;
 	__u32			count;
 	unsigned int		pgbase;
@@ -354,6 +355,7 @@ struct nfs_readres {
 struct nfs_writeargs {
 	struct nfs_fh *		fh;
 	struct nfs_open_context *context;
+	struct nfs_lock_context *lock_context;
 	__u64			offset;
 	__u32			count;
 	enum nfs3_stable_how	stable;

commit d77d76ffb638bd013782138cca6d8f4918c5afd6
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Jun 16 09:52:27 2010 -0400

    NFSv41: Clean up exclusive create
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 51914d7d6cc4..a319cb926abf 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -196,8 +196,10 @@ struct nfs_openargs {
 	__u64                   clientid;
 	__u64                   id;
 	union {
-		struct iattr *  attrs;    /* UNCHECKED, GUARDED */
-		nfs4_verifier   verifier; /* EXCLUSIVE */
+		struct {
+			struct iattr *  attrs;    /* UNCHECKED, GUARDED */
+			nfs4_verifier   verifier; /* EXCLUSIVE */
+		};
 		nfs4_stateid	delegation;		/* CLAIM_DELEGATE_CUR */
 		fmode_t		delegation_type;	/* CLAIM_PREVIOUS */
 	} u;

commit bb8b27e504c0f0463535fea31b42bcaa393c3fb0
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Apr 16 16:43:06 2010 -0400

    NFSv4: Clean up the NFSv4 setclientid operation
    
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 76e11c663403..51914d7d6cc4 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -824,6 +824,11 @@ struct nfs4_setclientid {
 	u32				sc_cb_ident;
 };
 
+struct nfs4_setclientid_res {
+	u64				clientid;
+	nfs4_verifier			confirm;
+};
+
 struct nfs4_statfs_arg {
 	const struct nfs_fh *		fh;
 	const u32 *			bitmask;

commit d346890bea062d697e24fb4e34591428021ad011
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Apr 16 16:22:50 2010 -0400

    NFS: Reduce stack footprint of nfs_proc_remove()
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 89b28812ec24..76e11c663403 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -386,8 +386,8 @@ struct nfs_removeargs {
 
 struct nfs_removeres {
 	const struct nfs_server *server;
+	struct nfs_fattr	*dir_attr;
 	struct nfs4_change_info	cinfo;
-	struct nfs_fattr	dir_attr;
 	struct nfs4_sequence_res 	seq_res;
 };
 

commit 37c24b37fb2454e95136139d10bb6828967105bf
Merge: 5ac4d630eb87 7663dacd9265
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 16 10:43:34 2009 -0800

    Merge branch 'for-2.6.33' of git://linux-nfs.org/~bfields/linux
    
    * 'for-2.6.33' of git://linux-nfs.org/~bfields/linux: (42 commits)
      nfsd: remove pointless paths in file headers
      nfsd: move most of nfsfh.h to fs/nfsd
      nfsd: remove unused field rq_reffh
      nfsd: enable V4ROOT exports
      nfsd: make V4ROOT exports read-only
      nfsd: restrict filehandles accepted in V4ROOT case
      nfsd: allow exports of symlinks
      nfsd: filter readdir results in V4ROOT case
      nfsd: filter lookup results in V4ROOT case
      nfsd4: don't continue "under" mounts in V4ROOT case
      nfsd: introduce export flag for v4 pseudoroot
      nfsd: let "insecure" flag vary by pseudoflavor
      nfsd: new interface to advertise export features
      nfsd: Move private headers to source directory
      vfs: nfsctl.c un-used nfsd #includes
      lockd: Remove un-used nfsd headers #includes
      s390: remove un-used nfsd #includes
      sparc: remove un-used nfsd #includes
      parsic: remove un-used nfsd #includes
      compat.c: Remove dependence on nfsd private headers
      ...

commit d703158229329af7152d159753f849aa7bd55ee6
Author: Boaz Harrosh <bharrosh@panasas.com>
Date:   Thu Dec 3 20:28:47 2009 +0200

    nfsd: Fix independence of a few nfsd related headers
    
    An header should be compilation independent, .i.e pull in
    any header who's declarations are directly used by this header.
    And not let users re-include all it's dependencies all over
    again.
    
    [At the end of the day what's the use of a header if it does
     not have more then one user?]
    
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 62f63fb0c4c8..00a0c8170816 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -2,6 +2,7 @@
 #define _LINUX_NFS_XDR_H
 
 #include <linux/nfsacl.h>
+#include <linux/nfs3.h>
 
 /*
  * To change the maximum rsize and wsize supported by the NFS client, adjust

commit 180197536b15d5862b389ce90b46ec8d004056f6
Author: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
Date:   Sat Dec 5 16:08:40 2009 -0500

    nfs41: RECLAIM_COMPLETE XDR functionality
    
    XDR encoding and decoding for RECLAIM_COMPLETE.  Implements the necessary
    encoding to indicate reclaim complete for the entire client.  In the future,
    it can be extended to provide reclaim complete functionality for a single
    file system after migration.
    
    Signed-off-by: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index ea32db30c289..51071b335751 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -939,6 +939,16 @@ struct nfs41_create_session_args {
 struct nfs41_create_session_res {
 	struct nfs_client	       *client;
 };
+
+struct nfs41_reclaim_complete_args {
+	/* In the future extend to include curr_fh for use with migration */
+	unsigned char			one_fs:1;
+	struct nfs4_sequence_args	seq_args;
+};
+
+struct nfs41_reclaim_complete_res {
+	struct nfs4_sequence_res	seq_res;
+};
 #endif /* CONFIG_NFS_V4_1 */
 
 struct nfs_page;

commit 0629e370dd5819efa5cf8d418a8e6729efe388ef
Author: Alexandros Batsakis <batsakis@netapp.com>
Date:   Sat Dec 5 13:46:14 2009 -0500

    nfs41: check SEQUENCE status flag
    
    the server can indicate a number of error conditions by setting the
    appropriate bits in the SEQUENCE operation. The client re-establishes
    state with the server when it receives one of those, with the action
    depending on the specific case.
    
    Signed-off-by: Alexandros Batsakis <batsakis@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 8c880372536e..ea32db30c289 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -172,6 +172,7 @@ struct nfs4_sequence_res {
 	u8			sr_slotid;	/* slot used to send request */
 	int			sr_status;	/* sequence operation status */
 	unsigned long		sr_renewal_time;
+	u32			sr_status_flags;
 };
 
 struct nfs4_get_lease_time_args {

commit a01878aac57eac6eb4bf194788ab2cc440490d0f
Author: Richard Kennedy <richard@rsk.demon.co.uk>
Date:   Thu Dec 3 15:58:56 2009 -0500

    NFS: reorder nfs4_sequence_regs to remove 8 bytes of padding on 64 bits
    
    reorder nfs4_sequence_args to remove 8 bytes of padding on 64 bit
    builds.
    
    The size of this structure drops to 24 bytes from 32 and reduces the
    text size of nfs.ko.
    On my x86_64 size reports
    
                    text       data     bss
    2.6.32-rc5      200996     8512     432  209940   33414 nfs.ko
    +patch          200884     8512     432  209828   333a4 nfs.ko
    
    
    Signed-off-by: Richard Kennedy <richard@rsk.demon.co.uk>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 62f63fb0c4c8..8c880372536e 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -170,8 +170,8 @@ struct nfs4_sequence_args {
 struct nfs4_sequence_res {
 	struct nfs4_session	*sr_session;
 	u8			sr_slotid;	/* slot used to send request */
-	unsigned long		sr_renewal_time;
 	int			sr_status;	/* sequence operation status */
+	unsigned long		sr_renewal_time;
 };
 
 struct nfs4_get_lease_time_args {

commit fc931582c260e53ca5ca23bd70ccc9b2265cca9f
Author: Andy Adamson <andros@netapp.com>
Date:   Wed Apr 1 09:22:31 2009 -0400

    nfs41: create_session operation
    
    Implement the create_session operation conforming to
    http://tools.ietf.org/html/draft-ietf-nfsv4-minorversion1-26
    
    Set the real fore channel max operations to preserve server resources.
    Note: If the server returns < NFS4_MAX_OPS, the client will very soon
    get an NFS4ERR_TOO_MANY_OPS. A later patch will handle this.
    
    Set the max_rqst_sz and max_resp_sz to PAGE_SIZE - we preallocate the buffers.
    
    Set the back channel max_resp_sz_cached to zero to force the client to
    always set csa_cachethis to FALSE because the current implementation
    of the back channel DRC only supports caching the CB_SEQUENCE operation.
    
    The client back channel server supports one slot, and desires 2 operations
    per compound.
    
    Signed-off-by: Ricardo Labiaga <ricardo.labiaga@netapp.com>
    Signed-off-by: Andy Adamson<andros@umich.edu>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: remove extraneous rpc_clnt pointer]
    Use the struct nfs_client cl_rpcclient.
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: nfs4_init_channel_attrs, just use nfs41_create_session_args]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: use rsize and wsize for session channel attributes]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: set channel max operations]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: set back channel attributes]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: obliterate nfs4_adjust_channel_attrs]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: have create_session work on nfs_client]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: move CONFIG_NFS_V4_1 endif]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: pass *session in seq_args and seq_res]
    [moved nfs4_init_slot_table definition here]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: use kcalloc to allocate slot table]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    [nfs41: fix Xcode_create_session's xdr Xcoding pointer type]
    [nfs41: refactor decoding of channel attributes]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index ca643aa87d46..62f63fb0c4c8 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -926,6 +926,18 @@ struct nfs41_exchange_id_res {
 	struct nfs_client		*client;
 	u32				flags;
 };
+
+struct nfs41_create_session_args {
+	struct nfs_client	       *client;
+	uint32_t			flags;
+	uint32_t			cb_program;
+	struct nfs4_channel_attrs	fc_attrs;	/* Fore Channel */
+	struct nfs4_channel_attrs	bc_attrs;	/* Back Channel */
+};
+
+struct nfs41_create_session_res {
+	struct nfs_client	       *client;
+};
 #endif /* CONFIG_NFS_V4_1 */
 
 struct nfs_page;

commit 2050f0cc0703aab7cee798b3cb47037754f368bc
Author: Andy Adamson <andros@netapp.com>
Date:   Wed Apr 1 09:22:30 2009 -0400

    nfs41: get_lease_time
    
    get_lease_time uses the FSINFO rpc operation to
    get the lease time attribute.
    
    nfs4_get_lease_time() is only called from the state manager on session setup
    so don't recover from clientid or sequence level errors.
    
    We do need to recover from NFS4ERR_DELAY or NFS4ERR_GRACE.
    Use NFS4_POLL_RETRY_MIN - the Linux server returns NFS4ERR_DELAY when an
    upcall is needed to resolve an uncached export referenced by a file handle.
    
    [nfs41: sequence res use slotid]
    Signed-off-by: Andy Adamson<andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: remove extraneous rpc_clnt pointer]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: have get_lease_time work on nfs_client]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: get_lease_time recover from NFS4ERR_DELAY]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: pass *session in seq_args and seq_res]
    [define nfs4_get_lease_time_{args,res}]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 5d70b924af5e..ca643aa87d46 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -174,6 +174,15 @@ struct nfs4_sequence_res {
 	int			sr_status;	/* sequence operation status */
 };
 
+struct nfs4_get_lease_time_args {
+	struct nfs4_sequence_args	la_seq_args;
+};
+
+struct nfs4_get_lease_time_res {
+	struct nfs_fsinfo	       *lr_fsinfo;
+	struct nfs4_sequence_res	lr_seq_res;
+};
+
 /*
  * Arguments to the open call.
  */

commit 99fe60d062cfecf382c036065b3278b82b6c5eff
Author: Benny Halevy <bhalevy@panasas.com>
Date:   Wed Apr 1 09:22:29 2009 -0400

    nfs41: exchange_id operation
    
    Implement the exchange_id operation conforming to
    http://tools.ietf.org/html/draft-ietf-nfsv4-minorversion1-26
    
    Unlike NFSv4.0, NFSv4.1 requires machine credentials. RPC_AUTH_GSS machine
    credentials will be passed into the kernel at mount time to be available for
    the exchange_id operation.
    
    RPC_AUTH_UNIX root mounts can use the UNIX root credential. Store the root
    credential in the nfs_client struct.
    
    Without a credential, NFSv4.1 state renewal fails.
    
    [nfs41: establish clientid via exchange id only if cred != NULL]
    Signed-off-by: Andy Adamson<andros@umich.edu>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfsd41: move nfstime4 from under CONFIG_NFS_V4_1]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: do not wait a lease time in exchange id]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: pass *session in seq_args and seq_res]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    [nfs41: Ignoring impid in decode_exchange_id is missing a READ_BUF]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: fix Xcode_exchange_id's xdr Xcoding pointer type]
    [nfs41: get rid of unused struct nfs41_exchange_id_res members]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 4ac14b40efc9..5d70b924af5e 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -879,6 +879,46 @@ struct nfs4_fs_locations_res {
 
 #endif /* CONFIG_NFS_V4 */
 
+struct nfstime4 {
+	u64	seconds;
+	u32	nseconds;
+};
+
+#ifdef CONFIG_NFS_V4_1
+struct nfs_impl_id4 {
+	u32		domain_len;
+	char		*domain;
+	u32		name_len;
+	char		*name;
+	struct nfstime4	date;
+};
+
+#define NFS4_EXCHANGE_ID_LEN	(48)
+struct nfs41_exchange_id_args {
+	struct nfs_client		*client;
+	nfs4_verifier			*verifier;
+	unsigned int 			id_len;
+	char 				id[NFS4_EXCHANGE_ID_LEN];
+	u32				flags;
+};
+
+struct server_owner {
+	uint64_t			minor_id;
+	uint32_t			major_id_sz;
+	char				major_id[NFS4_OPAQUE_LIMIT];
+};
+
+struct server_scope {
+	uint32_t			server_scope_sz;
+	char 				server_scope[NFS4_OPAQUE_LIMIT];
+};
+
+struct nfs41_exchange_id_res {
+	struct nfs_client		*client;
+	u32				flags;
+};
+#endif /* CONFIG_NFS_V4_1 */
+
 struct nfs_page;
 
 #define NFS_PAGEVEC_SIZE	(8U)

commit fbcd4abcb3841f85578985c09c6df85aa41b0ae8
Author: Andy Adamson <andros@netapp.com>
Date:   Wed Apr 1 09:22:15 2009 -0400

    nfs41: setup_sequence method
    
    Allocate a slot in the session slot table and set the sequence op arguments.
    
    Called at the rpc prepare stage.
    
    Add a status to nfs41_sequence_res, initialize it to one so that we catch
    rpc level failures which do not go through decode_sequence which sets
    the new status field.
    
    Note that upon an rpc level failure, we don't know if the server processed the
    sequence operation or not. Proceed as if the server did process the sequence
    operation.
    
    Signed-off-by: Rahul Iyer <iyer@netapp.com>
    [nfs41: sequence args use slotid]
    [nfs41: find slot return slotid]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: remove SEQ4_STATUS_USE_TK_STATUS]
    As per 11-14-08 review
    [move extern declaration from nfs41: sequence setup/done support]
    [removed sa_session definition, changed sa_cache_this into a u8 to reduce footprint]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: rpc_sleep_on slot_tbl_waitq must be called under slot_tbl_lock]
        Otherwise there's a race (we've hit) with nfs4_free_slot where
        nfs41_setup_sequence sees a full slot table, unlocks slot_tbl_lock,
        nfs4_free_slots happen concurrently and call rpc_wake_up_next
        where there's nobody to wake up yet, context goes back to
        nfs41_setup_sequence which goes to sleep when the slot table
        is actually empty now and there's no-one to wake it up anymore.
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index db0d1236aae7..4ac14b40efc9 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -163,11 +163,15 @@ struct nfs4_slot {
 
 struct nfs4_sequence_args {
 	struct nfs4_session	*sa_session;
+	u8			sa_slotid;
+	u8			sa_cache_this;
 };
 
 struct nfs4_sequence_res {
 	struct nfs4_session	*sr_session;
 	u8			sr_slotid;	/* slot used to send request */
+	unsigned long		sr_renewal_time;
+	int			sr_status;	/* sequence operation status */
 };
 
 /*

commit 5f7dbd5c752d88310d8fe1feedefd5c6496eff48
Author: Andy Adamson <andros@netapp.com>
Date:   Wed Apr 1 09:22:05 2009 -0400

    nfs41: set up seq_res.sr_slotid
    
    Initialize nfs4_sequence_res sr_slotid to NFS4_MAX_SLOT_TABLE.
    
    [was nfs41: sequence res use slotid]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    [pulled definition of struct nfs4_sequence_res.sr_slotid to here]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index f5675063f951..db0d1236aae7 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -167,6 +167,7 @@ struct nfs4_sequence_args {
 
 struct nfs4_sequence_res {
 	struct nfs4_session	*sr_session;
+	u8			sr_slotid;	/* slot used to send request */
 };
 
 /*

commit f3752975caa716709c5ea0b0820b86111d921df4
Author: Benny Halevy <bhalevy@panasas.com>
Date:   Wed Apr 1 09:22:04 2009 -0400

    nfs41: nfs41: pass *session in seq_args and seq_res
    
    To be used for getting the rpc's minorversion and for nfs41 xdr
    {en,de}coding of the sequence operation.
    Reset the seq session ptrs for minorversion=0 rpc calls.
    
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index d837f10c49ef..f5675063f951 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -162,11 +162,11 @@ struct nfs4_slot {
 };
 
 struct nfs4_sequence_args {
-	/* stub */
+	struct nfs4_session	*sa_session;
 };
 
 struct nfs4_sequence_res {
-	/* stub */
+	struct nfs4_session	*sr_session;
 };
 
 /*

commit 22958463d5dca8548e19430779f379e66fd6e4a4
Author: Benny Halevy <bhalevy@panasas.com>
Date:   Wed Apr 1 09:22:02 2009 -0400

    nfs41: use nfs4_fs_locations_res
    
    In preparation for nfs41 sequence processing.
    
    Signed-off-by: Andy Admason <andros@netapp.com>
    [find nfs4_fs_locations_res]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 0f2dc8f4cc36..d837f10c49ef 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -867,6 +867,11 @@ struct nfs4_fs_locations_arg {
 	struct nfs4_sequence_args	seq_args;
 };
 
+struct nfs4_fs_locations_res {
+	struct nfs4_fs_locations       *fs_locations;
+	struct nfs4_sequence_res	seq_res;
+};
+
 #endif /* CONFIG_NFS_V4 */
 
 struct nfs_page;

commit 73c403a9a93743b068103c13c05ed136dc687d05
Author: Benny Halevy <bhalevy@panasas.com>
Date:   Wed Apr 1 09:22:01 2009 -0400

    nfs41: use nfs4_setaclres
    
    In preparation for nfs41 sequence processing.
    
    Signed-off-by: Andy Admason <andros@netapp.com>
    [define nfs_setaclres]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 6e9ee2848606..0f2dc8f4cc36 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -436,6 +436,10 @@ struct nfs_setaclargs {
 	struct nfs4_sequence_args	seq_args;
 };
 
+struct nfs_setaclres {
+	struct nfs4_sequence_res	seq_res;
+};
+
 struct nfs_getaclargs {
 	struct nfs_fh *			fh;
 	size_t				acl_len;

commit 663c79b3cd8f5fe21fe7d7565fec0072e3234ddc
Author: Benny Halevy <bhalevy@panasas.com>
Date:   Wed Apr 1 09:21:59 2009 -0400

    nfs41: use nfs4_getaclres
    
    In preparation for nfs41 sequence processing.
    
    Signed-off-by: Andy Admason <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: embed resp_len in nfs_getaclres]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 56523319e14c..6e9ee2848606 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -444,6 +444,11 @@ struct nfs_getaclargs {
 	struct nfs4_sequence_args 	seq_args;
 };
 
+struct nfs_getaclres {
+	size_t				acl_len;
+	struct nfs4_sequence_res	seq_res;
+};
+
 struct nfs_setattrres {
 	struct nfs_fattr *              fattr;
 	const struct nfs_server *	server;

commit d45b2989a7956ae9e71d584ceac942278c0371c7
Author: Benny Halevy <bhalevy@panasas.com>
Date:   Wed Apr 1 09:21:58 2009 -0400

    nfs41: use nfs4_pathconf_res
    
    In preparation for nfs41 sequence processing.
    
    Signed-off-by: Andy Admason <andros@netapp.com>
    [define nfs4_pathconf_res]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 7d64913cbb1b..56523319e14c 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -734,6 +734,11 @@ struct nfs4_pathconf_arg {
 	struct nfs4_sequence_args	seq_args;
 };
 
+struct nfs4_pathconf_res {
+	struct nfs_pathconf	       *pathconf;
+	struct nfs4_sequence_res	seq_res;
+};
+
 struct nfs4_readdir_arg {
 	const struct nfs_fh *		fh;
 	u64				cookie;

commit 3dda5e434721f942870ee30bc6103761618d410f
Author: Benny Halevy <bhalevy@panasas.com>
Date:   Wed Apr 1 09:21:57 2009 -0400

    nfs41: use nfs4_fsinfo_res
    
    In preparation for nfs41 sequence processing.
    
    Signed-off-by: Andy Admason <andros@netapp.com>
    [define nfs4_fsinfo_res]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 4dac59ef6f4f..7d64913cbb1b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -675,6 +675,11 @@ struct nfs4_fsinfo_arg {
 	struct nfs4_sequence_args	seq_args;
 };
 
+struct nfs4_fsinfo_res {
+	struct nfs_fsinfo	       *fsinfo;
+	struct nfs4_sequence_res	seq_res;
+};
+
 struct nfs4_getattr_arg {
 	const struct nfs_fh *		fh;
 	const u32 *			bitmask;

commit 24ad148a0ff74b1e703a8bc5b3e0793dc7d4e3a9
Author: Benny Halevy <bhalevy@panasas.com>
Date:   Wed Apr 1 09:21:56 2009 -0400

    nfs41: use nfs4_statfs_res
    
    In preparation for nfs41 sequence processing.
    
    Signed-off-by: Andy Admason <andros@netapp.com>
    [define nfs4_statfs_res]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index f71260aeb803..4dac59ef6f4f 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -795,6 +795,11 @@ struct nfs4_statfs_arg {
 	struct nfs4_sequence_args	seq_args;
 };
 
+struct nfs4_statfs_res {
+	struct nfs_fsstat	       *fsstat;
+	struct nfs4_sequence_res	seq_res;
+};
+
 struct nfs4_server_caps_arg {
 	struct nfs_fh		       *fhandle;
 	struct nfs4_sequence_args	seq_args;

commit f50c7000817e7cb4e676ac5d911a82c0f3fd226f
Author: Benny Halevy <bhalevy@panasas.com>
Date:   Wed Apr 1 09:21:55 2009 -0400

    nfs41: use nfs4_readlink_res
    
    In preparation for nfs41 sequence processing.
    
    Signed-off-by: Andy Admason <andros@netapp.com>
    [define nfs4_readlink_res]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index a7b7f2a059cc..f71260aeb803 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -754,6 +754,10 @@ struct nfs4_readlink {
 	struct nfs4_sequence_args	seq_args;
 };
 
+struct nfs4_readlink_res {
+	struct nfs4_sequence_res	seq_res;
+};
+
 struct nfs4_rename_arg {
 	const struct nfs_fh *		old_dir;
 	const struct nfs_fh *		new_dir;

commit 43652ad55342d9146d8035932101a5814b22315a
Author: Benny Halevy <bhalevy@panasas.com>
Date:   Wed Apr 1 09:21:54 2009 -0400

    nfs41: use nfs4_server_caps_arg
    
    In preparation for nfs41 sequence processing.
    
    Signed-off-by: Andy Admason <andros@netapp.com>
    [define nfs4_server_caps_arg]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 8f8c026c558e..a7b7f2a059cc 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -791,6 +791,11 @@ struct nfs4_statfs_arg {
 	struct nfs4_sequence_args	seq_args;
 };
 
+struct nfs4_server_caps_arg {
+	struct nfs_fh		       *fhandle;
+	struct nfs4_sequence_args	seq_args;
+};
+
 struct nfs4_server_caps_res {
 	u32				attr_bitmask[2];
 	u32				acl_bitmask;

commit 557134a39c8d2ab79d8b8d53438e03e29feb5ec4
Author: Andy Adamson <andros@netapp.com>
Date:   Wed Apr 1 09:21:53 2009 -0400

    nfs41: sessions client infrastructure
    
    NFSv4.1 Sessions basic data types, initialization, and destruction.
    
    The session is always associated with a struct nfs_client that holds
    the exchange_id results.
    
    Signed-off-by: Rahul Iyer <iyer@netapp.com>
    Signed-off-by: Andy Adamson<andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [remove extraneous rpc_clnt pointer, use the struct nfs_client cl_rpcclient.
    remove the rpc_clnt parameter from nfs4 nfs4_init_session]
    Signed-off-by: Andy Adamson<andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [Use the presence of a session to determine behaviour instead of the
    minorversion number.]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    [constified nfs4_has_session's struct nfs_client parameter]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [Rename nfs4_put_session() to nfs4_destroy_session() and call it from nfs4_free_client() not nfs4_free_server().
    Also get rid of nfs4_get_session() and the ref_count in nfs4_session struct as keeping track of nfs_client should be sufficient]
    Signed-off-by: Alexandros Batsakis <Alexandros.Batsakis@netapp.com>
    [nfs41: pass rsize and wsize into nfs4_init_session]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    [separated out removal of rpc_clnt parameter from nfs4_init_session ot a
     patch of its own]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [Pass the nfs_client pointer into nfs4_alloc_session]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: don't assign to session->clp->cl_session in nfs4_destroy_session]
    [nfs41: fixup nfs4_clear_client_minor_version]
    [introduce nfs4_clear_client_minor_version() in this patch]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [Refactor nfs4_init_session]
        Moved session allocation into nfs4_init_client_minor_version, called from
        nfs4_init_client.
        Leave rwise and wsize initialization in nfs4_init_session, called from
        nfs4_init_server.
        Reverted moving of nfs_fsid definition to nfs_fs_sb.h
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: Move NFS4_MAX_SLOT_TABLE define from under CONFIG_NFS_V4_1]
    [Fix comile error when CONFIG_NFS_V4_1 is not set.]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [moved nfs4_init_slot_table definition to "create_session operation"]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: alloc session with GFP_KERNEL]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index f2c5700c7b6e..8f8c026c558e 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -146,6 +146,21 @@ struct nfs4_change_info {
 
 struct nfs_seqid;
 
+/* nfs41 sessions channel attributes */
+struct nfs4_channel_attrs {
+	u32			headerpadsz;
+	u32			max_rqst_sz;
+	u32			max_resp_sz;
+	u32			max_resp_sz_cached;
+	u32			max_ops;
+	u32			max_reqs;
+};
+
+/* nfs41 sessions slot seqid */
+struct nfs4_slot {
+	u32		 	seq_nr;
+};
+
 struct nfs4_sequence_args {
 	/* stub */
 };

commit 9ff71c3a9827b99699510076dffa0bbe7c36bfd4
Author: Benny Halevy <bhalevy@panasas.com>
Date:   Wed Apr 1 09:21:52 2009 -0400

    nfs41: client xdr definitions
    
    Define stubs for sequence args and res data structures and embed
    them in all other nfs4 and nfs41 xdr types.  They are needed for
    sending any op in a nfs41 compound rpc.
    
    Signed-off-by: Andy Adamson<andros@netapp.com>
    [moved new args/res definitions away, to where they're first used]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index b89c34e40bc2..f2c5700c7b6e 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -145,6 +145,15 @@ struct nfs4_change_info {
 };
 
 struct nfs_seqid;
+
+struct nfs4_sequence_args {
+	/* stub */
+};
+
+struct nfs4_sequence_res {
+	/* stub */
+};
+
 /*
  * Arguments to the open call.
  */
@@ -165,6 +174,7 @@ struct nfs_openargs {
 	const struct nfs_server *server;	 /* Needed for ID mapping */
 	const u32 *		bitmask;
 	__u32			claim;
+	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs_openres {
@@ -181,6 +191,7 @@ struct nfs_openres {
 	__u32			do_recall;
 	__u64			maxsize;
 	__u32			attrset[NFS4_BITMAP_SIZE];
+	struct nfs4_sequence_res	seq_res;
 };
 
 /*
@@ -206,6 +217,7 @@ struct nfs_closeargs {
 	struct nfs_seqid *	seqid;
 	fmode_t			fmode;
 	const u32 *		bitmask;
+	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs_closeres {
@@ -213,6 +225,7 @@ struct nfs_closeres {
 	struct nfs_fattr *	fattr;
 	struct nfs_seqid *	seqid;
 	const struct nfs_server *server;
+	struct nfs4_sequence_res	seq_res;
 };
 /*
  *  * Arguments to the lock,lockt, and locku call.
@@ -233,12 +246,14 @@ struct nfs_lock_args {
 	unsigned char		block : 1;
 	unsigned char		reclaim : 1;
 	unsigned char		new_lock_owner : 1;
+	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs_lock_res {
 	nfs4_stateid		stateid;
 	struct nfs_seqid *	lock_seqid;
 	struct nfs_seqid *	open_seqid;
+	struct nfs4_sequence_res	seq_res;
 };
 
 struct nfs_locku_args {
@@ -246,32 +261,38 @@ struct nfs_locku_args {
 	struct file_lock *	fl;
 	struct nfs_seqid *	seqid;
 	nfs4_stateid *		stateid;
+	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs_locku_res {
 	nfs4_stateid		stateid;
 	struct nfs_seqid *	seqid;
+	struct nfs4_sequence_res	seq_res;
 };
 
 struct nfs_lockt_args {
 	struct nfs_fh *		fh;
 	struct file_lock *	fl;
 	struct nfs_lowner	lock_owner;
+	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs_lockt_res {
 	struct file_lock *	denied; /* LOCK, LOCKT failed */
+	struct nfs4_sequence_res	seq_res;
 };
 
 struct nfs4_delegreturnargs {
 	const struct nfs_fh *fhandle;
 	const nfs4_stateid *stateid;
 	const u32 * bitmask;
+	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_delegreturnres {
 	struct nfs_fattr * fattr;
 	const struct nfs_server *server;
+	struct nfs4_sequence_res	seq_res;
 };
 
 /*
@@ -284,12 +305,14 @@ struct nfs_readargs {
 	__u32			count;
 	unsigned int		pgbase;
 	struct page **		pages;
+	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs_readres {
 	struct nfs_fattr *	fattr;
 	__u32			count;
 	int                     eof;
+	struct nfs4_sequence_res	seq_res;
 };
 
 /*
@@ -304,6 +327,7 @@ struct nfs_writeargs {
 	unsigned int		pgbase;
 	struct page **		pages;
 	const u32 *		bitmask;
+	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs_writeverf {
@@ -316,6 +340,7 @@ struct nfs_writeres {
 	struct nfs_writeverf *	verf;
 	__u32			count;
 	const struct nfs_server *server;
+	struct nfs4_sequence_res	seq_res;
 };
 
 /*
@@ -325,12 +350,14 @@ struct nfs_removeargs {
 	const struct nfs_fh	*fh;
 	struct qstr		name;
 	const u32 *		bitmask;
+	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs_removeres {
 	const struct nfs_server *server;
 	struct nfs4_change_info	cinfo;
 	struct nfs_fattr	dir_attr;
+	struct nfs4_sequence_res 	seq_res;
 };
 
 /*
@@ -383,6 +410,7 @@ struct nfs_setattrargs {
 	struct iattr *                  iap;
 	const struct nfs_server *	server; /* Needed for name mapping */
 	const u32 *			bitmask;
+	struct nfs4_sequence_args 	seq_args;
 };
 
 struct nfs_setaclargs {
@@ -390,6 +418,7 @@ struct nfs_setaclargs {
 	size_t				acl_len;
 	unsigned int			acl_pgbase;
 	struct page **			acl_pages;
+	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs_getaclargs {
@@ -397,11 +426,13 @@ struct nfs_getaclargs {
 	size_t				acl_len;
 	unsigned int			acl_pgbase;
 	struct page **			acl_pages;
+	struct nfs4_sequence_args 	seq_args;
 };
 
 struct nfs_setattrres {
 	struct nfs_fattr *              fattr;
 	const struct nfs_server *	server;
+	struct nfs4_sequence_res	seq_res;
 };
 
 struct nfs_linkargs {
@@ -583,6 +614,7 @@ struct nfs4_accessargs {
 	const struct nfs_fh *		fh;
 	const u32 *			bitmask;
 	u32				access;
+	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_accessres {
@@ -590,6 +622,7 @@ struct nfs4_accessres {
 	struct nfs_fattr *		fattr;
 	u32				supported;
 	u32				access;
+	struct nfs4_sequence_res	seq_res;
 };
 
 struct nfs4_create_arg {
@@ -609,6 +642,7 @@ struct nfs4_create_arg {
 	const struct iattr *		attrs;
 	const struct nfs_fh *		dir_fh;
 	const u32 *			bitmask;
+	struct nfs4_sequence_args 	seq_args;
 };
 
 struct nfs4_create_res {
@@ -617,21 +651,25 @@ struct nfs4_create_res {
 	struct nfs_fattr *		fattr;
 	struct nfs4_change_info		dir_cinfo;
 	struct nfs_fattr *		dir_fattr;
+	struct nfs4_sequence_res	seq_res;
 };
 
 struct nfs4_fsinfo_arg {
 	const struct nfs_fh *		fh;
 	const u32 *			bitmask;
+	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_getattr_arg {
 	const struct nfs_fh *		fh;
 	const u32 *			bitmask;
+	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_getattr_res {
 	const struct nfs_server *	server;
 	struct nfs_fattr *		fattr;
+	struct nfs4_sequence_res	seq_res;
 };
 
 struct nfs4_link_arg {
@@ -639,6 +677,7 @@ struct nfs4_link_arg {
 	const struct nfs_fh *		dir_fh;
 	const struct qstr *		name;
 	const u32 *			bitmask;
+	struct nfs4_sequence_args 	seq_args;
 };
 
 struct nfs4_link_res {
@@ -646,6 +685,7 @@ struct nfs4_link_res {
 	struct nfs_fattr *		fattr;
 	struct nfs4_change_info		cinfo;
 	struct nfs_fattr *		dir_attr;
+	struct nfs4_sequence_res	seq_res;
 };
 
 
@@ -653,21 +693,25 @@ struct nfs4_lookup_arg {
 	const struct nfs_fh *		dir_fh;
 	const struct qstr *		name;
 	const u32 *			bitmask;
+	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_lookup_res {
 	const struct nfs_server *	server;
 	struct nfs_fattr *		fattr;
 	struct nfs_fh *			fh;
+	struct nfs4_sequence_res	seq_res;
 };
 
 struct nfs4_lookup_root_arg {
 	const u32 *			bitmask;
+	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_pathconf_arg {
 	const struct nfs_fh *		fh;
 	const u32 *			bitmask;
+	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_readdir_arg {
@@ -678,11 +722,13 @@ struct nfs4_readdir_arg {
 	struct page **			pages;	/* zero-copy data */
 	unsigned int			pgbase;	/* zero-copy data */
 	const u32 *			bitmask;
+	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_readdir_res {
 	nfs4_verifier			verifier;
 	unsigned int			pgbase;
+	struct nfs4_sequence_res	seq_res;
 };
 
 struct nfs4_readlink {
@@ -690,6 +736,7 @@ struct nfs4_readlink {
 	unsigned int			pgbase;
 	unsigned int			pglen;   /* zero-copy data */
 	struct page **			pages;   /* zero-copy data */
+	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_rename_arg {
@@ -698,6 +745,7 @@ struct nfs4_rename_arg {
 	const struct qstr *		old_name;
 	const struct qstr *		new_name;
 	const u32 *			bitmask;
+	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_rename_res {
@@ -706,6 +754,7 @@ struct nfs4_rename_res {
 	struct nfs_fattr *		old_fattr;
 	struct nfs4_change_info		new_cinfo;
 	struct nfs_fattr *		new_fattr;
+	struct nfs4_sequence_res	seq_res;
 };
 
 #define NFS4_SETCLIENTID_NAMELEN	(127)
@@ -724,6 +773,7 @@ struct nfs4_setclientid {
 struct nfs4_statfs_arg {
 	const struct nfs_fh *		fh;
 	const u32 *			bitmask;
+	struct nfs4_sequence_args	seq_args;
 };
 
 struct nfs4_server_caps_res {
@@ -731,6 +781,7 @@ struct nfs4_server_caps_res {
 	u32				acl_bitmask;
 	u32				has_links;
 	u32				has_symlinks;
+	struct nfs4_sequence_res	seq_res;
 };
 
 struct nfs4_string {
@@ -765,6 +816,7 @@ struct nfs4_fs_locations_arg {
 	const struct qstr *name;
 	struct page *page;
 	const u32 *bitmask;
+	struct nfs4_sequence_args	seq_args;
 };
 
 #endif /* CONFIG_NFS_V4 */

commit cc85906110e26fe8537c3bdbc08a74ae8110030b
Merge: c09bca786ff9 c69da774b28e
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Apr 1 13:28:15 2009 -0400

    Merge branch 'devel' into for-linus

commit f786aa90e026f2174bb0c26d49f338c5c46ede55
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Feb 20 05:51:22 2009 +0000

    constify dentry_operations: NFS
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 2e5f00066afd..43a713fce11c 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -785,7 +785,7 @@ struct nfs_access_entry;
  */
 struct nfs_rpc_ops {
 	u32	version;		/* Protocol version */
-	struct dentry_operations *dentry_ops;
+	const struct dentry_operations *dentry_ops;
 	const struct inode_operations *dir_inode_ops;
 	const struct inode_operations *file_inode_ops;
 

commit 7fe5c398fc2186ed586db11106a6692d871d0d58
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Mar 19 15:35:50 2009 -0400

    NFS: Optimise NFS close()
    
    Close-to-open cache consistency rules really only require us to flush out
    writes on calls to close(), and require us to revalidate attributes on the
    very last close of the file.
    
    Currently we appear to be doing a lot of extra attribute revalidation
    and cache flushes.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 0691b9c188d9..9708e78a4d49 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -868,6 +868,7 @@ struct nfs_rpc_ops {
 	int	(*lock)(struct file *, int, struct file_lock *);
 	int	(*lock_check_bounds)(const struct file_lock *);
 	void	(*clear_acl_cache)(struct inode *);
+	void	(*close_context)(struct nfs_open_context *ctx, int);
 };
 
 /*

commit bca794785c2c12ecddeb09e70165b8ff80baa6ae
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Mar 11 14:10:26 2009 -0400

    NFS: Fix the type of struct nfs_fattr->mode
    
    There is no point in using anything other than umode_t, since we copy the
    content pretty much directly into inode->i_mode.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 6013acb0131f..0691b9c188d9 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -28,8 +28,7 @@ static inline int nfs_fsid_equal(const struct nfs_fsid *a, const struct nfs_fsid
 
 struct nfs_fattr {
 	unsigned int		valid;		/* which fields are valid */
-	enum nfs_ftype		type;		/* always use NFSv2 types */
-	__u32			mode;
+	umode_t			mode;
 	__u32			nlink;
 	__u32			uid;
 	__u32			gid;

commit 1ca277d88dafdbc3c5a69d32590e7184b9af6371
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Mar 11 14:10:25 2009 -0400

    NFS: Shrink the struct nfs_fattr
    
    We don't need the bitmap[] field anymore, since the 'valid' field tells us
    all we need to know about which attributes were filled in...
    Also move the pre-op attributes in order to improve the structure packing.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index b99295e07cdf..6013acb0131f 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -28,9 +28,6 @@ static inline int nfs_fsid_equal(const struct nfs_fsid *a, const struct nfs_fsid
 
 struct nfs_fattr {
 	unsigned int		valid;		/* which fields are valid */
-	__u64			pre_size;	/* pre_op_attr.size	  */
-	struct timespec		pre_mtime;	/* pre_op_attr.mtime	  */
-	struct timespec		pre_ctime;	/* pre_op_attr.ctime	  */
 	enum nfs_ftype		type;		/* always use NFSv2 types */
 	__u32			mode;
 	__u32			nlink;
@@ -52,9 +49,11 @@ struct nfs_fattr {
 	struct timespec		atime;
 	struct timespec		mtime;
 	struct timespec		ctime;
-	__u32			bitmap[2];	/* NFSv4 returned attribute bitmap */
 	__u64			change_attr;	/* NFSv4 change attribute */
 	__u64			pre_change_attr;/* pre-op NFSv4 change attribute */
+	__u64			pre_size;	/* pre_op_attr.size	  */
+	struct timespec		pre_mtime;	/* pre_op_attr.mtime	  */
+	struct timespec		pre_ctime;	/* pre_op_attr.ctime	  */
 	unsigned long		time_start;
 	unsigned long		gencount;
 };

commit 9e6e70f8d8b6698e0017c56b86525aabe9c7cd4c
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Mar 11 14:10:24 2009 -0400

    NFSv4: Support NFSv4 optional attributes in the struct nfs_fattr
    
    Currently, filling struct nfs_fattr is more or less an all or nothing
    operation, since NFSv2 and NFSv3 have only mandatory attributes.
    In NFSv4, some attributes are optional, and so we may simply not be able to
    fill in those fields. Furthermore, NFSv4 allows you to specify which
    attributes you are interested in retrieving, thus permitting you to
    optimise away retrieval of attributes that you know will no change...
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 2e5f00066afd..b99295e07cdf 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -27,7 +27,7 @@ static inline int nfs_fsid_equal(const struct nfs_fsid *a, const struct nfs_fsid
 }
 
 struct nfs_fattr {
-	unsigned short		valid;		/* which fields are valid */
+	unsigned int		valid;		/* which fields are valid */
 	__u64			pre_size;	/* pre_op_attr.size	  */
 	struct timespec		pre_mtime;	/* pre_op_attr.mtime	  */
 	struct timespec		pre_ctime;	/* pre_op_attr.ctime	  */
@@ -59,12 +59,46 @@ struct nfs_fattr {
 	unsigned long		gencount;
 };
 
-#define NFS_ATTR_WCC		0x0001		/* pre-op WCC data    */
-#define NFS_ATTR_FATTR		0x0002		/* post-op attributes */
-#define NFS_ATTR_FATTR_V3	0x0004		/* NFSv3 attributes */
-#define NFS_ATTR_FATTR_V4	0x0008		/* NFSv4 change attribute */
-#define NFS_ATTR_WCC_V4		0x0010		/* pre-op change attribute */
-#define NFS_ATTR_FATTR_V4_REFERRAL	0x0020		/* NFSv4 referral */
+#define NFS_ATTR_FATTR_TYPE		(1U << 0)
+#define NFS_ATTR_FATTR_MODE		(1U << 1)
+#define NFS_ATTR_FATTR_NLINK		(1U << 2)
+#define NFS_ATTR_FATTR_OWNER		(1U << 3)
+#define NFS_ATTR_FATTR_GROUP		(1U << 4)
+#define NFS_ATTR_FATTR_RDEV		(1U << 5)
+#define NFS_ATTR_FATTR_SIZE		(1U << 6)
+#define NFS_ATTR_FATTR_PRESIZE		(1U << 7)
+#define NFS_ATTR_FATTR_BLOCKS_USED	(1U << 8)
+#define NFS_ATTR_FATTR_SPACE_USED	(1U << 9)
+#define NFS_ATTR_FATTR_FSID		(1U << 10)
+#define NFS_ATTR_FATTR_FILEID		(1U << 11)
+#define NFS_ATTR_FATTR_ATIME		(1U << 12)
+#define NFS_ATTR_FATTR_MTIME		(1U << 13)
+#define NFS_ATTR_FATTR_CTIME		(1U << 14)
+#define NFS_ATTR_FATTR_PREMTIME		(1U << 15)
+#define NFS_ATTR_FATTR_PRECTIME		(1U << 16)
+#define NFS_ATTR_FATTR_CHANGE		(1U << 17)
+#define NFS_ATTR_FATTR_PRECHANGE	(1U << 18)
+#define NFS_ATTR_FATTR_V4_REFERRAL	(1U << 19)	/* NFSv4 referral */
+
+#define NFS_ATTR_FATTR (NFS_ATTR_FATTR_TYPE \
+		| NFS_ATTR_FATTR_MODE \
+		| NFS_ATTR_FATTR_NLINK \
+		| NFS_ATTR_FATTR_OWNER \
+		| NFS_ATTR_FATTR_GROUP \
+		| NFS_ATTR_FATTR_RDEV \
+		| NFS_ATTR_FATTR_SIZE \
+		| NFS_ATTR_FATTR_FSID \
+		| NFS_ATTR_FATTR_FILEID \
+		| NFS_ATTR_FATTR_ATIME \
+		| NFS_ATTR_FATTR_MTIME \
+		| NFS_ATTR_FATTR_CTIME)
+#define NFS_ATTR_FATTR_V2 (NFS_ATTR_FATTR \
+		| NFS_ATTR_FATTR_BLOCKS_USED)
+#define NFS_ATTR_FATTR_V3 (NFS_ATTR_FATTR \
+		| NFS_ATTR_FATTR_SPACE_USED)
+#define NFS_ATTR_FATTR_V4 (NFS_ATTR_FATTR \
+		| NFS_ATTR_FATTR_SPACE_USED \
+		| NFS_ATTR_FATTR_CHANGE)
 
 /*
  * Info on the file system

commit ae46141ff08f1965b17c531b571953c39ce8b9e2
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Mar 10 20:33:18 2009 -0400

    NFSv3: Fix posix ACL code
    
    Fix a memory leak due to allocation in the XDR layer. In cases where the
    RPC call needs to be retransmitted, we end up allocating new pages without
    clearing the old ones. Fix this by moving the allocation into
    nfs3_proc_setacls().
    
    Also fix an issue discovered by Kevin Rudd, whereby the amount of memory
    reserved for the acls in the xdr_buf->head was miscalculated, and causing
    corruption.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index a550b528319f..2e5f00066afd 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -406,6 +406,8 @@ struct nfs3_setaclargs {
 	int			mask;
 	struct posix_acl *	acl_access;
 	struct posix_acl *	acl_default;
+	size_t			len;
+	unsigned int		npages;
 	struct page **		pages;
 };
 

commit dc0b027dfadfcb8a5504f7d8052754bf8d501ab9
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Dec 23 15:21:56 2008 -0500

    NFSv4: Convert the open and close ops to use fmode
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 32c1a0ecdbff..a550b528319f 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -120,6 +120,7 @@ struct nfs_openargs {
 	const struct nfs_fh *	fh;
 	struct nfs_seqid *	seqid;
 	int			open_flags;
+	fmode_t			fmode;
 	__u64                   clientid;
 	__u64                   id;
 	union {
@@ -171,7 +172,7 @@ struct nfs_closeargs {
 	struct nfs_fh *         fh;
 	nfs4_stateid *		stateid;
 	struct nfs_seqid *	seqid;
-	int			open_flags;
+	fmode_t			fmode;
 	const u32 *		bitmask;
 };
 

commit bd7bf9d540c001055fba796ebf146d90e4dd2eb2
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Dec 23 15:21:53 2008 -0500

    NFSv4: Convert delegation->type field to fmode_t
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index c1c31acb8a2b..32c1a0ecdbff 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -126,7 +126,7 @@ struct nfs_openargs {
 		struct iattr *  attrs;    /* UNCHECKED, GUARDED */
 		nfs4_verifier   verifier; /* EXCLUSIVE */
 		nfs4_stateid	delegation;		/* CLAIM_DELEGATE_CUR */
-		int		delegation_type;	/* CLAIM_PREVIOUS */
+		fmode_t		delegation_type;	/* CLAIM_PREVIOUS */
 	} u;
 	const struct qstr *	name;
 	const struct nfs_server *server;	 /* Needed for ID mapping */
@@ -143,7 +143,7 @@ struct nfs_openres {
 	struct nfs_fattr *      dir_attr;
 	struct nfs_seqid *	seqid;
 	const struct nfs_server *server;
-	int			delegation_type;
+	fmode_t			delegation_type;
 	nfs4_stateid		delegation;
 	__u32			do_recall;
 	__u64			maxsize;

commit 4704f0e274829e3af00737d2d9adace2d71a9605
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Oct 14 19:16:07 2008 -0400

    NFS: Fix the resolution problem with nfs_inode_attrs_need_update()
    
    It appears that 'jiffies' timestamps do not have high enough resolution for
    nfs_inode_attrs_need_update(). One problem is that a GETATTR can be
    launched within < 1 jiffy of the last operation that updated the attribute.
    Another problem is that RPC calls can take < 1 jiffy to execute.
    
    We can fix this by switching the variables to use a simple global counter
    that gets incremented every time we start another GETATTR call.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 6ee6ae3f095c..c1c31acb8a2b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -56,6 +56,7 @@ struct nfs_fattr {
 	__u64			change_attr;	/* NFSv4 change attribute */
 	__u64			pre_change_attr;/* pre-op NFSv4 change attribute */
 	unsigned long		time_start;
+	unsigned long		gencount;
 };
 
 #define NFS_ATTR_WCC		0x0001		/* pre-op WCC data    */

commit 19d771f3caccaf66ce2fb539319222139e5b4e88
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Oct 8 13:54:52 2008 -0400

    NFS: Save padding bytes in struct nfs4_setclientid
    
    Peter Staubach suggested reducing NFS4_SETCLIENTID_NAMELEN by one byte so
    as to avoid 7 bytes of unnecessary padding.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index f6e95bfad5de..6ee6ae3f095c 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -672,7 +672,7 @@ struct nfs4_rename_res {
 	struct nfs_fattr *		new_fattr;
 };
 
-#define NFS4_SETCLIENTID_NAMELEN	(128)
+#define NFS4_SETCLIENTID_NAMELEN	(127)
 struct nfs4_setclientid {
 	const nfs4_verifier *		sc_verifier;
 	unsigned int			sc_name_len;

commit d1ce02e1689dff9d413138f60a79b4e3affb4708
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Thu Sep 25 11:57:12 2008 -0400

    NFS: SETCLIENTID truncates client ID and netid
    
    The sc_name field is currently 56 bytes long.  This is not large enough
    to hold a pair of IPv6 addresses, the authentication type, the protocol
    name, and a uniquifier number.  The maximum possible size of the name
    string using IPv6 addresses is just under 110 bytes, so I increased the
    size of the sc_name field to accomodate this maximum.
    
    In addition, the strings in the nfs4_setclientid structure are
    constructed with scnprintf(), which wants to terminate its output with
    '\0'.  The sc_netid field was large enough only for a three byte netid
    string and a '\0' so inet6 netids were being truncated.  Perhaps we
    don't need the overhead of scnprintf() to do a simple string copy, but
    I fixed this by increasing the size of the buffer by one byte.
    
    Since all three of the string buffers in nfs4_setclientid are
    constructed with scnprintf(), I increased the size of all three by one
    byte to document the requirement, although I don't think either the
    universal address field or the name field will be so small that these
    strings get truncated in this way.
    
    The size of the Linux client's client ID on the wire will be larger
    than before.  RFC 3530 suggests the size limit for client IDs is 1024,
    and we are still well below that.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 9cabbb3a9e6d..f6e95bfad5de 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -672,16 +672,16 @@ struct nfs4_rename_res {
 	struct nfs_fattr *		new_fattr;
 };
 
-#define NFS4_SETCLIENTID_NAMELEN	(56)
+#define NFS4_SETCLIENTID_NAMELEN	(128)
 struct nfs4_setclientid {
 	const nfs4_verifier *		sc_verifier;
 	unsigned int			sc_name_len;
-	char				sc_name[NFS4_SETCLIENTID_NAMELEN];
+	char				sc_name[NFS4_SETCLIENTID_NAMELEN + 1];
 	u32				sc_prog;
 	unsigned int			sc_netid_len;
-	char				sc_netid[RPCBIND_MAXNETIDLEN];
+	char				sc_netid[RPCBIND_MAXNETIDLEN + 1];
 	unsigned int			sc_uaddr_len;
-	char				sc_uaddr[RPCBIND_MAXUADDRLEN];
+	char				sc_uaddr[RPCBIND_MAXUADDRLEN + 1];
 	u32				sc_cb_ident;
 };
 

commit 9fa8d66f1e55bf197568c8c689043c2aad1ffc97
Author: Richard Kennedy <richard@rsk.demon.co.uk>
Date:   Tue Aug 26 16:23:20 2008 +0100

    NFS: remove 8 bytes of padding from struct nfs_fattr on 64 bit builds
    
    remove 8 bytes of padding from struct nfs_fattr on 64 bit builds
    
    This also removes padding from several nfs structures, including
    16 bytes from  nfs4_opendata, nfs4_createdata,nfs3_createdata
    & 8 bytes from nfs_read_data,nfs_write_data,nfs_removeres,nfs4_closedata
    
    This also reduces the reported stack usage of many nfs functions (30+).
    
    Signed-off-by: Richard Kennedy <richard@rsk.demon.co.uk>
    ----
    
    This patch is against the latest git 2.6.27-rc4.
    I've built & run this on my AMD64 desktop, & successfully run _simple_
    tests with a  64 bit client => 32 bit server & 32 bit client to 64 bit
    server.
    
    On fedora with gcc (GCC) 4.3.0 20080428 (Red Hat 4.3.0-8) checkpatch
    reports 33 functions with reduced stack usage.
    e.g.
    __nfs_revalidate_inode [nfs] 216 => 200
    _nfs4_proc_access [nfs] 304 => 288
    _nfs4_proc_link [nfs] 536 => 504
    _nfs4_proc_remove [nfs] 304 => 288
    _nfs4_proc_rename [nfs] 584 => 552
    nfs3_proc_access [nfs] 272 => 256
    nfs3_proc_getacl [nfs] 384 => 368
    nfs3_proc_link [nfs] 496 => 464
    etc
    I can supply the complete list if anyone is interested.
    
    regards
    Richard
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 8c77c11224d1..9cabbb3a9e6d 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -36,6 +36,7 @@ struct nfs_fattr {
 	__u32			nlink;
 	__u32			uid;
 	__u32			gid;
+	dev_t			rdev;
 	__u64			size;
 	union {
 		struct {
@@ -46,7 +47,6 @@ struct nfs_fattr {
 			__u64	used;
 		} nfs3;
 	} du;
-	dev_t			rdev;
 	struct nfs_fsid		fsid;
 	__u64			fileid;
 	struct timespec		atime;

commit 46cb650c224bb8e64a749090105d74b9e8eda669
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Jun 11 16:32:46 2008 -0400

    NFS: Remove the redundant file_open entry from struct nfs_rpc_ops
    
    All instances are set to nfs_open(), so we should just remove the redundant
    indirection. Ditto for the file_release op
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 8d780de371f0..8c77c11224d1 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -829,8 +829,6 @@ struct nfs_rpc_ops {
 	int	(*write_done)  (struct rpc_task *, struct nfs_write_data *);
 	void	(*commit_setup) (struct nfs_write_data *, struct rpc_message *);
 	int	(*commit_done) (struct rpc_task *, struct nfs_write_data *);
-	int	(*file_open)   (struct inode *, struct file *);
-	int	(*file_release) (struct inode *, struct file *);
 	int	(*lock)(struct file *, int, struct file_lock *);
 	int	(*lock_check_bounds)(const struct file_lock *);
 	void	(*clear_acl_cache)(struct inode *);

commit 2116271a347d1181b5497602c2bfada1de8fd53b
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue May 20 19:34:39 2008 -0400

    NFS: Add correct bounds checking to NFSv2 locks
    
    NFSv2 file locking currently fails the Connectathon tests, because the
    calls to the VFS locking code do not return an EINVAL error if the
    struct file_lock overflows the 32-bit boundaries.
    
    The problem is due to the fact that we occasionally call helpers from
    fs/locks.c in order to avoid RPC calls to the server when we know that a
    local process holds the lock. These helpers are, of course, always
    64-bit enabled, so EINVAL is not returned in cases when it would if
    the call had gone to the NLM code.
    
    For consistency, we therefore add support for a bounds-checking helper.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 24263bb8e0be..8d780de371f0 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -832,6 +832,7 @@ struct nfs_rpc_ops {
 	int	(*file_open)   (struct inode *, struct file *);
 	int	(*file_release) (struct inode *, struct file *);
 	int	(*lock)(struct file *, int, struct file_lock *);
+	int	(*lock_check_bounds)(const struct file_lock *);
 	void	(*clear_acl_cache)(struct inode *);
 };
 

commit c1d519312dcdf11532fed9f99a8ecc3547ffd9d6
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Apr 7 13:20:54 2008 -0400

    NFSv4: Only increment the sequence id if the server saw it
    
    It is quite possible that the OPEN, CLOSE, LOCK, LOCKU,... compounds fail
    before the actual stateful operation has been executed (for instance in the
    PUTFH call). There is no way to tell from the overall status result which
    operations were executed from the COMPOUND.
    
    The fix is to move incrementing of the sequence id into the XDR layer,
    so that we do it as we process the results from the stateful operation.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index f301d0b8babc..24263bb8e0be 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -140,6 +140,7 @@ struct nfs_openres {
 	__u32                   rflags;
 	struct nfs_fattr *      f_attr;
 	struct nfs_fattr *      dir_attr;
+	struct nfs_seqid *	seqid;
 	const struct nfs_server *server;
 	int			delegation_type;
 	nfs4_stateid		delegation;
@@ -159,6 +160,7 @@ struct nfs_open_confirmargs {
 
 struct nfs_open_confirmres {
 	nfs4_stateid            stateid;
+	struct nfs_seqid *	seqid;
 };
 
 /*
@@ -175,6 +177,7 @@ struct nfs_closeargs {
 struct nfs_closeres {
 	nfs4_stateid            stateid;
 	struct nfs_fattr *	fattr;
+	struct nfs_seqid *	seqid;
 	const struct nfs_server *server;
 };
 /*
@@ -199,7 +202,9 @@ struct nfs_lock_args {
 };
 
 struct nfs_lock_res {
-	nfs4_stateid			stateid;
+	nfs4_stateid		stateid;
+	struct nfs_seqid *	lock_seqid;
+	struct nfs_seqid *	open_seqid;
 };
 
 struct nfs_locku_args {
@@ -210,7 +215,8 @@ struct nfs_locku_args {
 };
 
 struct nfs_locku_res {
-	nfs4_stateid			stateid;
+	nfs4_stateid		stateid;
+	struct nfs_seqid *	seqid;
 };
 
 struct nfs_lockt_args {

commit c0e07cb68db353c0ffbb0f82401cf6d79c253aed
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Jan 14 12:32:05 2008 -0500

    NFS: NFS version number is unsigned
    
    RPC protocol version numbers are unsigned.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index d342ae5c76ab..f301d0b8babc 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -774,7 +774,7 @@ struct nfs_access_entry;
  * RPC procedure vector for NFSv2/NFSv3 demuxing
  */
 struct nfs_rpc_ops {
-	int	version;		/* Protocol version */
+	u32	version;		/* Protocol version */
 	struct dentry_operations *dentry_ops;
 	const struct inode_operations *dir_inode_ops;
 	const struct inode_operations *file_inode_ops;

commit 69dd716c5ffd89f5ba14ffb871d633ecea74d13a
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Dec 14 14:56:07 2007 -0500

    NFSv4: Add socket proto argument to setclientid
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index d8e395d0c7c9..d342ae5c76ab 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -666,7 +666,7 @@ struct nfs4_rename_res {
 	struct nfs_fattr *		new_fattr;
 };
 
-#define NFS4_SETCLIENTID_NAMELEN	(48)
+#define NFS4_SETCLIENTID_NAMELEN	(56)
 struct nfs4_setclientid {
 	const nfs4_verifier *		sc_verifier;
 	unsigned int			sc_name_len;

commit cc38bac3a0093b3b7928efc6ff8e9faf9e75f41d
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Dec 10 14:56:54 2007 -0500

    NFS: Ensure NFSv4 SETCLIENTID send buffer is large enough
    
    Ensure that the RPC buffer size specified for NFSv4 SETCLIENTID procedures
    matches what we are encoding into the buffer.  See the definition of
    struct nfs4_setclientid {} and the encode_setclientid() function.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 6b213a64b15f..d8e395d0c7c9 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -666,16 +666,17 @@ struct nfs4_rename_res {
 	struct nfs_fattr *		new_fattr;
 };
 
+#define NFS4_SETCLIENTID_NAMELEN	(48)
 struct nfs4_setclientid {
-	const nfs4_verifier *		sc_verifier;      /* request */
+	const nfs4_verifier *		sc_verifier;
 	unsigned int			sc_name_len;
-	char				sc_name[48];	  /* request */
-	u32				sc_prog;          /* request */
+	char				sc_name[NFS4_SETCLIENTID_NAMELEN];
+	u32				sc_prog;
 	unsigned int			sc_netid_len;
-	char				sc_netid[4];	  /* request */
+	char				sc_netid[RPCBIND_MAXNETIDLEN];
 	unsigned int			sc_uaddr_len;
-	char				sc_uaddr[24];     /* request */
-	u32				sc_cb_ident;      /* request */
+	char				sc_uaddr[RPCBIND_MAXUADDRLEN];
+	u32				sc_cb_ident;
 };
 
 struct nfs4_statfs_arg {

commit bdc7f021f3a1fade77adf3c2d7f65690566fddfe
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sat Jul 14 15:40:00 2007 -0400

    NFS: Clean up the (commit|read|write)_setup() callback routines
    
    Move the common code for setting up the nfs_write_data and nfs_read_data
    structures into fs/nfs/read.c, fs/nfs/write.c and fs/nfs/direct.c.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index daab252f2e5c..6b213a64b15f 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -816,11 +816,11 @@ struct nfs_rpc_ops {
 			     struct nfs_pathconf *);
 	int	(*set_capabilities)(struct nfs_server *, struct nfs_fh *);
 	__be32 *(*decode_dirent)(__be32 *, struct nfs_entry *, int plus);
-	void	(*read_setup)   (struct nfs_read_data *);
+	void	(*read_setup)   (struct nfs_read_data *, struct rpc_message *);
 	int	(*read_done)  (struct rpc_task *, struct nfs_read_data *);
-	void	(*write_setup)  (struct nfs_write_data *, int how);
+	void	(*write_setup)  (struct nfs_write_data *, struct rpc_message *);
 	int	(*write_done)  (struct rpc_task *, struct nfs_write_data *);
-	void	(*commit_setup) (struct nfs_write_data *, int how);
+	void	(*commit_setup) (struct nfs_write_data *, struct rpc_message *);
 	int	(*commit_done) (struct rpc_task *, struct nfs_write_data *);
 	int	(*file_open)   (struct inode *, struct file *);
 	int	(*file_release) (struct inode *, struct file *);

commit 70ca88521fc7bee8ef0fc22033a439d4b9a2c70d
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sun Sep 30 15:21:24 2007 -0400

    NFS: Fake up 'wcc' attributes to prevent cache invalidation after write
    
    NFSv2 and v4 don't offer weak cache consistency attributes on WRITE calls.
    In NFSv3, returning wcc data is optional. In all cases, we want to prevent
    the client from invalidating our cached data whenever ->write_done()
    attempts to update the inode attributes.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 03032017ffaa..daab252f2e5c 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -62,7 +62,8 @@ struct nfs_fattr {
 #define NFS_ATTR_FATTR		0x0002		/* post-op attributes */
 #define NFS_ATTR_FATTR_V3	0x0004		/* NFSv3 attributes */
 #define NFS_ATTR_FATTR_V4	0x0008		/* NFSv4 change attribute */
-#define NFS_ATTR_FATTR_V4_REFERRAL	0x0010		/* NFSv4 referral */
+#define NFS_ATTR_WCC_V4		0x0010		/* pre-op change attribute */
+#define NFS_ATTR_FATTR_V4_REFERRAL	0x0020		/* NFSv4 referral */
 
 /*
  * Info on the file system

commit 76b32999dfff6e59252a8af17a5671a4cf3bcf9b
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Aug 10 17:45:11 2007 -0400

    NFSv4: Make NFSv4 ACCESS calls return attributes too...
    
    It doesn't really make sense to cache an access call without also
    revalidating the attributes.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index cf74a4db84a5..03032017ffaa 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -538,10 +538,13 @@ typedef u64 clientid4;
 
 struct nfs4_accessargs {
 	const struct nfs_fh *		fh;
+	const u32 *			bitmask;
 	u32				access;
 };
 
 struct nfs4_accessres {
+	const struct nfs_server *	server;
+	struct nfs_fattr *		fattr;
 	u32				supported;
 	u32				access;
 };

commit e4eff1a622edd6ab7b73acd5d8763aa2fa3fee49
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sat Jul 14 15:39:58 2007 -0400

    SUNRPC: Clean up the sillyrename code
    
    Fix a couple of bugs:
     - Don't rely on the parent dentry still being valid when the call completes.
       Fixes a race with shrink_dcache_for_umount_subtree()
    
     - Don't remove the file if the filehandle has been labelled as stale.
    
    Fix a couple of inefficiencies
     - Remove the global list of sillyrenamed files. Instead we can cache the
       sillyrename information in the dentry->d_fsdata
     - Move common code from unlink_setup/unlink_done into fs/nfs/unlink.c
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 7babcb16300b..cf74a4db84a5 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -791,9 +791,8 @@ struct nfs_rpc_ops {
 	int	(*create)  (struct inode *, struct dentry *,
 			    struct iattr *, int, struct nameidata *);
 	int	(*remove)  (struct inode *, struct qstr *);
-	int	(*unlink_setup)  (struct rpc_message *,
-			    struct dentry *, struct qstr *);
-	int	(*unlink_done) (struct dentry *, struct rpc_task *);
+	void	(*unlink_setup)  (struct rpc_message *, struct inode *dir);
+	int	(*unlink_done) (struct rpc_task *, struct inode *);
 	int	(*rename)  (struct inode *, struct qstr *,
 			    struct inode *, struct qstr *);
 	int	(*link)    (struct inode *, struct inode *, struct qstr *);

commit 4fdc17b2a7f4d9db5b08e0f963d0027f714e4104
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sat Jul 14 15:39:57 2007 -0400

    NFS: Introduce struct nfs_removeargs+nfs_removeres
    
    We need a common structure for setting up an unlink() rpc call in order to
    fix the asynchronous unlink code.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 38d77681cf27..7babcb16300b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -277,6 +277,21 @@ struct nfs_writeres {
 	const struct nfs_server *server;
 };
 
+/*
+ * Common arguments to the unlink call
+ */
+struct nfs_removeargs {
+	const struct nfs_fh	*fh;
+	struct qstr		name;
+	const u32 *		bitmask;
+};
+
+struct nfs_removeres {
+	const struct nfs_server *server;
+	struct nfs4_change_info	cinfo;
+	struct nfs_fattr	dir_attr;
+};
+
 /*
  * Argument struct for decode_entry function
  */
@@ -631,18 +646,6 @@ struct nfs4_readlink {
 	struct page **			pages;   /* zero-copy data */
 };
 
-struct nfs4_remove_arg {
-	const struct nfs_fh *		fh;
-	const struct qstr *		name;
-	const u32 *			bitmask;
-};
-
-struct nfs4_remove_res {
-	const struct nfs_server *	server;
-	struct nfs4_change_info		cinfo;
-	struct nfs_fattr *		dir_attr;
-};
-
 struct nfs4_rename_arg {
 	const struct nfs_fh *		old_dir;
 	const struct nfs_fh *		new_dir;

commit 9f958ab8858c75df800e0121b1920182820cbc39
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Jul 2 13:58:33 2007 -0400

    NFSv4: Reduce the chances of an open_owner identifier collision
    
    Currently we just use a 32-bit counter.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index f7100df3a690..38d77681cf27 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -119,7 +119,7 @@ struct nfs_openargs {
 	struct nfs_seqid *	seqid;
 	int			open_flags;
 	__u64                   clientid;
-	__u32                   id;
+	__u64                   id;
 	union {
 		struct iattr *  attrs;    /* UNCHECKED, GUARDED */
 		nfs4_verifier   verifier; /* EXCLUSIVE */
@@ -181,7 +181,7 @@ struct nfs_closeres {
  *   */
 struct nfs_lowner {
 	__u64			clientid;
-	u32			id;
+	__u64			id;
 };
 
 struct nfs_lock_args {

commit aa53ed541a1fec78a78d02afc8b042d040cc080d
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Jun 5 14:49:03 2007 -0400

    NFS4: on a O_EXCL OPEN make sure SETATTR sets the fields holding the verifier
    
    The Linux NFS4 client simply skips over the bitmask in an O_EXCL open
    call and so it doesn't bother to reset any fields that may be holding
    the verifier. This patch has us save the first two words of the bitmask
    (which is all the current client has #defines for). The client then
    later checks this bitmask and turns on the appropriate flags in the
    sattr->ia_verify field for the following SETATTR call.
    
    This patch only currently checks to see if the server used the atime
    and mtime slots for the verifier (which is what the Linux server uses
    for this). I'm not sure of what other fields the server could
    reasonably use, but adding checks for others should be trivial.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 10c26ed0db71..f7100df3a690 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -144,6 +144,7 @@ struct nfs_openres {
 	nfs4_stateid		delegation;
 	__u32			do_recall;
 	__u64			maxsize;
+	__u32			attrset[NFS4_BITMAP_SIZE];
 };
 
 /*

commit d9bc125caf592b7d081021f32ce5b717efdf70c8
Merge: 43d78ef2ba5b ec2f9d1331f6
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Feb 12 22:43:25 2007 -0800

    Merge branch 'master' of /home/trondmy/kernel/linux-2.6/
    
    Conflicts:
    
            net/sunrpc/auth_gss/gss_krb5_crypto.c
            net/sunrpc/auth_gss/gss_spkm3_token.c
            net/sunrpc/clnt.c
    
    Merge with mainline and fix conflicts.

commit c5ef1c42c51b1b5b4a401a6517bdda30933ddbaf
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:40 2007 -0800

    [PATCH] mark struct inode_operations const 3
    
    Many struct inode_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 9ee9da5e1cc9..30d7116d601e 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -767,8 +767,8 @@ struct nfs_access_entry;
 struct nfs_rpc_ops {
 	int	version;		/* Protocol version */
 	struct dentry_operations *dentry_ops;
-	struct inode_operations *dir_inode_ops;
-	struct inode_operations *file_inode_ops;
+	const struct inode_operations *dir_inode_ops;
+	const struct inode_operations *file_inode_ops;
 
 	int	(*getroot) (struct nfs_server *, struct nfs_fh *,
 			    struct nfs_fsinfo *);

commit 8e0969f0451eaf7cf32f2ec3946196d8d0b1cb2c
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Dec 13 15:23:44 2006 -0500

    NFS: Remove nfs_readpage_sync()
    
    It makes no sense to maintain 2 parallel systems for reading in pages.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 9ee9da5e1cc9..115c8120ff13 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -784,7 +784,6 @@ struct nfs_rpc_ops {
 	int	(*access)  (struct inode *, struct nfs_access_entry *);
 	int	(*readlink)(struct inode *, struct page *, unsigned int,
 			    unsigned int);
-	int	(*read)    (struct nfs_read_data *);
 	int	(*create)  (struct inode *, struct dentry *,
 			    struct iattr *, int, struct nameidata *);
 	int	(*remove)  (struct inode *, struct qstr *);

commit 200baa2112012dd8a13db9da3ee6885403f9c013
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Dec 5 00:35:40 2006 -0500

    NFS: Remove nfs_writepage_sync()
    
    Maintaining two parallel ways of doing synchronous writes is rather
    pointless. This patch gets rid of the legacy nfs_writepage_sync(), and
    replaces it with the faster asynchronous writes.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 768c1ad5ff6f..9ee9da5e1cc9 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -785,8 +785,6 @@ struct nfs_rpc_ops {
 	int	(*readlink)(struct inode *, struct page *, unsigned int,
 			    unsigned int);
 	int	(*read)    (struct nfs_read_data *);
-	int	(*write)   (struct nfs_write_data *);
-	int	(*commit)  (struct nfs_write_data *);
 	int	(*create)  (struct inode *, struct dentry *,
 			    struct iattr *, int, struct nameidata *);
 	int	(*remove)  (struct inode *, struct qstr *);

commit bc4785cd475a11ba125df7af674e16c6ea1cfc30
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Oct 19 23:28:51 2006 -0700

    [PATCH] nfs: verifier is network-endian
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: Trond Myklebust <trond.myklebust@fys.uio.no>
    Acked-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index ac8058bc8f94..768c1ad5ff6f 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -266,7 +266,7 @@ struct nfs_writeargs {
 
 struct nfs_writeverf {
 	enum nfs3_stable_how	committed;
-	__u32			verifier[2];
+	__be32			verifier[2];
 };
 
 struct nfs_writeres {
@@ -420,7 +420,7 @@ struct nfs3_createargs {
 	unsigned int		len;
 	struct iattr *		sattr;
 	enum nfs3_createmode	createmode;
-	__u32			verifier[2];
+	__be32			verifier[2];
 };
 
 struct nfs3_mkdirargs {
@@ -467,7 +467,7 @@ struct nfs3_linkargs {
 struct nfs3_readdirargs {
 	struct nfs_fh *		fh;
 	__u64			cookie;
-	__u32			verf[2];
+	__be32			verf[2];
 	int			plus;
 	unsigned int            count;
 	struct page **		pages;
@@ -503,7 +503,7 @@ struct nfs3_linkres {
 
 struct nfs3_readdirres {
 	struct nfs_fattr *	dir_attr;
-	__u32 *			verf;
+	__be32 *		verf;
 	int			plus;
 };
 

commit 0dbb4c6799cf8fa8c5ba1926153a30960117477d
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Oct 19 23:28:49 2006 -0700

    [PATCH] xdr annotations: NFS readdir entries
    
    on-the-wire data is big-endian
    
    [in large part pulled from Alexey's patch]
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: Trond Myklebust <trond.myklebust@fys.uio.no>
    Acked-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index dc5397d9d23c..ac8058bc8f94 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -811,7 +811,7 @@ struct nfs_rpc_ops {
 	int	(*pathconf) (struct nfs_server *, struct nfs_fh *,
 			     struct nfs_pathconf *);
 	int	(*set_capabilities)(struct nfs_server *, struct nfs_fh *);
-	u32 *	(*decode_dirent)(u32 *, struct nfs_entry *, int plus);
+	__be32 *(*decode_dirent)(__be32 *, struct nfs_entry *, int plus);
 	void	(*read_setup)   (struct nfs_read_data *);
 	int	(*read_done)  (struct rpc_task *, struct nfs_read_data *);
 	void	(*write_setup)  (struct nfs_write_data *, int how);

commit 94a6d75320b3681e6e728b70e18bd186cb55e682
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Aug 22 20:06:23 2006 -0400

    NFS: Use cached page as buffer for NFS symlink requests
    
    Now that we have a copy of the symlink path in the page cache, we can pass
    a struct page down to the XDR routines instead of a string buffer.
    
    Test plan:
    Connectathon, all NFS versions.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index ddf5d75e97a2..dc5397d9d23c 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -358,8 +358,8 @@ struct nfs_symlinkargs {
 	struct nfs_fh *		fromfh;
 	const char *		fromname;
 	unsigned int		fromlen;
-	const char *		topath;
-	unsigned int		tolen;
+	struct page **		pages;
+	unsigned int		pathlen;
 	struct iattr *		sattr;
 };
 
@@ -434,8 +434,8 @@ struct nfs3_symlinkargs {
 	struct nfs_fh *		fromfh;
 	const char *		fromname;
 	unsigned int		fromlen;
-	const char *		topath;
-	unsigned int		tolen;
+	struct page **		pages;
+	unsigned int		pathlen;
 	struct iattr *		sattr;
 };
 
@@ -533,7 +533,10 @@ struct nfs4_accessres {
 struct nfs4_create_arg {
 	u32				ftype;
 	union {
-		struct qstr *		symlink;    /* NF4LNK */
+		struct {
+			struct page **	pages;
+			unsigned int	len;
+		} symlink;   /* NF4LNK */
 		struct {
 			u32		specdata1;
 			u32		specdata2;
@@ -793,8 +796,8 @@ struct nfs_rpc_ops {
 	int	(*rename)  (struct inode *, struct qstr *,
 			    struct inode *, struct qstr *);
 	int	(*link)    (struct inode *, struct inode *, struct qstr *);
-	int	(*symlink) (struct inode *, struct dentry *, struct qstr *,
-			    struct iattr *);
+	int	(*symlink) (struct inode *, struct dentry *, struct page *,
+			    unsigned int, struct iattr *);
 	int	(*mkdir)   (struct inode *, struct dentry *, struct iattr *);
 	int	(*rmdir)   (struct inode *, struct qstr *);
 	int	(*readdir) (struct dentry *, struct rpc_cred *,

commit 4f390c152bc87165da4b1f5b7d870b46fb106d4e
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Aug 22 20:06:22 2006 -0400

    NFS: Fix double d_drop in nfs_instantiate() error path
    
    If the LOOKUP or GETATTR in nfs_instantiate fail, nfs_instantiate will do a
    d_drop before returning.  But some callers already do a d_drop in the case
    of an error return.  Make certain we do only one d_drop in all error paths.
    
    This issue was introduced because over time, the symlink proc API diverged
    slightly from the create/mkdir/mknod proc API.  To prevent other coding
    mistakes of this type, change the symlink proc API to be more like
    create/mkdir/mknod and move the nfs_instantiate call into the symlink proc
    routines so it is used in exactly the same way for create, mkdir, mknod,
    and symlink.
    
    Test plan:
    Connectathon, all versions of NFS.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 0f33e621892f..ddf5d75e97a2 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -793,9 +793,8 @@ struct nfs_rpc_ops {
 	int	(*rename)  (struct inode *, struct qstr *,
 			    struct inode *, struct qstr *);
 	int	(*link)    (struct inode *, struct inode *, struct qstr *);
-	int	(*symlink) (struct inode *, struct qstr *, struct qstr *,
-			    struct iattr *, struct nfs_fh *,
-			    struct nfs_fattr *);
+	int	(*symlink) (struct inode *, struct dentry *, struct qstr *,
+			    struct iattr *);
 	int	(*mkdir)   (struct inode *, struct dentry *, struct iattr *);
 	int	(*rmdir)   (struct inode *, struct qstr *);
 	int	(*readdir) (struct dentry *, struct rpc_cred *,

commit 39d7bbcb5ba5e9d8d658b70903dd7939400e57db
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Aug 22 20:06:18 2006 -0400

    SUNRPC: remove extraneous header inclusions
    
    include/linux/sunrpc/clnt.h already includes include/linux/sunrpc/xprt.h.
    We can remove xprt.h from source files that already include clnt.h.
    Likewise include/linux/sunrpc/timer.h.
    
    Test plan:
    Compile kernel with CONFIG_NFS enabled.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 2426b11b6cce..0f33e621892f 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1,7 +1,6 @@
 #ifndef _LINUX_NFS_XDR_H
 #define _LINUX_NFS_XDR_H
 
-#include <linux/sunrpc/xprt.h>
 #include <linux/nfsacl.h>
 
 /*

commit 509de8111656a7d89b4a1a5f430f4460ce510f0f
Author: David Howells <dhowells@redhat.com>
Date:   Tue Aug 22 20:06:11 2006 -0400

    NFS: Add extra const qualifiers
    
    Add some extra const qualifiers into NFS.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index dd9ae6761f71..2426b11b6cce 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -833,9 +833,9 @@ struct nfs_rpc_ops {
 /*
  * Function vectors etc. for the NFS client
  */
-extern struct nfs_rpc_ops	nfs_v2_clientops;
-extern struct nfs_rpc_ops	nfs_v3_clientops;
-extern struct nfs_rpc_ops	nfs_v4_clientops;
+extern const struct nfs_rpc_ops	nfs_v2_clientops;
+extern const struct nfs_rpc_ops	nfs_v3_clientops;
+extern const struct nfs_rpc_ops	nfs_v4_clientops;
 extern struct rpc_version	nfs_version2;
 extern struct rpc_version	nfs_version3;
 extern struct rpc_version	nfs_version4;

commit e9326dcab413848e70ab746c7c5363da13e5f801
Author: David Howells <dhowells@redhat.com>
Date:   Tue Aug 22 20:06:10 2006 -0400

    NFS: Add a server capabilities NFS RPC op
    
    Add a set_capabilities NFS RPC op so that the server capabilities can be set.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 26879771831d..dd9ae6761f71 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -809,6 +809,7 @@ struct nfs_rpc_ops {
 			    struct nfs_fsinfo *);
 	int	(*pathconf) (struct nfs_server *, struct nfs_fh *,
 			     struct nfs_pathconf *);
+	int	(*set_capabilities)(struct nfs_server *, struct nfs_fh *);
 	u32 *	(*decode_dirent)(u32 *, struct nfs_entry *, int plus);
 	void	(*read_setup)   (struct nfs_read_data *);
 	int	(*read_done)  (struct rpc_task *, struct nfs_read_data *);

commit 2b3de4411b3ccaeb00018c99d1bbe7203554cf7f
Author: David Howells <dhowells@redhat.com>
Date:   Tue Aug 22 20:06:09 2006 -0400

    NFS: Add a lookupfh NFS RPC op
    
    Add a lookup filehandle NFS RPC op so that a file handle can be looked up
    without requiring dentries and inodes and other VFS stuff when doing an NFS4
    pathwalk during mounting.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 41e5a19199e9..26879771831d 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -770,6 +770,9 @@ struct nfs_rpc_ops {
 
 	int	(*getroot) (struct nfs_server *, struct nfs_fh *,
 			    struct nfs_fsinfo *);
+	int	(*lookupfh)(struct nfs_server *, struct nfs_fh *,
+			    struct qstr *, struct nfs_fh *,
+			    struct nfs_fattr *);
 	int	(*getattr) (struct nfs_server *, struct nfs_fh *,
 			    struct nfs_fattr *);
 	int	(*setattr) (struct dentry *, struct nfs_fattr *,

commit e9f7bee1df223dcf83743b46cb06c08d95497ec0
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Sep 8 09:48:54 2006 -0700

    [PATCH] NFS: large non-page-aligned direct I/O clobbers memory
    
    The logic in nfs_direct_read_schedule and nfs_direct_write_schedule can
    allow data->npages to be one larger than rpages.  This causes a page
    pointer to be written beyond the end of the pagevec in nfs_read_data (or
    nfs_write_data).
    
    Fix this by making nfs_(read|write)_alloc() calculate the size of the
    pagevec array, and initialise data->npages.
    
    Also get rid of the redundant argument to nfs_commit_alloc().
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Cc: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index db9cbf68e12b..41e5a19199e9 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -729,7 +729,7 @@ struct nfs_read_data {
 	struct list_head	pages;	/* Coalesced read requests */
 	struct nfs_page		*req;	/* multi ops per nfs_page */
 	struct page		**pagevec;
-	unsigned int		npages;	/* active pages in pagevec */
+	unsigned int		npages;	/* Max length of pagevec */
 	struct nfs_readargs args;
 	struct nfs_readres  res;
 #ifdef CONFIG_NFS_V4
@@ -748,7 +748,7 @@ struct nfs_write_data {
 	struct list_head	pages;		/* Coalesced requests we wish to flush */
 	struct nfs_page		*req;		/* multi ops per nfs_page */
 	struct page		**pagevec;
-	unsigned int		npages;		/* active pages in pagevec */
+	unsigned int		npages;		/* Max length of pagevec */
 	struct nfs_writeargs	args;		/* argument struct */
 	struct nfs_writeres	res;		/* result struct */
 #ifdef CONFIG_NFS_V4

commit 3cedf13af9f7e61aca0dbbd11b601ac93bf93a9f
Author: J. Bruce Fields <bfields@fieldses.org>
Date:   Thu Aug 24 15:44:12 2006 -0400

    NFSv4: increase client-provided nfs4 clientid size
    
    Neil Brown observed that the current limit of 32 bytes isn't enough to hold two
    ip addresses and the rest of the stuff we're putting in it, so it's often
    truncated to the point where it's unlikely to be unique.  This can cause
    spurious CLID_INUSE's from the server.
    
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    (cherry picked from fc8c17ec251e984ab3df9182ed097aa5b577c915 commit)

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 2d3fb6416d91..db9cbf68e12b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -659,7 +659,7 @@ struct nfs4_rename_res {
 struct nfs4_setclientid {
 	const nfs4_verifier *		sc_verifier;      /* request */
 	unsigned int			sc_name_len;
-	char				sc_name[32];	  /* request */
+	char				sc_name[48];	  /* request */
 	u32				sc_prog;          /* request */
 	unsigned int			sc_netid_len;
 	char				sc_netid[4];	  /* request */

commit 607f31e80b6f982d7c0dd7a5045377fc368fe507
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Jun 28 16:52:45 2006 -0400

    Revert "Merge branch 'odirect'"
    
    This reverts ccf01ef7aa9c6c293a1c64c27331a2ce227916ec commit.
    
    No idea how git managed this one: when I asked it to merge the odirect
    topic branch it actually generated a patch which reverted the change.
    
    Reverting the 'merge' will once again reveal Chuck's recent NFS/O_DIRECT
    work to the world.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 7c7320fa51aa..2d3fb6416d91 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -729,6 +729,7 @@ struct nfs_read_data {
 	struct list_head	pages;	/* Coalesced read requests */
 	struct nfs_page		*req;	/* multi ops per nfs_page */
 	struct page		**pagevec;
+	unsigned int		npages;	/* active pages in pagevec */
 	struct nfs_readargs args;
 	struct nfs_readres  res;
 #ifdef CONFIG_NFS_V4
@@ -747,6 +748,7 @@ struct nfs_write_data {
 	struct list_head	pages;		/* Coalesced requests we wish to flush */
 	struct nfs_page		*req;		/* multi ops per nfs_page */
 	struct page		**pagevec;
+	unsigned int		npages;		/* active pages in pagevec */
 	struct nfs_writeargs	args;		/* argument struct */
 	struct nfs_writeres	res;		/* result struct */
 #ifdef CONFIG_NFS_V4

commit ccf01ef7aa9c6c293a1c64c27331a2ce227916ec
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sun Jun 25 06:27:31 2006 -0400

    Merge branch 'odirect'

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 2d3fb6416d91..7c7320fa51aa 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -729,7 +729,6 @@ struct nfs_read_data {
 	struct list_head	pages;	/* Coalesced read requests */
 	struct nfs_page		*req;	/* multi ops per nfs_page */
 	struct page		**pagevec;
-	unsigned int		npages;	/* active pages in pagevec */
 	struct nfs_readargs args;
 	struct nfs_readres  res;
 #ifdef CONFIG_NFS_V4
@@ -748,7 +747,6 @@ struct nfs_write_data {
 	struct list_head	pages;		/* Coalesced requests we wish to flush */
 	struct nfs_page		*req;		/* multi ops per nfs_page */
 	struct page		**pagevec;
-	unsigned int		npages;		/* active pages in pagevec */
 	struct nfs_writeargs	args;		/* argument struct */
 	struct nfs_writeres	res;		/* result struct */
 #ifdef CONFIG_NFS_V4

commit 06cf6f2ed0b19629700794727d86ed57b9c0583e
Author: Chuck Lever <cel@netapp.com>
Date:   Tue Jun 20 12:56:49 2006 -0400

    NFS: Eliminate nfs_get_user_pages()
    
    Neil Brown observed that the kmalloc() in nfs_get_user_pages() is more
    likely to fail if the I/O is large enough to require the allocation of more
    than a single page to keep track of all the pinned pages in the user's
    buffer.
    
    Instead of tracking one large page array per dreq/iocb, track pages per
    nfs_read/write_data, just like the cached I/O path does.  An array for
    pages is already allocated for us by nfs_readdata_alloc() (and the write
    and commit equivalents).
    
    This is also required for adding support for vectored I/O to the NFS direct
    I/O path.
    
    The original reason to pin the user buffer and allocate all the NFS data
    structures before trying to schedule I/O was to ensure all needed resources
    are allocated on the client before starting to send requests.  This reduces
    the chance that resource exhaustion on the client will cause a short read
    or write.
    
    On the other hand, for an application making very large application I/O
    requests, this means that it will be nearly impossible for the application
    to make forward progress on a resource-limited client.
    
    Thus, moving the buffer pinning functionality into the I/O scheduling
    loops should be good for scalability.  The next patch will do the same for
    NFS data structure allocation.
    
    Signed-off-by: Chuck Lever <cel@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 7c7320fa51aa..2d3fb6416d91 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -729,6 +729,7 @@ struct nfs_read_data {
 	struct list_head	pages;	/* Coalesced read requests */
 	struct nfs_page		*req;	/* multi ops per nfs_page */
 	struct page		**pagevec;
+	unsigned int		npages;	/* active pages in pagevec */
 	struct nfs_readargs args;
 	struct nfs_readres  res;
 #ifdef CONFIG_NFS_V4
@@ -747,6 +748,7 @@ struct nfs_write_data {
 	struct list_head	pages;		/* Coalesced requests we wish to flush */
 	struct nfs_page		*req;		/* multi ops per nfs_page */
 	struct page		**pagevec;
+	unsigned int		npages;		/* active pages in pagevec */
 	struct nfs_writeargs	args;		/* argument struct */
 	struct nfs_writeres	res;		/* result struct */
 #ifdef CONFIG_NFS_V4

commit 6b97fd3da1eab2cc490cfe884c7d4956522eaf8b
Author: Manoj Naik <manoj@almaden.ibm.com>
Date:   Fri Jun 9 09:34:29 2006 -0400

    NFSv4: Follow a referral
    
    Respond to a moved error on NFS lookup by setting up the referral.
    Note: We don't actually follow the referral during lookup/getattr, but
    later when we detect fsid mismatch in inode revalidation (similar to the
    processing done for cloning submounts). Referrals will have fake attributes
    until they are actually followed or traversed.
    
    Signed-off-by: Manoj Naik <manoj@almaden.ibm.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index d6eea8348728..7c7320fa51aa 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -63,6 +63,7 @@ struct nfs_fattr {
 #define NFS_ATTR_FATTR		0x0002		/* post-op attributes */
 #define NFS_ATTR_FATTR_V3	0x0004		/* NFSv3 attributes */
 #define NFS_ATTR_FATTR_V4	0x0008		/* NFSv4 change attribute */
+#define NFS_ATTR_FATTR_V4_REFERRAL	0x0010		/* NFSv4 referral */
 
 /*
  * Info on the file system

commit 7aaa0b3bd4d215d9ce4d62b6c2043a63ba650f93
Author: Manoj Naik <manoj@almaden.ibm.com>
Date:   Fri Jun 9 09:34:23 2006 -0400

    NFSv4: convert fs-locations-components to conform to RFC3530
    
    Use component4-style formats for decoding list of servers and pathnames in
    fs_locations.
    
    Signed-off-by: Manoj Naik <manoj@almaden.ibm.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 15a20b815302..d6eea8348728 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -679,21 +679,31 @@ struct nfs4_server_caps_res {
 	u32				has_symlinks;
 };
 
-struct nfs_fs_location {
-	unsigned int serverlen;
-	char * server;
-	unsigned int rootpathlen;
-	char * rootpath;
+struct nfs4_string {
+	unsigned int len;
+	char *data;
 };
 
-#define NFS_FS_LOCATIONS_MAXENTRIES 10
-struct nfs_fs_locations {
+#define NFS4_PATHNAME_MAXCOMPONENTS 512
+struct nfs4_pathname {
+	unsigned int ncomponents;
+	struct nfs4_string components[NFS4_PATHNAME_MAXCOMPONENTS];
+};
+
+#define NFS4_FS_LOCATION_MAXSERVERS 10
+struct nfs4_fs_location {
+	unsigned int nservers;
+	struct nfs4_string servers[NFS4_FS_LOCATION_MAXSERVERS];
+	struct nfs4_pathname rootpath;
+};
+
+#define NFS4_FS_LOCATIONS_MAXENTRIES 10
+struct nfs4_fs_locations {
 	struct nfs_fattr fattr;
 	const struct nfs_server *server;
-	unsigned int fs_pathlen;
-	char * fs_path;
+	struct nfs4_pathname fs_path;
 	int nlocations;
-	struct nfs_fs_location locations[NFS_FS_LOCATIONS_MAXENTRIES];
+	struct nfs4_fs_location locations[NFS4_FS_LOCATIONS_MAXENTRIES];
 };
 
 struct nfs4_fs_locations_arg {

commit 683b57b435326eb512c7305892683b6205669448
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Jun 9 09:34:22 2006 -0400

    NFSv4: Implement the fs_locations function call
    
    NFSv4 allows for the fact that filesystems may be replicated across
    several servers or that they may be migrated to a backup server in case of
    failure of the primary server.
    fs_locations is an NFSv4 operation for retrieving information about the
    location of migrated and/or replicated filesystems.
    
    Based on an initial implementation by Jiaying Zhang <jiayingz@citi.umich.edu>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 95682f7d738a..15a20b815302 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -679,6 +679,30 @@ struct nfs4_server_caps_res {
 	u32				has_symlinks;
 };
 
+struct nfs_fs_location {
+	unsigned int serverlen;
+	char * server;
+	unsigned int rootpathlen;
+	char * rootpath;
+};
+
+#define NFS_FS_LOCATIONS_MAXENTRIES 10
+struct nfs_fs_locations {
+	struct nfs_fattr fattr;
+	const struct nfs_server *server;
+	unsigned int fs_pathlen;
+	char * fs_path;
+	int nlocations;
+	struct nfs_fs_location locations[NFS_FS_LOCATIONS_MAXENTRIES];
+};
+
+struct nfs4_fs_locations_arg {
+	const struct nfs_fh *dir_fh;
+	const struct qstr *name;
+	struct page *page;
+	const u32 *bitmask;
+};
+
 #endif /* CONFIG_NFS_V4 */
 
 struct nfs_page;

commit 8b4bdcf8995dd92b23d2ec22b32aee8fbbb50e1c
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Jun 9 09:34:19 2006 -0400

    NFS: Store the file system "fsid" value in the NFS super block.
    
    This should enable us to detect if we are crossing a mountpoint in the
    case where the server is exporting "nohide" mounts.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index e206c07080fe..95682f7d738a 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -14,11 +14,19 @@
 #define NFS_DEF_FILE_IO_SIZE	(4096U)
 #define NFS_MIN_FILE_IO_SIZE	(1024U)
 
-struct nfs4_fsid {
-	__u64 major;
-	__u64 minor;
+struct nfs_fsid {
+	uint64_t		major;
+	uint64_t		minor;
 };
 
+/*
+ * Helper for checking equality between 2 fsids.
+ */
+static inline int nfs_fsid_equal(const struct nfs_fsid *a, const struct nfs_fsid *b)
+{
+	return a->major == b->major && a->minor == b->minor;
+}
+
 struct nfs_fattr {
 	unsigned short		valid;		/* which fields are valid */
 	__u64			pre_size;	/* pre_op_attr.size	  */
@@ -40,10 +48,7 @@ struct nfs_fattr {
 		} nfs3;
 	} du;
 	dev_t			rdev;
-	union {
-		__u64		nfs3;		/* also nfs2 */
-		struct nfs4_fsid nfs4;
-	} fsid_u;
+	struct nfs_fsid		fsid;
 	__u64			fileid;
 	struct timespec		atime;
 	struct timespec		mtime;

commit 0d0b5cb36faf7002a11736032313f06d6f3d881c
Author: Chuck Lever <cel@netapp.com>
Date:   Thu May 25 01:40:53 2006 -0400

    NFS: Optimize allocation of nfs_read/write_data structures
    
    Clean up use of page_array, and fix an off-by-one error noticed by Tom
    Talpey which causes kmalloc calls in cases where using the page_array
    is sufficient.
    
    Test plan:
    Normal client functional testing with r/wsize=32768.
    
    Signed-off-by: Chuck Lever <cel@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index c483e239f993..e206c07080fe 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -694,7 +694,7 @@ struct nfs_read_data {
 #ifdef CONFIG_NFS_V4
 	unsigned long		timestamp;	/* For lease renewal */
 #endif
-	struct page		*page_array[NFS_PAGEVEC_SIZE + 1];
+	struct page		*page_array[NFS_PAGEVEC_SIZE];
 };
 
 struct nfs_write_data {
@@ -712,7 +712,7 @@ struct nfs_write_data {
 #ifdef CONFIG_NFS_V4
 	unsigned long		timestamp;	/* For lease renewal */
 #endif
-	struct page		*page_array[NFS_PAGEVEC_SIZE + 1];
+	struct page		*page_array[NFS_PAGEVEC_SIZE];
 };
 
 struct nfs_access_entry;

commit 73a3d07c1082145a3b78407bb5252df290470c4c
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu May 25 01:40:47 2006 -0400

    NFS: Clean up inode metadata updates
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 7fafc4c546b7..c483e239f993 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -57,8 +57,7 @@ struct nfs_fattr {
 #define NFS_ATTR_WCC		0x0001		/* pre-op WCC data    */
 #define NFS_ATTR_FATTR		0x0002		/* post-op attributes */
 #define NFS_ATTR_FATTR_V3	0x0004		/* NFSv3 attributes */
-#define NFS_ATTR_FATTR_V4	0x0008
-#define NFS_ATTR_PRE_CHANGE	0x0010
+#define NFS_ATTR_FATTR_V4	0x0008		/* NFSv4 change attribute */
 
 /*
  * Info on the file system

commit ec06c096edec0755534c7126f4caded69de131c2
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Mar 20 13:44:27 2006 -0500

    NFS: Cleanup of NFS read code
    
    Same callback hierarchy inversion as for the NFS write calls. This patch is
    not strictly speaking needed by the O_DIRECT code, but avoids confusing
    differences between the asynchronous read and write code.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 277750cc70c0..7fafc4c546b7 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -695,7 +695,6 @@ struct nfs_read_data {
 #ifdef CONFIG_NFS_V4
 	unsigned long		timestamp;	/* For lease renewal */
 #endif
-	void (*complete) (struct nfs_read_data *, int);
 	struct page		*page_array[NFS_PAGEVEC_SIZE + 1];
 };
 
@@ -768,6 +767,7 @@ struct nfs_rpc_ops {
 			     struct nfs_pathconf *);
 	u32 *	(*decode_dirent)(u32 *, struct nfs_entry *, int plus);
 	void	(*read_setup)   (struct nfs_read_data *);
+	int	(*read_done)  (struct rpc_task *, struct nfs_read_data *);
 	void	(*write_setup)  (struct nfs_write_data *, int how);
 	int	(*write_done)  (struct rpc_task *, struct nfs_write_data *);
 	void	(*commit_setup) (struct nfs_write_data *, int how);

commit 788e7a89a03e364855583c0ab4649b94925efbb9
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Mar 20 13:44:27 2006 -0500

    NFS: Cleanup of NFS write code in preparation for asynchronous o_direct
    
    This patch inverts the callback hierarchy for NFS write calls.
    
    Instead of having the NFSv2/v3/v4-specific code set up the RPC callback
    ops, we allow the original caller to do so. This allows for more
    flexibility w.r.t. how to set up and tear down the nfs_write_data
    structure while still allowing the NFSv3/v4 code to perform error
    handling.
    
    The greater flexibility is needed by the asynchronous O_DIRECT code, which
    wants to be able to hold on to the original nfs_write_data structures after
    the WRITE RPC call has completed in order to be able to replay them if the
    COMMIT call determines that the server has rebooted.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 6d6f69ec5675..277750cc70c0 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -714,7 +714,6 @@ struct nfs_write_data {
 #ifdef CONFIG_NFS_V4
 	unsigned long		timestamp;	/* For lease renewal */
 #endif
-	void (*complete) (struct nfs_write_data *, int);
 	struct page		*page_array[NFS_PAGEVEC_SIZE + 1];
 };
 
@@ -770,7 +769,9 @@ struct nfs_rpc_ops {
 	u32 *	(*decode_dirent)(u32 *, struct nfs_entry *, int plus);
 	void	(*read_setup)   (struct nfs_read_data *);
 	void	(*write_setup)  (struct nfs_write_data *, int how);
+	int	(*write_done)  (struct rpc_task *, struct nfs_write_data *);
 	void	(*commit_setup) (struct nfs_write_data *, int how);
+	int	(*commit_done) (struct rpc_task *, struct nfs_write_data *);
 	int	(*file_open)   (struct inode *, struct file *);
 	int	(*file_release) (struct inode *, struct file *);
 	int	(*lock)(struct file *, int, struct file_lock *);

commit fa178f29c0f8a0dce748181a5351f4a92fd4f455
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Jan 3 09:55:38 2006 +0100

    NFSv4: Ensure DELEGRETURN returns attributes
    
     Upon return of a write delegation, the server will almost always bump the
     change attribute. Ensure that we pick up that change so that we don't
     invalidate our data cache unnecessarily.
    
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 9f422fd87673..6d6f69ec5675 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -220,6 +220,12 @@ struct nfs_lockt_res {
 struct nfs4_delegreturnargs {
 	const struct nfs_fh *fhandle;
 	const nfs4_stateid *stateid;
+	const u32 * bitmask;
+};
+
+struct nfs4_delegreturnres {
+	struct nfs_fattr * fattr;
+	const struct nfs_server *server;
 };
 
 /*

commit 40859d7ee64ed6bfad8a4e93f9bb5c1074afadff
Author: Chuck Lever <cel@netapp.com>
Date:   Wed Nov 30 18:09:02 2005 -0500

    NFS: support large reads and writes on the wire
    
     Most NFS server implementations allow up to 64KB reads and writes on the
     wire.  The Solaris NFS server allows up to a megabyte, for instance.
    
     Now the Linux NFS client supports transfer sizes up to 1MB, too.  This will
     help reduce protocol and context switch overhead on read/write intensive NFS
     workloads, and support larger atomic read and write operations on servers
     that support them.
    
     Test-plan:
     Connectathon and iozone on mount point with wsize=rsize>32768 over TCP.
     Tests with NFS over UDP to verify the maximum RPC payload size cap.
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index b8b0eed98ec9..9f422fd87673 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -4,6 +4,16 @@
 #include <linux/sunrpc/xprt.h>
 #include <linux/nfsacl.h>
 
+/*
+ * To change the maximum rsize and wsize supported by the NFS client, adjust
+ * NFS_MAX_FILE_IO_SIZE.  64KB is a typical maximum, but some servers can
+ * support a megabyte or more.  The default is left at 4096 bytes, which is
+ * reasonable for NFS over UDP.
+ */
+#define NFS_MAX_FILE_IO_SIZE	(1048576U)
+#define NFS_DEF_FILE_IO_SIZE	(4096U)
+#define NFS_MIN_FILE_IO_SIZE	(1024U)
+
 struct nfs4_fsid {
 	__u64 major;
 	__u64 minor;
@@ -215,12 +225,6 @@ struct nfs4_delegreturnargs {
 /*
  * Arguments to the read call.
  */
-
-#define NFS_READ_MAXIOV		(9U)
-#if (NFS_READ_MAXIOV > (MAX_IOVEC -2))
-#error "NFS_READ_MAXIOV is too large"
-#endif
-
 struct nfs_readargs {
 	struct nfs_fh *		fh;
 	struct nfs_open_context *context;
@@ -239,11 +243,6 @@ struct nfs_readres {
 /*
  * Arguments to the write call.
  */
-#define NFS_WRITE_MAXIOV	(9U)
-#if (NFS_WRITE_MAXIOV > (MAX_IOVEC -2))
-#error "NFS_WRITE_MAXIOV is too large"
-#endif
-
 struct nfs_writeargs {
 	struct nfs_fh *		fh;
 	struct nfs_open_context *context;
@@ -674,6 +673,8 @@ struct nfs4_server_caps_res {
 
 struct nfs_page;
 
+#define NFS_PAGEVEC_SIZE	(8U)
+
 struct nfs_read_data {
 	int			flags;
 	struct rpc_task		task;
@@ -682,13 +683,14 @@ struct nfs_read_data {
 	struct nfs_fattr	fattr;	/* fattr storage */
 	struct list_head	pages;	/* Coalesced read requests */
 	struct nfs_page		*req;	/* multi ops per nfs_page */
-	struct page		*pagevec[NFS_READ_MAXIOV];
+	struct page		**pagevec;
 	struct nfs_readargs args;
 	struct nfs_readres  res;
 #ifdef CONFIG_NFS_V4
 	unsigned long		timestamp;	/* For lease renewal */
 #endif
 	void (*complete) (struct nfs_read_data *, int);
+	struct page		*page_array[NFS_PAGEVEC_SIZE + 1];
 };
 
 struct nfs_write_data {
@@ -700,13 +702,14 @@ struct nfs_write_data {
 	struct nfs_writeverf	verf;
 	struct list_head	pages;		/* Coalesced requests we wish to flush */
 	struct nfs_page		*req;		/* multi ops per nfs_page */
-	struct page		*pagevec[NFS_WRITE_MAXIOV];
+	struct page		**pagevec;
 	struct nfs_writeargs	args;		/* argument struct */
 	struct nfs_writeres	res;		/* result struct */
 #ifdef CONFIG_NFS_V4
 	unsigned long		timestamp;	/* For lease renewal */
 #endif
 	void (*complete) (struct nfs_write_data *, int);
+	struct page		*page_array[NFS_PAGEVEC_SIZE + 1];
 };
 
 struct nfs_access_entry;

commit 911d1aaf26fc4d771174d98fcab710a44e2a5fa0
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Jan 3 09:55:16 2006 +0100

    NFSv4: locking XDR cleanup
    
     Get rid of some unnecessary intermediate structures
    
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 518cfa5cd024..b8b0eed98ec9 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -165,50 +165,46 @@ struct nfs_closeres {
  *  * Arguments to the lock,lockt, and locku call.
  *   */
 struct nfs_lowner {
-	__u64           clientid;
-	u32                     id;
+	__u64			clientid;
+	u32			id;
 };
 
-struct nfs_lock_opargs {
+struct nfs_lock_args {
+	struct nfs_fh *		fh;
+	struct file_lock *	fl;
 	struct nfs_seqid *	lock_seqid;
 	nfs4_stateid *		lock_stateid;
 	struct nfs_seqid *	open_seqid;
 	nfs4_stateid *		open_stateid;
-	struct nfs_lowner       lock_owner;
-	__u32                   reclaim;
-	__u32                   new_lock_owner;
+	struct nfs_lowner	lock_owner;
+	unsigned char		block : 1;
+	unsigned char		reclaim : 1;
+	unsigned char		new_lock_owner : 1;
+};
+
+struct nfs_lock_res {
+	nfs4_stateid			stateid;
 };
 
-struct nfs_locku_opargs {
+struct nfs_locku_args {
+	struct nfs_fh *		fh;
+	struct file_lock *	fl;
 	struct nfs_seqid *	seqid;
 	nfs4_stateid *		stateid;
 };
 
-struct nfs_lockargs {
-	struct nfs_fh *         fh;
-	__u32                   type;
-	__u64                   offset; 
-	__u64                   length; 
-	union {
-		struct nfs_lock_opargs  *lock;    /* LOCK  */
-		struct nfs_lowner       *lockt;  /* LOCKT */
-		struct nfs_locku_opargs *locku;  /* LOCKU */
-	} u;
+struct nfs_locku_res {
+	nfs4_stateid			stateid;
 };
 
-struct nfs_lock_denied {
-	__u64                   offset;
-	__u64                   length;
-	__u32                   type;
-	struct nfs_lowner   	owner;
+struct nfs_lockt_args {
+	struct nfs_fh *		fh;
+	struct file_lock *	fl;
+	struct nfs_lowner	lock_owner;
 };
 
-struct nfs_lockres {
-	union {
-		nfs4_stateid            stateid;/* LOCK success, LOCKU */
-		struct nfs_lock_denied  denied; /* LOCK failed, LOCKT success */
-	} u;
-	const struct nfs_server *	server;
+struct nfs_lockt_res {
+	struct file_lock *	denied; /* LOCK, LOCKT failed */
 };
 
 struct nfs4_delegreturnargs {

commit cdd4e68b5f0ed12c64b3e2be83655d2a47588a74
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Jan 3 09:55:12 2006 +0100

    NFSv4: Make open_confirm() asynchronous too
    
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 40718669b9c8..518cfa5cd024 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -137,7 +137,7 @@ struct nfs_openres {
  */
 struct nfs_open_confirmargs {
 	const struct nfs_fh *	fh;
-	nfs4_stateid            stateid;
+	nfs4_stateid *		stateid;
 	struct nfs_seqid *	seqid;
 };
 

commit 4f9838c7ecd14f31f701f64fa65ded132fc0db8a
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Oct 27 22:12:44 2005 -0400

    NFSv4: Add post-op attributes to NFSv4 write and commit callbacks.
    
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index deeba7e2c518..40718669b9c8 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -256,6 +256,7 @@ struct nfs_writeargs {
 	enum nfs3_stable_how	stable;
 	unsigned int		pgbase;
 	struct page **		pages;
+	const u32 *		bitmask;
 };
 
 struct nfs_writeverf {
@@ -267,6 +268,7 @@ struct nfs_writeres {
 	struct nfs_fattr *	fattr;
 	struct nfs_writeverf *	verf;
 	__u32			count;
+	const struct nfs_server *server;
 };
 
 /*

commit 16e429596dec4d28e16812b3a9be27f18412c567
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Oct 27 22:12:44 2005 -0400

    NFSv4: Add post-op attributes to nfs4_proc_remove()
    
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 6f0804280824..deeba7e2c518 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -623,6 +623,13 @@ struct nfs4_readlink {
 struct nfs4_remove_arg {
 	const struct nfs_fh *		fh;
 	const struct qstr *		name;
+	const u32 *			bitmask;
+};
+
+struct nfs4_remove_res {
+	const struct nfs_server *	server;
+	struct nfs4_change_info		cinfo;
+	struct nfs_fattr *		dir_attr;
 };
 
 struct nfs4_rename_arg {

commit 6caf2c8276d371679a798058e8fdf49f5ff831a3
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Oct 27 22:12:43 2005 -0400

    NFSv4: Add post-op attributes to nfs4_proc_rename()
    
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 89238b799cfd..6f0804280824 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -630,11 +630,15 @@ struct nfs4_rename_arg {
 	const struct nfs_fh *		new_dir;
 	const struct qstr *		old_name;
 	const struct qstr *		new_name;
+	const u32 *			bitmask;
 };
 
 struct nfs4_rename_res {
+	const struct nfs_server *	server;
 	struct nfs4_change_info		old_cinfo;
+	struct nfs_fattr *		old_fattr;
 	struct nfs4_change_info		new_cinfo;
+	struct nfs_fattr *		new_fattr;
 };
 
 struct nfs4_setclientid {

commit 91ba2eeec5e8e86e054937eb3bf5aec5b22b1830
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Oct 27 22:12:42 2005 -0400

    NFSv4: Add post-op attributes to nfs4_proc_link()
    
     Optimise attribute revalidation when hardlinking. Add post-op attributes
     for the directory and the original inode.
    
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 4f03dc21cf4a..89238b799cfd 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -566,8 +566,17 @@ struct nfs4_link_arg {
 	const struct nfs_fh *		fh;
 	const struct nfs_fh *		dir_fh;
 	const struct qstr *		name;
+	const u32 *			bitmask;
+};
+
+struct nfs4_link_res {
+	const struct nfs_server *	server;
+	struct nfs_fattr *		fattr;
+	struct nfs4_change_info		cinfo;
+	struct nfs_fattr *		dir_attr;
 };
 
+
 struct nfs4_lookup_arg {
 	const struct nfs_fh *		dir_fh;
 	const struct qstr *		name;

commit 516a6af641bb50c608329a5bd751acd0d65cc4ab
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Oct 27 22:12:41 2005 -0400

    NFS: Add optional post-op getattr instruction to the NFSv4 file close.
    
     "Optional" means that the close call will not fail if the getattr
     at the end of the compound fails.
     If it does succeed, try to refresh inode attributes.
    
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 6485b8b41b83..4f03dc21cf4a 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -153,10 +153,13 @@ struct nfs_closeargs {
 	nfs4_stateid *		stateid;
 	struct nfs_seqid *	seqid;
 	int			open_flags;
+	const u32 *		bitmask;
 };
 
 struct nfs_closeres {
 	nfs4_stateid            stateid;
+	struct nfs_fattr *	fattr;
+	const struct nfs_server *server;
 };
 /*
  *  * Arguments to the lock,lockt, and locku call.

commit 56ae19f38f10aad4f27f7e12138a29b295dff07a
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Oct 27 22:12:40 2005 -0400

    NFSv4: Add directory post-op attributes to the CREATE operations.
    
     Since the directory attributes change every time we CREATE a file,
     we might as well pick up the new directory attributes in the same
     compound.
    
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index aeaee7e7c51d..6485b8b41b83 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -124,6 +124,7 @@ struct nfs_openres {
 	struct nfs4_change_info	cinfo;
 	__u32                   rflags;
 	struct nfs_fattr *      f_attr;
+	struct nfs_fattr *      dir_attr;
 	const struct nfs_server *server;
 	int			delegation_type;
 	nfs4_stateid		delegation;
@@ -540,6 +541,7 @@ struct nfs4_create_res {
 	struct nfs_fh *			fh;
 	struct nfs_fattr *		fattr;
 	struct nfs4_change_info		dir_cinfo;
+	struct nfs_fattr *		dir_fattr;
 };
 
 struct nfs4_fsinfo_arg {

commit 33801147a8fda6b04d7e9afe1d42f1c01d3d6837
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Oct 27 22:12:39 2005 -0400

    NFS: Optimise inode attribute cache updates
    
     Allow nfs_refresh_inode() also to update attributes on the inode if the
     RPC call was sent after the last call to nfs_update_inode().
    
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 60086dac11d5..aeaee7e7c51d 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -41,7 +41,7 @@ struct nfs_fattr {
 	__u32			bitmap[2];	/* NFSv4 returned attribute bitmap */
 	__u64			change_attr;	/* NFSv4 change attribute */
 	__u64			pre_change_attr;/* pre-op NFSv4 change attribute */
-	unsigned long		timestamp;
+	unsigned long		time_start;
 };
 
 #define NFS_ATTR_WCC		0x0001		/* pre-op WCC data    */

commit 02a913a73b52071e93f4b76db3e86138d19efffd
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Oct 18 14:20:17 2005 -0700

    NFSv4: Eliminate nfsv4 open race...
    
     Make NFSv4 return the fully initialized file pointer with the
     stateid that it created in the lookup w/intent.
    
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 57efcc27f20b..60086dac11d5 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -712,7 +712,7 @@ struct nfs_rpc_ops {
 	int	(*write)   (struct nfs_write_data *);
 	int	(*commit)  (struct nfs_write_data *);
 	int	(*create)  (struct inode *, struct dentry *,
-			    struct iattr *, int);
+			    struct iattr *, int, struct nameidata *);
 	int	(*remove)  (struct inode *, struct qstr *);
 	int	(*unlink_setup)  (struct rpc_message *,
 			    struct dentry *, struct qstr *);

commit 06735b3454824bd561decbde46111f144e905923
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Oct 18 14:20:15 2005 -0700

    NFSv4: Fix up handling of open_to_lock sequence ids
    
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 849f95c5fae4..57efcc27f20b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -165,25 +165,14 @@ struct nfs_lowner {
 	u32                     id;
 };
 
-struct nfs_open_to_lock {
-	struct nfs_seqid *	open_seqid;
-	nfs4_stateid            open_stateid;
+struct nfs_lock_opargs {
 	struct nfs_seqid *	lock_seqid;
+	nfs4_stateid *		lock_stateid;
+	struct nfs_seqid *	open_seqid;
+	nfs4_stateid *		open_stateid;
 	struct nfs_lowner       lock_owner;
-};
-
-struct nfs_exist_lock {
-	nfs4_stateid            stateid;
-	struct nfs_seqid *	seqid;
-};
-
-struct nfs_lock_opargs {
 	__u32                   reclaim;
 	__u32                   new_lock_owner;
-	union {
-		struct nfs_open_to_lock *open_lock;
-		struct nfs_exist_lock   *exist_lock;
-	} u;
 };
 
 struct nfs_locku_opargs {

commit faf5f49c2d9c0af2847837c232a432cc146e203b
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Oct 18 14:20:15 2005 -0700

    NFSv4: Make NFS clean up byte range locks asynchronously
    
     Currently we fail to do so if the process was signalled.
    
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index cac0df950c66..849f95c5fae4 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -188,7 +188,7 @@ struct nfs_lock_opargs {
 
 struct nfs_locku_opargs {
 	struct nfs_seqid *	seqid;
-	nfs4_stateid            stateid;
+	nfs4_stateid *		stateid;
 };
 
 struct nfs_lockargs {

commit 9512135df14f8293b9bc5e8fb22d4279dee5ff66
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Oct 18 14:20:12 2005 -0700

    NFSv4: Fix a potential CLOSE race
    
     Once the state_owner and lock_owner semaphores get removed, it will be
     possible for other OPEN requests to reopen the same file if they have
     lower sequence ids than our CLOSE call.
     This patch ensures that we recheck the file state once
     nfs_wait_on_sequence() has completed waiting.
    
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index d578912bf9a9..cac0df950c66 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -149,7 +149,7 @@ struct nfs_open_confirmres {
  */
 struct nfs_closeargs {
 	struct nfs_fh *         fh;
-	nfs4_stateid            stateid;
+	nfs4_stateid *		stateid;
 	struct nfs_seqid *	seqid;
 	int			open_flags;
 };

commit cee54fc944422c44e476736c045a9e8053cb0644
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Oct 18 14:20:12 2005 -0700

    NFSv4: Add functions to order RPC calls
    
     NFSv4 file state-changing functions such as OPEN, CLOSE, LOCK,... are all
     labelled with "sequence identifiers" in order to prevent the server from
     reordering RPC requests, as this could cause its file state to
     become out of sync with the client.
    
     Currently the NFS client code enforces this ordering locally using
     semaphores to restrict access to structures until the RPC call is done.
     This, of course, only works with synchronous RPC calls, since the
     user process must first grab the semaphore.
     By dropping semaphores, and instead teaching the RPC engine to hold
     the RPC calls until they are ready to be sent, we can extend this
     process to work nicely with asynchronous RPC calls too.
    
     This patch adds a new list called "rpc_sequence" that defines the order
     of the RPC calls to be sent. We add one such list for each state_owner.
     When an RPC call is ready to be sent, it checks if it is top of the
     rpc_sequence list. If so, it proceeds. If not, it goes back to sleep,
     and loops until it hits top of the list.
     Once the RPC call has completed, it can then bump the sequence id counter,
     and remove itself from the rpc_sequence list, and then wake up the next
     sleeper.
    
     Note that the state_owner sequence ids and lock_owner sequence ids are
     all indexed to the same rpc_sequence list, so OPEN, LOCK,... requests
     are all ordered w.r.t. each other.
    
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index a2bf6914ff1b..d578912bf9a9 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -96,12 +96,13 @@ struct nfs4_change_info {
 	u64			after;
 };
 
+struct nfs_seqid;
 /*
  * Arguments to the open call.
  */
 struct nfs_openargs {
 	const struct nfs_fh *	fh;
-	__u32                   seqid;
+	struct nfs_seqid *	seqid;
 	int			open_flags;
 	__u64                   clientid;
 	__u32                   id;
@@ -136,7 +137,7 @@ struct nfs_openres {
 struct nfs_open_confirmargs {
 	const struct nfs_fh *	fh;
 	nfs4_stateid            stateid;
-	__u32                   seqid;
+	struct nfs_seqid *	seqid;
 };
 
 struct nfs_open_confirmres {
@@ -149,7 +150,7 @@ struct nfs_open_confirmres {
 struct nfs_closeargs {
 	struct nfs_fh *         fh;
 	nfs4_stateid            stateid;
-	__u32                   seqid;
+	struct nfs_seqid *	seqid;
 	int			open_flags;
 };
 
@@ -165,15 +166,15 @@ struct nfs_lowner {
 };
 
 struct nfs_open_to_lock {
-	__u32                   open_seqid;
+	struct nfs_seqid *	open_seqid;
 	nfs4_stateid            open_stateid;
-	__u32                   lock_seqid;
+	struct nfs_seqid *	lock_seqid;
 	struct nfs_lowner       lock_owner;
 };
 
 struct nfs_exist_lock {
 	nfs4_stateid            stateid;
-	__u32                   seqid;
+	struct nfs_seqid *	seqid;
 };
 
 struct nfs_lock_opargs {
@@ -186,7 +187,7 @@ struct nfs_lock_opargs {
 };
 
 struct nfs_locku_opargs {
-	__u32                   seqid;
+	struct nfs_seqid *	seqid;
 	nfs4_stateid            stateid;
 };
 

commit b7fa0554cf1ba6d6895cd0a5b02989a26e0bc704
Author: Andreas Gruenbacher <agruen@suse.de>
Date:   Wed Jun 22 17:16:27 2005 +0000

    [PATCH] NFS: Add support for NFSv3 ACLs
    
     This adds acl support fo nfs clients via the NFSACL protocol extension, by
     implementing the getxattr, listxattr, setxattr, and removexattr iops for the
     system.posix_acl_access and system.posix_acl_default attributes.  This patch
     implements a dumb version that uses no caching (and thus adds some overhead).
     (Another patch in this patchset adds caching as well.)
    
     Signed-off-by: Andreas Gruenbacher <agruen@suse.de>
     Acked-by: Olaf Kirch <okir@suse.de>
     Signed-off-by: Andrew Morton <akpm@osdl.org>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 46b206b460c0..a2bf6914ff1b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -2,6 +2,7 @@
 #define _LINUX_NFS_XDR_H
 
 #include <linux/sunrpc/xprt.h>
+#include <linux/nfsacl.h>
 
 struct nfs4_fsid {
 	__u64 major;
@@ -368,6 +369,20 @@ struct nfs_readdirargs {
 	struct page **		pages;
 };
 
+struct nfs3_getaclargs {
+	struct nfs_fh *		fh;
+	int			mask;
+	struct page **		pages;
+};
+
+struct nfs3_setaclargs {
+	struct inode *		inode;
+	int			mask;
+	struct posix_acl *	acl_access;
+	struct posix_acl *	acl_default;
+	struct page **		pages;
+};
+
 struct nfs_diropok {
 	struct nfs_fh *		fh;
 	struct nfs_fattr *	fattr;
@@ -491,6 +506,15 @@ struct nfs3_readdirres {
 	int			plus;
 };
 
+struct nfs3_getaclres {
+	struct nfs_fattr *	fattr;
+	int			mask;
+	unsigned int		acl_access_count;
+	unsigned int		acl_default_count;
+	struct posix_acl *	acl_access;
+	struct posix_acl *	acl_default;
+};
+
 #ifdef CONFIG_NFS_V4
 
 typedef u64 clientid4;
@@ -748,4 +772,7 @@ extern struct rpc_version	nfs_version2;
 extern struct rpc_version	nfs_version3;
 extern struct rpc_version	nfs_version4;
 
+extern struct rpc_version	nfsacl_version3;
+extern struct rpc_program	nfsacl_program;
+
 #endif

commit 23ec6965c20db96bc8ea7af0ec178f074dd31c40
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Wed Jun 22 17:16:22 2005 +0000

    [PATCH] NFSv4: Client-side xdr for writing NFSv4 acls
    
     Client-side support for NFSv4 acls: xdr encoding and decoding routines for
     writing acls
    
     Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 9f5e1d407c7b..46b206b460c0 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -326,6 +326,13 @@ struct nfs_setattrargs {
 	const u32 *			bitmask;
 };
 
+struct nfs_setaclargs {
+	struct nfs_fh *			fh;
+	size_t				acl_len;
+	unsigned int			acl_pgbase;
+	struct page **			acl_pages;
+};
+
 struct nfs_getaclargs {
 	struct nfs_fh *			fh;
 	size_t				acl_len;

commit 029d105e66e5a90850d5a09dad76815d0bcfcaa3
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Wed Jun 22 17:16:22 2005 +0000

    [PATCH] NFSv4: Client-side xdr for reading NFSv4 acls
    
     Client-side support for NFSv4 acls: xdr encoding and decoding routines for
     reading acls
    
     Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index cf38db59f347..9f5e1d407c7b 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -326,6 +326,13 @@ struct nfs_setattrargs {
 	const u32 *			bitmask;
 };
 
+struct nfs_getaclargs {
+	struct nfs_fh *			fh;
+	size_t				acl_len;
+	unsigned int			acl_pgbase;
+	struct page **			acl_pages;
+};
+
 struct nfs_setattrres {
 	struct nfs_fattr *              fattr;
 	const struct nfs_server *	server;

commit ada70d9425bcc5e376fef8591e4e76e204c0834c
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Jun 22 17:16:22 2005 +0000

    [PATCH] NFS: Add hooks to allow common NFS attribute code to clear cached acls
    
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 5b45bafd9db5..cf38db59f347 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -714,6 +714,7 @@ struct nfs_rpc_ops {
 	int	(*file_open)   (struct inode *, struct file *);
 	int	(*file_release) (struct inode *, struct file *);
 	int	(*lock)(struct file *, int, struct file_lock *);
+	void	(*clear_acl_cache)(struct inode *);
 };
 
 /*

commit 92cfc62cb8412c9563860b1bf70cd4701f03092e
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Wed Jun 22 17:16:22 2005 +0000

    [PATCH] NFS: Allow NFS versions to support different sets of inode operations.
    
     ACL support will require supporting additional inode operations in v4
     (getxattr, setxattr, listxattr).  This patch allows different protocol versions
     to support different inode operations by adding a file_inode_ops to the
     nfs_rpc_ops (to match the existing dir_inode_ops).
    
     Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 47037d9521cb..5b45bafd9db5 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -667,6 +667,7 @@ struct nfs_rpc_ops {
 	int	version;		/* Protocol version */
 	struct dentry_operations *dentry_ops;
 	struct inode_operations *dir_inode_ops;
+	struct inode_operations *file_inode_ops;
 
 	int	(*getroot) (struct nfs_server *, struct nfs_fh *,
 			    struct nfs_fsinfo *);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
new file mode 100644
index 000000000000..47037d9521cb
--- /dev/null
+++ b/include/linux/nfs_xdr.h
@@ -0,0 +1,735 @@
+#ifndef _LINUX_NFS_XDR_H
+#define _LINUX_NFS_XDR_H
+
+#include <linux/sunrpc/xprt.h>
+
+struct nfs4_fsid {
+	__u64 major;
+	__u64 minor;
+};
+
+struct nfs_fattr {
+	unsigned short		valid;		/* which fields are valid */
+	__u64			pre_size;	/* pre_op_attr.size	  */
+	struct timespec		pre_mtime;	/* pre_op_attr.mtime	  */
+	struct timespec		pre_ctime;	/* pre_op_attr.ctime	  */
+	enum nfs_ftype		type;		/* always use NFSv2 types */
+	__u32			mode;
+	__u32			nlink;
+	__u32			uid;
+	__u32			gid;
+	__u64			size;
+	union {
+		struct {
+			__u32	blocksize;
+			__u32	blocks;
+		} nfs2;
+		struct {
+			__u64	used;
+		} nfs3;
+	} du;
+	dev_t			rdev;
+	union {
+		__u64		nfs3;		/* also nfs2 */
+		struct nfs4_fsid nfs4;
+	} fsid_u;
+	__u64			fileid;
+	struct timespec		atime;
+	struct timespec		mtime;
+	struct timespec		ctime;
+	__u32			bitmap[2];	/* NFSv4 returned attribute bitmap */
+	__u64			change_attr;	/* NFSv4 change attribute */
+	__u64			pre_change_attr;/* pre-op NFSv4 change attribute */
+	unsigned long		timestamp;
+};
+
+#define NFS_ATTR_WCC		0x0001		/* pre-op WCC data    */
+#define NFS_ATTR_FATTR		0x0002		/* post-op attributes */
+#define NFS_ATTR_FATTR_V3	0x0004		/* NFSv3 attributes */
+#define NFS_ATTR_FATTR_V4	0x0008
+#define NFS_ATTR_PRE_CHANGE	0x0010
+
+/*
+ * Info on the file system
+ */
+struct nfs_fsinfo {
+	struct nfs_fattr	*fattr; /* Post-op attributes */
+	__u32			rtmax;	/* max.  read transfer size */
+	__u32			rtpref;	/* pref. read transfer size */
+	__u32			rtmult;	/* reads should be multiple of this */
+	__u32			wtmax;	/* max.  write transfer size */
+	__u32			wtpref;	/* pref. write transfer size */
+	__u32			wtmult;	/* writes should be multiple of this */
+	__u32			dtpref;	/* pref. readdir transfer size */
+	__u64			maxfilesize;
+	__u32			lease_time; /* in seconds */
+};
+
+struct nfs_fsstat {
+	struct nfs_fattr	*fattr; /* Post-op attributes */
+	__u64			tbytes;	/* total size in bytes */
+	__u64			fbytes;	/* # of free bytes */
+	__u64			abytes;	/* # of bytes available to user */
+	__u64			tfiles;	/* # of files */
+	__u64			ffiles;	/* # of free files */
+	__u64			afiles;	/* # of files available to user */
+};
+
+struct nfs2_fsstat {
+	__u32			tsize;  /* Server transfer size */
+	__u32			bsize;  /* Filesystem block size */
+	__u32			blocks; /* No. of "bsize" blocks on filesystem */
+	__u32			bfree;  /* No. of free "bsize" blocks */
+	__u32			bavail; /* No. of available "bsize" blocks */
+};
+
+struct nfs_pathconf {
+	struct nfs_fattr	*fattr; /* Post-op attributes */
+	__u32			max_link; /* max # of hard links */
+	__u32			max_namelen; /* max name length */
+};
+
+struct nfs4_change_info {
+	u32			atomic;
+	u64			before;
+	u64			after;
+};
+
+/*
+ * Arguments to the open call.
+ */
+struct nfs_openargs {
+	const struct nfs_fh *	fh;
+	__u32                   seqid;
+	int			open_flags;
+	__u64                   clientid;
+	__u32                   id;
+	union {
+		struct iattr *  attrs;    /* UNCHECKED, GUARDED */
+		nfs4_verifier   verifier; /* EXCLUSIVE */
+		nfs4_stateid	delegation;		/* CLAIM_DELEGATE_CUR */
+		int		delegation_type;	/* CLAIM_PREVIOUS */
+	} u;
+	const struct qstr *	name;
+	const struct nfs_server *server;	 /* Needed for ID mapping */
+	const u32 *		bitmask;
+	__u32			claim;
+};
+
+struct nfs_openres {
+	nfs4_stateid            stateid;
+	struct nfs_fh           fh;
+	struct nfs4_change_info	cinfo;
+	__u32                   rflags;
+	struct nfs_fattr *      f_attr;
+	const struct nfs_server *server;
+	int			delegation_type;
+	nfs4_stateid		delegation;
+	__u32			do_recall;
+	__u64			maxsize;
+};
+
+/*
+ * Arguments to the open_confirm call.
+ */
+struct nfs_open_confirmargs {
+	const struct nfs_fh *	fh;
+	nfs4_stateid            stateid;
+	__u32                   seqid;
+};
+
+struct nfs_open_confirmres {
+	nfs4_stateid            stateid;
+};
+
+/*
+ * Arguments to the close call.
+ */
+struct nfs_closeargs {
+	struct nfs_fh *         fh;
+	nfs4_stateid            stateid;
+	__u32                   seqid;
+	int			open_flags;
+};
+
+struct nfs_closeres {
+	nfs4_stateid            stateid;
+};
+/*
+ *  * Arguments to the lock,lockt, and locku call.
+ *   */
+struct nfs_lowner {
+	__u64           clientid;
+	u32                     id;
+};
+
+struct nfs_open_to_lock {
+	__u32                   open_seqid;
+	nfs4_stateid            open_stateid;
+	__u32                   lock_seqid;
+	struct nfs_lowner       lock_owner;
+};
+
+struct nfs_exist_lock {
+	nfs4_stateid            stateid;
+	__u32                   seqid;
+};
+
+struct nfs_lock_opargs {
+	__u32                   reclaim;
+	__u32                   new_lock_owner;
+	union {
+		struct nfs_open_to_lock *open_lock;
+		struct nfs_exist_lock   *exist_lock;
+	} u;
+};
+
+struct nfs_locku_opargs {
+	__u32                   seqid;
+	nfs4_stateid            stateid;
+};
+
+struct nfs_lockargs {
+	struct nfs_fh *         fh;
+	__u32                   type;
+	__u64                   offset; 
+	__u64                   length; 
+	union {
+		struct nfs_lock_opargs  *lock;    /* LOCK  */
+		struct nfs_lowner       *lockt;  /* LOCKT */
+		struct nfs_locku_opargs *locku;  /* LOCKU */
+	} u;
+};
+
+struct nfs_lock_denied {
+	__u64                   offset;
+	__u64                   length;
+	__u32                   type;
+	struct nfs_lowner   	owner;
+};
+
+struct nfs_lockres {
+	union {
+		nfs4_stateid            stateid;/* LOCK success, LOCKU */
+		struct nfs_lock_denied  denied; /* LOCK failed, LOCKT success */
+	} u;
+	const struct nfs_server *	server;
+};
+
+struct nfs4_delegreturnargs {
+	const struct nfs_fh *fhandle;
+	const nfs4_stateid *stateid;
+};
+
+/*
+ * Arguments to the read call.
+ */
+
+#define NFS_READ_MAXIOV		(9U)
+#if (NFS_READ_MAXIOV > (MAX_IOVEC -2))
+#error "NFS_READ_MAXIOV is too large"
+#endif
+
+struct nfs_readargs {
+	struct nfs_fh *		fh;
+	struct nfs_open_context *context;
+	__u64			offset;
+	__u32			count;
+	unsigned int		pgbase;
+	struct page **		pages;
+};
+
+struct nfs_readres {
+	struct nfs_fattr *	fattr;
+	__u32			count;
+	int                     eof;
+};
+
+/*
+ * Arguments to the write call.
+ */
+#define NFS_WRITE_MAXIOV	(9U)
+#if (NFS_WRITE_MAXIOV > (MAX_IOVEC -2))
+#error "NFS_WRITE_MAXIOV is too large"
+#endif
+
+struct nfs_writeargs {
+	struct nfs_fh *		fh;
+	struct nfs_open_context *context;
+	__u64			offset;
+	__u32			count;
+	enum nfs3_stable_how	stable;
+	unsigned int		pgbase;
+	struct page **		pages;
+};
+
+struct nfs_writeverf {
+	enum nfs3_stable_how	committed;
+	__u32			verifier[2];
+};
+
+struct nfs_writeres {
+	struct nfs_fattr *	fattr;
+	struct nfs_writeverf *	verf;
+	__u32			count;
+};
+
+/*
+ * Argument struct for decode_entry function
+ */
+struct nfs_entry {
+	__u64			ino;
+	__u64			cookie,
+				prev_cookie;
+	const char *		name;
+	unsigned int		len;
+	int			eof;
+	struct nfs_fh *		fh;
+	struct nfs_fattr *	fattr;
+};
+
+/*
+ * The following types are for NFSv2 only.
+ */
+struct nfs_sattrargs {
+	struct nfs_fh *		fh;
+	struct iattr *		sattr;
+};
+
+struct nfs_diropargs {
+	struct nfs_fh *		fh;
+	const char *		name;
+	unsigned int		len;
+};
+
+struct nfs_createargs {
+	struct nfs_fh *		fh;
+	const char *		name;
+	unsigned int		len;
+	struct iattr *		sattr;
+};
+
+struct nfs_renameargs {
+	struct nfs_fh *		fromfh;
+	const char *		fromname;
+	unsigned int		fromlen;
+	struct nfs_fh *		tofh;
+	const char *		toname;
+	unsigned int		tolen;
+};
+
+struct nfs_setattrargs {
+	struct nfs_fh *                 fh;
+	nfs4_stateid                    stateid;
+	struct iattr *                  iap;
+	const struct nfs_server *	server; /* Needed for name mapping */
+	const u32 *			bitmask;
+};
+
+struct nfs_setattrres {
+	struct nfs_fattr *              fattr;
+	const struct nfs_server *	server;
+};
+
+struct nfs_linkargs {
+	struct nfs_fh *		fromfh;
+	struct nfs_fh *		tofh;
+	const char *		toname;
+	unsigned int		tolen;
+};
+
+struct nfs_symlinkargs {
+	struct nfs_fh *		fromfh;
+	const char *		fromname;
+	unsigned int		fromlen;
+	const char *		topath;
+	unsigned int		tolen;
+	struct iattr *		sattr;
+};
+
+struct nfs_readdirargs {
+	struct nfs_fh *		fh;
+	__u32			cookie;
+	unsigned int		count;
+	struct page **		pages;
+};
+
+struct nfs_diropok {
+	struct nfs_fh *		fh;
+	struct nfs_fattr *	fattr;
+};
+
+struct nfs_readlinkargs {
+	struct nfs_fh *		fh;
+	unsigned int		pgbase;
+	unsigned int		pglen;
+	struct page **		pages;
+};
+
+struct nfs3_sattrargs {
+	struct nfs_fh *		fh;
+	struct iattr *		sattr;
+	unsigned int		guard;
+	struct timespec		guardtime;
+};
+
+struct nfs3_diropargs {
+	struct nfs_fh *		fh;
+	const char *		name;
+	unsigned int		len;
+};
+
+struct nfs3_accessargs {
+	struct nfs_fh *		fh;
+	__u32			access;
+};
+
+struct nfs3_createargs {
+	struct nfs_fh *		fh;
+	const char *		name;
+	unsigned int		len;
+	struct iattr *		sattr;
+	enum nfs3_createmode	createmode;
+	__u32			verifier[2];
+};
+
+struct nfs3_mkdirargs {
+	struct nfs_fh *		fh;
+	const char *		name;
+	unsigned int		len;
+	struct iattr *		sattr;
+};
+
+struct nfs3_symlinkargs {
+	struct nfs_fh *		fromfh;
+	const char *		fromname;
+	unsigned int		fromlen;
+	const char *		topath;
+	unsigned int		tolen;
+	struct iattr *		sattr;
+};
+
+struct nfs3_mknodargs {
+	struct nfs_fh *		fh;
+	const char *		name;
+	unsigned int		len;
+	enum nfs3_ftype		type;
+	struct iattr *		sattr;
+	dev_t			rdev;
+};
+
+struct nfs3_renameargs {
+	struct nfs_fh *		fromfh;
+	const char *		fromname;
+	unsigned int		fromlen;
+	struct nfs_fh *		tofh;
+	const char *		toname;
+	unsigned int		tolen;
+};
+
+struct nfs3_linkargs {
+	struct nfs_fh *		fromfh;
+	struct nfs_fh *		tofh;
+	const char *		toname;
+	unsigned int		tolen;
+};
+
+struct nfs3_readdirargs {
+	struct nfs_fh *		fh;
+	__u64			cookie;
+	__u32			verf[2];
+	int			plus;
+	unsigned int            count;
+	struct page **		pages;
+};
+
+struct nfs3_diropres {
+	struct nfs_fattr *	dir_attr;
+	struct nfs_fh *		fh;
+	struct nfs_fattr *	fattr;
+};
+
+struct nfs3_accessres {
+	struct nfs_fattr *	fattr;
+	__u32			access;
+};
+
+struct nfs3_readlinkargs {
+	struct nfs_fh *		fh;
+	unsigned int		pgbase;
+	unsigned int		pglen;
+	struct page **		pages;
+};
+
+struct nfs3_renameres {
+	struct nfs_fattr *	fromattr;
+	struct nfs_fattr *	toattr;
+};
+
+struct nfs3_linkres {
+	struct nfs_fattr *	dir_attr;
+	struct nfs_fattr *	fattr;
+};
+
+struct nfs3_readdirres {
+	struct nfs_fattr *	dir_attr;
+	__u32 *			verf;
+	int			plus;
+};
+
+#ifdef CONFIG_NFS_V4
+
+typedef u64 clientid4;
+
+struct nfs4_accessargs {
+	const struct nfs_fh *		fh;
+	u32				access;
+};
+
+struct nfs4_accessres {
+	u32				supported;
+	u32				access;
+};
+
+struct nfs4_create_arg {
+	u32				ftype;
+	union {
+		struct qstr *		symlink;    /* NF4LNK */
+		struct {
+			u32		specdata1;
+			u32		specdata2;
+		} device;    /* NF4BLK, NF4CHR */
+	} u;
+	const struct qstr *		name;
+	const struct nfs_server *	server;
+	const struct iattr *		attrs;
+	const struct nfs_fh *		dir_fh;
+	const u32 *			bitmask;
+};
+
+struct nfs4_create_res {
+	const struct nfs_server *	server;
+	struct nfs_fh *			fh;
+	struct nfs_fattr *		fattr;
+	struct nfs4_change_info		dir_cinfo;
+};
+
+struct nfs4_fsinfo_arg {
+	const struct nfs_fh *		fh;
+	const u32 *			bitmask;
+};
+
+struct nfs4_getattr_arg {
+	const struct nfs_fh *		fh;
+	const u32 *			bitmask;
+};
+
+struct nfs4_getattr_res {
+	const struct nfs_server *	server;
+	struct nfs_fattr *		fattr;
+};
+
+struct nfs4_link_arg {
+	const struct nfs_fh *		fh;
+	const struct nfs_fh *		dir_fh;
+	const struct qstr *		name;
+};
+
+struct nfs4_lookup_arg {
+	const struct nfs_fh *		dir_fh;
+	const struct qstr *		name;
+	const u32 *			bitmask;
+};
+
+struct nfs4_lookup_res {
+	const struct nfs_server *	server;
+	struct nfs_fattr *		fattr;
+	struct nfs_fh *			fh;
+};
+
+struct nfs4_lookup_root_arg {
+	const u32 *			bitmask;
+};
+
+struct nfs4_pathconf_arg {
+	const struct nfs_fh *		fh;
+	const u32 *			bitmask;
+};
+
+struct nfs4_readdir_arg {
+	const struct nfs_fh *		fh;
+	u64				cookie;
+	nfs4_verifier			verifier;
+	u32				count;
+	struct page **			pages;	/* zero-copy data */
+	unsigned int			pgbase;	/* zero-copy data */
+	const u32 *			bitmask;
+};
+
+struct nfs4_readdir_res {
+	nfs4_verifier			verifier;
+	unsigned int			pgbase;
+};
+
+struct nfs4_readlink {
+	const struct nfs_fh *		fh;
+	unsigned int			pgbase;
+	unsigned int			pglen;   /* zero-copy data */
+	struct page **			pages;   /* zero-copy data */
+};
+
+struct nfs4_remove_arg {
+	const struct nfs_fh *		fh;
+	const struct qstr *		name;
+};
+
+struct nfs4_rename_arg {
+	const struct nfs_fh *		old_dir;
+	const struct nfs_fh *		new_dir;
+	const struct qstr *		old_name;
+	const struct qstr *		new_name;
+};
+
+struct nfs4_rename_res {
+	struct nfs4_change_info		old_cinfo;
+	struct nfs4_change_info		new_cinfo;
+};
+
+struct nfs4_setclientid {
+	const nfs4_verifier *		sc_verifier;      /* request */
+	unsigned int			sc_name_len;
+	char				sc_name[32];	  /* request */
+	u32				sc_prog;          /* request */
+	unsigned int			sc_netid_len;
+	char				sc_netid[4];	  /* request */
+	unsigned int			sc_uaddr_len;
+	char				sc_uaddr[24];     /* request */
+	u32				sc_cb_ident;      /* request */
+};
+
+struct nfs4_statfs_arg {
+	const struct nfs_fh *		fh;
+	const u32 *			bitmask;
+};
+
+struct nfs4_server_caps_res {
+	u32				attr_bitmask[2];
+	u32				acl_bitmask;
+	u32				has_links;
+	u32				has_symlinks;
+};
+
+#endif /* CONFIG_NFS_V4 */
+
+struct nfs_page;
+
+struct nfs_read_data {
+	int			flags;
+	struct rpc_task		task;
+	struct inode		*inode;
+	struct rpc_cred		*cred;
+	struct nfs_fattr	fattr;	/* fattr storage */
+	struct list_head	pages;	/* Coalesced read requests */
+	struct nfs_page		*req;	/* multi ops per nfs_page */
+	struct page		*pagevec[NFS_READ_MAXIOV];
+	struct nfs_readargs args;
+	struct nfs_readres  res;
+#ifdef CONFIG_NFS_V4
+	unsigned long		timestamp;	/* For lease renewal */
+#endif
+	void (*complete) (struct nfs_read_data *, int);
+};
+
+struct nfs_write_data {
+	int			flags;
+	struct rpc_task		task;
+	struct inode		*inode;
+	struct rpc_cred		*cred;
+	struct nfs_fattr	fattr;
+	struct nfs_writeverf	verf;
+	struct list_head	pages;		/* Coalesced requests we wish to flush */
+	struct nfs_page		*req;		/* multi ops per nfs_page */
+	struct page		*pagevec[NFS_WRITE_MAXIOV];
+	struct nfs_writeargs	args;		/* argument struct */
+	struct nfs_writeres	res;		/* result struct */
+#ifdef CONFIG_NFS_V4
+	unsigned long		timestamp;	/* For lease renewal */
+#endif
+	void (*complete) (struct nfs_write_data *, int);
+};
+
+struct nfs_access_entry;
+
+/*
+ * RPC procedure vector for NFSv2/NFSv3 demuxing
+ */
+struct nfs_rpc_ops {
+	int	version;		/* Protocol version */
+	struct dentry_operations *dentry_ops;
+	struct inode_operations *dir_inode_ops;
+
+	int	(*getroot) (struct nfs_server *, struct nfs_fh *,
+			    struct nfs_fsinfo *);
+	int	(*getattr) (struct nfs_server *, struct nfs_fh *,
+			    struct nfs_fattr *);
+	int	(*setattr) (struct dentry *, struct nfs_fattr *,
+			    struct iattr *);
+	int	(*lookup)  (struct inode *, struct qstr *,
+			    struct nfs_fh *, struct nfs_fattr *);
+	int	(*access)  (struct inode *, struct nfs_access_entry *);
+	int	(*readlink)(struct inode *, struct page *, unsigned int,
+			    unsigned int);
+	int	(*read)    (struct nfs_read_data *);
+	int	(*write)   (struct nfs_write_data *);
+	int	(*commit)  (struct nfs_write_data *);
+	int	(*create)  (struct inode *, struct dentry *,
+			    struct iattr *, int);
+	int	(*remove)  (struct inode *, struct qstr *);
+	int	(*unlink_setup)  (struct rpc_message *,
+			    struct dentry *, struct qstr *);
+	int	(*unlink_done) (struct dentry *, struct rpc_task *);
+	int	(*rename)  (struct inode *, struct qstr *,
+			    struct inode *, struct qstr *);
+	int	(*link)    (struct inode *, struct inode *, struct qstr *);
+	int	(*symlink) (struct inode *, struct qstr *, struct qstr *,
+			    struct iattr *, struct nfs_fh *,
+			    struct nfs_fattr *);
+	int	(*mkdir)   (struct inode *, struct dentry *, struct iattr *);
+	int	(*rmdir)   (struct inode *, struct qstr *);
+	int	(*readdir) (struct dentry *, struct rpc_cred *,
+			    u64, struct page *, unsigned int, int);
+	int	(*mknod)   (struct inode *, struct dentry *, struct iattr *,
+			    dev_t);
+	int	(*statfs)  (struct nfs_server *, struct nfs_fh *,
+			    struct nfs_fsstat *);
+	int	(*fsinfo)  (struct nfs_server *, struct nfs_fh *,
+			    struct nfs_fsinfo *);
+	int	(*pathconf) (struct nfs_server *, struct nfs_fh *,
+			     struct nfs_pathconf *);
+	u32 *	(*decode_dirent)(u32 *, struct nfs_entry *, int plus);
+	void	(*read_setup)   (struct nfs_read_data *);
+	void	(*write_setup)  (struct nfs_write_data *, int how);
+	void	(*commit_setup) (struct nfs_write_data *, int how);
+	int	(*file_open)   (struct inode *, struct file *);
+	int	(*file_release) (struct inode *, struct file *);
+	int	(*lock)(struct file *, int, struct file_lock *);
+};
+
+/*
+ * 	NFS_CALL(getattr, inode, (fattr));
+ * into
+ *	NFS_PROTO(inode)->getattr(fattr);
+ */
+#define NFS_CALL(op, inode, args)	NFS_PROTO(inode)->op args
+
+/*
+ * Function vectors etc. for the NFS client
+ */
+extern struct nfs_rpc_ops	nfs_v2_clientops;
+extern struct nfs_rpc_ops	nfs_v3_clientops;
+extern struct nfs_rpc_ops	nfs_v4_clientops;
+extern struct rpc_version	nfs_version2;
+extern struct rpc_version	nfs_version3;
+extern struct rpc_version	nfs_version4;
+
+#endif
