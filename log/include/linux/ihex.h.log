commit 1d9e13e8ef05029c61d52ad9a6f48f14771d14b7
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Mon Mar 23 18:00:04 2020 -0500

    ihex.h: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>

diff --git a/include/linux/ihex.h b/include/linux/ihex.h
index 98cb5ce0b0a0..b824877e6d1b 100644
--- a/include/linux/ihex.h
+++ b/include/linux/ihex.h
@@ -18,7 +18,7 @@
 struct ihex_binrec {
 	__be32 addr;
 	__be16 len;
-	uint8_t data[0];
+	uint8_t data[];
 } __attribute__((packed));
 
 static inline uint16_t ihex_binrec_size(const struct ihex_binrec *p)

commit 9fb4ab4d3dd665a62da9c176a89e7c7feaf5d9e4
Author: Andrey Smirnov <andrew.smirnov@gmail.com>
Date:   Thu Dec 20 23:28:39 2018 -0800

    ihex: Simplify next record offset calculation
    
    Next record calucaltion can be reduced to a much more tivial ALIGN
    operation as follows:
    
    1. Splitting 5 into 2 + 3 we get
    
       next = ((be16_to_cpu(rec->len) + 2 + 3) & ~3) - 2            (1)
    
    2. Using ALIGN macro we reduce (1) to:
    
       ALIGN(be16_to_cpu(rec->len) + 2, 4) - 2                      (2)
    
    3. Subsituting 'next' in original next record calucation we get:
    
       (void *)&rec->data[ALIGN(be16_to_cpu(rec->len) + 2, 4) - 2]  (3)
    
    4. Converting array index to pointer arithmetic we convert (3) into:
    
       (void *)rec + sizeof(*rec) +
             ALIGN(be16_to_cpu(rec->len) + 2, 4) - 2                (4)
    
    5. Subsituting sizeof(*rec) with its value, 6, and substracting 2,
       in (4) we get:
    
       (void *)rec + ALIGN(be16_to_cpu(rec->len) + 2, 4) + 4        (5)
    
    6. Since ALIGN(X, 4) + 4 == ALIGN(X + 4, 4), (5) can be converted to:
    
       (void *)rec + ALIGN(be16_to_cpu(rec->len) + 6, 4)            (6)
    
    5. Subsituting 6 in (6) to sizeof(*rec) we get:
    
       (void *)rec + ALIGN(be16_to_cpu(rec->len) + sizeof(*rec), 4) (7)
    
    Using expression (7) should make it more clear that next record is
    located by adding full size of the current record (payload + auxiliary
    data) aligned to 4 bytes, to the location of the current one. No
    functional change intended.
    
    Cc: Chris Healy <cphealy@gmail.com>
    Cc: Kyle McMartin <kyle@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: linux-kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: Andrey Smirnov <andrew.smirnov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/ihex.h b/include/linux/ihex.h
index 9130f307a420..98cb5ce0b0a0 100644
--- a/include/linux/ihex.h
+++ b/include/linux/ihex.h
@@ -21,14 +21,18 @@ struct ihex_binrec {
 	uint8_t data[0];
 } __attribute__((packed));
 
+static inline uint16_t ihex_binrec_size(const struct ihex_binrec *p)
+{
+	return be16_to_cpu(p->len) + sizeof(*p);
+}
+
 /* Find the next record, taking into account the 4-byte alignment */
 static inline const struct ihex_binrec *
 __ihex_next_binrec(const struct ihex_binrec *rec)
 {
-	int next = ((be16_to_cpu(rec->len) + 5) & ~3) - 2;
-	rec = (void *)&rec->data[next];
+	const void *p = rec;
 
-	return rec;
+	return p + ALIGN(ihex_binrec_size(rec), 4);
 }
 
 static inline const struct ihex_binrec *

commit 5158c36ec9d0b3343f58987cec7ebfd866331fd0
Author: Andrey Smirnov <andrew.smirnov@gmail.com>
Date:   Thu Dec 20 23:28:38 2018 -0800

    ihex: Check if zero-length record is at the end of the blob
    
    When verifying the validity of IHEX file we need to make sure that
    zero-length record we found is located at the end of the file. Not
    doing that could result in an invalid file with a bogus zero-length in
    the middle short-circuiting the check and being reported as valid.
    
    Cc: Chris Healy <cphealy@gmail.com>
    Cc: Kyle McMartin <kyle@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: linux-kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: Andrey Smirnov <andrew.smirnov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/ihex.h b/include/linux/ihex.h
index 9c701521176b..9130f307a420 100644
--- a/include/linux/ihex.h
+++ b/include/linux/ihex.h
@@ -49,7 +49,7 @@ static inline int ihex_validate_fw(const struct firmware *fw)
 
 	for (; rec <= end; rec = __ihex_next_binrec(rec)) {
 		/* Zero length marks end of records */
-		if (!be16_to_cpu(rec->len))
+		if (rec == end && !be16_to_cpu(rec->len))
 			return 0;
 	}
 	return -EINVAL;

commit 8092e79204e7884f4bee3584ecfe6cf4a124d129
Author: Andrey Smirnov <andrew.smirnov@gmail.com>
Date:   Thu Dec 20 23:28:37 2018 -0800

    ihex: Share code between ihex_validate_fw() and ihex_next_binrec()
    
    Convert both ihex_validate_fw() and ihex_next_binrec() to use a helper
    function to calculate next record offest. This way we only have one
    place implementing next record offset calculation logic. No functional
    change intended.
    
    Cc: Chris Healy <cphealy@gmail.com>
    Cc: Kyle McMartin <kyle@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: linux-kernel <linux-kernel@vger.kernel.org>
    Signed-off-by: Andrey Smirnov <andrew.smirnov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/ihex.h b/include/linux/ihex.h
index 75c194391869..9c701521176b 100644
--- a/include/linux/ihex.h
+++ b/include/linux/ihex.h
@@ -23,29 +23,34 @@ struct ihex_binrec {
 
 /* Find the next record, taking into account the 4-byte alignment */
 static inline const struct ihex_binrec *
-ihex_next_binrec(const struct ihex_binrec *rec)
+__ihex_next_binrec(const struct ihex_binrec *rec)
 {
 	int next = ((be16_to_cpu(rec->len) + 5) & ~3) - 2;
 	rec = (void *)&rec->data[next];
 
+	return rec;
+}
+
+static inline const struct ihex_binrec *
+ihex_next_binrec(const struct ihex_binrec *rec)
+{
+	rec = __ihex_next_binrec(rec);
+
 	return be16_to_cpu(rec->len) ? rec : NULL;
 }
 
 /* Check that ihex_next_binrec() won't take us off the end of the image... */
 static inline int ihex_validate_fw(const struct firmware *fw)
 {
-	const struct ihex_binrec *rec;
-	size_t ofs = 0;
+	const struct ihex_binrec *end, *rec;
 
-	while (ofs <= fw->size - sizeof(*rec)) {
-		rec = (void *)&fw->data[ofs];
+	rec = (const void *)fw->data;
+	end = (const void *)&fw->data[fw->size - sizeof(*end)];
 
+	for (; rec <= end; rec = __ihex_next_binrec(rec)) {
 		/* Zero length marks end of records */
 		if (!be16_to_cpu(rec->len))
 			return 0;
-
-		/* Point to next record... */
-		ofs += (sizeof(*rec) + be16_to_cpu(rec->len) + 3) & ~3;
 	}
 	return -EINVAL;
 }

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/ihex.h b/include/linux/ihex.h
index 31d8629e75a1..75c194391869 100644
--- a/include/linux/ihex.h
+++ b/include/linux/ihex.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Compact binary representation of ihex records. Some devices need their
  * firmware loaded in strange orders rather than a single big blob, but

commit 85ebd00334099fd5d296bcae74a66c943d46686d
Author: Marc Zyngier <maz@misterjones.org>
Date:   Sat Aug 2 19:12:23 2008 +0200

    Fix IHEX firmware generation/loading
    
    Fix both the IHEX firmware generation (len field always null, and EOF
    marker a byte too short) and loading (struct ihex_binrec needs to be
    packed to reflect the on-disk structure).
    
    Signed-off-by: Marc Zyngier <maz@misterjones.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/ihex.h b/include/linux/ihex.h
index 2baace2788a7..31d8629e75a1 100644
--- a/include/linux/ihex.h
+++ b/include/linux/ihex.h
@@ -18,7 +18,7 @@ struct ihex_binrec {
 	__be32 addr;
 	__be16 len;
 	uint8_t data[0];
-} __attribute__((aligned(4)));
+} __attribute__((packed));
 
 /* Find the next record, taking into account the 4-byte alignment */
 static inline const struct ihex_binrec *

commit f1485f3deb89e6ae10c4d34662ec9e692855ab5d
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Sat May 31 15:20:37 2008 +0300

    ihex: request_ihex_firmware() function to load and validate firmware
    
    Provide a helper to load the file and validate it in one call, to
    simplify error handling in the drivers which are going to use it.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/ihex.h b/include/linux/ihex.h
index df89edd890ae..2baace2788a7 100644
--- a/include/linux/ihex.h
+++ b/include/linux/ihex.h
@@ -9,6 +9,7 @@
 
 #include <linux/types.h>
 #include <linux/firmware.h>
+#include <linux/device.h>
 
 /* Intel HEX files actually limit the length to 256 bytes, but we have
    drivers which would benefit from using separate records which are
@@ -47,4 +48,27 @@ static inline int ihex_validate_fw(const struct firmware *fw)
 	}
 	return -EINVAL;
 }
+
+/* Request firmware and validate it so that we can trust we won't
+ * run off the end while reading records... */
+static inline int request_ihex_firmware(const struct firmware **fw,
+					const char *fw_name,
+					struct device *dev)
+{
+	const struct firmware *lfw;
+	int ret;
+
+	ret = request_firmware(&lfw, fw_name, dev);
+	if (ret)
+		return ret;
+	ret = ihex_validate_fw(lfw);
+	if (ret) {
+		dev_err(dev, "Firmware \"%s\" not valid IHEX records\n",
+			fw_name);
+		release_firmware(lfw);
+		return ret;
+	}
+	*fw = lfw;
+	return 0;
+}
 #endif /* __LINUX_IHEX_H__ */

commit bacfe09dd7545467965e8d8f1eab20bc62dce00d
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Fri May 30 13:57:27 2008 +0300

    ihex.h: binary representation of ihex records
    
    Some devices need their firmware as a set of {address, len, data...}
    records in some specific order rather than a simple blob.
    
    The normal way of doing this kind of thing is 'ihex', which is a text
    format and not entirely suitable for use in the kernel.
    
    This provides a binary representation which is very similar, but much
    more compact -- and a helper routine to skip to the next record,
    because the alignment constraints mean that everybody will screw it up
    for themselves otherwise.
    
    Also a helper function which can verify that a 'struct firmware'
    contains a valid set of ihex records, and that following them won't run
    off the end of the loaded data.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/ihex.h b/include/linux/ihex.h
new file mode 100644
index 000000000000..df89edd890ae
--- /dev/null
+++ b/include/linux/ihex.h
@@ -0,0 +1,50 @@
+/*
+ * Compact binary representation of ihex records. Some devices need their
+ * firmware loaded in strange orders rather than a single big blob, but
+ * actually parsing ihex-as-text within the kernel seems silly. Thus,...
+ */
+
+#ifndef __LINUX_IHEX_H__
+#define __LINUX_IHEX_H__
+
+#include <linux/types.h>
+#include <linux/firmware.h>
+
+/* Intel HEX files actually limit the length to 256 bytes, but we have
+   drivers which would benefit from using separate records which are
+   longer than that, so we extend to 16 bits of length */
+struct ihex_binrec {
+	__be32 addr;
+	__be16 len;
+	uint8_t data[0];
+} __attribute__((aligned(4)));
+
+/* Find the next record, taking into account the 4-byte alignment */
+static inline const struct ihex_binrec *
+ihex_next_binrec(const struct ihex_binrec *rec)
+{
+	int next = ((be16_to_cpu(rec->len) + 5) & ~3) - 2;
+	rec = (void *)&rec->data[next];
+
+	return be16_to_cpu(rec->len) ? rec : NULL;
+}
+
+/* Check that ihex_next_binrec() won't take us off the end of the image... */
+static inline int ihex_validate_fw(const struct firmware *fw)
+{
+	const struct ihex_binrec *rec;
+	size_t ofs = 0;
+
+	while (ofs <= fw->size - sizeof(*rec)) {
+		rec = (void *)&fw->data[ofs];
+
+		/* Zero length marks end of records */
+		if (!be16_to_cpu(rec->len))
+			return 0;
+
+		/* Point to next record... */
+		ofs += (sizeof(*rec) + be16_to_cpu(rec->len) + 3) & ~3;
+	}
+	return -EINVAL;
+}
+#endif /* __LINUX_IHEX_H__ */
