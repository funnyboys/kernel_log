commit 0c43125f2778dddb469036caaa14533846ce40bd
Author: Tudor Ambarus <tudor.ambarus@microchip.com>
Date:   Fri Aug 23 15:39:37 2019 +0000

    mtd: nand: fix typo, s/erasablocks/eraseblocks
    
    Signed-off-by: Tudor Ambarus <tudor.ambarus@microchip.com>
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index cebc38b6d6f5..0c7483843a32 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -346,7 +346,7 @@ static inline unsigned int nanddev_ntargets(const struct nand_device *nand)
 }
 
 /**
- * nanddev_neraseblocks() - Get the total number of erasablocks
+ * nanddev_neraseblocks() - Get the total number of eraseblocks
  * @nand: NAND device
  *
  * Return: the total number of eraseblocks exposed by @nand.

commit 46b01d7efda29356d4dff88825e5ef51dd9f6bae
Author: Boris Brezillon <bbrezillon@kernel.org>
Date:   Mon Oct 29 17:18:39 2018 +0100

    mtd: nand: Add a helper to retrieve the number of pages per target
    
    Will be used by the raw NAND framework.
    
    Signed-off-by: Boris Brezillon <bbrezillon@kernel.org>
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Reviewed-by: Frieder Schrempf <frieder.schrempf@kontron.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 12d75402472a..cebc38b6d6f5 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -271,6 +271,20 @@ nanddev_pages_per_eraseblock(const struct nand_device *nand)
 	return nand->memorg.pages_per_eraseblock;
 }
 
+/**
+ * nanddev_pages_per_target() - Get the number of pages per target
+ * @nand: NAND device
+ *
+ * Return: the number of pages per target.
+ */
+static inline unsigned int
+nanddev_pages_per_target(const struct nand_device *nand)
+{
+	return nand->memorg.pages_per_eraseblock *
+	       nand->memorg.eraseblocks_per_lun *
+	       nand->memorg.luns_per_target;
+}
+
 /**
  * nanddev_per_page_oobsize() - Get NAND erase block size
  * @nand: NAND device

commit 7c4ecca103b3d70c50adc693c9f5d39d292e13e0
Author: Boris Brezillon <bbrezillon@kernel.org>
Date:   Mon Oct 29 10:29:48 2018 +0100

    mtd: nand: Add a helper returning the number of eraseblocks per target
    
    Some drivers in the raw NAND framework seems to need this helper, so
    let's just add it instead of open-coding the logic.
    
    Signed-off-by: Boris Brezillon <bbrezillon@kernel.org>
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Reviewed-by: Frieder Schrempf <frieder.schrempf@kontron.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index d32bb623d532..12d75402472a 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -294,6 +294,18 @@ nanddev_eraseblocks_per_lun(const struct nand_device *nand)
 	return nand->memorg.eraseblocks_per_lun;
 }
 
+/**
+ * nanddev_eraseblocks_per_target() - Get the number of eraseblocks per target
+ * @nand: NAND device
+ *
+ * Return: the number of eraseblocks per target.
+ */
+static inline unsigned int
+nanddev_eraseblocks_per_target(const struct nand_device *nand)
+{
+	return nand->memorg.eraseblocks_per_lun * nand->memorg.luns_per_target;
+}
+
 /**
  * nanddev_target_size() - Get the total size provided by a single target/die
  * @nand: NAND device

commit 377e517b5fa53590418a7b4c2206082d92434fa3
Author: Boris Brezillon <bbrezillon@kernel.org>
Date:   Sun Nov 4 14:43:37 2018 +0100

    mtd: nand: Add max_bad_eraseblocks_per_lun info to memorg
    
    NAND datasheets usually give the maximum number of bad blocks per LUN
    and this number can be used to help upper layers decide how much blocks
    they should reserve for bad block handling.
    
    Add a max_bad_eraseblocks_per_lun to the nand_memory_organization
    struct and update the NAND_MEMORG() macro (and its users) accordingly.
    
    We also provide a default mtd->_max_bad_blocks() implementation.
    
    Signed-off-by: Boris Brezillon <bbrezillon@kernel.org>
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Reviewed-by: Frieder Schrempf <frieder.schrempf@kontron.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 7f53ece2c039..d32bb623d532 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -19,6 +19,7 @@
  * @oobsize: OOB area size
  * @pages_per_eraseblock: number of pages per eraseblock
  * @eraseblocks_per_lun: number of eraseblocks per LUN (Logical Unit Number)
+ * @max_bad_eraseblocks_per_lun: maximum number of eraseblocks per LUN
  * @planes_per_lun: number of planes per LUN
  * @luns_per_target: number of LUN per target (target is a synonym for die)
  * @ntargets: total number of targets exposed by the NAND device
@@ -29,18 +30,20 @@ struct nand_memory_organization {
 	unsigned int oobsize;
 	unsigned int pages_per_eraseblock;
 	unsigned int eraseblocks_per_lun;
+	unsigned int max_bad_eraseblocks_per_lun;
 	unsigned int planes_per_lun;
 	unsigned int luns_per_target;
 	unsigned int ntargets;
 };
 
-#define NAND_MEMORG(bpc, ps, os, ppe, epl, ppl, lpt, nt)	\
+#define NAND_MEMORG(bpc, ps, os, ppe, epl, mbb, ppl, lpt, nt)	\
 	{							\
 		.bits_per_cell = (bpc),				\
 		.pagesize = (ps),				\
 		.oobsize = (os),				\
 		.pages_per_eraseblock = (ppe),			\
 		.eraseblocks_per_lun = (epl),			\
+		.max_bad_eraseblocks_per_lun = (mbb),		\
 		.planes_per_lun = (ppl),			\
 		.luns_per_target = (lpt),			\
 		.ntargets = (nt),				\
@@ -729,5 +732,6 @@ static inline bool nanddev_bbt_is_initialized(struct nand_device *nand)
 
 /* MTD -> NAND helper functions. */
 int nanddev_mtd_erase(struct mtd_info *mtd, struct erase_info *einfo);
+int nanddev_mtd_max_bad_blocks(struct mtd_info *mtd, loff_t offs, size_t len);
 
 #endif /* __LINUX_MTD_NAND_H */

commit 98ee3fc7ef8395f8b7a379e6608aee91efc66d48
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Tue Nov 6 17:25:37 2018 +0100

    mtd: nand: Fix nanddev_pos_next_page() kernel-doc header
    
    Function name is wrong in the kernel-doc header.
    
    Fixes: 9c3736a3de21 ("mtd: nand: Add core infrastructure to deal with NAND devices")
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Miquel Raynal <miquel.raynal@bootlin.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 78b86dea2f29..7f53ece2c039 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -568,7 +568,7 @@ static inline void nanddev_pos_next_eraseblock(struct nand_device *nand,
 }
 
 /**
- * nanddev_pos_next_eraseblock() - Move a position to the next page
+ * nanddev_pos_next_page() - Move a position to the next page
  * @nand: NAND device
  * @pos: the position to update
  *

commit d098093ba06eb032057d1aca1c2e45889e099d00
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Sun Oct 28 12:29:55 2018 +0100

    mtd: nand: Fix nanddev_neraseblocks()
    
    nanddev_neraseblocks() currently returns the number pages per LUN
    instead of the total number of eraseblocks.
    
    Fixes: 9c3736a3de21 ("mtd: nand: Add core infrastructure to deal with NAND devices")
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Miquel Raynal <miquel.raynal@bootlin.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index abe975c87b90..78b86dea2f29 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -324,9 +324,8 @@ static inline unsigned int nanddev_ntargets(const struct nand_device *nand)
  */
 static inline unsigned int nanddev_neraseblocks(const struct nand_device *nand)
 {
-	return (u64)nand->memorg.luns_per_target *
-	       nand->memorg.eraseblocks_per_lun *
-	       nand->memorg.pages_per_eraseblock;
+	return nand->memorg.ntargets * nand->memorg.luns_per_target *
+	       nand->memorg.eraseblocks_per_lun;
 }
 
 /**

commit f567c71f4f91d173795a2f46d6fc493387ce084d
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Tue May 15 17:08:21 2018 +0200

    mtd: nand: Pass mode information to nand_page_io_req
    
    The NAND sub-layers are likely to need the MTD_OPS_XXX mode information
    in order to decide if they should enable/disable ECC or how they should
    place the OOB bytes in the provided OOB buffer.
    
    Add a field to nand_page_io_req to pass this information.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Tested-by: Frieder Schrempf <frieder.schrempf@exceet.de>
    Reviewed-by: Frieder Schrempf <frieder.schrempf@exceet.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 792ea5c26329..abe975c87b90 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -86,6 +86,7 @@ struct nand_pos {
  * @ooboffs: the OOB offset within the page
  * @ooblen: the number of OOB bytes to read from/write to this page
  * @oobbuf: buffer to store OOB data in or get OOB data from
+ * @mode: one of the %MTD_OPS_XXX mode
  *
  * This object is used to pass per-page I/O requests to NAND sub-layers. This
  * way all useful information are already formatted in a useful way and
@@ -106,6 +107,7 @@ struct nand_page_io_req {
 		const void *out;
 		void *in;
 	} oobbuf;
+	int mode;
 };
 
 /**
@@ -599,6 +601,7 @@ static inline void nanddev_io_iter_init(struct nand_device *nand,
 {
 	struct mtd_info *mtd = nanddev_to_mtd(nand);
 
+	iter->req.mode = req->mode;
 	iter->req.dataoffs = nanddev_offs_to_pos(nand, offs, &iter->req.pos);
 	iter->req.ooboffs = req->ooboffs;
 	iter->oobbytes_per_page = mtd_oobavail(mtd, req);

commit 9c3736a3de21d916a6af0594418b85a112f4bef6
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Mon Feb 5 23:02:05 2018 +0100

    mtd: nand: Add core infrastructure to deal with NAND devices
    
    Add an intermediate layer to abstract NAND device interface so that
    some logic can be shared between SPI NANDs, parallel/raw NANDs,
    OneNANDs, ...
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
new file mode 100644
index 000000000000..792ea5c26329
--- /dev/null
+++ b/include/linux/mtd/nand.h
@@ -0,0 +1,731 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ *  Copyright 2017 - Free Electrons
+ *
+ *  Authors:
+ *	Boris Brezillon <boris.brezillon@free-electrons.com>
+ *	Peter Pan <peterpandong@micron.com>
+ */
+
+#ifndef __LINUX_MTD_NAND_H
+#define __LINUX_MTD_NAND_H
+
+#include <linux/mtd/mtd.h>
+
+/**
+ * struct nand_memory_organization - Memory organization structure
+ * @bits_per_cell: number of bits per NAND cell
+ * @pagesize: page size
+ * @oobsize: OOB area size
+ * @pages_per_eraseblock: number of pages per eraseblock
+ * @eraseblocks_per_lun: number of eraseblocks per LUN (Logical Unit Number)
+ * @planes_per_lun: number of planes per LUN
+ * @luns_per_target: number of LUN per target (target is a synonym for die)
+ * @ntargets: total number of targets exposed by the NAND device
+ */
+struct nand_memory_organization {
+	unsigned int bits_per_cell;
+	unsigned int pagesize;
+	unsigned int oobsize;
+	unsigned int pages_per_eraseblock;
+	unsigned int eraseblocks_per_lun;
+	unsigned int planes_per_lun;
+	unsigned int luns_per_target;
+	unsigned int ntargets;
+};
+
+#define NAND_MEMORG(bpc, ps, os, ppe, epl, ppl, lpt, nt)	\
+	{							\
+		.bits_per_cell = (bpc),				\
+		.pagesize = (ps),				\
+		.oobsize = (os),				\
+		.pages_per_eraseblock = (ppe),			\
+		.eraseblocks_per_lun = (epl),			\
+		.planes_per_lun = (ppl),			\
+		.luns_per_target = (lpt),			\
+		.ntargets = (nt),				\
+	}
+
+/**
+ * struct nand_row_converter - Information needed to convert an absolute offset
+ *			       into a row address
+ * @lun_addr_shift: position of the LUN identifier in the row address
+ * @eraseblock_addr_shift: position of the eraseblock identifier in the row
+ *			   address
+ */
+struct nand_row_converter {
+	unsigned int lun_addr_shift;
+	unsigned int eraseblock_addr_shift;
+};
+
+/**
+ * struct nand_pos - NAND position object
+ * @target: the NAND target/die
+ * @lun: the LUN identifier
+ * @plane: the plane within the LUN
+ * @eraseblock: the eraseblock within the LUN
+ * @page: the page within the LUN
+ *
+ * These information are usually used by specific sub-layers to select the
+ * appropriate target/die and generate a row address to pass to the device.
+ */
+struct nand_pos {
+	unsigned int target;
+	unsigned int lun;
+	unsigned int plane;
+	unsigned int eraseblock;
+	unsigned int page;
+};
+
+/**
+ * struct nand_page_io_req - NAND I/O request object
+ * @pos: the position this I/O request is targeting
+ * @dataoffs: the offset within the page
+ * @datalen: number of data bytes to read from/write to this page
+ * @databuf: buffer to store data in or get data from
+ * @ooboffs: the OOB offset within the page
+ * @ooblen: the number of OOB bytes to read from/write to this page
+ * @oobbuf: buffer to store OOB data in or get OOB data from
+ *
+ * This object is used to pass per-page I/O requests to NAND sub-layers. This
+ * way all useful information are already formatted in a useful way and
+ * specific NAND layers can focus on translating these information into
+ * specific commands/operations.
+ */
+struct nand_page_io_req {
+	struct nand_pos pos;
+	unsigned int dataoffs;
+	unsigned int datalen;
+	union {
+		const void *out;
+		void *in;
+	} databuf;
+	unsigned int ooboffs;
+	unsigned int ooblen;
+	union {
+		const void *out;
+		void *in;
+	} oobbuf;
+};
+
+/**
+ * struct nand_ecc_req - NAND ECC requirements
+ * @strength: ECC strength
+ * @step_size: ECC step/block size
+ */
+struct nand_ecc_req {
+	unsigned int strength;
+	unsigned int step_size;
+};
+
+#define NAND_ECCREQ(str, stp) { .strength = (str), .step_size = (stp) }
+
+/**
+ * struct nand_bbt - bad block table object
+ * @cache: in memory BBT cache
+ */
+struct nand_bbt {
+	unsigned long *cache;
+};
+
+struct nand_device;
+
+/**
+ * struct nand_ops - NAND operations
+ * @erase: erase a specific block. No need to check if the block is bad before
+ *	   erasing, this has been taken care of by the generic NAND layer
+ * @markbad: mark a specific block bad. No need to check if the block is
+ *	     already marked bad, this has been taken care of by the generic
+ *	     NAND layer. This method should just write the BBM (Bad Block
+ *	     Marker) so that future call to struct_nand_ops->isbad() return
+ *	     true
+ * @isbad: check whether a block is bad or not. This method should just read
+ *	   the BBM and return whether the block is bad or not based on what it
+ *	   reads
+ *
+ * These are all low level operations that should be implemented by specialized
+ * NAND layers (SPI NAND, raw NAND, ...).
+ */
+struct nand_ops {
+	int (*erase)(struct nand_device *nand, const struct nand_pos *pos);
+	int (*markbad)(struct nand_device *nand, const struct nand_pos *pos);
+	bool (*isbad)(struct nand_device *nand, const struct nand_pos *pos);
+};
+
+/**
+ * struct nand_device - NAND device
+ * @mtd: MTD instance attached to the NAND device
+ * @memorg: memory layout
+ * @eccreq: ECC requirements
+ * @rowconv: position to row address converter
+ * @bbt: bad block table info
+ * @ops: NAND operations attached to the NAND device
+ *
+ * Generic NAND object. Specialized NAND layers (raw NAND, SPI NAND, OneNAND)
+ * should declare their own NAND object embedding a nand_device struct (that's
+ * how inheritance is done).
+ * struct_nand_device->memorg and struct_nand_device->eccreq should be filled
+ * at device detection time to reflect the NAND device
+ * capabilities/requirements. Once this is done nanddev_init() can be called.
+ * It will take care of converting NAND information into MTD ones, which means
+ * the specialized NAND layers should never manually tweak
+ * struct_nand_device->mtd except for the ->_read/write() hooks.
+ */
+struct nand_device {
+	struct mtd_info mtd;
+	struct nand_memory_organization memorg;
+	struct nand_ecc_req eccreq;
+	struct nand_row_converter rowconv;
+	struct nand_bbt bbt;
+	const struct nand_ops *ops;
+};
+
+/**
+ * struct nand_io_iter - NAND I/O iterator
+ * @req: current I/O request
+ * @oobbytes_per_page: maximum number of OOB bytes per page
+ * @dataleft: remaining number of data bytes to read/write
+ * @oobleft: remaining number of OOB bytes to read/write
+ *
+ * Can be used by specialized NAND layers to iterate over all pages covered
+ * by an MTD I/O request, which should greatly simplifies the boiler-plate
+ * code needed to read/write data from/to a NAND device.
+ */
+struct nand_io_iter {
+	struct nand_page_io_req req;
+	unsigned int oobbytes_per_page;
+	unsigned int dataleft;
+	unsigned int oobleft;
+};
+
+/**
+ * mtd_to_nanddev() - Get the NAND device attached to the MTD instance
+ * @mtd: MTD instance
+ *
+ * Return: the NAND device embedding @mtd.
+ */
+static inline struct nand_device *mtd_to_nanddev(struct mtd_info *mtd)
+{
+	return container_of(mtd, struct nand_device, mtd);
+}
+
+/**
+ * nanddev_to_mtd() - Get the MTD device attached to a NAND device
+ * @nand: NAND device
+ *
+ * Return: the MTD device embedded in @nand.
+ */
+static inline struct mtd_info *nanddev_to_mtd(struct nand_device *nand)
+{
+	return &nand->mtd;
+}
+
+/*
+ * nanddev_bits_per_cell() - Get the number of bits per cell
+ * @nand: NAND device
+ *
+ * Return: the number of bits per cell.
+ */
+static inline unsigned int nanddev_bits_per_cell(const struct nand_device *nand)
+{
+	return nand->memorg.bits_per_cell;
+}
+
+/**
+ * nanddev_page_size() - Get NAND page size
+ * @nand: NAND device
+ *
+ * Return: the page size.
+ */
+static inline size_t nanddev_page_size(const struct nand_device *nand)
+{
+	return nand->memorg.pagesize;
+}
+
+/**
+ * nanddev_per_page_oobsize() - Get NAND OOB size
+ * @nand: NAND device
+ *
+ * Return: the OOB size.
+ */
+static inline unsigned int
+nanddev_per_page_oobsize(const struct nand_device *nand)
+{
+	return nand->memorg.oobsize;
+}
+
+/**
+ * nanddev_pages_per_eraseblock() - Get the number of pages per eraseblock
+ * @nand: NAND device
+ *
+ * Return: the number of pages per eraseblock.
+ */
+static inline unsigned int
+nanddev_pages_per_eraseblock(const struct nand_device *nand)
+{
+	return nand->memorg.pages_per_eraseblock;
+}
+
+/**
+ * nanddev_per_page_oobsize() - Get NAND erase block size
+ * @nand: NAND device
+ *
+ * Return: the eraseblock size.
+ */
+static inline size_t nanddev_eraseblock_size(const struct nand_device *nand)
+{
+	return nand->memorg.pagesize * nand->memorg.pages_per_eraseblock;
+}
+
+/**
+ * nanddev_eraseblocks_per_lun() - Get the number of eraseblocks per LUN
+ * @nand: NAND device
+ *
+ * Return: the number of eraseblocks per LUN.
+ */
+static inline unsigned int
+nanddev_eraseblocks_per_lun(const struct nand_device *nand)
+{
+	return nand->memorg.eraseblocks_per_lun;
+}
+
+/**
+ * nanddev_target_size() - Get the total size provided by a single target/die
+ * @nand: NAND device
+ *
+ * Return: the total size exposed by a single target/die in bytes.
+ */
+static inline u64 nanddev_target_size(const struct nand_device *nand)
+{
+	return (u64)nand->memorg.luns_per_target *
+	       nand->memorg.eraseblocks_per_lun *
+	       nand->memorg.pages_per_eraseblock *
+	       nand->memorg.pagesize;
+}
+
+/**
+ * nanddev_ntarget() - Get the total of targets
+ * @nand: NAND device
+ *
+ * Return: the number of targets/dies exposed by @nand.
+ */
+static inline unsigned int nanddev_ntargets(const struct nand_device *nand)
+{
+	return nand->memorg.ntargets;
+}
+
+/**
+ * nanddev_neraseblocks() - Get the total number of erasablocks
+ * @nand: NAND device
+ *
+ * Return: the total number of eraseblocks exposed by @nand.
+ */
+static inline unsigned int nanddev_neraseblocks(const struct nand_device *nand)
+{
+	return (u64)nand->memorg.luns_per_target *
+	       nand->memorg.eraseblocks_per_lun *
+	       nand->memorg.pages_per_eraseblock;
+}
+
+/**
+ * nanddev_size() - Get NAND size
+ * @nand: NAND device
+ *
+ * Return: the total size (in bytes) exposed by @nand.
+ */
+static inline u64 nanddev_size(const struct nand_device *nand)
+{
+	return nanddev_target_size(nand) * nanddev_ntargets(nand);
+}
+
+/**
+ * nanddev_get_memorg() - Extract memory organization info from a NAND device
+ * @nand: NAND device
+ *
+ * This can be used by the upper layer to fill the memorg info before calling
+ * nanddev_init().
+ *
+ * Return: the memorg object embedded in the NAND device.
+ */
+static inline struct nand_memory_organization *
+nanddev_get_memorg(struct nand_device *nand)
+{
+	return &nand->memorg;
+}
+
+int nanddev_init(struct nand_device *nand, const struct nand_ops *ops,
+		 struct module *owner);
+void nanddev_cleanup(struct nand_device *nand);
+
+/**
+ * nanddev_register() - Register a NAND device
+ * @nand: NAND device
+ *
+ * Register a NAND device.
+ * This function is just a wrapper around mtd_device_register()
+ * registering the MTD device embedded in @nand.
+ *
+ * Return: 0 in case of success, a negative error code otherwise.
+ */
+static inline int nanddev_register(struct nand_device *nand)
+{
+	return mtd_device_register(&nand->mtd, NULL, 0);
+}
+
+/**
+ * nanddev_unregister() - Unregister a NAND device
+ * @nand: NAND device
+ *
+ * Unregister a NAND device.
+ * This function is just a wrapper around mtd_device_unregister()
+ * unregistering the MTD device embedded in @nand.
+ *
+ * Return: 0 in case of success, a negative error code otherwise.
+ */
+static inline int nanddev_unregister(struct nand_device *nand)
+{
+	return mtd_device_unregister(&nand->mtd);
+}
+
+/**
+ * nanddev_set_of_node() - Attach a DT node to a NAND device
+ * @nand: NAND device
+ * @np: DT node
+ *
+ * Attach a DT node to a NAND device.
+ */
+static inline void nanddev_set_of_node(struct nand_device *nand,
+				       struct device_node *np)
+{
+	mtd_set_of_node(&nand->mtd, np);
+}
+
+/**
+ * nanddev_get_of_node() - Retrieve the DT node attached to a NAND device
+ * @nand: NAND device
+ *
+ * Return: the DT node attached to @nand.
+ */
+static inline struct device_node *nanddev_get_of_node(struct nand_device *nand)
+{
+	return mtd_get_of_node(&nand->mtd);
+}
+
+/**
+ * nanddev_offs_to_pos() - Convert an absolute NAND offset into a NAND position
+ * @nand: NAND device
+ * @offs: absolute NAND offset (usually passed by the MTD layer)
+ * @pos: a NAND position object to fill in
+ *
+ * Converts @offs into a nand_pos representation.
+ *
+ * Return: the offset within the NAND page pointed by @pos.
+ */
+static inline unsigned int nanddev_offs_to_pos(struct nand_device *nand,
+					       loff_t offs,
+					       struct nand_pos *pos)
+{
+	unsigned int pageoffs;
+	u64 tmp = offs;
+
+	pageoffs = do_div(tmp, nand->memorg.pagesize);
+	pos->page = do_div(tmp, nand->memorg.pages_per_eraseblock);
+	pos->eraseblock = do_div(tmp, nand->memorg.eraseblocks_per_lun);
+	pos->plane = pos->eraseblock % nand->memorg.planes_per_lun;
+	pos->lun = do_div(tmp, nand->memorg.luns_per_target);
+	pos->target = tmp;
+
+	return pageoffs;
+}
+
+/**
+ * nanddev_pos_cmp() - Compare two NAND positions
+ * @a: First NAND position
+ * @b: Second NAND position
+ *
+ * Compares two NAND positions.
+ *
+ * Return: -1 if @a < @b, 0 if @a == @b and 1 if @a > @b.
+ */
+static inline int nanddev_pos_cmp(const struct nand_pos *a,
+				  const struct nand_pos *b)
+{
+	if (a->target != b->target)
+		return a->target < b->target ? -1 : 1;
+
+	if (a->lun != b->lun)
+		return a->lun < b->lun ? -1 : 1;
+
+	if (a->eraseblock != b->eraseblock)
+		return a->eraseblock < b->eraseblock ? -1 : 1;
+
+	if (a->page != b->page)
+		return a->page < b->page ? -1 : 1;
+
+	return 0;
+}
+
+/**
+ * nanddev_pos_to_offs() - Convert a NAND position into an absolute offset
+ * @nand: NAND device
+ * @pos: the NAND position to convert
+ *
+ * Converts @pos NAND position into an absolute offset.
+ *
+ * Return: the absolute offset. Note that @pos points to the beginning of a
+ *	   page, if one wants to point to a specific offset within this page
+ *	   the returned offset has to be adjusted manually.
+ */
+static inline loff_t nanddev_pos_to_offs(struct nand_device *nand,
+					 const struct nand_pos *pos)
+{
+	unsigned int npages;
+
+	npages = pos->page +
+		 ((pos->eraseblock +
+		   (pos->lun +
+		    (pos->target * nand->memorg.luns_per_target)) *
+		   nand->memorg.eraseblocks_per_lun) *
+		  nand->memorg.pages_per_eraseblock);
+
+	return (loff_t)npages * nand->memorg.pagesize;
+}
+
+/**
+ * nanddev_pos_to_row() - Extract a row address from a NAND position
+ * @nand: NAND device
+ * @pos: the position to convert
+ *
+ * Converts a NAND position into a row address that can then be passed to the
+ * device.
+ *
+ * Return: the row address extracted from @pos.
+ */
+static inline unsigned int nanddev_pos_to_row(struct nand_device *nand,
+					      const struct nand_pos *pos)
+{
+	return (pos->lun << nand->rowconv.lun_addr_shift) |
+	       (pos->eraseblock << nand->rowconv.eraseblock_addr_shift) |
+	       pos->page;
+}
+
+/**
+ * nanddev_pos_next_target() - Move a position to the next target/die
+ * @nand: NAND device
+ * @pos: the position to update
+ *
+ * Updates @pos to point to the start of the next target/die. Useful when you
+ * want to iterate over all targets/dies of a NAND device.
+ */
+static inline void nanddev_pos_next_target(struct nand_device *nand,
+					   struct nand_pos *pos)
+{
+	pos->page = 0;
+	pos->plane = 0;
+	pos->eraseblock = 0;
+	pos->lun = 0;
+	pos->target++;
+}
+
+/**
+ * nanddev_pos_next_lun() - Move a position to the next LUN
+ * @nand: NAND device
+ * @pos: the position to update
+ *
+ * Updates @pos to point to the start of the next LUN. Useful when you want to
+ * iterate over all LUNs of a NAND device.
+ */
+static inline void nanddev_pos_next_lun(struct nand_device *nand,
+					struct nand_pos *pos)
+{
+	if (pos->lun >= nand->memorg.luns_per_target - 1)
+		return nanddev_pos_next_target(nand, pos);
+
+	pos->lun++;
+	pos->page = 0;
+	pos->plane = 0;
+	pos->eraseblock = 0;
+}
+
+/**
+ * nanddev_pos_next_eraseblock() - Move a position to the next eraseblock
+ * @nand: NAND device
+ * @pos: the position to update
+ *
+ * Updates @pos to point to the start of the next eraseblock. Useful when you
+ * want to iterate over all eraseblocks of a NAND device.
+ */
+static inline void nanddev_pos_next_eraseblock(struct nand_device *nand,
+					       struct nand_pos *pos)
+{
+	if (pos->eraseblock >= nand->memorg.eraseblocks_per_lun - 1)
+		return nanddev_pos_next_lun(nand, pos);
+
+	pos->eraseblock++;
+	pos->page = 0;
+	pos->plane = pos->eraseblock % nand->memorg.planes_per_lun;
+}
+
+/**
+ * nanddev_pos_next_eraseblock() - Move a position to the next page
+ * @nand: NAND device
+ * @pos: the position to update
+ *
+ * Updates @pos to point to the start of the next page. Useful when you want to
+ * iterate over all pages of a NAND device.
+ */
+static inline void nanddev_pos_next_page(struct nand_device *nand,
+					 struct nand_pos *pos)
+{
+	if (pos->page >= nand->memorg.pages_per_eraseblock - 1)
+		return nanddev_pos_next_eraseblock(nand, pos);
+
+	pos->page++;
+}
+
+/**
+ * nand_io_iter_init - Initialize a NAND I/O iterator
+ * @nand: NAND device
+ * @offs: absolute offset
+ * @req: MTD request
+ * @iter: NAND I/O iterator
+ *
+ * Initializes a NAND iterator based on the information passed by the MTD
+ * layer.
+ */
+static inline void nanddev_io_iter_init(struct nand_device *nand,
+					loff_t offs, struct mtd_oob_ops *req,
+					struct nand_io_iter *iter)
+{
+	struct mtd_info *mtd = nanddev_to_mtd(nand);
+
+	iter->req.dataoffs = nanddev_offs_to_pos(nand, offs, &iter->req.pos);
+	iter->req.ooboffs = req->ooboffs;
+	iter->oobbytes_per_page = mtd_oobavail(mtd, req);
+	iter->dataleft = req->len;
+	iter->oobleft = req->ooblen;
+	iter->req.databuf.in = req->datbuf;
+	iter->req.datalen = min_t(unsigned int,
+				  nand->memorg.pagesize - iter->req.dataoffs,
+				  iter->dataleft);
+	iter->req.oobbuf.in = req->oobbuf;
+	iter->req.ooblen = min_t(unsigned int,
+				 iter->oobbytes_per_page - iter->req.ooboffs,
+				 iter->oobleft);
+}
+
+/**
+ * nand_io_iter_next_page - Move to the next page
+ * @nand: NAND device
+ * @iter: NAND I/O iterator
+ *
+ * Updates the @iter to point to the next page.
+ */
+static inline void nanddev_io_iter_next_page(struct nand_device *nand,
+					     struct nand_io_iter *iter)
+{
+	nanddev_pos_next_page(nand, &iter->req.pos);
+	iter->dataleft -= iter->req.datalen;
+	iter->req.databuf.in += iter->req.datalen;
+	iter->oobleft -= iter->req.ooblen;
+	iter->req.oobbuf.in += iter->req.ooblen;
+	iter->req.dataoffs = 0;
+	iter->req.ooboffs = 0;
+	iter->req.datalen = min_t(unsigned int, nand->memorg.pagesize,
+				  iter->dataleft);
+	iter->req.ooblen = min_t(unsigned int, iter->oobbytes_per_page,
+				 iter->oobleft);
+}
+
+/**
+ * nand_io_iter_end - Should end iteration or not
+ * @nand: NAND device
+ * @iter: NAND I/O iterator
+ *
+ * Check whether @iter has reached the end of the NAND portion it was asked to
+ * iterate on or not.
+ *
+ * Return: true if @iter has reached the end of the iteration request, false
+ *	   otherwise.
+ */
+static inline bool nanddev_io_iter_end(struct nand_device *nand,
+				       const struct nand_io_iter *iter)
+{
+	if (iter->dataleft || iter->oobleft)
+		return false;
+
+	return true;
+}
+
+/**
+ * nand_io_for_each_page - Iterate over all NAND pages contained in an MTD I/O
+ *			   request
+ * @nand: NAND device
+ * @start: start address to read/write from
+ * @req: MTD I/O request
+ * @iter: NAND I/O iterator
+ *
+ * Should be used for iterate over pages that are contained in an MTD request.
+ */
+#define nanddev_io_for_each_page(nand, start, req, iter)		\
+	for (nanddev_io_iter_init(nand, start, req, iter);		\
+	     !nanddev_io_iter_end(nand, iter);				\
+	     nanddev_io_iter_next_page(nand, iter))
+
+bool nanddev_isbad(struct nand_device *nand, const struct nand_pos *pos);
+bool nanddev_isreserved(struct nand_device *nand, const struct nand_pos *pos);
+int nanddev_erase(struct nand_device *nand, const struct nand_pos *pos);
+int nanddev_markbad(struct nand_device *nand, const struct nand_pos *pos);
+
+/* BBT related functions */
+enum nand_bbt_block_status {
+	NAND_BBT_BLOCK_STATUS_UNKNOWN,
+	NAND_BBT_BLOCK_GOOD,
+	NAND_BBT_BLOCK_WORN,
+	NAND_BBT_BLOCK_RESERVED,
+	NAND_BBT_BLOCK_FACTORY_BAD,
+	NAND_BBT_BLOCK_NUM_STATUS,
+};
+
+int nanddev_bbt_init(struct nand_device *nand);
+void nanddev_bbt_cleanup(struct nand_device *nand);
+int nanddev_bbt_update(struct nand_device *nand);
+int nanddev_bbt_get_block_status(const struct nand_device *nand,
+				 unsigned int entry);
+int nanddev_bbt_set_block_status(struct nand_device *nand, unsigned int entry,
+				 enum nand_bbt_block_status status);
+int nanddev_bbt_markbad(struct nand_device *nand, unsigned int block);
+
+/**
+ * nanddev_bbt_pos_to_entry() - Convert a NAND position into a BBT entry
+ * @nand: NAND device
+ * @pos: the NAND position we want to get BBT entry for
+ *
+ * Return the BBT entry used to store information about the eraseblock pointed
+ * by @pos.
+ *
+ * Return: the BBT entry storing information about eraseblock pointed by @pos.
+ */
+static inline unsigned int nanddev_bbt_pos_to_entry(struct nand_device *nand,
+						    const struct nand_pos *pos)
+{
+	return pos->eraseblock +
+	       ((pos->lun + (pos->target * nand->memorg.luns_per_target)) *
+		nand->memorg.eraseblocks_per_lun);
+}
+
+/**
+ * nanddev_bbt_is_initialized() - Check if the BBT has been initialized
+ * @nand: NAND device
+ *
+ * Return: true if the BBT has been initialized, false otherwise.
+ */
+static inline bool nanddev_bbt_is_initialized(struct nand_device *nand)
+{
+	return !!nand->bbt.cache;
+}
+
+/* MTD -> NAND helper functions. */
+int nanddev_mtd_erase(struct mtd_info *mtd, struct erase_info *einfo);
+
+#endif /* __LINUX_MTD_NAND_H */

commit d4092d76a4a4e57b65910899948a83cc8646c5a5
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Fri Aug 4 17:29:10 2017 +0200

    mtd: nand: Rename nand.h into rawnand.h
    
    We are planning to share more code between different NAND based
    devices (SPI NAND, OneNAND and raw NANDs), but before doing that
    we need to move the existing include/linux/mtd/nand.h file into
    include/linux/mtd/rawnand.h so we can later create a nand.h header
    containing all common structure and function prototypes.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Peter Pan <peterpandong@micron.com>
    Acked-by: Vladimir Zapolskiy <vz@mleia.com>
    Acked-by: Alexander Sverdlin <alexander.sverdlin@gmail.com>
    Acked-by: Wenyou Yang <wenyou.yang@microchip.com>
    Acked-by: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Han Xu <han.xu@nxp.com>
    Acked-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-By: Harvey Hunt <harveyhuntnexus@gmail.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Krzysztof Halasa <khalasa@piap.pl>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
deleted file mode 100644
index 892148c448cc..000000000000
--- a/include/linux/mtd/nand.h
+++ /dev/null
@@ -1,1331 +0,0 @@
-/*
- *  linux/include/linux/mtd/nand.h
- *
- *  Copyright © 2000-2010 David Woodhouse <dwmw2@infradead.org>
- *                        Steven J. Hill <sjhill@realitydiluted.com>
- *		          Thomas Gleixner <tglx@linutronix.de>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * Info:
- *	Contains standard defines and IDs for NAND flash devices
- *
- * Changelog:
- *	See git changelog.
- */
-#ifndef __LINUX_MTD_NAND_H
-#define __LINUX_MTD_NAND_H
-
-#include <linux/wait.h>
-#include <linux/spinlock.h>
-#include <linux/mtd/mtd.h>
-#include <linux/mtd/flashchip.h>
-#include <linux/mtd/bbm.h>
-
-struct mtd_info;
-struct nand_flash_dev;
-struct device_node;
-
-/* Scan and identify a NAND device */
-int nand_scan(struct mtd_info *mtd, int max_chips);
-/*
- * Separate phases of nand_scan(), allowing board driver to intervene
- * and override command or ECC setup according to flash type.
- */
-int nand_scan_ident(struct mtd_info *mtd, int max_chips,
-			   struct nand_flash_dev *table);
-int nand_scan_tail(struct mtd_info *mtd);
-
-/* Unregister the MTD device and free resources held by the NAND device */
-void nand_release(struct mtd_info *mtd);
-
-/* Internal helper for board drivers which need to override command function */
-void nand_wait_ready(struct mtd_info *mtd);
-
-/* locks all blocks present in the device */
-int nand_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
-
-/* unlocks specified locked blocks */
-int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
-
-/* The maximum number of NAND chips in an array */
-#define NAND_MAX_CHIPS		8
-
-/*
- * Constants for hardware specific CLE/ALE/NCE function
- *
- * These are bits which can be or'ed to set/clear multiple
- * bits in one go.
- */
-/* Select the chip by setting nCE to low */
-#define NAND_NCE		0x01
-/* Select the command latch by setting CLE to high */
-#define NAND_CLE		0x02
-/* Select the address latch by setting ALE to high */
-#define NAND_ALE		0x04
-
-#define NAND_CTRL_CLE		(NAND_NCE | NAND_CLE)
-#define NAND_CTRL_ALE		(NAND_NCE | NAND_ALE)
-#define NAND_CTRL_CHANGE	0x80
-
-/*
- * Standard NAND flash commands
- */
-#define NAND_CMD_READ0		0
-#define NAND_CMD_READ1		1
-#define NAND_CMD_RNDOUT		5
-#define NAND_CMD_PAGEPROG	0x10
-#define NAND_CMD_READOOB	0x50
-#define NAND_CMD_ERASE1		0x60
-#define NAND_CMD_STATUS		0x70
-#define NAND_CMD_SEQIN		0x80
-#define NAND_CMD_RNDIN		0x85
-#define NAND_CMD_READID		0x90
-#define NAND_CMD_ERASE2		0xd0
-#define NAND_CMD_PARAM		0xec
-#define NAND_CMD_GET_FEATURES	0xee
-#define NAND_CMD_SET_FEATURES	0xef
-#define NAND_CMD_RESET		0xff
-
-#define NAND_CMD_LOCK		0x2a
-#define NAND_CMD_UNLOCK1	0x23
-#define NAND_CMD_UNLOCK2	0x24
-
-/* Extended commands for large page devices */
-#define NAND_CMD_READSTART	0x30
-#define NAND_CMD_RNDOUTSTART	0xE0
-#define NAND_CMD_CACHEDPROG	0x15
-
-#define NAND_CMD_NONE		-1
-
-/* Status bits */
-#define NAND_STATUS_FAIL	0x01
-#define NAND_STATUS_FAIL_N1	0x02
-#define NAND_STATUS_TRUE_READY	0x20
-#define NAND_STATUS_READY	0x40
-#define NAND_STATUS_WP		0x80
-
-#define NAND_DATA_IFACE_CHECK_ONLY	-1
-
-/*
- * Constants for ECC_MODES
- */
-typedef enum {
-	NAND_ECC_NONE,
-	NAND_ECC_SOFT,
-	NAND_ECC_HW,
-	NAND_ECC_HW_SYNDROME,
-	NAND_ECC_HW_OOB_FIRST,
-	NAND_ECC_ON_DIE,
-} nand_ecc_modes_t;
-
-enum nand_ecc_algo {
-	NAND_ECC_UNKNOWN,
-	NAND_ECC_HAMMING,
-	NAND_ECC_BCH,
-};
-
-/*
- * Constants for Hardware ECC
- */
-/* Reset Hardware ECC for read */
-#define NAND_ECC_READ		0
-/* Reset Hardware ECC for write */
-#define NAND_ECC_WRITE		1
-/* Enable Hardware ECC before syndrome is read back from flash */
-#define NAND_ECC_READSYN	2
-
-/*
- * Enable generic NAND 'page erased' check. This check is only done when
- * ecc.correct() returns -EBADMSG.
- * Set this flag if your implementation does not fix bitflips in erased
- * pages and you want to rely on the default implementation.
- */
-#define NAND_ECC_GENERIC_ERASED_CHECK	BIT(0)
-#define NAND_ECC_MAXIMIZE		BIT(1)
-/*
- * If your controller already sends the required NAND commands when
- * reading or writing a page, then the framework is not supposed to
- * send READ0 and SEQIN/PAGEPROG respectively.
- */
-#define NAND_ECC_CUSTOM_PAGE_ACCESS	BIT(2)
-
-/* Bit mask for flags passed to do_nand_read_ecc */
-#define NAND_GET_DEVICE		0x80
-
-
-/*
- * Option constants for bizarre disfunctionality and real
- * features.
- */
-/* Buswidth is 16 bit */
-#define NAND_BUSWIDTH_16	0x00000002
-/* Chip has cache program function */
-#define NAND_CACHEPRG		0x00000008
-/*
- * Chip requires ready check on read (for auto-incremented sequential read).
- * True only for small page devices; large page devices do not support
- * autoincrement.
- */
-#define NAND_NEED_READRDY	0x00000100
-
-/* Chip does not allow subpage writes */
-#define NAND_NO_SUBPAGE_WRITE	0x00000200
-
-/* Device is one of 'new' xD cards that expose fake nand command set */
-#define NAND_BROKEN_XD		0x00000400
-
-/* Device behaves just like nand, but is readonly */
-#define NAND_ROM		0x00000800
-
-/* Device supports subpage reads */
-#define NAND_SUBPAGE_READ	0x00001000
-
-/*
- * Some MLC NANDs need data scrambling to limit bitflips caused by repeated
- * patterns.
- */
-#define NAND_NEED_SCRAMBLING	0x00002000
-
-/* Options valid for Samsung large page devices */
-#define NAND_SAMSUNG_LP_OPTIONS NAND_CACHEPRG
-
-/* Macros to identify the above */
-#define NAND_HAS_CACHEPROG(chip) ((chip->options & NAND_CACHEPRG))
-#define NAND_HAS_SUBPAGE_READ(chip) ((chip->options & NAND_SUBPAGE_READ))
-#define NAND_HAS_SUBPAGE_WRITE(chip) !((chip)->options & NAND_NO_SUBPAGE_WRITE)
-
-/* Non chip related options */
-/* This option skips the bbt scan during initialization. */
-#define NAND_SKIP_BBTSCAN	0x00010000
-/*
- * This option is defined if the board driver allocates its own buffers
- * (e.g. because it needs them DMA-coherent).
- */
-#define NAND_OWN_BUFFERS	0x00020000
-/* Chip may not exist, so silence any errors in scan */
-#define NAND_SCAN_SILENT_NODEV	0x00040000
-/*
- * Autodetect nand buswidth with readid/onfi.
- * This suppose the driver will configure the hardware in 8 bits mode
- * when calling nand_scan_ident, and update its configuration
- * before calling nand_scan_tail.
- */
-#define NAND_BUSWIDTH_AUTO      0x00080000
-/*
- * This option could be defined by controller drivers to protect against
- * kmap'ed, vmalloc'ed highmem buffers being passed from upper layers
- */
-#define NAND_USE_BOUNCE_BUFFER	0x00100000
-
-/*
- * In case your controller is implementing ->cmd_ctrl() and is relying on the
- * default ->cmdfunc() implementation, you may want to let the core handle the
- * tCCS delay which is required when a column change (RNDIN or RNDOUT) is
- * requested.
- * If your controller already takes care of this delay, you don't need to set
- * this flag.
- */
-#define NAND_WAIT_TCCS		0x00200000
-
-/* Options set by nand scan */
-/* Nand scan has allocated controller struct */
-#define NAND_CONTROLLER_ALLOC	0x80000000
-
-/* Cell info constants */
-#define NAND_CI_CHIPNR_MSK	0x03
-#define NAND_CI_CELLTYPE_MSK	0x0C
-#define NAND_CI_CELLTYPE_SHIFT	2
-
-/* Keep gcc happy */
-struct nand_chip;
-
-/* ONFI features */
-#define ONFI_FEATURE_16_BIT_BUS		(1 << 0)
-#define ONFI_FEATURE_EXT_PARAM_PAGE	(1 << 7)
-
-/* ONFI timing mode, used in both asynchronous and synchronous mode */
-#define ONFI_TIMING_MODE_0		(1 << 0)
-#define ONFI_TIMING_MODE_1		(1 << 1)
-#define ONFI_TIMING_MODE_2		(1 << 2)
-#define ONFI_TIMING_MODE_3		(1 << 3)
-#define ONFI_TIMING_MODE_4		(1 << 4)
-#define ONFI_TIMING_MODE_5		(1 << 5)
-#define ONFI_TIMING_MODE_UNKNOWN	(1 << 6)
-
-/* ONFI feature address */
-#define ONFI_FEATURE_ADDR_TIMING_MODE	0x1
-
-/* Vendor-specific feature address (Micron) */
-#define ONFI_FEATURE_ADDR_READ_RETRY	0x89
-#define ONFI_FEATURE_ON_DIE_ECC		0x90
-#define   ONFI_FEATURE_ON_DIE_ECC_EN	BIT(3)
-
-/* ONFI subfeature parameters length */
-#define ONFI_SUBFEATURE_PARAM_LEN	4
-
-/* ONFI optional commands SET/GET FEATURES supported? */
-#define ONFI_OPT_CMD_SET_GET_FEATURES	(1 << 2)
-
-struct nand_onfi_params {
-	/* rev info and features block */
-	/* 'O' 'N' 'F' 'I'  */
-	u8 sig[4];
-	__le16 revision;
-	__le16 features;
-	__le16 opt_cmd;
-	u8 reserved0[2];
-	__le16 ext_param_page_length; /* since ONFI 2.1 */
-	u8 num_of_param_pages;        /* since ONFI 2.1 */
-	u8 reserved1[17];
-
-	/* manufacturer information block */
-	char manufacturer[12];
-	char model[20];
-	u8 jedec_id;
-	__le16 date_code;
-	u8 reserved2[13];
-
-	/* memory organization block */
-	__le32 byte_per_page;
-	__le16 spare_bytes_per_page;
-	__le32 data_bytes_per_ppage;
-	__le16 spare_bytes_per_ppage;
-	__le32 pages_per_block;
-	__le32 blocks_per_lun;
-	u8 lun_count;
-	u8 addr_cycles;
-	u8 bits_per_cell;
-	__le16 bb_per_lun;
-	__le16 block_endurance;
-	u8 guaranteed_good_blocks;
-	__le16 guaranteed_block_endurance;
-	u8 programs_per_page;
-	u8 ppage_attr;
-	u8 ecc_bits;
-	u8 interleaved_bits;
-	u8 interleaved_ops;
-	u8 reserved3[13];
-
-	/* electrical parameter block */
-	u8 io_pin_capacitance_max;
-	__le16 async_timing_mode;
-	__le16 program_cache_timing_mode;
-	__le16 t_prog;
-	__le16 t_bers;
-	__le16 t_r;
-	__le16 t_ccs;
-	__le16 src_sync_timing_mode;
-	u8 src_ssync_features;
-	__le16 clk_pin_capacitance_typ;
-	__le16 io_pin_capacitance_typ;
-	__le16 input_pin_capacitance_typ;
-	u8 input_pin_capacitance_max;
-	u8 driver_strength_support;
-	__le16 t_int_r;
-	__le16 t_adl;
-	u8 reserved4[8];
-
-	/* vendor */
-	__le16 vendor_revision;
-	u8 vendor[88];
-
-	__le16 crc;
-} __packed;
-
-#define ONFI_CRC_BASE	0x4F4E
-
-/* Extended ECC information Block Definition (since ONFI 2.1) */
-struct onfi_ext_ecc_info {
-	u8 ecc_bits;
-	u8 codeword_size;
-	__le16 bb_per_lun;
-	__le16 block_endurance;
-	u8 reserved[2];
-} __packed;
-
-#define ONFI_SECTION_TYPE_0	0	/* Unused section. */
-#define ONFI_SECTION_TYPE_1	1	/* for additional sections. */
-#define ONFI_SECTION_TYPE_2	2	/* for ECC information. */
-struct onfi_ext_section {
-	u8 type;
-	u8 length;
-} __packed;
-
-#define ONFI_EXT_SECTION_MAX 8
-
-/* Extended Parameter Page Definition (since ONFI 2.1) */
-struct onfi_ext_param_page {
-	__le16 crc;
-	u8 sig[4];             /* 'E' 'P' 'P' 'S' */
-	u8 reserved0[10];
-	struct onfi_ext_section sections[ONFI_EXT_SECTION_MAX];
-
-	/*
-	 * The actual size of the Extended Parameter Page is in
-	 * @ext_param_page_length of nand_onfi_params{}.
-	 * The following are the variable length sections.
-	 * So we do not add any fields below. Please see the ONFI spec.
-	 */
-} __packed;
-
-struct jedec_ecc_info {
-	u8 ecc_bits;
-	u8 codeword_size;
-	__le16 bb_per_lun;
-	__le16 block_endurance;
-	u8 reserved[2];
-} __packed;
-
-/* JEDEC features */
-#define JEDEC_FEATURE_16_BIT_BUS	(1 << 0)
-
-struct nand_jedec_params {
-	/* rev info and features block */
-	/* 'J' 'E' 'S' 'D'  */
-	u8 sig[4];
-	__le16 revision;
-	__le16 features;
-	u8 opt_cmd[3];
-	__le16 sec_cmd;
-	u8 num_of_param_pages;
-	u8 reserved0[18];
-
-	/* manufacturer information block */
-	char manufacturer[12];
-	char model[20];
-	u8 jedec_id[6];
-	u8 reserved1[10];
-
-	/* memory organization block */
-	__le32 byte_per_page;
-	__le16 spare_bytes_per_page;
-	u8 reserved2[6];
-	__le32 pages_per_block;
-	__le32 blocks_per_lun;
-	u8 lun_count;
-	u8 addr_cycles;
-	u8 bits_per_cell;
-	u8 programs_per_page;
-	u8 multi_plane_addr;
-	u8 multi_plane_op_attr;
-	u8 reserved3[38];
-
-	/* electrical parameter block */
-	__le16 async_sdr_speed_grade;
-	__le16 toggle_ddr_speed_grade;
-	__le16 sync_ddr_speed_grade;
-	u8 async_sdr_features;
-	u8 toggle_ddr_features;
-	u8 sync_ddr_features;
-	__le16 t_prog;
-	__le16 t_bers;
-	__le16 t_r;
-	__le16 t_r_multi_plane;
-	__le16 t_ccs;
-	__le16 io_pin_capacitance_typ;
-	__le16 input_pin_capacitance_typ;
-	__le16 clk_pin_capacitance_typ;
-	u8 driver_strength_support;
-	__le16 t_adl;
-	u8 reserved4[36];
-
-	/* ECC and endurance block */
-	u8 guaranteed_good_blocks;
-	__le16 guaranteed_block_endurance;
-	struct jedec_ecc_info ecc_info[4];
-	u8 reserved5[29];
-
-	/* reserved */
-	u8 reserved6[148];
-
-	/* vendor */
-	__le16 vendor_rev_num;
-	u8 reserved7[88];
-
-	/* CRC for Parameter Page */
-	__le16 crc;
-} __packed;
-
-/**
- * struct nand_id - NAND id structure
- * @data: buffer containing the id bytes. Currently 8 bytes large, but can
- *	  be extended if required.
- * @len: ID length.
- */
-struct nand_id {
-	u8 data[8];
-	int len;
-};
-
-/**
- * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independent devices
- * @lock:               protection lock
- * @active:		the mtd device which holds the controller currently
- * @wq:			wait queue to sleep on if a NAND operation is in
- *			progress used instead of the per chip wait queue
- *			when a hw controller is available.
- */
-struct nand_hw_control {
-	spinlock_t lock;
-	struct nand_chip *active;
-	wait_queue_head_t wq;
-};
-
-static inline void nand_hw_control_init(struct nand_hw_control *nfc)
-{
-	nfc->active = NULL;
-	spin_lock_init(&nfc->lock);
-	init_waitqueue_head(&nfc->wq);
-}
-
-/**
- * struct nand_ecc_step_info - ECC step information of ECC engine
- * @stepsize: data bytes per ECC step
- * @strengths: array of supported strengths
- * @nstrengths: number of supported strengths
- */
-struct nand_ecc_step_info {
-	int stepsize;
-	const int *strengths;
-	int nstrengths;
-};
-
-/**
- * struct nand_ecc_caps - capability of ECC engine
- * @stepinfos: array of ECC step information
- * @nstepinfos: number of ECC step information
- * @calc_ecc_bytes: driver's hook to calculate ECC bytes per step
- */
-struct nand_ecc_caps {
-	const struct nand_ecc_step_info *stepinfos;
-	int nstepinfos;
-	int (*calc_ecc_bytes)(int step_size, int strength);
-};
-
-/* a shorthand to generate struct nand_ecc_caps with only one ECC stepsize */
-#define NAND_ECC_CAPS_SINGLE(__name, __calc, __step, ...)	\
-static const int __name##_strengths[] = { __VA_ARGS__ };	\
-static const struct nand_ecc_step_info __name##_stepinfo = {	\
-	.stepsize = __step,					\
-	.strengths = __name##_strengths,			\
-	.nstrengths = ARRAY_SIZE(__name##_strengths),		\
-};								\
-static const struct nand_ecc_caps __name = {			\
-	.stepinfos = &__name##_stepinfo,			\
-	.nstepinfos = 1,					\
-	.calc_ecc_bytes = __calc,				\
-}
-
-/**
- * struct nand_ecc_ctrl - Control structure for ECC
- * @mode:	ECC mode
- * @algo:	ECC algorithm
- * @steps:	number of ECC steps per page
- * @size:	data bytes per ECC step
- * @bytes:	ECC bytes per step
- * @strength:	max number of correctible bits per ECC step
- * @total:	total number of ECC bytes per page
- * @prepad:	padding information for syndrome based ECC generators
- * @postpad:	padding information for syndrome based ECC generators
- * @options:	ECC specific options (see NAND_ECC_XXX flags defined above)
- * @priv:	pointer to private ECC control data
- * @hwctl:	function to control hardware ECC generator. Must only
- *		be provided if an hardware ECC is available
- * @calculate:	function for ECC calculation or readback from ECC hardware
- * @correct:	function for ECC correction, matching to ECC generator (sw/hw).
- *		Should return a positive number representing the number of
- *		corrected bitflips, -EBADMSG if the number of bitflips exceed
- *		ECC strength, or any other error code if the error is not
- *		directly related to correction.
- *		If -EBADMSG is returned the input buffers should be left
- *		untouched.
- * @read_page_raw:	function to read a raw page without ECC. This function
- *			should hide the specific layout used by the ECC
- *			controller and always return contiguous in-band and
- *			out-of-band data even if they're not stored
- *			contiguously on the NAND chip (e.g.
- *			NAND_ECC_HW_SYNDROME interleaves in-band and
- *			out-of-band data).
- * @write_page_raw:	function to write a raw page without ECC. This function
- *			should hide the specific layout used by the ECC
- *			controller and consider the passed data as contiguous
- *			in-band and out-of-band data. ECC controller is
- *			responsible for doing the appropriate transformations
- *			to adapt to its specific layout (e.g.
- *			NAND_ECC_HW_SYNDROME interleaves in-band and
- *			out-of-band data).
- * @read_page:	function to read a page according to the ECC generator
- *		requirements; returns maximum number of bitflips corrected in
- *		any single ECC step, -EIO hw error
- * @read_subpage:	function to read parts of the page covered by ECC;
- *			returns same as read_page()
- * @write_subpage:	function to write parts of the page covered by ECC.
- * @write_page:	function to write a page according to the ECC generator
- *		requirements.
- * @write_oob_raw:	function to write chip OOB data without ECC
- * @read_oob_raw:	function to read chip OOB data without ECC
- * @read_oob:	function to read chip OOB data
- * @write_oob:	function to write chip OOB data
- */
-struct nand_ecc_ctrl {
-	nand_ecc_modes_t mode;
-	enum nand_ecc_algo algo;
-	int steps;
-	int size;
-	int bytes;
-	int total;
-	int strength;
-	int prepad;
-	int postpad;
-	unsigned int options;
-	void *priv;
-	void (*hwctl)(struct mtd_info *mtd, int mode);
-	int (*calculate)(struct mtd_info *mtd, const uint8_t *dat,
-			uint8_t *ecc_code);
-	int (*correct)(struct mtd_info *mtd, uint8_t *dat, uint8_t *read_ecc,
-			uint8_t *calc_ecc);
-	int (*read_page_raw)(struct mtd_info *mtd, struct nand_chip *chip,
-			uint8_t *buf, int oob_required, int page);
-	int (*write_page_raw)(struct mtd_info *mtd, struct nand_chip *chip,
-			const uint8_t *buf, int oob_required, int page);
-	int (*read_page)(struct mtd_info *mtd, struct nand_chip *chip,
-			uint8_t *buf, int oob_required, int page);
-	int (*read_subpage)(struct mtd_info *mtd, struct nand_chip *chip,
-			uint32_t offs, uint32_t len, uint8_t *buf, int page);
-	int (*write_subpage)(struct mtd_info *mtd, struct nand_chip *chip,
-			uint32_t offset, uint32_t data_len,
-			const uint8_t *data_buf, int oob_required, int page);
-	int (*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
-			const uint8_t *buf, int oob_required, int page);
-	int (*write_oob_raw)(struct mtd_info *mtd, struct nand_chip *chip,
-			int page);
-	int (*read_oob_raw)(struct mtd_info *mtd, struct nand_chip *chip,
-			int page);
-	int (*read_oob)(struct mtd_info *mtd, struct nand_chip *chip, int page);
-	int (*write_oob)(struct mtd_info *mtd, struct nand_chip *chip,
-			int page);
-};
-
-static inline int nand_standard_page_accessors(struct nand_ecc_ctrl *ecc)
-{
-	return !(ecc->options & NAND_ECC_CUSTOM_PAGE_ACCESS);
-}
-
-/**
- * struct nand_buffers - buffer structure for read/write
- * @ecccalc:	buffer pointer for calculated ECC, size is oobsize.
- * @ecccode:	buffer pointer for ECC read from flash, size is oobsize.
- * @databuf:	buffer pointer for data, size is (page size + oobsize).
- *
- * Do not change the order of buffers. databuf and oobrbuf must be in
- * consecutive order.
- */
-struct nand_buffers {
-	uint8_t	*ecccalc;
-	uint8_t	*ecccode;
-	uint8_t *databuf;
-};
-
-/**
- * struct nand_sdr_timings - SDR NAND chip timings
- *
- * This struct defines the timing requirements of a SDR NAND chip.
- * These information can be found in every NAND datasheets and the timings
- * meaning are described in the ONFI specifications:
- * www.onfi.org/~/media/ONFI/specs/onfi_3_1_spec.pdf (chapter 4.15 Timing
- * Parameters)
- *
- * All these timings are expressed in picoseconds.
- *
- * @tBERS_max: Block erase time
- * @tCCS_min: Change column setup time
- * @tPROG_max: Page program time
- * @tR_max: Page read time
- * @tALH_min: ALE hold time
- * @tADL_min: ALE to data loading time
- * @tALS_min: ALE setup time
- * @tAR_min: ALE to RE# delay
- * @tCEA_max: CE# access time
- * @tCEH_min: CE# high hold time
- * @tCH_min:  CE# hold time
- * @tCHZ_max: CE# high to output hi-Z
- * @tCLH_min: CLE hold time
- * @tCLR_min: CLE to RE# delay
- * @tCLS_min: CLE setup time
- * @tCOH_min: CE# high to output hold
- * @tCS_min: CE# setup time
- * @tDH_min: Data hold time
- * @tDS_min: Data setup time
- * @tFEAT_max: Busy time for Set Features and Get Features
- * @tIR_min: Output hi-Z to RE# low
- * @tITC_max: Interface and Timing Mode Change time
- * @tRC_min: RE# cycle time
- * @tREA_max: RE# access time
- * @tREH_min: RE# high hold time
- * @tRHOH_min: RE# high to output hold
- * @tRHW_min: RE# high to WE# low
- * @tRHZ_max: RE# high to output hi-Z
- * @tRLOH_min: RE# low to output hold
- * @tRP_min: RE# pulse width
- * @tRR_min: Ready to RE# low (data only)
- * @tRST_max: Device reset time, measured from the falling edge of R/B# to the
- *	      rising edge of R/B#.
- * @tWB_max: WE# high to SR[6] low
- * @tWC_min: WE# cycle time
- * @tWH_min: WE# high hold time
- * @tWHR_min: WE# high to RE# low
- * @tWP_min: WE# pulse width
- * @tWW_min: WP# transition to WE# low
- */
-struct nand_sdr_timings {
-	u32 tBERS_max;
-	u32 tCCS_min;
-	u32 tPROG_max;
-	u32 tR_max;
-	u32 tALH_min;
-	u32 tADL_min;
-	u32 tALS_min;
-	u32 tAR_min;
-	u32 tCEA_max;
-	u32 tCEH_min;
-	u32 tCH_min;
-	u32 tCHZ_max;
-	u32 tCLH_min;
-	u32 tCLR_min;
-	u32 tCLS_min;
-	u32 tCOH_min;
-	u32 tCS_min;
-	u32 tDH_min;
-	u32 tDS_min;
-	u32 tFEAT_max;
-	u32 tIR_min;
-	u32 tITC_max;
-	u32 tRC_min;
-	u32 tREA_max;
-	u32 tREH_min;
-	u32 tRHOH_min;
-	u32 tRHW_min;
-	u32 tRHZ_max;
-	u32 tRLOH_min;
-	u32 tRP_min;
-	u32 tRR_min;
-	u64 tRST_max;
-	u32 tWB_max;
-	u32 tWC_min;
-	u32 tWH_min;
-	u32 tWHR_min;
-	u32 tWP_min;
-	u32 tWW_min;
-};
-
-/**
- * enum nand_data_interface_type - NAND interface timing type
- * @NAND_SDR_IFACE:	Single Data Rate interface
- */
-enum nand_data_interface_type {
-	NAND_SDR_IFACE,
-};
-
-/**
- * struct nand_data_interface - NAND interface timing
- * @type:	type of the timing
- * @timings:	The timing, type according to @type
- */
-struct nand_data_interface {
-	enum nand_data_interface_type type;
-	union {
-		struct nand_sdr_timings sdr;
-	} timings;
-};
-
-/**
- * nand_get_sdr_timings - get SDR timing from data interface
- * @conf:	The data interface
- */
-static inline const struct nand_sdr_timings *
-nand_get_sdr_timings(const struct nand_data_interface *conf)
-{
-	if (conf->type != NAND_SDR_IFACE)
-		return ERR_PTR(-EINVAL);
-
-	return &conf->timings.sdr;
-}
-
-/**
- * struct nand_manufacturer_ops - NAND Manufacturer operations
- * @detect: detect the NAND memory organization and capabilities
- * @init: initialize all vendor specific fields (like the ->read_retry()
- *	  implementation) if any.
- * @cleanup: the ->init() function may have allocated resources, ->cleanup()
- *	     is here to let vendor specific code release those resources.
- */
-struct nand_manufacturer_ops {
-	void (*detect)(struct nand_chip *chip);
-	int (*init)(struct nand_chip *chip);
-	void (*cleanup)(struct nand_chip *chip);
-};
-
-/**
- * struct nand_chip - NAND Private Flash Chip Data
- * @mtd:		MTD device registered to the MTD framework
- * @IO_ADDR_R:		[BOARDSPECIFIC] address to read the 8 I/O lines of the
- *			flash device
- * @IO_ADDR_W:		[BOARDSPECIFIC] address to write the 8 I/O lines of the
- *			flash device.
- * @read_byte:		[REPLACEABLE] read one byte from the chip
- * @read_word:		[REPLACEABLE] read one word from the chip
- * @write_byte:		[REPLACEABLE] write a single byte to the chip on the
- *			low 8 I/O lines
- * @write_buf:		[REPLACEABLE] write data from the buffer to the chip
- * @read_buf:		[REPLACEABLE] read data from the chip into the buffer
- * @select_chip:	[REPLACEABLE] select chip nr
- * @block_bad:		[REPLACEABLE] check if a block is bad, using OOB markers
- * @block_markbad:	[REPLACEABLE] mark a block bad
- * @cmd_ctrl:		[BOARDSPECIFIC] hardwarespecific function for controlling
- *			ALE/CLE/nCE. Also used to write command and address
- * @dev_ready:		[BOARDSPECIFIC] hardwarespecific function for accessing
- *			device ready/busy line. If set to NULL no access to
- *			ready/busy is available and the ready/busy information
- *			is read from the chip status register.
- * @cmdfunc:		[REPLACEABLE] hardwarespecific function for writing
- *			commands to the chip.
- * @waitfunc:		[REPLACEABLE] hardwarespecific function for wait on
- *			ready.
- * @setup_read_retry:	[FLASHSPECIFIC] flash (vendor) specific function for
- *			setting the read-retry mode. Mostly needed for MLC NAND.
- * @ecc:		[BOARDSPECIFIC] ECC control structure
- * @buffers:		buffer structure for read/write
- * @buf_align:		minimum buffer alignment required by a platform
- * @hwcontrol:		platform-specific hardware control structure
- * @erase:		[REPLACEABLE] erase function
- * @scan_bbt:		[REPLACEABLE] function to scan bad block table
- * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transferring
- *			data from array to read regs (tR).
- * @state:		[INTERN] the current state of the NAND device
- * @oob_poi:		"poison value buffer," used for laying out OOB data
- *			before writing
- * @page_shift:		[INTERN] number of address bits in a page (column
- *			address bits).
- * @phys_erase_shift:	[INTERN] number of address bits in a physical eraseblock
- * @bbt_erase_shift:	[INTERN] number of address bits in a bbt entry
- * @chip_shift:		[INTERN] number of address bits in one chip
- * @options:		[BOARDSPECIFIC] various chip options. They can partly
- *			be set to inform nand_scan about special functionality.
- *			See the defines for further explanation.
- * @bbt_options:	[INTERN] bad block specific options. All options used
- *			here must come from bbm.h. By default, these options
- *			will be copied to the appropriate nand_bbt_descr's.
- * @badblockpos:	[INTERN] position of the bad block marker in the oob
- *			area.
- * @badblockbits:	[INTERN] minimum number of set bits in a good block's
- *			bad block marker position; i.e., BBM == 11110111b is
- *			not bad when badblockbits == 7
- * @bits_per_cell:	[INTERN] number of bits per cell. i.e., 1 means SLC.
- * @ecc_strength_ds:	[INTERN] ECC correctability from the datasheet.
- *			Minimum amount of bit errors per @ecc_step_ds guaranteed
- *			to be correctable. If unknown, set to zero.
- * @ecc_step_ds:	[INTERN] ECC step required by the @ecc_strength_ds,
- *			also from the datasheet. It is the recommended ECC step
- *			size, if known; if unknown, set to zero.
- * @onfi_timing_mode_default: [INTERN] default ONFI timing mode. This field is
- *			      set to the actually used ONFI mode if the chip is
- *			      ONFI compliant or deduced from the datasheet if
- *			      the NAND chip is not ONFI compliant.
- * @numchips:		[INTERN] number of physical chips
- * @chipsize:		[INTERN] the size of one chip for multichip arrays
- * @pagemask:		[INTERN] page number mask = number of (pages / chip) - 1
- * @pagebuf:		[INTERN] holds the pagenumber which is currently in
- *			data_buf.
- * @pagebuf_bitflips:	[INTERN] holds the bitflip count for the page which is
- *			currently in data_buf.
- * @subpagesize:	[INTERN] holds the subpagesize
- * @id:			[INTERN] holds NAND ID
- * @onfi_version:	[INTERN] holds the chip ONFI version (BCD encoded),
- *			non 0 if ONFI supported.
- * @jedec_version:	[INTERN] holds the chip JEDEC version (BCD encoded),
- *			non 0 if JEDEC supported.
- * @onfi_params:	[INTERN] holds the ONFI page parameter when ONFI is
- *			supported, 0 otherwise.
- * @jedec_params:	[INTERN] holds the JEDEC parameter page when JEDEC is
- *			supported, 0 otherwise.
- * @max_bb_per_die:	[INTERN] the max number of bad blocks each die of a
- *			this nand device will encounter their life times.
- * @blocks_per_die:	[INTERN] The number of PEBs in a die
- * @data_interface:	[INTERN] NAND interface timing information
- * @read_retries:	[INTERN] the number of read retry modes supported
- * @onfi_set_features:	[REPLACEABLE] set the features for ONFI nand
- * @onfi_get_features:	[REPLACEABLE] get the features for ONFI nand
- * @setup_data_interface: [OPTIONAL] setup the data interface and timing. If
- *			  chipnr is set to %NAND_DATA_IFACE_CHECK_ONLY this
- *			  means the configuration should not be applied but
- *			  only checked.
- * @bbt:		[INTERN] bad block table pointer
- * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash
- *			lookup.
- * @bbt_md:		[REPLACEABLE] bad block table mirror descriptor
- * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for initial
- *			bad block scan.
- * @controller:		[REPLACEABLE] a pointer to a hardware controller
- *			structure which is shared among multiple independent
- *			devices.
- * @priv:		[OPTIONAL] pointer to private chip data
- * @manufacturer:	[INTERN] Contains manufacturer information
- */
-
-struct nand_chip {
-	struct mtd_info mtd;
-	void __iomem *IO_ADDR_R;
-	void __iomem *IO_ADDR_W;
-
-	uint8_t (*read_byte)(struct mtd_info *mtd);
-	u16 (*read_word)(struct mtd_info *mtd);
-	void (*write_byte)(struct mtd_info *mtd, uint8_t byte);
-	void (*write_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
-	void (*read_buf)(struct mtd_info *mtd, uint8_t *buf, int len);
-	void (*select_chip)(struct mtd_info *mtd, int chip);
-	int (*block_bad)(struct mtd_info *mtd, loff_t ofs);
-	int (*block_markbad)(struct mtd_info *mtd, loff_t ofs);
-	void (*cmd_ctrl)(struct mtd_info *mtd, int dat, unsigned int ctrl);
-	int (*dev_ready)(struct mtd_info *mtd);
-	void (*cmdfunc)(struct mtd_info *mtd, unsigned command, int column,
-			int page_addr);
-	int(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this);
-	int (*erase)(struct mtd_info *mtd, int page);
-	int (*scan_bbt)(struct mtd_info *mtd);
-	int (*onfi_set_features)(struct mtd_info *mtd, struct nand_chip *chip,
-			int feature_addr, uint8_t *subfeature_para);
-	int (*onfi_get_features)(struct mtd_info *mtd, struct nand_chip *chip,
-			int feature_addr, uint8_t *subfeature_para);
-	int (*setup_read_retry)(struct mtd_info *mtd, int retry_mode);
-	int (*setup_data_interface)(struct mtd_info *mtd, int chipnr,
-				    const struct nand_data_interface *conf);
-
-
-	int chip_delay;
-	unsigned int options;
-	unsigned int bbt_options;
-
-	int page_shift;
-	int phys_erase_shift;
-	int bbt_erase_shift;
-	int chip_shift;
-	int numchips;
-	uint64_t chipsize;
-	int pagemask;
-	int pagebuf;
-	unsigned int pagebuf_bitflips;
-	int subpagesize;
-	uint8_t bits_per_cell;
-	uint16_t ecc_strength_ds;
-	uint16_t ecc_step_ds;
-	int onfi_timing_mode_default;
-	int badblockpos;
-	int badblockbits;
-
-	struct nand_id id;
-	int onfi_version;
-	int jedec_version;
-	union {
-		struct nand_onfi_params	onfi_params;
-		struct nand_jedec_params jedec_params;
-	};
-	u16 max_bb_per_die;
-	u32 blocks_per_die;
-
-	struct nand_data_interface *data_interface;
-
-	int read_retries;
-
-	flstate_t state;
-
-	uint8_t *oob_poi;
-	struct nand_hw_control *controller;
-
-	struct nand_ecc_ctrl ecc;
-	struct nand_buffers *buffers;
-	unsigned long buf_align;
-	struct nand_hw_control hwcontrol;
-
-	uint8_t *bbt;
-	struct nand_bbt_descr *bbt_td;
-	struct nand_bbt_descr *bbt_md;
-
-	struct nand_bbt_descr *badblock_pattern;
-
-	void *priv;
-
-	struct {
-		const struct nand_manufacturer *desc;
-		void *priv;
-	} manufacturer;
-};
-
-extern const struct mtd_ooblayout_ops nand_ooblayout_sp_ops;
-extern const struct mtd_ooblayout_ops nand_ooblayout_lp_ops;
-
-static inline void nand_set_flash_node(struct nand_chip *chip,
-				       struct device_node *np)
-{
-	mtd_set_of_node(&chip->mtd, np);
-}
-
-static inline struct device_node *nand_get_flash_node(struct nand_chip *chip)
-{
-	return mtd_get_of_node(&chip->mtd);
-}
-
-static inline struct nand_chip *mtd_to_nand(struct mtd_info *mtd)
-{
-	return container_of(mtd, struct nand_chip, mtd);
-}
-
-static inline struct mtd_info *nand_to_mtd(struct nand_chip *chip)
-{
-	return &chip->mtd;
-}
-
-static inline void *nand_get_controller_data(struct nand_chip *chip)
-{
-	return chip->priv;
-}
-
-static inline void nand_set_controller_data(struct nand_chip *chip, void *priv)
-{
-	chip->priv = priv;
-}
-
-static inline void nand_set_manufacturer_data(struct nand_chip *chip,
-					      void *priv)
-{
-	chip->manufacturer.priv = priv;
-}
-
-static inline void *nand_get_manufacturer_data(struct nand_chip *chip)
-{
-	return chip->manufacturer.priv;
-}
-
-/*
- * NAND Flash Manufacturer ID Codes
- */
-#define NAND_MFR_TOSHIBA	0x98
-#define NAND_MFR_ESMT		0xc8
-#define NAND_MFR_SAMSUNG	0xec
-#define NAND_MFR_FUJITSU	0x04
-#define NAND_MFR_NATIONAL	0x8f
-#define NAND_MFR_RENESAS	0x07
-#define NAND_MFR_STMICRO	0x20
-#define NAND_MFR_HYNIX		0xad
-#define NAND_MFR_MICRON		0x2c
-#define NAND_MFR_AMD		0x01
-#define NAND_MFR_MACRONIX	0xc2
-#define NAND_MFR_EON		0x92
-#define NAND_MFR_SANDISK	0x45
-#define NAND_MFR_INTEL		0x89
-#define NAND_MFR_ATO		0x9b
-#define NAND_MFR_WINBOND	0xef
-
-/* The maximum expected count of bytes in the NAND ID sequence */
-#define NAND_MAX_ID_LEN 8
-
-/*
- * A helper for defining older NAND chips where the second ID byte fully
- * defined the chip, including the geometry (chip size, eraseblock size, page
- * size). All these chips have 512 bytes NAND page size.
- */
-#define LEGACY_ID_NAND(nm, devid, chipsz, erasesz, opts)          \
-	{ .name = (nm), {{ .dev_id = (devid) }}, .pagesize = 512, \
-	  .chipsize = (chipsz), .erasesize = (erasesz), .options = (opts) }
-
-/*
- * A helper for defining newer chips which report their page size and
- * eraseblock size via the extended ID bytes.
- *
- * The real difference between LEGACY_ID_NAND and EXTENDED_ID_NAND is that with
- * EXTENDED_ID_NAND, manufacturers overloaded the same device ID so that the
- * device ID now only represented a particular total chip size (and voltage,
- * buswidth), and the page size, eraseblock size, and OOB size could vary while
- * using the same device ID.
- */
-#define EXTENDED_ID_NAND(nm, devid, chipsz, opts)                      \
-	{ .name = (nm), {{ .dev_id = (devid) }}, .chipsize = (chipsz), \
-	  .options = (opts) }
-
-#define NAND_ECC_INFO(_strength, _step)	\
-			{ .strength_ds = (_strength), .step_ds = (_step) }
-#define NAND_ECC_STRENGTH(type)		((type)->ecc.strength_ds)
-#define NAND_ECC_STEP(type)		((type)->ecc.step_ds)
-
-/**
- * struct nand_flash_dev - NAND Flash Device ID Structure
- * @name: a human-readable name of the NAND chip
- * @dev_id: the device ID (the second byte of the full chip ID array)
- * @mfr_id: manufecturer ID part of the full chip ID array (refers the same
- *          memory address as @id[0])
- * @dev_id: device ID part of the full chip ID array (refers the same memory
- *          address as @id[1])
- * @id: full device ID array
- * @pagesize: size of the NAND page in bytes; if 0, then the real page size (as
- *            well as the eraseblock size) is determined from the extended NAND
- *            chip ID array)
- * @chipsize: total chip size in MiB
- * @erasesize: eraseblock size in bytes (determined from the extended ID if 0)
- * @options: stores various chip bit options
- * @id_len: The valid length of the @id.
- * @oobsize: OOB size
- * @ecc: ECC correctability and step information from the datasheet.
- * @ecc.strength_ds: The ECC correctability from the datasheet, same as the
- *                   @ecc_strength_ds in nand_chip{}.
- * @ecc.step_ds: The ECC step required by the @ecc.strength_ds, same as the
- *               @ecc_step_ds in nand_chip{}, also from the datasheet.
- *               For example, the "4bit ECC for each 512Byte" can be set with
- *               NAND_ECC_INFO(4, 512).
- * @onfi_timing_mode_default: the default ONFI timing mode entered after a NAND
- *			      reset. Should be deduced from timings described
- *			      in the datasheet.
- *
- */
-struct nand_flash_dev {
-	char *name;
-	union {
-		struct {
-			uint8_t mfr_id;
-			uint8_t dev_id;
-		};
-		uint8_t id[NAND_MAX_ID_LEN];
-	};
-	unsigned int pagesize;
-	unsigned int chipsize;
-	unsigned int erasesize;
-	unsigned int options;
-	uint16_t id_len;
-	uint16_t oobsize;
-	struct {
-		uint16_t strength_ds;
-		uint16_t step_ds;
-	} ecc;
-	int onfi_timing_mode_default;
-};
-
-/**
- * struct nand_manufacturer - NAND Flash Manufacturer structure
- * @name:	Manufacturer name
- * @id:		manufacturer ID code of device.
- * @ops:	manufacturer operations
-*/
-struct nand_manufacturer {
-	int id;
-	char *name;
-	const struct nand_manufacturer_ops *ops;
-};
-
-const struct nand_manufacturer *nand_get_manufacturer(u8 id);
-
-static inline const char *
-nand_manufacturer_name(const struct nand_manufacturer *manufacturer)
-{
-	return manufacturer ? manufacturer->name : "Unknown";
-}
-
-extern struct nand_flash_dev nand_flash_ids[];
-
-extern const struct nand_manufacturer_ops toshiba_nand_manuf_ops;
-extern const struct nand_manufacturer_ops samsung_nand_manuf_ops;
-extern const struct nand_manufacturer_ops hynix_nand_manuf_ops;
-extern const struct nand_manufacturer_ops micron_nand_manuf_ops;
-extern const struct nand_manufacturer_ops amd_nand_manuf_ops;
-extern const struct nand_manufacturer_ops macronix_nand_manuf_ops;
-
-int nand_default_bbt(struct mtd_info *mtd);
-int nand_markbad_bbt(struct mtd_info *mtd, loff_t offs);
-int nand_isreserved_bbt(struct mtd_info *mtd, loff_t offs);
-int nand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt);
-int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
-		    int allowbbt);
-int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
-		 size_t *retlen, uint8_t *buf);
-
-/**
- * struct platform_nand_chip - chip level device structure
- * @nr_chips:		max. number of chips to scan for
- * @chip_offset:	chip number offset
- * @nr_partitions:	number of partitions pointed to by partitions (or zero)
- * @partitions:		mtd partition list
- * @chip_delay:		R/B delay value in us
- * @options:		Option flags, e.g. 16bit buswidth
- * @bbt_options:	BBT option flags, e.g. NAND_BBT_USE_FLASH
- * @part_probe_types:	NULL-terminated array of probe types
- */
-struct platform_nand_chip {
-	int nr_chips;
-	int chip_offset;
-	int nr_partitions;
-	struct mtd_partition *partitions;
-	int chip_delay;
-	unsigned int options;
-	unsigned int bbt_options;
-	const char **part_probe_types;
-};
-
-/* Keep gcc happy */
-struct platform_device;
-
-/**
- * struct platform_nand_ctrl - controller level device structure
- * @probe:		platform specific function to probe/setup hardware
- * @remove:		platform specific function to remove/teardown hardware
- * @hwcontrol:		platform specific hardware control structure
- * @dev_ready:		platform specific function to read ready/busy pin
- * @select_chip:	platform specific chip select function
- * @cmd_ctrl:		platform specific function for controlling
- *			ALE/CLE/nCE. Also used to write command and address
- * @write_buf:		platform specific function for write buffer
- * @read_buf:		platform specific function for read buffer
- * @read_byte:		platform specific function to read one byte from chip
- * @priv:		private data to transport driver specific settings
- *
- * All fields are optional and depend on the hardware driver requirements
- */
-struct platform_nand_ctrl {
-	int (*probe)(struct platform_device *pdev);
-	void (*remove)(struct platform_device *pdev);
-	void (*hwcontrol)(struct mtd_info *mtd, int cmd);
-	int (*dev_ready)(struct mtd_info *mtd);
-	void (*select_chip)(struct mtd_info *mtd, int chip);
-	void (*cmd_ctrl)(struct mtd_info *mtd, int dat, unsigned int ctrl);
-	void (*write_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
-	void (*read_buf)(struct mtd_info *mtd, uint8_t *buf, int len);
-	unsigned char (*read_byte)(struct mtd_info *mtd);
-	void *priv;
-};
-
-/**
- * struct platform_nand_data - container structure for platform-specific data
- * @chip:		chip level chip structure
- * @ctrl:		controller level device structure
- */
-struct platform_nand_data {
-	struct platform_nand_chip chip;
-	struct platform_nand_ctrl ctrl;
-};
-
-/* return the supported features. */
-static inline int onfi_feature(struct nand_chip *chip)
-{
-	return chip->onfi_version ? le16_to_cpu(chip->onfi_params.features) : 0;
-}
-
-/* return the supported asynchronous timing mode. */
-static inline int onfi_get_async_timing_mode(struct nand_chip *chip)
-{
-	if (!chip->onfi_version)
-		return ONFI_TIMING_MODE_UNKNOWN;
-	return le16_to_cpu(chip->onfi_params.async_timing_mode);
-}
-
-/* return the supported synchronous timing mode. */
-static inline int onfi_get_sync_timing_mode(struct nand_chip *chip)
-{
-	if (!chip->onfi_version)
-		return ONFI_TIMING_MODE_UNKNOWN;
-	return le16_to_cpu(chip->onfi_params.src_sync_timing_mode);
-}
-
-int onfi_init_data_interface(struct nand_chip *chip,
-			     struct nand_data_interface *iface,
-			     enum nand_data_interface_type type,
-			     int timing_mode);
-
-/*
- * Check if it is a SLC nand.
- * The !nand_is_slc() can be used to check the MLC/TLC nand chips.
- * We do not distinguish the MLC and TLC now.
- */
-static inline bool nand_is_slc(struct nand_chip *chip)
-{
-	return chip->bits_per_cell == 1;
-}
-
-/**
- * Check if the opcode's address should be sent only on the lower 8 bits
- * @command: opcode to check
- */
-static inline int nand_opcode_8bits(unsigned int command)
-{
-	switch (command) {
-	case NAND_CMD_READID:
-	case NAND_CMD_PARAM:
-	case NAND_CMD_GET_FEATURES:
-	case NAND_CMD_SET_FEATURES:
-		return 1;
-	default:
-		break;
-	}
-	return 0;
-}
-
-/* return the supported JEDEC features. */
-static inline int jedec_feature(struct nand_chip *chip)
-{
-	return chip->jedec_version ? le16_to_cpu(chip->jedec_params.features)
-		: 0;
-}
-
-/* get timing characteristics from ONFI timing mode. */
-const struct nand_sdr_timings *onfi_async_timing_mode_to_sdr_timings(int mode);
-/* get data interface from ONFI timing mode 0, used after reset. */
-const struct nand_data_interface *nand_get_default_data_interface(void);
-
-int nand_check_erased_ecc_chunk(void *data, int datalen,
-				void *ecc, int ecclen,
-				void *extraoob, int extraooblen,
-				int threshold);
-
-int nand_check_ecc_caps(struct nand_chip *chip,
-			const struct nand_ecc_caps *caps, int oobavail);
-
-int nand_match_ecc_req(struct nand_chip *chip,
-		       const struct nand_ecc_caps *caps,  int oobavail);
-
-int nand_maximize_ecc(struct nand_chip *chip,
-		      const struct nand_ecc_caps *caps, int oobavail);
-
-/* Default write_oob implementation */
-int nand_write_oob_std(struct mtd_info *mtd, struct nand_chip *chip, int page);
-
-/* Default write_oob syndrome implementation */
-int nand_write_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
-			    int page);
-
-/* Default read_oob implementation */
-int nand_read_oob_std(struct mtd_info *mtd, struct nand_chip *chip, int page);
-
-/* Default read_oob syndrome implementation */
-int nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
-			   int page);
-
-/* Stub used by drivers that do not support GET/SET FEATURES operations */
-int nand_onfi_get_set_features_notsupp(struct mtd_info *mtd,
-				       struct nand_chip *chip, int addr,
-				       u8 *subfeature_param);
-
-/* Default read_page_raw implementation */
-int nand_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
-		       uint8_t *buf, int oob_required, int page);
-
-/* Default write_page_raw implementation */
-int nand_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
-			const uint8_t *buf, int oob_required, int page);
-
-/* Reset and initialize a NAND device */
-int nand_reset(struct nand_chip *chip, int chipnr);
-
-/* Free resources held by the NAND device */
-void nand_cleanup(struct nand_chip *chip);
-
-/* Default extended ID decoding function */
-void nand_decode_ext_id(struct nand_chip *chip);
-#endif /* __LINUX_MTD_NAND_H */

commit b5e16170f59b4ae38937b795a56a356fb95cca56
Merge: da16dd9785f8 7d84120b5ba6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 13 12:07:44 2017 -0700

    Merge tag 'for-linus-20170713' of git://git.infradead.org/linux-mtd
    
    Pull MTD updates from Brian Norris:
     "General updates:
       - Cleanups and additional flash support for "dataflash" driver
       - new driver for mchp23k256 SPI SRAM device
       - improve handling of MTDs without eraseblocks (i.e., MTD_NO_ERASE)
       - refactor and improve "sub-partition" handling with TRX partition
         parser; partitions can now be created as sub-partitions of another
         partition
    
      SPINOR updates, from Cyrille Pitchen and Marek Vasut:
       - introduce support to the SPI 1-2-2 and 1-4-4 protocols.
       - introduce support to the Double Data Rate (DDR) mode.
       - introduce support to the Octo SPI protocols.
       - add support to new memory parts for Spansion, Macronix and Winbond.
       - add fixes for the Aspeed, STM32 and Cadence QSPI controler drivers.
       - clean up the st_spi_fsm driver.
    
      NAND updates, from Boris Brezillon:
       - addition of on-die ECC support to Micron driver
       - addition of helpers to help drivers choose most appropriate ECC
         settings
       - deletion of dead-code (cached programming and ->errstat() hook)
       - make sure drivers that do not support the SET/GET FEATURES command
         return ENOTSUPP use a dummy ->set/get_features implementation
         returning -ENOTSUPP (required for Micron on-die ECC)
       - change the semantic of ecc->write_page() for drivers setting the
         NAND_ECC_CUSTOM_PAGE_ACCESS flag
       - support exiting 'GET STATUS' command in default ->cmdfunc()
         implementations
       - change the prototype of ->setup_data_interface()
    
      A bunch of driver related changes:
       - various cleanup, fixes and improvements of the MTK driver
       - OMAP DT bindings fixes
       - support for ->setup_data_interface() in the fsmc driver
       - support for imx7 in the gpmi driver
       - finalization of the denali driver rework (thanks to Masahiro for
         the work he's done on this driver)
       - fix "bitflips in erased pages" handling in the ifc driver
       - addition of PM ops and dynamic timing configuration to the atmel
         driver"
    
    * tag 'for-linus-20170713' of git://git.infradead.org/linux-mtd: (118 commits)
      Documentation: ABI: mtd: describe "offset" more precisely
      mtd: Fix check in mtd_unpoint()
      mtd: nand: mtk: release lock on error path
      mtd: st_spi_fsm: remove SPINOR_OP_RDSR2 and use SPINOR_OP_RDCR instead
      mtd: spi-nor: cqspi: remove duplicate const
      mtd: spi-nor: Add support for Spansion S25FL064L
      mtd: spi-nor: Add support for mx66u51235f
      mtd: nand: mtk: add ->setup_data_interface() hook
      mtd: nand: mtk: remove unneeded mtk_ecc_hw_init from mtk_ecc_resume
      mtd: nand: mtk: remove unneeded mtk_nfc_hw_init from mtk_nfc_resume
      mtd: nand: mtk: disable ecc irq when writing page with hwecc
      mtd: nand: mtk: fix incorrect register setting order about ecc irq
      mtd: partitions: fixup some allocate_partition() whitespace
      mtd: parsers: trx: fix pr_err format for printing offset
      MAINTAINERS: Update SPI NOR subsystem git repositories
      mtd: extract TRX parser out of bcm47xxpart into a separated module
      mtd: partitions: add support for partition parsers
      mtd: partitions: add support for subpartitions
      mtd: partitions: rename "master" to the "parent" where appropriate
      mtd: partitions: remove sysfs files when deleting all master's partitions
      ...

commit a03c60178c181767ecfb26fb311a88742d228118
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed Jun 7 20:52:11 2017 +0900

    mtd: nand: add a shorthand to generate nand_ecc_caps structure
    
    struct nand_ecc_caps was designed as flexible as possible to support
    multiple stepsizes (like sunxi_nand.c).
    
    So, we need to write multiple arrays even for the simplest case.
    I guess many controllers support a single stepsize, so here is a
    shorthand macro for the case.
    
    It allows to describe like ...
    
    NAND_ECC_CAPS_SINGLE(denali_pci_ecc_caps, denali_calc_ecc_bytes, 512, 8, 15);
    
    ... instead of
    
    static const int denali_pci_ecc_strengths[] = {8, 15};
    static const struct nand_ecc_step_info denali_pci_ecc_stepinfo = {
            .stepsize = 512,
            .strengths = denali_pci_ecc_strengths,
            .nstrengths = ARRAY_SIZE(denali_pci_ecc_strengths),
    };
    static const struct nand_ecc_caps denali_pci_ecc_caps = {
            .stepinfos = &denali_pci_ecc_stepinfo,
            .nstepinfos = 1,
            .calc_ecc_bytes = denali_calc_ecc_bytes,
    };
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 568f53e812cd..dc8fbc033442 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -505,6 +505,20 @@ struct nand_ecc_caps {
 	int (*calc_ecc_bytes)(int step_size, int strength);
 };
 
+/* a shorthand to generate struct nand_ecc_caps with only one ECC stepsize */
+#define NAND_ECC_CAPS_SINGLE(__name, __calc, __step, ...)	\
+static const int __name##_strengths[] = { __VA_ARGS__ };	\
+static const struct nand_ecc_step_info __name##_stepinfo = {	\
+	.stepsize = __step,					\
+	.strengths = __name##_strengths,			\
+	.nstrengths = ARRAY_SIZE(__name##_strengths),		\
+};								\
+static const struct nand_ecc_caps __name = {			\
+	.stepinfos = &__name##_stepinfo,			\
+	.nstepinfos = 1,					\
+	.calc_ecc_bytes = __calc,				\
+}
+
 /**
  * struct nand_ecc_ctrl - Control structure for ECC
  * @mode:	ECC mode

commit 2c8f8afa7f92acb07641bf95b940d384ed1d0294
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed Jun 7 20:52:10 2017 +0900

    mtd: nand: add generic helpers to check, match, maximize ECC settings
    
    Driver are responsible for setting up ECC parameters correctly.
    Those include:
      - Check if ECC parameters specified (usually by DT) are valid
      - Meet the chip's ECC requirement
      - Maximize ECC strength if NAND_ECC_MAXIMIZE flag is set
    
    The logic can be generalized by factoring out common code.
    
    This commit adds 3 helpers to the NAND framework:
    nand_check_ecc_caps - Check if preset step_size and strength are valid
    nand_match_ecc_req - Match the chip's requirement
    nand_maximize_ecc - Maximize the ECC strength
    
    To use the helpers above, a driver needs to provide:
      - Data array of supported ECC step size and strength
      - A hook that calculates ECC bytes from the combination of
        step_size and strength.
    
    By using those helpers, code duplication among drivers will be
    reduced.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 8b3607bde1b5..568f53e812cd 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -481,6 +481,30 @@ static inline void nand_hw_control_init(struct nand_hw_control *nfc)
 	init_waitqueue_head(&nfc->wq);
 }
 
+/**
+ * struct nand_ecc_step_info - ECC step information of ECC engine
+ * @stepsize: data bytes per ECC step
+ * @strengths: array of supported strengths
+ * @nstrengths: number of supported strengths
+ */
+struct nand_ecc_step_info {
+	int stepsize;
+	const int *strengths;
+	int nstrengths;
+};
+
+/**
+ * struct nand_ecc_caps - capability of ECC engine
+ * @stepinfos: array of ECC step information
+ * @nstepinfos: number of ECC step information
+ * @calc_ecc_bytes: driver's hook to calculate ECC bytes per step
+ */
+struct nand_ecc_caps {
+	const struct nand_ecc_step_info *stepinfos;
+	int nstepinfos;
+	int (*calc_ecc_bytes)(int step_size, int strength);
+};
+
 /**
  * struct nand_ecc_ctrl - Control structure for ECC
  * @mode:	ECC mode
@@ -1246,6 +1270,15 @@ int nand_check_erased_ecc_chunk(void *data, int datalen,
 				void *extraoob, int extraooblen,
 				int threshold);
 
+int nand_check_ecc_caps(struct nand_chip *chip,
+			const struct nand_ecc_caps *caps, int oobavail);
+
+int nand_match_ecc_req(struct nand_chip *chip,
+		       const struct nand_ecc_caps *caps,  int oobavail);
+
+int nand_maximize_ecc(struct nand_chip *chip,
+		      const struct nand_ecc_caps *caps, int oobavail);
+
 /* Default write_oob implementation */
 int nand_write_oob_std(struct mtd_info *mtd, struct nand_chip *chip, int page);
 

commit 7d135bcced20be2b50128432c5426a7278ec4f6d
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Sat May 6 18:03:33 2017 +0200

    mtd: nand: Drop the ->errstat() hook
    
    The ->errstat() hook is no longer implemented NAND controller drivers.
    Get rid of it before someone starts abusing it.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 9de3686e738c..8b3607bde1b5 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -834,9 +834,6 @@ struct nand_manufacturer_ops {
  *			structure which is shared among multiple independent
  *			devices.
  * @priv:		[OPTIONAL] pointer to private chip data
- * @errstat:		[OPTIONAL] hardware specific function to perform
- *			additional error status checks (determine if errors are
- *			correctable).
  * @manufacturer:	[INTERN] Contains manufacturer information
  */
 
@@ -860,8 +857,6 @@ struct nand_chip {
 	int(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this);
 	int (*erase)(struct mtd_info *mtd, int page);
 	int (*scan_bbt)(struct mtd_info *mtd);
-	int (*errstat)(struct mtd_info *mtd, struct nand_chip *this, int state,
-			int status, int page);
 	int (*onfi_set_features)(struct mtd_info *mtd, struct nand_chip *chip,
 			int feature_addr, uint8_t *subfeature_para);
 	int (*onfi_get_features)(struct mtd_info *mtd, struct nand_chip *chip,

commit 104e442a67cfba4d0cc982384761befb917fb6a1
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Thu Mar 16 09:35:58 2017 +0100

    mtd: nand: Pass the CS line to ->setup_data_interface()
    
    Some NAND controllers can assign different NAND timings to different
    CS lines. Pass the CS line information to ->setup_data_interface() so
    that the NAND controller driver knows which CS line is concerned by
    the setup_data_interface() request.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 893d0ce08030..9de3686e738c 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -107,6 +107,8 @@ int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
 #define NAND_STATUS_READY	0x40
 #define NAND_STATUS_WP		0x80
 
+#define NAND_DATA_IFACE_CHECK_ONLY	-1
+
 /*
  * Constants for ECC_MODES
  */
@@ -818,7 +820,10 @@ struct nand_manufacturer_ops {
  * @read_retries:	[INTERN] the number of read retry modes supported
  * @onfi_set_features:	[REPLACEABLE] set the features for ONFI nand
  * @onfi_get_features:	[REPLACEABLE] get the features for ONFI nand
- * @setup_data_interface: [OPTIONAL] setup the data interface and timing
+ * @setup_data_interface: [OPTIONAL] setup the data interface and timing. If
+ *			  chipnr is set to %NAND_DATA_IFACE_CHECK_ONLY this
+ *			  means the configuration should not be applied but
+ *			  only checked.
  * @bbt:		[INTERN] bad block table pointer
  * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash
  *			lookup.
@@ -862,9 +867,8 @@ struct nand_chip {
 	int (*onfi_get_features)(struct mtd_info *mtd, struct nand_chip *chip,
 			int feature_addr, uint8_t *subfeature_para);
 	int (*setup_read_retry)(struct mtd_info *mtd, int retry_mode);
-	int (*setup_data_interface)(struct mtd_info *mtd,
-				    const struct nand_data_interface *conf,
-				    bool check_only);
+	int (*setup_data_interface)(struct mtd_info *mtd, int chipnr,
+				    const struct nand_data_interface *conf);
 
 
 	int chip_delay;

commit 9748e1d87573c94191442d6bd0307f523e5cd8b8
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Sat Apr 29 11:06:45 2017 +0200

    mtd: nand: add support for Micron on-die ECC
    
    Now that the core NAND subsystem has support for on-die ECC, this commit
    brings the necessary code to support on-die ECC on Micron NANDs.
    
    In micron_nand_init(), we detect if the Micron NAND chip supports on-die
    ECC mode, by checking a number of conditions:
    
     - It must be an ONFI NAND
     - It must be a SLC NAND
    
     - Enabling *and* disabling on-die ECC must work
    
     - The on-die ECC must be correcting 4 bits per 512 bytes of data. Some
       Micron NAND chips have an on-die ECC able to correct 8 bits per 512
       bytes of data, but they work slightly differently and therefore we
       don't support them in this patch.
    
    Then, if the on-die ECC cannot be disabled (some Micron NAND have on-die
    ECC forcefully enabled), we bail out, as we don't support such
    NANDs. Indeed, the implementation of raw_read()/raw_write() make the
    assumption that on-die ECC can be disabled. Support for Micron NANDs
    with on-die ECC forcefully enabled can easily be added, but in the
    absence of such HW for testing, we preferred to simply bail out.
    
    If the on-die ECC is supported, and requested in the Device Tree, then
    it is indeed enabled, by using custom implementations of the
    ->read_page(), ->read_page_raw(), ->write_page() and ->write_page_raw()
    operation to properly handle the on-die ECC.
    
    In the non-raw functions, we need to enable the internal ECC engine
    before issuing the NAND_CMD_READ0 or NAND_CMD_SEQIN commands, which is
    why we set the NAND_ECC_CUSTOM_PAGE_ACCESS option at initialization
    time (it asks the NAND core to let the NAND driver issue those
    commands).
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 28f7dd9177e9..893d0ce08030 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -258,6 +258,8 @@ struct nand_chip;
 
 /* Vendor-specific feature address (Micron) */
 #define ONFI_FEATURE_ADDR_READ_RETRY	0x89
+#define ONFI_FEATURE_ON_DIE_ECC		0x90
+#define   ONFI_FEATURE_ON_DIE_ECC_EN	BIT(3)
 
 /* ONFI subfeature parameters length */
 #define ONFI_SUBFEATURE_PARAM_LEN	4

commit 4a78cc644eed3cf2dae00c3a959910a86c140fd6
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Fri May 26 17:10:15 2017 +0200

    mtd: nand: Make sure drivers not supporting SET/GET_FEATURES return -ENOTSUPP
    
    A lot of drivers are providing their own ->cmdfunc(), and most of the
    time this implementation does not support all possible NAND operations.
    But since ->cmdfunc() cannot return an error code, the core has no way
    to know that the operation it requested is not supported.
    
    This is a problem we cannot address for all kind of operations with the
    current design, but we can prevent these silent failures for the
    GET/SET FEATURES operation by overloading the default
    ->onfi_{set,get}_features() methods with one returning -ENOTSUPP.
    
    Reported-by: Chris Packham <Chris.Packham@alliedtelesis.co.nz>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Tested-by: Chris Packham <Chris.Packham@alliedtelesis.co.nz>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 7a01d2eb7443..28f7dd9177e9 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -1259,6 +1259,11 @@ int nand_read_oob_std(struct mtd_info *mtd, struct nand_chip *chip, int page);
 int nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
 			   int page);
 
+/* Stub used by drivers that do not support GET/SET FEATURES operations */
+int nand_onfi_get_set_features_notsupp(struct mtd_info *mtd,
+				       struct nand_chip *chip, int addr,
+				       u8 *subfeature_param);
+
 /* Default read_page_raw implementation */
 int nand_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
 		       uint8_t *buf, int oob_required, int page);

commit 6312811be26f4a97fb36f53ffffafa5086833a28
Merge: 468f8763fea1 5d47c31b59f6
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Thu May 18 11:03:08 2017 -0600

    Merge remote-tracking branch 'mauro-exp/docbook3' into death-to-docbook
    
    Mauro says:
    
    This patch series convert the remaining DocBooks to ReST.
    
    The first version was originally
    send as 3 patch series:
    
       [PATCH 00/36] Convert DocBook documents to ReST
       [PATCH 0/5] Convert more books to ReST
       [PATCH 00/13] Get rid of DocBook
    
    The lsm book was added as if it were a text file under
    Documentation. The plan is to merge it with another file
    under Documentation/security, after both this series and
    a security Documentation patch series gets merged.
    
    It also adjusts some Sphinx-pedantic errors/warnings on
    some kernel-doc markups.
    
    I also added some patches here to add PDF output for all
    existing ReST books.

commit b6f6c29454d236e85f2912cb0f9366825ca1b0be
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Sat May 13 07:40:36 2017 -0300

    mtd: adjust kernel-docs to avoid Sphinx/kerneldoc warnings
    
    ./drivers/mtd/nand/nand_bbt.c:1: warning: no structured comments found
    ./include/linux/mtd/nand.h:785: ERROR: Unexpected indentation.
    ./drivers/mtd/nand/nand_base.c:449: WARNING: Definition list ends without a blank line; unexpected unindent.
    ./drivers/mtd/nand/nand_base.c:1161: ERROR: Unexpected indentation.
    ./drivers/mtd/nand/nand_base.c:1162: WARNING: Block quote ends without a blank line; unexpected unindent.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 9591e0fbe5bd..3d5b20379ba3 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -779,7 +779,7 @@ nand_get_sdr_timings(const struct nand_data_interface *conf)
  *			Minimum amount of bit errors per @ecc_step_ds guaranteed
  *			to be correctable. If unknown, set to zero.
  * @ecc_step_ds:	[INTERN] ECC step required by the @ecc_strength_ds,
- *                      also from the datasheet. It is the recommended ECC step
+ *			also from the datasheet. It is the recommended ECC step
  *			size, if known; if unknown, set to zero.
  * @onfi_timing_mode_default: [INTERN] default ONFI timing mode. This field is
  *			      set to the actually used ONFI mode if the chip is

commit cc0f51ec111266f5d255e753bf3254ad411d5c12
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Sat Apr 29 11:06:44 2017 +0200

    mtd: nand: export nand_{read,write}_page_raw()
    
    The nand_read_page_raw() and nand_write_page_raw() functions might be
    re-used by vendor-specific implementations of the read_page/write_page
    functions. Instead of having vendor-specific code duplicate this code,
    it is much better to export those functions and allow them to be
    re-used.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Reviewed-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 603522097ec9..7a01d2eb7443 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -1259,6 +1259,14 @@ int nand_read_oob_std(struct mtd_info *mtd, struct nand_chip *chip, int page);
 int nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
 			   int page);
 
+/* Default read_page_raw implementation */
+int nand_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+		       uint8_t *buf, int oob_required, int page);
+
+/* Default write_page_raw implementation */
+int nand_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+			const uint8_t *buf, int oob_required, int page);
+
 /* Reset and initialize a NAND device */
 int nand_reset(struct nand_chip *chip, int chipnr);
 

commit 785818fa8385fe55dab253e42a4c6728fca61333
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Sat Apr 29 11:06:43 2017 +0200

    mtd: nand: add core support for on-die ECC
    
    A number of NAND flashes have a capability called "on-die ECC" where the
    NAND chip itself is capable of detecting and correcting errors.
    
    Linux already has support for using the ECC implementation of the NAND
    controller, or a software based ECC implementation, but not for using
    the ECC implementation of the NAND controller. However, such an
    implementation is sometimes useful in situations where the NAND
    controller provides ECC algorithms that are not strong enough for the
    NAND chip used on the system. A typical case is a NAND chip that
    requires a 4-bit ECC, while the NAND controller only provides a 1-bit
    ECC algorithm.
    
    This commit introduces the support for the NAND_ECC_ON_DIE ECC mode:
    
     - Parsing of the "on-die" value for the "nand-ecc-mode" Device Tree
       property
    
     - Handling NAND_ECC_ON_DIE case in nand_scan_tail(). The idea is that
       the vendor specific code for the NAND chip must implement
       ->read_page() and ->write_page(). It may optionally provide its own
       ->read_page_raw() and ->write_page_raw() as well. For OOB operation,
       we assume the standard operations are good enough, but they can be
       overridden by the vendor specific code if needed.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Reviewed-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 8f67b1581683..603522097ec9 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -116,6 +116,7 @@ typedef enum {
 	NAND_ECC_HW,
 	NAND_ECC_HW_SYNDROME,
 	NAND_ECC_HW_OOB_FIRST,
+	NAND_ECC_ON_DIE,
 } nand_ecc_modes_t;
 
 enum nand_ecc_algo {

commit 477544c62a84d3bacd9f90ba75ffc16c04d78071
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Mar 30 17:15:05 2017 +0900

    mtd: nand: allow drivers to request minimum alignment for passed buffer
    
    In some cases, nand_do_{read,write}_ops is passed with unaligned
    ops->datbuf.  Drivers using DMA will be unhappy about unaligned
    buffer.
    
    The new struct member, buf_align, represents the minimum alignment
    the driver require for the buffer.  If the buffer passed from the
    upper MTD layer does not have enough alignment, nand_do_*_ops will
    use bufpoi.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 9e0c93c44bef..8f67b1581683 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -755,6 +755,7 @@ struct nand_manufacturer_ops {
  *			setting the read-retry mode. Mostly needed for MLC NAND.
  * @ecc:		[BOARDSPECIFIC] ECC control structure
  * @buffers:		buffer structure for read/write
+ * @buf_align:		minimum buffer alignment required by a platform
  * @hwcontrol:		platform-specific hardware control structure
  * @erase:		[REPLACEABLE] erase function
  * @scan_bbt:		[REPLACEABLE] function to scan bad block table
@@ -905,6 +906,7 @@ struct nand_chip {
 
 	struct nand_ecc_ctrl ecc;
 	struct nand_buffers *buffers;
+	unsigned long buf_align;
 	struct nand_hw_control hwcontrol;
 
 	uint8_t *bbt;

commit 07604686e808cd93d352172806a7828860f048f5
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Mar 30 15:45:47 2017 +0900

    mtd: nand: relax ecc.read_page() return value for uncorrectable ECC
    
    The comment for ecc.read_page() requires that it should return
    "0 if bitflips uncorrectable".
    
    Actually, drivers could return positive values when uncorrectable
    bitflips occur.  For example, nand_read_page_swecc() is the case.
    If ecc.correct() returns -EBADMSG for the first ECC sector, and
    a positive value for the second one, nand_read_page_swecc() returns
    a positive max_bitflips and increments ecc_stats.failed for the same
    page.
    
    The requirement can be relaxed by tweaking nand_do_read_ops().
    Move the max_bitflips calculation below the retry.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Suggested-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 40657939797c..9e0c93c44bef 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -516,7 +516,7 @@ static inline void nand_hw_control_init(struct nand_hw_control *nfc)
  *			out-of-band data).
  * @read_page:	function to read a page according to the ECC generator
  *		requirements; returns maximum number of bitflips corrected in
- *		any single ECC step, 0 if bitflips uncorrectable, -EIO hw error
+ *		any single ECC step, -EIO hw error
  * @read_subpage:	function to read parts of the page covered by ECC;
  *			returns same as read_page()
  * @write_subpage:	function to write parts of the page covered by ECC.

commit f107d7a43923a83d837b3ea3c7b7de58cd014bbd
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Thu Mar 16 09:02:42 2017 +0100

    mtd: nand: Remove unused chip->write_page() hook
    
    The last/only user of the chip->write_page() hook (the Atmel NAND
    controller driver) has been reworked and is no longer specifying a custom
    ->write_page() implementation.
    Drop this hook before someone else start abusing it.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Reviewed-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index c7de017c7f4c..40657939797c 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -828,7 +828,6 @@ struct nand_manufacturer_ops {
  * @errstat:		[OPTIONAL] hardware specific function to perform
  *			additional error status checks (determine if errors are
  *			correctable).
- * @write_page:		[REPLACEABLE] High-level page write function
  * @manufacturer:	[INTERN] Contains manufacturer information
  */
 
@@ -854,9 +853,6 @@ struct nand_chip {
 	int (*scan_bbt)(struct mtd_info *mtd);
 	int (*errstat)(struct mtd_info *mtd, struct nand_chip *this, int state,
 			int status, int page);
-	int (*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
-			uint32_t offset, int data_len, const uint8_t *buf,
-			int oob_required, int page, int cached, int raw);
 	int (*onfi_set_features)(struct mtd_info *mtd, struct nand_chip *chip,
 			int feature_addr, uint8_t *subfeature_para);
 	int (*onfi_get_features)(struct mtd_info *mtd, struct nand_chip *chip,

commit 3b5206f4be9b65d2f0f85b3239cf117a1d0de7ce
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Wed Jun 8 10:43:26 2016 +0200

    mtd: nand: Move Macronix specific initialization in nand_macronix.c
    
    Move Macronix specific initialization logic into nand_macronix.c. This
    is part of the "separate vendor specific code from core" cleanup
    process.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 97dce42778e9..c7de017c7f4c 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -1099,6 +1099,7 @@ extern const struct nand_manufacturer_ops samsung_nand_manuf_ops;
 extern const struct nand_manufacturer_ops hynix_nand_manuf_ops;
 extern const struct nand_manufacturer_ops micron_nand_manuf_ops;
 extern const struct nand_manufacturer_ops amd_nand_manuf_ops;
+extern const struct nand_manufacturer_ops macronix_nand_manuf_ops;
 
 int nand_default_bbt(struct mtd_info *mtd);
 int nand_markbad_bbt(struct mtd_info *mtd, loff_t offs);

commit 229204da53b31d576fcc1c93a33626943ea8202c
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Wed Jun 8 10:42:23 2016 +0200

    mtd: nand: Move AMD/Spansion specific init/detection logic in nand_amd.c
    
    Move AMD/Spansion specific initialization/detection logic into
    nand_amd.c. This is part of the "separate vendor specific code from
    core" cleanup process.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Acked-by: Richard Weinberger <richard@nod.at>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 7d0f18ecbf57..97dce42778e9 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -1098,6 +1098,7 @@ extern const struct nand_manufacturer_ops toshiba_nand_manuf_ops;
 extern const struct nand_manufacturer_ops samsung_nand_manuf_ops;
 extern const struct nand_manufacturer_ops hynix_nand_manuf_ops;
 extern const struct nand_manufacturer_ops micron_nand_manuf_ops;
+extern const struct nand_manufacturer_ops amd_nand_manuf_ops;
 
 int nand_default_bbt(struct mtd_info *mtd);
 int nand_markbad_bbt(struct mtd_info *mtd, loff_t offs);

commit 10d4e75c36f6c16311dde1461f318210da357219
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Wed Jun 8 10:38:57 2016 +0200

    mtd: nand: Move Micron specific init logic in nand_micron.c
    
    Move Micron specific initialization logic into nand_micron.c. This is
    part of the "separate vendor specific code from core" cleanup process.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Acked-by: Richard Weinberger <richard@nod.at>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index dd9e3b5ddd4f..7d0f18ecbf57 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -366,26 +366,6 @@ struct onfi_ext_param_page {
 	 */
 } __packed;
 
-struct nand_onfi_vendor_micron {
-	u8 two_plane_read;
-	u8 read_cache;
-	u8 read_unique_id;
-	u8 dq_imped;
-	u8 dq_imped_num_settings;
-	u8 dq_imped_feat_addr;
-	u8 rb_pulldown_strength;
-	u8 rb_pulldown_strength_feat_addr;
-	u8 rb_pulldown_strength_num_settings;
-	u8 otp_mode;
-	u8 otp_page_start;
-	u8 otp_data_prot_addr;
-	u8 otp_num_pages;
-	u8 otp_feat_addr;
-	u8 read_retry_options;
-	u8 reserved[72];
-	u8 param_revision;
-} __packed;
-
 struct jedec_ecc_info {
 	u8 ecc_bits;
 	u8 codeword_size;
@@ -1117,6 +1097,7 @@ extern struct nand_flash_dev nand_flash_ids[];
 extern const struct nand_manufacturer_ops toshiba_nand_manuf_ops;
 extern const struct nand_manufacturer_ops samsung_nand_manuf_ops;
 extern const struct nand_manufacturer_ops hynix_nand_manuf_ops;
+extern const struct nand_manufacturer_ops micron_nand_manuf_ops;
 
 int nand_default_bbt(struct mtd_info *mtd);
 int nand_markbad_bbt(struct mtd_info *mtd, loff_t offs);

commit 9b2d61f80b060ce3ea5af2a99e148b0b214932b2
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Wed Jun 8 10:34:57 2016 +0200

    mtd: nand: Move Toshiba specific init/detection logic in nand_toshiba.c
    
    Move Toshiba specific initialization and detection logic into
    nand_toshiba.c. This is part of the "separate vendor specific code from
    core" cleanup process.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Acked-by: Richard Weinberger <richard@nod.at>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 74e3a231cb56..dd9e3b5ddd4f 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -1114,6 +1114,7 @@ nand_manufacturer_name(const struct nand_manufacturer *manufacturer)
 
 extern struct nand_flash_dev nand_flash_ids[];
 
+extern const struct nand_manufacturer_ops toshiba_nand_manuf_ops;
 extern const struct nand_manufacturer_ops samsung_nand_manuf_ops;
 extern const struct nand_manufacturer_ops hynix_nand_manuf_ops;
 

commit 01389b6bd2f4f7649cdbb4a99a15d9e0c05d6f8c
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Wed Jun 8 10:30:18 2016 +0200

    mtd: nand: Move Hynix specific init/detection logic in nand_hynix.c
    
    Move Hynix specific initialization and detection logic into
    nand_hynix.c. This is part of the "separate vendor specific code from
    core" cleanup process.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Acked-by: Richard Weinberger <richard@nod.at>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 2f83cb55392f..74e3a231cb56 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -1115,6 +1115,7 @@ nand_manufacturer_name(const struct nand_manufacturer *manufacturer)
 extern struct nand_flash_dev nand_flash_ids[];
 
 extern const struct nand_manufacturer_ops samsung_nand_manuf_ops;
+extern const struct nand_manufacturer_ops hynix_nand_manuf_ops;
 
 int nand_default_bbt(struct mtd_info *mtd);
 int nand_markbad_bbt(struct mtd_info *mtd, loff_t offs);

commit c51d0ac59f24200dfdccc897ff7c3c9446c7599a
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Wed Jun 8 10:22:19 2016 +0200

    mtd: nand: Move Samsung specific init/detection logic in nand_samsung.c
    
    Move Samsung specific initialization and detection logic into
    nand_samsung.c. This is part of the "separate vendor specific code from
    core" cleanup process.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Acked-by: Richard Weinberger <richard@nod.at>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index ee9a19f42293..2f83cb55392f 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -1114,6 +1114,8 @@ nand_manufacturer_name(const struct nand_manufacturer *manufacturer)
 
 extern struct nand_flash_dev nand_flash_ids[];
 
+extern const struct nand_manufacturer_ops samsung_nand_manuf_ops;
+
 int nand_default_bbt(struct mtd_info *mtd);
 int nand_markbad_bbt(struct mtd_info *mtd, loff_t offs);
 int nand_isreserved_bbt(struct mtd_info *mtd, loff_t offs);

commit abbe26d144ec22bb067fa414d717b9f7ca2e12bd
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Wed Jun 8 09:32:55 2016 +0200

    mtd: nand: Add manufacturer specific initialization/detection steps
    
    A lot of NANDs are implementing generic features in a non-generic way,
    or are providing advanced auto-detection logic where the NAND ID bytes
    meaning changes with the NAND generation.
    
    Providing this vendor specific initialization step will allow us to get
    rid of full-id entries in the nand_ids table or all the vendor specific
    cases added over the time in the generic NAND ID decoding logic.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 6415aa16043c..ee9a19f42293 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -731,6 +731,20 @@ nand_get_sdr_timings(const struct nand_data_interface *conf)
 	return &conf->timings.sdr;
 }
 
+/**
+ * struct nand_manufacturer_ops - NAND Manufacturer operations
+ * @detect: detect the NAND memory organization and capabilities
+ * @init: initialize all vendor specific fields (like the ->read_retry()
+ *	  implementation) if any.
+ * @cleanup: the ->init() function may have allocated resources, ->cleanup()
+ *	     is here to let vendor specific code release those resources.
+ */
+struct nand_manufacturer_ops {
+	void (*detect)(struct nand_chip *chip);
+	int (*init)(struct nand_chip *chip);
+	void (*cleanup)(struct nand_chip *chip);
+};
+
 /**
  * struct nand_chip - NAND Private Flash Chip Data
  * @mtd:		MTD device registered to the MTD framework
@@ -835,6 +849,7 @@ nand_get_sdr_timings(const struct nand_data_interface *conf)
  *			additional error status checks (determine if errors are
  *			correctable).
  * @write_page:		[REPLACEABLE] High-level page write function
+ * @manufacturer:	[INTERN] Contains manufacturer information
  */
 
 struct nand_chip {
@@ -923,6 +938,11 @@ struct nand_chip {
 	struct nand_bbt_descr *badblock_pattern;
 
 	void *priv;
+
+	struct {
+		const struct nand_manufacturer *desc;
+		void *priv;
+	} manufacturer;
 };
 
 extern const struct mtd_ooblayout_ops nand_ooblayout_sp_ops;
@@ -959,6 +979,17 @@ static inline void nand_set_controller_data(struct nand_chip *chip, void *priv)
 	chip->priv = priv;
 }
 
+static inline void nand_set_manufacturer_data(struct nand_chip *chip,
+					      void *priv)
+{
+	chip->manufacturer.priv = priv;
+}
+
+static inline void *nand_get_manufacturer_data(struct nand_chip *chip)
+{
+	return chip->manufacturer.priv;
+}
+
 /*
  * NAND Flash Manufacturer ID Codes
  */
@@ -1065,10 +1096,12 @@ struct nand_flash_dev {
  * struct nand_manufacturer - NAND Flash Manufacturer structure
  * @name:	Manufacturer name
  * @id:		manufacturer ID code of device.
+ * @ops:	manufacturer operations
 */
 struct nand_manufacturer {
 	int id;
 	char *name;
+	const struct nand_manufacturer_ops *ops;
 };
 
 const struct nand_manufacturer *nand_get_manufacturer(u8 id);
@@ -1246,4 +1279,6 @@ int nand_reset(struct nand_chip *chip, int chipnr);
 /* Free resources held by the NAND device */
 void nand_cleanup(struct nand_chip *chip);
 
+/* Default extended ID decoding function */
+void nand_decode_ext_id(struct nand_chip *chip);
 #endif /* __LINUX_MTD_NAND_H */

commit bcc678c2d7a0e0af14cb3d858ebd367be378c172
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Sat Jan 7 15:48:25 2017 +0100

    mtd: nand: Do not expose the NAND manufacturer table directly
    
    There is no reason to expose the NAND manufacturer table. Provide an
    helper function to find manufacturers by their id.
    
    We also turn the nand_manufacturers table into a const array, since its
    members are not modified after the initial assignment.
    
    Finally, we remove the sentinel manufacturer entry from the manufacturers
    table (we already have the array size information given by ARRAY_SIZE()),
    and add the nand_manufacturer_name() helper to handle the "Unknown" case
    properly.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 9c679e8bde42..6415aa16043c 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -1071,8 +1071,15 @@ struct nand_manufacturer {
 	char *name;
 };
 
+const struct nand_manufacturer *nand_get_manufacturer(u8 id);
+
+static inline const char *
+nand_manufacturer_name(const struct nand_manufacturer *manufacturer)
+{
+	return manufacturer ? manufacturer->name : "Unknown";
+}
+
 extern struct nand_flash_dev nand_flash_ids[];
-extern struct nand_manufacturer nand_manuf_ids[];
 
 int nand_default_bbt(struct mtd_info *mtd);
 int nand_markbad_bbt(struct mtd_info *mtd, loff_t offs);

commit 8cfb9ab68f90703d419870fce7ac21ac401399f2
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Sat Jan 7 15:15:57 2017 +0100

    mtd: nand: Rename the nand_manufacturers struct
    
    Drop the 's' at the end of nand_manufacturers since the struct is actually
    describing a single manufacturer, not a manufacturer table.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index e2c11351b1bd..9c679e8bde42 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -1062,17 +1062,17 @@ struct nand_flash_dev {
 };
 
 /**
- * struct nand_manufacturers - NAND Flash Manufacturer ID Structure
+ * struct nand_manufacturer - NAND Flash Manufacturer structure
  * @name:	Manufacturer name
  * @id:		manufacturer ID code of device.
 */
-struct nand_manufacturers {
+struct nand_manufacturer {
 	int id;
 	char *name;
 };
 
 extern struct nand_flash_dev nand_flash_ids[];
-extern struct nand_manufacturers nand_manuf_ids[];
+extern struct nand_manufacturer nand_manuf_ids[];
 
 int nand_default_bbt(struct mtd_info *mtd);
 int nand_markbad_bbt(struct mtd_info *mtd, loff_t offs);

commit 7f501f0a72036dc29ad9a53811474c393634b401
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Tue May 24 19:20:05 2016 +0200

    mtd: nand: Store nand ID in struct nand_chip
    
    Store the NAND ID in struct nand_chip to avoid passing id_data and id_len
    as function parameters.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Acked-by: Richard Weinberger <richard@nod.at>
    Reviewed-by: Marek Vasut <marek.vasut@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 9591e0fbe5bd..e2c11351b1bd 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -464,6 +464,17 @@ struct nand_jedec_params {
 	__le16 crc;
 } __packed;
 
+/**
+ * struct nand_id - NAND id structure
+ * @data: buffer containing the id bytes. Currently 8 bytes large, but can
+ *	  be extended if required.
+ * @len: ID length.
+ */
+struct nand_id {
+	u8 data[8];
+	int len;
+};
+
 /**
  * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independent devices
  * @lock:               protection lock
@@ -793,6 +804,7 @@ nand_get_sdr_timings(const struct nand_data_interface *conf)
  * @pagebuf_bitflips:	[INTERN] holds the bitflip count for the page which is
  *			currently in data_buf.
  * @subpagesize:	[INTERN] holds the subpagesize
+ * @id:			[INTERN] holds NAND ID
  * @onfi_version:	[INTERN] holds the chip ONFI version (BCD encoded),
  *			non 0 if ONFI supported.
  * @jedec_version:	[INTERN] holds the chip JEDEC version (BCD encoded),
@@ -881,6 +893,7 @@ struct nand_chip {
 	int badblockpos;
 	int badblockbits;
 
+	struct nand_id id;
 	int onfi_version;
 	int jedec_version;
 	union {

commit 9c8d7ff32a0aa001ac8506180e1662ecdf927f32
Merge: 5d708ecc6c77 a4077ce58713
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Wed Feb 8 15:00:24 2017 -0800

    Merge tag 'nand/for-4.11' of github.com:linux-nand/linux
    
    From Boris:
    
    """
    This pull request contains minor fixes/improvements on existing drivers:
    - sunxi: avoid busy-waiting for NAND events
    - ifc: fix ECC handling on IFC v1.0
    - OX820: add explicit dependency on ARCH_OXNAS in Kconfig
    - core: add a new manufacture ID and fix a kernel-doc warning
    - fsmc: kill pdata support
    - lpc32xx_slc: remove unneeded NULL check
    """
    
    Conflicts:
            include/linux/mtd/nand.h
    [Brian: trivial conflict in the comment section]

commit ceb374eb06848212e47fb884964a3ae5e79615b5
Author: Zach Brown <zach.brown@ni.com>
Date:   Tue Jan 10 13:30:19 2017 -0600

    mtd: nand: Add max_bb_per_die and blocks_per_die fields to nand_chip
    
    The fields max_bb_per_die and blocks_per_die are useful determining the
    number of bad blocks a MTD needs to allocate. How they are set will
    depend on if the chip is ONFI, JEDEC or a full-id entry in the nand_ids
    table.
    
    Signed-off-by: Zach Brown <zach.brown@ni.com>
    Acked-by: Boris Brezillon <boris.brezillon@free-electron.com>
    Acked-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index c5f3a012ae62..4e1b441c3a7e 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -801,6 +801,9 @@ nand_get_sdr_timings(const struct nand_data_interface *conf)
  *			supported, 0 otherwise.
  * @jedec_params:	[INTERN] holds the JEDEC parameter page when JEDEC is
  *			supported, 0 otherwise.
+ * @max_bb_per_die:	[INTERN] the max number of bad blocks each die of a
+ *			this nand device will encounter their life times.
+ * @blocks_per_die:	[INTERN] The number of PEBs in a die
  * @read_retries:	[INTERN] the number of read retry modes supported
  * @onfi_set_features:	[REPLACEABLE] set the features for ONFI nand
  * @onfi_get_features:	[REPLACEABLE] get the features for ONFI nand
@@ -883,6 +886,8 @@ struct nand_chip {
 		struct nand_onfi_params	onfi_params;
 		struct nand_jedec_params jedec_params;
 	};
+	u16 max_bb_per_die;
+	u32 blocks_per_die;
 
 	struct nand_data_interface *data_interface;
 

commit a4077ce5871304f8a78f80b74b18b6052a410f1a
Author: Andrey Jr. Melnikov <temnota.am@gmail.com>
Date:   Thu Dec 8 19:57:08 2016 +0300

    mtd: nand: Add Winbond manufacturer id
    
    Add WINBOND manufacturer id.
    
    Signed-off-by: Andrey Jr. Melnikov <temnota.am@gmail.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index f67915c7726f..f6017a1a35d6 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -959,6 +959,7 @@ static inline void nand_set_controller_data(struct nand_chip *chip, void *priv)
 #define NAND_MFR_SANDISK	0x45
 #define NAND_MFR_INTEL		0x89
 #define NAND_MFR_ATO		0x9b
+#define NAND_MFR_WINBOND	0xef
 
 /* The maximum expected count of bytes in the NAND ID sequence */
 #define NAND_MAX_ID_LEN 8

commit 61babe943938bb41fcd7e2b1dec7d1537ea3892f
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Mon Nov 21 18:32:08 2016 -0800

    mtd: nand: fix nand.h kernel-doc warnings
    
    Fix kernel-doc warnings in <linux/mtd/nand.h>:
    
    ..//include/linux/mtd/nand.h:658: warning: No description found for parameter 'tCEH_min'
    ..//include/linux/mtd/nand.h:877: warning: No description found for parameter 'data_interface'
    
    Fixes: eee64b700e26 ("mtd: nand: Introduce nand_data_interface")
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index c5f3a012ae62..f67915c7726f 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -615,7 +615,7 @@ struct nand_buffers {
  * @tALS_min: ALE setup time
  * @tAR_min: ALE to RE# delay
  * @tCEA_max: CE# access time
- * @tCEH_min:
+ * @tCEH_min: CE# high hold time
  * @tCH_min:  CE# hold time
  * @tCHZ_max: CE# high to output hi-Z
  * @tCLH_min: CLE hold time
@@ -801,6 +801,7 @@ nand_get_sdr_timings(const struct nand_data_interface *conf)
  *			supported, 0 otherwise.
  * @jedec_params:	[INTERN] holds the JEDEC parameter page when JEDEC is
  *			supported, 0 otherwise.
+ * @data_interface:	[INTERN] NAND interface timing information
  * @read_retries:	[INTERN] the number of read retry modes supported
  * @onfi_set_features:	[REPLACEABLE] set the features for ONFI nand
  * @onfi_get_features:	[REPLACEABLE] get the features for ONFI nand

commit 0989b0909c1f86b8a4a76c0bee101cd017c4e259
Merge: b2c4ba5cf712 8fcfba072420
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Nov 29 18:28:30 2016 -0800

    Merge tag 'nand/for-4.10' of github.com:linux-nand/linux
    
    From Boris Brezillon:
    
    """
    This pull request contains the following notable changes:
    - new tango NAND controller driver
    - new ox820 NAND controller driver
    - addition of a new full-ID entry in the nand_ids table
    - rework of the s3c240 driver to support DT
    - extension of the nand_sdr_timings to expose tCCS, tPROG and tR
    - addition of a new flag to ask the core to wait for tCCS when sending
      a RNDIN/RNDOUT command
    - addition of a new flag to ask the core to let the controller driver
      send the READ/PROGPAGE command
    
    This pull request also contains minor fixes/cleanup/cosmetic changes:
    - properly support 512 ECC step size in the sunxi driver
    - improve the error messages in the pxa probe path
    - fix module autoload in the omap2 driver
    - cleanup of several nand drivers to return nand_scan{_tail}() error
      code instead of returning -EIO
    - various cleanups in the denali driver
    - cleanups in the ooblayout handling (MTD core)
    - fix an error check in nandsim
    """

commit 3371d663bb4579f1b2003a92162edd6d90edd089
Author: Marc Gonzalez <marc_gonzalez@sigmadesigns.com>
Date:   Tue Nov 15 10:56:20 2016 +0100

    mtd: nand: Support controllers with custom page
    
    If your controller already sends the required NAND commands when
    reading or writing a page, then the framework is not supposed to
    send READ0 and SEQIN/PAGEPROG respectively.
    
    Signed-off-by: Marc Gonzalez <marc_gonzalez@sigmadesigns.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 970ceb948835..ed6fd1993be1 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -142,6 +142,12 @@ enum nand_ecc_algo {
  */
 #define NAND_ECC_GENERIC_ERASED_CHECK	BIT(0)
 #define NAND_ECC_MAXIMIZE		BIT(1)
+/*
+ * If your controller already sends the required NAND commands when
+ * reading or writing a page, then the framework is not supposed to
+ * send READ0 and SEQIN/PAGEPROG respectively.
+ */
+#define NAND_ECC_CUSTOM_PAGE_ACCESS	BIT(2)
 
 /* Bit mask for flags passed to do_nand_read_ecc */
 #define NAND_GET_DEVICE		0x80
@@ -186,6 +192,7 @@ enum nand_ecc_algo {
 /* Macros to identify the above */
 #define NAND_HAS_CACHEPROG(chip) ((chip->options & NAND_CACHEPRG))
 #define NAND_HAS_SUBPAGE_READ(chip) ((chip->options & NAND_SUBPAGE_READ))
+#define NAND_HAS_SUBPAGE_WRITE(chip) !((chip)->options & NAND_NO_SUBPAGE_WRITE)
 
 /* Non chip related options */
 /* This option skips the bbt scan during initialization. */
@@ -568,6 +575,11 @@ struct nand_ecc_ctrl {
 			int page);
 };
 
+static inline int nand_standard_page_accessors(struct nand_ecc_ctrl *ecc)
+{
+	return !(ecc->options & NAND_ECC_CUSTOM_PAGE_ACCESS);
+}
+
 /**
  * struct nand_buffers - buffer structure for read/write
  * @ecccalc:	buffer pointer for calculated ECC, size is oobsize.

commit 6ea40a3ba93e1b14ffb349e276f9dfefc4334b99
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Sat Oct 1 10:24:03 2016 +0200

    mtd: nand: Wait tCCS after a column change
    
    Drivers implementing ->cmd_ctrl() and relying on the default ->cmdfunc()
    implementation usually don't wait tCCS when a column change (RNDIN or
    RNDOUT) is requested.
    Add an option flag to ask the core to do so (note that we keep this as
    an opt-in to avoid breaking existing implementations), and make use of
    the ->data_interface information is available (otherwise, wait 500ns).
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Tested-by: Marc Gonzalez <marc_gonzalez@sigmadesigns.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 6fe83bce83a6..970ceb948835 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -210,6 +210,16 @@ enum nand_ecc_algo {
  */
 #define NAND_USE_BOUNCE_BUFFER	0x00100000
 
+/*
+ * In case your controller is implementing ->cmd_ctrl() and is relying on the
+ * default ->cmdfunc() implementation, you may want to let the core handle the
+ * tCCS delay which is required when a column change (RNDIN or RNDOUT) is
+ * requested.
+ * If your controller already takes care of this delay, you don't need to set
+ * this flag.
+ */
+#define NAND_WAIT_TCCS		0x00200000
+
 /* Options set by nand scan */
 /* Nand scan has allocated controller struct */
 #define NAND_CONTROLLER_ALLOC	0x80000000

commit 204e7ecd47e26cc12d9e8e8a7e7a2eeb9573f0ba
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Sat Oct 1 10:24:02 2016 +0200

    mtd: nand: Add a few more timings to nand_sdr_timings
    
    Add the tR_max, tBERS_max, tPROG_max and tCCS_min timings to the
    nand_sdr_timings struct.
    Assign default/safe values for the statically defined timings, and
    extract them from the ONFI parameter table if the NAND is ONFI
    compliant.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Tested-by: Marc Gonzalez <marc_gonzalez@sigmadesigns.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index c5d3d5024fc8..6fe83bce83a6 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -584,6 +584,10 @@ struct nand_buffers {
  *
  * All these timings are expressed in picoseconds.
  *
+ * @tBERS_max: Block erase time
+ * @tCCS_min: Change column setup time
+ * @tPROG_max: Page program time
+ * @tR_max: Page read time
  * @tALH_min: ALE hold time
  * @tADL_min: ALE to data loading time
  * @tALS_min: ALE setup time
@@ -621,6 +625,10 @@ struct nand_buffers {
  * @tWW_min: WP# transition to WE# low
  */
 struct nand_sdr_timings {
+	u32 tBERS_max;
+	u32 tCCS_min;
+	u32 tPROG_max;
+	u32 tR_max;
 	u32 tALH_min;
 	u32 tADL_min;
 	u32 tALS_min;

commit 73f907fd5fa56b0066d199bdd7126bbd04f6cd7b
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Mon Oct 24 16:46:20 2016 +0200

    mtd: nand: Fix data interface configuration logic
    
    When changing from one data interface setting to another, one has to
    ensure a specific sequence which is described in the ONFI spec.
    
    One of these constraints is that the CE line has go high after a reset
    before a command can be sent with the new data interface setting, which
    is not guaranteed by the current implementation.
    
    Rework the nand_reset() function and all the call sites to make sure the
    CE line is asserted and released when required.
    
    Also make sure to actually apply the new data interface setting on the
    first die.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Fixes: d8e725dd8311 ("mtd: nand: automate NAND timings selection")
    Reviewed-by: Sascha Hauer <s.hauer@pengutronix.de>
    Tested-by: Marc Gonzalez <marc_gonzalez@sigmadesigns.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index c5d3d5024fc8..d8905a229f34 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -1184,7 +1184,7 @@ int nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
 			   int page);
 
 /* Reset and initialize a NAND device */
-int nand_reset(struct nand_chip *chip);
+int nand_reset(struct nand_chip *chip, int chipnr);
 
 /* Free resources held by the NAND device */
 void nand_cleanup(struct nand_chip *chip);

commit d44154f969a44269a9288c274c1c2fd9e85df8a5
Author: Richard Weinberger <richard@nod.at>
Date:   Wed Sep 21 11:44:41 2016 +0200

    mtd: nand: Provide nand_cleanup() function to free NAND related resources
    
    Provide a nand_cleanup() function to free all nand related resources
    without unregistering the mtd device.
    This should allow drivers to call mtd_device_unregister() and handle
    its return value and still being able to cleanup all nand related
    resources.
    
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Daniel Walter <dwalter@sigma-star.at>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 331caf987b16..c5d3d5024fc8 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -38,7 +38,7 @@ int nand_scan_ident(struct mtd_info *mtd, int max_chips,
 			   struct nand_flash_dev *table);
 int nand_scan_tail(struct mtd_info *mtd);
 
-/* Free resources held by the NAND device */
+/* Unregister the MTD device and free resources held by the NAND device */
 void nand_release(struct mtd_info *mtd);
 
 /* Internal helper for board drivers which need to override command function */
@@ -1186,4 +1186,7 @@ int nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
 /* Reset and initialize a NAND device */
 int nand_reset(struct nand_chip *chip);
 
+/* Free resources held by the NAND device */
+void nand_cleanup(struct nand_chip *chip);
+
 #endif /* __LINUX_MTD_NAND_H */

commit ba78ee00e1ff84de9b3ad33edbd3ec599099ee82
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Wed Jun 8 17:04:22 2016 +0200

    mtd: nand: Add an option to maximize the ECC strength
    
    The generic NAND DT bindings allows one to tweak the ECC strength and
    step size to their need. It can be used to lower the ECC strength to
    match a bootloader/firmware config, but might also be used to get a better
    reliability.
    
    In the latter case, the user might want to use the maximum ECC strength
    without having to explicitly calculate the exact value (this value not
    only depends on the OOB size, but also on the NAND controller, and can
    be tricky to extract).
    
    Add a generic 'nand-ecc-maximize' DT property and the associated
    NAND_ECC_MAXIMIZE flag, to let ECC controller drivers select the best
    ECC strength and step-size on their own.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Acked-by: Rob Herring <robh@kernel.org>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index d3e3f8d03336..331caf987b16 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -141,6 +141,7 @@ enum nand_ecc_algo {
  * pages and you want to rely on the default implementation.
  */
 #define NAND_ECC_GENERIC_ERASED_CHECK	BIT(0)
+#define NAND_ECC_MAXIMIZE		BIT(1)
 
 /* Bit mask for flags passed to do_nand_read_ecc */
 #define NAND_GET_DEVICE		0x80

commit d8e725dd831186a3595036b2b1df9f68cbc6efa3
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Thu Sep 15 10:32:50 2016 +0200

    mtd: nand: automate NAND timings selection
    
    The NAND framework provides several helpers to query timing modes supported
    by a NAND chip, but this implies that all NAND controller drivers have
    to implement the same timings selection dance. Also currently NAND
    devices can be resetted at arbitrary places which also resets the timing
    for ONFI chips to timing mode 0.
    
    Provide a common logic to select the best timings based on ONFI or
    ->onfi_timing_mode_default information. Hook this into nand_reset()
    to make sure the new timing is applied each time during a reset.
    
    NAND controller willing to support timings adjustment should just
    implement the ->setup_data_interface() method.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 0c9412c2d80b..d3e3f8d03336 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -751,10 +751,9 @@ nand_get_sdr_timings(const struct nand_data_interface *conf)
  *                      also from the datasheet. It is the recommended ECC step
  *			size, if known; if unknown, set to zero.
  * @onfi_timing_mode_default: [INTERN] default ONFI timing mode. This field is
- *			      either deduced from the datasheet if the NAND
- *			      chip is not ONFI compliant or set to 0 if it is
- *			      (an ONFI chip is always configured in mode 0
- *			      after a NAND reset)
+ *			      set to the actually used ONFI mode if the chip is
+ *			      ONFI compliant or deduced from the datasheet if
+ *			      the NAND chip is not ONFI compliant.
  * @numchips:		[INTERN] number of physical chips
  * @chipsize:		[INTERN] the size of one chip for multichip arrays
  * @pagemask:		[INTERN] page number mask = number of (pages / chip) - 1
@@ -774,6 +773,7 @@ nand_get_sdr_timings(const struct nand_data_interface *conf)
  * @read_retries:	[INTERN] the number of read retry modes supported
  * @onfi_set_features:	[REPLACEABLE] set the features for ONFI nand
  * @onfi_get_features:	[REPLACEABLE] get the features for ONFI nand
+ * @setup_data_interface: [OPTIONAL] setup the data interface and timing
  * @bbt:		[INTERN] bad block table pointer
  * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash
  *			lookup.
@@ -820,6 +820,10 @@ struct nand_chip {
 	int (*onfi_get_features)(struct mtd_info *mtd, struct nand_chip *chip,
 			int feature_addr, uint8_t *subfeature_para);
 	int (*setup_read_retry)(struct mtd_info *mtd, int retry_mode);
+	int (*setup_data_interface)(struct mtd_info *mtd,
+				    const struct nand_data_interface *conf,
+				    bool check_only);
+
 
 	int chip_delay;
 	unsigned int options;
@@ -849,6 +853,8 @@ struct nand_chip {
 		struct nand_jedec_params jedec_params;
 	};
 
+	struct nand_data_interface *data_interface;
+
 	int read_retries;
 
 	flstate_t state;

commit 6e1f9708dbf3c50a8da93c1952a01a7a2acb5e66
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Thu Sep 15 10:32:49 2016 +0200

    mtd: nand: Expose data interface for ONFI mode 0
    
    The nand layer will need ONFI mode 0 to use it as timing mode
    before and right after reset.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 1f34c04fe16c..0c9412c2d80b 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -1154,6 +1154,8 @@ static inline int jedec_feature(struct nand_chip *chip)
 
 /* get timing characteristics from ONFI timing mode. */
 const struct nand_sdr_timings *onfi_async_timing_mode_to_sdr_timings(int mode);
+/* get data interface from ONFI timing mode 0, used after reset. */
+const struct nand_data_interface *nand_get_default_data_interface(void);
 
 int nand_check_erased_ecc_chunk(void *data, int datalen,
 				void *ecc, int ecclen,

commit b88730ada99bfe243862add360720a3550b0edbf
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Thu Sep 15 10:32:48 2016 +0200

    mtd: nand: Add function to convert ONFI mode to data_interface
    
    onfi_init_data_interface() initializes a data interface with
    values from a given ONFI mode.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index a625e960c0c3..1f34c04fe16c 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -1112,6 +1112,11 @@ static inline int onfi_get_sync_timing_mode(struct nand_chip *chip)
 	return le16_to_cpu(chip->onfi_params.src_sync_timing_mode);
 }
 
+int onfi_init_data_interface(struct nand_chip *chip,
+			     struct nand_data_interface *iface,
+			     enum nand_data_interface_type type,
+			     int timing_mode);
+
 /*
  * Check if it is a SLC nand.
  * The !nand_is_slc() can be used to check the MLC/TLC nand chips.

commit eee64b700e26b9bcc6fce024681c31f5e12271fc
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Thu Sep 15 10:32:46 2016 +0200

    mtd: nand: Introduce nand_data_interface
    
    Currently we have no data structure to fully describe a NAND timing.
    We only have struct nand_sdr_timings for NAND timings in SDR mode,
    but nothing for DDR mode and also no container to store both types
    of timing.
    This patch adds struct nand_data_interface which stores the timing
    type and a union of different timings. This can be used to pass to
    drivers in order to configure the timing.
    Add kerneldoc for struct nand_sdr_timings while touching it anyway.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 73ccbf6e057c..a625e960c0c3 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -572,6 +572,123 @@ struct nand_buffers {
 	uint8_t *databuf;
 };
 
+/**
+ * struct nand_sdr_timings - SDR NAND chip timings
+ *
+ * This struct defines the timing requirements of a SDR NAND chip.
+ * These information can be found in every NAND datasheets and the timings
+ * meaning are described in the ONFI specifications:
+ * www.onfi.org/~/media/ONFI/specs/onfi_3_1_spec.pdf (chapter 4.15 Timing
+ * Parameters)
+ *
+ * All these timings are expressed in picoseconds.
+ *
+ * @tALH_min: ALE hold time
+ * @tADL_min: ALE to data loading time
+ * @tALS_min: ALE setup time
+ * @tAR_min: ALE to RE# delay
+ * @tCEA_max: CE# access time
+ * @tCEH_min:
+ * @tCH_min:  CE# hold time
+ * @tCHZ_max: CE# high to output hi-Z
+ * @tCLH_min: CLE hold time
+ * @tCLR_min: CLE to RE# delay
+ * @tCLS_min: CLE setup time
+ * @tCOH_min: CE# high to output hold
+ * @tCS_min: CE# setup time
+ * @tDH_min: Data hold time
+ * @tDS_min: Data setup time
+ * @tFEAT_max: Busy time for Set Features and Get Features
+ * @tIR_min: Output hi-Z to RE# low
+ * @tITC_max: Interface and Timing Mode Change time
+ * @tRC_min: RE# cycle time
+ * @tREA_max: RE# access time
+ * @tREH_min: RE# high hold time
+ * @tRHOH_min: RE# high to output hold
+ * @tRHW_min: RE# high to WE# low
+ * @tRHZ_max: RE# high to output hi-Z
+ * @tRLOH_min: RE# low to output hold
+ * @tRP_min: RE# pulse width
+ * @tRR_min: Ready to RE# low (data only)
+ * @tRST_max: Device reset time, measured from the falling edge of R/B# to the
+ *	      rising edge of R/B#.
+ * @tWB_max: WE# high to SR[6] low
+ * @tWC_min: WE# cycle time
+ * @tWH_min: WE# high hold time
+ * @tWHR_min: WE# high to RE# low
+ * @tWP_min: WE# pulse width
+ * @tWW_min: WP# transition to WE# low
+ */
+struct nand_sdr_timings {
+	u32 tALH_min;
+	u32 tADL_min;
+	u32 tALS_min;
+	u32 tAR_min;
+	u32 tCEA_max;
+	u32 tCEH_min;
+	u32 tCH_min;
+	u32 tCHZ_max;
+	u32 tCLH_min;
+	u32 tCLR_min;
+	u32 tCLS_min;
+	u32 tCOH_min;
+	u32 tCS_min;
+	u32 tDH_min;
+	u32 tDS_min;
+	u32 tFEAT_max;
+	u32 tIR_min;
+	u32 tITC_max;
+	u32 tRC_min;
+	u32 tREA_max;
+	u32 tREH_min;
+	u32 tRHOH_min;
+	u32 tRHW_min;
+	u32 tRHZ_max;
+	u32 tRLOH_min;
+	u32 tRP_min;
+	u32 tRR_min;
+	u64 tRST_max;
+	u32 tWB_max;
+	u32 tWC_min;
+	u32 tWH_min;
+	u32 tWHR_min;
+	u32 tWP_min;
+	u32 tWW_min;
+};
+
+/**
+ * enum nand_data_interface_type - NAND interface timing type
+ * @NAND_SDR_IFACE:	Single Data Rate interface
+ */
+enum nand_data_interface_type {
+	NAND_SDR_IFACE,
+};
+
+/**
+ * struct nand_data_interface - NAND interface timing
+ * @type:	type of the timing
+ * @timings:	The timing, type according to @type
+ */
+struct nand_data_interface {
+	enum nand_data_interface_type type;
+	union {
+		struct nand_sdr_timings sdr;
+	} timings;
+};
+
+/**
+ * nand_get_sdr_timings - get SDR timing from data interface
+ * @conf:	The data interface
+ */
+static inline const struct nand_sdr_timings *
+nand_get_sdr_timings(const struct nand_data_interface *conf)
+{
+	if (conf->type != NAND_SDR_IFACE)
+		return ERR_PTR(-EINVAL);
+
+	return &conf->timings.sdr;
+}
+
 /**
  * struct nand_chip - NAND Private Flash Chip Data
  * @mtd:		MTD device registered to the MTD framework
@@ -1030,55 +1147,6 @@ static inline int jedec_feature(struct nand_chip *chip)
 		: 0;
 }
 
-/*
- * struct nand_sdr_timings - SDR NAND chip timings
- *
- * This struct defines the timing requirements of a SDR NAND chip.
- * These informations can be found in every NAND datasheets and the timings
- * meaning are described in the ONFI specifications:
- * www.onfi.org/~/media/ONFI/specs/onfi_3_1_spec.pdf (chapter 4.15 Timing
- * Parameters)
- *
- * All these timings are expressed in picoseconds.
- */
-
-struct nand_sdr_timings {
-	u32 tALH_min;
-	u32 tADL_min;
-	u32 tALS_min;
-	u32 tAR_min;
-	u32 tCEA_max;
-	u32 tCEH_min;
-	u32 tCH_min;
-	u32 tCHZ_max;
-	u32 tCLH_min;
-	u32 tCLR_min;
-	u32 tCLS_min;
-	u32 tCOH_min;
-	u32 tCS_min;
-	u32 tDH_min;
-	u32 tDS_min;
-	u32 tFEAT_max;
-	u32 tIR_min;
-	u32 tITC_max;
-	u32 tRC_min;
-	u32 tREA_max;
-	u32 tREH_min;
-	u32 tRHOH_min;
-	u32 tRHW_min;
-	u32 tRHZ_max;
-	u32 tRLOH_min;
-	u32 tRP_min;
-	u32 tRR_min;
-	u64 tRST_max;
-	u32 tWB_max;
-	u32 tWC_min;
-	u32 tWH_min;
-	u32 tWHR_min;
-	u32 tWP_min;
-	u32 tWW_min;
-};
-
 /* get timing characteristics from ONFI timing mode. */
 const struct nand_sdr_timings *onfi_async_timing_mode_to_sdr_timings(int mode);
 

commit 2f94abfe35b210e7711af9202a3dcfc9e779219a
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Thu Sep 15 10:32:45 2016 +0200

    mtd: nand: Create a NAND reset function
    
    When NAND devices are resetted some initialization may have to be done,
    like for example they have to be configured for the timing mode that
    shall be used. To get a common place where this initialization can be
    implemented create a nand_reset() function. This currently only issues
    a NAND_CMD_RESET to the NAND device. The places issuing this command
    manually are replaced with a call to nand_reset().
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 28c1833ad708..73ccbf6e057c 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -1100,4 +1100,8 @@ int nand_read_oob_std(struct mtd_info *mtd, struct nand_chip *chip, int page);
 /* Default read_oob syndrome implementation */
 int nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
 			   int page);
+
+/* Reset and initialize a NAND device */
+int nand_reset(struct nand_chip *chip);
+
 #endif /* __LINUX_MTD_NAND_H */

commit 79022591839f110f465cac0223e117b91d47d5db
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Wed Sep 7 14:21:42 2016 +0200

    mtd: nand: remove unnecessary 'extern' from function declarations
    
    'extern' is not necessary for function declarations. To prevent
    people from adding the keyword to new declarations remove the
    existing ones.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index f6a2d5e7313c..28c1833ad708 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -29,26 +29,26 @@ struct nand_flash_dev;
 struct device_node;
 
 /* Scan and identify a NAND device */
-extern int nand_scan(struct mtd_info *mtd, int max_chips);
+int nand_scan(struct mtd_info *mtd, int max_chips);
 /*
  * Separate phases of nand_scan(), allowing board driver to intervene
  * and override command or ECC setup according to flash type.
  */
-extern int nand_scan_ident(struct mtd_info *mtd, int max_chips,
+int nand_scan_ident(struct mtd_info *mtd, int max_chips,
 			   struct nand_flash_dev *table);
-extern int nand_scan_tail(struct mtd_info *mtd);
+int nand_scan_tail(struct mtd_info *mtd);
 
 /* Free resources held by the NAND device */
-extern void nand_release(struct mtd_info *mtd);
+void nand_release(struct mtd_info *mtd);
 
 /* Internal helper for board drivers which need to override command function */
-extern void nand_wait_ready(struct mtd_info *mtd);
+void nand_wait_ready(struct mtd_info *mtd);
 
 /* locks all blocks present in the device */
-extern int nand_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
+int nand_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
 
 /* unlocks specified locked blocks */
-extern int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
+int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
 
 /* The maximum number of NAND chips in an array */
 #define NAND_MAX_CHIPS		8
@@ -900,14 +900,14 @@ struct nand_manufacturers {
 extern struct nand_flash_dev nand_flash_ids[];
 extern struct nand_manufacturers nand_manuf_ids[];
 
-extern int nand_default_bbt(struct mtd_info *mtd);
-extern int nand_markbad_bbt(struct mtd_info *mtd, loff_t offs);
-extern int nand_isreserved_bbt(struct mtd_info *mtd, loff_t offs);
-extern int nand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt);
-extern int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
-			   int allowbbt);
-extern int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
-			size_t *retlen, uint8_t *buf);
+int nand_default_bbt(struct mtd_info *mtd);
+int nand_markbad_bbt(struct mtd_info *mtd, loff_t offs);
+int nand_isreserved_bbt(struct mtd_info *mtd, loff_t offs);
+int nand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt);
+int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
+		    int allowbbt);
+int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
+		 size_t *retlen, uint8_t *buf);
 
 /**
  * struct platform_nand_chip - chip level device structure

commit d45bc58dd3bdcaabc1d7d8d9b0b8dee826635cc6
Author: Marc Gonzalez <marc_gonzalez@sigmadesigns.com>
Date:   Wed Jul 27 11:23:52 2016 +0200

    mtd: nand: import nand_hw_control_init()
    
    The code to initialize a struct nand_hw_control is duplicated across
    several drivers. Factorize it using an inline function.
    
    Signed-off-by: Marc Gonzalez <marc_gonzalez@sigmadesigns.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 8dd6e01f45c0..f6a2d5e7313c 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -460,6 +460,13 @@ struct nand_hw_control {
 	wait_queue_head_t wq;
 };
 
+static inline void nand_hw_control_init(struct nand_hw_control *nfc)
+{
+	nfc->active = NULL;
+	spin_lock_init(&nfc->lock);
+	init_waitqueue_head(&nfc->wq);
+}
+
 /**
  * struct nand_ecc_ctrl - Control structure for ECC
  * @mode:	ECC mode

commit 1c7fe6b438433e16d5b1211380c305351ac38299
Author: Rafał Miłecki <zajec5@gmail.com>
Date:   Thu Jun 9 20:10:11 2016 +0200

    mtd: nand: add ESMT manufacturer
    
    I got device with ESMT (Elite Semiconductor Memory Technology Inc)
    F59L1G81MA flash that was detected as:
    [    0.852034] nand: device found, Manufacturer ID: 0xc8, Chip ID: 0xd1
    [    0.858402] nand: Unknown NAND 128MiB 3,3V 8-bit
    [    0.863031] nand: 128MiB, SLC, page size: 2048, OOB size: 64
    
    According to the F59L1G81MA datasheet (and Read Id documentation) C8h is
    a "Maker Code" which should mean ESMT. Add it to fix above "Unknown".
    
    Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index fbe8e164a4ee..8dd6e01f45c0 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -783,6 +783,7 @@ static inline void nand_set_controller_data(struct nand_chip *chip, void *priv)
  * NAND Flash Manufacturer ID Codes
  */
 #define NAND_MFR_TOSHIBA	0x98
+#define NAND_MFR_ESMT		0xc8
 #define NAND_MFR_SAMSUNG	0xec
 #define NAND_MFR_FUJITSU	0x04
 #define NAND_MFR_NATIONAL	0x8f

commit e4225ae8234cf5548c38dc887b233ad1d45b4d53
Author: Rafał Miłecki <zajec5@gmail.com>
Date:   Sun Apr 17 22:53:07 2016 +0200

    mtd: mtd: drop NAND_ECC_SOFT_BCH enum value
    
    This value should not be part of nand_ecc_modes_t as it specifies
    algorithm not a mode. We successfully managed to introduce new "algo"
    field which is respected now.
    
    Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index e851839daf09..fbe8e164a4ee 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -116,7 +116,6 @@ typedef enum {
 	NAND_ECC_HW,
 	NAND_ECC_HW_SYNDROME,
 	NAND_ECC_HW_OOB_FIRST,
-	NAND_ECC_SOFT_BCH,
 } nand_ecc_modes_t;
 
 enum nand_ecc_algo {

commit 7f2b092c9eeda055ae60af194a8edacaea5f7a10
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Wed Feb 3 19:24:10 2016 +0100

    mtd: nand: kill the ecc->layout field
    
    Now that all NAND drivers have switched to mtd_ooblayout_ops, we can kill
    the ecc->layout field.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index f2ded7b1b3b8..e851839daf09 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -473,7 +473,6 @@ struct nand_hw_control {
  * @prepad:	padding information for syndrome based ECC generators
  * @postpad:	padding information for syndrome based ECC generators
  * @options:	ECC specific options (see NAND_ECC_XXX flags defined above)
- * @layout:	ECC layout control struct pointer
  * @priv:	pointer to private ECC control data
  * @hwctl:	function to control hardware ECC generator. Must only
  *		be provided if an hardware ECC is available
@@ -524,7 +523,6 @@ struct nand_ecc_ctrl {
 	int prepad;
 	int postpad;
 	unsigned int options;
-	struct nand_ecclayout	*layout;
 	void *priv;
 	void (*hwctl)(struct mtd_info *mtd, int mode);
 	int (*calculate)(struct mtd_info *mtd, const uint8_t *dat,

commit 41b207a70d3a86b9e2eede155e87838234c7cbd5
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Wed Feb 3 19:06:15 2016 +0100

    mtd: nand: implement the default mtd_ooblayout_ops
    
    Replace the default nand_ecclayout definitions for large and small page
    devices with the equivalent mtd_ooblayout_ops.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 7e06afb8552c..f2ded7b1b3b8 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -748,6 +748,9 @@ struct nand_chip {
 	void *priv;
 };
 
+extern const struct mtd_ooblayout_ops nand_ooblayout_sp_ops;
+extern const struct mtd_ooblayout_ops nand_ooblayout_lp_ops;
+
 static inline void nand_set_flash_node(struct nand_chip *chip,
 				       struct device_node *np)
 {

commit 9d02fc2a5129449581c3108c260e96377cf35f7e
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Wed Aug 26 16:08:12 2015 +0200

    mtd: nand: export default read/write oob functions
    
    Export the default read/write oob functions (for the standard and syndrome
    scheme), so that drivers can use them for their raw implementation and
    implement their own functions for the normal oob operation.
    
    This is required if your ECC engine is capable of fixing some of the OOB
    data. In this case you have to overload the ->read_oob() and ->write_oob(),
    but if you don't specify the ->read/write_oob_raw() functions they are
    assigned to the ->read/write_oob() implementation, which is not what you
    want.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 1b673e19667c..7e06afb8552c 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -1078,4 +1078,18 @@ int nand_check_erased_ecc_chunk(void *data, int datalen,
 				void *ecc, int ecclen,
 				void *extraoob, int extraooblen,
 				int threshold);
+
+/* Default write_oob implementation */
+int nand_write_oob_std(struct mtd_info *mtd, struct nand_chip *chip, int page);
+
+/* Default write_oob syndrome implementation */
+int nand_write_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
+			    int page);
+
+/* Default read_oob implementation */
+int nand_read_oob_std(struct mtd_info *mtd, struct nand_chip *chip, int page);
+
+/* Default read_oob syndrome implementation */
+int nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
+			   int page);
 #endif /* __LINUX_MTD_NAND_H */

commit b0fcd8ab7b3c89b5da7fff5224d06ed73e7a33cc
Author: Rafał Miłecki <zajec5@gmail.com>
Date:   Wed Mar 23 11:19:00 2016 +0100

    mtd: nand: add new enum for storing ECC algorithm
    
    Our nand_ecc_modes_t is already a bit abused by value NAND_ECC_SOFT_BCH.
    This enum should store ECC mode only and putting algorithm details there
    is a bad idea. It would result in too many values impossible to support
    in a sane way.
    
    To solve this problem let's add a new enum. We'll have to modify all
    drivers to set it properly but once it's done it'll be possible to drop
    NAND_ECC_SOFT_BCH. That will result in a cleaner design and more
    possibilities like setting ECC algorithm for hardware ECC mode.
    
    Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 56574ba36555..1b673e19667c 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -119,6 +119,12 @@ typedef enum {
 	NAND_ECC_SOFT_BCH,
 } nand_ecc_modes_t;
 
+enum nand_ecc_algo {
+	NAND_ECC_UNKNOWN,
+	NAND_ECC_HAMMING,
+	NAND_ECC_BCH,
+};
+
 /*
  * Constants for Hardware ECC
  */
@@ -458,6 +464,7 @@ struct nand_hw_control {
 /**
  * struct nand_ecc_ctrl - Control structure for ECC
  * @mode:	ECC mode
+ * @algo:	ECC algorithm
  * @steps:	number of ECC steps per page
  * @size:	data bytes per ECC step
  * @bytes:	ECC bytes per step
@@ -508,6 +515,7 @@ struct nand_hw_control {
  */
 struct nand_ecc_ctrl {
 	nand_ecc_modes_t mode;
+	enum nand_ecc_algo algo;
 	int steps;
 	int size;
 	int bytes;

commit 9f3e04297b08212ef43fce4f167e01f40a98d243
Author: Archit Taneja <architt@codeaurora.org>
Date:   Wed Feb 3 14:29:49 2016 +0530

    mtd: nand: don't select chip in nand_chip's block_bad op
    
    One of the arguments passed to struct nand_chip's block_bad op is
    'getchip', which, if true, is supposed to get and select the nand device,
    and later unselect and release the device.
    
    This op is intended to be replaceable by drivers. The drivers shouldn't
    be responsible for selecting/unselecting chip. Like other ops, the chip
    should already be selected before the block_bad op is called.
    
    Remove the getchip argument from the block_bad op and
    nand_block_checkbad. Move the chip selection to nand_block_isbad, since it
    is the only caller to nand_block_checkbad which requires chip selection.
    
    Modify nand_block_bad (the default function for the op) such that it
    doesn't select the chip.
    
    Remove the getchip argument from the bad_block funcs in cafe_nand,
    diskonchip and docg4 drivers.
    
    Reviewed-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 7604f4be3386..56574ba36555 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -672,7 +672,7 @@ struct nand_chip {
 	void (*write_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
 	void (*read_buf)(struct mtd_info *mtd, uint8_t *buf, int len);
 	void (*select_chip)(struct mtd_info *mtd, int chip);
-	int (*block_bad)(struct mtd_info *mtd, loff_t ofs, int getchip);
+	int (*block_bad)(struct mtd_info *mtd, loff_t ofs);
 	int (*block_markbad)(struct mtd_info *mtd, loff_t ofs);
 	void (*cmd_ctrl)(struct mtd_info *mtd, int dat, unsigned int ctrl);
 	int (*dev_ready)(struct mtd_info *mtd);

commit 02db97a9de1c80bd5551ba46d901cb4d912f78f2
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Mon Dec 7 23:26:01 2015 +0100

    mtd: nand: kill unused ->ecclayout field in platform_nand_chip struct
    
    This field is not set in any board file and can thus be dropped.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index a13dfd5bc58b..7604f4be3386 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -902,7 +902,6 @@ extern int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
  * @chip_delay:		R/B delay value in us
  * @options:		Option flags, e.g. 16bit buswidth
  * @bbt_options:	BBT option flags, e.g. NAND_BBT_USE_FLASH
- * @ecclayout:		ECC layout info structure
  * @part_probe_types:	NULL-terminated array of probe types
  */
 struct platform_nand_chip {
@@ -910,7 +909,6 @@ struct platform_nand_chip {
 	int chip_offset;
 	int nr_partitions;
 	struct mtd_partition *partitions;
-	struct nand_ecclayout *ecclayout;
 	int chip_delay;
 	unsigned int options;
 	unsigned int bbt_options;

commit c03d996900f9d063b47ef7462885a9085c8a587f
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Wed Dec 2 12:01:05 2015 +0100

    mtd: nand: add NAND_NEED_SCRAMBLING option flag
    
    Some MLC NANDs are sensitive to repeated patterns and require data to be
    scrambled in order to limit the number of bitflips.
    Add a new flag to let the NAND controller know about this constraint.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index bdd68e22b5a5..a13dfd5bc58b 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -168,6 +168,12 @@ typedef enum {
 /* Device supports subpage reads */
 #define NAND_SUBPAGE_READ	0x00001000
 
+/*
+ * Some MLC NANDs need data scrambling to limit bitflips caused by repeated
+ * patterns.
+ */
+#define NAND_NEED_SCRAMBLING	0x00002000
+
 /* Options valid for Samsung large page devices */
 #define NAND_SAMSUNG_LP_OPTIONS NAND_CACHEPRG
 

commit d39ddbd9ef70949bb78283a067e1b3366111dd90
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Thu Dec 10 09:00:39 2015 +0100

    mtd: nand: add helpers to access ->priv
    
    Add two helpers to access the field reserved for private controller data.
    This makes it clearer what this field is reserved for and ease future
    refactoring.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 86487dbe7358..bdd68e22b5a5 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -755,6 +755,16 @@ static inline struct mtd_info *nand_to_mtd(struct nand_chip *chip)
 	return &chip->mtd;
 }
 
+static inline void *nand_get_controller_data(struct nand_chip *chip)
+{
+	return chip->priv;
+}
+
+static inline void nand_set_controller_data(struct nand_chip *chip, void *priv)
+{
+	chip->priv = priv;
+}
+
 /*
  * NAND Flash Manufacturer ID Codes
  */

commit 40cbe6eee97b706f27bcc4c6aa1018bbe4f1e577
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Wed Dec 30 20:32:04 2015 +0100

    mtd: nand: use nand_check_erased_ecc_chunk in default ECC read functions
    
    The default NAND read functions are relying on the underlying controller
    driver to correct bitflips, but some of those controllers cannot properly
    fix bitflips in erased pages.
    Check for bitflips in erased pages in default core functions if the driver
    delegated the this check by setting the NAND_ECC_GENERIC_ERASED_CHECK flag.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Tested-by: Franklin S Cooper Jr. <fcooper@ti.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 518958115182..86487dbe7358 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -129,6 +129,14 @@ typedef enum {
 /* Enable Hardware ECC before syndrome is read back from flash */
 #define NAND_ECC_READSYN	2
 
+/*
+ * Enable generic NAND 'page erased' check. This check is only done when
+ * ecc.correct() returns -EBADMSG.
+ * Set this flag if your implementation does not fix bitflips in erased
+ * pages and you want to rely on the default implementation.
+ */
+#define NAND_ECC_GENERIC_ERASED_CHECK	BIT(0)
+
 /* Bit mask for flags passed to do_nand_read_ecc */
 #define NAND_GET_DEVICE		0x80
 
@@ -451,6 +459,7 @@ struct nand_hw_control {
  * @total:	total number of ECC bytes per page
  * @prepad:	padding information for syndrome based ECC generators
  * @postpad:	padding information for syndrome based ECC generators
+ * @options:	ECC specific options (see NAND_ECC_XXX flags defined above)
  * @layout:	ECC layout control struct pointer
  * @priv:	pointer to private ECC control data
  * @hwctl:	function to control hardware ECC generator. Must only
@@ -500,6 +509,7 @@ struct nand_ecc_ctrl {
 	int strength;
 	int prepad;
 	int postpad;
+	unsigned int options;
 	struct nand_ecclayout	*layout;
 	void *priv;
 	void (*hwctl)(struct mtd_info *mtd, int mode);

commit 6e9411923b8f4c0e568cbae0f35b7ee4eb989914
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Wed Dec 30 20:32:03 2015 +0100

    mtd: nand: return consistent error codes in ecc.correct() implementations
    
    The error code returned by the ecc.correct() are not consistent over the
    all implementations.
    
    Document the expected behavior in include/linux/mtd/nand.h and fix
    offending implementations.
    
    [Brian: this looks like a bugfix for the ECC reporting in the bf5xx_nand
    driver, but we haven't seen any testing results for it]
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Tested-by: Franklin S Cooper Jr. <fcooper@ti.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 3e92be1d2d43..518958115182 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -456,7 +456,13 @@ struct nand_hw_control {
  * @hwctl:	function to control hardware ECC generator. Must only
  *		be provided if an hardware ECC is available
  * @calculate:	function for ECC calculation or readback from ECC hardware
- * @correct:	function for ECC correction, matching to ECC generator (sw/hw)
+ * @correct:	function for ECC correction, matching to ECC generator (sw/hw).
+ *		Should return a positive number representing the number of
+ *		corrected bitflips, -EBADMSG if the number of bitflips exceed
+ *		ECC strength, or any other error code if the error is not
+ *		directly related to correction.
+ *		If -EBADMSG is returned the input buffers should be left
+ *		untouched.
  * @read_page_raw:	function to read a raw page without ECC. This function
  *			should hide the specific layout used by the ECC
  *			controller and always return contiguous in-band and

commit 8142b47ef33c655a34e08efd46b65732fe190675
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Mon Dec 14 16:13:31 2015 +0100

    mtd: nand: remove unused and buggy get_platform_nandchip() helper function
    
    Nobody uses the get_platform_nandchip() helper function which is supposed
    to return a pointer to a platform_nand_chip struct from an mtd_info
    pointer.
    Moreover, this function is buggy since the introduction of the plat_nand
    layer (chip->priv is now storing a pointer to an intermediate
    plat_nand_data structure allocated in plat_nand_probe(), and we have no
    way to retrieve a pointer to the provided platform_nand_chip struct from
    this plat_nand_data pointer).
    
    While we are at it, remove the useless (and buggy, since it's pointing to
    something stored on the stack) data->chip.priv assignment.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Fixes: 711fdf627ce1 ("[MTD] [NAND] platform NAND driver: add driver")
    Cc: Vitaly Wool <vitalywool@gmail.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 2bee2e42ae2f..3e92be1d2d43 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -927,15 +927,6 @@ struct platform_nand_data {
 	struct platform_nand_ctrl ctrl;
 };
 
-/* Some helpers to access the data structures */
-static inline
-struct platform_nand_chip *get_platform_nandchip(struct mtd_info *mtd)
-{
-	struct nand_chip *chip = mtd->priv;
-
-	return chip->priv;
-}
-
 /* return the supported features. */
 static inline int onfi_feature(struct nand_chip *chip)
 {

commit 29574ede097438c560e8115caff9b6b8668730be
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Thu Dec 10 09:00:38 2015 +0100

    mtd: nand: kill the chip->flash_node field
    
    Now that the nand_chip struct directly embeds an mtd_info struct we can
    get rid of the ->flash_node field and forward set/get_flash_node requests
    to the MTD layer.
    
    As a side effect, we no longer need the mtd_set_of_node() call done in
    nand_dt_init().
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 9cb7ace6fb1f..2bee2e42ae2f 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -545,7 +545,6 @@ struct nand_buffers {
  *			flash device
  * @IO_ADDR_W:		[BOARDSPECIFIC] address to write the 8 I/O lines of the
  *			flash device.
- * @flash_node:		[BOARDSPECIFIC] device node describing this instance
  * @read_byte:		[REPLACEABLE] read one byte from the chip
  * @read_word:		[REPLACEABLE] read one word from the chip
  * @write_byte:		[REPLACEABLE] write a single byte to the chip on the
@@ -645,8 +644,6 @@ struct nand_chip {
 	void __iomem *IO_ADDR_R;
 	void __iomem *IO_ADDR_W;
 
-	struct device_node *flash_node;
-
 	uint8_t (*read_byte)(struct mtd_info *mtd);
 	u16 (*read_word)(struct mtd_info *mtd);
 	void (*write_byte)(struct mtd_info *mtd, uint8_t byte);
@@ -724,12 +721,12 @@ struct nand_chip {
 static inline void nand_set_flash_node(struct nand_chip *chip,
 				       struct device_node *np)
 {
-	chip->flash_node = np;
+	mtd_set_of_node(&chip->mtd, np);
 }
 
 static inline struct device_node *nand_get_flash_node(struct nand_chip *chip)
 {
-	return chip->flash_node;
+	return mtd_get_of_node(&chip->mtd);
 }
 
 static inline struct nand_chip *mtd_to_nand(struct mtd_info *mtd)

commit 2d3b77bac34bf99d7fdfd712ec2dc4317b3e850b
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Thu Dec 10 09:00:33 2015 +0100

    mtd: nand: update mtd_to_nand()
    
    Now that all drivers are using the mtd instance embedded in the nand_chip
    struct we can safely update the mtd_to_nand() implementation to use
    the container_of macro instead of returning the content of mtd->priv.
    This will allow us to remove mtd->priv = chip assignments done in all
    NAND controller drivers.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index b614ed2105ac..9cb7ace6fb1f 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -734,7 +734,7 @@ static inline struct device_node *nand_get_flash_node(struct nand_chip *chip)
 
 static inline struct nand_chip *mtd_to_nand(struct mtd_info *mtd)
 {
-	return mtd->priv;
+	return container_of(mtd, struct nand_chip, mtd);
 }
 
 static inline struct mtd_info *nand_to_mtd(struct nand_chip *chip)

commit ffd014f43fdcb6edb5a7f302de1e717e8c0673d5
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Tue Dec 1 12:03:07 2015 +0100

    mtd: nand: add nand_to_mtd() helper
    
    Add a new helper to retrieve the MTD device attached to a NAND chip.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index d6710575ddb6..b614ed2105ac 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -737,6 +737,11 @@ static inline struct nand_chip *mtd_to_nand(struct mtd_info *mtd)
 	return mtd->priv;
 }
 
+static inline struct mtd_info *nand_to_mtd(struct nand_chip *chip)
+{
+	return &chip->mtd;
+}
+
 /*
  * NAND Flash Manufacturer ID Codes
  */

commit ed4f85c03cc7460a2f76afb73c22b8894b44ee20
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Tue Dec 1 12:03:06 2015 +0100

    mtd: nand: embed an mtd_info structure into nand_chip
    
    Currently all NAND controller drivers are providing both the mtd_info and
    nand_chip struct and then let the NAND subsystem to initialize a few
    things before registering the mtd instance to the MTD layer.
    Embed an mtd_info field into nand_chip to add some consistency to all NAND
    controller drivers.
    This change will also help factorizing boilerplate code copied in all NAND
    drivers.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index fad634ea1685..d6710575ddb6 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -540,6 +540,7 @@ struct nand_buffers {
 
 /**
  * struct nand_chip - NAND Private Flash Chip Data
+ * @mtd:		MTD device registered to the MTD framework
  * @IO_ADDR_R:		[BOARDSPECIFIC] address to read the 8 I/O lines of the
  *			flash device
  * @IO_ADDR_W:		[BOARDSPECIFIC] address to write the 8 I/O lines of the
@@ -640,6 +641,7 @@ struct nand_buffers {
  */
 
 struct nand_chip {
+	struct mtd_info mtd;
 	void __iomem *IO_ADDR_R;
 	void __iomem *IO_ADDR_W;
 

commit 74e98be45fe069fcdb00f35eccbb179309ab65cd
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Dec 1 11:08:32 2015 -0800

    mtd: nand: fix typo (t_ald -> t_adl)
    
    It's "ADL" ("ALE to data loading" time) not "ALD".
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Reviewed-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index eaf48b5a95dd..fad634ea1685 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -283,7 +283,7 @@ struct nand_onfi_params {
 	u8 input_pin_capacitance_max;
 	u8 driver_strength_support;
 	__le16 t_int_r;
-	__le16 t_ald;
+	__le16 t_adl;
 	u8 reserved4[8];
 
 	/* vendor */
@@ -407,7 +407,7 @@ struct nand_jedec_params {
 	__le16 input_pin_capacitance_typ;
 	__le16 clk_pin_capacitance_typ;
 	u8 driver_strength_support;
-	__le16 t_ald;
+	__le16 t_adl;
 	u8 reserved4[36];
 
 	/* ECC and endurance block */

commit de64aa9ec129ba627634088f662a4d09e356ddb6
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Mon Nov 23 11:23:07 2015 +0100

    mtd: nand: fix ONFI parameter page layout
    
    src_ssync_features field is only 1 byte large, and the 4th reserved area
    is actually 8 bytes large.
    
    Fixes: d1e1f4e42b5 ("mtd: nand: add support for reading ONFI parameters from NAND device")
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 056d1650eb89..eaf48b5a95dd 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -276,7 +276,7 @@ struct nand_onfi_params {
 	__le16 t_r;
 	__le16 t_ccs;
 	__le16 src_sync_timing_mode;
-	__le16 src_ssync_features;
+	u8 src_ssync_features;
 	__le16 clk_pin_capacitance_typ;
 	__le16 io_pin_capacitance_typ;
 	__le16 input_pin_capacitance_typ;
@@ -284,7 +284,7 @@ struct nand_onfi_params {
 	u8 driver_strength_support;
 	__le16 t_int_r;
 	__le16 t_ald;
-	u8 reserved4[7];
+	u8 reserved4[8];
 
 	/* vendor */
 	__le16 vendor_revision;

commit c291b3c3527fa962f53862426e0e4258d7bd8269
Merge: 1d8d8b5c852b 9eba47ddd8fe
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Thu Nov 19 11:10:41 2015 -0800

    mtd: merge in mtd_to_nand() branch
    
    In case other subsystems want to merge in this helper for use in their
    drivers, let's bring in that development separately from the rest of
    MTD -next development.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

commit 9eba47ddd8fee8a21f45e6e1d707103f040d90c7
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Mon Nov 16 14:37:35 2015 +0100

    mtd: nand: add an mtd_to_nand() helper
    
    Some drivers are retrieving the nand_chip pointer using the container_of
    macro on a struct wrapping both the nand_chip and the mtd_info struct while
    the standard way of retrieving this pointer is through mtd->priv.
    Provide an helper to do that.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 5a9d1d4c2487..a4839b3f27da 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -719,6 +719,11 @@ struct nand_chip {
 	void *priv;
 };
 
+static inline struct nand_chip *mtd_to_nand(struct mtd_info *mtd)
+{
+	return mtd->priv;
+}
+
 /*
  * NAND Flash Manufacturer ID Codes
  */

commit 28b8b26b308e656edfa9467867d5f79212da2ec3
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Oct 30 20:33:20 2015 -0700

    mtd: add get/set of_node/flash_node helpers
    
    We are going to begin using the mtd->dev.of_node field for MTD device
    nodes, so let's add helpers for it. Also, we'll be making some
    conversions on spi_nor (and nand_chip eventually) too, so get that ready
    with their own helpers.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Reviewed-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 5a9d1d4c2487..4f7c9b97982f 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -719,6 +719,17 @@ struct nand_chip {
 	void *priv;
 };
 
+static inline void nand_set_flash_node(struct nand_chip *chip,
+				       struct device_node *np)
+{
+	chip->flash_node = np;
+}
+
+static inline struct device_node *nand_get_flash_node(struct nand_chip *chip)
+{
+	return chip->flash_node;
+}
+
 /*
  * NAND Flash Manufacturer ID Codes
  */

commit 45aaeff947190e4b57b2d0db4d74ab5eea450825
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Tue Oct 13 11:22:18 2015 +0200

    mtd: nand: pass page number to ecc->write_xxx() methods
    
    The ->read_xxx() methods are all passed the page number the NAND controller
    is supposed to read, but ->write_xxx() do not have such a parameter.
    
    This is a problem if we want to properly implement data
    scrambling/randomization in order to mitigate MLC sensibility to repeated
    pattern: to prevent bitflips in adjacent pages in the same block we need
    to avoid repeating the same pattern at the same offset in those pages,
    hence the randomizer/scrambler engine need to be passed the page value
    in order to adapt its seed accordingly.
    
    Moreover, adding the page parameter to the ->write_xxx() methods add some
    consistency to the current API.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    CC: Josh Wu <josh.wu@atmel.com>
    CC: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    CC: Maxime Ripard <maxime.ripard@free-electrons.com>
    CC: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    CC: Huang Shijie <shijie.huang@arm.com>
    CC: Stefan Agner <stefan@agner.ch>
    CC: devel@driverdev.osuosl.org
    CC: linux-arm-kernel@lists.infradead.org
    CC: linux-kernel@vger.kernel.org
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 50e1f94fa377..5a9d1d4c2487 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -504,16 +504,16 @@ struct nand_ecc_ctrl {
 	int (*read_page_raw)(struct mtd_info *mtd, struct nand_chip *chip,
 			uint8_t *buf, int oob_required, int page);
 	int (*write_page_raw)(struct mtd_info *mtd, struct nand_chip *chip,
-			const uint8_t *buf, int oob_required);
+			const uint8_t *buf, int oob_required, int page);
 	int (*read_page)(struct mtd_info *mtd, struct nand_chip *chip,
 			uint8_t *buf, int oob_required, int page);
 	int (*read_subpage)(struct mtd_info *mtd, struct nand_chip *chip,
 			uint32_t offs, uint32_t len, uint8_t *buf, int page);
 	int (*write_subpage)(struct mtd_info *mtd, struct nand_chip *chip,
 			uint32_t offset, uint32_t data_len,
-			const uint8_t *data_buf, int oob_required);
+			const uint8_t *data_buf, int oob_required, int page);
 	int (*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
-			const uint8_t *buf, int oob_required);
+			const uint8_t *buf, int oob_required, int page);
 	int (*write_oob_raw)(struct mtd_info *mtd, struct nand_chip *chip,
 			int page);
 	int (*read_oob_raw)(struct mtd_info *mtd, struct nand_chip *chip,

commit a7f5ba40c74e67b2c8c6e15425157ab6775621d7
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Thu Oct 1 16:58:27 2015 +0200

    mtd: nand: remove unused ->init_size() hook
    
    The ->init_size() hook was introduced to let NAND controller drivers
    support NAND devices that could not be described in the nand_ids table.
    Since then, the core has added support for extended-id parsing and
    full-id description, thus allowing to describe pretty much all existing
    NANDs.
    Moreover, this hook is not used by any mainline driver, and should not be
    used by new drivers, because detecting the NAND chip is not something
    controller specific.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index c4d8e308f453..50e1f94fa377 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -556,10 +556,6 @@ struct nand_buffers {
  * @block_markbad:	[REPLACEABLE] mark a block bad
  * @cmd_ctrl:		[BOARDSPECIFIC] hardwarespecific function for controlling
  *			ALE/CLE/nCE. Also used to write command and address
- * @init_size:		[BOARDSPECIFIC] hardwarespecific function for setting
- *			mtd->oobsize, mtd->writesize and so on.
- *			@id_data contains the 8 bytes values of NAND_CMD_READID.
- *			Return with the bus width.
  * @dev_ready:		[BOARDSPECIFIC] hardwarespecific function for accessing
  *			device ready/busy line. If set to NULL no access to
  *			ready/busy is available and the ready/busy information
@@ -658,8 +654,6 @@ struct nand_chip {
 	int (*block_bad)(struct mtd_info *mtd, loff_t ofs, int getchip);
 	int (*block_markbad)(struct mtd_info *mtd, loff_t ofs);
 	void (*cmd_ctrl)(struct mtd_info *mtd, int dat, unsigned int ctrl);
-	int (*init_size)(struct mtd_info *mtd, struct nand_chip *this,
-			u8 *id_data);
 	int (*dev_ready)(struct mtd_info *mtd);
 	void (*cmdfunc)(struct mtd_info *mtd, unsigned command, int column,
 			int page_addr);

commit 730a43fbc135e593cc3de3b1b895e49c05c8e2dc
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Thu Sep 3 18:03:38 2015 +0200

    mtd: nand: add nand_check_erased helper functions
    
    Add two helper functions to help NAND controller drivers test whether a
    specific NAND region is erased or not.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 3140b3d94838..c4d8e308f453 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -1030,4 +1030,9 @@ struct nand_sdr_timings {
 
 /* get timing characteristics from ONFI timing mode. */
 const struct nand_sdr_timings *onfi_async_timing_mode_to_sdr_timings(int mode);
+
+int nand_check_erased_ecc_chunk(void *data, int datalen,
+				void *ecc, int ecclen,
+				void *extraoob, int extraooblen,
+				int threshold);
 #endif /* __LINUX_MTD_NAND_H */

commit 61528d888adf9470db73aaadf1ff9ca35942262a
Author: Marek Vasut <marex@denx.de>
Date:   Thu Sep 3 18:35:37 2015 +0200

    mtd: nand: Rename nand_chip .dn to .flash_node
    
    Use a more descriptive name for the device_node element in struct nand_chip .
    This name matches the element name used for device_node property of a flash
    in the spi-nor framework.
    
    Signed-off-by: Marek Vasut <marex@denx.de>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 272f42952f34..3140b3d94838 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -544,7 +544,7 @@ struct nand_buffers {
  *			flash device
  * @IO_ADDR_W:		[BOARDSPECIFIC] address to write the 8 I/O lines of the
  *			flash device.
- * @dn:			[BOARDSPECIFIC] device node describing this instance
+ * @flash_node:		[BOARDSPECIFIC] device node describing this instance
  * @read_byte:		[REPLACEABLE] read one byte from the chip
  * @read_word:		[REPLACEABLE] read one word from the chip
  * @write_byte:		[REPLACEABLE] write a single byte to the chip on the
@@ -647,7 +647,7 @@ struct nand_chip {
 	void __iomem *IO_ADDR_R;
 	void __iomem *IO_ADDR_W;
 
-	struct device_node *dn;
+	struct device_node *flash_node;
 
 	uint8_t (*read_byte)(struct mtd_info *mtd);
 	u16 (*read_word)(struct mtd_info *mtd);

commit 5f867db63473f32cce1b868e281ebd42a41f8fad
Author: Scott Wood <scottwood@freescale.com>
Date:   Fri Jun 26 19:43:58 2015 -0500

    mtd: nand: Fix NAND_USE_BOUNCE_BUFFER flag conflict
    
    Commit 66507c7bc8895f0da6b ("mtd: nand: Add support to use nand_base
    poi databuf as bounce buffer") added a flag NAND_USE_BOUNCE_BUFFER
    using the same bit value as the existing NAND_BUSWIDTH_AUTO.
    
    Cc: Kamal Dasu <kdasu.kdev@gmail.com>
    Fixes: 66507c7bc8895f0da6b ("mtd: nand: Add support to use nand_base
            poi databuf as bounce buffer")
    Signed-off-by: Scott Wood <scottwood@freescale.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index f25e2bdd188c..272f42952f34 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -177,11 +177,6 @@ typedef enum {
 #define NAND_OWN_BUFFERS	0x00020000
 /* Chip may not exist, so silence any errors in scan */
 #define NAND_SCAN_SILENT_NODEV	0x00040000
-/*
- * This option could be defined by controller drivers to protect against
- * kmap'ed, vmalloc'ed highmem buffers being passed from upper layers
- */
-#define NAND_USE_BOUNCE_BUFFER	0x00080000
 /*
  * Autodetect nand buswidth with readid/onfi.
  * This suppose the driver will configure the hardware in 8 bits mode
@@ -189,6 +184,11 @@ typedef enum {
  * before calling nand_scan_tail.
  */
 #define NAND_BUSWIDTH_AUTO      0x00080000
+/*
+ * This option could be defined by controller drivers to protect against
+ * kmap'ed, vmalloc'ed highmem buffers being passed from upper layers
+ */
+#define NAND_USE_BOUNCE_BUFFER	0x00100000
 
 /* Options set by nand scan */
 /* Nand scan has allocated controller struct */

commit 5844feeaa4154d1c46d3462c7a4653d22356d8b4
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Jan 23 00:22:27 2015 -0800

    mtd: nand: add common DT init code
    
    These are already-documented common bindings for NAND chips. Let's
    handle them in nand_base.
    
    If NAND controller drivers need to act on this data before bringing up
    the NAND chip (e.g., fill out ECC callback functions, change HW modes,
    etc.), then they can do so between calling nand_scan_ident() and
    nand_scan_tail().
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 6c51876941f3..f25e2bdd188c 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -26,6 +26,8 @@
 
 struct mtd_info;
 struct nand_flash_dev;
+struct device_node;
+
 /* Scan and identify a NAND device */
 extern int nand_scan(struct mtd_info *mtd, int max_chips);
 /*
@@ -542,6 +544,7 @@ struct nand_buffers {
  *			flash device
  * @IO_ADDR_W:		[BOARDSPECIFIC] address to write the 8 I/O lines of the
  *			flash device.
+ * @dn:			[BOARDSPECIFIC] device node describing this instance
  * @read_byte:		[REPLACEABLE] read one byte from the chip
  * @read_word:		[REPLACEABLE] read one word from the chip
  * @write_byte:		[REPLACEABLE] write a single byte to the chip on the
@@ -644,6 +647,8 @@ struct nand_chip {
 	void __iomem *IO_ADDR_R;
 	void __iomem *IO_ADDR_W;
 
+	struct device_node *dn;
+
 	uint8_t (*read_byte)(struct mtd_info *mtd);
 	u16 (*read_word)(struct mtd_info *mtd);
 	void (*write_byte)(struct mtd_info *mtd, uint8_t byte);

commit 17799359e7b3fa6ef4f2bf926cd6821cf7903ecf
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Sat Feb 28 02:13:11 2015 -0800

    mtd: nand_bbt: make nand_scan_bbt() static
    
    This implementation detail is no longer needed outside of nand_bbt.c.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 3d4ea7eb2b68..6c51876941f3 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -833,7 +833,6 @@ struct nand_manufacturers {
 extern struct nand_flash_dev nand_flash_ids[];
 extern struct nand_manufacturers nand_manuf_ids[];
 
-extern int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd);
 extern int nand_default_bbt(struct mtd_info *mtd);
 extern int nand_markbad_bbt(struct mtd_info *mtd, loff_t offs);
 extern int nand_isreserved_bbt(struct mtd_info *mtd, loff_t offs);

commit 641519cb61bc766c3b4a70fd9ef14fc9509bf8bf
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Nov 4 11:32:45 2014 -0800

    mtd: nand: add ATO manufacturer info
    
    Tested with ATO AFND1G08U3, 128MiB NAND.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index b14d190b593a..3d4ea7eb2b68 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -736,6 +736,7 @@ struct nand_chip {
 #define NAND_MFR_EON		0x92
 #define NAND_MFR_SANDISK	0x45
 #define NAND_MFR_INTEL		0x89
+#define NAND_MFR_ATO		0x9b
 
 /* The maximum expected count of bytes in the NAND ID sequence */
 #define NAND_MAX_ID_LEN 8

commit 62d956dc3e11138c5ffd4b2c62e4f909c5180a12
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Mon Oct 20 10:46:14 2014 +0200

    mtd: nand: provide detailed description for raw read/write page methods
    
    read_page_raw and write_page_raw method description is not clear enough.
    It clearly specifies that ECC correction should not be involved but does
    not talk about specific layout (by layout I mean where in-band and
    out-of-band data are stored on the NAND media) used by NAND/ECC
    controllers.
    
    Those specific layouts might impact MTD users and thus should be hidden (as
    already done in the standard NAND_ECC_HW_SYNDROME implementation).
    
    Clearly state this constraint in the nand_ecc_ctrl struct documentation.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index e4d451e4600b..b14d190b593a 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -455,8 +455,21 @@ struct nand_hw_control {
  *		be provided if an hardware ECC is available
  * @calculate:	function for ECC calculation or readback from ECC hardware
  * @correct:	function for ECC correction, matching to ECC generator (sw/hw)
- * @read_page_raw:	function to read a raw page without ECC
- * @write_page_raw:	function to write a raw page without ECC
+ * @read_page_raw:	function to read a raw page without ECC. This function
+ *			should hide the specific layout used by the ECC
+ *			controller and always return contiguous in-band and
+ *			out-of-band data even if they're not stored
+ *			contiguously on the NAND chip (e.g.
+ *			NAND_ECC_HW_SYNDROME interleaves in-band and
+ *			out-of-band data).
+ * @write_page_raw:	function to write a raw page without ECC. This function
+ *			should hide the specific layout used by the ECC
+ *			controller and consider the passed data as contiguous
+ *			in-band and out-of-band data. ECC controller is
+ *			responsible for doing the appropriate transformations
+ *			to adapt to its specific layout (e.g.
+ *			NAND_ECC_HW_SYNDROME interleaves in-band and
+ *			out-of-band data).
  * @read_page:	function to read a page according to the ECC generator
  *		requirements; returns maximum number of bitflips corrected in
  *		any single ECC step, 0 if bitflips uncorrectable, -EIO hw error

commit 57a94e24bc927f642f7f48ca1bf5476aa5be269d
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Mon Sep 22 20:11:50 2014 +0200

    mtd: nand: support ONFI timing mode retrieval for non-ONFI NANDs
    
    Add an onfi_timing_mode_default field to nand_chip and nand_flash_dev in
    order to support NAND timings definition for non-ONFI NAND.
    
    NAND that support better timings mode than the default one have to define
    a new entry in the nand_ids table.
    
    The default timing mode should be deduced from timings description from
    the datasheet and the ONFI specification
    (www.onfi.org/~/media/ONFI/specs/onfi_3_1_spec.pdf, chapter 4.15
    "Timing Parameters").
    You should choose the closest mode that fit the timings requirements of
    your NAND chip.
    
    Signed-off-by: Boris BREZILLON <boris.brezillon@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 8acb307b6fde..e4d451e4600b 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -587,6 +587,11 @@ struct nand_buffers {
  * @ecc_step_ds:	[INTERN] ECC step required by the @ecc_strength_ds,
  *                      also from the datasheet. It is the recommended ECC step
  *			size, if known; if unknown, set to zero.
+ * @onfi_timing_mode_default: [INTERN] default ONFI timing mode. This field is
+ *			      either deduced from the datasheet if the NAND
+ *			      chip is not ONFI compliant or set to 0 if it is
+ *			      (an ONFI chip is always configured in mode 0
+ *			      after a NAND reset)
  * @numchips:		[INTERN] number of physical chips
  * @chipsize:		[INTERN] the size of one chip for multichip arrays
  * @pagemask:		[INTERN] page number mask = number of (pages / chip) - 1
@@ -671,6 +676,7 @@ struct nand_chip {
 	uint8_t bits_per_cell;
 	uint16_t ecc_strength_ds;
 	uint16_t ecc_step_ds;
+	int onfi_timing_mode_default;
 	int badblockpos;
 	int badblockbits;
 
@@ -773,6 +779,10 @@ struct nand_chip {
  *               @ecc_step_ds in nand_chip{}, also from the datasheet.
  *               For example, the "4bit ECC for each 512Byte" can be set with
  *               NAND_ECC_INFO(4, 512).
+ * @onfi_timing_mode_default: the default ONFI timing mode entered after a NAND
+ *			      reset. Should be deduced from timings described
+ *			      in the datasheet.
+ *
  */
 struct nand_flash_dev {
 	char *name;
@@ -793,6 +803,7 @@ struct nand_flash_dev {
 		uint16_t strength_ds;
 		uint16_t step_ds;
 	} ecc;
+	int onfi_timing_mode_default;
 };
 
 /**

commit 5b49ab3e03f68eb49db4bce6290e5707b7f6c6f3
Merge: b25046b1e5e3 54ea17a597b0
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Aug 19 11:57:23 2014 -0700

    Merge l2-mtd/next into l2-mtd/master

commit b25046b1e5e3f1423434da77ccc859f2f779d1ce
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Sun Aug 17 10:29:42 2014 +0200

    mtd: nand: fix DocBook warnings on nand_sdr_timings doc
    
    Change the comment type (from /** to /*) to prevent DocBook from
    complaining about missing description for nand_sdr_timings fields.
    
    There is currently no need in documenting those fields because they are
    fully described in the ONFI specification (which is pointed out in the
    comment).
    
    Signed-off-by: Boris BREZILLON <boris.brezillon@free-electrons.com>
    Reported-by: Randy Dunlap <rdunlap@infradead.org>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Tested-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 3083c53e0270..c300db3ae285 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -949,7 +949,7 @@ static inline int jedec_feature(struct nand_chip *chip)
 		: 0;
 }
 
-/**
+/*
  * struct nand_sdr_timings - SDR NAND chip timings
  *
  * This struct defines the timing requirements of a SDR NAND chip.

commit 7b7d8982f0169d5ac67c6c2877449fb7f6968cac
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Sun Jul 27 14:31:53 2014 -0700

    mtd: fix linux/mtd/nand.h kernel-doc warning
    
    Fix kernel-doc warning in <linux/mtd/nand.h>:
    
    Warning(..//include/linux/mtd/nand.h:795): No description found for parameter 'ecc'
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Cc:     David Woodhouse <dwmw2@infradead.org>
    Cc:     Brian Norris <computersforpeace@gmail.com>
    Cc:     linux-mtd@lists.infradead.org
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 3083c53e0270..b7c11991cb09 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -766,6 +766,7 @@ struct nand_chip {
  * @options: stores various chip bit options
  * @id_len: The valid length of the @id.
  * @oobsize: OOB size
+ * @ecc: ECC correctability and step information from the datasheet.
  * @ecc.strength_ds: The ECC correctability from the datasheet, same as the
  *                   @ecc_strength_ds in nand_chip{}.
  * @ecc.step_ds: The ECC step required by the @ecc.strength_ds, same as the

commit 974647ea8a13021a91d558df61d598bcabf73439
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Fri Jul 11 09:49:42 2014 +0200

    mtd: nand: add ONFI timing mode to nand_timings converter
    
    Add a converter to retrieve NAND timings from an ONFI NAND timing mode.
    At the moment, only SDR NAND timings are supported.
    
    Signed-off-by: Boris BREZILLON <boris.brezillon@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index cdda207c16e1..3083c53e0270 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -997,4 +997,7 @@ struct nand_sdr_timings {
 	u32 tWP_min;
 	u32 tWW_min;
 };
+
+/* get timing characteristics from ONFI timing mode. */
+const struct nand_sdr_timings *onfi_async_timing_mode_to_sdr_timings(int mode);
 #endif /* __LINUX_MTD_NAND_H */

commit bb5fd0b6daaf0da0b1e78c699b8582984373d3f4
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Fri Jul 11 09:49:41 2014 +0200

    mtd: nand: define struct nand_timings
    
    Define a struct containing the standard NAND timings as described in NAND
    datasheets.
    
    Signed-off-by: Boris BREZILLON <boris.brezillon@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 1cff329ae13d..cdda207c16e1 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -948,4 +948,53 @@ static inline int jedec_feature(struct nand_chip *chip)
 	return chip->jedec_version ? le16_to_cpu(chip->jedec_params.features)
 		: 0;
 }
+
+/**
+ * struct nand_sdr_timings - SDR NAND chip timings
+ *
+ * This struct defines the timing requirements of a SDR NAND chip.
+ * These informations can be found in every NAND datasheets and the timings
+ * meaning are described in the ONFI specifications:
+ * www.onfi.org/~/media/ONFI/specs/onfi_3_1_spec.pdf (chapter 4.15 Timing
+ * Parameters)
+ *
+ * All these timings are expressed in picoseconds.
+ */
+
+struct nand_sdr_timings {
+	u32 tALH_min;
+	u32 tADL_min;
+	u32 tALS_min;
+	u32 tAR_min;
+	u32 tCEA_max;
+	u32 tCEH_min;
+	u32 tCH_min;
+	u32 tCHZ_max;
+	u32 tCLH_min;
+	u32 tCLR_min;
+	u32 tCLS_min;
+	u32 tCOH_min;
+	u32 tCS_min;
+	u32 tDH_min;
+	u32 tDS_min;
+	u32 tFEAT_max;
+	u32 tIR_min;
+	u32 tITC_max;
+	u32 tRC_min;
+	u32 tREA_max;
+	u32 tREH_min;
+	u32 tRHOH_min;
+	u32 tRHW_min;
+	u32 tRHZ_max;
+	u32 tRLOH_min;
+	u32 tRP_min;
+	u32 tRR_min;
+	u64 tRST_max;
+	u32 tWB_max;
+	u32 tWC_min;
+	u32 tWH_min;
+	u32 tWHR_min;
+	u32 tWP_min;
+	u32 tWW_min;
+};
 #endif /* __LINUX_MTD_NAND_H */

commit 8471bb73ba10ed6788b4f1e9b8a0f9dc6bdb05b5
Author: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
Date:   Wed May 21 19:06:12 2014 -0300

    mtd: Introduce mtd_block_isreserved()
    
    In addition to mtd_block_isbad(), which checks if a block is bad or
    reserved, it's needed to check if a block is reserved only (but not
    bad). This commit adds an MTD interface for it, in a similar fashion to
    mtd_block_isbad().
    
    While here, fix mtd_block_isbad() so the out-of-bounds checking is done
    before the callback check.
    
    Signed-off-by: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Tested-by: Pekon Gupta <pekon@ti.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 2f0af2891f0f..1cff329ae13d 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -810,6 +810,7 @@ extern struct nand_manufacturers nand_manuf_ids[];
 extern int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd);
 extern int nand_default_bbt(struct mtd_info *mtd);
 extern int nand_markbad_bbt(struct mtd_info *mtd, loff_t offs);
+extern int nand_isreserved_bbt(struct mtd_info *mtd, loff_t offs);
 extern int nand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt);
 extern int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
 			   int allowbbt);

commit 66507c7bc8895f0da6b4ad87e96d61a9f7d7a118
Author: Kamal Dasu <kdasu.kdev@gmail.com>
Date:   Thu May 1 20:51:19 2014 -0400

    mtd: nand: Add support to use nand_base poi databuf as bounce buffer
    
    nand_base can be passed a kmap()'d buffers from highmem by
    filesystems like jffs2. This results in failure to map the
    physical address of the DMA buffer on various contoller
    driver on different platforms. This change adds a chip option
    to use preallocated databuf as bounce buffers used in
    nand_do_read_ops() and nand_do_write_ops().
    This allows for specific nand controller driver to set this
    option as needed.
    
    Signed-off-by: Kamal Dasu <kdasu.kdev@gmail.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 7a922e6c4e4b..2f0af2891f0f 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -175,6 +175,11 @@ typedef enum {
 #define NAND_OWN_BUFFERS	0x00020000
 /* Chip may not exist, so silence any errors in scan */
 #define NAND_SCAN_SILENT_NODEV	0x00040000
+/*
+ * This option could be defined by controller drivers to protect against
+ * kmap'ed, vmalloc'ed highmem buffers being passed from upper layers
+ */
+#define NAND_USE_BOUNCE_BUFFER	0x00080000
 /*
  * Autodetect nand buswidth with readid/onfi.
  * This suppose the driver will configure the hardware in 8 bits mode

commit 49c50b97b5522a987b80fbbf9d9869deee8d23b0
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue May 6 16:02:19 2014 -0700

    mtd: nand: refactor erase_cmd() to return chip status
    
    The nand_chip::erase_cmd callback previously served a dual purpose; for
    one, it allowed a per-flash-chip override, so that AG-AND devices could
    use a different erase command than other NAND. These AND devices were
    dropped in commit 14c6578683367b1e7af0c3c09e872b45a45183a7 (mtd: nand:
    remove AG-AND support). On the other hand, some drivers (denali and
    doc-g4) need to use this sort of callback to implement
    controller-specific erase operations.
    
    To make the latter operation easier for some drivers (e.g., ST's new BCH
    NAND driver), it helps if the command dispatch and wait functions can be
    lumped together, rather than called separately.
    
    This patch does two things:
     1. Pull the call to chip->waitfunc() into chip->erase_cmd(), and return
        the status from this callback
     2. Rename erase_cmd() to just erase(), since this callback does a
        little more than just send a command
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Tested-by: Lee Jones <lee.jones@linaro.org>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 450d61ec7f06..7a922e6c4e4b 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -552,8 +552,7 @@ struct nand_buffers {
  * @ecc:		[BOARDSPECIFIC] ECC control structure
  * @buffers:		buffer structure for read/write
  * @hwcontrol:		platform-specific hardware control structure
- * @erase_cmd:		[INTERN] erase command write function, selectable due
- *			to AND support.
+ * @erase:		[REPLACEABLE] erase function
  * @scan_bbt:		[REPLACEABLE] function to scan bad block table
  * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transferring
  *			data from array to read regs (tR).
@@ -637,7 +636,7 @@ struct nand_chip {
 	void (*cmdfunc)(struct mtd_info *mtd, unsigned command, int column,
 			int page_addr);
 	int(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this);
-	void (*erase_cmd)(struct mtd_info *mtd, int page);
+	int (*erase)(struct mtd_info *mtd, int page);
 	int (*scan_bbt)(struct mtd_info *mtd);
 	int (*errstat)(struct mtd_info *mtd, struct nand_chip *this, int state,
 			int status, int page);

commit e34fcb07a6d57411de6e15a47724fbe92c5caa42
Author: David Mosberger <davidm@egauge.net>
Date:   Fri Mar 21 16:05:10 2014 -0600

    mtd: nand: fix GET/SET_FEATURES address on 16-bit devices
    
    GET_FEATURES and SET_FEATURES also need byte-addressing on 16-bit devices.
    
    Signed-off-by: David Mosberger <davidm@egauge.net>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 0747fef2bfc6..450d61ec7f06 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -925,7 +925,16 @@ static inline bool nand_is_slc(struct nand_chip *chip)
  */
 static inline int nand_opcode_8bits(unsigned int command)
 {
-	return command == NAND_CMD_READID || command == NAND_CMD_PARAM;
+	switch (command) {
+	case NAND_CMD_READID:
+	case NAND_CMD_PARAM:
+	case NAND_CMD_GET_FEATURES:
+	case NAND_CMD_SET_FEATURES:
+		return 1;
+	default:
+		break;
+	}
+	return 0;
 }
 
 /* return the supported JEDEC features. */

commit e004debdadf1a661dcd24e2a654e56b0a113e29e
Author: Huang Shijie <b32955@freescale.com>
Date:   Fri Jan 3 11:01:40 2014 +0800

    mtd: nand: add "page" argument for read_subpage hook
    
    Add the "page" argument for the read_subpage hook. With this argument,
    the implementation of this hook could prints out more accurate information
    for debugging.
    
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index aa005e87d161..0747fef2bfc6 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -488,7 +488,7 @@ struct nand_ecc_ctrl {
 	int (*read_page)(struct mtd_info *mtd, struct nand_chip *chip,
 			uint8_t *buf, int oob_required, int page);
 	int (*read_subpage)(struct mtd_info *mtd, struct nand_chip *chip,
-			uint32_t offs, uint32_t len, uint8_t *buf);
+			uint32_t offs, uint32_t len, uint8_t *buf, int page);
 	int (*write_subpage)(struct mtd_info *mtd, struct nand_chip *chip,
 			uint32_t offset, uint32_t data_len,
 			const uint8_t *data_buf, int oob_required);

commit 913618185e51ee1fcbc193b2f121a9d072405619
Author: Huang Shijie <b32955@freescale.com>
Date:   Fri Feb 21 13:39:40 2014 +0800

    mtd: nand: parse out the JEDEC compliant NAND
    
    This patch adds the parsing code for the JEDEC compliant NAND.
    
    Since we need the 0x40 as the column address, this patch also
    makes the NAND_CMD_PARAM to use the 8-bit address only.
    
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index afd1cf9b5eaf..aa005e87d161 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -925,7 +925,7 @@ static inline bool nand_is_slc(struct nand_chip *chip)
  */
 static inline int nand_opcode_8bits(unsigned int command)
 {
-	return command == NAND_CMD_READID;
+	return command == NAND_CMD_READID || command == NAND_CMD_PARAM;
 }
 
 /* return the supported JEDEC features. */

commit 7852f8962f0f022b11fc56d63de06226a9f70d88
Author: Huang Shijie <b32955@freescale.com>
Date:   Fri Feb 21 13:39:39 2014 +0800

    mtd: nand: add a helper to get the supported features for JEDEC
    
    Add a helper to get the supported features for JEDEC compliant NAND.
    Also add a macro JEDEC_FEATURE_16_BIT_BUS.
    
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index f9af7564118a..afd1cf9b5eaf 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -350,6 +350,9 @@ struct jedec_ecc_info {
 	u8 reserved[2];
 } __packed;
 
+/* JEDEC features */
+#define JEDEC_FEATURE_16_BIT_BUS	(1 << 0)
+
 struct nand_jedec_params {
 	/* rev info and features block */
 	/* 'J' 'E' 'S' 'D'  */
@@ -925,4 +928,10 @@ static inline int nand_opcode_8bits(unsigned int command)
 	return command == NAND_CMD_READID;
 }
 
+/* return the supported JEDEC features. */
+static inline int jedec_feature(struct nand_chip *chip)
+{
+	return chip->jedec_version ? le16_to_cpu(chip->jedec_params.features)
+		: 0;
+}
 #endif /* __LINUX_MTD_NAND_H */

commit d94abba7605d3c15123eb3b331a1872ef17d29e0
Author: Huang Shijie <b32955@freescale.com>
Date:   Fri Feb 21 13:39:38 2014 +0800

    mtd: nand: add fields for JEDEC in nand_chip
    
    Add the jedec_version field, and add an anonymous union which
    contains the nand_onfi_params and nand_jedec_params.
    
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 588f8a4a27af..f9af7564118a 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -590,8 +590,12 @@ struct nand_buffers {
  * @subpagesize:	[INTERN] holds the subpagesize
  * @onfi_version:	[INTERN] holds the chip ONFI version (BCD encoded),
  *			non 0 if ONFI supported.
+ * @jedec_version:	[INTERN] holds the chip JEDEC version (BCD encoded),
+ *			non 0 if JEDEC supported.
  * @onfi_params:	[INTERN] holds the ONFI page parameter when ONFI is
  *			supported, 0 otherwise.
+ * @jedec_params:	[INTERN] holds the JEDEC parameter page when JEDEC is
+ *			supported, 0 otherwise.
  * @read_retries:	[INTERN] the number of read retry modes supported
  * @onfi_set_features:	[REPLACEABLE] set the features for ONFI nand
  * @onfi_get_features:	[REPLACEABLE] get the features for ONFI nand
@@ -664,7 +668,11 @@ struct nand_chip {
 	int badblockbits;
 
 	int onfi_version;
-	struct nand_onfi_params	onfi_params;
+	int jedec_version;
+	union {
+		struct nand_onfi_params	onfi_params;
+		struct nand_jedec_params jedec_params;
+	};
 
 	int read_retries;
 

commit afbfff03d611de22b1ec7127ad56920e02936d5e
Author: Huang Shijie <b32955@freescale.com>
Date:   Fri Feb 21 13:39:37 2014 +0800

    mtd: nand: add the data structures for JEDEC parameter page
    
    Create the nand_jedec_params{} and jedec_ecc_info{} according to
    the JESD230A (Revision of JESD230, October 2012).
    
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index c034dc4224cb..588f8a4a27af 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -342,6 +342,81 @@ struct nand_onfi_vendor_micron {
 	u8 param_revision;
 } __packed;
 
+struct jedec_ecc_info {
+	u8 ecc_bits;
+	u8 codeword_size;
+	__le16 bb_per_lun;
+	__le16 block_endurance;
+	u8 reserved[2];
+} __packed;
+
+struct nand_jedec_params {
+	/* rev info and features block */
+	/* 'J' 'E' 'S' 'D'  */
+	u8 sig[4];
+	__le16 revision;
+	__le16 features;
+	u8 opt_cmd[3];
+	__le16 sec_cmd;
+	u8 num_of_param_pages;
+	u8 reserved0[18];
+
+	/* manufacturer information block */
+	char manufacturer[12];
+	char model[20];
+	u8 jedec_id[6];
+	u8 reserved1[10];
+
+	/* memory organization block */
+	__le32 byte_per_page;
+	__le16 spare_bytes_per_page;
+	u8 reserved2[6];
+	__le32 pages_per_block;
+	__le32 blocks_per_lun;
+	u8 lun_count;
+	u8 addr_cycles;
+	u8 bits_per_cell;
+	u8 programs_per_page;
+	u8 multi_plane_addr;
+	u8 multi_plane_op_attr;
+	u8 reserved3[38];
+
+	/* electrical parameter block */
+	__le16 async_sdr_speed_grade;
+	__le16 toggle_ddr_speed_grade;
+	__le16 sync_ddr_speed_grade;
+	u8 async_sdr_features;
+	u8 toggle_ddr_features;
+	u8 sync_ddr_features;
+	__le16 t_prog;
+	__le16 t_bers;
+	__le16 t_r;
+	__le16 t_r_multi_plane;
+	__le16 t_ccs;
+	__le16 io_pin_capacitance_typ;
+	__le16 input_pin_capacitance_typ;
+	__le16 clk_pin_capacitance_typ;
+	u8 driver_strength_support;
+	__le16 t_ald;
+	u8 reserved4[36];
+
+	/* ECC and endurance block */
+	u8 guaranteed_good_blocks;
+	__le16 guaranteed_block_endurance;
+	struct jedec_ecc_info ecc_info[4];
+	u8 reserved5[29];
+
+	/* reserved */
+	u8 reserved6[148];
+
+	/* vendor */
+	__le16 vendor_rev_num;
+	u8 reserved7[88];
+
+	/* CRC for Parameter Page */
+	__le16 crc;
+} __packed;
+
 /**
  * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independent devices
  * @lock:               protection lock

commit 3dad2344e92c6e1aeae42df1c4824f307c51bcc7
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Wed Jan 29 14:08:12 2014 -0800

    mtd: nand: force NAND_CMD_READID onto 8-bit bus
    
    The NAND command helpers tend to automatically shift the column address
    for x16 bus devices, since most commands expect a word address, not a
    byte address. The Read ID command, however, expects an 8-bit address
    (i.e., 0x00, 0x20, or 0x40 should not be translated to 0x00, 0x10, or
    0x20).
    
    This fixes the column address for a few drivers which imitate the
    nand_base defaults. Note that I don't touch sh_flctl.c, since it already
    handles this problem slightly differently (note its comment "READID is
    always performed using an 8-bit bus").
    
    I have not tested this patch, as I only have x8 parts up for testing at
    this point. Hopefully that can change soon...
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Tested-by: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Tested-By: Pekon Gupta <pekon@ti.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index a719686c9cce..c034dc4224cb 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -832,4 +832,14 @@ static inline bool nand_is_slc(struct nand_chip *chip)
 {
 	return chip->bits_per_cell == 1;
 }
+
+/**
+ * Check if the opcode's address should be sent only on the lower 8 bits
+ * @command: opcode to check
+ */
+static inline int nand_opcode_8bits(unsigned int command)
+{
+	return command == NAND_CMD_READID;
+}
+
 #endif /* __LINUX_MTD_NAND_H */

commit 3f172cbdfbb799e35cc972fc9f7e43d0e971577b
Author: Huang Shijie <shijie8@gmail.com>
Date:   Sat Dec 21 00:02:30 2013 +0800

    mtd: nand: remove the NAND_MAX_PAGESIZE/NAND_MAX_OOBSIZE
    
    There is no reference to these two macros now.
    Just remove them.
    
    Signed-off-by: Huang Shijie <shijie8@gmail.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 520ebca11f5d..a719686c9cce 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -51,14 +51,6 @@ extern int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
 /* The maximum number of NAND chips in an array */
 #define NAND_MAX_CHIPS		8
 
-/*
- * This constant declares the max. oobsize / page, which
- * is supported now. If you add a chip with bigger oobsize/page
- * adjust this accordingly.
- */
-#define NAND_MAX_OOBSIZE	744
-#define NAND_MAX_PAGESIZE	8192
-
 /*
  * Constants for hardware specific CLE/ALE/NCE function
  *

commit f02ea4e6a47d50a38f5baadbe87f5087dd337db0
Author: Huang Shijie <b32955@freescale.com>
Date:   Mon Jan 13 14:27:12 2014 +0800

    mtd: nand: kill the the NAND_MAX_PAGESIZE/NAND_MAX_OOBSIZE for nand_buffers{}
    
    The patch converts the arrays to buffer pointers for nand_buffers{}.
    
    The cafe_nand.c is the only NAND_OWN_BUFFERS user which allocates
    nand_buffers{} itself.
    
    This patch disables the DMA for nand_scan_ident, and restores the DMA
    status after we finish the nand_scan_ident. This way, we can get page
    size and OOB size and use them to allocate cafe->dmabuf.
    
    Since the cafe_nand.c uses the NAND_ECC_HW_SYNDROME ECC mode, we do not
    allocate the buffers for @ecccalc and @ecccode.
    
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 32f8612469d8..520ebca11f5d 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -435,17 +435,17 @@ struct nand_ecc_ctrl {
 
 /**
  * struct nand_buffers - buffer structure for read/write
- * @ecccalc:	buffer for calculated ECC
- * @ecccode:	buffer for ECC read from flash
- * @databuf:	buffer for data - dynamically sized
+ * @ecccalc:	buffer pointer for calculated ECC, size is oobsize.
+ * @ecccode:	buffer pointer for ECC read from flash, size is oobsize.
+ * @databuf:	buffer pointer for data, size is (page size + oobsize).
  *
  * Do not change the order of buffers. databuf and oobrbuf must be in
  * consecutive order.
  */
 struct nand_buffers {
-	uint8_t	ecccalc[NAND_MAX_OOBSIZE];
-	uint8_t	ecccode[NAND_MAX_OOBSIZE];
-	uint8_t databuf[NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE];
+	uint8_t	*ecccalc;
+	uint8_t	*ecccode;
+	uint8_t *databuf;
 };
 
 /**

commit 4968a4124cf2df4b3672eed4714c6755f10f400c
Author: Huang Shijie <b32955@freescale.com>
Date:   Fri Jan 3 16:50:39 2014 +0800

    mtd: nand: add Intel manufacturer ID
    
    Add the Intel manufacturer Id.
    Tested with Intel JS29F32G08ACMD1(4096 + 224) which is ONFI 2.0 compliant
    nand.
    
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index e03a78c70de1..32f8612469d8 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -634,6 +634,7 @@ struct nand_chip {
 #define NAND_MFR_MACRONIX	0xc2
 #define NAND_MFR_EON		0x92
 #define NAND_MFR_SANDISK	0x45
+#define NAND_MFR_INTEL		0x89
 
 /* The maximum expected count of bytes in the NAND ID sequence */
 #define NAND_MAX_ID_LEN 8

commit 3f97c6ff6de8a657e4d4d826e502698004cfc2ae
Author: Huang Shijie <b32955@freescale.com>
Date:   Thu Dec 26 15:37:45 2013 +0800

    mtd: nand: add SanDisk manufacturer ID
    
    Add the manufactor ID for SanDisk.
    Make preparation for SanDisk SDTNRGAMA-008G.
    
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 352e23891f58..e03a78c70de1 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -633,6 +633,7 @@ struct nand_chip {
 #define NAND_MFR_AMD		0x01
 #define NAND_MFR_MACRONIX	0xc2
 #define NAND_MFR_EON		0x92
+#define NAND_MFR_SANDISK	0x45
 
 /* The maximum expected count of bytes in the NAND ID sequence */
 #define NAND_MAX_ID_LEN 8

commit 05f7835975dad6b3b517f9e23415985e648fb875
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu Dec 5 22:22:04 2013 +0100

    mtd: nand: don't use {read,write}_buf for 8-bit transfers
    
    According to the Open NAND Flash Interface Specification (ONFI) Revision
    3.1 "Parameters are always transferred on the lower 8-bits of the data
    bus." for the Get Features and Set Features commands.
    
    So using read_buf and write_buf is wrong for 16-bit wide nand chips as
    they use I/O[15:0]. The Get Features command is easily fixed using 4
    times the read_byte callback. For Set Features implement a new
    overwritable callback "write_byte". Still I expect the default to work
    just fine for all controllers and making it overwriteable was just done
    for symmetry.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    [Brian: fixed warning]
    Tested-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 05fcdfea640b..352e23891f58 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -456,6 +456,8 @@ struct nand_buffers {
  *			flash device.
  * @read_byte:		[REPLACEABLE] read one byte from the chip
  * @read_word:		[REPLACEABLE] read one word from the chip
+ * @write_byte:		[REPLACEABLE] write a single byte to the chip on the
+ *			low 8 I/O lines
  * @write_buf:		[REPLACEABLE] write data from the buffer to the chip
  * @read_buf:		[REPLACEABLE] read data from the chip into the buffer
  * @select_chip:	[REPLACEABLE] select chip nr
@@ -548,6 +550,7 @@ struct nand_chip {
 
 	uint8_t (*read_byte)(struct mtd_info *mtd);
 	u16 (*read_word)(struct mtd_info *mtd);
+	void (*write_byte)(struct mtd_info *mtd, uint8_t byte);
 	void (*write_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
 	void (*read_buf)(struct mtd_info *mtd, uint8_t *buf, int len);
 	void (*select_chip)(struct mtd_info *mtd, int chip);

commit e2e6b7b7d64baeac1c38fa5eb0d3ec85f3d123f5
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Thu Dec 5 12:06:54 2013 -0800

    mtd: nand: use __packed shorthand
    
    To be consistent with the rest of include/linux/mtd/nand.h, we should
    use the __packed shorthand instead of __attribute__((packed)).
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Acked-by: Huang Shijie <b32955@freescale.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 3080a8c8b62e..05fcdfea640b 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -292,7 +292,7 @@ struct nand_onfi_params {
 	u8 vendor[88];
 
 	__le16 crc;
-} __attribute__((packed));
+} __packed;
 
 #define ONFI_CRC_BASE	0x4F4E
 

commit 8429bb3975ef81c114cde4da111e64d224d19f83
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Dec 3 15:51:09 2013 -0800

    mtd: nand: support Micron READ RETRY
    
    Micron provides READ RETRY support via the ONFI vendor-specific
    parameter block (to indicate how many read-retry modes are available)
    and the ONFI {GET,SET}_FEATURES commands with a vendor-specific feature
    address (to support reading/switching the current read-retry mode).
    
    The recommended sequence is as follows:
    
      1. Perform PAGE_READ operation
      2. If no ECC error, we are done
      3. Run SET_FEATURES with feature address 89h, mode 1
      4. Retry PAGE_READ operation
      5. If ECC error and there are remaining supported modes, increment the
         mode and return to step 3. Otherwise, this is a true ECC error.
      6. Run SET_FEATURES with feature address 89h, mode 0, to return to the
         default state.
    
    This patch implements the chip->setup_read_retry() callback for
    Micron and fills in the chip->read_retries.
    
    Tested on Micron MT29F32G08CBADA, which supports 8 read-retry modes.
    
    The Micron vendor-specific table was checked against the datasheets for
    the following Micron NAND:
    
    Needs retry   Cell-type    Part number          Vendor revision    Byte 180
    -----------   ---------    ----------------     ---------------    ------------
    No            SLC          MT29F16G08ABABA      1                  Reserved (0)
    No            MLC          MT29F32G08CBABA      1                  Reserved (0)
    No            SLC          MT29F1G08AACWP       1                  0
    Yes           MLC          MT29F32G08CBADA      1                  08h
    Yes           MLC          MT29F64G08CBABA      2                  08h
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Acked-by: Huang Shijie <b32955@freescale.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 267d61dd89dd..3080a8c8b62e 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -219,6 +219,9 @@ struct nand_chip;
 /* ONFI feature address */
 #define ONFI_FEATURE_ADDR_TIMING_MODE	0x1
 
+/* Vendor-specific feature address (Micron) */
+#define ONFI_FEATURE_ADDR_READ_RETRY	0x89
+
 /* ONFI subfeature parameters length */
 #define ONFI_SUBFEATURE_PARAM_LEN	4
 

commit ba84fb5952af114e28ac82adcdef75297701ccc1
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Jan 3 15:13:33 2014 -0800

    mtd: nand: add generic READ RETRY support
    
    Modern MLC (and even SLC?) NAND can experience a large number of
    bitflips (beyond the recommended correctability capacity) due to drifts
    in the voltage threshold (Vt). These bitflips can cause ECC errors to
    occur well within the expected lifetime of the flash. To account for
    this, some manufacturers provide a mechanism for shifting the Vt
    threshold after a corrupted read.
    
    The generic pattern seems to be that a particular flash has N read retry
    modes (where N = 0, traditionally), and after an ECC failure, the host
    should reconfigure the flash to use the next available mode, then retry
    the read operation. This process repeats until all bitfips can be
    corrected or until the host has tried all available retry modes.
    
    This patch adds the infrastructure support for a
    vendor-specific/flash-specific callback, used for setting the read-retry
    mode (i.e., voltage threshold).
    
    For now, this patch always returns the flash to mode 0 (the default
    mode) after a successful read-retry, according to the flowchart found in
    Micron's datasheets. This may need to change in the future if it is
    determined that eventually, mode 0 is insufficient for the majority of
    the flash cells (and so for performance reasons, we should leave the
    flash in mode 1, 2, etc.).
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Acked-by: Huang Shijie <b32955@freescale.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 029fe5948dc4..267d61dd89dd 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -472,6 +472,8 @@ struct nand_buffers {
  *			commands to the chip.
  * @waitfunc:		[REPLACEABLE] hardwarespecific function for wait on
  *			ready.
+ * @setup_read_retry:	[FLASHSPECIFIC] flash (vendor) specific function for
+ *			setting the read-retry mode. Mostly needed for MLC NAND.
  * @ecc:		[BOARDSPECIFIC] ECC control structure
  * @buffers:		buffer structure for read/write
  * @hwcontrol:		platform-specific hardware control structure
@@ -518,6 +520,7 @@ struct nand_buffers {
  *			non 0 if ONFI supported.
  * @onfi_params:	[INTERN] holds the ONFI page parameter when ONFI is
  *			supported, 0 otherwise.
+ * @read_retries:	[INTERN] the number of read retry modes supported
  * @onfi_set_features:	[REPLACEABLE] set the features for ONFI nand
  * @onfi_get_features:	[REPLACEABLE] get the features for ONFI nand
  * @bbt:		[INTERN] bad block table pointer
@@ -565,6 +568,7 @@ struct nand_chip {
 			int feature_addr, uint8_t *subfeature_para);
 	int (*onfi_get_features)(struct mtd_info *mtd, struct nand_chip *chip,
 			int feature_addr, uint8_t *subfeature_para);
+	int (*setup_read_retry)(struct mtd_info *mtd, int retry_mode);
 
 	int chip_delay;
 	unsigned int options;
@@ -589,6 +593,8 @@ struct nand_chip {
 	int onfi_version;
 	struct nand_onfi_params	onfi_params;
 
+	int read_retries;
+
 	flstate_t state;
 
 	uint8_t *oob_poi;

commit 6f0065b0124bef5e66869ec0b813d251797be439
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Dec 3 12:02:20 2013 -0800

    mtd: nand: add ONFI vendor block for Micron
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Acked-by: Huang Shijie <b32955@freescale.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index f3ea8daf08ee..029fe5948dc4 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -285,7 +285,8 @@ struct nand_onfi_params {
 	u8 reserved4[7];
 
 	/* vendor */
-	u8 reserved5[90];
+	__le16 vendor_revision;
+	u8 vendor[88];
 
 	__le16 crc;
 } __attribute__((packed));
@@ -326,6 +327,26 @@ struct onfi_ext_param_page {
 	 */
 } __packed;
 
+struct nand_onfi_vendor_micron {
+	u8 two_plane_read;
+	u8 read_cache;
+	u8 read_unique_id;
+	u8 dq_imped;
+	u8 dq_imped_num_settings;
+	u8 dq_imped_feat_addr;
+	u8 rb_pulldown_strength;
+	u8 rb_pulldown_strength_feat_addr;
+	u8 rb_pulldown_strength_num_settings;
+	u8 otp_mode;
+	u8 otp_page_start;
+	u8 otp_data_prot_addr;
+	u8 otp_num_pages;
+	u8 otp_feat_addr;
+	u8 read_retry_options;
+	u8 reserved[72];
+	u8 param_revision;
+} __packed;
+
 /**
  * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independent devices
  * @lock:               protection lock

commit a55e85ce9bee97df63f85547a5e72df14851b338
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Mon Dec 2 11:12:22 2013 -0800

    mtd: nand: fix misspelling in ONFI parameter field name
    
    s/strenght/strength/
    
    This field isn't used anywhere, so this rename is safe.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 9e6c8f9f306e..f3ea8daf08ee 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -279,7 +279,7 @@ struct nand_onfi_params {
 	__le16 io_pin_capacitance_typ;
 	__le16 input_pin_capacitance_typ;
 	u8 input_pin_capacitance_max;
-	u8 driver_strenght_support;
+	u8 driver_strength_support;
 	__le16 t_int_r;
 	__le16 t_ald;
 	u8 reserved4[7];

commit 7db906b79f69b6ed936a1ef1d788f02e3ad42462
Author: Huang Shijie <b32955@freescale.com>
Date:   Wed Sep 25 14:58:11 2013 +0800

    mtd: nand: rename the cellinfo to bits_per_cell
    
    The @cellinfo fields contains unused information, such as write caching,
    internal chip numbering, etc. But we only use it to check the SLC or MLC.
    
    This patch tries to make it more clear and simple, renames the @cellinfo
    to @bits_per_cell.
    
    In order to avoiding the bisect issue, this patch also does the following
    changes:
      (0) add a macro NAND_CI_CELLTYPE_SHIFT to avoid the hardcode.
    
      (1) add a helper to parse out the cell type : nand_get_bits_per_cell()
    
      (2) parse out the cell type for extended-ID chips and the full-id nand chips.
    
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 5c05bab0ad89..9e6c8f9f306e 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -198,6 +198,7 @@ typedef enum {
 /* Cell info constants */
 #define NAND_CI_CHIPNR_MSK	0x03
 #define NAND_CI_CELLTYPE_MSK	0x0C
+#define NAND_CI_CELLTYPE_SHIFT	2
 
 /* Keep gcc happy */
 struct nand_chip;
@@ -477,7 +478,7 @@ struct nand_buffers {
  * @badblockbits:	[INTERN] minimum number of set bits in a good block's
  *			bad block marker position; i.e., BBM == 11110111b is
  *			not bad when badblockbits == 7
- * @cellinfo:		[INTERN] MLC/multichip data from chip ident
+ * @bits_per_cell:	[INTERN] number of bits per cell. i.e., 1 means SLC.
  * @ecc_strength_ds:	[INTERN] ECC correctability from the datasheet.
  *			Minimum amount of bit errors per @ecc_step_ds guaranteed
  *			to be correctable. If unknown, set to zero.
@@ -558,7 +559,7 @@ struct nand_chip {
 	int pagebuf;
 	unsigned int pagebuf_bitflips;
 	int subpagesize;
-	uint8_t cellinfo;
+	uint8_t bits_per_cell;
 	uint16_t ecc_strength_ds;
 	uint16_t ecc_step_ds;
 	int badblockpos;
@@ -802,6 +803,6 @@ static inline int onfi_get_sync_timing_mode(struct nand_chip *chip)
  */
 static inline bool nand_is_slc(struct nand_chip *chip)
 {
-	return !(chip->cellinfo & NAND_CI_CELLTYPE_MSK);
+	return chip->bits_per_cell == 1;
 }
 #endif /* __LINUX_MTD_NAND_H */

commit 1d0ed69ddd714b6e2a974f42896463366923ded6
Author: Huang Shijie <b32955@freescale.com>
Date:   Wed Sep 25 14:58:10 2013 +0800

    mtd: nand: add a helper to check the SLC/MLC nand chip
    
    Add a helper to check if a nand chip is SLC or MLC.
    This helper makes the code more readable.
    
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 129548169400..5c05bab0ad89 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -795,4 +795,13 @@ static inline int onfi_get_sync_timing_mode(struct nand_chip *chip)
 	return le16_to_cpu(chip->onfi_params.src_sync_timing_mode);
 }
 
+/*
+ * Check if it is a SLC nand.
+ * The !nand_is_slc() can be used to check the MLC/TLC nand chips.
+ * We do not distinguish the MLC and TLC now.
+ */
+static inline bool nand_is_slc(struct nand_chip *chip)
+{
+	return !(chip->cellinfo & NAND_CI_CELLTYPE_MSK);
+}
 #endif /* __LINUX_MTD_NAND_H */

commit aaadd9819a128fb7ad988b6808581e3175859e2f
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Aug 23 23:24:47 2013 -0700

    mtd: nand: remove obsolete 'ecclayout' field
    
    This field is never used, except to print it out.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index ac8e89d5a792..129548169400 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -498,7 +498,6 @@ struct nand_buffers {
  *			supported, 0 otherwise.
  * @onfi_set_features:	[REPLACEABLE] set the features for ONFI nand
  * @onfi_get_features:	[REPLACEABLE] get the features for ONFI nand
- * @ecclayout:		[REPLACEABLE] the default ECC placement scheme
  * @bbt:		[INTERN] bad block table pointer
  * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash
  *			lookup.
@@ -572,7 +571,6 @@ struct nand_chip {
 
 	uint8_t *oob_poi;
 	struct nand_hw_control *controller;
-	struct nand_ecclayout *ecclayout;
 
 	struct nand_ecc_ctrl ecc;
 	struct nand_buffers *buffers;

commit 2dc0bdd91bb63f7d5755137177315c49637f6a96
Author: Huang Shijie <b32955@freescale.com>
Date:   Fri May 17 11:17:31 2013 +0800

    mtd: add ECC info for nand_flash_dev{}
    
    Add an instance of an anonymous struct to store the ECC info for full id
    nand chips.
            @ecc.strength_ds: ECC correctability from the datasheet.
            @ecc.step_ds: ECC size required by the @ecc.strength_ds,
    
    These two fields are all from the datasheet.
    
    Also add the necessary macros to make the code simple and clean.
    
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index bf4c566f0647..ac8e89d5a792 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -628,6 +628,11 @@ struct nand_chip {
 	{ .name = (nm), {{ .dev_id = (devid) }}, .chipsize = (chipsz), \
 	  .options = (opts) }
 
+#define NAND_ECC_INFO(_strength, _step)	\
+			{ .strength_ds = (_strength), .step_ds = (_step) }
+#define NAND_ECC_STRENGTH(type)		((type)->ecc.strength_ds)
+#define NAND_ECC_STEP(type)		((type)->ecc.step_ds)
+
 /**
  * struct nand_flash_dev - NAND Flash Device ID Structure
  * @name: a human-readable name of the NAND chip
@@ -645,6 +650,12 @@ struct nand_chip {
  * @options: stores various chip bit options
  * @id_len: The valid length of the @id.
  * @oobsize: OOB size
+ * @ecc.strength_ds: The ECC correctability from the datasheet, same as the
+ *                   @ecc_strength_ds in nand_chip{}.
+ * @ecc.step_ds: The ECC step required by the @ecc.strength_ds, same as the
+ *               @ecc_step_ds in nand_chip{}, also from the datasheet.
+ *               For example, the "4bit ECC for each 512Byte" can be set with
+ *               NAND_ECC_INFO(4, 512).
  */
 struct nand_flash_dev {
 	char *name;
@@ -661,6 +672,10 @@ struct nand_flash_dev {
 	unsigned int options;
 	uint16_t id_len;
 	uint16_t oobsize;
+	struct {
+		uint16_t strength_ds;
+		uint16_t step_ds;
+	} ecc;
 };
 
 /**

commit 5b40db68cb1bd14b3d5b159754c9c1bc3bdeb080
Author: Huang Shijie <shijie8@gmail.com>
Date:   Fri May 17 11:17:28 2013 +0800

    mtd: add a helper to get the supported features for ONFI nand
    
    add a helper to get the supported features for ONFI nand.
    Also add the neccessary macros.
    
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Reviewed-and-tested-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 01a7f3c71bd0..bf4c566f0647 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -202,6 +202,10 @@ typedef enum {
 /* Keep gcc happy */
 struct nand_chip;
 
+/* ONFI features */
+#define ONFI_FEATURE_16_BIT_BUS		(1 << 0)
+#define ONFI_FEATURE_EXT_PARAM_PAGE	(1 << 7)
+
 /* ONFI timing mode, used in both asynchronous and synchronous mode */
 #define ONFI_TIMING_MODE_0		(1 << 0)
 #define ONFI_TIMING_MODE_1		(1 << 1)
@@ -756,6 +760,12 @@ struct platform_nand_chip *get_platform_nandchip(struct mtd_info *mtd)
 	return chip->priv;
 }
 
+/* return the supported features. */
+static inline int onfi_feature(struct nand_chip *chip)
+{
+	return chip->onfi_version ? le16_to_cpu(chip->onfi_params.features) : 0;
+}
+
 /* return the supported asynchronous timing mode. */
 static inline int onfi_get_async_timing_mode(struct nand_chip *chip)
 {

commit 5138a98f6f47ce62a86cce4b9c381aaf4ad3a643
Author: Huang Shijie <b32955@freescale.com>
Date:   Fri May 17 11:17:27 2013 +0800

    mtd: add data structures for Extended Parameter Page
    
    Since the ONFI 2.1, the onfi spec adds the Extended Parameter Page
    to store the ECC info.
    
    The onfi spec tells us that if the nand chip's recommended ECC codeword
    size is not 512 bytes, then the @ecc_bits is 0xff. The host _SHOULD_ then
    read the Extended ECC information that is part of the extended parameter
    page to retrieve the ECC requirements for this device.
    
    This patch adds
        [1] the neccessary fields for nand_onfi_params{},
        [2] and adds the onfi_ext_ecc_info{} for Extended ECC information,
        [3] adds onfi_ext_section{} for extended sections,
        [4] and adds onfi_ext_param_page{} for the Extended Parameter Page.
    
    Acked-by: Pekon Gupta <pekon@ti.com>
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Reviewed-and-tested-by: Brian Norris <computersforpeace@gmail.com>
    [Brian: amended for checkpatch.pl]
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index fbf3bba37272..01a7f3c71bd0 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -227,7 +227,10 @@ struct nand_onfi_params {
 	__le16 revision;
 	__le16 features;
 	__le16 opt_cmd;
-	u8 reserved[22];
+	u8 reserved0[2];
+	__le16 ext_param_page_length; /* since ONFI 2.1 */
+	u8 num_of_param_pages;        /* since ONFI 2.1 */
+	u8 reserved1[17];
 
 	/* manufacturer information block */
 	char manufacturer[12];
@@ -284,6 +287,40 @@ struct nand_onfi_params {
 
 #define ONFI_CRC_BASE	0x4F4E
 
+/* Extended ECC information Block Definition (since ONFI 2.1) */
+struct onfi_ext_ecc_info {
+	u8 ecc_bits;
+	u8 codeword_size;
+	__le16 bb_per_lun;
+	__le16 block_endurance;
+	u8 reserved[2];
+} __packed;
+
+#define ONFI_SECTION_TYPE_0	0	/* Unused section. */
+#define ONFI_SECTION_TYPE_1	1	/* for additional sections. */
+#define ONFI_SECTION_TYPE_2	2	/* for ECC information. */
+struct onfi_ext_section {
+	u8 type;
+	u8 length;
+} __packed;
+
+#define ONFI_EXT_SECTION_MAX 8
+
+/* Extended Parameter Page Definition (since ONFI 2.1) */
+struct onfi_ext_param_page {
+	__le16 crc;
+	u8 sig[4];             /* 'E' 'P' 'P' 'S' */
+	u8 reserved0[10];
+	struct onfi_ext_section sections[ONFI_EXT_SECTION_MAX];
+
+	/*
+	 * The actual size of the Extended Parameter Page is in
+	 * @ext_param_page_length of nand_onfi_params{}.
+	 * The following are the variable length sections.
+	 * So we do not add any fields below. Please see the ONFI spec.
+	 */
+} __packed;
+
 /**
  * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independent devices
  * @lock:               protection lock

commit 4cfeca2d58de8292f45351f84e84f657222a4611
Author: Huang Shijie <b32955@freescale.com>
Date:   Fri May 17 11:17:25 2013 +0800

    mtd: add datasheet's ECC information to nand_chip{}
    
    1.) Why add the ECC information to the nand_chip{} ?
       Each nand chip has its requirement for the ECC correctability, such as
       "4bit ECC for each 512Byte" or "40bit ECC for each 1024Byte".
       This ECC info is very important to the nand controller, such as gpmi.
    
       Take the Micron MT29F64G08CBABA for example, its geometry is
       8KiB page size, 744 bytes oob size and it requires 40bit ECC per 1KiB.
       If we do not provide the ECC info to the gpmi nand driver, it has to
       calculate the ECC correctability itself. The gpmi driver will gets the 56bit
       ECC for per 1KiB which is beyond its BCH's 40bit ecc capibility.
       The gpmi will quits in this case. But in actually, the gpmi can supports
       this nand chip if it can get the right ECC info.
    
    2.) about the new fields.
       The @ecc_strength_ds stands for the ecc bits needed within the @ecc_step_ds.
       The two fields should be set from the nand chip's datasheets.
    
       For example:
            "4bit ECC for each 512Byte" could be:
                    @ecc_strength_ds = 4, @ecc_step_ds = 512.
            "40bit ECC for each 1024Byte" could be:
                    @ecc_strength_ds = 40, @ecc_step_ds = 1024.
    
    3.) Why do not re-use the @strength and @size in the nand_ecc_ctrl{}?
       The @strength and @size in nand_ecc_ctrl{} is used by the nand controller
       driver, while the @ecc_strength_ds and @ecc_step_ds are get from the datasheet.
    
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Reviewed-and-tested-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 9f7b248c70fe..fbf3bba37272 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -437,6 +437,12 @@ struct nand_buffers {
  *			bad block marker position; i.e., BBM == 11110111b is
  *			not bad when badblockbits == 7
  * @cellinfo:		[INTERN] MLC/multichip data from chip ident
+ * @ecc_strength_ds:	[INTERN] ECC correctability from the datasheet.
+ *			Minimum amount of bit errors per @ecc_step_ds guaranteed
+ *			to be correctable. If unknown, set to zero.
+ * @ecc_step_ds:	[INTERN] ECC step required by the @ecc_strength_ds,
+ *                      also from the datasheet. It is the recommended ECC step
+ *			size, if known; if unknown, set to zero.
  * @numchips:		[INTERN] number of physical chips
  * @chipsize:		[INTERN] the size of one chip for multichip arrays
  * @pagemask:		[INTERN] page number mask = number of (pages / chip) - 1
@@ -513,6 +519,8 @@ struct nand_chip {
 	unsigned int pagebuf_bitflips;
 	int subpagesize;
 	uint8_t cellinfo;
+	uint16_t ecc_strength_ds;
+	uint16_t ecc_step_ds;
 	int badblockpos;
 	int badblockbits;
 

commit b32843b772db6024336e36c39359d8edc3b416ab
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Jul 30 17:52:59 2013 -0700

    mtd: nand: hide in-memory BBT implementation details
    
    nand_base.c shouldn't have to know the implementation details of
    nand_bbt's in-memory BBT. Specifically, nand_base shouldn't perform the
    bit masking and shifting to isolate a BBT entry.
    
    Instead, just move some of the BBT code into a new nand_markbad_bbt()
    interface. This interface allows external users (i.e., nand_base) to
    mark a single block as bad in the BBT. Then nand_bbt will take care of
    modifying the in-memory BBT and updating the flash-based BBT (if
    applicable).
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 0745a42f1acd..9f7b248c70fe 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -628,8 +628,8 @@ extern struct nand_flash_dev nand_flash_ids[];
 extern struct nand_manufacturers nand_manuf_ids[];
 
 extern int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd);
-extern int nand_update_bbt(struct mtd_info *mtd, loff_t offs);
 extern int nand_default_bbt(struct mtd_info *mtd);
+extern int nand_markbad_bbt(struct mtd_info *mtd, loff_t offs);
 extern int nand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt);
 extern int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
 			   int allowbbt);

commit d914c932d7764bf9633af974940aee9390adf20d
Author: David Mosberger <dmosberger@gmail.com>
Date:   Wed May 29 15:30:13 2013 +0300

    mtd: nand_base: Only use GET/SET FEATURES command on chips that support them.
    
    Spansion's S34MLx chips support ONFI but not the GET/SET FEATURES calls.
    
    Signed-off-by: David Mosberger <dmosberger@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 38535eb453db..0745a42f1acd 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -217,6 +217,9 @@ struct nand_chip;
 /* ONFI subfeature parameters length */
 #define ONFI_SUBFEATURE_PARAM_LEN	4
 
+/* ONFI optional commands SET/GET FEATURES supported? */
+#define ONFI_OPT_CMD_SET_GET_FEATURES	(1 << 2)
+
 struct nand_onfi_params {
 	/* rev info and features block */
 	/* 'O' 'N' 'F' 'I'  */

commit 52778b2e9fcb66c8f1c9d5b1ae435815c19e7ae3
Author: Huang Shijie <b32955@freescale.com>
Date:   Wed May 15 16:40:25 2013 +0800

    mtd: increase max OOB size to 744
    
    The oob size of Micron's MT29F64G08CBABAWP is 744 bytes.
    So increase the NAND_MAX_OOBSIZE to 744.
    
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 50c5ea02c81a..38535eb453db 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -56,7 +56,7 @@ extern int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
  * is supported now. If you add a chip with bigger oobsize/page
  * adjust this accordingly.
  */
-#define NAND_MAX_OOBSIZE	640
+#define NAND_MAX_OOBSIZE	744
 #define NAND_MAX_PAGESIZE	8192
 
 /*

commit ce157510eb886feb996a7a13354973bdf4aae1a1
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Thu Apr 11 01:34:59 2013 -0700

    mtd: nand: reword nand_chip bad block interface comments
    
    This remedies a few problems:
    
    (1) The use of "the" vs. "a" is a little confusing, IMO.
    
    (2) nand_chip.block_bad is used exclusively for checking the OOB bad
        block markers of a NAND. Any BBT functionality is handled in
        nand_bbt.c, so this description should differentiate itself from
        nand_bbt.c.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index ab6363443ce8..50c5ea02c81a 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -390,8 +390,8 @@ struct nand_buffers {
  * @write_buf:		[REPLACEABLE] write data from the buffer to the chip
  * @read_buf:		[REPLACEABLE] read data from the chip into the buffer
  * @select_chip:	[REPLACEABLE] select chip nr
- * @block_bad:		[REPLACEABLE] check, if the block is bad
- * @block_markbad:	[REPLACEABLE] mark the block bad
+ * @block_bad:		[REPLACEABLE] check if a block is bad, using OOB markers
+ * @block_markbad:	[REPLACEABLE] mark a block bad
  * @cmd_ctrl:		[BOARDSPECIFIC] hardwarespecific function for controlling
  *			ALE/CLE/nCE. Also used to write command and address
  * @init_size:		[BOARDSPECIFIC] hardwarespecific function for setting

commit 837a6ba4f3b6d23026674e6af6b6849a4634fff9
Author: Gupta, Pekon <pekon@ti.com>
Date:   Fri Mar 15 17:55:53 2013 +0530

    mtd: nand: subpage write support for hardware based ECC schemes
    
    This patch adds support for subpage (partial-page) writes when using
    hardware based ECC schemes.
    Advantages:
    (1) reduces storage overhead when using file-systems like UBIFS, which
    store LEB header at page-size granularity.
    (2) allows independent subpage writes, thereby increasing NAND storage
    efficiency for non-page aligned data.
    + updated cafe_nand and lpc32xx_mlc NAND drivers for change in
    chip->write_page interface.
    
    Signed-off-by: Gupta, Pekon <pekon@ti.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index ebf970e11428..ab6363443ce8 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -318,6 +318,7 @@ struct nand_hw_control {
  *		any single ECC step, 0 if bitflips uncorrectable, -EIO hw error
  * @read_subpage:	function to read parts of the page covered by ECC;
  *			returns same as read_page()
+ * @write_subpage:	function to write parts of the page covered by ECC.
  * @write_page:	function to write a page according to the ECC generator
  *		requirements.
  * @write_oob_raw:	function to write chip OOB data without ECC
@@ -349,6 +350,9 @@ struct nand_ecc_ctrl {
 			uint8_t *buf, int oob_required, int page);
 	int (*read_subpage)(struct mtd_info *mtd, struct nand_chip *chip,
 			uint32_t offs, uint32_t len, uint8_t *buf);
+	int (*write_subpage)(struct mtd_info *mtd, struct nand_chip *chip,
+			uint32_t offset, uint32_t data_len,
+			const uint8_t *data_buf, int oob_required);
 	int (*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
 			const uint8_t *buf, int oob_required);
 	int (*write_oob_raw)(struct mtd_info *mtd, struct nand_chip *chip,
@@ -484,8 +488,8 @@ struct nand_chip {
 	int (*errstat)(struct mtd_info *mtd, struct nand_chip *this, int state,
 			int status, int page);
 	int (*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
-			const uint8_t *buf, int oob_required, int page,
-			int cached, int raw);
+			uint32_t offset, int data_len, const uint8_t *buf,
+			int oob_required, int page, int cached, int raw);
 	int (*onfi_set_features)(struct mtd_info *mtd, struct nand_chip *chip,
 			int feature_addr, uint8_t *subfeature_para);
 	int (*onfi_get_features)(struct mtd_info *mtd, struct nand_chip *chip,

commit 5bfa9b71a2d6642506e2dfdf49a66620f54f1d92
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Tue Mar 19 10:29:26 2013 +0200

    mtd: nand_ids: improve LEGACY_ID_NAND macro a bit
    
    Notice that all the flashes belonging to the "legacy ID" class have 512 bytes
    NAND page. This means we may simplify the 'LEGACY_ID_NAND()' macro as well as
    the NAND ID table a little.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 13786f0ae12a..ebf970e11428 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -552,12 +552,11 @@ struct nand_chip {
 /*
  * A helper for defining older NAND chips where the second ID byte fully
  * defined the chip, including the geometry (chip size, eraseblock size, page
- * size).
+ * size). All these chips have 512 bytes NAND page size.
  */
-#define LEGACY_ID_NAND(nm, devid, pagesz, chipsz, erasesz, opts)       \
-	{ .name = (nm), {{ .dev_id = (devid) }}, .pagesize = (pagesz), \
-	  .chipsize = (chipsz), .erasesize = (erasesz),                \
-	  .options = (opts) }
+#define LEGACY_ID_NAND(nm, devid, chipsz, erasesz, opts)          \
+	{ .name = (nm), {{ .dev_id = (devid) }}, .pagesize = 512, \
+	  .chipsize = (chipsz), .erasesize = (erasesz), .options = (opts) }
 
 /*
  * A helper for defining newer chips which report their page size and

commit f22d5f638b0ea40e7cceb4639a608bd2c3eff97c
Author: Huang Shijie <b32955@freescale.com>
Date:   Fri Mar 15 11:00:59 2013 +0800

    mtd: add new fields to nand_flash_dev{}
    
    As time goes on, we begin to meet the situation that we can not get enough
    information from some nand chips's id data. Take some Toshiba's nand chips
    for example. I have 4 Toshiba's nand chips in my hand:
            TC58NVG2S0F, TC58NVG3S0F, TC58NVG5D2, TC58NVG6D2
    
    When we read these chips' datasheets, we will get the geometry of these chips:
            TC58NVG2S0F : 4096 + 224
            TC58NVG3S0F : 4096 + 232
            TC58NVG5D2  : 8192 + 640
            TC58NVG6D2  : 8192 + 640
    
    But we can not parse out the correct oob size for these chips from the id data.
    
    This patch adds some new fields to the nand_flash_dev{}:
      @id_len: the valid length of the id data. See the comments in
               nand_id_has_period()
      @oobsize: the oob size.
    
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Reviewed-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 0f78d19303c5..13786f0ae12a 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -588,6 +588,8 @@ struct nand_chip {
  * @chipsize: total chip size in MiB
  * @erasesize: eraseblock size in bytes (determined from the extended ID if 0)
  * @options: stores various chip bit options
+ * @id_len: The valid length of the @id.
+ * @oobsize: OOB size
  */
 struct nand_flash_dev {
 	char *name;
@@ -602,6 +604,8 @@ struct nand_flash_dev {
 	unsigned int chipsize;
 	unsigned int erasesize;
 	unsigned int options;
+	uint16_t id_len;
+	uint16_t oobsize;
 };
 
 /**

commit 53552d22bfe1f83f69f18eddae2f1d96249440f3
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Thu Mar 14 09:57:23 2013 +0200

    mtd: introduce a macro for max NAND ID sequence length
    
    Introduce a helpful macro for the maximum NAND ID sequence length instead of
    using the "8" magic number.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Acked-by: Huang Shijie <shijie8@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index d5903c0a0fe7..0f78d19303c5 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -546,6 +546,9 @@ struct nand_chip {
 #define NAND_MFR_MACRONIX	0xc2
 #define NAND_MFR_EON		0x92
 
+/* The maximum expected count of bytes in the NAND ID sequence */
+#define NAND_MAX_ID_LEN 8
+
 /*
  * A helper for defining older NAND chips where the second ID byte fully
  * defined the chip, including the geometry (chip size, eraseblock size, page
@@ -593,7 +596,7 @@ struct nand_flash_dev {
 			uint8_t mfr_id;
 			uint8_t dev_id;
 		};
-		uint8_t id[8];
+		uint8_t id[NAND_MAX_ID_LEN];
 	};
 	unsigned int pagesize;
 	unsigned int chipsize;

commit ecb42fea59cf2d1e7160c5c7e707120e0e6714db
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Wed Mar 13 13:45:00 2013 +0200

    mtd: nand: use more reasonable integer types
    
    Use 'unsigned int' instead of 'unsigned long' in the NAND chip description data
    structure, because 32-bits is more than enough for our purposes. We do not need
    64-bits, which is what we end up on 64-bit architectures. We declare many
    instances of this data structure, so this should help saving some amount of
    memory.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 9a1b74c85044..d5903c0a0fe7 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -582,8 +582,8 @@ struct nand_chip {
  * @pagesize: size of the NAND page in bytes; if 0, then the real page size (as
  *            well as the eraseblock size) is determined from the extended NAND
  *            chip ID array)
- * @erasesize: eraseblock size in bytes (determined from the extended ID if 0)
  * @chipsize: total chip size in MiB
+ * @erasesize: eraseblock size in bytes (determined from the extended ID if 0)
  * @options: stores various chip bit options
  */
 struct nand_flash_dev {
@@ -595,10 +595,10 @@ struct nand_flash_dev {
 		};
 		uint8_t id[8];
 	};
-	unsigned long pagesize;
-	unsigned long chipsize;
-	unsigned long erasesize;
-	unsigned long options;
+	unsigned int pagesize;
+	unsigned int chipsize;
+	unsigned int erasesize;
+	unsigned int options;
 };
 
 /**

commit 8e12b474f9a2349bcaebda65bdc38e8398ff408e
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Mon Mar 4 16:26:56 2013 +0200

    mtd: nand: provision full ID support
    
    Up until now we identified NAND chips by the 'device ID' part of the full chip
    ID array, which is the second full ID array byte. However, the newest flashes
    use the same device ID for chips with identical page and eraseblock sizes, but
    different OOB sizes. And unfortunately, it is not clear if there is a
    "standard" way to fetch the OOB size from chip's full ID array. Here is an
    example:
    
    Toshiba TC58NVG2S0F: 0x98, 0xdc, 0x90, 0x26, 0x76, 0x15, 0x01, 0x08
    Toshiba TC58NVG3S0F: 0x98, 0xd3, 0x90, 0x26, 0x76, 0x15, 0x02, 0x08
    
    The first one is a 512MiB NAND chip with 4KiB NAND pages, 256KiB eraseblock
    size and 224 bytes OOB. The second one is a 1GiB NAND chip with the same page
    and eraseblock sizes, but with 232 bytes OOB.
    
    This means that we have to store full ID in our NAND flashes table in order to
    distinguish between these 2.
    
    This patch adds the 'id[8]' field to the 'struct nand_flash_dev' structure, and
    it makes it to be a part of anonymous union, where the second member is a
    structure containing the 'mfr_id' and 'dev_id' bytes. The union makes sure that
    'mfr_id' refers the same RAM address as 'id[0]' and 'dev_id' refers the same
    RAM address as 'id[1]'. The only motivation for the union is an assumption that
    'type->dev_id' is more readable than 'type->id[1]'.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 63b319a6f98c..9a1b74c85044 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -551,9 +551,9 @@ struct nand_chip {
  * defined the chip, including the geometry (chip size, eraseblock size, page
  * size).
  */
-#define LEGACY_ID_NAND(nm, devid, pagesz, chipsz, erasesz, opts) \
-	{ .name = (nm), .dev_id = (devid), .pagesize = (pagesz), \
-	  .chipsize = (chipsz), .erasesize = (erasesz),          \
+#define LEGACY_ID_NAND(nm, devid, pagesz, chipsz, erasesz, opts)       \
+	{ .name = (nm), {{ .dev_id = (devid) }}, .pagesize = (pagesz), \
+	  .chipsize = (chipsz), .erasesize = (erasesz),                \
 	  .options = (opts) }
 
 /*
@@ -566,14 +566,19 @@ struct nand_chip {
  * buswidth), and the page size, eraseblock size, and OOB size could vary while
  * using the same device ID.
  */
-#define EXTENDED_ID_NAND(nm, devid, chipsz, opts)                \
-	{ .name = (nm), .dev_id = (devid), .chipsize = (chipsz), \
+#define EXTENDED_ID_NAND(nm, devid, chipsz, opts)                      \
+	{ .name = (nm), {{ .dev_id = (devid) }}, .chipsize = (chipsz), \
 	  .options = (opts) }
 
 /**
  * struct nand_flash_dev - NAND Flash Device ID Structure
  * @name: a human-readable name of the NAND chip
  * @dev_id: the device ID (the second byte of the full chip ID array)
+ * @mfr_id: manufecturer ID part of the full chip ID array (refers the same
+ *          memory address as @id[0])
+ * @dev_id: device ID part of the full chip ID array (refers the same memory
+ *          address as @id[1])
+ * @id: full device ID array
  * @pagesize: size of the NAND page in bytes; if 0, then the real page size (as
  *            well as the eraseblock size) is determined from the extended NAND
  *            chip ID array)
@@ -583,7 +588,13 @@ struct nand_chip {
  */
 struct nand_flash_dev {
 	char *name;
-	int dev_id;
+	union {
+		struct {
+			uint8_t mfr_id;
+			uint8_t dev_id;
+		};
+		uint8_t id[8];
+	};
 	unsigned long pagesize;
 	unsigned long chipsize;
 	unsigned long erasesize;

commit 8dbfae1ef04311ba19d6b6c9a4d8fdddbb90ab0f
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Mon Mar 4 15:39:18 2013 +0200

    mtd: nand_ids: introduce helper macros
    
    Introduce helper macros for defining NAND chips. These macros do not really add
    much value in the current code-base. However, we are going to add full ID
    support which adds some more complexity to the table, and helper macros become
    useful for readability.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 9aed31a49af1..63b319a6f98c 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -546,6 +546,30 @@ struct nand_chip {
 #define NAND_MFR_MACRONIX	0xc2
 #define NAND_MFR_EON		0x92
 
+/*
+ * A helper for defining older NAND chips where the second ID byte fully
+ * defined the chip, including the geometry (chip size, eraseblock size, page
+ * size).
+ */
+#define LEGACY_ID_NAND(nm, devid, pagesz, chipsz, erasesz, opts) \
+	{ .name = (nm), .dev_id = (devid), .pagesize = (pagesz), \
+	  .chipsize = (chipsz), .erasesize = (erasesz),          \
+	  .options = (opts) }
+
+/*
+ * A helper for defining newer chips which report their page size and
+ * eraseblock size via the extended ID bytes.
+ *
+ * The real difference between LEGACY_ID_NAND and EXTENDED_ID_NAND is that with
+ * EXTENDED_ID_NAND, manufacturers overloaded the same device ID so that the
+ * device ID now only represented a particular total chip size (and voltage,
+ * buswidth), and the page size, eraseblock size, and OOB size could vary while
+ * using the same device ID.
+ */
+#define EXTENDED_ID_NAND(nm, devid, chipsz, opts)                \
+	{ .name = (nm), .dev_id = (devid), .chipsize = (chipsz), \
+	  .options = (opts) }
+
 /**
  * struct nand_flash_dev - NAND Flash Device ID Structure
  * @name: a human-readable name of the NAND chip

commit 68aa352de28235bccdcee96ddf49f7628e93ec6f
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Mon Mar 4 16:05:00 2013 +0200

    mtd: nand: rename the id field of 'struct nand_flash_dev'
    
    The 'id' is a bit confusing name because NAND IDs are multi-byte. Re-name
    it to 'dev_id' to make it clear that this is the "device ID" part (the second
    byte).
    
    While on it, clean-up the commentary for 'struct nand_flash_dev'.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Acked-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 07d7a3dc5582..9aed31a49af1 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -548,19 +548,18 @@ struct nand_chip {
 
 /**
  * struct nand_flash_dev - NAND Flash Device ID Structure
- * @name:	Identify the device type
- * @id:		device ID code
- * @pagesize:	Pagesize in bytes. Either 256 or 512 or 0
- *		If the pagesize is 0, then the real pagesize
- *		and the eraseize are determined from the
- *		extended id bytes in the chip
- * @erasesize:	Size of an erase block in the flash device.
- * @chipsize:	Total chipsize in Mega Bytes
- * @options:	Bitfield to store chip relevant options
+ * @name: a human-readable name of the NAND chip
+ * @dev_id: the device ID (the second byte of the full chip ID array)
+ * @pagesize: size of the NAND page in bytes; if 0, then the real page size (as
+ *            well as the eraseblock size) is determined from the extended NAND
+ *            chip ID array)
+ * @erasesize: eraseblock size in bytes (determined from the extended ID if 0)
+ * @chipsize: total chip size in MiB
+ * @options: stores various chip bit options
  */
 struct nand_flash_dev {
 	char *name;
-	int id;
+	int dev_id;
 	unsigned long pagesize;
 	unsigned long chipsize;
 	unsigned long erasesize;

commit 3239a6cdef0be60ec2dadc501cf385dc419d7452
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Mon Mar 4 14:56:18 2013 +0200

    mtd: nand: use NAND_HAS_CACHEPROG
    
    We have this unused macro, let's use it and justify its existence.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Acked-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index ec0a74877714..07d7a3dc5582 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -167,7 +167,7 @@ typedef enum {
 #define NAND_SUBPAGE_READ	0x00001000
 
 /* Options valid for Samsung large page devices */
-#define NAND_SAMSUNG_LP_OPTIONS (NAND_CACHEPRG)
+#define NAND_SAMSUNG_LP_OPTIONS NAND_CACHEPRG
 
 /* Macros to identify the above */
 #define NAND_HAS_CACHEPROG(chip) ((chip->options & NAND_CACHEPRG))

commit 88ad4b162adb3821815d0098987040fca26c7d80
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Mon Mar 4 14:52:25 2013 +0200

    mtd: nand: remove NAND_COPYBACK macro
    
    It is unused.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Acked-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 10fd7df07b5e..ec0a74877714 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -147,8 +147,6 @@ typedef enum {
 #define NAND_BUSWIDTH_16	0x00000002
 /* Chip has cache program function */
 #define NAND_CACHEPRG		0x00000008
-/* Chip has copy back function */
-#define NAND_COPYBACK		0x00000010
 /*
  * Chip requires ready check on read (for auto-incremented sequential read).
  * True only for small page devices; large page devices do not support
@@ -169,11 +167,10 @@ typedef enum {
 #define NAND_SUBPAGE_READ	0x00001000
 
 /* Options valid for Samsung large page devices */
-#define NAND_SAMSUNG_LP_OPTIONS (NAND_CACHEPRG | NAND_COPYBACK)
+#define NAND_SAMSUNG_LP_OPTIONS (NAND_CACHEPRG)
 
 /* Macros to identify the above */
 #define NAND_HAS_CACHEPROG(chip) ((chip->options & NAND_CACHEPRG))
-#define NAND_HAS_COPYBACK(chip) ((chip->options & NAND_COPYBACK))
 #define NAND_HAS_SUBPAGE_READ(chip) ((chip->options & NAND_SUBPAGE_READ))
 
 /* Non chip related options */

commit 96dca4c29c5e4fc158f8f31513994408c90c6818
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Mon Mar 4 14:50:43 2013 +0200

    mtd: nand: remove NAND_NO_PADDING macro
    
    It is not used anywhere.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Acked-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index e5d6160a4511..10fd7df07b5e 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -145,8 +145,6 @@ typedef enum {
  */
 /* Buswidth is 16 bit */
 #define NAND_BUSWIDTH_16	0x00000002
-/* Device supports partial programming without padding */
-#define NAND_NO_PADDING		0x00000004
 /* Chip has cache program function */
 #define NAND_CACHEPRG		0x00000008
 /* Chip has copy back function */
@@ -171,11 +169,9 @@ typedef enum {
 #define NAND_SUBPAGE_READ	0x00001000
 
 /* Options valid for Samsung large page devices */
-#define NAND_SAMSUNG_LP_OPTIONS \
-	(NAND_NO_PADDING | NAND_CACHEPRG | NAND_COPYBACK)
+#define NAND_SAMSUNG_LP_OPTIONS (NAND_CACHEPRG | NAND_COPYBACK)
 
 /* Macros to identify the above */
-#define NAND_MUST_PAD(chip) (!(chip->options & NAND_NO_PADDING))
 #define NAND_HAS_CACHEPROG(chip) ((chip->options & NAND_CACHEPRG))
 #define NAND_HAS_COPYBACK(chip) ((chip->options & NAND_COPYBACK))
 #define NAND_HAS_SUBPAGE_READ(chip) ((chip->options & NAND_SUBPAGE_READ))

commit 0be718e5525a73557e76ea1c05b8001dde507049
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Mon Mar 4 14:35:56 2013 +0200

    mtd: nand: remove a bunch of unused commands
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Acked-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 7cc299436f94..e5d6160a4511 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -86,7 +86,6 @@ extern int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
 #define NAND_CMD_READOOB	0x50
 #define NAND_CMD_ERASE1		0x60
 #define NAND_CMD_STATUS		0x70
-#define NAND_CMD_STATUS_MULTI	0x71
 #define NAND_CMD_SEQIN		0x80
 #define NAND_CMD_RNDIN		0x85
 #define NAND_CMD_READID		0x90
@@ -105,25 +104,6 @@ extern int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
 #define NAND_CMD_RNDOUTSTART	0xE0
 #define NAND_CMD_CACHEDPROG	0x15
 
-/* Extended commands for AG-AND device */
-/*
- * Note: the command for NAND_CMD_DEPLETE1 is really 0x00 but
- *       there is no way to distinguish that from NAND_CMD_READ0
- *       until the remaining sequence of commands has been completed
- *       so add a high order bit and mask it off in the command.
- */
-#define NAND_CMD_DEPLETE1	0x100
-#define NAND_CMD_DEPLETE2	0x38
-#define NAND_CMD_STATUS_MULTI	0x71
-#define NAND_CMD_STATUS_ERROR	0x72
-/* multi-bank error status (banks 0-3) */
-#define NAND_CMD_STATUS_ERROR0	0x73
-#define NAND_CMD_STATUS_ERROR1	0x74
-#define NAND_CMD_STATUS_ERROR2	0x75
-#define NAND_CMD_STATUS_ERROR3	0x76
-#define NAND_CMD_STATUS_RESET	0x7f
-#define NAND_CMD_STATUS_CLEAR	0xff
-
 #define NAND_CMD_NONE		-1
 
 /* Status bits */

commit 14c6578683367b1e7af0c3c09e872b45a45183a7
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Mon Mar 4 14:21:34 2013 +0200

    mtd: nand: remove AG-AND support
    
    We have only one AG-AND driver and it was not touched since 2005. It looks
    like AG-AND was not really make it to mass-production and can be considered
    a dead technology.
    
    Along with the AG-AND support, this patch removes the BBT_AUTO_REFRESH feature,
    because the only user of this feature is AG-AND. And even though it is
    implemented as a generic feature, I prefer to remove it because NAND flashes do
    not really need it in this form.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Acked-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index ef52d9c91459..7cc299436f94 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -171,22 +171,6 @@ typedef enum {
 #define NAND_CACHEPRG		0x00000008
 /* Chip has copy back function */
 #define NAND_COPYBACK		0x00000010
-/*
- * AND Chip which has 4 banks and a confusing page / block
- * assignment. See Renesas datasheet for further information.
- */
-#define NAND_IS_AND		0x00000020
-/*
- * Chip has a array of 4 pages which can be read without
- * additional ready /busy waits.
- */
-#define NAND_4PAGE_ARRAY	0x00000040
-/*
- * Chip requires that BBT is periodically rewritten to prevent
- * bits from adjacent blocks from 'leaking' in altering data.
- * This happens with the Renesas AG-AND chips, possibly others.
- */
-#define BBT_AUTO_REFRESH	0x00000080
 /*
  * Chip requires ready check on read (for auto-incremented sequential read).
  * True only for small page devices; large page devices do not support

commit 5bc7c33ca93a285dcfe7b7fd64970f6314440ad1
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Wed Mar 13 09:51:31 2013 -0700

    mtd: nand: reintroduce NAND_NO_READRDY as NAND_NEED_READRDY
    
    This partially reverts commit 1696e6bc2ae83734e64e206ac99766ea19e9a14e
    ("mtd: nand: kill NAND_NO_READRDY").
    
    In that patch I overlooked a few things.
    
    The original documentation for NAND_NO_READRDY included "True for all
    large page devices, as they do not support autoincrement." I was
    conflating "not support autoincrement" with the NAND_NO_AUTOINCR option,
    which was in fact doing nothing. So, when I dropped NAND_NO_AUTOINCR, I
    concluded that I then could harmlessly drop NAND_NO_READRDY. But of
    course the fact the NAND_NO_AUTOINCR was doing nothing didn't mean
    NAND_NO_READRDY was doing nothing...
    
    So, NAND_NO_READRDY is re-introduced as NAND_NEED_READRDY and applied
    only to those few remaining small-page NAND which needed it in the first
    place.
    
    Cc: stable@kernel.org [3.5+]
    Reported-by: Alexander Shiyan <shc_work@mail.ru>
    Tested-by: Alexander Shiyan <shc_work@mail.ru>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 7ccb3c59ed60..ef52d9c91459 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -187,6 +187,13 @@ typedef enum {
  * This happens with the Renesas AG-AND chips, possibly others.
  */
 #define BBT_AUTO_REFRESH	0x00000080
+/*
+ * Chip requires ready check on read (for auto-incremented sequential read).
+ * True only for small page devices; large page devices do not support
+ * autoincrement.
+ */
+#define NAND_NEED_READRDY	0x00000100
+
 /* Chip does not allow subpage writes */
 #define NAND_NO_SUBPAGE_WRITE	0x00000200
 

commit 64b37b2a63eb2f80b65c7185f0013f8ffc637ae3
Author: Matthieu CASTET <matthieu.castet@parrot.com>
Date:   Tue Nov 6 11:51:44 2012 +0100

    mtd: nand: add NAND_BUSWIDTH_AUTO to autodetect bus width
    
    The driver call nand_scan_ident in 8 bit mode, then
    readid or onfi detection are done (and detect bus width).
    The driver should update its bus width before calling nand_scan_tail.
    
    This work because readid and onfi are read work 8 byte mode.
    
    Note that nand_scan_ident send command (NAND_CMD_RESET, NAND_CMD_READID, NAND_CMD_PARAM), address and read data
    The ONFI specificication is not very clear for x16 device if high byte of address should be driven to 0,
    but according to [1] it should be ok to not drive it during autodetection.
    
    [1]
    3.3.2. Target Initialization
    
    [...]
    The Read ID and Read Parameter Page commands only use the lower 8-bits of the data bus.
    The host shall not issue commands that use a word data width on x16 devices until the host
    determines the device supports a 16-bit data bus width in the parameter page.
    
    Signed-off-by: Matthieu CASTET <matthieu.castet@parrot.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 9d8a6048aacd..7ccb3c59ed60 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -219,6 +219,13 @@ typedef enum {
 #define NAND_OWN_BUFFERS	0x00020000
 /* Chip may not exist, so silence any errors in scan */
 #define NAND_SCAN_SILENT_NODEV	0x00040000
+/*
+ * Autodetect nand buswidth with readid/onfi.
+ * This suppose the driver will configure the hardware in 8 bits mode
+ * when calling nand_scan_ident, and update its configuration
+ * before calling nand_scan_tail.
+ */
+#define NAND_BUSWIDTH_AUTO      0x00080000
 
 /* Options set by nand scan */
 /* Nand scan has allocated controller struct */

commit 9ef525a9141b14d23613faad303cf48a20814f1b
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Thu Oct 25 09:43:10 2012 -0400

    mtd: Fix kernel-doc content to avoid warning.
    
    Add missing colons to fix kernel-doc generation warnings.
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 24e915957e4f..9d8a6048aacd 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -471,8 +471,8 @@ struct nand_buffers {
  *			non 0 if ONFI supported.
  * @onfi_params:	[INTERN] holds the ONFI page parameter when ONFI is
  *			supported, 0 otherwise.
- * @onfi_set_features	[REPLACEABLE] set the features for ONFI nand
- * @onfi_get_features	[REPLACEABLE] get the features for ONFI nand
+ * @onfi_set_features:	[REPLACEABLE] set the features for ONFI nand
+ * @onfi_get_features:	[REPLACEABLE] get the features for ONFI nand
  * @ecclayout:		[REPLACEABLE] the default ECC placement scheme
  * @bbt:		[INTERN] bad block table pointer
  * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash

commit b9e48534d8f4eb17d531f54d2cb3b9138db13ccb
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Mon Sep 24 20:40:53 2012 -0700

    mtd: nand: increase max OOB size to 640
    
    Some Hynix and Samsung MLC NAND have 640B OOB size. Sooner or later, we should
    dynamically allocate the buffers that use these macros.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 2beeb6e4e4e6..24e915957e4f 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -56,7 +56,7 @@ extern int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
  * is supported now. If you add a chip with bigger oobsize/page
  * adjust this accordingly.
  */
-#define NAND_MAX_OOBSIZE	576
+#define NAND_MAX_OOBSIZE	640
 #define NAND_MAX_PAGESIZE	8192
 
 /*

commit 3e70192c41ac607c63c31ea00be62dd9afb85575
Author: Huang Shijie <b32955@freescale.com>
Date:   Thu Sep 13 14:57:53 2012 +0800

    mtd: add helpers to get the supportted ONFI timing mode
    
    add onfi_get_async_timing_mode() to get the supportted asynchronous
    timing mode.
    
    add onfi_get_sync_timing_mode() to get the supportted synchronous
    timing mode.
    
    Also add the neccessary macros : the timing modes.
    
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 922f313970d4..2beeb6e4e4e6 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -231,6 +231,15 @@ typedef enum {
 /* Keep gcc happy */
 struct nand_chip;
 
+/* ONFI timing mode, used in both asynchronous and synchronous mode */
+#define ONFI_TIMING_MODE_0		(1 << 0)
+#define ONFI_TIMING_MODE_1		(1 << 1)
+#define ONFI_TIMING_MODE_2		(1 << 2)
+#define ONFI_TIMING_MODE_3		(1 << 3)
+#define ONFI_TIMING_MODE_4		(1 << 4)
+#define ONFI_TIMING_MODE_5		(1 << 5)
+#define ONFI_TIMING_MODE_UNKNOWN	(1 << 6)
+
 /* ONFI feature address */
 #define ONFI_FEATURE_ADDR_TIMING_MODE	0x1
 
@@ -684,4 +693,20 @@ struct platform_nand_chip *get_platform_nandchip(struct mtd_info *mtd)
 	return chip->priv;
 }
 
+/* return the supported asynchronous timing mode. */
+static inline int onfi_get_async_timing_mode(struct nand_chip *chip)
+{
+	if (!chip->onfi_version)
+		return ONFI_TIMING_MODE_UNKNOWN;
+	return le16_to_cpu(chip->onfi_params.async_timing_mode);
+}
+
+/* return the supported synchronous timing mode. */
+static inline int onfi_get_sync_timing_mode(struct nand_chip *chip)
+{
+	if (!chip->onfi_version)
+		return ONFI_TIMING_MODE_UNKNOWN;
+	return le16_to_cpu(chip->onfi_params.src_sync_timing_mode);
+}
+
 #endif /* __LINUX_MTD_NAND_H */

commit 7db03eccfc23783a95dd78383b3fad55224aaa7b
Author: Huang Shijie <b32955@freescale.com>
Date:   Thu Sep 13 14:57:52 2012 +0800

    mtd: add helpers to set/get features for ONFI nand
    
    Add the set-features(0xef)/get-features(0xee) helpers for ONFI nand.
    Also add the necessary macros.
    
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index d245199ccaf3..922f313970d4 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -92,6 +92,8 @@ extern int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
 #define NAND_CMD_READID		0x90
 #define NAND_CMD_ERASE2		0xd0
 #define NAND_CMD_PARAM		0xec
+#define NAND_CMD_GET_FEATURES	0xee
+#define NAND_CMD_SET_FEATURES	0xef
 #define NAND_CMD_RESET		0xff
 
 #define NAND_CMD_LOCK		0x2a
@@ -229,6 +231,12 @@ typedef enum {
 /* Keep gcc happy */
 struct nand_chip;
 
+/* ONFI feature address */
+#define ONFI_FEATURE_ADDR_TIMING_MODE	0x1
+
+/* ONFI subfeature parameters length */
+#define ONFI_SUBFEATURE_PARAM_LEN	4
+
 struct nand_onfi_params {
 	/* rev info and features block */
 	/* 'O' 'N' 'F' 'I'  */
@@ -454,6 +462,8 @@ struct nand_buffers {
  *			non 0 if ONFI supported.
  * @onfi_params:	[INTERN] holds the ONFI page parameter when ONFI is
  *			supported, 0 otherwise.
+ * @onfi_set_features	[REPLACEABLE] set the features for ONFI nand
+ * @onfi_get_features	[REPLACEABLE] get the features for ONFI nand
  * @ecclayout:		[REPLACEABLE] the default ECC placement scheme
  * @bbt:		[INTERN] bad block table pointer
  * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash
@@ -496,6 +506,10 @@ struct nand_chip {
 	int (*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
 			const uint8_t *buf, int oob_required, int page,
 			int cached, int raw);
+	int (*onfi_set_features)(struct mtd_info *mtd, struct nand_chip *chip,
+			int feature_addr, uint8_t *subfeature_para);
+	int (*onfi_get_features)(struct mtd_info *mtd, struct nand_chip *chip,
+			int feature_addr, uint8_t *subfeature_para);
 
 	int chip_delay;
 	unsigned int options;

commit 5ca7f41528922c90da3ae3b917dc904047513be2
Author: Mike Dunn <mikedunn@newsguy.com>
Date:   Tue Sep 11 08:59:03 2012 -0700

    mtd: nand: expand description of read_page method in comment header
    
    In the absence of any formal documentation of the nand interface, I thought this
    patch to the header file might be helpful.
    
    Signed-off-by: Mike Dunn <mikedunn@newsguy.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 8f99d3621e12..d245199ccaf3 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -326,8 +326,10 @@ struct nand_hw_control {
  * @read_page_raw:	function to read a raw page without ECC
  * @write_page_raw:	function to write a raw page without ECC
  * @read_page:	function to read a page according to the ECC generator
- *		requirements.
- * @read_subpage:	function to read parts of the page covered by ECC.
+ *		requirements; returns maximum number of bitflips corrected in
+ *		any single ECC step, 0 if bitflips uncorrectable, -EIO hw error
+ * @read_subpage:	function to read parts of the page covered by ECC;
+ *			returns same as read_page()
  * @write_page:	function to write a page according to the ECC generator
  *		requirements.
  * @write_oob_raw:	function to write chip OOB data without ECC

commit a5ff4f102937a3492bca4a9ff0c341d78813414c
Author: Jeff Westfahl <jeff.westfahl@ni.com>
Date:   Mon Aug 13 16:35:30 2012 -0500

    mtd: nand: Added a device flag for subpage read support
    
    Added a NAND device flag for subpage read support. Previously this was
    hard coded based on large page and soft ECC.
    Updated base NAND driver to use the new subpage read flag if the NAND is
    large page and soft ECC.
    
    Signed-off-by: Jeff Westfahl <jeff.westfahl@ni.com>
    Reviewed-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 6bdad331cee4..8f99d3621e12 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -194,6 +194,9 @@ typedef enum {
 /* Device behaves just like nand, but is readonly */
 #define NAND_ROM		0x00000800
 
+/* Device supports subpage reads */
+#define NAND_SUBPAGE_READ	0x00001000
+
 /* Options valid for Samsung large page devices */
 #define NAND_SAMSUNG_LP_OPTIONS \
 	(NAND_NO_PADDING | NAND_CACHEPRG | NAND_COPYBACK)
@@ -202,9 +205,7 @@ typedef enum {
 #define NAND_MUST_PAD(chip) (!(chip->options & NAND_NO_PADDING))
 #define NAND_HAS_CACHEPROG(chip) ((chip->options & NAND_CACHEPRG))
 #define NAND_HAS_COPYBACK(chip) ((chip->options & NAND_COPYBACK))
-/* Large page NAND with SOFT_ECC should support subpage reads */
-#define NAND_SUBPAGE_READ(chip) ((chip->ecc.mode == NAND_ECC_SOFT) \
-					&& (chip->page_shift > 9))
+#define NAND_HAS_SUBPAGE_READ(chip) ((chip->options & NAND_SUBPAGE_READ))
 
 /* Non chip related options */
 /* This option skips the bbt scan during initialization. */

commit 25806d3cd2d3214225a86ade366364d4d9a911eb
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sat Aug 18 17:41:35 2012 -0700

    mtd: fix kernel-doc warning in include/linux/mtd/nand.h
    
    Fix kernel-doc warning in <linux/mtd/nand.h>:
    
    Warning(include/linux/mtd/nand.h:659): No description found for parameter 'read_byte'
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Acked-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 1d90e4f82bcf..6bdad331cee4 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -630,6 +630,7 @@ struct platform_device;
  *			ALE/CLE/nCE. Also used to write command and address
  * @write_buf:		platform specific function for write buffer
  * @read_buf:		platform specific function for read buffer
+ * @read_byte:		platform specific function to read one byte from chip
  * @priv:		private data to transport driver specific settings
  *
  * All fields are optional and depend on the hardware driver requirements

commit 657f28f8811c92724db10d18bbbec70d540147d6
Author: Huang Shijie <shijie8@gmail.com>
Date:   Tue Aug 14 22:38:45 2012 -0400

    mtd: kill MTD_NAND_VERIFY_WRITE
    
    Just as Artem suggested:
    
    "Both UBI and JFFS2 are able to read verify what they wrote already.
    There are also MTD tests which do this verification. So I think there
    is no reason to keep this in the NAND layer, let alone wasting RAM in
    the driver to support this feature. Besides, it does not work for sub-pages
    and many drivers have it broken. It hurts more than it provides benefits."
    
    So kill MTD_NAND_VERIFY_WRITE entirely.
    
    Signed-off-by: Huang Shijie <shijie8@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index eeb70153b646..1d90e4f82bcf 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -394,8 +394,6 @@ struct nand_buffers {
  * @read_word:		[REPLACEABLE] read one word from the chip
  * @write_buf:		[REPLACEABLE] write data from the buffer to the chip
  * @read_buf:		[REPLACEABLE] read data from the chip into the buffer
- * @verify_buf:		[REPLACEABLE] verify buffer contents against the chip
- *			data.
  * @select_chip:	[REPLACEABLE] select chip nr
  * @block_bad:		[REPLACEABLE] check, if the block is bad
  * @block_markbad:	[REPLACEABLE] mark the block bad
@@ -478,7 +476,6 @@ struct nand_chip {
 	u16 (*read_word)(struct mtd_info *mtd);
 	void (*write_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
 	void (*read_buf)(struct mtd_info *mtd, uint8_t *buf, int len);
-	int (*verify_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
 	void (*select_chip)(struct mtd_info *mtd, int chip);
 	int (*block_bad)(struct mtd_info *mtd, loff_t ofs, int getchip);
 	int (*block_markbad)(struct mtd_info *mtd, loff_t ofs);

commit bf7a01bf7987b63b121d572b240c132ec44129c4
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Jul 13 09:28:24 2012 -0700

    mtd: nand: allow NAND_NO_SUBPAGE_WRITE to be set from driver
    
    The NAND_CHIPOPTIONS_MSK has limited utility and is causing real bugs. It
    silently masks off at least one flag that might be set by the driver
    (NAND_NO_SUBPAGE_WRITE). This breaks the GPMI NAND driver and possibly
    others.
    
    Really, as long as driver writers exercise a small amount of care with
    NAND_* options, this mask is not necessary at all; it was only here to
    prevent certain options from accidentally being set by the driver. But the
    original thought turns out to be a bad idea occasionally. Thus, kill it.
    
    Note, this patch fixes some major gpmi-nand breakage.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Tested-by: Huang Shijie <shijie8@gmail.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 6dce5a7154bb..eeb70153b646 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -206,9 +206,6 @@ typedef enum {
 #define NAND_SUBPAGE_READ(chip) ((chip->ecc.mode == NAND_ECC_SOFT) \
 					&& (chip->page_shift > 9))
 
-/* Mask to zero out the chip options, which come from the id table */
-#define NAND_CHIPOPTIONS_MSK	0x0000ffff
-
 /* Non chip related options */
 /* This option skips the bbt scan during initialization. */
 #define NAND_SKIP_BBTSCAN	0x00010000

commit fdbad98dff8007f2b8bee6698b5d25ebba0471c9
Author: Josh Wu <josh.wu@atmel.com>
Date:   Mon Jun 25 18:07:45 2012 +0800

    mtd: nand: teach write_page and write_page_raw return an error code
    
    There is an implemention of hardware ECC write page function which may return an
    error indication.
    For instance, using Atmel HW PMECC to write one page into a nand flash, the hardware
    engine will compute the BCH ecc code for this page. so we need read a the
    status register to theck whether the ecc code is generated.
    But we cannot assume the status register always can be ready, for example,
    incorrect hardware configuration or hardware issue, in such case we need
    write_page() to return a error code.
    
    Since the definition of 'write_page' function in struct nand_ecc_ctrl is 'void'.
    So this patch will:
      1. add return 'int' value for 'write_page' function.
      2. to be consitent, add return 'int' value for 'write_page_raw' fuctions too.
      3. add code to test the return value, and if negative, indicate an
      error happend when write page with ECC.
      4. fix the compile warning in all impacted nand flash driver.
    
    Note: I couldn't compile-test all of these easily, as some had ARCH dependencies.
    
    Signed-off-by: Josh Wu <josh.wu@atmel.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index a81ac89a6950..6dce5a7154bb 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -355,13 +355,13 @@ struct nand_ecc_ctrl {
 			uint8_t *calc_ecc);
 	int (*read_page_raw)(struct mtd_info *mtd, struct nand_chip *chip,
 			uint8_t *buf, int oob_required, int page);
-	void (*write_page_raw)(struct mtd_info *mtd, struct nand_chip *chip,
+	int (*write_page_raw)(struct mtd_info *mtd, struct nand_chip *chip,
 			const uint8_t *buf, int oob_required);
 	int (*read_page)(struct mtd_info *mtd, struct nand_chip *chip,
 			uint8_t *buf, int oob_required, int page);
 	int (*read_subpage)(struct mtd_info *mtd, struct nand_chip *chip,
 			uint32_t offs, uint32_t len, uint8_t *buf);
-	void (*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
+	int (*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
 			const uint8_t *buf, int oob_required);
 	int (*write_oob_raw)(struct mtd_info *mtd, struct nand_chip *chip,
 			int page);

commit 1696e6bc2ae83734e64e206ac99766ea19e9a14e
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue May 22 23:50:00 2012 -0700

    mtd: nand: kill NAND_NO_READRDY
    
    According to its documentation, the NAND_NO_READRDY option is always used
    when autoincrement is not supported. Autoincrement support was recently
    dropped, so we can drop this options as well (defaulting to "no read ready
    check").
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 53dcf4973c1b..a81ac89a6950 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -185,12 +185,6 @@ typedef enum {
  * This happens with the Renesas AG-AND chips, possibly others.
  */
 #define BBT_AUTO_REFRESH	0x00000080
-/*
- * Chip does not require ready check on read. True
- * for all large page devices, as they do not support
- * autoincrement.
- */
-#define NAND_NO_READRDY		0x00000100
 /* Chip does not allow subpage writes */
 #define NAND_NO_SUBPAGE_WRITE	0x00000200
 

commit b1ccfab31a0bbcb103989cba3b08df0776ff90fe
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue May 22 07:30:47 2012 -0700

    mtd: nand: add Eon Silicon Solutions manufacturer ID
    
    Eon's new NAND flash: EN27LN1G08.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 57977c640529..53dcf4973c1b 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -559,6 +559,7 @@ struct nand_chip {
 #define NAND_MFR_MICRON		0x2c
 #define NAND_MFR_AMD		0x01
 #define NAND_MFR_MACRONIX	0xc2
+#define NAND_MFR_EON		0x92
 
 /**
  * struct nand_flash_dev - NAND Flash Device ID Structure

commit 5c2ffb11d40dd967eecb45b8570a871746ba124b
Author: Shmulik Ladkani <shmulik.ladkani@gmail.com>
Date:   Wed May 9 13:06:35 2012 +0300

    mtd: nand: remove 'sndcmd' parameter of 'read_oob/read_oob_raw'
    
    As of [mtd: nand: remove autoincrement 'sndcmd' code], the
    NAND_CMD_READ0 command is issued unconditionally.
    
    Thus, read_oob/read_oob_raw's 'sndcmd' argument is no longer needed, as
    well as their return code.
    
    Remove the 'sndcmd' parameter, and set the return code to 0.
    
    Signed-off-by: Shmulik Ladkani <shmulik.ladkani@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index c7755f455c81..57977c640529 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -372,9 +372,8 @@ struct nand_ecc_ctrl {
 	int (*write_oob_raw)(struct mtd_info *mtd, struct nand_chip *chip,
 			int page);
 	int (*read_oob_raw)(struct mtd_info *mtd, struct nand_chip *chip,
-			int page, int sndcmd);
-	int (*read_oob)(struct mtd_info *mtd, struct nand_chip *chip, int page,
-			int sndcmd);
+			int page);
+	int (*read_oob)(struct mtd_info *mtd, struct nand_chip *chip, int page);
 	int (*write_oob)(struct mtd_info *mtd, struct nand_chip *chip,
 			int page);
 };

commit 1fbb938dff5b6bb4514a4e7600276b03c7f08e25
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Wed May 2 10:14:55 2012 -0700

    mtd: nand: add 'oob_required' argument to NAND {read,write}_page interfaces
    
    New NAND controllers can perform read/write via HW engines which don't expose
    OOB data in their DMA mode. To reflect this, we should rework the nand_chip /
    nand_ecc_ctrl interfaces that assume that drivers will always read/write OOB
    data in the nand_chip.oob_poi buffer. A better interface includes a boolean
    argument that explicitly tells the callee when OOB data is requested by the
    calling layer (for reading/writing to/from nand_chip.oob_poi).
    
    This patch adds the 'oob_required' parameter to each relevant {read,write}_page
    interface; all 'oob_required' parameters are left unused for now. The next
    patch will set the parameter properly in the nand_base.c callers, and follow-up
    patches will make use of 'oob_required' in some of the callee functions.
    
    Note that currently, there is no harm in ignoring the 'oob_required' parameter
    and *always* utilizing nand_chip.oob_poi, but there can be
    performance/complexity/design benefits from avoiding filling oob_poi in the
    common case. I will try to implement this for some drivers which can be ported
    easily.
    
    Note: I couldn't compile-test all of these easily, as some had ARCH
    dependencies.
    
    [dwmw2: Merge later 1/0 vs. true/false cleanup]
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Reviewed-by: Shmulik Ladkani <shmulik.ladkani@gmail.com>
    Acked-by: Jiandong Zheng <jdzheng@broadcom.com>
    Acked-by: Mike Dunn <mikedunn@newsguy.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 94a6679bfc2e..c7755f455c81 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -360,15 +360,15 @@ struct nand_ecc_ctrl {
 	int (*correct)(struct mtd_info *mtd, uint8_t *dat, uint8_t *read_ecc,
 			uint8_t *calc_ecc);
 	int (*read_page_raw)(struct mtd_info *mtd, struct nand_chip *chip,
-			uint8_t *buf, int page);
+			uint8_t *buf, int oob_required, int page);
 	void (*write_page_raw)(struct mtd_info *mtd, struct nand_chip *chip,
-			const uint8_t *buf);
+			const uint8_t *buf, int oob_required);
 	int (*read_page)(struct mtd_info *mtd, struct nand_chip *chip,
-			uint8_t *buf, int page);
+			uint8_t *buf, int oob_required, int page);
 	int (*read_subpage)(struct mtd_info *mtd, struct nand_chip *chip,
 			uint32_t offs, uint32_t len, uint8_t *buf);
 	void (*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
-			const uint8_t *buf);
+			const uint8_t *buf, int oob_required);
 	int (*write_oob_raw)(struct mtd_info *mtd, struct nand_chip *chip,
 			int page);
 	int (*read_oob_raw)(struct mtd_info *mtd, struct nand_chip *chip,
@@ -504,7 +504,8 @@ struct nand_chip {
 	int (*errstat)(struct mtd_info *mtd, struct nand_chip *this, int state,
 			int status, int page);
 	int (*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
-			const uint8_t *buf, int page, int cached, int raw);
+			const uint8_t *buf, int oob_required, int page,
+			int cached, int raw);
 
 	int chip_delay;
 	unsigned int options;

commit b4f7aa84d6ff44327ab91a2973ebf0c2a7797d24
Author: John Crispin <blogic@openwrt.org>
Date:   Mon Apr 30 19:30:47 2012 +0200

    mtd: add read_byte support to plat_nand
    
    Lantiq SoCs have a External Bus Unit (EBU) that is used to attach MTD media.
    As we need to co-exist with PCI on the same bus, certain swapping settings must
    be applied. Similar to the NOR map driver we need to apply a fix to make NAND
    work. The easiest way is to use byte reads.
    
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 627f0c575ac4..94a6679bfc2e 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -654,6 +654,7 @@ struct platform_nand_ctrl {
 	void (*cmd_ctrl)(struct mtd_info *mtd, int dat, unsigned int ctrl);
 	void (*write_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
 	void (*read_buf)(struct mtd_info *mtd, uint8_t *buf, int len);
+	unsigned char (*read_byte)(struct mtd_info *mtd);
 	void *priv;
 };
 

commit 1826dbccebc9a58a0b0c0a9b7c09e47b19d97398
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue May 1 17:12:55 2012 -0700

    mtd: nand: kill NAND_NO_AUTOINCR option
    
    No drivers use auto-increment NAND, so kill the NO_AUTOINCR option entirely.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 2829e8be3a62..627f0c575ac4 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -161,8 +161,6 @@ typedef enum {
  * Option constants for bizarre disfunctionality and real
  * features.
  */
-/* Chip can not auto increment pages */
-#define NAND_NO_AUTOINCR	0x00000001
 /* Buswidth is 16 bit */
 #define NAND_BUSWIDTH_16	0x00000002
 /* Device supports partial programming without padding */
@@ -207,7 +205,6 @@ typedef enum {
 	(NAND_NO_PADDING | NAND_CACHEPRG | NAND_COPYBACK)
 
 /* Macros to identify the above */
-#define NAND_CANAUTOINCR(chip) (!(chip->options & NAND_NO_AUTOINCR))
 #define NAND_MUST_PAD(chip) (!(chip->options & NAND_NO_PADDING))
 #define NAND_HAS_CACHEPROG(chip) ((chip->options & NAND_CACHEPRG))
 #define NAND_HAS_COPYBACK(chip) ((chip->options & NAND_COPYBACK))
@@ -216,7 +213,7 @@ typedef enum {
 					&& (chip->page_shift > 9))
 
 /* Mask to zero out the chip options, which come from the id table */
-#define NAND_CHIPOPTIONS_MSK	(0x0000ffff & ~NAND_NO_AUTOINCR)
+#define NAND_CHIPOPTIONS_MSK	0x0000ffff
 
 /* Non chip related options */
 /* This option skips the bbt scan during initialization. */

commit edbc4540e02c201bdd4f4d498ebb6ed517fd36e2
Author: Mike Dunn <mikedunn@newsguy.com>
Date:   Wed Apr 25 12:06:11 2012 -0700

    mtd: driver _read() returns max_bitflips; mtd_read() returns -EUCLEAN
    
    The drivers' _read() method, absent an error, returns a non-negative integer
    indicating the maximum number of bit errors that were corrected in any one
    region comprising an ecc step.  MTD returns -EUCLEAN if this is >=
    bitflip_threshold, 0 otherwise.  If bitflip_threshold is zero, the comparison is
    not made since these devices lack ECC and always return zero in the non-error
    case (thanks Brian)¹.  Note that this is a subtle change to the driver
    interface.
    
    This and the preceding patches in this set were tested with ubi on top of the
    nandsim and docg4 devices, running the ubi test io_basic from mtd-utils.
    
    ¹ http://lists.infradead.org/pipermail/linux-mtd/2012-March/040468.html
    
    Signed-off-by: Mike Dunn <mikedunn@newsguy.com>
    Acked-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Acked-by: Brian Norris <computersforpeace@gmail.com>
    Ivan Djelic <ivan.djelic@parrot.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 1482340d3d9f..2829e8be3a62 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -459,6 +459,8 @@ struct nand_buffers {
  * @pagemask:		[INTERN] page number mask = number of (pages / chip) - 1
  * @pagebuf:		[INTERN] holds the pagenumber which is currently in
  *			data_buf.
+ * @pagebuf_bitflips:	[INTERN] holds the bitflip count for the page which is
+ *			currently in data_buf.
  * @subpagesize:	[INTERN] holds the subpagesize
  * @onfi_version:	[INTERN] holds the chip ONFI version (BCD encoded),
  *			non 0 if ONFI supported.
@@ -519,6 +521,7 @@ struct nand_chip {
 	uint64_t chipsize;
 	int pagemask;
 	int pagebuf;
+	unsigned int pagebuf_bitflips;
 	int subpagesize;
 	uint8_t cellinfo;
 	int badblockpos;

commit 1d0b95b0834087ba3653f69c24483d63a26d51a7
Author: Mike Dunn <mikedunn@newsguy.com>
Date:   Sun Mar 11 14:21:10 2012 -0700

    mtd: add ecc_strength fields to mtd structs
    
    This adds 'ecc_strength' to struct mtd_info.  This stores the maximum number of
    bit errors that can be corrected in one writesize region.
    
    For consistency with the nand code, 'strength' is similiarly added to struct
    nand_ecc_ctrl.  This stores the maximum number of bit errors that can be
    corrected in one ecc step.
    
    Signed-off-by: Mike Dunn <mikedunn@newsguy.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 609868f3db42..1482340d3d9f 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -324,6 +324,7 @@ struct nand_hw_control {
  * @steps:	number of ECC steps per page
  * @size:	data bytes per ECC step
  * @bytes:	ECC bytes per step
+ * @strength:	max number of correctible bits per ECC step
  * @total:	total number of ECC bytes per page
  * @prepad:	padding information for syndrome based ECC generators
  * @postpad:	padding information for syndrome based ECC generators
@@ -351,6 +352,7 @@ struct nand_ecc_ctrl {
 	int size;
 	int bytes;
 	int total;
+	int strength;
 	int prepad;
 	int postpad;
 	struct nand_ecclayout	*layout;

commit 661a08327d11bcc4cf649c5ae4bdf2db0a87b320
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Jan 13 18:11:50 2012 -0800

    mtd: nand: correct comment on nand_chip badblockbits
    
    The description for badblockbits is incorrect. I think someone just made
    up a false description on the spot to satisfy some kerneldoc warning.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 63b5a8b6dfbd..609868f3db42 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -448,8 +448,9 @@ struct nand_buffers {
  *			will be copied to the appropriate nand_bbt_descr's.
  * @badblockpos:	[INTERN] position of the bad block marker in the oob
  *			area.
- * @badblockbits:	[INTERN] number of bits to left-shift the bad block
- *			number
+ * @badblockbits:	[INTERN] minimum number of set bits in a good block's
+ *			bad block marker position; i.e., BBM == 11110111b is
+ *			not bad when badblockbits == 7
  * @cellinfo:		[INTERN] MLC/multichip data from chip ident
  * @numchips:		[INTERN] number of physical chips
  * @chipsize:		[INTERN] the size of one chip for multichip arrays

commit c1257b4798d48b73ad1a9ca359504cd49caefa0d
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Wed Nov 2 13:34:42 2011 -0700

    mtd: nand: add Macronix manufacturer
    
    Macronix is produing SLC NAND MX30LF1208AA, so add their manufacturer
    code to the manufacturer lists.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 904131bab501..63b5a8b6dfbd 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -555,6 +555,7 @@ struct nand_chip {
 #define NAND_MFR_HYNIX		0xad
 #define NAND_MFR_MICRON		0x2c
 #define NAND_MFR_AMD		0x01
+#define NAND_MFR_MACRONIX	0xc2
 
 /**
  * struct nand_flash_dev - NAND Flash Device ID Structure

commit 4a89ff885ff9f64ea62669100766e10e4e257c6e
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Aug 30 18:45:45 2011 -0700

    mtd: nand: kill member `ops' of `struct nand_chip'
    
    The nand_chip.ops field is a struct that is passed around globally with
    no particular reason. Every time it is used, it could just as easily be
    replaced with a local struct that is updated on each operation. So make
    it local.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 0b3d464cba13..904131bab501 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -427,7 +427,6 @@ struct nand_buffers {
  * @ecc:		[BOARDSPECIFIC] ECC control structure
  * @buffers:		buffer structure for read/write
  * @hwcontrol:		platform-specific hardware control structure
- * @ops:		oob operation operands
  * @erase_cmd:		[INTERN] erase command write function, selectable due
  *			to AND support.
  * @scan_bbt:		[REPLACEABLE] function to scan bad block table
@@ -535,8 +534,6 @@ struct nand_chip {
 	struct nand_buffers *buffers;
 	struct nand_hw_control hwcontrol;
 
-	struct mtd_oob_ops ops;
-
 	uint8_t *bbt;
 	struct nand_bbt_descr *bbt_td;
 	struct nand_bbt_descr *bbt_md;

commit c46f6483d21e93400e4a110de7902830173d53b0
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Aug 30 18:45:38 2011 -0700

    mtd: support reading OOB without ECC
    
    This fixes issues with `nanddump -n' and the MEMREADOOB[64] ioctls on
    hardware that performs error correction when reading only OOB data. A
    driver for such hardware needs to know when we're doing a RAW vs. a
    normal write, but mtd_do_read_oob does not pass such information to the
    lower layers (e.g., NAND). We should pass MTD_OOB_RAW or MTD_OOB_PLACE
    based on the MTD file mode.
    
    For now, most drivers can get away with just setting:
    
      chip->ecc.read_oob_raw = chip->ecc.read_oob
    
    This is done by default; but for systems that behave as described above,
    you must supply your own replacement function.
    
    This was tested with nandsim as well as on actual SLC NAND.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Cc: Jim Quinlan <jim2101024@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index c7113a9cd66d..0b3d464cba13 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -341,6 +341,7 @@ struct nand_hw_control {
  * @write_page:	function to write a page according to the ECC generator
  *		requirements.
  * @write_oob_raw:	function to write chip OOB data without ECC
+ * @read_oob_raw:	function to read chip OOB data without ECC
  * @read_oob:	function to read chip OOB data
  * @write_oob:	function to write chip OOB data
  */
@@ -371,6 +372,8 @@ struct nand_ecc_ctrl {
 			const uint8_t *buf);
 	int (*write_oob_raw)(struct mtd_info *mtd, struct nand_chip *chip,
 			int page);
+	int (*read_oob_raw)(struct mtd_info *mtd, struct nand_chip *chip,
+			int page, int sndcmd);
 	int (*read_oob)(struct mtd_info *mtd, struct nand_chip *chip, int page,
 			int sndcmd);
 	int (*write_oob)(struct mtd_info *mtd, struct nand_chip *chip,

commit e9195edc59f33e9cabdd32a2959e927806670f45
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Aug 30 18:45:43 2011 -0700

    mtd: nand: document nand_chip.oob_poi
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 5f3fdd9877b7..c7113a9cd66d 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -431,7 +431,8 @@ struct nand_buffers {
  * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transferring
  *			data from array to read regs (tR).
  * @state:		[INTERN] the current state of the NAND device
- * @oob_poi:		poison value buffer
+ * @oob_poi:		"poison value buffer," used for laying out OOB data
+ *			before writing
  * @page_shift:		[INTERN] number of address bits in a page (column
  *			address bits).
  * @phys_erase_shift:	[INTERN] number of address bits in a physical eraseblock

commit 9ce244b3fb416ce6600e05612ac46b9692dcc638
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Aug 30 18:45:37 2011 -0700

    mtd: support writing OOB without ECC
    
    This fixes issues with `nandwrite -n -o' and the MEMWRITEOOB[64] ioctls
    on hardware that writes ECC when writing OOB. The problem arises as
    follows: `nandwrite -n' can write page data to flash without applying
    ECC, but when used with the `-o' option, ECC is applied (incorrectly),
    contrary to the `--noecc' option.
    
    I found that this is the case because my hardware computes and writes
    ECC data to flash upon either OOB write or page write. Thus, to support
    a proper "no ECC" write, my driver must know when we're performing a raw
    OOB write vs. a normal ECC OOB write. However, MTD does not pass any raw
    mode information to the write_oob functions.  This patch addresses the
    problems by:
    
    1) Passing MTD_OOB_RAW down to lower layers, instead of just defaulting
       to MTD_OOB_PLACE
    2) Handling MTD_OOB_RAW within the NAND layer's `nand_do_write_oob'
    3) Adding a new (replaceable) function pointer in struct ecc_ctrl; this
       function should support writing OOB without ECC data. Current
       hardware often can use the same OOB write function when writing
       either with or without ECC
    
    This was tested with nandsim as well as on actual SLC NAND.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Cc: Jim Quinlan <jim2101024@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 85fef68a379d..5f3fdd9877b7 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -340,6 +340,7 @@ struct nand_hw_control {
  * @read_subpage:	function to read parts of the page covered by ECC.
  * @write_page:	function to write a page according to the ECC generator
  *		requirements.
+ * @write_oob_raw:	function to write chip OOB data without ECC
  * @read_oob:	function to read chip OOB data
  * @write_oob:	function to write chip OOB data
  */
@@ -368,6 +369,8 @@ struct nand_ecc_ctrl {
 			uint32_t offs, uint32_t len, uint8_t *buf);
 	void (*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
 			const uint8_t *buf);
+	int (*write_oob_raw)(struct mtd_info *mtd, struct nand_chip *chip,
+			int page);
 	int (*read_oob)(struct mtd_info *mtd, struct nand_chip *chip, int page,
 			int sndcmd);
 	int (*write_oob)(struct mtd_info *mtd, struct nand_chip *chip,

commit 32c8db8f622a4cb8ea9d571d462580f7137babbb
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Aug 23 17:17:35 2011 -0700

    mtd: nand: fix spelling error (date => data)
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 6d5696876b3f..85fef68a379d 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -465,7 +465,7 @@ struct nand_buffers {
  * @controller:		[REPLACEABLE] a pointer to a hardware controller
  *			structure which is shared among multiple independent
  *			devices.
- * @priv:		[OPTIONAL] pointer to private chip date
+ * @priv:		[OPTIONAL] pointer to private chip data
  * @errstat:		[OPTIONAL] hardware specific function to perform
  *			additional error status checks (determine if errors are
  *			correctable).

commit b4ca74738ab6c9ed8190b06cd7bf785dc98c640e
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Fri Jul 1 13:51:15 2011 +0200

    mtd: plat-nand: Fixup kerneldoc for struct platform_nand_chip
    
    The set_parts and priv members of struct platform_nand_chip where
    removed in commit c36a6ef3845262ade529afb9f458738b1f196f83 but the
    kerneldoc wasn't updated.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Artem Bityutskiy <dedekind1@gmail.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 877fbbda02cd..6d5696876b3f 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -606,8 +606,6 @@ extern int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
  * @bbt_options:	BBT option flags, e.g. NAND_BBT_USE_FLASH
  * @ecclayout:		ECC layout info structure
  * @part_probe_types:	NULL-terminated array of probe types
- * @set_parts:		platform specific function to set partitions
- * @priv:		hardware controller specific settings
  */
 struct platform_nand_chip {
 	int nr_chips;

commit 7854d3f7495b11be1570cd3e2318674d8f9ed797
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Thu Jun 23 14:12:08 2011 -0700

    mtd: spelling, capitalization, uniformity
    
    Therefor -> Therefore
    [Intern], [Internal] -> [INTERN]
    [REPLACABLE] -> [REPLACEABLE]
    syndrom, syndom -> syndrome
    ecc -> ECC
    buswith -> buswidth
    endianess -> endianness
    dont -> don't
    occures -> occurs
    independend -> independent
    wihin -> within
    erease -> erase
    blockes -> blocks
    ...
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 0f239e714219..877fbbda02cd 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -42,10 +42,10 @@ extern void nand_release(struct mtd_info *mtd);
 /* Internal helper for board drivers which need to override command function */
 extern void nand_wait_ready(struct mtd_info *mtd);
 
-/* locks all blockes present in the device */
+/* locks all blocks present in the device */
 extern int nand_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
 
-/* unlocks specified locked blockes */
+/* unlocks specified locked blocks */
 extern int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
 
 /* The maximum number of NAND chips in an array */
@@ -150,7 +150,7 @@ typedef enum {
 #define NAND_ECC_READ		0
 /* Reset Hardware ECC for write */
 #define NAND_ECC_WRITE		1
-/* Enable Hardware ECC before syndrom is read back from flash */
+/* Enable Hardware ECC before syndrome is read back from flash */
 #define NAND_ECC_READSYN	2
 
 /* Bit mask for flags passed to do_nand_read_ecc */
@@ -163,7 +163,7 @@ typedef enum {
  */
 /* Chip can not auto increment pages */
 #define NAND_NO_AUTOINCR	0x00000001
-/* Buswitdh is 16 bit */
+/* Buswidth is 16 bit */
 #define NAND_BUSWIDTH_16	0x00000002
 /* Device supports partial programming without padding */
 #define NAND_NO_PADDING		0x00000004
@@ -319,26 +319,26 @@ struct nand_hw_control {
 };
 
 /**
- * struct nand_ecc_ctrl - Control structure for ecc
- * @mode:	ecc mode
- * @steps:	number of ecc steps per page
- * @size:	data bytes per ecc step
- * @bytes:	ecc bytes per step
- * @total:	total number of ecc bytes per page
- * @prepad:	padding information for syndrome based ecc generators
- * @postpad:	padding information for syndrome based ecc generators
+ * struct nand_ecc_ctrl - Control structure for ECC
+ * @mode:	ECC mode
+ * @steps:	number of ECC steps per page
+ * @size:	data bytes per ECC step
+ * @bytes:	ECC bytes per step
+ * @total:	total number of ECC bytes per page
+ * @prepad:	padding information for syndrome based ECC generators
+ * @postpad:	padding information for syndrome based ECC generators
  * @layout:	ECC layout control struct pointer
- * @priv:	pointer to private ecc control data
- * @hwctl:	function to control hardware ecc generator. Must only
+ * @priv:	pointer to private ECC control data
+ * @hwctl:	function to control hardware ECC generator. Must only
  *		be provided if an hardware ECC is available
- * @calculate:	function for ecc calculation or readback from ecc hardware
- * @correct:	function for ecc correction, matching to ecc generator (sw/hw)
+ * @calculate:	function for ECC calculation or readback from ECC hardware
+ * @correct:	function for ECC correction, matching to ECC generator (sw/hw)
  * @read_page_raw:	function to read a raw page without ECC
  * @write_page_raw:	function to write a raw page without ECC
- * @read_page:	function to read a page according to the ecc generator
+ * @read_page:	function to read a page according to the ECC generator
  *		requirements.
  * @read_subpage:	function to read parts of the page covered by ECC.
- * @write_page:	function to write a page according to the ecc generator
+ * @write_page:	function to write a page according to the ECC generator
  *		requirements.
  * @read_oob:	function to read chip OOB data
  * @write_oob:	function to write chip OOB data
@@ -376,8 +376,8 @@ struct nand_ecc_ctrl {
 
 /**
  * struct nand_buffers - buffer structure for read/write
- * @ecccalc:	buffer for calculated ecc
- * @ecccode:	buffer for ecc read from flash
+ * @ecccalc:	buffer for calculated ECC
+ * @ecccode:	buffer for ECC read from flash
  * @databuf:	buffer for data - dynamically sized
  *
  * Do not change the order of buffers. databuf and oobrbuf must be in
@@ -410,7 +410,7 @@ struct nand_buffers {
  *			mtd->oobsize, mtd->writesize and so on.
  *			@id_data contains the 8 bytes values of NAND_CMD_READID.
  *			Return with the bus width.
- * @dev_ready:		[BOARDSPECIFIC] hardwarespecific function for accesing
+ * @dev_ready:		[BOARDSPECIFIC] hardwarespecific function for accessing
  *			device ready/busy line. If set to NULL no access to
  *			ready/busy is available and the ready/busy information
  *			is read from the chip status register.
@@ -418,7 +418,7 @@ struct nand_buffers {
  *			commands to the chip.
  * @waitfunc:		[REPLACEABLE] hardwarespecific function for wait on
  *			ready.
- * @ecc:		[BOARDSPECIFIC] ecc control ctructure
+ * @ecc:		[BOARDSPECIFIC] ECC control structure
  * @buffers:		buffer structure for read/write
  * @hwcontrol:		platform-specific hardware control structure
  * @ops:		oob operation operands
@@ -455,7 +455,7 @@ struct nand_buffers {
  *			non 0 if ONFI supported.
  * @onfi_params:	[INTERN] holds the ONFI page parameter when ONFI is
  *			supported, 0 otherwise.
- * @ecclayout:		[REPLACEABLE] the default ecc placement scheme
+ * @ecclayout:		[REPLACEABLE] the default ECC placement scheme
  * @bbt:		[INTERN] bad block table pointer
  * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash
  *			lookup.
@@ -463,7 +463,7 @@ struct nand_buffers {
  * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for initial
  *			bad block scan.
  * @controller:		[REPLACEABLE] a pointer to a hardware controller
- *			structure which is shared among multiple independend
+ *			structure which is shared among multiple independent
  *			devices.
  * @priv:		[OPTIONAL] pointer to private chip date
  * @errstat:		[OPTIONAL] hardware specific function to perform
@@ -604,7 +604,7 @@ extern int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
  * @chip_delay:		R/B delay value in us
  * @options:		Option flags, e.g. 16bit buswidth
  * @bbt_options:	BBT option flags, e.g. NAND_BBT_USE_FLASH
- * @ecclayout:		ecc layout info structure
+ * @ecclayout:		ECC layout info structure
  * @part_probe_types:	NULL-terminated array of probe types
  * @set_parts:		platform specific function to set partitions
  * @priv:		hardware controller specific settings

commit 0dc8626a17ab8dea9f1e34c7a5d667f5331b0ddc
Author: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
Date:   Mon Jun 6 18:04:16 2011 +0400

    mtd: plat-nand: drop unused fields from platform_nand_data
    
    Drop now unused set_parts from struct platform_nand_data. Also, while we are
    at it, drop long unused priv field from platform_nand_data.
    
    Signed-off-by: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 4a43ffc535c9..0f239e714219 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -619,8 +619,6 @@ struct platform_nand_chip {
 	unsigned int options;
 	unsigned int bbt_options;
 	const char **part_probe_types;
-	void (*set_parts)(uint64_t size, struct platform_nand_chip *chip);
-	void *priv;
 };
 
 /* Keep gcc happy */

commit b4dc53e16ff00c0edba3d3219e216475e68951b3
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue May 31 16:31:26 2011 -0700

    mtd: nand: renumber the reorganized flags in nand.h / bbm.h
    
    After several steps of rearrangement and consolidation, it is probably
    worth re-sequencing the numbers on some of our affected flags in nand.h
    and bbm.h.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index c1fca4fd35e7..4a43ffc535c9 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -220,14 +220,14 @@ typedef enum {
 
 /* Non chip related options */
 /* This option skips the bbt scan during initialization. */
-#define NAND_SKIP_BBTSCAN	0x00020000
+#define NAND_SKIP_BBTSCAN	0x00010000
 /*
  * This option is defined if the board driver allocates its own buffers
  * (e.g. because it needs them DMA-coherent).
  */
-#define NAND_OWN_BUFFERS	0x00040000
+#define NAND_OWN_BUFFERS	0x00020000
 /* Chip may not exist, so silence any errors in scan */
-#define NAND_SCAN_SILENT_NODEV	0x00080000
+#define NAND_SCAN_SILENT_NODEV	0x00040000
 
 /* Options set by nand scan */
 /* Nand scan has allocated controller struct */

commit b8f80684054ec8a3bcdf35dc9c76ddf629a36482
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue May 31 16:31:24 2011 -0700

    mtd: nand: move NAND_CREATE_EMPTY_BBT flag
    
    The NAND_CREATE_EMPTY_BBT flag was added by commit:
      453281a973c10bce941b240d1c654d536623b16b
      mtd: nand: introduce NAND_CREATE_EMPTY_BBT
    This flag is not used within the kernel and not explained well, so I
    took the liberty to edit its comments.
    
    Also, this is a BBT-related flag (and closely tied with NAND_BBT_CREATE)
    so I'm moving it to bbm.h next to NAND_BBT_CREATE, thus requiring that
    we use the flag in nand_chip.bbt_options, *not* in nand_chip.options.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 8a086d2cacf4..c1fca4fd35e7 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -228,8 +228,6 @@ typedef enum {
 #define NAND_OWN_BUFFERS	0x00040000
 /* Chip may not exist, so silence any errors in scan */
 #define NAND_SCAN_SILENT_NODEV	0x00080000
-/* Create an empty BBT with no vendor information if the BBT is available */
-#define NAND_CREATE_EMPTY_BBT		0x01000000
 
 /* Options set by nand scan */
 /* Nand scan has allocated controller struct */

commit a40f73419f02e40555f692785ea1c1813d5b4c12
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue May 31 16:31:22 2011 -0700

    mtd: nand: consolidate redundant flash-based BBT flags
    
    This patch works with the following three flags from two headers (nand.h
    and bbm.h):
      (1) NAND_USE_FLASH_BBT (nand.h)
      (2) NAND_USE_FLASH_BBT_NO_OOB (nand.h)
      (3) NAND_BBT_NO_OOB (bbm.h)
    
    These flags are all related and interdependent, yet they were in
    different headers. Flag (2) is simply the combination of (1) and (3) and
    can be eliminated.
    
    This patch accomplishes the following:
      * eliminate NAND_USE_FLASH_BBT_NO_OOB (i.e., flag (2))
      * move NAND_USE_FLASH_BBT (i.e., flag (1)) to bbm.h
    
    It's important to note that because (1) and (3) are now both found in
    bbm.h, they should NOT be used in the "nand_chip.options" field.
    
    I removed a small section from the mtdnand DocBook because it referes to
    NAND_USE_FLASH_BBT in nand.h, which has been moved to bbm.h.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 42f70e2d33af..8a086d2cacf4 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -219,11 +219,6 @@ typedef enum {
 #define NAND_CHIPOPTIONS_MSK	(0x0000ffff & ~NAND_NO_AUTOINCR)
 
 /* Non chip related options */
-/*
- * Use a flash based bad block table. OOB identifier is saved in OOB area.
- * This option is passed to the default bad block table function.
- */
-#define NAND_USE_FLASH_BBT	0x00010000
 /* This option skips the bbt scan during initialization. */
 #define NAND_SKIP_BBTSCAN	0x00020000
 /*
@@ -233,11 +228,6 @@ typedef enum {
 #define NAND_OWN_BUFFERS	0x00040000
 /* Chip may not exist, so silence any errors in scan */
 #define NAND_SCAN_SILENT_NODEV	0x00080000
-/*
- * If passed additionally to NAND_USE_FLASH_BBT then BBT code will not touch
- * the OOB area.
- */
-#define NAND_USE_FLASH_BBT_NO_OOB	0x00800000
 /* Create an empty BBT with no vendor information if the BBT is available */
 #define NAND_CREATE_EMPTY_BBT		0x01000000
 
@@ -615,6 +605,7 @@ extern int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
  * @partitions:		mtd partition list
  * @chip_delay:		R/B delay value in us
  * @options:		Option flags, e.g. 16bit buswidth
+ * @bbt_options:	BBT option flags, e.g. NAND_BBT_USE_FLASH
  * @ecclayout:		ecc layout info structure
  * @part_probe_types:	NULL-terminated array of probe types
  * @set_parts:		platform specific function to set partitions
@@ -628,6 +619,7 @@ struct platform_nand_chip {
 	struct nand_ecclayout *ecclayout;
 	int chip_delay;
 	unsigned int options;
+	unsigned int bbt_options;
 	const char **part_probe_types;
 	void (*set_parts)(uint64_t size, struct platform_nand_chip *chip);
 	void *priv;

commit 5fb1549dfc40f3b589dae560ea21535cdc5f64e0
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue May 31 16:31:21 2011 -0700

    mtd: nand: separate chip options / bbt_options
    
    This patch handles the problems we've been having with using conflicting
    flags from nand.h and bbm.h in the same nand_chip.options field. We
    should try to separate these two spaces a little more clearly, and so I
    have added a bbt_options field to nand_chip.
    
    Important notes about nand_chip fields:
    * bbt_options field should contain ONLY flags from bbm.h. They should be
      able to pass safely to a nand_bbt_descr data structure.
        - BBT option flags start with the "NAND_BBT_" prefix.
    * options field should contian ONLY flags from nand.h. Ideally, they
      should not be involved in any BBT related options.
        - NAND chip option flags start with the "NAND_" prefix.
    * Every flag should have a nice comment explaining what the flag is. While
      this is not yet the case on all existing flags, please be sure to write
      one for new flags. Even better, you can help document the code better
      yourself!
    
    Please try to follow these conventions to make everyone's lives easier.
    
    Among the flags that are being moved to the new bbt_options field
    throughout various drivers, etc. are:
     * NAND_BBT_SCANLASTPAGE
     * NAND_BBT_SCAN2NDPAGE
    and there will be more to come.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index c2b9ac4fbc4a..42f70e2d33af 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -449,6 +449,9 @@ struct nand_buffers {
  * @options:		[BOARDSPECIFIC] various chip options. They can partly
  *			be set to inform nand_scan about special functionality.
  *			See the defines for further explanation.
+ * @bbt_options:	[INTERN] bad block specific options. All options used
+ *			here must come from bbm.h. By default, these options
+ *			will be copied to the appropriate nand_bbt_descr's.
  * @badblockpos:	[INTERN] position of the bad block marker in the oob
  *			area.
  * @badblockbits:	[INTERN] number of bits to left-shift the bad block
@@ -509,6 +512,7 @@ struct nand_chip {
 
 	int chip_delay;
 	unsigned int options;
+	unsigned int bbt_options;
 
 	int page_shift;
 	int phys_erase_shift;

commit a626743f579aa743473fd8b9215ca198bacf2ac4
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Mar 18 21:53:41 2011 -0700

    mtd: nand: renumber conflicting BBT flags
    
    The NAND_USE_FLASH_BBT_NO_OOB and NAND_CREATE_EMPTY_BBT flags conflict
    with the NAND_BBT_SCANBYTE1AND6 and NAND_BBT_DYNAMICSTRUCT flags,
    respectively. This change will allow us to utilize these options
    independently.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index d44192740f6f..c2b9ac4fbc4a 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -237,9 +237,9 @@ typedef enum {
  * If passed additionally to NAND_USE_FLASH_BBT then BBT code will not touch
  * the OOB area.
  */
-#define NAND_USE_FLASH_BBT_NO_OOB	0x00100000
+#define NAND_USE_FLASH_BBT_NO_OOB	0x00800000
 /* Create an empty BBT with no vendor information if the BBT is available */
-#define NAND_CREATE_EMPTY_BBT		0x00200000
+#define NAND_CREATE_EMPTY_BBT		0x01000000
 
 /* Options set by nand scan */
 /* Nand scan has allocated controller struct */

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index ae67ef56a8f5..d44192740f6f 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -416,9 +416,9 @@ struct nand_buffers {
  * @select_chip:	[REPLACEABLE] select chip nr
  * @block_bad:		[REPLACEABLE] check, if the block is bad
  * @block_markbad:	[REPLACEABLE] mark the block bad
- * @cmd_ctrl:		[BOARDSPECIFIC] hardwarespecific funtion for controlling
+ * @cmd_ctrl:		[BOARDSPECIFIC] hardwarespecific function for controlling
  *			ALE/CLE/nCE. Also used to write command and address
- * @init_size:		[BOARDSPECIFIC] hardwarespecific funtion for setting
+ * @init_size:		[BOARDSPECIFIC] hardwarespecific function for setting
  *			mtd->oobsize, mtd->writesize and so on.
  *			@id_data contains the 8 bytes values of NAND_CMD_READID.
  *			Return with the bus width.
@@ -437,7 +437,7 @@ struct nand_buffers {
  * @erase_cmd:		[INTERN] erase command write function, selectable due
  *			to AND support.
  * @scan_bbt:		[REPLACEABLE] function to scan bad block table
- * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transfering
+ * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transferring
  *			data from array to read regs (tR).
  * @state:		[INTERN] the current state of the NAND device
  * @oob_poi:		poison value buffer

commit 193bd40026443835e1b96c79d5efe559d01509ae
Author: Ivan Djelic <ivan.djelic@parrot.com>
Date:   Fri Mar 11 11:05:33 2011 +0100

    mtd: nand: add software BCH ECC support
    
    This patch adds software BCH ECC support to mtd, in order to handle recent
    NAND device ecc requirements (4 bits or more).
    
    It does so by adding a new ecc mode (NAND_ECC_SOFT_BCH) for use by board
    drivers, and a new Kconfig option to enable BCH support. It relies on the
    generic BCH library introduced in a previous patch.
    
    When a board driver uses mode NAND_ECC_SOFT_BCH, it should also set fields
    chip->ecc.size and chip->ecc.bytes to select BCH ecc data size and required
    error correction capability. See nand_bch_init() documentation for details.
    
    It has been tested on the following platforms using mtd-utils, UBI and
    UBIFS: x86 (with nandsim), arm926ejs.
    
    Signed-off-by: Ivan Djelic <ivan.djelic@parrot.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 1f489b247a29..ae67ef56a8f5 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -140,6 +140,7 @@ typedef enum {
 	NAND_ECC_HW,
 	NAND_ECC_HW_SYNDROME,
 	NAND_ECC_HW_OOB_FIRST,
+	NAND_ECC_SOFT_BCH,
 } nand_ecc_modes_t;
 
 /*
@@ -339,6 +340,7 @@ struct nand_hw_control {
  * @prepad:	padding information for syndrome based ecc generators
  * @postpad:	padding information for syndrome based ecc generators
  * @layout:	ECC layout control struct pointer
+ * @priv:	pointer to private ecc control data
  * @hwctl:	function to control hardware ecc generator. Must only
  *		be provided if an hardware ECC is available
  * @calculate:	function for ecc calculation or readback from ecc hardware
@@ -362,6 +364,7 @@ struct nand_ecc_ctrl {
 	int prepad;
 	int postpad;
 	struct nand_ecclayout	*layout;
+	void *priv;
 	void (*hwctl)(struct mtd_info *mtd, int mode);
 	int (*calculate)(struct mtd_info *mtd, const uint8_t *dat,
 			uint8_t *ecc_code);

commit 1534b8b09757190ce6e97fa97f9ad77c49082cd8
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Thu Nov 18 15:02:21 2010 -0800

    mtd: fix nand kernel-doc warnings
    
    Warning(include/linux/mtd/nand.h:543): No description found for parameter 'badblockbits'
    Warning(drivers/mtd/nand/nand_bbt.c:1101): No description found for parameter 'mtd'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Cc:     David Woodhouse <dwmw2@infradead.org>
    Cc:     linux-mtd@lists.infradead.org
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 63e17d01fde9..1f489b247a29 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -448,6 +448,8 @@ struct nand_buffers {
  *			See the defines for further explanation.
  * @badblockpos:	[INTERN] position of the bad block marker in the oob
  *			area.
+ * @badblockbits:	[INTERN] number of bits to left-shift the bad block
+ *			number
  * @cellinfo:		[INTERN] MLC/multichip data from chip ident
  * @numchips:		[INTERN] number of physical chips
  * @chipsize:		[INTERN] the size of one chip for multichip arrays

commit b46daf7eb1a143169699a8f9df634aa751a6ddde
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Oct 7 21:48:27 2010 +0200

    mtd: remove junk tabs in nand.h
    
    Remove tabs between type and name.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index acd0b500f55a..63e17d01fde9 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -253,61 +253,62 @@ struct nand_chip;
 
 struct nand_onfi_params {
 	/* rev info and features block */
-	u8		sig[4]; /* 'O' 'N' 'F' 'I'  */
-	__le16		revision;
-	__le16		features;
-	__le16		opt_cmd;
-	u8		reserved[22];
+	/* 'O' 'N' 'F' 'I'  */
+	u8 sig[4];
+	__le16 revision;
+	__le16 features;
+	__le16 opt_cmd;
+	u8 reserved[22];
 
 	/* manufacturer information block */
-	char		manufacturer[12];
-	char		model[20];
-	u8		jedec_id;
-	__le16		date_code;
-	u8		reserved2[13];
+	char manufacturer[12];
+	char model[20];
+	u8 jedec_id;
+	__le16 date_code;
+	u8 reserved2[13];
 
 	/* memory organization block */
-	__le32		byte_per_page;
-	__le16		spare_bytes_per_page;
-	__le32		data_bytes_per_ppage;
-	__le16		spare_bytes_per_ppage;
-	__le32		pages_per_block;
-	__le32		blocks_per_lun;
-	u8		lun_count;
-	u8		addr_cycles;
-	u8		bits_per_cell;
-	__le16		bb_per_lun;
-	__le16		block_endurance;
-	u8		guaranteed_good_blocks;
-	__le16		guaranteed_block_endurance;
-	u8		programs_per_page;
-	u8		ppage_attr;
-	u8		ecc_bits;
-	u8		interleaved_bits;
-	u8		interleaved_ops;
-	u8		reserved3[13];
+	__le32 byte_per_page;
+	__le16 spare_bytes_per_page;
+	__le32 data_bytes_per_ppage;
+	__le16 spare_bytes_per_ppage;
+	__le32 pages_per_block;
+	__le32 blocks_per_lun;
+	u8 lun_count;
+	u8 addr_cycles;
+	u8 bits_per_cell;
+	__le16 bb_per_lun;
+	__le16 block_endurance;
+	u8 guaranteed_good_blocks;
+	__le16 guaranteed_block_endurance;
+	u8 programs_per_page;
+	u8 ppage_attr;
+	u8 ecc_bits;
+	u8 interleaved_bits;
+	u8 interleaved_ops;
+	u8 reserved3[13];
 
 	/* electrical parameter block */
-	u8		io_pin_capacitance_max;
-	__le16		async_timing_mode;
-	__le16		program_cache_timing_mode;
-	__le16		t_prog;
-	__le16		t_bers;
-	__le16		t_r;
-	__le16		t_ccs;
-	__le16		src_sync_timing_mode;
-	__le16		src_ssync_features;
-	__le16		clk_pin_capacitance_typ;
-	__le16		io_pin_capacitance_typ;
-	__le16		input_pin_capacitance_typ;
-	u8		input_pin_capacitance_max;
-	u8		driver_strenght_support;
-	__le16		t_int_r;
-	__le16		t_ald;
-	u8		reserved4[7];
+	u8 io_pin_capacitance_max;
+	__le16 async_timing_mode;
+	__le16 program_cache_timing_mode;
+	__le16 t_prog;
+	__le16 t_bers;
+	__le16 t_r;
+	__le16 t_ccs;
+	__le16 src_sync_timing_mode;
+	__le16 src_ssync_features;
+	__le16 clk_pin_capacitance_typ;
+	__le16 io_pin_capacitance_typ;
+	__le16 input_pin_capacitance_typ;
+	u8 input_pin_capacitance_max;
+	u8 driver_strenght_support;
+	__le16 t_int_r;
+	__le16 t_ald;
+	u8 reserved4[7];
 
 	/* vendor */
-	u8		reserved5[90];
+	u8 reserved5[90];
 
 	__le16 crc;
 } __attribute__((packed));
@@ -323,7 +324,7 @@ struct nand_onfi_params {
  *			when a hw controller is available.
  */
 struct nand_hw_control {
-	spinlock_t	 lock;
+	spinlock_t lock;
 	struct nand_chip *active;
 	wait_queue_head_t wq;
 };
@@ -353,44 +354,33 @@ struct nand_hw_control {
  * @write_oob:	function to write chip OOB data
  */
 struct nand_ecc_ctrl {
-	nand_ecc_modes_t	mode;
-	int			steps;
-	int			size;
-	int			bytes;
-	int			total;
-	int			prepad;
-	int			postpad;
+	nand_ecc_modes_t mode;
+	int steps;
+	int size;
+	int bytes;
+	int total;
+	int prepad;
+	int postpad;
 	struct nand_ecclayout	*layout;
-	void			(*hwctl)(struct mtd_info *mtd, int mode);
-	int			(*calculate)(struct mtd_info *mtd,
-					     const uint8_t *dat,
-					     uint8_t *ecc_code);
-	int			(*correct)(struct mtd_info *mtd, uint8_t *dat,
-					   uint8_t *read_ecc,
-					   uint8_t *calc_ecc);
-	int			(*read_page_raw)(struct mtd_info *mtd,
-						 struct nand_chip *chip,
-						 uint8_t *buf, int page);
-	void			(*write_page_raw)(struct mtd_info *mtd,
-						  struct nand_chip *chip,
-						  const uint8_t *buf);
-	int			(*read_page)(struct mtd_info *mtd,
-					     struct nand_chip *chip,
-					     uint8_t *buf, int page);
-	int			(*read_subpage)(struct mtd_info *mtd,
-					     struct nand_chip *chip,
-					     uint32_t offs, uint32_t len,
-					     uint8_t *buf);
-	void			(*write_page)(struct mtd_info *mtd,
-					      struct nand_chip *chip,
-					      const uint8_t *buf);
-	int			(*read_oob)(struct mtd_info *mtd,
-					    struct nand_chip *chip,
-					    int page,
-					    int sndcmd);
-	int			(*write_oob)(struct mtd_info *mtd,
-					     struct nand_chip *chip,
-					     int page);
+	void (*hwctl)(struct mtd_info *mtd, int mode);
+	int (*calculate)(struct mtd_info *mtd, const uint8_t *dat,
+			uint8_t *ecc_code);
+	int (*correct)(struct mtd_info *mtd, uint8_t *dat, uint8_t *read_ecc,
+			uint8_t *calc_ecc);
+	int (*read_page_raw)(struct mtd_info *mtd, struct nand_chip *chip,
+			uint8_t *buf, int page);
+	void (*write_page_raw)(struct mtd_info *mtd, struct nand_chip *chip,
+			const uint8_t *buf);
+	int (*read_page)(struct mtd_info *mtd, struct nand_chip *chip,
+			uint8_t *buf, int page);
+	int (*read_subpage)(struct mtd_info *mtd, struct nand_chip *chip,
+			uint32_t offs, uint32_t len, uint8_t *buf);
+	void (*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
+			const uint8_t *buf);
+	int (*read_oob)(struct mtd_info *mtd, struct nand_chip *chip, int page,
+			int sndcmd);
+	int (*write_oob)(struct mtd_info *mtd, struct nand_chip *chip,
+			int page);
 };
 
 /**
@@ -487,62 +477,55 @@ struct nand_buffers {
  */
 
 struct nand_chip {
-	void  __iomem	*IO_ADDR_R;
-	void  __iomem	*IO_ADDR_W;
-
-	uint8_t		(*read_byte)(struct mtd_info *mtd);
-	u16		(*read_word)(struct mtd_info *mtd);
-	void		(*write_buf)(struct mtd_info *mtd, const uint8_t *buf,
-			int len);
-	void		(*read_buf)(struct mtd_info *mtd, uint8_t *buf,
-			int len);
-	int		(*verify_buf)(struct mtd_info *mtd, const uint8_t *buf,
-			int len);
-	void		(*select_chip)(struct mtd_info *mtd, int chip);
-	int		(*block_bad)(struct mtd_info *mtd, loff_t ofs,
-			int getchip);
-	int		(*block_markbad)(struct mtd_info *mtd, loff_t ofs);
-	void		(*cmd_ctrl)(struct mtd_info *mtd, int dat,
-				    unsigned int ctrl);
-	int		(*init_size)(struct mtd_info *mtd,
-					struct nand_chip *this, u8 *id_data);
-	int		(*dev_ready)(struct mtd_info *mtd);
-	void		(*cmdfunc)(struct mtd_info *mtd, unsigned command,
-			int column, int page_addr);
-	int		(*waitfunc)(struct mtd_info *mtd,
-			struct nand_chip *this);
-	void		(*erase_cmd)(struct mtd_info *mtd, int page);
-	int		(*scan_bbt)(struct mtd_info *mtd);
-	int		(*errstat)(struct mtd_info *mtd, struct nand_chip *this,
-			int state, int status, int page);
-	int		(*write_page)(struct mtd_info *mtd,
-			struct nand_chip *chip, const uint8_t *buf, int page,
-			int cached, int raw);
-
-	int		chip_delay;
-	unsigned int	options;
-
-	int		page_shift;
-	int		phys_erase_shift;
-	int		bbt_erase_shift;
-	int		chip_shift;
-	int		numchips;
-	uint64_t	chipsize;
-	int		pagemask;
-	int		pagebuf;
-	int		subpagesize;
-	uint8_t		cellinfo;
-	int		badblockpos;
-	int		badblockbits;
-
-	int		onfi_version;
+	void __iomem *IO_ADDR_R;
+	void __iomem *IO_ADDR_W;
+
+	uint8_t (*read_byte)(struct mtd_info *mtd);
+	u16 (*read_word)(struct mtd_info *mtd);
+	void (*write_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
+	void (*read_buf)(struct mtd_info *mtd, uint8_t *buf, int len);
+	int (*verify_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
+	void (*select_chip)(struct mtd_info *mtd, int chip);
+	int (*block_bad)(struct mtd_info *mtd, loff_t ofs, int getchip);
+	int (*block_markbad)(struct mtd_info *mtd, loff_t ofs);
+	void (*cmd_ctrl)(struct mtd_info *mtd, int dat, unsigned int ctrl);
+	int (*init_size)(struct mtd_info *mtd, struct nand_chip *this,
+			u8 *id_data);
+	int (*dev_ready)(struct mtd_info *mtd);
+	void (*cmdfunc)(struct mtd_info *mtd, unsigned command, int column,
+			int page_addr);
+	int(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this);
+	void (*erase_cmd)(struct mtd_info *mtd, int page);
+	int (*scan_bbt)(struct mtd_info *mtd);
+	int (*errstat)(struct mtd_info *mtd, struct nand_chip *this, int state,
+			int status, int page);
+	int (*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
+			const uint8_t *buf, int page, int cached, int raw);
+
+	int chip_delay;
+	unsigned int options;
+
+	int page_shift;
+	int phys_erase_shift;
+	int bbt_erase_shift;
+	int chip_shift;
+	int numchips;
+	uint64_t chipsize;
+	int pagemask;
+	int pagebuf;
+	int subpagesize;
+	uint8_t cellinfo;
+	int badblockpos;
+	int badblockbits;
+
+	int onfi_version;
 	struct nand_onfi_params	onfi_params;
 
-	flstate_t	state;
+	flstate_t state;
 
-	uint8_t		*oob_poi;
-	struct nand_hw_control  *controller;
-	struct nand_ecclayout	*ecclayout;
+	uint8_t *oob_poi;
+	struct nand_hw_control *controller;
+	struct nand_ecclayout *ecclayout;
 
 	struct nand_ecc_ctrl ecc;
 	struct nand_buffers *buffers;
@@ -550,13 +533,13 @@ struct nand_chip {
 
 	struct mtd_oob_ops ops;
 
-	uint8_t		*bbt;
-	struct nand_bbt_descr	*bbt_td;
-	struct nand_bbt_descr	*bbt_md;
+	uint8_t *bbt;
+	struct nand_bbt_descr *bbt_td;
+	struct nand_bbt_descr *bbt_md;
 
-	struct nand_bbt_descr	*badblock_pattern;
+	struct nand_bbt_descr *badblock_pattern;
 
-	void		*priv;
+	void *priv;
 };
 
 /*
@@ -629,17 +612,16 @@ extern int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
  * @priv:		hardware controller specific settings
  */
 struct platform_nand_chip {
-	int			nr_chips;
-	int			chip_offset;
-	int			nr_partitions;
-	struct mtd_partition	*partitions;
-	struct nand_ecclayout	*ecclayout;
-	int			chip_delay;
-	unsigned int		options;
-	const char		**part_probe_types;
-	void			(*set_parts)(uint64_t size,
-					struct platform_nand_chip *chip);
-	void			*priv;
+	int nr_chips;
+	int chip_offset;
+	int nr_partitions;
+	struct mtd_partition *partitions;
+	struct nand_ecclayout *ecclayout;
+	int chip_delay;
+	unsigned int options;
+	const char **part_probe_types;
+	void (*set_parts)(uint64_t size, struct platform_nand_chip *chip);
+	void *priv;
 };
 
 /* Keep gcc happy */
@@ -661,18 +643,15 @@ struct platform_device;
  * All fields are optional and depend on the hardware driver requirements
  */
 struct platform_nand_ctrl {
-	int		(*probe)(struct platform_device *pdev);
-	void		(*remove)(struct platform_device *pdev);
-	void		(*hwcontrol)(struct mtd_info *mtd, int cmd);
-	int		(*dev_ready)(struct mtd_info *mtd);
-	void		(*select_chip)(struct mtd_info *mtd, int chip);
-	void		(*cmd_ctrl)(struct mtd_info *mtd, int dat,
-				    unsigned int ctrl);
-	void		(*write_buf)(struct mtd_info *mtd,
-				    const uint8_t *buf, int len);
-	void		(*read_buf)(struct mtd_info *mtd,
-				    uint8_t *buf, int len);
-	void		*priv;
+	int (*probe)(struct platform_device *pdev);
+	void (*remove)(struct platform_device *pdev);
+	void (*hwcontrol)(struct mtd_info *mtd, int cmd);
+	int (*dev_ready)(struct mtd_info *mtd);
+	void (*select_chip)(struct mtd_info *mtd, int chip);
+	void (*cmd_ctrl)(struct mtd_info *mtd, int dat, unsigned int ctrl);
+	void (*write_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
+	void (*read_buf)(struct mtd_info *mtd, uint8_t *buf, int len);
+	void *priv;
 };
 
 /**
@@ -681,8 +660,8 @@ struct platform_nand_ctrl {
  * @ctrl:		controller level device structure
  */
 struct platform_nand_data {
-	struct platform_nand_chip	chip;
-	struct platform_nand_ctrl	ctrl;
+	struct platform_nand_chip chip;
+	struct platform_nand_ctrl ctrl;
 };
 
 /* Some helpers to access the data structures */

commit a0491fc4d4b584ddc23f412e9a57b05d66a21263
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Tue Oct 5 12:41:01 2010 +0200

    mtd: cleanup nand.h
    
    - *var instead of * var
    - proper multiline comment
    - func(args) instead of func (args)
    - 80 lines
    
    So from
    |total: 2 errors, 37 warnings, 654 lines checked
    we got to one warning.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 023866572fb1..acd0b500f55a 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -27,15 +27,17 @@
 struct mtd_info;
 struct nand_flash_dev;
 /* Scan and identify a NAND device */
-extern int nand_scan (struct mtd_info *mtd, int max_chips);
-/* Separate phases of nand_scan(), allowing board driver to intervene
- * and override command or ECC setup according to flash type */
+extern int nand_scan(struct mtd_info *mtd, int max_chips);
+/*
+ * Separate phases of nand_scan(), allowing board driver to intervene
+ * and override command or ECC setup according to flash type.
+ */
 extern int nand_scan_ident(struct mtd_info *mtd, int max_chips,
 			   struct nand_flash_dev *table);
 extern int nand_scan_tail(struct mtd_info *mtd);
 
 /* Free resources held by the NAND device */
-extern void nand_release (struct mtd_info *mtd);
+extern void nand_release(struct mtd_info *mtd);
 
 /* Internal helper for board drivers which need to override command function */
 extern void nand_wait_ready(struct mtd_info *mtd);
@@ -49,7 +51,8 @@ extern int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
 /* The maximum number of NAND chips in an array */
 #define NAND_MAX_CHIPS		8
 
-/* This constant declares the max. oobsize / page, which
+/*
+ * This constant declares the max. oobsize / page, which
  * is supported now. If you add a chip with bigger oobsize/page
  * adjust this accordingly.
  */
@@ -153,9 +156,10 @@ typedef enum {
 #define NAND_GET_DEVICE		0x80
 
 
-/* Option constants for bizarre disfunctionality and real
-*  features
-*/
+/*
+ * Option constants for bizarre disfunctionality and real
+ * features.
+ */
 /* Chip can not auto increment pages */
 #define NAND_NO_AUTOINCR	0x00000001
 /* Buswitdh is 16 bit */
@@ -166,19 +170,27 @@ typedef enum {
 #define NAND_CACHEPRG		0x00000008
 /* Chip has copy back function */
 #define NAND_COPYBACK		0x00000010
-/* AND Chip which has 4 banks and a confusing page / block
- * assignment. See Renesas datasheet for further information */
+/*
+ * AND Chip which has 4 banks and a confusing page / block
+ * assignment. See Renesas datasheet for further information.
+ */
 #define NAND_IS_AND		0x00000020
-/* Chip has a array of 4 pages which can be read without
- * additional ready /busy waits */
+/*
+ * Chip has a array of 4 pages which can be read without
+ * additional ready /busy waits.
+ */
 #define NAND_4PAGE_ARRAY	0x00000040
-/* Chip requires that BBT is periodically rewritten to prevent
+/*
+ * Chip requires that BBT is periodically rewritten to prevent
  * bits from adjacent blocks from 'leaking' in altering data.
- * This happens with the Renesas AG-AND chips, possibly others.  */
+ * This happens with the Renesas AG-AND chips, possibly others.
+ */
 #define BBT_AUTO_REFRESH	0x00000080
-/* Chip does not require ready check on read. True
+/*
+ * Chip does not require ready check on read. True
  * for all large page devices, as they do not support
- * autoincrement.*/
+ * autoincrement.
+ */
 #define NAND_NO_READRDY		0x00000100
 /* Chip does not allow subpage writes */
 #define NAND_NO_SUBPAGE_WRITE	0x00000200
@@ -213,8 +225,10 @@ typedef enum {
 #define NAND_USE_FLASH_BBT	0x00010000
 /* This option skips the bbt scan during initialization. */
 #define NAND_SKIP_BBTSCAN	0x00020000
-/* This option is defined if the board driver allocates its own buffers
-   (e.g. because it needs them DMA-coherent */
+/*
+ * This option is defined if the board driver allocates its own buffers
+ * (e.g. because it needs them DMA-coherent).
+ */
 #define NAND_OWN_BUFFERS	0x00040000
 /* Chip may not exist, so silence any errors in scan */
 #define NAND_SCAN_SILENT_NODEV	0x00080000
@@ -304,8 +318,9 @@ struct nand_onfi_params {
  * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independent devices
  * @lock:               protection lock
  * @active:		the mtd device which holds the controller currently
- * @wq:			wait queue to sleep on if a NAND operation is in progress
- *                      used instead of the per chip wait queue when a hw controller is available
+ * @wq:			wait queue to sleep on if a NAND operation is in
+ *			progress used instead of the per chip wait queue
+ *			when a hw controller is available.
  */
 struct nand_hw_control {
 	spinlock_t	 lock;
@@ -329,9 +344,11 @@ struct nand_hw_control {
  * @correct:	function for ecc correction, matching to ecc generator (sw/hw)
  * @read_page_raw:	function to read a raw page without ECC
  * @write_page_raw:	function to write a raw page without ECC
- * @read_page:	function to read a page according to the ecc generator requirements
+ * @read_page:	function to read a page according to the ecc generator
+ *		requirements.
  * @read_subpage:	function to read parts of the page covered by ECC.
- * @write_page:	function to write a page according to the ecc generator requirements
+ * @write_page:	function to write a page according to the ecc generator
+ *		requirements.
  * @read_oob:	function to read chip OOB data
  * @write_oob:	function to write chip OOB data
  */
@@ -393,13 +410,16 @@ struct nand_buffers {
 
 /**
  * struct nand_chip - NAND Private Flash Chip Data
- * @IO_ADDR_R:		[BOARDSPECIFIC] address to read the 8 I/O lines of the flash device
- * @IO_ADDR_W:		[BOARDSPECIFIC] address to write the 8 I/O lines of the flash device
+ * @IO_ADDR_R:		[BOARDSPECIFIC] address to read the 8 I/O lines of the
+ *			flash device
+ * @IO_ADDR_W:		[BOARDSPECIFIC] address to write the 8 I/O lines of the
+ *			flash device.
  * @read_byte:		[REPLACEABLE] read one byte from the chip
  * @read_word:		[REPLACEABLE] read one word from the chip
  * @write_buf:		[REPLACEABLE] write data from the buffer to the chip
  * @read_buf:		[REPLACEABLE] read data from the chip into the buffer
- * @verify_buf:		[REPLACEABLE] verify buffer contents against the chip data
+ * @verify_buf:		[REPLACEABLE] verify buffer contents against the chip
+ *			data.
  * @select_chip:	[REPLACEABLE] select chip nr
  * @block_bad:		[REPLACEABLE] check, if the block is bad
  * @block_markbad:	[REPLACEABLE] mark the block bad
@@ -409,45 +429,60 @@ struct nand_buffers {
  *			mtd->oobsize, mtd->writesize and so on.
  *			@id_data contains the 8 bytes values of NAND_CMD_READID.
  *			Return with the bus width.
- * @dev_ready:		[BOARDSPECIFIC] hardwarespecific function for accesing device ready/busy line
- *			If set to NULL no access to ready/busy is available and the ready/busy information
- *			is read from the chip status register
- * @cmdfunc:		[REPLACEABLE] hardwarespecific function for writing commands to the chip
- * @waitfunc:		[REPLACEABLE] hardwarespecific function for wait on ready
+ * @dev_ready:		[BOARDSPECIFIC] hardwarespecific function for accesing
+ *			device ready/busy line. If set to NULL no access to
+ *			ready/busy is available and the ready/busy information
+ *			is read from the chip status register.
+ * @cmdfunc:		[REPLACEABLE] hardwarespecific function for writing
+ *			commands to the chip.
+ * @waitfunc:		[REPLACEABLE] hardwarespecific function for wait on
+ *			ready.
  * @ecc:		[BOARDSPECIFIC] ecc control ctructure
  * @buffers:		buffer structure for read/write
  * @hwcontrol:		platform-specific hardware control structure
  * @ops:		oob operation operands
- * @erase_cmd:		[INTERN] erase command write function, selectable due to AND support
+ * @erase_cmd:		[INTERN] erase command write function, selectable due
+ *			to AND support.
  * @scan_bbt:		[REPLACEABLE] function to scan bad block table
- * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transfering data from array to read regs (tR)
+ * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transfering
+ *			data from array to read regs (tR).
  * @state:		[INTERN] the current state of the NAND device
  * @oob_poi:		poison value buffer
- * @page_shift:		[INTERN] number of address bits in a page (column address bits)
+ * @page_shift:		[INTERN] number of address bits in a page (column
+ *			address bits).
  * @phys_erase_shift:	[INTERN] number of address bits in a physical eraseblock
  * @bbt_erase_shift:	[INTERN] number of address bits in a bbt entry
  * @chip_shift:		[INTERN] number of address bits in one chip
- * @options:		[BOARDSPECIFIC] various chip options. They can partly be set to inform nand_scan about
- *			special functionality. See the defines for further explanation
- * @badblockpos:	[INTERN] position of the bad block marker in the oob area
+ * @options:		[BOARDSPECIFIC] various chip options. They can partly
+ *			be set to inform nand_scan about special functionality.
+ *			See the defines for further explanation.
+ * @badblockpos:	[INTERN] position of the bad block marker in the oob
+ *			area.
  * @cellinfo:		[INTERN] MLC/multichip data from chip ident
  * @numchips:		[INTERN] number of physical chips
  * @chipsize:		[INTERN] the size of one chip for multichip arrays
  * @pagemask:		[INTERN] page number mask = number of (pages / chip) - 1
- * @pagebuf:		[INTERN] holds the pagenumber which is currently in data_buf
+ * @pagebuf:		[INTERN] holds the pagenumber which is currently in
+ *			data_buf.
  * @subpagesize:	[INTERN] holds the subpagesize
- * @onfi_version:	[INTERN] holds the chip ONFI version (BCD encoded), non 0 if ONFI supported
- * @onfi_params:	[INTERN] holds the ONFI page parameter when ONFI is supported, 0 otherwise
+ * @onfi_version:	[INTERN] holds the chip ONFI version (BCD encoded),
+ *			non 0 if ONFI supported.
+ * @onfi_params:	[INTERN] holds the ONFI page parameter when ONFI is
+ *			supported, 0 otherwise.
  * @ecclayout:		[REPLACEABLE] the default ecc placement scheme
  * @bbt:		[INTERN] bad block table pointer
- * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash lookup
+ * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash
+ *			lookup.
  * @bbt_md:		[REPLACEABLE] bad block table mirror descriptor
- * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for initial bad block scan
- * @controller:		[REPLACEABLE] a pointer to a hardware controller structure
- *			which is shared among multiple independend devices
+ * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for initial
+ *			bad block scan.
+ * @controller:		[REPLACEABLE] a pointer to a hardware controller
+ *			structure which is shared among multiple independend
+ *			devices.
  * @priv:		[OPTIONAL] pointer to private chip date
- * @errstat:		[OPTIONAL] hardware specific function to perform additional error status checks
- *			(determine if errors are correctable)
+ * @errstat:		[OPTIONAL] hardware specific function to perform
+ *			additional error status checks (determine if errors are
+ *			correctable).
  * @write_page:		[REPLACEABLE] High-level page write function
  */
 
@@ -457,24 +492,32 @@ struct nand_chip {
 
 	uint8_t		(*read_byte)(struct mtd_info *mtd);
 	u16		(*read_word)(struct mtd_info *mtd);
-	void		(*write_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
-	void		(*read_buf)(struct mtd_info *mtd, uint8_t *buf, int len);
-	int		(*verify_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
+	void		(*write_buf)(struct mtd_info *mtd, const uint8_t *buf,
+			int len);
+	void		(*read_buf)(struct mtd_info *mtd, uint8_t *buf,
+			int len);
+	int		(*verify_buf)(struct mtd_info *mtd, const uint8_t *buf,
+			int len);
 	void		(*select_chip)(struct mtd_info *mtd, int chip);
-	int		(*block_bad)(struct mtd_info *mtd, loff_t ofs, int getchip);
+	int		(*block_bad)(struct mtd_info *mtd, loff_t ofs,
+			int getchip);
 	int		(*block_markbad)(struct mtd_info *mtd, loff_t ofs);
 	void		(*cmd_ctrl)(struct mtd_info *mtd, int dat,
 				    unsigned int ctrl);
 	int		(*init_size)(struct mtd_info *mtd,
 					struct nand_chip *this, u8 *id_data);
 	int		(*dev_ready)(struct mtd_info *mtd);
-	void		(*cmdfunc)(struct mtd_info *mtd, unsigned command, int column, int page_addr);
-	int		(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this);
+	void		(*cmdfunc)(struct mtd_info *mtd, unsigned command,
+			int column, int page_addr);
+	int		(*waitfunc)(struct mtd_info *mtd,
+			struct nand_chip *this);
 	void		(*erase_cmd)(struct mtd_info *mtd, int page);
 	int		(*scan_bbt)(struct mtd_info *mtd);
-	int		(*errstat)(struct mtd_info *mtd, struct nand_chip *this, int state, int status, int page);
-	int		(*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
-				      const uint8_t *buf, int page, int cached, int raw);
+	int		(*errstat)(struct mtd_info *mtd, struct nand_chip *this,
+			int state, int status, int page);
+	int		(*write_page)(struct mtd_info *mtd,
+			struct nand_chip *chip, const uint8_t *buf, int page,
+			int cached, int raw);
 
 	int		chip_delay;
 	unsigned int	options;
@@ -557,7 +600,7 @@ struct nand_flash_dev {
 */
 struct nand_manufacturers {
 	int id;
-	char * name;
+	char *name;
 };
 
 extern struct nand_flash_dev nand_flash_ids[];
@@ -570,7 +613,7 @@ extern int nand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt);
 extern int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
 			   int allowbbt);
 extern int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
-			size_t * retlen, uint8_t * buf);
+			size_t *retlen, uint8_t *buf);
 
 /**
  * struct platform_nand_chip - chip level device structure

commit 453281a973c10bce941b240d1c654d536623b16b
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Fri Oct 1 21:37:37 2010 +0200

    mtd: nand: introduce NAND_CREATE_EMPTY_BBT
    
    it will create an empty BBT table without considering vendor's BBT
    information. Vendor's information may be unavailable if the NAND
    controller has a different DATA & OOB layout or this information may be
    allready purged.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index c0464d41f539..023866572fb1 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -223,6 +223,8 @@ typedef enum {
  * the OOB area.
  */
 #define NAND_USE_FLASH_BBT_NO_OOB	0x00100000
+/* Create an empty BBT with no vendor information if the BBT is available */
+#define NAND_CREATE_EMPTY_BBT		0x00200000
 
 /* Options set by nand scan */
 /* Nand scan has allocated controller struct */

commit 7cba7b14fe179969d7217cca52e28519d7d6ca89
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Sep 30 21:28:01 2010 +0200

    mtd: nand: add support for BBT without OOB
    
    The first (sixt) byte in the OOB area contains vendor's bad block
    information. During identification of the NAND chip this information is
    collected by scanning the complete chip.
    The option NAND_USE_FLASH_BBT is used to store this information in a sector so
    we don't have to scan the complete flash. Unfortunately the code stores
    a marker in order to recognize the BBT in the OOB area. This will fail
    if the OOB area is completely used for ECC.
    This patch introduces the option NAND_USE_FLASH_BBT_NO_OOB which has to be
    used with NAND_USE_FLASH_BBT. It will then store BBT on flash without
    touching the OOB area. The BBT format on flash remains same except the
    first page starts with the recognition pattern followed by the version byte.
    This change was tested in nandsim and it looks good so far :)
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 0f744547a48c..c0464d41f539 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -206,8 +206,10 @@ typedef enum {
 #define NAND_CHIPOPTIONS_MSK	(0x0000ffff & ~NAND_NO_AUTOINCR)
 
 /* Non chip related options */
-/* Use a flash based bad block table. This option is passed to the
- * default bad block table function. */
+/*
+ * Use a flash based bad block table. OOB identifier is saved in OOB area.
+ * This option is passed to the default bad block table function.
+ */
 #define NAND_USE_FLASH_BBT	0x00010000
 /* This option skips the bbt scan during initialization. */
 #define NAND_SKIP_BBTSCAN	0x00020000
@@ -216,6 +218,11 @@ typedef enum {
 #define NAND_OWN_BUFFERS	0x00040000
 /* Chip may not exist, so silence any errors in scan */
 #define NAND_SCAN_SILENT_NODEV	0x00080000
+/*
+ * If passed additionally to NAND_USE_FLASH_BBT then BBT code will not touch
+ * the OOB area.
+ */
+#define NAND_USE_FLASH_BBT_NO_OOB	0x00100000
 
 /* Options set by nand scan */
 /* Nand scan has allocated controller struct */

commit 12a40a57f762f569f58a393437d8c13864db390a
Author: Huang Shijie <shijie8@gmail.com>
Date:   Mon Sep 27 10:43:53 2010 +0800

    mtd: add init_size hook for NAND driver
    
    Not all the NAND devices have all the information in additional
    id bytes.
    
    So add a hook in the nand_chip{} is a good method to calculate the
    right value of oobsize, erasesize and so on.
    
    Without the hook,you will get the wrong value, and you have to hack
    in the ->scan_bbt() to change the wrong value which make the code
    mess.
    
    Signed-off-by: Huang Shijie <shijie8@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 7666c42235c7..0f744547a48c 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -396,6 +396,10 @@ struct nand_buffers {
  * @block_markbad:	[REPLACEABLE] mark the block bad
  * @cmd_ctrl:		[BOARDSPECIFIC] hardwarespecific funtion for controlling
  *			ALE/CLE/nCE. Also used to write command and address
+ * @init_size:		[BOARDSPECIFIC] hardwarespecific funtion for setting
+ *			mtd->oobsize, mtd->writesize and so on.
+ *			@id_data contains the 8 bytes values of NAND_CMD_READID.
+ *			Return with the bus width.
  * @dev_ready:		[BOARDSPECIFIC] hardwarespecific function for accesing device ready/busy line
  *			If set to NULL no access to ready/busy is available and the ready/busy information
  *			is read from the chip status register
@@ -452,6 +456,8 @@ struct nand_chip {
 	int		(*block_markbad)(struct mtd_info *mtd, loff_t ofs);
 	void		(*cmd_ctrl)(struct mtd_info *mtd, int dat,
 				    unsigned int ctrl);
+	int		(*init_size)(struct mtd_info *mtd,
+					struct nand_chip *this, u8 *id_data);
 	int		(*dev_ready)(struct mtd_info *mtd);
 	void		(*cmdfunc)(struct mtd_info *mtd, unsigned command, int column, int page_addr);
 	int		(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this);

commit d1e1f4e42b5df063712ca2926e50c07b95c96b96
Author: Florian Fainelli <florian@openwrt.org>
Date:   Mon Aug 30 18:32:24 2010 +0200

    mtd: nand: add support for reading ONFI parameters from NAND device
    
    This patch adds support for reading NAND device ONFI parameters and use
    the ONFI informations to define its geometry. In case the device supports
    ONFI, the onfi_version field in struct nand_chip contains the version (BCD)
    and the onfi_params structure can be used by drivers to set up timings and
    such. We currently only support ONFI 1.0 parameters.
    
    Signed-off-by: Brian Norris <norris@broadcom.com>
    Signed-off-by: Matthieu Castet <matthieu.castet@parrot.com>
    Signed-off-by: Maxime Bizon <mbizon@freebox.fr>
    Signed-off-by: Florian Fainelli <ffainelli@freebox.fr>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 29656a3f9331..7666c42235c7 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -228,6 +228,69 @@ typedef enum {
 /* Keep gcc happy */
 struct nand_chip;
 
+struct nand_onfi_params {
+	/* rev info and features block */
+	u8		sig[4]; /* 'O' 'N' 'F' 'I'  */
+	__le16		revision;
+	__le16		features;
+	__le16		opt_cmd;
+	u8		reserved[22];
+
+	/* manufacturer information block */
+	char		manufacturer[12];
+	char		model[20];
+	u8		jedec_id;
+	__le16		date_code;
+	u8		reserved2[13];
+
+	/* memory organization block */
+	__le32		byte_per_page;
+	__le16		spare_bytes_per_page;
+	__le32		data_bytes_per_ppage;
+	__le16		spare_bytes_per_ppage;
+	__le32		pages_per_block;
+	__le32		blocks_per_lun;
+	u8		lun_count;
+	u8		addr_cycles;
+	u8		bits_per_cell;
+	__le16		bb_per_lun;
+	__le16		block_endurance;
+	u8		guaranteed_good_blocks;
+	__le16		guaranteed_block_endurance;
+	u8		programs_per_page;
+	u8		ppage_attr;
+	u8		ecc_bits;
+	u8		interleaved_bits;
+	u8		interleaved_ops;
+	u8		reserved3[13];
+
+	/* electrical parameter block */
+	u8		io_pin_capacitance_max;
+	__le16		async_timing_mode;
+	__le16		program_cache_timing_mode;
+	__le16		t_prog;
+	__le16		t_bers;
+	__le16		t_r;
+	__le16		t_ccs;
+	__le16		src_sync_timing_mode;
+	__le16		src_ssync_features;
+	__le16		clk_pin_capacitance_typ;
+	__le16		io_pin_capacitance_typ;
+	__le16		input_pin_capacitance_typ;
+	u8		input_pin_capacitance_max;
+	u8		driver_strenght_support;
+	__le16		t_int_r;
+	__le16		t_ald;
+	u8		reserved4[7];
+
+	/* vendor */
+	u8		reserved5[90];
+
+	__le16 crc;
+} __attribute__((packed));
+
+#define ONFI_CRC_BASE	0x4F4E
+
 /**
  * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independent devices
  * @lock:               protection lock
@@ -360,6 +423,8 @@ struct nand_buffers {
  * @pagemask:		[INTERN] page number mask = number of (pages / chip) - 1
  * @pagebuf:		[INTERN] holds the pagenumber which is currently in data_buf
  * @subpagesize:	[INTERN] holds the subpagesize
+ * @onfi_version:	[INTERN] holds the chip ONFI version (BCD encoded), non 0 if ONFI supported
+ * @onfi_params:	[INTERN] holds the ONFI page parameter when ONFI is supported, 0 otherwise
  * @ecclayout:		[REPLACEABLE] the default ecc placement scheme
  * @bbt:		[INTERN] bad block table pointer
  * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash lookup
@@ -412,6 +477,9 @@ struct nand_chip {
 	int		badblockpos;
 	int		badblockbits;
 
+	int		onfi_version;
+	struct nand_onfi_params	onfi_params;
+
 	flstate_t	state;
 
 	uint8_t		*oob_poi;

commit caa4b6f24c2cae586ed3f371ddde7fc1fc75b322
Author: Florian Fainelli <florian@openwrt.org>
Date:   Mon Aug 30 18:32:14 2010 +0200

    mtd: nand: add NAND_CMD_PARAM (0xec) definition
    
    This command is used to read the device ONFI parameters page.
    
    Signed-off-by: Florian Fainelli <ffainelli@freebox.fr>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index a8921c213df5..29656a3f9331 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -88,6 +88,7 @@ extern int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
 #define NAND_CMD_RNDIN		0x85
 #define NAND_CMD_READID		0x90
 #define NAND_CMD_ERASE2		0xd0
+#define NAND_CMD_PARAM		0xec
 #define NAND_CMD_RESET		0xff
 
 #define NAND_CMD_LOCK		0x2a

commit 5c709ee9f33da4a07d94e3d48b297eb6f003fc61
Author: Brian Norris <norris@broadcom.com>
Date:   Fri Aug 20 12:36:13 2010 -0700

    mtd: nand: Increase NAND_MAX_OOBSIZE
    
    An increase in NAND_MAX_OOBSIZE and NAND_MAX_PAGESIZE is necessary
    in order to support many new chips. Among those:
    
    Toshiba TC58TxG4S2FBAxx  8KB page, 576B OOB
    Micron MT29F64G08CBAAA   8KB page, 448B OOB
    
    Signed-off-by: Brian Norris <norris@broadcom.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 102e12c58cb3..a8921c213df5 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -53,8 +53,8 @@ extern int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
  * is supported now. If you add a chip with bigger oobsize/page
  * adjust this accordingly.
  */
-#define NAND_MAX_OOBSIZE	256
-#define NAND_MAX_PAGESIZE	4096
+#define NAND_MAX_OOBSIZE	576
+#define NAND_MAX_PAGESIZE	8192
 
 /*
  * Constants for hardware specific CLE/ALE/NCE function

commit a1452a3771c4eb85bd779790b040efdc36f4274e
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Sun Aug 8 20:58:20 2010 +0100

    mtd: Update copyright notices
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 50f3aa00a452..102e12c58cb3 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -1,9 +1,9 @@
 /*
  *  linux/include/linux/mtd/nand.h
  *
- *  Copyright (c) 2000 David Woodhouse <dwmw2@infradead.org>
- *                     Steven J. Hill <sjhill@realitydiluted.com>
- *		       Thomas Gleixner <tglx@linutronix.de>
+ *  Copyright © 2000-2010 David Woodhouse <dwmw2@infradead.org>
+ *                        Steven J. Hill <sjhill@realitydiluted.com>
+ *		          Thomas Gleixner <tglx@linutronix.de>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as

commit 30fe8115b55223cb84530ce04c4a20ba9d6dcf0b
Author: Brian Norris <norris@broadcom.com>
Date:   Wed Jun 23 13:36:02 2010 -0700

    mtd: nand: edit macro flag for BBT scan of last page in block
    
    NAND_BB_LAST_PAGE used to be in nand.h, but it pertained to bad block
    management and so belongs next to NAND_BBT_SCAN2NDPAGE in bbm.h. Also,
    its previous flag value (0x00000400) conflicted with NAND_BBT_SCANALLPAGES
    so I changed its value to 0x00008000. All uses of the name were modified to
    provide consistency with other "NAND_BBT_*" flags.
    
    Signed-off-by: Brian Norris <norris@broadcom.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index a81b185e23a7..50f3aa00a452 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -181,8 +181,6 @@ typedef enum {
 #define NAND_NO_READRDY		0x00000100
 /* Chip does not allow subpage writes */
 #define NAND_NO_SUBPAGE_WRITE	0x00000200
-/* Chip stores bad block marker on the last page of the eraseblock */
-#define NAND_BB_LAST_PAGE	0x00000400
 
 /* Device is one of 'new' xD cards that expose fake nand command set */
 #define NAND_BROKEN_XD		0x00000400

commit b60b08b02ca8d9575985ae6711bd656dd67e9039
Author: Kevin Cernekee <cernekee@gmail.com>
Date:   Tue May 4 20:58:10 2010 -0700

    mtd: nand: support alternate BB marker locations on MLC
    
    This is a slightly modified version of a patch submitted last year by
    Reuben Dowle <reuben.dowle@navico.com>.  His original comments follow:
    
    This patch adds support for some MLC NAND flashes that place the BB
    marker in the LAST page of the bad block rather than the FIRST page used
    for SLC NAND and other types of MLC nand.
    
    Lifted from Samsung datasheet for K9LG8G08U0A (1Gbyte MLC NAND):
    "
    Identifying Initial Invalid Block(s)
    All device locations are erased(FFh) except locations where the initial
    invalid block(s) information is written prior to shipping. The initial
    invalid block(s) status is defined by the 1st byte in the spare area.
    Samsung makes sure that the last page of every initial invalid block has
    non-FFh data at the column address of 2,048.
    ...
    "
    
    As far as I can tell, this is the same for all Samsung MLC nand, and in
    fact the samsung bsp for the processor used in our project (s3c6410)
    actually contained a hack similar to this patch but less portable to
    enable use of their NAND parts. I discovered this problem when trying to
    use a Micron NAND which does not used this layout - I wish samsung would
    put their stuff in main-line to avoid this type of problem.
    
    Currently this patch causes all MLC nand with manufacturer codes from
    Samsung and ST(Numonyx) to use this alternative location, since these
    are the manufactures that I know of that use this layout.
    
    Signed-off-by: Kevin Cernekee <cernekee@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 50f3aa00a452..a81b185e23a7 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -181,6 +181,8 @@ typedef enum {
 #define NAND_NO_READRDY		0x00000100
 /* Chip does not allow subpage writes */
 #define NAND_NO_SUBPAGE_WRITE	0x00000200
+/* Chip stores bad block marker on the last page of the eraseblock */
+#define NAND_BB_LAST_PAGE	0x00000400
 
 /* Device is one of 'new' xD cards that expose fake nand command set */
 #define NAND_BROKEN_XD		0x00000400

commit 426c457a3216fac74e3d44dd39729b0689f4c7ab
Author: Kevin Cernekee <cernekee@gmail.com>
Date:   Tue May 4 20:58:03 2010 -0700

    mtd: nand: extend NAND flash detection to new MLC chips
    
    Some of the newer MLC devices have a 6-byte ID sequence in which
    several field definitions differ from older chips in a manner that is
    not backward compatible.  For instance:
    
    Samsung K9GAG08U0M (5-byte sequence): ec d5 14 b6 74
    4th byte, bits 1:0 encode the page size: 0=1KiB, 1=2KiB, 2=4KiB, 3=8KiB
    4th byte, bits 5:4 encode the block size: 0=64KiB, 1=128KiB, ...
    4th byte, bit 6 encodes the OOB size: 0=8B/512B, 1=16B/512B
    
    Samsung K9GAG08U0D (6-byte sequence): ec d5 94 29 34 41
    4th byte, bits 1:0 encode the page size: 0=2KiB, 1=4KiB, 3=8KiB, 4=rsvd
    4th byte, bits 7;5:4 encode the block size: 0=128KiB, 1=256KiB, ...
    4th byte, bits 6;3:2 encode the OOB size: 1=128B/page, 2=218B/page
    
    This patch uses the new 6-byte scheme if the following conditions are
    all true:
    
    1) The ID code wraps around after exactly 6 bytes
    
    2) Manufacturer is Samsung
    
    3) 6th byte is zero
    
    The patch also extends the maximum OOB size from 128B to 256B.
    
    Signed-off-by: Kevin Cernekee <cernekee@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 8bdacb885f90..50f3aa00a452 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -53,7 +53,7 @@ extern int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
  * is supported now. If you add a chip with bigger oobsize/page
  * adjust this accordingly.
  */
-#define NAND_MAX_OOBSIZE	128
+#define NAND_MAX_OOBSIZE	256
 #define NAND_MAX_PAGESIZE	4096
 
 /*

commit 93edbad69b0491d794c2ec86bcc65c69eac676e3
Author: Maxim Levitsky <maximlevitsky@gmail.com>
Date:   Mon Feb 22 20:39:40 2010 +0200

    mtd: Workaround wrong write protect status on some xD cards
    
    Signed-off-by: Maxim Levitsky <maximlevitsky@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index d152bdf9161f..8bdacb885f90 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -182,6 +182,12 @@ typedef enum {
 /* Chip does not allow subpage writes */
 #define NAND_NO_SUBPAGE_WRITE	0x00000200
 
+/* Device is one of 'new' xD cards that expose fake nand command set */
+#define NAND_BROKEN_XD		0x00000400
+
+/* Device behaves just like nand, but is readonly */
+#define NAND_ROM		0x00000800
+
 /* Options valid for Samsung large page devices */
 #define NAND_SAMSUNG_LP_OPTIONS \
 	(NAND_NO_PADDING | NAND_CACHEPRG | NAND_COPYBACK)

commit 5e81e88a4c140586d9212999cea683bcd66a15c6
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Fri Feb 26 18:32:56 2010 +0000

    mtd: nand: Allow caller to pass alternative ID table to nand_scan_ident()
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index f2d4a1ac14b8..d152bdf9161f 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -25,11 +25,13 @@
 #include <linux/mtd/bbm.h>
 
 struct mtd_info;
+struct nand_flash_dev;
 /* Scan and identify a NAND device */
 extern int nand_scan (struct mtd_info *mtd, int max_chips);
 /* Separate phases of nand_scan(), allowing board driver to intervene
  * and override command or ECC setup according to flash type */
-extern int nand_scan_ident(struct mtd_info *mtd, int max_chips);
+extern int nand_scan_ident(struct mtd_info *mtd, int max_chips,
+			   struct nand_flash_dev *table);
 extern int nand_scan_tail(struct mtd_info *mtd);
 
 /* Free resources held by the NAND device */

commit e0b58d0a7005cd4b9c7fa4694a437a2d86719c13
Author: Maxim Levitsky <maximlevitsky@gmail.com>
Date:   Mon Feb 22 20:39:38 2010 +0200

    mtd: nand: add ->badblockbits for minimum number of set bits in bad block byte
    
    This can be used to protect against bitflips in that field, but now mostly
    for smartmedia.
    
    Signed-off-by: Maxim Levitsky <maximlevitsky@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 48bc2c54302c..f2d4a1ac14b8 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -401,6 +401,7 @@ struct nand_chip {
 	int		subpagesize;
 	uint8_t		cellinfo;
 	int		badblockpos;
+	int		badblockbits;
 
 	flstate_t	state;
 

commit 7d70f334ad2bf1b3aaa1f0699c0f442e14bcc9e0
Author: Vimal Singh <vimal.newwork@gmail.com>
Date:   Mon Feb 8 15:50:49 2010 +0530

    mtd: nand: add lock/unlock routines
    
    Add nand lock / unlock routines. At least 'micron' parts
    support this.
    
    Signed-off-by: Vimal Singh <vimalsingh@ti.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index ccab9dfc5217..48bc2c54302c 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -38,6 +38,12 @@ extern void nand_release (struct mtd_info *mtd);
 /* Internal helper for board drivers which need to override command function */
 extern void nand_wait_ready(struct mtd_info *mtd);
 
+/* locks all blockes present in the device */
+extern int nand_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
+
+/* unlocks specified locked blockes */
+extern int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
+
 /* The maximum number of NAND chips in an array */
 #define NAND_MAX_CHIPS		8
 
@@ -82,6 +88,10 @@ extern void nand_wait_ready(struct mtd_info *mtd);
 #define NAND_CMD_ERASE2		0xd0
 #define NAND_CMD_RESET		0xff
 
+#define NAND_CMD_LOCK		0x2a
+#define NAND_CMD_UNLOCK1	0x23
+#define NAND_CMD_UNLOCK2	0x24
+
 /* Extended commands for large page devices */
 #define NAND_CMD_READSTART	0x30
 #define NAND_CMD_RNDOUTSTART	0xE0

commit b1c6e6db5bb7acad82e1c64914c6a9404dae3ee1
Author: Ben Dooks <ben@simtec.co.uk>
Date:   Mon Nov 2 18:12:33 2009 +0000

    mtd: nand: add option to quieten off the no device found messgae
    
    Add NAND_SCAN_SILENT_NODEV to chip->options to the user-worrying messages
    'No NAND device found!!!'. This message often worries users (was three
    exclamation marks really necessary?) and especially in systems such as the
    Simtec Osiris where there may be optional NAND devices which are not
    known until probe time.
    
    Revised version of the original NAND_PROBE_SPECULATIVE patch after comments
    by Artem Bityutskiy about adding a whole new call.
    
    Signed-off-by: Ben Dooks <ben@simtec.co.uk>
    Signed-off-by: Simtec Linux Team <linux@simtec.co.uk>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 2476078a032f..ccab9dfc5217 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -170,7 +170,6 @@ typedef enum {
 /* Chip does not allow subpage writes */
 #define NAND_NO_SUBPAGE_WRITE	0x00000200
 
-
 /* Options valid for Samsung large page devices */
 #define NAND_SAMSUNG_LP_OPTIONS \
 	(NAND_NO_PADDING | NAND_CACHEPRG | NAND_COPYBACK)
@@ -196,6 +195,9 @@ typedef enum {
 /* This option is defined if the board driver allocates its own buffers
    (e.g. because it needs them DMA-coherent */
 #define NAND_OWN_BUFFERS	0x00040000
+/* Chip may not exist, so silence any errors in scan */
+#define NAND_SCAN_SILENT_NODEV	0x00080000
+
 /* Options set by nand scan */
 /* Nand scan has allocated controller struct */
 #define NAND_CONTROLLER_ALLOC	0x80000000

commit 30631cb82d5c6c662d5ec682beaa834c1f9f0987
Author: Alessandro Rubini <rubini@unipv.it>
Date:   Sun Sep 20 23:28:14 2009 +0200

    mtd: unify status enum from three headers
    
    nand.h, onenand.h and flashchip.h defined enumeration types
    for chip status using the same symbolic names. This prevented
    a board file to include more than one of them. In particular,
    no nand and onenand platform devices could live in the same file.
    This patch augments flashchip.h with a few status values in order
    to cover all cases, so nand.h and onenand.h can use flstate_t
    without declaring their own status enum.
    
    Signed-off-by: Alessandro Rubini <rubini@unipv.it>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index d87ada538d17..2476078a032f 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -21,6 +21,7 @@
 #include <linux/wait.h>
 #include <linux/spinlock.h>
 #include <linux/mtd/mtd.h>
+#include <linux/mtd/flashchip.h>
 #include <linux/mtd/bbm.h>
 
 struct mtd_info;
@@ -203,20 +204,6 @@ typedef enum {
 #define NAND_CI_CHIPNR_MSK	0x03
 #define NAND_CI_CELLTYPE_MSK	0x0C
 
-/*
- * nand_state_t - chip states
- * Enumeration for NAND flash chip state
- */
-typedef enum {
-	FL_READY,
-	FL_READING,
-	FL_WRITING,
-	FL_ERASING,
-	FL_SYNCING,
-	FL_CACHEDPRG,
-	FL_PM_SUSPENDED,
-} nand_state_t;
-
 /* Keep gcc happy */
 struct nand_chip;
 
@@ -403,7 +390,7 @@ struct nand_chip {
 	uint8_t		cellinfo;
 	int		badblockpos;
 
-	nand_state_t	state;
+	flstate_t	state;
 
 	uint8_t		*oob_poi;
 	struct nand_hw_control  *controller;

commit c62d81bcfe82526cc3da10cf4fc63faad368bc60
Author: Alessandro Rubini <rubini@unipv.it>
Date:   Sun Sep 20 23:28:04 2009 +0200

    mtd: use bbm.h in nand.h
    
    This consolidates common code in nand.h and bbm.h. The
    comments and data structures were the same, this keeps
    the comment from nand.h as it fits 80 columns, while the one
    in bbm.h did not.
    
    Signed-off-by: Alessandro Rubini <rubini@unipv.it>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 7a232a9bdd62..d87ada538d17 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -21,6 +21,7 @@
 #include <linux/wait.h>
 #include <linux/spinlock.h>
 #include <linux/mtd/mtd.h>
+#include <linux/mtd/bbm.h>
 
 struct mtd_info;
 /* Scan and identify a NAND device */
@@ -470,75 +471,6 @@ struct nand_manufacturers {
 extern struct nand_flash_dev nand_flash_ids[];
 extern struct nand_manufacturers nand_manuf_ids[];
 
-/**
- * struct nand_bbt_descr - bad block table descriptor
- * @options:	options for this descriptor
- * @pages:	the page(s) where we find the bbt, used with option BBT_ABSPAGE
- *		when bbt is searched, then we store the found bbts pages here.
- *		Its an array and supports up to 8 chips now
- * @offs:	offset of the pattern in the oob area of the page
- * @veroffs:	offset of the bbt version counter in the oob are of the page
- * @version:	version read from the bbt page during scan
- * @len:	length of the pattern, if 0 no pattern check is performed
- * @maxblocks:	maximum number of blocks to search for a bbt. This number of
- *		blocks is reserved at the end of the device where the tables are
- *		written.
- * @reserved_block_code: if non-0, this pattern denotes a reserved (rather than
- *              bad) block in the stored bbt
- * @pattern:	pattern to identify bad block table or factory marked good /
- *		bad blocks, can be NULL, if len = 0
- *
- * Descriptor for the bad block table marker and the descriptor for the
- * pattern which identifies good and bad blocks. The assumption is made
- * that the pattern and the version count are always located in the oob area
- * of the first block.
- */
-struct nand_bbt_descr {
-	int	options;
-	int	pages[NAND_MAX_CHIPS];
-	int	offs;
-	int	veroffs;
-	uint8_t	version[NAND_MAX_CHIPS];
-	int	len;
-	int	maxblocks;
-	int	reserved_block_code;
-	uint8_t	*pattern;
-};
-
-/* Options for the bad block table descriptors */
-
-/* The number of bits used per block in the bbt on the device */
-#define NAND_BBT_NRBITS_MSK	0x0000000F
-#define NAND_BBT_1BIT		0x00000001
-#define NAND_BBT_2BIT		0x00000002
-#define NAND_BBT_4BIT		0x00000004
-#define NAND_BBT_8BIT		0x00000008
-/* The bad block table is in the last good block of the device */
-#define	NAND_BBT_LASTBLOCK	0x00000010
-/* The bbt is at the given page, else we must scan for the bbt */
-#define NAND_BBT_ABSPAGE	0x00000020
-/* The bbt is at the given page, else we must scan for the bbt */
-#define NAND_BBT_SEARCH		0x00000040
-/* bbt is stored per chip on multichip devices */
-#define NAND_BBT_PERCHIP	0x00000080
-/* bbt has a version counter at offset veroffs */
-#define NAND_BBT_VERSION	0x00000100
-/* Create a bbt if none axists */
-#define NAND_BBT_CREATE		0x00000200
-/* Search good / bad pattern through all pages of a block */
-#define NAND_BBT_SCANALLPAGES	0x00000400
-/* Scan block empty during good / bad block scan */
-#define NAND_BBT_SCANEMPTY	0x00000800
-/* Write bbt if neccecary */
-#define NAND_BBT_WRITE		0x00001000
-/* Read and write back block contents when writing bbt */
-#define NAND_BBT_SAVECONTENT	0x00002000
-/* Search good / bad pattern on the first and the second page */
-#define NAND_BBT_SCAN2NDPAGE	0x00004000
-
-/* The maximum number of blocks to scan for a bbt */
-#define NAND_BBT_SCAN_MAXBLOCKS	4
-
 extern int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd);
 extern int nand_update_bbt(struct mtd_info *mtd, loff_t offs);
 extern int nand_default_bbt(struct mtd_info *mtd);
@@ -548,12 +480,6 @@ extern int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
 extern int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
 			size_t * retlen, uint8_t * buf);
 
-/*
-* Constants for oob configuration
-*/
-#define NAND_SMALL_BADBLOCK_POS		5
-#define NAND_LARGE_BADBLOCK_POS		0
-
 /**
  * struct platform_nand_chip - chip level device structure
  * @nr_chips:		max. number of chips to scan for

commit 6e0cb135b3f3713b95ea41a11155e83a8c70f5f8
Author: Sneha Narnakaje <nsnehaprabha@ti.com>
Date:   Fri Sep 18 12:51:47 2009 -0700

    mtd: nand: add new ECC mode - ECC_HW_OOB_FIRST
    
    This patch adds the new mode NAND_ECC_HW_OOB_FIRST in the nand code to
    support 4-bit ECC on TI DaVinci devices with large page (up to 2KiB) NAND
    chips.  This ECC mode is similar to NAND_ECC_HW, with the exception of
    read_page API that first reads the OOB area, reads the data in chunks,
    feeds the ECC from OOB area to the ECC hw engine and perform any
    correction on the data as per the ECC status reported by the engine.
    
    "ECC_HW_OOB_FIRST" name suggested by Thomas Gleixner
    
    Reviewed-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Sneha Narnakaje <nsnehaprabha@ti.com>
    Signed-off-by: Sandeep Paulraj <s-paulraj@ti.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 686f3701f2f4..7a232a9bdd62 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -121,6 +121,7 @@ typedef enum {
 	NAND_ECC_SOFT,
 	NAND_ECC_HW,
 	NAND_ECC_HW_SYNDROME,
+	NAND_ECC_HW_OOB_FIRST,
 } nand_ecc_modes_t;
 
 /*

commit 46a8cf2df2232c0051f29716ff8a166ebeb08daf
Author: Sneha Narnakaje <nsnehaprabha@ti.com>
Date:   Fri Sep 18 12:51:46 2009 -0700

    mtd: nand: add "page" parameter to all read_page/read_page_raw APIs
    
    This patch adds a new "page" parameter to all NAND read_page/read_page_raw
    APIs.  The read_page API for the new mode ECC_HW_OOB_FIRST requires the
    page information to send the READOOB command and read the OOB area before
    the data area.
    
    Reviewed-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Sneha Narnakaje <nsnehaprabha@ti.com>
    Signed-off-by: Sandeep Paulraj <s-paulraj@ti.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 4030ebada49e..686f3701f2f4 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -271,13 +271,13 @@ struct nand_ecc_ctrl {
 					   uint8_t *calc_ecc);
 	int			(*read_page_raw)(struct mtd_info *mtd,
 						 struct nand_chip *chip,
-						 uint8_t *buf);
+						 uint8_t *buf, int page);
 	void			(*write_page_raw)(struct mtd_info *mtd,
 						  struct nand_chip *chip,
 						  const uint8_t *buf);
 	int			(*read_page)(struct mtd_info *mtd,
 					     struct nand_chip *chip,
-					     uint8_t *buf);
+					     uint8_t *buf, int page);
 	int			(*read_subpage)(struct mtd_info *mtd,
 					     struct nand_chip *chip,
 					     uint32_t offs, uint32_t len,

commit f36e20c01ad0104688f2eaebdf2213e749929c97
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 12 13:46:59 2009 -0700

    mtd: plat_nand: allow platform to set partitions
    
    Add optional callback to allow platform to initialize partitions.
    
    Static partitions on a nand device could vary depending on the size of the
    device.  This patch allows an optional platform callback to be used to
    setup this partition information at runtime.
    
    Scan order is:
            1) chip.part_probe_types
            2) chip.set_parts
            3) chip.partitions
            4) full mtd device (fallback for no partitions)
    
    Some of the existing nand drivers could possibly be replaced by the
    plat_nand driver by using this patch.  These include autcpu12.c and
    ts7250.c drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 7f2d69356554..4030ebada49e 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -563,6 +563,7 @@ extern int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
  * @options:		Option flags, e.g. 16bit buswidth
  * @ecclayout:		ecc layout info structure
  * @part_probe_types:	NULL-terminated array of probe types
+ * @set_parts:		platform specific function to set partitions
  * @priv:		hardware controller specific settings
  */
 struct platform_nand_chip {
@@ -574,6 +575,8 @@ struct platform_nand_chip {
 	int			chip_delay;
 	unsigned int		options;
 	const char		**part_probe_types;
+	void			(*set_parts)(uint64_t size,
+					struct platform_nand_chip *chip);
 	void			*priv;
 };
 

commit bf95efd41b1a760128eb25402791b0a4941eb655
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 12 13:46:58 2009 -0700

    mtd: plat_nand: add platform probe/remove callbacks
    
    Add optional probe and remove callbacks to the plat_nand driver.
    
    Some platforms may require additional setup, such as configuring the
    memory controller, before the nand device can be accessed.  This patch
    provides an optional callback to handle this setup as well as a callback
    to teardown the setup.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Tested-by: Alexander Clouter <alex@digriz.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 0e35375ea795..7f2d69356554 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -577,8 +577,13 @@ struct platform_nand_chip {
 	void			*priv;
 };
 
+/* Keep gcc happy */
+struct platform_device;
+
 /**
  * struct platform_nand_ctrl - controller level device structure
+ * @probe:		platform specific function to probe/setup hardware
+ * @remove:		platform specific function to remove/teardown hardware
  * @hwcontrol:		platform specific hardware control structure
  * @dev_ready:		platform specific function to read ready/busy pin
  * @select_chip:	platform specific chip select function
@@ -591,6 +596,8 @@ struct platform_nand_chip {
  * All fields are optional and depend on the hardware driver requirements
  */
 struct platform_nand_ctrl {
+	int		(*probe)(struct platform_device *pdev);
+	void		(*remove)(struct platform_device *pdev);
 	void		(*hwcontrol)(struct mtd_info *mtd, int cmd);
 	int		(*dev_ready)(struct mtd_info *mtd);
 	void		(*select_chip)(struct mtd_info *mtd, int chip);

commit d6fed9e9fc5eefae5be0ecf222bac7e7496e8e74
Author: Alexander Clouter <alex@digriz.org.uk>
Date:   Mon May 11 19:28:01 2009 +0100

    mtd: extend plat_nand for (read|write)_buf
    
    This patch adds (write|read)_buf callbacks to plat_nand.
    
    The NAND on the TS-7800 provisioned by the FPGA allows readw() and
    readl() to be used which gives a 2.5x speed up.  To be able to use this
    from the plat_nand driver a hook for read_buf (and also write_buf whilst
    we are in there) need to be made available.  This patch adds the hook.
    
    Signed-off-by: Alexander Clouter <alex@digriz.org.uk>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 7efb9be34662..0e35375ea795 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -584,6 +584,8 @@ struct platform_nand_chip {
  * @select_chip:	platform specific chip select function
  * @cmd_ctrl:		platform specific function for controlling
  *			ALE/CLE/nCE. Also used to write command and address
+ * @write_buf:		platform specific function for write buffer
+ * @read_buf:		platform specific function for read buffer
  * @priv:		private data to transport driver specific settings
  *
  * All fields are optional and depend on the hardware driver requirements
@@ -594,6 +596,10 @@ struct platform_nand_ctrl {
 	void		(*select_chip)(struct mtd_info *mtd, int chip);
 	void		(*cmd_ctrl)(struct mtd_info *mtd, int dat,
 				    unsigned int ctrl);
+	void		(*write_buf)(struct mtd_info *mtd,
+				    const uint8_t *buf, int len);
+	void		(*read_buf)(struct mtd_info *mtd,
+				    uint8_t *buf, int len);
 	void		*priv;
 };
 

commit 81ec5364a58c0545b694dee02fe65b9ae48f37b6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Dec 12 17:27:03 2007 +0100

    [MTD] [NAND] Add support for 4KiB pages.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Sebastian Siewior <bigeasy@linutronix.de>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index db5b63da2a7e..7efb9be34662 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -43,8 +43,8 @@ extern void nand_wait_ready(struct mtd_info *mtd);
  * is supported now. If you add a chip with bigger oobsize/page
  * adjust this accordingly.
  */
-#define NAND_MAX_OOBSIZE	64
-#define NAND_MAX_PAGESIZE	2048
+#define NAND_MAX_OOBSIZE	128
+#define NAND_MAX_PAGESIZE	4096
 
 /*
  * Constants for hardware specific CLE/ALE/NCE function

commit d3af0f048c114dd53713d5920c54f6d5b6b12139
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Mon Dec 1 14:23:38 2008 -0800

    [MTD] [NAND] remove excess kernel-doc notation
    
    Delete extra kernel-doc notation for struct fields and function
    parameters that don't exist:
    
    Warning(include/linux/mtd/nand.h:428): Excess struct/union/enum/typedef member 'wq' description in 'nand_chip'
    Warning(include/linux/mtd/nand.h:428): Excess struct/union/enum/typedef member 'datbuf' description in 'nand_chip'
    Warning(include/linux/mtd/nand.h:428): Excess struct/union/enum/typedef member 'oobbuf' description in 'nand_chip'
    Warning(include/linux/mtd/nand.h:428): Excess struct/union/enum/typedef member 'oobdirty' description in 'nand_chip'
    Warning(include/linux/mtd/nand.h:428): Excess struct/union/enum/typedef member 'data_poi' description in 'nand_chip'
    Warning(drivers/mtd/nand/nand_base.c:2527): Excess function parameter 'maxchips' description in 'nand_scan_tail'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index c0677b8082be..db5b63da2a7e 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -335,17 +335,12 @@ struct nand_buffers {
  * @erase_cmd:		[INTERN] erase command write function, selectable due to AND support
  * @scan_bbt:		[REPLACEABLE] function to scan bad block table
  * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transfering data from array to read regs (tR)
- * @wq:			[INTERN] wait queue to sleep on if a NAND operation is in progress
  * @state:		[INTERN] the current state of the NAND device
  * @oob_poi:		poison value buffer
  * @page_shift:		[INTERN] number of address bits in a page (column address bits)
  * @phys_erase_shift:	[INTERN] number of address bits in a physical eraseblock
  * @bbt_erase_shift:	[INTERN] number of address bits in a bbt entry
  * @chip_shift:		[INTERN] number of address bits in one chip
- * @datbuf:		[INTERN] internal buffer for one page + oob
- * @oobbuf:		[INTERN] oob buffer for one eraseblock
- * @oobdirty:		[INTERN] indicates that oob_buf must be reinitialized
- * @data_poi:		[INTERN] pointer to a data buffer
  * @options:		[BOARDSPECIFIC] various chip options. They can partly be set to inform nand_scan about
  *			special functionality. See the defines for further explanation
  * @badblockpos:	[INTERN] position of the bad block marker in the oob area

commit 69423d99fc182a81f3c5db3eb5c140acc6fc64be
Author: Adrian Hunter <ext-adrian.hunter@nokia.com>
Date:   Wed Dec 10 13:37:21 2008 +0000

    [MTD] update internal API to support 64-bit device size
    
    MTD internal API presently uses 32-bit values to represent
    device size.  This patch updates them to 64-bits but leaves
    the external API unchanged.  Extending the external API
    is a separate issue for several reasons.  First, no one
    needs it at the moment.  Secondly, whether the implementation
    is done with IOCTLs, sysfs or both is still debated.  Thirdly
    external API changes require the internal API to be accepted
    first.
    
    Note that although the MTD API will be able to support 64-bit
    device sizes, existing drivers do not and are not required
    to do so, although NAND base has been updated.
    
    In general, changing from 32-bit to 64-bit values cause little
    or no changes to the majority of the code with the following
    exceptions:
            - printk message formats
            - division and modulus of 64-bit values
            - NAND base support
            - 32-bit local variables used by mtdpart and mtdconcat
            - naughtily assuming one structure maps to another
            in MEMERASE ioctl
    
    Signed-off-by: Adrian Hunter <ext-adrian.hunter@nokia.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 733d3f3b4eb8..c0677b8082be 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -399,7 +399,7 @@ struct nand_chip {
 	int		bbt_erase_shift;
 	int		chip_shift;
 	int		numchips;
-	unsigned long	chipsize;
+	uint64_t	chipsize;
 	int		pagemask;
 	int		pagebuf;
 	int		subpagesize;

commit 17c1d2be28e485c0c8b09661db39d5bf2605069d
Author: Alexey Korolev <akorolev@infradead.org>
Date:   Wed Aug 20 22:32:08 2008 +0100

    [MTD] [NAND] Fix missing kernel-doc
    
    [Reported by Randy Dunlap]
    
    Signed-off-by: Alexey Korolev <akorolev@infradead.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 81774e5facf4..733d3f3b4eb8 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -248,6 +248,7 @@ struct nand_hw_control {
  * @read_page_raw:	function to read a raw page without ECC
  * @write_page_raw:	function to write a raw page without ECC
  * @read_page:	function to read a page according to the ecc generator requirements
+ * @read_subpage:	function to read parts of the page covered by ECC.
  * @write_page:	function to write a page according to the ecc generator requirements
  * @read_oob:	function to read chip OOB data
  * @write_oob:	function to write chip OOB data

commit 96d8b647cfff90c8ff07863866aacdcd9d13cead
Author: Alexey Korolev <akorolev@infradead.org>
Date:   Tue Jul 29 13:54:11 2008 +0100

    [MTD] [NAND] fix subpage read for small page NAND
    
    Current implementation of subpage read feature for NAND has issues with
    small page devices. Small page NAND do not support RNDOUT command.
    So subpage feature is not applicable for them.
    
    This patch disables support of subpage for small page NAND.
    The code is verified on nandsim(SP NAND simulation) and on LP NAND
    devices.
    
    Thanks a lot to Artem for finding this issue.
    
    Signed-off-by: Alexey Korolev <akorolev@infradead.org>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 83f678702dff..81774e5facf4 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -177,7 +177,9 @@ typedef enum {
 #define NAND_MUST_PAD(chip) (!(chip->options & NAND_NO_PADDING))
 #define NAND_HAS_CACHEPROG(chip) ((chip->options & NAND_CACHEPRG))
 #define NAND_HAS_COPYBACK(chip) ((chip->options & NAND_COPYBACK))
-#define NAND_SUBPAGE_READ(chip) ((chip->ecc.mode == NAND_ECC_SOFT))
+/* Large page NAND with SOFT_ECC should support subpage reads */
+#define NAND_SUBPAGE_READ(chip) ((chip->ecc.mode == NAND_ECC_SOFT) \
+					&& (chip->page_shift > 9))
 
 /* Mask to zero out the chip options, which come from the id table */
 #define NAND_CHIPOPTIONS_MSK	(0x0000ffff & ~NAND_NO_AUTOINCR)

commit 3d45955962496879dead8d4dd70bb9a23b07154b
Author: Alexey Korolev <akorolev@infradead.org>
Date:   Thu May 15 17:23:18 2008 +0100

    [MTD] [NAND] subpage read feature as a way to increase performance.
    
    This patch enables NAND subpage read functionality.
    If upper layer drivers are requesting to read non page aligned data NAND
    subpage-read functionality reads the only whose ECC regions which include
    requested data when original code reads whole page.
    This significantly improves performance in many cases.
    
    Here are some digits :
    
    UBI volume mount time
    No subpage reads: 5.75 seconds
    Subpage read patch: 2.42 seconds
    
    Open/stat time for files on JFFS2 volume:
    No subpage read  0m 5.36s
    Subpage read     0m 2.88s
    
    Signed-off-by Alexey Korolev <akorolev@infradead.org>
    Acked-by: Artem Bityutskiy <dedekind@infradead.org>
    Acked-by: Jörn Engel <joern@logfs.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 863e22a0ddb5..83f678702dff 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -177,6 +177,7 @@ typedef enum {
 #define NAND_MUST_PAD(chip) (!(chip->options & NAND_NO_PADDING))
 #define NAND_HAS_CACHEPROG(chip) ((chip->options & NAND_CACHEPRG))
 #define NAND_HAS_COPYBACK(chip) ((chip->options & NAND_COPYBACK))
+#define NAND_SUBPAGE_READ(chip) ((chip->ecc.mode == NAND_ECC_SOFT))
 
 /* Mask to zero out the chip options, which come from the id table */
 #define NAND_CHIPOPTIONS_MSK	(0x0000ffff & ~NAND_NO_AUTOINCR)
@@ -274,6 +275,10 @@ struct nand_ecc_ctrl {
 	int			(*read_page)(struct mtd_info *mtd,
 					     struct nand_chip *chip,
 					     uint8_t *buf);
+	int			(*read_subpage)(struct mtd_info *mtd,
+					     struct nand_chip *chip,
+					     uint32_t offs, uint32_t len,
+					     uint8_t *buf);
 	void			(*write_page)(struct mtd_info *mtd,
 					      struct nand_chip *chip,
 					      const uint8_t *buf);

commit a8931ef380c92d121ae74ecfb03b2d63f72eea6f
Merge: 90574d0a4d4b e5a5816f7875
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Fri Jul 11 14:36:25 2008 +0100

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6

commit 44d1b980c72db0faf35adb082fb2208351803028
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Thu Jun 5 22:46:18 2008 -0700

    Fix various old email addresses for dwmw2
    
    Although if people have questions about ARCnet, perhaps it's _better_
    for them to be mailing dwmw2@cam.ac.uk about it...
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index c42bc7f533a5..53ea3dc8b0e8 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -1,7 +1,7 @@
 /*
  *  linux/include/linux/mtd/nand.h
  *
- *  Copyright (c) 2000 David Woodhouse <dwmw2@mvhi.com>
+ *  Copyright (c) 2000 David Woodhouse <dwmw2@infradead.org>
  *                     Steven J. Hill <sjhill@realitydiluted.com>
  *		       Thomas Gleixner <tglx@linutronix.de>
  *

commit 59018b6d2acabb114ab58637e6ab95ba424a89d0
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue May 20 01:03:52 2008 +0300

    MTD/JFFS2: remove CVS keywords
    
    Once upon a time, the MTD repository was using CVS.
    
    This patch therefore removes all usages of the no longer updated CVS
    keywords from the MTD code.
    
    This also includes code that printed them to the user.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index c42bc7f533a5..1288be7b7740 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -5,8 +5,6 @@
  *                     Steven J. Hill <sjhill@realitydiluted.com>
  *		       Thomas Gleixner <tglx@linutronix.de>
  *
- * $Id: nand.h,v 1.74 2005/09/15 13:58:50 vwool Exp $
- *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.

commit 30eb0db07d67b9211da7f506220184df827e425d
Author: Steven J. Hill <sjhill@realitydiluted.com>
Date:   Wed Jul 18 23:29:46 2007 -0500

    [MTD] [NAND] Add NAND manufacturer AMD.
    
    This patch adds the manufacturer ID for AMD flash.
    
    Signed-off-by: Steven J. Hill <sjhill1@rockwellcollins.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index d2365c8dcacc..c42bc7f533a5 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -432,6 +432,7 @@ struct nand_chip {
 #define NAND_MFR_STMICRO	0x20
 #define NAND_MFR_HYNIX		0xad
 #define NAND_MFR_MICRON		0x2c
+#define NAND_MFR_AMD		0x01
 
 /**
  * struct nand_flash_dev - NAND Flash Device ID Structure

commit 972edcb79ec8c8512ed5b29ca6718065328d6992
Author: Vitaly Wool <vitalywool@gmail.com>
Date:   Sun May 6 18:46:57 2007 +0400

    [MTD] [NAND] platform NAND driver: update header
    
    This patch extends nand.h in order to enable platform NAND driver.
    
    Signed-off-by: Vitaly Wool <vitalywool@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index cf197ad62da6..d2365c8dcacc 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -560,6 +560,7 @@ extern int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
  * @chip_delay:		R/B delay value in us
  * @options:		Option flags, e.g. 16bit buswidth
  * @ecclayout:		ecc layout info structure
+ * @part_probe_types:	NULL-terminated array of probe types
  * @priv:		hardware controller specific settings
  */
 struct platform_nand_chip {
@@ -570,6 +571,7 @@ struct platform_nand_chip {
 	struct nand_ecclayout	*ecclayout;
 	int			chip_delay;
 	unsigned int		options;
+	const char		**part_probe_types;
 	void			*priv;
 };
 
@@ -578,6 +580,8 @@ struct platform_nand_chip {
  * @hwcontrol:		platform specific hardware control structure
  * @dev_ready:		platform specific function to read ready/busy pin
  * @select_chip:	platform specific chip select function
+ * @cmd_ctrl:		platform specific function for controlling
+ *			ALE/CLE/nCE. Also used to write command and address
  * @priv:		private data to transport driver specific settings
  *
  * All fields are optional and depend on the hardware driver requirements
@@ -586,9 +590,21 @@ struct platform_nand_ctrl {
 	void		(*hwcontrol)(struct mtd_info *mtd, int cmd);
 	int		(*dev_ready)(struct mtd_info *mtd);
 	void		(*select_chip)(struct mtd_info *mtd, int chip);
+	void		(*cmd_ctrl)(struct mtd_info *mtd, int dat,
+				    unsigned int ctrl);
 	void		*priv;
 };
 
+/**
+ * struct platform_nand_data - container structure for platform-specific data
+ * @chip:		chip level chip structure
+ * @ctrl:		controller level device structure
+ */
+struct platform_nand_data {
+	struct platform_nand_chip	chip;
+	struct platform_nand_ctrl	ctrl;
+};
+
 /* Some helpers to access the data structures */
 static inline
 struct platform_nand_chip *get_platform_nandchip(struct mtd_info *mtd)

commit 8c60e5475d8ca614d712cd3e2fe7330480709e02
Author: sshahrom@micron.com <sshahrom@micron.com>
Date:   Wed Mar 21 18:48:02 2007 -0700

    [MTD][NAND] Add Micron Manufacturer ID
    
    Add Micron Manufacturer ID.
    
    Signed-off-by: Shahrom Sharif <sshahrom@micron.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 97523887fe5d..cf197ad62da6 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -431,6 +431,7 @@ struct nand_chip {
 #define NAND_MFR_RENESAS	0x07
 #define NAND_MFR_STMICRO	0x20
 #define NAND_MFR_HYNIX		0xad
+#define NAND_MFR_MICRON		0x2c
 
 /**
  * struct nand_flash_dev - NAND Flash Device ID Structure

commit 552a8278d0becd671274af56a11ee601e585387a
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Mon Feb 5 16:28:59 2007 -0800

    [MTD] [NAND] Add kernel-doc for cellinfo field of struct nand_chip
    
    Fixes kernel-doc warning in mtd/nand.h.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 2071b02f0526..97523887fe5d 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -343,6 +343,7 @@ struct nand_buffers {
  * @options:		[BOARDSPECIFIC] various chip options. They can partly be set to inform nand_scan about
  *			special functionality. See the defines for further explanation
  * @badblockpos:	[INTERN] position of the bad block marker in the oob area
+ * @cellinfo:		[INTERN] MLC/multichip data from chip ident
  * @numchips:		[INTERN] number of physical chips
  * @chipsize:		[INTERN] the size of one chip for multichip arrays
  * @pagemask:		[INTERN] page number mask = number of (pages / chip) - 1

commit bd3c97a7c718bfb9f1e4f31c16c383a5c6f815eb
Merge: 6c33cafc794d 0215ffb08ce9
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Fri Dec 1 09:56:43 2006 +0000

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6

commit 29072b96078ffde36f03d51e6b5d0cff1ba8c7df
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Sep 28 15:38:36 2006 +0200

    [MTD] NAND: add subpage write support
    
    Many SLC NANDs support up to 4 writes at one NAND page. Add support
    of this feature.
    
    Signed-off-by: Artem Bityutskiy <dedekind@infradead.org>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 6fc3e07497e0..1aeedf27a1ff 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -166,6 +166,9 @@ typedef enum {
  * for all large page devices, as they do not support
  * autoincrement.*/
 #define NAND_NO_READRDY		0x00000100
+/* Chip does not allow subpage writes */
+#define NAND_NO_SUBPAGE_WRITE	0x00000200
+
 
 /* Options valid for Samsung large page devices */
 #define NAND_SAMSUNG_LP_OPTIONS \
@@ -193,6 +196,9 @@ typedef enum {
 /* Nand scan has allocated controller struct */
 #define NAND_CONTROLLER_ALLOC	0x80000000
 
+/* Cell info constants */
+#define NAND_CI_CHIPNR_MSK	0x03
+#define NAND_CI_CELLTYPE_MSK	0x0C
 
 /*
  * nand_state_t - chip states
@@ -341,6 +347,7 @@ struct nand_buffers {
  * @chipsize:		[INTERN] the size of one chip for multichip arrays
  * @pagemask:		[INTERN] page number mask = number of (pages / chip) - 1
  * @pagebuf:		[INTERN] holds the pagenumber which is currently in data_buf
+ * @subpagesize:	[INTERN] holds the subpagesize
  * @ecclayout:		[REPLACEABLE] the default ecc placement scheme
  * @bbt:		[INTERN] bad block table pointer
  * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash lookup
@@ -388,6 +395,8 @@ struct nand_chip {
 	unsigned long	chipsize;
 	int		pagemask;
 	int		pagebuf;
+	int		subpagesize;
+	uint8_t		cellinfo;
 	int		badblockpos;
 
 	nand_state_t	state;

commit 351edd240d0ba8620789ca9e24f5a38b62157f23
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Sun Oct 29 22:46:40 2006 -0800

    [PATCH] MTD: fix last kernel-doc warning
    
    Fix the last current kernel-doc warning:
    Warning(/var/linsrc/linux-2619-rc3g5//include/linux/mtd/nand.h:416): No description found for parameter 'write_page'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 70420bbae82b..8b3ef4187219 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -355,7 +355,7 @@ struct nand_buffers {
  * @priv:		[OPTIONAL] pointer to private chip date
  * @errstat:		[OPTIONAL] hardware specific function to perform additional error status checks
  *			(determine if errors are correctable)
- * @write_page		[REPLACEABLE] High-level page write function
+ * @write_page:		[REPLACEABLE] High-level page write function
  */
 
 struct nand_chip {

commit 7dcdcbef5d2b60d1db68fd2c07351f7afd8ad376
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Sat Oct 21 17:09:53 2006 +0100

    [MTD] NAND: Combined oob buffer so it's contiguous with data
    
    Ditch the separate oobrbuf and oobwbuf fields from the chip buffers,
    and use only a single buffer immediately after the data. This accommodates
    NAND controllers such as the OLPC CAFÉ chip, which can't do scatter/gather
    DMA so needs the OOB buffer to be contiguous with the data, for both read
    and write.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 70420bbae82b..6fc3e07497e0 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -286,9 +286,7 @@ struct nand_ecc_ctrl {
  * struct nand_buffers - buffer structure for read/write
  * @ecccalc:	buffer for calculated ecc
  * @ecccode:	buffer for ecc read from flash
- * @oobwbuf:	buffer for write oob data
  * @databuf:	buffer for data - dynamically sized
- * @oobrbuf:	buffer to read oob data
  *
  * Do not change the order of buffers. databuf and oobrbuf must be in
  * consecutive order.
@@ -296,9 +294,7 @@ struct nand_ecc_ctrl {
 struct nand_buffers {
 	uint8_t	ecccalc[NAND_MAX_OOBSIZE];
 	uint8_t	ecccode[NAND_MAX_OOBSIZE];
-	uint8_t	oobwbuf[NAND_MAX_OOBSIZE];
-	uint8_t databuf[NAND_MAX_PAGESIZE];
-	uint8_t	oobrbuf[NAND_MAX_OOBSIZE];
+	uint8_t databuf[NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE];
 };
 
 /**

commit b77d95c78fb0ec330cd53e0d297ffa4fd2975e32
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Mon Sep 25 21:58:50 2006 +0100

    [MTD NAND] Provide prototype for newly-exported nand_wait_ready()
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 2bcbcc896835..70420bbae82b 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -35,6 +35,9 @@ extern int nand_scan_tail(struct mtd_info *mtd);
 /* Free resources held by the NAND device */
 extern void nand_release (struct mtd_info *mtd);
 
+/* Internal helper for board drivers which need to override command function */
+extern void nand_wait_ready(struct mtd_info *mtd);
+
 /* The maximum number of NAND chips in an array */
 #define NAND_MAX_CHIPS		8
 

commit 956e944c7690ea994757a8cbedbb6241e1d9138f
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Mon Sep 25 17:12:39 2006 +0100

    [MTD NAND] Allow override of page read and write functions.
    
    - allow high-level nand_write_page() function to be overridden
    - likewise low-level write_page_raw() and read_page_raw() functions
    - Clean up the abuse of chip->ecc.{write,read}_page() with MTD_OOB_RAW
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index cd4fe9ae8622..2bcbcc896835 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -235,6 +235,8 @@ struct nand_hw_control {
  *		be provided if an hardware ECC is available
  * @calculate:	function for ecc calculation or readback from ecc hardware
  * @correct:	function for ecc correction, matching to ecc generator (sw/hw)
+ * @read_page_raw:	function to read a raw page without ECC
+ * @write_page_raw:	function to write a raw page without ECC
  * @read_page:	function to read a page according to the ecc generator requirements
  * @write_page:	function to write a page according to the ecc generator requirements
  * @read_oob:	function to read chip OOB data
@@ -256,6 +258,12 @@ struct nand_ecc_ctrl {
 	int			(*correct)(struct mtd_info *mtd, uint8_t *dat,
 					   uint8_t *read_ecc,
 					   uint8_t *calc_ecc);
+	int			(*read_page_raw)(struct mtd_info *mtd,
+						 struct nand_chip *chip,
+						 uint8_t *buf);
+	void			(*write_page_raw)(struct mtd_info *mtd,
+						  struct nand_chip *chip,
+						  const uint8_t *buf);
 	int			(*read_page)(struct mtd_info *mtd,
 					     struct nand_chip *chip,
 					     uint8_t *buf);
@@ -344,6 +352,7 @@ struct nand_buffers {
  * @priv:		[OPTIONAL] pointer to private chip date
  * @errstat:		[OPTIONAL] hardware specific function to perform additional error status checks
  *			(determine if errors are correctable)
+ * @write_page		[REPLACEABLE] High-level page write function
  */
 
 struct nand_chip {
@@ -366,6 +375,8 @@ struct nand_chip {
 	void		(*erase_cmd)(struct mtd_info *mtd, int page);
 	int		(*scan_bbt)(struct mtd_info *mtd);
 	int		(*errstat)(struct mtd_info *mtd, struct nand_chip *this, int state, int status, int page);
+	int		(*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
+				      const uint8_t *buf, int page, int cached, int raw);
 
 	int		chip_delay;
 	unsigned int	options;

commit 4bf63fcb83dc761853f69a77b15e47712689020b
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Mon Sep 25 17:08:04 2006 +0100

    [MTD NAND] Allocate chip->buffers separately to allow it to be overridden
    
    In particular, the board driver might need it to be DMAable.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 88d690d79d77..cd4fe9ae8622 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -183,7 +183,9 @@ typedef enum {
 #define NAND_USE_FLASH_BBT	0x00010000
 /* This option skips the bbt scan during initialization. */
 #define NAND_SKIP_BBTSCAN	0x00020000
-
+/* This option is defined if the board driver allocates its own buffers
+   (e.g. because it needs them DMA-coherent */
+#define NAND_OWN_BUFFERS	0x00040000
 /* Options set by nand scan */
 /* Nand scan has allocated controller struct */
 #define NAND_CONTROLLER_ALLOC	0x80000000
@@ -385,7 +387,7 @@ struct nand_chip {
 	struct nand_ecclayout	*ecclayout;
 
 	struct nand_ecc_ctrl ecc;
-	struct nand_buffers buffers;
+	struct nand_buffers *buffers;
 	struct nand_hw_control hwcontrol;
 
 	struct mtd_oob_ops ops;

commit 3b85c3211ebde263a86c8cd3c7277fdd2e440310
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Mon Sep 25 17:06:53 2006 +0100

    [MTD NAND] Split nand_scan() into two parts; allow board driver to intervene
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 0b4cd2fa64aa..88d690d79d77 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -27,6 +27,11 @@
 struct mtd_info;
 /* Scan and identify a NAND device */
 extern int nand_scan (struct mtd_info *mtd, int max_chips);
+/* Separate phases of nand_scan(), allowing board driver to intervene
+ * and override command or ECC setup according to flash type */
+extern int nand_scan_ident(struct mtd_info *mtd, int max_chips);
+extern int nand_scan_tail(struct mtd_info *mtd);
+
 /* Free resources held by the NAND device */
 extern void nand_release (struct mtd_info *mtd);
 

commit ea9b6dcc152f09c207117ab121d4fa03d2db282a
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Wed Jun 28 21:48:38 2006 -0700

    MTD: kernel-doc fixes + additions
    
    Fix some kernel-doc typos/spellos.
    Use kernel-doc syntax in places where it was almost used.
    Correct/add struct, struct field, and function param names where needed.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 2266f032a8c6..0b4cd2fa64aa 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -407,7 +407,6 @@ struct nand_chip {
 
 /**
  * struct nand_flash_dev - NAND Flash Device ID Structure
- *
  * @name:	Identify the device type
  * @id:		device ID code
  * @pagesize:	Pagesize in bytes. Either 256 or 512 or 0
@@ -526,7 +525,6 @@ extern int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
 
 /**
  * struct platform_nand_chip - chip level device structure
- *
  * @nr_chips:		max. number of chips to scan for
  * @chip_offset:	chip number offset
  * @nr_partitions:	number of partitions pointed to by partitions (or zero)
@@ -549,7 +547,6 @@ struct platform_nand_chip {
 
 /**
  * struct platform_nand_ctrl - controller level device structure
- *
  * @hwcontrol:		platform specific hardware control structure
  * @dev_ready:		platform specific function to read ready/busy pin
  * @select_chip:	platform specific chip select function

commit 844d3b427ef1a4f96e54866747bdb6c6cbca4c6a
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Wed Jun 28 21:48:27 2006 -0700

    MTD: fix all kernel-doc warnings
    
    Fix all kernel-doc warnings in MTD headers and source files:
    - add some missing struct fields;
    - correct some function parameter names;
    - use kernel-doc format for function doc. headers;
    - nand_ecc.c contains only exported interfaces, no internal ones;
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 66559272ebcb..2266f032a8c6 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -202,7 +202,7 @@ typedef enum {
 struct nand_chip;
 
 /**
- * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independend devices
+ * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independent devices
  * @lock:               protection lock
  * @active:		the mtd device which holds the controller currently
  * @wq:			wait queue to sleep on if a NAND operation is in progress
@@ -223,12 +223,15 @@ struct nand_hw_control {
  * @total:	total number of ecc bytes per page
  * @prepad:	padding information for syndrome based ecc generators
  * @postpad:	padding information for syndrome based ecc generators
+ * @layout:	ECC layout control struct pointer
  * @hwctl:	function to control hardware ecc generator. Must only
  *		be provided if an hardware ECC is available
  * @calculate:	function for ecc calculation or readback from ecc hardware
  * @correct:	function for ecc correction, matching to ecc generator (sw/hw)
  * @read_page:	function to read a page according to the ecc generator requirements
  * @write_page:	function to write a page according to the ecc generator requirements
+ * @read_oob:	function to read chip OOB data
+ * @write_oob:	function to write chip OOB data
  */
 struct nand_ecc_ctrl {
 	nand_ecc_modes_t	mode;
@@ -300,11 +303,15 @@ struct nand_buffers {
  * @cmdfunc:		[REPLACEABLE] hardwarespecific function for writing commands to the chip
  * @waitfunc:		[REPLACEABLE] hardwarespecific function for wait on ready
  * @ecc:		[BOARDSPECIFIC] ecc control ctructure
+ * @buffers:		buffer structure for read/write
+ * @hwcontrol:		platform-specific hardware control structure
+ * @ops:		oob operation operands
  * @erase_cmd:		[INTERN] erase command write function, selectable due to AND support
  * @scan_bbt:		[REPLACEABLE] function to scan bad block table
  * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transfering data from array to read regs (tR)
  * @wq:			[INTERN] wait queue to sleep on if a NAND operation is in progress
  * @state:		[INTERN] the current state of the NAND device
+ * @oob_poi:		poison value buffer
  * @page_shift:		[INTERN] number of address bits in a page (column address bits)
  * @phys_erase_shift:	[INTERN] number of address bits in a physical eraseblock
  * @bbt_erase_shift:	[INTERN] number of address bits in a bbt entry
@@ -521,7 +528,7 @@ extern int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
  * struct platform_nand_chip - chip level device structure
  *
  * @nr_chips:		max. number of chips to scan for
- * @chip_offs:		chip number offset
+ * @chip_offset:	chip number offset
  * @nr_partitions:	number of partitions pointed to by partitions (or zero)
  * @partitions:		mtd partition list
  * @chip_delay:		R/B delay value in us
@@ -546,7 +553,7 @@ struct platform_nand_chip {
  * @hwcontrol:		platform specific hardware control structure
  * @dev_ready:		platform specific function to read ready/busy pin
  * @select_chip:	platform specific chip select function
- * @priv_data:		private data to transport driver specific settings
+ * @priv:		private data to transport driver specific settings
  *
  * All fields are optional and depend on the hardware driver requirements
  */

commit cee4cca740d209bcb4b9857baa2253d5ba4e3fbe
Merge: 2edc322d420a 9348f0de2d2b
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Tue Jun 20 15:10:08 2006 -0700

    Merge git://git.infradead.org/hdrcleanup-2.6
    
    * git://git.infradead.org/hdrcleanup-2.6: (63 commits)
      [S390] __FD_foo definitions.
      Switch to __s32 types in joystick.h instead of C99 types for consistency.
      Add <sys/types.h> to headers included for userspace in <linux/input.h>
      Move inclusion of <linux/compat.h> out of user scope in asm-x86_64/mtrr.h
      Remove struct fddi_statistics from user view in <linux/if_fddi.h>
      Move user-visible parts of drivers/s390/crypto/z90crypt.h to include/asm-s390
      Revert include/media changes: Mauro says those ioctls are only used in-kernel(!)
      Include <linux/types.h> and use __uXX types in <linux/cramfs_fs.h>
      Use __uXX types in <linux/i2o_dev.h>, include <linux/ioctl.h> too
      Remove private struct dx_hash_info from public view in <linux/ext3_fs.h>
      Include <linux/types.h> and use __uXX types in <linux/affs_hardblocks.h>
      Use __uXX types in <linux/divert.h> for struct divert_blk et al.
      Use __u32 for elf_addr_t in <asm-powerpc/elf.h>, not u32. It's user-visible.
      Remove PPP_FCS from user view in <linux/ppp_defs.h>, remove __P mess entirely
      Use __uXX types in user-visible structures in <linux/nbd.h>
      Don't use 'u32' in user-visible struct ip_conntrack_old_tuple.
      Use __uXX types for S390 DASD volume label definitions which are user-visible
      S390 BIODASDREADCMB ioctl should use __u64 not u64 type.
      Remove unneeded inclusion of <linux/time.h> from <linux/ufs_fs.h>
      Fix private integer types used in V4L2 ioctls.
      ...
    
    Manually resolve conflict in include/linux/mtd/physmap.h

commit 7bc3312bef4d6f220812500c0de7868fb7625a41
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Tue Jun 20 20:05:05 2006 +0200

    [MTD] NAND: Fix breakage all over the place
    
    Following problems are addressed:
    
    - wrong status caused early break out of nand_wait()
    - removed the bogus status check in nand_wait() which
      is a relict of the abandoned support for interrupted
      erase.
    - status check moved to the correct place in read_oob
    - oob support for syndrom based ecc with strange layouts
    - use given offset in the AUTOOOB based oob operations
    
    Partially based on a patch from Vitaly Vool <vwool@ru.mvista.com>
    Thanks to Savin Zlobec <savin@epico.si> for tracking down the
    status problem.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index bf2ce68901f5..a30969eb9afe 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -63,18 +63,21 @@ extern void nand_release (struct mtd_info *mtd);
  */
 #define NAND_CMD_READ0		0
 #define NAND_CMD_READ1		1
+#define NAND_CMD_RNDOUT		5
 #define NAND_CMD_PAGEPROG	0x10
 #define NAND_CMD_READOOB	0x50
 #define NAND_CMD_ERASE1		0x60
 #define NAND_CMD_STATUS		0x70
 #define NAND_CMD_STATUS_MULTI	0x71
 #define NAND_CMD_SEQIN		0x80
+#define NAND_CMD_RNDIN		0x85
 #define NAND_CMD_READID		0x90
 #define NAND_CMD_ERASE2		0xd0
 #define NAND_CMD_RESET		0xff
 
 /* Extended commands for large page devices */
 #define NAND_CMD_READSTART	0x30
+#define NAND_CMD_RNDOUTSTART	0xE0
 #define NAND_CMD_CACHEDPROG	0x15
 
 /* Extended commands for AG-AND device */
@@ -250,6 +253,13 @@ struct nand_ecc_ctrl {
 	void			(*write_page)(struct mtd_info *mtd,
 					      struct nand_chip *chip,
 					      const uint8_t *buf);
+	int			(*read_oob)(struct mtd_info *mtd,
+					    struct nand_chip *chip,
+					    int page,
+					    int sndcmd);
+	int			(*write_oob)(struct mtd_info *mtd,
+					     struct nand_chip *chip,
+					     int page);
 };
 
 /**
@@ -339,7 +349,7 @@ struct nand_chip {
 				    unsigned int ctrl);
 	int		(*dev_ready)(struct mtd_info *mtd);
 	void		(*cmdfunc)(struct mtd_info *mtd, unsigned command, int column, int page_addr);
-	int		(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this, int state);
+	int		(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this);
 	void		(*erase_cmd)(struct mtd_info *mtd, int page);
 	int		(*scan_bbt)(struct mtd_info *mtd);
 	int		(*errstat)(struct mtd_info *mtd, struct nand_chip *this, int state, int status, int page);

commit 8593fbc68b0df1168995de76d1af38eb62fd6b62
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Mon May 29 03:26:58 2006 +0200

    [MTD] Rework the out of band handling completely
    
    Hopefully the last iteration on this!
    
    The handling of out of band data on NAND was accompanied by tons of fruitless
    discussions and halfarsed patches to make it work for a particular
    problem. Sufficiently annoyed by I all those "I know it better" mails and the
    resonable amount of discarded "it solves my problem" patches, I finally decided
    to go for the big rework. After removing the _ecc variants of mtd read/write
    functions the solution to satisfy the various requirements was to refactor the
    read/write _oob functions in mtd.
    
    The major change is that read/write_oob now takes a pointer to an operation
    descriptor structure "struct mtd_oob_ops".instead of having a function with at
    least seven arguments.
    
    read/write_oob which should probably renamed to a more descriptive name, can do
    the following tasks:
    
    - read/write out of band data
    - read/write data content and out of band data
    - read/write raw data content and out of band data (ecc disabled)
    
    struct mtd_oob_ops has a mode field, which determines the oob handling mode.
    
    Aside of the MTD_OOB_RAW mode, which is intended to be especially for
    diagnostic purposes and some internal functions e.g. bad block table creation,
    the other two modes are for mtd clients:
    
    MTD_OOB_PLACE puts/gets the given oob data exactly to/from the place which is
    described by the ooboffs and ooblen fields of the mtd_oob_ops strcuture. It's
    up to the caller to make sure that the byte positions are not used by the ECC
    placement algorithms.
    
    MTD_OOB_AUTO puts/gets the given oob data automaticaly to/from the places in
    the out of band area which are described by the oobfree tuples in the ecclayout
    data structre which is associated to the devicee.
    
    The decision whether data plus oob or oob only handling is done depends on the
    setting of the datbuf member of the data structure. When datbuf == NULL then
    the internal read/write_oob functions are selected, otherwise the read/write
    data routines are invoked.
    
    Tested on a few platforms with all variants. Please be aware of possible
    regressions for your particular device / application scenario
    
    Disclaimer: Any whining will be ignored from those who just contributed "hot
    air blurb" and never sat down to tackle the underlying problem of the mess in
    the NAND driver grown over time and the big chunk of work to fix up the
    existing users. The problem was not the holiness of the existing MTD
    interfaces. The problems was the lack of time to go for the big overhaul. It's
    easy to add more mess to the existing one, but it takes alot of effort to go
    for a real solution.
    
    Improvements and bugfixes are welcome!
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index dc2bf1bcf42b..bf2ce68901f5 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -31,14 +31,6 @@ extern int nand_scan (struct mtd_info *mtd, int max_chips);
 /* Free resources held by the NAND device */
 extern void nand_release (struct mtd_info *mtd);
 
-/* Read raw data from the device without ECC */
-extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from,
-			  size_t len, size_t ooblen);
-
-
-extern int nand_write_raw(struct mtd_info *mtd, loff_t to, size_t len,
-			  size_t *retlen, const uint8_t *buf, uint8_t *oob);
-
 /* The maximum number of NAND chips in an array */
 #define NAND_MAX_CHIPS		8
 
@@ -375,6 +367,8 @@ struct nand_chip {
 	struct nand_buffers buffers;
 	struct nand_hw_control hwcontrol;
 
+	struct mtd_oob_ops ops;
+
 	uint8_t		*bbt;
 	struct nand_bbt_descr	*bbt_td;
 	struct nand_bbt_descr	*bbt_md;

commit 5bd34c091a044d130601370c370f84b1c59f1627
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Sat May 27 22:16:10 2006 +0200

    [MTD] NAND Replace oobinfo by ecclayout
    
    The nand_oobinfo structure is not fitting the newer error correction
    demands anymore. Replace it by struct nand_ecclayout and fixup the users
    all over the place. Keep the nand_oobinfo based ioctl for user space
    compability reasons.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index fd46bcf52281..dc2bf1bcf42b 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -244,6 +244,7 @@ struct nand_ecc_ctrl {
 	int			total;
 	int			prepad;
 	int			postpad;
+	struct nand_ecclayout	*layout;
 	void			(*hwctl)(struct mtd_info *mtd, int mode);
 	int			(*calculate)(struct mtd_info *mtd,
 					     const uint8_t *dat,
@@ -318,7 +319,7 @@ struct nand_buffers {
  * @chipsize:		[INTERN] the size of one chip for multichip arrays
  * @pagemask:		[INTERN] page number mask = number of (pages / chip) - 1
  * @pagebuf:		[INTERN] holds the pagenumber which is currently in data_buf
- * @autooob:		[REPLACEABLE] the default (auto)placement scheme
+ * @ecclayout:		[REPLACEABLE] the default ecc placement scheme
  * @bbt:		[INTERN] bad block table pointer
  * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash lookup
  * @bbt_md:		[REPLACEABLE] bad block table mirror descriptor
@@ -368,7 +369,7 @@ struct nand_chip {
 
 	uint8_t		*oob_poi;
 	struct nand_hw_control  *controller;
-	struct nand_oobinfo	*autooob;
+	struct nand_ecclayout	*ecclayout;
 
 	struct nand_ecc_ctrl ecc;
 	struct nand_buffers buffers;
@@ -522,7 +523,7 @@ extern int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
  * @partitions:		mtd partition list
  * @chip_delay:		R/B delay value in us
  * @options:		Option flags, e.g. 16bit buswidth
- * @oobinfo:		oob info structure (ecc placement)
+ * @ecclayout:		ecc layout info structure
  * @priv:		hardware controller specific settings
  */
 struct platform_nand_chip {
@@ -530,7 +531,7 @@ struct platform_nand_chip {
 	int			chip_offset;
 	int			nr_partitions;
 	struct mtd_partition	*partitions;
-	struct nand_oobinfo	*oobinfo;
+	struct nand_ecclayout	*ecclayout;
 	int			chip_delay;
 	unsigned int		options;
 	void			*priv;

commit 8be834f76291fdcc0614cb84926c6910b9f2ecbc
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Sat May 27 20:05:26 2006 +0200

    [MTD] NAND Fix platform structure and NDFC driver
    
    The platform structure was lacking an oobinfo field.
    The NDFC driver had some remains from another tree.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 1a749ba6130f..fd46bcf52281 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -518,10 +518,11 @@ extern int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
  *
  * @nr_chips:		max. number of chips to scan for
  * @chip_offs:		chip number offset
- * @nr_partitions:	number of partitions pointed to be partitoons (or zero)
+ * @nr_partitions:	number of partitions pointed to by partitions (or zero)
  * @partitions:		mtd partition list
  * @chip_delay:		R/B delay value in us
  * @options:		Option flags, e.g. 16bit buswidth
+ * @oobinfo:		oob info structure (ecc placement)
  * @priv:		hardware controller specific settings
  */
 struct platform_nand_chip {
@@ -529,6 +530,7 @@ struct platform_nand_chip {
 	int			chip_offset;
 	int			nr_partitions;
 	struct mtd_partition	*partitions;
+	struct nand_oobinfo	*oobinfo;
 	int			chip_delay;
 	unsigned int		options;
 	void			*priv;

commit f75e5097ef298c5a0aa106faa211d1afdc92dc3d
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Fri May 26 18:52:08 2006 +0200

    [MTD] NAND modularize write function
    
    Modularize the write function and reorganaize the internal buffer
    management. Remove obsolete chip options and fixup all affected
    users.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 00916498ea55..1a749ba6130f 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -37,7 +37,7 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from,
 
 
 extern int nand_write_raw(struct mtd_info *mtd, loff_t to, size_t len,
-			  size_t *retlen, uint8_t *buf, uint8_t *oob);
+			  size_t *retlen, const uint8_t *buf, uint8_t *oob);
 
 /* The maximum number of NAND chips in an array */
 #define NAND_MAX_CHIPS		8
@@ -47,6 +47,7 @@ extern int nand_write_raw(struct mtd_info *mtd, loff_t to, size_t len,
  * adjust this accordingly.
  */
 #define NAND_MAX_OOBSIZE	64
+#define NAND_MAX_PAGESIZE	2048
 
 /*
  * Constants for hardware specific CLE/ALE/NCE function
@@ -181,20 +182,12 @@ typedef enum {
 /* Use a flash based bad block table. This option is passed to the
  * default bad block table function. */
 #define NAND_USE_FLASH_BBT	0x00010000
-/* The hw ecc generator provides a syndrome instead a ecc value on read
- * This can only work if we have the ecc bytes directly behind the
- * data bytes. Applies for DOC and AG-AND Renesas HW Reed Solomon generators */
-#define NAND_HWECC_SYNDROME	0x00020000
 /* This option skips the bbt scan during initialization. */
-#define NAND_SKIP_BBTSCAN	0x00040000
+#define NAND_SKIP_BBTSCAN	0x00020000
 
 /* Options set by nand scan */
 /* Nand scan has allocated controller struct */
-#define NAND_CONTROLLER_ALLOC	0x20000000
-/* Nand scan has allocated oob_buf */
-#define NAND_OOBBUF_ALLOC	0x40000000
-/* Nand scan has allocated data_buf */
-#define NAND_DATABUF_ALLOC	0x80000000
+#define NAND_CONTROLLER_ALLOC	0x80000000
 
 
 /*
@@ -240,6 +233,7 @@ struct nand_hw_control {
  *		be provided if an hardware ECC is available
  * @calculate:	function for ecc calculation or readback from ecc hardware
  * @correct:	function for ecc correction, matching to ecc generator (sw/hw)
+ * @read_page:	function to read a page according to the ecc generator requirements
  * @write_page:	function to write a page according to the ecc generator requirements
  */
 struct nand_ecc_ctrl {
@@ -260,9 +254,28 @@ struct nand_ecc_ctrl {
 	int			(*read_page)(struct mtd_info *mtd,
 					     struct nand_chip *chip,
 					     uint8_t *buf);
-	int			(*write_page)(struct mtd_info *mtd,
+	void			(*write_page)(struct mtd_info *mtd,
 					      struct nand_chip *chip,
-					      uint8_t *buf, int cached);
+					      const uint8_t *buf);
+};
+
+/**
+ * struct nand_buffers - buffer structure for read/write
+ * @ecccalc:	buffer for calculated ecc
+ * @ecccode:	buffer for ecc read from flash
+ * @oobwbuf:	buffer for write oob data
+ * @databuf:	buffer for data - dynamically sized
+ * @oobrbuf:	buffer to read oob data
+ *
+ * Do not change the order of buffers. databuf and oobrbuf must be in
+ * consecutive order.
+ */
+struct nand_buffers {
+	uint8_t	ecccalc[NAND_MAX_OOBSIZE];
+	uint8_t	ecccode[NAND_MAX_OOBSIZE];
+	uint8_t	oobwbuf[NAND_MAX_OOBSIZE];
+	uint8_t databuf[NAND_MAX_PAGESIZE];
+	uint8_t	oobrbuf[NAND_MAX_OOBSIZE];
 };
 
 /**
@@ -294,8 +307,8 @@ struct nand_ecc_ctrl {
  * @phys_erase_shift:	[INTERN] number of address bits in a physical eraseblock
  * @bbt_erase_shift:	[INTERN] number of address bits in a bbt entry
  * @chip_shift:		[INTERN] number of address bits in one chip
- * @data_buf:		[INTERN] internal buffer for one page + oob
- * @oob_buf:		[INTERN] oob buffer for one eraseblock
+ * @datbuf:		[INTERN] internal buffer for one page + oob
+ * @oobbuf:		[INTERN] oob buffer for one eraseblock
  * @oobdirty:		[INTERN] indicates that oob_buf must be reinitialized
  * @data_poi:		[INTERN] pointer to a data buffer
  * @options:		[BOARDSPECIFIC] various chip options. They can partly be set to inform nand_scan about
@@ -336,32 +349,38 @@ struct nand_chip {
 	int		(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this, int state);
 	void		(*erase_cmd)(struct mtd_info *mtd, int page);
 	int		(*scan_bbt)(struct mtd_info *mtd);
-	struct nand_ecc_ctrl ecc;
+	int		(*errstat)(struct mtd_info *mtd, struct nand_chip *this, int state, int status, int page);
+
 	int		chip_delay;
-	wait_queue_head_t wq;
-	nand_state_t	state;
+	unsigned int	options;
+
 	int		page_shift;
 	int		phys_erase_shift;
 	int		bbt_erase_shift;
 	int		chip_shift;
-	uint8_t		*data_buf;
-	uint8_t		*oob_buf;
-	int		oobdirty;
-	uint8_t		*data_poi;
-	unsigned int	options;
-	int		badblockpos;
 	int		numchips;
 	unsigned long	chipsize;
 	int		pagemask;
 	int		pagebuf;
+	int		badblockpos;
+
+	nand_state_t	state;
+
+	uint8_t		*oob_poi;
+	struct nand_hw_control  *controller;
 	struct nand_oobinfo	*autooob;
+
+	struct nand_ecc_ctrl ecc;
+	struct nand_buffers buffers;
+	struct nand_hw_control hwcontrol;
+
 	uint8_t		*bbt;
 	struct nand_bbt_descr	*bbt_td;
 	struct nand_bbt_descr	*bbt_md;
+
 	struct nand_bbt_descr	*badblock_pattern;
-	struct nand_hw_control  *controller;
+
 	void		*priv;
-	int		(*errstat)(struct mtd_info *mtd, struct nand_chip *this, int state, int status, int page);
 };
 
 /*

commit f5bbdacc41939f89d8ccb18dd79cd9b21c0cb75d
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Thu May 25 10:07:16 2006 +0200

    [MTD] NAND Modularize read function
    
    Split the core of the read function out and implement
    seperate handling functions for software and hardware
    ECC.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index daacde5132fe..00916498ea55 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -479,14 +479,14 @@ struct nand_bbt_descr {
 /* The maximum number of blocks to scan for a bbt */
 #define NAND_BBT_SCAN_MAXBLOCKS	4
 
-extern int nand_scan_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd);
-extern int nand_update_bbt (struct mtd_info *mtd, loff_t offs);
-extern int nand_default_bbt (struct mtd_info *mtd);
-extern int nand_isbad_bbt (struct mtd_info *mtd, loff_t offs, int allowbbt);
-extern int nand_erase_nand (struct mtd_info *mtd, struct erase_info *instr, int allowbbt);
-extern int nand_do_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
-			     size_t * retlen, uint8_t * buf, uint8_t * oob_buf,
-			     struct nand_oobinfo *oobsel, int flags);
+extern int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd);
+extern int nand_update_bbt(struct mtd_info *mtd, loff_t offs);
+extern int nand_default_bbt(struct mtd_info *mtd);
+extern int nand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt);
+extern int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
+			   int allowbbt);
+extern int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
+			size_t * retlen, uint8_t * buf);
 
 /*
 * Constants for oob configuration

commit 9577f44a899cf4acb9e381c8946307b72153cd15
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Thu May 25 10:04:31 2006 +0200

    [MTD] NAND Add read/write function pointers to struct nand_ecc_ctrl
    
    Add read/write function pointers to struct nand_ecc_ctrl to
    prepare the modulaization of nand_read/write functions. The
    current implementation handles every type of ecc mode
    software/hardware and all kinds of strange ecc placement
    schemes in one switch/if construct. Thats too complex to
    maintain and too inflexible to expand. Modularization will
    also shorten the code pathes of the read/write functions.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 2fd85d55803d..daacde5132fe 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -233,16 +233,23 @@ struct nand_hw_control {
  * @steps:	number of ecc steps per page
  * @size:	data bytes per ecc step
  * @bytes:	ecc bytes per step
+ * @total:	total number of ecc bytes per page
+ * @prepad:	padding information for syndrome based ecc generators
+ * @postpad:	padding information for syndrome based ecc generators
  * @hwctl:	function to control hardware ecc generator. Must only
  *		be provided if an hardware ECC is available
  * @calculate:	function for ecc calculation or readback from ecc hardware
  * @correct:	function for ecc correction, matching to ecc generator (sw/hw)
+ * @write_page:	function to write a page according to the ecc generator requirements
  */
 struct nand_ecc_ctrl {
 	nand_ecc_modes_t	mode;
 	int			steps;
 	int			size;
 	int			bytes;
+	int			total;
+	int			prepad;
+	int			postpad;
 	void			(*hwctl)(struct mtd_info *mtd, int mode);
 	int			(*calculate)(struct mtd_info *mtd,
 					     const uint8_t *dat,
@@ -250,6 +257,12 @@ struct nand_ecc_ctrl {
 	int			(*correct)(struct mtd_info *mtd, uint8_t *dat,
 					   uint8_t *read_ecc,
 					   uint8_t *calc_ecc);
+	int			(*read_page)(struct mtd_info *mtd,
+					     struct nand_chip *chip,
+					     uint8_t *buf);
+	int			(*write_page)(struct mtd_info *mtd,
+					      struct nand_chip *chip,
+					      uint8_t *buf, int cached);
 };
 
 /**

commit 7a30601b3ac7b02440ffa629fd3d2cca71c1bcd8
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Thu May 25 09:50:16 2006 +0200

    [MTD] NAND Introduce NAND_NO_READRDY option
    
    The nand driver has a superflous read ready / command
    delay in the read functions. This was added to handle
    chips which have an automatic read forward. Newer
    chips do not have this functionality anymore. Add this
    option to avoid the delay / I/O operation. Mark all
    large page chips with the new option flag.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 2c0fb6380461..2fd85d55803d 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -159,6 +159,10 @@ typedef enum {
  * bits from adjacent blocks from 'leaking' in altering data.
  * This happens with the Renesas AG-AND chips, possibly others.  */
 #define BBT_AUTO_REFRESH	0x00000080
+/* Chip does not require ready check on read. True
+ * for all large page devices, as they do not support
+ * autoincrement.*/
+#define NAND_NO_READRDY		0x00000100
 
 /* Options valid for Samsung large page devices */
 #define NAND_SAMSUNG_LP_OPTIONS \

commit cad74f2c380411ae7bee997f3ba18834cfe313a2
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Tue May 23 23:28:48 2006 +0200

    [MTD] NAND remove write_byte/word function from nand_chip
    
    The previous change of the command / hardware control allows to
    remove the write_byte/word functions completely, as their only
    user were nand_command and nand_command_lp.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index e9a935263151..2c0fb6380461 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -253,9 +253,7 @@ struct nand_ecc_ctrl {
  * @IO_ADDR_R:		[BOARDSPECIFIC] address to read the 8 I/O lines of the flash device
  * @IO_ADDR_W:		[BOARDSPECIFIC] address to write the 8 I/O lines of the flash device
  * @read_byte:		[REPLACEABLE] read one byte from the chip
- * @write_byte:		[REPLACEABLE] write one byte to the chip
  * @read_word:		[REPLACEABLE] read one word from the chip
- * @write_word:		[REPLACEABLE] write one word to the chip
  * @write_buf:		[REPLACEABLE] write data from the buffer to the chip
  * @read_buf:		[REPLACEABLE] read data from the chip into the buffer
  * @verify_buf:		[REPLACEABLE] verify buffer contents against the chip data
@@ -307,10 +305,7 @@ struct nand_chip {
 	void  __iomem	*IO_ADDR_W;
 
 	uint8_t		(*read_byte)(struct mtd_info *mtd);
-	void		(*write_byte)(struct mtd_info *mtd, uint8_t byte);
 	u16		(*read_word)(struct mtd_info *mtd);
-	void		(*write_word)(struct mtd_info *mtd, u16 word);
-
 	void		(*write_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
 	void		(*read_buf)(struct mtd_info *mtd, uint8_t *buf, int len);
 	int		(*verify_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);

commit 7abd3ef9875eb2afcdcd4f450680298a2983a55e
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Tue May 23 23:25:53 2006 +0200

    [MTD] Refactor NAND hwcontrol to cmd_ctrl
    
    The hwcontrol function enforced a step by step state machine
    for any kind of hardware chip access. Let the hardware driver
    know which control bits are set and inform it about a change
    of the control lines. Let the hardware driver write out the
    command and address bytes directly. This gives a peformance
    advantage for address bus controlled chips and simplifies the
    quirks in the hardware drivers.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 8362b466df3a..e9a935263151 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -50,23 +50,20 @@ extern int nand_write_raw(struct mtd_info *mtd, loff_t to, size_t len,
 
 /*
  * Constants for hardware specific CLE/ALE/NCE function
-*/
+ *
+ * These are bits which can be or'ed to set/clear multiple
+ * bits in one go.
+ */
 /* Select the chip by setting nCE to low */
-#define NAND_CTL_SETNCE		1
-/* Deselect the chip by setting nCE to high */
-#define NAND_CTL_CLRNCE		2
+#define NAND_NCE		0x01
 /* Select the command latch by setting CLE to high */
-#define NAND_CTL_SETCLE		3
-/* Deselect the command latch by setting CLE to low */
-#define NAND_CTL_CLRCLE		4
+#define NAND_CLE		0x02
 /* Select the address latch by setting ALE to high */
-#define NAND_CTL_SETALE		5
-/* Deselect the address latch by setting ALE to low */
-#define NAND_CTL_CLRALE		6
-/* Set write protection by setting WP to high. Not used! */
-#define NAND_CTL_SETWP		7
-/* Clear write protection by setting WP to low. Not used! */
-#define NAND_CTL_CLRWP		8
+#define NAND_ALE		0x04
+
+#define NAND_CTRL_CLE		(NAND_NCE | NAND_CLE)
+#define NAND_CTRL_ALE		(NAND_NCE | NAND_ALE)
+#define NAND_CTRL_CHANGE	0x80
 
 /*
  * Standard NAND flash commands
@@ -106,6 +103,8 @@ extern int nand_write_raw(struct mtd_info *mtd, loff_t to, size_t len,
 #define NAND_CMD_STATUS_RESET	0x7f
 #define NAND_CMD_STATUS_CLEAR	0xff
 
+#define NAND_CMD_NONE		-1
+
 /* Status bits */
 #define NAND_STATUS_FAIL	0x01
 #define NAND_STATUS_FAIL_N1	0x02
@@ -263,7 +262,8 @@ struct nand_ecc_ctrl {
  * @select_chip:	[REPLACEABLE] select chip nr
  * @block_bad:		[REPLACEABLE] check, if the block is bad
  * @block_markbad:	[REPLACEABLE] mark the block bad
- * @hwcontrol:		[BOARDSPECIFIC] hardwarespecific function for accesing control-lines
+ * @cmd_ctrl:		[BOARDSPECIFIC] hardwarespecific funtion for controlling
+ *			ALE/CLE/nCE. Also used to write command and address
  * @dev_ready:		[BOARDSPECIFIC] hardwarespecific function for accesing device ready/busy line
  *			If set to NULL no access to ready/busy is available and the ready/busy information
  *			is read from the chip status register
@@ -317,7 +317,8 @@ struct nand_chip {
 	void		(*select_chip)(struct mtd_info *mtd, int chip);
 	int		(*block_bad)(struct mtd_info *mtd, loff_t ofs, int getchip);
 	int		(*block_markbad)(struct mtd_info *mtd, loff_t ofs);
-	void		(*hwcontrol)(struct mtd_info *mtd, int cmd);
+	void		(*cmd_ctrl)(struct mtd_info *mtd, int dat,
+				    unsigned int ctrl);
 	int		(*dev_ready)(struct mtd_info *mtd);
 	void		(*cmdfunc)(struct mtd_info *mtd, unsigned command, int column, int page_addr);
 	int		(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this, int state);

commit 9223a456da8ed357bf7e0b128c853e2c8bd54614
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Tue May 23 17:21:03 2006 +0200

    [MTD] Remove read/write _ecc variants
    
    MTD clients are agnostic of FLASH which needs ECC suppport.
    Remove the functions and fixup the callers.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 6931376ed68d..8362b466df3a 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -36,6 +36,9 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from,
 			  size_t len, size_t ooblen);
 
 
+extern int nand_write_raw(struct mtd_info *mtd, loff_t to, size_t len,
+			  size_t *retlen, uint8_t *buf, uint8_t *oob);
+
 /* The maximum number of NAND chips in an array */
 #define NAND_MAX_CHIPS		8
 

commit 9a57d470fd4a77b9732fee97bed29c565c730af0
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Tue May 23 15:58:23 2006 +0200

    [MTD] NAND ECC hwctl function has no return value
    
    Fix the broken prototype
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 460525841a27..6931376ed68d 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -237,7 +237,7 @@ struct nand_ecc_ctrl {
 	int			steps;
 	int			size;
 	int			bytes;
-	int			(*hwctl)(struct mtd_info *mtd, int mode);
+	void			(*hwctl)(struct mtd_info *mtd, int mode);
 	int			(*calculate)(struct mtd_info *mtd,
 					     const uint8_t *dat,
 					     uint8_t *ecc_code);

commit 6dfc6d250d0b7ebaa6423c44dcd09fcfe68deabd
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Tue May 23 12:00:46 2006 +0200

    [MTD] NAND modularize ECC
    
    First step of modularizing ECC support.
    - Move ECC related functionality into a seperate embedded data structure
    - Get rid of the hardware dependend constants to simplify new ECC models
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 601c5c703a05..460525841a27 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -113,21 +113,12 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from,
 /*
  * Constants for ECC_MODES
  */
-
-/* No ECC. Usage is not recommended ! */
-#define NAND_ECC_NONE		0
-/* Software ECC 3 byte ECC per 256 Byte data */
-#define NAND_ECC_SOFT		1
-/* Hardware ECC 3 byte ECC per 256 Byte data */
-#define NAND_ECC_HW3_256	2
-/* Hardware ECC 3 byte ECC per 512 Byte data */
-#define NAND_ECC_HW3_512	3
-/* Hardware ECC 3 byte ECC per 512 Byte data */
-#define NAND_ECC_HW6_512	4
-/* Hardware ECC 8 byte ECC per 512 Byte data */
-#define NAND_ECC_HW8_512	6
-/* Hardware ECC 12 byte ECC per 2048 Byte data */
-#define NAND_ECC_HW12_2048	7
+typedef enum {
+	NAND_ECC_NONE,
+	NAND_ECC_SOFT,
+	NAND_ECC_HW,
+	NAND_ECC_HW_SYNDROME,
+} nand_ecc_modes_t;
 
 /*
  * Constants for Hardware ECC
@@ -230,6 +221,31 @@ struct nand_hw_control {
 	wait_queue_head_t wq;
 };
 
+/**
+ * struct nand_ecc_ctrl - Control structure for ecc
+ * @mode:	ecc mode
+ * @steps:	number of ecc steps per page
+ * @size:	data bytes per ecc step
+ * @bytes:	ecc bytes per step
+ * @hwctl:	function to control hardware ecc generator. Must only
+ *		be provided if an hardware ECC is available
+ * @calculate:	function for ecc calculation or readback from ecc hardware
+ * @correct:	function for ecc correction, matching to ecc generator (sw/hw)
+ */
+struct nand_ecc_ctrl {
+	nand_ecc_modes_t	mode;
+	int			steps;
+	int			size;
+	int			bytes;
+	int			(*hwctl)(struct mtd_info *mtd, int mode);
+	int			(*calculate)(struct mtd_info *mtd,
+					     const uint8_t *dat,
+					     uint8_t *ecc_code);
+	int			(*correct)(struct mtd_info *mtd, uint8_t *dat,
+					   uint8_t *read_ecc,
+					   uint8_t *calc_ecc);
+};
+
 /**
  * struct nand_chip - NAND Private Flash Chip Data
  * @IO_ADDR_R:		[BOARDSPECIFIC] address to read the 8 I/O lines of the flash device
@@ -250,16 +266,9 @@ struct nand_hw_control {
  *			is read from the chip status register
  * @cmdfunc:		[REPLACEABLE] hardwarespecific function for writing commands to the chip
  * @waitfunc:		[REPLACEABLE] hardwarespecific function for wait on ready
- * @calculate_ecc:	[REPLACEABLE] function for ecc calculation or readback from ecc hardware
- * @correct_data:	[REPLACEABLE] function for ecc correction, matching to ecc generator (sw/hw)
- * @enable_hwecc:	[BOARDSPECIFIC] function to enable (reset) hardware ecc generator. Must only
- *			be provided if a hardware ECC is available
+ * @ecc:		[BOARDSPECIFIC] ecc control ctructure
  * @erase_cmd:		[INTERN] erase command write function, selectable due to AND support
  * @scan_bbt:		[REPLACEABLE] function to scan bad block table
- * @eccmode:		[BOARDSPECIFIC] mode of ecc, see defines
- * @eccsize:		[INTERN] databytes used per ecc-calculation
- * @eccbytes:		[INTERN] number of ecc bytes per ecc-calculation step
- * @eccsteps:		[INTERN] number of ecc calculation steps per page
  * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transfering data from array to read regs (tR)
  * @wq:			[INTERN] wait queue to sleep on if a NAND operation is in progress
  * @state:		[INTERN] the current state of the NAND device
@@ -309,15 +318,9 @@ struct nand_chip {
 	int		(*dev_ready)(struct mtd_info *mtd);
 	void		(*cmdfunc)(struct mtd_info *mtd, unsigned command, int column, int page_addr);
 	int		(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this, int state);
-	int		(*calculate_ecc)(struct mtd_info *mtd, const uint8_t *dat, uint8_t *ecc_code);
-	int		(*correct_data)(struct mtd_info *mtd, uint8_t *dat, uint8_t *read_ecc, uint8_t *calc_ecc);
-	void		(*enable_hwecc)(struct mtd_info *mtd, int mode);
 	void		(*erase_cmd)(struct mtd_info *mtd, int page);
 	int		(*scan_bbt)(struct mtd_info *mtd);
-	int		eccmode;
-	int		eccsize;
-	int		eccbytes;
-	int		eccsteps;
+	struct nand_ecc_ctrl ecc;
 	int		chip_delay;
 	wait_queue_head_t wq;
 	nand_state_t	state;

commit 58dd8f2bfdcad1b219a4a92a2aadd8ea8c819f79
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Tue May 23 11:52:35 2006 +0200

    [MTD] NAND consolidate data types
    
    The NAND driver used a mix of unsigned char, u_char amd uint8_t
    data types. Consolidate to uint8_t usage
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 014ceefbec0e..601c5c703a05 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -294,14 +294,14 @@ struct nand_chip {
 	void  __iomem	*IO_ADDR_R;
 	void  __iomem	*IO_ADDR_W;
 
-	u_char		(*read_byte)(struct mtd_info *mtd);
-	void		(*write_byte)(struct mtd_info *mtd, u_char byte);
+	uint8_t		(*read_byte)(struct mtd_info *mtd);
+	void		(*write_byte)(struct mtd_info *mtd, uint8_t byte);
 	u16		(*read_word)(struct mtd_info *mtd);
 	void		(*write_word)(struct mtd_info *mtd, u16 word);
 
-	void		(*write_buf)(struct mtd_info *mtd, const u_char *buf, int len);
-	void		(*read_buf)(struct mtd_info *mtd, u_char *buf, int len);
-	int		(*verify_buf)(struct mtd_info *mtd, const u_char *buf, int len);
+	void		(*write_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
+	void		(*read_buf)(struct mtd_info *mtd, uint8_t *buf, int len);
+	int		(*verify_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
 	void		(*select_chip)(struct mtd_info *mtd, int chip);
 	int		(*block_bad)(struct mtd_info *mtd, loff_t ofs, int getchip);
 	int		(*block_markbad)(struct mtd_info *mtd, loff_t ofs);
@@ -309,8 +309,8 @@ struct nand_chip {
 	int		(*dev_ready)(struct mtd_info *mtd);
 	void		(*cmdfunc)(struct mtd_info *mtd, unsigned command, int column, int page_addr);
 	int		(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this, int state);
-	int		(*calculate_ecc)(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code);
-	int		(*correct_data)(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc);
+	int		(*calculate_ecc)(struct mtd_info *mtd, const uint8_t *dat, uint8_t *ecc_code);
+	int		(*correct_data)(struct mtd_info *mtd, uint8_t *dat, uint8_t *read_ecc, uint8_t *calc_ecc);
 	void		(*enable_hwecc)(struct mtd_info *mtd, int mode);
 	void		(*erase_cmd)(struct mtd_info *mtd, int page);
 	int		(*scan_bbt)(struct mtd_info *mtd);
@@ -325,10 +325,10 @@ struct nand_chip {
 	int		phys_erase_shift;
 	int		bbt_erase_shift;
 	int		chip_shift;
-	u_char		*data_buf;
-	u_char		*oob_buf;
+	uint8_t		*data_buf;
+	uint8_t		*oob_buf;
 	int		oobdirty;
-	u_char		*data_poi;
+	uint8_t		*data_poi;
 	unsigned int	options;
 	int		badblockpos;
 	int		numchips;
@@ -466,7 +466,7 @@ extern int nand_default_bbt (struct mtd_info *mtd);
 extern int nand_isbad_bbt (struct mtd_info *mtd, loff_t offs, int allowbbt);
 extern int nand_erase_nand (struct mtd_info *mtd, struct erase_info *instr, int allowbbt);
 extern int nand_do_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
-			     size_t * retlen, u_char * buf, u_char * oob_buf,
+			     size_t * retlen, uint8_t * buf, uint8_t * oob_buf,
 			     struct nand_oobinfo *oobsel, int flags);
 
 /*

commit 2c0a2bed9276ebbec5794edc07f66e21e9a1735c
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Tue May 23 11:50:56 2006 +0200

    [MTD] NAND whitespace and formatting cleanup
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 05c6ecc07036..014ceefbec0e 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -11,47 +11,11 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  *
- *  Info:
- *   Contains standard defines and IDs for NAND flash devices
+ * Info:
+ *	Contains standard defines and IDs for NAND flash devices
  *
- *  Changelog:
- *   01-31-2000 DMW     Created
- *   09-18-2000 SJH     Moved structure out of the Disk-On-Chip drivers
- *			so it can be used by other NAND flash device
- *			drivers. I also changed the copyright since none
- *			of the original contents of this file are specific
- *			to DoC devices. David can whack me with a baseball
- *			bat later if I did something naughty.
- *   10-11-2000 SJH     Added private NAND flash structure for driver
- *   10-24-2000 SJH     Added prototype for 'nand_scan' function
- *   10-29-2001 TG	changed nand_chip structure to support
- *			hardwarespecific function for accessing control lines
- *   02-21-2002 TG	added support for different read/write adress and
- *			ready/busy line access function
- *   02-26-2002 TG	added chip_delay to nand_chip structure to optimize
- *			command delay times for different chips
- *   04-28-2002 TG	OOB config defines moved from nand.c to avoid duplicate
- *			defines in jffs2/wbuf.c
- *   08-07-2002 TG	forced bad block location to byte 5 of OOB, even if
- *			CONFIG_MTD_NAND_ECC_JFFS2 is not set
- *   08-10-2002 TG	extensions to nand_chip structure to support HW-ECC
- *
- *   08-29-2002 tglx 	nand_chip structure: data_poi for selecting
- *			internal / fs-driver buffer
- *			support for 6byte/512byte hardware ECC
- *			read_ecc, write_ecc extended for different oob-layout
- *			oob layout selections: NAND_NONE_OOB, NAND_JFFS2_OOB,
- *			NAND_YAFFS_OOB
- *  11-25-2002 tglx	Added Manufacturer code FUJITSU, NATIONAL
- *			Split manufacturer and device ID structures
- *
- *  02-08-2004 tglx 	added option field to nand structure for chip anomalities
- *  05-25-2004 tglx 	added bad block table support, ST-MICRO manufacturer id
- *			update of nand_chip structure description
- *  01-17-2005 dmarlin	added extended commands for AG-AND device and added option
- * 			for BBT_AUTO_REFRESH.
- *  01-20-2005 dmarlin	added optional pointer to hardware specific callback for
- *			extra error status checks.
+ * Changelog:
+ *	See git changelog.
  */
 #ifndef __LINUX_MTD_NAND_H
 #define __LINUX_MTD_NAND_H
@@ -68,7 +32,8 @@ extern int nand_scan (struct mtd_info *mtd, int max_chips);
 extern void nand_release (struct mtd_info *mtd);
 
 /* Read raw data from the device without ECC */
-extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_t len, size_t ooblen);
+extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from,
+			  size_t len, size_t ooblen);
 
 
 /* The maximum number of NAND chips in an array */
@@ -84,7 +49,7 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_
  * Constants for hardware specific CLE/ALE/NCE function
 */
 /* Select the chip by setting nCE to low */
-#define NAND_CTL_SETNCE 	1
+#define NAND_CTL_SETNCE		1
 /* Deselect the chip by setting nCE to high */
 #define NAND_CTL_CLRNCE		2
 /* Select the command latch by setting CLE to high */
@@ -285,19 +250,19 @@ struct nand_hw_control {
  *			is read from the chip status register
  * @cmdfunc:		[REPLACEABLE] hardwarespecific function for writing commands to the chip
  * @waitfunc:		[REPLACEABLE] hardwarespecific function for wait on ready
- * @calculate_ecc: 	[REPLACEABLE] function for ecc calculation or readback from ecc hardware
+ * @calculate_ecc:	[REPLACEABLE] function for ecc calculation or readback from ecc hardware
  * @correct_data:	[REPLACEABLE] function for ecc correction, matching to ecc generator (sw/hw)
  * @enable_hwecc:	[BOARDSPECIFIC] function to enable (reset) hardware ecc generator. Must only
  *			be provided if a hardware ECC is available
  * @erase_cmd:		[INTERN] erase command write function, selectable due to AND support
  * @scan_bbt:		[REPLACEABLE] function to scan bad block table
  * @eccmode:		[BOARDSPECIFIC] mode of ecc, see defines
- * @eccsize: 		[INTERN] databytes used per ecc-calculation
- * @eccbytes: 		[INTERN] number of ecc bytes per ecc-calculation step
+ * @eccsize:		[INTERN] databytes used per ecc-calculation
+ * @eccbytes:		[INTERN] number of ecc bytes per ecc-calculation step
  * @eccsteps:		[INTERN] number of ecc calculation steps per page
  * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transfering data from array to read regs (tR)
  * @wq:			[INTERN] wait queue to sleep on if a NAND operation is in progress
- * @state: 		[INTERN] the current state of the NAND device
+ * @state:		[INTERN] the current state of the NAND device
  * @page_shift:		[INTERN] number of address bits in a page (column address bits)
  * @phys_erase_shift:	[INTERN] number of address bits in a physical eraseblock
  * @bbt_erase_shift:	[INTERN] number of address bits in a bbt entry
@@ -327,7 +292,7 @@ struct nand_hw_control {
 
 struct nand_chip {
 	void  __iomem	*IO_ADDR_R;
-	void  __iomem 	*IO_ADDR_W;
+	void  __iomem	*IO_ADDR_W;
 
 	u_char		(*read_byte)(struct mtd_info *mtd);
 	void		(*write_byte)(struct mtd_info *mtd, u_char byte);
@@ -340,12 +305,12 @@ struct nand_chip {
 	void		(*select_chip)(struct mtd_info *mtd, int chip);
 	int		(*block_bad)(struct mtd_info *mtd, loff_t ofs, int getchip);
 	int		(*block_markbad)(struct mtd_info *mtd, loff_t ofs);
-	void 		(*hwcontrol)(struct mtd_info *mtd, int cmd);
-	int  		(*dev_ready)(struct mtd_info *mtd);
-	void 		(*cmdfunc)(struct mtd_info *mtd, unsigned command, int column, int page_addr);
-	int 		(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this, int state);
+	void		(*hwcontrol)(struct mtd_info *mtd, int cmd);
+	int		(*dev_ready)(struct mtd_info *mtd);
+	void		(*cmdfunc)(struct mtd_info *mtd, unsigned command, int column, int page_addr);
+	int		(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this, int state);
 	int		(*calculate_ecc)(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code);
-	int 		(*correct_data)(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc);
+	int		(*correct_data)(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc);
 	void		(*enable_hwecc)(struct mtd_info *mtd, int mode);
 	void		(*erase_cmd)(struct mtd_info *mtd, int page);
 	int		(*scan_bbt)(struct mtd_info *mtd);
@@ -353,14 +318,14 @@ struct nand_chip {
 	int		eccsize;
 	int		eccbytes;
 	int		eccsteps;
-	int 		chip_delay;
+	int		chip_delay;
 	wait_queue_head_t wq;
-	nand_state_t 	state;
-	int 		page_shift;
+	nand_state_t	state;
+	int		page_shift;
 	int		phys_erase_shift;
 	int		bbt_erase_shift;
 	int		chip_shift;
-	u_char 		*data_buf;
+	u_char		*data_buf;
 	u_char		*oob_buf;
 	int		oobdirty;
 	u_char		*data_poi;
@@ -389,19 +354,19 @@ struct nand_chip {
 #define NAND_MFR_NATIONAL	0x8f
 #define NAND_MFR_RENESAS	0x07
 #define NAND_MFR_STMICRO	0x20
-#define NAND_MFR_HYNIX          0xad
+#define NAND_MFR_HYNIX		0xad
 
 /**
  * struct nand_flash_dev - NAND Flash Device ID Structure
  *
- * @name:  	Identify the device type
- * @id:   	device ID code
- * @pagesize:  	Pagesize in bytes. Either 256 or 512 or 0
+ * @name:	Identify the device type
+ * @id:		device ID code
+ * @pagesize:	Pagesize in bytes. Either 256 or 512 or 0
  *		If the pagesize is 0, then the real pagesize
  *		and the eraseize are determined from the
  *		extended id bytes in the chip
- * @erasesize: 	Size of an erase block in the flash device.
- * @chipsize:  	Total chipsize in Mega Bytes
+ * @erasesize:	Size of an erase block in the flash device.
+ * @chipsize:	Total chipsize in Mega Bytes
  * @options:	Bitfield to store chip relevant options
  */
 struct nand_flash_dev {
@@ -416,7 +381,7 @@ struct nand_flash_dev {
 /**
  * struct nand_manufacturers - NAND Flash Manufacturer ID Structure
  * @name:	Manufacturer name
- * @id: 	manufacturer ID code of device.
+ * @id:		manufacturer ID code of device.
 */
 struct nand_manufacturers {
 	int id;
@@ -456,7 +421,7 @@ struct nand_bbt_descr {
 	int	veroffs;
 	uint8_t	version[NAND_MAX_CHIPS];
 	int	len;
-	int 	maxblocks;
+	int	maxblocks;
 	int	reserved_block_code;
 	uint8_t	*pattern;
 };
@@ -501,8 +466,8 @@ extern int nand_default_bbt (struct mtd_info *mtd);
 extern int nand_isbad_bbt (struct mtd_info *mtd, loff_t offs, int allowbbt);
 extern int nand_erase_nand (struct mtd_info *mtd, struct erase_info *instr, int allowbbt);
 extern int nand_do_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
-                             size_t * retlen, u_char * buf, u_char * oob_buf,
-                             struct nand_oobinfo *oobsel, int flags);
+			     size_t * retlen, u_char * buf, u_char * oob_buf,
+			     struct nand_oobinfo *oobsel, int flags);
 
 /*
 * Constants for oob configuration
@@ -526,7 +491,7 @@ struct platform_nand_chip {
 	int			chip_offset;
 	int			nr_partitions;
 	struct mtd_partition	*partitions;
-	int 			chip_delay;
+	int			chip_delay;
 	unsigned int		options;
 	void			*priv;
 };
@@ -542,8 +507,8 @@ struct platform_nand_chip {
  * All fields are optional and depend on the hardware driver requirements
  */
 struct platform_nand_ctrl {
-	void 		(*hwcontrol)(struct mtd_info *mtd, int cmd);
-	int  		(*dev_ready)(struct mtd_info *mtd);
+	void		(*hwcontrol)(struct mtd_info *mtd, int cmd);
+	int		(*dev_ready)(struct mtd_info *mtd);
 	void		(*select_chip)(struct mtd_info *mtd, int chip);
 	void		*priv;
 };

commit 41796c2ea9b74cdf3bc2c368193d15b8ae8950ca
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Tue May 23 11:38:59 2006 +0200

    [MTD] Add platform support for NAND
    
    Add the data structures necessary to provide platform device support
    for NAND
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index b8792be3c4e0..05c6ecc07036 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -510,4 +510,51 @@ extern int nand_do_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
 #define NAND_SMALL_BADBLOCK_POS		5
 #define NAND_LARGE_BADBLOCK_POS		0
 
+/**
+ * struct platform_nand_chip - chip level device structure
+ *
+ * @nr_chips:		max. number of chips to scan for
+ * @chip_offs:		chip number offset
+ * @nr_partitions:	number of partitions pointed to be partitoons (or zero)
+ * @partitions:		mtd partition list
+ * @chip_delay:		R/B delay value in us
+ * @options:		Option flags, e.g. 16bit buswidth
+ * @priv:		hardware controller specific settings
+ */
+struct platform_nand_chip {
+	int			nr_chips;
+	int			chip_offset;
+	int			nr_partitions;
+	struct mtd_partition	*partitions;
+	int 			chip_delay;
+	unsigned int		options;
+	void			*priv;
+};
+
+/**
+ * struct platform_nand_ctrl - controller level device structure
+ *
+ * @hwcontrol:		platform specific hardware control structure
+ * @dev_ready:		platform specific function to read ready/busy pin
+ * @select_chip:	platform specific chip select function
+ * @priv_data:		private data to transport driver specific settings
+ *
+ * All fields are optional and depend on the hardware driver requirements
+ */
+struct platform_nand_ctrl {
+	void 		(*hwcontrol)(struct mtd_info *mtd, int cmd);
+	int  		(*dev_ready)(struct mtd_info *mtd);
+	void		(*select_chip)(struct mtd_info *mtd, int chip);
+	void		*priv;
+};
+
+/* Some helpers to access the data structures */
+static inline
+struct platform_nand_chip *get_platform_nandchip(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	return chip->priv;
+}
+
 #endif /* __LINUX_MTD_NAND_H */

commit a36ed2995c56d4f858ecb524a78837473e7115ae
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Tue May 23 11:37:03 2006 +0200

    [MTD] Simplify NAND locking
    
    Replace the chip lock by a the controller lock. For simple drivers a
    dummy controller structure is created by the scan code.
    This simplifies the locking algorithm in nand_get/release_chip().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index da5e67b3fc70..b8792be3c4e0 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -227,6 +227,8 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_
 #define NAND_SKIP_BBTSCAN	0x00040000
 
 /* Options set by nand scan */
+/* Nand scan has allocated controller struct */
+#define NAND_CONTROLLER_ALLOC	0x20000000
 /* Nand scan has allocated oob_buf */
 #define NAND_OOBBUF_ALLOC	0x40000000
 /* Nand scan has allocated data_buf */
@@ -294,7 +296,6 @@ struct nand_hw_control {
  * @eccbytes: 		[INTERN] number of ecc bytes per ecc-calculation step
  * @eccsteps:		[INTERN] number of ecc calculation steps per page
  * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transfering data from array to read regs (tR)
- * @chip_lock:		[INTERN] spinlock used to protect access to this structure and the chip
  * @wq:			[INTERN] wait queue to sleep on if a NAND operation is in progress
  * @state: 		[INTERN] the current state of the NAND device
  * @page_shift:		[INTERN] number of address bits in a page (column address bits)
@@ -317,7 +318,8 @@ struct nand_hw_control {
  * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash lookup
  * @bbt_md:		[REPLACEABLE] bad block table mirror descriptor
  * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for initial bad block scan
- * @controller:		[OPTIONAL] a pointer to a hardware controller structure which is shared among multiple independend devices
+ * @controller:		[REPLACEABLE] a pointer to a hardware controller structure
+ *			which is shared among multiple independend devices
  * @priv:		[OPTIONAL] pointer to private chip date
  * @errstat:		[OPTIONAL] hardware specific function to perform additional error status checks
  *			(determine if errors are correctable)
@@ -352,7 +354,6 @@ struct nand_chip {
 	int		eccbytes;
 	int		eccsteps;
 	int 		chip_delay;
-	spinlock_t	chip_lock;
 	wait_queue_head_t wq;
 	nand_state_t 	state;
 	int 		page_shift;

commit 62c4f0a2d5a188f73a94f2cb8ea0dba3e7cf0a7f
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 26 12:56:16 2006 +0100

    Don't include linux/config.h from anywhere else in include/
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index da5e67b3fc70..4b99d285803f 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -56,7 +56,6 @@
 #ifndef __LINUX_MTD_NAND_H
 #define __LINUX_MTD_NAND_H
 
-#include <linux/config.h>
 #include <linux/wait.h>
 #include <linux/spinlock.h>
 #include <linux/mtd/mtd.h>

commit 61ecfa8777d0bc8e33dc0e5c2cca9b3247da2d37
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Nov 7 11:15:31 2005 +0000

    [MTD] includes: Clean up trailing white spaces
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 2d36413b2f94..da5e67b3fc70 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -24,7 +24,7 @@
  *			bat later if I did something naughty.
  *   10-11-2000 SJH     Added private NAND flash structure for driver
  *   10-24-2000 SJH     Added prototype for 'nand_scan' function
- *   10-29-2001 TG	changed nand_chip structure to support 
+ *   10-29-2001 TG	changed nand_chip structure to support
  *			hardwarespecific function for accessing control lines
  *   02-21-2002 TG	added support for different read/write adress and
  *			ready/busy line access function
@@ -36,21 +36,21 @@
  *			CONFIG_MTD_NAND_ECC_JFFS2 is not set
  *   08-10-2002 TG	extensions to nand_chip structure to support HW-ECC
  *
- *   08-29-2002 tglx 	nand_chip structure: data_poi for selecting 
+ *   08-29-2002 tglx 	nand_chip structure: data_poi for selecting
  *			internal / fs-driver buffer
  *			support for 6byte/512byte hardware ECC
  *			read_ecc, write_ecc extended for different oob-layout
  *			oob layout selections: NAND_NONE_OOB, NAND_JFFS2_OOB,
  *			NAND_YAFFS_OOB
  *  11-25-2002 tglx	Added Manufacturer code FUJITSU, NATIONAL
- *			Split manufacturer and device ID structures 
+ *			Split manufacturer and device ID structures
  *
  *  02-08-2004 tglx 	added option field to nand structure for chip anomalities
  *  05-25-2004 tglx 	added bad block table support, ST-MICRO manufacturer id
  *			update of nand_chip structure description
- *  01-17-2005 dmarlin	added extended commands for AG-AND device and added option 
+ *  01-17-2005 dmarlin	added extended commands for AG-AND device and added option
  * 			for BBT_AUTO_REFRESH.
- *  01-20-2005 dmarlin	added optional pointer to hardware specific callback for 
+ *  01-20-2005 dmarlin	added optional pointer to hardware specific callback for
  *			extra error status checks.
  */
 #ifndef __LINUX_MTD_NAND_H
@@ -120,8 +120,8 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_
 #define NAND_CMD_CACHEDPROG	0x15
 
 /* Extended commands for AG-AND device */
-/* 
- * Note: the command for NAND_CMD_DEPLETE1 is really 0x00 but 
+/*
+ * Note: the command for NAND_CMD_DEPLETE1 is really 0x00 but
  *       there is no way to distinguish that from NAND_CMD_READ0
  *       until the remaining sequence of commands has been completed
  *       so add a high order bit and mask it off in the command.
@@ -145,7 +145,7 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_
 #define NAND_STATUS_READY	0x40
 #define NAND_STATUS_WP		0x80
 
-/* 
+/*
  * Constants for ECC_MODES
  */
 
@@ -191,12 +191,12 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_
 #define NAND_CACHEPRG		0x00000008
 /* Chip has copy back function */
 #define NAND_COPYBACK		0x00000010
-/* AND Chip which has 4 banks and a confusing page / block 
+/* AND Chip which has 4 banks and a confusing page / block
  * assignment. See Renesas datasheet for further information */
 #define NAND_IS_AND		0x00000020
 /* Chip has a array of 4 pages which can be read without
  * additional ready /busy waits */
-#define NAND_4PAGE_ARRAY	0x00000040 
+#define NAND_4PAGE_ARRAY	0x00000040
 /* Chip requires that BBT is periodically rewritten to prevent
  * bits from adjacent blocks from 'leaking' in altering data.
  * This happens with the Renesas AG-AND chips, possibly others.  */
@@ -219,8 +219,8 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_
 /* Use a flash based bad block table. This option is passed to the
  * default bad block table function. */
 #define NAND_USE_FLASH_BBT	0x00010000
-/* The hw ecc generator provides a syndrome instead a ecc value on read 
- * This can only work if we have the ecc bytes directly behind the 
+/* The hw ecc generator provides a syndrome instead a ecc value on read
+ * This can only work if we have the ecc bytes directly behind the
  * data bytes. Applies for DOC and AG-AND Renesas HW Reed Solomon generators */
 #define NAND_HWECC_SYNDROME	0x00020000
 /* This option skips the bbt scan during initialization. */
@@ -252,7 +252,7 @@ struct nand_chip;
 
 /**
  * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independend devices
- * @lock:               protection lock  
+ * @lock:               protection lock
  * @active:		the mtd device which holds the controller currently
  * @wq:			wait queue to sleep on if a NAND operation is in progress
  *                      used instead of the per chip wait queue when a hw controller is available
@@ -265,8 +265,8 @@ struct nand_hw_control {
 
 /**
  * struct nand_chip - NAND Private Flash Chip Data
- * @IO_ADDR_R:		[BOARDSPECIFIC] address to read the 8 I/O lines of the flash device 
- * @IO_ADDR_W:		[BOARDSPECIFIC] address to write the 8 I/O lines of the flash device 
+ * @IO_ADDR_R:		[BOARDSPECIFIC] address to read the 8 I/O lines of the flash device
+ * @IO_ADDR_W:		[BOARDSPECIFIC] address to write the 8 I/O lines of the flash device
  * @read_byte:		[REPLACEABLE] read one byte from the chip
  * @write_byte:		[REPLACEABLE] write one byte to the chip
  * @read_word:		[REPLACEABLE] read one word from the chip
@@ -289,7 +289,7 @@ struct nand_hw_control {
  *			be provided if a hardware ECC is available
  * @erase_cmd:		[INTERN] erase command write function, selectable due to AND support
  * @scan_bbt:		[REPLACEABLE] function to scan bad block table
- * @eccmode:		[BOARDSPECIFIC] mode of ecc, see defines 
+ * @eccmode:		[BOARDSPECIFIC] mode of ecc, see defines
  * @eccsize: 		[INTERN] databytes used per ecc-calculation
  * @eccbytes: 		[INTERN] number of ecc bytes per ecc-calculation step
  * @eccsteps:		[INTERN] number of ecc calculation steps per page
@@ -301,7 +301,7 @@ struct nand_hw_control {
  * @phys_erase_shift:	[INTERN] number of address bits in a physical eraseblock
  * @bbt_erase_shift:	[INTERN] number of address bits in a bbt entry
  * @chip_shift:		[INTERN] number of address bits in one chip
- * @data_buf:		[INTERN] internal buffer for one page + oob 
+ * @data_buf:		[INTERN] internal buffer for one page + oob
  * @oob_buf:		[INTERN] oob buffer for one eraseblock
  * @oobdirty:		[INTERN] indicates that oob_buf must be reinitialized
  * @data_poi:		[INTERN] pointer to a data buffer
@@ -316,22 +316,22 @@ struct nand_hw_control {
  * @bbt:		[INTERN] bad block table pointer
  * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash lookup
  * @bbt_md:		[REPLACEABLE] bad block table mirror descriptor
- * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for initial bad block scan 
+ * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for initial bad block scan
  * @controller:		[OPTIONAL] a pointer to a hardware controller structure which is shared among multiple independend devices
  * @priv:		[OPTIONAL] pointer to private chip date
- * @errstat:		[OPTIONAL] hardware specific function to perform additional error status checks 
+ * @errstat:		[OPTIONAL] hardware specific function to perform additional error status checks
  *			(determine if errors are correctable)
  */
- 
+
 struct nand_chip {
 	void  __iomem	*IO_ADDR_R;
 	void  __iomem 	*IO_ADDR_W;
-	
+
 	u_char		(*read_byte)(struct mtd_info *mtd);
 	void		(*write_byte)(struct mtd_info *mtd, u_char byte);
 	u16		(*read_word)(struct mtd_info *mtd);
 	void		(*write_word)(struct mtd_info *mtd, u16 word);
-	
+
 	void		(*write_buf)(struct mtd_info *mtd, const u_char *buf, int len);
 	void		(*read_buf)(struct mtd_info *mtd, u_char *buf, int len);
 	int		(*verify_buf)(struct mtd_info *mtd, const u_char *buf, int len);
@@ -396,7 +396,7 @@ struct nand_chip {
  * @name:  	Identify the device type
  * @id:   	device ID code
  * @pagesize:  	Pagesize in bytes. Either 256 or 512 or 0
- *		If the pagesize is 0, then the real pagesize 
+ *		If the pagesize is 0, then the real pagesize
  *		and the eraseize are determined from the
  *		extended id bytes in the chip
  * @erasesize: 	Size of an erase block in the flash device.
@@ -425,7 +425,7 @@ struct nand_manufacturers {
 extern struct nand_flash_dev nand_flash_ids[];
 extern struct nand_manufacturers nand_manuf_ids[];
 
-/** 
+/**
  * struct nand_bbt_descr - bad block table descriptor
  * @options:	options for this descriptor
  * @pages:	the page(s) where we find the bbt, used with option BBT_ABSPAGE
@@ -436,14 +436,14 @@ extern struct nand_manufacturers nand_manuf_ids[];
  * @version:	version read from the bbt page during scan
  * @len:	length of the pattern, if 0 no pattern check is performed
  * @maxblocks:	maximum number of blocks to search for a bbt. This number of
- *		blocks is reserved at the end of the device where the tables are 
+ *		blocks is reserved at the end of the device where the tables are
  *		written.
  * @reserved_block_code: if non-0, this pattern denotes a reserved (rather than
  *              bad) block in the stored bbt
- * @pattern:	pattern to identify bad block table or factory marked good / 
+ * @pattern:	pattern to identify bad block table or factory marked good /
  *		bad blocks, can be NULL, if len = 0
  *
- * Descriptor for the bad block table marker and the descriptor for the 
+ * Descriptor for the bad block table marker and the descriptor for the
  * pattern which identifies good and bad blocks. The assumption is made
  * that the pattern and the version count are always located in the oob area
  * of the first block.

commit 962034f43937d02a1c18e802a6641aed0a266ac5
Author: Vitaly Wool <vwool@ru.mvista.com>
Date:   Thu Sep 15 14:58:53 2005 +0100

    [MTD] NAND: Add suspend/resume functionality
    
    The changes introduced allow to suspend/resume NAND flash.
    A new state (FL_PM_SUSPENDED) is introduced, as well as
    routines for mtd->suspend and mtd->resume to put the flash in
    suspended state from software pov.
    
    Signed-off-by: Vitaly Wool <vwool@ru.mvista.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 9b5b76217584..2d36413b2f94 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -5,7 +5,7 @@
  *                     Steven J. Hill <sjhill@realitydiluted.com>
  *		       Thomas Gleixner <tglx@linutronix.de>
  *
- * $Id: nand.h,v 1.73 2005/05/31 19:39:17 gleixner Exp $
+ * $Id: nand.h,v 1.74 2005/09/15 13:58:50 vwool Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -244,6 +244,7 @@ typedef enum {
 	FL_ERASING,
 	FL_SYNCING,
 	FL_CACHEDPRG,
+	FL_PM_SUSPENDED,
 } nand_state_t;
 
 /* Keep gcc happy */

commit 0dfc62465ef92c7ddcb1ba223bf062453566fd0f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 31 20:39:20 2005 +0100

    [MTD] NAND: Reorganize chip locking
    
    The code was wrong in several aspects. The locking order was
    inconsistent, the device aquire code did not reset a variable
    after a wakeup and the wakeup handling was not working for
    applications where multiple chips are sharing a single
    hardware controller.
    When a hardware controller is available the locking is now
    reduced to the hardware controller lock and the waitqueue is
    moved to the hardware controller structure in order to avoid
    a wake_up_all().
    
    The problem was pointed out by Ben Dooks, who also found the
    missing variable reset as main cause for his deadlock problem.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index bee78969cb21..9b5b76217584 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -5,7 +5,7 @@
  *                     Steven J. Hill <sjhill@realitydiluted.com>
  *		       Thomas Gleixner <tglx@linutronix.de>
  *
- * $Id: nand.h,v 1.71 2005/02/09 12:12:59 gleixner Exp $
+ * $Id: nand.h,v 1.73 2005/05/31 19:39:17 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -253,10 +253,13 @@ struct nand_chip;
  * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independend devices
  * @lock:               protection lock  
  * @active:		the mtd device which holds the controller currently
+ * @wq:			wait queue to sleep on if a NAND operation is in progress
+ *                      used instead of the per chip wait queue when a hw controller is available
  */
 struct nand_hw_control {
 	spinlock_t	 lock;
 	struct nand_chip *active;
+	wait_queue_head_t wq;
 };
 
 /**

commit f1f67a9874f1a4bba1adff6d694aa52e5f52ff1a
Author: Nicolas S. Dade <daden@symbol.com>
Date:   Tue May 24 01:46:34 2005 -0700

    [MTD] NAND: Add Hynix to manufacturer list
    
    Signed-off-by: Nicolas S. Dade <daden@symbol.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index cf25c7cfd0ba..bee78969cb21 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -384,6 +384,7 @@ struct nand_chip {
 #define NAND_MFR_NATIONAL	0x8f
 #define NAND_MFR_RENESAS	0x07
 #define NAND_MFR_STMICRO	0x20
+#define NAND_MFR_HYNIX          0xad
 
 /**
  * struct nand_flash_dev - NAND Flash Device ID Structure

commit 0040bf382c77414739c933e4d2ee35ff817d0b99
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Feb 9 12:20:00 2005 +0000

    [MTD] NAND: Skip bad block table scan on request
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index cf52f20c6de2..cf25c7cfd0ba 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -5,7 +5,7 @@
  *                     Steven J. Hill <sjhill@realitydiluted.com>
  *		       Thomas Gleixner <tglx@linutronix.de>
  *
- * $Id: nand.h,v 1.70 2005/01/24 03:07:42 dmarlin Exp $
+ * $Id: nand.h,v 1.71 2005/02/09 12:12:59 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -223,7 +223,8 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_
  * This can only work if we have the ecc bytes directly behind the 
  * data bytes. Applies for DOC and AG-AND Renesas HW Reed Solomon generators */
 #define NAND_HWECC_SYNDROME	0x00020000
-
+/* This option skips the bbt scan during initialization. */
+#define NAND_SKIP_BBTSCAN	0x00040000
 
 /* Options set by nand scan */
 /* Nand scan has allocated oob_buf */

commit 068e3c0a002c79a5e3cc7c42cb749c4bb126288c
Author: David A. Marlin <dmarlin@redhat.com>
Date:   Mon Jan 24 03:07:46 2005 +0000

    [MTD] NAND Add optional ECC status check callback
    
    Add optional hardware specific callback routine to perform extra error
    status checks on erase and write failures for devices with hardware ECC.
    
    Signed-off-by: David A. Marlin <dmarlin@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 0118128ae384..cf52f20c6de2 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -5,7 +5,7 @@
  *                     Steven J. Hill <sjhill@realitydiluted.com>
  *		       Thomas Gleixner <tglx@linutronix.de>
  *
- * $Id: nand.h,v 1.69 2005/01/17 18:29:18 dmarlin Exp $
+ * $Id: nand.h,v 1.70 2005/01/24 03:07:42 dmarlin Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -50,6 +50,8 @@
  *			update of nand_chip structure description
  *  01-17-2005 dmarlin	added extended commands for AG-AND device and added option 
  * 			for BBT_AUTO_REFRESH.
+ *  01-20-2005 dmarlin	added optional pointer to hardware specific callback for 
+ *			extra error status checks.
  */
 #ifndef __LINUX_MTD_NAND_H
 #define __LINUX_MTD_NAND_H
@@ -164,7 +166,7 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_
 
 /*
  * Constants for Hardware ECC
-*/
+ */
 /* Reset Hardware ECC for read */
 #define NAND_ECC_READ		0
 /* Reset Hardware ECC for write */
@@ -172,6 +174,10 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_
 /* Enable Hardware ECC before syndrom is read back from flash */
 #define NAND_ECC_READSYN	2
 
+/* Bit mask for flags passed to do_nand_read_ecc */
+#define NAND_GET_DEVICE		0x80
+
+
 /* Option constants for bizarre disfunctionality and real
 *  features
 */
@@ -308,6 +314,8 @@ struct nand_hw_control {
  * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for initial bad block scan 
  * @controller:		[OPTIONAL] a pointer to a hardware controller structure which is shared among multiple independend devices
  * @priv:		[OPTIONAL] pointer to private chip date
+ * @errstat:		[OPTIONAL] hardware specific function to perform additional error status checks 
+ *			(determine if errors are correctable)
  */
  
 struct nand_chip {
@@ -363,6 +371,7 @@ struct nand_chip {
 	struct nand_bbt_descr	*badblock_pattern;
 	struct nand_hw_control  *controller;
 	void		*priv;
+	int		(*errstat)(struct mtd_info *mtd, struct nand_chip *this, int state, int status, int page);
 };
 
 /*
@@ -484,6 +493,9 @@ extern int nand_update_bbt (struct mtd_info *mtd, loff_t offs);
 extern int nand_default_bbt (struct mtd_info *mtd);
 extern int nand_isbad_bbt (struct mtd_info *mtd, loff_t offs, int allowbbt);
 extern int nand_erase_nand (struct mtd_info *mtd, struct erase_info *instr, int allowbbt);
+extern int nand_do_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+                             size_t * retlen, u_char * buf, u_char * oob_buf,
+                             struct nand_oobinfo *oobsel, int flags);
 
 /*
 * Constants for oob configuration

commit 28a48de72b876af794853593cc1412119ada9efc
Author: David A. Marlin <dmarlin@redhat.com>
Date:   Mon Jan 17 18:29:21 2005 +0000

    [MTD] NAND extended commands, badb block table autorefresh
    
    Added extended commands for AG-AND device and added
    option for BBT_AUTO_REFRESH.
    
    Signed-off-by: David A. Marlin <dmarlin@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 9a19c65abd74..0118128ae384 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -5,7 +5,7 @@
  *                     Steven J. Hill <sjhill@realitydiluted.com>
  *		       Thomas Gleixner <tglx@linutronix.de>
  *
- * $Id: nand.h,v 1.68 2004/11/12 10:40:37 gleixner Exp $
+ * $Id: nand.h,v 1.69 2005/01/17 18:29:18 dmarlin Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -48,6 +48,8 @@
  *  02-08-2004 tglx 	added option field to nand structure for chip anomalities
  *  05-25-2004 tglx 	added bad block table support, ST-MICRO manufacturer id
  *			update of nand_chip structure description
+ *  01-17-2005 dmarlin	added extended commands for AG-AND device and added option 
+ * 			for BBT_AUTO_REFRESH.
  */
 #ifndef __LINUX_MTD_NAND_H
 #define __LINUX_MTD_NAND_H
@@ -115,6 +117,25 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_
 #define NAND_CMD_READSTART	0x30
 #define NAND_CMD_CACHEDPROG	0x15
 
+/* Extended commands for AG-AND device */
+/* 
+ * Note: the command for NAND_CMD_DEPLETE1 is really 0x00 but 
+ *       there is no way to distinguish that from NAND_CMD_READ0
+ *       until the remaining sequence of commands has been completed
+ *       so add a high order bit and mask it off in the command.
+ */
+#define NAND_CMD_DEPLETE1	0x100
+#define NAND_CMD_DEPLETE2	0x38
+#define NAND_CMD_STATUS_MULTI	0x71
+#define NAND_CMD_STATUS_ERROR	0x72
+/* multi-bank error status (banks 0-3) */
+#define NAND_CMD_STATUS_ERROR0	0x73
+#define NAND_CMD_STATUS_ERROR1	0x74
+#define NAND_CMD_STATUS_ERROR2	0x75
+#define NAND_CMD_STATUS_ERROR3	0x76
+#define NAND_CMD_STATUS_RESET	0x7f
+#define NAND_CMD_STATUS_CLEAR	0xff
+
 /* Status bits */
 #define NAND_STATUS_FAIL	0x01
 #define NAND_STATUS_FAIL_N1	0x02
@@ -170,6 +191,10 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_
 /* Chip has a array of 4 pages which can be read without
  * additional ready /busy waits */
 #define NAND_4PAGE_ARRAY	0x00000040 
+/* Chip requires that BBT is periodically rewritten to prevent
+ * bits from adjacent blocks from 'leaking' in altering data.
+ * This happens with the Renesas AG-AND chips, possibly others.  */
+#define BBT_AUTO_REFRESH	0x00000080
 
 /* Options valid for Samsung large page devices */
 #define NAND_SAMSUNG_LP_OPTIONS \

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
new file mode 100644
index 000000000000..9a19c65abd74
--- /dev/null
+++ b/include/linux/mtd/nand.h
@@ -0,0 +1,469 @@
+/*
+ *  linux/include/linux/mtd/nand.h
+ *
+ *  Copyright (c) 2000 David Woodhouse <dwmw2@mvhi.com>
+ *                     Steven J. Hill <sjhill@realitydiluted.com>
+ *		       Thomas Gleixner <tglx@linutronix.de>
+ *
+ * $Id: nand.h,v 1.68 2004/11/12 10:40:37 gleixner Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Info:
+ *   Contains standard defines and IDs for NAND flash devices
+ *
+ *  Changelog:
+ *   01-31-2000 DMW     Created
+ *   09-18-2000 SJH     Moved structure out of the Disk-On-Chip drivers
+ *			so it can be used by other NAND flash device
+ *			drivers. I also changed the copyright since none
+ *			of the original contents of this file are specific
+ *			to DoC devices. David can whack me with a baseball
+ *			bat later if I did something naughty.
+ *   10-11-2000 SJH     Added private NAND flash structure for driver
+ *   10-24-2000 SJH     Added prototype for 'nand_scan' function
+ *   10-29-2001 TG	changed nand_chip structure to support 
+ *			hardwarespecific function for accessing control lines
+ *   02-21-2002 TG	added support for different read/write adress and
+ *			ready/busy line access function
+ *   02-26-2002 TG	added chip_delay to nand_chip structure to optimize
+ *			command delay times for different chips
+ *   04-28-2002 TG	OOB config defines moved from nand.c to avoid duplicate
+ *			defines in jffs2/wbuf.c
+ *   08-07-2002 TG	forced bad block location to byte 5 of OOB, even if
+ *			CONFIG_MTD_NAND_ECC_JFFS2 is not set
+ *   08-10-2002 TG	extensions to nand_chip structure to support HW-ECC
+ *
+ *   08-29-2002 tglx 	nand_chip structure: data_poi for selecting 
+ *			internal / fs-driver buffer
+ *			support for 6byte/512byte hardware ECC
+ *			read_ecc, write_ecc extended for different oob-layout
+ *			oob layout selections: NAND_NONE_OOB, NAND_JFFS2_OOB,
+ *			NAND_YAFFS_OOB
+ *  11-25-2002 tglx	Added Manufacturer code FUJITSU, NATIONAL
+ *			Split manufacturer and device ID structures 
+ *
+ *  02-08-2004 tglx 	added option field to nand structure for chip anomalities
+ *  05-25-2004 tglx 	added bad block table support, ST-MICRO manufacturer id
+ *			update of nand_chip structure description
+ */
+#ifndef __LINUX_MTD_NAND_H
+#define __LINUX_MTD_NAND_H
+
+#include <linux/config.h>
+#include <linux/wait.h>
+#include <linux/spinlock.h>
+#include <linux/mtd/mtd.h>
+
+struct mtd_info;
+/* Scan and identify a NAND device */
+extern int nand_scan (struct mtd_info *mtd, int max_chips);
+/* Free resources held by the NAND device */
+extern void nand_release (struct mtd_info *mtd);
+
+/* Read raw data from the device without ECC */
+extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_t len, size_t ooblen);
+
+
+/* The maximum number of NAND chips in an array */
+#define NAND_MAX_CHIPS		8
+
+/* This constant declares the max. oobsize / page, which
+ * is supported now. If you add a chip with bigger oobsize/page
+ * adjust this accordingly.
+ */
+#define NAND_MAX_OOBSIZE	64
+
+/*
+ * Constants for hardware specific CLE/ALE/NCE function
+*/
+/* Select the chip by setting nCE to low */
+#define NAND_CTL_SETNCE 	1
+/* Deselect the chip by setting nCE to high */
+#define NAND_CTL_CLRNCE		2
+/* Select the command latch by setting CLE to high */
+#define NAND_CTL_SETCLE		3
+/* Deselect the command latch by setting CLE to low */
+#define NAND_CTL_CLRCLE		4
+/* Select the address latch by setting ALE to high */
+#define NAND_CTL_SETALE		5
+/* Deselect the address latch by setting ALE to low */
+#define NAND_CTL_CLRALE		6
+/* Set write protection by setting WP to high. Not used! */
+#define NAND_CTL_SETWP		7
+/* Clear write protection by setting WP to low. Not used! */
+#define NAND_CTL_CLRWP		8
+
+/*
+ * Standard NAND flash commands
+ */
+#define NAND_CMD_READ0		0
+#define NAND_CMD_READ1		1
+#define NAND_CMD_PAGEPROG	0x10
+#define NAND_CMD_READOOB	0x50
+#define NAND_CMD_ERASE1		0x60
+#define NAND_CMD_STATUS		0x70
+#define NAND_CMD_STATUS_MULTI	0x71
+#define NAND_CMD_SEQIN		0x80
+#define NAND_CMD_READID		0x90
+#define NAND_CMD_ERASE2		0xd0
+#define NAND_CMD_RESET		0xff
+
+/* Extended commands for large page devices */
+#define NAND_CMD_READSTART	0x30
+#define NAND_CMD_CACHEDPROG	0x15
+
+/* Status bits */
+#define NAND_STATUS_FAIL	0x01
+#define NAND_STATUS_FAIL_N1	0x02
+#define NAND_STATUS_TRUE_READY	0x20
+#define NAND_STATUS_READY	0x40
+#define NAND_STATUS_WP		0x80
+
+/* 
+ * Constants for ECC_MODES
+ */
+
+/* No ECC. Usage is not recommended ! */
+#define NAND_ECC_NONE		0
+/* Software ECC 3 byte ECC per 256 Byte data */
+#define NAND_ECC_SOFT		1
+/* Hardware ECC 3 byte ECC per 256 Byte data */
+#define NAND_ECC_HW3_256	2
+/* Hardware ECC 3 byte ECC per 512 Byte data */
+#define NAND_ECC_HW3_512	3
+/* Hardware ECC 3 byte ECC per 512 Byte data */
+#define NAND_ECC_HW6_512	4
+/* Hardware ECC 8 byte ECC per 512 Byte data */
+#define NAND_ECC_HW8_512	6
+/* Hardware ECC 12 byte ECC per 2048 Byte data */
+#define NAND_ECC_HW12_2048	7
+
+/*
+ * Constants for Hardware ECC
+*/
+/* Reset Hardware ECC for read */
+#define NAND_ECC_READ		0
+/* Reset Hardware ECC for write */
+#define NAND_ECC_WRITE		1
+/* Enable Hardware ECC before syndrom is read back from flash */
+#define NAND_ECC_READSYN	2
+
+/* Option constants for bizarre disfunctionality and real
+*  features
+*/
+/* Chip can not auto increment pages */
+#define NAND_NO_AUTOINCR	0x00000001
+/* Buswitdh is 16 bit */
+#define NAND_BUSWIDTH_16	0x00000002
+/* Device supports partial programming without padding */
+#define NAND_NO_PADDING		0x00000004
+/* Chip has cache program function */
+#define NAND_CACHEPRG		0x00000008
+/* Chip has copy back function */
+#define NAND_COPYBACK		0x00000010
+/* AND Chip which has 4 banks and a confusing page / block 
+ * assignment. See Renesas datasheet for further information */
+#define NAND_IS_AND		0x00000020
+/* Chip has a array of 4 pages which can be read without
+ * additional ready /busy waits */
+#define NAND_4PAGE_ARRAY	0x00000040 
+
+/* Options valid for Samsung large page devices */
+#define NAND_SAMSUNG_LP_OPTIONS \
+	(NAND_NO_PADDING | NAND_CACHEPRG | NAND_COPYBACK)
+
+/* Macros to identify the above */
+#define NAND_CANAUTOINCR(chip) (!(chip->options & NAND_NO_AUTOINCR))
+#define NAND_MUST_PAD(chip) (!(chip->options & NAND_NO_PADDING))
+#define NAND_HAS_CACHEPROG(chip) ((chip->options & NAND_CACHEPRG))
+#define NAND_HAS_COPYBACK(chip) ((chip->options & NAND_COPYBACK))
+
+/* Mask to zero out the chip options, which come from the id table */
+#define NAND_CHIPOPTIONS_MSK	(0x0000ffff & ~NAND_NO_AUTOINCR)
+
+/* Non chip related options */
+/* Use a flash based bad block table. This option is passed to the
+ * default bad block table function. */
+#define NAND_USE_FLASH_BBT	0x00010000
+/* The hw ecc generator provides a syndrome instead a ecc value on read 
+ * This can only work if we have the ecc bytes directly behind the 
+ * data bytes. Applies for DOC and AG-AND Renesas HW Reed Solomon generators */
+#define NAND_HWECC_SYNDROME	0x00020000
+
+
+/* Options set by nand scan */
+/* Nand scan has allocated oob_buf */
+#define NAND_OOBBUF_ALLOC	0x40000000
+/* Nand scan has allocated data_buf */
+#define NAND_DATABUF_ALLOC	0x80000000
+
+
+/*
+ * nand_state_t - chip states
+ * Enumeration for NAND flash chip state
+ */
+typedef enum {
+	FL_READY,
+	FL_READING,
+	FL_WRITING,
+	FL_ERASING,
+	FL_SYNCING,
+	FL_CACHEDPRG,
+} nand_state_t;
+
+/* Keep gcc happy */
+struct nand_chip;
+
+/**
+ * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independend devices
+ * @lock:               protection lock  
+ * @active:		the mtd device which holds the controller currently
+ */
+struct nand_hw_control {
+	spinlock_t	 lock;
+	struct nand_chip *active;
+};
+
+/**
+ * struct nand_chip - NAND Private Flash Chip Data
+ * @IO_ADDR_R:		[BOARDSPECIFIC] address to read the 8 I/O lines of the flash device 
+ * @IO_ADDR_W:		[BOARDSPECIFIC] address to write the 8 I/O lines of the flash device 
+ * @read_byte:		[REPLACEABLE] read one byte from the chip
+ * @write_byte:		[REPLACEABLE] write one byte to the chip
+ * @read_word:		[REPLACEABLE] read one word from the chip
+ * @write_word:		[REPLACEABLE] write one word to the chip
+ * @write_buf:		[REPLACEABLE] write data from the buffer to the chip
+ * @read_buf:		[REPLACEABLE] read data from the chip into the buffer
+ * @verify_buf:		[REPLACEABLE] verify buffer contents against the chip data
+ * @select_chip:	[REPLACEABLE] select chip nr
+ * @block_bad:		[REPLACEABLE] check, if the block is bad
+ * @block_markbad:	[REPLACEABLE] mark the block bad
+ * @hwcontrol:		[BOARDSPECIFIC] hardwarespecific function for accesing control-lines
+ * @dev_ready:		[BOARDSPECIFIC] hardwarespecific function for accesing device ready/busy line
+ *			If set to NULL no access to ready/busy is available and the ready/busy information
+ *			is read from the chip status register
+ * @cmdfunc:		[REPLACEABLE] hardwarespecific function for writing commands to the chip
+ * @waitfunc:		[REPLACEABLE] hardwarespecific function for wait on ready
+ * @calculate_ecc: 	[REPLACEABLE] function for ecc calculation or readback from ecc hardware
+ * @correct_data:	[REPLACEABLE] function for ecc correction, matching to ecc generator (sw/hw)
+ * @enable_hwecc:	[BOARDSPECIFIC] function to enable (reset) hardware ecc generator. Must only
+ *			be provided if a hardware ECC is available
+ * @erase_cmd:		[INTERN] erase command write function, selectable due to AND support
+ * @scan_bbt:		[REPLACEABLE] function to scan bad block table
+ * @eccmode:		[BOARDSPECIFIC] mode of ecc, see defines 
+ * @eccsize: 		[INTERN] databytes used per ecc-calculation
+ * @eccbytes: 		[INTERN] number of ecc bytes per ecc-calculation step
+ * @eccsteps:		[INTERN] number of ecc calculation steps per page
+ * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transfering data from array to read regs (tR)
+ * @chip_lock:		[INTERN] spinlock used to protect access to this structure and the chip
+ * @wq:			[INTERN] wait queue to sleep on if a NAND operation is in progress
+ * @state: 		[INTERN] the current state of the NAND device
+ * @page_shift:		[INTERN] number of address bits in a page (column address bits)
+ * @phys_erase_shift:	[INTERN] number of address bits in a physical eraseblock
+ * @bbt_erase_shift:	[INTERN] number of address bits in a bbt entry
+ * @chip_shift:		[INTERN] number of address bits in one chip
+ * @data_buf:		[INTERN] internal buffer for one page + oob 
+ * @oob_buf:		[INTERN] oob buffer for one eraseblock
+ * @oobdirty:		[INTERN] indicates that oob_buf must be reinitialized
+ * @data_poi:		[INTERN] pointer to a data buffer
+ * @options:		[BOARDSPECIFIC] various chip options. They can partly be set to inform nand_scan about
+ *			special functionality. See the defines for further explanation
+ * @badblockpos:	[INTERN] position of the bad block marker in the oob area
+ * @numchips:		[INTERN] number of physical chips
+ * @chipsize:		[INTERN] the size of one chip for multichip arrays
+ * @pagemask:		[INTERN] page number mask = number of (pages / chip) - 1
+ * @pagebuf:		[INTERN] holds the pagenumber which is currently in data_buf
+ * @autooob:		[REPLACEABLE] the default (auto)placement scheme
+ * @bbt:		[INTERN] bad block table pointer
+ * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash lookup
+ * @bbt_md:		[REPLACEABLE] bad block table mirror descriptor
+ * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for initial bad block scan 
+ * @controller:		[OPTIONAL] a pointer to a hardware controller structure which is shared among multiple independend devices
+ * @priv:		[OPTIONAL] pointer to private chip date
+ */
+ 
+struct nand_chip {
+	void  __iomem	*IO_ADDR_R;
+	void  __iomem 	*IO_ADDR_W;
+	
+	u_char		(*read_byte)(struct mtd_info *mtd);
+	void		(*write_byte)(struct mtd_info *mtd, u_char byte);
+	u16		(*read_word)(struct mtd_info *mtd);
+	void		(*write_word)(struct mtd_info *mtd, u16 word);
+	
+	void		(*write_buf)(struct mtd_info *mtd, const u_char *buf, int len);
+	void		(*read_buf)(struct mtd_info *mtd, u_char *buf, int len);
+	int		(*verify_buf)(struct mtd_info *mtd, const u_char *buf, int len);
+	void		(*select_chip)(struct mtd_info *mtd, int chip);
+	int		(*block_bad)(struct mtd_info *mtd, loff_t ofs, int getchip);
+	int		(*block_markbad)(struct mtd_info *mtd, loff_t ofs);
+	void 		(*hwcontrol)(struct mtd_info *mtd, int cmd);
+	int  		(*dev_ready)(struct mtd_info *mtd);
+	void 		(*cmdfunc)(struct mtd_info *mtd, unsigned command, int column, int page_addr);
+	int 		(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this, int state);
+	int		(*calculate_ecc)(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code);
+	int 		(*correct_data)(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc);
+	void		(*enable_hwecc)(struct mtd_info *mtd, int mode);
+	void		(*erase_cmd)(struct mtd_info *mtd, int page);
+	int		(*scan_bbt)(struct mtd_info *mtd);
+	int		eccmode;
+	int		eccsize;
+	int		eccbytes;
+	int		eccsteps;
+	int 		chip_delay;
+	spinlock_t	chip_lock;
+	wait_queue_head_t wq;
+	nand_state_t 	state;
+	int 		page_shift;
+	int		phys_erase_shift;
+	int		bbt_erase_shift;
+	int		chip_shift;
+	u_char 		*data_buf;
+	u_char		*oob_buf;
+	int		oobdirty;
+	u_char		*data_poi;
+	unsigned int	options;
+	int		badblockpos;
+	int		numchips;
+	unsigned long	chipsize;
+	int		pagemask;
+	int		pagebuf;
+	struct nand_oobinfo	*autooob;
+	uint8_t		*bbt;
+	struct nand_bbt_descr	*bbt_td;
+	struct nand_bbt_descr	*bbt_md;
+	struct nand_bbt_descr	*badblock_pattern;
+	struct nand_hw_control  *controller;
+	void		*priv;
+};
+
+/*
+ * NAND Flash Manufacturer ID Codes
+ */
+#define NAND_MFR_TOSHIBA	0x98
+#define NAND_MFR_SAMSUNG	0xec
+#define NAND_MFR_FUJITSU	0x04
+#define NAND_MFR_NATIONAL	0x8f
+#define NAND_MFR_RENESAS	0x07
+#define NAND_MFR_STMICRO	0x20
+
+/**
+ * struct nand_flash_dev - NAND Flash Device ID Structure
+ *
+ * @name:  	Identify the device type
+ * @id:   	device ID code
+ * @pagesize:  	Pagesize in bytes. Either 256 or 512 or 0
+ *		If the pagesize is 0, then the real pagesize 
+ *		and the eraseize are determined from the
+ *		extended id bytes in the chip
+ * @erasesize: 	Size of an erase block in the flash device.
+ * @chipsize:  	Total chipsize in Mega Bytes
+ * @options:	Bitfield to store chip relevant options
+ */
+struct nand_flash_dev {
+	char *name;
+	int id;
+	unsigned long pagesize;
+	unsigned long chipsize;
+	unsigned long erasesize;
+	unsigned long options;
+};
+
+/**
+ * struct nand_manufacturers - NAND Flash Manufacturer ID Structure
+ * @name:	Manufacturer name
+ * @id: 	manufacturer ID code of device.
+*/
+struct nand_manufacturers {
+	int id;
+	char * name;
+};
+
+extern struct nand_flash_dev nand_flash_ids[];
+extern struct nand_manufacturers nand_manuf_ids[];
+
+/** 
+ * struct nand_bbt_descr - bad block table descriptor
+ * @options:	options for this descriptor
+ * @pages:	the page(s) where we find the bbt, used with option BBT_ABSPAGE
+ *		when bbt is searched, then we store the found bbts pages here.
+ *		Its an array and supports up to 8 chips now
+ * @offs:	offset of the pattern in the oob area of the page
+ * @veroffs:	offset of the bbt version counter in the oob are of the page
+ * @version:	version read from the bbt page during scan
+ * @len:	length of the pattern, if 0 no pattern check is performed
+ * @maxblocks:	maximum number of blocks to search for a bbt. This number of
+ *		blocks is reserved at the end of the device where the tables are 
+ *		written.
+ * @reserved_block_code: if non-0, this pattern denotes a reserved (rather than
+ *              bad) block in the stored bbt
+ * @pattern:	pattern to identify bad block table or factory marked good / 
+ *		bad blocks, can be NULL, if len = 0
+ *
+ * Descriptor for the bad block table marker and the descriptor for the 
+ * pattern which identifies good and bad blocks. The assumption is made
+ * that the pattern and the version count are always located in the oob area
+ * of the first block.
+ */
+struct nand_bbt_descr {
+	int	options;
+	int	pages[NAND_MAX_CHIPS];
+	int	offs;
+	int	veroffs;
+	uint8_t	version[NAND_MAX_CHIPS];
+	int	len;
+	int 	maxblocks;
+	int	reserved_block_code;
+	uint8_t	*pattern;
+};
+
+/* Options for the bad block table descriptors */
+
+/* The number of bits used per block in the bbt on the device */
+#define NAND_BBT_NRBITS_MSK	0x0000000F
+#define NAND_BBT_1BIT		0x00000001
+#define NAND_BBT_2BIT		0x00000002
+#define NAND_BBT_4BIT		0x00000004
+#define NAND_BBT_8BIT		0x00000008
+/* The bad block table is in the last good block of the device */
+#define	NAND_BBT_LASTBLOCK	0x00000010
+/* The bbt is at the given page, else we must scan for the bbt */
+#define NAND_BBT_ABSPAGE	0x00000020
+/* The bbt is at the given page, else we must scan for the bbt */
+#define NAND_BBT_SEARCH		0x00000040
+/* bbt is stored per chip on multichip devices */
+#define NAND_BBT_PERCHIP	0x00000080
+/* bbt has a version counter at offset veroffs */
+#define NAND_BBT_VERSION	0x00000100
+/* Create a bbt if none axists */
+#define NAND_BBT_CREATE		0x00000200
+/* Search good / bad pattern through all pages of a block */
+#define NAND_BBT_SCANALLPAGES	0x00000400
+/* Scan block empty during good / bad block scan */
+#define NAND_BBT_SCANEMPTY	0x00000800
+/* Write bbt if neccecary */
+#define NAND_BBT_WRITE		0x00001000
+/* Read and write back block contents when writing bbt */
+#define NAND_BBT_SAVECONTENT	0x00002000
+/* Search good / bad pattern on the first and the second page */
+#define NAND_BBT_SCAN2NDPAGE	0x00004000
+
+/* The maximum number of blocks to scan for a bbt */
+#define NAND_BBT_SCAN_MAXBLOCKS	4
+
+extern int nand_scan_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd);
+extern int nand_update_bbt (struct mtd_info *mtd, loff_t offs);
+extern int nand_default_bbt (struct mtd_info *mtd);
+extern int nand_isbad_bbt (struct mtd_info *mtd, loff_t offs, int allowbbt);
+extern int nand_erase_nand (struct mtd_info *mtd, struct erase_info *instr, int allowbbt);
+
+/*
+* Constants for oob configuration
+*/
+#define NAND_SMALL_BADBLOCK_POS		5
+#define NAND_LARGE_BADBLOCK_POS		0
+
+#endif /* __LINUX_MTD_NAND_H */
