commit fd534e9b5fdcf9bab33c03cb3ade1a1ae5b23c20
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 23 11:14:39 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 102
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      51 franklin st fifth floor boston ma 02110 1301 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 50 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190523091649.499889647@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 01b990e4b228..b4fa92a6e44b 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -1,20 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Copyright © 2000-2010 David Woodhouse <dwmw2@infradead.org> et al.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
  */
 
 /* Overhauled routines for dealing with different mmap regions of flash */

commit ea739a287f4f16d6250bea779a1026ead79695f2
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Thu May 10 19:20:54 2018 +0100

    mtd: Fix comparison in map_word_andequal()
    
    Commit 9e343e87d2c4 ("mtd: cfi: convert inline functions to macros")
    changed map_word_andequal() into a macro, but also changed the right
    hand side of the comparison from val3 to val2.  Change it back to use
    val3 on the right hand side.
    
    Thankfully this did not cause a regression because all callers
    currently pass the same argument for val2 and val3.
    
    Fixes: 9e343e87d2c4 ("mtd: cfi: convert inline functions to macros")
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index b5b43f94f311..01b990e4b228 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -312,7 +312,7 @@ void map_destroy(struct mtd_info *mtd);
 ({									\
 	int i, ret = 1;							\
 	for (i = 0; i < map_words(map); i++) {				\
-		if (((val1).x[i] & (val2).x[i]) != (val2).x[i]) {	\
+		if (((val1).x[i] & (val2).x[i]) != (val3).x[i]) {	\
 			ret = 0;					\
 			break;						\
 		}							\

commit 9e343e87d2c4c707ef8fae2844864d4dde3a2d13
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Oct 11 15:54:10 2017 +0200

    mtd: cfi: convert inline functions to macros
    
    The map_word_() functions, dating back to linux-2.6.8, try to perform
    bitwise operations on a 'map_word' structure. This may have worked
    with compilers that were current then (gcc-3.4 or earlier), but end
    up being rather inefficient on any version I could try now (gcc-4.4 or
    higher). Specifically we hit a problem analyzed in gcc PR81715 where we
    fail to reuse the stack space for local variables.
    
    This can be seen immediately in the stack consumption for
    cfi_staa_erase_varsize() and other functions that (with CONFIG_KASAN)
    can be up to 2200 bytes. Changing the inline functions into macros brings
    this down to 1280 bytes.  Without KASAN, the same problem exists, but
    the stack consumption is lower to start with, my patch shrinks it from
    920 to 496 bytes on with arm-linux-gnueabi-gcc-5.4, and saves around
    1KB in .text size for cfi_cmdset_0020.c, as it avoids copying map_word
    structures for each call to one of these helpers.
    
    With the latest gcc-8 snapshot, the problem is fixed in upstream gcc,
    but nobody uses that yet, so we should still work around it in mainline
    kernels and probably backport the workaround to stable kernels as well.
    We had a couple of other functions that suffered from the same gcc bug,
    and all of those had a simpler workaround involving dummy variables
    in the inline function. Unfortunately that did not work here, the
    macro hack was the best I could come up with.
    
    It would also be helpful to have someone to a little performance testing
    on the patch, to see how much it helps in terms of CPU utilitzation.
    
    Link: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81715
    Cc: stable@vger.kernel.org
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 3aa56e3104bb..b5b43f94f311 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -270,75 +270,67 @@ void map_destroy(struct mtd_info *mtd);
 #define INVALIDATE_CACHED_RANGE(map, from, size) \
 	do { if (map->inval_cache) map->inval_cache(map, from, size); } while (0)
 
-
-static inline int map_word_equal(struct map_info *map, map_word val1, map_word val2)
-{
-	int i;
-
-	for (i = 0; i < map_words(map); i++) {
-		if (val1.x[i] != val2.x[i])
-			return 0;
-	}
-
-	return 1;
-}
-
-static inline map_word map_word_and(struct map_info *map, map_word val1, map_word val2)
-{
-	map_word r;
-	int i;
-
-	for (i = 0; i < map_words(map); i++)
-		r.x[i] = val1.x[i] & val2.x[i];
-
-	return r;
-}
-
-static inline map_word map_word_clr(struct map_info *map, map_word val1, map_word val2)
-{
-	map_word r;
-	int i;
-
-	for (i = 0; i < map_words(map); i++)
-		r.x[i] = val1.x[i] & ~val2.x[i];
-
-	return r;
-}
-
-static inline map_word map_word_or(struct map_info *map, map_word val1, map_word val2)
-{
-	map_word r;
-	int i;
-
-	for (i = 0; i < map_words(map); i++)
-		r.x[i] = val1.x[i] | val2.x[i];
-
-	return r;
-}
-
-static inline int map_word_andequal(struct map_info *map, map_word val1, map_word val2, map_word val3)
-{
-	int i;
-
-	for (i = 0; i < map_words(map); i++) {
-		if ((val1.x[i] & val2.x[i]) != val3.x[i])
-			return 0;
-	}
-
-	return 1;
-}
-
-static inline int map_word_bitsset(struct map_info *map, map_word val1, map_word val2)
-{
-	int i;
-
-	for (i = 0; i < map_words(map); i++) {
-		if (val1.x[i] & val2.x[i])
-			return 1;
-	}
-
-	return 0;
-}
+#define map_word_equal(map, val1, val2)					\
+({									\
+	int i, ret = 1;							\
+	for (i = 0; i < map_words(map); i++)				\
+		if ((val1).x[i] != (val2).x[i]) {			\
+			ret = 0;					\
+			break;						\
+		}							\
+	ret;								\
+})
+
+#define map_word_and(map, val1, val2)					\
+({									\
+	map_word r;							\
+	int i;								\
+	for (i = 0; i < map_words(map); i++)				\
+		r.x[i] = (val1).x[i] & (val2).x[i];			\
+	r;								\
+})
+
+#define map_word_clr(map, val1, val2)					\
+({									\
+	map_word r;							\
+	int i;								\
+	for (i = 0; i < map_words(map); i++)				\
+		r.x[i] = (val1).x[i] & ~(val2).x[i];			\
+	r;								\
+})
+
+#define map_word_or(map, val1, val2)					\
+({									\
+	map_word r;							\
+	int i;								\
+	for (i = 0; i < map_words(map); i++)				\
+		r.x[i] = (val1).x[i] | (val2).x[i];			\
+	r;								\
+})
+
+#define map_word_andequal(map, val1, val2, val3)			\
+({									\
+	int i, ret = 1;							\
+	for (i = 0; i < map_words(map); i++) {				\
+		if (((val1).x[i] & (val2).x[i]) != (val2).x[i]) {	\
+			ret = 0;					\
+			break;						\
+		}							\
+	}								\
+	ret;								\
+})
+
+#define map_word_bitsset(map, val1, val2)				\
+({									\
+	int i, ret = 0;							\
+	for (i = 0; i < map_words(map); i++) {				\
+		if ((val1).x[i] & (val2).x[i]) {			\
+			ret = 1;					\
+			break;						\
+		}							\
+	}								\
+	ret;								\
+})
 
 static inline map_word map_word_load(struct map_info *map, const void *ptr)
 {

commit fddcca5107051adf9e4481d2a79ae0616577fd2c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Feb 29 13:20:28 2016 +0100

    mtd: avoid stack overflow in MTD CFI code
    
    When map_word gets too large, we use a lot of kernel stack, and for
    MTD_MAP_BANK_WIDTH_32, this means we use more than the recommended
    1024 bytes in a number of functions:
    
    drivers/mtd/chips/cfi_cmdset_0020.c: In function 'cfi_staa_write_buffers':
    drivers/mtd/chips/cfi_cmdset_0020.c:651:1: warning: the frame size of 1336 bytes is larger than 1024 bytes [-Wframe-larger-than=]
    drivers/mtd/chips/cfi_cmdset_0020.c: In function 'cfi_staa_erase_varsize':
    drivers/mtd/chips/cfi_cmdset_0020.c:972:1: warning: the frame size of 1208 bytes is larger than 1024 bytes [-Wframe-larger-than=]
    drivers/mtd/chips/cfi_cmdset_0001.c: In function 'do_write_buffer':
    drivers/mtd/chips/cfi_cmdset_0001.c:1835:1: warning: the frame size of 1240 bytes is larger than 1024 bytes [-Wframe-larger-than=]
    
    This can be avoided if all operations on the map word are done
    indirectly and the stack gets reused between the calls. We can
    mostly achieve this by selecting MTD_COMPLEX_MAPPINGS whenever
    MTD_MAP_BANK_WIDTH_32 is set, but for the case that no other
    bank width is enabled, we also need to use a non-constant
    map_bankwidth() to convince the compiler to use less stack.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    [Brian: this patch mostly achieves its goal by forcing
        MTD_COMPLEX_MAPPINGS (and the accompanying indirection) for 256-bit
        mappings; the rest of the change is mostly a wash, though it helps
        reduce stack size slightly. If we really care about supporting
        256-bit mappings though, we should consider rewriting some of this
        code to avoid keeping and assigning so many 256-bit objects on the
        stack.]
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 5e0eb7ccabd4..3aa56e3104bb 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -122,18 +122,13 @@
 #endif
 
 #ifdef CONFIG_MTD_MAP_BANK_WIDTH_32
-# ifdef map_bankwidth
-#  undef map_bankwidth
-#  define map_bankwidth(map) ((map)->bankwidth)
-#  undef map_bankwidth_is_large
-#  define map_bankwidth_is_large(map) (map_bankwidth(map) > BITS_PER_LONG/8)
-#  undef map_words
-#  define map_words(map) map_calc_words(map)
-# else
-#  define map_bankwidth(map) 32
-#  define map_bankwidth_is_large(map) (1)
-#  define map_words(map) map_calc_words(map)
-# endif
+/* always use indirect access for 256-bit to preserve kernel stack */
+# undef map_bankwidth
+# define map_bankwidth(map) ((map)->bankwidth)
+# undef map_bankwidth_is_large
+# define map_bankwidth_is_large(map) (map_bankwidth(map) > BITS_PER_LONG/8)
+# undef map_words
+# define map_words(map) map_calc_words(map)
 #define map_bankwidth_is_32(map) (map_bankwidth(map) == 32)
 #undef MAX_MAP_BANKWIDTH
 #define MAX_MAP_BANKWIDTH 32

commit 95a001f22b1c5717eafd500a43832249ddd93662
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Feb 1 23:02:48 2016 +0100

    mtd: map: fix .set_vpp() documentation
    
    As of commit 876fe76d793d03077eb61ba3afab4a383f46c554
    "mtd: maps: physmap: Add reference counter to set_vpp()"
    the comment in the header file is incorrect and misleading.
    Fix it up.
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Paul Parsons <lost.distance@yahoo.com>
    Fixes: 876fe76d793d ("mtd: maps: physmap: Add reference counter to set_vpp()")
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 58f3ba709ade..5e0eb7ccabd4 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -240,8 +240,11 @@ struct map_info {
 	   If there is no cache to care about this can be set to NULL. */
 	void (*inval_cache)(struct map_info *, unsigned long, ssize_t);
 
-	/* set_vpp() must handle being reentered -- enable, enable, disable
-	   must leave it enabled. */
+	/* This will be called with 1 as parameter when the first map user
+	 * needs VPP, and called with 0 when the last user exits. The map
+	 * core maintains a reference counter, and assumes that VPP is a
+	 * global resource applying to all mapped flash chips on the system.
+	 */
 	void (*set_vpp)(struct map_info *, int);
 
 	unsigned long pfow_base;

commit fe7579d6122f2869d00b55842bca9e2a9be51607
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Nov 24 23:09:02 2015 +0100

    mtd: cfi: don't warn about broken geometry for !CONFIG_MTD
    
    The linux/mtd/map.h header file is included by a couple of
    platform specific files that are built even when CONFIG_MTD
    is disabled, and we always get
    
     warning "No CONFIG_MTD_MAP_BANK_WIDTH_xx selected. No NOR chip support can work"
    
    in that case. This adds an #ifdef around the pointless warning,
    as everything is really fine when we don't build the drivers
    anyway.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 366cf77953b5..58f3ba709ade 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -142,7 +142,9 @@
 #endif
 
 #ifndef map_bankwidth
+#ifdef CONFIG_MTD
 #warning "No CONFIG_MTD_MAP_BANK_WIDTH_xx selected. No NOR chip support can work"
+#endif
 static inline int map_bankwidth(void *map)
 {
 	BUG();

commit 2584cf83578c26db144730ef498f4070f82ee3ea
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Aug 10 23:07:05 2015 -0400

    arch, drivers: don't include <asm/io.h> directly, use <linux/io.h> instead
    
    Preparation for uniform definition of ioremap, ioremap_wc, ioremap_wt,
    and ioremap_cache, tree-wide.
    
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 29975c73a953..366cf77953b5 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -27,9 +27,9 @@
 #include <linux/string.h>
 #include <linux/bug.h>
 #include <linux/kernel.h>
+#include <linux/io.h>
 
 #include <asm/unaligned.h>
-#include <asm/io.h>
 #include <asm/barrier.h>
 
 #ifdef CONFIG_MTD_MAP_BANK_WIDTH_1

commit 7234bea69de200e2060d099685c4c674b556edc0
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Mar 10 17:51:55 2015 +0100

    mtd: clean up whitespace in linux/mtd/map.h
    
    As the only comments I got for the "mtd: cfi: reduce stack size"
    patch were about whitespace changes, it appears necessary to fix
    up the rest of the file as well, which contains the exact same
    mistakes.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index a872157a0700..29975c73a953 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -77,7 +77,7 @@
 /* ensure we never evaluate anything shorted than an unsigned long
  * to zero, and ensure we'll never miss the end of an comparison (bjd) */
 
-#define map_calc_words(map) ((map_bankwidth(map) + (sizeof(unsigned long)-1))/ sizeof(unsigned long))
+#define map_calc_words(map) ((map_bankwidth(map) + (sizeof(unsigned long)-1)) / sizeof(unsigned long))
 
 #ifdef CONFIG_MTD_MAP_BANK_WIDTH_8
 # ifdef map_bankwidth
@@ -181,7 +181,7 @@ static inline int map_bankwidth_supported(int w)
 	}
 }
 
-#define MAX_MAP_LONGS ( ((MAX_MAP_BANKWIDTH*8) + BITS_PER_LONG - 1) / BITS_PER_LONG )
+#define MAX_MAP_LONGS (((MAX_MAP_BANKWIDTH * 8) + BITS_PER_LONG - 1) / BITS_PER_LONG)
 
 typedef union {
 	unsigned long x[MAX_MAP_LONGS];
@@ -264,20 +264,22 @@ void unregister_mtd_chip_driver(struct mtd_chip_driver *);
 struct mtd_info *do_map_probe(const char *name, struct map_info *map);
 void map_destroy(struct mtd_info *mtd);
 
-#define ENABLE_VPP(map) do { if(map->set_vpp) map->set_vpp(map, 1); } while(0)
-#define DISABLE_VPP(map) do { if(map->set_vpp) map->set_vpp(map, 0); } while(0)
+#define ENABLE_VPP(map) do { if (map->set_vpp) map->set_vpp(map, 1); } while (0)
+#define DISABLE_VPP(map) do { if (map->set_vpp) map->set_vpp(map, 0); } while (0)
 
 #define INVALIDATE_CACHED_RANGE(map, from, size) \
-	do { if(map->inval_cache) map->inval_cache(map, from, size); } while(0)
+	do { if (map->inval_cache) map->inval_cache(map, from, size); } while (0)
 
 
 static inline int map_word_equal(struct map_info *map, map_word val1, map_word val2)
 {
 	int i;
-	for (i=0; i<map_words(map); i++) {
+
+	for (i = 0; i < map_words(map); i++) {
 		if (val1.x[i] != val2.x[i])
 			return 0;
 	}
+
 	return 1;
 }
 
@@ -286,9 +288,9 @@ static inline map_word map_word_and(struct map_info *map, map_word val1, map_wor
 	map_word r;
 	int i;
 
-	for (i=0; i<map_words(map); i++) {
+	for (i = 0; i < map_words(map); i++)
 		r.x[i] = val1.x[i] & val2.x[i];
-	}
+
 	return r;
 }
 
@@ -297,9 +299,9 @@ static inline map_word map_word_clr(struct map_info *map, map_word val1, map_wor
 	map_word r;
 	int i;
 
-	for (i=0; i<map_words(map); i++) {
+	for (i = 0; i < map_words(map); i++)
 		r.x[i] = val1.x[i] & ~val2.x[i];
-	}
+
 	return r;
 }
 
@@ -308,9 +310,9 @@ static inline map_word map_word_or(struct map_info *map, map_word val1, map_word
 	map_word r;
 	int i;
 
-	for (i=0; i<map_words(map); i++) {
+	for (i = 0; i < map_words(map); i++)
 		r.x[i] = val1.x[i] | val2.x[i];
-	}
+
 	return r;
 }
 
@@ -330,10 +332,11 @@ static inline int map_word_bitsset(struct map_info *map, map_word val1, map_word
 {
 	int i;
 
-	for (i=0; i<map_words(map); i++) {
+	for (i = 0; i < map_words(map); i++) {
 		if (val1.x[i] & val2.x[i])
 			return 1;
 	}
+
 	return 0;
 }
 
@@ -365,14 +368,16 @@ static inline map_word map_word_load_partial(struct map_info *map, map_word orig
 
 	if (map_bankwidth_is_large(map)) {
 		char *dest = (char *)&orig;
+
 		memcpy(dest+start, buf, len);
 	} else {
-		for (i=start; i < start+len; i++) {
+		for (i = start; i < start+len; i++) {
 			int bitpos;
+
 #ifdef __LITTLE_ENDIAN
-			bitpos = i*8;
+			bitpos = i * 8;
 #else /* __BIG_ENDIAN */
-			bitpos = (map_bankwidth(map)-1-i)*8;
+			bitpos = (map_bankwidth(map) - 1 - i) * 8;
 #endif
 			orig.x[0] &= ~(0xff << bitpos);
 			orig.x[0] |= (unsigned long)buf[i-start] << bitpos;
@@ -394,9 +399,10 @@ static inline map_word map_word_ff(struct map_info *map)
 
 	if (map_bankwidth(map) < MAP_FF_LIMIT) {
 		int bw = 8 * map_bankwidth(map);
+
 		r.x[0] = (1UL << bw) - 1;
 	} else {
-		for (i=0; i<map_words(map); i++)
+		for (i = 0; i < map_words(map); i++)
 			r.x[i] = ~0UL;
 	}
 	return r;
@@ -417,7 +423,7 @@ static inline map_word inline_map_read(struct map_info *map, unsigned long ofs)
 		r.x[0] = __raw_readq(map->virt + ofs);
 #endif
 	else if (map_bankwidth_is_large(map))
-		memcpy_fromio(r.x, map->virt+ofs, map->bankwidth);
+		memcpy_fromio(r.x, map->virt + ofs, map->bankwidth);
 	else
 		BUG();
 

commit d09957fbb4d0b059b3176b510540df69048ad170
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Mar 10 17:48:37 2015 +0100

    mtd: cfi: reduce stack size
    
    The cfi_staa_write_buffers function uses a large amount of kernel stack
    whenever CONFIG_MTD_MAP_BANK_WIDTH_32 is set, and that results in a
    warning on ARM allmodconfig builds:
    
    drivers/mtd/chips/cfi_cmdset_0020.c: In function 'cfi_staa_write_buffers':
    drivers/mtd/chips/cfi_cmdset_0020.c:651:1: warning: the frame size of 1208 bytes is larger than 1024 bytes [-Wframe-larger-than=]
    
    It turns out that this is largely a result of a suboptimal implementation
    of map_word_andequal(). Replacing this function with a straightforward
    one reduces the stack size in this function by exactly 200 bytes,
    shrinks the .text segment for this file from 27648 bytes to 26608 bytes,
    and makes the warning go away.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 5f487d776411..a872157a0700 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -314,7 +314,17 @@ static inline map_word map_word_or(struct map_info *map, map_word val1, map_word
 	return r;
 }
 
-#define map_word_andequal(m, a, b, z) map_word_equal(m, z, map_word_and(m, a, b))
+static inline int map_word_andequal(struct map_info *map, map_word val1, map_word val2, map_word val3)
+{
+	int i;
+
+	for (i = 0; i < map_words(map); i++) {
+		if ((val1.x[i] & val2.x[i]) != val3.x[i])
+			return 0;
+	}
+
+	return 1;
+}
 
 static inline int map_word_bitsset(struct map_info *map, map_word val1, map_word val2)
 {

commit a4d62babf988fe5dfde24437fa135ef147bc7aa0
Author: Wang Haitao <wang.haitao1@zte.com.cn>
Date:   Thu Aug 22 19:32:38 2013 +0800

    mtd: map: fixed bug in 64-bit systems
    
    Hardware:
            CPU: XLP832,the 64-bit OS
            NOR Flash:S29GL128S 128M
    Software:
            Kernel:2.6.32.41
            Filesystem:JFFS2
    When writing files, errors appear:
            Write len 182  but return retlen 180
            Write of 182 bytes at 0x072c815c failed. returned -5, retlen 180
            Write len 186  but return retlen 184
            Write of 186 bytes at 0x072caff4 failed. returned -5, retlen 184
    These errors exist only in 64-bit systems,not in 32-bit systems. After analysis, we
    found that the left shift operation is wrong in map_word_load_partial. For instance:
            unsigned char buf[3] ={0x9e,0x3a,0xea};
            map_bankwidth(map) is 4;
            for (i=0; i < 3; i++) {
                    int bitpos;
                    bitpos = (map_bankwidth(map)-1-i)*8;
                    orig.x[0] &= ~(0xff << bitpos);
                    orig.x[0] |= buf[i] << bitpos;
            }
    
    The value of orig.x[0] is expected to be 0x9e3aeaff, but in this situation(64-bit
    System) we'll get the wrong value of 0xffffffff9e3aeaff due to the 64-bit sign
    extension:
    buf[i] is defined as "unsigned char" and the left-shift operation will convert it
    to the type of "signed int", so when left-shift buf[i] by 24 bits, the final result
    will get the wrong value: 0xffffffff9e3aeaff.
    
    If the left-shift bits are less than 24, then sign extension will not occur. Whereas
    the bankwidth of the nor flash we used is 4, therefore this BUG emerges.
    
    Signed-off-by: Pang Xunlei <pang.xunlei@zte.com.cn>
    Signed-off-by: Zhang Yi <zhang.yi20@zte.com.cn>
    Signed-off-by: Lu Zhongjun <lu.zhongjun@zte.com.cn>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 4b02512e421c..5f487d776411 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -365,7 +365,7 @@ static inline map_word map_word_load_partial(struct map_info *map, map_word orig
 			bitpos = (map_bankwidth(map)-1-i)*8;
 #endif
 			orig.x[0] &= ~(0xff << bitpos);
-			orig.x[0] |= buf[i-start] << bitpos;
+			orig.x[0] |= (unsigned long)buf[i-start] << bitpos;
 		}
 	}
 	return orig;
@@ -384,7 +384,7 @@ static inline map_word map_word_ff(struct map_info *map)
 
 	if (map_bankwidth(map) < MAP_FF_LIMIT) {
 		int bw = 8 * map_bankwidth(map);
-		r.x[0] = (1 << bw) - 1;
+		r.x[0] = (1UL << bw) - 1;
 	} else {
 		for (i=0; i<map_words(map); i++)
 			r.x[i] = ~0UL;

commit 24dea0c9feccf699749f860fa2f4ccd84d30390d
Author: Dmitry Eremin-Solenikov <dmitry_eremin@mentor.com>
Date:   Thu Jan 31 21:06:34 2013 +0400

    mtd: map: BUG() in non handled cases
    
    Several map-related functions look like a serie of ifs, checking
    widths of map. Those functions do not have any handling for default
    case. Instead of fiddling with uninitialized_var in those functions,
    let's just add a (correct) BUG() to the default case on those maps. This
    will also allow us to catch potential errors in maps setup in future.
    
    Signed-off-by: Dmitry Eremin-Solenikov <dmitry_eremin@mentor.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 8b9bfd7dcaa3..4b02512e421c 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -329,7 +329,7 @@ static inline int map_word_bitsset(struct map_info *map, map_word val1, map_word
 
 static inline map_word map_word_load(struct map_info *map, const void *ptr)
 {
-	map_word r = {{0} };
+	map_word r;
 
 	if (map_bankwidth_is_1(map))
 		r.x[0] = *(unsigned char *)ptr;
@@ -343,6 +343,8 @@ static inline map_word map_word_load(struct map_info *map, const void *ptr)
 #endif
 	else if (map_bankwidth_is_large(map))
 		memcpy(r.x, ptr, map->bankwidth);
+	else
+		BUG();
 
 	return r;
 }
@@ -392,7 +394,7 @@ static inline map_word map_word_ff(struct map_info *map)
 
 static inline map_word inline_map_read(struct map_info *map, unsigned long ofs)
 {
-	map_word uninitialized_var(r);
+	map_word r;
 
 	if (map_bankwidth_is_1(map))
 		r.x[0] = __raw_readb(map->virt + ofs);
@@ -426,6 +428,8 @@ static inline void inline_map_write(struct map_info *map, const map_word datum,
 #endif
 	else if (map_bankwidth_is_large(map))
 		memcpy_toio(map->virt+ofs, datum.x, map->bankwidth);
+	else
+		BUG();
 	mb();
 }
 

commit 1648eaaa1575ea686acb82fb8cb3d8839764ef2c
Author: Stefan Roese <sr@denx.de>
Date:   Fri Jan 18 13:10:05 2013 +0100

    mtd: cfi_cmdset_0002: Support Persistent Protection Bits (PPB) locking
    
    Currently cfi_cmdset_0002.c does not support PPB locking of sectors. This
    patch adds support for this locking/unlocking mechanism. It is needed on
    some platforms, since newer U-Boot versions do support this PPB locking
    and protect for example their environment sector(s) this way.
    
    This PPB locking/unlocking will be enabled for all devices supported by
    cfi_cmdset_0002 reporting 8 in the CFI word 0x49 (Sector Protect/Unprotect
    scheme).
    
    Please note that PPB locking does support sector-by-sector locking. But
    the whole chip can only be unlocked together. So unlocking one sector
    will automatically unlock all sectors of this device. Because of this
    chip limitation, the PPB unlocking function saves the current locking
    status of all sectors before unlocking the whole device. After unlocking
    the saved locking status is re-configured. This way only the addressed
    sectors will be unlocked.
    
    To selectively enable this advanced sector protection mechanism, the
    device-tree property "use-advanced-sector-protection" has been created.
    To enable support for this locking this property needs to be present in the
    flash DT node. E.g.:
    
    nor_flash@0,0 {
            compatible = "amd,s29gl256n", "cfi-flash";
            bank-width = <2>;
            use-advanced-sector-protection;
            ...
    
    Tested with Spansion S29GL512S10THI and Micron JS28F512M29EWx flash
    devices.
    
    Signed-off-by: Stefan Roese <sr@denx.de>
    Tested-by: Holger Brunck <holger.brunck@keymile.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index f6eb4332ac92..8b9bfd7dcaa3 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -245,6 +245,7 @@ struct map_info {
 	unsigned long pfow_base;
 	unsigned long map_priv_1;
 	unsigned long map_priv_2;
+	struct device_node *device_node;
 	void *fldrv_priv;
 	struct mtd_chip_driver *fldrv;
 };

commit 5d27aa5af04f58f3020de1c224dcf8a62151fd58
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Nov 6 22:55:28 2012 +0100

    mtd: uninitialized variable warning in map.h
    
    The map_word_load() function initializes exactly
    as many words in the buffer as required, but gcc
    cannot figure this out and gives a misleading
    warning. Marking the local variable as
    uninitialized_var shuts up that warning.
    
    Without this patch, building acs5k_defconfig results in:
    
    drivers/mtd/chips/cfi_cmdset_0002.c: In function 'cfi_amdstd_panic_write':
    include/linux/mtd/map.h:331:11: warning: 'r.x[0]' may be used uninitialized in this function [-Wuninitialized]
    drivers/mtd/chips/cfi_cmdset_0002.c: In function 'cfi_amdstd_write_words':
    include/linux/mtd/map.h:331:11: warning: 'r.x[0]' may be used uninitialized in this function [-Wuninitialized]
    drivers/mtd/chips/cfi_cmdset_0001.c: In function 'cfi_intelext_write_words':
    include/linux/mtd/map.h:331:11: warning: 'r.x[0]' may be used uninitialized in this function [-Wuninitialized]
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 56c7936e0c65..f6eb4332ac92 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -391,7 +391,7 @@ static inline map_word map_word_ff(struct map_info *map)
 
 static inline map_word inline_map_read(struct map_info *map, unsigned long ofs)
 {
-	map_word r;
+	map_word uninitialized_var(r);
 
 	if (map_bankwidth_is_1(map))
 		r.x[0] = __raw_readb(map->virt + ofs);

commit 3e9ce49e0ef95e22790a74720f0068696b2477c9
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Oct 29 22:47:26 2012 +0530

    mtd: map: Fix compilation warning
    
    This patch is an attempt to fix following compilation warning.
    
    In file included from drivers/mtd/chips/cfi_cmdset_0001.c:35:0:
    drivers/mtd/chips/cfi_cmdset_0001.c: In function 'cfi_intelext_write_words':
    include/linux/mtd/map.h:331:11: warning: 'r.x[0]' may be used uninitialized in this function [-Wmaybe-uninitialized]
    
    I could have used uninitialized_var() too, but didn't used it as the final else
    part of map_word_load() is missing. So there is a chance that it might be passed
    uninitialized. Better initialize to zero.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 3595a0236b0f..56c7936e0c65 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -328,7 +328,7 @@ static inline int map_word_bitsset(struct map_info *map, map_word val1, map_word
 
 static inline map_word map_word_load(struct map_info *map, const void *ptr)
 {
-	map_word r;
+	map_word r = {{0} };
 
 	if (map_bankwidth_is_1(map))
 		r.x[0] = *(unsigned char *)ptr;

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index ade5c990f1f0..3595a0236b0f 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -29,7 +29,6 @@
 #include <linux/kernel.h>
 
 #include <asm/unaligned.h>
-#include <asm/system.h>
 #include <asm/io.h>
 #include <asm/barrier.h>
 

commit 96f951edb1f1bdbbc99b0cd458f9808bb83d58ae
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Add #includes needed to permit the removal of asm/system.h
    
    asm/system.h is a cause of circular dependency problems because it contains
    commonly used primitive stuff like barrier definitions and uncommonly used
    stuff like switch_to() that might require MMU definitions.
    
    asm/system.h has been disintegrated by this point on all arches into the
    following common segments:
    
     (1) asm/barrier.h
    
         Moved memory barrier definitions here.
    
     (2) asm/cmpxchg.h
    
         Moved xchg() and cmpxchg() here.  #included in asm/atomic.h.
    
     (3) asm/bug.h
    
         Moved die() and similar here.
    
     (4) asm/exec.h
    
         Moved arch_align_stack() here.
    
     (5) asm/elf.h
    
         Moved AT_VECTOR_SIZE_ARCH here.
    
     (6) asm/switch_to.h
    
         Moved switch_to() here.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 94e924e2ecd5..ade5c990f1f0 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -31,6 +31,7 @@
 #include <asm/unaligned.h>
 #include <asm/system.h>
 #include <asm/io.h>
+#include <asm/barrier.h>
 
 #ifdef CONFIG_MTD_MAP_BANK_WIDTH_1
 #define map_bankwidth(map) 1

commit 4a42243886b87cd28a39b192161767c2af851a55
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 30 18:28:01 2011 +0200

    mtd: map.h: fix arm cross-build failure
    
    This patch fixes the following build failure:
    In file included from include/linux/mtd/qinfo.h:4:0,
                     from include/linux/mtd/pfow.h:7,
                     from drivers/mtd/lpddr/lpddr_cmds.c:27:
    include/linux/mtd/map.h: In function 'inline_map_read':
    include/linux/mtd/map.h:409:3: error: implicit declaration of function 'BUILD_BUG_ON' [-Werror=implicit-function-declaration]
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 1132410f14c6..94e924e2ecd5 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -26,7 +26,7 @@
 #include <linux/list.h>
 #include <linux/string.h>
 #include <linux/bug.h>
-
+#include <linux/kernel.h>
 
 #include <asm/unaligned.h>
 #include <asm/system.h>

commit 8e987465a137d4824710e02550f06aa891c9b865
Author: Aaron Sierra <asierra@xes-inc.com>
Date:   Mon Nov 14 18:44:34 2011 -0600

    mtd: cfi: Allow per-mapping CFI device endianness
    
    This patch allows each CFI device map to use its own endianness. The
    globally defined CFI endianness (CONFIG_MTD_CFI_NOSWAP,
    CONFIG_MTD_CFI_BE_BYTE_SWAP or CONFIG_MTD_CFI_LE_BYTE_SWAP) becomes the
    default value which can be overridden by a driver for a particular device.
    
    Signed-off-by: Aaron Sierra <asierra@xes-inc.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index a9e6ba46865e..1132410f14c6 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -214,6 +214,7 @@ struct map_info {
 	void __iomem *virt;
 	void *cached;
 
+	int swap; /* this mapping's byte-swapping requirement */
 	int bankwidth; /* in octets. This isn't necessarily the width
 		       of actual bus cycles -- it's the repeat interval
 		      in bytes, before you are talking to the first chip again.

commit 6ae0185fe201eae0548dace2a84acb5050fc8606
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Sun Aug 8 21:19:42 2010 +0100

    mtd: Remove obsolete <mtd/compatmac.h> include
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index eea3a4fb7405..a9e6ba46865e 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -27,7 +27,6 @@
 #include <linux/string.h>
 #include <linux/bug.h>
 
-#include <linux/mtd/compatmac.h>
 
 #include <asm/unaligned.h>
 #include <asm/system.h>

commit a1452a3771c4eb85bd779790b040efdc36f4274e
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Sun Aug 8 20:58:20 2010 +0100

    mtd: Update copyright notices
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index de89eca864ce..eea3a4fb7405 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -1,3 +1,21 @@
+/*
+ * Copyright © 2000-2010 David Woodhouse <dwmw2@infradead.org> et al.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
 
 /* Overhauled routines for dealing with different mmap regions of flash */
 

commit 9ea5973883bbe26372f45d99eb3a500f08d966f9
Author: Kevin Cernekee <cernekee@gmail.com>
Date:   Sat Apr 10 11:18:58 2010 -0700

    mtd: suppress warnings in inline_map_read()
    
    With gcc 4.4.3 -O2 on MIPS32:
    
    drivers/mtd/chips/cfi_util.c: In function 'cfi_qry_present':
    include/linux/mtd/map.h:390: warning: 'r' may be used uninitialized in this function
    include/linux/mtd/map.h:375: note: 'r' was declared here
    include/linux/mtd/map.h:390: warning: 'r' may be used uninitialized in this function
    include/linux/mtd/map.h:375: note: 'r' was declared here
    
    Signed-off-by: Kevin Cernekee <cernekee@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 01703d425986..de89eca864ce 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -387,6 +387,8 @@ static inline map_word inline_map_read(struct map_info *map, unsigned long ofs)
 #endif
 	else if (map_bankwidth_is_large(map))
 		memcpy_fromio(r.x, map->virt+ofs, map->bankwidth);
+	else
+		BUG();
 
 	return r;
 }

commit 709c4efb68cccd2de9a7d63b1f90276b1617e613
Author: Kevin Cernekee <cernekee@gmail.com>
Date:   Tue May 4 12:51:34 2010 -0700

    mtd: map.h: add missing bug.h include
    
    Signed-off-by: Kevin Cernekee <cernekee@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index b981b8772217..01703d425986 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -7,6 +7,7 @@
 #include <linux/types.h>
 #include <linux/list.h>
 #include <linux/string.h>
+#include <linux/bug.h>
 
 #include <linux/mtd/compatmac.h>
 

commit d13e51e747fee301b404dffcf4a7e1bdc558969b
Author: Alexey Korolev <akorolev@infradead.org>
Date:   Tue Dec 16 18:21:10 2008 +0000

    [MTD] LPDDR added new pfow_base parameter
    
    We need to supply additional parameter to mapping driver and tell
    LPDDR drivers where PFOW window is in chip mapping.
    It leads to necessity of map_info structure extendoing.
    
    Signed-off-by: Alexey Korolev <akorolev@infradead.org>
    Acked-by: Jared Hulbert <jaredeh@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index aa30244492c6..b981b8772217 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -223,6 +223,7 @@ struct map_info {
 	   must leave it enabled. */
 	void (*set_vpp)(struct map_info *, int);
 
+	unsigned long pfow_base;
 	unsigned long map_priv_1;
 	unsigned long map_priv_2;
 	void *fldrv_priv;

commit ff877ea80efa2015b6263766f78ee42c2a1b32f9
Merge: 30821fee4f0c d37e6bf68fc1
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Fri Jul 25 10:40:14 2008 -0400

    Merge branch 'linux-next' of git://git.infradead.org/~dedekind/ubi-2.6

commit eadcf0d704a46979c29984fa05f1fc413c775bcb
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Jul 2 12:46:22 2008 -0700

    MTD: handle pci_name() being const
    
    This changes the MTD core to handle pci_name() now returning a constant
    string.
    
    Cc: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index a9fae032ba81..9c1d95491f8b 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -189,7 +189,7 @@ typedef union {
 */
 
 struct map_info {
-	char *name;
+	const char *name;
 	unsigned long size;
 	resource_size_t phys;
 #define NO_XIP (-1UL)

commit 59018b6d2acabb114ab58637e6ab95ba424a89d0
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue May 20 01:03:52 2008 +0300

    MTD/JFFS2: remove CVS keywords
    
    Once upon a time, the MTD repository was using CVS.
    
    This patch therefore removes all usages of the no longer updated CVS
    keywords from the MTD code.
    
    This also includes code that printed them to the user.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index a9fae032ba81..85e3939cf487 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -1,6 +1,5 @@
 
 /* Overhauled routines for dealing with different mmap regions of flash */
-/* $Id: map.h,v 1.54 2005/11/07 11:14:54 gleixner Exp $ */
 
 #ifndef __LINUX_MTD_MAP_H__
 #define __LINUX_MTD_MAP_H__

commit 241651d04d672fb685b2874707016cbbf95931e5
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Thu Sep 6 09:40:21 2007 +0100

    [MTD] Fix CFI build error when no map width or interleave supported
    
    When building NOR flash support, you have compile-time options for the
    bus width and the number of individual chips which are interleaved
    together onto that bus. The code to deal with arbitrary geometry is a
    bit convoluted, and people want to just configure it for the specific
    hardware they have, to avoid the runtime overhead.
    
    Selecting _none_ of the available options doesn't make any sense. You
    should have at least one. This makes it build though, since people
    persist in trying.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 81f3a314dd76..a9fae032ba81 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -125,7 +125,15 @@
 #endif
 
 #ifndef map_bankwidth
-#error "No bus width supported. What's the point?"
+#warning "No CONFIG_MTD_MAP_BANK_WIDTH_xx selected. No NOR chip support can work"
+static inline int map_bankwidth(void *map)
+{
+	BUG();
+	return 0;
+}
+#define map_bankwidth_is_large(map) (0)
+#define map_words(map) (0)
+#define MAX_MAP_BANKWIDTH 1
 #endif
 
 static inline int map_bankwidth_supported(int w)

commit 0d36da3b409536a24266c5f0972f2e1cfae1afd4
Author: Stefan Roese <ml@stefan-roese.de>
Date:   Fri Jan 19 08:40:04 2007 +0100

    [MTD] physmap: Add support for 64 bit resources
    
    This patch adds support for 64 bit resources enabled via the
    CONFIG_RESOURCES_64BIT option. Now a 64 bit can be passed to the
    physmap driver.
    
    Signed-off-by: Stefan Roese <sr@denx.de>
    Signed-off-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 28d461d862bd..81f3a314dd76 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -183,7 +183,7 @@ typedef union {
 struct map_info {
 	char *name;
 	unsigned long size;
-	unsigned long phys;
+	resource_size_t phys;
 #define NO_XIP (-1UL)
 
 	void __iomem *virt;

commit 62c4f0a2d5a188f73a94f2cb8ea0dba3e7cf0a7f
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 26 12:56:16 2006 +0100

    Don't include linux/config.h from anywhere else in include/
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 7dfd6e1fcde7..28d461d862bd 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -5,7 +5,6 @@
 #ifndef __LINUX_MTD_MAP_H__
 #define __LINUX_MTD_MAP_H__
 
-#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/list.h>
 #include <linux/string.h>

commit 1b8623545b42c03eb92e51b28c84acf4b8ba00a3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 15 01:07:03 2005 -0500

    [PATCH] remove bogus asm/bug.h includes.
    
    A bunch of asm/bug.h includes are both not needed (since it will get
    pulled anyway) and bogus (since they are done too early).  Removed.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index fedfbc8a287f..7dfd6e1fcde7 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -15,7 +15,6 @@
 #include <asm/unaligned.h>
 #include <asm/system.h>
 #include <asm/io.h>
-#include <asm/bug.h>
 
 #ifdef CONFIG_MTD_MAP_BANK_WIDTH_1
 #define map_bankwidth(map) 1

commit 61ecfa8777d0bc8e33dc0e5c2cca9b3247da2d37
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Nov 7 11:15:31 2005 +0000

    [MTD] includes: Clean up trailing white spaces
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index fc28841f3409..fedfbc8a287f 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -1,6 +1,6 @@
 
 /* Overhauled routines for dealing with different mmap regions of flash */
-/* $Id: map.h,v 1.52 2005/05/25 10:29:41 gleixner Exp $ */
+/* $Id: map.h,v 1.54 2005/11/07 11:14:54 gleixner Exp $ */
 
 #ifndef __LINUX_MTD_MAP_H__
 #define __LINUX_MTD_MAP_H__
@@ -170,14 +170,14 @@ typedef union {
    to a chip probe routine -- either JEDEC or CFI probe or both -- via
    do_map_probe(). If a chip is recognised, the probe code will invoke the
    appropriate chip driver (if present) and return a struct mtd_info.
-   At which point, you fill in the mtd->module with your own module 
+   At which point, you fill in the mtd->module with your own module
    address, and register it with the MTD core code. Or you could partition
    it and register the partitions instead, or keep it for your own private
    use; whatever.
-   
+
    The mtd->priv field will point to the struct map_info, and any further
-   private data required by the chip driver is linked from the 
-   mtd->priv->fldrv_priv field. This allows the map driver to get at 
+   private data required by the chip driver is linked from the
+   mtd->priv->fldrv_priv field. This allows the map driver to get at
    the destructor function map->fldrv_destroy() when it's tired
    of living.
 */
@@ -214,7 +214,7 @@ struct map_info {
 	   If there is no cache to care about this can be set to NULL. */
 	void (*inval_cache)(struct map_info *, unsigned long, ssize_t);
 
-	/* set_vpp() must handle being reentered -- enable, enable, disable 
+	/* set_vpp() must handle being reentered -- enable, enable, disable
 	   must leave it enabled. */
 	void (*set_vpp)(struct map_info *, int);
 
@@ -353,7 +353,7 @@ static inline map_word map_word_ff(struct map_info *map)
 {
 	map_word r;
 	int i;
-	
+
 	if (map_bankwidth(map) < MAP_FF_LIMIT) {
 		int bw = 8 * map_bankwidth(map);
 		r.x[0] = (1 << bw) - 1;

commit 4e57b6817880946a3a78d5d8cad1ace363f7e449
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Sun Oct 30 15:03:48 2005 -0800

    [PATCH] fix missing includes
    
    I recently picked up my older work to remove unnecessary #includes of
    sched.h, starting from a patch by Dave Jones to not include sched.h
    from module.h. This reduces the number of indirect includes of sched.h
    by ~300. Another ~400 pointless direct includes can be removed after
    this disentangling (patch to follow later).
    However, quite a few indirect includes need to be fixed up for this.
    
    In order to feed the patches through -mm with as little disturbance as
    possible, I've split out the fixes I accumulated up to now (complete for
    i386 and x86_64, more archs to follow later) and post them before the real
    patch.  This way this large part of the patch is kept simple with only
    adding #includes, and all hunks are independent of each other.  So if any
    hunk rejects or gets in the way of other patches, just drop it.  My scripts
    will pick it up again in the next round.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 142963f01d29..fc28841f3409 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -8,7 +8,10 @@
 #include <linux/config.h>
 #include <linux/types.h>
 #include <linux/list.h>
+#include <linux/string.h>
+
 #include <linux/mtd/compatmac.h>
+
 #include <asm/unaligned.h>
 #include <asm/system.h>
 #include <asm/io.h>

commit a8aff8ab981cc8ef170e89d85094da722644a7fd
Author: Thomas Gleixner <tglx@tglx.tec.linutronix.de>
Date:   Wed May 25 12:32:37 2005 +0200

    [MTD] Fix it really
    
    tglx declares him self to be the idiot of the day.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index dbd7b9b510d3..142963f01d29 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -1,6 +1,6 @@
 
 /* Overhauled routines for dealing with different mmap regions of flash */
-/* $Id: map.h,v 1.51 2005/05/25 10:15:29 gleixner Exp $ */
+/* $Id: map.h,v 1.52 2005/05/25 10:29:41 gleixner Exp $ */
 
 #ifndef __LINUX_MTD_MAP_H__
 #define __LINUX_MTD_MAP_H__
@@ -352,7 +352,7 @@ static inline map_word map_word_ff(struct map_info *map)
 	int i;
 	
 	if (map_bankwidth(map) < MAP_FF_LIMIT) {
-		int bw = 8 * map_bankwidth;
+		int bw = 8 * map_bankwidth(map);
 		r.x[0] = (1 << bw) - 1;
 	} else {
 		for (i=0; i<map_words(map); i++)

commit b0435695cb3b3e0542c9a3f921f40b216ec37580
Author: Thomas Gleixner <tglx@tglx.tec.linutronix.de>
Date:   Wed May 25 12:20:29 2005 +0200

    [MTD] map.h Use the correct macro and fix the resulting compiler warning
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index dd36d9433f00..dbd7b9b510d3 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -1,6 +1,6 @@
 
 /* Overhauled routines for dealing with different mmap regions of flash */
-/* $Id: map.h,v 1.49 2005/05/24 18:45:15 gleixner Exp $ */
+/* $Id: map.h,v 1.51 2005/05/25 10:15:29 gleixner Exp $ */
 
 #ifndef __LINUX_MTD_MAP_H__
 #define __LINUX_MTD_MAP_H__
@@ -351,8 +351,9 @@ static inline map_word map_word_ff(struct map_info *map)
 	map_word r;
 	int i;
 	
-	if (map_bank_width(map) < MAP_FF_LIMIT) {
-		r.x[0] = (1 << (8*map_bank_width(map))) - 1;
+	if (map_bankwidth(map) < MAP_FF_LIMIT) {
+		int bw = 8 * map_bankwidth;
+		r.x[0] = (1 << bw) - 1;
 	} else {
 		for (i=0; i<map_words(map); i++)
 			r.x[i] = ~0UL;

commit 3a3ab48c68de656736f091c6ed768fa8c110a7ab
Author: Thomas Gleixner <tglx@tglx.tec.linutronix.de>
Date:   Tue May 24 20:50:18 2005 +0200

    [MTD] Make map_word_ff ware of the flash buswidth
    
    map_word_ff() was setting the mapword to ~0UL regardless of the
    buswidth of the mapped flash chip. The read_map functions are
    buswidth aware and therefor the map_word_equal function failed.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 115b14a634da..dd36d9433f00 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -1,6 +1,6 @@
 
 /* Overhauled routines for dealing with different mmap regions of flash */
-/* $Id: map.h,v 1.48 2005/02/16 15:54:59 nico Exp $ */
+/* $Id: map.h,v 1.49 2005/05/24 18:45:15 gleixner Exp $ */
 
 #ifndef __LINUX_MTD_MAP_H__
 #define __LINUX_MTD_MAP_H__
@@ -340,13 +340,22 @@ static inline map_word map_word_load_partial(struct map_info *map, map_word orig
 	return orig;
 }
 
+#if BITS_PER_LONG < 64
+#define MAP_FF_LIMIT 4
+#else
+#define MAP_FF_LIMIT 8
+#endif
+
 static inline map_word map_word_ff(struct map_info *map)
 {
 	map_word r;
 	int i;
-
-	for (i=0; i<map_words(map); i++) {
-		r.x[i] = ~0UL;
+	
+	if (map_bank_width(map) < MAP_FF_LIMIT) {
+		r.x[0] = (1 << (8*map_bank_width(map))) - 1;
+	} else {
+		for (i=0; i<map_words(map); i++)
+			r.x[i] = ~0UL;
 	}
 	return r;
 }

commit f16407d73effc59e1e9f88e45a3dc53cacbb8264
Author: Nicolas Pitre <nico@cam.org>
Date:   Wed Feb 16 15:55:03 2005 +0000

    [MTD] Quiet unused variable warning
    
    Signed-off-by: Nioclas Pitre <nico@cam.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 8fc6679aa9b1..115b14a634da 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -1,6 +1,6 @@
 
 /* Overhauled routines for dealing with different mmap regions of flash */
-/* $Id: map.h,v 1.47 2005/02/08 17:11:15 nico Exp $ */
+/* $Id: map.h,v 1.48 2005/02/16 15:54:59 nico Exp $ */
 
 #ifndef __LINUX_MTD_MAP_H__
 #define __LINUX_MTD_MAP_H__
@@ -418,7 +418,7 @@ extern void simple_map_init(struct map_info *);
 
 
 #define simple_map_init(map) BUG_ON(!map_bankwidth_supported((map)->bankwidth))
-#define map_is_linear(map) (1)
+#define map_is_linear(map) ({ (void)(map); 1; })
 
 #endif /* !CONFIG_MTD_COMPLEX_MAPPINGS */
 

commit f77814dd5728edaf1239d19755d2aa0d8c33d861
Author: Nicolas Pitre <nico@cam.org>
Date:   Tue Feb 8 17:11:19 2005 +0000

    [MTD] Support for protection register support on Intel FLASH chips
    
    This enables support for reading, writing and locking so called
    "Protection Registers" present on some flash chips.
    A subset of them are pre-programmed at the factory with a
    unique set of values. The rest is user-programmable.
    
    Signed-off-by: Nicolas Pitre <nico@cam.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index f0268b99c900..8fc6679aa9b1 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -1,6 +1,6 @@
 
 /* Overhauled routines for dealing with different mmap regions of flash */
-/* $Id: map.h,v 1.46 2005/01/05 17:09:44 dwmw2 Exp $ */
+/* $Id: map.h,v 1.47 2005/02/08 17:11:15 nico Exp $ */
 
 #ifndef __LINUX_MTD_MAP_H__
 #define __LINUX_MTD_MAP_H__
@@ -263,6 +263,17 @@ static inline map_word map_word_and(struct map_info *map, map_word val1, map_wor
 	return r;
 }
 
+static inline map_word map_word_clr(struct map_info *map, map_word val1, map_word val2)
+{
+	map_word r;
+	int i;
+
+	for (i=0; i<map_words(map); i++) {
+		r.x[i] = val1.x[i] & ~val2.x[i];
+	}
+	return r;
+}
+
 static inline map_word map_word_or(struct map_info *map, map_word val1, map_word val2)
 {
 	map_word r;
@@ -273,6 +284,7 @@ static inline map_word map_word_or(struct map_info *map, map_word val1, map_word
 	}
 	return r;
 }
+
 #define map_word_andequal(m, a, b, z) map_word_equal(m, z, map_word_and(m, a, b))
 
 static inline int map_word_bitsset(struct map_info *map, map_word val1, map_word val2)
@@ -338,6 +350,7 @@ static inline map_word map_word_ff(struct map_info *map)
 	}
 	return r;
 }
+
 static inline map_word inline_map_read(struct map_info *map, unsigned long ofs)
 {
 	map_word r;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
new file mode 100644
index 000000000000..f0268b99c900
--- /dev/null
+++ b/include/linux/mtd/map.h
@@ -0,0 +1,412 @@
+
+/* Overhauled routines for dealing with different mmap regions of flash */
+/* $Id: map.h,v 1.46 2005/01/05 17:09:44 dwmw2 Exp $ */
+
+#ifndef __LINUX_MTD_MAP_H__
+#define __LINUX_MTD_MAP_H__
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/mtd/compatmac.h>
+#include <asm/unaligned.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/bug.h>
+
+#ifdef CONFIG_MTD_MAP_BANK_WIDTH_1
+#define map_bankwidth(map) 1
+#define map_bankwidth_is_1(map) (map_bankwidth(map) == 1)
+#define map_bankwidth_is_large(map) (0)
+#define map_words(map) (1)
+#define MAX_MAP_BANKWIDTH 1
+#else
+#define map_bankwidth_is_1(map) (0)
+#endif
+
+#ifdef CONFIG_MTD_MAP_BANK_WIDTH_2
+# ifdef map_bankwidth
+#  undef map_bankwidth
+#  define map_bankwidth(map) ((map)->bankwidth)
+# else
+#  define map_bankwidth(map) 2
+#  define map_bankwidth_is_large(map) (0)
+#  define map_words(map) (1)
+# endif
+#define map_bankwidth_is_2(map) (map_bankwidth(map) == 2)
+#undef MAX_MAP_BANKWIDTH
+#define MAX_MAP_BANKWIDTH 2
+#else
+#define map_bankwidth_is_2(map) (0)
+#endif
+
+#ifdef CONFIG_MTD_MAP_BANK_WIDTH_4
+# ifdef map_bankwidth
+#  undef map_bankwidth
+#  define map_bankwidth(map) ((map)->bankwidth)
+# else
+#  define map_bankwidth(map) 4
+#  define map_bankwidth_is_large(map) (0)
+#  define map_words(map) (1)
+# endif
+#define map_bankwidth_is_4(map) (map_bankwidth(map) == 4)
+#undef MAX_MAP_BANKWIDTH
+#define MAX_MAP_BANKWIDTH 4
+#else
+#define map_bankwidth_is_4(map) (0)
+#endif
+
+/* ensure we never evaluate anything shorted than an unsigned long
+ * to zero, and ensure we'll never miss the end of an comparison (bjd) */
+
+#define map_calc_words(map) ((map_bankwidth(map) + (sizeof(unsigned long)-1))/ sizeof(unsigned long))
+
+#ifdef CONFIG_MTD_MAP_BANK_WIDTH_8
+# ifdef map_bankwidth
+#  undef map_bankwidth
+#  define map_bankwidth(map) ((map)->bankwidth)
+#  if BITS_PER_LONG < 64
+#   undef map_bankwidth_is_large
+#   define map_bankwidth_is_large(map) (map_bankwidth(map) > BITS_PER_LONG/8)
+#   undef map_words
+#   define map_words(map) map_calc_words(map)
+#  endif
+# else
+#  define map_bankwidth(map) 8
+#  define map_bankwidth_is_large(map) (BITS_PER_LONG < 64)
+#  define map_words(map) map_calc_words(map)
+# endif
+#define map_bankwidth_is_8(map) (map_bankwidth(map) == 8)
+#undef MAX_MAP_BANKWIDTH
+#define MAX_MAP_BANKWIDTH 8
+#else
+#define map_bankwidth_is_8(map) (0)
+#endif
+
+#ifdef CONFIG_MTD_MAP_BANK_WIDTH_16
+# ifdef map_bankwidth
+#  undef map_bankwidth
+#  define map_bankwidth(map) ((map)->bankwidth)
+#  undef map_bankwidth_is_large
+#  define map_bankwidth_is_large(map) (map_bankwidth(map) > BITS_PER_LONG/8)
+#  undef map_words
+#  define map_words(map) map_calc_words(map)
+# else
+#  define map_bankwidth(map) 16
+#  define map_bankwidth_is_large(map) (1)
+#  define map_words(map) map_calc_words(map)
+# endif
+#define map_bankwidth_is_16(map) (map_bankwidth(map) == 16)
+#undef MAX_MAP_BANKWIDTH
+#define MAX_MAP_BANKWIDTH 16
+#else
+#define map_bankwidth_is_16(map) (0)
+#endif
+
+#ifdef CONFIG_MTD_MAP_BANK_WIDTH_32
+# ifdef map_bankwidth
+#  undef map_bankwidth
+#  define map_bankwidth(map) ((map)->bankwidth)
+#  undef map_bankwidth_is_large
+#  define map_bankwidth_is_large(map) (map_bankwidth(map) > BITS_PER_LONG/8)
+#  undef map_words
+#  define map_words(map) map_calc_words(map)
+# else
+#  define map_bankwidth(map) 32
+#  define map_bankwidth_is_large(map) (1)
+#  define map_words(map) map_calc_words(map)
+# endif
+#define map_bankwidth_is_32(map) (map_bankwidth(map) == 32)
+#undef MAX_MAP_BANKWIDTH
+#define MAX_MAP_BANKWIDTH 32
+#else
+#define map_bankwidth_is_32(map) (0)
+#endif
+
+#ifndef map_bankwidth
+#error "No bus width supported. What's the point?"
+#endif
+
+static inline int map_bankwidth_supported(int w)
+{
+	switch (w) {
+#ifdef CONFIG_MTD_MAP_BANK_WIDTH_1
+	case 1:
+#endif
+#ifdef CONFIG_MTD_MAP_BANK_WIDTH_2
+	case 2:
+#endif
+#ifdef CONFIG_MTD_MAP_BANK_WIDTH_4
+	case 4:
+#endif
+#ifdef CONFIG_MTD_MAP_BANK_WIDTH_8
+	case 8:
+#endif
+#ifdef CONFIG_MTD_MAP_BANK_WIDTH_16
+	case 16:
+#endif
+#ifdef CONFIG_MTD_MAP_BANK_WIDTH_32
+	case 32:
+#endif
+		return 1;
+
+	default:
+		return 0;
+	}
+}
+
+#define MAX_MAP_LONGS ( ((MAX_MAP_BANKWIDTH*8) + BITS_PER_LONG - 1) / BITS_PER_LONG )
+
+typedef union {
+	unsigned long x[MAX_MAP_LONGS];
+} map_word;
+
+/* The map stuff is very simple. You fill in your struct map_info with
+   a handful of routines for accessing the device, making sure they handle
+   paging etc. correctly if your device needs it. Then you pass it off
+   to a chip probe routine -- either JEDEC or CFI probe or both -- via
+   do_map_probe(). If a chip is recognised, the probe code will invoke the
+   appropriate chip driver (if present) and return a struct mtd_info.
+   At which point, you fill in the mtd->module with your own module 
+   address, and register it with the MTD core code. Or you could partition
+   it and register the partitions instead, or keep it for your own private
+   use; whatever.
+   
+   The mtd->priv field will point to the struct map_info, and any further
+   private data required by the chip driver is linked from the 
+   mtd->priv->fldrv_priv field. This allows the map driver to get at 
+   the destructor function map->fldrv_destroy() when it's tired
+   of living.
+*/
+
+struct map_info {
+	char *name;
+	unsigned long size;
+	unsigned long phys;
+#define NO_XIP (-1UL)
+
+	void __iomem *virt;
+	void *cached;
+
+	int bankwidth; /* in octets. This isn't necessarily the width
+		       of actual bus cycles -- it's the repeat interval
+		      in bytes, before you are talking to the first chip again.
+		      */
+
+#ifdef CONFIG_MTD_COMPLEX_MAPPINGS
+	map_word (*read)(struct map_info *, unsigned long);
+	void (*copy_from)(struct map_info *, void *, unsigned long, ssize_t);
+
+	void (*write)(struct map_info *, const map_word, unsigned long);
+	void (*copy_to)(struct map_info *, unsigned long, const void *, ssize_t);
+
+	/* We can perhaps put in 'point' and 'unpoint' methods, if we really
+	   want to enable XIP for non-linear mappings. Not yet though. */
+#endif
+	/* It's possible for the map driver to use cached memory in its
+	   copy_from implementation (and _only_ with copy_from).  However,
+	   when the chip driver knows some flash area has changed contents,
+	   it will signal it to the map driver through this routine to let
+	   the map driver invalidate the corresponding cache as needed.
+	   If there is no cache to care about this can be set to NULL. */
+	void (*inval_cache)(struct map_info *, unsigned long, ssize_t);
+
+	/* set_vpp() must handle being reentered -- enable, enable, disable 
+	   must leave it enabled. */
+	void (*set_vpp)(struct map_info *, int);
+
+	unsigned long map_priv_1;
+	unsigned long map_priv_2;
+	void *fldrv_priv;
+	struct mtd_chip_driver *fldrv;
+};
+
+struct mtd_chip_driver {
+	struct mtd_info *(*probe)(struct map_info *map);
+	void (*destroy)(struct mtd_info *);
+	struct module *module;
+	char *name;
+	struct list_head list;
+};
+
+void register_mtd_chip_driver(struct mtd_chip_driver *);
+void unregister_mtd_chip_driver(struct mtd_chip_driver *);
+
+struct mtd_info *do_map_probe(const char *name, struct map_info *map);
+void map_destroy(struct mtd_info *mtd);
+
+#define ENABLE_VPP(map) do { if(map->set_vpp) map->set_vpp(map, 1); } while(0)
+#define DISABLE_VPP(map) do { if(map->set_vpp) map->set_vpp(map, 0); } while(0)
+
+#define INVALIDATE_CACHED_RANGE(map, from, size) \
+	do { if(map->inval_cache) map->inval_cache(map, from, size); } while(0)
+
+
+static inline int map_word_equal(struct map_info *map, map_word val1, map_word val2)
+{
+	int i;
+	for (i=0; i<map_words(map); i++) {
+		if (val1.x[i] != val2.x[i])
+			return 0;
+	}
+	return 1;
+}
+
+static inline map_word map_word_and(struct map_info *map, map_word val1, map_word val2)
+{
+	map_word r;
+	int i;
+
+	for (i=0; i<map_words(map); i++) {
+		r.x[i] = val1.x[i] & val2.x[i];
+	}
+	return r;
+}
+
+static inline map_word map_word_or(struct map_info *map, map_word val1, map_word val2)
+{
+	map_word r;
+	int i;
+
+	for (i=0; i<map_words(map); i++) {
+		r.x[i] = val1.x[i] | val2.x[i];
+	}
+	return r;
+}
+#define map_word_andequal(m, a, b, z) map_word_equal(m, z, map_word_and(m, a, b))
+
+static inline int map_word_bitsset(struct map_info *map, map_word val1, map_word val2)
+{
+	int i;
+
+	for (i=0; i<map_words(map); i++) {
+		if (val1.x[i] & val2.x[i])
+			return 1;
+	}
+	return 0;
+}
+
+static inline map_word map_word_load(struct map_info *map, const void *ptr)
+{
+	map_word r;
+
+	if (map_bankwidth_is_1(map))
+		r.x[0] = *(unsigned char *)ptr;
+	else if (map_bankwidth_is_2(map))
+		r.x[0] = get_unaligned((uint16_t *)ptr);
+	else if (map_bankwidth_is_4(map))
+		r.x[0] = get_unaligned((uint32_t *)ptr);
+#if BITS_PER_LONG >= 64
+	else if (map_bankwidth_is_8(map))
+		r.x[0] = get_unaligned((uint64_t *)ptr);
+#endif
+	else if (map_bankwidth_is_large(map))
+		memcpy(r.x, ptr, map->bankwidth);
+
+	return r;
+}
+
+static inline map_word map_word_load_partial(struct map_info *map, map_word orig, const unsigned char *buf, int start, int len)
+{
+	int i;
+
+	if (map_bankwidth_is_large(map)) {
+		char *dest = (char *)&orig;
+		memcpy(dest+start, buf, len);
+	} else {
+		for (i=start; i < start+len; i++) {
+			int bitpos;
+#ifdef __LITTLE_ENDIAN
+			bitpos = i*8;
+#else /* __BIG_ENDIAN */
+			bitpos = (map_bankwidth(map)-1-i)*8;
+#endif
+			orig.x[0] &= ~(0xff << bitpos);
+			orig.x[0] |= buf[i-start] << bitpos;
+		}
+	}
+	return orig;
+}
+
+static inline map_word map_word_ff(struct map_info *map)
+{
+	map_word r;
+	int i;
+
+	for (i=0; i<map_words(map); i++) {
+		r.x[i] = ~0UL;
+	}
+	return r;
+}
+static inline map_word inline_map_read(struct map_info *map, unsigned long ofs)
+{
+	map_word r;
+
+	if (map_bankwidth_is_1(map))
+		r.x[0] = __raw_readb(map->virt + ofs);
+	else if (map_bankwidth_is_2(map))
+		r.x[0] = __raw_readw(map->virt + ofs);
+	else if (map_bankwidth_is_4(map))
+		r.x[0] = __raw_readl(map->virt + ofs);
+#if BITS_PER_LONG >= 64
+	else if (map_bankwidth_is_8(map))
+		r.x[0] = __raw_readq(map->virt + ofs);
+#endif
+	else if (map_bankwidth_is_large(map))
+		memcpy_fromio(r.x, map->virt+ofs, map->bankwidth);
+
+	return r;
+}
+
+static inline void inline_map_write(struct map_info *map, const map_word datum, unsigned long ofs)
+{
+	if (map_bankwidth_is_1(map))
+		__raw_writeb(datum.x[0], map->virt + ofs);
+	else if (map_bankwidth_is_2(map))
+		__raw_writew(datum.x[0], map->virt + ofs);
+	else if (map_bankwidth_is_4(map))
+		__raw_writel(datum.x[0], map->virt + ofs);
+#if BITS_PER_LONG >= 64
+	else if (map_bankwidth_is_8(map))
+		__raw_writeq(datum.x[0], map->virt + ofs);
+#endif
+	else if (map_bankwidth_is_large(map))
+		memcpy_toio(map->virt+ofs, datum.x, map->bankwidth);
+	mb();
+}
+
+static inline void inline_map_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	if (map->cached)
+		memcpy(to, (char *)map->cached + from, len);
+	else
+		memcpy_fromio(to, map->virt + from, len);
+}
+
+static inline void inline_map_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->virt + to, from, len);
+}
+
+#ifdef CONFIG_MTD_COMPLEX_MAPPINGS
+#define map_read(map, ofs) (map)->read(map, ofs)
+#define map_copy_from(map, to, from, len) (map)->copy_from(map, to, from, len)
+#define map_write(map, datum, ofs) (map)->write(map, datum, ofs)
+#define map_copy_to(map, to, from, len) (map)->copy_to(map, to, from, len)
+
+extern void simple_map_init(struct map_info *);
+#define map_is_linear(map) (map->phys != NO_XIP)
+
+#else
+#define map_read(map, ofs) inline_map_read(map, ofs)
+#define map_copy_from(map, to, from, len) inline_map_copy_from(map, to, from, len)
+#define map_write(map, datum, ofs) inline_map_write(map, datum, ofs)
+#define map_copy_to(map, to, from, len) inline_map_copy_to(map, to, from, len)
+
+
+#define simple_map_init(map) BUG_ON(!map_bankwidth_supported((map)->bankwidth))
+#define map_is_linear(map) (1)
+
+#endif /* !CONFIG_MTD_COMPLEX_MAPPINGS */
+
+#endif /* __LINUX_MTD_MAP_H__ */
