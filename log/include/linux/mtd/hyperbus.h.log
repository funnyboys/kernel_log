commit dcc7d3446a0fa19bd7e8074920b8f9ef3b7ec00c
Author: Vignesh Raghavendra <vigneshr@ti.com>
Date:   Tue Jun 25 13:27:44 2019 +0530

    mtd: Add support for HyperBus memory devices
    
    Cypress' HyperBus is Low Signal Count, High Performance Double Data Rate
    Bus interface between a host system master and one or more slave
    interfaces. HyperBus is used to connect microprocessor, microcontroller,
    or ASIC devices with random access NOR flash memory (called HyperFlash)
    or self refresh DRAM (called HyperRAM).
    
    Its a 8-bit data bus (DQ[7:0]) with  Read-Write Data Strobe (RWDS)
    signal and either Single-ended clock(3.0V parts) or Differential clock
    (1.8V parts). It uses ChipSelect lines to select b/w multiple slaves.
    At bus level, it follows a separate protocol described in HyperBus
    specification[1].
    
    HyperFlash follows CFI AMD/Fujitsu Extended Command Set (0x0002) similar
    to that of existing parallel NORs. Since HyperBus is x8 DDR bus,
    its equivalent to x16 parallel NOR flash with respect to bits per clock
    cycle. But HyperBus operates at >166MHz frequencies.
    HyperRAM provides direct random read/write access to flash memory
    array.
    
    But, HyperBus memory controllers seem to abstract implementation details
    and expose a simple MMIO interface to access connected flash.
    
    Add support for registering HyperFlash devices with MTD framework. MTD
    maps framework along with CFI chip support framework are used to support
    communicating with flash.
    
    Framework is modelled along the lines of spi-nor framework. HyperBus
    memory controller (HBMC) drivers calls hyperbus_register_device() to
    register a single HyperFlash device. HyperFlash core parses MMIO access
    information from DT, sets up the map_info struct, probes CFI flash and
    registers it with MTD framework.
    
    Some HBMC masters need calibration/training sequence[3] to be carried
    out, in order for DLL inside the controller to lock, by reading a known
    string/pattern. This is done by repeatedly reading CFI Query
    Identification String. Calibration needs to be done before trying to detect
    flash as part of CFI flash probe.
    
    HyperRAM is not supported at the moment.
    
    HyperBus specification can be found at[1]
    HyperFlash datasheet can be found at[2]
    
    [1] https://www.cypress.com/file/213356/download
    [2] https://www.cypress.com/file/213346/download
    [3] http://www.ti.com/lit/ug/spruid7b/spruid7b.pdf
        Table 12-5741. HyperFlash Access Sequence
    
    Signed-off-by: Vignesh Raghavendra <vigneshr@ti.com>
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>

diff --git a/include/linux/mtd/hyperbus.h b/include/linux/mtd/hyperbus.h
new file mode 100644
index 000000000000..2dfe65964f6e
--- /dev/null
+++ b/include/linux/mtd/hyperbus.h
@@ -0,0 +1,84 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2019 Texas Instruments Incorporated - http://www.ti.com/
+ */
+
+#ifndef __LINUX_MTD_HYPERBUS_H__
+#define __LINUX_MTD_HYPERBUS_H__
+
+#include <linux/mtd/map.h>
+
+enum hyperbus_memtype {
+	HYPERFLASH,
+	HYPERRAM,
+};
+
+/**
+ * struct hyperbus_device - struct representing HyperBus slave device
+ * @map: map_info struct for accessing MMIO HyperBus flash memory
+ * @np: pointer to HyperBus slave device node
+ * @mtd: pointer to MTD struct
+ * @ctlr: pointer to HyperBus controller struct
+ * @memtype: type of memory device: HyperFlash or HyperRAM
+ */
+
+struct hyperbus_device {
+	struct map_info map;
+	struct device_node *np;
+	struct mtd_info *mtd;
+	struct hyperbus_ctlr *ctlr;
+	enum hyperbus_memtype memtype;
+};
+
+/**
+ * struct hyperbus_ops - struct representing custom HyperBus operations
+ * @read16: read 16 bit of data from flash in a single burst. Used to read
+ *          from non default address space, such as ID/CFI space
+ * @write16: write 16 bit of data to flash in a single burst. Used to
+ *           send cmd to flash or write single 16 bit word at a time.
+ * @copy_from: copy data from flash memory
+ * @copy_to: copy data to flash memory
+ * @calibrate: calibrate HyperBus controller
+ */
+
+struct hyperbus_ops {
+	u16 (*read16)(struct hyperbus_device *hbdev, unsigned long addr);
+	void (*write16)(struct hyperbus_device *hbdev,
+			unsigned long addr, u16 val);
+	void (*copy_from)(struct hyperbus_device *hbdev, void *to,
+			  unsigned long from, ssize_t len);
+	void (*copy_to)(struct hyperbus_device *dev, unsigned long to,
+			const void *from, ssize_t len);
+	int (*calibrate)(struct hyperbus_device *dev);
+};
+
+/**
+ * struct hyperbus_ctlr - struct representing HyperBus controller
+ * @dev: pointer to HyperBus controller device
+ * @calibrated: flag to indicate ctlr calibration sequence is complete
+ * @ops: HyperBus controller ops
+ */
+struct hyperbus_ctlr {
+	struct device *dev;
+	bool calibrated;
+
+	const struct hyperbus_ops *ops;
+};
+
+/**
+ * hyperbus_register_device - probe and register a HyperBus slave memory device
+ * @hbdev: hyperbus_device struct with dev, np and ctlr field populated
+ *
+ * Return: 0 for success, others for failure.
+ */
+int hyperbus_register_device(struct hyperbus_device *hbdev);
+
+/**
+ * hyperbus_unregister_device - deregister HyperBus slave memory device
+ * @hbdev: hyperbus_device to be unregistered
+ *
+ * Return: 0 for success, others for failure.
+ */
+int hyperbus_unregister_device(struct hyperbus_device *hbdev);
+
+#endif /* __LINUX_MTD_HYPERBUS_H__ */
