commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index bfe9e10fae04..1e517961d0ba 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -1,12 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  *  linux/include/linux/mtd/onenand.h
  *
  *  Copyright © 2005-2009 Samsung Electronics
  *  Kyungmin Park <kyungmin.park@samsung.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #ifndef __LINUX_MTD_ONENAND_H

commit bfd15c904ac584dfacfafb1e382c158f6db73d2a
Author: Frieder Schrempf <frieder.schrempf@kontron.de>
Date:   Wed Apr 17 12:36:35 2019 +0000

    mtd: onenand: Store bad block marker position in chip struct
    
    The information about where the manufacturer puts the bad block
    markers inside the bad block and in the OOB data is stored in
    different places. Let's move this information to the chip struct,
    as we did it for rawnand.
    
    Signed-off-by: Frieder Schrempf <frieder.schrempf@kontron.de>
    Reviewed-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 0aaa98b219a4..bfe9e10fae04 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -94,6 +94,7 @@ struct onenand_chip {
 	unsigned int		technology;
 	unsigned int		density_mask;
 	unsigned int		options;
+	unsigned int		badblockpos;
 
 	unsigned int		erase_shift;
 	unsigned int		page_shift;
@@ -188,6 +189,8 @@ struct onenand_chip {
 /* Check byte access in OneNAND */
 #define ONENAND_CHECK_BYTE_ACCESS(addr)		(addr & 0x1)
 
+#define ONENAND_BADBLOCK_POS		0
+
 /*
  * Options bits
  */

commit a411679fb5fd7ee2df64a55c23c81538ceeb6d06
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Mon Dec 7 22:46:45 2015 +0100

    mtd: onenand: switch to mtd_ooblayout_ops
    
    Implementing the mtd_ooblayout_ops interface is the new way of exposing
    ECC/OOB layout to MTD users. Modify the onenand drivers to switch to this
    approach.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 4596503c9da9..0aaa98b219a4 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -80,7 +80,6 @@ struct onenand_bufferram {
  * @page_buf:		[INTERN] page main data buffer
  * @oob_buf:		[INTERN] page oob data buffer
  * @subpagesize:	[INTERN] holds the subpagesize
- * @ecclayout:		[REPLACEABLE] the default ecc placement scheme
  * @bbm:		[REPLACEABLE] pointer to Bad Block Management
  * @priv:		[OPTIONAL] pointer to private chip date
  */
@@ -134,7 +133,6 @@ struct onenand_chip {
 #endif
 
 	int			subpagesize;
-	struct nand_ecclayout	*ecclayout;
 
 	void			*bbm;
 

commit e1c10243df92822954b9b5e04d12dd2f23a39652
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Wed Jun 22 14:16:49 2011 +0900

    mtd: OneNAND: Detect the correct NOP when 4KiB pagesize
    
    There are two different 4KiB pagesize chips
    KFM4G16Q4M series have NOP 4 with version ID 0x0131
    But KFM4G16Q5M has NOP 1 with versoin ID 0x013e
    
    Note that Q5M means that it has NOP 1.
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 52b6f187bf49..4596503c9da9 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -184,6 +184,9 @@ struct onenand_chip {
 #define ONENAND_IS_CACHE_PROGRAM(this)					\
 	(this->options & ONENAND_HAS_CACHE_PROGRAM)
 
+#define ONENAND_IS_NOP_1(this)						\
+	(this->options & ONENAND_HAS_NOP_1)
+
 /* Check byte access in OneNAND */
 #define ONENAND_CHECK_BYTE_ACCESS(addr)		(addr & 0x1)
 
@@ -195,6 +198,7 @@ struct onenand_chip {
 #define ONENAND_HAS_2PLANE		(0x0004)
 #define ONENAND_HAS_4KB_PAGE		(0x0008)
 #define ONENAND_HAS_CACHE_PROGRAM	(0x0010)
+#define ONENAND_HAS_NOP_1		(0x0020)
 #define ONENAND_SKIP_UNLOCK_CHECK	(0x0100)
 #define ONENAND_PAGEBUF_ALLOC		(0x1000)
 #define ONENAND_OOBBUF_ALLOC		(0x2000)

commit b3dcfd35244e1cb8dc8dfa5c05013b133dbb437a
Author: Roman Tereshonkov <roman.tereshonkov@nokia.com>
Date:   Thu Feb 17 13:44:41 2011 +0200

    mtd: onenand: add new option to control initial onenand unlocking
    
    A new option ONENAND_SKIP_INITIAL_UNLOCKING is added. This allows
    to disable initial onenand unlocking when the driver is initialized.
    
    Signed-off-by: Roman Tereshonkov <roman.tereshonkov@nokia.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index ae418e41d8f5..52b6f187bf49 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -198,6 +198,7 @@ struct onenand_chip {
 #define ONENAND_SKIP_UNLOCK_CHECK	(0x0100)
 #define ONENAND_PAGEBUF_ALLOC		(0x1000)
 #define ONENAND_OOBBUF_ALLOC		(0x2000)
+#define ONENAND_SKIP_INITIAL_UNLOCKING	(0x4000)
 
 #define ONENAND_IS_4KB_PAGE(this)					\
 	(this->options & ONENAND_HAS_4KB_PAGE)

commit cf24dc85ff29a41abd8e73730e5feb22b2666bd3
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Fri Feb 19 15:39:52 2010 +0100

    mtd: OneNAND: add enable / disable methods to onenand_chip
    
    Add enable / disable methods called from get_device() / release_device().
    These can be used, for example, to allow the driver to prevent the voltage
    regulator from being put to sleep while OneNAND is in use.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 6da3fe314828..ae418e41d8f5 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -118,6 +118,8 @@ struct onenand_chip {
 	int (*chip_probe)(struct mtd_info *mtd);
 	int (*block_markbad)(struct mtd_info *mtd, loff_t ofs);
 	int (*scan_bbt)(struct mtd_info *mtd);
+	int (*enable)(struct mtd_info *mtd);
+	int (*disable)(struct mtd_info *mtd);
 
 	struct completion	complete;
 	int			irq;

commit 3e3198f1adda8e0fbd499bde806781237d6c841f
Author: Roman Tereshonkov <roman.tereshonkov@nokia.com>
Date:   Wed Nov 3 12:55:19 2010 +0200

    mtd: onenand: add option and variable for cache program feature
    
    A new option is added for cache program feature. A new variable
    ongoing is introduced for onenand_chip to handle the multi-command
    cache program operation.
    
    Signed-off-by: Roman Tereshonkov <roman.tereshonkov@nokia.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 0c8815bfae1c..6da3fe314828 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -137,6 +137,14 @@ struct onenand_chip {
 	void			*bbm;
 
 	void			*priv;
+
+	/*
+	 * Shows that the current operation is composed
+	 * of sequence of commands. For example, cache program.
+	 * Such command status OnGo bit is checked at the end of
+	 * sequence.
+	 */
+	unsigned int		ongoing;
 };
 
 /*
@@ -171,6 +179,9 @@ struct onenand_chip {
 #define ONENAND_IS_2PLANE(this)			(0)
 #endif
 
+#define ONENAND_IS_CACHE_PROGRAM(this)					\
+	(this->options & ONENAND_HAS_CACHE_PROGRAM)
+
 /* Check byte access in OneNAND */
 #define ONENAND_CHECK_BYTE_ACCESS(addr)		(addr & 0x1)
 
@@ -181,6 +192,7 @@ struct onenand_chip {
 #define ONENAND_HAS_UNLOCK_ALL		(0x0002)
 #define ONENAND_HAS_2PLANE		(0x0004)
 #define ONENAND_HAS_4KB_PAGE		(0x0008)
+#define ONENAND_HAS_CACHE_PROGRAM	(0x0010)
 #define ONENAND_SKIP_UNLOCK_CHECK	(0x0100)
 #define ONENAND_PAGEBUF_ALLOC		(0x1000)
 #define ONENAND_OOBBUF_ALLOC		(0x2000)

commit ad0d363b8fb7559a410483635349e22de6727988
Author: Kyungmin Park <kmpark@infradead.org>
Date:   Fri May 28 11:03:11 2010 +0900

    mtd: OneNAND: Introduce chip_probe function
    
    Samsung SoCs use the own OneNAND controler and detect OneNAND chip at power on.
    To use this feature, introduce the chip_probe function.
    
    Also remove workaround for Samsung SoCs.
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index c26ff86ad08a..0c8815bfae1c 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -68,6 +68,7 @@ struct onenand_bufferram {
  * @write_word:		[REPLACEABLE] hardware specific function for write
  *			register of OneNAND
  * @mmcontrol:		sync burst read function
+ * @chip_probe:		[REPLACEABLE] hardware specific function for chip probe
  * @block_markbad:	function to mark a block as bad
  * @scan_bbt:		[REPLACEALBE] hardware specific function for scanning
  *			Bad block Table
@@ -114,6 +115,7 @@ struct onenand_chip {
 	unsigned short (*read_word)(void __iomem *addr);
 	void (*write_word)(unsigned short value, void __iomem *addr);
 	void (*mmcontrol)(struct mtd_info *mtd, int sync_read);
+	int (*chip_probe)(struct mtd_info *mtd);
 	int (*block_markbad)(struct mtd_info *mtd, loff_t ofs);
 	int (*scan_bbt)(struct mtd_info *mtd);
 

commit 3328dc315914aa6db486da2ceb021b6f0b36b877
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Wed Apr 28 17:46:47 2010 +0200

    mtd: onenand: add new callback for bufferram read
    
    This patch adds a new callback for the underlying drivers, which is
    called instead of accessing the buffer ram directly. This callback will
    be used by Samsung OneNAND driver to implement DMA transfers on S5PC110
    SoC.
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 9b43268224a7..c26ff86ad08a 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -212,6 +212,8 @@ struct mtd_partition;
 
 struct onenand_platform_data {
 	void		(*mmcontrol)(struct mtd_info *mtd, int sync_read);
+	int		(*read_bufferram)(struct mtd_info *mtd, int area,
+			unsigned char *buffer, int offset, size_t count);
 	struct mtd_partition *parts;
 	unsigned int	nr_parts;
 };

commit 4a8ce0b030716b95004a4ace969953bc3ad7d2fe
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Wed Apr 28 17:46:46 2010 +0200

    mtd: onenand: allocate verify buffer in the core
    
    This patch extends OneNAND core code with support for OneNAND verify
    write check. This is done by allocating the buffer for verify read
    directly from the core code.
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index c9a3c3596b68..9b43268224a7 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -125,6 +125,9 @@ struct onenand_chip {
 	flstate_t		state;
 	unsigned char		*page_buf;
 	unsigned char		*oob_buf;
+#ifdef CONFIG_MTD_ONENAND_VERIFY_WRITE
+	unsigned char		*verify_buf;
+#endif
 
 	int			subpagesize;
 	struct nand_ecclayout	*ecclayout;

commit 6a88c47bd528cb0f82692986a3ca57b3695d9c60
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Wed Apr 28 17:46:45 2010 +0200

    mtd: onenand: add support for chips with 4KiB page size
    
    This patch adds support for OneNAND chips that have 4KiB page size.
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 5509eb06b326..c9a3c3596b68 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -175,10 +175,14 @@ struct onenand_chip {
 #define ONENAND_HAS_CONT_LOCK		(0x0001)
 #define ONENAND_HAS_UNLOCK_ALL		(0x0002)
 #define ONENAND_HAS_2PLANE		(0x0004)
+#define ONENAND_HAS_4KB_PAGE		(0x0008)
 #define ONENAND_SKIP_UNLOCK_CHECK	(0x0100)
 #define ONENAND_PAGEBUF_ALLOC		(0x1000)
 #define ONENAND_OOBBUF_ALLOC		(0x2000)
 
+#define ONENAND_IS_4KB_PAGE(this)					\
+	(this->options & ONENAND_HAS_4KB_PAGE)
+
 /*
  * OneNAND Flash Manufacturer ID Codes
  */

commit 3cf602532c535ec655725e9833378e04c9fd7783
Author: Amul Kumar Saha <amul.saha@samsung.com>
Date:   Wed Oct 21 17:00:05 2009 +0530

    mtd: OneNAND OTP support rework
    
    What is OTP in OneNAND?
    The device includes,
    1. one block-sized OTP (One Time Programmable) area and
    2. user-controlled 1st block OTP(Block 0)
    that can be used to increase system security or to provide
    identification capabilities.
    
    What is done?
    In OneNAND, one block of the NAND Array is set aside as an OTP
    memory area, and 1st Block (Block 0) can be used as OTP area.
    This area, available to the user, can be configured and locked
    with secured user information. The OTP block can be read,
    programmed and locked using the same operations as any other NAND
    Flash Array memory block. After issuing an OTP-Lock, OTP block
    cannot be erased. OTP block is fully-guaranteed to be a good
    block.
    
    Why it is done?
    Locking the 1st Block OTP has the effect of a 'Write-protect' to
    guard against accidental re-programming of data stored in the 1st
    block and OTP Block.
    
    Which problem it solves?
    OTP support is provided in the existing implementation of
    OneNAND/Flex-OneNAND driver, but it is not working with OneNAND
    devices. Have observed the following in current OTP OneNAND Implmentation,
    1. DataSheet specific sequence to lock the OTP Area is not followed.
    2. Certain functions are quiet generic to cope with OTP specific activity.
    This patch re-implements OTP support for OneNAND device.
    
    How it is done?
    For all blocks, 8th word is available to the user.
    However, in case of OTP Block, 8th word of sector 0, page 0 is reserved as
    OTP Locking Bit area. Therefore, in case of OTP Block, user usage on this
    area is prohibited. Condition specific values are entered in the 8th word,
    sector0, page 0 of the OTP block during the process of issuing an OTP-Lock.
    The possible conditions are:
    1. Only 1st Block Lock
    2. Only OTP Block Lock
    3. Lock both the 1st Block and the OTP Block
    
    What Other feature additions have been done in this patch?
    This patch adds feature for:
    1. Only 1st Block Lock
    2. Lock both the 1st Block and the OTP Blocks
    
    Re-implemented OTP support for OneNAND
    Added following features to OneNAND
            1. Lock only 1st Block in OneNAND
            2. Lock BOTH 1st Block and OTP Block in OneNAND
    
    [comments were slightly tweaked by Artem]
    
    Signed-off-by: Amul Kumar Saha <amul.saha@samsung.com>
    Reviewed-by: Adrian Hunter <adrian.hunter@nokia.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index f57e29e17bb0..5509eb06b326 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -1,7 +1,7 @@
 /*
  *  linux/include/linux/mtd/onenand.h
  *
- *  Copyright (C) 2005-2007 Samsung Electronics
+ *  Copyright © 2005-2009 Samsung Electronics
  *  Kyungmin Park <kyungmin.park@samsung.com>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -137,6 +137,8 @@ struct onenand_chip {
 /*
  * Helper macros
  */
+#define ONENAND_PAGES_PER_BLOCK        (1<<6)
+
 #define ONENAND_CURRENT_BUFFERRAM(this)		(this->bufferram_index)
 #define ONENAND_NEXT_BUFFERRAM(this)		(this->bufferram_index ^ 1)
 #define ONENAND_SET_NEXT_BUFFERRAM(this)	(this->bufferram_index ^= 1)

commit 30631cb82d5c6c662d5ec682beaa834c1f9f0987
Author: Alessandro Rubini <rubini@unipv.it>
Date:   Sun Sep 20 23:28:14 2009 +0200

    mtd: unify status enum from three headers
    
    nand.h, onenand.h and flashchip.h defined enumeration types
    for chip status using the same symbolic names. This prevented
    a board file to include more than one of them. In particular,
    no nand and onenand platform devices could live in the same file.
    This patch augments flashchip.h with a few status values in order
    to cover all cases, so nand.h and onenand.h can use flstate_t
    without declaring their own status enum.
    
    Signed-off-by: Alessandro Rubini <rubini@unipv.it>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 4e49f3350678..f57e29e17bb0 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -14,6 +14,7 @@
 
 #include <linux/spinlock.h>
 #include <linux/completion.h>
+#include <linux/mtd/flashchip.h>
 #include <linux/mtd/onenand_regs.h>
 #include <linux/mtd/bbm.h>
 
@@ -25,22 +26,6 @@ extern int onenand_scan(struct mtd_info *mtd, int max_chips);
 /* Free resources held by the OneNAND device */
 extern void onenand_release(struct mtd_info *mtd);
 
-/*
- * onenand_state_t - chip states
- * Enumeration for OneNAND flash chip state
- */
-typedef enum {
-	FL_READY,
-	FL_READING,
-	FL_WRITING,
-	FL_ERASING,
-	FL_SYNCING,
-	FL_LOCKING,
-	FL_RESETING,
-	FL_OTPING,
-	FL_PM_SUSPENDED,
-} onenand_state_t;
-
 /**
  * struct onenand_bufferram - OneNAND BufferRAM Data
  * @blockpage:		block & page address in BufferRAM
@@ -137,7 +122,7 @@ struct onenand_chip {
 
 	spinlock_t		chip_lock;
 	wait_queue_head_t	wq;
-	onenand_state_t		state;
+	flstate_t		state;
 	unsigned char		*page_buf;
 	unsigned char		*oob_buf;
 

commit 778dbcc1ebea6f9a560020110987449bf4607e5f
Author: Magnus Damm <damm@igel.co.jp>
Date:   Fri Sep 18 12:51:44 2009 -0700

    mtd: onenand: make onenand/generic.c more generic
    
    Remove the ARM dependency from the generic "onenand" platform device
    driver.  This change makes the driver useful for other architectures as
    well.  Needed for the SuperH kfr2r09 board.
    
    Apart from the obvious Kconfig bits, the most important change is the move
    away from ARM specific includes and platform data.  Together with this
    change the only in-tree board code gets an update, and the driver name is
    also changed gracefully break potential out of tree drivers.
    
    The driver is also updated to allow NULL as platform data together with a
    few changes to make use of resource_size() and dev_name().
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Kyungmin Park <kmpark@infradead.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 8ed873374381..4e49f3350678 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -214,4 +214,12 @@ unsigned onenand_block(struct onenand_chip *this, loff_t addr);
 loff_t onenand_addr(struct onenand_chip *this, int block);
 int flexonenand_region(struct mtd_info *mtd, loff_t addr);
 
+struct mtd_partition;
+
+struct onenand_platform_data {
+	void		(*mmcontrol)(struct mtd_info *mtd, int sync_read);
+	struct mtd_partition *parts;
+	unsigned int	nr_parts;
+};
+
 #endif	/* __LINUX_MTD_ONENAND_H */

commit 31bb999ee73748068ddc271dd99b22dcc418efe3
Author: Kyungmin Park <kmpark@infradead.org>
Date:   Tue May 12 13:46:57 2009 -0700

    mtd: onenand: add bbt_wait & unlock_all as replaceable for some platform
    
    Add bbt_wait & unlock_all as replaceable for some platform such as
      s3c64xx s3c64xx has its own OneNAND controller and another interface
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 9aab82c1c743..8ed873374381 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -74,6 +74,8 @@ struct onenand_bufferram {
  * @command:		[REPLACEABLE] hardware specific function for writing
  *			commands to the chip
  * @wait:		[REPLACEABLE] hardware specific function for wait on ready
+ * @bbt_wait:		[REPLACEABLE] hardware specific function for bbt wait on ready
+ * @unlock_all:		[REPLACEABLE] hardware specific function for unlock all
  * @read_bufferram:	[REPLACEABLE] hardware specific function for BufferRAM Area
  * @write_bufferram:	[REPLACEABLE] hardware specific function for BufferRAM Area
  * @read_word:		[REPLACEABLE] hardware specific function for read
@@ -118,6 +120,8 @@ struct onenand_chip {
 
 	int (*command)(struct mtd_info *mtd, int cmd, loff_t address, size_t len);
 	int (*wait)(struct mtd_info *mtd, int state);
+	int (*bbt_wait)(struct mtd_info *mtd, int state);
+	void (*unlock_all)(struct mtd_info *mtd);
 	int (*read_bufferram)(struct mtd_info *mtd, int area,
 			unsigned char *buffer, int offset, size_t count);
 	int (*write_bufferram)(struct mtd_info *mtd, int area,
@@ -184,6 +188,7 @@ struct onenand_chip {
 #define ONENAND_HAS_CONT_LOCK		(0x0001)
 #define ONENAND_HAS_UNLOCK_ALL		(0x0002)
 #define ONENAND_HAS_2PLANE		(0x0004)
+#define ONENAND_SKIP_UNLOCK_CHECK	(0x0100)
 #define ONENAND_PAGEBUF_ALLOC		(0x1000)
 #define ONENAND_OOBBUF_ALLOC		(0x2000)
 

commit 5988af2319781bc8e0ce418affec4e09cfa77907
Author: Rohit Hagargundgi <h.rohit@samsung.com>
Date:   Tue May 12 13:46:57 2009 -0700

    mtd: Flex-OneNAND support
    
    Add support for Samsung Flex-OneNAND devices.
    
    Flex-OneNAND combines SLC and MLC technologies into a single device.
    SLC area provides increased reliability and speed, suitable for storing
    code such as bootloader, kernel and root file system.  MLC area
    provides high density and is suitable for storing user data.
    
    SLC and MLC regions can be configured through kernel parameter.
    
    [akpm@linux-foundation.org: export flexoand_region and onenand_addr]
    Signed-off-by: Rohit Hagargundgi <h.rohit@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Vishak G <vishak.g@samsung.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 0fa3ac4ad576..9aab82c1c743 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -17,6 +17,7 @@
 #include <linux/mtd/onenand_regs.h>
 #include <linux/mtd/bbm.h>
 
+#define MAX_DIES		2
 #define MAX_BUFFERRAM		2
 
 /* Scan and identify a OneNAND device */
@@ -51,7 +52,12 @@ struct onenand_bufferram {
 /**
  * struct onenand_chip - OneNAND Private Flash Chip Data
  * @base:		[BOARDSPECIFIC] address to access OneNAND
+ * @dies:		[INTERN][FLEX-ONENAND] number of dies on chip
+ * @boundary:		[INTERN][FLEX-ONENAND] Boundary of the dies
+ * @diesize:		[INTERN][FLEX-ONENAND] Size of the dies
  * @chipsize:		[INTERN] the size of one chip for multichip arrays
+ *			FIXME For Flex-OneNAND, chipsize holds maximum possible
+ *			device size ie when all blocks are considered MLC
  * @device_id:		[INTERN] device ID
  * @density_mask:	chip density, used for DDP devices
  * @verstion_id:	[INTERN] version ID
@@ -92,9 +98,13 @@ struct onenand_bufferram {
  */
 struct onenand_chip {
 	void __iomem		*base;
+	unsigned		dies;
+	unsigned		boundary[MAX_DIES];
+	loff_t			diesize[MAX_DIES];
 	unsigned int		chipsize;
 	unsigned int		device_id;
 	unsigned int		version_id;
+	unsigned int		technology;
 	unsigned int		density_mask;
 	unsigned int		options;
 
@@ -145,6 +155,8 @@ struct onenand_chip {
 #define ONENAND_SET_BUFFERRAM0(this)		(this->bufferram_index = 0)
 #define ONENAND_SET_BUFFERRAM1(this)		(this->bufferram_index = 1)
 
+#define FLEXONENAND(this)						\
+	(this->device_id & DEVICE_IS_FLEXONENAND)
 #define ONENAND_GET_SYS_CFG1(this)					\
 	(this->read_word(this->base + ONENAND_REG_SYS_CFG1))
 #define ONENAND_SET_SYS_CFG1(v, this)					\
@@ -153,6 +165,9 @@ struct onenand_chip {
 #define ONENAND_IS_DDP(this)						\
 	(this->device_id & ONENAND_DEVICE_IS_DDP)
 
+#define ONENAND_IS_MLC(this)						\
+	(this->technology & ONENAND_TECHNOLOGY_IS_MLC)
+
 #ifdef CONFIG_MTD_ONENAND_2X_PROGRAM
 #define ONENAND_IS_2PLANE(this)						\
 	(this->options & ONENAND_HAS_2PLANE)
@@ -190,5 +205,8 @@ struct onenand_manufacturers {
 
 int onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from,
 			 struct mtd_oob_ops *ops);
+unsigned onenand_block(struct onenand_chip *this, loff_t addr);
+loff_t onenand_addr(struct onenand_chip *this, int block);
+int flexonenand_region(struct mtd_info *mtd, loff_t addr);
 
 #endif	/* __LINUX_MTD_ONENAND_H */

commit ee8f37688966ab1438d0cf42e0cb7c6595d9592c
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Tue May 5 11:04:19 2009 +0300

    mtd: OneNAND: add support for OneNAND manufactured by Numonyx
    
    In addition to adding the Numonyx manufacturer code, this patch
    also ensures 'sync. write' is disabled when reading identification
    data - something that the Numonyx chip objects to, but the
    Samsung chip seems to ignore.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 9aa2a9149b58..0fa3ac4ad576 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -176,6 +176,7 @@ struct onenand_chip {
  * OneNAND Flash Manufacturer ID Codes
  */
 #define ONENAND_MFR_SAMSUNG	0xec
+#define ONENAND_MFR_NUMONYX	0x20
 
 /**
  * struct onenand_manufacturers - NAND Flash Manufacturer ID Structure

commit 607d1cb1042657177bf72247eeb85c0d8416bd51
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon Apr 14 17:20:38 2008 +0300

    [MTD] [OneNAND] proper onenand_bbt_read_oob() prototype
    
    This patch adds a proper prototype for onenand_bbt_read_oob() in
    include/linux/mtd/onenand.h
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index fd0a260e070b..9aa2a9149b58 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -187,4 +187,7 @@ struct onenand_manufacturers {
         char *name;
 };
 
+int onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from,
+			 struct mtd_oob_ops *ops);
+
 #endif	/* __LINUX_MTD_ONENAND_H */

commit ee9745fcf214272b7cdd9d320d044cf433ee958e
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Sat Jun 30 13:57:49 2007 +0900

    [MTD] [OneNAND] 2X program support
    
    The 2X Program is an extension of Program Operation.
    
    Since the device is equipped with two DataRAMs, and two-plane NAND Flash
    memory array, these two component enables simultaneous program of 4KiB.
    Plane1 has only even blocks such as block0, block2, block4 while Plane2
    has only odd blocks such as block1, block3, block5.
    So MTD regards it as 4KiB page size and 256KiB block size
    
    Now the following chips support it. (KFXXX16Q2M)
    Demux: KFG2G16Q2M, KFH4G16Q2M, KFW8G16Q2M,
    Mux:   KFM2G16Q2M, KFN4G16Q2M,
    
    And more recent chips
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index a56d24ada505..fd0a260e070b 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -60,6 +60,7 @@ struct onenand_bufferram {
  * @erase_shift:	[INTERN] number of address bits in a block
  * @page_shift:		[INTERN] number of address bits in a page
  * @page_mask:		[INTERN] a page per block mask
+ * @writesize:		[INTERN] a real page size
  * @bufferram_index:	[INTERN] BufferRAM index
  * @bufferram:		[INTERN] BufferRAM info
  * @readw:		[REPLACEABLE] hardware specific function for read short
@@ -100,6 +101,7 @@ struct onenand_chip {
 	unsigned int		erase_shift;
 	unsigned int		page_shift;
 	unsigned int		page_mask;
+	unsigned int		writesize;
 
 	unsigned int		bufferram_index;
 	struct onenand_bufferram	bufferram[MAX_BUFFERRAM];
@@ -140,6 +142,8 @@ struct onenand_chip {
 #define ONENAND_NEXT_BUFFERRAM(this)		(this->bufferram_index ^ 1)
 #define ONENAND_SET_NEXT_BUFFERRAM(this)	(this->bufferram_index ^= 1)
 #define ONENAND_SET_PREV_BUFFERRAM(this)	(this->bufferram_index ^= 1)
+#define ONENAND_SET_BUFFERRAM0(this)		(this->bufferram_index = 0)
+#define ONENAND_SET_BUFFERRAM1(this)		(this->bufferram_index = 1)
 
 #define ONENAND_GET_SYS_CFG1(this)					\
 	(this->read_word(this->base + ONENAND_REG_SYS_CFG1))
@@ -149,6 +153,13 @@ struct onenand_chip {
 #define ONENAND_IS_DDP(this)						\
 	(this->device_id & ONENAND_DEVICE_IS_DDP)
 
+#ifdef CONFIG_MTD_ONENAND_2X_PROGRAM
+#define ONENAND_IS_2PLANE(this)						\
+	(this->options & ONENAND_HAS_2PLANE)
+#else
+#define ONENAND_IS_2PLANE(this)			(0)
+#endif
+
 /* Check byte access in OneNAND */
 #define ONENAND_CHECK_BYTE_ACCESS(addr)		(addr & 0x1)
 
@@ -157,6 +168,7 @@ struct onenand_chip {
  */
 #define ONENAND_HAS_CONT_LOCK		(0x0001)
 #define ONENAND_HAS_UNLOCK_ALL		(0x0002)
+#define ONENAND_HAS_2PLANE		(0x0004)
 #define ONENAND_PAGEBUF_ALLOC		(0x1000)
 #define ONENAND_OOBBUF_ALLOC		(0x2000)
 

commit 470bc844361b238bcbe6a07ba47d51fca25f2742
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Fri Mar 9 10:08:11 2007 +0900

    [MTD] [OneNAND] Classify the page data and oob buffer
    
    Classify the page data and oob buffer
    and it prevents the memory fragementation (writesize + oobsize)
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index d8af8a95e58d..a56d24ada505 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -82,7 +82,8 @@ struct onenand_bufferram {
  * @wq:			[INTERN] wait queue to sleep on if a OneNAND
  *			operation is in progress
  * @state:		[INTERN] the current state of the OneNAND device
- * @page_buf:		data buffer
+ * @page_buf:		[INTERN] page main data buffer
+ * @oob_buf:		[INTERN] page oob data buffer
  * @subpagesize:	[INTERN] holds the subpagesize
  * @ecclayout:		[REPLACEABLE] the default ecc placement scheme
  * @bbm:		[REPLACEABLE] pointer to Bad Block Management
@@ -122,6 +123,7 @@ struct onenand_chip {
 	wait_queue_head_t	wq;
 	onenand_state_t		state;
 	unsigned char		*page_buf;
+	unsigned char		*oob_buf;
 
 	int			subpagesize;
 	struct nand_ecclayout	*ecclayout;
@@ -156,6 +158,7 @@ struct onenand_chip {
 #define ONENAND_HAS_CONT_LOCK		(0x0001)
 #define ONENAND_HAS_UNLOCK_ALL		(0x0002)
 #define ONENAND_PAGEBUF_ALLOC		(0x1000)
+#define ONENAND_OOBBUF_ALLOC		(0x2000)
 
 /*
  * OneNAND Flash Manufacturer ID Codes

commit abf3c0f23df6686a984efc8fae7277fcdaffaa32
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Fri Feb 2 09:29:36 2007 +0900

    [MTD] OneNAND: Reduce internal BufferRAM operations
    
    It use blockpage instead of a pair (block, page). It can also cover a small chunk access. 0x00, 0x20, 0x40 and so on.
    
    And in JFFS2 behavior, sometimes it reads two pages alternatively.
    e.g., It first reads A page, B page and A page.
    So we check another bufferram to find requested page.
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index a5e6c4bf7af3..d8af8a95e58d 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -42,14 +42,10 @@ typedef enum {
 
 /**
  * struct onenand_bufferram - OneNAND BufferRAM Data
- * @block:		block address in BufferRAM
- * @page:		page address in BufferRAM
- * @valid:		valid flag
+ * @blockpage:		block & page address in BufferRAM
  */
 struct onenand_bufferram {
-	int block;
-	int page;
-	int valid;
+	int	blockpage;
 };
 
 /**

commit 9bfbc9b24f663b15149874a94a69ba89b3b7e44c
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Wed Jan 31 14:25:21 2007 +0900

    [MTD] OneNAND: Remove unused fields
    
    - Remove unused fields
    - Fix typo
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 60b3534de74d..a5e6c4bf7af3 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -63,7 +63,6 @@ struct onenand_bufferram {
  *			partly be set to inform onenand_scan about
  * @erase_shift:	[INTERN] number of address bits in a block
  * @page_shift:		[INTERN] number of address bits in a page
- * @ppb_shift:		[INTERN] number of address bits in a pages per block
  * @page_mask:		[INTERN] a page per block mask
  * @bufferram_index:	[INTERN] BufferRAM index
  * @bufferram:		[INTERN] BufferRAM info
@@ -103,7 +102,6 @@ struct onenand_chip {
 
 	unsigned int		erase_shift;
 	unsigned int		page_shift;
-	unsigned int		ppb_shift;	/* Pages per block shift */
 	unsigned int		page_mask;
 
 	unsigned int		bufferram_index;

commit 75384b0d9c04dc2d48f45825f84a982eaf5c2f53
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Thu Jan 18 11:10:57 2007 +0900

    [MTD] OneNAND: Update copyrights and code cleanup
    
    Update copyrights and code cleanup
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index a99b2944d26b..60b3534de74d 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -1,7 +1,7 @@
 /*
  *  linux/include/linux/mtd/onenand.h
  *
- *  Copyright (C) 2005-2006 Samsung Electronics
+ *  Copyright (C) 2005-2007 Samsung Electronics
  *  Kyungmin Park <kyungmin.park@samsung.com>
  *
  * This program is free software; you can redistribute it and/or modify

commit 738d61f53781a9b677cb472cbd740aa74e7dcd6d
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Mon Jan 15 17:09:14 2007 +0900

    [MTD] OneNAND: Reduce Double Density Package (DDP) operations
    
    - DDP code clean-up
    - Reduce block & bufferram operations in DDP
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index f775a7af3890..a99b2944d26b 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -150,6 +150,9 @@ struct onenand_chip {
 #define ONENAND_SET_SYS_CFG1(v, this)					\
 	(this->write_word(v, this->base + ONENAND_REG_SYS_CFG1))
 
+#define ONENAND_IS_DDP(this)						\
+	(this->device_id & ONENAND_DEVICE_IS_DDP)
+
 /* Check byte access in OneNAND */
 #define ONENAND_CHECK_BYTE_ACCESS(addr)		(addr & 0x1)
 

commit a8de85d557004d6d4e4cf79ecd6b97339b986fe9
Author: Adrian Hunter <ext-adrian.hunter@nokia.com>
Date:   Thu Jan 4 09:51:26 2007 +0200

    [MTD] OneNAND: Implement read-while-load
    
    Read-while-load enables higher performance read operations.
    
    Signed-off-by: Adrian Hunter <ext-adrian.hunter@nokia.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index fe3500d7d4bb..f775a7af3890 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -143,6 +143,7 @@ struct onenand_chip {
 #define ONENAND_CURRENT_BUFFERRAM(this)		(this->bufferram_index)
 #define ONENAND_NEXT_BUFFERRAM(this)		(this->bufferram_index ^ 1)
 #define ONENAND_SET_NEXT_BUFFERRAM(this)	(this->bufferram_index ^= 1)
+#define ONENAND_SET_PREV_BUFFERRAM(this)	(this->bufferram_index ^= 1)
 
 #define ONENAND_GET_SYS_CFG1(this)					\
 	(this->read_word(this->base + ONENAND_REG_SYS_CFG1))

commit 60d84f9739a47d0ed8e19805d9056e39fba31c79
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Fri Dec 22 16:21:54 2006 +0900

    [MTD] OneNAND: add subpage write support
    
    OneNAND supports up to 4 writes at one NAND page. Add support of this feature.
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 62ca0f429822..fe3500d7d4bb 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -88,6 +88,7 @@ struct onenand_bufferram {
  *			operation is in progress
  * @state:		[INTERN] the current state of the OneNAND device
  * @page_buf:		data buffer
+ * @subpagesize:	[INTERN] holds the subpagesize
  * @ecclayout:		[REPLACEABLE] the default ecc placement scheme
  * @bbm:		[REPLACEABLE] pointer to Bad Block Management
  * @priv:		[OPTIONAL] pointer to private chip date
@@ -128,6 +129,7 @@ struct onenand_chip {
 	onenand_state_t		state;
 	unsigned char		*page_buf;
 
+	int			subpagesize;
 	struct nand_ecclayout	*ecclayout;
 
 	void			*bbm;

commit 08f782b60a633cbd926ef5e49de303a752390719
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Thu Nov 16 11:29:39 2006 +0900

    [MTD] OneNAND: lock support
    
    Now you can use mtd lock inferface on OneNAND
    
    The idea is from Nemakal, Vijaya, thanks
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index df963f1f6f87..62ca0f429822 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -34,7 +34,6 @@ typedef enum {
 	FL_WRITING,
 	FL_ERASING,
 	FL_SYNCING,
-	FL_UNLOCKING,
 	FL_LOCKING,
 	FL_RESETING,
 	FL_OTPING,

commit 2c22120fbd017d78ad2b6825ba573db3ef539bca
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Thu Nov 16 11:23:48 2006 +0900

    MTD: OneNAND: interrupt based wait support
    
      We can use the two methods to wait.
      1. polling: read interrupt status register
      2. interrupt: use kernel ineterrupt mechanism
    
      To use interrupt method, you first connect onenand interrupt pin to your
    platform and configure interrupt properly
    
    Signed-off-by: Kyungmin Park <kyungmin.park at samsung.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 6f045b586e76..df963f1f6f87 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -13,6 +13,7 @@
 #define __LINUX_MTD_ONENAND_H
 
 #include <linux/spinlock.h>
+#include <linux/completion.h>
 #include <linux/mtd/onenand_regs.h>
 #include <linux/mtd/bbm.h>
 
@@ -120,6 +121,9 @@ struct onenand_chip {
 	int (*block_markbad)(struct mtd_info *mtd, loff_t ofs);
 	int (*scan_bbt)(struct mtd_info *mtd);
 
+	struct completion	complete;
+	int			irq;
+
 	spinlock_t		chip_lock;
 	wait_queue_head_t	wq;
 	onenand_state_t		state;

commit 28b79ff9661b22e4c41c0d00d4ab8503e810f13d
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Tue Sep 26 09:45:28 2006 +0000

    [MTD ONENAND] Check OneNAND lock scheme & all block unlock command support
    
    OneNAND lock scheme depends on density and process of chip.
    Some OneNAND chips support all block unlock
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 1f4972155249..6f045b586e76 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -1,7 +1,7 @@
 /*
  *  linux/include/linux/mtd/onenand.h
  *
- *  Copyright (C) 2005 Samsung Electronics
+ *  Copyright (C) 2005-2006 Samsung Electronics
  *  Kyungmin Park <kyungmin.park@samsung.com>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -96,6 +96,7 @@ struct onenand_chip {
 	void __iomem		*base;
 	unsigned int		chipsize;
 	unsigned int		device_id;
+	unsigned int		version_id;
 	unsigned int		density_mask;
 	unsigned int		options;
 
@@ -149,7 +150,8 @@ struct onenand_chip {
 /*
  * Options bits
  */
-#define ONENAND_CONT_LOCK		(0x0001)
+#define ONENAND_HAS_CONT_LOCK		(0x0001)
+#define ONENAND_HAS_UNLOCK_ALL		(0x0002)
 #define ONENAND_PAGEBUF_ALLOC		(0x1000)
 
 /*

commit ea9b6dcc152f09c207117ab121d4fa03d2db282a
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Wed Jun 28 21:48:38 2006 -0700

    MTD: kernel-doc fixes + additions
    
    Fix some kernel-doc typos/spellos.
    Use kernel-doc syntax in places where it was almost used.
    Correct/add struct, struct field, and function param names where needed.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 9ce9a48db444..1f4972155249 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -23,7 +23,7 @@ extern int onenand_scan(struct mtd_info *mtd, int max_chips);
 /* Free resources held by the OneNAND device */
 extern void onenand_release(struct mtd_info *mtd);
 
-/**
+/*
  * onenand_state_t - chip states
  * Enumeration for OneNAND flash chip state
  */
@@ -42,9 +42,9 @@ typedef enum {
 
 /**
  * struct onenand_bufferram - OneNAND BufferRAM Data
- * @param block		block address in BufferRAM
- * @param page		page address in BufferRAM
- * @param valid		valid flag
+ * @block:		block address in BufferRAM
+ * @page:		page address in BufferRAM
+ * @valid:		valid flag
  */
 struct onenand_bufferram {
 	int block;
@@ -54,32 +54,43 @@ struct onenand_bufferram {
 
 /**
  * struct onenand_chip - OneNAND Private Flash Chip Data
- * @param base		[BOARDSPECIFIC] address to access OneNAND
- * @param chipsize	[INTERN] the size of one chip for multichip arrays
- * @param device_id	[INTERN] device ID
- * @param verstion_id	[INTERN] version ID
- * @param options	[BOARDSPECIFIC] various chip options. They can partly be set to inform onenand_scan about
- * @param erase_shift	[INTERN] number of address bits in a block
- * @param page_shift	[INTERN] number of address bits in a page
- * @param ppb_shift	[INTERN] number of address bits in a pages per block
- * @param page_mask	[INTERN] a page per block mask
- * @param bufferam_index	[INTERN] BufferRAM index
- * @param bufferam	[INTERN] BufferRAM info
- * @param readw		[REPLACEABLE] hardware specific function for read short
- * @param writew	[REPLACEABLE] hardware specific function for write short
- * @param command	[REPLACEABLE] hardware specific function for writing commands to the chip
- * @param wait		[REPLACEABLE] hardware specific function for wait on ready
- * @param read_bufferram	[REPLACEABLE] hardware specific function for BufferRAM Area
- * @param write_bufferram	[REPLACEABLE] hardware specific function for BufferRAM Area
- * @param read_word	[REPLACEABLE] hardware specific function for read register of OneNAND
- * @param write_word	[REPLACEABLE] hardware specific function for write register of OneNAND
- * @param scan_bbt	[REPLACEALBE] hardware specific function for scaning Bad block Table
- * @param chip_lock	[INTERN] spinlock used to protect access to this structure and the chip
- * @param wq		[INTERN] wait queue to sleep on if a OneNAND operation is in progress
- * @param state		[INTERN] the current state of the OneNAND device
- * @param ecclayout	[REPLACEABLE] the default ecc placement scheme
- * @param bbm		[REPLACEABLE] pointer to Bad Block Management
- * @param priv		[OPTIONAL] pointer to private chip date
+ * @base:		[BOARDSPECIFIC] address to access OneNAND
+ * @chipsize:		[INTERN] the size of one chip for multichip arrays
+ * @device_id:		[INTERN] device ID
+ * @density_mask:	chip density, used for DDP devices
+ * @verstion_id:	[INTERN] version ID
+ * @options:		[BOARDSPECIFIC] various chip options. They can
+ *			partly be set to inform onenand_scan about
+ * @erase_shift:	[INTERN] number of address bits in a block
+ * @page_shift:		[INTERN] number of address bits in a page
+ * @ppb_shift:		[INTERN] number of address bits in a pages per block
+ * @page_mask:		[INTERN] a page per block mask
+ * @bufferram_index:	[INTERN] BufferRAM index
+ * @bufferram:		[INTERN] BufferRAM info
+ * @readw:		[REPLACEABLE] hardware specific function for read short
+ * @writew:		[REPLACEABLE] hardware specific function for write short
+ * @command:		[REPLACEABLE] hardware specific function for writing
+ *			commands to the chip
+ * @wait:		[REPLACEABLE] hardware specific function for wait on ready
+ * @read_bufferram:	[REPLACEABLE] hardware specific function for BufferRAM Area
+ * @write_bufferram:	[REPLACEABLE] hardware specific function for BufferRAM Area
+ * @read_word:		[REPLACEABLE] hardware specific function for read
+ *			register of OneNAND
+ * @write_word:		[REPLACEABLE] hardware specific function for write
+ *			register of OneNAND
+ * @mmcontrol:		sync burst read function
+ * @block_markbad:	function to mark a block as bad
+ * @scan_bbt:		[REPLACEALBE] hardware specific function for scanning
+ *			Bad block Table
+ * @chip_lock:		[INTERN] spinlock used to protect access to this
+ *			structure and the chip
+ * @wq:			[INTERN] wait queue to sleep on if a OneNAND
+ *			operation is in progress
+ * @state:		[INTERN] the current state of the OneNAND device
+ * @page_buf:		data buffer
+ * @ecclayout:		[REPLACEABLE] the default ecc placement scheme
+ * @bbm:		[REPLACEABLE] pointer to Bad Block Management
+ * @priv:		[OPTIONAL] pointer to private chip date
  */
 struct onenand_chip {
 	void __iomem		*base;
@@ -147,9 +158,9 @@ struct onenand_chip {
 #define ONENAND_MFR_SAMSUNG	0xec
 
 /**
- * struct nand_manufacturers - NAND Flash Manufacturer ID Structure
- * @param name:		Manufacturer name
- * @param id:		manufacturer ID code of device.
+ * struct onenand_manufacturers - NAND Flash Manufacturer ID Structure
+ * @name:	Manufacturer name
+ * @id:		manufacturer ID code of device.
 */
 struct onenand_manufacturers {
         int id;

commit 5bd34c091a044d130601370c370f84b1c59f1627
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Sat May 27 22:16:10 2006 +0200

    [MTD] NAND Replace oobinfo by ecclayout
    
    The nand_oobinfo structure is not fitting the newer error correction
    demands anymore. Replace it by struct nand_ecclayout and fixup the users
    all over the place. Keep the nand_oobinfo based ioctl for user space
    compability reasons.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 3f5919f2e9da..9ce9a48db444 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -77,7 +77,7 @@ struct onenand_bufferram {
  * @param chip_lock	[INTERN] spinlock used to protect access to this structure and the chip
  * @param wq		[INTERN] wait queue to sleep on if a OneNAND operation is in progress
  * @param state		[INTERN] the current state of the OneNAND device
- * @param autooob	[REPLACEABLE] the default (auto)placement scheme
+ * @param ecclayout	[REPLACEABLE] the default ecc placement scheme
  * @param bbm		[REPLACEABLE] pointer to Bad Block Management
  * @param priv		[OPTIONAL] pointer to private chip date
  */
@@ -113,9 +113,9 @@ struct onenand_chip {
 	onenand_state_t		state;
 	unsigned char		*page_buf;
 
-	struct nand_oobinfo	*autooob;
+	struct nand_ecclayout	*ecclayout;
 
-	void 			*bbm;
+	void			*bbm;
 
 	void			*priv;
 };

commit 493c646077ef0b8668ed71b8057f81cb7454af87
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Fri May 12 17:03:07 2006 +0300

    OneNAND: One-Time Programmable (OTP) support
    
    One Block of the NAND Flash Array memory is reserved as
    a One-Time Programmable Block memory area.
    Also, 1st Block of NAND Flash Array can be used as OTP.
    
    The OTP block can be read, programmed and locked using the same
    operations as any other NAND Flash Array memory block.
    OTP block cannot be erased.
    
    OTP block is fully-guaranteed to be a valid block.
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 22322c8a7729..3f5919f2e9da 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -35,6 +35,8 @@ typedef enum {
 	FL_SYNCING,
 	FL_UNLOCKING,
 	FL_LOCKING,
+	FL_RESETING,
+	FL_OTPING,
 	FL_PM_SUSPENDED,
 } onenand_state_t;
 

commit 9c01f87db183403a4f603fe5180c57b82b54b4a1
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Fri May 12 17:02:31 2006 +0300

    OneNAND: handle byte access on BufferRAM
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 7419b5fab133..22322c8a7729 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -130,6 +130,9 @@ struct onenand_chip {
 #define ONENAND_SET_SYS_CFG1(v, this)					\
 	(this->write_word(v, this->base + ONENAND_REG_SYS_CFG1))
 
+/* Check byte access in OneNAND */
+#define ONENAND_CHECK_BYTE_ACCESS(addr)		(addr & 0x1)
+
 /*
  * Options bits
  */

commit 532a37cf8d05dd1aa5631be836036204b0d2b4a1
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Fri Dec 16 11:17:29 2005 +0900

    [PATCH] mtd onenand driver: reduce stack usage
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 53423d3b43bf..7419b5fab133 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -17,7 +17,6 @@
 #include <linux/mtd/bbm.h>
 
 #define MAX_BUFFERRAM		2
-#define MAX_ONENAND_PAGESIZE	(2048 + 64)
 
 /* Scan and identify a OneNAND device */
 extern int onenand_scan(struct mtd_info *mtd, int max_chips);
@@ -110,6 +109,7 @@ struct onenand_chip {
 	spinlock_t		chip_lock;
 	wait_queue_head_t	wq;
 	onenand_state_t		state;
+	unsigned char		*page_buf;
 
 	struct nand_oobinfo	*autooob;
 
@@ -134,7 +134,7 @@ struct onenand_chip {
  * Options bits
  */
 #define ONENAND_CONT_LOCK		(0x0001)
-
+#define ONENAND_PAGEBUF_ALLOC		(0x1000)
 
 /*
  * OneNAND Flash Manufacturer ID Codes

commit 37b1cc3910f7976369fc0ed55068a686e92555e6
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Fri Dec 16 11:17:29 2005 +0900

    [PATCH] mtd onenand driver: check correct manufacturer
    
    This (and the three subsequent patches) is working well on OMAP H4 with
    2.6.15-rc4 kernel and passes the LTP fs test.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index f1fd4215686a..53423d3b43bf 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -140,7 +140,6 @@ struct onenand_chip {
  * OneNAND Flash Manufacturer ID Codes
  */
 #define ONENAND_MFR_SAMSUNG	0xec
-#define ONENAND_MFR_UNKNOWN	0x00
 
 /**
  * struct nand_manufacturers - NAND Flash Manufacturer ID Structure

commit 61ecfa8777d0bc8e33dc0e5c2cca9b3247da2d37
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Nov 7 11:15:31 2005 +0000

    [MTD] includes: Clean up trailing white spaces
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index d27fd12d096d..f1fd4215686a 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -77,7 +77,7 @@ struct onenand_bufferram {
  * @param wq		[INTERN] wait queue to sleep on if a OneNAND operation is in progress
  * @param state		[INTERN] the current state of the OneNAND device
  * @param autooob	[REPLACEABLE] the default (auto)placement scheme
- * @param bbm		[REPLACEABLE] pointer to Bad Block Management 
+ * @param bbm		[REPLACEABLE] pointer to Bad Block Management
  * @param priv		[OPTIONAL] pointer to private chip date
  */
 struct onenand_chip {

commit 83a368380e172c1b2e9fd6ec2a62e457684adf0c
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Thu Sep 29 04:53:16 2005 +0100

    [MTD] OneNAND: Enhanced support for DDP (Dual Densitiy Packages)
    
    Add density mask for better support of DDP chips.
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index afaa6342aa7f..d27fd12d096d 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -84,6 +84,7 @@ struct onenand_chip {
 	void __iomem		*base;
 	unsigned int		chipsize;
 	unsigned int		device_id;
+	unsigned int		density_mask;
 	unsigned int		options;
 
 	unsigned int		erase_shift;

commit a41371eb6d9b368e53867cd85156f07371e9f72f
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Thu Sep 29 03:55:31 2005 +0100

    [MTD] OneNAND: Power Management (PM) support
    
    Add suspend/resume
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 58023082320a..afaa6342aa7f 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -36,6 +36,7 @@ typedef enum {
 	FL_SYNCING,
 	FL_UNLOCKING,
 	FL_LOCKING,
+	FL_PM_SUSPENDED,
 } onenand_state_t;
 
 /**

commit d36d63d404b75ddf231da0dbd3640e6d1722b4ab
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Sat Sep 3 07:36:21 2005 +0100

    [PATCH] OneNAND: Fix bug in write verify
    
    - Remove unused block, page parameters
    - Add constant instead of runtime value
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 2c29a5ca2c91..58023082320a 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -17,6 +17,7 @@
 #include <linux/mtd/bbm.h>
 
 #define MAX_BUFFERRAM		2
+#define MAX_ONENAND_PAGESIZE	(2048 + 64)
 
 /* Scan and identify a OneNAND device */
 extern int onenand_scan(struct mtd_info *mtd, int max_chips);

commit fcc31470c49e224ed8115c70541f599fc7568fee
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Sat Sep 3 07:20:08 2005 +0100

    [PATCH] OneNAND: Update OMAP OneNAND mapping using device driver model
    
    - Update OMAP OneNAND mapping file using device driver model
    - Remove board specific macro and values.
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 89aaffbc9576..2c29a5ca2c91 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -115,10 +115,18 @@ struct onenand_chip {
 	void			*priv;
 };
 
+/*
+ * Helper macros
+ */
 #define ONENAND_CURRENT_BUFFERRAM(this)		(this->bufferram_index)
 #define ONENAND_NEXT_BUFFERRAM(this)		(this->bufferram_index ^ 1)
 #define ONENAND_SET_NEXT_BUFFERRAM(this)	(this->bufferram_index ^= 1)
 
+#define ONENAND_GET_SYS_CFG1(this)					\
+	(this->read_word(this->base + ONENAND_REG_SYS_CFG1))
+#define ONENAND_SET_SYS_CFG1(v, this)					\
+	(this->write_word(v, this->base + ONENAND_REG_SYS_CFG1))
+
 /*
  * Options bits
  */

commit cdc001305da4f057353911018e28f26f8f879061
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Sat Sep 3 07:15:48 2005 +0100

    [PATCH] OneNAND: Simple Bad Block handling support
    
    Based on NAND memory bad block table code
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index c557caa24a6c..89aaffbc9576 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -14,6 +14,7 @@
 
 #include <linux/spinlock.h>
 #include <linux/mtd/onenand_regs.h>
+#include <linux/mtd/bbm.h>
 
 #define MAX_BUFFERRAM		2
 
@@ -67,10 +68,14 @@ struct onenand_bufferram {
  * @param wait		[REPLACEABLE] hardware specific function for wait on ready
  * @param read_bufferram	[REPLACEABLE] hardware specific function for BufferRAM Area
  * @param write_bufferram	[REPLACEABLE] hardware specific function for BufferRAM Area
+ * @param read_word	[REPLACEABLE] hardware specific function for read register of OneNAND
+ * @param write_word	[REPLACEABLE] hardware specific function for write register of OneNAND
+ * @param scan_bbt	[REPLACEALBE] hardware specific function for scaning Bad block Table
  * @param chip_lock	[INTERN] spinlock used to protect access to this structure and the chip
  * @param wq		[INTERN] wait queue to sleep on if a OneNAND operation is in progress
  * @param state		[INTERN] the current state of the OneNAND device
  * @param autooob	[REPLACEABLE] the default (auto)placement scheme
+ * @param bbm		[REPLACEABLE] pointer to Bad Block Management 
  * @param priv		[OPTIONAL] pointer to private chip date
  */
 struct onenand_chip {
@@ -96,6 +101,8 @@ struct onenand_chip {
 	unsigned short (*read_word)(void __iomem *addr);
 	void (*write_word)(unsigned short value, void __iomem *addr);
 	void (*mmcontrol)(struct mtd_info *mtd, int sync_read);
+	int (*block_markbad)(struct mtd_info *mtd, loff_t ofs);
+	int (*scan_bbt)(struct mtd_info *mtd);
 
 	spinlock_t		chip_lock;
 	wait_queue_head_t	wq;
@@ -103,6 +110,8 @@ struct onenand_chip {
 
 	struct nand_oobinfo	*autooob;
 
+	void 			*bbm;
+
 	void			*priv;
 };
 

commit 52b0eea73de05df33c51ca652e288a3ba1bba03b
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Sat Sep 3 07:07:19 2005 +0100

    [PATCH] OneNAND: Sync. Burst Read support
    
    Add OneNAND Sync. Burst Read support
    Tested with OMAP platform
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index b9a64117d646..c557caa24a6c 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -95,6 +95,7 @@ struct onenand_chip {
 			const unsigned char *buffer, int offset, size_t count);
 	unsigned short (*read_word)(void __iomem *addr);
 	void (*write_word)(unsigned short value, void __iomem *addr);
+	void (*mmcontrol)(struct mtd_info *mtd, int sync_read);
 
 	spinlock_t		chip_lock;
 	wait_queue_head_t	wq;

commit cd5f6346bc28a41375412b49b290d22ee4e4bbe8
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Mon Jul 11 11:41:53 2005 +0100

    [MTD] Add initial support for OneNAND flash chips
    
    OneNAND is a new flash technology from Samsung with integrated SRAM
    buffers and logic interface.
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
new file mode 100644
index 000000000000..b9a64117d646
--- /dev/null
+++ b/include/linux/mtd/onenand.h
@@ -0,0 +1,134 @@
+/*
+ *  linux/include/linux/mtd/onenand.h
+ *
+ *  Copyright (C) 2005 Samsung Electronics
+ *  Kyungmin Park <kyungmin.park@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __LINUX_MTD_ONENAND_H
+#define __LINUX_MTD_ONENAND_H
+
+#include <linux/spinlock.h>
+#include <linux/mtd/onenand_regs.h>
+
+#define MAX_BUFFERRAM		2
+
+/* Scan and identify a OneNAND device */
+extern int onenand_scan(struct mtd_info *mtd, int max_chips);
+/* Free resources held by the OneNAND device */
+extern void onenand_release(struct mtd_info *mtd);
+
+/**
+ * onenand_state_t - chip states
+ * Enumeration for OneNAND flash chip state
+ */
+typedef enum {
+	FL_READY,
+	FL_READING,
+	FL_WRITING,
+	FL_ERASING,
+	FL_SYNCING,
+	FL_UNLOCKING,
+	FL_LOCKING,
+} onenand_state_t;
+
+/**
+ * struct onenand_bufferram - OneNAND BufferRAM Data
+ * @param block		block address in BufferRAM
+ * @param page		page address in BufferRAM
+ * @param valid		valid flag
+ */
+struct onenand_bufferram {
+	int block;
+	int page;
+	int valid;
+};
+
+/**
+ * struct onenand_chip - OneNAND Private Flash Chip Data
+ * @param base		[BOARDSPECIFIC] address to access OneNAND
+ * @param chipsize	[INTERN] the size of one chip for multichip arrays
+ * @param device_id	[INTERN] device ID
+ * @param verstion_id	[INTERN] version ID
+ * @param options	[BOARDSPECIFIC] various chip options. They can partly be set to inform onenand_scan about
+ * @param erase_shift	[INTERN] number of address bits in a block
+ * @param page_shift	[INTERN] number of address bits in a page
+ * @param ppb_shift	[INTERN] number of address bits in a pages per block
+ * @param page_mask	[INTERN] a page per block mask
+ * @param bufferam_index	[INTERN] BufferRAM index
+ * @param bufferam	[INTERN] BufferRAM info
+ * @param readw		[REPLACEABLE] hardware specific function for read short
+ * @param writew	[REPLACEABLE] hardware specific function for write short
+ * @param command	[REPLACEABLE] hardware specific function for writing commands to the chip
+ * @param wait		[REPLACEABLE] hardware specific function for wait on ready
+ * @param read_bufferram	[REPLACEABLE] hardware specific function for BufferRAM Area
+ * @param write_bufferram	[REPLACEABLE] hardware specific function for BufferRAM Area
+ * @param chip_lock	[INTERN] spinlock used to protect access to this structure and the chip
+ * @param wq		[INTERN] wait queue to sleep on if a OneNAND operation is in progress
+ * @param state		[INTERN] the current state of the OneNAND device
+ * @param autooob	[REPLACEABLE] the default (auto)placement scheme
+ * @param priv		[OPTIONAL] pointer to private chip date
+ */
+struct onenand_chip {
+	void __iomem		*base;
+	unsigned int		chipsize;
+	unsigned int		device_id;
+	unsigned int		options;
+
+	unsigned int		erase_shift;
+	unsigned int		page_shift;
+	unsigned int		ppb_shift;	/* Pages per block shift */
+	unsigned int		page_mask;
+
+	unsigned int		bufferram_index;
+	struct onenand_bufferram	bufferram[MAX_BUFFERRAM];
+
+	int (*command)(struct mtd_info *mtd, int cmd, loff_t address, size_t len);
+	int (*wait)(struct mtd_info *mtd, int state);
+	int (*read_bufferram)(struct mtd_info *mtd, int area,
+			unsigned char *buffer, int offset, size_t count);
+	int (*write_bufferram)(struct mtd_info *mtd, int area,
+			const unsigned char *buffer, int offset, size_t count);
+	unsigned short (*read_word)(void __iomem *addr);
+	void (*write_word)(unsigned short value, void __iomem *addr);
+
+	spinlock_t		chip_lock;
+	wait_queue_head_t	wq;
+	onenand_state_t		state;
+
+	struct nand_oobinfo	*autooob;
+
+	void			*priv;
+};
+
+#define ONENAND_CURRENT_BUFFERRAM(this)		(this->bufferram_index)
+#define ONENAND_NEXT_BUFFERRAM(this)		(this->bufferram_index ^ 1)
+#define ONENAND_SET_NEXT_BUFFERRAM(this)	(this->bufferram_index ^= 1)
+
+/*
+ * Options bits
+ */
+#define ONENAND_CONT_LOCK		(0x0001)
+
+
+/*
+ * OneNAND Flash Manufacturer ID Codes
+ */
+#define ONENAND_MFR_SAMSUNG	0xec
+#define ONENAND_MFR_UNKNOWN	0x00
+
+/**
+ * struct nand_manufacturers - NAND Flash Manufacturer ID Structure
+ * @param name:		Manufacturer name
+ * @param id:		manufacturer ID code of device.
+*/
+struct onenand_manufacturers {
+        int id;
+        char *name;
+};
+
+#endif	/* __LINUX_MTD_ONENAND_H */
