commit b466a37fbcc99ef79ea59e40ef6aa8391430b0d8
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jan 7 13:07:41 2019 +0200

    dmaengine: dw: convert to SPDX identifiers
    
    This patch updates license to use SPDX-License-Identifier
    instead of verbose license text.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/include/linux/platform_data/dma-dw.h b/include/linux/platform_data/dma-dw.h
index 576048433809..f3eaf9ec00a1 100644
--- a/include/linux/platform_data/dma-dw.h
+++ b/include/linux/platform_data/dma-dw.h
@@ -1,12 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Driver for the Synopsys DesignWare DMA Controller
  *
  * Copyright (C) 2007 Atmel Corporation
  * Copyright (C) 2010-2011 ST Microelectronics
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 #ifndef _PLATFORM_DATA_DMA_DW_H
 #define _PLATFORM_DATA_DMA_DW_H

commit 69da8be90d5e85e60b5377c47384154b9dabf592
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jan 7 13:07:38 2019 +0200

    dmaengine: dw: Split DW and iDMA 32-bit operations
    
    Here is a kinda big refactoring that should have been done
    in the first place, when Intel iDMA 32-bit support appeared.
    
    It splits operations which are different to Synopsys DesignWare and
    Intel iDMA 32-bit controllers.
    
    No functional change intended.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/include/linux/platform_data/dma-dw.h b/include/linux/platform_data/dma-dw.h
index 1c85eeee4171..576048433809 100644
--- a/include/linux/platform_data/dma-dw.h
+++ b/include/linux/platform_data/dma-dw.h
@@ -38,7 +38,6 @@ struct dw_dma_slave {
 /**
  * struct dw_dma_platform_data - Controller configuration parameters
  * @nr_channels: Number of channels supported by hardware (max 8)
- * @is_idma32: The type of the DMA controller is iDMA32
  * @chan_allocation_order: Allocate channels starting from 0 or 7
  * @chan_priority: Set channel priority increasing from 0 to 7 or 7 to 0.
  * @block_size: Maximum block size supported by the controller
@@ -50,7 +49,6 @@ struct dw_dma_slave {
  */
 struct dw_dma_platform_data {
 	unsigned int	nr_channels;
-	bool		is_idma32;
 #define CHAN_ALLOCATION_ASCENDING	0	/* zero to seven */
 #define CHAN_ALLOCATION_DESCENDING	1	/* seven to zero */
 	unsigned char	chan_allocation_order;

commit 078165779608873e7b6eae1316a39c73af9f3edc
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jan 7 13:07:37 2019 +0200

    dmaengine: dw: Remove unused internal property
    
    All known devices, which use DT for configuration, support
    memory-to-memory transfers. So enable it by default.
    
    The rest two cases, i.e. Intel Quark and PPC460ex, instantiate DMA driver and
    use its channels exclusively for hardware, which means there is no available
    channel for any other purposes anyway.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/include/linux/platform_data/dma-dw.h b/include/linux/platform_data/dma-dw.h
index d443025c5c72..1c85eeee4171 100644
--- a/include/linux/platform_data/dma-dw.h
+++ b/include/linux/platform_data/dma-dw.h
@@ -38,7 +38,6 @@ struct dw_dma_slave {
 /**
  * struct dw_dma_platform_data - Controller configuration parameters
  * @nr_channels: Number of channels supported by hardware (max 8)
- * @is_memcpy: The device channels do support memory-to-memory transfers.
  * @is_idma32: The type of the DMA controller is iDMA32
  * @chan_allocation_order: Allocate channels starting from 0 or 7
  * @chan_priority: Set channel priority increasing from 0 to 7 or 7 to 0.
@@ -51,7 +50,6 @@ struct dw_dma_slave {
  */
 struct dw_dma_platform_data {
 	unsigned int	nr_channels;
-	bool		is_memcpy;
 	bool		is_idma32;
 #define CHAN_ALLOCATION_ASCENDING	0	/* zero to seven */
 #define CHAN_ALLOCATION_DESCENDING	1	/* seven to zero */

commit d7dba6be0f31ae61f5f3296aa130f45d57d30f74
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jan 7 13:07:36 2019 +0200

    dmaengine: dw: Remove misleading is_private property
    
    The commit a9ddb575d6d6
    
       ("dmaengine: dw_dmac: Enhance device tree support")
    
    introduces is_private property in uncertain understanding what does it mean.
    
    First of all, documentation defines DMA_PRIVATE capability as
    
    Documentation/crypto/async-tx-api.txt:
      The DMA_PRIVATE capability flag is used to tag dma devices that should not be
      used by the general-purpose allocator. It can be set at initialization time
      if it is known that a channel will always be private. Alternatively,
      it is set when dma_request_channel() finds an unused "public" channel.
    
      A couple caveats to note when implementing a driver and consumer:
      1/ Once a channel has been privately allocated it will no longer be
         considered by the general-purpose allocator even after a call to
         dma_release_channel().
      2/ Since capabilities are specified at the device level a dma_device with
         multiple channels will either have all channels public, or all channels
         private.
    
    Documentation/driver-api/dmaengine/provider.rst:
      - DMA_PRIVATE
        The devices only supports slave transfers, and as such isn't available
        for async transfers.
    
    The capability had been introduced by the commit 59b5ec21446b
    
      ("dmaengine: introduce dma_request_channel and private channels")
    
    and some code didn't changed from that times ever.
    
    Taking into consideration above and the fact that on all known platforms
    Synopsys DesignWare DMA engine is attached to serve slave transfers,
    the DMA_PRIVATE capability must be enabled for this device unconditionally.
    Otherwise, as rightfully noticed in drivers/dma/at_xdmac.c:
      /*
       * Without DMA_PRIVATE the driver is not able to allocate more than
       * one channel, second allocation fails in private_candidate.
       */
    because of of a caveats mentioned in above documentation excerpts.
    
    So, remove conditional around DMA_PRIVATE followed by removal leftovers.
    
    If someone wonders, DMA_PRIVATE can be not used if and only if the all channels
    of the DMA controller are supposed to serve memory-to-memory like operations.
    For example, EP93xx has two controllers, one of which can only perform
    memory-to-memory transfers
    
    Note, this change doesn't affect dmatest to be able to test such controllers.
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org> (maintainer:SERIAL DRIVERS)
    Cc: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/include/linux/platform_data/dma-dw.h b/include/linux/platform_data/dma-dw.h
index 1a1d58ebffbf..d443025c5c72 100644
--- a/include/linux/platform_data/dma-dw.h
+++ b/include/linux/platform_data/dma-dw.h
@@ -38,8 +38,6 @@ struct dw_dma_slave {
 /**
  * struct dw_dma_platform_data - Controller configuration parameters
  * @nr_channels: Number of channels supported by hardware (max 8)
- * @is_private: The device channels should be marked as private and not for
- *	by the general purpose DMA channel allocator.
  * @is_memcpy: The device channels do support memory-to-memory transfers.
  * @is_idma32: The type of the DMA controller is iDMA32
  * @chan_allocation_order: Allocate channels starting from 0 or 7
@@ -53,7 +51,6 @@ struct dw_dma_slave {
  */
 struct dw_dma_platform_data {
 	unsigned int	nr_channels;
-	bool		is_private;
 	bool		is_memcpy;
 	bool		is_idma32;
 #define CHAN_ALLOCATION_ASCENDING	0	/* zero to seven */

commit 7b0c03ecc42fb223baf015877fee9d517c2c8af1
Author: Christian Lamparter <chunkeey@gmail.com>
Date:   Sat Nov 17 17:17:21 2018 +0100

    dmaengine: dw-dmac: implement dma protection control setting
    
    This patch adds a new device-tree property that allows to
    specify the dma protection control bits for the all of the
    DMA controller's channel uniformly.
    
    Setting the "correct" bits can have a huge impact on the
    PPC460EX and APM82181 that use this DMA engine in combination
    with a DesignWare' SATA-II core (sata_dwc_460ex driver).
    
    In the OpenWrt Forum, the user takimata reported that:
    |It seems your patch unleashed the full power of the SATA port.
    |Where I was previously hitting a really hard limit at around
    |82 MB/s for reading and 27 MB/s for writing, I am now getting this:
    |
    |root@OpenWrt:/mnt# time dd if=/dev/zero of=tempfile bs=1M count=1024
    |1024+0 records in
    |1024+0 records out
    |real    0m 13.65s
    |user    0m 0.01s
    |sys     0m 11.89s
    |
    |root@OpenWrt:/mnt# time dd if=tempfile of=/dev/null bs=1M count=1024
    |1024+0 records in
    |1024+0 records out
    |real    0m 8.41s
    |user    0m 0.01s
    |sys     0m 4.70s
    |
    |This means: 121 MB/s reading and 75 MB/s writing!
    |
    |The drive is a WD Green WD10EARX taken from an older MBL Single.
    |I repeated the test a few times with even larger files to rule out
    |any caching, I'm still seeing the same great performance. OpenWrt is
    |now completely on par with the original MBL firmware's performance.
    
    Another user And.short reported:
    |I can report that your fix worked! Boots up fine with two
    |drives even with more partitions, and no more reboot on
    |concurrent disk access!
    
    A closer look into the sata_dwc_460ex code revealed that
    the driver did initally set the correct protection control
    bits. However, this feature was lost when the sata_dwc_460ex
    driver was converted to the generic DMA driver framework.
    
    BugLink: https://forum.openwrt.org/t/wd-mybook-live-duo-two-disks/16195/55
    BugLink: https://forum.openwrt.org/t/wd-mybook-live-duo-two-disks/16195/50
    Fixes: 8b3444852a2b ("sata_dwc_460ex: move to generic DMA driver")
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Christian Lamparter <chunkeey@gmail.com>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/include/linux/platform_data/dma-dw.h b/include/linux/platform_data/dma-dw.h
index 896cb71a382c..1a1d58ebffbf 100644
--- a/include/linux/platform_data/dma-dw.h
+++ b/include/linux/platform_data/dma-dw.h
@@ -49,6 +49,7 @@ struct dw_dma_slave {
  * @data_width: Maximum data width supported by hardware per AHB master
  *		(in bytes, power of 2)
  * @multi_block: Multi block transfers supported by hardware per channel.
+ * @protctl: Protection control signals setting per channel.
  */
 struct dw_dma_platform_data {
 	unsigned int	nr_channels;
@@ -65,6 +66,11 @@ struct dw_dma_platform_data {
 	unsigned char	nr_masters;
 	unsigned char	data_width[DW_DMA_MAX_NR_MASTERS];
 	unsigned char	multi_block[DW_DMA_MAX_NR_CHANNELS];
+#define CHAN_PROTCTL_PRIVILEGED		BIT(0)
+#define CHAN_PROTCTL_BUFFERABLE		BIT(1)
+#define CHAN_PROTCTL_CACHEABLE		BIT(2)
+#define CHAN_PROTCTL_MASK		GENMASK(2, 0)
+	unsigned char	protctl;
 };
 
 #endif /* _PLATFORM_DATA_DMA_DW_H */

commit 199244d69458770770890f8b5988a1b6cad701ad
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Jan 17 13:57:31 2017 +0200

    dmaengine: dw: add support of iDMA 32-bit hardware
    
    iDMA 32-bit is Intel designed DMA controller that behaves like Synopsys
    Designware DMA. This patch adds a support of the new Intel hardware.
    
    Due to iDMA 32-bit has no autoconfiguration the platform code must
    provide a platform data to dw_dma_probe().
    
    By default full FIFO (1024 bytes) is assigned to channel 0. Here we
    slice FIFO on equal parts between channels for iDMA 32-bit case.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/include/linux/platform_data/dma-dw.h b/include/linux/platform_data/dma-dw.h
index e69e415d0d98..896cb71a382c 100644
--- a/include/linux/platform_data/dma-dw.h
+++ b/include/linux/platform_data/dma-dw.h
@@ -41,6 +41,7 @@ struct dw_dma_slave {
  * @is_private: The device channels should be marked as private and not for
  *	by the general purpose DMA channel allocator.
  * @is_memcpy: The device channels do support memory-to-memory transfers.
+ * @is_idma32: The type of the DMA controller is iDMA32
  * @chan_allocation_order: Allocate channels starting from 0 or 7
  * @chan_priority: Set channel priority increasing from 0 to 7 or 7 to 0.
  * @block_size: Maximum block size supported by the controller
@@ -53,6 +54,7 @@ struct dw_dma_platform_data {
 	unsigned int	nr_channels;
 	bool		is_private;
 	bool		is_memcpy;
+	bool		is_idma32;
 #define CHAN_ALLOCATION_ASCENDING	0	/* zero to seven */
 #define CHAN_ALLOCATION_DESCENDING	1	/* seven to zero */
 	unsigned char	chan_allocation_order;

commit bd2c6636cc59c4626a04d9918953a107f88eaff9
Author: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
Date:   Fri Nov 25 17:59:07 2016 +0300

    dmaengine: DW DMAC: add multi-block property to device tree
    
    Several versions of DW DMAC have multi block transfers hardware
    support. Hardware support of multi block transfers is disabled
    by default if we use DT to configure DMAC and software emulation
    of multi block transfers used instead.
    Add multi-block property, so it is possible to enable hardware
    multi block transfers (if present) via DT.
    
    Switch from per device is_nollp variable to multi_block array
    to be able enable/disable multi block transfers separately per
    channel.
    
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/include/linux/platform_data/dma-dw.h b/include/linux/platform_data/dma-dw.h
index 5f0e11e7354c..e69e415d0d98 100644
--- a/include/linux/platform_data/dma-dw.h
+++ b/include/linux/platform_data/dma-dw.h
@@ -14,6 +14,7 @@
 #include <linux/device.h>
 
 #define DW_DMA_MAX_NR_MASTERS	4
+#define DW_DMA_MAX_NR_CHANNELS	8
 
 /**
  * struct dw_dma_slave - Controller-specific information about a slave
@@ -40,19 +41,18 @@ struct dw_dma_slave {
  * @is_private: The device channels should be marked as private and not for
  *	by the general purpose DMA channel allocator.
  * @is_memcpy: The device channels do support memory-to-memory transfers.
- * @is_nollp: The device channels does not support multi block transfers.
  * @chan_allocation_order: Allocate channels starting from 0 or 7
  * @chan_priority: Set channel priority increasing from 0 to 7 or 7 to 0.
  * @block_size: Maximum block size supported by the controller
  * @nr_masters: Number of AHB masters supported by the controller
  * @data_width: Maximum data width supported by hardware per AHB master
  *		(in bytes, power of 2)
+ * @multi_block: Multi block transfers supported by hardware per channel.
  */
 struct dw_dma_platform_data {
 	unsigned int	nr_channels;
 	bool		is_private;
 	bool		is_memcpy;
-	bool		is_nollp;
 #define CHAN_ALLOCATION_ASCENDING	0	/* zero to seven */
 #define CHAN_ALLOCATION_DESCENDING	1	/* seven to zero */
 	unsigned char	chan_allocation_order;
@@ -62,6 +62,7 @@ struct dw_dma_platform_data {
 	unsigned int	block_size;
 	unsigned char	nr_masters;
 	unsigned char	data_width[DW_DMA_MAX_NR_MASTERS];
+	unsigned char	multi_block[DW_DMA_MAX_NR_CHANNELS];
 };
 
 #endif /* _PLATFORM_DATA_DMA_DW_H */

commit 5fb23e35cacffb7b99ed5b97a002ddb8c9144bb6
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Aug 17 19:20:22 2016 +0300

    dmaengine: dw: override LLP support if asked in platform data
    
    There are at least two known devices, e.g. DMA controller found on ARC AXS101
    SDP board, that have LLP register and no multi block transfer support at the
    same time.
    
    Override autodetection by user provided data.
    
    Reported-by: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
    Reviewed-by: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Bryan O'Donoghue <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/platform_data/dma-dw.h b/include/linux/platform_data/dma-dw.h
index 4636c9335305..5f0e11e7354c 100644
--- a/include/linux/platform_data/dma-dw.h
+++ b/include/linux/platform_data/dma-dw.h
@@ -40,6 +40,7 @@ struct dw_dma_slave {
  * @is_private: The device channels should be marked as private and not for
  *	by the general purpose DMA channel allocator.
  * @is_memcpy: The device channels do support memory-to-memory transfers.
+ * @is_nollp: The device channels does not support multi block transfers.
  * @chan_allocation_order: Allocate channels starting from 0 or 7
  * @chan_priority: Set channel priority increasing from 0 to 7 or 7 to 0.
  * @block_size: Maximum block size supported by the controller
@@ -51,6 +52,7 @@ struct dw_dma_platform_data {
 	unsigned int	nr_channels;
 	bool		is_private;
 	bool		is_memcpy;
+	bool		is_nollp;
 #define CHAN_ALLOCATION_ASCENDING	0	/* zero to seven */
 #define CHAN_ALLOCATION_DESCENDING	1	/* seven to zero */
 	unsigned char	chan_allocation_order;

commit c072e113b8fbd6b2bf325e92379a0da6dea619b3
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Aug 17 19:20:21 2016 +0300

    dmaengine: dw: set polarity of handshake interface
    
    Intel Quark UART uses DesignWare DMA IP. Though the DMA IP is connected in such
    way that handshake interface uses inverted polarity. We have to provide a
    possibility to set this in the DMA driver when configuring a channel.
    
    Introduce a new member of custom slave configuration called 'hs_polarity' and
    set active low polarity in case this value is 'true'.
    
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Bryan O'Donoghue <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/platform_data/dma-dw.h b/include/linux/platform_data/dma-dw.h
index d15d8ba8cc24..4636c9335305 100644
--- a/include/linux/platform_data/dma-dw.h
+++ b/include/linux/platform_data/dma-dw.h
@@ -23,6 +23,7 @@
  * @dst_id:	dst request line
  * @m_master:	memory master for transfers on allocated channel
  * @p_master:	peripheral master for transfers on allocated channel
+ * @hs_polarity:set active low polarity of handshake interface
  */
 struct dw_dma_slave {
 	struct device		*dma_dev;
@@ -30,6 +31,7 @@ struct dw_dma_slave {
 	u8			dst_id;
 	u8			m_master;
 	u8			p_master;
+	bool			hs_polarity;
 };
 
 /**

commit 161c3d04aeca8a5bfffe3902786bdf0ccd8575c0
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Apr 27 14:15:39 2016 +0300

    dmaengine: dw: keep entire platform data in struct dw_dma
    
    Keep the entire platform data in the struct dw_dma.
    It makes the driver a bit cleaner.
    
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/include/linux/platform_data/dma-dw.h b/include/linux/platform_data/dma-dw.h
index ad768111c350..d15d8ba8cc24 100644
--- a/include/linux/platform_data/dma-dw.h
+++ b/include/linux/platform_data/dma-dw.h
@@ -55,7 +55,7 @@ struct dw_dma_platform_data {
 #define CHAN_PRIORITY_ASCENDING		0	/* chan0 highest */
 #define CHAN_PRIORITY_DESCENDING	1	/* chan7 highest */
 	unsigned char	chan_priority;
-	unsigned short	block_size;
+	unsigned int	block_size;
 	unsigned char	nr_masters;
 	unsigned char	data_width[DW_DMA_MAX_NR_MASTERS];
 };

commit 2e65060e803e046fc9b5ed0107494a452424845e
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Apr 27 14:15:38 2016 +0300

    dmaengine: dw: revisit data_width property
    
    There several changes are done here:
    
    - Convert the property to be in bytes
    
      Besides that this is a common practice for such property, the use of a value
      in bytes much more convenient than handling the encoded one.
    
    - Rename data_width to data-width in the device tree bindings
    
      The change leaves the support for the old format as well just in case someone
      will use a newer kernel with an old device tree blob.
    
    - While here, replace dwc_fast_ffs() by __ffs()
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/include/linux/platform_data/dma-dw.h b/include/linux/platform_data/dma-dw.h
index b881b978e486..ad768111c350 100644
--- a/include/linux/platform_data/dma-dw.h
+++ b/include/linux/platform_data/dma-dw.h
@@ -43,7 +43,7 @@ struct dw_dma_slave {
  * @block_size: Maximum block size supported by the controller
  * @nr_masters: Number of AHB masters supported by the controller
  * @data_width: Maximum data width supported by hardware per AHB master
- *		(0 - 8bits, 1 - 16bits, ..., 5 - 256bits)
+ *		(in bytes, power of 2)
  */
 struct dw_dma_platform_data {
 	unsigned int	nr_channels;

commit c422025c185fb2bb28df65b1bbed7953480c7f87
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Mar 18 16:24:41 2016 +0200

    dmaengine: dw: rename masters to reflect actual topology
    
    The source and destination masters are reflecting buses or their layers to
    where the different devices can be connected. The patch changes the master
    names to reflect which one is related to which independently on the transfer
    direction.
    
    The outcome of the change is that the memory data width is now always limited
    by a data width of the master which is dedicated to communicate to memory.
    
    The patch will not break anything since all current users have the same data
    width for all masters. Though it would be nice to revisit avr32 platforms to
    check what is the actual hardware topology in use there. It seems that it has
    one bus and two masters on it as stated by Table 8-2, that's why everything
    works independently on the master in use. The purpose of the sequential patch
    is to fix the driver for configuration of more than one bus.
    
    The change is done in the assumption that src_master and dst_master are
    reflecting a connection to the memory and peripheral correspondently on avr32
    and otherwise on the rest.
    
    Acked-by: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/include/linux/platform_data/dma-dw.h b/include/linux/platform_data/dma-dw.h
index 03b6095d3b18..b881b978e486 100644
--- a/include/linux/platform_data/dma-dw.h
+++ b/include/linux/platform_data/dma-dw.h
@@ -21,15 +21,15 @@
  * @dma_dev:	required DMA master device
  * @src_id:	src request line
  * @dst_id:	dst request line
- * @src_master: src master for transfers on allocated channel.
- * @dst_master: dest master for transfers on allocated channel.
+ * @m_master:	memory master for transfers on allocated channel
+ * @p_master:	peripheral master for transfers on allocated channel
  */
 struct dw_dma_slave {
 	struct device		*dma_dev;
 	u8			src_id;
 	u8			dst_id;
-	u8			src_master;
-	u8			dst_master;
+	u8			m_master;
+	u8			p_master;
 };
 
 /**

commit df5c7386f62d2db95ca48005087195e9a15e2b1f
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Oct 13 20:09:19 2015 +0300

    dmaengine: dw: some Intel devices has no memcpy support
    
    Provide a flag to choose if the device does support memory-to-memory transfers.
    At least this is not true for iDMA32 controller that might be supported in the
    future. Besides that Intel BayTrail and Braswell users should not try this
    feature due to HW specific behaviour.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/include/linux/platform_data/dma-dw.h b/include/linux/platform_data/dma-dw.h
index 87ac14c584f2..03b6095d3b18 100644
--- a/include/linux/platform_data/dma-dw.h
+++ b/include/linux/platform_data/dma-dw.h
@@ -37,6 +37,7 @@ struct dw_dma_slave {
  * @nr_channels: Number of channels supported by hardware (max 8)
  * @is_private: The device channels should be marked as private and not for
  *	by the general purpose DMA channel allocator.
+ * @is_memcpy: The device channels do support memory-to-memory transfers.
  * @chan_allocation_order: Allocate channels starting from 0 or 7
  * @chan_priority: Set channel priority increasing from 0 to 7 or 7 to 0.
  * @block_size: Maximum block size supported by the controller
@@ -47,6 +48,7 @@ struct dw_dma_slave {
 struct dw_dma_platform_data {
 	unsigned int	nr_channels;
 	bool		is_private;
+	bool		is_memcpy;
 #define CHAN_ALLOCATION_ASCENDING	0	/* zero to seven */
 #define CHAN_ALLOCATION_DESCENDING	1	/* seven to zero */
 	unsigned char	chan_allocation_order;

commit d8ded50f8b26a224df48f9f93e49440c6a39b77f
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Jan 13 19:08:14 2015 +0200

    dmaengine: dw: define DW_DMA_MAX_NR_MASTERS
    
    Instead of using magic number in the code the patch provides
    DW_DMA_MAX_NR_MASTERS constant.
    
    While here, restrict the reading of data width array by amount of the actual
    number of AHB masters.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/include/linux/platform_data/dma-dw.h b/include/linux/platform_data/dma-dw.h
index 359127d290e7..87ac14c584f2 100644
--- a/include/linux/platform_data/dma-dw.h
+++ b/include/linux/platform_data/dma-dw.h
@@ -13,6 +13,8 @@
 
 #include <linux/device.h>
 
+#define DW_DMA_MAX_NR_MASTERS	4
+
 /**
  * struct dw_dma_slave - Controller-specific information about a slave
  *
@@ -53,7 +55,7 @@ struct dw_dma_platform_data {
 	unsigned char	chan_priority;
 	unsigned short	block_size;
 	unsigned char	nr_masters;
-	unsigned char	data_width[4];
+	unsigned char	data_width[DW_DMA_MAX_NR_MASTERS];
 };
 
 #endif /* _PLATFORM_DATA_DMA_DW_H */

commit cfd8fef322305bbe9955817464f0d2054ce545c0
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Jan 13 19:08:13 2015 +0200

    dmaengine: dw: amend description of dma_dev field
    
    The dma_dev field is widely used in filter functions to mach with a proper DMA
    controller device. Thus it's not deprecated. The patch fixes the description of
    that field. There is no functional change.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/include/linux/platform_data/dma-dw.h b/include/linux/platform_data/dma-dw.h
index d8155c005242..359127d290e7 100644
--- a/include/linux/platform_data/dma-dw.h
+++ b/include/linux/platform_data/dma-dw.h
@@ -16,7 +16,7 @@
 /**
  * struct dw_dma_slave - Controller-specific information about a slave
  *
- * @dma_dev: required DMA master device. Depricated.
+ * @dma_dev:	required DMA master device
  * @src_id:	src request line
  * @dst_id:	dst request line
  * @src_master: src master for transfers on allocated channel.

commit 3d588f83e4d6a5230d9094b97d38621cbaa9a972
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Sep 23 17:18:11 2014 +0300

    dmaengine: dw: split dma-dw.h to platform and private parts
    
    The introduced include/linux/dma/dw.h is going to contain the private
    extensions and structures which are shared for dw_dmac users in the kernel.
    Meanwhile include/linux/platform_data/dma-dw.h keeps only platform related data
    types and definitions.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/include/linux/platform_data/dma-dw.h b/include/linux/platform_data/dma-dw.h
index d0c97da66e22..d8155c005242 100644
--- a/include/linux/platform_data/dma-dw.h
+++ b/include/linux/platform_data/dma-dw.h
@@ -8,10 +8,10 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
-#ifndef DW_DMAC_H
-#define DW_DMAC_H
+#ifndef _PLATFORM_DATA_DMA_DW_H
+#define _PLATFORM_DATA_DMA_DW_H
 
-#include <linux/dmaengine.h>
+#include <linux/device.h>
 
 /**
  * struct dw_dma_slave - Controller-specific information about a slave
@@ -56,23 +56,4 @@ struct dw_dma_platform_data {
 	unsigned char	data_width[4];
 };
 
-/* DMA API extensions */
-struct dw_cyclic_desc {
-	struct dw_desc	**desc;
-	unsigned long	periods;
-	void		(*period_callback)(void *param);
-	void		*period_callback_param;
-};
-
-struct dw_cyclic_desc *dw_dma_cyclic_prep(struct dma_chan *chan,
-		dma_addr_t buf_addr, size_t buf_len, size_t period_len,
-		enum dma_transfer_direction direction);
-void dw_dma_cyclic_free(struct dma_chan *chan);
-int dw_dma_cyclic_start(struct dma_chan *chan);
-void dw_dma_cyclic_stop(struct dma_chan *chan);
-
-dma_addr_t dw_dma_get_src_addr(struct dma_chan *chan);
-
-dma_addr_t dw_dma_get_dst_addr(struct dma_chan *chan);
-
-#endif /* DW_DMAC_H */
+#endif /* _PLATFORM_DATA_DMA_DW_H */

commit 46e8c83c83c06b90ebc000df481c2fdcee79a141
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Sep 23 17:18:10 2014 +0300

    dmaengine: dw: move private definitions to regs.h
    
    Since we don't allow user to set registers directly through private slave
    configuration we may move definitions to the regs.h because they are not used
    anywhere except core.c part.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/include/linux/platform_data/dma-dw.h b/include/linux/platform_data/dma-dw.h
index bc411a1bf8e7..d0c97da66e22 100644
--- a/include/linux/platform_data/dma-dw.h
+++ b/include/linux/platform_data/dma-dw.h
@@ -56,37 +56,6 @@ struct dw_dma_platform_data {
 	unsigned char	data_width[4];
 };
 
-/* bursts size */
-enum dw_dma_msize {
-	DW_DMA_MSIZE_1,
-	DW_DMA_MSIZE_4,
-	DW_DMA_MSIZE_8,
-	DW_DMA_MSIZE_16,
-	DW_DMA_MSIZE_32,
-	DW_DMA_MSIZE_64,
-	DW_DMA_MSIZE_128,
-	DW_DMA_MSIZE_256,
-};
-
-/* Platform-configurable bits in CFG_HI */
-#define DWC_CFGH_FCMODE		(1 << 0)
-#define DWC_CFGH_FIFO_MODE	(1 << 1)
-#define DWC_CFGH_PROTCTL(x)	((x) << 2)
-#define DWC_CFGH_SRC_PER(x)	((x) << 7)
-#define DWC_CFGH_DST_PER(x)	((x) << 11)
-
-/* Platform-configurable bits in CFG_LO */
-#define DWC_CFGL_LOCK_CH_XFER	(0 << 12)	/* scope of LOCK_CH */
-#define DWC_CFGL_LOCK_CH_BLOCK	(1 << 12)
-#define DWC_CFGL_LOCK_CH_XACT	(2 << 12)
-#define DWC_CFGL_LOCK_BUS_XFER	(0 << 14)	/* scope of LOCK_BUS */
-#define DWC_CFGL_LOCK_BUS_BLOCK	(1 << 14)
-#define DWC_CFGL_LOCK_BUS_XACT	(2 << 14)
-#define DWC_CFGL_LOCK_CH	(1 << 15)	/* channel lockout */
-#define DWC_CFGL_LOCK_BUS	(1 << 16)	/* busmaster lockout */
-#define DWC_CFGL_HS_DST_POL	(1 << 18)	/* dst handshake active low */
-#define DWC_CFGL_HS_SRC_POL	(1 << 19)	/* src handshake active low */
-
 /* DMA API extensions */
 struct dw_cyclic_desc {
 	struct dw_desc	**desc;

commit 7e1e2f27c5508518e58e5cbb11e26cbb815f4c56
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Aug 19 20:29:14 2014 +0300

    dmaengine: dw: convert dw_dma_slave to use explicit HS interfaces
    
    Instead of exposing the possibility to set DMA registers CFG_HI and CFG_LO
    strict user to provide handshake interfaces explicitly.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/include/linux/platform_data/dma-dw.h b/include/linux/platform_data/dma-dw.h
index 68b4024184de..bc411a1bf8e7 100644
--- a/include/linux/platform_data/dma-dw.h
+++ b/include/linux/platform_data/dma-dw.h
@@ -17,17 +17,15 @@
  * struct dw_dma_slave - Controller-specific information about a slave
  *
  * @dma_dev: required DMA master device. Depricated.
- * @bus_id: name of this device channel, not just a device name since
- *          devices may have more than one channel e.g. "foo_tx"
- * @cfg_hi: Platform-specific initializer for the CFG_HI register
- * @cfg_lo: Platform-specific initializer for the CFG_LO register
+ * @src_id:	src request line
+ * @dst_id:	dst request line
  * @src_master: src master for transfers on allocated channel.
  * @dst_master: dest master for transfers on allocated channel.
  */
 struct dw_dma_slave {
 	struct device		*dma_dev;
-	u32			cfg_hi;
-	u32			cfg_lo;
+	u8			src_id;
+	u8			dst_id;
 	u8			src_master;
 	u8			dst_master;
 };

commit 3d598f47e804a77208c6bb0a454123018e2f2281
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Aug 19 20:29:12 2014 +0300

    dmaengine: dw: move dw_dmac.h to where it belongs to
    
    There is a common storage for platform data related structures and definitions
    inside kernel source tree. The patch moves file from include/linux to
    include/linux/platform_data and renames it acoordingly. The users are also
    updated.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    [For the arch/avr32/.* and .*sound/atmel.*]
    Acked-by: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/include/linux/platform_data/dma-dw.h b/include/linux/platform_data/dma-dw.h
new file mode 100644
index 000000000000..68b4024184de
--- /dev/null
+++ b/include/linux/platform_data/dma-dw.h
@@ -0,0 +1,111 @@
+/*
+ * Driver for the Synopsys DesignWare DMA Controller
+ *
+ * Copyright (C) 2007 Atmel Corporation
+ * Copyright (C) 2010-2011 ST Microelectronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef DW_DMAC_H
+#define DW_DMAC_H
+
+#include <linux/dmaengine.h>
+
+/**
+ * struct dw_dma_slave - Controller-specific information about a slave
+ *
+ * @dma_dev: required DMA master device. Depricated.
+ * @bus_id: name of this device channel, not just a device name since
+ *          devices may have more than one channel e.g. "foo_tx"
+ * @cfg_hi: Platform-specific initializer for the CFG_HI register
+ * @cfg_lo: Platform-specific initializer for the CFG_LO register
+ * @src_master: src master for transfers on allocated channel.
+ * @dst_master: dest master for transfers on allocated channel.
+ */
+struct dw_dma_slave {
+	struct device		*dma_dev;
+	u32			cfg_hi;
+	u32			cfg_lo;
+	u8			src_master;
+	u8			dst_master;
+};
+
+/**
+ * struct dw_dma_platform_data - Controller configuration parameters
+ * @nr_channels: Number of channels supported by hardware (max 8)
+ * @is_private: The device channels should be marked as private and not for
+ *	by the general purpose DMA channel allocator.
+ * @chan_allocation_order: Allocate channels starting from 0 or 7
+ * @chan_priority: Set channel priority increasing from 0 to 7 or 7 to 0.
+ * @block_size: Maximum block size supported by the controller
+ * @nr_masters: Number of AHB masters supported by the controller
+ * @data_width: Maximum data width supported by hardware per AHB master
+ *		(0 - 8bits, 1 - 16bits, ..., 5 - 256bits)
+ */
+struct dw_dma_platform_data {
+	unsigned int	nr_channels;
+	bool		is_private;
+#define CHAN_ALLOCATION_ASCENDING	0	/* zero to seven */
+#define CHAN_ALLOCATION_DESCENDING	1	/* seven to zero */
+	unsigned char	chan_allocation_order;
+#define CHAN_PRIORITY_ASCENDING		0	/* chan0 highest */
+#define CHAN_PRIORITY_DESCENDING	1	/* chan7 highest */
+	unsigned char	chan_priority;
+	unsigned short	block_size;
+	unsigned char	nr_masters;
+	unsigned char	data_width[4];
+};
+
+/* bursts size */
+enum dw_dma_msize {
+	DW_DMA_MSIZE_1,
+	DW_DMA_MSIZE_4,
+	DW_DMA_MSIZE_8,
+	DW_DMA_MSIZE_16,
+	DW_DMA_MSIZE_32,
+	DW_DMA_MSIZE_64,
+	DW_DMA_MSIZE_128,
+	DW_DMA_MSIZE_256,
+};
+
+/* Platform-configurable bits in CFG_HI */
+#define DWC_CFGH_FCMODE		(1 << 0)
+#define DWC_CFGH_FIFO_MODE	(1 << 1)
+#define DWC_CFGH_PROTCTL(x)	((x) << 2)
+#define DWC_CFGH_SRC_PER(x)	((x) << 7)
+#define DWC_CFGH_DST_PER(x)	((x) << 11)
+
+/* Platform-configurable bits in CFG_LO */
+#define DWC_CFGL_LOCK_CH_XFER	(0 << 12)	/* scope of LOCK_CH */
+#define DWC_CFGL_LOCK_CH_BLOCK	(1 << 12)
+#define DWC_CFGL_LOCK_CH_XACT	(2 << 12)
+#define DWC_CFGL_LOCK_BUS_XFER	(0 << 14)	/* scope of LOCK_BUS */
+#define DWC_CFGL_LOCK_BUS_BLOCK	(1 << 14)
+#define DWC_CFGL_LOCK_BUS_XACT	(2 << 14)
+#define DWC_CFGL_LOCK_CH	(1 << 15)	/* channel lockout */
+#define DWC_CFGL_LOCK_BUS	(1 << 16)	/* busmaster lockout */
+#define DWC_CFGL_HS_DST_POL	(1 << 18)	/* dst handshake active low */
+#define DWC_CFGL_HS_SRC_POL	(1 << 19)	/* src handshake active low */
+
+/* DMA API extensions */
+struct dw_cyclic_desc {
+	struct dw_desc	**desc;
+	unsigned long	periods;
+	void		(*period_callback)(void *param);
+	void		*period_callback_param;
+};
+
+struct dw_cyclic_desc *dw_dma_cyclic_prep(struct dma_chan *chan,
+		dma_addr_t buf_addr, size_t buf_len, size_t period_len,
+		enum dma_transfer_direction direction);
+void dw_dma_cyclic_free(struct dma_chan *chan);
+int dw_dma_cyclic_start(struct dma_chan *chan);
+void dw_dma_cyclic_stop(struct dma_chan *chan);
+
+dma_addr_t dw_dma_get_src_addr(struct dma_chan *chan);
+
+dma_addr_t dw_dma_get_dst_addr(struct dma_chan *chan);
+
+#endif /* DW_DMAC_H */
