commit f5152416528c2295f35dd9c9bd4fb27c4032413d
Author: Qian Cai <cai@lca.pw>
Date:   Thu Mar 5 15:15:02 2020 -0500

    iommu/vt-d: Silence RCU-list debugging warnings
    
    Similar to the commit 02d715b4a818 ("iommu/vt-d: Fix RCU list debugging
    warnings"), there are several other places that call
    list_for_each_entry_rcu() outside of an RCU read side critical section
    but with dmar_global_lock held. Silence those false positives as well.
    
     drivers/iommu/intel-iommu.c:4288 RCU-list traversed in non-reader section!!
     1 lock held by swapper/0/1:
      #0: ffffffff935892c8 (dmar_global_lock){+.+.}, at: intel_iommu_init+0x1ad/0xb97
    
     drivers/iommu/dmar.c:366 RCU-list traversed in non-reader section!!
     1 lock held by swapper/0/1:
      #0: ffffffff935892c8 (dmar_global_lock){+.+.}, at: intel_iommu_init+0x125/0xb97
    
     drivers/iommu/intel-iommu.c:5057 RCU-list traversed in non-reader section!!
     1 lock held by swapper/0/1:
      #0: ffffffffa71892c8 (dmar_global_lock){++++}, at: intel_iommu_init+0x61a/0xb13
    
    Signed-off-by: Qian Cai <cai@lca.pw>
    Acked-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 712be8bc6a7c..d7bf029df737 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -74,11 +74,13 @@ extern struct list_head dmar_drhd_units;
 				dmar_rcu_check())
 
 #define for_each_active_drhd_unit(drhd)					\
-	list_for_each_entry_rcu(drhd, &dmar_drhd_units, list)		\
+	list_for_each_entry_rcu(drhd, &dmar_drhd_units, list,		\
+				dmar_rcu_check())			\
 		if (drhd->ignored) {} else
 
 #define for_each_active_iommu(i, drhd)					\
-	list_for_each_entry_rcu(drhd, &dmar_drhd_units, list)		\
+	list_for_each_entry_rcu(drhd, &dmar_drhd_units, list,		\
+				dmar_rcu_check())			\
 		if (i=drhd->iommu, drhd->ignored) {} else
 
 #define for_each_iommu(i, drhd)						\

commit 02d715b4a8182f4887d82df82a7b83aced647760
Author: Amol Grover <frextrite@gmail.com>
Date:   Sun Feb 23 22:25:39 2020 +0530

    iommu/vt-d: Fix RCU list debugging warnings
    
    dmar_drhd_units is traversed using list_for_each_entry_rcu()
    outside of an RCU read side critical section but under the
    protection of dmar_global_lock. Hence add corresponding lockdep
    expression to silence the following false-positive warnings:
    
    [    1.603975] =============================
    [    1.603976] WARNING: suspicious RCU usage
    [    1.603977] 5.5.4-stable #17 Not tainted
    [    1.603978] -----------------------------
    [    1.603980] drivers/iommu/intel-iommu.c:4769 RCU-list traversed in non-reader section!!
    
    [    1.603869] =============================
    [    1.603870] WARNING: suspicious RCU usage
    [    1.603872] 5.5.4-stable #17 Not tainted
    [    1.603874] -----------------------------
    [    1.603875] drivers/iommu/dmar.c:293 RCU-list traversed in non-reader section!!
    
    Tested-by: Madhuparna Bhowmik <madhuparnabhowmik10@gmail.com>
    Signed-off-by: Amol Grover <frextrite@gmail.com>
    Cc: stable@vger.kernel.org
    Acked-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index f64ca27dc210..712be8bc6a7c 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -69,8 +69,9 @@ struct dmar_pci_notify_info {
 extern struct rw_semaphore dmar_global_lock;
 extern struct list_head dmar_drhd_units;
 
-#define for_each_drhd_unit(drhd) \
-	list_for_each_entry_rcu(drhd, &dmar_drhd_units, list)
+#define for_each_drhd_unit(drhd)					\
+	list_for_each_entry_rcu(drhd, &dmar_drhd_units, list,		\
+				dmar_rcu_check())
 
 #define for_each_active_drhd_unit(drhd)					\
 	list_for_each_entry_rcu(drhd, &dmar_drhd_units, list)		\
@@ -81,7 +82,8 @@ extern struct list_head dmar_drhd_units;
 		if (i=drhd->iommu, drhd->ignored) {} else
 
 #define for_each_iommu(i, drhd)						\
-	list_for_each_entry_rcu(drhd, &dmar_drhd_units, list)		\
+	list_for_each_entry_rcu(drhd, &dmar_drhd_units, list,		\
+				dmar_rcu_check())			\
 		if (i=drhd->iommu, 0) {} else 
 
 static inline bool dmar_rcu_check(void)

commit 6c3a44ed3c553c324845744f30bcd1d3b07d61fd
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Sun Nov 10 09:27:44 2019 -0800

    iommu/vt-d: Turn off translations at shutdown
    
    The intel-iommu driver assumes that the iommu state is
    cleaned up at the start of the new kernel.
    But, when we try to kexec boot something other than the
    Linux kernel, the cleanup cannot be relied upon.
    Hence, cleanup before we go down for reboot.
    
    Keeping the cleanup at initialization also, in case BIOS
    leaves the IOMMU enabled.
    
    I considered turning off iommu only during kexec reboot, but a clean
    shutdown seems always a good idea. But if someone wants to make it
    conditional, such as VMM live update, we can do that.  There doesn't
    seem to be such a condition at this time.
    
    Tested that before, the info message
    'DMAR: Translation was enabled for <iommu> but we are not in kdump mode'
    would be reported for each iommu. The message will not appear when the
    DMA-remapping is not enabled on entry to the kernel.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Acked-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index a7cf3599d9a1..f64ca27dc210 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -129,6 +129,7 @@ static inline int dmar_res_noop(struct acpi_dmar_header *hdr, void *arg)
 #ifdef CONFIG_INTEL_IOMMU
 extern int iommu_detected, no_iommu;
 extern int intel_iommu_init(void);
+extern void intel_iommu_shutdown(void);
 extern int dmar_parse_one_rmrr(struct acpi_dmar_header *header, void *arg);
 extern int dmar_parse_one_atsr(struct acpi_dmar_header *header, void *arg);
 extern int dmar_check_one_atsr(struct acpi_dmar_header *hdr, void *arg);
@@ -137,6 +138,7 @@ extern int dmar_iommu_hotplug(struct dmar_drhd_unit *dmaru, bool insert);
 extern int dmar_iommu_notify_scope_dev(struct dmar_pci_notify_info *info);
 #else /* !CONFIG_INTEL_IOMMU: */
 static inline int intel_iommu_init(void) { return -ENODEV; }
+static inline void intel_iommu_shutdown(void) { }
 
 #define	dmar_parse_one_rmrr		dmar_res_noop
 #define	dmar_parse_one_atsr		dmar_res_noop

commit a760f8a67cb38d19fd52f2a28c65c967e469367e
Author: Qian Cai <cai@lca.pw>
Date:   Thu Jul 11 20:52:24 2019 -0700

    include/linux/dmar.h: replace single-char identifiers in macros
    
    There are a few macros in IOMMU have single-char identifiers make the code
    hard to read and debug.  Replace them with meaningful names.
    
    Link: http://lkml.kernel.org/r/1559566783-13627-1-git-send-email-cai@lca.pw
    Signed-off-by: Qian Cai <cai@lca.pw>
    Suggested-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Joerg Roedel <jroedel@suse.de>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 28813c6f44b6..a7cf3599d9a1 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -92,12 +92,14 @@ static inline bool dmar_rcu_check(void)
 
 #define	dmar_rcu_dereference(p)	rcu_dereference_check((p), dmar_rcu_check())
 
-#define	for_each_dev_scope(a, c, p, d)	\
-	for ((p) = 0; ((d) = (p) < (c) ? dmar_rcu_dereference((a)[(p)].dev) : \
-			NULL, (p) < (c)); (p)++)
-
-#define	for_each_active_dev_scope(a, c, p, d)	\
-	for_each_dev_scope((a), (c), (p), (d))	if (!(d)) { continue; } else
+#define for_each_dev_scope(devs, cnt, i, tmp)				\
+	for ((i) = 0; ((tmp) = (i) < (cnt) ?				\
+	    dmar_rcu_dereference((devs)[(i)].dev) : NULL, (i) < (cnt)); \
+	    (i)++)
+
+#define for_each_active_dev_scope(devs, cnt, i, tmp)			\
+	for_each_dev_scope((devs), (cnt), (i), (tmp))			\
+		if (!(tmp)) { continue; } else
 
 extern int dmar_table_init(void);
 extern int dmar_dev_scope_init(void);

commit 3b20eb23724d493eca79f02b1e062bd5432e29d0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:35 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 320
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms and conditions of the gnu general public license
      version 2 as published by the free software foundation this program
      is distributed in the hope it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 59 temple place suite 330 boston ma 02111
      1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 33 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000435.254582722@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index f8af1d770520..28813c6f44b6 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -1,19 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (c) 2006, Intel Corporation.
  *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
- * Place - Suite 330, Boston, MA 02111-1307 USA.
- *
  * Copyright (C) Ashok Raj <ashok.raj@intel.com>
  * Copyright (C) Shaohua Li <shaohua.li@intel.com>
  */

commit 89a6079df791aeace2044ea93be1b397195824ec
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Tue Oct 23 15:45:01 2018 +0800

    iommu/vt-d: Force IOMMU on for platform opt in hint
    
    Intel VT-d spec added a new DMA_CTRL_PLATFORM_OPT_IN_FLAG flag in DMAR
    ACPI table [1] for BIOS to report compliance about platform initiated
    DMA restricted to RMRR ranges when transferring control to the OS. This
    means that during OS boot, before it enables IOMMU none of the connected
    devices can bypass DMA protection for instance by overwriting the data
    structures used by the IOMMU. The OS also treats this as a hint that the
    IOMMU should be enabled to prevent DMA attacks from possible malicious
    devices.
    
    A use of this flag is Kernel DMA protection for Thunderbolt [2] which in
    practice means that IOMMU should be enabled for PCIe devices connected
    to the Thunderbolt ports. With IOMMU enabled for these devices, all DMA
    operations are limited in the range reserved for it, thus the DMA
    attacks are prevented. All these devices are enumerated in the PCI/PCIe
    module and marked with an untrusted flag.
    
    This forces IOMMU to be enabled if DMA_CTRL_PLATFORM_OPT_IN_FLAG is set
    in DMAR ACPI table and there are PCIe devices marked as untrusted in the
    system. This can be turned off by adding "intel_iommu=off" in the kernel
    command line, if any problems are found.
    
    [1] https://software.intel.com/sites/default/files/managed/c5/15/vt-directed-io-spec.pdf
    [2] https://docs.microsoft.com/en-us/windows/security/information-protection/kernel-dma-protection-for-thunderbolt
    
    Cc: Jacob Pan <jacob.jun.pan@linux.intel.com>
    Cc: Sohil Mehta <sohil.mehta@intel.com>
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Ashok Raj <ashok.raj@intel.com>
    Reviewed-by: Joerg Roedel <jroedel@suse.de>
    Acked-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 843a41ba7e28..f8af1d770520 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -39,6 +39,7 @@ struct acpi_dmar_header;
 /* DMAR Flags */
 #define DMAR_INTR_REMAP		0x1
 #define DMAR_X2APIC_OPT_OUT	0x2
+#define DMAR_PLATFORM_OPT_IN	0x4
 
 struct intel_iommu;
 
@@ -170,6 +171,8 @@ static inline int dmar_ir_hotplug(struct dmar_drhd_unit *dmaru, bool insert)
 { return 0; }
 #endif /* CONFIG_IRQ_REMAP */
 
+extern bool dmar_platform_optin(void);
+
 #else /* CONFIG_DMAR_TABLE */
 
 static inline int dmar_device_add(void *handle)
@@ -182,6 +185,11 @@ static inline int dmar_device_remove(void *handle)
 	return 0;
 }
 
+static inline bool dmar_platform_optin(void)
+{
+	return false;
+}
+
 #endif /* CONFIG_DMAR_TABLE */
 
 struct irte {

commit 818b7587b4d34e989ea6c042eeb8d50ffa5be13e
Author: Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
Date:   Wed Jun 27 10:31:20 2018 -0500

    x86: irq_remapping: Move irq remapping mode enum
    
    The enum is currently defined in Intel-specific DMAR header file,
    but it is also used by APIC common code. Therefore, move it to
    a more appropriate interrupt-remapping common header file.
    This will also be used by subsequent patches.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Joerg Roedel <jroedel@suse.de>
    Signed-off-by: Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index e2433bc50210..843a41ba7e28 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -265,11 +265,6 @@ static inline void dmar_copy_shared_irte(struct irte *dst, struct irte *src)
 #define PDA_LOW_BIT    26
 #define PDA_HIGH_BIT   32
 
-enum {
-	IRQ_REMAP_XAPIC_MODE,
-	IRQ_REMAP_X2APIC_MODE,
-};
-
 /* Can't use the common MSI interrupt functions
  * since DMAR is not a pci device
  */

commit ec154bf56b276a0bb36079a5d22a267b5f417801
Author: Joerg Roedel <jroedel@suse.de>
Date:   Fri Oct 6 15:00:53 2017 +0200

    iommu/vt-d: Don't register bus-notifier under dmar_global_lock
    
    The notifier function will take the dmar_global_lock too, so
    lockdep complains about inverse locking order when the
    notifier is registered under the dmar_global_lock.
    
    Reported-by: Jan Kiszka <jan.kiszka@siemens.com>
    Fixes: 59ce0515cdaf ('iommu/vt-d: Update DRHD/RMRR/ATSR device scope caches when PCI hotplug happens')
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index e8ffba1052d3..e2433bc50210 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -112,6 +112,7 @@ static inline bool dmar_rcu_check(void)
 
 extern int dmar_table_init(void);
 extern int dmar_dev_scope_init(void);
+extern void dmar_register_bus_notifier(void);
 extern int dmar_parse_dev_scope(void *start, void *end, int *cnt,
 				struct dmar_dev_scope **devices, u16 segment);
 extern void *dmar_alloc_dev_scope(void *start, void *end, int *cnt);

commit b2d091031075ac9a1598e3cc3a29c28f02e64c0d
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Feb 4 01:27:20 2017 +0100

    sched/headers: Prepare to use <linux/rcuupdate.h> instead of <linux/rculist.h> in <linux/sched.h>
    
    We don't actually need the full rculist.h header in sched.h anymore,
    we will be able to include the smaller rcupdate.h header instead.
    
    But first update code that relied on the implicit header inclusion.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index e9bc9292bd3a..e8ffba1052d3 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -26,7 +26,7 @@
 #include <linux/msi.h>
 #include <linux/irqreturn.h>
 #include <linux/rwsem.h>
-#include <linux/rcupdate.h>
+#include <linux/rculist.h>
 
 struct acpi_dmar_header;
 

commit bf56027ff4d9e75bf668ae990fe6204d00a23002
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 9 13:20:30 2015 +0800

    iommu: dmar: Provide helper to copy shared irte fields
    
    Instead of open coding, provide a helper function to copy the shared
    irte fields.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: jiang.liu@linux.intel.com
    Cc: iommu@lists.linux-foundation.org
    Cc: joro@8bytes.org
    Cc: dwmw2@infradead.org
    Link: http://lkml.kernel.org/r/1433827237-3382-4-git-send-email-feng.wu@intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 0dbcabcb5f0d..e9bc9292bd3a 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -249,6 +249,18 @@ struct irte {
 	};
 };
 
+static inline void dmar_copy_shared_irte(struct irte *dst, struct irte *src)
+{
+	dst->present	= src->present;
+	dst->fpd	= src->fpd;
+	dst->avail	= src->avail;
+	dst->pst	= src->pst;
+	dst->vector	= src->vector;
+	dst->sid	= src->sid;
+	dst->sq		= src->sq;
+	dst->svt	= src->svt;
+}
+
 #define PDA_LOW_BIT    26
 #define PDA_HIGH_BIT   32
 

commit 3bf17472226b0041b0c61363bd57a5cadbe620c4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 9 13:20:29 2015 +0800

    iommu: dmar: Extend struct irte for VT-d Posted-Interrupts
    
    The IRTE (Interrupt Remapping Table Entry) is either an entry for
    remapped or for posted interrupts. The hardware distiguishes between
    remapped and posted entries by bit 15 in the low 64 bit of the
    IRTE. If cleared the entry is remapped, if set it's posted.
    
    The entries have common fields and dependent on the posted bit fields
    with different meanings.
    
    Extend struct irte to handle the differences between remap and posted
    mode by having three structs in the unions:
    
            - Shared
            - Remapped
            - Posted
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Feng Wu <feng.wu@intel.com>
    Acked-by: Joerg Roedel <joro@8bytes.org>
    Cc: jiang.liu@linux.intel.com
    Cc: iommu@lists.linux-foundation.org
    Cc: dwmw2@infradead.org
    Link: http://lkml.kernel.org/r/1433827237-3382-3-git-send-email-feng.wu@intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 84737565c1fd..0dbcabcb5f0d 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -185,33 +185,73 @@ static inline int dmar_device_remove(void *handle)
 
 struct irte {
 	union {
+		/* Shared between remapped and posted mode*/
 		struct {
-			__u64	present 	: 1,
-				fpd		: 1,
-				dst_mode	: 1,
-				redir_hint	: 1,
-				trigger_mode	: 1,
-				dlvry_mode	: 3,
-				avail		: 4,
-				__reserved_1	: 4,
-				vector		: 8,
-				__reserved_2	: 8,
-				dest_id		: 32;
+			__u64	present		: 1,  /*  0      */
+				fpd		: 1,  /*  1      */
+				__res0		: 6,  /*  2 -  6 */
+				avail		: 4,  /*  8 - 11 */
+				__res1		: 3,  /* 12 - 14 */
+				pst		: 1,  /* 15      */
+				vector		: 8,  /* 16 - 23 */
+				__res2		: 40; /* 24 - 63 */
+		};
+
+		/* Remapped mode */
+		struct {
+			__u64	r_present	: 1,  /*  0      */
+				r_fpd		: 1,  /*  1      */
+				dst_mode	: 1,  /*  2      */
+				redir_hint	: 1,  /*  3      */
+				trigger_mode	: 1,  /*  4      */
+				dlvry_mode	: 3,  /*  5 -  7 */
+				r_avail		: 4,  /*  8 - 11 */
+				r_res0		: 4,  /* 12 - 15 */
+				r_vector	: 8,  /* 16 - 23 */
+				r_res1		: 8,  /* 24 - 31 */
+				dest_id		: 32; /* 32 - 63 */
+		};
+
+		/* Posted mode */
+		struct {
+			__u64	p_present	: 1,  /*  0      */
+				p_fpd		: 1,  /*  1      */
+				p_res0		: 6,  /*  2 -  7 */
+				p_avail		: 4,  /*  8 - 11 */
+				p_res1		: 2,  /* 12 - 13 */
+				p_urgent	: 1,  /* 14      */
+				p_pst		: 1,  /* 15      */
+				p_vector	: 8,  /* 16 - 23 */
+				p_res2		: 14, /* 24 - 37 */
+				pda_l		: 26; /* 38 - 63 */
 		};
 		__u64 low;
 	};
 
 	union {
+		/* Shared between remapped and posted mode*/
 		struct {
-			__u64	sid		: 16,
-				sq		: 2,
-				svt		: 2,
-				__reserved_3	: 44;
+			__u64	sid		: 16,  /* 64 - 79  */
+				sq		: 2,   /* 80 - 81  */
+				svt		: 2,   /* 82 - 83  */
+				__res3		: 44;  /* 84 - 127 */
+		};
+
+		/* Posted mode*/
+		struct {
+			__u64	p_sid		: 16,  /* 64 - 79  */
+				p_sq		: 2,   /* 80 - 81  */
+				p_svt		: 2,   /* 82 - 83  */
+				p_res3		: 12,  /* 84 - 95  */
+				pda_h		: 32;  /* 96 - 127 */
 		};
 		__u64 high;
 	};
 };
 
+#define PDA_LOW_BIT    26
+#define PDA_HIGH_BIT   32
+
 enum {
 	IRQ_REMAP_XAPIC_MODE,
 	IRQ_REMAP_X2APIC_MODE,

commit 34742db8eaf9ff364034f214ee5827701e131d4b
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Apr 13 14:11:41 2015 +0800

    iommu/vt-d: Refine the interfaces to create IRQ for DMAR unit
    
    Refine the interfaces to create IRQ for DMAR unit. It's a preparation
    for converting DMAR IRQ to hierarchical irqdomain on x86.
    
    It also moves dmar_alloc_hwirq()/dmar_free_hwirq() from irq_remapping.h
    to dmar.h. They are not irq_remapping specific.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: David Cohen <david.a.cohen@linux.intel.com>
    Cc: Sander Eikelenboom <linux@eikelenboom.it>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: iommu@lists.linux-foundation.org
    Cc: Vinod Koul <vinod.koul@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dimitri Sivanich <sivanich@sgi.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Link: http://lkml.kernel.org/r/1428905519-23704-20-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 30624954dec5..84737565c1fd 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -227,6 +227,7 @@ extern void dmar_msi_read(int irq, struct msi_msg *msg);
 extern void dmar_msi_write(int irq, struct msi_msg *msg);
 extern int dmar_set_interrupt(struct intel_iommu *iommu);
 extern irqreturn_t dmar_fault(int irq, void *dev_id);
-extern int arch_setup_dmar_msi(unsigned int irq);
+extern int dmar_alloc_hwirq(int id, int node, void *arg);
+extern void dmar_free_hwirq(int irq);
 
 #endif /* __DMAR_H__ */

commit 6b1972493a84f8fe13ff9d202745590f6c53d670
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Sun Nov 9 22:47:58 2014 +0800

    iommu/vt-d: Implement DMAR unit hotplug framework
    
    On Intel platforms, an IO Hub (PCI/PCIe host bridge) may contain DMAR
    units, so we need to support DMAR hotplug when supporting PCI host
    bridge hotplug on Intel platforms.
    
    According to Section 8.8 "Remapping Hardware Unit Hot Plug" in "Intel
    Virtualization Technology for Directed IO Architecture Specification
    Rev 2.2", ACPI BIOS should implement ACPI _DSM method under the ACPI
    object for the PCI host bridge to support DMAR hotplug.
    
    This patch introduces interfaces to parse ACPI _DSM method for
    DMAR unit hotplug. It also implements state machines for DMAR unit
    hot-addition and hot-removal.
    
    The PCI host bridge hotplug driver should call dmar_hotplug_hotplug()
    before scanning PCI devices connected for hot-addition and after
    destroying all PCI devices for hot-removal.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Reviewed-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 725204fc433e..30624954dec5 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -126,6 +126,8 @@ extern int dmar_remove_dev_scope(struct dmar_pci_notify_info *info,
 /* Intel IOMMU detection */
 extern int detect_intel_iommu(void);
 extern int enable_drhd_fault_handling(void);
+extern int dmar_device_add(acpi_handle handle);
+extern int dmar_device_remove(acpi_handle handle);
 
 static inline int dmar_res_noop(struct acpi_dmar_header *hdr, void *arg)
 {
@@ -137,17 +139,48 @@ extern int iommu_detected, no_iommu;
 extern int intel_iommu_init(void);
 extern int dmar_parse_one_rmrr(struct acpi_dmar_header *header, void *arg);
 extern int dmar_parse_one_atsr(struct acpi_dmar_header *header, void *arg);
+extern int dmar_check_one_atsr(struct acpi_dmar_header *hdr, void *arg);
+extern int dmar_release_one_atsr(struct acpi_dmar_header *hdr, void *arg);
+extern int dmar_iommu_hotplug(struct dmar_drhd_unit *dmaru, bool insert);
 extern int dmar_iommu_notify_scope_dev(struct dmar_pci_notify_info *info);
 #else /* !CONFIG_INTEL_IOMMU: */
 static inline int intel_iommu_init(void) { return -ENODEV; }
+
 #define	dmar_parse_one_rmrr		dmar_res_noop
 #define	dmar_parse_one_atsr		dmar_res_noop
+#define	dmar_check_one_atsr		dmar_res_noop
+#define	dmar_release_one_atsr		dmar_res_noop
+
 static inline int dmar_iommu_notify_scope_dev(struct dmar_pci_notify_info *info)
 {
 	return 0;
 }
+
+static inline int dmar_iommu_hotplug(struct dmar_drhd_unit *dmaru, bool insert)
+{
+	return 0;
+}
 #endif /* CONFIG_INTEL_IOMMU */
 
+#ifdef CONFIG_IRQ_REMAP
+extern int dmar_ir_hotplug(struct dmar_drhd_unit *dmaru, bool insert);
+#else  /* CONFIG_IRQ_REMAP */
+static inline int dmar_ir_hotplug(struct dmar_drhd_unit *dmaru, bool insert)
+{ return 0; }
+#endif /* CONFIG_IRQ_REMAP */
+
+#else /* CONFIG_DMAR_TABLE */
+
+static inline int dmar_device_add(void *handle)
+{
+	return 0;
+}
+
+static inline int dmar_device_remove(void *handle)
+{
+	return 0;
+}
+
 #endif /* CONFIG_DMAR_TABLE */
 
 struct irte {

commit 78d8e7046111425bb688cddc4303d79cb0f0d281
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Sun Nov 9 22:47:57 2014 +0800

    iommu/vt-d: Dynamically allocate and free seq_id for DMAR units
    
    Introduce functions to support dynamic IOMMU seq_id allocating and
    releasing, which will be used to support DMAR hotplug.
    
    Also rename IOMMU_UNITS_SUPPORTED as DMAR_UNITS_SUPPORTED.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Reviewed-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 495df5e48f80..725204fc433e 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -30,6 +30,12 @@
 
 struct acpi_dmar_header;
 
+#ifdef	CONFIG_X86
+# define	DMAR_UNITS_SUPPORTED	MAX_IO_APICS
+#else
+# define	DMAR_UNITS_SUPPORTED	64
+#endif
+
 /* DMAR Flags */
 #define DMAR_INTR_REMAP		0x1
 #define DMAR_X2APIC_OPT_OUT	0x2

commit c2a0b538d2c778aef7bf2fbe7973229192c9a392
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Sun Nov 9 22:47:56 2014 +0800

    iommu/vt-d: Introduce helper function dmar_walk_resources()
    
    Introduce helper function dmar_walk_resources to walk resource entries
    in DMAR table and ACPI buffer object returned by ACPI _DSM method
    for IOMMU hot-plug.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 593fff99e6bf..495df5e48f80 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -121,22 +121,21 @@ extern int dmar_remove_dev_scope(struct dmar_pci_notify_info *info,
 extern int detect_intel_iommu(void);
 extern int enable_drhd_fault_handling(void);
 
+static inline int dmar_res_noop(struct acpi_dmar_header *hdr, void *arg)
+{
+	return 0;
+}
+
 #ifdef CONFIG_INTEL_IOMMU
 extern int iommu_detected, no_iommu;
 extern int intel_iommu_init(void);
-extern int dmar_parse_one_rmrr(struct acpi_dmar_header *header);
-extern int dmar_parse_one_atsr(struct acpi_dmar_header *header);
+extern int dmar_parse_one_rmrr(struct acpi_dmar_header *header, void *arg);
+extern int dmar_parse_one_atsr(struct acpi_dmar_header *header, void *arg);
 extern int dmar_iommu_notify_scope_dev(struct dmar_pci_notify_info *info);
 #else /* !CONFIG_INTEL_IOMMU: */
 static inline int intel_iommu_init(void) { return -ENODEV; }
-static inline int dmar_parse_one_rmrr(struct acpi_dmar_header *header)
-{
-	return 0;
-}
-static inline int dmar_parse_one_atsr(struct acpi_dmar_header *header)
-{
-	return 0;
-}
+#define	dmar_parse_one_rmrr		dmar_res_noop
+#define	dmar_parse_one_atsr		dmar_res_noop
 static inline int dmar_iommu_notify_scope_dev(struct dmar_pci_notify_info *info)
 {
 	return 0;

commit 57384592c43375d2c9a14d82aebbdc95fdda9e9d
Author: Joerg Roedel <jroedel@suse.de>
Date:   Thu Oct 2 11:50:25 2014 +0200

    iommu/vt-d: Store bus information in RMRR PCI device path
    
    This will be used later to match broken RMRR entries.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 1deece46a0ca..593fff99e6bf 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -56,13 +56,19 @@ struct dmar_drhd_unit {
 	struct intel_iommu *iommu;
 };
 
+struct dmar_pci_path {
+	u8 bus;
+	u8 device;
+	u8 function;
+};
+
 struct dmar_pci_notify_info {
 	struct pci_dev			*dev;
 	unsigned long			event;
 	int				bus;
 	u16				seg;
 	u16				level;
-	struct acpi_dmar_pci_path	path[];
+	struct dmar_pci_path		path[];
 }  __attribute__((packed));
 
 extern struct rw_semaphore dmar_global_lock;

commit 8594d83261d14754288ef00993f0971131ff08eb
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Fri Jul 11 14:19:32 2014 +0800

    iommu/vt-d: Simplify include/linux/dmar.h
    
    Simplify include/linux/dmar.h a bit based on the fact that
    both CONFIG_INTEL_IOMMU and CONFIG_IRQ_REMAP select CONFIG_DMAR_TABLE.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 23c8db129560..1deece46a0ca 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -114,22 +114,30 @@ extern int dmar_remove_dev_scope(struct dmar_pci_notify_info *info,
 /* Intel IOMMU detection */
 extern int detect_intel_iommu(void);
 extern int enable_drhd_fault_handling(void);
-#else
-struct dmar_pci_notify_info;
-static inline int detect_intel_iommu(void)
+
+#ifdef CONFIG_INTEL_IOMMU
+extern int iommu_detected, no_iommu;
+extern int intel_iommu_init(void);
+extern int dmar_parse_one_rmrr(struct acpi_dmar_header *header);
+extern int dmar_parse_one_atsr(struct acpi_dmar_header *header);
+extern int dmar_iommu_notify_scope_dev(struct dmar_pci_notify_info *info);
+#else /* !CONFIG_INTEL_IOMMU: */
+static inline int intel_iommu_init(void) { return -ENODEV; }
+static inline int dmar_parse_one_rmrr(struct acpi_dmar_header *header)
 {
-	return -ENODEV;
+	return 0;
 }
-
-static inline int dmar_table_init(void)
+static inline int dmar_parse_one_atsr(struct acpi_dmar_header *header)
 {
-	return -ENODEV;
+	return 0;
 }
-static inline int enable_drhd_fault_handling(void)
+static inline int dmar_iommu_notify_scope_dev(struct dmar_pci_notify_info *info)
 {
-	return -1;
+	return 0;
 }
-#endif /* !CONFIG_DMAR_TABLE */
+#endif /* CONFIG_INTEL_IOMMU */
+
+#endif /* CONFIG_DMAR_TABLE */
 
 struct irte {
 	union {
@@ -177,26 +185,4 @@ extern int dmar_set_interrupt(struct intel_iommu *iommu);
 extern irqreturn_t dmar_fault(int irq, void *dev_id);
 extern int arch_setup_dmar_msi(unsigned int irq);
 
-#ifdef CONFIG_INTEL_IOMMU
-extern int iommu_detected, no_iommu;
-extern int dmar_parse_one_rmrr(struct acpi_dmar_header *header);
-extern int dmar_parse_one_atsr(struct acpi_dmar_header *header);
-extern int dmar_iommu_notify_scope_dev(struct dmar_pci_notify_info *info);
-extern int intel_iommu_init(void);
-#else /* !CONFIG_INTEL_IOMMU: */
-static inline int intel_iommu_init(void) { return -ENODEV; }
-static inline int dmar_parse_one_rmrr(struct acpi_dmar_header *header)
-{
-	return 0;
-}
-static inline int dmar_parse_one_atsr(struct acpi_dmar_header *header)
-{
-	return 0;
-}
-static inline int dmar_iommu_notify_scope_dev(struct dmar_pci_notify_info *info)
-{
-	return 0;
-}
-#endif /* CONFIG_INTEL_IOMMU */
-
 #endif /* __DMAR_H__ */

commit 832bd858674023b2415c7585db3beba345ef807f
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Fri Mar 7 15:08:36 2014 +0000

    iommu/vt-d: Change scope lists to struct device, bus, devfn
    
    It's not only for PCI devices any more, and the scope information for an
    ACPI device provides the bus and devfn so that has to be stored here too.
    
    It is the device pointer itself which needs to be protected with RCU,
    so the __rcu annotation follows it into the definition of struct
    dmar_dev_scope, since we're no longer just passing arrays of device
    pointers around.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 0a92e4d978bc..23c8db129560 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -36,13 +36,19 @@ struct acpi_dmar_header;
 
 struct intel_iommu;
 
+struct dmar_dev_scope {
+	struct device __rcu *dev;
+	u8 bus;
+	u8 devfn;
+};
+
 #ifdef CONFIG_DMAR_TABLE
 extern struct acpi_table_header *dmar_tbl;
 struct dmar_drhd_unit {
 	struct list_head list;		/* list of drhd units	*/
 	struct  acpi_dmar_header *hdr;	/* ACPI header		*/
 	u64	reg_base_addr;		/* register base address*/
-	struct	pci_dev __rcu **devices;/* target device array	*/
+	struct	dmar_dev_scope *devices;/* target device array	*/
 	int	devices_cnt;		/* target device count	*/
 	u16	segment;		/* PCI domain		*/
 	u8	ignored:1; 		/* ignore drhd		*/
@@ -86,7 +92,7 @@ static inline bool dmar_rcu_check(void)
 #define	dmar_rcu_dereference(p)	rcu_dereference_check((p), dmar_rcu_check())
 
 #define	for_each_dev_scope(a, c, p, d)	\
-	for ((p) = 0; ((d) = (p) < (c) ? dmar_rcu_dereference((a)[(p)]) : \
+	for ((p) = 0; ((d) = (p) < (c) ? dmar_rcu_dereference((a)[(p)].dev) : \
 			NULL, (p) < (c)); (p)++)
 
 #define	for_each_active_dev_scope(a, c, p, d)	\
@@ -95,15 +101,15 @@ static inline bool dmar_rcu_check(void)
 extern int dmar_table_init(void);
 extern int dmar_dev_scope_init(void);
 extern int dmar_parse_dev_scope(void *start, void *end, int *cnt,
-				struct pci_dev ***devices, u16 segment);
+				struct dmar_dev_scope **devices, u16 segment);
 extern void *dmar_alloc_dev_scope(void *start, void *end, int *cnt);
-extern void dmar_free_dev_scope(struct pci_dev __rcu ***devices, int *cnt);
+extern void dmar_free_dev_scope(struct dmar_dev_scope **devices, int *cnt);
 extern int dmar_insert_dev_scope(struct dmar_pci_notify_info *info,
 				 void *start, void*end, u16 segment,
-				 struct pci_dev __rcu **devices,
+				 struct dmar_dev_scope *devices,
 				 int devices_cnt);
 extern int dmar_remove_dev_scope(struct dmar_pci_notify_info *info,
-				 u16 segment, struct pci_dev __rcu **devices,
+				 u16 segment, struct dmar_dev_scope *devices,
 				 int count);
 /* Intel IOMMU detection */
 extern int detect_intel_iommu(void);

commit 2e45528930388658603ea24d49cf52867b928d3e
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Wed Feb 19 14:07:36 2014 +0800

    iommu/vt-d: Unify the way to process DMAR device scope array
    
    Now we have a PCI bus notification based mechanism to update DMAR
    device scope array, we could extend the mechanism to support boot
    time initialization too, which will help to unify and simplify
    the implementation.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 4e196430f1b2..0a92e4d978bc 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -173,7 +173,6 @@ extern int arch_setup_dmar_msi(unsigned int irq);
 
 #ifdef CONFIG_INTEL_IOMMU
 extern int iommu_detected, no_iommu;
-extern int dmar_parse_rmrr_atsr_dev(void);
 extern int dmar_parse_one_rmrr(struct acpi_dmar_header *header);
 extern int dmar_parse_one_atsr(struct acpi_dmar_header *header);
 extern int dmar_iommu_notify_scope_dev(struct dmar_pci_notify_info *info);
@@ -188,10 +187,6 @@ static inline int dmar_parse_one_atsr(struct acpi_dmar_header *header)
 {
 	return 0;
 }
-static inline int dmar_parse_rmrr_atsr_dev(void)
-{
-	return 0;
-}
 static inline int dmar_iommu_notify_scope_dev(struct dmar_pci_notify_info *info)
 {
 	return 0;

commit 59ce0515cdaf3b7d47893d12f61e51d691863788
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Wed Feb 19 14:07:35 2014 +0800

    iommu/vt-d: Update DRHD/RMRR/ATSR device scope caches when PCI hotplug happens
    
    Current Intel DMAR/IOMMU driver assumes that all PCI devices associated
    with DMAR/RMRR/ATSR device scope arrays are created at boot time and
    won't change at runtime, so it caches pointers of associated PCI device
    object. That assumption may be wrong now due to:
    1) introduction of PCI host bridge hotplug
    2) PCI device hotplug through sysfs interfaces.
    
    Wang Yijing has tried to solve this issue by caching <bus, dev, func>
    tupple instead of the PCI device object pointer, but that's still
    unreliable because PCI bus number may change in case of hotplug.
    Please refer to http://lkml.org/lkml/2013/11/5/64
    Message from Yingjing's mail:
    after remove and rescan a pci device
    [  611.857095] dmar: DRHD: handling fault status reg 2
    [  611.857109] dmar: DMAR:[DMA Read] Request device [86:00.3] fault addr ffff7000
    [  611.857109] DMAR:[fault reason 02] Present bit in context entry is clear
    [  611.857524] dmar: DRHD: handling fault status reg 102
    [  611.857534] dmar: DMAR:[DMA Read] Request device [86:00.3] fault addr ffff6000
    [  611.857534] DMAR:[fault reason 02] Present bit in context entry is clear
    [  611.857936] dmar: DRHD: handling fault status reg 202
    [  611.857947] dmar: DMAR:[DMA Read] Request device [86:00.3] fault addr ffff5000
    [  611.857947] DMAR:[fault reason 02] Present bit in context entry is clear
    [  611.858351] dmar: DRHD: handling fault status reg 302
    [  611.858362] dmar: DMAR:[DMA Read] Request device [86:00.3] fault addr ffff4000
    [  611.858362] DMAR:[fault reason 02] Present bit in context entry is clear
    [  611.860819] IPv6: ADDRCONF(NETDEV_UP): eth3: link is not ready
    [  611.860983] dmar: DRHD: handling fault status reg 402
    [  611.860995] dmar: INTR-REMAP: Request device [[86:00.3] fault index a4
    [  611.860995] INTR-REMAP:[fault reason 34] Present field in the IRTE entry is clear
    
    This patch introduces a new mechanism to update the DRHD/RMRR/ATSR device scope
    caches by hooking PCI bus notification.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index bedebab934b4..4e196430f1b2 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -50,6 +50,15 @@ struct dmar_drhd_unit {
 	struct intel_iommu *iommu;
 };
 
+struct dmar_pci_notify_info {
+	struct pci_dev			*dev;
+	unsigned long			event;
+	int				bus;
+	u16				seg;
+	u16				level;
+	struct acpi_dmar_pci_path	path[];
+}  __attribute__((packed));
+
 extern struct rw_semaphore dmar_global_lock;
 extern struct list_head dmar_drhd_units;
 
@@ -89,12 +98,18 @@ extern int dmar_parse_dev_scope(void *start, void *end, int *cnt,
 				struct pci_dev ***devices, u16 segment);
 extern void *dmar_alloc_dev_scope(void *start, void *end, int *cnt);
 extern void dmar_free_dev_scope(struct pci_dev __rcu ***devices, int *cnt);
-extern void dmar_free_dev_scope(struct pci_dev ***devices, int *cnt);
-
+extern int dmar_insert_dev_scope(struct dmar_pci_notify_info *info,
+				 void *start, void*end, u16 segment,
+				 struct pci_dev __rcu **devices,
+				 int devices_cnt);
+extern int dmar_remove_dev_scope(struct dmar_pci_notify_info *info,
+				 u16 segment, struct pci_dev __rcu **devices,
+				 int count);
 /* Intel IOMMU detection */
 extern int detect_intel_iommu(void);
 extern int enable_drhd_fault_handling(void);
 #else
+struct dmar_pci_notify_info;
 static inline int detect_intel_iommu(void)
 {
 	return -ENODEV;
@@ -161,6 +176,7 @@ extern int iommu_detected, no_iommu;
 extern int dmar_parse_rmrr_atsr_dev(void);
 extern int dmar_parse_one_rmrr(struct acpi_dmar_header *header);
 extern int dmar_parse_one_atsr(struct acpi_dmar_header *header);
+extern int dmar_iommu_notify_scope_dev(struct dmar_pci_notify_info *info);
 extern int intel_iommu_init(void);
 #else /* !CONFIG_INTEL_IOMMU: */
 static inline int intel_iommu_init(void) { return -ENODEV; }
@@ -176,6 +192,10 @@ static inline int dmar_parse_rmrr_atsr_dev(void)
 {
 	return 0;
 }
+static inline int dmar_iommu_notify_scope_dev(struct dmar_pci_notify_info *info)
+{
+	return 0;
+}
 #endif /* CONFIG_INTEL_IOMMU */
 
 #endif /* __DMAR_H__ */

commit 0e242612d9cdb46e878ed1f126c78fe68492af00
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Wed Feb 19 14:07:34 2014 +0800

    iommu/vt-d: Use RCU to protect global resources in interrupt context
    
    Global DMA and interrupt remapping resources may be accessed in
    interrupt context, so use RCU instead of rwsem to protect them
    in such cases.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 8f06a0135a84..bedebab934b4 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -26,6 +26,7 @@
 #include <linux/msi.h>
 #include <linux/irqreturn.h>
 #include <linux/rwsem.h>
+#include <linux/rcupdate.h>
 
 struct acpi_dmar_header;
 
@@ -41,7 +42,7 @@ struct dmar_drhd_unit {
 	struct list_head list;		/* list of drhd units	*/
 	struct  acpi_dmar_header *hdr;	/* ACPI header		*/
 	u64	reg_base_addr;		/* register base address*/
-	struct	pci_dev **devices; 	/* target device array	*/
+	struct	pci_dev __rcu **devices;/* target device array	*/
 	int	devices_cnt;		/* target device count	*/
 	u16	segment;		/* PCI domain		*/
 	u8	ignored:1; 		/* ignore drhd		*/
@@ -53,22 +54,31 @@ extern struct rw_semaphore dmar_global_lock;
 extern struct list_head dmar_drhd_units;
 
 #define for_each_drhd_unit(drhd) \
-	list_for_each_entry(drhd, &dmar_drhd_units, list)
+	list_for_each_entry_rcu(drhd, &dmar_drhd_units, list)
 
 #define for_each_active_drhd_unit(drhd)					\
-	list_for_each_entry(drhd, &dmar_drhd_units, list)		\
+	list_for_each_entry_rcu(drhd, &dmar_drhd_units, list)		\
 		if (drhd->ignored) {} else
 
 #define for_each_active_iommu(i, drhd)					\
-	list_for_each_entry(drhd, &dmar_drhd_units, list)		\
+	list_for_each_entry_rcu(drhd, &dmar_drhd_units, list)		\
 		if (i=drhd->iommu, drhd->ignored) {} else
 
 #define for_each_iommu(i, drhd)						\
-	list_for_each_entry(drhd, &dmar_drhd_units, list)		\
+	list_for_each_entry_rcu(drhd, &dmar_drhd_units, list)		\
 		if (i=drhd->iommu, 0) {} else 
 
+static inline bool dmar_rcu_check(void)
+{
+	return rwsem_is_locked(&dmar_global_lock) ||
+	       system_state == SYSTEM_BOOTING;
+}
+
+#define	dmar_rcu_dereference(p)	rcu_dereference_check((p), dmar_rcu_check())
+
 #define	for_each_dev_scope(a, c, p, d)	\
-	for ((p) = 0; ((d) = (p) < (c) ? (a)[(p)] : NULL, (p) < (c)); (p)++)
+	for ((p) = 0; ((d) = (p) < (c) ? dmar_rcu_dereference((a)[(p)]) : \
+			NULL, (p) < (c)); (p)++)
 
 #define	for_each_active_dev_scope(a, c, p, d)	\
 	for_each_dev_scope((a), (c), (p), (d))	if (!(d)) { continue; } else
@@ -78,6 +88,7 @@ extern int dmar_dev_scope_init(void);
 extern int dmar_parse_dev_scope(void *start, void *end, int *cnt,
 				struct pci_dev ***devices, u16 segment);
 extern void *dmar_alloc_dev_scope(void *start, void *end, int *cnt);
+extern void dmar_free_dev_scope(struct pci_dev __rcu ***devices, int *cnt);
 extern void dmar_free_dev_scope(struct pci_dev ***devices, int *cnt);
 
 /* Intel IOMMU detection */

commit 3a5670e8ac932c10a3e50d9dc0ab1da4cc3041d7
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Wed Feb 19 14:07:33 2014 +0800

    iommu/vt-d: Introduce a rwsem to protect global data structures
    
    Introduce a global rwsem dmar_global_lock, which will be used to
    protect DMAR related global data structures from DMAR/PCI/memory
    device hotplug operations in process context.
    
    DMA and interrupt remapping related data structures are read most,
    and only change when memory/PCI/DMAR hotplug event happens.
    So a global rwsem solution is adopted for balance between simplicity
    and performance.
    
    For interrupt remapping driver, function intel_irq_remapping_supported(),
    dmar_table_init(), intel_enable_irq_remapping(), disable_irq_remapping(),
    reenable_irq_remapping() and enable_drhd_fault_handling() etc
    are called during booting, suspending and resuming with interrupt
    disabled, so no need to take the global lock.
    
    For interrupt remapping entry allocation, the locking model is:
            down_read(&dmar_global_lock);
            /* Find corresponding iommu */
            iommu = map_hpet_to_ir(id);
            if (iommu)
                    /*
                     * Allocate remapping entry and mark entry busy,
                     * the IOMMU won't be hot-removed until the
                     * allocated entry has been released.
                     */
                    index = alloc_irte(iommu, irq, 1);
            up_read(&dmar_global_lock);
    
    For DMA remmaping driver, we only uses the dmar_global_lock rwsem to
    protect functions which are only called in process context. For any
    function which may be called in interrupt context, we will use RCU
    to protect them in following patches.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 4b77fd8fde76..8f06a0135a84 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -25,6 +25,7 @@
 #include <linux/types.h>
 #include <linux/msi.h>
 #include <linux/irqreturn.h>
+#include <linux/rwsem.h>
 
 struct acpi_dmar_header;
 
@@ -48,6 +49,7 @@ struct dmar_drhd_unit {
 	struct intel_iommu *iommu;
 };
 
+extern struct rw_semaphore dmar_global_lock;
 extern struct list_head dmar_drhd_units;
 
 #define for_each_drhd_unit(drhd) \

commit b683b230a244c3b2b3f6f3292e59d4a63298528b
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Wed Feb 19 14:07:32 2014 +0800

    iommu/vt-d: Introduce macro for_each_dev_scope() to walk device scope entries
    
    Introduce for_each_dev_scope()/for_each_active_dev_scope() to walk
    {active} device scope entries. This will help following RCU lock
    related patches.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index ea599d4ca9e0..4b77fd8fde76 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -65,6 +65,12 @@ extern struct list_head dmar_drhd_units;
 	list_for_each_entry(drhd, &dmar_drhd_units, list)		\
 		if (i=drhd->iommu, 0) {} else 
 
+#define	for_each_dev_scope(a, c, p, d)	\
+	for ((p) = 0; ((d) = (p) < (c) ? (a)[(p)] : NULL, (p) < (c)); (p)++)
+
+#define	for_each_active_dev_scope(a, c, p, d)	\
+	for_each_dev_scope((a), (c), (p), (d))	if (!(d)) { continue; } else
+
 extern int dmar_table_init(void);
 extern int dmar_dev_scope_init(void);
 extern int dmar_parse_dev_scope(void *start, void *end, int *cnt,

commit b94e4117f8c4ffb591b1e462364d725e3a1c63c4
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Wed Feb 19 14:07:25 2014 +0800

    iommu/vt-d: Move private structures and variables into intel-iommu.c
    
    Move private structures and variables into intel-iommu.c, which will
    help to simplify locking policy for hotplug. Also delete redundant
    declarations.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 1b08ce80bfbf..ea599d4ca9e0 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -139,28 +139,7 @@ extern int arch_setup_dmar_msi(unsigned int irq);
 
 #ifdef CONFIG_INTEL_IOMMU
 extern int iommu_detected, no_iommu;
-extern struct list_head dmar_rmrr_units;
-struct dmar_rmrr_unit {
-	struct list_head list;		/* list of rmrr units	*/
-	struct acpi_dmar_header *hdr;	/* ACPI header		*/
-	u64	base_address;		/* reserved base address*/
-	u64	end_address;		/* reserved end address */
-	struct pci_dev **devices;	/* target devices */
-	int	devices_cnt;		/* target device count */
-};
-
-#define for_each_rmrr_units(rmrr) \
-	list_for_each_entry(rmrr, &dmar_rmrr_units, list)
-
-struct dmar_atsr_unit {
-	struct list_head list;		/* list of ATSR units */
-	struct acpi_dmar_header *hdr;	/* ACPI header */
-	struct pci_dev **devices;	/* target devices */
-	int devices_cnt;		/* target device count */
-	u8 include_all:1;		/* include all ports */
-};
-
-int dmar_parse_rmrr_atsr_dev(void);
+extern int dmar_parse_rmrr_atsr_dev(void);
 extern int dmar_parse_one_rmrr(struct acpi_dmar_header *header);
 extern int dmar_parse_one_atsr(struct acpi_dmar_header *header);
 extern int intel_iommu_init(void);

commit bb3a6b7845851d23cb826040b4c3c9c294e7cfb4
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Wed Feb 19 14:07:24 2014 +0800

    iommu/vt-d: Factor out dmar_alloc_dev_scope() for later reuse
    
    Factor out function dmar_alloc_dev_scope() from dmar_parse_dev_scope()
    for later reuse.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index eccb0c0c6cf6..1b08ce80bfbf 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -69,6 +69,7 @@ extern int dmar_table_init(void);
 extern int dmar_dev_scope_init(void);
 extern int dmar_parse_dev_scope(void *start, void *end, int *cnt,
 				struct pci_dev ***devices, u16 segment);
+extern void *dmar_alloc_dev_scope(void *start, void *end, int *cnt);
 extern void dmar_free_dev_scope(struct pci_dev ***devices, int *cnt);
 
 /* Intel IOMMU detection */

commit 7c9197791a0cbbbb0f74aade3339f8e5890fbd15
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jan 6 14:18:18 2014 +0800

    iommu/vt-d, trivial: simplify code with existing macros
    
    Simplify vt-d related code with existing macros and introduce a new
    macro for_each_active_drhd_unit() to enumerate all active DRHD unit.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 1a60dd630bb4..eccb0c0c6cf6 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -53,6 +53,10 @@ extern struct list_head dmar_drhd_units;
 #define for_each_drhd_unit(drhd) \
 	list_for_each_entry(drhd, &dmar_drhd_units, list)
 
+#define for_each_active_drhd_unit(drhd)					\
+	list_for_each_entry(drhd, &dmar_drhd_units, list)		\
+		if (drhd->ignored) {} else
+
 #define for_each_active_iommu(i, drhd)					\
 	list_for_each_entry(drhd, &dmar_drhd_units, list)		\
 		if (i=drhd->iommu, drhd->ignored) {} else

commit 694835dc227ad203886457aa447025d09b2f7523
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jan 6 14:18:16 2014 +0800

    iommu/vt-d: mark internal functions as static
    
    Functions alloc_iommu() and parse_ioapics_under_ir()
    are only used internally, so mark them as static.
    
    [Joerg: Made detect_intel_iommu() non-static again for IA64]
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 205ee37eed73..1a60dd630bb4 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -33,6 +33,7 @@ struct acpi_dmar_header;
 #define DMAR_X2APIC_OPT_OUT	0x2
 
 struct intel_iommu;
+
 #ifdef CONFIG_DMAR_TABLE
 extern struct acpi_table_header *dmar_tbl;
 struct dmar_drhd_unit {
@@ -69,9 +70,6 @@ extern void dmar_free_dev_scope(struct pci_dev ***devices, int *cnt);
 /* Intel IOMMU detection */
 extern int detect_intel_iommu(void);
 extern int enable_drhd_fault_handling(void);
-
-extern int parse_ioapics_under_ir(void);
-extern int alloc_iommu(struct dmar_drhd_unit *);
 #else
 static inline int detect_intel_iommu(void)
 {

commit ada4d4b2a32e9f63d4dcb9f69578473408f4622c
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jan 6 14:18:09 2014 +0800

    iommu/vt-d: fix PCI device reference leakage on error recovery path
    
    Function dmar_parse_dev_scope() should release the PCI device reference
    count gained in function dmar_parse_one_dev_scope() on error recovery,
    otherwise it will cause PCI device object leakage.
    
    This patch also introduces dmar_free_dev_scope(), which will be used
    to support DMAR device hotplug.
    
    Reviewed-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index b029d1aa2d12..205ee37eed73 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -62,6 +62,9 @@ extern struct list_head dmar_drhd_units;
 
 extern int dmar_table_init(void);
 extern int dmar_dev_scope_init(void);
+extern int dmar_parse_dev_scope(void *start, void *end, int *cnt,
+				struct pci_dev ***devices, u16 segment);
+extern void dmar_free_dev_scope(struct pci_dev ***devices, int *cnt);
 
 /* Intel IOMMU detection */
 extern int detect_intel_iommu(void);
@@ -157,8 +160,6 @@ struct dmar_atsr_unit {
 int dmar_parse_rmrr_atsr_dev(void);
 extern int dmar_parse_one_rmrr(struct acpi_dmar_header *header);
 extern int dmar_parse_one_atsr(struct acpi_dmar_header *header);
-extern int dmar_parse_dev_scope(void *start, void *end, int *cnt,
-				struct pci_dev ***devices, u16 segment);
 extern int intel_iommu_init(void);
 #else /* !CONFIG_INTEL_IOMMU: */
 static inline int intel_iommu_init(void) { return -ENODEV; }

commit 263b5e8629c9ce21c9cd4c0e29c097afb1c10ef3
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Fri Mar 30 11:47:06 2012 -0700

    x86, iommu/vt-d: Clean up interfaces for interrupt remapping
    
    Remove the Intel specific interfaces from dmar.h and remove
    asm/irq_remapping.h which is only used for io_apic.c anyway.
    
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 7a207a39f879..b029d1aa2d12 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -114,65 +114,6 @@ struct irte {
 	};
 };
 
-#ifdef CONFIG_IRQ_REMAP
-extern int get_irte(int irq, struct irte *entry);
-extern int modify_irte(int irq, struct irte *irte_modified);
-extern int alloc_irte(struct intel_iommu *iommu, int irq, u16 count);
-extern int set_irte_irq(int irq, struct intel_iommu *iommu, u16 index,
-   			u16 sub_handle);
-extern int map_irq_to_irte_handle(int irq, u16 *sub_handle);
-
-extern struct intel_iommu *map_dev_to_ir(struct pci_dev *dev);
-extern struct intel_iommu *map_ioapic_to_ir(int apic);
-extern struct intel_iommu *map_hpet_to_ir(u8 id);
-extern int set_ioapic_sid(struct irte *irte, int apic);
-extern int set_hpet_sid(struct irte *irte, u8 id);
-extern int set_msi_sid(struct irte *irte, struct pci_dev *dev);
-#else
-static inline int alloc_irte(struct intel_iommu *iommu, int irq, u16 count)
-{
-	return -1;
-}
-static inline int modify_irte(int irq, struct irte *irte_modified)
-{
-	return -1;
-}
-static inline int map_irq_to_irte_handle(int irq, u16 *sub_handle)
-{
-	return -1;
-}
-static inline int set_irte_irq(int irq, struct intel_iommu *iommu, u16 index,
-			       u16 sub_handle)
-{
-	return -1;
-}
-static inline struct intel_iommu *map_dev_to_ir(struct pci_dev *dev)
-{
-	return NULL;
-}
-static inline struct intel_iommu *map_ioapic_to_ir(int apic)
-{
-	return NULL;
-}
-static inline struct intel_iommu *map_hpet_to_ir(unsigned int hpet_id)
-{
-	return NULL;
-}
-static inline int set_ioapic_sid(struct irte *irte, int apic)
-{
-	return 0;
-}
-static inline int set_hpet_sid(struct irte *irte, u8 id)
-{
-	return -1;
-}
-static inline int set_msi_sid(struct irte *irte, struct pci_dev *dev)
-{
-	return 0;
-}
-
-#endif
-
 enum {
 	IRQ_REMAP_XAPIC_MODE,
 	IRQ_REMAP_X2APIC_MODE,

commit 9d619f65722236e0e0c35467d1528caed206e439
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Fri Mar 30 11:47:04 2012 -0700

    iommu/vt-d: Convert free_irte into a remap_ops callback
    
    The operation for releasing a remapping entry is iommu
    specific too.
    
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index f2bd87f52a8d..7a207a39f879 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -121,7 +121,6 @@ extern int alloc_irte(struct intel_iommu *iommu, int irq, u16 count);
 extern int set_irte_irq(int irq, struct intel_iommu *iommu, u16 index,
    			u16 sub_handle);
 extern int map_irq_to_irte_handle(int irq, u16 *sub_handle);
-extern int free_irte(int irq);
 
 extern struct intel_iommu *map_dev_to_ir(struct pci_dev *dev);
 extern struct intel_iommu *map_ioapic_to_ir(int apic);
@@ -138,10 +137,6 @@ static inline int modify_irte(int irq, struct irte *irte_modified)
 {
 	return -1;
 }
-static inline int free_irte(int irq)
-{
-	return -1;
-}
 static inline int map_irq_to_irte_handle(int irq, u16 *sub_handle)
 {
 	return -1;

commit 4f3d8b67ad3090f9fb72f8235d21cde53cd24b79
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Fri Mar 30 11:47:01 2012 -0700

    iommu/vt-d: Convert missing apic.c intr-remapping call to remap_ops
    
    Convert these calls too:
    
            * Disable of remapping hardware
            * Reenable of remapping hardware
            * Enable fault handling
    
    With that all of arch/x86/kernel/apic/apic.c is converted to
    use the generic intr-remapping interface.
    
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 6d66c9c76e0a..f2bd87f52a8d 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -115,9 +115,6 @@ struct irte {
 };
 
 #ifdef CONFIG_IRQ_REMAP
-extern void disable_intr_remapping(void);
-extern int reenable_intr_remapping(int);
-
 extern int get_irte(int irq, struct irte *entry);
 extern int modify_irte(int irq, struct irte *irte_modified);
 extern int alloc_irte(struct intel_iommu *iommu, int irq, u16 count);
@@ -179,21 +176,6 @@ static inline int set_msi_sid(struct irte *irte, struct pci_dev *dev)
 	return 0;
 }
 
-#define intr_remapping_enabled		(0)
-
-static inline int enable_intr_remapping(void)
-{
-	return -1;
-}
-
-static inline void disable_intr_remapping(void)
-{
-}
-
-static inline int reenable_intr_remapping(int eim)
-{
-	return 0;
-}
 #endif
 
 enum {

commit 736baef4472d00574089f295bc759ac002b9558c
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Fri Mar 30 11:47:00 2012 -0700

    iommu/vt-d: Make intr-remapping initialization generic
    
    This patch introduces irq_remap_ops to hold implementation
    specific function pointer to handle interrupt remapping. As
    the first part the initialization functions for VT-d are
    converted to these ops.
    
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 731a60975101..6d66c9c76e0a 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -115,9 +115,6 @@ struct irte {
 };
 
 #ifdef CONFIG_IRQ_REMAP
-extern int intr_remapping_enabled;
-extern int intr_remapping_supported(void);
-extern int enable_intr_remapping(void);
 extern void disable_intr_remapping(void);
 extern int reenable_intr_remapping(int);
 

commit 6eea69dd8befeabd3d0f217400f54b157dd91fe9
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Mon Oct 31 17:06:29 2011 -0700

    include/linux/dmar.h: forward-declare struct acpi_dmar_header
    
    x86_64 allnoconfig:
    
    In file included from arch/x86/kernel/pci-dma.c:3:
    include/linux/dmar.h:248: warning: 'struct acpi_dmar_header' declared inside parameter list
    include/linux/dmar.h:248: warning: its scope is only this definition or declaration, which is probably not what you want
    
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index a8b1a847c103..731a60975101 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -26,6 +26,8 @@
 #include <linux/msi.h>
 #include <linux/irqreturn.h>
 
+struct acpi_dmar_header;
+
 /* DMAR Flags */
 #define DMAR_INTR_REMAP		0x1
 #define DMAR_X2APIC_OPT_OUT	0x2

commit d3f138106b4b40640dc667f0222fd9f137387b32
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Tue Aug 23 17:05:25 2011 -0700

    iommu: Rename the DMAR and INTR_REMAP config options
    
    Change the CONFIG_DMAR to CONFIG_INTEL_IOMMU to be consistent
    with the other IOMMU options.
    
    Rename the CONFIG_INTR_REMAP to CONFIG_IRQ_REMAP to match the
    irq subsystem name.
    
    And define the CONFIG_DMAR_TABLE for the common ACPI DMAR
    routines shared by both CONFIG_INTEL_IOMMU and CONFIG_IRQ_REMAP.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: yinghai@kernel.org
    Cc: youquan.song@intel.com
    Cc: joerg.roedel@amd.com
    Cc: tony.luck@intel.com
    Cc: dwmw2@infradead.org
    Link: http://lkml.kernel.org/r/20110824001456.558630224@sbsiddha-desk.sc.intel.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index a7992ec36570..a8b1a847c103 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -31,7 +31,7 @@
 #define DMAR_X2APIC_OPT_OUT	0x2
 
 struct intel_iommu;
-#if defined(CONFIG_DMAR) || defined(CONFIG_INTR_REMAP)
+#ifdef CONFIG_DMAR_TABLE
 extern struct acpi_table_header *dmar_tbl;
 struct dmar_drhd_unit {
 	struct list_head list;		/* list of drhd units	*/
@@ -81,7 +81,7 @@ static inline int enable_drhd_fault_handling(void)
 {
 	return -1;
 }
-#endif /* !CONFIG_DMAR && !CONFIG_INTR_REMAP */
+#endif /* !CONFIG_DMAR_TABLE */
 
 struct irte {
 	union {
@@ -112,7 +112,7 @@ struct irte {
 	};
 };
 
-#ifdef CONFIG_INTR_REMAP
+#ifdef CONFIG_IRQ_REMAP
 extern int intr_remapping_enabled;
 extern int intr_remapping_supported(void);
 extern int enable_intr_remapping(void);
@@ -214,7 +214,7 @@ extern int dmar_set_interrupt(struct intel_iommu *iommu);
 extern irqreturn_t dmar_fault(int irq, void *dev_id);
 extern int arch_setup_dmar_msi(unsigned int irq);
 
-#ifdef CONFIG_DMAR
+#ifdef CONFIG_INTEL_IOMMU
 extern int iommu_detected, no_iommu;
 extern struct list_head dmar_rmrr_units;
 struct dmar_rmrr_unit {
@@ -243,7 +243,7 @@ extern int dmar_parse_one_atsr(struct acpi_dmar_header *header);
 extern int dmar_parse_dev_scope(void *start, void *end, int *cnt,
 				struct pci_dev ***devices, u16 segment);
 extern int intel_iommu_init(void);
-#else /* !CONFIG_DMAR: */
+#else /* !CONFIG_INTEL_IOMMU: */
 static inline int intel_iommu_init(void) { return -ENODEV; }
 static inline int dmar_parse_one_rmrr(struct acpi_dmar_header *header)
 {
@@ -257,6 +257,6 @@ static inline int dmar_parse_rmrr_atsr_dev(void)
 {
 	return 0;
 }
-#endif /* CONFIG_DMAR */
+#endif /* CONFIG_INTEL_IOMMU */
 
 #endif /* __DMAR_H__ */

commit 318fe7df9d8456f778451b01913b5d0dc0a25854
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Tue Aug 23 17:05:20 2011 -0700

    iommu: Move IOMMU specific code to intel-iommu.c
    
    Move the IOMMU specific routines to intel-iommu.c leaving the
    dmar.c to the common ACPI dmar code shared between DMA-remapping
    and Interrupt-remapping.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: yinghai@kernel.org
    Cc: youquan.song@intel.com
    Cc: joerg.roedel@amd.com
    Cc: tony.luck@intel.com
    Cc: dwmw2@infradead.org
    Link: http://lkml.kernel.org/r/20110824001456.282401285@sbsiddha-desk.sc.intel.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 2dc810e35dd0..a7992ec36570 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -237,9 +237,26 @@ struct dmar_atsr_unit {
 	u8 include_all:1;		/* include all ports */
 };
 
+int dmar_parse_rmrr_atsr_dev(void);
+extern int dmar_parse_one_rmrr(struct acpi_dmar_header *header);
+extern int dmar_parse_one_atsr(struct acpi_dmar_header *header);
+extern int dmar_parse_dev_scope(void *start, void *end, int *cnt,
+				struct pci_dev ***devices, u16 segment);
 extern int intel_iommu_init(void);
 #else /* !CONFIG_DMAR: */
 static inline int intel_iommu_init(void) { return -ENODEV; }
+static inline int dmar_parse_one_rmrr(struct acpi_dmar_header *header)
+{
+	return 0;
+}
+static inline int dmar_parse_one_atsr(struct acpi_dmar_header *header)
+{
+	return 0;
+}
+static inline int dmar_parse_rmrr_atsr_dev(void)
+{
+	return 0;
+}
 #endif /* CONFIG_DMAR */
 
 #endif /* __DMAR_H__ */

commit 41750d31fc9599fd81763e685a6b7b42d298c4f8
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Tue Aug 23 17:05:18 2011 -0700

    x86, x2apic: Enable the bios request for x2apic optout
    
    On the platforms which are x2apic and interrupt-remapping
    capable, Linux kernel is enabling x2apic even if the BIOS
    doesn't. This is to take advantage of the features that x2apic
    brings in.
    
    Some of the OEM platforms are running into issues because of
    this, as their bios is not x2apic aware. For example, this was
    resulting in interrupt migration issues on one of the platforms.
    Also if the BIOS SMI handling uses APIC interface to send SMI's,
    then the BIOS need to be aware of x2apic mode that OS has
    enabled.
    
    On some of these platforms, BIOS doesn't have a HW mechanism to
    turnoff the x2apic feature to prevent OS from enabling it.
    
    To resolve this mess, recent changes to the VT-d2 specification:
    
     http://download.intel.com/technology/computing/vptech/Intel(r)_VT_for_Direct_IO.pdf
    
    includes a mechanism that provides BIOS a way to request system
    software to opt out of enabling x2apic mode.
    
    Look at the x2apic optout flag in the DMAR tables before
    enabling the x2apic mode in the platform. Also print a warning
    that we have disabled x2apic based on the BIOS request.
    
    Kernel boot parameter "intremap=no_x2apic_optout" can be used to
    override the BIOS x2apic optout request.
    
    Signed-off-by: Youquan Song <youquan.song@intel.com>
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: yinghai@kernel.org
    Cc: joerg.roedel@amd.com
    Cc: tony.luck@intel.com
    Cc: dwmw2@infradead.org
    Link: http://lkml.kernel.org/r/20110824001456.171766616@sbsiddha-desk.sc.intel.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 7b776d71d36d..2dc810e35dd0 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -26,8 +26,13 @@
 #include <linux/msi.h>
 #include <linux/irqreturn.h>
 
+/* DMAR Flags */
+#define DMAR_INTR_REMAP		0x1
+#define DMAR_X2APIC_OPT_OUT	0x2
+
 struct intel_iommu;
 #if defined(CONFIG_DMAR) || defined(CONFIG_INTR_REMAP)
+extern struct acpi_table_header *dmar_tbl;
 struct dmar_drhd_unit {
 	struct list_head list;		/* list of drhd units	*/
 	struct  acpi_dmar_header *hdr;	/* ACPI header		*/
@@ -110,7 +115,7 @@ struct irte {
 #ifdef CONFIG_INTR_REMAP
 extern int intr_remapping_enabled;
 extern int intr_remapping_supported(void);
-extern int enable_intr_remapping(int);
+extern int enable_intr_remapping(void);
 extern void disable_intr_remapping(void);
 extern int reenable_intr_remapping(int);
 
@@ -177,7 +182,7 @@ static inline int set_msi_sid(struct irte *irte, struct pci_dev *dev)
 
 #define intr_remapping_enabled		(0)
 
-static inline int enable_intr_remapping(int eim)
+static inline int enable_intr_remapping(void)
 {
 	return -1;
 }
@@ -192,6 +197,11 @@ static inline int reenable_intr_remapping(int eim)
 }
 #endif
 
+enum {
+	IRQ_REMAP_XAPIC_MODE,
+	IRQ_REMAP_X2APIC_MODE,
+};
+
 /* Can't use the common MSI interrupt functions
  * since DMAR is not a pci device
  */

commit 4917b284db8607e414c334317b7d15239854d39c
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Mon Nov 22 12:48:34 2010 -0800

    dmar, x86: Use function stubs when CONFIG_INTR_REMAP is disabled
    
    The stubs for CONFIG_INTR_REMAP disabled need to be functions
    instead of values to eliminate build warnings.
    
     arch/x86/kernel/apic/apic.c: In function 'lapic_suspend':
     arch/x86/kernel/apic/apic.c:2060:3: warning: statement with no effect
     arch/x86/kernel/apic/apic.c: In function 'lapic_resume':
     arch/x86/kernel/apic/apic.c:2137:3: warning: statement with no effect
    
    Reported-and-Tested-by: Fabio Comolli <fabio.comolli@gmail.com>
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    LKML-Reference: <20101122124834.74429004.randy.dunlap@oracle.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index a7d9dc21391d..7b776d71d36d 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -175,10 +175,21 @@ static inline int set_msi_sid(struct irte *irte, struct pci_dev *dev)
 	return 0;
 }
 
-#define enable_intr_remapping(mode)	(-1)
-#define disable_intr_remapping()	(0)
-#define reenable_intr_remapping(mode)	(0)
 #define intr_remapping_enabled		(0)
+
+static inline int enable_intr_remapping(int eim)
+{
+	return -1;
+}
+
+static inline void disable_intr_remapping(void)
+{
+}
+
+static inline int reenable_intr_remapping(int eim)
+{
+	return 0;
+}
 #endif
 
 /* Can't use the common MSI interrupt functions

commit 157b6ceb13e4b4148ee03dd517dbe88748943125
Merge: 4a60cfa94577 6e9636693373
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 21 14:23:48 2010 -0700

    Merge branch 'x86-iommu-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'x86-iommu-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86, iommu: Update header comments with appropriate naming
      ia64, iommu: Add a dummy iommu_table.h file in IA64.
      x86, iommu: Fix IOMMU_INIT alignment rules
      x86, doc: Adding comments about .iommu_table and its neighbors.
      x86, iommu: Utilize the IOMMU_INIT macros functionality.
      x86, VT-d: Make Intel VT-d IOMMU use IOMMU_INIT_* macros.
      x86, GART/AMD-VI: Make AMD GART and IOMMU use IOMMU_INIT_* macros.
      x86, calgary: Make Calgary IOMMU use IOMMU_INIT_* macros.
      x86, xen-swiotlb: Make Xen-SWIOTLB use IOMMU_INIT_* macros.
      x86, swiotlb: Make SWIOTLB use IOMMU_INIT_* macros.
      x86, swiotlb: Simplify SWIOTLB pci_swiotlb_detect routine.
      x86, iommu: Add proper dependency sort routine (and sanity check).
      x86, iommu: Make all IOMMU's detection routines return a value.
      x86, iommu: Add IOMMU_INIT macros, .iommu_table section, and iommu_table_entry structure

commit 1a0730d6649113c820217387a011a17dd4aff3ad
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Oct 11 11:55:37 2010 +0200

    x86: Speed up the irq_remapped check in hot pathes
    
    irq_2_iommu is in struct irq_cfg, so we can do the irq_remapped check
    based on irq_cfg instead of going through a lookup function. That's
    especially interesting in the eoi_ioapic_irq() hotpath.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 4475f8cf7a62..51651b76d40f 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -122,7 +122,6 @@ extern int set_irte_irq(int irq, struct intel_iommu *iommu, u16 index,
 extern int map_irq_to_irte_handle(int irq, u16 *sub_handle);
 extern int free_irte(int irq);
 
-extern int irq_remapped(int irq);
 extern struct intel_iommu *map_dev_to_ir(struct pci_dev *dev);
 extern struct intel_iommu *map_ioapic_to_ir(int apic);
 extern struct intel_iommu *map_hpet_to_ir(u8 id);
@@ -176,7 +175,6 @@ static inline int set_msi_sid(struct irte *irte, struct pci_dev *dev)
 	return 0;
 }
 
-#define irq_remapped(irq)		(0)
 #define enable_intr_remapping(mode)	(-1)
 #define disable_intr_remapping()	(0)
 #define reenable_intr_remapping(mode)	(0)

commit 423f085952fd7253407cb92984cc2d495a564481
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Oct 10 11:39:09 2010 +0200

    x86: Embedd irq_2_iommu into irq_cfg
    
    That interrupt remapping code is x86 specific and tied to the io_apic
    code. No need for separate allocator functions in the interrupt
    remapping code. This allows to simplify the code and irq_2_iommu is
    small (13 bytes on 64bit) so it's not a real problem even if interrupt
    remapping is runtime disabled. If it's compile time disabled the
    impact is zero.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 200439ec7c49..4475f8cf7a62 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -106,6 +106,7 @@ struct irte {
 		__u64 high;
 	};
 };
+
 #ifdef CONFIG_INTR_REMAP
 extern int intr_remapping_enabled;
 extern int intr_remapping_supported(void);

commit d0ad63927c6d4d511e172c78ba4a623539ef6901
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Oct 4 18:41:37 2010 +0200

    pci: intr_remap: Remove unused functions
    
    No users.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index cb86aa1ca436..200439ec7c49 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -119,8 +119,6 @@ extern int alloc_irte(struct intel_iommu *iommu, int irq, u16 count);
 extern int set_irte_irq(int irq, struct intel_iommu *iommu, u16 index,
    			u16 sub_handle);
 extern int map_irq_to_irte_handle(int irq, u16 *sub_handle);
-extern int clear_irte_irq(int irq, struct intel_iommu *iommu, u16 index);
-extern int flush_irte(int irq);
 extern int free_irte(int irq);
 
 extern int irq_remapped(int irq);

commit 5c2837fbaa609e615ef9a1c58a4cd26ce90be35b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 28 17:15:11 2010 +0200

    dmar: Convert to new irq chip functions
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index d7cecc90ed34..cb86aa1ca436 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -187,8 +187,9 @@ static inline int set_msi_sid(struct irte *irte, struct pci_dev *dev)
 /* Can't use the common MSI interrupt functions
  * since DMAR is not a pci device
  */
-extern void dmar_msi_unmask(unsigned int irq);
-extern void dmar_msi_mask(unsigned int irq);
+struct irq_data;
+extern void dmar_msi_unmask(struct irq_data *data);
+extern void dmar_msi_mask(struct irq_data *data);
 extern void dmar_msi_read(int irq, struct msi_msg *msg);
 extern void dmar_msi_write(int irq, struct msi_msg *msg);
 extern int dmar_set_interrupt(struct intel_iommu *iommu);

commit 480125ba49ba62be93beea37770f266846e077ab
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Thu Aug 26 13:57:57 2010 -0400

    x86, iommu: Make all IOMMU's detection routines return a value.
    
    We return 1 if the IOMMU has been detected. Zero or an error number
    if we failed to find it. This is in preperation of using the IOMMU_INIT
    so that we can detect whether an IOMMU is present. I have not
    tested this for regression on Calgary, nor on AMD Vi chipsets as
    I don't have that hardware.
    
    CC: Muli Ben-Yehuda <muli@il.ibm.com>
    CC: "Jon D. Mason" <jdmason@kudzu.us>
    CC: "Darrick J. Wong" <djwong@us.ibm.com>
    CC: Jesse Barnes <jbarnes@virtuousgeek.org>
    CC: David Woodhouse <David.Woodhouse@intel.com>
    CC: Chris Wright <chrisw@sous-sol.org>
    CC: Yinghai Lu <yinghai@kernel.org>
    CC: Joerg Roedel <joerg.roedel@amd.com>
    CC: H. Peter Anvin <hpa@zytor.com>
    CC: Fujita Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    LKML-Reference: <1282845485-8991-3-git-send-email-konrad.wilk@oracle.com>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index d7cecc90ed34..a20602041511 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -57,15 +57,15 @@ extern int dmar_table_init(void);
 extern int dmar_dev_scope_init(void);
 
 /* Intel IOMMU detection */
-extern void detect_intel_iommu(void);
+extern int detect_intel_iommu(void);
 extern int enable_drhd_fault_handling(void);
 
 extern int parse_ioapics_under_ir(void);
 extern int alloc_iommu(struct dmar_drhd_unit *);
 #else
-static inline void detect_intel_iommu(void)
+static inline int detect_intel_iommu(void)
 {
-	return;
+	return -ENODEV;
 }
 
 static inline int dmar_table_init(void)

commit 849e8dea099aafa56db9e74b580b0d858b956533
Merge: e069efb6bbf8 18ed61da985c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 8 19:26:55 2009 -0800

    Merge branch 'timers-for-linus-hpet' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-for-linus-hpet' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86: hpet: Make WARN_ON understandable
      x86: arch specific support for remapping HPET MSIs
      intr-remap: generic support for remapping HPET MSIs
      x86, hpet: Simplify the HPET code
      x86, hpet: Disable per-cpu hpet timer if ARAT is supported

commit 9d5ce73a64be2be8112147a3e0b551ad9cd1247b
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Tue Nov 10 19:46:16 2009 +0900

    x86: intel-iommu: Convert detect_intel_iommu to use iommu_init hook
    
    This changes detect_intel_iommu() to set intel_iommu_init() to
    iommu_init hook if detect_intel_iommu() finds the IOMMU.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Cc: chrisw@sous-sol.org
    Cc: dwmw2@infradead.org
    Cc: joerg.roedel@amd.com
    Cc: muli@il.ibm.com
    LKML-Reference: <1257849980-22640-6-git-send-email-fujita.tomonori@lab.ntt.co.jp>
    [ -v2: build fix for the !CONFIG_DMAR case ]
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 4a2b162c256a..5de4c9e5856d 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -208,16 +208,9 @@ struct dmar_atsr_unit {
 	u8 include_all:1;		/* include all ports */
 };
 
-/* Intel DMAR  initialization functions */
 extern int intel_iommu_init(void);
-#else
-static inline int intel_iommu_init(void)
-{
-#ifdef CONFIG_INTR_REMAP
-	return dmar_dev_scope_init();
-#else
-	return -ENODEV;
-#endif
-}
-#endif /* !CONFIG_DMAR */
+#else /* !CONFIG_DMAR: */
+static inline int intel_iommu_init(void) { return -ENODEV; }
+#endif /* CONFIG_DMAR */
+
 #endif /* __DMAR_H__ */

commit 20f3097bfe5fb5ced0b14f9ea2620c4039bf1dde
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Tue Aug 4 12:07:08 2009 -0700

    intr-remap: generic support for remapping HPET MSIs
    
    Generic support for remapping HPET MSI's by parsing the HPET timer block
    device scope in the ACPI DRHD tables. This is needed for platforms
    supporting interrupt-remapping and MSI capable HPET timer block.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Cc: Jay Fenlason <fenlason@redhat.com>
    LKML-Reference: <20090804190729.477649000@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 4a2b162c256a..69a6fbac0921 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -126,7 +126,9 @@ extern int free_irte(int irq);
 extern int irq_remapped(int irq);
 extern struct intel_iommu *map_dev_to_ir(struct pci_dev *dev);
 extern struct intel_iommu *map_ioapic_to_ir(int apic);
+extern struct intel_iommu *map_hpet_to_ir(u8 id);
 extern int set_ioapic_sid(struct irte *irte, int apic);
+extern int set_hpet_sid(struct irte *irte, u8 id);
 extern int set_msi_sid(struct irte *irte, struct pci_dev *dev);
 #else
 static inline int alloc_irte(struct intel_iommu *iommu, int irq, u16 count)
@@ -158,10 +160,18 @@ static inline struct intel_iommu *map_ioapic_to_ir(int apic)
 {
 	return NULL;
 }
+static inline struct intel_iommu *map_hpet_to_ir(unsigned int hpet_id)
+{
+	return NULL;
+}
 static inline int set_ioapic_sid(struct irte *irte, int apic)
 {
 	return 0;
 }
+static inline int set_hpet_sid(struct irte *irte, u8 id)
+{
+	return -1;
+}
 static inline int set_msi_sid(struct irte *irte, struct pci_dev *dev)
 {
 	return 0;

commit f007e99c8e2e322b8331aba72414715119a2920d
Author: Weidong Han <weidong.han@intel.com>
Date:   Sat May 23 00:41:15 2009 +0800

    Intel-IOMMU, intr-remap: source-id checking
    
    To support domain-isolation usages, the platform hardware must be
    capable of uniquely identifying the requestor (source-id) for each
    interrupt message. Without source-id checking for interrupt remapping
    , a rouge guest/VM with assigned devices can launch interrupt attacks
    to bring down anothe guest/VM or the VMM itself.
    
    This patch adds source-id checking for interrupt remapping, and then
    really isolates interrupts for guests/VMs with assigned devices.
    
    Because PCI subsystem is not initialized yet when set up IOAPIC
    entries, use read_pci_config_byte to access PCI config space directly.
    
    Signed-off-by: Weidong Han <weidong.han@intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 1731fb5fd775..4a2b162c256a 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -126,6 +126,8 @@ extern int free_irte(int irq);
 extern int irq_remapped(int irq);
 extern struct intel_iommu *map_dev_to_ir(struct pci_dev *dev);
 extern struct intel_iommu *map_ioapic_to_ir(int apic);
+extern int set_ioapic_sid(struct irte *irte, int apic);
+extern int set_msi_sid(struct irte *irte, struct pci_dev *dev);
 #else
 static inline int alloc_irte(struct intel_iommu *iommu, int irq, u16 count)
 {
@@ -156,6 +158,15 @@ static inline struct intel_iommu *map_ioapic_to_ir(int apic)
 {
 	return NULL;
 }
+static inline int set_ioapic_sid(struct irte *irte, int apic)
+{
+	return 0;
+}
+static inline int set_msi_sid(struct irte *irte, struct pci_dev *dev)
+{
+	return 0;
+}
+
 #define irq_remapped(irq)		(0)
 #define enable_intr_remapping(mode)	(-1)
 #define disable_intr_remapping()	(0)

commit 687d680985b1438360a9ba470ece8b57cd205c3b
Merge: 1053414068ba 008fe148cb0f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 22 21:38:22 2009 -0700

    Merge git://git.infradead.org/~dwmw2/iommu-2.6.31
    
    * git://git.infradead.org/~dwmw2/iommu-2.6.31:
      intel-iommu: Fix one last ia64 build problem in Pass Through Support
      VT-d: support the device IOTLB
      VT-d: cleanup iommu_flush_iotlb_psi and flush_unmaps
      VT-d: add device IOTLB invalidation support
      VT-d: parse ATSR in DMA Remapping Reporting Structure
      PCI: handle Virtual Function ATS enabling
      PCI: support the ATS capability
      intel-iommu: dmar_set_interrupt return error value
      intel-iommu: Tidy up iommu->gcmd handling
      intel-iommu: Fix tiny theoretical race in write-buffer flush.
      intel-iommu: Clean up handling of "caching mode" vs. IOTLB flushing.
      intel-iommu: Clean up handling of "caching mode" vs. context flushing.
      VT-d: fix invalid domain id for KVM context flush
      Fix !CONFIG_DMAR build failure introduced by Intel IOMMU Pass Through Support
      Intel IOMMU Pass Through Support
    
    Fix up trivial conflicts in drivers/pci/{intel-iommu.c,intr_remapping.c}

commit aa5d2b515b6fca5f8a56eac84f7fa0a68c1ce9b7
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Mon May 18 13:51:34 2009 +0800

    VT-d: parse ATSR in DMA Remapping Reporting Structure
    
    Parse the Root Port ATS Capability Reporting Structure in the DMA
    Remapping Reporting Structure ACPI table.
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index e397dc342cda..7c9a207e5da6 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -185,6 +185,15 @@ struct dmar_rmrr_unit {
 
 #define for_each_rmrr_units(rmrr) \
 	list_for_each_entry(rmrr, &dmar_rmrr_units, list)
+
+struct dmar_atsr_unit {
+	struct list_head list;		/* list of ATSR units */
+	struct acpi_dmar_header *hdr;	/* ACPI header */
+	struct pci_dev **devices;	/* target devices */
+	int devices_cnt;		/* target device count */
+	u8 include_all:1;		/* include all ports */
+};
+
 /* Intel DMAR  initialization functions */
 extern int intel_iommu_init(void);
 #else

commit fc1edaf9e7cc4d4696f83dee495b8f158d01c4eb
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Mon Apr 20 13:02:27 2009 -0700

    x86: x2apic, IR: Clean up X86_X2APIC and INTR_REMAP config checks
    
    Add x2apic_supported() to clean up CONFIG_X86_X2APIC checks.
    
    Fix CONFIG_INTR_REMAP checks.
    
    [ Impact: cleanup ]
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: dwmw2@infradead.org
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: Weidong Han <weidong.han@intel.com>
    LKML-Reference: <20090420200450.128993000@linux-os.sc.intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 06f592a7f73c..10ff5c498824 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -158,6 +158,8 @@ static inline struct intel_iommu *map_ioapic_to_ir(int apic)
 }
 #define irq_remapped(irq)		(0)
 #define enable_intr_remapping(mode)	(-1)
+#define disable_intr_remapping()	(0)
+#define reenable_intr_remapping(mode)	(0)
 #define intr_remapping_enabled		(0)
 #endif
 

commit 937582382c71b75b29fbb92615629494e1a05ac0
Author: Weidong Han <weidong.han@intel.com>
Date:   Fri Apr 17 16:42:14 2009 +0800

    x86, intr-remap: enable interrupt remapping early
    
    Currently, when x2apic is not enabled, interrupt remapping
    will be enabled in init_dmars(), where it is too late to remap
    ioapic interrupts, that is, ioapic interrupts are really in
    compatibility mode, not remappable mode.
    
    This patch always enables interrupt remapping before ioapic
    setup, it guarantees all interrupts will be remapped when
    interrupt remapping is enabled. Thus it doesn't need to set
    the compatibility interrupt bit.
    
    [ Impact: refactor intr-remap init sequence, enable fuller remap mode ]
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Signed-off-by: Weidong Han <weidong.han@intel.com>
    Acked-by: David Woodhouse <David.Woodhouse@intel.com>
    Cc: iommu@lists.linux-foundation.org
    Cc: allen.m.kay@intel.com
    Cc: fenghua.yu@intel.com
    LKML-Reference: <1239957736-6161-4-git-send-email-weidong.han@intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index e397dc342cda..06f592a7f73c 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -108,6 +108,7 @@ struct irte {
 };
 #ifdef CONFIG_INTR_REMAP
 extern int intr_remapping_enabled;
+extern int intr_remapping_supported(void);
 extern int enable_intr_remapping(int);
 extern void disable_intr_remapping(void);
 extern int reenable_intr_remapping(int);

commit 276dbf997043cbf38f0087624e0f9c51742c8885
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Sat Apr 4 01:45:37 2009 +0100

    intel-iommu: Handle PCI domains appropriately.
    
    We were comparing {bus,devfn} and assuming that a match meant it was the
    same device. It doesn't -- the same {bus,devfn} can exist in
    multiple PCI domains. Include domain number in device identification
    (and call it 'segment' in most places, because there's already a lot of
    references to 'domain' which means something else, and this code is
    infected with ACPI thinking already).
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 4a0ce6f27e1b..e397dc342cda 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -34,6 +34,7 @@ struct dmar_drhd_unit {
 	u64	reg_base_addr;		/* register base address*/
 	struct	pci_dev **devices; 	/* target device array	*/
 	int	devices_cnt;		/* target device count	*/
+	u16	segment;		/* PCI domain		*/
 	u8	ignored:1; 		/* ignore drhd		*/
 	u8	include_all:1;
 	struct intel_iommu *iommu;

commit b24696bc55f66fecc30715e003f10fc2555a9271
Author: Fenghua Yu <fenghua.yu@intel.com>
Date:   Fri Mar 27 14:22:44 2009 -0700

    Intel IOMMU Suspend/Resume Support - Interrupt Remapping
    
    This patch enables suspend/resume for interrupt remapping. During suspend,
    interrupt remapping is disabled. When resume, interrupt remapping is enabled
    again.
    
    Signed-off-by: Fenghua Yu <fenghua.yu@intel.com>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 0b4aa8069985..4a0ce6f27e1b 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -108,6 +108,8 @@ struct irte {
 #ifdef CONFIG_INTR_REMAP
 extern int intr_remapping_enabled;
 extern int enable_intr_remapping(int);
+extern void disable_intr_remapping(void);
+extern int reenable_intr_remapping(int);
 
 extern int get_irte(int irq, struct irte *entry);
 extern int modify_irte(int irq, struct irte *irte_modified);

commit 8f912ba4d7cdaf7d31cf39fe5a9b7732308a256d
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Fri Apr 3 15:19:32 2009 +0100

    intel-iommu: Add for_each_iommu() and for_each_active_iommu() macros
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Acked-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 2f3427468956..0b4aa8069985 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -44,6 +44,14 @@ extern struct list_head dmar_drhd_units;
 #define for_each_drhd_unit(drhd) \
 	list_for_each_entry(drhd, &dmar_drhd_units, list)
 
+#define for_each_active_iommu(i, drhd)					\
+	list_for_each_entry(drhd, &dmar_drhd_units, list)		\
+		if (i=drhd->iommu, drhd->ignored) {} else
+
+#define for_each_iommu(i, drhd)						\
+	list_for_each_entry(drhd, &dmar_drhd_units, list)		\
+		if (i=drhd->iommu, 0) {} else 
+
 extern int dmar_table_init(void);
 extern int dmar_dev_scope_init(void);
 

commit 29b61be65a33c95564fa82e7e8d60d97adb68ea8
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Mon Mar 16 17:05:02 2009 -0700

    x86, x2apic: cleanup ifdef CONFIG_INTR_REMAP in io_apic code
    
    Impact: cleanup
    
    Clean up #ifdefs and replace them with helper functions.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 8a035aec14a9..2f3427468956 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -26,9 +26,8 @@
 #include <linux/msi.h>
 #include <linux/irqreturn.h>
 
-#if defined(CONFIG_DMAR) || defined(CONFIG_INTR_REMAP)
 struct intel_iommu;
-
+#if defined(CONFIG_DMAR) || defined(CONFIG_INTR_REMAP)
 struct dmar_drhd_unit {
 	struct list_head list;		/* list of drhd units	*/
 	struct  acpi_dmar_header *hdr;	/* ACPI header		*/
@@ -52,7 +51,6 @@ extern int dmar_dev_scope_init(void);
 extern void detect_intel_iommu(void);
 extern int enable_drhd_fault_handling(void);
 
-
 extern int parse_ioapics_under_ir(void);
 extern int alloc_iommu(struct dmar_drhd_unit *);
 #else
@@ -65,12 +63,12 @@ static inline int dmar_table_init(void)
 {
 	return -ENODEV;
 }
+static inline int enable_drhd_fault_handling(void)
+{
+	return -1;
+}
 #endif /* !CONFIG_DMAR && !CONFIG_INTR_REMAP */
 
-#ifdef CONFIG_INTR_REMAP
-extern int intr_remapping_enabled;
-extern int enable_intr_remapping(int);
-
 struct irte {
 	union {
 		struct {
@@ -99,6 +97,10 @@ struct irte {
 		__u64 high;
 	};
 };
+#ifdef CONFIG_INTR_REMAP
+extern int intr_remapping_enabled;
+extern int enable_intr_remapping(int);
+
 extern int get_irte(int irq, struct irte *entry);
 extern int modify_irte(int irq, struct irte *irte_modified);
 extern int alloc_irte(struct intel_iommu *iommu, int irq, u16 count);
@@ -113,6 +115,35 @@ extern int irq_remapped(int irq);
 extern struct intel_iommu *map_dev_to_ir(struct pci_dev *dev);
 extern struct intel_iommu *map_ioapic_to_ir(int apic);
 #else
+static inline int alloc_irte(struct intel_iommu *iommu, int irq, u16 count)
+{
+	return -1;
+}
+static inline int modify_irte(int irq, struct irte *irte_modified)
+{
+	return -1;
+}
+static inline int free_irte(int irq)
+{
+	return -1;
+}
+static inline int map_irq_to_irte_handle(int irq, u16 *sub_handle)
+{
+	return -1;
+}
+static inline int set_irte_irq(int irq, struct intel_iommu *iommu, u16 index,
+			       u16 sub_handle)
+{
+	return -1;
+}
+static inline struct intel_iommu *map_dev_to_ir(struct pci_dev *dev)
+{
+	return NULL;
+}
+static inline struct intel_iommu *map_ioapic_to_ir(int apic)
+{
+	return NULL;
+}
 #define irq_remapped(irq)		(0)
 #define enable_intr_remapping(mode)	(-1)
 #define intr_remapping_enabled		(0)

commit 1531a6a6b81a4e6f9eec9a5608758a6ea14b96e0
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Mon Mar 16 17:04:57 2009 -0700

    x86, dmar: start with sane state while enabling dma and interrupt-remapping
    
    Impact: cleanup/sanitization
    
    Start from a sane state while enabling dma and interrupt-remapping, by
    clearing the previous recorded faults and disabling previously
    enabled queued invalidation and interrupt-remapping.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index c7768330c11d..8a035aec14a9 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -24,6 +24,7 @@
 #include <linux/acpi.h>
 #include <linux/types.h>
 #include <linux/msi.h>
+#include <linux/irqreturn.h>
 
 #if defined(CONFIG_DMAR) || defined(CONFIG_INTR_REMAP)
 struct intel_iommu;
@@ -125,6 +126,7 @@ extern void dmar_msi_mask(unsigned int irq);
 extern void dmar_msi_read(int irq, struct msi_msg *msg);
 extern void dmar_msi_write(int irq, struct msi_msg *msg);
 extern int dmar_set_interrupt(struct intel_iommu *iommu);
+extern irqreturn_t dmar_fault(int irq, void *dev_id);
 extern int arch_setup_dmar_msi(unsigned int irq);
 
 #ifdef CONFIG_DMAR

commit 9d783ba042771284fb4ee5013c3d94220755ae7f
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Mon Mar 16 17:04:55 2009 -0700

    x86, x2apic: enable fault handling for intr-remapping
    
    Impact: interface augmentation (not yet used)
    
    Enable fault handling flow for intr-remapping aswell. Fault handling
    code now shared by both dma-remapping and intr-remapping.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index f28440784cf0..c7768330c11d 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -49,6 +49,7 @@ extern int dmar_dev_scope_init(void);
 
 /* Intel IOMMU detection */
 extern void detect_intel_iommu(void);
+extern int enable_drhd_fault_handling(void);
 
 
 extern int parse_ioapics_under_ir(void);
@@ -116,9 +117,6 @@ extern struct intel_iommu *map_ioapic_to_ir(int apic);
 #define intr_remapping_enabled		(0)
 #endif
 
-#ifdef CONFIG_DMAR
-extern const char *dmar_get_fault_reason(u8 fault_reason);
-
 /* Can't use the common MSI interrupt functions
  * since DMAR is not a pci device
  */
@@ -129,6 +127,7 @@ extern void dmar_msi_write(int irq, struct msi_msg *msg);
 extern int dmar_set_interrupt(struct intel_iommu *iommu);
 extern int arch_setup_dmar_msi(unsigned int irq);
 
+#ifdef CONFIG_DMAR
 extern int iommu_detected, no_iommu;
 extern struct list_head dmar_rmrr_units;
 struct dmar_rmrr_unit {

commit 58fa7304a2c2bfd46e505c293ef779aa1d9715c2
Author: Mark McLoughlin <markmc@redhat.com>
Date:   Thu Nov 20 15:49:49 2008 +0000

    intel-iommu: kill off duplicate def of dmar_disabled
    
    This is only used in dmar.c and intel-iommu.h, so dma_remapping.h
    seems like the appropriate place for it.
    
    Signed-off-by: Mark McLoughlin <markmc@redhat.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index f1984fc3e06d..f28440784cf0 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -144,7 +144,6 @@ struct dmar_rmrr_unit {
 	list_for_each_entry(rmrr, &dmar_rmrr_units, list)
 /* Intel DMAR  initialization functions */
 extern int intel_iommu_init(void);
-extern int dmar_disabled;
 #else
 static inline int intel_iommu_init(void)
 {

commit f6dd5c3106fb283e37d915eeb33019ef40510f85
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Wed Sep 3 16:58:32 2008 -0700

    dmar: fix using early fixmap mapping for DMAR table parsing
    
    Very early detection of the DMAR tables will setup fixmap mapping. For
    parsing these tables later (while enabling dma and/or interrupt remapping),
    early fixmap mapping shouldn't be used. Fix it by calling table detection
    routines again, which will call generic apci_get_table() for setting up
    the correct mapping.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index c360c558e59e..f1984fc3e06d 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -45,7 +45,6 @@ extern struct list_head dmar_drhd_units;
 	list_for_each_entry(drhd, &dmar_drhd_units, list)
 
 extern int dmar_table_init(void);
-extern int early_dmar_detect(void);
 extern int dmar_dev_scope_init(void);
 
 /* Intel IOMMU detection */

commit 75c46fa61bc5b4ccd20a168ff325c58771248fcd
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Thu Jul 10 11:16:57 2008 -0700

    x64, x2apic/intr-remap: MSI and MSI-X support for interrupt remapping infrastructure
    
    MSI and MSI-X support for interrupt remapping infrastructure.
    
    MSI address register will be programmed with interrupt-remapping table
    entry(IRTE) index and the IRTE will contain information about the vector,
    cpu destination, etc.
    
    For MSI-X, all the IRTE's will be consecutively allocated in the table,
    and the address registers will contain the starting index to the block
    and the data register will contain the subindex with in that block.
    
    This also introduces a new irq_chip for cleaner irq migration (in the process
    context as opposed to the current irq migration in the context of an interrupt.
    interrupt-remapping infrastructure will help us achieve this).
    
    As MSI is edge triggered, irq migration is a simple atomic update(of vector
    and cpu destination) of IRTE and flushing the hardware cache.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: akpm@linux-foundation.org
    Cc: arjan@linux.intel.com
    Cc: andi@firstfloor.org
    Cc: ebiederm@xmission.com
    Cc: jbarnes@virtuousgeek.org
    Cc: steiner@sgi.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index bf41ffa74705..c360c558e59e 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -109,6 +109,7 @@ extern int flush_irte(int irq);
 extern int free_irte(int irq);
 
 extern int irq_remapped(int irq);
+extern struct intel_iommu *map_dev_to_ir(struct pci_dev *dev);
 extern struct intel_iommu *map_ioapic_to_ir(int apic);
 #else
 #define irq_remapped(irq)		(0)

commit 89027d35aa5b8f45ce0f7fa0911db85b46563da0
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Thu Jul 10 11:16:56 2008 -0700

    x64, x2apic/intr-remap: IO-APIC support for interrupt-remapping
    
    IO-APIC support in the presence of interrupt-remapping infrastructure.
    
    IO-APIC RTE will be programmed with interrupt-remapping table entry(IRTE)
    index and the IRTE will contain information about the vector, cpu destination,
    trigger mode etc, which traditionally was present in the IO-APIC RTE.
    
    Introduce a new irq_chip for cleaner irq migration (in the process
    context as opposed to the current irq migration in the context of an interrupt.
    interrupt-remapping infrastructure will help us achieve this cleanly).
    
    For edge triggered, irq migration is a simple atomic update(of vector
    and cpu destination) of IRTE and flush the hardware cache.
    
    For level triggered, we need to modify the io-apic RTE aswell with the update
    vector information, along with modifying IRTE with vector and cpu destination.
    So irq migration for level triggered is little  bit more complex compared to
    edge triggered migration. But the good news is, we use the same algorithm
    for level triggered migration as we have today, only difference being,
    we now initiate the irq migration from process context instead of the
    interrupt context.
    
    In future, when we do a directed EOI (combined with cpu EOI broadcast
    suppression) to the IO-APIC, level triggered irq migration will also be
    as simple as edge triggered migration and we can do the irq migration
    with a simple atomic update to IO-APIC RTE.
    
    TBD: some tests/changes needed in the presence of fixup_irqs() for
    level triggered irq migration.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: akpm@linux-foundation.org
    Cc: arjan@linux.intel.com
    Cc: andi@firstfloor.org
    Cc: ebiederm@xmission.com
    Cc: jbarnes@virtuousgeek.org
    Cc: steiner@sgi.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 324bbca85a26..bf41ffa74705 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -109,6 +109,7 @@ extern int flush_irte(int irq);
 extern int free_irte(int irq);
 
 extern int irq_remapped(int irq);
+extern struct intel_iommu *map_ioapic_to_ir(int apic);
 #else
 #define irq_remapped(irq)		(0)
 #define enable_intr_remapping(mode)	(-1)

commit b6fcb33ad6c05f152a672f7c96c1fab006527b80
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Thu Jul 10 11:16:44 2008 -0700

    x64, x2apic/intr-remap: routines managing Interrupt remapping table entries.
    
    Routines handling the management of interrupt remapping table entries.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: akpm@linux-foundation.org
    Cc: arjan@linux.intel.com
    Cc: andi@firstfloor.org
    Cc: ebiederm@xmission.com
    Cc: jbarnes@virtuousgeek.org
    Cc: steiner@sgi.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 8a0238dd2c11..324bbca85a26 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -98,7 +98,19 @@ struct irte {
 		__u64 high;
 	};
 };
+extern int get_irte(int irq, struct irte *entry);
+extern int modify_irte(int irq, struct irte *irte_modified);
+extern int alloc_irte(struct intel_iommu *iommu, int irq, u16 count);
+extern int set_irte_irq(int irq, struct intel_iommu *iommu, u16 index,
+   			u16 sub_handle);
+extern int map_irq_to_irte_handle(int irq, u16 *sub_handle);
+extern int clear_irte_irq(int irq, struct intel_iommu *iommu, u16 index);
+extern int flush_irte(int irq);
+extern int free_irte(int irq);
+
+extern int irq_remapped(int irq);
 #else
+#define irq_remapped(irq)		(0)
 #define enable_intr_remapping(mode)	(-1)
 #define intr_remapping_enabled		(0)
 #endif

commit 2ae21010694e56461a63bfc80e960090ce0a5ed9
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Thu Jul 10 11:16:43 2008 -0700

    x64, x2apic/intr-remap: Interrupt remapping infrastructure
    
    Interrupt remapping (part of Intel Virtualization Tech for directed I/O)
    infrastructure.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: akpm@linux-foundation.org
    Cc: arjan@linux.intel.com
    Cc: andi@firstfloor.org
    Cc: ebiederm@xmission.com
    Cc: jbarnes@virtuousgeek.org
    Cc: steiner@sgi.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index c4e96eb29617..8a0238dd2c11 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -25,9 +25,85 @@
 #include <linux/types.h>
 #include <linux/msi.h>
 
-#ifdef CONFIG_DMAR
+#if defined(CONFIG_DMAR) || defined(CONFIG_INTR_REMAP)
 struct intel_iommu;
 
+struct dmar_drhd_unit {
+	struct list_head list;		/* list of drhd units	*/
+	struct  acpi_dmar_header *hdr;	/* ACPI header		*/
+	u64	reg_base_addr;		/* register base address*/
+	struct	pci_dev **devices; 	/* target device array	*/
+	int	devices_cnt;		/* target device count	*/
+	u8	ignored:1; 		/* ignore drhd		*/
+	u8	include_all:1;
+	struct intel_iommu *iommu;
+};
+
+extern struct list_head dmar_drhd_units;
+
+#define for_each_drhd_unit(drhd) \
+	list_for_each_entry(drhd, &dmar_drhd_units, list)
+
+extern int dmar_table_init(void);
+extern int early_dmar_detect(void);
+extern int dmar_dev_scope_init(void);
+
+/* Intel IOMMU detection */
+extern void detect_intel_iommu(void);
+
+
+extern int parse_ioapics_under_ir(void);
+extern int alloc_iommu(struct dmar_drhd_unit *);
+#else
+static inline void detect_intel_iommu(void)
+{
+	return;
+}
+
+static inline int dmar_table_init(void)
+{
+	return -ENODEV;
+}
+#endif /* !CONFIG_DMAR && !CONFIG_INTR_REMAP */
+
+#ifdef CONFIG_INTR_REMAP
+extern int intr_remapping_enabled;
+extern int enable_intr_remapping(int);
+
+struct irte {
+	union {
+		struct {
+			__u64	present 	: 1,
+				fpd		: 1,
+				dst_mode	: 1,
+				redir_hint	: 1,
+				trigger_mode	: 1,
+				dlvry_mode	: 3,
+				avail		: 4,
+				__reserved_1	: 4,
+				vector		: 8,
+				__reserved_2	: 8,
+				dest_id		: 32;
+		};
+		__u64 low;
+	};
+
+	union {
+		struct {
+			__u64	sid		: 16,
+				sq		: 2,
+				svt		: 2,
+				__reserved_3	: 44;
+		};
+		__u64 high;
+	};
+};
+#else
+#define enable_intr_remapping(mode)	(-1)
+#define intr_remapping_enabled		(0)
+#endif
+
+#ifdef CONFIG_DMAR
 extern const char *dmar_get_fault_reason(u8 fault_reason);
 
 /* Can't use the common MSI interrupt functions
@@ -40,29 +116,8 @@ extern void dmar_msi_write(int irq, struct msi_msg *msg);
 extern int dmar_set_interrupt(struct intel_iommu *iommu);
 extern int arch_setup_dmar_msi(unsigned int irq);
 
-/* Intel IOMMU detection and initialization functions */
-extern void detect_intel_iommu(void);
-extern int intel_iommu_init(void);
-
-extern int dmar_table_init(void);
-extern int early_dmar_detect(void);
-extern int dmar_dev_scope_init(void);
-extern int parse_ioapics_under_ir(void);
-
-extern struct list_head dmar_drhd_units;
+extern int iommu_detected, no_iommu;
 extern struct list_head dmar_rmrr_units;
-
-struct dmar_drhd_unit {
-	struct list_head list;		/* list of drhd units	*/
-	struct  acpi_dmar_header *hdr;	/* ACPI header		*/
-	u64	reg_base_addr;		/* register base address*/
-	struct	pci_dev **devices; 	/* target device array	*/
-	int	devices_cnt;		/* target device count	*/
-	u8	ignored:1; 		/* ignore drhd		*/
-	u8	include_all:1;
-	struct intel_iommu *iommu;
-};
-
 struct dmar_rmrr_unit {
 	struct list_head list;		/* list of rmrr units	*/
 	struct acpi_dmar_header *hdr;	/* ACPI header		*/
@@ -72,24 +127,19 @@ struct dmar_rmrr_unit {
 	int	devices_cnt;		/* target device count */
 };
 
-#define for_each_drhd_unit(drhd) \
-	list_for_each_entry(drhd, &dmar_drhd_units, list)
 #define for_each_rmrr_units(rmrr) \
 	list_for_each_entry(rmrr, &dmar_rmrr_units, list)
-
-extern int alloc_iommu(struct dmar_drhd_unit *);
+/* Intel DMAR  initialization functions */
+extern int intel_iommu_init(void);
+extern int dmar_disabled;
 #else
-static inline void detect_intel_iommu(void)
-{
-	return;
-}
 static inline int intel_iommu_init(void)
 {
+#ifdef CONFIG_INTR_REMAP
+	return dmar_dev_scope_init();
+#else
 	return -ENODEV;
-}
-static inline int dmar_table_init(void)
-{
-	return -ENODEV;
+#endif
 }
 #endif /* !CONFIG_DMAR */
 #endif /* __DMAR_H__ */

commit ad3ad3f6a2caebf56869b83b69e23eb9fa5e0ab6
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Thu Jul 10 11:16:40 2008 -0700

    x64, x2apic/intr-remap: parse ioapic scope under vt-d structures
    
    Parse the vt-d device scope structures to find the mapping between IO-APICs
    and the interrupt remapping hardware units.
    
    This will be used later for enabling Interrupt-remapping for IOAPIC devices.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: akpm@linux-foundation.org
    Cc: arjan@linux.intel.com
    Cc: andi@firstfloor.org
    Cc: ebiederm@xmission.com
    Cc: jbarnes@virtuousgeek.org
    Cc: steiner@sgi.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 3ab07e425583..c4e96eb29617 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -47,6 +47,7 @@ extern int intel_iommu_init(void);
 extern int dmar_table_init(void);
 extern int early_dmar_detect(void);
 extern int dmar_dev_scope_init(void);
+extern int parse_ioapics_under_ir(void);
 
 extern struct list_head dmar_drhd_units;
 extern struct list_head dmar_rmrr_units;

commit 1886e8a90a580f3ad343f2065c84c1b9e1dac9ef
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Thu Jul 10 11:16:37 2008 -0700

    x64, x2apic/intr-remap: code re-structuring, to be used by both DMA and Interrupt remapping
    
    Allocate the iommu during the parse of DMA remapping hardware
    definition structures. And also, introduce routines for device
    scope initialization which will be explicitly called during
    dma-remapping initialization.
    
    These will be used for enabling interrupt remapping separately from the
    existing DMA-remapping enabling sequence.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: akpm@linux-foundation.org
    Cc: arjan@linux.intel.com
    Cc: andi@firstfloor.org
    Cc: ebiederm@xmission.com
    Cc: jbarnes@virtuousgeek.org
    Cc: steiner@sgi.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 56c73b847551..3ab07e425583 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -46,12 +46,14 @@ extern int intel_iommu_init(void);
 
 extern int dmar_table_init(void);
 extern int early_dmar_detect(void);
+extern int dmar_dev_scope_init(void);
 
 extern struct list_head dmar_drhd_units;
 extern struct list_head dmar_rmrr_units;
 
 struct dmar_drhd_unit {
 	struct list_head list;		/* list of drhd units	*/
+	struct  acpi_dmar_header *hdr;	/* ACPI header		*/
 	u64	reg_base_addr;		/* register base address*/
 	struct	pci_dev **devices; 	/* target device array	*/
 	int	devices_cnt;		/* target device count	*/
@@ -62,6 +64,7 @@ struct dmar_drhd_unit {
 
 struct dmar_rmrr_unit {
 	struct list_head list;		/* list of rmrr units	*/
+	struct acpi_dmar_header *hdr;	/* ACPI header		*/
 	u64	base_address;		/* reserved base address*/
 	u64	end_address;		/* reserved end address */
 	struct pci_dev **devices;	/* target devices */
@@ -72,6 +75,8 @@ struct dmar_rmrr_unit {
 	list_for_each_entry(drhd, &dmar_drhd_units, list)
 #define for_each_rmrr_units(rmrr) \
 	list_for_each_entry(rmrr, &dmar_rmrr_units, list)
+
+extern int alloc_iommu(struct dmar_drhd_unit *);
 #else
 static inline void detect_intel_iommu(void)
 {
@@ -81,6 +86,9 @@ static inline int intel_iommu_init(void)
 {
 	return -ENODEV;
 }
-
+static inline int dmar_table_init(void)
+{
+	return -ENODEV;
+}
 #endif /* !CONFIG_DMAR */
 #endif /* __DMAR_H__ */

commit d94afc6ccf6690b30ae112ec8101b3f10d50114e
Author: mark gross <mgross@linux.intel.com>
Date:   Fri Feb 8 04:18:39 2008 -0800

    intel-iommu: fault_reason index cleanup
    
    Fix an off by one bug in the fault reason string reporting function, and
    clean up some of the code around this buglet.
    
    [akpm@linux-foundation.org: cleanup]
    Signed-off-by: mark gross <mgross@linux.intel.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andi Kleen <ak@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index ffb6439cb5e6..56c73b847551 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -28,7 +28,7 @@
 #ifdef CONFIG_DMAR
 struct intel_iommu;
 
-extern char *dmar_get_fault_reason(u8 fault_reason);
+extern const char *dmar_get_fault_reason(u8 fault_reason);
 
 /* Can't use the common MSI interrupt functions
  * since DMAR is not a pci device

commit 3460a6d9cef9ac2aa997da7eff7ff1c8291b361c
Author: Keshavamurthy, Anil S <anil.s.keshavamurthy@intel.com>
Date:   Sun Oct 21 16:41:54 2007 -0700

    Intel IOMMU: DMAR fault handling support
    
    MSI interrupt handler registrations and fault handling support for Intel-IOMMU
    hadrware.
    
    This patch enables the MSI interrupts for the DMA remapping units and in the
    interrupt handler read the fault cause and outputs the same on to the console.
    
    Signed-off-by: Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
    Cc: Andi Kleen <ak@suse.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Muli Ben-Yehuda <muli@il.ibm.com>
    Cc: "Siddha, Suresh B" <suresh.b.siddha@intel.com>
    Cc: Arjan van de Ven <arjan@infradead.org>
    Cc: Ashok Raj <ashok.raj@intel.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Christoph Lameter <clameter@sgi.com>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 7d683dc8ed1e..ffb6439cb5e6 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -28,6 +28,18 @@
 #ifdef CONFIG_DMAR
 struct intel_iommu;
 
+extern char *dmar_get_fault_reason(u8 fault_reason);
+
+/* Can't use the common MSI interrupt functions
+ * since DMAR is not a pci device
+ */
+extern void dmar_msi_unmask(unsigned int irq);
+extern void dmar_msi_mask(unsigned int irq);
+extern void dmar_msi_read(int irq, struct msi_msg *msg);
+extern void dmar_msi_write(int irq, struct msi_msg *msg);
+extern int dmar_set_interrupt(struct intel_iommu *iommu);
+extern int arch_setup_dmar_msi(unsigned int irq);
+
 /* Intel IOMMU detection and initialization functions */
 extern void detect_intel_iommu(void);
 extern int intel_iommu_init(void);

commit ba39592764ed20cee09aae5352e603a27bf56b0d
Author: Keshavamurthy, Anil S <anil.s.keshavamurthy@intel.com>
Date:   Sun Oct 21 16:41:49 2007 -0700

    Intel IOMMU: Intel IOMMU driver
    
    Actual intel IOMMU driver.  Hardware spec can be found at:
    http://www.intel.com/technology/virtualization
    
    This driver sets X86_64 'dma_ops', so hook into standard DMA APIs.  In this
    way, PCI driver will get virtual DMA address.  This change is transparent to
    PCI drivers.
    
    [akpm@linux-foundation.org: remove unneeded cast]
    [akpm@linux-foundation.org: build fix]
    [bunk@stusta.de: fix duplicate CONFIG_DMAR Makefile line]
    Signed-off-by: Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
    Cc: Andi Kleen <ak@suse.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Muli Ben-Yehuda <muli@il.ibm.com>
    Cc: "Siddha, Suresh B" <suresh.b.siddha@intel.com>
    Cc: Arjan van de Ven <arjan@infradead.org>
    Cc: Ashok Raj <ashok.raj@intel.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Christoph Lameter <clameter@sgi.com>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
index 8d3e0e38ca4d..7d683dc8ed1e 100644
--- a/include/linux/dmar.h
+++ b/include/linux/dmar.h
@@ -23,7 +23,14 @@
 
 #include <linux/acpi.h>
 #include <linux/types.h>
+#include <linux/msi.h>
 
+#ifdef CONFIG_DMAR
+struct intel_iommu;
+
+/* Intel IOMMU detection and initialization functions */
+extern void detect_intel_iommu(void);
+extern int intel_iommu_init(void);
 
 extern int dmar_table_init(void);
 extern int early_dmar_detect(void);
@@ -49,4 +56,19 @@ struct dmar_rmrr_unit {
 	int	devices_cnt;		/* target device count */
 };
 
+#define for_each_drhd_unit(drhd) \
+	list_for_each_entry(drhd, &dmar_drhd_units, list)
+#define for_each_rmrr_units(rmrr) \
+	list_for_each_entry(rmrr, &dmar_rmrr_units, list)
+#else
+static inline void detect_intel_iommu(void)
+{
+	return;
+}
+static inline int intel_iommu_init(void)
+{
+	return -ENODEV;
+}
+
+#endif /* !CONFIG_DMAR */
 #endif /* __DMAR_H__ */

commit 10e5247f40f3bf7508a0ed2848c9cae37bddf4bc
Author: Keshavamurthy, Anil S <anil.s.keshavamurthy@intel.com>
Date:   Sun Oct 21 16:41:41 2007 -0700

    Intel IOMMU: DMAR detection and parsing logic
    
    This patch supports the upcomming Intel IOMMU hardware a.k.a.  Intel(R)
    Virtualization Technology for Directed I/O Architecture and the hardware spec
    for the same can be found here
    http://www.intel.com/technology/virtualization/index.htm
    
    FAQ! (questions from akpm, answers from ak)
    
    > So...  what's all this code for?
    >
    > I assume that the intent here is to speed things up under Xen, etc?
    
    Yes in some cases, but not this code.  That would be the Xen version of this
    code that could potentially assign whole devices to guests.  I expect this to
    be only useful in some special cases though because most hardware is not
    virtualizable and you typically want an own instance for each guest.
    
    Ok at some point KVM might implement this too; i likely would use this code
    for this.
    
    > Do we
    > have any benchmark results to help us to decide whether a merge would be
    > justified?
    
    The main advantage for doing it in the normal kernel is not performance, but
    more safety.  Broken devices won't be able to corrupt memory by doing random
    DMA.
    
    Unfortunately that doesn't work for graphics yet, for that need user space
    interfaces for the X server are needed.
    
    There are some potential performance benefits too:
    
    - When you have a device that cannot address the complete address range an
      IOMMU can remap its memory instead of bounce buffering.  Remapping is likely
      cheaper than copying.
    
    - The IOMMU can merge sg lists into a single virtual block.  This could
      potentially speed up SG IO when the device is slow walking SG lists.  [I
      long ago benchmarked 5% on some block benchmark with an old MPT Fusion; but
      it probably depends a lot on the HBA]
    
    And you get better driver debugging because unexpected memory accesses from
    the devices will cause a trappable event.
    
    >
    > Does it slow anything down?
    
    It adds more overhead to each IO so yes.
    
    This patch:
    
    Add support for early detection and parsing of DMAR's (DMA Remapping) reported
    to OS via ACPI tables.
    
    DMA remapping(DMAR) devices support enables independent address translations
    for Direct Memory Access(DMA) from Devices.  These DMA remapping devices are
    reported via ACPI tables and includes pci device scope covered by these DMA
    remapping device.
    
    For detailed info on the specification of "Intel(R) Virtualization Technology
    for Directed I/O Architecture" please see
    http://www.intel.com/technology/virtualization/index.htm
    
    Signed-off-by: Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
    Cc: Andi Kleen <ak@suse.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Muli Ben-Yehuda <muli@il.ibm.com>
    Cc: "Siddha, Suresh B" <suresh.b.siddha@intel.com>
    Cc: Arjan van de Ven <arjan@infradead.org>
    Cc: Ashok Raj <ashok.raj@intel.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Christoph Lameter <clameter@sgi.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/dmar.h b/include/linux/dmar.h
new file mode 100644
index 000000000000..8d3e0e38ca4d
--- /dev/null
+++ b/include/linux/dmar.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2006, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * Copyright (C) Ashok Raj <ashok.raj@intel.com>
+ * Copyright (C) Shaohua Li <shaohua.li@intel.com>
+ */
+
+#ifndef __DMAR_H__
+#define __DMAR_H__
+
+#include <linux/acpi.h>
+#include <linux/types.h>
+
+
+extern int dmar_table_init(void);
+extern int early_dmar_detect(void);
+
+extern struct list_head dmar_drhd_units;
+extern struct list_head dmar_rmrr_units;
+
+struct dmar_drhd_unit {
+	struct list_head list;		/* list of drhd units	*/
+	u64	reg_base_addr;		/* register base address*/
+	struct	pci_dev **devices; 	/* target device array	*/
+	int	devices_cnt;		/* target device count	*/
+	u8	ignored:1; 		/* ignore drhd		*/
+	u8	include_all:1;
+	struct intel_iommu *iommu;
+};
+
+struct dmar_rmrr_unit {
+	struct list_head list;		/* list of rmrr units	*/
+	u64	base_address;		/* reserved base address*/
+	u64	end_address;		/* reserved end address */
+	struct pci_dev **devices;	/* target devices */
+	int	devices_cnt;		/* target device count */
+};
+
+#endif /* __DMAR_H__ */
