commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/arm-cci.h b/include/linux/arm-cci.h
index 521ec1f2e6bc..d0e44201d855 100644
--- a/include/linux/arm-cci.h
+++ b/include/linux/arm-cci.h
@@ -1,21 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * CCI cache coherent interconnect support
  *
  * Copyright (C) 2013 ARM Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
 #ifndef __LINUX_ARM_CCI_H

commit ee8e5d5fbec0e880b18bbdbfe12de53ab1dec21f
Author: Suzuki K. Poulose <suzuki.poulose@arm.com>
Date:   Wed Mar 18 12:24:41 2015 +0000

    arm-cci: Split the code for PMU vs driver support
    
    This patch separates the PMU driver code from the low level
    CCI driver code and enables the PMU driver for ARM64.
    
    Introduces config options for both.
    
     ARM_CCI400_PORT_CTRL   - controls the low level driver code for
                              CCI400 ports.
     ARM_CCI400_PMU         - controls the PMU driver code
     ARM_CCI400_COMMON      - Common defintions for CCI400
    
    This patch also changes:
     ARM_CCI - common code for probing the CCI devices. This can be
       used for adding support for newer CCI versions(e.g, CCI-500).
    
    Cc: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Abhilash Kesavan <a.kesavan@samsung.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Nicolas Pitre <nicolas.pitre@linaro.org>
    Cc: Punit Agrawal <punit.agrawal@arm.com>
    Acked-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Acked-by: Punit Agrawal <punit.agrawal@arm.com>
    Signed-off-by: Suzuki K. Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/arm-cci.h b/include/linux/arm-cci.h
index aede5c765eec..521ec1f2e6bc 100644
--- a/include/linux/arm-cci.h
+++ b/include/linux/arm-cci.h
@@ -30,12 +30,16 @@ struct device_node;
 
 #ifdef CONFIG_ARM_CCI
 extern bool cci_probed(void);
+#else
+static inline bool cci_probed(void) { return false; }
+#endif
+
+#ifdef CONFIG_ARM_CCI400_PORT_CTRL
 extern int cci_ace_get_port(struct device_node *dn);
 extern int cci_disable_port_by_cpu(u64 mpidr);
 extern int __cci_control_port_by_device(struct device_node *dn, bool enable);
 extern int __cci_control_port_by_index(u32 port, bool enable);
 #else
-static inline bool cci_probed(void) { return false; }
 static inline int cci_ace_get_port(struct device_node *dn)
 {
 	return -ENODEV;
@@ -51,6 +55,7 @@ static inline int __cci_control_port_by_index(u32 port, bool enable)
 	return -ENODEV;
 }
 #endif
+
 #define cci_disable_port_by_device(dev) \
 	__cci_control_port_by_device(dev, false)
 #define cci_enable_port_by_device(dev) \

commit 772742a6c7ea4612fe043353531e6435ed33e719
Author: Suzuki K. Poulose <suzuki.poulose@arm.com>
Date:   Wed Mar 18 12:24:40 2015 +0000

    arm-cci: Get rid of secure transactions for PMU driver
    
    Avoid secure transactions while probing the CCI PMU. The
    existing code makes use of the Peripheral ID2 (PID2) register
    to determine the revision of the CCI400, which requires a
    secure transaction. This puts a limitation on the usage of the
    driver on systems running non-secure Linux(e.g, ARM64).
    
    Updated the device-tree binding for cci pmu node to add the explicit
    revision number for the compatible field.
    
    The supported strings are :
            arm,cci-400-pmu,r0
            arm,cci-400-pmu,r1
            arm,cci-400-pmu - DEPRECATED. See NOTE below
    
    NOTE: If the revision is not mentioned, we need to probe the cci revision,
    which could be fatal on a platform running non-secure. We need a reliable way
    to know if we can poke the CCI registers at runtime on ARM32. We depend on
    'mcpm_is_available()' when it is available. mcpm_is_available() returns true
    only when there is a registered driver for mcpm. Otherwise, we assume that we
    don't have secure access, and skips probing the revision number(ARM64 case).
    
    The MCPM should figure out if it is safe to access the CCI. Unfortunately
    there isn't a reliable way to indicate the same via dtb. This patch doesn't
    address/change the current situation. It only deals with the CCI-PMU, leaving
    the assumptions about the secure access as it has been, prior to this patch.
    
    Cc: devicetree@vger.kernel.org
    Cc: Punit Agrawal <punit.agrawal@arm.com>
    Tested-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Suzuki K. Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/arm-cci.h b/include/linux/arm-cci.h
index 79d6edf446d5..aede5c765eec 100644
--- a/include/linux/arm-cci.h
+++ b/include/linux/arm-cci.h
@@ -24,6 +24,8 @@
 #include <linux/errno.h>
 #include <linux/types.h>
 
+#include <asm/arm-cci.h>
+
 struct device_node;
 
 #ifdef CONFIG_ARM_CCI

commit ed69bdd8fd9b2db68b915ce5f60fc51d4744a9b1
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Fri Jul 13 15:55:52 2012 +0100

    drivers: bus: add ARM CCI support
    
    On ARM multi-cluster systems coherency between cores running on
    different clusters is managed by the cache-coherent interconnect (CCI).
    It allows broadcasting of TLB invalidates and memory barriers and it
    guarantees cache coherency at system level through snooping of slave
    interfaces connected to it.
    
    This patch enables the basic infrastructure required in Linux to handle and
    programme the CCI component.
    
    Non-local variables used by the CCI management functions called by power
    down function calls after disabling the cache must be flushed out to main
    memory in advance, otherwise incoherency of those values may occur if they
    are sitting in the cache of some other CPU when power down functions
    execute. Driver code ensures that relevant data structures are flushed
    from inner and outer caches after the driver probe is completed.
    
    CCI slave port resources are linked to set of CPUs through bus masters
    phandle properties that link the interface resources to masters node in
    the device tree.
    
    Documentation describing the CCI DT bindings is provided with the patch.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>

diff --git a/include/linux/arm-cci.h b/include/linux/arm-cci.h
new file mode 100644
index 000000000000..79d6edf446d5
--- /dev/null
+++ b/include/linux/arm-cci.h
@@ -0,0 +1,61 @@
+/*
+ * CCI cache coherent interconnect support
+ *
+ * Copyright (C) 2013 ARM Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __LINUX_ARM_CCI_H
+#define __LINUX_ARM_CCI_H
+
+#include <linux/errno.h>
+#include <linux/types.h>
+
+struct device_node;
+
+#ifdef CONFIG_ARM_CCI
+extern bool cci_probed(void);
+extern int cci_ace_get_port(struct device_node *dn);
+extern int cci_disable_port_by_cpu(u64 mpidr);
+extern int __cci_control_port_by_device(struct device_node *dn, bool enable);
+extern int __cci_control_port_by_index(u32 port, bool enable);
+#else
+static inline bool cci_probed(void) { return false; }
+static inline int cci_ace_get_port(struct device_node *dn)
+{
+	return -ENODEV;
+}
+static inline int cci_disable_port_by_cpu(u64 mpidr) { return -ENODEV; }
+static inline int __cci_control_port_by_device(struct device_node *dn,
+					       bool enable)
+{
+	return -ENODEV;
+}
+static inline int __cci_control_port_by_index(u32 port, bool enable)
+{
+	return -ENODEV;
+}
+#endif
+#define cci_disable_port_by_device(dev) \
+	__cci_control_port_by_device(dev, false)
+#define cci_enable_port_by_device(dev) \
+	__cci_control_port_by_device(dev, true)
+#define cci_disable_port_by_index(dev) \
+	__cci_control_port_by_index(dev, false)
+#define cci_enable_port_by_index(dev) \
+	__cci_control_port_by_index(dev, true)
+
+#endif
