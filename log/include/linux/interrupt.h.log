commit f0178fc01fe46bab6a95415f5647d1a74efcad1b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jun 10 08:37:01 2020 +0200

    x86/entry: Unbreak __irqentry_text_start/end magic
    
    The entry rework moved interrupt entry code from the irqentry to the
    noinstr section which made the irqentry section empty.
    
    This breaks boundary checks which rely on the __irqentry_text_start/end
    markers to find out whether a function in a stack trace is
    interrupt/exception entry code. This affects the function graph tracer and
    filter_irq_stacks().
    
    As the IDT entry points are all sequentialy emitted this is rather simple
    to unbreak by injecting __irqentry_text_start/end as global labels.
    
    To make this work correctly:
    
      - Remove the IRQENTRY_TEXT section from the x86 linker script
      - Define __irqentry so it breaks the build if it's used
      - Adjust the entry mirroring in PTI
      - Remove the redundant kprobes and unwinder bound checks
    
    Reported-by: Qian Cai <cai@lca.pw>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 80f637c3a6f3..5db970b6615a 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -760,8 +760,10 @@ extern int arch_early_irq_init(void);
 /*
  * We want to know which function is an entrypoint of a hardirq or a softirq.
  */
-#define __irq_entry		 __attribute__((__section__(".irqentry.text")))
-#define __softirq_entry  \
-	__attribute__((__section__(".softirqentry.text")))
+#ifndef __irq_entry
+# define __irq_entry	 __attribute__((__section__(".irqentry.text")))
+#endif
+
+#define __softirq_entry  __attribute__((__section__(".softirqentry.text")))
 
 #endif

commit acd26bcf362708594ea081ef55140e37d0854ed2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 6 14:03:47 2020 +0100

    genirq: Provide interrupt injection mechanism
    
    Error injection mechanisms need a half ways safe way to inject interrupts as
    invoking generic_handle_irq() or the actual device interrupt handler
    directly from e.g. a debugfs write is not guaranteed to be safe.
    
    On x86 generic_handle_irq() is unsafe due to the hardware trainwreck which
    is the base of x86 interrupt delivery and affinity management.
    
    Move the irq debugfs injection code into a separate function which can be
    used by error injection code as well.
    
    The implementation prevents at least that state is corrupted, but it cannot
    close a very tiny race window on x86 which might result in a stale and not
    serviced device interrupt under very unlikely circumstances.
    
    This is explicitly for debugging and testing and not for production use or
    abuse in random driver code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Reviewed-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Acked-by: Marc Zyngier <maz@kernel.org>
    Link: https://lkml.kernel.org/r/20200306130623.990928309@linutronix.de

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index c5fe60ec6b84..80f637c3a6f3 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -248,6 +248,8 @@ extern void enable_percpu_nmi(unsigned int irq, unsigned int type);
 extern int prepare_percpu_nmi(unsigned int irq);
 extern void teardown_percpu_nmi(unsigned int irq);
 
+extern int irq_inject_interrupt(unsigned int irq);
+
 /* The following three functions are for the core kernel use only. */
 extern void suspend_device_irqs(void);
 extern void resume_device_irqs(void);

commit 043cf46825c102683b1027762c09c7e2b749e5a3
Merge: b22bfea7f16c 83bae01182ea
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 3 12:20:25 2019 -0800

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Ingo Molnar:
     "The main changes in the timer code in this cycle were:
    
       - Clockevent updates:
    
          - timer-of framework cleanups. (Geert Uytterhoeven)
    
          - Use timer-of for the renesas-ostm and the device name to prevent
            name collision in case of multiple timers. (Geert Uytterhoeven)
    
          - Check if there is an error after calling of_clk_get in asm9260
            (Chuhong Yuan)
    
       - ABI fix: Zero out high order bits of nanoseconds on compat
         syscalls. This got broken a year ago, with apparently no side
         effects so far.
    
         Since the kernel would use random data otherwise I don't think we'd
         have other options but to fix the bug, even if there was a side
         effect to applications (Dmitry Safonov)
    
       - Optimize ns_to_timespec64() on 32-bit systems: move away from
         div_s64_rem() which can be slow, to div_u64_rem() which is faster
         (Arnd Bergmann)
    
       - Annotate KCSAN-reported false positive data races in
         hrtimer_is_queued() users by moving timer->state handling over to
         the READ_ONCE()/WRITE_ONCE() APIs. This documents these accesses
         (Eric Dumazet)
    
       - Misc cleanups and small fixes"
    
    [ I undid the "ABI fix" and updated the comments instead. The reason
      there were apparently no side effects is that the fix was a no-op.
    
      The updated comment is to say _why_ it was a no-op.    - Linus ]
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      time: Zero the upper 32-bits in __kernel_timespec on 32-bit
      time: Rename tsk->real_start_time to ->start_boottime
      hrtimer: Remove the comment about not used HRTIMER_SOFTIRQ
      time: Fix spelling mistake in comment
      time: Optimize ns_to_timespec64()
      hrtimer: Annotate lockless access to timer->state
      clocksource/drivers/asm9260: Add a check for of_clk_get
      clocksource/drivers/renesas-ostm: Use unique device name instead of ostm
      clocksource/drivers/renesas-ostm: Convert to timer_of
      clocksource/drivers/timer-of: Use unique device name instead of timer
      clocksource/drivers/timer-of: Convert last full_name to %pOF

commit 5ca470a0c3886b80ec13c3a19e9aae4c2f469202
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Fri Oct 4 10:39:55 2019 -0600

    docs: Add request_irq() documentation
    
    While checking the results of the :c:func: removal, I noticed that there
    was no documentation for request_irq(), and request_threaded_irq() was not
    mentioned at all.  Add a kerneldoc comment for request_irq() and add
    request_threaded_irq() to the list of functions.
    
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 89fc59dab57d..ba873ec7e09d 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -140,6 +140,19 @@ request_threaded_irq(unsigned int irq, irq_handler_t handler,
 		     irq_handler_t thread_fn,
 		     unsigned long flags, const char *name, void *dev);
 
+/**
+ * request_irq - Add a handler for an interrupt line
+ * @irq:	The interrupt line to allocate
+ * @handler:	Function to be called when the IRQ occurs.
+ *		Primary handler for threaded interrupts
+ *		If NULL, the default primary handler is installed
+ * @flags:	Handling flags
+ * @name:	Name of the device generating this interrupt
+ * @dev:	A cookie passed to the handler function
+ *
+ * This call allocates an interrupt and establishes a handler; see
+ * the documentation for request_threaded_irq() for details.
+ */
 static inline int __must_check
 request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
 	    const char *name, void *dev)

commit 3bbc53f4ae1686b501d92d4a5fd400f4958c8a98
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Nov 7 10:19:24 2019 +0100

    hrtimer: Remove the comment about not used HRTIMER_SOFTIRQ
    
    The softirq `HRTIMER_SOFTIRQ' was not used since commit c6eb3f70d448
    ("hrtimer: Get rid of hrtimer softirq").
    
    But it got used again, beginning with commit 5da70160462e ("hrtimer:
    Implement support for softirq based hrtimers"), which did not remove the
    comment. Remove it now.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20191107091924.13410-1-bigeasy@linutronix.de

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 89fc59dab57d..963c3c695784 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -520,8 +520,7 @@ enum
 	IRQ_POLL_SOFTIRQ,
 	TASKLET_SOFTIRQ,
 	SCHED_SOFTIRQ,
-	HRTIMER_SOFTIRQ, /* Unused, but kept as tools rely on the
-			    numbering. Sigh! */
+	HRTIMER_SOFTIRQ,
 	RCU_SOFTIRQ,    /* Preferable RCU should always be the last softirq */
 
 	NR_SOFTIRQS

commit 77dcfe2b9edc98286cf18e03c243c9b999f955d9
Merge: 04cbfba62085 fc6763a2d7e0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 17 19:15:14 2019 -0700

    Merge tag 'pm-5.4-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management updates from Rafael Wysocki:
     "These include a rework of the main suspend-to-idle code flow (related
      to the handling of spurious wakeups), a switch over of several users
      of cpufreq notifiers to QoS-based limits, a new devfreq driver for
      Tegra20, a new cpuidle driver and governor for virtualized guests, an
      extension of the wakeup sources framework to expose wakeup sources as
      device objects in sysfs, and more.
    
      Specifics:
    
       - Rework the main suspend-to-idle control flow to avoid repeating
         "noirq" device resume and suspend operations in case of spurious
         wakeups from the ACPI EC and decouple the ACPI EC wakeups support
         from the LPS0 _DSM support (Rafael Wysocki).
    
       - Extend the wakeup sources framework to expose wakeup sources as
         device objects in sysfs (Tri Vo, Stephen Boyd).
    
       - Expose system suspend statistics in sysfs (Kalesh Singh).
    
       - Introduce a new haltpoll cpuidle driver and a new matching governor
         for virtualized guests wanting to do guest-side polling in the idle
         loop (Marcelo Tosatti, Joao Martins, Wanpeng Li, Stephen Rothwell).
    
       - Fix the menu and teo cpuidle governors to allow the scheduler tick
         to be stopped if PM QoS is used to limit the CPU idle state exit
         latency in some cases (Rafael Wysocki).
    
       - Increase the resolution of the play_idle() argument to microseconds
         for more fine-grained injection of CPU idle cycles (Daniel
         Lezcano).
    
       - Switch over some users of cpuidle notifiers to the new QoS-based
         frequency limits and drop the CPUFREQ_ADJUST and CPUFREQ_NOTIFY
         policy notifier events (Viresh Kumar).
    
       - Add new cpufreq driver based on nvmem for sun50i (Yangtao Li).
    
       - Add support for MT8183 and MT8516 to the mediatek cpufreq driver
         (Andrew-sh.Cheng, Fabien Parent).
    
       - Add i.MX8MN support to the imx-cpufreq-dt cpufreq driver (Anson
         Huang).
    
       - Add qcs404 to cpufreq-dt-platdev blacklist (Jorge Ramirez-Ortiz).
    
       - Update the qcom cpufreq driver (among other things, to make it
         easier to extend and to use kryo cpufreq for other nvmem-based
         SoCs) and add qcs404 support to it (Niklas Cassel, Douglas
         RAILLARD, Sibi Sankar, Sricharan R).
    
       - Fix assorted issues and make assorted minor improvements in the
         cpufreq code (Colin Ian King, Douglas RAILLARD, Florian Fainelli,
         Gustavo Silva, Hariprasad Kelam).
    
       - Add new devfreq driver for NVidia Tegra20 (Dmitry Osipenko, Arnd
         Bergmann).
    
       - Add new Exynos PPMU events to devfreq events and extend that
         mechanism (Lukasz Luba).
    
       - Fix and clean up the exynos-bus devfreq driver (Kamil Konieczny).
    
       - Improve devfreq documentation and governor code, fix spelling typos
         in devfreq (Ezequiel Garcia, Krzysztof Kozlowski, Leonard Crestez,
         MyungJoo Ham, Gaël PORTAY).
    
       - Add regulators enable and disable to the OPP (operating performance
         points) framework (Kamil Konieczny).
    
       - Update the OPP framework to support multiple opp-suspend properties
         (Anson Huang).
    
       - Fix assorted issues and make assorted minor improvements in the OPP
         code (Niklas Cassel, Viresh Kumar, Yue Hu).
    
       - Clean up the generic power domains (genpd) framework (Ulf Hansson).
    
       - Clean up assorted pieces of power management code and documentation
         (Akinobu Mita, Amit Kucheria, Chuhong Yuan).
    
       - Update the pm-graph tool to version 5.5 including multiple fixes
         and improvements (Todd Brandt).
    
       - Update the cpupower utility (Benjamin Weis, Geert Uytterhoeven,
         Sébastien Szymanski)"
    
    * tag 'pm-5.4-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (126 commits)
      cpuidle-haltpoll: Enable kvm guest polling when dedicated physical CPUs are available
      cpuidle-haltpoll: do not set an owner to allow modunload
      cpuidle-haltpoll: return -ENODEV on modinit failure
      cpuidle-haltpoll: set haltpoll as preferred governor
      cpuidle: allow governor switch on cpuidle_register_driver()
      PM: runtime: Documentation: add runtime_status ABI document
      pm-graph: make setVal unbuffered again for python2 and python3
      powercap: idle_inject: Use higher resolution for idle injection
      cpuidle: play_idle: Increase the resolution to usec
      cpuidle-haltpoll: vcpu hotplug support
      cpufreq: Add qcs404 to cpufreq-dt-platdev blacklist
      cpufreq: qcom: Add support for qcs404 on nvmem driver
      cpufreq: qcom: Refactor the driver to make it easier to extend
      cpufreq: qcom: Re-organise kryo cpufreq to use it for other nvmem based qcom socs
      dt-bindings: opp: Add qcom-opp bindings with properties needed for CPR
      dt-bindings: opp: qcom-nvmem: Support pstates provided by a power domain
      Documentation: cpufreq: Update policy notifier documentation
      cpufreq: Remove CPUFREQ_ADJUST and CPUFREQ_NOTIFY policy notifier events
      PM / Domains: Verify PM domain type in dev_pm_genpd_set_performance_state()
      PM / Domains: Simplify genpd_lookup_dev()
      ...

commit b6a32bbd8735def2d0d696ba59205d1874b7800f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Aug 16 18:09:23 2019 +0200

    genirq: Force interrupt threading on RT
    
    Switch force_irqthreads from a boot time modifiable variable to a compile
    time constant when CONFIG_PREEMPT_RT is enabled.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20190816160923.12855-1-bigeasy@linutronix.de

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 5b8328a99b2a..07b527dca996 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -472,7 +472,11 @@ extern int irq_set_irqchip_state(unsigned int irq, enum irqchip_irq_state which,
 				 bool state);
 
 #ifdef CONFIG_IRQ_FORCED_THREADING
+# ifdef CONFIG_PREEMPT_RT
+#  define force_irqthreads	(true)
+# else
 extern bool force_irqthreads;
+# endif
 #else
 #define force_irqthreads	(0)
 #endif

commit 3a79bc63d90750f737ab9d7219bd3091d2fd6d84
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 15 13:03:20 2019 +0200

    PCI: irq: Introduce rearm_wake_irq()
    
    Introduce a new function, rearm_wake_irq(), allowing a wakeup IRQ
    to be armed for systen wakeup detection again without running any
    action handlers associated with it after it has been armed for
    wakeup detection and triggered.
    
    That is useful for IRQs, like ACPI SCI, that may deliver wakeup
    as well as non-wakeup interrupts when armed for systen wakeup
    detection.  In those cases, it may be possible to determine whether
    or not the delivered interrupt is a systen wakeup one without
    running the entire action handler (or handlers, if the IRQ is
    shared) for the IRQ, and if the interrupt turns out to be a
    non-wakeup one, the IRQ can be rearmed with the help of the
    new function.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 5b8328a99b2a..0e9cdb3efda7 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -238,6 +238,7 @@ extern void teardown_percpu_nmi(unsigned int irq);
 /* The following three functions are for the core kernel use only. */
 extern void suspend_device_irqs(void);
 extern void resume_device_irqs(void);
+extern void rearm_wake_irq(unsigned int irq);
 
 /**
  * struct irq_affinity_notify - context for notification of IRQ affinity changes

commit 151f4e2bdc7a04020ae5c533896fb91a16e1f501
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Thu Jun 13 07:10:36 2019 -0300

    docs: power: convert docs to ReST and rename to *.rst
    
    Convert the PM documents to ReST, in order to allow them to
    build with Sphinx.
    
    The conversion is actually:
      - add blank lines and indentation in order to identify paragraphs;
      - fix tables markups;
      - add some lists markups;
      - mark literal blocks;
      - adjust title markups.
    
    At its new index.rst, let's add a :orphan: while this is not linked to
    the main index.rst file, in order to avoid build warnings.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Acked-by: Srivatsa S. Bhat (VMware) <srivatsa@csail.mit.edu>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index c7eef32e7739..5b8328a99b2a 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -52,7 +52,7 @@
  *                irq line disabled until the threaded handler has been run.
  * IRQF_NO_SUSPEND - Do not disable this IRQ during suspend.  Does not guarantee
  *                   that this interrupt will wake the system from a suspended
- *                   state.  See Documentation/power/suspend-and-interrupts.txt
+ *                   state.  See Documentation/power/suspend-and-interrupts.rst
  * IRQF_FORCE_RESUME - Force enable it on resume even if IRQF_NO_SUSPEND is set
  * IRQF_NO_THREAD - Interrupt cannot be threaded
  * IRQF_EARLY_RESUME - Resume IRQ early during syscore instead of at device

commit d7dcf26ff0ffd7b56fe2b09ed7f1867589f3cdf1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 1 23:48:21 2019 +0100

    softirq: Remove tasklet_hrtimer
    
    There are no more users of this interface.
    Remove it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: David S. Miller <davem@davemloft.net>
    Cc: netdev@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190301224821.29843-4-bigeasy@linutronix.de

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 690b238a44d5..c7eef32e7739 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -668,31 +668,6 @@ extern void tasklet_kill_immediate(struct tasklet_struct *t, unsigned int cpu);
 extern void tasklet_init(struct tasklet_struct *t,
 			 void (*func)(unsigned long), unsigned long data);
 
-struct tasklet_hrtimer {
-	struct hrtimer		timer;
-	struct tasklet_struct	tasklet;
-	enum hrtimer_restart	(*function)(struct hrtimer *);
-};
-
-extern void
-tasklet_hrtimer_init(struct tasklet_hrtimer *ttimer,
-		     enum hrtimer_restart (*function)(struct hrtimer *),
-		     clockid_t which_clock, enum hrtimer_mode mode);
-
-static inline
-void tasklet_hrtimer_start(struct tasklet_hrtimer *ttimer, ktime_t time,
-			   const enum hrtimer_mode mode)
-{
-	hrtimer_start(&ttimer->timer, time, mode);
-}
-
-static inline
-void tasklet_hrtimer_cancel(struct tasklet_hrtimer *ttimer)
-{
-	hrtimer_cancel(&ttimer->timer);
-	tasklet_kill(&ttimer->tasklet);
-}
-
 /*
  * Autoprobing for irqs:
  *

commit a324ca9cad4736252c33c1e28cffe1d87f262d03
Merge: 4e6b26d23dc1 28528fca4908
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Feb 23 10:53:31 2019 +0100

    Merge tag 'irqchip-5.1' of git://git.kernel.org/pub/scm/linux/kernel/git/maz/arm-platforms into irq/core
    
    Pull irqchip updates from Marc Zyngier
    
    - Core pseudo-NMI handling code
    - Allow the default irq domain to be retrieved
    - A new interrupt controller for the Loongson LS1X platform
    - Affinity support for the SiFive PLIC
    - Better support for the iMX irqsteer driver
    - NUMA aware memory allocations for GICv3
    - A handful of other fixes (i8259, GICv3, PLIC)

commit c66d4bd110a1f8a68c1a88bfbf866eb50c6464b7
Author: Ming Lei <ming.lei@redhat.com>
Date:   Sat Feb 16 18:13:09 2019 +0100

    genirq/affinity: Add new callback for (re)calculating interrupt sets
    
    The interrupt affinity spreading mechanism supports to spread out
    affinities for one or more interrupt sets. A interrupt set contains one or
    more interrupts. Each set is mapped to a specific functionality of a
    device, e.g. general I/O queues and read I/O queus of multiqueue block
    devices.
    
    The number of interrupts per set is defined by the driver. It depends on
    the total number of available interrupts for the device, which is
    determined by the PCI capabilites and the availability of underlying CPU
    resources, and the number of queues which the device provides and the
    driver wants to instantiate.
    
    The driver passes initial configuration for the interrupt allocation via a
    pointer to struct irq_affinity.
    
    Right now the allocation mechanism is complex as it requires to have a loop
    in the driver to determine the maximum number of interrupts which are
    provided by the PCI capabilities and the underlying CPU resources.  This
    loop would have to be replicated in every driver which wants to utilize
    this mechanism. That's unwanted code duplication and error prone.
    
    In order to move this into generic facilities it is required to have a
    mechanism, which allows the recalculation of the interrupt sets and their
    size, in the core code. As the core code does not have any knowledge about the
    underlying device, a driver specific callback is required in struct
    irq_affinity, which can be invoked by the core code. The callback gets the
    number of available interupts as an argument, so the driver can calculate the
    corresponding number and size of interrupt sets.
    
    At the moment the struct irq_affinity pointer which is handed in from the
    driver and passed through to several core functions is marked 'const', but for
    the callback to be able to modify the data in the struct it's required to
    remove the 'const' qualifier.
    
    Add the optional callback to struct irq_affinity, which allows drivers to
    recalculate the number and size of interrupt sets and remove the 'const'
    qualifier.
    
    For simple invocations, which do not supply a callback, a default callback
    is installed, which just sets nr_sets to 1 and transfers the number of
    spreadable vectors to the set_size array at index 0.
    
    This is for now guarded by a check for nr_sets != 0 to keep the NVME driver
    working until it is converted to the callback mechanism.
    
    To make sure that the driver configuration is correct under all circumstances
    the callback is invoked even when there are no interrupts for queues left,
    i.e. the pre/post requirements already exhaust the numner of available
    interrupts.
    
    At the PCI layer irq_create_affinity_masks() has to be invoked even for the
    case where the legacy interrupt is used. That ensures that the callback is
    invoked and the device driver can adjust to that situation.
    
    [ tglx: Fixed the simple case (no sets required). Moved the sanity check
            for nr_sets after the invocation of the callback so it catches
            broken drivers. Fixed the kernel doc comments for struct
            irq_affinity and de-'This patch'-ed the changelog ]
    
    Signed-off-by: Ming Lei <ming.lei@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Bjorn Helgaas <helgaas@kernel.org>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: linux-block@vger.kernel.org
    Cc: Sagi Grimberg <sagi@grimberg.me>
    Cc: linux-nvme@lists.infradead.org
    Cc: linux-pci@vger.kernel.org
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Sumit Saxena <sumit.saxena@broadcom.com>
    Cc: Kashyap Desai <kashyap.desai@broadcom.com>
    Cc: Shivasharan Srikanteshwara <shivasharan.srikanteshwara@broadcom.com>
    Link: https://lkml.kernel.org/r/20190216172228.512444498@linutronix.de

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 5afdfd5dc39b..dcdddf4fa76b 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -252,12 +252,18 @@ struct irq_affinity_notify {
  * @nr_sets:		The number of interrupt sets for which affinity
  *			spreading is required
  * @set_size:		Array holding the size of each interrupt set
+ * @calc_sets:		Callback for calculating the number and size
+ *			of interrupt sets
+ * @priv:		Private data for usage by @calc_sets, usually a
+ *			pointer to driver/device specific data.
  */
 struct irq_affinity {
 	unsigned int	pre_vectors;
 	unsigned int	post_vectors;
 	unsigned int	nr_sets;
 	unsigned int	set_size[IRQ_AFFINITY_MAX_SETS];
+	void		(*calc_sets)(struct irq_affinity *, unsigned int nvecs);
+	void		*priv;
 };
 
 /**
@@ -317,7 +323,7 @@ extern int
 irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify);
 
 struct irq_affinity_desc *
-irq_create_affinity_masks(unsigned int nvec, const struct irq_affinity *affd);
+irq_create_affinity_masks(unsigned int nvec, struct irq_affinity *affd);
 
 unsigned int irq_calc_affinity_vectors(unsigned int minvec, unsigned int maxvec,
 				       const struct irq_affinity *affd);
@@ -354,7 +360,7 @@ irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)
 }
 
 static inline struct irq_affinity_desc *
-irq_create_affinity_masks(unsigned int nvec, const struct irq_affinity *affd)
+irq_create_affinity_masks(unsigned int nvec, struct irq_affinity *affd)
 {
 	return NULL;
 }

commit 9cfef55bb57e7620c63087be18a76351628f8d0f
Author: Ming Lei <ming.lei@redhat.com>
Date:   Sat Feb 16 18:13:08 2019 +0100

    genirq/affinity: Store interrupt sets size in struct irq_affinity
    
    The interrupt affinity spreading mechanism supports to spread out
    affinities for one or more interrupt sets. A interrupt set contains one
    or more interrupts. Each set is mapped to a specific functionality of a
    device, e.g. general I/O queues and read I/O queus of multiqueue block
    devices.
    
    The number of interrupts per set is defined by the driver. It depends on
    the total number of available interrupts for the device, which is
    determined by the PCI capabilites and the availability of underlying CPU
    resources, and the number of queues which the device provides and the
    driver wants to instantiate.
    
    The driver passes initial configuration for the interrupt allocation via
    a pointer to struct irq_affinity.
    
    Right now the allocation mechanism is complex as it requires to have a
    loop in the driver to determine the maximum number of interrupts which
    are provided by the PCI capabilities and the underlying CPU resources.
    This loop would have to be replicated in every driver which wants to
    utilize this mechanism. That's unwanted code duplication and error
    prone.
    
    In order to move this into generic facilities it is required to have a
    mechanism, which allows the recalculation of the interrupt sets and
    their size, in the core code. As the core code does not have any
    knowledge about the underlying device, a driver specific callback will
    be added to struct affinity_desc, which will be invoked by the core
    code. The callback will get the number of available interupts as an
    argument, so the driver can calculate the corresponding number and size
    of interrupt sets.
    
    To support this, two modifications for the handling of struct irq_affinity
    are required:
    
    1) The (optional) interrupt sets size information is contained in a
       separate array of integers and struct irq_affinity contains a
       pointer to it.
    
       This is cumbersome and as the maximum number of interrupt sets is small,
       there is no reason to have separate storage. Moving the size array into
       struct affinity_desc avoids indirections and makes the code simpler.
    
    2) At the moment the struct irq_affinity pointer which is handed in from
       the driver and passed through to several core functions is marked
       'const'.
    
       With the upcoming callback to recalculate the number and size of
       interrupt sets, it's necessary to remove the 'const'
       qualifier. Otherwise the callback would not be able to update the data.
    
    Implement #1 and store the interrupt sets size in 'struct irq_affinity'.
    
    No functional change.
    
    [ tglx: Fixed the memcpy() size so it won't copy beyond the size of the
            source. Fixed the kernel doc comments for struct irq_affinity and
            de-'This patch'-ed the changelog ]
    
    Signed-off-by: Ming Lei <ming.lei@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Bjorn Helgaas <helgaas@kernel.org>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: linux-block@vger.kernel.org
    Cc: Sagi Grimberg <sagi@grimberg.me>
    Cc: linux-nvme@lists.infradead.org
    Cc: linux-pci@vger.kernel.org
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Sumit Saxena <sumit.saxena@broadcom.com>
    Cc: Kashyap Desai <kashyap.desai@broadcom.com>
    Cc: Shivasharan Srikanteshwara <shivasharan.srikanteshwara@broadcom.com>
    Link: https://lkml.kernel.org/r/20190216172228.423723127@linutronix.de

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 35e7389c2011..5afdfd5dc39b 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -241,20 +241,23 @@ struct irq_affinity_notify {
 	void (*release)(struct kref *ref);
 };
 
+#define	IRQ_AFFINITY_MAX_SETS  4
+
 /**
  * struct irq_affinity - Description for automatic irq affinity assignements
  * @pre_vectors:	Don't apply affinity to @pre_vectors at beginning of
  *			the MSI(-X) vector space
  * @post_vectors:	Don't apply affinity to @post_vectors at end of
  *			the MSI(-X) vector space
- * @nr_sets:		Length of passed in *sets array
- * @sets:		Number of affinitized sets
+ * @nr_sets:		The number of interrupt sets for which affinity
+ *			spreading is required
+ * @set_size:		Array holding the size of each interrupt set
  */
 struct irq_affinity {
 	unsigned int	pre_vectors;
 	unsigned int	post_vectors;
 	unsigned int	nr_sets;
-	unsigned int	*sets;
+	unsigned int	set_size[IRQ_AFFINITY_MAX_SETS];
 };
 
 /**

commit 0145c30e896d26e638d27c957d9eed72893c1c92
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Feb 16 18:13:07 2019 +0100

    genirq/affinity: Code consolidation
    
    All information and calculations in the interrupt affinity spreading code
    is strictly unsigned int. Though the code uses int all over the place.
    
    Convert it over to unsigned int.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ming Lei <ming.lei@redhat.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Bjorn Helgaas <helgaas@kernel.org>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: linux-block@vger.kernel.org
    Cc: Sagi Grimberg <sagi@grimberg.me>
    Cc: linux-nvme@lists.infradead.org
    Cc: linux-pci@vger.kernel.org
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Sumit Saxena <sumit.saxena@broadcom.com>
    Cc: Kashyap Desai <kashyap.desai@broadcom.com>
    Cc: Shivasharan Srikanteshwara <shivasharan.srikanteshwara@broadcom.com>
    Link: https://lkml.kernel.org/r/20190216172228.336424556@linutronix.de

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 4a728dba02e2..35e7389c2011 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -251,10 +251,10 @@ struct irq_affinity_notify {
  * @sets:		Number of affinitized sets
  */
 struct irq_affinity {
-	int	pre_vectors;
-	int	post_vectors;
-	int	nr_sets;
-	int	*sets;
+	unsigned int	pre_vectors;
+	unsigned int	post_vectors;
+	unsigned int	nr_sets;
+	unsigned int	*sets;
 };
 
 /**
@@ -314,9 +314,10 @@ extern int
 irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify);
 
 struct irq_affinity_desc *
-irq_create_affinity_masks(int nvec, const struct irq_affinity *affd);
+irq_create_affinity_masks(unsigned int nvec, const struct irq_affinity *affd);
 
-int irq_calc_affinity_vectors(int minvec, int maxvec, const struct irq_affinity *affd);
+unsigned int irq_calc_affinity_vectors(unsigned int minvec, unsigned int maxvec,
+				       const struct irq_affinity *affd);
 
 #else /* CONFIG_SMP */
 
@@ -350,13 +351,14 @@ irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)
 }
 
 static inline struct irq_affinity_desc *
-irq_create_affinity_masks(int nvec, const struct irq_affinity *affd)
+irq_create_affinity_masks(unsigned int nvec, const struct irq_affinity *affd)
 {
 	return NULL;
 }
 
-static inline int
-irq_calc_affinity_vectors(int minvec, int maxvec, const struct irq_affinity *affd)
+static inline unsigned int
+irq_calc_affinity_vectors(unsigned int minvec, unsigned int maxvec,
+			  const struct irq_affinity *affd)
 {
 	return maxvec;
 }

commit 4b078c3f1a26487c39363089ba0d5c6b09f2a89f
Author: Julien Thierry <julien.thierry@arm.com>
Date:   Thu Jan 31 14:53:59 2019 +0000

    genirq: Provide NMI management for percpu_devid interrupts
    
    Add support for percpu_devid interrupts treated as NMIs.
    
    Percpu_devid NMIs need to be setup/torn down on each CPU they target.
    
    The same restrictions as for global NMIs still apply for percpu_devid NMIs.
    
    Signed-off-by: Julien Thierry <julien.thierry@arm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 9941d1a8d83c..831ddcdc5597 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -168,10 +168,15 @@ request_percpu_irq(unsigned int irq, irq_handler_t handler,
 				    devname, percpu_dev_id);
 }
 
+extern int __must_check
+request_percpu_nmi(unsigned int irq, irq_handler_t handler,
+		   const char *devname, void __percpu *dev);
+
 extern const void *free_irq(unsigned int, void *);
 extern void free_percpu_irq(unsigned int, void __percpu *);
 
 extern const void *free_nmi(unsigned int irq, void *dev_id);
+extern void free_percpu_nmi(unsigned int irq, void __percpu *percpu_dev_id);
 
 struct device;
 
@@ -224,7 +229,11 @@ extern bool irq_percpu_is_enabled(unsigned int irq);
 extern void irq_wake_thread(unsigned int irq, void *dev_id);
 
 extern void disable_nmi_nosync(unsigned int irq);
+extern void disable_percpu_nmi(unsigned int irq);
 extern void enable_nmi(unsigned int irq);
+extern void enable_percpu_nmi(unsigned int irq, unsigned int type);
+extern int prepare_percpu_nmi(unsigned int irq);
+extern void teardown_percpu_nmi(unsigned int irq);
 
 /* The following three functions are for the core kernel use only. */
 extern void suspend_device_irqs(void);

commit b525903c254dab2491410f0f23707691b7c2c317
Author: Julien Thierry <julien.thierry@arm.com>
Date:   Thu Jan 31 14:53:58 2019 +0000

    genirq: Provide basic NMI management for interrupt lines
    
    Add functionality to allocate interrupt lines that will deliver IRQs
    as Non-Maskable Interrupts. These allocations are only successful if
    the irqchip provides the necessary support and allows NMI delivery for the
    interrupt line.
    
    Interrupt lines allocated for NMI delivery must be enabled/disabled through
    enable_nmi/disable_nmi_nosync to keep their state consistent.
    
    To treat a PERCPU IRQ as NMI, the interrupt must not be shared nor threaded,
    the irqchip directly managing the IRQ must be the root irqchip and the
    irqchip cannot be behind a slow bus.
    
    Signed-off-by: Julien Thierry <julien.thierry@arm.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index c672f34235e7..9941d1a8d83c 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -156,6 +156,10 @@ __request_percpu_irq(unsigned int irq, irq_handler_t handler,
 		     unsigned long flags, const char *devname,
 		     void __percpu *percpu_dev_id);
 
+extern int __must_check
+request_nmi(unsigned int irq, irq_handler_t handler, unsigned long flags,
+	    const char *name, void *dev);
+
 static inline int __must_check
 request_percpu_irq(unsigned int irq, irq_handler_t handler,
 		   const char *devname, void __percpu *percpu_dev_id)
@@ -167,6 +171,8 @@ request_percpu_irq(unsigned int irq, irq_handler_t handler,
 extern const void *free_irq(unsigned int, void *);
 extern void free_percpu_irq(unsigned int, void __percpu *);
 
+extern const void *free_nmi(unsigned int irq, void *dev_id);
+
 struct device;
 
 extern int __must_check
@@ -217,6 +223,9 @@ extern void enable_percpu_irq(unsigned int irq, unsigned int type);
 extern bool irq_percpu_is_enabled(unsigned int irq);
 extern void irq_wake_thread(unsigned int irq, void *dev_id);
 
+extern void disable_nmi_nosync(unsigned int irq);
+extern void enable_nmi(unsigned int irq);
+
 /* The following three functions are for the core kernel use only. */
 extern void suspend_device_irqs(void);
 extern void resume_device_irqs(void);

commit 70921ae25f944423f0abf096f73455c586da0652
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Tue Jan 8 17:04:32 2019 -0700

    genirq: Fix the kerneldoc comment for struct irq_affinity_desc
    
    A recent commit added a new field but did not update the kerneldoc comment,
    leading to this build warning:
    
      ./include/linux/interrupt.h:268: warning: Function parameter or member 'is_managed' not described in 'irq_affinity_desc'
    
    Add the missing information, making the docs build 0.001% quieter.
    
    Fixes: c410abbbacb9 ("genirq/affinity: Add is_managed to struct irq_affinity_desc")
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Dou Liyang <douliyangs@gmail.com>
    Link: https://lkml.kernel.org/r/20190108170432.59bae8a6@lwn.net

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index c672f34235e7..4a728dba02e2 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -260,6 +260,7 @@ struct irq_affinity {
 /**
  * struct irq_affinity_desc - Interrupt affinity descriptor
  * @mask:	cpumask to hold the affinity assignment
+ * @is_managed: 1 if the interrupt is managed internally
  */
 struct irq_affinity_desc {
 	struct cpumask	mask;

commit c410abbbacb9b378365ba17a30df08b4b9eec64f
Author: Dou Liyang <douliyangs@gmail.com>
Date:   Tue Dec 4 23:51:21 2018 +0800

    genirq/affinity: Add is_managed to struct irq_affinity_desc
    
    Devices which use managed interrupts usually have two classes of
    interrupts:
    
      - Interrupts for multiple device queues
      - Interrupts for general device management
    
    Currently both classes are treated the same way, i.e. as managed
    interrupts. The general interrupts get the default affinity mask assigned
    while the device queue interrupts are spread out over the possible CPUs.
    
    Treating the general interrupts as managed is both a limitation and under
    certain circumstances a bug. Assume the following situation:
    
     default_irq_affinity = 4..7
    
    So if CPUs 4-7 are offlined, then the core code will shut down the device
    management interrupts because the last CPU in their affinity mask went
    offline.
    
    It's also a limitation because it's desired to allow manual placement of
    the general device interrupts for various reasons. If they are marked
    managed then the interrupt affinity setting from both user and kernel space
    is disabled. That limitation was reported by Kashyap and Sumit.
    
    Expand struct irq_affinity_desc with a new bit 'is_managed' which is set
    for truly managed interrupts (queue interrupts) and cleared for the general
    device interrupts.
    
    [ tglx: Simplify code and massage changelog ]
    
    Reported-by: Kashyap Desai <kashyap.desai@broadcom.com>
    Reported-by: Sumit Saxena <sumit.saxena@broadcom.com>
    Signed-off-by: Dou Liyang <douliyangs@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-pci@vger.kernel.org
    Cc: shivasharan.srikanteshwara@broadcom.com
    Cc: ming.lei@redhat.com
    Cc: hch@lst.de
    Cc: bhelgaas@google.com
    Cc: douliyang1@huawei.com
    Link: https://lkml.kernel.org/r/20181204155122.6327-3-douliyangs@gmail.com

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index c44b7844dc83..c672f34235e7 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -263,6 +263,7 @@ struct irq_affinity {
  */
 struct irq_affinity_desc {
 	struct cpumask	mask;
+	unsigned int	is_managed : 1;
 };
 
 #if defined(CONFIG_SMP)

commit bec04037e4e484f41ee4d9409e40616874169d20
Author: Dou Liyang <douliyangs@gmail.com>
Date:   Tue Dec 4 23:51:20 2018 +0800

    genirq/core: Introduce struct irq_affinity_desc
    
    The interrupt affinity management uses straight cpumask pointers to convey
    the automatically assigned affinity masks for managed interrupts. The core
    interrupt descriptor allocation also decides based on the pointer being non
    NULL whether an interrupt is managed or not.
    
    Devices which use managed interrupts usually have two classes of
    interrupts:
    
      - Interrupts for multiple device queues
      - Interrupts for general device management
    
    Currently both classes are treated the same way, i.e. as managed
    interrupts. The general interrupts get the default affinity mask assigned
    while the device queue interrupts are spread out over the possible CPUs.
    
    Treating the general interrupts as managed is both a limitation and under
    certain circumstances a bug. Assume the following situation:
    
     default_irq_affinity = 4..7
    
    So if CPUs 4-7 are offlined, then the core code will shut down the device
    management interrupts because the last CPU in their affinity mask went
    offline.
    
    It's also a limitation because it's desired to allow manual placement of
    the general device interrupts for various reasons. If they are marked
    managed then the interrupt affinity setting from both user and kernel space
    is disabled.
    
    To remedy that situation it's required to convey more information than the
    cpumasks through various interfaces related to interrupt descriptor
    allocation.
    
    Instead of adding yet another argument, create a new data structure
    'irq_affinity_desc' which for now just contains the cpumask. This struct
    can be expanded to convey auxilliary information in the next step.
    
    No functional change, just preparatory work.
    
    [ tglx: Simplified logic and clarified changelog ]
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Dou Liyang <douliyangs@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-pci@vger.kernel.org
    Cc: kashyap.desai@broadcom.com
    Cc: shivasharan.srikanteshwara@broadcom.com
    Cc: sumit.saxena@broadcom.com
    Cc: ming.lei@redhat.com
    Cc: hch@lst.de
    Cc: douliyang1@huawei.com
    Link: https://lkml.kernel.org/r/20181204155122.6327-2-douliyangs@gmail.com

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index ca397ff40836..c44b7844dc83 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -257,6 +257,14 @@ struct irq_affinity {
 	int	*sets;
 };
 
+/**
+ * struct irq_affinity_desc - Interrupt affinity descriptor
+ * @mask:	cpumask to hold the affinity assignment
+ */
+struct irq_affinity_desc {
+	struct cpumask	mask;
+};
+
 #if defined(CONFIG_SMP)
 
 extern cpumask_var_t irq_default_affinity;
@@ -303,7 +311,9 @@ extern int irq_set_affinity_hint(unsigned int irq, const struct cpumask *m);
 extern int
 irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify);
 
-struct cpumask *irq_create_affinity_masks(int nvec, const struct irq_affinity *affd);
+struct irq_affinity_desc *
+irq_create_affinity_masks(int nvec, const struct irq_affinity *affd);
+
 int irq_calc_affinity_vectors(int minvec, int maxvec, const struct irq_affinity *affd);
 
 #else /* CONFIG_SMP */
@@ -337,7 +347,7 @@ irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)
 	return 0;
 }
 
-static inline struct cpumask *
+static inline struct irq_affinity_desc *
 irq_create_affinity_masks(int nvec, const struct irq_affinity *affd)
 {
 	return NULL;

commit 6da4b3ab9a6e9b1b5f90322ab3fa3a7dd18edb19
Author: Jens Axboe <axboe@kernel.dk>
Date:   Fri Nov 2 22:59:51 2018 +0800

    genirq/affinity: Add support for allocating interrupt sets
    
    A driver may have a need to allocate multiple sets of MSI/MSI-X interrupts,
    and have them appropriately affinitized.
    
    Add support for defining a number of sets in the irq_affinity structure, of
    varying sizes, and get each set affinitized correctly across the machine.
    
    [ tglx: Minor changelog tweaks ]
    
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Ming Lei <ming.lei@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Ming Lei <ming.lei@redhat.com>
    Reviewed-by: Keith Busch <keith.busch@intel.com>
    Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
    Cc: linux-block@vger.kernel.org
    Link: https://lkml.kernel.org/r/20181102145951.31979-5-ming.lei@redhat.com

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 1d6711c28271..ca397ff40836 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -247,10 +247,14 @@ struct irq_affinity_notify {
  *			the MSI(-X) vector space
  * @post_vectors:	Don't apply affinity to @post_vectors at end of
  *			the MSI(-X) vector space
+ * @nr_sets:		Length of passed in *sets array
+ * @sets:		Number of affinitized sets
  */
 struct irq_affinity {
 	int	pre_vectors;
 	int	post_vectors;
+	int	nr_sets;
+	int	*sets;
 };
 
 #if defined(CONFIG_SMP)

commit b8d62f33b7b225935649ab165d901fe8dd7f95e5
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Oct 8 13:17:26 2018 +0200

    genirq: Fix grammar s/an /a /
    
    Fix a grammar mistake in <linux/interrupt.h>.
    
    [ mingo: While at it also fix another similar error in another comment as well. ]
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Jiri Kosina <trivial@kernel.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20181008111726.26286-1-geert%2Brenesas@glider.be
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index eeceac3376fc..1d6711c28271 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -45,7 +45,7 @@
  * IRQF_PERCPU - Interrupt is per cpu
  * IRQF_NOBALANCING - Flag to exclude this interrupt from irq balancing
  * IRQF_IRQPOLL - Interrupt is used for polling (only the interrupt that is
- *                registered first in an shared interrupt is considered for
+ *                registered first in a shared interrupt is considered for
  *                performance reasons)
  * IRQF_ONESHOT - Interrupt is not reenabled after the hardirq handler finished.
  *                Used by threaded interrupts which need to keep the

commit 48bda43eabb8d086204f543cf8bbad696b8c6391
Author: Frederic Weisbecker <frederic@kernel.org>
Date:   Tue May 8 15:38:26 2018 +0200

    softirq/s390: Move default mutators of overwritten softirq mask to s390
    
    s390 is now the last architecture that entirely overwrites
    local_softirq_pending() and uses the according default definitions of
    set_softirq_pending() and or_softirq_pending().
    
    Just move these to s390 to debloat the generic code complexity.
    
    Suggested-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Frederic Weisbecker <frederic@kernel.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: James E.J. Bottomley <jejb@parisc-linux.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/1525786706-22846-12-git-send-email-frederic@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 7a11f73c5c3b..eeceac3376fc 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -442,13 +442,6 @@ extern bool force_irqthreads;
 #define set_softirq_pending(x)	(__this_cpu_write(local_softirq_pending_ref, (x)))
 #define or_softirq_pending(x)	(__this_cpu_or(local_softirq_pending_ref, (x)))
 
-#else /* local_softirq_pending */
-
-#ifndef __ARCH_SET_SOFTIRQ_PENDING
-#define set_softirq_pending(x) (local_softirq_pending() = (x))
-#define or_softirq_pending(x)  (local_softirq_pending() |= (x))
-#endif
-
 #endif /* local_softirq_pending */
 
 /* Some architectures might implement lazy enabling/disabling of

commit 0fd7d86285290ccebc0dc6eb536b6b043dd6a1e4
Author: Frederic Weisbecker <frederic@kernel.org>
Date:   Tue May 8 15:38:20 2018 +0200

    softirq/core: Consolidate default local_softirq_pending() implementations
    
    Consolidate and optimize default softirq mask API implementations.
    Per-CPU operations are expected to be faster and a few architectures
    already rely on them to implement local_softirq_pending() and related
    accessors/mutators. Those will be migrated to the new generic code.
    
    Signed-off-by: Frederic Weisbecker <frederic@kernel.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: James E.J. Bottomley <jejb@parisc-linux.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/1525786706-22846-6-git-send-email-frederic@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 5426627f9c55..7a11f73c5c3b 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -432,11 +432,25 @@ extern bool force_irqthreads;
 #define force_irqthreads	(0)
 #endif
 
+#ifndef local_softirq_pending
+
+#ifndef local_softirq_pending_ref
+#define local_softirq_pending_ref irq_stat.__softirq_pending
+#endif
+
+#define local_softirq_pending()	(__this_cpu_read(local_softirq_pending_ref))
+#define set_softirq_pending(x)	(__this_cpu_write(local_softirq_pending_ref, (x)))
+#define or_softirq_pending(x)	(__this_cpu_or(local_softirq_pending_ref, (x)))
+
+#else /* local_softirq_pending */
+
 #ifndef __ARCH_SET_SOFTIRQ_PENDING
 #define set_softirq_pending(x) (local_softirq_pending() = (x))
 #define or_softirq_pending(x)  (local_softirq_pending() |= (x))
 #endif
 
+#endif /* local_softirq_pending */
+
 /* Some architectures might implement lazy enabling/disabling of
  * interrupts. In some cases, such as stop_machine, we might want
  * to ensure that after a local_irq_disable(), interrupts have

commit 562c45d635ecd5c0648ceb4d4aff9bdc1ad91252
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Thu Feb 15 16:49:45 2018 -0800

    headers: Drop two #included headers from <linux/interrupt.h>
    
    It seems that <linux/interrupt.h> does not need <linux/linkage.h>
    nor <linux/preempt.h>.  8 kernels builds are successful without
    these 2 headers (allmodconfig, allyesconfig, allnoconfig, and
    tinyconfig on both i386 and x86_64).
    
    <linux/interrupt.h> is #included 3875 times in 4.16-rc1, so this
    reduces #include processing of these 2 files by a total of 7750 times.
    
    Since I only tested x86 builds, this needs to be tested on other
    $ARCHes as well.
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-arch@vger.kernel.org
    Link: http://lkml.kernel.org/r/b24b9ec8-4970-65f5-759a-911d4ba2fcf0@infradead.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 69c238210325..5426627f9c55 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -4,9 +4,7 @@
 #define _LINUX_INTERRUPT_H
 
 #include <linux/kernel.h>
-#include <linux/linkage.h>
 #include <linux/bitops.h>
-#include <linux/preempt.h>
 #include <linux/cpumask.h>
 #include <linux/irqreturn.h>
 #include <linux/irqnr.h>

commit 4675ff05de2d76d167336b368bd07f3fef6ed5a6
Author: Levin, Alexander (Sasha Levin) <alexander.levin@verizon.com>
Date:   Wed Nov 15 17:36:02 2017 -0800

    kmemcheck: rip it out
    
    Fix up makefiles, remove references, and git rm kmemcheck.
    
    Link: http://lkml.kernel.org/r/20171007030159.22241-4-alexander.levin@verizon.com
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Vegard Nossum <vegardno@ifi.uio.no>
    Cc: Pekka Enberg <penberg@kernel.org>
    Cc: Michal Hocko <mhocko@kernel.org>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Tim Hansen <devtimhansen@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index baeb872283d9..69c238210325 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -594,21 +594,6 @@ static inline void tasklet_hi_schedule(struct tasklet_struct *t)
 		__tasklet_hi_schedule(t);
 }
 
-extern void __tasklet_hi_schedule_first(struct tasklet_struct *t);
-
-/*
- * This version avoids touching any other tasklets. Needed for kmemcheck
- * in order not to take any page faults while enqueueing this tasklet;
- * consider VERY carefully whether you really need this or
- * tasklet_hi_schedule()...
- */
-static inline void tasklet_hi_schedule_first(struct tasklet_struct *t)
-{
-	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
-		__tasklet_hi_schedule_first(t);
-}
-
-
 static inline void tasklet_disable_nosync(struct tasklet_struct *t)
 {
 	atomic_inc(&t->count);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 59ba11661b6e..baeb872283d9 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /* interrupt.h */
 #ifndef _LINUX_INTERRUPT_H
 #define _LINUX_INTERRUPT_H

commit 229a71860547ec856b156179a9c6bef2de426f66
Author: Masami Hiramatsu <mhiramat@kernel.org>
Date:   Thu Aug 3 11:38:21 2017 +0900

    irq: Make the irqentry text section unconditional
    
    Generate irqentry and softirqentry text sections without
    any Kconfig dependencies. This will add extra sections, but
    there should be no performace impact.
    
    Suggested-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Masami Hiramatsu <mhiramat@kernel.org>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: David S . Miller <davem@davemloft.net>
    Cc: Francis Deslauriers <francis.deslauriers@efficios.com>
    Cc: Jesper Nilsson <jesper.nilsson@axis.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: linux-arch@vger.kernel.org
    Cc: linux-cris-kernel@axis.com
    Cc: mathieu.desnoyers@efficios.com
    Link: http://lkml.kernel.org/r/150172789110.27216.3955739126693102122.stgit@devbox
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index a2fddddb0d60..59ba11661b6e 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -18,6 +18,7 @@
 #include <linux/atomic.h>
 #include <asm/ptrace.h>
 #include <asm/irq.h>
+#include <asm/sections.h>
 
 /*
  * These correspond to the IORESOURCE_IRQ_* defines in
@@ -726,7 +727,6 @@ extern int early_irq_init(void);
 extern int arch_probe_nr_irqs(void);
 extern int arch_early_irq_init(void);
 
-#if defined(CONFIG_FUNCTION_GRAPH_TRACER) || defined(CONFIG_KASAN)
 /*
  * We want to know which function is an entrypoint of a hardirq or a softirq.
  */
@@ -734,16 +734,4 @@ extern int arch_early_irq_init(void);
 #define __softirq_entry  \
 	__attribute__((__section__(".softirqentry.text")))
 
-/* Limits of hardirq entrypoints */
-extern char __irqentry_text_start[];
-extern char __irqentry_text_end[];
-/* Limits of softirq entrypoints */
-extern char __softirqentry_text_start[];
-extern char __softirqentry_text_end[];
-
-#else
-#define __irq_entry
-#define __softirq_entry
-#endif
-
 #endif

commit 7cb328c30a71a450278031f932d2134c11165f4c
Merge: 19bf2e0ef18e c5c601c4295f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jul 9 10:24:46 2017 -0700

    Merge branch 'irq-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq fixes from Thomas Gleixner:
    
     - A few fixes mopping up the fallout of the big irq overhaul
    
     - Move the interrupt resource management logic out of the spin locked,
       irq disabled region to avoid unnecessary restrictions of the resource
       callbacks
    
     - Preparation for reworking the per cpu irq request function.
    
    * 'irq-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      irqdomain: Allow ACPI device nodes to be used as irqdomain identifiers
      genirq/debugfs: Remove redundant NULL pointer check
      genirq: Allow to pass the IRQF_TIMER flag with percpu irq request
      genirq/timings: Move free timings out of spinlocked region
      genirq: Move irq resource handling out of spinlocked region
      genirq: Add mutex to irq desc to serialize request/free_irq()
      genirq: Move bus locking into __setup_irq()
      genirq: Force inlining of __irq_startup_managed to prevent build failure
      genirq/debugfs: Fix build for !CONFIG_IRQ_DOMAIN

commit f263fbb8d60824993c1b64385056a3cfdbb21d45
Merge: 026d15f6b987 6aed468480e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 8 15:51:57 2017 -0700

    Merge tag 'pci-v4.13-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
      - add sysfs max_link_speed/width, current_link_speed/width (Wong Vee
        Khee)
    
      - make host bridge IRQ mapping much more generic (Matthew Minter,
        Lorenzo Pieralisi)
    
      - convert most drivers to pci_scan_root_bus_bridge() (Lorenzo
        Pieralisi)
    
      - mutex sriov_configure() (Jakub Kicinski)
    
      - mutex pci_error_handlers callbacks (Christoph Hellwig)
    
      - split ->reset_notify() into ->reset_prepare()/reset_done()
        (Christoph Hellwig)
    
      - support multiple PCIe portdrv interrupts for MSI as well as MSI-X
        (Gabriele Paoloni)
    
      - allocate MSI/MSI-X vector for Downstream Port Containment (Gabriele
        Paoloni)
    
      - fix MSI IRQ affinity pre/post/min_vecs issue (Michael Hernandez)
    
      - test INTx masking during enumeration, not at run-time (Piotr Gregor)
    
      - avoid using device_may_wakeup() for runtime PM (Rafael J. Wysocki)
    
      - restore the status of PCI devices across hibernation (Chen Yu)
    
      - keep parent resources that start at 0x0 (Ard Biesheuvel)
    
      - enable ECRC only if device supports it (Bjorn Helgaas)
    
      - restore PRI and PASID state after Function-Level Reset (CQ Tang)
    
      - skip DPC event if device is not present (Keith Busch)
    
      - check domain when matching SMBIOS info (Sujith Pandel)
    
      - mark Intel XXV710 NIC INTx masking as broken (Alex Williamson)
    
      - avoid AMD SB7xx EHCI USB wakeup defect (Kai-Heng Feng)
    
      - work around long-standing Macbook Pro poweroff issue (Bjorn Helgaas)
    
      - add Switchtec "running" status flag (Logan Gunthorpe)
    
      - fix dra7xx incorrect RW1C IRQ register usage (Arvind Yadav)
    
      - modify xilinx-nwl IRQ chip for legacy interrupts (Bharat Kumar
        Gogada)
    
      - move VMD SRCU cleanup after bus, child device removal (Jon Derrick)
    
      - add Faraday clock handling (Linus Walleij)
    
      - configure Rockchip MPS and reorganize (Shawn Lin)
    
      - limit Qualcomm TLP size to 2K (hardware issue) (Srinivas Kandagatla)
    
      - support Tegra MSI 64-bit addressing (Thierry Reding)
    
      - use Rockchip normal (not privileged) register bank (Shawn Lin)
    
      - add HiSilicon Kirin SoC PCIe controller driver (Xiaowei Song)
    
      - add Sigma Designs Tango SMP8759 PCIe controller driver (Marc
        Gonzalez)
    
      - add MediaTek PCIe host controller support (Ryder Lee)
    
      - add Qualcomm IPQ4019 support (John Crispin)
    
      - add HyperV vPCI protocol v1.2 support (Jork Loeser)
    
      - add i.MX6 regulator support (Quentin Schulz)
    
    * tag 'pci-v4.13-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (113 commits)
      PCI: tango: Add Sigma Designs Tango SMP8759 PCIe host bridge support
      PCI: Add DT binding for Sigma Designs Tango PCIe controller
      PCI: rockchip: Use normal register bank for config accessors
      dt-bindings: PCI: Add documentation for MediaTek PCIe
      PCI: Remove __pci_dev_reset() and pci_dev_reset()
      PCI: Split ->reset_notify() method into ->reset_prepare() and ->reset_done()
      PCI: xilinx: Make of_device_ids const
      PCI: xilinx-nwl: Modify IRQ chip for legacy interrupts
      PCI: vmd: Move SRCU cleanup after bus, child device removal
      PCI: vmd: Correct comment: VMD domains start at 0x10000, not 0x1000
      PCI: versatile: Add local struct device pointers
      PCI: tegra: Do not allocate MSI target memory
      PCI: tegra: Support MSI 64-bit addressing
      PCI: rockchip: Use local struct device pointer consistently
      PCI: rockchip: Check for clk_prepare_enable() errors during resume
      MAINTAINERS: Remove Wenrui Li as Rockchip PCIe driver maintainer
      PCI: rockchip: Configure RC's MPS setting
      PCI: rockchip: Reconfigure configuration space header type
      PCI: rockchip: Split out rockchip_pcie_cfg_configuration_accesses()
      PCI: rockchip: Move configuration accesses into rockchip_pcie_cfg_atu()
      ...

commit c80081b9209713e0fe86d3def395a9fc66503c58
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Thu Jul 6 14:29:04 2017 +0200

    genirq: Allow to pass the IRQF_TIMER flag with percpu irq request
    
    The irq timings infrastructure tracks when interrupts occur in order to
    statistically predict te next interrupt event.
    
    There is no point to track timer interrupts and try to predict them because
    the next expiration time is already known. This can be avoided via the
    IRQF_TIMER flag which is passed by timer drivers in request_irq(). It marks
    the interrupt as timer based which alloes to ignore these interrupts in the
    timings code.
    
    Per CPU interrupts which are requested via request_percpu_+irq() have no
    flag argument, so marking per cpu timer interrupts is not possible and they
    get tracked pointlessly.
    
    Add __request_percpu_irq() as a variant of request_percpu_irq() with a
    flags argument and make request_percpu_irq() an inline wrapper passing
    flags = 0.
    
    The flag parameter is restricted to IRQF_TIMER as all other IRQF_ flags
    make no sense for per cpu interrupts.
    
    The next step is to convert all existing users of request_percpu_irq() and
    then remove the wrapper and the underscores.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: peterz@infradead.org
    Cc: nicolas.pitre@linaro.org
    Cc: vincent.guittot@linaro.org
    Cc: rafael@kernel.org
    Link: http://lkml.kernel.org/r/1499344144-3964-1-git-send-email-daniel.lezcano@linaro.org

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 37f8e354f564..5ac6e238555e 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -152,8 +152,17 @@ request_any_context_irq(unsigned int irq, irq_handler_t handler,
 			unsigned long flags, const char *name, void *dev_id);
 
 extern int __must_check
+__request_percpu_irq(unsigned int irq, irq_handler_t handler,
+		     unsigned long flags, const char *devname,
+		     void __percpu *percpu_dev_id);
+
+static inline int __must_check
 request_percpu_irq(unsigned int irq, irq_handler_t handler,
-		   const char *devname, void __percpu *percpu_dev_id);
+		   const char *devname, void __percpu *percpu_dev_id)
+{
+	return __request_percpu_irq(irq, handler, 0,
+				    devname, percpu_dev_id);
+}
 
 extern const void *free_irq(unsigned int, void *);
 extern void free_percpu_irq(unsigned int, void __percpu *);

commit e1c921495534002d727b15a76a2f8c20b6b108b5
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri Jun 23 16:11:08 2017 +0200

    genirq/timings: Add infrastructure for estimating the next interrupt arrival time
    
    An interrupt behaves with a burst of activity with periodic interval of time
    followed by one or two peaks of longer interval.
    
    As the time intervals are periodic, statistically speaking they follow a normal
    distribution and each interrupts can be tracked individually.
    
    Add a mechanism to compute the statistics on all interrupts, except the
    timers which are deterministic from a prediction point of view, as their
    expiry time is known.
    
    The goal is to extract the periodicity for each interrupt, with the last
    timestamp and sum them, so the next event can be predicted to a certain
    extent.
    
    Taking the earliest prediction gives the expected wakeup on the system
    (assuming a timer won't expire before).
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Nicolas Pitre <nicolas.pitre@linaro.org>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Hannes Reinecke <hare@suse.com>
    Cc: Vincent Guittot <vincent.guittot@linaro.org>
    Cc: "Rafael J . Wysocki" <rafael@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Link: http://lkml.kernel.org/r/1498227072-5980-2-git-send-email-daniel.lezcano@linaro.org

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 9f617238a2f7..37f8e354f564 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -706,6 +706,7 @@ static inline void init_irq_proc(void)
 #ifdef CONFIG_IRQ_TIMINGS
 void irq_timings_enable(void);
 void irq_timings_disable(void);
+u64 irq_timings_next_event(u64 now);
 #endif
 
 struct seq_file;

commit b2d3d61adb7b73cfe5f82404f7a130a76fc64232
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri Jun 23 16:11:07 2017 +0200

    genirq/timings: Add infrastructure to track the interrupt timings
    
    The interrupt framework gives a lot of information about each interrupt. It
    does not keep track of when those interrupts occur though, which is a
    prerequisite for estimating the next interrupt arrival for power management
    purposes.
    
    Add a mechanism to record the timestamp for each interrupt occurrences in a
    per-CPU circular buffer to help with the prediction of the next occurrence
    using a statistical model.
    
    Each CPU can store up to IRQ_TIMINGS_SIZE events <irq, timestamp>, the
    current value of IRQ_TIMINGS_SIZE is 32.
    
    Each event is encoded into a single u64, where the high 48 bits are used
    for the timestamp and the low 16 bits are for the irq number.
    
    A static key is introduced so when the irq prediction is switched off at
    runtime, the overhead is near to zero.
    
    It results in most of the code in internals.h for inline reasons and a very
    few in the new file timings.c. The latter will contain more in the next patch
    which will provide the statistical model for the next event prediction.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Hannes Reinecke <hare@suse.com>
    Cc: Vincent Guittot <vincent.guittot@linaro.org>
    Cc: "Rafael J . Wysocki" <rafael@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Link: http://lkml.kernel.org/r/1498227072-5980-1-git-send-email-daniel.lezcano@linaro.org

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index a6fba4804672..9f617238a2f7 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -703,6 +703,11 @@ static inline void init_irq_proc(void)
 }
 #endif
 
+#ifdef CONFIG_IRQ_TIMINGS
+void irq_timings_enable(void);
+void irq_timings_disable(void);
+#endif
+
 struct seq_file;
 int show_interrupts(struct seq_file *p, void *v);
 int arch_show_interrupts(struct seq_file *p, int prec);

commit 6f9a22bc5775d231ab8fbe2c2f3c88e45e3e7c28
Author: Michael Hernandez <michael.hernandez@cavium.com>
Date:   Thu May 18 10:47:47 2017 -0700

    PCI/MSI: Ignore affinity if pre/post vector count is more than min_vecs
    
    min_vecs is the minimum amount of vectors needed to operate in MSI-X mode
    which may just include the vectors that don't need affinity.
    
    Disabling affinity settings causes the qla2xxx driver scsi_add_host() to fail
    when blk_mq is enabled as the blk_mq_pci_map_queues() expects affinity masks
    on each vector.
    
    Fixes: dfef358bd1be ("PCI/MSI: Don't apply affinity if there aren't enough vectors left")
    Signed-off-by: Michael Hernandez <michael.hernandez@cavium.com>
    Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: stable@vger.kernel.org      # v4.10+

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index a6fba4804672..0991f973f8ca 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -291,7 +291,7 @@ extern int
 irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify);
 
 struct cpumask *irq_create_affinity_masks(int nvec, const struct irq_affinity *affd);
-int irq_calc_affinity_vectors(int maxvec, const struct irq_affinity *affd);
+int irq_calc_affinity_vectors(int minvec, int maxvec, const struct irq_affinity *affd);
 
 #else /* CONFIG_SMP */
 
@@ -331,7 +331,7 @@ irq_create_affinity_masks(int nvec, const struct irq_affinity *affd)
 }
 
 static inline int
-irq_calc_affinity_vectors(int maxvec, const struct irq_affinity *affd)
+irq_calc_affinity_vectors(int minvec, int maxvec, const struct irq_affinity *affd)
 {
 	return maxvec;
 }

commit 25ce4be72411867e0471908ee9319599035cc624
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Apr 13 09:06:41 2017 +0200

    genirq: Return the IRQ name from free_irq()
    
    This allows callers to get back at them instead of having to store it in
    another variable.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 53144e78a369..a6fba4804672 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -155,7 +155,7 @@ extern int __must_check
 request_percpu_irq(unsigned int irq, irq_handler_t handler,
 		   const char *devname, void __percpu *percpu_dev_id);
 
-extern void free_irq(unsigned int, void *);
+extern const void *free_irq(unsigned int, void *);
 extern void free_percpu_irq(unsigned int, void __percpu *);
 
 struct device;

commit 67c93c218dc5d1b45d547771f1fdb44a381e1faf
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 8 17:15:03 2016 -0800

    genirq/affinity: Handle pre/post vectors in irq_create_affinity_masks()
    
    Only calculate the affinity for the main I/O vectors, and skip the
    pre or post vectors specified by struct irq_affinity.
    
    Also remove the irq_affinity cpumask argument that has never been used.
    If we ever need it in the future we can pass it through struct
    irq_affinity.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Jens Axboe <axboe@kernel.dk>
    Cc: linux-block@vger.kernel.org
    Cc: linux-pci@vger.kernel.org
    Link: http://lkml.kernel.org/r/1478654107-7384-4-git-send-email-hch@lst.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 9081f23bc0ff..53144e78a369 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -290,7 +290,7 @@ extern int irq_set_affinity_hint(unsigned int irq, const struct cpumask *m);
 extern int
 irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify);
 
-struct cpumask *irq_create_affinity_masks(const struct cpumask *affinity, int nvec);
+struct cpumask *irq_create_affinity_masks(int nvec, const struct irq_affinity *affd);
 int irq_calc_affinity_vectors(int maxvec, const struct irq_affinity *affd);
 
 #else /* CONFIG_SMP */
@@ -325,7 +325,7 @@ irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)
 }
 
 static inline struct cpumask *
-irq_create_affinity_masks(const struct cpumask *affinity, int nvec)
+irq_create_affinity_masks(int nvec, const struct irq_affinity *affd)
 {
 	return NULL;
 }

commit 212bd846223c718b6577d4df16fd8d05a55ad914
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 8 17:15:02 2016 -0800

    genirq/affinity: Handle pre/post vectors in irq_calc_affinity_vectors()
    
    Only calculate the affinity for the main I/O vectors, and skip the pre or
    post vectors specified by struct irq_affinity.
    
    Also remove the irq_affinity cpumask argument that has never been used.  If
    we ever need it in the future we can pass it through struct irq_affinity.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Jens Axboe <axboe@kernel.dk>
    Cc: linux-block@vger.kernel.org
    Cc: linux-pci@vger.kernel.org
    Link: http://lkml.kernel.org/r/1478654107-7384-3-git-send-email-hch@lst.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 6b5268688a81..9081f23bc0ff 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -291,7 +291,7 @@ extern int
 irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify);
 
 struct cpumask *irq_create_affinity_masks(const struct cpumask *affinity, int nvec);
-int irq_calc_affinity_vectors(const struct cpumask *affinity, int maxvec);
+int irq_calc_affinity_vectors(int maxvec, const struct irq_affinity *affd);
 
 #else /* CONFIG_SMP */
 
@@ -331,7 +331,7 @@ irq_create_affinity_masks(const struct cpumask *affinity, int nvec)
 }
 
 static inline int
-irq_calc_affinity_vectors(const struct cpumask *affinity, int maxvec)
+irq_calc_affinity_vectors(int maxvec, const struct irq_affinity *affd)
 {
 	return maxvec;
 }

commit 20e407e195b29a4f5a18d713a61f54a75f992bd5
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 8 17:15:01 2016 -0800

    genirq/affinity: Introduce struct irq_affinity
    
    Some drivers (various network and RDMA adapter for example) have a MSI-X
    vector layout where most of the vectors are used for I/O queues and should
    have CPU affinity assigned to them, but some (usually 1 but sometimes more)
    at the beginning or end are used for low-performance admin or configuration
    work and should not have any explicit affinity assigned to them.
    
    Add a new irq_affinity structure, which will be passed through a variant of
    pci_irq_alloc_vectors that allows to specify these requirements (and is
    extensible to any future quirks in that area) so that the core IRQ affinity
    algorithm can take this quirks into account.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Jens Axboe <axboe@kernel.dk>
    Cc: linux-block@vger.kernel.org
    Cc: linux-pci@vger.kernel.org
    Link: http://lkml.kernel.org/r/1478654107-7384-2-git-send-email-hch@lst.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 72f0721f75e7..6b5268688a81 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -232,6 +232,18 @@ struct irq_affinity_notify {
 	void (*release)(struct kref *ref);
 };
 
+/**
+ * struct irq_affinity - Description for automatic irq affinity assignements
+ * @pre_vectors:	Don't apply affinity to @pre_vectors at beginning of
+ *			the MSI(-X) vector space
+ * @post_vectors:	Don't apply affinity to @post_vectors at end of
+ *			the MSI(-X) vector space
+ */
+struct irq_affinity {
+	int	pre_vectors;
+	int	post_vectors;
+};
+
 #if defined(CONFIG_SMP)
 
 extern cpumask_var_t irq_default_affinity;

commit 44082fd6702fb12020967fd375f8bf6dd7c111bf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 14 16:18:50 2016 +0200

    genirq/affinity: Remove old irq spread infrastructure
    
    No more users.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: axboe@fb.com
    Cc: keith.busch@intel.com
    Cc: agordeev@redhat.com
    Cc: linux-block@vger.kernel.org
    Link: http://lkml.kernel.org/r/1473862739-15032-5-git-send-email-hch@lst.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 4e59d122cad9..72f0721f75e7 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -278,7 +278,6 @@ extern int irq_set_affinity_hint(unsigned int irq, const struct cpumask *m);
 extern int
 irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify);
 
-struct cpumask *irq_create_affinity_mask(unsigned int *nr_vecs);
 struct cpumask *irq_create_affinity_masks(const struct cpumask *affinity, int nvec);
 int irq_calc_affinity_vectors(const struct cpumask *affinity, int maxvec);
 
@@ -313,12 +312,6 @@ irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)
 	return 0;
 }
 
-static inline struct cpumask *irq_create_affinity_mask(unsigned int *nr_vecs)
-{
-	*nr_vecs = 1;
-	return NULL;
-}
-
 static inline struct cpumask *
 irq_create_affinity_masks(const struct cpumask *affinity, int nvec)
 {

commit 34c3d9819fda464be4f1bec59b63353814f76c73
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 14 16:18:48 2016 +0200

    genirq/affinity: Provide smarter irq spreading infrastructure
    
    The current irq spreading infrastructure is just looking at a cpumask and
    tries to spread the interrupts over the mask. Thats suboptimal as it does
    not take numa nodes into account.
    
    Change the logic so the interrupts are spread across numa nodes and inside
    the nodes. If there are more cpus than vectors per node, then we set the
    affinity to several cpus. If HT siblings are available we take that into
    account and try to set all siblings to a single vector.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: axboe@fb.com
    Cc: keith.busch@intel.com
    Cc: agordeev@redhat.com
    Cc: linux-block@vger.kernel.org
    Link: http://lkml.kernel.org/r/1473862739-15032-3-git-send-email-hch@lst.de

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index b6683f0ffc9f..4e59d122cad9 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -279,6 +279,8 @@ extern int
 irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify);
 
 struct cpumask *irq_create_affinity_mask(unsigned int *nr_vecs);
+struct cpumask *irq_create_affinity_masks(const struct cpumask *affinity, int nvec);
+int irq_calc_affinity_vectors(const struct cpumask *affinity, int maxvec);
 
 #else /* CONFIG_SMP */
 
@@ -316,6 +318,19 @@ static inline struct cpumask *irq_create_affinity_mask(unsigned int *nr_vecs)
 	*nr_vecs = 1;
 	return NULL;
 }
+
+static inline struct cpumask *
+irq_create_affinity_masks(const struct cpumask *affinity, int nvec)
+{
+	return NULL;
+}
+
+static inline int
+irq_calc_affinity_vectors(const struct cpumask *affinity, int maxvec)
+{
+	return maxvec;
+}
+
 #endif /* CONFIG_SMP */
 
 /*

commit 5e385a6ef31fbbf2acbda770aecc2bc2ff933d17
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jul 4 17:39:27 2016 +0900

    genirq: Add a helper to spread an affinity mask for MSI/MSI-X vectors
    
    This is lifted from the blk-mq code and adopted to use the affinity mask
    concept just introduced in the irq handling code.  It tries to keep the
    algorithm the same as the one current used by blk-mq, but improvements
    like assining vectors on a per-node basis instead of just per sibling
    are possible with this simple move and refactoring.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: linux-block@vger.kernel.org
    Cc: linux-pci@vger.kernel.org
    Cc: linux-nvme@lists.infradead.org
    Cc: axboe@fb.com
    Cc: agordeev@redhat.com
    Link: http://lkml.kernel.org/r/1467621574-8277-7-git-send-email-hch@lst.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 9fcabeb07787..b6683f0ffc9f 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -278,6 +278,8 @@ extern int irq_set_affinity_hint(unsigned int irq, const struct cpumask *m);
 extern int
 irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify);
 
+struct cpumask *irq_create_affinity_mask(unsigned int *nr_vecs);
+
 #else /* CONFIG_SMP */
 
 static inline int irq_set_affinity(unsigned int irq, const struct cpumask *m)
@@ -308,6 +310,12 @@ irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)
 {
 	return 0;
 }
+
+static inline struct cpumask *irq_create_affinity_mask(unsigned int *nr_vecs)
+{
+	*nr_vecs = 1;
+	return NULL;
+}
 #endif /* CONFIG_SMP */
 
 /*

commit be7635e7287e0e8013af3c89a6354a9e0182594c
Author: Alexander Potapenko <glider@google.com>
Date:   Fri Mar 25 14:22:05 2016 -0700

    arch, ftrace: for KASAN put hard/soft IRQ entries into separate sections
    
    KASAN needs to know whether the allocation happens in an IRQ handler.
    This lets us strip everything below the IRQ entry point to reduce the
    number of unique stack traces needed to be stored.
    
    Move the definition of __irq_entry to <linux/interrupt.h> so that the
    users don't need to pull in <linux/ftrace.h>.  Also introduce the
    __softirq_entry macro which is similar to __irq_entry, but puts the
    corresponding functions to the .softirqentry.text section.
    
    Signed-off-by: Alexander Potapenko <glider@google.com>
    Acked-by: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Lameter <cl@linux.com>
    Cc: Pekka Enberg <penberg@kernel.org>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
    Cc: Andrey Konovalov <adech.fo@gmail.com>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Cc: Andrey Ryabinin <ryabinin.a.a@gmail.com>
    Cc: Konstantin Serebryany <kcc@google.com>
    Cc: Dmitry Chernenkov <dmitryc@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 358076eda364..9fcabeb07787 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -683,4 +683,24 @@ extern int early_irq_init(void);
 extern int arch_probe_nr_irqs(void);
 extern int arch_early_irq_init(void);
 
+#if defined(CONFIG_FUNCTION_GRAPH_TRACER) || defined(CONFIG_KASAN)
+/*
+ * We want to know which function is an entrypoint of a hardirq or a softirq.
+ */
+#define __irq_entry		 __attribute__((__section__(".irqentry.text")))
+#define __softirq_entry  \
+	__attribute__((__section__(".softirqentry.text")))
+
+/* Limits of hardirq entrypoints */
+extern char __irqentry_text_start[];
+extern char __irqentry_text_end[];
+/* Limits of softirq entrypoints */
+extern char __softirqentry_text_start[];
+extern char __softirqentry_text_end[];
+
+#else
+#define __irq_entry
+#define __softirq_entry
+#endif
+
 #endif

commit e237a5518425155faa508a087f28269f58074b92
Author: Chen Fan <chen.fan.fnst@cn.fujitsu.com>
Date:   Mon Feb 15 12:52:01 2016 +0800

    x86/ACPI/PCI: Recognize that Interrupt Line 255 means "not connected"
    
    Per the x86-specific footnote to PCI spec r3.0, sec 6.2.4, the value 255 in
    the Interrupt Line register means "unknown" or "no connection."
    Previously, when we couldn't derive an IRQ from the _PRT, we fell back to
    using the value from Interrupt Line as an IRQ.  It's questionable whether
    we should do that at all, but the spec clearly suggests we shouldn't do it
    for the value 255 on x86.
    
    Calling request_irq() with IRQ 255 may succeed, but the driver won't
    receive any interrupts.  Or, if IRQ 255 is shared with another device, it
    may succeed, and the driver's ISR will be called at random times when the
    *other* device interrupts.  Or it may fail if another device is using IRQ
    255 with incompatible flags.  What we *want* is for request_irq() to fail
    predictably so the driver can fall back to polling.
    
    On x86, assume 255 in the Interrupt Line means the INTx line is not
    connected.  In that case, set dev->irq to IRQ_NOTCONNECTED so request_irq()
    will fail gracefully with -ENOTCONN.
    
    We found this problem on a system where Secure Boot firmware assigned
    Interrupt Line 255 to an i801_smbus device and another device was already
    using MSI-X IRQ 255.  This was in v3.10, where i801_probe() fails if
    request_irq() fails:
    
      i801_smbus 0000:00:1f.3: enabling device (0140 -> 0143)
      i801_smbus 0000:00:1f.3: can't derive routing for PCI INT C
      i801_smbus 0000:00:1f.3: PCI INT C: no GSI
      genirq: Flags mismatch irq 255. 00000080 (i801_smbus) vs. 00000000 (megasa)
      CPU: 0 PID: 2487 Comm: kworker/0:1 Not tainted 3.10.0-229.el7.x86_64 #1
      Hardware name: FUJITSU PRIMEQUEST 2800E2/D3736, BIOS PRIMEQUEST 2000 Serie5
      Call Trace:
        dump_stack+0x19/0x1b
        __setup_irq+0x54a/0x570
        request_threaded_irq+0xcc/0x170
        i801_probe+0x32f/0x508 [i2c_i801]
        local_pci_probe+0x45/0xa0
      i801_smbus 0000:00:1f.3: Failed to allocate irq 255: -16
      i801_smbus: probe of 0000:00:1f.3 failed with error -16
    
    After aeb8a3d16ae0 ("i2c: i801: Check if interrupts are disabled"),
    i801_probe() will fall back to polling if request_irq() fails.  But we
    still need this patch because request_irq() may succeed or fail depending
    on other devices in the system.  If request_irq() fails, i801_smbus will
    work by falling back to polling, but if it succeeds, i801_smbus won't work
    because it expects interrupts that it may not receive.
    
    Signed-off-by: Chen Fan <chen.fan.fnst@cn.fujitsu.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 0e95fcc75b2a..358076eda364 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -125,6 +125,16 @@ struct irqaction {
 
 extern irqreturn_t no_action(int cpl, void *dev_id);
 
+/*
+ * If a (PCI) device interrupt is not connected we set dev->irq to
+ * IRQ_NOTCONNECTED. This causes request_irq() to fail with -ENOTCONN, so we
+ * can distingiush that case from other error returns.
+ *
+ * 0x80000000 is guaranteed to be outside the available range of interrupts
+ * and easy to distinguish from other possible incorrect values.
+ */
+#define IRQ_NOTCONNECTED	(1U << 31)
+
 extern int __must_check
 request_threaded_irq(unsigned int irq, irq_handler_t handler,
 		     irq_handler_t thread_fn,

commit 048ccca8c1c8f583deec3367d7df521bb1f542ae
Merge: b3e27d5d4a29 34356f64ac0d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 23 18:45:06 2016 -0800

    Merge tag 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dledford/rdma
    
    Pull rdma updates from Doug Ledford:
     "Initial roundup of 4.5 merge window patches
    
       - Remove usage of ib_query_device and instead store attributes in
         ib_device struct
    
       - Move iopoll out of block and into lib, rename to irqpoll, and use
         in several places in the rdma stack as our new completion queue
         polling library mechanism.  Update the other block drivers that
         already used iopoll to use the new mechanism too.
    
       - Replace the per-entry GID table locks with a single GID table lock
    
       - IPoIB multicast cleanup
    
       - Cleanups to the IB MR facility
    
       - Add support for 64bit extended IB counters
    
       - Fix for netlink oops while parsing RDMA nl messages
    
       - RoCEv2 support for the core IB code
    
       - mlx4 RoCEv2 support
    
       - mlx5 RoCEv2 support
    
       - Cross Channel support for mlx5
    
       - Timestamp support for mlx5
    
       - Atomic support for mlx5
    
       - Raw QP support for mlx5
    
       - MAINTAINERS update for mlx4/mlx5
    
       - Misc ocrdma, qib, nes, usNIC, cxgb3, cxgb4, mlx4, mlx5 updates
    
       - Add support for remote invalidate to the iSER driver (pushed
         through the RDMA tree due to dependencies, acknowledged by nab)
    
       - Update to NFSoRDMA (pushed through the RDMA tree due to
         dependencies, acknowledged by Bruce)"
    
    * tag 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dledford/rdma: (169 commits)
      IB/mlx5: Unify CQ create flags check
      IB/mlx5: Expose Raw Packet QP to user space consumers
      {IB, net}/mlx5: Move the modify QP operation table to mlx5_ib
      IB/mlx5: Support setting Ethernet priority for Raw Packet QPs
      IB/mlx5: Add Raw Packet QP query functionality
      IB/mlx5: Add create and destroy functionality for Raw Packet QP
      IB/mlx5: Refactor mlx5_ib_qp to accommodate other QP types
      IB/mlx5: Allocate a Transport Domain for each ucontext
      net/mlx5_core: Warn on unsupported events of QP/RQ/SQ
      net/mlx5_core: Add RQ and SQ event handling
      net/mlx5_core: Export transport objects
      IB/mlx5: Expose CQE version to user-space
      IB/mlx5: Add CQE version 1 support to user QPs and SRQs
      IB/mlx5: Fix data validation in mlx5_ib_alloc_ucontext
      IB/sa: Fix netlink local service GFP crash
      IB/srpt: Remove redundant wc array
      IB/qib: Improve ipoib UD performance
      IB/mlx4: Advertise RoCE v2 support
      IB/mlx4: Create and use another QP1 for RoCEv2
      IB/mlx4: Enable send of RoCE QP1 packets with IP/UDP headers
      ...

commit 511cbce2ff8b9d322077909ee90c5d4b67b29b75
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 10 14:56:14 2015 +0100

    irq_poll: make blk-iopoll available outside the block layer
    
    The new name is irq_poll as iopoll is already taken.  Better suggestions
    welcome.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <bart.vanassche@sandisk.com>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index ad16809c8596..7ff98c23199a 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -412,7 +412,7 @@ enum
 	NET_TX_SOFTIRQ,
 	NET_RX_SOFTIRQ,
 	BLOCK_SOFTIRQ,
-	BLOCK_IOPOLL_SOFTIRQ,
+	IRQ_POLL_SOFTIRQ,
 	TASKLET_SOFTIRQ,
 	SCHED_SOFTIRQ,
 	HRTIMER_SOFTIRQ, /* Unused, but kept as tools rely on the

commit f0cb32207307e9d7b3ee8117078b7a37f8d0166e
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Tue Oct 20 15:23:51 2015 +0200

    genirq: Implement irq_percpu_is_enabled()
    
    Certain interrupt controller drivers have a register set that does not
    make it easy to save/restore the mask of enabled/disabled interrupts
    at suspend/resume time. At resume time, such drivers rely on the core
    kernel irq subsystem to tell whether such or such interrupt is enabled
    or not, in order to restore the proper state in the interrupt
    controller register.
    
    While the irqd_irq_disabled() provides the relevant information for
    global interrupts, there is no similar function to query the
    enabled/disabled state of a per-CPU interrupt.
    
    Therefore, this commit complements the percpu_irq API with an
    irq_percpu_is_enabled() function.
    
    [ tglx: Simplified the implementation and added kerneldoc ]
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Tawfik Bayouk <tawfik@marvell.com>
    Cc: Nadav Haklai <nadavh@marvell.com>
    Cc: Lior Amsalem <alior@marvell.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Cc: Gregory Clement <gregory.clement@free-electrons.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Link: http://lkml.kernel.org/r/1445347435-2333-2-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index ad16809c8596..cb30edbfe9fc 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -195,6 +195,7 @@ extern void disable_irq(unsigned int irq);
 extern void disable_percpu_irq(unsigned int irq);
 extern void enable_irq(unsigned int irq);
 extern void enable_percpu_irq(unsigned int irq, unsigned int type);
+extern bool irq_percpu_is_enabled(unsigned int irq);
 extern void irq_wake_thread(unsigned int irq, void *dev_id);
 
 /* The following three functions are for the core kernel use only. */

commit 2a1d3ab8986d1b2f598ffc42351d94166fa0f022
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 21 11:01:10 2015 +0200

    genirq: Handle force threading of irqs with primary and thread handler
    
    Force threading of interrupts does not really deal with interrupts
    which are requested with a primary and a threaded handler. The current
    policy is to leave them alone and let the primary handler run in
    interrupt context, but we set the ONESHOT flag for those interrupts as
    well.
    
    Kohji Okuno debugged a problem with the SDHCI driver where the
    interrupt thread waits for a hardware interrupt to trigger, which can't
    work well because the hardware interrupt is masked due to the ONESHOT
    flag being set. He proposed to set the ONESHOT flag only if the
    interrupt does not provide a thread handler.
    
    Though that does not work either because these interrupts can be
    shared. So the other interrupt would rightfully get the ONESHOT flag
    set and therefor the same situation would happen again.
    
    To deal with this proper, we need to force thread the primary handler
    of such interrupts as well. That means that the primary interrupt
    handler is treated as any other primary interrupt handler which is not
    marked IRQF_NO_THREAD. The threaded handler becomes a separate thread
    so the SDHCI flow logic can be handled gracefully.
    
    The same issue was reported against 4.1-rt.
    
    Reported-and-tested-by: Kohji Okuno <okuno.kohji@jp.panasonic.com>
    Reported-By: Michal Smucr <msmucr@gmail.com>
    Reported-and-tested-by: Nathan Sullivan <nathan.sullivan@ni.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.11.1509211058080.5606@nanos
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index be7e75c945e9..ad16809c8596 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -102,6 +102,7 @@ typedef irqreturn_t (*irq_handler_t)(int, void *);
  * @flags:	flags (see IRQF_* above)
  * @thread_fn:	interrupt handler function for threaded interrupts
  * @thread:	thread pointer for threaded interrupts
+ * @secondary:	pointer to secondary irqaction (force threading)
  * @thread_flags:	flags related to @thread
  * @thread_mask:	bitmask for keeping track of @thread activity
  * @dir:	pointer to the proc/irq/NN/name entry
@@ -113,6 +114,7 @@ struct irqaction {
 	struct irqaction	*next;
 	irq_handler_t		thread_fn;
 	struct task_struct	*thread;
+	struct irqaction	*secondary;
 	unsigned int		irq;
 	unsigned int		flags;
 	unsigned long		thread_flags;

commit 61699e13072a89880aa584dcc64c6da465fb2ccc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Apr 14 21:09:23 2015 +0000

    hrtimer: Remove hrtimer_start() return value
    
    No user was ever interested whether the timer was active or not when
    it was started. All abusers of the return value are gone, so get rid
    of it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Link: http://lkml.kernel.org/r/20150414203503.483556394@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 6bf15a66bce7..be7e75c945e9 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -593,10 +593,10 @@ tasklet_hrtimer_init(struct tasklet_hrtimer *ttimer,
 		     clockid_t which_clock, enum hrtimer_mode mode);
 
 static inline
-int tasklet_hrtimer_start(struct tasklet_hrtimer *ttimer, ktime_t time,
-			  const enum hrtimer_mode mode)
+void tasklet_hrtimer_start(struct tasklet_hrtimer *ttimer, ktime_t time,
+			   const enum hrtimer_mode mode)
 {
-	return hrtimer_start(&ttimer->timer, time, mode);
+	hrtimer_start(&ttimer->timer, time, mode);
 }
 
 static inline

commit c6eb3f70d4482806dc2d3e1e3c7736f497b1d418
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Apr 14 21:08:51 2015 +0000

    hrtimer: Get rid of hrtimer softirq
    
    hrtimer softirq is a leftover from the initial implementation and
    serves only the purpose to handle the enqueueing of already expired
    timers in the high resolution timer mode. We discussed whether we
    change the return value and force all start sites to handle that the
    timer is already expired, but that would be a Herculean task and I'm
    not sure whether its a good idea to enforce that handling on
    everyone.
    
    A simpler solution is to enforce a timer interrupt instead of raising
    and scheduling a softirq. Just use the existing infrastructure to do
    so and remove all the softirq leftovers.
    
    The HRTIMER softirq enum is now unused, but kept around because trace
    parsers rely on the existing numbering.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Link: http://lkml.kernel.org/r/20150414203501.840834708@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 950ae4501826..6bf15a66bce7 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -413,7 +413,8 @@ enum
 	BLOCK_IOPOLL_SOFTIRQ,
 	TASKLET_SOFTIRQ,
 	SCHED_SOFTIRQ,
-	HRTIMER_SOFTIRQ,
+	HRTIMER_SOFTIRQ, /* Unused, but kept as tools rely on the
+			    numbering. Sigh! */
 	RCU_SOFTIRQ,    /* Preferable RCU should always be the last softirq */
 
 	NR_SOFTIRQS

commit 1b7047edfcfb257f69e306c9afbab150cb987717
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Wed Mar 18 11:01:22 2015 +0000

    genirq: Allow the irqchip state of an IRQ to be save/restored
    
    There is a number of cases where a kernel subsystem may want to
    introspect the state of an interrupt at the irqchip level:
    
    - When a peripheral is shared between virtual machines,
      its interrupt state becomes part of the guest's state,
      and must be switched accordingly. KVM on arm/arm64 requires
      this for its guest-visible timer
    - Some GPIO controllers seem to require peeking into the
      interrupt controller they are connected to to report
      their internal state
    
    This seem to be a pattern that is common enough for the core code
    to try and support this without too many horrible hacks. Introduce
    a pair of accessors (irq_get_irqchip_state/irq_set_irqchip_state)
    to retrieve the bits that can be of interest to another subsystem:
    pending, active, and masked.
    
    - irq_get_irqchip_state returns the state of the interrupt according
      to a parameter set to IRQCHIP_STATE_PENDING, IRQCHIP_STATE_ACTIVE,
      IRQCHIP_STATE_MASKED or IRQCHIP_STATE_LINE_LEVEL.
    - irq_set_irqchip_state similarly sets the state of the interrupt.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@sonymobile.com>
    Tested-by: Bjorn Andersson <bjorn.andersson@sonymobile.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Abhijeet Dharmapurikar <adharmap@codeaurora.org>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Phong Vo <pvo@apm.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Tin Huynh <tnhuynh@apm.com>
    Cc: Y Vo <yvo@apm.com>
    Cc: Toan Le <toanle@apm.com>
    Cc: Bjorn Andersson <bjorn@kryo.se>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Link: http://lkml.kernel.org/r/1426676484-21812-2-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 150dde04cf4f..950ae4501826 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -361,6 +361,20 @@ static inline int disable_irq_wake(unsigned int irq)
 	return irq_set_irq_wake(irq, 0);
 }
 
+/*
+ * irq_get_irqchip_state/irq_set_irqchip_state specific flags
+ */
+enum irqchip_irq_state {
+	IRQCHIP_STATE_PENDING,		/* Is interrupt pending? */
+	IRQCHIP_STATE_ACTIVE,		/* Is interrupt in progress? */
+	IRQCHIP_STATE_MASKED,		/* Is interrupt masked? */
+	IRQCHIP_STATE_LINE_LEVEL,	/* Is IRQ line high? */
+};
+
+extern int irq_get_irqchip_state(unsigned int irq, enum irqchip_irq_state which,
+				 bool *state);
+extern int irq_set_irqchip_state(unsigned int irq, enum irqchip_irq_state which,
+				 bool state);
 
 #ifdef CONFIG_IRQ_FORCED_THREADING
 extern bool force_irqthreads;

commit 462b69b1e43ceccab68a47d65b1e46520cd0fdc0
Merge: d8bf368d0631 f22e6e847115
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Apr 8 23:26:21 2015 +0200

    Merge branch 'linus' into irq/core to get the GIC updates which
    conflict with pending GIC changes.
    
    Conflicts:
            drivers/usb/isp1760/isp1760-core.c

commit d8bf368d0631d4bc2612d8bf2e4e8e74e620d0cc
Author: Valentin Rothberg <valentinrothberg@gmail.com>
Date:   Thu Mar 5 15:23:08 2015 +0100

    genirq: Remove the deprecated 'IRQF_DISABLED' request_irq() flag entirely
    
    The IRQF_DISABLED flag is a NOOP and has been scheduled for removal
    since Linux v2.6.36 by commit 6932bf37bed4 ("genirq: Remove
    IRQF_DISABLED from core code").
    
    According to commit e58aa3d2d0cc ("genirq: Run irq handlers with
    interrupts disabled"), running IRQ handlers with interrupts
    enabled can cause stack overflows when the interrupt line of the
    issuing device is still active.
    
    This patch ends the grace period for IRQF_DISABLED (i.e.,
    SA_INTERRUPT in older versions of Linux) and removes the
    definition and all remaining usages of this flag.
    
    There's still a few non-functional references left in the kernel
    source:
    
      - The bigger hunk in Documentation/scsi/ncr53c8xx.txt is removed entirely
        as IRQF_DISABLED is gone now; the usage in older kernel versions
        (including the old SA_INTERRUPT flag) should be discouraged.  The
        trouble of using IRQF_SHARED is a general problem and not specific to
        any driver.
    
      - I left the reference in Documentation/PCI/MSI-HOWTO.txt untouched since
        it has already been removed in linux-next.
    
      - All remaining references are changelogs that I suggest to keep.
    
    Signed-off-by: Valentin Rothberg <valentinrothberg@gmail.com>
    Cc: Afzal Mohammed <afzal@ti.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Brian Norris <computersforpeace@gmail.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Ewan Milne <emilne@redhat.com>
    Cc: Eyal Perry <eyalpe@mellanox.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: Hongliang Tao <taohl@lemote.com>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Keerthy <j-keerthy@ti.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Nishanth Menon <nm@ti.com>
    Cc: Paul Bolle <pebolle@tiscali.nl>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Quentin Lambert <lambert.quentin@gmail.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Sricharan R <r.sricharan@ti.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Zhou Wang <wangzhou1@hisilicon.com>
    Cc: iss_storagedev@hp.com
    Cc: linux-mips@linux-mips.org
    Cc: linux-mtd@lists.infradead.org
    Link: http://lkml.kernel.org/r/1425565425-12604-1-git-send-email-valentinrothberg@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 3bb01b9a379c..2cee1761c77d 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -39,8 +39,6 @@
  * These flags used only by the kernel as part of the
  * irq handling routines.
  *
- * IRQF_DISABLED - keep irqs disabled when calling the action handler.
- *                 DEPRECATED. This flag is a NOOP and scheduled to be removed
  * IRQF_SHARED - allow sharing the irq among several devices
  * IRQF_PROBE_SHARED - set by callers when they expect sharing mismatches to occur
  * IRQF_TIMER - Flag to mark this interrupt as timer interrupt
@@ -58,7 +56,6 @@
  * IRQF_EARLY_RESUME - Resume IRQ early during syscore instead of at device
  *                resume time.
  */
-#define IRQF_DISABLED		0x00000020
 #define IRQF_SHARED		0x00000080
 #define IRQF_PROBE_SHARED	0x00000100
 #define __IRQF_TIMER		0x00000200

commit 17f480342026e54000731acaa69bf32787ce46cb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 27 00:07:55 2015 +0100

    genirq / PM: Add flag for shared NO_SUSPEND interrupt lines
    
    It currently is required that all users of NO_SUSPEND interrupt
    lines pass the IRQF_NO_SUSPEND flag when requesting the IRQ or the
    WARN_ON_ONCE() in irq_pm_install_action() will trigger.  That is
    done to warn about situations in which unprepared interrupt handlers
    may be run unnecessarily for suspended devices and may attempt to
    access those devices by mistake.  However, it may cause drivers
    that have no technical reasons for using IRQF_NO_SUSPEND to set
    that flag just because they happen to share the interrupt line
    with something like a timer.
    
    Moreover, the generic handling of wakeup interrupts introduced by
    commit 9ce7a25849e8 (genirq: Simplify wakeup mechanism) only works
    for IRQs without any NO_SUSPEND users, so the drivers of wakeup
    devices needing to use shared NO_SUSPEND interrupt lines for
    signaling system wakeup generally have to detect wakeup in their
    interrupt handlers.  Thus if they happen to share an interrupt line
    with a NO_SUSPEND user, they also need to request that their
    interrupt handlers be run after suspend_device_irqs().
    
    In both cases the reason for using IRQF_NO_SUSPEND is not because
    the driver in question has a genuine need to run its interrupt
    handler after suspend_device_irqs(), but because it happens to
    share the line with some other NO_SUSPEND user.  Otherwise, the
    driver would do without IRQF_NO_SUSPEND just fine.
    
    To make it possible to specify that condition explicitly, introduce
    a new IRQ action handler flag for shared IRQs, IRQF_COND_SUSPEND,
    that, when set, will indicate to the IRQ core that the interrupt
    user is generally fine with suspending the IRQ, but it also can
    tolerate handler invocations after suspend_device_irqs() and, in
    particular, it is capable of detecting system wakeup and triggering
    it as appropriate from its interrupt handler.
    
    That will allow us to work around a problem with a shared timer
    interrupt line on at91 platforms.
    
    Link: http://marc.info/?l=linux-kernel&m=142252777602084&w=2
    Link: http://marc.info/?t=142252775300011&r=1&w=2
    Link: https://lkml.org/lkml/2014/12/15/552
    Reported-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: Mark Rutland <mark.rutland@arm.com>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 606771c7cac2..2e88580194f0 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -59,6 +59,10 @@
  * IRQF_NO_THREAD - Interrupt cannot be threaded
  * IRQF_EARLY_RESUME - Resume IRQ early during syscore instead of at device
  *                resume time.
+ * IRQF_COND_SUSPEND - If the IRQ is shared with a NO_SUSPEND user, execute this
+ *                interrupt handler after suspending interrupts. For system
+ *                wakeup devices users need to implement wakeup detection in
+ *                their interrupt handlers.
  */
 #define IRQF_DISABLED		0x00000020
 #define IRQF_SHARED		0x00000080
@@ -72,6 +76,7 @@
 #define IRQF_FORCE_RESUME	0x00008000
 #define IRQF_NO_THREAD		0x00010000
 #define IRQF_EARLY_RESUME	0x00020000
+#define IRQF_COND_SUSPEND	0x00040000
 
 #define IRQF_TIMER		(__IRQF_TIMER | IRQF_NO_SUSPEND | IRQF_NO_THREAD)
 

commit 737eb0301f296d55c22350c6968ff1ef51bacb5f
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Fri Feb 20 14:53:46 2015 +0000

    genirq / PM: better describe IRQF_NO_SUSPEND semantics
    
    The IRQF_NO_SUSPEND flag is intended to be used for interrupts required
    to be enabled during the suspend-resume cycle. This mostly consists of
    IPIs and timer interrupts, potentially including chained irqchip
    interrupts if these are necessary to handle timers or IPIs. If an
    interrupt does not fall into one of the aforementioned categories,
    requesting it with IRQF_NO_SUSPEND is likely incorrect.
    
    Using IRQF_NO_SUSPEND does not guarantee that the interrupt can wake the
    system from a suspended state. For an interrupt to be able to trigger a
    wakeup, it may be necessary to program various components of the system.
    In these cases it is necessary to use {enable,disabled}_irq_wake.
    
    Unfortunately, several drivers assume that IRQF_NO_SUSPEND ensures that
    an IRQ can wake up the system, and the documentation can be read
    ambiguously w.r.t. this property.
    
    This patch updates the documentation regarding IRQF_NO_SUSPEND to make
    this caveat explicit, hopefully making future misuse rarer. Cleanup of
    existing misuse will occur as part of later patch series.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index d9b05b5bf8c7..606771c7cac2 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -52,7 +52,9 @@
  * IRQF_ONESHOT - Interrupt is not reenabled after the hardirq handler finished.
  *                Used by threaded interrupts which need to keep the
  *                irq line disabled until the threaded handler has been run.
- * IRQF_NO_SUSPEND - Do not disable this IRQ during suspend
+ * IRQF_NO_SUSPEND - Do not disable this IRQ during suspend.  Does not guarantee
+ *                   that this interrupt will wake the system from a suspended
+ *                   state.  See Documentation/power/suspend-and-interrupts.txt
  * IRQF_FORCE_RESUME - Force enable it on resume even if IRQF_NO_SUSPEND is set
  * IRQF_NO_THREAD - Interrupt cannot be threaded
  * IRQF_EARLY_RESUME - Resume IRQ early during syscore instead of at device

commit 02cea3958664723a5d2236f0f0058de97c7e4693
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Thu Feb 5 14:06:23 2015 +0100

    genirq: Provide disable_hardirq()
    
    For things like netpoll there is a need to disable an interrupt from
    atomic context. Currently netpoll uses disable_irq() which will
    sleep-wait on threaded handlers and thus forced_irqthreads breaks
    things.
    
    Provide disable_hardirq(), which uses synchronize_hardirq() to only wait
    for active hardirq handlers; also change synchronize_hardirq() to
    return the status of threaded handlers.
    
    This will allow one to try-disable an interrupt from atomic context, or
    in case of request_threaded_irq() to only wait for the hardirq part.
    
    Suggested-by: Sabrina Dubroca <sd@queasysnail.net>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eyal Perry <eyalpe@mellanox.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Quentin Lambert <lambert.quentin@gmail.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Link: http://lkml.kernel.org/r/20150205130623.GH5029@twins.programming.kicks-ass.net
    [ Fixed typos and such. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index d9b05b5bf8c7..3bb01b9a379c 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -184,6 +184,7 @@ extern void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id);
 #endif
 
 extern void disable_irq_nosync(unsigned int irq);
+extern bool disable_hardirq(unsigned int irq);
 extern void disable_irq(unsigned int irq);
 extern void disable_percpu_irq(unsigned int irq);
 extern void enable_irq(unsigned int irq);

commit 7142637dd93a7e1e9f5515e6c66c7d271fa92ad2
Author: Quentin Lambert <lambert.quentin@gmail.com>
Date:   Fri Dec 12 13:36:54 2014 +0100

    linux/interrupt.h: remove the definition of unused tasklet_hi_enable
    
    Signed-off-by: Quentin Lambert <lambert.quentin@gmail.com>
    Signed-off-by: Valentin Rothberg <valentinrothberg@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 69517a24bc50..d9b05b5bf8c7 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -556,12 +556,6 @@ static inline void tasklet_enable(struct tasklet_struct *t)
 	atomic_dec(&t->count);
 }
 
-static inline void tasklet_hi_enable(struct tasklet_struct *t)
-{
-	smp_mb__before_atomic();
-	atomic_dec(&t->count);
-}
-
 extern void tasklet_kill(struct tasklet_struct *t);
 extern void tasklet_kill_immediate(struct tasklet_struct *t, unsigned int cpu);
 extern void tasklet_init(struct tasklet_struct *t,

commit 9ce7a25849e80cfb264f4995f832b932c1987e1a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Aug 29 14:00:16 2014 +0200

    genirq: Simplify wakeup mechanism
    
    Currently we suspend wakeup interrupts by lazy disabling them and
    check later whether the interrupt has fired, but that's not sufficient
    for suspend to idle as there is no way to check that once we
    transitioned into the CPU idle state.
    
    So we change the mechanism in the following way:
    
    1) Leave the wakeup interrupts enabled across suspend
    
    2) Add a check to irq_may_run() which is called at the beginning of
       each flow handler whether the interrupt is an armed wakeup source.
    
       This check is basically free as it just extends the existing check
       for IRQD_IRQ_INPROGRESS. So no new conditional in the hot path.
    
       If the IRQD_WAKEUP_ARMED flag is set, then the interrupt is
       disabled, marked as pending/suspended and the pm core is notified
       about the wakeup event.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [ rjw: syscore.c and put irq_pm_check_wakeup() into pm.c ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 698ad053d064..69517a24bc50 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -193,11 +193,6 @@ extern void irq_wake_thread(unsigned int irq, void *dev_id);
 /* The following three functions are for the core kernel use only. */
 extern void suspend_device_irqs(void);
 extern void resume_device_irqs(void);
-#ifdef CONFIG_PM_SLEEP
-extern int check_wakeup_irqs(void);
-#else
-static inline int check_wakeup_irqs(void) { return 0; }
-#endif
 
 /**
  * struct irq_affinity_notify - context for notification of IRQ affinity changes

commit d09cc3659db494aca4b3bb2393c533fb4946b794
Merge: 82e627eb5e07 c0ffa793994a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 4 15:59:13 2014 -0700

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip into next
    
    Pull core irq updates from Thomas Gleixner:
     "The irq department delivers:
    
       - Another tree wide update to get rid of the horrible create_irq
         interface along with its even more horrible variants.  That also
         gets rid of the last leftovers of the initial sparse irq hackery.
         arch/driver specific changes have been either acked or ignored.
    
       - A fix for the spurious interrupt detection logic with threaded
         interrupts.
    
       - A new ARM SoC interrupt controller
    
       - The usual pile of fixes and improvements all over the place"
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (40 commits)
      Documentation: brcmstb-l2: Add Broadcom STB Level-2 interrupt controller binding
      irqchip: brcmstb-l2: Add Broadcom Set Top Box Level-2 interrupt controller
      genirq: Improve documentation to match current implementation
      ARM: iop13xx: fix msi support with sparse IRQ
      genirq: Provide !SMP stub for irq_set_affinity_notifier()
      irqchip: armada-370-xp: Move the devicetree binding documentation
      irqchip: gic: Use mask field in GICC_IAR
      genirq: Remove dynamic_irq mess
      ia64: Use irq_init_desc
      genirq: Replace dynamic_irq_init/cleanup
      genirq: Remove irq_reserve_irq[s]
      genirq: Replace reserve_irqs in core code
      s390: Avoid call to irq_reserve_irqs()
      s390: Remove pointless arch_show_interrupts()
      s390: pci: Check return value of alloc_irq_desc() proper
      sh: intc: Remove pointless irq_reserve_irqs() invocation
      x86, irq: Remove pointless irq_reserve_irqs() call
      genirq: Make create/destroy_irq() ia64 private
      tile: Use SPARSE_IRQ
      tile: pci: Use irq_alloc/free_hwirq()
      ...

commit 776edb59317ada867dfcddde40b55648beeb0078
Merge: 59a3d4c3631e 3cf2f34e1a3d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 3 12:57:53 2014 -0700

    Merge branch 'locking-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip into next
    
    Pull core locking updates from Ingo Molnar:
     "The main changes in this cycle were:
    
       - reduced/streamlined smp_mb__*() interface that allows more usecases
         and makes the existing ones less buggy, especially in rarer
         architectures
    
       - add rwsem implementation comments
    
       - bump up lockdep limits"
    
    * 'locking-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (33 commits)
      rwsem: Add comments to explain the meaning of the rwsem's count field
      lockdep: Increase static allocations
      arch: Mass conversion of smp_mb__*()
      arch,doc: Convert smp_mb__*()
      arch,xtensa: Convert smp_mb__*()
      arch,x86: Convert smp_mb__*()
      arch,tile: Convert smp_mb__*()
      arch,sparc: Convert smp_mb__*()
      arch,sh: Convert smp_mb__*()
      arch,score: Convert smp_mb__*()
      arch,s390: Convert smp_mb__*()
      arch,powerpc: Convert smp_mb__*()
      arch,parisc: Convert smp_mb__*()
      arch,openrisc: Convert smp_mb__*()
      arch,mn10300: Convert smp_mb__*()
      arch,mips: Convert smp_mb__*()
      arch,metag: Convert smp_mb__*()
      arch,m68k: Convert smp_mb__*()
      arch,m32r: Convert smp_mb__*()
      arch,ia64: Convert smp_mb__*()
      ...

commit 1e5418c2535f4fddbbee4036750de41e16e0f7b0
Merge: d8179bc0db8d f0ba3d05c9c6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 21 11:33:09 2014 +0900

    Merge branch 'irq/for-net' into irq/core
    
    Reason: Import the change which might be pulled in from net
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit f0ba3d05c9c647ab42ed6a0dbdfdeae42bfbd6de
Author: Eyal Perry <eyalpe@mellanox.com>
Date:   Tue May 20 17:57:00 2014 +0300

    genirq: Provide !SMP stub for irq_set_affinity_notifier()
    
    Instead of requiring each consumer of the IRQ affinity notifier to have
    themselves be explicitly dependent on CONFIG_SMP, make the definition of
    struct irq_affinity_notify to exist independently of that config option
    and introduce a stub for irq_set_affinity_notifier() under non SMP
    configuration.
    
    Fixes: 2eacc23 ("net/mlx4_core: Enforce irq affinity changes
    immediatly")
    
    Signed-off-by: Eyal Perry <eyalpe@mellanox.com>
    Signed-off-by: Amir Vadai <amirv@mellanox.com>
    Cc: Ben Hutchings <bhutchings@solarflare.com>
    Cc: Yevgeny Petrilin <yevgenyp@mellanox.com>
    Cc: Or Gerlitz <ogerlitz@mellanox.com>
    Cc: David S. Miller <davem@davemloft.net>
    Link: http://lkml.kernel.org/r/1400597820-30685-1-git-send-email-amirv@mellanox.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 97ac926c78a7..3f74c0593171 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -199,6 +199,26 @@ extern int check_wakeup_irqs(void);
 static inline int check_wakeup_irqs(void) { return 0; }
 #endif
 
+/**
+ * struct irq_affinity_notify - context for notification of IRQ affinity changes
+ * @irq:		Interrupt to which notification applies
+ * @kref:		Reference count, for internal use
+ * @work:		Work item, for internal use
+ * @notify:		Function to be called on change.  This will be
+ *			called in process context.
+ * @release:		Function to be called on release.  This will be
+ *			called in process context.  Once registered, the
+ *			structure must only be freed when this function is
+ *			called or later.
+ */
+struct irq_affinity_notify {
+	unsigned int irq;
+	struct kref kref;
+	struct work_struct work;
+	void (*notify)(struct irq_affinity_notify *, const cpumask_t *mask);
+	void (*release)(struct kref *ref);
+};
+
 #if defined(CONFIG_SMP)
 
 extern cpumask_var_t irq_default_affinity;
@@ -242,26 +262,6 @@ extern int irq_select_affinity(unsigned int irq);
 
 extern int irq_set_affinity_hint(unsigned int irq, const struct cpumask *m);
 
-/**
- * struct irq_affinity_notify - context for notification of IRQ affinity changes
- * @irq:		Interrupt to which notification applies
- * @kref:		Reference count, for internal use
- * @work:		Work item, for internal use
- * @notify:		Function to be called on change.  This will be
- *			called in process context.
- * @release:		Function to be called on release.  This will be
- *			called in process context.  Once registered, the
- *			structure must only be freed when this function is
- *			called or later.
- */
-struct irq_affinity_notify {
-	unsigned int irq;
-	struct kref kref;
-	struct work_struct work;
-	void (*notify)(struct irq_affinity_notify *, const cpumask_t *mask);
-	void (*release)(struct kref *ref);
-};
-
 extern int
 irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify);
 
@@ -284,6 +284,12 @@ static inline int irq_set_affinity_hint(unsigned int irq,
 {
 	return -EINVAL;
 }
+
+static inline int
+irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)
+{
+	return 0;
+}
 #endif /* CONFIG_SMP */
 
 /*

commit 4c88d7f9b0d5fb0588c3386be62115cc2eaa8f9f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Apr 23 14:49:17 2014 +0200

    genirq: Provide irq_force_affinity fallback for non-SMP
    
    Patch 01f8fa4f01d "genirq: Allow forcing cpu affinity of interrupts" added
    an irq_force_affinity() function, and 30ccf03b4a6 "clocksource: Exynos_mct:
    Use irq_force_affinity() in cpu bringup" subsequently uses it. However, the
    driver can be used with CONFIG_SMP disabled, but the function declaration
    is only available for CONFIG_SMP, leading to this build error:
    
    drivers/clocksource/exynos_mct.c:431:3: error: implicit declaration of function 'irq_force_affinity' [-Werror=implicit-function-declaration]
       irq_force_affinity(mct_irqs[MCT_L0_IRQ + cpu], cpumask_of(cpu));
    
    This patch introduces a dummy helper function for the non-SMP case
    that always returns success, to get rid of the build error.
    Since the patches causing the problem are marked for stable backports,
    this one should be as well.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/5619084.0zmrrIUZLV@wuerfel
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 97ac926c78a7..051c85032f48 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -272,6 +272,11 @@ static inline int irq_set_affinity(unsigned int irq, const struct cpumask *m)
 	return -EINVAL;
 }
 
+static inline int irq_force_affinity(unsigned int irq, const struct cpumask *cpumask)
+{
+	return 0;
+}
+
 static inline int irq_can_set_affinity(unsigned int irq)
 {
 	return 0;

commit def5f1273c5f18abf8fcaee03a115d3e907ad407
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Sun Apr 27 21:03:09 2014 -0700

    linux/interrupt.h: fix new kernel-doc warnings
    
    Fix new kernel-doc warnings in <linux/interrupt.h>:
    
    Warning(include/linux/interrupt.h:219): No description found for parameter 'cpumask'
    Warning(include/linux/interrupt.h:219): Excess function parameter 'mask' description in 'irq_set_affinity'
    Warning(include/linux/interrupt.h:236): No description found for parameter 'cpumask'
    Warning(include/linux/interrupt.h:236): Excess function parameter 'mask' description in 'irq_force_affinity'
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Link: http://lkml.kernel.org/r/535DD2FD.7030804@infradead.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 8834a7e5b944..97ac926c78a7 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -210,7 +210,7 @@ extern int __irq_set_affinity(unsigned int irq, const struct cpumask *cpumask,
 /**
  * irq_set_affinity - Set the irq affinity of a given irq
  * @irq:	Interrupt to set affinity
- * @mask:	cpumask
+ * @cpumask:	cpumask
  *
  * Fails if cpumask does not contain an online CPU
  */
@@ -223,7 +223,7 @@ irq_set_affinity(unsigned int irq, const struct cpumask *cpumask)
 /**
  * irq_force_affinity - Force the irq affinity of a given irq
  * @irq:	Interrupt to set affinity
- * @mask:	cpumask
+ * @cpumask:	cpumask
  *
  * Same as irq_set_affinity, but without checking the mask against
  * online cpus.

commit 4e857c58efeb99393cba5a5d0d8ec7117183137c
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Mon Mar 17 18:06:10 2014 +0100

    arch: Mass conversion of smp_mb__*()
    
    Mostly scripted conversion of the smp_mb__* barriers.
    
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Link: http://lkml.kernel.org/n/tip-55dhyhocezdw1dg7u19hmh1u@git.kernel.org
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: linux-arch@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index c7bfac1c4a7b..157111043281 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -453,7 +453,7 @@ static inline int tasklet_trylock(struct tasklet_struct *t)
 
 static inline void tasklet_unlock(struct tasklet_struct *t)
 {
-	smp_mb__before_clear_bit(); 
+	smp_mb__before_atomic();
 	clear_bit(TASKLET_STATE_RUN, &(t)->state);
 }
 
@@ -501,7 +501,7 @@ static inline void tasklet_hi_schedule_first(struct tasklet_struct *t)
 static inline void tasklet_disable_nosync(struct tasklet_struct *t)
 {
 	atomic_inc(&t->count);
-	smp_mb__after_atomic_inc();
+	smp_mb__after_atomic();
 }
 
 static inline void tasklet_disable(struct tasklet_struct *t)
@@ -513,13 +513,13 @@ static inline void tasklet_disable(struct tasklet_struct *t)
 
 static inline void tasklet_enable(struct tasklet_struct *t)
 {
-	smp_mb__before_atomic_dec();
+	smp_mb__before_atomic();
 	atomic_dec(&t->count);
 }
 
 static inline void tasklet_hi_enable(struct tasklet_struct *t)
 {
-	smp_mb__before_atomic_dec();
+	smp_mb__before_atomic();
 	atomic_dec(&t->count);
 }
 

commit 01f8fa4f01d8362358eb90e412bd7ae18a3ec1ad
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Apr 16 14:36:44 2014 +0000

    genirq: Allow forcing cpu affinity of interrupts
    
    The current implementation of irq_set_affinity() refuses rightfully to
    route an interrupt to an offline cpu.
    
    But there is a special case, where this is actually desired. Some of
    the ARM SoCs have per cpu timers which require setting the affinity
    during cpu startup where the cpu is not yet in the online mask.
    
    If we can't do that, then the local timer interrupt for the about to
    become online cpu is routed to some random online cpu.
    
    The developers of the affected machines tried to work around that
    issue, but that results in a massive mess in that timer code.
    
    We have a yet unused argument in the set_affinity callbacks of the irq
    chips, which I added back then for a similar reason. It was never
    required so it got not used. But I'm happy that I never removed it.
    
    That allows us to implement a sane handling of the above scenario. So
    the affected SoC drivers can add the required force handling to their
    interrupt chip, switch the timer code to irq_force_affinity() and
    things just work.
    
    This does not affect any existing user of irq_set_affinity().
    
    Tagged for stable to allow a simple fix of the affected SoC clock
    event drivers.
    
    Reported-and-tested-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Cc: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Cc: Tomasz Figa <t.figa@samsung.com>,
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>,
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: linux-arm-kernel@lists.infradead.org,
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/20140416143315.717251504@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index c7bfac1c4a7b..8834a7e5b944 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -203,7 +203,40 @@ static inline int check_wakeup_irqs(void) { return 0; }
 
 extern cpumask_var_t irq_default_affinity;
 
-extern int irq_set_affinity(unsigned int irq, const struct cpumask *cpumask);
+/* Internal implementation. Use the helpers below */
+extern int __irq_set_affinity(unsigned int irq, const struct cpumask *cpumask,
+			      bool force);
+
+/**
+ * irq_set_affinity - Set the irq affinity of a given irq
+ * @irq:	Interrupt to set affinity
+ * @mask:	cpumask
+ *
+ * Fails if cpumask does not contain an online CPU
+ */
+static inline int
+irq_set_affinity(unsigned int irq, const struct cpumask *cpumask)
+{
+	return __irq_set_affinity(irq, cpumask, false);
+}
+
+/**
+ * irq_force_affinity - Force the irq affinity of a given irq
+ * @irq:	Interrupt to set affinity
+ * @mask:	cpumask
+ *
+ * Same as irq_set_affinity, but without checking the mask against
+ * online cpus.
+ *
+ * Solely for low level cpu hotplug code, where we need to make per
+ * cpu interrupts affine before the cpu becomes online.
+ */
+static inline int
+irq_force_affinity(unsigned int irq, const struct cpumask *cpumask)
+{
+	return __irq_set_affinity(irq, cpumask, true);
+}
+
 extern int irq_can_set_affinity(unsigned int irq);
 extern int irq_select_affinity(unsigned int irq);
 

commit a92444c6b2225a9115d661c950cb48a22aeace20
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Feb 15 00:55:19 2014 +0000

    genirq: Provide irq_wake_thread()
    
    In course of the sdhci/sdio discussion with Russell about killing the
    sdio kthread hackery we discovered the need to be able to wake an
    interrupt thread from software.
    
    The rationale for this is, that sdio hardware can lack proper
    interrupt support for certain features. So the driver needs to poll
    the status registers, but at the same time it needs to be woken up by
    an hardware interrupt.
    
    To be able to get rid of the home brewn kthread construct of sdio we
    need a way to wake an irq thread independent of an actual hardware
    interrupt.
    
    Provide an irq_wake_thread() function which wakes up the thread which
    is associated to a given dev_id. This allows sdio to invoke the irq
    thread from the hardware irq handler via the IRQ_WAKE_THREAD return
    value and provides a possibility to wake it via a timer for the
    polling scenarios. That allows to simplify the sdio logic
    significantly.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Chris Ball <chris@printf.net>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20140215003823.772565780@linutronix.de

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index a2678d35b5a2..c7bfac1c4a7b 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -188,6 +188,7 @@ extern void disable_irq(unsigned int irq);
 extern void disable_percpu_irq(unsigned int irq);
 extern void enable_irq(unsigned int irq);
 extern void enable_percpu_irq(unsigned int irq, unsigned int type);
+extern void irq_wake_thread(unsigned int irq, void *dev_id);
 
 /* The following three functions are for the core kernel use only. */
 extern void suspend_device_irqs(void);

commit 0668d3065128d39449c097e62dbdb5707820137d
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jan 2 16:37:32 2014 -0800

    genirq: Add devm_request_any_context_irq()
    
    Some drivers use request_any_context_irq() but there isn't a
    devm_* function for it. Add one so that these drivers don't need
    to explicitly free the irq on driver detach.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Link: http://lkml.kernel.org/r/1388709460-19222-3-git-send-email-sboyd@codeaurora.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 0053adde0ed9..a2678d35b5a2 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -158,6 +158,11 @@ devm_request_irq(struct device *dev, unsigned int irq, irq_handler_t handler,
 					 devname, dev_id);
 }
 
+extern int __must_check
+devm_request_any_context_irq(struct device *dev, unsigned int irq,
+		 irq_handler_t handler, unsigned long irqflags,
+		 const char *devname, void *dev_id);
+
 extern void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id);
 
 /*

commit ce85b4f2eab663dfd4ff2cb5b603ba03f595922e
Author: Joe Perches <joe@perches.com>
Date:   Mon Jan 27 17:07:16 2014 -0800

    softirq: use const char * const for softirq_to_name, whitespace neatening
    
    Reduce data size a little.
    Reduce checkpatch noise.
    
    $ size kernel/softirq.o*
       text    data     bss     dec     hex filename
      11554    6013    4008   21575    5447 kernel/softirq.o.new
      11474    6093    4008   21575    5447 kernel/softirq.o.old
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index db43b58a3355..0053adde0ed9 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -360,7 +360,7 @@ enum
 /* map softirq index to softirq name. update 'softirq_to_name' in
  * kernel/softirq.c when adding a new softirq.
  */
-extern char *softirq_to_name[NR_SOFTIRQS];
+extern const char * const softirq_to_name[NR_SOFTIRQS];
 
 /* softirq mask and active fields moved to irq_cpustat_t in
  * asm/hardirq.h to get better cache usage.  KAO

commit fc21c0cff2f425891b28ff6fb6b03b325c977428
Author: Christoph Hellwig <hch@infradead.org>
Date:   Thu Nov 14 14:32:06 2013 -0800

    revert "softirq: Add support for triggering softirq work on softirqs"
    
    This commit was incomplete in that code to remove items from the per-cpu
    lists was missing and never acquired a user in the 5 years it has been in
    the tree.  We're going to implement what it seems to try to archive in a
    simpler way, and this code is in the way of doing so.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index c9e831dc80bc..db43b58a3355 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -11,8 +11,6 @@
 #include <linux/irqnr.h>
 #include <linux/hardirq.h>
 #include <linux/irqflags.h>
-#include <linux/smp.h>
-#include <linux/percpu.h>
 #include <linux/hrtimer.h>
 #include <linux/kref.h>
 #include <linux/workqueue.h>
@@ -392,15 +390,6 @@ extern void __raise_softirq_irqoff(unsigned int nr);
 extern void raise_softirq_irqoff(unsigned int nr);
 extern void raise_softirq(unsigned int nr);
 
-/* This is the worklist that queues up per-cpu softirq work.
- *
- * send_remote_sendirq() adds work to these lists, and
- * the softirq handler itself dequeues from them.  The queues
- * are protected by disabling local cpu interrupts and they must
- * only be accessed by the local cpu that they are for.
- */
-DECLARE_PER_CPU(struct list_head [NR_SOFTIRQS], softirq_work_list);
-
 DECLARE_PER_CPU(struct task_struct *, ksoftirqd);
 
 static inline struct task_struct *this_cpu_ksoftirqd(void)
@@ -408,17 +397,6 @@ static inline struct task_struct *this_cpu_ksoftirqd(void)
 	return this_cpu_read(ksoftirqd);
 }
 
-/* Try to send a softirq to a remote cpu.  If this cannot be done, the
- * work will be queued to the local cpu.
- */
-extern void send_remote_softirq(struct call_single_data *cp, int cpu, int softirq);
-
-/* Like send_remote_softirq(), but the caller must disable local cpu interrupts
- * and compute the current cpu, passed in as 'this_cpu'.
- */
-extern void __send_remote_softirq(struct call_single_data *cp, int cpu,
-				  int this_cpu, int softirq);
-
 /* Tasklets --- multithreaded analogue of BHs.
 
    Main feature differing them of generic softirqs: tasklet

commit 7d65f4a6553203da6a22097821d151fbbe7e4956
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Thu Sep 5 15:49:45 2013 +0200

    irq: Consolidate do_softirq() arch overriden implementations
    
    All arch overriden implementations of do_softirq() share the following
    common code: disable irqs (to avoid races with the pending check),
    check if there are softirqs pending, then execute __do_softirq() on
    a specific stack.
    
    Consolidate the common parts such that archs only worry about the
    stack switch.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@au1.ibm.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul Mackerras <paulus@au1.ibm.com>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: James E.J. Bottomley <jejb@parisc-linux.org>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Andrew Morton <akpm@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 5e865b554940..c9e831dc80bc 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -19,6 +19,7 @@
 
 #include <linux/atomic.h>
 #include <asm/ptrace.h>
+#include <asm/irq.h>
 
 /*
  * These correspond to the IORESOURCE_IRQ_* defines in
@@ -374,6 +375,16 @@ struct softirq_action
 
 asmlinkage void do_softirq(void);
 asmlinkage void __do_softirq(void);
+
+#ifdef __ARCH_HAS_DO_SOFTIRQ
+void do_softirq_own_stack(void);
+#else
+static inline void do_softirq_own_stack(void)
+{
+	__do_softirq();
+}
+#endif
+
 extern void open_softirq(int nr, void (*action)(struct softirq_action *));
 extern void softirq_init(void);
 extern void __raise_softirq_irqoff(unsigned int nr);

commit 0244ad004a54e39308d495fee0a2e637f8b5c317
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 30 09:39:53 2013 +0200

    Remove GENERIC_HARDIRQ config option
    
    After the last architecture switched to generic hard irqs the config
    options HAVE_GENERIC_HARDIRQS & GENERIC_HARDIRQS and the related code
    for !CONFIG_GENERIC_HARDIRQS can be removed.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 5fa5afeeb759..5e865b554940 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -120,7 +120,6 @@ struct irqaction {
 
 extern irqreturn_t no_action(int cpl, void *dev_id);
 
-#ifdef CONFIG_GENERIC_HARDIRQS
 extern int __must_check
 request_threaded_irq(unsigned int irq, irq_handler_t handler,
 		     irq_handler_t thread_fn,
@@ -140,40 +139,6 @@ request_any_context_irq(unsigned int irq, irq_handler_t handler,
 extern int __must_check
 request_percpu_irq(unsigned int irq, irq_handler_t handler,
 		   const char *devname, void __percpu *percpu_dev_id);
-#else
-
-extern int __must_check
-request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
-	    const char *name, void *dev);
-
-/*
- * Special function to avoid ifdeffery in kernel/irq/devres.c which
- * gets magically built by GENERIC_HARDIRQS=n architectures (sparc,
- * m68k). I really love these $@%#!* obvious Makefile references:
- * ../../../kernel/irq/devres.o
- */
-static inline int __must_check
-request_threaded_irq(unsigned int irq, irq_handler_t handler,
-		     irq_handler_t thread_fn,
-		     unsigned long flags, const char *name, void *dev)
-{
-	return request_irq(irq, handler, flags, name, dev);
-}
-
-static inline int __must_check
-request_any_context_irq(unsigned int irq, irq_handler_t handler,
-			unsigned long flags, const char *name, void *dev_id)
-{
-	return request_irq(irq, handler, flags, name, dev_id);
-}
-
-static inline int __must_check
-request_percpu_irq(unsigned int irq, irq_handler_t handler,
-		   const char *devname, void __percpu *percpu_dev_id)
-{
-	return request_irq(irq, handler, 0, devname, percpu_dev_id);
-}
-#endif
 
 extern void free_irq(unsigned int, void *);
 extern void free_percpu_irq(unsigned int, void __percpu *);
@@ -221,7 +186,6 @@ extern void enable_irq(unsigned int irq);
 extern void enable_percpu_irq(unsigned int irq, unsigned int type);
 
 /* The following three functions are for the core kernel use only. */
-#ifdef CONFIG_GENERIC_HARDIRQS
 extern void suspend_device_irqs(void);
 extern void resume_device_irqs(void);
 #ifdef CONFIG_PM_SLEEP
@@ -229,13 +193,8 @@ extern int check_wakeup_irqs(void);
 #else
 static inline int check_wakeup_irqs(void) { return 0; }
 #endif
-#else
-static inline void suspend_device_irqs(void) { };
-static inline void resume_device_irqs(void) { };
-static inline int check_wakeup_irqs(void) { return 0; }
-#endif
 
-#if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_HARDIRQS)
+#if defined(CONFIG_SMP)
 
 extern cpumask_var_t irq_default_affinity;
 
@@ -287,9 +246,8 @@ static inline int irq_set_affinity_hint(unsigned int irq,
 {
 	return -EINVAL;
 }
-#endif /* CONFIG_SMP && CONFIG_GENERIC_HARDIRQS */
+#endif /* CONFIG_SMP */
 
-#ifdef CONFIG_GENERIC_HARDIRQS
 /*
  * Special lockdep variants of irq disabling/enabling.
  * These should be used for locking constructs that
@@ -354,33 +312,6 @@ static inline int disable_irq_wake(unsigned int irq)
 	return irq_set_irq_wake(irq, 0);
 }
 
-#else /* !CONFIG_GENERIC_HARDIRQS */
-/*
- * NOTE: non-genirq architectures, if they want to support the lock
- * validator need to define the methods below in their asm/irq.h
- * files, under an #ifdef CONFIG_LOCKDEP section.
- */
-#ifndef CONFIG_LOCKDEP
-#  define disable_irq_nosync_lockdep(irq)	disable_irq_nosync(irq)
-#  define disable_irq_nosync_lockdep_irqsave(irq, flags) \
-						disable_irq_nosync(irq)
-#  define disable_irq_lockdep(irq)		disable_irq(irq)
-#  define enable_irq_lockdep(irq)		enable_irq(irq)
-#  define enable_irq_lockdep_irqrestore(irq, flags) \
-						enable_irq(irq)
-# endif
-
-static inline int enable_irq_wake(unsigned int irq)
-{
-	return 0;
-}
-
-static inline int disable_irq_wake(unsigned int irq)
-{
-	return 0;
-}
-#endif /* CONFIG_GENERIC_HARDIRQS */
-
 
 #ifdef CONFIG_IRQ_FORCED_THREADING
 extern bool force_irqthreads;
@@ -655,7 +586,7 @@ void tasklet_hrtimer_cancel(struct tasklet_hrtimer *ttimer)
  * if more than one irq occurred.
  */
 
-#if defined(CONFIG_GENERIC_HARDIRQS) && !defined(CONFIG_GENERIC_IRQ_PROBE) 
+#if !defined(CONFIG_GENERIC_IRQ_PROBE) 
 static inline unsigned long probe_irq_on(void)
 {
 	return 0;

commit 896f97ea95c1d29c0520ee0766b66b7f64cb967c
Author: David Decotigny <decot@googlers.com>
Date:   Fri Jan 11 14:31:36 2013 -0800

    lib: cpu_rmap: avoid flushing all workqueues
    
    In some cases, free_irq_cpu_rmap() is called while holding a lock (eg
    rtnl).  This can lead to deadlocks, because it invokes
    flush_scheduled_work() which ends up waiting for whole system workqueue
    to flush, but some pending works might try to acquire the lock we are
    already holding.
    
    This commit uses reference-counting to replace
    irq_run_affinity_notifiers().  It also removes
    irq_run_affinity_notifiers() altogether.
    
    [akpm@linux-foundation.org: eliminate free_cpu_rmap, rename cpu_rmap_reclaim() to cpu_rmap_release(), propagate kref_put() retval from cpu_rmap_put()]
    Signed-off-by: David Decotigny <decot@googlers.com>
    Reviewed-by: Ben Hutchings <bhutchings@solarflare.com>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Or Gerlitz <ogerlitz@mellanox.com>
    Acked-by: Amir Vadai <amirv@mellanox.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 5e4e6170f43a..5fa5afeeb759 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -268,11 +268,6 @@ struct irq_affinity_notify {
 extern int
 irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify);
 
-static inline void irq_run_affinity_notifiers(void)
-{
-	flush_scheduled_work();
-}
-
 #else /* CONFIG_SMP */
 
 static inline int irq_set_affinity(unsigned int irq, const struct cpumask *m)

commit 803b0ebae921714d1c36f0996db8125eda5fae53
Author: Paul E. McKenney <paul.mckenney@linaro.org>
Date:   Thu Aug 23 08:34:07 2012 -0700

    time: RCU permitted to stop idle entry via softirq
    
    The can_stop_idle_tick() function complains if a softirq vector is
    raised too late in the idle-entry process, presumably in order to
    prevent dangling softirq invocations from being delayed across the
    full idle period, which might be indefinitely long -- and if softirq
    was asserted any later than the call to this function, such a delay
    might well happen.
    
    However, RCU needs to be able to use softirq to stop idle entry in
    order to be able to drain RCU callbacks from the current CPU, which in
    turn enables faster entry into dyntick-idle mode, which in turn reduces
    power consumption.  Because RCU takes this action at a well-defined
    point in the idle-entry path, it is safe for RCU to take this approach.
    
    This commit therefore silences the error message that is sometimes
    produced when the going-idle CPU suddenly finds that it has an RCU_SOFTIRQ
    to process.  The error message will continue to be issued for other
    softirq vectors.
    
    Reported-by: Sedat Dilek <sedat.dilek@gmail.com>
    Signed-off-by: Paul E. McKenney <paul.mckenney@linaro.org>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Tested-by: Sedat Dilek <sedat.dilek@gmail.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index c5f856a040b9..5e4e6170f43a 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -430,6 +430,8 @@ enum
 	NR_SOFTIRQS
 };
 
+#define SOFTIRQ_STOP_IDLE_MASK (~(1 << RCU_SOFTIRQ))
+
 /* map softirq index to softirq name. update 'softirq_to_name' in
  * kernel/softirq.c when adding a new softirq.
  */

commit b4237003cff66084ebeb502412d9cee392e6f52f
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Tue Jul 17 14:20:51 2012 -0400

    random: final removal of IRQF_SAMPLE_RANDOM
    
    The IRQF_SAMPLE_RANDOM flag is finally gone from the kernel tree, only
    three years late.  :-)
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index e68a8e53bb59..c5f856a040b9 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -42,7 +42,6 @@
  *
  * IRQF_DISABLED - keep irqs disabled when calling the action handler.
  *                 DEPRECATED. This flag is a NOOP and scheduled to be removed
- * IRQF_SAMPLE_RANDOM - irq is used to feed the random generator
  * IRQF_SHARED - allow sharing the irq among several devices
  * IRQF_PROBE_SHARED - set by callers when they expect sharing mismatches to occur
  * IRQF_TIMER - Flag to mark this interrupt as timer interrupt
@@ -61,7 +60,6 @@
  *                resume time.
  */
 #define IRQF_DISABLED		0x00000020
-#define IRQF_SAMPLE_RANDOM	0x00000040
 #define IRQF_SHARED		0x00000080
 #define IRQF_PROBE_SHARED	0x00000100
 #define __IRQF_TIMER		0x00000200

commit 4d1d61a6b203d957777d73fcebf19d90b038b5b2
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Fri May 11 10:59:08 2012 +1000

    genirq: reimplement exit_irq_thread() hook via task_work_add()
    
    exit_irq_thread() and task->irq_thread are needed to handle the unexpected
    (and unlikely) exit of irq-thread.
    
    We can use task_work instead and make this all private to
    kernel/irq/manage.c, cleanup plus micro-optimization.
    
    1. rename exit_irq_thread() to irq_thread_dtor(), make it
       static, and move it up before irq_thread().
    
    2. change irq_thread() to do task_work_add(irq_thread_dtor)
       at the start and task_work_cancel() before return.
    
       tracehook_notify_resume() can never play with kthreads,
       only do_exit()->exit_task_work() can call the callback
       and this is what we want.
    
    3. remove task_struct->irq_thread and the special hook
       in do_exit().
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Alexander Gordeev <agordeev@redhat.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: David Smith <dsmith@redhat.com>
    Cc: "Frank Ch. Eigler" <fche@redhat.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Larry Woodman <lwoodman@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index c91171599cb6..e68a8e53bb59 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -142,8 +142,6 @@ request_any_context_irq(unsigned int irq, irq_handler_t handler,
 extern int __must_check
 request_percpu_irq(unsigned int irq, irq_handler_t handler,
 		   const char *devname, void __percpu *percpu_dev_id);
-
-extern void exit_irq_thread(void);
 #else
 
 extern int __must_check
@@ -177,8 +175,6 @@ request_percpu_irq(unsigned int irq, irq_handler_t handler,
 {
 	return request_irq(irq, handler, 0, devname, percpu_dev_id);
 }
-
-static inline void exit_irq_thread(void) { }
 #endif
 
 extern void free_irq(unsigned int, void *);

commit c0ecaa06d6d40cb02cd264ddb308e82f0a49ec91
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 19 11:53:25 2012 +0200

    genirq: Streamline irq_action
    
    There is no need to have flags as unsigned long. Make it unsigned int
    and put it together with irq so it does not waste space on 64 bit.
    Make irq unsigned int while at it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 2aea5d22db07..c91171599cb6 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -93,27 +93,27 @@ typedef irqreturn_t (*irq_handler_t)(int, void *);
 /**
  * struct irqaction - per interrupt action descriptor
  * @handler:	interrupt handler function
- * @flags:	flags (see IRQF_* above)
  * @name:	name of the device
  * @dev_id:	cookie to identify the device
  * @percpu_dev_id:	cookie to identify the device
  * @next:	pointer to the next irqaction for shared interrupts
  * @irq:	interrupt number
- * @dir:	pointer to the proc/irq/NN/name entry
+ * @flags:	flags (see IRQF_* above)
  * @thread_fn:	interrupt handler function for threaded interrupts
  * @thread:	thread pointer for threaded interrupts
  * @thread_flags:	flags related to @thread
  * @thread_mask:	bitmask for keeping track of @thread activity
+ * @dir:	pointer to the proc/irq/NN/name entry
  */
 struct irqaction {
 	irq_handler_t		handler;
-	unsigned long		flags;
 	void			*dev_id;
 	void __percpu		*percpu_dev_id;
 	struct irqaction	*next;
-	int			irq;
 	irq_handler_t		thread_fn;
 	struct task_struct	*thread;
+	unsigned int		irq;
+	unsigned int		flags;
 	unsigned long		thread_flags;
 	unsigned long		thread_mask;
 	const char		*name;

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 3f830e005118..2aea5d22db07 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -19,7 +19,6 @@
 
 #include <linux/atomic.h>
 #include <asm/ptrace.h>
-#include <asm/system.h>
 
 /*
  * These correspond to the IORESOURCE_IRQ_* defines in

commit f069686e4bdc60a637d210ea3eea25fcdb82df88
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Wed Jan 25 20:18:55 2012 -0500

    tracing/softirq: Move __raise_softirq_irqoff() out of header
    
    The __raise_softirq_irqoff() contains a tracepoint. As tracepoints in headers
    can cause issues, and not to mention, bloats the kernel when they are
    in a static inline, it is best to move the function that contains the
    tracepoint out of the header and into softirq.c.
    
    Link: http://lkml.kernel.org/r/20120118120711.GB14863@elte.hu
    
    Suggested-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index a64b00e286f5..3f830e005118 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -20,7 +20,6 @@
 #include <linux/atomic.h>
 #include <asm/ptrace.h>
 #include <asm/system.h>
-#include <trace/events/irq.h>
 
 /*
  * These correspond to the IORESOURCE_IRQ_* defines in
@@ -456,11 +455,7 @@ asmlinkage void do_softirq(void);
 asmlinkage void __do_softirq(void);
 extern void open_softirq(int nr, void (*action)(struct softirq_action *));
 extern void softirq_init(void);
-static inline void __raise_softirq_irqoff(unsigned int nr)
-{
-	trace_softirq_raise(nr);
-	or_softirq_pending(1UL << nr);
-}
+extern void __raise_softirq_irqoff(unsigned int nr);
 
 extern void raise_softirq_irqoff(unsigned int nr);
 extern void raise_softirq(unsigned int nr);

commit 9bab0b7fbaceec47d32db51cd9e59c82fb071f5a
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Mon Oct 3 15:37:00 2011 +0100

    genirq: Add IRQF_RESUME_EARLY and resume such IRQs earlier
    
    This adds a mechanism to resume selected IRQs during syscore_resume
    instead of dpm_resume_noirq.
    
    Under Xen we need to resume IRQs associated with IPIs early enough
    that the resched IPI is unmasked and we can therefore schedule
    ourselves out of the stop_machine where the suspend/resume takes
    place.
    
    This issue was introduced by 676dc3cf5bc3 "xen: Use IRQF_FORCE_RESUME".
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Jeremy Fitzhardinge <Jeremy.Fitzhardinge@citrix.com>
    Cc: xen-devel <xen-devel@lists.xensource.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Link: http://lkml.kernel.org/r/1318713254.11016.52.camel@dagon.hellion.org.uk
    Cc: stable@kernel.org (at least to 2.6.32.y)
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 664544ff77d5..a64b00e286f5 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -59,6 +59,8 @@
  * IRQF_NO_SUSPEND - Do not disable this IRQ during suspend
  * IRQF_FORCE_RESUME - Force enable it on resume even if IRQF_NO_SUSPEND is set
  * IRQF_NO_THREAD - Interrupt cannot be threaded
+ * IRQF_EARLY_RESUME - Resume IRQ early during syscore instead of at device
+ *                resume time.
  */
 #define IRQF_DISABLED		0x00000020
 #define IRQF_SAMPLE_RANDOM	0x00000040
@@ -72,6 +74,7 @@
 #define IRQF_NO_SUSPEND		0x00004000
 #define IRQF_FORCE_RESUME	0x00008000
 #define IRQF_NO_THREAD		0x00010000
+#define IRQF_EARLY_RESUME	0x00020000
 
 #define IRQF_TIMER		(__IRQF_TIMER | IRQF_NO_SUSPEND | IRQF_NO_THREAD)
 

commit 1e7c5fd29487ee88cb3abac945bafa60ae026146
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Sep 30 10:48:47 2011 +0100

    genirq: percpu: allow interrupt type to be set at enable time
    
    As request_percpu_irq() doesn't allow for a percpu interrupt to have
    its type configured (it is generally impossible to configure it on all
    CPUs at once), add a 'type' argument to enable_percpu_irq().
    
    This allows some low-level, board specific init code to be switched to
    a generic API.
    
    [ tglx: Added WARN_ON argument ]
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Abhijeet Dharmapurikar <adharmap@codeaurora.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 1cdfd09c8abc..664544ff77d5 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -223,7 +223,7 @@ extern void disable_irq_nosync(unsigned int irq);
 extern void disable_irq(unsigned int irq);
 extern void disable_percpu_irq(unsigned int irq);
 extern void enable_irq(unsigned int irq);
-extern void enable_percpu_irq(unsigned int irq);
+extern void enable_percpu_irq(unsigned int irq, unsigned int type);
 
 /* The following three functions are for the core kernel use only. */
 #ifdef CONFIG_GENERIC_HARDIRQS

commit 31d9d9b6d83030f748d013e61502fa5477e2ac0e
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Sep 23 17:03:06 2011 +0100

    genirq: Add support for per-cpu dev_id interrupts
    
    The ARM GIC interrupt controller offers per CPU interrupts (PPIs),
    which are usually used to connect local timers to each core. Each CPU
    has its own private interface to the GIC, and only sees the PPIs that
    are directly connect to it.
    
    While these timers are separate devices and have a separate interrupt
    line to a core, they all use the same IRQ number.
    
    For these devices, request_irq() is not the right API as it assumes
    that an IRQ number is visible by a number of CPUs (through the
    affinity setting), but makes it very awkward to express that an IRQ
    number can be handled by all CPUs, and yet be a different interrupt
    line on each CPU, requiring a different dev_id cookie to be passed
    back to the handler.
    
    The *_percpu_irq() functions is designed to overcome these
    limitations, by providing a per-cpu dev_id vector:
    
    int request_percpu_irq(unsigned int irq, irq_handler_t handler,
                       const char *devname, void __percpu *percpu_dev_id);
    void free_percpu_irq(unsigned int, void __percpu *);
    int setup_percpu_irq(unsigned int irq, struct irqaction *new);
    void remove_percpu_irq(unsigned int irq, struct irqaction *act);
    void enable_percpu_irq(unsigned int irq);
    void disable_percpu_irq(unsigned int irq);
    
    The API has a number of limitations:
    - no interrupt sharing
    - no threading
    - common handler across all the CPUs
    
    Once the interrupt is requested using setup_percpu_irq() or
    request_percpu_irq(), it must be enabled by each core that wishes its
    local interrupt to be delivered.
    
    Based on an initial patch by Thomas Gleixner.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Link: http://lkml.kernel.org/r/1316793788-14500-2-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index a103732b7588..1cdfd09c8abc 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -95,6 +95,7 @@ typedef irqreturn_t (*irq_handler_t)(int, void *);
  * @flags:	flags (see IRQF_* above)
  * @name:	name of the device
  * @dev_id:	cookie to identify the device
+ * @percpu_dev_id:	cookie to identify the device
  * @next:	pointer to the next irqaction for shared interrupts
  * @irq:	interrupt number
  * @dir:	pointer to the proc/irq/NN/name entry
@@ -104,17 +105,18 @@ typedef irqreturn_t (*irq_handler_t)(int, void *);
  * @thread_mask:	bitmask for keeping track of @thread activity
  */
 struct irqaction {
-	irq_handler_t handler;
-	unsigned long flags;
-	void *dev_id;
-	struct irqaction *next;
-	int irq;
-	irq_handler_t thread_fn;
-	struct task_struct *thread;
-	unsigned long thread_flags;
-	unsigned long thread_mask;
-	const char *name;
-	struct proc_dir_entry *dir;
+	irq_handler_t		handler;
+	unsigned long		flags;
+	void			*dev_id;
+	void __percpu		*percpu_dev_id;
+	struct irqaction	*next;
+	int			irq;
+	irq_handler_t		thread_fn;
+	struct task_struct	*thread;
+	unsigned long		thread_flags;
+	unsigned long		thread_mask;
+	const char		*name;
+	struct proc_dir_entry	*dir;
 } ____cacheline_internodealigned_in_smp;
 
 extern irqreturn_t no_action(int cpl, void *dev_id);
@@ -136,6 +138,10 @@ extern int __must_check
 request_any_context_irq(unsigned int irq, irq_handler_t handler,
 			unsigned long flags, const char *name, void *dev_id);
 
+extern int __must_check
+request_percpu_irq(unsigned int irq, irq_handler_t handler,
+		   const char *devname, void __percpu *percpu_dev_id);
+
 extern void exit_irq_thread(void);
 #else
 
@@ -164,10 +170,18 @@ request_any_context_irq(unsigned int irq, irq_handler_t handler,
 	return request_irq(irq, handler, flags, name, dev_id);
 }
 
+static inline int __must_check
+request_percpu_irq(unsigned int irq, irq_handler_t handler,
+		   const char *devname, void __percpu *percpu_dev_id)
+{
+	return request_irq(irq, handler, 0, devname, percpu_dev_id);
+}
+
 static inline void exit_irq_thread(void) { }
 #endif
 
 extern void free_irq(unsigned int, void *);
+extern void free_percpu_irq(unsigned int, void __percpu *);
 
 struct device;
 
@@ -207,7 +221,9 @@ extern void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id);
 
 extern void disable_irq_nosync(unsigned int irq);
 extern void disable_irq(unsigned int irq);
+extern void disable_percpu_irq(unsigned int irq);
 extern void enable_irq(unsigned int irq);
+extern void enable_percpu_irq(unsigned int irq);
 
 /* The following three functions are for the core kernel use only. */
 #ifdef CONFIG_GENERIC_HARDIRQS

commit 60063497a95e716c9a689af3be2687d261f115b4
Author: Arun Sharma <asharma@fb.com>
Date:   Tue Jul 26 16:09:06 2011 -0700

    atomic: use <linux/atomic.h>
    
    This allows us to move duplicated code in <asm/atomic.h>
    (atomic_inc_not_zero() for now) to <linux/atomic.h>
    
    Signed-off-by: Arun Sharma <asharma@fb.com>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index f6efed0039ed..a103732b7588 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -17,7 +17,7 @@
 #include <linux/kref.h>
 #include <linux/workqueue.h>
 
-#include <asm/atomic.h>
+#include <linux/atomic.h>
 #include <asm/ptrace.h>
 #include <asm/system.h>
 #include <trace/events/irq.h>

commit 09223371deac67d08ca0b70bd18787920284c967
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Tue Jun 14 13:26:25 2011 +0800

    rcu: Use softirq to address performance regression
    
    Commit a26ac2455ffcf3(rcu: move TREE_RCU from softirq to kthread)
    introduced performance regression. In an AIM7 test, this commit degraded
    performance by about 40%.
    
    The commit runs rcu callbacks in a kthread instead of softirq. We observed
    high rate of context switch which is caused by this. Out test system has
    64 CPUs and HZ is 1000, so we saw more than 64k context switch per second
    which is caused by RCU's per-CPU kthread.  A trace showed that most of
    the time the RCU per-CPU kthread doesn't actually handle any callbacks,
    but instead just does a very small amount of work handling grace periods.
    This means that RCU's per-CPU kthreads are making the scheduler do quite
    a bit of work in order to allow a very small amount of RCU-related
    processing to be done.
    
    Alex Shi's analysis determined that this slowdown is due to lock
    contention within the scheduler.  Unfortunately, as Peter Zijlstra points
    out, the scheduler's real-time semantics require global action, which
    means that this contention is inherent in real-time scheduling.  (Yes,
    perhaps someone will come up with a workaround -- otherwise, -rt is not
    going to do well on large SMP systems -- but this patch will work around
    this issue in the meantime.  And "the meantime" might well be forever.)
    
    This patch therefore re-introduces softirq processing to RCU, but only
    for core RCU work.  RCU callbacks are still executed in kthread context,
    so that only a small amount of RCU work runs in softirq context in the
    common case.  This should minimize ksoftirqd execution, allowing us to
    skip boosting of ksoftirqd for CONFIG_RCU_BOOST=y kernels.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Tested-by: "Alex,Shi" <alex.shi@intel.com>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 6c12989839d9..f6efed0039ed 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -414,6 +414,7 @@ enum
 	TASKLET_SOFTIRQ,
 	SCHED_SOFTIRQ,
 	HRTIMER_SOFTIRQ,
+	RCU_SOFTIRQ,    /* Preferable RCU should always be the last softirq */
 
 	NR_SOFTIRQS
 };

commit a26ac2455ffcf3be5c6ef92bc6df7182700f2114
Author: Paul E. McKenney <paul.mckenney@linaro.org>
Date:   Wed Jan 12 14:10:23 2011 -0800

    rcu: move TREE_RCU from softirq to kthread
    
    If RCU priority boosting is to be meaningful, callback invocation must
    be boosted in addition to preempted RCU readers.  Otherwise, in presence
    of CPU real-time threads, the grace period ends, but the callbacks don't
    get invoked.  If the callbacks don't get invoked, the associated memory
    doesn't get freed, so the system is still subject to OOM.
    
    But it is not reasonable to priority-boost RCU_SOFTIRQ, so this commit
    moves the callback invocations to a kthread, which can be boosted easily.
    
    Also add comments and properly synchronized all accesses to
    rcu_cpu_kthread_task, as suggested by Lai Jiangshan.
    
    Signed-off-by: Paul E. McKenney <paul.mckenney@linaro.org>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index bea0ac750712..6c12989839d9 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -414,7 +414,6 @@ enum
 	TASKLET_SOFTIRQ,
 	SCHED_SOFTIRQ,
 	HRTIMER_SOFTIRQ,
-	RCU_SOFTIRQ,	/* Preferable RCU should always be the last softirq */
 
 	NR_SOFTIRQS
 };

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 943c9b53695c..bea0ac750712 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -98,7 +98,7 @@ typedef irqreturn_t (*irq_handler_t)(int, void *);
  * @next:	pointer to the next irqaction for shared interrupts
  * @irq:	interrupt number
  * @dir:	pointer to the proc/irq/NN/name entry
- * @thread_fn:	interupt handler function for threaded interrupts
+ * @thread_fn:	interrupt handler function for threaded interrupts
  * @thread:	thread pointer for threaded interrupts
  * @thread_flags:	flags related to @thread
  * @thread_mask:	bitmask for keeping track of @thread activity
@@ -484,7 +484,7 @@ extern void __send_remote_softirq(struct call_single_data *cp, int cpu,
    Properties:
    * If tasklet_schedule() is called, then tasklet is guaranteed
      to be executed on some cpu at least once after this.
-   * If the tasklet is already scheduled, but its excecution is still not
+   * If the tasklet is already scheduled, but its execution is still not
      started, it will be executed only once.
    * If this tasklet is already running on another CPU (or schedule is called
      from tasklet itself), it is rescheduled for later.

commit 380a26be7d5af83f3831c3b6697031dffbb1c8f3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 30 00:35:34 2011 +0200

    genirq: Remove now obsolete set_irq_wake()
    
    Missed that one in the big compat remval patch
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 59b72ca1c5d1..943c9b53695c 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -338,14 +338,6 @@ static inline void enable_irq_lockdep_irqrestore(unsigned int irq, unsigned long
 /* IRQ wakeup (PM) control: */
 extern int irq_set_irq_wake(unsigned int irq, unsigned int on);
 
-#ifndef CONFIG_GENERIC_HARDIRQS_NO_COMPAT
-/* Please do not use: Use the replacement functions instead */
-static inline int set_irq_wake(unsigned int irq, unsigned int on)
-{
-	return irq_set_irq_wake(irq, on);
-}
-#endif
-
 static inline int enable_irq_wake(unsigned int irq)
 {
 	return irq_set_irq_wake(irq, 1);

commit 5f6fb45466b2273ffb91c9cf209f164f666c33b1
Merge: 3904afb41d43 c0185808eb85
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 15 19:23:40 2011 -0700

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (116 commits)
      x86: Enable forced interrupt threading support
      x86: Mark low level interrupts IRQF_NO_THREAD
      x86: Use generic show_interrupts
      x86: ioapic: Avoid redundant lookup of irq_cfg
      x86: ioapic: Use new move_irq functions
      x86: Use the proper accessors in fixup_irqs()
      x86: ioapic: Use irq_data->state
      x86: ioapic: Simplify irq chip and handler setup
      x86: Cleanup the genirq name space
      genirq: Add chip flag to force mask on suspend
      genirq: Add desc->irq_data accessor
      genirq: Add comments to Kconfig switches
      genirq: Fixup fasteoi handler for oneshot mode
      genirq: Provide forced interrupt threading
      sched: Switch wait_task_inactive to schedule_hrtimeout()
      genirq: Add IRQF_NO_THREAD
      genirq: Allow shared oneshot interrupts
      genirq: Prepare the handling of shared oneshot interrupts
      genirq: Make warning in handle_percpu_event useful
      x86: ioapic: Move trigger defines to io_apic.h
      ...
    
    Fix up trivial(?) conflicts in arch/x86/pci/xen.c due to genirq name
    space changes clashing with the Xen cleanups.  The set_irq_msi() had
    moved to xen_bind_pirq_msi_to_irq().

commit 9620639b7ea3843983f4ced8b4c81eb4d8974838
Merge: a926021cb1f8 6d1cafd8b56e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 15 18:37:30 2011 -0700

    Merge branch 'sched-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'sched-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (26 commits)
      sched: Resched proper CPU on yield_to()
      sched: Allow users with sufficient RLIMIT_NICE to change from SCHED_IDLE policy
      sched: Allow SCHED_BATCH to preempt SCHED_IDLE tasks
      sched: Clean up the IRQ_TIME_ACCOUNTING code
      sched: Add #ifdef around irq time accounting functions
      sched, autogroup: Stop claiming ownership of the root task group
      sched, autogroup: Stop going ahead if autogroup is disabled
      sched, autogroup, sysctl: Use proc_dointvec_minmax() instead
      sched: Fix the group_imb logic
      sched: Clean up some f_b_g() comments
      sched: Clean up remnants of sd_idle
      sched: Wholesale removal of sd_idle logic
      sched: Add yield_to(task, preempt) functionality
      sched: Use a buddy to implement yield_task_fair()
      sched: Limit the scope of clear_buddies
      sched: Check the right ->nr_running in yield_task_fair()
      sched: Avoid expensive initial update_cfs_load(), on UP too
      sched: Fix switch_from_fair()
      sched: Simplify the idle scheduling class
      softirqs: Account ksoftirqd time as cpustat softirq
      ...

commit 8d32a307e4faa8b123dc8a9cd56d1a7525f69ad3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Feb 23 23:52:23 2011 +0000

    genirq: Provide forced interrupt threading
    
    Add a commandline parameter "threadirqs" which forces all interrupts except
    those marked IRQF_NO_THREAD to run threaded. That's mostly a debug option to
    allow retrieving better debug data from crashing interrupt handlers. If
    "threadirqs" is not enabled on the kernel command line, then there is no
    impact in the interrupt hotpath.
    
    Architecture code needs to select CONFIG_IRQ_FORCED_THREADING after
    marking the interrupts which cant be threaded IRQF_NO_THREAD. All
    interrupts which have IRQF_TIMER set are implict marked
    IRQF_NO_THREAD. Also all PER_CPU interrupts are excluded.
    
    Forced threading hard interrupts also forces all soft interrupt
    handling into thread context.
    
    When enabled it might slow down things a bit, but for debugging problems in
    interrupt code it's a reasonable penalty as it does not immediately
    crash and burn the machine when an interrupt handler is buggy.
    
    Some test results on a Core2Duo machine:
    
    Cache cold run of:
     # time git grep irq_desc
    
          non-threaded       threaded
     real 1m18.741s          1m19.061s
     user 0m1.874s           0m1.757s
     sys  0m5.843s           0m5.427s
    
     # iperf -c server
    non-threaded
    [  3]  0.0-10.0 sec  1.09 GBytes   933 Mbits/sec
    [  3]  0.0-10.0 sec  1.09 GBytes   934 Mbits/sec
    [  3]  0.0-10.0 sec  1.09 GBytes   933 Mbits/sec
    threaded
    [  3]  0.0-10.0 sec  1.09 GBytes   939 Mbits/sec
    [  3]  0.0-10.0 sec  1.09 GBytes   934 Mbits/sec
    [  3]  0.0-10.0 sec  1.09 GBytes   937 Mbits/sec
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    LKML-Reference: <20110223234956.772668648@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 0fc3eb9397b4..f8a8af108e0c 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -383,6 +383,13 @@ static inline int disable_irq_wake(unsigned int irq)
 }
 #endif /* CONFIG_GENERIC_HARDIRQS */
 
+
+#ifdef CONFIG_IRQ_FORCED_THREADING
+extern bool force_irqthreads;
+#else
+#define force_irqthreads	(0)
+#endif
+
 #ifndef __ARCH_SET_SOFTIRQ_PENDING
 #define set_softirq_pending(x) (local_softirq_pending() = (x))
 #define or_softirq_pending(x)  (local_softirq_pending() |= (x))

commit 0c4602ff88d6d6ef0ee6d228ee9acaa6448ff6f5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Feb 23 23:52:18 2011 +0000

    genirq: Add IRQF_NO_THREAD
    
    Some low level interrupts cannot be threaded even when we force thread
    all interrupt handlers. Add a flag to annotate such interrupts. Add
    all timer interrupts to this category by default.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    LKML-Reference: <20110223234956.578893460@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index e116fef274cd..0fc3eb9397b4 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -58,6 +58,7 @@
  *                irq line disabled until the threaded handler has been run.
  * IRQF_NO_SUSPEND - Do not disable this IRQ during suspend
  * IRQF_FORCE_RESUME - Force enable it on resume even if IRQF_NO_SUSPEND is set
+ * IRQF_NO_THREAD - Interrupt cannot be threaded
  */
 #define IRQF_DISABLED		0x00000020
 #define IRQF_SAMPLE_RANDOM	0x00000040
@@ -70,8 +71,9 @@
 #define IRQF_ONESHOT		0x00002000
 #define IRQF_NO_SUSPEND		0x00004000
 #define IRQF_FORCE_RESUME	0x00008000
+#define IRQF_NO_THREAD		0x00010000
 
-#define IRQF_TIMER		(__IRQF_TIMER | IRQF_NO_SUSPEND)
+#define IRQF_TIMER		(__IRQF_TIMER | IRQF_NO_SUSPEND | IRQF_NO_THREAD)
 
 /*
  * These values can be returned by request_any_context_irq() and

commit b5faba21a6805c33b40e258d36f57997ee1de131
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Feb 23 23:52:13 2011 +0000

    genirq: Prepare the handling of shared oneshot interrupts
    
    For level type interrupts we need to track how many threads are on
    flight to avoid useless interrupt storms when not all thread handlers
    have finished yet. Keep track of the woken threads and only unmask
    when there are no more threads in flight.
    
    Yes, I'm lazy and using a bitfield. But not only because I'm lazy, the
    main reason is that it's way simpler than using a refcount. A refcount
    based solution would need to keep track of various things like
    crashing the irq thread, spurious interrupts coming in,
    disables/enables, free_irq() and some more. The bitfield keeps the
    tracking simple and makes things just work. It's also nicely confined
    to the thread code pathes and does not require additional checks all
    over the place.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    LKML-Reference: <20110223234956.388095876@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 8da6643e39a6..e116fef274cd 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -99,6 +99,7 @@ typedef irqreturn_t (*irq_handler_t)(int, void *);
  * @thread_fn:	interupt handler function for threaded interrupts
  * @thread:	thread pointer for threaded interrupts
  * @thread_flags:	flags related to @thread
+ * @thread_mask:	bitmask for keeping track of @thread activity
  */
 struct irqaction {
 	irq_handler_t handler;
@@ -109,6 +110,7 @@ struct irqaction {
 	irq_handler_t thread_fn;
 	struct task_struct *thread;
 	unsigned long thread_flags;
+	unsigned long thread_mask;
 	const char *name;
 	struct proc_dir_entry *dir;
 } ____cacheline_internodealigned_in_smp;

commit c78b9b65faa291def628dbd8539649f58299f0f3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Dec 16 17:21:47 2010 +0100

    genirq: Implement generic irq_show_interrupts()
    
    All archs implement show_interrupts() in more or less the same
    way. That's tons of duplicated code with different bugs with no
    value. Implement a generic version and deprecate show_interrupts()
    
    Unfortunately we need some ifdeffery for !GENERIC_HARDIRQ archs.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index de97b958f478..8da6643e39a6 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -671,6 +671,7 @@ static inline void init_irq_proc(void)
 
 struct seq_file;
 int show_interrupts(struct seq_file *p, void *v);
+int arch_show_interrupts(struct seq_file *p, int prec);
 
 extern int early_irq_init(void);
 extern int arch_probe_nr_irqs(void);

commit 1535dfacbf21c4da1b73fcf07c39913da5bd5581
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 01:55:43 2011 +0100

    genirq: Move irq thread flags to core
    
    Soleley used in core code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 7834726dd95b..de97b958f478 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -73,20 +73,6 @@
 
 #define IRQF_TIMER		(__IRQF_TIMER | IRQF_NO_SUSPEND)
 
-/*
- * Bits used by threaded handlers:
- * IRQTF_RUNTHREAD - signals that the interrupt handler thread should run
- * IRQTF_DIED      - handler thread died
- * IRQTF_WARNED    - warning "IRQ_WAKE_THREAD w/o thread_fn" has been printed
- * IRQTF_AFFINITY  - irq thread is requested to adjust affinity
- */
-enum {
-	IRQTF_RUNTHREAD,
-	IRQTF_DIED,
-	IRQTF_WARNED,
-	IRQTF_AFFINITY,
-};
-
 /*
  * These values can be returned by request_any_context_irq() and
  * describe the context the interrupt will be run in.

commit a0cd9ca2b907d7ee26575e7b63ac92dad768a75e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 10 11:36:33 2011 +0100

    genirq: Namespace cleanup
    
    The irq namespace has become quite convoluted. My bad.  Clean it up
    and deprecate the old functions. All new functions follow the scheme:
    
    irq number based:
        irq_set/get/xxx/_xxx(unsigned int irq, ...)
    
    irq_data based:
             irq_data_set/get/xxx/_xxx(struct irq_data *d, ....)
    
    irq_desc based:
             irq_desc_get_xxx(struct irq_desc *desc)
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 56b7c97aaf0a..7834726dd95b 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -346,16 +346,24 @@ static inline void enable_irq_lockdep_irqrestore(unsigned int irq, unsigned long
 }
 
 /* IRQ wakeup (PM) control: */
-extern int set_irq_wake(unsigned int irq, unsigned int on);
+extern int irq_set_irq_wake(unsigned int irq, unsigned int on);
+
+#ifndef CONFIG_GENERIC_HARDIRQS_NO_COMPAT
+/* Please do not use: Use the replacement functions instead */
+static inline int set_irq_wake(unsigned int irq, unsigned int on)
+{
+	return irq_set_irq_wake(irq, on);
+}
+#endif
 
 static inline int enable_irq_wake(unsigned int irq)
 {
-	return set_irq_wake(irq, 1);
+	return irq_set_irq_wake(irq, 1);
 }
 
 static inline int disable_irq_wake(unsigned int irq)
 {
-	return set_irq_wake(irq, 0);
+	return irq_set_irq_wake(irq, 0);
 }
 
 #else /* !CONFIG_GENERIC_HARDIRQS */

commit c9a443cdf7726ce8b78c3177c6ae601ce37292fc
Merge: 285c1a2c3a5f dc5f219e8829
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 16:38:00 2011 +0100

    Merge branch 'irq/for-xen' into irq/core
    
    irq/for-xen contains new functionality to avoid Xen private irq
    hackery. That branch has a single irq commit and is pulled by Xen to
    base their new features on.
    
    Merge it into irq/core as other patches modify the same code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit dc5f219e88294b93009eef946251251ffffb6d60
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 4 13:19:20 2011 +0100

    genirq: Add IRQF_FORCE_RESUME
    
    Xen needs to reenable interrupts which are marked IRQF_NO_SUSPEND in the
    resume path. Add a flag to force the reenabling in the resume code.
    
    Tested-and-acked-by: Ian Campbell <Ian.Campbell@eu.citrix.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 55e0d4253e49..d746da19c6a2 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -55,7 +55,7 @@
  *                Used by threaded interrupts which need to keep the
  *                irq line disabled until the threaded handler has been run.
  * IRQF_NO_SUSPEND - Do not disable this IRQ during suspend
- *
+ * IRQF_FORCE_RESUME - Force enable it on resume even if IRQF_NO_SUSPEND is set
  */
 #define IRQF_DISABLED		0x00000020
 #define IRQF_SAMPLE_RANDOM	0x00000040
@@ -67,6 +67,7 @@
 #define IRQF_IRQPOLL		0x00001000
 #define IRQF_ONESHOT		0x00002000
 #define IRQF_NO_SUSPEND		0x00004000
+#define IRQF_FORCE_RESUME	0x00008000
 
 #define IRQF_TIMER		(__IRQF_TIMER | IRQF_NO_SUSPEND)
 

commit 4dd53d891ca46dcc1fde0376a33540d3fd83cb9a
Author: Venkatesh Pallipadi <venki@google.com>
Date:   Tue Dec 21 17:09:00 2010 -0800

    softirqs: Free up pf flag PF_KSOFTIRQD
    
    Cleanup patch, freeing up PF_KSOFTIRQD and use per_cpu ksoftirqd pointer
    instead, as suggested by Eric Dumazet.
    
    Tested-by: Shaun Ruffell <sruffell@digium.com>
    Signed-off-by: Venkatesh Pallipadi <venki@google.com>
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    LKML-Reference: <1292980144-28796-2-git-send-email-venki@google.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 55e0d4253e49..a1382b9b5813 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -426,6 +426,13 @@ extern void raise_softirq(unsigned int nr);
  */
 DECLARE_PER_CPU(struct list_head [NR_SOFTIRQS], softirq_work_list);
 
+DECLARE_PER_CPU(struct task_struct *, ksoftirqd);
+
+static inline struct task_struct *this_cpu_ksoftirqd(void)
+{
+	return this_cpu_read(ksoftirqd);
+}
+
 /* Try to send a softirq to a remote cpu.  If this cannot be done, the
  * work will be queued to the local cpu.
  */

commit cd7eab44e9946c28d595abe3e9a43e945bc49141
Author: Ben Hutchings <bhutchings@solarflare.com>
Date:   Wed Jan 19 21:01:44 2011 +0000

    genirq: Add IRQ affinity notifiers
    
    When initiating I/O on a multiqueue and multi-IRQ device, we may want
    to select a queue for which the response will be handled on the same
    or a nearby CPU.  This requires a reverse-map of IRQ affinity.  Add a
    notification mechanism to support this.
    
    This is based closely on work by Thomas Gleixner <tglx@linutronix.de>.
    
    Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
    Cc: linux-net-drivers@solarflare.com
    Cc: Tom Herbert <therbert@google.com>
    Cc: David Miller <davem@davemloft.net>
    LKML-Reference: <1295470904.11126.84.camel@bwh-desktop>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 55e0d4253e49..63c5ad78e37c 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -14,6 +14,8 @@
 #include <linux/smp.h>
 #include <linux/percpu.h>
 #include <linux/hrtimer.h>
+#include <linux/kref.h>
+#include <linux/workqueue.h>
 
 #include <asm/atomic.h>
 #include <asm/ptrace.h>
@@ -240,6 +242,35 @@ extern int irq_can_set_affinity(unsigned int irq);
 extern int irq_select_affinity(unsigned int irq);
 
 extern int irq_set_affinity_hint(unsigned int irq, const struct cpumask *m);
+
+/**
+ * struct irq_affinity_notify - context for notification of IRQ affinity changes
+ * @irq:		Interrupt to which notification applies
+ * @kref:		Reference count, for internal use
+ * @work:		Work item, for internal use
+ * @notify:		Function to be called on change.  This will be
+ *			called in process context.
+ * @release:		Function to be called on release.  This will be
+ *			called in process context.  Once registered, the
+ *			structure must only be freed when this function is
+ *			called or later.
+ */
+struct irq_affinity_notify {
+	unsigned int irq;
+	struct kref kref;
+	struct work_struct work;
+	void (*notify)(struct irq_affinity_notify *, const cpumask_t *mask);
+	void (*release)(struct kref *ref);
+};
+
+extern int
+irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify);
+
+static inline void irq_run_affinity_notifiers(void)
+{
+	flush_scheduled_work();
+}
+
 #else /* CONFIG_SMP */
 
 static inline int irq_set_affinity(unsigned int irq, const struct cpumask *m)
@@ -255,7 +286,7 @@ static inline int irq_can_set_affinity(unsigned int irq)
 static inline int irq_select_affinity(unsigned int irq)  { return 0; }
 
 static inline int irq_set_affinity_hint(unsigned int irq,
-                                        const struct cpumask *m)
+					const struct cpumask *m)
 {
 	return -EINVAL;
 }

commit f6cd24777513fcc673d432cc29ef59881d3e4df1
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Thu Nov 4 11:13:48 2010 +0100

    irq: Better struct irqaction layout
    
    We currently use kmalloc-96 slab for struct irqaction allocations on
    64bit arches.
    
    This is unfortunate because of possible false sharing and two cache
    lines accesses.
    
    Move 'name' and 'dir' fields at the end of the structure, and force a
    suitable alignement.
    
    Hot path fields now use one cache line on x86_64.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Reviewed-by: Andi Kleen <andi@firstfloor.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    LKML-Reference: <1288865628.2659.69.camel@edumazet-laptop>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 79d0c4f6d071..55e0d4253e49 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -114,15 +114,15 @@ typedef irqreturn_t (*irq_handler_t)(int, void *);
 struct irqaction {
 	irq_handler_t handler;
 	unsigned long flags;
-	const char *name;
 	void *dev_id;
 	struct irqaction *next;
 	int irq;
-	struct proc_dir_entry *dir;
 	irq_handler_t thread_fn;
 	struct task_struct *thread;
 	unsigned long thread_flags;
-};
+	const char *name;
+	struct proc_dir_entry *dir;
+} ____cacheline_internodealigned_in_smp;
 
 extern irqreturn_t no_action(int cpl, void *dev_id);
 

commit a042e26137d7674ac04b1cd2d5c06b9ebc1ee2d5
Merge: f66dd539feb8 e25804a0327d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 27 18:48:00 2010 -0700

    Merge branch 'perf-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'perf-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (50 commits)
      perf python scripting: Add futex-contention script
      perf python scripting: Fixup cut'n'paste error in sctop script
      perf scripting: Shut up 'perf record' final status
      perf record: Remove newline character from perror() argument
      perf python scripting: Support fedora 11 (audit 1.7.17)
      perf python scripting: Improve the syscalls-by-pid script
      perf python scripting: print the syscall name on sctop
      perf python scripting: Improve the syscalls-counts script
      perf python scripting: Improve the failed-syscalls-by-pid script
      kprobes: Remove redundant text_mutex lock in optimize
      x86/oprofile: Fix uninitialized variable use in debug printk
      tracing: Fix 'faild' -> 'failed' typo
      perf probe: Fix format specified for Dwarf_Off parameter
      perf trace: Fix detection of script extension
      perf trace: Use $PERF_EXEC_PATH in canned report scripts
      perf tools: Document event modifiers
      perf tools: Remove direct slang.h include
      perf_events: Fix for transaction recovery in group_sched_in()
      perf_events: Revert: Fix transaction recovery in group_sched_in()
      perf, x86: Use NUMA aware allocations for PEBS/BTS/DS allocations
      ...

commit b8ecad8b2f8757d51632b1ea6d602c1f7b9760a2
Merge: eea4a0b19a27 8bfb5e7d6a14
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sat Oct 23 20:05:43 2010 +0200

    Merge branch 'perf/core' of git://git.kernel.org/pub/scm/linux/kernel/git/acme/linux-2.6 into perf/urgent

commit 02f36038c568111ad4fc433f6fa760ff5e38fab4
Merge: 6c2754c28f23 676cb02dc32a 07bd8516a2f9 50f2d7f682f9 892df7f81c31 68f4d5a00ada b365a85c6816 6554287b1de0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 23 08:25:36 2010 -0700

    Merge branches 'softirq-for-linus', 'x86-debug-for-linus', 'x86-numa-for-linus', 'x86-quirks-for-linus', 'x86-setup-for-linus', 'x86-uv-for-linus' and 'x86-vm86-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'softirq-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      softirqs: Make wakeup_softirqd static
    
    * 'x86-debug-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86, asm: Restore parentheses around one pushl_cfi argument
      x86, asm: Fix ancient-GAS workaround
      x86, asm: Fix CFI macro invocations to deal with shortcomings in gas
    
    * 'x86-numa-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86, numa: Assign CPUs to nodes in round-robin manner on fake NUMA
    
    * 'x86-quirks-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86: HPET force enable for CX700 / VIA Epia LT
    
    * 'x86-setup-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86, setup: Use string copy operation to optimze copy in kernel compression
    
    * 'x86-uv-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86, UV: Use allocated buffer in tlb_uv.c:tunables_read()
    
    * 'x86-vm86-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86, vm86: Fix preemption bug for int1 debug and int3 breakpoint handlers.

commit 4a60cfa9457749f7987fd4f3c956dbba5a281129
Merge: 62bea97f54d8 27afdf2008da
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 21 14:11:46 2010 -0700

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (96 commits)
      apic, x86: Use BIOS settings for IBS and MCE threshold interrupt LVT offsets
      apic, x86: Check if EILVT APIC registers are available (AMD only)
      x86: ioapic: Call free_irte only if interrupt remapping enabled
      arm: Use ARCH_IRQ_INIT_FLAGS
      genirq, ARM: Fix boot on ARM platforms
      genirq: Fix CONFIG_GENIRQ_NO_DEPRECATED=y build
      x86: Switch sparse_irq allocations to GFP_KERNEL
      genirq: Switch sparse_irq allocator to GFP_KERNEL
      genirq: Make sparse_lock a mutex
      x86: lguest: Use new irq allocator
      genirq: Remove the now unused sparse irq leftovers
      genirq: Sanitize dynamic irq handling
      genirq: Remove arch_init_chip_data()
      x86: xen: Sanitise sparse_irq handling
      x86: Use sane enumeration
      x86: uv: Clean up the direct access to irq_desc
      x86: Make io_apic.c local functions static
      genirq: Remove irq_2_iommu
      x86: Speed up the irq_remapped check in hot pathes
      intr_remap: Simplify the code further
      ...
    
    Fix up trivial conflicts in arch/x86/Kconfig

commit f4bc6bb2d562703eafc895c37e7be20906de139d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Oct 19 15:00:13 2010 +0200

    tracing: Cleanup the convoluted softirq tracepoints
    
    With the addition of trace_softirq_raise() the softirq tracepoint got
    even more convoluted. Why the tracepoints take two pointers to assign
    an integer is beyond my comprehension.
    
    But adding an extra case which treats the first pointer as an unsigned
    long when the second pointer is NULL including the back and forth
    type casting is just horrible.
    
    Convert the softirq tracepoints to take a single unsigned int argument
    for the softirq vector number and fix the call sites.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    LKML-Reference: <alpine.LFD.2.00.1010191428560.6815@localhost6.localdomain6>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Acked-by: mathieu.desnoyers@efficios.com
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 531495db1708..0ac194946fec 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -410,7 +410,7 @@ extern void open_softirq(int nr, void (*action)(struct softirq_action *));
 extern void softirq_init(void);
 static inline void __raise_softirq_irqoff(unsigned int nr)
 {
-	trace_softirq_raise((struct softirq_action *)(unsigned long)nr, NULL);
+	trace_softirq_raise(nr);
 	or_softirq_pending(1UL << nr);
 }
 

commit b7d0d8258a9f71949b810e0f82a3d75088f4d364
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 29 18:44:23 2010 +0200

    genirq: Remove arch_init_chip_data()
    
    This function should have not been there in the first place.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index a0384a4d1e6f..19988983aeac 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -641,11 +641,8 @@ static inline void init_irq_proc(void)
 struct seq_file;
 int show_interrupts(struct seq_file *p, void *v);
 
-struct irq_desc;
-
 extern int early_irq_init(void);
 extern int arch_probe_nr_irqs(void);
 extern int arch_early_irq_init(void);
-extern int arch_init_chip_data(struct irq_desc *desc, int node);
 
 #endif

commit 676cb02dc32adef13d9efb5ea52079e4ede1e3ec
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 20 23:33:49 2009 +0200

    softirqs: Make wakeup_softirqd static
    
    No users outside of kernel/softirq.c
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index a0384a4d1e6f..0a9141e69241 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -410,7 +410,6 @@ extern void softirq_init(void);
 #define __raise_softirq_irqoff(nr) do { or_softirq_pending(1UL << (nr)); } while (0)
 extern void raise_softirq_irqoff(unsigned int nr);
 extern void raise_softirq(unsigned int nr);
-extern void wakeup_softirqd(void);
 
 /* This is the worklist that queues up per-cpu softirq work.
  *

commit 2bf2160d8805de64308e2e7c3cd97813cb58ed2f
Author: Lai Jiangshan <laijs@cn.fujitsu.com>
Date:   Mon Aug 23 18:42:48 2010 +0900

    irq: Add tracepoint to softirq_raise
    
    Add a tracepoint for tracing when softirq action is raised.
    
    This and the existing tracepoints complete softirq's tracepoints:
    softirq_raise, softirq_entry and softirq_exit.
    
    And when this tracepoint is used in combination with
    the softirq_entry tracepoint we can determine
    the softirq raise latency.
    
    Signed-off-by: Lai Jiangshan <laijs@cn.fujitsu.com>
    Acked-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Cc: David Miller <davem@davemloft.net>
    Cc: Kaneshige Kenji <kaneshige.kenji@jp.fujitsu.com>
    Cc: Izumo Taku <izumi.taku@jp.fujitsu.com>
    Cc: Kosaki Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Cc: Lai Jiangshan <laijs@cn.fujitsu.com>
    Cc: Scott Mcmillan <scott.a.mcmillan@intel.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    LKML-Reference: <4C724298.4050509@jp.fujitsu.com>
    [ factorize softirq events with DECLARE_EVENT_CLASS ]
    Signed-off-by: Koki Sanagi <sanagi.koki@jp.fujitsu.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index a0384a4d1e6f..531495db1708 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -18,6 +18,7 @@
 #include <asm/atomic.h>
 #include <asm/ptrace.h>
 #include <asm/system.h>
+#include <trace/events/irq.h>
 
 /*
  * These correspond to the IORESOURCE_IRQ_* defines in
@@ -407,7 +408,12 @@ asmlinkage void do_softirq(void);
 asmlinkage void __do_softirq(void);
 extern void open_softirq(int nr, void (*action)(struct softirq_action *));
 extern void softirq_init(void);
-#define __raise_softirq_irqoff(nr) do { or_softirq_pending(1UL << (nr)); } while (0)
+static inline void __raise_softirq_irqoff(unsigned int nr)
+{
+	trace_softirq_raise((struct softirq_action *)(unsigned long)nr, NULL);
+	or_softirq_pending(1UL << nr);
+}
+
 extern void raise_softirq_irqoff(unsigned int nr);
 extern void raise_softirq(unsigned int nr);
 extern void wakeup_softirqd(void);

commit 685fd0b4ea3f0f1d5385610b0d5b57775a8d5842
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Jul 29 11:16:32 2010 +0100

    irq: Add new IRQ flag IRQF_NO_SUSPEND
    
    A small number of users of IRQF_TIMER are using it for the implied no
    suspend behaviour on interrupts which are not timer interrupts.
    
    Therefore add a new IRQF_NO_SUSPEND flag, rename IRQF_TIMER to
    __IRQF_TIMER and redefine IRQF_TIMER in terms of these new flags.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Cc: Jeremy Fitzhardinge <jeremy@goop.org>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: xen-devel@lists.xensource.com
    Cc: linux-input@vger.kernel.org
    Cc: linuxppc-dev@ozlabs.org
    Cc: devicetree-discuss@lists.ozlabs.org
    LKML-Reference: <1280398595-29708-1-git-send-email-ian.campbell@citrix.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index c2331138ca1b..a0384a4d1e6f 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -53,16 +53,21 @@
  * IRQF_ONESHOT - Interrupt is not reenabled after the hardirq handler finished.
  *                Used by threaded interrupts which need to keep the
  *                irq line disabled until the threaded handler has been run.
+ * IRQF_NO_SUSPEND - Do not disable this IRQ during suspend
+ *
  */
 #define IRQF_DISABLED		0x00000020
 #define IRQF_SAMPLE_RANDOM	0x00000040
 #define IRQF_SHARED		0x00000080
 #define IRQF_PROBE_SHARED	0x00000100
-#define IRQF_TIMER		0x00000200
+#define __IRQF_TIMER		0x00000200
 #define IRQF_PERCPU		0x00000400
 #define IRQF_NOBALANCING	0x00000800
 #define IRQF_IRQPOLL		0x00001000
 #define IRQF_ONESHOT		0x00002000
+#define IRQF_NO_SUSPEND		0x00004000
+
+#define IRQF_TIMER		(__IRQF_TIMER | IRQF_NO_SUSPEND)
 
 /*
  * Bits used by threaded handlers:

commit b4e6b09738fde057ce885703705f71cc953d0512
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Fri May 21 09:03:01 2010 -0700

    interrupt.h: fix fatal kernel-doc error
    
    Fix kernel-doc fatal error:
    /** beginning a non-kernel-doc comment block:
    (That alone does not kill kernel-doc, but the 'enum' was
    totally confusing to it.)
    
    Error(/lnx/src/TMP/linux-2.6.34-git6//include/linux/interrupt.h:88): cannot understand prototype: 'enum '
    make[2]: *** [Documentation/DocBook/genericirq.xml] Error 1
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 5137db3317f9..c2331138ca1b 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -78,7 +78,7 @@ enum {
 	IRQTF_AFFINITY,
 };
 
-/**
+/*
  * These values can be returned by request_any_context_irq() and
  * describe the context the interrupt will be run in.
  *

commit e7a297b0d7d6049bd4e423ac1e17da31e4c401b8
Author: Peter P Waskiewicz Jr <peter.p.waskiewicz.jr@intel.com>
Date:   Fri Apr 30 14:44:50 2010 -0700

    genirq: Add CPU mask affinity hint
    
    This patch adds a cpumask affinity hint to the irq_desc structure,
    along with a registration function and a read-only proc entry for each
    interrupt.
    
    This affinity_hint handle for each interrupt can be used by underlying
    drivers that need a better mechanism to control interrupt affinity.
    The underlying driver can register a cpumask for the interrupt, which
    will allow the driver to provide the CPU mask for the interrupt to
    anything that requests it.  The intent is to extend the userspace
    daemon, irqbalance, to help hint to it a preferred CPU mask to balance
    the interrupt into.
    
    [ tglx: Fixed compile warnings, added WARN_ON, made SMP only ]
    
    Signed-off-by: Peter P Waskiewicz Jr <peter.p.waskiewicz.jr@intel.com>
    Cc: davem@davemloft.net
    Cc: arjan@linux.jf.intel.com
    Cc: bhutchings@solarflare.com
    LKML-Reference: <20100430214445.3992.41647.stgit@ppwaskie-hc2.jf.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index e6d2f4441fda..5137db3317f9 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -233,6 +233,7 @@ extern int irq_set_affinity(unsigned int irq, const struct cpumask *cpumask);
 extern int irq_can_set_affinity(unsigned int irq);
 extern int irq_select_affinity(unsigned int irq);
 
+extern int irq_set_affinity_hint(unsigned int irq, const struct cpumask *m);
 #else /* CONFIG_SMP */
 
 static inline int irq_set_affinity(unsigned int irq, const struct cpumask *m)
@@ -247,6 +248,11 @@ static inline int irq_can_set_affinity(unsigned int irq)
 
 static inline int irq_select_affinity(unsigned int irq)  { return 0; }
 
+static inline int irq_set_affinity_hint(unsigned int irq,
+                                        const struct cpumask *m)
+{
+	return -EINVAL;
+}
 #endif /* CONFIG_SMP && CONFIG_GENERIC_HARDIRQS */
 
 #ifdef CONFIG_GENERIC_HARDIRQS

commit 6932bf37bed45ce8ed531928b1b0f98162fe6df6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 26 00:06:55 2010 +0000

    genirq: Remove IRQF_DISABLED from core code
    
    Remove all code which is related to IRQF_DISABLED from the core kernel
    code. IRQF_DISABLED still exists as a flag, but becomes a NOOP and
    will be removed after a grace period. That way we can easily revert to
    the previous behaviour by just restoring the core code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: David Miller <davem@davemloft.net>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Linus Torvalds <torvalds@osdl.org>
    LKML-Reference: <20100326000405.991244690@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index d7e7a7660c6c..e6d2f4441fda 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -39,7 +39,8 @@
  * These flags used only by the kernel as part of the
  * irq handling routines.
  *
- * IRQF_DISABLED - keep irqs disabled when calling the action handler
+ * IRQF_DISABLED - keep irqs disabled when calling the action handler.
+ *                 DEPRECATED. This flag is a NOOP and scheduled to be removed
  * IRQF_SAMPLE_RANDOM - irq is used to feed the random generator
  * IRQF_SHARED - allow sharing the irq among several devices
  * IRQF_PROBE_SHARED - set by callers when they expect sharing mismatches to occur

commit ae731f8d0785ccd3380f511bae888933b6562e45
Author: Marc Zyngier <maz@misterjones.org>
Date:   Mon Mar 15 22:56:33 2010 +0000

    genirq: Introduce request_any_context_irq()
    
    Now that we enjoy threaded interrupts, we're starting to see irq_chip
    implementations (wm831x, pca953x) that make use of threaded interrupts
    for the controller, and nested interrupts for the client interrupt. It
    all works very well, with one drawback:
    
    Drivers requesting an IRQ must now know whether the handler will
    run in a thread context or not, and call request_threaded_irq() or
    request_irq() accordingly.
    
    The problem is that the requesting driver sometimes doesn't know
    about the nature of the interrupt, specially when the interrupt
    controller is a discrete chip (typically a GPIO expander connected
    over I2C) that can be connected to a wide variety of otherwise perfectly
    supported hardware.
    
    This patch introduces the request_any_context_irq() function that mostly
    mimics the usual request_irq(), except that it checks whether the irq
    level is configured as nested or not, and calls the right backend.
    On success, it also returns either IRQC_IS_HARDIRQ or IRQC_IS_NESTED.
    
    [ tglx: Made return value an enum, simplified code and made the export
            of request_any_context_irq GPL ]
    
    Signed-off-by: Marc Zyngier <maz@misterjones.org>
    Cc: <joachim.eastwood@jotron.com>
    LKML-Reference: <927ea285bd0c68934ddae1a47e44a9ba@localhost>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 75f3f00ac1e5..d7e7a7660c6c 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -77,6 +77,18 @@ enum {
 	IRQTF_AFFINITY,
 };
 
+/**
+ * These values can be returned by request_any_context_irq() and
+ * describe the context the interrupt will be run in.
+ *
+ * IRQC_IS_HARDIRQ - interrupt runs in hardirq context
+ * IRQC_IS_NESTED - interrupt runs in a nested threaded context
+ */
+enum {
+	IRQC_IS_HARDIRQ	= 0,
+	IRQC_IS_NESTED,
+};
+
 typedef irqreturn_t (*irq_handler_t)(int, void *);
 
 /**
@@ -120,6 +132,10 @@ request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
 	return request_threaded_irq(irq, handler, NULL, flags, name, dev);
 }
 
+extern int __must_check
+request_any_context_irq(unsigned int irq, irq_handler_t handler,
+			unsigned long flags, const char *name, void *dev_id);
+
 extern void exit_irq_thread(void);
 #else
 
@@ -141,6 +157,13 @@ request_threaded_irq(unsigned int irq, irq_handler_t handler,
 	return request_irq(irq, handler, flags, name, dev);
 }
 
+static inline int __must_check
+request_any_context_irq(unsigned int irq, irq_handler_t handler,
+			unsigned long flags, const char *name, void *dev_id)
+{
+	return request_irq(irq, handler, flags, name, dev_id);
+}
+
 static inline void exit_irq_thread(void) { }
 #endif
 

commit 663e69592856df53ef52969482ef413a96bc4e06
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Nov 4 14:22:21 2009 +0100

    irq: Remove unused debug_poll_all_shared_irqs()
    
    commit 74296a8ed added this function for debug purposes, but it was
    never used for anything. Remove it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 7ca72b74eec7..75f3f00ac1e5 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -603,12 +603,6 @@ static inline void init_irq_proc(void)
 }
 #endif
 
-#if defined(CONFIG_GENERIC_HARDIRQS) && defined(CONFIG_DEBUG_SHIRQ)
-extern void debug_poll_all_shared_irqs(void);
-#else
-static inline void debug_poll_all_shared_irqs(void) { }
-#endif
-
 struct seq_file;
 int show_interrupts(struct seq_file *p, void *v);
 

commit d43c36dc6b357fa1806800f18aa30123c747a6d1
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Oct 7 17:09:06 2009 +0400

    headers: remove sched.h from interrupt.h
    
    After m68k's task_thread_info() doesn't refer to current,
    it's possible to remove sched.h from interrupt.h and not break m68k!
    Many thanks to Heiko Carstens for allowing this.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index b78cf8194957..7ca72b74eec7 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -10,7 +10,6 @@
 #include <linux/irqreturn.h>
 #include <linux/irqnr.h>
 #include <linux/hardirq.h>
-#include <linux/sched.h>
 #include <linux/irqflags.h>
 #include <linux/smp.h>
 #include <linux/percpu.h>
@@ -610,6 +609,7 @@ extern void debug_poll_all_shared_irqs(void);
 static inline void debug_poll_all_shared_irqs(void) { }
 #endif
 
+struct seq_file;
 int show_interrupts(struct seq_file *p, void *v);
 
 struct irq_desc;

commit 144e2ce6115c0a1ee4cb5c935360ea4e2966b0ce
Author: Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
Date:   Mon Jun 15 12:16:54 2009 +0900

    cpumask: Remove mask field from comments
    
    By 7be23e278f, mask field was deleted by irqaction. However, it was not
    deleted from comment.
    
    Signed-off-by: Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
    CC: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 894ed7180bff..b78cf8194957 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -84,7 +84,6 @@ typedef irqreturn_t (*irq_handler_t)(int, void *);
  * struct irqaction - per interrupt action descriptor
  * @handler:	interrupt handler function
  * @flags:	flags (see IRQF_* above)
- * @mask:	no comment as it is useless and about to be removed
  * @name:	name of the device
  * @dev_id:	cookie to identify the device
  * @next:	pointer to the next irqaction for shared interrupts

commit ef79f8e191722dbc1fc33bdfc448f572266c37e9
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Sep 24 09:34:37 2009 -0600

    cpumask: remove unused mask field from struct irqaction.
    
    Up until 1.1.83, the primitive human tribes used struct sigaction for
    interrupts.  The sa_mask field was overloaded to hold a pointer to the
    name.
    
    When someone created the new "struct irqaction" they carried across
    the "mask" field as a kind of ancestor worship: the fact that it was
    unused makes clear its spiritual significance.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 8e9e151f811e..894ed7180bff 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -97,7 +97,6 @@ typedef irqreturn_t (*irq_handler_t)(int, void *);
 struct irqaction {
 	irq_handler_t handler;
 	unsigned long flags;
-	cpumask_t mask;
 	const char *name;
 	void *dev_id;
 	struct irqaction *next;

commit 355bbd8cb82e60a592f6cd86ce6dbe5677615cf4
Merge: 39695224bd84 746cd1e7e4a5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Sep 14 17:55:15 2009 -0700

    Merge branch 'for-2.6.32' of git://git.kernel.dk/linux-2.6-block
    
    * 'for-2.6.32' of git://git.kernel.dk/linux-2.6-block: (29 commits)
      block: use blkdev_issue_discard in blk_ioctl_discard
      Make DISCARD_BARRIER and DISCARD_NOBARRIER writes instead of reads
      block: don't assume device has a request list backing in nr_requests store
      block: Optimal I/O limit wrapper
      cfq: choose a new next_req when a request is dispatched
      Seperate read and write statistics of in_flight requests
      aoe: end barrier bios with EOPNOTSUPP
      block: trace bio queueing trial only when it occurs
      block: enable rq CPU completion affinity by default
      cfq: fix the log message after dispatched a request
      block: use printk_once
      cciss: memory leak in cciss_init_one()
      splice: update mtime and atime on files
      block: make blk_iopoll_prep_sched() follow normal 0/1 return convention
      cfq-iosched: get rid of must_alloc flag
      block: use interrupts disabled version of raise_softirq_irqoff()
      block: fix comment in blk-iopoll.c
      block: adjust default budget for blk-iopoll
      block: fix long lines in block/blk-iopoll.c
      block: add blk-iopoll, a NAPI like approach for block devices
      ...

commit 5e605b64a183a6c0e84cdb99a6f8acb1f8200437
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Wed Aug 5 09:07:21 2009 +0200

    block: add blk-iopoll, a NAPI like approach for block devices
    
    This borrows some code from NAPI and implements a polled completion
    mode for block devices. The idea is the same as NAPI - instead of
    doing the command completion when the irq occurs, schedule a dedicated
    softirq in the hopes that we will complete more IO when the iopoll
    handler is invoked. Devices have a budget of commands assigned, and will
    stay in polled mode as long as they continue to consume their budget
    from the iopoll softirq handler. If they do not, the device is set back
    to interrupt completion mode.
    
    This patch holds the core bits for blk-iopoll, device driver support
    sold separately.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 35e7df1e9f30..edd8d5c90394 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -344,6 +344,7 @@ enum
 	NET_TX_SOFTIRQ,
 	NET_RX_SOFTIRQ,
 	BLOCK_SOFTIRQ,
+	BLOCK_IOPOLL_SOFTIRQ,
 	TASKLET_SOFTIRQ,
 	SCHED_SOFTIRQ,
 	HRTIMER_SOFTIRQ,

commit b25c340c195447afb1860da580fe2a85a6b652c5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 13 12:17:22 2009 +0200

    genirq: Add oneshot support
    
    For threaded interrupt handlers we expect the hard interrupt handler
    part to mask the interrupt on the originating device. The interrupt
    line itself is reenabled after the hard interrupt handler has
    executed.
    
    This requires access to the originating device from hard interrupt
    context which is not always possible. There are devices which can only
    be accessed via a bus (i2c, spi, ...). The bus access requires thread
    context. For such devices we need to keep the interrupt line masked
    until the threaded handler has executed.
    
    Add a new flag IRQF_ONESHOT which allows drivers to request that the
    interrupt is not unmasked after the hard interrupt context handler has
    been executed and the thread has been woken. The interrupt line is
    unmasked after the thread handler function has been executed.
    
    Note that for now IRQF_ONESHOT cannot be used with IRQF_SHARED to
    avoid complex accounting mechanisms.
    
    For oneshot interrupts the primary handler simply returns
    IRQ_WAKE_THREAD and does nothing else. A generic implementation
    irq_default_primary_handler() is provided to avoid useless copies all
    over the place. It is automatically installed when
    request_threaded_irq() is called with handler=NULL and
    thread_fn!=NULL.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Trilok Soni <soni.trilok@gmail.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Brian Swetland <swetland@google.com>
    Cc: Joonyoung Shim <jy0922.shim@samsung.com>
    Cc: m.szyprowski@samsung.com
    Cc: t.fujak@samsung.com
    Cc: kyungmin.park@samsung.com,
    Cc: David Brownell <david-b@pacbell.net>
    Cc: Daniel Ribeiro <drwyrm@gmail.com>
    Cc: arve@android.com
    Cc: Barry Song <21cnbao@gmail.com>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 35e7df1e9f30..1ac57e522a1f 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -50,6 +50,9 @@
  * IRQF_IRQPOLL - Interrupt is used for polling (only the interrupt that is
  *                registered first in an shared interrupt is considered for
  *                performance reasons)
+ * IRQF_ONESHOT - Interrupt is not reenabled after the hardirq handler finished.
+ *                Used by threaded interrupts which need to keep the
+ *                irq line disabled until the threaded handler has been run.
  */
 #define IRQF_DISABLED		0x00000020
 #define IRQF_SAMPLE_RANDOM	0x00000040
@@ -59,6 +62,7 @@
 #define IRQF_PERCPU		0x00000400
 #define IRQF_NOBALANCING	0x00000800
 #define IRQF_IRQPOLL		0x00001000
+#define IRQF_ONESHOT		0x00002000
 
 /*
  * Bits used by threaded handlers:

commit 612e900c286a9535cc17da5171b0d8dcf8f3a12f
Merge: c57c3743784e 9ba5f005c994
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 22 10:12:18 2009 -0700

    Merge branch 'core-fixes-for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'core-fixes-for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      softirq: introduce tasklet_hrtimer infrastructure

commit 9ba5f005c994ad28e266a0cd14ef29354be382c9
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Wed Jul 22 14:18:35 2009 +0200

    softirq: introduce tasklet_hrtimer infrastructure
    
    commit ca109491f (hrtimer: removing all ur callback modes) moved all
    hrtimer callbacks into hard interrupt context when high resolution
    timers are active. That breaks code which relied on the assumption
    that the callback happens in softirq context.
    
    Provide a generic infrastructure which combines tasklets and hrtimers
    together to provide an in-softirq hrtimer experience.
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: torvalds@linux-foundation.org
    Cc: kaber@trash.net
    Cc: David Miller <davem@davemloft.net>
    LKML-Reference: <1248265724.27058.1366.camel@twins>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 2721f07e9354..fd4c9c63c757 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -14,6 +14,7 @@
 #include <linux/irqflags.h>
 #include <linux/smp.h>
 #include <linux/percpu.h>
+#include <linux/hrtimer.h>
 
 #include <asm/atomic.h>
 #include <asm/ptrace.h>
@@ -517,6 +518,31 @@ extern void tasklet_kill_immediate(struct tasklet_struct *t, unsigned int cpu);
 extern void tasklet_init(struct tasklet_struct *t,
 			 void (*func)(unsigned long), unsigned long data);
 
+struct tasklet_hrtimer {
+	struct hrtimer		timer;
+	struct tasklet_struct	tasklet;
+	enum hrtimer_restart	(*function)(struct hrtimer *);
+};
+
+extern void
+tasklet_hrtimer_init(struct tasklet_hrtimer *ttimer,
+		     enum hrtimer_restart (*function)(struct hrtimer *),
+		     clockid_t which_clock, enum hrtimer_mode mode);
+
+static inline
+int tasklet_hrtimer_start(struct tasklet_hrtimer *ttimer, ktime_t time,
+			  const enum hrtimer_mode mode)
+{
+	return hrtimer_start(&ttimer->timer, time, mode);
+}
+
+static inline
+void tasklet_hrtimer_cancel(struct tasklet_hrtimer *ttimer)
+{
+	hrtimer_cancel(&ttimer->timer);
+	tasklet_kill(&ttimer->tasklet);
+}
+
 /*
  * Autoprobing for irqs:
  *

commit 591d2fb02ea80472d846c0b8507007806bdd69cc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 21 11:09:39 2009 +0200

    genirq: Delegate irq affinity setting to the irq thread
    
    irq_set_thread_affinity() calls set_cpus_allowed_ptr() which might
    sleep, but irq_set_thread_affinity() is called with desc->lock held
    and can be called from hard interrupt context as well. The code has
    another bug as it does not hold a ref on the task struct as required
    by set_cpus_allowed_ptr().
    
    Just set the IRQTF_AFFINITY bit in action->thread_flags. The next time
    the thread runs it migrates itself. Solves all of the above problems
    nicely.
    
    Add kerneldoc to irq_set_thread_affinity() while at it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    LKML-Reference: <new-submission>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 2721f07e9354..88b056ac5629 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -64,11 +64,13 @@
  * IRQTF_RUNTHREAD - signals that the interrupt handler thread should run
  * IRQTF_DIED      - handler thread died
  * IRQTF_WARNED    - warning "IRQ_WAKE_THREAD w/o thread_fn" has been printed
+ * IRQTF_AFFINITY  - irq thread is requested to adjust affinity
  */
 enum {
 	IRQTF_RUNTHREAD,
 	IRQTF_DIED,
 	IRQTF_WARNED,
+	IRQTF_AFFINITY,
 };
 
 typedef irqreturn_t (*irq_handler_t)(int, void *);

commit 722f2a6c87f34ee0fd0130a8cf45f81e0705594a
Merge: 7a0aeb14e18a 45e3e1935e28
Author: Vegard Nossum <vegard.nossum@gmail.com>
Date:   Mon Jun 15 15:50:49 2009 +0200

    Merge commit 'linus/master' into HEAD
    
    Conflicts:
            MAINTAINERS
    
    Signed-off-by: Vegard Nossum <vegard.nossum@gmail.com>

commit 7c692cbade8b8884f1c20500393bcc7cd6d24ef8
Author: Vegard Nossum <vegard.nossum@gmail.com>
Date:   Wed May 21 22:53:13 2008 +0200

    tasklets: new tasklet scheduling function
    
    Rationale: kmemcheck needs to be able to schedule a tasklet without
    touching any dynamically allocated memory _at_ _all_ (since that would
    lead to a recursive page fault). This tasklet is used for writing the
    error reports to the kernel log.
    
    The new scheduling function avoids touching any other tasklets by
    inserting the new tasklist as the head of the "tasklet_hi" list instead
    of on the tail.
    
    Also don't wake up the softirq thread lest the scheduler access some
    tracked memory and we go down with a recursive page fault.
    
    In this case, we'd better just wait for the maximum time of 1/HZ for the
    message to appear.
    
    Signed-off-by: Vegard Nossum <vegard.nossum@gmail.com>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index ff374ceface0..dd574d51bcaa 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -466,6 +466,20 @@ static inline void tasklet_hi_schedule(struct tasklet_struct *t)
 		__tasklet_hi_schedule(t);
 }
 
+extern void __tasklet_hi_schedule_first(struct tasklet_struct *t);
+
+/*
+ * This version avoids touching any other tasklets. Needed for kmemcheck
+ * in order not to take any page faults while enqueueing this tasklet;
+ * consider VERY carefully whether you really need this or
+ * tasklet_hi_schedule()...
+ */
+static inline void tasklet_hi_schedule_first(struct tasklet_struct *t)
+{
+	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
+		__tasklet_hi_schedule_first(t);
+}
+
 
 static inline void tasklet_disable_nosync(struct tasklet_struct *t)
 {

commit 5818a6e2519b34cd6d0220d89f5729ab2725e1bf
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Thu Jun 11 21:59:21 2009 +0200

    PM: Add empty suspend/resume device irq functions
    
    git commit 0a0c5168 "PM: Introduce functions for suspending and resuming
    device interrupts" introduced some helper functions. However these
    functions are only available for architectures which support
    GENERIC_HARDIRQS.
    
    Other architectures will see this build error:
    
    drivers/built-in.o: In function `sysdev_suspend':
    (.text+0x15138): undefined reference to `check_wakeup_irqs'
    drivers/built-in.o: In function `device_power_up':
    (.text+0x1cb66): undefined reference to `resume_device_irqs'
    drivers/built-in.o: In function `device_power_down':
    (.text+0x1cb92): undefined reference to `suspend_device_irqs'
    
    To fix this add some empty inline functions for !GENERIC_HARDIRQS.
    
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index ff374ceface0..c41e812e9d5e 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -183,6 +183,7 @@ extern void disable_irq(unsigned int irq);
 extern void enable_irq(unsigned int irq);
 
 /* The following three functions are for the core kernel use only. */
+#ifdef CONFIG_GENERIC_HARDIRQS
 extern void suspend_device_irqs(void);
 extern void resume_device_irqs(void);
 #ifdef CONFIG_PM_SLEEP
@@ -190,6 +191,11 @@ extern int check_wakeup_irqs(void);
 #else
 static inline int check_wakeup_irqs(void) { return 0; }
 #endif
+#else
+static inline void suspend_device_irqs(void) { };
+static inline void resume_device_irqs(void) { };
+static inline int check_wakeup_irqs(void) { return 0; }
+#endif
 
 #if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_HARDIRQS)
 

commit 85ac16d033370caf6f48d743c8dc8103700f5cc5
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Apr 27 18:00:38 2009 -0700

    x86/irq: change irq_desc_alloc() to take node instead of cpu
    
    This simplifies the node awareness of the code. All our allocators
    only deal with a NUMA node ID locality not with CPU ids anyway - so
    there's no need to maintain (and transform) a CPU id all across the
    IRq layer.
    
    v2: keep move_irq_desc related
    
    [ Impact: cleanup, prepare IRQ code to be NUMA-aware ]
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Jeremy Fitzhardinge <jeremy@goop.org>
    LKML-Reference: <49F65536.2020300@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 91bb76f44f14..ff374ceface0 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -566,6 +566,6 @@ struct irq_desc;
 extern int early_irq_init(void);
 extern int arch_probe_nr_irqs(void);
 extern int arch_early_irq_init(void);
-extern int arch_init_chip_data(struct irq_desc *desc, int cpu);
+extern int arch_init_chip_data(struct irq_desc *desc, int node);
 
 #endif

commit c61b79b6ef266890954213a701d8f6021d8c1289
Merge: 2b2ec7554cf7 9efe21cb82b5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 7 14:07:52 2009 -0700

    Merge branch 'irq/threaded' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'irq/threaded' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      genirq: fix devres.o build for GENERIC_HARDIRQS=n
      genirq: provide old request_irq() for CONFIG_GENERIC_HARDIRQ=n
      genirq: threaded irq handlers review fixups
      genirq: add support for threaded interrupts to devres
      genirq: add threaded interrupt handler support

commit 609862be074cc20e007c640fd936ffe798b41abc
Merge: 12fe32e4f942 eedeeabdeead
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 6 13:37:30 2009 -0700

    Merge branch 'locking-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'locking-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      lockdep: add stack dumps to asserts
      hrtimer: fix rq->lock inversion (again)

commit 9efe21cb82b5dbe3b0b2ae4de4eccc64ecb94e95
Merge: de18836e447c 0221c81b1b8e
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Apr 6 01:41:22 2009 +0200

    Merge branch 'linus' into irq/threaded
    
    Conflicts:
            include/linux/irq.h
            kernel/irq/handle.c

commit 8302294f43250dc337108c51882a6007f2b1e2e0
Merge: 4fe70410d9a2 2e572895bf32
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Apr 1 21:54:19 2009 +0200

    Merge branch 'tracing/core-v2' into tracing-for-linus
    
    Conflicts:
            include/linux/slub_def.h
            lib/Kconfig.debug
            mm/slob.c
            mm/slub.c

commit 7f1e2ca9f04b02794597f60e7b1d43f0a1317939
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Fri Mar 13 12:21:27 2009 +0100

    hrtimer: fix rq->lock inversion (again)
    
    It appears I inadvertly introduced rq->lock recursion to the
    hrtimer_start() path when I delegated running already expired
    timers to softirq context.
    
    This patch fixes it by introducing a __hrtimer_start_range_ns()
    method that will not use raise_softirq_irqoff() but
    __raise_softirq_irqoff() which avoids the wakeup.
    
    It then also changes schedule() to check for pending softirqs and
    do the wakeup then, I'm not quite sure I like this last bit, nor
    am I convinced its really needed.
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: paulus@samba.org
    LKML-Reference: <20090313112301.096138802@chello.nl>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index c68bffd182bb..4528bf70866a 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -294,6 +294,7 @@ extern void softirq_init(void);
 #define __raise_softirq_irqoff(nr) do { or_softirq_pending(1UL << (nr)); } while (0)
 extern void raise_softirq_irqoff(unsigned int nr);
 extern void raise_softirq(unsigned int nr);
+extern void wakeup_softirqd(void);
 
 /* This is the worklist that queues up per-cpu softirq work.
  *

commit 0a0c5168df270a50e3518e4f12bddb31f8f5f38f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Mar 16 22:33:49 2009 +0100

    PM: Introduce functions for suspending and resuming device interrupts
    
    Introduce helper functions allowing us to prevent device drivers from
    getting any interrupts (without disabling interrupts on the CPU)
    during suspend (or hibernation) and to make them start to receive
    interrupts again during the subsequent resume.  These functions make it
    possible to keep timer interrupts enabled while the "late" suspend and
    "early" resume callbacks provided by device drivers are being
    executed.  In turn, this allows device drivers' "late" suspend and
    "early" resume callbacks to sleep, execute ACPI callbacks etc.
    
    The functions introduced here will be used to rework the handling of
    interrupts during suspend (hibernation) and resume.  Namely,
    interrupts will only be disabled on the CPU right before suspending
    sysdevs, while device drivers will be prevented from receiving
    interrupts, with the help of the new helper function, before their
    "late" suspend callbacks run (and analogously during resume).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 0c9cb63e6895..c68bffd182bb 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -117,6 +117,15 @@ extern void disable_irq_nosync(unsigned int irq);
 extern void disable_irq(unsigned int irq);
 extern void enable_irq(unsigned int irq);
 
+/* The following three functions are for the core kernel use only. */
+extern void suspend_device_irqs(void);
+extern void resume_device_irqs(void);
+#ifdef CONFIG_PM_SLEEP
+extern int check_wakeup_irqs(void);
+#else
+static inline int check_wakeup_irqs(void) { return 0; }
+#endif
+
 #if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_HARDIRQS)
 
 extern cpumask_var_t irq_default_affinity;

commit 6e15cf04860074ad032e88c306bea656bbdd0f22
Merge: be0ea69674ed 60db56422043
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Mar 26 21:39:17 2009 +0100

    Merge branch 'core/percpu' into percpu-cpumask-x86-for-linus-2
    
    Conflicts:
            arch/parisc/kernel/irq.c
            arch/x86/include/asm/fixmap_64.h
            arch/x86/include/asm/setup.h
            kernel/irq/handle.c
    
    Semantic merge:
            arch/x86/include/asm/fixmap.h
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit de18836e447c2dc30120c0919b8db8ddc0401cc4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 25 17:33:38 2009 +0100

    genirq: fix devres.o build for GENERIC_HARDIRQS=n
    
    kernel/irq/devres.c is built by sparc (32bit) and m68k via the obscure
    ../../../kernel/irq/devres.o reference in arch/[sparc/m68k]/kernel/Makefile
    
    To avoid ifdeffery in devres.c provide request_threaded_irq as an
    inline for these users.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 7e63b824833f..143192f48bf3 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -123,6 +123,20 @@ extern int __must_check
 request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
 	    const char *name, void *dev);
 
+/*
+ * Special function to avoid ifdeffery in kernel/irq/devres.c which
+ * gets magically built by GENERIC_HARDIRQS=n architectures (sparc,
+ * m68k). I really love these $@%#!* obvious Makefile references:
+ * ../../../kernel/irq/devres.o
+ */
+static inline int __must_check
+request_threaded_irq(unsigned int irq, irq_handler_t handler,
+		     irq_handler_t thread_fn,
+		     unsigned long flags, const char *name, void *dev)
+{
+	return request_irq(irq, handler, flags, name, dev);
+}
+
 static inline void exit_irq_thread(void) { }
 #endif
 

commit 3a38148f0488069cadb75c4a6909954072d648bf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Mar 24 20:27:39 2009 +0100

    genirq: provide old request_irq() for CONFIG_GENERIC_HARDIRQ=n
    
    Impact: Undo compile breakage for archs with CONFIG_GENERIC_HARDIRQ=n
    
    The threaded interrupt handler patches changed request_irq from extern
    to inline. Architectures which do not use the generic irq code still
    have request_irq() as a global function and therefor fail to compile.
    
    Keep the extern declaration for CONFIG_GENERIC_HARDIRQ=n
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 266a5f5f57cc..7e63b824833f 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -103,6 +103,7 @@ struct irqaction {
 
 extern irqreturn_t no_action(int cpl, void *dev_id);
 
+#ifdef CONFIG_GENERIC_HARDIRQS
 extern int __must_check
 request_threaded_irq(unsigned int irq, irq_handler_t handler,
 		     irq_handler_t thread_fn,
@@ -115,9 +116,13 @@ request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
 	return request_threaded_irq(irq, handler, NULL, flags, name, dev);
 }
 
-#ifdef CONFIG_GENERIC_HARDIRQS
 extern void exit_irq_thread(void);
 #else
+
+extern int __must_check
+request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
+	    const char *name, void *dev);
+
 static inline void exit_irq_thread(void) { }
 #endif
 

commit f48fe81e5b032914183e9a17052313720c2cac56
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Mar 24 11:46:22 2009 +0100

    genirq: threaded irq handlers review fixups
    
    Delta patch to address the review comments.
    
          - Implement warning when IRQ_WAKE_THREAD is requested and no
            thread handler installed
          - coding style fixes
    
    Pointed-out-by: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index dbf6a6fd116c..266a5f5f57cc 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -63,10 +63,12 @@
  * Bits used by threaded handlers:
  * IRQTF_RUNTHREAD - signals that the interrupt handler thread should run
  * IRQTF_DIED      - handler thread died
+ * IRQTF_WARNED    - warning "IRQ_WAKE_THREAD w/o thread_fn" has been printed
  */
 enum {
 	IRQTF_RUNTHREAD,
 	IRQTF_DIED,
+	IRQTF_WARNED,
 };
 
 typedef irqreturn_t (*irq_handler_t)(int, void *);

commit 935bd5b971f0df7c06d214d022cf8392e2f37952
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Mar 23 18:28:16 2009 +0100

    genirq: add support for threaded interrupts to devres
    
    Some devices use devres_request_irq() for to install their interrupt
    handler. Add support for threaded interrupts to devres as well.
    
    [tglx - simplified and adapted to latest threadirq version]
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 6fc2b720c231..dbf6a6fd116c 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -123,9 +123,20 @@ extern void free_irq(unsigned int, void *);
 
 struct device;
 
-extern int __must_check devm_request_irq(struct device *dev, unsigned int irq,
-			    irq_handler_t handler, unsigned long irqflags,
-			    const char *devname, void *dev_id);
+extern int __must_check
+devm_request_threaded_irq(struct device *dev, unsigned int irq,
+			  irq_handler_t handler, irq_handler_t thread_fn,
+			  unsigned long irqflags, const char *devname,
+			  void *dev_id);
+
+static inline int __must_check
+devm_request_irq(struct device *dev, unsigned int irq, irq_handler_t handler,
+		 unsigned long irqflags, const char *devname, void *dev_id)
+{
+	return devm_request_threaded_irq(dev, irq, handler, NULL, irqflags,
+					 devname, dev_id);
+}
+
 extern void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id);
 
 /*

commit 3aa551c9b4c40018f0e261a178e3d25478dc04a9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 23 18:28:15 2009 +0100

    genirq: add threaded interrupt handler support
    
    Add support for threaded interrupt handlers:
    
    A device driver can request that its main interrupt handler runs in a
    thread. To achive this the device driver requests the interrupt with
    request_threaded_irq() and provides additionally to the handler a
    thread function. The handler function is called in hard interrupt
    context and needs to check whether the interrupt originated from the
    device. If the interrupt originated from the device then the handler
    can either return IRQ_HANDLED or IRQ_WAKE_THREAD. IRQ_HANDLED is
    returned when no further action is required. IRQ_WAKE_THREAD causes
    the genirq code to invoke the threaded (main) handler. When
    IRQ_WAKE_THREAD is returned handler must have disabled the interrupt
    on the device level. This is mandatory for shared interrupt handlers,
    but we need to do it as well for obscure x86 hardware where disabling
    an interrupt on the IO_APIC level redirects the interrupt to the
    legacy PIC interrupt lines.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 0c9cb63e6895..6fc2b720c231 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -59,6 +59,16 @@
 #define IRQF_NOBALANCING	0x00000800
 #define IRQF_IRQPOLL		0x00001000
 
+/*
+ * Bits used by threaded handlers:
+ * IRQTF_RUNTHREAD - signals that the interrupt handler thread should run
+ * IRQTF_DIED      - handler thread died
+ */
+enum {
+	IRQTF_RUNTHREAD,
+	IRQTF_DIED,
+};
+
 typedef irqreturn_t (*irq_handler_t)(int, void *);
 
 /**
@@ -71,6 +81,9 @@ typedef irqreturn_t (*irq_handler_t)(int, void *);
  * @next:	pointer to the next irqaction for shared interrupts
  * @irq:	interrupt number
  * @dir:	pointer to the proc/irq/NN/name entry
+ * @thread_fn:	interupt handler function for threaded interrupts
+ * @thread:	thread pointer for threaded interrupts
+ * @thread_flags:	flags related to @thread
  */
 struct irqaction {
 	irq_handler_t handler;
@@ -81,11 +94,31 @@ struct irqaction {
 	struct irqaction *next;
 	int irq;
 	struct proc_dir_entry *dir;
+	irq_handler_t thread_fn;
+	struct task_struct *thread;
+	unsigned long thread_flags;
 };
 
 extern irqreturn_t no_action(int cpl, void *dev_id);
-extern int __must_check request_irq(unsigned int, irq_handler_t handler,
-		       unsigned long, const char *, void *);
+
+extern int __must_check
+request_threaded_irq(unsigned int irq, irq_handler_t handler,
+		     irq_handler_t thread_fn,
+		     unsigned long flags, const char *name, void *dev);
+
+static inline int __must_check
+request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
+	    const char *name, void *dev)
+{
+	return request_threaded_irq(irq, handler, NULL, flags, name, dev);
+}
+
+#ifdef CONFIG_GENERIC_HARDIRQS
+extern void exit_irq_thread(void);
+#else
+static inline void exit_irq_thread(void) { }
+#endif
+
 extern void free_irq(unsigned int, void *);
 
 struct device;

commit 80c5520811d3805adcb15c570ea5e2d489fa5d0b
Merge: b3e3b302cf6d 8c083f081d00
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 23 14:50:03 2009 +0100

    Merge branch 'cpus4096' into irq/threaded
    
    Conflicts:
            arch/parisc/kernel/irq.c
            kernel/irq/handle.c
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit a9d0a1a38352c4fb8946e73b3e42ba4ada29e733
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Mar 3 16:58:16 2009 +0100

    genirq: add doc to struct irqaction
    
    Impact: documentation
    
    struct irqaction is not documented. Add kernel doc comments and add
    interrupt.h to the genirq docbook.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 468e3a25a4a1..91658d076598 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -61,6 +61,17 @@
 
 typedef irqreturn_t (*irq_handler_t)(int, void *);
 
+/**
+ * struct irqaction - per interrupt action descriptor
+ * @handler:	interrupt handler function
+ * @flags:	flags (see IRQF_* above)
+ * @mask:	no comment as it is useless and about to be removed
+ * @name:	name of the device
+ * @dev_id:	cookie to identify the device
+ * @next:	pointer to the next irqaction for shared interrupts
+ * @irq:	interrupt number
+ * @dir:	pointer to the proc/irq/NN/name entry
+ */
 struct irqaction {
 	irq_handler_t handler;
 	unsigned long flags;

commit 5d592b44b29a1d73e13d5c9e3426eed843bdc359
Author: Jason Baron <jbaron@redhat.com>
Date:   Thu Mar 12 14:33:36 2009 -0400

    tracing: tracepoints for softirq entry/exit - add softirq-to-name array
    
    Create a 'softirq_to_name' array, which is indexed by softirq #, so
    that we can easily convert between the softirq index # and its name, in
    order to get more meaningful output messages.
    
    LKML-Reference: <20090312183336.GB3352@redhat.com>
    Signed-off-by: Jason Baron <jbaron@redhat.com>
    Signed-off-by: Steven Rostedt <srostedt@redhat.com>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 472f11765f60..9b7e9d743476 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -258,6 +258,11 @@ enum
 	NR_SOFTIRQS
 };
 
+/* map softirq index to softirq name. update 'softirq_to_name' in
+ * kernel/softirq.c when adding a new softirq.
+ */
+extern char *softirq_to_name[NR_SOFTIRQS];
+
 /* softirq mask and active fields moved to irq_cpustat_t in
  * asm/hardirq.h to get better cache usage.  KAO
  */

commit 74296a8ed6aa3c5bf672808ada690de7ba323ecc
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Jan 16 17:43:50 2009 +0100

    irq: provide debug_poll_all_shared_irqs() method under CONFIG_DEBUG_SHIRQ
    
    Provide a shared interrupt debug facility under CONFIG_DEBUG_SHIRQ:
    it uses the existing irqpoll facilities to iterate through all
    registered interrupt handlers and call those which can handle shared
    IRQ lines.
    
    This can be handy for suspend/resume debugging: if we call this function
    early during resume we can trigger crashes in those drivers which have
    incorrect assumptions about when exactly their ISRs will be called
    during suspend/resume.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 9127f6b51a39..468e3a25a4a1 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -462,6 +462,12 @@ static inline void init_irq_proc(void)
 }
 #endif
 
+#if defined(CONFIG_GENERIC_HARDIRQS) && defined(CONFIG_DEBUG_SHIRQ)
+extern void debug_poll_all_shared_irqs(void);
+#else
+static inline void debug_poll_all_shared_irqs(void) { }
+#endif
+
 int show_interrupts(struct seq_file *p, void *v);
 
 struct irq_desc;

commit 4a046d1754ee6ebb6f399696805ed61ea0444d4c
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Jan 12 17:39:24 2009 -0800

    x86: arch_probe_nr_irqs
    
    Impact: save RAM with large NR_CPUS, get smaller nr_irqs
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Mike Travis <travis@sgi.com>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 9127f6b51a39..472f11765f60 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -467,6 +467,7 @@ int show_interrupts(struct seq_file *p, void *v);
 struct irq_desc;
 
 extern int early_irq_init(void);
+extern int arch_probe_nr_irqs(void);
 extern int arch_early_irq_init(void);
 extern int arch_init_chip_data(struct irq_desc *desc, int cpu);
 

commit 3610639d1fceb09cb418c65fcbe9136c31eee03a
Merge: cfa97f993c27 82c5b7b527cc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 6 17:10:53 2009 -0800

    Merge branch 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      hrtimer: splitout peek ahead functionality, fix
      hrtimer: fixup comments
      hrtimer: fix recursion deadlock by re-introducing the softirq
      hrtimer: simplify hotplug migration
      hrtimer: fix HOTPLUG_CPU=n compile warning
      hrtimer: splitout peek ahead functionality

commit 8c3659347efb43857b2c2d7bc63a9c7d68d1a608
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Tue Jan 6 14:41:14 2009 -0800

    include/linux/interrupt.h: do not include linux/irqnr.h twice
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 0702c4d7bdf0..af886b26c9d1 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -14,7 +14,6 @@
 #include <linux/irqflags.h>
 #include <linux/smp.h>
 #include <linux/percpu.h>
-#include <linux/irqnr.h>
 
 #include <asm/atomic.h>
 #include <asm/ptrace.h>

commit a6037b61c2f5fc99c57c15b26d7cfa58bbb34008
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Mon Jan 5 11:28:22 2009 +0100

    hrtimer: fix recursion deadlock by re-introducing the softirq
    
    Impact: fix rare runtime deadlock
    
    There are a few sites that do:
    
      spin_lock_irq(&foo)
      hrtimer_start(&bar)
        __run_hrtimer(&bar)
          func()
            spin_lock(&foo)
    
    which obviously deadlocks. In order to avoid this, never call __run_hrtimer()
    from hrtimer_start*() context, but instead defer this to softirq context.
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 0702c4d7bdf0..2062833f5f7a 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -253,7 +253,8 @@ enum
 	BLOCK_SOFTIRQ,
 	TASKLET_SOFTIRQ,
 	SCHED_SOFTIRQ,
-	RCU_SOFTIRQ, 	/* Preferable RCU should always be the last softirq */
+	HRTIMER_SOFTIRQ,
+	RCU_SOFTIRQ,	/* Preferable RCU should always be the last softirq */
 
 	NR_SOFTIRQS
 };

commit 7d3b56ba37a95f1f370f50258ed3954c304c524b
Merge: 269b012321f2 ab14398abd19
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 3 12:04:39 2009 -0800

    Merge branch 'cpus4096-for-linus-3' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'cpus4096-for-linus-3' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (77 commits)
      x86: setup_per_cpu_areas() cleanup
      cpumask: fix compile error when CONFIG_NR_CPUS is not defined
      cpumask: use alloc_cpumask_var_node where appropriate
      cpumask: convert shared_cpu_map in acpi_processor* structs to cpumask_var_t
      x86: use cpumask_var_t in acpi/boot.c
      x86: cleanup some remaining usages of NR_CPUS where s/b nr_cpu_ids
      sched: put back some stack hog changes that were undone in kernel/sched.c
      x86: enable cpus display of kernel_max and offlined cpus
      ia64: cpumask fix for is_affinity_mask_valid()
      cpumask: convert RCU implementations, fix
      xtensa: define __fls
      mn10300: define __fls
      m32r: define __fls
      h8300: define __fls
      frv: define __fls
      cris: define __fls
      cpumask: CONFIG_DISABLE_OBSOLETE_CPUMASK_FUNCTIONS
      cpumask: zero extra bits in alloc_cpumask_var_node
      cpumask: replace for_each_cpu_mask_nr with for_each_cpu in kernel/time/
      cpumask: convert mm/
      ...

commit b840d79631c882786925303c2b0f4fefc31845ed
Merge: 597b0d21626d c3d80000e3a8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 2 11:44:09 2009 -0800

    Merge branch 'cpus4096-for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'cpus4096-for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (66 commits)
      x86: export vector_used_by_percpu_irq
      x86: use logical apicid in x2apic_cluster's x2apic_cpu_mask_to_apicid_and()
      sched: nominate preferred wakeup cpu, fix
      x86: fix lguest used_vectors breakage, -v2
      x86: fix warning in arch/x86/kernel/io_apic.c
      sched: fix warning in kernel/sched.c
      sched: move test_sd_parent() to an SMP section of sched.h
      sched: add SD_BALANCE_NEWIDLE at MC and CPU level for sched_mc>0
      sched: activate active load balancing in new idle cpus
      sched: bias task wakeups to preferred semi-idle packages
      sched: nominate preferred wakeup cpu
      sched: favour lower logical cpu number for sched_mc balance
      sched: framework for sched_mc/smt_power_savings=N
      sched: convert BALANCE_FOR_xx_POWER to inline functions
      x86: use possible_cpus=NUM to extend the possible cpus allowed
      x86: fix cpu_mask_to_apicid_and to include cpu_online_mask
      x86: update io_apic.c to the new cpumask code
      x86: Introduce topology_core_cpumask()/topology_thread_cpumask()
      x86: xen: use smp_call_function_many()
      x86: use work_on_cpu in x86/kernel/cpu/mcheck/mce_amd_64.c
      ...
    
    Fixed up trivial conflict in kernel/time/tick-sched.c manually

commit d036e67b40f52bdd95392390108defbac7e53837
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Jan 1 10:12:26 2009 +1030

    cpumask: convert kernel/irq
    
    Impact: Reduce stack usage, use new cpumask API.  ALPHA mod!
    
    Main change is that irq_default_affinity becomes a cpumask_var_t, so
    treat it as a pointer (this effects alpha).
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index dfaee6bd265b..91f1ef8e5810 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -109,7 +109,7 @@ extern void enable_irq(unsigned int irq);
 
 #if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_HARDIRQS)
 
-extern cpumask_t irq_default_affinity;
+extern cpumask_var_t irq_default_affinity;
 
 extern int irq_set_affinity(unsigned int irq, const struct cpumask *cpumask);
 extern int irq_can_set_affinity(unsigned int irq);

commit db200df0b3530f673d8e9f5bd535e9e10305842a
Merge: ec270e59a74e 43a256322ac1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 31 09:00:59 2008 -0800

    Merge branch 'irq-fixes-for-linus-4' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'irq-fixes-for-linus-4' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      sparseirq: move __weak symbols into separate compilation unit
      sparseirq: work around __weak alias bug
      sparseirq: fix hang with !SPARSE_IRQ
      sparseirq: set lock_class for legacy irq when sparse_irq is selected
      sparseirq: work around compiler optimizing away __weak functions
      sparseirq: fix desc->lock init
      sparseirq: do not printk when migrating IRQ descriptors
      sparseirq: remove duplicated arch_early_irq_init()
      irq: simplify for_each_irq_desc() usage
      proc: remove ifdef CONFIG_SPARSE_IRQ from stat.c
      irq: for_each_irq_desc() move to irqnr.h
      hrtimer: remove #include <linux/irq.h>

commit 2ca1a615835d9f4990f42102ab1f2ef434e7e89c
Merge: e12f0102ac81 6a94cb73064c
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Wed Dec 31 23:05:57 2008 +1030

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
    
            arch/x86/kernel/io_apic.c

commit 179475a3b46f86e2d06f83e2312218ac3f0cf3a7
Merge: bb758e9637e5 860cf8894b32
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 30 16:20:19 2008 -0800

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86, sparseirq: clean up Kconfig entry
      x86: turn CONFIG_SPARSE_IRQ off by default
      sparseirq: fix numa_migrate_irq_desc dependency and comments
      sparseirq: add kernel-doc notation for new member in irq_desc, -v2
      locking, irq: enclose irq_desc_lock_class in CONFIG_LOCKDEP
      sparseirq, xen: make sure irq_desc is allocated for interrupts
      sparseirq: fix !SMP building, #2
      x86, sparseirq: move irq_desc according to smp_affinity, v7
      proc: enclose desc variable of show_stat() in CONFIG_SPARSE_IRQ
      sparse irqs: add irqnr.h to the user headers list
      sparse irqs: handle !GENIRQ platforms
      sparseirq: fix !SMP && !PCI_MSI && !HT_IRQ build
      sparseirq: fix Alpha build failure
      sparseirq: fix typo in !CONFIG_IO_APIC case
      x86, MSI: pass irq_cfg and irq_desc
      x86: MSI start irq numbering from nr_irqs_gsi
      x86: use NR_IRQS_LEGACY
      sparse irq_desc[] array: core kernel and x86 changes
      genirq: record IRQ_LEVEL in irq_desc[]
      irq.h: remove padding from irq_desc on 64bits

commit 43a256322ac1fc105c181b3cade3b9bfc0b63ca1
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Sun Dec 28 16:01:13 2008 -0800

    sparseirq: move __weak symbols into separate compilation unit
    
    GCC has a bug with __weak alias functions: if the functions are in
    the same compilation unit as their call site, GCC can decide to
    inline them - and thus rob the linker of the opportunity to override
    the weak alias with the real thing.
    
    So move all the IRQ handling related __weak symbols to kernel/irq/chip.c.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 777f89e00b4a..d9a370325ae2 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -467,4 +467,10 @@ static inline void init_irq_proc(void)
 
 int show_interrupts(struct seq_file *p, void *v);
 
+struct irq_desc;
+
+extern int early_irq_init(void);
+extern int arch_early_irq_init(void);
+extern int arch_init_chip_data(struct irq_desc *desc, int cpu);
+
 #endif

commit 968ea6d80e395cf11a51143cfa1b9a14ada676df
Merge: 7be7585393d3 8299608f140a
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Sat Dec 13 21:55:51 2008 +1030

    Merge ../linux-2.6-x86
    
    Conflicts:
    
            arch/x86/kernel/io_apic.c
            kernel/sched.c
            kernel/sched_stats.h

commit 0de26520c7cabf36e1de090ea8092f011a6106ce
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Sat Dec 13 21:20:26 2008 +1030

    cpumask: make irq_set_affinity() take a const struct cpumask
    
    Impact: change existing irq_chip API
    
    Not much point with gentle transition here: the struct irq_chip's
    setaffinity method signature needs to change.
    
    Fortunately, not widely used code, but hits a few architectures.
    
    Note: In irq_select_affinity() I save a temporary in by mangling
    irq_desc[irq].affinity directly.  Ingo, does this break anything?
    
    (Folded in fix from KOSAKI Motohiro)
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Mike Travis <travis@sgi.com>
    Reviewed-by: Grant Grundler <grundler@parisc-linux.org>
    Acked-by: Ingo Molnar <mingo@redhat.com>
    Cc: ralf@linux-mips.org
    Cc: grundler@parisc-linux.org
    Cc: jeremy@xensource.com
    Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index f58a0cf8929a..48e63934fabe 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -109,13 +109,13 @@ extern void enable_irq(unsigned int irq);
 
 extern cpumask_t irq_default_affinity;
 
-extern int irq_set_affinity(unsigned int irq, cpumask_t cpumask);
+extern int irq_set_affinity(unsigned int irq, const struct cpumask *cpumask);
 extern int irq_can_set_affinity(unsigned int irq);
 extern int irq_select_affinity(unsigned int irq);
 
 #else /* CONFIG_SMP */
 
-static inline int irq_set_affinity(unsigned int irq, cpumask_t cpumask)
+static inline int irq_set_affinity(unsigned int irq, const struct cpumask *m)
 {
 	return -EINVAL;
 }

commit 0ebb26e7a4e2c5337502e98b2221e037fda911b9
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Dec 12 11:26:39 2008 +0100

    sparse irqs: handle !GENIRQ platforms
    
    Impact: build fix
    
    fix:
    
     In file included from /home/mingo/tip/arch/m68k/amiga/amiints.c:39:
     /home/mingo/tip/include/linux/interrupt.h:21: error: expected identifier or '('
     /home/mingo/tip/arch/m68k/amiga/amiints.c: In function 'amiga_init_IRQ':
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 79e915e7e8a5..777f89e00b4a 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -14,12 +14,12 @@
 #include <linux/irqflags.h>
 #include <linux/smp.h>
 #include <linux/percpu.h>
+#include <linux/irqnr.h>
+
 #include <asm/atomic.h>
 #include <asm/ptrace.h>
 #include <asm/system.h>
 
-extern int nr_irqs;
-
 /*
  * These correspond to the IORESOURCE_IRQ_* defines in
  * linux/ioport.h to select the interrupt line behaviour.  When

commit 0b8f1efad30bd58f89961b82dfe68b9edf8fd2ac
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri Dec 5 18:58:31 2008 -0800

    sparse irq_desc[] array: core kernel and x86 changes
    
    Impact: new feature
    
    Problem on distro kernels: irq_desc[NR_IRQS] takes megabytes of RAM with
    NR_CPUS set to large values. The goal is to be able to scale up to much
    larger NR_IRQS value without impacting the (important) common case.
    
    To solve this, we generalize irq_desc[NR_IRQS] to an (optional) array of
    irq_desc pointers.
    
    When CONFIG_SPARSE_IRQ=y is used, we use kzalloc_node to get irq_desc,
    this also makes the IRQ descriptors NUMA-local (to the site that calls
    request_irq()).
    
    This gets rid of the irq_cfg[] static array on x86 as well: irq_cfg now
    uses desc->chip_data for x86 to store irq_cfg.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index f58a0cf8929a..79e915e7e8a5 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -18,6 +18,8 @@
 #include <asm/ptrace.h>
 #include <asm/system.h>
 
+extern int nr_irqs;
+
 /*
  * These correspond to the IORESOURCE_IRQ_* defines in
  * linux/ioport.h to select the interrupt line behaviour.  When

commit ca109491f612aab5c8152207631c0444f63da97f
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Tue Nov 25 12:43:51 2008 +0100

    hrtimer: removing all ur callback modes
    
    Impact: cleanup, move all hrtimer processing into hardirq context
    
    This is an attempt at removing some of the hrtimer complexity by
    reducing the number of callback modes to 1.
    
    This means that all hrtimer callback functions will be ran from HARD-irq
    context.
    
    I went through all the 30 odd hrtimer callback functions in the kernel
    and saw only one that I'm not quite sure of, which is the one in
    net/can/bcm.c - hence I'm CC-ing the folks responsible for that code.
    
    Furthermore, the hrtimer core now calls callbacks directly with IRQs
    disabled in case you try to enqueue an expired timer. If this timer is a
    periodic timer (which should use hrtimer_forward() to advance its time)
    then it might be possible to end up in an inf. recursive loop due to the
    fact that hrtimer_forward() doesn't round up to the next timer
    granularity, and therefore keeps on calling the callback - obviously
    this needs a fix.
    
    Aside from that, this seems to compile and actually boot on my dual core
    test box - although I'm sure there are some bugs in, me not hitting any
    makes me certain :-)
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index f58a0cf8929a..d6210a97a8ca 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -251,9 +251,6 @@ enum
 	BLOCK_SOFTIRQ,
 	TASKLET_SOFTIRQ,
 	SCHED_SOFTIRQ,
-#ifdef CONFIG_HIGH_RES_TIMERS
-	HRTIMER_SOFTIRQ,
-#endif
 	RCU_SOFTIRQ, 	/* Preferable RCU should always be the last softirq */
 
 	NR_SOFTIRQS

commit 9301975ec251bab1ad7cfcb84a688b26187e4e4a
Merge: 7110879cf2af dd3a1db900f2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 20 13:22:50 2008 -0700

    Merge branch 'genirq-v28-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    This merges branches irq/genirq, irq/sparseirq-v4, timers/hpet-percpu
    and x86/uv.
    
    The sparseirq branch is just preliminary groundwork: no sparse IRQs are
    actually implemented by this tree anymore - just the new APIs are added
    while keeping the old way intact as well (the new APIs map 1:1 to
    irq_desc[]).  The 'real' sparse IRQ support will then be a relatively
    small patch ontop of this - with a v2.6.29 merge target.
    
    * 'genirq-v28-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (178 commits)
      genirq: improve include files
      intr_remapping: fix typo
      io_apic: make irq_mis_count available on 64-bit too
      genirq: fix name space collisions of nr_irqs in arch/*
      genirq: fix name space collision of nr_irqs in autoprobe.c
      genirq: use iterators for irq_desc loops
      proc: fixup irq iterator
      genirq: add reverse iterator for irq_desc
      x86: move ack_bad_irq() to irq.c
      x86: unify show_interrupts() and proc helpers
      x86: cleanup show_interrupts
      genirq: cleanup the sparseirq modifications
      genirq: remove artifacts from sparseirq removal
      genirq: revert dynarray
      genirq: remove irq_to_desc_alloc
      genirq: remove sparse irq code
      genirq: use inline function for irq_to_desc
      genirq: consolidate nr_irqs and for_each_irq_desc()
      x86: remove sparse irq from Kconfig
      genirq: define nr_irqs for architectures with GENERIC_HARDIRQS=n
      ...

commit dd3a1db900f2a215a7d7dd71b836e149a6cf5fed
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Oct 16 18:20:58 2008 +0200

    genirq: improve include files
    
    Move the irq_desc related iterators out of irq.h, into irqnr.h, also
    available via interrupt.h.
    
    This way non-genirq (and even non-hardirq) architectures get the
    common definitions and iterators.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 58ff4e74b2f3..72fcfcff5637 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -8,6 +8,7 @@
 #include <linux/preempt.h>
 #include <linux/cpumask.h>
 #include <linux/irqreturn.h>
+#include <linux/irqnr.h>
 #include <linux/hardirq.h>
 #include <linux/sched.h>
 #include <linux/irqflags.h>

commit 54514a70adefe356afe854e2d3912d46668068e6
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Sep 23 22:15:57 2008 -0700

    softirq: Add support for triggering softirq work on softirqs.
    
    This is basically a genericization of Jens Axboe's block layer
    remote softirq changes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 54b3623434ec..35a61dc60d51 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -11,6 +11,8 @@
 #include <linux/hardirq.h>
 #include <linux/sched.h>
 #include <linux/irqflags.h>
+#include <linux/smp.h>
+#include <linux/percpu.h>
 #include <asm/atomic.h>
 #include <asm/ptrace.h>
 #include <asm/system.h>
@@ -273,6 +275,25 @@ extern void softirq_init(void);
 extern void raise_softirq_irqoff(unsigned int nr);
 extern void raise_softirq(unsigned int nr);
 
+/* This is the worklist that queues up per-cpu softirq work.
+ *
+ * send_remote_sendirq() adds work to these lists, and
+ * the softirq handler itself dequeues from them.  The queues
+ * are protected by disabling local cpu interrupts and they must
+ * only be accessed by the local cpu that they are for.
+ */
+DECLARE_PER_CPU(struct list_head [NR_SOFTIRQS], softirq_work_list);
+
+/* Try to send a softirq to a remote cpu.  If this cannot be done, the
+ * work will be queued to the local cpu.
+ */
+extern void send_remote_softirq(struct call_single_data *cp, int cpu, int softirq);
+
+/* Like send_remote_softirq(), but the caller must disable local cpu interrupts
+ * and compute the current cpu, passed in as 'this_cpu'.
+ */
+extern void __send_remote_softirq(struct call_single_data *cp, int cpu,
+				  int this_cpu, int softirq);
 
 /* Tasklets --- multithreaded analogue of BHs.
 

commit 70dd4d992ab324a59cdcd6bedc3f4e729863d514
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Oct 15 15:39:27 2008 +0200

    genirq: consolidate nr_irqs and for_each_irq_desc()
    
    Move all of those to linux/irq.h where they belong.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 5a57df2ee922..58ff4e74b2f3 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -15,15 +15,6 @@
 #include <asm/ptrace.h>
 #include <asm/system.h>
 
-#ifndef CONFIG_GENERIC_HARDIRQS
-# define for_each_irq_desc(irq, desc)		\
-	for (irq = 0; irq < nr_irqs; irq++)
-
-# define nr_irqs		NR_IRQS
-#else
-extern int nr_irqs;
-#endif
-
 /*
  * These correspond to the IORESOURCE_IRQ_* defines in
  * linux/ioport.h to select the interrupt line behaviour.  When

commit 7ef0c30dbf96a8d9a234e90c248eb19df3c031be
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Oct 15 13:07:35 2008 +0200

    genirq: define nr_irqs for architectures with GENERIC_HARDIRQS=n
    
    Revert the sparse irq changes in m68k/s390/sparc and just define
    nr_irqs as NR_IRQS for those architectures.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index d4039a0b23f4..5a57df2ee922 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -15,11 +15,13 @@
 #include <asm/ptrace.h>
 #include <asm/system.h>
 
-extern int nr_irqs;
-
 #ifndef CONFIG_GENERIC_HARDIRQS
-#define for_each_irq_desc(irq, desc)		\
+# define for_each_irq_desc(irq, desc)		\
 	for (irq = 0; irq < nr_irqs; irq++)
+
+# define nr_irqs		NR_IRQS
+#else
+extern int nr_irqs;
 #endif
 
 /*

commit c7fb03a475bd80c642c1345d85c7c550f63514b8
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Aug 19 20:50:12 2008 -0700

    irq, fs/proc: replace loop with nr_irqs for proc/stat
    
    Replace another nr_irqs loop to avoid the allocation of all sparse
    irq entries - use for_each_irq_desc instead.
    
    v2: make sure arch without GENERIC_HARDIRQS works too
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 511803853a5b..d4039a0b23f4 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -17,6 +17,11 @@
 
 extern int nr_irqs;
 
+#ifndef CONFIG_GENERIC_HARDIRQS
+#define for_each_irq_desc(irq, desc)		\
+	for (irq = 0; irq < nr_irqs; irq++)
+#endif
+
 /*
  * These correspond to the IORESOURCE_IRQ_* defines in
  * linux/ioport.h to select the interrupt line behaviour.  When

commit 85c0f90978bf50596dbd23854648020f1f9b5bfd
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Aug 19 20:49:47 2008 -0700

    irq: introduce nr_irqs
    
    at this point nr_irqs is equal NR_IRQS
    
    convert a few easy users from NR_IRQS to dynamic nr_irqs.
    
    v2: according to Eric, we need to take care of arch without generic_hardirqs
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 58ff4e74b2f3..511803853a5b 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -15,6 +15,8 @@
 #include <asm/ptrace.h>
 #include <asm/system.h>
 
+extern int nr_irqs;
+
 /*
  * These correspond to the IORESOURCE_IRQ_* defines in
  * linux/ioport.h to select the interrupt line behaviour.  When

commit 978b0116cd225682a29e3d1d5010319bf2de32c2
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Sep 6 20:04:36 2008 +0200

    softirq: allocate less vectors
    
    We don't need whole 32 of them, only NR_SOFTIRQS.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 58ff4e74b2f3..54b3623434ec 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -252,6 +252,8 @@ enum
 	HRTIMER_SOFTIRQ,
 #endif
 	RCU_SOFTIRQ, 	/* Preferable RCU should always be the last softirq */
+
+	NR_SOFTIRQS
 };
 
 /* softirq mask and active fields moved to irq_cpustat_t in

commit f6ac436dcc4c34709bcde355f3f2254ac0a183d4
Author: Mark Asselstine <mark.asselstine@windriver.com>
Date:   Tue Aug 5 13:01:24 2008 -0700

    Remove the deprecated cli() sti() functions
    
    These functions have been deprecated for some time now but remained until
    all legacy callers could be removed.  With a few commits in 2.6.26 this
    has happened so now we can remove these deprecated functions.
    
    Signed-off-by: Mark Asselstine <mark.asselstine@windriver.com>
    Reviewed-by: Matthew Wilcox <willy@linux.intel.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 62aa4f895abe..58ff4e74b2f3 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -223,35 +223,6 @@ static inline int disable_irq_wake(unsigned int irq)
 #define or_softirq_pending(x)  (local_softirq_pending() |= (x))
 #endif
 
-/*
- * Temporary defines for UP kernels, until all code gets fixed.
- */
-#ifndef CONFIG_SMP
-static inline void __deprecated cli(void)
-{
-	local_irq_disable();
-}
-static inline void __deprecated sti(void)
-{
-	local_irq_enable();
-}
-static inline void __deprecated save_flags(unsigned long *x)
-{
-	local_save_flags(*x);
-}
-#define save_flags(x) save_flags(&x)
-static inline void __deprecated restore_flags(unsigned long x)
-{
-	local_irq_restore(x);
-}
-
-static inline void __deprecated save_and_cli(unsigned long *x)
-{
-	local_irq_save(*x);
-}
-#define save_and_cli(x)	save_and_cli(&x)
-#endif /* CONFIG_SMP */
-
 /* Some architectures might implement lazy enabling/disabling of
  * interrupts. In some cases, such as stop_machine, we might want
  * to ensure that after a local_irq_disable(), interrupts have

commit 61d97f4fcf73d30864a52373a34093be25be6a03
Merge: 38c46578ffd8 48627d8d23c3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 15 10:39:22 2008 -0700

    Merge branch 'genirq' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'genirq' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      genirq: remove extraneous checks in manage.c
      genirq: Expose default irq affinity mask (take 3)

commit 18404756765c713a0be4eb1082920c04822ce588
Author: Max Krasnyansky <maxk@qualcomm.com>
Date:   Thu May 29 11:02:52 2008 -0700

    genirq: Expose default irq affinity mask (take 3)
    
    Current IRQ affinity interface does not provide a way to set affinity
    for the IRQs that will be allocated/activated in the future.
    This patch creates /proc/irq/default_smp_affinity that lets users set
    default affinity mask for the newly allocated IRQs. Changing the default
    does not affect affinity masks for the currently active IRQs, they
    have to be changed explicitly.
    
    Updated based on Paul J's comments and added some more documentation.
    
    Signed-off-by: Max Krasnyansky <maxk@qualcomm.com>
    Cc: pj@sgi.com
    Cc: a.p.zijlstra@chello.nl
    Cc: tglx@linutronix.de
    Cc: rdunlap@xenotime.net
    Cc: mingo@elte.hu
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index f1fc7470d26c..043400f3d458 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -104,8 +104,11 @@ extern void enable_irq(unsigned int irq);
 
 #if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_HARDIRQS)
 
+extern cpumask_t irq_default_affinity;
+
 extern int irq_set_affinity(unsigned int irq, cpumask_t cpumask);
 extern int irq_can_set_affinity(unsigned int irq);
+extern int irq_select_affinity(unsigned int irq);
 
 #else /* CONFIG_SMP */
 
@@ -119,6 +122,8 @@ static inline int irq_can_set_affinity(unsigned int irq)
 	return 0;
 }
 
+static inline int irq_select_affinity(unsigned int irq)  { return 0; }
+
 #endif /* CONFIG_SMP && CONFIG_GENERIC_HARDIRQS */
 
 #ifdef CONFIG_GENERIC_HARDIRQS

commit 962cf36c5bf6d2840b8d66ee9a606fae2f540bbd
Author: Carlos R. Mafra <crmafra2@gmail.com>
Date:   Thu May 15 11:15:37 2008 -0300

    Remove argument from open_softirq which is always NULL
    
    As git-grep shows, open_softirq() is always called with the last argument
    being NULL
    
    block/blk-core.c:       open_softirq(BLOCK_SOFTIRQ, blk_done_softirq, NULL);
    kernel/hrtimer.c:       open_softirq(HRTIMER_SOFTIRQ, run_hrtimer_softirq, NULL);
    kernel/rcuclassic.c:    open_softirq(RCU_SOFTIRQ, rcu_process_callbacks, NULL);
    kernel/rcupreempt.c:    open_softirq(RCU_SOFTIRQ, rcu_process_callbacks, NULL);
    kernel/sched.c: open_softirq(SCHED_SOFTIRQ, run_rebalance_domains, NULL);
    kernel/softirq.c:       open_softirq(TASKLET_SOFTIRQ, tasklet_action, NULL);
    kernel/softirq.c:       open_softirq(HI_SOFTIRQ, tasklet_hi_action, NULL);
    kernel/timer.c: open_softirq(TIMER_SOFTIRQ, run_timer_softirq, NULL);
    net/core/dev.c: open_softirq(NET_TX_SOFTIRQ, net_tx_action, NULL);
    net/core/dev.c: open_softirq(NET_RX_SOFTIRQ, net_rx_action, NULL);
    
    This observation has already been made by Matthew Wilcox in June 2002
    (http://www.cs.helsinki.fi/linux/linux-kernel/2002-25/0687.html)
    
    "I notice that none of the current softirq routines use the data element
    passed to them."
    
    and the situation hasn't changed since them. So it appears we can safely
    remove that extra argument to save 128 (54) bytes of kernel data (text).
    
    Signed-off-by: Carlos R. Mafra <crmafra@ift.unesp.br>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index f1fc7470d26c..a86186dd0474 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -285,12 +285,11 @@ enum
 struct softirq_action
 {
 	void	(*action)(struct softirq_action *);
-	void	*data;
 };
 
 asmlinkage void do_softirq(void);
 asmlinkage void __do_softirq(void);
-extern void open_softirq(int nr, void (*action)(struct softirq_action*), void *data);
+extern void open_softirq(int nr, void (*action)(struct softirq_action *));
 extern void softirq_init(void);
 #define __raise_softirq_irqoff(nr) do { or_softirq_pending(1UL << (nr)); } while (0)
 extern void raise_softirq_irqoff(unsigned int nr);

commit eb0f1c442d7cf1f7cb746c26c6120bb42e69c49c
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Apr 29 00:59:12 2008 -0700

    proper __do_softirq() prototype
    
    Add a proper prototype for __do_softirq() in include/linux/interrupt.h
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index b5fef13148bd..f1fc7470d26c 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -289,6 +289,7 @@ struct softirq_action
 };
 
 asmlinkage void do_softirq(void);
+asmlinkage void __do_softirq(void);
 extern void open_softirq(int nr, void (*action)(struct softirq_action*), void *data);
 extern void softirq_init(void);
 #define __raise_softirq_irqoff(nr) do { or_softirq_pending(1UL << (nr)); } while (0)

commit d7b906897e9caae452947e33674df0a2d6f7e10f
Author: Russell King <rmk+lkml@arm.linux.org.uk>
Date:   Thu Apr 17 07:46:24 2008 +0200

    [S390] genirq/clockevents: move irq affinity prototypes/inlines to interrupt.h
    
    > Generic code is not supposed to include irq.h. Replace this include
    > by linux/hardirq.h instead and add/replace an include of linux/irq.h
    > in asm header files where necessary.
    > This change should only matter for architectures that make use of
    > GENERIC_CLOCKEVENTS.
    > Architectures in question are mips, x86, arm, sh, powerpc, uml and sparc64.
    >
    > I did some cross compile tests for mips, x86_64, arm, powerpc and sparc64.
    > This patch fixes also build breakages caused by the include replacement in
    > tick-common.h.
    
    I generally dislike adding optional linux/* includes in asm/* includes -
    I'm nervous about this causing include loops.
    
    However, there's a separate point to be discussed here.
    
    That is, what interfaces are expected of every architecture in the kernel.
    If generic code wants to be able to set the affinity of interrupts, then
    that needs to become part of the interfaces listed in linux/interrupt.h
    rather than linux/irq.h.
    
    So what I suggest is this approach instead (against Linus' tree of a
    couple of days ago) - we move irq_set_affinity() and irq_can_set_affinity()
    to linux/interrupt.h, change the linux/irq.h includes to linux/interrupt.h
    and include asm/irq_regs.h where needed (asm/irq_regs.h is supposed to be
    rarely used include since not much touches the stacked parent context
    registers.)
    
    Build tested on ARM PXA family kernels and ARM's Realview platform
    kernels which both use genirq.
    
    [ tglx@linutronix.de: add GENERIC_HARDIRQ dependencies ]
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index f8ab4ce70564..b5fef13148bd 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -102,6 +102,25 @@ extern void disable_irq_nosync(unsigned int irq);
 extern void disable_irq(unsigned int irq);
 extern void enable_irq(unsigned int irq);
 
+#if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_HARDIRQS)
+
+extern int irq_set_affinity(unsigned int irq, cpumask_t cpumask);
+extern int irq_can_set_affinity(unsigned int irq);
+
+#else /* CONFIG_SMP */
+
+static inline int irq_set_affinity(unsigned int irq, cpumask_t cpumask)
+{
+	return -EINVAL;
+}
+
+static inline int irq_can_set_affinity(unsigned int irq)
+{
+	return 0;
+}
+
+#endif /* CONFIG_SMP && CONFIG_GENERIC_HARDIRQS */
+
 #ifdef CONFIG_GENERIC_HARDIRQS
 /*
  * Special lockdep variants of irq disabling/enabling.

commit b3c97528689619fc66569b30bf83d09d9929521a
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Wed Feb 13 15:03:15 2008 -0800

    include/linux: Remove all users of FASTCALL() macro
    
    FASTCALL() is always expanded to empty, remove it.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index dea7598aeff4..f8ab4ce70564 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -273,8 +273,8 @@ asmlinkage void do_softirq(void);
 extern void open_softirq(int nr, void (*action)(struct softirq_action*), void *data);
 extern void softirq_init(void);
 #define __raise_softirq_irqoff(nr) do { or_softirq_pending(1UL << (nr)); } while (0)
-extern void FASTCALL(raise_softirq_irqoff(unsigned int nr));
-extern void FASTCALL(raise_softirq(unsigned int nr));
+extern void raise_softirq_irqoff(unsigned int nr);
+extern void raise_softirq(unsigned int nr);
 
 
 /* Tasklets --- multithreaded analogue of BHs.
@@ -341,7 +341,7 @@ static inline void tasklet_unlock_wait(struct tasklet_struct *t)
 #define tasklet_unlock(t) do { } while (0)
 #endif
 
-extern void FASTCALL(__tasklet_schedule(struct tasklet_struct *t));
+extern void __tasklet_schedule(struct tasklet_struct *t);
 
 static inline void tasklet_schedule(struct tasklet_struct *t)
 {
@@ -349,7 +349,7 @@ static inline void tasklet_schedule(struct tasklet_struct *t)
 		__tasklet_schedule(t);
 }
 
-extern void FASTCALL(__tasklet_hi_schedule(struct tasklet_struct *t));
+extern void __tasklet_hi_schedule(struct tasklet_struct *t);
 
 static inline void tasklet_hi_schedule(struct tasklet_struct *t)
 {

commit f74596d07957235ad9da5120029348b372224a27
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Feb 6 01:36:35 2008 -0800

    proper show_interrupts() prototype
    
    Add a proper prototype for show_interrupts() in include/linux/interrupt.h
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index c3db4a00f1fa..dea7598aeff4 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -444,4 +444,6 @@ static inline void init_irq_proc(void)
 }
 #endif
 
+int show_interrupts(struct seq_file *p, void *v);
+
 #endif

commit c2d727aa2ff17a1c8e5ed1e5e231bb8579b27e82
Author: Dipankar Sarma <dipankar@in.ibm.com>
Date:   Fri Jan 25 21:08:23 2008 +0100

    Preempt-RCU: Use softirq instead of tasklets for
    
    This patch makes RCU use softirq instead of tasklets.
    
    It also adds a memory barrier after raising the softirq
    inorder to ensure that the cpu sees the most recently updated
    value of rcu->cur while processing callbacks.
    The discussion of the related theoretical race pointed out
    by James Huang can be found here --> http://lkml.org/lkml/2007/11/20/603
    
    Signed-off-by: Gautham R Shenoy <ego@in.ibm.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Dipankar Sarma <dipankar@in.ibm.com>
    Reviewed-by: Steven Rostedt <srostedt@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 2306920fa388..c3db4a00f1fa 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -256,6 +256,7 @@ enum
 #ifdef CONFIG_HIGH_RES_TIMERS
 	HRTIMER_SOFTIRQ,
 #endif
+	RCU_SOFTIRQ, 	/* Preferable RCU should always be the last softirq */
 };
 
 /* softirq mask and active fields moved to irq_cpustat_t in

commit b4471cbb09c4694e54092d02715c09fda2eb45ed
Author: Ahmed S. Darwish <darwish.07@gmail.com>
Date:   Tue Oct 16 23:30:21 2007 -0700

    Completely remove deprecated IRQ flags (SA_*)
    
    Only very little files use the deprecated SA_* IRQ flags in latest pull.  This
    patch series removes such macros from the tree and transfrom old code to the
    new IRQF_* flags.
    
    I've grepped the whole tree to make sure that no more files than the patched
    ones use such deprecated macros.  I hope this series won't introduce build
    errors.
    
    Signed-off-by: Ahmed S. Darwish <darwish.07@gmail.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Matthew Wilcox <willy@debian.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 8e5f289052a2..2306920fa388 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -55,28 +55,6 @@
 #define IRQF_NOBALANCING	0x00000800
 #define IRQF_IRQPOLL		0x00001000
 
-/*
- * Migration helpers. Scheduled for removal in 9/2007
- * Do not use for new code !
- */
-static inline
-unsigned long __deprecated deprecated_irq_flag(unsigned long flag)
-{
-	return flag;
-}
-
-#define SA_INTERRUPT		deprecated_irq_flag(IRQF_DISABLED)
-#define SA_SAMPLE_RANDOM	deprecated_irq_flag(IRQF_SAMPLE_RANDOM)
-#define SA_SHIRQ		deprecated_irq_flag(IRQF_SHARED)
-#define SA_PROBEIRQ		deprecated_irq_flag(IRQF_PROBE_SHARED)
-#define SA_PERCPU		deprecated_irq_flag(IRQF_PERCPU)
-
-#define SA_TRIGGER_LOW		deprecated_irq_flag(IRQF_TRIGGER_LOW)
-#define SA_TRIGGER_HIGH		deprecated_irq_flag(IRQF_TRIGGER_HIGH)
-#define SA_TRIGGER_FALLING	deprecated_irq_flag(IRQF_TRIGGER_FALLING)
-#define SA_TRIGGER_RISING	deprecated_irq_flag(IRQF_TRIGGER_RISING)
-#define SA_TRIGGER_MASK		deprecated_irq_flag(IRQF_TRIGGER_MASK)
-
 typedef irqreturn_t (*irq_handler_t)(int, void *);
 
 struct irqaction {

commit aa5346a2126ea65e8ef04eebea0f2481f701bdb8
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Tue Oct 16 01:24:01 2007 -0700

    provide stubs for enable_irq_wake() and disable_irq_wake()
    
    Provide {enable,disable}_irq_wakeup dummies for undefined
    cross-compilers for platforms without CONFIG_GENERIC_IRQ.
    
    Needed by wake-up-from-a-serial-port.patch
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 5523f19d88d2..8e5f289052a2 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -205,6 +205,15 @@ static inline int disable_irq_wake(unsigned int irq)
 						enable_irq(irq)
 # endif
 
+static inline int enable_irq_wake(unsigned int irq)
+{
+	return 0;
+}
+
+static inline int disable_irq_wake(unsigned int irq)
+{
+	return 0;
+}
 #endif /* CONFIG_GENERIC_HARDIRQS */
 
 #ifndef __ARCH_SET_SOFTIRQ_PENDING

commit 0af3678f7c5872836d1cc8d7c659abd62c3c5ae7
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Fri Jul 27 14:24:33 2007 +0100

    rip some includes from linux/interrupt.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 0a3c2ebf2008..5523f19d88d2 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -11,8 +11,6 @@
 #include <linux/hardirq.h>
 #include <linux/sched.h>
 #include <linux/irqflags.h>
-#include <linux/bottom_half.h>
-#include <linux/device.h>
 #include <asm/atomic.h>
 #include <asm/ptrace.h>
 #include <asm/system.h>
@@ -97,6 +95,8 @@ extern int __must_check request_irq(unsigned int, irq_handler_t handler,
 		       unsigned long, const char *, void *);
 extern void free_irq(unsigned int, void *);
 
+struct device;
+
 extern int __must_check devm_request_irq(struct device *dev, unsigned int irq,
 			    irq_handler_t handler, unsigned long irqflags,
 			    const char *devname, void *dev_id);

commit e9ed7e722e3f4cea07cf3c4bfe98c18180a17793
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Jul 21 23:29:12 2007 +0100

    take declarations of enable_irq() et.al. to linux/interrupt.h
    
    Now that the last inlined instances are gone, all that is left to do
    is turning disable_irq_nosync on arm26 and m68k from defines to aliases
    and we are all set - we can make these externs in linux/interrupt.h
    uncoditional and kill remaining instances in asm/irq.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 5323f6275854..0a3c2ebf2008 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -120,11 +120,11 @@ extern void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id);
 # define local_irq_enable_in_hardirq()	local_irq_enable()
 #endif
 
-#ifdef CONFIG_GENERIC_HARDIRQS
 extern void disable_irq_nosync(unsigned int irq);
 extern void disable_irq(unsigned int irq);
 extern void enable_irq(unsigned int irq);
 
+#ifdef CONFIG_GENERIC_HARDIRQS
 /*
  * Special lockdep variants of irq disabling/enabling.
  * These should be used for locking constructs that

commit 2d3fbbb391e280724f7f7804ab00ff61cf1b6a4c
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Thu May 10 22:22:46 2007 -0700

    Add hard_irq_disable()
    
    Some architectures, like powerpc, implement lazy disabling of interrupts.
    That means that on those, local_irq_disable() doesn't actually disable
    interrupts on the CPU, but only sets some per CPU flag which cause them to be
    disabled only if an interrupt actually occurs.
    
    However, in some cases, such as stop_machine, we really want interrupts to be
    fully disabled.  For example, I have code using stop machine to do ECC error
    injection, used to verify operations of the ECC hardware, that sort of thing.
    It really needs to make sure that nothing is actually writing to memory while
    the injection happens.  Similar examples can be found in other low level bits
    and pieces.
    
    This patch implements a generic hard_irq_disable() function which is meant to
    be called -after- local_irq_disable() and ensures that interrupts are fully
    disabled on that CPU.  The default implementation is a nop, though powerpc
    does already provide an appropriate one.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index f7b01b9a35b3..5323f6275854 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -241,6 +241,16 @@ static inline void __deprecated save_and_cli(unsigned long *x)
 #define save_and_cli(x)	save_and_cli(&x)
 #endif /* CONFIG_SMP */
 
+/* Some architectures might implement lazy enabling/disabling of
+ * interrupts. In some cases, such as stop_machine, we might want
+ * to ensure that after a local_irq_disable(), interrupts have
+ * really been disabled in hardware. Such architectures need to
+ * implement the following hook.
+ */
+#ifndef hard_irq_disable
+#define hard_irq_disable()	do { } while(0)
+#endif
+
 /* PLEASE, avoid to allocate new softirqs, if you need not _really_ high
    frequency threaded job scheduling. For almost all the purposes
    tasklets are more than enough. F.e. all serial device BHs et

commit d85a60d85ea5b7c597508c1510c88e657773d378
Author: Bernhard Walle <bwalle@suse.de>
Date:   Tue May 8 00:35:24 2007 -0700

    Add IRQF_IRQPOLL flag (common code)
    
    irqpoll is broken on some architectures that don't use the IRQ 0 for the timer
    interrupt like IA64.  This patch adds a IRQF_IRQPOLL flag.
    
    Each architecture is handled in a separate pach.  As I left the irq == 0 as
    condition, this should not break existing architectures that use timer_irq ==
    0 and that I did't address with that patch (because I don't know).
    
    This patch:
    
    This patch adds a IRQF_IRQPOLL flag that the interrupt registration code could
    use for the interrupt it wants to use for IRQ polling.
    
    Because this must not be the timer interrupt, an additional flag was added
    instead of re-using the IRQF_TIMER constant.  Until all architectures will
    have an IRQF_IRQPOLL interrupt, irq == 0 will stay as alternative as it should
    not break anything.
    
    Also, note_interrupt() is called on CPU-specific interrupts to be used as
    interrupt source for IRQ polling.
    
    Signed-off-by: Bernhard Walle <bwalle@suse.de>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Matthew Wilcox <willy@debian.org>
    Cc: Grant Grundler <grundler@google.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 80e63d8e9b15..f7b01b9a35b3 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -44,6 +44,9 @@
  * IRQF_TIMER - Flag to mark this interrupt as timer interrupt
  * IRQF_PERCPU - Interrupt is per cpu
  * IRQF_NOBALANCING - Flag to exclude this interrupt from irq balancing
+ * IRQF_IRQPOLL - Interrupt is used for polling (only the interrupt that is
+ *                registered first in an shared interrupt is considered for
+ *                performance reasons)
  */
 #define IRQF_DISABLED		0x00000020
 #define IRQF_SAMPLE_RANDOM	0x00000040
@@ -52,6 +55,7 @@
 #define IRQF_TIMER		0x00000200
 #define IRQF_PERCPU		0x00000400
 #define IRQF_NOBALANCING	0x00000800
+#define IRQF_IRQPOLL		0x00001000
 
 /*
  * Migration helpers. Scheduled for removal in 9/2007

commit 0e8638e2ace18eb6b814a63fe087106be05ca267
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 8 00:28:56 2007 -0700

    Deprecate SA_xxx interrupt flags -V2
    
    The deprecation of the SA_xxx interrupt flags did not emit deprecated
    warnings. Andrew said about the removal of the deprecated flag defines:
    
    > This is going to break a lot of external stuff.  We should have found
    > a way to make usage of SA_* emit deprecated warnings (or _some_
    > warning) to warn people of impending doom.  But I can't immediately
    > find a way of doing that. if we _can_ find a way of doing this, I
    > suspect we'll need to do it, and give people another six months.  It's
    > going to get ugly out there.  We shall see...
    
    Define the deprecated flags as a call to a __deprecated inline function
    so a warning is emitted on compile time.
    
    Extend the reprieve of out of tree drivers to 9/2007.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 2067a7ef6e62..80e63d8e9b15 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -54,20 +54,26 @@
 #define IRQF_NOBALANCING	0x00000800
 
 /*
- * Migration helpers. Scheduled for removal in 1/2007
+ * Migration helpers. Scheduled for removal in 9/2007
  * Do not use for new code !
  */
-#define SA_INTERRUPT		IRQF_DISABLED
-#define SA_SAMPLE_RANDOM	IRQF_SAMPLE_RANDOM
-#define SA_SHIRQ		IRQF_SHARED
-#define SA_PROBEIRQ		IRQF_PROBE_SHARED
-#define SA_PERCPU		IRQF_PERCPU
-
-#define SA_TRIGGER_LOW		IRQF_TRIGGER_LOW
-#define SA_TRIGGER_HIGH		IRQF_TRIGGER_HIGH
-#define SA_TRIGGER_FALLING	IRQF_TRIGGER_FALLING
-#define SA_TRIGGER_RISING	IRQF_TRIGGER_RISING
-#define SA_TRIGGER_MASK		IRQF_TRIGGER_MASK
+static inline
+unsigned long __deprecated deprecated_irq_flag(unsigned long flag)
+{
+	return flag;
+}
+
+#define SA_INTERRUPT		deprecated_irq_flag(IRQF_DISABLED)
+#define SA_SAMPLE_RANDOM	deprecated_irq_flag(IRQF_SAMPLE_RANDOM)
+#define SA_SHIRQ		deprecated_irq_flag(IRQF_SHARED)
+#define SA_PROBEIRQ		deprecated_irq_flag(IRQF_PROBE_SHARED)
+#define SA_PERCPU		deprecated_irq_flag(IRQF_PERCPU)
+
+#define SA_TRIGGER_LOW		deprecated_irq_flag(IRQF_TRIGGER_LOW)
+#define SA_TRIGGER_HIGH		deprecated_irq_flag(IRQF_TRIGGER_HIGH)
+#define SA_TRIGGER_FALLING	deprecated_irq_flag(IRQF_TRIGGER_FALLING)
+#define SA_TRIGGER_RISING	deprecated_irq_flag(IRQF_TRIGGER_RISING)
+#define SA_TRIGGER_MASK		deprecated_irq_flag(IRQF_TRIGGER_MASK)
 
 typedef irqreturn_t (*irq_handler_t)(int, void *);
 

commit 616883df78bd4b3fcdb6ddc39bd3d4cb902bfa32
Author: Monakhov Dmitriy <dmonakhov@openvz.org>
Date:   Tue May 8 00:25:07 2007 -0700

    IRQ: add __must_check to request_irq
    
    This could help to find buggy drivers where request_irq return value wasn't
    checked.  There's just no reason to ignore errors which can and do occur.
    Anyone who got warning during compilation have to realise what it is't
    realy safe code.
    
    Signed-off-by: Monakhov Dmitriy <dmonakhov@openvz.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 0319f665dd3f..2067a7ef6e62 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -83,11 +83,11 @@ struct irqaction {
 };
 
 extern irqreturn_t no_action(int cpl, void *dev_id);
-extern int request_irq(unsigned int, irq_handler_t handler,
+extern int __must_check request_irq(unsigned int, irq_handler_t handler,
 		       unsigned long, const char *, void *);
 extern void free_irq(unsigned int, void *);
 
-extern int devm_request_irq(struct device *dev, unsigned int irq,
+extern int __must_check devm_request_irq(struct device *dev, unsigned int irq,
 			    irq_handler_t handler, unsigned long irqflags,
 			    const char *devname, void *dev_id);
 extern void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id);

commit b3e2fd9cebcf4e82d0306fe7e796eeca5aac0614
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Tue May 1 22:32:42 2007 +0200

    lockdep: Add missing disable/enable irq variant
    
    Add missing disable/enable irq variant
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 838cf5a5bd7f..0319f665dd3f 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -185,10 +185,14 @@ static inline int disable_irq_wake(unsigned int irq)
  * validator need to define the methods below in their asm/irq.h
  * files, under an #ifdef CONFIG_LOCKDEP section.
  */
-# ifndef CONFIG_LOCKDEP
+#ifndef CONFIG_LOCKDEP
 #  define disable_irq_nosync_lockdep(irq)	disable_irq_nosync(irq)
+#  define disable_irq_nosync_lockdep_irqsave(irq, flags) \
+						disable_irq_nosync(irq)
 #  define disable_irq_lockdep(irq)		disable_irq(irq)
 #  define enable_irq_lockdep(irq)		enable_irq(irq)
+#  define enable_irq_lockdep_irqrestore(irq, flags) \
+						enable_irq(irq)
 # endif
 
 #endif /* CONFIG_GENERIC_HARDIRQS */

commit 6168a702ab0be181e5e57a0b2d0e7376f7a47f0b
Author: Andrew Morton <akpm@osdl.org>
Date:   Sat Feb 17 21:22:39 2007 -0800

    [PATCH] Declare init_irq_proc before we use it.
    
    powerpc gets:
    
    init/main.c: In function `do_basic_setup':
    init/main.c:714: warning: implicit declaration of function `init_irq_proc'
    
    but we cannot include linux/irq.h in generic code.
    
    Fix it by moving the declaration into linux/interrupt.h instead.
    
    And make sure all code that defines init_irq_proc() is including
    linux/interrupt.h.
    
    And nuke an ifdef-in-C
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index e5ea1411050b..838cf5a5bd7f 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -423,4 +423,13 @@ extern int probe_irq_off(unsigned long);	/* returns 0 or negative on failure */
 extern unsigned int probe_irq_mask(unsigned long);	/* returns mask of ISA interrupts */
 #endif
 
+#ifdef CONFIG_PROC_FS
+/* Initialize /proc/irq/ */
+extern void init_irq_proc(void);
+#else
+static inline void init_irq_proc(void)
+{
+}
+#endif
+
 #endif

commit 54cdfdb47f73b5af3d1ebb0f1e383efbe70fde9e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 16 01:28:11 2007 -0800

    [PATCH] hrtimers: add high resolution timer support
    
    Implement high resolution timers on top of the hrtimers infrastructure and the
    clockevents / tick-management framework.  This provides accurate timers for
    all hrtimer subsystem users.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 690113d07698..e5ea1411050b 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -242,6 +242,9 @@ enum
 	BLOCK_SOFTIRQ,
 	TASKLET_SOFTIRQ,
 	SCHED_SOFTIRQ,
+#ifdef CONFIG_HIGH_RES_TIMERS
+	HRTIMER_SOFTIRQ,
+#endif
 };
 
 /* softirq mask and active fields moved to irq_cpustat_t in

commit 950f4427c2ddc921164088a20f01304cf231437c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 16 01:27:24 2007 -0800

    [PATCH] Add irq flag to disable balancing for an interrupt
    
    Add a flag so we can prevent the irq balancing of an interrupt.  Move the
    bits, so we have room for more :)
    
    Necessary for the ability to setup clocksources more flexible (e.g.  use the
    different HPET channels per CPU)
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 5a8ba0b8ccba..690113d07698 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -42,6 +42,8 @@
  * IRQF_SHARED - allow sharing the irq among several devices
  * IRQF_PROBE_SHARED - set by callers when they expect sharing mismatches to occur
  * IRQF_TIMER - Flag to mark this interrupt as timer interrupt
+ * IRQF_PERCPU - Interrupt is per cpu
+ * IRQF_NOBALANCING - Flag to exclude this interrupt from irq balancing
  */
 #define IRQF_DISABLED		0x00000020
 #define IRQF_SAMPLE_RANDOM	0x00000040
@@ -49,6 +51,7 @@
 #define IRQF_PROBE_SHARED	0x00000100
 #define IRQF_TIMER		0x00000200
 #define IRQF_PERCPU		0x00000400
+#define IRQF_NOBALANCING	0x00000800
 
 /*
  * Migration helpers. Scheduled for removal in 1/2007

commit 9ac7849e35f705830f7b016ff272b0ff1f7ff759
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Jan 20 16:00:26 2007 +0900

    devres: device resource management
    
    Implement device resource management, in short, devres.  A device
    driver can allocate arbirary size of devres data which is associated
    with a release function.  On driver detach, release function is
    invoked on the devres data, then, devres data is freed.
    
    devreses are typed by associated release functions.  Some devreses are
    better represented by single instance of the type while others need
    multiple instances sharing the same release function.  Both usages are
    supported.
    
    devreses can be grouped using devres group such that a device driver
    can easily release acquired resources halfway through initialization
    or selectively release resources (e.g. resources for port 1 out of 4
    ports).
    
    This patch adds devres core including documentation and the following
    managed interfaces.
    
    * alloc/free    : devm_kzalloc(), devm_kzfree()
    * IO region     : devm_request_region(), devm_release_region()
    * IRQ           : devm_request_irq(), devm_free_irq()
    * DMA           : dmam_alloc_coherent(), dmam_free_coherent(),
                      dmam_declare_coherent_memory(), dmam_pool_create(),
                      dmam_pool_destroy()
    * PCI           : pcim_enable_device(), pcim_pin_device(), pci_is_managed()
    * iomap         : devm_ioport_map(), devm_ioport_unmap(), devm_ioremap(),
                      devm_ioremap_nocache(), devm_iounmap(), pcim_iomap_table(),
                      pcim_iomap(), pcim_iounmap()
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index e36e86c869fb..5a8ba0b8ccba 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -12,6 +12,7 @@
 #include <linux/sched.h>
 #include <linux/irqflags.h>
 #include <linux/bottom_half.h>
+#include <linux/device.h>
 #include <asm/atomic.h>
 #include <asm/ptrace.h>
 #include <asm/system.h>
@@ -83,6 +84,11 @@ extern int request_irq(unsigned int, irq_handler_t handler,
 		       unsigned long, const char *, void *);
 extern void free_irq(unsigned int, void *);
 
+extern int devm_request_irq(struct device *dev, unsigned int irq,
+			    irq_handler_t handler, unsigned long irqflags,
+			    const char *devname, void *dev_id);
+extern void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id);
+
 /*
  * On lockdep we dont want to enable hardirqs in hardirq
  * context. Use local_irq_enable_in_hardirq() to annotate

commit c9819f4593e8d052b41a89f47140f5c5e7e30582
Author: Christoph Lameter <clameter@sgi.com>
Date:   Sun Dec 10 02:20:25 2006 -0800

    [PATCH] sched: use softirq for load balancing
    
    Call rebalance_tick (renamed to run_rebalance_domains) from a newly introduced
    softirq.
    
    We calculate the earliest time for each layer of sched domains to be rescanned
    (this is the rescan time for idle) and use the earliest of those to schedule
    the softirq via a new field "next_balance" added to struct rq.
    
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Cc: Peter Williams <pwil3058@bigpond.net.au>
    Cc: Nick Piggin <nickpiggin@yahoo.com.au>
    Cc: Christoph Lameter <clameter@sgi.com>
    Cc: "Siddha, Suresh B" <suresh.b.siddha@intel.com>
    Cc: "Chen, Kenneth W" <kenneth.w.chen@intel.com>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index de7593f4e895..e36e86c869fb 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -231,7 +231,8 @@ enum
 	NET_TX_SOFTIRQ,
 	NET_RX_SOFTIRQ,
 	BLOCK_SOFTIRQ,
-	TASKLET_SOFTIRQ
+	TASKLET_SOFTIRQ,
+	SCHED_SOFTIRQ,
 };
 
 /* softirq mask and active fields moved to irq_cpustat_t in

commit 676dcb8bc2ec78d80091037773598d6ec8c673d6
Author: Andrew Morton <akpm@osdl.org>
Date:   Wed Dec 6 20:31:30 2006 -0800

    [PATCH] add bottom_half.h
    
    With CONFIG_SMP=n:
    
      drivers/input/ff-memless.c:384: warning: implicit declaration of function 'local_bh_disable'
      drivers/input/ff-memless.c:393: warning: implicit declaration of function 'local_bh_enable'
    
    Really linux/spinlock.h should include linux/interrupt.h.  But interrupt.h
    includes sched.h which will need spinlock.h.
    
    So the patch breaks the _bh declarations out into a separate header and
    includes it in both interrupt.h and spinlock.h.
    
    Cc: "Randy.Dunlap" <rdunlap@xenotime.net>
    Cc: Andi Kleen <ak@suse.de>
    Cc: <stable@kernel.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 5b83e7b59621..de7593f4e895 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -11,6 +11,7 @@
 #include <linux/hardirq.h>
 #include <linux/sched.h>
 #include <linux/irqflags.h>
+#include <linux/bottom_half.h>
 #include <asm/atomic.h>
 #include <asm/ptrace.h>
 #include <asm/system.h>
@@ -217,12 +218,6 @@ static inline void __deprecated save_and_cli(unsigned long *x)
 #define save_and_cli(x)	save_and_cli(&x)
 #endif /* CONFIG_SMP */
 
-extern void local_bh_disable(void);
-extern void __local_bh_enable(void);
-extern void _local_bh_enable(void);
-extern void local_bh_enable(void);
-extern void local_bh_enable_ip(unsigned long ip);
-
 /* PLEASE, avoid to allocate new softirqs, if you need not _really_ high
    frequency threaded job scheduling. For almost all the purposes
    tasklets are more than enough. F.e. all serial device BHs et

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 19782350dcc8..5b83e7b59621 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -64,7 +64,7 @@
 #define SA_TRIGGER_RISING	IRQF_TRIGGER_RISING
 #define SA_TRIGGER_MASK		IRQF_TRIGGER_MASK
 
-typedef irqreturn_t (*irq_handler_t)(int, void *, struct pt_regs *);
+typedef irqreturn_t (*irq_handler_t)(int, void *);
 
 struct irqaction {
 	irq_handler_t handler;
@@ -77,7 +77,7 @@ struct irqaction {
 	struct proc_dir_entry *dir;
 };
 
-extern irqreturn_t no_action(int cpl, void *dev_id, struct pt_regs *regs);
+extern irqreturn_t no_action(int cpl, void *dev_id);
 extern int request_irq(unsigned int, irq_handler_t handler,
 		       unsigned long, const char *, void *);
 extern void free_irq(unsigned int, void *);

commit da482792a6d1a3fbaaa25fae867b343fb4db3246
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 13:06:34 2006 +0100

    IRQ: Typedef the IRQ handler function type
    
    Typedef the IRQ handler function type.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1356d1e5fd256997e3d3dce0777ab787d0515c7a commit)

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 1f97e3d92639..19782350dcc8 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -64,8 +64,10 @@
 #define SA_TRIGGER_RISING	IRQF_TRIGGER_RISING
 #define SA_TRIGGER_MASK		IRQF_TRIGGER_MASK
 
+typedef irqreturn_t (*irq_handler_t)(int, void *, struct pt_regs *);
+
 struct irqaction {
-	irqreturn_t (*handler)(int, void *, struct pt_regs *);
+	irq_handler_t handler;
 	unsigned long flags;
 	cpumask_t mask;
 	const char *name;
@@ -76,8 +78,7 @@ struct irqaction {
 };
 
 extern irqreturn_t no_action(int cpl, void *dev_id, struct pt_regs *regs);
-extern int request_irq(unsigned int,
-		       irqreturn_t (*handler)(int, void *, struct pt_regs *),
+extern int request_irq(unsigned int, irq_handler_t handler,
 		       unsigned long, const char *, void *);
 extern void free_irq(unsigned int, void *);
 

commit e8106b941ceab68cc5ff713df7b1276484554584
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Fri Sep 29 02:01:08 2006 -0700

    [PATCH] lockdep: core, add enable/disable_irq_irqsave/irqrestore() APIs
    
    Introduce the disable_irq_nosync_lockdep_irqsave() and
    enable_irq_lockdep_irqrestore() APIs.  These are needed for NE2000; basically
    NE2000 calls disable_irq and enable_irq as locking against the IRQ handler,
    but both in cases where interrupts are on and off.  This means that lockdep
    needs to track the old state of the virtual irq flags on disable_irq, and
    restore these at enable_irq time.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index d5afee95fd43..1f97e3d92639 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -123,6 +123,14 @@ static inline void disable_irq_nosync_lockdep(unsigned int irq)
 #endif
 }
 
+static inline void disable_irq_nosync_lockdep_irqsave(unsigned int irq, unsigned long *flags)
+{
+	disable_irq_nosync(irq);
+#ifdef CONFIG_LOCKDEP
+	local_irq_save(*flags);
+#endif
+}
+
 static inline void disable_irq_lockdep(unsigned int irq)
 {
 	disable_irq(irq);
@@ -139,6 +147,14 @@ static inline void enable_irq_lockdep(unsigned int irq)
 	enable_irq(irq);
 }
 
+static inline void enable_irq_lockdep_irqrestore(unsigned int irq, unsigned long *flags)
+{
+#ifdef CONFIG_LOCKDEP
+	local_irq_restore(*flags);
+#endif
+	enable_irq(irq);
+}
+
 /* IRQ wakeup (PM) control: */
 extern int set_irq_wake(unsigned int irq, unsigned int on);
 

commit de30a2b355ea85350ca2f58f3b9bf4e5bc007986
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jul 3 00:24:42 2006 -0700

    [PATCH] lockdep: irqtrace subsystem, core
    
    Accurate hard-IRQ-flags and softirq-flags state tracing.
    
    This allows us to attach extra functionality to IRQ flags on/off
    events (such as trace-on/off).
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 73463fbb38e4..d5afee95fd43 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -10,6 +10,7 @@
 #include <linux/irqreturn.h>
 #include <linux/hardirq.h>
 #include <linux/sched.h>
+#include <linux/irqflags.h>
 #include <asm/atomic.h>
 #include <asm/ptrace.h>
 #include <asm/system.h>
@@ -199,13 +200,11 @@ static inline void __deprecated save_and_cli(unsigned long *x)
 #define save_and_cli(x)	save_and_cli(&x)
 #endif /* CONFIG_SMP */
 
-/* SoftIRQ primitives.  */
-#define local_bh_disable() \
-		do { add_preempt_count(SOFTIRQ_OFFSET); barrier(); } while (0)
-#define __local_bh_enable() \
-		do { barrier(); sub_preempt_count(SOFTIRQ_OFFSET); } while (0)
-
+extern void local_bh_disable(void);
+extern void __local_bh_enable(void);
+extern void _local_bh_enable(void);
 extern void local_bh_enable(void);
+extern void local_bh_enable_ip(unsigned long ip);
 
 /* PLEASE, avoid to allocate new softirqs, if you need not _really_ high
    frequency threaded job scheduling. For almost all the purposes

commit d7e9629de051bb4b1d104588cd97673ad770809e
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jul 3 00:24:27 2006 -0700

    [PATCH] lockdep: add local_irq_enable_in_hardirq() API
    
    Introduce local_irq_enable_in_hardirq() API.  It is currently aliased to
    local_irq_enable(), hence has no functional effects.
    
    This API will be used by lockdep, but even without lockdep this will better
    document places in the kernel where a hardirq context enables hardirqs.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 2c5452c1d7bb..73463fbb38e4 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -80,6 +80,23 @@ extern int request_irq(unsigned int,
 		       unsigned long, const char *, void *);
 extern void free_irq(unsigned int, void *);
 
+/*
+ * On lockdep we dont want to enable hardirqs in hardirq
+ * context. Use local_irq_enable_in_hardirq() to annotate
+ * kernel code that has to do this nevertheless (pretty much
+ * the only valid case is for old/broken hardware that is
+ * insanely slow).
+ *
+ * NOTE: in theory this might break fragile code that relies
+ * on hardirq delivery - in practice we dont seem to have such
+ * places left. So the only effect should be slightly increased
+ * irqs-off latencies.
+ */
+#ifdef CONFIG_LOCKDEP
+# define local_irq_enable_in_hardirq()	do { } while (0)
+#else
+# define local_irq_enable_in_hardirq()	local_irq_enable()
+#endif
 
 #ifdef CONFIG_GENERIC_HARDIRQS
 extern void disable_irq_nosync(unsigned int irq);

commit c01d403b2e3e3f231b18ebd07ad64ecbe6a258a5
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jul 3 00:24:27 2006 -0700

    [PATCH] lockdep: add disable/enable_irq_lockdep() API
    
    lockdep wants to use the disable_irq()/enable_irq() prototypes before they are
    provied by the platform's asm/irq.h.  So move them out of the
    CONFIG_GENERIC_HARDIRQS define - all architectures have a common prototype for
    this anyway.
    
    Add special lockdep variants of irq line disabling/enabling.
    
    These should be used for locking constructs that know that a particular irq
    context which is disabled, and which is the only irq-context user of a lock,
    that it's safe to take the lock in the irq-disabled section without disabling
    hardirqs.
    
    [akpm@osdl.org: build fix]
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index da3e0dbe61d4..2c5452c1d7bb 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -86,6 +86,41 @@ extern void disable_irq_nosync(unsigned int irq);
 extern void disable_irq(unsigned int irq);
 extern void enable_irq(unsigned int irq);
 
+/*
+ * Special lockdep variants of irq disabling/enabling.
+ * These should be used for locking constructs that
+ * know that a particular irq context which is disabled,
+ * and which is the only irq-context user of a lock,
+ * that it's safe to take the lock in the irq-disabled
+ * section without disabling hardirqs.
+ *
+ * On !CONFIG_LOCKDEP they are equivalent to the normal
+ * irq disable/enable methods.
+ */
+static inline void disable_irq_nosync_lockdep(unsigned int irq)
+{
+	disable_irq_nosync(irq);
+#ifdef CONFIG_LOCKDEP
+	local_irq_disable();
+#endif
+}
+
+static inline void disable_irq_lockdep(unsigned int irq)
+{
+	disable_irq(irq);
+#ifdef CONFIG_LOCKDEP
+	local_irq_disable();
+#endif
+}
+
+static inline void enable_irq_lockdep(unsigned int irq)
+{
+#ifdef CONFIG_LOCKDEP
+	local_irq_enable();
+#endif
+	enable_irq(irq);
+}
+
 /* IRQ wakeup (PM) control: */
 extern int set_irq_wake(unsigned int irq, unsigned int on);
 
@@ -99,7 +134,19 @@ static inline int disable_irq_wake(unsigned int irq)
 	return set_irq_wake(irq, 0);
 }
 
-#endif
+#else /* !CONFIG_GENERIC_HARDIRQS */
+/*
+ * NOTE: non-genirq architectures, if they want to support the lock
+ * validator need to define the methods below in their asm/irq.h
+ * files, under an #ifdef CONFIG_LOCKDEP section.
+ */
+# ifndef CONFIG_LOCKDEP
+#  define disable_irq_nosync_lockdep(irq)	disable_irq_nosync(irq)
+#  define disable_irq_lockdep(irq)		disable_irq(irq)
+#  define enable_irq_lockdep(irq)		enable_irq(irq)
+# endif
+
+#endif /* CONFIG_GENERIC_HARDIRQS */
 
 #ifndef __ARCH_SET_SOFTIRQ_PENDING
 #define set_softirq_pending(x) (local_softirq_pending() = (x))

commit 284c66806eb6df7f5c66d298681f1abe81a5a9ab
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 3 02:20:32 2006 +0200

    [PATCH] genirq:fixup missing SA_PERCPU replacement
    
    The irqflags consolidation converted SA_PERCPU_IRQ to IRQF_PERCPU but
    did not define the new constant.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index cf682a73a6f9..da3e0dbe61d4 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -45,6 +45,7 @@
 #define IRQF_SHARED		0x00000080
 #define IRQF_PROBE_SHARED	0x00000100
 #define IRQF_TIMER		0x00000200
+#define IRQF_PERCPU		0x00000400
 
 /*
  * Migration helpers. Scheduled for removal in 1/2007
@@ -54,6 +55,7 @@
 #define SA_SAMPLE_RANDOM	IRQF_SAMPLE_RANDOM
 #define SA_SHIRQ		IRQF_SHARED
 #define SA_PROBEIRQ		IRQF_PROBE_SHARED
+#define SA_PERCPU		IRQF_PERCPU
 
 #define SA_TRIGGER_LOW		IRQF_TRIGGER_LOW
 #define SA_TRIGGER_HIGH		IRQF_TRIGGER_HIGH

commit 6e21361619328751e2637b004e14cf360aafbddc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:03 2006 -0700

    [PATCH] irq-flags: consolidate flags for request_irq
    
    The recent interrupt rework introduced bit value conflicts with sparc.
    Instead of introducing new architecture flags mess, move the interrupt SA_
    flags out of the signal namespace and replace them by interrupt related flags.
    
    This allows to remove the obsolete SA_INTERRUPT flag and clean up the bit
    field values.
    
    This patch:
    
    Move the interrupt related SA_ flags out of linux/signal.h and rename them to
    IRQF_ .  This moves the interrupt related flags out of the signal namespace
    and allows to remove the architecture dependencies.
    
    SA_INTERRUPT is not needed by userspace and glibc so it can be removed safely.
    
    The existing SA_ constants are kept for easy transition and will be
    removed after a 6 month grace period.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: "Randy.Dunlap" <rdunlap@xenotime.net>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Cc: Greg KH <greg@kroah.com>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: Karsten Keil <kkeil@suse.de>
    Cc: Jody McIntyre <scjody@modernduck.com>
    Cc: Ben Collins <bcollins@debian.org>
    Cc: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Cc: Dave Airlie <airlied@linux.ie>
    Cc: Jens Axboe <axboe@suse.de>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: Andi Kleen <ak@muc.de>
    Cc: Miles Bader <uclinux-v850@lsi.nec.co.jp>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Kazumoto Kojima <kkojima@rr.iij4u.or.jp>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>                                 Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greg Ungerer <gerg@uclinux.org>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Richard Henderson <rth@twiddle.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index db2a63a11633..cf682a73a6f9 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -14,6 +14,53 @@
 #include <asm/ptrace.h>
 #include <asm/system.h>
 
+/*
+ * These correspond to the IORESOURCE_IRQ_* defines in
+ * linux/ioport.h to select the interrupt line behaviour.  When
+ * requesting an interrupt without specifying a IRQF_TRIGGER, the
+ * setting should be assumed to be "as already configured", which
+ * may be as per machine or firmware initialisation.
+ */
+#define IRQF_TRIGGER_NONE	0x00000000
+#define IRQF_TRIGGER_RISING	0x00000001
+#define IRQF_TRIGGER_FALLING	0x00000002
+#define IRQF_TRIGGER_HIGH	0x00000004
+#define IRQF_TRIGGER_LOW	0x00000008
+#define IRQF_TRIGGER_MASK	(IRQF_TRIGGER_HIGH | IRQF_TRIGGER_LOW | \
+				 IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING)
+#define IRQF_TRIGGER_PROBE	0x00000010
+
+/*
+ * These flags used only by the kernel as part of the
+ * irq handling routines.
+ *
+ * IRQF_DISABLED - keep irqs disabled when calling the action handler
+ * IRQF_SAMPLE_RANDOM - irq is used to feed the random generator
+ * IRQF_SHARED - allow sharing the irq among several devices
+ * IRQF_PROBE_SHARED - set by callers when they expect sharing mismatches to occur
+ * IRQF_TIMER - Flag to mark this interrupt as timer interrupt
+ */
+#define IRQF_DISABLED		0x00000020
+#define IRQF_SAMPLE_RANDOM	0x00000040
+#define IRQF_SHARED		0x00000080
+#define IRQF_PROBE_SHARED	0x00000100
+#define IRQF_TIMER		0x00000200
+
+/*
+ * Migration helpers. Scheduled for removal in 1/2007
+ * Do not use for new code !
+ */
+#define SA_INTERRUPT		IRQF_DISABLED
+#define SA_SAMPLE_RANDOM	IRQF_SAMPLE_RANDOM
+#define SA_SHIRQ		IRQF_SHARED
+#define SA_PROBEIRQ		IRQF_PROBE_SHARED
+
+#define SA_TRIGGER_LOW		IRQF_TRIGGER_LOW
+#define SA_TRIGGER_HIGH		IRQF_TRIGGER_HIGH
+#define SA_TRIGGER_FALLING	IRQF_TRIGGER_FALLING
+#define SA_TRIGGER_RISING	IRQF_TRIGGER_RISING
+#define SA_TRIGGER_MASK		IRQF_TRIGGER_MASK
+
 struct irqaction {
 	irqreturn_t (*handler)(int, void *, struct pt_regs *);
 	unsigned long flags;

commit ba9a2331bae5da8f65be3722b9e2d210f1987857
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 29 02:24:55 2006 -0700

    [PATCH] genirq: add irq-wake (power-management) support
    
    Enable platforms to set the irq-wake (power-management) properties of an IRQ.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 70741e170114..db2a63a11633 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -36,6 +36,20 @@ extern void free_irq(unsigned int, void *);
 extern void disable_irq_nosync(unsigned int irq);
 extern void disable_irq(unsigned int irq);
 extern void enable_irq(unsigned int irq);
+
+/* IRQ wakeup (PM) control: */
+extern int set_irq_wake(unsigned int irq, unsigned int on);
+
+static inline int enable_irq_wake(unsigned int irq)
+{
+	return set_irq_wake(irq, 1);
+}
+
+static inline int disable_irq_wake(unsigned int irq)
+{
+	return set_irq_wake(irq, 0);
+}
+
 #endif
 
 #ifndef __ARCH_SET_SOFTIRQ_PENDING

commit 908dcecda1d18803b5823f30e6c47d2882dc0cf1
Author: Jan Beulich <jbeulich@novell.com>
Date:   Fri Jun 23 02:06:00 2006 -0700

    [PATCH] adjust handle_IRR_event() return type
    
    Correct the return type of handle_IRQ_event() (inconsistency noticed during
    Xen development), and remove redundant declarations.  The return type
    adjustment required breaking out the definition of irqreturn_t into a
    separate header, in order to satisfy current include order dependencies.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Ian Molton <spyro@f2s.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Hirokazu Takata <takata.hirokazu@renesas.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: William Lee Irwin III <wli@holomorphy.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Miles Bader <uclinux-v850@lsi.nec.co.jp>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 9e0fefd7884a..70741e170114 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -7,32 +7,13 @@
 #include <linux/bitops.h>
 #include <linux/preempt.h>
 #include <linux/cpumask.h>
+#include <linux/irqreturn.h>
 #include <linux/hardirq.h>
 #include <linux/sched.h>
 #include <asm/atomic.h>
 #include <asm/ptrace.h>
 #include <asm/system.h>
 
-/*
- * For 2.4.x compatibility, 2.4.x can use
- *
- *	typedef void irqreturn_t;
- *	#define IRQ_NONE
- *	#define IRQ_HANDLED
- *	#define IRQ_RETVAL(x)
- *
- * To mix old-style and new-style irq handler returns.
- *
- * IRQ_NONE means we didn't handle it.
- * IRQ_HANDLED means that we did have a valid interrupt and handled it.
- * IRQ_RETVAL(x) selects on the two depending on x being non-zero (for handled)
- */
-typedef int irqreturn_t;
-
-#define IRQ_NONE	(0)
-#define IRQ_HANDLED	(1)
-#define IRQ_RETVAL(x)	((x) != 0)
-
 struct irqaction {
 	irqreturn_t (*handler)(int, void *, struct pt_regs *);
 	unsigned long flags;

commit 62c4f0a2d5a188f73a94f2cb8ea0dba3e7cf0a7f
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 26 12:56:16 2006 +0100

    Don't include linux/config.h from anywhere else in include/
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 2c08fdc2bdf7..9e0fefd7884a 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -2,7 +2,6 @@
 #ifndef _LINUX_INTERRUPT_H
 #define _LINUX_INTERRUPT_H
 
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/linkage.h>
 #include <linux/bitops.h>

commit 1aea6434eebd25e532d2e5ddabf2733af4e1ff0b
Author: Jens Axboe <axboe@suse.de>
Date:   Mon Jan 9 16:03:03 2006 +0100

    [SCSI] Kill the SCSI softirq handling
    
    This patch moves the SCSI softirq handling to the block layer version.
    There should be no functional changes.
    
    Signed-off-by: Jens Axboe <axboe@suse.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index f02204706984..2c08fdc2bdf7 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -113,7 +113,6 @@ enum
 	NET_TX_SOFTIRQ,
 	NET_RX_SOFTIRQ,
 	BLOCK_SOFTIRQ,
-	SCSI_SOFTIRQ,
 	TASKLET_SOFTIRQ
 };
 

commit ff856bad67cb65cb4dc4ef88b808804fc4265782
Author: Jens Axboe <axboe@suse.de>
Date:   Mon Jan 9 16:02:34 2006 +0100

    [BLOCK] ll_rw_blk: Enable out-of-order request completions through softirq
    
    Request completion can be a quite heavy process, since it needs to
    iterate through the entire request and complete the bio's it holds.
    This patch adds blk_complete_request() which moves this processing
    into a dedicated block softirq.
    
    Signed-off-by: Jens Axboe <axboe@suse.de>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index e50a95fbeb11..f02204706984 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -112,6 +112,7 @@ enum
 	TIMER_SOFTIRQ,
 	NET_TX_SOFTIRQ,
 	NET_RX_SOFTIRQ,
+	BLOCK_SOFTIRQ,
 	SCSI_SOFTIRQ,
 	TASKLET_SOFTIRQ
 };

commit ef9ceab28203690a42d7d3915ccf6e208f0762bc
Author: Andrew Morton <akpm@osdl.org>
Date:   Sun Jan 8 01:05:10 2006 -0800

    [PATCH] remove semicolons from save_flags()
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 41f150a3d2dd..e50a95fbeb11 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -79,7 +79,7 @@ static inline void __deprecated save_flags(unsigned long *x)
 {
 	local_save_flags(*x);
 }
-#define save_flags(x) save_flags(&x);
+#define save_flags(x) save_flags(&x)
 static inline void __deprecated restore_flags(unsigned long x)
 {
 	local_irq_restore(x);

commit f037360f2ed111fe89a8f5cb6ba351f4e9934e53
Author: Al Viro <viro@parcelfarce.linux.theplanet.co.uk>
Date:   Sun Nov 13 16:06:57 2005 -0800

    [PATCH] m68k: thread_info header cleanup
    
    a) in smp_lock.h #include of sched.h and spinlock.h moved under #ifdef
       CONFIG_LOCK_KERNEL.
    
    b) interrupt.h now explicitly pulls sched.h (not via smp_lock.h from
       hardirq.h as it used to)
    
    c) in three more places we need changes to compensate for (a) - one place
       in arch/sparc needs string.h now, hardirq.h needs forward declaration of
       task_struct and preempt.h needs direct include of thread_info.h.
    
    d) thread_info-related helpers in sched.h and thread_info.h put under
       ifndef __HAVE_THREAD_FUNCTIONS.  Obviously safe.
    
    Signed-off-by: Al Viro <viro@parcelfarce.linux.theplanet.co.uk>
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 0a90205184b0..41f150a3d2dd 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -9,6 +9,7 @@
 #include <linux/preempt.h>
 #include <linux/cpumask.h>
 #include <linux/hardirq.h>
+#include <linux/sched.h>
 #include <asm/atomic.h>
 #include <asm/ptrace.h>
 #include <asm/system.h>

commit 3f74478b5fd7263e9311cdb320923d599c73a792
Author: Andi Kleen <ak@suse.de>
Date:   Mon Sep 12 18:49:24 2005 +0200

    [PATCH] x86-64: Some cleanup and optimization to the processor data area.
    
    - Remove unused irqrsp field
    - Remove pda->me
    - Optimize set_softirq_pending slightly
    
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index d99e7aeb7d33..0a90205184b0 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -57,6 +57,11 @@ extern void disable_irq(unsigned int irq);
 extern void enable_irq(unsigned int irq);
 #endif
 
+#ifndef __ARCH_SET_SOFTIRQ_PENDING
+#define set_softirq_pending(x) (local_softirq_pending() = (x))
+#define or_softirq_pending(x)  (local_softirq_pending() |= (x))
+#endif
+
 /*
  * Temporary defines for UP kernels, until all code gets fixed.
  */
@@ -123,7 +128,7 @@ struct softirq_action
 asmlinkage void do_softirq(void);
 extern void open_softirq(int nr, void (*action)(struct softirq_action*), void *data);
 extern void softirq_init(void);
-#define __raise_softirq_irqoff(nr) do { local_softirq_pending() |= 1UL << (nr); } while (0)
+#define __raise_softirq_irqoff(nr) do { or_softirq_pending(1UL << (nr)); } while (0)
 extern void FASTCALL(raise_softirq_irqoff(unsigned int nr));
 extern void FASTCALL(raise_softirq(unsigned int nr));
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
new file mode 100644
index 000000000000..d99e7aeb7d33
--- /dev/null
+++ b/include/linux/interrupt.h
@@ -0,0 +1,289 @@
+/* interrupt.h */
+#ifndef _LINUX_INTERRUPT_H
+#define _LINUX_INTERRUPT_H
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/linkage.h>
+#include <linux/bitops.h>
+#include <linux/preempt.h>
+#include <linux/cpumask.h>
+#include <linux/hardirq.h>
+#include <asm/atomic.h>
+#include <asm/ptrace.h>
+#include <asm/system.h>
+
+/*
+ * For 2.4.x compatibility, 2.4.x can use
+ *
+ *	typedef void irqreturn_t;
+ *	#define IRQ_NONE
+ *	#define IRQ_HANDLED
+ *	#define IRQ_RETVAL(x)
+ *
+ * To mix old-style and new-style irq handler returns.
+ *
+ * IRQ_NONE means we didn't handle it.
+ * IRQ_HANDLED means that we did have a valid interrupt and handled it.
+ * IRQ_RETVAL(x) selects on the two depending on x being non-zero (for handled)
+ */
+typedef int irqreturn_t;
+
+#define IRQ_NONE	(0)
+#define IRQ_HANDLED	(1)
+#define IRQ_RETVAL(x)	((x) != 0)
+
+struct irqaction {
+	irqreturn_t (*handler)(int, void *, struct pt_regs *);
+	unsigned long flags;
+	cpumask_t mask;
+	const char *name;
+	void *dev_id;
+	struct irqaction *next;
+	int irq;
+	struct proc_dir_entry *dir;
+};
+
+extern irqreturn_t no_action(int cpl, void *dev_id, struct pt_regs *regs);
+extern int request_irq(unsigned int,
+		       irqreturn_t (*handler)(int, void *, struct pt_regs *),
+		       unsigned long, const char *, void *);
+extern void free_irq(unsigned int, void *);
+
+
+#ifdef CONFIG_GENERIC_HARDIRQS
+extern void disable_irq_nosync(unsigned int irq);
+extern void disable_irq(unsigned int irq);
+extern void enable_irq(unsigned int irq);
+#endif
+
+/*
+ * Temporary defines for UP kernels, until all code gets fixed.
+ */
+#ifndef CONFIG_SMP
+static inline void __deprecated cli(void)
+{
+	local_irq_disable();
+}
+static inline void __deprecated sti(void)
+{
+	local_irq_enable();
+}
+static inline void __deprecated save_flags(unsigned long *x)
+{
+	local_save_flags(*x);
+}
+#define save_flags(x) save_flags(&x);
+static inline void __deprecated restore_flags(unsigned long x)
+{
+	local_irq_restore(x);
+}
+
+static inline void __deprecated save_and_cli(unsigned long *x)
+{
+	local_irq_save(*x);
+}
+#define save_and_cli(x)	save_and_cli(&x)
+#endif /* CONFIG_SMP */
+
+/* SoftIRQ primitives.  */
+#define local_bh_disable() \
+		do { add_preempt_count(SOFTIRQ_OFFSET); barrier(); } while (0)
+#define __local_bh_enable() \
+		do { barrier(); sub_preempt_count(SOFTIRQ_OFFSET); } while (0)
+
+extern void local_bh_enable(void);
+
+/* PLEASE, avoid to allocate new softirqs, if you need not _really_ high
+   frequency threaded job scheduling. For almost all the purposes
+   tasklets are more than enough. F.e. all serial device BHs et
+   al. should be converted to tasklets, not to softirqs.
+ */
+
+enum
+{
+	HI_SOFTIRQ=0,
+	TIMER_SOFTIRQ,
+	NET_TX_SOFTIRQ,
+	NET_RX_SOFTIRQ,
+	SCSI_SOFTIRQ,
+	TASKLET_SOFTIRQ
+};
+
+/* softirq mask and active fields moved to irq_cpustat_t in
+ * asm/hardirq.h to get better cache usage.  KAO
+ */
+
+struct softirq_action
+{
+	void	(*action)(struct softirq_action *);
+	void	*data;
+};
+
+asmlinkage void do_softirq(void);
+extern void open_softirq(int nr, void (*action)(struct softirq_action*), void *data);
+extern void softirq_init(void);
+#define __raise_softirq_irqoff(nr) do { local_softirq_pending() |= 1UL << (nr); } while (0)
+extern void FASTCALL(raise_softirq_irqoff(unsigned int nr));
+extern void FASTCALL(raise_softirq(unsigned int nr));
+
+
+/* Tasklets --- multithreaded analogue of BHs.
+
+   Main feature differing them of generic softirqs: tasklet
+   is running only on one CPU simultaneously.
+
+   Main feature differing them of BHs: different tasklets
+   may be run simultaneously on different CPUs.
+
+   Properties:
+   * If tasklet_schedule() is called, then tasklet is guaranteed
+     to be executed on some cpu at least once after this.
+   * If the tasklet is already scheduled, but its excecution is still not
+     started, it will be executed only once.
+   * If this tasklet is already running on another CPU (or schedule is called
+     from tasklet itself), it is rescheduled for later.
+   * Tasklet is strictly serialized wrt itself, but not
+     wrt another tasklets. If client needs some intertask synchronization,
+     he makes it with spinlocks.
+ */
+
+struct tasklet_struct
+{
+	struct tasklet_struct *next;
+	unsigned long state;
+	atomic_t count;
+	void (*func)(unsigned long);
+	unsigned long data;
+};
+
+#define DECLARE_TASKLET(name, func, data) \
+struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(0), func, data }
+
+#define DECLARE_TASKLET_DISABLED(name, func, data) \
+struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(1), func, data }
+
+
+enum
+{
+	TASKLET_STATE_SCHED,	/* Tasklet is scheduled for execution */
+	TASKLET_STATE_RUN	/* Tasklet is running (SMP only) */
+};
+
+#ifdef CONFIG_SMP
+static inline int tasklet_trylock(struct tasklet_struct *t)
+{
+	return !test_and_set_bit(TASKLET_STATE_RUN, &(t)->state);
+}
+
+static inline void tasklet_unlock(struct tasklet_struct *t)
+{
+	smp_mb__before_clear_bit(); 
+	clear_bit(TASKLET_STATE_RUN, &(t)->state);
+}
+
+static inline void tasklet_unlock_wait(struct tasklet_struct *t)
+{
+	while (test_bit(TASKLET_STATE_RUN, &(t)->state)) { barrier(); }
+}
+#else
+#define tasklet_trylock(t) 1
+#define tasklet_unlock_wait(t) do { } while (0)
+#define tasklet_unlock(t) do { } while (0)
+#endif
+
+extern void FASTCALL(__tasklet_schedule(struct tasklet_struct *t));
+
+static inline void tasklet_schedule(struct tasklet_struct *t)
+{
+	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
+		__tasklet_schedule(t);
+}
+
+extern void FASTCALL(__tasklet_hi_schedule(struct tasklet_struct *t));
+
+static inline void tasklet_hi_schedule(struct tasklet_struct *t)
+{
+	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
+		__tasklet_hi_schedule(t);
+}
+
+
+static inline void tasklet_disable_nosync(struct tasklet_struct *t)
+{
+	atomic_inc(&t->count);
+	smp_mb__after_atomic_inc();
+}
+
+static inline void tasklet_disable(struct tasklet_struct *t)
+{
+	tasklet_disable_nosync(t);
+	tasklet_unlock_wait(t);
+	smp_mb();
+}
+
+static inline void tasklet_enable(struct tasklet_struct *t)
+{
+	smp_mb__before_atomic_dec();
+	atomic_dec(&t->count);
+}
+
+static inline void tasklet_hi_enable(struct tasklet_struct *t)
+{
+	smp_mb__before_atomic_dec();
+	atomic_dec(&t->count);
+}
+
+extern void tasklet_kill(struct tasklet_struct *t);
+extern void tasklet_kill_immediate(struct tasklet_struct *t, unsigned int cpu);
+extern void tasklet_init(struct tasklet_struct *t,
+			 void (*func)(unsigned long), unsigned long data);
+
+/*
+ * Autoprobing for irqs:
+ *
+ * probe_irq_on() and probe_irq_off() provide robust primitives
+ * for accurate IRQ probing during kernel initialization.  They are
+ * reasonably simple to use, are not "fooled" by spurious interrupts,
+ * and, unlike other attempts at IRQ probing, they do not get hung on
+ * stuck interrupts (such as unused PS2 mouse interfaces on ASUS boards).
+ *
+ * For reasonably foolproof probing, use them as follows:
+ *
+ * 1. clear and/or mask the device's internal interrupt.
+ * 2. sti();
+ * 3. irqs = probe_irq_on();      // "take over" all unassigned idle IRQs
+ * 4. enable the device and cause it to trigger an interrupt.
+ * 5. wait for the device to interrupt, using non-intrusive polling or a delay.
+ * 6. irq = probe_irq_off(irqs);  // get IRQ number, 0=none, negative=multiple
+ * 7. service the device to clear its pending interrupt.
+ * 8. loop again if paranoia is required.
+ *
+ * probe_irq_on() returns a mask of allocated irq's.
+ *
+ * probe_irq_off() takes the mask as a parameter,
+ * and returns the irq number which occurred,
+ * or zero if none occurred, or a negative irq number
+ * if more than one irq occurred.
+ */
+
+#if defined(CONFIG_GENERIC_HARDIRQS) && !defined(CONFIG_GENERIC_IRQ_PROBE) 
+static inline unsigned long probe_irq_on(void)
+{
+	return 0;
+}
+static inline int probe_irq_off(unsigned long val)
+{
+	return 0;
+}
+static inline unsigned int probe_irq_mask(unsigned long val)
+{
+	return 0;
+}
+#else
+extern unsigned long probe_irq_on(void);	/* returns 0 on failure */
+extern int probe_irq_off(unsigned long);	/* returns 0 or negative on failure */
+extern unsigned int probe_irq_mask(unsigned long);	/* returns mask of ISA interrupts */
+#endif
+
+#endif
