commit 5de815a7eedfacf593817ef34634eaa9b75a1482
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue May 29 08:40:23 2018 +0200

    block: remove parent device reference from struct bsg_class_device
    
    Bsg holding a reference to the parent device may result in a crash if a
    bsg file handle is closed after the parent device driver has unloaded.
    
    Holding a reference is not really needed: the parent device must exist
    between bsg_register_queue and bsg_unregister_queue.  Before the device
    goes away the caller does blk_cleanup_queue so that all in-flight
    requests to the device are gone and all new requests cannot pass beyond
    the queue.  The queue itself is a refcounted object and it will stay
    alive with a bsg file.
    
    Based on analysis, previous patch and changelog from Anatoliy Glagolev.
    
    Reported-by: Anatoliy Glagolev <glagolig@gmail.com>
    Reviewed-by: James E.J. Bottomley <jejb@linux.vnet.ibm.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/bsg.h b/include/linux/bsg.h
index 0c7dd9ceb139..dac37b6e00ec 100644
--- a/include/linux/bsg.h
+++ b/include/linux/bsg.h
@@ -17,17 +17,13 @@ struct bsg_ops {
 
 struct bsg_class_device {
 	struct device *class_dev;
-	struct device *parent;
 	int minor;
 	struct request_queue *queue;
-	struct kref ref;
 	const struct bsg_ops *ops;
-	void (*release)(struct device *);
 };
 
 int bsg_register_queue(struct request_queue *q, struct device *parent,
-		const char *name, const struct bsg_ops *ops,
-		void (*release)(struct device *));
+		const char *name, const struct bsg_ops *ops);
 int bsg_scsi_register_queue(struct request_queue *q, struct device *parent);
 void bsg_unregister_queue(struct request_queue *q);
 #else

commit 17cb960f29c29ee07bf6848ada3265f4be55972e
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Mar 13 17:28:41 2018 +0100

    bsg: split handling of SCSI CDBs vs transport requeues
    
    The current BSG design tries to shoe-horn the transport-specific
    passthrough commands into the overall framework for SCSI passthrough
    requests.  This has a couple problems:
    
     - each passthrough queue has to set the QUEUE_FLAG_SCSI_PASSTHROUGH flag
       despite not dealing with SCSI commands at all.  Because of that these
       queues could also incorrectly accept SCSI commands from in-kernel
       users or through the legacy SCSI_IOCTL_SEND_COMMAND ioctl.
     - the real SCSI bsg queues also incorrectly accept bsg requests of the
       BSG_SUB_PROTOCOL_SCSI_TRANSPORT type
     - the bsg transport code is almost unredable because it tries to reuse
       different SCSI concepts for its own purpose.
    
    This patch instead adds a new bsg_ops structure to handle the two cases
    differently, and thus solves all of the above problems.  Another side
    effect is that the bsg-lib queues also don't need to embedd a
    struct scsi_request anymore.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/bsg.h b/include/linux/bsg.h
index 2a202e41a3af..0c7dd9ceb139 100644
--- a/include/linux/bsg.h
+++ b/include/linux/bsg.h
@@ -1,34 +1,43 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-#ifndef BSG_H
-#define BSG_H
+#ifndef _LINUX_BSG_H
+#define _LINUX_BSG_H
 
 #include <uapi/linux/bsg.h>
 
+struct request;
+
+#ifdef CONFIG_BLK_DEV_BSG
+struct bsg_ops {
+	int	(*check_proto)(struct sg_io_v4 *hdr);
+	int	(*fill_hdr)(struct request *rq, struct sg_io_v4 *hdr,
+				fmode_t mode);
+	int	(*complete_rq)(struct request *rq, struct sg_io_v4 *hdr);
+	void	(*free_rq)(struct request *rq);
+};
 
-#if defined(CONFIG_BLK_DEV_BSG)
 struct bsg_class_device {
 	struct device *class_dev;
 	struct device *parent;
 	int minor;
 	struct request_queue *queue;
 	struct kref ref;
+	const struct bsg_ops *ops;
 	void (*release)(struct device *);
 };
 
-extern int bsg_register_queue(struct request_queue *q,
-			      struct device *parent, const char *name,
-			      void (*release)(struct device *));
-extern void bsg_unregister_queue(struct request_queue *);
+int bsg_register_queue(struct request_queue *q, struct device *parent,
+		const char *name, const struct bsg_ops *ops,
+		void (*release)(struct device *));
+int bsg_scsi_register_queue(struct request_queue *q, struct device *parent);
+void bsg_unregister_queue(struct request_queue *q);
 #else
-static inline int bsg_register_queue(struct request_queue *q,
-				     struct device *parent, const char *name,
-				     void (*release)(struct device *))
+static inline int bsg_scsi_register_queue(struct request_queue *q,
+		struct device *parent)
 {
 	return 0;
 }
 static inline void bsg_unregister_queue(struct request_queue *q)
 {
 }
-#endif
-
-#endif
+#endif /* CONFIG_BLK_DEV_BSG */
+#endif /* _LINUX_BSG_H */

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/bsg.h b/include/linux/bsg.h
index 7173f6e9d2dd..2a202e41a3af 100644
--- a/include/linux/bsg.h
+++ b/include/linux/bsg.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef BSG_H
 #define BSG_H
 

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/bsg.h b/include/linux/bsg.h
index ecb4730d0868..7173f6e9d2dd 100644
--- a/include/linux/bsg.h
+++ b/include/linux/bsg.h
@@ -1,67 +1,8 @@
 #ifndef BSG_H
 #define BSG_H
 
-#include <linux/types.h>
+#include <uapi/linux/bsg.h>
 
-#define BSG_PROTOCOL_SCSI		0
-
-#define BSG_SUB_PROTOCOL_SCSI_CMD	0
-#define BSG_SUB_PROTOCOL_SCSI_TMF	1
-#define BSG_SUB_PROTOCOL_SCSI_TRANSPORT	2
-
-/*
- * For flags member below
- * sg.h sg_io_hdr also has bits defined for it's flags member. However
- * none of these bits are implemented/used by bsg. The bits below are
- * allocated to not conflict with sg.h ones anyway.
- */
-#define BSG_FLAG_Q_AT_TAIL 0x10 /* default, == 0 at this bit, is Q_AT_HEAD */
-
-struct sg_io_v4 {
-	__s32 guard;		/* [i] 'Q' to differentiate from v3 */
-	__u32 protocol;		/* [i] 0 -> SCSI , .... */
-	__u32 subprotocol;	/* [i] 0 -> SCSI command, 1 -> SCSI task
-				   management function, .... */
-
-	__u32 request_len;	/* [i] in bytes */
-	__u64 request;		/* [i], [*i] {SCSI: cdb} */
-	__u64 request_tag;	/* [i] {SCSI: task tag (only if flagged)} */
-	__u32 request_attr;	/* [i] {SCSI: task attribute} */
-	__u32 request_priority;	/* [i] {SCSI: task priority} */
-	__u32 request_extra;	/* [i] {spare, for padding} */
-	__u32 max_response_len;	/* [i] in bytes */
-	__u64 response;		/* [i], [*o] {SCSI: (auto)sense data} */
-
-        /* "dout_": data out (to device); "din_": data in (from device) */
-	__u32 dout_iovec_count;	/* [i] 0 -> "flat" dout transfer else
-				   dout_xfer points to array of iovec */
-	__u32 dout_xfer_len;	/* [i] bytes to be transferred to device */
-	__u32 din_iovec_count;	/* [i] 0 -> "flat" din transfer */
-	__u32 din_xfer_len;	/* [i] bytes to be transferred from device */
-	__u64 dout_xferp;	/* [i], [*i] */
-	__u64 din_xferp;	/* [i], [*o] */
-
-	__u32 timeout;		/* [i] units: millisecond */
-	__u32 flags;		/* [i] bit mask */
-	__u64 usr_ptr;		/* [i->o] unused internally */
-	__u32 spare_in;		/* [i] */
-
-	__u32 driver_status;	/* [o] 0 -> ok */
-	__u32 transport_status;	/* [o] 0 -> ok */
-	__u32 device_status;	/* [o] {SCSI: command completion status} */
-	__u32 retry_delay;	/* [o] {SCSI: status auxiliary information} */
-	__u32 info;		/* [o] additional information */
-	__u32 duration;		/* [o] time to complete, in milliseconds */
-	__u32 response_len;	/* [o] bytes of response actually written */
-	__s32 din_resid;	/* [o] din_xfer_len - actual_din_xfer_len */
-	__s32 dout_resid;	/* [o] dout_xfer_len - actual_dout_xfer_len */
-	__u64 generated_tag;	/* [o] {SCSI: transport generated task tag} */
-	__u32 spare_out;	/* [o] */
-
-	__u32 padding;
-};
-
-#ifdef __KERNEL__
 
 #if defined(CONFIG_BLK_DEV_BSG)
 struct bsg_class_device {
@@ -89,6 +30,4 @@ static inline void bsg_unregister_queue(struct request_queue *q)
 }
 #endif
 
-#endif /* __KERNEL__ */
-
 #endif

commit d54b3538b0bfb31351d02d1669d4a978d2abfc5f
Merge: 5d80f8e5a9dc af50bb993dfa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 28 13:30:43 2009 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6: (119 commits)
      [SCSI] scsi_dh_rdac: Retry for NOT_READY check condition
      [SCSI] mpt2sas: make global symbols unique
      [SCSI] sd: Make revalidate less chatty
      [SCSI] sd: Try READ CAPACITY 16 first for SBC-2 devices
      [SCSI] sd: Refactor sd_read_capacity()
      [SCSI] mpt2sas v00.100.11.15
      [SCSI] mpt2sas: add MPT2SAS_MINOR(221) to miscdevice.h
      [SCSI] ch: Add scsi type modalias
      [SCSI] 3w-9xxx: add power management support
      [SCSI] bsg: add linux/types.h include to bsg.h
      [SCSI] cxgb3i: fix function descriptions
      [SCSI] libiscsi: fix possbile null ptr session command cleanup
      [SCSI] iscsi class: remove host no argument from session creation callout
      [SCSI] libiscsi: pass session failure a session struct
      [SCSI] iscsi lib: remove qdepth param from iscsi host allocation
      [SCSI] iscsi lib: have lib create work queue for transmitting IO
      [SCSI] iscsi class: fix lock dep warning on logout
      [SCSI] libiscsi: don't cap queue depth in iscsi modules
      [SCSI] iscsi_tcp: replace scsi_debug/tcp_debug logging with iscsi conn logging
      [SCSI] libiscsi_tcp: replace tcp_debug/scsi_debug logging with session/conn logging
      ...

commit 05378940caf979a8655c18b18a17213dcfa52412
Author: Boaz Harrosh <bharrosh@panasas.com>
Date:   Tue Mar 24 12:23:40 2009 +0100

    bsg: add support for tail queuing
    
    Currently inherited from sg.c bsg will submit asynchronous request
     at the head-of-the-queue, (using "at_head" set in the call to
     blk_execute_rq_nowait()). This is bad in situation where the queues
     are full, requests will execute out of order, and can cause
     starvation of the first submitted requests.
    
    The sg_io_v4->flags member is used and a bit is allocated to denote the
    Q_AT_TAIL. Zero is to queue at_head as before, to be compatible with old
    code at the write/read path. SG_IO code path behavior was changed so to
    be the same as write/read behavior. SG_IO was very rarely used and breaking
    compatibility with it is OK at this stage.
    
    sg_io_hdr at sg.h also has a flags member and uses 3 bits from the first
    nibble and one bit from the last nibble. Even though none of these bits
    are supported by bsg, The second nibble is allocated for use by bsg. Just
    in case.
    
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    CC: Douglas Gilbert <dgilbert@interlog.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/bsg.h b/include/linux/bsg.h
index cf0303a60611..3f0c64ace424 100644
--- a/include/linux/bsg.h
+++ b/include/linux/bsg.h
@@ -7,6 +7,14 @@
 #define BSG_SUB_PROTOCOL_SCSI_TMF	1
 #define BSG_SUB_PROTOCOL_SCSI_TRANSPORT	2
 
+/*
+ * For flags member below
+ * sg.h sg_io_hdr also has bits defined for it's flags member. However
+ * none of these bits are implemented/used by bsg. The bits below are
+ * allocated to not conflict with sg.h ones anyway.
+ */
+#define BSG_FLAG_Q_AT_TAIL 0x10 /* default, == 0 at this bit, is Q_AT_HEAD */
+
 struct sg_io_v4 {
 	__s32 guard;		/* [i] 'Q' to differentiate from v3 */
 	__u32 protocol;		/* [i] 0 -> SCSI , .... */

commit 4ab3b73f85ca2e99d9dbdb55ac13e57327a7e915
Author: Douglas Gilbert <dgilbert@interlog.com>
Date:   Mon Mar 9 10:51:38 2009 -0400

    [SCSI] bsg: add linux/types.h include to bsg.h
    
    Since bsg.h has recently been added to the list of kernel
    headers that should be exported to the user space, this
    attachment makes bsg.h more user space "friendly".
    Specifically autotools dislike headers that don't compile
    freestanding and bsg.h's use of __u32 types (and friends)
    are not standard C (C90 or C99). The inclusion of
    linux/types.h fixes that.
    
    Signed-off-by: Douglas Gilbert <dgilbert@interlog.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/linux/bsg.h b/include/linux/bsg.h
index cf0303a60611..6c0a00dfa90c 100644
--- a/include/linux/bsg.h
+++ b/include/linux/bsg.h
@@ -1,6 +1,8 @@
 #ifndef BSG_H
 #define BSG_H
 
+#include <linux/types.h>
+
 #define BSG_PROTOCOL_SCSI		0
 
 #define BSG_SUB_PROTOCOL_SCSI_CMD	0

commit 97f46ae45c70857e459b7f8df1fc2807e7bd90a9
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Sat Apr 19 00:43:14 2008 +0900

    [SCSI] bsg: add release callback support
    
    This patch adds release callback support, which is called when a bsg
    device goes away. bsg_register_queue() takes a pointer to a callback
    function. This feature is useful for stuff like sas_host that can't
    use the release callback in struct device.
    
    If a caller doesn't need bsg's release callback, it can call
    bsg_register_queue() with NULL pointer (e.g. scsi devices can use
    release callback in struct device so they don't need bsg's callback).
    
    With this patch, bsg uses kref for refcounts on bsg devices instead of
    get/put_device in fops->open/release. bsg calls put_device and the
    caller's release callback (if it was registered) in kref_put's
    release.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/linux/bsg.h b/include/linux/bsg.h
index e8406c55c6d3..cf0303a60611 100644
--- a/include/linux/bsg.h
+++ b/include/linux/bsg.h
@@ -56,19 +56,25 @@ struct sg_io_v4 {
 #if defined(CONFIG_BLK_DEV_BSG)
 struct bsg_class_device {
 	struct device *class_dev;
-	struct device *dev;
+	struct device *parent;
 	int minor;
 	struct request_queue *queue;
+	struct kref ref;
+	void (*release)(struct device *);
 };
 
-extern int bsg_register_queue(struct request_queue *, struct device *, const char *);
+extern int bsg_register_queue(struct request_queue *q,
+			      struct device *parent, const char *name,
+			      void (*release)(struct device *));
 extern void bsg_unregister_queue(struct request_queue *);
 #else
-static inline int bsg_register_queue(struct request_queue * rq, struct device *dev, const char *name)
+static inline int bsg_register_queue(struct request_queue *q,
+				     struct device *parent, const char *name,
+				     void (*release)(struct device *))
 {
 	return 0;
 }
-static inline void bsg_unregister_queue(struct request_queue *rq)
+static inline void bsg_unregister_queue(struct request_queue *q)
 {
 }
 #endif

commit ee959b00c335d7780136c5abda37809191fe52c3
Author: Tony Jones <tonyj@suse.de>
Date:   Fri Feb 22 00:13:36 2008 +0100

    SCSI: convert struct class_device to struct device
    
    It's big, but there doesn't seem to be a way to split it up smaller...
    
    Signed-off-by: Tony Jones <tonyj@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Roland Dreier <rolandd@cisco.com>
    Cc: Sean Hefty <sean.hefty@intel.com>
    Cc: Hal Rosenstock <hal.rosenstock@gmail.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/bsg.h b/include/linux/bsg.h
index 60e377b520f8..e8406c55c6d3 100644
--- a/include/linux/bsg.h
+++ b/include/linux/bsg.h
@@ -55,7 +55,7 @@ struct sg_io_v4 {
 
 #if defined(CONFIG_BLK_DEV_BSG)
 struct bsg_class_device {
-	struct class_device *class_dev;
+	struct device *class_dev;
 	struct device *dev;
 	int minor;
 	struct request_queue *queue;

commit 0c6a89ba640d28e1dcd7fd1a217d2cfb92ae4953
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Sun Jul 29 23:00:46 2007 +0900

    [SCSI] bsg: update sg_io_v4 structure
    
    This updates sg_io_v4 structure (based on Doug's RFC, release 1.3).
    
    The major changes are:
    
    - add dout_resid field
    - increase tag size to 64 bits to comply with SAM-4 and SRP
    - add dout_iovec_count and din_iovec_count
    
    dout_iovec_count and din_iovec_count aren't supported now. I'm not
    sure whether they will be supported or not but they were added for the
    possible future changes.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/linux/bsg.h b/include/linux/bsg.h
index 102dc096e1cb..60e377b520f8 100644
--- a/include/linux/bsg.h
+++ b/include/linux/bsg.h
@@ -15,14 +15,18 @@ struct sg_io_v4 {
 
 	__u32 request_len;	/* [i] in bytes */
 	__u64 request;		/* [i], [*i] {SCSI: cdb} */
+	__u64 request_tag;	/* [i] {SCSI: task tag (only if flagged)} */
 	__u32 request_attr;	/* [i] {SCSI: task attribute} */
-	__u32 request_tag;	/* [i] {SCSI: task tag (only if flagged)} */
 	__u32 request_priority;	/* [i] {SCSI: task priority} */
+	__u32 request_extra;	/* [i] {spare, for padding} */
 	__u32 max_response_len;	/* [i] in bytes */
 	__u64 response;		/* [i], [*o] {SCSI: (auto)sense data} */
 
-	/* "din_" for data in (from device); "dout_" for data out (to device) */
+        /* "dout_": data out (to device); "din_": data in (from device) */
+	__u32 dout_iovec_count;	/* [i] 0 -> "flat" dout transfer else
+				   dout_xfer points to array of iovec */
 	__u32 dout_xfer_len;	/* [i] bytes to be transferred to device */
+	__u32 din_iovec_count;	/* [i] 0 -> "flat" din transfer */
 	__u32 din_xfer_len;	/* [i] bytes to be transferred from device */
 	__u64 dout_xferp;	/* [i], [*i] */
 	__u64 din_xferp;	/* [i], [*o] */
@@ -39,8 +43,9 @@ struct sg_io_v4 {
 	__u32 info;		/* [o] additional information */
 	__u32 duration;		/* [o] time to complete, in milliseconds */
 	__u32 response_len;	/* [o] bytes of response actually written */
-	__s32 din_resid;	/* [o] actual_din_xfer_len - din_xfer_len */
-	__u32 generated_tag;	/* [o] {SCSI: task tag that transport chose} */
+	__s32 din_resid;	/* [o] din_xfer_len - actual_din_xfer_len */
+	__s32 dout_resid;	/* [o] dout_xfer_len - actual_dout_xfer_len */
+	__u64 generated_tag;	/* [o] {SCSI: transport generated task tag} */
 	__u32 spare_out;	/* [o] */
 
 	__u32 padding;

commit a4ee0df8b3d007f0d685d38a56dc0b91e01aaaf7
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Mon Jul 23 09:53:51 2007 -0500

    [SCSI] bsg: fix unused variable warnings for BLK_DEV_BSG=n
    
    Just using #defines for the
    bsg_register_queue()/bsg_unregister_queue() can cause undefined
    variables when they're defined to nothing.  Use dummy inline functions
    instead.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/linux/bsg.h b/include/linux/bsg.h
index 241eed03e42c..102dc096e1cb 100644
--- a/include/linux/bsg.h
+++ b/include/linux/bsg.h
@@ -59,8 +59,13 @@ struct bsg_class_device {
 extern int bsg_register_queue(struct request_queue *, struct device *, const char *);
 extern void bsg_unregister_queue(struct request_queue *);
 #else
-#define bsg_register_queue(disk, dev, name)		(0)
-#define bsg_unregister_queue(disk)	do { } while (0)
+static inline int bsg_register_queue(struct request_queue * rq, struct device *dev, const char *name)
+{
+	return 0;
+}
+static inline void bsg_unregister_queue(struct request_queue *rq)
+{
+}
 #endif
 
 #endif /* __KERNEL__ */

commit 598443a2124618fc8fe5a8bae32c129666ac3eab
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Mon Jul 23 09:33:26 2007 +0900

    [SCSI] bsg: use lib/idr.c to find a unique minor number
    
    This replaces the current linear search for a unique minor number with
    lib/idr.c.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Acked-by: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/linux/bsg.h b/include/linux/bsg.h
index f415f89e0ac8..241eed03e42c 100644
--- a/include/linux/bsg.h
+++ b/include/linux/bsg.h
@@ -53,7 +53,6 @@ struct bsg_class_device {
 	struct class_device *class_dev;
 	struct device *dev;
 	int minor;
-	struct list_head list;
 	struct request_queue *queue;
 };
 

commit 39dca558a5b52b63e49bc234a7e887be092aa690
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Fri Jul 20 18:22:17 2007 -0500

    [SCSI] bsg: make class backlinks
    
    Currently, bsg doesn't make class backlinks (a process whereby you'd get
    a link to bsg in the device directory in the same way you get one for
    sg).  This is because the bsg device is uninitialised, so the class
    device has nothing it can attach to.  The fix is to make the bsg device
    point to the cdevice of the entity creating the bsg, necessitating
    changing the bsg_register_queue() prototype into a form that takes the
    generic device.
    
    Acked-by: FUJITA Tomonori <tomof@acm.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/linux/bsg.h b/include/linux/bsg.h
index 8547b10c388b..f415f89e0ac8 100644
--- a/include/linux/bsg.h
+++ b/include/linux/bsg.h
@@ -57,10 +57,10 @@ struct bsg_class_device {
 	struct request_queue *queue;
 };
 
-extern int bsg_register_queue(struct request_queue *, const char *);
+extern int bsg_register_queue(struct request_queue *, struct device *, const char *);
 extern void bsg_unregister_queue(struct request_queue *);
 #else
-#define bsg_register_queue(disk, name)		(0)
+#define bsg_register_queue(disk, dev, name)		(0)
 #define bsg_unregister_queue(disk)	do { } while (0)
 #endif
 

commit 13bd59a111760bb7cba8dcf17b6b55a0d99d3592
Author: Geert Uytterhoeven <Geert.Uytterhoeven@sonycom.com>
Date:   Tue Jul 17 14:18:47 2007 +0200

    Don't define empty struct bsg_class_device if !CONFIG_BLK_DEV_BSG
    
    Don't define an empty struct bsg_class_device if !CONFIG_BLK_DEV_BSG.
    
    It's embedded in struct request_queue, but there we have
    
    #if defined(CONFIG_BLK_DEV_BSG)
            struct bsg_class_device bsg_dev;
    #endif
    
    anyway.
    
    Signed-off-by: Geert Uytterhoeven <Geert.Uytterhoeven@sonycom.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/bsg.h b/include/linux/bsg.h
index bd998ca6cb2e..8547b10c388b 100644
--- a/include/linux/bsg.h
+++ b/include/linux/bsg.h
@@ -60,7 +60,6 @@ struct bsg_class_device {
 extern int bsg_register_queue(struct request_queue *, const char *);
 extern void bsg_unregister_queue(struct request_queue *);
 #else
-struct bsg_class_device { };
 #define bsg_register_queue(disk, name)		(0)
 #define bsg_unregister_queue(disk)	do { } while (0)
 #endif

commit 15d10b611fa94b52f004a08a1d4cf7b39de3cba3
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Mon Jul 16 08:52:16 2007 +0200

    bsg: add SCSI transport-level request support
    
    This enables bsg to handle SCSI transport-level request like SAS
    management protocol (SMP).
    
    - add BSG_SUB_PROTOCOL_{SCSI_CMD, SCSI_TMF, SCSI_TRANSPORT} definitions.
    - SCSI transport-level requests skip blk_verify_command().
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/bsg.h b/include/linux/bsg.h
index 0dd01f90ba5e..bd998ca6cb2e 100644
--- a/include/linux/bsg.h
+++ b/include/linux/bsg.h
@@ -1,6 +1,12 @@
 #ifndef BSG_H
 #define BSG_H
 
+#define BSG_PROTOCOL_SCSI		0
+
+#define BSG_SUB_PROTOCOL_SCSI_CMD	0
+#define BSG_SUB_PROTOCOL_SCSI_TMF	1
+#define BSG_SUB_PROTOCOL_SCSI_TRANSPORT	2
+
 struct sg_io_v4 {
 	__s32 guard;		/* [i] 'Q' to differentiate from v3 */
 	__u32 protocol;		/* [i] 0 -> SCSI , .... */

commit 4cf0723ac89b5f2189da2ad07ef875de26b83c77
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Fri Mar 30 11:19:39 2007 +0200

    bsg: minor bug fixes
    
    This fixes the following minor issues:
    
    - add EXPORT_SYMBOL_GPL for bsg_register_queue and
    bsg_unregister_queue.
    
    - shut up gcc warnings
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Jens Axboe <axboe@nelson.home.kernel.dk>

diff --git a/include/linux/bsg.h b/include/linux/bsg.h
index 0475a6d3ff6a..0dd01f90ba5e 100644
--- a/include/linux/bsg.h
+++ b/include/linux/bsg.h
@@ -51,7 +51,7 @@ struct bsg_class_device {
 	struct request_queue *queue;
 };
 
-extern int bsg_register_queue(struct request_queue *, char *);
+extern int bsg_register_queue(struct request_queue *, const char *);
 extern void bsg_unregister_queue(struct request_queue *);
 #else
 struct bsg_class_device { };

commit d351af01b9307566135cb0f355ca65d0952c10b5
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Mon Jul 9 12:40:35 2007 +0200

    bsg: bind bsg to request_queue instead of gendisk
    
    This patch binds bsg devices to request_queue instead of gendisk. Any
    objects (like transport entities) can define own request_handler and
    create own bsg device.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/bsg.h b/include/linux/bsg.h
index 2154a6dfbd53..0475a6d3ff6a 100644
--- a/include/linux/bsg.h
+++ b/include/linux/bsg.h
@@ -47,16 +47,16 @@ struct bsg_class_device {
 	struct class_device *class_dev;
 	struct device *dev;
 	int minor;
-	struct gendisk *disk;
 	struct list_head list;
+	struct request_queue *queue;
 };
 
-extern int bsg_register_disk(struct gendisk *);
-extern void bsg_unregister_disk(struct gendisk *);
+extern int bsg_register_queue(struct request_queue *, char *);
+extern void bsg_unregister_queue(struct request_queue *);
 #else
 struct bsg_class_device { };
-#define bsg_register_disk(disk)		(0)
-#define bsg_unregister_disk(disk)	do { } while (0)
+#define bsg_register_queue(disk, name)		(0)
+#define bsg_unregister_queue(disk)	do { } while (0)
 #endif
 
 #endif /* __KERNEL__ */

commit 3862153b673516b2efa0447b9b3778f47ac8f8c8
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Fri Dec 22 09:43:51 2006 +0100

    Replace s32, u32 and u64 with __s32, __u32 and __u64 in bsg.h for userspace
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/bsg.h b/include/linux/bsg.h
index f968726cfadc..2154a6dfbd53 100644
--- a/include/linux/bsg.h
+++ b/include/linux/bsg.h
@@ -2,42 +2,42 @@
 #define BSG_H
 
 struct sg_io_v4 {
-	s32 guard;		/* [i] 'Q' to differentiate from v3 */
-	u32 protocol;		/* [i] 0 -> SCSI , .... */
-	u32 subprotocol;	/* [i] 0 -> SCSI command, 1 -> SCSI task
+	__s32 guard;		/* [i] 'Q' to differentiate from v3 */
+	__u32 protocol;		/* [i] 0 -> SCSI , .... */
+	__u32 subprotocol;	/* [i] 0 -> SCSI command, 1 -> SCSI task
 				   management function, .... */
 
-	u32 request_len;	/* [i] in bytes */
-	u64 request;		/* [i], [*i] {SCSI: cdb} */
-	u32 request_attr;	/* [i] {SCSI: task attribute} */
-	u32 request_tag;	/* [i] {SCSI: task tag (only if flagged)} */
-	u32 request_priority;	/* [i] {SCSI: task priority} */
-	u32 max_response_len;	/* [i] in bytes */
-	u64 response;		/* [i], [*o] {SCSI: (auto)sense data} */
+	__u32 request_len;	/* [i] in bytes */
+	__u64 request;		/* [i], [*i] {SCSI: cdb} */
+	__u32 request_attr;	/* [i] {SCSI: task attribute} */
+	__u32 request_tag;	/* [i] {SCSI: task tag (only if flagged)} */
+	__u32 request_priority;	/* [i] {SCSI: task priority} */
+	__u32 max_response_len;	/* [i] in bytes */
+	__u64 response;		/* [i], [*o] {SCSI: (auto)sense data} */
 
 	/* "din_" for data in (from device); "dout_" for data out (to device) */
-	u32 dout_xfer_len;	/* [i] bytes to be transferred to device */
-	u32 din_xfer_len;	/* [i] bytes to be transferred from device */
-	u64 dout_xferp;		/* [i], [*i] */
-	u64 din_xferp;		/* [i], [*o] */
+	__u32 dout_xfer_len;	/* [i] bytes to be transferred to device */
+	__u32 din_xfer_len;	/* [i] bytes to be transferred from device */
+	__u64 dout_xferp;	/* [i], [*i] */
+	__u64 din_xferp;	/* [i], [*o] */
 
-	u32 timeout;		/* [i] units: millisecond */
-	u32 flags;		/* [i] bit mask */
-	u64 usr_ptr;		/* [i->o] unused internally */
-	u32 spare_in;		/* [i] */
+	__u32 timeout;		/* [i] units: millisecond */
+	__u32 flags;		/* [i] bit mask */
+	__u64 usr_ptr;		/* [i->o] unused internally */
+	__u32 spare_in;		/* [i] */
 
-	u32 driver_status;	/* [o] 0 -> ok */
-	u32 transport_status;	/* [o] 0 -> ok */
-	u32 device_status;	/* [o] {SCSI: command completion status} */
-	u32 retry_delay;	/* [o] {SCSI: status auxiliary information} */
-	u32 info;		/* [o] additional information */
-	u32 duration;		/* [o] time to complete, in milliseconds */
-	u32 response_len;	/* [o] bytes of response actually written */
-	s32 din_resid;		/* [o] actual_din_xfer_len - din_xfer_len */
-	u32 generated_tag;	/* [o] {SCSI: task tag that transport chose} */
-	u32 spare_out;		/* [o] */
+	__u32 driver_status;	/* [o] 0 -> ok */
+	__u32 transport_status;	/* [o] 0 -> ok */
+	__u32 device_status;	/* [o] {SCSI: command completion status} */
+	__u32 retry_delay;	/* [o] {SCSI: status auxiliary information} */
+	__u32 info;		/* [o] additional information */
+	__u32 duration;		/* [o] time to complete, in milliseconds */
+	__u32 response_len;	/* [o] bytes of response actually written */
+	__s32 din_resid;	/* [o] actual_din_xfer_len - din_xfer_len */
+	__u32 generated_tag;	/* [o] {SCSI: task tag that transport chose} */
+	__u32 spare_out;	/* [o] */
 
-	u32 padding;
+	__u32 padding;
 };
 
 #ifdef __KERNEL__

commit 1594a3f0eb526c73bc3915e8da13f2abf0ea1acd
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Wed Dec 20 11:23:35 2006 +0100

    bsg: use u32 etc instead of uint32_t
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/bsg.h b/include/linux/bsg.h
index 0d212cc06abf..f968726cfadc 100644
--- a/include/linux/bsg.h
+++ b/include/linux/bsg.h
@@ -2,42 +2,42 @@
 #define BSG_H
 
 struct sg_io_v4 {
-	int32_t guard;		/* [i] 'Q' to differentiate from v3 */
-	uint32_t protocol;	/* [i] 0 -> SCSI , .... */
-	uint32_t subprotocol;	/* [i] 0 -> SCSI command, 1 -> SCSI task
+	s32 guard;		/* [i] 'Q' to differentiate from v3 */
+	u32 protocol;		/* [i] 0 -> SCSI , .... */
+	u32 subprotocol;	/* [i] 0 -> SCSI command, 1 -> SCSI task
 				   management function, .... */
 
-	uint32_t request_len;	/* [i] in bytes */
-	uint64_t request;	/* [i], [*i] {SCSI: cdb} */
-	uint32_t request_attr;	/* [i] {SCSI: task attribute} */
-	uint32_t request_tag;	/* [i] {SCSI: task tag (only if flagged)} */
-	uint32_t request_priority;	/* [i] {SCSI: task priority} */
-	uint32_t max_response_len;	/* [i] in bytes */
-	uint64_t response;	/* [i], [*o] {SCSI: (auto)sense data} */
+	u32 request_len;	/* [i] in bytes */
+	u64 request;		/* [i], [*i] {SCSI: cdb} */
+	u32 request_attr;	/* [i] {SCSI: task attribute} */
+	u32 request_tag;	/* [i] {SCSI: task tag (only if flagged)} */
+	u32 request_priority;	/* [i] {SCSI: task priority} */
+	u32 max_response_len;	/* [i] in bytes */
+	u64 response;		/* [i], [*o] {SCSI: (auto)sense data} */
 
 	/* "din_" for data in (from device); "dout_" for data out (to device) */
-	uint32_t dout_xfer_len;	/* [i] bytes to be transferred to device */
-	uint32_t din_xfer_len;	/* [i] bytes to be transferred from device */
-	uint64_t dout_xferp;	/* [i], [*i] */
-	uint64_t din_xferp;	/* [i], [*o] */
+	u32 dout_xfer_len;	/* [i] bytes to be transferred to device */
+	u32 din_xfer_len;	/* [i] bytes to be transferred from device */
+	u64 dout_xferp;		/* [i], [*i] */
+	u64 din_xferp;		/* [i], [*o] */
 
-	uint32_t timeout;	/* [i] units: millisecond */
-	uint32_t flags;		/* [i] bit mask */
-	uint64_t usr_ptr;	/* [i->o] unused internally */
-	uint32_t spare_in;	/* [i] */
+	u32 timeout;		/* [i] units: millisecond */
+	u32 flags;		/* [i] bit mask */
+	u64 usr_ptr;		/* [i->o] unused internally */
+	u32 spare_in;		/* [i] */
 
-	uint32_t driver_status;	/* [o] 0 -> ok */
-	uint32_t transport_status;	/* [o] 0 -> ok */
-	uint32_t device_status;	/* [o] {SCSI: command completion status} */
-	uint32_t retry_delay;	/* [o] {SCSI: status auxiliary information} */
-	uint32_t info;		/* [o] additional information */
-	uint32_t duration;	/* [o] time to complete, in milliseconds */
-	uint32_t response_len;	/* [o] bytes of response actually written */
-	int32_t din_resid;	/* [o] actual_din_xfer_len - din_xfer_len */
-	uint32_t generated_tag;	/* [o] {SCSI: task tag that transport chose} */
-	uint32_t spare_out;	/* [o] */
+	u32 driver_status;	/* [o] 0 -> ok */
+	u32 transport_status;	/* [o] 0 -> ok */
+	u32 device_status;	/* [o] {SCSI: command completion status} */
+	u32 retry_delay;	/* [o] {SCSI: status auxiliary information} */
+	u32 info;		/* [o] additional information */
+	u32 duration;		/* [o] time to complete, in milliseconds */
+	u32 response_len;	/* [o] bytes of response actually written */
+	s32 din_resid;		/* [o] actual_din_xfer_len - din_xfer_len */
+	u32 generated_tag;	/* [o] {SCSI: task tag that transport chose} */
+	u32 spare_out;		/* [o] */
 
-	uint32_t padding;
+	u32 padding;
 };
 
 #ifdef __KERNEL__

commit 45977d0e87ac988d04fccfb89221727aaf8d78a4
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Wed Dec 20 11:19:32 2006 +0100

    bsg: add sg_io_v4 structure
    
    This patch adds sg_io_v4 structure that Doug proposed last month.
    
    There's one major change from the RFC. I dropped iovec, which needs
    compat stuff. The bsg code simply calls blk_rq_map_user against
    dout_xferp/din_xferp. So if possible, the page frames are directly
    mapped. If not possible, the block layer allocates new page frames and
    does memory copies.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/bsg.h b/include/linux/bsg.h
index dc0d7282c4cb..0d212cc06abf 100644
--- a/include/linux/bsg.h
+++ b/include/linux/bsg.h
@@ -1,6 +1,47 @@
 #ifndef BSG_H
 #define BSG_H
 
+struct sg_io_v4 {
+	int32_t guard;		/* [i] 'Q' to differentiate from v3 */
+	uint32_t protocol;	/* [i] 0 -> SCSI , .... */
+	uint32_t subprotocol;	/* [i] 0 -> SCSI command, 1 -> SCSI task
+				   management function, .... */
+
+	uint32_t request_len;	/* [i] in bytes */
+	uint64_t request;	/* [i], [*i] {SCSI: cdb} */
+	uint32_t request_attr;	/* [i] {SCSI: task attribute} */
+	uint32_t request_tag;	/* [i] {SCSI: task tag (only if flagged)} */
+	uint32_t request_priority;	/* [i] {SCSI: task priority} */
+	uint32_t max_response_len;	/* [i] in bytes */
+	uint64_t response;	/* [i], [*o] {SCSI: (auto)sense data} */
+
+	/* "din_" for data in (from device); "dout_" for data out (to device) */
+	uint32_t dout_xfer_len;	/* [i] bytes to be transferred to device */
+	uint32_t din_xfer_len;	/* [i] bytes to be transferred from device */
+	uint64_t dout_xferp;	/* [i], [*i] */
+	uint64_t din_xferp;	/* [i], [*o] */
+
+	uint32_t timeout;	/* [i] units: millisecond */
+	uint32_t flags;		/* [i] bit mask */
+	uint64_t usr_ptr;	/* [i->o] unused internally */
+	uint32_t spare_in;	/* [i] */
+
+	uint32_t driver_status;	/* [o] 0 -> ok */
+	uint32_t transport_status;	/* [o] 0 -> ok */
+	uint32_t device_status;	/* [o] {SCSI: command completion status} */
+	uint32_t retry_delay;	/* [o] {SCSI: status auxiliary information} */
+	uint32_t info;		/* [o] additional information */
+	uint32_t duration;	/* [o] time to complete, in milliseconds */
+	uint32_t response_len;	/* [o] bytes of response actually written */
+	int32_t din_resid;	/* [o] actual_din_xfer_len - din_xfer_len */
+	uint32_t generated_tag;	/* [o] {SCSI: task tag that transport chose} */
+	uint32_t spare_out;	/* [o] */
+
+	uint32_t padding;
+};
+
+#ifdef __KERNEL__
+
 #if defined(CONFIG_BLK_DEV_BSG)
 struct bsg_class_device {
 	struct class_device *class_dev;
@@ -18,4 +59,6 @@ struct bsg_class_device { };
 #define bsg_unregister_disk(disk)	do { } while (0)
 #endif
 
+#endif /* __KERNEL__ */
+
 #endif

commit 3d6392cfbd7dc11f23058e3493683afab4ac13a3
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Mon Jul 9 12:38:05 2007 +0200

    bsg: support for full generic block layer SG v3
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/bsg.h b/include/linux/bsg.h
new file mode 100644
index 000000000000..dc0d7282c4cb
--- /dev/null
+++ b/include/linux/bsg.h
@@ -0,0 +1,21 @@
+#ifndef BSG_H
+#define BSG_H
+
+#if defined(CONFIG_BLK_DEV_BSG)
+struct bsg_class_device {
+	struct class_device *class_dev;
+	struct device *dev;
+	int minor;
+	struct gendisk *disk;
+	struct list_head list;
+};
+
+extern int bsg_register_disk(struct gendisk *);
+extern void bsg_unregister_disk(struct gendisk *);
+#else
+struct bsg_class_device { };
+#define bsg_register_disk(disk)		(0)
+#define bsg_unregister_disk(disk)	do { } while (0)
+#endif
+
+#endif
