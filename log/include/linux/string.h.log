commit 47227d27e2fcb01a9e8f5958d8997cf47a820afc
Author: Daniel Axtens <dja@axtens.net>
Date:   Wed Jun 3 15:56:46 2020 -0700

    string.h: fix incompatibility between FORTIFY_SOURCE and KASAN
    
    The memcmp KASAN self-test fails on a kernel with both KASAN and
    FORTIFY_SOURCE.
    
    When FORTIFY_SOURCE is on, a number of functions are replaced with
    fortified versions, which attempt to check the sizes of the operands.
    However, these functions often directly invoke __builtin_foo() once they
    have performed the fortify check.  Using __builtins may bypass KASAN
    checks if the compiler decides to inline it's own implementation as
    sequence of instructions, rather than emit a function call that goes out
    to a KASAN-instrumented implementation.
    
    Why is only memcmp affected?
    ============================
    
    Of the string and string-like functions that kasan_test tests, only memcmp
    is replaced by an inline sequence of instructions in my testing on x86
    with gcc version 9.2.1 20191008 (Ubuntu 9.2.1-9ubuntu2).
    
    I believe this is due to compiler heuristics.  For example, if I annotate
    kmalloc calls with the alloc_size annotation (and disable some fortify
    compile-time checking!), the compiler will replace every memset except the
    one in kmalloc_uaf_memset with inline instructions.  (I have some WIP
    patches to add this annotation.)
    
    Does this affect other functions in string.h?
    =============================================
    
    Yes. Anything that uses __builtin_* rather than __real_* could be
    affected. This looks like:
    
     - strncpy
     - strcat
     - strlen
     - strlcpy maybe, under some circumstances?
     - strncat under some circumstances
     - memset
     - memcpy
     - memmove
     - memcmp (as noted)
     - memchr
     - strcpy
    
    Whether a function call is emitted always depends on the compiler.  Most
    bugs should get caught by FORTIFY_SOURCE, but the missed memcmp test shows
    that this is not always the case.
    
    Isn't FORTIFY_SOURCE disabled with KASAN?
    ========================================-
    
    The string headers on all arches supporting KASAN disable fortify with
    kasan, but only when address sanitisation is _also_ disabled.  For example
    from x86:
    
     #if defined(CONFIG_KASAN) && !defined(__SANITIZE_ADDRESS__)
     /*
      * For files that are not instrumented (e.g. mm/slub.c) we
      * should use not instrumented version of mem* functions.
      */
     #define memcpy(dst, src, len) __memcpy(dst, src, len)
     #define memmove(dst, src, len) __memmove(dst, src, len)
     #define memset(s, c, n) __memset(s, c, n)
    
     #ifndef __NO_FORTIFY
     #define __NO_FORTIFY /* FORTIFY_SOURCE uses __builtin_memcpy, etc. */
     #endif
    
     #endif
    
    This comes from commit 6974f0c4555e ("include/linux/string.h: add the
    option of fortified string.h functions"), and doesn't work when KASAN is
    enabled and the file is supposed to be sanitised - as with test_kasan.c
    
    I'm pretty sure this is not wrong, but not as expansive it should be:
    
     * we shouldn't use __builtin_memcpy etc in files where we don't have
       instrumentation - it could devolve into a function call to memcpy,
       which will be instrumented. Rather, we should use __memcpy which
       by convention is not instrumented.
    
     * we also shouldn't be using __builtin_memcpy when we have a KASAN
       instrumented file, because it could be replaced with inline asm
       that will not be instrumented.
    
    What is correct behaviour?
    ==========================
    
    Firstly, there is some overlap between fortification and KASAN: both
    provide some level of _runtime_ checking. Only fortify provides
    compile-time checking.
    
    KASAN and fortify can pick up different things at runtime:
    
     - Some fortify functions, notably the string functions, could easily be
       modified to consider sub-object sizes (e.g. members within a struct),
       and I have some WIP patches to do this. KASAN cannot detect these
       because it cannot insert poision between members of a struct.
    
     - KASAN can detect many over-reads/over-writes when the sizes of both
       operands are unknown, which fortify cannot.
    
    So there are a couple of options:
    
     1) Flip the test: disable fortify in santised files and enable it in
        unsanitised files. This at least stops us missing KASAN checking, but
        we lose the fortify checking.
    
     2) Make the fortify code always call out to real versions. Do this only
        for KASAN, for fear of losing the inlining opportunities we get from
        __builtin_*.
    
    (We can't use kasan_check_{read,write}: because the fortify functions are
    _extern inline_, you can't include _static_ inline functions without a
    compiler warning. kasan_check_{read,write} are static inline so we can't
    use them even when they would otherwise be suitable.)
    
    Take approach 2 and call out to real versions when KASAN is enabled.
    
    Use __underlying_foo to distinguish from __real_foo: __real_foo always
    refers to the kernel's implementation of foo, __underlying_foo could be
    either the kernel implementation or the __builtin_foo implementation.
    
    This is sometimes enough to make the memcmp test succeed with
    FORTIFY_SOURCE enabled. It is at least enough to get the function call
    into the module. One more fix is needed to make it reliable: see the next
    patch.
    
    Fixes: 6974f0c4555e ("include/linux/string.h: add the option of fortified string.h functions")
    Signed-off-by: Daniel Axtens <dja@axtens.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Tested-by: David Gow <davidgow@google.com>
    Reviewed-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Daniel Micay <danielmicay@gmail.com>
    Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
    Cc: Alexander Potapenko <glider@google.com>
    Link: http://lkml.kernel.org/r/20200423154503.5103-3-dja@axtens.net
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 6dfbb2efa815..9b7a0632e87a 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -272,6 +272,31 @@ void __read_overflow3(void) __compiletime_error("detected read beyond size of ob
 void __write_overflow(void) __compiletime_error("detected write beyond size of object passed as 1st parameter");
 
 #if !defined(__NO_FORTIFY) && defined(__OPTIMIZE__) && defined(CONFIG_FORTIFY_SOURCE)
+
+#ifdef CONFIG_KASAN
+extern void *__underlying_memchr(const void *p, int c, __kernel_size_t size) __RENAME(memchr);
+extern int __underlying_memcmp(const void *p, const void *q, __kernel_size_t size) __RENAME(memcmp);
+extern void *__underlying_memcpy(void *p, const void *q, __kernel_size_t size) __RENAME(memcpy);
+extern void *__underlying_memmove(void *p, const void *q, __kernel_size_t size) __RENAME(memmove);
+extern void *__underlying_memset(void *p, int c, __kernel_size_t size) __RENAME(memset);
+extern char *__underlying_strcat(char *p, const char *q) __RENAME(strcat);
+extern char *__underlying_strcpy(char *p, const char *q) __RENAME(strcpy);
+extern __kernel_size_t __underlying_strlen(const char *p) __RENAME(strlen);
+extern char *__underlying_strncat(char *p, const char *q, __kernel_size_t count) __RENAME(strncat);
+extern char *__underlying_strncpy(char *p, const char *q, __kernel_size_t size) __RENAME(strncpy);
+#else
+#define __underlying_memchr	__builtin_memchr
+#define __underlying_memcmp	__builtin_memcmp
+#define __underlying_memcpy	__builtin_memcpy
+#define __underlying_memmove	__builtin_memmove
+#define __underlying_memset	__builtin_memset
+#define __underlying_strcat	__builtin_strcat
+#define __underlying_strcpy	__builtin_strcpy
+#define __underlying_strlen	__builtin_strlen
+#define __underlying_strncat	__builtin_strncat
+#define __underlying_strncpy	__builtin_strncpy
+#endif
+
 __FORTIFY_INLINE char *strncpy(char *p, const char *q, __kernel_size_t size)
 {
 	size_t p_size = __builtin_object_size(p, 0);
@@ -279,14 +304,14 @@ __FORTIFY_INLINE char *strncpy(char *p, const char *q, __kernel_size_t size)
 		__write_overflow();
 	if (p_size < size)
 		fortify_panic(__func__);
-	return __builtin_strncpy(p, q, size);
+	return __underlying_strncpy(p, q, size);
 }
 
 __FORTIFY_INLINE char *strcat(char *p, const char *q)
 {
 	size_t p_size = __builtin_object_size(p, 0);
 	if (p_size == (size_t)-1)
-		return __builtin_strcat(p, q);
+		return __underlying_strcat(p, q);
 	if (strlcat(p, q, p_size) >= p_size)
 		fortify_panic(__func__);
 	return p;
@@ -300,7 +325,7 @@ __FORTIFY_INLINE __kernel_size_t strlen(const char *p)
 	/* Work around gcc excess stack consumption issue */
 	if (p_size == (size_t)-1 ||
 	    (__builtin_constant_p(p[p_size - 1]) && p[p_size - 1] == '\0'))
-		return __builtin_strlen(p);
+		return __underlying_strlen(p);
 	ret = strnlen(p, p_size);
 	if (p_size <= ret)
 		fortify_panic(__func__);
@@ -333,7 +358,7 @@ __FORTIFY_INLINE size_t strlcpy(char *p, const char *q, size_t size)
 			__write_overflow();
 		if (len >= p_size)
 			fortify_panic(__func__);
-		__builtin_memcpy(p, q, len);
+		__underlying_memcpy(p, q, len);
 		p[len] = '\0';
 	}
 	return ret;
@@ -346,12 +371,12 @@ __FORTIFY_INLINE char *strncat(char *p, const char *q, __kernel_size_t count)
 	size_t p_size = __builtin_object_size(p, 0);
 	size_t q_size = __builtin_object_size(q, 0);
 	if (p_size == (size_t)-1 && q_size == (size_t)-1)
-		return __builtin_strncat(p, q, count);
+		return __underlying_strncat(p, q, count);
 	p_len = strlen(p);
 	copy_len = strnlen(q, count);
 	if (p_size < p_len + copy_len + 1)
 		fortify_panic(__func__);
-	__builtin_memcpy(p + p_len, q, copy_len);
+	__underlying_memcpy(p + p_len, q, copy_len);
 	p[p_len + copy_len] = '\0';
 	return p;
 }
@@ -363,7 +388,7 @@ __FORTIFY_INLINE void *memset(void *p, int c, __kernel_size_t size)
 		__write_overflow();
 	if (p_size < size)
 		fortify_panic(__func__);
-	return __builtin_memset(p, c, size);
+	return __underlying_memset(p, c, size);
 }
 
 __FORTIFY_INLINE void *memcpy(void *p, const void *q, __kernel_size_t size)
@@ -378,7 +403,7 @@ __FORTIFY_INLINE void *memcpy(void *p, const void *q, __kernel_size_t size)
 	}
 	if (p_size < size || q_size < size)
 		fortify_panic(__func__);
-	return __builtin_memcpy(p, q, size);
+	return __underlying_memcpy(p, q, size);
 }
 
 __FORTIFY_INLINE void *memmove(void *p, const void *q, __kernel_size_t size)
@@ -393,7 +418,7 @@ __FORTIFY_INLINE void *memmove(void *p, const void *q, __kernel_size_t size)
 	}
 	if (p_size < size || q_size < size)
 		fortify_panic(__func__);
-	return __builtin_memmove(p, q, size);
+	return __underlying_memmove(p, q, size);
 }
 
 extern void *__real_memscan(void *, int, __kernel_size_t) __RENAME(memscan);
@@ -419,7 +444,7 @@ __FORTIFY_INLINE int memcmp(const void *p, const void *q, __kernel_size_t size)
 	}
 	if (p_size < size || q_size < size)
 		fortify_panic(__func__);
-	return __builtin_memcmp(p, q, size);
+	return __underlying_memcmp(p, q, size);
 }
 
 __FORTIFY_INLINE void *memchr(const void *p, int c, __kernel_size_t size)
@@ -429,7 +454,7 @@ __FORTIFY_INLINE void *memchr(const void *p, int c, __kernel_size_t size)
 		__read_overflow();
 	if (p_size < size)
 		fortify_panic(__func__);
-	return __builtin_memchr(p, c, size);
+	return __underlying_memchr(p, c, size);
 }
 
 void *__real_memchr_inv(const void *s, int c, size_t n) __RENAME(memchr_inv);
@@ -460,11 +485,22 @@ __FORTIFY_INLINE char *strcpy(char *p, const char *q)
 	size_t p_size = __builtin_object_size(p, 0);
 	size_t q_size = __builtin_object_size(q, 0);
 	if (p_size == (size_t)-1 && q_size == (size_t)-1)
-		return __builtin_strcpy(p, q);
+		return __underlying_strcpy(p, q);
 	memcpy(p, q, strlen(q) + 1);
 	return p;
 }
 
+/* Don't use these outside the FORITFY_SOURCE implementation */
+#undef __underlying_memchr
+#undef __underlying_memcmp
+#undef __underlying_memcpy
+#undef __underlying_memmove
+#undef __underlying_memset
+#undef __underlying_strcat
+#undef __underlying_strcpy
+#undef __underlying_strlen
+#undef __underlying_strncat
+#undef __underlying_strncpy
 #endif
 
 /**

commit 0bee0cece2a6a71ccc347fdc1d46cf638cd5fd1c
Author: Yury Norov <yury.norov@gmail.com>
Date:   Mon Feb 3 17:37:20 2020 -0800

    lib/string: add strnchrnul()
    
    Patch series "lib: rework bitmap_parse", v5.
    
    Similarl to the recently revisited bitmap_parselist(), bitmap_parse() is
    ineffective and overcomplicated.  This series reworks it, aligns its
    interface with bitmap_parselist() and makes it simpler to use.
    
    The series also adds a test for the function and fixes usage of it in
    cpumask_parse() according to the new design - drops the calculating of
    length of an input string.
    
    bitmap_parse() takes the array of numbers to be put into the map in the BE
    order which is reversed to the natural LE order for bitmaps.  For example,
    to construct bitmap containing a bit on the position 42, we have to put a
    line '400,0'.  Current implementation reads chunk one by one from the
    beginning ('400' before '0') and makes bitmap shift after each successful
    parse.  It makes the complexity of the whole process as O(n^2).  We can do
    it in reverse direction ('0' before '400') and avoid shifting, but it
    requires reverse parsing helpers.
    
    This patch (of 7):
    
    New function works like strchrnul() with a length limited string.
    
    Link: http://lkml.kernel.org/r/20200102043031.30357-2-yury.norov@gmail.com
    Signed-off-by: Yury Norov <yury.norov@gmail.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Amritha Nambiar <amritha.nambiar@intel.com>
    Cc: Willem de Bruijn <willemb@google.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: "Tobin C . Harding" <tobin@kernel.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Miklos Szeredi <mszeredi@redhat.com>
    Cc: Vineet Gupta <vineet.gupta1@synopsys.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Steffen Klassert <steffen.klassert@secunet.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 02894e417565..6dfbb2efa815 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -62,6 +62,7 @@ extern char * strchr(const char *,int);
 #ifndef __HAVE_ARCH_STRCHRNUL
 extern char * strchrnul(const char *,int);
 #endif
+extern char * strnchrnul(const char *, size_t, int);
 #ifndef __HAVE_ARCH_STRNCHR
 extern char * strnchr(const char *, size_t, int);
 #endif

commit e4dcad204d3a281be6f8573e0a82648a4ad84e69
Author: Joel Fernandes (Google) <joel@joelfernandes.org>
Date:   Sat Nov 30 17:50:33 2019 -0800

    rss_stat: add support to detect RSS updates of external mm
    
    When a process updates the RSS of a different process, the rss_stat
    tracepoint appears in the context of the process doing the update.  This
    can confuse userspace that the RSS of process doing the update is
    updated, while in reality a different process's RSS was updated.
    
    This issue happens in reclaim paths such as with direct reclaim or
    background reclaim.
    
    This patch adds more information to the tracepoint about whether the mm
    being updated belongs to the current process's context (curr field).  We
    also include a hash of the mm pointer so that the process who the mm
    belongs to can be uniquely identified (mm_id field).
    
    Also vsprintf.c is refactored a bit to allow reuse of hashing code.
    
    [akpm@linux-foundation.org: remove unused local `str']
    [joelaf@google.com: inline call to ptr_to_hashval]
      Link: http://lore.kernel.org/r/20191113153816.14b95acd@gandalf.local.home
      Link: http://lkml.kernel.org/r/20191114164622.GC233237@google.com
    Link: http://lkml.kernel.org/r/20191106024452.81923-1-joel@joelfernandes.org
    Signed-off-by: Joel Fernandes (Google) <joel@joelfernandes.org>
    Reported-by: Ioannis Ilkos <ilkos@google.com>
    Acked-by: Petr Mladek <pmladek@suse.com>        [lib/vsprintf.c]
    Cc: Tim Murray <timmurray@google.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Carmen Jackson <carmenjackson@google.com>
    Cc: Mayank Gupta <mayankgupta@google.com>
    Cc: Daniel Colascione <dancol@google.com>
    Cc: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Cc: Minchan Kim <minchan@kernel.org>
    Cc: "Aneesh Kumar K.V" <aneesh.kumar@linux.ibm.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Ralph Campbell <rcampbell@nvidia.com>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index b6ccdc2c7f02..02894e417565 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -216,6 +216,8 @@ int bprintf(u32 *bin_buf, size_t size, const char *fmt, ...) __printf(3, 4);
 extern ssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,
 				       const void *from, size_t available);
 
+int ptr_to_hashval(const void *ptr, unsigned long *hashval_out);
+
 /**
  * strstarts - does @str start with @prefix?
  * @str: string to examine

commit bec500777089b3c96c53681fc0aa6fee59711d4a
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Mon Oct 7 18:00:02 2019 -0400

    lib/string: Make memzero_explicit() inline instead of external
    
    With the use of the barrier implied by barrier_data(), there is no need
    for memzero_explicit() to be extern. Making it inline saves the overhead
    of a function call, and allows the code to be reused in arch/*/purgatory
    without having to duplicate the implementation.
    
    Tested-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: H . Peter Anvin <hpa@zytor.com>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephan Mueller <smueller@chronox.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-crypto@vger.kernel.org
    Cc: linux-s390@vger.kernel.org
    Fixes: 906a4bb97f5d ("crypto: sha256 - Use get/put_unaligned_be32 to get input, memzero_explicit")
    Link: https://lkml.kernel.org/r/20191007220000.GA408752@rani.riverdale.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index b2f9df7f0761..b6ccdc2c7f02 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -227,7 +227,26 @@ static inline bool strstarts(const char *str, const char *prefix)
 }
 
 size_t memweight(const void *ptr, size_t bytes);
-void memzero_explicit(void *s, size_t count);
+
+/**
+ * memzero_explicit - Fill a region of memory (e.g. sensitive
+ *		      keying data) with 0s.
+ * @s: Pointer to the start of the area.
+ * @count: The size of the area.
+ *
+ * Note: usually using memset() is just fine (!), but in cases
+ * where clearing out _local_ data at the end of a scope is
+ * necessary, memzero_explicit() should be used instead in
+ * order to prevent the compiler from optimising away zeroing.
+ *
+ * memzero_explicit() doesn't need an arch-specific version as
+ * it just invokes the one of memset() implicitly.
+ */
+static inline void memzero_explicit(void *s, size_t count)
+{
+	memset(s, 0, count);
+	barrier_data(s);
+}
 
 /**
  * kbasename - return the last part of a pathname.

commit 917cda2790c4bd624c5191b8d9edd12121749e86
Author: Joe Perches <joe@perches.com>
Date:   Wed Sep 25 16:46:13 2019 -0700

    kernel-doc: core-api: include string.h into core-api
    
    core-api should show all the various string functions including the newly
    added stracpy and stracpy_pad.
    
    Miscellanea:
    
    o Update the Returns: value for strscpy
    o fix a defect with %NUL)
    
    [joe@perches.com: correct return of -E2BIG descriptions]
      Link: http://lkml.kernel.org/r/29f998b4c1a9d69fbeae70500ba0daa4b340c546.1563889130.git.joe@perches.com
    Link: http://lkml.kernel.org/r/224a6ebf39955f4107c0c376d66155d970e46733.1563841972.git.joe@perches.com
    Signed-off-by: Joe Perches <joe@perches.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Stephen Kitt <steve@sk2.org>
    Cc: Nitin Gote <nitin.r.gote@intel.com>
    Cc: Rasmus Villemoes <rasmus.villemoes@prevas.dk>
    Cc: Jann Horn <jannh@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 4deb11f7976b..b2f9df7f0761 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -474,8 +474,9 @@ static inline void memcpy_and_pad(void *dest, size_t dest_len,
  * But this can lead to bugs due to typos, or if prefix is a pointer
  * and not a constant. Instead use str_has_prefix().
  *
- * Returns: 0 if @str does not start with @prefix
-         strlen(@prefix) if @str does start with @prefix
+ * Returns:
+ * * strlen(@prefix) if @str starts with @prefix
+ * * 0 if @str does not start with @prefix
  */
 static __always_inline size_t str_has_prefix(const char *str, const char *prefix)
 {

commit 458a3bf82df4fe1f951d0f52b1e0c1e9d5a88a3b
Author: Tobin C. Harding <tobin@kernel.org>
Date:   Fri Apr 5 12:58:58 2019 +1100

    lib/string: Add strscpy_pad() function
    
    We have a function to copy strings safely and we have a function to copy
    strings and zero the tail of the destination (if source string is
    shorter than destination buffer) but we do not have a function to do
    both at once.  This means developers must write this themselves if they
    desire this functionality.  This is a chore, and also leaves us open to
    off by one errors unnecessarily.
    
    Add a function that calls strscpy() then memset()s the tail to zero if
    the source string is shorter than the destination buffer.
    
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Tobin C. Harding <tobin@kernel.org>
    Signed-off-by: Shuah Khan <shuah@kernel.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 6ab0a6fa512e..4deb11f7976b 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -31,6 +31,10 @@ size_t strlcpy(char *, const char *, size_t);
 #ifndef __HAVE_ARCH_STRSCPY
 ssize_t strscpy(char *, const char *, size_t);
 #endif
+
+/* Wraps calls to strscpy()/memset(), no arch specific code required */
+ssize_t strscpy_pad(char *dest, const char *src, size_t count);
+
 #ifndef __HAVE_ARCH_STRCAT
 extern char * strcat(char *, const char *);
 #endif

commit 5f074f3e192f10c9fade898b9b3b8812e3d83342
Author: Nick Desaulniers <ndesaulniers@google.com>
Date:   Fri Apr 5 18:38:45 2019 -0700

    lib/string.c: implement a basic bcmp
    
    A recent optimization in Clang (r355672) lowers comparisons of the
    return value of memcmp against zero to comparisons of the return value
    of bcmp against zero.  This helps some platforms that implement bcmp
    more efficiently than memcmp.  glibc simply aliases bcmp to memcmp, but
    an optimized implementation is in the works.
    
    This results in linkage failures for all targets with Clang due to the
    undefined symbol.  For now, just implement bcmp as a tailcail to memcmp
    to unbreak the build.  This routine can be further optimized in the
    future.
    
    Other ideas discussed:
    
     * A weak alias was discussed, but breaks for architectures that define
       their own implementations of memcmp since aliases to declarations are
       not permitted (only definitions). Arch-specific memcmp
       implementations typically declare memcmp in C headers, but implement
       them in assembly.
    
     * -ffreestanding also is used sporadically throughout the kernel.
    
     * -fno-builtin-bcmp doesn't work when doing LTO.
    
    Link: https://bugs.llvm.org/show_bug.cgi?id=41035
    Link: https://code.woboq.org/userspace/glibc/string/memcmp.c.html#bcmp
    Link: https://github.com/llvm/llvm-project/commit/8e16d73346f8091461319a7dfc4ddd18eedcff13
    Link: https://github.com/ClangBuiltLinux/linux/issues/416
    Link: http://lkml.kernel.org/r/20190313211335.165605-1-ndesaulniers@google.com
    Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
    Reported-by: Nathan Chancellor <natechancellor@gmail.com>
    Reported-by: Adhemerval Zanella <adhemerval.zanella@linaro.org>
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Suggested-by: James Y Knight <jyknight@google.com>
    Suggested-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Suggested-by: Nathan Chancellor <natechancellor@gmail.com>
    Suggested-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Acked-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Reviewed-by: Nathan Chancellor <natechancellor@gmail.com>
    Tested-by: Nathan Chancellor <natechancellor@gmail.com>
    Reviewed-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: David Laight <David.Laight@ACULAB.COM>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 7927b875f80c..6ab0a6fa512e 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -150,6 +150,9 @@ extern void * memscan(void *,int,__kernel_size_t);
 #ifndef __HAVE_ARCH_MEMCMP
 extern int memcmp(const void *,const void *,__kernel_size_t);
 #endif
+#ifndef __HAVE_ARCH_BCMP
+extern int bcmp(const void *,const void *,__kernel_size_t);
+#endif
 #ifndef __HAVE_ARCH_MEMCHR
 extern void * memchr(const void *,int,__kernel_size_t);
 #endif

commit 72921427d46bf9731a1ab7864adc64c43dfae29f
Author: Steven Rostedt (VMware) <rostedt@goodmis.org>
Date:   Fri Dec 21 18:10:14 2018 -0500

    string.h: Add str_has_prefix() helper function
    
    A discussion came up in the trace triggers thread about converting a
    bunch of:
    
     strncmp(str, "const", sizeof("const") - 1)
    
    use cases into a helper macro. It started with:
    
            strncmp(str, const, sizeof(const) - 1)
    
    But then Joe Perches mentioned that if a const is not used, the
    sizeof() will be the size of a pointer, which can be bad. And that
    gcc will optimize strlen("const") into "sizeof("const") - 1".
    
    Thinking about this more, a quick grep in the kernel tree found several
    (thousands!) of cases that use this construct. A quick grep also
    revealed that there's probably several bugs in that use case. Some are
    that people forgot the "- 1" (which I found) and others could be that
    the constant for the sizeof is different than the constant (although, I
    haven't found any of those, but I also didn't look hard).
    
    I figured the best thing to do is to create a helper macro and place it
    into include/linux/string.h. And go around and fix all the open coded
    versions of it later.
    
    Note, gcc appears to optimize this when we make it into an always_inline
    static function, which removes a lot of issues that a macro produces.
    
    Link: http://lkml.kernel.org/r/e3e754f2bd18e56eaa8baf79bee619316ebf4cfc.1545161087.git.tom.zanussi@linux.intel.com
    Link: http://lkml.kernel.org/r/20181219211615.2298e781@gandalf.local.home
    Link: http://lkml.kernel.org/r/CAHk-=wg_sR-UEC1ggmkZpypOUYanL5CMX4R7ceuaV4QMf5jBtg@mail.gmail.com
    
    Cc: Tom Zanussi <zanussi@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Namhyung Kim <namhyung@kernel.org>
    Suggestions-by: Linus Torvalds <torvalds@linux-foundation.org>
    Suggestions-by: Joe Perches <joe@perches.com>
    Suggestions-by: Andreas Schwab <schwab@linux-m68k.org>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 27d0482e5e05..7927b875f80c 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -456,4 +456,24 @@ static inline void memcpy_and_pad(void *dest, size_t dest_len,
 		memcpy(dest, src, dest_len);
 }
 
+/**
+ * str_has_prefix - Test if a string has a given prefix
+ * @str: The string to test
+ * @prefix: The string to see if @str starts with
+ *
+ * A common way to test a prefix of a string is to do:
+ *  strncmp(str, prefix, sizeof(prefix) - 1)
+ *
+ * But this can lead to bugs due to typos, or if prefix is a pointer
+ * and not a constant. Instead use str_has_prefix().
+ *
+ * Returns: 0 if @str does not start with @prefix
+         strlen(@prefix) if @str does start with @prefix
+ */
+static __always_inline size_t str_has_prefix(const char *str, const char *prefix)
+{
+	size_t len = strlen(prefix);
+	return strncmp(str, prefix, len) == 0 ? len : 0;
+}
+
 #endif /* _LINUX_STRING_H_ */

commit ce76d938dd98817f998c905e01fbb99b072c0bf6
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Fri Oct 5 15:43:05 2018 +0300

    lib: Add memcat_p(): paste 2 pointer arrays together
    
    This adds a helper to paste 2 pointer arrays together, useful for merging
    various types of attribute arrays. There are a few places in the kernel
    tree where this is open coded, and I just added one more in the STM class.
    
    The naming is inspired by memset_p() and memcat(), and partial credit for
    it goes to Andy Shevchenko.
    
    This patch adds the function wrapped in a type-enforcing macro and a test
    module.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 4a5a0eb7df51..27d0482e5e05 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -131,6 +131,13 @@ static inline void *memset_p(void **p, void *v, __kernel_size_t n)
 		return memset64((uint64_t *)p, (uintptr_t)v, n);
 }
 
+extern void **__memcat_p(void **a, void **b);
+#define memcat_p(a, b) ({					\
+	BUILD_BUG_ON_MSG(!__same_type(*(a), *(b)),		\
+			 "type mismatch in memcat_p()");	\
+	(typeof(*a) *)__memcat_p((void **)(a), (void **)(b));	\
+})
+
 #ifndef __HAVE_ARCH_MEMCPY
 extern void * memcpy(void *,const void *,__kernel_size_t);
 #endif

commit 60622d68227d6d71fdfba5fb39f7f3d44cdd8815
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 3 17:06:21 2018 -0700

    x86/asm/memcpy_mcsafe: Return bytes remaining
    
    Machine check safe memory copies are currently deployed in the pmem
    driver whenever reading from persistent memory media, so that -EIO is
    returned rather than triggering a kernel panic. While this protects most
    pmem accesses, it is not complete in the filesystem-dax case. When
    filesystem-dax is enabled reads may bypass the block layer and the
    driver via dax_iomap_actor() and its usage of copy_to_iter().
    
    In preparation for creating a copy_to_iter() variant that can handle
    machine checks, teach memcpy_mcsafe() to return the number of bytes
    remaining rather than -EFAULT when an exception occurs.
    
    Co-developed-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: hch@lst.de
    Cc: linux-fsdevel@vger.kernel.org
    Cc: linux-nvdimm@lists.01.org
    Link: http://lkml.kernel.org/r/152539238119.31796.14318473522414462886.stgit@dwillia2-desk3.amr.corp.intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index dd39a690c841..4a5a0eb7df51 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -147,8 +147,8 @@ extern int memcmp(const void *,const void *,__kernel_size_t);
 extern void * memchr(const void *,int,__kernel_size_t);
 #endif
 #ifndef __HAVE_ARCH_MEMCPY_MCSAFE
-static inline __must_check int memcpy_mcsafe(void *dst, const void *src,
-		size_t cnt)
+static inline __must_check unsigned long memcpy_mcsafe(void *dst,
+		const void *src, size_t cnt)
 {
 	memcpy(dst, src, cnt);
 	return 0;

commit 19e7b5f99474107e8d0b4b3e4652fa19ddb87efc
Merge: 26064ea409b4 ce4c253573ad
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 31 09:25:20 2018 -0800

    Merge branch 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc vfs updates from Al Viro:
     "All kinds of misc stuff, without any unifying topic, from various
      people.
    
      Neil's d_anon patch, several bugfixes, introduction of kvmalloc
      analogue of kmemdup_user(), extending bitfield.h to deal with
      fixed-endians, assorted cleanups all over the place..."
    
    * 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (28 commits)
      alpha: osf_sys.c: use timespec64 where appropriate
      alpha: osf_sys.c: fix put_tv32 regression
      jffs2: Fix use-after-free bug in jffs2_iget()'s error handling path
      dcache: delete unused d_hash_mask
      dcache: subtract d_hash_shift from 32 in advance
      fs/buffer.c: fold init_buffer() into init_page_buffers()
      fs: fold __inode_permission() into inode_permission()
      fs: add RWF_APPEND
      sctp: use vmemdup_user() rather than badly open-coding memdup_user()
      snd_ctl_elem_init_enum_names(): switch to vmemdup_user()
      replace_user_tlv(): switch to vmemdup_user()
      new primitive: vmemdup_user()
      memdup_user(): switch to GFP_USER
      eventfd: fold eventfd_ctx_get() into eventfd_ctx_fileget()
      eventfd: fold eventfd_ctx_read() into eventfd_read()
      eventfd: convert to use anon_inode_getfd()
      nfs4file: get rid of pointless include of btrfs.h
      uvc_v4l2: clean copyin/copyout up
      vme_user: don't use __copy_..._user()
      usx2y: don't bother with memdup_user() for 16-byte structure
      ...

commit 13ddd1667e7f01071cdf120132238ffca004a88e
Merge: 289104c9a45c 03eac8b22194
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 30 15:09:47 2018 -0800

    Merge branch 'for-4.16' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/cgroup
    
    Pull cgroup updates from Tejun Heo:
     "Nothing too interesting. Documentation updates and trivial changes;
      however, this pull request does containt he previusly discussed
      dropping of __must_check from strscpy()"
    
    * 'for-4.16' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/cgroup:
      Documentation: Fix 'file_mapped' -> 'mapped_file'
      string: drop __must_check from strscpy() and restore strscpy() usages in cgroup
      cgroup, docs: document the root cgroup behavior of cpu and io controllers
      cgroup-v2.txt: fix typos
      cgroup: Update documentation reference
      Documentation/cgroup-v1: fix outdated programming details
      cgroup, docs: document cgroup v2 device controller

commit 08a77676f9c5fc69a681ccd2cd8140e65dcb26c7
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Jan 9 07:21:15 2018 -0800

    string: drop __must_check from strscpy() and restore strscpy() usages in cgroup
    
    e7fd37ba1217 ("cgroup: avoid copying strings longer than the buffers")
    converted possibly unsafe strncpy() usages in cgroup to strscpy().
    However, although the callsites are completely fine with truncated
    copied, because strscpy() is marked __must_check, it led to the
    following warnings.
    
      kernel/cgroup/cgroup.c: In function ‘cgroup_file_name’:
      kernel/cgroup/cgroup.c:1400:10: warning: ignoring return value of ‘strscpy’, declared with attribute warn_unused_result [-Wunused-result]
         strscpy(buf, cft->name, CGROUP_FILE_NAME_MAX);
                   ^
    
    To avoid the warnings, 50034ed49645 ("cgroup: use strlcpy() instead of
    strscpy() to avoid spurious warning") switched them to strlcpy().
    
    strlcpy() is worse than strlcpy() because it unconditionally runs
    strlen() on the source string, and the only reason we switched to
    strlcpy() here was because it was lacking __must_check, which doesn't
    reflect any material differences between the two function.  It's just
    that someone added __must_check to strscpy() and not to strlcpy().
    
    These basic string copy operations are used in variety of ways, and
    one of not-so-uncommon use cases is safely handling truncated copies,
    where the caller naturally doesn't care about the return value.  The
    __must_check doesn't match the actual use cases and forces users to
    opt for inferior variants which lack __must_check by happenstance or
    spread ugly (void) casts.
    
    Remove __must_check from strscpy() and restore strscpy() usages in
    cgroup.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Ma Shimiao <mashimiao.fnst@cn.fujitsu.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Chris Metcalf <cmetcalf@ezchip.com>

diff --git a/include/linux/string.h b/include/linux/string.h
index 410ecf17de3c..dfdf8afeac64 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -28,7 +28,7 @@ extern char * strncpy(char *,const char *, __kernel_size_t);
 size_t strlcpy(char *, const char *, size_t);
 #endif
 #ifndef __HAVE_ARCH_STRSCPY
-ssize_t __must_check strscpy(char *, const char *, size_t);
+ssize_t strscpy(char *, const char *, size_t);
 #endif
 #ifndef __HAVE_ARCH_STRCAT
 extern char * strcat(char *, const char *);

commit 50fd2f298bef9d1f69ac755f1fdf70cd98746be2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jan 7 13:06:15 2018 -0500

    new primitive: vmemdup_user()
    
    similar to memdup_user(), but does *not* guarantee that result will
    be physically contiguous; use only in cases where that's not a requirement
    and free it with kvfree().
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/string.h b/include/linux/string.h
index 410ecf17de3c..12d5429de0c8 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -11,6 +11,7 @@
 
 extern char *strndup_user(const char __user *, long);
 extern void *memdup_user(const void __user *, size_t);
+extern void *vmemdup_user(const void __user *, size_t);
 extern void *memdup_user_nul(const void __user *, size_t);
 
 /*

commit 146734b091430c80d80bb96b1139a96fb4bc830e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Dec 14 15:32:34 2017 -0800

    string.h: workaround for increased stack usage
    
    The hardened strlen() function causes rather large stack usage in at
    least one file in the kernel, in particular when CONFIG_KASAN is
    enabled:
    
      drivers/media/usb/em28xx/em28xx-dvb.c: In function 'em28xx_dvb_init':
      drivers/media/usb/em28xx/em28xx-dvb.c:2062:1: error: the frame size of 3256 bytes is larger than 204 bytes [-Werror=frame-larger-than=]
    
    Analyzing this problem led to the discovery that gcc fails to merge the
    stack slots for the i2c_board_info[] structures after we strlcpy() into
    them, due to the 'noreturn' attribute on the source string length check.
    
    I reported this as a gcc bug, but it is unlikely to get fixed for gcc-8,
    since it is relatively easy to work around, and it gets triggered
    rarely.  An earlier workaround I did added an empty inline assembly
    statement before the call to fortify_panic(), which works surprisingly
    well, but is really ugly and unintuitive.
    
    This is a new approach to the same problem, this time addressing it by
    not calling the 'extern __real_strnlen()' function for string constants
    where __builtin_strlen() is a compile-time constant and therefore known
    to be safe.
    
    We do this by checking if the last character in the string is a
    compile-time constant '\0'.  If it is, we can assume that strlen() of
    the string is also constant.
    
    As a side-effect, this should also improve the object code output for
    any other call of strlen() on a string constant.
    
    [akpm@linux-foundation.org: add comment]
    Link: http://lkml.kernel.org/r/20171205215143.3085755-1-arnd@arndb.de
    Link: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82365
    Link: https://patchwork.kernel.org/patch/9980413/
    Link: https://patchwork.kernel.org/patch/9974047/
    Fixes: 6974f0c4555 ("include/linux/string.h: add the option of fortified string.h functions")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
    Cc: Daniel Micay <danielmicay@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Martin Wilck <mwilck@suse.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 410ecf17de3c..cfd83eb2f926 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -259,7 +259,10 @@ __FORTIFY_INLINE __kernel_size_t strlen(const char *p)
 {
 	__kernel_size_t ret;
 	size_t p_size = __builtin_object_size(p, 0);
-	if (p_size == (size_t)-1)
+
+	/* Work around gcc excess stack consumption issue */
+	if (p_size == (size_t)-1 ||
+	    (__builtin_constant_p(p[p_size - 1]) && p[p_size - 1] == '\0'))
 		return __builtin_strlen(p);
 	ret = strnlen(p, p_size);
 	if (p_size <= ret)

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 54d21783e18d..410ecf17de3c 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _LINUX_STRING_H_
 #define _LINUX_STRING_H_
 

commit 1359798f9d4082eb04575efdd19512fbd9c28464
Author: Martin Wilck <mwilck@suse.com>
Date:   Wed Sep 6 14:36:57 2017 +0200

    string.h: un-fortify memcpy_and_pad
    
    The way I'd implemented the new helper memcpy_and_pad  with
    __FORTIFY_INLINE caused compiler warnings for certain kernel
    configurations.
    
    This helper is only used in a single place at this time, and thus
    doesn't benefit much from fortification. So simplify the code
    by dropping fortification support for now.
    
    Fixes: 01f33c336e2d "string.h: add memcpy_and_pad()"
    Signed-off-by: Martin Wilck <mwilck@suse.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/string.h b/include/linux/string.h
index e1eeb0a8a969..54d21783e18d 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -434,20 +434,9 @@ __FORTIFY_INLINE char *strcpy(char *p, const char *q)
  * @count: The number of bytes to copy
  * @pad: Character to use for padding if space is left in destination.
  */
-__FORTIFY_INLINE void memcpy_and_pad(void *dest, size_t dest_len,
-				     const void *src, size_t count, int pad)
+static inline void memcpy_and_pad(void *dest, size_t dest_len,
+				  const void *src, size_t count, int pad)
 {
-	size_t dest_size = __builtin_object_size(dest, 0);
-	size_t src_size = __builtin_object_size(src, 0);
-
-	if (__builtin_constant_p(dest_len) && __builtin_constant_p(count)) {
-		if (dest_size < dest_len && dest_size < count)
-			__write_overflow();
-		else if (src_size < dest_len && src_size < count)
-			__read_overflow3();
-	}
-	if (dest_size < dest_len)
-		fortify_panic(__func__);
 	if (dest_len > count) {
 		memcpy(dest, src, count);
 		memset(dest + count, pad,  dest_len - count);

commit 126e76ffbf78d9e948b641aadb265d16c57f5a3d
Merge: fbd01410e89a 175206cf9ab6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Sep 9 12:49:01 2017 -0700

    Merge branch 'for-4.14/block-postmerge' of git://git.kernel.dk/linux-block
    
    Pull followup block layer updates from Jens Axboe:
     "I ended up splitting the main pull request for this series into two,
      mainly because of clashes between NVMe fixes that went into 4.13 after
      the for-4.14 branches were split off. This pull request is mostly
      NVMe, but not exclusively. In detail, it contains:
    
       - Two pull request for NVMe changes from Christoph. Nothing new on
         the feature front, basically just fixes all over the map for the
         core bits, transport, rdma, etc.
    
       - Series from Bart, cleaning up various bits in the BFQ scheduler.
    
       - Series of bcache fixes, which has been lingering for a release or
         two. Coly sent this in, but patches from various people in this
         area.
    
       - Set of patches for BFQ from Paolo himself, updating both
         documentation and fixing some corner cases in performance.
    
       - Series from Omar, attempting to now get the 4k loop support
         correct. Our confidence level is higher this time.
    
       - Series from Shaohua for loop as well, improving O_DIRECT
         performance and fixing a use-after-free"
    
    * 'for-4.14/block-postmerge' of git://git.kernel.dk/linux-block: (74 commits)
      bcache: initialize dirty stripes in flash_dev_run()
      loop: set physical block size to logical block size
      bcache: fix bch_hprint crash and improve output
      bcache: Update continue_at() documentation
      bcache: silence static checker warning
      bcache: fix for gc and write-back race
      bcache: increase the number of open buckets
      bcache: Correct return value for sysfs attach errors
      bcache: correct cache_dirty_target in __update_writeback_rate()
      bcache: gc does not work when triggering by manual command
      bcache: Don't reinvent the wheel but use existing llist API
      bcache: do not subtract sectors_to_gc for bypassed IO
      bcache: fix sequential large write IO bypass
      bcache: Fix leak of bdev reference
      block/loop: remove unused field
      block/loop: fix use after free
      bfq: Use icq_to_bic() consistently
      bfq: Suppress compiler warnings about comparisons
      bfq: Check kstrtoul() return value
      bfq: Declare local functions static
      ...

commit 3b3c4babd898715926d24ae10aa64778ace33aae
Author: Matthew Wilcox <mawilcox@microsoft.com>
Date:   Fri Sep 8 16:13:48 2017 -0700

    lib/string.c: add multibyte memset functions
    
    Patch series "Multibyte memset variations", v4.
    
    A relatively common idiom we're missing is a function to fill an area of
    memory with a pattern which is larger than a single byte.  I first
    noticed this with a zram patch which wanted to fill a page with an
    'unsigned long' value.  There turn out to be quite a few places in the
    kernel which can benefit from using an optimised function rather than a
    loop; sometimes text size, sometimes speed, and sometimes both.  The
    optimised PowerPC version (not included here) improves performance by
    about 30% on POWER8 on just the raw memset_l().
    
    Most of the extra lines of code come from the three testcases I added.
    
    This patch (of 8):
    
    memset16(), memset32() and memset64() are like memset(), but allow the
    caller to fill the destination with a value larger than a single byte.
    memset_l() and memset_p() allow the caller to use unsigned long and
    pointer values respectively.
    
    Link: http://lkml.kernel.org/r/20170720184539.31609-2-willy@infradead.org
    Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: "James E.J. Bottomley" <jejb@linux.vnet.ibm.com>
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: David Miller <davem@davemloft.net>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Minchan Kim <minchan@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Russell King <rmk+kernel@armlinux.org.uk>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index a467e617eeb0..c8bdafffd2f0 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -99,6 +99,36 @@ extern __kernel_size_t strcspn(const char *,const char *);
 #ifndef __HAVE_ARCH_MEMSET
 extern void * memset(void *,int,__kernel_size_t);
 #endif
+
+#ifndef __HAVE_ARCH_MEMSET16
+extern void *memset16(uint16_t *, uint16_t, __kernel_size_t);
+#endif
+
+#ifndef __HAVE_ARCH_MEMSET32
+extern void *memset32(uint32_t *, uint32_t, __kernel_size_t);
+#endif
+
+#ifndef __HAVE_ARCH_MEMSET64
+extern void *memset64(uint64_t *, uint64_t, __kernel_size_t);
+#endif
+
+static inline void *memset_l(unsigned long *p, unsigned long v,
+		__kernel_size_t n)
+{
+	if (BITS_PER_LONG == 32)
+		return memset32((uint32_t *)p, v, n);
+	else
+		return memset64((uint64_t *)p, v, n);
+}
+
+static inline void *memset_p(void **p, void *v, __kernel_size_t n)
+{
+	if (BITS_PER_LONG == 32)
+		return memset32((uint32_t *)p, (uintptr_t)v, n);
+	else
+		return memset64((uint64_t *)p, (uintptr_t)v, n);
+}
+
 #ifndef __HAVE_ARCH_MEMCPY
 extern void * memcpy(void *,const void *,__kernel_size_t);
 #endif

commit 01f33c336e2d298ea5d4ce5d6e5bcd12865cc30f
Author: Martin Wilck <mwilck@suse.com>
Date:   Mon Aug 14 22:12:38 2017 +0200

    string.h: add memcpy_and_pad()
    
    This helper function is useful for the nvme subsystem, and maybe
    others.
    
    Note: the warnings reported by the kbuild test robot for this patch
    are actually generated by the use of CONFIG_PROFILE_ALL_BRANCHES
    together with __FORTIFY_INLINE.
    
    Signed-off-by: Martin Wilck <mwilck@suse.com>
    Reviewed-by: Sagi Grimberg <sagi@grimbeg.me>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/string.h b/include/linux/string.h
index a467e617eeb0..0bec4151b0eb 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -200,6 +200,7 @@ static inline const char *kbasename(const char *path)
 void fortify_panic(const char *name) __noreturn __cold;
 void __read_overflow(void) __compiletime_error("detected read beyond size of object passed as 1st parameter");
 void __read_overflow2(void) __compiletime_error("detected read beyond size of object passed as 2nd parameter");
+void __read_overflow3(void) __compiletime_error("detected read beyond size of object passed as 3rd parameter");
 void __write_overflow(void) __compiletime_error("detected write beyond size of object passed as 1st parameter");
 
 #if !defined(__NO_FORTIFY) && defined(__OPTIMIZE__) && defined(CONFIG_FORTIFY_SOURCE)
@@ -395,4 +396,33 @@ __FORTIFY_INLINE char *strcpy(char *p, const char *q)
 
 #endif
 
+/**
+ * memcpy_and_pad - Copy one buffer to another with padding
+ * @dest: Where to copy to
+ * @dest_len: The destination buffer size
+ * @src: Where to copy from
+ * @count: The number of bytes to copy
+ * @pad: Character to use for padding if space is left in destination.
+ */
+__FORTIFY_INLINE void memcpy_and_pad(void *dest, size_t dest_len,
+				     const void *src, size_t count, int pad)
+{
+	size_t dest_size = __builtin_object_size(dest, 0);
+	size_t src_size = __builtin_object_size(src, 0);
+
+	if (__builtin_constant_p(dest_len) && __builtin_constant_p(count)) {
+		if (dest_size < dest_len && dest_size < count)
+			__write_overflow();
+		else if (src_size < dest_len && src_size < count)
+			__read_overflow3();
+	}
+	if (dest_size < dest_len)
+		fortify_panic(__func__);
+	if (dest_len > count) {
+		memcpy(dest, src, count);
+		memset(dest + count, pad,  dest_len - count);
+	} else
+		memcpy(dest, src, dest_len);
+}
+
 #endif /* _LINUX_STRING_H_ */

commit 78dcf73421a879d22319d3889119945b85954a68
Merge: 93ff81859733 fdb254db21bb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 15 12:00:42 2017 -0700

    Merge branch 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull ->s_options removal from Al Viro:
     "Preparations for fsmount/fsopen stuff (coming next cycle). Everything
      gets moved to explicit ->show_options(), killing ->s_options off +
      some cosmetic bits around fs/namespace.c and friends. Basically, the
      stuff needed to work with fsmount series with minimum of conflicts
      with other work.
    
      It's not strictly required for this merge window, but it would reduce
      the PITA during the coming cycle, so it would be nice to have those
      bits and pieces out of the way"
    
    * 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      isofs: Fix isofs_show_options()
      VFS: Kill off s_options and helpers
      orangefs: Implement show_options
      9p: Implement show_options
      isofs: Implement show_options
      afs: Implement show_options
      affs: Implement show_options
      befs: Implement show_options
      spufs: Implement show_options
      bpf: Implement show_options
      ramfs: Implement show_options
      pstore: Implement show_options
      omfs: Implement show_options
      hugetlbfs: Implement show_options
      VFS: Don't use save/replace_mount_options if not using generic_show_options
      VFS: Provide empty name qstr
      VFS: Make get_filesystem() return the affected filesystem
      VFS: Clean up whitespace in fs/namespace.c and fs/super.c
      Provide a function to create a NUL-terminated string from unterminated data

commit 077d2ba519b2e8bf1abd80cbade699b1de42cafe
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Fri Jul 14 17:28:12 2017 -0400

    replace incorrect strscpy use in FORTIFY_SOURCE
    
    Using strscpy was wrong because FORTIFY_SOURCE is passing the maximum
    possible size of the outermost object, but strscpy defines the count
    parameter as the exact buffer size, so this could copy past the end of
    the source.  This would still be wrong with the planned usage of
    __builtin_object_size(p, 1) for intra-object overflow checks since it's
    the maximum possible size of the specified object with no guarantee of
    it being that large.
    
    Reuse of the fortified functions like this currently makes the runtime
    error reporting less precise but that can be improved later on.
    
    Noticed by Dave Jones and KASAN.
    
    Signed-off-by: Daniel Micay <danielmicay@gmail.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Reported-by: Dave Jones <davej@codemonkey.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 96f5a5fd0377..049866760e8b 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -202,17 +202,6 @@ void __read_overflow2(void) __compiletime_error("detected read beyond size of ob
 void __write_overflow(void) __compiletime_error("detected write beyond size of object passed as 1st parameter");
 
 #if !defined(__NO_FORTIFY) && defined(__OPTIMIZE__) && defined(CONFIG_FORTIFY_SOURCE)
-__FORTIFY_INLINE char *strcpy(char *p, const char *q)
-{
-	size_t p_size = __builtin_object_size(p, 0);
-	size_t q_size = __builtin_object_size(q, 0);
-	if (p_size == (size_t)-1 && q_size == (size_t)-1)
-		return __builtin_strcpy(p, q);
-	if (strscpy(p, q, p_size < q_size ? p_size : q_size) < 0)
-		fortify_panic(__func__);
-	return p;
-}
-
 __FORTIFY_INLINE char *strncpy(char *p, const char *q, __kernel_size_t size)
 {
 	size_t p_size = __builtin_object_size(p, 0);
@@ -391,6 +380,18 @@ __FORTIFY_INLINE void *kmemdup(const void *p, size_t size, gfp_t gfp)
 		fortify_panic(__func__);
 	return __real_kmemdup(p, size, gfp);
 }
+
+/* defined after fortified strlen and memcpy to reuse them */
+__FORTIFY_INLINE char *strcpy(char *p, const char *q)
+{
+	size_t p_size = __builtin_object_size(p, 0);
+	size_t q_size = __builtin_object_size(q, 0);
+	if (p_size == (size_t)-1 && q_size == (size_t)-1)
+		return __builtin_strcpy(p, q);
+	memcpy(p, q, strlen(q) + 1);
+	return p;
+}
+
 #endif
 
 #endif /* _LINUX_STRING_H_ */

commit 6974f0c4555e285ab217cee58b6e874f776ff409
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Wed Jul 12 14:36:10 2017 -0700

    include/linux/string.h: add the option of fortified string.h functions
    
    This adds support for compiling with a rough equivalent to the glibc
    _FORTIFY_SOURCE=1 feature, providing compile-time and runtime buffer
    overflow checks for string.h functions when the compiler determines the
    size of the source or destination buffer at compile-time.  Unlike glibc,
    it covers buffer reads in addition to writes.
    
    GNU C __builtin_*_chk intrinsics are avoided because they would force a
    much more complex implementation.  They aren't designed to detect read
    overflows and offer no real benefit when using an implementation based
    on inline checks.  Inline checks don't add up to much code size and
    allow full use of the regular string intrinsics while avoiding the need
    for a bunch of _chk functions and per-arch assembly to avoid wrapper
    overhead.
    
    This detects various overflows at compile-time in various drivers and
    some non-x86 core kernel code.  There will likely be issues caught in
    regular use at runtime too.
    
    Future improvements left out of initial implementation for simplicity,
    as it's all quite optional and can be done incrementally:
    
    * Some of the fortified string functions (strncpy, strcat), don't yet
      place a limit on reads from the source based on __builtin_object_size of
      the source buffer.
    
    * Extending coverage to more string functions like strlcat.
    
    * It should be possible to optionally use __builtin_object_size(x, 1) for
      some functions (C strings) to detect intra-object overflows (like
      glibc's _FORTIFY_SOURCE=2), but for now this takes the conservative
      approach to avoid likely compatibility issues.
    
    * The compile-time checks should be made available via a separate config
      option which can be enabled by default (or always enabled) once enough
      time has passed to get the issues it catches fixed.
    
    Kees said:
     "This is great to have. While it was out-of-tree code, it would have
      blocked at least CVE-2016-3858 from being exploitable (improper size
      argument to strlcpy()). I've sent a number of fixes for
      out-of-bounds-reads that this detected upstream already"
    
    [arnd@arndb.de: x86: fix fortified memcpy]
      Link: http://lkml.kernel.org/r/20170627150047.660360-1-arnd@arndb.de
    [keescook@chromium.org: avoid panic() in favor of BUG()]
      Link: http://lkml.kernel.org/r/20170626235122.GA25261@beast
    [keescook@chromium.org: move from -mm, add ARCH_HAS_FORTIFY_SOURCE, tweak Kconfig help]
    Link: http://lkml.kernel.org/r/20170526095404.20439-1-danielmicay@gmail.com
    Link: http://lkml.kernel.org/r/1497903987-21002-8-git-send-email-keescook@chromium.org
    Signed-off-by: Daniel Micay <danielmicay@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Daniel Axtens <dja@axtens.net>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Chris Metcalf <cmetcalf@ezchip.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 7439d83eaa33..96f5a5fd0377 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -193,4 +193,204 @@ static inline const char *kbasename(const char *path)
 	return tail ? tail + 1 : path;
 }
 
+#define __FORTIFY_INLINE extern __always_inline __attribute__((gnu_inline))
+#define __RENAME(x) __asm__(#x)
+
+void fortify_panic(const char *name) __noreturn __cold;
+void __read_overflow(void) __compiletime_error("detected read beyond size of object passed as 1st parameter");
+void __read_overflow2(void) __compiletime_error("detected read beyond size of object passed as 2nd parameter");
+void __write_overflow(void) __compiletime_error("detected write beyond size of object passed as 1st parameter");
+
+#if !defined(__NO_FORTIFY) && defined(__OPTIMIZE__) && defined(CONFIG_FORTIFY_SOURCE)
+__FORTIFY_INLINE char *strcpy(char *p, const char *q)
+{
+	size_t p_size = __builtin_object_size(p, 0);
+	size_t q_size = __builtin_object_size(q, 0);
+	if (p_size == (size_t)-1 && q_size == (size_t)-1)
+		return __builtin_strcpy(p, q);
+	if (strscpy(p, q, p_size < q_size ? p_size : q_size) < 0)
+		fortify_panic(__func__);
+	return p;
+}
+
+__FORTIFY_INLINE char *strncpy(char *p, const char *q, __kernel_size_t size)
+{
+	size_t p_size = __builtin_object_size(p, 0);
+	if (__builtin_constant_p(size) && p_size < size)
+		__write_overflow();
+	if (p_size < size)
+		fortify_panic(__func__);
+	return __builtin_strncpy(p, q, size);
+}
+
+__FORTIFY_INLINE char *strcat(char *p, const char *q)
+{
+	size_t p_size = __builtin_object_size(p, 0);
+	if (p_size == (size_t)-1)
+		return __builtin_strcat(p, q);
+	if (strlcat(p, q, p_size) >= p_size)
+		fortify_panic(__func__);
+	return p;
+}
+
+__FORTIFY_INLINE __kernel_size_t strlen(const char *p)
+{
+	__kernel_size_t ret;
+	size_t p_size = __builtin_object_size(p, 0);
+	if (p_size == (size_t)-1)
+		return __builtin_strlen(p);
+	ret = strnlen(p, p_size);
+	if (p_size <= ret)
+		fortify_panic(__func__);
+	return ret;
+}
+
+extern __kernel_size_t __real_strnlen(const char *, __kernel_size_t) __RENAME(strnlen);
+__FORTIFY_INLINE __kernel_size_t strnlen(const char *p, __kernel_size_t maxlen)
+{
+	size_t p_size = __builtin_object_size(p, 0);
+	__kernel_size_t ret = __real_strnlen(p, maxlen < p_size ? maxlen : p_size);
+	if (p_size <= ret && maxlen != ret)
+		fortify_panic(__func__);
+	return ret;
+}
+
+/* defined after fortified strlen to reuse it */
+extern size_t __real_strlcpy(char *, const char *, size_t) __RENAME(strlcpy);
+__FORTIFY_INLINE size_t strlcpy(char *p, const char *q, size_t size)
+{
+	size_t ret;
+	size_t p_size = __builtin_object_size(p, 0);
+	size_t q_size = __builtin_object_size(q, 0);
+	if (p_size == (size_t)-1 && q_size == (size_t)-1)
+		return __real_strlcpy(p, q, size);
+	ret = strlen(q);
+	if (size) {
+		size_t len = (ret >= size) ? size - 1 : ret;
+		if (__builtin_constant_p(len) && len >= p_size)
+			__write_overflow();
+		if (len >= p_size)
+			fortify_panic(__func__);
+		__builtin_memcpy(p, q, len);
+		p[len] = '\0';
+	}
+	return ret;
+}
+
+/* defined after fortified strlen and strnlen to reuse them */
+__FORTIFY_INLINE char *strncat(char *p, const char *q, __kernel_size_t count)
+{
+	size_t p_len, copy_len;
+	size_t p_size = __builtin_object_size(p, 0);
+	size_t q_size = __builtin_object_size(q, 0);
+	if (p_size == (size_t)-1 && q_size == (size_t)-1)
+		return __builtin_strncat(p, q, count);
+	p_len = strlen(p);
+	copy_len = strnlen(q, count);
+	if (p_size < p_len + copy_len + 1)
+		fortify_panic(__func__);
+	__builtin_memcpy(p + p_len, q, copy_len);
+	p[p_len + copy_len] = '\0';
+	return p;
+}
+
+__FORTIFY_INLINE void *memset(void *p, int c, __kernel_size_t size)
+{
+	size_t p_size = __builtin_object_size(p, 0);
+	if (__builtin_constant_p(size) && p_size < size)
+		__write_overflow();
+	if (p_size < size)
+		fortify_panic(__func__);
+	return __builtin_memset(p, c, size);
+}
+
+__FORTIFY_INLINE void *memcpy(void *p, const void *q, __kernel_size_t size)
+{
+	size_t p_size = __builtin_object_size(p, 0);
+	size_t q_size = __builtin_object_size(q, 0);
+	if (__builtin_constant_p(size)) {
+		if (p_size < size)
+			__write_overflow();
+		if (q_size < size)
+			__read_overflow2();
+	}
+	if (p_size < size || q_size < size)
+		fortify_panic(__func__);
+	return __builtin_memcpy(p, q, size);
+}
+
+__FORTIFY_INLINE void *memmove(void *p, const void *q, __kernel_size_t size)
+{
+	size_t p_size = __builtin_object_size(p, 0);
+	size_t q_size = __builtin_object_size(q, 0);
+	if (__builtin_constant_p(size)) {
+		if (p_size < size)
+			__write_overflow();
+		if (q_size < size)
+			__read_overflow2();
+	}
+	if (p_size < size || q_size < size)
+		fortify_panic(__func__);
+	return __builtin_memmove(p, q, size);
+}
+
+extern void *__real_memscan(void *, int, __kernel_size_t) __RENAME(memscan);
+__FORTIFY_INLINE void *memscan(void *p, int c, __kernel_size_t size)
+{
+	size_t p_size = __builtin_object_size(p, 0);
+	if (__builtin_constant_p(size) && p_size < size)
+		__read_overflow();
+	if (p_size < size)
+		fortify_panic(__func__);
+	return __real_memscan(p, c, size);
+}
+
+__FORTIFY_INLINE int memcmp(const void *p, const void *q, __kernel_size_t size)
+{
+	size_t p_size = __builtin_object_size(p, 0);
+	size_t q_size = __builtin_object_size(q, 0);
+	if (__builtin_constant_p(size)) {
+		if (p_size < size)
+			__read_overflow();
+		if (q_size < size)
+			__read_overflow2();
+	}
+	if (p_size < size || q_size < size)
+		fortify_panic(__func__);
+	return __builtin_memcmp(p, q, size);
+}
+
+__FORTIFY_INLINE void *memchr(const void *p, int c, __kernel_size_t size)
+{
+	size_t p_size = __builtin_object_size(p, 0);
+	if (__builtin_constant_p(size) && p_size < size)
+		__read_overflow();
+	if (p_size < size)
+		fortify_panic(__func__);
+	return __builtin_memchr(p, c, size);
+}
+
+void *__real_memchr_inv(const void *s, int c, size_t n) __RENAME(memchr_inv);
+__FORTIFY_INLINE void *memchr_inv(const void *p, int c, size_t size)
+{
+	size_t p_size = __builtin_object_size(p, 0);
+	if (__builtin_constant_p(size) && p_size < size)
+		__read_overflow();
+	if (p_size < size)
+		fortify_panic(__func__);
+	return __real_memchr_inv(p, c, size);
+}
+
+extern void *__real_kmemdup(const void *src, size_t len, gfp_t gfp) __RENAME(kmemdup);
+__FORTIFY_INLINE void *kmemdup(const void *p, size_t size, gfp_t gfp)
+{
+	size_t p_size = __builtin_object_size(p, 0);
+	if (__builtin_constant_p(size) && p_size < size)
+		__read_overflow();
+	if (p_size < size)
+		fortify_panic(__func__);
+	return __real_kmemdup(p, size, gfp);
+}
+#endif
+
 #endif /* _LINUX_STRING_H_ */

commit f35157417215ec138c920320c746fdb3e04ef1d5
Author: David Howells <dhowells@redhat.com>
Date:   Tue Jul 4 17:25:02 2017 +0100

    Provide a function to create a NUL-terminated string from unterminated data
    
    Provide a function, kmemdup_nul(), that will create a NUL-terminated string
    from an unterminated character array where the length is known in advance.
    
    This is better than kstrndup() in situations where we already know the
    string length as the strnlen() in kstrndup() is superfluous.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/string.h b/include/linux/string.h
index 537918f8a98e..3dd944cfe171 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -131,6 +131,7 @@ extern char *kstrdup(const char *s, gfp_t gfp) __malloc;
 extern const char *kstrdup_const(const char *s, gfp_t gfp);
 extern char *kstrndup(const char *s, size_t len, gfp_t gfp);
 extern void *kmemdup(const void *src, size_t len, gfp_t gfp);
+extern char *kmemdup_nul(const char *s, size_t len, gfp_t gfp);
 
 extern char **argv_split(gfp_t gfp, const char *str, int *argcp);
 extern void argv_free(char **argv);

commit 0aed55af88345b5d673240f90e671d79662fb01e
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon May 29 12:22:50 2017 -0700

    x86, uaccess: introduce copy_from_iter_flushcache for pmem / cache-bypass operations
    
    The pmem driver has a need to transfer data with a persistent memory
    destination and be able to rely on the fact that the destination writes are not
    cached. It is sufficient for the writes to be flushed to a cpu-store-buffer
    (non-temporal / "movnt" in x86 terms), as we expect userspace to call fsync()
    to ensure data-writes have reached a power-fail-safe zone in the platform. The
    fsync() triggers a REQ_FUA or REQ_FLUSH to the pmem driver which will turn
    around and fence previous writes with an "sfence".
    
    Implement a __copy_from_user_inatomic_flushcache, memcpy_page_flushcache, and
    memcpy_flushcache, that guarantee that the destination buffer is not dirty in
    the cpu cache on completion. The new copy_from_iter_flushcache and sub-routines
    will be used to replace the "pmem api" (include/linux/pmem.h +
    arch/x86/include/asm/pmem.h). The availability of copy_from_iter_flushcache()
    and memcpy_flushcache() are gated by the CONFIG_ARCH_HAS_UACCESS_FLUSHCACHE
    config symbol, and fallback to copy_from_iter_nocache() and plain memcpy()
    otherwise.
    
    This is meant to satisfy the concern from Linus that if a driver wants to do
    something beyond the normal nocache semantics it should be something private to
    that driver [1], and Al's concern that anything uaccess related belongs with
    the rest of the uaccess code [2].
    
    The first consumer of this interface is a new 'copy_from_iter' dax operation so
    that pmem can inject cache maintenance operations without imposing this
    overhead on other dax-capable drivers.
    
    [1]: https://lists.01.org/pipermail/linux-nvdimm/2017-January/008364.html
    [2]: https://lists.01.org/pipermail/linux-nvdimm/2017-April/009942.html
    
    Cc: <x86@kernel.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jeff Moyer <jmoyer@redhat.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Toshi Kani <toshi.kani@hpe.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Matthew Wilcox <mawilcox@microsoft.com>
    Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/linux/string.h b/include/linux/string.h
index 537918f8a98e..7439d83eaa33 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -122,6 +122,12 @@ static inline __must_check int memcpy_mcsafe(void *dst, const void *src,
 	return 0;
 }
 #endif
+#ifndef __HAVE_ARCH_MEMCPY_FLUSHCACHE
+static inline void memcpy_flushcache(void *dst, const void *src, size_t cnt)
+{
+	memcpy(dst, src, cnt);
+}
+#endif
 void *memchr_inv(const void *s, int c, size_t n);
 char *strreplace(char *s, char old, char new);
 

commit 53ef7d0e208fa38c3f63d287e0c3ab174f1e1235
Merge: c6a677c6f37b 736163671bcb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 5 18:49:20 2017 -0700

    Merge tag 'libnvdimm-for-4.12' of git://git.kernel.org/pub/scm/linux/kernel/git/nvdimm/nvdimm
    
    Pull libnvdimm updates from Dan Williams:
     "The bulk of this has been in multiple -next releases. There were a few
      late breaking fixes and small features that got added in the last
      couple days, but the whole set has received a build success
      notification from the kbuild robot.
    
      Change summary:
    
       - Region media error reporting: A libnvdimm region device is the
         parent to one or more namespaces. To date, media errors have been
         reported via the "badblocks" attribute attached to pmem block
         devices for namespaces in "raw" or "memory" mode. Given that
         namespaces can be in "device-dax" or "btt-sector" mode this new
         interface reports media errors generically, i.e. independent of
         namespace modes or state.
    
         This subsequently allows userspace tooling to craft "ACPI 6.1
         Section 9.20.7.6 Function Index 4 - Clear Uncorrectable Error"
         requests and submit them via the ioctl path for NVDIMM root bus
         devices.
    
       - Introduce 'struct dax_device' and 'struct dax_operations': Prompted
         by a request from Linus and feedback from Christoph this allows for
         dax capable drivers to publish their own custom dax operations.
         This fixes the broken assumption that all dax operations are
         related to a persistent memory device, and makes it easier for
         other architectures and platforms to add customized persistent
         memory support.
    
       - 'libnvdimm' core updates: A new "deep_flush" sysfs attribute is
         available for storage appliance applications to manually trigger
         memory controllers to drain write-pending buffers that would
         otherwise be flushed automatically by the platform ADR
         (asynchronous-DRAM-refresh) mechanism at a power loss event.
         Support for "locked" DIMMs is included to prevent namespaces from
         surfacing when the namespace label data area is locked. Finally,
         fixes for various reported deadlocks and crashes, also tagged for
         -stable.
    
       - ACPI / nfit driver updates: General updates of the nfit driver to
         add DSM command overrides, ACPI 6.1 health state flags support, DSM
         payload debug available by default, and various fixes.
    
      Acknowledgements that came after the branch was pushed:
    
       - commmit 565851c972b5 "device-dax: fix sysfs attribute deadlock":
         Tested-by: Yi Zhang <yizhan@redhat.com>
    
       - commit 23f498448362 "libnvdimm: rework region badblocks clearing"
         Tested-by: Toshi Kani <toshi.kani@hpe.com>"
    
    * tag 'libnvdimm-for-4.12' of git://git.kernel.org/pub/scm/linux/kernel/git/nvdimm/nvdimm: (52 commits)
      libnvdimm, pfn: fix 'npfns' vs section alignment
      libnvdimm: handle locked label storage areas
      libnvdimm: convert NDD_ flags to use bitops, introduce NDD_LOCKED
      brd: fix uninitialized use of brd->dax_dev
      block, dax: use correct format string in bdev_dax_supported
      device-dax: fix sysfs attribute deadlock
      libnvdimm: restore "libnvdimm: band aid btt vs clear poison locking"
      libnvdimm: fix nvdimm_bus_lock() vs device_lock() ordering
      libnvdimm: rework region badblocks clearing
      acpi, nfit: kill ACPI_NFIT_DEBUG
      libnvdimm: fix clear length of nvdimm_forget_poison()
      libnvdimm, pmem: fix a NULL pointer BUG in nd_pmem_notify
      libnvdimm, region: sysfs trigger for nvdimm_flush()
      libnvdimm: fix phys_addr for nvdimm_clear_poison
      x86, dax, pmem: remove indirection around memcpy_from_pmem()
      block: remove block_device_operations ->direct_access()
      block, dax: convert bdev_dax_supported() to dax_direct_access()
      filesystem-dax: convert to dax_direct_access()
      Revert "block: use DAX for partition table reads"
      ext2, ext4, xfs: retrieve dax_device for iomap operations
      ...

commit 6abccd1bfee49e491095772fd5aa9e96d915ae52
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jan 13 14:14:23 2017 -0800

    x86, dax, pmem: remove indirection around memcpy_from_pmem()
    
    memcpy_from_pmem() maps directly to memcpy_mcsafe(). The wrapper
    serves no real benefit aside from affording a more generic function name
    than the x86-specific 'mcsafe'. However this would not be the first time
    that x86 terminology leaked into the global namespace. For lack of
    better name, just use memcpy_mcsafe() directly.
    
    This conversion also catches a place where we should have been using
    plain memcpy, acpi_nfit_blk_single_io().
    
    Cc: <x86@kernel.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jeff Moyer <jmoyer@redhat.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Matthew Wilcox <mawilcox@microsoft.com>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Acked-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/linux/string.h b/include/linux/string.h
index 26b6f6a66f83..9d6f189157e2 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -114,6 +114,14 @@ extern int memcmp(const void *,const void *,__kernel_size_t);
 #ifndef __HAVE_ARCH_MEMCHR
 extern void * memchr(const void *,int,__kernel_size_t);
 #endif
+#ifndef __HAVE_ARCH_MEMCPY_MCSAFE
+static inline __must_check int memcpy_mcsafe(void *dst, const void *src,
+		size_t cnt)
+{
+	memcpy(dst, src, cnt);
+	return 0;
+}
+#endif
 void *memchr_inv(const void *s, int c, size_t n);
 char *strreplace(char *s, char old, char new);
 

commit e1fe7b6a7b376bfb54558725ddb2a89aaaa4adcc
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Tue Mar 21 13:56:46 2017 +0200

    lib/string: add sysfs_match_string helper
    
    Make a simple helper for matching strings with sysfs
    attribute files. In most parts the same as match_string(),
    except sysfs_match_string() uses sysfs_streq() instead of
    strcmp() for matching. This is more convenient when used
    with sysfs attributes.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 26b6f6a66f83..c4011b28f3d8 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -135,6 +135,16 @@ static inline int strtobool(const char *s, bool *res)
 }
 
 int match_string(const char * const *array, size_t n, const char *string);
+int __sysfs_match_string(const char * const *array, size_t n, const char *s);
+
+/**
+ * sysfs_match_string - matches given string in an array
+ * @_a: array of strings
+ * @_s: string to match with
+ *
+ * Helper for __sysfs_match_string(). Calculates the size of @a automatically.
+ */
+#define sysfs_match_string(_a, _s) __sysfs_match_string(_a, ARRAY_SIZE(_a), _s)
 
 #ifdef CONFIG_BINARY_PRINTF
 int vbin_printf(u32 *bin_buf, size_t size, const char *fmt, va_list args);

commit 48a270554a3251681ae11173f2fd6389d943e183
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Thu May 19 17:10:55 2016 -0700

    include/linux: apply __malloc attribute
    
    Attach the malloc attribute to a few allocation functions.  This helps
    gcc generate better code by telling it that the return value doesn't
    alias any existing pointers (which is even more valuable given the
    pessimizations implied by -fno-strict-aliasing).
    
    A simple example of what this allows gcc to do can be seen by looking at
    the last part of drm_atomic_helper_plane_reset:
    
            plane->state = kzalloc(sizeof(*plane->state), GFP_KERNEL);
    
            if (plane->state) {
                    plane->state->plane = plane;
                    plane->state->rotation = BIT(DRM_ROTATE_0);
            }
    
    which compiles to
    
        e8 99 bf d6 ff          callq  ffffffff8116d540 <kmem_cache_alloc_trace>
        48 85 c0                test   %rax,%rax
        48 89 83 40 02 00 00    mov    %rax,0x240(%rbx)
        74 11                   je     ffffffff814015c4 <drm_atomic_helper_plane_reset+0x64>
        48 89 18                mov    %rbx,(%rax)
        48 8b 83 40 02 00 00    mov    0x240(%rbx),%rax [*]
        c7 40 40 01 00 00 00    movl   $0x1,0x40(%rax)
    
    With this patch applied, the instruction at [*] is elided, since the
    store to plane->state->plane is known to not alter the value of
    plane->state.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Christoph Lameter <cl@linux.com>
    Cc: Pekka Enberg <penberg@kernel.org>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index d3993a79a325..26b6f6a66f83 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -119,7 +119,7 @@ char *strreplace(char *s, char old, char new);
 
 extern void kfree_const(const void *x);
 
-extern char *kstrdup(const char *s, gfp_t gfp);
+extern char *kstrdup(const char *s, gfp_t gfp) __malloc;
 extern const char *kstrdup_const(const char *s, gfp_t gfp);
 extern char *kstrndup(const char *s, size_t len, gfp_t gfp);
 extern void *kmemdup(const void *src, size_t len, gfp_t gfp);

commit ef951599074ba4fad2d0efa0a977129b41e6d203
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Mar 17 14:22:50 2016 -0700

    lib: move strtobool() to kstrtobool()
    
    Create the kstrtobool_from_user() helper and move strtobool() logic into
    the new kstrtobool() (matching all the other kstrto* functions).
    Provides an inline wrapper for existing strtobool() callers.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: Amitkumar Karwar <akarwar@marvell.com>
    Cc: Nishant Sarmukadam <nishants@marvell.com>
    Cc: Kalle Valo <kvalo@codeaurora.org>
    Cc: Steve French <sfrench@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 0f235e80d355..d3993a79a325 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -128,7 +128,11 @@ extern char **argv_split(gfp_t gfp, const char *str, int *argcp);
 extern void argv_free(char **argv);
 
 extern bool sysfs_streq(const char *s1, const char *s2);
-extern int strtobool(const char *s, bool *res);
+extern int kstrtobool(const char *s, bool *res);
+static inline int strtobool(const char *s, bool *res)
+{
+	return kstrtobool(s, res);
+}
 
 int match_string(const char * const *array, size_t n, const char *string);
 

commit 56b060814e2d87d6646a85a2f4609c73587399ca
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Mar 17 14:22:14 2016 -0700

    lib/string: introduce match_string() helper
    
    Occasionally we have to search for an occurrence of a string in an array
    of strings.  Make a simple helper for that purpose.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Sebastian Reichel <sre@kernel.org>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 9eebc66d957a..0f235e80d355 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -130,6 +130,8 @@ extern void argv_free(char **argv);
 extern bool sysfs_streq(const char *s1, const char *s2);
 extern int strtobool(const char *s, bool *res);
 
+int match_string(const char * const *array, size_t n, const char *string);
+
 #ifdef CONFIG_BINARY_PRINTF
 int vbin_printf(u32 *bin_buf, size_t size, const char *fmt, va_list args);
 int bstr_printf(char *buf, size_t size, const char *fmt, const u32 *bin_buf);

commit e9d408e107db9a554b36c3a79f67b37dd3e16da0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 24 00:06:05 2015 -0500

    new helper: memdup_user_nul()
    
    Similar to memdup_user(), except that allocated buffer is one byte
    longer and '\0' is stored after the copied data.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/string.h b/include/linux/string.h
index 9ef7795e65e4..9eebc66d957a 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -10,6 +10,7 @@
 
 extern char *strndup_user(const char __user *, long);
 extern void *memdup_user(const void __user *, size_t);
+extern void *memdup_user_nul(const void __user *, size_t);
 
 /*
  * Include machine specific inline routines

commit 30035e45753b708e7d47a98398500ca005e02b86
Author: Chris Metcalf <cmetcalf@ezchip.com>
Date:   Wed Apr 29 12:52:04 2015 -0400

    string: provide strscpy()
    
    The strscpy() API is intended to be used instead of strlcpy(),
    and instead of most uses of strncpy().
    
    - Unlike strlcpy(), it doesn't read from memory beyond (src + size).
    
    - Unlike strlcpy() or strncpy(), the API provides an easy way to check
      for destination buffer overflow: an -E2BIG error return value.
    
    - The provided implementation is robust in the face of the source
      buffer being asynchronously changed during the copy, unlike the
      current implementation of strlcpy().
    
    - Unlike strncpy(), the destination buffer will be NUL-terminated
      if the string in the source buffer is too long.
    
    - Also unlike strncpy(), the destination buffer will not be updated
      beyond the NUL termination, avoiding strncpy's behavior of zeroing
      the entire tail end of the destination buffer.  (A memset() after
      the strscpy() can be used if this behavior is desired.)
    
    - The implementation should be reasonably performant on all
      platforms since it uses the asm/word-at-a-time.h API rather than
      simple byte copy.  Kernel-to-kernel string copy is not considered
      to be performance critical in any case.
    
    Signed-off-by: Chris Metcalf <cmetcalf@ezchip.com>

diff --git a/include/linux/string.h b/include/linux/string.h
index a8d90db9c4b0..9ef7795e65e4 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -25,6 +25,9 @@ extern char * strncpy(char *,const char *, __kernel_size_t);
 #ifndef __HAVE_ARCH_STRLCPY
 size_t strlcpy(char *, const char *, size_t);
 #endif
+#ifndef __HAVE_ARCH_STRSCPY
+ssize_t __must_check strscpy(char *, const char *, size_t);
+#endif
 #ifndef __HAVE_ARCH_STRCAT
 extern char * strcat(char *, const char *);
 #endif

commit 94df290404cd0da8016698bf3f398410f29d9a64
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Thu Jun 25 15:02:22 2015 -0700

    lib/string.c: introduce strreplace()
    
    Strings are sometimes sanitized by replacing a certain character (often
    '/') by another (often '!').  In a few places, this is done the same way
    Schlemiel the Painter would do it.  Others are slightly smarter but still
    do multiple strchr() calls.  Introduce strreplace() to do this using a
    single function call and a single pass over the string.
    
    One would expect the return value to be one of three things: void, s, or
    the number of replacements made.  I chose the fourth, returning a pointer
    to the end of the string.  This is more likely to be useful (for example
    allowing the caller to avoid a strlen call).
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Joe Perches <joe@perches.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index e40099e585c9..a8d90db9c4b0 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -111,6 +111,7 @@ extern int memcmp(const void *,const void *,__kernel_size_t);
 extern void * memchr(const void *,int,__kernel_size_t);
 #endif
 void *memchr_inv(const void *s, int c, size_t n);
+char *strreplace(char *s, char old, char new);
 
 extern void kfree_const(const void *x);
 

commit a4bb1e43e22d3cade8f942fc6f95920248eb2fd0
Author: Andrzej Hajda <a.hajda@samsung.com>
Date:   Fri Feb 13 14:36:24 2015 -0800

    mm/util: add kstrdup_const
    
    kstrdup() is often used to duplicate strings where neither source neither
    destination will be ever modified.  In such case we can just reuse the
    source instead of duplicating it.  The problem is that we must be sure
    that the source is non-modifiable and its life-time is long enough.
    
    I suspect the good candidates for such strings are strings located in
    kernel .rodata section, they cannot be modifed because the section is
    read-only and their life-time is equal to kernel life-time.
    
    This small patchset proposes alternative version of kstrdup -
    kstrdup_const, which returns source string if it is located in .rodata
    otherwise it fallbacks to kstrdup.  To verify if the source is in
    .rodata function checks if the address is between sentinels
    __start_rodata, __end_rodata.  I guess it should work with all
    architectures.
    
    The main patch is accompanied by four patches constifying kstrdup for
    cases where situtation described above happens frequently.
    
    I have tested the patchset on mobile platform (exynos4210-trats) and it
    saves 3272 string allocations.  Since minimal allocation is 32 or 64
    bytes depending on Kconfig options the patchset saves respectively about
    100KB or 200KB of memory.
    
    Stats from tested platform show that the main offender is sysfs:
    
    By caller:
      2260 __kernfs_new_node
        631 clk_register+0xc8/0x1b8
        318 clk_register+0x34/0x1b8
          51 kmem_cache_create
          12 alloc_vfsmnt
    
    By string (with count >= 5):
        883 power
        876 subsystem
        135 parameters
        132 device
         61 iommu_group
        ...
    
    This patch (of 5):
    
    Add an alternative version of kstrdup which returns pointer to constant
    char array.  The function checks if input string is in persistent and
    read-only memory section, if yes it returns the input string, otherwise it
    fallbacks to kstrdup.
    
    kstrdup_const is accompanied by kfree_const performing conditional memory
    deallocation of the string.
    
    Signed-off-by: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Mike Turquette <mturquette@linaro.org>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Lameter <cl@linux.com>
    Cc: Pekka Enberg <penberg@kernel.org>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Greg KH <greg@kroah.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index b9bc9a5d9e21..e40099e585c9 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -112,7 +112,10 @@ extern void * memchr(const void *,int,__kernel_size_t);
 #endif
 void *memchr_inv(const void *s, int c, size_t n);
 
+extern void kfree_const(const void *x);
+
 extern char *kstrdup(const char *s, gfp_t gfp);
+extern const char *kstrdup_const(const char *s, gfp_t gfp);
 extern char *kstrndup(const char *s, size_t len, gfp_t gfp);
 extern void *kmemdup(const void *src, size_t len, gfp_t gfp);
 

commit af3cd13501eb04ca61d017ff4406f1cbffafdc04
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Thu Feb 12 15:02:15 2015 -0800

    lib/string.c: remove strnicmp()
    
    Now that all in-tree users of strnicmp have been converted to
    strncasecmp, the wrapper can be removed.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 2e22a2e58f3a..b9bc9a5d9e21 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -40,9 +40,6 @@ extern int strcmp(const char *,const char *);
 #ifndef __HAVE_ARCH_STRNCMP
 extern int strncmp(const char *,const char *,__kernel_size_t);
 #endif
-#ifndef __HAVE_ARCH_STRNICMP
-#define strnicmp strncasecmp
-#endif
 #ifndef __HAVE_ARCH_STRCASECMP
 extern int strcasecmp(const char *s1, const char *s2);
 #endif

commit 14d4cc08832efb724e58944ba2ac22e2ca3143dc
Merge: 1c45d9a920e6 7185ad2672a7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 24 12:33:32 2014 -0700

    Merge tag 'random_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/random
    
    Pull /dev/random updates from Ted Ts'o:
     "This adds a memzero_explicit() call which is guaranteed not to be
      optimized away by GCC.  This is important when we are wiping
      cryptographically sensitive material"
    
    * tag 'random_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/random:
      crypto: memzero_explicit - make sure to clear out sensitive data
      random: add and use memzero_explicit() for clearing data

commit d4c5efdb97773f59a2b711754ca0953f24516739
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Tue Aug 26 23:16:35 2014 -0400

    random: add and use memzero_explicit() for clearing data
    
    zatimend has reported that in his environment (3.16/gcc4.8.3/corei7)
    memset() calls which clear out sensitive data in extract_{buf,entropy,
    entropy_user}() in random driver are being optimized away by gcc.
    
    Add a helper memzero_explicit() (similarly as explicit_bzero() variants)
    that can be used in such cases where a variable with sensitive data is
    being cleared out in the end. Other use cases might also be in crypto
    code. [ I have put this into lib/string.c though, as it's always built-in
    and doesn't need any dependencies then. ]
    
    Fixes kernel bugzilla: 82041
    
    Reported-by: zatimend@hotmail.co.uk
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Cc: stable@vger.kernel.org

diff --git a/include/linux/string.h b/include/linux/string.h
index d36977e029af..3b42b3732da6 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -132,7 +132,7 @@ int bprintf(u32 *bin_buf, size_t size, const char *fmt, ...) __printf(3, 4);
 #endif
 
 extern ssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,
-			const void *from, size_t available);
+				       const void *from, size_t available);
 
 /**
  * strstarts - does @str start with @prefix?
@@ -144,7 +144,8 @@ static inline bool strstarts(const char *str, const char *prefix)
 	return strncmp(str, prefix, strlen(prefix)) == 0;
 }
 
-extern size_t memweight(const void *ptr, size_t bytes);
+size_t memweight(const void *ptr, size_t bytes);
+void memzero_explicit(void *s, size_t count);
 
 /**
  * kbasename - return the last part of a pathname.

commit b0bfb63118612e3614cf77b115c00f895a42c96a
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Mon Oct 13 15:54:27 2014 -0700

    lib: string: Make all calls to strnicmp into calls to strncasecmp
    
    The previous patch made strnicmp into a wrapper for strncasecmp.
    
    This patch makes all in-tree users of strnicmp call strncasecmp
    directly, while still making sure that the strnicmp symbol can be used
    by out-of-tree modules.  It should be considered a temporary hack until
    all in-tree callers have been converted.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index d36977e029af..e6edfe51575a 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -41,7 +41,7 @@ extern int strcmp(const char *,const char *);
 extern int strncmp(const char *,const char *,__kernel_size_t);
 #endif
 #ifndef __HAVE_ARCH_STRNICMP
-extern int strnicmp(const char *, const char *, __kernel_size_t);
+#define strnicmp strncasecmp
 #endif
 #ifndef __HAVE_ARCH_STRCASECMP
 extern int strcasecmp(const char *s1, const char *s2);

commit 11d200e95f3e84c1102e4cc9863a3614fd41f3ad
Author: Grant Likely <grant.likely@linaro.org>
Date:   Fri Mar 14 17:00:14 2014 +0000

    lib: add glibc style strchrnul() variant
    
    The strchrnul() variant helpfully returns a the end of the string
    instead of a NULL if the requested character is not found. This can
    simplify string parsing code since it doesn't need to expicitly check
    for a NULL return. If a valid string pointer is passed in, then a valid
    null terminated string will always come back out.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index ac889c5ea11b..d36977e029af 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -52,6 +52,9 @@ extern int strncasecmp(const char *s1, const char *s2, size_t n);
 #ifndef __HAVE_ARCH_STRCHR
 extern char * strchr(const char *,int);
 #endif
+#ifndef __HAVE_ARCH_STRCHRNUL
+extern char * strchrnul(const char *,int);
+#endif
 #ifndef __HAVE_ARCH_STRNCHR
 extern char * strnchr(const char *, size_t, int);
 #endif

commit b18888ab256f05626193be955a7a03f01d676f8c
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Dec 17 16:01:18 2012 -0800

    string: introduce helper to get base file name from given path
    
    There are several places in the kernel that use functionality like
    basename(3) with the exception: in case of '/foo/bar/' we expect to get an
    empty string.  Let's do it common helper for them.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Jason Baron <jbaron@redhat.com>
    Cc: YAMANE Toshiaki <yamanetoshi@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 630125818ca8..ac889c5ea11b 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -143,4 +143,15 @@ static inline bool strstarts(const char *str, const char *prefix)
 
 extern size_t memweight(const void *ptr, size_t bytes);
 
+/**
+ * kbasename - return the last part of a pathname.
+ *
+ * @path: path to extract the filename from.
+ */
+static inline const char *kbasename(const char *path)
+{
+	const char *tail = strrchr(path, '/');
+	return tail ? tail + 1 : path;
+}
+
 #endif /* _LINUX_STRING_H_ */

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/string.h b/include/linux/string.h
index b9178812d9df..630125818ca8 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -1,16 +1,12 @@
 #ifndef _LINUX_STRING_H_
 #define _LINUX_STRING_H_
 
-/* We don't want strings.h stuff being used by user stuff by accident */
-
-#ifndef __KERNEL__
-#include <string.h>
-#else
 
 #include <linux/compiler.h>	/* for inline */
 #include <linux/types.h>	/* for size_t */
 #include <linux/stddef.h>	/* for NULL */
 #include <stdarg.h>
+#include <uapi/linux/string.h>
 
 extern char *strndup_user(const char __user *, long);
 extern void *memdup_user(const void __user *, size_t);
@@ -147,5 +143,4 @@ static inline bool strstarts(const char *str, const char *prefix)
 
 extern size_t memweight(const void *ptr, size_t bytes);
 
-#endif /* __KERNEL__ */
 #endif /* _LINUX_STRING_H_ */

commit c3a5ce0416b6c172a23bc8a3760d8704d3d1535b
Author: WANG Cong <xiyou.wangcong@gmail.com>
Date:   Tue Aug 21 16:16:00 2012 -0700

    string: do not export memweight() to userspace
    
    Fix the following warning:
    
      usr/include/linux/string.h:8: userspace cannot reference function or variable defined in the kernel
    
    Signed-off-by: WANG Cong <xiyou.wangcong@gmail.com>
    Acked-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index ffe0442e18d2..b9178812d9df 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -144,8 +144,8 @@ static inline bool strstarts(const char *str, const char *prefix)
 {
 	return strncmp(str, prefix, strlen(prefix)) == 0;
 }
-#endif
 
 extern size_t memweight(const void *ptr, size_t bytes);
 
+#endif /* __KERNEL__ */
 #endif /* _LINUX_STRING_H_ */

commit 639b9e34f15e4b2c30068a4e4485586af0cdf709
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Mon Jul 30 14:40:55 2012 -0700

    string: introduce memweight()
    
    memweight() is the function that counts the total number of bits set in
    memory area.  Unlike bitmap_weight(), memweight() takes pointer and size
    in bytes to specify a memory area which does not need to be aligned to
    long-word boundary.
    
    [akpm@linux-foundation.org: rename `w' to `ret']
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Cc: Anders Larsen <al@alarsen.net>
    Cc: Alasdair Kergon <agk@redhat.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Andreas Dilger <adilger.kernel@dilger.ca>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: Tony Luck <tony.luck@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index e033564f10ba..ffe0442e18d2 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -145,4 +145,7 @@ static inline bool strstarts(const char *str, const char *prefix)
 	return strncmp(str, prefix, strlen(prefix)) == 0;
 }
 #endif
+
+extern size_t memweight(const void *ptr, size_t bytes);
+
 #endif /* _LINUX_STRING_H_ */

commit 798248206b59acc6e1238c778281419c041891a7
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Mon Oct 31 17:08:07 2011 -0700

    lib/string.c: introduce memchr_inv()
    
    memchr_inv() is mainly used to check whether the whole buffer is filled
    with just a specified byte.
    
    The function name and prototype are stolen from logfs and the
    implementation is from SLUB.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Acked-by: Christoph Lameter <cl@linux-foundation.org>
    Acked-by: Pekka Enberg <penberg@kernel.org>
    Cc: Matt Mackall <mpm@selenic.com>
    Acked-by: Joern Engel <joern@logfs.org>
    Cc: Marcin Slusarz <marcin.slusarz@gmail.com>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index a176db2f2c85..e033564f10ba 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -114,6 +114,7 @@ extern int memcmp(const void *,const void *,__kernel_size_t);
 #ifndef __HAVE_ARCH_MEMCHR
 extern void * memchr(const void *,int,__kernel_size_t);
 #endif
+void *memchr_inv(const void *s, int c, size_t n);
 
 extern char *kstrdup(const char *s, gfp_t gfp);
 extern char *kstrndup(const char *s, size_t len, gfp_t gfp);

commit d0f1fed29e6e73d9d17f4c91a5896a4ce3938d45
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Tue Apr 19 12:43:45 2011 +0100

    Add a strtobool function matching semantics of existing in kernel equivalents
    
    This is a rename of the usr_strtobool proposal, which was a renamed,
    relocated and fixed version of previous kstrtobool RFC
    
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/include/linux/string.h b/include/linux/string.h
index a716ee2a8adb..a176db2f2c85 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -123,6 +123,7 @@ extern char **argv_split(gfp_t gfp, const char *str, int *argcp);
 extern void argv_free(char **argv);
 
 extern bool sysfs_streq(const char *s1, const char *s2);
+extern int strtobool(const char *s, bool *res);
 
 #ifdef CONFIG_BINARY_PRINTF
 int vbin_printf(u32 *bin_buf, size_t size, const char *fmt, va_list args);

commit d5f1fb53353edc38da326445267c1df0c9676df2
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Thu Jan 14 10:53:55 2010 +0800

    lib: Introduce strnstr()
    
    It differs strstr() in that it limits the length to be searched
    in the first string.
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    LKML-Reference: <4B4E8743.6030805@cn.fujitsu.com>
    Acked-by: Frederic Weisbecker <fweisbec@gmail.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 651839a2a755..a716ee2a8adb 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -72,7 +72,10 @@ static inline __must_check char *strstrip(char *str)
 }
 
 #ifndef __HAVE_ARCH_STRSTR
-extern char * strstr(const char *,const char *);
+extern char * strstr(const char *, const char *);
+#endif
+#ifndef __HAVE_ARCH_STRNSTR
+extern char * strnstr(const char *, const char *, size_t);
 #endif
 #ifndef __HAVE_ARCH_STRLEN
 extern __kernel_size_t strlen(const char *);

commit ca54cb8c9eb38095dc420b73c6380ce1dbeb10fa
Author: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
Date:   Mon Dec 14 18:01:15 2009 -0800

    Subject: Re: [PATCH] strstrip incorrectly marked __must_check
    
    Recently, We marked strstrip() as must_check.  because it was frequently
    misused and it should be checked.  However, we found one exception.
    scsi/ipr.c intentionally ignore return value of strstrip.  Because it
    wishes to keep the whitespace at the beginning.
    
    Thus we need to keep with and without checked whitespace trim function.
    This patch adds a new strim() and changes ipr.c to use it.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Suggested-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 168dad11ae03..651839a2a755 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -63,7 +63,14 @@ extern char * strnchr(const char *, size_t, int);
 extern char * strrchr(const char *,int);
 #endif
 extern char * __must_check skip_spaces(const char *);
-extern char * __must_check strstrip(char *);
+
+extern char *strim(char *);
+
+static inline __must_check char *strstrip(char *str)
+{
+	return strim(str);
+}
+
 #ifndef __HAVE_ARCH_STRSTR
 extern char * strstr(const char *,const char *);
 #endif

commit f653398c86a1c104f0992bd788dd4bb065449be4
Author: André Goddard Rosa <andre.goddard@gmail.com>
Date:   Mon Dec 14 18:01:04 2009 -0800

    string: factorize skip_spaces and export it to be generally available
    
    On the following sentence:
        while (*s && isspace(*s))
            s++;
    
    If *s == 0, isspace() evaluates to ((_ctype[*s] & 0x20) != 0), which
    evaluates to ((0x08 & 0x20) != 0) which equals to 0 as well.
    If *s == 1, we depend on isspace() result anyway. In other words,
    "a char equals zero is never a space", so remove this check.
    
    Also, *s != 0 is most common case (non-null string).
    
    Fixed const return as noticed by Jan Engelhardt and James Bottomley.
    Fixed unnecessary extra cast on strstrip() as noticed by Jan Engelhardt.
    
    Signed-off-by: André Goddard Rosa <andre.goddard@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index b8508868d5ad..168dad11ae03 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -62,6 +62,7 @@ extern char * strnchr(const char *, size_t, int);
 #ifndef __HAVE_ARCH_STRRCHR
 extern char * strrchr(const char *,int);
 #endif
+extern char * __must_check skip_spaces(const char *);
 extern char * __must_check strstrip(char *);
 #ifndef __HAVE_ARCH_STRSTR
 extern char * strstr(const char *,const char *);

commit 0a1b71b4008d332e57b5605a8228ea7aa96687e8
Author: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
Date:   Mon Oct 26 16:49:37 2009 -0700

    strstrip(): mark as as must_check
    
    strstrip() can return a modified value of its input argument, when
    removing elading whitesapce.  So it is surely bug for this function's
    return value to be ignored.  The caller is probably going to use the
    incorrect original pointer.
    
    So mark it __must_check to prevent this frm happening (as it has before).
    
    Signed-off-by: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 489019ef1694..b8508868d5ad 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -62,7 +62,7 @@ extern char * strnchr(const char *, size_t, int);
 #ifndef __HAVE_ARCH_STRRCHR
 extern char * strrchr(const char *,int);
 #endif
-extern char * strstrip(char *);
+extern char * __must_check strstrip(char *);
 #ifndef __HAVE_ARCH_STRSTR
 extern char * strstr(const char *,const char *);
 #endif

commit cab4e4c43f92582a2bfc026137b3d8a175bd0360
Merge: 5412b5399e09 49502677e110
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 5 10:30:21 2009 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux-2.6-module-and-param
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux-2.6-module-and-param:
      module: use strstarts()
      strstarts: helper function for !strncmp(str, prefix, strlen(prefix))
      arm: allow usage of string functions in linux/string.h
      module: don't use stop_machine on module load
      module: create a request_module_nowait()
      module: include other structures in module version check
      module: remove the SHF_ALLOC flag on the __versions section.
      module: clarify the force-loading taint message.
      module: Export symbols needed for Ksplice
      Ksplice: Add functions for walking kallsyms symbols
      module: remove module_text_address()
      module: __module_address
      module: Make find_symbol return a struct kernel_symbol
      kernel/module.c: fix an unused goto label
      param: fix charp parameters set via sysfs
    
    Fix trivial conflicts in kernel/extable.c manually.

commit e4c393fd551654179c46b65e4a70ea20d831c783
Merge: 0a053e8c71d6 38a6ed3ed8e1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 5 10:23:25 2009 -0700

    Merge branch 'printk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'printk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      printk: correct the behavior of printk_timed_ratelimit()
      vsprintf: unify the format decoding layer for its 3 users, cleanup
      fix regression from "vsprintf: unify the format decoding layer for its 3 users"
      vsprintf: fix bug in negative value printing
      vsprintf: unify the format decoding layer for its 3 users
      vsprintf: add binary printf
      printk: introduce printk_once()
    
    Fix trivial conflicts (printk_once vs log_buf_kexec_setup() added near
    each other) in include/linux/kernel.h.

commit 610a77e04a8d9fe8764dc484e2182fa251ce1cc2
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Tue Mar 31 15:23:16 2009 -0700

    memdup_user(): introduce
    
    I notice there are many places doing copy_from_user() which follows
    kmalloc():
    
            dst = kmalloc(len, GFP_KERNEL);
            if (!dst)
                    return -ENOMEM;
            if (copy_from_user(dst, src, len)) {
                    kfree(dst);
                    return -EFAULT
            }
    
    memdup_user() is a wrapper of the above code.  With this new function, we
    don't have to write 'len' twice, which can lead to typos/mistakes.  It
    also produces smaller code and kernel text.
    
    A quick grep shows 250+ places where memdup_user() *may* be used.  I'll
    prepare a patchset to do this conversion.
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Cc: Americo Wang <xiyou.wangcong@gmail.com>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index d18fc198aa2f..8852739f36df 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -12,6 +12,7 @@
 #include <linux/stddef.h>	/* for NULL */
 
 extern char *strndup_user(const char __user *, long);
+extern void *memdup_user(const void __user *, size_t);
 
 /*
  * Include machine specific inline routines

commit 66f92cf9d415e96a5bdd6c64de8dd8418595d2fc
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Tue Mar 31 13:05:36 2009 -0600

    strstarts: helper function for !strncmp(str, prefix, strlen(prefix))
    
    Impact: minor new API
    
    ksplice added a "starts_with" function, which seems like a common need.
    When people open-code it they seem to use fixed numbers rather than strlen,
    so it's quite a readability win (also, strncmp() almost always wants != 0
    on it).
    
    So here's strstarts().
    
    Cc: Anders Kaseorg <andersk@mit.edu>
    Cc: Jeff Arnold <jbarnold@mit.edu>
    Cc: Tim Abbott <tabbott@mit.edu>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/include/linux/string.h b/include/linux/string.h
index d18fc198aa2f..76ec218bb30f 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -114,5 +114,14 @@ extern bool sysfs_streq(const char *s1, const char *s2);
 extern ssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,
 			const void *from, size_t available);
 
+/**
+ * strstarts - does @str start with @prefix?
+ * @str: string to examine
+ * @prefix: prefix to look for.
+ */
+static inline bool strstarts(const char *str, const char *prefix)
+{
+	return strncmp(str, prefix, strlen(prefix)) == 0;
+}
 #endif
 #endif /* _LINUX_STRING_H_ */

commit 4370aa4aa75391a5e2e06bccb0919109f725ed8e
Author: Lai Jiangshan <laijs@cn.fujitsu.com>
Date:   Fri Mar 6 17:21:46 2009 +0100

    vsprintf: add binary printf
    
    Impact: add new APIs for binary trace printk infrastructure
    
    vbin_printf(): write args to binary buffer, string is copied
    when "%s" is occurred.
    
    bstr_printf(): read from binary buffer for args and format a string
    
    [fweisbec@gmail.com: rebase]
    
    Signed-off-by: Lai Jiangshan <laijs@cn.fujitsu.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    LKML-Reference: <1236356510-8381-2-git-send-email-fweisbec@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/string.h b/include/linux/string.h
index d18fc198aa2f..27ac31784ad2 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -10,6 +10,7 @@
 #include <linux/compiler.h>	/* for inline */
 #include <linux/types.h>	/* for size_t */
 #include <linux/stddef.h>	/* for NULL */
+#include <stdarg.h>
 
 extern char *strndup_user(const char __user *, long);
 
@@ -111,6 +112,12 @@ extern void argv_free(char **argv);
 
 extern bool sysfs_streq(const char *s1, const char *s2);
 
+#ifdef CONFIG_BINARY_PRINTF
+int vbin_printf(u32 *bin_buf, size_t size, const char *fmt, va_list args);
+int bstr_printf(char *buf, size_t size, const char *fmt, const u32 *bin_buf);
+int bprintf(u32 *bin_buf, size_t size, const char *fmt, ...) __printf(3, 4);
+#endif
+
 extern ssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,
 			const void *from, size_t available);
 

commit 4ac96572f1f6abe44b5e02e80fdfb5a990129613
Author: Jeff Garzik <jeff@garzik.org>
Date:   Sun Nov 2 09:51:27 2008 -0500

    linux/string.h: fix comment typo
    
    s/user/used/
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 810d80df0a1d..d18fc198aa2f 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -1,7 +1,7 @@
 #ifndef _LINUX_STRING_H_
 #define _LINUX_STRING_H_
 
-/* We don't want strings.h stuff being user by user stuff by accident */
+/* We don't want strings.h stuff being used by user stuff by accident */
 
 #ifndef __KERNEL__
 #include <string.h>

commit e108526e77aa41c89b3be96f75d97615db2b751c
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Wed Jul 23 21:26:44 2008 -0700

    move memory_read_from_buffer() from fs.h to string.h
    
    James Bottomley warns that inclusion of linux/fs.h in a low level
    driver was always a danger signal.  This patch moves
    memory_read_from_buffer() from fs.h to string.h and fixes includes in
    existing memory_read_from_buffer() users.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Cc: James Bottomley <James.Bottomley@hansenpartnership.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Cc: Bob Moore <robert.moore@intel.com>
    Cc: Thomas Renninger <trenn@suse.de>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index efdc44593b52..810d80df0a1d 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -111,5 +111,8 @@ extern void argv_free(char **argv);
 
 extern bool sysfs_streq(const char *s1, const char *s2);
 
+extern ssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,
+			const void *from, size_t available);
+
 #endif
 #endif /* _LINUX_STRING_H_ */

commit 34990cf702bdf2b4964e0629dab4af7669f8b2c5
Author: David Brownell <david-b@pacbell.net>
Date:   Thu May 1 04:34:42 2008 -0700

    Add a new sysfs_streq() string comparison function
    
    Add a new sysfs_streq() string comparison function, which ignores
    the trailing newlines found in sysfs inputs.  By example:
    
            sysfs_streq("a", "b")   ==> false
            sysfs_streq("a", "a")   ==> true
            sysfs_streq("a", "a\n") ==> true
            sysfs_streq("a\n", "a") ==> true
    
    This is intended to simplify parsing of sysfs inputs, letting them
    avoid the need to manually strip off newlines from inputs.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index c5d3fcad7b57..efdc44593b52 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -109,5 +109,7 @@ extern void *kmemdup(const void *src, size_t len, gfp_t gfp);
 extern char **argv_split(gfp_t gfp, const char *str, int *argcp);
 extern void argv_free(char **argv);
 
+extern bool sysfs_streq(const char *s1, const char *s2);
+
 #endif
 #endif /* _LINUX_STRING_H_ */

commit 97ef1bb0c8e371b7988287f38bd107c4aa14d78d
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Tue Oct 30 21:44:00 2007 -0700

    [TIPC]: Fix headercheck wrt. tipc_config.h
    
    It wants string functions like memcpy() for inline
    routines, and these define userland interfaces.
    
    The only clean way to deal with this is to simply
    put linux/string.h into unifdef-y and have it
    include <string.h> when not-__KERNEL__.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/string.h b/include/linux/string.h
index 836062b7582a..c5d3fcad7b57 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -3,16 +3,14 @@
 
 /* We don't want strings.h stuff being user by user stuff by accident */
 
-#ifdef __KERNEL__
+#ifndef __KERNEL__
+#include <string.h>
+#else
 
 #include <linux/compiler.h>	/* for inline */
 #include <linux/types.h>	/* for size_t */
 #include <linux/stddef.h>	/* for NULL */
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 extern char *strndup_user(const char __user *, long);
 
 /*
@@ -111,9 +109,5 @@ extern void *kmemdup(const void *src, size_t len, gfp_t gfp);
 extern char **argv_split(gfp_t gfp, const char *str, int *argcp);
 extern void argv_free(char **argv);
 
-#ifdef __cplusplus
-}
-#endif
-
 #endif
 #endif /* _LINUX_STRING_H_ */

commit d84d1cc7647c7e4f77d517e2d87b4a106a0420d9
Author: Jeremy Fitzhardinge <jeremy@xensource.com>
Date:   Tue Jul 17 18:37:02 2007 -0700

    add argv_split()
    
    argv_split() is a helper function which takes a string, splits it at
    whitespace, and returns a NULL-terminated argv vector.  This is
    deliberately simple - it does no quote processing of any kind.
    
    [ Seems to me that this is something which is already being done in
      the kernel, but I couldn't find any other implementations, either to
      steal or replace.  Keep an eye out. ]
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy@xensource.com>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>

diff --git a/include/linux/string.h b/include/linux/string.h
index ee5e9ccc4aae..836062b7582a 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -108,6 +108,9 @@ extern char *kstrdup(const char *s, gfp_t gfp);
 extern char *kstrndup(const char *s, size_t len, gfp_t gfp);
 extern void *kmemdup(const void *src, size_t len, gfp_t gfp);
 
+extern char **argv_split(gfp_t gfp, const char *str, int *argcp);
+extern void argv_free(char **argv);
+
 #ifdef __cplusplus
 }
 #endif

commit 1e66df3ee301209f4a38df097d7cc5cb9b367a3f
Author: Jeremy Fitzhardinge <jeremy@xensource.com>
Date:   Tue Jul 17 18:37:02 2007 -0700

    add kstrndup
    
    Add a kstrndup function, modelled on strndup.  Like strndup this
    returns a string copied into its own allocated memory, but it copies
    no more than the specified number of bytes from the source.
    
    Remove private strndup() from irda code.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy@xensource.com>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Cc: Akinobu Mita <akinobu.mita@gmail.com>
    Cc: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Cc: Al Viro <viro@ftp.linux.org.uk>
    Cc: Panagiotis Issaris <takis@issaris.org>
    Cc: Rene Scharfe <rene.scharfe@lsrfire.ath.cx>

diff --git a/include/linux/string.h b/include/linux/string.h
index 7f2eb6a477f9..ee5e9ccc4aae 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -105,6 +105,7 @@ extern void * memchr(const void *,int,__kernel_size_t);
 #endif
 
 extern char *kstrdup(const char *s, gfp_t gfp);
+extern char *kstrndup(const char *s, size_t len, gfp_t gfp);
 extern void *kmemdup(const void *src, size_t len, gfp_t gfp);
 
 #ifdef __cplusplus

commit ded220bd8f0823771fc0a9bdf7f5bcbe543197b6
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Thu Mar 29 01:18:42 2007 -0700

    [STRING]: Move strcasecmp/strncasecmp to lib/string.c
    
    We have several platforms using local copies of identical
    code.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/string.h b/include/linux/string.h
index 4f69ef9e6eb5..7f2eb6a477f9 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -47,6 +47,12 @@ extern int strncmp(const char *,const char *,__kernel_size_t);
 #ifndef __HAVE_ARCH_STRNICMP
 extern int strnicmp(const char *, const char *, __kernel_size_t);
 #endif
+#ifndef __HAVE_ARCH_STRCASECMP
+extern int strcasecmp(const char *s1, const char *s2);
+#endif
+#ifndef __HAVE_ARCH_STRNCASECMP
+extern int strncasecmp(const char *s1, const char *s2, size_t n);
+#endif
 #ifndef __HAVE_ARCH_STRCHR
 extern char * strchr(const char *,int);
 #endif

commit 1a2f67b459bb7846d4a15924face63eb2683acc2
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Sep 30 23:27:20 2006 -0700

    [PATCH] kmemdup: introduce
    
    One of idiomatic ways to duplicate a region of memory is
    
            dst = kmalloc(len, GFP_KERNEL);
            if (!dst)
                    return -ENOMEM;
            memcpy(dst, src, len);
    
    which is neat code except a programmer needs to write size twice.  Which
    sometimes leads to mistakes.  If len passed to kmalloc is smaller that len
    passed to memcpy, it's straight overwrite-beyond-end.  If len passed to
    memcpy is smaller than len passed to kmalloc, it's either a) legit
    behaviour ;-), or b) cloned buffer will contain garbage in second half.
    
    Slight trolling of commit lists shows several duplications bugs
    done exactly because of diverged lenghts:
    
            Linux:
                    [CRYPTO]: Fix memcpy/memset args.
                    [PATCH] memcpy/memset fixes
            OpenBSD:
                    kerberosV/src/lib/asn1: der_copy.c:1.4
    
    If programmer is given only one place to play with lengths, I believe, such
    mistakes could be avoided.
    
    With kmemdup, the snippet above will be rewritten as:
    
            dst = kmemdup(src, len, GFP_KERNEL);
            if (!dst)
                    return -ENOMEM;
    
    This also leads to smaller code (kzalloc effect). Quick grep shows
    200+ places where kmemdup() can be used.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index e4c755860316..4f69ef9e6eb5 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -99,6 +99,7 @@ extern void * memchr(const void *,int,__kernel_size_t);
 #endif
 
 extern char *kstrdup(const char *s, gfp_t gfp);
+extern void *kmemdup(const void *src, size_t len, gfp_t gfp);
 
 #ifdef __cplusplus
 }

commit 481fad483487ea967fe20bbc9e565d787f7bf20f
Author: Pekka Enberg <penberg@cs.helsinki.fi>
Date:   Fri Jun 23 02:05:44 2006 -0700

    [PATCH] strstrip() API
    
    Add a new strstrip() function to lib/string.c for removing leading and
    trailing whitespace from a string.
    
    Cc: Michael Holzheu <holzheu@de.ibm.com>
    Acked-by: Ingo Oeser <ioe-lkml@rameria.de>
    Acked-by: Joern Engel <joern@wohnheim.fh-wedel.de>
    Cc: Corey Minyard <minyard@acm.org>
    Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Acked-by: Michael Holzheu <HOLZHEU@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index c61306da8c52..e4c755860316 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -56,6 +56,7 @@ extern char * strnchr(const char *, size_t, int);
 #ifndef __HAVE_ARCH_STRRCHR
 extern char * strrchr(const char *,int);
 #endif
+extern char * strstrip(char *);
 #ifndef __HAVE_ARCH_STRSTR
 extern char * strstr(const char *,const char *);
 #endif

commit 8833d328caf009f8da58337e17a2cf5d52993a7c
Author: Kyle McMartin <kyle@parisc-linux.org>
Date:   Mon Apr 10 22:53:57 2006 -0700

    [PATCH] Clean up arch-overrides in linux/string.h
    
    Some string functions were safely overrideable in lib/string.c, but their
    corresponding declarations in linux/string.h were not.  Correct this, and
    make strcspn overrideable.
    
    Odds of someone wanting to do optimized assembly of these are small, but
    for the sake of cleanliness, might as well bring them into line with the
    rest of the file.
    
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index dee221429ad0..c61306da8c52 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -13,11 +13,6 @@
 extern "C" {
 #endif
 
-extern char * strpbrk(const char *,const char *);
-extern char * strsep(char **,const char *);
-extern __kernel_size_t strspn(const char *,const char *);
-extern __kernel_size_t strcspn(const char *,const char *);
-
 extern char *strndup_user(const char __user *, long);
 
 /*
@@ -70,6 +65,18 @@ extern __kernel_size_t strlen(const char *);
 #ifndef __HAVE_ARCH_STRNLEN
 extern __kernel_size_t strnlen(const char *,__kernel_size_t);
 #endif
+#ifndef __HAVE_ARCH_STRPBRK
+extern char * strpbrk(const char *,const char *);
+#endif
+#ifndef __HAVE_ARCH_STRSEP
+extern char * strsep(char **,const char *);
+#endif
+#ifndef __HAVE_ARCH_STRSPN
+extern __kernel_size_t strspn(const char *,const char *);
+#endif
+#ifndef __HAVE_ARCH_STRCSPN
+extern __kernel_size_t strcspn(const char *,const char *);
+#endif
 
 #ifndef __HAVE_ARCH_MEMSET
 extern void * memset(void *,int,__kernel_size_t);

commit 96840aa00a031069a136ec4c55d0bdd09ac6d3a7
Author: Davi Arnaut <davi.arnaut@gmail.com>
Date:   Fri Mar 24 03:18:42 2006 -0800

    [PATCH] strndup_user()
    
    This patch series creates a strndup_user() function to easy copying C strings
    from userspace.  Also we avoid common pitfalls like userspace modifying the
    final \0 after the strlen_user().
    
    Signed-off-by: Davi Arnaut <davi.arnaut@gmail.com>
    Cc: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 369be3264a55..dee221429ad0 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -18,6 +18,8 @@ extern char * strsep(char **,const char *);
 extern __kernel_size_t strspn(const char *,const char *);
 extern __kernel_size_t strcspn(const char *,const char *);
 
+extern char *strndup_user(const char __user *, long);
+
 /*
  * Include machine specific inline routines
  */

commit dd0fc66fb33cd610bc1a5db8a5e232d34879b4d7
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Fri Oct 7 07:46:04 2005 +0100

    [PATCH] gfp flags annotations - part 1
    
     - added typedef unsigned int __nocast gfp_t;
    
     - replaced __nocast uses for gfp flags with gfp_t - it gives exactly
       the same warnings as far as sparse is concerned, doesn't change
       generated code (from gcc point of view we replaced unsigned int with
       typedef) and documents what's going on far better.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index dab2652acbd8..369be3264a55 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -88,7 +88,7 @@ extern int memcmp(const void *,const void *,__kernel_size_t);
 extern void * memchr(const void *,int,__kernel_size_t);
 #endif
 
-extern char *kstrdup(const char *s, unsigned int __nocast gfp);
+extern char *kstrdup(const char *s, gfp_t gfp);
 
 #ifdef __cplusplus
 }

commit 0db925af1db5f3dfe1691c35b39496e2baaff9c9
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Thu Jul 7 17:56:58 2005 -0700

    [PATCH] propagate __nocast annotations
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index 93994c613095..dab2652acbd8 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -88,7 +88,7 @@ extern int memcmp(const void *,const void *,__kernel_size_t);
 extern void * memchr(const void *,int,__kernel_size_t);
 #endif
 
-extern char *kstrdup(const char *s, int gfp);
+extern char *kstrdup(const char *s, unsigned int __nocast gfp);
 
 #ifdef __cplusplus
 }

commit 543537bd922692bc978e2e356fcd8bfc9c2ee7d5
Author: Paulo Marques <pmarques@grupopie.com>
Date:   Thu Jun 23 00:09:02 2005 -0700

    [PATCH] create a kstrdup library function
    
    This patch creates a new kstrdup library function and changes the "local"
    implementations in several places to use this function.
    
    Most of the changes come from the sound and net subsystems.  The sound part
    had already been acknowledged by Takashi Iwai and the net part by David S.
    Miller.
    
    I left UML alone for now because I would need more time to read the code
    carefully before making changes there.
    
    Signed-off-by: Paulo Marques <pmarques@grupopie.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/string.h b/include/linux/string.h
index b9fc59469956..93994c613095 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -88,6 +88,8 @@ extern int memcmp(const void *,const void *,__kernel_size_t);
 extern void * memchr(const void *,int,__kernel_size_t);
 #endif
 
+extern char *kstrdup(const char *s, int gfp);
+
 #ifdef __cplusplus
 }
 #endif

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/string.h b/include/linux/string.h
new file mode 100644
index 000000000000..b9fc59469956
--- /dev/null
+++ b/include/linux/string.h
@@ -0,0 +1,96 @@
+#ifndef _LINUX_STRING_H_
+#define _LINUX_STRING_H_
+
+/* We don't want strings.h stuff being user by user stuff by accident */
+
+#ifdef __KERNEL__
+
+#include <linux/compiler.h>	/* for inline */
+#include <linux/types.h>	/* for size_t */
+#include <linux/stddef.h>	/* for NULL */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern char * strpbrk(const char *,const char *);
+extern char * strsep(char **,const char *);
+extern __kernel_size_t strspn(const char *,const char *);
+extern __kernel_size_t strcspn(const char *,const char *);
+
+/*
+ * Include machine specific inline routines
+ */
+#include <asm/string.h>
+
+#ifndef __HAVE_ARCH_STRCPY
+extern char * strcpy(char *,const char *);
+#endif
+#ifndef __HAVE_ARCH_STRNCPY
+extern char * strncpy(char *,const char *, __kernel_size_t);
+#endif
+#ifndef __HAVE_ARCH_STRLCPY
+size_t strlcpy(char *, const char *, size_t);
+#endif
+#ifndef __HAVE_ARCH_STRCAT
+extern char * strcat(char *, const char *);
+#endif
+#ifndef __HAVE_ARCH_STRNCAT
+extern char * strncat(char *, const char *, __kernel_size_t);
+#endif
+#ifndef __HAVE_ARCH_STRLCAT
+extern size_t strlcat(char *, const char *, __kernel_size_t);
+#endif
+#ifndef __HAVE_ARCH_STRCMP
+extern int strcmp(const char *,const char *);
+#endif
+#ifndef __HAVE_ARCH_STRNCMP
+extern int strncmp(const char *,const char *,__kernel_size_t);
+#endif
+#ifndef __HAVE_ARCH_STRNICMP
+extern int strnicmp(const char *, const char *, __kernel_size_t);
+#endif
+#ifndef __HAVE_ARCH_STRCHR
+extern char * strchr(const char *,int);
+#endif
+#ifndef __HAVE_ARCH_STRNCHR
+extern char * strnchr(const char *, size_t, int);
+#endif
+#ifndef __HAVE_ARCH_STRRCHR
+extern char * strrchr(const char *,int);
+#endif
+#ifndef __HAVE_ARCH_STRSTR
+extern char * strstr(const char *,const char *);
+#endif
+#ifndef __HAVE_ARCH_STRLEN
+extern __kernel_size_t strlen(const char *);
+#endif
+#ifndef __HAVE_ARCH_STRNLEN
+extern __kernel_size_t strnlen(const char *,__kernel_size_t);
+#endif
+
+#ifndef __HAVE_ARCH_MEMSET
+extern void * memset(void *,int,__kernel_size_t);
+#endif
+#ifndef __HAVE_ARCH_MEMCPY
+extern void * memcpy(void *,const void *,__kernel_size_t);
+#endif
+#ifndef __HAVE_ARCH_MEMMOVE
+extern void * memmove(void *,const void *,__kernel_size_t);
+#endif
+#ifndef __HAVE_ARCH_MEMSCAN
+extern void * memscan(void *,int,__kernel_size_t);
+#endif
+#ifndef __HAVE_ARCH_MEMCMP
+extern int memcmp(const void *,const void *,__kernel_size_t);
+#endif
+#ifndef __HAVE_ARCH_MEMCHR
+extern void * memchr(const void *,int,__kernel_size_t);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+#endif /* _LINUX_STRING_H_ */
