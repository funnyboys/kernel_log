commit 1d05334d2899bd3ecdf01beb53f0a70884a7f471
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Wed Apr 29 10:24:45 2020 -0500

    livepatch: Remove .klp.arch
    
    After the previous patch, vmlinux-specific KLP relocations are now
    applied early during KLP module load.  This means that .klp.arch
    sections are no longer needed for *vmlinux-specific* KLP relocations.
    
    One might think they're still needed for *module-specific* KLP
    relocations.  If a to-be-patched module is loaded *after* its
    corresponding KLP module is loaded, any corresponding KLP relocations
    will be delayed until the to-be-patched module is loaded.  If any
    special sections (.parainstructions, for example) rely on those
    relocations, their initializations (apply_paravirt) need to be done
    afterwards.  Thus the apparent need for arch_klp_init_object_loaded()
    and its corresponding .klp.arch sections -- it allows some of the
    special section initializations to be done at a later time.
    
    But... if you look closer, that dependency between the special sections
    and the module-specific KLP relocations doesn't actually exist in
    reality.  Looking at the contents of the .altinstructions and
    .parainstructions sections, there's not a realistic scenario in which a
    KLP module's .altinstructions or .parainstructions section needs to
    access a symbol in a to-be-patched module.  It might need to access a
    local symbol or even a vmlinux symbol; but not another module's symbol.
    When a special section needs to reference a local or vmlinux symbol, a
    normal rela can be used instead of a KLP rela.
    
    Since the special section initializations don't actually have any real
    dependency on module-specific KLP relocations, .klp.arch and
    arch_klp_init_object_loaded() no longer have a reason to exist.  So
    remove them.
    
    As Peter said much more succinctly:
    
      So the reason for .klp.arch was that .klp.rela.* stuff would overwrite
      paravirt instructions. If that happens you're doing it wrong. Those
      RELAs are core kernel, not module, and thus should've happened in
      .rela.* sections at patch-module loading time.
    
      Reverting this removes the two apply_{paravirt,alternatives}() calls
      from the late patching path, and means we don't have to worry about
      them when removing module_disable_ro().
    
    [ jpoimboe: Rewrote patch description.  Tweaked klp_init_object_loaded()
                error path. ]
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: Joe Lawrence <joe.lawrence@redhat.com>
    Acked-by: Miroslav Benes <mbenes@suse.cz>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index c4302e9a5905..2614247a9781 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -195,9 +195,6 @@ struct klp_patch {
 
 int klp_enable_patch(struct klp_patch *);
 
-void arch_klp_init_object_loaded(struct klp_patch *patch,
-				 struct klp_object *obj);
-
 /* Called from the module loader during module coming/going states */
 int klp_module_coming(struct module *mod);
 void klp_module_going(struct module *mod);

commit 7c8e2bdd5f0d990e2398ee3deafc626dd469fc2d
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Wed Apr 29 10:24:44 2020 -0500

    livepatch: Apply vmlinux-specific KLP relocations early
    
    KLP relocations are livepatch-specific relocations which are applied to
    a KLP module's text or data.  They exist for two reasons:
    
      1) Unexported symbols: replacement functions often need to access
         unexported symbols (e.g. static functions), which "normal"
         relocations don't allow.
    
      2) Late module patching: this is the ability for a KLP module to
         bypass normal module dependencies, such that the KLP module can be
         loaded *before* a to-be-patched module.  This means that
         relocations which need to access symbols in the to-be-patched
         module might need to be applied to the KLP module well after it has
         been loaded.
    
    Non-late-patched KLP relocations are applied from the KLP module's init
    function.  That usually works fine, unless the patched code wants to use
    alternatives, paravirt patching, jump tables, or some other special
    section which needs relocations.  Then we run into ordering issues and
    crashes.
    
    In order for those special sections to work properly, the KLP
    relocations should be applied *before* the special section init code
    runs, such as apply_paravirt(), apply_alternatives(), or
    jump_label_apply_nops().
    
    You might think the obvious solution would be to move the KLP relocation
    initialization earlier, but it's not necessarily that simple.  The
    problem is the above-mentioned late module patching, for which KLP
    relocations can get applied well after the KLP module is loaded.
    
    To "fix" this issue in the past, we created .klp.arch sections:
    
      .klp.arch.{module}..altinstructions
      .klp.arch.{module}..parainstructions
    
    Those sections allow KLP late module patching code to call
    apply_paravirt() and apply_alternatives() after the module-specific KLP
    relocations (.klp.rela.{module}.{section}) have been applied.
    
    But that has a lot of drawbacks, including code complexity, the need for
    arch-specific code, and the (per-arch) danger that we missed some
    special section -- for example the __jump_table section which is used
    for jump labels.
    
    It turns out there's a simpler and more functional approach.  There are
    two kinds of KLP relocation sections:
    
      1) vmlinux-specific KLP relocation sections
    
         .klp.rela.vmlinux.{sec}
    
         These are relocations (applied to the KLP module) which reference
         unexported vmlinux symbols.
    
      2) module-specific KLP relocation sections
    
         .klp.rela.{module}.{sec}:
    
         These are relocations (applied to the KLP module) which reference
         unexported or exported module symbols.
    
    Up until now, these have been treated the same.  However, they're
    inherently different.
    
    Because of late module patching, module-specific KLP relocations can be
    applied very late, thus they can create the ordering headaches described
    above.
    
    But vmlinux-specific KLP relocations don't have that problem.  There's
    nothing to prevent them from being applied earlier.  So apply them at
    the same time as normal relocations, when the KLP module is being
    loaded.
    
    This means that for vmlinux-specific KLP relocations, we no longer have
    any ordering issues.  vmlinux-referencing jump labels, alternatives, and
    paravirt patching will work automatically, without the need for the
    .klp.arch hacks.
    
    All that said, for module-specific KLP relocations, the ordering
    problems still exist and we *do* still need .klp.arch.  Or do we?  Stay
    tuned.
    
    Suggested-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: Joe Lawrence <joe.lawrence@redhat.com>
    Acked-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Jessica Yu <jeyu@kernel.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index e894e74905f3..c4302e9a5905 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -234,6 +234,11 @@ void klp_shadow_free_all(unsigned long id, klp_shadow_dtor_t dtor);
 struct klp_state *klp_get_state(struct klp_patch *patch, unsigned long id);
 struct klp_state *klp_get_prev_state(unsigned long id);
 
+int klp_apply_section_relocs(struct module *pmod, Elf_Shdr *sechdrs,
+			     const char *shstrtab, const char *strtab,
+			     unsigned int symindex, unsigned int secindex,
+			     const char *objname);
+
 #else /* !CONFIG_LIVEPATCH */
 
 static inline int klp_module_coming(struct module *mod) { return 0; }
@@ -242,6 +247,15 @@ static inline bool klp_patch_pending(struct task_struct *task) { return false; }
 static inline void klp_update_patch_state(struct task_struct *task) {}
 static inline void klp_copy_process(struct task_struct *child) {}
 
+static inline
+int klp_apply_section_relocs(struct module *pmod, Elf_Shdr *sechdrs,
+			     const char *shstrtab, const char *strtab,
+			     unsigned int symindex, unsigned int secindex,
+			     const char *objname)
+{
+	return 0;
+}
+
 #endif /* CONFIG_LIVEPATCH */
 
 #endif /* _LINUX_LIVEPATCH_H_ */

commit 92c9abf5e57500ea7dc59a55273aa7850b631bda
Author: Petr Mladek <pmladek@suse.com>
Date:   Wed Oct 30 16:43:11 2019 +0100

    livepatch: Allow to distinguish different version of system state changes
    
    The atomic replace runs pre/post (un)install callbacks only from the new
    livepatch. There are several reasons for this:
    
      + Simplicity: clear ordering of operations, no interactions between
            old and new callbacks.
    
      + Reliability: only new livepatch knows what changes can already be made
            by older livepatches and how to take over the state.
    
      + Testing: the atomic replace can be properly tested only when a newer
            livepatch is available. It might be too late to fix unwanted effect
            of callbacks from older livepatches.
    
    It might happen that an older change is not enough and the same system
    state has to be modified another way. Different changes need to get
    distinguished by a version number added to struct klp_state.
    
    The version can also be used to prevent loading incompatible livepatches.
    The check is done when the livepatch is enabled. The rules are:
    
      + Any completely new system state modification is allowed.
    
      + System state modifications with the same or higher version are allowed
        for already modified system states.
    
      + Cumulative livepatches must handle all system state modifications from
        already installed livepatches.
    
      + Non-cumulative livepatches are allowed to touch already modified
        system states.
    
    Link: http://lkml.kernel.org/r/20191030154313.13263-4-pmladek@suse.com
    To: Jiri Kosina <jikos@kernel.org>
    Cc: Kamalesh Babulal <kamalesh@linux.vnet.ibm.com>
    Cc: Nicolai Stange <nstange@suse.de>
    Cc: live-patching@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Acked-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Joe Lawrence <joe.lawrence@redhat.com>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index 726947338fd5..e894e74905f3 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -133,10 +133,12 @@ struct klp_object {
 /**
  * struct klp_state - state of the system modified by the livepatch
  * @id:		system state identifier (non-zero)
+ * @version:	version of the change
  * @data:	custom data
  */
 struct klp_state {
 	unsigned long id;
+	unsigned int version;
 	void *data;
 };
 

commit 73727f4dafa2df107e85753c5ab703a1f344e1f1
Author: Petr Mladek <pmladek@suse.com>
Date:   Wed Oct 30 16:43:10 2019 +0100

    livepatch: Basic API to track system state changes
    
    This is another step how to help maintaining more livepatches.
    
    One big help was the atomic replace and cumulative livepatches. These
    livepatches replace the already installed ones. Therefore it should
    be enough when each cumulative livepatch is consistent.
    
    The problems might come with shadow variables and callbacks. They might
    change the system behavior or state so that it is no longer safe to
    go back and use an older livepatch or the original kernel code. Also,
    a new livepatch must be able to detect changes which were made by
    the already installed livepatches.
    
    This is where the livepatch system state tracking gets useful. It
    allows to:
    
      - find whether a system state has already been modified by
        previous livepatches
    
      - store data needed to manipulate and restore the system state
    
    The information about the manipulated system states is stored in an
    array of struct klp_state. It can be searched by two new functions
    klp_get_state() and klp_get_prev_state().
    
    The dependencies are going to be solved by a version field added later.
    The only important information is that it will be allowed to modify
    the same state by more non-cumulative livepatches. It is similar
    to allowing to modify the same function several times. The livepatch
    author is responsible for preventing incompatible changes.
    
    Link: http://lkml.kernel.org/r/20191030154313.13263-3-pmladek@suse.com
    To: Jiri Kosina <jikos@kernel.org>
    Cc: Kamalesh Babulal <kamalesh@linux.vnet.ibm.com>
    Cc: Nicolai Stange <nstange@suse.de>
    Cc: live-patching@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Acked-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Joe Lawrence <joe.lawrence@redhat.com>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index 273400814020..726947338fd5 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -130,10 +130,21 @@ struct klp_object {
 	bool patched;
 };
 
+/**
+ * struct klp_state - state of the system modified by the livepatch
+ * @id:		system state identifier (non-zero)
+ * @data:	custom data
+ */
+struct klp_state {
+	unsigned long id;
+	void *data;
+};
+
 /**
  * struct klp_patch - patch structure for live patching
  * @mod:	reference to the live patch module
  * @objs:	object entries for kernel objects to be patched
+ * @states:	system states that can get modified
  * @replace:	replace all actively used patches
  * @list:	list node for global list of actively used patches
  * @kobj:	kobject for sysfs resources
@@ -147,6 +158,7 @@ struct klp_patch {
 	/* external */
 	struct module *mod;
 	struct klp_object *objs;
+	struct klp_state *states;
 	bool replace;
 
 	/* internal */
@@ -217,6 +229,9 @@ void *klp_shadow_get_or_alloc(void *obj, unsigned long id,
 void klp_shadow_free(void *obj, unsigned long id, klp_shadow_dtor_t dtor);
 void klp_shadow_free_all(unsigned long id, klp_shadow_dtor_t dtor);
 
+struct klp_state *klp_get_state(struct klp_patch *patch, unsigned long id);
+struct klp_state *klp_get_prev_state(unsigned long id);
+
 #else /* !CONFIG_LIVEPATCH */
 
 static inline int klp_module_coming(struct module *mod) { return 0; }

commit db0457338ece7482378d88e50ad298191c3e6947
Merge: 1f7563f743d7 38195dd5e916
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 11 15:30:05 2019 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/livepatching/livepatching
    
    Pull livepatching updates from Jiri Kosina:
    
     - stacktrace handling improvements from Miroslav benes
    
     - debug output improvements from Petr Mladek
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/livepatching/livepatching:
      livepatch: Remove duplicate warning about missing reliable stacktrace support
      Revert "livepatch: Remove reliable stacktrace check in klp_try_switch_task()"
      stacktrace: Remove weak version of save_stack_trace_tsk_reliable()
      livepatch: Use static buffer for debugging messages under rq lock
      livepatch: Remove stale kobj_added entries from kernel-doc descriptions

commit 1ccea77e2a2687cae171b7987eb44730ec8c6d5f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:43 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 13
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not see http www gnu org licenses
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details [based]
      [from] [clk] [highbank] [c] you should have received a copy of the
      gnu general public license along with this program if not see http
      www gnu org licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 355 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154041.837383322@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index a14bab1a0a3e..eeba421cc671 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -1,21 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * livepatch.h - Kernel Live Patching Core
  *
  * Copyright (C) 2014 Seth Jennings <sjenning@redhat.com>
  * Copyright (C) 2014 SUSE
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifndef _LINUX_LIVEPATCH_H_

commit aec71d794731c441a9b7ee9705efedd2f6054173
Author: Miroslav Benes <mbenes@suse.cz>
Date:   Tue May 7 15:08:14 2019 +0200

    livepatch: Remove stale kobj_added entries from kernel-doc descriptions
    
    Commit 4d141ab3416d ("livepatch: Remove custom kobject state handling")
    removed kobj_added members of klp_func, klp_object and klp_patch
    structures. kernel-doc descriptions were omitted by accident. Remove
    them.
    
    Reported-by: Kamalesh Babulal <kamalesh@linux.vnet.ibm.com>
    Signed-off-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Joe Lawrence <joe.lawrence@redhat.com>
    Reviewed-by: Kamalesh Babulal <kamalesh@linux.vnet.ibm.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index a14bab1a0a3e..955d46f37b72 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -47,7 +47,6 @@
  * @stack_node:	list node for klp_ops func_stack list
  * @old_size:	size of the old function
  * @new_size:	size of the new function
- * @kobj_added: @kobj has been added and needs freeing
  * @nop:        temporary patch to use the original code again; dyn. allocated
  * @patched:	the func has been added to the klp_ops list
  * @transition:	the func is currently being applied or reverted
@@ -125,7 +124,6 @@ struct klp_callbacks {
  * @node:	list node for klp_patch obj_list
  * @mod:	kernel module associated with the patched object
  *		(NULL for vmlinux)
- * @kobj_added: @kobj has been added and needs freeing
  * @dynamic:    temporary object for nop functions; dynamically allocated
  * @patched:	the object's funcs have been added to the klp_ops list
  */
@@ -152,7 +150,6 @@ struct klp_object {
  * @list:	list node for global list of actively used patches
  * @kobj:	kobject for sysfs resources
  * @obj_list:	dynamic list of the object entries
- * @kobj_added: @kobj has been added and needs freeing
  * @enabled:	the patch is enabled (but operation may be incomplete)
  * @forced:	was involved in a forced transition
  * @free_work:	patch cleanup from workqueue-context

commit 4d141ab3416d90f87775f5dee725efdf40110a8f
Author: Petr Mladek <pmladek@suse.com>
Date:   Fri May 3 15:26:24 2019 +0200

    livepatch: Remove custom kobject state handling
    
    kobject_init() always succeeds and sets the reference count to 1.
    It allows to always free the structures via kobject_put() and
    the related release callback.
    
    Note that the custom kobject state handling was used only
    because we did not know that kobject_put() can and actually
    should get called even when kobject_init_and_add() fails.
    
    The patch should not change the existing behavior.
    
    Suggested-by: "Tobin C. Harding" <tobin@kernel.org>
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Reviewed-by: Kamalesh Babulal <kamalesh@linux.vnet.ibm.com>
    Acked-by: Joe Lawrence <joe.lawrence@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index 53551f470722..a14bab1a0a3e 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -86,7 +86,6 @@ struct klp_func {
 	struct list_head node;
 	struct list_head stack_node;
 	unsigned long old_size, new_size;
-	bool kobj_added;
 	bool nop;
 	bool patched;
 	bool transition;
@@ -141,7 +140,6 @@ struct klp_object {
 	struct list_head func_list;
 	struct list_head node;
 	struct module *mod;
-	bool kobj_added;
 	bool dynamic;
 	bool patched;
 };
@@ -170,7 +168,6 @@ struct klp_patch {
 	struct list_head list;
 	struct kobject kobj;
 	struct list_head obj_list;
-	bool kobj_added;
 	bool enabled;
 	bool forced;
 	struct work_struct free_work;

commit e1452b607c48c642caf57299f4da83aa002f8533
Author: Jason Baron <jbaron@akamai.com>
Date:   Wed Jan 9 13:43:25 2019 +0100

    livepatch: Add atomic replace
    
    Sometimes we would like to revert a particular fix. Currently, this
    is not easy because we want to keep all other fixes active and we
    could revert only the last applied patch.
    
    One solution would be to apply new patch that implemented all
    the reverted functions like in the original code. It would work
    as expected but there will be unnecessary redirections. In addition,
    it would also require knowing which functions need to be reverted at
    build time.
    
    Another problem is when there are many patches that touch the same
    functions. There might be dependencies between patches that are
    not enforced on the kernel side. Also it might be pretty hard to
    actually prepare the patch and ensure compatibility with the other
    patches.
    
    Atomic replace && cumulative patches:
    
    A better solution would be to create cumulative patch and say that
    it replaces all older ones.
    
    This patch adds a new "replace" flag to struct klp_patch. When it is
    enabled, a set of 'nop' klp_func will be dynamically created for all
    functions that are already being patched but that will no longer be
    modified by the new patch. They are used as a new target during
    the patch transition.
    
    The idea is to handle Nops' structures like the static ones. When
    the dynamic structures are allocated, we initialize all values that
    are normally statically defined.
    
    The only exception is "new_func" in struct klp_func. It has to point
    to the original function and the address is known only when the object
    (module) is loaded. Note that we really need to set it. The address is
    used, for example, in klp_check_stack_func().
    
    Nevertheless we still need to distinguish the dynamically allocated
    structures in some operations. For this, we add "nop" flag into
    struct klp_func and "dynamic" flag into struct klp_object. They
    need special handling in the following situations:
    
      + The structures are added into the lists of objects and functions
        immediately. In fact, the lists were created for this purpose.
    
      + The address of the original function is known only when the patched
        object (module) is loaded. Therefore it is copied later in
        klp_init_object_loaded().
    
      + The ftrace handler must not set PC to func->new_func. It would cause
        infinite loop because the address points back to the beginning of
        the original function.
    
      + The various free() functions must free the structure itself.
    
    Note that other ways to detect the dynamic structures are not considered
    safe. For example, even the statically defined struct klp_object might
    include empty funcs array. It might be there just to run some callbacks.
    
    Also note that the safe iterator must be used in the free() functions.
    Otherwise already freed structures might get accessed.
    
    Special callbacks handling:
    
    The callbacks from the replaced patches are _not_ called by intention.
    It would be pretty hard to define a reasonable semantic and implement it.
    
    It might even be counter-productive. The new patch is cumulative. It is
    supposed to include most of the changes from older patches. In most cases,
    it will not want to call pre_unpatch() post_unpatch() callbacks from
    the replaced patches. It would disable/break things for no good reasons.
    Also it should be easier to handle various scenarios in a single script
    in the new patch than think about interactions caused by running many
    scripts from older patches. Not to say that the old scripts even would
    not expect to be called in this situation.
    
    Removing replaced patches:
    
    One nice effect of the cumulative patches is that the code from the
    older patches is no longer used. Therefore the replaced patches can
    be removed. It has several advantages:
    
      + Nops' structs will no longer be necessary and might be removed.
        This would save memory, restore performance (no ftrace handler),
        allow clear view on what is really patched.
    
      + Disabling the patch will cause using the original code everywhere.
        Therefore the livepatch callbacks could handle only one scenario.
        Note that the complication is already complex enough when the patch
        gets enabled. It is currently solved by calling callbacks only from
        the new cumulative patch.
    
      + The state is clean in both the sysfs interface and lsmod. The modules
        with the replaced livepatches might even get removed from the system.
    
    Some people actually expected this behavior from the beginning. After all
    a cumulative patch is supposed to "completely" replace an existing one.
    It is like when a new version of an application replaces an older one.
    
    This patch does the first step. It removes the replaced patches from
    the list of patches. It is safe. The consistency model ensures that
    they are no longer used. By other words, each process works only with
    the structures from klp_transition_patch.
    
    The removal is done by a special function. It combines actions done by
    __disable_patch() and klp_complete_transition(). But it is a fast
    track without all the transaction-related stuff.
    
    Signed-off-by: Jason Baron <jbaron@akamai.com>
    [pmladek@suse.com: Split, reuse existing code, simplified]
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Jessica Yu <jeyu@kernel.org>
    Cc: Jiri Kosina <jikos@kernel.org>
    Cc: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index e117e20ff771..53551f470722 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -48,6 +48,7 @@
  * @old_size:	size of the old function
  * @new_size:	size of the new function
  * @kobj_added: @kobj has been added and needs freeing
+ * @nop:        temporary patch to use the original code again; dyn. allocated
  * @patched:	the func has been added to the klp_ops list
  * @transition:	the func is currently being applied or reverted
  *
@@ -86,6 +87,7 @@ struct klp_func {
 	struct list_head stack_node;
 	unsigned long old_size, new_size;
 	bool kobj_added;
+	bool nop;
 	bool patched;
 	bool transition;
 };
@@ -125,6 +127,7 @@ struct klp_callbacks {
  * @mod:	kernel module associated with the patched object
  *		(NULL for vmlinux)
  * @kobj_added: @kobj has been added and needs freeing
+ * @dynamic:    temporary object for nop functions; dynamically allocated
  * @patched:	the object's funcs have been added to the klp_ops list
  */
 struct klp_object {
@@ -139,6 +142,7 @@ struct klp_object {
 	struct list_head node;
 	struct module *mod;
 	bool kobj_added;
+	bool dynamic;
 	bool patched;
 };
 
@@ -146,6 +150,7 @@ struct klp_object {
  * struct klp_patch - patch structure for live patching
  * @mod:	reference to the live patch module
  * @objs:	object entries for kernel objects to be patched
+ * @replace:	replace all actively used patches
  * @list:	list node for global list of actively used patches
  * @kobj:	kobject for sysfs resources
  * @obj_list:	dynamic list of the object entries
@@ -159,6 +164,7 @@ struct klp_patch {
 	/* external */
 	struct module *mod;
 	struct klp_object *objs;
+	bool replace;
 
 	/* internal */
 	struct list_head list;
@@ -174,6 +180,9 @@ struct klp_patch {
 #define klp_for_each_object_static(patch, obj) \
 	for (obj = patch->objs; obj->funcs || obj->name; obj++)
 
+#define klp_for_each_object_safe(patch, obj, tmp_obj)		\
+	list_for_each_entry_safe(obj, tmp_obj, &patch->obj_list, node)
+
 #define klp_for_each_object(patch, obj)	\
 	list_for_each_entry(obj, &patch->obj_list, node)
 
@@ -182,6 +191,9 @@ struct klp_patch {
 	     func->old_name || func->new_func || func->old_sympos; \
 	     func++)
 
+#define klp_for_each_func_safe(obj, func, tmp_func)			\
+	list_for_each_entry_safe(func, tmp_func, &obj->func_list, node)
+
 #define klp_for_each_func(obj, func)	\
 	list_for_each_entry(func, &obj->func_list, node)
 

commit 20e55025958e18e671d92c7adea00c301ac93c43
Author: Jason Baron <jbaron@akamai.com>
Date:   Wed Jan 9 13:43:24 2019 +0100

    livepatch: Use lists to manage patches, objects and functions
    
    Currently klp_patch contains a pointer to a statically allocated array of
    struct klp_object and struct klp_objects contains a pointer to a statically
    allocated array of klp_func. In order to allow for the dynamic allocation
    of objects and functions, link klp_patch, klp_object, and klp_func together
    via linked lists. This allows us to more easily allocate new objects and
    functions, while having the iterator be a simple linked list walk.
    
    The static structures are added to the lists early. It allows to add
    the dynamically allocated objects before klp_init_object() and
    klp_init_func() calls. Therefore it reduces the further changes
    to the code.
    
    This patch does not change the existing behavior.
    
    Signed-off-by: Jason Baron <jbaron@akamai.com>
    [pmladek@suse.com: Initialize lists before init calls]
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Acked-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Joe Lawrence <joe.lawrence@redhat.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Jiri Kosina <jikos@kernel.org>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index 8f9c19c69744..e117e20ff771 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -24,6 +24,7 @@
 #include <linux/module.h>
 #include <linux/ftrace.h>
 #include <linux/completion.h>
+#include <linux/list.h>
 
 #if IS_ENABLED(CONFIG_LIVEPATCH)
 
@@ -42,6 +43,7 @@
  *		can be found (optional)
  * @old_func:	pointer to the function being patched
  * @kobj:	kobject for sysfs resources
+ * @node:	list node for klp_object func_list
  * @stack_node:	list node for klp_ops func_stack list
  * @old_size:	size of the old function
  * @new_size:	size of the new function
@@ -80,6 +82,7 @@ struct klp_func {
 	/* internal */
 	void *old_func;
 	struct kobject kobj;
+	struct list_head node;
 	struct list_head stack_node;
 	unsigned long old_size, new_size;
 	bool kobj_added;
@@ -117,6 +120,8 @@ struct klp_callbacks {
  * @funcs:	function entries for functions to be patched in the object
  * @callbacks:	functions to be executed pre/post (un)patching
  * @kobj:	kobject for sysfs resources
+ * @func_list:	dynamic list of the function entries
+ * @node:	list node for klp_patch obj_list
  * @mod:	kernel module associated with the patched object
  *		(NULL for vmlinux)
  * @kobj_added: @kobj has been added and needs freeing
@@ -130,6 +135,8 @@ struct klp_object {
 
 	/* internal */
 	struct kobject kobj;
+	struct list_head func_list;
+	struct list_head node;
 	struct module *mod;
 	bool kobj_added;
 	bool patched;
@@ -141,6 +148,7 @@ struct klp_object {
  * @objs:	object entries for kernel objects to be patched
  * @list:	list node for global list of actively used patches
  * @kobj:	kobject for sysfs resources
+ * @obj_list:	dynamic list of the object entries
  * @kobj_added: @kobj has been added and needs freeing
  * @enabled:	the patch is enabled (but operation may be incomplete)
  * @forced:	was involved in a forced transition
@@ -155,6 +163,7 @@ struct klp_patch {
 	/* internal */
 	struct list_head list;
 	struct kobject kobj;
+	struct list_head obj_list;
 	bool kobj_added;
 	bool enabled;
 	bool forced;
@@ -162,14 +171,20 @@ struct klp_patch {
 	struct completion finish;
 };
 
-#define klp_for_each_object(patch, obj) \
+#define klp_for_each_object_static(patch, obj) \
 	for (obj = patch->objs; obj->funcs || obj->name; obj++)
 
-#define klp_for_each_func(obj, func) \
+#define klp_for_each_object(patch, obj)	\
+	list_for_each_entry(obj, &patch->obj_list, node)
+
+#define klp_for_each_func_static(obj, func) \
 	for (func = obj->funcs; \
 	     func->old_name || func->new_func || func->old_sympos; \
 	     func++)
 
+#define klp_for_each_func(obj, func)	\
+	list_for_each_entry(func, &obj->func_list, node)
+
 int klp_enable_patch(struct klp_patch *);
 
 void arch_klp_init_object_loaded(struct klp_patch *patch,

commit 958ef1e39d24d6cb8bf2a7406130a98c9564230f
Author: Petr Mladek <pmladek@suse.com>
Date:   Wed Jan 9 13:43:23 2019 +0100

    livepatch: Simplify API by removing registration step
    
    The possibility to re-enable a registered patch was useful for immediate
    patches where the livepatch module had to stay until the system reboot.
    The improved consistency model allows to achieve the same result by
    unloading and loading the livepatch module again.
    
    Also we are going to add a feature called atomic replace. It will allow
    to create a patch that would replace all already registered patches.
    The aim is to handle dependent patches more securely. It will obsolete
    the stack of patches that helped to handle the dependencies so far.
    Then it might be unclear when a cumulative patch re-enabling is safe.
    
    It would be complicated to support the many modes. Instead we could
    actually make the API and code easier to understand.
    
    Therefore, remove the two step public API. All the checks and init calls
    are moved from klp_register_patch() to klp_enabled_patch(). Also the patch
    is automatically freed, including the sysfs interface when the transition
    to the disabled state is completed.
    
    As a result, there is never a disabled patch on the top of the stack.
    Therefore we do not need to check the stack in __klp_enable_patch().
    And we could simplify the check in __klp_disable_patch().
    
    Also the API and logic is much easier. It is enough to call
    klp_enable_patch() in module_init() call. The patch can be disabled
    by writing '0' into /sys/kernel/livepatch/<patch>/enabled. Then the module
    can be removed once the transition finishes and sysfs interface is freed.
    
    The only problem is how to free the structures and kobjects safely.
    The operation is triggered from the sysfs interface. We could not put
    the related kobject from there because it would cause lock inversion
    between klp_mutex and kernfs locks, see kn->count lockdep map.
    
    Therefore, offload the free task to a workqueue. It is perfectly fine:
    
      + The patch can no longer be used in the livepatch operations.
    
      + The module could not be removed until the free operation finishes
        and module_put() is called.
    
      + The operation is asynchronous already when the first
        klp_try_complete_transition() fails and another call
        is queued with a delay.
    
    Suggested-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Acked-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index 6a9165d9b090..8f9c19c69744 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -139,11 +139,12 @@ struct klp_object {
  * struct klp_patch - patch structure for live patching
  * @mod:	reference to the live patch module
  * @objs:	object entries for kernel objects to be patched
- * @list:	list node for global list of registered patches
+ * @list:	list node for global list of actively used patches
  * @kobj:	kobject for sysfs resources
  * @kobj_added: @kobj has been added and needs freeing
  * @enabled:	the patch is enabled (but operation may be incomplete)
  * @forced:	was involved in a forced transition
+ * @free_work:	patch cleanup from workqueue-context
  * @finish:	for waiting till it is safe to remove the patch module
  */
 struct klp_patch {
@@ -157,6 +158,7 @@ struct klp_patch {
 	bool kobj_added;
 	bool enabled;
 	bool forced;
+	struct work_struct free_work;
 	struct completion finish;
 };
 
@@ -168,10 +170,7 @@ struct klp_patch {
 	     func->old_name || func->new_func || func->old_sympos; \
 	     func++)
 
-int klp_register_patch(struct klp_patch *);
-int klp_unregister_patch(struct klp_patch *);
 int klp_enable_patch(struct klp_patch *);
-int klp_disable_patch(struct klp_patch *);
 
 void arch_klp_init_object_loaded(struct klp_patch *patch,
 				 struct klp_object *obj);

commit 68007289bf3cd937a5b8fc4987d2787167bd06ca
Author: Petr Mladek <pmladek@suse.com>
Date:   Wed Jan 9 13:43:22 2019 +0100

    livepatch: Don't block the removal of patches loaded after a forced transition
    
    module_put() is currently never called in klp_complete_transition() when
    klp_force is set. As a result, we might keep the reference count even when
    klp_enable_patch() fails and klp_cancel_transition() is called.
    
    This might give the impression that a module might get blocked in some
    strange init state. Fortunately, it is not the case. The reference count
    is ignored when mod->init fails and erroneous modules are always removed.
    
    Anyway, this might be confusing. Instead, this patch moves
    the global klp_forced flag into struct klp_patch. As a result,
    we block only modules that might still be in use after a forced
    transition. Newly loaded livepatches might be eventually completely
    removed later.
    
    It is not a big deal. But the code is at least consistent with
    the reality.
    
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Acked-by: Joe Lawrence <joe.lawrence@redhat.com>
    Acked-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index 6978785bc059..6a9165d9b090 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -143,6 +143,7 @@ struct klp_object {
  * @kobj:	kobject for sysfs resources
  * @kobj_added: @kobj has been added and needs freeing
  * @enabled:	the patch is enabled (but operation may be incomplete)
+ * @forced:	was involved in a forced transition
  * @finish:	for waiting till it is safe to remove the patch module
  */
 struct klp_patch {
@@ -155,6 +156,7 @@ struct klp_patch {
 	struct kobject kobj;
 	bool kobj_added;
 	bool enabled;
+	bool forced;
 	struct completion finish;
 };
 

commit 0430f78bf38f9972f0cf0522709cc63d49fa164c
Author: Petr Mladek <pmladek@suse.com>
Date:   Wed Jan 9 13:43:21 2019 +0100

    livepatch: Consolidate klp_free functions
    
    The code for freeing livepatch structures is a bit scattered and tricky:
    
      + direct calls to klp_free_*_limited() and kobject_put() are
        used to release partially initialized objects
    
      + klp_free_patch() removes the patch from the public list
        and releases all objects except for patch->kobj
    
      + object_put(&patch->kobj) and the related wait_for_completion()
        are called directly outside klp_mutex; this code is duplicated;
    
    Now, we are going to remove the registration stage to simplify the API
    and the code. This would require handling more situations in
    klp_enable_patch() error paths.
    
    More importantly, we are going to add a feature called atomic replace.
    It will need to dynamically create func and object structures. We will
    want to reuse the existing init() and free() functions. This would
    create even more error path scenarios.
    
    This patch implements more straightforward free functions:
    
      + checks kobj_added flag instead of @limit[*]
    
      + initializes patch->list early so that the check for empty list
        always works
    
      + The action(s) that has to be done outside klp_mutex are done
        in separate klp_free_patch_finish() function. It waits only
        when patch->kobj was really released via the _start() part.
    
    The patch does not change the existing behavior.
    
    [*] We need our own flag to track that the kobject was successfully
        added to the hierarchy.  Note that kobj.state_initialized only
        indicates that kobject has been initialized, not whether is has
        been added (and needs to be removed on cleanup).
    
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Miroslav Benes <mbenes@suse.cz>
    Cc: Jessica Yu <jeyu@kernel.org>
    Cc: Jiri Kosina <jikos@kernel.org>
    Cc: Jason Baron <jbaron@akamai.com>
    Acked-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index 634e13876380..6978785bc059 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -45,6 +45,7 @@
  * @stack_node:	list node for klp_ops func_stack list
  * @old_size:	size of the old function
  * @new_size:	size of the new function
+ * @kobj_added: @kobj has been added and needs freeing
  * @patched:	the func has been added to the klp_ops list
  * @transition:	the func is currently being applied or reverted
  *
@@ -81,6 +82,7 @@ struct klp_func {
 	struct kobject kobj;
 	struct list_head stack_node;
 	unsigned long old_size, new_size;
+	bool kobj_added;
 	bool patched;
 	bool transition;
 };
@@ -117,6 +119,7 @@ struct klp_callbacks {
  * @kobj:	kobject for sysfs resources
  * @mod:	kernel module associated with the patched object
  *		(NULL for vmlinux)
+ * @kobj_added: @kobj has been added and needs freeing
  * @patched:	the object's funcs have been added to the klp_ops list
  */
 struct klp_object {
@@ -128,6 +131,7 @@ struct klp_object {
 	/* internal */
 	struct kobject kobj;
 	struct module *mod;
+	bool kobj_added;
 	bool patched;
 };
 
@@ -137,6 +141,7 @@ struct klp_object {
  * @objs:	object entries for kernel objects to be patched
  * @list:	list node for global list of registered patches
  * @kobj:	kobject for sysfs resources
+ * @kobj_added: @kobj has been added and needs freeing
  * @enabled:	the patch is enabled (but operation may be incomplete)
  * @finish:	for waiting till it is safe to remove the patch module
  */
@@ -148,6 +153,7 @@ struct klp_patch {
 	/* internal */
 	struct list_head list;
 	struct kobject kobj;
+	bool kobj_added;
 	bool enabled;
 	struct completion finish;
 };

commit 19514910d021c93c7823ec32067e6b7dea224f0f
Author: Petr Mladek <pmladek@suse.com>
Date:   Wed Jan 9 13:43:19 2019 +0100

    livepatch: Change unsigned long old_addr -> void *old_func in struct klp_func
    
    The address of the to be patched function and new function is stored
    in struct klp_func as:
    
            void *new_func;
            unsigned long old_addr;
    
    The different naming scheme and type are derived from the way
    the addresses are set. @old_addr is assigned at runtime using
    kallsyms-based search. @new_func is statically initialized,
    for example:
    
      static struct klp_func funcs[] = {
            {
                    .old_name = "cmdline_proc_show",
                    .new_func = livepatch_cmdline_proc_show,
            }, { }
      };
    
    This patch changes unsigned long old_addr -> void *old_func. It removes
    some confusion when these address are later used in the code. It is
    motivated by a followup patch that adds special NOP struct klp_func
    where we want to assign func->new_func = func->old_addr respectively
    func->new_func = func->old_func.
    
    This patch does not modify the existing behavior.
    
    Suggested-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Acked-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Joe Lawrence <joe.lawrence@redhat.com>
    Acked-by: Alice Ferrazzi <alice.ferrazzi@gmail.com>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index aec44b1d9582..634e13876380 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -40,7 +40,7 @@
  * @new_func:	pointer to the patched function code
  * @old_sympos: a hint indicating which symbol position the old function
  *		can be found (optional)
- * @old_addr:	the address of the function being patched
+ * @old_func:	pointer to the function being patched
  * @kobj:	kobject for sysfs resources
  * @stack_node:	list node for klp_ops func_stack list
  * @old_size:	size of the old function
@@ -77,7 +77,7 @@ struct klp_func {
 	unsigned long old_sympos;
 
 	/* internal */
-	unsigned long old_addr;
+	void *old_func;
 	struct kobject kobj;
 	struct list_head stack_node;
 	unsigned long old_size, new_size;

commit 3b2c77d000fe9f7d02e9e726e00dccf9f92b256f
Author: Petr Mladek <pmladek@suse.com>
Date:   Mon Apr 16 13:36:47 2018 +0200

    livepatch: Allow to call a custom callback when freeing shadow variables
    
    We might need to do some actions before the shadow variable is freed.
    For example, we might need to remove it from a list or free some data
    that it points to.
    
    This is already possible now. The user can get the shadow variable
    by klp_shadow_get(), do the necessary actions, and then call
    klp_shadow_free().
    
    This patch allows to do it a more elegant way. The user could implement
    the needed actions in a callback that is passed to klp_shadow_free()
    as a parameter. The callback usually does reverse operations to
    the constructor callback that can be called by klp_shadow_*alloc().
    
    It is especially useful for klp_shadow_free_all(). There we need to do
    these extra actions for each found shadow variable with the given ID.
    
    Note that the memory used by the shadow variable itself is still released
    later by rcu callback. It is needed to protect internal structures that
    keep all shadow variables. But the destructor is called immediately.
    The shadow variable must not be access anyway after klp_shadow_free()
    is called. The user is responsible to protect this any suitable way.
    
    Be aware that the destructor is called under klp_shadow_lock. It is
    the same as for the contructor in klp_shadow_alloc().
    
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Miroslav Benes <mbenes@suse.cz>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index 7e084321b146..aec44b1d9582 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -189,6 +189,7 @@ static inline bool klp_have_reliable_stack(void)
 typedef int (*klp_shadow_ctor_t)(void *obj,
 				 void *shadow_data,
 				 void *ctor_data);
+typedef void (*klp_shadow_dtor_t)(void *obj, void *shadow_data);
 
 void *klp_shadow_get(void *obj, unsigned long id);
 void *klp_shadow_alloc(void *obj, unsigned long id,
@@ -197,8 +198,8 @@ void *klp_shadow_alloc(void *obj, unsigned long id,
 void *klp_shadow_get_or_alloc(void *obj, unsigned long id,
 			      size_t size, gfp_t gfp_flags,
 			      klp_shadow_ctor_t ctor, void *ctor_data);
-void klp_shadow_free(void *obj, unsigned long id);
-void klp_shadow_free_all(unsigned long id);
+void klp_shadow_free(void *obj, unsigned long id, klp_shadow_dtor_t dtor);
+void klp_shadow_free_all(unsigned long id, klp_shadow_dtor_t dtor);
 
 #else /* !CONFIG_LIVEPATCH */
 

commit e91c2518a5d22a07642f35d85f39001ad379dae4
Author: Petr Mladek <pmladek@suse.com>
Date:   Mon Apr 16 13:36:46 2018 +0200

    livepatch: Initialize shadow variables safely by a custom callback
    
    The existing API allows to pass a sample data to initialize the shadow
    data. It works well when the data are position independent. But it fails
    miserably when we need to set a pointer to the shadow structure itself.
    
    Unfortunately, we might need to initialize the pointer surprisingly
    often because of struct list_head. It is even worse because the list
    might be hidden in other common structures, for example, struct mutex,
    struct wait_queue_head.
    
    For example, this was needed to fix races in ALSA sequencer. It required
    to add mutex into struct snd_seq_client. See commit b3defb791b26ea06
    ("ALSA: seq: Make ioctls race-free") and commit d15d662e89fc667b9
    ("ALSA: seq: Fix racy pool initializations")
    
    This patch makes the API more safe. A custom constructor function and data
    are passed to klp_shadow_*alloc() functions instead of the sample data.
    
    Note that ctor_data are no longer a template for shadow->data. It might
    point to any data that might be necessary when the constructor is called.
    
    Also note that the constructor is called under klp_shadow_lock. It is
    an internal spin_lock that synchronizes alloc() vs. get() operations,
    see klp_shadow_get_or_alloc(). On one hand, this adds a risk of ABBA
    deadlocks. On the other hand, it allows to do some operations safely.
    For example, we could add the new structure into an existing list.
    This must be done only once when the structure is allocated.
    
    Reported-by: Nicolai Stange <nstange@suse.de>
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Miroslav Benes <mbenes@suse.cz>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index 4754f01c1abb..7e084321b146 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -186,11 +186,17 @@ static inline bool klp_have_reliable_stack(void)
 	       IS_ENABLED(CONFIG_HAVE_RELIABLE_STACKTRACE);
 }
 
+typedef int (*klp_shadow_ctor_t)(void *obj,
+				 void *shadow_data,
+				 void *ctor_data);
+
 void *klp_shadow_get(void *obj, unsigned long id);
-void *klp_shadow_alloc(void *obj, unsigned long id, void *data,
-		       size_t size, gfp_t gfp_flags);
-void *klp_shadow_get_or_alloc(void *obj, unsigned long id, void *data,
-			      size_t size, gfp_t gfp_flags);
+void *klp_shadow_alloc(void *obj, unsigned long id,
+		       size_t size, gfp_t gfp_flags,
+		       klp_shadow_ctor_t ctor, void *ctor_data);
+void *klp_shadow_get_or_alloc(void *obj, unsigned long id,
+			      size_t size, gfp_t gfp_flags,
+			      klp_shadow_ctor_t ctor, void *ctor_data);
 void klp_shadow_free(void *obj, unsigned long id);
 void klp_shadow_free_all(unsigned long id);
 

commit d0807da78e11d46f18399cbf8c4028c731346766
Author: Miroslav Benes <mbenes@suse.cz>
Date:   Wed Jan 10 11:01:28 2018 +0100

    livepatch: Remove immediate feature
    
    Immediate flag has been used to disable per-task consistency and patch
    all tasks immediately. It could be useful if the patch doesn't change any
    function or data semantics.
    
    However, it causes problems on its own. The consistency problem is
    currently broken with respect to immediate patches.
    
    func            a
    patches         1i
                    2i
                    3
    
    When the patch 3 is applied, only 2i function is checked (by stack
    checking facility). There might be a task sleeping in 1i though. Such
    task is migrated to 3, because we do not check 1i in
    klp_check_stack_func() at all.
    
    Coming atomic replace feature would be easier to implement and more
    reliable without immediate.
    
    Thus, remove immediate feature completely and save us from the problems.
    
    Note that force feature has the similar problem. However it is
    considered as a last resort. If used, administrator should not apply any
    new live patches and should plan for reboot into an updated kernel.
    
    The architectures would now need to provide HAVE_RELIABLE_STACKTRACE to
    fully support livepatch.
    
    Signed-off-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index fc5c1be3f6f4..4754f01c1abb 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -40,7 +40,6 @@
  * @new_func:	pointer to the patched function code
  * @old_sympos: a hint indicating which symbol position the old function
  *		can be found (optional)
- * @immediate:  patch the func immediately, bypassing safety mechanisms
  * @old_addr:	the address of the function being patched
  * @kobj:	kobject for sysfs resources
  * @stack_node:	list node for klp_ops func_stack list
@@ -76,7 +75,6 @@ struct klp_func {
 	 * in kallsyms for the given object is used.
 	 */
 	unsigned long old_sympos;
-	bool immediate;
 
 	/* internal */
 	unsigned long old_addr;
@@ -137,7 +135,6 @@ struct klp_object {
  * struct klp_patch - patch structure for live patching
  * @mod:	reference to the live patch module
  * @objs:	object entries for kernel objects to be patched
- * @immediate:  patch all funcs immediately, bypassing safety mechanisms
  * @list:	list node for global list of registered patches
  * @kobj:	kobject for sysfs resources
  * @enabled:	the patch is enabled (but operation may be incomplete)
@@ -147,7 +144,6 @@ struct klp_patch {
 	/* external */
 	struct module *mod;
 	struct klp_object *objs;
-	bool immediate;
 
 	/* internal */
 	struct list_head list;

commit 93862e385ded7c60351e09fcd2a541d273650905
Author: Joe Lawrence <joe.lawrence@redhat.com>
Date:   Fri Oct 13 15:08:41 2017 -0400

    livepatch: add (un)patch callbacks
    
    Provide livepatch modules a klp_object (un)patching notification
    mechanism.  Pre and post-(un)patch callbacks allow livepatch modules to
    setup or synchronize changes that would be difficult to support in only
    patched-or-unpatched code contexts.
    
    Callbacks can be registered for target module or vmlinux klp_objects,
    but each implementation is klp_object specific.
    
      - Pre-(un)patch callbacks run before any (un)patching transition
        starts.
    
      - Post-(un)patch callbacks run once an object has been (un)patched and
        the klp_patch fully transitioned to its target state.
    
    Example use cases include modification of global data and registration
    of newly available services/handlers.
    
    See Documentation/livepatch/callbacks.txt for details and
    samples/livepatch/ for examples.
    
    Signed-off-by: Joe Lawrence <joe.lawrence@redhat.com>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Miroslav Benes <mbenes@suse.cz>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index d08eddc00497..fc5c1be3f6f4 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -87,10 +87,35 @@ struct klp_func {
 	bool transition;
 };
 
+struct klp_object;
+
+/**
+ * struct klp_callbacks - pre/post live-(un)patch callback structure
+ * @pre_patch:		executed before code patching
+ * @post_patch:		executed after code patching
+ * @pre_unpatch:	executed before code unpatching
+ * @post_unpatch:	executed after code unpatching
+ * @post_unpatch_enabled:	flag indicating if post-unpatch callback
+ * 				should run
+ *
+ * All callbacks are optional.  Only the pre-patch callback, if provided,
+ * will be unconditionally executed.  If the parent klp_object fails to
+ * patch for any reason, including a non-zero error status returned from
+ * the pre-patch callback, no further callbacks will be executed.
+ */
+struct klp_callbacks {
+	int (*pre_patch)(struct klp_object *obj);
+	void (*post_patch)(struct klp_object *obj);
+	void (*pre_unpatch)(struct klp_object *obj);
+	void (*post_unpatch)(struct klp_object *obj);
+	bool post_unpatch_enabled;
+};
+
 /**
  * struct klp_object - kernel object structure for live patching
  * @name:	module name (or NULL for vmlinux)
  * @funcs:	function entries for functions to be patched in the object
+ * @callbacks:	functions to be executed pre/post (un)patching
  * @kobj:	kobject for sysfs resources
  * @mod:	kernel module associated with the patched object
  *		(NULL for vmlinux)
@@ -100,6 +125,7 @@ struct klp_object {
 	/* external */
 	const char *name;
 	struct klp_func *funcs;
+	struct klp_callbacks callbacks;
 
 	/* internal */
 	struct kobject kobj;

commit 439e7271dc2b63de379e37971dc2f64d71e24f8a
Author: Joe Lawrence <joe.lawrence@redhat.com>
Date:   Thu Aug 31 16:37:41 2017 -0400

    livepatch: introduce shadow variable API
    
    Add exported API for livepatch modules:
    
      klp_shadow_get()
      klp_shadow_alloc()
      klp_shadow_get_or_alloc()
      klp_shadow_free()
      klp_shadow_free_all()
    
    that implement "shadow" variables, which allow callers to associate new
    shadow fields to existing data structures.  This is intended to be used
    by livepatch modules seeking to emulate additions to data structure
    definitions.
    
    See Documentation/livepatch/shadow-vars.txt for a summary of the new
    shadow variable API, including a few common use cases.
    
    See samples/livepatch/livepatch-shadow-* for example modules that
    demonstrate shadow variables.
    
    [jkosina@suse.cz: fix __klp_shadow_get_or_alloc() comment as spotted by
     Josh]
    Signed-off-by: Joe Lawrence <joe.lawrence@redhat.com>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Miroslav Benes <mbenes@suse.cz>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index 194991ef9347..d08eddc00497 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -164,6 +164,14 @@ static inline bool klp_have_reliable_stack(void)
 	       IS_ENABLED(CONFIG_HAVE_RELIABLE_STACKTRACE);
 }
 
+void *klp_shadow_get(void *obj, unsigned long id);
+void *klp_shadow_alloc(void *obj, unsigned long id, void *data,
+		       size_t size, gfp_t gfp_flags);
+void *klp_shadow_get_or_alloc(void *obj, unsigned long id, void *data,
+			      size_t size, gfp_t gfp_flags);
+void klp_shadow_free(void *obj, unsigned long id);
+void klp_shadow_free_all(unsigned long id);
+
 #else /* !CONFIG_LIVEPATCH */
 
 static inline int klp_module_coming(struct module *mod) { return 0; }

commit 3ec24776bfd09668079df7dca0c0136d80820ab4
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Mon Mar 6 11:20:29 2017 -0600

    livepatch: allow removal of a disabled patch
    
    Currently we do not allow patch module to unload since there is no
    method to determine if a task is still running in the patched code.
    
    The consistency model gives us the way because when the unpatching
    finishes we know that all tasks were marked as safe to call an original
    function. Thus every new call to the function calls the original code
    and at the same time no task can be somewhere in the patched code,
    because it had to leave that code to be marked as safe.
    
    We can safely let the patch module go after that.
    
    Completion is used for synchronization between module removal and sysfs
    infrastructure in a similar way to commit 942e443127e9 ("module: Fix
    mod->mkobj.kobj potentially freed too early").
    
    Note that we still do not allow the removal for immediate model, that is
    no consistency model. The module refcount may increase in this case if
    somebody disables and enables the patch several times. This should not
    cause any harm.
    
    With this change a call to try_module_get() is moved to
    __klp_enable_patch from klp_register_patch to make module reference
    counting symmetric (module_put() is in a patch disable path) and to
    allow to take a new reference to a disabled module when being enabled.
    
    Finally, we need to be very careful about possible races between
    klp_unregister_patch(), kobject_put() functions and operations
    on the related sysfs files.
    
    kobject_put(&patch->kobj) must be called without klp_mutex. Otherwise,
    it might be blocked by enabled_store() that needs the mutex as well.
    In addition, enabled_store() must check if the patch was not
    unregisted in the meantime.
    
    There is no need to do the same for other kobject_put() callsites
    at the moment. Their sysfs operations neither take the lock nor
    they access any data that might be freed in the meantime.
    
    There was an attempt to use kobjects the right way and prevent these
    races by design. But it made the patch definition more complicated
    and opened another can of worms. See
    https://lkml.kernel.org/r/1464018848-4303-1-git-send-email-pmladek@suse.com
    
    [Thanks to Petr Mladek for improving the commit message.]
    
    Signed-off-by: Miroslav Benes <mbenes@suse.cz>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Acked-by: Miroslav Benes <mbenes@suse.cz>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index ed90ad1605c1..194991ef9347 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -23,6 +23,7 @@
 
 #include <linux/module.h>
 #include <linux/ftrace.h>
+#include <linux/completion.h>
 
 #if IS_ENABLED(CONFIG_LIVEPATCH)
 
@@ -114,6 +115,7 @@ struct klp_object {
  * @list:	list node for global list of registered patches
  * @kobj:	kobject for sysfs resources
  * @enabled:	the patch is enabled (but operation may be incomplete)
+ * @finish:	for waiting till it is safe to remove the patch module
  */
 struct klp_patch {
 	/* external */
@@ -125,6 +127,7 @@ struct klp_patch {
 	struct list_head list;
 	struct kobject kobj;
 	bool enabled;
+	struct completion finish;
 };
 
 #define klp_for_each_object(patch, obj) \

commit d83a7cb375eec21f04c83542395d08b2f6641da2
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Mon Feb 13 19:42:40 2017 -0600

    livepatch: change to a per-task consistency model
    
    Change livepatch to use a basic per-task consistency model.  This is the
    foundation which will eventually enable us to patch those ~10% of
    security patches which change function or data semantics.  This is the
    biggest remaining piece needed to make livepatch more generally useful.
    
    This code stems from the design proposal made by Vojtech [1] in November
    2014.  It's a hybrid of kGraft and kpatch: it uses kGraft's per-task
    consistency and syscall barrier switching combined with kpatch's stack
    trace switching.  There are also a number of fallback options which make
    it quite flexible.
    
    Patches are applied on a per-task basis, when the task is deemed safe to
    switch over.  When a patch is enabled, livepatch enters into a
    transition state where tasks are converging to the patched state.
    Usually this transition state can complete in a few seconds.  The same
    sequence occurs when a patch is disabled, except the tasks converge from
    the patched state to the unpatched state.
    
    An interrupt handler inherits the patched state of the task it
    interrupts.  The same is true for forked tasks: the child inherits the
    patched state of the parent.
    
    Livepatch uses several complementary approaches to determine when it's
    safe to patch tasks:
    
    1. The first and most effective approach is stack checking of sleeping
       tasks.  If no affected functions are on the stack of a given task,
       the task is patched.  In most cases this will patch most or all of
       the tasks on the first try.  Otherwise it'll keep trying
       periodically.  This option is only available if the architecture has
       reliable stacks (HAVE_RELIABLE_STACKTRACE).
    
    2. The second approach, if needed, is kernel exit switching.  A
       task is switched when it returns to user space from a system call, a
       user space IRQ, or a signal.  It's useful in the following cases:
    
       a) Patching I/O-bound user tasks which are sleeping on an affected
          function.  In this case you have to send SIGSTOP and SIGCONT to
          force it to exit the kernel and be patched.
       b) Patching CPU-bound user tasks.  If the task is highly CPU-bound
          then it will get patched the next time it gets interrupted by an
          IRQ.
       c) In the future it could be useful for applying patches for
          architectures which don't yet have HAVE_RELIABLE_STACKTRACE.  In
          this case you would have to signal most of the tasks on the
          system.  However this isn't supported yet because there's
          currently no way to patch kthreads without
          HAVE_RELIABLE_STACKTRACE.
    
    3. For idle "swapper" tasks, since they don't ever exit the kernel, they
       instead have a klp_update_patch_state() call in the idle loop which
       allows them to be patched before the CPU enters the idle state.
    
       (Note there's not yet such an approach for kthreads.)
    
    All the above approaches may be skipped by setting the 'immediate' flag
    in the 'klp_patch' struct, which will disable per-task consistency and
    patch all tasks immediately.  This can be useful if the patch doesn't
    change any function or data semantics.  Note that, even with this flag
    set, it's possible that some tasks may still be running with an old
    version of the function, until that function returns.
    
    There's also an 'immediate' flag in the 'klp_func' struct which allows
    you to specify that certain functions in the patch can be applied
    without per-task consistency.  This might be useful if you want to patch
    a common function like schedule(), and the function change doesn't need
    consistency but the rest of the patch does.
    
    For architectures which don't have HAVE_RELIABLE_STACKTRACE, the user
    must set patch->immediate which causes all tasks to be patched
    immediately.  This option should be used with care, only when the patch
    doesn't change any function or data semantics.
    
    In the future, architectures which don't have HAVE_RELIABLE_STACKTRACE
    may be allowed to use per-task consistency if we can come up with
    another way to patch kthreads.
    
    The /sys/kernel/livepatch/<patch>/transition file shows whether a patch
    is in transition.  Only a single patch (the topmost patch on the stack)
    can be in transition at a given time.  A patch can remain in transition
    indefinitely, if any of the tasks are stuck in the initial patch state.
    
    A transition can be reversed and effectively canceled by writing the
    opposite value to the /sys/kernel/livepatch/<patch>/enabled file while
    the transition is in progress.  Then all the tasks will attempt to
    converge back to the original patch state.
    
    [1] https://lkml.kernel.org/r/20141107140458.GA21774@suse.cz
    
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Ingo Molnar <mingo@kernel.org>        # for the scheduler changes
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index 6602b34bed2b..ed90ad1605c1 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -28,18 +28,40 @@
 
 #include <asm/livepatch.h>
 
+/* task patch states */
+#define KLP_UNDEFINED	-1
+#define KLP_UNPATCHED	 0
+#define KLP_PATCHED	 1
+
 /**
  * struct klp_func - function structure for live patching
  * @old_name:	name of the function to be patched
  * @new_func:	pointer to the patched function code
  * @old_sympos: a hint indicating which symbol position the old function
  *		can be found (optional)
+ * @immediate:  patch the func immediately, bypassing safety mechanisms
  * @old_addr:	the address of the function being patched
  * @kobj:	kobject for sysfs resources
  * @stack_node:	list node for klp_ops func_stack list
  * @old_size:	size of the old function
  * @new_size:	size of the new function
  * @patched:	the func has been added to the klp_ops list
+ * @transition:	the func is currently being applied or reverted
+ *
+ * The patched and transition variables define the func's patching state.  When
+ * patching, a func is always in one of the following states:
+ *
+ *   patched=0 transition=0: unpatched
+ *   patched=0 transition=1: unpatched, temporary starting state
+ *   patched=1 transition=1: patched, may be visible to some tasks
+ *   patched=1 transition=0: patched, visible to all tasks
+ *
+ * And when unpatching, it goes in the reverse order:
+ *
+ *   patched=1 transition=0: patched, visible to all tasks
+ *   patched=1 transition=1: patched, may be visible to some tasks
+ *   patched=0 transition=1: unpatched, temporary ending state
+ *   patched=0 transition=0: unpatched
  */
 struct klp_func {
 	/* external */
@@ -53,6 +75,7 @@ struct klp_func {
 	 * in kallsyms for the given object is used.
 	 */
 	unsigned long old_sympos;
+	bool immediate;
 
 	/* internal */
 	unsigned long old_addr;
@@ -60,6 +83,7 @@ struct klp_func {
 	struct list_head stack_node;
 	unsigned long old_size, new_size;
 	bool patched;
+	bool transition;
 };
 
 /**
@@ -68,7 +92,7 @@ struct klp_func {
  * @funcs:	function entries for functions to be patched in the object
  * @kobj:	kobject for sysfs resources
  * @mod:	kernel module associated with the patched object
- * 		(NULL for vmlinux)
+ *		(NULL for vmlinux)
  * @patched:	the object's funcs have been added to the klp_ops list
  */
 struct klp_object {
@@ -86,6 +110,7 @@ struct klp_object {
  * struct klp_patch - patch structure for live patching
  * @mod:	reference to the live patch module
  * @objs:	object entries for kernel objects to be patched
+ * @immediate:  patch all funcs immediately, bypassing safety mechanisms
  * @list:	list node for global list of registered patches
  * @kobj:	kobject for sysfs resources
  * @enabled:	the patch is enabled (but operation may be incomplete)
@@ -94,6 +119,7 @@ struct klp_patch {
 	/* external */
 	struct module *mod;
 	struct klp_object *objs;
+	bool immediate;
 
 	/* internal */
 	struct list_head list;
@@ -121,13 +147,27 @@ void arch_klp_init_object_loaded(struct klp_patch *patch,
 int klp_module_coming(struct module *mod);
 void klp_module_going(struct module *mod);
 
+void klp_copy_process(struct task_struct *child);
 void klp_update_patch_state(struct task_struct *task);
 
+static inline bool klp_patch_pending(struct task_struct *task)
+{
+	return test_tsk_thread_flag(task, TIF_PATCH_PENDING);
+}
+
+static inline bool klp_have_reliable_stack(void)
+{
+	return IS_ENABLED(CONFIG_STACKTRACE) &&
+	       IS_ENABLED(CONFIG_HAVE_RELIABLE_STACKTRACE);
+}
+
 #else /* !CONFIG_LIVEPATCH */
 
 static inline int klp_module_coming(struct module *mod) { return 0; }
 static inline void klp_module_going(struct module *mod) {}
+static inline bool klp_patch_pending(struct task_struct *task) { return false; }
 static inline void klp_update_patch_state(struct task_struct *task) {}
+static inline void klp_copy_process(struct task_struct *child) {}
 
 #endif /* CONFIG_LIVEPATCH */
 

commit f5e547f4ac785c65a39211f0b8e4ffc4fe09112d
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Mon Feb 13 19:42:39 2017 -0600

    livepatch: store function sizes
    
    For the consistency model we'll need to know the sizes of the old and
    new functions to determine if they're on the stacks of any tasks.
    
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Miroslav Benes <mbenes@suse.cz>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Reviewed-by: Kamalesh Babulal <kamalesh@linux.vnet.ibm.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index 9787a63b57ac..6602b34bed2b 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -37,6 +37,8 @@
  * @old_addr:	the address of the function being patched
  * @kobj:	kobject for sysfs resources
  * @stack_node:	list node for klp_ops func_stack list
+ * @old_size:	size of the old function
+ * @new_size:	size of the new function
  * @patched:	the func has been added to the klp_ops list
  */
 struct klp_func {
@@ -56,6 +58,7 @@ struct klp_func {
 	unsigned long old_addr;
 	struct kobject kobj;
 	struct list_head stack_node;
+	unsigned long old_size, new_size;
 	bool patched;
 };
 

commit 0dade9f374f1c15f9b43ab01ab75a3b459bba5f6
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Mon Feb 13 19:42:35 2017 -0600

    livepatch: separate enabled and patched states
    
    Once we have a consistency model, patches and their objects will be
    enabled and disabled at different times.  For example, when a patch is
    disabled, its loaded objects' funcs can remain registered with ftrace
    indefinitely until the unpatching operation is complete and they're no
    longer in use.
    
    It's less confusing if we give them different names: patches can be
    enabled or disabled; objects (and their funcs) can be patched or
    unpatched:
    
    - Enabled means that a patch is logically enabled (but not necessarily
      fully applied).
    
    - Patched means that an object's funcs are registered with ftrace and
      added to the klp_ops func stack.
    
    Also, since these states are binary, represent them with booleans
    instead of ints.
    
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Miroslav Benes <mbenes@suse.cz>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Reviewed-by: Kamalesh Babulal <kamalesh@linux.vnet.ibm.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index 5cc20e588a22..9787a63b57ac 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -28,11 +28,6 @@
 
 #include <asm/livepatch.h>
 
-enum klp_state {
-	KLP_DISABLED,
-	KLP_ENABLED
-};
-
 /**
  * struct klp_func - function structure for live patching
  * @old_name:	name of the function to be patched
@@ -41,8 +36,8 @@ enum klp_state {
  *		can be found (optional)
  * @old_addr:	the address of the function being patched
  * @kobj:	kobject for sysfs resources
- * @state:	tracks function-level patch application state
  * @stack_node:	list node for klp_ops func_stack list
+ * @patched:	the func has been added to the klp_ops list
  */
 struct klp_func {
 	/* external */
@@ -60,8 +55,8 @@ struct klp_func {
 	/* internal */
 	unsigned long old_addr;
 	struct kobject kobj;
-	enum klp_state state;
 	struct list_head stack_node;
+	bool patched;
 };
 
 /**
@@ -71,7 +66,7 @@ struct klp_func {
  * @kobj:	kobject for sysfs resources
  * @mod:	kernel module associated with the patched object
  * 		(NULL for vmlinux)
- * @state:	tracks object-level patch application state
+ * @patched:	the object's funcs have been added to the klp_ops list
  */
 struct klp_object {
 	/* external */
@@ -81,7 +76,7 @@ struct klp_object {
 	/* internal */
 	struct kobject kobj;
 	struct module *mod;
-	enum klp_state state;
+	bool patched;
 };
 
 /**
@@ -90,7 +85,7 @@ struct klp_object {
  * @objs:	object entries for kernel objects to be patched
  * @list:	list node for global list of registered patches
  * @kobj:	kobject for sysfs resources
- * @state:	tracks patch-level application state
+ * @enabled:	the patch is enabled (but operation may be incomplete)
  */
 struct klp_patch {
 	/* external */
@@ -100,7 +95,7 @@ struct klp_patch {
 	/* internal */
 	struct list_head list;
 	struct kobject kobj;
-	enum klp_state state;
+	bool enabled;
 };
 
 #define klp_for_each_object(patch, obj) \

commit 46c5a0113f843be5c55b1c40dd486538891156d4
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Mon Feb 13 19:42:30 2017 -0600

    livepatch: create temporary klp_update_patch_state() stub
    
    Create temporary stubs for klp_update_patch_state() so we can add
    TIF_PATCH_PENDING to different architectures in separate patches without
    breaking build bisectability.
    
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index 9072f04db616..5cc20e588a22 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -123,10 +123,13 @@ void arch_klp_init_object_loaded(struct klp_patch *patch,
 int klp_module_coming(struct module *mod);
 void klp_module_going(struct module *mod);
 
+void klp_update_patch_state(struct task_struct *task);
+
 #else /* !CONFIG_LIVEPATCH */
 
 static inline int klp_module_coming(struct module *mod) { return 0; }
-static inline void klp_module_going(struct module *mod) { }
+static inline void klp_module_going(struct module *mod) {}
+static inline void klp_update_patch_state(struct task_struct *task) {}
 
 #endif /* CONFIG_LIVEPATCH */
 

commit 255e732c61dbb6a0bf9e0a3d6bc45f202853c880
Author: Jessica Yu <jeyu@redhat.com>
Date:   Wed Aug 17 20:58:28 2016 -0400

    livepatch: use arch_klp_init_object_loaded() to finish arch-specific tasks
    
    Introduce arch_klp_init_object_loaded() to complete any additional
    arch-specific tasks during patching. Architecture code may override this
    function.
    
    Signed-off-by: Jessica Yu <jeyu@redhat.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Acked-by: Miroslav Benes <mbenes@suse.cz>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index a93a0b23dc8d..9072f04db616 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -116,6 +116,9 @@ int klp_unregister_patch(struct klp_patch *);
 int klp_enable_patch(struct klp_patch *);
 int klp_disable_patch(struct klp_patch *);
 
+void arch_klp_init_object_loaded(struct klp_patch *patch,
+				 struct klp_object *obj);
+
 /* Called from the module loader during module coming/going states */
 int klp_module_coming(struct module *mod);
 void klp_module_going(struct module *mod);

commit be69f70e6395a4ba9c178b2531433547e1955195
Merge: f09d90864eb7 5e4e38446a62 4d4fb97a6210
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Tue May 17 12:06:35 2016 +0200

    Merge branches 'for-4.7/core', 'for-4.7/livepatching-doc' and 'for-4.7/livepatching-ppc64' into for-linus

commit f09d90864eb7cc00cadbbfd083b4eff84c167981
Author: Miroslav Benes <mbenes@suse.cz>
Date:   Thu Apr 28 16:34:08 2016 +0200

    livepatch: make object/func-walking helpers more robust
    
    Current object-walking helper checks the presence of obj->funcs to
    determine the end of objs array in klp_object structure. This is
    somewhat fragile because one can easily forget about funcs definition
    during livepatch creation. In such a case the livepatch module is
    successfully loaded and all objects after the incorrect one are omitted.
    This is very confusing. Let's make the helper more robust and check also
    for the other external member, name. Thus the helper correctly stops on
    an empty item of the array. We need to have a check for obj->funcs in
    klp_init_object() to make it work.
    
    The same applies to a func-walking helper.
    
    As a benefit we'll check for new_func member definition during the
    livepatch initialization. There is no such check anywhere in the code
    now.
    
    [jkosina@suse.cz: fix shortlog]
    Signed-off-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Jessica Yu <jeyu@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index bd830d590465..90843ccb7852 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -124,10 +124,12 @@ struct klp_patch {
 };
 
 #define klp_for_each_object(patch, obj) \
-	for (obj = patch->objs; obj->funcs; obj++)
+	for (obj = patch->objs; obj->funcs || obj->name; obj++)
 
 #define klp_for_each_func(obj, func) \
-	for (func = obj->funcs; func->old_name; func++)
+	for (func = obj->funcs; \
+	     func->old_name || func->new_func || func->old_sympos; \
+	     func++)
 
 int klp_register_patch(struct klp_patch *);
 int klp_unregister_patch(struct klp_patch *);

commit 425595a7fc2096ab46c741b5ed5372c5ab5bbeac
Author: Jessica Yu <jeyu@redhat.com>
Date:   Tue Mar 22 20:03:18 2016 -0400

    livepatch: reuse module loader code to write relocations
    
    Reuse module loader code to write relocations, thereby eliminating the need
    for architecture specific relocation code in livepatch. Specifically, reuse
    the apply_relocate_add() function in the module loader to write relocations
    instead of duplicating functionality in livepatch's arch-dependent
    klp_write_module_reloc() function.
    
    In order to accomplish this, livepatch modules manage their own relocation
    sections (marked with the SHF_RELA_LIVEPATCH section flag) and
    livepatch-specific symbols (marked with SHN_LIVEPATCH symbol section
    index). To apply livepatch relocation sections, livepatch symbols
    referenced by relocs are resolved and then apply_relocate_add() is called
    to apply those relocations.
    
    In addition, remove x86 livepatch relocation code and the s390
    klp_write_module_reloc() function stub. They are no longer needed since
    relocation work has been offloaded to module loader.
    
    Lastly, mark the module as a livepatch module so that the module loader
    canappropriately identify and initialize it.
    
    Signed-off-by: Jessica Yu <jeyu@redhat.com>
    Reviewed-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Heiko Carstens <heiko.carstens@de.ibm.com>   # for s390 changes
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index bd830d590465..0933ca47791c 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -64,28 +64,9 @@ struct klp_func {
 	struct list_head stack_node;
 };
 
-/**
- * struct klp_reloc - relocation structure for live patching
- * @loc:	address where the relocation will be written
- * @sympos:	position in kallsyms to disambiguate symbols (optional)
- * @type:	ELF relocation type
- * @name:	name of the referenced symbol (for lookup/verification)
- * @addend:	offset from the referenced symbol
- * @external:	symbol is either exported or within the live patch module itself
- */
-struct klp_reloc {
-	unsigned long loc;
-	unsigned long sympos;
-	unsigned long type;
-	const char *name;
-	int addend;
-	int external;
-};
-
 /**
  * struct klp_object - kernel object structure for live patching
  * @name:	module name (or NULL for vmlinux)
- * @relocs:	relocation entries to be applied at load time
  * @funcs:	function entries for functions to be patched in the object
  * @kobj:	kobject for sysfs resources
  * @mod:	kernel module associated with the patched object
@@ -95,7 +76,6 @@ struct klp_reloc {
 struct klp_object {
 	/* external */
 	const char *name;
-	struct klp_reloc *relocs;
 	struct klp_func *funcs;
 
 	/* internal */

commit 7e545d6eca20ce8ef7f66a63146cbff82b2ba760
Author: Jessica Yu <jeyu@redhat.com>
Date:   Wed Mar 16 20:55:39 2016 -0400

    livepatch/module: remove livepatch module notifier
    
    Remove the livepatch module notifier in favor of directly enabling and
    disabling patches to modules in the module loader. Hard-coding the
    function calls ensures that ftrace_module_enable() is run before
    klp_module_coming() during module load, and that klp_module_going() is
    run before ftrace_release_mod() during module unload. This way, ftrace
    and livepatch code is run in the correct order during the module
    load/unload sequence without dependence on the module notifier call chain.
    
    Signed-off-by: Jessica Yu <jeyu@redhat.com>
    Reviewed-by: Petr Mladek <pmladek@suse.cz>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Acked-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index c05679701e10..bd830d590465 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -24,6 +24,8 @@
 #include <linux/module.h>
 #include <linux/ftrace.h>
 
+#if IS_ENABLED(CONFIG_LIVEPATCH)
+
 #include <asm/livepatch.h>
 
 enum klp_state {
@@ -132,4 +134,15 @@ int klp_unregister_patch(struct klp_patch *);
 int klp_enable_patch(struct klp_patch *);
 int klp_disable_patch(struct klp_patch *);
 
+/* Called from the module loader during module coming/going states */
+int klp_module_coming(struct module *mod);
+void klp_module_going(struct module *mod);
+
+#else /* !CONFIG_LIVEPATCH */
+
+static inline int klp_module_coming(struct module *mod) { return 0; }
+static inline void klp_module_going(struct module *mod) { }
+
+#endif /* CONFIG_LIVEPATCH */
+
 #endif /* _LINUX_LIVEPATCH_H_ */

commit 335e073faacc9d90bee1527fa2550d6df045df63
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Sun Mar 6 22:20:25 2016 +0100

    klp: remove CONFIG_LIVEPATCH dependency from klp headers
    
    There is no need for livepatch.h (generic and arch-specific) to depend
    on CONFIG_LIVEPATCH. Remove that superfluous dependency.
    
    Reported-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index a8828652f794..c05679701e10 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -24,8 +24,6 @@
 #include <linux/module.h>
 #include <linux/ftrace.h>
 
-#if IS_ENABLED(CONFIG_LIVEPATCH)
-
 #include <asm/livepatch.h>
 
 enum klp_state {
@@ -134,6 +132,4 @@ int klp_unregister_patch(struct klp_patch *);
 int klp_enable_patch(struct klp_patch *);
 int klp_disable_patch(struct klp_patch *);
 
-#endif /* CONFIG_LIVEPATCH */
-
 #endif /* _LINUX_LIVEPATCH_H_ */

commit 064c89df6247cd829a7880cc8a87b7ed2cdfccd8
Author: Chris J Arges <chris.j.arges@canonical.com>
Date:   Tue Dec 1 20:40:55 2015 -0600

    livepatch: add sympos as disambiguator field to klp_reloc
    
    In cases of duplicate symbols, sympos will be used to disambiguate instead
    of val. By default sympos will be 0, and patching will only succeed if
    the symbol is unique. Specifying a positive value will ensure that
    occurrence of the symbol in kallsyms for the patched object will be used
    for patching if it is valid. For external relocations sympos is not
    supported.
    
    Remove klp_verify_callback, klp_verify_args and klp_verify_vmlinux_symbol
    as they are no longer used.
    
    From the klp_reloc structure remove val, as it can be refactored as a
    local variable in klp_write_object_relocations.
    
    Signed-off-by: Chris J Arges <chris.j.arges@canonical.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index b60e8abab0ab..a8828652f794 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -67,8 +67,7 @@ struct klp_func {
 /**
  * struct klp_reloc - relocation structure for live patching
  * @loc:	address where the relocation will be written
- * @val:	address of the referenced symbol (optional,
- *		vmlinux	patches only)
+ * @sympos:	position in kallsyms to disambiguate symbols (optional)
  * @type:	ELF relocation type
  * @name:	name of the referenced symbol (for lookup/verification)
  * @addend:	offset from the referenced symbol
@@ -76,7 +75,7 @@ struct klp_func {
  */
 struct klp_reloc {
 	unsigned long loc;
-	unsigned long val;
+	unsigned long sympos;
 	unsigned long type;
 	const char *name;
 	int addend;

commit b2b018ef48675a9a524fa9791ea7d67fdac405f7
Author: Chris J Arges <chris.j.arges@canonical.com>
Date:   Tue Dec 1 20:40:54 2015 -0600

    livepatch: add old_sympos as disambiguator field to klp_func
    
    Currently, patching objects with duplicate symbol names fail because the
    creation of the sysfs function directory collides with the previous
    attempt. Appending old_addr to the function name is problematic as it
    reveals the address of the function being patch to a normal user. Using
    the symbol's occurrence in kallsyms to postfix the function name in the
    sysfs directory solves the issue of having consistent unique names and
    ensuring that the address is not exposed to a normal user.
    
    In addition, using the symbol position as the user's method to disambiguate
    symbols instead of addr allows for disambiguating symbols in modules as
    well for both function addresses and for relocs. This also simplifies much
    of the code. Special handling for kASLR is no longer needed and can be
    removed. The klp_find_verify_func_addr function can be replaced by
    klp_find_object_symbol, and klp_verify_vmlinux_symbol and its callback can
    be removed completely.
    
    In cases of duplicate symbols, old_sympos will be used to disambiguate
    instead of old_addr. By default old_sympos will be 0, and patching will
    only succeed if the symbol is unique. Specifying a positive value will
    ensure that occurrence of the symbol in kallsyms for the patched object
    will be used for patching if it is valid.
    
    In addition, make old_addr an internal structure field not to be specified
    by the user. Finally, remove klp_find_verify_func_addr as it can be
    replaced by klp_find_object_symbol directly.
    
    Support for symbol position disambiguation for relocations is added in the
    next patch in this series.
    
    Signed-off-by: Chris J Arges <chris.j.arges@canonical.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index 31db7a05dd36..b60e8abab0ab 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -37,8 +37,9 @@ enum klp_state {
  * struct klp_func - function structure for live patching
  * @old_name:	name of the function to be patched
  * @new_func:	pointer to the patched function code
- * @old_addr:	a hint conveying at what address the old function
- *		can be found (optional, vmlinux patches only)
+ * @old_sympos: a hint indicating which symbol position the old function
+ *		can be found (optional)
+ * @old_addr:	the address of the function being patched
  * @kobj:	kobject for sysfs resources
  * @state:	tracks function-level patch application state
  * @stack_node:	list node for klp_ops func_stack list
@@ -48,16 +49,16 @@ struct klp_func {
 	const char *old_name;
 	void *new_func;
 	/*
-	 * The old_addr field is optional and can be used to resolve
-	 * duplicate symbol names in the vmlinux object.  If this
-	 * information is not present, the symbol is located by name
-	 * with kallsyms. If the name is not unique and old_addr is
-	 * not provided, the patch application fails as there is no
-	 * way to resolve the ambiguity.
+	 * The old_sympos field is optional and can be used to resolve
+	 * duplicate symbol names in livepatch objects. If this field is zero,
+	 * it is expected the symbol is unique, otherwise patching fails. If
+	 * this value is greater than zero then that occurrence of the symbol
+	 * in kallsyms for the given object is used.
 	 */
-	unsigned long old_addr;
+	unsigned long old_sympos;
 
 	/* internal */
+	unsigned long old_addr;
 	struct kobject kobj;
 	enum klp_state state;
 	struct list_head stack_node;

commit 8cdd043ab32c2ff28d2a77c514a768a9edce244c
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Tue May 19 12:01:19 2015 +0200

    livepatch: introduce patch/func-walking helpers
    
    klp_for_each_object and klp_for_each_func are now used all over the
    code. One need not think what is the proper condition to check in the
    for loop now.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index fe45f2f02c8d..31db7a05dd36 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -123,6 +123,12 @@ struct klp_patch {
 	enum klp_state state;
 };
 
+#define klp_for_each_object(patch, obj) \
+	for (obj = patch->objs; obj->funcs; obj++)
+
+#define klp_for_each_func(obj, func) \
+	for (func = obj->funcs; func->old_name; func++)
+
 int klp_register_patch(struct klp_patch *);
 int klp_unregister_patch(struct klp_patch *);
 int klp_enable_patch(struct klp_patch *);

commit cad706df7e4a00a595f2662f32c0fc174aa4e61f
Author: Miroslav Benes <mbenes@suse.cz>
Date:   Tue May 19 12:01:18 2015 +0200

    livepatch: make kobject in klp_object statically allocated
    
    Make kobj variable (of type struct kobject) statically allocated in
    klp_object structure. It will allow us to move in the func-object-patch
    hierarchy through kobject links.
    
    The only reason to have it dynamic was to not have empty release
    callback in the code. However we have empty callbacks for function and
    patch in the code now, so it is no longer valid and the advantage of
    static allocation is clear.
    
    Signed-off-by: Miroslav Benes <mbenes@suse.cz>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index ee6dbb39a809..fe45f2f02c8d 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -99,7 +99,7 @@ struct klp_object {
 	struct klp_func *funcs;
 
 	/* internal */
-	struct kobject *kobj;
+	struct kobject kobj;
 	struct module *mod;
 	enum klp_state state;
 };

commit 4421f8f0fa02bc982b410cd773223cc280791c54
Author: Miroslav Benes <mbenes@suse.cz>
Date:   Wed Feb 18 15:21:07 2015 +0100

    livepatch: remove extern specifier from header files
    
    Storage-class specifier 'extern' is redundant in front of the function
    declaration. According to the C specification it has the same meaning as
    if not present at all. So remove it.
    
    Signed-off-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Reviewed-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index 95023fd8b00d..ee6dbb39a809 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -123,10 +123,10 @@ struct klp_patch {
 	enum klp_state state;
 };
 
-extern int klp_register_patch(struct klp_patch *);
-extern int klp_unregister_patch(struct klp_patch *);
-extern int klp_enable_patch(struct klp_patch *);
-extern int klp_disable_patch(struct klp_patch *);
+int klp_register_patch(struct klp_patch *);
+int klp_unregister_patch(struct klp_patch *);
+int klp_enable_patch(struct klp_patch *);
+int klp_disable_patch(struct klp_patch *);
 
 #endif /* CONFIG_LIVEPATCH */
 

commit 12cf89b550d13eb7cb86ef182bd6c04345a33a1f
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Tue Feb 3 16:45:18 2015 -0600

    livepatch: rename config to CONFIG_LIVEPATCH
    
    Rename CONFIG_LIVE_PATCHING to CONFIG_LIVEPATCH to make the naming of
    the config and the code more consistent.
    
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Reviewed-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index f14c6fb262b4..95023fd8b00d 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -24,7 +24,7 @@
 #include <linux/module.h>
 #include <linux/ftrace.h>
 
-#if IS_ENABLED(CONFIG_LIVE_PATCHING)
+#if IS_ENABLED(CONFIG_LIVEPATCH)
 
 #include <asm/livepatch.h>
 
@@ -128,6 +128,6 @@ extern int klp_unregister_patch(struct klp_patch *);
 extern int klp_enable_patch(struct klp_patch *);
 extern int klp_disable_patch(struct klp_patch *);
 
-#endif /* CONFIG_LIVE_PATCHING */
+#endif /* CONFIG_LIVEPATCH */
 
 #endif /* _LINUX_LIVEPATCH_H_ */

commit 3c33f5b99d688deafd21d4a770303691c7c3a320
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Tue Jan 20 09:26:19 2015 -0600

    livepatch: support for repatching a function
    
    Add support for patching a function multiple times.  If multiple patches
    affect a function, the function in the most recently enabled patch
    "wins".  This enables a cumulative patch upgrade path, where each patch
    is a superset of previous patches.
    
    This requires restructuring the data a little bit.  With the current
    design, where each klp_func struct has its own ftrace_ops, we'd have to
    unregister the old ops and then register the new ops, because
    FTRACE_OPS_FL_IPMODIFY prevents us from having two ops registered for
    the same function at the same time.  That would leave a regression
    window where the function isn't patched at all (not good for a patch
    upgrade path).
    
    This patch replaces the per-klp_func ftrace_ops with a global klp_ops
    list, with one ftrace_ops per original function.  A single ftrace_ops is
    shared between all klp_funcs which have the same old_addr.  This allows
    the switch between function versions to happen instantaneously by
    updating the klp_ops struct's func_stack list.  The winner is the
    klp_func at the top of the func_stack (front of the list).
    
    [ jkosina@suse.cz: turn WARN_ON() into WARN_ON_ONCE() in ftrace handler to
      avoid storm in pathological cases ]
    
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Reviewed-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
index 950bc615842f..f14c6fb262b4 100644
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -40,8 +40,8 @@ enum klp_state {
  * @old_addr:	a hint conveying at what address the old function
  *		can be found (optional, vmlinux patches only)
  * @kobj:	kobject for sysfs resources
- * @fops:	ftrace operations structure
  * @state:	tracks function-level patch application state
+ * @stack_node:	list node for klp_ops func_stack list
  */
 struct klp_func {
 	/* external */
@@ -59,8 +59,8 @@ struct klp_func {
 
 	/* internal */
 	struct kobject kobj;
-	struct ftrace_ops *fops;
 	enum klp_state state;
+	struct list_head stack_node;
 };
 
 /**

commit b700e7f03df5d92f85fa5247fe1f557528d3363d
Author: Seth Jennings <sjenning@redhat.com>
Date:   Tue Dec 16 11:58:19 2014 -0600

    livepatch: kernel: add support for live patching
    
    This commit introduces code for the live patching core.  It implements
    an ftrace-based mechanism and kernel interface for doing live patching
    of kernel and kernel module functions.
    
    It represents the greatest common functionality set between kpatch and
    kgraft and can accept patches built using either method.
    
    This first version does not implement any consistency mechanism that
    ensures that old and new code do not run together.  In practice, ~90% of
    CVEs are safe to apply in this way, since they simply add a conditional
    check.  However, any function change that can not execute safely with
    the old version of the function can _not_ be safely applied in this
    version.
    
    [ jkosina@suse.cz: due to the number of contributions that got folded into
      this original patch from Seth Jennings, add SUSE's copyright as well, as
      discussed via e-mail ]
    
    Signed-off-by: Seth Jennings <sjenning@redhat.com>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Reviewed-by: Miroslav Benes <mbenes@suse.cz>
    Reviewed-by: Petr Mladek <pmladek@suse.cz>
    Reviewed-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Signed-off-by: Miroslav Benes <mbenes@suse.cz>
    Signed-off-by: Petr Mladek <pmladek@suse.cz>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
new file mode 100644
index 000000000000..950bc615842f
--- /dev/null
+++ b/include/linux/livepatch.h
@@ -0,0 +1,133 @@
+/*
+ * livepatch.h - Kernel Live Patching Core
+ *
+ * Copyright (C) 2014 Seth Jennings <sjenning@redhat.com>
+ * Copyright (C) 2014 SUSE
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _LINUX_LIVEPATCH_H_
+#define _LINUX_LIVEPATCH_H_
+
+#include <linux/module.h>
+#include <linux/ftrace.h>
+
+#if IS_ENABLED(CONFIG_LIVE_PATCHING)
+
+#include <asm/livepatch.h>
+
+enum klp_state {
+	KLP_DISABLED,
+	KLP_ENABLED
+};
+
+/**
+ * struct klp_func - function structure for live patching
+ * @old_name:	name of the function to be patched
+ * @new_func:	pointer to the patched function code
+ * @old_addr:	a hint conveying at what address the old function
+ *		can be found (optional, vmlinux patches only)
+ * @kobj:	kobject for sysfs resources
+ * @fops:	ftrace operations structure
+ * @state:	tracks function-level patch application state
+ */
+struct klp_func {
+	/* external */
+	const char *old_name;
+	void *new_func;
+	/*
+	 * The old_addr field is optional and can be used to resolve
+	 * duplicate symbol names in the vmlinux object.  If this
+	 * information is not present, the symbol is located by name
+	 * with kallsyms. If the name is not unique and old_addr is
+	 * not provided, the patch application fails as there is no
+	 * way to resolve the ambiguity.
+	 */
+	unsigned long old_addr;
+
+	/* internal */
+	struct kobject kobj;
+	struct ftrace_ops *fops;
+	enum klp_state state;
+};
+
+/**
+ * struct klp_reloc - relocation structure for live patching
+ * @loc:	address where the relocation will be written
+ * @val:	address of the referenced symbol (optional,
+ *		vmlinux	patches only)
+ * @type:	ELF relocation type
+ * @name:	name of the referenced symbol (for lookup/verification)
+ * @addend:	offset from the referenced symbol
+ * @external:	symbol is either exported or within the live patch module itself
+ */
+struct klp_reloc {
+	unsigned long loc;
+	unsigned long val;
+	unsigned long type;
+	const char *name;
+	int addend;
+	int external;
+};
+
+/**
+ * struct klp_object - kernel object structure for live patching
+ * @name:	module name (or NULL for vmlinux)
+ * @relocs:	relocation entries to be applied at load time
+ * @funcs:	function entries for functions to be patched in the object
+ * @kobj:	kobject for sysfs resources
+ * @mod:	kernel module associated with the patched object
+ * 		(NULL for vmlinux)
+ * @state:	tracks object-level patch application state
+ */
+struct klp_object {
+	/* external */
+	const char *name;
+	struct klp_reloc *relocs;
+	struct klp_func *funcs;
+
+	/* internal */
+	struct kobject *kobj;
+	struct module *mod;
+	enum klp_state state;
+};
+
+/**
+ * struct klp_patch - patch structure for live patching
+ * @mod:	reference to the live patch module
+ * @objs:	object entries for kernel objects to be patched
+ * @list:	list node for global list of registered patches
+ * @kobj:	kobject for sysfs resources
+ * @state:	tracks patch-level application state
+ */
+struct klp_patch {
+	/* external */
+	struct module *mod;
+	struct klp_object *objs;
+
+	/* internal */
+	struct list_head list;
+	struct kobject kobj;
+	enum klp_state state;
+};
+
+extern int klp_register_patch(struct klp_patch *);
+extern int klp_unregister_patch(struct klp_patch *);
+extern int klp_enable_patch(struct klp_patch *);
+extern int klp_disable_patch(struct klp_patch *);
+
+#endif /* CONFIG_LIVE_PATCHING */
+
+#endif /* _LINUX_LIVEPATCH_H_ */
