commit 32927393dc1ccd60fb2bdc05b9e8e88753761469
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Apr 24 08:43:38 2020 +0200

    sysctl: pass kernel pointers to ->proc_handler
    
    Instead of having all the sysctl handlers deal with user pointers, which
    is rather hairy in terms of the BPF interaction, copy the input to and
    from  userspace in common code.  This also means that the strings are
    always NUL-terminated by the common code, making the API a little bit
    safer.
    
    As most handler just pass through the data to one of the common handlers
    a lot of the changes are mechnical.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Andrey Ignatov <rdna@fb.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 9003e29cde46..750c7f395ca9 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -202,16 +202,11 @@ static inline void watchdog_update_hrtimer_threshold(u64 period) { }
 #endif
 
 struct ctl_table;
-extern int proc_watchdog(struct ctl_table *, int ,
-			 void __user *, size_t *, loff_t *);
-extern int proc_nmi_watchdog(struct ctl_table *, int ,
-			     void __user *, size_t *, loff_t *);
-extern int proc_soft_watchdog(struct ctl_table *, int ,
-			      void __user *, size_t *, loff_t *);
-extern int proc_watchdog_thresh(struct ctl_table *, int ,
-				void __user *, size_t *, loff_t *);
-extern int proc_watchdog_cpumask(struct ctl_table *, int,
-				 void __user *, size_t *, loff_t *);
+int proc_watchdog(struct ctl_table *, int, void *, size_t *, loff_t *);
+int proc_nmi_watchdog(struct ctl_table *, int , void *, size_t *, loff_t *);
+int proc_soft_watchdog(struct ctl_table *, int , void *, size_t *, loff_t *);
+int proc_watchdog_thresh(struct ctl_table *, int , void *, size_t *, loff_t *);
+int proc_watchdog_cpumask(struct ctl_table *, int, void *, size_t *, loff_t *);
 
 #ifdef CONFIG_HAVE_ACPI_APEI_NMI
 #include <asm/nmi.h>

commit 81bd415c91eb966118d773dddf254aebf3022411
Author: Mathieu Malaterre <malat@debian.org>
Date:   Wed Jun 6 21:42:32 2018 +0200

    watchdog/core: Add missing prototypes for weak functions
    
    The split out of the hard lockup detector exposed two new weak functions,
    but no prototypes for them, which triggers the build warning:
    
      kernel/watchdog.c:109:12: warning: no previous prototype for ‘watchdog_nmi_enable’ [-Wmissing-prototypes]
      kernel/watchdog.c:115:13: warning: no previous prototype for ‘watchdog_nmi_disable’ [-Wmissing-prototypes]
    
    Add the prototypes.
    
    Fixes: 73ce0511c436 ("kernel/watchdog.c: move hardlockup detector to separate file")
    Signed-off-by: Mathieu Malaterre <malat@debian.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Babu Moger <babu.moger@oracle.com>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20180606194232.17653-1-malat@debian.org

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 08f9247e9827..9003e29cde46 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -119,6 +119,8 @@ static inline int hardlockup_detector_perf_init(void) { return 0; }
 void watchdog_nmi_stop(void);
 void watchdog_nmi_start(void);
 int watchdog_nmi_probe(void);
+int watchdog_nmi_enable(unsigned int cpu);
+void watchdog_nmi_disable(unsigned int cpu);
 
 /**
  * touch_nmi_watchdog - restart NMI watchdog timeout.

commit aef92a8bed25d03b8f03ce499a56e8e8e5e2c05e
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Tue Jul 10 13:42:10 2018 +0200

    watchdog/softlockup: Fix the SOFTLOCKUP_DETECTOR=n build
    
    I got confused by all the various CONFIG options here about and
    conflated CONFIG_LOCKUP_DETECTOR and CONFIG_SOFTLOCKUP_DETECTOR.
    
    This results in a build failure for:
    
       CONFIG_LOCKUP_DETECTOR=y && CONFIG_SOFTLOCKUP_DETECTOR=n
    
    As reported by Abdul.
    
    Reported-and-tested-by: Abdul Haleem <abdhalee@linux.vnet.ibm.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-next <linux-next@vger.kernel.org>
    Cc: linuxppc-dev <linuxppc-dev@lists.ozlabs.org>
    Cc: mpe <mpe@ellerman.id.au>
    Cc: sachinp <sachinp@linux.vnet.ibm.com>
    Cc: stephen Rothwell <sfr@canb.auug.org.au>
    Fixes: 9cf57731b63e ("watchdog/softlockup: Replace "watchdog/%u" threads with cpu_stop_work")
    Link: http://lkml.kernel.org/r/20180710114210.GI2476@hirez.programming.kicks-ass.net
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 80664bbeca43..08f9247e9827 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -33,15 +33,10 @@ extern int sysctl_hardlockup_all_cpu_backtrace;
 #define sysctl_hardlockup_all_cpu_backtrace 0
 #endif /* !CONFIG_SMP */
 
-extern int lockup_detector_online_cpu(unsigned int cpu);
-extern int lockup_detector_offline_cpu(unsigned int cpu);
-
 #else /* CONFIG_LOCKUP_DETECTOR */
 static inline void lockup_detector_init(void) { }
 static inline void lockup_detector_soft_poweroff(void) { }
 static inline void lockup_detector_cleanup(void) { }
-#define lockup_detector_online_cpu	NULL
-#define lockup_detector_offline_cpu	NULL
 #endif /* !CONFIG_LOCKUP_DETECTOR */
 
 #ifdef CONFIG_SOFTLOCKUP_DETECTOR
@@ -50,12 +45,18 @@ extern void touch_softlockup_watchdog(void);
 extern void touch_softlockup_watchdog_sync(void);
 extern void touch_all_softlockup_watchdogs(void);
 extern unsigned int  softlockup_panic;
-#else
+
+extern int lockup_detector_online_cpu(unsigned int cpu);
+extern int lockup_detector_offline_cpu(unsigned int cpu);
+#else /* CONFIG_SOFTLOCKUP_DETECTOR */
 static inline void touch_softlockup_watchdog_sched(void) { }
 static inline void touch_softlockup_watchdog(void) { }
 static inline void touch_softlockup_watchdog_sync(void) { }
 static inline void touch_all_softlockup_watchdogs(void) { }
-#endif
+
+#define lockup_detector_online_cpu	NULL
+#define lockup_detector_offline_cpu	NULL
+#endif /* CONFIG_SOFTLOCKUP_DETECTOR */
 
 #ifdef CONFIG_DETECT_HUNG_TASK
 void reset_hung_task_detector(void);

commit 9cf57731b63e37ed995b46690adc604891a9a28f
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Thu Jun 7 10:52:03 2018 +0200

    watchdog/softlockup: Replace "watchdog/%u" threads with cpu_stop_work
    
    Oleg suggested to replace the "watchdog/%u" threads with
    cpu_stop_work. That removes one thread per CPU while at the same time
    fixes softlockup vs SCHED_DEADLINE.
    
    But more importantly, it does away with the single
    smpboot_update_cpumask_percpu_thread() user, which allows
    cleanups/shrinkage of the smpboot interface.
    
    Suggested-by: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index b8d868d23e79..80664bbeca43 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -33,10 +33,15 @@ extern int sysctl_hardlockup_all_cpu_backtrace;
 #define sysctl_hardlockup_all_cpu_backtrace 0
 #endif /* !CONFIG_SMP */
 
+extern int lockup_detector_online_cpu(unsigned int cpu);
+extern int lockup_detector_offline_cpu(unsigned int cpu);
+
 #else /* CONFIG_LOCKUP_DETECTOR */
 static inline void lockup_detector_init(void) { }
 static inline void lockup_detector_soft_poweroff(void) { }
 static inline void lockup_detector_cleanup(void) { }
+#define lockup_detector_online_cpu	NULL
+#define lockup_detector_offline_cpu	NULL
 #endif /* !CONFIG_LOCKUP_DETECTOR */
 
 #ifdef CONFIG_SOFTLOCKUP_DETECTOR

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 27e249ed7c5c..b8d868d23e79 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  *  linux/include/linux/nmi.h
  */

commit 34ddaa3e5c0096fef52485186c7eb6cf56ddc686
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Oct 3 16:39:02 2017 +0200

    powerpc/watchdog: Make use of watchdog_nmi_probe()
    
    The rework of the core hotplug code triggers the WARN_ON in start_wd_cpu()
    on powerpc because it is called multiple times for the boot CPU.
    
    The first call is via:
    
      start_wd_on_cpu+0x80/0x2f0
      watchdog_nmi_reconfigure+0x124/0x170
      softlockup_reconfigure_threads+0x110/0x130
      lockup_detector_init+0xbc/0xe0
      kernel_init_freeable+0x18c/0x37c
      kernel_init+0x2c/0x160
      ret_from_kernel_thread+0x5c/0xbc
    
    And then again via the CPU hotplug registration:
    
      start_wd_on_cpu+0x80/0x2f0
      cpuhp_invoke_callback+0x194/0x620
      cpuhp_thread_fun+0x7c/0x1b0
      smpboot_thread_fn+0x290/0x2a0
      kthread+0x168/0x1b0
      ret_from_kernel_thread+0x5c/0xbc
    
    This can be avoided by setting up the cpu hotplug state with nocalls and
    move the initialization to the watchdog_nmi_probe() function. That
    initializes the hotplug callbacks without invoking the callback and the
    following core initialization function then configures the watchdog for the
    online CPUs (in this case CPU0) via softlockup_reconfigure_threads().
    
    Reported-and-tested-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Cc: linuxppc-dev@lists.ozlabs.org

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 0c9ed49fb21a..27e249ed7c5c 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -111,6 +111,7 @@ static inline int hardlockup_detector_perf_init(void) { return 0; }
 
 void watchdog_nmi_stop(void);
 void watchdog_nmi_start(void);
+int watchdog_nmi_probe(void);
 
 /**
  * touch_nmi_watchdog - restart NMI watchdog timeout.

commit 6b9dc4806b28214a4a260517e59439e0ac12a15e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Oct 2 12:34:50 2017 +0200

    watchdog/core, powerpc: Replace watchdog_nmi_reconfigure()
    
    The recent cleanup of the watchdog code split watchdog_nmi_reconfigure()
    into two stages. One to stop the NMI and one to restart it after
    reconfiguration. That was done by adding a boolean 'run' argument to the
    code, which is functionally correct but not necessarily a piece of art.
    
    Replace it by two explicit functions: watchdog_nmi_stop() and
    watchdog_nmi_start().
    
    Fixes: 6592ad2fcc8f ("watchdog/core, powerpc: Make watchdog_nmi_reconfigure() two stage")
    Requested-by: Linus 'Nursing his pet-peeve' Torvalds <torvalds@linuxfoundation.org>
    Signed-off-by: Thomas 'Mopping up garbage' Gleixner <tglx@linutronix.de>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Cc: linuxppc-dev@lists.ozlabs.org
    Link: http://lkml.kernel.org/r/alpine.DEB.2.20.1710021957480.2114@nanos

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 89ba8b23c6fe..0c9ed49fb21a 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -109,7 +109,8 @@ static inline int hardlockup_detector_perf_init(void) { return 0; }
 # endif
 #endif
 
-void watchdog_nmi_reconfigure(bool run);
+void watchdog_nmi_stop(void);
+void watchdog_nmi_start(void);
 
 /**
  * touch_nmi_watchdog - restart NMI watchdog timeout.

commit 2a1b8ee4f5665b4291e43e4a25d964c3eb2f4c32
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 12 21:37:20 2017 +0200

    watchdog/hardlockup/perf: Implement CPU enable replacement
    
    watchdog_nmi_enable() is an unparseable mess, Provide a clean perf specific
    implementation, which will be used when the existing setup/teardown mess is
    replaced.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Don Zickus <dzickus@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sebastian Siewior <bigeasy@linutronix.de>
    Cc: Ulrich Obergfell <uobergfe@redhat.com>
    Link: http://lkml.kernel.org/r/20170912194148.180215498@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 72c62a809e92..89ba8b23c6fe 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -92,12 +92,14 @@ extern void arch_touch_nmi_watchdog(void);
 extern void hardlockup_detector_perf_stop(void);
 extern void hardlockup_detector_perf_restart(void);
 extern void hardlockup_detector_perf_disable(void);
+extern void hardlockup_detector_perf_enable(void);
 extern void hardlockup_detector_perf_cleanup(void);
 extern int hardlockup_detector_perf_init(void);
 #else
 static inline void hardlockup_detector_perf_stop(void) { }
 static inline void hardlockup_detector_perf_restart(void) { }
 static inline void hardlockup_detector_perf_disable(void) { }
+static inline void hardlockup_detector_perf_enable(void) { }
 static inline void hardlockup_detector_perf_cleanup(void) { }
 # if !defined(CONFIG_HAVE_NMI_WATCHDOG)
 static inline int hardlockup_detector_perf_init(void) { return -ENODEV; }

commit 178b9f7a36d2c74a38274b66dd89f53611298a19
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 12 21:37:18 2017 +0200

    watchdog/hardlockup/perf: Implement init time perf validation
    
    The watchdog tries to create perf events even after it figured out that
    perf is not functional or the requested event is not supported.
    
    That's braindead as this can be done once at init time and if not supported
    the NMI watchdog can be turned off unconditonally.
    
    Implement the perf hardlockup detector functionality for that. This creates
    a new event create function, which will replace the unholy mess of the
    existing one in later patches.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Don Zickus <dzickus@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sebastian Siewior <bigeasy@linutronix.de>
    Cc: Ulrich Obergfell <uobergfe@redhat.com>
    Link: http://lkml.kernel.org/r/20170912194148.019090547@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index eee255bc0fd6..72c62a809e92 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -93,14 +93,18 @@ extern void hardlockup_detector_perf_stop(void);
 extern void hardlockup_detector_perf_restart(void);
 extern void hardlockup_detector_perf_disable(void);
 extern void hardlockup_detector_perf_cleanup(void);
+extern int hardlockup_detector_perf_init(void);
 #else
 static inline void hardlockup_detector_perf_stop(void) { }
 static inline void hardlockup_detector_perf_restart(void) { }
 static inline void hardlockup_detector_perf_disable(void) { }
 static inline void hardlockup_detector_perf_cleanup(void) { }
-#if !defined(CONFIG_HAVE_NMI_WATCHDOG)
+# if !defined(CONFIG_HAVE_NMI_WATCHDOG)
+static inline int hardlockup_detector_perf_init(void) { return -ENODEV; }
 static inline void arch_touch_nmi_watchdog(void) {}
-#endif
+# else
+static inline int hardlockup_detector_perf_init(void) { return 0; }
+# endif
 #endif
 
 void watchdog_nmi_reconfigure(bool run);

commit 6592ad2fcc8f15b4f99b36c1db7d9f65510c203b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 12 21:37:16 2017 +0200

    watchdog/core, powerpc: Make watchdog_nmi_reconfigure() two stage
    
    Both the perf reconfiguration and the powerpc watchdog_nmi_reconfigure()
    need to be done in two steps.
    
         1) Stop all NMIs
         2) Read the new parameters and start NMIs
    
    Right now watchdog_nmi_reconfigure() is a combination of both. To allow a
    clean reconfiguration add a 'run' argument and split the functionality in
    powerpc.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Don Zickus <dzickus@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sebastian Siewior <bigeasy@linutronix.de>
    Cc: Ulrich Obergfell <uobergfe@redhat.com>
    Cc: linuxppc-dev@lists.ozlabs.org
    Link: http://lkml.kernel.org/r/20170912194147.862865570@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 4a8d1037364e..eee255bc0fd6 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -103,6 +103,8 @@ static inline void arch_touch_nmi_watchdog(void) {}
 #endif
 #endif
 
+void watchdog_nmi_reconfigure(bool run);
+
 /**
  * touch_nmi_watchdog - restart NMI watchdog timeout.
  *

commit 7feeb9cd4f5b34476ffb9e6d58d58c5416375b19
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 12 21:37:15 2017 +0200

    watchdog/sysctl: Clean up sysctl variable name space
    
    Reflect that these variables are user interface related and remove the
    whitespace damage in the sysctl table while at it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Don Zickus <dzickus@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sebastian Siewior <bigeasy@linutronix.de>
    Cc: Ulrich Obergfell <uobergfe@redhat.com>
    Link: http://lkml.kernel.org/r/20170912194147.783210221@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 5774b443dba1..4a8d1037364e 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -17,8 +17,8 @@ void lockup_detector_cleanup(void);
 bool is_hardlockup(void);
 
 extern int watchdog_user_enabled;
-extern int nmi_watchdog_enabled;
-extern int soft_watchdog_enabled;
+extern int nmi_watchdog_user_enabled;
+extern int soft_watchdog_user_enabled;
 extern int watchdog_thresh;
 extern unsigned long watchdog_enabled;
 
@@ -62,12 +62,12 @@ static inline void reset_hung_task_detector(void) { }
  * 'watchdog_enabled' variable. Each lockup detector has its dedicated bit -
  * bit 0 for the hard lockup detector and bit 1 for the soft lockup detector.
  *
- * 'watchdog_user_enabled', 'nmi_watchdog_enabled' and 'soft_watchdog_enabled'
- * are variables that are only used as an 'interface' between the parameters
- * in /proc/sys/kernel and the internal state bits in 'watchdog_enabled'. The
- * 'watchdog_thresh' variable is handled differently because its value is not
- * boolean, and the lockup detectors are 'suspended' while 'watchdog_thresh'
- * is equal zero.
+ * 'watchdog_user_enabled', 'nmi_watchdog_user_enabled' and
+ * 'soft_watchdog_user_enabled' are variables that are only used as an
+ * 'interface' between the parameters in /proc/sys/kernel and the internal
+ * state bits in 'watchdog_enabled'. The 'watchdog_thresh' variable is
+ * handled differently because its value is not boolean, and the lockup
+ * detectors are 'suspended' while 'watchdog_thresh' is equal zero.
  */
 #define NMI_WATCHDOG_ENABLED_BIT   0
 #define SOFT_WATCHDOG_ENABLED_BIT  1

commit 51d4052b01ca555e0d1d5fe297b309beb6c64aa0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 12 21:37:14 2017 +0200

    watchdog/sysctl: Get rid of the #ifdeffery
    
    The sysctl of the nmi_watchdog file prevents writes by setting:
    
        min = max = 0
    
    if none of the users is enabled. That involves ifdeffery and is competely
    non obvious.
    
    If none of the facilities is enabeld, then the file can simply be made read
    only. Move the ifdeffery into the header and use a constant for file
    permissions.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Don Zickus <dzickus@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sebastian Siewior <bigeasy@linutronix.de>
    Cc: Ulrich Obergfell <uobergfe@redhat.com>
    Link: http://lkml.kernel.org/r/20170912194147.706073616@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index cfebb3bc4eed..5774b443dba1 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -81,6 +81,12 @@ extern unsigned int hardlockup_panic;
 static inline void hardlockup_detector_disable(void) {}
 #endif
 
+#if defined(CONFIG_HAVE_NMI_WATCHDOG) || defined(CONFIG_HARDLOCKUP_DETECTOR)
+# define NMI_WATCHDOG_SYSCTL_PERM	0644
+#else
+# define NMI_WATCHDOG_SYSCTL_PERM	0444
+#endif
+
 #if defined(CONFIG_HARDLOCKUP_DETECTOR_PERF)
 extern void arch_touch_nmi_watchdog(void);
 extern void hardlockup_detector_perf_stop(void);

commit 3b371b5936e7777c819619c00ca60f196a8e13fa
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 12 21:37:13 2017 +0200

    watchdog/core: Clean up header mess
    
    Having the same #ifdef in various places does not make it more
    readable. Collect stuff into one place.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Don Zickus <dzickus@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sebastian Siewior <bigeasy@linutronix.de>
    Cc: Ulrich Obergfell <uobergfe@redhat.com>
    Link: http://lkml.kernel.org/r/20170912194147.627096864@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 91a3a4a4c8ae..cfebb3bc4eed 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -14,11 +14,29 @@
 void lockup_detector_init(void);
 void lockup_detector_soft_poweroff(void);
 void lockup_detector_cleanup(void);
+bool is_hardlockup(void);
+
+extern int watchdog_user_enabled;
+extern int nmi_watchdog_enabled;
+extern int soft_watchdog_enabled;
+extern int watchdog_thresh;
+extern unsigned long watchdog_enabled;
+
+extern struct cpumask watchdog_cpumask;
+extern unsigned long *watchdog_cpumask_bits;
+#ifdef CONFIG_SMP
+extern int sysctl_softlockup_all_cpu_backtrace;
+extern int sysctl_hardlockup_all_cpu_backtrace;
 #else
+#define sysctl_softlockup_all_cpu_backtrace 0
+#define sysctl_hardlockup_all_cpu_backtrace 0
+#endif /* !CONFIG_SMP */
+
+#else /* CONFIG_LOCKUP_DETECTOR */
 static inline void lockup_detector_init(void) { }
 static inline void lockup_detector_soft_poweroff(void) { }
 static inline void lockup_detector_cleanup(void) { }
-#endif
+#endif /* !CONFIG_LOCKUP_DETECTOR */
 
 #ifdef CONFIG_SOFTLOCKUP_DETECTOR
 extern void touch_softlockup_watchdog_sched(void);
@@ -26,28 +44,17 @@ extern void touch_softlockup_watchdog(void);
 extern void touch_softlockup_watchdog_sync(void);
 extern void touch_all_softlockup_watchdogs(void);
 extern unsigned int  softlockup_panic;
-extern int soft_watchdog_enabled;
 #else
-static inline void touch_softlockup_watchdog_sched(void)
-{
-}
-static inline void touch_softlockup_watchdog(void)
-{
-}
-static inline void touch_softlockup_watchdog_sync(void)
-{
-}
-static inline void touch_all_softlockup_watchdogs(void)
-{
-}
+static inline void touch_softlockup_watchdog_sched(void) { }
+static inline void touch_softlockup_watchdog(void) { }
+static inline void touch_softlockup_watchdog_sync(void) { }
+static inline void touch_all_softlockup_watchdogs(void) { }
 #endif
 
 #ifdef CONFIG_DETECT_HUNG_TASK
 void reset_hung_task_detector(void);
 #else
-static inline void reset_hung_task_detector(void)
-{
-}
+static inline void reset_hung_task_detector(void) { }
 #endif
 
 /*
@@ -92,7 +99,7 @@ static inline void arch_touch_nmi_watchdog(void) {}
 
 /**
  * touch_nmi_watchdog - restart NMI watchdog timeout.
- * 
+ *
  * If the architecture supports the NMI watchdog, touch_nmi_watchdog()
  * may be used to reset the timeout - for code which intentionally
  * disables interrupts for a long time. This call is stateless.
@@ -162,21 +169,6 @@ static inline bool trigger_single_cpu_backtrace(int cpu)
 u64 hw_nmi_get_sample_period(int watchdog_thresh);
 #endif
 
-#ifdef CONFIG_LOCKUP_DETECTOR
-extern int nmi_watchdog_enabled;
-extern int watchdog_user_enabled;
-extern int watchdog_thresh;
-extern unsigned long watchdog_enabled;
-extern struct cpumask watchdog_cpumask;
-extern unsigned long *watchdog_cpumask_bits;
-#ifdef CONFIG_SMP
-extern int sysctl_softlockup_all_cpu_backtrace;
-extern int sysctl_hardlockup_all_cpu_backtrace;
-#else
-#define sysctl_softlockup_all_cpu_backtrace 0
-#define sysctl_hardlockup_all_cpu_backtrace 0
-#endif
-
 #if defined(CONFIG_HARDLOCKUP_CHECK_TIMESTAMP) && \
     defined(CONFIG_HARDLOCKUP_DETECTOR)
 void watchdog_update_hrtimer_threshold(u64 period);
@@ -184,7 +176,6 @@ void watchdog_update_hrtimer_threshold(u64 period);
 static inline void watchdog_update_hrtimer_threshold(u64 period) { }
 #endif
 
-extern bool is_hardlockup(void);
 struct ctl_table;
 extern int proc_watchdog(struct ctl_table *, int ,
 			 void __user *, size_t *, loff_t *);
@@ -196,7 +187,6 @@ extern int proc_watchdog_thresh(struct ctl_table *, int ,
 				void __user *, size_t *, loff_t *);
 extern int proc_watchdog_cpumask(struct ctl_table *, int,
 				 void __user *, size_t *, loff_t *);
-#endif
 
 #ifdef CONFIG_HAVE_ACPI_APEI_NMI
 #include <asm/nmi.h>

commit 01f0a02701cbcf32d22cfc9d1ab9a3f0ff2ba68c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 12 21:37:05 2017 +0200

    watchdog/core: Remove the park_in_progress obfuscation
    
    Commit:
    
      b94f51183b06 ("kernel/watchdog: prevent false hardlockup on overloaded system")
    
    tries to fix the following issue:
    
    proc_write()
       set_sample_period()    <--- New sample period becoms visible
                              <----- Broken starts
       proc_watchdog_update()
         watchdog_enable_all_cpus()         watchdog_hrtimer_fn()
         update_watchdog_all_cpus()            restart_timer(sample_period)
            watchdog_park_threads()
    
                                            thread->park()
                                              disable_nmi()
                              <----- Broken ends
    
    The reason why this is broken is that the update of the watchdog threshold
    becomes immediately effective and visible for the hrtimer function which
    uses that value to rearm the timer. But the NMI/perf side still uses the
    old value up to the point where it is disabled. If the rate has been
    lowered then the NMI can run fast enough to 'detect' a hard lockup because
    the timer has not fired due to the longer period.
    
    The patch 'fixed' this by adding a variable:
    
    proc_write()
       set_sample_period()
                                            <----- Broken starts
       proc_watchdog_update()
         watchdog_enable_all_cpus()         watchdog_hrtimer_fn()
         update_watchdog_all_cpus()            restart_timer(sample_period)
             watchdog_park_threads()
              park_in_progress = 1
                                            <----- Broken ends
                                            nmi_watchdog()
                                              if (park_in_progress)
                                                 return;
    
    The only effect of this variable was to make the window where the breakage
    can hit small enough that it was not longer observable in testing. From a
    correctness point of view it is a pointless bandaid which merily papers
    over the root cause: the unsychronized update of the variable.
    
    Looking deeper into the related code pathes unearthed similar problems in
    the watchdog_start()/stop() functions.
    
     watchdog_start()
            perf_nmi_event_start()
            hrtimer_start()
    
     watchdog_stop()
            hrtimer_cancel()
            perf_nmi_event_stop()
    
    In both cases the call order is wrong because if the tasks gets preempted
    or the VM gets scheduled out long enough after the first call, then there is
    a chance that the next NMI will see a stale hrtimer interrupt count and
    trigger a false positive hard lockup splat.
    
    Get rid of park_in_progress so the code can be gradually deobfuscated and
    pruned from several layers of duct tape papering over the root cause,
    which has been either ignored or not understood at all.
    
    Once this is removed the underlying problem will be fixed by rewriting the
    proc interface to do a proper synchronized update.
    
    Address the start/stop() ordering problem as well by reverting the call
    order, so this part is at least correct now.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Don Zickus <dzickus@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sebastian Siewior <bigeasy@linutronix.de>
    Cc: Ulrich Obergfell <uobergfe@redhat.com>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.20.1709052038270.2393@nanos
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 80354e6fa86d..91a3a4a4c8ae 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -27,7 +27,6 @@ extern void touch_softlockup_watchdog_sync(void);
 extern void touch_all_softlockup_watchdogs(void);
 extern unsigned int  softlockup_panic;
 extern int soft_watchdog_enabled;
-extern atomic_t watchdog_park_in_progress;
 #else
 static inline void touch_softlockup_watchdog_sched(void)
 {

commit 941154bd6937a710ae9193a3c733c0029e5ae7b8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 12 21:37:04 2017 +0200

    watchdog/hardlockup/perf: Prevent CPU hotplug deadlock
    
    The following deadlock is possible in the watchdog hotplug code:
    
      cpus_write_lock()
        ...
          takedown_cpu()
            smpboot_park_threads()
              smpboot_park_thread()
                kthread_park()
                  ->park() := watchdog_disable()
                    watchdog_nmi_disable()
                      perf_event_release_kernel();
                        put_event()
                          _free_event()
                            ->destroy() := hw_perf_event_destroy()
                              x86_release_hardware()
                                release_ds_buffers()
                                  get_online_cpus()
    
    when a per cpu watchdog perf event is destroyed which drops the last
    reference to the PMU hardware. The cleanup code there invokes
    get_online_cpus() which instantly deadlocks because the hotplug percpu
    rwsem is write locked.
    
    To solve this add a deferring mechanism:
    
      cpus_write_lock()
                               kthread_park()
                                watchdog_nmi_disable(deferred)
                                  perf_event_disable(event);
                                  move_event_to_deferred(event);
                               ....
      cpus_write_unlock()
      cleaup_deferred_events()
        perf_event_release_kernel()
    
    This is still properly serialized against concurrent hotplug via the
    cpu_add_remove_lock, which is held by the task which initiated the hotplug
    event.
    
    This is also used to handle event destruction when the watchdog threads are
    parked via other mechanisms than CPU hotplug.
    
    Analyzed-by: Peter Zijlstra <peterz@infradead.org>
    
    Reported-by: Borislav Petkov <bp@alien8.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Don Zickus <dzickus@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sebastian Siewior <bigeasy@linutronix.de>
    Cc: Ulrich Obergfell <uobergfe@redhat.com>
    Link: http://lkml.kernel.org/r/20170912194146.884469246@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 7eefe7abf44b..80354e6fa86d 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -13,9 +13,11 @@
 #ifdef CONFIG_LOCKUP_DETECTOR
 void lockup_detector_init(void);
 void lockup_detector_soft_poweroff(void);
+void lockup_detector_cleanup(void);
 #else
 static inline void lockup_detector_init(void) { }
 static inline void lockup_detector_soft_poweroff(void) { }
+static inline void lockup_detector_cleanup(void) { }
 #endif
 
 #ifdef CONFIG_SOFTLOCKUP_DETECTOR
@@ -77,9 +79,13 @@ static inline void hardlockup_detector_disable(void) {}
 extern void arch_touch_nmi_watchdog(void);
 extern void hardlockup_detector_perf_stop(void);
 extern void hardlockup_detector_perf_restart(void);
+extern void hardlockup_detector_perf_disable(void);
+extern void hardlockup_detector_perf_cleanup(void);
 #else
 static inline void hardlockup_detector_perf_stop(void) { }
 static inline void hardlockup_detector_perf_restart(void) { }
+static inline void hardlockup_detector_perf_disable(void) { }
+static inline void hardlockup_detector_perf_cleanup(void) { }
 #if !defined(CONFIG_HAVE_NMI_WATCHDOG)
 static inline void arch_touch_nmi_watchdog(void) {}
 #endif

commit 5490125d77a43016b26f629d4b485e2c62172551
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 12 21:36:59 2017 +0200

    watchdog/core: Remove broken suspend/resume interfaces
    
    This interface has several issues:
    
     - It's causing recursive locking of the hotplug lock.
    
     - It's complete overkill to teardown all threads and then recreate them
    
    The same can be achieved with the simple hardlockup_detector_perf_stop /
    restart() interfaces. The abuse from the busy looping poweroff() loop of
    PARISC has been solved as well.
    
    Remove the cruft.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Don Zickus <dzickus@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sebastian Siewior <bigeasy@linutronix.de>
    Cc: Ulrich Obergfell <uobergfe@redhat.com>
    Link: http://lkml.kernel.org/r/20170912194146.487537732@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 85bb268be39c..7eefe7abf44b 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -164,7 +164,6 @@ extern int watchdog_thresh;
 extern unsigned long watchdog_enabled;
 extern struct cpumask watchdog_cpumask;
 extern unsigned long *watchdog_cpumask_bits;
-extern int __read_mostly watchdog_suspended;
 #ifdef CONFIG_SMP
 extern int sysctl_softlockup_all_cpu_backtrace;
 extern int sysctl_hardlockup_all_cpu_backtrace;
@@ -192,17 +191,6 @@ extern int proc_watchdog_thresh(struct ctl_table *, int ,
 				void __user *, size_t *, loff_t *);
 extern int proc_watchdog_cpumask(struct ctl_table *, int,
 				 void __user *, size_t *, loff_t *);
-extern int lockup_detector_suspend(void);
-extern void lockup_detector_resume(void);
-#else
-static inline int lockup_detector_suspend(void)
-{
-	return 0;
-}
-
-static inline void lockup_detector_resume(void)
-{
-}
 #endif
 
 #ifdef CONFIG_HAVE_ACPI_APEI_NMI

commit 6554fd8cf06db86f861bb24d7487b2873ca444c4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 12 21:36:57 2017 +0200

    watchdog/core: Provide interface to stop from poweroff()
    
    PARISC has a a busy looping power off routine. If the watchdog is enabled
    the watchdog timer will still fire, but the thread is not running, which
    causes the softlockup watchdog to trigger.
    
    Provide a interface which allows to turn the watchdog off.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Don Zickus <dzickus@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sebastian Siewior <bigeasy@linutronix.de>
    Cc: Ulrich Obergfell <uobergfe@redhat.com>
    Cc: linux-parisc@vger.kernel.org
    Link: http://lkml.kernel.org/r/20170912194146.327343752@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index b24d4a58674a..85bb268be39c 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -12,10 +12,10 @@
 
 #ifdef CONFIG_LOCKUP_DETECTOR
 void lockup_detector_init(void);
+void lockup_detector_soft_poweroff(void);
 #else
-static inline void lockup_detector_init(void)
-{
-}
+static inline void lockup_detector_init(void) { }
+static inline void lockup_detector_soft_poweroff(void) { }
 #endif
 
 #ifdef CONFIG_SOFTLOCKUP_DETECTOR

commit d0b6e0a8ef24b1b07078ababe5d91bcdf4f4264a
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Tue Sep 12 21:36:55 2017 +0200

    watchdog/hardlockup: Provide interface to stop/restart perf events
    
    Provide an interface to stop and restart perf NMI watchdog events on all
    CPUs. This is only usable during init and especially for handling the perf
    HT bug on Intel machines. It's safe to use it this way as nothing can
    start/stop the NMI watchdog in parallel.
    
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Don Zickus <dzickus@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Cc: Sebastian Siewior <bigeasy@linutronix.de>
    Cc: Ulrich Obergfell <uobergfe@redhat.com>
    Link: http://lkml.kernel.org/r/20170912194146.167649596@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index a36abe2da13e..b24d4a58674a 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -75,7 +75,11 @@ static inline void hardlockup_detector_disable(void) {}
 
 #if defined(CONFIG_HARDLOCKUP_DETECTOR_PERF)
 extern void arch_touch_nmi_watchdog(void);
+extern void hardlockup_detector_perf_stop(void);
+extern void hardlockup_detector_perf_restart(void);
 #else
+static inline void hardlockup_detector_perf_stop(void) { }
+static inline void hardlockup_detector_perf_restart(void) { }
 #if !defined(CONFIG_HAVE_NMI_WATCHDOG)
 static inline void arch_touch_nmi_watchdog(void) {}
 #endif

commit 7edaeb6841dfb27e362288ab8466ebdc4972e867
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Aug 15 09:50:13 2017 +0200

    kernel/watchdog: Prevent false positives with turbo modes
    
    The hardlockup detector on x86 uses a performance counter based on unhalted
    CPU cycles and a periodic hrtimer. The hrtimer period is about 2/5 of the
    performance counter period, so the hrtimer should fire 2-3 times before the
    performance counter NMI fires. The NMI code checks whether the hrtimer
    fired since the last invocation. If not, it assumess a hard lockup.
    
    The calculation of those periods is based on the nominal CPU
    frequency. Turbo modes increase the CPU clock frequency and therefore
    shorten the period of the perf/NMI watchdog. With extreme Turbo-modes (3x
    nominal frequency) the perf/NMI period is shorter than the hrtimer period
    which leads to false positives.
    
    A simple fix would be to shorten the hrtimer period, but that comes with
    the side effect of more frequent hrtimer and softlockup thread wakeups,
    which is not desired.
    
    Implement a low pass filter, which checks the perf/NMI period against
    kernel time. If the perf/NMI fires before 4/5 of the watchdog period has
    elapsed then the event is ignored and postponed to the next perf/NMI.
    
    That solves the problem and avoids the overhead of shorter hrtimer periods
    and more frequent softlockup thread wakeups.
    
    Fixes: 58687acba592 ("lockup_detector: Combine nmi_watchdog and softlockup detector")
    Reported-and-tested-by: Kan Liang <Kan.liang@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: dzickus@redhat.com
    Cc: prarit@redhat.com
    Cc: ak@linux.intel.com
    Cc: babu.moger@oracle.com
    Cc: peterz@infradead.org
    Cc: eranian@google.com
    Cc: acme@redhat.com
    Cc: stable@vger.kernel.org
    Cc: atomlin@redhat.com
    Cc: akpm@linux-foundation.org
    Cc: torvalds@linux-foundation.org
    Link: http://lkml.kernel.org/r/alpine.DEB.2.20.1708150931310.1886@nanos

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 8aa01fd859fb..a36abe2da13e 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -168,6 +168,14 @@ extern int sysctl_hardlockup_all_cpu_backtrace;
 #define sysctl_softlockup_all_cpu_backtrace 0
 #define sysctl_hardlockup_all_cpu_backtrace 0
 #endif
+
+#if defined(CONFIG_HARDLOCKUP_CHECK_TIMESTAMP) && \
+    defined(CONFIG_HARDLOCKUP_DETECTOR)
+void watchdog_update_hrtimer_threshold(u64 period);
+#else
+static inline void watchdog_update_hrtimer_threshold(u64 period) { }
+#endif
+
 extern bool is_hardlockup(void);
 struct ctl_table;
 extern int proc_watchdog(struct ctl_table *, int ,

commit 05a4a95279311c3a4633b4277a5d21cfd616c6c7
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Wed Jul 12 14:35:46 2017 -0700

    kernel/watchdog: split up config options
    
    Split SOFTLOCKUP_DETECTOR from LOCKUP_DETECTOR, and split
    HARDLOCKUP_DETECTOR_PERF from HARDLOCKUP_DETECTOR.
    
    LOCKUP_DETECTOR implies the general boot, sysctl, and programming
    interfaces for the lockup detectors.
    
    An architecture that wants to use a hard lockup detector must define
    HAVE_HARDLOCKUP_DETECTOR_PERF or HAVE_HARDLOCKUP_DETECTOR_ARCH.
    
    Alternatively an arch can define HAVE_NMI_WATCHDOG, which provides the
    minimum arch_touch_nmi_watchdog, and it otherwise does its own thing and
    does not implement the LOCKUP_DETECTOR interfaces.
    
    sparc is unusual in that it has started to implement some of the
    interfaces, but not fully yet.  It should probably be converted to a full
    HAVE_HARDLOCKUP_DETECTOR_ARCH.
    
    [npiggin@gmail.com: fix]
      Link: http://lkml.kernel.org/r/20170617223522.66c0ad88@roar.ozlabs.ibm.com
    Link: http://lkml.kernel.org/r/20170616065715.18390-4-npiggin@gmail.com
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Reviewed-by: Don Zickus <dzickus@redhat.com>
    Reviewed-by: Babu Moger <babu.moger@oracle.com>
    Tested-by: Babu Moger <babu.moger@oracle.com>   [sparc]
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index bd387ef8bccd..8aa01fd859fb 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -11,13 +11,21 @@
 #endif
 
 #ifdef CONFIG_LOCKUP_DETECTOR
+void lockup_detector_init(void);
+#else
+static inline void lockup_detector_init(void)
+{
+}
+#endif
+
+#ifdef CONFIG_SOFTLOCKUP_DETECTOR
 extern void touch_softlockup_watchdog_sched(void);
 extern void touch_softlockup_watchdog(void);
 extern void touch_softlockup_watchdog_sync(void);
 extern void touch_all_softlockup_watchdogs(void);
 extern unsigned int  softlockup_panic;
-extern unsigned int  hardlockup_panic;
-void lockup_detector_init(void);
+extern int soft_watchdog_enabled;
+extern atomic_t watchdog_park_in_progress;
 #else
 static inline void touch_softlockup_watchdog_sched(void)
 {
@@ -31,9 +39,6 @@ static inline void touch_softlockup_watchdog_sync(void)
 static inline void touch_all_softlockup_watchdogs(void)
 {
 }
-static inline void lockup_detector_init(void)
-{
-}
 #endif
 
 #ifdef CONFIG_DETECT_HUNG_TASK
@@ -63,15 +68,18 @@ static inline void reset_hung_task_detector(void)
 
 #if defined(CONFIG_HARDLOCKUP_DETECTOR)
 extern void hardlockup_detector_disable(void);
+extern unsigned int hardlockup_panic;
 #else
 static inline void hardlockup_detector_disable(void) {}
 #endif
 
-#if defined(CONFIG_HARDLOCKUP_DETECTOR) || defined(CONFIG_HAVE_NMI_WATCHDOG)
+#if defined(CONFIG_HARDLOCKUP_DETECTOR_PERF)
 extern void arch_touch_nmi_watchdog(void);
 #else
+#if !defined(CONFIG_HAVE_NMI_WATCHDOG)
 static inline void arch_touch_nmi_watchdog(void) {}
 #endif
+#endif
 
 /**
  * touch_nmi_watchdog - restart NMI watchdog timeout.
@@ -141,15 +149,18 @@ static inline bool trigger_single_cpu_backtrace(int cpu)
 }
 #endif
 
-#ifdef CONFIG_LOCKUP_DETECTOR
+#ifdef CONFIG_HARDLOCKUP_DETECTOR_PERF
 u64 hw_nmi_get_sample_period(int watchdog_thresh);
+#endif
+
+#ifdef CONFIG_LOCKUP_DETECTOR
 extern int nmi_watchdog_enabled;
-extern int soft_watchdog_enabled;
 extern int watchdog_user_enabled;
 extern int watchdog_thresh;
 extern unsigned long watchdog_enabled;
+extern struct cpumask watchdog_cpumask;
 extern unsigned long *watchdog_cpumask_bits;
-extern atomic_t watchdog_park_in_progress;
+extern int __read_mostly watchdog_suspended;
 #ifdef CONFIG_SMP
 extern int sysctl_softlockup_all_cpu_backtrace;
 extern int sysctl_hardlockup_all_cpu_backtrace;

commit f2e0cff85ed111a3cf24d894c3fa11697dfae628
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Wed Jul 12 14:35:43 2017 -0700

    kernel/watchdog: introduce arch_touch_nmi_watchdog()
    
    For architectures that define HAVE_NMI_WATCHDOG, instead of having them
    provide the complete touch_nmi_watchdog() function, just have them
    provide arch_touch_nmi_watchdog().
    
    This gives the generic code more flexibility in implementing this
    function, and arch implementations don't miss out on touching the
    softlockup watchdog or other generic details.
    
    Link: http://lkml.kernel.org/r/20170616065715.18390-3-npiggin@gmail.com
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Reviewed-by: Don Zickus <dzickus@redhat.com>
    Reviewed-by: Babu Moger <babu.moger@oracle.com>
    Tested-by: Babu Moger <babu.moger@oracle.com>   [sparc]
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 5e2e57536d98..bd387ef8bccd 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -6,6 +6,9 @@
 
 #include <linux/sched.h>
 #include <asm/irq.h>
+#if defined(CONFIG_HAVE_NMI_WATCHDOG)
+#include <asm/nmi.h>
+#endif
 
 #ifdef CONFIG_LOCKUP_DETECTOR
 extern void touch_softlockup_watchdog_sched(void);
@@ -58,6 +61,18 @@ static inline void reset_hung_task_detector(void)
 #define NMI_WATCHDOG_ENABLED      (1 << NMI_WATCHDOG_ENABLED_BIT)
 #define SOFT_WATCHDOG_ENABLED     (1 << SOFT_WATCHDOG_ENABLED_BIT)
 
+#if defined(CONFIG_HARDLOCKUP_DETECTOR)
+extern void hardlockup_detector_disable(void);
+#else
+static inline void hardlockup_detector_disable(void) {}
+#endif
+
+#if defined(CONFIG_HARDLOCKUP_DETECTOR) || defined(CONFIG_HAVE_NMI_WATCHDOG)
+extern void arch_touch_nmi_watchdog(void);
+#else
+static inline void arch_touch_nmi_watchdog(void) {}
+#endif
+
 /**
  * touch_nmi_watchdog - restart NMI watchdog timeout.
  * 
@@ -65,21 +80,11 @@ static inline void reset_hung_task_detector(void)
  * may be used to reset the timeout - for code which intentionally
  * disables interrupts for a long time. This call is stateless.
  */
-#if defined(CONFIG_HAVE_NMI_WATCHDOG) || defined(CONFIG_HARDLOCKUP_DETECTOR)
-#include <asm/nmi.h>
-extern void touch_nmi_watchdog(void);
-#else
 static inline void touch_nmi_watchdog(void)
 {
+	arch_touch_nmi_watchdog();
 	touch_softlockup_watchdog();
 }
-#endif
-
-#if defined(CONFIG_HARDLOCKUP_DETECTOR)
-extern void hardlockup_detector_disable(void);
-#else
-static inline void hardlockup_detector_disable(void) {}
-#endif
 
 /*
  * Create trigger_all_cpu_backtrace() out of the arch-provided

commit 24bb44612c5f93a1dff1f7e71b7b7b109a988791
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Wed Jul 12 14:35:40 2017 -0700

    kernel/watchdog: remove unused declaration
    
    Patch series "Improve watchdog config for arch watchdogs", v4.
    
    A series to make the hardlockup watchdog more easily replaceable by arch
    code.  The last patch provides some justification for why we want to do
    this (existing sparc watchdog is another that could benefit).
    
    This patch (of 5):
    
    Remove unused declaration.
    
    Link: http://lkml.kernel.org/r/20170616065715.18390-2-npiggin@gmail.com
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Reviewed-by: Don Zickus <dzickus@redhat.com>
    Reviewed-by: Babu Moger <babu.moger@oracle.com>
    Tested-by: Babu Moger <babu.moger@oracle.com>   [sparc]
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index aa3cd0878270..5e2e57536d98 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -12,9 +12,6 @@ extern void touch_softlockup_watchdog_sched(void);
 extern void touch_softlockup_watchdog(void);
 extern void touch_softlockup_watchdog_sync(void);
 extern void touch_all_softlockup_watchdogs(void);
-extern int proc_dowatchdog_thresh(struct ctl_table *table, int write,
-				  void __user *buffer,
-				  size_t *lenp, loff_t *ppos);
 extern unsigned int  softlockup_panic;
 extern unsigned int  hardlockup_panic;
 void lockup_detector_init(void);

commit d151b27d3f86589308cd8c891fdfd2db5f8e80d6
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Feb 2 11:17:23 2017 +0100

    sched/headers: Move softlockup detector watchdog methods to <linux/nmi.h>
    
    These methods don't belong into <linux/sched.h>, they are neither directly
    related to task_struct or are scheduler functionality.
    
    Put them next to the other watchdog methods in <linux/nmi.h>.
    
    ( Arguably that header's name is a misnomer, and this patch makes it
      more so - but it should be renamed in another patch. )
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 0a3fadc32693..aa3cd0878270 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -7,6 +7,43 @@
 #include <linux/sched.h>
 #include <asm/irq.h>
 
+#ifdef CONFIG_LOCKUP_DETECTOR
+extern void touch_softlockup_watchdog_sched(void);
+extern void touch_softlockup_watchdog(void);
+extern void touch_softlockup_watchdog_sync(void);
+extern void touch_all_softlockup_watchdogs(void);
+extern int proc_dowatchdog_thresh(struct ctl_table *table, int write,
+				  void __user *buffer,
+				  size_t *lenp, loff_t *ppos);
+extern unsigned int  softlockup_panic;
+extern unsigned int  hardlockup_panic;
+void lockup_detector_init(void);
+#else
+static inline void touch_softlockup_watchdog_sched(void)
+{
+}
+static inline void touch_softlockup_watchdog(void)
+{
+}
+static inline void touch_softlockup_watchdog_sync(void)
+{
+}
+static inline void touch_all_softlockup_watchdogs(void)
+{
+}
+static inline void lockup_detector_init(void)
+{
+}
+#endif
+
+#ifdef CONFIG_DETECT_HUNG_TASK
+void reset_hung_task_detector(void);
+#else
+static inline void reset_hung_task_detector(void)
+{
+}
+#endif
+
 /*
  * The run state of the lockup detectors is controlled by the content of the
  * 'watchdog_enabled' variable. Each lockup detector has its dedicated bit -

commit b94f51183b0617e7b9b4fb4137d4cf1cab7547c2
Author: Don Zickus <dzickus@redhat.com>
Date:   Tue Jan 24 15:17:53 2017 -0800

    kernel/watchdog: prevent false hardlockup on overloaded system
    
    On an overloaded system, it is possible that a change in the watchdog
    threshold can be delayed long enough to trigger a false positive.
    
    This can easily be achieved by having a cpu spinning indefinitely on a
    task, while another cpu updates watchdog threshold.
    
    What happens is while trying to park the watchdog threads, the hrtimers
    on the other cpus trigger and reprogram themselves with the new slower
    watchdog threshold.  Meanwhile, the nmi watchdog is still programmed
    with the old faster threshold.
    
    Because the one cpu is blocked, it prevents the thread parking on the
    other cpus from completing, which is needed to shutdown the nmi watchdog
    and reprogram it correctly.  As a result, a false positive from the nmi
    watchdog is reported.
    
    Fix this by setting a park_in_progress flag to block all lockups until
    the parking is complete.
    
    Fix provided by Ulrich Obergfell.
    
    [akpm@linux-foundation.org: s/park_in_progress/watchdog_park_in_progress/]
    Link: http://lkml.kernel.org/r/1481041033-192236-1-git-send-email-dzickus@redhat.com
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Reviewed-by: Aaron Tomlin <atomlin@redhat.com>
    Cc: Ulrich Obergfell <uobergfe@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index aacca824a6ae..0a3fadc32693 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -110,6 +110,7 @@ extern int watchdog_user_enabled;
 extern int watchdog_thresh;
 extern unsigned long watchdog_enabled;
 extern unsigned long *watchdog_cpumask_bits;
+extern atomic_t watchdog_park_in_progress;
 #ifdef CONFIG_SMP
 extern int sysctl_softlockup_all_cpu_backtrace;
 extern int sysctl_hardlockup_all_cpu_backtrace;

commit 249e52e35580fcfe5dad53a7dcd7c1252788749c
Author: Babu Moger <babu.moger@oracle.com>
Date:   Wed Dec 14 15:06:21 2016 -0800

    kernel/watchdog.c: move shared definitions to nmi.h
    
    Patch series "Clean up watchdog handlers", v2.
    
    This is an attempt to cleanup watchdog handlers.  Right now,
    kernel/watchdog.c implements both softlockup and hardlockup detectors.
    Softlockup code is generic.  Hardlockup code is arch specific.  Some
    architectures don't use hardlockup detectors.  They use their own
    watchdog detectors.  To make both these combination work, we have
    numerous #ifdefs in kernel/watchdog.c.
    
    We are trying here to make these handlers independent of each other.
    Also provide an interface for architectures to implement their own
    handlers.  watchdog_nmi_enable and watchdog_nmi_disable will be defined
    as weak such that architectures can override its definitions.
    
    Thanks to Don Zickus for his suggestions.
    Here are our previous discussions
    http://www.spinics.net/lists/sparclinux/msg16543.html
    http://www.spinics.net/lists/sparclinux/msg16441.html
    
    This patch (of 3):
    
    Move shared macros and definitions to nmi.h so that watchdog.c, new file
    watchdog_hld.c or any other architecture specific handler can use those
    definitions.
    
    Link: http://lkml.kernel.org/r/1478034826-43888-2-git-send-email-babu.moger@oracle.com
    Signed-off-by: Babu Moger <babu.moger@oracle.com>
    Acked-by: Don Zickus <dzickus@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Yaowei Bai <baiyaowei@cmss.chinamobile.com>
    Cc: Aaron Tomlin <atomlin@redhat.com>
    Cc: Ulrich Obergfell <uobergfe@redhat.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Hidehiro Kawai <hidehiro.kawai.ez@hitachi.com>
    Cc: Josh Hunt <johunt@akamai.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index a78c35cff1ae..aacca824a6ae 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -7,6 +7,23 @@
 #include <linux/sched.h>
 #include <asm/irq.h>
 
+/*
+ * The run state of the lockup detectors is controlled by the content of the
+ * 'watchdog_enabled' variable. Each lockup detector has its dedicated bit -
+ * bit 0 for the hard lockup detector and bit 1 for the soft lockup detector.
+ *
+ * 'watchdog_user_enabled', 'nmi_watchdog_enabled' and 'soft_watchdog_enabled'
+ * are variables that are only used as an 'interface' between the parameters
+ * in /proc/sys/kernel and the internal state bits in 'watchdog_enabled'. The
+ * 'watchdog_thresh' variable is handled differently because its value is not
+ * boolean, and the lockup detectors are 'suspended' while 'watchdog_thresh'
+ * is equal zero.
+ */
+#define NMI_WATCHDOG_ENABLED_BIT   0
+#define SOFT_WATCHDOG_ENABLED_BIT  1
+#define NMI_WATCHDOG_ENABLED      (1 << NMI_WATCHDOG_ENABLED_BIT)
+#define SOFT_WATCHDOG_ENABLED     (1 << SOFT_WATCHDOG_ENABLED_BIT)
+
 /**
  * touch_nmi_watchdog - restart NMI watchdog timeout.
  * 
@@ -91,9 +108,16 @@ extern int nmi_watchdog_enabled;
 extern int soft_watchdog_enabled;
 extern int watchdog_user_enabled;
 extern int watchdog_thresh;
+extern unsigned long watchdog_enabled;
 extern unsigned long *watchdog_cpumask_bits;
+#ifdef CONFIG_SMP
 extern int sysctl_softlockup_all_cpu_backtrace;
 extern int sysctl_hardlockup_all_cpu_backtrace;
+#else
+#define sysctl_softlockup_all_cpu_backtrace 0
+#define sysctl_hardlockup_all_cpu_backtrace 0
+#endif
+extern bool is_hardlockup(void);
 struct ctl_table;
 extern int proc_watchdog(struct ctl_table *, int ,
 			 void __user *, size_t *, loff_t *);

commit 9a01c3ed5cdb35d9004eb92510ee6ea11b4a5f16
Author: Chris Metcalf <cmetcalf@mellanox.com>
Date:   Fri Oct 7 17:02:45 2016 -0700

    nmi_backtrace: add more trigger_*_cpu_backtrace() methods
    
    Patch series "improvements to the nmi_backtrace code" v9.
    
    This patch series modifies the trigger_xxx_backtrace() NMI-based remote
    backtracing code to make it more flexible, and makes a few small
    improvements along the way.
    
    The motivation comes from the task isolation code, where there are
    scenarios where we want to be able to diagnose a case where some cpu is
    about to interrupt a task-isolated cpu.  It can be helpful to see both
    where the interrupting cpu is, and also an approximation of where the
    cpu that is being interrupted is.  The nmi_backtrace framework allows us
    to discover the stack of the interrupted cpu.
    
    I've tested that the change works as desired on tile, and build-tested
    x86, arm, mips, and sparc64.  For x86 I confirmed that the generic
    cpuidle stuff as well as the architecture-specific routines are in the
    new cpuidle section.  For arm, mips, and sparc I just build-tested it
    and made sure the generic cpuidle routines were in the new cpuidle
    section, but I didn't attempt to figure out which the platform-specific
    idle routines might be.  That might be more usefully done by someone
    with platform experience in follow-up patches.
    
    This patch (of 4):
    
    Currently you can only request a backtrace of either all cpus, or all
    cpus but yourself.  It can also be helpful to request a remote backtrace
    of a single cpu, and since we want that, the logical extension is to
    support a cpumask as the underlying primitive.
    
    This change modifies the existing lib/nmi_backtrace.c code to take a
    cpumask as its basic primitive, and modifies the linux/nmi.h code to use
    the new "cpumask" method instead.
    
    The existing clients of nmi_backtrace (arm and x86) are converted to
    using the new cpumask approach in this change.
    
    The other users of the backtracing API (sparc64 and mips) are converted
    to use the cpumask approach rather than the all/allbutself approach.
    The mips code ignored the "include_self" boolean but with this change it
    will now also dump a local backtrace if requested.
    
    Link: http://lkml.kernel.org/r/1472487169-14923-2-git-send-email-cmetcalf@mellanox.com
    Signed-off-by: Chris Metcalf <cmetcalf@mellanox.com>
    Tested-by: Daniel Thompson <daniel.thompson@linaro.org> [arm]
    Reviewed-by: Aaron Tomlin <atomlin@redhat.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: David Miller <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 4630eeae18e0..a78c35cff1ae 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -35,21 +35,34 @@ static inline void hardlockup_detector_disable(void) {}
  * base function. Return whether such support was available,
  * to allow calling code to fall back to some other mechanism:
  */
-#ifdef arch_trigger_all_cpu_backtrace
+#ifdef arch_trigger_cpumask_backtrace
 static inline bool trigger_all_cpu_backtrace(void)
 {
-	arch_trigger_all_cpu_backtrace(true);
-
+	arch_trigger_cpumask_backtrace(cpu_online_mask, false);
 	return true;
 }
+
 static inline bool trigger_allbutself_cpu_backtrace(void)
 {
-	arch_trigger_all_cpu_backtrace(false);
+	arch_trigger_cpumask_backtrace(cpu_online_mask, true);
+	return true;
+}
+
+static inline bool trigger_cpumask_backtrace(struct cpumask *mask)
+{
+	arch_trigger_cpumask_backtrace(mask, false);
+	return true;
+}
+
+static inline bool trigger_single_cpu_backtrace(int cpu)
+{
+	arch_trigger_cpumask_backtrace(cpumask_of(cpu), false);
 	return true;
 }
 
 /* generic implementation */
-void nmi_trigger_all_cpu_backtrace(bool include_self,
+void nmi_trigger_cpumask_backtrace(const cpumask_t *mask,
+				   bool exclude_self,
 				   void (*raise)(cpumask_t *mask));
 bool nmi_cpu_backtrace(struct pt_regs *regs);
 
@@ -62,6 +75,14 @@ static inline bool trigger_allbutself_cpu_backtrace(void)
 {
 	return false;
 }
+static inline bool trigger_cpumask_backtrace(struct cpumask *mask)
+{
+	return false;
+}
+static inline bool trigger_single_cpu_backtrace(int cpu)
+{
+	return false;
+}
 #endif
 
 #ifdef CONFIG_LOCKUP_DETECTOR

commit f09e3f4fe42caad0c0f59c1489d2b3f512c070b5
Author: Yaowei Bai <baiyaowei@cmss.chinamobile.com>
Date:   Wed Mar 23 09:40:09 2016 +0800

    x86/apic: Remove declaration of unused hw_nmi_is_cpu_stuck
    
    Commit 10f9014912 ("x86: Cleanup hw_nmi.c cruft") removed unused
    code in the hw_nmi.c file because of the redesign of the hardlockup
    watchdog but left declaration of hw_nmi_is_cpu_stuck in linux/nmi.h,
    so remvoe it.
    
    Signed-off-by: Yaowei Bai <baiyaowei@cmss.chinamobile.com>
    Link: http://lkml.kernel.org/r/1458697210-3027-1-git-send-email-baiyaowei@cmss.chinamobile.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 7ec5b86735f3..4630eeae18e0 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -65,7 +65,6 @@ static inline bool trigger_allbutself_cpu_backtrace(void)
 #endif
 
 #ifdef CONFIG_LOCKUP_DETECTOR
-int hw_nmi_is_cpu_stuck(struct pt_regs *);
 u64 hw_nmi_get_sample_period(int watchdog_thresh);
 extern int nmi_watchdog_enabled;
 extern int soft_watchdog_enabled;

commit 55537871ef666b4153fd1ef8782e4a13fee142cc
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Nov 5 18:44:41 2015 -0800

    kernel/watchdog.c: perform all-CPU backtrace in case of hard lockup
    
    In many cases of hardlockup reports, it's actually not possible to know
    why it triggered, because the CPU that got stuck is usually waiting on a
    resource (with IRQs disabled) in posession of some other CPU is holding.
    
    IOW, we are often looking at the stacktrace of the victim and not the
    actual offender.
    
    Introduce sysctl / cmdline parameter that makes it possible to have
    hardlockup detector perform all-CPU backtrace.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Reviewed-by: Aaron Tomlin <atomlin@redhat.com>
    Cc: Ulrich Obergfell <uobergfe@redhat.com>
    Acked-by: Don Zickus <dzickus@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 78488e099ce7..7ec5b86735f3 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -73,6 +73,7 @@ extern int watchdog_user_enabled;
 extern int watchdog_thresh;
 extern unsigned long *watchdog_cpumask_bits;
 extern int sysctl_softlockup_all_cpu_backtrace;
+extern int sysctl_hardlockup_all_cpu_backtrace;
 struct ctl_table;
 extern int proc_watchdog(struct ctl_table *, int ,
 			 void __user *, size_t *, loff_t *);

commit 6f0a2fc1feb19bd142961a39dc118e7e55418b3f
Merge: 752240e74d65 96f0e00378d4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 8 12:28:10 2015 -0700

    Merge branch 'nmi' of git://ftp.arm.linux.org.uk/~rmk/linux-arm
    
    Pull NMI backtrace update from Russell King:
     "These changes convert the x86 NMI handling to be a library
      implementation which other architectures can make use of.  Thomas
      Gleixner has reviewed and tested these changes, and wishes me to send
      these rather than taking them through the tip tree.
    
      The final patch in the set adds an initial implementation using this
      infrastructure to ARM, even though it doesn't send the IPI at "NMI"
      level.  Patches are in progress to add the ARM equivalent of NMI, but
      we still need the IRQ-level fallback for systems where the "NMI" isn't
      available due to secure firmware denying access to it"
    
    * 'nmi' of git://ftp.arm.linux.org.uk/~rmk/linux-arm:
      ARM: add basic support for on-demand backtrace of other CPUs
      nmi: x86: convert to generic nmi handler
      nmi: create generic NMI backtrace implementation

commit ec6a90661a0d6ce1461d05c7a58a0a151154e14a
Author: Ulrich Obergfell <uobergfe@redhat.com>
Date:   Fri Sep 4 15:45:28 2015 -0700

    watchdog: rename watchdog_suspend() and watchdog_resume()
    
    Rename watchdog_suspend() to lockup_detector_suspend() and
    watchdog_resume() to lockup_detector_resume() to avoid confusion with the
    watchdog subsystem and to be consistent with the existing name
    lockup_detector_init().
    
    Also provide comment blocks to explain the watchdog_running and
    watchdog_suspended variables and their relationship.
    
    Signed-off-by: Ulrich Obergfell <uobergfe@redhat.com>
    Reviewed-by: Aaron Tomlin <atomlin@redhat.com>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Ulrich Obergfell <uobergfe@redhat.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Chris Metcalf <cmetcalf@ezchip.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Ingo Molnar <mingo@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index e5afe8bae202..a91adf6e02f2 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -78,15 +78,15 @@ extern int proc_watchdog_thresh(struct ctl_table *, int ,
 				void __user *, size_t *, loff_t *);
 extern int proc_watchdog_cpumask(struct ctl_table *, int,
 				 void __user *, size_t *, loff_t *);
-extern int watchdog_suspend(void);
-extern void watchdog_resume(void);
+extern int lockup_detector_suspend(void);
+extern void lockup_detector_resume(void);
 #else
-static inline int watchdog_suspend(void)
+static inline int lockup_detector_suspend(void)
 {
 	return 0;
 }
 
-static inline void watchdog_resume(void)
+static inline void lockup_detector_resume(void)
 {
 }
 #endif

commit 999bbe49ea0118b70ddf3f5d679f51dc7a97ae55
Author: Ulrich Obergfell <uobergfe@redhat.com>
Date:   Fri Sep 4 15:45:25 2015 -0700

    watchdog: use suspend/resume interface in fixup_ht_bug()
    
    Remove watchdog_nmi_disable_all() and watchdog_nmi_enable_all() since
    these functions are no longer needed.  If a subsystem has a need to
    deactivate the watchdog temporarily, it should utilize the
    watchdog_suspend() and watchdog_resume() functions.
    
    [akpm@linux-foundation.org: fix build with CONFIG_LOCKUP_DETECTOR=m]
    Signed-off-by: Ulrich Obergfell <uobergfe@redhat.com>
    Reviewed-by: Aaron Tomlin <atomlin@redhat.com>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Ulrich Obergfell <uobergfe@redhat.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Chris Metcalf <cmetcalf@ezchip.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Ingo Molnar <mingo@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index e9f213c337bb..e5afe8bae202 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -26,12 +26,8 @@ static inline void touch_nmi_watchdog(void)
 
 #if defined(CONFIG_HARDLOCKUP_DETECTOR)
 extern void hardlockup_detector_disable(void);
-void watchdog_nmi_disable_all(void);
-void watchdog_nmi_enable_all(void);
 #else
 static inline void hardlockup_detector_disable(void) {}
-static inline void watchdog_nmi_disable_all(void) {}
-static inline void watchdog_nmi_enable_all(void) {}
 #endif
 
 /*
@@ -84,6 +80,15 @@ extern int proc_watchdog_cpumask(struct ctl_table *, int,
 				 void __user *, size_t *, loff_t *);
 extern int watchdog_suspend(void);
 extern void watchdog_resume(void);
+#else
+static inline int watchdog_suspend(void)
+{
+	return 0;
+}
+
+static inline void watchdog_resume(void)
+{
+}
 #endif
 
 #ifdef CONFIG_HAVE_ACPI_APEI_NMI

commit 8c073d27d7ad293bf734cc8475689413afadab81
Author: Ulrich Obergfell <uobergfe@redhat.com>
Date:   Fri Sep 4 15:45:18 2015 -0700

    watchdog: introduce watchdog_suspend() and watchdog_resume()
    
    This interface can be utilized to deactivate the hard and soft lockup
    detector temporarily.  Callers are expected to minimize the duration of
    deactivation.  Multiple deactivations are allowed to occur in parallel but
    should be rare in practice.
    
    [akpm@linux-foundation.org: remove unneeded static initialization]
    Signed-off-by: Ulrich Obergfell <uobergfe@redhat.com>
    Reviewed-by: Aaron Tomlin <atomlin@redhat.com>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Ulrich Obergfell <uobergfe@redhat.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Chris Metcalf <cmetcalf@ezchip.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Ingo Molnar <mingo@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 088714537d10..e9f213c337bb 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -82,6 +82,8 @@ extern int proc_watchdog_thresh(struct ctl_table *, int ,
 				void __user *, size_t *, loff_t *);
 extern int proc_watchdog_cpumask(struct ctl_table *, int,
 				 void __user *, size_t *, loff_t *);
+extern int watchdog_suspend(void);
+extern void watchdog_resume(void);
 #endif
 
 #ifdef CONFIG_HAVE_ACPI_APEI_NMI

commit aacfbe6a9724bb6d66a656a5abcc681d5649ed92
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Fri Sep 4 15:45:12 2015 -0700

    kernel/watchdog: move NMI function header declarations from watchdog.h to nmi.h
    
    The kernel's NMI watchdog has nothing to do with the watchdog subsystem.
    Its header declarations should be in linux/nmi.h, not linux/watchdog.h.
    
    The code provided two sets of dummy functions if HARDLOCKUP_DETECTOR is
    not configured, one in the include file and one in kernel/watchdog.c.
    Remove the dummy functions from kernel/watchdog.c and use those from the
    include file.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Don Zickus <dzickus@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index f94da0e65dea..088714537d10 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -26,10 +26,12 @@ static inline void touch_nmi_watchdog(void)
 
 #if defined(CONFIG_HARDLOCKUP_DETECTOR)
 extern void hardlockup_detector_disable(void);
+void watchdog_nmi_disable_all(void);
+void watchdog_nmi_enable_all(void);
 #else
-static inline void hardlockup_detector_disable(void)
-{
-}
+static inline void hardlockup_detector_disable(void) {}
+static inline void watchdog_nmi_disable_all(void) {}
+static inline void watchdog_nmi_enable_all(void) {}
 #endif
 
 /*

commit b2c0b2cbb282f0cf42518ffacbe197e6f2884168
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Sep 3 23:57:13 2014 +0100

    nmi: create generic NMI backtrace implementation
    
    x86s NMI backtrace implementation (for arch_trigger_all_cpu_backtrace())
    is fairly generic in nature - the only architecture specific bits are
    the act of raising the NMI to other CPUs, and reporting the status of
    the NMI handler.
    
    These are fairly simple to factor out, and produce a generic
    implementation which can be shared between ARM and x86.
    
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index f94da0e65dea..5791e3229068 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -49,6 +49,12 @@ static inline bool trigger_allbutself_cpu_backtrace(void)
 	arch_trigger_all_cpu_backtrace(false);
 	return true;
 }
+
+/* generic implementation */
+void nmi_trigger_all_cpu_backtrace(bool include_self,
+				   void (*raise)(cpumask_t *mask));
+bool nmi_cpu_backtrace(struct pt_regs *regs);
+
 #else
 static inline bool trigger_all_cpu_backtrace(void)
 {

commit fe4ba3c34352b7e8068b7f18eb233444aed17011
Author: Chris Metcalf <cmetcalf@ezchip.com>
Date:   Wed Jun 24 16:55:45 2015 -0700

    watchdog: add watchdog_cpumask sysctl to assist nohz
    
    Change the default behavior of watchdog so it only runs on the
    housekeeping cores when nohz_full is enabled at build and boot time.
    Allow modifying the set of cores the watchdog is currently running on
    with a new kernel.watchdog_cpumask sysctl.
    
    In the current system, the watchdog subsystem runs a periodic timer that
    schedules the watchdog kthread to run.  However, nohz_full cores are
    designed to allow userspace application code running on those cores to
    have 100% access to the CPU.  So the watchdog system prevents the
    nohz_full application code from being able to run the way it wants to,
    thus the motivation to suppress the watchdog on nohz_full cores, which
    this patchset provides by default.
    
    However, if we disable the watchdog globally, then the housekeeping
    cores can't benefit from the watchdog functionality.  So we allow
    disabling it only on some cores.  See Documentation/lockup-watchdogs.txt
    for more information.
    
    [jhubbard@nvidia.com: fix a watchdog crash in some configurations]
    Signed-off-by: Chris Metcalf <cmetcalf@ezchip.com>
    Acked-by: Don Zickus <dzickus@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Ulrich Obergfell <uobergfe@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Signed-off-by: John Hubbard <jhubbard@nvidia.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 3d46fb4708e0..f94da0e65dea 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -67,6 +67,7 @@ extern int nmi_watchdog_enabled;
 extern int soft_watchdog_enabled;
 extern int watchdog_user_enabled;
 extern int watchdog_thresh;
+extern unsigned long *watchdog_cpumask_bits;
 extern int sysctl_softlockup_all_cpu_backtrace;
 struct ctl_table;
 extern int proc_watchdog(struct ctl_table *, int ,
@@ -77,6 +78,8 @@ extern int proc_soft_watchdog(struct ctl_table *, int ,
 			      void __user *, size_t *, loff_t *);
 extern int proc_watchdog_thresh(struct ctl_table *, int ,
 				void __user *, size_t *, loff_t *);
+extern int proc_watchdog_cpumask(struct ctl_table *, int,
+				 void __user *, size_t *, loff_t *);
 #endif
 
 #ifdef CONFIG_HAVE_ACPI_APEI_NMI

commit 692297d8f96887f836d9049a653ed05a71cf48fb
Author: Ulrich Obergfell <uobergfe@redhat.com>
Date:   Tue Apr 14 15:44:19 2015 -0700

    watchdog: introduce the hardlockup_detector_disable() function
    
    Have kvm_guest_init() use hardlockup_detector_disable() instead of
    watchdog_enable_hardlockup_detector(false).
    
    Remove the watchdog_hardlockup_detector_is_enabled() and the
    watchdog_enable_hardlockup_detector() function which are no longer needed.
    
    Signed-off-by: Ulrich Obergfell <uobergfe@redhat.com>
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 0426357297d5..3d46fb4708e0 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -25,16 +25,11 @@ static inline void touch_nmi_watchdog(void)
 #endif
 
 #if defined(CONFIG_HARDLOCKUP_DETECTOR)
-extern void watchdog_enable_hardlockup_detector(bool val);
-extern bool watchdog_hardlockup_detector_is_enabled(void);
+extern void hardlockup_detector_disable(void);
 #else
-static inline void watchdog_enable_hardlockup_detector(bool val)
+static inline void hardlockup_detector_disable(void)
 {
 }
-static inline bool watchdog_hardlockup_detector_is_enabled(void)
-{
-	return true;
-}
 #endif
 
 /*

commit 195daf665a6299de98a4da3843fed2dd9de19d3a
Author: Ulrich Obergfell <uobergfe@redhat.com>
Date:   Tue Apr 14 15:44:13 2015 -0700

    watchdog: enable the new user interface of the watchdog mechanism
    
    With the current user interface of the watchdog mechanism it is only
    possible to disable or enable both lockup detectors at the same time.
    This series introduces new kernel parameters and changes the semantics of
    some existing kernel parameters, so that the hard lockup detector and the
    soft lockup detector can be disabled or enabled individually.  With this
    series applied, the user interface is as follows.
    
    - parameters in /proc/sys/kernel
    
      . soft_watchdog
        This is a new parameter to control and examine the run state of
        the soft lockup detector.
    
      . nmi_watchdog
        The semantics of this parameter have changed. It can now be used
        to control and examine the run state of the hard lockup detector.
    
      . watchdog
        This parameter is still available to control the run state of both
        lockup detectors at the same time. If this parameter is examined,
        it shows the logical OR of soft_watchdog and nmi_watchdog.
    
      . watchdog_thresh
        The semantics of this parameter are not affected by the patch.
    
    - kernel command line parameters
    
      . nosoftlockup
        The semantics of this parameter have changed. It can now be used
        to disable the soft lockup detector at boot time.
    
      . nmi_watchdog=0 or nmi_watchdog=1
        Disable or enable the hard lockup detector at boot time. The patch
        introduces '=1' as a new option.
    
      . nowatchdog
        The semantics of this parameter are not affected by the patch. It
        is still available to disable both lockup detectors at boot time.
    
    Also, remove the proc_dowatchdog() function which is no longer needed.
    
    [dzickus@redhat.com: wrote changelog]
    [dzickus@redhat.com: update documentation for kernel params and sysctl]
    Signed-off-by: Ulrich Obergfell <uobergfe@redhat.com>
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 5b5450585b8a..0426357297d5 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -82,8 +82,6 @@ extern int proc_soft_watchdog(struct ctl_table *, int ,
 			      void __user *, size_t *, loff_t *);
 extern int proc_watchdog_thresh(struct ctl_table *, int ,
 				void __user *, size_t *, loff_t *);
-extern int proc_dowatchdog(struct ctl_table *, int ,
-			   void __user *, size_t *, loff_t *);
 #endif
 
 #ifdef CONFIG_HAVE_ACPI_APEI_NMI

commit 83a80a39075a9ded23df1e26a4b617c289077630
Author: Ulrich Obergfell <uobergfe@redhat.com>
Date:   Tue Apr 14 15:44:08 2015 -0700

    watchdog: introduce separate handlers for parameters in /proc/sys/kernel
    
    Separate handlers for each watchdog parameter in /proc/sys/kernel replace
    the proc_dowatchdog() function.  Three of those handlers merely call
    proc_watchdog_common() with one different argument.
    
    Signed-off-by: Ulrich Obergfell <uobergfe@redhat.com>
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 3885a7d12bd2..5b5450585b8a 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -74,6 +74,14 @@ extern int watchdog_user_enabled;
 extern int watchdog_thresh;
 extern int sysctl_softlockup_all_cpu_backtrace;
 struct ctl_table;
+extern int proc_watchdog(struct ctl_table *, int ,
+			 void __user *, size_t *, loff_t *);
+extern int proc_nmi_watchdog(struct ctl_table *, int ,
+			     void __user *, size_t *, loff_t *);
+extern int proc_soft_watchdog(struct ctl_table *, int ,
+			      void __user *, size_t *, loff_t *);
+extern int proc_watchdog_thresh(struct ctl_table *, int ,
+				void __user *, size_t *, loff_t *);
 extern int proc_dowatchdog(struct ctl_table *, int ,
 			   void __user *, size_t *, loff_t *);
 #endif

commit 84d56e66b9b4a646f04ec30696ca1aeea5e654d5
Author: Ulrich Obergfell <uobergfe@redhat.com>
Date:   Tue Apr 14 15:43:55 2015 -0700

    watchdog: new definitions and variables, initialization
    
    The hardlockup and softockup had always been tied together.  Due to the
    request of KVM folks, they had a need to have one enabled but not the
    other.  Internally rework the code to split things apart more cleanly.
    
    There is a bunch of churn here, but the end result should be code that
    should be easier to maintain and fix without knowing the internals of what
    is going on.
    
    This patch (of 9):
    
    Introduce new definitions and variables to separate the user interface in
    /proc/sys/kernel from the internal run state of the lockup detectors.  The
    internal run state is represented by two bits in a new variable that is
    named 'watchdog_enabled'.  This helps simplify the code, for example:
    
    - In order to check if any of the two lockup detectors is enabled,
      it is sufficient to check if 'watchdog_enabled' is not zero.
    
    - In order to enable/disable one or both lockup detectors,
      it is sufficient to set/clear one or both bits in 'watchdog_enabled'.
    
    - Concurrent updates of 'watchdog_enabled' need not be synchronized via
      a spinlock or a mutex. Updates can either be atomic or concurrency can
      be detected by using 'cmpxchg'.
    
    Signed-off-by: Ulrich Obergfell <uobergfe@redhat.com>
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 9b2022ab4d85..3885a7d12bd2 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -68,6 +68,8 @@ static inline bool trigger_allbutself_cpu_backtrace(void)
 #ifdef CONFIG_LOCKUP_DETECTOR
 int hw_nmi_is_cpu_stuck(struct pt_regs *);
 u64 hw_nmi_get_sample_period(int watchdog_thresh);
+extern int nmi_watchdog_enabled;
+extern int soft_watchdog_enabled;
 extern int watchdog_user_enabled;
 extern int watchdog_thresh;
 extern int sysctl_softlockup_all_cpu_backtrace;

commit 6e7458a6f074c71e74cda31c483114e65ea0f570
Author: Ulrich Obergfell <uobergfe@redhat.com>
Date:   Mon Oct 13 15:55:35 2014 -0700

    kernel/watchdog.c: control hard lockup detection default
    
    In some cases we don't want hard lockup detection enabled by default.
    An example is when running as a guest.  Introduce
    
      watchdog_enable_hardlockup_detector(bool)
    
    allowing those cases to disable hard lockup detection.  This must be
    executed early by the boot processor from e.g.  smp_prepare_boot_cpu, in
    order to allow kernel command line arguments to override it, as well as
    to avoid hard lockup detection being enabled before we've had a chance
    to indicate that it's unwanted.  In summary,
    
      initial boot:                                 default=enabled
      smp_prepare_boot_cpu
        watchdog_enable_hardlockup_detector(false): default=disabled
      cmdline has 'nmi_watchdog=1':                 default=enabled
    
    The running kernel still has the ability to enable/disable at any time
    with /proc/sys/kernel/nmi_watchdog us usual.  However even when the
    default has been overridden /proc/sys/kernel/nmi_watchdog will initially
    show '1'.  To truly turn it on one must disable/enable it, i.e.
    
      echo 0 > /proc/sys/kernel/nmi_watchdog
      echo 1 > /proc/sys/kernel/nmi_watchdog
    
    This patch will be immediately useful for KVM with the next patch of this
    series.  Other hypervisor guest types may find it useful as well.
    
    [akpm@linux-foundation.org: fix build]
    [dzickus@redhat.com: fix compile issues on sparc]
    Signed-off-by: Ulrich Obergfell <uobergfe@redhat.com>
    Signed-off-by: Andrew Jones <drjones@redhat.com>
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 1d2a6ab6b8bb..9b2022ab4d85 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -24,6 +24,19 @@ static inline void touch_nmi_watchdog(void)
 }
 #endif
 
+#if defined(CONFIG_HARDLOCKUP_DETECTOR)
+extern void watchdog_enable_hardlockup_detector(bool val);
+extern bool watchdog_hardlockup_detector_is_enabled(void);
+#else
+static inline void watchdog_enable_hardlockup_detector(bool val)
+{
+}
+static inline bool watchdog_hardlockup_detector_is_enabled(void)
+{
+	return true;
+}
+#endif
+
 /*
  * Create trigger_all_cpu_backtrace() out of the arch-provided
  * base function. Return whether such support was available,

commit 44a69f6195628f6f940566d133a72987559e102d
Author: Tomasz Nowicki <tomasz.nowicki@linaro.org>
Date:   Tue Jul 22 11:20:12 2014 +0200

    acpi, apei, ghes: Make NMI error notification to be GHES architecture extension.
    
    Currently APEI depends on x86 architecture. It is because of NMI hardware
    error notification of GHES which is currently supported by x86 only.
    However, many other APEI features can be still used perfectly by other
    architectures.
    
    This commit adds two symbols:
    1. HAVE_ACPI_APEI for those archs which support APEI.
    2. HAVE_ACPI_APEI_NMI which is used for NMI code isolation in ghes.c
       file. NMI related data and functions are grouped so they can be wrapped
       inside one #ifdef section. Appropriate function stubs are provided for
       !NMI case.
    
    Note there is no functional changes for x86 due to hard selected
    HAVE_ACPI_APEI and HAVE_ACPI_APEI_NMI symbols.
    
    Signed-off-by: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Acked-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 447775ee2c4b..1d2a6ab6b8bb 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -63,4 +63,8 @@ extern int proc_dowatchdog(struct ctl_table *, int ,
 			   void __user *, size_t *, loff_t *);
 #endif
 
+#ifdef CONFIG_HAVE_ACPI_APEI_NMI
+#include <asm/nmi.h>
+#endif
+
 #endif

commit ed235875e2ca983197831337a986f0517074e1a0
Author: Aaron Tomlin <atomlin@redhat.com>
Date:   Mon Jun 23 13:22:05 2014 -0700

    kernel/watchdog.c: print traces for all cpus on lockup detection
    
    A 'softlockup' is defined as a bug that causes the kernel to loop in
    kernel mode for more than a predefined period to time, without giving
    other tasks a chance to run.
    
    Currently, upon detection of this condition by the per-cpu watchdog
    task, debug information (including a stack trace) is sent to the system
    log.
    
    On some occasions, we have observed that the "victim" rather than the
    actual "culprit" (i.e.  the owner/holder of the contended resource) is
    reported to the user.  Often this information has proven to be
    insufficient to assist debugging efforts.
    
    To avoid loss of useful debug information, for architectures which
    support NMI, this patch makes it possible to improve soft lockup
    reporting.  This is accomplished by issuing an NMI to each cpu to obtain
    a stack trace.
    
    If NMI is not supported we just revert back to the old method.  A sysctl
    and boot-time parameter is available to toggle this feature.
    
    [dzickus@redhat.com: add CONFIG_SMP in certain areas]
    [akpm@linux-foundation.org: additional CONFIG_SMP=n optimisations]
    [mq@suse.cz: fix warning]
    Signed-off-by: Aaron Tomlin <atomlin@redhat.com>
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Mateusz Guzik <mguzik@redhat.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Jan Moskyto Matejka <mq@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index a17ab6398d7c..447775ee2c4b 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -57,6 +57,7 @@ int hw_nmi_is_cpu_stuck(struct pt_regs *);
 u64 hw_nmi_get_sample_period(int watchdog_thresh);
 extern int watchdog_user_enabled;
 extern int watchdog_thresh;
+extern int sysctl_softlockup_all_cpu_backtrace;
 struct ctl_table;
 extern int proc_dowatchdog(struct ctl_table *, int ,
 			   void __user *, size_t *, loff_t *);

commit f3aca3d09525f87731ba6b892c9b010570bc54b4
Author: Aaron Tomlin <atomlin@redhat.com>
Date:   Mon Jun 23 13:22:05 2014 -0700

    nmi: provide the option to issue an NMI back trace to every cpu but current
    
    Sometimes it is preferred not to use the trigger_all_cpu_backtrace()
    routine when one wants to avoid capturing a back trace for current.  For
    instance if one was previously captured recently.
    
    This patch provides a new routine namely
    trigger_allbutself_cpu_backtrace() which offers the flexibility to issue
    an NMI to every cpu but current and capture a back trace accordingly.
    
    Patch x86 and sparc to support new routine.
    
    [dzickus@redhat.com: add stub in #else clause]
    [dzickus@redhat.com: don't print message in single processor case, wrap with get/put_cpu based on Oleg's suggestion]
    [sfr@canb.auug.org.au: undo C99ism]
    Signed-off-by: Aaron Tomlin <atomlin@redhat.com>
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Cc: Mateusz Guzik <mguzik@redhat.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 6a45fb583ff1..a17ab6398d7c 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -32,15 +32,24 @@ static inline void touch_nmi_watchdog(void)
 #ifdef arch_trigger_all_cpu_backtrace
 static inline bool trigger_all_cpu_backtrace(void)
 {
-	arch_trigger_all_cpu_backtrace();
+	arch_trigger_all_cpu_backtrace(true);
 
 	return true;
 }
+static inline bool trigger_allbutself_cpu_backtrace(void)
+{
+	arch_trigger_all_cpu_backtrace(false);
+	return true;
+}
 #else
 static inline bool trigger_all_cpu_backtrace(void)
 {
 	return false;
 }
+static inline bool trigger_allbutself_cpu_backtrace(void)
+{
+	return false;
+}
 #endif
 
 #ifdef CONFIG_LOCKUP_DETECTOR

commit 3c00ea82c724fab0b98f15428a804cb45eb9ad38
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Sun May 19 20:45:15 2013 +0200

    watchdog: Rename confusing state variable
    
    We have two very conflicting state variable names in the
    watchdog:
    
    * watchdog_enabled: This one reflects the user interface. It's
    set to 1 by default and can be overriden with boot options
    or sysctl/procfs interface.
    
    * watchdog_disabled: This is the internal toggle state that
    tells if watchdog threads, timers and NMI events are currently
    running or not. This state mostly depends on the user settings.
    It's a convenient state latch.
    
    Now we really need to find clearer names because those
    are just too confusing to encourage deep review.
    
    watchdog_enabled now becomes watchdog_user_enabled to reflect
    its purpose as an interface.
    
    watchdog_disabled becomes watchdog_running to suggest its
    role as a pure internal state.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Cc: Anish Singh <anish198519851985@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Li Zhong <zhong@linux.vnet.ibm.com>
    Cc: Don Zickus <dzickus@redhat.com>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index db50840e6355..6a45fb583ff1 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -46,7 +46,7 @@ static inline bool trigger_all_cpu_backtrace(void)
 #ifdef CONFIG_LOCKUP_DETECTOR
 int hw_nmi_is_cpu_stuck(struct pt_regs *);
 u64 hw_nmi_get_sample_period(int watchdog_thresh);
-extern int watchdog_enabled;
+extern int watchdog_user_enabled;
 extern int watchdog_thresh;
 struct ctl_table;
 extern int proc_dowatchdog(struct ctl_table *, int ,

commit d314d74c695f967e10598467a326f41c78ed1e20
Author: Cong Wang <xiyou.wangcong@gmail.com>
Date:   Fri Mar 23 15:01:51 2012 -0700

    nmi watchdog: do not use cpp symbol in Kconfig
    
    ARCH_HAS_NMI_WATCHDOG is a macro defined by arch, but config
    HARDLOCKUP_DETECTOR depends on it.  This is wrong, ARCH_HAS_NMI_WATCHDOG
    has to be a Kconfig config, and arch's need it should select it
    explicitly.
    
    Signed-off-by: WANG Cong <xiyou.wangcong@gmail.com>
    Acked-by: Don Zickus <dzickus@redhat.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: David Miller <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 2d304efc89df..db50840e6355 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -14,7 +14,7 @@
  * may be used to reset the timeout - for code which intentionally
  * disables interrupts for a long time. This call is stateless.
  */
-#if defined(ARCH_HAS_NMI_WATCHDOG) || defined(CONFIG_HARDLOCKUP_DETECTOR)
+#if defined(CONFIG_HAVE_NMI_WATCHDOG) || defined(CONFIG_HARDLOCKUP_DETECTOR)
 #include <asm/nmi.h>
 extern void touch_nmi_watchdog(void);
 #else

commit 4eec42f392043063d0f019640b4ccc2a45570002
Author: Mandeep Singh Baines <msb@chromium.org>
Date:   Sun May 22 22:10:23 2011 -0700

    watchdog: Change the default timeout and configure nmi watchdog period based on watchdog_thresh
    
    Before the conversion of the NMI watchdog to perf event, the
    watchdog timeout was 5 seconds. Now it is 60 seconds. For my
    particular application, netbooks, 5 seconds was a better
    timeout. With a short timeout, we catch faults earlier and are
    able to send back a panic. With a 60 second timeout, the user is
    unlikely to wait and will instead hit the power button, causing
    us to lose the panic info.
    
    This change configures the NMI period to watchdog_thresh and
    sets the softlockup_thresh to watchdog_thresh * 2. In addition,
    watchdog_thresh was reduced to 10 seconds as suggested by Ingo
    Molnar.
    
    Signed-off-by: Mandeep Singh Baines <msb@chromium.org>
    Cc: Marcin Slusarz <marcin.slusarz@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Link: http://lkml.kernel.org/r/1306127423-3347-4-git-send-email-msb@chromium.org
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    LKML-Reference: <20110517071642.GF22305@elte.hu>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 5317b8b2198f..2d304efc89df 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -45,7 +45,7 @@ static inline bool trigger_all_cpu_backtrace(void)
 
 #ifdef CONFIG_LOCKUP_DETECTOR
 int hw_nmi_is_cpu_stuck(struct pt_regs *);
-u64 hw_nmi_get_sample_period(void);
+u64 hw_nmi_get_sample_period(int watchdog_thresh);
 extern int watchdog_enabled;
 extern int watchdog_thresh;
 struct ctl_table;

commit 586692a5a5fc5740c8a46abc0f2365495c2d7c5f
Author: Mandeep Singh Baines <msb@chromium.org>
Date:   Sun May 22 22:10:22 2011 -0700

    watchdog: Disable watchdog when thresh is zero
    
    This restores the previous behavior of softlock_thresh.
    
    Currently, setting watchdog_thresh to zero causes the watchdog
    kthreads to consume a lot of CPU.
    
    In addition, the logic of proc_dowatchdog_thresh and
    proc_dowatchdog_enabled has been factored into proc_dowatchdog.
    
    Signed-off-by: Mandeep Singh Baines <msb@chromium.org>
    Cc: Marcin Slusarz <marcin.slusarz@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Link: http://lkml.kernel.org/r/1306127423-3347-3-git-send-email-msb@chromium.org
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    LKML-Reference: <20110517071018.GE22305@elte.hu>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index c536f8545f74..5317b8b2198f 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -47,9 +47,10 @@ static inline bool trigger_all_cpu_backtrace(void)
 int hw_nmi_is_cpu_stuck(struct pt_regs *);
 u64 hw_nmi_get_sample_period(void);
 extern int watchdog_enabled;
+extern int watchdog_thresh;
 struct ctl_table;
-extern int proc_dowatchdog_enabled(struct ctl_table *, int ,
-			void __user *, size_t *, loff_t *);
+extern int proc_dowatchdog(struct ctl_table *, int ,
+			   void __user *, size_t *, loff_t *);
 #endif
 
 #endif

commit 4a7863cc2eb5f9804f1c4e9156619a801cd7f14f
Author: Don Zickus <dzickus@redhat.com>
Date:   Wed Dec 22 14:00:03 2010 -0500

    x86, nmi_watchdog: Remove ARCH_HAS_NMI_WATCHDOG and rely on CONFIG_HARDLOCKUP_DETECTOR
    
    The x86 arch has shifted its use of the nmi_watchdog from a
    local implementation to the global one provide by
    kernel/watchdog.c.  This shift has caused a whole bunch of
    compile problems under different config options.  I attempt to
    simplify things with the patch below.
    
    In order to simplify things, I had to come to terms with the
    meaning of two terms ARCH_HAS_NMI_WATCHDOG and
    CONFIG_HARDLOCKUP_DETECTOR.  Basically they mean the same thing,
    the former on a local level and the latter on a global level.
    
    With the old x86 nmi watchdog gone, there is no need to rely on
    defining the ARCH_HAS_NMI_WATCHDOG variable because it doesn't
    make sense any more.  x86 will now use the global
    implementation.
    
    The changes below do a few things.  First it changes the few
    places that relied on ARCH_HAS_NMI_WATCHDOG to use
    CONFIG_X86_LOCAL_APIC (the former was an alias for the latter
    anyway, so nothing unusual here).  Those pieces of code were
    relying more on local apic functionality the nmi watchdog
    functionality, so the change should make sense.
    
    Second, I removed the x86 implementation of
    touch_nmi_watchdog().  It isn't need now, instead x86 will rely
    on kernel/watchdog.c's implementation.
    
    Third, I removed the #define ARCH_HAS_NMI_WATCHDOG itself from
    x86.  And tweaked the include/linux/nmi.h file to tell users to
    look for an externally defined touch_nmi_watchdog in the case of
    ARCH_HAS_NMI_WATCHDOG _or_ CONFIG_HARDLOCKUP_DETECTOR. This
    changes removes some of the ugliness in that file.
    
    Finally, I added a Kconfig dependency for
    CONFIG_HARDLOCKUP_DETECTOR that said you can't have
    ARCH_HAS_NMI_WATCHDOG _and_ CONFIG_HARDLOCKUP_DETECTOR.  You can
    only have one nmi_watchdog.
    
    Tested with
    ARCH=i386: allnoconfig, defconfig, allyesconfig, (various broken
    configs) ARCH=x86_64: allnoconfig, defconfig, allyesconfig,
    (various broken configs)
    
    Hopefully, after this patch I won't get any more compile broken
    emails. :-)
    
    v3:
      changed a couple of 'linux/nmi.h' -> 'asm/nmi.h' to pick-up correct function
      prototypes when CONFIG_HARDLOCKUP_DETECTOR is not set.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: fweisbec@gmail.com
    LKML-Reference: <1293044403-14117-1-git-send-email-dzickus@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 17ccf44e7dcb..c536f8545f74 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -14,18 +14,14 @@
  * may be used to reset the timeout - for code which intentionally
  * disables interrupts for a long time. This call is stateless.
  */
-#ifdef ARCH_HAS_NMI_WATCHDOG
+#if defined(ARCH_HAS_NMI_WATCHDOG) || defined(CONFIG_HARDLOCKUP_DETECTOR)
 #include <asm/nmi.h>
 extern void touch_nmi_watchdog(void);
 #else
-#ifndef CONFIG_HARDLOCKUP_DETECTOR
 static inline void touch_nmi_watchdog(void)
 {
 	touch_softlockup_watchdog();
 }
-#else
-extern void touch_nmi_watchdog(void);
-#endif
 #endif
 
 /*

commit 96a84c20d635fb1e98ab92f9fc517c4441f5c424
Author: Don Zickus <dzickus@redhat.com>
Date:   Mon Nov 29 17:07:16 2010 -0500

    lockup detector: Compile fixes from removing the old x86 nmi watchdog
    
    My patch that removed the old x86 nmi watchdog broke other
    arches.  This change reverts a piece of that patch and puts the
    change in the correct spot.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Reviewed-by: Cyrill Gorcunov <gorcunov@gmail.com>
    Cc: fweisbec@gmail.com
    Cc: yinghai@kernel.org
    LKML-Reference: <1291068437-5331-2-git-send-email-dzickus@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 1c451e6ecc17..17ccf44e7dcb 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -16,7 +16,8 @@
  */
 #ifdef ARCH_HAS_NMI_WATCHDOG
 #include <asm/nmi.h>
-#endif
+extern void touch_nmi_watchdog(void);
+#else
 #ifndef CONFIG_HARDLOCKUP_DETECTOR
 static inline void touch_nmi_watchdog(void)
 {
@@ -25,6 +26,7 @@ static inline void touch_nmi_watchdog(void)
 #else
 extern void touch_nmi_watchdog(void);
 #endif
+#endif
 
 /*
  * Create trigger_all_cpu_backtrace() out of the arch-provided

commit 072b198a4ad48bd722ec6d203d65422a4698eae7
Author: Don Zickus <dzickus@redhat.com>
Date:   Fri Nov 12 11:22:24 2010 -0500

    x86, nmi_watchdog: Remove all stub function calls from old nmi_watchdog
    
    Now that the bulk of the old nmi_watchdog is gone, remove all
    the stub variables and hooks associated with it.
    
    This touches lots of files mainly because of how the io_apic
    nmi_watchdog was implemented.  Now that the io_apic nmi_watchdog
    is forever gone, remove all its fingers.
    
    Most of this code was not being exercised by virtue of
    nmi_watchdog != NMI_IO_APIC, so there shouldn't be anything to
    risky here.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: fweisbec@gmail.com
    Cc: gorcunov@openvz.org
    LKML-Reference: <1289578944-28564-3-git-send-email-dzickus@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 0cb3e5c246d0..1c451e6ecc17 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -25,8 +25,6 @@ static inline void touch_nmi_watchdog(void)
 #else
 extern void touch_nmi_watchdog(void);
 #endif
-static inline void acpi_nmi_disable(void) { }
-static inline void acpi_nmi_enable(void) { }
 
 /*
  * Create trigger_all_cpu_backtrace() out of the arch-provided

commit 5f2b0ba4d94b3ac23cbc4b7f675d98eb677a760a
Author: Don Zickus <dzickus@redhat.com>
Date:   Fri Nov 12 11:22:23 2010 -0500

    x86, nmi_watchdog: Remove the old nmi_watchdog
    
    Now that we have a new nmi_watchdog that is more generic and
    sits on top of the perf subsystem, we really do not need the old
    nmi_watchdog any more.
    
    In addition, the old nmi_watchdog doesn't really work if you are
    using the default clocksource, hpet.  The old nmi_watchdog code
    relied on local apic interrupts to determine if the cpu is still
    alive.  With hpet as the clocksource, these interrupts don't
    increment any more and the old nmi_watchdog triggers false
    postives.
    
    This piece removes the old nmi_watchdog code and stubs out any
    variables and functions calls.  The stubs are the same ones used
    by the new nmi_watchdog code, so it should be well tested.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: fweisbec@gmail.com
    Cc: gorcunov@openvz.org
    LKML-Reference: <1289578944-28564-2-git-send-email-dzickus@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 06aab5eee134..0cb3e5c246d0 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -16,10 +16,7 @@
  */
 #ifdef ARCH_HAS_NMI_WATCHDOG
 #include <asm/nmi.h>
-extern void touch_nmi_watchdog(void);
-extern void acpi_nmi_disable(void);
-extern void acpi_nmi_enable(void);
-#else
+#endif
 #ifndef CONFIG_HARDLOCKUP_DETECTOR
 static inline void touch_nmi_watchdog(void)
 {
@@ -30,7 +27,6 @@ extern void touch_nmi_watchdog(void);
 #endif
 static inline void acpi_nmi_disable(void) { }
 static inline void acpi_nmi_enable(void) { }
-#endif
 
 /*
  * Create trigger_all_cpu_backtrace() out of the arch-provided

commit cafcd80d216bc2136b8edbb794327e495792c666
Author: Don Zickus <dzickus@redhat.com>
Date:   Fri May 14 11:11:21 2010 -0400

    lockup_detector: Cross arch compile fixes
    
    Combining the softlockup and hardlockup code causes watchdog.c
    to build even without the hardlockup detection support.
    
    So if an arch, that has the previous and the new nmi watchdog
    implementations cohabiting, wants to know if the generic one
    is in use, CONFIG_LOCKUP_DETECTOR is not a reliable check.
    We need to use CONFIG_HARDLOCKUP_DETECTOR instead.
    
    Fixes:
            kernel/built-in.o: In function `touch_nmi_watchdog':
            (.text+0x449bc): multiple definition of `touch_nmi_watchdog'
            arch/sparc/kernel/built-in.o:(.text+0x11b28): first defined here
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Cyrill Gorcunov <gorcunov@gmail.com>
    LKML-Reference: <20100514151121.GR15159@redhat.com>
    [ use CONFIG_HARDLOCKUP_DETECTOR instead of CONFIG_PERF_EVENTS_NMI]
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index abd48aacaf79..06aab5eee134 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -20,7 +20,7 @@ extern void touch_nmi_watchdog(void);
 extern void acpi_nmi_disable(void);
 extern void acpi_nmi_enable(void);
 #else
-#ifndef CONFIG_LOCKUP_DETECTOR
+#ifndef CONFIG_HARDLOCKUP_DETECTOR
 static inline void touch_nmi_watchdog(void)
 {
 	touch_softlockup_watchdog();

commit 58687acba59266735adb8ccd9b5b9aa2c7cd205b
Author: Don Zickus <dzickus@redhat.com>
Date:   Fri May 7 17:11:44 2010 -0400

    lockup_detector: Combine nmi_watchdog and softlockup detector
    
    The new nmi_watchdog (which uses the perf event subsystem) is very
    similar in structure to the softlockup detector.  Using Ingo's
    suggestion, I combined the two functionalities into one file:
    kernel/watchdog.c.
    
    Now both the nmi_watchdog (or hardlockup detector) and softlockup
    detector sit on top of the perf event subsystem, which is run every
    60 seconds or so to see if there are any lockups.
    
    To detect hardlockups, cpus not responding to interrupts, I
    implemented an hrtimer that runs 5 times for every perf event
    overflow event.  If that stops counting on a cpu, then the cpu is
    most likely in trouble.
    
    To detect softlockups, tasks not yielding to the scheduler, I used the
    previous kthread idea that now gets kicked every time the hrtimer fires.
    If the kthread isn't being scheduled neither is anyone else and the
    warning is printed to the console.
    
    I tested this on x86_64 and both the softlockup and hardlockup paths
    work.
    
    V2:
    - cleaned up the Kconfig and softlockup combination
    - surrounded hardlockup cases with #ifdef CONFIG_PERF_EVENTS_NMI
    - seperated out the softlockup case from perf event subsystem
    - re-arranged the enabling/disabling nmi watchdog from proc space
    - added cpumasks for hardlockup failure cases
    - removed fallback to soft events if no PMU exists for hard events
    
    V3:
    - comment cleanups
    - drop support for older softlockup code
    - per_cpu cleanups
    - completely remove software clock base hardlockup detector
    - use per_cpu masking on hard/soft lockup detection
    - #ifdef cleanups
    - rename config option NMI_WATCHDOG to LOCKUP_DETECTOR
    - documentation additions
    
    V4:
    - documentation fixes
    - convert per_cpu to __get_cpu_var
    - powerpc compile fixes
    
    V5:
    - split apart warn flags for hard and soft lockups
    
    TODO:
    - figure out how to make an arch-agnostic clock2cycles call
      (if possible) to feed into perf events as a sample period
    
    [fweisbec: merged conflict patch]
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Cyrill Gorcunov <gorcunov@gmail.com>
    Cc: Eric Paris <eparis@redhat.com>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    LKML-Reference: <1273266711-18706-2-git-send-email-dzickus@redhat.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 22cc7960b649..abd48aacaf79 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -20,7 +20,7 @@ extern void touch_nmi_watchdog(void);
 extern void acpi_nmi_disable(void);
 extern void acpi_nmi_enable(void);
 #else
-#ifndef CONFIG_NMI_WATCHDOG
+#ifndef CONFIG_LOCKUP_DETECTOR
 static inline void touch_nmi_watchdog(void)
 {
 	touch_softlockup_watchdog();
@@ -51,12 +51,12 @@ static inline bool trigger_all_cpu_backtrace(void)
 }
 #endif
 
-#ifdef CONFIG_NMI_WATCHDOG
+#ifdef CONFIG_LOCKUP_DETECTOR
 int hw_nmi_is_cpu_stuck(struct pt_regs *);
 u64 hw_nmi_get_sample_period(void);
-extern int nmi_watchdog_enabled;
+extern int watchdog_enabled;
 struct ctl_table;
-extern int proc_nmi_enabled(struct ctl_table *, int ,
+extern int proc_dowatchdog_enabled(struct ctl_table *, int ,
 			void __user *, size_t *, loff_t *);
 #endif
 

commit 47195d57636604ff6048b0d7aa3e4ed9643f6073
Author: Don Zickus <dzickus@redhat.com>
Date:   Mon Feb 22 18:09:03 2010 -0500

    nmi_watchdog: Clean up various small details
    
    Mostly copy/paste whitespace damage with a couple of nitpicks by
    the checkpatch script. Fix the struct definition as requested by Ingo too.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: peterz@infradead.org
    Cc: gorcunov@gmail.com
    Cc: aris@redhat.com
    LKML-Reference: <1266880143-24943-1-git-send-email-dzickus@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    --
     arch/x86/kernel/apic/hw_nmi.c |   14 +++++------
     arch/x86/kernel/traps.c       |    6 ++--
     include/linux/nmi.h           |    2 -
     kernel/nmi_watchdog.c         |   51 ++++++++++++++++++++----------------------
     4 files changed, 36 insertions(+), 37 deletions(-)

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 794e7354c5bf..22cc7960b649 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -57,7 +57,7 @@ u64 hw_nmi_get_sample_period(void);
 extern int nmi_watchdog_enabled;
 struct ctl_table;
 extern int proc_nmi_enabled(struct ctl_table *, int ,
-                        void __user *, size_t *, loff_t *);
+			void __user *, size_t *, loff_t *);
 #endif
 
 #endif

commit 504d7cf10ee42bb76b9556859f23d4121dee0a77
Author: Don Zickus <dzickus@redhat.com>
Date:   Fri Feb 12 17:19:19 2010 -0500

    nmi_watchdog: Compile and portability fixes
    
    The original patch was x86_64 centric.  Changed the code to make
    it less so.
    
    ested by building and running on a powerpc.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: peterz@infradead.org
    Cc: gorcunov@gmail.com
    Cc: aris@redhat.com
    LKML-Reference: <1266013161-31197-2-git-send-email-dzickus@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index a42ff0bef708..794e7354c5bf 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -20,10 +20,14 @@ extern void touch_nmi_watchdog(void);
 extern void acpi_nmi_disable(void);
 extern void acpi_nmi_enable(void);
 #else
+#ifndef CONFIG_NMI_WATCHDOG
 static inline void touch_nmi_watchdog(void)
 {
 	touch_softlockup_watchdog();
 }
+#else
+extern void touch_nmi_watchdog(void);
+#endif
 static inline void acpi_nmi_disable(void) { }
 static inline void acpi_nmi_enable(void) { }
 #endif
@@ -49,6 +53,11 @@ static inline bool trigger_all_cpu_backtrace(void)
 
 #ifdef CONFIG_NMI_WATCHDOG
 int hw_nmi_is_cpu_stuck(struct pt_regs *);
+u64 hw_nmi_get_sample_period(void);
+extern int nmi_watchdog_enabled;
+struct ctl_table;
+extern int proc_nmi_enabled(struct ctl_table *, int ,
+                        void __user *, size_t *, loff_t *);
 #endif
 
 #endif

commit 84e478c6f1eb9c4bfa1fff2f8108e9a061b46428
Author: Don Zickus <dzickus@redhat.com>
Date:   Fri Feb 5 21:47:05 2010 -0500

    nmi_watchdog: Config option to enable new nmi_watchdog
    
    These are the bits that enable the new nmi_watchdog and safely
    isolate the old nmi_watchdog.  Only one or the other can run,
    not both at the same time.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: gorcunov@gmail.com
    Cc: aris@redhat.com
    Cc: peterz@infradead.org
    LKML-Reference: <1265424425-31562-4-git-send-email-dzickus@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index b752e807adde..a42ff0bef708 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -47,4 +47,8 @@ static inline bool trigger_all_cpu_backtrace(void)
 }
 #endif
 
+#ifdef CONFIG_NMI_WATCHDOG
+int hw_nmi_is_cpu_stuck(struct pt_regs *);
+#endif
+
 #endif

commit 47cab6a722d44c71c4f8224017ef548522243cf4
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Aug 3 09:31:54 2009 +0200

    debug lockups: Improve lockup detection, fix generic arch fallback
    
    As Andrew noted, my previous patch ("debug lockups: Improve lockup
    detection") broke/removed SysRq-L support from architecture that do
    not provide a __trigger_all_cpu_backtrace implementation.
    
    Restore a fallback path and clean up the SysRq-L machinery a bit:
    
     - Rename the arch method to arch_trigger_all_cpu_backtrace()
    
     - Simplify the define
    
     - Document the method a bit - in the hope of more architectures
       adding support for it.
    
    [ The patch touches Sparc code for the rename. ]
    
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    LKML-Reference: <20090802140809.7ec4bb6b.akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index 29af2d5df097..b752e807adde 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -28,8 +28,23 @@ static inline void acpi_nmi_disable(void) { }
 static inline void acpi_nmi_enable(void) { }
 #endif
 
-#ifndef trigger_all_cpu_backtrace
-#define trigger_all_cpu_backtrace() do { } while (0)
+/*
+ * Create trigger_all_cpu_backtrace() out of the arch-provided
+ * base function. Return whether such support was available,
+ * to allow calling code to fall back to some other mechanism:
+ */
+#ifdef arch_trigger_all_cpu_backtrace
+static inline bool trigger_all_cpu_backtrace(void)
+{
+	arch_trigger_all_cpu_backtrace();
+
+	return true;
+}
+#else
+static inline bool trigger_all_cpu_backtrace(void)
+{
+	return false;
+}
 #endif
 
 #endif

commit 5d0e600d903caa09e790824cc5812f0d97113b23
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Feb 13 13:26:24 2007 +0100

    [PATCH] x86: fix laptop bootup hang in init_acpi()
    
    During kernel bootup, a new T60 laptop (CoreDuo, 32-bit) hangs about
    10%-20% of the time in acpi_init():
    
     Calling initcall 0xc055ce1a: topology_init+0x0/0x2f()
     Calling initcall 0xc055d75e: mtrr_init_finialize+0x0/0x2c()
     Calling initcall 0xc05664f3: param_sysfs_init+0x0/0x175()
     Calling initcall 0xc014cb65: pm_sysrq_init+0x0/0x17()
     Calling initcall 0xc0569f99: init_bio+0x0/0xf4()
     Calling initcall 0xc056b865: genhd_device_init+0x0/0x50()
     Calling initcall 0xc056c4bd: fbmem_init+0x0/0x87()
     Calling initcall 0xc056dd74: acpi_init+0x0/0x1ee()
    
    It's a hard hang that not even an NMI could punch through!  Frustratingly,
    adding printks or function tracing to the ACPI code made the hangs go away
    ...
    
    After some time an additional detail emerged: disabling the NMI watchdog
    made these occasional hangs go away.
    
    So i spent the better part of today trying to debug this and trying out
    various theories when i finally found the likely reason for the hang: if
    acpi_ns_initialize_devices() executes an _INI AML method and an NMI
    happens to hit that AML execution in the wrong moment, the machine would
    hang.  (my theory is that this must be some sort of chipset setup method
    doing stores to chipset mmio registers?)
    
    Unfortunately given the characteristics of the hang it was sheer
    impossible to figure out which of the numerous AML methods is impacted
    by this problem.
    
    As a workaround i wrote an interface to disable chipset-based NMIs while
    executing _INI sections - and indeed this fixed the hang.  I did a
    boot-loop of 100 separate reboots and none hung - while without the patch
    it would hang every 5-10 attempts.  Out of caution i did not touch the
    nmi_watchdog=2 case (it's not related to the chipset anyway and didnt
    hang).
    
    I implemented this for both x86_64 and i686, tested the i686 laptop both
    with nmi_watchdog=1 [which triggered the hangs] and nmi_watchdog=2, and
    tested an Athlon64 box with the 64-bit kernel as well. Everything builds
    and works with the patch applied.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andi Kleen <ak@suse.de>
    Cc: Andi Kleen <ak@suse.de>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index acb4ed130247..29af2d5df097 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -17,8 +17,15 @@
 #ifdef ARCH_HAS_NMI_WATCHDOG
 #include <asm/nmi.h>
 extern void touch_nmi_watchdog(void);
+extern void acpi_nmi_disable(void);
+extern void acpi_nmi_enable(void);
 #else
-# define touch_nmi_watchdog() touch_softlockup_watchdog()
+static inline void touch_nmi_watchdog(void)
+{
+	touch_softlockup_watchdog();
+}
+static inline void acpi_nmi_disable(void) { }
+static inline void acpi_nmi_enable(void) { }
 #endif
 
 #ifndef trigger_all_cpu_backtrace

commit bb81a09e55eaf7e5f798468ab971469b6f66a259
Author: Andrew Morton <akpm@osdl.org>
Date:   Thu Dec 7 02:14:01 2006 +0100

    [PATCH] x86: all cpu backtrace
    
    When a spinlock lockup occurs, arrange for the NMI code to emit an all-cpu
    backtrace, so we get to see which CPU is holding the lock, and where.
    
    Cc: Andi Kleen <ak@muc.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Badari Pulavarty <pbadari@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Andi Kleen <ak@suse.de>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index e16904e28c3a..acb4ed130247 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -15,9 +15,14 @@
  * disables interrupts for a long time. This call is stateless.
  */
 #ifdef ARCH_HAS_NMI_WATCHDOG
+#include <asm/nmi.h>
 extern void touch_nmi_watchdog(void);
 #else
 # define touch_nmi_watchdog() touch_softlockup_watchdog()
 #endif
 
+#ifndef trigger_all_cpu_backtrace
+#define trigger_all_cpu_backtrace() do { } while (0)
+#endif
+
 #endif

commit 9938406ab6b2558d60c0c7200cc8e12f1ea7104a
Author: Michal Schmidt <xschmi00@stud.feec.vutbr.cz>
Date:   Fri Sep 29 01:59:03 2006 -0700

    [PATCH] Make touch_nmi_watchdog imply touch_softlockup_watchdog on all archs
    
    touch_nmi_watchdog() calls touch_softlockup_watchdog() on both
    architectures that implement it (i386 and x86_64).  On other architectures
    it does nothing at all.  touch_nmi_watchdog() should imply
    touch_softlockup_watchdog() on all architectures.  Suggested by Andi Kleen.
    
    [heiko.carstens@de.ibm.com: s390 fix]
    Signed-off-by: Michal Schmidt <xschmi00@stud.feec.vutbr.cz>
    Cc: Andi Kleen <ak@muc.de>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Michal Schmidt <xschmi00@stud.feec.vutbr.cz>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index c8f4d2f627d7..e16904e28c3a 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -4,6 +4,7 @@
 #ifndef LINUX_NMI_H
 #define LINUX_NMI_H
 
+#include <linux/sched.h>
 #include <asm/irq.h>
 
 /**
@@ -16,7 +17,7 @@
 #ifdef ARCH_HAS_NMI_WATCHDOG
 extern void touch_nmi_watchdog(void);
 #else
-# define touch_nmi_watchdog() do { } while(0)
+# define touch_nmi_watchdog() touch_softlockup_watchdog()
 #endif
 
 #endif

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/nmi.h b/include/linux/nmi.h
new file mode 100644
index 000000000000..c8f4d2f627d7
--- /dev/null
+++ b/include/linux/nmi.h
@@ -0,0 +1,22 @@
+/*
+ *  linux/include/linux/nmi.h
+ */
+#ifndef LINUX_NMI_H
+#define LINUX_NMI_H
+
+#include <asm/irq.h>
+
+/**
+ * touch_nmi_watchdog - restart NMI watchdog timeout.
+ * 
+ * If the architecture supports the NMI watchdog, touch_nmi_watchdog()
+ * may be used to reset the timeout - for code which intentionally
+ * disables interrupts for a long time. This call is stateless.
+ */
+#ifdef ARCH_HAS_NMI_WATCHDOG
+extern void touch_nmi_watchdog(void);
+#else
+# define touch_nmi_watchdog() do { } while(0)
+#endif
+
+#endif
