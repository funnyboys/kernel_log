commit 4951d27b099bd24f87a093f67d91618742bd3a65
Author: Bumsik Kim <kbumsik@gmail.com>
Date:   Fri Apr 3 12:15:07 2020 +0900

    watchdog: clarify that stop() is optional
    
    The commit d0684c8a9354 ("watchdog: Make stop function optional")
    made stop function not mandatory, but the comments
    and the doc weren't reflected. Fix it to clarify.
    
    Signed-off-by: Bumsik Kim <k.bumsik@gmail.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Link: https://lore.kernel.org/r/20200403031507.63487-1-k.bumsik@gmail.com
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 417d9f37077a..1464ce6ffa31 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -37,15 +37,15 @@ struct watchdog_governor;
  *
  * The watchdog_ops structure contains a list of low-level operations
  * that control a watchdog device. It also contains the module that owns
- * these operations. The start and stop function are mandatory, all other
+ * these operations. The start function is mandatory, all other
  * functions are optional.
  */
 struct watchdog_ops {
 	struct module *owner;
 	/* mandatory operations */
 	int (*start)(struct watchdog_device *);
-	int (*stop)(struct watchdog_device *);
 	/* optional operations */
+	int (*stop)(struct watchdog_device *);
 	int (*ping)(struct watchdog_device *);
 	unsigned int (*status)(struct watchdog_device *);
 	int (*set_timeout)(struct watchdog_device *, unsigned int);

commit e1b83a31c79811409023aac560d5b0fc2967bec9
Author: Hardik Singh Rathore <hardiksingh.k@gmail.com>
Date:   Sun Dec 9 16:17:26 2018 +0530

    Watchdog: remove outdated comment
    
    The lock field doesn't exist in watchdog_device structure.
    It was added by commit f4e9c82f64b5 ("watchdog: Add Locking support")
    and removed by commit b4ffb1909843
    ("watchdog: Separate and maintain variables based on variable lifetime")
    
    Signed-off-by: Hardik Singh Rathore <hardiksingh.k@gmail.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@linux-watchdog.org>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 44985c4a1e86..417d9f37077a 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -90,9 +90,6 @@ struct watchdog_ops {
  *
  * The driver-data field may not be accessed directly. It must be accessed
  * via the watchdog_set_drvdata and watchdog_get_drvdata helpers.
- *
- * The lock field is for watchdog core internal use only and should not be
- * touched.
  */
 struct watchdog_device {
 	int id;

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index a786e5e8973b..44985c4a1e86 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  *	Generic watchdog defines. Derived from..
  *

commit bb292ac1c6028344013309a309b44dc691581825
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Wed Jan 25 14:21:10 2017 -0800

    watchdog: Introduce watchdog_stop_on_unregister helper
    
    Many watchdog drivers explicitly stop the watchdog when unregistering it.
    While it is unclear if this is actually needed (the whatdog should not be
    running at that time if it can be stopped), introduce a helper to
    explicitly stop the watchdog in the watchdog core when unregistering it.
    This helps reducing driver code size while retaining functionality.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 35a4d8185b51..a786e5e8973b 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -117,6 +117,7 @@ struct watchdog_device {
 #define WDOG_NO_WAY_OUT		1	/* Is 'nowayout' feature set ? */
 #define WDOG_STOP_ON_REBOOT	2	/* Should be stopped on reboot */
 #define WDOG_HW_RUNNING		3	/* True if HW watchdog running */
+#define WDOG_STOP_ON_UNREGISTER	4	/* Should be stopped on unregister */
 	struct list_head deferred;
 };
 
@@ -151,6 +152,12 @@ static inline void watchdog_stop_on_reboot(struct watchdog_device *wdd)
 	set_bit(WDOG_STOP_ON_REBOOT, &wdd->status);
 }
 
+/* Use the following function to stop the watchdog when unregistering it */
+static inline void watchdog_stop_on_unregister(struct watchdog_device *wdd)
+{
+	set_bit(WDOG_STOP_ON_UNREGISTER, &wdd->status);
+}
+
 /* Use the following function to check if a timeout value is invalid */
 static inline bool watchdog_timeout_invalid(struct watchdog_device *wdd, unsigned int t)
 {

commit ff84136cb6a4943f489ad037fe93f43be0573c23
Author: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
Date:   Fri Oct 7 15:39:54 2016 +0300

    watchdog: add watchdog pretimeout governor framework
    
    The change adds a simple watchdog pretimeout framework infrastructure,
    its purpose is to allow users to select a desired handling of watchdog
    pretimeout events, which may be generated by some watchdog devices.
    
    A user selects a default watchdog pretimeout governor during
    compilation stage.
    
    Watchdogs with WDIOF_PRETIMEOUT capability now have one more device
    attribute in sysfs, pretimeout_governor attribute is intended to display
    the selected watchdog pretimeout governor.
    
    The framework has no impact at runtime on watchdog devices with no
    WDIOF_PRETIMEOUT capability set.
    
    Signed-off-by: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Reviewed-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Tested-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 4035df7ec023..35a4d8185b51 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -19,6 +19,7 @@
 struct watchdog_ops;
 struct watchdog_device;
 struct watchdog_core_data;
+struct watchdog_governor;
 
 /** struct watchdog_ops - The watchdog-devices operations
  *
@@ -61,6 +62,7 @@ struct watchdog_ops {
  *		watchdog device.
  * @info:	Pointer to a watchdog_info structure.
  * @ops:	Pointer to the list of watchdog operations.
+ * @gov:	Pointer to watchdog pretimeout governor.
  * @bootstatus:	Status of the watchdog device at boot.
  * @timeout:	The watchdog devices timeout value (in seconds).
  * @pretimeout: The watchdog devices pre_timeout value.
@@ -97,6 +99,7 @@ struct watchdog_device {
 	const struct attribute_group **groups;
 	const struct watchdog_info *info;
 	const struct watchdog_ops *ops;
+	const struct watchdog_governor *gov;
 	unsigned int bootstatus;
 	unsigned int timeout;
 	unsigned int pretimeout;
@@ -185,6 +188,16 @@ static inline void *watchdog_get_drvdata(struct watchdog_device *wdd)
 	return wdd->driver_data;
 }
 
+/* Use the following functions to report watchdog pretimeout event */
+#if IS_ENABLED(CONFIG_WATCHDOG_PRETIMEOUT_GOV)
+void watchdog_notify_pretimeout(struct watchdog_device *wdd);
+#else
+static inline void watchdog_notify_pretimeout(struct watchdog_device *wdd)
+{
+	pr_alert("watchdog%d: pretimeout event\n", wdd->id);
+}
+#endif
+
 /* drivers/watchdog/watchdog_core.c */
 void watchdog_set_restart_priority(struct watchdog_device *wdd, int priority);
 extern int watchdog_init_timeout(struct watchdog_device *wdd,

commit df044e02206230c7d79a9aef96a6c087476f5533
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Wed Aug 31 14:52:41 2016 +0300

    watchdog: add pretimeout support to the core
    
    Since the watchdog framework centrializes the IOCTL interfaces of device
    drivers now, SETPRETIMEOUT and GETPRETIMEOUT need to be added in the
    common code.
    
    Signed-off-by: Robin Gong <b38343@freescale.com>
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    [vzapolskiy: added conditional pretimeout sysfs attribute visibility]
    Signed-off-by: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 7047bc7f8106..4035df7ec023 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -28,6 +28,7 @@ struct watchdog_core_data;
  * @ping:	The routine that sends a keepalive ping to the watchdog device.
  * @status:	The routine that shows the status of the watchdog device.
  * @set_timeout:The routine for setting the watchdog devices timeout value (in seconds).
+ * @set_pretimeout:The routine for setting the watchdog devices pretimeout.
  * @get_timeleft:The routine that gets the time left before a reset (in seconds).
  * @restart:	The routine for restarting the machine.
  * @ioctl:	The routines that handles extra ioctl calls.
@@ -46,6 +47,7 @@ struct watchdog_ops {
 	int (*ping)(struct watchdog_device *);
 	unsigned int (*status)(struct watchdog_device *);
 	int (*set_timeout)(struct watchdog_device *, unsigned int);
+	int (*set_pretimeout)(struct watchdog_device *, unsigned int);
 	unsigned int (*get_timeleft)(struct watchdog_device *);
 	int (*restart)(struct watchdog_device *, unsigned long, void *);
 	long (*ioctl)(struct watchdog_device *, unsigned int, unsigned long);
@@ -61,6 +63,7 @@ struct watchdog_ops {
  * @ops:	Pointer to the list of watchdog operations.
  * @bootstatus:	Status of the watchdog device at boot.
  * @timeout:	The watchdog devices timeout value (in seconds).
+ * @pretimeout: The watchdog devices pre_timeout value.
  * @min_timeout:The watchdog devices minimum timeout value (in seconds).
  * @max_timeout:The watchdog devices maximum timeout value (in seconds)
  *		as configurable from user space. Only relevant if
@@ -96,6 +99,7 @@ struct watchdog_device {
 	const struct watchdog_ops *ops;
 	unsigned int bootstatus;
 	unsigned int timeout;
+	unsigned int pretimeout;
 	unsigned int min_timeout;
 	unsigned int max_timeout;
 	unsigned int min_hw_heartbeat_ms;
@@ -163,6 +167,13 @@ static inline bool watchdog_timeout_invalid(struct watchdog_device *wdd, unsigne
 		 t > wdd->max_timeout);
 }
 
+/* Use the following function to check if a pretimeout value is invalid */
+static inline bool watchdog_pretimeout_invalid(struct watchdog_device *wdd,
+					       unsigned int t)
+{
+	return t && wdd->timeout && t >= wdd->timeout;
+}
+
 /* Use the following functions to manipulate watchdog driver specific data */
 static inline void watchdog_set_drvdata(struct watchdog_device *wdd, void *data)
 {

commit f9f535c1b76128f94dae7a4bb41464aacd4c10ec
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Fri May 27 14:19:06 2016 -0700

    watchdog: Improve description of min_hw_heartbeat_ms
    
    The description of min_hw_heartbeat_ms is misleading and needs some
    improvements.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 6b75e38b683f..7047bc7f8106 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -66,7 +66,8 @@ struct watchdog_ops {
  *		as configurable from user space. Only relevant if
  *		max_hw_heartbeat_ms is not provided.
  * @min_hw_heartbeat_ms:
- *		Minimum time between heartbeats, in milli-seconds.
+ *		Hardware limit for minimum time between heartbeats,
+ *		in milli-seconds.
  * @max_hw_heartbeat_ms:
  *		Hardware limit for maximum timeout, in milli-seconds.
  *		Replaces max_timeout if specified.

commit 83fbae5a148cc1cd53e5be1a28edb3b6701b7af2
Author: Neil Armstrong <narmstrong@baylibre.com>
Date:   Fri May 27 17:33:54 2016 +0200

    watchdog: Add a device managed API for watchdog_register_device()
    
    This helps in reducing code in .remove callbacks and sometimes
    dropping .remove callbacks entirely.
    
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 51732d6c9555..6b75e38b683f 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -180,4 +180,7 @@ extern int watchdog_init_timeout(struct watchdog_device *wdd,
 extern int watchdog_register_device(struct watchdog_device *);
 extern void watchdog_unregister_device(struct watchdog_device *);
 
+/* devres register variant */
+int devm_watchdog_register_device(struct device *dev, struct watchdog_device *);
+
 #endif  /* ifndef _LINUX_WATCHDOG_H */

commit 15013ad813f6544be8e79afc23672745950d59bc
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sun Feb 28 13:12:18 2016 -0800

    watchdog: Add support for minimum time between heartbeats
    
    Some watchdogs require a minimum time between heartbeats.
    Examples are the watchdogs in DA9062 and AT91SAM9x.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index e2f45549b243..51732d6c9555 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -65,6 +65,8 @@ struct watchdog_ops {
  * @max_timeout:The watchdog devices maximum timeout value (in seconds)
  *		as configurable from user space. Only relevant if
  *		max_hw_heartbeat_ms is not provided.
+ * @min_hw_heartbeat_ms:
+ *		Minimum time between heartbeats, in milli-seconds.
  * @max_hw_heartbeat_ms:
  *		Hardware limit for maximum timeout, in milli-seconds.
  *		Replaces max_timeout if specified.
@@ -95,6 +97,7 @@ struct watchdog_device {
 	unsigned int timeout;
 	unsigned int min_timeout;
 	unsigned int max_timeout;
+	unsigned int min_hw_heartbeat_ms;
 	unsigned int max_hw_heartbeat_ms;
 	struct notifier_block reboot_nb;
 	struct notifier_block restart_nb;

commit ee142889e32f564f9b5e57b68b06693ec5473074
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sun Feb 28 13:12:16 2016 -0800

    watchdog: Introduce WDOG_HW_RUNNING flag
    
    The WDOG_HW_RUNNING flag is expected to be set by watchdog drivers if
    the hardware watchdog is running. If the flag is set, the watchdog
    subsystem will ping the watchdog even if the watchdog device is closed.
    
    The watchdog driver stop function is now optional and may be omitted
    if the watchdog can not be stopped. If stopping the watchdog is not
    possible but the driver implements a stop function, it is responsible
    to set the WDOG_HW_RUNNING flag in its stop function.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 8e82daecb7d3..e2f45549b243 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -105,6 +105,7 @@ struct watchdog_device {
 #define WDOG_ACTIVE		0	/* Is the watchdog running/active */
 #define WDOG_NO_WAY_OUT		1	/* Is 'nowayout' feature set ? */
 #define WDOG_STOP_ON_REBOOT	2	/* Should be stopped on reboot */
+#define WDOG_HW_RUNNING		3	/* True if HW watchdog running */
 	struct list_head deferred;
 };
 
@@ -117,6 +118,15 @@ static inline bool watchdog_active(struct watchdog_device *wdd)
 	return test_bit(WDOG_ACTIVE, &wdd->status);
 }
 
+/*
+ * Use the following function to check whether or not the hardware watchdog
+ * is running
+ */
+static inline bool watchdog_hw_running(struct watchdog_device *wdd)
+{
+	return test_bit(WDOG_HW_RUNNING, &wdd->status);
+}
+
 /* Use the following function to set the nowayout feature */
 static inline void watchdog_set_nowayout(struct watchdog_device *wdd, bool nowayout)
 {

commit 664a39236e718f9f03fa73fc01006da9ced04efc
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sun Feb 28 13:12:15 2016 -0800

    watchdog: Introduce hardware maximum heartbeat in watchdog core
    
    Introduce an optional hardware maximum heartbeat in the watchdog core.
    The hardware maximum heartbeat can be lower than the maximum timeout.
    
    Drivers can set the maximum hardware heartbeat value in the watchdog data
    structure. If the configured timeout exceeds the maximum hardware heartbeat,
    the watchdog core enables a timer function to assist sending keepalive
    requests to the watchdog driver.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 0b565f2ad242..8e82daecb7d3 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -10,8 +10,9 @@
 
 
 #include <linux/bitops.h>
-#include <linux/device.h>
 #include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
 #include <linux/notifier.h>
 #include <uapi/linux/watchdog.h>
 
@@ -61,14 +62,19 @@ struct watchdog_ops {
  * @bootstatus:	Status of the watchdog device at boot.
  * @timeout:	The watchdog devices timeout value (in seconds).
  * @min_timeout:The watchdog devices minimum timeout value (in seconds).
- * @max_timeout:The watchdog devices maximum timeout value (in seconds).
+ * @max_timeout:The watchdog devices maximum timeout value (in seconds)
+ *		as configurable from user space. Only relevant if
+ *		max_hw_heartbeat_ms is not provided.
+ * @max_hw_heartbeat_ms:
+ *		Hardware limit for maximum timeout, in milli-seconds.
+ *		Replaces max_timeout if specified.
  * @reboot_nb:	The notifier block to stop watchdog on reboot.
  * @restart_nb:	The notifier block to register a restart function.
  * @driver_data:Pointer to the drivers private data.
  * @wd_data:	Pointer to watchdog core internal data.
  * @status:	Field that contains the devices internal status bits.
- * @deferred: entry in wtd_deferred_reg_list which is used to
- *			   register early initialized watchdogs.
+ * @deferred:	Entry in wtd_deferred_reg_list which is used to
+ *		register early initialized watchdogs.
  *
  * The watchdog_device structure contains all information about a
  * watchdog timer device.
@@ -89,6 +95,7 @@ struct watchdog_device {
 	unsigned int timeout;
 	unsigned int min_timeout;
 	unsigned int max_timeout;
+	unsigned int max_hw_heartbeat_ms;
 	struct notifier_block reboot_nb;
 	struct notifier_block restart_nb;
 	void *driver_data;
@@ -128,13 +135,18 @@ static inline bool watchdog_timeout_invalid(struct watchdog_device *wdd, unsigne
 {
 	/*
 	 * The timeout is invalid if
+	 * - the requested value is larger than UINT_MAX / 1000
+	 *   (since internal calculations are done in milli-seconds),
+	 * or
 	 * - the requested value is smaller than the configured minimum timeout,
 	 * or
-	 * - a maximum timeout is configured, and the requested value is larger
-	 *   than the maximum timeout.
+	 * - a maximum hardware timeout is not configured, a maximum timeout
+	 *   is configured, and the requested value is larger than the
+	 *   configured maximum timeout.
 	 */
-	return t < wdd->min_timeout ||
-		(wdd->max_timeout && t > wdd->max_timeout);
+	return t > UINT_MAX / 1000 || t < wdd->min_timeout ||
+		(!wdd->max_hw_heartbeat_ms && wdd->max_timeout &&
+		 t > wdd->max_timeout);
 }
 
 /* Use the following functions to manipulate watchdog driver specific data */

commit 4d8b229d5ea610affe672e919021e9d02cd877da
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Fri Feb 26 17:32:49 2016 -0800

    watchdog: Add 'action' and 'data' parameters to restart handler callback
    
    The 'action' (or restart mode) and data parameters may be used by restart
    handlers, so they should be passed to the restart callback functions.
    
    Cc: Sylvain Lemieux <slemieux@tycoint.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index b585fa2507ee..0b565f2ad242 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -46,7 +46,7 @@ struct watchdog_ops {
 	unsigned int (*status)(struct watchdog_device *);
 	int (*set_timeout)(struct watchdog_device *, unsigned int);
 	unsigned int (*get_timeleft)(struct watchdog_device *);
-	int (*restart)(struct watchdog_device *);
+	int (*restart)(struct watchdog_device *, unsigned long, void *);
 	long (*ioctl)(struct watchdog_device *, unsigned int, unsigned long);
 };
 

commit 0254e953537c92df3e7d0176f401a211e944fd61
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sun Jan 3 15:11:58 2016 -0800

    watchdog: Drop pointer to watchdog device from struct watchdog_device
    
    The lifetime of the watchdog device pointer is different from the lifetime
    of its character device. Remove it entirely to avoid race conditions.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 076df50ea0da..b585fa2507ee 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -53,7 +53,6 @@ struct watchdog_ops {
 /** struct watchdog_device - The structure that defines a watchdog device
  *
  * @id:		The watchdog's ID. (Allocated by watchdog_register_device)
- * @dev:	The device for our watchdog
  * @parent:	The parent bus device
  * @groups:	List of sysfs attribute groups to create when creating the
  *		watchdog device.
@@ -82,7 +81,6 @@ struct watchdog_ops {
  */
 struct watchdog_device {
 	int id;
-	struct device *dev;
 	struct device *parent;
 	const struct attribute_group **groups;
 	const struct watchdog_info *info;

commit faa584757b63aad42d19f1c6a6eac2c848618f83
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sun Jan 3 15:11:56 2016 -0800

    watchdog: Add support for creating driver specific sysfs attributes
    
    The Zodiac watchdog driver attaches additional sysfs attributes to the
    watchdog device. This has a number of problems: The watchdog device
    lifetime differs from the driver lifetime, and the device structure
    should therefore not be accessed from drivers. Also, creating sysfs
    attributes after driver registration results in a potential race condition
    if user space expects the attributes to exist but they don't exist yet.
    
    Add support for creating driver specific sysfs attributes to the watchdog
    core to solve the problems.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index aaabd4703b46..076df50ea0da 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -55,6 +55,8 @@ struct watchdog_ops {
  * @id:		The watchdog's ID. (Allocated by watchdog_register_device)
  * @dev:	The device for our watchdog
  * @parent:	The parent bus device
+ * @groups:	List of sysfs attribute groups to create when creating the
+ *		watchdog device.
  * @info:	Pointer to a watchdog_info structure.
  * @ops:	Pointer to the list of watchdog operations.
  * @bootstatus:	Status of the watchdog device at boot.
@@ -82,6 +84,7 @@ struct watchdog_device {
 	int id;
 	struct device *dev;
 	struct device *parent;
+	const struct attribute_group **groups;
 	const struct watchdog_info *info;
 	const struct watchdog_ops *ops;
 	unsigned int bootstatus;

commit 62cd1c40ce1c7c16835b599751c7a002eb5bbdf5
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Sun Jan 3 13:32:37 2016 +0200

    watchdog: kill unref/ref ops
    
    ref/unref ops are not called at all so even marked them as deprecated
    is misleading, we need to just drop the API.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 850af04fe0c7..aaabd4703b46 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -47,8 +47,6 @@ struct watchdog_ops {
 	int (*set_timeout)(struct watchdog_device *, unsigned int);
 	unsigned int (*get_timeleft)(struct watchdog_device *);
 	int (*restart)(struct watchdog_device *);
-	void (*ref)(struct watchdog_device *) __deprecated;
-	void (*unref)(struct watchdog_device *) __deprecated;
 	long (*ioctl)(struct watchdog_device *, unsigned int, unsigned long);
 };
 

commit b4ffb1909843b28f3b1b60197d517b123b7a9b66
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Fri Dec 25 16:01:42 2015 -0800

    watchdog: Separate and maintain variables based on variable lifetime
    
    All variables required by the watchdog core to manage a watchdog are
    currently stored in struct watchdog_device. The lifetime of those
    variables is determined by the watchdog driver. However, the lifetime
    of variables used by the watchdog core differs from the lifetime of
    struct watchdog_device. To remedy this situation, watchdog drivers
    can implement ref and unref callbacks, to be used by the watchdog
    core to lock struct watchdog_device in memory.
    
    While this solves the immediate problem, it depends on watchdog drivers
    to actually implement the ref/unref callbacks. This is error prone,
    often not implemented in the first place, or not implemented correctly.
    
    To solve the problem without requiring driver support, split the variables
    in struct watchdog_device into two data structures - one for variables
    associated with the watchdog driver, one for variables associated with
    the watchdog core. With this approach, the watchdog core can keep track
    of its variable lifetime and no longer depends on ref/unref callbacks
    in the driver. As a side effect, some of the variables originally in
    struct watchdog_driver are now private to the watchdog core and no longer
    visible in watchdog drivers.
    
    As a side effect of the changes made, an ioctl will now always fail
    with -ENODEV after a watchdog device was unregistered with the character
    device still open. Previously, it would only fail with -ENODEV in some
    situations. Also, ioctl operations are now atomic from driver perspective.
    With this change, it is now guaranteed that the driver will not unregister
    a watchdog between a timeout change and the subsequent ping.
    
    The 'ref' and 'unref' callbacks in struct watchdog_driver are no longer
    used and marked as deprecated.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index a88f955fde92..850af04fe0c7 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -17,6 +17,7 @@
 
 struct watchdog_ops;
 struct watchdog_device;
+struct watchdog_core_data;
 
 /** struct watchdog_ops - The watchdog-devices operations
  *
@@ -28,8 +29,6 @@ struct watchdog_device;
  * @set_timeout:The routine for setting the watchdog devices timeout value (in seconds).
  * @get_timeleft:The routine that gets the time left before a reset (in seconds).
  * @restart:	The routine for restarting the machine.
- * @ref:	The ref operation for dyn. allocated watchdog_device structs
- * @unref:	The unref operation for dyn. allocated watchdog_device structs
  * @ioctl:	The routines that handles extra ioctl calls.
  *
  * The watchdog_ops structure contains a list of low-level operations
@@ -48,15 +47,14 @@ struct watchdog_ops {
 	int (*set_timeout)(struct watchdog_device *, unsigned int);
 	unsigned int (*get_timeleft)(struct watchdog_device *);
 	int (*restart)(struct watchdog_device *);
-	void (*ref)(struct watchdog_device *);
-	void (*unref)(struct watchdog_device *);
+	void (*ref)(struct watchdog_device *) __deprecated;
+	void (*unref)(struct watchdog_device *) __deprecated;
 	long (*ioctl)(struct watchdog_device *, unsigned int, unsigned long);
 };
 
 /** struct watchdog_device - The structure that defines a watchdog device
  *
  * @id:		The watchdog's ID. (Allocated by watchdog_register_device)
- * @cdev:	The watchdog's Character device.
  * @dev:	The device for our watchdog
  * @parent:	The parent bus device
  * @info:	Pointer to a watchdog_info structure.
@@ -67,8 +65,8 @@ struct watchdog_ops {
  * @max_timeout:The watchdog devices maximum timeout value (in seconds).
  * @reboot_nb:	The notifier block to stop watchdog on reboot.
  * @restart_nb:	The notifier block to register a restart function.
- * @driver-data:Pointer to the drivers private data.
- * @lock:	Lock for watchdog core internal use only.
+ * @driver_data:Pointer to the drivers private data.
+ * @wd_data:	Pointer to watchdog core internal data.
  * @status:	Field that contains the devices internal status bits.
  * @deferred: entry in wtd_deferred_reg_list which is used to
  *			   register early initialized watchdogs.
@@ -84,7 +82,6 @@ struct watchdog_ops {
  */
 struct watchdog_device {
 	int id;
-	struct cdev cdev;
 	struct device *dev;
 	struct device *parent;
 	const struct watchdog_info *info;
@@ -96,15 +93,12 @@ struct watchdog_device {
 	struct notifier_block reboot_nb;
 	struct notifier_block restart_nb;
 	void *driver_data;
-	struct mutex lock;
+	struct watchdog_core_data *wd_data;
 	unsigned long status;
 /* Bit numbers for status flags */
 #define WDOG_ACTIVE		0	/* Is the watchdog running/active */
-#define WDOG_DEV_OPEN		1	/* Opened via /dev/watchdog ? */
-#define WDOG_ALLOW_RELEASE	2	/* Did we receive the magic char ? */
-#define WDOG_NO_WAY_OUT		3	/* Is 'nowayout' feature set ? */
-#define WDOG_UNREGISTERED	4	/* Has the device been unregistered */
-#define WDOG_STOP_ON_REBOOT	5	/* Should be stopped on reboot */
+#define WDOG_NO_WAY_OUT		1	/* Is 'nowayout' feature set ? */
+#define WDOG_STOP_ON_REBOOT	2	/* Should be stopped on reboot */
 	struct list_head deferred;
 };
 

commit e131319669e0ef5e6fcd75174daeffa40492135c
Author: Damien Riegel <damien.riegel@savoirfairelinux.com>
Date:   Fri Nov 20 16:54:51 2015 -0500

    watchdog: core: add reboot notifier support
    
    Many watchdog drivers register a reboot notifier in order to stop the
    watchdog on system reboot. Thus we can factorize this code in the
    watchdog core.
    
    For that purpose, a new notifier block is added in watchdog_device for
    internal use only, as well as a new watchdog_stop_on_reboot helper
    function.
    
    If this helper is called, watchdog core registers the related notifier
    block and will stop the watchdog when SYS_HALT or SYS_DOWN is received.
    
    Since this operation can be critical on some platforms, abort the device
    registration if the reboot notifier registration fails.
    
    Suggested-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: Damien Riegel <damien.riegel@savoirfairelinux.com>
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 5b52c834f7aa..a88f955fde92 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -65,6 +65,7 @@ struct watchdog_ops {
  * @timeout:	The watchdog devices timeout value (in seconds).
  * @min_timeout:The watchdog devices minimum timeout value (in seconds).
  * @max_timeout:The watchdog devices maximum timeout value (in seconds).
+ * @reboot_nb:	The notifier block to stop watchdog on reboot.
  * @restart_nb:	The notifier block to register a restart function.
  * @driver-data:Pointer to the drivers private data.
  * @lock:	Lock for watchdog core internal use only.
@@ -92,6 +93,7 @@ struct watchdog_device {
 	unsigned int timeout;
 	unsigned int min_timeout;
 	unsigned int max_timeout;
+	struct notifier_block reboot_nb;
 	struct notifier_block restart_nb;
 	void *driver_data;
 	struct mutex lock;
@@ -102,6 +104,7 @@ struct watchdog_device {
 #define WDOG_ALLOW_RELEASE	2	/* Did we receive the magic char ? */
 #define WDOG_NO_WAY_OUT		3	/* Is 'nowayout' feature set ? */
 #define WDOG_UNREGISTERED	4	/* Has the device been unregistered */
+#define WDOG_STOP_ON_REBOOT	5	/* Should be stopped on reboot */
 	struct list_head deferred;
 };
 
@@ -121,6 +124,12 @@ static inline void watchdog_set_nowayout(struct watchdog_device *wdd, bool noway
 		set_bit(WDOG_NO_WAY_OUT, &wdd->status);
 }
 
+/* Use the following function to stop the watchdog on reboot */
+static inline void watchdog_stop_on_reboot(struct watchdog_device *wdd)
+{
+	set_bit(WDOG_STOP_ON_REBOOT, &wdd->status);
+}
+
 /* Use the following function to check if a timeout value is invalid */
 static inline bool watchdog_timeout_invalid(struct watchdog_device *wdd, unsigned int t)
 {

commit 2165bf524da5f5e496d1cdb8c5afae1345ecce1e
Author: Damien Riegel <damien.riegel@savoirfairelinux.com>
Date:   Mon Nov 16 12:27:59 2015 -0500

    watchdog: core: add restart handler support
    
    Many watchdog drivers implement the same code to register a restart
    handler. This patch provides a generic way to set such a function.
    
    The patch adds a new restart watchdog operation. If a restart priority
    greater than 0 is needed, the driver can call
    watchdog_set_restart_priority to set it.
    
    Suggested-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: Damien Riegel <damien.riegel@savoirfairelinux.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 027b1f43f12d..5b52c834f7aa 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -12,6 +12,7 @@
 #include <linux/bitops.h>
 #include <linux/device.h>
 #include <linux/cdev.h>
+#include <linux/notifier.h>
 #include <uapi/linux/watchdog.h>
 
 struct watchdog_ops;
@@ -26,6 +27,7 @@ struct watchdog_device;
  * @status:	The routine that shows the status of the watchdog device.
  * @set_timeout:The routine for setting the watchdog devices timeout value (in seconds).
  * @get_timeleft:The routine that gets the time left before a reset (in seconds).
+ * @restart:	The routine for restarting the machine.
  * @ref:	The ref operation for dyn. allocated watchdog_device structs
  * @unref:	The unref operation for dyn. allocated watchdog_device structs
  * @ioctl:	The routines that handles extra ioctl calls.
@@ -45,6 +47,7 @@ struct watchdog_ops {
 	unsigned int (*status)(struct watchdog_device *);
 	int (*set_timeout)(struct watchdog_device *, unsigned int);
 	unsigned int (*get_timeleft)(struct watchdog_device *);
+	int (*restart)(struct watchdog_device *);
 	void (*ref)(struct watchdog_device *);
 	void (*unref)(struct watchdog_device *);
 	long (*ioctl)(struct watchdog_device *, unsigned int, unsigned long);
@@ -62,6 +65,7 @@ struct watchdog_ops {
  * @timeout:	The watchdog devices timeout value (in seconds).
  * @min_timeout:The watchdog devices minimum timeout value (in seconds).
  * @max_timeout:The watchdog devices maximum timeout value (in seconds).
+ * @restart_nb:	The notifier block to register a restart function.
  * @driver-data:Pointer to the drivers private data.
  * @lock:	Lock for watchdog core internal use only.
  * @status:	Field that contains the devices internal status bits.
@@ -88,6 +92,7 @@ struct watchdog_device {
 	unsigned int timeout;
 	unsigned int min_timeout;
 	unsigned int max_timeout;
+	struct notifier_block restart_nb;
 	void *driver_data;
 	struct mutex lock;
 	unsigned long status;
@@ -142,6 +147,7 @@ static inline void *watchdog_get_drvdata(struct watchdog_device *wdd)
 }
 
 /* drivers/watchdog/watchdog_core.c */
+void watchdog_set_restart_priority(struct watchdog_device *wdd, int priority);
 extern int watchdog_init_timeout(struct watchdog_device *wdd,
 				  unsigned int timeout_parm, struct device *dev);
 extern int watchdog_register_device(struct watchdog_device *);

commit 760d280084f8805e5de73e3591912d5db9da9dbe
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue Nov 3 09:00:16 2015 +0100

    watchdog: include: add units for timeout values in kerneldoc
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 5f18dd9ec224..027b1f43f12d 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -24,8 +24,8 @@ struct watchdog_device;
  * @stop:	The routine for stopping the watchdog device.
  * @ping:	The routine that sends a keepalive ping to the watchdog device.
  * @status:	The routine that shows the status of the watchdog device.
- * @set_timeout:The routine for setting the watchdog devices timeout value.
- * @get_timeleft:The routine that gets the time left before a reset.
+ * @set_timeout:The routine for setting the watchdog devices timeout value (in seconds).
+ * @get_timeleft:The routine that gets the time left before a reset (in seconds).
  * @ref:	The ref operation for dyn. allocated watchdog_device structs
  * @unref:	The unref operation for dyn. allocated watchdog_device structs
  * @ioctl:	The routines that handles extra ioctl calls.
@@ -59,9 +59,9 @@ struct watchdog_ops {
  * @info:	Pointer to a watchdog_info structure.
  * @ops:	Pointer to the list of watchdog operations.
  * @bootstatus:	Status of the watchdog device at boot.
- * @timeout:	The watchdog devices timeout value.
- * @min_timeout:The watchdog devices minimum timeout value.
- * @max_timeout:The watchdog devices maximum timeout value.
+ * @timeout:	The watchdog devices timeout value (in seconds).
+ * @min_timeout:The watchdog devices minimum timeout value (in seconds).
+ * @max_timeout:The watchdog devices maximum timeout value (in seconds).
  * @driver-data:Pointer to the drivers private data.
  * @lock:	Lock for watchdog core internal use only.
  * @status:	Field that contains the devices internal status bits.

commit 80220fa72b917c64675f3ba4008d2c5a7b50b281
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue Nov 3 09:00:15 2015 +0100

    watchdog: include: fix some typos
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index e90e3ea5ebeb..5f18dd9ec224 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -25,7 +25,7 @@ struct watchdog_device;
  * @ping:	The routine that sends a keepalive ping to the watchdog device.
  * @status:	The routine that shows the status of the watchdog device.
  * @set_timeout:The routine for setting the watchdog devices timeout value.
- * @get_timeleft:The routine that get's the time that's left before a reset.
+ * @get_timeleft:The routine that gets the time left before a reset.
  * @ref:	The ref operation for dyn. allocated watchdog_device structs
  * @unref:	The unref operation for dyn. allocated watchdog_device structs
  * @ioctl:	The routines that handles extra ioctl calls.
@@ -33,7 +33,7 @@ struct watchdog_device;
  * The watchdog_ops structure contains a list of low-level operations
  * that control a watchdog device. It also contains the module that owns
  * these operations. The start and stop function are mandatory, all other
- * functions are optonal.
+ * functions are optional.
  */
 struct watchdog_ops {
 	struct module *owner;

commit 1e935949111e77b2b1b6fa550e88ff0573c2f4c7
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Sep 29 01:27:24 2015 -0700

    watchdog: Always evaluate new timeout against min_timeout
    
    Up to now, a new timeout value is only evaluated against min_timeout
    if max_timeout is provided. This does not really make sense; a driver
    can have a minimum timeout even if it does not have a maximum timeout.
    Ensure that it is not smaller than min_timeout, even if max_timeout
    is not set.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Uwe Kleine-KÃ¶nig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index d74a0e907b9e..e90e3ea5ebeb 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -119,8 +119,15 @@ static inline void watchdog_set_nowayout(struct watchdog_device *wdd, bool noway
 /* Use the following function to check if a timeout value is invalid */
 static inline bool watchdog_timeout_invalid(struct watchdog_device *wdd, unsigned int t)
 {
-	return ((wdd->max_timeout != 0) &&
-		(t < wdd->min_timeout || t > wdd->max_timeout));
+	/*
+	 * The timeout is invalid if
+	 * - the requested value is smaller than the configured minimum timeout,
+	 * or
+	 * - a maximum timeout is configured, and the requested value is larger
+	 *   than the maximum timeout.
+	 */
+	return t < wdd->min_timeout ||
+		(wdd->max_timeout && t > wdd->max_timeout);
 }
 
 /* Use the following functions to manipulate watchdog driver specific data */

commit aacfbe6a9724bb6d66a656a5abcc681d5649ed92
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Fri Sep 4 15:45:12 2015 -0700

    kernel/watchdog: move NMI function header declarations from watchdog.h to nmi.h
    
    The kernel's NMI watchdog has nothing to do with the watchdog subsystem.
    Its header declarations should be in linux/nmi.h, not linux/watchdog.h.
    
    The code provided two sets of dummy functions if HARDLOCKUP_DETECTOR is
    not configured, one in the include file and one in kernel/watchdog.c.
    Remove the dummy functions from kernel/watchdog.c and use those from the
    include file.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Don Zickus <dzickus@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index f47feada5b42..d74a0e907b9e 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -140,12 +140,4 @@ extern int watchdog_init_timeout(struct watchdog_device *wdd,
 extern int watchdog_register_device(struct watchdog_device *);
 extern void watchdog_unregister_device(struct watchdog_device *);
 
-#ifdef CONFIG_HARDLOCKUP_DETECTOR
-void watchdog_nmi_disable_all(void);
-void watchdog_nmi_enable_all(void);
-#else
-static inline void watchdog_nmi_disable_all(void) {}
-static inline void watchdog_nmi_enable_all(void) {}
-#endif
-
 #endif  /* ifndef _LINUX_WATCHDOG_H */

commit ef90174f821041313d42d99c1c8b35a3af64a910
Author: Jean-Baptiste Theou <jtheou@adeneo-embedded.us>
Date:   Tue Jun 9 09:55:02 2015 -0700

    watchdog: watchdog_core: Add watchdog registration deferral mechanism
    
    Currently, watchdog subsystem require the misc subsystem to
    register a watchdog. This may not be the case in case of an
    early registration of a watchdog, which can be required when
    the watchdog cannot be disabled.
    
    This patch introduces a deferral mechanism to remove this requirement.
    
    Signed-off-by: Jean-Baptiste Theou <jtheou@adeneo-embedded.us>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index a746bf5216f8..f47feada5b42 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -65,6 +65,8 @@ struct watchdog_ops {
  * @driver-data:Pointer to the drivers private data.
  * @lock:	Lock for watchdog core internal use only.
  * @status:	Field that contains the devices internal status bits.
+ * @deferred: entry in wtd_deferred_reg_list which is used to
+ *			   register early initialized watchdogs.
  *
  * The watchdog_device structure contains all information about a
  * watchdog timer device.
@@ -95,6 +97,7 @@ struct watchdog_device {
 #define WDOG_ALLOW_RELEASE	2	/* Did we receive the magic char ? */
 #define WDOG_NO_WAY_OUT		3	/* Is 'nowayout' feature set ? */
 #define WDOG_UNREGISTERED	4	/* Has the device been unregistered */
+	struct list_head deferred;
 };
 
 #define WATCHDOG_NOWAYOUT		IS_BUILTIN(CONFIG_WATCHDOG_NOWAYOUT)

commit b3738d29323344da3017a91010530cf3a58590fc
Author: Stephane Eranian <eranian@google.com>
Date:   Mon Nov 17 20:07:03 2014 +0100

    watchdog: Add watchdog enable/disable all functions
    
    This patch adds two new functions to enable/disable
    the watchdog across all CPUs.
    
    This will be used by the HT PMU bug workaround code to
    disable/enable the NMI watchdog across quirk enablement.
    
    Signed-off-by: Stephane Eranian <eranian@google.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: bp@alien8.de
    Cc: jolsa@redhat.com
    Cc: kan.liang@intel.com
    Cc: maria.n.dimakopoulou@gmail.com
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Link: http://lkml.kernel.org/r/1416251225-17721-12-git-send-email-eranian@google.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 395b70e0eccf..a746bf5216f8 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -137,4 +137,12 @@ extern int watchdog_init_timeout(struct watchdog_device *wdd,
 extern int watchdog_register_device(struct watchdog_device *);
 extern void watchdog_unregister_device(struct watchdog_device *);
 
+#ifdef CONFIG_HARDLOCKUP_DETECTOR
+void watchdog_nmi_disable_all(void);
+void watchdog_nmi_enable_all(void);
+#else
+static inline void watchdog_nmi_disable_all(void) {}
+static inline void watchdog_nmi_enable_all(void) {}
+#endif
+
 #endif  /* ifndef _LINUX_WATCHDOG_H */

commit 4846e3784585173f48e267b76f968bcb4a12d3b2
Author: Uwe Kleine-KÃ¶nig <u.kleine-koenig@pengutronix.de>
Date:   Tue Sep 9 22:18:31 2014 +0200

    watchdog: simplify definitions of WATCHDOG_NOWAYOUT(_INIT_STATUS)?
    
    Signed-off-by: Uwe Kleine-K=C3=B6nig <u.kleine-koenig@pengutronix.de>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 2a3038ee17a3..395b70e0eccf 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -97,13 +97,8 @@ struct watchdog_device {
 #define WDOG_UNREGISTERED	4	/* Has the device been unregistered */
 };
 
-#ifdef CONFIG_WATCHDOG_NOWAYOUT
-#define WATCHDOG_NOWAYOUT		1
-#define WATCHDOG_NOWAYOUT_INIT_STATUS	(1 << WDOG_NO_WAY_OUT)
-#else
-#define WATCHDOG_NOWAYOUT		0
-#define WATCHDOG_NOWAYOUT_INIT_STATUS	0
-#endif
+#define WATCHDOG_NOWAYOUT		IS_BUILTIN(CONFIG_WATCHDOG_NOWAYOUT)
+#define WATCHDOG_NOWAYOUT_INIT_STATUS	(WATCHDOG_NOWAYOUT << WDOG_NO_WAY_OUT)
 
 /* Use the following function to check whether or not the watchdog is active */
 static inline bool watchdog_active(struct watchdog_device *wdd)

commit 3048253ed957fc6cdc34599178408559aa1e0062
Author: Fabio Porcedda <fabio.porcedda@gmail.com>
Date:   Tue Jan 8 11:04:10 2013 +0100

    watchdog: core: dt: add support for the timeout-sec dt property
    
    Add support for watchdog drivers to initialize/set the timeout field
    of the watchdog_device structure. The timeout field is initialised
    either with the module timeout parameter value (if valid) or with the
    timeout-sec dt property (if valid). If both are invalid the initial
    value is unchanged.
    
    Signed-off-by: Fabio Porcedda <fabio.porcedda@gmail.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 3a9df2f43be6..2a3038ee17a3 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -118,6 +118,13 @@ static inline void watchdog_set_nowayout(struct watchdog_device *wdd, bool noway
 		set_bit(WDOG_NO_WAY_OUT, &wdd->status);
 }
 
+/* Use the following function to check if a timeout value is invalid */
+static inline bool watchdog_timeout_invalid(struct watchdog_device *wdd, unsigned int t)
+{
+	return ((wdd->max_timeout != 0) &&
+		(t < wdd->min_timeout || t > wdd->max_timeout));
+}
+
 /* Use the following functions to manipulate watchdog driver specific data */
 static inline void watchdog_set_drvdata(struct watchdog_device *wdd, void *data)
 {
@@ -130,6 +137,8 @@ static inline void *watchdog_get_drvdata(struct watchdog_device *wdd)
 }
 
 /* drivers/watchdog/watchdog_core.c */
+extern int watchdog_init_timeout(struct watchdog_device *wdd,
+				  unsigned int timeout_parm, struct device *dev);
 extern int watchdog_register_device(struct watchdog_device *);
 extern void watchdog_unregister_device(struct watchdog_device *);
 

commit cf13a84d174947df4bb809edfb4887393642303e
Author: Fabio Porcedda <fabio.porcedda@gmail.com>
Date:   Fri Oct 5 12:16:09 2012 +0200

    watchdog: WatchDog Timer Driver Core: fix comment
    
    Signed-off-by: Fabio Porcedda <fabio.porcedda@gmail.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 87490ac4bd87..3a9df2f43be6 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -129,7 +129,7 @@ static inline void *watchdog_get_drvdata(struct watchdog_device *wdd)
 	return wdd->driver_data;
 }
 
-/* drivers/watchdog/core/watchdog_core.c */
+/* drivers/watchdog/watchdog_core.c */
 extern int watchdog_register_device(struct watchdog_device *);
 extern void watchdog_unregister_device(struct watchdog_device *);
 

commit 48fc7f7e787dd65ffe88521bce31f4062ba273eb
Author: Adam Buchbinder <adam.buchbinder@gmail.com>
Date:   Wed Sep 19 21:48:00 2012 -0400

    Fix misspellings of "whether" in comments.
    
    "Whether" is misspelled in various comments across the tree; this
    fixes them. No code changes.
    
    Signed-off-by: Adam Buchbinder <adam.buchbinder@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index b7f45d48b2de..87490ac4bd87 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -105,7 +105,7 @@ struct watchdog_device {
 #define WATCHDOG_NOWAYOUT_INIT_STATUS	0
 #endif
 
-/* Use the following function to check wether or not the watchdog is active */
+/* Use the following function to check whether or not the watchdog is active */
 static inline bool watchdog_active(struct watchdog_device *wdd)
 {
 	return test_bit(WDOG_ACTIVE, &wdd->status);

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index da70f0facd2b..b7f45d48b2de 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -5,59 +5,14 @@
  * by Ken Hollis <khollis@bitgate.com>
  *
  */
-
 #ifndef _LINUX_WATCHDOG_H
 #define _LINUX_WATCHDOG_H
 
-#include <linux/ioctl.h>
-#include <linux/types.h>
-
-#define	WATCHDOG_IOCTL_BASE	'W'
-
-struct watchdog_info {
-	__u32 options;		/* Options the card/driver supports */
-	__u32 firmware_version;	/* Firmware version of the card */
-	__u8  identity[32];	/* Identity of the board */
-};
-
-#define	WDIOC_GETSUPPORT	_IOR(WATCHDOG_IOCTL_BASE, 0, struct watchdog_info)
-#define	WDIOC_GETSTATUS		_IOR(WATCHDOG_IOCTL_BASE, 1, int)
-#define	WDIOC_GETBOOTSTATUS	_IOR(WATCHDOG_IOCTL_BASE, 2, int)
-#define	WDIOC_GETTEMP		_IOR(WATCHDOG_IOCTL_BASE, 3, int)
-#define	WDIOC_SETOPTIONS	_IOR(WATCHDOG_IOCTL_BASE, 4, int)
-#define	WDIOC_KEEPALIVE		_IOR(WATCHDOG_IOCTL_BASE, 5, int)
-#define	WDIOC_SETTIMEOUT        _IOWR(WATCHDOG_IOCTL_BASE, 6, int)
-#define	WDIOC_GETTIMEOUT        _IOR(WATCHDOG_IOCTL_BASE, 7, int)
-#define	WDIOC_SETPRETIMEOUT	_IOWR(WATCHDOG_IOCTL_BASE, 8, int)
-#define	WDIOC_GETPRETIMEOUT	_IOR(WATCHDOG_IOCTL_BASE, 9, int)
-#define	WDIOC_GETTIMELEFT	_IOR(WATCHDOG_IOCTL_BASE, 10, int)
-
-#define	WDIOF_UNKNOWN		-1	/* Unknown flag error */
-#define	WDIOS_UNKNOWN		-1	/* Unknown status error */
-
-#define	WDIOF_OVERHEAT		0x0001	/* Reset due to CPU overheat */
-#define	WDIOF_FANFAULT		0x0002	/* Fan failed */
-#define	WDIOF_EXTERN1		0x0004	/* External relay 1 */
-#define	WDIOF_EXTERN2		0x0008	/* External relay 2 */
-#define	WDIOF_POWERUNDER	0x0010	/* Power bad/power fault */
-#define	WDIOF_CARDRESET		0x0020	/* Card previously reset the CPU */
-#define	WDIOF_POWEROVER		0x0040	/* Power over voltage */
-#define	WDIOF_SETTIMEOUT	0x0080  /* Set timeout (in seconds) */
-#define	WDIOF_MAGICCLOSE	0x0100	/* Supports magic close char */
-#define	WDIOF_PRETIMEOUT	0x0200  /* Pretimeout (in seconds), get/set */
-#define	WDIOF_ALARMONLY		0x0400	/* Watchdog triggers a management or
-					   other external alarm not a reboot */
-#define	WDIOF_KEEPALIVEPING	0x8000	/* Keep alive ping reply */
-
-#define	WDIOS_DISABLECARD	0x0001	/* Turn off the watchdog timer */
-#define	WDIOS_ENABLECARD	0x0002	/* Turn on the watchdog timer */
-#define	WDIOS_TEMPPANIC		0x0004	/* Kernel panic on temperature trip */
-
-#ifdef __KERNEL__
 
 #include <linux/bitops.h>
 #include <linux/device.h>
 #include <linux/cdev.h>
+#include <uapi/linux/watchdog.h>
 
 struct watchdog_ops;
 struct watchdog_device;
@@ -178,6 +133,4 @@ static inline void *watchdog_get_drvdata(struct watchdog_device *wdd)
 extern int watchdog_register_device(struct watchdog_device *);
 extern void watchdog_unregister_device(struct watchdog_device *);
 
-#endif	/* __KERNEL__ */
-
 #endif  /* ifndef _LINUX_WATCHDOG_H */

commit e907df32725204d6d2cb79b872529911c8eadcdf
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue May 22 11:40:26 2012 +0200

    watchdog: Add support for dynamically allocated watchdog_device structs
    
    If a driver's watchdog_device struct is part of a dynamically allocated
    struct (which it often will be), merely locking the module is not enough,
    even with a drivers module locked, the driver can be unbound from the device,
    examples:
    1) The root user can unbind it through sysfd
    2) The i2c bus master driver being unloaded for an i2c watchdog
    
    I will gladly admit that these are corner cases, but we still need to handle
    them correctly.
    
    The fix for this consists of 2 parts:
    1) Add ref / unref operations, so that the driver can refcount the struct
       holding the watchdog_device struct and delay freeing it until any
       open filehandles referring to it are closed
    2) Most driver operations will do IO on the device and the driver should not
       do any IO on the device after it has been unbound. Rather then letting each
       driver deal with this internally, it is better to ensure at the watchdog
       core level that no operations (other then unref) will get called after
       the driver has called watchdog_unregister_device(). This actually is the
       bulk of this patch.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index da1dc1b52744..da70f0facd2b 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -71,6 +71,8 @@ struct watchdog_device;
  * @status:	The routine that shows the status of the watchdog device.
  * @set_timeout:The routine for setting the watchdog devices timeout value.
  * @get_timeleft:The routine that get's the time that's left before a reset.
+ * @ref:	The ref operation for dyn. allocated watchdog_device structs
+ * @unref:	The unref operation for dyn. allocated watchdog_device structs
  * @ioctl:	The routines that handles extra ioctl calls.
  *
  * The watchdog_ops structure contains a list of low-level operations
@@ -88,6 +90,8 @@ struct watchdog_ops {
 	unsigned int (*status)(struct watchdog_device *);
 	int (*set_timeout)(struct watchdog_device *, unsigned int);
 	unsigned int (*get_timeleft)(struct watchdog_device *);
+	void (*ref)(struct watchdog_device *);
+	void (*unref)(struct watchdog_device *);
 	long (*ioctl)(struct watchdog_device *, unsigned int, unsigned long);
 };
 
@@ -135,6 +139,7 @@ struct watchdog_device {
 #define WDOG_DEV_OPEN		1	/* Opened via /dev/watchdog ? */
 #define WDOG_ALLOW_RELEASE	2	/* Did we receive the magic char ? */
 #define WDOG_NO_WAY_OUT		3	/* Is 'nowayout' feature set ? */
+#define WDOG_UNREGISTERED	4	/* Has the device been unregistered */
 };
 
 #ifdef CONFIG_WATCHDOG_NOWAYOUT

commit f4e9c82f64b524314a390b13d3ba7d483f09258f
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue May 22 11:40:26 2012 +0200

    watchdog: Add Locking support
    
    This patch fixes some potential multithreading issues, despite only
    allowing one process to open the /dev/watchdog device, we can still get
    called multiple times at the same time, since a program could be using thread,
    or could share the fd after a fork.
    
    This causes 2 potential problems:
    1) watchdog_start / open do an unlocked test_n_set / test_n_clear,
       if these 2 race, the watchdog could be stopped while the active
       bit indicates it is running or visa versa.
    
    2) Most watchdog_dev drivers probably assume that only one
       watchdog-op will get called at a time, this is not necessary
       true atm.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index c3545c5d918a..da1dc1b52744 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -104,6 +104,7 @@ struct watchdog_ops {
  * @min_timeout:The watchdog devices minimum timeout value.
  * @max_timeout:The watchdog devices maximum timeout value.
  * @driver-data:Pointer to the drivers private data.
+ * @lock:	Lock for watchdog core internal use only.
  * @status:	Field that contains the devices internal status bits.
  *
  * The watchdog_device structure contains all information about a
@@ -111,6 +112,9 @@ struct watchdog_ops {
  *
  * The driver-data field may not be accessed directly. It must be accessed
  * via the watchdog_set_drvdata and watchdog_get_drvdata helpers.
+ *
+ * The lock field is for watchdog core internal use only and should not be
+ * touched.
  */
 struct watchdog_device {
 	int id;
@@ -124,6 +128,7 @@ struct watchdog_device {
 	unsigned int min_timeout;
 	unsigned int max_timeout;
 	void *driver_data;
+	struct mutex lock;
 	unsigned long status;
 /* Bit numbers for status flags */
 #define WDOG_ACTIVE		0	/* Is the watchdog running/active */

commit d6b469d915ae348b3bb8b25034063d6870ff4a00
Author: Alan Cox <alan@linux.intel.com>
Date:   Fri May 11 12:00:20 2012 +0200

    watchdog: create all the proper device files
    
    Create the watchdog class and it's associated devices.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 32678a50f98d..c3545c5d918a 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -95,6 +95,8 @@ struct watchdog_ops {
  *
  * @id:		The watchdog's ID. (Allocated by watchdog_register_device)
  * @cdev:	The watchdog's Character device.
+ * @dev:	The device for our watchdog
+ * @parent:	The parent bus device
  * @info:	Pointer to a watchdog_info structure.
  * @ops:	Pointer to the list of watchdog operations.
  * @bootstatus:	Status of the watchdog device at boot.
@@ -113,6 +115,8 @@ struct watchdog_ops {
 struct watchdog_device {
 	int id;
 	struct cdev cdev;
+	struct device *dev;
+	struct device *parent;
 	const struct watchdog_info *info;
 	const struct watchdog_ops *ops;
 	unsigned int bootstatus;

commit 2bbeed016dd96045ec82c3a309afddcc3a0db1d2
Author: Alan Cox <alan@linux.intel.com>
Date:   Fri May 11 12:00:19 2012 +0200

    watchdog: Add a flag to indicate the watchdog doesn't reboot things
    
    Some watchdogs merely trigger external alarms and controls. In a managed
    environment this is very useful but we want drivers to be able to figure
    out which is which now multiple dogs can be loaded. Thus add an ALARMONLY
    feature flag.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 508d56399e6d..32678a50f98d 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -45,6 +45,8 @@ struct watchdog_info {
 #define	WDIOF_SETTIMEOUT	0x0080  /* Set timeout (in seconds) */
 #define	WDIOF_MAGICCLOSE	0x0100	/* Supports magic close char */
 #define	WDIOF_PRETIMEOUT	0x0200  /* Pretimeout (in seconds), get/set */
+#define	WDIOF_ALARMONLY		0x0400	/* Watchdog triggers a management or
+					   other external alarm not a reboot */
 #define	WDIOF_KEEPALIVEPING	0x8000	/* Keep alive ping reply */
 
 #define	WDIOS_DISABLECARD	0x0001	/* Turn off the watchdog timer */

commit 45f5fed30a6460ec58f159ff297a2974153a97de
Author: Alan Cox <alan@linux.intel.com>
Date:   Thu May 10 21:48:59 2012 +0200

    watchdog: Add multiple device support
    
    We keep the old /dev/watchdog interface file for the first watchdog via
    miscdev. This is basically a cut and paste of the relevant interface code
    from the rtc driver layer tweaked for watchdog.
    
    Revised to fix problems noted by Hans de Goede
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 1984ea610577..508d56399e6d 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -54,6 +54,8 @@ struct watchdog_info {
 #ifdef __KERNEL__
 
 #include <linux/bitops.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
 
 struct watchdog_ops;
 struct watchdog_device;
@@ -89,6 +91,8 @@ struct watchdog_ops {
 
 /** struct watchdog_device - The structure that defines a watchdog device
  *
+ * @id:		The watchdog's ID. (Allocated by watchdog_register_device)
+ * @cdev:	The watchdog's Character device.
  * @info:	Pointer to a watchdog_info structure.
  * @ops:	Pointer to the list of watchdog operations.
  * @bootstatus:	Status of the watchdog device at boot.
@@ -105,6 +109,8 @@ struct watchdog_ops {
  * via the watchdog_set_drvdata and watchdog_get_drvdata helpers.
  */
 struct watchdog_device {
+	int id;
+	struct cdev cdev;
 	const struct watchdog_info *info;
 	const struct watchdog_ops *ops;
 	unsigned int bootstatus;

commit 257f8c4aae392654d4ab846030b9f4518f16ed32
Author: Viresh Kumar <viresh.kumar@st.com>
Date:   Mon Mar 12 09:51:56 2012 +0530

    watchdog: Add watchdog_active() routine
    
    Some watchdog may need to check if watchdog is ACTIVE or not, for example in
    their suspend/resume hooks.
    
    This patch adds this routine and changes the core drivers to use it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@st.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index ac40716b44e9..1984ea610577 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -128,6 +128,12 @@ struct watchdog_device {
 #define WATCHDOG_NOWAYOUT_INIT_STATUS	0
 #endif
 
+/* Use the following function to check wether or not the watchdog is active */
+static inline bool watchdog_active(struct watchdog_device *wdd)
+{
+	return test_bit(WDOG_ACTIVE, &wdd->status);
+}
+
 /* Use the following function to set the nowayout feature */
 static inline void watchdog_set_nowayout(struct watchdog_device *wdd, bool nowayout)
 {

commit fd7b673c92731fc6c0b1e999adfd87b6762ee797
Author: Viresh Kumar <viresh.kumar@st.com>
Date:   Fri Mar 16 09:14:00 2012 +0100

    watchdog: Add support for WDIOC_GETTIMELEFT IOCTL in watchdog core
    
    This patch adds support for WDIOC_GETTIMELEFT IOCTL in watchdog core. So, there
    is another function pointer added to struct watchdog_ops, which can be passed by
    drivers to support this IOCTL.
    
    Related documentation is updated too.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@st.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index de75167093bf..ac40716b44e9 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -66,6 +66,7 @@ struct watchdog_device;
  * @ping:	The routine that sends a keepalive ping to the watchdog device.
  * @status:	The routine that shows the status of the watchdog device.
  * @set_timeout:The routine for setting the watchdog devices timeout value.
+ * @get_timeleft:The routine that get's the time that's left before a reset.
  * @ioctl:	The routines that handles extra ioctl calls.
  *
  * The watchdog_ops structure contains a list of low-level operations
@@ -82,6 +83,7 @@ struct watchdog_ops {
 	int (*ping)(struct watchdog_device *);
 	unsigned int (*status)(struct watchdog_device *);
 	int (*set_timeout)(struct watchdog_device *, unsigned int);
+	unsigned int (*get_timeleft)(struct watchdog_device *);
 	long (*ioctl)(struct watchdog_device *, unsigned int, unsigned long);
 };
 

commit 86a1e1896c2710402e29a875d8d830244274244d
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Mon Mar 5 16:51:11 2012 +0100

    watchdog: nowayout is bool
    
    nowayout is actually a boolean value.
    So make it bool for all watchdog device drivers.
    
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 43ba5b3ce2a3..de75167093bf 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -127,7 +127,7 @@ struct watchdog_device {
 #endif
 
 /* Use the following function to set the nowayout feature */
-static inline void watchdog_set_nowayout(struct watchdog_device *wdd, int nowayout)
+static inline void watchdog_set_nowayout(struct watchdog_device *wdd, bool nowayout)
 {
 	if (nowayout)
 		set_bit(WDOG_NO_WAY_OUT, &wdd->status);

commit ff0b3cd4a416bc727b0797b95b229b278d2a28f2
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Tue Nov 29 16:24:16 2011 +0100

    watchdog: add nowayout helpers to Watchdog Timer Driver Kernel API
    
    Add two nowayout helpers for the Watchdog Timer Driver Kernel API.
    And apply this to the already converted drivers.
    Note: s3c2410_wdt lost the nowayout feature during the conversion.
    
    Reviewed-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 111843f88b2a..43ba5b3ce2a3 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -53,11 +53,7 @@ struct watchdog_info {
 
 #ifdef __KERNEL__
 
-#ifdef CONFIG_WATCHDOG_NOWAYOUT
-#define WATCHDOG_NOWAYOUT	1
-#else
-#define WATCHDOG_NOWAYOUT	0
-#endif
+#include <linux/bitops.h>
 
 struct watchdog_ops;
 struct watchdog_device;
@@ -122,6 +118,21 @@ struct watchdog_device {
 #define WDOG_NO_WAY_OUT		3	/* Is 'nowayout' feature set ? */
 };
 
+#ifdef CONFIG_WATCHDOG_NOWAYOUT
+#define WATCHDOG_NOWAYOUT		1
+#define WATCHDOG_NOWAYOUT_INIT_STATUS	(1 << WDOG_NO_WAY_OUT)
+#else
+#define WATCHDOG_NOWAYOUT		0
+#define WATCHDOG_NOWAYOUT_INIT_STATUS	0
+#endif
+
+/* Use the following function to set the nowayout feature */
+static inline void watchdog_set_nowayout(struct watchdog_device *wdd, int nowayout)
+{
+	if (nowayout)
+		set_bit(WDOG_NO_WAY_OUT, &wdd->status);
+}
+
 /* Use the following functions to manipulate watchdog driver specific data */
 static inline void watchdog_set_drvdata(struct watchdog_device *wdd, void *data)
 {

commit 3f43f68e29f1dcb853d70280c7412fc0ef9a0da6
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Fri Jul 22 19:00:16 2011 +0000

    watchdog: WatchDog Timer Driver Core - Add minimum and max timeout
    
    Add min_timeout (minimum timeout) and max_timeout
    values so that the framework can check if the new
    timeout value is between the minimum and maximum
    timeout values. If both values are 0, then the
    framework will leave the check for the watchdog
    device driver itself.
    
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 325d90b6641b..111843f88b2a 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -95,6 +95,8 @@ struct watchdog_ops {
  * @ops:	Pointer to the list of watchdog operations.
  * @bootstatus:	Status of the watchdog device at boot.
  * @timeout:	The watchdog devices timeout value.
+ * @min_timeout:The watchdog devices minimum timeout value.
+ * @max_timeout:The watchdog devices maximum timeout value.
  * @driver-data:Pointer to the drivers private data.
  * @status:	Field that contains the devices internal status bits.
  *
@@ -109,6 +111,8 @@ struct watchdog_device {
 	const struct watchdog_ops *ops;
 	unsigned int bootstatus;
 	unsigned int timeout;
+	unsigned int min_timeout;
+	unsigned int max_timeout;
 	void *driver_data;
 	unsigned long status;
 /* Bit numbers for status flags */

commit 78d88fc01202b088573c962e2885556a5e99bf74
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Fri Jul 22 18:59:49 2011 +0000

    watchdog: WatchDog Timer Driver Core - Add ioctl call
    
    Add support for extra ioctl calls by adding a
    ioctl watchdog operation. This operation will be
    called before we do our own handling of ioctl
    commands. This way we can override the internal
    ioctl command handling and we can also add
    extra ioctl commands. The ioctl watchdog operation
    should return the appropriate error codes or
    -ENOIOCTLCMD if the ioctl command should be handled
    through the internal ioctl handling of the framework.
    
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index f719883c5141..325d90b6641b 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -70,6 +70,7 @@ struct watchdog_device;
  * @ping:	The routine that sends a keepalive ping to the watchdog device.
  * @status:	The routine that shows the status of the watchdog device.
  * @set_timeout:The routine for setting the watchdog devices timeout value.
+ * @ioctl:	The routines that handles extra ioctl calls.
  *
  * The watchdog_ops structure contains a list of low-level operations
  * that control a watchdog device. It also contains the module that owns
@@ -85,6 +86,7 @@ struct watchdog_ops {
 	int (*ping)(struct watchdog_device *);
 	unsigned int (*status)(struct watchdog_device *);
 	int (*set_timeout)(struct watchdog_device *, unsigned int);
+	long (*ioctl)(struct watchdog_device *, unsigned int, unsigned long);
 };
 
 /** struct watchdog_device - The structure that defines a watchdog device

commit 7e192b9c4234d29bdc20ac8d0a67edf7624b4206
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Fri Jul 22 18:59:17 2011 +0000

    watchdog: WatchDog Timer Driver Core - Add nowayout feature
    
    Add support for the nowayout feature to the
    WatchDog Timer Driver Core framework.
    This feature prevents the watchdog timer from being
    stopped.
    
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index e9881ca2452b..f719883c5141 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -113,6 +113,7 @@ struct watchdog_device {
 #define WDOG_ACTIVE		0	/* Is the watchdog running/active */
 #define WDOG_DEV_OPEN		1	/* Opened via /dev/watchdog ? */
 #define WDOG_ALLOW_RELEASE	2	/* Did we receive the magic char ? */
+#define WDOG_NO_WAY_OUT		3	/* Is 'nowayout' feature set ? */
 };
 
 /* Use the following functions to manipulate watchdog driver specific data */

commit 017cf0805105496ab1880e236cb3e4bf156fb915
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Fri Jul 22 18:58:54 2011 +0000

    watchdog: WatchDog Timer Driver Core - Add Magic Close feature
    
    Add support for the Magic Close feature to the
    WatchDog Timer Driver Core framework.
    
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 9f33efe199d1..e9881ca2452b 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -112,6 +112,7 @@ struct watchdog_device {
 /* Bit numbers for status flags */
 #define WDOG_ACTIVE		0	/* Is the watchdog running/active */
 #define WDOG_DEV_OPEN		1	/* Opened via /dev/watchdog ? */
+#define WDOG_ALLOW_RELEASE	2	/* Did we receive the magic char ? */
 };
 
 /* Use the following functions to manipulate watchdog driver specific data */

commit 014d694e5d59e4219803cd14deaae496d86e4910
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Fri Jul 22 18:58:21 2011 +0000

    watchdog: WatchDog Timer Driver Core - Add WDIOC_SETTIMEOUT and WDIOC_GETTIMEOUT ioctl
    
    This part add's the WDIOC_SETTIMEOUT and WDIOC_GETTIMEOUT ioctl
    functionality to the WatchDog Timer Driver Core framework.
    
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index db46fe89563e..9f33efe199d1 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -69,6 +69,7 @@ struct watchdog_device;
  * @stop:	The routine for stopping the watchdog device.
  * @ping:	The routine that sends a keepalive ping to the watchdog device.
  * @status:	The routine that shows the status of the watchdog device.
+ * @set_timeout:The routine for setting the watchdog devices timeout value.
  *
  * The watchdog_ops structure contains a list of low-level operations
  * that control a watchdog device. It also contains the module that owns
@@ -83,6 +84,7 @@ struct watchdog_ops {
 	/* optional operations */
 	int (*ping)(struct watchdog_device *);
 	unsigned int (*status)(struct watchdog_device *);
+	int (*set_timeout)(struct watchdog_device *, unsigned int);
 };
 
 /** struct watchdog_device - The structure that defines a watchdog device
@@ -90,6 +92,7 @@ struct watchdog_ops {
  * @info:	Pointer to a watchdog_info structure.
  * @ops:	Pointer to the list of watchdog operations.
  * @bootstatus:	Status of the watchdog device at boot.
+ * @timeout:	The watchdog devices timeout value.
  * @driver-data:Pointer to the drivers private data.
  * @status:	Field that contains the devices internal status bits.
  *
@@ -103,6 +106,7 @@ struct watchdog_device {
 	const struct watchdog_info *info;
 	const struct watchdog_ops *ops;
 	unsigned int bootstatus;
+	unsigned int timeout;
 	void *driver_data;
 	unsigned long status;
 /* Bit numbers for status flags */

commit 234445b4e4542f3e0f216459245ab369a18adcf2
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Fri Jul 22 18:57:55 2011 +0000

    watchdog: WatchDog Timer Driver Core - Add WDIOC_SETOPTIONS ioctl
    
    This part add's the WDIOC_SETOPTIONS ioctl functionality
    to the WatchDog Timer Driver Core framework.
    
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 29ff80807dd4..db46fe89563e 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -106,6 +106,7 @@ struct watchdog_device {
 	void *driver_data;
 	unsigned long status;
 /* Bit numbers for status flags */
+#define WDOG_ACTIVE		0	/* Is the watchdog running/active */
 #define WDOG_DEV_OPEN		1	/* Opened via /dev/watchdog ? */
 };
 

commit 2fa03560ab3a6dd83cad9bfd5692179fc2ceabb3
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Fri Jul 22 18:56:38 2011 +0000

    watchdog: WatchDog Timer Driver Core - Add basic ioctl functionality
    
    This part add's the basic ioctl functionality to the
    WatchDog Timer Driver Core framework. The supported
    ioctl call's are:
            WDIOC_GETSUPPORT
            WDIOC_GETSTATUS
            WDIOC_GETBOOTSTATUS
    
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 5ab31bfd2906..29ff80807dd4 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -68,6 +68,7 @@ struct watchdog_device;
  * @start:	The routine for starting the watchdog device.
  * @stop:	The routine for stopping the watchdog device.
  * @ping:	The routine that sends a keepalive ping to the watchdog device.
+ * @status:	The routine that shows the status of the watchdog device.
  *
  * The watchdog_ops structure contains a list of low-level operations
  * that control a watchdog device. It also contains the module that owns
@@ -81,12 +82,14 @@ struct watchdog_ops {
 	int (*stop)(struct watchdog_device *);
 	/* optional operations */
 	int (*ping)(struct watchdog_device *);
+	unsigned int (*status)(struct watchdog_device *);
 };
 
 /** struct watchdog_device - The structure that defines a watchdog device
  *
  * @info:	Pointer to a watchdog_info structure.
  * @ops:	Pointer to the list of watchdog operations.
+ * @bootstatus:	Status of the watchdog device at boot.
  * @driver-data:Pointer to the drivers private data.
  * @status:	Field that contains the devices internal status bits.
  *
@@ -99,6 +102,7 @@ struct watchdog_ops {
 struct watchdog_device {
 	const struct watchdog_info *info;
 	const struct watchdog_ops *ops;
+	unsigned int bootstatus;
 	void *driver_data;
 	unsigned long status;
 /* Bit numbers for status flags */

commit 43316044d4f64da008d6aca7d4b60771b9a24eb8
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Fri Jul 22 18:55:18 2011 +0000

    watchdog: WatchDog Timer Driver Core - Add basic framework
    
    The WatchDog Timer Driver Core is a framework
    that contains the common code for all watchdog-driver's.
    It also introduces a watchdog device structure and the
    operations that go with it.
    
    This is the introduction of this framework. This part
    supports the minimal watchdog userspace API (or with
    other words: the functionality to use /dev/watchdog's
    open, release and write functionality as defined in
    the simplest watchdog API). Extra functionality will
    follow in the next set of patches.
    
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 011bcfeb9f09..5ab31bfd2906 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -59,6 +59,67 @@ struct watchdog_info {
 #define WATCHDOG_NOWAYOUT	0
 #endif
 
+struct watchdog_ops;
+struct watchdog_device;
+
+/** struct watchdog_ops - The watchdog-devices operations
+ *
+ * @owner:	The module owner.
+ * @start:	The routine for starting the watchdog device.
+ * @stop:	The routine for stopping the watchdog device.
+ * @ping:	The routine that sends a keepalive ping to the watchdog device.
+ *
+ * The watchdog_ops structure contains a list of low-level operations
+ * that control a watchdog device. It also contains the module that owns
+ * these operations. The start and stop function are mandatory, all other
+ * functions are optonal.
+ */
+struct watchdog_ops {
+	struct module *owner;
+	/* mandatory operations */
+	int (*start)(struct watchdog_device *);
+	int (*stop)(struct watchdog_device *);
+	/* optional operations */
+	int (*ping)(struct watchdog_device *);
+};
+
+/** struct watchdog_device - The structure that defines a watchdog device
+ *
+ * @info:	Pointer to a watchdog_info structure.
+ * @ops:	Pointer to the list of watchdog operations.
+ * @driver-data:Pointer to the drivers private data.
+ * @status:	Field that contains the devices internal status bits.
+ *
+ * The watchdog_device structure contains all information about a
+ * watchdog timer device.
+ *
+ * The driver-data field may not be accessed directly. It must be accessed
+ * via the watchdog_set_drvdata and watchdog_get_drvdata helpers.
+ */
+struct watchdog_device {
+	const struct watchdog_info *info;
+	const struct watchdog_ops *ops;
+	void *driver_data;
+	unsigned long status;
+/* Bit numbers for status flags */
+#define WDOG_DEV_OPEN		1	/* Opened via /dev/watchdog ? */
+};
+
+/* Use the following functions to manipulate watchdog driver specific data */
+static inline void watchdog_set_drvdata(struct watchdog_device *wdd, void *data)
+{
+	wdd->driver_data = data;
+}
+
+static inline void *watchdog_get_drvdata(struct watchdog_device *wdd)
+{
+	return wdd->driver_data;
+}
+
+/* drivers/watchdog/core/watchdog_core.c */
+extern int watchdog_register_device(struct watchdog_device *);
+extern void watchdog_unregister_device(struct watchdog_device *);
+
 #endif	/* __KERNEL__ */
 
 #endif  /* ifndef _LINUX_WATCHDOG_H */

commit 58b519f3e5e491d5a3e320dc525f58ac439bdde4
Author: Wim Van Sebroeck <wim@iguana.be>
Date:   Sun May 21 12:48:44 2006 +0200

    [WATCHDOG] add WDIOC_GETTIMELEFT ioctl
    
    Some watchdog drivers have the ability to report the remaining time
    before the system will reboot. With the WDIOC_GETTIMELEFT ioctl
    you can now read the time left before the watchdog would reboot
    your system.
    
    The following drivers support this new IOCTL:
    i8xx_tco.c, pcwd_pci.c and pcwd_usb.c .
    
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
    Signed-off-by: Andrew Morton <akpm@osdl.org>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index a99c937f665e..011bcfeb9f09 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -30,6 +30,7 @@ struct watchdog_info {
 #define	WDIOC_GETTIMEOUT        _IOR(WATCHDOG_IOCTL_BASE, 7, int)
 #define	WDIOC_SETPRETIMEOUT	_IOWR(WATCHDOG_IOCTL_BASE, 8, int)
 #define	WDIOC_GETPRETIMEOUT	_IOR(WATCHDOG_IOCTL_BASE, 9, int)
+#define	WDIOC_GETTIMELEFT	_IOR(WATCHDOG_IOCTL_BASE, 10, int)
 
 #define	WDIOF_UNKNOWN		-1	/* Unknown flag error */
 #define	WDIOS_UNKNOWN		-1	/* Unknown status error */
@@ -40,9 +41,9 @@ struct watchdog_info {
 #define	WDIOF_EXTERN2		0x0008	/* External relay 2 */
 #define	WDIOF_POWERUNDER	0x0010	/* Power bad/power fault */
 #define	WDIOF_CARDRESET		0x0020	/* Card previously reset the CPU */
-#define WDIOF_POWEROVER		0x0040	/* Power over voltage */
-#define WDIOF_SETTIMEOUT	0x0080  /* Set timeout (in seconds) */
-#define WDIOF_MAGICCLOSE	0x0100	/* Supports magic close char */
+#define	WDIOF_POWEROVER		0x0040	/* Power over voltage */
+#define	WDIOF_SETTIMEOUT	0x0080  /* Set timeout (in seconds) */
+#define	WDIOF_MAGICCLOSE	0x0100	/* Supports magic close char */
 #define	WDIOF_PRETIMEOUT	0x0200  /* Pretimeout (in seconds), get/set */
 #define	WDIOF_KEEPALIVEPING	0x8000	/* Keep alive ping reply */
 

commit e05b59fe7927bc648ac3af3d59dc64a7ee6b22e2
Author: Corey Minyard <minyard@acm.org>
Date:   Wed Apr 19 22:40:53 2006 +0200

    [WATCHDOG] Pre-Timeout flags
    
    Some watchdog timers support the concept of a "pretimeout" which
    occurs some time before the real timeout.  The pretimeout can
    be delivered via an interrupt or NMI and can be used to panic
    the system when it occurs (so you get useful information instead
    of a blind reboot).
    
    Signed-off-by: Corey Minyard <minyard@acm.org>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
    Signed-off-by: Andrew Morton <akpm@osdl.org>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 1192ed8f4fe8..a99c937f665e 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -28,6 +28,8 @@ struct watchdog_info {
 #define	WDIOC_KEEPALIVE		_IOR(WATCHDOG_IOCTL_BASE, 5, int)
 #define	WDIOC_SETTIMEOUT        _IOWR(WATCHDOG_IOCTL_BASE, 6, int)
 #define	WDIOC_GETTIMEOUT        _IOR(WATCHDOG_IOCTL_BASE, 7, int)
+#define	WDIOC_SETPRETIMEOUT	_IOWR(WATCHDOG_IOCTL_BASE, 8, int)
+#define	WDIOC_GETPRETIMEOUT	_IOR(WATCHDOG_IOCTL_BASE, 9, int)
 
 #define	WDIOF_UNKNOWN		-1	/* Unknown flag error */
 #define	WDIOS_UNKNOWN		-1	/* Unknown status error */
@@ -41,6 +43,7 @@ struct watchdog_info {
 #define WDIOF_POWEROVER		0x0040	/* Power over voltage */
 #define WDIOF_SETTIMEOUT	0x0080  /* Set timeout (in seconds) */
 #define WDIOF_MAGICCLOSE	0x0100	/* Supports magic close char */
+#define	WDIOF_PRETIMEOUT	0x0200  /* Pretimeout (in seconds), get/set */
 #define	WDIOF_KEEPALIVEPING	0x8000	/* Keep alive ping reply */
 
 #define	WDIOS_DISABLECARD	0x0001	/* Turn off the watchdog timer */

commit 4bfdf37830111321e2cd1fe0102dd776ce93194d
Author: Andrey Panin <pazke@donpac.ru>
Date:   Wed Jul 27 11:43:58 2005 -0700

    [PATCH] consolidate CONFIG_WATCHDOG_NOWAYOUT handling
    
    Attached patch removes #ifdef CONFIG_WATCHDOG_NOWAYOUT mess duplicated in
    almost every watchdog driver and replaces it with common define in
    linux/watchdog.h.
    
    Signed-off-by: Andrey Panin <pazke@donpac.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 88ba0d29f8c8..1192ed8f4fe8 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -47,4 +47,14 @@ struct watchdog_info {
 #define	WDIOS_ENABLECARD	0x0002	/* Turn on the watchdog timer */
 #define	WDIOS_TEMPPANIC		0x0004	/* Kernel panic on temperature trip */
 
+#ifdef __KERNEL__
+
+#ifdef CONFIG_WATCHDOG_NOWAYOUT
+#define WATCHDOG_NOWAYOUT	1
+#else
+#define WATCHDOG_NOWAYOUT	0
+#endif
+
+#endif	/* __KERNEL__ */
+
 #endif  /* ifndef _LINUX_WATCHDOG_H */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
new file mode 100644
index 000000000000..88ba0d29f8c8
--- /dev/null
+++ b/include/linux/watchdog.h
@@ -0,0 +1,50 @@
+/*
+ *	Generic watchdog defines. Derived from..
+ *
+ * Berkshire PC Watchdog Defines
+ * by Ken Hollis <khollis@bitgate.com>
+ *
+ */
+
+#ifndef _LINUX_WATCHDOG_H
+#define _LINUX_WATCHDOG_H
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+#define	WATCHDOG_IOCTL_BASE	'W'
+
+struct watchdog_info {
+	__u32 options;		/* Options the card/driver supports */
+	__u32 firmware_version;	/* Firmware version of the card */
+	__u8  identity[32];	/* Identity of the board */
+};
+
+#define	WDIOC_GETSUPPORT	_IOR(WATCHDOG_IOCTL_BASE, 0, struct watchdog_info)
+#define	WDIOC_GETSTATUS		_IOR(WATCHDOG_IOCTL_BASE, 1, int)
+#define	WDIOC_GETBOOTSTATUS	_IOR(WATCHDOG_IOCTL_BASE, 2, int)
+#define	WDIOC_GETTEMP		_IOR(WATCHDOG_IOCTL_BASE, 3, int)
+#define	WDIOC_SETOPTIONS	_IOR(WATCHDOG_IOCTL_BASE, 4, int)
+#define	WDIOC_KEEPALIVE		_IOR(WATCHDOG_IOCTL_BASE, 5, int)
+#define	WDIOC_SETTIMEOUT        _IOWR(WATCHDOG_IOCTL_BASE, 6, int)
+#define	WDIOC_GETTIMEOUT        _IOR(WATCHDOG_IOCTL_BASE, 7, int)
+
+#define	WDIOF_UNKNOWN		-1	/* Unknown flag error */
+#define	WDIOS_UNKNOWN		-1	/* Unknown status error */
+
+#define	WDIOF_OVERHEAT		0x0001	/* Reset due to CPU overheat */
+#define	WDIOF_FANFAULT		0x0002	/* Fan failed */
+#define	WDIOF_EXTERN1		0x0004	/* External relay 1 */
+#define	WDIOF_EXTERN2		0x0008	/* External relay 2 */
+#define	WDIOF_POWERUNDER	0x0010	/* Power bad/power fault */
+#define	WDIOF_CARDRESET		0x0020	/* Card previously reset the CPU */
+#define WDIOF_POWEROVER		0x0040	/* Power over voltage */
+#define WDIOF_SETTIMEOUT	0x0080  /* Set timeout (in seconds) */
+#define WDIOF_MAGICCLOSE	0x0100	/* Supports magic close char */
+#define	WDIOF_KEEPALIVEPING	0x8000	/* Keep alive ping reply */
+
+#define	WDIOS_DISABLECARD	0x0001	/* Turn off the watchdog timer */
+#define	WDIOS_ENABLECARD	0x0002	/* Turn on the watchdog timer */
+#define	WDIOS_TEMPPANIC		0x0004	/* Kernel panic on temperature trip */
+
+#endif  /* ifndef _LINUX_WATCHDOG_H */
