commit 04a8682a71becdb639ec9c0d82b315a2baef7a5d
Author: Andrei Vagin <avagin@gmail.com>
Date:   Tue Nov 12 01:27:16 2019 +0000

    fs/proc: Introduce /proc/pid/timens_offsets
    
    API to set time namespace offsets for children processes, i.e.:
    echo "$clockid $offset_sec $offset_nsec" > /proc/self/timens_offsets
    
    Co-developed-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Andrei Vagin <avagin@gmail.com>
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20191112012724.250792-28-dima@arista.com

diff --git a/include/linux/time_namespace.h b/include/linux/time_namespace.h
index 04a2ba8b8a06..824d54e057eb 100644
--- a/include/linux/time_namespace.h
+++ b/include/linux/time_namespace.h
@@ -52,6 +52,16 @@ static inline void put_time_ns(struct time_namespace *ns)
 	kref_put(&ns->kref, free_time_ns);
 }
 
+void proc_timens_show_offsets(struct task_struct *p, struct seq_file *m);
+
+struct proc_timens_offset {
+	int			clockid;
+	struct timespec64	val;
+};
+
+int proc_timens_set_offset(struct file *file, struct task_struct *p,
+			   struct proc_timens_offset *offsets, int n);
+
 static inline void timens_add_monotonic(struct timespec64 *ts)
 {
 	struct timens_offsets *ns_offsets = &current->nsproxy->time_ns->offsets;

commit 70ddf65184ec1e8989322f35193e4fde7377f0cc
Author: Dmitry Safonov <dima@arista.com>
Date:   Tue Nov 12 01:27:15 2019 +0000

    x86/vdso: Zap vvar pages when switching to a time namespace
    
    The VVAR page layout depends on whether a task belongs to the root or
    non-root time namespace. Whenever a task changes its namespace, the VVAR
    page tables are cleared and then they will be re-faulted with a
    corresponding layout.
    
    Co-developed-by: Andrei Vagin <avagin@gmail.com>
    Signed-off-by: Andrei Vagin <avagin@gmail.com>
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20191112012724.250792-27-dima@arista.com

diff --git a/include/linux/time_namespace.h b/include/linux/time_namespace.h
index 6b7767f7df4a..04a2ba8b8a06 100644
--- a/include/linux/time_namespace.h
+++ b/include/linux/time_namespace.h
@@ -31,6 +31,9 @@ struct time_namespace {
 extern struct time_namespace init_time_ns;
 
 #ifdef CONFIG_TIME_NS
+extern int vdso_join_timens(struct task_struct *task,
+			    struct time_namespace *ns);
+
 static inline struct time_namespace *get_time_ns(struct time_namespace *ns)
 {
 	kref_get(&ns->kref);
@@ -77,6 +80,12 @@ static inline ktime_t timens_ktime_to_host(clockid_t clockid, ktime_t tim)
 }
 
 #else
+static inline int vdso_join_timens(struct task_struct *task,
+				   struct time_namespace *ns)
+{
+	return 0;
+}
+
 static inline struct time_namespace *get_time_ns(struct time_namespace *ns)
 {
 	return NULL;

commit afaa7b5ac7c87479fb5a626f87d2157af30d6401
Author: Dmitry Safonov <dima@arista.com>
Date:   Tue Nov 12 01:27:12 2019 +0000

    time: Allocate per-timens vvar page
    
    VDSO support for Time namespace needs to set up a page with the same
    layout as VVAR. That timens page will be placed on position of VVAR page
    inside namespace. That page contains time namespace clock offsets and it
    has vdso_data->seq set to 1 to enforce the slow path and
    vdso_data->clock_mode set to VCLOCK_TIMENS to enforce the time namespace
    handling path.
    
    Allocate the timens page during namespace creation. Setup the offsets
    when the first task enters the ns and freeze them to guarantee the pace
    of monotonic/boottime clocks and to avoid breakage of applications.
    
    The design decision is to have a global offset_lock which is used during
    namespace offsets setup and to freeze offsets when the first task joins the
    new time namespace. That is better in terms of memory usage compared to
    having a per namespace mutex that's used only during the setup period.
    
    Suggested-by: Andy Lutomirski <luto@kernel.org>
    Based-on-work-by: Thomas Gleixner <tglx@linutronix.de>
    Co-developed-by: Andrei Vagin <avagin@gmail.com>
    Signed-off-by: Andrei Vagin <avagin@gmail.com>
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20191112012724.250792-24-dima@arista.com

diff --git a/include/linux/time_namespace.h b/include/linux/time_namespace.h
index 063a343d1d78..6b7767f7df4a 100644
--- a/include/linux/time_namespace.h
+++ b/include/linux/time_namespace.h
@@ -23,6 +23,9 @@ struct time_namespace {
 	struct ucounts		*ucounts;
 	struct ns_common	ns;
 	struct timens_offsets	offsets;
+	struct page		*vvar_page;
+	/* If set prevents changing offsets after any task joined namespace. */
+	bool			frozen_offsets;
 } __randomize_layout;
 
 extern struct time_namespace init_time_ns;

commit 64b302ab66c5965702693e79690823ca120288b9
Author: Dmitry Safonov <dima@arista.com>
Date:   Tue Nov 12 01:27:10 2019 +0000

    x86/vdso: Provide vdso_data offset on vvar_page
    
    VDSO support for time namespaces needs to set up a page with the same
    layout as VVAR. That timens page will be placed on position of VVAR page
    inside namespace. That page has vdso_data->seq set to 1 to enforce
    the slow path and vdso_data->clock_mode set to VCLOCK_TIMENS to enforce
    the time namespace handling path.
    
    To prepare the time namespace page the kernel needs to know the vdso_data
    offset.  Provide arch_get_vdso_data() helper for locating vdso_data on VVAR
    page.
    
    Co-developed-by: Andrei Vagin <avagin@openvz.org>
    Signed-off-by: Andrei Vagin <avagin@openvz.org>
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20191112012724.250792-22-dima@arista.com

diff --git a/include/linux/time_namespace.h b/include/linux/time_namespace.h
index 34ee110b5c35..063a343d1d78 100644
--- a/include/linux/time_namespace.h
+++ b/include/linux/time_namespace.h
@@ -39,6 +39,7 @@ struct time_namespace *copy_time_ns(unsigned long flags,
 				    struct time_namespace *old_ns);
 void free_time_ns(struct kref *kref);
 int timens_on_fork(struct nsproxy *nsproxy, struct task_struct *tsk);
+struct vdso_data *arch_get_vdso_data(void *vvar_page);
 
 static inline void put_time_ns(struct time_namespace *ns)
 {

commit 89dd8eecfe961fab4924dcd14f80cf2ab2820044
Author: Andrei Vagin <avagin@gmail.com>
Date:   Tue Nov 12 01:27:01 2019 +0000

    time: Add do_timens_ktime_to_host() helper
    
    The helper subtracts namespace's clock offset from the given time
    and ensures that the result is within [0, KTIME_MAX].
    
    Co-developed-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Andrei Vagin <avagin@gmail.com>
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20191112012724.250792-13-dima@arista.com

diff --git a/include/linux/time_namespace.h b/include/linux/time_namespace.h
index d7e3b4994e31..34ee110b5c35 100644
--- a/include/linux/time_namespace.h
+++ b/include/linux/time_namespace.h
@@ -59,6 +59,19 @@ static inline void timens_add_boottime(struct timespec64 *ts)
 	*ts = timespec64_add(*ts, ns_offsets->boottime);
 }
 
+ktime_t do_timens_ktime_to_host(clockid_t clockid, ktime_t tim,
+				struct timens_offsets *offsets);
+
+static inline ktime_t timens_ktime_to_host(clockid_t clockid, ktime_t tim)
+{
+	struct time_namespace *ns = current->nsproxy->time_ns;
+
+	if (likely(ns == &init_time_ns))
+		return tim;
+
+	return do_timens_ktime_to_host(clockid, tim, &ns->offsets);
+}
+
 #else
 static inline struct time_namespace *get_time_ns(struct time_namespace *ns)
 {
@@ -88,6 +101,10 @@ static inline int timens_on_fork(struct nsproxy *nsproxy,
 
 static inline void timens_add_monotonic(struct timespec64 *ts) { }
 static inline void timens_add_boottime(struct timespec64 *ts) { }
+static inline ktime_t timens_ktime_to_host(clockid_t clockid, ktime_t tim)
+{
+	return tim;
+}
 #endif
 
 #endif /* _LINUX_TIMENS_H */

commit af993f58d69ee9c1f421dfc87c3ed231c113989c
Author: Andrei Vagin <avagin@openvz.org>
Date:   Tue Nov 12 01:26:53 2019 +0000

    time: Add timens_offsets to be used for tasks in time namespace
    
    Introduce offsets for time namespace. They will contain an adjustment
    needed to convert clocks to/from host's.
    
    A new namespace is created with the same offsets as the time namespace
    of the current process.
    
    Co-developed-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Andrei Vagin <avagin@openvz.org>
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20191112012724.250792-5-dima@arista.com

diff --git a/include/linux/time_namespace.h b/include/linux/time_namespace.h
index 8c74cc12ad24..d7e3b4994e31 100644
--- a/include/linux/time_namespace.h
+++ b/include/linux/time_namespace.h
@@ -12,11 +12,17 @@
 struct user_namespace;
 extern struct user_namespace init_user_ns;
 
+struct timens_offsets {
+	struct timespec64 monotonic;
+	struct timespec64 boottime;
+};
+
 struct time_namespace {
 	struct kref		kref;
 	struct user_namespace	*user_ns;
 	struct ucounts		*ucounts;
 	struct ns_common	ns;
+	struct timens_offsets	offsets;
 } __randomize_layout;
 
 extern struct time_namespace init_time_ns;
@@ -39,6 +45,20 @@ static inline void put_time_ns(struct time_namespace *ns)
 	kref_put(&ns->kref, free_time_ns);
 }
 
+static inline void timens_add_monotonic(struct timespec64 *ts)
+{
+	struct timens_offsets *ns_offsets = &current->nsproxy->time_ns->offsets;
+
+	*ts = timespec64_add(*ts, ns_offsets->monotonic);
+}
+
+static inline void timens_add_boottime(struct timespec64 *ts)
+{
+	struct timens_offsets *ns_offsets = &current->nsproxy->time_ns->offsets;
+
+	*ts = timespec64_add(*ts, ns_offsets->boottime);
+}
+
 #else
 static inline struct time_namespace *get_time_ns(struct time_namespace *ns)
 {
@@ -66,6 +86,8 @@ static inline int timens_on_fork(struct nsproxy *nsproxy,
 	return 0;
 }
 
+static inline void timens_add_monotonic(struct timespec64 *ts) { }
+static inline void timens_add_boottime(struct timespec64 *ts) { }
 #endif
 
 #endif /* _LINUX_TIMENS_H */

commit 769071ac9f20b6a447410c7eaa55d1a5233ef40c
Author: Andrei Vagin <avagin@openvz.org>
Date:   Tue Nov 12 01:26:52 2019 +0000

    ns: Introduce Time Namespace
    
    Time Namespace isolates clock values.
    
    The kernel provides access to several clocks CLOCK_REALTIME,
    CLOCK_MONOTONIC, CLOCK_BOOTTIME, etc.
    
    CLOCK_REALTIME
          System-wide clock that measures real (i.e., wall-clock) time.
    
    CLOCK_MONOTONIC
          Clock that cannot be set and represents monotonic time since
          some unspecified starting point.
    
    CLOCK_BOOTTIME
          Identical to CLOCK_MONOTONIC, except it also includes any time
          that the system is suspended.
    
    For many users, the time namespace means the ability to changes date and
    time in a container (CLOCK_REALTIME). Providing per namespace notions of
    CLOCK_REALTIME would be complex with a massive overhead, but has a dubious
    value.
    
    But in the context of checkpoint/restore functionality, monotonic and
    boottime clocks become interesting. Both clocks are monotonic with
    unspecified starting points. These clocks are widely used to measure time
    slices and set timers. After restoring or migrating processes, it has to be
    guaranteed that they never go backward. In an ideal case, the behavior of
    these clocks should be the same as for a case when a whole system is
    suspended. All this means that it is required to set CLOCK_MONOTONIC and
    CLOCK_BOOTTIME clocks, which can be achieved by adding per-namespace
    offsets for clocks.
    
    A time namespace is similar to a pid namespace in the way how it is
    created: unshare(CLONE_NEWTIME) system call creates a new time namespace,
    but doesn't set it to the current process. Then all children of the process
    will be born in the new time namespace, or a process can use the setns()
    system call to join a namespace.
    
    This scheme allows setting clock offsets for a namespace, before any
    processes appear in it.
    
    All available clone flags have been used, so CLONE_NEWTIME uses the highest
    bit of CSIGNAL. It means that it can be used only with the unshare() and
    the clone3() system calls.
    
    [ tglx: Adjusted paragraph about clone3() to reality and massaged the
            changelog a bit. ]
    
    Co-developed-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Andrei Vagin <avagin@gmail.com>
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://criu.org/Time_namespace
    Link: https://lists.openvz.org/pipermail/criu/2018-June/041504.html
    Link: https://lore.kernel.org/r/20191112012724.250792-4-dima@arista.com

diff --git a/include/linux/time_namespace.h b/include/linux/time_namespace.h
new file mode 100644
index 000000000000..8c74cc12ad24
--- /dev/null
+++ b/include/linux/time_namespace.h
@@ -0,0 +1,71 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _LINUX_TIMENS_H
+#define _LINUX_TIMENS_H
+
+
+#include <linux/sched.h>
+#include <linux/kref.h>
+#include <linux/nsproxy.h>
+#include <linux/ns_common.h>
+#include <linux/err.h>
+
+struct user_namespace;
+extern struct user_namespace init_user_ns;
+
+struct time_namespace {
+	struct kref		kref;
+	struct user_namespace	*user_ns;
+	struct ucounts		*ucounts;
+	struct ns_common	ns;
+} __randomize_layout;
+
+extern struct time_namespace init_time_ns;
+
+#ifdef CONFIG_TIME_NS
+static inline struct time_namespace *get_time_ns(struct time_namespace *ns)
+{
+	kref_get(&ns->kref);
+	return ns;
+}
+
+struct time_namespace *copy_time_ns(unsigned long flags,
+				    struct user_namespace *user_ns,
+				    struct time_namespace *old_ns);
+void free_time_ns(struct kref *kref);
+int timens_on_fork(struct nsproxy *nsproxy, struct task_struct *tsk);
+
+static inline void put_time_ns(struct time_namespace *ns)
+{
+	kref_put(&ns->kref, free_time_ns);
+}
+
+#else
+static inline struct time_namespace *get_time_ns(struct time_namespace *ns)
+{
+	return NULL;
+}
+
+static inline void put_time_ns(struct time_namespace *ns)
+{
+}
+
+static inline
+struct time_namespace *copy_time_ns(unsigned long flags,
+				    struct user_namespace *user_ns,
+				    struct time_namespace *old_ns)
+{
+	if (flags & CLONE_NEWTIME)
+		return ERR_PTR(-EINVAL);
+
+	return old_ns;
+}
+
+static inline int timens_on_fork(struct nsproxy *nsproxy,
+				 struct task_struct *tsk)
+{
+	return 0;
+}
+
+#endif
+
+#endif /* _LINUX_TIMENS_H */
