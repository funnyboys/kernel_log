commit 9ea393d8d8377b6da8ee25c6a114ec24c0687c7c
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Wed Mar 28 18:43:57 2018 +0300

    stm class: Add SPDX GPL-2.0 header to replace GPLv2 boilerplate
    
    This adds SPDX GPL-2.0 header to to stm core files and removes the
    GPLv2 boilerplate text.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>

diff --git a/include/linux/stm.h b/include/linux/stm.h
index 210ff2292361..c6f577ab6f21 100644
--- a/include/linux/stm.h
+++ b/include/linux/stm.h
@@ -1,15 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * System Trace Module (STM) infrastructure apis
  * Copyright (C) 2014 Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
  */
 
 #ifndef _STM_H_

commit 9dfed80d87ca2c365cd1004a91ef4ed716c8e44e
Author: Chunyan Zhang <zhang.chunyan@linaro.org>
Date:   Mon Nov 21 15:57:23 2016 +0800

    stm: Mark the functions of writing STM with notrace
    
    If CONFIG_STM_SOURCE_FTRACE is selected, Function trace data can be
    writen to sink via STM, all functions that related to writing data
    packets to STM should be marked 'notrace' to avoid being traced by
    Ftrace, otherwise the program would stall into an endless loop.
    
    Link: http://lkml.kernel.org/r/1479715043-6534-7-git-send-email-zhang.chunyan@linaro.org
    
    Signed-off-by: Chunyan Zhang <zhang.chunyan@linaro.org>
    Acked-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/stm.h b/include/linux/stm.h
index 8369d8a8cabd..210ff2292361 100644
--- a/include/linux/stm.h
+++ b/include/linux/stm.h
@@ -133,7 +133,7 @@ int stm_source_register_device(struct device *parent,
 			       struct stm_source_data *data);
 void stm_source_unregister_device(struct stm_source_data *data);
 
-int stm_source_write(struct stm_source_data *data, unsigned int chan,
-		     const char *buf, size_t count);
+int notrace stm_source_write(struct stm_source_data *data, unsigned int chan,
+			     const char *buf, size_t count);
 
 #endif /* _STM_H_ */

commit 8e996a2874bbbed30e8dfe881453825fc6b7654e
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Tue May 3 11:33:37 2016 -0600

    stm class: Support devices that override software assigned masters
    
    Some STM devices adjust software assigned master numbers depending on
    the trace source and its runtime state and whatnot. This patch adds
    a sysfs attribute to inform the trace-side software that master numbers
    assigned to software sources will not match those in the STP stream,
    so that, for example, master/channel allocation policy can be adjusted
    accordingly.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/stm.h b/include/linux/stm.h
index 1a79ed8e43da..8369d8a8cabd 100644
--- a/include/linux/stm.h
+++ b/include/linux/stm.h
@@ -50,6 +50,8 @@ struct stm_device;
  * @sw_end:		last STP master available to software
  * @sw_nchannels:	number of STP channels per master
  * @sw_mmiosz:		size of one channel's IO space, for mmap, optional
+ * @hw_override:	masters in the STP stream will not match the ones
+ *			assigned by software, but are up to the STM hardware
  * @packet:		callback that sends an STP packet
  * @mmio_addr:		mmap callback, optional
  * @link:		called when a new stm_source gets linked to us, optional
@@ -85,6 +87,7 @@ struct stm_data {
 	unsigned int		sw_end;
 	unsigned int		sw_nchannels;
 	unsigned int		sw_mmiosz;
+	unsigned int		hw_override;
 	ssize_t			(*packet)(struct stm_data *, unsigned int,
 					  unsigned int, unsigned int,
 					  unsigned int, unsigned int,

commit cc8424074e51355e0c6ba717d8edc50d408f2802
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Mon Feb 15 19:12:09 2016 +0200

    stm class: Plug stm device's unlink callback
    
    STM device's unlink callback is never actually called from anywhere in
    the stm class code.
    
    This patch adds calls to stm driver's unlink method after the unlinking
    has succeeded.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/stm.h b/include/linux/stm.h
index ab8ceca4f570..1a79ed8e43da 100644
--- a/include/linux/stm.h
+++ b/include/linux/stm.h
@@ -74,6 +74,9 @@ struct stm_device;
  *      it must return zero;
  *   3) if it does not support the requested packet type/flag combination,
  *      it must return -ENOTSUPP.
+ *
+ * The @unlink callback is called when there are no more active writers so
+ * that the master/channel can be quiesced.
  */
 struct stm_data {
 	const char		*name;

commit f8560a9bc76b2cd5c06fa412cb7b5481d70fcf34
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Mon Feb 15 19:12:01 2016 +0200

    stm class: Use driver's packet callback return value
    
    STM drivers provide a callback to generate/send individual STP packets;
    it also tells the stm core how many bytes of payload it has consumed.
    However, we would also need to use the negative space of this return
    value to communicate errors that occur during the packet generation,
    in which case the stm core will have to take appropriate action.
    
    For now, we need to account for the possibility that the stm driver may
    not support certain combinations of packet type/flags, in which case
    it is expected to signal an error.
    
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/stm.h b/include/linux/stm.h
index 9d0083d364e6..ab8ceca4f570 100644
--- a/include/linux/stm.h
+++ b/include/linux/stm.h
@@ -67,6 +67,13 @@ struct stm_device;
  * description. That is, the lowest master that can be allocated to software
  * writers is @sw_start and data from this writer will appear is @sw_start
  * master in the STP stream.
+ *
+ * The @packet callback should adhere to the following rules:
+ *   1) it must return the number of bytes it consumed from the payload;
+ *   2) therefore, if it sent a packet that does not have payload (like FLAG),
+ *      it must return zero;
+ *   3) if it does not support the requested packet type/flag combination,
+ *      it must return -ENOTSUPP.
  */
 struct stm_data {
 	const char		*name;

commit 7bd1d4093c2fa37d1ecab05da3c9d48ea2af2264
Author: Alexander Shishkin <alexander.shishkin@linux.intel.com>
Date:   Tue Sep 22 15:47:10 2015 +0300

    stm class: Introduce an abstraction for System Trace Module devices
    
    A System Trace Module (STM) is a device exporting data in System Trace
    Protocol (STP) format as defined by MIPI STP standards. Examples of such
    devices are Intel(R) Trace Hub and Coresight STM.
    
    This abstraction provides a unified interface for software trace sources
    to send their data over an STM device to a debug host. In order to do
    that, such a trace source needs to be assigned a pair of master/channel
    identifiers that all the data from this source will be tagged with. The
    STP decoder on the debug host side will use these master/channel tags to
    distinguish different trace streams from one another inside one STP
    stream.
    
    This abstraction provides a configfs-based policy management mechanism
    for dynamic allocation of these master/channel pairs based on trace
    source-supplied string identifier. It has the flexibility of being
    defined at runtime and at the same time (provided that the policy
    definition is aligned with the decoding end) consistency.
    
    For userspace trace sources, this abstraction provides write()-based and
    mmap()-based (if the underlying stm device allows this) output mechanism.
    
    For kernel-side trace sources, we provide "stm_source" device class that
    can be connected to an stm device at run time.
    
    Cc: linux-api@vger.kernel.org
    Reviewed-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/stm.h b/include/linux/stm.h
new file mode 100644
index 000000000000..9d0083d364e6
--- /dev/null
+++ b/include/linux/stm.h
@@ -0,0 +1,126 @@
+/*
+ * System Trace Module (STM) infrastructure apis
+ * Copyright (C) 2014 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef _STM_H_
+#define _STM_H_
+
+#include <linux/device.h>
+
+/**
+ * enum stp_packet_type - STP packets that an STM driver sends
+ */
+enum stp_packet_type {
+	STP_PACKET_DATA = 0,
+	STP_PACKET_FLAG,
+	STP_PACKET_USER,
+	STP_PACKET_MERR,
+	STP_PACKET_GERR,
+	STP_PACKET_TRIG,
+	STP_PACKET_XSYNC,
+};
+
+/**
+ * enum stp_packet_flags - STP packet modifiers
+ */
+enum stp_packet_flags {
+	STP_PACKET_MARKED	= 0x1,
+	STP_PACKET_TIMESTAMPED	= 0x2,
+};
+
+struct stp_policy;
+
+struct stm_device;
+
+/**
+ * struct stm_data - STM device description and callbacks
+ * @name:		device name
+ * @stm:		internal structure, only used by stm class code
+ * @sw_start:		first STP master available to software
+ * @sw_end:		last STP master available to software
+ * @sw_nchannels:	number of STP channels per master
+ * @sw_mmiosz:		size of one channel's IO space, for mmap, optional
+ * @packet:		callback that sends an STP packet
+ * @mmio_addr:		mmap callback, optional
+ * @link:		called when a new stm_source gets linked to us, optional
+ * @unlink:		likewise for unlinking, again optional
+ * @set_options:	set device-specific options on a channel
+ *
+ * Fill out this structure before calling stm_register_device() to create
+ * an STM device and stm_unregister_device() to destroy it. It will also be
+ * passed back to @packet(), @mmio_addr(), @link(), @unlink() and @set_options()
+ * callbacks.
+ *
+ * Normally, an STM device will have a range of masters available to software
+ * and the rest being statically assigned to various hardware trace sources.
+ * The former is defined by the the range [@sw_start..@sw_end] of the device
+ * description. That is, the lowest master that can be allocated to software
+ * writers is @sw_start and data from this writer will appear is @sw_start
+ * master in the STP stream.
+ */
+struct stm_data {
+	const char		*name;
+	struct stm_device	*stm;
+	unsigned int		sw_start;
+	unsigned int		sw_end;
+	unsigned int		sw_nchannels;
+	unsigned int		sw_mmiosz;
+	ssize_t			(*packet)(struct stm_data *, unsigned int,
+					  unsigned int, unsigned int,
+					  unsigned int, unsigned int,
+					  const unsigned char *);
+	phys_addr_t		(*mmio_addr)(struct stm_data *, unsigned int,
+					     unsigned int, unsigned int);
+	int			(*link)(struct stm_data *, unsigned int,
+					unsigned int);
+	void			(*unlink)(struct stm_data *, unsigned int,
+					  unsigned int);
+	long			(*set_options)(struct stm_data *, unsigned int,
+					       unsigned int, unsigned int,
+					       unsigned long);
+};
+
+int stm_register_device(struct device *parent, struct stm_data *stm_data,
+			struct module *owner);
+void stm_unregister_device(struct stm_data *stm_data);
+
+struct stm_source_device;
+
+/**
+ * struct stm_source_data - STM source device description and callbacks
+ * @name:	device name, will be used for policy lookup
+ * @src:	internal structure, only used by stm class code
+ * @nr_chans:	number of channels to allocate
+ * @link:	called when this source gets linked to an STM device
+ * @unlink:	called when this source is about to get unlinked from its STM
+ *
+ * Fill in this structure before calling stm_source_register_device() to
+ * register a source device. Also pass it to unregister and write calls.
+ */
+struct stm_source_data {
+	const char		*name;
+	struct stm_source_device *src;
+	unsigned int		percpu;
+	unsigned int		nr_chans;
+	int			(*link)(struct stm_source_data *data);
+	void			(*unlink)(struct stm_source_data *data);
+};
+
+int stm_source_register_device(struct device *parent,
+			       struct stm_source_data *data);
+void stm_source_unregister_device(struct stm_source_data *data);
+
+int stm_source_write(struct stm_source_data *data, unsigned int chan,
+		     const char *buf, size_t count);
+
+#endif /* _STM_H_ */
