commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/ppp_channel.h b/include/linux/ppp_channel.h
index 5d87f810a3b7..98966064ee68 100644
--- a/include/linux/ppp_channel.h
+++ b/include/linux/ppp_channel.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 #ifndef _PPP_CHANNEL_H_
 #define _PPP_CHANNEL_H_
 /*
@@ -11,11 +12,6 @@
  *
  * Copyright 1999 Paul Mackerras.
  *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version
- *  2 of the License, or (at your option) any later version.
- *
  * ==FILEVERSION 20000322==
  */
 

commit d7100da026317fcf07411f765fe1cdb044053917
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Wed Aug 4 07:34:36 2010 +0000

    ppp: make channel_ops const
    
    The PPP channel ops structure should be const.
    Cleanup the declarations to use standard C99 format.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/ppp_channel.h b/include/linux/ppp_channel.h
index bff98ec1bfed..5d87f810a3b7 100644
--- a/include/linux/ppp_channel.h
+++ b/include/linux/ppp_channel.h
@@ -36,7 +36,7 @@ struct ppp_channel_ops {
 
 struct ppp_channel {
 	void		*private;	/* channel private data */
-	struct ppp_channel_ops *ops;	/* operations for this channel */
+	const struct ppp_channel_ops *ops; /* operations for this channel */
 	int		mtu;		/* max transmit packet size */
 	int		hdrlen;		/* amount of headroom channel needs */
 	void		*ppp;		/* opaque to channel */

commit 63f96072f9ba430aa348bc987c3d5a4f48bae301
Author: James Chapman <jchapman@katalix.com>
Date:   Fri Apr 2 06:18:39 2010 +0000

    ppp: Add ppp_dev_name() exported function
    
    ppp_dev_name() gives PPP users visibility of a ppp channel's device
    name. This can be used by L2TP drivers to dump the assigned PPP
    interface name.
    
    Signed-off-by: James Chapman <jchapman@katalix.com>
    Reviewed-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/ppp_channel.h b/include/linux/ppp_channel.h
index 0d3fa63e90ea..bff98ec1bfed 100644
--- a/include/linux/ppp_channel.h
+++ b/include/linux/ppp_channel.h
@@ -72,6 +72,9 @@ extern int ppp_channel_index(struct ppp_channel *);
 /* Get the unit number associated with a channel, or -1 if none */
 extern int ppp_unit_number(struct ppp_channel *);
 
+/* Get the device name associated with a channel, or NULL if none */
+extern char *ppp_dev_name(struct ppp_channel *);
+
 /*
  * SMP locking notes:
  * The channel code must ensure that when it calls ppp_unregister_channel,

commit 9c705260feea6ae329bc6b6d5f6d2ef0227eda0a
Author: Gabriele Paoloni <gabriele.paoloni@intel.com>
Date:   Fri Mar 13 16:09:12 2009 -0700

    ppp: ppp_mp_explode() redesign
    
    I found the PPP subsystem to not work properly when connecting channels
    with different speeds to the same bundle.
    
    Problem Description:
    
    As the "ppp_mp_explode" function fragments the sk_buff buffer evenly
    among the PPP channels that are connected to a certain PPP unit to
    make up a bundle, if we are transmitting using an upper layer protocol
    that requires an Ack before sending the next packet (like TCP/IP for
    example), we will have a bandwidth bottleneck on the slowest channel
    of the bundle.
    
    Let's clarify by an example. Let's consider a scenario where we have
    two PPP links making up a bundle: a slow link (10KB/sec) and a fast
    link (1000KB/sec) working at the best (full bandwidth). On the top we
    have a TCP/IP stack sending a 1000 Bytes sk_buff buffer down to the
    PPP subsystem. The "ppp_mp_explode" function will divide the buffer in
    two fragments of 500B each (we are neglecting all the headers, crc,
    flags etc?.). Before the TCP/IP stack sends out the next buffer, it
    will have to wait for the ACK response from the remote peer, so it
    will have to wait for both fragments to have been sent over the two
    PPP links, received by the remote peer and reconstructed. The
    resulting behaviour is that, rather than having a bundle working
    @1010KB/sec (the sum of the channels bandwidths), we'll have a bundle
    working @20KB/sec (the double of the slowest channels bandwidth).
    
    
    Problem Solution:
    
    The problem has been solved by redesigning the "ppp_mp_explode"
    function in such a way to make it split the sk_buff buffer according
    to the speeds of the underlying PPP channels (the speeds of the serial
    interfaces respectively attached to the PPP channels). Referring to
    the above example, the redesigned "ppp_mp_explode" function will now
    divide the 1000 Bytes buffer into two fragments whose sizes are set
    according to the speeds of the channels where they are going to be
    sent on (e.g .  10 Byets on 10KB/sec channel and 990 Bytes on
    1000KB/sec channel).  The reworked function grants the same
    performances of the original one in optimal working conditions (i.e. a
    bundle made up of PPP links all working at the same speed), while
    greatly improving performances on the bundles made up of channels
    working at different speeds.
    
    Signed-off-by: Gabriele Paoloni <gabriele.paoloni@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/ppp_channel.h b/include/linux/ppp_channel.h
index 9d64bdf14770..0d3fa63e90ea 100644
--- a/include/linux/ppp_channel.h
+++ b/include/linux/ppp_channel.h
@@ -40,8 +40,8 @@ struct ppp_channel {
 	int		mtu;		/* max transmit packet size */
 	int		hdrlen;		/* amount of headroom channel needs */
 	void		*ppp;		/* opaque to channel */
-	/* the following are not used at present */
 	int		speed;		/* transfer rate (bytes/second) */
+	/* the following is not used at present */
 	int		latency;	/* overhead time in milliseconds */
 };
 

commit 273ec51dd7ceaa76e038875d85061ec856d8905e
Author: Cyrill Gorcunov <gorcunov@gmail.com>
Date:   Wed Jan 21 15:55:35 2009 -0800

    net: ppp_generic - introduce net-namespace functionality v2
    
    - Each namespace contains ppp channels and units separately
      with appropriate locks
    
    Signed-off-by: Cyrill Gorcunov <gorcunov@openvz.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/ppp_channel.h b/include/linux/ppp_channel.h
index a942892d6dfe..9d64bdf14770 100644
--- a/include/linux/ppp_channel.h
+++ b/include/linux/ppp_channel.h
@@ -22,6 +22,7 @@
 #include <linux/list.h>
 #include <linux/skbuff.h>
 #include <linux/poll.h>
+#include <net/net_namespace.h>
 
 struct ppp_channel;
 
@@ -56,6 +57,9 @@ extern void ppp_input(struct ppp_channel *, struct sk_buff *);
    that we may have missed a packet. */
 extern void ppp_input_error(struct ppp_channel *, int code);
 
+/* Attach a channel to a given PPP unit in specified net. */
+extern int ppp_register_net_channel(struct net *, struct ppp_channel *);
+
 /* Attach a channel to a given PPP unit. */
 extern int ppp_register_channel(struct ppp_channel *);
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/ppp_channel.h b/include/linux/ppp_channel.h
new file mode 100644
index 000000000000..a942892d6dfe
--- /dev/null
+++ b/include/linux/ppp_channel.h
@@ -0,0 +1,81 @@
+#ifndef _PPP_CHANNEL_H_
+#define _PPP_CHANNEL_H_
+/*
+ * Definitions for the interface between the generic PPP code
+ * and a PPP channel.
+ *
+ * A PPP channel provides a way for the generic PPP code to send
+ * and receive packets over some sort of communications medium.
+ * Packets are stored in sk_buffs and have the 2-byte PPP protocol
+ * number at the start, but not the address and control bytes.
+ *
+ * Copyright 1999 Paul Mackerras.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ *
+ * ==FILEVERSION 20000322==
+ */
+
+#include <linux/list.h>
+#include <linux/skbuff.h>
+#include <linux/poll.h>
+
+struct ppp_channel;
+
+struct ppp_channel_ops {
+	/* Send a packet (or multilink fragment) on this channel.
+	   Returns 1 if it was accepted, 0 if not. */
+	int	(*start_xmit)(struct ppp_channel *, struct sk_buff *);
+	/* Handle an ioctl call that has come in via /dev/ppp. */
+	int	(*ioctl)(struct ppp_channel *, unsigned int, unsigned long);
+};
+
+struct ppp_channel {
+	void		*private;	/* channel private data */
+	struct ppp_channel_ops *ops;	/* operations for this channel */
+	int		mtu;		/* max transmit packet size */
+	int		hdrlen;		/* amount of headroom channel needs */
+	void		*ppp;		/* opaque to channel */
+	/* the following are not used at present */
+	int		speed;		/* transfer rate (bytes/second) */
+	int		latency;	/* overhead time in milliseconds */
+};
+
+#ifdef __KERNEL__
+/* Called by the channel when it can send some more data. */
+extern void ppp_output_wakeup(struct ppp_channel *);
+
+/* Called by the channel to process a received PPP packet.
+   The packet should have just the 2-byte PPP protocol header. */
+extern void ppp_input(struct ppp_channel *, struct sk_buff *);
+
+/* Called by the channel when an input error occurs, indicating
+   that we may have missed a packet. */
+extern void ppp_input_error(struct ppp_channel *, int code);
+
+/* Attach a channel to a given PPP unit. */
+extern int ppp_register_channel(struct ppp_channel *);
+
+/* Detach a channel from its PPP unit (e.g. on hangup). */
+extern void ppp_unregister_channel(struct ppp_channel *);
+
+/* Get the channel number for a channel */
+extern int ppp_channel_index(struct ppp_channel *);
+
+/* Get the unit number associated with a channel, or -1 if none */
+extern int ppp_unit_number(struct ppp_channel *);
+
+/*
+ * SMP locking notes:
+ * The channel code must ensure that when it calls ppp_unregister_channel,
+ * nothing is executing in any of the procedures above, for that
+ * channel.  The generic layer will ensure that nothing is executing
+ * in the start_xmit and ioctl routines for the channel by the time
+ * that ppp_unregister_channel returns.
+ */
+
+#endif /* __KERNEL__ */
+#endif
