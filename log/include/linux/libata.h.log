commit 3cd1c5d582f42fead949947a6e3c8f51797580c9
Merge: c322f5399fc3 afe89f115e84
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 27 15:20:03 2020 -0700

    Merge tag 'scsi-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI fixes from James Bottomley:
     "Six small fixes, five in drivers and one to correct another minor
      regression from cc97923a5bcc ("block: move dma drain handling to
      scsi") where we still need the drain stub to be built in to the kernel
      for the modular libata, non-modular SAS driver case"
    
    * tag 'scsi-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi:
      scsi: mptscsih: Fix read sense data size
      scsi: zfcp: Fix panic on ERP timeout for previously dismissed ERP action
      scsi: lpfc: Avoid another null dereference in lpfc_sli4_hba_unset()
      scsi: libata: Fix the ata_scsi_dma_need_drain stub
      scsi: qla2xxx: Keep initiator ports after RSCN
      scsi: qla2xxx: Set NVMe status code for failed NVMe FCP request

commit aad4b4d15f30de087c5972cfb767fadb5dbc3c52
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jun 20 09:13:02 2020 +0200

    scsi: libata: Fix the ata_scsi_dma_need_drain stub
    
    We not only need the stub when libata is disabled, but also if it is
    modular and there are built-in SAS drivers (which can happen when
    SCSI_SAS_ATA is disabled).
    
    Link: https://lore.kernel.org/r/20200620071302.462974-2-hch@lst.de
    Fixes: b8f1d1e05817 ("scsi: Wire up ata_scsi_dma_need_drain for SAS HBA drivers")
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 042e584daca7..c57bf6749681 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1092,7 +1092,7 @@ extern int ata_scsi_ioctl(struct scsi_device *dev, unsigned int cmd,
 #define ATA_SCSI_COMPAT_IOCTL /* empty */
 #endif
 extern int ata_scsi_queuecmd(struct Scsi_Host *h, struct scsi_cmnd *cmd);
-#if IS_ENABLED(CONFIG_ATA)
+#if IS_REACHABLE(CONFIG_ATA)
 bool ata_scsi_dma_need_drain(struct request *rq);
 #else
 #define ata_scsi_dma_need_drain NULL

commit 64677779e8962c20b580b471790fe42367750599
Merge: a5c6a1f0fe1d b8f1d1e05817
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 20 19:23:13 2020 -0700

    Merge tag 'scsi-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI fixes from James Bottomley:
     "One minor fix and two patches reworking the ata dma drain for the
      !CONFIG_LIBATA case. The latter is a 5.7 regression fix"
    
    * tag 'scsi-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi:
      scsi: Wire up ata_scsi_dma_need_drain for SAS HBA drivers
      scsi: libata: Provide an ata_scsi_dma_need_drain stub for !CONFIG_ATA
      scsi: ufs-bsg: Fix runtime PM imbalance on error

commit 592be758f196ed4610e326fc3f33dadd80aa7c6b
Merge: 62c91ead977a b5292111de9b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 19 13:09:40 2020 -0700

    Merge tag 'libata-5.8-2020-06-19' of git://git.kernel.dk/linux-block
    
    Pull libata fixes from Jens Axboe:
     "A few minor changes that should go into this release"
    
    * tag 'libata-5.8-2020-06-19' of git://git.kernel.dk/linux-block:
      libata: Use per port sync for detach
      ata/libata: Fix usage of page address by page_address in ata_scsi_mode_select_xlat function
      sata_rcar: handle pm_runtime_get_sync failure cases

commit b5292111de9bb70cba3489075970889765302136
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Wed Jun 3 15:48:19 2020 +0800

    libata: Use per port sync for detach
    
    Commit 130f4caf145c ("libata: Ensure ata_port probe has completed before
    detach") may cause system freeze during suspend.
    
    Using async_synchronize_full() in PM callbacks is wrong, since async
    callbacks that are already scheduled may wait for not-yet-scheduled
    callbacks, causes a circular dependency.
    
    Instead of using big hammer like async_synchronize_full(), use async
    cookie to make sure port probe are synced, without affecting other
    scheduled PM callbacks.
    
    Fixes: 130f4caf145c ("libata: Ensure ata_port probe has completed before detach")
    Suggested-by: John Garry <john.garry@huawei.com>
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Tested-by: John Garry <john.garry@huawei.com>
    BugLink: https://bugs.launchpad.net/bugs/1867983
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index af832852e620..8a4843704d28 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -22,6 +22,7 @@
 #include <linux/acpi.h>
 #include <linux/cdrom.h>
 #include <linux/sched.h>
+#include <linux/async.h>
 
 /*
  * Define if arch has non-standard setup.  This is a _PCI_ standard
@@ -872,6 +873,8 @@ struct ata_port {
 	struct timer_list	fastdrain_timer;
 	unsigned long		fastdrain_cnt;
 
+	async_cookie_t		cookie;
+
 	int			em_message_type;
 	void			*private_data;
 

commit 9c5fbf05cb00cc9e6f1baf42751c6bfe1e6859ba
Author: Gustavo A. R. Silva <gustavoars@kernel.org>
Date:   Thu May 28 09:35:11 2020 -0500

    libata: Replace zero-length array with flexible-array
    
    There is a regular need in the kernel to provide a way to declare having a
    dynamically sized set of trailing elements in a structure. Kernel code should
    always use “flexible array members”[1] for these cases. The older style of
    one-element or zero-length arrays should no longer be used[2].
    
    [1] https://en.wikipedia.org/wiki/Flexible_array_member
    [2] https://github.com/KSPP/linux/issues/21
    
    Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index af832852e620..8bf5e59a7859 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -609,7 +609,7 @@ struct ata_host {
 	struct task_struct	*eh_owner;
 
 	struct ata_port		*simplex_claimed;	/* channel owning the DMA */
-	struct ata_port		*ports[0];
+	struct ata_port		*ports[];
 };
 
 struct ata_queued_cmd {

commit 7bb7ee8704fea9fec9eea53322b8464c3ed70a3d
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jun 15 08:46:23 2020 +0200

    scsi: libata: Provide an ata_scsi_dma_need_drain stub for !CONFIG_ATA
    
    SAS drivers can be compiled with ata support disabled.  Provide a stub so
    that the drivers don't have to ifdef around wiring up
    ata_scsi_dma_need_drain.
    
    Link: https://lore.kernel.org/r/20200615064624.37317-2-hch@lst.de
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index af832852e620..042e584daca7 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1092,7 +1092,11 @@ extern int ata_scsi_ioctl(struct scsi_device *dev, unsigned int cmd,
 #define ATA_SCSI_COMPAT_IOCTL /* empty */
 #endif
 extern int ata_scsi_queuecmd(struct Scsi_Host *h, struct scsi_cmnd *cmd);
+#if IS_ENABLED(CONFIG_ATA)
 bool ata_scsi_dma_need_drain(struct request *rq);
+#else
+#define ata_scsi_dma_need_drain NULL
+#endif
 extern int ata_sas_scsi_ioctl(struct ata_port *ap, struct scsi_device *dev,
 			    unsigned int cmd, void __user *arg);
 extern bool ata_link_online(struct ata_link *link);

commit cc97923a5bccc776851c242b61015faf288d5c22
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Apr 14 09:42:24 2020 +0200

    block: move dma drain handling to scsi
    
    Don't burden the common block code with with specifics of the libata DMA
    draining mechanism.  Instead move most of the code to the scsi midlayer.
    
    That also means the nr_phys_segments adjustments in the blk-mq fast path
    can go away entirely, given that SCSI never looks at nr_phys_segments
    after mapping the request to a scatterlist.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index cffa4714bfa8..af832852e620 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1092,6 +1092,7 @@ extern int ata_scsi_ioctl(struct scsi_device *dev, unsigned int cmd,
 #define ATA_SCSI_COMPAT_IOCTL /* empty */
 #endif
 extern int ata_scsi_queuecmd(struct Scsi_Host *h, struct scsi_cmnd *cmd);
+bool ata_scsi_dma_need_drain(struct request *rq);
 extern int ata_sas_scsi_ioctl(struct ata_port *ap, struct scsi_device *dev,
 			    unsigned int cmd, void __user *arg);
 extern bool ata_link_online(struct ata_link *link);
@@ -1387,6 +1388,7 @@ extern struct device_attribute *ata_common_sdev_attrs[];
 	.ioctl			= ata_scsi_ioctl,		\
 	ATA_SCSI_COMPAT_IOCTL					\
 	.queuecommand		= ata_scsi_queuecmd,		\
+	.dma_need_drain		= ata_scsi_dma_need_drain,	\
 	.can_queue		= ATA_DEF_QUEUE,		\
 	.tag_alloc_policy	= BLK_TAG_ALLOC_RR,		\
 	.this_id		= ATA_SHT_THIS_ID,		\

commit a0ccd2511b6f70394b30f8290da8bfc723d6bc07
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Mar 26 16:58:21 2020 +0100

    ata: move ata_eh_analyze_ncq_error() & co. to libata-sata.c
    
    * move ata_eh_analyze_ncq_error() and ata_eh_read_log_10h() to
      libata-sata.c
    
    * add static inline for ata_eh_analyze_ncq_error() for
      CONFIG_SATA_HOST=n case (link->sactive is non-zero only if
      NCQ commands are actually queued so empty function body is
      sufficient)
    
    Code size savings on m68k arch using (modified) atari_defconfig:
    
       text    data     bss     dec     hex filename
    before:
      16164      18       0   16182    3f36 drivers/ata/libata-eh.o
    after:
      15446      18       0   15464    3c68 drivers/ata/libata-eh.o
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 9c7ca659dc94..cffa4714bfa8 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1181,6 +1181,7 @@ extern int sata_link_hardreset(struct ata_link *link,
 			bool *online, int (*check_ready)(struct ata_link *));
 extern int sata_link_resume(struct ata_link *link, const unsigned long *params,
 			    unsigned long deadline);
+extern void ata_eh_analyze_ncq_error(struct ata_link *link);
 #else
 static inline const unsigned long *
 sata_ehc_deb_timing(struct ata_eh_context *ehc)
@@ -1217,6 +1218,7 @@ static inline int sata_link_resume(struct ata_link *link,
 {
 	return -EOPNOTSUPP;
 }
+static inline void ata_eh_analyze_ncq_error(struct ata_link *link) { }
 #endif
 extern int sata_link_debounce(struct ata_link *link,
 			const unsigned long *params, unsigned long deadline);
@@ -1339,7 +1341,6 @@ extern void ata_eh_thaw_port(struct ata_port *ap);
 
 extern void ata_eh_qc_complete(struct ata_queued_cmd *qc);
 extern void ata_eh_qc_retry(struct ata_queued_cmd *qc);
-extern void ata_eh_analyze_ncq_error(struct ata_link *link);
 
 extern void ata_do_eh(struct ata_port *ap, ata_prereset_fn_t prereset,
 		      ata_reset_fn_t softreset, ata_reset_fn_t hardreset,

commit a695de27fca5cefce0d1d93bab681e35605fee55
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Mar 26 16:58:20 2020 +0100

    ata: start separating SATA specific code from libata-eh.c
    
    Start separating SATA specific code from libata-eh.c:
    
    * move sata_async_notification() to libata-sata.c:
    
    Code size savings on m68k arch using (modified) atari_defconfig:
    
       text    data     bss     dec     hex filename
    before:
      16243      18       0   16261    3f85 drivers/ata/libata-eh.o
    after:
      16164      18       0   16182    3f36 drivers/ata/libata-eh.o
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index da899f18a3e9..9c7ca659dc94 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1240,6 +1240,7 @@ extern void ata_tf_to_fis(const struct ata_taskfile *tf,
 extern void ata_tf_from_fis(const u8 *fis, struct ata_taskfile *tf);
 extern int ata_qc_complete_multiple(struct ata_port *ap, u64 qc_active);
 extern bool sata_lpm_ignore_phy_events(struct ata_link *link);
+extern int sata_async_notification(struct ata_port *ap);
 
 extern int ata_cable_40wire(struct ata_port *ap);
 extern int ata_cable_80wire(struct ata_port *ap);
@@ -1332,7 +1333,6 @@ extern void ata_port_wait_eh(struct ata_port *ap);
 extern int ata_link_abort(struct ata_link *link);
 extern int ata_port_abort(struct ata_port *ap);
 extern int ata_port_freeze(struct ata_port *ap);
-extern int sata_async_notification(struct ata_port *ap);
 
 extern void ata_eh_freeze_port(struct ata_port *ap);
 extern void ata_eh_thaw_port(struct ata_port *ap);

commit 15964ff72832ee489ae9e31c4e1a924e80e05dcb
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Mar 26 16:58:19 2020 +0100

    ata: move ata_sas_*() to libata-sata.c
    
    * un-inline:
      - ata_scsi_dump_cdb()
      - __ata_scsi_queuecmd()
    
    * un-static:
      - ata_scsi_sdev_config()
      - ata_scsi_dev_config()
      - ata_scsi_dump_cdb()
      - __ata_scsi_queuecmd()
    
    * move ata_sas_*() to libata-sata.c:
    
    * add static inlines for CONFIG_SATA_HOST=n case for
      ata_sas_{allocate,free}_tag()
    
    Code size savings on m68k arch using (modified) atari_defconfig:
    
       text    data     bss     dec     hex filename
    before:
      19137      23     576   19736    4d18 drivers/ata/libata-scsi.o
    after:
      18330      23     576   18929    49f1 drivers/ata/libata-scsi.o
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ae74fd048a32..da899f18a3e9 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1094,18 +1094,6 @@ extern int ata_scsi_ioctl(struct scsi_device *dev, unsigned int cmd,
 extern int ata_scsi_queuecmd(struct Scsi_Host *h, struct scsi_cmnd *cmd);
 extern int ata_sas_scsi_ioctl(struct ata_port *ap, struct scsi_device *dev,
 			    unsigned int cmd, void __user *arg);
-extern void ata_sas_port_destroy(struct ata_port *);
-extern struct ata_port *ata_sas_port_alloc(struct ata_host *,
-					   struct ata_port_info *, struct Scsi_Host *);
-extern void ata_sas_async_probe(struct ata_port *ap);
-extern int ata_sas_sync_probe(struct ata_port *ap);
-extern int ata_sas_port_init(struct ata_port *);
-extern int ata_sas_port_start(struct ata_port *ap);
-extern int ata_sas_tport_add(struct device *parent, struct ata_port *ap);
-extern void ata_sas_tport_delete(struct ata_port *ap);
-extern void ata_sas_port_stop(struct ata_port *ap);
-extern int ata_sas_slave_configure(struct scsi_device *, struct ata_port *);
-extern int ata_sas_queuecmd(struct scsi_cmnd *cmd, struct ata_port *ap);
 extern bool ata_link_online(struct ata_link *link);
 extern bool ata_link_offline(struct ata_link *link);
 #ifdef CONFIG_PM
@@ -1235,6 +1223,18 @@ extern int sata_link_debounce(struct ata_link *link,
 extern int sata_link_scr_lpm(struct ata_link *link, enum ata_lpm_policy policy,
 			     bool spm_wakeup);
 extern int ata_slave_link_init(struct ata_port *ap);
+extern void ata_sas_port_destroy(struct ata_port *);
+extern struct ata_port *ata_sas_port_alloc(struct ata_host *,
+					   struct ata_port_info *, struct Scsi_Host *);
+extern void ata_sas_async_probe(struct ata_port *ap);
+extern int ata_sas_sync_probe(struct ata_port *ap);
+extern int ata_sas_port_init(struct ata_port *);
+extern int ata_sas_port_start(struct ata_port *ap);
+extern int ata_sas_tport_add(struct device *parent, struct ata_port *ap);
+extern void ata_sas_tport_delete(struct ata_port *ap);
+extern void ata_sas_port_stop(struct ata_port *ap);
+extern int ata_sas_slave_configure(struct scsi_device *, struct ata_port *);
+extern int ata_sas_queuecmd(struct scsi_cmnd *cmd, struct ata_port *ap);
 extern void ata_tf_to_fis(const struct ata_taskfile *tf,
 			  u8 pmp, int is_cmd, u8 *fis);
 extern void ata_tf_from_fis(const u8 *fis, struct ata_taskfile *tf);

commit ec811a94c5bb6916d01c02dc99c8cecfa59cbb85
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Mar 26 16:58:18 2020 +0100

    ata: start separating SATA specific code from libata-scsi.c
    
    Start separating SATA specific code from libata-scsi.c:
    
    * un-static ata_scsi_find_dev()
    
    * move following code to libata-sata.c:
      - SATA only sysfs device attributes handling
      - __ata_change_queue_depth()
      - ata_scsi_change_queue_depth()
    
    * cover with CONFIG_SATA_HOST ifdef SATA only sysfs device
      attributes handling code and ATA_SHT_NCQ() macro in
      <linux/libata.h>
    
    Code size savings on m68k arch using (modified) atari_defconfig:
    
       text    data     bss     dec     hex filename
    before:
      20702     105     576   21383    5387 drivers/ata/libata-scsi.o
    after:
      19137      23     576   19736    4d18 drivers/ata/libata-scsi.o
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 90c929b5df3d..ae74fd048a32 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -530,12 +530,14 @@ typedef int (*ata_reset_fn_t)(struct ata_link *link, unsigned int *classes,
 			      unsigned long deadline);
 typedef void (*ata_postreset_fn_t)(struct ata_link *link, unsigned int *classes);
 
-extern struct device_attribute dev_attr_link_power_management_policy;
 extern struct device_attribute dev_attr_unload_heads;
+#ifdef CONFIG_SATA_HOST
+extern struct device_attribute dev_attr_link_power_management_policy;
 extern struct device_attribute dev_attr_ncq_prio_enable;
 extern struct device_attribute dev_attr_em_message_type;
 extern struct device_attribute dev_attr_em_message;
 extern struct device_attribute dev_attr_sw_activity;
+#endif
 
 enum sw_activity {
 	OFF,
@@ -1371,7 +1373,6 @@ extern int ata_link_nr_enabled(struct ata_link *link);
 extern const struct ata_port_operations ata_base_port_ops;
 extern const struct ata_port_operations sata_port_ops;
 extern struct device_attribute *ata_common_sdev_attrs[];
-extern struct device_attribute *ata_ncq_sdev_attrs[];
 
 /*
  * All sht initializers (BASE, PIO, BMDMA, NCQ) must be instantiated
@@ -1399,10 +1400,14 @@ extern struct device_attribute *ata_ncq_sdev_attrs[];
 	__ATA_BASE_SHT(drv_name),				\
 	.sdev_attrs		= ata_common_sdev_attrs
 
+#ifdef CONFIG_SATA_HOST
+extern struct device_attribute *ata_ncq_sdev_attrs[];
+
 #define ATA_NCQ_SHT(drv_name)					\
 	__ATA_BASE_SHT(drv_name),				\
 	.sdev_attrs		= ata_ncq_sdev_attrs,		\
 	.change_queue_depth	= ata_scsi_change_queue_depth
+#endif
 
 /*
  * PMP helpers

commit 2b384ede7107a528c65ec826e045b572bcb2aa0b
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Mar 26 16:58:17 2020 +0100

    ata: move sata_deb_timing_*() to libata-sata.c
    
    * move sata_deb_timing_*() to libata-sata.c
    
    * add static inline for sata_ehc_deb_timing() for
      CONFIG_SATA_HOST=n case
    
    Code size savings on m68k arch using (modified) atari_defconfig:
    
       text    data     bss     dec     hex filename
    before:
      32158     572      40   32770    8002 drivers/ata/libata-core.o
    after:
      32015     572      40   32627    7f73 drivers/ata/libata-core.o
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 08fec96a6a1e..90c929b5df3d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1019,10 +1019,6 @@ struct ata_timing {
 /*
  * Core layer - drivers/ata/libata-core.c
  */
-extern const unsigned long sata_deb_timing_normal[];
-extern const unsigned long sata_deb_timing_hotplug[];
-extern const unsigned long sata_deb_timing_long[];
-
 extern struct ata_port_operations ata_dummy_port_ops;
 extern const struct ata_port_info ata_dummy_port_info;
 
@@ -1060,15 +1056,6 @@ static inline int is_multi_taskfile(struct ata_taskfile *tf)
 	       (tf->command == ATA_CMD_WRITE_MULTI_FUA_EXT);
 }
 
-static inline const unsigned long *
-sata_ehc_deb_timing(struct ata_eh_context *ehc)
-{
-	if (ehc->i.flags & ATA_EHI_HOTPLUGGED)
-		return sata_deb_timing_hotplug;
-	else
-		return sata_deb_timing_normal;
-}
-
 static inline int ata_port_is_dummy(struct ata_port *ap)
 {
 	return ap->ops == &ata_dummy_port_ops;
@@ -1181,6 +1168,19 @@ extern void ata_scsi_cmd_error_handler(struct Scsi_Host *host, struct ata_port *
  * SATA specific code - drivers/ata/libata-sata.c
  */
 #ifdef CONFIG_SATA_HOST
+extern const unsigned long sata_deb_timing_normal[];
+extern const unsigned long sata_deb_timing_hotplug[];
+extern const unsigned long sata_deb_timing_long[];
+
+static inline const unsigned long *
+sata_ehc_deb_timing(struct ata_eh_context *ehc)
+{
+	if (ehc->i.flags & ATA_EHI_HOTPLUGGED)
+		return sata_deb_timing_hotplug;
+	else
+		return sata_deb_timing_normal;
+}
+
 extern int sata_scr_valid(struct ata_link *link);
 extern int sata_scr_read(struct ata_link *link, int reg, u32 *val);
 extern int sata_scr_write(struct ata_link *link, int reg, u32 val);
@@ -1192,6 +1192,11 @@ extern int sata_link_hardreset(struct ata_link *link,
 extern int sata_link_resume(struct ata_link *link, const unsigned long *params,
 			    unsigned long deadline);
 #else
+static inline const unsigned long *
+sata_ehc_deb_timing(struct ata_eh_context *ehc)
+{
+	return NULL;
+}
 static inline int sata_scr_valid(struct ata_link *link) { return 0; }
 static inline int sata_scr_read(struct ata_link *link, int reg, u32 *val)
 {

commit 61a11986d33d01dbef745d49c0536961eb06d2f1
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Mar 26 16:58:16 2020 +0100

    ata: move ata_qc_complete_multiple() to libata-sata.c
    
    * move ata_qc_complete_multiple() to libata-sata.c
    
    Code size savings on m68k arch using (modified) atari_defconfig:
    
       text    data     bss     dec     hex filename
    before:
      32559     572      40   33171    8193 drivers/ata/libata-core.o
    after:
      32162     572      40   32774    8006 drivers/ata/libata-core.o
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 981f73c02509..08fec96a6a1e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1160,7 +1160,6 @@ extern void ata_id_c_string(const u16 *id, unsigned char *s,
 extern unsigned int ata_do_dev_read_id(struct ata_device *dev,
 					struct ata_taskfile *tf, u16 *id);
 extern void ata_qc_complete(struct ata_queued_cmd *qc);
-extern int ata_qc_complete_multiple(struct ata_port *ap, u64 qc_active);
 extern u64 ata_qc_get_active(struct ata_port *ap);
 extern void ata_scsi_simulate(struct ata_device *dev, struct scsi_cmnd *cmd);
 extern int ata_std_bios_param(struct scsi_device *sdev,
@@ -1232,6 +1231,7 @@ extern int ata_slave_link_init(struct ata_port *ap);
 extern void ata_tf_to_fis(const struct ata_taskfile *tf,
 			  u8 pmp, int is_cmd, u8 *fis);
 extern void ata_tf_from_fis(const u8 *fis, struct ata_taskfile *tf);
+extern int ata_qc_complete_multiple(struct ata_port *ap, u64 qc_active);
 extern bool sata_lpm_ignore_phy_events(struct ata_link *link);
 
 extern int ata_cable_40wire(struct ata_port *ap);

commit 78c97c80d76b0590fc6ff5e20f4b18f105aa4fae
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Mar 26 16:58:15 2020 +0100

    ata: move sata_link_hardreset() to libata-sata.c
    
    * move sata_link_hardreset() to libata-sata.c
    
    * add static inline for CONFIG_SATA_HOST=n case
    
    * make sata_set_spd_needed() static
    
    Code size savings on m68k arch using (modified) atari_defconfig:
    
       text    data     bss     dec     hex filename
    before:
      32724     572      40   33336    8238 drivers/ata/libata-core.o
    after:
      32559     572      40   33171    8193 drivers/ata/libata-core.o
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b05538d06919..981f73c02509 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1077,9 +1077,6 @@ static inline int ata_port_is_dummy(struct ata_port *ap)
 extern int ata_std_prereset(struct ata_link *link, unsigned long deadline);
 extern int ata_wait_after_reset(struct ata_link *link, unsigned long deadline,
 				int (*check_ready)(struct ata_link *link));
-extern int sata_link_hardreset(struct ata_link *link,
-			const unsigned long *timing, unsigned long deadline,
-			bool *online, int (*check_ready)(struct ata_link *));
 extern int sata_std_hardreset(struct ata_link *link, unsigned int *class,
 			      unsigned long deadline);
 extern void ata_std_postreset(struct ata_link *link, unsigned int *classes);
@@ -1190,6 +1187,9 @@ extern int sata_scr_read(struct ata_link *link, int reg, u32 *val);
 extern int sata_scr_write(struct ata_link *link, int reg, u32 val);
 extern int sata_scr_write_flush(struct ata_link *link, int reg, u32 val);
 extern int sata_set_spd(struct ata_link *link);
+extern int sata_link_hardreset(struct ata_link *link,
+			const unsigned long *timing, unsigned long deadline,
+			bool *online, int (*check_ready)(struct ata_link *));
 extern int sata_link_resume(struct ata_link *link, const unsigned long *params,
 			    unsigned long deadline);
 #else
@@ -1207,6 +1207,16 @@ static inline int sata_scr_write_flush(struct ata_link *link, int reg, u32 val)
 	return -EOPNOTSUPP;
 }
 static inline int sata_set_spd(struct ata_link *link) { return -EOPNOTSUPP; }
+static inline int sata_link_hardreset(struct ata_link *link,
+				      const unsigned long *timing,
+				      unsigned long deadline,
+				      bool *online,
+				      int (*check_ready)(struct ata_link *))
+{
+	if (online)
+		*online = false;
+	return -EOPNOTSUPP;
+}
 static inline int sata_link_resume(struct ata_link *link,
 				   const unsigned long *params,
 				   unsigned long deadline)

commit 9d3158f5cb11142d85c351fa0e0087ef95ac9cb8
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Mar 26 16:58:14 2020 +0100

    ata: move sata_link_{debounce,resume}() to libata-sata.c
    
    * move sata_link_{debounce,resume}() to libata-sata.c
    
    * add static inline for CONFIG_SATA_HOST=n case (only one,
      for sata_link_resume() is needed)
    
    Code size savings on m68k arch using (modified) atari_defconfig:
    
       text    data     bss     dec     hex filename
    before:
      32816     572      40   33428    8294 drivers/ata/libata-core.o
    after:
      32724     572      40   33336    8238 drivers/ata/libata-core.o
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index f0817a8f1e3f..b05538d06919 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1077,10 +1077,6 @@ static inline int ata_port_is_dummy(struct ata_port *ap)
 extern int ata_std_prereset(struct ata_link *link, unsigned long deadline);
 extern int ata_wait_after_reset(struct ata_link *link, unsigned long deadline,
 				int (*check_ready)(struct ata_link *link));
-extern int sata_link_debounce(struct ata_link *link,
-			const unsigned long *params, unsigned long deadline);
-extern int sata_link_resume(struct ata_link *link, const unsigned long *params,
-			    unsigned long deadline);
 extern int sata_link_hardreset(struct ata_link *link,
 			const unsigned long *timing, unsigned long deadline,
 			bool *online, int (*check_ready)(struct ata_link *));
@@ -1194,6 +1190,8 @@ extern int sata_scr_read(struct ata_link *link, int reg, u32 *val);
 extern int sata_scr_write(struct ata_link *link, int reg, u32 val);
 extern int sata_scr_write_flush(struct ata_link *link, int reg, u32 val);
 extern int sata_set_spd(struct ata_link *link);
+extern int sata_link_resume(struct ata_link *link, const unsigned long *params,
+			    unsigned long deadline);
 #else
 static inline int sata_scr_valid(struct ata_link *link) { return 0; }
 static inline int sata_scr_read(struct ata_link *link, int reg, u32 *val)
@@ -1209,7 +1207,15 @@ static inline int sata_scr_write_flush(struct ata_link *link, int reg, u32 val)
 	return -EOPNOTSUPP;
 }
 static inline int sata_set_spd(struct ata_link *link) { return -EOPNOTSUPP; }
+static inline int sata_link_resume(struct ata_link *link,
+				   const unsigned long *params,
+				   unsigned long deadline)
+{
+	return -EOPNOTSUPP;
+}
 #endif
+extern int sata_link_debounce(struct ata_link *link,
+			const unsigned long *params, unsigned long deadline);
 extern int sata_link_scr_lpm(struct ata_link *link, enum ata_lpm_policy policy,
 			     bool spm_wakeup);
 extern int ata_slave_link_init(struct ata_port *ap);

commit ab4117cf2470618ffd5af16fa7c363b81260d6e7
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Mar 26 16:58:13 2020 +0100

    ata: move *sata_set_spd*() to libata-sata.c
    
    * move *sata_set_spd*() to libata-sata.c
    
    * add static inlines for CONFIG_SATA_HOST=n case
    
    Code size savings on m68k arch using (modified) atari_defconfig:
    
       text    data     bss     dec     hex filename
    before:
      32842     572      40   33458    82ae drivers/ata/libata-core.o
    after:
      32812     572      40   33428    8290 drivers/ata/libata-core.o
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 86703ce5a33e..f0817a8f1e3f 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1074,7 +1074,6 @@ static inline int ata_port_is_dummy(struct ata_port *ap)
 	return ap->ops == &ata_dummy_port_ops;
 }
 
-extern int sata_set_spd(struct ata_link *link);
 extern int ata_std_prereset(struct ata_link *link, unsigned long deadline);
 extern int ata_wait_after_reset(struct ata_link *link, unsigned long deadline,
 				int (*check_ready)(struct ata_link *link));
@@ -1194,6 +1193,7 @@ extern int sata_scr_valid(struct ata_link *link);
 extern int sata_scr_read(struct ata_link *link, int reg, u32 *val);
 extern int sata_scr_write(struct ata_link *link, int reg, u32 val);
 extern int sata_scr_write_flush(struct ata_link *link, int reg, u32 val);
+extern int sata_set_spd(struct ata_link *link);
 #else
 static inline int sata_scr_valid(struct ata_link *link) { return 0; }
 static inline int sata_scr_read(struct ata_link *link, int reg, u32 *val)
@@ -1208,6 +1208,7 @@ static inline int sata_scr_write_flush(struct ata_link *link, int reg, u32 val)
 {
 	return -EOPNOTSUPP;
 }
+static inline int sata_set_spd(struct ata_link *link) { return -EOPNOTSUPP; }
 #endif
 extern int sata_link_scr_lpm(struct ata_link *link, enum ata_lpm_policy policy,
 			     bool spm_wakeup);

commit 6eab1bc0eecb541f4c383a0823902dc8f5d99861
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Mar 26 16:58:12 2020 +0100

    ata: move sata_scr_*() to libata-sata.c
    
    * move sata_scr_*() to libata-sata.c
    
    * add static inlines for CONFIG_SATA_HOST=n case
    
    Code size savings on m68k arch using (modified) atari_defconfig:
    
       text    data     bss     dec     hex filename
    before:
      35642     572      40   36254    8d9e drivers/ata/libata-core.o
      16607      18       0   16625    40f1 drivers/ata/libata-eh.o
    after:
      32846     572      40   33458    82b2 drivers/ata/libata-core.o
      16243      18       0   16261    3f85 drivers/ata/libata-eh.o
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b419d7412f71..86703ce5a33e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1125,10 +1125,6 @@ extern void ata_sas_tport_delete(struct ata_port *ap);
 extern void ata_sas_port_stop(struct ata_port *ap);
 extern int ata_sas_slave_configure(struct scsi_device *, struct ata_port *);
 extern int ata_sas_queuecmd(struct scsi_cmnd *cmd, struct ata_port *ap);
-extern int sata_scr_valid(struct ata_link *link);
-extern int sata_scr_read(struct ata_link *link, int reg, u32 *val);
-extern int sata_scr_write(struct ata_link *link, int reg, u32 val);
-extern int sata_scr_write_flush(struct ata_link *link, int reg, u32 val);
 extern bool ata_link_online(struct ata_link *link);
 extern bool ata_link_offline(struct ata_link *link);
 #ifdef CONFIG_PM
@@ -1193,6 +1189,26 @@ extern void ata_scsi_cmd_error_handler(struct Scsi_Host *host, struct ata_port *
 /*
  * SATA specific code - drivers/ata/libata-sata.c
  */
+#ifdef CONFIG_SATA_HOST
+extern int sata_scr_valid(struct ata_link *link);
+extern int sata_scr_read(struct ata_link *link, int reg, u32 *val);
+extern int sata_scr_write(struct ata_link *link, int reg, u32 val);
+extern int sata_scr_write_flush(struct ata_link *link, int reg, u32 val);
+#else
+static inline int sata_scr_valid(struct ata_link *link) { return 0; }
+static inline int sata_scr_read(struct ata_link *link, int reg, u32 *val)
+{
+	return -EOPNOTSUPP;
+}
+static inline int sata_scr_write(struct ata_link *link, int reg, u32 val)
+{
+	return -EOPNOTSUPP;
+}
+static inline int sata_scr_write_flush(struct ata_link *link, int reg, u32 val)
+{
+	return -EOPNOTSUPP;
+}
+#endif
 extern int sata_link_scr_lpm(struct ata_link *link, enum ata_lpm_policy policy,
 			     bool spm_wakeup);
 extern int ata_slave_link_init(struct ata_port *ap);

commit 7fe183c773c42f9814cd361c45a0233f441bc4fc
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Mar 26 16:58:11 2020 +0100

    ata: start separating SATA specific code from libata-core.c
    
    Start separating SATA specific code from libata-core.c:
    
    * move following functions to libata-sata.c:
      - ata_tf_to_fis()
      - ata_tf_from_fis()
      - sata_link_scr_lpm()
      - ata_slave_link_init()
      - sata_lpm_ignore_phy_events()
    
    * group above functions together in <linux/libata.h>
    
    * include libata-sata.c in the build when CONFIG_SATA_HOST=y
    
    Code size savings on m68k arch using (modified) atari_defconfig:
    
       text    data     bss     dec     hex filename
    before:
      37582     572      40   38194    9532 drivers/ata/libata-core.o
    after:
      36762     572      40   37374    91fe drivers/ata/libata-core.o
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 661d76038684..b419d7412f71 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1082,8 +1082,6 @@ extern int sata_link_debounce(struct ata_link *link,
 			const unsigned long *params, unsigned long deadline);
 extern int sata_link_resume(struct ata_link *link, const unsigned long *params,
 			    unsigned long deadline);
-extern int sata_link_scr_lpm(struct ata_link *link, enum ata_lpm_policy policy,
-			     bool spm_wakeup);
 extern int sata_link_hardreset(struct ata_link *link,
 			const unsigned long *timing, unsigned long deadline,
 			bool *online, int (*check_ready)(struct ata_link *));
@@ -1094,7 +1092,6 @@ extern void ata_std_postreset(struct ata_link *link, unsigned int *classes);
 extern struct ata_host *ata_host_alloc(struct device *dev, int max_ports);
 extern struct ata_host *ata_host_alloc_pinfo(struct device *dev,
 			const struct ata_port_info * const * ppi, int n_ports);
-extern int ata_slave_link_init(struct ata_port *ap);
 extern void ata_host_get(struct ata_host *host);
 extern void ata_host_put(struct ata_host *host);
 extern int ata_host_start(struct ata_host *host);
@@ -1152,9 +1149,6 @@ extern void ata_msleep(struct ata_port *ap, unsigned int msecs);
 extern u32 ata_wait_register(struct ata_port *ap, void __iomem *reg, u32 mask,
 			u32 val, unsigned long interval, unsigned long timeout);
 extern int atapi_cmd_type(u8 opcode);
-extern void ata_tf_to_fis(const struct ata_taskfile *tf,
-			  u8 pmp, int is_cmd, u8 *fis);
-extern void ata_tf_from_fis(const u8 *fis, struct ata_taskfile *tf);
 extern unsigned long ata_pack_xfermask(unsigned long pio_mask,
 			unsigned long mwdma_mask, unsigned long udma_mask);
 extern void ata_unpack_xfermask(unsigned long xfer_mask,
@@ -1195,6 +1189,16 @@ extern struct ata_device *ata_dev_pair(struct ata_device *adev);
 extern int ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
 extern void ata_scsi_port_error_handler(struct Scsi_Host *host, struct ata_port *ap);
 extern void ata_scsi_cmd_error_handler(struct Scsi_Host *host, struct ata_port *ap, struct list_head *eh_q);
+
+/*
+ * SATA specific code - drivers/ata/libata-sata.c
+ */
+extern int sata_link_scr_lpm(struct ata_link *link, enum ata_lpm_policy policy,
+			     bool spm_wakeup);
+extern int ata_slave_link_init(struct ata_port *ap);
+extern void ata_tf_to_fis(const struct ata_taskfile *tf,
+			  u8 pmp, int is_cmd, u8 *fis);
+extern void ata_tf_from_fis(const u8 *fis, struct ata_taskfile *tf);
 extern bool sata_lpm_ignore_phy_events(struct ata_link *link);
 
 extern int ata_cable_40wire(struct ata_port *ap);

commit 7caa30ea8238aed4f9998d032bfca7a91f6c36cd
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Mar 26 16:58:08 2020 +0100

    ata: add CONFIG_SATA_HOST=n version of ata_ncq_enabled()
    
    When CONFIG_SATA_HOST=n there are no NCQ capable host drivers
    built so it is safe to hardwire ata_ncq_enabled() to always
    return zero.
    
    Code size savings on m68k arch using (modified) atari_defconfig:
    
       text    data     bss     dec     hex filename
    before:
      37820     572      40   38432    9620 drivers/ata/libata-core.o
      21040     105     576   21721    54d9 drivers/ata/libata-scsi.o
      17405      18       0   17423    440f drivers/ata/libata-eh.o
    after:
      37582     572      40   38194    9532 drivers/ata/libata-core.o
      20702     105     576   21383    5387 drivers/ata/libata-scsi.o
      17353      18       0   17371    43db drivers/ata/libata-eh.o
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 500b709ed3de..661d76038684 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1633,6 +1633,8 @@ extern struct ata_device *ata_dev_next(struct ata_device *dev,
  */
 static inline int ata_ncq_enabled(struct ata_device *dev)
 {
+	if (!IS_ENABLED(CONFIG_SATA_HOST))
+		return 0;
 	return (dev->flags & (ATA_DFLAG_PIO | ATA_DFLAG_NCQ_OFF |
 			      ATA_DFLAG_NCQ)) == ATA_DFLAG_NCQ;
 }

commit a9b2c120e34bcfe49f837830ee4bfbd2aad4b5c8
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Mar 26 16:58:07 2020 +0100

    ata: separate PATA timings code from libata-core.c
    
    Separate PATA timings code from libata-core.c:
    
    * add PATA_TIMINGS config option and make corresponding PATA
      host drivers (and ATA ACPI code) select it
    
    * move following PATA timings code to libata-pata-timings.c:
      - ata_timing_quantize()
      - ata_timing_merge()
      - ata_timing_find_mode()
      - ata_timing_compute()
    
    * group above functions together in <linux/libata.h>
    
    * include libata-pata-timings.c in the build when PATA_TIMINGS
      config option is enabled
    
    * cover ata_timing_cycle2mode() with CONFIG_ATA_ACPI ifdef (it
      depends on code from libata-core.c and libata-pata-timings.c
      while its only user is ATA ACPI)
    
    Code size savings on m68k arch using (modified) atari_defconfig:
    
       text    data     bss     dec     hex filename
    before:
      39688     573      40   40301    9d6d drivers/ata/libata-core.o
    after:
      37820     572      40   38432    9620 drivers/ata/libata-core.o
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 236e4c55be48..500b709ed3de 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1205,12 +1205,6 @@ extern int ata_cable_unknown(struct ata_port *ap);
 
 /* Timing helpers */
 extern unsigned int ata_pio_need_iordy(const struct ata_device *);
-extern const struct ata_timing *ata_timing_find_mode(u8 xfer_mode);
-extern int ata_timing_compute(struct ata_device *, unsigned short,
-			      struct ata_timing *, int, int);
-extern void ata_timing_merge(const struct ata_timing *,
-			     const struct ata_timing *, struct ata_timing *,
-			     unsigned int);
 extern u8 ata_timing_cycle2mode(unsigned int xfer_shift, int cycle);
 
 /* PCI */
@@ -1807,6 +1801,16 @@ static inline int ata_dma_enabled(struct ata_device *adev)
 	return (adev->dma_mode == 0xFF ? 0 : 1);
 }
 
+/**************************************************************************
+ * PATA timings - drivers/ata/libata-pata-timings.c
+ */
+extern const struct ata_timing *ata_timing_find_mode(u8 xfer_mode);
+extern int ata_timing_compute(struct ata_device *, unsigned short,
+			      struct ata_timing *, int, int);
+extern void ata_timing_merge(const struct ata_timing *,
+			     const struct ata_timing *, struct ata_timing *,
+			     unsigned int);
+
 /**************************************************************************
  * PMP - drivers/ata/libata-pmp.c
  */

commit 8ba5a45c998cdbfb565fb7670782407c3e4a25ba
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Mar 26 16:58:02 2020 +0100

    ata: optimize struct ata_force_param size
    
    Optimize struct ata_force_param size by:
    - using u8 for cbl and spd_limit fields
    - using u16 for lflags field
    
    Code size savings on m68k arch using (modified) atari_defconfig:
    
       text    data     bss     dec     hex filename
    before:
      41064     573      40   41677    a2cd drivers/ata/libata-core.o
    after:
      40654     573      40   41267    a133 drivers/ata/libata-core.o
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 350fa584acde..236e4c55be48 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -174,6 +174,7 @@ enum {
 	ATA_DEV_NONE		= 11,	/* no device */
 
 	/* struct ata_link flags */
+	/* NOTE: struct ata_force_param currently stores lflags in u16 */
 	ATA_LFLAG_NO_HRST	= (1 << 1), /* avoid hardreset */
 	ATA_LFLAG_NO_SRST	= (1 << 2), /* avoid softreset */
 	ATA_LFLAG_ASSUME_ATA	= (1 << 3), /* assume ATA class */

commit 6f09eae3b5d974ef845e56690d6bc2b8f2a70acd
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Mar 26 16:57:57 2020 +0100

    ata: expose ncq_enable_prio sysfs attribute only on NCQ capable hosts
    
    There is no point in exposing ncq_enable_prio sysfs attribute for
    devices on PATA and non-NCQ capable SATA hosts so:
    
    * remove dev_attr_ncq_prio_enable from ata_common_sdev_attrs[]
    
    * add ata_ncq_sdev_attrs[]
    
    * update ATA_NCQ_SHT() macro to use ata_ncq_sdev_attrs[]
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 710e09dae910..350fa584acde 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1334,6 +1334,7 @@ extern int ata_link_nr_enabled(struct ata_link *link);
 extern const struct ata_port_operations ata_base_port_ops;
 extern const struct ata_port_operations sata_port_ops;
 extern struct device_attribute *ata_common_sdev_attrs[];
+extern struct device_attribute *ata_ncq_sdev_attrs[];
 
 /*
  * All sht initializers (BASE, PIO, BMDMA, NCQ) must be instantiated
@@ -1341,7 +1342,7 @@ extern struct device_attribute *ata_common_sdev_attrs[];
  * edge driver's module reference, otherwise the driver can be unloaded
  * even if the scsi_device is being accessed.
  */
-#define ATA_BASE_SHT(drv_name)					\
+#define __ATA_BASE_SHT(drv_name)				\
 	.module			= THIS_MODULE,			\
 	.name			= drv_name,			\
 	.ioctl			= ata_scsi_ioctl,		\
@@ -1355,11 +1356,15 @@ extern struct device_attribute *ata_common_sdev_attrs[];
 	.slave_configure	= ata_scsi_slave_config,	\
 	.slave_destroy		= ata_scsi_slave_destroy,	\
 	.bios_param		= ata_std_bios_param,		\
-	.unlock_native_capacity	= ata_scsi_unlock_native_capacity, \
+	.unlock_native_capacity	= ata_scsi_unlock_native_capacity
+
+#define ATA_BASE_SHT(drv_name)					\
+	__ATA_BASE_SHT(drv_name),				\
 	.sdev_attrs		= ata_common_sdev_attrs
 
 #define ATA_NCQ_SHT(drv_name)					\
-	ATA_BASE_SHT(drv_name),					\
+	__ATA_BASE_SHT(drv_name),				\
+	.sdev_attrs		= ata_ncq_sdev_attrs,		\
 	.change_queue_depth	= ata_scsi_change_queue_depth
 
 /*

commit 58def851063d2178c10622e436897e6285850077
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Mar 3 10:37:34 2020 +0100

    libata: drop BPRINTK()
    
    No users, drop it.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 2ca9b7056a82..710e09dae910 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -57,8 +57,6 @@
 #define VPRINTK(fmt, args...)
 #endif	/* ATA_DEBUG */
 
-#define BPRINTK(fmt, args...) if (ap->flags & ATA_FLAG_DEBUGMSG) printk(KERN_ERR "%s: " fmt, __func__, ## args)
-
 #define ata_print_version_once(dev, version)			\
 ({								\
 	static bool __print_once;				\

commit 0384066381ed5572cf1f57f8d01eaccd3f6d4785
Merge: 4c7d00ccf40d 7991901082f0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 6 06:11:50 2020 +0000

    Merge tag 'libata-5.6-2020-02-05' of git://git.kernel.dk/linux-block
    
    Pull libata updates from Jens Axboe:
    
     - Add a Sandisk CF card to supported pata_pcmcia list (Christian)
    
     - Move pata_arasan_cf away from legacy API (Peter)
    
     - Ensure ahci DMA/ints are shut down on shutdown (Prabhakar)
    
    * tag 'libata-5.6-2020-02-05' of git://git.kernel.dk/linux-block:
      ata: pata_arasan_cf: Use dma_request_chan() instead dma_request_slave_channel()
      ata: ahci: Add shutdown to freeze hardware resources of ahci
      pata_pcmia: add SanDisk High (>8G) CF card to supported list

commit 10a663a1b15134a5a714aa515e11425a44d4fdf7
Author: Prabhakar Kushwaha <pkushwaha@marvell.com>
Date:   Sat Jan 25 03:37:29 2020 +0000

    ata: ahci: Add shutdown to freeze hardware resources of ahci
    
    device_shutdown() called from reboot or power_shutdown expect
    all devices to be shutdown. Same is true for even ahci pci driver.
    As no ahci shutdown function is implemented, the ata subsystem
    always remains alive with DMA & interrupt support. File system
    related calls should not be honored after device_shutdown().
    
    So defining ahci pci driver shutdown to freeze hardware (mask
    interrupt, stop DMA engine and free DMA resources).
    
    Signed-off-by: Prabhakar Kushwaha <pkushwaha@marvell.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 2dbde119721d..bff539918d82 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1221,6 +1221,7 @@ struct pci_bits {
 };
 
 extern int pci_test_config_bits(struct pci_dev *pdev, const struct pci_bits *bits);
+extern void ata_pci_shutdown_one(struct pci_dev *pdev);
 extern void ata_pci_remove_one(struct pci_dev *pdev);
 
 #ifdef CONFIG_PM

commit 75c0b0e118b929cb8bad8ce1ab4c8be8a76c45e2
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Nov 30 20:28:12 2019 +0100

    compat_ioctl: scsi: handle HDIO commands from drivers
    
    The ata_sas_scsi_ioctl() function implements a number of HDIO_* commands
    for SCSI devices, it is used by all libata drivers as well as a few
    drivers that support SAS attached SATA drives.
    
    The only command that is not safe for compat ioctls here is
    HDIO_GET_32BIT. Change the implementation to check for in_compat_syscall()
    in order to do both cases correctly, and change all callers to use it
    as both native and compat callback pointers, including the indirect
    callers through sas_ioctl and ata_scsi_ioctl.
    
    Reviewed-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 2dbde119721d..a36bdcb8d9e9 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1109,6 +1109,11 @@ extern void ata_host_init(struct ata_host *, struct device *, struct ata_port_op
 extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, unsigned int cmd,
 			  void __user *arg);
+#ifdef CONFIG_COMPAT
+#define ATA_SCSI_COMPAT_IOCTL .compat_ioctl = ata_scsi_ioctl,
+#else
+#define ATA_SCSI_COMPAT_IOCTL /* empty */
+#endif
 extern int ata_scsi_queuecmd(struct Scsi_Host *h, struct scsi_cmnd *cmd);
 extern int ata_sas_scsi_ioctl(struct ata_port *ap, struct scsi_device *dev,
 			    unsigned int cmd, void __user *arg);
@@ -1341,6 +1346,7 @@ extern struct device_attribute *ata_common_sdev_attrs[];
 	.module			= THIS_MODULE,			\
 	.name			= drv_name,			\
 	.ioctl			= ata_scsi_ioctl,		\
+	ATA_SCSI_COMPAT_IOCTL					\
 	.queuecommand		= ata_scsi_queuecmd,		\
 	.can_queue		= ATA_DEF_QUEUE,		\
 	.tag_alloc_policy	= BLK_TAG_ALLOC_RR,		\

commit 8385d756e114f2df8568e508902d5f9850817ffb
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Fri Dec 13 09:04:08 2019 +0100

    libata: Fix retrieving of active qcs
    
    ata_qc_complete_multiple() is called with a mask of the still active
    tags.
    
    mv_sata doesn't have this information directly and instead calculates
    the still active tags from the started tags (ap->qc_active) and the
    finished tags as (ap->qc_active ^ done_mask)
    
    Since 28361c40368 the hw_tag and tag are no longer the same and the
    equation is no longer valid. In ata_exec_internal_sg() ap->qc_active is
    initialized as 1ULL << ATA_TAG_INTERNAL, but in hardware tag 0 is
    started and this will be in done_mask on completion. ap->qc_active ^
    done_mask becomes 0x100000000 ^ 0x1 = 0x100000001 and thus tag 0 used as
    the internal tag will never be reported as completed.
    
    This is fixed by introducing ata_qc_get_active() which returns the
    active hardware tags and calling it where appropriate.
    
    This is tested on mv_sata, but sata_fsl and sata_nv suffer from the same
    problem. There is another case in sata_nv that most likely needs fixing
    as well, but this looks a little different, so I wasn't confident enough
    to change that.
    
    Fixes: 28361c403683 ("libata: add extra internal command")
    Cc: stable@vger.kernel.org
    Tested-by: Pali Rohár <pali.rohar@gmail.com>
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    
    Add missing export of ata_qc_get_active(), as per Pali.
    
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d3bbfddf616a..2dbde119721d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1175,6 +1175,7 @@ extern unsigned int ata_do_dev_read_id(struct ata_device *dev,
 					struct ata_taskfile *tf, u16 *id);
 extern void ata_qc_complete(struct ata_queued_cmd *qc);
 extern int ata_qc_complete_multiple(struct ata_port *ap, u64 qc_active);
+extern u64 ata_qc_get_active(struct ata_port *ap);
 extern void ata_scsi_simulate(struct ata_device *dev, struct scsi_cmnd *cmd);
 extern int ata_std_bios_param(struct scsi_device *sdev,
 			      struct block_device *bdev,

commit 95364f36701e62dd50eee91e1303187fd1a9f567
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Oct 31 10:59:45 2019 +0100

    ata: make qc_prep return ata_completion_errors
    
    In case a driver wants to return an error from qc_prep, return enum
    ata_completion_errors. sata_mv is one of those drivers -- see the next
    patch. Other drivers return the newly defined AC_ERR_OK.
    
    [v2] use enum ata_completion_errors and AC_ERR_OK.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: linux-ide@vger.kernel.org
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b63ce4ebcd66..d3bbfddf616a 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -892,9 +892,9 @@ struct ata_port_operations {
 	/*
 	 * Command execution
 	 */
-	int  (*qc_defer)(struct ata_queued_cmd *qc);
-	int  (*check_atapi_dma)(struct ata_queued_cmd *qc);
-	void (*qc_prep)(struct ata_queued_cmd *qc);
+	int (*qc_defer)(struct ata_queued_cmd *qc);
+	int (*check_atapi_dma)(struct ata_queued_cmd *qc);
+	enum ata_completion_errors (*qc_prep)(struct ata_queued_cmd *qc);
 	unsigned int (*qc_issue)(struct ata_queued_cmd *qc);
 	bool (*qc_fill_rtf)(struct ata_queued_cmd *qc);
 
@@ -1162,7 +1162,7 @@ extern int ata_xfer_mode2shift(unsigned long xfer_mode);
 extern const char *ata_mode_string(unsigned long xfer_mask);
 extern unsigned long ata_id_xfermask(const u16 *id);
 extern int ata_std_qc_defer(struct ata_queued_cmd *qc);
-extern void ata_noop_qc_prep(struct ata_queued_cmd *qc);
+extern enum ata_completion_errors ata_noop_qc_prep(struct ata_queued_cmd *qc);
 extern void ata_sg_init(struct ata_queued_cmd *qc, struct scatterlist *sg,
 		 unsigned int n_elem);
 extern unsigned int ata_dev_classify(const struct ata_taskfile *tf);
@@ -1894,9 +1894,9 @@ extern const struct ata_port_operations ata_bmdma_port_ops;
 	.sg_tablesize		= LIBATA_MAX_PRD,		\
 	.dma_boundary		= ATA_DMA_BOUNDARY
 
-extern void ata_bmdma_qc_prep(struct ata_queued_cmd *qc);
+extern enum ata_completion_errors ata_bmdma_qc_prep(struct ata_queued_cmd *qc);
 extern unsigned int ata_bmdma_qc_issue(struct ata_queued_cmd *qc);
-extern void ata_bmdma_dumb_qc_prep(struct ata_queued_cmd *qc);
+extern enum ata_completion_errors ata_bmdma_dumb_qc_prep(struct ata_queued_cmd *qc);
 extern unsigned int ata_bmdma_port_intr(struct ata_port *ap,
 				      struct ata_queued_cmd *qc);
 extern irqreturn_t ata_bmdma_interrupt(int irq, void *dev_instance);

commit 25937580a5065d6fbd92d9c8ebd47145ad80052e
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Oct 31 10:59:44 2019 +0100

    ata: define AC_ERR_OK
    
    Since we will return enum ata_completion_errors from qc_prep in the next
    patch, let's define AC_ERR_OK to mark the OK status.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: linux-ide@vger.kernel.org
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 207e7ee764ce..b63ce4ebcd66 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -484,6 +484,7 @@ enum hsm_task_states {
 };
 
 enum ata_completion_errors {
+	AC_ERR_OK		= 0,	    /* no error */
 	AC_ERR_DEV		= (1 << 0), /* device reported error */
 	AC_ERR_HSM		= (1 << 1), /* host state machine violation */
 	AC_ERR_TIMEOUT		= (1 << 2), /* timeout */

commit c82ee6d3beaa489058c1fe1ca710042a07df9d40
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:48 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 18
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 or at your option any
      later version this program is distributed in the hope that it will
      be useful but without any warranty without even the implied warranty
      of merchantability or fitness for a particular purpose see the gnu
      general public license for more details you should have received a
      copy of the gnu general public license along with this program see
      the file copying if not write to the free software foundation 675
      mass ave cambridge ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 52 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154042.342335923@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c9419c05a90a..207e7ee764ce 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1,26 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  *  Copyright 2003-2005 Red Hat, Inc.  All rights reserved.
  *  Copyright 2003-2005 Jeff Garzik
  *
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- *
  *  libata documentation is available via 'make {ps|pdf}docs',
  *  as Documentation/driver-api/libata.rst
- *
  */
 
 #ifndef __LINUX_LIBATA_H__

commit 6f4e626fb0cc93d50b49b79c2ee33bd769ee57f0
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Thu Feb 7 09:07:20 2019 -0700

    scsi: ata: Use unsigned int for cmd's type in ioctls in scsi_host_template
    
    Clang warns several times in the scsi subsystem (trimmed for brevity):
    
    drivers/scsi/hpsa.c:6209:7: warning: overflow converting case value to
    switch condition type (2147762695 to 18446744071562347015) [-Wswitch]
            case CCISS_GETBUSTYPES:
                 ^
    drivers/scsi/hpsa.c:6208:7: warning: overflow converting case value to
    switch condition type (2147762694 to 18446744071562347014) [-Wswitch]
            case CCISS_GETHEARTBEAT:
                 ^
    
    The root cause is that the _IOC macro can generate really large numbers,
    which don't fit into type 'int', which is used for the cmd parameter in
    the ioctls in scsi_host_template. My research into how GCC and Clang are
    handling this at a low level didn't prove fruitful. However, looking at
    the rest of the kernel tree, all ioctls use an 'unsigned int' for the
    cmd parameter, which will fit all of the _IOC values in the scsi/ata
    subsystems.
    
    Make that change because none of the ioctls expect a negative value for
    any command, it brings the ioctls inline with the reset of the kernel,
    and it removes ambiguity, which is never good when dealing with compilers.
    
    Link: https://github.com/ClangBuiltLinux/linux/issues/85
    Link: https://github.com/ClangBuiltLinux/linux/issues/154
    Link: https://github.com/ClangBuiltLinux/linux/issues/157
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Acked-by: Bradley Grove <bgrove@attotech.com>
    Acked-by: Don Brace <don.brace@microsemi.com>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Tested-by: Nick Desaulniers <ndesaulniers@google.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 68133842e6d7..c9419c05a90a 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1122,10 +1122,11 @@ extern int ata_host_activate(struct ata_host *host, int irq,
 extern void ata_host_detach(struct ata_host *host);
 extern void ata_host_init(struct ata_host *, struct device *, struct ata_port_operations *);
 extern int ata_scsi_detect(struct scsi_host_template *sht);
-extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
+extern int ata_scsi_ioctl(struct scsi_device *dev, unsigned int cmd,
+			  void __user *arg);
 extern int ata_scsi_queuecmd(struct Scsi_Host *h, struct scsi_cmnd *cmd);
 extern int ata_sas_scsi_ioctl(struct ata_port *ap, struct scsi_device *dev,
-			    int cmd, void __user *arg);
+			    unsigned int cmd, void __user *arg);
 extern void ata_sas_port_destroy(struct ata_port *);
 extern struct ata_port *ata_sas_port_alloc(struct ata_host *,
 					   struct ata_port_info *, struct Scsi_Host *);

commit 2a3d4eb8e228061c09d5ca8bf39e7f00c2091213
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:02 2018 +0100

    scsi: flip the default on use_clustering
    
    Most SCSI drivers want to enable "clustering", that is merging of
    segments so that they might span more than a single page.  Remove the
    ENABLE_CLUSTERING define, and require drivers to explicitly set
    DISABLE_CLUSTERING to disable this feature.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 38c95d66ab12..68133842e6d7 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -135,7 +135,6 @@ enum {
 
 	ATA_SHT_EMULATED	= 1,
 	ATA_SHT_THIS_ID		= -1,
-	ATA_SHT_USE_CLUSTERING	= 1,
 
 	/* struct ata_taskfile flags */
 	ATA_TFLAG_LBA48		= (1 << 0), /* enable 48-bit LBA and "HOB" */
@@ -1360,7 +1359,6 @@ extern struct device_attribute *ata_common_sdev_attrs[];
 	.tag_alloc_policy	= BLK_TAG_ALLOC_RR,		\
 	.this_id		= ATA_SHT_THIS_ID,		\
 	.emulated		= ATA_SHT_EMULATED,		\
-	.use_clustering		= ATA_SHT_USE_CLUSTERING,	\
 	.proc_name		= drv_name,			\
 	.slave_configure	= ata_scsi_slave_config,	\
 	.slave_destroy		= ata_scsi_slave_destroy,	\

commit 0519359784328bfa92bf0931bf0cff3b58c16932
Merge: 596766102a3a 2d17f460c5d7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Aug 24 13:20:33 2018 -0700

    Merge branch 'for-4.19' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata
    
    Pull libata updates from Tejun Heo:
     "Nothing too interesting. Mostly ahci and ahci_platform changes, many
      around power management"
    
    * 'for-4.19' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata: (22 commits)
      ata: ahci_platform: enable to get and control reset
      ata: libahci_platform: add reset control support
      ata: add an extra argument to ahci_platform_get_resources()
      ata: sata_rcar: Add r8a77965 support
      ata: sata_rcar: exclude setting of PHY registers in Gen3
      ata: sata_rcar: really mask all interrupts on Gen2 and later
      Revert "ata: ahci_platform: allow disabling of hotplug to save power"
      ata: libahci: Allow reconfigure of DEVSLP register
      ata: libahci: Correct setting of DEVSLP register
      ata: ahci: Enable DEVSLP by default on x86 with SLP_S0
      ata: ahci: Support state with min power but Partial low power state
      Revert "ata: ahci_platform: convert kcalloc to devm_kcalloc"
      ata: sata_rcar: Add rudimentary Runtime PM support
      ata: sata_rcar: Provide a short-hand for &pdev->dev
      ata: Only output sg element mapped number in verbose debug
      ata: Guard ata_scsi_dump_cdb() by ATA_VERBOSE_DEBUG
      ata: ahci_platform: convert kcalloc to devm_kcalloc
      ata: ahci_platform: convert kzallloc to kcalloc
      ata: ahci_platform: correct parameter documentation for ahci_platform_shutdown
      libata: remove ata_sff_data_xfer_noirq()
      ...

commit 72f02ba66bd83b54054da20eae550123de84da6f
Merge: db06f826ec12 51372570ac3c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 15 22:06:26 2018 -0700

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This is mostly updates to the usual drivers: mpt3sas, lpfc, qla2xxx,
      hisi_sas, smartpqi, megaraid_sas, arcmsr.
    
      In addition, with the continuing absence of Nic we have target updates
      for tcmu and target core (all with reviews and acks).
    
      The biggest observable change is going to be that we're (again) trying
      to switch to mulitqueue as the default (a user can still override the
      setting on the kernel command line).
    
      Other major core stuff is the removal of the remaining Microchannel
      drivers, an update of the internal timers and some reworks of
      completion and result handling"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (203 commits)
      scsi: core: use blk_mq_run_hw_queues in scsi_kick_queue
      scsi: ufs: remove unnecessary query(DM) UPIU trace
      scsi: qla2xxx: Fix issue reported by static checker for qla2x00_els_dcmd2_sp_done()
      scsi: aacraid: Spelling fix in comment
      scsi: mpt3sas: Fix calltrace observed while running IO & reset
      scsi: aic94xx: fix an error code in aic94xx_init()
      scsi: st: remove redundant pointer STbuffer
      scsi: qla2xxx: Update driver version to 10.00.00.08-k
      scsi: qla2xxx: Migrate NVME N2N handling into state machine
      scsi: qla2xxx: Save frame payload size from ICB
      scsi: qla2xxx: Fix stalled relogin
      scsi: qla2xxx: Fix race between switch cmd completion and timeout
      scsi: qla2xxx: Fix Management Server NPort handle reservation logic
      scsi: qla2xxx: Flush mailbox commands on chip reset
      scsi: qla2xxx: Fix unintended Logout
      scsi: qla2xxx: Fix session state stuck in Get Port DB
      scsi: qla2xxx: Fix redundant fc_rport registration
      scsi: qla2xxx: Silent erroneous message
      scsi: qla2xxx: Prevent sysfs access when chip is down
      scsi: qla2xxx: Add longer window for chip reset
      ...

commit a5ec5a7bfd1f28d1905499641c9f589be36808c1
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Fri Jul 27 13:47:02 2018 -0700

    ata: ahci: Support state with min power but Partial low power state
    
    Currently when min_power policy is selected, the partial low power state
    is not entered and link will try aggressively enter to only slumber state.
    Add a new policy which still enable DEVSLP but also try to enter partial
    low power state. This policy is presented as "min_power_with_partial".
    
    For information the difference between partial and slumber
    Partial – PHY logic is powered up, and in a reduced power state. The link
    PM exit latency to active state maximum is 10 ns.
    Slumber – PHY logic is powered up, and in a reduced power state. The link
    PM exit latency to active state maximum is 10 ms.
    Devslp – PHY logic is powered down. The link PM exit latency from this
    state to active state maximum is 20 ms, unless otherwise specified by
    DETO.
    
    Suggested-and-reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index aa8583655a18..80c2bd202367 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -522,7 +522,8 @@ enum ata_lpm_policy {
 	ATA_LPM_MAX_POWER,
 	ATA_LPM_MED_POWER,
 	ATA_LPM_MED_POWER_WITH_DIPM, /* Med power + DIPM as win IRST does */
-	ATA_LPM_MIN_POWER,
+	ATA_LPM_MIN_POWER_WITH_PARTIAL, /* Min Power + partial and slumber */
+	ATA_LPM_MIN_POWER, /* Min power + no partial (slumber only) */
 };
 
 enum ata_lpm_hints {

commit 23ebda2fc715534d383d59ae6740d4e3ebd43798
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed Jul 11 17:21:05 2018 +0200

    libata: remove ata_sff_data_xfer_noirq()
    
    ata_sff_data_xfer_noirq() is invoked via the ->sff_data_xfer hook. The
    latter is invoked by ata_pio_sector(), atapi_send_cdb() and
    __atapi_pio_bytes() which in turn is invoked by ata_sff_hsm_move().
    The latter function requires that the "ap->lock" lock is held which
    needs to be taken with disabled interrupts.
    
    There is no need have to have ata_sff_data_xfer_noirq() which invokes
    ata_sff_data_xfer32() with disabled interrupts because at this point the
    interrupts are already disabled.
    Remove the function and its references to it and replace all callers
    with ata_sff_data_xfer32().
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 8b8946dd63b9..aa8583655a18 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1832,8 +1832,6 @@ extern unsigned int ata_sff_data_xfer(struct ata_queued_cmd *qc,
 			unsigned char *buf, unsigned int buflen, int rw);
 extern unsigned int ata_sff_data_xfer32(struct ata_queued_cmd *qc,
 			unsigned char *buf, unsigned int buflen, int rw);
-extern unsigned int ata_sff_data_xfer_noirq(struct ata_queued_cmd *qc,
-			unsigned char *buf, unsigned int buflen, int rw);
 extern void ata_sff_irq_on(struct ata_port *ap);
 extern void ata_sff_irq_clear(struct ata_port *ap);
 extern int ata_sff_hsm_move(struct ata_port *ap, struct ata_queued_cmd *qc,

commit 240630e61870e62e39a97225048f9945848fa5f5
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Jul 1 12:15:46 2018 +0200

    ahci: Disable LPM on Lenovo 50 series laptops with a too old BIOS
    
    There have been several reports of LPM related hard freezes about once
    a day on multiple Lenovo 50 series models. Strange enough these reports
    where not disk model specific as LPM issues usually are and some users
    with the exact same disk + laptop where seeing them while other users
    where not seeing these issues.
    
    It turns out that enabling LPM triggers a firmware bug somewhere, which
    has been fixed in later BIOS versions.
    
    This commit adds a new ahci_broken_lpm() function and a new ATA_FLAG_NO_LPM
    for dealing with this.
    
    The ahci_broken_lpm() function contains DMI match info for the 4 models
    which are known to be affected by this and the DMI BIOS date field for
    known good BIOS versions. If the BIOS date is older then the one in the
    table LPM will be disabled and a warning will be printed.
    
    Note the BIOS dates are for known good versions, some older versions may
    work too, but we don't know for sure, the table is using dates from BIOS
    versions for which users have confirmed that upgrading to that version
    makes the problem go away.
    
    Unfortunately I've been unable to get hold of the reporter who reported
    that BIOS version 2.35 fixed the problems on the W541 for him. I've been
    able to verify the DMI_SYS_VENDOR and DMI_PRODUCT_VERSION from an older
    dmidecode, but I don't know the exact BIOS date as reported in the DMI.
    Lenovo keeps a changelog with dates in their release notes, but the
    dates there are the release dates not the build dates which are in DMI.
    So I've chosen to set the date to which we compare to one day past the
    release date of the 2.34 BIOS. I plan to fix this with a follow up
    commit once I've the necessary info.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a2257e380789..32f247cb5e9e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -210,6 +210,7 @@ enum {
 	ATA_FLAG_SLAVE_POSS	= (1 << 0), /* host supports slave dev */
 					    /* (doesn't imply presence) */
 	ATA_FLAG_SATA		= (1 << 1),
+	ATA_FLAG_NO_LPM		= (1 << 2), /* host not happy with LPM */
 	ATA_FLAG_NO_LOG_PAGE	= (1 << 5), /* do not issue log page read */
 	ATA_FLAG_NO_ATAPI	= (1 << 6), /* No ATAPI support */
 	ATA_FLAG_PIO_DMA	= (1 << 7), /* PIO cmds via DMA */

commit 2fa4a32613c9182b00e46872755b0662374424a7
Author: Jason Yan <yanaijie@huawei.com>
Date:   Thu May 10 11:05:16 2018 +0800

    scsi: libsas: dynamically allocate and free ata host
    
    Commit 2623c7a5f2 ("libata: add refcounting to ata_host") v4.17+ introduced
    refcounting to ata_host and will increase or decrease the refcount when
    adding or deleting transport ATA port.
    
    Now the ata host for libsas is embedded in domain_device, and the ->kref
    member is not initialized. Afer we add ata transport class, ata_host_get()
    will be called when adding transport ATA port and a warning will be
    triggered as below:
    
    refcount_t: increment on 0; use-after-free.
    WARNING: CPU: 2 PID: 103 at
    lib/refcount.c:153 refcount_inc+0x40/0x48 ......  Call trace:
     refcount_inc+0x40/0x48
     ata_host_get+0x10/0x18
     ata_tport_add+0x40/0x120
     ata_sas_tport_add+0xc/0x14
     sas_ata_init+0x7c/0xc8
     sas_discover_domain+0x380/0x53c
     process_one_work+0x12c/0x288
     worker_thread+0x58/0x3f0
     kthread+0xfc/0x128
     ret_from_fork+0x10/0x18
    
    And also when removing transport ATA port ata_host_put() will be called and
    another similar warning will be triggered. If the refcount decreased to
    zero, the ata host will be freed. But this ata host is only part of
    domain_device, it cannot be freed directly.
    
    So we have to change this embedded static ata host to a dynamically
    allocated ata host and initialize the ->kref member. To use ata_host_get()
    and ata_host_put() in libsas, we need to move the declaration of these
    functions to the public libata.h and export them.
    
    Fixes: b6240a4df018 ("scsi: libsas: add transport class for ATA devices")
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    CC: John Garry <john.garry@huawei.com>
    CC: Taras Kondratiuk <takondra@cisco.com>
    CC: Tejun Heo <tj@kernel.org>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 8b8946dd63b9..33e9718397e2 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1110,6 +1110,8 @@ extern struct ata_host *ata_host_alloc(struct device *dev, int max_ports);
 extern struct ata_host *ata_host_alloc_pinfo(struct device *dev,
 			const struct ata_port_info * const * ppi, int n_ports);
 extern int ata_slave_link_init(struct ata_port *ap);
+extern void ata_host_get(struct ata_host *host);
+extern void ata_host_put(struct ata_host *host);
 extern int ata_host_start(struct ata_host *host);
 extern int ata_host_register(struct ata_host *host,
 			     struct scsi_host_template *sht);

commit 6362f0a290023bafd7f991089e81dd9278f154b8
Author: Jens Axboe <axboe@kernel.dk>
Date:   Tue Jun 19 10:12:48 2018 -0600

    libata: add command iterator helpers
    
    Now that we have the internal tag as a special (higher) value tag,
    it gets a bit tricky to iterate the internal commands as some loops
    will exceed ATA_MAX_QUEUE. Add explicit helpers for iterating pending
    commands, both inflight and internal.
    
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 8b8946dd63b9..a2257e380789 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1495,6 +1495,29 @@ static inline bool ata_tag_valid(unsigned int tag)
 	return tag < ATA_MAX_QUEUE || ata_tag_internal(tag);
 }
 
+#define __ata_qc_for_each(ap, qc, tag, max_tag, fn)		\
+	for ((tag) = 0; (tag) < (max_tag) &&			\
+	     ({ qc = fn((ap), (tag)); 1; }); (tag)++)		\
+
+/*
+ * Internal use only, iterate commands ignoring error handling and
+ * status of 'qc'.
+ */
+#define ata_qc_for_each_raw(ap, qc, tag)					\
+	__ata_qc_for_each(ap, qc, tag, ATA_MAX_QUEUE, __ata_qc_from_tag)
+
+/*
+ * Iterate all potential commands that can be queued
+ */
+#define ata_qc_for_each(ap, qc, tag)					\
+	__ata_qc_for_each(ap, qc, tag, ATA_MAX_QUEUE, ata_qc_from_tag)
+
+/*
+ * Like ata_qc_for_each, but with the internal tag included
+ */
+#define ata_qc_for_each_with_internal(ap, qc, tag)			\
+	__ata_qc_for_each(ap, qc, tag, ATA_MAX_QUEUE + 1, ata_qc_from_tag)
+
 /*
  * device helpers
  */

commit 5f85942c2ea2ed59d8f19c954bbb0f5c1a2ebdd1
Merge: 0c14e43a42e4 1b5c2cb19668
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jun 10 13:01:12 2018 -0700

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This is mostly updates to the usual drivers: ufs, qedf, mpt3sas, lpfc,
      xfcp, hisi_sas, cxlflash, qla2xxx.
    
      In the absence of Nic, we're also taking target updates which are
      mostly minor except for the tcmu refactor.
    
      The only real core change to worry about is the removal of high page
      bouncing (in sas, storvsc and iscsi). This has been well tested and no
      problems have shown up so far"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (268 commits)
      scsi: lpfc: update driver version to 12.0.0.4
      scsi: lpfc: Fix port initialization failure.
      scsi: lpfc: Fix 16gb hbas failing cq create.
      scsi: lpfc: Fix crash in blk_mq layer when executing modprobe -r lpfc
      scsi: lpfc: correct oversubscription of nvme io requests for an adapter
      scsi: lpfc: Fix MDS diagnostics failure (Rx < Tx)
      scsi: hisi_sas: Mark PHY as in reset for nexus reset
      scsi: hisi_sas: Fix return value when get_free_slot() failed
      scsi: hisi_sas: Terminate STP reject quickly for v2 hw
      scsi: hisi_sas: Add v2 hw force PHY function for internal ATA command
      scsi: hisi_sas: Include TMF elements in struct hisi_sas_slot
      scsi: hisi_sas: Try wait commands before before controller reset
      scsi: hisi_sas: Init disks after controller reset
      scsi: hisi_sas: Create a scsi_host_template per HW module
      scsi: hisi_sas: Reset disks when discovered
      scsi: hisi_sas: Add LED feature for v3 hw
      scsi: hisi_sas: Change common allocation mode of device id
      scsi: hisi_sas: change slot index allocation mode
      scsi: hisi_sas: Introduce hisi_sas_phy_set_linkrate()
      scsi: hisi_sas: fix a typo in hisi_sas_task_prep()
      ...

commit 0bbddb8cbe7a8765e9c6ef598a33b50461934f88
Merge: 476d9ff653b3 88e10092f6a6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 5 17:01:41 2018 -0700

    Merge branch 'for-4.18' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata
    
    Pull libata updates from Tejun Heo:
    
     - libata has always been limiting the maximum queue depth to 31, with
       one entry set aside mostly for historical reasons. This didn't use to
       make much difference but Jens found out that modern hard drives can
       actually perform measurably better with the extra one queue depth.
       Jens updated libata core so that it can make use of full 32 queue
       depth
    
     - Damien updated command retry logic in error handling so that it
       doesn't unnecessarily retry when upper layer (SCSI) is gonna handle
       them
    
     - A couple misc changes
    
    * 'for-4.18' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata:
      sata_fsl: use the right type for tag bitshift
      ahci: enable full queue depth of 32
      libata: don't clamp queue depth to ATA_MAX_QUEUE - 1
      libata: add extra internal command
      sata_nv: set host can_queue count appropriately
      libata: remove assumption that ATA_MAX_QUEUE - 1 is the max
      libata: use ata_tag_internal() consistently
      libata: bump ->qc_active to a 64-bit type
      libata: convert core and drivers to ->hw_tag usage
      libata: introduce notion of separate hardware tags
      libata: Fix command retry decision
      libata: Honor RQF_QUIET flag
      libata: Make ata_dev_set_mode() less verbose
      libata: Fix ata_err_string()
      libata: Fix comment typo in ata_eh_analyze_tf()
      sata_nv: don't use block layer bounce buffer
      ata: hpt37x: Convert to use match_string() helper

commit 01fc27d96950149c3e6c0b8dfbe05e26725381cb
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue May 29 15:52:26 2018 +0200

    libata: remove ata_scsi_timed_out
    
    As far as I can tell this function can't even be called any more, given
    that ATA implements its own eh_strategy_handler with ata_scsi_error, which
    never calls ->eh_timed_out.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 1795fecdea17..1c113134c98f 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1133,7 +1133,6 @@ extern int ata_sas_port_start(struct ata_port *ap);
 extern void ata_sas_port_stop(struct ata_port *ap);
 extern int ata_sas_slave_configure(struct scsi_device *, struct ata_port *);
 extern int ata_sas_queuecmd(struct scsi_cmnd *cmd, struct ata_port *ap);
-extern enum blk_eh_timer_return ata_scsi_timed_out(struct scsi_cmnd *cmd);
 extern int sata_scr_valid(struct ata_link *link);
 extern int sata_scr_read(struct ata_link *link, int reg, u32 *val);
 extern int sata_scr_write(struct ata_link *link, int reg, u32 val);
@@ -1359,7 +1358,6 @@ extern struct device_attribute *ata_common_sdev_attrs[];
 	.proc_name		= drv_name,			\
 	.slave_configure	= ata_scsi_slave_config,	\
 	.slave_destroy		= ata_scsi_slave_destroy,	\
-	.eh_timed_out		= ata_scsi_timed_out,		\
 	.bios_param		= ata_std_bios_param,		\
 	.unlock_native_capacity	= ata_scsi_unlock_native_capacity, \
 	.sdev_attrs		= ata_common_sdev_attrs

commit 28361c403683c2b00d4f5e76045f3ccd299bf99d
Author: Jens Axboe <axboe@kernel.dk>
Date:   Fri May 11 12:51:09 2018 -0600

    libata: add extra internal command
    
    Bump the internal tag to 32, instead of stealing the last tag in
    our regular command space. This works just fine, since we don't
    actually need a separate hardware tag for this. Internal commands
    cannot coexist with NCQ commands.
    
    As a bonus, we get rid of the special casing of what tag to use
    for the internal command.
    
    This is in preparation for utilizing all 32 commands for normal IO.
    
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 60ce1ba26fdd..1d026719461b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -125,9 +125,8 @@ enum {
 	LIBATA_MAX_PRD		= ATA_MAX_PRD / 2,
 	LIBATA_DUMB_MAX_PRD	= ATA_MAX_PRD / 4,	/* Worst case */
 	ATA_DEF_QUEUE		= 1,
-	/* tag ATA_MAX_QUEUE - 1 is reserved for internal commands */
 	ATA_MAX_QUEUE		= 32,
-	ATA_TAG_INTERNAL	= ATA_MAX_QUEUE - 1,
+	ATA_TAG_INTERNAL	= ATA_MAX_QUEUE,
 	ATA_SHORT_PAUSE		= 16,
 
 	ATAPI_MAX_DRAIN		= 16 << 10,
@@ -850,7 +849,7 @@ struct ata_port {
 	unsigned int		udma_mask;
 	unsigned int		cbl;	/* cable type; ATA_CBL_xxx */
 
-	struct ata_queued_cmd	qcmd[ATA_MAX_QUEUE];
+	struct ata_queued_cmd	qcmd[ATA_MAX_QUEUE + 1];
 	unsigned long		sas_tag_allocated; /* for sas tag allocation only */
 	u64			qc_active;
 	int			nr_active_links; /* #links with active qcs */
@@ -1486,14 +1485,14 @@ extern void ata_port_pbar_desc(struct ata_port *ap, int bar, ssize_t offset,
 			       const char *name);
 #endif
 
-static inline unsigned int ata_tag_valid(unsigned int tag)
+static inline bool ata_tag_internal(unsigned int tag)
 {
-	return (tag < ATA_MAX_QUEUE) ? 1 : 0;
+	return tag == ATA_TAG_INTERNAL;
 }
 
-static inline bool ata_tag_internal(unsigned int tag)
+static inline bool ata_tag_valid(unsigned int tag)
 {
-	return tag == ATA_TAG_INTERNAL;
+	return tag < ATA_MAX_QUEUE || ata_tag_internal(tag);
 }
 
 /*
@@ -1656,7 +1655,7 @@ static inline void ata_qc_set_polling(struct ata_queued_cmd *qc)
 static inline struct ata_queued_cmd *__ata_qc_from_tag(struct ata_port *ap,
 						       unsigned int tag)
 {
-	if (likely(ata_tag_valid(tag)))
+	if (ata_tag_valid(tag))
 		return &ap->qcmd[tag];
 	return NULL;
 }

commit 2e2cc676cee8962cdc82a23723df2fb394d35c64
Author: Jens Axboe <axboe@kernel.dk>
Date:   Fri May 11 12:51:06 2018 -0600

    libata: use ata_tag_internal() consistently
    
    Some check for the value directly, use the provided helper instead.
    Also make it return a bool, since that's what it does.
    
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 2881919b3728..60ce1ba26fdd 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1491,7 +1491,7 @@ static inline unsigned int ata_tag_valid(unsigned int tag)
 	return (tag < ATA_MAX_QUEUE) ? 1 : 0;
 }
 
-static inline unsigned int ata_tag_internal(unsigned int tag)
+static inline bool ata_tag_internal(unsigned int tag)
 {
 	return tag == ATA_TAG_INTERNAL;
 }

commit e3ed8939644166a7560a33c46f508584a7f1756a
Author: Jens Axboe <axboe@kernel.dk>
Date:   Fri May 11 12:51:05 2018 -0600

    libata: bump ->qc_active to a 64-bit type
    
    This is in preparation for allowing full usage of the tag space,
    which means that our reserved error handling command will be
    using an internal tag value of 32. This doesn't fit in a u32, so
    move to a u64.
    
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 07a8d54ba7af..2881919b3728 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -852,7 +852,7 @@ struct ata_port {
 
 	struct ata_queued_cmd	qcmd[ATA_MAX_QUEUE];
 	unsigned long		sas_tag_allocated; /* for sas tag allocation only */
-	unsigned int		qc_active;
+	u64			qc_active;
 	int			nr_active_links; /* #links with active qcs */
 	unsigned int		sas_last_tag;	/* track next tag hw expects */
 
@@ -1185,7 +1185,7 @@ extern void ata_id_c_string(const u16 *id, unsigned char *s,
 extern unsigned int ata_do_dev_read_id(struct ata_device *dev,
 					struct ata_taskfile *tf, u16 *id);
 extern void ata_qc_complete(struct ata_queued_cmd *qc);
-extern int ata_qc_complete_multiple(struct ata_port *ap, u32 qc_active);
+extern int ata_qc_complete_multiple(struct ata_port *ap, u64 qc_active);
 extern void ata_scsi_simulate(struct ata_device *dev, struct scsi_cmnd *cmd);
 extern int ata_std_bios_param(struct scsi_device *sdev,
 			      struct block_device *bdev,

commit 5ac40790b4708e4cb1a64ba2cb77320939bc5240
Author: Jens Axboe <axboe@kernel.dk>
Date:   Fri May 11 12:51:03 2018 -0600

    libata: introduce notion of separate hardware tags
    
    Rigth now these are the same, but drivers should be using ->hw_tag
    for their command setup and issue.
    
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 1795fecdea17..07a8d54ba7af 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -637,7 +637,8 @@ struct ata_queued_cmd {
 	u8			cdb[ATAPI_CDB_LEN];
 
 	unsigned long		flags;		/* ATA_QCFLAG_xxx */
-	unsigned int		tag;
+	unsigned int		tag;		/* libata core tag */
+	unsigned int		hw_tag;		/* driver tag */
 	unsigned int		n_elem;
 	unsigned int		orig_n_elem;
 

commit b6240a4df0186c03e5ffff6f61570ed31a1a5172
Author: Jason Yan <yanaijie@huawei.com>
Date:   Mon Mar 26 17:27:41 2018 +0800

    scsi: libsas: add transport class for ATA devices
    
    Now ata devices attached with sas controller do not have transport
    class, so that we can not see any information of these ata devices in
    /sys/class/ata_port(or ata_link or ata_device).
    
    Add transport class for the ata devices attached with sas controller.
    The /sys/class directory will show the infomation of the ata devices
    as follows:
    
    localhost:/sys/class # ls ata*
    ata_device:
    dev1.0  dev2.0
    
    ata_link:
    link1  link2
    
    ata_port:
    ata1  ata2
    
    No functional change of the device scanning and io path. The ata
    transport class was deleted when destroying the sas devices.
    
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    CC: Dan Williams <dan.j.williams@intel.com>
    CC: Tejun Heo <tj@kernel.org>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 1795fecdea17..0619ebf4d475 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1130,6 +1130,8 @@ extern void ata_sas_async_probe(struct ata_port *ap);
 extern int ata_sas_sync_probe(struct ata_port *ap);
 extern int ata_sas_port_init(struct ata_port *);
 extern int ata_sas_port_start(struct ata_port *ap);
+extern int ata_sas_tport_add(struct device *parent, struct ata_port *ap);
+extern void ata_sas_tport_delete(struct ata_port *ap);
 extern void ata_sas_port_stop(struct ata_port *ap);
 extern int ata_sas_slave_configure(struct scsi_device *, struct ata_port *);
 extern int ata_sas_queuecmd(struct scsi_cmnd *cmd, struct ata_port *ap);

commit 2623c7a5f2799569d8bb05eb211da524a8144cb3
Author: Taras Kondratiuk <takondra@cisco.com>
Date:   Fri Mar 9 08:34:41 2018 +0000

    libata: add refcounting to ata_host
    
    After commit 9a6d6a2ddabb ("ata: make ata port as parent device of scsi
    host") manual driver unbind/remove causes use-after-free.
    
    Unbind unconditionally invokes devres_release_all() which calls
    ata_host_release() and frees ata_host/ata_port memory while it is still
    being referenced as a parent of SCSI host. When SCSI host is finally
    released scsi_host_dev_release() calls put_device(parent) and accesses
    freed ata_port memory.
    
    Add reference counting to make sure that ata_host lives long enough.
    
    Bug report: https://lkml.org/lkml/2017/11/1/945
    Fixes: 9a6d6a2ddabb ("ata: make ata port as parent device of scsi host")
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Lin Ming <minggr@gmail.com>
    Cc: linux-ide@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Taras Kondratiuk <takondra@cisco.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ed9826b21c5e..1795fecdea17 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -617,6 +617,7 @@ struct ata_host {
 	void			*private_data;
 	struct ata_port_operations *ops;
 	unsigned long		flags;
+	struct kref		kref;
 
 	struct mutex		eh_mutex;
 	struct task_struct	*eh_owner;

commit f4ac6476945ff62939420bcf8266e39f8d5d54bd
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Sep 14 12:35:36 2017 +0200

    libata: Add new med_power_with_dipm link_power_management_policy setting
    
    As described by Matthew Garret quite a while back:
    https://mjg59.dreamwidth.org/34868.html
    
    Intel CPUs starting with the Haswell generation need SATA links to power
    down for the "package" part of the CPU to reach low power-states like
    PC7 / P8 which bring a significant power-saving with them.
    
    The default max_performance lpm policy does not allow for these high
    PC states, both the medium_power and min_power policies do allow this.
    
    The min_power policy saves significantly more power, but there are some
    reports of some disks / SSDs not liking min_power leading to system
    crashes and in some cases even data corruption has been reported.
    
    Matthew has found a document documenting the default settings of
    Intel's IRST Windows driver with which most laptops ship:
    https://www-ssl.intel.com/content/dam/doc/reference-guide/sata-devices-implementation-recommendations.pdf
    
    Matthew wrote a patch changing med_power to match those defaults, but
    that never got anywhere as some people where reporting issues with the
    patch-set that patch was a part of.
    
    This commit is another attempt to make the default IRST driver settings
    available under Linux, but instead of changing medium_power and
    potentially introducing regressions, this commit adds a new
    med_power_with_dipm setting which is identical to the existing
    medium_power accept that it enables dipm on top, which makes it match
    the Windows IRST driver settings, which should hopefully be safe to
    use on most devices.
    
    The med_power_with_dipm setting is close to min_power, except that:
    a) It does not use host-initiated slumber mode (ASP not set),
       but it does allow device-initiated slumber
    b) It does not enable DevSlp mode
    
    On my T440s test laptop I get the following power savings when idle:
    medium_power            0.9W
    med_power_with_dipm     1.2W
    min_power               1.2W
    
    Suggested-by: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 931c32f1f18d..ed9826b21c5e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -522,6 +522,7 @@ enum ata_lpm_policy {
 	ATA_LPM_UNKNOWN,
 	ATA_LPM_MAX_POWER,
 	ATA_LPM_MED_POWER,
+	ATA_LPM_MED_POWER_WITH_DIPM, /* Med power + DIPM as win IRST does */
 	ATA_LPM_MIN_POWER,
 };
 

commit 7cfdfdc82a467c78af9132cb9c98e84415df34bc
Author: Damien Le Moal <damien.lemoal@wdc.com>
Date:   Mon Jul 10 14:45:20 2017 +0900

    libata: Cleanup ata_read_log_page()
    
    The warning message "READ LOG DMA EXT failed, trying unqueued" in
    ata_read_log_page() as well as the macro name ATA_HORKAGE_NO_NCQ_LOG
    are confusing: the command READ LOG DMA EXT is not an queued NCQ command
    unless it is encapsulated in a RECEIVE FPDMA QUEUED command.
    From ACS-4 READ LOG DMA EXT description:
    
    "The device processes the READ LOG DMA EXT command in the NCQ feature
    set environment (see 4.13.6) if the READ LOG DMA EXT command is
    encapsulated in a RECEIVE FPDMA QUEUED command (see 7.30) with the
    inputs encapsulated as shown in 7.23.6."
    
    To avoid confusion, fix the warning messsage to mention switching to PIO and
    not "unqueued" and rename the macro ATA_HORKAGE_NO_NCQ_LOG to
    ATA_HORKAGE_NO_DMA_LOG.
    
    Signed-off-by: Damien Le Moal <damien.lemoal@wdc.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 55de3da58b1c..931c32f1f18d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -435,7 +435,7 @@ enum {
 	ATA_HORKAGE_NOLPM	= (1 << 20),	/* don't use LPM */
 	ATA_HORKAGE_WD_BROKEN_LPM = (1 << 21),	/* some WDs have broken LPM */
 	ATA_HORKAGE_ZERO_AFTER_TRIM = (1 << 22),/* guarantees zero after trim */
-	ATA_HORKAGE_NO_NCQ_LOG	= (1 << 23),	/* don't use NCQ for log read */
+	ATA_HORKAGE_NO_DMA_LOG	= (1 << 23),	/* don't use DMA for log read */
 	ATA_HORKAGE_NOTRIM	= (1 << 24),	/* don't use TRIM */
 	ATA_HORKAGE_MAX_SEC_1024 = (1 << 25),	/* Limit max sects to 1024 */
 

commit 818831c8b22f75353f59a63a484e20736c0567c9
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Jun 4 14:42:24 2017 +0200

    libata: implement SECURITY PROTOCOL IN/OUT
    
    This allows us to use the generic OPAL code with ATA devices.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 9e6633235ad7..55de3da58b1c 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -156,6 +156,7 @@ enum {
 	ATA_DFLAG_ACPI_PENDING	= (1 << 5), /* ACPI resume action pending */
 	ATA_DFLAG_ACPI_FAILED	= (1 << 6), /* ACPI on devcfg has failed */
 	ATA_DFLAG_AN		= (1 << 7), /* AN configured */
+	ATA_DFLAG_TRUSTED	= (1 << 8), /* device supports trusted send/recv */
 	ATA_DFLAG_DMADIR	= (1 << 10), /* device requires DMADIR */
 	ATA_DFLAG_CFG_MASK	= (1 << 12) - 1,
 

commit 9bb9a39ce51eae886575251e87d9292f679e3e32
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Tue May 16 09:16:37 2017 -0300

    ata: update references for libata documentation
    
    The libata documentation is now using ReST. Update references
    to it to point to the new place.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c9a69fc8821e..9e6633235ad7 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -19,7 +19,7 @@
  *
  *
  *  libata documentation is available via 'make {ps|pdf}docs',
- *  as Documentation/DocBook/libata.*
+ *  as Documentation/driver-api/libata.rst
  *
  */
 

commit 79f4d1d5c0d7d115b5a693a5bb369e69efb7e7a5
Merge: 97a229f90731 73b2951414f6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 21 17:21:32 2017 -0800

    Merge branch 'for-4.11' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata
    
    Pull libata updates from Tejun Heo:
    
     - Bartlomiej added pata_falcon
    
     - Christoph is trying to remove use of static 4k buf.  It's still WIP
    
     - config cleanup around HAS_DMA
    
     - other fixes and driver-specific changes
    
    * 'for-4.11' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata: (29 commits)
      ata: pata_of_platform: using of_property_read_u32() helper
      pata_atiixp: Don't use unconnected secondary port on SB600/SB700
      libata-sff: Don't scan disabled ports when checking for legacy mode.
      pata_octeon_cf: remove unused local variables from octeon_cf_set_piomode()
      ahci: qoriq: added ls2088a platforms support
      ahci: qoriq: report error when ecc register address is missing in dts
      ahci: qoriq: added a condition to enable dma coherence
      Revert "libata: switch to dynamic allocation instead of ata_scsi_rbuf"
      ahci: imx: fix building without hwmon or thermal
      ata: add Atari Falcon PATA controller driver
      ata: pass queued command to ->sff_data_xfer method
      ata: allow subsystem to be used on m68k arch
      libata: switch to dynamic allocation instead of ata_scsi_rbuf
      libata: don't call ata_scsi_rbuf_fill for command without a response buffer
      libata: call ->scsi_done from ata_scsi_simulate
      libata: remove the done callback from ata_scsi_args
      libata: move struct ata_scsi_args to libata-scsi.c
      libata: avoid global response buffer in atapi_qc_complete
      libata-eh: Use switch() instead of sparse array for protocol strings
      ata: sata_mv: Convert to devm_ioremap_resource()
      ...

commit b6a05c823fc573a65efc4466f174abf05f922e0f
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 30 13:18:58 2017 +0100

    scsi: remove eh_timed_out methods in the transport template
    
    Instead define the timeout behavior purely based on the host_template
    eh_timed_out method and wire up the existing transport implementations
    in the host templates.  This also clears up the confusion that the
    transport template method overrides the host template one, so some
    drivers have to re-override the transport template one.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c170be548b7f..46e18c0619c6 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1130,6 +1130,7 @@ extern int ata_sas_port_start(struct ata_port *ap);
 extern void ata_sas_port_stop(struct ata_port *ap);
 extern int ata_sas_slave_configure(struct scsi_device *, struct ata_port *);
 extern int ata_sas_queuecmd(struct scsi_cmnd *cmd, struct ata_port *ap);
+extern enum blk_eh_timer_return ata_scsi_timed_out(struct scsi_cmnd *cmd);
 extern int sata_scr_valid(struct ata_link *link);
 extern int sata_scr_read(struct ata_link *link, int reg, u32 *val);
 extern int sata_scr_write(struct ata_link *link, int reg, u32 val);
@@ -1355,6 +1356,7 @@ extern struct device_attribute *ata_common_sdev_attrs[];
 	.proc_name		= drv_name,			\
 	.slave_configure	= ata_scsi_slave_config,	\
 	.slave_destroy		= ata_scsi_slave_destroy,	\
+	.eh_timed_out		= ata_scsi_timed_out,		\
 	.bios_param		= ata_std_bios_param,		\
 	.unlock_native_capacity	= ata_scsi_unlock_native_capacity, \
 	.sdev_attrs		= ata_common_sdev_attrs

commit 989e0aac1a801e9e9580632c9fd448a7aaca596a
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Fri Dec 30 15:01:17 2016 +0100

    ata: pass queued command to ->sff_data_xfer method
    
    For Atari Falcon PATA support we need to check the current command
    in its ->sff_data_xfer method.  Update core code and all users
    accordingly.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c170be548b7f..0e8a8000b45f 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -968,7 +968,7 @@ struct ata_port_operations {
 	void (*sff_tf_read)(struct ata_port *ap, struct ata_taskfile *tf);
 	void (*sff_exec_command)(struct ata_port *ap,
 				 const struct ata_taskfile *tf);
-	unsigned int (*sff_data_xfer)(struct ata_device *dev,
+	unsigned int (*sff_data_xfer)(struct ata_queued_cmd *qc,
 			unsigned char *buf, unsigned int buflen, int rw);
 	void (*sff_irq_on)(struct ata_port *);
 	bool (*sff_irq_check)(struct ata_port *);
@@ -1823,11 +1823,11 @@ extern void ata_sff_tf_load(struct ata_port *ap, const struct ata_taskfile *tf);
 extern void ata_sff_tf_read(struct ata_port *ap, struct ata_taskfile *tf);
 extern void ata_sff_exec_command(struct ata_port *ap,
 				 const struct ata_taskfile *tf);
-extern unsigned int ata_sff_data_xfer(struct ata_device *dev,
+extern unsigned int ata_sff_data_xfer(struct ata_queued_cmd *qc,
 			unsigned char *buf, unsigned int buflen, int rw);
-extern unsigned int ata_sff_data_xfer32(struct ata_device *dev,
+extern unsigned int ata_sff_data_xfer32(struct ata_queued_cmd *qc,
 			unsigned char *buf, unsigned int buflen, int rw);
-extern unsigned int ata_sff_data_xfer_noirq(struct ata_device *dev,
+extern unsigned int ata_sff_data_xfer_noirq(struct ata_queued_cmd *qc,
 			unsigned char *buf, unsigned int buflen, int rw);
 extern void ata_sff_irq_on(struct ata_port *ap);
 extern void ata_sff_irq_clear(struct ata_port *ap);

commit 84f95243b5439a20c33837075b88926bfa00c4ec
Author: Adam Manzanares <adam.manzanares@hgst.com>
Date:   Mon Oct 17 11:27:30 2016 -0700

    ata: ATA Command Priority Disabled By Default
    
    Add a sysfs entry to turn on priority information being passed
    to a ATA device. By default this feature is turned off.
    
    This patch depends on ata: Enabling ATA Command Priorities
    
    tj: Renamed ncq_prio_on to ncq_prio_enable and removed trivial
        ata_ncq_prio_on() and open-coded the test.
    
    Signed-off-by: Adam Manzanares <adam.manzanares@hgst.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 90b69a6293a3..c170be548b7f 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -167,6 +167,7 @@ enum {
 	ATA_DFLAG_UNLOCK_HPA	= (1 << 18), /* unlock HPA */
 	ATA_DFLAG_NCQ_SEND_RECV = (1 << 19), /* device supports NCQ SEND and RECV */
 	ATA_DFLAG_NCQ_PRIO	= (1 << 20), /* device supports NCQ priority */
+	ATA_DFLAG_NCQ_PRIO_ENABLE = (1 << 21), /* Priority cmds sent to dev */
 	ATA_DFLAG_INIT_MASK	= (1 << 24) - 1,
 
 	ATA_DFLAG_DETACH	= (1 << 24),
@@ -545,6 +546,7 @@ typedef void (*ata_postreset_fn_t)(struct ata_link *link, unsigned int *classes)
 
 extern struct device_attribute dev_attr_link_power_management_policy;
 extern struct device_attribute dev_attr_unload_heads;
+extern struct device_attribute dev_attr_ncq_prio_enable;
 extern struct device_attribute dev_attr_em_message_type;
 extern struct device_attribute dev_attr_em_message;
 extern struct device_attribute dev_attr_sw_activity;

commit 8e061784b51ec4a4efed0deaafb5bd9725bf5b06
Author: Adam Manzanares <adam.manzanares@hgst.com>
Date:   Mon Oct 17 11:27:29 2016 -0700

    ata: Enabling ATA Command Priorities
    
    This patch checks to see if an ATA device supports NCQ command priorities.
    If so and the user has specified an iocontext that indicates
    IO_PRIO_CLASS_RT then we build a tf with a high priority command.
    
    This is done to improve the tail latency of commands that are high
    priority by passing priority to the device.
    
    tj: Removed trivial ata_ncq_prio_enabled() and open-coded the test.
    
    Signed-off-by: Adam Manzanares <adam.manzanares@hgst.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 616eef4d81ea..90b69a6293a3 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -166,6 +166,7 @@ enum {
 	ATA_DFLAG_NO_UNLOAD	= (1 << 17), /* device doesn't support unload */
 	ATA_DFLAG_UNLOCK_HPA	= (1 << 18), /* unlock HPA */
 	ATA_DFLAG_NCQ_SEND_RECV = (1 << 19), /* device supports NCQ SEND and RECV */
+	ATA_DFLAG_NCQ_PRIO	= (1 << 20), /* device supports NCQ priority */
 	ATA_DFLAG_INIT_MASK	= (1 << 24) - 1,
 
 	ATA_DFLAG_DETACH	= (1 << 24),
@@ -342,7 +343,9 @@ enum {
 	ATA_SHIFT_PIO		= 0,
 	ATA_SHIFT_MWDMA		= ATA_SHIFT_PIO + ATA_NR_PIO_MODES,
 	ATA_SHIFT_UDMA		= ATA_SHIFT_MWDMA + ATA_NR_MWDMA_MODES,
+	ATA_SHIFT_PRIO		= 6,
 
+	ATA_PRIO_HIGH		= 2,
 	/* size of buffer to pad xfers ending on unaligned boundaries */
 	ATA_DMA_PAD_SZ		= 4,
 

commit dcd3ea81f572fba57d18e91743a525a9787c1f6e
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Sep 22 07:49:50 2016 -0700

    libata: remove <asm-generic/libata-portmap.h>
    
    asm-generic is only intended for architecture defaults, and we can simply
    kill it off by moving the two defintions directly to <linux/libata.h>.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index e37d4f99f510..616eef4d81ea 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -46,7 +46,8 @@
 #ifdef CONFIG_ATA_NONSTANDARD
 #include <asm/libata-portmap.h>
 #else
-#include <asm-generic/libata-portmap.h>
+#define ATA_PRIMARY_IRQ(dev)	14
+#define ATA_SECONDARY_IRQ(dev)	15
 #endif
 
 /*

commit 37f92d77dc45d1fb74eff8501f26e72a3dcaa3cf
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jul 16 22:16:43 2016 +0900

    ata: define ATA_PROT_* in terms of ATA_PROT_FLAG_*
    
    This avoid the need to always translate between the two in ata_prot_flags
    and generally cleans up the taskfile protocol usage.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 5838fbf6acf7..e37d4f99f510 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -146,12 +146,6 @@ enum {
 	ATA_TFLAG_FUA		= (1 << 5), /* enable FUA */
 	ATA_TFLAG_POLLING	= (1 << 6), /* set nIEN to 1 and use polling */
 
-	/* protocol flags */
-	ATA_PROT_FLAG_PIO	= (1 << 0), /* is PIO */
-	ATA_PROT_FLAG_DMA	= (1 << 1), /* is DMA */
-	ATA_PROT_FLAG_NCQ	= (1 << 2), /* is NCQ */
-	ATA_PROT_FLAG_ATAPI	= (1 << 3), /* is ATAPI */
-
 	/* struct ata_device stuff */
 	ATA_DFLAG_LBA		= (1 << 0), /* device supports LBA */
 	ATA_DFLAG_LBA48		= (1 << 1), /* device supports LBA48 */
@@ -1038,55 +1032,29 @@ extern const unsigned long sata_deb_timing_long[];
 extern struct ata_port_operations ata_dummy_port_ops;
 extern const struct ata_port_info ata_dummy_port_info;
 
-/*
- * protocol tests
- */
-static inline unsigned int ata_prot_flags(u8 prot)
-{
-	switch (prot) {
-	case ATA_PROT_NODATA:
-		return 0;
-	case ATA_PROT_PIO:
-		return ATA_PROT_FLAG_PIO;
-	case ATA_PROT_DMA:
-		return ATA_PROT_FLAG_DMA;
-	case ATA_PROT_NCQ:
-		return ATA_PROT_FLAG_DMA | ATA_PROT_FLAG_NCQ;
-	case ATA_PROT_NCQ_NODATA:
-		return ATA_PROT_FLAG_NCQ;
-	case ATAPI_PROT_NODATA:
-		return ATA_PROT_FLAG_ATAPI;
-	case ATAPI_PROT_PIO:
-		return ATA_PROT_FLAG_ATAPI | ATA_PROT_FLAG_PIO;
-	case ATAPI_PROT_DMA:
-		return ATA_PROT_FLAG_ATAPI | ATA_PROT_FLAG_DMA;
-	}
-	return 0;
-}
-
 static inline bool ata_is_atapi(u8 prot)
 {
-	return ata_prot_flags(prot) & ATA_PROT_FLAG_ATAPI;
+	return prot & ATA_PROT_FLAG_ATAPI;
 }
 
 static inline bool ata_is_pio(u8 prot)
 {
-	return ata_prot_flags(prot) & ATA_PROT_FLAG_PIO;
+	return prot & ATA_PROT_FLAG_PIO;
 }
 
 static inline bool ata_is_dma(u8 prot)
 {
-	return ata_prot_flags(prot) & ATA_PROT_FLAG_DMA;
+	return prot & ATA_PROT_FLAG_DMA;
 }
 
 static inline bool ata_is_ncq(u8 prot)
 {
-	return ata_prot_flags(prot) & ATA_PROT_FLAG_NCQ;
+	return prot & ATA_PROT_FLAG_NCQ;
 }
 
 static inline bool ata_is_data(u8 prot)
 {
-	return ata_prot_flags(prot) & (ATA_PROT_FLAG_PIO | ATA_PROT_FLAG_DMA);
+	return prot & (ATA_PROT_FLAG_PIO | ATA_PROT_FLAG_DMA);
 }
 
 static inline int is_multi_taskfile(struct ata_taskfile *tf)

commit d6e50e379eb1e7f2426eac61a1bbbf6e4cf68905
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jul 16 22:16:42 2016 +0900

    libata: remove ATA_PROT_FLAG_DATA
    
    Instead we can simply check for PIO or DMA in ata_is_data.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 283b6be6c319..5838fbf6acf7 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -149,7 +149,6 @@ enum {
 	/* protocol flags */
 	ATA_PROT_FLAG_PIO	= (1 << 0), /* is PIO */
 	ATA_PROT_FLAG_DMA	= (1 << 1), /* is DMA */
-	ATA_PROT_FLAG_DATA	= ATA_PROT_FLAG_PIO | ATA_PROT_FLAG_DMA,
 	ATA_PROT_FLAG_NCQ	= (1 << 2), /* is NCQ */
 	ATA_PROT_FLAG_ATAPI	= (1 << 3), /* is ATAPI */
 
@@ -1087,7 +1086,7 @@ static inline bool ata_is_ncq(u8 prot)
 
 static inline bool ata_is_data(u8 prot)
 {
-	return ata_prot_flags(prot) & ATA_PROT_FLAG_DATA;
+	return ata_prot_flags(prot) & (ATA_PROT_FLAG_PIO | ATA_PROT_FLAG_DMA);
 }
 
 static inline int is_multi_taskfile(struct ata_taskfile *tf)

commit eb0effdf53b061bd57d8efc86032454e79487263
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jul 16 22:16:41 2016 +0900

    libata: remove ata_is_nodata
    
    The only caller can just check for !ata_is_data instead.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 1abd6690c776..283b6be6c319 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1070,11 +1070,6 @@ static inline bool ata_is_atapi(u8 prot)
 	return ata_prot_flags(prot) & ATA_PROT_FLAG_ATAPI;
 }
 
-static inline bool ata_is_nodata(u8 prot)
-{
-	return !(ata_prot_flags(prot) & ATA_PROT_FLAG_DATA);
-}
-
 static inline bool ata_is_pio(u8 prot)
 {
 	return ata_prot_flags(prot) & ATA_PROT_FLAG_PIO;

commit 5b844b63ddfb65aef923eaabe0420196fd71dd13
Author: Hannes Reinecke <hare@suse.de>
Date:   Thu Jul 14 09:05:48 2016 +0900

    ata: Handle ATA NCQ NO-DATA commands correctly
    
    Add a new taskfile protocol ATA_PROT_NCQ_NODATA to handle
    ATA NCQ NO-DATA commands correctly.
    And fixup ata_scsi_zbc_out_xlat() to use it.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 4e5a09c6dc10..1abd6690c776 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1053,6 +1053,8 @@ static inline unsigned int ata_prot_flags(u8 prot)
 		return ATA_PROT_FLAG_DMA;
 	case ATA_PROT_NCQ:
 		return ATA_PROT_FLAG_DMA | ATA_PROT_FLAG_NCQ;
+	case ATA_PROT_NCQ_NODATA:
+		return ATA_PROT_FLAG_NCQ;
 	case ATAPI_PROT_NODATA:
 		return ATA_PROT_FLAG_ATAPI;
 	case ATAPI_PROT_PIO:

commit b1c04e80c6da5f5d3d4778ede23c59666135fdeb
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Jul 14 09:05:42 2016 +0900

    libata: return boolean values from ata_is_*
    
    This way we don't have to worry about the exact bit postition of the
    test to leak out and any crazy propagation effects in the callers.
    
    Suggested-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d15c19e331d1..4e5a09c6dc10 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1063,32 +1063,32 @@ static inline unsigned int ata_prot_flags(u8 prot)
 	return 0;
 }
 
-static inline int ata_is_atapi(u8 prot)
+static inline bool ata_is_atapi(u8 prot)
 {
 	return ata_prot_flags(prot) & ATA_PROT_FLAG_ATAPI;
 }
 
-static inline int ata_is_nodata(u8 prot)
+static inline bool ata_is_nodata(u8 prot)
 {
 	return !(ata_prot_flags(prot) & ATA_PROT_FLAG_DATA);
 }
 
-static inline int ata_is_pio(u8 prot)
+static inline bool ata_is_pio(u8 prot)
 {
 	return ata_prot_flags(prot) & ATA_PROT_FLAG_PIO;
 }
 
-static inline int ata_is_dma(u8 prot)
+static inline bool ata_is_dma(u8 prot)
 {
 	return ata_prot_flags(prot) & ATA_PROT_FLAG_DMA;
 }
 
-static inline int ata_is_ncq(u8 prot)
+static inline bool ata_is_ncq(u8 prot)
 {
 	return ata_prot_flags(prot) & ATA_PROT_FLAG_NCQ;
 }
 
-static inline int ata_is_data(u8 prot)
+static inline bool ata_is_data(u8 prot)
 {
 	return ata_prot_flags(prot) & ATA_PROT_FLAG_DATA;
 }
@@ -1407,7 +1407,7 @@ static inline bool sata_pmp_attached(struct ata_port *ap)
 	return ap->nr_pmp_links != 0;
 }
 
-static inline int ata_is_host_link(const struct ata_link *link)
+static inline bool ata_is_host_link(const struct ata_link *link)
 {
 	return link == &link->ap->link || link == link->ap->slave_link;
 }
@@ -1422,7 +1422,7 @@ static inline bool sata_pmp_attached(struct ata_port *ap)
 	return false;
 }
 
-static inline int ata_is_host_link(const struct ata_link *link)
+static inline bool ata_is_host_link(const struct ata_link *link)
 {
 	return 1;
 }

commit 6d1003ae8db228b74ef61536364cd2a1bd973dd8
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 25 12:45:56 2016 +0200

    libata: support host-aware and host-managed ZAC devices
    
    Byte 69 bits 0:1 in the IDENTIFY DEVICE data indicate a
    host-aware ZAC device.
    Host-managed ZAC devices have their own individual signature,
    and to not set the bits in the IDENTIFY DEVICE data.
    And whenever we detect a ZAC-compatible device we should
    be displaying the zoned block characteristics VPD page.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 0019d4b51b11..d15c19e331d1 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -181,6 +181,7 @@ enum {
 	ATA_DFLAG_DEVSLP	= (1 << 27), /* device supports Device Sleep */
 	ATA_DFLAG_ACPI_DISABLED = (1 << 28), /* ACPI for the device is disabled */
 	ATA_DFLAG_D_SENSE	= (1 << 29), /* Descriptor sense requested */
+	ATA_DFLAG_ZAC		= (1 << 30), /* ZAC device */
 
 	ATA_DEV_UNKNOWN		= 0,	/* unknown device */
 	ATA_DEV_ATA		= 1,	/* ATA device */
@@ -731,6 +732,12 @@ struct ata_device {
 	u8			ncq_send_recv_cmds[ATA_LOG_NCQ_SEND_RECV_SIZE];
 	u8			ncq_non_data_cmds[ATA_LOG_NCQ_NON_DATA_SIZE];
 
+	/* ZAC zone configuration */
+	u32			zac_zoned_cap;
+	u32			zac_zones_optimal_open;
+	u32			zac_zones_optimal_nonseq;
+	u32			zac_zones_max_open;
+
 	/* error history */
 	int			spdn_cnt;
 	/* ering is CLEAR_END, read comment above CLEAR_END */

commit 284b3b77ea883234dadb2cbf97b145c3c30fe4bd
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 25 12:45:54 2016 +0200

    libata: NCQ encapsulation for ZAC MANAGEMENT OUT
    
    Add NCQ encapsulation for ZAC MANAGEMENT OUT and evaluate
    NCQ Non-Data log pages to figure out if NCQ encapsulation
    is supported.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c0806b60c4fa..0019d4b51b11 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -729,6 +729,7 @@ struct ata_device {
 
 	/* NCQ send and receive log subcommand support */
 	u8			ncq_send_recv_cmds[ATA_LOG_NCQ_SEND_RECV_SIZE];
+	u8			ncq_non_data_cmds[ATA_LOG_NCQ_NON_DATA_SIZE];
 
 	/* error history */
 	int			spdn_cnt;
@@ -1658,6 +1659,12 @@ static inline bool ata_fpdma_zac_mgmt_in_supported(struct ata_device *dev)
 		ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_IN_SUPPORTED);
 }
 
+static inline bool ata_fpdma_zac_mgmt_out_supported(struct ata_device *dev)
+{
+	return (dev->ncq_non_data_cmds[ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OFFSET] &
+		ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OUT);
+}
+
 static inline void ata_qc_set_polling(struct ata_queued_cmd *qc)
 {
 	qc->tf.ctl |= ATA_NIEN;

commit 28a3fc2295a744a0d2ddf86b2ccdf03fbab123f9
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 25 12:45:52 2016 +0200

    libata: implement ZBC IN translation
    
    ZAC drives implement a 'ZAC Management In' command template,
    which maps onto the ZBC IN command.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 92297cd111f6..c0806b60c4fa 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1651,6 +1651,13 @@ static inline bool ata_fpdma_read_log_supported(struct ata_device *dev)
 		 ATA_LOG_NCQ_SEND_RECV_RD_LOG_SUPPORTED);
 }
 
+static inline bool ata_fpdma_zac_mgmt_in_supported(struct ata_device *dev)
+{
+	return (dev->flags & ATA_DFLAG_NCQ_SEND_RECV) &&
+		(dev->ncq_send_recv_cmds[ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OFFSET] &
+		ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_IN_SUPPORTED);
+}
+
 static inline void ata_qc_set_polling(struct ata_queued_cmd *qc)
 {
 	qc->tf.ctl |= ATA_NIEN;

commit 3a92945b24c7ff46757a3d5d5112bfc62d2e45b2
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 25 12:45:51 2016 +0200

    libata: fixup ZAC device disabling
    
    libata device disabling is ... curious. So add the correct
    definitions that we can disable ZAC devices properly.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 09ddb5a6f555..92297cd111f6 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -192,7 +192,8 @@ enum {
 	ATA_DEV_SEMB		= 7,	/* SEMB */
 	ATA_DEV_SEMB_UNSUP	= 8,	/* SEMB (unsupported) */
 	ATA_DEV_ZAC		= 9,	/* ZAC device */
-	ATA_DEV_NONE		= 10,	/* no device */
+	ATA_DEV_ZAC_UNSUP	= 10,	/* ZAC device (unsupported) */
+	ATA_DEV_NONE		= 11,	/* no device */
 
 	/* struct ata_link flags */
 	ATA_LFLAG_NO_HRST	= (1 << 1), /* avoid hardreset */
@@ -1524,7 +1525,8 @@ static inline unsigned int ata_class_enabled(unsigned int class)
 static inline unsigned int ata_class_disabled(unsigned int class)
 {
 	return class == ATA_DEV_ATA_UNSUP || class == ATA_DEV_ATAPI_UNSUP ||
-		class == ATA_DEV_PMP_UNSUP || class == ATA_DEV_SEMB_UNSUP;
+		class == ATA_DEV_PMP_UNSUP || class == ATA_DEV_SEMB_UNSUP ||
+		class == ATA_DEV_ZAC_UNSUP;
 }
 
 static inline unsigned int ata_class_absent(unsigned int class)

commit 5c65d8bb3503beb12864895426a69269c19e6e87
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 25 12:45:47 2016 +0200

    libata: Add command definitions for NCQ Encapsulation for READ LOG DMA EXT
    
    ACS-4 defines an NCQ encapsulation for READ LOG DMA EXT.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a418bca0df0d..09ddb5a6f555 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1642,6 +1642,13 @@ static inline bool ata_fpdma_dsm_supported(struct ata_device *dev)
 		 ATA_LOG_NCQ_SEND_RECV_DSM_TRIM);
 }
 
+static inline bool ata_fpdma_read_log_supported(struct ata_device *dev)
+{
+	return (dev->flags & ATA_DFLAG_NCQ_SEND_RECV) &&
+		(dev->ncq_send_recv_cmds[ATA_LOG_NCQ_SEND_RECV_RD_LOG_OFFSET] &
+		 ATA_LOG_NCQ_SEND_RECV_RD_LOG_SUPPORTED);
+}
+
 static inline void ata_qc_set_polling(struct ata_queued_cmd *qc)
 {
 	qc->tf.ctl |= ATA_NIEN;

commit 06dbde5f3a44248fc02e24d662ac4849202abb48
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 4 11:44:03 2016 +0200

    libata: Implement control mode page to select sense format
    
    Implement MODE SELECT for the control mode page to allow the OS
    to switch to descriptor sense.
    
    tj: Dropped s/sb/cmd->sense_buffer/ in ata_gen_ata_sense().  Added
        @dev description to ata_msense_ctl_mode().
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 2c4ebef79d0c..a418bca0df0d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -180,6 +180,7 @@ enum {
 	ATA_DFLAG_DA		= (1 << 26), /* device supports Device Attention */
 	ATA_DFLAG_DEVSLP	= (1 << 27), /* device supports Device Sleep */
 	ATA_DFLAG_ACPI_DISABLED = (1 << 28), /* ACPI for the device is disabled */
+	ATA_DFLAG_D_SENSE	= (1 << 29), /* Descriptor sense requested */
 
 	ATA_DEV_UNKNOWN		= 0,	/* unknown device */
 	ATA_DEV_ATA		= 1,	/* ATA device */

commit 4ee34ea3a12396f35b26d90a094c75db95080baa
Author: Harvey Hunt <harvey.hunt@imgtec.com>
Date:   Wed Feb 24 15:16:43 2016 +0000

    libata: Align ata_device's id on a cacheline
    
    The id buffer in ata_device is a DMA target, but it isn't explicitly
    cacheline aligned. Due to this, adjacent fields can be overwritten with
    stale data from memory on non coherent architectures. As a result, the
    kernel is sometimes unable to communicate with an ATA device.
    
    Fix this by ensuring that the id buffer is cacheline aligned.
    
    This issue is similar to that fixed by Commit 84bda12af31f
    ("libata: align ap->sector_buf").
    
    Signed-off-by: Harvey Hunt <harvey.hunt@imgtec.com>
    Cc: linux-kernel@vger.kernel.org
    Cc: <stable@vger.kernel.org> # 2.6.18
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index bec2abbd7ab2..2c4ebef79d0c 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -720,7 +720,7 @@ struct ata_device {
 	union {
 		u16		id[ATA_ID_WORDS]; /* IDENTIFY xxx DEVICE data */
 		u32		gscr[SATA_PMP_GSCR_DWORDS]; /* PMP GSCR block */
-	};
+	} ____cacheline_aligned;
 
 	/* DEVSLP Timing Variables from Identify Device Data Log */
 	u8			devslp_timing[ATA_LOG_DEVSLP_SIZE];

commit fb3296335500aaff61333df8eabbccf28761c79d
Author: Danesh Petigara <dpetigara@broadcom.com>
Date:   Mon Jan 11 13:22:26 2016 -0800

    drivers: ata: wake port before DMA stop for ALPM
    
    The AHCI driver code stops and starts port DMA engines at will
    without considering the power state of the particular port. The
    AHCI specification isn't very clear on how to handle this scenario,
    leaving implementation open to interpretation.
    
    Broadcom's STB SATA host controller is unable to handle port DMA
    controller restarts when the port in question is in low power mode.
    When a port enters partial or slumber mode, its PHY is powered down.
    When a controller restart is requested, the controller's internal
    state machine expects the PHY to be brought back up by software which
    never happens in this case, resulting in failures.
    
    To avoid this situation, logic is added to manually wake up the port
    just before its DMA engine is stopped, if the port happens to be in
    a low power state. HBA initiated power management ensures that the port
    eventually returns to its configured low power state, when the link is
    idle (as per the conditions listed in the spec). A new host flag is also
    added to ensure this logic is only exercised for hosts with the above
    limitation.
    
    tj: Formatting changes.
    
    Signed-off-by: Danesh Petigara <dpetigara@broadcom.com>
    Reviewed-by: Markus Mayer <mmayer@broadcom.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 851821bfd553..bec2abbd7ab2 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -526,6 +526,7 @@ enum ata_lpm_policy {
 enum ata_lpm_hints {
 	ATA_LPM_EMPTY		= (1 << 0), /* port empty/probing */
 	ATA_LPM_HIPM		= (1 << 1), /* may use HIPM */
+	ATA_LPM_WAKE_ONLY	= (1 << 2), /* only wake up link */
 };
 
 /* forward declarations */

commit 8c930204ce76eddeb2e1af66a75f0ab2506c76e2
Merge: 367262c1be4b e39b2bb3b72b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 11 19:33:59 2016 -0800

    Merge branch 'for-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata
    
    Pull libata updates from Tejun Heo:
     "Mostly low level driver specific changes.
    
      Two changes are somewhat noteworthy.  First, Dan's patchset to support
      per-port msix interrupt handling for ahci, which was tried last cycle
      but had to be backed out due to a couple issues, is back and seems to
      be working fine.  Second, libata exception handling now uses
      usleep_range() instead of msleep() for sleeps < 20ms which can make
      things snappier in some corner cases"
    
    * 'for-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata:
      libata: skip debounce delay on link resume
      ata: ahci_brcmstb: disable DIPM support
      ata: ahci_brcmstb: enable support for ALPM
      drivers: libata-core: Use usleep_range() instead of msleep() for short sleeps (<20 ms)
      sata_sx4: correctly handling failed allocation
      ata: ahci_brcmstb: add support for MIPS-based platforms
      ahci: qoriq: Adjust the default register values on ls1021a
      ahci: qoriq: Update the default Rx watermark value
      ahci: qoriq: Adjust the default register values on ls1043a
      ahci: compile out msi/msix infrastructure
      ata: core: fix irq description on AHCI single irq systems
      ata: ahci_brcmstb: remove unused definitions
      ata: ahci_brcmstb: add a quirk for MIPS-based platforms
      ata: ahci_brcmstb: disable NCQ for MIPS-based platforms
      ata: sata_rcar: Remove obsolete platform_device_id entries
      sata_rcar: Add compatible string for r8a7795
      ahci: kill 'intr_status'
      ahci: switch from 'threaded' to 'hardirq' interrupt handling
      ahci: per-port msix support

commit e39b2bb3b72b999a04e8d295882be3255aca5ade
Author: Danesh Petigara <dpetigara@broadcom.com>
Date:   Thu Jan 7 16:03:33 2016 -0800

    libata: skip debounce delay on link resume
    
    The link resume logic uses a 200msec delay while debouncing
    the SControl register. The rationale behind that delay is
    to accommodate some PHYs that behave badly if their SStatus/
    SControl registers are pounded immediately on resume.
    The Broadcom STB SATA PHY does not seem to have this issue.
    This patch introduces a new link flag that allows platforms
    to skip the debounce delay if it isn't needed.
    
    Signed-off-by: Danesh Petigara <dpetigara@broadcom.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 83577f8fd15b..088ed924fa66 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -205,6 +205,7 @@ enum {
 	ATA_LFLAG_NO_LPM	= (1 << 8), /* disable LPM on this link */
 	ATA_LFLAG_RST_ONCE	= (1 << 9), /* limit recovery to one reset */
 	ATA_LFLAG_CHANGED	= (1 << 10), /* LPM state changed on this link */
+	ATA_LFLAG_NO_DB_DELAY	= (1 << 11), /* no debounce delay on link resume */
 
 	/* struct ata_port flags */
 	ATA_FLAG_SLAVE_POSS	= (1 << 0), /* host supports slave dev */

commit ea013a9b205b47b1fcbc72522146fad560af0712
Author: Andreas Werner <andreas.werner@men.de>
Date:   Fri Dec 4 18:12:49 2015 +0100

    libata-eh.c: Introduce new ata port flag for controller which lockup on read log page
    
    Some controller lockup on a ata_read_log_page.
    Add new ata port flag ATA_FLAG_NO_LOG_PAGE which can used
    to blacklist a controller.
    
    If this flag is set, any attempt to read a log page returns an error
    without actually issuing the command.
    
    Signed-off-by: Andreas Werner <andreas.werner@men.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 83577f8fd15b..600c1e0626a5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -210,6 +210,7 @@ enum {
 	ATA_FLAG_SLAVE_POSS	= (1 << 0), /* host supports slave dev */
 					    /* (doesn't imply presence) */
 	ATA_FLAG_SATA		= (1 << 1),
+	ATA_FLAG_NO_LOG_PAGE	= (1 << 5), /* do not issue log page read */
 	ATA_FLAG_NO_ATAPI	= (1 << 6), /* No ATAPI support */
 	ATA_FLAG_PIO_DMA	= (1 << 7), /* PIO cmds via DMA */
 	ATA_FLAG_PIO_LBA48	= (1 << 8), /* Host DMA engine is LBA28 only */

commit 8a3e33cf92c7b7ae25c589eccd1a69ab11cc4353
Author: Manuel Lauss <manuel.lauss@gmail.com>
Date:   Wed Sep 30 21:10:25 2015 +0200

    ata: ahci: find eSATA ports and flag them as removable
    
    If the AHCI ports' HPCP or ESP bits are set, the port
    should be considered external (e.g. eSATA) and is marked
    as removable.  Userspace tools like udisks then treat it
    like an usb drive.
    
    With this patch applied, when I plug a drive into the esata port,
    KDE pops up a window asking what to do with the drives(s), just
    like it does for any random USB stick.
    
    Removability is indicated to the upper layers by way of the
    SCSI RMB bit, as I haven't found another way to signal
    userspace to treat a sata disk like any usb stick.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c9cfbcdb8d14..83577f8fd15b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -254,6 +254,7 @@ enum {
 
 	ATA_PFLAG_PIO32		= (1 << 20),  /* 32bit PIO */
 	ATA_PFLAG_PIO32CHANGE	= (1 << 21),  /* 32bit PIO can be turned on/off */
+	ATA_PFLAG_EXTERNAL	= (1 << 22),  /* eSATA/external port */
 
 	/* struct ata_queued_cmd flags */
 	ATA_QCFLAG_ACTIVE	= (1 << 0), /* cmd not yet ack'd to scsi lyer */

commit af34d637637eabaf49406eb35c948cd51ba262a6
Author: David Milburn <dmilburn@redhat.com>
Date:   Mon Jul 13 11:48:23 2015 -0500

    libata: add ATA_HORKAGE_MAX_SEC_1024 to revert back to previous max_sectors limit
    
    Since no longer limiting max_sectors to BLK_DEF_MAX_SECTORS (commit 34b48db66e08),
    data corruption may occur on ST380013AS drive configured on 82801JI (ICH10 Family)
    SATA controller. This patch will allow the driver to limit max_sectors as before
    
     # cat /sys/block/sdb/queue/max_sectors_kb
     512
    
    I was able to double the max_sectors_kb value up to 16384 on linux-4.2.0-rc2
    before seeing corruption, but seems safer to use previous limit. Without this
    patch max_sectors_kb will be 32767.
    
    tj: Minor comment update.
    
    Reported-by: Jeff Moyer <jmoyer@redhat.com>
    Signed-off-by: David Milburn <dmilburn@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: stable@vger.kernel.org # v3.19 and later
    Fixes: 34b48db66e08 ("block: remove artifical max_hw_sectors cap")

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 5c8bac6225a6..c9cfbcdb8d14 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -432,7 +432,7 @@ enum {
 	ATA_HORKAGE_ZERO_AFTER_TRIM = (1 << 22),/* guarantees zero after trim */
 	ATA_HORKAGE_NO_NCQ_LOG	= (1 << 23),	/* don't use NCQ for log read */
 	ATA_HORKAGE_NOTRIM	= (1 << 24),	/* don't use TRIM */
-
+	ATA_HORKAGE_MAX_SEC_1024 = (1 << 25),	/* Limit max sects to 1024 */
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */

commit 71d126fd28de2d4d9b7b2088dbccd7ca62fad6e0
Author: Arne Fitzenreiter <arne_f@ipfire.org>
Date:   Wed Jul 15 13:54:36 2015 +0200

    libata: add ATA_HORKAGE_NOTRIM
    
    Some devices lose data on TRIM whether queued or not.  This patch adds
    a horkage to disable TRIM.
    
    tj: Collapsed unnecessary if() nesting.
    
    Signed-off-by: Arne Fitzenreiter <arne_f@ipfire.org>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 36ce37bcc963..5c8bac6225a6 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -431,6 +431,8 @@ enum {
 	ATA_HORKAGE_WD_BROKEN_LPM = (1 << 21),	/* some WDs have broken LPM */
 	ATA_HORKAGE_ZERO_AFTER_TRIM = (1 << 22),/* guarantees zero after trim */
 	ATA_HORKAGE_NO_NCQ_LOG	= (1 << 23),	/* don't use NCQ for log read */
+	ATA_HORKAGE_NOTRIM	= (1 << 24),	/* don't use TRIM */
+
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */

commit 64e22b86854227b4d13a57fa02f26472bc426812
Merge: 6597ac8a514e 243918be6393
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 25 16:49:21 2015 -0700

    Merge branch 'for-4.2' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata
    
    Pull libata updates from Tejun Heo:
    
     - a number of libata core changes to better support NCQ TRIM.
    
     - ahci now supports MSI-X in single IRQ mode to support a new
       controller which doesn't implement MSI or INTX.
    
     - ahci now supports edge-triggered IRQ mode to support a new controller
       which for some odd reason did edge-triggered IRQ.
    
     - the usual controller support additions and changes.
    
    * 'for-4.2' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata: (27 commits)
      libata: Do not blacklist Micron M500DC
      ata: ahci_mvebu: add suspend/resume support
      ahci, msix: Fix build error for !PCI_MSI
      ahci: Add support for Cavium's ThunderX host controller
      ahci: Add generic MSI-X support for single interrupts to SATA PCI driver
      libata: finally use __initconst in ata_parse_force_one()
      drivers: ata: add support for Ceva sata host controller
      devicetree:bindings: add devicetree bindings for ceva ahci
      ahci: added support for Freescale AHCI sata
      ahci: Store irq number in struct ahci_host_priv
      ahci: Move interrupt enablement code to a separate function
      Doc: libata: Fix spelling typo found in libata.xml
      ata:sata_nv - Change 1 to true for bool type variable.
      ata: add Broadcom AHCI SATA3 driver for STB chips
      Documentation: devicetree: add Broadcom SATA binding
      libata: Fix regression when the NCQ Send and Receive log page is absent
      ata: hpt366: fix constant cast warning
      ata: ahci_xgene: potential NULL dereference in probe
      ata: ahci_xgene: Add AHCI Support for 2nd HW version of APM X-Gene SoC AHCI SATA Host controller.
      libahci: Add support to handle HOST_IRQ_STAT as edge trigger latch.
      ...

commit acd53127c4adbd34570b221e7ea1f7fc94aea923
Merge: f9d1b5a31ab0 c8806b6c9e82
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 23 15:55:44 2015 -0700

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This is the usual grab bag of driver updates (lpfc, hpsa,
      megaraid_sas, cxgbi, be2iscsi) plus an assortment of minor updates.
    
      There is also one new driver: the Cisco snic.  The advansys driver has
      been rewritten to get rid of the warning about converting it to the
      DMA API, the tape statistics patch got in and finally, there's a
      resuffle of SCSI header files to separate more cleanly initiator from
      target mode (and better share the common definitions)"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (156 commits)
      snic: driver for Cisco SCSI HBA
      qla2xxx: Fix indentation
      qla2xxx: Comment out unreachable code
      fusion: remove dead MTRR code
      advansys: fix compilation errors and warnings when CONFIG_PCI is not set
      mptsas: fix depth param in scsi_track_queue_full
      megaraid: fix irq setup process regression
      lpfc: Update version to 10.7.0.0 for upstream patch set.
      lpfc: Fix to drop PLOGIs from fabric node till LOGO processing completes
      lpfc: Fix scsi task management error message.
      lpfc: Fix cq_id masking problem.
      lpfc: Fix scsi prep dma buf error.
      lpfc: Add support for using block multi-queue
      lpfc: Devices are not discovered during takeaway/giveback testing
      lpfc: Fix vport deletion failure.
      lpfc: Check for active portpeerbeacon.
      lpfc: Update driver version for upstream patch set 10.6.0.1.
      lpfc: Change buffer pool empty message to miscellaneous category
      lpfc: Fix incorrect log message reported for empty FCF record.
      lpfc: Fix rport leak.
      ...

commit b84b1d522f979fb53ad347605e24b2940fa2ad99
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Apr 29 08:57:34 2015 +0200

    scsi: Do not set cmd_per_lun to 1 in the host template
    
    '0' is now used as the default cmd_per_lun value,
    so there's no need to explicitly set it to '1' in the
    host template.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 8dad4a307bb8..1402291aab5e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -134,7 +134,6 @@ enum {
 	ATA_ALL_DEVICES		= (1 << ATA_MAX_DEVICES) - 1,
 
 	ATA_SHT_EMULATED	= 1,
-	ATA_SHT_CMD_PER_LUN	= 1,
 	ATA_SHT_THIS_ID		= -1,
 	ATA_SHT_USE_CLUSTERING	= 1,
 
@@ -1354,7 +1353,6 @@ extern struct device_attribute *ata_common_sdev_attrs[];
 	.can_queue		= ATA_DEF_QUEUE,		\
 	.tag_alloc_policy	= BLK_TAG_ALLOC_RR,		\
 	.this_id		= ATA_SHT_THIS_ID,		\
-	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,		\
 	.emulated		= ATA_SHT_EMULATED,		\
 	.use_clustering		= ATA_SHT_USE_CLUSTERING,	\
 	.proc_name		= drv_name,			\

commit 5d3abf8ff67f49271a42c0f7fa4f20f9e046bf0e
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Mon May 4 21:54:21 2015 -0400

    libata: Fall back to unqueued READ LOG EXT if the DMA variant fails
    
    Some devices advertise support for the READ/WRITE LOG DMA EXT commands
    but fail when we try to issue them. This can lead to queued TRIM being
    unintentionally disabled since the relevant feature flag is located in a
    general purpose log page.
    
    Fall back to unqueued READ LOG EXT if the DMA variant fails while
    reading a log page.
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 8dad4a307bb8..c3ef58014b33 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -424,6 +424,7 @@ enum {
 	ATA_HORKAGE_NOLPM	= (1 << 20),	/* don't use LPM */
 	ATA_HORKAGE_WD_BROKEN_LPM = (1 << 21),	/* some WDs have broken LPM */
 	ATA_HORKAGE_ZERO_AFTER_TRIM = (1 << 22),/* guarantees zero after trim */
+	ATA_HORKAGE_NO_NCQ_LOG	= (1 << 23),	/* don't use NCQ for log read */
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */

commit 09c5b4803a80a5451d950d6a539d2eb311dc0fb1
Author: Gabriele Mazzotta <gabriele.mzt@gmail.com>
Date:   Sat Apr 25 19:52:37 2015 +0200

    libata: Ignore spurious PHY event on LPM policy change
    
    When the LPM policy is set to ATA_LPM_MAX_POWER, the device might
    generate a spurious PHY event that cuases errors on the link.
    Ignore this event if it occured within 10s after the policy change.
    
    The timeout was chosen observing that on a Dell XPS13 9333 these
    spurious events can occur up to roughly 6s after the policy change.
    
    Link: http://lkml.kernel.org/g/3352987.ugV1Ipy7Z5@xps13
    Signed-off-by: Gabriele Mazzotta <gabriele.mzt@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6138d87277af..28aeae46f355 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -205,6 +205,7 @@ enum {
 	ATA_LFLAG_SW_ACTIVITY	= (1 << 7), /* keep activity stats */
 	ATA_LFLAG_NO_LPM	= (1 << 8), /* disable LPM on this link */
 	ATA_LFLAG_RST_ONCE	= (1 << 9), /* limit recovery to one reset */
+	ATA_LFLAG_CHANGED	= (1 << 10), /* LPM state changed on this link */
 
 	/* struct ata_port flags */
 	ATA_FLAG_SLAVE_POSS	= (1 << 0), /* host supports slave dev */
@@ -309,6 +310,12 @@ enum {
 	 */
 	ATA_TMOUT_PMP_SRST_WAIT	= 5000,
 
+	/* When the LPM policy is set to ATA_LPM_MAX_POWER, there might
+	 * be a spurious PHY event, so ignore the first PHY event that
+	 * occurs within 10s after the policy change.
+	 */
+	ATA_TMOUT_SPURIOUS_PHY	= 10000,
+
 	/* ATA bus states */
 	BUS_UNKNOWN		= 0,
 	BUS_DMA			= 1,
@@ -788,6 +795,8 @@ struct ata_link {
 	struct ata_eh_context	eh_context;
 
 	struct ata_device	device[ATA_MAX_DEVICES];
+
+	unsigned long		last_lpm_change; /* when last LPM change happened */
 };
 #define ATA_LINK_CLEAR_BEGIN		offsetof(struct ata_link, active_tag)
 #define ATA_LINK_CLEAR_END		offsetof(struct ata_link, device[0])

commit 8393b811f38acdf7fd8da2028708edad3e68ce1f
Author: Gabriele Mazzotta <gabriele.mzt@gmail.com>
Date:   Sat Apr 25 19:52:36 2015 +0200

    libata: Add helper to determine when PHY events should be ignored
    
    This is a preparation commit that will allow to add other criteria
    according to which PHY events should be dropped.
    
    Signed-off-by: Gabriele Mazzotta <gabriele.mzt@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 8dad4a307bb8..6138d87277af 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1201,6 +1201,7 @@ extern struct ata_device *ata_dev_pair(struct ata_device *adev);
 extern int ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
 extern void ata_scsi_port_error_handler(struct Scsi_Host *host, struct ata_port *ap);
 extern void ata_scsi_cmd_error_handler(struct Scsi_Host *host, struct ata_port *ap, struct list_head *eh_q);
+extern bool sata_lpm_ignore_phy_events(struct ata_link *link);
 
 extern int ata_cable_40wire(struct ata_port *ap);
 extern int ata_cable_80wire(struct ata_port *ap);

commit a1480a166dd509f25f90e824411cb488fa9fff7e
Merge: 45141eeafefd c54c719b558e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 13 16:42:16 2015 -0700

    Merge branch 'for-4.1' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata
    
    Pull libata updates from Tejun Heo:
    
     - Hannes's patchset implements support for better error reporting
       introduced by the new ATA command spec.
    
     - the deperecated pci_ dma API usages have been replaced by dma_ ones.
    
     - a bunch of hardware specific updates and some cleanups.
    
    * 'for-4.1' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata:
      ata: remove deprecated use of pci api
      ahci: st: st_configure_oob must be called after IP is clocked.
      ahci: st: Update the ahci_st DT documentation
      ahci: st: Update the DT example for how to obtain the PHY.
      sata_dwc_460ex: indent an if statement
      libata: Add tracepoints
      libata-eh: Set 'information' field for autosense
      libata: Implement support for sense data reporting
      libata: Implement NCQ autosense
      libata: use status bit definitions in ata_dump_status()
      ide,ata: Rename ATA_IDX to ATA_SENSE
      libata: whitespace fixes in ata_to_sense_error()
      libata: whitespace cleanup in ata_get_cmd_descript()
      libata: use READ_LOG_DMA_EXT
      libata: remove ATA_FLAG_LOWTAG
      sata_dwc_460ex: re-use hsdev->dev instead of dwc_dev
      sata_dwc_460ex: move to generic DMA driver
      sata_dwc_460ex: join messages back
      sata: xgene: add ACPI support for APM X-Gene SATA ports
      ata: sata_mv: add proper definitions for LP_PHY_CTL register values

commit 3a02824396c1df1db422d067b0fdcac724f44dd6
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Mar 24 14:14:18 2015 -0400

    libata: remove ATA_FLAG_LOWTAG
    
    sata_sil24 for some reason pukes when tags are allocated round-robin
    which helps tag ordered controllers.  To work around the issue,
    72dd299d5039 ("libata: allow sata_sil24 to opt-out of tag ordered
    submission") introduced ATA_FLAG_LOWTAG which tells libata tag
    allocation to do lowest-first.
    
    However, with the recent switch to blk-mq tag allocation, the liata
    tag allocation code path is no longer used and the workaround is now
    implemented in the block layer and selected by setting
    scsi_host_template->tag_alloc_policy to BLK_TAG_ALLOC_FIFO.  See
    9269e23496dd ("libata: make sata_sil24 use fifo tag allocator").
    
    This leaves ATA_FLAG_LOWTAG withoout any actual user.  Remove it.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Shaohua Li <shli@fb.com>
    Cc: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index fc03efa64ffe..ebe132a4873c 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -231,7 +231,6 @@ enum {
 	ATA_FLAG_SW_ACTIVITY	= (1 << 22), /* driver supports sw activity
 					      * led */
 	ATA_FLAG_NO_DIPM	= (1 << 23), /* host not happy with DIPM */
-	ATA_FLAG_LOWTAG		= (1 << 24), /* host wants lowest available tag */
 
 	/* bits 24:31 of ap->flags are reserved for LLD specific flags */
 

commit 5067c0469c643512f24786990e315f9c15cc7d24
Author: Shaohua Li <shli@fb.com>
Date:   Thu Mar 12 10:32:18 2015 -0700

    ata: Add a new flag to destinguish sas controller
    
    SAS controller has its own tag allocation, which doesn't directly match to ATA
    tag, so SAS and SATA have different code path for ata tags. Originally we use
    port->scsi_host (98bd4be1) to destinguish SAS controller, but libsas set
    ->scsi_host too, so we can't use it for the destinguish, we add a new flag for
    this purpose.
    
    Without this patch, the following oops can happen because scsi-mq uses
    a host-wide tag map shared among all devices with some integer tag
    values >= ATA_MAX_QUEUE.  These unexpectedly high tag values cause
    __ata_qc_from_tag() to return NULL, which is then dereferenced in
    ata_qc_new_init().
    
      BUG: unable to handle kernel NULL pointer dereference at 0000000000000058
      IP: [<ffffffff804fd46e>] ata_qc_new_init+0x3e/0x120
      PGD 32adf0067 PUD 32adf1067 PMD 0
      Oops: 0002 [#1] SMP DEBUG_PAGEALLOC
      Modules linked in: iscsi_tcp libiscsi_tcp libiscsi scsi_transport_iscsi igb
      i2c_algo_bit ptp pps_core pm80xx libsas scsi_transport_sas sg coretemp
      eeprom w83795 i2c_i801
      CPU: 4 PID: 1450 Comm: cydiskbench Not tainted 4.0.0-rc3 #1
      Hardware name: Supermicro X8DTH-i/6/iF/6F/X8DTH, BIOS 2.1b       05/04/12
      task: ffff8800ba86d500 ti: ffff88032a064000 task.ti: ffff88032a064000
      RIP: 0010:[<ffffffff804fd46e>]  [<ffffffff804fd46e>] ata_qc_new_init+0x3e/0x120
      RSP: 0018:ffff88032a067858  EFLAGS: 00010046
      RAX: 0000000000000000 RBX: ffff8800ba0d2230 RCX: 000000000000002a
      RDX: ffffffff80505ae0 RSI: 0000000000000020 RDI: ffff8800ba0d2230
      RBP: ffff88032a067868 R08: 0000000000000201 R09: 0000000000000001
      R10: 0000000000000000 R11: 0000000000000000 R12: ffff8800ba0d0000
      R13: ffff8800ba0d2230 R14: ffffffff80505ae0 R15: ffff8800ba0d0000
      FS:  0000000041223950(0063) GS:ffff88033e480000(0000) knlGS:0000000000000000
      CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
      CR2: 0000000000000058 CR3: 000000032a0a3000 CR4: 00000000000006e0
      Stack:
       ffff880329eee758 ffff880329eee758 ffff88032a0678a8 ffffffff80502dad
       ffff8800ba167978 ffff880329eee758 ffff88032bf9c520 ffff8800ba167978
       ffff88032bf9c520 ffff88032bf9a290 ffff88032a0678b8 ffffffff80506909
      Call Trace:
       [<ffffffff80502dad>] ata_scsi_translate+0x3d/0x1b0
       [<ffffffff80506909>] ata_sas_queuecmd+0x149/0x2a0
       [<ffffffffa0046650>] sas_queuecommand+0xa0/0x1f0 [libsas]
       [<ffffffff804ea544>] scsi_dispatch_cmd+0xd4/0x1a0
       [<ffffffff804eb50f>] scsi_queue_rq+0x66f/0x7f0
       [<ffffffff803e5098>] __blk_mq_run_hw_queue+0x208/0x3f0
       [<ffffffff803e54b8>] blk_mq_run_hw_queue+0x88/0xc0
       [<ffffffff803e5c74>] blk_mq_insert_request+0xc4/0x130
       [<ffffffff803e0b63>] blk_execute_rq_nowait+0x73/0x160
       [<ffffffffa0023fca>] sg_common_write+0x3da/0x720 [sg]
       [<ffffffffa0025100>] sg_new_write+0x250/0x360 [sg]
       [<ffffffffa0025feb>] sg_write+0x13b/0x450 [sg]
       [<ffffffff8032ec91>] vfs_write+0xd1/0x1b0
       [<ffffffff8032ee54>] SyS_write+0x54/0xc0
       [<ffffffff80689932>] system_call_fastpath+0x12/0x17
    
    tj: updated description.
    
    Fixes: 12cb5ce101ab ("libata: use blk taging")
    Reported-and-tested-by: Tony Battersby <tonyb@cybernetics.com>
    Signed-off-by: Shaohua Li <shli@fb.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index fc03efa64ffe..6b08cc106c21 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -232,6 +232,7 @@ enum {
 					      * led */
 	ATA_FLAG_NO_DIPM	= (1 << 23), /* host not happy with DIPM */
 	ATA_FLAG_LOWTAG		= (1 << 24), /* host wants lowest available tag */
+	ATA_FLAG_SAS_HOST	= (1 << 25), /* SAS host */
 
 	/* bits 24:31 of ap->flags are reserved for LLD specific flags */
 

commit 8494bcf5b7c4b2416687e233dd34d4c6b6fe5653
Merge: 3e12cefbe143 b042a3ca9490
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 12 14:30:53 2015 -0800

    Merge branch 'for-3.20/drivers' of git://git.kernel.dk/linux-block
    
    Pull block driver changes from Jens Axboe:
     "This contains:
    
       - The 4k/partition fixes for brd from Boaz/Matthew.
    
       - A few xen front/back block fixes from David Vrabel and Roger Pau
         Monne.
    
       - Floppy changes from Takashi, cleaning the device file creation.
    
       - Switching libata to use the new blk-mq tagging policy, removing
         code (and a suboptimal implementation) from libata.  This will
         throw you a merge conflict, since a bug in the original libata
         tagging code was fixed since this code was branched.  Trivial.
         From Shaohua.
    
       - Conversion of loop to blk-mq, from Ming Lei.
    
       - Cleanup of the io_schedule() handling in bsg from Peter Zijlstra.
         He claims it improves on unreadable code, which will cost him a
         beer.
    
       - Maintainer update or NDB, now handled by Markus Pargmann.
    
       - NVMe:
            - Optimization from me that avoids a kmalloc/kfree per IO for
              smaller (<= 8KB) IO. This cuts about 1% of high IOPS CPU
              overhead.
            - Removal of (now) dead RCU code, a relic from before NVMe was
              converted to blk-mq"
    
    * 'for-3.20/drivers' of git://git.kernel.dk/linux-block:
      xen-blkback: default to X86_32 ABI on x86
      xen-blkfront: fix accounting of reqs when migrating
      xen-blkback,xen-blkfront: add myself as maintainer
      block: Simplify bsg complete all
      floppy: Avoid manual call of device_create_file()
      NVMe: avoid kmalloc/kfree for smaller IO
      MAINTAINERS: Update NBD maintainer
      libata: make sata_sil24 use fifo tag allocator
      libata: move sas ata tag allocation to libata-scsi.c
      libata: use blk taging
      NVMe: within nvme_free_queues(), delete RCU sychro/deferred free
      null_blk: suppress invalid partition info
      brd: Request from fdisk 4k alignment
      brd: Fix all partitions BUGs
      axonram: Fix bug in direct_access
      loop: add blk-mq.h include
      block: loop: don't handle REQ_FUA explicitly
      block: loop: introduce lo_discard() and lo_req_flush()
      block: loop: say goodby to bio
      block: loop: improve performance via blk-mq

commit b12aa1f25e1da7e23fa44f646ac46e41366cfc6c
Merge: f627cfdeb7d0 09c32aaa3683
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 9 07:54:41 2015 -0500

    Merge branch 'for-3.19-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata into for-3.20
    
    09c32aaa3683 ("ahci_xgene: Fix the dma state machine lockup for the
    ATA_CMD_SMART PIO mode command.") missed 3.19 release.  Fold it into
    for-3.20.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>

commit 018d5ef2048fcab339467bcbebccf588c9bd2531
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Thu Jan 29 08:30:29 2015 +0900

    ata: ahci_platform: fix owner module reference mismatch for scsi host
    
    The owner module reference of the ahci platform's scsi_host is
    initialized to libahci_platform's one, because these drivers use a
    scsi_host_template defined in libahci_platform.  So these drivers can
    be unloaded even if the scsi device is being accessed.
    
    This fixes it by pushing the scsi_host_template from libahci_platform
    to all leaf drivers.  The scsi_host_template is passed through a new
    argument of ahci_platform_init_host().
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
    Cc: linux-ide@vger.kernel.org
    Cc: linux-scsi@vger.kernel.org

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 2d182413b1db..11beb4196c32 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1338,6 +1338,12 @@ extern const struct ata_port_operations ata_base_port_ops;
 extern const struct ata_port_operations sata_port_ops;
 extern struct device_attribute *ata_common_sdev_attrs[];
 
+/*
+ * All sht initializers (BASE, PIO, BMDMA, NCQ) must be instantiated
+ * by the edge drivers.  Because the 'module' field of sht must be the
+ * edge driver's module reference, otherwise the driver can be unloaded
+ * even if the scsi_device is being accessed.
+ */
 #define ATA_BASE_SHT(drv_name)					\
 	.module			= THIS_MODULE,			\
 	.name			= drv_name,			\

commit 12cb5ce101abfaf74421f8cc9f196e708209eb79
Author: Shaohua Li <shli@fb.com>
Date:   Thu Jan 15 17:32:27 2015 -0800

    libata: use blk taging
    
    libata uses its own tag management which is duplication and the
    implementation is poor. And if we switch to blk-mq, tag is build-in.
    It's time to switch to generic taging.
    
    The SAS driver has its own tag management, and looks we can't directly
    map the host controler tag to SATA tag. So I just bypassed the SAS case.
    
    I changed the code/variable name for the tag management of libata to
    make it self contained. Only sas will use it. Later if libsas implements
    its tag management, the tag management code in libata can be deleted
    easily.
    
    Cc: Jens Axboe <axboe@fb.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Shaohua Li <shli@fb.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 2d182413b1db..f23454762717 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -821,10 +821,10 @@ struct ata_port {
 	unsigned int		cbl;	/* cable type; ATA_CBL_xxx */
 
 	struct ata_queued_cmd	qcmd[ATA_MAX_QUEUE];
-	unsigned long		qc_allocated;
+	unsigned long		sas_tag_allocated; /* for sas tag allocation only */
 	unsigned int		qc_active;
 	int			nr_active_links; /* #links with active qcs */
-	unsigned int		last_tag;	/* track next tag hw expects */
+	unsigned int		sas_last_tag;	/* track next tag hw expects */
 
 	struct ata_link		link;		/* host default link */
 	struct ata_link		*slave_link;	/* see ata_slave_link_init() */
@@ -1344,6 +1344,7 @@ extern struct device_attribute *ata_common_sdev_attrs[];
 	.ioctl			= ata_scsi_ioctl,		\
 	.queuecommand		= ata_scsi_queuecmd,		\
 	.can_queue		= ATA_DEF_QUEUE,		\
+	.tag_alloc_policy	= BLK_TAG_ALLOC_RR,		\
 	.this_id		= ATA_SHT_THIS_ID,		\
 	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,		\
 	.emulated		= ATA_SHT_EMULATED,		\

commit 72dd299d5039a336493993dcc63413cf31d0e662
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jan 16 15:13:02 2015 -0800

    libata: allow sata_sil24 to opt-out of tag ordered submission
    
    Ronny reports: https://bugzilla.kernel.org/show_bug.cgi?id=87101
        "Since commit 8a4aeec8d "libata/ahci: accommodate tag ordered
        controllers" the access to the harddisk on the first SATA-port is
        failing on its first access. The access to the harddisk on the
        second port is working normal.
    
        When reverting the above commit, access to both harddisks is working
        fine again."
    
    Maintain tag ordered submission as the default, but allow sata_sil24 to
    continue with the old behavior.
    
    Cc: <stable@vger.kernel.org>
    Cc: Tejun Heo <tj@kernel.org>
    Reported-by: Ronny Hegewald <Ronny.Hegewald@online.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index f2b440e44fd7..91f705de2c0b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -231,6 +231,7 @@ enum {
 	ATA_FLAG_SW_ACTIVITY	= (1 << 22), /* driver supports sw activity
 					      * led */
 	ATA_FLAG_NO_DIPM	= (1 << 23), /* host not happy with DIPM */
+	ATA_FLAG_LOWTAG		= (1 << 24), /* host wants lowest available tag */
 
 	/* bits 24:31 of ap->flags are reserved for LLD specific flags */
 

commit e61f7d1c3c07a7e51036b0796749edb00deff845
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Thu Jan 8 10:34:27 2015 -0500

    libata: Whitelist SSDs that are known to properly return zeroes after TRIM
    
    As defined, the DRAT (Deterministic Read After Trim) and RZAT (Return
    Zero After Trim) flags in the ATA Command Set are unreliable in the
    sense that they only define what happens if the device successfully
    executed the DSM TRIM command. TRIM is only advisory, however, and the
    device is free to silently ignore all or parts of the request.
    
    In practice this renders the DRAT and RZAT flags completely useless and
    because the results are unpredictable we decided to disable discard in
    MD for 3.18 to avoid the risk of data corruption.
    
    Hardware vendors in the real world obviously need better guarantees than
    what the standards bodies provide. Unfortuntely those guarantees are
    encoded in product requirements documents rather than somewhere we can
    key off of them programatically. So we are compelled to disabling
    discard_zeroes_data for all devices unless we explicitly have data to
    support whitelisting them.
    
    This patch whitelists SSDs from a few of the main vendors. None of the
    whitelists are based on written guarantees. They are purely based on
    empirical evidence collected from internal and external users that have
    tested or qualified these drives in RAID deployments.
    
    The whitelist is only meant as a starting point and is by no means
    comprehensive:
    
       - All intel SSD models except for 510
       - Micron M5?0/M600
       - Samsung SSDs
       - Seagate SSDs
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 2d182413b1db..f2b440e44fd7 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -422,6 +422,7 @@ enum {
 	ATA_HORKAGE_NO_NCQ_TRIM	= (1 << 19),	/* don't use queued TRIM */
 	ATA_HORKAGE_NOLPM	= (1 << 20),	/* don't use LPM */
 	ATA_HORKAGE_WD_BROKEN_LPM = (1 << 21),	/* some WDs have broken LPM */
+	ATA_HORKAGE_ZERO_AFTER_TRIM = (1 << 22),/* guarantees zero after trim */
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */

commit 4e8790f77f051d4cc745a57b48a73052521e8dfc
Merge: 0a27044c83fe 2ba520f0cd65
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 11 18:52:37 2014 -0800

    Merge branch 'for-3.19' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata
    
    Pull libata changes from Tejun Heo:
     "The only interesting piece is the support for shingled drives.  The
      changes in libata layer are minimal.  All it does is identifying the
      new class of device and report upwards accordingly"
    
    * 'for-3.19' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata:
      libata: Remove FIXME comment in atapi_request_sense()
      sata_rcar: Document deprecated "renesas,rcar-sata"
      sata_rcar: Add clocks to sata_rcar bindings
      ahci_sunxi: Make AHCI_HFLAG_NO_PMP flag configurable with a module option
      libata-scsi: Update SATL for ZAC drives
      libata: Implement ATA_DEV_ZAC
      libsas: use ata_dev_classify()

commit db5ed4dfd5dd0142ec36ff7b335e0ec3b836b3e6
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Nov 13 15:08:42 2014 +0100

    scsi: drop reason argument from ->change_queue_depth
    
    Drop the now unused reason argument from the ->change_queue_depth method.
    Also add a return value to scsi_adjust_queue_depth, and rename it to
    scsi_change_queue_depth now that it can be used as the default
    ->change_queue_depth implementation.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index bd5fefeaf548..bfbc817c34ee 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1191,9 +1191,9 @@ extern void ata_scsi_unlock_native_capacity(struct scsi_device *sdev);
 extern int ata_scsi_slave_config(struct scsi_device *sdev);
 extern void ata_scsi_slave_destroy(struct scsi_device *sdev);
 extern int ata_scsi_change_queue_depth(struct scsi_device *sdev,
-				       int queue_depth, int reason);
+				       int queue_depth);
 extern int __ata_change_queue_depth(struct ata_port *ap, struct scsi_device *sdev,
-				    int queue_depth, int reason);
+				    int queue_depth);
 extern struct ata_device *ata_dev_pair(struct ata_device *adev);
 extern int ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
 extern void ata_scsi_port_error_handler(struct Scsi_Host *host, struct ata_port *ap);

commit 9162c6579bf90b3f5ddb7e3a6c6fa946c1b4cbeb
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Nov 5 13:08:21 2014 +0100

    libata: Implement ATA_DEV_ZAC
    
    Add new ATA device type for ZAC devices.
    
    Acked-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index bd5fefeaf548..a26daea7f5eb 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -191,7 +191,8 @@ enum {
 	ATA_DEV_PMP_UNSUP	= 6,	/* SATA port multiplier (unsupported) */
 	ATA_DEV_SEMB		= 7,	/* SEMB */
 	ATA_DEV_SEMB_UNSUP	= 8,	/* SEMB (unsupported) */
-	ATA_DEV_NONE		= 9,	/* no device */
+	ATA_DEV_ZAC		= 9,	/* ZAC device */
+	ATA_DEV_NONE		= 10,	/* no device */
 
 	/* struct ata_link flags */
 	ATA_LFLAG_NO_HRST	= (1 << 1), /* avoid hardreset */
@@ -1491,7 +1492,8 @@ static inline unsigned int ata_tag_internal(unsigned int tag)
 static inline unsigned int ata_class_enabled(unsigned int class)
 {
 	return class == ATA_DEV_ATA || class == ATA_DEV_ATAPI ||
-		class == ATA_DEV_PMP || class == ATA_DEV_SEMB;
+		class == ATA_DEV_PMP || class == ATA_DEV_SEMB ||
+		class == ATA_DEV_ZAC;
 }
 
 static inline unsigned int ata_class_disabled(unsigned int class)

commit d7bead1b8890c3e47a24db270fdb840ea728d8f0
Author: Joe Perches <joe@perches.com>
Date:   Mon Sep 22 09:52:18 2014 -0700

    libata: change ata_<foo>_printk routines to return void
    
    The return value is not used by callers of these functions nor
    by uses of all macros so change the functions to return void.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 92abb497ab14..bd5fefeaf548 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1404,14 +1404,14 @@ static inline int sata_srst_pmp(struct ata_link *link)
  * printk helpers
  */
 __printf(3, 4)
-int ata_port_printk(const struct ata_port *ap, const char *level,
-		    const char *fmt, ...);
+void ata_port_printk(const struct ata_port *ap, const char *level,
+		     const char *fmt, ...);
 __printf(3, 4)
-int ata_link_printk(const struct ata_link *link, const char *level,
-		    const char *fmt, ...);
+void ata_link_printk(const struct ata_link *link, const char *level,
+		     const char *fmt, ...);
 __printf(3, 4)
-int ata_dev_printk(const struct ata_device *dev, const char *level,
-		   const char *fmt, ...);
+void ata_dev_printk(const struct ata_device *dev, const char *level,
+		    const char *fmt, ...);
 
 #define ata_port_err(ap, fmt, ...)				\
 	ata_port_printk(ap, KERN_ERR, fmt, ##__VA_ARGS__)

commit 1a112d10f03e83fb3a2fdc4c9165865dec8a3ca6
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Jul 23 09:05:27 2014 -0400

    libata: introduce ata_host->n_tags to avoid oops on SAS controllers
    
    1871ee134b73 ("libata: support the ata host which implements a queue
    depth less than 32") directly used ata_port->scsi_host->can_queue from
    ata_qc_new() to determine the number of tags supported by the host;
    unfortunately, SAS controllers doing SATA don't initialize ->scsi_host
    leading to the following oops.
    
     BUG: unable to handle kernel NULL pointer dereference at 0000000000000058
     IP: [<ffffffff814e0618>] ata_qc_new_init+0x188/0x1b0
     PGD 0
     Oops: 0002 [#1] SMP
     Modules linked in: isci libsas scsi_transport_sas mgag200 drm_kms_helper ttm
     CPU: 1 PID: 518 Comm: udevd Not tainted 3.16.0-rc6+ #62
     Hardware name: Intel Corporation S2600CO/S2600CO, BIOS SE5C600.86B.02.02.0002.122320131210 12/23/2013
     task: ffff880c1a00b280 ti: ffff88061a000000 task.ti: ffff88061a000000
     RIP: 0010:[<ffffffff814e0618>]  [<ffffffff814e0618>] ata_qc_new_init+0x188/0x1b0
     RSP: 0018:ffff88061a003ae8  EFLAGS: 00010012
     RAX: 0000000000000001 RBX: ffff88000241ca80 RCX: 00000000000000fa
     RDX: 0000000000000020 RSI: 0000000000000020 RDI: ffff8806194aa298
     RBP: ffff88061a003ae8 R08: ffff8806194a8000 R09: 0000000000000000
     R10: 0000000000000000 R11: ffff88000241ca80 R12: ffff88061ad58200
     R13: ffff8806194aa298 R14: ffffffff814e67a0 R15: ffff8806194a8000
     FS:  00007f3ad7fe3840(0000) GS:ffff880627620000(0000) knlGS:0000000000000000
     CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
     CR2: 0000000000000058 CR3: 000000061a118000 CR4: 00000000001407e0
     Stack:
      ffff88061a003b20 ffffffff814e96e1 ffff88000241ca80 ffff88061ad58200
      ffff8800b6bf6000 ffff880c1c988000 ffff880619903850 ffff88061a003b68
      ffffffffa0056ce1 ffff88061a003b48 0000000013d6e6f8 ffff88000241ca80
     Call Trace:
      [<ffffffff814e96e1>] ata_sas_queuecmd+0xa1/0x430
      [<ffffffffa0056ce1>] sas_queuecommand+0x191/0x220 [libsas]
      [<ffffffff8149afee>] scsi_dispatch_cmd+0x10e/0x300
      [<ffffffff814a3bc5>] scsi_request_fn+0x2f5/0x550
      [<ffffffff81317613>] __blk_run_queue+0x33/0x40
      [<ffffffff8131781a>] queue_unplugged+0x2a/0x90
      [<ffffffff8131ceb4>] blk_flush_plug_list+0x1b4/0x210
      [<ffffffff8131d274>] blk_finish_plug+0x14/0x50
      [<ffffffff8117eaa8>] __do_page_cache_readahead+0x198/0x1f0
      [<ffffffff8117ee21>] force_page_cache_readahead+0x31/0x50
      [<ffffffff8117ee7e>] page_cache_sync_readahead+0x3e/0x50
      [<ffffffff81172ac6>] generic_file_read_iter+0x496/0x5a0
      [<ffffffff81219897>] blkdev_read_iter+0x37/0x40
      [<ffffffff811e307e>] new_sync_read+0x7e/0xb0
      [<ffffffff811e3734>] vfs_read+0x94/0x170
      [<ffffffff811e43c6>] SyS_read+0x46/0xb0
      [<ffffffff811e33d1>] ? SyS_lseek+0x91/0xb0
      [<ffffffff8171ee29>] system_call_fastpath+0x16/0x1b
     Code: 00 00 00 88 50 29 83 7f 08 01 19 d2 83 e2 f0 83 ea 50 88 50 34 c6 81 1d 02 00 00 40 c6 81 17 02 00 00 00 5d c3 66 0f 1f 44 00 00 <89> 14 25 58 00 00 00
    
    Fix it by introducing ata_host->n_tags which is initialized to
    ATA_MAX_QUEUE - 1 in ata_host_init() for SAS controllers and set to
    scsi_host_template->can_queue in ata_host_register() for !SAS ones.
    As SAS hosts are never registered, this will give them the same
    ATA_MAX_QUEUE - 1 as before.  Note that we can't use
    scsi_host->can_queue directly for SAS hosts anyway as they can go
    higher than the libata maximum.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Mike Qiu <qiudayu@linux.vnet.ibm.com>
    Reported-by: Jesse Brandeburg <jesse.brandeburg@gmail.com>
    Reported-by: Peter Hurley <peter@hurleysoftware.com>
    Reported-by: Peter Zijlstra <peterz@infradead.org>
    Tested-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Fixes: 1871ee134b73 ("libata: support the ata host which implements a queue depth less than 32")
    Cc: Kevin Hao <haokexin@gmail.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: stable@vger.kernel.org

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 5ab4e3a76721..92abb497ab14 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -593,6 +593,7 @@ struct ata_host {
 	struct device 		*dev;
 	void __iomem * const	*iomap;
 	unsigned int		n_ports;
+	unsigned int		n_tags;			/* nr of NCQ tags */
 	void			*private_data;
 	struct ata_port_operations *ops;
 	unsigned long		flags;

commit 8a4aeec8d2d6a3edeffbdfae451cdf05cbf0fefd
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Apr 17 11:48:21 2014 -0700

    libata/ahci: accommodate tag ordered controllers
    
    The AHCI spec allows implementations to issue commands in tag order
    rather than FIFO order:
    
            5.3.2.12 P:SelectCmd
            HBA sets pSlotLoc = (pSlotLoc + 1) mod (CAP.NCS + 1)
            or HBA selects the command to issue that has had the
            PxCI bit set to '1' longer than any other command
            pending to be issued.
    
    The result is that commands posted sequentially (time-wise) may play out
    of sequence when issued by hardware.
    
    This behavior has likely been hidden by drives that arrange for commands
    to complete in issue order.  However, it appears recent drives (two from
    different vendors that we have found so far) inflict out-of-order
    completions as a matter of course.  So, we need to take care to maintain
    ordered submission, otherwise we risk triggering a drive to fall out of
    sequential-io automation and back to random-io processing, which incurs
    large latency and degrades throughput.
    
    This issue was found in simple benchmarks where QD=2 seq-write
    performance was 30-50% *greater* than QD=32 seq-write performance.
    
    Tagging for -stable and making the change globally since it has a low
    risk-to-reward ratio.  Also, word is that recent versions of an unnamed
    OS also does it this way now.  So, drives in the field are already
    experienced with this tag ordering scheme.
    
    Cc: <stable@vger.kernel.org>
    Cc: Dave Jiang <dave.jiang@intel.com>
    Cc: Ed Ciechanowski <ed.ciechanowski@intel.com>
    Reviewed-by: Matthew Wilcox <matthew.r.wilcox@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 1de36be64df4..5ab4e3a76721 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -822,6 +822,7 @@ struct ata_port {
 	unsigned long		qc_allocated;
 	unsigned int		qc_active;
 	int			nr_active_links; /* #links with active qcs */
+	unsigned int		last_tag;	/* track next tag hw expects */
 
 	struct ata_link		link;		/* host default link */
 	struct ata_link		*slave_link;	/* see ata_slave_link_init() */

commit 0dd5d6f0e8763ff09939adf3e5b1465a3a414fea
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Mar 19 11:14:15 2014 -0700

    libata: remove unused ata_sas_port_async_resume() stub
    
    Commit bc6e7c4b0d1a "libata, libsas: kill pm_result and related cleanup"
    renamed ata_sas_port_async_resume() to ata_sas_port_resume(), but missed
    a CONFIG_PM=n stub conversion.  Randy fixed that up in commit
    a5a6569959fc "libata.h: add stub for ata_sas_port_resume", but missed
    the deletion of the now unused ata_sas_port_async_resume() routine.
    
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 52723789b991..1de36be64df4 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1145,9 +1145,6 @@ extern void ata_sas_port_resume(struct ata_port *ap);
 static inline void ata_sas_port_suspend(struct ata_port *ap)
 {
 }
-static inline void ata_sas_port_async_resume(struct ata_port *ap)
-{
-}
 static inline void ata_sas_port_resume(struct ata_port *ap)
 {
 }

commit a5a6569959fc55d4ebf1526f7855003596946c32
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Wed Mar 19 10:46:25 2014 -0700

    libata.h: add stub for ata_sas_port_resume
    
    Fix build error when CONFIG_PM is not enabled by adding a stub
    function in <linux/libata.h>.
    
    drivers/scsi/libsas/sas_ata.c: In function 'sas_resume_sata':
    drivers/scsi/libsas/sas_ata.c:756:3: error: implicit declaration of function 'ata_sas_port_resume' [-Werror=implicit-function-declaration]
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Reported-by: Jim Davis <jim.epost@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 5c09e86982c9..52723789b991 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1148,6 +1148,9 @@ static inline void ata_sas_port_suspend(struct ata_port *ap)
 static inline void ata_sas_port_async_resume(struct ata_port *ap)
 {
 }
+static inline void ata_sas_port_resume(struct ata_port *ap)
+{
+}
 #endif
 extern int ata_ratelimit(void);
 extern void ata_msleep(struct ata_port *ap, unsigned int msecs);

commit bc6e7c4b0d1a1f742d96556f63d68f17f4e232c3
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Mar 14 13:52:48 2014 -0700

    libata, libsas: kill pm_result and related cleanup
    
    Tejun says:
      "At least for libata, worrying about suspend/resume failures don't make
       whole lot of sense.  If suspend failed, just proceed with suspend.  If
       the device can't be woken up afterwards, that's that.  There isn't
       anything we could have done differently anyway.  The same for resume, if
       spinup fails, the device is dud and the following commands will invoke
       EH actions and will eventually fail.  Again, there really isn't any
       *choice* to make.  Just making sure the errors are handled gracefully
       (ie. don't crash) and the following commands are handled correctly
       should be enough."
    
    The only libata user that actually cares about the result from a suspend
    operation is libsas.  However, it only cares about whether queuing a new
    operation collides with an in-flight one.  All libsas does with the
    error is retry, but we can just let libata wait for the previous
    operation before continuing.
    
    Other cleanups include:
    1/ Unifying all ata port pm operations on an ata_port_pm_ prefix
    2/ Marking all ata port pm helper routines as returning void, only
       ata_port_pm_ entry points need to fake a 0 return value.
    3/ Killing ata_port_{suspend|resume}_common() in favor of calling
       ata_port_request_pm() directly
    4/ Killing the wrappers that just do a to_ata_port() conversion
    5/ Clearly marking the entry points that do async operations with an
      _async suffix.
    
    Reference: http://marc.info/?l=linux-scsi&m=138995409532286&w=2
    
    Cc: Phillip Susi <psusi@ubuntu.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Suggested-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Todd Brandt <todd.e.brandt@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index bec6dbe939a0..5c09e86982c9 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -848,7 +848,6 @@ struct ata_port {
 	struct completion	park_req_pending;
 
 	pm_message_t		pm_mesg;
-	int			*pm_result;
 	enum ata_lpm_policy	target_lpm_policy;
 
 	struct timer_list	fastdrain_timer;
@@ -1140,16 +1139,14 @@ extern bool ata_link_offline(struct ata_link *link);
 #ifdef CONFIG_PM
 extern int ata_host_suspend(struct ata_host *host, pm_message_t mesg);
 extern void ata_host_resume(struct ata_host *host);
-extern int ata_sas_port_async_suspend(struct ata_port *ap, int *async);
-extern int ata_sas_port_async_resume(struct ata_port *ap, int *async);
+extern void ata_sas_port_suspend(struct ata_port *ap);
+extern void ata_sas_port_resume(struct ata_port *ap);
 #else
-static inline int ata_sas_port_async_suspend(struct ata_port *ap, int *async)
+static inline void ata_sas_port_suspend(struct ata_port *ap)
 {
-	return 0;
 }
-static inline int ata_sas_port_async_resume(struct ata_port *ap, int *async)
+static inline void ata_sas_port_async_resume(struct ata_port *ap)
 {
-	return 0;
 }
 #endif
 extern int ata_ratelimit(void);

commit ecd75ad514d73efc1bbcc5f10a13566c3ace5f53
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Jan 16 09:47:17 2014 -0500

    libata: disable LPM for some WD SATA-I devices
    
    For some reason, some early WD drives spin up and down drives
    erratically when the link is put into slumber mode which can reduce
    the life expectancy of the device significantly.  Unfortunately, we
    don't have full list of devices and given the nature of the issue it'd
    be better to err on the side of false positives than the other way
    around.  Let's disable LPM on all WD devices which match one of the
    known problematic model prefixes and are SATA-I.
    
    As horkage list doesn't support matching SATA capabilities, this is
    implemented as two horkages - WD_BROKEN_LPM and NOLPM.  The former is
    set for the known prefixes and sets the latter if the matched device
    is SATA-I.
    
    Note that this isn't optimal as this disables all LPM operations and
    partial link power state reportedly works fine on these; however, the
    way LPM is implemented in libata makes it difficult to precisely map
    libata LPM setting to specific link power state.  Well, these devices
    are already fairly outdated.  Let's just disable whole LPM for now.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-and-tested-by: Nikos Barkas <levelwol@gmail.com>
    Reported-and-tested-by: Ioannis Barkas <risc4all@yahoo.com>
    References: https://bugzilla.kernel.org/show_bug.cgi?id=57211
    Cc: stable@vger.kernel.org

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 9b503376738f..bec6dbe939a0 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -419,6 +419,8 @@ enum {
 	ATA_HORKAGE_MAX_SEC_LBA48 = (1 << 17),	/* Set max sects to 65535 */
 	ATA_HORKAGE_ATAPI_DMADIR = (1 << 18),	/* device requires dmadir */
 	ATA_HORKAGE_NO_NCQ_TRIM	= (1 << 19),	/* don't use queued TRIM */
+	ATA_HORKAGE_NOLPM	= (1 << 20),	/* don't use LPM */
+	ATA_HORKAGE_WD_BROKEN_LPM = (1 << 21),	/* some WDs have broken LPM */
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */

commit f78dea064c5f7de07de4912a6e5136dbc443d614
Author: Marc Carino <marc.ceeeee@gmail.com>
Date:   Mon Dec 16 18:15:53 2013 -0800

    libata: implement ATA_HORKAGE_NO_NCQ_TRIM and apply it to Micro M500 SSDs
    
    Certain drives cannot handle queued TRIM commands properly, even
    though support is indicated in the IDENTIFY DEVICE buffer.  This patch
    allows for disabling the commands for the affected drives and apply it
    to the Micron/Crucial M500 SSDs which exhibit incorrect protocol
    behavior when issued queued TRIM commands, which could lead to silent
    data corruption.
    
    tj: Merged two unnecessarily split patches and made minor edits
        including shortening horkage name.
    
    Signed-off-by: Marc Carino <marc.ceeeee@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Link: http://lkml.kernel.org/g/1387246554-7311-1-git-send-email-marc.ceeeee@gmail.com
    Cc: stable@vger.kernel.org # 3.12+

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 0e23c26485f4..9b503376738f 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -418,6 +418,7 @@ enum {
 	ATA_HORKAGE_DUMP_ID	= (1 << 16),	/* dump IDENTIFY data */
 	ATA_HORKAGE_MAX_SEC_LBA48 = (1 << 17),	/* Set max sects to 65535 */
 	ATA_HORKAGE_ATAPI_DMADIR = (1 << 18),	/* device requires dmadir */
+	ATA_HORKAGE_NO_NCQ_TRIM	= (1 << 19),	/* don't use queued TRIM */
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */

commit 87fb6c31b9ef9ccab9a822b01fc3911f026a29bb
Author: Marc Carino <marc.ceeeee@gmail.com>
Date:   Sat Aug 24 23:22:51 2013 -0700

    libata: Add support for queued DSM TRIM
    
    Some new SSDs support the queued version of the DSM TRIM command.
    Let the driver use the new command if supported.
    
    Signed-off-by: Marc Carino <marc.ceeeee@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a988c2d7d0e8..0e23c26485f4 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1606,6 +1606,13 @@ static inline int ata_ncq_enabled(struct ata_device *dev)
 			      ATA_DFLAG_NCQ)) == ATA_DFLAG_NCQ;
 }
 
+static inline bool ata_fpdma_dsm_supported(struct ata_device *dev)
+{
+	return (dev->flags & ATA_DFLAG_NCQ_SEND_RECV) &&
+		(dev->ncq_send_recv_cmds[ATA_LOG_NCQ_SEND_RECV_DSM_OFFSET] &
+		 ATA_LOG_NCQ_SEND_RECV_DSM_TRIM);
+}
+
 static inline void ata_qc_set_polling(struct ata_queued_cmd *qc)
 {
 	qc->tf.ctl |= ATA_NIEN;

commit ed36911c747c18525691c0aa0fbe6b918c8eac19
Author: Marc Carino <marc.ceeeee@gmail.com>
Date:   Sat Aug 24 23:22:50 2013 -0700

    libata: Add support for SEND/RECEIVE FPDMA QUEUED
    
    Add support for the following ATA opcodes, which are present
    in SATA 3.1 and T13 ATA ACS-3:
    
            SEND FPDMA QUEUED
            RECEIVE FPDMA QUEUED
    
    Signed-off-by: Marc Carino <marc.ceeeee@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 578f98c3ff57..a988c2d7d0e8 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -172,6 +172,7 @@ enum {
 	ATA_DFLAG_DUBIOUS_XFER	= (1 << 16), /* data transfer not verified */
 	ATA_DFLAG_NO_UNLOAD	= (1 << 17), /* device doesn't support unload */
 	ATA_DFLAG_UNLOCK_HPA	= (1 << 18), /* unlock HPA */
+	ATA_DFLAG_NCQ_SEND_RECV = (1 << 19), /* device supports NCQ SEND and RECV */
 	ATA_DFLAG_INIT_MASK	= (1 << 24) - 1,
 
 	ATA_DFLAG_DETACH	= (1 << 24),
@@ -704,6 +705,9 @@ struct ata_device {
 	/* DEVSLP Timing Variables from Identify Device Data Log */
 	u8			devslp_timing[ATA_LOG_DEVSLP_SIZE];
 
+	/* NCQ send and receive log subcommand support */
+	u8			ncq_send_recv_cmds[ATA_LOG_NCQ_SEND_RECV_SIZE];
+
 	/* error history */
 	int			spdn_cnt;
 	/* ering is CLEAR_END, read comment above CLEAR_END */

commit 40fb59e75ad197a1c4ca2fbccef85432d8d103f8
Author: Marc Carino <marc.ceeeee@gmail.com>
Date:   Sat Aug 24 23:22:49 2013 -0700

    libata: Add H2D FIS "auxiliary" port flag
    
    Add a new port flag, ATA_FLAG_FPDMA_AUX, used to indicate
    support for transmission of the H2D FIS 'auxiliary' field.
    
    Signed-off-by: Marc Carino <marc.ceeeee@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 9b6ba196179f..578f98c3ff57 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -223,6 +223,7 @@ enum {
 	ATA_FLAG_ACPI_SATA	= (1 << 17), /* need native SATA ACPI layout */
 	ATA_FLAG_AN		= (1 << 18), /* controller supports AN */
 	ATA_FLAG_PMP		= (1 << 19), /* controller supports PMP */
+	ATA_FLAG_FPDMA_AUX	= (1 << 20), /* controller supports H2DFIS aux field */
 	ATA_FLAG_EM		= (1 << 21), /* driver supports enclosure
 					      * management */
 	ATA_FLAG_SW_ACTIVITY	= (1 << 22), /* driver supports sw activity

commit 8be5ad9acb7c11b9d717bcdbe3d6de0dab081a39
Author: Marc Carino <marc.ceeeee@gmail.com>
Date:   Sat Aug 24 23:22:48 2013 -0700

    libata: Populate host-to-device FIS "auxiliary" field
    
    SATA 3.1 added an "auxiliary" field to the host-to-device FIS.
    Populate the host-to-device FIS with the new field via the
    taskfile struct.
    
    Signed-off-by: Marc Carino <marc.ceeeee@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 3198617905e1..9b6ba196179f 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -555,6 +555,10 @@ struct ata_taskfile {
 	u8			device;
 
 	u8			command;	/* IO operation */
+
+	u32			auxiliary;	/* auxiliary field */
+						/* from SATA 3.1 and */
+						/* ATA-8 ACS-3 */
 };
 
 #ifdef CONFIG_ATA_SFF

commit f1bc1e4c44b1b78fe34431936c60759b5aad5e3f
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Fri Aug 23 10:17:54 2013 +0800

    ata: acpi: rework the ata acpi bind support
    
    Binding ACPI handle to SCSI device has several drawbacks, namely:
    1 During ATA device initialization time, ACPI handle will be needed
      while SCSI devices are not created yet. So each time ACPI handle is
      needed, instead of retrieving the handle by ACPI_HANDLE macro,
      a namespace scan is performed to find the handle for the corresponding
      ATA device. This is inefficient, and also expose a restriction on
      calling path not holding any lock.
    2 The binding to SCSI device tree makes code complex, while at the same
      time doesn't bring us any benefit. All ACPI handlings are still done
      in ATA module, not in SCSI.
    
    Rework the ATA ACPI binding code to bind ACPI handle to ATA transport
    devices(ATA port and ATA device). The binding needs to be done only once,
    since the ATA transport devices do not go away with hotplug. And due to
    this, the flush_work call in hotplug handler for ATA bay is no longer
    needed.
    
    Tested on an Intel test platform for binding and runtime power off for
    ODD(ZPODD) and hard disk; on an ASUS S400C for binding and normal boot
    and S3, where its SATA port node has _SDD and _GTF control methods when
    configured as an AHCI controller and its PATA device node has _GTF
    control method when configured as an IDE controller. SATA PMP binding
    and ATA hotplug is not tested.
    
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Tested-by: Dirk Griesbach <spamthis@freenet.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 283d66bc603c..3198617905e1 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1244,8 +1244,6 @@ int ata_acpi_stm(struct ata_port *ap, const struct ata_acpi_gtm *stm);
 int ata_acpi_gtm(struct ata_port *ap, struct ata_acpi_gtm *stm);
 unsigned long ata_acpi_gtm_xfermask(struct ata_device *dev,
 				    const struct ata_acpi_gtm *gtm);
-acpi_handle ata_ap_acpi_handle(struct ata_port *ap);
-acpi_handle ata_dev_acpi_handle(struct ata_device *dev);
 int ata_acpi_cbl_80wire(struct ata_port *ap, const struct ata_acpi_gtm *gtm);
 #else
 static inline const struct ata_acpi_gtm *ata_acpi_init_gtm(struct ata_port *ap)

commit dc34e7e1a701134c2639dc7af78dc91055616477
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Mon Jul 1 00:01:32 2013 +0400

    libata: move 'struct ata_taskfile' and friends from ata.h to libata.h
    
    Move 'struct ata_taskfile', ata_prot_flags() and their friends from
    <linux/ata.h> to <linux/libata.h>. They were misplaced from the beginning,  as
    <linux/ata.h> should cover ATA/ATAPI and related standards only -- to which the
    aforementioned structure and function have only remote relation.
    
    I would have moved 'enum ata_tf_protocols' closely related to 'struct
    ata_taskfile' but it unfortunately gets used by 'drivers/ide/ide-ioctls.c'...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 4ea55bb45deb..283d66bc603c 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -138,6 +138,22 @@ enum {
 	ATA_SHT_THIS_ID		= -1,
 	ATA_SHT_USE_CLUSTERING	= 1,
 
+	/* struct ata_taskfile flags */
+	ATA_TFLAG_LBA48		= (1 << 0), /* enable 48-bit LBA and "HOB" */
+	ATA_TFLAG_ISADDR	= (1 << 1), /* enable r/w to nsect/lba regs */
+	ATA_TFLAG_DEVICE	= (1 << 2), /* enable r/w to device reg */
+	ATA_TFLAG_WRITE		= (1 << 3), /* data dir: host->dev==1 (write) */
+	ATA_TFLAG_LBA		= (1 << 4), /* enable LBA */
+	ATA_TFLAG_FUA		= (1 << 5), /* enable FUA */
+	ATA_TFLAG_POLLING	= (1 << 6), /* set nIEN to 1 and use polling */
+
+	/* protocol flags */
+	ATA_PROT_FLAG_PIO	= (1 << 0), /* is PIO */
+	ATA_PROT_FLAG_DMA	= (1 << 1), /* is DMA */
+	ATA_PROT_FLAG_DATA	= ATA_PROT_FLAG_PIO | ATA_PROT_FLAG_DMA,
+	ATA_PROT_FLAG_NCQ	= (1 << 2), /* is NCQ */
+	ATA_PROT_FLAG_ATAPI	= (1 << 3), /* is ATAPI */
+
 	/* struct ata_device stuff */
 	ATA_DFLAG_LBA		= (1 << 0), /* device supports LBA */
 	ATA_DFLAG_LBA48		= (1 << 1), /* device supports LBA48 */
@@ -518,6 +534,29 @@ enum sw_activity {
 	BLINK_OFF,
 };
 
+struct ata_taskfile {
+	unsigned long		flags;		/* ATA_TFLAG_xxx */
+	u8			protocol;	/* ATA_PROT_xxx */
+
+	u8			ctl;		/* control reg */
+
+	u8			hob_feature;	/* additional data */
+	u8			hob_nsect;	/* to support LBA48 */
+	u8			hob_lbal;
+	u8			hob_lbam;
+	u8			hob_lbah;
+
+	u8			feature;
+	u8			nsect;
+	u8			lbal;
+	u8			lbam;
+	u8			lbah;
+
+	u8			device;
+
+	u8			command;	/* IO operation */
+};
+
 #ifdef CONFIG_ATA_SFF
 struct ata_ioports {
 	void __iomem		*cmd_addr;
@@ -959,6 +998,69 @@ extern const unsigned long sata_deb_timing_long[];
 extern struct ata_port_operations ata_dummy_port_ops;
 extern const struct ata_port_info ata_dummy_port_info;
 
+/*
+ * protocol tests
+ */
+static inline unsigned int ata_prot_flags(u8 prot)
+{
+	switch (prot) {
+	case ATA_PROT_NODATA:
+		return 0;
+	case ATA_PROT_PIO:
+		return ATA_PROT_FLAG_PIO;
+	case ATA_PROT_DMA:
+		return ATA_PROT_FLAG_DMA;
+	case ATA_PROT_NCQ:
+		return ATA_PROT_FLAG_DMA | ATA_PROT_FLAG_NCQ;
+	case ATAPI_PROT_NODATA:
+		return ATA_PROT_FLAG_ATAPI;
+	case ATAPI_PROT_PIO:
+		return ATA_PROT_FLAG_ATAPI | ATA_PROT_FLAG_PIO;
+	case ATAPI_PROT_DMA:
+		return ATA_PROT_FLAG_ATAPI | ATA_PROT_FLAG_DMA;
+	}
+	return 0;
+}
+
+static inline int ata_is_atapi(u8 prot)
+{
+	return ata_prot_flags(prot) & ATA_PROT_FLAG_ATAPI;
+}
+
+static inline int ata_is_nodata(u8 prot)
+{
+	return !(ata_prot_flags(prot) & ATA_PROT_FLAG_DATA);
+}
+
+static inline int ata_is_pio(u8 prot)
+{
+	return ata_prot_flags(prot) & ATA_PROT_FLAG_PIO;
+}
+
+static inline int ata_is_dma(u8 prot)
+{
+	return ata_prot_flags(prot) & ATA_PROT_FLAG_DMA;
+}
+
+static inline int ata_is_ncq(u8 prot)
+{
+	return ata_prot_flags(prot) & ATA_PROT_FLAG_NCQ;
+}
+
+static inline int ata_is_data(u8 prot)
+{
+	return ata_prot_flags(prot) & ATA_PROT_FLAG_DATA;
+}
+
+static inline int is_multi_taskfile(struct ata_taskfile *tf)
+{
+	return (tf->command == ATA_CMD_READ_MULTI) ||
+	       (tf->command == ATA_CMD_WRITE_MULTI) ||
+	       (tf->command == ATA_CMD_READ_MULTI_EXT) ||
+	       (tf->command == ATA_CMD_WRITE_MULTI_EXT) ||
+	       (tf->command == ATA_CMD_WRITE_MULTI_FUA_EXT);
+}
+
 static inline const unsigned long *
 sata_ehc_deb_timing(struct ata_eh_context *ehc)
 {

commit 439d7a358f93a52458527329939be9f97db1242a
Author: Mark Langsdorf <mark.langsdorf@calxeda.com>
Date:   Thu May 30 15:17:30 2013 -0500

    ahci: make ahci_transmit_led_message into a function pointer
    
    Create a new ata_port_operations function pointer called
    transmit_led_message and give it the default value of
    ahci_transmit_led_message. This allows AHCI controllers with
    non-standard LED interfaces to use the existing em_ interface.
    
    Signed-off-by: Mark Langsdorf <mark.langsdorf@calxeda.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c886dc87aa81..4ea55bb45deb 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -910,6 +910,9 @@ struct ata_port_operations {
 	ssize_t (*sw_activity_show)(struct ata_device *dev, char *buf);
 	ssize_t (*sw_activity_store)(struct ata_device *dev,
 				     enum sw_activity val);
+	ssize_t (*transmit_led_message)(struct ata_port *ap, u32 state,
+					ssize_t size);
+
 	/*
 	 * Obsolete
 	 */

commit 966fbe193f47c68e70a80ec9991098e88e7959cb
Author: Vincent Pelletier <plr.vincent@gmail.com>
Date:   Tue May 21 22:30:58 2013 +0200

    libata: Add atapi_dmadir force flag
    
    Some device require DMADIR to be enabled, but are not detected as such
    by atapi_id_dmadir.  One such example is "Asus Serillel 2"
    SATA-host-to-PATA-device bridge: the bridge itself requires DMADIR,
    even if the bridged device does not.
    
    As atapi_dmadir module parameter can cause problems with some devices
    (as per Tejun Heo's memory), enabling it globally may not be possible
    depending on the hardware.
    
    This patch adds atapi_dmadir in the form of a "force" horkage value,
    allowing global, per-bus and per-device control.
    
    Signed-off-by: Vincent Pelletier <plr.vincent@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 47e029236f6e..c886dc87aa81 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -399,6 +399,7 @@ enum {
 	ATA_HORKAGE_BROKEN_FPDMA_AA	= (1 << 15),	/* skip AA */
 	ATA_HORKAGE_DUMP_ID	= (1 << 16),	/* dump IDENTIFY data */
 	ATA_HORKAGE_MAX_SEC_LBA48 = (1 << 17),	/* Set max sects to 65535 */
+	ATA_HORKAGE_ATAPI_DMADIR = (1 << 18),	/* device requires dmadir */
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */

commit e628dc999e43a9dd51fb6bd810772c277f934484
Author: David Milburn <dmilburn@redhat.com>
Date:   Tue May 14 13:48:40 2013 -0500

    libata: export ata_port port_no attribute via /sys
    
    While registering host controller track port number based upon number
    of ports available on the controller, export port_no attribute through
    /sys. This patch is needed by udev for composing persistent links in
    /dev/disk/by-path.
    
    /sys/devices/pci0000:00/0000:00:1f.2/ata8/ata_port/ata8
    total 0
    lrwxrwxrwx. 1 root root    0 Mar  6 12:43 device -> ../../../ata8
    -r--r--r--. 1 root root 4096 Mar  6 12:43 idle_irq
    -r--r--r--. 1 root root 4096 Mar  6 12:43 nr_pmp_links
    -r--r--r--. 1 root root 4096 Mar  6 12:43 port_no
    drwxr-xr-x. 2 root root    0 Mar  6 12:42 power
    lrwxrwxrwx. 1 root root    0 Mar  6 12:41 subsystem -> ../../../../../../class/ata_port
    -rw-r--r--. 1 root root 4096 Mar  6 12:40 uevent
    1
    
    Signed-off-by: David Milburn <dmilburn@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index eae7a053dc51..47e029236f6e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -746,6 +746,7 @@ struct ata_port {
 	/* Flags that change dynamically, protected by ap->lock */
 	unsigned int		pflags; /* ATA_PFLAG_xxx */
 	unsigned int		print_id; /* user visible unique port ID */
+	unsigned int            local_port_no; /* host local port num */
 	unsigned int		port_no; /* 0 based port no. inside the host */
 
 #ifdef CONFIG_ATA_SFF

commit a32450e127fc6e5ca6d958ceb3cfea4d30a00846
Author: Shan Hai <shan.hai@windriver.com>
Date:   Mon Mar 18 10:30:44 2013 +0800

    libata: Set max sector to 65535 for Slimtype DVD A DS8A8SH drive
    
    The Slimtype DVD A  DS8A8SH drive locks up when max sector is smaller than
    65535, and the blow backtrace is observed on locking up:
    
    INFO: task flush-8:32:1130 blocked for more than 120 seconds.
    "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    flush-8:32      D ffffffff8180cf60     0  1130      2 0x00000000
     ffff880273aef618 0000000000000046 0000000000000005 ffff880273aee000
     ffff880273aee000 ffff880273aeffd8 ffff880273aee010 ffff880273aee000
     ffff880273aeffd8 ffff880273aee000 ffff88026e842ea0 ffff880274a10000
    Call Trace:
     [<ffffffff8168fc2d>] schedule+0x5d/0x70
     [<ffffffff8168fccc>] io_schedule+0x8c/0xd0
     [<ffffffff81324461>] get_request+0x731/0x7d0
     [<ffffffff8133dc60>] ? cfq_allow_merge+0x50/0x90
     [<ffffffff81083aa0>] ? wake_up_bit+0x40/0x40
     [<ffffffff81320443>] ? bio_attempt_back_merge+0x33/0x110
     [<ffffffff813248ea>] blk_queue_bio+0x23a/0x3f0
     [<ffffffff81322176>] generic_make_request+0xc6/0x120
     [<ffffffff81322308>] submit_bio+0x138/0x160
     [<ffffffff811d7596>] ? bio_alloc_bioset+0x96/0x120
     [<ffffffff811d1f61>] submit_bh+0x1f1/0x220
     [<ffffffff811d48b8>] __block_write_full_page+0x228/0x340
     [<ffffffff811d3650>] ? attach_nobh_buffers+0xc0/0xc0
     [<ffffffff811d8960>] ? I_BDEV+0x10/0x10
     [<ffffffff811d8960>] ? I_BDEV+0x10/0x10
     [<ffffffff811d4ab6>] block_write_full_page_endio+0xe6/0x100
     [<ffffffff811d4ae5>] block_write_full_page+0x15/0x20
     [<ffffffff811d9268>] blkdev_writepage+0x18/0x20
     [<ffffffff81142527>] __writepage+0x17/0x40
     [<ffffffff811438ba>] write_cache_pages+0x34a/0x4a0
     [<ffffffff81142510>] ? set_page_dirty+0x70/0x70
     [<ffffffff81143a61>] generic_writepages+0x51/0x80
     [<ffffffff81143ab0>] do_writepages+0x20/0x50
     [<ffffffff811c9ed6>] __writeback_single_inode+0xa6/0x2b0
     [<ffffffff811ca861>] writeback_sb_inodes+0x311/0x4d0
     [<ffffffff811caaa6>] __writeback_inodes_wb+0x86/0xd0
     [<ffffffff811cad43>] wb_writeback+0x1a3/0x330
     [<ffffffff816916cf>] ? _raw_spin_lock_irqsave+0x3f/0x50
     [<ffffffff811b8362>] ? get_nr_inodes+0x52/0x70
     [<ffffffff811cb0ac>] wb_do_writeback+0x1dc/0x260
     [<ffffffff8168dd34>] ? schedule_timeout+0x204/0x240
     [<ffffffff811cb232>] bdi_writeback_thread+0x102/0x2b0
     [<ffffffff811cb130>] ? wb_do_writeback+0x260/0x260
     [<ffffffff81083550>] kthread+0xc0/0xd0
     [<ffffffff81083490>] ? kthread_worker_fn+0x1b0/0x1b0
     [<ffffffff8169a3ec>] ret_from_fork+0x7c/0xb0
     [<ffffffff81083490>] ? kthread_worker_fn+0x1b0/0x1b0
    
     The above trace was triggered by
       "dd if=/dev/zero of=/dev/sr0 bs=2048 count=32768"
    
     It was previously working by accident, since another bug introduced
     by 4dce8ba94c7 (libata: Use 'bool' return value for ata_id_XXX) caused
     all drives to use maxsect=65535.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Shan Hai <shan.hai@windriver.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 91c9d109e5f1..eae7a053dc51 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -398,6 +398,7 @@ enum {
 	ATA_HORKAGE_NOSETXFER	= (1 << 14),	/* skip SETXFER, SATA only */
 	ATA_HORKAGE_BROKEN_FPDMA_AA	= (1 << 15),	/* skip AA */
 	ATA_HORKAGE_DUMP_ID	= (1 << 16),	/* dump IDENTIFY data */
+	ATA_HORKAGE_MAX_SEC_LBA48 = (1 << 17),	/* Set max sects to 65535 */
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */

commit e175435ed281d06ffd56d4edc8a2dd56f8672f07
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Jan 25 15:30:23 2013 -0500

    Revert "libata: export host controller number thru /sys"
    
    This reverts commit 1757d902b029a29dfcef63609964385cf8865b5a.
    
    Discussion continues upstream.

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 65ff67e34b77..91c9d109e5f1 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -546,7 +546,6 @@ struct ata_host {
 	void			*private_data;
 	struct ata_port_operations *ops;
 	unsigned long		flags;
-	unsigned int            host_id; /* user visible host ID */
 
 	struct mutex		eh_mutex;
 	struct task_struct	*eh_owner;

commit afe759511808cd5bb508b598007cf0c7b0ca8e08
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Tue Jan 15 17:20:58 2013 +0800

    libata: identify and init ZPODD devices
    
    The ODD can be enabled for ZPODD if the following three conditions are
    satisfied:
    1 The ODD supports device attention;
    2 The platform can runtime power off the ODD through ACPI;
    3 The ODD is either slot type or drawer type.
    For such ODDs, zpodd_init is called and a new structure is allocated for
    it to store ZPODD related stuffs.
    
    And the zpodd_dev_enabled function is used to test if ZPODD is currently
    enabled for this ODD.
    
    A new config CONFIG_SATA_ZPODD is added to selectively build ZPODD code.
    
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 7ae207eb29a0..65ff67e34b77 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -620,6 +620,9 @@ struct ata_device {
 #ifdef CONFIG_ATA_ACPI
 	union acpi_object	*gtf_cache;
 	unsigned int		gtf_filter;
+#endif
+#ifdef CONFIG_SATA_ZPODD
+	void			*zpodd;
 #endif
 	struct device		tdev;
 	/* n_sector is CLEAR_BEGIN, read comment above CLEAR_BEGIN */

commit 1757d902b029a29dfcef63609964385cf8865b5a
Author: David Milburn <dmilburn@redhat.com>
Date:   Mon Jan 14 09:59:30 2013 -0600

    libata: export host controller number thru /sys
    
    As low-level drivers register their host controller(s), keep track
    of the number of controllers and export thru /sys in a <host.port>
    format so that udev can better match up port numbers with a
    specific controller.
    
    # pwd
    /sys/devices/pci0000:00
    # find . -name 'ata*' -print
    
    (2nd controller with port multiplier attached)
    
    ./0000:00:1e.0/0000:05:01.0/ata2.7
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7/dev7.0/ata_device
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7/ata_link
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.0/dev7.0.0/ata_device
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.0/ata_link
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.1/dev7.1.0/ata_device
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.1/ata_link
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.2/dev7.2.0/ata_device
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.2/ata_link
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.3/dev7.3.0/ata_device
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.3/ata_link
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.4/dev7.4.0/ata_device
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.4/ata_link
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.5/dev7.5.0/ata_device
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.5/ata_link
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.6/dev7.6.0/ata_device
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.6/ata_link
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.7/dev7.7.0/ata_device
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.7/ata_link
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.8/dev7.8.0/ata_device
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.8/ata_link
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.9/dev7.9.0/ata_device
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.9/ata_link
    ./0000:00:1e.0/0000:05:01.0/ata2.7/ata_port
    ./0000:00:1e.0/0000:05:01.0/ata2.7/ata_port/ata2.7
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.10/dev7.10.0/ata_device
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.10/ata_link
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.11/dev7.11.0/ata_device
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.11/ata_link
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.12/dev7.12.0/ata_device
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.12/ata_link
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.13/dev7.13.0/ata_device
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.13/ata_link
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.14/dev7.14.0/ata_device
    ./0000:00:1e.0/0000:05:01.0/ata2.7/link7.14/ata_link
    ./0000:00:1e.0/0000:05:01.0/ata2.8
    ./0000:00:1e.0/0000:05:01.0/ata2.8/link8/dev8.0/ata_device
    ./0000:00:1e.0/0000:05:01.0/ata2.8/link8/ata_link
    ./0000:00:1e.0/0000:05:01.0/ata2.8/ata_port
    ./0000:00:1e.0/0000:05:01.0/ata2.8/ata_port/ata2.8
    
    (1st controller)
    
    ./0000:00:1f.2/ata1.1
    ./0000:00:1f.2/ata1.1/link1/dev1.0/ata_device
    ./0000:00:1f.2/ata1.1/link1/ata_link
    ./0000:00:1f.2/ata1.1/ata_port
    ./0000:00:1f.2/ata1.1/ata_port/ata1.1
    ./0000:00:1f.2/ata1.2
    ./0000:00:1f.2/ata1.2/link2/dev2.0/ata_device
    ./0000:00:1f.2/ata1.2/link2/ata_link
    ./0000:00:1f.2/ata1.2/ata_port
    ./0000:00:1f.2/ata1.2/ata_port/ata1.2
    ./0000:00:1f.2/ata1.3
    ./0000:00:1f.2/ata1.3/link3/dev3.0/ata_device
    ./0000:00:1f.2/ata1.3/link3/ata_link
    ./0000:00:1f.2/ata1.3/ata_port
    ./0000:00:1f.2/ata1.3/ata_port/ata1.3
    ./0000:00:1f.2/ata1.4
    ./0000:00:1f.2/ata1.4/link4/dev4.0/ata_device
    ./0000:00:1f.2/ata1.4/link4/ata_link
    ./0000:00:1f.2/ata1.4/ata_port
    ./0000:00:1f.2/ata1.4/ata_port/ata1.4
    ./0000:00:1f.2/ata1.5
    ./0000:00:1f.2/ata1.5/link5/dev5.0/ata_device
    ./0000:00:1f.2/ata1.5/link5/ata_link
    ./0000:00:1f.2/ata1.5/ata_port
    ./0000:00:1f.2/ata1.5/ata_port/ata1.5
    ./0000:00:1f.2/ata1.6
    ./0000:00:1f.2/ata1.6/link6/dev6.0/ata_device
    ./0000:00:1f.2/ata1.6/link6/ata_link
    ./0000:00:1f.2/ata1.6/ata_port
    ./0000:00:1f.2/ata1.6/ata_port/ata1.6
    
    Signed-off-by: David Milburn <dmilburn@redhat.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 649e5f86b5f0..7ae207eb29a0 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -546,6 +546,7 @@ struct ata_host {
 	void			*private_data;
 	struct ata_port_operations *ops;
 	unsigned long		flags;
+	unsigned int            host_id; /* user visible host ID */
 
 	struct mutex		eh_mutex;
 	struct task_struct	*eh_owner;

commit 803739d25c2343da6d2f95eebdcbc08bf67097d4
Author: Shane Huang <shane.huang@amd.com>
Date:   Mon Dec 17 23:18:59 2012 +0800

    [libata] replace sata_settings with devslp_timing
    
    NCQ capability was used to check availability of SATA Settings page
    from Identify Device Data Log, which contains DevSlp timing variables.
    It does not work on some HDDs and leads to error messages.
    
    IDENTIFY word 78 bit 5(Hardware Feature Control) can't work either
    because it is only the sufficient condition of Identify Device data
    log, not the necessary condition.
    
    This patch replaced ata_device->sata_settings with ->devslp_timing
    to only save DevSlp timing variables(8 bytes), instead of the whole
    SATA Settings page(512 bytes).
    
    Addresses https://bugzilla.kernel.org/show_bug.cgi?id=51881
    
    Reported-by: Borislav Petkov <bp@alien8.de>
    Signed-off-by: Shane Huang <shane.huang@amd.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 83ba0ab2c915..649e5f86b5f0 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -652,8 +652,8 @@ struct ata_device {
 		u32		gscr[SATA_PMP_GSCR_DWORDS]; /* PMP GSCR block */
 	};
 
-	/* Identify Device Data Log (30h), SATA Settings (page 08h) */
-	u8			sata_settings[ATA_SECT_SIZE];
+	/* DEVSLP Timing Variables from Identify Device Data Log */
+	u8			devslp_timing[ATA_LOG_DEVSLP_SIZE];
 
 	/* error history */
 	int			spdn_cnt;

commit b7db04d9264fca4b00e949da7b3180c50e243fca
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Nov 2 12:29:32 2012 -0700

    libata: implement ata_platform_remove_one()
    
    This relatively simple boiler-plate code is repeated in several platform
    drivers. We should implement a common version in libata.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index e931c9ad1078..83ba0ab2c915 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1115,6 +1115,10 @@ extern int ata_pci_device_resume(struct pci_dev *pdev);
 #endif /* CONFIG_PM */
 #endif /* CONFIG_PCI */
 
+struct platform_device;
+
+extern int ata_platform_remove_one(struct platform_device *pdev);
+
 /*
  * ACPI - drivers/ata/libata-acpi.c
  */

commit 0d0cdb028f9d9771e2b346038707734121f906e3
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Mon Nov 26 13:55:25 2012 +0800

    libata: restore acpi disable functionality
    
    Commit 66fa7f215 "libata-acpi: improve ACPI disabling" introdcued the
    behaviour of disabling ATA ACPI if ata_acpi_on_devcfg failed the 2nd
    time, but commit 30dcf76ac dropped this behaviour and this caused
    problem for Dimitris Damigos, where his laptop can not resume correctly.
    
    The bugzilla page for it is:
    https://bugzilla.kernel.org/show_bug.cgi?id=49331
    
    The problem is, ata_dev_push_id will fail the 2nd time it is invoked,
    and due to disabling ACPI code is dropped, ata_acpi_on_devcfg which
    calls ata_dev_push_id will keep failing and eventually made the device
    disabled.
    
    This patch restores the original behaviour, if acpi failed the 2nd time,
    disable acpi functionality for the device(and we do not event need to
    add a debug message for this as it is still there ;-).
    
    Reported-by: Dimitris Damigos <damigos@freemail.gr>
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 77eeeda2b6e2..e931c9ad1078 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -163,6 +163,7 @@ enum {
 
 	ATA_DFLAG_DA		= (1 << 26), /* device supports Device Attention */
 	ATA_DFLAG_DEVSLP	= (1 << 27), /* device supports Device Sleep */
+	ATA_DFLAG_ACPI_DISABLED = (1 << 28), /* ACPI for the device is disabled */
 
 	ATA_DEV_UNKNOWN		= 0,	/* unknown device */
 	ATA_DEV_ATA		= 1,	/* ATA device */

commit 3151367f8778a1789d6f6e6f6c642681b6cd6d64
Merge: 16642a2e7be2 fe709ed827d3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 2 19:01:32 2012 -0700

    Merge tag 'scsi-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull first round of SCSI updates from James Bottomley:
     "This is a large set of updates, mostly for drivers (qla2xxx [including
      support for new 83xx based card], qla4xxx, mpt2sas, bfa, zfcp, hpsa,
      be2iscsi, isci, lpfc, ipr, ibmvfc, ibmvscsi, megaraid_sas).
    
      There's also a rework for tape adding virtually unlimited numbers of
      tape drives plus a set of dif fixes for sd and a fix for a live lock
      on hot remove of SCSI devices.
    
      This round includes a signed tag pull of isci-for-3.6
    
      Signed-off-by: James Bottomley <JBottomley@Parallels.com>"
    
    Fix up trivial conflict in drivers/scsi/qla2xxx/qla_nx.c due to new PCI
    helper function use in a function that was removed by this pull.
    
    * tag 'scsi-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (198 commits)
      [SCSI] st: remove st_mutex
      [SCSI] sd: Ensure we correctly disable devices with unknown protection type
      [SCSI] hpsa: gen8plus Smart Array IDs
      [SCSI] qla4xxx: Update driver version to 5.03.00-k1
      [SCSI] qla4xxx: Disable generating pause frames for ISP83XX
      [SCSI] qla4xxx: Fix double clearing of risc_intr for ISP83XX
      [SCSI] qla4xxx: IDC implementation for Loopback
      [SCSI] qla4xxx: update copyrights in LICENSE.qla4xxx
      [SCSI] qla4xxx: Fix panic while rmmod
      [SCSI] qla4xxx: Fail probe_adapter if IRQ allocation fails
      [SCSI] qla4xxx: Prevent MSI/MSI-X falling back to INTx for ISP82XX
      [SCSI] qla4xxx: Update idc reg in case of PCI AER
      [SCSI] qla4xxx: Fix double IDC locking in qla4_8xxx_error_recovery
      [SCSI] qla4xxx: Clear interrupt while unloading driver for ISP83XX
      [SCSI] qla4xxx: Print correct IDC version
      [SCSI] qla4xxx: Added new mbox cmd to pass driver version to FW
      [SCSI] scsi_dh_alua: Enable STPG for unavailable ports
      [SCSI] scsi_remove_target: fix softlockup regression on hot remove
      [SCSI] ibmvscsi: Fix host config length field overflow
      [SCSI] ibmvscsi: Remove backend abstraction
      ...

commit 65fe1f0f66a57380229a4ced844188103135f37b
Author: Shane Huang <shane.huang@amd.com>
Date:   Fri Sep 7 22:40:01 2012 +0800

    ahci: implement aggressive SATA device sleep support
    
    Device Sleep is a feature as described in AHCI 1.3.1 Technical Proposal.
    This feature enables an HBA and SATA storage device to enter the DevSleep
    interface state, enabling lower power SATA-based systems.
    
    Aggressive Device Sleep enables the HBA to assert the DEVSLP signal as
    soon as there are no commands outstanding to the device and the port
    specific Device Sleep idle timer has expired. This enables autonomous
    entry into the DevSleep interface state without waiting for software
    in power sensitive systems.
    
    This patch enables Aggressive Device Sleep only if both host controller
    and device support it.
    
    Tested on AMD reference board together with Device Sleep supported device
    sample.
    
    Signed-off-by: Shane Huang <shane.huang@amd.com>
    Reviewed-by: Aaron Lu <aaron.lwe@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 64f90e17e51d..464e67c2e77a 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -162,6 +162,7 @@ enum {
 	ATA_DFLAG_DETACHED	= (1 << 25),
 
 	ATA_DFLAG_DA		= (1 << 26), /* device supports Device Attention */
+	ATA_DFLAG_DEVSLP	= (1 << 27), /* device supports Device Sleep */
 
 	ATA_DEV_UNKNOWN		= 0,	/* unknown device */
 	ATA_DEV_ATA		= 1,	/* ATA device */
@@ -649,6 +650,9 @@ struct ata_device {
 		u32		gscr[SATA_PMP_GSCR_DWORDS]; /* PMP GSCR block */
 	};
 
+	/* Identify Device Data Log (30h), SATA Settings (page 08h) */
+	u8			sata_settings[ATA_SECT_SIZE];
+
 	/* error history */
 	int			spdn_cnt;
 	/* ering is CLEAR_END, read comment above CLEAR_END */

commit 8d8e7d13146eb6be8b98dbd58ac30421a4f8edf3
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jul 9 21:06:08 2012 -0700

    [SCSI] libsas, ipr: cleanup ata_host flags initialization via ata_host_init
    
    libsas and ipr pass flags to ata_host_init that are meant for the port.
    
    ata_host flags:
            ATA_HOST_SIMPLEX        = (1 << 0),     /* Host is simplex, one DMA channel per host only */
            ATA_HOST_STARTED        = (1 << 1),     /* Host started */
            ATA_HOST_PARALLEL_SCAN  = (1 << 2),     /* Ports on this host can be scanned in parallel */
            ATA_HOST_IGNORE_ATA     = (1 << 3),     /* Ignore ATA devices on this host. */
    
    flags passed by libsas:
            ATA_FLAG_SATA           = (1 << 1),
            ATA_FLAG_PIO_DMA        = (1 << 7), /* PIO cmds via DMA */
            ATA_FLAG_NCQ            = (1 << 10), /* host supports NCQ */
    
    The only one that aliases is ATA_HOST_STARTED which is a 'don't care' in
    the libsas and ipr cases since ata_hosts from these sources are not
    registered with libata.
    
    Reported-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Brian King <brking@us.ibm.com>
    Acked-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index cc834e1136b2..a22707186421 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -987,8 +987,7 @@ extern int ata_host_activate(struct ata_host *host, int irq,
 			     irq_handler_t irq_handler, unsigned long irq_flags,
 			     struct scsi_host_template *sht);
 extern void ata_host_detach(struct ata_host *host);
-extern void ata_host_init(struct ata_host *, struct device *,
-			  unsigned long, struct ata_port_operations *);
+extern void ata_host_init(struct ata_host *, struct device *, struct ata_port_operations *);
 extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
 extern int ata_scsi_queuecmd(struct Scsi_Host *h, struct scsi_cmnd *cmd);

commit 2fcbdcb4c802fe40d6827dbc365dac90cfe8c0a3
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 21 23:41:46 2012 -0700

    [SCSI] libata: export ata_port suspend/resume infrastructure for sas
    
    Reuse ata_port_{suspend|resume}_common for sas.  This path is chosen
    over adding coordination between ata-tranport and sas-transport because
    libsas wants to revalidate the domain at resume-time at the host level.
    It can not validate links have resumed properly until libata has had a
    chance to perform its revalidation, and any sane placing of an ata_port
    in the sas-transport model would delay it's resumption until after the
    host.
    
    Export the common portion of port suspend/resume (bypass pm_runtime),
    and allow sas to perform these operations asynchronously (similar to the
    libsas async-ata probe implmentation).  Async operation is determined by
    having an external, rather than stack based, location for storing the
    result of the operation.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Reviewed-by: Jacek Danecki <jacek.danecki@intel.com>
    Acked-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 31a2853e9530..cc834e1136b2 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1013,6 +1013,17 @@ extern bool ata_link_offline(struct ata_link *link);
 #ifdef CONFIG_PM
 extern int ata_host_suspend(struct ata_host *host, pm_message_t mesg);
 extern void ata_host_resume(struct ata_host *host);
+extern int ata_sas_port_async_suspend(struct ata_port *ap, int *async);
+extern int ata_sas_port_async_resume(struct ata_port *ap, int *async);
+#else
+static inline int ata_sas_port_async_suspend(struct ata_port *ap, int *async)
+{
+	return 0;
+}
+static inline int ata_sas_port_async_resume(struct ata_port *ap, int *async)
+{
+	return 0;
+}
 #endif
 extern int ata_ratelimit(void);
 extern void ata_msleep(struct ata_port *ap, unsigned int msecs);

commit ca6d43b051b5a061b33c43303b6b4c93b46a34b5
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 21 23:41:41 2012 -0700

    [SCSI] libata: reset once
    
    Hotplug testing with libsas currently encounters a 55 second wait for
    link recovery to give up.  In the case where the user trusts the
    response time of their devices permit the recovery attempts to be
    limited to one.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 64f90e17e51d..31a2853e9530 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -184,6 +184,7 @@ enum {
 	ATA_LFLAG_DISABLED	= (1 << 6), /* link is disabled */
 	ATA_LFLAG_SW_ACTIVITY	= (1 << 7), /* keep activity stats */
 	ATA_LFLAG_NO_LPM	= (1 << 8), /* disable LPM on this link */
+	ATA_LFLAG_RST_ONCE	= (1 << 9), /* limit recovery to one reset */
 
 	/* struct ata_port flags */
 	ATA_FLAG_SLAVE_POSS	= (1 << 0), /* host supports slave dev */

commit 8407884dd9164ec18ed2afc00f56b87e36c51fcf
Merge: dc7f71f486f4 bdc0077af574
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Jul 25 15:58:48 2012 -0400

    Merge branch 'master' [vanilla Linus master] into libata-dev.git/upstream
    
    Two bits were appended to the end of the bitfield
    list in struct scsi_device.  Resolve that conflict
    by including both bits.
    
    Conflicts:
            include/scsi/scsi_device.h

commit e4a9c3732cea3e3c8c704aad86636090ffe6b25f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 21 23:25:27 2012 -0700

    [SCSI] libata, libsas: introduce sched_eh and end_eh port ops
    
    When managing shost->host_eh_scheduled libata assumes that there is a
    1:1 shost-to-ata_port relationship.  libsas creates a 1:N relationship
    so it needs to manage host_eh_scheduled cumulatively at the host level.
    The sched_eh and end_eh port port ops allow libsas to track when domain
    devices enter/leave the "eh-pending" state under ha->lock (previously
    named ha->state_lock, but it is no longer just a lock for ha->state
    changes).
    
    Since host_eh_scheduled indicates eh without backing commands pinning
    the device it can be deallocated at any time.  Move the taking of the
    domain_device reference under the port_lock to guarantee that the
    ata_port stays around for the duration of eh.
    
    Reviewed-by: Jacek Danecki <jacek.danecki@intel.com>
    Acked-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6e887c742a27..53da442f892d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -846,6 +846,8 @@ struct ata_port_operations {
 	void (*error_handler)(struct ata_port *ap);
 	void (*lost_interrupt)(struct ata_port *ap);
 	void (*post_internal_cmd)(struct ata_queued_cmd *qc);
+	void (*sched_eh)(struct ata_port *ap);
+	void (*end_eh)(struct ata_port *ap);
 
 	/*
 	 * Optional features
@@ -1167,6 +1169,8 @@ extern void ata_do_eh(struct ata_port *ap, ata_prereset_fn_t prereset,
 		      ata_reset_fn_t softreset, ata_reset_fn_t hardreset,
 		      ata_postreset_fn_t postreset);
 extern void ata_std_error_handler(struct ata_port *ap);
+extern void ata_std_sched_eh(struct ata_port *ap);
+extern void ata_std_end_eh(struct ata_port *ap);
 extern int ata_link_nr_enabled(struct ata_link *link);
 
 /*

commit b1354cbb5bfce28f2e1ed28d77b362dfdfca638d
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Mon Jun 25 16:13:08 2012 +0800

    libata: detect Device Attention support
    
    Add a new flag ATA_DFLAG_DA to indicate that device supports "Device
    Attention".
    
    Acked-by: Aaron Lu <aaron.lu@amd.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 888feef3cda4..cc22b943db83 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -161,6 +161,8 @@ enum {
 	ATA_DFLAG_DETACH	= (1 << 24),
 	ATA_DFLAG_DETACHED	= (1 << 25),
 
+	ATA_DFLAG_DA		= (1 << 26), /* device supports Device Attention */
+
 	ATA_DEV_UNKNOWN		= 0,	/* unknown device */
 	ATA_DEV_ATA		= 1,	/* ATA device */
 	ATA_DEV_ATA_UNSUP	= 2,	/* ATA device (unsupported) */

commit 30dcf76acc695cbd2fa919e294670fe9552e16e7
Author: Matthew Garrett <mjg@redhat.com>
Date:   Mon Jun 25 16:13:04 2012 +0800

    libata: migrate ACPI code over to new bindings
    
    Now that we have the ability to directly glue the ACPI namespace to the
    driver model in libata, we don't need the custom code to handle the same
    thing. Remove it and migrate the functions over to the new code.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Holger Macht <holger@homac.de>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6e887c742a27..888feef3cda4 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -545,9 +545,6 @@ struct ata_host {
 	struct mutex		eh_mutex;
 	struct task_struct	*eh_owner;
 
-#ifdef CONFIG_ATA_ACPI
-	acpi_handle		acpi_handle;
-#endif
 	struct ata_port		*simplex_claimed;	/* channel owning the DMA */
 	struct ata_port		*ports[0];
 };
@@ -615,7 +612,6 @@ struct ata_device {
 	struct scsi_device	*sdev;		/* attached SCSI device */
 	void			*private_data;
 #ifdef CONFIG_ATA_ACPI
-	acpi_handle		acpi_handle;
 	union acpi_object	*gtf_cache;
 	unsigned int		gtf_filter;
 #endif
@@ -797,7 +793,6 @@ struct ata_port {
 	void			*private_data;
 
 #ifdef CONFIG_ATA_ACPI
-	acpi_handle		acpi_handle;
 	struct ata_acpi_gtm	__acpi_init_gtm; /* use ata_acpi_init_gtm() */
 #endif
 	/* owned by EH */
@@ -1114,6 +1109,8 @@ int ata_acpi_stm(struct ata_port *ap, const struct ata_acpi_gtm *stm);
 int ata_acpi_gtm(struct ata_port *ap, struct ata_acpi_gtm *stm);
 unsigned long ata_acpi_gtm_xfermask(struct ata_device *dev,
 				    const struct ata_acpi_gtm *gtm);
+acpi_handle ata_ap_acpi_handle(struct ata_port *ap);
+acpi_handle ata_dev_acpi_handle(struct ata_device *dev);
 int ata_acpi_cbl_80wire(struct ata_port *ap, const struct ata_acpi_gtm *gtm);
 #else
 static inline const struct ata_acpi_gtm *ata_acpi_init_gtm(struct ata_port *ap)

commit db63a4c8115a0bb904496e1cdd3e7488e68b0d06
Author: Andy Whitcroft <apw@canonical.com>
Date:   Fri May 4 22:15:10 2012 +0100

    libata: add a host flag to ignore detected ATA devices
    
    Where devices are visible via more than one host we sometimes wish to
    indicate that cirtain devices should be ignored on a specific host.  Add a
    host flag indicating that this host wishes to ignore ATA specific devices.
    
    Signed-off-by: Andy Whitcroft <apw@canonical.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index e926df7b54c9..6e887c742a27 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -247,6 +247,7 @@ enum {
 	ATA_HOST_SIMPLEX	= (1 << 0),	/* Host is simplex, one DMA channel per host only */
 	ATA_HOST_STARTED	= (1 << 1),	/* Host started */
 	ATA_HOST_PARALLEL_SCAN	= (1 << 2),	/* Ports on this host can be scanned in parallel */
+	ATA_HOST_IGNORE_ATA	= (1 << 3),	/* Ignore ATA devices on this host. */
 
 	/* bits 24:31 of host->flags are reserved for LLD specific flags */
 

commit b2024459252a9d2d312ee562f86f332a1498f412
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Mar 21 21:09:07 2012 -0700

    [SCSI] libsas, libata: fix start of life for a sas ata_port
    
    This changes the ordering of initialization and probing events from:
      1/ allocate rphy in PORTE_BYTES_DMAED, DISCE_REVALIDATE_DOMAIN
      2/ allocate ata_port and schedule port probe in DISCE_PROBE
    ...to:
      1/ allocate ata_port in PORTE_BYTES_DMAED, DISCE_REVALIDATE_DOMAIN
      2/ allocate rphy in PORTE_BYTES_DMAED, DISCE_REVALIDATE_DOMAIN
      3/ schedule port probe in DISCE_PROBE
    
    This ordering prevents PHYE_SIGNAL_LOSS_EVENTS from sneaking in to
    destrory ata devices before they have been fully initialized:
    
      BUG: unable to handle kernel paging request at 0000000000003b10
      IP: [<ffffffffa0053d7e>] sas_ata_end_eh+0x12/0x5e [libsas]
      ...
      [<ffffffffa004d1af>] sas_unregister_common_dev+0x78/0xc9 [libsas]
      [<ffffffffa004d4d4>] sas_unregister_dev+0x4f/0xad [libsas]
      [<ffffffffa004d5b1>] sas_unregister_domain_devices+0x7f/0xbf [libsas]
      [<ffffffffa004c487>] sas_deform_port+0x61/0x1b8 [libsas]
      [<ffffffffa004bed0>] sas_phye_loss_of_signal+0x29/0x2b [libsas]
    
    ...and kills the awkward "sata domain_device briefly existing in the
    domain without an ata_port" state.
    
    Reported-by: Michal Kosciowski <michal.kosciowski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 42378d637ffb..e926df7b54c9 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -996,7 +996,8 @@ extern int ata_sas_scsi_ioctl(struct ata_port *ap, struct scsi_device *dev,
 extern void ata_sas_port_destroy(struct ata_port *);
 extern struct ata_port *ata_sas_port_alloc(struct ata_host *,
 					   struct ata_port_info *, struct Scsi_Host *);
-extern int ata_sas_async_port_init(struct ata_port *);
+extern void ata_sas_async_probe(struct ata_port *ap);
+extern int ata_sas_sync_probe(struct ata_port *ap);
 extern int ata_sas_port_init(struct ata_port *);
 extern int ata_sas_port_start(struct ata_port *ap);
 extern void ata_sas_port_stop(struct ata_port *ap);

commit 9508a66f898d46e726a318469312b45e0b1d078b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jan 18 20:47:01 2012 -0800

    [SCSI] libsas: async ata scanning
    
    libsas ata error handling is already async but this does not help the
    scan case.  Move initial link recovery out from under host->scan_mutex,
    and delay synchronization with eh until after all port probe/recovery
    work has been queued.
    
    Device ordering is maintained with scan order by still calling
    sas_rphy_add() in order of domain discovery.
    
    Since we now scan the domain list when invoking libata-eh we need to be
    careful to check for fully initialized ata ports.
    
    Acked-by: Jack Wang <jack_wang@usish.com>
    Acked-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index aa4270477563..42378d637ffb 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -996,6 +996,7 @@ extern int ata_sas_scsi_ioctl(struct ata_port *ap, struct scsi_device *dev,
 extern void ata_sas_port_destroy(struct ata_port *);
 extern struct ata_port *ata_sas_port_alloc(struct ata_host *,
 					   struct ata_port_info *, struct Scsi_Host *);
+extern int ata_sas_async_port_init(struct ata_port *);
 extern int ata_sas_port_init(struct ata_port *);
 extern int ata_sas_port_start(struct ata_port *ap);
 extern void ata_sas_port_stop(struct ata_port *ap);

commit 81c757bc696284f39f07766f0c2ca67af64ce9bd
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Dec 2 16:07:01 2011 -0800

    [SCSI] libsas: execute transport link resets with libata-eh via host workqueue
    
    Link resets leave ata affiliations intact, so arrange for libsas to make
    an effort to avoid dropping the device due to a slow-to-recover link.
    Towards this end carry out reset in the host workqueue so that it can
    check for ata devices and kick the reset request to libata.  Hard
    resets, in contrast, bypass libata since they are meant for associating
    an ata device with another initiator in the domain (tears down
    affiliations).
    
    Need to add a new transport_sas_phy_reset() since the current
    sas_phy_reset() is a utility function to libsas lldds.  They are not
    prepared for it to loop back into eh.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index cafc09a64fe4..aa4270477563 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1147,6 +1147,7 @@ static inline int ata_acpi_cbl_80wire(struct ata_port *ap,
  * EH - drivers/ata/libata-eh.c
  */
 extern void ata_port_schedule_eh(struct ata_port *ap);
+extern void ata_port_wait_eh(struct ata_port *ap);
 extern int ata_link_abort(struct ata_link *link);
 extern int ata_port_abort(struct ata_port *ap);
 extern int ata_port_freeze(struct ata_port *ap);

commit b9075fa968a0a4347aef35e235e2995c0e57dddd
Author: Joe Perches <joe@perches.com>
Date:   Mon Oct 31 17:11:33 2011 -0700

    treewide: use __printf not __attribute__((format(printf,...)))
    
    Standardize the style for compiler based printf format verification.
    Standardized the location of __printf too.
    
    Done via script and a little typing.
    
    $ grep -rPl --include=*.[ch] -w "__attribute__" * | \
      grep -vP "^(tools|scripts|include/linux/compiler-gcc.h)" | \
      xargs perl -n -i -e 'local $/; while (<>) { s/\b__attribute__\s*\(\s*\(\s*format\s*\(\s*printf\s*,\s*(.+)\s*,\s*(.+)\s*\)\s*\)\s*\)/__printf($1, $2)/g ; print; }'
    
    [akpm@linux-foundation.org: revert arch bits]
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: "Kirill A. Shutemov" <kirill@shutemov.name>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 23fa829bf7a3..cafc09a64fe4 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1256,13 +1256,13 @@ static inline int sata_srst_pmp(struct ata_link *link)
 /*
  * printk helpers
  */
-__attribute__((format (printf, 3, 4)))
+__printf(3, 4)
 int ata_port_printk(const struct ata_port *ap, const char *level,
 		    const char *fmt, ...);
-__attribute__((format (printf, 3, 4)))
+__printf(3, 4)
 int ata_link_printk(const struct ata_link *link, const char *level,
 		    const char *fmt, ...);
-__attribute__((format (printf, 3, 4)))
+__printf(3, 4)
 int ata_dev_printk(const struct ata_device *dev, const char *level,
 		   const char *fmt, ...);
 
@@ -1304,10 +1304,10 @@ void ata_print_version(const struct device *dev, const char *version);
 /*
  * ata_eh_info helpers
  */
-extern void __ata_ehi_push_desc(struct ata_eh_info *ehi, const char *fmt, ...)
-	__attribute__ ((format (printf, 2, 3)));
-extern void ata_ehi_push_desc(struct ata_eh_info *ehi, const char *fmt, ...)
-	__attribute__ ((format (printf, 2, 3)));
+extern __printf(2, 3)
+void __ata_ehi_push_desc(struct ata_eh_info *ehi, const char *fmt, ...);
+extern __printf(2, 3)
+void ata_ehi_push_desc(struct ata_eh_info *ehi, const char *fmt, ...);
 extern void ata_ehi_clear_desc(struct ata_eh_info *ehi);
 
 static inline void ata_ehi_hotplugged(struct ata_eh_info *ehi)
@@ -1321,8 +1321,8 @@ static inline void ata_ehi_hotplugged(struct ata_eh_info *ehi)
 /*
  * port description helpers
  */
-extern void ata_port_desc(struct ata_port *ap, const char *fmt, ...)
-	__attribute__ ((format (printf, 2, 3)));
+extern __printf(2, 3)
+void ata_port_desc(struct ata_port *ap, const char *fmt, ...);
 #ifdef CONFIG_PCI
 extern void ata_port_pbar_desc(struct ata_port *ap, int bar, ssize_t offset,
 			       const char *name);

commit f6e67035a9edd79b8b202c159d5bec560bb9c358
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Sep 20 15:10:33 2011 -0700

    [SCSI] libsas,libata: fix ->change_queue_{depth|type} for sata devices
    
    Pass queue_depth change requests to libata, and prevent queue_type
    changes for ATA devices.
    
    Otherwise:
    1/ we do not honor the libata specific restrictions on the queue depth
    2/ libsas drivers that do not set sdev->tagged_supported are unable to
       change the queue_depth of ata devices via sysfs
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index efd6f9800762..23fa829bf7a3 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1052,6 +1052,8 @@ extern int ata_scsi_slave_config(struct scsi_device *sdev);
 extern void ata_scsi_slave_destroy(struct scsi_device *sdev);
 extern int ata_scsi_change_queue_depth(struct scsi_device *sdev,
 				       int queue_depth, int reason);
+extern int __ata_change_queue_depth(struct ata_port *ap, struct scsi_device *sdev,
+				    int queue_depth, int reason);
 extern struct ata_device *ata_dev_pair(struct ata_device *adev);
 extern int ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
 extern void ata_scsi_port_error_handler(struct Scsi_Host *host, struct ata_port *ap);

commit 06296a1e684bcd40b9a28d5d8030809e4295528b
Author: Joe Perches <joe@perches.com>
Date:   Fri Apr 15 15:52:00 2011 -0700

    ata: Add and use ata_print_version_once
    
    Use a single mechanism to show driver version.
    Reduces text a tiny bit too.
    
    Remove uses of static int printed_version
    Add and use ata_print_version(const struct device *, const char *ver)
    and ata_print_version_once.
    
    $ size drivers/ata/built-in.*
       text    data     bss     dec     hex filename
     544969   73893  116584  735446   b38d6 drivers/ata/built-in.allyesconfig.ata.o
     543870   73893  116592  734355   b34ad drivers/ata/built-in.allyesconfig.print_once.o
     141328   14689    4220  160237   271ed drivers/ata/built-in.defconfig.ata.o
     141212   14689    4220  160121   27179 drivers/ata/built-in.defconfig.print_once.o
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 4e72a6af70b5..efd6f9800762 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -74,6 +74,16 @@
 
 #define BPRINTK(fmt, args...) if (ap->flags & ATA_FLAG_DEBUGMSG) printk(KERN_ERR "%s: " fmt, __func__, ## args)
 
+#define ata_print_version_once(dev, version)			\
+({								\
+	static bool __print_once;				\
+								\
+	if (!__print_once) {					\
+		__print_once = true;				\
+		ata_print_version(dev, version);		\
+	}							\
+})
+
 /* NEW: debug levels */
 #define HAVE_LIBATA_MSG 1
 
@@ -1287,6 +1297,8 @@ int ata_dev_printk(const struct ata_device *dev, const char *level,
 #define ata_dev_dbg(dev, fmt, ...)				\
 	ata_dev_printk(dev, KERN_DEBUG, fmt, ##__VA_ARGS__)
 
+void ata_print_version(const struct device *dev, const char *version);
+
 /*
  * ata_eh_info helpers
  */

commit a9a79dfec239568bdbf778242f8fcd10bcc5b9e2
Author: Joe Perches <joe@perches.com>
Date:   Fri Apr 15 15:51:59 2011 -0700

    ata: Convert ata_<foo>_printk(KERN_<LEVEL> to ata_<foo>_<level>
    
    Saves text by removing nearly duplicated text format strings by
    creating ata_<foo>_printk functions and printf extension %pV.
    
    ata defconfig size shrinks ~5% (~8KB), allyesconfig ~2.5% (~13KB)
    
    Format string duplication comes from:
    
     #define ata_link_printk(link, lv, fmt, args...) do { \
           if (sata_pmp_attached((link)->ap) || (link)->ap->slave_link)    \
                   printk("%sata%u.%02u: "fmt, lv, (link)->ap->print_id,   \
                          (link)->pmp , ##args); \
           else \
                   printk("%sata%u: "fmt, lv, (link)->ap->print_id , ##args); \
           } while(0)
    
    Coalesce long formats.
    
    $ size drivers/ata/built-in.*
       text    data     bss     dec     hex filename
     544969   73893  116584  735446   b38d6 drivers/ata/built-in.allyesconfig.ata.o
     558429   73893  117864  750186   b726a drivers/ata/built-in.allyesconfig.dev_level.o
     141328   14689    4220  160237   271ed drivers/ata/built-in.defconfig.ata.o
     149567   14689    4220  168476   2921c drivers/ata/built-in.defconfig.dev_level.o
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 5a9926b34072..4e72a6af70b5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1244,20 +1244,48 @@ static inline int sata_srst_pmp(struct ata_link *link)
 /*
  * printk helpers
  */
-#define ata_port_printk(ap, lv, fmt, args...) \
-	printk("%sata%u: "fmt, lv, (ap)->print_id , ##args)
-
-#define ata_link_printk(link, lv, fmt, args...) do { \
-	if (sata_pmp_attached((link)->ap) || (link)->ap->slave_link)	\
-		printk("%sata%u.%02u: "fmt, lv, (link)->ap->print_id,	\
-		       (link)->pmp , ##args); \
-	else \
-		printk("%sata%u: "fmt, lv, (link)->ap->print_id , ##args); \
-	} while(0)
-
-#define ata_dev_printk(dev, lv, fmt, args...) \
-	printk("%sata%u.%02u: "fmt, lv, (dev)->link->ap->print_id,	\
-	       (dev)->link->pmp + (dev)->devno , ##args)
+__attribute__((format (printf, 3, 4)))
+int ata_port_printk(const struct ata_port *ap, const char *level,
+		    const char *fmt, ...);
+__attribute__((format (printf, 3, 4)))
+int ata_link_printk(const struct ata_link *link, const char *level,
+		    const char *fmt, ...);
+__attribute__((format (printf, 3, 4)))
+int ata_dev_printk(const struct ata_device *dev, const char *level,
+		   const char *fmt, ...);
+
+#define ata_port_err(ap, fmt, ...)				\
+	ata_port_printk(ap, KERN_ERR, fmt, ##__VA_ARGS__)
+#define ata_port_warn(ap, fmt, ...)				\
+	ata_port_printk(ap, KERN_WARNING, fmt, ##__VA_ARGS__)
+#define ata_port_notice(ap, fmt, ...)				\
+	ata_port_printk(ap, KERN_NOTICE, fmt, ##__VA_ARGS__)
+#define ata_port_info(ap, fmt, ...)				\
+	ata_port_printk(ap, KERN_INFO, fmt, ##__VA_ARGS__)
+#define ata_port_dbg(ap, fmt, ...)				\
+	ata_port_printk(ap, KERN_DEBUG, fmt, ##__VA_ARGS__)
+
+#define ata_link_err(link, fmt, ...)				\
+	ata_link_printk(link, KERN_ERR, fmt, ##__VA_ARGS__)
+#define ata_link_warn(link, fmt, ...)				\
+	ata_link_printk(link, KERN_WARNING, fmt, ##__VA_ARGS__)
+#define ata_link_notice(link, fmt, ...)				\
+	ata_link_printk(link, KERN_NOTICE, fmt, ##__VA_ARGS__)
+#define ata_link_info(link, fmt, ...)				\
+	ata_link_printk(link, KERN_INFO, fmt, ##__VA_ARGS__)
+#define ata_link_dbg(link, fmt, ...)				\
+	ata_link_printk(link, KERN_DEBUG, fmt, ##__VA_ARGS__)
+
+#define ata_dev_err(dev, fmt, ...)				\
+	ata_dev_printk(dev, KERN_ERR, fmt, ##__VA_ARGS__)
+#define ata_dev_warn(dev, fmt, ...)				\
+	ata_dev_printk(dev, KERN_WARNING, fmt, ##__VA_ARGS__)
+#define ata_dev_notice(dev, fmt, ...)				\
+	ata_dev_printk(dev, KERN_NOTICE, fmt, ##__VA_ARGS__)
+#define ata_dev_info(dev, fmt, ...)				\
+	ata_dev_printk(dev, KERN_INFO, fmt, ##__VA_ARGS__)
+#define ata_dev_dbg(dev, fmt, ...)				\
+	ata_dev_printk(dev, KERN_DEBUG, fmt, ##__VA_ARGS__)
 
 /*
  * ata_eh_info helpers

commit 8a745f1f39b7a20047a362b67ce9151c07d14440
Author: Kristen Carlson Accardi <kristen@linux.intel.com>
Date:   Fri Mar 4 10:24:11 2011 -0800

    libata: Power off empty ports
    
    Give users the option of completely powering off unoccupied
    SATA ports using the existing min_power link_power_management_policy
    option.  When the use selects this option on an empty port, we
    will power the port off by setting DET to off.  For occupied ports,
    behavior is unchanged.
    
    Signed-off-by: Kristen Carlson Accardi <kristen@linux.intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 04f32a3eb26b..5a9926b34072 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1151,6 +1151,7 @@ extern void ata_do_eh(struct ata_port *ap, ata_prereset_fn_t prereset,
 		      ata_reset_fn_t softreset, ata_reset_fn_t hardreset,
 		      ata_postreset_fn_t postreset);
 extern void ata_std_error_handler(struct ata_port *ap);
+extern int ata_link_nr_enabled(struct ata_link *link);
 
 /*
  * Base operations to inherit from and initializers for sht

commit ae01b2493c3bf03c504c32ac4ebb01d528508db3
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 16 11:14:55 2011 +0100

    libata: Implement ATA_FLAG_NO_DIPM and apply it to mcp65
    
    NVIDIA mcp65 familiy of controllers cause command timeouts when DIPM
    is used.  Implement ATA_FLAG_NO_DIPM and apply it.
    
    This problem was reported by Stefan Bader in the following thread.
    
     http://thread.gmane.org/gmane.linux.ide/48841
    
    stable: applicable to 2.6.37 and 38.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Stefan Bader <stefan.bader@canonical.com>
    Cc: stable@kernel.org
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 3b4d223a6aff..04f32a3eb26b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -196,6 +196,7 @@ enum {
 					      * management */
 	ATA_FLAG_SW_ACTIVITY	= (1 << 22), /* driver supports sw activity
 					      * led */
+	ATA_FLAG_NO_DIPM	= (1 << 23), /* host not happy with DIPM */
 
 	/* bits 24:31 of ap->flags are reserved for LLD specific flags */
 

commit 3f7ac1d6671ebca7a955853f7127c937f7befbd3
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 16 11:14:25 2011 +0100

    libata: Kill unused ATA_DFLAG_{H|D}IPM flags
    
    ATA_DFLAG_{H|D}IPM flags are no longer used.  Kill them.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 7f675aa81d87..3b4d223a6aff 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -137,8 +137,6 @@ enum {
 	ATA_DFLAG_ACPI_PENDING	= (1 << 5), /* ACPI resume action pending */
 	ATA_DFLAG_ACPI_FAILED	= (1 << 6), /* ACPI on devcfg has failed */
 	ATA_DFLAG_AN		= (1 << 7), /* AN configured */
-	ATA_DFLAG_HIPM		= (1 << 8), /* device supports HIPM */
-	ATA_DFLAG_DIPM		= (1 << 9), /* device supports DIPM */
 	ATA_DFLAG_DMADIR	= (1 << 10), /* device requires DMADIR */
 	ATA_DFLAG_CFG_MASK	= (1 << 12) - 1,
 

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c71f46960f39..7f675aa81d87 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -364,7 +364,7 @@ enum {
 	ATA_EH_CMD_TIMEOUT_TABLE_SIZE = 6,
 
 	/* Horkage types. May be set by libata or controller on drives
-	   (some horkage may be drive/controller pair dependant */
+	   (some horkage may be drive/controller pair dependent */
 
 	ATA_HORKAGE_DIAGNOSTIC	= (1 << 0),	/* Failed boot diag */
 	ATA_HORKAGE_NODMA	= (1 << 1),	/* DMA problems */

commit 64b97594251bb909d74d64012a2b9e5cc32bb11d
Author: Viresh Kumar <viresh.kumar@st.com>
Date:   Tue Feb 22 14:32:38 2011 +0530

    libata-sff: add ata_sff_queue_work() & ata_sff_queue_delayed_work()
    
    This patch adds ata_sff_queue_work() & ata_sff_queue_delayed_work() routine in
    libata-sff.c file. This routine can be used by ata drivers to use ata_sff_wq.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@st.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 71333aa39532..c71f46960f39 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1610,6 +1610,9 @@ extern void ata_sff_irq_on(struct ata_port *ap);
 extern void ata_sff_irq_clear(struct ata_port *ap);
 extern int ata_sff_hsm_move(struct ata_port *ap, struct ata_queued_cmd *qc,
 			    u8 status, int in_wq);
+extern void ata_sff_queue_work(struct work_struct *work);
+extern void ata_sff_queue_delayed_work(struct delayed_work *dwork,
+		unsigned long delay);
 extern void ata_sff_queue_pio_task(struct ata_link *link, unsigned long delay);
 extern unsigned int ata_sff_qc_issue(struct ata_queued_cmd *qc);
 extern bool ata_sff_qc_fill_rtf(struct ata_queued_cmd *qc);

commit 1a0f6b7ecdcd810f8991ea26c95d93ff965e8f41
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Fri Feb 4 22:08:22 2011 +0300

    libata: remove ATA_FLAG_LPM
    
    Commit 6b7ae9545ad9875a289f4191c0216b473e313cb9 (libata: reimplement link power
    management) removed the check of ATA_FLAG_LPM but neglected to remove the flag
    itself.  Do it now...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 26d80479c75f..71333aa39532 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -194,7 +194,6 @@ enum {
 	ATA_FLAG_ACPI_SATA	= (1 << 17), /* need native SATA ACPI layout */
 	ATA_FLAG_AN		= (1 << 18), /* controller supports AN */
 	ATA_FLAG_PMP		= (1 << 19), /* controller supports PMP */
-	ATA_FLAG_LPM		= (1 << 20), /* driver can handle LPM */
 	ATA_FLAG_EM		= (1 << 21), /* driver supports enclosure
 					      * management */
 	ATA_FLAG_SW_ACTIVITY	= (1 << 22), /* driver supports sw activity

commit 9cbe056f6c467e7395d5aec39aceec47812eb98e
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Fri Feb 4 22:05:48 2011 +0300

    libata: remove ATA_FLAG_NO_LEGACY
    
    All checks of ATA_FLAG_NO_LEGACY have been removed by the commits
    c791c30670ea61f19eec390124128bf278e854fe ([libata] minor PCI IDE probe
    fixes and cleanups) and f0d36efdc624beb3d9e29b9ab9e9537bf0f25d5b (libata:
    update libata core layer to use devres), so I think it's time to finally
    get rid of this flag...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 0c3d9e144891..26d80479c75f 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -179,7 +179,6 @@ enum {
 	ATA_FLAG_SLAVE_POSS	= (1 << 0), /* host supports slave dev */
 					    /* (doesn't imply presence) */
 	ATA_FLAG_SATA		= (1 << 1),
-	ATA_FLAG_NO_LEGACY	= (1 << 2), /* no legacy mode check */
 	ATA_FLAG_NO_ATAPI	= (1 << 6), /* No ATAPI support */
 	ATA_FLAG_PIO_DMA	= (1 << 7), /* PIO cmds via DMA */
 	ATA_FLAG_PIO_LBA48	= (1 << 8), /* Host DMA engine is LBA28 only */

commit 3696df309971b3427cb9cb039138a1732a865a0b
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Fri Feb 4 22:04:17 2011 +0300

    libata: remove ATA_FLAG_MMIO
    
    Commit 0d5ff566779f894ca9937231a181eb31e4adff0e (libata: convert to iomap)
    removed all checks of ATA_FLAG_MMIO but neglected to remove the flag itself.
    Do it now, at last...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 51ec439f75ad..0c3d9e144891 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -180,7 +180,6 @@ enum {
 					    /* (doesn't imply presence) */
 	ATA_FLAG_SATA		= (1 << 1),
 	ATA_FLAG_NO_LEGACY	= (1 << 2), /* no legacy mode check */
-	ATA_FLAG_MMIO		= (1 << 3), /* use MMIO, not PIO */
 	ATA_FLAG_NO_ATAPI	= (1 << 6), /* No ATAPI support */
 	ATA_FLAG_PIO_DMA	= (1 << 7), /* PIO cmds via DMA */
 	ATA_FLAG_PIO_LBA48	= (1 << 8), /* Host DMA engine is LBA28 only */

commit c10f97b9d8df818e51e6073be1b96454630595c1
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Fri Feb 4 22:03:34 2011 +0300

    libata: remove ATA_FLAG_{SRST|SATA_RESET}
    
    These flags are marked as obsolete and the checks for them have been removed
    by commit 294440887b32c58d220fb54b73b7a58079b78f20 (libata-sff: kill unused
    ata_bus_reset()), so I think it's time to finally get rid of them...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 9739317c707a..51ec439f75ad 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -181,8 +181,6 @@ enum {
 	ATA_FLAG_SATA		= (1 << 1),
 	ATA_FLAG_NO_LEGACY	= (1 << 2), /* no legacy mode check */
 	ATA_FLAG_MMIO		= (1 << 3), /* use MMIO, not PIO */
-	ATA_FLAG_SRST		= (1 << 4), /* (obsolete) use ATA SRST, not E.D.D. */
-	ATA_FLAG_SATA_RESET	= (1 << 5), /* (obsolete) use COMRESET */
 	ATA_FLAG_NO_ATAPI	= (1 << 6), /* No ATAPI support */
 	ATA_FLAG_PIO_DMA	= (1 << 7), /* PIO cmds via DMA */
 	ATA_FLAG_PIO_LBA48	= (1 << 8), /* Host DMA engine is LBA28 only */

commit 0e0b494ca8c54a7297d0cc549405091019b3b77e
Author: James Bottomley <James.Bottomley@suse.de>
Date:   Sun Jan 23 09:42:50 2011 -0600

    libata: separate error handler into usable components
    
    Right at the moment, the libata error handler is incredibly
    monolithic.  This makes it impossible to use from composite drivers
    like libsas and ipr which have to handle error themselves in the first
    instance.
    
    The essence of the change is to split the monolithic error handler
    into two components: one which handles a queue of ata commands for
    processing and the other which handles the back end of readying a
    port.  This allows the upper error handler fine grained control in
    calling libsas functions (and making sure they only get called for ATA
    commands whose lower errors have been fixed up).
    
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c9c5d7ad1a2b..9739317c707a 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1050,6 +1050,8 @@ extern int ata_scsi_change_queue_depth(struct scsi_device *sdev,
 				       int queue_depth, int reason);
 extern struct ata_device *ata_dev_pair(struct ata_device *adev);
 extern int ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
+extern void ata_scsi_port_error_handler(struct Scsi_Host *host, struct ata_port *ap);
+extern void ata_scsi_cmd_error_handler(struct Scsi_Host *host, struct ata_port *ap, struct list_head *eh_q);
 
 extern int ata_cable_40wire(struct ata_port *ap);
 extern int ata_cable_80wire(struct ata_port *ap);

commit b27dcfb0670ea7352a67137f4ff7947c2a9f6892
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Nov 17 22:56:48 2010 -0500

    [libata] avoid needlessly passing around ptr to SCSI completion func
    
    It's stored in struct scsi_cmnd->scsi_done, making several 'done'
    parameters to functions redundant.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d947b1231662..c9c5d7ad1a2b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -996,8 +996,7 @@ extern int ata_sas_port_init(struct ata_port *);
 extern int ata_sas_port_start(struct ata_port *ap);
 extern void ata_sas_port_stop(struct ata_port *ap);
 extern int ata_sas_slave_configure(struct scsi_device *, struct ata_port *);
-extern int ata_sas_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *),
-			    struct ata_port *ap);
+extern int ata_sas_queuecmd(struct scsi_cmnd *cmd, struct ata_port *ap);
 extern int sata_scr_valid(struct ata_link *link);
 extern int sata_scr_read(struct ata_link *link, int reg, u32 *val);
 extern int sata_scr_write(struct ata_link *link, int reg, u32 val);
@@ -1040,8 +1039,7 @@ extern unsigned int ata_do_dev_read_id(struct ata_device *dev,
 					struct ata_taskfile *tf, u16 *id);
 extern void ata_qc_complete(struct ata_queued_cmd *qc);
 extern int ata_qc_complete_multiple(struct ata_port *ap, u32 qc_active);
-extern void ata_scsi_simulate(struct ata_device *dev, struct scsi_cmnd *cmd,
-			      void (*done)(struct scsi_cmnd *));
+extern void ata_scsi_simulate(struct ata_device *dev, struct scsi_cmnd *cmd);
 extern int ata_std_bios_param(struct scsi_device *sdev,
 			      struct block_device *bdev,
 			      sector_t capacity, int geom[]);

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 15b77b8dc7e1..d947b1231662 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -986,7 +986,7 @@ extern void ata_host_init(struct ata_host *, struct device *,
 			  unsigned long, struct ata_port_operations *);
 extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
-extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));
+extern int ata_scsi_queuecmd(struct Scsi_Host *h, struct scsi_cmnd *cmd);
 extern int ata_sas_scsi_ioctl(struct ata_port *ap, struct scsi_device *dev,
 			    int cmd, void __user *arg);
 extern void ata_sas_port_destroy(struct ata_port *);

commit 89692c03226a066a017048cf7fbacbaa645f0e79
Author: Andrea Gelmini <andrea.gelmini@gelma.net>
Date:   Sat Oct 16 15:19:18 2010 +0200

    include/linux/libata.h: fix typo
    
    Signed-off-by: Andrea Gelmini <andrea.gelmini@gelma.net>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 15efec05df67..15b77b8dc7e1 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -342,7 +342,7 @@ enum {
 	ATA_EHI_DID_HARDRESET	= (1 << 17), /* already soft-reset this port */
 	ATA_EHI_PRINTINFO	= (1 << 18), /* print configuration info */
 	ATA_EHI_SETMODE		= (1 << 19), /* configure transfer mode */
-	ATA_EHI_POST_SETMODE	= (1 << 20), /* revaildating after setmode */
+	ATA_EHI_POST_SETMODE	= (1 << 20), /* revalidating after setmode */
 
 	ATA_EHI_DID_RESET	= ATA_EHI_DID_SOFTRESET | ATA_EHI_DID_HARDRESET,
 

commit b34e90429ce8a23546b6b927d4e151df4c113644
Author: Richard Kennedy <richard@rsk.demon.co.uk>
Date:   Fri Sep 10 12:19:43 2010 +0100

    libata: reorder ata_queued_cmd to remove alignment padding on 64 bit builds
    
    Reorder structure ata_queued_cmd to remove 8 bytes of alignment padding
    on 64 bit builds & therefore reduce the size of structure ata_port by
    256 bytes.
    
    Overall this will have little impact, other than reducing the amount of
    memory that is cleared when allocating ata_ports.
    
    Signed-off-by: Richard Kennedy <richard@rsk.demon.co.uk>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 52112d39d71e..15efec05df67 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -570,13 +570,13 @@ struct ata_queued_cmd {
 	unsigned int		extrabytes;
 	unsigned int		curbytes;
 
-	struct scatterlist	*cursg;
-	unsigned int		cursg_ofs;
-
 	struct scatterlist	sgent;
 
 	struct scatterlist	*sg;
 
+	struct scatterlist	*cursg;
+	unsigned int		cursg_ofs;
+
 	unsigned int		err_mask;
 	struct ata_taskfile	result_tf;
 	ata_qc_cb_t		complete_fn;

commit c0c362b60e259e3480a36ef70280d545818844f0
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Sep 6 17:57:14 2010 +0200

    libata: implement cross-port EH exclusion
    
    In libata, the non-EH code paths should always take and release
    ap->lock explicitly when accessing hardware or shared data structures.
    However, once EH is active, it's assumed that the port is owned by EH
    and EH methods don't explicitly take ap->lock unless race from irq
    handler or other code paths are expected.  However, libata EH didn't
    guarantee exclusion among EHs for ports of the same host.  IOW,
    multiple EHs may execute in parallel on multiple ports of the same
    controller.
    
    In many cases, especially in SATA, the ports are completely
    independent of each other and this doesn't cause problems; however,
    there are cases where different ports share the same resource, which
    lead to obscure timing related bugs such as the one fixed by commit
    213373cf (ata_piix: fix locking around SIDPR access).
    
    This patch implements exclusion among EHs of the same host.  When EH
    begins, it acquires per-host EH ownership by calling ata_eh_acquire().
    When EH finishes, the ownership is released by calling
    ata_eh_release().  EH ownership is also released whenever the EH
    thread goes to sleep from ata_msleep() or explicitly and reacquired
    after waking up.
    
    This ensures that while EH is actively accessing the hardware, it has
    exclusive access to it while allowing EHs to interleave and progress
    in parallel as they hit waiting stages, which dominate the time spent
    in EH.  This achieves cross-port EH exclusion without pervasive and
    fragile changes while still allowing parallel EH for the most part.
    
    This was first reported by yuanding02@gmail.com more than three years
    ago in the following bugzilla.  :-)
    
      https://bugzilla.kernel.org/show_bug.cgi?id=8223
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Reported-by: yuanding02@gmail.com
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 2fbd22bd68ce..52112d39d71e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -37,6 +37,7 @@
 #include <scsi/scsi_host.h>
 #include <linux/acpi.h>
 #include <linux/cdrom.h>
+#include <linux/sched.h>
 
 /*
  * Define if arch has non-standard setup.  This is a _PCI_ standard
@@ -535,6 +536,10 @@ struct ata_host {
 	void			*private_data;
 	struct ata_port_operations *ops;
 	unsigned long		flags;
+
+	struct mutex		eh_mutex;
+	struct task_struct	*eh_owner;
+
 #ifdef CONFIG_ATA_ACPI
 	acpi_handle		acpi_handle;
 #endif

commit 97750cebb3000a9cc08f8ce8dc8c7143be7d7201
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Sep 6 17:56:29 2010 +0200

    libata: add @ap to ata_wait_register() and introduce ata_msleep()
    
    Add optional @ap argument to ata_wait_register() and replace msleep()
    calls with ata_msleep() which take optional @ap in addition to the
    duration.  These will be used to implement EH exclusion.
    
    This patch doesn't cause any behavior difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index bc4ee218b185..2fbd22bd68ce 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1004,8 +1004,9 @@ extern int ata_host_suspend(struct ata_host *host, pm_message_t mesg);
 extern void ata_host_resume(struct ata_host *host);
 #endif
 extern int ata_ratelimit(void);
-extern u32 ata_wait_register(void __iomem *reg, u32 mask, u32 val,
-			     unsigned long interval, unsigned long timeout);
+extern void ata_msleep(struct ata_port *ap, unsigned int msecs);
+extern u32 ata_wait_register(struct ata_port *ap, void __iomem *reg, u32 mask,
+			u32 val, unsigned long interval, unsigned long timeout);
 extern int atapi_cmd_type(u8 opcode);
 extern void ata_tf_to_fis(const struct ata_taskfile *tf,
 			  u8 pmp, int is_cmd, u8 *fis);

commit 6b7ae9545ad9875a289f4191c0216b473e313cb9
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 1 17:50:06 2010 +0200

    libata: reimplement link power management
    
    The current LPM implementation has the following issues.
    
    * Operation order isn't well thought-out.  e.g. HIPM should be
      configured after IPM in SControl is properly configured.  Not the
      other way around.
    
    * Suspend/resume paths call ata_lpm_enable/disable() which must only
      be called from EH context directly.  Also, ata_lpm_enable/disable()
      were called whether LPM was in use or not.
    
    * Implementation is per-port when it should be per-link.  As a result,
      it can't be used for controllers with slave links or PMP.
    
    * LPM state isn't managed consistently.  After a link reset for
      whatever reason including suspend/resume the actual LPM state would
      be reset leaving ap->lpm_policy inconsistent.
    
    * Generic/driver-specific logic boundary isn't clear.  Currently,
      libahci has to mangle stuff which libata EH proper should be
      handling.  This makes the implementation unnecessarily complex and
      fragile.
    
    * Tied to ALPM.  Doesn't consider DIPM only cases and doesn't check
      whether the device allows HIPM.
    
    * Error handling isn't implemented.
    
    Given the extent of mismatch with the rest of libata, I don't think
    trying to fix it piecewise makes much sense.  This patch reimplements
    LPM support.
    
    * The new implementation is per-link.  The target policy is still
      port-wide (ap->target_lpm_policy) but all the mechanisms and states
      are per-link and integrate well with the rest of link abstraction
      and can work with slave and PMP links.
    
    * Core EH has proper control of LPM state.  LPM state is reconfigured
      when and only when reconfiguration is necessary.  It makes sure that
      LPM state is reset when probing for new device on the link.
      Controller agnostic logic is now implemented in libata EH proper and
      driver implementation only has to deal with controller specifics.
    
    * Proper error handling.  LPM config failure is attributed to the
      device on the link and LPM is disabled for the link if it fails
      repeatedly.
    
    * ops->enable/disable_pm() are replaced with single ops->set_lpm()
      which takes @policy and @hints.  This simplifies driver specific
      implementation.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 7770eeb21039..bc4ee218b185 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -172,6 +172,7 @@ enum {
 	ATA_LFLAG_NO_RETRY	= (1 << 5), /* don't retry this link */
 	ATA_LFLAG_DISABLED	= (1 << 6), /* link is disabled */
 	ATA_LFLAG_SW_ACTIVITY	= (1 << 7), /* keep activity stats */
+	ATA_LFLAG_NO_LPM	= (1 << 8), /* disable LPM on this link */
 
 	/* struct ata_port flags */
 	ATA_FLAG_SLAVE_POSS	= (1 << 0), /* host supports slave dev */
@@ -324,12 +325,11 @@ enum {
 	ATA_EH_HARDRESET	= (1 << 2), /* meaningful only in ->prereset */
 	ATA_EH_RESET		= ATA_EH_SOFTRESET | ATA_EH_HARDRESET,
 	ATA_EH_ENABLE_LINK	= (1 << 3),
-	ATA_EH_LPM		= (1 << 4),  /* link power management action */
 	ATA_EH_PARK		= (1 << 5), /* unload heads and stop I/O */
 
 	ATA_EH_PERDEV_MASK	= ATA_EH_REVALIDATE | ATA_EH_PARK,
 	ATA_EH_ALL_ACTIONS	= ATA_EH_REVALIDATE | ATA_EH_RESET |
-				  ATA_EH_ENABLE_LINK | ATA_EH_LPM,
+				  ATA_EH_ENABLE_LINK,
 
 	/* ata_eh_info->flags */
 	ATA_EHI_HOTPLUGGED	= (1 << 0),  /* could have been hotplugged */
@@ -377,7 +377,6 @@ enum {
 	ATA_HORKAGE_BROKEN_HPA	= (1 << 4),	/* Broken HPA */
 	ATA_HORKAGE_DISABLE	= (1 << 5),	/* Disable it */
 	ATA_HORKAGE_HPA_SIZE	= (1 << 6),	/* native size off by one */
-	ATA_HORKAGE_LPM		= (1 << 7),	/* Link PM problems */
 	ATA_HORKAGE_IVB		= (1 << 8),	/* cbl det validity bit bugs */
 	ATA_HORKAGE_STUCK_ERR	= (1 << 9),	/* stuck ERR on next PACKET */
 	ATA_HORKAGE_BRIDGE_OK	= (1 << 10),	/* no bridge limits */
@@ -475,6 +474,11 @@ enum ata_lpm_policy {
 	ATA_LPM_MIN_POWER,
 };
 
+enum ata_lpm_hints {
+	ATA_LPM_EMPTY		= (1 << 0), /* port empty/probing */
+	ATA_LPM_HIPM		= (1 << 1), /* may use HIPM */
+};
+
 /* forward declarations */
 struct scsi_device;
 struct ata_port_operations;
@@ -702,6 +706,7 @@ struct ata_link {
 	unsigned int		hw_sata_spd_limit;
 	unsigned int		sata_spd_limit;
 	unsigned int		sata_spd;	/* current SATA PHY speed */
+	enum ata_lpm_policy	lpm_policy;
 
 	/* record runtime error info, protected by host_set lock */
 	struct ata_eh_info	eh_info;
@@ -773,7 +778,7 @@ struct ata_port {
 
 	pm_message_t		pm_mesg;
 	int			*pm_result;
-	enum ata_lpm_policy	lpm_policy;
+	enum ata_lpm_policy	target_lpm_policy;
 
 	struct timer_list	fastdrain_timer;
 	unsigned long		fastdrain_cnt;
@@ -839,8 +844,8 @@ struct ata_port_operations {
 	int  (*scr_write)(struct ata_link *link, unsigned int sc_reg, u32 val);
 	void (*pmp_attach)(struct ata_port *ap);
 	void (*pmp_detach)(struct ata_port *ap);
-	int  (*enable_pm)(struct ata_port *ap, enum ata_lpm_policy policy);
-	void (*disable_pm)(struct ata_port *ap);
+	int  (*set_lpm)(struct ata_link *link, enum ata_lpm_policy policy,
+			unsigned hints);
 
 	/*
 	 * Start, stop, suspend and resume

commit 1152b2617a6e1943b6b82e07c962950e56f1000c
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 1 17:50:05 2010 +0200

    libata: implement sata_link_scr_lpm() and make ata_dev_set_feature() global
    
    Link power management is about to be reimplemented.  Prepare for it.
    
    * Implement sata_link_scr_lpm().
    
    * Drop static from ata_dev_set_feature() and make it available to
      other libata files.
    
    * Trivial whitespace adjustments.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c5bdc90fd319..7770eeb21039 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -952,6 +952,8 @@ extern int sata_link_debounce(struct ata_link *link,
 			const unsigned long *params, unsigned long deadline);
 extern int sata_link_resume(struct ata_link *link, const unsigned long *params,
 			    unsigned long deadline);
+extern int sata_link_scr_lpm(struct ata_link *link, enum ata_lpm_policy policy,
+			     bool spm_wakeup);
 extern int sata_link_hardreset(struct ata_link *link,
 			const unsigned long *timing, unsigned long deadline,
 			bool *online, int (*check_ready)(struct ata_link *));

commit c93b263e0d4fa8ce5fec0142a98196d1a127e845
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 1 17:50:04 2010 +0200

    libata: clean up lpm related symbols and sysfs show/store functions
    
    Link power management related symbols are in confusing state w/ mixed
    usages of lpm, ipm and pm.  This patch cleans up lpm related symbols
    and sysfs show/store functions as follows.
    
    * lpm states - NOT_AVAILABLE, MIN_POWER, MAX_PERFORMANCE and
      MEDIUM_POWER are renamed to ATA_LPM_UNKNOWN and
      ATA_LPM_{MIN|MAX|MED}_POWER.
    
    * Pre/postfixes are unified to lpm.
    
    * sysfs show/store functions for link_power_management_policy were
      curiously named get/put and unnecessarily complex.  Renamed to
      show/store and simplified.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c50f66d4382c..c5bdc90fd319 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -196,7 +196,7 @@ enum {
 	ATA_FLAG_ACPI_SATA	= (1 << 17), /* need native SATA ACPI layout */
 	ATA_FLAG_AN		= (1 << 18), /* controller supports AN */
 	ATA_FLAG_PMP		= (1 << 19), /* controller supports PMP */
-	ATA_FLAG_IPM		= (1 << 20), /* driver can handle IPM */
+	ATA_FLAG_LPM		= (1 << 20), /* driver can handle LPM */
 	ATA_FLAG_EM		= (1 << 21), /* driver supports enclosure
 					      * management */
 	ATA_FLAG_SW_ACTIVITY	= (1 << 22), /* driver supports sw activity
@@ -377,7 +377,7 @@ enum {
 	ATA_HORKAGE_BROKEN_HPA	= (1 << 4),	/* Broken HPA */
 	ATA_HORKAGE_DISABLE	= (1 << 5),	/* Disable it */
 	ATA_HORKAGE_HPA_SIZE	= (1 << 6),	/* native size off by one */
-	ATA_HORKAGE_IPM		= (1 << 7),	/* Link PM problems */
+	ATA_HORKAGE_LPM		= (1 << 7),	/* Link PM problems */
 	ATA_HORKAGE_IVB		= (1 << 8),	/* cbl det validity bit bugs */
 	ATA_HORKAGE_STUCK_ERR	= (1 << 9),	/* stuck ERR on next PACKET */
 	ATA_HORKAGE_BRIDGE_OK	= (1 << 10),	/* no bridge limits */
@@ -464,6 +464,17 @@ enum ata_completion_errors {
 	AC_ERR_NCQ		= (1 << 10), /* marker for offending NCQ qc */
 };
 
+/*
+ * Link power management policy: If you alter this, you also need to
+ * alter libata-scsi.c (for the ascii descriptions)
+ */
+enum ata_lpm_policy {
+	ATA_LPM_UNKNOWN,
+	ATA_LPM_MAX_POWER,
+	ATA_LPM_MED_POWER,
+	ATA_LPM_MIN_POWER,
+};
+
 /* forward declarations */
 struct scsi_device;
 struct ata_port_operations;
@@ -478,16 +489,6 @@ typedef int (*ata_reset_fn_t)(struct ata_link *link, unsigned int *classes,
 			      unsigned long deadline);
 typedef void (*ata_postreset_fn_t)(struct ata_link *link, unsigned int *classes);
 
-/*
- * host pm policy: If you alter this, you also need to alter libata-scsi.c
- * (for the ascii descriptions)
- */
-enum link_pm {
-	NOT_AVAILABLE,
-	MIN_POWER,
-	MAX_PERFORMANCE,
-	MEDIUM_POWER,
-};
 extern struct device_attribute dev_attr_link_power_management_policy;
 extern struct device_attribute dev_attr_unload_heads;
 extern struct device_attribute dev_attr_em_message_type;
@@ -772,7 +773,7 @@ struct ata_port {
 
 	pm_message_t		pm_mesg;
 	int			*pm_result;
-	enum link_pm		pm_policy;
+	enum ata_lpm_policy	lpm_policy;
 
 	struct timer_list	fastdrain_timer;
 	unsigned long		fastdrain_cnt;
@@ -838,7 +839,7 @@ struct ata_port_operations {
 	int  (*scr_write)(struct ata_link *link, unsigned int sc_reg, u32 val);
 	void (*pmp_attach)(struct ata_port *ap);
 	void (*pmp_detach)(struct ata_port *ap);
-	int  (*enable_pm)(struct ata_port *ap, enum link_pm policy);
+	int  (*enable_pm)(struct ata_port *ap, enum ata_lpm_policy policy);
 	void (*disable_pm)(struct ata_port *ap);
 
 	/*

commit d9027470b88631d0956ac37cdadfdeb9cdcf2c99
Author: Gwendal Grignou <gwendal@google.com>
Date:   Tue May 25 12:31:38 2010 -0700

    [libata] Add ATA transport class
    
    This is a scheleton for libata transport class.
    All information is read only, exporting information from libata:
    - ata_port class: one per ATA port
    - ata_link class: one per ATA port or 15 for SATA Port Multiplier
    - ata_device class: up to 2 for PATA link, usually one for SATA.
    
    Signed-off-by: Gwendal Grignou <gwendal@google.com>
    Reviewed-by: Grant Grundler <grundler@google.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 45fb2967b66d..c50f66d4382c 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -604,6 +604,7 @@ struct ata_device {
 	union acpi_object	*gtf_cache;
 	unsigned int		gtf_filter;
 #endif
+	struct device		tdev;
 	/* n_sector is CLEAR_BEGIN, read comment above CLEAR_BEGIN */
 	u64			n_sectors;	/* size of device, if ATA */
 	u64			n_native_sectors; /* native size, if ATA */
@@ -690,6 +691,7 @@ struct ata_link {
 	struct ata_port		*ap;
 	int			pmp;		/* port multiplier port # */
 
+	struct device		tdev;
 	unsigned int		active_tag;	/* active tag on this link */
 	u32			sactive;	/* active NCQ commands */
 
@@ -707,6 +709,8 @@ struct ata_link {
 
 	struct ata_device	device[ATA_MAX_DEVICES];
 };
+#define ATA_LINK_CLEAR_BEGIN		offsetof(struct ata_link, active_tag)
+#define ATA_LINK_CLEAR_END		offsetof(struct ata_link, device[0])
 
 struct ata_port {
 	struct Scsi_Host	*scsi_host; /* our co-allocated scsi host */
@@ -752,6 +756,7 @@ struct ata_port {
 	struct ata_port_stats	stats;
 	struct ata_host		*host;
 	struct device 		*dev;
+	struct device		tdev;
 
 	struct mutex		scsi_scan_mutex;
 	struct delayed_work	hotplug_task;

commit ea3c64506ea7965f86f030155e6fdef381de10e2
Author: Gwendal Grignou <gwendal@google.com>
Date:   Tue Aug 31 16:20:36 2010 -0700

    libata-sff: Reenable Port Multiplier after libata-sff remodeling.
    
    Keep track of the link on the which the current request is in progress.
    It allows support of links behind port multiplier.
    
    Not all libata-sff is PMP compliant. Code for native BMDMA controller
    does not take in accound PMP.
    
    Tested on Marvell 7042 and Sil7526.
    
    Signed-off-by: Gwendal Grignou <gwendal@google.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 7de282d8bedf..45fb2967b66d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -724,6 +724,7 @@ struct ata_port {
 	struct ata_ioports	ioaddr;	/* ATA cmd/ctl/dma register blocks */
 	u8			ctl;	/* cache of ATA control register */
 	u8			last_ctl;	/* Cache last written value */
+	struct ata_link*	sff_pio_task_link; /* link currently used */
 	struct delayed_work	sff_pio_task;
 #ifdef CONFIG_ATA_BMDMA
 	struct ata_bmdma_prd	*bmdma_prd;	/* BMDMA SG list */
@@ -1595,7 +1596,7 @@ extern void ata_sff_irq_on(struct ata_port *ap);
 extern void ata_sff_irq_clear(struct ata_port *ap);
 extern int ata_sff_hsm_move(struct ata_port *ap, struct ata_queued_cmd *qc,
 			    u8 status, int in_wq);
-extern void ata_sff_queue_pio_task(struct ata_port *ap, unsigned long delay);
+extern void ata_sff_queue_pio_task(struct ata_link *link, unsigned long delay);
 extern unsigned int ata_sff_qc_issue(struct ata_queued_cmd *qc);
 extern bool ata_sff_qc_fill_rtf(struct ata_queued_cmd *qc);
 extern unsigned int ata_sff_port_intr(struct ata_port *ap,

commit e2f3d75fc0e4a0d03c61872bad39ffa2e74a04ff
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Sep 7 14:05:31 2010 +0200

    libata: skip EH autopsy and recovery during suspend
    
    For some mysterious reason, certain hardware reacts badly to usual EH
    actions while the system is going for suspend.  As the devices won't
    be needed until the system is resumed, ask EH to skip usual autopsy
    and recovery and proceed directly to suspend.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Tested-by: Stephan Diestelhorst <stephan.diestelhorst@amd.com>
    Cc: stable@kernel.org
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index f010f18a0f86..7de282d8bedf 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -335,6 +335,7 @@ enum {
 	ATA_EHI_HOTPLUGGED	= (1 << 0),  /* could have been hotplugged */
 	ATA_EHI_NO_AUTOPSY	= (1 << 2),  /* no autopsy */
 	ATA_EHI_QUIET		= (1 << 3),  /* be quiet */
+	ATA_EHI_NO_RECOVERY	= (1 << 4),  /* no recovery */
 
 	ATA_EHI_DID_SOFTRESET	= (1 << 16), /* already soft-reset this port */
 	ATA_EHI_DID_HARDRESET	= (1 << 17), /* already soft-reset this port */

commit ad72cf9885c536e3adae03f8337557ac9dd1e4bb
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jul 2 10:03:52 2010 +0200

    libata: take advantage of cmwq and remove concurrency limitations
    
    libata has two concurrency related limitations.
    
    a. ata_wq which is used for polling PIO has single thread per CPU.  If
       there are multiple devices doing polling PIO on the same CPU, they
       can't be executed simultaneously.
    
    b. ata_aux_wq which is used for SCSI probing has single thread.  In
       cases where SCSI probing is stalled for extended period of time
       which is possible for ATAPI devices, this will stall all probing.
    
    #a is solved by increasing maximum concurrency of ata_wq.  Please note
    that polling PIO might be used under allocation path and thus needs to
    be served by a separate wq with a rescuer.
    
    #b is solved by using the default wq instead and achieving exclusion
    via per-port mutex.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b85f3ff34d7d..f010f18a0f86 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -751,6 +751,7 @@ struct ata_port {
 	struct ata_host		*host;
 	struct device 		*dev;
 
+	struct mutex		scsi_scan_mutex;
 	struct delayed_work	hotplug_task;
 	struct work_struct	scsi_rescan_task;
 

commit d8d9129ea28e2177749627c82962feb26e8d11e9
Author: Tejun Heo <tj@kernel.org>
Date:   Sat May 15 20:09:34 2010 +0200

    libata: implement on-demand HPA unlocking
    
    Implement ata_scsi_unlock_native_capacity() which will be called
    through SCSI layer when block layer notices that partitions on a
    device extend beyond the end of the device.  It requests EH to unlock
    HPA, waits for completion and returns the current device capacity.
    
    This allows libata to unlock HPA on demand instead of having to decide
    whether to unlock upfront.  Unlocking on demand is safer than
    unlocking by upfront because some BIOSes write private data to the
    area beyond HPA limit.  This was suggested by Ben Hutchings.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Suggested-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 3bad2701bfa6..b85f3ff34d7d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1023,6 +1023,7 @@ extern void ata_scsi_simulate(struct ata_device *dev, struct scsi_cmnd *cmd,
 extern int ata_std_bios_param(struct scsi_device *sdev,
 			      struct block_device *bdev,
 			      sector_t capacity, int geom[]);
+extern void ata_scsi_unlock_native_capacity(struct scsi_device *sdev);
 extern int ata_scsi_slave_config(struct scsi_device *sdev);
 extern void ata_scsi_slave_destroy(struct scsi_device *sdev);
 extern int ata_scsi_change_queue_depth(struct scsi_device *sdev,
@@ -1174,6 +1175,7 @@ extern struct device_attribute *ata_common_sdev_attrs[];
 	.slave_configure	= ata_scsi_slave_config,	\
 	.slave_destroy		= ata_scsi_slave_destroy,	\
 	.bios_param		= ata_std_bios_param,		\
+	.unlock_native_capacity	= ata_scsi_unlock_native_capacity, \
 	.sdev_attrs		= ata_common_sdev_attrs
 
 #define ATA_NCQ_SHT(drv_name)					\

commit 43c9c59185eec7caaff6e9dd8d4c93a4d9836a86
Author: Tejun Heo <tj@kernel.org>
Date:   Sun May 23 12:59:11 2010 +0200

    libata: implement dump_id force param
    
    Add dump_id libata.force parameter.  If specified, libata dumps full
    IDENTIFY data during device configuration.  This is to aid debugging.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Larry Baker <baker@usgs.gov>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 4c5eca4e663b..3bad2701bfa6 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -386,6 +386,7 @@ enum {
 	ATA_HORKAGE_1_5_GBPS	= (1 << 13),	/* force 1.5 Gbps */
 	ATA_HORKAGE_NOSETXFER	= (1 << 14),	/* skip SETXFER, SATA only */
 	ATA_HORKAGE_BROKEN_FPDMA_AA	= (1 << 15),	/* skip AA */
+	ATA_HORKAGE_DUMP_ID	= (1 << 16),	/* dump IDENTIFY data */
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */

commit 9a7780c9acb821fe1c2b6fc53f74cc2556ff5364
Author: Tejun Heo <tj@kernel.org>
Date:   Wed May 19 22:10:24 2010 +0200

    libata-sff: make BMDMA optional
    
    Make BMDMA optional depending on new config variable CONFIG_ATA_BMDMA.
    In Kconfig, drivers are grouped into five groups - non-SFF native, SFF
    w/ custom DMA interface, SFF w/ BMDMA, PIO-only SFF, and generic
    fallback / legacy ones.  Kconfig and Makefile are reorganized
    according to the groups and ordered alphabetically inside each group.
    
    ata_ioports.bmdma_addr and ata_port.bmdma_prd[_dma] are put into
    CONFIG_ATA_BMDMA, as are all bmdma related ops, variables and
    functions.
    
    This increase the binary size slightly when BMDMA is enabled but on
    both native-only and PIO-only configurations the size is slightly
    reduced.  Either way, the size difference is insignificant.  This
    change is more meaningful to signify the separation between SFF and
    BMDMA and as a tool to verify the separation.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index fe2be88bc266..4c5eca4e663b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -513,7 +513,9 @@ struct ata_ioports {
 	void __iomem		*command_addr;
 	void __iomem		*altstatus_addr;
 	void __iomem		*ctl_addr;
+#ifdef CONFIG_ATA_BMDMA
 	void __iomem		*bmdma_addr;
+#endif /* CONFIG_ATA_BMDMA */
 	void __iomem		*scr_addr;
 };
 #endif /* CONFIG_ATA_SFF */
@@ -721,8 +723,10 @@ struct ata_port {
 	u8			ctl;	/* cache of ATA control register */
 	u8			last_ctl;	/* Cache last written value */
 	struct delayed_work	sff_pio_task;
+#ifdef CONFIG_ATA_BMDMA
 	struct ata_bmdma_prd	*bmdma_prd;	/* BMDMA SG list */
 	dma_addr_t		bmdma_prd_dma;	/* and its DMA mapping */
+#endif /* CONFIG_ATA_BMDMA */
 #endif /* CONFIG_ATA_SFF */
 
 	unsigned int		pio_mask;
@@ -856,10 +860,12 @@ struct ata_port_operations {
 	void (*sff_irq_clear)(struct ata_port *);
 	void (*sff_drain_fifo)(struct ata_queued_cmd *qc);
 
+#ifdef CONFIG_ATA_BMDMA
 	void (*bmdma_setup)(struct ata_queued_cmd *qc);
 	void (*bmdma_start)(struct ata_queued_cmd *qc);
 	void (*bmdma_stop)(struct ata_queued_cmd *qc);
 	u8   (*bmdma_status)(struct ata_port *ap);
+#endif /* CONFIG_ATA_BMDMA */
 #endif /* CONFIG_ATA_SFF */
 
 	ssize_t (*em_show)(struct ata_port *ap, char *buf);
@@ -1555,7 +1561,6 @@ extern void sata_pmp_error_handler(struct ata_port *ap);
 #ifdef CONFIG_ATA_SFF
 
 extern const struct ata_port_operations ata_sff_port_ops;
-extern const struct ata_port_operations ata_bmdma_port_ops;
 extern const struct ata_port_operations ata_bmdma32_port_ops;
 
 /* PIO only, sg_tablesize and dma_boundary limits can be removed */
@@ -1564,11 +1569,6 @@ extern const struct ata_port_operations ata_bmdma32_port_ops;
 	.sg_tablesize		= LIBATA_MAX_PRD,		\
 	.dma_boundary		= ATA_DMA_BOUNDARY
 
-#define ATA_BMDMA_SHT(drv_name)					\
-	ATA_BASE_SHT(drv_name),					\
-	.sg_tablesize		= LIBATA_MAX_PRD,		\
-	.dma_boundary		= ATA_DMA_BOUNDARY
-
 extern void ata_sff_dev_select(struct ata_port *ap, unsigned int device);
 extern u8 ata_sff_check_status(struct ata_port *ap);
 extern void ata_sff_pause(struct ata_port *ap);
@@ -1625,6 +1625,15 @@ extern int ata_pci_sff_init_one(struct pci_dev *pdev,
 		struct scsi_host_template *sht, void *host_priv, int hflags);
 #endif /* CONFIG_PCI */
 
+#ifdef CONFIG_ATA_BMDMA
+
+extern const struct ata_port_operations ata_bmdma_port_ops;
+
+#define ATA_BMDMA_SHT(drv_name)					\
+	ATA_BASE_SHT(drv_name),					\
+	.sg_tablesize		= LIBATA_MAX_PRD,		\
+	.dma_boundary		= ATA_DMA_BOUNDARY
+
 extern void ata_bmdma_qc_prep(struct ata_queued_cmd *qc);
 extern unsigned int ata_bmdma_qc_issue(struct ata_queued_cmd *qc);
 extern void ata_bmdma_dumb_qc_prep(struct ata_queued_cmd *qc);
@@ -1652,6 +1661,7 @@ extern int ata_pci_bmdma_init_one(struct pci_dev *pdev,
 				  struct scsi_host_template *sht,
 				  void *host_priv, int hflags);
 #endif /* CONFIG_PCI */
+#endif /* CONFIG_ATA_BMDMA */
 
 /**
  *	ata_sff_busy_wait - Wait for a port status register

commit 1c5afdf7a629d2e77de8dd043b97a33dcd7e6dfa
Author: Tejun Heo <tj@kernel.org>
Date:   Wed May 19 22:10:22 2010 +0200

    libata-sff: separate out BMDMA init
    
    Separate out ata_pci_bmdma_prepare_host() and ata_pci_bmdma_init_one()
    from their SFF counterparts.  SFF ones no longer try to initialize
    BMDMA or set PCI master.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b76d767e0240..fe2be88bc266 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1644,6 +1644,13 @@ extern int ata_bmdma_port_start32(struct ata_port *ap);
 #ifdef CONFIG_PCI
 extern int ata_pci_bmdma_clear_simplex(struct pci_dev *pdev);
 extern void ata_pci_bmdma_init(struct ata_host *host);
+extern int ata_pci_bmdma_prepare_host(struct pci_dev *pdev,
+				      const struct ata_port_info * const * ppi,
+				      struct ata_host **r_host);
+extern int ata_pci_bmdma_init_one(struct pci_dev *pdev,
+				  const struct ata_port_info * const * ppi,
+				  struct scsi_host_template *sht,
+				  void *host_priv, int hflags);
 #endif /* CONFIG_PCI */
 
 /**

commit c3b2889424c26f3b42962b6f39aabb4f1fd1b576
Author: Tejun Heo <tj@kernel.org>
Date:   Wed May 19 22:10:21 2010 +0200

    libata-sff: separate out BMDMA irq handler
    
    Separate out BMDMA irq handler from SFF irq handler.  The misnamed
    host_intr() functions are renamed to ata_sff_port_intr() and
    ata_bmdma_port_intr().  Common parts are factored into
    __ata_sff_port_intr() and __ata_sff_interrupt() and used by sff and
    bmdma interrupt routines.
    
    All BMDMA drivers now use ata_bmdma_interrupt() or
    ata_bmdma_port_intr() while all non-BMDMA SFF ones use
    ata_sff_interrupt() or ata_sff_port_intr().
    
    For now, ata_pci_sff_init_one() uses ata_bmdma_interrupt() as it's
    used by both SFF and BMDMA drivers.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 8fd1ca8c7ef3..b76d767e0240 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1593,7 +1593,7 @@ extern int ata_sff_hsm_move(struct ata_port *ap, struct ata_queued_cmd *qc,
 extern void ata_sff_queue_pio_task(struct ata_port *ap, unsigned long delay);
 extern unsigned int ata_sff_qc_issue(struct ata_queued_cmd *qc);
 extern bool ata_sff_qc_fill_rtf(struct ata_queued_cmd *qc);
-extern unsigned int ata_sff_host_intr(struct ata_port *ap,
+extern unsigned int ata_sff_port_intr(struct ata_port *ap,
 				      struct ata_queued_cmd *qc);
 extern irqreturn_t ata_sff_interrupt(int irq, void *dev_instance);
 extern void ata_sff_lost_interrupt(struct ata_port *ap);
@@ -1628,6 +1628,9 @@ extern int ata_pci_sff_init_one(struct pci_dev *pdev,
 extern void ata_bmdma_qc_prep(struct ata_queued_cmd *qc);
 extern unsigned int ata_bmdma_qc_issue(struct ata_queued_cmd *qc);
 extern void ata_bmdma_dumb_qc_prep(struct ata_queued_cmd *qc);
+extern unsigned int ata_bmdma_port_intr(struct ata_port *ap,
+				      struct ata_queued_cmd *qc);
+extern irqreturn_t ata_bmdma_interrupt(int irq, void *dev_instance);
 extern void ata_bmdma_error_handler(struct ata_port *ap);
 extern void ata_bmdma_post_internal_cmd(struct ata_queued_cmd *qc);
 extern void ata_bmdma_irq_clear(struct ata_port *ap);

commit 37f65b8bc262a5ae4c8e58be92fe3032f0aaaf04
Author: Tejun Heo <tj@kernel.org>
Date:   Wed May 19 22:10:20 2010 +0200

    libata-sff: ata_sff_irq_clear() is BMDMA specific
    
    ata_sff_irq_clear() is BMDMA specific.  Rename it to
    ata_bmdma_irq_clear(), move it to ata_bmdma_port_ops and make
    ->sff_irq_clear() optional.
    
    Note: ata_bmdma_irq_clear() is actually only needed by ata_piix and
          possibly by sata_sil.  This should be moved to respective low
          level drivers later.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ee84e7e12039..8fd1ca8c7ef3 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1630,6 +1630,7 @@ extern unsigned int ata_bmdma_qc_issue(struct ata_queued_cmd *qc);
 extern void ata_bmdma_dumb_qc_prep(struct ata_queued_cmd *qc);
 extern void ata_bmdma_error_handler(struct ata_port *ap);
 extern void ata_bmdma_post_internal_cmd(struct ata_queued_cmd *qc);
+extern void ata_bmdma_irq_clear(struct ata_port *ap);
 extern void ata_bmdma_setup(struct ata_queued_cmd *qc);
 extern void ata_bmdma_start(struct ata_queued_cmd *qc);
 extern void ata_bmdma_stop(struct ata_queued_cmd *qc);

commit 360ff7833098e944e5003618b03894251e937802
Author: Tejun Heo <tj@kernel.org>
Date:   Mon May 10 21:41:42 2010 +0200

    libata-sff: separate out BMDMA qc_issue
    
    Separate out ata_bmdma_qc_issue() from ata_sff_qc_issue() such that
    ata_sff_qc_issue() only deals with non-BMDMA SFF protocols (PIO and
    nodata) while ata_bmdma_qc_issue() deals with the BMDMA protocols and
    uses ata_sff_qc_issue() for non-DMA commands.  All the users are
    updated accordingly.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d973972f0db2..ee84e7e12039 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1626,6 +1626,7 @@ extern int ata_pci_sff_init_one(struct pci_dev *pdev,
 #endif /* CONFIG_PCI */
 
 extern void ata_bmdma_qc_prep(struct ata_queued_cmd *qc);
+extern unsigned int ata_bmdma_qc_issue(struct ata_queued_cmd *qc);
 extern void ata_bmdma_dumb_qc_prep(struct ata_queued_cmd *qc);
 extern void ata_bmdma_error_handler(struct ata_port *ap);
 extern void ata_bmdma_post_internal_cmd(struct ata_queued_cmd *qc);

commit f60d70113fa04e32aee2dedbf304a48469c9c45c
Author: Tejun Heo <tj@kernel.org>
Date:   Mon May 10 21:41:41 2010 +0200

    libata-sff: prd is BMDMA specific
    
    struct ata_prd and ap->prd are BMDMA specific.  Add bmdma_ prefix to
    them and move them inside CONFIG_ATA_SFF.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 3675fd29b2e5..d973972f0db2 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -716,14 +716,13 @@ struct ata_port {
 	unsigned int		print_id; /* user visible unique port ID */
 	unsigned int		port_no; /* 0 based port no. inside the host */
 
-	struct ata_prd		*prd;	 /* our SG list */
-	dma_addr_t		prd_dma; /* and its DMA mapping */
-
 #ifdef CONFIG_ATA_SFF
 	struct ata_ioports	ioaddr;	/* ATA cmd/ctl/dma register blocks */
 	u8			ctl;	/* cache of ATA control register */
 	u8			last_ctl;	/* Cache last written value */
 	struct delayed_work	sff_pio_task;
+	struct ata_bmdma_prd	*bmdma_prd;	/* BMDMA SG list */
+	dma_addr_t		bmdma_prd_dma;	/* and its DMA mapping */
 #endif /* CONFIG_ATA_SFF */
 
 	unsigned int		pio_mask;

commit f47451c45fe0032ef491aaf3e0623fa0154e156d
Author: Tejun Heo <tj@kernel.org>
Date:   Mon May 10 21:41:40 2010 +0200

    libata-sff: ata_sff_[dumb_]qc_prep are BMDMA specific
    
    Both qc_prep functions deal only with BMDMA PRD setup and PIO only SFF
    drivers don't need them.  Rename to ata_bmdma_[dumb_]qc_prep() and
    relocate.
    
    All usages are renamed except for pdc_adma and sata_qstor.  Those two
    drivers are not BMDMA drivers and don't need to call BMDMA qc_prep
    functions.  Calls to ata_sff_qc_prep() in the two drivers are removed.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 1d3859016aec..3675fd29b2e5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1570,8 +1570,6 @@ extern const struct ata_port_operations ata_bmdma32_port_ops;
 	.sg_tablesize		= LIBATA_MAX_PRD,		\
 	.dma_boundary		= ATA_DMA_BOUNDARY
 
-extern void ata_sff_qc_prep(struct ata_queued_cmd *qc);
-extern void ata_sff_dumb_qc_prep(struct ata_queued_cmd *qc);
 extern void ata_sff_dev_select(struct ata_port *ap, unsigned int device);
 extern u8 ata_sff_check_status(struct ata_port *ap);
 extern void ata_sff_pause(struct ata_port *ap);
@@ -1628,6 +1626,8 @@ extern int ata_pci_sff_init_one(struct pci_dev *pdev,
 		struct scsi_host_template *sht, void *host_priv, int hflags);
 #endif /* CONFIG_PCI */
 
+extern void ata_bmdma_qc_prep(struct ata_queued_cmd *qc);
+extern void ata_bmdma_dumb_qc_prep(struct ata_queued_cmd *qc);
 extern void ata_bmdma_error_handler(struct ata_port *ap);
 extern void ata_bmdma_post_internal_cmd(struct ata_queued_cmd *qc);
 extern void ata_bmdma_setup(struct ata_queued_cmd *qc);

commit fe06e5f9b7c61dc567edace3f4909672067f7d7e
Author: Tejun Heo <tj@kernel.org>
Date:   Mon May 10 21:41:39 2010 +0200

    libata-sff: separate out BMDMA EH
    
    Some of error handling logic in ata_sff_error_handler() and all of
    ata_sff_post_internal_cmd() are for BMDMA.  Create
    ata_bmdma_error_handler() and ata_bmdma_post_internal_cmd() and move
    BMDMA part into those.
    
    While at it, change DMA protocol check to ata_is_dma(), fix
    post_internal_cmd to call ap->ops->bmdma_stop instead of directly
    calling ata_bmdma_stop() and open code hardreset selection so that
    ata_std_error_handler() doesn't have to know about sff hardreset.
    
    As these two functions are BMDMA specific, there's no reason to check
    for bmdma_addr before calling bmdma methods if the protocol of the
    failed command is DMA.  sata_mv and pata_mpc52xx now don't need to set
    .post_internal_cmd to ATA_OP_NULL and pata_icside and sata_qstor don't
    need to set it to their bmdma_stop routines.
    
    ata_sff_post_internal_cmd() becomes noop and is removed.
    
    This fixes p3 described in clean-up-BMDMA-initialization patch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6888b5c36e0f..1d3859016aec 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1614,7 +1614,6 @@ extern int sata_sff_hardreset(struct ata_link *link, unsigned int *class,
 extern void ata_sff_postreset(struct ata_link *link, unsigned int *classes);
 extern void ata_sff_drain_fifo(struct ata_queued_cmd *qc);
 extern void ata_sff_error_handler(struct ata_port *ap);
-extern void ata_sff_post_internal_cmd(struct ata_queued_cmd *qc);
 extern void ata_sff_std_ports(struct ata_ioports *ioaddr);
 #ifdef CONFIG_PCI
 extern int ata_pci_sff_init_host(struct ata_host *host);
@@ -1629,6 +1628,8 @@ extern int ata_pci_sff_init_one(struct pci_dev *pdev,
 		struct scsi_host_template *sht, void *host_priv, int hflags);
 #endif /* CONFIG_PCI */
 
+extern void ata_bmdma_error_handler(struct ata_port *ap);
+extern void ata_bmdma_post_internal_cmd(struct ata_queued_cmd *qc);
 extern void ata_bmdma_setup(struct ata_queued_cmd *qc);
 extern void ata_bmdma_start(struct ata_queued_cmd *qc);
 extern void ata_bmdma_stop(struct ata_queued_cmd *qc);

commit c429137a67b82788d24682153bb9c96501a9ef34
Author: Tejun Heo <tj@kernel.org>
Date:   Mon May 10 21:41:38 2010 +0200

    libata-sff: port_task is SFF specific
    
    port_task is tightly bound to the standard SFF PIO HSM implementation.
    Using it for any other purpose would be error-prone and there's no
    such user and if some drivers need such feature, it would be much
    better off using its own.  Move it inside CONFIG_ATA_SFF and rename it
    to sff_pio_task.
    
    The only function which is exposed to the core layer is
    ata_sff_flush_pio_task() which is renamed from ata_port_flush_task()
    and now also takes care of resetting hsm_task_state to HSM_ST_IDLE,
    which is possible as it's now specific to PIO HSM.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 85b99b83f990..6888b5c36e0f 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -723,6 +723,7 @@ struct ata_port {
 	struct ata_ioports	ioaddr;	/* ATA cmd/ctl/dma register blocks */
 	u8			ctl;	/* cache of ATA control register */
 	u8			last_ctl;	/* Cache last written value */
+	struct delayed_work	sff_pio_task;
 #endif /* CONFIG_ATA_SFF */
 
 	unsigned int		pio_mask;
@@ -746,8 +747,6 @@ struct ata_port {
 	struct ata_host		*host;
 	struct device 		*dev;
 
-	void			*port_task_data;
-	struct delayed_work	port_task;
 	struct delayed_work	hotplug_task;
 	struct work_struct	scsi_rescan_task;
 
@@ -1031,9 +1030,6 @@ extern int ata_cable_sata(struct ata_port *ap);
 extern int ata_cable_ignore(struct ata_port *ap);
 extern int ata_cable_unknown(struct ata_port *ap);
 
-extern void ata_pio_queue_task(struct ata_port *ap, void *data,
-			       unsigned long delay);
-
 /* Timing helpers */
 extern unsigned int ata_pio_need_iordy(const struct ata_device *);
 extern const struct ata_timing *ata_timing_find_mode(u8 xfer_mode);
@@ -1597,6 +1593,7 @@ extern void ata_sff_irq_on(struct ata_port *ap);
 extern void ata_sff_irq_clear(struct ata_port *ap);
 extern int ata_sff_hsm_move(struct ata_port *ap, struct ata_queued_cmd *qc,
 			    u8 status, int in_wq);
+extern void ata_sff_queue_pio_task(struct ata_port *ap, unsigned long delay);
 extern unsigned int ata_sff_qc_issue(struct ata_queued_cmd *qc);
 extern bool ata_sff_qc_fill_rtf(struct ata_queued_cmd *qc);
 extern unsigned int ata_sff_host_intr(struct ata_port *ap,

commit 5fe7454aa9c6ef5fcf506b0f2dfc20f696891f1a
Author: Tejun Heo <tj@kernel.org>
Date:   Mon May 10 21:41:37 2010 +0200

    libata-sff: ap->[last_]ctl are SFF specific
    
    ap->[last_]ctl are specific to SFF controllers.  Put them inside
    CONFIG_ATA_SFF and move initialization into ata_sff_port_init().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 19f716edd3be..85b99b83f990 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -721,10 +721,10 @@ struct ata_port {
 
 #ifdef CONFIG_ATA_SFF
 	struct ata_ioports	ioaddr;	/* ATA cmd/ctl/dma register blocks */
-#endif /* CONFIG_ATA_SFF */
-
 	u8			ctl;	/* cache of ATA control register */
 	u8			last_ctl;	/* Cache last written value */
+#endif /* CONFIG_ATA_SFF */
+
 	unsigned int		pio_mask;
 	unsigned int		mwdma_mask;
 	unsigned int		udma_mask;
@@ -1435,7 +1435,11 @@ static inline void ata_tf_init(struct ata_device *dev, struct ata_taskfile *tf)
 {
 	memset(tf, 0, sizeof(*tf));
 
+#ifdef CONFIG_ATA_SFF
 	tf->ctl = dev->link->ap->ctl;
+#else
+	tf->ctl = ATA_DEVCTL_OBS;
+#endif
 	if (dev->devno == 0)
 		tf->device = ATA_DEVICE_OBS;
 	else

commit 8244cd05979ef924787aa70fd80304f1773976a1
Author: Tejun Heo <tj@kernel.org>
Date:   Mon May 10 21:41:36 2010 +0200

    libata-sff: rename ap->ops->drain_fifo() to sff_drain_fifo()
    
    ->drain_fifo() is SFF specific.  Rename and relocate it.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 45a547e42d47..19f716edd3be 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -856,13 +856,12 @@ struct ata_port_operations {
 	void (*sff_irq_on)(struct ata_port *);
 	bool (*sff_irq_check)(struct ata_port *);
 	void (*sff_irq_clear)(struct ata_port *);
+	void (*sff_drain_fifo)(struct ata_queued_cmd *qc);
 
 	void (*bmdma_setup)(struct ata_queued_cmd *qc);
 	void (*bmdma_start)(struct ata_queued_cmd *qc);
 	void (*bmdma_stop)(struct ata_queued_cmd *qc);
 	u8   (*bmdma_status)(struct ata_port *ap);
-
-	void (*drain_fifo)(struct ata_queued_cmd *qc);
 #endif /* CONFIG_ATA_SFF */
 
 	ssize_t (*em_show)(struct ata_port *ap, char *buf);

commit c7087652e1890a3feef35b30ee1d4be68e1932cd
Author: Tejun Heo <tj@kernel.org>
Date:   Mon May 10 21:41:34 2010 +0200

    libata-sff: clean up BMDMA initialization
    
    When BMDMA initialization failed or BMDMA was not available for
    whatever reason, bmdma_addr was left at zero and used as an indication
    that BMDMA shouldn't be used.  This leads to the following problems.
    
    p1. For BMDMA drivers which don't use traditional BMDMA register,
        ata_bmdma_mode_filter() incorrectly inhibits DMA modes.  Those
        drivers either have to inherit from ata_sff_port_ops or clear
        ->mode_filter explicitly.
    
    p2. non-BMDMA drivers call into BMDMA PRD table allocation.  It
        doesn't actually allocate PRD table if bmdma_addr is not
        initialized but is still confusing.
    
    p3. For BMDMA drivers which don't use traditional BMDMA register, some
        methods might not be invoked as expected (e.g. bmdma_stop from
        ata_sff_post_internal_cmd()).
    
    p4. SFF drivers w/ custom DMA interface implement noop BMDMA ops
        worrying libata core might call into one of them.
    
    These problems are caused by the muddy line between SFF and BMDMA and
    the assumption that all BMDMA controllers initialize bmdma_addr.
    
    This patch fixes p1 and p2 by removing the bmdma_addr assumption and
    moving prd allocation to BMDMA port start.  Later patches will fix the
    remaining issues.
    
    This patch improves BMDMA initialization such that
    
    * When BMDMA register initialization fails, falls back to PIO instead
      of failing.  ata_pci_bmdma_init() never fails now.
    
    * When ata_pci_bmdma_init() falls back to PIO, it clears
      ap->mwdma_mask and udma_mask instead of depending on
      ata_bmdma_mode_filter().  This makes ata_bmdma_mode_filter()
      unnecessary thus resolving p1.
    
    * ata_port_start() which actually is BMDMA specific is moved to
      ata_bmdma_port_start().  ata_port_start() and ata_sff_port_start()
      are killed.
    
    * ata_sff_port_start32() is moved and renamed to
      ata_bmdma_port_start32().
    
    Drivers which no longer call into PRD table allocation are...
    
      pdc_adma, sata_inic162x, sata_qstor, sata_sx4, pata_cmd640 and all
      drivers which inherit from ata_sff_port_ops.
    
    pata_icside sets ->port_start to ATA_OP_NULL as it doesn't need PRD
    but is a BMDMA controller and doesn't have custom port_start like
    other such controllers.
    
    Note that with the previous patch which makes all and only BMDMA
    drivers inherit from ata_bmdma_port_ops, this change doesn't break
    drivers which need PRD table.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d735728873b5..45a547e42d47 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1000,7 +1000,6 @@ extern unsigned long ata_xfer_mode2mask(u8 xfer_mode);
 extern int ata_xfer_mode2shift(unsigned long xfer_mode);
 extern const char *ata_mode_string(unsigned long xfer_mask);
 extern unsigned long ata_id_xfermask(const u16 *id);
-extern int ata_port_start(struct ata_port *ap);
 extern int ata_std_qc_defer(struct ata_queued_cmd *qc);
 extern void ata_noop_qc_prep(struct ata_queued_cmd *qc);
 extern void ata_sg_init(struct ata_queued_cmd *qc, struct scatterlist *sg,
@@ -1616,8 +1615,6 @@ extern void ata_sff_postreset(struct ata_link *link, unsigned int *classes);
 extern void ata_sff_drain_fifo(struct ata_queued_cmd *qc);
 extern void ata_sff_error_handler(struct ata_port *ap);
 extern void ata_sff_post_internal_cmd(struct ata_queued_cmd *qc);
-extern int ata_sff_port_start(struct ata_port *ap);
-extern int ata_sff_port_start32(struct ata_port *ap);
 extern void ata_sff_std_ports(struct ata_ioports *ioaddr);
 #ifdef CONFIG_PCI
 extern int ata_pci_sff_init_host(struct ata_host *host);
@@ -1632,16 +1629,16 @@ extern int ata_pci_sff_init_one(struct pci_dev *pdev,
 		struct scsi_host_template *sht, void *host_priv, int hflags);
 #endif /* CONFIG_PCI */
 
-extern unsigned long ata_bmdma_mode_filter(struct ata_device *dev,
-					   unsigned long xfer_mask);
 extern void ata_bmdma_setup(struct ata_queued_cmd *qc);
 extern void ata_bmdma_start(struct ata_queued_cmd *qc);
 extern void ata_bmdma_stop(struct ata_queued_cmd *qc);
 extern u8 ata_bmdma_status(struct ata_port *ap);
+extern int ata_bmdma_port_start(struct ata_port *ap);
+extern int ata_bmdma_port_start32(struct ata_port *ap);
 
 #ifdef CONFIG_PCI
 extern int ata_pci_bmdma_clear_simplex(struct pci_dev *pdev);
-extern int ata_pci_bmdma_init(struct ata_host *host);
+extern void ata_pci_bmdma_init(struct ata_host *host);
 #endif /* CONFIG_PCI */
 
 /**

commit 9f2f72107ff621fdf3066e5a1b5ecb03ee587ebc
Author: Tejun Heo <tj@kernel.org>
Date:   Mon May 10 21:41:32 2010 +0200

    libata-sff: reorder SFF/BMDMA functions
    
    Reorder functions such that SFF and BMDMA functions are grouped.
    While at it, s/BMDMA/SFF in a few comments where it actually meant
    SFF.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index bd1b2b49e121..d735728873b5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1619,16 +1619,7 @@ extern void ata_sff_post_internal_cmd(struct ata_queued_cmd *qc);
 extern int ata_sff_port_start(struct ata_port *ap);
 extern int ata_sff_port_start32(struct ata_port *ap);
 extern void ata_sff_std_ports(struct ata_ioports *ioaddr);
-extern unsigned long ata_bmdma_mode_filter(struct ata_device *dev,
-					   unsigned long xfer_mask);
-extern void ata_bmdma_setup(struct ata_queued_cmd *qc);
-extern void ata_bmdma_start(struct ata_queued_cmd *qc);
-extern void ata_bmdma_stop(struct ata_queued_cmd *qc);
-extern u8 ata_bmdma_status(struct ata_port *ap);
-
 #ifdef CONFIG_PCI
-extern int ata_pci_bmdma_clear_simplex(struct pci_dev *pdev);
-extern int ata_pci_bmdma_init(struct ata_host *host);
 extern int ata_pci_sff_init_host(struct ata_host *host);
 extern int ata_pci_sff_prepare_host(struct pci_dev *pdev,
 				    const struct ata_port_info * const * ppi,
@@ -1641,6 +1632,18 @@ extern int ata_pci_sff_init_one(struct pci_dev *pdev,
 		struct scsi_host_template *sht, void *host_priv, int hflags);
 #endif /* CONFIG_PCI */
 
+extern unsigned long ata_bmdma_mode_filter(struct ata_device *dev,
+					   unsigned long xfer_mask);
+extern void ata_bmdma_setup(struct ata_queued_cmd *qc);
+extern void ata_bmdma_start(struct ata_queued_cmd *qc);
+extern void ata_bmdma_stop(struct ata_queued_cmd *qc);
+extern u8 ata_bmdma_status(struct ata_port *ap);
+
+#ifdef CONFIG_PCI
+extern int ata_pci_bmdma_clear_simplex(struct pci_dev *pdev);
+extern int ata_pci_bmdma_init(struct ata_host *host);
+#endif /* CONFIG_PCI */
+
 /**
  *	ata_sff_busy_wait - Wait for a port status register
  *	@ap: Port to wait for.

commit 3e4ec3443f70fbe144799ccf0b1c3797f78d1715
Author: Tejun Heo <tj@kernel.org>
Date:   Mon May 10 21:41:30 2010 +0200

    libata: kill ATA_FLAG_DISABLED
    
    ATA_FLAG_DISABLED is only used by drivers which don't use
    ->error_handler framework and is largely broken.  Its only meaningful
    function is to make irq handlers skip processing if the flag is set,
    which is largely useless and even harmful as it makes those ports more
    likely to cause IRQ storms.
    
    Kill ATA_FLAG_DISABLED and makes the callers disable attached devices
    instead.  ata_port_probe() and ata_port_disable() which manipulate the
    flag are also killed.
    
    This simplifies condition check in IRQ handlers.  While updating IRQ
    handlers, remove ap NULL check as libata guarantees consecutive port
    allocation (unoccupied ports are initialized with dummies) and
    long-obsolete ATA_QCFLAG_ACTIVE check (checked by ata_qc_from_tag()).
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index af700923a393..bd1b2b49e121 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -202,12 +202,6 @@ enum {
 	ATA_FLAG_SW_ACTIVITY	= (1 << 22), /* driver supports sw activity
 					      * led */
 
-	/* The following flag belongs to ap->pflags but is kept in
-	 * ap->flags because it's referenced in many LLDs and will be
-	 * removed in not-too-distant future.
-	 */
-	ATA_FLAG_DISABLED	= (1 << 23), /* port is disabled, ignore it */
-
 	/* bits 24:31 of ap->flags are reserved for LLD specific flags */
 
 
@@ -937,7 +931,6 @@ static inline int ata_port_is_dummy(struct ata_port *ap)
 	return ap->ops == &ata_dummy_port_ops;
 }
 
-extern void ata_port_probe(struct ata_port *);
 extern int sata_set_spd(struct ata_link *link);
 extern int ata_std_prereset(struct ata_link *link, unsigned long deadline);
 extern int ata_wait_after_reset(struct ata_link *link, unsigned long deadline,
@@ -952,7 +945,6 @@ extern int sata_link_hardreset(struct ata_link *link,
 extern int sata_std_hardreset(struct ata_link *link, unsigned int *class,
 			      unsigned long deadline);
 extern void ata_std_postreset(struct ata_link *link, unsigned int *classes);
-extern void ata_port_disable(struct ata_port *);
 
 extern struct ata_host *ata_host_alloc(struct device *dev, int max_ports);
 extern struct ata_host *ata_host_alloc_pinfo(struct device *dev,

commit e42a542ba9cca594897176020445023c54d903d6
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Fri May 7 22:49:02 2010 +0400

    libata: make sff_irq_on() method optional
    
    Now, with the introduction of the sff_set_devctl() method, we can
    use it in sff_irq_on() method too -- that way its implementations
    in 'pata_bf54x' and 'pata_scc' become virtually identical to
    ata_sff_irq_on().  The sff_irq_on() method now becomes quite
    superfluous, and the only reason not to remove it completely is
    the existence of the 'pata_octeon_cf' driver which implements it
    as an empty function. Just make the method optional then, with
    ata_sff_irq_on() becoming generic taskfile-bound function, still
    global for the 'pata_bf54x' driver to be able to call it from its
    thaw() and postreset() methods.
    
    While at it, make the sff_irq_on() method and ata_sff_irq_on() return
    'void' as the result is always ignored anyway.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6207ec600722..af700923a393 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -859,7 +859,7 @@ struct ata_port_operations {
 				 const struct ata_taskfile *tf);
 	unsigned int (*sff_data_xfer)(struct ata_device *dev,
 			unsigned char *buf, unsigned int buflen, int rw);
-	u8   (*sff_irq_on)(struct ata_port *);
+	void (*sff_irq_on)(struct ata_port *);
 	bool (*sff_irq_check)(struct ata_port *);
 	void (*sff_irq_clear)(struct ata_port *);
 
@@ -1599,7 +1599,7 @@ extern unsigned int ata_sff_data_xfer32(struct ata_device *dev,
 			unsigned char *buf, unsigned int buflen, int rw);
 extern unsigned int ata_sff_data_xfer_noirq(struct ata_device *dev,
 			unsigned char *buf, unsigned int buflen, int rw);
-extern u8 ata_sff_irq_on(struct ata_port *ap);
+extern void ata_sff_irq_on(struct ata_port *ap);
 extern void ata_sff_irq_clear(struct ata_port *ap);
 extern int ata_sff_hsm_move(struct ata_port *ap, struct ata_queued_cmd *qc,
 			    u8 status, int in_wq);

commit 41dec29bcb05eb8ec396f70ce791c6e3e4ce4712
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Fri May 7 22:47:50 2010 +0400

    libata: introduce sff_set_devctl() method
    
    The set of libata's taskfile access methods is clearly incomplete as
    it lacks a method to write to the device control register -- which
    forces drivers like 'pata_bf54x' and 'pata_scc' to implement more
    "high level" (and more weighty) methods like freeze() and postreset().
    
    So, introduce the optional sff_set_devctl() method which the drivers
    only have to implement if the standard iowrite8() can't be used (just
    like the existing sff_check_altstatus() method) and make use of it
    in the freeze() and postreset() method implementations (I could also
    have used it in softreset() method but it also reads other taskfile
    registers without using tf_read() making that quite pointless);
    this makes freeze() method implementations in the 'pata_bf54x' and
    'pata_scc' methods virtually identical to ata_sff_freeze(), so we
    can get rid of them completely.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 242eb2646101..6207ec600722 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -850,6 +850,7 @@ struct ata_port_operations {
 	 * SFF / taskfile oriented ops
 	 */
 	void (*sff_dev_select)(struct ata_port *ap, unsigned int device);
+	void (*sff_set_devctl)(struct ata_port *ap, u8 ctl);
 	u8   (*sff_check_status)(struct ata_port *ap);
 	u8   (*sff_check_altstatus)(struct ata_port *ap);
 	void (*sff_tf_load)(struct ata_port *ap, const struct ata_taskfile *tf);

commit b48d58f55aa1d2d0d12378e45663842d4021916e
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Apr 9 19:46:38 2010 +0900

    libata: use longer 0xff wait if parallel scan is enabled
    
    There are some SATA devices which take relatively long to get out of
    0xff status after reset.  In libata, this timeout is determined by
    ATA_TMOUT_FF_WAIT.  Quantum GoVault is the worst requring about 2s for
    reliable detection.  However, because 2s 0xff timeout can introduce
    rather long spurious delay during boot, libata has been compromising
    at the next longest timeout of 800ms for HHD424020F7SV00 iVDR drive.
    
    Now that parallel scan is in place for common drivers, libata can
    afford 2s 0xff timeout.  Use 2s 0xff timeout if parallel scan is
    enabled.
    
    Please note that the chance of spurious wait is pretty slim w/ working
    SCR access so this will only affect SATA controllers w/o SCR access
    which isn't too common these days.
    
    Please read the following thread for more information on the GoVault
    drive.
    
      http://thread.gmane.org/gmane.linux.ide/14545/focus=14663
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Gary Hade <garyhade@us.ibm.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 4fa748e9bc01..242eb2646101 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -256,12 +256,13 @@ enum {
 	ATA_TMOUT_INTERNAL_QUICK = 5000,
 	ATA_TMOUT_MAX_PARK	= 30000,
 
-	/* FIXME: GoVault needs 2s but we can't afford that without
-	 * parallel probing.  800ms is enough for iVDR disk
-	 * HHD424020F7SV00.  Increase to 2secs when parallel probing
-	 * is in place.
+	/*
+	 * GoVault needs 2s and iVDR disk HHD424020F7SV00 800ms.  2s
+	 * is too much without parallel probing.  Use 2s if parallel
+	 * probing is available, 800ms otherwise.
 	 */
-	ATA_TMOUT_FF_WAIT	=  800,
+	ATA_TMOUT_FF_WAIT_LONG	=  2000,
+	ATA_TMOUT_FF_WAIT	=   800,
 
 	/* Spec mandates to wait for ">= 2ms" before checking status
 	 * after reset.  We wait 150ms, because that was the magic

commit 294440887b32c58d220fb54b73b7a58079b78f20
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Thu Apr 22 20:03:35 2010 +0400

    libata-sff: kill unused ata_bus_reset()
    
    ... since I see no callers of it.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b2f2003b92e5..4fa748e9bc01 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1631,7 +1631,6 @@ extern void ata_bmdma_setup(struct ata_queued_cmd *qc);
 extern void ata_bmdma_start(struct ata_queued_cmd *qc);
 extern void ata_bmdma_stop(struct ata_queued_cmd *qc);
 extern u8 ata_bmdma_status(struct ata_port *ap);
-extern void ata_bus_reset(struct ata_port *ap);
 
 #ifdef CONFIG_PCI
 extern int ata_pci_bmdma_clear_simplex(struct pci_dev *pdev);

commit 445d211b0da4e9a6e6d576edff85085c2aaf53df
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Apr 5 10:33:13 2010 +0900

    libata: unlock HPA if device shrunk
    
    Some BIOSes don't configure HPA during boot but do so while resuming.
    This causes harddrives to shrink during resume making libata detach
    and reattach them.  This can be worked around by unlocking HPA if old
    size equals native size.
    
    Add ATA_DFLAG_UNLOCK_HPA so that HPA unlocking can be controlled
    per-device and update ata_dev_revalidate() such that it sets
    ATA_DFLAG_UNLOCK_HPA and fails with -EIO when the above condition is
    detected.
    
    This patch fixes the following bug.
    
      https://bugzilla.kernel.org/show_bug.cgi?id=15396
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Oleksandr Yermolenko <yaa.bta@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index f8ea71e6d0e2..b2f2003b92e5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -146,6 +146,7 @@ enum {
 	ATA_DFLAG_SLEEPING	= (1 << 15), /* device is sleeping */
 	ATA_DFLAG_DUBIOUS_XFER	= (1 << 16), /* data transfer not verified */
 	ATA_DFLAG_NO_UNLOAD	= (1 << 17), /* device doesn't support unload */
+	ATA_DFLAG_UNLOCK_HPA	= (1 << 18), /* unlock HPA */
 	ATA_DFLAG_INIT_MASK	= (1 << 24) - 1,
 
 	ATA_DFLAG_DETACH	= (1 << 24),

commit 16ea0fc98d53c72cb4e1a9edcb685a87e3a81430
Author: Alan Cox <alan@linux.intel.com>
Date:   Tue Feb 23 02:26:06 2010 -0500

    libata: Pass host flags into the pci helper
    
    This allows parallel scan and the like to be set without having to stop
    using the existing full helper functions. This patch merely adds the argument
    and fixes up the callers. It doesn't undo the special cases already in the
    tree or add any new parallel callers.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 5fb888462359..f8ea71e6d0e2 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1643,8 +1643,8 @@ extern int ata_pci_sff_activate_host(struct ata_host *host,
 				     irq_handler_t irq_handler,
 				     struct scsi_host_template *sht);
 extern int ata_pci_sff_init_one(struct pci_dev *pdev,
-				const struct ata_port_info * const * ppi,
-				struct scsi_host_template *sht, void *host_priv);
+		const struct ata_port_info * const * ppi,
+		struct scsi_host_template *sht, void *host_priv, int hflags);
 #endif /* CONFIG_PCI */
 
 /**

commit 27943620cbd960f710a385ff4a538e14ed3f1922
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Jan 19 10:49:19 2010 +0900

    libata: implement spurious irq handling for SFF and apply it to piix
    
    Traditional IDE interface sucks in that it doesn't have a reliable IRQ
    pending bit, so if the controller raises IRQ while the driver is
    expecting it not to, the IRQ won't be cleared and eventually the IRQ
    line will be killed by interrupt subsystem.  Some controllers have
    non-standard mechanism to indicate IRQ pending so that this condition
    can be detected and worked around.
    
    This patch adds an optional operation ->sff_irq_check() which will be
    called for each port from the ata_sff_interrupt() if an unexpected
    interrupt is received.  If the operation returns %true,
    ->sff_check_status() and ->sff_irq_clear() will be cleared for the
    port.  Note that this doesn't mark the interrupt as handled so it
    won't prevent IRQ subsystem from killing the IRQ if this mechanism
    fails to clear the spurious IRQ.
    
    This patch also implements ->sff_irq_check() for ata_piix.  Note that
    this adds slight overhead to shared IRQ operation as IRQs which are
    destined for other controllers will trigger extra register accesses to
    check whether IDE interrupt is pending but this solves rare screaming
    IRQ cases and for some curious reason also helps weird BIOS related
    glitch on Samsung n130 as reported in bko#14314.
    
      http://bugzilla.kernel.org/show_bug.cgi?id=14314
    
    * piix_base_ops dropped as suggested by Sergei.
    
    * Spurious IRQ detection doesn't kick in anymore if polling qc is in
      progress.  This provides less protection but some controllers have
      possible data corruption issues if the wrong register is accessed
      while a command is in progress.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Johannes Stezenbach <js@sig21.net>
    Reported-by: Hans Werner <hwerner4@gmx.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 73112250862c..5fb888462359 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -857,6 +857,7 @@ struct ata_port_operations {
 	unsigned int (*sff_data_xfer)(struct ata_device *dev,
 			unsigned char *buf, unsigned int buflen, int rw);
 	u8   (*sff_irq_on)(struct ata_port *);
+	bool (*sff_irq_check)(struct ata_port *);
 	void (*sff_irq_clear)(struct ata_port *);
 
 	void (*bmdma_setup)(struct ata_queued_cmd *qc);

commit 5040ab67a2c6d5710ba497dc52a8f7035729d7b0
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Jan 11 11:14:44 2010 +0900

    libata: retry link resume if necessary
    
    Interestingly, when SIDPR is used in ata_piix, writes to DET in
    SControl sometimes get ignored leading to detection failure.  Update
    sata_link_resume() such that it reads back SControl after clearing DET
    and retry if it's not clear.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: fengxiangjun <fengxiangjun@neusoft.com>
    Reported-by: Jim Faulkner <jfaulkne@ccs.neu.edu>
    Cc: stable@kernel.org
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6a9c4ddd3d95..73112250862c 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -354,6 +354,9 @@ enum {
 	/* max tries if error condition is still set after ->error_handler */
 	ATA_EH_MAX_TRIES	= 5,
 
+	/* sometimes resuming a link requires several retries */
+	ATA_LINK_RESUME_TRIES	= 5,
+
 	/* how hard are we gonna try to probe/recover devices */
 	ATA_PROBE_MAX_TRIES	= 3,
 	ATA_EH_DEV_TRIES	= 3,

commit 382f51fe2f2276344d8a21447656778cdf6583b6
Merge: 701791cc3c8f 54987386ee37
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 9 19:42:25 2009 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6: (222 commits)
      [SCSI] zfcp: Remove flag ZFCP_STATUS_FSFREQ_TMFUNCNOTSUPP
      [SCSI] zfcp: Activate fc4s attributes for zfcp in FC transport class
      [SCSI] zfcp: Block scsi_eh thread for rport state BLOCKED
      [SCSI] zfcp: Update FSF error reporting
      [SCSI] zfcp: Improve ELS ADISC handling
      [SCSI] zfcp: Simplify handling of ct and els requests
      [SCSI] zfcp: Remove ZFCP_DID_MASK
      [SCSI] zfcp: Move WKA port to zfcp FC code
      [SCSI] zfcp: Use common code definitions for FC CT structs
      [SCSI] zfcp: Use common code definitions for FC ELS structs
      [SCSI] zfcp: Update FCP protocol related code
      [SCSI] zfcp: Dont fail SCSI commands when transitioning to blocked fc_rport
      [SCSI] zfcp: Assign scheduled work to driver queue
      [SCSI] zfcp: Remove STATUS_COMMON_REMOVE flag as it is not required anymore
      [SCSI] zfcp: Implement module unloading
      [SCSI] zfcp: Merge trace code for fsf requests in one function
      [SCSI] zfcp: Access ports and units with container_of in sysfs code
      [SCSI] zfcp: Remove suspend callback
      [SCSI] zfcp: Remove global config_mutex
      [SCSI] zfcp: Replace local reference counting with common kref
      ...

commit e881a172dac4d9ea3b2a1540041d872963c269bd
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Oct 15 17:46:39 2009 -0700

    [SCSI] modify change_queue_depth to take in reason why it is being called
    
    This patch modifies scsi_host_template->change_queue_depth so that
    it takes an argument indicating why it is being called. This will be
    used so that if a LLD needs to do some extra processing when
    handling queue fulls or later ramp ups, it can do so.
    
    This is a simple port of the drivers setting a change_queue_depth
    callback. In the patch I just have these LLDs adjust the queue depth
    if the user was requesting it.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    
    [Vasu.Dev: v2
            Also converted pmcraid_change_queue_depth and then verified
    all modules compile  using "make allmodconfig" for any new build
    warnings on X86_64.
    
            Updated original description after combing two original
    patches from Mike to make this patch git bisectable.]
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    [jejb: fixed up 53c700]
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 87698640c091..85df383fd4bd 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1023,7 +1023,7 @@ extern int ata_std_bios_param(struct scsi_device *sdev,
 extern int ata_scsi_slave_config(struct scsi_device *sdev);
 extern void ata_scsi_slave_destroy(struct scsi_device *sdev);
 extern int ata_scsi_change_queue_depth(struct scsi_device *sdev,
-				       int queue_depth);
+				       int queue_depth, int reason);
 extern struct ata_device *ata_dev_pair(struct ata_device *adev);
 extern int ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
 

commit 95514fd8ff0f30de7815950edfd84ef1e19fb1c8
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Nov 25 18:12:48 2009 +0100

    libata: add private driver field to struct ata_device
    
    This brings struct ata_device in-line with struct ata_{port,host}.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ba07e84c9840..a5b3dc71e819 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -595,6 +595,7 @@ struct ata_device {
 	unsigned int		horkage;	/* List of broken features */
 	unsigned long		flags;		/* ATA_DFLAG_xxx */
 	struct scsi_device	*sdev;		/* attached SCSI device */
+	void			*private_data;
 #ifdef CONFIG_ATA_ACPI
 	acpi_handle		acpi_handle;
 	union acpi_object	*gtf_cache;

commit 6013efd8860bf15c1f86f365332642cfe557152f
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 19 15:36:45 2009 +0900

    libata: retry failed FLUSH if device didn't fail it
    
    If ATA device failed FLUSH, it means that the device failed to write
    out some amount of data and the error needs to be reported to upper
    layers. As retries can't recover the lost data, FLUSH failures need to
    be reported immediately in general.
    
    However, if FLUSH fails due to transmission errors, the FLUSH needs to
    be retried; otherwise, filesystems may switch to RO mode and/or raid
    array may drop a drive for a random transmission glitch.
    
    This condition can be rather easily reproduced on certain ahci
    controllers which go through a PHY event after powersave mode switch +
    ext4 combination.  Powersave mode switch is often closely followed by
    flush from the filesystem failing the FLUSH with ATA bus error which
    makes the filesystem code believe that data is lost and drop to RO
    mode.  This was reported in the following bugzilla bug.
    
      http://bugzilla.kernel.org/show_bug.cgi?id=14543
    
    This patch makes libata EH retry FLUSH if it wasn't failed by the
    device.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Andrey Vihrov <andrey.vihrov@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 87698640c091..ba07e84c9840 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -365,7 +365,7 @@ enum {
 	/* This should match the actual table size of
 	 * ata_eh_cmd_timeout_table in libata-eh.c.
 	 */
-	ATA_EH_CMD_TIMEOUT_TABLE_SIZE = 5,
+	ATA_EH_CMD_TIMEOUT_TABLE_SIZE = 6,
 
 	/* Horkage types. May be set by libata or controller on drives
 	   (some horkage may be drive/controller pair dependant */

commit 110f66d25c33c2259b1125255fa7063ab07b8340
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 16 04:17:28 2009 +0900

    libata: make gtf_filter per-dev
    
    Add ->gtf_filter to ata_device and set it to ata_acpi_gtf_filter when
    initializing ata_link.  This is to allow quirks which apply different
    gtf filters.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index aa52794d2a03..87698640c091 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -598,6 +598,7 @@ struct ata_device {
 #ifdef CONFIG_ATA_ACPI
 	acpi_handle		acpi_handle;
 	union acpi_object	*gtf_cache;
+	unsigned int		gtf_filter;
 #endif
 	/* n_sector is CLEAR_BEGIN, read comment above CLEAR_BEGIN */
 	u64			n_sectors;	/* size of device, if ATA */

commit fa5b561c4ea170caf9759109acc2e961a7e83bea
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 16 04:17:02 2009 +0900

    libata: implement more acpi filtering options
    
    Currently libata-acpi can only filter DIPM among SATA feature enables
    via _GTF.  This patch adds the capability to filter out FPDMA non-zero
    offset, in-order guarantee and auto-activation.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 5b2f7491fb26..aa52794d2a03 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -423,6 +423,8 @@ enum {
 	ATA_ACPI_FILTER_SETXFER	= 1 << 0,
 	ATA_ACPI_FILTER_LOCK	= 1 << 1,
 	ATA_ACPI_FILTER_DIPM	= 1 << 2,
+	ATA_ACPI_FILTER_FPDMA_OFFSET = 1 << 3,	/* FPDMA non-zero offset */
+	ATA_ACPI_FILTER_FPDMA_AA = 1 << 4,	/* FPDMA auto activate */
 
 	ATA_ACPI_FILTER_DEFAULT	= ATA_ACPI_FILTER_SETXFER |
 				  ATA_ACPI_FILTER_LOCK |

commit f1bce7f80e3b400cf29787b0afa9c3042b959017
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 16 04:16:04 2009 +0900

    libata: cosmetic updates
    
    We're about to add more SATA_* and ATA_ACPI_FILTER_* constants.
    Reformat them in preparation.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 76319bf03e37..5b2f7491fb26 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -418,6 +418,15 @@ enum {
 				  ATA_TIMING_ACTIVE | ATA_TIMING_RECOVER |
 				  ATA_TIMING_DMACK_HOLD | ATA_TIMING_CYCLE |
 				  ATA_TIMING_UDMA,
+
+	/* ACPI constants */
+	ATA_ACPI_FILTER_SETXFER	= 1 << 0,
+	ATA_ACPI_FILTER_LOCK	= 1 << 1,
+	ATA_ACPI_FILTER_DIPM	= 1 << 2,
+
+	ATA_ACPI_FILTER_DEFAULT	= ATA_ACPI_FILTER_SETXFER |
+				  ATA_ACPI_FILTER_LOCK |
+				  ATA_ACPI_FILTER_DIPM,
 };
 
 enum ata_xfer_mask {

commit 051d9fbdd1d1ec85ea18ba20581234cf23f1c217
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jul 3 11:46:12 2009 +0900

    libata: remove spindown skipping and warning
    
    This was a hack to give userland shutdown tools time to drop manual
    spindown.  All popular distros updated quite some time ago and the due
    is well passed.  Drop it.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Jaswinder Singh Rajput <jaswinder@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d3f7cab4873e..76319bf03e37 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -143,7 +143,6 @@ enum {
 
 	ATA_DFLAG_PIO		= (1 << 12), /* device limited to PIO mode */
 	ATA_DFLAG_NCQ_OFF	= (1 << 13), /* device limited to non-NCQ mode */
-	ATA_DFLAG_SPUNDOWN	= (1 << 14), /* XXX: for spindown_compat */
 	ATA_DFLAG_SLEEPING	= (1 << 15), /* device is sleeping */
 	ATA_DFLAG_DUBIOUS_XFER	= (1 << 16), /* data transfer not verified */
 	ATA_DFLAG_NO_UNLOAD	= (1 << 17), /* device doesn't support unload */

commit 388539f3ff0cf1de926b03f94e1eec112358f74d
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Mon Jul 27 09:24:35 2009 +0800

    [libata] add DMA setup FIS auto-activate feature
    
    Hopefully results in fewer on-the-wire FIS's and no breakage.  We'll see!
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index e5b6e33c6571..d3f7cab4873e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -190,6 +190,7 @@ enum {
 	ATA_FLAG_NO_POWEROFF_SPINDOWN = (1 << 11), /* don't spindown before poweroff */
 	ATA_FLAG_NO_HIBERNATE_SPINDOWN = (1 << 12), /* don't spindown before hibernation */
 	ATA_FLAG_DEBUGMSG	= (1 << 13),
+	ATA_FLAG_FPDMA_AA		= (1 << 14), /* driver supports Auto-Activate */
 	ATA_FLAG_IGN_SIMPLEX	= (1 << 15), /* ignore SIMPLEX */
 	ATA_FLAG_NO_IORDY	= (1 << 16), /* controller lacks iordy */
 	ATA_FLAG_ACPI_SATA	= (1 << 17), /* need native SATA ACPI layout */
@@ -386,6 +387,7 @@ enum {
 	ATA_HORKAGE_FIRMWARE_WARN = (1 << 12),	/* firmware update warning */
 	ATA_HORKAGE_1_5_GBPS	= (1 << 13),	/* force 1.5 Gbps */
 	ATA_HORKAGE_NOSETXFER	= (1 << 14),	/* skip SETXFER, SATA only */
+	ATA_HORKAGE_BROKEN_FPDMA_AA	= (1 << 15),	/* skip AA */
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */

commit 5920dadfb4aec6c1372c5570e71bcd3b4837e63c
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Jul 15 17:11:41 2009 +0900

    libata: accept late unlocking of HPA
    
    On certain configurations, HPA isn't or can't be unlocked during
    probing but it somehow ends up unlocked afterwards.  In the following
    thread, the problem can be reliably reproduced after resuming from
    STR.  The BIOS turns on HPA during boot but forgets to do it during
    resume.
    
      http://thread.gmane.org/gmane.linux.kernel/858310
    
    This patch updates libata revalidation such that it considers native
    n_sectors.  If the device size has increased to match native
    n_sectors, it's assumed that HPA has been unlocked involuntarily and
    the device is recognized as the same one.  This should be fairly safe
    while nicely working around the problem.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Christof Warlich <christof@warlich.name>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 79b6d7fd4ac2..e5b6e33c6571 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -589,6 +589,7 @@ struct ata_device {
 #endif
 	/* n_sector is CLEAR_BEGIN, read comment above CLEAR_BEGIN */
 	u64			n_sectors;	/* size of device, if ATA */
+	u64			n_native_sectors; /* native size, if ATA */
 	unsigned int		class;		/* ATA_DEV_xxx */
 	unsigned long		unpark_deadline;
 

commit d0cb43b35d64877b2944bd37719708be5d7bbf99
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Jul 9 09:27:50 2009 +0900

    libata: implement and use HORKAGE_NOSETXFER, take#2
    
    PIONEER DVD-RW DVRTD08 times out SETXFER if no media is present.  The
    device is SATA and simply skipping SETXFER works around the problem.
    Implement ATA_HORKAGE_NOSETXFER and apply it to the device.
    
    Reported by Moritz Rigler in the following thread.
    
      http://thread.gmane.org/gmane.linux.ide/36790
    
    and by Lars in bko#9540.
    
    Updated to whine and ignore NOSETXFER if PATA component is detected as
    suggested by Alan Cox.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Moritz Rigler <linux-ide@momail.e4ward.com>
    Reported-by: Lars <lars21ce@gmx.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 3d501db36a26..79b6d7fd4ac2 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -385,6 +385,7 @@ enum {
 						    not multiple of 16 bytes */
 	ATA_HORKAGE_FIRMWARE_WARN = (1 << 12),	/* firmware update warning */
 	ATA_HORKAGE_1_5_GBPS	= (1 << 13),	/* force 1.5 Gbps */
+	ATA_HORKAGE_NOSETXFER	= (1 << 14),	/* skip SETXFER, SATA only */
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */

commit e3cf95dd6d352954b663d2934110d6e30af2406d
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Thu Apr 9 17:31:17 2009 +0100

    ata: Report 16/32bit PIO as best we can
    
    The legacy old IDE ioctl API for this is a bit primitive so we try
    and map stuff sensibly onto it.
    
    - Set PIO over DMA devices to report 32bit
    - Add ability to change the PIO32 settings if the controller permits it
    - Add that functionality into the sff drivers
    - Add that functionality into the VLB legacy driver
    - Turn on the 32bit PIO on the ninja32 and add support there
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b450a2628855..3d501db36a26 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -209,6 +209,7 @@ enum {
 
 	/* bits 24:31 of ap->flags are reserved for LLD specific flags */
 
+
 	/* struct ata_port pflags */
 	ATA_PFLAG_EH_PENDING	= (1 << 0), /* EH pending */
 	ATA_PFLAG_EH_IN_PROGRESS = (1 << 1), /* EH in progress */
@@ -225,6 +226,9 @@ enum {
 	ATA_PFLAG_PM_PENDING	= (1 << 18), /* PM operation pending */
 	ATA_PFLAG_INIT_GTM_VALID = (1 << 19), /* initial gtm data valid */
 
+	ATA_PFLAG_PIO32		= (1 << 20),  /* 32bit PIO */
+	ATA_PFLAG_PIO32CHANGE	= (1 << 21),  /* 32bit PIO can be turned on/off */
+
 	/* struct ata_queued_cmd flags */
 	ATA_QCFLAG_ACTIVE	= (1 << 0), /* cmd not yet ack'd to scsi lyer */
 	ATA_QCFLAG_DMAMAP	= (1 << 1), /* SG table is DMA mapped */
@@ -689,7 +693,10 @@ struct ata_port {
 	struct Scsi_Host	*scsi_host; /* our co-allocated scsi host */
 	struct ata_port_operations *ops;
 	spinlock_t		*lock;
+	/* Flags owned by the EH context. Only EH should touch these once the
+	   port is active */
 	unsigned long		flags;	/* ATA_FLAG_xxx */
+	/* Flags that change dynamically, protected by ap->lock */
 	unsigned int		pflags; /* ATA_PFLAG_xxx */
 	unsigned int		print_id; /* user visible unique port ID */
 	unsigned int		port_no; /* 0 based port no. inside the host */
@@ -1595,6 +1602,7 @@ extern void ata_sff_drain_fifo(struct ata_queued_cmd *qc);
 extern void ata_sff_error_handler(struct ata_port *ap);
 extern void ata_sff_post_internal_cmd(struct ata_queued_cmd *qc);
 extern int ata_sff_port_start(struct ata_port *ap);
+extern int ata_sff_port_start32(struct ata_port *ap);
 extern void ata_sff_std_ports(struct ata_ioports *ioaddr);
 extern unsigned long ata_bmdma_mode_filter(struct ata_device *dev,
 					   unsigned long xfer_mask);

commit 877d03105d04b2c13e241130277fa69c8d2564f0
Author: Nick Andrew <nick@nick-andrew.net>
Date:   Mon Jan 26 11:06:57 2009 +0100

    trivial: Fix misspelling of firmware
    
    Fix misspelling of firmware.
    
    Signed-off-by: Nick Andrew <nick@nick-andrew.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 76262d83656b..b450a2628855 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -379,7 +379,7 @@ enum {
 	ATA_HORKAGE_BRIDGE_OK	= (1 << 10),	/* no bridge limits */
 	ATA_HORKAGE_ATAPI_MOD16_DMA = (1 << 11), /* use ATAPI DMA for commands
 						    not multiple of 16 bytes */
-	ATA_HORKAGE_FIRMWARE_WARN = (1 << 12),	/* firwmare update warning */
+	ATA_HORKAGE_FIRMWARE_WARN = (1 << 12),	/* firmware update warning */
 	ATA_HORKAGE_1_5_GBPS	= (1 << 13),	/* force 1.5 Gbps */
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT

commit c96f1732e25362d10ee7bcac1df8412a2e6b7d23
Author: Alan Cox <alan@redhat.com>
Date:   Tue Mar 24 10:23:46 2009 +0000

    [libata] Improve timeout handling
    
    On a timeout call a device specific handler early in the recovery so that
    we can complete and process successful commands which timed out due to IRQ
    loss or the like rather more elegantly.
    
    [Revised to exclude the timeout handling on a few devices that inherit from
     SFF but are not SFF enough to use the default timeout handler]
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 3a07a32dfc2e..76262d83656b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -795,6 +795,7 @@ struct ata_port_operations {
 	ata_reset_fn_t		pmp_hardreset;
 	ata_postreset_fn_t	pmp_postreset;
 	void (*error_handler)(struct ata_port *ap);
+	void (*lost_interrupt)(struct ata_port *ap);
 	void (*post_internal_cmd)(struct ata_queued_cmd *qc);
 
 	/*
@@ -1577,6 +1578,7 @@ extern bool ata_sff_qc_fill_rtf(struct ata_queued_cmd *qc);
 extern unsigned int ata_sff_host_intr(struct ata_port *ap,
 				      struct ata_queued_cmd *qc);
 extern irqreturn_t ata_sff_interrupt(int irq, void *dev_instance);
+extern void ata_sff_lost_interrupt(struct ata_port *ap);
 extern void ata_sff_freeze(struct ata_port *ap);
 extern void ata_sff_thaw(struct ata_port *ap);
 extern int ata_sff_prereset(struct ata_link *link, unsigned long deadline);

commit 3d47aa8e7e7b2aa09256590388aa8dddc79280f9
Author: Alan Cox <alan@redhat.com>
Date:   Tue Mar 24 10:23:19 2009 +0000

    [libata] Drain data on errors
    
    If the device is signalling that there is data to drain after an error we
    should read the bytes out and throw them away. Without this some devices
    and controllers get wedged and don't recover.
    
    Based on earlier work by Mark Lord
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 19af7d22a7f8..3a07a32dfc2e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -836,6 +836,8 @@ struct ata_port_operations {
 	void (*bmdma_start)(struct ata_queued_cmd *qc);
 	void (*bmdma_stop)(struct ata_queued_cmd *qc);
 	u8   (*bmdma_status)(struct ata_port *ap);
+
+	void (*drain_fifo)(struct ata_queued_cmd *qc);
 #endif /* CONFIG_ATA_SFF */
 
 	ssize_t (*em_show)(struct ata_port *ap, char *buf);
@@ -1587,6 +1589,7 @@ extern int ata_sff_softreset(struct ata_link *link, unsigned int *classes,
 extern int sata_sff_hardreset(struct ata_link *link, unsigned int *class,
 			       unsigned long deadline);
 extern void ata_sff_postreset(struct ata_link *link, unsigned int *classes);
+extern void ata_sff_drain_fifo(struct ata_queued_cmd *qc);
 extern void ata_sff_error_handler(struct ata_port *ap);
 extern void ata_sff_post_internal_cmd(struct ata_queued_cmd *qc);
 extern int ata_sff_port_start(struct ata_port *ap);

commit 1a660164c291f41b2aa853a7269b310933574ef9
Author: Mark Lord <mlord@pobox.com>
Date:   Wed Feb 25 15:18:32 2009 -0500

    [libata] Export ata_pio_queue_task() so that it can be used from sata_mv.
    
    Signed-off-by: Mark Lord <mlord@pobox.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index dc18b87ed722..19af7d22a7f8 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1008,6 +1008,9 @@ extern int ata_cable_sata(struct ata_port *ap);
 extern int ata_cable_ignore(struct ata_port *ap);
 extern int ata_cable_unknown(struct ata_port *ap);
 
+extern void ata_pio_queue_task(struct ata_port *ap, void *data,
+			       unsigned long delay);
+
 /* Timing helpers */
 extern unsigned int ata_pio_need_iordy(const struct ata_device *);
 extern const struct ata_timing *ata_timing_find_mode(u8 xfer_mode);

commit 84bda12af31f930e4200c5244aa111de2485d7b0
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Mar 2 18:53:26 2009 +0900

    libata: align ap->sector_buf
    
    ap->sector_buf is used as DMA target and should at least be aligned on
    cacheline.  This caused problems on some embedded machines.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index fbf064e13ad5..dc18b87ed722 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -751,7 +751,8 @@ struct ata_port {
 	acpi_handle		acpi_handle;
 	struct ata_acpi_gtm	__acpi_init_gtm; /* use ata_acpi_init_gtm() */
 #endif
-	u8			sector_buf[ATA_SECT_SIZE]; /* owned by EH */
+	/* owned by EH */
+	u8			sector_buf[ATA_SECT_SIZE] ____cacheline_aligned;
 };
 
 /* The following initializer overrides a method to NULL whether one of

commit 5825627c9463581fd9e70f8285685889ae5bb9bb
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Fri Feb 27 17:35:43 2009 +0900

    libata: fix dma_unmap_sg misuse
    
    libata passes the returned value of dma_map_sg() to
    dma_unmap_sg(),which is the misuse of dma_unmap_sg().
    
    DMA-mapping.txt says:
    
    To unmap a scatterlist, just call:
    
            pci_unmap_sg(pdev, sglist, nents, direction);
    
    Again, make sure DMA activity has already finished.
    
    PLEASE NOTE:  The 'nents' argument to the pci_unmap_sg call must be
                  the _same_ one you passed into the pci_map_sg call,
                  it should _NOT_ be the 'count' value _returned_ from the
                  pci_map_sg call.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Acked-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index dd818c7decd7..fbf064e13ad5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -530,6 +530,7 @@ struct ata_queued_cmd {
 	unsigned long		flags;		/* ATA_QCFLAG_xxx */
 	unsigned int		tag;
 	unsigned int		n_elem;
+	unsigned int		orig_n_elem;
 
 	int			dma_dir;
 

commit e7d3ef13d52a126438f687a1a32da65ff926ed57
Author: Stuart Hayes <stuart_hayes@dell.com>
Date:   Wed Mar 4 11:59:46 2009 -0800

    libata: change drive ready wait after hard reset to 5s
    
    This fixes problems during resume with drives that take longer than 1s to
    be ready.  The ATA-6 spec appears to allow 5 seconds for a drive to be
    ready.
    
    On one affected system, this patch changes "PM: resume devices took..."
    message from 17 seconds to 4 seconds, and gets rid of a lot of ugly
    timeout/error messages.
    
    Without this patch, the libata code moves on after 1s, tries to send a
    soft reset (which the drive doesn't see because it isn't ready) which also
    times out, then an IDENTIFY command is sent to the drive which times out,
    and finally the error handler will try to send another hard reset which
    will finally get things working.
    
    Signed-off-by: Stuart Hayes <stuart_hayes@dell.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 5d87bc09a1f5..dd818c7decd7 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -275,7 +275,7 @@ enum {
 	 * advised to wait only for the following duration before
 	 * doing SRST.
 	 */
-	ATA_TMOUT_PMP_SRST_WAIT	= 1000,
+	ATA_TMOUT_PMP_SRST_WAIT	= 5000,
 
 	/* ATA bus states */
 	BUS_UNKNOWN		= 0,

commit 9062712fa9ed13b531dfc2228086650b8bd6a255
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Jan 29 20:31:36 2009 +0900

    libata: implement HORKAGE_1_5_GBPS and apply it to WD My Book
    
    3Gbps is often much more prone to transmission failures.  It's usually
    okay to let EH handle speed down after transmission failures but some
    WD My Book drives completely shutdown after certain transmission
    failures and after it only power cycling can revive them.  Combined
    with the fact that external drives often end up with cable assembly
    which is longer than usual and more likely to have intervening gender,
    this makes these drives very likely to shutdown under certain
    configurations virtually rendering them unusable.
    
    This patch implements HOARKGE_1_5_GBPS and applies it to WD My Book
    such that 1.5Gbps is forced once the device is identified.
    
    Please take a look at the following bz for related reports.
    
      http://bugzilla.kernel.org/show_bug.cgi?id=9913
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 9dcefee5843c..5d87bc09a1f5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -380,6 +380,7 @@ enum {
 	ATA_HORKAGE_ATAPI_MOD16_DMA = (1 << 11), /* use ATAPI DMA for commands
 						    not multiple of 16 bytes */
 	ATA_HORKAGE_FIRMWARE_WARN = (1 << 12),	/* firwmare update warning */
+	ATA_HORKAGE_1_5_GBPS	= (1 << 13),	/* force 1.5 Gbps */
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */

commit 99cf610aa4840d822cdc67d194b23b55010ca9bd
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Jan 29 20:31:32 2009 +0900

    libata: clear dev->ering in smarter way
    
    dev->ering used to be cleared together with the rest of ata_device in
    ata_dev_init() which is called whenever a probing event occurs.
    dev->ering is about to be used to track probing failures so it needs
    to remain persistent over multiple porbing events.  This patch
    achieves this by doing the following.
    
    * Instead of CLEAR_OFFSET, define CLEAR_BEGIN and CLEAR_END and only
      clear between BEGIN and END.  ering is moved after END.  The split
      of persistent area is to allow hotter items remain at the head.
    
    * ering is explicitly cleared on ata_dev_disable() and when device
      attach succeeds.  So, ering is persistent throug a device's life
      time (unless explicitly cleared of course) and also through periods
      inbetween disablement of an attached device and successful detection
      of the next one.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index bca3ba25f52a..9dcefee5843c 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -580,7 +580,7 @@ struct ata_device {
 	acpi_handle		acpi_handle;
 	union acpi_object	*gtf_cache;
 #endif
-	/* n_sector is used as CLEAR_OFFSET, read comment above CLEAR_OFFSET */
+	/* n_sector is CLEAR_BEGIN, read comment above CLEAR_BEGIN */
 	u64			n_sectors;	/* size of device, if ATA */
 	unsigned int		class;		/* ATA_DEV_xxx */
 	unsigned long		unpark_deadline;
@@ -605,20 +605,22 @@ struct ata_device {
 	u16			heads;		/* Number of heads */
 	u16			sectors;	/* Number of sectors per track */
 
-	/* error history */
-	int			spdn_cnt;
-	struct ata_ering	ering;
-
 	union {
 		u16		id[ATA_ID_WORDS]; /* IDENTIFY xxx DEVICE data */
 		u32		gscr[SATA_PMP_GSCR_DWORDS]; /* PMP GSCR block */
 	};
+
+	/* error history */
+	int			spdn_cnt;
+	/* ering is CLEAR_END, read comment above CLEAR_END */
+	struct ata_ering	ering;
 };
 
-/* Offset into struct ata_device.  Fields above it are maintained
- * acress device init.  Fields below are zeroed.
+/* Fields between ATA_DEVICE_CLEAR_BEGIN and ATA_DEVICE_CLEAR_END are
+ * cleared to zero on ata_dev_init().
  */
-#define ATA_DEVICE_CLEAR_OFFSET		offsetof(struct ata_device, n_sectors)
+#define ATA_DEVICE_CLEAR_BEGIN		offsetof(struct ata_device, n_sectors)
+#define ATA_DEVICE_CLEAR_END		offsetof(struct ata_device, ering)
 
 struct ata_eh_info {
 	struct ata_device	*dev;		/* offending device */

commit 2a6e58d2731dcc05dafa7f976d935e0f0627fcd7
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jan 19 20:56:43 2009 +0100

    SATA: Blacklisting of systems that spin off disks during ACPI power off
    
    Introduce new libata flags ATA_FLAG_NO_POWEROFF_SPINDOWN and
    ATA_FLAG_NO_HIBERNATE_SPINDOWN that, if set, will prevent disks from
    being spun off during system power off and hibernation, respectively
    (to handle the hibernation case we need the new system state
    SYSTEM_HIBERNATE_ENTER that can be checked against by libata, in
    analogy with SYSTEM_POWER_OFF).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 2c6bd66209ff..bca3ba25f52a 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -187,6 +187,8 @@ enum {
 	ATA_FLAG_PIO_POLLING	= (1 << 9), /* use polling PIO if LLD
 					     * doesn't handle PIO interrupts */
 	ATA_FLAG_NCQ		= (1 << 10), /* host supports NCQ */
+	ATA_FLAG_NO_POWEROFF_SPINDOWN = (1 << 11), /* don't spindown before poweroff */
+	ATA_FLAG_NO_HIBERNATE_SPINDOWN = (1 << 12), /* don't spindown before hibernation */
 	ATA_FLAG_DEBUGMSG	= (1 << 13),
 	ATA_FLAG_IGN_SIMPLEX	= (1 << 15), /* ignore SIMPLEX */
 	ATA_FLAG_NO_IORDY	= (1 << 16), /* controller lacks iordy */

commit 3ada9c126499dd4700dcdbd5b9fe8110ad17f578
Author: David Daney <ddaney@caviumnetworks.com>
Date:   Thu Jan 15 17:45:31 2009 -0800

    libata: Add another column to the ata_timing table.
    
    The forthcoming OCTEON SOC Compact Flash driver needs an additional
    timing value that was not available in the ata_timing table.  I add a
    new column for dmack_hold time.  The values were obtained from the
    Compact Flash specification Rev 4.1.
    
    Signed-off-by: David Daney <ddaney@caviumnetworks.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 73b69c7071c5..2c6bd66209ff 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -401,12 +401,14 @@ enum {
 				  ATA_TIMING_CYC8B,
 	ATA_TIMING_ACTIVE	= (1 << 4),
 	ATA_TIMING_RECOVER	= (1 << 5),
-	ATA_TIMING_CYCLE	= (1 << 6),
-	ATA_TIMING_UDMA		= (1 << 7),
+	ATA_TIMING_DMACK_HOLD	= (1 << 6),
+	ATA_TIMING_CYCLE	= (1 << 7),
+	ATA_TIMING_UDMA		= (1 << 8),
 	ATA_TIMING_ALL		= ATA_TIMING_SETUP | ATA_TIMING_ACT8B |
 				  ATA_TIMING_REC8B | ATA_TIMING_CYC8B |
 				  ATA_TIMING_ACTIVE | ATA_TIMING_RECOVER |
-				  ATA_TIMING_CYCLE | ATA_TIMING_UDMA,
+				  ATA_TIMING_DMACK_HOLD | ATA_TIMING_CYCLE |
+				  ATA_TIMING_UDMA,
 };
 
 enum ata_xfer_mask {
@@ -866,6 +868,7 @@ struct ata_timing {
 	unsigned short cyc8b;		/* t0 for 8-bit I/O */
 	unsigned short active;		/* t2 or tD */
 	unsigned short recover;		/* t2i or tK */
+	unsigned short dmack_hold;	/* tj */
 	unsigned short cycle;		/* t0 */
 	unsigned short udma;		/* t2CYCTYP/2 */
 };

commit 94be9a58d7e683ac3c1df1858a17f09ebade8da0
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Jan 16 10:17:09 2009 -0500

    [libata] get-identity ioctl: Fix use of invalid memory pointer
    for SAS drivers.
    
    Caught by Ke Wei (and team?) at Marvell.
    
    Also, move the ata_scsi_ioctl export to libata-scsi.c, as that seems to be the
    general trend.
    
    Acked-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b6b8a7f3ec66..73b69c7071c5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -927,6 +927,8 @@ extern void ata_host_init(struct ata_host *, struct device *,
 extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
 extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));
+extern int ata_sas_scsi_ioctl(struct ata_port *ap, struct scsi_device *dev,
+			    int cmd, void __user *arg);
 extern void ata_sas_port_destroy(struct ata_port *);
 extern struct ata_port *ata_sas_port_alloc(struct ata_host *,
 					   struct ata_port_info *, struct Scsi_Host *);

commit 886ad09fc83342aa1c5a02a0b6d3298b78a8067f
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Fri Jan 9 15:54:07 2009 -0800

    libata: Add a per-host flag to opt-in into parallel port probes
    
    This patch adds a per host flag that allows drivers to opt in into
    having its busses scanned in parallel.
    
    Drivers that do not set this flag get their ports scanned in
    the "original" sequence.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 4f7c8fb4d3fe..b6b8a7f3ec66 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -239,6 +239,7 @@ enum {
 	/* host set flags */
 	ATA_HOST_SIMPLEX	= (1 << 0),	/* Host is simplex, one DMA channel per host only */
 	ATA_HOST_STARTED	= (1 << 1),	/* Host started */
+	ATA_HOST_PARALLEL_SCAN	= (1 << 2),	/* Ports on this host can be scanned in parallel */
 
 	/* bits 24:31 of host->flags are reserved for LLD specific flags */
 

commit 871af1210f13966ab911ed2166e4ab2ce775b99d
Author: Alan Cox <alan@redhat.com>
Date:   Mon Jan 5 14:16:39 2009 +0000

    libata: Add 32bit PIO support
    
    This matters for some controllers and in one or two cases almost doubles
    PIO performance. Add a bmdma32 operations set we can inherit and activate
    it for some controllers
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 3449de597eff..4f7c8fb4d3fe 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1518,6 +1518,7 @@ extern void sata_pmp_error_handler(struct ata_port *ap);
 
 extern const struct ata_port_operations ata_sff_port_ops;
 extern const struct ata_port_operations ata_bmdma_port_ops;
+extern const struct ata_port_operations ata_bmdma32_port_ops;
 
 /* PIO only, sg_tablesize and dma_boundary limits can be removed */
 #define ATA_PIO_SHT(drv_name)					\
@@ -1545,6 +1546,8 @@ extern void ata_sff_exec_command(struct ata_port *ap,
 				 const struct ata_taskfile *tf);
 extern unsigned int ata_sff_data_xfer(struct ata_device *dev,
 			unsigned char *buf, unsigned int buflen, int rw);
+extern unsigned int ata_sff_data_xfer32(struct ata_device *dev,
+			unsigned char *buf, unsigned int buflen, int rw);
 extern unsigned int ata_sff_data_xfer_noirq(struct ata_device *dev,
 			unsigned char *buf, unsigned int buflen, int rw);
 extern u8 ata_sff_irq_on(struct ata_port *ap);

commit ece180d1cfe5fa751eaa85bf796cf28b2150af15
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 3 20:04:37 2008 +0900

    libata: perform port detach in EH
    
    ata_port_detach() first made sure EH saw ATA_PFLAG_UNLOADING and then
    assumed EH context belongs to it and performed detach operation
    itself.  However, UNLOADING doesn't disable all of EH and this could
    lead to problems including triggering WARN_ON()'s in EH path.
    
    This patch makes port detach behave more like other EH actions such
    that ata_port_detach() requests EH to detach and waits for completion.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 3b2a0c6444ee..3449de597eff 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -213,10 +213,11 @@ enum {
 	ATA_PFLAG_FROZEN	= (1 << 2), /* port is frozen */
 	ATA_PFLAG_RECOVERED	= (1 << 3), /* recovery action performed */
 	ATA_PFLAG_LOADING	= (1 << 4), /* boot/loading probe */
-	ATA_PFLAG_UNLOADING	= (1 << 5), /* module is unloading */
 	ATA_PFLAG_SCSI_HOTPLUG	= (1 << 6), /* SCSI hotplug scheduled */
 	ATA_PFLAG_INITIALIZING	= (1 << 7), /* being initialized, don't touch */
 	ATA_PFLAG_RESETTING	= (1 << 8), /* reset in progress */
+	ATA_PFLAG_UNLOADING	= (1 << 9), /* driver is being unloaded */
+	ATA_PFLAG_UNLOADED	= (1 << 10), /* driver is unloaded */
 
 	ATA_PFLAG_SUSPENDED	= (1 << 17), /* port is suspended (power) */
 	ATA_PFLAG_PM_PENDING	= (1 << 18), /* PM operation pending */

commit 1eca4365be25c540650693e941bc06a66cf38f94
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 3 20:03:17 2008 +0900

    libata: beef up iterators
    
    There currently are the following looping constructs.
    
    * __ata_port_for_each_link() for all available links
    * ata_port_for_each_link() for edge links
    * ata_link_for_each_dev() for all devices
    * ata_link_for_each_dev_reverse() for all devices in reverse order
    
    Now there's a need for looping construct which is similar to
    __ata_port_for_each_link() but iterates over PMP links before the host
    link.  Instead of adding another one with long name, do the following
    cleanup.
    
    * Implement and export ata_link_next() and ata_dev_next() which take
      @mode parameter and can be used to build custom loop.
    * Implement ata_for_each_link() and ata_for_each_dev() which take
      looping mode explicitly.
    
    The following iteration modes are implemented.
    
    * ATA_LITER_EDGE                : loop over edge links
    * ATA_LITER_HOST_FIRST          : loop over all links, host link first
    * ATA_LITER_PMP_FIRST           : loop over all links, PMP links first
    
    * ATA_DITER_ENABLED             : loop over enabled devices
    * ATA_DITER_ENABLED_REVERSE     : loop over enabled devices in reverse order
    * ATA_DITER_ALL                 : loop over all devices
    * ATA_DITER_ALL_REVERSE         : loop over all devices in reverse order
    
    This change removes exlicit device enabledness checks from many loops
    and makes it clear which ones are iterated over in which direction.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ed3f26eb5df1..3b2a0c6444ee 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1285,26 +1285,62 @@ static inline int ata_link_active(struct ata_link *link)
 	return ata_tag_valid(link->active_tag) || link->sactive;
 }
 
-extern struct ata_link *__ata_port_next_link(struct ata_port *ap,
-					     struct ata_link *link,
-					     bool dev_only);
-
-#define __ata_port_for_each_link(link, ap) \
-	for ((link) = __ata_port_next_link((ap), NULL, false); (link); \
-	     (link) = __ata_port_next_link((ap), (link), false))
-
-#define ata_port_for_each_link(link, ap) \
-	for ((link) = __ata_port_next_link((ap), NULL, true); (link); \
-	     (link) = __ata_port_next_link((ap), (link), true))
-
-#define ata_link_for_each_dev(dev, link) \
-	for ((dev) = (link)->device; \
-	     (dev) < (link)->device + ata_link_max_devices(link) || ((dev) = NULL); \
-	     (dev)++)
-
-#define ata_link_for_each_dev_reverse(dev, link) \
-	for ((dev) = (link)->device + ata_link_max_devices(link) - 1; \
-	     (dev) >= (link)->device || ((dev) = NULL); (dev)--)
+/*
+ * Iterators
+ *
+ * ATA_LITER_* constants are used to select link iteration mode and
+ * ATA_DITER_* device iteration mode.
+ *
+ * For a custom iteration directly using ata_{link|dev}_next(), if
+ * @link or @dev, respectively, is NULL, the first element is
+ * returned.  @dev and @link can be any valid device or link and the
+ * next element according to the iteration mode will be returned.
+ * After the last element, NULL is returned.
+ */
+enum ata_link_iter_mode {
+	ATA_LITER_EDGE,		/* if present, PMP links only; otherwise,
+				 * host link.  no slave link */
+	ATA_LITER_HOST_FIRST,	/* host link followed by PMP or slave links */
+	ATA_LITER_PMP_FIRST,	/* PMP links followed by host link,
+				 * slave link still comes after host link */
+};
+
+enum ata_dev_iter_mode {
+	ATA_DITER_ENABLED,
+	ATA_DITER_ENABLED_REVERSE,
+	ATA_DITER_ALL,
+	ATA_DITER_ALL_REVERSE,
+};
+
+extern struct ata_link *ata_link_next(struct ata_link *link,
+				      struct ata_port *ap,
+				      enum ata_link_iter_mode mode);
+
+extern struct ata_device *ata_dev_next(struct ata_device *dev,
+				       struct ata_link *link,
+				       enum ata_dev_iter_mode mode);
+
+/*
+ * Shortcut notation for iterations
+ *
+ * ata_for_each_link() iterates over each link of @ap according to
+ * @mode.  @link points to the current link in the loop.  @link is
+ * NULL after loop termination.  ata_for_each_dev() works the same way
+ * except that it iterates over each device of @link.
+ *
+ * Note that the mode prefixes ATA_{L|D}ITER_ shouldn't need to be
+ * specified when using the following shorthand notations.  Only the
+ * mode itself (EDGE, HOST_FIRST, ENABLED, etc...) should be
+ * specified.  This not only increases brevity but also makes it
+ * impossible to use ATA_LITER_* for device iteration or vice-versa.
+ */
+#define ata_for_each_link(link, ap, mode) \
+	for ((link) = ata_link_next(NULL, (ap), ATA_LITER_##mode); (link); \
+	     (link) = ata_link_next((link), (ap), ATA_LITER_##mode))
+
+#define ata_for_each_dev(dev, link, mode) \
+	for ((dev) = ata_dev_next(NULL, (link), ATA_DITER_##mode); (dev); \
+	     (dev) = ata_dev_next((dev), (link), ATA_DITER_##mode))
 
 /**
  *	ata_ncq_enabled - Test whether NCQ is enabled

commit ac70a964b0e22a95af3628c344815857a01461b7
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 27 13:36:48 2008 +0900

    libata: blacklist Seagate drives which time out FLUSH_CACHE when used with NCQ
    
    Some recent Seagate harddrives have firmware bug which causes FLUSH
    CACHE to timeout under certain circumstances if NCQ is being used.
    This can be worked around by disabling NCQ and fixed by updating the
    firmware.  Implement ATA_HORKAGE_FIRMWARE_UPDATE and blacklist these
    devices.
    
    The wiki page has been updated to contain information on this issue.
    
      http://ata.wiki.kernel.org/index.php/Known_issues
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 59b0f1c807b5..ed3f26eb5df1 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -375,6 +375,7 @@ enum {
 	ATA_HORKAGE_BRIDGE_OK	= (1 << 10),	/* no bridge limits */
 	ATA_HORKAGE_ATAPI_MOD16_DMA = (1 << 11), /* use ATAPI DMA for commands
 						    not multiple of 16 bytes */
+	ATA_HORKAGE_FIRMWARE_WARN = (1 << 12),	/* firwmare update warning */
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */

commit 8a8bc22332ee6ea49137508467a76aa7f4367719
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 10 14:48:21 2008 +0900

    libata: revert convert-to-block-tagging patches
    
    This patch reverts the following three commits which convert libata to
    use block layer tagging.
    
     43a49cbdf31e812c0d8f553d433b09b421f5d52c
     e013e13bf605b9e6b702adffbe2853cfc60e7806
     2fca5ccf97d2c28bcfce44f5b07d85e74e3cd18e
    
    Although using block layer tagging is the right direction, due to the
    tight coupling among tag number, data structure allocation and
    hardware command slot allocation, libata doesn't work correctly with
    the current conversion.
    
    The biggest problem is guaranteeing that tag 0 is always used for
    non-NCQ commands.  Due to the way blk-tag is implemented and how SCSI
    starts and finishes requests, such guarantee can't be made.  I'm not
    sure whether this would actually break any low level driver but it
    doesn't look like a good idea to break such assumption given the
    frailty of ATA controllers.
    
    So, for the time being, keep using the old dumb in-libata qc
    allocation.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Jens Axobe <jens.axboe@oracle.com>
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c7665a4134c5..59b0f1c807b5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -698,6 +698,7 @@ struct ata_port {
 	unsigned int		cbl;	/* cable type; ATA_CBL_xxx */
 
 	struct ata_queued_cmd	qcmd[ATA_MAX_QUEUE];
+	unsigned long		qc_allocated;
 	unsigned int		qc_active;
 	int			nr_active_links; /* #links with active qcs */
 

commit 6a87e42e955ff27e07a77f65f8f077dc7c4171e1
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 3 19:01:09 2008 +0900

    libata: implement ATA_HORKAGE_ATAPI_MOD16_DMA and apply it
    
    libata always uses PIO for ATAPI commands when the number of bytes to
    transfer isn't multiple of 16 but quantum DAT72 chokes on odd bytes
    PIO transfers.  Implement a horkage to skip the mod16 check and apply
    it to the quantum device.
    
    This is reported by John Clark in the following thread.
    
      http://thread.gmane.org/gmane.linux.ide/34748
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: John Clark <clarkjc@runbox.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index f5441edee55f..c7665a4134c5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -373,6 +373,8 @@ enum {
 	ATA_HORKAGE_IVB		= (1 << 8),	/* cbl det validity bit bugs */
 	ATA_HORKAGE_STUCK_ERR	= (1 << 9),	/* stuck ERR on next PACKET */
 	ATA_HORKAGE_BRIDGE_OK	= (1 << 10),	/* no bridge limits */
+	ATA_HORKAGE_ATAPI_MOD16_DMA = (1 << 11), /* use ATAPI DMA for commands
+						    not multiple of 16 bytes */
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */

commit 9ce8e3073d9cfd6f859c22a25441db41b85cbf6e
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Wed Aug 27 15:23:18 2008 +0200

    libata: add whitelist for devices with known good pata-sata bridges
    
    libata currently imposes a UDMA5 max transfer rate and 200 sector max
    transfer size for SATA devices that sit behind a pata-sata bridge. Lots
    of devices have known good bridges that don't need this limit applied.
    The MTRON SSD disks are such devices. Transfer rates are increased by
    20-30% with the restriction removed.
    
    So add a "blacklist" entry for the MTRON devices, with a flag indicating
    that the bridge is known good.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 507f53ef8038..f5441edee55f 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -372,6 +372,7 @@ enum {
 	ATA_HORKAGE_IPM		= (1 << 7),	/* Link PM problems */
 	ATA_HORKAGE_IVB		= (1 << 8),	/* cbl det validity bit bugs */
 	ATA_HORKAGE_STUCK_ERR	= (1 << 9),	/* stuck ERR on next PACKET */
+	ATA_HORKAGE_BRIDGE_OK	= (1 << 10),	/* no bridge limits */
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */

commit 2fca5ccf97d2c28bcfce44f5b07d85e74e3cd18e
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Wed Oct 22 09:34:49 2008 +0200

    libata: switch to using block layer tagging support
    
    libata currently has a pretty dumb ATA_MAX_QUEUE loop for finding
    a free tag to use. Instead of fixing that up, convert libata to
    using block layer tagging - gets rid of code in libata, and is also
    much faster.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c261aa0584b1..507f53ef8038 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -695,7 +695,6 @@ struct ata_port {
 	unsigned int		cbl;	/* cable type; ATA_CBL_xxx */
 
 	struct ata_queued_cmd	qcmd[ATA_MAX_QUEUE];
-	unsigned long		qc_allocated;
 	unsigned int		qc_active;
 	int			nr_active_links; /* #links with active qcs */
 

commit 848e4c68c4695beae563f9a3d59fce596b466a74
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Oct 21 14:26:39 2008 +0900

    libata: transfer EHI control flags to slave ehc.i
    
    ATA_EHI_NO_AUTOPSY and ATA_EHI_QUIET are used to control the behavior
    of EH.  As only the master link is visible outside EH, these flags are
    set only for the master link although they should also apply to the
    slave link, which causes spurious EH messages during probe and
    suspend/resume.
    
    This patch transfers those two flags to slave ehc.i before performing
    slave autopsy and reporting.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 947cf84e555d..c261aa0584b1 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -340,6 +340,9 @@ enum {
 
 	ATA_EHI_DID_RESET	= ATA_EHI_DID_SOFTRESET | ATA_EHI_DID_HARDRESET,
 
+	/* mask of flags to transfer *to* the slave link */
+	ATA_EHI_TO_SLAVE_MASK	= ATA_EHI_NO_AUTOPSY | ATA_EHI_QUIET,
+
 	/* max tries if error condition is still set after ->error_handler */
 	ATA_EH_MAX_TRIES	= 5,
 

commit 6866e7bc83f13a1bc6de59099930e9db1ab0042f
Author: Richard Kennedy <richard@rsk.demon.co.uk>
Date:   Mon Sep 22 14:47:13 2008 -0700

    libata: reorder ata_device to remove 8 bytes of padding on 64 bits
    
    reduce size by 8 bytes from 1160 to 1152 allowing it to fit in 1 fewer
    cachelines.
    
    Signed-off-by: Richard Kennedy <richard@rsk.demon.co.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 1f44cfb847e1..947cf84e555d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -560,8 +560,8 @@ struct ata_ering {
 struct ata_device {
 	struct ata_link		*link;
 	unsigned int		devno;		/* 0 or 1 */
-	unsigned long		flags;		/* ATA_DFLAG_xxx */
 	unsigned int		horkage;	/* List of broken features */
+	unsigned long		flags;		/* ATA_DFLAG_xxx */
 	struct scsi_device	*sdev;		/* attached SCSI device */
 #ifdef CONFIG_ATA_ACPI
 	acpi_handle		acpi_handle;

commit 45fabbb77bd95adff7a80bde1c7a0ace1075fde6
Author: Elias Oltmanns <eo@nebensachen.de>
Date:   Sun Sep 21 11:54:08 2008 +0200

    libata: Implement disk shock protection support
    
    On user request (through sysfs), the IDLE IMMEDIATE command with UNLOAD
    FEATURE as specified in ATA-7 is issued to the device and processing of
    the request queue is stopped thereafter until the specified timeout
    expires or user space asks to resume normal operation. This is supposed
    to prevent the heads of a hard drive from accidentally crashing onto the
    platter when a heavy shock is anticipated (like a falling laptop
    expected to hit the floor). In fact, the whole port stops processing
    commands until the timeout has expired in order to avoid any resets due
    to failed commands on another device.
    
    Signed-off-by: Elias Oltmanns <eo@nebensachen.de>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 244ff601559a..1f44cfb847e1 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -146,6 +146,7 @@ enum {
 	ATA_DFLAG_SPUNDOWN	= (1 << 14), /* XXX: for spindown_compat */
 	ATA_DFLAG_SLEEPING	= (1 << 15), /* device is sleeping */
 	ATA_DFLAG_DUBIOUS_XFER	= (1 << 16), /* data transfer not verified */
+	ATA_DFLAG_NO_UNLOAD	= (1 << 17), /* device doesn't support unload */
 	ATA_DFLAG_INIT_MASK	= (1 << 24) - 1,
 
 	ATA_DFLAG_DETACH	= (1 << 24),
@@ -244,6 +245,7 @@ enum {
 	ATA_TMOUT_BOOT		= 30000,	/* heuristic */
 	ATA_TMOUT_BOOT_QUICK	=  7000,	/* heuristic */
 	ATA_TMOUT_INTERNAL_QUICK = 5000,
+	ATA_TMOUT_MAX_PARK	= 30000,
 
 	/* FIXME: GoVault needs 2s but we can't afford that without
 	 * parallel probing.  800ms is enough for iVDR disk
@@ -319,8 +321,9 @@ enum {
 	ATA_EH_RESET		= ATA_EH_SOFTRESET | ATA_EH_HARDRESET,
 	ATA_EH_ENABLE_LINK	= (1 << 3),
 	ATA_EH_LPM		= (1 << 4),  /* link power management action */
+	ATA_EH_PARK		= (1 << 5), /* unload heads and stop I/O */
 
-	ATA_EH_PERDEV_MASK	= ATA_EH_REVALIDATE,
+	ATA_EH_PERDEV_MASK	= ATA_EH_REVALIDATE | ATA_EH_PARK,
 	ATA_EH_ALL_ACTIONS	= ATA_EH_REVALIDATE | ATA_EH_RESET |
 				  ATA_EH_ENABLE_LINK | ATA_EH_LPM,
 
@@ -454,6 +457,7 @@ enum link_pm {
 	MEDIUM_POWER,
 };
 extern struct device_attribute dev_attr_link_power_management_policy;
+extern struct device_attribute dev_attr_unload_heads;
 extern struct device_attribute dev_attr_em_message_type;
 extern struct device_attribute dev_attr_em_message;
 extern struct device_attribute dev_attr_sw_activity;
@@ -566,6 +570,7 @@ struct ata_device {
 	/* n_sector is used as CLEAR_OFFSET, read comment above CLEAR_OFFSET */
 	u64			n_sectors;	/* size of device, if ATA */
 	unsigned int		class;		/* ATA_DEV_xxx */
+	unsigned long		unpark_deadline;
 
 	u8			pio_mode;
 	u8			dma_mode;
@@ -623,6 +628,7 @@ struct ata_eh_context {
 					       [ATA_EH_CMD_TIMEOUT_TABLE_SIZE];
 	unsigned int		classes[ATA_MAX_DEVICES];
 	unsigned int		did_probe_mask;
+	unsigned int		unloaded_mask;
 	unsigned int		saved_ncq_enabled;
 	u8			saved_xfer_mode[ATA_MAX_DEVICES];
 	/* timestamp for the last reset attempt or success */
@@ -712,6 +718,7 @@ struct ata_port {
 	struct list_head	eh_done_q;
 	wait_queue_head_t	eh_wait_q;
 	int			eh_tries;
+	struct completion	park_req_pending;
 
 	pm_message_t		pm_mesg;
 	int			*pm_result;
@@ -1102,6 +1109,7 @@ extern void ata_std_error_handler(struct ata_port *ap);
  */
 extern const struct ata_port_operations ata_base_port_ops;
 extern const struct ata_port_operations sata_port_ops;
+extern struct device_attribute *ata_common_sdev_attrs[];
 
 #define ATA_BASE_SHT(drv_name)					\
 	.module			= THIS_MODULE,			\
@@ -1116,7 +1124,8 @@ extern const struct ata_port_operations sata_port_ops;
 	.proc_name		= drv_name,			\
 	.slave_configure	= ata_scsi_slave_config,	\
 	.slave_destroy		= ata_scsi_slave_destroy,	\
-	.bios_param		= ata_std_bios_param
+	.bios_param		= ata_std_bios_param,		\
+	.sdev_attrs		= ata_common_sdev_attrs
 
 #define ATA_NCQ_SHT(drv_name)					\
 	ATA_BASE_SHT(drv_name),					\

commit b1c72916abbdd0a55015c87358536ca0ebaf6735
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Jul 31 17:02:43 2008 +0900

    libata: implement slave_link
    
    Explanation taken from the comment of ata_slave_link_init().
    
     In libata, a port contains links and a link contains devices.  There
     is single host link but if a PMP is attached to it, there can be
     multiple fan-out links.  On SATA, there's usually a single device
     connected to a link but PATA and SATA controllers emulating TF based
     interface can have two - master and slave.
    
     However, there are a few controllers which don't fit into this
     abstraction too well - SATA controllers which emulate TF interface
     with both master and slave devices but also have separate SCR
     register sets for each device.  These controllers need separate links
     for physical link handling (e.g. onlineness, link speed) but should
     be treated like a traditional M/S controller for everything else
     (e.g. command issue, softreset).
    
     slave_link is libata's way of handling this class of controllers
     without impacting core layer too much.  For anything other than
     physical link handling, the default host link is used for both master
     and slave.  For physical link handling, separate @ap->slave_link is
     used.  All dirty details are implemented inside libata core layer.
     From LLD's POV, the only difference is that prereset, hardreset and
     postreset are called once more for the slave link, so the reset
     sequence looks like the following.
    
     prereset(M) -> prereset(S) -> hardreset(M) -> hardreset(S) ->
     softreset(M) -> postreset(M) -> postreset(S)
    
     Note that softreset is called only for the master.  Softreset resets
     both M/S by definition, so SRST on master should handle both (the
     standard method will work just fine).
    
    As slave_link excludes PMP support and only code paths which deal with
    the attributes of physical link are affected, all the changes are
    localized to libata.h, libata-core.c and libata-eh.c.
    
     * ata_is_host_link() updated so that slave_link is considered as host
       link too.
    
     * iterator extended to iterate over the slave_link when using the
       underbarred version.
    
     * force param handling updated such that devno 16 is mapped to the
       slave link/device.
    
     * ata_link_on/offline() updated to return the combined result from
       master and slave link.  ata_phys_link_on/offline() are the direct
       versions.
    
     * EH autopsy and report are performed separately for master slave
       links.  Reset is udpated to implement the above described reset
       sequence.
    
    Except for reset update, most changes are minor, many of them just
    modifying dev->link to ata_dev_phys_link(dev) or using phys online
    test instead.
    
    After this update, LLDs can take full advantage of per-dev SCR
    registers by simply turning on slave link.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 0c7e6f3c28eb..244ff601559a 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -690,7 +690,8 @@ struct ata_port {
 	unsigned int		qc_active;
 	int			nr_active_links; /* #links with active qcs */
 
-	struct ata_link		link;	/* host default link */
+	struct ata_link		link;		/* host default link */
+	struct ata_link		*slave_link;	/* see ata_slave_link_init() */
 
 	int			nr_pmp_links;	/* nr of available PMP links */
 	struct ata_link		*pmp_link;	/* array of PMP links */
@@ -897,6 +898,7 @@ extern void ata_port_disable(struct ata_port *);
 extern struct ata_host *ata_host_alloc(struct device *dev, int max_ports);
 extern struct ata_host *ata_host_alloc_pinfo(struct device *dev,
 			const struct ata_port_info * const * ppi, int n_ports);
+extern int ata_slave_link_init(struct ata_port *ap);
 extern int ata_host_start(struct ata_host *host);
 extern int ata_host_register(struct ata_host *host,
 			     struct scsi_host_template *sht);
@@ -1136,7 +1138,7 @@ static inline bool sata_pmp_attached(struct ata_port *ap)
 
 static inline int ata_is_host_link(const struct ata_link *link)
 {
-	return link == &link->ap->link;
+	return link == &link->ap->link || link == link->ap->slave_link;
 }
 #else /* CONFIG_SATA_PMP */
 static inline bool sata_pmp_supported(struct ata_port *ap)
@@ -1169,7 +1171,7 @@ static inline int sata_srst_pmp(struct ata_link *link)
 	printk("%sata%u: "fmt, lv, (ap)->print_id , ##args)
 
 #define ata_link_printk(link, lv, fmt, args...) do { \
-	if (sata_pmp_attached((link)->ap)) \
+	if (sata_pmp_attached((link)->ap) || (link)->ap->slave_link)	\
 		printk("%sata%u.%02u: "fmt, lv, (link)->ap->print_id,	\
 		       (link)->pmp , ##args); \
 	else \

commit b5b3fa386b8f96c7fa92e507e5deddc2637924b4
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Jul 31 17:02:42 2008 +0900

    libata: misc updates to prepare for slave link
    
    * Add ATA_EH_ALL_ACTIONS.
    
    * Make sata_link_{on|off}_line() return bool instead of int.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 3eaca347ce29..0c7e6f3c28eb 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -321,6 +321,8 @@ enum {
 	ATA_EH_LPM		= (1 << 4),  /* link power management action */
 
 	ATA_EH_PERDEV_MASK	= ATA_EH_REVALIDATE,
+	ATA_EH_ALL_ACTIONS	= ATA_EH_REVALIDATE | ATA_EH_RESET |
+				  ATA_EH_ENABLE_LINK | ATA_EH_LPM,
 
 	/* ata_eh_info->flags */
 	ATA_EHI_HOTPLUGGED	= (1 << 0),  /* could have been hotplugged */
@@ -920,8 +922,8 @@ extern int sata_scr_valid(struct ata_link *link);
 extern int sata_scr_read(struct ata_link *link, int reg, u32 *val);
 extern int sata_scr_write(struct ata_link *link, int reg, u32 val);
 extern int sata_scr_write_flush(struct ata_link *link, int reg, u32 val);
-extern int ata_link_online(struct ata_link *link);
-extern int ata_link_offline(struct ata_link *link);
+extern bool ata_link_online(struct ata_link *link);
+extern bool ata_link_offline(struct ata_link *link);
 #ifdef CONFIG_PM
 extern int ata_host_suspend(struct ata_host *host, pm_message_t mesg);
 extern void ata_host_resume(struct ata_host *host);

commit aadffb682cc5572f48cc24883681db65530bd284
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Jul 31 17:02:41 2008 +0900

    libata: reimplement link iterator
    
    Implement __ata_port_next_link() and reimplement
    __ata_port_for_each_link() and ata_port_for_each_link() using it.
    This removes relatively large inlined code and makes iteration easier
    to extend.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ffd622fa319c..3eaca347ce29 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1265,34 +1265,17 @@ static inline int ata_link_active(struct ata_link *link)
 	return ata_tag_valid(link->active_tag) || link->sactive;
 }
 
-static inline struct ata_link *ata_port_first_link(struct ata_port *ap)
-{
-	if (sata_pmp_attached(ap))
-		return ap->pmp_link;
-	return &ap->link;
-}
-
-static inline struct ata_link *ata_port_next_link(struct ata_link *link)
-{
-	struct ata_port *ap = link->ap;
-
-	if (ata_is_host_link(link)) {
-		if (!sata_pmp_attached(ap))
-			return NULL;
-		return ap->pmp_link;
-	}
-
-	if (++link < ap->nr_pmp_links + ap->pmp_link)
-		return link;
-	return NULL;
-}
+extern struct ata_link *__ata_port_next_link(struct ata_port *ap,
+					     struct ata_link *link,
+					     bool dev_only);
 
-#define __ata_port_for_each_link(lk, ap) \
-	for ((lk) = &(ap)->link; (lk); (lk) = ata_port_next_link(lk))
+#define __ata_port_for_each_link(link, ap) \
+	for ((link) = __ata_port_next_link((ap), NULL, false); (link); \
+	     (link) = __ata_port_next_link((ap), (link), false))
 
 #define ata_port_for_each_link(link, ap) \
-	for ((link) = ata_port_first_link(ap); (link); \
-	     (link) = ata_port_next_link(link))
+	for ((link) = __ata_port_next_link((ap), NULL, true); (link); \
+	     (link) = __ata_port_next_link((ap), (link), true))
 
 #define ata_link_for_each_dev(dev, link) \
 	for ((dev) = (link)->device; \

commit 82ef04fb4c82542b3eda81cca461f0594ce9cd0b
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Jul 31 17:02:40 2008 +0900

    libata: make SCR access ops per-link
    
    Logically, SCR access ops should take @link; however, there was no
    compelling reason to convert all SCR access ops when adding @link
    abstraction as there's one-to-one mapping between a port and a non-PMP
    link.  However, that assumption won't hold anymore with the scheduled
    addition of slave link.
    
    Make SCR access ops per-link.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 225bfc5bd9ec..ffd622fa319c 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -772,8 +772,8 @@ struct ata_port_operations {
 	/*
 	 * Optional features
 	 */
-	int  (*scr_read)(struct ata_port *ap, unsigned int sc_reg, u32 *val);
-	int  (*scr_write)(struct ata_port *ap, unsigned int sc_reg, u32 val);
+	int  (*scr_read)(struct ata_link *link, unsigned int sc_reg, u32 *val);
+	int  (*scr_write)(struct ata_link *link, unsigned int sc_reg, u32 val);
 	void (*pmp_attach)(struct ata_port *ap);
 	void (*pmp_detach)(struct ata_port *ap);
 	int  (*enable_pm)(struct ata_port *ap, enum link_pm policy);

commit b15b3ebae102f89c25ccbcae0b2099af312f2e82
Author: Alan Cox <alan@redhat.com>
Date:   Fri Aug 1 09:18:34 2008 +0100

    libata: Fix a large collection of DMA mode mismatches
    
    Dave Müller sent a diff for the pata_oldpiix that highlighted a problem
    where a lot of the ATA drivers assume dma_mode == 0 means "no DMA" while
    the core code uses 0xFF.
    
    This turns out to have other consequences such as code doing >= XFER_UDMA_0
    also catching 0xFF as UDMAlots. Fortunately it doesn't generally affect
    set_dma_mode, although some drivers call back into their own set mode code
    from other points.
    
    Having been through the drivers I've added helpers for using_udma/using_mwdma
    dma_enabled so that people don't open code ranges that may change (eg if UDMA8
    appears somewhere)
    
    Thanks to David for the initial bits
    [and added fix for pata_oldpiix from and signed-off-by Dave Mueller
     <dave.mueller@gmx.ch>  -jg]
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 80233fdc159f..225bfc5bd9ec 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1429,6 +1429,28 @@ static inline unsigned long ata_deadline(unsigned long from_jiffies,
 	return from_jiffies + msecs_to_jiffies(timeout_msecs);
 }
 
+/* Don't open code these in drivers as there are traps. Firstly the range may
+   change in future hardware and specs, secondly 0xFF means 'no DMA' but is
+   > UDMA_0. Dyma ddreigiau */
+
+static inline int ata_using_mwdma(struct ata_device *adev)
+{
+	if (adev->dma_mode >= XFER_MW_DMA_0 && adev->dma_mode <= XFER_MW_DMA_4)
+		return 1;
+	return 0;
+}
+
+static inline int ata_using_udma(struct ata_device *adev)
+{
+	if (adev->dma_mode >= XFER_UDMA_0 && adev->dma_mode <= XFER_UDMA_7)
+		return 1;
+	return 0;
+}
+
+static inline int ata_dma_enabled(struct ata_device *adev)
+{
+	return (adev->dma_mode == 0xFF ? 0 : 1);
+}
 
 /**************************************************************************
  * PMP - drivers/ata/libata-pmp.c

commit d127ea7b8643a93d14d1f3c542974407f14d3663
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Jul 31 16:09:34 2008 +0900

    libata: restore SControl on detach
    
    Save SControl during probing and restore it on detach.  This prevents
    adjustments made by libata drivers to seep into the next driver which
    gets attached (be it a libata one or not).
    
    It's not clear whether SControl also needs to be restored on suspend.
    The next system to have control (ACPI or kexec'd kernel) would
    probably like to see the original SControl value but there's no
    guarantee that a link is gonna keep working after SControl is adjusted
    without a reset and adding a reset and modified recovery cycle soley
    for this is an overkill.  For now, do it only for detach.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 5340d4c83fd9..80233fdc159f 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -647,6 +647,7 @@ struct ata_link {
 
 	unsigned int		flags;		/* ATA_LFLAG_xxx */
 
+	u32			saved_scontrol;	/* SControl on probe */
 	unsigned int		hw_sata_spd_limit;
 	unsigned int		sata_spd_limit;
 	unsigned int		sata_spd;	/* current SATA PHY speed */

commit 05944bdf6fadb5394710269df6770dde447b23ca
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Aug 13 20:19:09 2008 +0900

    libata: implement no[hs]rst force params
    
    Implement force params nohrst, nosrst and norst.  This is to work
    around reset related problems and ease debugging.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 06b80337303b..5340d4c83fd9 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -163,6 +163,7 @@ enum {
 	ATA_DEV_NONE		= 9,	/* no device */
 
 	/* struct ata_link flags */
+	ATA_LFLAG_NO_HRST	= (1 << 1), /* avoid hardreset */
 	ATA_LFLAG_NO_SRST	= (1 << 2), /* avoid softreset */
 	ATA_LFLAG_ASSUME_ATA	= (1 << 3), /* assume ATA class */
 	ATA_LFLAG_ASSUME_SEMB	= (1 << 4), /* assume SEMB class */

commit 963e4975c6f93c148ca809d986d412201df9af89
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Thu Jul 24 17:16:06 2008 +0100

    pata_it821x: Driver updates and reworking
    
    - Add support for the RDC 1010 variant
    - Rework the core library to have a read_id method. This allows the hacky
      bits of it821x to go and prepares us for pata_hd
    - Switch from WARN to BUG in ata_id_string as it will reboot if you get
      it wrong so WARN won't be seen
    - Allow the issue of command 0xFC on the 821x. This is needed to query
      rebuild status.
    - Tidy up printk formatting
    - Do more ident rewriting on RAID volumes to handle firmware provided
      ident data which is rather wonky
    - Report the firmware revision and device layout in RAID mode
    - Don't try and disable raid on the 8211 or RDC - they don't have the
      relevant bits
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d4b8e5fa3e8b..06b80337303b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -750,6 +750,7 @@ struct ata_port_operations {
 	void (*set_piomode)(struct ata_port *ap, struct ata_device *dev);
 	void (*set_dmamode)(struct ata_port *ap, struct ata_device *dev);
 	int  (*set_mode)(struct ata_link *link, struct ata_device **r_failed_dev);
+	unsigned int (*read_id)(struct ata_device *dev, struct ata_taskfile *tf, u16 *id);
 
 	void (*dev_config)(struct ata_device *dev);
 
@@ -951,6 +952,8 @@ extern void ata_id_string(const u16 *id, unsigned char *s,
 			  unsigned int ofs, unsigned int len);
 extern void ata_id_c_string(const u16 *id, unsigned char *s,
 			    unsigned int ofs, unsigned int len);
+extern unsigned int ata_do_dev_read_id(struct ata_device *dev,
+					struct ata_taskfile *tf, u16 *id);
 extern void ata_qc_complete(struct ata_queued_cmd *qc);
 extern int ata_qc_complete_multiple(struct ata_port *ap, u32 qc_active);
 extern void ata_scsi_simulate(struct ata_device *dev, struct scsi_cmnd *cmd,

commit 1f938d060a7bc01b5f82d46db3e38cd501b445a6
Author: Alexander Beregalov <a.beregalov@gmail.com>
Date:   Mon Jul 21 00:06:19 2008 +0400

    libata.h: replace __FUNCTION__ with __func__
    
    Signed-off-by: Alexander Beregalov <a.beregalov@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 5b247b8a6b3b..d4b8e5fa3e8b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -60,9 +60,9 @@
 
 /* note: prints function name for you */
 #ifdef ATA_DEBUG
-#define DPRINTK(fmt, args...) printk(KERN_ERR "%s: " fmt, __FUNCTION__, ## args)
+#define DPRINTK(fmt, args...) printk(KERN_ERR "%s: " fmt, __func__, ## args)
 #ifdef ATA_VERBOSE_DEBUG
-#define VPRINTK(fmt, args...) printk(KERN_ERR "%s: " fmt, __FUNCTION__, ## args)
+#define VPRINTK(fmt, args...) printk(KERN_ERR "%s: " fmt, __func__, ## args)
 #else
 #define VPRINTK(fmt, args...)
 #endif	/* ATA_VERBOSE_DEBUG */
@@ -71,7 +71,7 @@
 #define VPRINTK(fmt, args...)
 #endif	/* ATA_DEBUG */
 
-#define BPRINTK(fmt, args...) if (ap->flags & ATA_FLAG_DEBUGMSG) printk(KERN_ERR "%s: " fmt, __FUNCTION__, ## args)
+#define BPRINTK(fmt, args...) if (ap->flags & ATA_FLAG_DEBUGMSG) printk(KERN_ERR "%s: " fmt, __func__, ## args)
 
 /* NEW: debug levels */
 #define HAVE_LIBATA_MSG 1

commit 18f7ba4c2f4be6b37d925931f04d6cc28d88d1ee
Author: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
Date:   Tue Jun 3 10:33:55 2008 -0700

    libata/ahci: enclosure management support
    
    Add Enclosure Management support to libata and ahci.
    
    Signed-off-by:  Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 035f8e1cd0ac..5b247b8a6b3b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -169,6 +169,7 @@ enum {
 	ATA_LFLAG_ASSUME_CLASS	= ATA_LFLAG_ASSUME_ATA | ATA_LFLAG_ASSUME_SEMB,
 	ATA_LFLAG_NO_RETRY	= (1 << 5), /* don't retry this link */
 	ATA_LFLAG_DISABLED	= (1 << 6), /* link is disabled */
+	ATA_LFLAG_SW_ACTIVITY	= (1 << 7), /* keep activity stats */
 
 	/* struct ata_port flags */
 	ATA_FLAG_SLAVE_POSS	= (1 << 0), /* host supports slave dev */
@@ -191,6 +192,10 @@ enum {
 	ATA_FLAG_AN		= (1 << 18), /* controller supports AN */
 	ATA_FLAG_PMP		= (1 << 19), /* controller supports PMP */
 	ATA_FLAG_IPM		= (1 << 20), /* driver can handle IPM */
+	ATA_FLAG_EM		= (1 << 21), /* driver supports enclosure
+					      * management */
+	ATA_FLAG_SW_ACTIVITY	= (1 << 22), /* driver supports sw activity
+					      * led */
 
 	/* The following flag belongs to ap->pflags but is kept in
 	 * ap->flags because it's referenced in many LLDs and will be
@@ -446,6 +451,15 @@ enum link_pm {
 	MEDIUM_POWER,
 };
 extern struct device_attribute dev_attr_link_power_management_policy;
+extern struct device_attribute dev_attr_em_message_type;
+extern struct device_attribute dev_attr_em_message;
+extern struct device_attribute dev_attr_sw_activity;
+
+enum sw_activity {
+	OFF,
+	BLINK_ON,
+	BLINK_OFF,
+};
 
 #ifdef CONFIG_ATA_SFF
 struct ata_ioports {
@@ -701,6 +715,7 @@ struct ata_port {
 	struct timer_list	fastdrain_timer;
 	unsigned long		fastdrain_cnt;
 
+	int			em_message_type;
 	void			*private_data;
 
 #ifdef CONFIG_ATA_ACPI
@@ -792,6 +807,12 @@ struct ata_port_operations {
 	u8   (*bmdma_status)(struct ata_port *ap);
 #endif /* CONFIG_ATA_SFF */
 
+	ssize_t (*em_show)(struct ata_port *ap, char *buf);
+	ssize_t (*em_store)(struct ata_port *ap, const char *message,
+			    size_t size);
+	ssize_t (*sw_activity_show)(struct ata_device *dev, char *buf);
+	ssize_t (*sw_activity_store)(struct ata_device *dev,
+				     enum sw_activity val);
 	/*
 	 * Obsolete
 	 */

commit 87fbc5a060faf2394bee88a93519f9b9d434727c
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue May 20 02:17:54 2008 +0900

    libata: improve EH internal command timeout handling
    
    ATA_TMOUT_INTERNAL which was 30secs were used for all internal
    commands which is way too long when something goes wrong.  This patch
    implements command type based stepped timeouts.  Different command
    types can use different timeouts and each command type can use
    different timeout values after timeouts.
    
    ie. the initial timeout is set to a value which should cover most of
    the cases but not too long so that run away cases don't delay things
    too much.  After the first try times out, the second try can use
    longer timeout and if that one times out too, it can go for full 30sec
    timeout.
    
    IDENTIFYs use 5s - 10s - 30s timeout and all other commands use 5s -
    10s timeouts.
    
    This patch significantly cuts down the needed time to handle failure
    cases while still allowing libata to work with nut job devices through
    retries.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 9058c2a325a9..035f8e1cd0ac 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -237,7 +237,6 @@ enum {
 	/* various lengths of time */
 	ATA_TMOUT_BOOT		= 30000,	/* heuristic */
 	ATA_TMOUT_BOOT_QUICK	=  7000,	/* heuristic */
-	ATA_TMOUT_INTERNAL	= 30000,
 	ATA_TMOUT_INTERNAL_QUICK = 5000,
 
 	/* FIXME: GoVault needs 2s but we can't afford that without
@@ -341,6 +340,11 @@ enum {
 
 	SATA_PMP_RW_TIMEOUT	= 3000,		/* PMP read/write timeout */
 
+	/* This should match the actual table size of
+	 * ata_eh_cmd_timeout_table in libata-eh.c.
+	 */
+	ATA_EH_CMD_TIMEOUT_TABLE_SIZE = 5,
+
 	/* Horkage types. May be set by libata or controller on drives
 	   (some horkage may be drive/controller pair dependant */
 
@@ -598,6 +602,8 @@ struct ata_eh_info {
 struct ata_eh_context {
 	struct ata_eh_info	i;
 	int			tries[ATA_MAX_DEVICES];
+	int			cmd_timeout_idx[ATA_MAX_DEVICES]
+					       [ATA_EH_CMD_TIMEOUT_TABLE_SIZE];
 	unsigned int		classes[ATA_MAX_DEVICES];
 	unsigned int		did_probe_mask;
 	unsigned int		saved_ncq_enabled;

commit 0a2c0f56159999e20015241d3b8fa89b1ab14309
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue May 20 02:17:52 2008 +0900

    libata: improve EH retry delay handling
    
    EH retries were delayed by 5 seconds to ensure that resets don't occur
    back-to-back.  However, this 5 second delay is superflous or excessive
    in many cases.  For example, after IDENTIFY times out, there's no
    reason to wait five more seconds before retrying.
    
    This patch adds ehc->last_reset timestamp and record the timestamp for
    the last reset trial or success and uses it to space resets by
    ATA_EH_RESET_COOL_DOWN which is 5 secs and removes unconditional 5 sec
    sleeps.
    
    As this change makes inter-try waits often shorter and they're
    redundant in nature, this patch also removes the "retrying..."
    messages.
    
    While at it, convert explicit rounding up division to DIV_ROUND_UP().
    
    This change speeds up EH in many cases w/o sacrificing robustness.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 94110b652b30..9058c2a325a9 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -602,6 +602,8 @@ struct ata_eh_context {
 	unsigned int		did_probe_mask;
 	unsigned int		saved_ncq_enabled;
 	u8			saved_xfer_mode[ATA_MAX_DEVICES];
+	/* timestamp for the last reset attempt or success */
+	unsigned long		last_reset;
 };
 
 struct ata_acpi_drive

commit 341c2c958ec7bdd9f54733a8b0b432fe76842a82
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue May 20 02:17:51 2008 +0900

    libata: consistently use msecs for time durations
    
    libata has been using mix of jiffies and msecs for time druations.
    This is getting confusing.  As writing sub HZ values in jiffies is
    PITA and msecs_to_jiffies() can't be used as initializer, unify unit
    for all time durations to msecs.  So, durations are in msecs and
    deadlines are in jiffies.  ata_deadline() is added to compute deadline
    from a start time and duration in msecs.
    
    While at it, drop now superflous _msec suffix from arguments and
    rename @timeout to @deadline if it represents a fixed point in time
    rather than duration.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index e57e5d08312d..94110b652b30 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -27,6 +27,7 @@
 #define __LINUX_LIBATA_H__
 
 #include <linux/delay.h>
+#include <linux/jiffies.h>
 #include <linux/interrupt.h>
 #include <linux/dma-mapping.h>
 #include <linux/scatterlist.h>
@@ -115,7 +116,7 @@ enum {
 	/* tag ATA_MAX_QUEUE - 1 is reserved for internal commands */
 	ATA_MAX_QUEUE		= 32,
 	ATA_TAG_INTERNAL	= ATA_MAX_QUEUE - 1,
-	ATA_SHORT_PAUSE		= (HZ >> 6) + 1,
+	ATA_SHORT_PAUSE		= 16,
 
 	ATAPI_MAX_DRAIN		= 16 << 10,
 
@@ -234,17 +235,17 @@ enum {
 	/* bits 24:31 of host->flags are reserved for LLD specific flags */
 
 	/* various lengths of time */
-	ATA_TMOUT_BOOT		= 30 * HZ,	/* heuristic */
-	ATA_TMOUT_BOOT_QUICK	= 7 * HZ,	/* heuristic */
-	ATA_TMOUT_INTERNAL	= 30 * HZ,
-	ATA_TMOUT_INTERNAL_QUICK = 5 * HZ,
+	ATA_TMOUT_BOOT		= 30000,	/* heuristic */
+	ATA_TMOUT_BOOT_QUICK	=  7000,	/* heuristic */
+	ATA_TMOUT_INTERNAL	= 30000,
+	ATA_TMOUT_INTERNAL_QUICK = 5000,
 
 	/* FIXME: GoVault needs 2s but we can't afford that without
 	 * parallel probing.  800ms is enough for iVDR disk
 	 * HHD424020F7SV00.  Increase to 2secs when parallel probing
 	 * is in place.
 	 */
-	ATA_TMOUT_FF_WAIT	= 4 * HZ / 5,
+	ATA_TMOUT_FF_WAIT	=  800,
 
 	/* Spec mandates to wait for ">= 2ms" before checking status
 	 * after reset.  We wait 150ms, because that was the magic
@@ -256,14 +257,14 @@ enum {
 	 *
 	 * Old drivers/ide uses the 2mS rule and then waits for ready.
 	 */
-	ATA_WAIT_AFTER_RESET_MSECS = 150,
+	ATA_WAIT_AFTER_RESET	=  150,
 
 	/* If PMP is supported, we have to do follow-up SRST.  As some
 	 * PMPs don't send D2H Reg FIS after hardreset, LLDs are
 	 * advised to wait only for the following duration before
 	 * doing SRST.
 	 */
-	ATA_TMOUT_PMP_SRST_WAIT	= 1 * HZ,
+	ATA_TMOUT_PMP_SRST_WAIT	= 1000,
 
 	/* ATA bus states */
 	BUS_UNKNOWN		= 0,
@@ -895,8 +896,7 @@ extern void ata_host_resume(struct ata_host *host);
 #endif
 extern int ata_ratelimit(void);
 extern u32 ata_wait_register(void __iomem *reg, u32 mask, u32 val,
-			     unsigned long interval_msec,
-			     unsigned long timeout_msec);
+			     unsigned long interval, unsigned long timeout);
 extern int atapi_cmd_type(u8 opcode);
 extern void ata_tf_to_fis(const struct ata_taskfile *tf,
 			  u8 pmp, int is_cmd, u8 *fis);
@@ -1389,6 +1389,12 @@ static inline int ata_check_ready(u8 status)
 	return 0;
 }
 
+static inline unsigned long ata_deadline(unsigned long from_jiffies,
+					 unsigned long timeout_msecs)
+{
+	return from_jiffies + msecs_to_jiffies(timeout_msecs);
+}
+
 
 /**************************************************************************
  * PMP - drivers/ata/libata-pmp.c

commit a57c1bade5a0ee5cd8b74502db9cbebb7f5780b2
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Thu May 29 22:10:58 2008 +0100

    libata-sff: Fix oops reported in kerneloops.org for pnp devices with no ctl
    
    - Make ata_sff_altstatus private so nobody uses it by mistake
    - Drop the 400nS delay from it
    
    Add
    
    ata_sff_irq_status      -       encapsulates the IRQ check logic
    
    This function keeps the existing behaviour for altstatus using devices. I
    actually suspect the logic was wrong before the changes but -rc isn't the
    time to play with that
    
    ata_sff_sync            -       ensure writes hit the device
    
    Really we want an io* operation for 'is posted' eg ioisposted(ioaddr) so
    that we can fix the nasty delay this causes on most systems.
    
    - ata_sff_pause         -       400nS delay
    
    Ensure the command hit the device and delay 400nS
    
    - ata_sff_dma_pause
    
    Ensure the I/O hit the device and enforce an HDMA1:0 transition delay.
    Requires altstatus register exists, BUG if not so we don't risk
    corruption in MWDMA modes. (UDMA the checksum will save your backside in
    theory)
    
    The only other complication then is devices with their own handlers.
    rb532 can use dma_pause but scc needs to access its own altstatus
    register for internal errata workarounds so directly call the drivers own
    altstatus function.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 93e2b89d0c57..e57e5d08312d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1432,7 +1432,8 @@ extern void ata_sff_qc_prep(struct ata_queued_cmd *qc);
 extern void ata_sff_dumb_qc_prep(struct ata_queued_cmd *qc);
 extern void ata_sff_dev_select(struct ata_port *ap, unsigned int device);
 extern u8 ata_sff_check_status(struct ata_port *ap);
-extern u8 ata_sff_altstatus(struct ata_port *ap);
+extern void ata_sff_pause(struct ata_port *ap);
+extern void ata_sff_dma_pause(struct ata_port *ap);
 extern int ata_sff_busy_sleep(struct ata_port *ap,
 			      unsigned long timeout_pat, unsigned long timeout);
 extern int ata_sff_wait_ready(struct ata_link *link, unsigned long deadline);
@@ -1492,19 +1493,6 @@ extern int ata_pci_sff_init_one(struct pci_dev *pdev,
 				struct scsi_host_template *sht, void *host_priv);
 #endif /* CONFIG_PCI */
 
-/**
- *	ata_sff_pause - Flush writes and pause 400 nanoseconds.
- *	@ap: Port to wait for.
- *
- *	LOCKING:
- *	Inherited from caller.
- */
-static inline void ata_sff_pause(struct ata_port *ap)
-{
-	ata_sff_altstatus(ap);
-	ndelay(400);
-}
-
 /**
  *	ata_sff_busy_wait - Wait for a port status register
  *	@ap: Port to wait for.

commit 4f0ebe3cc57f18ba26317b56b80b108c2848b1de
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue May 20 02:17:50 2008 +0900

    libata: kill unused constants
    
    Kill a few unused constants.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 4a92fbafce9d..93e2b89d0c57 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -111,13 +111,10 @@ enum {
 	/* various global constants */
 	LIBATA_MAX_PRD		= ATA_MAX_PRD / 2,
 	LIBATA_DUMB_MAX_PRD	= ATA_MAX_PRD / 4,	/* Worst case */
-	ATA_MAX_PORTS		= 8,
 	ATA_DEF_QUEUE		= 1,
 	/* tag ATA_MAX_QUEUE - 1 is reserved for internal commands */
 	ATA_MAX_QUEUE		= 32,
 	ATA_TAG_INTERNAL	= ATA_MAX_QUEUE - 1,
-	ATA_MAX_BUS		= 2,
-	ATA_DEF_BUSY_WAIT	= 10000,
 	ATA_SHORT_PAUSE		= (HZ >> 6) + 1,
 
 	ATAPI_MAX_DRAIN		= 16 << 10,

commit 50af2fa1e18d0ab411d06bf727ecadb7e01721e9
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 19 01:15:14 2008 +0900

    libata: ignore SIMG4726 config pseudo device
    
    I was hoping ATA_HORKAGE_NODMA | ATA_HORKAGE_SKIP_PM could keep it
    happy but no even this doesn't work under certain configurations and
    it's not like we can do anything useful with the cofig device anyway.
    Replace ATA_HORKAGE_SKIP_PM with ATA_HORKAGE_DISABLE and use it for
    the config device.  This makes the device completely ignored by
    libata.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 8d6999da1d3e..4a92fbafce9d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -351,7 +351,7 @@ enum {
 	ATA_HORKAGE_NONCQ	= (1 << 2),	/* Don't use NCQ */
 	ATA_HORKAGE_MAX_SEC_128	= (1 << 3),	/* Limit max sects to 128 */
 	ATA_HORKAGE_BROKEN_HPA	= (1 << 4),	/* Broken HPA */
-	ATA_HORKAGE_SKIP_PM	= (1 << 5),	/* Skip PM operations */
+	ATA_HORKAGE_DISABLE	= (1 << 5),	/* Disable it */
 	ATA_HORKAGE_HPA_SIZE	= (1 << 6),	/* native size off by one */
 	ATA_HORKAGE_IPM		= (1 << 7),	/* Link PM problems */
 	ATA_HORKAGE_IVB		= (1 << 8),	/* cbl det validity bit bugs */

commit bf1bff6fa9fdd4e92e57d80a5434fd5201c051fc
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 19 01:15:10 2008 +0900

    libata: increase PMP register access timeout to 3s
    
    This timeout was set low because previously PMP register access was
    done via polling and register access timeouts could stack up.  This is
    no longer the case.  One timeout will make all following accesses fail
    immediately.
    
    In rare cases both marvell and SIMG PMPs need almost a second.  Bump
    it to 3s.
    
    While at it, rename it to SATA_PMP_RW_TIMEOUT.  It's not specific to
    SCR access.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 07ec193fc941..8d6999da1d3e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -341,7 +341,7 @@ enum {
 	ATA_EH_PMP_TRIES	= 5,
 	ATA_EH_PMP_LINK_TRIES	= 3,
 
-	SATA_PMP_SCR_TIMEOUT	= 250,
+	SATA_PMP_RW_TIMEOUT	= 3000,		/* PMP read/write timeout */
 
 	/* Horkage types. May be set by libata or controller on drives
 	   (some horkage may be drive/controller pair dependant */

commit 07633b5d0723ce2ec31262e1096dcf61311bf078
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Wed May 14 16:17:00 2008 -0700

    ata: remove FIT() macro
    
    Use the kernel-provided clamp_val() macro.
    
    FIT was always applied to a member of struct ata_timing (unsigned short)
    and two constants.  clamp_val will not cast to short anymore.
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 0f17643e0a6e..07ec193fc941 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -821,8 +821,6 @@ struct ata_timing {
 	unsigned short udma;		/* t2CYCTYP/2 */
 };
 
-#define FIT(v, vmin, vmax)	max_t(short, min_t(short, v, vmax), vmin)
-
 /*
  * Core layer - drivers/ata/libata-core.c
  */

commit 005b1f7495e812b99b73de5adbc73afd7a1cbcaf
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri May 9 15:00:55 2008 -0400

    [libata] revert new check-ready Status register logic
    
    This behavior differs across multiple controllers, so we cannot use
    common logic for all controllers.
    
    Revert back to the basic common behavior, and specific drivers will
    be updated from here to take into account the unusual Status return
    values.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 7e206da1fbfb..0f17643e0a6e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1384,17 +1384,14 @@ static inline struct ata_port *ata_shost_to_port(struct Scsi_Host *host)
 
 static inline int ata_check_ready(u8 status)
 {
-	/* Some controllers report 0x77 or 0x7f during intermediate
-	 * not-ready stages.
-	 */
-	if (status == 0x77 || status == 0x7f)
-		return 0;
+	if (!(status & ATA_BUSY))
+		return 1;
 
 	/* 0xff indicates either no device or device not ready */
 	if (status == 0xff)
 		return -ENODEV;
 
-	return !(status & ATA_BUSY);
+	return 0;
 }
 
 

commit 10acf3b0d3b46c6ef5d6f0722f72ad9b743ea848
Author: Mark Lord <liml@rtr.ca>
Date:   Fri May 2 02:14:53 2008 -0400

    libata: export ata_eh_analyze_ncq_error
    
    Export ata_eh_analyze_ncq_error() for subsequent use by sata_mv,
    as suggested by Tejun.
    
    Signed-off-by: Mark Lord <mlord@pobox.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 95e6159b44cf..7e206da1fbfb 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1039,6 +1039,7 @@ extern void ata_eh_thaw_port(struct ata_port *ap);
 
 extern void ata_eh_qc_complete(struct ata_queued_cmd *qc);
 extern void ata_eh_qc_retry(struct ata_queued_cmd *qc);
+extern void ata_eh_analyze_ncq_error(struct ata_link *link);
 
 extern void ata_do_eh(struct ata_port *ap, ata_prereset_fn_t prereset,
 		      ata_reset_fn_t softreset, ata_reset_fn_t hardreset,

commit 78ab88f04f44bed566d51dce0c7cbfeff6449a06
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu May 1 23:41:41 2008 +0900

    libata: improve post-reset device ready test
    
    Some controllers (jmb and inic162x) use 0x77 and 0x7f to indicate that
    the device isn't ready yet.  It looks like they use 0xff if device
    presence is detected but connection isn't established.  0x77 or 0x7f
    after connection is established and use the value from signature FIS
    after receiving it.
    
    This patch implements ata_check_ready(), which takes TF status value
    and determines whether the port is ready or not considering the above
    and other conditions, and use it in @check_ready() functions.  This is
    safe as both 0x77 and 0x7f aren't valid ready status value even though
    they have BSY bit cleared.
    
    This fixes hot plug detection failures which can be triggered with
    certain drives if they aren't already spun up when the data connector
    is hot plugged.
    
    Tested on sil, sil24, ahci (jmb/ich), piix and inic162x combined with
    eight drives from all major vendors.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d1dfe872ee30..95e6159b44cf 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1381,6 +1381,21 @@ static inline struct ata_port *ata_shost_to_port(struct Scsi_Host *host)
 	return *(struct ata_port **)&host->hostdata[0];
 }
 
+static inline int ata_check_ready(u8 status)
+{
+	/* Some controllers report 0x77 or 0x7f during intermediate
+	 * not-ready stages.
+	 */
+	if (status == 0x77 || status == 0x7f)
+		return 0;
+
+	/* 0xff indicates either no device or device not ready */
+	if (status == 0xff)
+		return -ENODEV;
+
+	return !(status & ATA_BUSY);
+}
+
 
 /**************************************************************************
  * PMP - drivers/ata/libata-pmp.c

commit f7e989301b6c232dec5489e94ee7741c85cb11ba
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Apr 29 17:47:34 2008 -0400

    [libata] linux/libata.h: reorganize ata_device struct members a bit
    
    Put the big stuff at the end, to prepare for upcoming changes (and
    also hopefully achieve nicer packing of remaining members).
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 395a523d8c30..d1dfe872ee30 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -548,11 +548,6 @@ struct ata_device {
 	u64			n_sectors;	/* size of device, if ATA */
 	unsigned int		class;		/* ATA_DEV_xxx */
 
-	union {
-		u16		id[ATA_ID_WORDS]; /* IDENTIFY xxx DEVICE data */
-		u32		gscr[SATA_PMP_GSCR_DWORDS]; /* PMP GSCR block */
-	};
-
 	u8			pio_mode;
 	u8			dma_mode;
 	u8			xfer_mode;
@@ -574,8 +569,13 @@ struct ata_device {
 	u16			sectors;	/* Number of sectors per track */
 
 	/* error history */
-	struct ata_ering	ering;
 	int			spdn_cnt;
+	struct ata_ering	ering;
+
+	union {
+		u16		id[ATA_ID_WORDS]; /* IDENTIFY xxx DEVICE data */
+		u32		gscr[SATA_PMP_GSCR_DWORDS]; /* PMP GSCR block */
+	};
 };
 
 /* Offset into struct ata_device.  Fields above it are maintained

commit 6bdb4fc9f9e5307012f6f2afb8642b52dad9c186
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon Apr 21 11:51:11 2008 +0300

    make sata_print_link_status() static
    
    sata_print_link_status() can now become static.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 07ed56f7a767..395a523d8c30 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -847,7 +847,6 @@ static inline int ata_port_is_dummy(struct ata_port *ap)
 	return ap->ops == &ata_dummy_port_ops;
 }
 
-extern void sata_print_link_status(struct ata_link *link);
 extern void ata_port_probe(struct ata_port *);
 extern int sata_set_spd(struct ata_link *link);
 extern int ata_std_prereset(struct ata_link *link, unsigned long deadline);

commit ee959b00c335d7780136c5abda37809191fe52c3
Author: Tony Jones <tonyj@suse.de>
Date:   Fri Feb 22 00:13:36 2008 +0100

    SCSI: convert struct class_device to struct device
    
    It's big, but there doesn't seem to be a way to split it up smaller...
    
    Signed-off-by: Tony Jones <tonyj@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Roland Dreier <rolandd@cisco.com>
    Cc: Sean Hefty <sean.hefty@intel.com>
    Cc: Hal Rosenstock <hal.rosenstock@gmail.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 165734a2dd47..07ed56f7a767 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -443,7 +443,7 @@ enum link_pm {
 	MAX_PERFORMANCE,
 	MEDIUM_POWER,
 };
-extern struct class_device_attribute class_device_attr_link_power_management_policy;
+extern struct device_attribute dev_attr_link_power_management_policy;
 
 #ifdef CONFIG_ATA_SFF
 struct ata_ioports {

commit 88fcd5627563722483427a55113c0a83f56e8080
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:22 2008 +0900

    libata: make PMP support optional
    
    Make PMP support optional by adding CONFIG_SATA_PMP and leaving out
    libata-pmp.c if it isn't set.  PMP helpers return constant values if
    PMP support is not enabled and PMP declarations alias non-PMP
    counterparts.  This makes the compiler to leave out PMP related part
    out and LLDs to use non-PMP counterparts automatically.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 1908bf484743..165734a2dd47 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1092,6 +1092,7 @@ extern const struct ata_port_operations sata_port_ops;
 /*
  * PMP helpers
  */
+#ifdef CONFIG_SATA_PMP
 static inline bool sata_pmp_supported(struct ata_port *ap)
 {
 	return ap->flags & ATA_FLAG_PMP;
@@ -1106,6 +1107,22 @@ static inline int ata_is_host_link(const struct ata_link *link)
 {
 	return link == &link->ap->link;
 }
+#else /* CONFIG_SATA_PMP */
+static inline bool sata_pmp_supported(struct ata_port *ap)
+{
+	return false;
+}
+
+static inline bool sata_pmp_attached(struct ata_port *ap)
+{
+	return false;
+}
+
+static inline int ata_is_host_link(const struct ata_link *link)
+{
+	return 1;
+}
+#endif /* CONFIG_SATA_PMP */
 
 static inline int sata_srst_pmp(struct ata_link *link)
 {
@@ -1369,11 +1386,21 @@ static inline struct ata_port *ata_shost_to_port(struct Scsi_Host *host)
 /**************************************************************************
  * PMP - drivers/ata/libata-pmp.c
  */
+#ifdef CONFIG_SATA_PMP
+
 extern const struct ata_port_operations sata_pmp_port_ops;
 
 extern int sata_pmp_qc_defer_cmd_switch(struct ata_queued_cmd *qc);
 extern void sata_pmp_error_handler(struct ata_port *ap);
 
+#else /* CONFIG_SATA_PMP */
+
+#define sata_pmp_port_ops		sata_port_ops
+#define sata_pmp_qc_defer_cmd_switch	ata_std_qc_defer
+#define sata_pmp_error_handler		ata_std_error_handler
+
+#endif /* CONFIG_SATA_PMP */
+
 
 /**************************************************************************
  * SFF - drivers/ata/libata-sff.c

commit 071f44b1d2c051641b62a3571223314737ccbe59
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:22 2008 +0900

    libata: implement PMP helpers
    
    Implement helpers to test whether PMP is supported, attached and
    determine pmp number to use when issuing SRST to a link.  While at it,
    move ata_is_host_link() so that it's together with the two new PMP
    helpers.
    
    This change simplifies LLDs and helps making PMP support optional.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index eb86d6f39635..1908bf484743 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1089,6 +1089,31 @@ extern const struct ata_port_operations sata_port_ops;
 	ATA_BASE_SHT(drv_name),					\
 	.change_queue_depth	= ata_scsi_change_queue_depth
 
+/*
+ * PMP helpers
+ */
+static inline bool sata_pmp_supported(struct ata_port *ap)
+{
+	return ap->flags & ATA_FLAG_PMP;
+}
+
+static inline bool sata_pmp_attached(struct ata_port *ap)
+{
+	return ap->nr_pmp_links != 0;
+}
+
+static inline int ata_is_host_link(const struct ata_link *link)
+{
+	return link == &link->ap->link;
+}
+
+static inline int sata_srst_pmp(struct ata_link *link)
+{
+	if (sata_pmp_supported(link->ap) && ata_is_host_link(link))
+		return SATA_PMP_CTRL_PORT;
+	return link->pmp;
+}
+
 /*
  * printk helpers
  */
@@ -1096,7 +1121,7 @@ extern const struct ata_port_operations sata_port_ops;
 	printk("%sata%u: "fmt, lv, (ap)->print_id , ##args)
 
 #define ata_link_printk(link, lv, fmt, args...) do { \
-	if ((link)->ap->nr_pmp_links) \
+	if (sata_pmp_attached((link)->ap)) \
 		printk("%sata%u.%02u: "fmt, lv, (link)->ap->print_id,	\
 		       (link)->pmp , ##args); \
 	else \
@@ -1182,11 +1207,6 @@ static inline unsigned int ata_dev_absent(const struct ata_device *dev)
 /*
  * link helpers
  */
-static inline int ata_is_host_link(const struct ata_link *link)
-{
-	return link == &link->ap->link;
-}
-
 static inline int ata_link_max_devices(const struct ata_link *link)
 {
 	if (ata_is_host_link(link) && link->ap->flags & ATA_FLAG_SLAVE_POSS)
@@ -1201,7 +1221,7 @@ static inline int ata_link_active(struct ata_link *link)
 
 static inline struct ata_link *ata_port_first_link(struct ata_port *ap)
 {
-	if (ap->nr_pmp_links)
+	if (sata_pmp_attached(ap))
 		return ap->pmp_link;
 	return &ap->link;
 }
@@ -1210,8 +1230,8 @@ static inline struct ata_link *ata_port_next_link(struct ata_link *link)
 {
 	struct ata_port *ap = link->ap;
 
-	if (link == &ap->link) {
-		if (!ap->nr_pmp_links)
+	if (ata_is_host_link(link)) {
+		if (!sata_pmp_attached(ap))
 			return NULL;
 		return ap->pmp_link;
 	}

commit 48515f6c006c2a9d7b624ee8ad068018c2d3fe0e
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:21 2008 +0900

    libata: separate PMP support code from core code
    
    Most of PMP support code is already in libata-pmp.c.  All that are in
    libata-core.c are sata_pmp_port_ops and EXPORTs.  Move them to
    libata-pmp.c.  Also, collect PMP related prototypes and declarations
    in header files and move them right above of SFF stuff.
    
    This change is to make PMP support optional.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index db77b90003fd..eb86d6f39635 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1026,12 +1026,6 @@ static inline int ata_acpi_cbl_80wire(struct ata_port *ap,
 }
 #endif
 
-/*
- * PMP - drivers/ata/libata-pmp.c
- */
-extern int sata_pmp_qc_defer_cmd_switch(struct ata_queued_cmd *qc);
-extern void sata_pmp_error_handler(struct ata_port *ap);
-
 /*
  * EH - drivers/ata/libata-eh.c
  */
@@ -1075,7 +1069,6 @@ extern void ata_std_error_handler(struct ata_port *ap);
  */
 extern const struct ata_port_operations ata_base_port_ops;
 extern const struct ata_port_operations sata_port_ops;
-extern const struct ata_port_operations sata_pmp_port_ops;
 
 #define ATA_BASE_SHT(drv_name)					\
 	.module			= THIS_MODULE,			\
@@ -1352,6 +1345,16 @@ static inline struct ata_port *ata_shost_to_port(struct Scsi_Host *host)
 	return *(struct ata_port **)&host->hostdata[0];
 }
 
+
+/**************************************************************************
+ * PMP - drivers/ata/libata-pmp.c
+ */
+extern const struct ata_port_operations sata_pmp_port_ops;
+
+extern int sata_pmp_qc_defer_cmd_switch(struct ata_queued_cmd *qc);
+extern void sata_pmp_error_handler(struct ata_port *ap);
+
+
 /**************************************************************************
  * SFF - drivers/ata/libata-sff.c
  */

commit 127102aea2ea9ec4e9ca233e2b1a75c8d3b058c4
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:21 2008 +0900

    libata: make SFF support optional
    
    Now that SFF support is completely separated out from the core layer,
    it can be made optional.  Add CONFIG_ATA_SFF and let SFF drivers
    depend on it.  If CONFIG_ATA_SFF isn't set, all codes in libata-sff.c
    and data structures for SFF support are disabled.  This saves good
    number of bytes for small systems.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 037db1883bae..db77b90003fd 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -445,6 +445,7 @@ enum link_pm {
 };
 extern struct class_device_attribute class_device_attr_link_power_management_policy;
 
+#ifdef CONFIG_ATA_SFF
 struct ata_ioports {
 	void __iomem		*cmd_addr;
 	void __iomem		*data_addr;
@@ -462,6 +463,7 @@ struct ata_ioports {
 	void __iomem		*bmdma_addr;
 	void __iomem		*scr_addr;
 };
+#endif /* CONFIG_ATA_SFF */
 
 struct ata_host {
 	spinlock_t		lock;
@@ -648,7 +650,9 @@ struct ata_port {
 	struct ata_prd		*prd;	 /* our SG list */
 	dma_addr_t		prd_dma; /* and its DMA mapping */
 
+#ifdef CONFIG_ATA_SFF
 	struct ata_ioports	ioaddr;	/* ATA cmd/ctl/dma register blocks */
+#endif /* CONFIG_ATA_SFF */
 
 	u8			ctl;	/* cache of ATA control register */
 	u8			last_ctl;	/* Cache last written value */
@@ -760,6 +764,7 @@ struct ata_port_operations {
 	void (*port_stop)(struct ata_port *ap);
 	void (*host_stop)(struct ata_host *host);
 
+#ifdef CONFIG_ATA_SFF
 	/*
 	 * SFF / taskfile oriented ops
 	 */
@@ -779,6 +784,7 @@ struct ata_port_operations {
 	void (*bmdma_start)(struct ata_queued_cmd *qc);
 	void (*bmdma_stop)(struct ata_queued_cmd *qc);
 	u8   (*bmdma_status)(struct ata_port *ap);
+#endif /* CONFIG_ATA_SFF */
 
 	/*
 	 * Obsolete
@@ -1349,6 +1355,8 @@ static inline struct ata_port *ata_shost_to_port(struct Scsi_Host *host)
 /**************************************************************************
  * SFF - drivers/ata/libata-sff.c
  */
+#ifdef CONFIG_ATA_SFF
+
 extern const struct ata_port_operations ata_sff_port_ops;
 extern const struct ata_port_operations ata_bmdma_port_ops;
 
@@ -1489,5 +1497,6 @@ static inline u8 ata_wait_idle(struct ata_port *ap)
 
 	return status;
 }
+#endif /* CONFIG_ATA_SFF */
 
 #endif /* __LINUX_LIBATA_H__ */

commit c9f75b04ed5ed65a058d18a8a8dda50632a96de8
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:21 2008 +0900

    libata: kill ata_noop_dev_select()
    
    Now that SFF assumptions are separated out from non-SFF reset
    sequence, port_ops->sff_dev_select() is no longer necessary for
    non-SFF controllers.  Kill ata_noop_dev_select() and ->sff_dev_select
    initialization from base and other non-SFF port_ops.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 1d8b6b7de0a2..037db1883bae 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -911,7 +911,6 @@ extern unsigned long ata_xfer_mode2mask(u8 xfer_mode);
 extern int ata_xfer_mode2shift(unsigned long xfer_mode);
 extern const char *ata_mode_string(unsigned long xfer_mask);
 extern unsigned long ata_id_xfermask(const u16 *id);
-extern void ata_noop_dev_select(struct ata_port *ap, unsigned int device);
 extern int ata_port_start(struct ata_port *ap);
 extern int ata_std_qc_defer(struct ata_queued_cmd *qc);
 extern void ata_noop_qc_prep(struct ata_queued_cmd *qc);

commit 79f97dadfe9b4b561634d202225ba2fa910dc225
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:20 2008 +0900

    libata: drop @finish_qc from ata_qc_complete_multiple()
    
    ata_qc_complete_multiple() took @finish_qc and called it on every qc
    before completing it.  This was to give opportunity to update TF cache
    before ata_qc_complete() tries to fill result_tf.  Now that result TF
    is a separate operation, this is no longer necessary.
    
    Update sata_sil24, which was the only user of this mechanism, such
    that it implements its own ops->qc_fill_rtf() and drop @finish_qc from
    ata_qc_complete_multiple().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index bb4200d42f0d..1d8b6b7de0a2 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -924,8 +924,7 @@ extern void ata_id_string(const u16 *id, unsigned char *s,
 extern void ata_id_c_string(const u16 *id, unsigned char *s,
 			    unsigned int ofs, unsigned int len);
 extern void ata_qc_complete(struct ata_queued_cmd *qc);
-extern int ata_qc_complete_multiple(struct ata_port *ap, u32 qc_active,
-				    void (*finish_qc)(struct ata_queued_cmd *));
+extern int ata_qc_complete_multiple(struct ata_port *ap, u32 qc_active);
 extern void ata_scsi_simulate(struct ata_device *dev, struct scsi_cmnd *cmd,
 			      void (*done)(struct scsi_cmnd *));
 extern int ata_std_bios_param(struct scsi_device *sdev,

commit 22183bf569c8600ff414ac25f23134044e0ef453
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:20 2008 +0900

    libata: add qc_fill_rtf port operation
    
    On command completion, ata_qc_complete() directly called ops->tf_read
    to fill qc->result_tf.  This patch adds ops->qc_fill_rtf to replace
    hardcoded ops->tf_read usage.
    
    ata_sff_qc_fill_rtf() which uses ops->tf_read to fill result_tf is
    implemented and set in ata_base_port_ops and other ops tables which
    don't inherit from ata_base_port_ops, so this patch doesn't introduce
    any behavior change.
    
    ops->qc_fill_rtf() is similar to ops->sff_tf_read() but can only be
    called when a command finishes.  As some non-SFF controllers don't
    have TF registers defined unless they're associated with in-flight
    commands, this limited operation makes life easier for those drivers
    and help lifting SFF assumptions from libata core layer.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 2b5a0b77e179..bb4200d42f0d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -715,6 +715,7 @@ struct ata_port_operations {
 	int  (*check_atapi_dma)(struct ata_queued_cmd *qc);
 	void (*qc_prep)(struct ata_queued_cmd *qc);
 	unsigned int (*qc_issue)(struct ata_queued_cmd *qc);
+	bool (*qc_fill_rtf)(struct ata_queued_cmd *qc);
 
 	/*
 	 * Configuration and exception handling
@@ -1385,6 +1386,7 @@ extern void ata_sff_irq_clear(struct ata_port *ap);
 extern int ata_sff_hsm_move(struct ata_port *ap, struct ata_queued_cmd *qc,
 			    u8 status, int in_wq);
 extern unsigned int ata_sff_qc_issue(struct ata_queued_cmd *qc);
+extern bool ata_sff_qc_fill_rtf(struct ata_queued_cmd *qc);
 extern unsigned int ata_sff_host_intr(struct ata_port *ap,
 				      struct ata_queued_cmd *qc);
 extern irqreturn_t ata_sff_interrupt(int irq, void *dev_instance);

commit 5958e3025fd9d97429163e074d9cfa3848f51f28
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:20 2008 +0900

    libata: move PMP SCR access failure during reset to ata_eh_reset()
    
    If PMP fan-out reset fails and SCR isn't accessible, PMP should be
    reset.  This used to be tested by sata_pmp_std_hardreset() and
    communicated to EH by -ERESTART.  However, this logic is generic and
    doesn't really have much to do with specific hardreset implementation.
    
    This patch moves SCR access failure detection logic to ata_eh_reset()
    where it belongs.  As this makes sata_pmp_std_hardreset() identical to
    sata_std_hardreset(), the function is killed and replaced with the
    standard method.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b9188371b12a..2b5a0b77e179 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1025,8 +1025,6 @@ static inline int ata_acpi_cbl_80wire(struct ata_port *ap,
  * PMP - drivers/ata/libata-pmp.c
  */
 extern int sata_pmp_qc_defer_cmd_switch(struct ata_queued_cmd *qc);
-extern int sata_pmp_std_hardreset(struct ata_link *link, unsigned int *class,
-				  unsigned long deadline);
 extern void sata_pmp_error_handler(struct ata_port *ap);
 
 /*

commit ac371987a81c61c2efbd6931245cdcaf43baad89
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:19 2008 +0900

    libata: clear SError after link resume
    
    SError used to be cleared in ->postreset.  This has small hotplug race
    condition.  If a device is plugged in after reset is complete but
    postreset hasn't run yet, its hotplug event gets lost when SError is
    cleared.  This patch makes sata_link_resume() clear SError.  This
    kills the race condition and makes a lot of sense as some PMP and host
    PHYs don't work properly without SError cleared.
    
    This change makes sata_pmp_std_{pre|post}_reset()'s unnecessary as
    they become identical to ata_std counterparts.  It also simplifies
    sata_pmp_hardreset() and ahci_vt8251_hardreset().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c060cd3cba66..b9188371b12a 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1025,10 +1025,8 @@ static inline int ata_acpi_cbl_80wire(struct ata_port *ap,
  * PMP - drivers/ata/libata-pmp.c
  */
 extern int sata_pmp_qc_defer_cmd_switch(struct ata_queued_cmd *qc);
-extern int sata_pmp_std_prereset(struct ata_link *link, unsigned long deadline);
 extern int sata_pmp_std_hardreset(struct ata_link *link, unsigned int *class,
 				  unsigned long deadline);
-extern void sata_pmp_std_postreset(struct ata_link *link, unsigned int *class);
 extern void sata_pmp_error_handler(struct ata_port *ap);
 
 /*

commit 57c9efdfb3cee5d4564fcb5f70555e2edb1bc52a
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:19 2008 +0900

    libata: implement and use sata_std_hardreset()
    
    Implement sata_std_hardreset(), which simply wraps around
    sata_link_hardreset().  sata_std_hardreset() becomes new standard
    hardreset method for sata_port_ops and sata_sff_hardreset() moves from
    ata_base_port_ops to ata_sff_port_ops, which is where it really
    belongs.
    
    ata_is_builtin_hardreset() is added so that both
    ata_std_error_handler() and ata_sff_error_handler() skip both builtin
    hardresets if SCR isn't accessible.
    
    piix_sidpr_hardreset() in ata_piix.c is identical to
    sata_std_hardreset() in functionality and got replaced with the
    standard function.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d9ebce2bf5e7..c060cd3cba66 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -853,6 +853,8 @@ extern int sata_link_resume(struct ata_link *link, const unsigned long *params,
 extern int sata_link_hardreset(struct ata_link *link,
 			const unsigned long *timing, unsigned long deadline,
 			bool *online, int (*check_ready)(struct ata_link *));
+extern int sata_std_hardreset(struct ata_link *link, unsigned int *class,
+			      unsigned long deadline);
 extern void ata_std_postreset(struct ata_link *link, unsigned int *classes);
 extern void ata_port_disable(struct ata_port *);
 

commit 9dadd45b24145d6aee2fabb28d7aef972301892b
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:19 2008 +0900

    libata: move generic hardreset code from sata_sff_hardreset() to sata_link_hardreset()
    
    sata_sff_hardreset() contains link readiness wait logic which isn't
    SFF specific.  Move that part into sata_link_hardreset(), which now
    takes two more parameters - @online and @check_ready.  Both are
    optional.  The former is out parameter for link onlineness after
    reset.  The latter is used to wait for link readiness after hardreset.
    
    Users of sata_link_hardreset() is updated to use new funtionality and
    ahci_hardreset() is updated to use sata_link_hardreset() instead of
    sata_sff_hardreset().  This doesn't really cause any behavior change.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 4bbf2524e473..d9ebce2bf5e7 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -261,6 +261,13 @@ enum {
 	 */
 	ATA_WAIT_AFTER_RESET_MSECS = 150,
 
+	/* If PMP is supported, we have to do follow-up SRST.  As some
+	 * PMPs don't send D2H Reg FIS after hardreset, LLDs are
+	 * advised to wait only for the following duration before
+	 * doing SRST.
+	 */
+	ATA_TMOUT_PMP_SRST_WAIT	= 1 * HZ,
+
 	/* ATA bus states */
 	BUS_UNKNOWN		= 0,
 	BUS_DMA			= 1,
@@ -844,7 +851,8 @@ extern int sata_link_debounce(struct ata_link *link,
 extern int sata_link_resume(struct ata_link *link, const unsigned long *params,
 			    unsigned long deadline);
 extern int sata_link_hardreset(struct ata_link *link,
-			const unsigned long *timing, unsigned long deadline);
+			const unsigned long *timing, unsigned long deadline,
+			bool *online, int (*check_ready)(struct ata_link *));
 extern void ata_std_postreset(struct ata_link *link, unsigned int *classes);
 extern void ata_port_disable(struct ata_port *);
 

commit aa2731ad9ad80ac3fca48bd1c4cf0eceede4810e
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:19 2008 +0900

    libata: separate out ata_wait_ready() and implement ata_wait_after_reset()
    
    Factor out waiting logic (which is common to all ATA controllers) from
    ata_sff_wait_ready() into ata_wait_ready().  ata_wait_ready() takes
    @check_ready function pointer and uses it to poll for readiness.  This
    allows non-SFF controllers to use ata_wait_ready() to wait for link
    readiness.
    
    This patch also implements ata_wait_after_reset() - generic version of
    ata_sff_wait_after_reset() - using ata_wait_ready().
    
    ata_sff_wait_ready() is reimplemented using ata_wait_ready() and
    ata_sff_check_ready().  Functionality remains the same.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index da5560244787..4bbf2524e473 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -837,6 +837,8 @@ extern void sata_print_link_status(struct ata_link *link);
 extern void ata_port_probe(struct ata_port *);
 extern int sata_set_spd(struct ata_link *link);
 extern int ata_std_prereset(struct ata_link *link, unsigned long deadline);
+extern int ata_wait_after_reset(struct ata_link *link, unsigned long deadline,
+				int (*check_ready)(struct ata_link *link));
 extern int sata_link_debounce(struct ata_link *link,
 			const unsigned long *params, unsigned long deadline);
 extern int sata_link_resume(struct ata_link *link, const unsigned long *params,

commit 705e76beb90b97421e1f61e857c4246799781bb5
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:19 2008 +0900

    libata: restructure SFF post-reset readiness waits
    
    Previously, post-softreset readiness is waited as follows.
    
    1. ata_sff_wait_after_reset() waits for 150ms and then for
       ATA_TMOUT_FF_WAIT if status is 0xff and other conditions meet.
    
    2. ata_bus_softreset() finishes with -ENODEV if status is still 0xff.
       If not, continue to #3.
    
    3. ata_bus_post_reset() waits readiness of dev0 and/or dev1 depending
       on devmask using ata_sff_wait_ready().
    
    And for post-hardreset readiness,
    
    1. ata_sff_wait_after_reset() waits for 150ms and then for
       ATA_TMOUT_FF_WAIT if status is 0xff and other conditions meet.
    
    2. sata_sff_hardreset waits for device readiness using
       ata_sff_wait_ready().
    
    This patch merges and unifies post-reset readiness waits into
    ata_sff_wait_ready() and ata_sff_wait_after_reset().
    
    ATA_TMOUT_FF_WAIT handling is merged into ata_sff_wait_ready().  If TF
    status is 0xff, link status is unknown and the port is SATA, it will
    continue polling till ATA_TMOUT_FF_WAIT.
    
    ata_sff_wait_after_reset() is updated to perform the following steps.
    
    1. waits for 150ms.
    
    2. waits for dev0 readiness using ata_sff_wait_ready().  Note that
       this is done regardless of devmask, as ata_sff_wait_ready() handles
       0xff status correctly, this preserves the original behavior except
       that it may wait longer after softreset if link is online but
       status is 0xff.  This behavior change is very unlikely to cause any
       actual difference and is intended.  It brings softreset behavior to
       that of hardreset.
    
    3. waits for dev1 readiness just the same way ata_bus_post_reset() did.
    
    Now both soft and hard resets call ata_sff_wait_after_reset() after
    reset to wait for readiness after resets.  As
    ata_sff_wait_after_reset() contains calls to ->sff_dev_select(),
    explicit call near the end of sata_sff_hardreset() is removed.
    
    This change makes reset implementation simpler and more consistent.
    
    While at it, make the magical 150ms wait post-reset wait duration a
    constant and ata_sff_wait_ready() and ata_sff_wait_after_reset() take
    @link instead of @ap.  This is to make them consistent with other
    reset helpers and ease core changes.
    
    pata_scc is updated accordingly.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6e14c27319d5..da5560244787 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -249,6 +249,18 @@ enum {
 	 */
 	ATA_TMOUT_FF_WAIT	= 4 * HZ / 5,
 
+	/* Spec mandates to wait for ">= 2ms" before checking status
+	 * after reset.  We wait 150ms, because that was the magic
+	 * delay used for ATAPI devices in Hale Landis's ATADRVR, for
+	 * the period of time between when the ATA command register is
+	 * written, and then status is checked.  Because waiting for
+	 * "a while" before checking status is fine, post SRST, we
+	 * perform this magic delay here as well.
+	 *
+	 * Old drivers/ide uses the 2mS rule and then waits for ready.
+	 */
+	ATA_WAIT_AFTER_RESET_MSECS = 150,
+
 	/* ATA bus states */
 	BUS_UNKNOWN		= 0,
 	BUS_DMA			= 1,
@@ -1351,7 +1363,7 @@ extern u8 ata_sff_check_status(struct ata_port *ap);
 extern u8 ata_sff_altstatus(struct ata_port *ap);
 extern int ata_sff_busy_sleep(struct ata_port *ap,
 			      unsigned long timeout_pat, unsigned long timeout);
-extern int ata_sff_wait_ready(struct ata_port *ap, unsigned long deadline);
+extern int ata_sff_wait_ready(struct ata_link *link, unsigned long deadline);
 extern void ata_sff_tf_load(struct ata_port *ap, const struct ata_taskfile *tf);
 extern void ata_sff_tf_read(struct ata_port *ap, struct ata_taskfile *tf);
 extern void ata_sff_exec_command(struct ata_port *ap,
@@ -1373,8 +1385,8 @@ extern void ata_sff_thaw(struct ata_port *ap);
 extern int ata_sff_prereset(struct ata_link *link, unsigned long deadline);
 extern unsigned int ata_sff_dev_classify(struct ata_device *dev, int present,
 					  u8 *r_err);
-extern void ata_sff_wait_after_reset(struct ata_port *ap,
-				     unsigned long deadline);
+extern int ata_sff_wait_after_reset(struct ata_link *link, unsigned int devmask,
+				    unsigned long deadline);
 extern int ata_sff_softreset(struct ata_link *link, unsigned int *classes,
 			     unsigned long deadline);
 extern int sata_sff_hardreset(struct ata_link *link, unsigned int *class,

commit 203c75b8245c5386044721d9c5eda5c6b71b3d14
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:18 2008 +0900

    libata: separate out ata_std_postreset() from ata_sff_postreset()
    
    Separate out generic ATA portion from ata_sff_postreset() into
    ata_std_postreset() and implement ata_sff_postreset() using the std
    version.
    
    ata_base_port_ops now has ata_std_postreset() for its postreset and
    ata_sff_port_ops overrides it to ata_sff_postreset().
    
    This change affects pdc_adma, ahci, sata_fsl and sata_sil24.  pdc_adma
    now specifies postreset to ata_sff_postreset() explicitly.  sata_fsl
    and sata_sil24 now use ata_std_postreset() which makes no difference
    to them.  ahci now calls ata_std_postreset() from its own postreset
    method, which causes no behavior difference.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 595ede55fe4c..6e14c27319d5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -831,6 +831,7 @@ extern int sata_link_resume(struct ata_link *link, const unsigned long *params,
 			    unsigned long deadline);
 extern int sata_link_hardreset(struct ata_link *link,
 			const unsigned long *timing, unsigned long deadline);
+extern void ata_std_postreset(struct ata_link *link, unsigned int *classes);
 extern void ata_port_disable(struct ata_port *);
 
 extern struct ata_host *ata_host_alloc(struct device *dev, int max_ports);

commit 0aa1113d544226bc2c4a20d6ac1d71170512a361
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:18 2008 +0900

    libata: separate out ata_std_prereset() from ata_sff_prereset()
    
    Separate out generic ATA portion from ata_sff_prereset() into
    ata_std_prereset() and implement ata_sff_prereset() using the std
    version.  Waiting for device readiness is the only SFF specific part.
    
    ata_base_port_ops now has ata_std_prereset() for its prereset and
    ata_sff_port_ops overrides it to ata_sff_prereset().  This change can
    affect pdc_adma, ahci, sata_fsl and sata_sil24.  pdc_adma implements
    its own prereset using ata_sff_prereset() and the rest has hardreset
    and thus are unaffected by this change.
    
    This change reflects real world situation.  There is no generic way to
    wait for device readiness for non-SFF controllers and some of them
    don't have any mechanism for that.  Non-sff drivers which don't have
    hardreset should wrap ata_std_prereset() and wait for device readiness
    itself but there's no such driver now and isn't likely to be popular
    in the future either.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 603712b59cf3..595ede55fe4c 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -824,6 +824,7 @@ static inline int ata_port_is_dummy(struct ata_port *ap)
 extern void sata_print_link_status(struct ata_link *link);
 extern void ata_port_probe(struct ata_port *);
 extern int sata_set_spd(struct ata_link *link);
+extern int ata_std_prereset(struct ata_link *link, unsigned long deadline);
 extern int sata_link_debounce(struct ata_link *link,
 			const unsigned long *params, unsigned long deadline);
 extern int sata_link_resume(struct ata_link *link, const unsigned long *params,

commit 288623a06c652239d2f57d271af12bb024cf7218
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:17 2008 +0900

    libata: clean up port_ops->sff_irq_clear()
    
    ->sff_irq_clear() is called only from SFF interrupt handler, so there
    is no reason to initialize it for non-SFF controllers.  Also,
    ata_sff_irq_clear() can handle both BMDMA and non-BMDMA SFF
    controllers.
    
    This patch kills ata_noop_irq_clear() and removes it from base
    port_ops and sets ->sff_irq_clear to ata_sff_irq_clear() in sff
    port_ops instead of bmdma port_ops.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 584eca19b8f1..603712b59cf3 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -896,7 +896,6 @@ extern void ata_id_string(const u16 *id, unsigned char *s,
 			  unsigned int ofs, unsigned int len);
 extern void ata_id_c_string(const u16 *id, unsigned char *s,
 			    unsigned int ofs, unsigned int len);
-extern void ata_noop_irq_clear(struct ata_port *ap);
 extern void ata_qc_complete(struct ata_queued_cmd *qc);
 extern int ata_qc_complete_multiple(struct ata_port *ap, u32 qc_active,
 				    void (*finish_qc)(struct ata_queued_cmd *));

commit 5682ed33aae05d10a25c95633ef9d9c062825888
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:16 2008 +0900

    libata: rename SFF port ops
    
    Add sff_ prefix to SFF specific port ops.
    
    This rename is in preparation of separating SFF support out of libata
    core layer.  This patch strictly renames ops and doesn't introduce any
    behavior difference.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 66663bfe2c71..584eca19b8f1 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -743,17 +743,18 @@ struct ata_port_operations {
 	/*
 	 * SFF / taskfile oriented ops
 	 */
-	void (*dev_select)(struct ata_port *ap, unsigned int device);
-	u8   (*check_status)(struct ata_port *ap);
-	u8   (*check_altstatus)(struct ata_port *ap);
-	void (*tf_load)(struct ata_port *ap, const struct ata_taskfile *tf);
-	void (*tf_read)(struct ata_port *ap, struct ata_taskfile *tf);
-	void (*exec_command)(struct ata_port *ap, const struct ata_taskfile *tf);
-	unsigned int (*data_xfer)(struct ata_device *dev, unsigned char *buf,
-				  unsigned int buflen, int rw);
-	u8   (*irq_on)(struct ata_port *);
-
-	void (*irq_clear)(struct ata_port *);
+	void (*sff_dev_select)(struct ata_port *ap, unsigned int device);
+	u8   (*sff_check_status)(struct ata_port *ap);
+	u8   (*sff_check_altstatus)(struct ata_port *ap);
+	void (*sff_tf_load)(struct ata_port *ap, const struct ata_taskfile *tf);
+	void (*sff_tf_read)(struct ata_port *ap, struct ata_taskfile *tf);
+	void (*sff_exec_command)(struct ata_port *ap,
+				 const struct ata_taskfile *tf);
+	unsigned int (*sff_data_xfer)(struct ata_device *dev,
+			unsigned char *buf, unsigned int buflen, int rw);
+	u8   (*sff_irq_on)(struct ata_port *);
+	void (*sff_irq_clear)(struct ata_port *);
+
 	void (*bmdma_setup)(struct ata_queued_cmd *qc);
 	void (*bmdma_start)(struct ata_queued_cmd *qc);
 	void (*bmdma_stop)(struct ata_queued_cmd *qc);
@@ -1438,7 +1439,7 @@ static inline u8 ata_sff_busy_wait(struct ata_port *ap, unsigned int bits,
 
 	do {
 		udelay(10);
-		status = ap->ops->check_status(ap);
+		status = ap->ops->sff_check_status(ap);
 		max--;
 	} while (status != 0xff && (status & bits) && (max > 0));
 

commit 9363c3825ea9ad76561eb48a395349dd29211ed6
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:16 2008 +0900

    libata: rename SFF functions
    
    SFF functions have confusing names.  Some have sff prefix, some have
    bmdma, some std, some pci and some none.  Unify the naming by...
    
    * SFF functions which are common to both BMDMA and non-BMDMA are
      prefixed with ata_sff_.
    
    * SFF functions which are specific to BMDMA are prefixed with
      ata_bmdma_.
    
    * SFF functions which are specific to PCI but apply to both BMDMA and
      non-BMDMA are prefixed with ata_pci_sff_.
    
    * SFF functions which are specific to PCI and BMDMA are prefixed with
      ata_pci_bmdma_.
    
    * Drop generic prefixes from LLD specific routines.  For example,
      bfin_std_dev_select -> bfin_dev_select.
    
    The following renames are noteworthy.
    
      ata_qc_issue_prot() -> ata_sff_qc_issue()
      ata_pci_default_filter() -> ata_bmdma_mode_filter()
      ata_dev_try_classify() -> ata_sff_dev_classify()
    
    This rename is in preparation of separating SFF support out of libata
    core layer.  This patch strictly renames functions and doesn't
    introduce any behavior difference.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a05de2ba7a72..66663bfe2c71 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1342,45 +1342,48 @@ extern const struct ata_port_operations ata_bmdma_port_ops;
 	.sg_tablesize		= LIBATA_MAX_PRD,		\
 	.dma_boundary		= ATA_DMA_BOUNDARY
 
-extern void ata_qc_prep(struct ata_queued_cmd *qc);
-extern void ata_dumb_qc_prep(struct ata_queued_cmd *qc);
-extern void ata_std_dev_select(struct ata_port *ap, unsigned int device);
-extern u8 ata_check_status(struct ata_port *ap);
-extern u8 ata_altstatus(struct ata_port *ap);
-extern int ata_busy_sleep(struct ata_port *ap,
-			  unsigned long timeout_pat, unsigned long timeout);
-extern int ata_wait_ready(struct ata_port *ap, unsigned long deadline);
-extern void ata_tf_load(struct ata_port *ap, const struct ata_taskfile *tf);
-extern void ata_tf_read(struct ata_port *ap, struct ata_taskfile *tf);
-extern void ata_exec_command(struct ata_port *ap, const struct ata_taskfile *tf);
-extern unsigned int ata_data_xfer(struct ata_device *dev,
+extern void ata_sff_qc_prep(struct ata_queued_cmd *qc);
+extern void ata_sff_dumb_qc_prep(struct ata_queued_cmd *qc);
+extern void ata_sff_dev_select(struct ata_port *ap, unsigned int device);
+extern u8 ata_sff_check_status(struct ata_port *ap);
+extern u8 ata_sff_altstatus(struct ata_port *ap);
+extern int ata_sff_busy_sleep(struct ata_port *ap,
+			      unsigned long timeout_pat, unsigned long timeout);
+extern int ata_sff_wait_ready(struct ata_port *ap, unsigned long deadline);
+extern void ata_sff_tf_load(struct ata_port *ap, const struct ata_taskfile *tf);
+extern void ata_sff_tf_read(struct ata_port *ap, struct ata_taskfile *tf);
+extern void ata_sff_exec_command(struct ata_port *ap,
+				 const struct ata_taskfile *tf);
+extern unsigned int ata_sff_data_xfer(struct ata_device *dev,
 			unsigned char *buf, unsigned int buflen, int rw);
-extern unsigned int ata_data_xfer_noirq(struct ata_device *dev,
+extern unsigned int ata_sff_data_xfer_noirq(struct ata_device *dev,
 			unsigned char *buf, unsigned int buflen, int rw);
-extern u8 ata_irq_on(struct ata_port *ap);
-extern void ata_bmdma_irq_clear(struct ata_port *ap);
-extern int ata_hsm_move(struct ata_port *ap, struct ata_queued_cmd *qc,
-			u8 status, int in_wq);
-extern unsigned int ata_qc_issue_prot(struct ata_queued_cmd *qc);
-extern unsigned int ata_host_intr(struct ata_port *ap, struct ata_queued_cmd *qc);
-extern irqreturn_t ata_interrupt(int irq, void *dev_instance);
-extern void ata_bmdma_freeze(struct ata_port *ap);
-extern void ata_bmdma_thaw(struct ata_port *ap);
-extern int ata_std_prereset(struct ata_link *link, unsigned long deadline);
-extern unsigned int ata_dev_try_classify(struct ata_device *dev, int present,
-					 u8 *r_err);
-extern void ata_wait_after_reset(struct ata_port *ap, unsigned long deadline);
-extern int ata_std_softreset(struct ata_link *link, unsigned int *classes,
+extern u8 ata_sff_irq_on(struct ata_port *ap);
+extern void ata_sff_irq_clear(struct ata_port *ap);
+extern int ata_sff_hsm_move(struct ata_port *ap, struct ata_queued_cmd *qc,
+			    u8 status, int in_wq);
+extern unsigned int ata_sff_qc_issue(struct ata_queued_cmd *qc);
+extern unsigned int ata_sff_host_intr(struct ata_port *ap,
+				      struct ata_queued_cmd *qc);
+extern irqreturn_t ata_sff_interrupt(int irq, void *dev_instance);
+extern void ata_sff_freeze(struct ata_port *ap);
+extern void ata_sff_thaw(struct ata_port *ap);
+extern int ata_sff_prereset(struct ata_link *link, unsigned long deadline);
+extern unsigned int ata_sff_dev_classify(struct ata_device *dev, int present,
+					  u8 *r_err);
+extern void ata_sff_wait_after_reset(struct ata_port *ap,
+				     unsigned long deadline);
+extern int ata_sff_softreset(struct ata_link *link, unsigned int *classes,
 			     unsigned long deadline);
-extern int sata_std_hardreset(struct ata_link *link, unsigned int *class,
-			      unsigned long deadline);
-extern void ata_std_postreset(struct ata_link *link, unsigned int *classes);
-extern void ata_bmdma_error_handler(struct ata_port *ap);
-extern void ata_bmdma_post_internal_cmd(struct ata_queued_cmd *qc);
+extern int sata_sff_hardreset(struct ata_link *link, unsigned int *class,
+			       unsigned long deadline);
+extern void ata_sff_postreset(struct ata_link *link, unsigned int *classes);
+extern void ata_sff_error_handler(struct ata_port *ap);
+extern void ata_sff_post_internal_cmd(struct ata_queued_cmd *qc);
 extern int ata_sff_port_start(struct ata_port *ap);
-extern void ata_std_ports(struct ata_ioports *ioaddr);
-extern unsigned long ata_pci_default_filter(struct ata_device *dev,
-					    unsigned long xfer_mask);
+extern void ata_sff_std_ports(struct ata_ioports *ioaddr);
+extern unsigned long ata_bmdma_mode_filter(struct ata_device *dev,
+					   unsigned long xfer_mask);
 extern void ata_bmdma_setup(struct ata_queued_cmd *qc);
 extern void ata_bmdma_start(struct ata_queued_cmd *qc);
 extern void ata_bmdma_stop(struct ata_queued_cmd *qc);
@@ -1388,35 +1391,35 @@ extern u8 ata_bmdma_status(struct ata_port *ap);
 extern void ata_bus_reset(struct ata_port *ap);
 
 #ifdef CONFIG_PCI
-extern int ata_pci_clear_simplex(struct pci_dev *pdev);
-extern int ata_pci_init_bmdma(struct ata_host *host);
-extern int ata_pci_init_sff_host(struct ata_host *host);
-extern int ata_pci_prepare_sff_host(struct pci_dev *pdev,
+extern int ata_pci_bmdma_clear_simplex(struct pci_dev *pdev);
+extern int ata_pci_bmdma_init(struct ata_host *host);
+extern int ata_pci_sff_init_host(struct ata_host *host);
+extern int ata_pci_sff_prepare_host(struct pci_dev *pdev,
 				    const struct ata_port_info * const * ppi,
 				    struct ata_host **r_host);
-extern int ata_pci_activate_sff_host(struct ata_host *host,
+extern int ata_pci_sff_activate_host(struct ata_host *host,
 				     irq_handler_t irq_handler,
 				     struct scsi_host_template *sht);
-extern int ata_pci_init_one(struct pci_dev *pdev,
-			    const struct ata_port_info * const * ppi,
-			    struct scsi_host_template *sht, void *host_priv);
+extern int ata_pci_sff_init_one(struct pci_dev *pdev,
+				const struct ata_port_info * const * ppi,
+				struct scsi_host_template *sht, void *host_priv);
 #endif /* CONFIG_PCI */
 
 /**
- *	ata_pause - Flush writes and pause 400 nanoseconds.
+ *	ata_sff_pause - Flush writes and pause 400 nanoseconds.
  *	@ap: Port to wait for.
  *
  *	LOCKING:
  *	Inherited from caller.
  */
-static inline void ata_pause(struct ata_port *ap)
+static inline void ata_sff_pause(struct ata_port *ap)
 {
-	ata_altstatus(ap);
+	ata_sff_altstatus(ap);
 	ndelay(400);
 }
 
 /**
- *	ata_busy_wait - Wait for a port status register
+ *	ata_sff_busy_wait - Wait for a port status register
  *	@ap: Port to wait for.
  *	@bits: bits that must be clear
  *	@max: number of 10uS waits to perform
@@ -1428,8 +1431,8 @@ static inline void ata_pause(struct ata_port *ap)
  *	LOCKING:
  *	Inherited from caller.
  */
-static inline u8 ata_busy_wait(struct ata_port *ap, unsigned int bits,
-			       unsigned int max)
+static inline u8 ata_sff_busy_wait(struct ata_port *ap, unsigned int bits,
+				   unsigned int max)
 {
 	u8 status;
 
@@ -1454,7 +1457,7 @@ static inline u8 ata_busy_wait(struct ata_port *ap, unsigned int bits,
  */
 static inline u8 ata_wait_idle(struct ata_port *ap)
 {
-	u8 status = ata_busy_wait(ap, ATA_BUSY | ATA_DRQ, 1000);
+	u8 status = ata_sff_busy_wait(ap, ATA_BUSY | ATA_DRQ, 1000);
 
 #ifdef ATA_DEBUG
 	if (status != 0xff && (status & (ATA_BUSY | ATA_DRQ)))

commit 83c063dd730cb56bf3fc89b70250ff9a398fec1e
Author: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
Date:   Thu Feb 28 21:43:13 2008 +0900

    use ATA_TAG_INTERNAL in ata_tag_internal()
    
    It should be ATA_TAG_INTERNAL.
    
    Signed-off-by: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b25ea6ab1be9..a05de2ba7a72 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1121,7 +1121,7 @@ static inline unsigned int ata_tag_valid(unsigned int tag)
 
 static inline unsigned int ata_tag_internal(unsigned int tag)
 {
-	return tag == ATA_MAX_QUEUE - 1;
+	return tag == ATA_TAG_INTERNAL;
 }
 
 /*

commit 03faab7827e4e45823fd27c47b84c133e20a0cd0
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Mar 27 19:14:24 2008 +0900

    libata: implement ATA_QCFLAG_RETRY
    
    Currently whether a command should be retried after failure is
    determined inside ata_eh_finish().  Add ATA_QCFLAG_RETRY and move the
    logic into ata_eh_autopsy().  This makes things clearer and helps
    extending retry determination logic.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 61a7f8d06971..b25ea6ab1be9 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -224,6 +224,7 @@ enum {
 	ATA_QCFLAG_RESULT_TF	= (1 << 4), /* result TF requested */
 	ATA_QCFLAG_CLEAR_EXCL	= (1 << 5), /* clear excl_link on completion */
 	ATA_QCFLAG_QUIET	= (1 << 6), /* don't report device error */
+	ATA_QCFLAG_RETRY	= (1 << 7), /* retry after failure */
 
 	ATA_QCFLAG_FAILED	= (1 << 16), /* cmd failed and is owned by EH */
 	ATA_QCFLAG_SENSE_VALID	= (1 << 17), /* sense data valid */

commit 6fd36390117f7844ad147377878ddb52088f583a
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 22:16:44 2008 +0900

    libata: kill ata_chk_status()
    
    ata_chk_status() just calls ops->check_status and it only adds
    confusion with other status functions.  Kill it.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 53b8db05a1fb..61a7f8d06971 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1401,11 +1401,6 @@ extern int ata_pci_init_one(struct pci_dev *pdev,
 			    struct scsi_host_template *sht, void *host_priv);
 #endif /* CONFIG_PCI */
 
-static inline u8 ata_chk_status(struct ata_port *ap)
-{
-	return ap->ops->check_status(ap);
-}
-
 /**
  *	ata_pause - Flush writes and pause 400 nanoseconds.
  *	@ap: Port to wait for.
@@ -1439,7 +1434,7 @@ static inline u8 ata_busy_wait(struct ata_port *ap, unsigned int bits,
 
 	do {
 		udelay(10);
-		status = ata_chk_status(ap);
+		status = ap->ops->check_status(ap);
 		max--;
 	} while (status != 0xff && (status & bits) && (max > 0));
 

commit 071ce34d57924edb76b76f7de460eb4991463959
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 22:16:42 2008 +0900

    libata: move ata_pci_default_filter() out of CONFIG_PCI
    
    ata_pci_default_filter() doesn't really have anything to do with PCI.
    It's generally applicable to BMDMA controllers.  Move it out of
    CONFIG_PCI.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 673f34b256ba..53b8db05a1fb 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1378,6 +1378,8 @@ extern void ata_bmdma_error_handler(struct ata_port *ap);
 extern void ata_bmdma_post_internal_cmd(struct ata_queued_cmd *qc);
 extern int ata_sff_port_start(struct ata_port *ap);
 extern void ata_std_ports(struct ata_ioports *ioaddr);
+extern unsigned long ata_pci_default_filter(struct ata_device *dev,
+					    unsigned long xfer_mask);
 extern void ata_bmdma_setup(struct ata_queued_cmd *qc);
 extern void ata_bmdma_start(struct ata_queued_cmd *qc);
 extern void ata_bmdma_stop(struct ata_queued_cmd *qc);
@@ -1386,8 +1388,6 @@ extern void ata_bus_reset(struct ata_port *ap);
 
 #ifdef CONFIG_PCI
 extern int ata_pci_clear_simplex(struct pci_dev *pdev);
-extern unsigned long ata_pci_default_filter(struct ata_device *dev,
-					    unsigned long xfer_mask);
 extern int ata_pci_init_bmdma(struct ata_host *host);
 extern int ata_pci_init_sff_host(struct ata_host *host);
 extern int ata_pci_prepare_sff_host(struct pci_dev *pdev,

commit 624d5c514eed18d5a93062e9d86d67065175f30a
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 22:16:41 2008 +0900

    libata: reorganize SFF related stuff
    
    * Move SFF related functions from libata-core.c to libata-sff.c.
    
      ata_[bmdma_]sff_port_ops, ata_devchk(), ata_dev_try_classify(),
      ata_std_dev_select(), ata_tf_to_host(), ata_busy_sleep(),
      ata_wait_after_reset(), ata_wait_ready(), ata_bus_post_reset(),
      ata_bus_softreset(), ata_bus_reset(), ata_std_softreset(),
      sata_std_hardreset(), ata_fill_sg(), ata_fill_sg_dumb(),
      ata_qc_prep(), ata_dump_qc_prep(), ata_data_xfer(),
      ata_data_xfer_noirq(), ata_pio_sector(), ata_pio_sectors(),
      atapi_send_cdb(), __atapi_pio_bytes(), atapi_pio_bytes(),
      ata_hsm_ok_in_wq(), ata_hsm_qc_complete(), ata_hsm_move(),
      ata_pio_task(), ata_qc_issue_prot(), ata_host_intr(),
      ata_interrupt(), ata_std_ports()
    
    * Make ata_pio_queue_task() global as it's now called from
      libata-sff.c.
    
    * Move SFF related stuff in include/linux/libata.h and
      drivers/ata/libata.h into one place.  While at it, move timing
      constants into the global enum definition and fortify comments a
      bit.
    
    This patch strictly moves stuff around and as such doesn't cause any
    functional difference.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 01c233303aee..673f34b256ba 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -349,6 +349,22 @@ enum {
 	ATAPI_READ_CD		= 2,		/* READ CD [MSF] */
 	ATAPI_PASS_THRU		= 3,		/* SAT pass-thru */
 	ATAPI_MISC		= 4,		/* the rest */
+
+	/* Timing constants */
+	ATA_TIMING_SETUP	= (1 << 0),
+	ATA_TIMING_ACT8B	= (1 << 1),
+	ATA_TIMING_REC8B	= (1 << 2),
+	ATA_TIMING_CYC8B	= (1 << 3),
+	ATA_TIMING_8BIT		= ATA_TIMING_ACT8B | ATA_TIMING_REC8B |
+				  ATA_TIMING_CYC8B,
+	ATA_TIMING_ACTIVE	= (1 << 4),
+	ATA_TIMING_RECOVER	= (1 << 5),
+	ATA_TIMING_CYCLE	= (1 << 6),
+	ATA_TIMING_UDMA		= (1 << 7),
+	ATA_TIMING_ALL		= ATA_TIMING_SETUP | ATA_TIMING_ACT8B |
+				  ATA_TIMING_REC8B | ATA_TIMING_CYC8B |
+				  ATA_TIMING_ACTIVE | ATA_TIMING_RECOVER |
+				  ATA_TIMING_CYCLE | ATA_TIMING_UDMA,
 };
 
 enum ata_xfer_mask {
@@ -779,6 +795,9 @@ struct ata_timing {
 
 #define FIT(v, vmin, vmax)	max_t(short, min_t(short, v, vmax), vmin)
 
+/*
+ * Core layer - drivers/ata/libata-core.c
+ */
 extern const unsigned long sata_deb_timing_normal[];
 extern const unsigned long sata_deb_timing_hotplug[];
 extern const unsigned long sata_deb_timing_long[];
@@ -802,22 +821,14 @@ static inline int ata_port_is_dummy(struct ata_port *ap)
 
 extern void sata_print_link_status(struct ata_link *link);
 extern void ata_port_probe(struct ata_port *);
-extern void ata_bus_reset(struct ata_port *ap);
 extern int sata_set_spd(struct ata_link *link);
 extern int sata_link_debounce(struct ata_link *link,
 			const unsigned long *params, unsigned long deadline);
 extern int sata_link_resume(struct ata_link *link, const unsigned long *params,
 			    unsigned long deadline);
-extern int ata_std_prereset(struct ata_link *link, unsigned long deadline);
-extern int ata_std_softreset(struct ata_link *link, unsigned int *classes,
-			     unsigned long deadline);
 extern int sata_link_hardreset(struct ata_link *link,
 			const unsigned long *timing, unsigned long deadline);
-extern int sata_std_hardreset(struct ata_link *link, unsigned int *class,
-			      unsigned long deadline);
-extern void ata_std_postreset(struct ata_link *link, unsigned int *classes);
 extern void ata_port_disable(struct ata_port *);
-extern void ata_std_ports(struct ata_ioports *ioaddr);
 
 extern struct ata_host *ata_host_alloc(struct device *dev, int max_ports);
 extern struct ata_host *ata_host_alloc_pinfo(struct device *dev,
@@ -843,7 +854,6 @@ extern void ata_sas_port_stop(struct ata_port *ap);
 extern int ata_sas_slave_configure(struct scsi_device *, struct ata_port *);
 extern int ata_sas_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *),
 			    struct ata_port *ap);
-extern unsigned int ata_host_intr(struct ata_port *ap, struct ata_queued_cmd *qc);
 extern int sata_scr_valid(struct ata_link *link);
 extern int sata_scr_read(struct ata_link *link, int reg, u32 *val);
 extern int sata_scr_write(struct ata_link *link, int reg, u32 val);
@@ -855,21 +865,9 @@ extern int ata_host_suspend(struct ata_host *host, pm_message_t mesg);
 extern void ata_host_resume(struct ata_host *host);
 #endif
 extern int ata_ratelimit(void);
-extern int ata_busy_sleep(struct ata_port *ap,
-			  unsigned long timeout_pat, unsigned long timeout);
-extern void ata_wait_after_reset(struct ata_port *ap, unsigned long deadline);
-extern int ata_wait_ready(struct ata_port *ap, unsigned long deadline);
 extern u32 ata_wait_register(void __iomem *reg, u32 mask, u32 val,
 			     unsigned long interval_msec,
 			     unsigned long timeout_msec);
-extern unsigned int ata_dev_try_classify(struct ata_device *dev, int present,
-					 u8 *r_err);
-
-/*
- * Default driver ops implementations
- */
-extern void ata_tf_load(struct ata_port *ap, const struct ata_taskfile *tf);
-extern void ata_tf_read(struct ata_port *ap, struct ata_taskfile *tf);
 extern int atapi_cmd_type(u8 opcode);
 extern void ata_tf_to_fis(const struct ata_taskfile *tf,
 			  u8 pmp, int is_cmd, u8 *fis);
@@ -885,22 +883,9 @@ extern int ata_xfer_mode2shift(unsigned long xfer_mode);
 extern const char *ata_mode_string(unsigned long xfer_mask);
 extern unsigned long ata_id_xfermask(const u16 *id);
 extern void ata_noop_dev_select(struct ata_port *ap, unsigned int device);
-extern void ata_std_dev_select(struct ata_port *ap, unsigned int device);
-extern u8 ata_check_status(struct ata_port *ap);
-extern u8 ata_altstatus(struct ata_port *ap);
-extern void ata_exec_command(struct ata_port *ap, const struct ata_taskfile *tf);
 extern int ata_port_start(struct ata_port *ap);
-extern int ata_sff_port_start(struct ata_port *ap);
-extern irqreturn_t ata_interrupt(int irq, void *dev_instance);
-extern unsigned int ata_data_xfer(struct ata_device *dev,
-			unsigned char *buf, unsigned int buflen, int rw);
-extern unsigned int ata_data_xfer_noirq(struct ata_device *dev,
-			unsigned char *buf, unsigned int buflen, int rw);
 extern int ata_std_qc_defer(struct ata_queued_cmd *qc);
-extern void ata_dumb_qc_prep(struct ata_queued_cmd *qc);
-extern void ata_qc_prep(struct ata_queued_cmd *qc);
 extern void ata_noop_qc_prep(struct ata_queued_cmd *qc);
-extern unsigned int ata_qc_issue_prot(struct ata_queued_cmd *qc);
 extern void ata_sg_init(struct ata_queued_cmd *qc, struct scatterlist *sg,
 		 unsigned int n_elem);
 extern unsigned int ata_dev_classify(const struct ata_taskfile *tf);
@@ -909,18 +894,7 @@ extern void ata_id_string(const u16 *id, unsigned char *s,
 			  unsigned int ofs, unsigned int len);
 extern void ata_id_c_string(const u16 *id, unsigned char *s,
 			    unsigned int ofs, unsigned int len);
-extern void ata_bmdma_setup(struct ata_queued_cmd *qc);
-extern void ata_bmdma_start(struct ata_queued_cmd *qc);
-extern void ata_bmdma_stop(struct ata_queued_cmd *qc);
-extern u8   ata_bmdma_status(struct ata_port *ap);
-extern void ata_bmdma_irq_clear(struct ata_port *ap);
 extern void ata_noop_irq_clear(struct ata_port *ap);
-extern void ata_bmdma_freeze(struct ata_port *ap);
-extern void ata_bmdma_thaw(struct ata_port *ap);
-extern void ata_bmdma_error_handler(struct ata_port *ap);
-extern void ata_bmdma_post_internal_cmd(struct ata_queued_cmd *qc);
-extern int ata_hsm_move(struct ata_port *ap, struct ata_queued_cmd *qc,
-			u8 status, int in_wq);
 extern void ata_qc_complete(struct ata_queued_cmd *qc);
 extern int ata_qc_complete_multiple(struct ata_port *ap, u32 qc_active,
 				    void (*finish_qc)(struct ata_queued_cmd *));
@@ -935,7 +909,6 @@ extern int ata_scsi_change_queue_depth(struct scsi_device *sdev,
 				       int queue_depth);
 extern struct ata_device *ata_dev_pair(struct ata_device *adev);
 extern int ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
-extern u8 ata_irq_on(struct ata_port *ap);
 
 extern int ata_cable_40wire(struct ata_port *ap);
 extern int ata_cable_80wire(struct ata_port *ap);
@@ -943,10 +916,7 @@ extern int ata_cable_sata(struct ata_port *ap);
 extern int ata_cable_ignore(struct ata_port *ap);
 extern int ata_cable_unknown(struct ata_port *ap);
 
-/*
- * Timing helpers
- */
-
+/* Timing helpers */
 extern unsigned int ata_pio_need_iordy(const struct ata_device *);
 extern const struct ata_timing *ata_timing_find_mode(u8 xfer_mode);
 extern int ata_timing_compute(struct ata_device *, unsigned short,
@@ -956,24 +926,31 @@ extern void ata_timing_merge(const struct ata_timing *,
 			     unsigned int);
 extern u8 ata_timing_cycle2mode(unsigned int xfer_shift, int cycle);
 
-enum {
-	ATA_TIMING_SETUP	= (1 << 0),
-	ATA_TIMING_ACT8B	= (1 << 1),
-	ATA_TIMING_REC8B	= (1 << 2),
-	ATA_TIMING_CYC8B	= (1 << 3),
-	ATA_TIMING_8BIT		= ATA_TIMING_ACT8B | ATA_TIMING_REC8B |
-				  ATA_TIMING_CYC8B,
-	ATA_TIMING_ACTIVE	= (1 << 4),
-	ATA_TIMING_RECOVER	= (1 << 5),
-	ATA_TIMING_CYCLE	= (1 << 6),
-	ATA_TIMING_UDMA		= (1 << 7),
-	ATA_TIMING_ALL		= ATA_TIMING_SETUP | ATA_TIMING_ACT8B |
-				  ATA_TIMING_REC8B | ATA_TIMING_CYC8B |
-				  ATA_TIMING_ACTIVE | ATA_TIMING_RECOVER |
-				  ATA_TIMING_CYCLE | ATA_TIMING_UDMA,
+/* PCI */
+#ifdef CONFIG_PCI
+struct pci_dev;
+
+struct pci_bits {
+	unsigned int		reg;	/* PCI config register to read */
+	unsigned int		width;	/* 1 (8 bit), 2 (16 bit), 4 (32 bit) */
+	unsigned long		mask;
+	unsigned long		val;
 };
 
-/* libata-acpi.c */
+extern int pci_test_config_bits(struct pci_dev *pdev, const struct pci_bits *bits);
+extern void ata_pci_remove_one(struct pci_dev *pdev);
+
+#ifdef CONFIG_PM
+extern void ata_pci_device_do_suspend(struct pci_dev *pdev, pm_message_t mesg);
+extern int __must_check ata_pci_device_do_resume(struct pci_dev *pdev);
+extern int ata_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg);
+extern int ata_pci_device_resume(struct pci_dev *pdev);
+#endif /* CONFIG_PM */
+#endif /* CONFIG_PCI */
+
+/*
+ * ACPI - drivers/ata/libata-acpi.c
+ */
 #ifdef CONFIG_ATA_ACPI
 static inline const struct ata_acpi_gtm *ata_acpi_init_gtm(struct ata_port *ap)
 {
@@ -1017,43 +994,8 @@ static inline int ata_acpi_cbl_80wire(struct ata_port *ap,
 }
 #endif
 
-#ifdef CONFIG_PCI
-struct pci_dev;
-
-extern int ata_pci_init_one(struct pci_dev *pdev,
-			    const struct ata_port_info * const * ppi,
-			    struct scsi_host_template *sht, void *host_priv);
-extern void ata_pci_remove_one(struct pci_dev *pdev);
-#ifdef CONFIG_PM
-extern void ata_pci_device_do_suspend(struct pci_dev *pdev, pm_message_t mesg);
-extern int __must_check ata_pci_device_do_resume(struct pci_dev *pdev);
-extern int ata_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg);
-extern int ata_pci_device_resume(struct pci_dev *pdev);
-#endif
-extern int ata_pci_clear_simplex(struct pci_dev *pdev);
-
-struct pci_bits {
-	unsigned int		reg;	/* PCI config register to read */
-	unsigned int		width;	/* 1 (8 bit), 2 (16 bit), 4 (32 bit) */
-	unsigned long		mask;
-	unsigned long		val;
-};
-
-extern int ata_pci_init_sff_host(struct ata_host *host);
-extern int ata_pci_init_bmdma(struct ata_host *host);
-extern int ata_pci_prepare_sff_host(struct pci_dev *pdev,
-				    const struct ata_port_info * const * ppi,
-				    struct ata_host **r_host);
-extern int ata_pci_activate_sff_host(struct ata_host *host,
-				     irq_handler_t irq_handler,
-				     struct scsi_host_template *sht);
-extern int pci_test_config_bits(struct pci_dev *pdev, const struct pci_bits *bits);
-extern unsigned long ata_pci_default_filter(struct ata_device *dev,
-					    unsigned long xfer_mask);
-#endif /* CONFIG_PCI */
-
 /*
- * PMP
+ * PMP - drivers/ata/libata-pmp.c
  */
 extern int sata_pmp_qc_defer_cmd_switch(struct ata_queued_cmd *qc);
 extern int sata_pmp_std_prereset(struct ata_link *link, unsigned long deadline);
@@ -1063,7 +1005,7 @@ extern void sata_pmp_std_postreset(struct ata_link *link, unsigned int *class);
 extern void sata_pmp_error_handler(struct ata_port *ap);
 
 /*
- * EH
+ * EH - drivers/ata/libata-eh.c
  */
 extern void ata_port_schedule_eh(struct ata_port *ap);
 extern int ata_link_abort(struct ata_link *link);
@@ -1106,8 +1048,6 @@ extern void ata_std_error_handler(struct ata_port *ap);
 extern const struct ata_port_operations ata_base_port_ops;
 extern const struct ata_port_operations sata_port_ops;
 extern const struct ata_port_operations sata_pmp_port_ops;
-extern const struct ata_port_operations ata_sff_port_ops;
-extern const struct ata_port_operations ata_bmdma_port_ops;
 
 #define ATA_BASE_SHT(drv_name)					\
 	.module			= THIS_MODULE,			\
@@ -1124,17 +1064,6 @@ extern const struct ata_port_operations ata_bmdma_port_ops;
 	.slave_destroy		= ata_scsi_slave_destroy,	\
 	.bios_param		= ata_std_bios_param
 
-/* PIO only, sg_tablesize and dma_boundary limits can be removed */
-#define ATA_PIO_SHT(drv_name)					\
-	ATA_BASE_SHT(drv_name),					\
-	.sg_tablesize		= LIBATA_MAX_PRD,		\
-	.dma_boundary		= ATA_DMA_BOUNDARY
-
-#define ATA_BMDMA_SHT(drv_name)					\
-	ATA_BASE_SHT(drv_name),					\
-	.sg_tablesize		= LIBATA_MAX_PRD,		\
-	.dma_boundary		= ATA_DMA_BOUNDARY
-
 #define ATA_NCQ_SHT(drv_name)					\
 	ATA_BASE_SHT(drv_name),					\
 	.change_queue_depth	= ata_scsi_change_queue_depth
@@ -1287,11 +1216,6 @@ static inline struct ata_link *ata_port_next_link(struct ata_link *link)
 	for ((dev) = (link)->device + ata_link_max_devices(link) - 1; \
 	     (dev) >= (link)->device || ((dev) = NULL); (dev)--)
 
-static inline u8 ata_chk_status(struct ata_port *ap)
-{
-	return ap->ops->check_status(ap);
-}
-
 /**
  *	ata_ncq_enabled - Test whether NCQ is enabled
  *	@dev: ATA device to test for
@@ -1308,74 +1232,6 @@ static inline int ata_ncq_enabled(struct ata_device *dev)
 			      ATA_DFLAG_NCQ)) == ATA_DFLAG_NCQ;
 }
 
-/**
- *	ata_pause - Flush writes and pause 400 nanoseconds.
- *	@ap: Port to wait for.
- *
- *	LOCKING:
- *	Inherited from caller.
- */
-
-static inline void ata_pause(struct ata_port *ap)
-{
-	ata_altstatus(ap);
-	ndelay(400);
-}
-
-
-/**
- *	ata_busy_wait - Wait for a port status register
- *	@ap: Port to wait for.
- *	@bits: bits that must be clear
- *	@max: number of 10uS waits to perform
- *
- *	Waits up to max*10 microseconds for the selected bits in the port's
- *	status register to be cleared.
- *	Returns final value of status register.
- *
- *	LOCKING:
- *	Inherited from caller.
- */
-
-static inline u8 ata_busy_wait(struct ata_port *ap, unsigned int bits,
-			       unsigned int max)
-{
-	u8 status;
-
-	do {
-		udelay(10);
-		status = ata_chk_status(ap);
-		max--;
-	} while (status != 0xff && (status & bits) && (max > 0));
-
-	return status;
-}
-
-
-/**
- *	ata_wait_idle - Wait for a port to be idle.
- *	@ap: Port to wait for.
- *
- *	Waits up to 10ms for port's BUSY and DRQ signals to clear.
- *	Returns final value of status register.
- *
- *	LOCKING:
- *	Inherited from caller.
- */
-
-static inline u8 ata_wait_idle(struct ata_port *ap)
-{
-	u8 status = ata_busy_wait(ap, ATA_BUSY | ATA_DRQ, 1000);
-
-#ifdef ATA_DEBUG
-	if (status != 0xff && (status & (ATA_BUSY | ATA_DRQ)))
-		ata_port_printk(ap, KERN_DEBUG, "abnormal Status 0x%X\n",
-				status);
-#endif
-
-	return status;
-}
-
 static inline void ata_qc_set_polling(struct ata_queued_cmd *qc)
 {
 	qc->tf.ctl |= ATA_NIEN;
@@ -1468,4 +1324,149 @@ static inline struct ata_port *ata_shost_to_port(struct Scsi_Host *host)
 	return *(struct ata_port **)&host->hostdata[0];
 }
 
+/**************************************************************************
+ * SFF - drivers/ata/libata-sff.c
+ */
+extern const struct ata_port_operations ata_sff_port_ops;
+extern const struct ata_port_operations ata_bmdma_port_ops;
+
+/* PIO only, sg_tablesize and dma_boundary limits can be removed */
+#define ATA_PIO_SHT(drv_name)					\
+	ATA_BASE_SHT(drv_name),					\
+	.sg_tablesize		= LIBATA_MAX_PRD,		\
+	.dma_boundary		= ATA_DMA_BOUNDARY
+
+#define ATA_BMDMA_SHT(drv_name)					\
+	ATA_BASE_SHT(drv_name),					\
+	.sg_tablesize		= LIBATA_MAX_PRD,		\
+	.dma_boundary		= ATA_DMA_BOUNDARY
+
+extern void ata_qc_prep(struct ata_queued_cmd *qc);
+extern void ata_dumb_qc_prep(struct ata_queued_cmd *qc);
+extern void ata_std_dev_select(struct ata_port *ap, unsigned int device);
+extern u8 ata_check_status(struct ata_port *ap);
+extern u8 ata_altstatus(struct ata_port *ap);
+extern int ata_busy_sleep(struct ata_port *ap,
+			  unsigned long timeout_pat, unsigned long timeout);
+extern int ata_wait_ready(struct ata_port *ap, unsigned long deadline);
+extern void ata_tf_load(struct ata_port *ap, const struct ata_taskfile *tf);
+extern void ata_tf_read(struct ata_port *ap, struct ata_taskfile *tf);
+extern void ata_exec_command(struct ata_port *ap, const struct ata_taskfile *tf);
+extern unsigned int ata_data_xfer(struct ata_device *dev,
+			unsigned char *buf, unsigned int buflen, int rw);
+extern unsigned int ata_data_xfer_noirq(struct ata_device *dev,
+			unsigned char *buf, unsigned int buflen, int rw);
+extern u8 ata_irq_on(struct ata_port *ap);
+extern void ata_bmdma_irq_clear(struct ata_port *ap);
+extern int ata_hsm_move(struct ata_port *ap, struct ata_queued_cmd *qc,
+			u8 status, int in_wq);
+extern unsigned int ata_qc_issue_prot(struct ata_queued_cmd *qc);
+extern unsigned int ata_host_intr(struct ata_port *ap, struct ata_queued_cmd *qc);
+extern irqreturn_t ata_interrupt(int irq, void *dev_instance);
+extern void ata_bmdma_freeze(struct ata_port *ap);
+extern void ata_bmdma_thaw(struct ata_port *ap);
+extern int ata_std_prereset(struct ata_link *link, unsigned long deadline);
+extern unsigned int ata_dev_try_classify(struct ata_device *dev, int present,
+					 u8 *r_err);
+extern void ata_wait_after_reset(struct ata_port *ap, unsigned long deadline);
+extern int ata_std_softreset(struct ata_link *link, unsigned int *classes,
+			     unsigned long deadline);
+extern int sata_std_hardreset(struct ata_link *link, unsigned int *class,
+			      unsigned long deadline);
+extern void ata_std_postreset(struct ata_link *link, unsigned int *classes);
+extern void ata_bmdma_error_handler(struct ata_port *ap);
+extern void ata_bmdma_post_internal_cmd(struct ata_queued_cmd *qc);
+extern int ata_sff_port_start(struct ata_port *ap);
+extern void ata_std_ports(struct ata_ioports *ioaddr);
+extern void ata_bmdma_setup(struct ata_queued_cmd *qc);
+extern void ata_bmdma_start(struct ata_queued_cmd *qc);
+extern void ata_bmdma_stop(struct ata_queued_cmd *qc);
+extern u8 ata_bmdma_status(struct ata_port *ap);
+extern void ata_bus_reset(struct ata_port *ap);
+
+#ifdef CONFIG_PCI
+extern int ata_pci_clear_simplex(struct pci_dev *pdev);
+extern unsigned long ata_pci_default_filter(struct ata_device *dev,
+					    unsigned long xfer_mask);
+extern int ata_pci_init_bmdma(struct ata_host *host);
+extern int ata_pci_init_sff_host(struct ata_host *host);
+extern int ata_pci_prepare_sff_host(struct pci_dev *pdev,
+				    const struct ata_port_info * const * ppi,
+				    struct ata_host **r_host);
+extern int ata_pci_activate_sff_host(struct ata_host *host,
+				     irq_handler_t irq_handler,
+				     struct scsi_host_template *sht);
+extern int ata_pci_init_one(struct pci_dev *pdev,
+			    const struct ata_port_info * const * ppi,
+			    struct scsi_host_template *sht, void *host_priv);
+#endif /* CONFIG_PCI */
+
+static inline u8 ata_chk_status(struct ata_port *ap)
+{
+	return ap->ops->check_status(ap);
+}
+
+/**
+ *	ata_pause - Flush writes and pause 400 nanoseconds.
+ *	@ap: Port to wait for.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+static inline void ata_pause(struct ata_port *ap)
+{
+	ata_altstatus(ap);
+	ndelay(400);
+}
+
+/**
+ *	ata_busy_wait - Wait for a port status register
+ *	@ap: Port to wait for.
+ *	@bits: bits that must be clear
+ *	@max: number of 10uS waits to perform
+ *
+ *	Waits up to max*10 microseconds for the selected bits in the port's
+ *	status register to be cleared.
+ *	Returns final value of status register.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+static inline u8 ata_busy_wait(struct ata_port *ap, unsigned int bits,
+			       unsigned int max)
+{
+	u8 status;
+
+	do {
+		udelay(10);
+		status = ata_chk_status(ap);
+		max--;
+	} while (status != 0xff && (status & bits) && (max > 0));
+
+	return status;
+}
+
+/**
+ *	ata_wait_idle - Wait for a port to be idle.
+ *	@ap: Port to wait for.
+ *
+ *	Waits up to 10ms for port's BUSY and DRQ signals to clear.
+ *	Returns final value of status register.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+static inline u8 ata_wait_idle(struct ata_port *ap)
+{
+	u8 status = ata_busy_wait(ap, ATA_BUSY | ATA_DRQ, 1000);
+
+#ifdef ATA_DEBUG
+	if (status != 0xff && (status & (ATA_BUSY | ATA_DRQ)))
+		ata_port_printk(ap, KERN_DEBUG, "abnormal Status 0x%X\n",
+				status);
+#endif
+
+	return status;
+}
+
 #endif /* __LINUX_LIBATA_H__ */

commit a1efdaba2dbd6fb89e23a87b66d3f4dd92c9f5af
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:50 2008 +0900

    libata: make reset related methods proper port operations
    
    Currently reset methods are not specified directly in the
    ata_port_operations table.  If a LLD wants to use custom reset
    methods, it should construct and use a error_handler which uses those
    reset methods.  It's done this way for two reasons.
    
    First, the ops table already contained too many methods and adding
    four more of them would noticeably increase the amount of necessary
    boilerplate code all over low level drivers.
    
    Second, as ->error_handler uses those reset methods, it can get
    confusing.  ie. By overriding ->error_handler, those reset ops can be
    made useless making layering a bit hazy.
    
    Now that ops table uses inheritance, the first problem doesn't exist
    anymore.  The second isn't completely solved but is relieved by
    providing default values - most drivers can just override what it has
    implemented and don't have to concern itself about higher level
    callbacks.  In fact, there currently is no driver which actually
    modifies error handling behavior.  Drivers which override
    ->error_handler just wraps the standard error handler only to prepare
    the controller for EH.  I don't think making ops layering strict has
    any noticeable benefit.
    
    This patch makes ->prereset, ->softreset, ->hardreset, ->postreset and
    their PMP counterparts propoer ops.  Default ops are provided in the
    base ops tables and drivers are converted to override individual reset
    methods instead of creating custom error_handler.
    
    * ata_std_error_handler() doesn't use sata_std_hardreset() if SCRs
      aren't accessible.  sata_promise doesn't need to use separate
      error_handlers for PATA and SATA anymore.
    
    * softreset is broken for sata_inic162x and sata_sx4.  As libata now
      always prefers hardreset, this doesn't really matter but the ops are
      forced to NULL using ATA_OP_NULL for documentation purpose.
    
    * pata_hpt374 needs to use different prereset for the first and second
      PCI functions.  This used to be done by branching from
      hpt374_error_handler().  The proper way to do this is to use
      separate ops and port_info tables for each function.  Converted.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 88c6fa84ed74..01c233303aee 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -693,6 +693,14 @@ struct ata_port_operations {
 
 	void (*freeze)(struct ata_port *ap);
 	void (*thaw)(struct ata_port *ap);
+	ata_prereset_fn_t	prereset;
+	ata_reset_fn_t		softreset;
+	ata_reset_fn_t		hardreset;
+	ata_postreset_fn_t	postreset;
+	ata_prereset_fn_t	pmp_prereset;
+	ata_reset_fn_t		pmp_softreset;
+	ata_reset_fn_t		pmp_hardreset;
+	ata_postreset_fn_t	pmp_postreset;
 	void (*error_handler)(struct ata_port *ap);
 	void (*post_internal_cmd)(struct ata_queued_cmd *qc);
 
@@ -909,10 +917,6 @@ extern void ata_bmdma_irq_clear(struct ata_port *ap);
 extern void ata_noop_irq_clear(struct ata_port *ap);
 extern void ata_bmdma_freeze(struct ata_port *ap);
 extern void ata_bmdma_thaw(struct ata_port *ap);
-extern void ata_bmdma_drive_eh(struct ata_port *ap, ata_prereset_fn_t prereset,
-			       ata_reset_fn_t softreset,
-			       ata_reset_fn_t hardreset,
-			       ata_postreset_fn_t postreset);
 extern void ata_bmdma_error_handler(struct ata_port *ap);
 extern void ata_bmdma_post_internal_cmd(struct ata_queued_cmd *qc);
 extern int ata_hsm_move(struct ata_port *ap, struct ata_queued_cmd *qc,
@@ -1056,11 +1060,7 @@ extern int sata_pmp_std_prereset(struct ata_link *link, unsigned long deadline);
 extern int sata_pmp_std_hardreset(struct ata_link *link, unsigned int *class,
 				  unsigned long deadline);
 extern void sata_pmp_std_postreset(struct ata_link *link, unsigned int *class);
-extern void sata_pmp_do_eh(struct ata_port *ap,
-		ata_prereset_fn_t prereset, ata_reset_fn_t softreset,
-		ata_reset_fn_t hardreset, ata_postreset_fn_t postreset,
-		ata_prereset_fn_t pmp_prereset, ata_reset_fn_t pmp_softreset,
-		ata_reset_fn_t pmp_hardreset, ata_postreset_fn_t pmp_postreset);
+extern void sata_pmp_error_handler(struct ata_port *ap);
 
 /*
  * EH
@@ -1080,6 +1080,7 @@ extern void ata_eh_qc_retry(struct ata_queued_cmd *qc);
 extern void ata_do_eh(struct ata_port *ap, ata_prereset_fn_t prereset,
 		      ata_reset_fn_t softreset, ata_reset_fn_t hardreset,
 		      ata_postreset_fn_t postreset);
+extern void ata_std_error_handler(struct ata_port *ap);
 
 /*
  * Base operations to inherit from and initializers for sht

commit 959471936241bd83da7d0a76411cef6772140fe6
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:49 2008 +0900

    libata: kill port_info->sht and ->irq_handler
    
    libata core layer doesn't care about sht or ->irq_handler.  Those are
    only of interest to the LLD during initialization.  This is confusing
    and has caused several drivers to have duplicate unused initializers
    for these fields.
    
    Currently only sata_nv uses these fields.  Make sata_nv use
    ->private_data, which is supposed to carry LLD-specific information,
    instead and kill ->sht and ->irq_handler.  nv_pi_priv structure is
    defined and struct literals are used to initialize private_data.
    Notational overhead is negligible.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index e7f10a88efe1..88c6fa84ed74 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -748,14 +748,12 @@ struct ata_port_operations {
 };
 
 struct ata_port_info {
-	struct scsi_host_template	*sht;
 	unsigned long		flags;
 	unsigned long		link_flags;
 	unsigned long		pio_mask;
 	unsigned long		mwdma_mask;
 	unsigned long		udma_mask;
 	struct ata_port_operations *port_ops;
-	irq_handler_t		irq_handler;
 	void 			*private_data;
 };
 

commit 887125e3740283be25564bfc6fb5d24974b651ab
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:49 2008 +0900

    libata: stop overloading port_info->private_data
    
    port_info->private_data is currently used for two purposes - to record
    private data about the port_info or to specify host->private_data to
    use when allocating ata_host.
    
    This overloading is confusing and counter-intuitive in that
    port_info->private_data becomes host->private_data instead of
    port->private_data.  In addition, port_info and host don't correspond
    to each other 1-to-1.  Currently, the first non-NULL
    port_info->private_data is used.
    
    This patch makes port_info->private_data just be what it is -
    private_data for the port_info where LLD can jot down extra info.
    libata no longer sets host->private_data to the first non-NULL
    port_info->private_data, @host_priv argument is added to
    ata_pci_init_one() instead.  LLDs which use ata_pci_init_one() can use
    this argument to pass in pointer to host private data.  LLDs which
    don't should use init-register model anyway and can initialize
    host->private_data directly.
    
    Adding @host_priv instead of using init-register model for LLDs which
    use ata_pci_init_one() is suggested by Alan Cox.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 5494119854de..e7f10a88efe1 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1020,7 +1020,7 @@ struct pci_dev;
 
 extern int ata_pci_init_one(struct pci_dev *pdev,
 			    const struct ata_port_info * const * ppi,
-			    struct scsi_host_template *sht);
+			    struct scsi_host_template *sht, void *host_priv);
 extern void ata_pci_remove_one(struct pci_dev *pdev);
 #ifdef CONFIG_PM
 extern void ata_pci_device_do_suspend(struct pci_dev *pdev, pm_message_t mesg);

commit 1bd5b715a305f6f13455e89becbd839010dd14b5
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:49 2008 +0900

    libata: make ata_pci_init_one() not use ops->irq_handler and pi->sht
    
    ata_pci_init_one() is the only function which uses ops->irq_handler
    and pi->sht.  Other initialization functions take the same information
    as arguments.  This causes confusion and duplicate unused entries in
    structures.
    
    Make ata_pci_init_one() take sht as an argument and use ata_interrupt
    implicitly.  All current users use ata_interrupt and if different irq
    handler is necessary open coding ata_pci_init_one() using
    ata_prepare_sff_host() and ata_activate_sff_host can be done under ten
    lines including error handling and driver which requires custom
    interrupt handler is likely to require custom initialization anyway.
    
    As ata_pci_init_one() was the last user of ops->irq_handler, this
    patch also kills the field.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 46aa4ab64891..5494119854de 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -739,7 +739,6 @@ struct ata_port_operations {
 	 */
 	void (*phy_reset)(struct ata_port *ap);
 	void (*eng_timeout)(struct ata_port *ap);
-	irq_handler_t irq_handler;
 
 	/*
 	 * ->inherits must be the last field and all the preceding
@@ -1020,7 +1019,8 @@ static inline int ata_acpi_cbl_80wire(struct ata_port *ap,
 struct pci_dev;
 
 extern int ata_pci_init_one(struct pci_dev *pdev,
-			     const struct ata_port_info * const * ppi);
+			    const struct ata_port_info * const * ppi,
+			    struct scsi_host_template *sht);
 extern void ata_pci_remove_one(struct pci_dev *pdev);
 #ifdef CONFIG_PM
 extern void ata_pci_device_do_suspend(struct pci_dev *pdev, pm_message_t mesg);

commit 029cfd6b74fc5c517865fad78cf4a3ea8d9b664a
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:49 2008 +0900

    libata: implement and use ops inheritance
    
    libata lets low level drivers build ata_port_operations table and
    register it with libata core layer.  This allows low level drivers
    high level of flexibility but also burdens them with lots of
    boilerplate entries.
    
    This becomes worse for drivers which support related similar
    controllers which differ slightly.  They share most of the operations
    except for a few.  However, the driver still needs to list all
    operations for each variant.  This results in large number of
    duplicate entries, which is not only inefficient but also error-prone
    as it becomes very difficult to tell what the actual differences are.
    
    This duplicate boilerplates all over the low level drivers also make
    updating the core layer exteremely difficult and error-prone.  When
    compounded with multi-branched development model, it ends up
    accumulating inconsistencies over time.  Some of those inconsistencies
    cause immediate problems and fixed.  Others just remain there dormant
    making maintenance increasingly difficult.
    
    To rectify the problem, this patch implements ata_port_operations
    inheritance.  To allow LLDs to easily re-use their own ops tables
    overriding only specific methods, this patch implements poor man's
    class inheritance.  An ops table has ->inherits field which can be set
    to any ops table as long as it doesn't create a loop.  When the host
    is started, the inheritance chain is followed and any operation which
    isn't specified is taken from the nearest ancestor which has it
    specified.  This operation is called finalization and done only once
    per an ops table and the LLD doesn't have to do anything special about
    it other than making the ops table non-const such that libata can
    update it.
    
    libata provides four base ops tables lower drivers can inherit from -
    base, sata, pmp, sff and bmdma.  To avoid overriding these ops
    accidentaly, these ops are declared const and LLDs should always
    inherit these instead of using them directly.
    
    After finalization, all the ops table are identical before and after
    the patch except for setting .irq_handler to ata_interrupt in drivers
    which didn't use to.  The .irq_handler doesn't have any actual effect
    and the field will soon be removed by later patch.
    
    * sata_sx4 is still using old style EH and currently doesn't take
      advantage of ops inheritance.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index eccc38e17568..46aa4ab64891 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -433,7 +433,7 @@ struct ata_host {
 	void __iomem * const	*iomap;
 	unsigned int		n_ports;
 	void			*private_data;
-	const struct ata_port_operations *ops;
+	struct ata_port_operations *ops;
 	unsigned long		flags;
 #ifdef CONFIG_ATA_ACPI
 	acpi_handle		acpi_handle;
@@ -602,7 +602,7 @@ struct ata_link {
 
 struct ata_port {
 	struct Scsi_Host	*scsi_host; /* our co-allocated scsi host */
-	const struct ata_port_operations *ops;
+	struct ata_port_operations *ops;
 	spinlock_t		*lock;
 	unsigned long		flags;	/* ATA_FLAG_xxx */
 	unsigned int		pflags; /* ATA_PFLAG_xxx */
@@ -664,6 +664,13 @@ struct ata_port {
 	u8			sector_buf[ATA_SECT_SIZE]; /* owned by EH */
 };
 
+/* The following initializer overrides a method to NULL whether one of
+ * its parent has the method defined or not.  This is equivalent to
+ * ERR_PTR(-ENOENT).  Unfortunately, ERR_PTR doesn't render a constant
+ * expression and thus can't be used as an initializer.
+ */
+#define ATA_OP_NULL		(void *)(unsigned long)(-ENOENT)
+
 struct ata_port_operations {
 	/*
 	 * Command execution
@@ -733,6 +740,12 @@ struct ata_port_operations {
 	void (*phy_reset)(struct ata_port *ap);
 	void (*eng_timeout)(struct ata_port *ap);
 	irq_handler_t irq_handler;
+
+	/*
+	 * ->inherits must be the last field and all the preceding
+	 * fields must be pointers.
+	 */
+	const struct ata_port_operations	*inherits;
 };
 
 struct ata_port_info {
@@ -742,7 +755,7 @@ struct ata_port_info {
 	unsigned long		pio_mask;
 	unsigned long		mwdma_mask;
 	unsigned long		udma_mask;
-	const struct ata_port_operations *port_ops;
+	struct ata_port_operations *port_ops;
 	irq_handler_t		irq_handler;
 	void 			*private_data;
 };
@@ -765,7 +778,7 @@ extern const unsigned long sata_deb_timing_normal[];
 extern const unsigned long sata_deb_timing_hotplug[];
 extern const unsigned long sata_deb_timing_long[];
 
-extern const struct ata_port_operations ata_dummy_port_ops;
+extern struct ata_port_operations ata_dummy_port_ops;
 extern const struct ata_port_info ata_dummy_port_info;
 
 static inline const unsigned long *
@@ -812,7 +825,7 @@ extern int ata_host_activate(struct ata_host *host, int irq,
 			     struct scsi_host_template *sht);
 extern void ata_host_detach(struct ata_host *host);
 extern void ata_host_init(struct ata_host *, struct device *,
-			  unsigned long, const struct ata_port_operations *);
+			  unsigned long, struct ata_port_operations *);
 extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
 extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));

commit 68d1d07b510bb57a504588adc2bd2758adea0965
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:49 2008 +0900

    libata: implement and use SHT initializers
    
    libata lets low level drivers build scsi_host_template and register it
    to the SCSI layer.  This allows low level drivers high level of
    flexibility but also burdens them with lots of boilerplate entries.
    
    This patch implements SHT initializers which can be used to initialize
    all the boilerplate entries in a sht.  Three variants of them are
    implemented - BASE, BMDMA and NCQ - for different types of drivers.
    Note that entries can be overriden by putting individual initializers
    after the helper macro.
    
    All sht tables are identical before and after this patch.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 639298af583e..eccc38e17568 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1070,6 +1070,63 @@ extern void ata_do_eh(struct ata_port *ap, ata_prereset_fn_t prereset,
 		      ata_reset_fn_t softreset, ata_reset_fn_t hardreset,
 		      ata_postreset_fn_t postreset);
 
+/*
+ * Base operations to inherit from and initializers for sht
+ *
+ * Operations
+ *
+ * base  : Common to all libata drivers.
+ * sata  : SATA controllers w/ native interface.
+ * pmp   : SATA controllers w/ PMP support.
+ * sff   : SFF ATA controllers w/o BMDMA support.
+ * bmdma : SFF ATA controllers w/ BMDMA support.
+ *
+ * sht initializers
+ *
+ * BASE  : Common to all libata drivers.  The user must set
+ *	   sg_tablesize and dma_boundary.
+ * PIO   : SFF ATA controllers w/ only PIO support.
+ * BMDMA : SFF ATA controllers w/ BMDMA support.  sg_tablesize and
+ *	   dma_boundary are set to BMDMA limits.
+ * NCQ   : SATA controllers supporting NCQ.  The user must set
+ *	   sg_tablesize, dma_boundary and can_queue.
+ */
+extern const struct ata_port_operations ata_base_port_ops;
+extern const struct ata_port_operations sata_port_ops;
+extern const struct ata_port_operations sata_pmp_port_ops;
+extern const struct ata_port_operations ata_sff_port_ops;
+extern const struct ata_port_operations ata_bmdma_port_ops;
+
+#define ATA_BASE_SHT(drv_name)					\
+	.module			= THIS_MODULE,			\
+	.name			= drv_name,			\
+	.ioctl			= ata_scsi_ioctl,		\
+	.queuecommand		= ata_scsi_queuecmd,		\
+	.can_queue		= ATA_DEF_QUEUE,		\
+	.this_id		= ATA_SHT_THIS_ID,		\
+	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,		\
+	.emulated		= ATA_SHT_EMULATED,		\
+	.use_clustering		= ATA_SHT_USE_CLUSTERING,	\
+	.proc_name		= drv_name,			\
+	.slave_configure	= ata_scsi_slave_config,	\
+	.slave_destroy		= ata_scsi_slave_destroy,	\
+	.bios_param		= ata_std_bios_param
+
+/* PIO only, sg_tablesize and dma_boundary limits can be removed */
+#define ATA_PIO_SHT(drv_name)					\
+	ATA_BASE_SHT(drv_name),					\
+	.sg_tablesize		= LIBATA_MAX_PRD,		\
+	.dma_boundary		= ATA_DMA_BOUNDARY
+
+#define ATA_BMDMA_SHT(drv_name)					\
+	ATA_BASE_SHT(drv_name),					\
+	.sg_tablesize		= LIBATA_MAX_PRD,		\
+	.dma_boundary		= ATA_DMA_BOUNDARY
+
+#define ATA_NCQ_SHT(drv_name)					\
+	ATA_BASE_SHT(drv_name),					\
+	.change_queue_depth	= ata_scsi_change_queue_depth
+
 /*
  * printk helpers
  */

commit 358f9a77a668660729e705fde9c3cf69f013aa98
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:47 2008 +0900

    libata: implement and use ata_noop_irq_clear()
    
    ->irq_clear() is used to clear IRQ bit of a SFF controller and isn't
    useful for drivers which don't use libata SFF HSM implementation.
    However, it's a required callback and many drivers implement their own
    noop version as placeholder.  This patch implements ata_noop_irq_clear
    and use it to replace those custom placeholders.
    
    Also, SFF drivers which don't support BMDMA don't need to use
    ata_bmdma_irq_clear().  It becomes noop if BMDMA address isn't
    initialized.  Convert them to use ata_noop_irq_clear().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 9476a479691b..639298af583e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -896,6 +896,7 @@ extern void ata_bmdma_start(struct ata_queued_cmd *qc);
 extern void ata_bmdma_stop(struct ata_queued_cmd *qc);
 extern u8   ata_bmdma_status(struct ata_port *ap);
 extern void ata_bmdma_irq_clear(struct ata_port *ap);
+extern void ata_noop_irq_clear(struct ata_port *ap);
 extern void ata_bmdma_freeze(struct ata_port *ap);
 extern void ata_bmdma_thaw(struct ata_port *ap);
 extern void ata_bmdma_drive_eh(struct ata_port *ap, ata_prereset_fn_t prereset,

commit c1bc899f5805771926c9198e2ab4d77122c356a1
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:47 2008 +0900

    libata: reorganize ata_port_operations
    
    Over the time, ops in ata_port_operations has become a bit confusing.
    Reorganize.  SFF/BMDMA ops are separated into separate a group as they
    will be taken out of ata_port_operations later.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index bc60132c7d33..9476a479691b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -665,69 +665,74 @@ struct ata_port {
 };
 
 struct ata_port_operations {
-	void (*dev_config) (struct ata_device *);
+	/*
+	 * Command execution
+	 */
+	int  (*qc_defer)(struct ata_queued_cmd *qc);
+	int  (*check_atapi_dma)(struct ata_queued_cmd *qc);
+	void (*qc_prep)(struct ata_queued_cmd *qc);
+	unsigned int (*qc_issue)(struct ata_queued_cmd *qc);
 
-	void (*set_piomode) (struct ata_port *, struct ata_device *);
-	void (*set_dmamode) (struct ata_port *, struct ata_device *);
-	unsigned long (*mode_filter) (struct ata_device *, unsigned long);
+	/*
+	 * Configuration and exception handling
+	 */
+	int  (*cable_detect)(struct ata_port *ap);
+	unsigned long (*mode_filter)(struct ata_device *dev, unsigned long xfer_mask);
+	void (*set_piomode)(struct ata_port *ap, struct ata_device *dev);
+	void (*set_dmamode)(struct ata_port *ap, struct ata_device *dev);
+	int  (*set_mode)(struct ata_link *link, struct ata_device **r_failed_dev);
 
-	void (*tf_load) (struct ata_port *ap, const struct ata_taskfile *tf);
-	void (*tf_read) (struct ata_port *ap, struct ata_taskfile *tf);
+	void (*dev_config)(struct ata_device *dev);
 
-	void (*exec_command)(struct ata_port *ap, const struct ata_taskfile *tf);
+	void (*freeze)(struct ata_port *ap);
+	void (*thaw)(struct ata_port *ap);
+	void (*error_handler)(struct ata_port *ap);
+	void (*post_internal_cmd)(struct ata_queued_cmd *qc);
+
+	/*
+	 * Optional features
+	 */
+	int  (*scr_read)(struct ata_port *ap, unsigned int sc_reg, u32 *val);
+	int  (*scr_write)(struct ata_port *ap, unsigned int sc_reg, u32 val);
+	void (*pmp_attach)(struct ata_port *ap);
+	void (*pmp_detach)(struct ata_port *ap);
+	int  (*enable_pm)(struct ata_port *ap, enum link_pm policy);
+	void (*disable_pm)(struct ata_port *ap);
+
+	/*
+	 * Start, stop, suspend and resume
+	 */
+	int  (*port_suspend)(struct ata_port *ap, pm_message_t mesg);
+	int  (*port_resume)(struct ata_port *ap);
+	int  (*port_start)(struct ata_port *ap);
+	void (*port_stop)(struct ata_port *ap);
+	void (*host_stop)(struct ata_host *host);
+
+	/*
+	 * SFF / taskfile oriented ops
+	 */
+	void (*dev_select)(struct ata_port *ap, unsigned int device);
 	u8   (*check_status)(struct ata_port *ap);
 	u8   (*check_altstatus)(struct ata_port *ap);
-	void (*dev_select)(struct ata_port *ap, unsigned int device);
-
-	void (*phy_reset) (struct ata_port *ap); /* obsolete */
-	int  (*set_mode) (struct ata_link *link, struct ata_device **r_failed_dev);
-
-	int (*cable_detect) (struct ata_port *ap);
-
-	int  (*check_atapi_dma) (struct ata_queued_cmd *qc);
-
-	void (*bmdma_setup) (struct ata_queued_cmd *qc);
-	void (*bmdma_start) (struct ata_queued_cmd *qc);
-
-	unsigned int (*data_xfer) (struct ata_device *dev, unsigned char *buf,
-				   unsigned int buflen, int rw);
-
-	int (*qc_defer) (struct ata_queued_cmd *qc);
-	void (*qc_prep) (struct ata_queued_cmd *qc);
-	unsigned int (*qc_issue) (struct ata_queued_cmd *qc);
-
-	/* port multiplier */
-	void (*pmp_attach) (struct ata_port *ap);
-	void (*pmp_detach) (struct ata_port *ap);
-
-	/* Error handlers.  ->error_handler overrides ->eng_timeout and
-	 * indicates that new-style EH is in place.
+	void (*tf_load)(struct ata_port *ap, const struct ata_taskfile *tf);
+	void (*tf_read)(struct ata_port *ap, struct ata_taskfile *tf);
+	void (*exec_command)(struct ata_port *ap, const struct ata_taskfile *tf);
+	unsigned int (*data_xfer)(struct ata_device *dev, unsigned char *buf,
+				  unsigned int buflen, int rw);
+	u8   (*irq_on)(struct ata_port *);
+
+	void (*irq_clear)(struct ata_port *);
+	void (*bmdma_setup)(struct ata_queued_cmd *qc);
+	void (*bmdma_start)(struct ata_queued_cmd *qc);
+	void (*bmdma_stop)(struct ata_queued_cmd *qc);
+	u8   (*bmdma_status)(struct ata_port *ap);
+
+	/*
+	 * Obsolete
 	 */
-	void (*eng_timeout) (struct ata_port *ap); /* obsolete */
-
-	void (*freeze) (struct ata_port *ap);
-	void (*thaw) (struct ata_port *ap);
-	void (*error_handler) (struct ata_port *ap);
-	void (*post_internal_cmd) (struct ata_queued_cmd *qc);
-
+	void (*phy_reset)(struct ata_port *ap);
+	void (*eng_timeout)(struct ata_port *ap);
 	irq_handler_t irq_handler;
-	void (*irq_clear) (struct ata_port *);
-	u8 (*irq_on) (struct ata_port *);
-
-	int (*scr_read) (struct ata_port *ap, unsigned int sc_reg, u32 *val);
-	int (*scr_write) (struct ata_port *ap, unsigned int sc_reg, u32 val);
-
-	int (*port_suspend) (struct ata_port *ap, pm_message_t mesg);
-	int (*port_resume) (struct ata_port *ap);
-	int (*enable_pm) (struct ata_port *ap, enum link_pm policy);
-	void (*disable_pm) (struct ata_port *ap);
-	int (*port_start) (struct ata_port *ap);
-	void (*port_stop) (struct ata_port *ap);
-
-	void (*host_stop) (struct ata_host *host);
-
-	void (*bmdma_stop) (struct ata_queued_cmd *qc);
-	u8   (*bmdma_status) (struct ata_port *ap);
 };
 
 struct ata_port_info {

commit b558edddb1c42c70a30cfe494984d4be409f7b2b
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Jan 24 00:05:14 2008 +0900

    libata: kill ata_ehi_schedule_probe()
    
    ata_ehi_schedule_probe() was created to hide details of link-resuming
    reset magic.  Now that all the softreset workarounds are gone,
    scheduling probe is very simple - set probe_mask and request RESET.
    Kill ata_ehi_schedule_probe() and open code it.  This also increases
    consistency as ata_ehi_schedule_probe() couldn't cover individual
    device probings so they were open-coded even when the helper existed.
    
    While at it, define ATA_ALL_DEVICES as mask of all possible devices on
    a link and always use it when requesting probe on link level for
    simplicity and consistency.  Setting extra bits in the probe_mask
    doesn't hurt anybody.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6eec11957e54..bc60132c7d33 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -122,6 +122,8 @@ enum {
 
 	ATAPI_MAX_DRAIN		= 16 << 10,
 
+	ATA_ALL_DEVICES		= (1 << ATA_MAX_DEVICES) - 1,
+
 	ATA_SHT_EMULATED	= 1,
 	ATA_SHT_CMD_PER_LUN	= 1,
 	ATA_SHT_THIS_ID		= -1,
@@ -1089,17 +1091,11 @@ extern void ata_ehi_push_desc(struct ata_eh_info *ehi, const char *fmt, ...)
 	__attribute__ ((format (printf, 2, 3)));
 extern void ata_ehi_clear_desc(struct ata_eh_info *ehi);
 
-static inline void ata_ehi_schedule_probe(struct ata_eh_info *ehi)
-{
-	ehi->action |= ATA_EH_RESET;
-	ehi->probe_mask |= (1 << ATA_MAX_DEVICES) - 1;
-}
-
 static inline void ata_ehi_hotplugged(struct ata_eh_info *ehi)
 {
-	ata_ehi_schedule_probe(ehi);
+	ehi->probe_mask |= (1 << ATA_MAX_DEVICES) - 1;
 	ehi->flags |= ATA_EHI_HOTPLUGGED;
-	ehi->action |= ATA_EH_ENABLE_LINK;
+	ehi->action |= ATA_EH_RESET | ATA_EH_ENABLE_LINK;
 	ehi->err_mask |= AC_ERR_ATA_BUS;
 }
 

commit 8cebf274dd1c955a6e03385a85fd6569ce445946
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Jan 24 00:05:14 2008 +0900

    libata: kill ATA_LFLAG_SKIP_D2H_BSY
    
    Some controllers can't reliably record the initial D2H FIS after SATA
    link is brought online for whatever reason.  Advanced controllers
    which don't have traditional TF register based interface often have
    this problem as they don't really have the TF registers to update
    while the controller and link are being initialized.
    
    SKIP_D2H_BSY works around the problem by skipping the wait for device
    readiness before issuing SRST, so for such controllers libata issues
    SRST blindly and hopes for the best.
    
    Now that libata defaults to hardreset, this workaround is no longer
    necessary.  For controllers which have support for hardreset, SRST is
    never issued by itself.  It is only issued as follow-up SRST for
    device classification and PMP initialization, so there's no need to
    wait for it from prereset.
    
    Kill ATA_LFLAG_SKIP_D2H_BSY.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 4093e3b6a8b7..6eec11957e54 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -163,8 +163,6 @@ enum {
 	ATA_DEV_NONE		= 9,	/* no device */
 
 	/* struct ata_link flags */
-	ATA_LFLAG_SKIP_D2H_BSY	= (1 << 1), /* can't wait for the first D2H
-					     * Register FIS clearing BSY */
 	ATA_LFLAG_NO_SRST	= (1 << 2), /* avoid softreset */
 	ATA_LFLAG_ASSUME_ATA	= (1 << 3), /* assume ATA class */
 	ATA_LFLAG_ASSUME_SEMB	= (1 << 4), /* assume SEMB class */

commit 672b2d65ba83a6f3f801fd3d58851aa9c0725a54
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Jan 24 00:05:14 2008 +0900

    libata: kill ATA_EHI_RESUME_LINK
    
    ATA_EHI_RESUME_LINK has two functions - promote reset to hardreset if
    ATA_LFLAG_HRST_TO_RESUME is set and preventing EH from shortcutting
    reset action when probing is requested.  The former is gone now and
    the latter can easily be achieved by making EH to perform at least one
    reset if reset is requested, which also makes more sense than
    depending on RESUME_LINK flag.
    
    As ATA_EHI_RESUME_LINK was the only EHI reset modifier, this also
    kills reset modifier handling.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 1524af6f018b..4093e3b6a8b7 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -301,7 +301,6 @@ enum {
 
 	/* ata_eh_info->flags */
 	ATA_EHI_HOTPLUGGED	= (1 << 0),  /* could have been hotplugged */
-	ATA_EHI_RESUME_LINK	= (1 << 1),  /* resume link (reset modifier) */
 	ATA_EHI_NO_AUTOPSY	= (1 << 2),  /* no autopsy */
 	ATA_EHI_QUIET		= (1 << 3),  /* be quiet */
 
@@ -312,7 +311,6 @@ enum {
 	ATA_EHI_POST_SETMODE	= (1 << 20), /* revaildating after setmode */
 
 	ATA_EHI_DID_RESET	= ATA_EHI_DID_SOFTRESET | ATA_EHI_DID_HARDRESET,
-	ATA_EHI_RESET_MODIFIER_MASK = ATA_EHI_RESUME_LINK,
 
 	/* max tries if error condition is still set after ->error_handler */
 	ATA_EH_MAX_TRIES	= 5,
@@ -1095,7 +1093,6 @@ extern void ata_ehi_clear_desc(struct ata_eh_info *ehi);
 
 static inline void ata_ehi_schedule_probe(struct ata_eh_info *ehi)
 {
-	ehi->flags |= ATA_EHI_RESUME_LINK;
 	ehi->action |= ATA_EH_RESET;
 	ehi->probe_mask |= (1 << ATA_MAX_DEVICES) - 1;
 }

commit d692abd92f22a81b38d52c39601871003262841c
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Jan 24 00:05:14 2008 +0900

    libata: kill ATA_LFLAG_HRST_TO_RESUME
    
    Now that hardreset is the preferred method of resetting, there's no
    need for ATA_LFLAG_HRST_TO_RESUME flag.  Kill it.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c63cfb3b222b..1524af6f018b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -163,7 +163,6 @@ enum {
 	ATA_DEV_NONE		= 9,	/* no device */
 
 	/* struct ata_link flags */
-	ATA_LFLAG_HRST_TO_RESUME = (1 << 0), /* hardreset to resume link */
 	ATA_LFLAG_SKIP_D2H_BSY	= (1 << 1), /* can't wait for the first D2H
 					     * Register FIS clearing BSY */
 	ATA_LFLAG_NO_SRST	= (1 << 2), /* avoid softreset */

commit cf48062658e7ab3bc55e10c65676c3c73c16f8bf
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Jan 24 00:05:14 2008 +0900

    libata: prefer hardreset
    
    When both soft and hard resets are available, libata preferred
    softreset till now.  The logic behind it was to be softer to devices;
    however, this doesn't really help much.  Rationales for the change:
    
    * BIOS may freeze lock certain things during boot and softreset can't
      unlock those.  This by itself is okay but during operation PHY event
      or other error conditions can trigger hardreset and the device may
      end up with different configuration.
    
      For example, after a hardreset, previously unlockable HPA can be
      unlocked resulting in different device size and thus revalidation
      failure.  Similar condition can occur during or after resume.
    
    * Certain ATAPI devices require hardreset to recover after certain
      error conditions.  On PATA, this is done by issuing the DEVICE RESET
      command.  On SATA, COMRESET has equivalent effect.  The problem is
      that DEVICE RESET needs its own execution protocol.
    
      For SFF controllers with bare TF access, it can be easily
      implemented but more advanced controllers (e.g. ahci and sata_sil24)
      require specialized implementations.  Simply using hardreset solves
      the problem nicely.
    
    * COMRESET initialization sequence is the norm in SATA land and many
      SATA devices don't work properly if only SRST is used.  For example,
      some PMPs behave this way and libata works around by always issuing
      hardreset if the host supports PMP.
    
      Like the above example, libata has developed a number of mechanisms
      aiming to promote softreset to hardreset if softreset is not going
      to work.  This approach is time consuming and error prone.
    
      Also, note that, dependingon how you read the specs, it could be
      argued that PMP fan-out ports require COMRESET to start operation.
      In fact, all the PMPs on the market except one don't work properly
      if COMRESET is not issued to fan-out ports after PMP reset.
    
    * COMRESET is an integral part of SATA connection and any working
      device should be able to handle COMRESET properly.  After all, it's
      the way to signal hardreset during reboot.  This is the most used
      and recommended (at least by the ahci spec) method of resetting
      devices.
    
    So, this patch makes libata prefer hardreset over softreset by making
    the following changes.
    
    * Rename ATA_EH_RESET_MASK to ATA_EH_RESET and use it whereever
      ATA_EH_{SOFT|HARD}RESET used to be used.  ATA_EH_{SOFT|HARD}RESET is
      now only used to tell prereset whether soft or hard reset will be
      issued.
    
    * Strip out now unneeded promote-to-hardreset logics from
      ata_eh_reset(), ata_std_prereset(), sata_pmp_std_prereset() and
      other places.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 37ee881c42ac..c63cfb3b222b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -292,12 +292,12 @@ enum {
 
 	/* reset / recovery action types */
 	ATA_EH_REVALIDATE	= (1 << 0),
-	ATA_EH_SOFTRESET	= (1 << 1),
-	ATA_EH_HARDRESET	= (1 << 2),
+	ATA_EH_SOFTRESET	= (1 << 1), /* meaningful only in ->prereset */
+	ATA_EH_HARDRESET	= (1 << 2), /* meaningful only in ->prereset */
+	ATA_EH_RESET		= ATA_EH_SOFTRESET | ATA_EH_HARDRESET,
 	ATA_EH_ENABLE_LINK	= (1 << 3),
 	ATA_EH_LPM		= (1 << 4),  /* link power management action */
 
-	ATA_EH_RESET_MASK	= ATA_EH_SOFTRESET | ATA_EH_HARDRESET,
 	ATA_EH_PERDEV_MASK	= ATA_EH_REVALIDATE,
 
 	/* ata_eh_info->flags */
@@ -1097,7 +1097,7 @@ extern void ata_ehi_clear_desc(struct ata_eh_info *ehi);
 static inline void ata_ehi_schedule_probe(struct ata_eh_info *ehi)
 {
 	ehi->flags |= ATA_EHI_RESUME_LINK;
-	ehi->action |= ATA_EH_SOFTRESET;
+	ehi->action |= ATA_EH_RESET;
 	ehi->probe_mask |= (1 << ATA_MAX_DEVICES) - 1;
 }
 

commit e52dcc4899cf1b7601379c31542bd91cd2997a64
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Apr 2 17:35:19 2008 +0900

    libata: ATA_12/16 doesn't fall into ATAPI_MISC
    
    SAT passthrus don't really fit into ATAPI_MISC class.  SAT passthru
    commands always transfer multiple of 512 bytes and variable length
    response is not allowed.  This patch creates a separate category -
    ATAPI_PASS_THRU - for these.
    
    This fixes HSM violation on "hdparm -I".
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 92c64909ed25..37ee881c42ac 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -350,7 +350,8 @@ enum {
 	ATAPI_READ		= 0,		/* READs */
 	ATAPI_WRITE		= 1,		/* WRITEs */
 	ATAPI_READ_CD		= 2,		/* READ CD [MSF] */
-	ATAPI_MISC		= 3,		/* the rest */
+	ATAPI_PASS_THRU		= 3,		/* SAT pass-thru */
+	ATAPI_MISC		= 4,		/* the rest */
 };
 
 enum ata_xfer_mask {

commit 436d34b36202ef724778ded1e9cb10f8c37b32bc
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Apr 2 17:28:46 2008 +0900

    libata: uninline atapi_cmd_type()
    
    Uninline atapi_cmd_type().  It doesn't really have to be inline and
    more case will be added which need to access unexported libata
    variable.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b064bfeb69ee..92c64909ed25 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -849,6 +849,7 @@ extern unsigned int ata_dev_try_classify(struct ata_device *dev, int present,
  */
 extern void ata_tf_load(struct ata_port *ap, const struct ata_taskfile *tf);
 extern void ata_tf_read(struct ata_port *ap, struct ata_taskfile *tf);
+extern int atapi_cmd_type(u8 opcode);
 extern void ata_tf_to_fis(const struct ata_taskfile *tf,
 			  u8 pmp, int is_cmd, u8 *fis);
 extern void ata_tf_from_fis(const u8 *fis, struct ata_taskfile *tf);
@@ -1379,27 +1380,6 @@ static inline int ata_try_flush_cache(const struct ata_device *dev)
 	       ata_id_has_flush_ext(dev->id);
 }
 
-static inline int atapi_cmd_type(u8 opcode)
-{
-	switch (opcode) {
-	case GPCMD_READ_10:
-	case GPCMD_READ_12:
-		return ATAPI_READ;
-
-	case GPCMD_WRITE_10:
-	case GPCMD_WRITE_12:
-	case GPCMD_WRITE_AND_VERIFY_10:
-		return ATAPI_WRITE;
-
-	case GPCMD_READ_CD:
-	case GPCMD_READ_CD_MSF:
-		return ATAPI_READ_CD;
-
-	default:
-		return ATAPI_MISC;
-	}
-}
-
 static inline unsigned int ac_err_mask(u8 status)
 {
 	if (status & (ATA_BUSY | ATA_DRQ))

commit 3ec25ebd69dc120d0590e64caaf1477aa88c8a93
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Mar 27 18:37:14 2008 +0900

    libata: ATA_EHI_LPM should be ATA_EH_LPM
    
    EH actions are ATA_EH_* not ATA_EHI_*.  Rename ATA_EHI_LPM to
    ATA_EH_LPM.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 269cdba09578..b064bfeb69ee 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -295,6 +295,7 @@ enum {
 	ATA_EH_SOFTRESET	= (1 << 1),
 	ATA_EH_HARDRESET	= (1 << 2),
 	ATA_EH_ENABLE_LINK	= (1 << 3),
+	ATA_EH_LPM		= (1 << 4),  /* link power management action */
 
 	ATA_EH_RESET_MASK	= ATA_EH_SOFTRESET | ATA_EH_HARDRESET,
 	ATA_EH_PERDEV_MASK	= ATA_EH_REVALIDATE,
@@ -304,7 +305,6 @@ enum {
 	ATA_EHI_RESUME_LINK	= (1 << 1),  /* resume link (reset modifier) */
 	ATA_EHI_NO_AUTOPSY	= (1 << 2),  /* no autopsy */
 	ATA_EHI_QUIET		= (1 << 3),  /* be quiet */
-	ATA_EHI_LPM		= (1 << 4),  /* link power management action */
 
 	ATA_EHI_DID_SOFTRESET	= (1 << 16), /* already soft-reset this port */
 	ATA_EHI_DID_HARDRESET	= (1 << 17), /* already soft-reset this port */

commit aacda37538e7f9cf2148eedf3766239829e51ba4
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 18 17:47:43 2008 +0900

    libata: implement ata_qc_raw_nbytes()
    
    Implement ata_qc_raw_nbytes() which determines the raw user-requested
    size of a PC command.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a05f60013642..269cdba09578 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -463,6 +463,7 @@ struct ata_queued_cmd {
 	unsigned int		sect_size;
 
 	unsigned int		nbytes;
+	unsigned int		extrabytes;
 	unsigned int		curbytes;
 
 	struct scatterlist	*cursg;
@@ -1336,6 +1337,11 @@ static inline struct ata_queued_cmd *ata_qc_from_tag(struct ata_port *ap,
 	return NULL;
 }
 
+static inline unsigned int ata_qc_raw_nbytes(struct ata_queued_cmd *qc)
+{
+	return qc->nbytes - min(qc->extrabytes, qc->nbytes);
+}
+
 static inline void ata_tf_init(struct ata_device *dev, struct ata_taskfile *tf)
 {
 	memset(tf, 0, sizeof(*tf));
@@ -1354,7 +1360,7 @@ static inline void ata_qc_reinit(struct ata_queued_cmd *qc)
 	qc->flags = 0;
 	qc->cursg = NULL;
 	qc->cursg_ofs = 0;
-	qc->nbytes = qc->curbytes = 0;
+	qc->nbytes = qc->extrabytes = qc->curbytes = 0;
 	qc->n_elem = 0;
 	qc->err_mask = 0;
 	qc->sect_size = ATA_SECT_SIZE;

commit 9116300634c5c76cfcd0d2af689846e04d172256
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Feb 21 13:25:50 2008 +0900

    libata: automatically use DMADIR if drive/bridge requires it
    
    Back in 2.6.17-rc2, a libata module parameter was added for atapi_dmadir.
    
    That's nice, but most SATA devices which need it will tell us about it
    in their IDENTIFY PACKET response, as bit-15 of word-62 of the
    returned data (as per ATA7, ATA8 specifications).
    
    So for those which specify it, we should automatically use the DMADIR bit.
    Otherwise, disc writing will fail by default on many SATA-ATAPI drives.
    
    This patch adds ATA_DFLAG_DMADIR and make ata_dev_configure() set it
    if atapi_dmadir is set or identify data indicates DMADIR is necessary.
    atapi_xlat() is converted to check ATA_DFLAG_DMADIR before setting
    DMADIR.
    
    Original patch is from Mark Lord.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Mark Lord <mlord@pobox.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ce7603a73156..a05f60013642 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -138,6 +138,7 @@ enum {
 	ATA_DFLAG_AN		= (1 << 7), /* AN configured */
 	ATA_DFLAG_HIPM		= (1 << 8), /* device supports HIPM */
 	ATA_DFLAG_DIPM		= (1 << 9), /* device supports DIPM */
+	ATA_DFLAG_DMADIR	= (1 << 10), /* device requires DMADIR */
 	ATA_DFLAG_CFG_MASK	= (1 << 12) - 1,
 
 	ATA_DFLAG_PIO		= (1 << 12), /* device limited to PIO mode */

commit 5d44b414daa8c1d8551aed6130d86d54175db43f
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Fri Feb 15 13:41:32 2008 -0800

    ata: fix sparse warning in libata.h
    
    Avoids lots of these, also is more readable.
    include/linux/libata.h:1210:13: warning: potentially expensive pointer subtraction
    
    Change the subtraction to addition on the other side of the comparison.
    
    Thanks to Christer Weinigel for the suggestion.
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Acked-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 2e098f940cec..ce7603a73156 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1197,7 +1197,7 @@ static inline struct ata_link *ata_port_next_link(struct ata_link *link)
 		return ap->pmp_link;
 	}
 
-	if (++link - ap->pmp_link < ap->nr_pmp_links)
+	if (++link < ap->nr_pmp_links + ap->pmp_link)
 		return link;
 	return NULL;
 }

commit dde2020754aeb14e17052d61784dcb37f252aac2
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Feb 19 11:36:56 2008 +0100

    libata: eliminate the home grown dma padding in favour of
    
    that provided by the block layer
    
    ATA requires that all DMA transfers begin and end on word boundaries.
    Because of this, a large amount of machinery grew up in ide to adjust
    scatterlists on this basis.  However, as of 2.5, the block layer has a
    dma_alignment variable which ensures both the beginning and length of a
    DMA transfer are aligned on the dma_alignment boundary.  Although the
    block layer does adjust the beginning of the transfer to ensure this
    happens, it doesn't actually adjust the length, it merely makes sure
    that space is allocated for transfers beyond the declared length.  The
    upshot of this is that scatterlists may be padded to any size between
    the actual length and the length adjusted to the dma_alignment safely
    knowing that memory is allocated in this region.
    
    Right at the moment, SCSI takes the default dma_aligment which is on a
    512 byte boundary.  Note that this aligment only applies to transfers
    coming in from user space.  However, since all kernel allocations are
    automatically aligned on a minimum of 32 byte boundaries, it is safe to
    adjust them in this manner as well.
    
    tj: * Adjusting sg after padding is done in block layer.  Make libata
          set queue alignment correctly for ATAPI devices and drop broken
          sg mangling from ata_sg_setup().
        * Use request->raw_data_len for ATAPI transfer chunk size.
        * Killed qc->raw_nbytes.
        * Separated out killing qc->n_iter.
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index bc5a8d0c7090..2e098f940cec 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -278,7 +278,6 @@ enum {
 
 	/* size of buffer to pad xfers ending on unaligned boundaries */
 	ATA_DMA_PAD_SZ		= 4,
-	ATA_DMA_PAD_BUF_SZ	= ATA_DMA_PAD_SZ * ATA_MAX_QUEUE,
 
 	/* ering size */
 	ATA_ERING_SIZE		= 32,
@@ -457,24 +456,18 @@ struct ata_queued_cmd {
 	unsigned long		flags;		/* ATA_QCFLAG_xxx */
 	unsigned int		tag;
 	unsigned int		n_elem;
-	unsigned int		mapped_n_elem;
 
 	int			dma_dir;
 
-	unsigned int		pad_len;
 	unsigned int		sect_size;
 
 	unsigned int		nbytes;
-	unsigned int		raw_nbytes;
 	unsigned int		curbytes;
 
 	struct scatterlist	*cursg;
 	unsigned int		cursg_ofs;
 
-	struct scatterlist	*last_sg;
-	struct scatterlist	saved_last_sg;
 	struct scatterlist	sgent;
-	struct scatterlist	extra_sg[2];
 
 	struct scatterlist	*sg;
 
@@ -619,9 +612,6 @@ struct ata_port {
 	struct ata_prd		*prd;	 /* our SG list */
 	dma_addr_t		prd_dma; /* and its DMA mapping */
 
-	void			*pad;	/* array of DMA pad buffers */
-	dma_addr_t		pad_dma;
-
 	struct ata_ioports	ioaddr;	/* ATA cmd/ctl/dma register blocks */
 
 	u8			ctl;	/* cache of ATA control register */
@@ -1363,12 +1353,9 @@ static inline void ata_qc_reinit(struct ata_queued_cmd *qc)
 	qc->flags = 0;
 	qc->cursg = NULL;
 	qc->cursg_ofs = 0;
-	qc->nbytes = qc->raw_nbytes = qc->curbytes = 0;
+	qc->nbytes = qc->curbytes = 0;
 	qc->n_elem = 0;
-	qc->mapped_n_elem = 0;
 	qc->err_mask = 0;
-	qc->pad_len = 0;
-	qc->last_sg = NULL;
 	qc->sect_size = ATA_SECT_SIZE;
 
 	ata_tf_init(qc->dev, &qc->tf);
@@ -1423,19 +1410,6 @@ static inline unsigned int __ac_err_mask(u8 status)
 	return mask;
 }
 
-static inline int ata_pad_alloc(struct ata_port *ap, struct device *dev)
-{
-	ap->pad_dma = 0;
-	ap->pad = dmam_alloc_coherent(dev, ATA_DMA_PAD_BUF_SZ,
-				      &ap->pad_dma, GFP_KERNEL);
-	return (ap->pad == NULL) ? -ENOMEM : 0;
-}
-
-static inline void ata_pad_free(struct ata_port *ap, struct device *dev)
-{
-	dmam_free_coherent(dev, ATA_DMA_PAD_BUF_SZ, ap->pad, ap->pad_dma);
-}
-
 static inline struct ata_port *ata_shost_to_port(struct Scsi_Host *host)
 {
 	return *(struct ata_port **)&host->hostdata[0];

commit 37198e3051b63d3184886e9bb8235e7578e82628
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Feb 5 14:06:27 2008 +0900

    libata: kill now unused n_iter and fix sata_fsl
    
    qc->n_iter was used for libata's own sg walking before sg chaining
    replaced it.  During conversion, the field and its usage in sata_fsl
    were left behind.  Kill the filed and update sata_fsl.
    
    tj: This was part of James's libata-use-block-layer-padding patch.
        Separated out by me.
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Li Yang <leoli@freescale.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 4374c4277780..bc5a8d0c7090 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -457,7 +457,6 @@ struct ata_queued_cmd {
 	unsigned long		flags;		/* ATA_QCFLAG_xxx */
 	unsigned int		tag;
 	unsigned int		n_elem;
-	unsigned int		n_iter;
 	unsigned int		mapped_n_elem;
 
 	int			dma_dir;
@@ -1367,7 +1366,6 @@ static inline void ata_qc_reinit(struct ata_queued_cmd *qc)
 	qc->nbytes = qc->raw_nbytes = qc->curbytes = 0;
 	qc->n_elem = 0;
 	qc->mapped_n_elem = 0;
-	qc->n_iter = 0;
 	qc->err_mask = 0;
 	qc->pad_len = 0;
 	qc->last_sg = NULL;

commit 4e6b79fa61091a0ed9b0af0f573cc257772cd88d
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Jan 18 18:36:28 2008 +0900

    libata: factor out ata_pci_activate_sff_host() from ata_pci_one()
    
    Factor out ata_pci_activate_sff_host() from ata_pci_one().  This does
    about the same thing as ata_host_activate() but needs to be separate
    because SFF controllers use different and multiple IRQs in legacy
    mode.
    
    This will be used to make SFF LLD initialization more flexible.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ccb055636f37..4374c4277780 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1033,6 +1033,9 @@ extern int ata_pci_init_bmdma(struct ata_host *host);
 extern int ata_pci_prepare_sff_host(struct pci_dev *pdev,
 				    const struct ata_port_info * const * ppi,
 				    struct ata_host **r_host);
+extern int ata_pci_activate_sff_host(struct ata_host *host,
+				     irq_handler_t irq_handler,
+				     struct scsi_host_template *sht);
 extern int pci_test_config_bits(struct pci_dev *pdev, const struct pci_bits *bits);
 extern unsigned long ata_pci_default_filter(struct ata_device *dev,
 					    unsigned long xfer_mask);

commit 442eacc362c2576aac8ebfd41b99252e28e0f49c
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Dec 19 04:25:10 2007 -0500

    libata: make ata_port_queue_task() an internal function
    
    ata_port_queue_task() served a single user:  ata_pio_task()
    
    Rename to ata_pio_queue_task() and un-export it, as nobody outside of
    libata-core.c uses it.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 7b7c78e42077..ccb055636f37 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -847,8 +847,6 @@ extern int ata_busy_sleep(struct ata_port *ap,
 			  unsigned long timeout_pat, unsigned long timeout);
 extern void ata_wait_after_reset(struct ata_port *ap, unsigned long deadline);
 extern int ata_wait_ready(struct ata_port *ap, unsigned long deadline);
-extern void ata_port_queue_task(struct ata_port *ap, work_func_t fn,
-				void *data, unsigned long delay);
 extern u32 ata_wait_register(void __iomem *reg, u32 mask, u32 val,
 			     unsigned long interval_msec,
 			     unsigned long timeout_msec);

commit 0bcc65ad78ae517de16b2ca07a2891f49d44d156
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Dec 5 16:43:12 2007 +0900

    libata: make qc->nbytes include extra buffers
    
    qc->nbytes didn't use to include extra buffers setup by libata core
    layer and my be odd.  This patch makes qc->nbytes include any extra
    buffers setup by libata core layer and guaranteed to be aligned on 4
    byte boundary.
    
    This value is to be used to program the host controller.  As this
    represents the actual length of buffer available to the controller and
    the controller must be able to deal with short transfers for ATAPI
    commands which can transfer variable length, this shouldn't break any
    controllers while making problems like rounding-down and controllers
    choking up on odd transfer bytes much less likely.
    
    The unmodified value is stored in new field qc->raw_nbytes.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 162f8b5509ac..7b7c78e42077 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -466,6 +466,7 @@ struct ata_queued_cmd {
 	unsigned int		sect_size;
 
 	unsigned int		nbytes;
+	unsigned int		raw_nbytes;
 	unsigned int		curbytes;
 
 	struct scatterlist	*cursg;
@@ -1362,7 +1363,7 @@ static inline void ata_qc_reinit(struct ata_queued_cmd *qc)
 	qc->flags = 0;
 	qc->cursg = NULL;
 	qc->cursg_ofs = 0;
-	qc->nbytes = qc->curbytes = 0;
+	qc->nbytes = qc->raw_nbytes = qc->curbytes = 0;
 	qc->n_elem = 0;
 	qc->mapped_n_elem = 0;
 	qc->n_iter = 0;

commit ff2aeb1eb64c8a4770a6304f9addbae9f9828646
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Dec 5 16:43:11 2007 +0900

    libata: convert to chained sg
    
    libata used private sg iterator to handle padding sg.  Now that sg can
    be chained, padding can be handled using standard sg ops.  Convert to
    chained sg.
    
    * s/qc->__sg/qc->sg/
    
    * s/qc->pad_sgent/qc->extra_sg[]/.  Because chaining consumes one sg
      entry.  There need to be two extra sg entries.  The renaming is also
      for future addition of other extra sg entries.
    
    * Padding setup is moved into ata_sg_setup_extra() which is organized
      in a way that future addition of other extra sg entries is easy.
    
    * qc->orig_n_elem is unused and removed.
    
    * qc->n_elem now contains the number of sg entries that LLDs should
      map.  qc->mapped_n_elem is added to carry the original number of
      mapped sgs for unmapping.
    
    * The last sg of the original sg list is used to chain to extra sg
      list.  The original last sg is pointed to by qc->last_sg and the
      content is stored in qc->saved_last_sg.  It's restored during
      ata_sg_clean().
    
    * All sg walking code has been updated.  Unnecessary assertions and
      checks for conditions the core layer already guarantees are removed.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index acd90ad78417..162f8b5509ac 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -458,7 +458,7 @@ struct ata_queued_cmd {
 	unsigned int		tag;
 	unsigned int		n_elem;
 	unsigned int		n_iter;
-	unsigned int		orig_n_elem;
+	unsigned int		mapped_n_elem;
 
 	int			dma_dir;
 
@@ -471,11 +471,12 @@ struct ata_queued_cmd {
 	struct scatterlist	*cursg;
 	unsigned int		cursg_ofs;
 
+	struct scatterlist	*last_sg;
+	struct scatterlist	saved_last_sg;
 	struct scatterlist	sgent;
-	struct scatterlist	pad_sgent;
+	struct scatterlist	extra_sg[2];
 
-	/* DO NOT iterate over __sg manually, use ata_for_each_sg() */
-	struct scatterlist	*__sg;
+	struct scatterlist	*sg;
 
 	unsigned int		err_mask;
 	struct ata_taskfile	result_tf;
@@ -1123,35 +1124,6 @@ extern void ata_port_pbar_desc(struct ata_port *ap, int bar, ssize_t offset,
 			       const char *name);
 #endif
 
-/*
- * qc helpers
- */
-static inline struct scatterlist *
-ata_qc_first_sg(struct ata_queued_cmd *qc)
-{
-	qc->n_iter = 0;
-	if (qc->n_elem)
-		return qc->__sg;
-	if (qc->pad_len)
-		return &qc->pad_sgent;
-	return NULL;
-}
-
-static inline struct scatterlist *
-ata_qc_next_sg(struct scatterlist *sg, struct ata_queued_cmd *qc)
-{
-	if (sg == &qc->pad_sgent)
-		return NULL;
-	if (++qc->n_iter < qc->n_elem)
-		return sg_next(sg);
-	if (qc->pad_len)
-		return &qc->pad_sgent;
-	return NULL;
-}
-
-#define ata_for_each_sg(sg, qc) \
-	for (sg = ata_qc_first_sg(qc); sg; sg = ata_qc_next_sg(sg, qc))
-
 static inline unsigned int ata_tag_valid(unsigned int tag)
 {
 	return (tag < ATA_MAX_QUEUE) ? 1 : 0;
@@ -1386,15 +1358,17 @@ static inline void ata_tf_init(struct ata_device *dev, struct ata_taskfile *tf)
 static inline void ata_qc_reinit(struct ata_queued_cmd *qc)
 {
 	qc->dma_dir = DMA_NONE;
-	qc->__sg = NULL;
+	qc->sg = NULL;
 	qc->flags = 0;
 	qc->cursg = NULL;
 	qc->cursg_ofs = 0;
 	qc->nbytes = qc->curbytes = 0;
 	qc->n_elem = 0;
+	qc->mapped_n_elem = 0;
 	qc->n_iter = 0;
 	qc->err_mask = 0;
 	qc->pad_len = 0;
+	qc->last_sg = NULL;
 	qc->sect_size = ATA_SECT_SIZE;
 
 	ata_tf_init(qc->dev, &qc->tf);

commit 001102d7859be0e7f7b9f2d62b841f2c0f9c2640
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Dec 5 16:43:09 2007 +0900

    libata: kill non-sg DMA interface
    
    With atapi_request_sense() converted to use sg, there's no user of
    non-sg interface.  Kill non-sg interface.
    
    * ATA_QCFLAG_SINGLE and ATA_QCFLAG_SG are removed.  ATA_QCFLAG_DMAMAP
      is used instead.  (this way no LLD change is necessary)
    
    * qc->buf_virt is removed.
    
    * ata_sg_init_one() and ata_sg_setup_one() are removed.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Rusty Russel <rusty@rustcorp.com.au>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 7fa96cb4f6db..acd90ad78417 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -219,9 +219,7 @@ enum {
 
 	/* struct ata_queued_cmd flags */
 	ATA_QCFLAG_ACTIVE	= (1 << 0), /* cmd not yet ack'd to scsi lyer */
-	ATA_QCFLAG_SG		= (1 << 1), /* have s/g table? */
-	ATA_QCFLAG_SINGLE	= (1 << 2), /* no s/g, just a single buffer */
-	ATA_QCFLAG_DMAMAP	= ATA_QCFLAG_SG | ATA_QCFLAG_SINGLE,
+	ATA_QCFLAG_DMAMAP	= (1 << 1), /* SG table is DMA mapped */
 	ATA_QCFLAG_IO		= (1 << 3), /* standard IO command */
 	ATA_QCFLAG_RESULT_TF	= (1 << 4), /* result TF requested */
 	ATA_QCFLAG_CLEAR_EXCL	= (1 << 5), /* clear excl_link on completion */
@@ -475,7 +473,6 @@ struct ata_queued_cmd {
 
 	struct scatterlist	sgent;
 	struct scatterlist	pad_sgent;
-	void			*buf_virt;
 
 	/* DO NOT iterate over __sg manually, use ata_for_each_sg() */
 	struct scatterlist	*__sg;
@@ -891,8 +888,6 @@ extern void ata_dumb_qc_prep(struct ata_queued_cmd *qc);
 extern void ata_qc_prep(struct ata_queued_cmd *qc);
 extern void ata_noop_qc_prep(struct ata_queued_cmd *qc);
 extern unsigned int ata_qc_issue_prot(struct ata_queued_cmd *qc);
-extern void ata_sg_init_one(struct ata_queued_cmd *qc, void *buf,
-		unsigned int buflen);
 extern void ata_sg_init(struct ata_queued_cmd *qc, struct scatterlist *sg,
 		 unsigned int n_elem);
 extern unsigned int ata_dev_classify(const struct ata_taskfile *tf);

commit 55dba3120fbcbea6800f9a18503d25f73212a347
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Dec 5 16:43:07 2007 +0900

    libata: update ->data_xfer hook for ATAPI
    
    Depending on how many bytes are transferred as a unit, PIO data
    transfer may consume more bytes than requested.  Knowing how much
    data is consumed is necessary to determine how much is left for
    draining.  This patch update ->data_xfer such that it returns the
    number of consumed bytes.
    
    While at it, it also makes the following changes.
    
    * s/adev/dev/
    * use READ/WRITE constants for rw indication
    * misc clean ups
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 03afcd63202d..7fa96cb4f6db 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -701,7 +701,8 @@ struct ata_port_operations {
 	void (*bmdma_setup) (struct ata_queued_cmd *qc);
 	void (*bmdma_start) (struct ata_queued_cmd *qc);
 
-	void (*data_xfer) (struct ata_device *, unsigned char *, unsigned int, int);
+	unsigned int (*data_xfer) (struct ata_device *dev, unsigned char *buf,
+				   unsigned int buflen, int rw);
 
 	int (*qc_defer) (struct ata_queued_cmd *qc);
 	void (*qc_prep) (struct ata_queued_cmd *qc);
@@ -881,10 +882,10 @@ extern void ata_exec_command(struct ata_port *ap, const struct ata_taskfile *tf)
 extern int ata_port_start(struct ata_port *ap);
 extern int ata_sff_port_start(struct ata_port *ap);
 extern irqreturn_t ata_interrupt(int irq, void *dev_instance);
-extern void ata_data_xfer(struct ata_device *adev, unsigned char *buf,
-			  unsigned int buflen, int write_data);
-extern void ata_data_xfer_noirq(struct ata_device *adev, unsigned char *buf,
-				unsigned int buflen, int write_data);
+extern unsigned int ata_data_xfer(struct ata_device *dev,
+			unsigned char *buf, unsigned int buflen, int rw);
+extern unsigned int ata_data_xfer_noirq(struct ata_device *dev,
+			unsigned char *buf, unsigned int buflen, int rw);
 extern int ata_std_qc_defer(struct ata_queued_cmd *qc);
 extern void ata_dumb_qc_prep(struct ata_queued_cmd *qc);
 extern void ata_qc_prep(struct ata_queued_cmd *qc);

commit ceb0c642624f634c5b4f46b0e22df19be87a2e53
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Dec 5 16:43:06 2007 +0900

    libata: add ATAPI_* cmd types and implement atapi_cmd_type()
    
    Add ATAPI command types - ATAPI_READ, WRITE, RW_BUF, READ_CD and MISC,
    and implement atapi_cmd_type() which takes SCSI opcode and returns to
    which class the opcode belongs.  This will be used later to improve
    ATAPI handling.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index cc4eaef6f889..03afcd63202d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -35,6 +35,7 @@
 #include <linux/workqueue.h>
 #include <scsi/scsi_host.h>
 #include <linux/acpi.h>
+#include <linux/cdrom.h>
 
 /*
  * Define if arch has non-standard setup.  This is a _PCI_ standard
@@ -346,6 +347,12 @@ enum {
 	ATA_DMA_MASK_ATA	= (1 << 0),	/* DMA on ATA Disk */
 	ATA_DMA_MASK_ATAPI	= (1 << 1),	/* DMA on ATAPI */
 	ATA_DMA_MASK_CFA	= (1 << 2),	/* DMA on CF Card */
+
+	/* ATAPI command types */
+	ATAPI_READ		= 0,		/* READs */
+	ATAPI_WRITE		= 1,		/* WRITEs */
+	ATAPI_READ_CD		= 2,		/* READ CD [MSF] */
+	ATAPI_MISC		= 3,		/* the rest */
 };
 
 enum ata_xfer_mask {
@@ -1408,6 +1415,27 @@ static inline int ata_try_flush_cache(const struct ata_device *dev)
 	       ata_id_has_flush_ext(dev->id);
 }
 
+static inline int atapi_cmd_type(u8 opcode)
+{
+	switch (opcode) {
+	case GPCMD_READ_10:
+	case GPCMD_READ_12:
+		return ATAPI_READ;
+
+	case GPCMD_WRITE_10:
+	case GPCMD_WRITE_12:
+	case GPCMD_WRITE_AND_VERIFY_10:
+		return ATAPI_WRITE;
+
+	case GPCMD_READ_CD:
+	case GPCMD_READ_CD_MSF:
+		return ATAPI_READ_CD;
+
+	default:
+		return ATAPI_MISC;
+	}
+}
+
 static inline unsigned int ac_err_mask(u8 status)
 {
 	if (status & (ATA_BUSY | ATA_DRQ))

commit 021ee9a6da1cfc57f6a6c769c3c898bdd4753108
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Dec 18 16:33:06 2007 +0900

    libata: reimplement ata_acpi_cbl_80wire() using ata_acpi_gtm_xfermask()
    
    Reimplement ata_acpi_cbl_80wire() using ata_acpi_gtm_xfermask() and
    while at it relocate the function below ata_acpi_gtm_xfermask().
    
    New ata_acpi_cbl_80wire() implementation takes @gtm, in both pata_via
    and pata_amd, use the initial GTM value.  Both are trying to peek
    initial BIOS configuration, so using initial caching value makes
    sense.  This fixes ACPI part of cable detection in pata_amd which
    previously always returned 0 because configuring PIO0 during reset
    clears DMA configuration.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 8ede93b5c7a6..cc4eaef6f889 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -968,18 +968,16 @@ static inline const struct ata_acpi_gtm *ata_acpi_init_gtm(struct ata_port *ap)
 		return &ap->__acpi_init_gtm;
 	return NULL;
 }
-extern int ata_acpi_cbl_80wire(struct ata_port *ap);
 int ata_acpi_stm(struct ata_port *ap, const struct ata_acpi_gtm *stm);
 int ata_acpi_gtm(struct ata_port *ap, struct ata_acpi_gtm *stm);
 unsigned long ata_acpi_gtm_xfermask(struct ata_device *dev,
 				    const struct ata_acpi_gtm *gtm);
-
+int ata_acpi_cbl_80wire(struct ata_port *ap, const struct ata_acpi_gtm *gtm);
 #else
 static inline const struct ata_acpi_gtm *ata_acpi_init_gtm(struct ata_port *ap)
 {
 	return NULL;
 }
-static inline int ata_acpi_cbl_80wire(struct ata_port *ap) { return 0; }
 
 static inline int ata_acpi_stm(const struct ata_port *ap,
 			       struct ata_acpi_gtm *stm)
@@ -998,6 +996,12 @@ static inline unsigned int ata_acpi_gtm_xfermask(struct ata_device *dev,
 {
 	return 0;
 }
+
+static inline int ata_acpi_cbl_80wire(struct ata_port *ap,
+				      const struct ata_acpi_gtm *gtm)
+{
+	return 0;
+}
 #endif
 
 #ifdef CONFIG_PCI

commit a0f79b929acaba10d4780acd2543eff20bf4b5b0
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Dec 18 16:33:05 2007 +0900

    libata: implement ata_timing_cycle2mode() and use it in libata-acpi and pata_acpi
    
    libata-acpi is using separate timing tables for transfer modes
    although libata-core has the complete ata_timing table.  Implement
    ata_timing_cycle2mode() to look for matching mode given transfer type
    and cycle duration and use it in libata-acpi and pata_acpi to replace
    private timing tables.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 8022e5b2224d..8ede93b5c7a6 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -941,6 +941,7 @@ extern int ata_timing_compute(struct ata_device *, unsigned short,
 extern void ata_timing_merge(const struct ata_timing *,
 			     const struct ata_timing *, struct ata_timing *,
 			     unsigned int);
+extern u8 ata_timing_cycle2mode(unsigned int xfer_shift, int cycle);
 
 enum {
 	ATA_TIMING_SETUP	= (1 << 0),
@@ -961,10 +962,6 @@ enum {
 
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI
-extern const unsigned int ata_acpi_pio_cycle[7];
-extern const unsigned int ata_acpi_mwdma_cycle[5];
-extern const unsigned int ata_acpi_udma_cycle[7];
-
 static inline const struct ata_acpi_gtm *ata_acpi_init_gtm(struct ata_port *ap)
 {
 	if (ap->pflags & ATA_PFLAG_INIT_GTM_VALID)

commit 7c77fa4d51b1480bcec2e898c94d6912fe063c16
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Dec 18 16:33:03 2007 +0900

    libata: separate out ata_acpi_gtm_xfermask() from pacpi_discover_modes()
    
    Finding out matching transfer mode from ACPI GTM values is useful for
    other purposes too.  Separate out the function and timing tables from
    pata_acpi::pacpi_discover_modes().
    
    Other than checking shared-configuration bit after doing
    ata_acpi_gtm() in pacpi_discover_modes() which should be safe, this
    patch doesn't introduce any behavior change.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index bdb7c6e13993..8022e5b2224d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -961,6 +961,10 @@ enum {
 
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI
+extern const unsigned int ata_acpi_pio_cycle[7];
+extern const unsigned int ata_acpi_mwdma_cycle[5];
+extern const unsigned int ata_acpi_udma_cycle[7];
+
 static inline const struct ata_acpi_gtm *ata_acpi_init_gtm(struct ata_port *ap)
 {
 	if (ap->pflags & ATA_PFLAG_INIT_GTM_VALID)
@@ -970,12 +974,33 @@ static inline const struct ata_acpi_gtm *ata_acpi_init_gtm(struct ata_port *ap)
 extern int ata_acpi_cbl_80wire(struct ata_port *ap);
 int ata_acpi_stm(struct ata_port *ap, const struct ata_acpi_gtm *stm);
 int ata_acpi_gtm(struct ata_port *ap, struct ata_acpi_gtm *stm);
+unsigned long ata_acpi_gtm_xfermask(struct ata_device *dev,
+				    const struct ata_acpi_gtm *gtm);
+
 #else
 static inline const struct ata_acpi_gtm *ata_acpi_init_gtm(struct ata_port *ap)
 {
 	return NULL;
 }
 static inline int ata_acpi_cbl_80wire(struct ata_port *ap) { return 0; }
+
+static inline int ata_acpi_stm(const struct ata_port *ap,
+			       struct ata_acpi_gtm *stm)
+{
+	return -ENOSYS;
+}
+
+static inline int ata_acpi_gtm(const struct ata_port *ap,
+			       struct ata_acpi_gtm *stm)
+{
+	return -ENOSYS;
+}
+
+static inline unsigned int ata_acpi_gtm_xfermask(struct ata_device *dev,
+					const struct ata_acpi_gtm *gtm)
+{
+	return 0;
+}
 #endif
 
 #ifdef CONFIG_PCI

commit c88f90c3779cd5e710f2acdf59ad2bd0380de98d
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Nov 27 19:43:48 2007 +0900

    libata: add ATA_CBL_PATA_IGN
    
    ATA_CBL_PATA_UNK indicates that the cable type can't be determined
    from the host side and might be either 80c or 40c.  libata applies
    drive or other generic limit in this case.  However, there are
    controllers where both host and drive side detections are
    misimplemented and the driver has to rely solely on private method -
    peeking BIOS or ACPI configuration or using some other private
    mechanism.
    
    This patch adds ATA_CBL_PATA_IGN which tells libata to ignore the
    cable type completely and just let the LLD determine the transfer mode
    via host transfer mode masks and ->mode_filter().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d9eb20c67bb6..bdb7c6e13993 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -927,6 +927,7 @@ extern u8 ata_irq_on(struct ata_port *ap);
 extern int ata_cable_40wire(struct ata_port *ap);
 extern int ata_cable_80wire(struct ata_port *ap);
 extern int ata_cable_sata(struct ata_port *ap);
+extern int ata_cable_ignore(struct ata_port *ap);
 extern int ata_cable_unknown(struct ata_port *ap);
 
 /*

commit 7dc951aefdc1dc20228691b04867fb6195864d67
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Nov 27 19:43:42 2007 +0900

    libata: xfer_mask is unsigned long not unsigned int
    
    Jeff says xfer_mask is unsigned long not unsigned int.  Convert all
    xfermask fields and handling functions to deal with unsigned longs.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d33702fe78f9..d9eb20c67bb6 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -267,7 +267,7 @@ enum {
 	PORT_DISABLED		= 2,
 
 	/* encoding various smaller bitmaps into a single
-	 * unsigned int bitmap
+	 * unsigned long bitmap
 	 */
 	ATA_NR_PIO_MODES	= 7,
 	ATA_NR_MWDMA_MODES	= 5,
@@ -277,13 +277,6 @@ enum {
 	ATA_SHIFT_MWDMA		= ATA_SHIFT_PIO + ATA_NR_PIO_MODES,
 	ATA_SHIFT_UDMA		= ATA_SHIFT_MWDMA + ATA_NR_MWDMA_MODES,
 
-	ATA_MASK_PIO		= ((1 << ATA_NR_PIO_MODES) - 1)
-					<< ATA_SHIFT_PIO,
-	ATA_MASK_MWDMA		= ((1 << ATA_NR_MWDMA_MODES) - 1)
-					<< ATA_SHIFT_MWDMA,
-	ATA_MASK_UDMA		= ((1 << ATA_NR_UDMA_MODES) - 1)
-					<< ATA_SHIFT_UDMA,
-
 	/* size of buffer to pad xfers ending on unaligned boundaries */
 	ATA_DMA_PAD_SZ		= 4,
 	ATA_DMA_PAD_BUF_SZ	= ATA_DMA_PAD_SZ * ATA_MAX_QUEUE,
@@ -355,6 +348,15 @@ enum {
 	ATA_DMA_MASK_CFA	= (1 << 2),	/* DMA on CF Card */
 };
 
+enum ata_xfer_mask {
+	ATA_MASK_PIO		= ((1LU << ATA_NR_PIO_MODES) - 1)
+					<< ATA_SHIFT_PIO,
+	ATA_MASK_MWDMA		= ((1LU << ATA_NR_MWDMA_MODES) - 1)
+					<< ATA_SHIFT_MWDMA,
+	ATA_MASK_UDMA		= ((1LU << ATA_NR_UDMA_MODES) - 1)
+					<< ATA_SHIFT_UDMA,
+};
+
 enum hsm_task_states {
 	HSM_ST_IDLE,		/* no command on going */
 	HSM_ST_FIRST,		/* (waiting the device to)
@@ -526,9 +528,9 @@ struct ata_device {
 	unsigned int		cdb_len;
 
 	/* per-dev xfer mask */
-	unsigned int		pio_mask;
-	unsigned int		mwdma_mask;
-	unsigned int		udma_mask;
+	unsigned long		pio_mask;
+	unsigned long		mwdma_mask;
+	unsigned long		udma_mask;
 
 	/* for CHS addressing */
 	u16			cylinders;	/* Number of cylinders */
@@ -854,15 +856,16 @@ extern void ata_tf_read(struct ata_port *ap, struct ata_taskfile *tf);
 extern void ata_tf_to_fis(const struct ata_taskfile *tf,
 			  u8 pmp, int is_cmd, u8 *fis);
 extern void ata_tf_from_fis(const u8 *fis, struct ata_taskfile *tf);
-extern unsigned int ata_pack_xfermask(unsigned int pio_mask,
-			unsigned int mwdma_mask, unsigned int udma_mask);
-extern void ata_unpack_xfermask(unsigned int xfer_mask, unsigned int *pio_mask,
-			unsigned int *mwdma_mask, unsigned int *udma_mask);
-extern u8 ata_xfer_mask2mode(unsigned int xfer_mask);
-extern unsigned int ata_xfer_mode2mask(u8 xfer_mode);
-extern int ata_xfer_mode2shift(unsigned int xfer_mode);
-extern const char *ata_mode_string(unsigned int xfer_mask);
-extern unsigned int ata_id_xfermask(const u16 *id);
+extern unsigned long ata_pack_xfermask(unsigned long pio_mask,
+			unsigned long mwdma_mask, unsigned long udma_mask);
+extern void ata_unpack_xfermask(unsigned long xfer_mask,
+			unsigned long *pio_mask, unsigned long *mwdma_mask,
+			unsigned long *udma_mask);
+extern u8 ata_xfer_mask2mode(unsigned long xfer_mask);
+extern unsigned long ata_xfer_mode2mask(u8 xfer_mode);
+extern int ata_xfer_mode2shift(unsigned long xfer_mode);
+extern const char *ata_mode_string(unsigned long xfer_mask);
+extern unsigned long ata_id_xfermask(const u16 *id);
 extern void ata_noop_dev_select(struct ata_port *ap, unsigned int device);
 extern void ata_std_dev_select(struct ata_port *ap, unsigned int device);
 extern u8 ata_check_status(struct ata_port *ap);
@@ -1001,7 +1004,8 @@ extern int ata_pci_prepare_sff_host(struct pci_dev *pdev,
 				    const struct ata_port_info * const * ppi,
 				    struct ata_host **r_host);
 extern int pci_test_config_bits(struct pci_dev *pdev, const struct pci_bits *bits);
-extern unsigned long ata_pci_default_filter(struct ata_device *, unsigned long);
+extern unsigned long ata_pci_default_filter(struct ata_device *dev,
+					    unsigned long xfer_mask);
 #endif /* CONFIG_PCI */
 
 /*

commit 9d3501ab962b1506d93974faf8509251b4a85fbc
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Nov 27 19:43:41 2007 +0900

    libata: kill ata_id_to_dma_mode()
    
    ata_id_to_dma_mode() isn't quite generic.  The function is basically
    privately implemented ata_id_xfermask() combined with hardcoded mode
    printing and configuration which are specific to ata_generic.
    
    Kill the function and open code it in generic_set_mode() using generic
    xfermode handling functions.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index e2ed3bac8c5b..d33702fe78f9 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -890,7 +890,6 @@ extern void ata_id_string(const u16 *id, unsigned char *s,
 			  unsigned int ofs, unsigned int len);
 extern void ata_id_c_string(const u16 *id, unsigned char *s,
 			    unsigned int ofs, unsigned int len);
-extern void ata_id_to_dma_mode(struct ata_device *dev, u8 unknown);
 extern void ata_bmdma_setup(struct ata_queued_cmd *qc);
 extern void ata_bmdma_start(struct ata_queued_cmd *qc);
 extern void ata_bmdma_stop(struct ata_queued_cmd *qc);

commit 70cd071e4ecc06c985189665af75c108601fd5a3
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Nov 27 19:43:40 2007 +0900

    libata: clean up xfermode / PATA timing related stuff
    
    * s/ATA_BITS_(PIO|MWDMA|UDMA)/ATA_NR_\1_MODES/g
    
    * Consistently use 0xff to indicate invalid transfer mode (0x00 is
      valid for PIO_SLOW).
    
    * Make ata_xfer_mode2mask() return proper mode mask instead of just
      the highest bit.
    
    * Sort ata_timing table in increasing xfermode order and update
      ata_timing_find_mode() accordingly.
    
    This patch doesn't introduce any behavior change.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 083dd77b120d..e2ed3bac8c5b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -269,17 +269,20 @@ enum {
 	/* encoding various smaller bitmaps into a single
 	 * unsigned int bitmap
 	 */
-	ATA_BITS_PIO		= 7,
-	ATA_BITS_MWDMA		= 5,
-	ATA_BITS_UDMA		= 8,
+	ATA_NR_PIO_MODES	= 7,
+	ATA_NR_MWDMA_MODES	= 5,
+	ATA_NR_UDMA_MODES	= 8,
 
 	ATA_SHIFT_PIO		= 0,
-	ATA_SHIFT_MWDMA		= ATA_SHIFT_PIO + ATA_BITS_PIO,
-	ATA_SHIFT_UDMA		= ATA_SHIFT_MWDMA + ATA_BITS_MWDMA,
-
-	ATA_MASK_PIO		= ((1 << ATA_BITS_PIO) - 1) << ATA_SHIFT_PIO,
-	ATA_MASK_MWDMA		= ((1 << ATA_BITS_MWDMA) - 1) << ATA_SHIFT_MWDMA,
-	ATA_MASK_UDMA		= ((1 << ATA_BITS_UDMA) - 1) << ATA_SHIFT_UDMA,
+	ATA_SHIFT_MWDMA		= ATA_SHIFT_PIO + ATA_NR_PIO_MODES,
+	ATA_SHIFT_UDMA		= ATA_SHIFT_MWDMA + ATA_NR_MWDMA_MODES,
+
+	ATA_MASK_PIO		= ((1 << ATA_NR_PIO_MODES) - 1)
+					<< ATA_SHIFT_PIO,
+	ATA_MASK_MWDMA		= ((1 << ATA_NR_MWDMA_MODES) - 1)
+					<< ATA_SHIFT_MWDMA,
+	ATA_MASK_UDMA		= ((1 << ATA_NR_UDMA_MODES) - 1)
+					<< ATA_SHIFT_UDMA,
 
 	/* size of buffer to pad xfers ending on unaligned boundaries */
 	ATA_DMA_PAD_SZ		= 4,

commit 6357357cae7794dcb89cace758108dec612e7ed5
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Nov 27 19:43:39 2007 +0900

    libata: export xfermode / PATA timing related functions
    
    Export the following xfermode related functions.
    
    * ata_pack_xfermask()
    * ata_unpack_xfermask()
    * ata_xfer_mask2mode()
    * ata_xfer_mode2mask()
    * ata_xfer_mode2shift()
    * ata_mode_string()
    * ata_id_xfermask()
    * ata_timing_find_mode()
    
    These functions will be used later by LLD updates.  While at it,
    change unsigned short @speed to u8 @xfer_mode in
    ata_timing_find_mode() for consistency.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 131fb6625e14..083dd77b120d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -851,6 +851,15 @@ extern void ata_tf_read(struct ata_port *ap, struct ata_taskfile *tf);
 extern void ata_tf_to_fis(const struct ata_taskfile *tf,
 			  u8 pmp, int is_cmd, u8 *fis);
 extern void ata_tf_from_fis(const u8 *fis, struct ata_taskfile *tf);
+extern unsigned int ata_pack_xfermask(unsigned int pio_mask,
+			unsigned int mwdma_mask, unsigned int udma_mask);
+extern void ata_unpack_xfermask(unsigned int xfer_mask, unsigned int *pio_mask,
+			unsigned int *mwdma_mask, unsigned int *udma_mask);
+extern u8 ata_xfer_mask2mode(unsigned int xfer_mask);
+extern unsigned int ata_xfer_mode2mask(u8 xfer_mode);
+extern int ata_xfer_mode2shift(unsigned int xfer_mode);
+extern const char *ata_mode_string(unsigned int xfer_mask);
+extern unsigned int ata_id_xfermask(const u16 *id);
 extern void ata_noop_dev_select(struct ata_port *ap, unsigned int device);
 extern void ata_std_dev_select(struct ata_port *ap, unsigned int device);
 extern u8 ata_check_status(struct ata_port *ap);
@@ -920,6 +929,7 @@ extern int ata_cable_unknown(struct ata_port *ap);
  */
 
 extern unsigned int ata_pio_need_iordy(const struct ata_device *);
+extern const struct ata_timing *ata_timing_find_mode(u8 xfer_mode);
 extern int ata_timing_compute(struct ata_device *, unsigned short,
 			      struct ata_timing *, int, int);
 extern void ata_timing_merge(const struct ata_timing *,

commit 00115e0f5bc3bfdf3f3855ad89c8895f10458f92
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Nov 27 19:28:58 2007 +0900

    libata: implement ATA_DFLAG_DUBIOUS_XFER
    
    ATA_DFLAG_DUBIOUS_XFER is set whenever data transfer speed or method
    changes and gets cleared when data transfer command succeeds in the
    newly configured transfer mode.
    
    This will be used to improve speed down logic.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com<
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 74f1255e2524..131fb6625e14 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -143,6 +143,7 @@ enum {
 	ATA_DFLAG_NCQ_OFF	= (1 << 13), /* device limited to non-NCQ mode */
 	ATA_DFLAG_SPUNDOWN	= (1 << 14), /* XXX: for spindown_compat */
 	ATA_DFLAG_SLEEPING	= (1 << 15), /* device is sleeping */
+	ATA_DFLAG_DUBIOUS_XFER	= (1 << 16), /* data transfer not verified */
 	ATA_DFLAG_INIT_MASK	= (1 << 24) - 1,
 
 	ATA_DFLAG_DETACH	= (1 << 24),
@@ -560,6 +561,8 @@ struct ata_eh_context {
 	int			tries[ATA_MAX_DEVICES];
 	unsigned int		classes[ATA_MAX_DEVICES];
 	unsigned int		did_probe_mask;
+	unsigned int		saved_ncq_enabled;
+	u8			saved_xfer_mode[ATA_MAX_DEVICES];
 };
 
 struct ata_acpi_drive

commit 3884f7b0a8382b89d8ca5da23bd98e3e15fc805b
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Nov 27 19:28:56 2007 +0900

    libata: clean up EH speed down implementation
    
    Clean up EH speed down implementation.
    
    * is_io boolean variable is replaced eflags.  is_io is ATA_EFLAG_IS_IO.
    
    * Error categories now have names.
    
    * Better comments.
    
    * Reorder 5min and 10min rules in ata_eh_speed_down_verdict()
    
    * Use local variable @link to cache @dev->link in ata_eh_speed_down()
    
    These changes are to improve readability and ease further changes.
    This patch doesn't introduce any behavior change.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ca347b018649..74f1255e2524 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -482,7 +482,7 @@ struct ata_port_stats {
 };
 
 struct ata_ering_entry {
-	int			is_io;
+	unsigned int		eflags;
 	unsigned int		err_mask;
 	u64			timestamp;
 };

commit f20ded38aa54b92dd0af32578b8916d0aa2d9e05
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Nov 27 19:28:52 2007 +0900

    libata: rearrange ATA_DFLAG_*
    
    Area for DFLAGs which are cleared on INIT is full.  Extend it by 8
    bits.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 124033cb5e9b..ca347b018649 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -143,10 +143,10 @@ enum {
 	ATA_DFLAG_NCQ_OFF	= (1 << 13), /* device limited to non-NCQ mode */
 	ATA_DFLAG_SPUNDOWN	= (1 << 14), /* XXX: for spindown_compat */
 	ATA_DFLAG_SLEEPING	= (1 << 15), /* device is sleeping */
-	ATA_DFLAG_INIT_MASK	= (1 << 16) - 1,
+	ATA_DFLAG_INIT_MASK	= (1 << 24) - 1,
 
-	ATA_DFLAG_DETACH	= (1 << 16),
-	ATA_DFLAG_DETACHED	= (1 << 17),
+	ATA_DFLAG_DETACH	= (1 << 24),
+	ATA_DFLAG_DETACHED	= (1 << 25),
 
 	ATA_DEV_UNKNOWN		= 0,	/* unknown device */
 	ATA_DEV_ATA		= 1,	/* ATA device */

commit 140b5e59119a172a91b5fa13d54ca4f79bbefee1
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Dec 12 12:21:52 2007 +0900

    libata: fix ATAPI draining
    
    With ATAPI transfer chunk size properly programmed, libata PIO HSM
    should be able to handle full spurious data chunks.  Also, it's a good
    idea to suppress trailing data warning for misc ATAPI commands as
    there can be many of them per command - for example, if the chunk size
    is 16 and the drive tries to transfer 510 bytes, there can be 31
    trailing data messages.
    
    This patch makes the following updates to libata ATAPI PIO HSM
    implementation.
    
    * Make it drain full spurious chunks.
    
    * Suppress trailing data warning message for misc commands.
    
    * Put limit on how many bytes can be drained.
    
    * If odd, round up consumed bytes and the number of bytes to be
      drained.  This gets the number of bytes to drain right for drivers
      which do 16bit PIO.
    
    This patch is partial backport of improve-ATAPI-data-xfer patchset
    pending for #upstream.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index cb91280be9bd..124033cb5e9b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -119,6 +119,8 @@ enum {
 	ATA_DEF_BUSY_WAIT	= 10000,
 	ATA_SHORT_PAUSE		= (HZ >> 6) + 1,
 
+	ATAPI_MAX_DRAIN		= 16 << 10,
+
 	ATA_SHT_EMULATED	= 1,
 	ATA_SHT_CMD_PER_LUN	= 1,
 	ATA_SHT_THIS_ID		= -1,

commit 398e07826b24cbeb5ff2f0a178367fc9d24cd475
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Dec 15 15:05:03 2007 +0900

    libata-acpi: implement dev->gtf_cache and evaluate _GTF right after _STM during resume
    
    On certain implementations, _GTF evaluation depends on preceding _STM
    and both can be pretty picky about the configuration.  Using _GTM
    result cached during controller initialization satisfies the most
    neurotic _STM implementation.  However, libata evaluates _GTF after
    reset during device configuration and the hardware state can be
    different from what _GTF expects and can cause evaluation failure.
    
    This patch adds dev->gtf_cache and updates ata_dev_get_GTF() such that
    it uses the cached value if available.  Cache is cleared with a call
    to ata_acpi_clear_gtf().
    
    Because for SATA ACPI nodes _GTF must be evaluated after _SDD which
    can't be done till IDENTIFY is complete, _GTF caching from
    ata_acpi_on_resume() is used only for IDE ACPI nodes.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ba84d8a37545..cb91280be9bd 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -498,6 +498,7 @@ struct ata_device {
 	struct scsi_device	*sdev;		/* attached SCSI device */
 #ifdef CONFIG_ATA_ACPI
 	acpi_handle		acpi_handle;
+	union acpi_object	*gtf_cache;
 #endif
 	/* n_sector is used as CLEAR_OFFSET, read comment above CLEAR_OFFSET */
 	u64			n_sectors;	/* size of device, if ATA */

commit c05e6ff035c1b25d17364a685432b33937d3dc23
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Dec 15 15:05:02 2007 +0900

    libata-acpi: implement and use ata_acpi_init_gtm()
    
    _GTM fetches currently configured transfer mode while _STM configures
    controller according to _GTM parameter and prepares transfer mode
    configuration TFs for _GTF.  In many cases _GTM and _STM
    implementations are quite brittle and can't cope with configuration
    changed by libata.
    
    libata does not depend on ATA ACPI to configure devices.  The only
    reason libata performs _GTM and _STM are to make _GTF evaluation
    succeed and libata also doesn't care about how _GTF TFs configure
    transfer mode.  It overrides that configuration anyway, so from
    libata's POV, it doesn't matter what value is feeded to _STM as long
    as evaluation succeeds for _STM and following _GTF.
    
    This patch adds dev->__acpi_init_gtm and store initial _GTM values on
    host initialization before modified by reset and mode configuration.
    If the field is valid, ata_acpi_init_gtm() returns pointer to the
    saved _GTM structure; otherwise, NULL.
    
    This saved value is used for _STM during resume and peek at
    BIOS/firmware programmed initial timing for later use.  The accessor
    is there to make building w/o ACPI easy as dev->__acpi_init doesn't
    exist if ACPI is not enabled.
    
    On driver detach, the initial BIOS configuration is restored by
    executing _STM with the initial _GTM values such that the next driver
    can also use the initial BIOS configured values.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 3784af395576..ba84d8a37545 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -211,7 +211,7 @@ enum {
 
 	ATA_PFLAG_SUSPENDED	= (1 << 17), /* port is suspended (power) */
 	ATA_PFLAG_PM_PENDING	= (1 << 18), /* PM operation pending */
-	ATA_PFLAG_GTM_VALID	= (1 << 19), /* acpi_gtm data valid */
+	ATA_PFLAG_INIT_GTM_VALID = (1 << 19), /* initial gtm data valid */
 
 	/* struct ata_queued_cmd flags */
 	ATA_QCFLAG_ACTIVE	= (1 << 0), /* cmd not yet ack'd to scsi lyer */
@@ -653,7 +653,7 @@ struct ata_port {
 
 #ifdef CONFIG_ATA_ACPI
 	acpi_handle		acpi_handle;
-	struct ata_acpi_gtm	acpi_gtm;
+	struct ata_acpi_gtm	__acpi_init_gtm; /* use ata_acpi_init_gtm() */
 #endif
 	u8			sector_buf[ATA_SECT_SIZE]; /* owned by EH */
 };
@@ -939,10 +939,20 @@ enum {
 
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI
+static inline const struct ata_acpi_gtm *ata_acpi_init_gtm(struct ata_port *ap)
+{
+	if (ap->pflags & ATA_PFLAG_INIT_GTM_VALID)
+		return &ap->__acpi_init_gtm;
+	return NULL;
+}
 extern int ata_acpi_cbl_80wire(struct ata_port *ap);
 int ata_acpi_stm(struct ata_port *ap, const struct ata_acpi_gtm *stm);
 int ata_acpi_gtm(struct ata_port *ap, struct ata_acpi_gtm *stm);
 #else
+static inline const struct ata_acpi_gtm *ata_acpi_init_gtm(struct ata_port *ap)
+{
+	return NULL;
+}
 static inline int ata_acpi_cbl_80wire(struct ata_port *ap) { return 0; }
 #endif
 

commit c2e366a107e511ad00c2181c52e4150fc086ec0f
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Dec 15 15:04:58 2007 +0900

    libata: update ata_*_printk() macros such that level can be a variable
    
    Make prink helpers format @lv together rather than prepending to the
    format string as constant.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 1ca9b89632f9..3784af395576 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1013,18 +1013,18 @@ extern void ata_do_eh(struct ata_port *ap, ata_prereset_fn_t prereset,
  * printk helpers
  */
 #define ata_port_printk(ap, lv, fmt, args...) \
-	printk(lv"ata%u: "fmt, (ap)->print_id , ##args)
+	printk("%sata%u: "fmt, lv, (ap)->print_id , ##args)
 
 #define ata_link_printk(link, lv, fmt, args...) do { \
 	if ((link)->ap->nr_pmp_links) \
-		printk(lv"ata%u.%02u: "fmt, (link)->ap->print_id, \
+		printk("%sata%u.%02u: "fmt, lv, (link)->ap->print_id,	\
 		       (link)->pmp , ##args); \
 	else \
-		printk(lv"ata%u: "fmt, (link)->ap->print_id , ##args); \
+		printk("%sata%u: "fmt, lv, (link)->ap->print_id , ##args); \
 	} while(0)
 
 #define ata_dev_printk(dev, lv, fmt, args...) \
-	printk(lv"ata%u.%02u: "fmt, (dev)->link->ap->print_id, \
+	printk("%sata%u.%02u: "fmt, lv, (dev)->link->ap->print_id,	\
 	       (dev)->link->pmp + (dev)->devno , ##args)
 
 /*

commit 0d02f0b22b678b9d6c8ac8cad7b4cfbbdf6fab18
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Dec 15 15:04:57 2007 +0900

    libata-acpi: adjust constness in ata_acpi_gtm/stm() parameters
    
    * No internal function uses const ata_port.  Drop const from @ap.
    
    * Make ata_acpi_stm() copy @stm before using it and change @stm to
      const.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ef52a07c43d8..1ca9b89632f9 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -940,8 +940,8 @@ enum {
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI
 extern int ata_acpi_cbl_80wire(struct ata_port *ap);
-int ata_acpi_stm(const struct ata_port *ap, struct ata_acpi_gtm *stm);
-int ata_acpi_gtm(const struct ata_port *ap, struct ata_acpi_gtm *stm);
+int ata_acpi_stm(struct ata_port *ap, const struct ata_acpi_gtm *stm);
+int ata_acpi_gtm(struct ata_port *ap, struct ata_acpi_gtm *stm);
 #else
 static inline int ata_acpi_cbl_80wire(struct ata_port *ap) { return 0; }
 #endif

commit 2d3b8eea7f2fbafd5d779cc92f7aedbd1ef575e9
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Thu Nov 15 10:35:46 2007 +0900

    libata: workaround DRQ=1 ERR=1 for ATAPI tape drives
    
    After an error condition, some ATAPI tape drives set DRQ=1 together
    with ERR=1 when asking the host to transfer the CDB of the next packet
    command (i.e. request sense).  This patch, a revised version of
    Alan/Mark's previous patch, adds ATA_HORKAGE_STUCK_ERR to workaround
    the problem by ignoring the ERR bit and proceed sending the CDB.
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Mark Lord <liml@rtr.ca>
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 3f9a6a140a98..ef52a07c43d8 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -340,6 +340,7 @@ enum {
 	ATA_HORKAGE_HPA_SIZE	= (1 << 6),	/* native size off by one */
 	ATA_HORKAGE_IPM		= (1 << 7),	/* Link PM problems */
 	ATA_HORKAGE_IVB		= (1 << 8),	/* cbl det validity bit bugs */
+	ATA_HORKAGE_STUCK_ERR	= (1 << 9),	/* stuck ERR on next PACKET */
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */

commit 21bef6dd2b419f28c8096a8e30ad86dcbff44c02
Author: Adrian Bunk <bunk@kernel.org>
Date:   Thu Nov 15 10:35:45 2007 +0900

    libata: remove unused functions
    
    This patch removes the following obsolete functions:
    - libata-core.c: __sata_phy_reset()
    - libata-core.c: sata_phy_reset()
    - libata-eh.c: ata_qc_timeout()
    - libata-eh.c: ata_eng_timeout()
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 56a5673aebad..3f9a6a140a98 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -771,8 +771,6 @@ static inline int ata_port_is_dummy(struct ata_port *ap)
 
 extern void sata_print_link_status(struct ata_link *link);
 extern void ata_port_probe(struct ata_port *);
-extern void __sata_phy_reset(struct ata_port *ap);
-extern void sata_phy_reset(struct ata_port *ap);
 extern void ata_bus_reset(struct ata_port *ap);
 extern int sata_set_spd(struct ata_link *link);
 extern int sata_link_debounce(struct ata_link *link,
@@ -994,8 +992,6 @@ extern void sata_pmp_do_eh(struct ata_port *ap,
 /*
  * EH
  */
-extern void ata_eng_timeout(struct ata_port *ap);
-
 extern void ata_port_schedule_eh(struct ata_port *ap);
 extern int ata_link_abort(struct ata_link *link);
 extern int ata_port_abort(struct ata_port *ap);

commit 6bbfd53d47abd1fb20d7c93a9b19a75970b66f49
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Nov 5 22:58:58 2007 +0000

    libata: handle broken cable reporting
    
    One or two ancient drives predated the cable spec and didn't sent the
    valid bits for the field. I had hoped to leave this out of libata as a
    piece of historical annoyance but a recent CD drive shows the same bug so
    we have to import support for it.
    
    Same concept as Bartlomiej's changes old IDE except that as we have
    centralised blacklists we can avoid keeping another private table of stuff
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 1e277852ba42..56a5673aebad 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -339,6 +339,7 @@ enum {
 	ATA_HORKAGE_SKIP_PM	= (1 << 5),	/* Skip PM operations */
 	ATA_HORKAGE_HPA_SIZE	= (1 << 6),	/* native size off by one */
 	ATA_HORKAGE_IPM		= (1 << 7),	/* Link PM problems */
+	ATA_HORKAGE_IVB		= (1 << 8),	/* cbl det validity bit bugs */
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */

commit e027bd36c146582cef382364e5c826db93d4427b
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Oct 26 16:19:26 2007 +0900

    libata: implement and use ATA_QCFLAG_QUIET
    
    Implement ATA_QCFLAG_QUIET which indicates that there's no need to
    report if the command fails with AC_ERR_DEV and set it for passthrough
    commands.
    
    Combined with previous changes, this now makes device errors for all
    direct commands reported directly to the issuer without going through
    EH actions and reporting.
    
    Note that EH is still invoked after non-IO device errors to determine
    the nature of the error and resume command execution (some controller
    requires special care after error to continue).  It just performs
    default maintenance after error, examines what's going on, realizes
    that it's none of its business and reports the command failure without
    logging any error messages.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 147ccc40c8af..1e277852ba42 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -221,6 +221,7 @@ enum {
 	ATA_QCFLAG_IO		= (1 << 3), /* standard IO command */
 	ATA_QCFLAG_RESULT_TF	= (1 << 4), /* result TF requested */
 	ATA_QCFLAG_CLEAR_EXCL	= (1 << 5), /* clear excl_link on completion */
+	ATA_QCFLAG_QUIET	= (1 << 6), /* don't report device error */
 
 	ATA_QCFLAG_FAILED	= (1 << 16), /* cmd failed and is owned by EH */
 	ATA_QCFLAG_SENSE_VALID	= (1 << 17), /* sense data valid */

commit ca77329fb713b7fea6a307068e0dd0248e7aa640
Author: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
Date:   Thu Oct 25 00:58:59 2007 -0400

    [libata] Link power management infrastructure
    
    Device Initiated Power Management, which is defined
    in SATA 2.5 can be enabled for disks which support it.
    This patch enables DIPM when the user sets the link
    power management policy to "min_power".
    
    Additionally, libata drivers can define a function
    (enable_pm) that will perform hardware specific actions to
    enable whatever power management policy the user set up
    for Host Initiated Power management (HIPM).
    This power management policy will be activated after all
    disks have been enumerated and intialized.  Drivers should
    also define disable_pm, which will turn off link power
    management, but not change link power management policy.
    
    Documentation/scsi/link_power_management_policy.txt has additional
    information.
    
    Signed-off-by:  Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 439d40f86c55..147ccc40c8af 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -133,6 +133,8 @@ enum {
 	ATA_DFLAG_ACPI_PENDING	= (1 << 5), /* ACPI resume action pending */
 	ATA_DFLAG_ACPI_FAILED	= (1 << 6), /* ACPI on devcfg has failed */
 	ATA_DFLAG_AN		= (1 << 7), /* AN configured */
+	ATA_DFLAG_HIPM		= (1 << 8), /* device supports HIPM */
+	ATA_DFLAG_DIPM		= (1 << 9), /* device supports DIPM */
 	ATA_DFLAG_CFG_MASK	= (1 << 12) - 1,
 
 	ATA_DFLAG_PIO		= (1 << 12), /* device limited to PIO mode */
@@ -186,6 +188,7 @@ enum {
 	ATA_FLAG_ACPI_SATA	= (1 << 17), /* need native SATA ACPI layout */
 	ATA_FLAG_AN		= (1 << 18), /* controller supports AN */
 	ATA_FLAG_PMP		= (1 << 19), /* controller supports PMP */
+	ATA_FLAG_IPM		= (1 << 20), /* driver can handle IPM */
 
 	/* The following flag belongs to ap->pflags but is kept in
 	 * ap->flags because it's referenced in many LLDs and will be
@@ -302,6 +305,7 @@ enum {
 	ATA_EHI_RESUME_LINK	= (1 << 1),  /* resume link (reset modifier) */
 	ATA_EHI_NO_AUTOPSY	= (1 << 2),  /* no autopsy */
 	ATA_EHI_QUIET		= (1 << 3),  /* be quiet */
+	ATA_EHI_LPM		= (1 << 4),  /* link power management action */
 
 	ATA_EHI_DID_SOFTRESET	= (1 << 16), /* already soft-reset this port */
 	ATA_EHI_DID_HARDRESET	= (1 << 17), /* already soft-reset this port */
@@ -333,6 +337,7 @@ enum {
 	ATA_HORKAGE_BROKEN_HPA	= (1 << 4),	/* Broken HPA */
 	ATA_HORKAGE_SKIP_PM	= (1 << 5),	/* Skip PM operations */
 	ATA_HORKAGE_HPA_SIZE	= (1 << 6),	/* native size off by one */
+	ATA_HORKAGE_IPM		= (1 << 7),	/* Link PM problems */
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */
@@ -378,6 +383,18 @@ typedef int (*ata_reset_fn_t)(struct ata_link *link, unsigned int *classes,
 			      unsigned long deadline);
 typedef void (*ata_postreset_fn_t)(struct ata_link *link, unsigned int *classes);
 
+/*
+ * host pm policy: If you alter this, you also need to alter libata-scsi.c
+ * (for the ascii descriptions)
+ */
+enum link_pm {
+	NOT_AVAILABLE,
+	MIN_POWER,
+	MAX_PERFORMANCE,
+	MEDIUM_POWER,
+};
+extern struct class_device_attribute class_device_attr_link_power_management_policy;
+
 struct ata_ioports {
 	void __iomem		*cmd_addr;
 	void __iomem		*data_addr;
@@ -624,6 +641,7 @@ struct ata_port {
 
 	pm_message_t		pm_mesg;
 	int			*pm_result;
+	enum link_pm		pm_policy;
 
 	struct timer_list	fastdrain_timer;
 	unsigned long		fastdrain_cnt;
@@ -691,7 +709,8 @@ struct ata_port_operations {
 
 	int (*port_suspend) (struct ata_port *ap, pm_message_t mesg);
 	int (*port_resume) (struct ata_port *ap);
-
+	int (*enable_pm) (struct ata_port *ap, enum link_pm policy);
+	void (*disable_pm) (struct ata_port *ap);
 	int (*port_start) (struct ata_port *ap);
 	void (*port_stop) (struct ata_port *ap);
 

commit 88ff6eafbb2a1c55f0f0e2e16d72e7b10d8ae8a5
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Oct 16 14:21:24 2007 -0700

    libata: implement ata_wait_after_reset()
    
    On certain device/controller combination, 0xff status is asserted
    after reset and doesn't get cleared during 150ms post-reset wait.  As
    0xff status is interpreted as no device (for good reasons), this can
    lead to misdetection on such cases.
    
    This patch implements ata_wait_after_reset() which replaces the 150ms
    sleep and waits upto ATA_TMOUT_FF_WAIT if status is 0xff.
    ATA_TMOUT_FF_WAIT is currently 800ms which is enough for
    HHD424020F7SV00 to get detected but not enough for Quantum GoVault
    drive which is known to take upto 2s.
    
    Without parallel probing, spending 2s on 0xff port would incur too
    much delay on ata_piix's which use 0xff to indicate empty port and
    doesn't have SCR register, so GoVault needs to wait till parallel
    probing.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 2f0fc636b4b6..439d40f86c55 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -235,6 +235,13 @@ enum {
 	ATA_TMOUT_INTERNAL	= 30 * HZ,
 	ATA_TMOUT_INTERNAL_QUICK = 5 * HZ,
 
+	/* FIXME: GoVault needs 2s but we can't afford that without
+	 * parallel probing.  800ms is enough for iVDR disk
+	 * HHD424020F7SV00.  Increase to 2secs when parallel probing
+	 * is in place.
+	 */
+	ATA_TMOUT_FF_WAIT	= 4 * HZ / 5,
+
 	/* ATA bus states */
 	BUS_UNKNOWN		= 0,
 	BUS_DMA			= 1,
@@ -800,6 +807,7 @@ extern void ata_host_resume(struct ata_host *host);
 extern int ata_ratelimit(void);
 extern int ata_busy_sleep(struct ata_port *ap,
 			  unsigned long timeout_pat, unsigned long timeout);
+extern void ata_wait_after_reset(struct ata_port *ap, unsigned long deadline);
 extern int ata_wait_ready(struct ata_port *ap, unsigned long deadline);
 extern void ata_port_queue_task(struct ata_port *ap, work_func_t fn,
 				void *data, unsigned long delay);

commit 054a5fbaceb2eb3a31ea843c1cf0b8e10b91478c
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Oct 25 18:30:36 2007 +0900

    libata: track SLEEP state and issue SRST to wake it up
    
    ATA devices in SLEEP mode don't respond to any commands.  SRST is
    necessary to wake it up.  Till now, when a command is issued to a
    device in SLEEP mode, the command times out, which makes EH reset the
    device and retry the command after that, causing a long delay.
    
    This patch makes libata track SLEEP state and issue SRST automatically
    if a command is about to be issued to a device in SLEEP.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Bruce Allen <ballen@gravity.phys.uwm.edu>
    Cc: Andrew Paprocki <andrew@ishiboo.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6fd24e03622e..2f0fc636b4b6 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -138,6 +138,7 @@ enum {
 	ATA_DFLAG_PIO		= (1 << 12), /* device limited to PIO mode */
 	ATA_DFLAG_NCQ_OFF	= (1 << 13), /* device limited to non-NCQ mode */
 	ATA_DFLAG_SPUNDOWN	= (1 << 14), /* XXX: for spindown_compat */
+	ATA_DFLAG_SLEEPING	= (1 << 15), /* device is sleeping */
 	ATA_DFLAG_INIT_MASK	= (1 << 16) - 1,
 
 	ATA_DFLAG_DETACH	= (1 << 16),

commit 2dcb407e61458ded17503d6bd12b8c064965368b
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Oct 19 06:42:56 2007 -0400

    [libata] checkpatch-inspired cleanups
    
    Tackle the relatively sane complaints of checkpatch --file.
    
    The vast majority is indentation and whitespace changes, the rest are
    
    * #include fixes
    * printk KERN_xxx prefix addition
    * BSS/initializer cleanups
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index bc3b6fc7b98d..6fd24e03622e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -326,7 +326,7 @@ enum {
 	ATA_HORKAGE_SKIP_PM	= (1 << 5),	/* Skip PM operations */
 	ATA_HORKAGE_HPA_SIZE	= (1 << 6),	/* native size off by one */
 
-	 /* DMA mask for user DMA control: User visible values; DO NOT 
+	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */
 	ATA_DMA_MASK_ATA	= (1 << 0),	/* DMA on ATA Disk */
 	ATA_DMA_MASK_ATAPI	= (1 << 1),	/* DMA on ATAPI */
@@ -717,7 +717,7 @@ struct ata_timing {
 	unsigned short udma;		/* t2CYCTYP/2 */
 };
 
-#define FIT(v,vmin,vmax)	max_t(short,min_t(short,v,vmax),vmin)
+#define FIT(v, vmin, vmax)	max_t(short, min_t(short, v, vmax), vmin)
 
 extern const unsigned long sata_deb_timing_normal[];
 extern const unsigned long sata_deb_timing_hotplug[];
@@ -816,14 +816,14 @@ extern void ata_tf_read(struct ata_port *ap, struct ata_taskfile *tf);
 extern void ata_tf_to_fis(const struct ata_taskfile *tf,
 			  u8 pmp, int is_cmd, u8 *fis);
 extern void ata_tf_from_fis(const u8 *fis, struct ata_taskfile *tf);
-extern void ata_noop_dev_select (struct ata_port *ap, unsigned int device);
-extern void ata_std_dev_select (struct ata_port *ap, unsigned int device);
+extern void ata_noop_dev_select(struct ata_port *ap, unsigned int device);
+extern void ata_std_dev_select(struct ata_port *ap, unsigned int device);
 extern u8 ata_check_status(struct ata_port *ap);
 extern u8 ata_altstatus(struct ata_port *ap);
 extern void ata_exec_command(struct ata_port *ap, const struct ata_taskfile *tf);
-extern int ata_port_start (struct ata_port *ap);
-extern int ata_sff_port_start (struct ata_port *ap);
-extern irqreturn_t ata_interrupt (int irq, void *dev_instance);
+extern int ata_port_start(struct ata_port *ap);
+extern int ata_sff_port_start(struct ata_port *ap);
+extern irqreturn_t ata_interrupt(int irq, void *dev_instance);
 extern void ata_data_xfer(struct ata_device *adev, unsigned char *buf,
 			  unsigned int buflen, int write_data);
 extern void ata_data_xfer_noirq(struct ata_device *adev, unsigned char *buf,
@@ -844,8 +844,8 @@ extern void ata_id_string(const u16 *id, unsigned char *s,
 extern void ata_id_c_string(const u16 *id, unsigned char *s,
 			    unsigned int ofs, unsigned int len);
 extern void ata_id_to_dma_mode(struct ata_device *dev, u8 unknown);
-extern void ata_bmdma_setup (struct ata_queued_cmd *qc);
-extern void ata_bmdma_start (struct ata_queued_cmd *qc);
+extern void ata_bmdma_setup(struct ata_queued_cmd *qc);
+extern void ata_bmdma_start(struct ata_queued_cmd *qc);
 extern void ata_bmdma_stop(struct ata_queued_cmd *qc);
 extern u8   ata_bmdma_status(struct ata_port *ap);
 extern void ata_bmdma_irq_clear(struct ata_port *ap);
@@ -920,9 +920,9 @@ static inline int ata_acpi_cbl_80wire(struct ata_port *ap) { return 0; }
 #ifdef CONFIG_PCI
 struct pci_dev;
 
-extern int ata_pci_init_one (struct pci_dev *pdev,
+extern int ata_pci_init_one(struct pci_dev *pdev,
 			     const struct ata_port_info * const * ppi);
-extern void ata_pci_remove_one (struct pci_dev *pdev);
+extern void ata_pci_remove_one(struct pci_dev *pdev);
 #ifdef CONFIG_PM
 extern void ata_pci_device_do_suspend(struct pci_dev *pdev, pm_message_t mesg);
 extern int __must_check ata_pci_device_do_resume(struct pci_dev *pdev);

commit 3be6cbd73f74b4a3da82cc7d6e1688a4ae595fc7
Author: Jeff Garzik <jeff@garzik.org>
Date:   Thu Oct 18 16:21:18 2007 -0400

    [libata] kill ata_sg_is_last()
    
    Short term, this works around a bug introduced by early sg-chaining
    work.
    
    Long term, removing this function eliminates a branch from a hot
    path loop in each scatter/gather table build.  Also, as this code
    demonstrates, we don't need to _track_ the end of the s/g list, as
    long as we mark it in some way.  And doing so programatically is nice.
    So its a useful cleanup, regardless of its short term effects.
    
    Based conceptually on a quick patch by Jens Axboe.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 377e6d4d9be3..bc3b6fc7b98d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1037,18 +1037,6 @@ extern void ata_port_pbar_desc(struct ata_port *ap, int bar, ssize_t offset,
 /*
  * qc helpers
  */
-static inline int
-ata_sg_is_last(struct scatterlist *sg, struct ata_queued_cmd *qc)
-{
-	if (sg == &qc->pad_sgent)
-		return 1;
-	if (qc->pad_len)
-		return 0;
-	if (qc->n_iter == qc->n_elem)
-		return 1;
-	return 0;
-}
-
 static inline struct scatterlist *
 ata_qc_first_sg(struct ata_queued_cmd *qc)
 {

commit 8726021626780a73e795c9b939e1ee49ac8c9136
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Tue Oct 16 11:14:12 2007 +0200

    libata: convert to using sg helpers
    
    This converts libata to using the sg helpers for looking up sg
    elements, instead of doing it manually.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 229a9ff9f924..377e6d4d9be3 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -29,7 +29,7 @@
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/dma-mapping.h>
-#include <asm/scatterlist.h>
+#include <linux/scatterlist.h>
 #include <linux/io.h>
 #include <linux/ata.h>
 #include <linux/workqueue.h>
@@ -416,6 +416,7 @@ struct ata_queued_cmd {
 	unsigned long		flags;		/* ATA_QCFLAG_xxx */
 	unsigned int		tag;
 	unsigned int		n_elem;
+	unsigned int		n_iter;
 	unsigned int		orig_n_elem;
 
 	int			dma_dir;
@@ -426,7 +427,7 @@ struct ata_queued_cmd {
 	unsigned int		nbytes;
 	unsigned int		curbytes;
 
-	unsigned int		cursg;
+	struct scatterlist	*cursg;
 	unsigned int		cursg_ofs;
 
 	struct scatterlist	sgent;
@@ -1043,7 +1044,7 @@ ata_sg_is_last(struct scatterlist *sg, struct ata_queued_cmd *qc)
 		return 1;
 	if (qc->pad_len)
 		return 0;
-	if (((sg - qc->__sg) + 1) == qc->n_elem)
+	if (qc->n_iter == qc->n_elem)
 		return 1;
 	return 0;
 }
@@ -1051,6 +1052,7 @@ ata_sg_is_last(struct scatterlist *sg, struct ata_queued_cmd *qc)
 static inline struct scatterlist *
 ata_qc_first_sg(struct ata_queued_cmd *qc)
 {
+	qc->n_iter = 0;
 	if (qc->n_elem)
 		return qc->__sg;
 	if (qc->pad_len)
@@ -1063,8 +1065,8 @@ ata_qc_next_sg(struct scatterlist *sg, struct ata_queued_cmd *qc)
 {
 	if (sg == &qc->pad_sgent)
 		return NULL;
-	if (++sg - qc->__sg < qc->n_elem)
-		return sg;
+	if (++qc->n_iter < qc->n_elem)
+		return sg_next(sg);
 	if (qc->pad_len)
 		return &qc->pad_sgent;
 	return NULL;
@@ -1309,9 +1311,11 @@ static inline void ata_qc_reinit(struct ata_queued_cmd *qc)
 	qc->dma_dir = DMA_NONE;
 	qc->__sg = NULL;
 	qc->flags = 0;
-	qc->cursg = qc->cursg_ofs = 0;
+	qc->cursg = NULL;
+	qc->cursg_ofs = 0;
 	qc->nbytes = qc->curbytes = 0;
 	qc->n_elem = 0;
+	qc->n_iter = 0;
 	qc->err_mask = 0;
 	qc->pad_len = 0;
 	qc->sect_size = ATA_SECT_SIZE;

commit 2855568b1ee4f58ef2c0a13ddfceb4b0b216b7ed
Author: Jeff Garzik <jeff@garzik.org>
Date:   Thu Oct 11 17:12:35 2007 -0400

    [libata] struct pci_dev related cleanups
    
    * remove pointless pci_dev_to_dev() wrapper.  Just directly reference
      the embedded struct device like everyone else does.
    
    * pata_cs5520: delete cs5520_remove_one(), it was a duplicate of
      ata_pci_remove_one()
    
    * linux/libata.h: don't bother including linux/pci.h, we don't need it.
      Simply declare 'struct pci_dev' and assume interested parties will
      include the header, as they should be doing anyway.
    
    * linux/libata.h: consolidate all CONFIG_PCI declarations into a
      single location in the header.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 2439f1fa47a1..229a9ff9f924 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -28,7 +28,6 @@
 
 #include <linux/delay.h>
 #include <linux/interrupt.h>
-#include <linux/pci.h>
 #include <linux/dma-mapping.h>
 #include <asm/scatterlist.h>
 #include <linux/io.h>
@@ -107,12 +106,6 @@ static inline u32 ata_msg_init(int dval, int default_msg_enable_bits)
 /* defines only for the constants which don't work well as enums */
 #define ATA_TAG_POISON		0xfafbfcfdU
 
-/* move to PCI layer? */
-static inline struct device *pci_dev_to_dev(struct pci_dev *pdev)
-{
-	return &pdev->dev;
-}
-
 enum {
 	/* various global constants */
 	LIBATA_MAX_PRD		= ATA_MAX_PRD / 2,
@@ -766,18 +759,7 @@ extern int sata_std_hardreset(struct ata_link *link, unsigned int *class,
 extern void ata_std_postreset(struct ata_link *link, unsigned int *classes);
 extern void ata_port_disable(struct ata_port *);
 extern void ata_std_ports(struct ata_ioports *ioaddr);
-#ifdef CONFIG_PCI
-extern int ata_pci_init_one (struct pci_dev *pdev,
-			     const struct ata_port_info * const * ppi);
-extern void ata_pci_remove_one (struct pci_dev *pdev);
-#ifdef CONFIG_PM
-extern void ata_pci_device_do_suspend(struct pci_dev *pdev, pm_message_t mesg);
-extern int __must_check ata_pci_device_do_resume(struct pci_dev *pdev);
-extern int ata_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg);
-extern int ata_pci_device_resume(struct pci_dev *pdev);
-#endif
-extern int ata_pci_clear_simplex(struct pci_dev *pdev);
-#endif /* CONFIG_PCI */
+
 extern struct ata_host *ata_host_alloc(struct device *dev, int max_ports);
 extern struct ata_host *ata_host_alloc_pinfo(struct device *dev,
 			const struct ata_port_info * const * ppi, int n_ports);
@@ -935,6 +917,19 @@ static inline int ata_acpi_cbl_80wire(struct ata_port *ap) { return 0; }
 #endif
 
 #ifdef CONFIG_PCI
+struct pci_dev;
+
+extern int ata_pci_init_one (struct pci_dev *pdev,
+			     const struct ata_port_info * const * ppi);
+extern void ata_pci_remove_one (struct pci_dev *pdev);
+#ifdef CONFIG_PM
+extern void ata_pci_device_do_suspend(struct pci_dev *pdev, pm_message_t mesg);
+extern int __must_check ata_pci_device_do_resume(struct pci_dev *pdev);
+extern int ata_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg);
+extern int ata_pci_device_resume(struct pci_dev *pdev);
+#endif
+extern int ata_pci_clear_simplex(struct pci_dev *pdev);
+
 struct pci_bits {
 	unsigned int		reg;	/* PCI config register to read */
 	unsigned int		width;	/* 1 (8 bit), 2 (16 bit), 4 (32 bit) */

commit b06ce3e51e3df4394a584c234f11240b1c6f8d5b
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Oct 9 15:06:48 2007 +0900

    libata: use ata_exec_internal() for PMP register access
    
    PMP registers used to be accessed with dedicated accessors ->pmp_read
    and ->pmp_write.  During reset, those callbacks are called with the
    port frozen so they should be able to run without depending on
    interrupt delivery.  To achieve this, they were implemented polling.
    
    However, as resetting the host port makes the PMP to isolate fan-out
    ports until SError.X is cleared, resetting fan-out ports while port is
    frozen doesn't buy much additional safety.
    
    This patch updates libata PMP support such that PMP registers are
    accessed using regular ata_exec_internal() mechanism and kills
    ->pmp_read/write() callbacks.  The following changes are made.
    
    * PMP access helpers - sata_pmp_read_init_tf(), sata_pmp_read_val(),
      sata_pmp_write_init_tf() are folded into sata_pmp_read/write() which
      are now standalone PMP register access functions.
    
    * sata_pmp_read/write() returns err_mask instead of rc.  This is
      consistent with other functions which issue internal commands and
      allows more detailed error reporting.
    
    * ahci interrupt handler is modified to ignore BAD_PMP and
      spurious/illegal completion IRQs while reset is in progress.  These
      conditions are expected during reset.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 529af9fbed53..2439f1fa47a1 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -669,8 +669,6 @@ struct ata_port_operations {
 	/* port multiplier */
 	void (*pmp_attach) (struct ata_port *ap);
 	void (*pmp_detach) (struct ata_port *ap);
-	int (*pmp_read) (struct ata_device *dev, int pmp, int reg, u32 *r_val);
-	int (*pmp_write) (struct ata_device *dev, int pmp, int reg, u32 val);
 
 	/* Error handlers.  ->error_handler overrides ->eng_timeout and
 	 * indicates that new-style EH is in place.
@@ -957,12 +955,6 @@ extern unsigned long ata_pci_default_filter(struct ata_device *, unsigned long);
  * PMP
  */
 extern int sata_pmp_qc_defer_cmd_switch(struct ata_queued_cmd *qc);
-extern void sata_pmp_read_init_tf(struct ata_taskfile *tf,
-				  struct ata_device *dev, int pmp, int reg);
-extern u32 sata_pmp_read_val(const struct ata_taskfile *tf);
-extern void sata_pmp_write_init_tf(struct ata_taskfile *tf,
-				   struct ata_device *dev,
-				   int pmp, int reg, u32 val);
 extern int sata_pmp_std_prereset(struct ata_link *link, unsigned long deadline);
 extern int sata_pmp_std_hardreset(struct ata_link *link, unsigned int *class,
 				  unsigned long deadline);

commit afaa5c373d2c49ee4865847031b82f1377f609d0
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Oct 9 15:06:10 2007 +0900

    libata: implement ATA_PFLAG_RESETTING
    
    Implement ATA_PFLAG_RESETTING.  This flag is set while reset is in
    progress.  It's set before prereset is called and cleared after reset
    fails or postreset is finished.
    
    This flag itself doesn't have any function.  It will be used by LLDs
    to tell whether reset is in progress if it needs to behave differently
    during reset.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 751aabc21a3e..529af9fbed53 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -210,6 +210,7 @@ enum {
 	ATA_PFLAG_UNLOADING	= (1 << 5), /* module is unloading */
 	ATA_PFLAG_SCSI_HOTPLUG	= (1 << 6), /* SCSI hotplug scheduled */
 	ATA_PFLAG_INITIALIZING	= (1 << 7), /* being initialized, don't touch */
+	ATA_PFLAG_RESETTING	= (1 << 8), /* reset in progress */
 
 	ATA_PFLAG_SUSPENDED	= (1 << 17), /* port is suspended (power) */
 	ATA_PFLAG_PM_PENDING	= (1 << 18), /* PM operation pending */

commit badff03df7a005d13ea2ae8ddc2f5ec0cfc049e8
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Thu Oct 4 21:28:18 2007 +0100

    libata-core: Expose gtm methods for driver use
    
    Talk to the dark side our driver has to, yes. Much misleading is the
    data. Store it in a structure we do so that it may be parsed.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    --
    Whats small, old and shouts phrases out of order across mountains ?
    Yodla..
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 84dfc23b9d31..751aabc21a3e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -929,6 +929,8 @@ enum {
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI
 extern int ata_acpi_cbl_80wire(struct ata_port *ap);
+int ata_acpi_stm(const struct ata_port *ap, struct ata_acpi_gtm *stm);
+int ata_acpi_gtm(const struct ata_port *ap, struct ata_acpi_gtm *stm);
 #else
 static inline int ata_acpi_cbl_80wire(struct ata_port *ap) { return 0; }
 #endif

commit b3a706014e56b1356e7b275fd25b833c63175bf0
Author: Alan Cox <alan@redhat.com>
Date:   Tue Oct 2 12:38:26 2007 -0400

    libata: Add a drivers/ide style DMA disable
    
    This is useful when debugging, handling problem systems, or for
    distributions just to get the system installed so it can be sorted
    out later.
    
    This is a bit smarter than the old IDE one and lets you do
    
    libata.dma=0    Disable all PATA DMA like old IDE
    libata.dma=1    Disk DMA only
    libata.dma=2    ATAPI DMA only
    libata.dma=4    CF DMA only
    
    (or combinations thereof - 0,1,3 being the useful ones I suspect)
    
    (I've split CF as it seems to be a seperate case of pain and suffering
    different to the others and caused by assorted PIO wired adapters etc)
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    
    [edited to work on SATA too, changing name from 'pata_dma' to 'dma']
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ca296a575c4a..84dfc23b9d31 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -331,6 +331,12 @@ enum {
 	ATA_HORKAGE_BROKEN_HPA	= (1 << 4),	/* Broken HPA */
 	ATA_HORKAGE_SKIP_PM	= (1 << 5),	/* Skip PM operations */
 	ATA_HORKAGE_HPA_SIZE	= (1 << 6),	/* native size off by one */
+
+	 /* DMA mask for user DMA control: User visible values; DO NOT 
+	    renumber */
+	ATA_DMA_MASK_ATA	= (1 << 0),	/* DMA on ATA Disk */
+	ATA_DMA_MASK_ATAPI	= (1 << 1),	/* DMA on ATAPI */
+	ATA_DMA_MASK_CFA	= (1 << 2),	/* DMA on CF Card */
 };
 
 enum hsm_task_states {

commit 31f88384443b3e0d7e2c9d36a96647b7e82edad3
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Sep 23 13:19:54 2007 +0900

    libata-pmp: implement qc_defer for command switching PMP support
    
    Implement sata_pmp_qc_defer_cmd_switch() - standard qc_defer for
    command switching PMP support.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 3cfdb5f67621..ca296a575c4a 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -947,6 +947,7 @@ extern unsigned long ata_pci_default_filter(struct ata_device *, unsigned long);
 /*
  * PMP
  */
+extern int sata_pmp_qc_defer_cmd_switch(struct ata_queued_cmd *qc);
 extern void sata_pmp_read_init_tf(struct ata_taskfile *tf,
 				  struct ata_device *dev, int pmp, int reg);
 extern u32 sata_pmp_read_val(const struct ata_taskfile *tf);

commit 3af9a77af9e2b72366363864bfcd3d51465ff98a
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Sep 23 13:19:54 2007 +0900

    libata-pmp: implement Port Multiplier support
    
    Implement Port Multiplier support.  To support PMP, a LLDD has to
    supply ops->pmp_read() and pmp_write().  If non-null, ->pmp_attach and
    ->pmp_detach are called on PMP attach and detach, respectively.
    
    ->pmp_read/write() can be called while the port is frozen, so they
    must be implemented by polling.  This patch supplies several helpers
    to ease ->pmp_read/write() implementation.
    
    Also, irq_handler and error_handler must be PMP aware.  Most of PMP
    aware EH can be done by calling ata_pmp_do_eh() with appropriate
    methods.  PMP EH uses separate set of reset methods and this patch
    implements standard prereset, hardreset and postreset methods.
    
    This patch only implements PMP support.  The next patch will integrate
    PMP into the reset of libata and thus enable PMP support.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index f9ed198e4fcd..3cfdb5f67621 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -944,6 +944,25 @@ extern int pci_test_config_bits(struct pci_dev *pdev, const struct pci_bits *bit
 extern unsigned long ata_pci_default_filter(struct ata_device *, unsigned long);
 #endif /* CONFIG_PCI */
 
+/*
+ * PMP
+ */
+extern void sata_pmp_read_init_tf(struct ata_taskfile *tf,
+				  struct ata_device *dev, int pmp, int reg);
+extern u32 sata_pmp_read_val(const struct ata_taskfile *tf);
+extern void sata_pmp_write_init_tf(struct ata_taskfile *tf,
+				   struct ata_device *dev,
+				   int pmp, int reg, u32 val);
+extern int sata_pmp_std_prereset(struct ata_link *link, unsigned long deadline);
+extern int sata_pmp_std_hardreset(struct ata_link *link, unsigned int *class,
+				  unsigned long deadline);
+extern void sata_pmp_std_postreset(struct ata_link *link, unsigned int *class);
+extern void sata_pmp_do_eh(struct ata_port *ap,
+		ata_prereset_fn_t prereset, ata_reset_fn_t softreset,
+		ata_reset_fn_t hardreset, ata_postreset_fn_t postreset,
+		ata_prereset_fn_t pmp_prereset, ata_reset_fn_t pmp_softreset,
+		ata_reset_fn_t pmp_hardreset, ata_postreset_fn_t pmp_postreset);
+
 /*
  * EH
  */

commit 93328e1145c1989d1a214d34ac4e968dea7f7ed7
Author: Alan Cox <alan@redhat.com>
Date:   Sat Sep 29 04:06:48 2007 -0400

    [PATCH] libata: Fix HPA handling regression
    
    Restore the support for handling drives that report one sector too many
    (ie SCSI not ATA style). This worked before the HPA update but was
    removed in that process.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index cd9c2a28136a..f9ed198e4fcd 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -330,6 +330,7 @@ enum {
 	ATA_HORKAGE_MAX_SEC_128	= (1 << 3),	/* Limit max sects to 128 */
 	ATA_HORKAGE_BROKEN_HPA	= (1 << 4),	/* Broken HPA */
 	ATA_HORKAGE_SKIP_PM	= (1 << 5),	/* Skip PM operations */
+	ATA_HORKAGE_HPA_SIZE	= (1 << 6),	/* native size off by one */
 };
 
 enum hsm_task_states {

commit 7d77b247088fb360aa74bfdd9e19bce1e1987668
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Sep 23 13:14:13 2007 +0900

    libata-pmp-prep: implement sata_async_notification()
    
    AN serves multiple purposes.  For ATAPI, it's used for media change
    notification.  For PMP, for downstream PHY status change notification.
    Implement sata_async_notification() which demultiplexes AN.
    
    To avoid unnecessary port events, ATAPI AN is not enabled if PMP is
    attached but SNTF is not available.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Kriten Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 56b218771114..cd9c2a28136a 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -139,7 +139,7 @@ enum {
 	ATA_DFLAG_FLUSH_EXT	= (1 << 4), /* do FLUSH_EXT instead of FLUSH */
 	ATA_DFLAG_ACPI_PENDING	= (1 << 5), /* ACPI resume action pending */
 	ATA_DFLAG_ACPI_FAILED	= (1 << 6), /* ACPI on devcfg has failed */
-	ATA_DFLAG_AN		= (1 << 7), /* device supports AN */
+	ATA_DFLAG_AN		= (1 << 7), /* AN configured */
 	ATA_DFLAG_CFG_MASK	= (1 << 12) - 1,
 
 	ATA_DFLAG_PIO		= (1 << 12), /* device limited to PIO mode */
@@ -787,7 +787,6 @@ extern void ata_host_init(struct ata_host *, struct device *,
 extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
 extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));
-extern void ata_scsi_media_change_notify(struct ata_device *atadev);
 extern void ata_sas_port_destroy(struct ata_port *);
 extern struct ata_port *ata_sas_port_alloc(struct ata_host *,
 					   struct ata_port_info *, struct Scsi_Host *);
@@ -953,6 +952,7 @@ extern void ata_port_schedule_eh(struct ata_port *ap);
 extern int ata_link_abort(struct ata_link *link);
 extern int ata_port_abort(struct ata_port *ap);
 extern int ata_port_freeze(struct ata_port *ap);
+extern int sata_async_notification(struct ata_port *ap);
 
 extern void ata_eh_freeze_port(struct ata_port *ap);
 extern void ata_eh_thaw_port(struct ata_port *ap);

commit e31e8531d668c9c4dc7883054788f89805188003
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Sep 23 13:14:13 2007 +0900

    libata-pmp-prep: implement ATA_HORKAGE_SKIP_PM
    
    Some pseudo devices fail PM commands unnecessarily aborting system
    suspend.  Implement ATA_HORKAGE_SKIP_PM which makes libata skip PM
    commands for these devices.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 2bd1d26c9c8d..56b218771114 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -329,6 +329,7 @@ enum {
 	ATA_HORKAGE_NONCQ	= (1 << 2),	/* Don't use NCQ */
 	ATA_HORKAGE_MAX_SEC_128	= (1 << 3),	/* Limit max sects to 128 */
 	ATA_HORKAGE_BROKEN_HPA	= (1 << 4),	/* Broken HPA */
+	ATA_HORKAGE_SKIP_PM	= (1 << 5),	/* Skip PM operations */
 };
 
 enum hsm_task_states {

commit f9df58cb27dfd605eced643bb3aa599fe4feeee8
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Sep 23 13:14:13 2007 +0900

    libata-pmp-prep: implement ATA_LFLAG_DISABLED
    
    Implement ATA_LFLAG_DISABLED.  The flag indicates the link is disabled
    due to EH recovery failure.  While a link is disabled, no EH action is
    taken on the link and suspend/resume become noop too.
    
    This will be used by PMP links to manage failed links.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index adeee7397cdb..2bd1d26c9c8d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -170,6 +170,7 @@ enum {
 	ATA_LFLAG_ASSUME_SEMB	= (1 << 4), /* assume SEMB class */
 	ATA_LFLAG_ASSUME_CLASS	= ATA_LFLAG_ASSUME_ATA | ATA_LFLAG_ASSUME_SEMB,
 	ATA_LFLAG_NO_RETRY	= (1 << 5), /* don't retry this link */
+	ATA_LFLAG_DISABLED	= (1 << 6), /* link is disabled */
 
 	/* struct ata_port flags */
 	ATA_FLAG_SLAVE_POSS	= (1 << 0), /* host supports slave dev */
@@ -289,6 +290,7 @@ enum {
 	ATA_EH_REVALIDATE	= (1 << 0),
 	ATA_EH_SOFTRESET	= (1 << 1),
 	ATA_EH_HARDRESET	= (1 << 2),
+	ATA_EH_ENABLE_LINK	= (1 << 3),
 
 	ATA_EH_RESET_MASK	= ATA_EH_SOFTRESET | ATA_EH_HARDRESET,
 	ATA_EH_PERDEV_MASK	= ATA_EH_REVALIDATE,
@@ -999,6 +1001,7 @@ static inline void ata_ehi_hotplugged(struct ata_eh_info *ehi)
 {
 	ata_ehi_schedule_probe(ehi);
 	ehi->flags |= ATA_EHI_HOTPLUGGED;
+	ehi->action |= ATA_EH_ENABLE_LINK;
 	ehi->err_mask |= AC_ERR_ATA_BUS;
 }
 

commit fd995f7039f1955ccc6b43e1e2d168060b31e4b2
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Sep 23 13:14:12 2007 +0900

    libata-pmp-prep: implement ATA_LFLAG_NO_RETRY
    
    Some PMP links are connected to internal pseudo devices which may come
    and go depending on situation.  There's no reason to try hard to
    recover them.  ATA_LFLAG_NO_RETRY tells EH to not retry if the device
    attached to the link fails.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6266fffb0eb3..adeee7397cdb 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -169,6 +169,7 @@ enum {
 	ATA_LFLAG_ASSUME_ATA	= (1 << 3), /* assume ATA class */
 	ATA_LFLAG_ASSUME_SEMB	= (1 << 4), /* assume SEMB class */
 	ATA_LFLAG_ASSUME_CLASS	= ATA_LFLAG_ASSUME_ATA | ATA_LFLAG_ASSUME_SEMB,
+	ATA_LFLAG_NO_RETRY	= (1 << 5), /* don't retry this link */
 
 	/* struct ata_port flags */
 	ATA_FLAG_SLAVE_POSS	= (1 << 0), /* host supports slave dev */

commit ae791c05694d7391ee9261a0450a50f7e95aedfd
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Sep 23 13:14:12 2007 +0900

    libata-pmp-prep: implement ATA_LFLAG_NO_SRST, ASSUME_ATA and ASSUME_SEMB
    
    Some links on some PMPs locks up on SRST and/or report incorrect
    device signature.  Implement ATA_LFLAG_NO_SRST, ASSUME_ATA and
    ASSUME_SEMB to handle these quirky links.  NO_SRST makes EH avoid
    SRST.  ASSUME_ATA and SEMB forces class code to ATA and SEMB_UNSUP
    respectively.  Note that SEMB isn't currently supported yet so the
    _UNSUP variant is used.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index f9f81fd93293..6266fffb0eb3 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -165,6 +165,10 @@ enum {
 	ATA_LFLAG_HRST_TO_RESUME = (1 << 0), /* hardreset to resume link */
 	ATA_LFLAG_SKIP_D2H_BSY	= (1 << 1), /* can't wait for the first D2H
 					     * Register FIS clearing BSY */
+	ATA_LFLAG_NO_SRST	= (1 << 2), /* avoid softreset */
+	ATA_LFLAG_ASSUME_ATA	= (1 << 3), /* assume ATA class */
+	ATA_LFLAG_ASSUME_SEMB	= (1 << 4), /* assume SEMB class */
+	ATA_LFLAG_ASSUME_CLASS	= ATA_LFLAG_ASSUME_ATA | ATA_LFLAG_ASSUME_SEMB,
 
 	/* struct ata_port flags */
 	ATA_FLAG_SLAVE_POSS	= (1 << 0), /* host supports slave dev */

commit da917d69d0ea63f5390716cba6e77f490ce96df9
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Sep 23 13:14:12 2007 +0900

    libata-pmp-prep: implement qc_defer helpers
    
    Implement ap->nr_active_links (the number of links with active qcs),
    ap->excl_link (pointer to link which can be used by ->qc_defer and is
    cleared when a qc with ATA_QCFLAG_CLEAR_EXCL completes), and
    ata_link_active().
    
    These can be used by ->qc_defer() to implement proper command
    exclusion.  This set of helpers seem enough for both sil24 (ATAPI
    exclusion needed) and cmd-switching PMP.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b0d4ca0d27b4..f9f81fd93293 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -216,6 +216,7 @@ enum {
 	ATA_QCFLAG_DMAMAP	= ATA_QCFLAG_SG | ATA_QCFLAG_SINGLE,
 	ATA_QCFLAG_IO		= (1 << 3), /* standard IO command */
 	ATA_QCFLAG_RESULT_TF	= (1 << 4), /* result TF requested */
+	ATA_QCFLAG_CLEAR_EXCL	= (1 << 5), /* clear excl_link on completion */
 
 	ATA_QCFLAG_FAILED	= (1 << 16), /* cmd failed and is owned by EH */
 	ATA_QCFLAG_SENSE_VALID	= (1 << 17), /* sense data valid */
@@ -579,11 +580,13 @@ struct ata_port {
 	struct ata_queued_cmd	qcmd[ATA_MAX_QUEUE];
 	unsigned long		qc_allocated;
 	unsigned int		qc_active;
+	int			nr_active_links; /* #links with active qcs */
 
 	struct ata_link		link;	/* host default link */
 
 	int			nr_pmp_links;	/* nr of available PMP links */
 	struct ata_link		*pmp_link;	/* array of PMP links */
+	struct ata_link		*excl_link;	/* for PMP qc exclusion */
 
 	struct ata_port_stats	stats;
 	struct ata_host		*host;
@@ -1104,6 +1107,11 @@ static inline int ata_link_max_devices(const struct ata_link *link)
 	return 1;
 }
 
+static inline int ata_link_active(struct ata_link *link)
+{
+	return ata_tag_valid(link->active_tag) || link->sactive;
+}
+
 static inline struct ata_link *ata_port_first_link(struct ata_port *ap)
 {
 	if (ap->nr_pmp_links)

commit 31cc23b34913bc173680bdc87af79e551bf8cc0d
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Sep 23 13:14:12 2007 +0900

    libata-pmp-prep: implement ops->qc_defer()
    
    Controllers which support PMP have various restrictions on which
    combinations of commands are allowed to what number of devices
    concurrently.  This patch implements ops->qc_defer() which determines
    whether a qc can be issued at the moment or should be deferred.
    
    If the function returns ATA_DEFER_LINK, the qc will be deferred until
    a qc completes on the link.  If ATA_DEFER_PORT, until a qc completes
    on any link.  The defer conditions are advisory and in general
    ATA_DEFER_LINK can be considered as lower priority deferring than
    ATA_DEFER_PORT.
    
    ops->qc_defer() replaces fixed ata_scmd_need_defer().  For standard
    NCQ/non-NCQ exclusion, ata_std_qc_defer() is implemented.  ahci and
    sata_sil24 are converted to use ata_std_qc_defer().
    
    ops->qc_defer() is heavier than the original mechanism because full qc
    is prepped before determining to defer it, but various information is
    needed to determine defer conditinos and fully translating a qc is the
    only way to supply such information in generic manner.
    
    IMHO, this shouldn't cause any noticeable performance issues as
    
    * for most cases deferring occurs rarely (except for NCQ-aware
      cmd-switching PMP)
    * translation itself isn't that expensive
    * once deferred the command won't be repeated until another command
      completes which usually is a very long time cpu-wise.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c3820f105ffa..b0d4ca0d27b4 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -272,6 +272,10 @@ enum {
 	/* ering size */
 	ATA_ERING_SIZE		= 32,
 
+	/* return values for ->qc_defer */
+	ATA_DEFER_LINK		= 1,
+	ATA_DEFER_PORT		= 2,
+
 	/* desc_len for ata_eh_info and context */
 	ATA_EH_DESC_LEN		= 80,
 
@@ -639,6 +643,7 @@ struct ata_port_operations {
 
 	void (*data_xfer) (struct ata_device *, unsigned char *, unsigned int, int);
 
+	int (*qc_defer) (struct ata_queued_cmd *qc);
 	void (*qc_prep) (struct ata_queued_cmd *qc);
 	unsigned int (*qc_issue) (struct ata_queued_cmd *qc);
 
@@ -824,6 +829,7 @@ extern void ata_data_xfer(struct ata_device *adev, unsigned char *buf,
 			  unsigned int buflen, int write_data);
 extern void ata_data_xfer_noirq(struct ata_device *adev, unsigned char *buf,
 				unsigned int buflen, int write_data);
+extern int ata_std_qc_defer(struct ata_queued_cmd *qc);
 extern void ata_dumb_qc_prep(struct ata_queued_cmd *qc);
 extern void ata_qc_prep(struct ata_queued_cmd *qc);
 extern void ata_noop_qc_prep(struct ata_queued_cmd *qc);

commit e0a7175263db4a226558883a51a88a5d2bc5d9fe
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Sep 23 13:14:12 2007 +0900

    libata-pmp-prep: add PMP related constants, fields, ops and update helpers
    
    Add PMP related constants, fields and ops.  Also, update
    ata_class_enabled/disabled() such that PMP classes are considered.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 3ab2196c651a..c3820f105ffa 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -155,7 +155,11 @@ enum {
 	ATA_DEV_ATA_UNSUP	= 2,	/* ATA device (unsupported) */
 	ATA_DEV_ATAPI		= 3,	/* ATAPI device */
 	ATA_DEV_ATAPI_UNSUP	= 4,	/* ATAPI device (unsupported) */
-	ATA_DEV_NONE		= 5,	/* no device */
+	ATA_DEV_PMP		= 5,	/* SATA port multiplier */
+	ATA_DEV_PMP_UNSUP	= 6,	/* SATA port multiplier (unsupported) */
+	ATA_DEV_SEMB		= 7,	/* SEMB */
+	ATA_DEV_SEMB_UNSUP	= 8,	/* SEMB (unsupported) */
+	ATA_DEV_NONE		= 9,	/* no device */
 
 	/* struct ata_link flags */
 	ATA_LFLAG_HRST_TO_RESUME = (1 << 0), /* hardreset to resume link */
@@ -181,6 +185,7 @@ enum {
 	ATA_FLAG_NO_IORDY	= (1 << 16), /* controller lacks iordy */
 	ATA_FLAG_ACPI_SATA	= (1 << 17), /* need native SATA ACPI layout */
 	ATA_FLAG_AN		= (1 << 18), /* controller supports AN */
+	ATA_FLAG_PMP		= (1 << 19), /* controller supports PMP */
 
 	/* The following flag belongs to ap->pflags but is kept in
 	 * ap->flags because it's referenced in many LLDs and will be
@@ -299,6 +304,10 @@ enum {
 	/* how hard are we gonna try to probe/recover devices */
 	ATA_PROBE_MAX_TRIES	= 3,
 	ATA_EH_DEV_TRIES	= 3,
+	ATA_EH_PMP_TRIES	= 5,
+	ATA_EH_PMP_LINK_TRIES	= 3,
+
+	SATA_PMP_SCR_TIMEOUT	= 250,
 
 	/* Horkage types. May be set by libata or controller on drives
 	   (some horkage may be drive/controller pair dependant */
@@ -450,7 +459,12 @@ struct ata_device {
 	/* n_sector is used as CLEAR_OFFSET, read comment above CLEAR_OFFSET */
 	u64			n_sectors;	/* size of device, if ATA */
 	unsigned int		class;		/* ATA_DEV_xxx */
-	u16			id[ATA_ID_WORDS]; /* IDENTIFY xxx DEVICE data */
+
+	union {
+		u16		id[ATA_ID_WORDS]; /* IDENTIFY xxx DEVICE data */
+		u32		gscr[SATA_PMP_GSCR_DWORDS]; /* PMP GSCR block */
+	};
+
 	u8			pio_mode;
 	u8			dma_mode;
 	u8			xfer_mode;
@@ -628,6 +642,12 @@ struct ata_port_operations {
 	void (*qc_prep) (struct ata_queued_cmd *qc);
 	unsigned int (*qc_issue) (struct ata_queued_cmd *qc);
 
+	/* port multiplier */
+	void (*pmp_attach) (struct ata_port *ap);
+	void (*pmp_detach) (struct ata_port *ap);
+	int (*pmp_read) (struct ata_device *dev, int pmp, int reg, u32 *r_val);
+	int (*pmp_write) (struct ata_device *dev, int pmp, int reg, u32 val);
+
 	/* Error handlers.  ->error_handler overrides ->eng_timeout and
 	 * indicates that new-style EH is in place.
 	 */
@@ -1033,12 +1053,14 @@ static inline unsigned int ata_tag_internal(unsigned int tag)
  */
 static inline unsigned int ata_class_enabled(unsigned int class)
 {
-	return class == ATA_DEV_ATA || class == ATA_DEV_ATAPI;
+	return class == ATA_DEV_ATA || class == ATA_DEV_ATAPI ||
+		class == ATA_DEV_PMP || class == ATA_DEV_SEMB;
 }
 
 static inline unsigned int ata_class_disabled(unsigned int class)
 {
-	return class == ATA_DEV_ATA_UNSUP || class == ATA_DEV_ATAPI_UNSUP;
+	return class == ATA_DEV_ATA_UNSUP || class == ATA_DEV_ATAPI_UNSUP ||
+		class == ATA_DEV_PMP_UNSUP || class == ATA_DEV_SEMB_UNSUP;
 }
 
 static inline unsigned int ata_class_absent(unsigned int class)

commit 3f19859ee95a38c066a0420eb8a30c76ecd67a42
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Sep 2 23:23:57 2007 +0900

    libata: update ata_dev_try_classify() arguments
    
    Make ata_dev_try_classify() take a pointer to ata_device instead of
    ata_port/port_number combination for consistency and add @present
    argument.  @present indicates whether the device seems present during
    reset.  It's the result of TF access during softreset and link
    onlineness during hardreset.  @present will be used to improve
    diagnostic failure handling.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 49da62d0c83b..3ab2196c651a 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -781,7 +781,8 @@ extern void ata_port_queue_task(struct ata_port *ap, work_func_t fn,
 extern u32 ata_wait_register(void __iomem *reg, u32 mask, u32 val,
 			     unsigned long interval_msec,
 			     unsigned long timeout_msec);
-extern unsigned int ata_dev_try_classify(struct ata_port *, unsigned int, u8 *);
+extern unsigned int ata_dev_try_classify(struct ata_device *dev, int present,
+					 u8 *r_err);
 
 /*
  * Default driver ops implementations

commit 2557164e0b18e78a7772632a2a90832f56181fc5
Author: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
Date:   Tue Sep 11 11:41:59 2007 -0700

    ata: increase allowed config flags
    
    In anticipation of more features, increase number of config flags
    allowed, and move the init flags.
    
    Signed-off-by:  Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Cc: Hugh Dickens <hugh@veritas.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 74e034ea9016..49da62d0c83b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -140,11 +140,11 @@ enum {
 	ATA_DFLAG_ACPI_PENDING	= (1 << 5), /* ACPI resume action pending */
 	ATA_DFLAG_ACPI_FAILED	= (1 << 6), /* ACPI on devcfg has failed */
 	ATA_DFLAG_AN		= (1 << 7), /* device supports AN */
-	ATA_DFLAG_CFG_MASK	= (1 << 8) - 1,
+	ATA_DFLAG_CFG_MASK	= (1 << 12) - 1,
 
-	ATA_DFLAG_PIO		= (1 << 8), /* device limited to PIO mode */
-	ATA_DFLAG_NCQ_OFF	= (1 << 9), /* device limited to non-NCQ mode */
-	ATA_DFLAG_SPUNDOWN	= (1 << 10), /* XXX: for spindown_compat */
+	ATA_DFLAG_PIO		= (1 << 12), /* device limited to PIO mode */
+	ATA_DFLAG_NCQ_OFF	= (1 << 13), /* device limited to non-NCQ mode */
+	ATA_DFLAG_SPUNDOWN	= (1 << 14), /* XXX: for spindown_compat */
 	ATA_DFLAG_INIT_MASK	= (1 << 16) - 1,
 
 	ATA_DFLAG_DETACH	= (1 << 16),

commit a1e10f7e68a544c80081fee4fa550dc28389f44a
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Aug 18 13:28:49 2007 +0900

    libata: move EH repeat reporting into ata_eh_report()
    
    EH is sometimes repeated without any error or action.  For example,
    this happens when probing IDENTIFY fails because of a phantom device.
    In these cases, all the repeated EH does is making sure there is no
    unhandled error or pending action and return.  This repeation is
    necessary to avoid losing any event which occurred while EH was in
    progress.
    
    Unfortunately, this dry run causes annonying "EH pending after
    completion" message.  This patch moves the repeat reporting into
    ata_eh_report() such that it's more compact and skipped on dry runs.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Mikael Pettersson <mikep@it.uu.se>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d3defae689ca..74e034ea9016 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -293,8 +293,8 @@ enum {
 	ATA_EHI_DID_RESET	= ATA_EHI_DID_SOFTRESET | ATA_EHI_DID_HARDRESET,
 	ATA_EHI_RESET_MODIFIER_MASK = ATA_EHI_RESUME_LINK,
 
-	/* max repeat if error condition is still set after ->error_handler */
-	ATA_EH_MAX_REPEAT	= 5,
+	/* max tries if error condition is still set after ->error_handler */
+	ATA_EH_MAX_TRIES	= 5,
 
 	/* how hard are we gonna try to probe/recover devices */
 	ATA_PROBE_MAX_TRIES	= 3,
@@ -581,6 +581,7 @@ struct ata_port {
 	u32			msg_enable;
 	struct list_head	eh_done_q;
 	wait_queue_head_t	eh_wait_q;
+	int			eh_tries;
 
 	pm_message_t		pm_mesg;
 	int			*pm_result;

commit cbcdd87593a1d85c5c4b259945a3a09eee12814d
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Aug 18 13:14:55 2007 +0900

    libata: implement and use ata_port_desc() to report port configuration
    
    Currently, port configuration reporting has the following problems.
    
    * iomapped address is reported instead of raw address
    * report contains irrelevant fields or lacks necessary fields for
      non-SFF controllers.
    * host->irq/irq2 are there just for reporting and hacky.
    
    This patch implements and uses ata_port_desc() and
    ata_port_pbar_desc().  ata_port_desc() is almost identical to
    ata_ehi_push_desc() except that it takes @ap instead of @ehi, has no
    locking requirement, can only be used during host initialization and "
    " is used as separator instead of ", ".  ata_port_pbar_desc() is a
    helper to ease reporting of a PCI BAR or an offsetted address into it.
    
    LLD pushes whatever description it wants using the above two
    functions.  The accumulated description is printed on host
    registration after "[S/P]ATA max MAX_XFERMODE ".
    
    SFF init helpers and ata_host_activate() automatically add
    descriptions for addresses and irq respectively, so only LLDs which
    isn't standard SFF need to add custom descriptions.  In many cases,
    such controllers need to report different things anyway.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index e7d163edb4c0..d3defae689ca 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -368,8 +368,6 @@ struct ata_ioports {
 struct ata_host {
 	spinlock_t		lock;
 	struct device 		*dev;
-	unsigned long		irq;
-	unsigned long		irq2;
 	void __iomem * const	*iomap;
 	unsigned int		n_ports;
 	void			*private_data;
@@ -968,6 +966,16 @@ static inline void ata_ehi_hotplugged(struct ata_eh_info *ehi)
 	ehi->err_mask |= AC_ERR_ATA_BUS;
 }
 
+/*
+ * port description helpers
+ */
+extern void ata_port_desc(struct ata_port *ap, const char *fmt, ...)
+	__attribute__ ((format (printf, 2, 3)));
+#ifdef CONFIG_PCI
+extern void ata_port_pbar_desc(struct ata_port *ap, int bar, ssize_t offset,
+			       const char *name);
+#endif
+
 /*
  * qc helpers
  */

commit ac8869d56d95a8c74403e6f7a47d74fcfcc1b988
Author: Jeff Garzik <jeff@garzik.org>
Date:   Thu Aug 16 03:17:03 2007 -0400

    [libata] Remove ->port_disable() hook
    
    It was always set to ata_port_disable().  Removed the hook, and replaced
    the very few ap->ops->port_disable() callsites with direct calls to
    ata_port_disable().
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 382898ef6545..e7d163edb4c0 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -600,8 +600,6 @@ struct ata_port {
 };
 
 struct ata_port_operations {
-	void (*port_disable) (struct ata_port *);
-
 	void (*dev_config) (struct ata_device *);
 
 	void (*set_piomode) (struct ata_port *, struct ata_device *);

commit e1ddb4b6a2c9b2c72991eb8640ef2f50691ac502
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Thu Aug 16 02:33:36 2007 -0400

    [libata] add ACPI cable detect API
    
    Combined from two Alan Cox patches:
    
    1) libata: ACPI checks for 80wire cable
    
    We can use the ACPI mode information with several drivers as a hint to
    cable type. If the ACPI mode set by the BIOS is faster than UDMA33 then
    we know the BIOS thinks there are 80wire cables. If it doesn't set such a
    mode or it has no ACPI method then we get no further information and can
    rely on existing approaches
    
    Introduce the function headers needed. Null it out for non ACPI boxes
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    
    2) libata: ACPI checks for 80wire cable
    
    Provide actual methods for checking if the ACPI support thinks the cable
    is 80wire, or doesn't know
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    
    Combined into a single changeset and
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 9295cd541ffc..382898ef6545 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -885,6 +885,12 @@ enum {
 				  ATA_TIMING_CYCLE | ATA_TIMING_UDMA,
 };
 
+/* libata-acpi.c */
+#ifdef CONFIG_ATA_ACPI
+extern int ata_acpi_cbl_80wire(struct ata_port *ap);
+#else
+static inline int ata_acpi_cbl_80wire(struct ata_port *ap) { return 0; }
+#endif
 
 #ifdef CONFIG_PCI
 struct pci_bits {

commit 6d32d30f55020d766388df7515f771f68c973033
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Aug 15 05:38:46 2007 -0400

    [libata] Remove ->irq_ack() hook, and ata_dummy_irq_on()
    
    * ->irq_ack() is redundant to what the irq handler already
      performs... chk-status + irq-clear.  Furthermore, it is only
      called in one place, when screaming-irq-debugging is enabled,
      so we don't want to bother with a hook just for that.
    
    * ata_dummy_irq_on() is only ever used in drivers that have
      no callpath reaching ->irq_on().  Remove .irq_on hook from
      those drivers, and the now-unused ata_dummy_irq_on()
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b89d191ceb2b..9295cd541ffc 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -644,7 +644,6 @@ struct ata_port_operations {
 	irq_handler_t irq_handler;
 	void (*irq_clear) (struct ata_port *);
 	u8 (*irq_on) (struct ata_port *);
-	u8 (*irq_ack) (struct ata_port *ap, unsigned int chk_drq);
 
 	int (*scr_read) (struct ata_port *ap, unsigned int sc_reg, u32 *val);
 	int (*scr_write) (struct ata_port *ap, unsigned int sc_reg, u32 val);
@@ -852,9 +851,6 @@ extern int ata_scsi_change_queue_depth(struct scsi_device *sdev,
 extern struct ata_device *ata_dev_pair(struct ata_device *adev);
 extern int ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
 extern u8 ata_irq_on(struct ata_port *ap);
-extern u8 ata_dummy_irq_on(struct ata_port *ap);
-extern u8 ata_irq_ack(struct ata_port *ap, unsigned int chk_drq);
-extern u8 ata_dummy_irq_ack(struct ata_port *ap, unsigned int chk_drq);
 
 extern int ata_cable_40wire(struct ata_port *ap);
 extern int ata_cable_80wire(struct ata_port *ap);

commit cb94c1cf5a6beffbd8935eb91227df0dd1987644
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jul 30 14:24:15 2007 +0900

    libata: add printf format attribute to ehi desc functions
    
    Tell the compiler that [__]ata_ehi_push_desc() functions take printf
    style format string and arguments.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 86cc0491b35e..b89d191ceb2b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -948,8 +948,10 @@ extern void ata_do_eh(struct ata_port *ap, ata_prereset_fn_t prereset,
 /*
  * ata_eh_info helpers
  */
-extern void __ata_ehi_push_desc(struct ata_eh_info *ehi, const char *fmt, ...);
-extern void ata_ehi_push_desc(struct ata_eh_info *ehi, const char *fmt, ...);
+extern void __ata_ehi_push_desc(struct ata_eh_info *ehi, const char *fmt, ...)
+	__attribute__ ((format (printf, 2, 3)));
+extern void ata_ehi_push_desc(struct ata_eh_info *ehi, const char *fmt, ...)
+	__attribute__ ((format (printf, 2, 3)));
 extern void ata_ehi_clear_desc(struct ata_eh_info *ehi);
 
 static inline void ata_ehi_schedule_probe(struct ata_eh_info *ehi)

commit 1552945669b4fb23bff8d3b30221bfe3ade63515
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jul 30 14:23:03 2007 +0900

    libata: use ata_port_printk() in ata_wait_idle()
    
    ata_wait_idle() identified controller by printing out the address of
    the Status register.  This is bogus because 1. it's iomapped address
    2. some controllers don't have Status register and don't initialize
    the field.  Use ata_port_printk() instead.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d98e8b50e20c..86cc0491b35e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1182,9 +1182,11 @@ static inline u8 ata_wait_idle(struct ata_port *ap)
 {
 	u8 status = ata_busy_wait(ap, ATA_BUSY | ATA_DRQ, 1000);
 
+#ifdef ATA_DEBUG
 	if (status != 0xff && (status & (ATA_BUSY | ATA_DRQ)))
-		DPRINTK("ATA: abnormal status 0x%X on port 0x%p\n",
-			status, ap->ioaddr.status_addr);
+		ata_port_printk(ap, KERN_DEBUG, "abnormal Status 0x%X\n",
+				status);
+#endif
 
 	return status;
 }

commit 2f2949680ad89d606db838340b17c30216c0bb0f
Author: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
Date:   Wed Aug 15 04:11:25 2007 -0400

    [libata] ahci: send event when AN received
    
    When we get an SDB FIS with the 'N' bit set, we should send
    an event to user space to indicate that there has been a
    media change.  This will be done via the scsi device.
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6dd5b437210d..d98e8b50e20c 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -755,6 +755,7 @@ extern void ata_host_init(struct ata_host *, struct device *,
 extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
 extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));
+extern void ata_scsi_media_change_notify(struct ata_device *atadev);
 extern void ata_sas_port_destroy(struct ata_port *);
 extern struct ata_port *ata_sas_port_alloc(struct ata_host *,
 					   struct ata_port_info *, struct Scsi_Host *);

commit 9f45cbd3f0fc597530aaf85cad7fe52cd63f1fd8
Author: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
Date:   Wed Aug 15 03:57:11 2007 -0400

    [libata] check for SATA async notify support
    
    Check to see if an ATAPI device supports Asynchronous Notification.
    If so, enable it, if the host controller supports AN.
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 7a1793bd2371..6dd5b437210d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -139,6 +139,7 @@ enum {
 	ATA_DFLAG_FLUSH_EXT	= (1 << 4), /* do FLUSH_EXT instead of FLUSH */
 	ATA_DFLAG_ACPI_PENDING	= (1 << 5), /* ACPI resume action pending */
 	ATA_DFLAG_ACPI_FAILED	= (1 << 6), /* ACPI on devcfg has failed */
+	ATA_DFLAG_AN		= (1 << 7), /* device supports AN */
 	ATA_DFLAG_CFG_MASK	= (1 << 8) - 1,
 
 	ATA_DFLAG_PIO		= (1 << 8), /* device limited to PIO mode */
@@ -179,6 +180,7 @@ enum {
 	ATA_FLAG_IGN_SIMPLEX	= (1 << 15), /* ignore SIMPLEX */
 	ATA_FLAG_NO_IORDY	= (1 << 16), /* controller lacks iordy */
 	ATA_FLAG_ACPI_SATA	= (1 << 17), /* need native SATA ACPI layout */
+	ATA_FLAG_AN		= (1 << 18), /* controller supports AN */
 
 	/* The following flag belongs to ap->pflags but is kept in
 	 * ap->flags because it's referenced in many LLDs and will be

commit 8989805d6d176aa32c0e9a68a536aa4c8ef5231c
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Aug 6 18:36:23 2007 +0900

    libata-link: add PMP links
    
    Add link->pmp, ap->nr_pmp_links, ap->pmp_link[], and implement/update
    link helpers.
    
    printk helpers are updated such that port and link are identifed as
    'ataP:' if no PMP is attached, while device is identified as
    'ataP.DD:'.  If PMP is attached, they become 'ataP:', 'ataP.LL:' and
    'ataP.LL' - ie. link and device are identified their PMP number.
    
    If PPM is attached (ap->nr_pmp_links != 0), ata_for_each_link()
    iterates over PMP links, while __ata_for_each_link() iterates over the
    host link + PMP links.  If PMP is not attached (ap->nr_pmp_links ==
    0), both iterate over only the host link.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index bfa155789993..7a1793bd2371 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -515,6 +515,7 @@ struct ata_acpi_gtm {
 
 struct ata_link {
 	struct ata_port		*ap;
+	int			pmp;		/* port multiplier port # */
 
 	unsigned int		active_tag;	/* active tag on this link */
 	u32			sactive;	/* active NCQ commands */
@@ -563,6 +564,9 @@ struct ata_port {
 
 	struct ata_link		link;	/* host default link */
 
+	int			nr_pmp_links;	/* nr of available PMP links */
+	struct ata_link		*pmp_link;	/* array of PMP links */
+
 	struct ata_port_stats	stats;
 	struct ata_host		*host;
 	struct device 		*dev;
@@ -926,11 +930,17 @@ extern void ata_do_eh(struct ata_port *ap, ata_prereset_fn_t prereset,
 #define ata_port_printk(ap, lv, fmt, args...) \
 	printk(lv"ata%u: "fmt, (ap)->print_id , ##args)
 
-#define ata_link_printk(link, lv, fmt, args...) \
-	printk(lv"ata%u: "fmt, (link)->ap->print_id , ##args)
+#define ata_link_printk(link, lv, fmt, args...) do { \
+	if ((link)->ap->nr_pmp_links) \
+		printk(lv"ata%u.%02u: "fmt, (link)->ap->print_id, \
+		       (link)->pmp , ##args); \
+	else \
+		printk(lv"ata%u: "fmt, (link)->ap->print_id , ##args); \
+	} while(0)
 
 #define ata_dev_printk(dev, lv, fmt, args...) \
-	printk(lv"ata%u.%02u: "fmt, (dev)->link->ap->print_id, (dev)->devno , ##args)
+	printk(lv"ata%u.%02u: "fmt, (dev)->link->ap->print_id, \
+	       (dev)->link->pmp + (dev)->devno , ##args)
 
 /*
  * ata_eh_info helpers
@@ -1039,15 +1049,46 @@ static inline unsigned int ata_dev_absent(const struct ata_device *dev)
 /*
  * link helpers
  */
+static inline int ata_is_host_link(const struct ata_link *link)
+{
+	return link == &link->ap->link;
+}
+
 static inline int ata_link_max_devices(const struct ata_link *link)
 {
-	if (link->ap->flags & ATA_FLAG_SLAVE_POSS)
+	if (ata_is_host_link(link) && link->ap->flags & ATA_FLAG_SLAVE_POSS)
 		return 2;
 	return 1;
 }
 
-#define ata_port_for_each_link(lk, ap) \
-	for ((lk) = &(ap)->link; (lk); (lk) = NULL)
+static inline struct ata_link *ata_port_first_link(struct ata_port *ap)
+{
+	if (ap->nr_pmp_links)
+		return ap->pmp_link;
+	return &ap->link;
+}
+
+static inline struct ata_link *ata_port_next_link(struct ata_link *link)
+{
+	struct ata_port *ap = link->ap;
+
+	if (link == &ap->link) {
+		if (!ap->nr_pmp_links)
+			return NULL;
+		return ap->pmp_link;
+	}
+
+	if (++link - ap->pmp_link < ap->nr_pmp_links)
+		return link;
+	return NULL;
+}
+
+#define __ata_port_for_each_link(lk, ap) \
+	for ((lk) = &(ap)->link; (lk); (lk) = ata_port_next_link(lk))
+
+#define ata_port_for_each_link(link, ap) \
+	for ((link) = ata_port_first_link(ap); (link); \
+	     (link) = ata_port_next_link(link))
 
 #define ata_link_for_each_dev(dev, link) \
 	for ((dev) = (link)->device; \

commit dbd826168d6267a26cf20cd233f6730f8d8047d6
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Aug 6 18:36:23 2007 +0900

    libata-link: implement ata_link_abort()
    
    Implement ata_link_abort().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 74ced08d5989..bfa155789993 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -906,6 +906,7 @@ extern unsigned long ata_pci_default_filter(struct ata_device *, unsigned long);
 extern void ata_eng_timeout(struct ata_port *ap);
 
 extern void ata_port_schedule_eh(struct ata_port *ap);
+extern int ata_link_abort(struct ata_link *link);
 extern int ata_port_abort(struct ata_port *ap);
 extern int ata_port_freeze(struct ata_port *ap);
 

commit 0c88758b5a6325428aaadab619886242db20ceae
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Aug 6 18:36:23 2007 +0900

    libata-link: make two port flags HRST_TO_RESUME and SKIP_D2H_BSY link flags
    
    HRST_TO_RESUME and SKIP_D2H_BSY are link attributes.  Move them to
    ata_link->flags.  This will allow host and PMP links to have different
    attributes.  ata_port_info->link_flags is added and used by LLDs to
    specify these flags during initialization.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 0f86d9be78ab..74ced08d5989 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -156,6 +156,11 @@ enum {
 	ATA_DEV_ATAPI_UNSUP	= 4,	/* ATAPI device (unsupported) */
 	ATA_DEV_NONE		= 5,	/* no device */
 
+	/* struct ata_link flags */
+	ATA_LFLAG_HRST_TO_RESUME = (1 << 0), /* hardreset to resume link */
+	ATA_LFLAG_SKIP_D2H_BSY	= (1 << 1), /* can't wait for the first D2H
+					     * Register FIS clearing BSY */
+
 	/* struct ata_port flags */
 	ATA_FLAG_SLAVE_POSS	= (1 << 0), /* host supports slave dev */
 					    /* (doesn't imply presence) */
@@ -170,9 +175,6 @@ enum {
 	ATA_FLAG_PIO_POLLING	= (1 << 9), /* use polling PIO if LLD
 					     * doesn't handle PIO interrupts */
 	ATA_FLAG_NCQ		= (1 << 10), /* host supports NCQ */
-	ATA_FLAG_HRST_TO_RESUME	= (1 << 11), /* hardreset to resume phy */
-	ATA_FLAG_SKIP_D2H_BSY	= (1 << 12), /* can't wait for the first D2H
-					      * Register FIS clearing BSY */
 	ATA_FLAG_DEBUGMSG	= (1 << 13),
 	ATA_FLAG_IGN_SIMPLEX	= (1 << 15), /* ignore SIMPLEX */
 	ATA_FLAG_NO_IORDY	= (1 << 16), /* controller lacks iordy */
@@ -517,6 +519,8 @@ struct ata_link {
 	unsigned int		active_tag;	/* active tag on this link */
 	u32			sactive;	/* active NCQ commands */
 
+	unsigned int		flags;		/* ATA_LFLAG_xxx */
+
 	unsigned int		hw_sata_spd_limit;
 	unsigned int		sata_spd_limit;
 	unsigned int		sata_spd;	/* current SATA PHY speed */
@@ -654,6 +658,7 @@ struct ata_port_operations {
 struct ata_port_info {
 	struct scsi_host_template	*sht;
 	unsigned long		flags;
+	unsigned long		link_flags;
 	unsigned long		pio_mask;
 	unsigned long		mwdma_mask;
 	unsigned long		udma_mask;

commit 0260731f0187840e272bfa10d3ba0f3e417976f5
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Aug 6 18:36:23 2007 +0900

    libata-link: linkify config/EH related functions
    
    Make the following functions deal with ata_link instead of ata_port.
    
    * ata_set_mode()
    * ata_eh_autopsy() and related functions
    * ata_eh_report() and related functions
    * suspend/resume related functions
    * ata_eh_recover() and related functions
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 25444dafae50..0f86d9be78ab 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -607,7 +607,7 @@ struct ata_port_operations {
 	void (*dev_select)(struct ata_port *ap, unsigned int device);
 
 	void (*phy_reset) (struct ata_port *ap); /* obsolete */
-	int  (*set_mode) (struct ata_port *ap, struct ata_device **r_failed_dev);
+	int  (*set_mode) (struct ata_link *link, struct ata_device **r_failed_dev);
 
 	int (*cable_detect) (struct ata_port *ap);
 
@@ -838,7 +838,7 @@ extern void ata_scsi_slave_destroy(struct scsi_device *sdev);
 extern int ata_scsi_change_queue_depth(struct scsi_device *sdev,
 				       int queue_depth);
 extern struct ata_device *ata_dev_pair(struct ata_device *adev);
-extern int ata_do_set_mode(struct ata_port *ap, struct ata_device **r_failed_dev);
+extern int ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
 extern u8 ata_irq_on(struct ata_port *ap);
 extern u8 ata_dummy_irq_on(struct ata_port *ap);
 extern u8 ata_irq_ack(struct ata_port *ap, unsigned int chk_drq);

commit cc0680a580b5be81a1ca321b58f8e9b80b5c1052
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Aug 6 18:36:23 2007 +0900

    libata-link: linkify reset
    
    Make reset methods and related functions deal with ata_link instead of
    ata_port.
    
    * ata_do_reset()
    * ata_eh_reset()
    * all prereset/reset/postreset methods and related functions
    
    This patch introduces no behavior change.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index e7882ba63e78..25444dafae50 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -333,14 +333,15 @@ enum ata_completion_errors {
 struct scsi_device;
 struct ata_port_operations;
 struct ata_port;
+struct ata_link;
 struct ata_queued_cmd;
 
 /* typedefs */
 typedef void (*ata_qc_cb_t) (struct ata_queued_cmd *qc);
-typedef int (*ata_prereset_fn_t)(struct ata_port *ap, unsigned long deadline);
-typedef int (*ata_reset_fn_t)(struct ata_port *ap, unsigned int *classes,
+typedef int (*ata_prereset_fn_t)(struct ata_link *link, unsigned long deadline);
+typedef int (*ata_reset_fn_t)(struct ata_link *link, unsigned int *classes,
 			      unsigned long deadline);
-typedef void (*ata_postreset_fn_t)(struct ata_port *ap, unsigned int *classes);
+typedef void (*ata_postreset_fn_t)(struct ata_link *link, unsigned int *classes);
 
 struct ata_ioports {
 	void __iomem		*cmd_addr;
@@ -706,14 +707,14 @@ extern int sata_link_debounce(struct ata_link *link,
 			const unsigned long *params, unsigned long deadline);
 extern int sata_link_resume(struct ata_link *link, const unsigned long *params,
 			    unsigned long deadline);
-extern int ata_std_prereset(struct ata_port *ap, unsigned long deadline);
-extern int ata_std_softreset(struct ata_port *ap, unsigned int *classes,
+extern int ata_std_prereset(struct ata_link *link, unsigned long deadline);
+extern int ata_std_softreset(struct ata_link *link, unsigned int *classes,
 			     unsigned long deadline);
-extern int sata_port_hardreset(struct ata_port *ap, const unsigned long *timing,
-			       unsigned long deadline);
-extern int sata_std_hardreset(struct ata_port *ap, unsigned int *class,
+extern int sata_link_hardreset(struct ata_link *link,
+			const unsigned long *timing, unsigned long deadline);
+extern int sata_std_hardreset(struct ata_link *link, unsigned int *class,
 			      unsigned long deadline);
-extern void ata_std_postreset(struct ata_port *ap, unsigned int *classes);
+extern void ata_std_postreset(struct ata_link *link, unsigned int *classes);
 extern void ata_port_disable(struct ata_port *);
 extern void ata_std_ports(struct ata_ioports *ioaddr);
 #ifdef CONFIG_PCI

commit 936fd7328657884d5a69a55666c74a55aa83ca27
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Aug 6 18:36:23 2007 +0900

    libata-link: linkify PHY-related functions
    
    Make the following PHY-related functions to deal with ata_link instead
    of ata_port.
    
    * sata_print_link_status()
    * sata_down_spd_limit()
    * ata_set_sata_spd_limit() and friends
    * sata_link_debounce/resume()
    * sata_scr_valid/read/write/write_flush()
    * ata_link_on/offline()
    
    This patch introduces no behavior change.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 62fa8cf677a1..e7882ba63e78 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -696,16 +696,16 @@ static inline int ata_port_is_dummy(struct ata_port *ap)
 	return ap->ops == &ata_dummy_port_ops;
 }
 
-extern void sata_print_link_status(struct ata_port *ap);
+extern void sata_print_link_status(struct ata_link *link);
 extern void ata_port_probe(struct ata_port *);
 extern void __sata_phy_reset(struct ata_port *ap);
 extern void sata_phy_reset(struct ata_port *ap);
 extern void ata_bus_reset(struct ata_port *ap);
-extern int sata_set_spd(struct ata_port *ap);
-extern int sata_phy_debounce(struct ata_port *ap, const unsigned long *param,
-			     unsigned long deadline);
-extern int sata_phy_resume(struct ata_port *ap, const unsigned long *param,
-			   unsigned long deadline);
+extern int sata_set_spd(struct ata_link *link);
+extern int sata_link_debounce(struct ata_link *link,
+			const unsigned long *params, unsigned long deadline);
+extern int sata_link_resume(struct ata_link *link, const unsigned long *params,
+			    unsigned long deadline);
 extern int ata_std_prereset(struct ata_port *ap, unsigned long deadline);
 extern int ata_std_softreset(struct ata_port *ap, unsigned int *classes,
 			     unsigned long deadline);
@@ -753,12 +753,12 @@ extern int ata_sas_slave_configure(struct scsi_device *, struct ata_port *);
 extern int ata_sas_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *),
 			    struct ata_port *ap);
 extern unsigned int ata_host_intr(struct ata_port *ap, struct ata_queued_cmd *qc);
-extern int sata_scr_valid(struct ata_port *ap);
-extern int sata_scr_read(struct ata_port *ap, int reg, u32 *val);
-extern int sata_scr_write(struct ata_port *ap, int reg, u32 val);
-extern int sata_scr_write_flush(struct ata_port *ap, int reg, u32 val);
-extern int ata_port_online(struct ata_port *ap);
-extern int ata_port_offline(struct ata_port *ap);
+extern int sata_scr_valid(struct ata_link *link);
+extern int sata_scr_read(struct ata_link *link, int reg, u32 *val);
+extern int sata_scr_write(struct ata_link *link, int reg, u32 val);
+extern int sata_scr_write_flush(struct ata_link *link, int reg, u32 val);
+extern int ata_link_online(struct ata_link *link);
+extern int ata_link_offline(struct ata_link *link);
 #ifdef CONFIG_PM
 extern int ata_host_suspend(struct ata_host *host, pm_message_t mesg);
 extern void ata_host_resume(struct ata_host *host);

commit f58229f8060055b08b34008ea08f31de1e2f003c
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Aug 6 18:36:23 2007 +0900

    libata-link: implement and use link/device iterators
    
    Multiple links and different number of devices per link should be
    considered to iterate over links and devices.  This patch implements
    and uses link and device iterators - ata_port_for_each_link() and
    ata_link_for_each_dev() - and ata_link_max_devices().
    
    This change makes a lot of functions iterate over only possible
    devices instead of from dev 0 to dev ATA_MAX_DEVICES.  All such
    changes have been examined and nothing should be broken.
    
    While at it, add a separating comment before device helpers to
    distinguish them better from link helpers and others.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ca4493125fa0..62fa8cf677a1 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1030,15 +1030,26 @@ static inline unsigned int ata_dev_absent(const struct ata_device *dev)
 }
 
 /*
- * port helpers
+ * link helpers
  */
-static inline int ata_port_max_devices(const struct ata_port *ap)
+static inline int ata_link_max_devices(const struct ata_link *link)
 {
-	if (ap->flags & ATA_FLAG_SLAVE_POSS)
+	if (link->ap->flags & ATA_FLAG_SLAVE_POSS)
 		return 2;
 	return 1;
 }
 
+#define ata_port_for_each_link(lk, ap) \
+	for ((lk) = &(ap)->link; (lk); (lk) = NULL)
+
+#define ata_link_for_each_dev(dev, link) \
+	for ((dev) = (link)->device; \
+	     (dev) < (link)->device + ata_link_max_devices(link) || ((dev) = NULL); \
+	     (dev)++)
+
+#define ata_link_for_each_dev_reverse(dev, link) \
+	for ((dev) = (link)->device + ata_link_max_devices(link) - 1; \
+	     (dev) >= (link)->device || ((dev) = NULL); (dev)--)
 
 static inline u8 ata_chk_status(struct ata_port *ap)
 {

commit 9af5c9c97dc9d599281778864c72b385f0c63341
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Aug 6 18:36:22 2007 +0900

    libata-link: introduce ata_link
    
    Introduce ata_link.  It abstracts PHY and sits between ata_port and
    ata_device.  This new level of abstraction is necessary to support
    SATA Port Multiplier, which basically adds a bunch of links (PHYs) to
    a ATA host port.  Fields related to command execution, spd_limit and
    EH are per-link and thus moved to ata_link.
    
    This patch only defines the host link.  Multiple link handling will be
    added later.  Also, a lot of ap->link derefences are added but many of
    them will be removed as each part is converted to deal directly with
    ata_link instead of ata_port.
    
    This patch introduces no behavior change.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: James Bottomley <James.Bottomley@SteelEye.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a67bb9075e9b..ca4493125fa0 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -436,7 +436,7 @@ struct ata_ering {
 };
 
 struct ata_device {
-	struct ata_port		*ap;
+	struct ata_link		*link;
 	unsigned int		devno;		/* 0 or 1 */
 	unsigned long		flags;		/* ATA_DFLAG_xxx */
 	unsigned int		horkage;	/* List of broken features */
@@ -510,6 +510,24 @@ struct ata_acpi_gtm {
 	u32 flags;
 } __packed;
 
+struct ata_link {
+	struct ata_port		*ap;
+
+	unsigned int		active_tag;	/* active tag on this link */
+	u32			sactive;	/* active NCQ commands */
+
+	unsigned int		hw_sata_spd_limit;
+	unsigned int		sata_spd_limit;
+	unsigned int		sata_spd;	/* current SATA PHY speed */
+
+	/* record runtime error info, protected by host_set lock */
+	struct ata_eh_info	eh_info;
+	/* EH context */
+	struct ata_eh_context	eh_context;
+
+	struct ata_device	device[ATA_MAX_DEVICES];
+};
+
 struct ata_port {
 	struct Scsi_Host	*scsi_host; /* our co-allocated scsi host */
 	const struct ata_port_operations *ops;
@@ -533,23 +551,12 @@ struct ata_port {
 	unsigned int		mwdma_mask;
 	unsigned int		udma_mask;
 	unsigned int		cbl;	/* cable type; ATA_CBL_xxx */
-	unsigned int		hw_sata_spd_limit;
-	unsigned int		sata_spd_limit;	/* SATA PHY speed limit */
-	unsigned int		sata_spd;	/* current SATA PHY speed */
-
-	/* record runtime error info, protected by host lock */
-	struct ata_eh_info	eh_info;
-	/* EH context owned by EH */
-	struct ata_eh_context	eh_context;
-
-	struct ata_device	device[ATA_MAX_DEVICES];
 
 	struct ata_queued_cmd	qcmd[ATA_MAX_QUEUE];
 	unsigned long		qc_allocated;
 	unsigned int		qc_active;
 
-	unsigned int		active_tag;
-	u32			sactive;
+	struct ata_link		link;	/* host default link */
 
 	struct ata_port_stats	stats;
 	struct ata_host		*host;
@@ -912,8 +919,11 @@ extern void ata_do_eh(struct ata_port *ap, ata_prereset_fn_t prereset,
 #define ata_port_printk(ap, lv, fmt, args...) \
 	printk(lv"ata%u: "fmt, (ap)->print_id , ##args)
 
+#define ata_link_printk(link, lv, fmt, args...) \
+	printk(lv"ata%u: "fmt, (link)->ap->print_id , ##args)
+
 #define ata_dev_printk(dev, lv, fmt, args...) \
-	printk(lv"ata%u.%02u: "fmt, (dev)->ap->print_id, (dev)->devno , ##args)
+	printk(lv"ata%u.%02u: "fmt, (dev)->link->ap->print_id, (dev)->devno , ##args)
 
 /*
  * ata_eh_info helpers
@@ -1149,7 +1159,7 @@ static inline void ata_tf_init(struct ata_device *dev, struct ata_taskfile *tf)
 {
 	memset(tf, 0, sizeof(*tf));
 
-	tf->ctl = dev->ap->ctl;
+	tf->ctl = dev->link->ap->ctl;
 	if (dev->devno == 0)
 		tf->device = ATA_DEVICE_OBS;
 	else

commit 16c55b038033d8f6f7601996dfae44399666d9ab
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Aug 29 11:58:33 2007 +0900

    libata: implement BROKEN_HPA horkage and apply it to affected drives
    
    Some drives choke on READ_NATIVE_MAX_ADDRESS[_EXT].  Implement
    ATA_HORKAGE_BROKEN_HPA and apply it to affected drives.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 41978a557318..a67bb9075e9b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -303,6 +303,7 @@ enum {
 	ATA_HORKAGE_NODMA	= (1 << 1),	/* DMA problems */
 	ATA_HORKAGE_NONCQ	= (1 << 2),	/* Don't use NCQ */
 	ATA_HORKAGE_MAX_SEC_128	= (1 << 3),	/* Limit max sects to 128 */
+	ATA_HORKAGE_BROKEN_HPA	= (1 << 4),	/* Broken HPA */
 };
 
 enum hsm_task_states {

commit b8b275efc28e34f9b1d1e382d0b02dfa381b2a79
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Jul 10 15:55:43 2007 +0900

    ata_piix: fix suspend/resume for some TOSHIBA laptops
    
    ACPI implementations in several TOSHIBA laptops are weird and burn cpu
    cycles for tens of seconds while trying to suspend if the PCI device
    for the ATA controller is disabled when the ACPI suspend is called.
    
    This patch uses DMI to match those machines and bypass device disable
    on those machines during suspend.  As the device needs to be put into
    enabled state on resume without affecting PCI enable count, matching
    resume callback uses __pci_reenable_device().
    
    This bug is reported in bugzilla bug 7780.
    
      http://bugzilla.kernel.org/show_bug.cgi?id=7780
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 9aa6c10f7bb1..41978a557318 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -216,6 +216,8 @@ enum {
 	ATA_HOST_SIMPLEX	= (1 << 0),	/* Host is simplex, one DMA channel per host only */
 	ATA_HOST_STARTED	= (1 << 1),	/* Host started */
 
+	/* bits 24:31 of host->flags are reserved for LLD specific flags */
+
 	/* various lengths of time */
 	ATA_TMOUT_BOOT		= 30 * HZ,	/* heuristic */
 	ATA_TMOUT_BOOT_QUICK	= 7 * HZ,	/* heuristic */

commit e6f194d8f6f50da6837af637b2fd839c34185f7a
Merge: 7578634990fb b91421749a18
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Sun Jul 22 11:36:49 2007 -0700

    Merge master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6
    
    * master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6: (60 commits)
      [SCSI] libsas: make ATA functions selectable by a config option
      [SCSI] bsg: unexport sg v3 helper functions
      [SCSI] bsg: fix bsg_unregister_queue
      [SCSI] bsg: make class backlinks
      [SCSI] 3w-9xxx: add support for 9690SA
      [SCSI] bsg: fix bsg_register_queue error path
      [SCSI] ESP: Increase ESP_BUS_TIMEOUT to 275.
      [SCSI] libsas: fix scr_read/write users and update the libata documentation
      [SCSI] mpt fusion: update Kconfig help
      [SCSI] scsi_transport_sas: add destructor for bsg
      [SCSI] iscsi_tcp: buggered kmalloc()
      [SCSI] qla2xxx: Update version number to 8.02.00-k2.
      [SCSI] qla2xxx: Add ISP25XX support.
      [SCSI] qla2xxx: Use pci_try_set_mwi().
      [SCSI] qla2xxx: Use PCI-X/PCI-Express read control interfaces.
      [SCSI] qla2xxx: Re-factor isp_operations to static structures.
      [SCSI] qla2xxx: Validate mid-layer 'underflow' during check-condition handling.
      [SCSI] qla2xxx: Correct setting of 'current' and 'supported' speeds during FDMI registration.
      [SCSI] qla2xxx: Generalize iIDMA support.
      [SCSI] qla2xxx: Generalize FW-Interface-2 support.
      ...

commit 5ddf24c5ea9d715dc4f5d5d5dd1c9337d90466dc
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jul 16 14:29:41 2007 +0900

    libata: implement EH fast drain
    
    In most cases, when EH is scheduled, all in-flight commands are
    aborted causing EH to kick in immediately.  However, in some cases
    (especially with PMP), it's unclear which commands are affected by the
    error condition and although aborting all in-flight commands work, it
    isn't optimal and may cause unnecessary disruption.  On the other
    hand, waiting for in-flight commands to drain themselves can take up
    to 30seconds.
    
    This patch implements EH fast drain to handle such situations.  It
    gives in-flight commands some time to finish up but doesn't wait for
    too long.  After EH is scheduled, fast drain timer is started and if
    no other completion occurs in ATA_EH_FASTDRAIN_INTERVAL all in-flight
    commands are aborted.  If any completion occurred in the interval, the
    port is given another interval to finish up itself.
    
    Currently ATA_EH_FASTDRAIN_INTERVAL is 3 secs which should be enough
    for finishing up most commands.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 74800ad6d81f..be5a43928c84 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -565,6 +565,9 @@ struct ata_port {
 	pm_message_t		pm_mesg;
 	int			*pm_result;
 
+	struct timer_list	fastdrain_timer;
+	unsigned long		fastdrain_cnt;
+
 	void			*private_data;
 
 #ifdef CONFIG_ATA_ACPI

commit f8f1e1cc0cd4d75c73e9a55a0ede8958e4fa14f1
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jul 16 14:29:40 2007 +0900

    libata: reorganize ata_ehi_hotplugged()
    
    __ata_ehi_hotplugged() now has no users.  Regorganize
    ata_ehi_hotplugged() such that a new function ata_ehi_schedule_probe()
    deals with scheduling probing.  ata_ehi_hotplugged() calls it and
    additionally marks hotplug specific flags.  ata_ehi_schedule_probe()
    will be used laster.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 16ebdf152c75..74800ad6d81f 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -915,16 +915,17 @@ extern void __ata_ehi_push_desc(struct ata_eh_info *ehi, const char *fmt, ...);
 extern void ata_ehi_push_desc(struct ata_eh_info *ehi, const char *fmt, ...);
 extern void ata_ehi_clear_desc(struct ata_eh_info *ehi);
 
-static inline void __ata_ehi_hotplugged(struct ata_eh_info *ehi)
+static inline void ata_ehi_schedule_probe(struct ata_eh_info *ehi)
 {
-	ehi->flags |= ATA_EHI_HOTPLUGGED | ATA_EHI_RESUME_LINK;
+	ehi->flags |= ATA_EHI_RESUME_LINK;
 	ehi->action |= ATA_EH_SOFTRESET;
 	ehi->probe_mask |= (1 << ATA_MAX_DEVICES) - 1;
 }
 
 static inline void ata_ehi_hotplugged(struct ata_eh_info *ehi)
 {
-	__ata_ehi_hotplugged(ehi);
+	ata_ehi_schedule_probe(ehi);
+	ehi->flags |= ATA_EHI_HOTPLUGGED;
 	ehi->err_mask |= AC_ERR_ATA_BUS;
 }
 

commit 008a78961ec72990d09d7625ef9499d7317d040d
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jul 16 14:29:40 2007 +0900

    libata: improve SATA PHY speed down logic
    
    sata_down_spd_limit() first reads the current SPD from SStatus and
    limit the speed to the lower one of one below the current limit or one
    below the current SPD in SStatus.  SPD may not be accessible or valid
    when SPD down is requested making sata_down_spd_limit() fail when it's
    most needed.
    
    This patch makes the current SPD cached after each successful reset
    and forces GEN I speed (1.5Gbps) if neither of SStatus or the cached
    value is valid, so sata_down_spd_limit() is now guaranteed to lower
    the speed limit if lower speed is available.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c732b3e78e28..16ebdf152c75 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -531,6 +531,7 @@ struct ata_port {
 	unsigned int		cbl;	/* cable type; ATA_CBL_xxx */
 	unsigned int		hw_sata_spd_limit;
 	unsigned int		sata_spd_limit;	/* SATA PHY speed limit */
+	unsigned int		sata_spd;	/* current SATA PHY speed */
 
 	/* record runtime error info, protected by host lock */
 	struct ata_eh_info	eh_info;

commit da3dbb17a0e9a9ec7f5aed95f1fddadb790edc9d
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jul 16 14:29:40 2007 +0900

    libata: make ->scr_read/write callbacks return error code
    
    Convert ->scr_read/write callbacks to return error code to better
    indicate failure.  This will help handling of SCR_NOTIFICATION.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index cb181713d9b5..c732b3e78e28 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -620,9 +620,8 @@ struct ata_port_operations {
 	u8 (*irq_on) (struct ata_port *);
 	u8 (*irq_ack) (struct ata_port *ap, unsigned int chk_drq);
 
-	u32 (*scr_read) (struct ata_port *ap, unsigned int sc_reg);
-	void (*scr_write) (struct ata_port *ap, unsigned int sc_reg,
-			   u32 val);
+	int (*scr_read) (struct ata_port *ap, unsigned int sc_reg, u32 *val);
+	int (*scr_write) (struct ata_port *ap, unsigned int sc_reg, u32 val);
 
 	int (*port_suspend) (struct ata_port *ap, pm_message_t mesg);
 	int (*port_resume) (struct ata_port *ap);

commit 5335b729064e03319cd2d5219770451dbb1d7f67
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jul 16 14:29:40 2007 +0900

    libata: implement AC_ERR_NCQ
    
    When an NCQ command fails, all commands in flight are aborted and the
    offending one is reported using log page 10h.  Depending on controller
    characteristics and LLD implementation, all commands may appear as
    having a device error due to shared TF status making it hard to
    determine what's actually going on.
    
    This patch adds AC_ERR_NCQ, marks the command reported by log page 10h
    with it and print extra "<F>" after the error report for the command
    to help distinguishing the offending command.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 94b37d180680..cb181713d9b5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -323,6 +323,7 @@ enum ata_completion_errors {
 	AC_ERR_INVALID		= (1 << 7), /* invalid argument */
 	AC_ERR_OTHER		= (1 << 8), /* unknown */
 	AC_ERR_NODEV_HINT	= (1 << 9), /* polling device detection hint */
+	AC_ERR_NCQ		= (1 << 10), /* marker for offending NCQ qc */
 };
 
 /* forward declarations */

commit b64bbc39f2122a2276578e40144af69ef01decd4
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jul 16 14:29:39 2007 +0900

    libata: improve EH report formatting
    
    Requiring LLDs to format multiple error description messages properly
    doesn't work too well.  Help LLDs a bit by making ata_ehi_push_desc()
    insert ", " on each invocation.  __ata_ehi_push_desc() is the raw
    version without the automatic separator.
    
    While at it, make ehi_desc interface proper functions instead of
    macros.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 5d3df6cde272..94b37d180680 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -910,16 +910,9 @@ extern void ata_do_eh(struct ata_port *ap, ata_prereset_fn_t prereset,
 /*
  * ata_eh_info helpers
  */
-#define ata_ehi_push_desc(ehi, fmt, args...) do { \
-	(ehi)->desc_len += scnprintf((ehi)->desc + (ehi)->desc_len, \
-				     ATA_EH_DESC_LEN - (ehi)->desc_len, \
-				     fmt , ##args); \
-} while (0)
-
-#define ata_ehi_clear_desc(ehi) do { \
-	(ehi)->desc[0] = '\0'; \
-	(ehi)->desc_len = 0; \
-} while (0)
+extern void __ata_ehi_push_desc(struct ata_eh_info *ehi, const char *fmt, ...);
+extern void ata_ehi_push_desc(struct ata_eh_info *ehi, const char *fmt, ...);
+extern void ata_ehi_clear_desc(struct ata_eh_info *ehi);
 
 static inline void __ata_ehi_hotplugged(struct ata_eh_info *ehi)
 {

commit 9977126c4b65c1396b665f7a0eeb8c7dede336f9
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jul 16 14:29:38 2007 +0900

    libata: add @is_cmd to ata_tf_to_fis()
    
    Add @is_cmd to ata_tf_to_fis().  This controls bit 7 of the second
    byte which tells the device whether this H2D FIS is for a command or
    not.  This cleans up ahci a bit and will be used by PMP.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 47cd2a1c5544..5d3df6cde272 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -764,7 +764,8 @@ extern unsigned int ata_dev_try_classify(struct ata_port *, unsigned int, u8 *);
  */
 extern void ata_tf_load(struct ata_port *ap, const struct ata_taskfile *tf);
 extern void ata_tf_read(struct ata_port *ap, struct ata_taskfile *tf);
-extern void ata_tf_to_fis(const struct ata_taskfile *tf, u8 *fis, u8 pmp);
+extern void ata_tf_to_fis(const struct ata_taskfile *tf,
+			  u8 pmp, int is_cmd, u8 *fis);
 extern void ata_tf_from_fis(const u8 *fis, struct ata_taskfile *tf);
 extern void ata_noop_dev_select (struct ata_port *ap, unsigned int device);
 extern void ata_std_dev_select (struct ata_port *ap, unsigned int device);

commit 1c50dc83f9ca752b1e1b985f1ce33d2695103ffa
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Tue Jan 30 01:18:41 2007 -0800

    [SCSI] sas_ata: ata_post_internal should abort the sas_task
    
    This patch adds a new field, lldd_task, to ata_queued_cmd so that libata
    users such as libsas can associate some data with a qc.  The particular
    ambition with this patch is to associate a sas_task with a qc; that way,
    if libata decides to timeout a command, we can come back (in
    sas_ata_post_internal) and abort the sas task.
    
    One question remains: Is it necessary to reset the phy on error, or will
    the libata error handler take care of it?  (Assuming that one is written,
    of course.)  This patch, as it is today, works well enough to clean
    things up when an ATA device probe attempt fails halfway through the probe,
    though I'm not sure this is always the right thing to do.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 47cd2a1c5544..4abb758a0450 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -411,6 +411,7 @@ struct ata_queued_cmd {
 	ata_qc_cb_t		complete_fn;
 
 	void			*private_data;
+	void			*lldd_task;
 };
 
 struct ata_port_stats {

commit 75683fe7153c3817bb4fd4491e2a5913af6c463e
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Jul 5 13:31:27 2007 +0900

    libata: clean up horkage handling
    
    Horkage handling had the following problems.
    
    * dev->horkage was positioned after ATA_DEVICE_CLEAR_OFFSET, so it was
      cleared before the device is configured.  This broke
      HORKAGE_DIAGNOSTIC.
    
    * Some used dev->horkage while others called ata_device_blacklisted()
      directly.  This was at best confusing.
    
    This patch moves dev->horkage right after dev->flags and set the field
    according to the blacklist during device configuration.  All users
    test against dev->horkage.  ata_device_blacklisted() now has only one
    user, make it static.  While at it, rename it to ata_dev_blacklisted()
    for consistency.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 0c8b6578bd59..47cd2a1c5544 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -434,6 +434,7 @@ struct ata_device {
 	struct ata_port		*ap;
 	unsigned int		devno;		/* 0 or 1 */
 	unsigned long		flags;		/* ATA_DFLAG_xxx */
+	unsigned int		horkage;	/* List of broken features */
 	struct scsi_device	*sdev;		/* attached SCSI device */
 #ifdef CONFIG_ATA_ACPI
 	acpi_handle		acpi_handle;
@@ -465,7 +466,6 @@ struct ata_device {
 	/* error history */
 	struct ata_ering	ering;
 	int			spdn_cnt;
-	unsigned int		horkage;	/* List of broken features */
 };
 
 /* Offset into struct ata_device.  Fields above it are maintained
@@ -793,7 +793,6 @@ extern void ata_id_string(const u16 *id, unsigned char *s,
 extern void ata_id_c_string(const u16 *id, unsigned char *s,
 			    unsigned int ofs, unsigned int len);
 extern void ata_id_to_dma_mode(struct ata_device *dev, u8 unknown);
-extern unsigned long ata_device_blacklisted(const struct ata_device *dev);
 extern void ata_bmdma_setup (struct ata_queued_cmd *qc);
 extern void ata_bmdma_start (struct ata_queued_cmd *qc);
 extern void ata_bmdma_stop(struct ata_queued_cmd *qc);

commit d583bc18812f8da52bf25eef9cd111e5fd46a6ab
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Jul 4 18:02:07 2007 +0900

    libata: simplify PCI legacy SFF host handling
    
    With PCI resource fix up for legacy hosts.  We can use the same code
    path to allocate IO resources and initialize host for both legacy and
    native SFF hosts.  Only IRQ requesting needs to be different.
    
    Rename ata_pci_*_native_host() to ata_pci_*_sff_host(), kill all
    legacy specific functions and use the renamed functions instead.  This
    simplifies code a lot.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index bf98d44c8109..0c8b6578bd59 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -870,11 +870,11 @@ struct pci_bits {
 	unsigned long		val;
 };
 
-extern int ata_pci_init_native_host(struct ata_host *host);
+extern int ata_pci_init_sff_host(struct ata_host *host);
 extern int ata_pci_init_bmdma(struct ata_host *host);
-extern int ata_pci_prepare_native_host(struct pci_dev *pdev,
-				const struct ata_port_info * const * ppi,
-				struct ata_host **r_host);
+extern int ata_pci_prepare_sff_host(struct pci_dev *pdev,
+				    const struct ata_port_info * const * ppi,
+				    struct ata_host **r_host);
 extern int pci_test_config_bits(struct pci_dev *pdev, const struct pci_bits *bits);
 extern unsigned long ata_pci_default_filter(struct ata_device *, unsigned long);
 #endif /* CONFIG_PCI */

commit 45a66c1c3ff88e8050dd25e81bafdf79a12a8042
Author: Oleg Nesterov <oleg@tv-sign.ru>
Date:   Mon Jul 9 11:46:13 2007 -0700

    libata-core: convert to use cancel_rearming_delayed_work()
    
    We should not use cancel_work_sync(delayed_work->work). This works, but not
    good. We can use cancel_rearming_delayed_work(), this also simplifies the
    code.
    
    Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a3df64677ac3..bf98d44c8109 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -196,7 +196,6 @@ enum {
 	ATA_PFLAG_SCSI_HOTPLUG	= (1 << 6), /* SCSI hotplug scheduled */
 	ATA_PFLAG_INITIALIZING	= (1 << 7), /* being initialized, don't touch */
 
-	ATA_PFLAG_FLUSH_PORT_TASK = (1 << 16), /* flush port task */
 	ATA_PFLAG_SUSPENDED	= (1 << 17), /* port is suspended (power) */
 	ATA_PFLAG_PM_PENDING	= (1 << 18), /* PM operation pending */
 	ATA_PFLAG_GTM_VALID	= (1 << 19), /* acpi_gtm data valid */

commit d26fc9551a15fdad0d5de8376a78816b8af44f00
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Fri Jul 6 19:13:52 2007 -0400

    libata: Support chips with 64K PRD quirk
    
    Add ata_dumb_qc_prep and supporting logic so that a driver can just
    specify it needs to be helped in this area. 64K entries are split
    as with drivers/ide.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 8d3e391ab8d3..a3df64677ac3 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -116,6 +116,7 @@ static inline struct device *pci_dev_to_dev(struct pci_dev *pdev)
 enum {
 	/* various global constants */
 	LIBATA_MAX_PRD		= ATA_MAX_PRD / 2,
+	LIBATA_DUMB_MAX_PRD	= ATA_MAX_PRD / 4,	/* Worst case */
 	ATA_MAX_PORTS		= 8,
 	ATA_DEF_QUEUE		= 1,
 	/* tag ATA_MAX_QUEUE - 1 is reserved for internal commands */
@@ -778,6 +779,7 @@ extern void ata_data_xfer(struct ata_device *adev, unsigned char *buf,
 			  unsigned int buflen, int write_data);
 extern void ata_data_xfer_noirq(struct ata_device *adev, unsigned char *buf,
 				unsigned int buflen, int write_data);
+extern void ata_dumb_qc_prep(struct ata_queued_cmd *qc);
 extern void ata_qc_prep(struct ata_queued_cmd *qc);
 extern void ata_noop_qc_prep(struct ata_queued_cmd *qc);
 extern unsigned int ata_qc_issue_prot(struct ata_queued_cmd *qc);

commit 64578a3de723d502621860f9d4d28f34d001b066
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue May 15 03:28:16 2007 +0900

    libata-acpi: implement _GTM/_STM support
    
    Implement _GTM/_STM support.  acpi_gtm is added to ata_port which
    stores _GTM parameters over suspend/resume cycle.  A new hook
    ata_acpi_on_suspend() is responsible for storing _GTM parameters
    during suspend.  _STM is executed in ata_acpi_on_resume().  With this
    change, invoking _GTF is safe on IDE hierarchy and acpi_sata check
    before _GTF is removed.
    
    ata_acpi_gtm() and ata_acpi_stm() implementation is taken from Alan
    Cox's pata_acpi implementation.  ata_acpi_gtm() is fixed such that the
    result parameter is not shifted by sizeof(union acpi_object).
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 0c4f63b55ec6..8d3e391ab8d3 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -198,6 +198,7 @@ enum {
 	ATA_PFLAG_FLUSH_PORT_TASK = (1 << 16), /* flush port task */
 	ATA_PFLAG_SUSPENDED	= (1 << 17), /* port is suspended (power) */
 	ATA_PFLAG_PM_PENDING	= (1 << 18), /* PM operation pending */
+	ATA_PFLAG_GTM_VALID	= (1 << 19), /* acpi_gtm data valid */
 
 	/* struct ata_queued_cmd flags */
 	ATA_QCFLAG_ACTIVE	= (1 << 0), /* cmd not yet ack'd to scsi lyer */
@@ -493,6 +494,17 @@ struct ata_eh_context {
 	unsigned int		did_probe_mask;
 };
 
+struct ata_acpi_drive
+{
+	u32 pio;
+	u32 dma;
+} __packed;
+
+struct ata_acpi_gtm {
+	struct ata_acpi_drive drive[2];
+	u32 flags;
+} __packed;
+
 struct ata_port {
 	struct Scsi_Host	*scsi_host; /* our co-allocated scsi host */
 	const struct ata_port_operations *ops;
@@ -555,6 +567,7 @@ struct ata_port {
 
 #ifdef CONFIG_ATA_ACPI
 	acpi_handle		acpi_handle;
+	struct ata_acpi_gtm	acpi_gtm;
 #endif
 	u8			sector_buf[ATA_SECT_SIZE]; /* owned by EH */
 };

commit 6746544c3b143ca7071d144f1882ccbe1f47b08d
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue May 15 03:28:16 2007 +0900

    libata: reimplement ACPI invocation
    
    This patch reimplements ACPI invocation such that, instead of
    exporting ACPI details to the rest of libata, ACPI event handlers -
    ata_acpi_on_resume() and ata_acpi_on_devcfg() - are used.  These two
    functions are responsible for determining whether specific ACPI method
    is used and when.
    
    On resume, _GTF is scheduled by setting ATA_DFLAG_ACPI_PENDING device
    flag.  This is done this way to avoid performing the action on wrong
    device device (device swapping while suspended).
    
    On every ata_dev_configure(), ata_acpi_on_devcfg() is called, which
    performs _SDD and _GTF.  _GTF is performed only after resuming and, if
    SATA, hardreset as the ACPI spec specifies.  As _GTF may contain
    arbitrary commands, IDENTIFY page is re-read after _GTF taskfiles are
    executed.
    
    If one of ACPI methods fails, ata_acpi_on_devcfg() retries on the
    first failure.  If it fails again on the second try, ACPI is disabled
    on the device.  Note that successful configuration clears ACPI failed
    status.
    
    With all feature checks moved to the above two functions,
    do_drive_set_taskfiles() is trivial and thus collapsed into
    ata_acpi_exec_tfs(), which is now static and converted to return the
    number of executed taskfiles to be used by ata_acpi_on_resume().  As
    failures are handled properly, ata_acpi_push_id() now returns -errno
    on errors instead of unconditional zero.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d758168ee45d..0c4f63b55ec6 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -136,6 +136,8 @@ enum {
 	ATA_DFLAG_CDB_INTR	= (1 << 2), /* device asserts INTRQ when ready for CDB */
 	ATA_DFLAG_NCQ		= (1 << 3), /* device supports NCQ */
 	ATA_DFLAG_FLUSH_EXT	= (1 << 4), /* do FLUSH_EXT instead of FLUSH */
+	ATA_DFLAG_ACPI_PENDING	= (1 << 5), /* ACPI resume action pending */
+	ATA_DFLAG_ACPI_FAILED	= (1 << 6), /* ACPI on devcfg has failed */
 	ATA_DFLAG_CFG_MASK	= (1 << 8) - 1,
 
 	ATA_DFLAG_PIO		= (1 << 8), /* device limited to PIO mode */

commit fafbae87db88a73b166d3bc3294d209207f27056
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue May 15 03:28:16 2007 +0900

    libata-acpi: implement ata_acpi_associate()
    
    * Add acpi_handle to ata_host and ata_port.  Rename
      ata_device->obj_handle to ->acpi_handle and move it above such that
      it doesn't get cleared on reconfiguration.
    
    * Replace ACPI node association which ata_acpi_associate() which is
      called once during host initialization.  Unlike the previous
      implementation, ata_acpi_associate() uses ATA_FLAG_ACPI_SATA to
      choose between IDE or SATA ACPI hierarchy and uses simple child look
      up instead of recursive walk to match the nodes.  This is way safer
      and simpler.  Please read the following message for more info.
    
      http://article.gmane.org/gmane.linux.ide/17554
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 620da7be07b7..d758168ee45d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -363,6 +363,9 @@ struct ata_host {
 	void			*private_data;
 	const struct ata_port_operations *ops;
 	unsigned long		flags;
+#ifdef CONFIG_ATA_ACPI
+	acpi_handle		acpi_handle;
+#endif
 	struct ata_port		*simplex_claimed;	/* channel owning the DMA */
 	struct ata_port		*ports[0];
 };
@@ -429,6 +432,9 @@ struct ata_device {
 	unsigned int		devno;		/* 0 or 1 */
 	unsigned long		flags;		/* ATA_DFLAG_xxx */
 	struct scsi_device	*sdev;		/* attached SCSI device */
+#ifdef CONFIG_ATA_ACPI
+	acpi_handle		acpi_handle;
+#endif
 	/* n_sector is used as CLEAR_OFFSET, read comment above CLEAR_OFFSET */
 	u64			n_sectors;	/* size of device, if ATA */
 	unsigned int		class;		/* ATA_DEV_xxx */
@@ -457,10 +463,6 @@ struct ata_device {
 	struct ata_ering	ering;
 	int			spdn_cnt;
 	unsigned int		horkage;	/* List of broken features */
-#ifdef CONFIG_ATA_ACPI
-	/* ACPI objects info */
-	acpi_handle obj_handle;
-#endif
 };
 
 /* Offset into struct ata_device.  Fields above it are maintained
@@ -549,6 +551,9 @@ struct ata_port {
 
 	void			*private_data;
 
+#ifdef CONFIG_ATA_ACPI
+	acpi_handle		acpi_handle;
+#endif
 	u8			sector_buf[ATA_SECT_SIZE]; /* owned by EH */
 };
 

commit 40a1d531f6c894b298e784fd2090d87633e4989a
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Jun 27 02:49:38 2007 +0900

    libata: kill ATA_HORKAGE_DMA_RW_ONLY
    
    ATA_HORKAGE_DMA_RW_ONLY for TORiSAN is verified to be subset of using
    DMA for ATAPI commands which aren't aligned to 16 bytes.  As libata
    now doesn't use DMA for unaligned ATAPI commands, the horkage is
    redundant.  Kill it.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a3380f808630..620da7be07b7 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -298,7 +298,6 @@ enum {
 	ATA_HORKAGE_NODMA	= (1 << 1),	/* DMA problems */
 	ATA_HORKAGE_NONCQ	= (1 << 2),	/* Don't use NCQ */
 	ATA_HORKAGE_MAX_SEC_128	= (1 << 3),	/* Limit max sects to 128 */
-	ATA_HORKAGE_DMA_RW_ONLY	= (1 << 4),	/* ATAPI DMA for RW only */
 };
 
 enum hsm_task_states {

commit 55f3952d45a439cecc36fd845a87026d04c82931
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jun 25 21:31:05 2007 +0900

    libata: kill the infamous abnormal status message
    
    The infamous abnormal status message triggers on not so abnormal cases
    including empty port and even when it's being triggered on actual
    errors the info it provides is redundant and out of context - higher
    level functions will print the info in better safe later anyway.
    
    Also, by being triggered all the time, it leads people to think that
    the abnormality is somehow related to all ATA and system problems
    they're experiencing and gives owners of healthy systems unfounded
    doubts about the integrity of the universe.  Make it a DPRINTK and
    save the universe.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 745c4f9b4caa..a3380f808630 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1088,11 +1088,9 @@ static inline u8 ata_wait_idle(struct ata_port *ap)
 {
 	u8 status = ata_busy_wait(ap, ATA_BUSY | ATA_DRQ, 1000);
 
-	if (status != 0xff && (status & (ATA_BUSY | ATA_DRQ))) {
-		if (ata_msg_warn(ap))
-			printk(KERN_WARNING "ATA: abnormal status 0x%X on port 0x%p\n",
-				status, ap->ioaddr.status_addr);
-	}
+	if (status != 0xff && (status & (ATA_BUSY | ATA_DRQ)))
+		DPRINTK("ATA: abnormal status 0x%X on port 0x%p\n",
+			status, ap->ioaddr.status_addr);
 
 	return status;
 }

commit d92e74d353345d19f762e9501a50b0a5f43f7ba8
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Thu Jun 7 16:19:15 2007 +0100

    libata-core/sff: Fix multiple assumptions about DMA
    
    The ata IRQ ack functions are only used when debugging. Unfortunately
    almost every controller that calls them can cause crashes in some
    configurations as there are missing checks for bmdma presence.
    
    In addition ata_port_start insists of installing DMA buffers and pad
    buffers for controllers regardless. The SFF controllers actually need to
    make that decision dynamically at controller setup time and all need the
    same helper - so we add ata_sff_port_start. Future patches will switch
    the SFF drivers to use this.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a6a3113120a4..745c4f9b4caa 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -753,6 +753,7 @@ extern u8 ata_check_status(struct ata_port *ap);
 extern u8 ata_altstatus(struct ata_port *ap);
 extern void ata_exec_command(struct ata_port *ap, const struct ata_taskfile *tf);
 extern int ata_port_start (struct ata_port *ap);
+extern int ata_sff_port_start (struct ata_port *ap);
 extern irqreturn_t ata_interrupt (int irq, void *dev_instance);
 extern void ata_data_xfer(struct ata_device *adev, unsigned char *buf,
 			  unsigned int buflen, int write_data);

commit 464cf177df7727efcc5506322fc5d0c8b896f545
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun May 27 15:10:40 2007 +0200

    libata: always use polling SETXFER
    
    Several people have reported LITE-ON LTR-48246S detection failed
    because SETXFER fails.  It seems the device raises IRQ too early after
    SETXFER.  This is controller independent.  The same problem has been
    reported for different controllers.
    
    So, now we have pata_via where the controller raises IRQ before it's
    ready after SETXFER and a device which does similar thing.  This patch
    makes libata always execute SETXFER via polling.  As this only happens
    during EH, performance impact is nil.  Setting ATA_TFLAG_POLLING is
    also moved from issue hot path to ata_dev_set_xfermode() - the only
    place where SETXFER can be issued.
    
    Note that ATA_TFLAG_POLLING applies only to drivers which implement
    SFF TF interface and use libata HSM.  More advanced controllers ignore
    the flag.  This doesn't matter for this fix as SFF TF controllers are
    the problematic ones.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 85f7b1bd1482..a6a3113120a4 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -171,7 +171,6 @@ enum {
 	ATA_FLAG_SKIP_D2H_BSY	= (1 << 12), /* can't wait for the first D2H
 					      * Register FIS clearing BSY */
 	ATA_FLAG_DEBUGMSG	= (1 << 13),
-	ATA_FLAG_SETXFER_POLLING= (1 << 14), /* use polling for SETXFER */
 	ATA_FLAG_IGN_SIMPLEX	= (1 << 15), /* ignore SIMPLEX */
 	ATA_FLAG_NO_IORDY	= (1 << 16), /* controller lacks iordy */
 	ATA_FLAG_ACPI_SATA	= (1 << 17), /* need native SATA ACPI layout */

commit bc9a8a7eaa58d802a2b26c75edcc95cb92835db3
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon May 21 15:20:33 2007 +0100

    libata: Kiss post_set_mode goodbye
    
    As of the -mm tree we don't have post_set_mode users any more.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 666592ef0b25..85f7b1bd1482 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -574,8 +574,6 @@ struct ata_port_operations {
 	void (*phy_reset) (struct ata_port *ap); /* obsolete */
 	int  (*set_mode) (struct ata_port *ap, struct ata_device **r_failed_dev);
 
-	void (*post_set_mode) (struct ata_port *ap);
-
 	int (*cable_detect) (struct ata_port *ap);
 
 	int  (*check_atapi_dma) (struct ata_queued_cmd *qc);

commit 13b8d09f5de0aaa3153bbccc98baf247387823dc
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue May 15 12:29:22 2007 +0200

    libata: track spindown status and skip spindown_compat if possible
    
    Our assumption that most distros issue STANDBYNOW seems wrong.  The
    upstream sysvinit and thus many distros including gentoo and opensuse
    don't take any action for libata disks on spindown.  We can skip
    compat handling for these distros so that they don't need to update
    anything to take advantage of kernel-side shutdown.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 9b2122db30ff..666592ef0b25 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -140,6 +140,7 @@ enum {
 
 	ATA_DFLAG_PIO		= (1 << 8), /* device limited to PIO mode */
 	ATA_DFLAG_NCQ_OFF	= (1 << 9), /* device limited to non-NCQ mode */
+	ATA_DFLAG_SPUNDOWN	= (1 << 10), /* XXX: for spindown_compat */
 	ATA_DFLAG_INIT_MASK	= (1 << 16) - 1,
 
 	ATA_DFLAG_DETACH	= (1 << 16),

commit 3cadbcc09891b8544203f211dac13f9cc4e6832a
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue May 15 03:28:15 2007 +0900

    libata-acpi: add ATA_FLAG_ACPI_SATA port flag
    
    Whether a controller needs IDE or SATA ACPI hierarchy is determined by
    the programming interface of the controller not by whether the
    controller is SATA or PATA, or it supports slave device or not.  This
    patch adds ATA_FLAG_ACPI_SATA port flags which tells libata-acpi that
    the port needs SATA ACPI nodes, and sets the flag for ahci and
    sata_sil24.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b38a0f9bc9f7..9b2122db30ff 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -173,6 +173,7 @@ enum {
 	ATA_FLAG_SETXFER_POLLING= (1 << 14), /* use polling for SETXFER */
 	ATA_FLAG_IGN_SIMPLEX	= (1 << 15), /* ignore SIMPLEX */
 	ATA_FLAG_NO_IORDY	= (1 << 16), /* controller lacks iordy */
+	ATA_FLAG_ACPI_SATA	= (1 << 17), /* need native SATA ACPI layout */
 
 	/* The following flag belongs to ap->pflags but is kept in
 	 * ap->flags because it's referenced in many LLDs and will be

commit 6ddcd3b0201a7ad72294347636d2b4028ddbd95d
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue May 15 03:28:15 2007 +0900

    libata: during revalidation, check n_sectors after device is configured
    
    Device might be resized during ata_dev_configure() due to HPA or
    (later) ACPI _GTF.  Currently it's worked around by caching n_sectors
    before turning off HPA.  The cached original size is overwritten if
    the device is reconfigured without being hardreset - which always
    happens after configuring trasnfer mode.  If the device gets hardreset
    for some reason after that, revalidation fails with -ENODEV.
    
    This patch makes size checking more robust by moving n_sectors check
    from ata_dev_reread_id() to ata_dev_revalidate() after the device is
    fully configured.  No matter what happens during configuration, a
    device must have the same n_sectors after fully configured to be
    treated as the same device.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 27d936279574..b38a0f9bc9f7 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -431,7 +431,6 @@ struct ata_device {
 	struct scsi_device	*sdev;		/* attached SCSI device */
 	/* n_sector is used as CLEAR_OFFSET, read comment above CLEAR_OFFSET */
 	u64			n_sectors;	/* size of device, if ATA */
-	u64			n_sectors_boot;	/* size of ATA device at startup */
 	unsigned int		class;		/* ATA_DEV_xxx */
 	u16			id[ATA_ID_WORDS]; /* IDENTIFY xxx DEVICE data */
 	u8			pio_mode;

commit e92351bb53c0849fabfa80be53cbf3b0aa166e54
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat May 5 23:50:38 2007 +0900

    libata-acpi: s/CONFIG_SATA_ACPI/CONFIG_ATA_ACPI/
    
    ACPI applies to both SATA and PATA.  Drop the 'S' from the config
    variable.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 90abcdc3d4ef..27d936279574 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -458,7 +458,7 @@ struct ata_device {
 	struct ata_ering	ering;
 	int			spdn_cnt;
 	unsigned int		horkage;	/* List of broken features */
-#ifdef CONFIG_SATA_ACPI
+#ifdef CONFIG_ATA_ACPI
 	/* ACPI objects info */
 	acpi_handle obj_handle;
 #endif

commit f4d6d00466ef4879e4289f18c2f59210a06a7ada
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue May 1 11:50:15 2007 +0200

    libata: ignore EH scheduling during initialization
    
    libata enables SCSI host during ATA host activation which happens
    after IRQ handler is registered and IRQ is enabled.  All ATA ports are
    in frozen state when IRQ is enabled but frozen ports may raise limited
    number of IRQs after being frozen - IOW, ->freeze() is not responsible
    for clearing pending IRQs.  During normal operation, the IRQ handler
    is responsible for clearing spurious IRQs on frozen ports and it
    usually doesn't require any extra code.
    
    Unfortunately, during host initialization, the IRQ handler can end up
    scheduling EH for a port whose SCSI host isn't initialized yet.  This
    results in OOPS in the SCSI midlayer.  This is relatively short window
    and scheduling EH for probing is the first thing libata does after
    initialization, so ignoring EH scheduling until initialization is
    complete solves the problem nicely.
    
    This problem was spotted by Berck E. Nash in the following thread.
    
      http://thread.gmane.org/gmane.linux.kernel/519412
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Berck E. Nash <flyboy@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 95b74ba7dbf4..90abcdc3d4ef 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -190,6 +190,7 @@ enum {
 	ATA_PFLAG_LOADING	= (1 << 4), /* boot/loading probe */
 	ATA_PFLAG_UNLOADING	= (1 << 5), /* module is unloading */
 	ATA_PFLAG_SCSI_HOTPLUG	= (1 << 6), /* SCSI hotplug scheduled */
+	ATA_PFLAG_INITIALIZING	= (1 << 7), /* being initialized, don't touch */
 
 	ATA_PFLAG_FLUSH_PORT_TASK = (1 << 16), /* flush port task */
 	ATA_PFLAG_SUSPENDED	= (1 << 17), /* port is suspended (power) */

commit 1626aeb881236c8cb022b5e4ca594146a951d669
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri May 4 12:43:58 2007 +0200

    libata: clean up SFF init mess
    
    The intention of using port_mask in SFF init helpers was to eventually
    support exoctic configurations such as combination of legacy and
    native port on the same controller.  This never became actually
    necessary and the related code always has been subtly broken one way
    or the other.  Now that new init model is in place, there is no reason
    to make common helpers capable of handling all corner cases.  Exotic
    cases can simply dealt within LLDs as necessary.
    
    This patch removes port_mask handling in SFF init helpers.  SFF init
    helpers don't take n_ports argument and interpret it into port_mask
    anymore.  All information is carried via port_info.  n_ports argument
    is dropped and always two ports are allocated.  LLD can tell SFF to
    skip certain port by marking it dummy.  Note that SFF code has been
    treating unuvailable ports this way for a long time until recent
    breakage fix from Linus and is consistent with how other drivers
    handle with unavailable ports.
    
    This fixes 1-port legacy host handling still broken after the recent
    native mode fix and simplifies SFF init logic.  The following changes
    are made...
    
    * ata_pci_init_native_host() and ata_init_legacy_host() both now try
      to initialized whatever they can and mark failed ports dummy.  They
      return 0 if any port is successfully initialized.
    
    * ata_pci_prepare_native_host() and ata_pci_init_one() now doesn't
      take n_ports argument.  All info should be specified via port_info
      array.  Always two ports are allocated.
    
    * ata_pci_init_bmdma() exported to be used by LLDs in exotic cases.
    
    * port_info handling in all LLDs are standardized - all port_info
      arrays are const stack variable named ppi.  Unless the second port
      is different from the first, its port_info is specified as NULL
      (tells libata that it's identical to the last non-NULL port_info).
    
    * pata_hpt37x/hpt3x2n: don't modify static variable directly.  Make an
      on-stack copy instead as ata_piix does.
    
    * pata_uli: It has 4 ports instead of 2.  Don't use
      ata_pci_prepare_native_host().  Allocate the host explicitly and use
      init helpers.  It's simple enough.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 8a7cc13c8516..95b74ba7dbf4 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -253,10 +253,6 @@ enum {
 	ATA_DMA_PAD_SZ		= 4,
 	ATA_DMA_PAD_BUF_SZ	= ATA_DMA_PAD_SZ * ATA_MAX_QUEUE,
 
-	/* masks for port functions */
-	ATA_PORT_PRIMARY	= (1 << 0),
-	ATA_PORT_SECONDARY	= (1 << 1),
-
 	/* ering size */
 	ATA_ERING_SIZE		= 32,
 
@@ -688,8 +684,8 @@ extern void ata_std_postreset(struct ata_port *ap, unsigned int *classes);
 extern void ata_port_disable(struct ata_port *);
 extern void ata_std_ports(struct ata_ioports *ioaddr);
 #ifdef CONFIG_PCI
-extern int ata_pci_init_one (struct pci_dev *pdev, struct ata_port_info **port_info,
-			     unsigned int n_ports);
+extern int ata_pci_init_one (struct pci_dev *pdev,
+			     const struct ata_port_info * const * ppi);
 extern void ata_pci_remove_one (struct pci_dev *pdev);
 #ifdef CONFIG_PM
 extern void ata_pci_device_do_suspend(struct pci_dev *pdev, pm_message_t mesg);
@@ -854,11 +850,11 @@ struct pci_bits {
 	unsigned long		val;
 };
 
-extern int ata_pci_init_native_host(struct ata_host *host,
-				    unsigned int port_mask);
+extern int ata_pci_init_native_host(struct ata_host *host);
+extern int ata_pci_init_bmdma(struct ata_host *host);
 extern int ata_pci_prepare_native_host(struct pci_dev *pdev,
 				const struct ata_port_info * const * ppi,
-				int n_ports, struct ata_host **r_host);
+				struct ata_host **r_host);
 extern int pci_test_config_bits(struct pci_dev *pdev, const struct pci_bits *bits);
 extern unsigned long ata_pci_default_filter(struct ata_device *, unsigned long);
 #endif /* CONFIG_PCI */

commit 9666f4009c22f6520ac3fb8a19c9e32ab973e828
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri May 4 21:27:47 2007 +0200

    libata: reimplement suspend/resume support using sdev->manage_start_stop
    
    Reimplement suspend/resume support using sdev->manage_start_stop.
    
    * Device suspend/resume is now SCSI layer's responsibility and the
      code is simplified a lot.
    
    * DPM is dropped.  This also simplifies code a lot.  Suspend/resume
      status is port-wide now.
    
    * ata_scsi_device_suspend/resume() and ata_dev_ready() removed.
    
    * Resume now has to wait for disk to spin up before proceeding.  I
      couldn't find easy way out as libata is in EH waiting for the
      disk to be ready and sd is waiting for EH to complete to issue
      START_STOP.
    
    * sdev->manage_start_stop is set to 1 in ata_scsi_slave_config().
      This fixes spindown on shutdown and suspend-to-disk.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 7906d750aa77..8a7cc13c8516 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -140,7 +140,6 @@ enum {
 
 	ATA_DFLAG_PIO		= (1 << 8), /* device limited to PIO mode */
 	ATA_DFLAG_NCQ_OFF	= (1 << 9), /* device limited to non-NCQ mode */
-	ATA_DFLAG_SUSPENDED	= (1 << 10), /* device suspended */
 	ATA_DFLAG_INIT_MASK	= (1 << 16) - 1,
 
 	ATA_DFLAG_DETACH	= (1 << 16),
@@ -268,13 +267,9 @@ enum {
 	ATA_EH_REVALIDATE	= (1 << 0),
 	ATA_EH_SOFTRESET	= (1 << 1),
 	ATA_EH_HARDRESET	= (1 << 2),
-	ATA_EH_SUSPEND		= (1 << 3),
-	ATA_EH_RESUME		= (1 << 4),
-	ATA_EH_PM_FREEZE	= (1 << 5),
 
 	ATA_EH_RESET_MASK	= ATA_EH_SOFTRESET | ATA_EH_HARDRESET,
-	ATA_EH_PERDEV_MASK	= ATA_EH_REVALIDATE | ATA_EH_SUSPEND |
-				  ATA_EH_RESUME | ATA_EH_PM_FREEZE,
+	ATA_EH_PERDEV_MASK	= ATA_EH_REVALIDATE,
 
 	/* ata_eh_info->flags */
 	ATA_EHI_HOTPLUGGED	= (1 << 0),  /* could have been hotplugged */
@@ -736,8 +731,6 @@ extern int sata_scr_write_flush(struct ata_port *ap, int reg, u32 val);
 extern int ata_port_online(struct ata_port *ap);
 extern int ata_port_offline(struct ata_port *ap);
 #ifdef CONFIG_PM
-extern int ata_scsi_device_resume(struct scsi_device *);
-extern int ata_scsi_device_suspend(struct scsi_device *, pm_message_t mesg);
 extern int ata_host_suspend(struct ata_host *host, pm_message_t mesg);
 extern void ata_host_resume(struct ata_host *host);
 #endif
@@ -1008,11 +1001,6 @@ static inline unsigned int ata_dev_absent(const struct ata_device *dev)
 	return ata_class_absent(dev->class);
 }
 
-static inline unsigned int ata_dev_ready(const struct ata_device *dev)
-{
-	return ata_dev_enabled(dev) && !(dev->flags & ATA_DFLAG_SUSPENDED);
-}
-
 /*
  * port helpers
  */

commit 31daabda16063b64a99a526242add727601e43c3
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Feb 2 16:50:52 2007 +0900

    libata: reimplement reset sequencing
    
    libata previously depended upon waits in prereset to get resets after
    hotplug right for both spin up and device ready wait.  This was
    necessary both for reliablity and speed as reset was likely to fail if
    initiated too early and each try usually took more than 30secs to
    fail.  Previous patches fixed the reliability part by fixing status
    and SCR handling in resets.  This patch remedies the speed part by
    improving reset sequencing.
    
    Prereset waiting timeout is adjusted to 10s because spinup wait is
    replaced by reset sequencing and !BSY wait is not as important as
    before.  During boot or module loading where the drive is already
    fully spun up, !BSY wait succeeds immediately, so 10s should be enough
    in most cases.  It matters after hotplugging or other error
    conditions, but in those cases, !BSY wait in prereset simply can't be
    relied upon due to the varied and weird behaviors ATA controllers and
    devices show.
    
    Reset is now driven by ata_eh_reset_timeouts[] table which contains
    timeouts for each reset try.  The first reset can be softreset but the
    following ones are always hardreset if available.  Each timeout
    defines deadline for the reset try.  If a reset try fails, reset is
    retried with the next timeout till the end of the timeout table is
    reached.  If a reset try fails before the timeout with error, libata
    waits till the deadline of the failed try before retrying.
    
    IOW, the timeout table defines timetable of reset tries such that the
    n'th try always begins at least after the sum of all previous timeouts
    has passed.  The current timetable defines 4 tries and takes around 1
    minute.
    
    @0      : First try.  This should succeed most of the time during boot.
    @10     : 10s is enough to spin up most consumer harddrives.  Give it
              another shot.
    @20     : 20s should spin up > 99% of working drives.  This has 30s
              timeout for retarded devices needing long idleness post reset.
    @55     : Final try with 5s timeout just in case.
    
    The above timetable is trade off between not annoying the device too
    much with frequent resets and taking reasonable amount of time in most
    cases.  Some controllers may do better with shorter timeouts while
    others may fare better with longer but we just can't rely upon LLD
    writers to test each controller with wide variety of devices using
    various scenarios.  We need default behavior which reasonably fits
    most cases.
    
    I've tested the above timetable on a dozen SATA controllers and a few
    PATA controllers with about a dozen different drives from all major
    vendors and 4 different ODDs from three different vendors for both
    boot and hotplug (if available) cases.
    
    Boot probing is not affected unless the device is broken in which
    cases new code gives up on the port after a minute rather than five or
    nine minutes.  When hotplugging, most devices get detected on the
    first or second try.  Multi-platter drives with long spin up time
    which sometimes took > 40 secs with the original code, now usually
    comes up during the second try and at least right after the third try
    @20.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 69fc1b8a9215..7906d750aa77 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -296,18 +296,8 @@ enum {
 
 	/* how hard are we gonna try to probe/recover devices */
 	ATA_PROBE_MAX_TRIES	= 3,
-	ATA_EH_RESET_TRIES	= 3,
 	ATA_EH_DEV_TRIES	= 3,
 
-	/* Drive spinup time (time from power-on to the first D2H FIS)
-	 * in msecs - 8s currently.  Failing to get ready in this time
-	 * isn't critical.  It will result in reset failure for
-	 * controllers which can't wait for the first D2H FIS.  libata
-	 * will retry, so it just has to be long enough to spin up
-	 * most devices.
-	 */
-	ATA_SPINUP_WAIT		= 8000,
-
 	/* Horkage types. May be set by libata or controller on drives
 	   (some horkage may be drive/controller pair dependant */
 
@@ -495,7 +485,6 @@ struct ata_eh_info {
 	unsigned int		dev_action[ATA_MAX_DEVICES]; /* dev EH action */
 	unsigned int		flags;		/* ATA_EHI_* flags */
 
-	unsigned long		hotplug_timestamp;
 	unsigned int		probe_mask;
 
 	char			desc[ATA_EH_DESC_LEN];
@@ -925,12 +914,7 @@ extern void ata_do_eh(struct ata_port *ap, ata_prereset_fn_t prereset,
 
 static inline void __ata_ehi_hotplugged(struct ata_eh_info *ehi)
 {
-	if (ehi->flags & ATA_EHI_HOTPLUGGED)
-		return;
-
 	ehi->flags |= ATA_EHI_HOTPLUGGED | ATA_EHI_RESUME_LINK;
-	ehi->hotplug_timestamp = jiffies;
-
 	ehi->action |= ATA_EH_SOFTRESET;
 	ehi->probe_mask |= (1 << ATA_MAX_DEVICES) - 1;
 }

commit d4b2bab4f26345ea1803feb23ea92fbe3f6b77bc
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Feb 2 16:50:52 2007 +0900

    libata: add deadline support to prereset and reset methods
    
    Add @deadline to prereset and reset methods and make them honor it.
    ata_wait_ready() which directly takes @deadline is implemented to be
    used as the wait function.  This patch is in preparation for EH timing
    improvements.
    
    * ata_wait_ready() never does busy sleep.  It's only used from EH and
      no wait in EH is that urgent.  This function also prints 'be
      patient' message automatically after 5 secs of waiting if more than
      3 secs is remaining till deadline.
    
    * ata_bus_post_reset() now fails with error code if any of its wait
      fails.  This is important because earlier reset tries will have
      shorter timeout than the spec requires.  If a device fails to
      respond before the short timeout, reset should be retried with
      longer timeout rather than silently ignoring the device.
    
      There are three behavior differences.
    
      1. Timeout is applied to both devices at once, not separately.  This
         is more consistent with what the spec says.
    
      2. When a device passes devchk but fails to become ready before
         deadline.  Previouly, post_reset would just succeed and let
         device classification remove the device.  New code fails the
         reset thus causing reset retry.  After a few times, EH will give
         up disabling the port.
    
      3. When slave device passes devchk but fails to become accessible
         (TF-wise) after reset.  Original code disables dev1 after 30s
         timeout and continues as if the device doesn't exist, while the
         patched code fails reset.  When this happens, new code fails
         reset on whole port rather than proceeding with only the primary
         device.
    
      If the failing device is suffering transient problems, new code
      retries reset which is a better behavior.  If the failing device is
      actually broken, the net effect is identical to it, but not to the
      other device sharing the channel.  In the previous code, reset would
      have succeeded after 30s thus detecting the working one.  In the new
      code, reset fails and whole port gets disabled.  IMO, it's a
      pathological case anyway (broken device sharing bus with working
      one) and doesn't really matter.
    
    * ata_bus_softreset() is changed to return error code from
      ata_bus_post_reset().  It used to return 0 unconditionally.
    
    * Spin up waiting is to be removed and not converted to honor
      deadline.
    
    * To be on the safe side, deadline is set to 40s for the time being.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d8cfc72ea9c1..69fc1b8a9215 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -348,8 +348,9 @@ struct ata_queued_cmd;
 
 /* typedefs */
 typedef void (*ata_qc_cb_t) (struct ata_queued_cmd *qc);
-typedef int (*ata_prereset_fn_t)(struct ata_port *ap);
-typedef int (*ata_reset_fn_t)(struct ata_port *ap, unsigned int *classes);
+typedef int (*ata_prereset_fn_t)(struct ata_port *ap, unsigned long deadline);
+typedef int (*ata_reset_fn_t)(struct ata_port *ap, unsigned int *classes,
+			      unsigned long deadline);
 typedef void (*ata_postreset_fn_t)(struct ata_port *ap, unsigned int *classes);
 
 struct ata_ioports {
@@ -688,13 +689,17 @@ extern void __sata_phy_reset(struct ata_port *ap);
 extern void sata_phy_reset(struct ata_port *ap);
 extern void ata_bus_reset(struct ata_port *ap);
 extern int sata_set_spd(struct ata_port *ap);
-extern int sata_phy_debounce(struct ata_port *ap, const unsigned long *param);
-extern int sata_phy_resume(struct ata_port *ap, const unsigned long *param);
-extern int ata_std_prereset(struct ata_port *ap);
-extern int ata_std_softreset(struct ata_port *ap, unsigned int *classes);
-extern int sata_port_hardreset(struct ata_port *ap,
-			       const unsigned long *timing);
-extern int sata_std_hardreset(struct ata_port *ap, unsigned int *class);
+extern int sata_phy_debounce(struct ata_port *ap, const unsigned long *param,
+			     unsigned long deadline);
+extern int sata_phy_resume(struct ata_port *ap, const unsigned long *param,
+			   unsigned long deadline);
+extern int ata_std_prereset(struct ata_port *ap, unsigned long deadline);
+extern int ata_std_softreset(struct ata_port *ap, unsigned int *classes,
+			     unsigned long deadline);
+extern int sata_port_hardreset(struct ata_port *ap, const unsigned long *timing,
+			       unsigned long deadline);
+extern int sata_std_hardreset(struct ata_port *ap, unsigned int *class,
+			      unsigned long deadline);
 extern void ata_std_postreset(struct ata_port *ap, unsigned int *classes);
 extern void ata_port_disable(struct ata_port *);
 extern void ata_std_ports(struct ata_ioports *ioaddr);
@@ -750,6 +755,7 @@ extern void ata_host_resume(struct ata_host *host);
 extern int ata_ratelimit(void);
 extern int ata_busy_sleep(struct ata_port *ap,
 			  unsigned long timeout_pat, unsigned long timeout);
+extern int ata_wait_ready(struct ata_port *ap, unsigned long deadline);
 extern void ata_port_queue_task(struct ata_port *ap, work_func_t fn,
 				void *data, unsigned long delay);
 extern u32 ata_wait_register(void __iomem *reg, u32 mask, u32 val,

commit 0d64a233fe6a8fd45a062fe125159854ffed60c7
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 23 02:41:05 2007 +0900

    libata: separate ATA_EHI_DID_RESET into DID_SOFTRESET and DID_HARDRESET
    
    Separate ATA_EHI_DID_RESET into ATA_EHI_DID_SOFTRESET and
    ATA_EHI_DID_HARDRESET.  ATA_EHI_DID_RESET is redefined as OR of the
    two flags.  This patch doesn't introduce any behavior change.  This
    will be used later to determine whether _SDD is necessary or not.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 73b86dd30aec..d8cfc72ea9c1 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -282,11 +282,13 @@ enum {
 	ATA_EHI_NO_AUTOPSY	= (1 << 2),  /* no autopsy */
 	ATA_EHI_QUIET		= (1 << 3),  /* be quiet */
 
-	ATA_EHI_DID_RESET	= (1 << 16), /* already reset this port */
-	ATA_EHI_PRINTINFO	= (1 << 17), /* print configuration info */
-	ATA_EHI_SETMODE		= (1 << 18), /* configure transfer mode */
-	ATA_EHI_POST_SETMODE	= (1 << 19), /* revaildating after setmode */
+	ATA_EHI_DID_SOFTRESET	= (1 << 16), /* already soft-reset this port */
+	ATA_EHI_DID_HARDRESET	= (1 << 17), /* already soft-reset this port */
+	ATA_EHI_PRINTINFO	= (1 << 18), /* print configuration info */
+	ATA_EHI_SETMODE		= (1 << 19), /* configure transfer mode */
+	ATA_EHI_POST_SETMODE	= (1 << 20), /* revaildating after setmode */
 
+	ATA_EHI_DID_RESET	= ATA_EHI_DID_SOFTRESET | ATA_EHI_DID_HARDRESET,
 	ATA_EHI_RESET_MODIFIER_MASK = ATA_EHI_RESUME_LINK,
 
 	/* max repeat if error condition is still set after ->error_handler */

commit 1e999736cafdffc374f22eed37b291129ef82e4e
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Wed Apr 11 00:23:13 2007 +0100

    libata: HPA support
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    
    Add support for ignoring the BIOS HPA result (off by default) and setting
    the disk to the full available size unless already frozen.
    
    Tested with various platforms/disks and confirmed to work with the
    Macintosh (which broke earlier) and ata_piix (breakage due to the LBA48
    readback that Tejun fixed).
    
    For normal users this brings us, I believe, to feature parity with old IDE
    (and of course more featured in some areas too).
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 7c14a52079d5..73b86dd30aec 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -446,6 +446,7 @@ struct ata_device {
 	struct scsi_device	*sdev;		/* attached SCSI device */
 	/* n_sector is used as CLEAR_OFFSET, read comment above CLEAR_OFFSET */
 	u64			n_sectors;	/* size of device, if ATA */
+	u64			n_sectors_boot;	/* size of ATA device at startup */
 	unsigned int		class;		/* ATA_DEV_xxx */
 	u16			id[ATA_ID_WORDS]; /* IDENTIFY xxx DEVICE data */
 	u8			pio_mode;

commit 6bfff31e77cfa1b13490337e5a4dbaa3407e83ac
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Apr 17 23:44:08 2007 +0900

    libata: kill probe_ent and related helpers
    
    All drivers are converted to new init model.  Kill probe_ent,
    ata_device_add() and ata_pci_init_native_mode().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 5d32c157de60..7c14a52079d5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -368,34 +368,6 @@ struct ata_ioports {
 	void __iomem		*scr_addr;
 };
 
-struct ata_probe_ent {
-	struct list_head	node;
-	struct device 		*dev;
-	const struct ata_port_operations *port_ops;
-	struct scsi_host_template *sht;
-	struct ata_ioports	port[ATA_MAX_PORTS];
-	unsigned int		n_ports;
-	unsigned int		dummy_port_mask;
-	unsigned int		pio_mask;
-	unsigned int		mwdma_mask;
-	unsigned int		udma_mask;
-	unsigned long		irq;
-	unsigned long		irq2;
-	unsigned int		irq_flags;
-	unsigned long		port_flags;
-	unsigned long		_host_flags;
-	void __iomem * const	*iomap;
-	void			*private_data;
-
-	/* port_info for the secondary port.  Together with irq2, it's
-	 * used to implement non-uniform secondary port.  Currently,
-	 * the only user is ata_piix combined mode.  This workaround
-	 * will be removed together with ata_probe_ent when init model
-	 * is updated.
-	 */
-	const struct ata_port_info *pinfo2;
-};
-
 struct ata_host {
 	spinlock_t		lock;
 	struct device 		*dev;
@@ -744,7 +716,6 @@ extern int ata_host_register(struct ata_host *host,
 extern int ata_host_activate(struct ata_host *host, int irq,
 			     irq_handler_t irq_handler, unsigned long irq_flags,
 			     struct scsi_host_template *sht);
-extern int ata_device_add(const struct ata_probe_ent *ent);
 extern void ata_host_detach(struct ata_host *host);
 extern void ata_host_init(struct ata_host *, struct device *,
 			  unsigned long, const struct ata_port_operations *);
@@ -892,8 +863,6 @@ struct pci_bits {
 	unsigned long		val;
 };
 
-extern struct ata_probe_ent *
-ata_pci_init_native_mode(struct pci_dev *pdev, struct ata_port_info **port, int portmask);
 extern int ata_pci_init_native_host(struct ata_host *host,
 				    unsigned int port_mask);
 extern int ata_pci_prepare_native_host(struct pci_dev *pdev,

commit 21b0ad4fb8306ac2bf5a249ffc978b1b8924c7d0
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Apr 17 23:44:07 2007 +0900

    libata: add init helpers including ata_pci_prepare_native_host()
    
    These will be used to convert LLDs to new init model.
    
    * Add irq_handler field to port_info.  In new init model, requesting
      IRQ is LLD's responsibility and libata doesn't need to know about
      irq_handler.  Most LLDs can simply register their irq_handler but
      some need different irq_handler depending on specific chip.  The
      added port_info->irq_handler field can be used by LLDs to select
      the matching IRQ handler in such cases.
    
    * Add ata_dummy_port_info.
    
    * Implement ata_pci_prepare_native_host(), a helper to alloc ATA host,
      acquire all resources and init the host in one go.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 400429f9cd9d..5d32c157de60 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -668,6 +668,7 @@ struct ata_port_info {
 	unsigned long		mwdma_mask;
 	unsigned long		udma_mask;
 	const struct ata_port_operations *port_ops;
+	irq_handler_t		irq_handler;
 	void 			*private_data;
 };
 
@@ -690,6 +691,7 @@ extern const unsigned long sata_deb_timing_hotplug[];
 extern const unsigned long sata_deb_timing_long[];
 
 extern const struct ata_port_operations ata_dummy_port_ops;
+extern const struct ata_port_info ata_dummy_port_info;
 
 static inline const unsigned long *
 sata_ehc_deb_timing(struct ata_eh_context *ehc)
@@ -894,6 +896,9 @@ extern struct ata_probe_ent *
 ata_pci_init_native_mode(struct pci_dev *pdev, struct ata_port_info **port, int portmask);
 extern int ata_pci_init_native_host(struct ata_host *host,
 				    unsigned int port_mask);
+extern int ata_pci_prepare_native_host(struct pci_dev *pdev,
+				const struct ata_port_info * const * ppi,
+				int n_ports, struct ata_host **r_host);
 extern int pci_test_config_bits(struct pci_dev *pdev, const struct pci_bits *bits);
 extern unsigned long ata_pci_default_filter(struct ata_device *, unsigned long);
 #endif /* CONFIG_PCI */

commit d491b27b1959565671e2c05dff09b5f535a854ce
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Apr 17 23:44:07 2007 +0900

    libata: convert native PCI host handling to new init model
    
    Convert native PCI host handling to alloc-init-register model.  New
    function ata_pci_init_native_host() follows the new init model and
    replaces ata_pci_init_native_mode().  As there are remaining LLD
    users, the old function isn't removed yet.
    
    ata_pci_init_one() is reimplemented using the new function and now
    fully converted to new init model.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 300daf6c50d0..400429f9cd9d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -892,6 +892,8 @@ struct pci_bits {
 
 extern struct ata_probe_ent *
 ata_pci_init_native_mode(struct pci_dev *pdev, struct ata_port_info **port, int portmask);
+extern int ata_pci_init_native_host(struct ata_host *host,
+				    unsigned int port_mask);
 extern int pci_test_config_bits(struct pci_dev *pdev, const struct pci_bits *bits);
 extern unsigned long ata_pci_default_filter(struct ata_device *, unsigned long);
 #endif /* CONFIG_PCI */

commit f5cda257296fbd3683b1f568f2d94d3caaacf74d
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Apr 17 23:44:07 2007 +0900

    libata: implement ata_host_alloc_pinfo() and ata_host_register()
    
    Implement ata_host_alloc_pinfo() and ata_host_register().  These helpers
    will be used in the following patches to adopt new init model.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 06cf23f0b3c7..300daf6c50d0 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -734,9 +734,14 @@ extern int ata_pci_device_resume(struct pci_dev *pdev);
 extern int ata_pci_clear_simplex(struct pci_dev *pdev);
 #endif /* CONFIG_PCI */
 extern struct ata_host *ata_host_alloc(struct device *dev, int max_ports);
+extern struct ata_host *ata_host_alloc_pinfo(struct device *dev,
+			const struct ata_port_info * const * ppi, int n_ports);
 extern int ata_host_start(struct ata_host *host);
 extern int ata_host_register(struct ata_host *host,
 			     struct scsi_host_template *sht);
+extern int ata_host_activate(struct ata_host *host, int irq,
+			     irq_handler_t irq_handler, unsigned long irq_flags,
+			     struct scsi_host_template *sht);
 extern int ata_device_add(const struct ata_probe_ent *ent);
 extern void ata_host_detach(struct ata_host *host);
 extern void ata_host_init(struct ata_host *, struct device *,

commit f31871951b38daf2d7ca17daad59fdb735062da3
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Apr 17 23:44:07 2007 +0900

    libata: separate out ata_host_alloc() and ata_host_register()
    
    Reorganize ata_host_alloc() and its subroutines into the following
    three functions.
    
    * ata_host_alloc() : allocates host and its ports.  shost is not
      registered automatically.
    
    * ata_scsi_add_hosts() : allocates and adds shosts associated with an
      ATA host.  Used by ata_host_register().
    
    * ata_host_register() : takes a fully initialized ata_host structure
      and registers it to libata layer and probes it.
    
    Only ata_host_alloc() and ata_host_register() are exported.
    ata_device_add() is rewritten using the above functions.  This patch
    does not introduce any observable behavior change.  Things worth
    mentioning.
    
    * print_id is assigned at registration time and LLDs are allowed to
      overallocate ports and reduce host->n_ports during initialization.
      ata_host_register() will throw away unused ports automatically.
    
    * All SCSI host initialization stuff now resides in
      ata_scsi_add_hosts() in libata-scsi.c, where it should be.
    
    * ipr is now the only user of ata_host_init().  Either kill it by
      converting ipr to use ata_host_alloc() and friends or rename and
      move it to libata-scsi.c
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index bda26e86f05f..06cf23f0b3c7 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -733,7 +733,10 @@ extern int ata_pci_device_resume(struct pci_dev *pdev);
 #endif
 extern int ata_pci_clear_simplex(struct pci_dev *pdev);
 #endif /* CONFIG_PCI */
+extern struct ata_host *ata_host_alloc(struct device *dev, int max_ports);
 extern int ata_host_start(struct ata_host *host);
+extern int ata_host_register(struct ata_host *host,
+			     struct scsi_host_template *sht);
 extern int ata_device_add(const struct ata_probe_ent *ent);
 extern void ata_host_detach(struct ata_host *host);
 extern void ata_host_init(struct ata_host *, struct device *,

commit ecef7253235e7a9365afe08a508e11bed91c1c11
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Apr 17 23:44:06 2007 +0900

    libata: separate out ata_host_start()
    
    Separate out ata_host_start() from ata_device_add().  ata_host_start()
    calls ->port_start on each port if available and freezes the port.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ced9dd54035e..bda26e86f05f 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -210,6 +210,7 @@ enum {
 
 	/* host set flags */
 	ATA_HOST_SIMPLEX	= (1 << 0),	/* Host is simplex, one DMA channel per host only */
+	ATA_HOST_STARTED	= (1 << 1),	/* Host started */
 
 	/* various lengths of time */
 	ATA_TMOUT_BOOT		= 30 * HZ,	/* heuristic */
@@ -732,6 +733,7 @@ extern int ata_pci_device_resume(struct pci_dev *pdev);
 #endif
 extern int ata_pci_clear_simplex(struct pci_dev *pdev);
 #endif /* CONFIG_PCI */
+extern int ata_host_start(struct ata_host *host);
 extern int ata_device_add(const struct ata_probe_ent *ent);
 extern void ata_host_detach(struct ata_host *host);
 extern void ata_host_init(struct ata_host *, struct device *,

commit 4911487a34baa89ec5b5f09a661761b73091fbec
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Apr 17 23:44:06 2007 +0900

    libata: allocate ap separately from shost
    
    Don't embed ap inside shost.  Allocate it separately and point it back
    from shosts's hostdata.  This makes port allocation more flexible and
    allows regular ATA and SAS share host alloc/init paths.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 12237d4b9f9b..ced9dd54035e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1231,7 +1231,7 @@ static inline void ata_pad_free(struct ata_port *ap, struct device *dev)
 
 static inline struct ata_port *ata_shost_to_port(struct Scsi_Host *host)
 {
-	return (struct ata_port *) &host->hostdata[0];
+	return *(struct ata_port **)&host->hostdata[0];
 }
 
 #endif /* __LINUX_LIBATA_H__ */

commit 5a5dbd18a7496ed403f6f54bb20c955c65482fa5
Author: Mark Lord <liml@rtr.ca>
Date:   Fri Mar 16 10:22:26 2007 -0400

    libata: add support for READ/WRITE LONG
    
    The READ/WRITE LONG commands are theoretically obsolete,
    but the majority of drives in existance still implement them.
    
    The WRITE_LONG and WRITE_LONG_ONCE commands are of particular
    interest for fault injection testing -- eg. creating "media errors"
    at specific locations on a disk.
    
    The fussy bit is that these commands require a non-standard
    sector size, usually 520 bytes instead of 512.
    
    This patch adds support to libata for READ/WRITE LONG commands
    issued via SG_IO/ATA_16.
    
    Signed-off-by:  Mark Lord <mlord@pobox.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 5a40a8d95114..12237d4b9f9b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -427,6 +427,7 @@ struct ata_queued_cmd {
 	int			dma_dir;
 
 	unsigned int		pad_len;
+	unsigned int		sect_size;
 
 	unsigned int		nbytes;
 	unsigned int		curbytes;
@@ -1182,6 +1183,7 @@ static inline void ata_qc_reinit(struct ata_queued_cmd *qc)
 	qc->n_elem = 0;
 	qc->err_mask = 0;
 	qc->pad_len = 0;
+	qc->sect_size = ATA_SECT_SIZE;
 
 	ata_tf_init(qc->dev, &qc->tf);
 

commit a76b62ca70662cd0ca98edf366c6637009a95f7d
Author: Alan Cox <alan@redhat.com>
Date:   Fri Mar 9 09:34:07 2007 -0500

    libata: Change prototype of mode_filter to remove ata_port*
    
    With Tejun having added adev->ap some time ago we can get rid of the
    almost unused port being passed to mode filters. And while we are
    doing filters, lets turn on the !IORDY filter as well.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    
    With some hand massaging from
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c145d9df04d0..5a40a8d95114 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -601,7 +601,7 @@ struct ata_port_operations {
 
 	void (*set_piomode) (struct ata_port *, struct ata_device *);
 	void (*set_dmamode) (struct ata_port *, struct ata_device *);
-	unsigned long (*mode_filter) (const struct ata_port *, struct ata_device *, unsigned long);
+	unsigned long (*mode_filter) (struct ata_device *, unsigned long);
 
 	void (*tf_load) (struct ata_port *ap, const struct ata_taskfile *tf);
 	void (*tf_read) (struct ata_port *ap, struct ata_taskfile *tf);
@@ -882,7 +882,7 @@ struct pci_bits {
 extern struct ata_probe_ent *
 ata_pci_init_native_mode(struct pci_dev *pdev, struct ata_port_info **port, int portmask);
 extern int pci_test_config_bits(struct pci_dev *pdev, const struct pci_bits *bits);
-extern unsigned long ata_pci_default_filter(const struct ata_port *, struct ata_device *, unsigned long);
+extern unsigned long ata_pci_default_filter(struct ata_device *, unsigned long);
 #endif /* CONFIG_PCI */
 
 /*

commit 04351821b43e6c0c91ad50d7e4be54a935f749e1
Author: Alan <alan@lxorguk.ukuu.org.uk>
Date:   Tue Mar 6 02:37:52 2007 -0800

    pata: expose set_mode method so it can be wrapped
    
    This splits set_mode into do_set_mode and the wrapper so that a driver can
    call the standard method inside its own.  This in theory also obsoletes
    ->post_set_mode().
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 3451ef97a931..c145d9df04d0 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -831,6 +831,7 @@ extern void ata_scsi_slave_destroy(struct scsi_device *sdev);
 extern int ata_scsi_change_queue_depth(struct scsi_device *sdev,
 				       int queue_depth);
 extern struct ata_device *ata_dev_pair(struct ata_device *adev);
+extern int ata_do_set_mode(struct ata_port *ap, struct ata_device **r_failed_dev);
 extern u8 ata_irq_on(struct ata_port *ap);
 extern u8 ata_dummy_irq_on(struct ata_port *ap);
 extern u8 ata_irq_ack(struct ata_port *ap, unsigned int chk_drq);

commit be0d18dff5fae83845801929f297977c10ab99ad
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Tue Mar 6 02:37:56 2007 -0800

    libata: cable detection fixes
    
    2.6.21-rc has horrible problems with libata and PATA cable types (and
    thus speeds). This occurs because Tejun fixed a pile of other bugs and
    we now do cable detect enforcement for drive side detection properly.
    
    Unfortunately we don't do the process around cable detection right. Tejun
    identified the problem and pointed to the right Annex in the spec, this patch
    implements the rest of the needed changes.
    
    We add a ->cable_detect() method called after the identify
    sequence which allows a host to do host side detection at this point
    should it wish, or to modify the results of the drive side identify.
    
    This separate ->cable_detect method also cleans up a lot of code because
    many drivers have their own error_handler methods which really just set
    the cable type.
    
    If there is no ->cable_detect method the cable type is left alone so a
    driver setting it earlier (eg because it has the SATA flags set or
    because it uses the old error_handler approach) will still do the right
    thing (or at least the same thing) as before.
    
    This patch simply adds the cable_detect method and helpers it doesn't use
    them but other follow up patches will (ie Adrian please don't submit
    patches to unexport them ;))
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 84787cad860d..3451ef97a931 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -616,6 +616,8 @@ struct ata_port_operations {
 
 	void (*post_set_mode) (struct ata_port *ap);
 
+	int (*cable_detect) (struct ata_port *ap);
+
 	int  (*check_atapi_dma) (struct ata_queued_cmd *qc);
 
 	void (*bmdma_setup) (struct ata_queued_cmd *qc);
@@ -834,6 +836,11 @@ extern u8 ata_dummy_irq_on(struct ata_port *ap);
 extern u8 ata_irq_ack(struct ata_port *ap, unsigned int chk_drq);
 extern u8 ata_dummy_irq_ack(struct ata_port *ap, unsigned int chk_drq);
 
+extern int ata_cable_40wire(struct ata_port *ap);
+extern int ata_cable_80wire(struct ata_port *ap);
+extern int ata_cable_sata(struct ata_port *ap);
+extern int ata_cable_unknown(struct ata_port *ap);
+
 /*
  * Timing helpers
  */

commit cd0d3bbcdd650651b7ccfaf55d107e3fc237d95a
Author: Alan <alan@lxorguk.ukuu.org.uk>
Date:   Fri Mar 2 00:56:15 2007 +0000

    libata: dev_config does not need ap and adev passing
    
    It used to be impossible to get from ata_device to ata_port but that is
    no longer true. Various methods have been cleaned up over time but
    dev_config still takes both and most users don't need both anyway. Tidy
    this one up
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a41749820964..84787cad860d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -597,7 +597,7 @@ struct ata_port {
 struct ata_port_operations {
 	void (*port_disable) (struct ata_port *);
 
-	void (*dev_config) (struct ata_port *, struct ata_device *);
+	void (*dev_config) (struct ata_device *);
 
 	void (*set_piomode) (struct ata_port *, struct ata_device *);
 	void (*set_dmamode) (struct ata_port *, struct ata_device *);

commit 43727fbc753c63f9d2764c56467303698cc52c14
Author: Jeff Garzik <jeff@garzik.org>
Date:   Sun Feb 25 16:50:52 2007 -0500

    [libata] export sata_print_link_status()
    
    To be used in sata_mv's exception handling code, and overall is a
    generally useful function.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 0cfbcb6f08eb..a41749820964 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -701,6 +701,7 @@ static inline int ata_port_is_dummy(struct ata_port *ap)
 	return ap->ops == &ata_dummy_port_ops;
 }
 
+extern void sata_print_link_status(struct ata_port *ap);
 extern void ata_port_probe(struct ata_port *);
 extern void __sata_phy_reset(struct ata_port *ap);
 extern void sata_phy_reset(struct ata_port *ap);

commit 6f23a31d1cbe791a1ce86ffa9b23251ab0a1ef45
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Mon Apr 2 11:39:25 2007 +0800

    libata: Limit ATAPI DMA to R/W commands only for TORiSAN DVD drives (take 3)
    
    patch 4/4:
    
      Limit ATAPI DMA to R/W commands only for TORiSAN DRD-N216 DVD-ROM drives
      (http://bugzilla.kernel.org/show_bug.cgi?id=6710)
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c04aec360406..0cfbcb6f08eb 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -312,6 +312,7 @@ enum {
 	ATA_HORKAGE_NODMA	= (1 << 1),	/* DMA problems */
 	ATA_HORKAGE_NONCQ	= (1 << 2),	/* Don't use NCQ */
 	ATA_HORKAGE_MAX_SEC_128	= (1 << 3),	/* Limit max sects to 128 */
+	ATA_HORKAGE_DMA_RW_ONLY	= (1 << 4),	/* ATAPI DMA for RW only */
 };
 
 enum hsm_task_states {

commit 18d6e9d51891f91af4e7351cbab3cb180bb9f430
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Mon Apr 2 11:34:15 2007 +0800

    libata: Limit max sector to 128 for TORiSAN DVD drives (take 3)
    
    patch 3/4:
      The TORiSAN drive locks up when max sector == 256.
      Limit max sector to 128 for the TORiSAN DRD-N216 drives.
      (http://bugzilla.kernel.org/show_bug.cgi?id=6710)
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c7b5e661fe59..c04aec360406 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -311,6 +311,7 @@ enum {
 	ATA_HORKAGE_DIAGNOSTIC	= (1 << 0),	/* Failed boot diag */
 	ATA_HORKAGE_NODMA	= (1 << 1),	/* DMA problems */
 	ATA_HORKAGE_NONCQ	= (1 << 2),	/* Don't use NCQ */
+	ATA_HORKAGE_MAX_SEC_128	= (1 << 3),	/* Limit max sects to 128 */
 };
 
 enum hsm_task_states {

commit 7152764700559b6a4041fdaba345df9a5cd962f0
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Mon Apr 2 11:28:52 2007 +0800

    libata: reorder HSM_ST_FIRST for easier decoding (take 3)
    
    patch 1/4:
      Reorder HSM_ST_FIRST, such that the task state transition is easier decoded with human eyes.
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index e3f32f3189b2..c7b5e661fe59 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -315,11 +315,11 @@ enum {
 
 enum hsm_task_states {
 	HSM_ST_IDLE,		/* no command on going */
+	HSM_ST_FIRST,		/* (waiting the device to)
+				   write CDB or first data block */
 	HSM_ST,			/* (waiting the device to) transfer data */
 	HSM_ST_LAST,		/* (waiting the device to) complete command */
 	HSM_ST_ERR,		/* error */
-	HSM_ST_FIRST,		/* (waiting the device to)
-				   write CDB or first data block */
 };
 
 enum ata_completion_errors {

commit 6ffa01d88c9dd45e2ed917b5eeeb494d07efb1ab
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Mar 2 17:32:47 2007 +0900

    libata: add CONFIG_PM to libata core layer
    
    Conditionalize all PM related stuff in libata core layer using
    CONFIG_PM.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 3f89d13c2e9a..e3f32f3189b2 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -718,10 +718,12 @@ extern void ata_std_ports(struct ata_ioports *ioaddr);
 extern int ata_pci_init_one (struct pci_dev *pdev, struct ata_port_info **port_info,
 			     unsigned int n_ports);
 extern void ata_pci_remove_one (struct pci_dev *pdev);
+#ifdef CONFIG_PM
 extern void ata_pci_device_do_suspend(struct pci_dev *pdev, pm_message_t mesg);
 extern int __must_check ata_pci_device_do_resume(struct pci_dev *pdev);
 extern int ata_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg);
 extern int ata_pci_device_resume(struct pci_dev *pdev);
+#endif
 extern int ata_pci_clear_simplex(struct pci_dev *pdev);
 #endif /* CONFIG_PCI */
 extern int ata_device_add(const struct ata_probe_ent *ent);
@@ -747,10 +749,12 @@ extern int sata_scr_write(struct ata_port *ap, int reg, u32 val);
 extern int sata_scr_write_flush(struct ata_port *ap, int reg, u32 val);
 extern int ata_port_online(struct ata_port *ap);
 extern int ata_port_offline(struct ata_port *ap);
+#ifdef CONFIG_PM
 extern int ata_scsi_device_resume(struct scsi_device *);
 extern int ata_scsi_device_suspend(struct scsi_device *, pm_message_t mesg);
 extern int ata_host_suspend(struct ata_host *host, pm_message_t mesg);
 extern void ata_host_resume(struct ata_host *host);
+#endif
 extern int ata_ratelimit(void);
 extern int ata_busy_sleep(struct ata_port *ap,
 			  unsigned long timeout_pat, unsigned long timeout);

commit 032af1ce16d496b825adde0fa03948785ee16830
Author: Alan <alan@lxorguk.ukuu.org.uk>
Date:   Thu Mar 1 17:36:46 2007 +0000

    libata-core: Fix simplex handling
    
    The initial simplex handling code is fooled if you suspend and resume.
    This also causes problems with some single channel controllers which
    claim to be simplex.
    
    The fix is fairly simple, instead of keeping a flag to remember if we
    gave away the simplex channel we remember the actual owner. As the owner
    is always part of the host_set we don't even need a refcount.
    
    Knowing the owner also means we can reassign simplex DMA channels in
    future hotplug code etc if we need to
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    (and a signed-off for the patch I sent before while I remember)
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 045fb3a72d59..3f89d13c2e9a 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -403,8 +403,7 @@ struct ata_host {
 	void			*private_data;
 	const struct ata_port_operations *ops;
 	unsigned long		flags;
-	int			simplex_claimed;	/* Keep seperate in case we
-							   ever need to do this locked */
+	struct ata_port		*simplex_claimed;	/* channel owning the DMA */
 	struct ata_port		*ports[0];
 };
 

commit 10305f0f8e642590c69674d08bd22accef610aed
Author: Alan <alan@lxorguk.ukuu.org.uk>
Date:   Tue Feb 20 18:01:59 2007 +0000

    Add id_to_dma_mode function for printing DMA modes
    
    Also export dev_disable as this is needed by drivers doing slave decode
    filtering, which will follow shortly
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 1f2099de0511..045fb3a72d59 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -788,10 +788,12 @@ extern void ata_sg_init_one(struct ata_queued_cmd *qc, void *buf,
 extern void ata_sg_init(struct ata_queued_cmd *qc, struct scatterlist *sg,
 		 unsigned int n_elem);
 extern unsigned int ata_dev_classify(const struct ata_taskfile *tf);
+extern void ata_dev_disable(struct ata_device *adev);
 extern void ata_id_string(const u16 *id, unsigned char *s,
 			  unsigned int ofs, unsigned int len);
 extern void ata_id_c_string(const u16 *id, unsigned char *s,
 			    unsigned int ofs, unsigned int len);
+extern void ata_id_to_dma_mode(struct ata_device *dev, u8 unknown);
 extern unsigned long ata_device_blacklisted(const struct ata_device *dev);
 extern void ata_bmdma_setup (struct ata_queued_cmd *qc);
 extern void ata_bmdma_start (struct ata_queued_cmd *qc);

commit 44877b4e22f391d39c6589412106a3668e81a05b
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Feb 21 01:06:51 2007 +0900

    libata: s/ap->id/ap->print_id/g
    
    ata_port has two different id fields - id and port_no.  id is
    system-wide 1-based unique id for the port while port_no is 0-based
    host-wide port number.  The former is primarily used to identify the
    ATA port to the user in printk messages while the latter is used in
    various places in libata core and LLDs to index the port inside the
    host.
    
    The two fields feel quite similar and sometimes ap->id is used in
    place of ap->port_no, which is very difficult to spot.  This patch
    renames ap->id to ap->print_id to reduce the possibility of such bugs.
    
    Some printk messages are adjusted such that id string (ata%u[.%u])
    isn't printed twice and/or to use ata_*_printk() instead of hardcoded
    id format.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 5233e47eeb89..1f2099de0511 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -536,8 +536,8 @@ struct ata_port {
 	spinlock_t		*lock;
 	unsigned long		flags;	/* ATA_FLAG_xxx */
 	unsigned int		pflags; /* ATA_PFLAG_xxx */
-	unsigned int		id;	/* unique id req'd by scsi midlyr */
-	unsigned int		port_no; /* unique port #; from zero */
+	unsigned int		print_id; /* user visible unique port ID */
+	unsigned int		port_no; /* 0 based port no. inside the host */
 
 	struct ata_prd		*prd;	 /* our SG list */
 	dma_addr_t		prd_dma; /* and its DMA mapping */
@@ -892,10 +892,10 @@ extern void ata_do_eh(struct ata_port *ap, ata_prereset_fn_t prereset,
  * printk helpers
  */
 #define ata_port_printk(ap, lv, fmt, args...) \
-	printk(lv"ata%u: "fmt, (ap)->id , ##args)
+	printk(lv"ata%u: "fmt, (ap)->print_id , ##args)
 
 #define ata_dev_printk(dev, lv, fmt, args...) \
-	printk(lv"ata%u.%02u: "fmt, (dev)->ap->id, (dev)->devno , ##args)
+	printk(lv"ata%u.%02u: "fmt, (dev)->ap->print_id, (dev)->devno , ##args)
 
 /*
  * ata_eh_info helpers

commit 6d1245bf294e9ea65b3717be9fa0338bfb6ff6c9
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Feb 20 23:20:27 2007 +0900

    libata: separate out ata_ncq_enabled()
    
    Separate out ata_ncq_enabled().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 5db50fa594ac..5233e47eeb89 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1033,6 +1033,21 @@ static inline u8 ata_chk_status(struct ata_port *ap)
 	return ap->ops->check_status(ap);
 }
 
+/**
+ *	ata_ncq_enabled - Test whether NCQ is enabled
+ *	@dev: ATA device to test for
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host lock)
+ *
+ *	RETURNS:
+ *	1 if NCQ is enabled for @dev, 0 otherwise.
+ */
+static inline int ata_ncq_enabled(struct ata_device *dev)
+{
+	return (dev->flags & (ATA_DFLAG_PIO | ATA_DFLAG_NCQ_OFF |
+			      ATA_DFLAG_NCQ)) == ATA_DFLAG_NCQ;
+}
 
 /**
  *	ata_pause - Flush writes and pause 400 nanoseconds.

commit 7d47e8d4d4fb0c3d3bdc706759e70d5453b61ec3
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Feb 2 16:22:31 2007 +0900

    libata: put some intelligence into EH speed down sequence
    
    The current EH speed down code is more of a proof that the EH
    framework is capable of adjusting transfer speed in response to error.
    This patch puts some intelligence into EH speed down sequence.  The
    rules are..
    
    * If there have been more than three timeout, HSM violation or
      unclassified DEV errors for known supported commands during last 10
      mins, NCQ is turned off.
    
    * If there have been more than three timeout or HSM violation for known
      supported command, transfer mode is slowed down.  If DMA is active,
      it is first slowered by one grade (e.g. UDMA133->100).  If that
      doesn't help, it's slowered to 40c limit (UDMA33).  If PIO is
      active, it's slowered by one grade first.  If that doesn't help,
      PIO0 is forced.  Note that this rule does not change transfer mode.
      DMA is never degraded into PIO by this rule.
    
    * If there have been more than ten ATA bus, timeout, HSM violation or
      unclassified device errors for known supported commands && speeding
      down DMA mode didn't help, the device is forced into PIO mode.  Note
      that this rule is considered only for PATA devices and is pretty
      difficult to trigger.
    
    One error can only trigger one rule at a time.  After a rule is
    triggered, error history is cleared such that the next speed down
    happens only after some number of errors are accumulated.  This makes
    sense because now speed down is done in bigger stride.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 60dfc5f7e882..5db50fa594ac 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -495,6 +495,7 @@ struct ata_device {
 
 	/* error history */
 	struct ata_ering	ering;
+	int			spdn_cnt;
 	unsigned int		horkage;	/* List of broken features */
 #ifdef CONFIG_SATA_ACPI
 	/* ACPI objects info */

commit a619f981b477035027dd27dfbee6148b4cd4a83c
Author: Akira Iguchi <akira2.iguchi@toshiba.co.jp>
Date:   Fri Jan 26 16:28:18 2007 +0900

    libata: PATA driver for Celleb
    
    This is the patch for PATA controller of Celleb.
    
    This driver uses the managed iomap (devres).
    
    Because this driver needs special taskfile accesses, there is
    a copy of ata_std_softreset(). ata_dev_try_classify() is exported
    so that it can be used in this function.
    
    Signed-off-by: Kou Ishizaki <kou.ishizaki@toshiba.co.jp>
    Signed-off-by: Akira Iguchi <akira2.iguchi@toshiba.co.jp>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 86762a9f52ba..60dfc5f7e882 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -759,6 +759,7 @@ extern void ata_port_queue_task(struct ata_port *ap, work_func_t fn,
 extern u32 ata_wait_register(void __iomem *reg, u32 mask, u32 val,
 			     unsigned long interval_msec,
 			     unsigned long timeout_msec);
+extern unsigned int ata_dev_try_classify(struct ata_port *, unsigned int, u8 *);
 
 /*
  * Default driver ops implementations

commit 11ef697b37e3c85ce1ac21f7711babf1f5b12784
Author: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
Date:   Thu Sep 28 11:29:01 2006 -0700

    [PATCH] libata: ACPI and _GTF support
    
    _GTF is an acpi method that is used to reinitialize the drive.  It returns
    a task file containing ata commands that are sent back to the drive to restore
    it to boot up defaults.
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>
    (cherry picked from 9c69cab24b51a89664f4c0dfaf8a436d32117624 commit)

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b870b20df43c..86762a9f52ba 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -35,6 +35,7 @@
 #include <linux/ata.h>
 #include <linux/workqueue.h>
 #include <scsi/scsi_host.h>
+#include <linux/acpi.h>
 
 /*
  * Define if arch has non-standard setup.  This is a _PCI_ standard
@@ -495,6 +496,10 @@ struct ata_device {
 	/* error history */
 	struct ata_ering	ering;
 	unsigned int		horkage;	/* List of broken features */
+#ifdef CONFIG_SATA_ACPI
+	/* ACPI objects info */
+	acpi_handle obj_handle;
+#endif
 };
 
 /* Offset into struct ata_device.  Fields above it are maintained

commit f834e49f1a09414e9618ff0c9cd83c2114032bb6
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Wed Feb 7 13:46:00 2007 -0800

    libata: Add a host flag to indicate lack of IORDY capability
    
    This is the first preparation to doing the !IORDY cases properly.  Further
    diffs will then add the needed logic to do it right.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 596e0c18887d..b870b20df43c 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -172,6 +172,7 @@ enum {
 	ATA_FLAG_DEBUGMSG	= (1 << 13),
 	ATA_FLAG_SETXFER_POLLING= (1 << 14), /* use polling for SETXFER */
 	ATA_FLAG_IGN_SIMPLEX	= (1 << 15), /* ignore SIMPLEX */
+	ATA_FLAG_NO_IORDY	= (1 << 16), /* controller lacks iordy */
 
 	/* The following flag belongs to ap->pflags but is kept in
 	 * ap->flags because it's referenced in many LLDs and will be

commit 66efc5a7e3061c3597ac43a8bb1026488d57e66b
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Feb 6 22:19:10 2007 -0500

    libata: kill ATA_ENABLE_PATA
    
    The ATA_ENABLE_PATA define was never meant to be permanent, and in
    recent kernels, it's already been unconditionally enabled.  Remove.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index bdfe6ea8edf7..596e0c18887d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -54,8 +54,6 @@
 #undef ATA_VERBOSE_DEBUG	/* yet more debugging output */
 #undef ATA_IRQ_TRAP		/* define to ack screaming irqs */
 #undef ATA_NDEBUG		/* define to disable quick runtime checks */
-#define ATA_ENABLE_PATA		/* define to enable PATA support in some
-				 * low-level drivers */
 
 
 /* note: prints function name for you */

commit 836250069fc0eeebe8b6aed772281535cc6e34f9
Author: Akira Iguchi <akira2.iguchi@toshiba.co.jp>
Date:   Fri Jan 26 16:27:32 2007 +0900

    libata: add another IRQ calls (core and headers)
    
    This patch is against the libata core and headers.
    
    Two IRQ calls are added in ata_port_operations.
    - irq_on() is used to enable interrupts.
    - irq_ack() is used to acknowledge a device interrupt.
    
    In most drivers, ata_irq_on() and ata_irq_ack() are used for
    irq_on and irq_ack respectively.
    
    In some drivers (ex: ahci, sata_sil24) which cannot use them
    as is, ata_dummy_irq_on() and ata_dummy_irq_ack() are used.
    
    Signed-off-by: Kou Ishizaki <kou.ishizaki@toshiba.co.jp>
    Signed-off-by: Akira Iguchi <akira2.iguchi@toshiba.co.jp>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 308bb8cbe50f..bdfe6ea8edf7 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -632,6 +632,8 @@ struct ata_port_operations {
 
 	irq_handler_t irq_handler;
 	void (*irq_clear) (struct ata_port *);
+	u8 (*irq_on) (struct ata_port *);
+	u8 (*irq_ack) (struct ata_port *ap, unsigned int chk_drq);
 
 	u32 (*scr_read) (struct ata_port *ap, unsigned int sc_reg);
 	void (*scr_write) (struct ata_port *ap, unsigned int sc_reg,
@@ -813,6 +815,10 @@ extern void ata_scsi_slave_destroy(struct scsi_device *sdev);
 extern int ata_scsi_change_queue_depth(struct scsi_device *sdev,
 				       int queue_depth);
 extern struct ata_device *ata_dev_pair(struct ata_device *adev);
+extern u8 ata_irq_on(struct ata_port *ap);
+extern u8 ata_dummy_irq_on(struct ata_port *ap);
+extern u8 ata_irq_ack(struct ata_port *ap, unsigned int chk_drq);
+extern u8 ata_dummy_irq_ack(struct ata_port *ap, unsigned int chk_drq);
 
 /*
  * Timing helpers
@@ -1147,42 +1153,6 @@ static inline void ata_qc_reinit(struct ata_queued_cmd *qc)
 	qc->result_tf.feature = 0;
 }
 
-/**
- *	ata_irq_ack - Acknowledge a device interrupt.
- *	@ap: Port on which interrupts are enabled.
- *
- *	Wait up to 10 ms for legacy IDE device to become idle (BUSY
- *	or BUSY+DRQ clear).  Obtain dma status and port status from
- *	device.  Clear the interrupt.  Return port status.
- *
- *	LOCKING:
- */
-
-static inline u8 ata_irq_ack(struct ata_port *ap, unsigned int chk_drq)
-{
-	unsigned int bits = chk_drq ? ATA_BUSY | ATA_DRQ : ATA_BUSY;
-	u8 host_stat, post_stat, status;
-
-	status = ata_busy_wait(ap, bits, 1000);
-	if (status & bits)
-		if (ata_msg_err(ap))
-			printk(KERN_ERR "abnormal status 0x%X\n", status);
-
-	/* get controller status; clear intr, err bits */
-	host_stat = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
-	iowrite8(host_stat | ATA_DMA_INTR | ATA_DMA_ERR,
-		 ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
-
-	post_stat = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
-
-	if (ata_msg_intr(ap))
-		printk(KERN_INFO "%s: irq ack: host_stat 0x%X, new host_stat 0x%X, drv_stat 0x%X\n",
-			__FUNCTION__,
-			host_stat, post_stat, status);
-
-	return status;
-}
-
 static inline int ata_try_flush_cache(const struct ata_device *dev)
 {
 	return ata_id_wcache_enabled(dev->id) ||

commit 0d5ff566779f894ca9937231a181eb31e4adff0e
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Feb 1 15:06:36 2007 +0900

    libata: convert to iomap
    
    Convert libata core layer and LLDs to use iomap.
    
    * managed iomap is used.  Pointer to pcim_iomap_table() is cached at
      host->iomap and used through out LLDs.  This basically replaces
      host->mmio_base.
    
    * if possible, pcim_iomap_regions() is used
    
    Most iomap operation conversions are taken from Jeff Garzik
    <jgarzik@pobox.com>'s iomap branch.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index cebbcc8d45fd..308bb8cbe50f 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -348,21 +348,21 @@ typedef int (*ata_reset_fn_t)(struct ata_port *ap, unsigned int *classes);
 typedef void (*ata_postreset_fn_t)(struct ata_port *ap, unsigned int *classes);
 
 struct ata_ioports {
-	unsigned long		cmd_addr;
-	unsigned long		data_addr;
-	unsigned long		error_addr;
-	unsigned long		feature_addr;
-	unsigned long		nsect_addr;
-	unsigned long		lbal_addr;
-	unsigned long		lbam_addr;
-	unsigned long		lbah_addr;
-	unsigned long		device_addr;
-	unsigned long		status_addr;
-	unsigned long		command_addr;
-	unsigned long		altstatus_addr;
-	unsigned long		ctl_addr;
-	unsigned long		bmdma_addr;
-	unsigned long		scr_addr;
+	void __iomem		*cmd_addr;
+	void __iomem		*data_addr;
+	void __iomem		*error_addr;
+	void __iomem		*feature_addr;
+	void __iomem		*nsect_addr;
+	void __iomem		*lbal_addr;
+	void __iomem		*lbam_addr;
+	void __iomem		*lbah_addr;
+	void __iomem		*device_addr;
+	void __iomem		*status_addr;
+	void __iomem		*command_addr;
+	void __iomem		*altstatus_addr;
+	void __iomem		*ctl_addr;
+	void __iomem		*bmdma_addr;
+	void __iomem		*scr_addr;
 };
 
 struct ata_probe_ent {
@@ -381,7 +381,7 @@ struct ata_probe_ent {
 	unsigned int		irq_flags;
 	unsigned long		port_flags;
 	unsigned long		_host_flags;
-	void __iomem		*mmio_base;
+	void __iomem * const	*iomap;
 	void			*private_data;
 
 	/* port_info for the secondary port.  Together with irq2, it's
@@ -398,7 +398,7 @@ struct ata_host {
 	struct device 		*dev;
 	unsigned long		irq;
 	unsigned long		irq2;
-	void __iomem		*mmio_base;
+	void __iomem * const	*iomap;
 	unsigned int		n_ports;
 	void			*private_data;
 	const struct ata_port_operations *ops;
@@ -768,12 +768,10 @@ extern u8 ata_altstatus(struct ata_port *ap);
 extern void ata_exec_command(struct ata_port *ap, const struct ata_taskfile *tf);
 extern int ata_port_start (struct ata_port *ap);
 extern irqreturn_t ata_interrupt (int irq, void *dev_instance);
-extern void ata_mmio_data_xfer(struct ata_device *adev, unsigned char *buf,
-			       unsigned int buflen, int write_data);
-extern void ata_pio_data_xfer(struct ata_device *adev, unsigned char *buf,
-			      unsigned int buflen, int write_data);
-extern void ata_pio_data_xfer_noirq(struct ata_device *adev, unsigned char *buf,
-			      unsigned int buflen, int write_data);
+extern void ata_data_xfer(struct ata_device *adev, unsigned char *buf,
+			  unsigned int buflen, int write_data);
+extern void ata_data_xfer_noirq(struct ata_device *adev, unsigned char *buf,
+				unsigned int buflen, int write_data);
 extern void ata_qc_prep(struct ata_queued_cmd *qc);
 extern void ata_noop_qc_prep(struct ata_queued_cmd *qc);
 extern unsigned int ata_qc_issue_prot(struct ata_queued_cmd *qc);
@@ -1084,10 +1082,9 @@ static inline u8 ata_wait_idle(struct ata_port *ap)
 	u8 status = ata_busy_wait(ap, ATA_BUSY | ATA_DRQ, 1000);
 
 	if (status != 0xff && (status & (ATA_BUSY | ATA_DRQ))) {
-		unsigned long l = ap->ioaddr.status_addr;
 		if (ata_msg_warn(ap))
-			printk(KERN_WARNING "ATA: abnormal status 0x%X on port 0x%lX\n",
-				status, l);
+			printk(KERN_WARNING "ATA: abnormal status 0x%X on port 0x%p\n",
+				status, ap->ioaddr.status_addr);
 	}
 
 	return status;
@@ -1172,20 +1169,11 @@ static inline u8 ata_irq_ack(struct ata_port *ap, unsigned int chk_drq)
 			printk(KERN_ERR "abnormal status 0x%X\n", status);
 
 	/* get controller status; clear intr, err bits */
-	if (ap->flags & ATA_FLAG_MMIO) {
-		void __iomem *mmio = (void __iomem *) ap->ioaddr.bmdma_addr;
-		host_stat = readb(mmio + ATA_DMA_STATUS);
-		writeb(host_stat | ATA_DMA_INTR | ATA_DMA_ERR,
-		       mmio + ATA_DMA_STATUS);
-
-		post_stat = readb(mmio + ATA_DMA_STATUS);
-	} else {
-		host_stat = inb(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
-		outb(host_stat | ATA_DMA_INTR | ATA_DMA_ERR,
-		     ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
-
-		post_stat = inb(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
-	}
+	host_stat = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
+	iowrite8(host_stat | ATA_DMA_INTR | ATA_DMA_ERR,
+		 ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
+
+	post_stat = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
 
 	if (ata_msg_intr(ap))
 		printk(KERN_INFO "%s: irq ack: host_stat 0x%X, new host_stat 0x%X, drv_stat 0x%X\n",

commit b878ca5d37953ad1c4578b225a13a3c3e7e743b7
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Jan 20 16:00:28 2007 +0900

    libata: remove unused functions
    
    Now that all LLDs are converted to use devres, default stop callbacks
    are unused.  Remove them.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index f96277ed184f..cebbcc8d45fd 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -722,7 +722,6 @@ extern int ata_device_add(const struct ata_probe_ent *ent);
 extern void ata_host_detach(struct ata_host *host);
 extern void ata_host_init(struct ata_host *, struct device *,
 			  unsigned long, const struct ata_port_operations *);
-extern void ata_host_remove(struct ata_host *host);
 extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
 extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));
@@ -768,8 +767,6 @@ extern u8 ata_check_status(struct ata_port *ap);
 extern u8 ata_altstatus(struct ata_port *ap);
 extern void ata_exec_command(struct ata_port *ap, const struct ata_taskfile *tf);
 extern int ata_port_start (struct ata_port *ap);
-extern void ata_port_stop (struct ata_port *ap);
-extern void ata_host_stop (struct ata_host *host);
 extern irqreturn_t ata_interrupt (int irq, void *dev_instance);
 extern void ata_mmio_data_xfer(struct ata_device *adev, unsigned char *buf,
 			       unsigned int buflen, int write_data);
@@ -856,7 +853,6 @@ struct pci_bits {
 	unsigned long		val;
 };
 
-extern void ata_pci_host_stop (struct ata_host *host);
 extern struct ata_probe_ent *
 ata_pci_init_native_mode(struct pci_dev *pdev, struct ata_port_info **port, int portmask);
 extern int pci_test_config_bits(struct pci_dev *pdev, const struct pci_bits *bits);

commit f0d36efdc624beb3d9e29b9ab9e9537bf0f25d5b
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Jan 20 16:00:28 2007 +0900

    libata: update libata core layer to use devres
    
    Update libata core layer to use devres.
    
    * ata_device_add() acquires all resources in managed mode.
    
    * ata_host is allocated as devres associated with ata_host_release.
    
    * Port attached status is handled as devres associated with
      ata_host_attach_release().
    
    * Initialization failure and host removal is handedl by releasing
      devres group.
    
    * Except for ata_scsi_release() removal, LLD interface remains the
      same.  Some functions use hacky is_managed test to support both
      managed and unmanaged devices.  These will go away once all LLDs are
      updated to use devres.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index e9a0cfdcfe2c..f96277ed184f 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -31,7 +31,7 @@
 #include <linux/pci.h>
 #include <linux/dma-mapping.h>
 #include <asm/scatterlist.h>
-#include <asm/io.h>
+#include <linux/io.h>
 #include <linux/ata.h>
 #include <linux/workqueue.h>
 #include <scsi/scsi_host.h>
@@ -726,7 +726,6 @@ extern void ata_host_remove(struct ata_host *host);
 extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
 extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));
-extern int ata_scsi_release(struct Scsi_Host *host);
 extern void ata_sas_port_destroy(struct ata_port *);
 extern struct ata_port *ata_sas_port_alloc(struct ata_host *,
 					   struct ata_port_info *, struct Scsi_Host *);
@@ -1227,14 +1226,14 @@ static inline unsigned int __ac_err_mask(u8 status)
 static inline int ata_pad_alloc(struct ata_port *ap, struct device *dev)
 {
 	ap->pad_dma = 0;
-	ap->pad = dma_alloc_coherent(dev, ATA_DMA_PAD_BUF_SZ,
-				     &ap->pad_dma, GFP_KERNEL);
+	ap->pad = dmam_alloc_coherent(dev, ATA_DMA_PAD_BUF_SZ,
+				      &ap->pad_dma, GFP_KERNEL);
 	return (ap->pad == NULL) ? -ENOMEM : 0;
 }
 
 static inline void ata_pad_free(struct ata_port *ap, struct device *dev)
 {
-	dma_free_coherent(dev, ATA_DMA_PAD_BUF_SZ, ap->pad, ap->pad_dma);
+	dmam_free_coherent(dev, ATA_DMA_PAD_BUF_SZ, ap->pad, ap->pad_dma);
 }
 
 static inline struct ata_port *ata_shost_to_port(struct Scsi_Host *host)

commit 0529c159dbdd79794796c1b50b39442d72efbe97
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Jan 20 16:00:26 2007 +0900

    libata: implement ata_host_detach()
    
    Implement ata_host_detach() which calls ata_port_detach() for each
    port in the host and export it.  ata_port_detach() is now internal and
    thus un-exported.  ata_host_detach() will be used as the 'deregister
    from libata layer' function after devres conversion.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a2458dfefb17..e9a0cfdcfe2c 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -719,7 +719,7 @@ extern int ata_pci_device_resume(struct pci_dev *pdev);
 extern int ata_pci_clear_simplex(struct pci_dev *pdev);
 #endif /* CONFIG_PCI */
 extern int ata_device_add(const struct ata_probe_ent *ent);
-extern void ata_port_detach(struct ata_port *ap);
+extern void ata_host_detach(struct ata_host *host);
 extern void ata_host_init(struct ata_host *, struct device *,
 			  unsigned long, const struct ata_port_operations *);
 extern void ata_host_remove(struct ata_host *host);

commit 726f0785b608d09bdd64bdbadc09217ebbf9920e
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Jan 3 17:30:39 2007 +0900

    libata: kill qc->nsect and cursect
    
    libata used two separate sets of variables to record request size and
    current offset for ATA and ATAPI.  This is confusing and fragile.
    This patch replaces qc->nsect/cursect with qc->nbytes/curbytes and
    kills them.  Also, ata_pio_sector() is updated to use bytes for
    qc->cursg_ofs instead of sectors.  The field used to be used in bytes
    for ATAPI and in sectors for ATA.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a8ecaaad55ff..a2458dfefb17 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -427,9 +427,6 @@ struct ata_queued_cmd {
 
 	unsigned int		pad_len;
 
-	unsigned int		nsect;
-	unsigned int		cursect;
-
 	unsigned int		nbytes;
 	unsigned int		curbytes;
 
@@ -1145,8 +1142,7 @@ static inline void ata_qc_reinit(struct ata_queued_cmd *qc)
 	qc->dma_dir = DMA_NONE;
 	qc->__sg = NULL;
 	qc->flags = 0;
-	qc->cursect = qc->cursg = qc->cursg_ofs = 0;
-	qc->nsect = 0;
+	qc->cursg = qc->cursg_ofs = 0;
 	qc->nbytes = qc->curbytes = 0;
 	qc->n_elem = 0;
 	qc->err_mask = 0;

commit 553c4aa630af7bc885e056d0436e4eb7f238579b
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Dec 26 19:39:50 2006 +0900

    libata: handle pci_enable_device() failure while resuming
    
    Handle pci_enable_device() failure while resuming.  This patch kills
    the "ignoring return value of 'pci_enable_device'" warning message and
    propagates __must_check through ata_pci_device_do_resume().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index dab4dc505ce7..a8ecaaad55ff 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -716,7 +716,7 @@ extern int ata_pci_init_one (struct pci_dev *pdev, struct ata_port_info **port_i
 			     unsigned int n_ports);
 extern void ata_pci_remove_one (struct pci_dev *pdev);
 extern void ata_pci_device_do_suspend(struct pci_dev *pdev, pm_message_t mesg);
-extern void ata_pci_device_do_resume(struct pci_dev *pdev);
+extern int __must_check ata_pci_device_do_resume(struct pci_dev *pdev);
 extern int ata_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg);
 extern int ata_pci_device_resume(struct pci_dev *pdev);
 extern int ata_pci_clear_simplex(struct pci_dev *pdev);

commit d4013f07bd5380178bf28ef1cd76649779367288
Author: Alan Cox <alan@redhat.com>
Date:   Fri Dec 15 13:08:50 2006 -0800

    [PATCH] pci: Move PCI_VDEVICE from libata to core
    
    Updated diff which doesn't move the comment as per Jeff's request and
    corrects the docs as per report on l/k
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 84f12e8cae71..dab4dc505ce7 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -109,10 +109,6 @@ static inline u32 ata_msg_init(int dval, int default_msg_enable_bits)
 #define ATA_TAG_POISON		0xfafbfcfdU
 
 /* move to PCI layer? */
-#define PCI_VDEVICE(vendor, device)		\
-	PCI_VENDOR_ID_##vendor, (device),	\
-	PCI_ANY_ID, PCI_ANY_ID, 0, 0
-
 static inline struct device *pci_dev_to_dev(struct pci_dev *pdev)
 {
 	return &pdev->dev;

commit f20b16ff7c19d1c369ee07470952aca093551ed0
Author: Jeff Garzik <jeff@garzik.org>
Date:   Mon Dec 11 11:14:06 2006 -0500

    [libata] trim trailing whitespace
    
    Most of these contributed by that mysterious figger known as A.C.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 91bb8ceef0b5..84f12e8cae71 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -308,7 +308,7 @@ enum {
 	 * most devices.
 	 */
 	ATA_SPINUP_WAIT		= 8000,
-	
+
 	/* Horkage types. May be set by libata or controller on drives
 	   (some horkage may be drive/controller pair dependant */
 

commit 0777721c9b270f087bf967369c9acbee3f1a12ae
Author: Alan <alan@lxorguk.ukuu.org.uk>
Date:   Wed Jan 31 17:47:24 2007 +0000

    libata: Fix ata_busy_wait() kernel docs
    
    > Looks like you should use ata_busy_wait() here, rather than reproducing
    > the same code again.
    
    It waits in 10uS chunks while 1uS chunks were used in the workaround.
    Could indeed do that once I know the fix is right. While I'm at it the
    ata_busy_wait kerneldoc is borked so here's a fix
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 22aa69e20905..91bb8ceef0b5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1054,6 +1054,8 @@ static inline void ata_pause(struct ata_port *ap)
 /**
  *	ata_busy_wait - Wait for a port status register
  *	@ap: Port to wait for.
+ *	@bits: bits that must be clear
+ *	@max: number of 10uS waits to perform
  *
  *	Waits up to max*10 microseconds for the selected bits in the port's
  *	status register to be cleared.

commit b2a8bbe67d73631c71492fd60b757fc50a87f182
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Jan 25 19:40:05 2007 +0900

    libata: implement ATA_FLAG_IGN_SIMPLEX and use it in sata_uli
    
    Some uli controllers have stuck SIMPLEX bit which can't be cleared
    with ata_pci_clear_simplex(), but the controller is capable of doing
    DMAs on both channels simultaneously.  Implement ATA_FLAG_IGN_SIMPLEX
    which makes libata ignore the simplex bit and use it in sata_uli.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index df76fc467816..22aa69e20905 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -177,6 +177,7 @@ enum {
 					      * Register FIS clearing BSY */
 	ATA_FLAG_DEBUGMSG	= (1 << 13),
 	ATA_FLAG_SETXFER_POLLING= (1 << 14), /* use polling for SETXFER */
+	ATA_FLAG_IGN_SIMPLEX	= (1 << 15), /* ignore SIMPLEX */
 
 	/* The following flag belongs to ap->pflags but is kept in
 	 * ap->flags because it's referenced in many LLDs and will be

commit b229a7b0aed808f2ef6a5e9dbf78b0f17cefb4d0
Author: Alan <alan@lxorguk.ukuu.org.uk>
Date:   Wed Jan 24 11:47:07 2007 +0000

    libata: set_mode, Fix the FIXME
    
    When set_mode() changed ->set_mode didn't adapt. This makes the needed
    changes and removes the relevant FIXME case.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index f7f268e38749..df76fc467816 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -612,11 +612,11 @@ struct ata_port_operations {
 	void (*dev_select)(struct ata_port *ap, unsigned int device);
 
 	void (*phy_reset) (struct ata_port *ap); /* obsolete */
-	void (*set_mode) (struct ata_port *ap);
+	int  (*set_mode) (struct ata_port *ap, struct ata_device **r_failed_dev);
 
 	void (*post_set_mode) (struct ata_port *ap);
 
-	int (*check_atapi_dma) (struct ata_queued_cmd *qc);
+	int  (*check_atapi_dma) (struct ata_queued_cmd *qc);
 
 	void (*bmdma_setup) (struct ata_queued_cmd *qc);
 	void (*bmdma_start) (struct ata_queued_cmd *qc);

commit d0f29485686d9d1c4f31240953a742d5dd4fdb72
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Wed Jan 17 12:32:28 2007 -0600

    libata: Initialize qc->pad_len
    
    Initialize qc->pad_len for each new command. This ensures
    that pad_len is not set to a stale value for zero data
    length commands.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 65d318746ac6..f7f268e38749 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1151,6 +1151,7 @@ static inline void ata_qc_reinit(struct ata_queued_cmd *qc)
 	qc->nbytes = qc->curbytes = 0;
 	qc->n_elem = 0;
 	qc->err_mask = 0;
+	qc->pad_len = 0;
 
 	ata_tf_init(qc->dev, &qc->tf);
 

commit 7a801184fa480e11e6431f184a5bdf31f63326fb
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Wed Jan 17 12:32:12 2007 -0600

    libata: Fixup n_elem initialization
    
    Fixup the inialization of qc->n_elem. It currently gets
    initialized to 1 for commands that do not transfer any data.
    Fix this by initializing n_elem to 0 and only setting to 1
    in ata_scsi_qc_new when there is data to transfer. This fixes
    some problems seen with SATA devices attached to ipr adapters.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index e53a13ba7f78..65d318746ac6 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1149,6 +1149,7 @@ static inline void ata_qc_reinit(struct ata_queued_cmd *qc)
 	qc->cursect = qc->cursg = qc->cursg_ofs = 0;
 	qc->nsect = 0;
 	qc->nbytes = qc->curbytes = 0;
+	qc->n_elem = 0;
 	qc->err_mask = 0;
 
 	ata_tf_init(qc->dev, &qc->tf);

commit 501e0c500217e38276d61445ee0839b3f2c66d05
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Jan 17 11:34:02 2007 +0900

    libata: initialize qc->dma_dir to DMA_NONE
    
    libata didn't used to init qc->dma_dir to any specific value on qc
    initialization and command translation path didn't set qc->dma_dir if
    the command doesn't need data transfer.  This made non-data commands
    to have random qc->dma_dir.
    
    This usually doesn't cause problem because LLDs usually check
    qc->protocol first and look at qc->dma_dir iff the command needs data
    transfer but this doesn't hold for all LLDs.
    
    It might be worthwhile to rename qc->dma_dir to qc->data_dir as we use
    the field to tag data direction for both PIO and DMA protocols.
    
    This problem has been spotted by James Bottomley.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: James Bottomley <James.Bottomley@SteelEye.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ab2754830322..e53a13ba7f78 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1143,6 +1143,7 @@ static inline void ata_tf_init(struct ata_device *dev, struct ata_taskfile *tf)
 
 static inline void ata_qc_reinit(struct ata_queued_cmd *qc)
 {
+	qc->dma_dir = DMA_NONE;
 	qc->__sg = NULL;
 	qc->flags = 0;
 	qc->cursect = qc->cursg = qc->cursg_ofs = 0;

commit 9db73724453a9350e1c22dbe732d427e2939a5c9
Merge: 4c1ac1b49122 e62438630ca3
Author: David Howells <dhowells@redhat.com>
Date:   Tue Dec 5 17:01:28 2006 +0000

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
    
            drivers/ata/libata-scsi.c
            include/linux/libata.h
    
    Futher merge of Linus's head and compilation fixups.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

commit 800b399669ad495ad4361d134df87401ae36f44f
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Dec 3 21:34:13 2006 +0900

    [PATCH] libata: always use polling IDENTIFY
    
    libata switched to IRQ-driven IDENTIFY when IRQ-driven PIO was
    introduced.  This has caused a lot of problems including device
    misdetection and phantom device.
    
    ATA_FLAG_DETECT_POLLING was added recently to selectively use polling
    IDENTIFY on problemetic drivers but many controllers and devices are
    affected by this problem and trying to adding ATA_FLAG_DETECT_POLLING
    for each such case is diffcult and not very rewarding.
    
    This patch makes libata always use polling IDENTIFY.  This is
    consistent with libata's original behavior and drivers/ide's behavior.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 8b57b6a806cc..202283b5df96 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -176,9 +176,7 @@ enum {
 	ATA_FLAG_SKIP_D2H_BSY	= (1 << 12), /* can't wait for the first D2H
 					      * Register FIS clearing BSY */
 	ATA_FLAG_DEBUGMSG	= (1 << 13),
-	ATA_FLAG_DETECT_POLLING	= (1 << 14), /* detect device presence by
-					      * polling IDENTIFY */
-	ATA_FLAG_SETXFER_POLLING= (1 << 15), /* use polling for SETXFER */
+	ATA_FLAG_SETXFER_POLLING= (1 << 14), /* use polling for SETXFER */
 
 	/* The following flag belongs to ap->pflags but is kept in
 	 * ap->flags because it's referenced in many LLDs and will be

commit 3d3cca37559e3ab2b574eda11ed5207ccdb8980a
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Nov 16 10:50:50 2006 +0900

    [PATCH] libata: implement ATA_FLAG_SETXFER_POLLING and use it in pata_via, take #2
    
    This patch implements ATA_FLAG_SETXFER_POLLING and use in pata_via.
    If this flag is set, transfer mode setting performed by polling not by
    interrupt.  This should help those controllers which raise interrupt
    before the command is actually complete on SETXFER.
    
    Rationale for this approach.
    
    * uses existing facility and relatively simple
    * no busy sleep in the interrupt handler
    * updating drivers is easy
    
    While at it, kill now unused flag ATA_FLAG_SRST in pata_via.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6013211ac7de..8b57b6a806cc 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -178,6 +178,7 @@ enum {
 	ATA_FLAG_DEBUGMSG	= (1 << 13),
 	ATA_FLAG_DETECT_POLLING	= (1 << 14), /* detect device presence by
 					      * polling IDENTIFY */
+	ATA_FLAG_SETXFER_POLLING= (1 << 15), /* use polling for SETXFER */
 
 	/* The following flag belongs to ap->pflags but is kept in
 	 * ap->flags because it's referenced in many LLDs and will be

commit 582982e6991d6718ddadf8751072b50a850dde48
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Nov 17 12:05:11 2006 +0900

    [PATCH] libata: remove unused HSM_ST_UNKNOWN
    
    HSM_ST_UNKNOWN is not used anywhere.  Its value is zero and supposed
    to serve sanity check purpose but HSM_ST_IDLE is used for that
    purpose.  This unused state causes confusion.  After a port is
    initialized but before the first command is executed, the idle hsm
    state is UNKNOWN.  However, once a command has completed, the idle hsm
    state is IDLE.  This defeats sanity check in ata_pio_task() for the
    first command.
    
    This patch removes HSM_ST_UNKNOWN and consequently make HSM_ST_IDLE
    the default state.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 9080789913f7..6013211ac7de 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -318,7 +318,6 @@ enum {
 };
 
 enum hsm_task_states {
-	HSM_ST_UNKNOWN,		/* state unknown */
 	HSM_ST_IDLE,		/* no command on going */
 	HSM_ST,			/* (waiting the device to) transfer data */
 	HSM_ST_LAST,		/* (waiting the device to) complete command */

commit 55a8e2c83ce50548dfef74bb19dfe2b809cb3099
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Nov 10 18:08:10 2006 +0900

    [PATCH] libata: implement presence detection via polling IDENTIFY
    
    On some controllers (ICHs in piix mode), there is *NO* reliable way to
    determine device presence other than issuing IDENTIFY and see how the
    transaction proceeds by watching the TF status register.
    
    libata acted this way before irq-pio and phantom devices caused very
    little problem but now that IDENTIFY is performed using IRQ drive PIO,
    such phantom devices now result in multiple 30sec timeouts during
    boot.
    
    This patch implements ATA_FLAG_DETECT_POLLING.  If a LLD sets this
    flag, libata core issues the initial IDENTIFY in polling mode and if
    the initial data transfer fails w/ HSM violation, the port is
    considered to be empty thus replicating the old libata and IDE
    behavior.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 36e233cc3886..9080789913f7 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -176,6 +176,8 @@ enum {
 	ATA_FLAG_SKIP_D2H_BSY	= (1 << 12), /* can't wait for the first D2H
 					      * Register FIS clearing BSY */
 	ATA_FLAG_DEBUGMSG	= (1 << 13),
+	ATA_FLAG_DETECT_POLLING	= (1 << 14), /* detect device presence by
+					      * polling IDENTIFY */
 
 	/* The following flag belongs to ap->pflags but is kept in
 	 * ap->flags because it's referenced in many LLDs and will be
@@ -335,6 +337,7 @@ enum ata_completion_errors {
 	AC_ERR_SYSTEM		= (1 << 6), /* system error */
 	AC_ERR_INVALID		= (1 << 7), /* invalid argument */
 	AC_ERR_OTHER		= (1 << 8), /* unknown */
+	AC_ERR_NODEV_HINT	= (1 << 9), /* polling device detection hint */
 };
 
 /* forward declarations */

commit 6fc49adb9417b9c793e8f88d485387bb89ceb733
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Nov 11 20:10:45 2006 +0900

    [PATCH] libata: use FLUSH_EXT only when driver is larger than LBA28 limit
    
    Many drives support LBA48 even when its capacity is smaller than
    1<<28, as LBA48 is required for many functionalities.  FLUSH_EXT is
    mandatory for drives w/ LBA48 support.
    
    Interestingly, at least one of such drives (ST960812A) has problems
    dealing with FLUSH_EXT.  It eventually completes the command but takes
    around 7 seconds to finish in many cases thus drastically slowing down
    IO transactions.  This seems to be a firmware bug which sneaked into
    production probably because no other ATA driver including linux IDE
    issues FLUSH_EXT to drives which report support for LBA48 & FLUSH_EXT
    but is smaller than 1<<28 blocks.
    
    This patch adds ATA_DFLAG_FLUSH_EXT which is set iff the drive
    supports LBA48 & FLUSH_EXT and is larger than LBA28 limit.  Both cache
    flush paths are updated to issue FLUSH_EXT only when the flag is set.
    Note that the changed behavior is more inline with the rest of libata.
    libata prefers shorter commands whenever possible.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Danny Kukawka <dkukawka@novell.com>
    Cc: Stefan Seyfried <seife@novell.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 0d0ddeaee73f..36e233cc3886 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -140,6 +140,7 @@ enum {
 	ATA_DFLAG_LBA48		= (1 << 1), /* device supports LBA48 */
 	ATA_DFLAG_CDB_INTR	= (1 << 2), /* device asserts INTRQ when ready for CDB */
 	ATA_DFLAG_NCQ		= (1 << 3), /* device supports NCQ */
+	ATA_DFLAG_FLUSH_EXT	= (1 << 4), /* do FLUSH_EXT instead of FLUSH */
 	ATA_DFLAG_CFG_MASK	= (1 << 8) - 1,
 
 	ATA_DFLAG_PIO		= (1 << 8), /* device limited to PIO mode */

commit baa1e78a834c917984a4659fd282f712c17ee3bf
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Nov 1 18:39:27 2006 +0900

    [PATCH] libata: implement ATA_EHI_SETMODE and ATA_EHI_POST_SETMODE
    
    libata EH used to perform ata_set_mode() iff the EH session performed
    reset as indicated by ATA_EHI_DID_RESET.  This is incorrect because
    ->dev_config() called by revalidation is allowed to modify transfer
    mode which ata_set_mode() should take care of.  This patch implements
    the following two flags.
    
    * ATA_EHI_SETMODE: set during EH to schedule ata_set_mode().  Both new
      device attachment and revalidation set this flag.
    
    * ATA_EHI_POST_SETMODE: set while the device is revalidated after
      ata_set_mode().  Post-setmode revalidation is different from initial
      configuaration and EH revalidation in that ->dev_config() is not
      allowed tune transfer mode.  LLD can use this flag to determine
      whether it's allowed to tune transfer mode.  Note that POST_SETMODE
      ->dev_config() is guaranteed to be preceded by non-POST_SETMODE
      ->dev_config().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 949484627e67..0d0ddeaee73f 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -284,6 +284,8 @@ enum {
 
 	ATA_EHI_DID_RESET	= (1 << 16), /* already reset this port */
 	ATA_EHI_PRINTINFO	= (1 << 17), /* print configuration info */
+	ATA_EHI_SETMODE		= (1 << 18), /* configure transfer mode */
+	ATA_EHI_POST_SETMODE	= (1 << 19), /* revaildating after setmode */
 
 	ATA_EHI_RESET_MODIFIER_MASK = ATA_EHI_RESUME_LINK,
 

commit efdaedc443e935eda82e9e78a6e65d1f993d242f
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Nov 1 18:38:52 2006 +0900

    [PATCH] libata: implement ATA_EHI_PRINTINFO
    
    Implement ehi flag ATA_EHI_PRINTINFO.  This flag is set when device
    configuration needs to print out device info.  This used to be handled
    by @print_info argument to ata_dev_configure() but LLDs also need to
    know about it in ->dev_config() callback.
    
    This patch replaces @print_info w/ ATA_EHI_PRINTINFO and make sata_sil
    print workaround messages only on the initial configuration.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 41fa0890dbfb..949484627e67 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -283,6 +283,7 @@ enum {
 	ATA_EHI_QUIET		= (1 << 3),  /* be quiet */
 
 	ATA_EHI_DID_RESET	= (1 << 16), /* already reset this port */
+	ATA_EHI_PRINTINFO	= (1 << 17), /* print configuration info */
 
 	ATA_EHI_RESET_MODIFIER_MASK = ATA_EHI_RESUME_LINK,
 

commit b6103f6d1659e2024776bc759d28613fb36344a8
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Nov 1 17:59:53 2006 +0900

    [PATCH] libata: separate out and export sata_port_hardreset()
    
    Separate out sata_port_hardreset() from sata_std_hardreset().  This
    will be used by LLD hardreset implementation and later by PMP.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d3bf7b936c3f..41fa0890dbfb 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -702,6 +702,8 @@ extern int sata_phy_debounce(struct ata_port *ap, const unsigned long *param);
 extern int sata_phy_resume(struct ata_port *ap, const unsigned long *param);
 extern int ata_std_prereset(struct ata_port *ap);
 extern int ata_std_softreset(struct ata_port *ap, unsigned int *classes);
+extern int sata_port_hardreset(struct ata_port *ap,
+			       const unsigned long *timing);
 extern int sata_std_hardreset(struct ata_port *ap, unsigned int *class);
 extern void ata_std_postreset(struct ata_port *ap, unsigned int *classes);
 extern void ata_port_disable(struct ata_port *);

commit 90088bb41200b4da962282dfd45db82544adac3b
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Oct 9 11:10:26 2006 +0900

    [PATCH] libata: move ata_irq_on() into libata-sff.c
    
    ata_irq_on() isn't used outside of libata core layer.  The function is
    TF/SFF interface specific but currently used by core path with some
    hack too.  Move it from include/linux/libata.h to
    drivers/ata/libata-sff.c.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6c003d852a88..d3bf7b936c3f 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1149,37 +1149,6 @@ static inline void ata_qc_reinit(struct ata_queued_cmd *qc)
 	qc->result_tf.feature = 0;
 }
 
-/**
- *	ata_irq_on - Enable interrupts on a port.
- *	@ap: Port on which interrupts are enabled.
- *
- *	Enable interrupts on a legacy IDE device using MMIO or PIO,
- *	wait for idle, clear any pending interrupts.
- *
- *	LOCKING:
- *	Inherited from caller.
- */
-
-static inline u8 ata_irq_on(struct ata_port *ap)
-{
-	struct ata_ioports *ioaddr = &ap->ioaddr;
-	u8 tmp;
-
-	ap->ctl &= ~ATA_NIEN;
-	ap->last_ctl = ap->ctl;
-
-	if (ap->flags & ATA_FLAG_MMIO)
-		writeb(ap->ctl, (void __iomem *) ioaddr->ctl_addr);
-	else
-		outb(ap->ctl, ioaddr->ctl_addr);
-	tmp = ata_wait_idle(ap);
-
-	ap->ops->irq_clear(ap);
-
-	return tmp;
-}
-
-
 /**
  *	ata_irq_ack - Acknowledge a device interrupt.
  *	@ap: Port on which interrupts are enabled.

commit d1adc1bbd6dde3e05a91e2d3e6ab42d202ea61d5
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Oct 9 18:32:15 2006 +0900

    [PATCH] libata: handle 0xff status properly
    
    libata waits for !BSY even when the status register reports 0xff.
    This causes long boot delays when D8 isn't pulled down properly.  This
    patch does the followings.
    
    * don't wait if status register is 0xff in all wait functions
    
    * make ata_busy_sleep() return 0 on success and -errno on failure.
      -ENODEV is returned on 0xff status and -EBUSY on other failures.
    
    * make ata_bus_softreset() succeed on 0xff status.  0xff status is not
      reset failure.  It indicates no device.  This removes unnecessary
      retries on such ports.  Note that the code change assumes unoccupied
      port reporting 0xff status does not produce valid device signature.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Joe Jin <lkmaillist@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 2300fcc37f80..6c003d852a88 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -746,9 +746,8 @@ extern int ata_scsi_device_suspend(struct scsi_device *, pm_message_t mesg);
 extern int ata_host_suspend(struct ata_host *host, pm_message_t mesg);
 extern void ata_host_resume(struct ata_host *host);
 extern int ata_ratelimit(void);
-extern unsigned int ata_busy_sleep(struct ata_port *ap,
-				   unsigned long timeout_pat,
-				   unsigned long timeout);
+extern int ata_busy_sleep(struct ata_port *ap,
+			  unsigned long timeout_pat, unsigned long timeout);
 extern void ata_port_queue_task(struct ata_port *ap, void (*fn)(void *),
 				void *data, unsigned long delay);
 extern u32 ata_wait_register(void __iomem *reg, u32 mask, u32 val,
@@ -1064,7 +1063,7 @@ static inline u8 ata_busy_wait(struct ata_port *ap, unsigned int bits,
 		udelay(10);
 		status = ata_chk_status(ap);
 		max--;
-	} while ((status & bits) && (max > 0));
+	} while (status != 0xff && (status & bits) && (max > 0));
 
 	return status;
 }
@@ -1085,7 +1084,7 @@ static inline u8 ata_wait_idle(struct ata_port *ap)
 {
 	u8 status = ata_busy_wait(ap, ATA_BUSY | ATA_DRQ, 1000);
 
-	if (status & (ATA_BUSY | ATA_DRQ)) {
+	if (status != 0xff && (status & (ATA_BUSY | ATA_DRQ))) {
 		unsigned long l = ap->ioaddr.status_addr;
 		if (ata_msg_warn(ap))
 			printk(KERN_WARNING "ATA: abnormal status 0x%X on port 0x%lX\n",

commit 6919a0a6cfdad9e83d02cef5973826acd416560c
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Fri Oct 27 19:08:46 2006 -0700

    [PATCH] libata: Revamp blacklist support to allow multiple kinds of blacklisting flaws
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index abd2debebca2..2300fcc37f80 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -307,6 +307,8 @@ enum {
 	   (some horkage may be drive/controller pair dependant */
 
 	ATA_HORKAGE_DIAGNOSTIC	= (1 << 0),	/* Failed boot diag */
+	ATA_HORKAGE_NODMA	= (1 << 1),	/* DMA problems */
+	ATA_HORKAGE_NONCQ	= (1 << 2),	/* Don't use NCQ */
 };
 
 enum hsm_task_states {
@@ -787,6 +789,7 @@ extern void ata_id_string(const u16 *id, unsigned char *s,
 			  unsigned int ofs, unsigned int len);
 extern void ata_id_c_string(const u16 *id, unsigned char *s,
 			    unsigned int ofs, unsigned int len);
+extern unsigned long ata_device_blacklisted(const struct ata_device *dev);
 extern void ata_bmdma_setup (struct ata_queued_cmd *qc);
 extern void ata_bmdma_start (struct ata_queued_cmd *qc);
 extern void ata_bmdma_stop(struct ata_queued_cmd *qc);

commit 65f27f38446e1976cc98fd3004b110fedcddd189
Author: David Howells <dhowells@redhat.com>
Date:   Wed Nov 22 14:55:48 2006 +0000

    WorkStruct: Pass the work_struct pointer instead of context data
    
    Pass the work_struct pointer to the work function rather than context data.
    The work function can use container_of() to work out the data.
    
    For the cases where the container of the work_struct may go away the moment the
    pending bit is cleared, it is made possible to defer the release of the
    structure by deferring the clearing of the pending bit.
    
    To make this work, an extra flag is introduced into the management side of the
    work_struct.  This governs auto-release of the structure upon execution.
    
    Ordinarily, the work queue executor would release the work_struct for further
    scheduling or deallocation by clearing the pending bit prior to jumping to the
    work function.  This means that, unless the driver makes some guarantee itself
    that the work_struct won't go away, the work function may not access anything
    else in the work_struct or its container lest they be deallocated..  This is a
    problem if the auxiliary data is taken away (as done by the last patch).
    
    However, if the pending bit is *not* cleared before jumping to the work
    function, then the work function *may* access the work_struct and its container
    with no problems.  But then the work function must itself release the
    work_struct by calling work_release().
    
    In most cases, automatic release is fine, so this is the default.  Special
    initiators exist for the non-auto-release case (ending in _NAR).
    
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 5f04006e8dd2..b3f32eadbef5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -568,6 +568,7 @@ struct ata_port {
 	struct ata_host		*host;
 	struct device 		*dev;
 
+	void			*port_task_data;
 	struct delayed_work	port_task;
 	struct delayed_work	hotplug_task;
 	struct work_struct	scsi_rescan_task;
@@ -747,7 +748,7 @@ extern int ata_ratelimit(void);
 extern unsigned int ata_busy_sleep(struct ata_port *ap,
 				   unsigned long timeout_pat,
 				   unsigned long timeout);
-extern void ata_port_queue_task(struct ata_port *ap, void (*fn)(void *),
+extern void ata_port_queue_task(struct ata_port *ap, work_func_t fn,
 				void *data, unsigned long delay);
 extern u32 ata_wait_register(void __iomem *reg, u32 mask, u32 val,
 			     unsigned long interval_msec,

commit 52bad64d95bd89e08c49ec5a071fa6dcbe5a1a9c
Author: David Howells <dhowells@redhat.com>
Date:   Wed Nov 22 14:54:01 2006 +0000

    WorkStruct: Separate delayable and non-delayable events.
    
    Separate delayable work items from non-delayable work items be splitting them
    into a separate structure (delayed_work), which incorporates a work_struct and
    the timer_list removed from work_struct.
    
    The work_struct struct is huge, and this limits it's usefulness.  On a 64-bit
    architecture it's nearly 100 bytes in size.  This reduces that by half for the
    non-delayable type of event.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index abd2debebca2..5f04006e8dd2 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -568,8 +568,8 @@ struct ata_port {
 	struct ata_host		*host;
 	struct device 		*dev;
 
-	struct work_struct	port_task;
-	struct work_struct	hotplug_task;
+	struct delayed_work	port_task;
+	struct delayed_work	hotplug_task;
 	struct work_struct	scsi_rescan_task;
 
 	unsigned int		hsm_task_state;

commit 6e42acc4115bc376b8523acbcba2b2b7cc27d016
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Oct 27 19:08:42 2006 -0700

    [PATCH] libata: unexport ata_dev_revalidate()
    
    ata_dev_revalidate() isn't used outside of libata core.  Unexport it.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b03d5a340dc8..abd2debebca2 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -702,7 +702,6 @@ extern int ata_std_prereset(struct ata_port *ap);
 extern int ata_std_softreset(struct ata_port *ap, unsigned int *classes);
 extern int sata_std_hardreset(struct ata_port *ap, unsigned int *class);
 extern void ata_std_postreset(struct ata_port *ap, unsigned int *classes);
-extern int ata_dev_revalidate(struct ata_device *dev, int post_reset);
 extern void ata_port_disable(struct ata_port *);
 extern void ata_std_ports(struct ata_ioports *ioaddr);
 #ifdef CONFIG_PCI

commit 3343571d9f88a0de542d33aea9ab881f00ff866d
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Oct 19 14:44:53 2006 +0900

    [PATCH] libata: typo fix
    
    Typo fix in commment.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d0a7ad5ed518..b03d5a340dc8 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -143,7 +143,7 @@ enum {
 	ATA_DFLAG_CFG_MASK	= (1 << 8) - 1,
 
 	ATA_DFLAG_PIO		= (1 << 8), /* device limited to PIO mode */
-	ATA_DFLAG_NCQ_OFF	= (1 << 9), /* devied limited to non-NCQ mode */
+	ATA_DFLAG_NCQ_OFF	= (1 << 9), /* device limited to non-NCQ mode */
 	ATA_DFLAG_SUSPENDED	= (1 << 10), /* device suspended */
 	ATA_DFLAG_INIT_MASK	= (1 << 16) - 1,
 

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d1af1dbeaeb4..d0a7ad5ed518 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -628,7 +628,7 @@ struct ata_port_operations {
 	void (*error_handler) (struct ata_port *ap);
 	void (*post_internal_cmd) (struct ata_queued_cmd *qc);
 
-	irqreturn_t (*irq_handler)(int, void *, struct pt_regs *);
+	irq_handler_t irq_handler;
 	void (*irq_clear) (struct ata_port *);
 
 	u32 (*scr_read) (struct ata_port *ap, unsigned int sc_reg);
@@ -769,7 +769,7 @@ extern void ata_exec_command(struct ata_port *ap, const struct ata_taskfile *tf)
 extern int ata_port_start (struct ata_port *ap);
 extern void ata_port_stop (struct ata_port *ap);
 extern void ata_host_stop (struct ata_host *host);
-extern irqreturn_t ata_interrupt (int irq, void *dev_instance, struct pt_regs *regs);
+extern irqreturn_t ata_interrupt (int irq, void *dev_instance);
 extern void ata_mmio_data_xfer(struct ata_device *adev, unsigned char *buf,
 			       unsigned int buflen, int write_data);
 extern void ata_pio_data_xfer(struct ata_device *adev, unsigned char *buf,

commit 360f654e7cda850034f3f6252a7a7cff3fa77356
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Sep 30 19:45:00 2006 +0900

    [PATCH] libata: turn off NCQ if queue depth is adjusted to 1
    
    Turn off NCQ if queue depth is adjusted to 1.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index e54a5fd6a41e..d1af1dbeaeb4 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -143,6 +143,7 @@ enum {
 	ATA_DFLAG_CFG_MASK	= (1 << 8) - 1,
 
 	ATA_DFLAG_PIO		= (1 << 8), /* device limited to PIO mode */
+	ATA_DFLAG_NCQ_OFF	= (1 << 9), /* devied limited to non-NCQ mode */
 	ATA_DFLAG_SUSPENDED	= (1 << 10), /* device suspended */
 	ATA_DFLAG_INIT_MASK	= (1 << 16) - 1,
 

commit e5c9e081e9c980fa785cd9002c25a251cf3f090e
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Sep 30 19:44:39 2006 +0900

    [PATCH] libata: cosmetic changes to constants
    
    Cosmetic changes to ATA_DFLAG_* constants for soon-to-follow NCQ-off
    patch.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index df44b09fbae8..e54a5fd6a41e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -142,8 +142,8 @@ enum {
 	ATA_DFLAG_NCQ		= (1 << 3), /* device supports NCQ */
 	ATA_DFLAG_CFG_MASK	= (1 << 8) - 1,
 
-	ATA_DFLAG_PIO		= (1 << 8), /* device currently in PIO mode */
-	ATA_DFLAG_SUSPENDED	= (1 << 9), /* device suspended */
+	ATA_DFLAG_PIO		= (1 << 8), /* device limited to PIO mode */
+	ATA_DFLAG_SUSPENDED	= (1 << 10), /* device suspended */
 	ATA_DFLAG_INIT_MASK	= (1 << 16) - 1,
 
 	ATA_DFLAG_DETACH	= (1 << 16),

commit 54bb3a94b192be09feb85993b664ff118d6433d0
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Sep 27 22:20:11 2006 -0400

    [libata] Use new PCI_VDEVICE() macro to dramatically shorten ID lists
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d6a3d4b345fc..df44b09fbae8 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -109,6 +109,10 @@ static inline u32 ata_msg_init(int dval, int default_msg_enable_bits)
 #define ATA_TAG_POISON		0xfafbfcfdU
 
 /* move to PCI layer? */
+#define PCI_VDEVICE(vendor, device)		\
+	PCI_VENDOR_ID_##vendor, (device),	\
+	PCI_ANY_ID, PCI_ANY_ID, 0, 0
+
 static inline struct device *pci_dev_to_dev(struct pci_dev *pdev)
 {
 	return &pdev->dev;

commit a6d967a485c67ec8a1276261f39d81ace6a3e308
Author: Jeff Garzik <jeff@garzik.org>
Date:   Mon Sep 25 15:33:09 2006 -0400

    [libata] No need for all those arch libata-portmap.h headers
    
    They all contain the same thing.  Instead, have a single generic one in
    include/asm-generic, and permit an arch to override as needed.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 1ef3d3901b47..d6a3d4b345fc 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -36,7 +36,15 @@
 #include <linux/workqueue.h>
 #include <scsi/scsi_host.h>
 
+/*
+ * Define if arch has non-standard setup.  This is a _PCI_ standard
+ * not a legacy or ISA standard.
+ */
+#ifdef CONFIG_ATA_NONSTANDARD
 #include <asm/libata-portmap.h>
+#else
+#include <asm-generic/libata-portmap.h>
+#endif
 
 /*
  * compile-time options: to be removed as soon as all the drivers are

commit 93590859884784520a1850767f86296abc2cdc6d
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Tue Sep 12 16:55:12 2006 +0100

    [PATCH] libata: improve handling of diagostic fail (and hardware that misreports it)
    
    Our ATA probe code checks that a device is not reporting a diagnostic
    failure during start up. Unfortunately at least one device seems to like
    doing this - the Gigabyte iRAM.
    
    This is only done for the master right now (which is fine for the iRAM
    as it is SATA), as with PATA some combinations of ATAPI device seem to
    fool the check into seeing a drive that isn't there if it is applied to
    the slave.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ff67e7524fe9..1ef3d3901b47 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -289,6 +289,11 @@ enum {
 	 * most devices.
 	 */
 	ATA_SPINUP_WAIT		= 8000,
+	
+	/* Horkage types. May be set by libata or controller on drives
+	   (some horkage may be drive/controller pair dependant */
+
+	ATA_HORKAGE_DIAGNOSTIC	= (1 << 0),	/* Failed boot diag */
 };
 
 enum hsm_task_states {
@@ -476,6 +481,7 @@ struct ata_device {
 
 	/* error history */
 	struct ata_ering	ering;
+	unsigned int		horkage;	/* List of broken features */
 };
 
 /* Offset into struct ata_device.  Fields above it are maintained

commit fea63e38013ec628ab3f7fddc4c2148064b7910a
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Sep 16 03:04:15 2006 +0900

    [PATCH] libata: fix non-uniform ports handling
    
    Non-uniform ports handling got broken while updating libata to handle
    those in the same host.  Only separate irq for the non-uniform
    secondary port was implemented while all other fields (host flags,
    transfer mode...) of the secondary port simply shared those of the
    first.
    
    For ata_piix combined mode, which ATM is the only user of non-uniform
    ports, this causes the secondary port assume the wrong type.  This can
    cause PATA port to use SATA ops, which results in bogus check on PCS
    and detection failure.
    
    This patch adds ata_probe_ent->pinfo2 which points to optional
    port_info for the secondary port.  For the time being, this seems to
    be the simplest solution.  This workaround will be removed together
    with ata_probe_ent itself after init model is updated to allow more
    flexibility.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Nelson A. de Oliveira <naoliv@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 8715305f611f..ff67e7524fe9 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -361,6 +361,14 @@ struct ata_probe_ent {
 	unsigned long		_host_flags;
 	void __iomem		*mmio_base;
 	void			*private_data;
+
+	/* port_info for the secondary port.  Together with irq2, it's
+	 * used to implement non-uniform secondary port.  Currently,
+	 * the only user is ata_piix combined mode.  This workaround
+	 * will be removed together with ata_probe_ent when init model
+	 * is updated.
+	 */
+	const struct ata_port_info *pinfo2;
 };
 
 struct ata_host {

commit 481ff126e8d9be63809e7854badf815e54066eed
Merge: 669a5db411d8 9bec2e38527a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Thu Aug 31 00:02:26 2006 -0400

    Merge branch 'upstream' into pata-drivers

commit 9bec2e38527a9f2497b3d976715c672d08d6160d
Author: Jeff Garzik <jeff@garzik.org>
Date:   Thu Aug 31 00:02:15 2006 -0400

    [libata] Trim trailing whitespace.

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 563885cb0995..0ddf16c17b93 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -198,7 +198,7 @@ enum {
 
 	/* host set flags */
 	ATA_HOST_SIMPLEX	= (1 << 0),	/* Host is simplex, one DMA channel per host only */
-	
+
 	/* various lengths of time */
 	ATA_TMOUT_BOOT		= 30 * HZ,	/* heuristic */
 	ATA_TMOUT_BOOT_QUICK	= 7 * HZ,	/* heuristic */

commit 669a5db411d85a14f86cd92bc16bf7ab5b8aa235
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Aug 29 18:12:40 2006 -0400

    [libata] Add a bunch of PATA drivers.
    
    The vast majority of drivers and changes are from Alan Cox.  Albert Lee
    contributed and maintains pata_pdc2027x.  Adrian Bunk, Andrew Morton,
    and Tejun Heo contributed various minor fixes and updates.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 563885cb0995..a6d818148ae0 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -46,7 +46,7 @@
 #undef ATA_VERBOSE_DEBUG	/* yet more debugging output */
 #undef ATA_IRQ_TRAP		/* define to ack screaming irqs */
 #undef ATA_NDEBUG		/* define to disable quick runtime checks */
-#undef ATA_ENABLE_PATA		/* define to enable PATA support in some
+#define ATA_ENABLE_PATA		/* define to enable PATA support in some
 				 * low-level drivers */
 
 

commit cca3974e48607c3775dc73b544a5700b2e37c21a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Thu Aug 24 03:19:22 2006 -0400

    libata: Grand renaming.
    
    The biggest change is that ata_host_set is renamed to ata_host.
    
    * ata_host_set                  => ata_host
    * ata_probe_ent->host_flags     => ata_probe_ent->port_flags
    * ata_probe_ent->host_set_flags => ata_probe_ent->_host_flags
    * ata_host_stats                => ata_port_stats
    * ata_port->host                => ata_port->scsi_host
    * ata_port->host_set            => ata_port->host
    * ata_port_info->host_flags     => ata_port_info->flags
    * ata_(.*)host_set(.*)\(\)      => ata_\1host\2()
    
    The leading underscore in ata_probe_ent->_host_flags is to avoid
    reusing ->host_flags for different purpose.  Currently, the only user
    of the field is libata-bmdma.c and probe_ent itself is scheduled to be
    removed.
    
    ata_port->host is reused for different purpose but this field is used
    inside libata core proper and of different type.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 806682603ac5..563885cb0995 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -197,7 +197,7 @@ enum {
 	ATA_QCFLAG_EH_SCHEDULED = (1 << 18), /* EH scheduled (obsolete) */
 
 	/* host set flags */
-	ATA_HOST_SIMPLEX	= (1 << 0),	/* Host is simplex, one DMA channel per host_set only */
+	ATA_HOST_SIMPLEX	= (1 << 0),	/* Host is simplex, one DMA channel per host only */
 	
 	/* various lengths of time */
 	ATA_TMOUT_BOOT		= 30 * HZ,	/* heuristic */
@@ -357,13 +357,13 @@ struct ata_probe_ent {
 	unsigned long		irq;
 	unsigned long		irq2;
 	unsigned int		irq_flags;
-	unsigned long		host_flags;
-	unsigned long		host_set_flags;
+	unsigned long		port_flags;
+	unsigned long		_host_flags;
 	void __iomem		*mmio_base;
 	void			*private_data;
 };
 
-struct ata_host_set {
+struct ata_host {
 	spinlock_t		lock;
 	struct device 		*dev;
 	unsigned long		irq;
@@ -420,7 +420,7 @@ struct ata_queued_cmd {
 	void			*private_data;
 };
 
-struct ata_host_stats {
+struct ata_port_stats {
 	unsigned long		unhandled_irq;
 	unsigned long		idle_irq;
 	unsigned long		rw_reqbuf;
@@ -498,7 +498,7 @@ struct ata_eh_context {
 };
 
 struct ata_port {
-	struct Scsi_Host	*host;	/* our co-allocated scsi host */
+	struct Scsi_Host	*scsi_host; /* our co-allocated scsi host */
 	const struct ata_port_operations *ops;
 	spinlock_t		*lock;
 	unsigned long		flags;	/* ATA_FLAG_xxx */
@@ -523,7 +523,7 @@ struct ata_port {
 	unsigned int		hw_sata_spd_limit;
 	unsigned int		sata_spd_limit;	/* SATA PHY speed limit */
 
-	/* record runtime error info, protected by host_set lock */
+	/* record runtime error info, protected by host lock */
 	struct ata_eh_info	eh_info;
 	/* EH context owned by EH */
 	struct ata_eh_context	eh_context;
@@ -537,8 +537,8 @@ struct ata_port {
 	unsigned int		active_tag;
 	u32			sactive;
 
-	struct ata_host_stats	stats;
-	struct ata_host_set	*host_set;
+	struct ata_port_stats	stats;
+	struct ata_host		*host;
 	struct device 		*dev;
 
 	struct work_struct	port_task;
@@ -614,7 +614,7 @@ struct ata_port_operations {
 	int (*port_start) (struct ata_port *ap);
 	void (*port_stop) (struct ata_port *ap);
 
-	void (*host_stop) (struct ata_host_set *host_set);
+	void (*host_stop) (struct ata_host *host);
 
 	void (*bmdma_stop) (struct ata_queued_cmd *qc);
 	u8   (*bmdma_status) (struct ata_port *ap);
@@ -622,7 +622,7 @@ struct ata_port_operations {
 
 struct ata_port_info {
 	struct scsi_host_template	*sht;
-	unsigned long		host_flags;
+	unsigned long		flags;
 	unsigned long		pio_mask;
 	unsigned long		mwdma_mask;
 	unsigned long		udma_mask;
@@ -690,15 +690,15 @@ extern int ata_pci_clear_simplex(struct pci_dev *pdev);
 #endif /* CONFIG_PCI */
 extern int ata_device_add(const struct ata_probe_ent *ent);
 extern void ata_port_detach(struct ata_port *ap);
-extern void ata_host_set_init(struct ata_host_set *, struct device *,
-			      unsigned long, const struct ata_port_operations *);
-extern void ata_host_set_remove(struct ata_host_set *host_set);
+extern void ata_host_init(struct ata_host *, struct device *,
+			  unsigned long, const struct ata_port_operations *);
+extern void ata_host_remove(struct ata_host *host);
 extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
 extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));
 extern int ata_scsi_release(struct Scsi_Host *host);
 extern void ata_sas_port_destroy(struct ata_port *);
-extern struct ata_port *ata_sas_port_alloc(struct ata_host_set *,
+extern struct ata_port *ata_sas_port_alloc(struct ata_host *,
 					   struct ata_port_info *, struct Scsi_Host *);
 extern int ata_sas_port_init(struct ata_port *);
 extern int ata_sas_port_start(struct ata_port *ap);
@@ -715,9 +715,8 @@ extern int ata_port_online(struct ata_port *ap);
 extern int ata_port_offline(struct ata_port *ap);
 extern int ata_scsi_device_resume(struct scsi_device *);
 extern int ata_scsi_device_suspend(struct scsi_device *, pm_message_t mesg);
-extern int ata_host_set_suspend(struct ata_host_set *host_set,
-				pm_message_t mesg);
-extern void ata_host_set_resume(struct ata_host_set *host_set);
+extern int ata_host_suspend(struct ata_host *host, pm_message_t mesg);
+extern void ata_host_resume(struct ata_host *host);
 extern int ata_ratelimit(void);
 extern unsigned int ata_busy_sleep(struct ata_port *ap,
 				   unsigned long timeout_pat,
@@ -742,7 +741,7 @@ extern u8 ata_altstatus(struct ata_port *ap);
 extern void ata_exec_command(struct ata_port *ap, const struct ata_taskfile *tf);
 extern int ata_port_start (struct ata_port *ap);
 extern void ata_port_stop (struct ata_port *ap);
-extern void ata_host_stop (struct ata_host_set *host_set);
+extern void ata_host_stop (struct ata_host *host);
 extern irqreturn_t ata_interrupt (int irq, void *dev_instance, struct pt_regs *regs);
 extern void ata_mmio_data_xfer(struct ata_device *adev, unsigned char *buf,
 			       unsigned int buflen, int write_data);
@@ -828,7 +827,7 @@ struct pci_bits {
 	unsigned long		val;
 };
 
-extern void ata_pci_host_stop (struct ata_host_set *host_set);
+extern void ata_pci_host_stop (struct ata_host *host);
 extern struct ata_probe_ent *
 ata_pci_init_native_mode(struct pci_dev *pdev, struct ata_port_info **port, int portmask);
 extern int pci_test_config_bits(struct pci_dev *pdev, const struct pci_bits *bits);

commit b352e57dc3bb5033996adaa67c2f69b795eddd39
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Thu Aug 10 18:52:12 2006 +0100

    [PATCH] libata: Add CompactFlash support
    
    The CFA world has some additional rules and drive modes we need to support for
    newer expansion cards and on embedded boxes
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 060da736b3a8..806682603ac5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -225,8 +225,8 @@ enum {
 	/* encoding various smaller bitmaps into a single
 	 * unsigned int bitmap
 	 */
-	ATA_BITS_PIO		= 5,
-	ATA_BITS_MWDMA		= 3,
+	ATA_BITS_PIO		= 7,
+	ATA_BITS_MWDMA		= 5,
 	ATA_BITS_UDMA		= 8,
 
 	ATA_SHIFT_PIO		= 0,

commit 8b881b0410de0f72a43e814393abf3a4cb29ebb4
Author: Jeff Garzik <jeff@garzik.org>
Date:   Sun Jun 11 09:59:27 2006 -0400

    [ATA] Increase lba48 max-sectors from 200 to 256.
    
    Also, moved ATA_MAX_SECTORS and ATA_MAX_SECTORS_LBA48 from
    linux/libata.h to linux/ata.h, now that they truly reflect the standard
    (well... mostly; note TODO comment).
    
    This changes the performance profile (and potential bug profile)
    for a bunch of drivers, so be wary.

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ed749f778697..060da736b3a8 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -114,8 +114,6 @@ enum {
 	/* tag ATA_MAX_QUEUE - 1 is reserved for internal commands */
 	ATA_MAX_QUEUE		= 32,
 	ATA_TAG_INTERNAL	= ATA_MAX_QUEUE - 1,
-	ATA_MAX_SECTORS		= 200,	/* FIXME */
-	ATA_MAX_SECTORS_LBA48	= 65535,
 	ATA_MAX_BUS		= 2,
 	ATA_DEF_BUSY_WAIT	= 10000,
 	ATA_SHORT_PAUSE		= (HZ >> 6) + 1,

commit 4852ba24f647199be797545226c6d325db231937
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Aug 10 16:59:18 2006 +0900

    [PATCH] libata: kill unused hard_port_no and legacy_mode
    
    Kill unused probe_ent/ap->hard_port_no and probe_ent->legacy_mode.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 30bfe8f1666e..ed749f778697 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -352,12 +352,10 @@ struct ata_probe_ent {
 	struct scsi_host_template *sht;
 	struct ata_ioports	port[ATA_MAX_PORTS];
 	unsigned int		n_ports;
-	unsigned int		hard_port_no;
 	unsigned int		dummy_port_mask;
 	unsigned int		pio_mask;
 	unsigned int		mwdma_mask;
 	unsigned int		udma_mask;
-	unsigned int		legacy_mode;
 	unsigned long		irq;
 	unsigned long		irq2;
 	unsigned int		irq_flags;
@@ -509,7 +507,6 @@ struct ata_port {
 	unsigned int		pflags; /* ATA_PFLAG_xxx */
 	unsigned int		id;	/* unique id req'd by scsi midlyr */
 	unsigned int		port_no; /* unique port #; from zero */
-	unsigned int		hard_port_no;	/* hardware port #; from zero */
 
 	struct ata_prd		*prd;	 /* our SG list */
 	dma_addr_t		prd_dma; /* and its DMA mapping */

commit dd5b06c490de72440ec39f814de99a714a45a1a9
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Aug 10 16:59:12 2006 +0900

    [PATCH] libata: implement dummy port
    
    Implement dummy port which can be requested by setting appropriate bit
    in probe_ent->dummy_port_mask.  The dummy port is used as placeholder
    for stolen legacy port.  This allows libata to guarantee that
    index_of(ap) == ap->port_no == actual_device_port_no, and thus to
    remove error-prone ap->hard_port_no.
    
    As it's used only when one port of a legacy controller is reserved by
    some other entity (e.g. IDE), the focus is on keeping the added *code*
    complexity at minimum, so dummy port allocates all libata core
    resources and acts as a normal port.  It just has all dummy port_ops.
    
    This patch only implements dummy port.  The following patch will make
    libata use it for stolen legacy ports.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 4504776570e4..30bfe8f1666e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -353,6 +353,7 @@ struct ata_probe_ent {
 	struct ata_ioports	port[ATA_MAX_PORTS];
 	unsigned int		n_ports;
 	unsigned int		hard_port_no;
+	unsigned int		dummy_port_mask;
 	unsigned int		pio_mask;
 	unsigned int		mwdma_mask;
 	unsigned int		udma_mask;
@@ -652,6 +653,8 @@ extern const unsigned long sata_deb_timing_normal[];
 extern const unsigned long sata_deb_timing_hotplug[];
 extern const unsigned long sata_deb_timing_long[];
 
+extern const struct ata_port_operations ata_dummy_port_ops;
+
 static inline const unsigned long *
 sata_ehc_deb_timing(struct ata_eh_context *ehc)
 {
@@ -661,6 +664,11 @@ sata_ehc_deb_timing(struct ata_eh_context *ehc)
 		return sata_deb_timing_normal;
 }
 
+static inline int ata_port_is_dummy(struct ata_port *ap)
+{
+	return ap->ops == &ata_dummy_port_ops;
+}
+
 extern void ata_port_probe(struct ata_port *);
 extern void __sata_phy_reset(struct ata_port *ap);
 extern void sata_phy_reset(struct ata_port *ap);

commit 2ec7df0457b710d9201f211dbccdbecf0ad38b7e
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Thu Aug 10 16:59:10 2006 +0900

    [PATCH] libata: rework legacy handling to remove much of the cruft
    
    Kill host_set->next
    Fix simplex support
    Allow per platform setting of IDE legacy bases
    
    Some of this can be tidied further later on, in particular all the
    legacy port gunge belongs as a PCI quirk/PCI header decode to understand
    the special legacy IDE rules in the PCI spec.
    
    Longer term Jeff also wants to move the request_irq/free_irq out of core
    which will make this even cleaner.
    
    tj: folded in three followup patches - ata_piix-fix, broken-arch-fix
    and fix-new-legacy-handling, and separated per-dev xfermask into
    separate patch preceding this one.  Folded in fixes are...
    
    * ata_piix-fix: fix build failure due to host_set->next removal
    * broken-arch-fix: add missing include/asm-*/libata-portmap.h
    * fix-new-legacy-handling:
            * In ata_pci_init_legacy_port(), probe_num was incorrectly
              incremented during initialization of the secondary port and
              probe_ent->n_ports was incorrectly fixed to 1.
    
            * Both legacy ports ended up having the same hard_port_no.
    
            * When printing port information, both legacy ports printed
              the first irq.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index cf5eb1da3e32..4504776570e4 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -36,6 +36,8 @@
 #include <linux/workqueue.h>
 #include <scsi/scsi_host.h>
 
+#include <asm/libata-portmap.h>
+
 /*
  * compile-time options: to be removed as soon as all the drivers are
  * converted to the new debugging mechanism
@@ -356,6 +358,7 @@ struct ata_probe_ent {
 	unsigned int		udma_mask;
 	unsigned int		legacy_mode;
 	unsigned long		irq;
+	unsigned long		irq2;
 	unsigned int		irq_flags;
 	unsigned long		host_flags;
 	unsigned long		host_set_flags;
@@ -367,6 +370,7 @@ struct ata_host_set {
 	spinlock_t		lock;
 	struct device 		*dev;
 	unsigned long		irq;
+	unsigned long		irq2;
 	void __iomem		*mmio_base;
 	unsigned int		n_ports;
 	void			*private_data;
@@ -374,7 +378,6 @@ struct ata_host_set {
 	unsigned long		flags;
 	int			simplex_claimed;	/* Keep seperate in case we
 							   ever need to do this locked */
-	struct ata_host_set	*next;		/* for legacy mode */
 	struct ata_port		*ports[0];
 };
 

commit 80289167fd3ebaeb7b2641e69cbec44b61165fe7
Author: Brian King <brking@us.ibm.com>
Date:   Mon Aug 7 14:27:31 2006 -0500

    [PATCH] libata: Add support for SATA attachment to SAS adapters
    
    The following patch enhances libata to allow SAS device drivers
    to utilize libata to talk to SATA devices. It introduces some
    new APIs which allow libata to be used without allocating a
    virtual scsi host.
    
    New APIs:
    
    ata_sas_port_alloc - Allocate an ata_port
    ata_sas_port_init - Initialize an ata_port (probe device, etc)
    ata_sas_port_destroy - Free an ata_port allocated by ata_sas_port_alloc
    ata_sas_slave_configure - configure scsi device
    ata_sas_queuecmd - queue a scsi command, similar to ata_scsi_queuecomand
    
    These new APIs can be used either directly by a SAS LLDD or could be used
    by the SAS transport class.
    
    Possible usage for a SAS LLDD would be:
    
    scsi_scan_host
            target_alloc
                    ata_sas_port_alloc
            slave_alloc
                    ata_sas_port_init
            slave_configure
                    ata_sas_slave_configure
    
    Commands received by the LLDD for SATA devices would call ata_sas_queuecmd.
    
    Device teardown would occur with:
    
    slave_destroy
            port_disable
    target_destroy
            ata_sas_port_destroy
    
    Signed-off-by: Brian King <brking@us.ibm.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index be15ef5d8d85..cf5eb1da3e32 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -691,6 +691,15 @@ extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
 extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));
 extern int ata_scsi_release(struct Scsi_Host *host);
+extern void ata_sas_port_destroy(struct ata_port *);
+extern struct ata_port *ata_sas_port_alloc(struct ata_host_set *,
+					   struct ata_port_info *, struct Scsi_Host *);
+extern int ata_sas_port_init(struct ata_port *);
+extern int ata_sas_port_start(struct ata_port *ap);
+extern void ata_sas_port_stop(struct ata_port *ap);
+extern int ata_sas_slave_configure(struct scsi_device *, struct ata_port *);
+extern int ata_sas_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *),
+			    struct ata_port *ap);
 extern unsigned int ata_host_intr(struct ata_port *ap, struct ata_queued_cmd *qc);
 extern int sata_scr_valid(struct ata_port *ap);
 extern int sata_scr_read(struct ata_port *ap, int reg, u32 *val);

commit b03732f006bd1ecee32587ec8235c41af5ad905f
Author: Brian King <brking@us.ibm.com>
Date:   Mon Aug 7 14:27:10 2006 -0500

    [PATCH] libata: Add ata_host_set_init
    
    Add ata_host_set_init in preparation for SAS attached SATA.
    
    Signed-off-by: Brian King <brking@us.ibm.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b9416708bba2..be15ef5d8d85 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -684,6 +684,8 @@ extern int ata_pci_clear_simplex(struct pci_dev *pdev);
 #endif /* CONFIG_PCI */
 extern int ata_device_add(const struct ata_probe_ent *ent);
 extern void ata_port_detach(struct ata_port *ap);
+extern void ata_host_set_init(struct ata_host_set *, struct device *,
+			      unsigned long, const struct ata_port_operations *);
 extern void ata_host_set_remove(struct ata_host_set *host_set);
 extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);

commit 3c5100c1c40cc5e27b4da4a736994c76d93392a0
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Jul 26 16:58:33 2006 +0900

    [PATCH] libata: cosmetic changes to PM functions
    
    Unify pm_message_t argument to the new-style @mesg.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 66c3100c2b94..b9416708bba2 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -676,9 +676,9 @@ extern void ata_std_ports(struct ata_ioports *ioaddr);
 extern int ata_pci_init_one (struct pci_dev *pdev, struct ata_port_info **port_info,
 			     unsigned int n_ports);
 extern void ata_pci_remove_one (struct pci_dev *pdev);
-extern void ata_pci_device_do_suspend(struct pci_dev *pdev, pm_message_t state);
+extern void ata_pci_device_do_suspend(struct pci_dev *pdev, pm_message_t mesg);
 extern void ata_pci_device_do_resume(struct pci_dev *pdev);
-extern int ata_pci_device_suspend(struct pci_dev *pdev, pm_message_t state);
+extern int ata_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg);
 extern int ata_pci_device_resume(struct pci_dev *pdev);
 extern int ata_pci_clear_simplex(struct pci_dev *pdev);
 #endif /* CONFIG_PCI */
@@ -697,7 +697,7 @@ extern int sata_scr_write_flush(struct ata_port *ap, int reg, u32 val);
 extern int ata_port_online(struct ata_port *ap);
 extern int ata_port_offline(struct ata_port *ap);
 extern int ata_scsi_device_resume(struct scsi_device *);
-extern int ata_scsi_device_suspend(struct scsi_device *, pm_message_t state);
+extern int ata_scsi_device_suspend(struct scsi_device *, pm_message_t mesg);
 extern int ata_host_set_suspend(struct ata_host_set *host_set,
 				pm_message_t mesg);
 extern void ata_host_set_resume(struct ata_host_set *host_set);

commit 13abf50df209008b5d44075bafeeab42ace56aa6
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jul 10 23:18:46 2006 +0900

    [PATCH] libata: improve EH action and EHI flag handling
    
    Update ata_eh_about_to_do() and ata_eh_done() to improve EH action and
    EHI flag handling.
    
    * There are two types of EHI flags - one which expires on successful
      EH and the other which expires on a successful reset.  Make this
      distinction clear.
    
    * Unlike other EH actions, reset actions are represented by two EH
      action masks and a EHI modifier.  Implement correct about_to_do/done
      semantics for resets.  That is, prior to reset, related EH info is
      sucked in from ehi and cleared, and after reset is complete, related
      EH info in ehc is cleared.
    
    These changes improve consistency and remove unnecessary EH actions
    caused by stale EH action masks and EHI flags.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6cc497a2b6da..66c3100c2b94 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -265,12 +265,14 @@ enum {
 
 	/* ata_eh_info->flags */
 	ATA_EHI_HOTPLUGGED	= (1 << 0),  /* could have been hotplugged */
-	ATA_EHI_RESUME_LINK	= (1 << 1),  /* need to resume link */
+	ATA_EHI_RESUME_LINK	= (1 << 1),  /* resume link (reset modifier) */
 	ATA_EHI_NO_AUTOPSY	= (1 << 2),  /* no autopsy */
 	ATA_EHI_QUIET		= (1 << 3),  /* be quiet */
 
 	ATA_EHI_DID_RESET	= (1 << 16), /* already reset this port */
 
+	ATA_EHI_RESET_MODIFIER_MASK = ATA_EHI_RESUME_LINK,
+
 	/* max repeat if error condition is still set after ->error_handler */
 	ATA_EH_MAX_REPEAT	= 5,
 

commit 500530f652f9e5dabe7571b018dec47742ce0f16
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jul 3 16:07:27 2006 +0900

    [PATCH] libata: reimplement controller-wide PM
    
    Reimplement controller-wide PM.  ata_host_set_suspend/resume() are
    defined to suspend and resume a host_set.  While suspended, EHs for
    all ports in the host_set are pegged using ATA_FLAG_SUSPENDED and
    frozen.
    
    Because SCSI device hotplug is done asynchronously against the rest of
    libata EH and the same mutex is used when adding new device, suspend
    cannot wait for hotplug to complete.  So, if SCSI device hotplug is in
    progress, suspend fails with -EBUSY.
    
    In most cases, host_set resume is followed by device resume.  As each
    resume operation requires a reset, a single host_set-wide resume
    operation may result in multiple resets.  To avoid this, resume waits
    upto 1 second giving PM to request resume for devices.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 5ac262608199..6cc497a2b6da 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -182,6 +182,7 @@ enum {
 
 	ATA_PFLAG_FLUSH_PORT_TASK = (1 << 16), /* flush port task */
 	ATA_PFLAG_SUSPENDED	= (1 << 17), /* port is suspended (power) */
+	ATA_PFLAG_PM_PENDING	= (1 << 18), /* PM operation pending */
 
 	/* struct ata_queued_cmd flags */
 	ATA_QCFLAG_ACTIVE	= (1 << 0), /* cmd not yet ack'd to scsi lyer */
@@ -549,6 +550,9 @@ struct ata_port {
 	struct list_head	eh_done_q;
 	wait_queue_head_t	eh_wait_q;
 
+	pm_message_t		pm_mesg;
+	int			*pm_result;
+
 	void			*private_data;
 
 	u8			sector_buf[ATA_SECT_SIZE]; /* owned by EH */
@@ -603,6 +607,9 @@ struct ata_port_operations {
 	void (*scr_write) (struct ata_port *ap, unsigned int sc_reg,
 			   u32 val);
 
+	int (*port_suspend) (struct ata_port *ap, pm_message_t mesg);
+	int (*port_resume) (struct ata_port *ap);
+
 	int (*port_start) (struct ata_port *ap);
 	void (*port_stop) (struct ata_port *ap);
 
@@ -667,6 +674,8 @@ extern void ata_std_ports(struct ata_ioports *ioaddr);
 extern int ata_pci_init_one (struct pci_dev *pdev, struct ata_port_info **port_info,
 			     unsigned int n_ports);
 extern void ata_pci_remove_one (struct pci_dev *pdev);
+extern void ata_pci_device_do_suspend(struct pci_dev *pdev, pm_message_t state);
+extern void ata_pci_device_do_resume(struct pci_dev *pdev);
 extern int ata_pci_device_suspend(struct pci_dev *pdev, pm_message_t state);
 extern int ata_pci_device_resume(struct pci_dev *pdev);
 extern int ata_pci_clear_simplex(struct pci_dev *pdev);
@@ -687,6 +696,9 @@ extern int ata_port_online(struct ata_port *ap);
 extern int ata_port_offline(struct ata_port *ap);
 extern int ata_scsi_device_resume(struct scsi_device *);
 extern int ata_scsi_device_suspend(struct scsi_device *, pm_message_t state);
+extern int ata_host_set_suspend(struct ata_host_set *host_set,
+				pm_message_t mesg);
+extern void ata_host_set_resume(struct ata_host_set *host_set);
 extern int ata_ratelimit(void);
 extern unsigned int ata_busy_sleep(struct ata_port *ap,
 				   unsigned long timeout_pat,

commit d6f26d1f1f1128a896f38a7f8426daed0a1205a2
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jul 3 16:07:26 2006 +0900

    [PATCH] libata: reimplement per-dev PM
    
    Reimplement per-dev PM.  The original implementation directly put the
    device into suspended mode and didn't synchronize w/ EH operations
    including hotplug.  This patch reimplements ata_scsi_device_suspend()
    and ata_scsi_device_resume() such that they request EH to perform the
    respective operations.  Both functions synchronize with hotplug such
    that it doesn't operate on detached devices.
    
    Suspend waits for completion but resume just issues request and
    returns.  This allows parallel wake up of devices and thus speeds up
    system resume.
    
    Due to sdev detach synchronization, it's not feasible to separate out
    EH requesting from sdev handling; thus, ata_device_suspend/resume()
    are removed and everything is implemented in the respective
    libata-scsi functions.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 363c7501843a..5ac262608199 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -687,8 +687,6 @@ extern int ata_port_online(struct ata_port *ap);
 extern int ata_port_offline(struct ata_port *ap);
 extern int ata_scsi_device_resume(struct scsi_device *);
 extern int ata_scsi_device_suspend(struct scsi_device *, pm_message_t state);
-extern int ata_device_resume(struct ata_device *);
-extern int ata_device_suspend(struct ata_device *, pm_message_t state);
 extern int ata_ratelimit(void);
 extern unsigned int ata_busy_sleep(struct ata_port *ap,
 				   unsigned long timeout_pat,

commit 02670bf379267f55a43aa57f6895689697e90eb3
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jul 3 16:07:26 2006 +0900

    [PATCH] libata: implement PM EH actions
    
    Implement two PM per-dev EH actions - ATA_EH_SUSPEND and
    ATA_EH_RESUME.  Each action puts the target device into suspended mode
    and resumes from it respectively.
    
    Once a device is put to suspended mode, no EH operations other than
    RESUME is allowed on the device.  The device will stay suspended till
    it gets resumed and thus reset and revalidated.  To implement this, a
    new device state helper - ata_dev_ready() - is implemented and used in
    EH action implementations to make them operate only on attached &
    running devices.
    
    If all possible devices on a port are suspended, reset is skipped too.
    This prevents spurious events including hotplug events from disrupting
    suspended devices.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 2aa1398bbd52..363c7501843a 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -131,6 +131,7 @@ enum {
 	ATA_DFLAG_CFG_MASK	= (1 << 8) - 1,
 
 	ATA_DFLAG_PIO		= (1 << 8), /* device currently in PIO mode */
+	ATA_DFLAG_SUSPENDED	= (1 << 9), /* device suspended */
 	ATA_DFLAG_INIT_MASK	= (1 << 16) - 1,
 
 	ATA_DFLAG_DETACH	= (1 << 16),
@@ -253,9 +254,13 @@ enum {
 	ATA_EH_REVALIDATE	= (1 << 0),
 	ATA_EH_SOFTRESET	= (1 << 1),
 	ATA_EH_HARDRESET	= (1 << 2),
+	ATA_EH_SUSPEND		= (1 << 3),
+	ATA_EH_RESUME		= (1 << 4),
+	ATA_EH_PM_FREEZE	= (1 << 5),
 
 	ATA_EH_RESET_MASK	= ATA_EH_SOFTRESET | ATA_EH_HARDRESET,
-	ATA_EH_PERDEV_MASK	= ATA_EH_REVALIDATE,
+	ATA_EH_PERDEV_MASK	= ATA_EH_REVALIDATE | ATA_EH_SUSPEND |
+				  ATA_EH_RESUME | ATA_EH_PM_FREEZE,
 
 	/* ata_eh_info->flags */
 	ATA_EHI_HOTPLUGGED	= (1 << 0),  /* could have been hotplugged */
@@ -944,6 +949,11 @@ static inline unsigned int ata_dev_absent(const struct ata_device *dev)
 	return ata_class_absent(dev->class);
 }
 
+static inline unsigned int ata_dev_ready(const struct ata_device *dev)
+{
+	return ata_dev_enabled(dev) && !(dev->flags & ATA_DFLAG_SUSPENDED);
+}
+
 /*
  * port helpers
  */

commit c0b6c0377c32fe3f6a2cf1e018db6da8a3b78379
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jul 3 16:07:26 2006 +0900

    [PATCH] libata: separate out __ata_ehi_hotplugged()
    
    Separate out __ata_ehi_hotplugged() from ata_ehi_hotplugged().  The
    underscored version doesn't set AC_ERR_ATA_BUS.  This will be used for
    resume which is a hotplug event but not an ATA bus error.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 36938ae1254d..2aa1398bbd52 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -843,7 +843,7 @@ extern void ata_do_eh(struct ata_port *ap, ata_prereset_fn_t prereset,
 	(ehi)->desc_len = 0; \
 } while (0)
 
-static inline void ata_ehi_hotplugged(struct ata_eh_info *ehi)
+static inline void __ata_ehi_hotplugged(struct ata_eh_info *ehi)
 {
 	if (ehi->flags & ATA_EHI_HOTPLUGGED)
 		return;
@@ -851,11 +851,16 @@ static inline void ata_ehi_hotplugged(struct ata_eh_info *ehi)
 	ehi->flags |= ATA_EHI_HOTPLUGGED | ATA_EHI_RESUME_LINK;
 	ehi->hotplug_timestamp = jiffies;
 
-	ehi->err_mask |= AC_ERR_ATA_BUS;
 	ehi->action |= ATA_EH_SOFTRESET;
 	ehi->probe_mask |= (1 << ATA_MAX_DEVICES) - 1;
 }
 
+static inline void ata_ehi_hotplugged(struct ata_eh_info *ehi)
+{
+	__ata_ehi_hotplugged(ehi);
+	ehi->err_mask |= AC_ERR_ATA_BUS;
+}
+
 /*
  * qc helpers
  */

commit 1cdaf534f829b8759ba30f97d5e8dceb2ab77ba4
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jul 3 16:07:26 2006 +0900

    [PATCH] libata: implement ATA_EHI_NO_AUTOPSY and QUIET
    
    Implement ATA_EHI_NO_AUTOPSY and QUIET.  These used to be implied by
    ATA_PFLAG_LOADING, but new power management and PMP support need to
    use these separately.  e.g. Suspend/resume operations shouldn't print
    full EH messages and resume shouldn't be recorded as an error.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 2f7bbfc0c41b..36938ae1254d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -260,6 +260,8 @@ enum {
 	/* ata_eh_info->flags */
 	ATA_EHI_HOTPLUGGED	= (1 << 0),  /* could have been hotplugged */
 	ATA_EHI_RESUME_LINK	= (1 << 1),  /* need to resume link */
+	ATA_EHI_NO_AUTOPSY	= (1 << 2),  /* no autopsy */
+	ATA_EHI_QUIET		= (1 << 3),  /* be quiet */
 
 	ATA_EHI_DID_RESET	= (1 << 16), /* already reset this port */
 

commit e9c839142d698086d3fe33a0daafde55ddd00c4e
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jul 3 16:07:26 2006 +0900

    [PATCH] libata: clean up debounce parameters and improve parameter selection
    
    The names of predefined debounce timing parameters didn't exactly
    match their usages.  Rename to more generic names and implement param
    selection helper sata_ehc_deb_timing() which uses EHI_HOTPLUGGED to
    select params.
    
    Combined with the previous EHI_RESUME_LINK differentiation, this makes
    parameter selection accurate.  e.g. user scan resumes link but normal
    deb param is used instead of hotplug param.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 4d4ed2c8fec7..2f7bbfc0c41b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -629,9 +629,18 @@ struct ata_timing {
 
 #define FIT(v,vmin,vmax)	max_t(short,min_t(short,v,vmax),vmin)
 
-extern const unsigned long sata_deb_timing_boot[];
-extern const unsigned long sata_deb_timing_eh[];
-extern const unsigned long sata_deb_timing_before_fsrst[];
+extern const unsigned long sata_deb_timing_normal[];
+extern const unsigned long sata_deb_timing_hotplug[];
+extern const unsigned long sata_deb_timing_long[];
+
+static inline const unsigned long *
+sata_ehc_deb_timing(struct ata_eh_context *ehc)
+{
+	if (ehc->i.flags & ATA_EHI_HOTPLUGGED)
+		return sata_deb_timing_hotplug;
+	else
+		return sata_deb_timing_normal;
+}
 
 extern void ata_port_probe(struct ata_port *);
 extern void __sata_phy_reset(struct ata_port *ap);

commit 28324304350e23db24d679c55de3f06a5b1e40aa
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jul 3 16:07:26 2006 +0900

    [PATCH] libata: implement ATA_EHI_RESUME_LINK
    
    Implement ATA_EHI_RESUME_LINK, which indicates that the link needs to
    be resumed.  This used to be implied by ATA_EHI_HOTPLUGGED.  However,
    hotplug isn't the only event which requires link resume and separating
    this out allows other places to request link resume.  This
    differentiation also allows better debounce timing selection.
    
    This patch converts user scan to use ATA_EHI_RESUME_LINK.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b5d247d780f8..4d4ed2c8fec7 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -259,6 +259,7 @@ enum {
 
 	/* ata_eh_info->flags */
 	ATA_EHI_HOTPLUGGED	= (1 << 0),  /* could have been hotplugged */
+	ATA_EHI_RESUME_LINK	= (1 << 1),  /* need to resume link */
 
 	ATA_EHI_DID_RESET	= (1 << 16), /* already reset this port */
 
@@ -836,7 +837,7 @@ static inline void ata_ehi_hotplugged(struct ata_eh_info *ehi)
 	if (ehi->flags & ATA_EHI_HOTPLUGGED)
 		return;
 
-	ehi->flags |= ATA_EHI_HOTPLUGGED;
+	ehi->flags |= ATA_EHI_HOTPLUGGED | ATA_EHI_RESUME_LINK;
 	ehi->hotplug_timestamp = jiffies;
 
 	ehi->err_mask |= AC_ERR_ATA_BUS;

commit b51e9e5db0e36239f786692f1cac6e435ed30c66
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Jun 29 01:29:30 2006 +0900

    [PATCH] libata: add ap->pflags and move core dynamic flags to it
    
    ap->flags is way too clamped.  Separate out core dynamic flags to
    ap->pflags.  ATA_FLAG_DISABLED is a dynamic flag but left alone as
    it's referenced by a lot of LLDs and it's gonna be removed once all
    LLDs are converted to new EH.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index f4284bf89758..b5d247d780f8 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -160,22 +160,27 @@ enum {
 	ATA_FLAG_HRST_TO_RESUME	= (1 << 11), /* hardreset to resume phy */
 	ATA_FLAG_SKIP_D2H_BSY	= (1 << 12), /* can't wait for the first D2H
 					      * Register FIS clearing BSY */
-
 	ATA_FLAG_DEBUGMSG	= (1 << 13),
-	ATA_FLAG_FLUSH_PORT_TASK = (1 << 14), /* flush port task */
 
-	ATA_FLAG_EH_PENDING	= (1 << 15), /* EH pending */
-	ATA_FLAG_EH_IN_PROGRESS	= (1 << 16), /* EH in progress */
-	ATA_FLAG_FROZEN		= (1 << 17), /* port is frozen */
-	ATA_FLAG_RECOVERED	= (1 << 18), /* recovery action performed */
-	ATA_FLAG_LOADING	= (1 << 19), /* boot/loading probe */
-	ATA_FLAG_UNLOADING	= (1 << 20), /* module is unloading */
-	ATA_FLAG_SCSI_HOTPLUG	= (1 << 21), /* SCSI hotplug scheduled */
+	/* The following flag belongs to ap->pflags but is kept in
+	 * ap->flags because it's referenced in many LLDs and will be
+	 * removed in not-too-distant future.
+	 */
+	ATA_FLAG_DISABLED	= (1 << 23), /* port is disabled, ignore it */
+
+	/* bits 24:31 of ap->flags are reserved for LLD specific flags */
 
-	ATA_FLAG_DISABLED	= (1 << 22), /* port is disabled, ignore it */
-	ATA_FLAG_SUSPENDED	= (1 << 23), /* port is suspended (power) */
+	/* struct ata_port pflags */
+	ATA_PFLAG_EH_PENDING	= (1 << 0), /* EH pending */
+	ATA_PFLAG_EH_IN_PROGRESS = (1 << 1), /* EH in progress */
+	ATA_PFLAG_FROZEN	= (1 << 2), /* port is frozen */
+	ATA_PFLAG_RECOVERED	= (1 << 3), /* recovery action performed */
+	ATA_PFLAG_LOADING	= (1 << 4), /* boot/loading probe */
+	ATA_PFLAG_UNLOADING	= (1 << 5), /* module is unloading */
+	ATA_PFLAG_SCSI_HOTPLUG	= (1 << 6), /* SCSI hotplug scheduled */
 
-	/* bits 24:31 of ap->flags are reserved for LLDD specific flags */
+	ATA_PFLAG_FLUSH_PORT_TASK = (1 << 16), /* flush port task */
+	ATA_PFLAG_SUSPENDED	= (1 << 17), /* port is suspended (power) */
 
 	/* struct ata_queued_cmd flags */
 	ATA_QCFLAG_ACTIVE	= (1 << 0), /* cmd not yet ack'd to scsi lyer */
@@ -486,6 +491,7 @@ struct ata_port {
 	const struct ata_port_operations *ops;
 	spinlock_t		*lock;
 	unsigned long		flags;	/* ATA_FLAG_xxx */
+	unsigned int		pflags; /* ATA_PFLAG_xxx */
 	unsigned int		id;	/* unique id req'd by scsi midlyr */
 	unsigned int		port_no; /* unique port #; from zero */
 	unsigned int		hard_port_no;	/* hardware port #; from zero */

commit 5806db22cffc7557b675d3c9229f327980aee797
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Jun 24 20:30:19 2006 +0900

    [PATCH] libata: implement ata_port_max_devices()
    
    Implement ata_port_max_devices().  This function returns the number of
    possible devices on a port.  This will be used by new PM
    implementation.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c227dace1d26..f4284bf89758 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -888,6 +888,9 @@ static inline unsigned int ata_tag_internal(unsigned int tag)
 	return tag == ATA_MAX_QUEUE - 1;
 }
 
+/*
+ * device helpers
+ */
 static inline unsigned int ata_class_enabled(unsigned int class)
 {
 	return class == ATA_DEV_ATA || class == ATA_DEV_ATAPI;
@@ -918,6 +921,17 @@ static inline unsigned int ata_dev_absent(const struct ata_device *dev)
 	return ata_class_absent(dev->class);
 }
 
+/*
+ * port helpers
+ */
+static inline int ata_port_max_devices(const struct ata_port *ap)
+{
+	if (ap->flags & ATA_FLAG_SLAVE_POSS)
+		return 2;
+	return 1;
+}
+
+
 static inline u8 ata_chk_status(struct ata_port *ap)
 {
 	return ap->ops->check_status(ap);

commit 41542dbe12e34165e586de1e3fe0a245707aa39e
Author: Andrew Morton <akpm@osdl.org>
Date:   Fri Jun 23 04:18:31 2006 -0700

    [PATCH] libata.h needs scatterlist.h
    
    From: Andrew Morton <akpm@osdl.org>
    
    s390:
    
    In file included from drivers/scsi/libata-bmdma.c:39:                           include/linux/libata.h:391: error: field 'sgent' has incomplete type
    include/linux/libata.h:392: error: field 'pad_sgent' has incomplete type
    include/linux/libata.h: In function 'ata_sg_is_last':                           include/linux/libata.h:849: error: arithmetic on pointer to an incomplete type
    include/linux/libata.h:849: error: arithmetic on pointer to an incomplete type
    include/linux/libata.h: In function 'ata_qc_next_sg':
    include/linux/libata.h:869: error: increment of pointer to unknown structure
    include/linux/libata.h:869: error: arithmetic on pointer to an incomplete type
    include/linux/libata.h:869: error: arithmetic on pointer to an incomplete type
    include/linux/libata.h:869: error: arithmetic on pointer to an incomplete type
    
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 20b1cf527c60..c227dace1d26 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -30,6 +30,7 @@
 #include <linux/interrupt.h>
 #include <linux/pci.h>
 #include <linux/dma-mapping.h>
+#include <asm/scatterlist.h>
 #include <asm/io.h>
 #include <linux/ata.h>
 #include <linux/workqueue.h>

commit ba6a13083c1b720a47c05bee7bedbb6ef06c4611
Author: Jeff Garzik <jeff@garzik.org>
Date:   Thu Jun 22 23:46:10 2006 -0400

    [libata] Add host lock to struct ata_port
    
    Prepare for changes required to support SATA devices
    attached to SAS HBAs. For these devices we don't want to
    use host_set at all, since libata will not be the owner
    of struct scsi_host.
    
    Signed-off-by: Brian King <brking@us.ibm.com>
    
    (with slight merge modifications made by...)
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6b3c3af2c75f..20b1cf527c60 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -483,6 +483,7 @@ struct ata_eh_context {
 struct ata_port {
 	struct Scsi_Host	*host;	/* our co-allocated scsi host */
 	const struct ata_port_operations *ops;
+	spinlock_t		*lock;
 	unsigned long		flags;	/* ATA_FLAG_xxx */
 	unsigned int		id;	/* unique id req'd by scsi midlyr */
 	unsigned int		port_no; /* unique port #; from zero */

commit 47005f255ed126a4b48a1a2f63164fb1d83bcb0a
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jun 19 18:27:23 2006 +0900

    [PATCH] libata: implement per-dev EH action mask eh_info->dev_action[]
    
    Currently, the only per-dev EH action is REVALIDATE.  EH used to
    exploit ehi->dev to do selective revalidation on a ATA bus.  However,
    this is a bit hacky and makes it impossible to request selective
    revalidation from outside of EH or add another per-dev EH action.
    
    This patch adds per-dev EH action mask eh_info->dev_action[] and
    update EH to use this field for REVALIDATE.  Note that per-dev actions
    can still be specified at port-level and it has the same effect of
    specifying the action for all devices on the port.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index f03b8664af11..6b3c3af2c75f 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -249,6 +249,7 @@ enum {
 	ATA_EH_HARDRESET	= (1 << 2),
 
 	ATA_EH_RESET_MASK	= ATA_EH_SOFTRESET | ATA_EH_HARDRESET,
+	ATA_EH_PERDEV_MASK	= ATA_EH_REVALIDATE,
 
 	/* ata_eh_info->flags */
 	ATA_EHI_HOTPLUGGED	= (1 << 0),  /* could have been hotplugged */
@@ -462,6 +463,7 @@ struct ata_eh_info {
 	u32			serror;		/* SError from LLDD */
 	unsigned int		err_mask;	/* port-wide err_mask */
 	unsigned int		action;		/* ATA_EH_* action mask */
+	unsigned int		dev_action[ATA_MAX_DEVICES]; /* dev EH action */
 	unsigned int		flags;		/* ATA_EHI_* flags */
 
 	unsigned long		hotplug_timestamp;

commit f0eb62b81dd16bfc4034916418c3406ba20011e1
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jun 12 23:05:38 2006 +0900

    [PATCH] libata: add host_set->next for legacy two host_sets case, take #3
    
    For a legacy ATA controller, libata registers two separate host sets.
    There was no connection between the two hosts making it impossible to
    traverse all ports related to the controller.  This patch adds
    host_set->next which points to the second host_set and makes
    ata_pci_remove_one() remove all associated host_sets.
    
    * On device removal, all ports hanging off the device are properly
      detached.  Prior to this patch, ports on the first host_set weren't
      detached casuing oops on driver unloading.
    
    * On device removal, both host_sets are properly freed
    
    This will also be used by new power management code to suspend and
    resume all ports of a controller.  host_set/port representation will
    be improved to handle legacy controllers better and this host_set
    linking will go away with it.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 61eea5795d5a..f03b8664af11 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -356,7 +356,8 @@ struct ata_host_set {
 	unsigned long		flags;
 	int			simplex_claimed;	/* Keep seperate in case we
 							   ever need to do this locked */
-	struct ata_port *	ports[0];
+	struct ata_host_set	*next;		/* for legacy mode */
+	struct ata_port		*ports[0];
 };
 
 struct ata_queued_cmd {

commit 3b01b8af2414b6684051da4a1507dfacdbf24f86
Author: Jeff Garzik <jeff@garzik.org>
Date:   Mon Jun 12 00:22:04 2006 -0400

    libata: fix build, by adding required workqueue member to port struct

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 39e6b77de1a9..61eea5795d5a 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -522,6 +522,7 @@ struct ata_port {
 
 	struct work_struct	port_task;
 	struct work_struct	hotplug_task;
+	struct work_struct	scsi_rescan_task;
 
 	unsigned int		hsm_task_state;
 

commit 9a9c77dc4c4eed9dfb74080e768c0b3c9d905496
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Jun 11 11:19:00 2006 +0900

    [PATCH] libata: cosmetic change in struct ata_port
    
    Cosmetic change in struct ata_port.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a2a33a902917..39e6b77de1a9 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -520,7 +520,8 @@ struct ata_port {
 	struct ata_host_set	*host_set;
 	struct device 		*dev;
 
-	struct work_struct	port_task, hotplug_task;
+	struct work_struct	port_task;
+	struct work_struct	hotplug_task;
 
 	unsigned int		hsm_task_state;
 

commit 52783c5dcc8d317bc8c3e2692d366e8a305abada
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed May 31 18:28:22 2006 +0900

    [PATCH] libata-hp: killl ops->probe_reset
    
    Now that all drivers implementing new EH are converted to new probing
    mechanism, ops->probe_reset doesn't have any user.  Kill it.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index f11ba2715bef..a2a33a902917 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -303,7 +303,6 @@ struct ata_queued_cmd;
 
 /* typedefs */
 typedef void (*ata_qc_cb_t) (struct ata_queued_cmd *qc);
-typedef void (*ata_probeinit_fn_t)(struct ata_port *ap);
 typedef int (*ata_prereset_fn_t)(struct ata_port *ap);
 typedef int (*ata_reset_fn_t)(struct ata_port *ap, unsigned int *classes);
 typedef void (*ata_postreset_fn_t)(struct ata_port *ap, unsigned int *classes);
@@ -553,7 +552,6 @@ struct ata_port_operations {
 
 	void (*phy_reset) (struct ata_port *ap); /* obsolete */
 	void (*set_mode) (struct ata_port *ap);
-	int (*probe_reset) (struct ata_port *ap, unsigned int *classes);
 
 	void (*post_set_mode) (struct ata_port *ap);
 
@@ -628,11 +626,6 @@ extern void ata_bus_reset(struct ata_port *ap);
 extern int sata_set_spd(struct ata_port *ap);
 extern int sata_phy_debounce(struct ata_port *ap, const unsigned long *param);
 extern int sata_phy_resume(struct ata_port *ap, const unsigned long *param);
-extern int ata_drive_probe_reset(struct ata_port *ap,
-			ata_probeinit_fn_t probeinit,
-			ata_reset_fn_t softreset, ata_reset_fn_t hardreset,
-			ata_postreset_fn_t postreset, unsigned int *classes);
-extern void ata_std_probeinit(struct ata_port *ap);
 extern int ata_std_prereset(struct ata_port *ap);
 extern int ata_std_softreset(struct ata_port *ap, unsigned int *classes);
 extern int sata_std_hardreset(struct ata_port *ap, unsigned int *class);
@@ -688,7 +681,6 @@ extern void ata_std_dev_select (struct ata_port *ap, unsigned int device);
 extern u8 ata_check_status(struct ata_port *ap);
 extern u8 ata_altstatus(struct ata_port *ap);
 extern void ata_exec_command(struct ata_port *ap, const struct ata_taskfile *tf);
-extern int ata_std_probe_reset(struct ata_port *ap, unsigned int *classes);
 extern int ata_port_start (struct ata_port *ap);
 extern void ata_port_stop (struct ata_port *ap);
 extern void ata_host_stop (struct ata_host_set *host_set);

commit 720ba12620ee09dce269adf4ad50958adac7bb54
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed May 31 18:28:13 2006 +0900

    [PATCH] libata-hp: update unload-unplug
    
    Update unload unplug - driver unloading / PCI removal.  This is done
    by ata_port_detach() which short-circuits EH, disables all devices and
    freezes the port.  With this patch, EH and unloading/unplugging are
    properly synchronized.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 74786c33c526..f11ba2715bef 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -649,6 +649,7 @@ extern int ata_pci_device_resume(struct pci_dev *pdev);
 extern int ata_pci_clear_simplex(struct pci_dev *pdev);
 #endif /* CONFIG_PCI */
 extern int ata_device_add(const struct ata_probe_ent *ent);
+extern void ata_port_detach(struct ata_port *ap);
 extern void ata_host_set_remove(struct ata_host_set *host_set);
 extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);

commit 83c47bcb3c533180a6dda78152334de50065358a
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed May 31 18:28:07 2006 +0900

    [PATCH] libata-hp: implement warmplug
    
    Implement warmplug.  User-initiated unplug can be detected by
    hostt->slave_destroy() and plug by transportt->user_scan().  This
    patch only implements the two callbacks.  The next function will hook
    them.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 407115624d9f..74786c33c526 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -734,6 +734,7 @@ extern int ata_std_bios_param(struct scsi_device *sdev,
 			      struct block_device *bdev,
 			      sector_t capacity, int geom[]);
 extern int ata_scsi_slave_config(struct scsi_device *sdev);
+extern void ata_scsi_slave_destroy(struct scsi_device *sdev);
 extern int ata_scsi_change_queue_depth(struct scsi_device *sdev,
 				       int queue_depth);
 extern struct ata_device *ata_dev_pair(struct ata_device *adev);

commit 580b2102327ab8444af5bde4e70b50d268a1d558
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed May 31 18:28:05 2006 +0900

    [PATCH] libata-hp: implement SCSI part of hotplug
    
    Implement SCSI part of hotplug.
    
    This must be done in a separate context as SCSI makes use of EH during
    probing.  SCSI scan fails silently if EH is in progress.  In such
    cases, libata pauses briefly and retries until every device is
    attached.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 56971943d261..407115624d9f 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -521,7 +521,7 @@ struct ata_port {
 	struct ata_host_set	*host_set;
 	struct device 		*dev;
 
-	struct work_struct	port_task;
+	struct work_struct	port_task, hotplug_task;
 
 	unsigned int		hsm_task_state;
 

commit 084fe639b81c4d418a2cf714acb0475e3713cb73
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed May 31 18:28:03 2006 +0900

    [PATCH] libata-hp: implement hotplug
    
    Implement ATA part of hotplug.  To avoid probing broken devices over
    and over again, disabled devices are not automatically detached.  They
    are detached only if probing is requested for the device or the
    associated port is offline.  Also, to avoid infinite probing loop,
    Each device is probed only once per EH run.
    
    As SATA PHY status is fragile, devices are detached only after it has
    used up its recovery chances unless explicitly requested by LLDD or
    user (LLDD may request direct detach if, for example, it supports cold
    presence detection).
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a1ceb5b67b97..56971943d261 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -824,6 +824,19 @@ extern void ata_do_eh(struct ata_port *ap, ata_prereset_fn_t prereset,
 	(ehi)->desc_len = 0; \
 } while (0)
 
+static inline void ata_ehi_hotplugged(struct ata_eh_info *ehi)
+{
+	if (ehi->flags & ATA_EHI_HOTPLUGGED)
+		return;
+
+	ehi->flags |= ATA_EHI_HOTPLUGGED;
+	ehi->hotplug_timestamp = jiffies;
+
+	ehi->err_mask |= AC_ERR_ATA_BUS;
+	ehi->action |= ATA_EH_SOFTRESET;
+	ehi->probe_mask |= (1 << ATA_MAX_DEVICES) - 1;
+}
+
 /*
  * qc helpers
  */

commit 9a1004d0c11be41c83d06a67dfe74567a41ae582
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed May 31 18:27:52 2006 +0900

    [PATCH] libata: export ata_hsm_move()
    
    ata_hsm_move() will be used by LLDDs which depend on standard PIO HSM
    but implement their own interrupt handlers.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index fe5f53943c44..a1ceb5b67b97 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -723,6 +723,8 @@ extern void ata_bmdma_drive_eh(struct ata_port *ap, ata_prereset_fn_t prereset,
 			       ata_postreset_fn_t postreset);
 extern void ata_bmdma_error_handler(struct ata_port *ap);
 extern void ata_bmdma_post_internal_cmd(struct ata_queued_cmd *qc);
+extern int ata_hsm_move(struct ata_port *ap, struct ata_queued_cmd *qc,
+			u8 status, int in_wq);
 extern void ata_qc_complete(struct ata_queued_cmd *qc);
 extern int ata_qc_complete_multiple(struct ata_port *ap, u32 qc_active,
 				    void (*finish_qc)(struct ata_queued_cmd *));

commit f5914a461eb9703773226a0813f6ffcae10c0861
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed May 31 18:27:48 2006 +0900

    [PATCH] libata-hp-prep: add prereset() method and implement ata_std_prereset()
    
    With hotplug, every reset might be a probing reset and thus something
    similar to probe_init() is needed.  prereset() method is called before
    a series of resets to a port and is the counterpart of postreset().
    prereset() can tell EH to use different type of reset or skip reset by
    modifying ehc->i.action.
    
    This patch also implements ata_std_prereset().  Most controllers
    should be able to use this function directly or with some wrapping.
    After hotplug, different controllers need different actions to resume
    the PHY and detect the newly attached device.  Controllers can be
    categorized as follows.
    
    * Controllers which can wait for the first D2H FIS after hotplug.
      Note that if the waiting is implemented by polling TF status, there
      needs to be a way to set BSY on PHY status change.  It can be
      implemented by hardware or with the help of the driver.
    
    * Controllers which can wait for the first D2H FIS after sending
      COMRESET.  These controllers need to issue COMRESET to wait for the
      first FIS.  Note that the received D2H FIS could be the first D2H
      FIS after POR (power-on-reset) or D2H FIS in response to the
      COMRESET.  Some controllers use COMRESET as TF status
      synchronization point and clear TF automatically (sata_sil).
    
    * Controllers which cannot wait for the first D2H FIS reliably.
      Blindly issuing SRST to spinning-up device often results in command
      issue failure or timeout, causing extended delay.  For these
      controllers, ata_std_prereset() explicitly waits ATA_SPINUP_WAIT
      (currently 8s) to give newly attached device time to spin up, then
      issues reset.  Note that failing to getting ready in ATA_SPINUP_WAIT
      is not critical.  libata will retry.  So, the timeout needs to be
      long enough to spin up most devices.
    
    LLDDs can tell ata_std_prereset() which of above action is needed with
    ATA_FLAG_HRST_TO_RESUME and ATA_FLAG_SKIP_D2H_BSY flags.  These flags
    are PHY-specific property and will be moved to ata_link later.
    
    While at it, this patch unifies function typedef's such that they all
    have named arguments.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 1c167f728fb4..fe5f53943c44 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -262,6 +262,15 @@ enum {
 	ATA_PROBE_MAX_TRIES	= 3,
 	ATA_EH_RESET_TRIES	= 3,
 	ATA_EH_DEV_TRIES	= 3,
+
+	/* Drive spinup time (time from power-on to the first D2H FIS)
+	 * in msecs - 8s currently.  Failing to get ready in this time
+	 * isn't critical.  It will result in reset failure for
+	 * controllers which can't wait for the first D2H FIS.  libata
+	 * will retry, so it just has to be long enough to spin up
+	 * most devices.
+	 */
+	ATA_SPINUP_WAIT		= 8000,
 };
 
 enum hsm_task_states {
@@ -294,9 +303,10 @@ struct ata_queued_cmd;
 
 /* typedefs */
 typedef void (*ata_qc_cb_t) (struct ata_queued_cmd *qc);
-typedef void (*ata_probeinit_fn_t)(struct ata_port *);
-typedef int (*ata_reset_fn_t)(struct ata_port *, unsigned int *);
-typedef void (*ata_postreset_fn_t)(struct ata_port *ap, unsigned int *);
+typedef void (*ata_probeinit_fn_t)(struct ata_port *ap);
+typedef int (*ata_prereset_fn_t)(struct ata_port *ap);
+typedef int (*ata_reset_fn_t)(struct ata_port *ap, unsigned int *classes);
+typedef void (*ata_postreset_fn_t)(struct ata_port *ap, unsigned int *classes);
 
 struct ata_ioports {
 	unsigned long		cmd_addr;
@@ -623,6 +633,7 @@ extern int ata_drive_probe_reset(struct ata_port *ap,
 			ata_reset_fn_t softreset, ata_reset_fn_t hardreset,
 			ata_postreset_fn_t postreset, unsigned int *classes);
 extern void ata_std_probeinit(struct ata_port *ap);
+extern int ata_std_prereset(struct ata_port *ap);
 extern int ata_std_softreset(struct ata_port *ap, unsigned int *classes);
 extern int sata_std_hardreset(struct ata_port *ap, unsigned int *class);
 extern void ata_std_postreset(struct ata_port *ap, unsigned int *classes);
@@ -706,7 +717,7 @@ extern u8   ata_bmdma_status(struct ata_port *ap);
 extern void ata_bmdma_irq_clear(struct ata_port *ap);
 extern void ata_bmdma_freeze(struct ata_port *ap);
 extern void ata_bmdma_thaw(struct ata_port *ap);
-extern void ata_bmdma_drive_eh(struct ata_port *ap,
+extern void ata_bmdma_drive_eh(struct ata_port *ap, ata_prereset_fn_t prereset,
 			       ata_reset_fn_t softreset,
 			       ata_reset_fn_t hardreset,
 			       ata_postreset_fn_t postreset);
@@ -784,8 +795,9 @@ extern void ata_eh_thaw_port(struct ata_port *ap);
 extern void ata_eh_qc_complete(struct ata_queued_cmd *qc);
 extern void ata_eh_qc_retry(struct ata_queued_cmd *qc);
 
-extern void ata_do_eh(struct ata_port *ap, ata_reset_fn_t softreset,
-		      ata_reset_fn_t hardreset, ata_postreset_fn_t postreset);
+extern void ata_do_eh(struct ata_port *ap, ata_prereset_fn_t prereset,
+		      ata_reset_fn_t softreset, ata_reset_fn_t hardreset,
+		      ata_postreset_fn_t postreset);
 
 /*
  * printk helpers

commit d7bb4cc7575929a60b0a718daa1bce87bea9a9cc
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed May 31 18:27:46 2006 +0900

    [PATCH] libata-hp-prep: implement sata_phy_debounce()
    
    With hotplug, PHY always needs to be debounced before a reset as any
    reset might find new devices.  Extract PHY waiting code from
    sata_phy_resume() and extend it to include SStatus debouncing.  Note
    that sata_phy_debounce() is superset of what used to be done inside
    sata_phy_resume().
    
    Three default debounce timing parameters are defined to be used by
    hot/boot plug.  As resume failure during probing will be properly
    handled as errors, timeout doesn't have to be long as before.
    probeinit() uses the same timeout to retain the original behavior.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c0513c752751..1c167f728fb4 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -607,11 +607,17 @@ struct ata_timing {
 
 #define FIT(v,vmin,vmax)	max_t(short,min_t(short,v,vmax),vmin)
 
+extern const unsigned long sata_deb_timing_boot[];
+extern const unsigned long sata_deb_timing_eh[];
+extern const unsigned long sata_deb_timing_before_fsrst[];
+
 extern void ata_port_probe(struct ata_port *);
 extern void __sata_phy_reset(struct ata_port *ap);
 extern void sata_phy_reset(struct ata_port *ap);
 extern void ata_bus_reset(struct ata_port *ap);
 extern int sata_set_spd(struct ata_port *ap);
+extern int sata_phy_debounce(struct ata_port *ap, const unsigned long *param);
+extern int sata_phy_resume(struct ata_port *ap, const unsigned long *param);
 extern int ata_drive_probe_reset(struct ata_port *ap,
 			ata_probeinit_fn_t probeinit,
 			ata_reset_fn_t softreset, ata_reset_fn_t hardreset,

commit 3edebac41bab7e146578ad9e723ee7fff71c99c0
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed May 31 18:27:40 2006 +0900

    [PATCH] libata-hp-prep: store attached SCSI device
    
    Add device persistent field dev->sdev and store the attached SCSI
    device.  With hotplug, libata needs to know the attached SCSI device
    to offline and detach it, but scsi_device_lookup() cannot be used
    because libata will reuse SCSI ID numbers - dead but not gone devices
    (due to zombie opens, etc...) interfere with the lookup.
    
    dev->sdev doesn't hold reference to the SCSI device.  It's cleared
    when the SCSI device goes away.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 10dc235ad8bc..c0513c752751 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -413,6 +413,7 @@ struct ata_device {
 	struct ata_port		*ap;
 	unsigned int		devno;		/* 0 or 1 */
 	unsigned long		flags;		/* ATA_DFLAG_xxx */
+	struct scsi_device	*sdev;		/* attached SCSI device */
 	/* n_sector is used as CLEAR_OFFSET, read comment above CLEAR_OFFSET */
 	u64			n_sectors;	/* size of device, if ATA */
 	unsigned int		class;		/* ATA_DEV_xxx */

commit 5a04bf4befa8bffa012eedc3a0903c158b9131a9
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed May 31 18:27:38 2006 +0900

    [PATCH] libata-hp-prep: implement ap->hw_sata_spd_limit
    
    Add ap->hw_sata_spd_limit and initialize it once during the boot
    initialization (or driver load initialization).  ap->sata_spd_limit is
    reset to ap->hw_sata_spd_limit on hotplug.  This prevents spd limits
    introduced by earlier devices from affecting new devices.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index aa14eda0656c..10dc235ad8bc 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -489,6 +489,7 @@ struct ata_port {
 	unsigned int		mwdma_mask;
 	unsigned int		udma_mask;
 	unsigned int		cbl;	/* cable type; ATA_CBL_xxx */
+	unsigned int		hw_sata_spd_limit;
 	unsigned int		sata_spd_limit;	/* SATA PHY speed limit */
 
 	/* record runtime error info, protected by host_set lock */

commit 72fa4b742b327bd1b07985d79a61c61dbd9fd4e6
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed May 31 18:27:32 2006 +0900

    [PATCH] libata-hp-prep: make some ata_device fields persistent
    
    Lifetimes of some fields span over device plugging/unplugging.  This
    patch moves such persistent fields to the top of ata_device and
    separate them with ATA_DEVICE_CLEAR_OFFSET.  Fields above the offset
    are initialized once during host initializatino while all other fields
    are cleared before hotplugging.  Currently ->ap, devno and part of
    flags are persistent.
    
    Note that flags is partially cleared while holding host_set lock.
    This is to synchronize with later warm plug implementation which will
    record hotplug request in dev->flags.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d4a668cf143b..aa14eda0656c 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -130,6 +130,7 @@ enum {
 	ATA_DFLAG_CFG_MASK	= (1 << 8) - 1,
 
 	ATA_DFLAG_PIO		= (1 << 8), /* device currently in PIO mode */
+	ATA_DFLAG_INIT_MASK	= (1 << 16) - 1,
 
 	ATA_DFLAG_DETACH	= (1 << 16),
 	ATA_DFLAG_DETACHED	= (1 << 17),
@@ -410,10 +411,11 @@ struct ata_ering {
 
 struct ata_device {
 	struct ata_port		*ap;
-	u64			n_sectors;	/* size of device, if ATA */
+	unsigned int		devno;		/* 0 or 1 */
 	unsigned long		flags;		/* ATA_DFLAG_xxx */
+	/* n_sector is used as CLEAR_OFFSET, read comment above CLEAR_OFFSET */
+	u64			n_sectors;	/* size of device, if ATA */
 	unsigned int		class;		/* ATA_DEV_xxx */
-	unsigned int		devno;		/* 0 or 1 */
 	u16			id[ATA_ID_WORDS]; /* IDENTIFY xxx DEVICE data */
 	u8			pio_mode;
 	u8			dma_mode;
@@ -439,6 +441,11 @@ struct ata_device {
 	struct ata_ering	ering;
 };
 
+/* Offset into struct ata_device.  Fields above it are maintained
+ * acress device init.  Fields below are zeroed.
+ */
+#define ATA_DEVICE_CLEAR_OFFSET		offsetof(struct ata_device, n_sectors)
+
 struct ata_eh_info {
 	struct ata_device	*dev;		/* offending device */
 	u32			serror;		/* SError from LLDD */

commit abdda7331d469fa965167365f011d05e226008fb
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed May 31 18:27:29 2006 +0900

    [PATCH] libata-hp-prep: add flags and eh_info/context fields for hotplug
    
    Add hotplug related flags and eh_info/context fields.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 2eb5828839e4..d4a668cf143b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -131,6 +131,9 @@ enum {
 
 	ATA_DFLAG_PIO		= (1 << 8), /* device currently in PIO mode */
 
+	ATA_DFLAG_DETACH	= (1 << 16),
+	ATA_DFLAG_DETACHED	= (1 << 17),
+
 	ATA_DEV_UNKNOWN		= 0,	/* unknown device */
 	ATA_DEV_ATA		= 1,	/* ATA device */
 	ATA_DEV_ATA_UNSUP	= 2,	/* ATA device (unsupported) */
@@ -152,6 +155,9 @@ enum {
 	ATA_FLAG_PIO_POLLING	= (1 << 9), /* use polling PIO if LLD
 					     * doesn't handle PIO interrupts */
 	ATA_FLAG_NCQ		= (1 << 10), /* host supports NCQ */
+	ATA_FLAG_HRST_TO_RESUME	= (1 << 11), /* hardreset to resume phy */
+	ATA_FLAG_SKIP_D2H_BSY	= (1 << 12), /* can't wait for the first D2H
+					      * Register FIS clearing BSY */
 
 	ATA_FLAG_DEBUGMSG	= (1 << 13),
 	ATA_FLAG_FLUSH_PORT_TASK = (1 << 14), /* flush port task */
@@ -160,6 +166,9 @@ enum {
 	ATA_FLAG_EH_IN_PROGRESS	= (1 << 16), /* EH in progress */
 	ATA_FLAG_FROZEN		= (1 << 17), /* port is frozen */
 	ATA_FLAG_RECOVERED	= (1 << 18), /* recovery action performed */
+	ATA_FLAG_LOADING	= (1 << 19), /* boot/loading probe */
+	ATA_FLAG_UNLOADING	= (1 << 20), /* module is unloading */
+	ATA_FLAG_SCSI_HOTPLUG	= (1 << 21), /* SCSI hotplug scheduled */
 
 	ATA_FLAG_DISABLED	= (1 << 22), /* port is disabled, ignore it */
 	ATA_FLAG_SUSPENDED	= (1 << 23), /* port is suspended (power) */
@@ -241,7 +250,9 @@ enum {
 	ATA_EH_RESET_MASK	= ATA_EH_SOFTRESET | ATA_EH_HARDRESET,
 
 	/* ata_eh_info->flags */
-	ATA_EHI_DID_RESET	= (1 << 0), /* already reset this port */
+	ATA_EHI_HOTPLUGGED	= (1 << 0),  /* could have been hotplugged */
+
+	ATA_EHI_DID_RESET	= (1 << 16), /* already reset this port */
 
 	/* max repeat if error condition is still set after ->error_handler */
 	ATA_EH_MAX_REPEAT	= 5,
@@ -434,6 +445,10 @@ struct ata_eh_info {
 	unsigned int		err_mask;	/* port-wide err_mask */
 	unsigned int		action;		/* ATA_EH_* action mask */
 	unsigned int		flags;		/* ATA_EHI_* flags */
+
+	unsigned long		hotplug_timestamp;
+	unsigned int		probe_mask;
+
 	char			desc[ATA_EH_DESC_LEN];
 	int			desc_len;
 };
@@ -441,6 +456,8 @@ struct ata_eh_info {
 struct ata_eh_context {
 	struct ata_eh_info	i;
 	int			tries[ATA_MAX_DEVICES];
+	unsigned int		classes[ATA_MAX_DEVICES];
+	unsigned int		did_probe_mask;
 };
 
 struct ata_port {

commit c6cf9e99d1de5ca6a08fb639bb73031ffe50d802
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed May 31 18:27:27 2006 +0900

    [PATCH] libata: implement ata_eh_wait()
    
    Implement ata_eh_wait().  On return from this function, it's
    guaranteed that the EH which was pending or in progress when the
    function was called is complete - including the tailing part of SCSI
    EH.  This will be used by hotplug and others to synchronize with EH.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 3f9c65f1aafa..2eb5828839e4 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -157,6 +157,7 @@ enum {
 	ATA_FLAG_FLUSH_PORT_TASK = (1 << 14), /* flush port task */
 
 	ATA_FLAG_EH_PENDING	= (1 << 15), /* EH pending */
+	ATA_FLAG_EH_IN_PROGRESS	= (1 << 16), /* EH in progress */
 	ATA_FLAG_FROZEN		= (1 << 17), /* port is frozen */
 	ATA_FLAG_RECOVERED	= (1 << 18), /* recovery action performed */
 
@@ -490,6 +491,7 @@ struct ata_port {
 
 	u32			msg_enable;
 	struct list_head	eh_done_q;
+	wait_queue_head_t	eh_wait_q;
 
 	void			*private_data;
 

commit 7395acb2c840fd4d0cacc91d6fb71440057141ab
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed May 31 18:27:25 2006 +0900

    [PATCH] libata: shift host flag constants
    
    Nudge host flag constants to make a room after ATA_FLAG_EH_PENDING.
    New EH flag will be added.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b0ee1c1437d6..3f9c65f1aafa 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -149,14 +149,14 @@ enum {
 	ATA_FLAG_NO_ATAPI	= (1 << 6), /* No ATAPI support */
 	ATA_FLAG_PIO_DMA	= (1 << 7), /* PIO cmds via DMA */
 	ATA_FLAG_PIO_LBA48	= (1 << 8), /* Host DMA engine is LBA28 only */
-	ATA_FLAG_PIO_POLLING	= (1 << 10), /* use polling PIO if LLD
-					      * doesn't handle PIO interrupts */
-	ATA_FLAG_NCQ		= (1 << 11), /* host supports NCQ */
+	ATA_FLAG_PIO_POLLING	= (1 << 9), /* use polling PIO if LLD
+					     * doesn't handle PIO interrupts */
+	ATA_FLAG_NCQ		= (1 << 10), /* host supports NCQ */
 
-	ATA_FLAG_DEBUGMSG	= (1 << 14),
-	ATA_FLAG_FLUSH_PORT_TASK = (1 << 15), /* flush port task */
+	ATA_FLAG_DEBUGMSG	= (1 << 13),
+	ATA_FLAG_FLUSH_PORT_TASK = (1 << 14), /* flush port task */
 
-	ATA_FLAG_EH_PENDING	= (1 << 16), /* EH pending */
+	ATA_FLAG_EH_PENDING	= (1 << 15), /* EH pending */
 	ATA_FLAG_FROZEN		= (1 << 17), /* port is frozen */
 	ATA_FLAG_RECOVERED	= (1 << 18), /* recovery action performed */
 

commit 75e995855f45a83afdae34d50c0b3ee14fb23b7a
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Wed May 24 14:14:41 2006 +0100

    [PATCH] libata: add pio_data_xfer_noirq
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 9c60b4a4e2fd..b0ee1c1437d6 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -651,6 +651,8 @@ extern void ata_mmio_data_xfer(struct ata_device *adev, unsigned char *buf,
 			       unsigned int buflen, int write_data);
 extern void ata_pio_data_xfer(struct ata_device *adev, unsigned char *buf,
 			      unsigned int buflen, int write_data);
+extern void ata_pio_data_xfer_noirq(struct ata_device *adev, unsigned char *buf,
+			      unsigned int buflen, int write_data);
 extern void ata_qc_prep(struct ata_queued_cmd *qc);
 extern void ata_noop_qc_prep(struct ata_queued_cmd *qc);
 extern unsigned int ata_qc_issue_prot(struct ata_queued_cmd *qc);

commit 957d2df1801865eb1e63864bc63b970aa9c460ba
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Tue May 23 13:18:57 2006 +0100

    [PATCH] libata: Remove obsolete flag
    
    ATA_FLAG_IRQ_MASK was added when I did the original data transfer with
    IRQ masked bits for PIO. It has since been replaced by ->pio_data_xfer
    methods so should be removed so nobody uses it by mistake thinking it
    still works.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 25a6bf181599..9c60b4a4e2fd 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -149,7 +149,6 @@ enum {
 	ATA_FLAG_NO_ATAPI	= (1 << 6), /* No ATAPI support */
 	ATA_FLAG_PIO_DMA	= (1 << 7), /* PIO cmds via DMA */
 	ATA_FLAG_PIO_LBA48	= (1 << 8), /* Host DMA engine is LBA28 only */
-	ATA_FLAG_IRQ_MASK	= (1 << 9), /* Mask IRQ in PIO xfers */
 	ATA_FLAG_PIO_POLLING	= (1 << 10), /* use polling PIO if LLD
 					      * doesn't handle PIO interrupts */
 	ATA_FLAG_NCQ		= (1 << 11), /* host supports NCQ */

commit a6b2c5d4754dc539a560fdf0d3fb78a14174394a
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon May 22 16:59:59 2006 +0100

    [PATCH] PATCH: libata. Add ->data_xfer method
    
    We need to pass the device in order to do per device checks such as
    32bit I/O enables. With the changes to include dev->ap we now don't have
    to add parameters however just clean them up. Also add data_xfer methods
    to the existing drivers except ata_piix (which is in the other block of
    patches). If you reject the piix one just add a data_xfer to it...
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c51502c047a4..25a6bf181599 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -525,6 +525,8 @@ struct ata_port_operations {
 	void (*bmdma_setup) (struct ata_queued_cmd *qc);
 	void (*bmdma_start) (struct ata_queued_cmd *qc);
 
+	void (*data_xfer) (struct ata_device *, unsigned char *, unsigned int, int);
+
 	void (*qc_prep) (struct ata_queued_cmd *qc);
 	unsigned int (*qc_issue) (struct ata_queued_cmd *qc);
 
@@ -646,6 +648,10 @@ extern int ata_port_start (struct ata_port *ap);
 extern void ata_port_stop (struct ata_port *ap);
 extern void ata_host_stop (struct ata_host_set *host_set);
 extern irqreturn_t ata_interrupt (int irq, void *dev_instance, struct pt_regs *regs);
+extern void ata_mmio_data_xfer(struct ata_device *adev, unsigned char *buf,
+			       unsigned int buflen, int write_data);
+extern void ata_pio_data_xfer(struct ata_device *adev, unsigned char *buf,
+			      unsigned int buflen, int write_data);
 extern void ata_qc_prep(struct ata_queued_cmd *qc);
 extern void ata_noop_qc_prep(struct ata_queued_cmd *qc);
 extern unsigned int ata_qc_issue_prot(struct ata_queued_cmd *qc);

commit 3655d1d323386e001c786af10f0a3f39f438f03b
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Fri May 19 11:43:04 2006 +0800

    [PATCH] libata: Fix the HSM error_mask mapping (was: Re: libata-tj and SMART)
    
    Fix the HSM error_mask mapping.
    
    Changes:
    - Better mapping in ac_err_mask()
    - In HSM_ST_FIRST ans HSM_ST state, check ATA_ERR|ATA_DF and map it to AC_ERR_DEV instead of AC_ERR_HSM.
    - In HSM_ST_FIRST and HSM_ST state, map DRQ=1 ERR=1 to AC_ERR_HSM.
    - For PIO data in and DRQ=1 ERR=1, add check after the junk data block is read.
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 2803ab8e9243..c51502c047a4 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1062,7 +1062,7 @@ static inline int ata_try_flush_cache(const struct ata_device *dev)
 
 static inline unsigned int ac_err_mask(u8 status)
 {
-	if (status & ATA_BUSY)
+	if (status & (ATA_BUSY | ATA_DRQ))
 		return AC_ERR_HSM;
 	if (status & (ATA_ERR | ATA_DF))
 		return AC_ERR_DEV;

commit 8d4ee71ff6de5255ebfdf44fb83419d27bd06368
Merge: efa6e7e9d40f 9a375e93f882
Author: Jeff Garzik <jeff@garzik.org>
Date:   Mon May 15 11:27:47 2006 -0400

    Merge branch 'max-sect' into upstream

commit a6e6ce8e8dc907a2cf2b994b0ea4099423f046bf
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 21:03:48 2006 +0900

    [PATCH] libata-ncq: implement NCQ device configuration
    
    Now that all NCQ related stuff are in place, implement NCQ device
    configuration and bump ATA_MAX_QUEUE to 32 thus activating NCQ
    support.
    
    Original implementation is from Jens Axboe.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index dd0db2d21bc5..fcdd798bb086 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -109,7 +109,7 @@ enum {
 	ATA_MAX_PORTS		= 8,
 	ATA_DEF_QUEUE		= 1,
 	/* tag ATA_MAX_QUEUE - 1 is reserved for internal commands */
-	ATA_MAX_QUEUE		= 2,
+	ATA_MAX_QUEUE		= 32,
 	ATA_TAG_INTERNAL	= ATA_MAX_QUEUE - 1,
 	ATA_MAX_SECTORS		= 200,	/* FIXME */
 	ATA_MAX_BUS		= 2,
@@ -679,6 +679,8 @@ extern int ata_std_bios_param(struct scsi_device *sdev,
 			      struct block_device *bdev,
 			      sector_t capacity, int geom[]);
 extern int ata_scsi_slave_config(struct scsi_device *sdev);
+extern int ata_scsi_change_queue_depth(struct scsi_device *sdev,
+				       int queue_depth);
 extern struct ata_device *ata_dev_pair(struct ata_device *adev);
 
 /*

commit dedaf2b0365ccec50714fbde0b3215e7e94fa47c
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 21:03:43 2006 +0900

    [PATCH] libata-ncq: implement ap->qc_active, ap->sactive and complete helper
    
    Add ap->qc_active and ap->sactive, mask of all active qcs and libata's
    view of the SActive register, respectively.  Also, implement
    ata_qc_complete_multiple() which takes new qc_active mask and complete
    multiple qcs according to the mask.
    
    These will be used to track NCQ commands and complete them.  The
    distinction between ap->qc_active and ap->sactive is also useful for
    later PM implementation.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b3a4f8bea828..dd0db2d21bc5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -475,7 +475,10 @@ struct ata_port {
 
 	struct ata_queued_cmd	qcmd[ATA_MAX_QUEUE];
 	unsigned long		qc_allocated;
+	unsigned int		qc_active;
+
 	unsigned int		active_tag;
+	u32			sactive;
 
 	struct ata_host_stats	stats;
 	struct ata_host_set	*host_set;
@@ -668,6 +671,8 @@ extern void ata_bmdma_drive_eh(struct ata_port *ap,
 extern void ata_bmdma_error_handler(struct ata_port *ap);
 extern void ata_bmdma_post_internal_cmd(struct ata_queued_cmd *qc);
 extern void ata_qc_complete(struct ata_queued_cmd *qc);
+extern int ata_qc_complete_multiple(struct ata_port *ap, u32 qc_active,
+				    void (*finish_qc)(struct ata_queued_cmd *));
 extern void ata_scsi_simulate(struct ata_device *dev, struct scsi_cmnd *cmd,
 			      void (*done)(struct scsi_cmnd *));
 extern int ata_std_bios_param(struct scsi_device *sdev,

commit 6cec4a3943bdfe46e2952bc246f17670f747be8d
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 21:03:41 2006 +0900

    [PATCH] libata-ncq: rename ap->qactive to ap->qc_allocated
    
    Rename ap->qactive to ap->qc_allocated.  This is to accomodate
    addition of ap->qc_active, mask of active qcs.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 7c9e280a4829..b3a4f8bea828 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -474,7 +474,7 @@ struct ata_port {
 	struct ata_device	device[ATA_MAX_DEVICES];
 
 	struct ata_queued_cmd	qcmd[ATA_MAX_QUEUE];
-	unsigned long		qactive;
+	unsigned long		qc_allocated;
 	unsigned int		active_tag;
 
 	struct ata_host_stats	stats;

commit 88e490340ea4c3a2ebc0187a4339912e2fc1a081
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 21:03:38 2006 +0900

    [PATCH] libata-ncq: add NCQ related ATA/libata constants and macros
    
    Add NCQ related ATA/libata constants and macros.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index db17723e23fb..7c9e280a4829 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -125,6 +125,7 @@ enum {
 	ATA_DFLAG_LBA		= (1 << 0), /* device supports LBA */
 	ATA_DFLAG_LBA48		= (1 << 1), /* device supports LBA48 */
 	ATA_DFLAG_CDB_INTR	= (1 << 2), /* device asserts INTRQ when ready for CDB */
+	ATA_DFLAG_NCQ		= (1 << 3), /* device supports NCQ */
 	ATA_DFLAG_CFG_MASK	= (1 << 8) - 1,
 
 	ATA_DFLAG_PIO		= (1 << 8), /* device currently in PIO mode */
@@ -150,6 +151,7 @@ enum {
 	ATA_FLAG_IRQ_MASK	= (1 << 9), /* Mask IRQ in PIO xfers */
 	ATA_FLAG_PIO_POLLING	= (1 << 10), /* use polling PIO if LLD
 					      * doesn't handle PIO interrupts */
+	ATA_FLAG_NCQ		= (1 << 11), /* host supports NCQ */
 
 	ATA_FLAG_DEBUGMSG	= (1 << 14),
 	ATA_FLAG_FLUSH_PORT_TASK = (1 << 15), /* flush port task */

commit 12436c30f4808e00fa008c6787c609bc6ae216ba
Merge: 88ce7550c38f 7894eaf29123
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:59:15 2006 +0900

    Merge branch 'irq-pio'
    
    Conflicts:
    
            drivers/scsi/libata-core.c
            include/linux/libata.h

commit 6d97dbd72da31a0e334f251fa9df4be9fab6fde2
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:58:24 2006 +0900

    [PATCH] libata-eh: implement BMDMA EH
    
    Implement stock BMDMA error handling methods.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 9fe46073cf8c..6ccacbf889e3 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -661,6 +661,14 @@ extern void ata_bmdma_start (struct ata_queued_cmd *qc);
 extern void ata_bmdma_stop(struct ata_queued_cmd *qc);
 extern u8   ata_bmdma_status(struct ata_port *ap);
 extern void ata_bmdma_irq_clear(struct ata_port *ap);
+extern void ata_bmdma_freeze(struct ata_port *ap);
+extern void ata_bmdma_thaw(struct ata_port *ap);
+extern void ata_bmdma_drive_eh(struct ata_port *ap,
+			       ata_reset_fn_t softreset,
+			       ata_reset_fn_t hardreset,
+			       ata_postreset_fn_t postreset);
+extern void ata_bmdma_error_handler(struct ata_port *ap);
+extern void ata_bmdma_post_internal_cmd(struct ata_queued_cmd *qc);
 extern void ata_qc_complete(struct ata_queued_cmd *qc);
 extern void ata_scsi_simulate(struct ata_device *dev, struct scsi_cmnd *cmd,
 			      void (*done)(struct scsi_cmnd *));

commit 022bdb075b9e1f224088a0b268de56268d7bc5b6
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:58:22 2006 +0900

    [PATCH] libata-eh: implement new EH
    
    Implement new EH.  The exported interface is ata_do_eh() which is to
    be called from ->error_handler and performs the following steps to
    recover the failed port.
    
    ata_eh_autopsy() : analyze SError/TF, determine the cause of failure
                       and required recovery actions and record it in
                       ap->eh_context
    ata_eh_report()  : report the failure to user
    ata_eh_recover() : perform recovery actions described in ap->eh_context
    ata_eh_finish()  : finish failed qcs
    
    LLDDs can customize error handling by modifying eh_context before
    calling ata_do_eh() or, if necessary, doing so inbetween each major
    steps by calling each step explicitly.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 298f9918e375..9fe46073cf8c 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -247,6 +247,8 @@ enum {
 
 	/* how hard are we gonna try to probe/recover devices */
 	ATA_PROBE_MAX_TRIES	= 3,
+	ATA_EH_RESET_TRIES	= 3,
+	ATA_EH_DEV_TRIES	= 3,
 };
 
 enum hsm_task_states {
@@ -727,6 +729,9 @@ extern void ata_eh_thaw_port(struct ata_port *ap);
 extern void ata_eh_qc_complete(struct ata_queued_cmd *qc);
 extern void ata_eh_qc_retry(struct ata_queued_cmd *qc);
 
+extern void ata_do_eh(struct ata_port *ap, ata_reset_fn_t softreset,
+		      ata_reset_fn_t hardreset, ata_postreset_fn_t postreset);
+
 /*
  * printk helpers
  */

commit f3e81b19aac23c0e8c55d5961324ef7de44c23bb
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:58:21 2006 +0900

    [PATCH] libata-eh: implement ata_eh_info and ata_eh_context
    
    struct ata_eh_info serves as the communication channel between
    execution path and EH.  Execution path describes detected error
    condition in ap->eh_info and EH recovers the port using it.  To avoid
    missing error conditions detected during EH, EH makes its own copy of
    eh_info and clears it on entry allowing error info to accumulate
    during EH.
    
    Most EH states including EH's copy of eh_info are stored in
    ap->eh_context (struct ata_eh_context) which is owned by EH and thus
    doesn't require any synchronization to access and alter.  This
    standardized context makes it easy to integrate various parts of EH
    and extend EH to handle multiple links (for PM).
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index f5cea13599c3..298f9918e375 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -229,6 +229,9 @@ enum {
 	/* ering size */
 	ATA_ERING_SIZE		= 32,
 
+	/* desc_len for ata_eh_info and context */
+	ATA_EH_DESC_LEN		= 80,
+
 	/* reset / recovery action types */
 	ATA_EH_REVALIDATE	= (1 << 0),
 	ATA_EH_SOFTRESET	= (1 << 1),
@@ -236,6 +239,9 @@ enum {
 
 	ATA_EH_RESET_MASK	= ATA_EH_SOFTRESET | ATA_EH_HARDRESET,
 
+	/* ata_eh_info->flags */
+	ATA_EHI_DID_RESET	= (1 << 0), /* already reset this port */
+
 	/* max repeat if error condition is still set after ->error_handler */
 	ATA_EH_MAX_REPEAT	= 5,
 
@@ -420,6 +426,21 @@ struct ata_device {
 	struct ata_ering	ering;
 };
 
+struct ata_eh_info {
+	struct ata_device	*dev;		/* offending device */
+	u32			serror;		/* SError from LLDD */
+	unsigned int		err_mask;	/* port-wide err_mask */
+	unsigned int		action;		/* ATA_EH_* action mask */
+	unsigned int		flags;		/* ATA_EHI_* flags */
+	char			desc[ATA_EH_DESC_LEN];
+	int			desc_len;
+};
+
+struct ata_eh_context {
+	struct ata_eh_info	i;
+	int			tries[ATA_MAX_DEVICES];
+};
+
 struct ata_port {
 	struct Scsi_Host	*host;	/* our co-allocated scsi host */
 	const struct ata_port_operations *ops;
@@ -444,6 +465,11 @@ struct ata_port {
 	unsigned int		cbl;	/* cable type; ATA_CBL_xxx */
 	unsigned int		sata_spd_limit;	/* SATA PHY speed limit */
 
+	/* record runtime error info, protected by host_set lock */
+	struct ata_eh_info	eh_info;
+	/* EH context owned by EH */
+	struct ata_eh_context	eh_context;
+
 	struct ata_device	device[ATA_MAX_DEVICES];
 
 	struct ata_queued_cmd	qcmd[ATA_MAX_QUEUE];
@@ -710,6 +736,20 @@ extern void ata_eh_qc_retry(struct ata_queued_cmd *qc);
 #define ata_dev_printk(dev, lv, fmt, args...) \
 	printk(lv"ata%u.%02u: "fmt, (dev)->ap->id, (dev)->devno , ##args)
 
+/*
+ * ata_eh_info helpers
+ */
+#define ata_ehi_push_desc(ehi, fmt, args...) do { \
+	(ehi)->desc_len += scnprintf((ehi)->desc + (ehi)->desc_len, \
+				     ATA_EH_DESC_LEN - (ehi)->desc_len, \
+				     fmt , ##args); \
+} while (0)
+
+#define ata_ehi_clear_desc(ehi) do { \
+	(ehi)->desc[0] = '\0'; \
+	(ehi)->desc_len = 0; \
+} while (0)
+
 /*
  * qc helpers
  */

commit 0c247c559cd70f85ba9f0764ce13ae00e20fcad8
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:58:19 2006 +0900

    [PATCH] libata-eh: implement dev->ering
    
    This patch implements ata_ering and uses it to define dev->ering.
    
    ata_ering is a ring buffer which records libata errors - whether a
    command was for normar IO request, err_mask and timestamp.  Errors are
    recorded per-device in dev->ering.  This will be used by EH to
    determine recovery actions.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6fe5ed8eabf5..f5cea13599c3 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -226,6 +226,9 @@ enum {
 	ATA_PORT_PRIMARY	= (1 << 0),
 	ATA_PORT_SECONDARY	= (1 << 1),
 
+	/* ering size */
+	ATA_ERING_SIZE		= 32,
+
 	/* reset / recovery action types */
 	ATA_EH_REVALIDATE	= (1 << 0),
 	ATA_EH_SOFTRESET	= (1 << 1),
@@ -375,6 +378,17 @@ struct ata_host_stats {
 	unsigned long		rw_reqbuf;
 };
 
+struct ata_ering_entry {
+	int			is_io;
+	unsigned int		err_mask;
+	u64			timestamp;
+};
+
+struct ata_ering {
+	int			cursor;
+	struct ata_ering_entry	ring[ATA_ERING_SIZE];
+};
+
 struct ata_device {
 	struct ata_port		*ap;
 	u64			n_sectors;	/* size of device, if ATA */
@@ -401,6 +415,9 @@ struct ata_device {
 	u16			cylinders;	/* Number of cylinders */
 	u16			heads;		/* Number of heads */
 	u16			sectors;	/* Number of sectors per track */
+
+	/* error history */
+	struct ata_ering	ering;
 };
 
 struct ata_port {

commit 9be1e979f2e1e57a091a658fa88dac266f9fd6fe
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:58:17 2006 +0900

    [PATCH] libata-eh: add ATA and libata flags for new EH
    
    Add ATA and libata flags to be used by new EH.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 5ad50163c8ef..6fe5ed8eabf5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -155,6 +155,7 @@ enum {
 
 	ATA_FLAG_EH_PENDING	= (1 << 16), /* EH pending */
 	ATA_FLAG_FROZEN		= (1 << 17), /* port is frozen */
+	ATA_FLAG_RECOVERED	= (1 << 18), /* recovery action performed */
 
 	ATA_FLAG_DISABLED	= (1 << 22), /* port is disabled, ignore it */
 	ATA_FLAG_SUSPENDED	= (1 << 23), /* port is suspended (power) */
@@ -225,6 +226,13 @@ enum {
 	ATA_PORT_PRIMARY	= (1 << 0),
 	ATA_PORT_SECONDARY	= (1 << 1),
 
+	/* reset / recovery action types */
+	ATA_EH_REVALIDATE	= (1 << 0),
+	ATA_EH_SOFTRESET	= (1 << 1),
+	ATA_EH_HARDRESET	= (1 << 2),
+
+	ATA_EH_RESET_MASK	= ATA_EH_SOFTRESET | ATA_EH_HARDRESET,
+
 	/* max repeat if error condition is still set after ->error_handler */
 	ATA_EH_MAX_REPEAT	= 5,
 

commit ad9e27624479bd167dd7eac0cea4bb3ad13bc926
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:58:12 2006 +0900

    [PATCH] libata-eh-fw: update ata_scsi_error() for new EH
    
    Update ata_scsi_error() for new EH.  ata_scsi_error() is responsible
    for claiming timed out qcs and invoking ->error_handler in safe and
    synchronized manner.  As the state of the controller is unknown if a
    qc has timed out, the port is frozen in such cases.
    
    Note that ata_scsi_timed_out() isn't used for new EH.  This is because
    a timed out qc cannot be claimed by EH without freezing the port and
    freezing the port in ata_scsi_timed_out() results in unnecessary
    abortion of other active qcs.  ata_scsi_timed_out() can be removed
    once all drivers are converted to new EH.
    
    While at it, add 'TODO: kill' comments to old EH functions.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6758b4d374a0..5ad50163c8ef 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -225,6 +225,9 @@ enum {
 	ATA_PORT_PRIMARY	= (1 << 0),
 	ATA_PORT_SECONDARY	= (1 << 1),
 
+	/* max repeat if error condition is still set after ->error_handler */
+	ATA_EH_MAX_REPEAT	= 5,
+
 	/* how hard are we gonna try to probe/recover devices */
 	ATA_PROBE_MAX_TRIES	= 3,
 };

commit e318049949b07152d851dbfebbd93e560af45ebe
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:58:09 2006 +0900

    [PATCH] libata-eh-fw: implement freeze/thaw
    
    Freezing is performed atomic w.r.t. host_set->lock and once frozen
    LLDD is not allowed to access the port or any qc on it.  Also, libata
    makes sure that no new qc gets issued to a frozen port.
    
    A frozen port is thawed after a reset operation completes
    successfully, so reset methods must do its job while the port is
    frozen.  During initialization all ports get frozen before requesting
    IRQ, so reset methods are always invoked on a frozen port.
    
    Optional ->freeze and ->thaw operations notify LLDD that the port is
    being frozen and thawed, respectively.  LLDD can disable/enable
    hardware interrupt in these callbacks if the controller's IRQ mask can
    be changed dynamically.  If the controller doesn't allow such
    operation, LLDD can check for frozen state in the interrupt handler
    and ack/clear interrupts unconditionally while frozen.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 086e14690954..6758b4d374a0 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -665,6 +665,10 @@ extern void ata_eng_timeout(struct ata_port *ap);
 
 extern void ata_port_schedule_eh(struct ata_port *ap);
 extern int ata_port_abort(struct ata_port *ap);
+extern int ata_port_freeze(struct ata_port *ap);
+
+extern void ata_eh_freeze_port(struct ata_port *ap);
+extern void ata_eh_thaw_port(struct ata_port *ap);
 
 extern void ata_eh_qc_complete(struct ata_queued_cmd *qc);
 extern void ata_eh_qc_retry(struct ata_queued_cmd *qc);

commit 7b70fc039824bc7303e4007a5f758f832de56611
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:58:07 2006 +0900

    [PATCH] libata-eh-fw: implement ata_port_schedule_eh() and ata_port_abort()
    
    ata_port_schedule_eh() directly schedules EH for @ap without
    associated qc.  Once EH scheduled, no further qc is allowed and EH
    kicks in as soon as all currently active qc's are drained.
    
    ata_port_abort() schedules all currently active commands for EH by
    qc_completing them with ATA_QCFLAG_FAILED set.  If ata_port_abort()
    doesn't find any qc to abort, it directly schedule EH using
    ata_port_schedule_eh().
    
    These two functions provide ways to invoke EH for conditions which
    aren't directly related to any specfic qc.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6023f324e68e..086e14690954 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -662,6 +662,10 @@ extern unsigned long ata_pci_default_filter(const struct ata_port *, struct ata_
  * EH
  */
 extern void ata_eng_timeout(struct ata_port *ap);
+
+extern void ata_port_schedule_eh(struct ata_port *ap);
+extern int ata_port_abort(struct ata_port *ap);
+
 extern void ata_eh_qc_complete(struct ata_queued_cmd *qc);
 extern void ata_eh_qc_retry(struct ata_queued_cmd *qc);
 

commit f686bcb8078ac7505ec88818886c2c72639f4fc5
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:58:05 2006 +0900

    [PATCH] libata-eh-fw: implement new EH scheduling via error completion
    
    There are several ways a qc can get schedule for EH in new EH.  This
    patch implements one of them - completing a qc with ATA_QCFLAG_FAILED
    set or with non-zero qc->err_mask.  ALL such qc's are examined by EH.
    
    New EH schedules a qc for EH from completion iff ->error_handler is
    implemented, qc is marked as failed or qc->err_mask is non-zero and
    the command is not an internal command (internal cmd is handled via
    ->post_internal_cmd).  The EH scheduling itself is performed by asking
    SCSI midlayer to schedule EH for the specified scmd.
    
    For drivers implementing old-EH, nothing changes.  As this change
    makes ata_qc_complete() rather large, it's not inlined anymore and
    __ata_qc_complete() is exported to other parts of libata for later
    use.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index bfcefdca0616..6023f324e68e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -605,7 +605,7 @@ extern void ata_bmdma_start (struct ata_queued_cmd *qc);
 extern void ata_bmdma_stop(struct ata_queued_cmd *qc);
 extern u8   ata_bmdma_status(struct ata_port *ap);
 extern void ata_bmdma_irq_clear(struct ata_port *ap);
-extern void __ata_qc_complete(struct ata_queued_cmd *qc);
+extern void ata_qc_complete(struct ata_queued_cmd *qc);
 extern void ata_scsi_simulate(struct ata_device *dev, struct scsi_cmnd *cmd,
 			      void (*done)(struct scsi_cmnd *));
 extern int ata_std_bios_param(struct scsi_device *sdev,
@@ -882,31 +882,6 @@ static inline void ata_qc_reinit(struct ata_queued_cmd *qc)
 	qc->result_tf.feature = 0;
 }
 
-/**
- *	ata_qc_complete - Complete an active ATA command
- *	@qc: Command to complete
- *	@err_mask: ATA Status register contents
- *
- *	Indicate to the mid and upper layers that an ATA
- *	command has completed, with either an ok or not-ok status.
- *
- *	LOCKING:
- *	spin_lock_irqsave(host_set lock)
- */
-static inline void ata_qc_complete(struct ata_queued_cmd *qc)
-{
-	struct ata_port *ap = qc->ap;
-
-	if (unlikely(qc->flags & ATA_QCFLAG_EH_SCHEDULED))
-		return;
-
-	/* read result TF if failed or requested */
-	if (qc->err_mask || qc->flags & ATA_QCFLAG_RESULT_TF)
-		ap->ops->tf_read(ap, &qc->result_tf);
-
-	__ata_qc_complete(qc);
-}
-
 /**
  *	ata_irq_on - Enable interrupts on a port.
  *	@ap: Port on which interrupts are enabled.

commit f69499f42caf74194df678c9c293f2ee0fe90bc3
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:58:03 2006 +0900

    [PATCH] libata-eh-fw: update ata_qc_from_tag() to enforce normal/EH qc ownership
    
    New EH framework has clear distinction about who owns a qc.  Every qc
    starts owned by normal execution path - PIO, interrupt or whatever.
    When an exception condition occurs which affects the qc, the qc gets
    scheduled for EH.  Note that some events (say, link lost and regained,
    command timeout) may schedule qc's which are not directly related but
    could have been affected for EH too.  Scheduling for EH is atomic
    w.r.t. ap->host_set->lock and once schedule for EH, normal execution
    path is not allowed to access the qc in whatever way.  (PIO
    synchronization acts a bit different and will be dealt with later)
    
    This patch make ata_qc_from_tag() check whether a qc is active and
    owned by normal path before returning it.  If conditions don't match,
    NULL is returned and thus access to the qc is denied.
    __ata_qc_from_tag() is the original ata_qc_from_tag() and is used by
    libata core/EH layers to access inactive/failed qc's.
    
    This change is applied only if the associated LLDD implements new EH
    as indicated by non-NULL ->error_handler
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 5a403e434ff8..bfcefdca0616 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -832,14 +832,29 @@ static inline void ata_qc_set_polling(struct ata_queued_cmd *qc)
 	qc->tf.ctl |= ATA_NIEN;
 }
 
-static inline struct ata_queued_cmd *ata_qc_from_tag (struct ata_port *ap,
-						      unsigned int tag)
+static inline struct ata_queued_cmd *__ata_qc_from_tag(struct ata_port *ap,
+						       unsigned int tag)
 {
 	if (likely(ata_tag_valid(tag)))
 		return &ap->qcmd[tag];
 	return NULL;
 }
 
+static inline struct ata_queued_cmd *ata_qc_from_tag(struct ata_port *ap,
+						     unsigned int tag)
+{
+	struct ata_queued_cmd *qc = __ata_qc_from_tag(ap, tag);
+
+	if (unlikely(!qc) || !ap->ops->error_handler)
+		return qc;
+
+	if ((qc->flags & (ATA_QCFLAG_ACTIVE |
+			  ATA_QCFLAG_FAILED)) == ATA_QCFLAG_ACTIVE)
+		return qc;
+
+	return NULL;
+}
+
 static inline void ata_tf_init(struct ata_device *dev, struct ata_taskfile *tf)
 {
 	memset(tf, 0, sizeof(*tf));

commit 2ab7db1ff1d64a2ba389d0692d532f42a15f1f72
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:58:02 2006 +0900

    [PATCH] libata-eh-fw: use special reserved tag and qc for internal commands
    
    New EH may issue internal commands to recover from error while failed
    qc's are still hanging around.  To allow such usage, reserve tag
    ATA_MAX_QUEUE-1 for internal command.  This also makes it easy to tell
    whether a qc is for internal command or not.  ata_tag_internal() test
    implements this test.
    
    To avoid breaking existing drivers, ata_exec_internal() uses
    ATA_TAG_INTERNAL only for drivers which implement ->error_handler.
    For drivers using old EH, tag 0 is used.  Note that this makes
    ata_tag_internal() test valid only when ->error_handler is
    implemented.  This is okay as drivers on old EH should not and does
    not have any reason to use ata_tag_internal().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index e5d6d7f8e6dc..5a403e434ff8 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -108,7 +108,9 @@ enum {
 	LIBATA_MAX_PRD		= ATA_MAX_PRD / 2,
 	ATA_MAX_PORTS		= 8,
 	ATA_DEF_QUEUE		= 1,
-	ATA_MAX_QUEUE		= 1,
+	/* tag ATA_MAX_QUEUE - 1 is reserved for internal commands */
+	ATA_MAX_QUEUE		= 2,
+	ATA_TAG_INTERNAL	= ATA_MAX_QUEUE - 1,
 	ATA_MAX_SECTORS		= 200,	/* FIXME */
 	ATA_MAX_BUS		= 2,
 	ATA_DEF_BUSY_WAIT	= 10000,
@@ -717,6 +719,11 @@ static inline unsigned int ata_tag_valid(unsigned int tag)
 	return (tag < ATA_MAX_QUEUE) ? 1 : 0;
 }
 
+static inline unsigned int ata_tag_internal(unsigned int tag)
+{
+	return tag == ATA_MAX_QUEUE - 1;
+}
+
 static inline unsigned int ata_class_enabled(unsigned int class)
 {
 	return class == ATA_DEV_ATA || class == ATA_DEV_ATAPI;

commit 9ec957f2002bd2994be659bbc0ec28397fa251ee
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:57:58 2006 +0900

    [PATCH] libata-eh-fw: add flags and operations for new EH
    
    Add ATA_FLAG_EH_{PENDING|FROZEN}, ATA_ATA_QCFLAG_{FAILED|SENSE_VALID}
    and ops->freeze, thaw, error_handler, post_internal_cmd() for new EH.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 91e10e6b7565..e5d6d7f8e6dc 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -146,13 +146,16 @@ enum {
 	ATA_FLAG_PIO_LBA48	= (1 << 8), /* Host DMA engine is LBA28 only */
 	ATA_FLAG_IRQ_MASK	= (1 << 9), /* Mask IRQ in PIO xfers */
 
-	ATA_FLAG_NOINTR		= (1 << 16), /* FIXME: Remove this once
+	ATA_FLAG_NOINTR		= (1 << 13), /* FIXME: Remove this once
 					      * proper HSM is in place. */
-	ATA_FLAG_DEBUGMSG	= (1 << 17),
-	ATA_FLAG_FLUSH_PORT_TASK = (1 << 18), /* flush port task */
+	ATA_FLAG_DEBUGMSG	= (1 << 14),
+	ATA_FLAG_FLUSH_PORT_TASK = (1 << 15), /* flush port task */
 
-	ATA_FLAG_DISABLED	= (1 << 19), /* port is disabled, ignore it */
-	ATA_FLAG_SUSPENDED	= (1 << 20), /* port is suspended */
+	ATA_FLAG_EH_PENDING	= (1 << 16), /* EH pending */
+	ATA_FLAG_FROZEN		= (1 << 17), /* port is frozen */
+
+	ATA_FLAG_DISABLED	= (1 << 22), /* port is disabled, ignore it */
+	ATA_FLAG_SUSPENDED	= (1 << 23), /* port is suspended (power) */
 
 	/* bits 24:31 of ap->flags are reserved for LLDD specific flags */
 
@@ -164,7 +167,9 @@ enum {
 	ATA_QCFLAG_IO		= (1 << 3), /* standard IO command */
 	ATA_QCFLAG_RESULT_TF	= (1 << 4), /* result TF requested */
 
-	ATA_QCFLAG_EH_SCHEDULED = (1 << 16), /* EH scheduled */
+	ATA_QCFLAG_FAILED	= (1 << 16), /* cmd failed and is owned by EH */
+	ATA_QCFLAG_SENSE_VALID	= (1 << 17), /* sense data valid */
+	ATA_QCFLAG_EH_SCHEDULED = (1 << 18), /* EH scheduled (obsolete) */
 
 	/* host set flags */
 	ATA_HOST_SIMPLEX	= (1 << 0),	/* Host is simplex, one DMA channel per host_set only */
@@ -463,7 +468,15 @@ struct ata_port_operations {
 	void (*qc_prep) (struct ata_queued_cmd *qc);
 	unsigned int (*qc_issue) (struct ata_queued_cmd *qc);
 
-	void (*eng_timeout) (struct ata_port *ap);
+	/* Error handlers.  ->error_handler overrides ->eng_timeout and
+	 * indicates that new-style EH is in place.
+	 */
+	void (*eng_timeout) (struct ata_port *ap); /* obsolete */
+
+	void (*freeze) (struct ata_port *ap);
+	void (*thaw) (struct ata_port *ap);
+	void (*error_handler) (struct ata_port *ap);
+	void (*post_internal_cmd) (struct ata_queued_cmd *qc);
 
 	irqreturn_t (*irq_handler)(int, void *, struct pt_regs *);
 	void (*irq_clear) (struct ata_port *);

commit 61440db61fe4945ad9f7b32b4d6a22b17174aa1f
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:57:55 2006 +0900

    [PATCH] libata: implement ATA printk helpers
    
    Implement ata_{port|dev}_printk() which prefixes the message with
    proper identification string.  This change is necessary for later PM
    support because devices and links should be identified differently
    depending on how they are attached.
    
    This also helps unifying device id strings.  Currently, there are two
    forms in use (P is the port number D device number) - 'ataP(D):', and
    'ataP: dev D '.  These macros also make it harder to forget proper ID
    string (e.g. printing only port number when a device is in question).
    
    Debug message handling can be integrated into these printk macros by
    passing debug type and level via @lv.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 8154b366bbd1..91e10e6b7565 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -650,7 +650,18 @@ extern void ata_eng_timeout(struct ata_port *ap);
 extern void ata_eh_qc_complete(struct ata_queued_cmd *qc);
 extern void ata_eh_qc_retry(struct ata_queued_cmd *qc);
 
+/*
+ * printk helpers
+ */
+#define ata_port_printk(ap, lv, fmt, args...) \
+	printk(lv"ata%u: "fmt, (ap)->id , ##args)
+
+#define ata_dev_printk(dev, lv, fmt, args...) \
+	printk(lv"ata%u.%02u: "fmt, (dev)->ap->id, (dev)->devno , ##args)
 
+/*
+ * qc helpers
+ */
 static inline int
 ata_sg_is_last(struct scatterlist *sg, struct ata_queued_cmd *qc)
 {

commit 3373efd89dead4ce7818d685729e0431448357c9
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:57:53 2006 +0900

    [PATCH] libata: use dev->ap
    
    Use dev->ap where possible and eliminate superflous @ap from functions
    and structures.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ac2d2cc78b10..8154b366bbd1 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -518,8 +518,7 @@ extern void ata_std_probeinit(struct ata_port *ap);
 extern int ata_std_softreset(struct ata_port *ap, unsigned int *classes);
 extern int sata_std_hardreset(struct ata_port *ap, unsigned int *class);
 extern void ata_std_postreset(struct ata_port *ap, unsigned int *classes);
-extern int ata_dev_revalidate(struct ata_port *ap, struct ata_device *dev,
-			      int post_reset);
+extern int ata_dev_revalidate(struct ata_device *dev, int post_reset);
 extern void ata_port_disable(struct ata_port *);
 extern void ata_std_ports(struct ata_ioports *ioaddr);
 #ifdef CONFIG_PCI
@@ -545,8 +544,8 @@ extern int ata_port_online(struct ata_port *ap);
 extern int ata_port_offline(struct ata_port *ap);
 extern int ata_scsi_device_resume(struct scsi_device *);
 extern int ata_scsi_device_suspend(struct scsi_device *, pm_message_t state);
-extern int ata_device_resume(struct ata_port *, struct ata_device *);
-extern int ata_device_suspend(struct ata_port *, struct ata_device *, pm_message_t state);
+extern int ata_device_resume(struct ata_device *);
+extern int ata_device_suspend(struct ata_device *, pm_message_t state);
 extern int ata_ratelimit(void);
 extern unsigned int ata_busy_sleep(struct ata_port *ap,
 				   unsigned long timeout_pat,
@@ -592,15 +591,13 @@ extern void ata_bmdma_stop(struct ata_queued_cmd *qc);
 extern u8   ata_bmdma_status(struct ata_port *ap);
 extern void ata_bmdma_irq_clear(struct ata_port *ap);
 extern void __ata_qc_complete(struct ata_queued_cmd *qc);
-extern void ata_scsi_simulate(struct ata_port *ap, struct ata_device *dev,
-			      struct scsi_cmnd *cmd,
+extern void ata_scsi_simulate(struct ata_device *dev, struct scsi_cmnd *cmd,
 			      void (*done)(struct scsi_cmnd *));
 extern int ata_std_bios_param(struct scsi_device *sdev,
 			      struct block_device *bdev,
 			      sector_t capacity, int geom[]);
 extern int ata_scsi_slave_config(struct scsi_device *sdev);
-extern struct ata_device *ata_dev_pair(struct ata_port *ap, 
-				       struct ata_device *adev);
+extern struct ata_device *ata_dev_pair(struct ata_device *adev);
 
 /*
  * Timing helpers
@@ -812,12 +809,12 @@ static inline struct ata_queued_cmd *ata_qc_from_tag (struct ata_port *ap,
 	return NULL;
 }
 
-static inline void ata_tf_init(struct ata_port *ap, struct ata_taskfile *tf, unsigned int device)
+static inline void ata_tf_init(struct ata_device *dev, struct ata_taskfile *tf)
 {
 	memset(tf, 0, sizeof(*tf));
 
-	tf->ctl = ap->ctl;
-	if (device == 0)
+	tf->ctl = dev->ap->ctl;
+	if (dev->devno == 0)
 		tf->device = ATA_DEVICE_OBS;
 	else
 		tf->device = ATA_DEVICE_OBS | ATA_DEV1;
@@ -832,7 +829,7 @@ static inline void ata_qc_reinit(struct ata_queued_cmd *qc)
 	qc->nbytes = qc->curbytes = 0;
 	qc->err_mask = 0;
 
-	ata_tf_init(qc->ap, &qc->tf, qc->dev->devno);
+	ata_tf_init(qc->dev, &qc->tf);
 
 	/* init result_tf such that it indicates normal completion */
 	qc->result_tf.command = ATA_DRDY;

commit 38d87234d6c47ca487fc6344100323d5adc6f32c
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:57:51 2006 +0900

    [PATCH] libata: add dev->ap
    
    Add dev->ap which points back to the port the device belongs to.  This
    makes it unnecessary to pass @ap for silly reasons (e.g. printks).
    Also, this change is necessary to accomodate later PM support which
    will introduce ATA link inbetween port and device.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index cd467cd54473..ac2d2cc78b10 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -358,6 +358,7 @@ struct ata_host_stats {
 };
 
 struct ata_device {
+	struct ata_port		*ap;
 	u64			n_sectors;	/* size of device, if ATA */
 	unsigned long		flags;		/* ATA_DFLAG_xxx */
 	unsigned int		class;		/* ATA_DEV_xxx */

commit a0ab51cefc95cb7756c4914603fea2b1a0f813c5
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:57:49 2006 +0900

    [PATCH] libata: kill old SCR functions and sata_dev_present()
    
    Kill now unused scr_{read|write|write_flush}() and sata_dev_present().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 47b97157995d..cd467cd54473 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -939,28 +939,6 @@ static inline u8 ata_irq_ack(struct ata_port *ap, unsigned int chk_drq)
 	return status;
 }
 
-static inline u32 scr_read(struct ata_port *ap, unsigned int reg)
-{
-	return ap->ops->scr_read(ap, reg);
-}
-
-static inline void scr_write(struct ata_port *ap, unsigned int reg, u32 val)
-{
-	ap->ops->scr_write(ap, reg, val);
-}
-
-static inline void scr_write_flush(struct ata_port *ap, unsigned int reg,
-				   u32 val)
-{
-	ap->ops->scr_write(ap, reg, val);
-	(void) ap->ops->scr_read(ap, reg);
-}
-
-static inline unsigned int sata_dev_present(struct ata_port *ap)
-{
-	return ((scr_read(ap, SCR_STATUS) & 0xf) == 0x3) ? 1 : 0;
-}
-
 static inline int ata_try_flush_cache(const struct ata_device *dev)
 {
 	return ata_id_wcache_enabled(dev->id) ||

commit 34bf21704c848fe00c516d1c8f163db08b70b137
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:57:46 2006 +0900

    [PATCH] libata: implement new SCR handling and port on/offline functions
    
    Implement ata_scr_{valid|read|write|write_flush}() and
    ata_port_{online|offline}().  These functions replace
    scr_{read|write}() and sata_dev_present().
    
    Major difference between between the new SCR functions and the old
    ones is that the new ones have a way to signal error to the caller.
    This makes handling SCR-available and SCR-unavailable cases in the
    same path easier.  Also, it eases later PM implementation where SCR
    access can fail due to various reasons.
    
    ata_port_{online|offline}() functions return 1 only when they are
    affirmitive of the condition.  e.g.  if SCR is unaccessible or
    presence cannot be determined for other reasons, these functions
    return 0.  So, ata_port_online() != !ata_port_offline().  This
    distinction is useful in many exception handling cases.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a4b8a419caad..47b97157995d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -536,6 +536,12 @@ extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
 extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));
 extern int ata_scsi_release(struct Scsi_Host *host);
 extern unsigned int ata_host_intr(struct ata_port *ap, struct ata_queued_cmd *qc);
+extern int sata_scr_valid(struct ata_port *ap);
+extern int sata_scr_read(struct ata_port *ap, int reg, u32 *val);
+extern int sata_scr_write(struct ata_port *ap, int reg, u32 val);
+extern int sata_scr_write_flush(struct ata_port *ap, int reg, u32 val);
+extern int ata_port_online(struct ata_port *ap);
+extern int ata_port_offline(struct ata_port *ap);
 extern int ata_scsi_device_resume(struct scsi_device *);
 extern int ata_scsi_device_suspend(struct scsi_device *, pm_message_t state);
 extern int ata_device_resume(struct ata_port *, struct ata_device *);

commit e61e067227bc76b4d9411a50d735c9d87f27b0e2
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:57:40 2006 +0900

    [PATCH] libata: implement qc->result_tf
    
    Add qc->result_tf and ATA_QCFLAG_RESULT_TF.  This moves the
    responsibility of loading result TF from post-compltion path to qc
    execution path.  qc->result_tf is loaded if explicitly requested or
    the qc failsa.  This allows more efficient completion implementation
    and correct handling of result TF for controllers which don't have
    global TF representation such as sil3124/32.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 0e1a3be39475..a4b8a419caad 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -162,7 +162,9 @@ enum {
 	ATA_QCFLAG_SINGLE	= (1 << 2), /* no s/g, just a single buffer */
 	ATA_QCFLAG_DMAMAP	= ATA_QCFLAG_SG | ATA_QCFLAG_SINGLE,
 	ATA_QCFLAG_IO		= (1 << 3), /* standard IO command */
-	ATA_QCFLAG_EH_SCHEDULED = (1 << 4), /* EH scheduled */
+	ATA_QCFLAG_RESULT_TF	= (1 << 4), /* result TF requested */
+
+	ATA_QCFLAG_EH_SCHEDULED = (1 << 16), /* EH scheduled */
 
 	/* host set flags */
 	ATA_HOST_SIMPLEX	= (1 << 0),	/* Host is simplex, one DMA channel per host_set only */
@@ -343,7 +345,7 @@ struct ata_queued_cmd {
 	struct scatterlist	*__sg;
 
 	unsigned int		err_mask;
-
+	struct ata_taskfile	result_tf;
 	ata_qc_cb_t		complete_fn;
 
 	void			*private_data;
@@ -824,6 +826,10 @@ static inline void ata_qc_reinit(struct ata_queued_cmd *qc)
 	qc->err_mask = 0;
 
 	ata_tf_init(qc->ap, &qc->tf, qc->dev->devno);
+
+	/* init result_tf such that it indicates normal completion */
+	qc->result_tf.command = ATA_DRDY;
+	qc->result_tf.feature = 0;
 }
 
 /**
@@ -839,9 +845,15 @@ static inline void ata_qc_reinit(struct ata_queued_cmd *qc)
  */
 static inline void ata_qc_complete(struct ata_queued_cmd *qc)
 {
+	struct ata_port *ap = qc->ap;
+
 	if (unlikely(qc->flags & ATA_QCFLAG_EH_SCHEDULED))
 		return;
 
+	/* read result TF if failed or requested */
+	if (qc->err_mask || qc->flags & ATA_QCFLAG_RESULT_TF)
+		ap->ops->tf_read(ap, &qc->result_tf);
+
 	__ata_qc_complete(qc);
 }
 

commit fe635c7e91036282e4fd0cc5b4eebc712e43270d
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:57:35 2006 +0900

    [PATCH] libata: use preallocated buffers
    
    It's not a very good idea to allocate memory during EH.  Use
    statically allocated buffer for dev->id[] and add 512byte buffer
    ap->sector_buf.  This buffer is owned by EH (or probing) and to be
    used as temporary buffer for various purposes (IDENTIFY, NCQ log page
    10h, PM GSCR block).
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 220b9d7bfc28..0e1a3be39475 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -360,7 +360,7 @@ struct ata_device {
 	unsigned long		flags;		/* ATA_DFLAG_xxx */
 	unsigned int		class;		/* ATA_DEV_xxx */
 	unsigned int		devno;		/* 0 or 1 */
-	u16			*id;		/* IDENTIFY xxx DEVICE data */
+	u16			id[ATA_ID_WORDS]; /* IDENTIFY xxx DEVICE data */
 	u8			pio_mode;
 	u8			dma_mode;
 	u8			xfer_mode;
@@ -425,6 +425,8 @@ struct ata_port {
 	struct list_head	eh_done_q;
 
 	void			*private_data;
+
+	u8			sector_buf[ATA_SECT_SIZE]; /* owned by EH */
 };
 
 struct ata_port_operations {

commit 6cd727b14f1a6cdcb088d1067c1ba0ba124806a7
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:57:28 2006 +0900

    [PATCH] libata: kill duplicate prototypes
    
    Kill duplicate prototypes for ata_eh_qc_complete/retry() in libata.h.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 0b67aafd3878..220b9d7bfc28 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -530,8 +530,6 @@ extern void ata_host_set_remove(struct ata_host_set *host_set);
 extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
 extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));
-extern void ata_eh_qc_complete(struct ata_queued_cmd *qc);
-extern void ata_eh_qc_retry(struct ata_queued_cmd *qc);
 extern int ata_scsi_release(struct Scsi_Host *host);
 extern unsigned int ata_host_intr(struct ata_port *ap, struct ata_queued_cmd *qc);
 extern int ata_scsi_device_resume(struct scsi_device *);

commit 3c567b7d1137633f3ff67cd1df94abc5fd497a85
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:57:23 2006 +0900

    [PATCH] libata: rename ata_down_sata_spd_limit() and friends
    
    Rename ata_down_sata_spd_limit() and friends to sata_down_spd_limit()
    and likewise for simplicity & consistency.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d35b1e3bb7e0..0b67aafd3878 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -504,7 +504,7 @@ extern void ata_port_probe(struct ata_port *);
 extern void __sata_phy_reset(struct ata_port *ap);
 extern void sata_phy_reset(struct ata_port *ap);
 extern void ata_bus_reset(struct ata_port *ap);
-extern int ata_set_sata_spd(struct ata_port *ap);
+extern int sata_set_spd(struct ata_port *ap);
 extern int ata_drive_probe_reset(struct ata_port *ap,
 			ata_probeinit_fn_t probeinit,
 			ata_reset_fn_t softreset, ata_reset_fn_t hardreset,

commit a890b15c0990cc8d686edcc85f5fccde71ad5ce9
Merge: 79fa1b677be3 26ec634c31a1
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Apr 12 16:54:43 2006 -0400

    Merge branch 'upstream'

commit 875999c5539999f61a45620aae0c3e5fb1d2b035
Merge: 79072f38909e 26ec634c31a1
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Apr 12 16:54:16 2006 -0400

    Merge branch 'upstream'

commit 499a86af41cf5a4bf811726841bbc49c0e96fd35
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Apr 11 22:32:18 2006 +0900

    [PATCH] libata: export ata_set_sata_spd()
    
    This will be used by LLDD hardreset implementation.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index dd5bcb5d29b5..d35b1e3bb7e0 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -504,6 +504,7 @@ extern void ata_port_probe(struct ata_port *);
 extern void __sata_phy_reset(struct ata_port *ap);
 extern void sata_phy_reset(struct ata_port *ap);
 extern void ata_bus_reset(struct ata_port *ap);
+extern int ata_set_sata_spd(struct ata_port *ap);
 extern int ata_drive_probe_reset(struct ata_port *ap,
 			ata_probeinit_fn_t probeinit,
 			ata_reset_fn_t softreset, ata_reset_fn_t hardreset,

commit c22daff41001e9ccead87179ac0547f85447139e
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Apr 11 22:22:29 2006 +0900

    [PATCH] libata: implement ata_wait_register()
    
    As waiting for some register bits to change seems to be a common
    operation shared by some controllers, implement helper function
    ata_wait_register().  This function also takes care of register write
    flushing.
    
    Note that the condition is inverted, the wait is over when the masked
    value does NOT match @val.  As we're waiting for bits to change, this
    test is more powerful and allows the function to be used in more
    places.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d5fd5c06e755..dd5bcb5d29b5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -543,6 +543,9 @@ extern unsigned int ata_busy_sleep(struct ata_port *ap,
 				   unsigned long timeout);
 extern void ata_port_queue_task(struct ata_port *ap, void (*fn)(void *),
 				void *data, unsigned long delay);
+extern u32 ata_wait_register(void __iomem *reg, u32 mask, u32 val,
+			     unsigned long interval_msec,
+			     unsigned long timeout_msec);
 
 /*
  * Default driver ops implementations

commit 2bf2cb26b2512c6a609bb152982c388329bedff6
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Apr 11 22:16:45 2006 +0900

    [PATCH] libata: kill @verbose from ata_reset_fn_t
    
    @verbose was added to ata_reset_fn_t because AHCI complained during
    probing if no device was attached to the port.  However, muting
    failure message isn't the correct approach.  Reset methods are
    responsible for detecting no device condition and finishing
    successfully.  Now that AHCI softreset is fixed, kill @verbose.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index fe0a1dcc76c2..d5fd5c06e755 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -252,7 +252,7 @@ struct ata_queued_cmd;
 /* typedefs */
 typedef void (*ata_qc_cb_t) (struct ata_queued_cmd *qc);
 typedef void (*ata_probeinit_fn_t)(struct ata_port *);
-typedef int (*ata_reset_fn_t)(struct ata_port *, int, unsigned int *);
+typedef int (*ata_reset_fn_t)(struct ata_port *, unsigned int *);
 typedef void (*ata_postreset_fn_t)(struct ata_port *ap, unsigned int *);
 
 struct ata_ioports {
@@ -509,10 +509,8 @@ extern int ata_drive_probe_reset(struct ata_port *ap,
 			ata_reset_fn_t softreset, ata_reset_fn_t hardreset,
 			ata_postreset_fn_t postreset, unsigned int *classes);
 extern void ata_std_probeinit(struct ata_port *ap);
-extern int ata_std_softreset(struct ata_port *ap, int verbose,
-			     unsigned int *classes);
-extern int sata_std_hardreset(struct ata_port *ap, int verbose,
-			      unsigned int *class);
+extern int ata_std_softreset(struct ata_port *ap, unsigned int *classes);
+extern int sata_std_hardreset(struct ata_port *ap, unsigned int *class);
 extern void ata_std_postreset(struct ata_port *ap, unsigned int *classes);
 extern int ata_dev_revalidate(struct ata_port *ap, struct ata_device *dev,
 			      int post_reset);

commit 35bb94b116e1fd4959ef0d3187458b5820eac8c4
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Apr 11 13:12:34 2006 -0400

    libata: Add helper ata_shost_to_port()

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 2564bc514bca..fe0a1dcc76c2 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -33,6 +33,7 @@
 #include <asm/io.h>
 #include <linux/ata.h>
 #include <linux/workqueue.h>
+#include <scsi/scsi_host.h>
 
 /*
  * compile-time options: to be removed as soon as all the drivers are
@@ -977,4 +978,9 @@ static inline void ata_pad_free(struct ata_port *ap, struct device *dev)
 	dma_free_coherent(dev, ATA_DMA_PAD_BUF_SZ, ap->pad, ap->pad_dma);
 }
 
+static inline struct ata_port *ata_shost_to_port(struct Scsi_Host *host)
+{
+	return (struct ata_port *) &host->hostdata[0];
+}
+
 #endif /* __LINUX_LIBATA_H__ */

commit 381544bba3ae6f2f1004b267da34f840b469033c
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Apr 11 13:04:39 2006 -0400

    libata: Fix EH merge difference between this branch and upstream.

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a7161d42d18f..2564bc514bca 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -637,7 +637,6 @@ extern unsigned long ata_pci_default_filter(const struct ata_port *, struct ata_
 /*
  * EH
  */
-extern int ata_scsi_error(struct Scsi_Host *host);
 extern void ata_eng_timeout(struct ata_port *ap);
 extern void ata_eh_qc_complete(struct ata_queued_cmd *qc);
 extern void ata_eh_qc_retry(struct ata_queued_cmd *qc);

commit 10a5fd5e6b7e2d464c9f95f67cade4ddbd63f4e1
Merge: c2a658529600 a145410dccdb
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Apr 11 12:51:40 2006 -0400

    Merge branch 'master'
    
    Conflicts:
    
            drivers/scsi/libata-scsi.c
            include/linux/libata.h

commit 9227c33de80ac01f269ed33624990ce84358e419
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Apr 1 19:21:04 2006 +0200

    [PATCH] move ->eh_strategy_handler to the transport class
    
    Overriding the whole EH code is a per-transport, not per-host thing.
    Move ->eh_strategy_handler to the transport class, same as
    ->eh_timed_out.
    
    Downside is that scsi_host_alloc can't check for the total lack of EH
    anymore, but the transition period from old EH where we needed it is
    long gone already.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 0d61357604d5..b80d2e7fa6d2 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -523,7 +523,6 @@ extern void ata_host_set_remove(struct ata_host_set *host_set);
 extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
 extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));
-extern int ata_scsi_error(struct Scsi_Host *host);
 extern void ata_eh_qc_complete(struct ata_queued_cmd *qc);
 extern void ata_eh_qc_retry(struct ata_queued_cmd *qc);
 extern int ata_scsi_release(struct Scsi_Host *host);

commit 79fa1b677be3a985cc66b9218a4dd09818f1051b
Merge: 31ce6daefe2d c2a658529600
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Apr 4 08:45:13 2006 -0400

    Merge branch 'upstream'

commit 95de719adc94392a95c3c4d0a2d6b8b1ea39d236
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Tue Apr 4 10:57:18 2006 +0800

    [PATCH] libata: convert ATAPI_ENABLE_DMADIR to module parameter
    
    Convert the ATAPI_ENABLE_DMADIR compile time option needed
    by some SATA-PATA bridge to runtime module parameter.
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 75bdee09c307..03231cb6b406 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -44,7 +44,6 @@
 #undef ATA_NDEBUG		/* define to disable quick runtime checks */
 #undef ATA_ENABLE_PATA		/* define to enable PATA support in some
 				 * low-level drivers */
-#undef ATAPI_ENABLE_DMADIR	/* enables ATAPI DMADIR bridge support */
 
 
 /* note: prints function name for you */

commit 029f5468b5b5f93a09bf90326fdcb9124079658d
Merge: 8e181c14f2ba 1ad8e7f9eb05
Author: Jeff Garzik <jeff@garzik.org>
Date:   Sun Apr 2 10:30:40 2006 -0400

    Merge branch 'upstream'
    
    Conflicts:
    
            drivers/scsi/libata-core.c
            drivers/scsi/pdc_adma.c
            drivers/scsi/sata_mv.c
            drivers/scsi/sata_nv.c
            drivers/scsi/sata_promise.c
            drivers/scsi/sata_qstor.c
            drivers/scsi/sata_sx4.c
            drivers/scsi/sata_vsc.c
            include/linux/libata.h

commit ece1d63619df010b8c4f08e43755e2a03f3b6eed
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Apr 2 18:51:53 2006 +0900

    [PATCH] libata: separate out libata-eh.c
    
    A lot of EH codes are about to be added to libata.  Separate out
    libata-eh.c.  ata_scsi_timed_out(), ata_scsi_error(),
    ata_qc_timeout(), ata_eng_timeout(), ata_eh_qc_complete() and
    ata_eh_qc_retry() are moved.  No code is changed by this patch.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a6d829cb0567..75bdee09c307 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -531,9 +531,6 @@ extern void ata_host_set_remove(struct ata_host_set *host_set);
 extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
 extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));
-extern int ata_scsi_error(struct Scsi_Host *host);
-extern void ata_eh_qc_complete(struct ata_queued_cmd *qc);
-extern void ata_eh_qc_retry(struct ata_queued_cmd *qc);
 extern int ata_scsi_release(struct Scsi_Host *host);
 extern unsigned int ata_host_intr(struct ata_port *ap, struct ata_queued_cmd *qc);
 extern int ata_scsi_device_resume(struct scsi_device *);
@@ -582,7 +579,6 @@ extern void ata_bmdma_stop(struct ata_queued_cmd *qc);
 extern u8   ata_bmdma_status(struct ata_port *ap);
 extern void ata_bmdma_irq_clear(struct ata_port *ap);
 extern void __ata_qc_complete(struct ata_queued_cmd *qc);
-extern void ata_eng_timeout(struct ata_port *ap);
 extern void ata_scsi_simulate(struct ata_port *ap, struct ata_device *dev,
 			      struct scsi_cmnd *cmd,
 			      void (*done)(struct scsi_cmnd *));
@@ -637,6 +633,14 @@ extern int pci_test_config_bits(struct pci_dev *pdev, const struct pci_bits *bit
 extern unsigned long ata_pci_default_filter(const struct ata_port *, struct ata_device *, unsigned long);
 #endif /* CONFIG_PCI */
 
+/*
+ * EH
+ */
+extern int ata_scsi_error(struct Scsi_Host *host);
+extern void ata_eng_timeout(struct ata_port *ap);
+extern void ata_eh_qc_complete(struct ata_queued_cmd *qc);
+extern void ata_eh_qc_retry(struct ata_queued_cmd *qc);
+
 
 static inline int
 ata_sg_is_last(struct scatterlist *sg, struct ata_queued_cmd *qc)

commit 2719736779da2c7fbb17d3de16c817b429bfeb9c
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Apr 2 18:51:53 2006 +0900

    [PATCH] libata: add ATA_QCFLAG_IO
    
    Add a new qc flag ATA_QCFLAG_IO.  This flag gets set for normal IO
    commands originating from SCSI midlayer.  This information will be
    used by EH to determine transfer speed reconfiguration.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index cbbc821fe22c..a6d829cb0567 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -161,7 +161,8 @@ enum {
 	ATA_QCFLAG_SG		= (1 << 1), /* have s/g table? */
 	ATA_QCFLAG_SINGLE	= (1 << 2), /* no s/g, just a single buffer */
 	ATA_QCFLAG_DMAMAP	= ATA_QCFLAG_SG | ATA_QCFLAG_SINGLE,
-	ATA_QCFLAG_EH_SCHEDULED = (1 << 3), /* EH scheduled */
+	ATA_QCFLAG_IO		= (1 << 3), /* standard IO command */
+	ATA_QCFLAG_EH_SCHEDULED = (1 << 4), /* EH scheduled */
 
 	/* host set flags */
 	ATA_HOST_SIMPLEX	= (1 << 0),	/* Host is simplex, one DMA channel per host_set only */

commit ea1dd4e13010eb9dd5ffb4bfabbb472bc238bebb
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Apr 2 18:51:53 2006 +0900

    [PATCH] libata: clear only affected flags during ata_dev_configure()
    
    ata_dev_configure() should not clear dynamic device flags determined
    elsewhere.  Lower eight bits are reserved for feature flags, define
    ATA_DFLAG_CFG_MASK and clear only those bits before configuring
    device.  Without this patch, ATA_DFLAG_PIO gets turned off during
    revalidation making PIO mode unuseable.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 890262f44d0a..cbbc821fe22c 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -122,6 +122,7 @@ enum {
 	/* struct ata_device stuff */
 	ATA_DFLAG_LBA		= (1 << 0), /* device supports LBA */
 	ATA_DFLAG_LBA48		= (1 << 1), /* device supports LBA48 */
+	ATA_DFLAG_CFG_MASK	= (1 << 8) - 1,
 
 	ATA_DFLAG_PIO		= (1 << 8), /* device currently in PIO mode */
 

commit 198e0fed9e59461fc1890dd8b75ec72d14638873
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Apr 2 18:51:52 2006 +0900

    [PATCH] libata: rename ATA_FLAG_PORT_DISABLED to ATA_FLAG_DISABLED
    
    Rename ATA_FLAG_PORT_DISABLED to ATA_FLAG_DISABLED for consistency.
    (ATA_FLAG_* are always about ports).
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b7488a31e320..890262f44d0a 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -150,7 +150,7 @@ enum {
 	ATA_FLAG_DEBUGMSG	= (1 << 17),
 	ATA_FLAG_FLUSH_PORT_TASK = (1 << 18), /* flush port task */
 
-	ATA_FLAG_PORT_DISABLED	= (1 << 19), /* port is disabled, ignore it */
+	ATA_FLAG_DISABLED	= (1 << 19), /* port is disabled, ignore it */
 	ATA_FLAG_SUSPENDED	= (1 << 20), /* port is suspended */
 
 	/* bits 24:31 of ap->flags are reserved for LLDD specific flags */

commit 949b38af40a0b88b7267908b1554a45b97b5b737
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Apr 2 18:51:52 2006 +0900

    [PATCH] libata: clean up constants
    
    * Reorder ATA_DFLAG_* such that feature flags determined by
      ata_dev_configure() are on lower bits.  Reserve lower eight bits
      for this purpose and allocate dynamic flags from bit 8.
    
    * Reorder ATA_FLAG_* such that feature flags determined during driver
      initiailization are on bits 0:15, dynamic flags on 16:23 and LLDD
      specific flags on 24:31.
    
    * Kill trailing white space and lower-case an one line comment for
      consistency.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index e20b0bfbd5f2..b7488a31e320 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -120,9 +120,10 @@ enum {
 	ATA_SHT_USE_CLUSTERING	= 1,
 
 	/* struct ata_device stuff */
-	ATA_DFLAG_LBA48		= (1 << 0), /* device supports LBA48 */
-	ATA_DFLAG_PIO		= (1 << 1), /* device currently in PIO mode */
-	ATA_DFLAG_LBA		= (1 << 2), /* device supports LBA */
+	ATA_DFLAG_LBA		= (1 << 0), /* device supports LBA */
+	ATA_DFLAG_LBA48		= (1 << 1), /* device supports LBA48 */
+
+	ATA_DFLAG_PIO		= (1 << 8), /* device currently in PIO mode */
 
 	ATA_DEV_UNKNOWN		= 0,	/* unknown device */
 	ATA_DEV_ATA		= 1,	/* ATA device */
@@ -132,32 +133,34 @@ enum {
 	ATA_DEV_NONE		= 5,	/* no device */
 
 	/* struct ata_port flags */
-	ATA_FLAG_SLAVE_POSS	= (1 << 1), /* host supports slave dev */
+	ATA_FLAG_SLAVE_POSS	= (1 << 0), /* host supports slave dev */
 					    /* (doesn't imply presence) */
-	ATA_FLAG_PORT_DISABLED	= (1 << 2), /* port is disabled, ignore it */
-	ATA_FLAG_SATA		= (1 << 3),
-	ATA_FLAG_NO_LEGACY	= (1 << 4), /* no legacy mode check */
-	ATA_FLAG_SRST		= (1 << 5), /* (obsolete) use ATA SRST, not E.D.D. */
-	ATA_FLAG_MMIO		= (1 << 6), /* use MMIO, not PIO */
-	ATA_FLAG_SATA_RESET	= (1 << 7), /* (obsolete) use COMRESET */
-	ATA_FLAG_PIO_DMA	= (1 << 8), /* PIO cmds via DMA */
-	ATA_FLAG_NOINTR		= (1 << 9), /* FIXME: Remove this once
-					     * proper HSM is in place. */
-	ATA_FLAG_DEBUGMSG	= (1 << 10),
-	ATA_FLAG_NO_ATAPI	= (1 << 11), /* No ATAPI support */
-
-	ATA_FLAG_SUSPENDED	= (1 << 12), /* port is suspended */
-
-	ATA_FLAG_PIO_LBA48	= (1 << 13), /* Host DMA engine is LBA28 only */
-	ATA_FLAG_IRQ_MASK	= (1 << 14), /* Mask IRQ in PIO xfers */
-
-	ATA_FLAG_FLUSH_PORT_TASK = (1 << 15), /* Flush port task */
-
-	ATA_QCFLAG_ACTIVE	= (1 << 1), /* cmd not yet ack'd to scsi lyer */
-	ATA_QCFLAG_SG		= (1 << 3), /* have s/g table? */
-	ATA_QCFLAG_SINGLE	= (1 << 4), /* no s/g, just a single buffer */
+	ATA_FLAG_SATA		= (1 << 1),
+	ATA_FLAG_NO_LEGACY	= (1 << 2), /* no legacy mode check */
+	ATA_FLAG_MMIO		= (1 << 3), /* use MMIO, not PIO */
+	ATA_FLAG_SRST		= (1 << 4), /* (obsolete) use ATA SRST, not E.D.D. */
+	ATA_FLAG_SATA_RESET	= (1 << 5), /* (obsolete) use COMRESET */
+	ATA_FLAG_NO_ATAPI	= (1 << 6), /* No ATAPI support */
+	ATA_FLAG_PIO_DMA	= (1 << 7), /* PIO cmds via DMA */
+	ATA_FLAG_PIO_LBA48	= (1 << 8), /* Host DMA engine is LBA28 only */
+	ATA_FLAG_IRQ_MASK	= (1 << 9), /* Mask IRQ in PIO xfers */
+
+	ATA_FLAG_NOINTR		= (1 << 16), /* FIXME: Remove this once
+					      * proper HSM is in place. */
+	ATA_FLAG_DEBUGMSG	= (1 << 17),
+	ATA_FLAG_FLUSH_PORT_TASK = (1 << 18), /* flush port task */
+
+	ATA_FLAG_PORT_DISABLED	= (1 << 19), /* port is disabled, ignore it */
+	ATA_FLAG_SUSPENDED	= (1 << 20), /* port is suspended */
+
+	/* bits 24:31 of ap->flags are reserved for LLDD specific flags */
+
+	/* struct ata_queued_cmd flags */
+	ATA_QCFLAG_ACTIVE	= (1 << 0), /* cmd not yet ack'd to scsi lyer */
+	ATA_QCFLAG_SG		= (1 << 1), /* have s/g table? */
+	ATA_QCFLAG_SINGLE	= (1 << 2), /* no s/g, just a single buffer */
 	ATA_QCFLAG_DMAMAP	= ATA_QCFLAG_SG | ATA_QCFLAG_SINGLE,
-	ATA_QCFLAG_EH_SCHEDULED = (1 << 5), /* EH scheduled */
+	ATA_QCFLAG_EH_SCHEDULED = (1 << 3), /* EH scheduled */
 
 	/* host set flags */
 	ATA_HOST_SIMPLEX	= (1 << 0),	/* Host is simplex, one DMA channel per host_set only */
@@ -206,8 +209,8 @@ enum {
 	/* size of buffer to pad xfers ending on unaligned boundaries */
 	ATA_DMA_PAD_SZ		= 4,
 	ATA_DMA_PAD_BUF_SZ	= ATA_DMA_PAD_SZ * ATA_MAX_QUEUE,
-	
-	/* Masks for port functions */
+
+	/* masks for port functions */
 	ATA_PORT_PRIMARY	= (1 << 0),
 	ATA_PORT_SECONDARY	= (1 << 1),
 

commit c43c555c3a6db7f0b55fd9b66d7ecff16e827d4e
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Apr 2 18:51:52 2006 +0900

    [PATCH] libata: ATA_FLAG_IN_EH is not used, kill it
    
    Kill unused flag ATA_FLAG_IN_EH.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a4a1e6304e78..e20b0bfbd5f2 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -152,7 +152,6 @@ enum {
 	ATA_FLAG_IRQ_MASK	= (1 << 14), /* Mask IRQ in PIO xfers */
 
 	ATA_FLAG_FLUSH_PORT_TASK = (1 << 15), /* Flush port task */
-	ATA_FLAG_IN_EH		= (1 << 16), /* EH in progress */
 
 	ATA_QCFLAG_ACTIVE	= (1 << 1), /* cmd not yet ack'd to scsi lyer */
 	ATA_QCFLAG_SG		= (1 << 3), /* have s/g table? */

commit 14d2bac1877ed4e2cc940d1680db1a4f29225811
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Apr 2 17:54:46 2006 +0900

    [PATCH] libata: improve ata_bus_probe()
    
    Improve ata_bus_probe() such that configuration failures are handled
    better.  Each device is given ATA_PROBE_MAX_TRIES chances, but any
    non-transient error (revalidation failure with -ENODEV, configuration
    failure with -EINVAL...) disables the device directly.  Any IO error
    results in SATA PHY speed down and ata_set_mode() failure lowers
    transfer mode.  The last try always puts a device into PIO-0.
    
    After each failure, the whole port is reset to make sure that the
    controller and all the devices are in a known and stable state.  The
    reset also applies SATA SPD configuration if necessary.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a5207e66ca52..a4a1e6304e78 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -211,6 +211,9 @@ enum {
 	/* Masks for port functions */
 	ATA_PORT_PRIMARY	= (1 << 0),
 	ATA_PORT_SECONDARY	= (1 << 1),
+
+	/* how hard are we gonna try to probe/recover devices */
+	ATA_PROBE_MAX_TRIES	= 3,
 };
 
 enum hsm_task_states {

commit 1c3fae4d7eb121933341443c37d3bbee43c0fb68
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Apr 2 20:53:28 2006 +0900

    [PATCH] libata: implement ap->sata_spd_limit and helpers
    
    ap->sata_spd_limit contrains SATA PHY speed of the port.  It is
    initialized to the configured value prior to probing thus preserving
    BIOS configured value.  hardreset is responsible for applying SPD
    limit and sata_std_hardreset() is updated to do that.  SATA SPD limit
    will be used to enhance failure handling during probing and later by
    EH.
    
    This patch also normalizes some comments around affected code.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 0f8e3720edd9..a5207e66ca52 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -397,6 +397,7 @@ struct ata_port {
 	unsigned int		mwdma_mask;
 	unsigned int		udma_mask;
 	unsigned int		cbl;	/* cable type; ATA_CBL_xxx */
+	unsigned int		sata_spd_limit;	/* SATA PHY speed limit */
 
 	struct ata_device	device[ATA_MAX_DEVICES];
 

commit 002c8054fa8d0f1afce2b0c728be32d338b9293a
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Apr 2 17:54:46 2006 +0900

    [PATCH] libata: implement ata_dev_absent()
    
    For the time being we cannot use ata_dev_present() as it was renamed
    to ata_dev_enabled() but we still need presence test.  Implement
    negation of the test.  Conveniently, the negated result is needed in
    more places.  This is suggested by Jeff Garzik.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c6883ba8cba9..0f8e3720edd9 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -682,6 +682,11 @@ static inline unsigned int ata_class_disabled(unsigned int class)
 	return class == ATA_DEV_ATA_UNSUP || class == ATA_DEV_ATAPI_UNSUP;
 }
 
+static inline unsigned int ata_class_absent(unsigned int class)
+{
+	return !ata_class_enabled(class) && !ata_class_disabled(class);
+}
+
 static inline unsigned int ata_dev_enabled(const struct ata_device *dev)
 {
 	return ata_class_enabled(dev->class);
@@ -692,6 +697,11 @@ static inline unsigned int ata_dev_disabled(const struct ata_device *dev)
 	return ata_class_disabled(dev->class);
 }
 
+static inline unsigned int ata_dev_absent(const struct ata_device *dev)
+{
+	return ata_class_absent(dev->class);
+}
+
 static inline u8 ata_chk_status(struct ata_port *ap)
 {
 	return ap->ops->check_status(ap);

commit 6e07e16404deafadf45895a7d2aeb5feba53b479
Merge: 08a556db919f e8e0619f68bf
Author: Jeff Garzik <jeff@garzik.org>
Date:   Sat Apr 1 14:29:12 2006 -0500

    Merge branch 'upstream'

commit e1211e3fa7fd05ff0d4f597fd37e40de8acc6784
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Apr 1 01:38:18 2006 +0900

    [PATCH] libata: implement ata_dev_enabled and disabled()
    
    This patch renames ata_dev_present() to ata_dev_enabled() and adds
    ata_dev_disabled().  This is to discern the state where a device is
    present but disabled from not-present state.  This disctinction is
    necessary when configuring transfer mode because device selection
    timing must not be violated even if a device fails to configure.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 0d61357604d5..c6883ba8cba9 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -672,14 +672,24 @@ static inline unsigned int ata_tag_valid(unsigned int tag)
 	return (tag < ATA_MAX_QUEUE) ? 1 : 0;
 }
 
-static inline unsigned int ata_class_present(unsigned int class)
+static inline unsigned int ata_class_enabled(unsigned int class)
 {
 	return class == ATA_DEV_ATA || class == ATA_DEV_ATAPI;
 }
 
-static inline unsigned int ata_dev_present(const struct ata_device *dev)
+static inline unsigned int ata_class_disabled(unsigned int class)
 {
-	return ata_class_present(dev->class);
+	return class == ATA_DEV_ATA_UNSUP || class == ATA_DEV_ATAPI_UNSUP;
+}
+
+static inline unsigned int ata_dev_enabled(const struct ata_device *dev)
+{
+	return ata_class_enabled(dev->class);
+}
+
+static inline unsigned int ata_dev_disabled(const struct ata_device *dev)
+{
+	return ata_class_disabled(dev->class);
 }
 
 static inline u8 ata_chk_status(struct ata_port *ap)

commit 4f0e7c51ae392d841be395a9c6b8d26a9fbf33d2
Merge: 74d89c16735d 55d8ca4f8094
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Mar 29 19:59:39 2006 -0500

    Merge branch 'upstream'
    
    Conflicts:
    
            drivers/scsi/sata_mv.c

commit 79072f38909e3d9883317238887460c39ddcc4cb
Merge: 200d5a7684cc 55d8ca4f8094
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Mar 29 19:58:22 2006 -0500

    Merge branch 'upstream'

commit 5444a6f405618706eddbe1605ef8533b1b655764
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Mar 27 18:58:20 2006 +0100

    [PATCH] libata: Simplex and other mode filtering logic
    
    Add a field to the host_set called 'flags' (was host_set_flags changed
    to suit Jeff)
    Add a simplex_claimed field so we can remember who owns the DMA channel
    Add a ->mode_filter() hook to allow drivers to filter modes
    Add docs for mode_filter and set_mode
    Filter according to simplex state
    Filter cable in core
    
    This provides the needed framework to support all the mode rules found
    in the PATA world. The simplex filter deals with 'to spec' simplex DMA
    systems found in older chips. The cable filter avoids duplicating the
    same rules in each chip driver with PATA. Finally the mode filter is
    neccessary because drive/chip combinations have errata that forbid
    certain modes with some drives or types of ATA object.
    
    Drive speed setup remains per channel for now and the filters now use
    the framework Tejun put into place which cleans them up a lot from the
    older libata-pata patches.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6a9316cbb70b..0d61357604d5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -294,6 +294,9 @@ struct ata_host_set {
 	unsigned int		n_ports;
 	void			*private_data;
 	const struct ata_port_operations *ops;
+	unsigned long		flags;
+	int			simplex_claimed;	/* Keep seperate in case we
+							   ever need to do this locked */
 	struct ata_port *	ports[0];
 };
 
@@ -423,6 +426,7 @@ struct ata_port_operations {
 
 	void (*set_piomode) (struct ata_port *, struct ata_device *);
 	void (*set_dmamode) (struct ata_port *, struct ata_device *);
+	unsigned long (*mode_filter) (const struct ata_port *, struct ata_device *, unsigned long);
 
 	void (*tf_load) (struct ata_port *ap, const struct ata_taskfile *tf);
 	void (*tf_read) (struct ata_port *ap, struct ata_taskfile *tf);

commit e35a9e01f2a504871e70576a9e11dbe4d8dee456
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Mar 27 18:46:37 2006 +0100

    [PATCH] libata: Add ->set_mode hook for odd drivers
    
    Some hardware doesn't want the usual mode setup logic running. This
    allows the hardware driver to replace it for special cases in the least
    invasive way possible.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a5c213ce97c9..6a9316cbb70b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -433,6 +433,7 @@ struct ata_port_operations {
 	void (*dev_select)(struct ata_port *ap, unsigned int device);
 
 	void (*phy_reset) (struct ata_port *ap); /* obsolete */
+	void (*set_mode) (struct ata_port *ap);
 	int (*probe_reset) (struct ata_port *ap, unsigned int *classes);
 
 	void (*post_set_mode) (struct ata_port *ap);

commit 4e5ec5dba22ea509b1a004f9815751f0ffc815e5
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Mar 27 18:42:40 2006 +0100

    [PATCH] libata: BMDMA handling updates
    
    This is the minimal patch set to enable the current code to be used with
    a controller following SFF (ie any PATA and early SATA controllers)
    safely without crashes if there is no BMDMA area or if BMDMA is not
    assigned by the BIOS for some reason.
    
    Simplex status is recorded but not acted upon in this change, this isn't
    a problem with the current drivers as none of them are for simplex
    hardware. A following diff will deal with that.
    
    The flags in the probe structure remain ->host_set_flags although Jeff
    asked me to rename them, simply because the rename would break the usual
    Linux rules that old code should break when there are changes. not
    compile and run and then blow up/eat your computer/etc. Renaming this
    later is a trivial exercise once a better name is chosen.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 9fcc061e3adf..a5c213ce97c9 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -160,6 +160,9 @@ enum {
 	ATA_QCFLAG_DMAMAP	= ATA_QCFLAG_SG | ATA_QCFLAG_SINGLE,
 	ATA_QCFLAG_EH_SCHEDULED = (1 << 5), /* EH scheduled */
 
+	/* host set flags */
+	ATA_HOST_SIMPLEX	= (1 << 0),	/* Host is simplex, one DMA channel per host_set only */
+	
 	/* various lengths of time */
 	ATA_TMOUT_PIO		= 30 * HZ,
 	ATA_TMOUT_BOOT		= 30 * HZ,	/* heuristic */
@@ -278,6 +281,7 @@ struct ata_probe_ent {
 	unsigned long		irq;
 	unsigned int		irq_flags;
 	unsigned long		host_flags;
+	unsigned long		host_set_flags;
 	void __iomem		*mmio_base;
 	void			*private_data;
 };

commit 27cdadef6dfe0d0614653919a110fc75ab1650ce
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Sat Mar 25 17:53:57 2006 +0800

    [PATCH] libata-dev: Cleanup unused enums/functions
    
    Cleanup the following unused functions:
    - ata_pio_poll()
    - ata_pio_complete()
    - ata_pio_first_block()
    - ata_pio_block()
    - ata_pio_error()
    ap->pio_task_timeout and other enums.
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 70ca99bbc6c7..0eb71c1773a1 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -162,13 +162,8 @@ enum {
 	ATA_QCFLAG_EH_SCHEDULED = (1 << 5), /* EH scheduled */
 
 	/* various lengths of time */
-	ATA_TMOUT_PIO		= 30 * HZ,
 	ATA_TMOUT_BOOT		= 30 * HZ,	/* heuristic */
 	ATA_TMOUT_BOOT_QUICK	= 7 * HZ,	/* heuristic */
-	ATA_TMOUT_DATAOUT	= 30 * HZ,
-	ATA_TMOUT_DATAOUT_QUICK	= 5 * HZ,
-	ATA_TMOUT_CDB		= 30 * HZ,
-	ATA_TMOUT_CDB_QUICK	= 5 * HZ,
 	ATA_TMOUT_INTERNAL	= 30 * HZ,
 	ATA_TMOUT_INTERNAL_QUICK = 5 * HZ,
 
@@ -216,11 +211,8 @@ enum {
 enum hsm_task_states {
 	HSM_ST_UNKNOWN,		/* state unknown */
 	HSM_ST_IDLE,		/* no command on going */
-	HSM_ST_POLL,		/* same as HSM_ST, waits longer */
-	HSM_ST_TMOUT,		/* timeout */
 	HSM_ST,			/* (waiting the device to) transfer data */
 	HSM_ST_LAST,		/* (waiting the device to) complete command */
-	HSM_ST_LAST_POLL,	/* same as HSM_ST_LAST, waits longer */
 	HSM_ST_ERR,		/* error */
 	HSM_ST_FIRST,		/* (waiting the device to)
 				   write CDB or first data block */
@@ -409,7 +401,6 @@ struct ata_port {
 	struct work_struct	port_task;
 
 	unsigned int		hsm_task_state;
-	unsigned long		pio_task_timeout;
 
 	u32			msg_enable;
 	struct list_head	eh_done_q;

commit 4bbf7bc4c7bf1c80ec3c942fa5f1b6e6fa67dd99
Merge: 84ac69e8bf9f aec5c3c1a929
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Mar 24 12:29:39 2006 -0500

    Merge branch 'upstream'
    
    Conflicts:
    
            drivers/scsi/libata-core.c

commit aec5c3c1a929d7d79a420e943285cf3ba26a7c0d
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Mar 25 01:33:34 2006 +0900

    [PATCH] libata: kill E.D.D.
    
    E.D.D. has no user in-tree and mostly useless.  Kill it.  For possible
    out-of-tree users, add a nice warning message and error handling if
    LLDD doesn't report any useable reset mechanism (and thus tries to use
    E.D.D.).
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 047192253c3a..9fcc061e3adf 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -161,7 +161,6 @@ enum {
 	ATA_QCFLAG_EH_SCHEDULED = (1 << 5), /* EH scheduled */
 
 	/* various lengths of time */
-	ATA_TMOUT_EDD		= 5 * HZ,	/* heuristic */
 	ATA_TMOUT_PIO		= 30 * HZ,
 	ATA_TMOUT_BOOT		= 30 * HZ,	/* heuristic */
 	ATA_TMOUT_BOOT_QUICK	= 7 * HZ,	/* heuristic */

commit 2f1f610b62bce36d6d50857859091b8989c70267
Author: Brian King <brking@us.ibm.com>
Date:   Thu Mar 23 17:30:15 2006 -0600

    [PATCH] libata: Remove dependence on host_set->dev for SAS
    
    Remove some of the dependence on the host_set struct
    in preparation for supporting SAS HBAs. Adds a struct device
    pointer to the ata_port struct.
    
    Signed-off-by: Brian King <brking@us.ibm.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 80c2339da67d..047192253c3a 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -400,6 +400,7 @@ struct ata_port {
 
 	struct ata_host_stats	stats;
 	struct ata_host_set	*host_set;
+	struct device 		*dev;
 
 	struct work_struct	port_task;
 

commit ebdfca6eb1b755d3bfe9a81339ecdafd92038c1a
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Thu Mar 23 15:38:34 2006 +0000

    [PATCH] libata: add ata_dev_pair helper
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c52f13498556..80c2339da67d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -573,6 +573,8 @@ extern int ata_std_bios_param(struct scsi_device *sdev,
 			      struct block_device *bdev,
 			      sector_t capacity, int geom[]);
 extern int ata_scsi_slave_config(struct scsi_device *sdev);
+extern struct ata_device *ata_dev_pair(struct ata_port *ap, 
+				       struct ata_device *adev);
 
 /*
  * Timing helpers

commit 082776e4be791736c32baf818e50f501a7f83819
Author: Nigel Cunningham <ncunningham@cyclades.com>
Date:   Thu Mar 23 23:22:16 2006 +1000

    [PATCH] Make libata not powerdown drivers on PM_EVENT_FREEZE.
    
    At the moment libata doesn't pass pm_message_t down ata_device_suspend.
    This causes drives to be powered down when we just want a freeze,
    causing unnecessary wear and tear. This patch gets pm_message_t passed
    down so that it can be used to determine whether to power down the
    drive.
    
    Signed-off-by: Nigel Cunningham <nigel@suspend2.net>
    
     drivers/scsi/libata-core.c |    5 +++--
     drivers/scsi/libata-scsi.c |    4 ++--
     drivers/scsi/scsi_sysfs.c  |    2 +-
     include/linux/libata.h     |    4 ++--
     include/scsi/scsi_host.h   |    2 +-
     5 files changed, 9 insertions(+), 8 deletions(-)
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index fbe8ba212598..c52f13498556 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -520,9 +520,9 @@ extern void ata_eh_qc_retry(struct ata_queued_cmd *qc);
 extern int ata_scsi_release(struct Scsi_Host *host);
 extern unsigned int ata_host_intr(struct ata_port *ap, struct ata_queued_cmd *qc);
 extern int ata_scsi_device_resume(struct scsi_device *);
-extern int ata_scsi_device_suspend(struct scsi_device *);
+extern int ata_scsi_device_suspend(struct scsi_device *, pm_message_t state);
 extern int ata_device_resume(struct ata_port *, struct ata_device *);
-extern int ata_device_suspend(struct ata_port *, struct ata_device *);
+extern int ata_device_suspend(struct ata_port *, struct ata_device *, pm_message_t state);
 extern int ata_ratelimit(void);
 extern unsigned int ata_busy_sleep(struct ata_port *ap,
 				   unsigned long timeout_pat,

commit acf356b12d13c8b43c486e53e8ee12f1f435ecc8
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Mar 24 14:07:50 2006 +0900

    [PATCH] libata: add per-dev pio/mwdma/udma_mask
    
    Add per-dev pio/mwdma/udma_mask.  All transfer mode limits used to be
    applied to ap->*_mask which unnecessarily restricted other devices
    sharing the port.  This change will also benefit later EH speed down
    and hotplug.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 7a54244d30aa..fbe8ba212598 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -358,6 +358,11 @@ struct ata_device {
 	unsigned int		max_sectors;	/* per-device max sectors */
 	unsigned int		cdb_len;
 
+	/* per-dev xfer mask */
+	unsigned int		pio_mask;
+	unsigned int		mwdma_mask;
+	unsigned int		udma_mask;
+
 	/* for CHS addressing */
 	u16			cylinders;	/* Number of cylinders */
 	u16			heads;		/* Number of heads */

commit 11ed56fb7899f9eb9eaef8e5919db1bf08f1b07e
Merge: 54da9a396844 2cc432eed049
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Mar 24 09:24:04 2006 -0500

    Merge branch 'upstream'
    
    Conflicts:
    
            drivers/scsi/sata_vsc.c

commit f01c18456993bab43067b678f56c87ca954aa43b
Merge: 949ec2c8e6b7 1c2e02750b99
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Mar 22 19:13:54 2006 -0500

    Merge branch 'master'

commit 200d5a7684cc49ef4be40e832daf3f217e70dfbb
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Feb 15 16:24:49 2006 +0900

    [PATCH] libata: increase LBA48 max sectors to 65535
    
    max_hw_sectors/max_sectors separation patch made into the tree,
    increase max_sectors to its hardware limit.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d81cecdda4f3..4dff3cf9d389 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -110,6 +110,7 @@ enum {
 	ATA_DEF_QUEUE		= 1,
 	ATA_MAX_QUEUE		= 1,
 	ATA_MAX_SECTORS		= 200,	/* FIXME */
+	ATA_MAX_SECTORS_LBA48	= 65535,
 	ATA_MAX_BUS		= 2,
 	ATA_DEF_BUSY_WAIT	= 10000,
 	ATA_SHORT_PAUSE		= (HZ >> 6) + 1,

commit 17bb34a3c548c4fd2a7c859123a631f97c2af09f
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Mar 21 21:29:21 2006 -0500

    [libata] add prototypes for helpers
    
    Add prototypes for stuff recently added by Alan.

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 17e5a719c72b..d81cecdda4f3 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -502,6 +502,7 @@ extern int ata_pci_init_one (struct pci_dev *pdev, struct ata_port_info **port_i
 extern void ata_pci_remove_one (struct pci_dev *pdev);
 extern int ata_pci_device_suspend(struct pci_dev *pdev, pm_message_t state);
 extern int ata_pci_device_resume(struct pci_dev *pdev);
+extern int ata_pci_clear_simplex(struct pci_dev *pdev);
 #endif /* CONFIG_PCI */
 extern int ata_device_add(const struct ata_probe_ent *ent);
 extern void ata_host_set_remove(struct ata_host_set *host_set);
@@ -610,7 +611,7 @@ extern void ata_pci_host_stop (struct ata_host_set *host_set);
 extern struct ata_probe_ent *
 ata_pci_init_native_mode(struct pci_dev *pdev, struct ata_port_info **port, int portmask);
 extern int pci_test_config_bits(struct pci_dev *pdev, const struct pci_bits *bits);
-
+extern unsigned long ata_pci_default_filter(const struct ata_port *, struct ata_device *, unsigned long);
 #endif /* CONFIG_PCI */
 
 

commit e46834cd2ddb1e2941806cb8fec60fb6bdd2ec29
Author: Brian King <brking@us.ibm.com>
Date:   Fri Mar 17 17:04:03 2006 -0600

    [PATCH] libata: Add some dummy noop functions
    
    Add some dummy noop functions for use by libata clients
    that do not need to do anything. Future SAS patches will
    utilize these functions.
    
    Signed-off-by: Brian King <brking@us.ibm.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 239408ecfddf..17e5a719c72b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -543,6 +543,7 @@ extern void ata_port_stop (struct ata_port *ap);
 extern void ata_host_stop (struct ata_host_set *host_set);
 extern irqreturn_t ata_interrupt (int irq, void *dev_instance, struct pt_regs *regs);
 extern void ata_qc_prep(struct ata_queued_cmd *qc);
+extern void ata_noop_qc_prep(struct ata_queued_cmd *qc);
 extern unsigned int ata_qc_issue_prot(struct ata_queued_cmd *qc);
 extern void ata_sg_init_one(struct ata_queued_cmd *qc, void *buf,
 		unsigned int buflen);

commit 30afc84cf7325e88fb9746340eba3c161080ff49
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Mar 18 18:40:14 2006 +0900

    [SCSI] libata: implement minimal transport template for ->eh_timed_out
    
    SCSI midlayer has moved hostt->eh_timed_out to transport template.  As
    libata doesn't need full-blown transport support yet, implement
    minimal transport for libata.  No transport class or whatsoever, just
    empty transport template with ->eh_timed_out hook.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 239408ecfddf..204c37a55f06 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -508,7 +508,6 @@ extern void ata_host_set_remove(struct ata_host_set *host_set);
 extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
 extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));
-extern enum scsi_eh_timer_return ata_scsi_timed_out(struct scsi_cmnd *cmd);
 extern int ata_scsi_error(struct Scsi_Host *host);
 extern void ata_eh_qc_complete(struct ata_queued_cmd *qc);
 extern void ata_eh_qc_retry(struct ata_queued_cmd *qc);

commit ce1e7a2ac721eb9d825b63f74752d0c9e0c635c2
Merge: c2956a3b0d1c 75deb6fa985b
Author: Jeff Garzik <jeff@garzik.org>
Date:   Sat Mar 11 19:21:17 2006 -0500

    Merge branch 'upstream'

commit 1da7b0d01b20bf21f3263d8d2f17fa49a214d773
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Mar 6 04:31:56 2006 +0900

    [PATCH] libata: improve xfer mask constants and update ata_mode_string()
    
    Add ATA_BITS_*, ATA_MASK_* macros and reorder xfer_mask fields such
    that higher transfer mode is placed at higher order bit.  As thie
    reordering breaks ata_mode_string(), this patch also rewrites
    ata_mode_string().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 15674923cc84..239408ecfddf 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -188,11 +188,19 @@ enum {
 	PORT_DISABLED		= 2,
 
 	/* encoding various smaller bitmaps into a single
-	 * unsigned long bitmap
+	 * unsigned int bitmap
 	 */
-	ATA_SHIFT_UDMA		= 0,
-	ATA_SHIFT_MWDMA		= 8,
-	ATA_SHIFT_PIO		= 11,
+	ATA_BITS_PIO		= 5,
+	ATA_BITS_MWDMA		= 3,
+	ATA_BITS_UDMA		= 8,
+
+	ATA_SHIFT_PIO		= 0,
+	ATA_SHIFT_MWDMA		= ATA_SHIFT_PIO + ATA_BITS_PIO,
+	ATA_SHIFT_UDMA		= ATA_SHIFT_MWDMA + ATA_BITS_MWDMA,
+
+	ATA_MASK_PIO		= ((1 << ATA_BITS_PIO) - 1) << ATA_SHIFT_PIO,
+	ATA_MASK_MWDMA		= ((1 << ATA_BITS_MWDMA) - 1) << ATA_SHIFT_MWDMA,
+	ATA_MASK_UDMA		= ((1 << ATA_BITS_UDMA) - 1) << ATA_SHIFT_UDMA,
 
 	/* size of buffer to pad xfers ending on unaligned boundaries */
 	ATA_DMA_PAD_SZ		= 4,

commit 2e755f68ee23b03484fde18d978f910cc5479cb8
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Mar 5 15:29:09 2006 +0900

    [PATCH] libata: rename ATA_FLAG_FLUSH_PIO_TASK to ATA_FLAG_FLUSH_PORT_TASK
    
    Rename ATA_FLAG_FLUSH_PIO_TASK to ATA_FLAG_FLUSH_PORT_TASK.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 9ad020ac8591..15674923cc84 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -151,7 +151,7 @@ enum {
 	ATA_FLAG_PIO_LBA48	= (1 << 13), /* Host DMA engine is LBA28 only */
 	ATA_FLAG_IRQ_MASK	= (1 << 14), /* Mask IRQ in PIO xfers */
 
-	ATA_FLAG_FLUSH_PIO_TASK	= (1 << 15), /* Flush PIO task */
+	ATA_FLAG_FLUSH_PORT_TASK = (1 << 15), /* Flush port task */
 	ATA_FLAG_IN_EH		= (1 << 16), /* EH in progress */
 
 	ATA_QCFLAG_ACTIVE	= (1 << 1), /* cmd not yet ack'd to scsi lyer */

commit 507ceda00302c071029277652d9faa5a0a55419a
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Mar 5 15:29:09 2006 +0900

    [PATCH] libata: kill unused pio_task and packet_task
    
    Kill unused pio_task and packet_task.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 3ad2570f663b..9ad020ac8591 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -390,9 +390,6 @@ struct ata_port {
 
 	struct work_struct	port_task;
 
-	struct work_struct	packet_task;
-
-	struct work_struct	pio_task;
 	unsigned int		hsm_task_state;
 	unsigned long		pio_task_timeout;
 

commit 86e45b6bd6900c4a0b3666fb18b46e215f775c4f
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Mar 5 15:29:09 2006 +0900

    [PATCH] libata: implement port_task
    
    Implement port_task.  LLDD's can schedule a function to be executed
    with context after specified delay.  libata core takes care of
    synchronization against EH.  This is generalized form of pio_task and
    packet_task which are tied to PIO hsm implementation.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 66dce58f1941..3ad2570f663b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -388,6 +388,8 @@ struct ata_port {
 	struct ata_host_stats	stats;
 	struct ata_host_set	*host_set;
 
+	struct work_struct	port_task;
+
 	struct work_struct	packet_task;
 
 	struct work_struct	pio_task;
@@ -515,6 +517,8 @@ extern int ata_ratelimit(void);
 extern unsigned int ata_busy_sleep(struct ata_port *ap,
 				   unsigned long timeout_pat,
 				   unsigned long timeout);
+extern void ata_port_queue_task(struct ata_port *ap, void (*fn)(void *),
+				void *data, unsigned long delay);
 
 /*
  * Default driver ops implementations

commit 623a3128aa2b86caa8e06e762e9e444177e4fa47
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Mar 5 17:55:58 2006 +0900

    [PATCH] libata: implement ata_dev_revalidate()
    
    ata_dev_revalidate() re-reads IDENTIFY PAGE of the given device and
    makes sure it's the same device as the configured one.  Once it's
    verified that it's the same device, @dev is configured according to
    newly read IDENTIFY PAGE.  Note that revalidation currently doesn't
    invoke transfer mode reconfiguration.
    
    Criteria for 'same device'
    
    * same class (of course)
    * same model string
    * same serial string
    * if ATA, same n_sectors (to catch geometry parameter changes)
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 86a504f0ef06..66dce58f1941 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -485,6 +485,8 @@ extern int ata_std_softreset(struct ata_port *ap, int verbose,
 extern int sata_std_hardreset(struct ata_port *ap, int verbose,
 			      unsigned int *class);
 extern void ata_std_postreset(struct ata_port *ap, unsigned int *classes);
+extern int ata_dev_revalidate(struct ata_port *ap, struct ata_device *dev,
+			      int post_reset);
 extern void ata_port_disable(struct ata_port *);
 extern void ata_std_ports(struct ata_ioports *ioaddr);
 #ifdef CONFIG_PCI

commit 4b2f3ededc035525038a7a9247074243dac6b351
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Mar 1 16:09:36 2006 +0900

    [PATCH] libata: fold ata_dev_config() into ata_dev_configure()
    
    ata_dev_config() needs to be done everytime a device is configured.
    Fold it into ata_dev_configure().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 9f273dd1958c..86a504f0ef06 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -542,7 +542,6 @@ extern void ata_id_string(const u16 *id, unsigned char *s,
 			  unsigned int ofs, unsigned int len);
 extern void ata_id_c_string(const u16 *id, unsigned char *s,
 			    unsigned int ofs, unsigned int len);
-extern void ata_dev_config(struct ata_port *ap, unsigned int i);
 extern void ata_bmdma_setup (struct ata_queued_cmd *qc);
 extern void ata_bmdma_start (struct ata_queued_cmd *qc);
 extern void ata_bmdma_stop(struct ata_queued_cmd *qc);

commit d9572b1d5e60b63e27e17f1f7771c5a26dd5d81e
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Mar 1 16:09:35 2006 +0900

    [PATCH] libata: convert dev->id to pointer
    
    Convert dev->id from array to pointer.  This is to accomodate
    revalidation.  During revalidation, both old and new IDENTIFY pages
    should be accessible and single ->id array doesn't cut it.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 22e86cb2d166..9f273dd1958c 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -339,7 +339,7 @@ struct ata_device {
 	unsigned long		flags;		/* ATA_DFLAG_xxx */
 	unsigned int		class;		/* ATA_DEV_xxx */
 	unsigned int		devno;		/* 0 or 1 */
-	u16			id[ATA_ID_WORDS]; /* IDENTIFY xxx DEVICE data */
+	u16			*id;		/* IDENTIFY xxx DEVICE data */
 	u8			pio_mode;
 	u8			dma_mode;
 	u8			xfer_mode;

commit 597afd21401c85bdf9441830abf431c2be6fd45f
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Mar 1 01:25:38 2006 +0900

    [PATCH] libata: seperate out ata_class_present()
    
    Seperate out ata_class_present() from ata_dev_present().  This is
    useful because new reset mechanism deals with classes[] directly.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 66b6847225df..22e86cb2d166 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -645,10 +645,14 @@ static inline unsigned int ata_tag_valid(unsigned int tag)
 	return (tag < ATA_MAX_QUEUE) ? 1 : 0;
 }
 
+static inline unsigned int ata_class_present(unsigned int class)
+{
+	return class == ATA_DEV_ATA || class == ATA_DEV_ATAPI;
+}
+
 static inline unsigned int ata_dev_present(const struct ata_device *dev)
 {
-	return ((dev->class == ATA_DEV_ATA) ||
-		(dev->class == ATA_DEV_ATAPI));
+	return ata_class_present(dev->class);
 }
 
 static inline u8 ata_chk_status(struct ata_port *ap)

commit 11fff8287fdaeb700df79aa8253650b60c7b21e2
Merge: a5fd79ccd60b f131883e73a8
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Feb 20 16:56:08 2006 -0500

    Merge branch 'upstream'

commit f131883e73a8662dc92c3ea371ae9ded0c8f2c37
Merge: ccbe6d5ee0eb 2e242fa99442
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Feb 20 16:55:56 2006 -0500

    Merge branch 'upstream-fixes'

commit cc1887f3d8ae8ea61efa1a75af8ec0467b9dd546
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Feb 20 23:48:38 2006 +0900

    [PATCH] libata: fix qc->n_elem == 0 case handling in ata_qc_next_sg
    
    This patch makes ata_for_each_sg() start with pad_sgent when
    qc->n_elem is zero.  Previously, ata_for_each_sg() unconditionally
    started with qc->__sg, handling the first sg to fill_sg() routines
    even when the entry was invalid.  And while at it, unwind ?: in
    ata_qc_next_sg() into if statement.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 9e5db2949c58..c91be5e64ede 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -556,6 +556,16 @@ ata_sg_is_last(struct scatterlist *sg, struct ata_queued_cmd *qc)
 	return 0;
 }
 
+static inline struct scatterlist *
+ata_qc_first_sg(struct ata_queued_cmd *qc)
+{
+	if (qc->n_elem)
+		return qc->__sg;
+	if (qc->pad_len)
+		return &qc->pad_sgent;
+	return NULL;
+}
+
 static inline struct scatterlist *
 ata_qc_next_sg(struct scatterlist *sg, struct ata_queued_cmd *qc)
 {
@@ -563,11 +573,13 @@ ata_qc_next_sg(struct scatterlist *sg, struct ata_queued_cmd *qc)
 		return NULL;
 	if (++sg - qc->__sg < qc->n_elem)
 		return sg;
-	return qc->pad_len ? &qc->pad_sgent : NULL;
+	if (qc->pad_len)
+		return &qc->pad_sgent;
+	return NULL;
 }
 
 #define ata_for_each_sg(sg, qc) \
-	for (sg = qc->__sg; sg; sg = ata_qc_next_sg(sg, qc))
+	for (sg = ata_qc_first_sg(qc); sg; sg = ata_qc_next_sg(sg, qc))
 
 static inline unsigned int ata_tag_valid(unsigned int tag)
 {

commit ff607748590fba14aecedb0d50edc4ada98d4302
Merge: db024d5398cd 6aff8f1f07a7
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Feb 20 05:13:31 2006 -0500

    Merge branch 'upstream'

commit 6a62a04d4705df4f9f9bee39e889b9e920eeca47
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Feb 13 10:02:46 2006 +0900

    [PATCH] libata: rename ata_dev_id_[c_]string()
    
    This patch renames ata_dev_id_[c_]string() to ata_id_[c_]string().
    All other functions which read data from ATA ID data start with ata_id
    and those two function names were getting too long.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index afe46457124e..0d6bf50ad029 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -538,10 +538,10 @@ extern void ata_sg_init_one(struct ata_queued_cmd *qc, void *buf,
 extern void ata_sg_init(struct ata_queued_cmd *qc, struct scatterlist *sg,
 		 unsigned int n_elem);
 extern unsigned int ata_dev_classify(const struct ata_taskfile *tf);
-extern void ata_dev_id_string(const u16 *id, unsigned char *s,
-			      unsigned int ofs, unsigned int len);
-extern void ata_dev_id_c_string(const u16 *id, unsigned char *s,
-				unsigned int ofs, unsigned int len);
+extern void ata_id_string(const u16 *id, unsigned char *s,
+			  unsigned int ofs, unsigned int len);
+extern void ata_id_c_string(const u16 *id, unsigned char *s,
+			    unsigned int ofs, unsigned int len);
 extern void ata_dev_config(struct ata_port *ap, unsigned int i);
 extern void ata_bmdma_setup (struct ata_queued_cmd *qc);
 extern void ata_bmdma_start (struct ata_queued_cmd *qc);

commit 3875e1945b55f0eb83fe7359614a801eeb716761
Merge: 587005de144a f1b318793dcd
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Feb 13 00:13:48 2006 -0500

    Merge branch 'upstream'

commit b00eec1d58ee71131375bfeb86e64bceec3f5618
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Feb 12 23:32:59 2006 +0900

    [PATCH] libata: add per-device max_sectors
    
    If a low level driver wants to control max_sectors, it had to adjust
    ap->host->max_sectors and set ATA_DFLAG_LOCK_SECTORS to tell
    ata_scsi_slave_config not to override the limit.  This is not only
    cumbersome but also incorrect for hosts which support more than one
    devices per port.
    
    This patch adds per-device ->max_sectors.  If the field is unset
    (zero), libata core layer will adjust ->max_sectors according to
    default rules.  If the field is set, libata honors the setting.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 853c98859a9f..afe46457124e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -122,8 +122,7 @@ enum {
 	/* struct ata_device stuff */
 	ATA_DFLAG_LBA48		= (1 << 0), /* device supports LBA48 */
 	ATA_DFLAG_PIO		= (1 << 1), /* device currently in PIO mode */
-	ATA_DFLAG_LOCK_SECTORS	= (1 << 2), /* don't adjust max_sectors */
-	ATA_DFLAG_LBA		= (1 << 3), /* device supports LBA */
+	ATA_DFLAG_LBA		= (1 << 2), /* device supports LBA */
 
 	ATA_DEV_UNKNOWN		= 0,	/* unknown device */
 	ATA_DEV_ATA		= 1,	/* ATA device */
@@ -348,6 +347,7 @@ struct ata_device {
 
 	unsigned int		multi_count;	/* sectors count for
 						   READ/WRITE MULTIPLE */
+	unsigned int		max_sectors;	/* per-device max sectors */
 	unsigned int		cdb_len;
 
 	/* for CHS addressing */

commit 6e7846e9c548443c86cfbad9e4defb4bdcfc538b
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Feb 12 23:32:58 2006 +0900

    [PATCH] libata: move cdb_len for host to device
    
    cdb_len is per-device property.  Sharing cdb_len on ap results in
    inaccurate configuration on revalidation and hotplugging.  This patch
    makes cdb_len per-device.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 0853032673b7..853c98859a9f 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -348,6 +348,7 @@ struct ata_device {
 
 	unsigned int		multi_count;	/* sectors count for
 						   READ/WRITE MULTIPLE */
+	unsigned int		cdb_len;
 
 	/* for CHS addressing */
 	u16			cylinders;	/* Number of cylinders */
@@ -377,7 +378,6 @@ struct ata_port {
 	unsigned int		mwdma_mask;
 	unsigned int		udma_mask;
 	unsigned int		cbl;	/* cable type; ATA_CBL_xxx */
-	unsigned int		cdb_len;
 
 	struct ata_device	device[ATA_MAX_DEVICES];
 

commit 0e949ff304a7ca07db38c17fbbf3ead1085d7bbf
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Feb 12 22:47:04 2006 +0900

    [PATCH] libata: implement ata_dev_id_c_string()
    
    ata_dev_id_c_string() reads ATA string from the specified offset of
    the given IDENTIFY PAGE and puts it in the specified buffer in trimmed
    and NULL-terminated form.  The caller must supply a buffer which is
    one byte larger than the maximum size of the target ID string.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 83a1f2ead861..0853032673b7 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -540,6 +540,8 @@ extern void ata_sg_init(struct ata_queued_cmd *qc, struct scatterlist *sg,
 extern unsigned int ata_dev_classify(const struct ata_taskfile *tf);
 extern void ata_dev_id_string(const u16 *id, unsigned char *s,
 			      unsigned int ofs, unsigned int len);
+extern void ata_dev_id_c_string(const u16 *id, unsigned char *s,
+				unsigned int ofs, unsigned int len);
 extern void ata_dev_config(struct ata_port *ap, unsigned int i);
 extern void ata_bmdma_setup (struct ata_queued_cmd *qc);
 extern void ata_bmdma_start (struct ata_queued_cmd *qc);

commit 1cb9d721d9df9182a42d1ff59427a100c6522efc
Merge: ca7d5e42d783 bef4a456b8dc
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat Feb 11 18:02:04 2006 -0500

    Merge branch 'upstream'

commit bef4a456b8dc8b3638f4d49a25a89e1467da9483
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Feb 11 19:11:13 2006 +0900

    [PATCH] libata: kill assert() macro
    
    libata assert() now has no user left.  Kill it.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 695d9ae6ec03..83a1f2ead861 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -62,16 +62,6 @@
 
 #define BPRINTK(fmt, args...) if (ap->flags & ATA_FLAG_DEBUGMSG) printk(KERN_ERR "%s: " fmt, __FUNCTION__, ## args)
 
-#ifdef ATA_NDEBUG
-#define assert(expr)
-#else
-#define assert(expr) \
-        if(unlikely(!(expr))) {                                   \
-        printk(KERN_ERR "Assertion failed! %s,%s,%s,line=%d\n", \
-        #expr,__FILE__,__FUNCTION__,__LINE__);          \
-        }
-#endif
-
 /* NEW: debug levels */
 #define HAVE_LIBATA_MSG 1
 

commit 76014427e60f7ecfdc689dfbcb48e9760e1da4fb
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Feb 11 15:13:49 2006 +0900

    [PATCH] libata: inline ata_qc_complete()
    
    This patch inlines ata_qc_complete() and uninlines __ata_qc_complete()
    as suggested by Jeff Garzik.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index c1e198655bb1..695d9ae6ec03 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -556,7 +556,7 @@ extern void ata_bmdma_start (struct ata_queued_cmd *qc);
 extern void ata_bmdma_stop(struct ata_queued_cmd *qc);
 extern u8   ata_bmdma_status(struct ata_port *ap);
 extern void ata_bmdma_irq_clear(struct ata_port *ap);
-extern void ata_qc_complete(struct ata_queued_cmd *qc);
+extern void __ata_qc_complete(struct ata_queued_cmd *qc);
 extern void ata_eng_timeout(struct ata_port *ap);
 extern void ata_scsi_simulate(struct ata_port *ap, struct ata_device *dev,
 			      struct scsi_cmnd *cmd,
@@ -756,6 +756,24 @@ static inline void ata_qc_reinit(struct ata_queued_cmd *qc)
 	ata_tf_init(qc->ap, &qc->tf, qc->dev->devno);
 }
 
+/**
+ *	ata_qc_complete - Complete an active ATA command
+ *	@qc: Command to complete
+ *	@err_mask: ATA Status register contents
+ *
+ *	Indicate to the mid and upper layers that an ATA
+ *	command has completed, with either an ok or not-ok status.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host_set lock)
+ */
+static inline void ata_qc_complete(struct ata_queued_cmd *qc)
+{
+	if (unlikely(qc->flags & ATA_QCFLAG_EH_SCHEDULED))
+		return;
+
+	__ata_qc_complete(qc);
+}
 
 /**
  *	ata_irq_on - Enable interrupts on a port.

commit ca7d5e42d783e54f0057317c9226262d68ab7717
Merge: a0819750024a cc9278ed5e99
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Fri Feb 10 07:09:37 2006 -0500

    Merge branch 'upstream'

commit f29841e08fa20a7f2c8bc1b70306975299c66ee7
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Feb 10 15:10:48 2006 +0900

    [PATCH] libata: implement ata_scsi_timed_out()
    
    Implement ata_scsi_timed_out(), to be used as
    scsi_host_template->eh_timed_out callback for all libata drivers.
    Without this function, the following race exists.
    
    If a qc completes after SCSI timer expires but before libata EH kicks
    in, the qc gets completed but the scsicmd still gets passed to libata
    EH resulting in ->eng_timeout invocation with NULL qc, which none is
    handling properly.
    
    This patch makes sure that scmd and qc share the same lifetime.
    Original idea from Jeff Garzik <jgarzik@pobox.com>.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 5c70a57f93ee..c1e198655bb1 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -509,6 +509,7 @@ extern void ata_host_set_remove(struct ata_host_set *host_set);
 extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
 extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));
+extern enum scsi_eh_timer_return ata_scsi_timed_out(struct scsi_cmnd *cmd);
 extern int ata_scsi_error(struct Scsi_Host *host);
 extern void ata_eh_qc_complete(struct ata_queued_cmd *qc);
 extern void ata_eh_qc_retry(struct ata_queued_cmd *qc);

commit 341963b909a01d2f38d86f5db8dd1f8c80bd6dbf
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Feb 10 15:10:48 2006 +0900

    [PATCH] libata: add ATA_QCFLAG_EH_SCHEDULED
    
    Add ATA_QCFLAG_EH_SCHEDULED.  If this flag is set, the qc is owned by
    EH and normal completion path is not allowed to finish it.  This patch
    doesn't actually use this flag.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 68b3fe6f9a4d..5c70a57f93ee 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -169,6 +169,7 @@ enum {
 	ATA_QCFLAG_SG		= (1 << 3), /* have s/g table? */
 	ATA_QCFLAG_SINGLE	= (1 << 4), /* no s/g, just a single buffer */
 	ATA_QCFLAG_DMAMAP	= ATA_QCFLAG_SG | ATA_QCFLAG_SINGLE,
+	ATA_QCFLAG_EH_SCHEDULED = (1 << 5), /* EH scheduled */
 
 	/* various lengths of time */
 	ATA_TMOUT_EDD		= 5 * HZ,	/* heuristic */

commit 99b3738fbf17208ac474420fa6b7e4b0c0c2b9ed
Merge: 332b5a52f2f9 8a19ac89edbe
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Thu Feb 9 04:28:13 2006 -0500

    Merge branch 'upstream'

commit 8a19ac89edbe9b702c10fd2039b8cb2db4644a5f
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Feb 2 18:20:00 2006 +0900

    [PATCH] libata: implement ata_std_probeinit()
    
    This patch implements the off-the-shelf probeinit component operation.
    Currently, all it does is waking up the PHY if it's a SATA port.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index e8f29cefc351..68b3fe6f9a4d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -488,6 +488,7 @@ extern int ata_drive_probe_reset(struct ata_port *ap,
 			ata_probeinit_fn_t probeinit,
 			ata_reset_fn_t softreset, ata_reset_fn_t hardreset,
 			ata_postreset_fn_t postreset, unsigned int *classes);
+extern void ata_std_probeinit(struct ata_port *ap);
 extern int ata_std_softreset(struct ata_port *ap, int verbose,
 			     unsigned int *classes);
 extern int sata_std_hardreset(struct ata_port *ap, int verbose,

commit 7944ea9522ce0ea32d57894b3dc2540b0bdca66e
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Feb 2 18:20:00 2006 +0900

    [PATCH] libata: add probeinit component operation to ata_drive_probe_reset()
    
    This patch adds probeinit component operation to
    ata_drive_probe_reset().  If present, this new operation is called
    before performing any reset.  The operations's roll is to prepare @ap
    for following probe-reset operations.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index f4cd1eb734a0..e8f29cefc351 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -244,6 +244,7 @@ struct ata_queued_cmd;
 
 /* typedefs */
 typedef void (*ata_qc_cb_t) (struct ata_queued_cmd *qc);
+typedef void (*ata_probeinit_fn_t)(struct ata_port *);
 typedef int (*ata_reset_fn_t)(struct ata_port *, int, unsigned int *);
 typedef void (*ata_postreset_fn_t)(struct ata_port *ap, unsigned int *);
 
@@ -484,6 +485,7 @@ extern void __sata_phy_reset(struct ata_port *ap);
 extern void sata_phy_reset(struct ata_port *ap);
 extern void ata_bus_reset(struct ata_port *ap);
 extern int ata_drive_probe_reset(struct ata_port *ap,
+			ata_probeinit_fn_t probeinit,
 			ata_reset_fn_t softreset, ata_reset_fn_t hardreset,
 			ata_postreset_fn_t postreset, unsigned int *classes);
 extern int ata_std_softreset(struct ata_port *ap, int verbose,

commit c18d06f89fd09ee0059c4899e615c471d59af66a
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Feb 2 00:56:10 2006 +0900

    [PATCH] libata: EH / pio tasks synchronization
    
    This patch makes sure that pio tasks are flushed before proceeding
    with EH.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 55176df403a5..f4cd1eb734a0 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -162,7 +162,8 @@ enum {
 	ATA_FLAG_PIO_LBA48	= (1 << 13), /* Host DMA engine is LBA28 only */
 	ATA_FLAG_IRQ_MASK	= (1 << 14), /* Mask IRQ in PIO xfers */
 
-	ATA_FLAG_IN_EH		= (1 << 15), /* EH in progress */
+	ATA_FLAG_FLUSH_PIO_TASK	= (1 << 15), /* Flush PIO task */
+	ATA_FLAG_IN_EH		= (1 << 16), /* EH in progress */
 
 	ATA_QCFLAG_ACTIVE	= (1 << 1), /* cmd not yet ack'd to scsi lyer */
 	ATA_QCFLAG_SG		= (1 << 3), /* have s/g table? */

commit dde44589bf9fac0168c6ce6d097c99c33b18074f
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Feb 2 00:56:10 2006 +0900

    [PATCH] libata: implement ATA_FLAG_IN_EH port flag
    
    ATA_FLAG_IN_EH flag is set on entry to EH and cleared on completion.
    This patch just sets and clears the flag.  Following patches will
    build normal qc execution / EH synchronization aroung this flag.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 474cdfa35d1e..55176df403a5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -162,6 +162,8 @@ enum {
 	ATA_FLAG_PIO_LBA48	= (1 << 13), /* Host DMA engine is LBA28 only */
 	ATA_FLAG_IRQ_MASK	= (1 << 14), /* Mask IRQ in PIO xfers */
 
+	ATA_FLAG_IN_EH		= (1 << 15), /* EH in progress */
+
 	ATA_QCFLAG_ACTIVE	= (1 << 1), /* cmd not yet ack'd to scsi lyer */
 	ATA_QCFLAG_SG		= (1 << 3), /* have s/g table? */
 	ATA_QCFLAG_SINGLE	= (1 << 4), /* no s/g, just a single buffer */

commit c2bd58047b9b5c91a3b0a851de66a877f2eb7ae3
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Jan 24 17:05:22 2006 +0900

    [PATCH] libata: implement standard reset component operations and ->probe_reset
    
    Implement SRST, COMRESET and standard postreset component operations
    for ata_drive_probe_reset(), and use these three functions to
    implement ata_std_probe_reset.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 38e08ce2d1af..474cdfa35d1e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -483,6 +483,11 @@ extern void ata_bus_reset(struct ata_port *ap);
 extern int ata_drive_probe_reset(struct ata_port *ap,
 			ata_reset_fn_t softreset, ata_reset_fn_t hardreset,
 			ata_postreset_fn_t postreset, unsigned int *classes);
+extern int ata_std_softreset(struct ata_port *ap, int verbose,
+			     unsigned int *classes);
+extern int sata_std_hardreset(struct ata_port *ap, int verbose,
+			      unsigned int *class);
+extern void ata_std_postreset(struct ata_port *ap, unsigned int *classes);
 extern void ata_port_disable(struct ata_port *);
 extern void ata_std_ports(struct ata_ioports *ioaddr);
 #ifdef CONFIG_PCI
@@ -523,6 +528,7 @@ extern void ata_std_dev_select (struct ata_port *ap, unsigned int device);
 extern u8 ata_check_status(struct ata_port *ap);
 extern u8 ata_altstatus(struct ata_port *ap);
 extern void ata_exec_command(struct ata_port *ap, const struct ata_taskfile *tf);
+extern int ata_std_probe_reset(struct ata_port *ap, unsigned int *classes);
 extern int ata_port_start (struct ata_port *ap);
 extern void ata_port_stop (struct ata_port *ap);
 extern void ata_host_stop (struct ata_host_set *host_set);

commit a62c0fc526c344d8163f7a9e45e68cc63826ffd3
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Jan 24 17:05:22 2006 +0900

    [PATCH] libata: implement ata_drive_probe_reset()
    
    Most low level drivers share supported reset/classify actions and
    sequence.  This patch implements ata_drive_probe_reset() which helps
    constructing ->probe_reset from three component operations -
    softreset, hardreset and postreset.  This minimizes duplicate code and
    yet allows flexibility if needed. The three component operations can
    also be shared by EH later.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a84d1c3a5429..38e08ce2d1af 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -241,6 +241,8 @@ struct ata_queued_cmd;
 
 /* typedefs */
 typedef void (*ata_qc_cb_t) (struct ata_queued_cmd *qc);
+typedef int (*ata_reset_fn_t)(struct ata_port *, int, unsigned int *);
+typedef void (*ata_postreset_fn_t)(struct ata_port *ap, unsigned int *);
 
 struct ata_ioports {
 	unsigned long		cmd_addr;
@@ -478,6 +480,9 @@ extern void ata_port_probe(struct ata_port *);
 extern void __sata_phy_reset(struct ata_port *ap);
 extern void sata_phy_reset(struct ata_port *ap);
 extern void ata_bus_reset(struct ata_port *ap);
+extern int ata_drive_probe_reset(struct ata_port *ap,
+			ata_reset_fn_t softreset, ata_reset_fn_t hardreset,
+			ata_postreset_fn_t postreset, unsigned int *classes);
 extern void ata_port_disable(struct ata_port *);
 extern void ata_std_ports(struct ata_ioports *ioaddr);
 #ifdef CONFIG_PCI

commit f6ef65e6d004b77d516037424c7ccc209d0d3509
Merge: 7103c7bc863c c19ba8af4f10
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Fri Jan 27 02:45:00 2006 -0500

    Merge branch 'upstream-2.6.17'

commit 7103c7bc863c10dd2a26c19c8cf4d7d2846da947
Merge: b4d28889f7eb a72ec4ce6d3a
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Fri Jan 27 02:39:25 2006 -0500

    Merge branch 'tmp'

commit b4d28889f7ebfe498dedaceb773b4c785b97d195
Merge: 7dfb869c8e45 041c5fc33cb7
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Fri Jan 27 02:37:46 2006 -0500

    Merge branch 'tmp'

commit 7dfb869c8e45e5863534f38fdac990829b22964a
Merge: 628e386e2767 11a56d243925
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Fri Jan 27 02:36:14 2006 -0500

    Merge branch 'tmp'

commit 628e386e27674906326455f01d87878a5f0cbce7
Merge: 8dd2e3bd57c3 77853bf2b48e
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Fri Jan 27 02:29:20 2006 -0500

    Merge branch 'tmp'

commit 8dd2e3bd57c3b389febba1de6b10372ef507f985
Merge: 2af5920b81a4 71e834f56379
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Fri Jan 27 02:26:46 2006 -0500

    Merge branch 'tmp'

commit 2af5920b81a4cd0a22d40b6b2c38356d3df03e13
Merge: 000080c3499c 3ee68c4af3fd
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Fri Jan 27 02:20:42 2006 -0500

    Merge branch 'master'

commit c19ba8af4f104cca28d548cac55c128b28dd31fb
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Jan 24 17:05:22 2006 +0900

    [PATCH] libata: new ->probe_reset operation
    
    Add new ->probe_reset operation to ata_port_operations obsoleting
    ->phy_reset.  The main difference from ->phy_reset is that the new
    operation is not allowed to manipulate libata internals directly.
    It's not allowed to configure or disable the port or devices.  It can
    only succeed or fail and classify attached devices into passed
    @classes.
    
    This change gives more control to higher level and eases sharing reset
    methods with EH.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 45646f6ebbf5..a84d1c3a5429 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -148,9 +148,9 @@ enum {
 	ATA_FLAG_PORT_DISABLED	= (1 << 2), /* port is disabled, ignore it */
 	ATA_FLAG_SATA		= (1 << 3),
 	ATA_FLAG_NO_LEGACY	= (1 << 4), /* no legacy mode check */
-	ATA_FLAG_SRST		= (1 << 5), /* use ATA SRST, not E.D.D. */
+	ATA_FLAG_SRST		= (1 << 5), /* (obsolete) use ATA SRST, not E.D.D. */
 	ATA_FLAG_MMIO		= (1 << 6), /* use MMIO, not PIO */
-	ATA_FLAG_SATA_RESET	= (1 << 7), /* use COMRESET */
+	ATA_FLAG_SATA_RESET	= (1 << 7), /* (obsolete) use COMRESET */
 	ATA_FLAG_PIO_DMA	= (1 << 8), /* PIO cmds via DMA */
 	ATA_FLAG_NOINTR		= (1 << 9), /* FIXME: Remove this once
 					     * proper HSM is in place. */
@@ -419,7 +419,9 @@ struct ata_port_operations {
 	u8   (*check_altstatus)(struct ata_port *ap);
 	void (*dev_select)(struct ata_port *ap, unsigned int device);
 
-	void (*phy_reset) (struct ata_port *ap);
+	void (*phy_reset) (struct ata_port *ap); /* obsolete */
+	int (*probe_reset) (struct ata_port *ap, unsigned int *classes);
+
 	void (*post_set_mode) (struct ata_port *ap);
 
 	int (*check_atapi_dma) (struct ata_queued_cmd *qc);

commit 6f8b99589524f3e759e44721376abcdf88ed8915
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Jan 24 17:05:21 2006 +0900

    [PATCH] libata: export ata_busy_sleep
    
    Export ata_busy_sleep(), to be used by low level driver reset functions.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 576788de962a..45646f6ebbf5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -500,6 +500,9 @@ extern int ata_scsi_device_suspend(struct scsi_device *);
 extern int ata_device_resume(struct ata_port *, struct ata_device *);
 extern int ata_device_suspend(struct ata_port *, struct ata_device *);
 extern int ata_ratelimit(void);
+extern unsigned int ata_busy_sleep(struct ata_port *ap,
+				   unsigned long timeout_pat,
+				   unsigned long timeout);
 
 /*
  * Default driver ops implementations

commit a72ec4ce6d3ae92e76baf5b2c65cc26e5e775e83
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jan 23 13:09:37 2006 +0900

    [PATCH] libata: implement and apply ata_eh_qc_complete/retry()
    
    Implement ata_eh_qc_complete/retry() using scsi_eh_finish_cmd() and
    scsi_eh_flush_done_q().  This removes all eh scsicmd finish hacks from
    low level drivers.
    
    This change was first suggested by Jeff Garzik.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index b1ea2f98bfbb..576788de962a 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -398,6 +398,7 @@ struct ata_port {
 	unsigned long		pio_task_timeout;
 
 	u32			msg_enable;
+	struct list_head	eh_done_q;
 
 	void			*private_data;
 };
@@ -490,6 +491,8 @@ extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
 extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));
 extern int ata_scsi_error(struct Scsi_Host *host);
+extern void ata_eh_qc_complete(struct ata_queued_cmd *qc);
+extern void ata_eh_qc_retry(struct ata_queued_cmd *qc);
 extern int ata_scsi_release(struct Scsi_Host *host);
 extern unsigned int ata_host_intr(struct ata_port *ap, struct ata_queued_cmd *qc);
 extern int ata_scsi_device_resume(struct scsi_device *);

commit 11a56d2439259892319df81cf1582687d7e7fde5
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jan 23 13:09:36 2006 +0900

    [PATCH] libata: add detailed AC_ERR_* flags
    
    Add detailed AC_ERR_* flags and use them.  Long-term goal is to
    describe all errors with err_mask and tf combination (tf for failed
    sector information, etc...).  After proper error diagnosis is
    implemented, sense data should also be generated from err_mask instead
    of directly from hardware tf registers as it is currently.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d58b659cf3f5..8ff3a7f6f63c 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -222,10 +222,15 @@ enum hsm_task_states {
 };
 
 enum ata_completion_errors {
-	AC_ERR_OTHER		= (1 << 0),
-	AC_ERR_DEV		= (1 << 1),
-	AC_ERR_ATA_BUS		= (1 << 2),
-	AC_ERR_HOST_BUS		= (1 << 3),
+	AC_ERR_DEV		= (1 << 0), /* device reported error */
+	AC_ERR_HSM		= (1 << 1), /* host state machine violation */
+	AC_ERR_TIMEOUT		= (1 << 2), /* timeout */
+	AC_ERR_MEDIA		= (1 << 3), /* media error */
+	AC_ERR_ATA_BUS		= (1 << 4), /* ATA bus error */
+	AC_ERR_HOST_BUS		= (1 << 5), /* host bus error */
+	AC_ERR_SYSTEM		= (1 << 6), /* system error */
+	AC_ERR_INVALID		= (1 << 7), /* invalid argument */
+	AC_ERR_OTHER		= (1 << 8), /* unknown */
 };
 
 /* forward declarations */
@@ -833,7 +838,7 @@ static inline int ata_try_flush_cache(const struct ata_device *dev)
 static inline unsigned int ac_err_mask(u8 status)
 {
 	if (status & ATA_BUSY)
-		return AC_ERR_ATA_BUS;
+		return AC_ERR_HSM;
 	if (status & (ATA_ERR | ATA_DF))
 		return AC_ERR_DEV;
 	return 0;

commit 9a3d9eb0177eb10500d49cd283b35576082a522d
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jan 23 13:09:36 2006 +0900

    [PATCH] libata: return AC_ERR_* from issue functions
    
    Return AC_ERR_* mask from issue fuctions instead of 0/-1.  This
    enables things like failing a qc with AC_ERR_HSM when the device
    doesn't set DRDY when the qc is about to be issued.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 8ff3a7f6f63c..b1ea2f98bfbb 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -427,7 +427,7 @@ struct ata_port_operations {
 	void (*bmdma_start) (struct ata_queued_cmd *qc);
 
 	void (*qc_prep) (struct ata_queued_cmd *qc);
-	int (*qc_issue) (struct ata_queued_cmd *qc);
+	unsigned int (*qc_issue) (struct ata_queued_cmd *qc);
 
 	void (*eng_timeout) (struct ata_port *ap);
 
@@ -515,7 +515,7 @@ extern void ata_port_stop (struct ata_port *ap);
 extern void ata_host_stop (struct ata_host_set *host_set);
 extern irqreturn_t ata_interrupt (int irq, void *dev_instance, struct pt_regs *regs);
 extern void ata_qc_prep(struct ata_queued_cmd *qc);
-extern int ata_qc_issue_prot(struct ata_queued_cmd *qc);
+extern unsigned int ata_qc_issue_prot(struct ata_queued_cmd *qc);
 extern void ata_sg_init_one(struct ata_queued_cmd *qc, void *buf,
 		unsigned int buflen);
 extern void ata_sg_init(struct ata_queued_cmd *qc, struct scatterlist *sg,

commit 77853bf2b48e34449e826a9ef4df5ea0dbe947f4
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jan 23 13:09:36 2006 +0900

    [PATCH] libata: make the owner of a qc responsible for freeing it
    
    qc used to be freed automatically on command completion.  However, as
    a qc can carry information about its completion status, it can be
    useful to its owner/issuer after command completion.  This patch makes
    freeing qc responsibility of its owner.  This simplifies
    ata_exec_internal() and makes command turn-around for atapi request
    sensing less hackish.
    
    This change was originally suggested by Jeff Garzik.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 46ccea215892..d58b659cf3f5 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -235,7 +235,7 @@ struct ata_port;
 struct ata_queued_cmd;
 
 /* typedefs */
-typedef int (*ata_qc_cb_t) (struct ata_queued_cmd *qc);
+typedef void (*ata_qc_cb_t) (struct ata_queued_cmd *qc);
 
 struct ata_ioports {
 	unsigned long		cmd_addr;

commit 8a6d498e864aa3d1ae21fce650452dd13a305769
Merge: a1bd9e685732 bfd6057959ec
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Tue Jan 17 19:46:27 2006 -0500

    Merge branch 'debug'

commit 8d238e012469a9a332c78d6a69a8a46ac4b1e9c2
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Tue Jan 17 20:50:31 2006 +0000

    [PATCH] libata: Fix heuristic typos add LBA48PIO flag and support code, add IRQ flag for next diff
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index af6624450f65..9e5db2949c58 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -126,16 +126,19 @@ enum {
 
 	ATA_FLAG_SUSPENDED	= (1 << 12), /* port is suspended */
 
+	ATA_FLAG_PIO_LBA48	= (1 << 13), /* Host DMA engine is LBA28 only */
+	ATA_FLAG_IRQ_MASK	= (1 << 14), /* Mask IRQ in PIO xfers */
+
 	ATA_QCFLAG_ACTIVE	= (1 << 1), /* cmd not yet ack'd to scsi lyer */
 	ATA_QCFLAG_SG		= (1 << 3), /* have s/g table? */
 	ATA_QCFLAG_SINGLE	= (1 << 4), /* no s/g, just a single buffer */
 	ATA_QCFLAG_DMAMAP	= ATA_QCFLAG_SG | ATA_QCFLAG_SINGLE,
 
 	/* various lengths of time */
-	ATA_TMOUT_EDD		= 5 * HZ,	/* hueristic */
+	ATA_TMOUT_EDD		= 5 * HZ,	/* heuristic */
 	ATA_TMOUT_PIO		= 30 * HZ,
-	ATA_TMOUT_BOOT		= 30 * HZ,	/* hueristic */
-	ATA_TMOUT_BOOT_QUICK	= 7 * HZ,	/* hueristic */
+	ATA_TMOUT_BOOT		= 30 * HZ,	/* heuristic */
+	ATA_TMOUT_BOOT_QUICK	= 7 * HZ,	/* heuristic */
 	ATA_TMOUT_CDB		= 30 * HZ,
 	ATA_TMOUT_CDB_QUICK	= 5 * HZ,
 	ATA_TMOUT_INTERNAL	= 30 * HZ,

commit bfd6057959ecd3ff779a373a4d07cda2c2d0eec1
Author: Randy Dunlap <randy_d_dunlap@linux.intel.com>
Date:   Tue Jan 17 19:34:42 2006 -0500

    From: Borislav Petkov <petkov@uni-muenster.de>
    
    libata new debugging macro definitions
    
    Signed-off-by: Borislav Petkov <petkov@uni-muenster.de>
    Signed-off-by: Randy Dunlap <randy_d_dunlap@linux.intel.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a43c95f8f968..339f7e75cb60 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -35,7 +35,8 @@
 #include <linux/workqueue.h>
 
 /*
- * compile-time options
+ * compile-time options: to be removed as soon as all the drivers are
+ * converted to the new debugging mechanism
  */
 #undef ATA_DEBUG		/* debugging output */
 #undef ATA_VERBOSE_DEBUG	/* yet more debugging output */
@@ -71,6 +72,38 @@
         }
 #endif
 
+/* NEW: debug levels */
+#define HAVE_LIBATA_MSG 1
+
+enum {
+	ATA_MSG_DRV	= 0x0001,
+	ATA_MSG_INFO	= 0x0002,
+	ATA_MSG_PROBE	= 0x0004,
+	ATA_MSG_WARN	= 0x0008,
+	ATA_MSG_MALLOC	= 0x0010,
+	ATA_MSG_CTL	= 0x0020,
+	ATA_MSG_INTR	= 0x0040,
+	ATA_MSG_ERR	= 0x0080,
+};
+
+#define ata_msg_drv(p)    ((p)->msg_enable & ATA_MSG_DRV)
+#define ata_msg_info(p)   ((p)->msg_enable & ATA_MSG_INFO)
+#define ata_msg_probe(p)  ((p)->msg_enable & ATA_MSG_PROBE)
+#define ata_msg_warn(p)   ((p)->msg_enable & ATA_MSG_WARN)
+#define ata_msg_malloc(p) ((p)->msg_enable & ATA_MSG_MALLOC)
+#define ata_msg_ctl(p)    ((p)->msg_enable & ATA_MSG_CTL)
+#define ata_msg_intr(p)   ((p)->msg_enable & ATA_MSG_INTR)
+#define ata_msg_err(p)    ((p)->msg_enable & ATA_MSG_ERR)
+
+static inline u32 ata_msg_init(int dval, int default_msg_enable_bits)
+{
+	if (dval < 0 || dval >= (sizeof(u32) * 8))
+		return default_msg_enable_bits; /* should be 0x1 - only driver info msgs */
+	if (!dval)
+		return 0;
+	return (1 << dval) - 1;
+}
+
 /* defines only for the constants which don't work well as enums */
 #define ATA_TAG_POISON		0xfafbfcfdU
 
@@ -356,6 +389,8 @@ struct ata_port {
 	unsigned int		hsm_task_state;
 	unsigned long		pio_task_timeout;
 
+	u32			msg_enable;
+
 	void			*private_data;
 };
 
@@ -640,9 +675,9 @@ static inline u8 ata_wait_idle(struct ata_port *ap)
 
 	if (status & (ATA_BUSY | ATA_DRQ)) {
 		unsigned long l = ap->ioaddr.status_addr;
-		printk(KERN_WARNING
-		       "ATA: abnormal status 0x%X on port 0x%lX\n",
-		       status, l);
+		if (ata_msg_warn(ap))
+			printk(KERN_WARNING "ATA: abnormal status 0x%X on port 0x%lX\n",
+				status, l);
 	}
 
 	return status;
@@ -734,7 +769,8 @@ static inline u8 ata_irq_ack(struct ata_port *ap, unsigned int chk_drq)
 
 	status = ata_busy_wait(ap, bits, 1000);
 	if (status & bits)
-		DPRINTK("abnormal status 0x%X\n", status);
+		if (ata_msg_err(ap))
+			printk(KERN_ERR "abnormal status 0x%X\n", status);
 
 	/* get controller status; clear intr, err bits */
 	if (ap->flags & ATA_FLAG_MMIO) {
@@ -752,8 +788,10 @@ static inline u8 ata_irq_ack(struct ata_port *ap, unsigned int chk_drq)
 		post_stat = inb(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
 	}
 
-	VPRINTK("irq ack: host_stat 0x%X, new host_stat 0x%X, drv_stat 0x%X\n",
-		host_stat, post_stat, status);
+	if (ata_msg_intr(ap))
+		printk(KERN_INFO "%s: irq ack: host_stat 0x%X, new host_stat 0x%X, drv_stat 0x%X\n",
+			__FUNCTION__,
+			host_stat, post_stat, status);
 
 	return status;
 }

commit ea9b395fe20ac74be788f415af2622ac8f0c35c7
Merge: 61420e147a70 1bc4ccfff867
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Tue Jan 17 10:29:06 2006 -0500

    Merge branch 'upstream'

commit 1bc4ccfff8675adc3d96f91245eb7e2dc0043ca9
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Jan 9 17:18:14 2006 +0000

    [PATCH] libata: add a function to decide if we need iordy
    
    This ought to be simple but for PIO2 we have to poke around the drive
    data to get it 100% correct.
    
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a43c95f8f968..af6624450f65 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -499,6 +499,8 @@ extern int ata_scsi_slave_config(struct scsi_device *sdev);
 /*
  * Timing helpers
  */
+
+extern unsigned int ata_pio_need_iordy(const struct ata_device *);
 extern int ata_timing_compute(struct ata_device *, unsigned short,
 			      struct ata_timing *, int, int);
 extern void ata_timing_merge(const struct ata_timing *,

commit d99cf9d679a520d67f81d805b7cb91c68e1847f0
Merge: 7ed40918a386 e650c305ec31
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Fri Jan 6 09:01:25 2006 -0800

    Merge branch 'post-2.6.15' of git://brick.kernel.dk/data/git/linux-2.6-block
    
    Manual fixup for merge with Jens' "Suspend support for libata", commit
    ID 9b847548663ef1039dd49f0eb4463d001e596bc3.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit 9b847548663ef1039dd49f0eb4463d001e596bc3
Author: Jens Axboe <axboe@suse.de>
Date:   Fri Jan 6 09:28:07 2006 +0100

    [PATCH] Suspend support for libata
    
    This patch adds suspend patch to libata, and ata_piix in particular. For
    most low level drivers, they should just need to add the 4 hooks to
    work. As I can only test ata_piix, I didn't enable it for more
    though.
    
    Suspend support is the single most important feature on a notebook, and
    most new notebooks have sata drives. It's quite embarrassing that we
    _still_ do not support this. Right now, it's perfectly possible to
    suspend the drive in mid-transfer.
    
    Signed-off-by: Jens Axboe <axboe@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index e828e172ccbf..cdab75c209a0 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -124,6 +124,8 @@ enum {
 	ATA_FLAG_DEBUGMSG	= (1 << 10),
 	ATA_FLAG_NO_ATAPI	= (1 << 11), /* No ATAPI support */
 
+	ATA_FLAG_SUSPENDED	= (1 << 12), /* port is suspended */
+
 	ATA_QCFLAG_ACTIVE	= (1 << 1), /* cmd not yet ack'd to scsi lyer */
 	ATA_QCFLAG_SG		= (1 << 3), /* have s/g table? */
 	ATA_QCFLAG_SINGLE	= (1 << 4), /* no s/g, just a single buffer */
@@ -436,6 +438,8 @@ extern void ata_std_ports(struct ata_ioports *ioaddr);
 extern int ata_pci_init_one (struct pci_dev *pdev, struct ata_port_info **port_info,
 			     unsigned int n_ports);
 extern void ata_pci_remove_one (struct pci_dev *pdev);
+extern int ata_pci_device_suspend(struct pci_dev *pdev, pm_message_t state);
+extern int ata_pci_device_resume(struct pci_dev *pdev);
 #endif /* CONFIG_PCI */
 extern int ata_device_add(const struct ata_probe_ent *ent);
 extern void ata_host_set_remove(struct ata_host_set *host_set);
@@ -445,6 +449,10 @@ extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmn
 extern int ata_scsi_error(struct Scsi_Host *host);
 extern int ata_scsi_release(struct Scsi_Host *host);
 extern unsigned int ata_host_intr(struct ata_port *ap, struct ata_queued_cmd *qc);
+extern int ata_scsi_device_resume(struct scsi_device *);
+extern int ata_scsi_device_suspend(struct scsi_device *);
+extern int ata_device_resume(struct ata_port *, struct ata_device *);
+extern int ata_device_suspend(struct ata_port *, struct ata_device *);
 extern int ata_ratelimit(void);
 
 /*

commit 9a3dccc42556537a48f39ee9a9e7ab90a933f766
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Jan 6 09:56:18 2006 +0100

    [BLOCK] add FUA support to libata
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jens Axboe <axboe@suse.de>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index e828e172ccbf..6db2c0845731 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -480,7 +480,8 @@ extern u8   ata_bmdma_status(struct ata_port *ap);
 extern void ata_bmdma_irq_clear(struct ata_port *ap);
 extern void ata_qc_complete(struct ata_queued_cmd *qc);
 extern void ata_eng_timeout(struct ata_port *ap);
-extern void ata_scsi_simulate(u16 *id, struct scsi_cmnd *cmd,
+extern void ata_scsi_simulate(struct ata_port *ap, struct ata_device *dev,
+			      struct scsi_cmnd *cmd,
 			      void (*done)(struct scsi_cmnd *));
 extern int ata_std_bios_param(struct scsi_device *sdev,
 			      struct block_device *bdev,

commit e8b09428482deff1a9d7a36d371acee364182ec3
Merge: d1397f837647 e508a391a070
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Tue Dec 13 02:32:01 2005 -0500

    Merge branch 'upstream'

commit e508a391a0705f770ef1c4f1c304678b0e8e4fe8
Merge: d00d598ffbba 50630195bbdf
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Tue Dec 13 02:30:04 2005 -0500

    Merge branch 'upstream-fixes'

commit 50630195bbdfe1ca775d94cd68a5f18bc1b717e4
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Tue Dec 13 02:29:45 2005 -0500

    [libata] mark certain hardware (or drivers) with a no-atapi flag
    
    Some hardware does not support the PACKET command at all.
    Other hardware supports ATAPI, but the driver does something nasty such
    as calling BUG() when an ATAPI command is issued.
    
    For these such cases, we mark them with a new flag, ATA_FLAG_NO_ATAPI.
    
    Initial version contributed by Ben Collins.

diff --git a/include/linux/libata.h b/include/linux/libata.h
index f2dbb684ce9e..41ea7dbc1755 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -122,6 +122,7 @@ enum {
 	ATA_FLAG_NOINTR		= (1 << 9), /* FIXME: Remove this once
 					     * proper HSM is in place. */
 	ATA_FLAG_DEBUGMSG	= (1 << 10),
+	ATA_FLAG_NO_ATAPI	= (1 << 11), /* No ATAPI support */
 
 	ATA_QCFLAG_ACTIVE	= (1 << 1), /* cmd not yet ack'd to scsi lyer */
 	ATA_QCFLAG_SG		= (1 << 3), /* have s/g table? */

commit d1397f837647d8b6b3c9253a7e713d203f3cbb26
Merge: 278efe950988 d00d598ffbba
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Tue Dec 13 01:47:05 2005 -0500

    Merge branch 'upstream'

commit b5632303401c231bf270ef36f1013e52caf4caf9
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Dec 13 14:51:25 2005 +0900

    [PATCH] libata: remove unused qc->waiting
    
    There is no user of qc->waiting left after ata_exec_internal()
    changes.  Kill the field.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 833e57afd54c..46337e71613e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -285,8 +285,6 @@ struct ata_queued_cmd {
 
 	ata_qc_cb_t		complete_fn;
 
-	struct completion	*waiting;
-
 	void			*private_data;
 };
 

commit a2a7a662f80d8b7f2295a36de1f9b033ed0b910c
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Dec 13 14:48:31 2005 +0900

    [PATCH] libata: implement ata_exec_internal()
    
    This patch implements ata_exec_internal() function which performs
    libata internal command execution.  Previously, this was done by each
    user by manually initializing a qc, issueing it, waiting for its
    completion and handling errors.  In addition to obvious code
    factoring, using ata_exec_internal() fixes the following bugs.
    
    * qc not freed on issue failure
    * ap->qactive clearing could race with the next internal command
    * race between timeout handling and irq
    * ignoring error condition not represented in tf->status
    
    Also, qc & hardware are not accessed anymore once it's completed,
    making internal commands more conformant with general semantics.
    ata_exec_internal() also makes it easy to issue internal commands from
    multiple threads if that becomes necessary.
    
    This patch only implements ata_exec_internal().  A following patch
    will convert all users.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    
    --
    
    Jeff, all patches have been regenerated against upstream branch as of
    today.  (575ab52a218e4ff0667a6cbd972c3af443ee8713)
    
    Also, I took out a debug printk from ata_exec_internal (don't know how
    that one got left there).  Other than that, all patches are identical
    to the previous posting.
    
    Thanks. :-)
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index e18ce039cdfd..833e57afd54c 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -135,6 +135,8 @@ enum {
 	ATA_TMOUT_BOOT_QUICK	= 7 * HZ,	/* hueristic */
 	ATA_TMOUT_CDB		= 30 * HZ,
 	ATA_TMOUT_CDB_QUICK	= 5 * HZ,
+	ATA_TMOUT_INTERNAL	= 30 * HZ,
+	ATA_TMOUT_INTERNAL_QUICK = 5 * HZ,
 
 	/* ATA bus states */
 	BUS_UNKNOWN		= 0,

commit 701db69d6647f61e4660c9102d7f2fd5dffc203d
Merge: 6cf5bcaaf9a9 fe79e683ccdb
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Tue Dec 6 04:52:48 2005 -0500

    Merge branch 'upstream'

commit a22e2eb0710798009b8e696ae911aef745089dd6
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Mon Dec 5 15:38:02 2005 +0800

    [PATCH] libata: move err_mask to ata_queued_cmd
    
      - remove err_mask from the parameter list of the complete functions
      - move err_mask to ata_queued_cmd
      - initialize qc->err_mask when needed
      - for each function call to ata_qc_complete(), replace the err_mask parameter with qc->err_mask.
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    
    ===============
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 83a83babff84..e18ce039cdfd 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -194,7 +194,7 @@ struct ata_port;
 struct ata_queued_cmd;
 
 /* typedefs */
-typedef int (*ata_qc_cb_t) (struct ata_queued_cmd *qc, unsigned int err_mask);
+typedef int (*ata_qc_cb_t) (struct ata_queued_cmd *qc);
 
 struct ata_ioports {
 	unsigned long		cmd_addr;
@@ -279,6 +279,8 @@ struct ata_queued_cmd {
 	/* DO NOT iterate over __sg manually, use ata_for_each_sg() */
 	struct scatterlist	*__sg;
 
+	unsigned int		err_mask;
+
 	ata_qc_cb_t		complete_fn;
 
 	struct completion	*waiting;
@@ -475,7 +477,7 @@ extern void ata_bmdma_start (struct ata_queued_cmd *qc);
 extern void ata_bmdma_stop(struct ata_queued_cmd *qc);
 extern u8   ata_bmdma_status(struct ata_port *ap);
 extern void ata_bmdma_irq_clear(struct ata_port *ap);
-extern void ata_qc_complete(struct ata_queued_cmd *qc, unsigned int err_mask);
+extern void ata_qc_complete(struct ata_queued_cmd *qc);
 extern void ata_eng_timeout(struct ata_port *ap);
 extern void ata_scsi_simulate(u16 *id, struct scsi_cmnd *cmd,
 			      void (*done)(struct scsi_cmnd *));
@@ -667,6 +669,7 @@ static inline void ata_qc_reinit(struct ata_queued_cmd *qc)
 	qc->cursect = qc->cursg = qc->cursg_ofs = 0;
 	qc->nsect = 0;
 	qc->nbytes = qc->curbytes = 0;
+	qc->err_mask = 0;
 
 	ata_tf_init(qc->ap, &qc->tf, qc->dev->devno);
 }

commit f333b3f111e9db76109e304df8ee777ace7fbf86
Merge: f4256e301d98 79bfb0a98fdc
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Fri Nov 18 11:44:17 2005 -0500

    Merge branch 'upstream'

commit e74ac79956ecb56e71a398c57eb10fab8c58a562
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Nov 14 18:16:37 2005 -0500

    [libata] remove two unused fields from struct ata_port

diff --git a/include/linux/libata.h b/include/linux/libata.h
index f2dbb684ce9e..83a83babff84 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -330,8 +330,6 @@ struct ata_port {
 
 	u8			ctl;	/* cache of ATA control register */
 	u8			last_ctl;	/* Cache last written value */
-	unsigned int		bus_state;
-	unsigned int		port_state;
 	unsigned int		pio_mask;
 	unsigned int		mwdma_mask;
 	unsigned int		udma_mask;

commit 2c13b7cee045af689b36349c2bc6a9ed6e3d73fa
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Nov 14 14:14:16 2005 -0500

    [libata] minor fixes, new helpers
    
    - in ata_dev_identify(), don't assume that all devices are either
      ATA or ATAPI.  In the future, this code will see port multipliers
      and other devices.
    - make a debugging printk less verbose
    - add new helper ata_qc_reinit()
    - add new helper BPRINTK() and port flag ATA_FLAG_DEBUGMSG, for
      fine-grained debugging use.

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ad5996183ec2..f2dbb684ce9e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -59,6 +59,8 @@
 #define VPRINTK(fmt, args...)
 #endif	/* ATA_DEBUG */
 
+#define BPRINTK(fmt, args...) if (ap->flags & ATA_FLAG_DEBUGMSG) printk(KERN_ERR "%s: " fmt, __FUNCTION__, ## args)
+
 #ifdef ATA_NDEBUG
 #define assert(expr)
 #else
@@ -119,6 +121,7 @@ enum {
 	ATA_FLAG_PIO_DMA	= (1 << 8), /* PIO cmds via DMA */
 	ATA_FLAG_NOINTR		= (1 << 9), /* FIXME: Remove this once
 					     * proper HSM is in place. */
+	ATA_FLAG_DEBUGMSG	= (1 << 10),
 
 	ATA_QCFLAG_ACTIVE	= (1 << 1), /* cmd not yet ack'd to scsi lyer */
 	ATA_QCFLAG_SG		= (1 << 3), /* have s/g table? */
@@ -659,6 +662,17 @@ static inline void ata_tf_init(struct ata_port *ap, struct ata_taskfile *tf, uns
 		tf->device = ATA_DEVICE_OBS | ATA_DEV1;
 }
 
+static inline void ata_qc_reinit(struct ata_queued_cmd *qc)
+{
+	qc->__sg = NULL;
+	qc->flags = 0;
+	qc->cursect = qc->cursg = qc->cursg_ofs = 0;
+	qc->nsect = 0;
+	qc->nbytes = qc->curbytes = 0;
+
+	ata_tf_init(qc->ap, &qc->tf, qc->dev->devno);
+}
+
 
 /**
  *	ata_irq_on - Enable interrupts on a port.

commit f4256e301d9800b1e0276404cb01b3ac85b51067
Merge: fb2a26b9f8f5 cd52d1ee9a92
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Fri Nov 11 23:39:35 2005 -0500

    Merge branch 'master'

commit d72d6f1b5647258e83819b51f72fe37e2b7d7965
Merge: 33ddcbbfb1d9 8a87a0b63131
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Fri Nov 11 14:04:37 2005 -0800

    Merge master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-for-linus-2.6

commit e99f8b5efe78110e4af10f35ebf11feeef8f43b6
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Tue Nov 8 14:09:44 2005 +0000

    [PATCH] libata: propogate host private data from probe function
    
    This will let me chop the code size of several drivers right down. In
    many cases the actual private data is very useful and constant for a
    given host controller so being able to just pass it at probe time would
    be very useful indeed (eg with the via driver would could pass the udma
    clocking and reduce the code size, or with the AMD one the UDMA
    multiplier and the offset)
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a5390313c7b4..1464a7586de8 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -405,6 +405,7 @@ struct ata_port_info {
 	unsigned long		mwdma_mask;
 	unsigned long		udma_mask;
 	const struct ata_port_operations *port_ops;
+	void 			*private_data;
 };
 
 struct ata_timing {

commit 1c72d8d90da3b29540c3c281a3e0b743ee6b6f74
Author: Andrew Morton <akpm@osdl.org>
Date:   Thu Nov 10 16:21:38 2005 -0800

    [PATCH] libata.h needs dma-mapping.h
    
    On Alpha:
    
    include/linux/libata.h: In function `ata_pad_alloc':
    include/linux/libata.h:785: warning: implicit declaration of function `dma_alloc_coherent'
    include/linux/libata.h:786: warning: assignment makes pointer from integer without a cast
    include/linux/libata.h: In function `ata_pad_free':
    include/linux/libata.h:792: warning: implicit declaration of function `dma_free_coherent'
    
    (I have a decouple-some-header-files cleanup in -mm, so it's causing some
    fallout of this nature)
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6f0752219f64..a5390313c7b4 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -29,6 +29,7 @@
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/pci.h>
+#include <linux/dma-mapping.h>
 #include <asm/io.h>
 #include <linux/ata.h>
 #include <linux/workqueue.h>

commit d0be4a7d29ad0bd3ce2209dd9e46d410b632db59
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Oct 31 18:31:40 2005 +0100

    [SCSI] remove Scsi_Host_Template typedef
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index dcd17e7458ab..e8c93b15c58d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -214,7 +214,7 @@ struct ata_probe_ent {
 	struct list_head	node;
 	struct device 		*dev;
 	const struct ata_port_operations *port_ops;
-	Scsi_Host_Template	*sht;
+	struct scsi_host_template *sht;
 	struct ata_ioports	port[ATA_MAX_PORTS];
 	unsigned int		n_ports;
 	unsigned int		hard_port_no;
@@ -398,7 +398,7 @@ struct ata_port_operations {
 };
 
 struct ata_port_info {
-	Scsi_Host_Template	*sht;
+	struct scsi_host_template	*sht;
 	unsigned long		host_flags;
 	unsigned long		pio_mask;
 	unsigned long		mwdma_mask;
@@ -433,7 +433,7 @@ extern void ata_pci_remove_one (struct pci_dev *pdev);
 #endif /* CONFIG_PCI */
 extern int ata_device_add(const struct ata_probe_ent *ent);
 extern void ata_host_set_remove(struct ata_host_set *host_set);
-extern int ata_scsi_detect(Scsi_Host_Template *sht);
+extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
 extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));
 extern int ata_scsi_error(struct Scsi_Host *host);

commit e27486db89ef04d5df1727c52362fa3d50cff241
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Tue Nov 1 19:24:49 2005 +0800

    [PATCH] libata irq-pio: merge the ata_dataout_task workqueue with ata_pio_task workqueue
    
       - remove ap->dataout_task from struct ata_port
       - let ata_pio_task() handle the HSM_ST_FIRST state.
       - rename ata_dataout_task() to ata_pio_first_block()
       - replace the ata_dataout_task workqueue with ata_pio_task workqueue
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    
    ========
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ad0451dfee15..70ae140dbf23 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -346,8 +346,6 @@ struct ata_port {
 	struct ata_host_stats	stats;
 	struct ata_host_set	*host_set;
 
-	struct work_struct	dataout_task;
-
 	struct work_struct	pio_task;
 	unsigned int		hsm_task_state;
 	unsigned long		pio_task_timeout;

commit c7c6e9494cc9a4a5b1a2ca870ed4531ad2b98a83
Merge: 8cedcfd43a0b 8e8b77dd4846
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Wed Nov 9 01:20:26 2005 -0500

    Merge branch 'upstream'

commit 193515d51ccb363165d6b09e9ba5c21089e34bad
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Nov 7 00:59:37 2005 -0500

    [libata] eliminate use of drivers/scsi/scsi.h compatibility header/defines

diff --git a/include/linux/libata.h b/include/linux/libata.h
index dcd17e7458ab..6f0752219f64 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -214,7 +214,7 @@ struct ata_probe_ent {
 	struct list_head	node;
 	struct device 		*dev;
 	const struct ata_port_operations *port_ops;
-	Scsi_Host_Template	*sht;
+	struct scsi_host_template *sht;
 	struct ata_ioports	port[ATA_MAX_PORTS];
 	unsigned int		n_ports;
 	unsigned int		hard_port_no;
@@ -398,7 +398,7 @@ struct ata_port_operations {
 };
 
 struct ata_port_info {
-	Scsi_Host_Template	*sht;
+	struct scsi_host_template *sht;
 	unsigned long		host_flags;
 	unsigned long		pio_mask;
 	unsigned long		mwdma_mask;
@@ -433,7 +433,7 @@ extern void ata_pci_remove_one (struct pci_dev *pdev);
 #endif /* CONFIG_PCI */
 extern int ata_device_add(const struct ata_probe_ent *ent);
 extern void ata_host_set_remove(struct ata_host_set *host_set);
-extern int ata_scsi_detect(Scsi_Host_Template *sht);
+extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
 extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));
 extern int ata_scsi_error(struct Scsi_Host *host);

commit 8cedcfd43a0b00741fff43d6a4c1a8b7748db3b0
Merge: cd8200e6d4f9 70d9d825e0a5
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat Nov 5 15:44:02 2005 -0500

    Merge branch 'master'

commit 6037d6bbdff65eb5a84fe35e140f4da4f7cc103a
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Fri Nov 4 22:08:00 2005 -0500

    [libata] ATAPI pad allocation fixes/cleanup
    
    Use ata_pad_{alloc,free} in two drivers, to factor out common code.
    
    Add ata_pad_{alloc,free} to two other drivers, which needed the padding
    but had not been updated.

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6225b78fa65b..dcd17e7458ab 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -777,4 +777,17 @@ static inline unsigned int __ac_err_mask(u8 status)
 	return mask;
 }
 
+static inline int ata_pad_alloc(struct ata_port *ap, struct device *dev)
+{
+	ap->pad_dma = 0;
+	ap->pad = dma_alloc_coherent(dev, ATA_DMA_PAD_BUF_SZ,
+				     &ap->pad_dma, GFP_KERNEL);
+	return (ap->pad == NULL) ? -ENOMEM : 0;
+}
+
+static inline void ata_pad_free(struct ata_port *ap, struct device *dev)
+{
+	dma_free_coherent(dev, ATA_DMA_PAD_BUF_SZ, ap->pad, ap->pad_dma);
+}
+
 #endif /* __LINUX_LIBATA_H__ */

commit 122401ce39faab22b29eb11b20e4342f7f566b1b
Merge: 94ec1ef1cf29 6e9d6b8ee4e0
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sun Oct 30 20:25:28 2005 -0500

    Merge branch 'master'

commit 054ee8fd39f1b5d50e803f126b63f400d631eea4
Merge: f0612bbc41f6 a7dac447bb9c
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sun Oct 30 04:50:22 2005 -0500

    Merge branch 'upstream'

commit a7dac447bb9cef27d4d29cdf63e2d7809c50b1f4
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sun Oct 30 04:44:42 2005 -0500

    [libata] change ata_qc_complete() to take error mask as second arg
    
    The second argument to ata_qc_complete() was being used for two
    purposes: communicate the ATA Status register to the completion
    function, and indicate an error.  On legacy PCI IDE hardware, the latter
    is often implicit in the former.  On more modern hardware, the driver
    often completely emulated a Status register value, passing ATA_ERR as an
    indication that something went wrong.
    
    Now that previous code changes have eliminated the need to use drv_stat
    arg to communicate the ATA Status register value, we can convert it to a
    mask of possible error classes.
    
    This will lead to more flexible error handling in the future.

diff --git a/include/linux/libata.h b/include/linux/libata.h
index a4cce9936a80..0ba3af7a1236 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -172,6 +172,13 @@ enum hsm_task_states {
 	HSM_ST_ERR,
 };
 
+enum ata_completion_errors {
+	AC_ERR_OTHER		= (1 << 0),
+	AC_ERR_DEV		= (1 << 1),
+	AC_ERR_ATA_BUS		= (1 << 2),
+	AC_ERR_HOST_BUS		= (1 << 3),
+};
+
 /* forward declarations */
 struct scsi_device;
 struct ata_port_operations;
@@ -179,7 +186,7 @@ struct ata_port;
 struct ata_queued_cmd;
 
 /* typedefs */
-typedef int (*ata_qc_cb_t) (struct ata_queued_cmd *qc, u8 drv_stat);
+typedef int (*ata_qc_cb_t) (struct ata_queued_cmd *qc, unsigned int err_mask);
 
 struct ata_ioports {
 	unsigned long		cmd_addr;
@@ -453,7 +460,7 @@ extern void ata_bmdma_start (struct ata_queued_cmd *qc);
 extern void ata_bmdma_stop(struct ata_queued_cmd *qc);
 extern u8   ata_bmdma_status(struct ata_port *ap);
 extern void ata_bmdma_irq_clear(struct ata_port *ap);
-extern void ata_qc_complete(struct ata_queued_cmd *qc, u8 drv_stat);
+extern void ata_qc_complete(struct ata_queued_cmd *qc, unsigned int err_mask);
 extern void ata_eng_timeout(struct ata_port *ap);
 extern void ata_scsi_simulate(u16 *id, struct scsi_cmnd *cmd,
 			      void (*done)(struct scsi_cmnd *));
@@ -716,4 +723,21 @@ static inline int ata_try_flush_cache(const struct ata_device *dev)
 	       ata_id_has_flush_ext(dev->id);
 }
 
+static inline unsigned int ac_err_mask(u8 status)
+{
+	if (status & ATA_BUSY)
+		return AC_ERR_ATA_BUS;
+	if (status & (ATA_ERR | ATA_DF))
+		return AC_ERR_DEV;
+	return 0;
+}
+
+static inline unsigned int __ac_err_mask(u8 status)
+{
+	unsigned int mask = ac_err_mask(status);
+	if (mask == 0)
+		return AC_ERR_OTHER;
+	return mask;
+}
+
 #endif /* __LINUX_LIBATA_H__ */

commit fce45c1c8a6b5334fa88bbb9b1496b0699d3fef0
Merge: 15dbb5a3f971 81cfb8864c73
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sun Oct 30 01:58:41 2005 -0500

    Merge branch 'upstream'

commit f0612bbc41f65f5a684f69d714a1a17a6f0f40c5
Merge: b0c4e148bd59 81cfb8864c73
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sun Oct 30 01:58:18 2005 -0500

    Merge branch 'upstream'

commit 0169e284f6b6b263cc7c2ed25986b96cd6fda610
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat Oct 29 21:25:10 2005 -0400

    [libata] remove ata_chk_err(), ->check_err() hook.
    
    We now depend on ->tf_read() to provide us with the contents
    of the Error shadow register.

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 00a8a5738858..a4cce9936a80 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -347,7 +347,6 @@ struct ata_port_operations {
 	void (*exec_command)(struct ata_port *ap, const struct ata_taskfile *tf);
 	u8   (*check_status)(struct ata_port *ap);
 	u8   (*check_altstatus)(struct ata_port *ap);
-	u8   (*check_err)(struct ata_port *ap);
 	void (*dev_select)(struct ata_port *ap, unsigned int device);
 
 	void (*phy_reset) (struct ata_port *ap);
@@ -434,7 +433,6 @@ extern void ata_noop_dev_select (struct ata_port *ap, unsigned int device);
 extern void ata_std_dev_select (struct ata_port *ap, unsigned int device);
 extern u8 ata_check_status(struct ata_port *ap);
 extern u8 ata_altstatus(struct ata_port *ap);
-extern u8 ata_chk_err(struct ata_port *ap);
 extern void ata_exec_command(struct ata_port *ap, const struct ata_taskfile *tf);
 extern int ata_port_start (struct ata_port *ap);
 extern void ata_port_stop (struct ata_port *ap);

commit 15dbb5a3f971a28040ae6cbcd8bbdf19b629fa83
Merge: be697c3f137c 5fadd053d9bb
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Fri Oct 28 12:30:16 2005 -0400

    Merge branch 'master'

commit 7a9f8f93d2dad38f30fbc79d8a1e6517373aa4b6
Merge: 972c26bdd6b5 5fadd053d9bb
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Fri Oct 28 12:29:23 2005 -0400

    Merge branch 'master'

commit 057ace5e79da9ebf2aa82833cfea825533ac06fb
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat Oct 22 14:27:05 2005 -0400

    libata: const-ification bombing run
    
    Enforce access rules where appropriate.
    
    If the compiler is smart enough, this may buy us an optimization or two
    as a side effect.

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 634b5aa0a615..00a8a5738858 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -202,7 +202,7 @@ struct ata_ioports {
 struct ata_probe_ent {
 	struct list_head	node;
 	struct device 		*dev;
-	struct ata_port_operations	*port_ops;
+	const struct ata_port_operations *port_ops;
 	Scsi_Host_Template	*sht;
 	struct ata_ioports	port[ATA_MAX_PORTS];
 	unsigned int		n_ports;
@@ -225,7 +225,7 @@ struct ata_host_set {
 	void __iomem		*mmio_base;
 	unsigned int		n_ports;
 	void			*private_data;
-	struct ata_port_operations *ops;
+	const struct ata_port_operations *ops;
 	struct ata_port *	ports[0];
 };
 
@@ -294,7 +294,7 @@ struct ata_device {
 
 struct ata_port {
 	struct Scsi_Host	*host;	/* our co-allocated scsi host */
-	struct ata_port_operations	*ops;
+	const struct ata_port_operations *ops;
 	unsigned long		flags;	/* ATA_FLAG_xxx */
 	unsigned int		id;	/* unique id req'd by scsi midlyr */
 	unsigned int		port_no; /* unique port #; from zero */
@@ -341,10 +341,10 @@ struct ata_port_operations {
 	void (*set_piomode) (struct ata_port *, struct ata_device *);
 	void (*set_dmamode) (struct ata_port *, struct ata_device *);
 
-	void (*tf_load) (struct ata_port *ap, struct ata_taskfile *tf);
+	void (*tf_load) (struct ata_port *ap, const struct ata_taskfile *tf);
 	void (*tf_read) (struct ata_port *ap, struct ata_taskfile *tf);
 
-	void (*exec_command)(struct ata_port *ap, struct ata_taskfile *tf);
+	void (*exec_command)(struct ata_port *ap, const struct ata_taskfile *tf);
 	u8   (*check_status)(struct ata_port *ap);
 	u8   (*check_altstatus)(struct ata_port *ap);
 	u8   (*check_err)(struct ata_port *ap);
@@ -385,7 +385,7 @@ struct ata_port_info {
 	unsigned long		pio_mask;
 	unsigned long		mwdma_mask;
 	unsigned long		udma_mask;
-	struct ata_port_operations	*port_ops;
+	const struct ata_port_operations *port_ops;
 };
 
 struct ata_timing {
@@ -413,7 +413,7 @@ extern int ata_pci_init_one (struct pci_dev *pdev, struct ata_port_info **port_i
 			     unsigned int n_ports);
 extern void ata_pci_remove_one (struct pci_dev *pdev);
 #endif /* CONFIG_PCI */
-extern int ata_device_add(struct ata_probe_ent *ent);
+extern int ata_device_add(const struct ata_probe_ent *ent);
 extern void ata_host_set_remove(struct ata_host_set *host_set);
 extern int ata_scsi_detect(Scsi_Host_Template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
@@ -426,16 +426,16 @@ extern int ata_ratelimit(void);
 /*
  * Default driver ops implementations
  */
-extern void ata_tf_load(struct ata_port *ap, struct ata_taskfile *tf);
+extern void ata_tf_load(struct ata_port *ap, const struct ata_taskfile *tf);
 extern void ata_tf_read(struct ata_port *ap, struct ata_taskfile *tf);
-extern void ata_tf_to_fis(struct ata_taskfile *tf, u8 *fis, u8 pmp);
-extern void ata_tf_from_fis(u8 *fis, struct ata_taskfile *tf);
+extern void ata_tf_to_fis(const struct ata_taskfile *tf, u8 *fis, u8 pmp);
+extern void ata_tf_from_fis(const u8 *fis, struct ata_taskfile *tf);
 extern void ata_noop_dev_select (struct ata_port *ap, unsigned int device);
 extern void ata_std_dev_select (struct ata_port *ap, unsigned int device);
 extern u8 ata_check_status(struct ata_port *ap);
 extern u8 ata_altstatus(struct ata_port *ap);
 extern u8 ata_chk_err(struct ata_port *ap);
-extern void ata_exec_command(struct ata_port *ap, struct ata_taskfile *tf);
+extern void ata_exec_command(struct ata_port *ap, const struct ata_taskfile *tf);
 extern int ata_port_start (struct ata_port *ap);
 extern void ata_port_stop (struct ata_port *ap);
 extern void ata_host_stop (struct ata_host_set *host_set);
@@ -446,8 +446,8 @@ extern void ata_sg_init_one(struct ata_queued_cmd *qc, void *buf,
 		unsigned int buflen);
 extern void ata_sg_init(struct ata_queued_cmd *qc, struct scatterlist *sg,
 		 unsigned int n_elem);
-extern unsigned int ata_dev_classify(struct ata_taskfile *tf);
-extern void ata_dev_id_string(u16 *id, unsigned char *s,
+extern unsigned int ata_dev_classify(const struct ata_taskfile *tf);
+extern void ata_dev_id_string(const u16 *id, unsigned char *s,
 			      unsigned int ofs, unsigned int len);
 extern void ata_dev_config(struct ata_port *ap, unsigned int i);
 extern void ata_bmdma_setup (struct ata_queued_cmd *qc);
@@ -502,7 +502,7 @@ struct pci_bits {
 extern void ata_pci_host_stop (struct ata_host_set *host_set);
 extern struct ata_probe_ent *
 ata_pci_init_native_mode(struct pci_dev *pdev, struct ata_port_info **port, int portmask);
-extern int pci_test_config_bits(struct pci_dev *pdev, struct pci_bits *bits);
+extern int pci_test_config_bits(struct pci_dev *pdev, const struct pci_bits *bits);
 
 #endif /* CONFIG_PCI */
 
@@ -512,7 +512,7 @@ static inline unsigned int ata_tag_valid(unsigned int tag)
 	return (tag < ATA_MAX_QUEUE) ? 1 : 0;
 }
 
-static inline unsigned int ata_dev_present(struct ata_device *dev)
+static inline unsigned int ata_dev_present(const struct ata_device *dev)
 {
 	return ((dev->class == ATA_DEV_ATA) ||
 		(dev->class == ATA_DEV_ATAPI));
@@ -711,7 +711,7 @@ static inline unsigned int sata_dev_present(struct ata_port *ap)
 	return ((scr_read(ap, SCR_STATUS) & 0xf) == 0x3) ? 1 : 0;
 }
 
-static inline int ata_try_flush_cache(struct ata_device *dev)
+static inline int ata_try_flush_cache(const struct ata_device *dev)
 {
 	return ata_id_wcache_enabled(dev->id) ||
 	       ata_id_has_flush(dev->id) ||

commit cf482935c6abe5245e481213c6e6df808c976f56
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat Oct 22 00:19:33 2005 -0400

    libata: turn on block layer clustering

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 0e214f8c8f9f..634b5aa0a615 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -91,7 +91,7 @@ enum {
 	ATA_SHT_EMULATED	= 1,
 	ATA_SHT_CMD_PER_LUN	= 1,
 	ATA_SHT_THIS_ID		= -1,
-	ATA_SHT_USE_CLUSTERING	= 0,
+	ATA_SHT_USE_CLUSTERING	= 1,
 
 	/* struct ata_device stuff */
 	ATA_DFLAG_LBA48		= (1 << 0), /* device supports LBA48 */

commit 452503f993feffe96e8cc9fbff4888b96e2c5e40
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Fri Oct 21 19:01:32 2005 -0400

    Add ide-timing functionality to libata.
    
    This is needed for full AMD and VIA drivers and possibly more. Functions
    to turn actual clocking and cycle timings into register values. Also to
    merge shared timings to compute an optimal timing set.
    
    Built from the drivers/ide version by Vojtech Pavlik
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 0261c55f3483..0e214f8c8f9f 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -388,6 +388,19 @@ struct ata_port_info {
 	struct ata_port_operations	*port_ops;
 };
 
+struct ata_timing {
+	unsigned short mode;		/* ATA mode */
+	unsigned short setup;		/* t1 */
+	unsigned short act8b;		/* t2 for 8-bit I/O */
+	unsigned short rec8b;		/* t2i for 8-bit I/O */
+	unsigned short cyc8b;		/* t0 for 8-bit I/O */
+	unsigned short active;		/* t2 or tD */
+	unsigned short recover;		/* t2i or tK */
+	unsigned short cycle;		/* t0 */
+	unsigned short udma;		/* t2CYCTYP/2 */
+};
+
+#define FIT(v,vmin,vmax)	max_t(short,min_t(short,v,vmax),vmin)
 
 extern void ata_port_probe(struct ata_port *);
 extern void __sata_phy_reset(struct ata_port *ap);
@@ -451,6 +464,32 @@ extern int ata_std_bios_param(struct scsi_device *sdev,
 			      sector_t capacity, int geom[]);
 extern int ata_scsi_slave_config(struct scsi_device *sdev);
 
+/*
+ * Timing helpers
+ */
+extern int ata_timing_compute(struct ata_device *, unsigned short,
+			      struct ata_timing *, int, int);
+extern void ata_timing_merge(const struct ata_timing *,
+			     const struct ata_timing *, struct ata_timing *,
+			     unsigned int);
+
+enum {
+	ATA_TIMING_SETUP	= (1 << 0),
+	ATA_TIMING_ACT8B	= (1 << 1),
+	ATA_TIMING_REC8B	= (1 << 2),
+	ATA_TIMING_CYC8B	= (1 << 3),
+	ATA_TIMING_8BIT		= ATA_TIMING_ACT8B | ATA_TIMING_REC8B |
+				  ATA_TIMING_CYC8B,
+	ATA_TIMING_ACTIVE	= (1 << 4),
+	ATA_TIMING_RECOVER	= (1 << 5),
+	ATA_TIMING_CYCLE	= (1 << 6),
+	ATA_TIMING_UDMA		= (1 << 7),
+	ATA_TIMING_ALL		= ATA_TIMING_SETUP | ATA_TIMING_ACT8B |
+				  ATA_TIMING_REC8B | ATA_TIMING_CYC8B |
+				  ATA_TIMING_ACTIVE | ATA_TIMING_RECOVER |
+				  ATA_TIMING_CYCLE | ATA_TIMING_UDMA,
+};
+
 
 #ifdef CONFIG_PCI
 struct pci_bits {

commit 972c26bdd6b58e7534473c4f7928584578cf43f4
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Tue Oct 18 22:14:54 2005 -0400

    libata: add ata_sg_is_last() helper, use it in several drivers

diff --git a/include/linux/libata.h b/include/linux/libata.h
index d3f58a796c3a..d3dfefefabec 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -480,6 +480,18 @@ extern int pci_test_config_bits(struct pci_dev *pdev, struct pci_bits *bits);
 #endif /* CONFIG_PCI */
 
 
+static inline int
+ata_sg_is_last(struct scatterlist *sg, struct ata_queued_cmd *qc)
+{
+	if (sg == &qc->pad_sgent)
+		return 1;
+	if (qc->pad_len)
+		return 0;
+	if (((sg - qc->__sg) + 1) == qc->n_elem)
+		return 1;
+	return 0;
+}
+
 static inline struct scatterlist *
 ata_qc_next_sg(struct scatterlist *sg, struct ata_queued_cmd *qc)
 {

commit b194b4250c2b7e9d762823ac6045316fcd4bf4f9
Merge: c4052da6f0c0 59a10b172fcc
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Tue Oct 18 21:52:42 2005 -0400

    Merge branch 'upstream'

commit 4e0e329d9a2011f9f7a7c0a378dc3bff7b0a0283
Merge: e33b9dfa3008 59a10b172fcc
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Tue Oct 18 21:23:11 2005 -0400

    Merge branch 'upstream'

commit 8cbd6df1f0ce977ab7b61feffa59879bb5e0ed8f
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Wed Oct 12 15:06:27 2005 +0800

    [PATCH] libata CHS: calculate read/write commands and protocol on the fly (revise #6)
    
         - merge ata_prot_to_cmd() and ata_dev_set_protocol() as
           ata_rwcmd_protocol()
         - pave road for read/write multiple support
         - remove usage of pre-cached command and protocol values and call
           ata_rwcmd_protocol() instead
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    
    ==============
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 7929cfc9318d..0261c55f3483 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -283,10 +283,8 @@ struct ata_device {
 	u8			xfer_mode;
 	unsigned int		xfer_shift;	/* ATA_SHIFT_xxx */
 
-	/* cache info about current transfer mode */
-	u8			xfer_protocol;	/* taskfile xfer protocol */
-	u8			read_cmd;	/* opcode to use on read */
-	u8			write_cmd;	/* opcode to use on write */
+	unsigned int		multi_count;	/* sectors count for
+						   READ/WRITE MULTIPLE */
 
 	/* for CHS addressing */
 	u16			cylinders;	/* Number of cylinders */

commit c4052da6f0c01a0b059d125d72bb934d0980b798
Merge: cedc9a478d8c 3d3467f0fdf6
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sun Oct 9 11:16:14 2005 -0400

    Merge branch 'upstream'

commit f58f8be7f65312f602f7970e7da47a6413e692b0
Merge: c71c18576d0d e710245bb0f9
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sun Oct 9 09:44:07 2005 -0400

    Merge branch 'upstream'

commit cedc9a478d8c6265879dc3839ef3d4849a709184
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Wed Oct 5 07:13:30 2005 -0400

    libata: fix ATAPI DMA alignment issues
    
    ATAPI needs to be padded to next 4 byte boundary, if misaligned.
    
    Original work by me, many fixes from Tejun Heo.

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ceee1fc42c60..3ab67622ef93 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -154,6 +154,10 @@ enum {
 	ATA_SHIFT_UDMA		= 0,
 	ATA_SHIFT_MWDMA		= 8,
 	ATA_SHIFT_PIO		= 11,
+
+	/* size of buffer to pad xfers ending on unaligned boundaries */
+	ATA_DMA_PAD_SZ		= 4,
+	ATA_DMA_PAD_BUF_SZ	= ATA_DMA_PAD_SZ * ATA_MAX_QUEUE,
 };
 
 enum pio_task_states {
@@ -237,9 +241,12 @@ struct ata_queued_cmd {
 	unsigned long		flags;		/* ATA_QCFLAG_xxx */
 	unsigned int		tag;
 	unsigned int		n_elem;
+	unsigned int		orig_n_elem;
 
 	int			dma_dir;
 
+	unsigned int		pad_len;
+
 	unsigned int		nsect;
 	unsigned int		cursect;
 
@@ -250,9 +257,11 @@ struct ata_queued_cmd {
 	unsigned int		cursg_ofs;
 
 	struct scatterlist	sgent;
+	struct scatterlist	pad_sgent;
 	void			*buf_virt;
 
-	struct scatterlist	*sg;
+	/* DO NOT iterate over __sg manually, use ata_for_each_sg() */
+	struct scatterlist	*__sg;
 
 	ata_qc_cb_t		complete_fn;
 
@@ -295,6 +304,9 @@ struct ata_port {
 	struct ata_prd		*prd;	 /* our SG list */
 	dma_addr_t		prd_dma; /* and its DMA mapping */
 
+	void			*pad;	/* array of DMA pad buffers */
+	dma_addr_t		pad_dma;
+
 	struct ata_ioports	ioaddr;	/* ATA cmd/ctl/dma register blocks */
 
 	u8			ctl;	/* cache of ATA control register */
@@ -458,6 +470,19 @@ extern int pci_test_config_bits(struct pci_dev *pdev, struct pci_bits *bits);
 #endif /* CONFIG_PCI */
 
 
+static inline struct scatterlist *
+ata_qc_next_sg(struct scatterlist *sg, struct ata_queued_cmd *qc)
+{
+	if (sg == &qc->pad_sgent)
+		return NULL;
+	if (++sg - qc->__sg < qc->n_elem)
+		return sg;
+	return qc->pad_len ? &qc->pad_sgent : NULL;
+}
+
+#define ata_for_each_sg(sg, qc) \
+	for (sg = qc->__sg; sg; sg = ata_qc_next_sg(sg, qc))
+
 static inline unsigned int ata_tag_valid(unsigned int tag)
 {
 	return (tag < ATA_MAX_QUEUE) ? 1 : 0;

commit 67846b30171cc4d706125f630193a76a26bb334a
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Wed Oct 5 02:58:32 2005 -0400

    libata: add ata_ratelimit(), use it in AHCI driver irq handler

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 4d45179872cc..7929cfc9318d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -410,6 +410,8 @@ extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmn
 extern int ata_scsi_error(struct Scsi_Host *host);
 extern int ata_scsi_release(struct Scsi_Host *host);
 extern unsigned int ata_host_intr(struct ata_port *ap, struct ata_queued_cmd *qc);
+extern int ata_ratelimit(void);
+
 /*
  * Default driver ops implementations
  */

commit 47a8659380d40d5c0786ddb62a89b3f7f1392430
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Tue Oct 4 08:09:19 2005 -0400

    libata: bitmask based pci init functions for one or two ports
    
    This redoes the n_ports logic I proposed before as a bitmask.
    ata_pci_init_native_mode is now used with a mask allowing for mixed mode
    stuff later on. ata_pci_init_legacy_port is called with port number and
    does one port now not two. Instead it is called twice by the ata init
    logic which cleans both of them up.
    
    There are stil limits in the original code left over
    
    - IRQ/port mapping for legacy mode should be arch specific values
    - You can have one legacy mode IDE adapter per PCI root bridge on some systems
    - Doesn't handle mixed mode devices yet (but is now a lot closer to it)

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 4739a75b983d..4d45179872cc 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -155,6 +155,10 @@ enum {
 	ATA_SHIFT_UDMA		= 0,
 	ATA_SHIFT_MWDMA		= 8,
 	ATA_SHIFT_PIO		= 11,
+	
+	/* Masks for port functions */
+	ATA_PORT_PRIMARY	= (1 << 0),
+	ATA_PORT_SECONDARY	= (1 << 1),
 };
 
 enum hsm_task_states {
@@ -458,7 +462,7 @@ struct pci_bits {
 
 extern void ata_pci_host_stop (struct ata_host_set *host_set);
 extern struct ata_probe_ent *
-ata_pci_init_native_mode(struct pci_dev *pdev, struct ata_port_info **port);
+ata_pci_init_native_mode(struct pci_dev *pdev, struct ata_port_info **port, int portmask);
 extern int pci_test_config_bits(struct pci_dev *pdev, struct pci_bits *bits);
 
 #endif /* CONFIG_PCI */

commit 0fbbbf2bde4da5cb01a949c3d7b21c0627f520a8
Merge: 54f00389563c 2b235826098b
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Oct 3 19:48:49 2005 -0400

    Merge libata upstream (which includes C/H/S support) include irq-pio branch.
    Merge branch 'upstream'

commit f9997be974be40e884e9e8157ded2f2f9aed454c
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Fri Sep 30 19:09:31 2005 +0800

    [PATCH] libata irq-pio: rename atapi_packet_task() and comments
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 1fcd0ef9e1c9..7e6feb97406e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -129,8 +129,8 @@ enum {
 	ATA_TMOUT_PIO		= 30 * HZ,
 	ATA_TMOUT_BOOT		= 30 * HZ,	/* hueristic */
 	ATA_TMOUT_BOOT_QUICK	= 7 * HZ,	/* hueristic */
-	ATA_TMOUT_CDB		= 30 * HZ,
-	ATA_TMOUT_CDB_QUICK	= 5 * HZ,
+	ATA_TMOUT_DATAOUT	= 30 * HZ,
+	ATA_TMOUT_DATAOUT_QUICK	= 5 * HZ,
 
 	/* ATA bus states */
 	BUS_UNKNOWN		= 0,
@@ -319,7 +319,7 @@ struct ata_port {
 	struct ata_host_stats	stats;
 	struct ata_host_set	*host_set;
 
-	struct work_struct	packet_task;
+	struct work_struct	dataout_task;
 
 	struct work_struct	pio_task;
 	unsigned int		hsm_task_state;

commit c56b14d2a3e32695e13cd49b417da889da744d1c
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Fri Sep 30 19:07:39 2005 +0800

    [PATCH] libata irq-pio: add comments and cleanup
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ea8ab29aa92e..1fcd0ef9e1c9 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -158,15 +158,16 @@ enum {
 };
 
 enum hsm_task_states {
-	HSM_ST_UNKNOWN,
-	HSM_ST_IDLE,
-	HSM_ST_POLL,
-	HSM_ST_TMOUT,
-	HSM_ST,
-	HSM_ST_LAST,
-	HSM_ST_LAST_POLL,
-	HSM_ST_ERR,
-	HSM_ST_FIRST,
+	HSM_ST_UNKNOWN,		/* state unknown */
+	HSM_ST_IDLE,		/* no command on going */
+	HSM_ST_POLL,		/* same as HSM_ST, waits longer */
+	HSM_ST_TMOUT,		/* timeout */
+	HSM_ST,			/* (waiting the device to) transfer data */
+	HSM_ST_LAST,		/* (waiting the device to) complete command */
+	HSM_ST_LAST_POLL,	/* same as HSM_ST_LAST, waits longer */
+	HSM_ST_ERR,		/* error */
+	HSM_ST_FIRST,		/* (waiting the device to)
+				   write CDB or first data block */
 };
 
 /* forward declarations */

commit 64f09c98d7fce21dcb8da9f248e4159eb1ec245e
Merge: 14be71f4c5c5 98ed72deebfd
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Wed Sep 28 12:11:15 2005 -0400

    /spare/repo/libata-dev branch 'chs-support'

commit e50362eccd8809a224cda5f71714a088ba37b2ab
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Tue Sep 27 17:39:50 2005 +0800

    [PATCH] libata: interrupt driven pio for LLD
    
    libata.h:
    libata-core:
      Add ATA_FLAG_PIO_POLLING flag for LLDs that expect interrupt for
    command completion only.
    
    sata_nv.c:
    sata_vsc.c:
      irq handler is wrapper around ata_host_intr(), can handle PIO interrupts.
    
    sata_promise.c:
    sata_sx4.c:
    sata_qstor.c:
    sata_mv.c:
      Private irq handler.
      Polling mode ATA_FLAG_PIO_POLLING used for compatibility.
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 9ac2b69df3c1..ea8ab29aa92e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -116,6 +116,8 @@ enum {
 	ATA_FLAG_MMIO		= (1 << 6), /* use MMIO, not PIO */
 	ATA_FLAG_SATA_RESET	= (1 << 7), /* use COMRESET */
 	ATA_FLAG_PIO_DMA	= (1 << 8), /* PIO cmds via DMA */
+	ATA_FLAG_PIO_POLLING	= (1 << 9), /* use polling PIO if LLD
+					     * doesn't handle PIO interrupts */
 
 	ATA_QCFLAG_ACTIVE	= (1 << 1), /* cmd not yet ack'd to scsi lyer */
 	ATA_QCFLAG_SG		= (1 << 3), /* have s/g table? */

commit 312f7da2824c82800ee78d6190f12854456957af
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Tue Sep 27 17:38:03 2005 +0800

    [PATCH] libata: interrupt driven pio for libata-core
    
    - add PIO_ST_FIRST for the state before sending ATAPI CDB or sending
    "ATA PIO data out" first data block.
    - add ATA_TFLAG_POLLING and ATA_DFLAG_CDB_INTR flags
    - remove the ATA_FLAG_NOINTR flag since the interrupt handler is now
    aware of the states
    - modify ata_pio_sector() and atapi_pio_bytes() to work in the interrupt
    context
    - modify the ata_host_intr() to handle PIO interrupts
    - modify ata_qc_issue_prot() to initialize states
    - atapi_packet_task() changed to handle "ATA PIO data out" first data block
    - support the pre-ATA4 ATAPI device which raise interrupt when ready to
    receive CDB
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index bb2d916bce44..9ac2b69df3c1 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -97,6 +97,7 @@ enum {
 	ATA_DFLAG_LBA48		= (1 << 0), /* device supports LBA48 */
 	ATA_DFLAG_PIO		= (1 << 1), /* device currently in PIO mode */
 	ATA_DFLAG_LOCK_SECTORS	= (1 << 2), /* don't adjust max_sectors */
+	ATA_DFLAG_CDB_INTR	= (1 << 3), /* device asserts INTRQ when ready for CDB */
 
 	ATA_DEV_UNKNOWN		= 0,	/* unknown device */
 	ATA_DEV_ATA		= 1,	/* ATA device */
@@ -115,8 +116,6 @@ enum {
 	ATA_FLAG_MMIO		= (1 << 6), /* use MMIO, not PIO */
 	ATA_FLAG_SATA_RESET	= (1 << 7), /* use COMRESET */
 	ATA_FLAG_PIO_DMA	= (1 << 8), /* PIO cmds via DMA */
-	ATA_FLAG_NOINTR		= (1 << 9), /* FIXME: Remove this once
-					     * proper HSM is in place. */
 
 	ATA_QCFLAG_ACTIVE	= (1 << 1), /* cmd not yet ack'd to scsi lyer */
 	ATA_QCFLAG_SG		= (1 << 3), /* have s/g table? */
@@ -165,6 +164,7 @@ enum hsm_task_states {
 	HSM_ST_LAST,
 	HSM_ST_LAST_POLL,
 	HSM_ST_ERR,
+	HSM_ST_FIRST,
 };
 
 /* forward declarations */

commit 14be71f4c5c5ad1e222c5202ee6d234e9c8828b7
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Tue Sep 27 17:36:35 2005 +0800

    [PATCH] libata: rename host states
    
    Changes:
    s/PIO_ST_/HSM_ST_/ and s/pio_task_state/hsm_task_state/.
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index ceee1fc42c60..bb2d916bce44 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -156,15 +156,15 @@ enum {
 	ATA_SHIFT_PIO		= 11,
 };
 
-enum pio_task_states {
-	PIO_ST_UNKNOWN,
-	PIO_ST_IDLE,
-	PIO_ST_POLL,
-	PIO_ST_TMOUT,
-	PIO_ST,
-	PIO_ST_LAST,
-	PIO_ST_LAST_POLL,
-	PIO_ST_ERR,
+enum hsm_task_states {
+	HSM_ST_UNKNOWN,
+	HSM_ST_IDLE,
+	HSM_ST_POLL,
+	HSM_ST_TMOUT,
+	HSM_ST,
+	HSM_ST_LAST,
+	HSM_ST_LAST_POLL,
+	HSM_ST_ERR,
 };
 
 /* forward declarations */
@@ -319,7 +319,7 @@ struct ata_port {
 	struct work_struct	packet_task;
 
 	struct work_struct	pio_task;
-	unsigned int		pio_task_state;
+	unsigned int		hsm_task_state;
 	unsigned long		pio_task_timeout;
 
 	void			*private_data;

commit 98ed72deebfd2b55b7e1bb94c8175b1169999212
Merge: dbaa9a9d2b37 87e807b6c461
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat Sep 24 00:26:49 2005 -0400

    Merge /spare/repo/linux-2.6/

commit 17b14451fd2b187ddd6303726755a3af0a926b6c
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Thu Sep 15 15:44:00 2005 +0100

    [PATCH] PATCH: remove function for non-PCI as requested
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 022105c745fc..ceee1fc42c60 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -393,6 +393,7 @@ extern int ata_pci_init_one (struct pci_dev *pdev, struct ata_port_info **port_i
 extern void ata_pci_remove_one (struct pci_dev *pdev);
 #endif /* CONFIG_PCI */
 extern int ata_device_add(struct ata_probe_ent *ent);
+extern void ata_host_set_remove(struct ata_host_set *host_set);
 extern int ata_scsi_detect(Scsi_Host_Template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
 extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));

commit 142e27fc8a3619471669d6241784eec9167c47d1
Merge: a9053d0494d3 caf39e87cc11
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Thu Sep 8 05:41:28 2005 -0400

    Merge /spare/repo/linux-2.6/

commit d0bd99299bf933ae006d2dc6a31ffcba482ae3f2
Merge: 6f1062330499 586a4ac509b0
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Sep 5 05:20:33 2005 -0400

    /spare/repo/libata-dev branch 'iomap-try3'

commit 374b1873571bf80dc0c1fcceaaad067980f3b9de
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Tue Aug 30 05:42:52 2005 -0400

    [libata] update several drivers to use pci_iomap()/pci_iounmap()

diff --git a/include/linux/libata.h b/include/linux/libata.h
index fc05a9899288..bd0f79dfb9cd 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -450,6 +450,7 @@ struct pci_bits {
 	unsigned long		val;
 };
 
+extern void ata_pci_host_stop (struct ata_host_set *host_set);
 extern struct ata_probe_ent *
 ata_pci_init_native_mode(struct pci_dev *pdev, struct ata_port_info **port);
 extern int pci_test_config_bits(struct pci_dev *pdev, struct pci_bits *bits);

commit 1623c81eece58740279b8de802fa5895221f2044
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Tue Aug 30 03:37:42 2005 -0400

    [libata] allow ATAPI to be enabled with new atapi_enabled module option
    
    ATAPI is getting close to being ready.  To increase exposure, we enable
    the code in the upstream kernel, but default it to off (present
    behavior).  Users must pass atapi_enabled=1 as a module option (if
    module) or on the kernel command line (if built in) to turn on
    discovery of their ATAPI devices.

diff --git a/include/linux/libata.h b/include/linux/libata.h
index fc05a9899288..1eaba4077e15 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -40,7 +40,6 @@
 #undef ATA_VERBOSE_DEBUG	/* yet more debugging output */
 #undef ATA_IRQ_TRAP		/* define to ack screaming irqs */
 #undef ATA_NDEBUG		/* define to disable quick runtime checks */
-#undef ATA_ENABLE_ATAPI		/* define to enable ATAPI support */
 #undef ATA_ENABLE_PATA		/* define to enable PATA support in some
 				 * low-level drivers */
 #undef ATAPI_ENABLE_DMADIR	/* enables ATAPI DMADIR bridge support */

commit 76b2bf9b4dee2fb32ef17f5c84a99ce481a14be2
Merge: 2fca877b68b2 8f3d17fb7bcb
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Aug 29 19:24:43 2005 -0400

    Merge libata branch 'chs-support' to latest upstream kernel.

commit 70d374ea9907036e15574a5ce89219edd5baee10
Merge: aa7e16d6b88b bf4e70e54cf3
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Aug 29 15:59:42 2005 -0400

    Merge /spare/repo/linux-2.6/

commit af36d7f0df56de3e3e4bbfb15d0915097ecb8cab
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sun Aug 28 20:18:39 2005 -0400

    [libata] license change, other bits
    
    - changes license of all code from OSL+GPL to plain ole GPL
      - except for NVIDIA, who hasn't yet responded about sata_nv
      - copyright holders were already contacted privately
    
    - adds info in each driver about where hardware/protocol docs may be
      obtained
    
    - where I have made major contributions, updated copyright dates

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6cd9ba63563b..51d2b20d34f2 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -1,23 +1,26 @@
 /*
-   Copyright 2003-2004 Red Hat, Inc.  All rights reserved.
-   Copyright 2003-2004 Jeff Garzik
-
-   The contents of this file are subject to the Open
-   Software License version 1.1 that can be found at
-   http://www.opensource.org/licenses/osl-1.1.txt and is included herein
-   by reference.
-
-   Alternatively, the contents of this file may be used under the terms
-   of the GNU General Public License version 2 (the "GPL") as distributed
-   in the kernel source COPYING file, in which case the provisions of
-   the GPL are applicable instead of the above.  If you wish to allow
-   the use of your version of this file only under the terms of the
-   GPL and not to allow others to use your version of this file under
-   the OSL, indicate your decision by deleting the provisions above and
-   replace them with the notice and other provisions required by the GPL.
-   If you do not delete the provisions above, a recipient may use your
-   version of this file under either the OSL or the GPL.
-
+ *  Copyright 2003-2005 Red Hat, Inc.  All rights reserved.
+ *  Copyright 2003-2005 Jeff Garzik
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ *  libata documentation is available via 'make {ps|pdf}docs',
+ *  as Documentation/DocBook/libata.*
+ *
  */
 
 #ifndef __LINUX_LIBATA_H__

commit d18d36b4edbb980c9de7fe00724c3ded5de1b7a7
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat Aug 27 04:13:52 2005 -0400

    libata: fix a few alan-isms

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 33f3ab4eb827..7c09540c52bc 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -424,7 +424,6 @@ extern unsigned int ata_dev_classify(struct ata_taskfile *tf);
 extern void ata_dev_id_string(u16 *id, unsigned char *s,
 			      unsigned int ofs, unsigned int len);
 extern void ata_dev_config(struct ata_port *ap, unsigned int i);
-extern void ata_dev_set_protocol(struct ata_device *dev);
 extern void ata_bmdma_setup (struct ata_queued_cmd *qc);
 extern void ata_bmdma_start (struct ata_queued_cmd *qc);
 extern void ata_bmdma_stop(struct ata_queued_cmd *qc);

commit b73fc89f6d1f84326e5e897ad249d00a9f218fd7
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Fri Aug 26 16:03:19 2005 +0100

    [PATCH] libata: regularize dma_start/stop arguments
    
    Needed for a few PATA drivers.
    
    Also fix up a wrong comment.
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 724b7d1c18ea..33f3ab4eb827 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -365,7 +365,7 @@ struct ata_port_operations {
 
 	void (*host_stop) (struct ata_host_set *host_set);
 
-	void (*bmdma_stop) (struct ata_port *ap);
+	void (*bmdma_stop) (struct ata_queued_cmd *qc);
 	u8   (*bmdma_status) (struct ata_port *ap);
 };
 
@@ -424,9 +424,10 @@ extern unsigned int ata_dev_classify(struct ata_taskfile *tf);
 extern void ata_dev_id_string(u16 *id, unsigned char *s,
 			      unsigned int ofs, unsigned int len);
 extern void ata_dev_config(struct ata_port *ap, unsigned int i);
+extern void ata_dev_set_protocol(struct ata_device *dev);
 extern void ata_bmdma_setup (struct ata_queued_cmd *qc);
 extern void ata_bmdma_start (struct ata_queued_cmd *qc);
-extern void ata_bmdma_stop(struct ata_port *ap);
+extern void ata_bmdma_stop(struct ata_queued_cmd *qc);
 extern u8   ata_bmdma_status(struct ata_port *ap);
 extern void ata_bmdma_irq_clear(struct ata_port *ap);
 extern void ata_qc_complete(struct ata_queued_cmd *qc, u8 drv_stat);

commit c1389503710ef4b4e5d21bea284afde19e9619cf
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Aug 22 14:59:24 2005 +0900

    [PATCH] fix atapi_packet_task vs. intr race (take 2)
    
    Interrupts from devices sharing the same IRQ could cause
    ata_host_intr to finish commands being processed by atapi_packet_task
    if the commands are using ATA_PROT_ATAPI_NODATA or ATA_PROT_ATAPI_DMA
    protocol.  This is because libata interrupt handler is unaware that
    interrupts are not expected during that period.  This patch adds
    ATA_FLAG_NOINTR flag to tell the interrupt handler that we're not
    expecting interrupts.
    
     Note that once proper HSM is implemented for interrupt-driven PIO,
    this should be merged into it and this flag will be removed.
    
     ahci.c is a different kind of beast, so it's left alone.
    
    * The following drivers use ata_qc_issue_prot and ata_interrupt, so
      changes in libata core will do.
    
      ata_piix sata_sil sata_svw sata_via sata_sis sata_uli
    
    * The following drivers use ata_qc_issue_prot and custom intr handler.
      They need this change to work correctly.
    
      sata_nv sata_vsc
    
    * The following drivers use custom issue function and intr handler.
      Currently all custom issue functions don't support ATAPI, so this
      change is irrelevant, updated for consistency and to avoid later
      mistakes.
    
      sata_promise sata_qstor sata_sx4
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 85b0aaee0ef8..724b7d1c18ea 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -113,6 +113,8 @@ enum {
 	ATA_FLAG_MMIO		= (1 << 6), /* use MMIO, not PIO */
 	ATA_FLAG_SATA_RESET	= (1 << 7), /* use COMRESET */
 	ATA_FLAG_PIO_DMA	= (1 << 8), /* PIO cmds via DMA */
+	ATA_FLAG_NOINTR		= (1 << 9), /* FIXME: Remove this once
+					     * proper HSM is in place. */
 
 	ATA_QCFLAG_ACTIVE	= (1 << 1), /* cmd not yet ack'd to scsi lyer */
 	ATA_QCFLAG_SG		= (1 << 3), /* have s/g table? */

commit 8a60a07129fad60bba779a2a4038c7518b167fc7
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sun Jul 31 13:13:24 2005 -0400

    libata: trim trailing whitespace.
    
    Also, fixup a tabs-to-spaces block of code in ata_piix.

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 6cd9ba63563b..85b0aaee0ef8 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -644,7 +644,7 @@ static inline void scr_write(struct ata_port *ap, unsigned int reg, u32 val)
 	ap->ops->scr_write(ap, reg, val);
 }
 
-static inline void scr_write_flush(struct ata_port *ap, unsigned int reg, 
+static inline void scr_write_flush(struct ata_port *ap, unsigned int reg,
 				   u32 val)
 {
 	ap->ops->scr_write(ap, reg, val);

commit ff40c6d3d1437ecdf295b8e39adcb06c3d6021ef
Merge: 8bf62ecee583 2a5a68b840cb
Author: Jeff Garzik <jgarzik@pretzel.yyz.us>
Date:   Wed Jun 22 13:07:28 2005 -0400

    Merge upstream kernel changes into 'C/H/S support' branch of libata.

commit 73561695b2e77473e353a5ae63bab81ed5098d8e
Merge: 6f2f38128170 8be3de3fd846
Author:  <jgarzik@pretzel.yyz.us>
Date:   Fri Jun 3 23:54:56 2005 -0400

    Automatic merge of /spare/repo/linux-2.6/.git branch HEAD

commit d7aaf48128ec7fcefcee92ea22833afc1a80e268
Merge: decc6d0b68f2 1e86d1c64850
Author:  <jgarzik@pretzel.yyz.us>
Date:   Thu Jun 2 18:43:09 2005 -0400

    Automatic merge of /spare/repo/linux-2.6/.git branch HEAD

commit 0baab86b00cdf9785ac2bb2ce1ab63995b3866ca
Author: Edward Falk <efalk@google.com>
Date:   Thu Jun 2 18:17:13 2005 -0400

    libata: update inline source docs

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 1f7e2039a04e..ad410590664f 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -466,12 +466,34 @@ static inline u8 ata_chk_status(struct ata_port *ap)
 	return ap->ops->check_status(ap);
 }
 
+
+/**
+ *	ata_pause - Flush writes and pause 400 nanoseconds.
+ *	@ap: Port to wait for.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+
 static inline void ata_pause(struct ata_port *ap)
 {
 	ata_altstatus(ap);
 	ndelay(400);
 }
 
+
+/**
+ *	ata_busy_wait - Wait for a port status register
+ *	@ap: Port to wait for.
+ *
+ *	Waits up to max*10 microseconds for the selected bits in the port's
+ *	status register to be cleared.
+ *	Returns final value of status register.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+
 static inline u8 ata_busy_wait(struct ata_port *ap, unsigned int bits,
 			       unsigned int max)
 {
@@ -486,6 +508,18 @@ static inline u8 ata_busy_wait(struct ata_port *ap, unsigned int bits,
 	return status;
 }
 
+
+/**
+ *	ata_wait_idle - Wait for a port to be idle.
+ *	@ap: Port to wait for.
+ *
+ *	Waits up to 10ms for port's BUSY and DRQ signals to clear.
+ *	Returns final value of status register.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+
 static inline u8 ata_wait_idle(struct ata_port *ap)
 {
 	u8 status = ata_busy_wait(ap, ATA_BUSY | ATA_DRQ, 1000);
@@ -524,6 +558,18 @@ static inline void ata_tf_init(struct ata_port *ap, struct ata_taskfile *tf, uns
 		tf->device = ATA_DEVICE_OBS | ATA_DEV1;
 }
 
+
+/**
+ *	ata_irq_on - Enable interrupts on a port.
+ *	@ap: Port on which interrupts are enabled.
+ *
+ *	Enable interrupts on a legacy IDE device using MMIO or PIO,
+ *	wait for idle, clear any pending interrupts.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+
 static inline u8 ata_irq_on(struct ata_port *ap)
 {
 	struct ata_ioports *ioaddr = &ap->ioaddr;
@@ -543,6 +589,18 @@ static inline u8 ata_irq_on(struct ata_port *ap)
 	return tmp;
 }
 
+
+/**
+ *	ata_irq_ack - Acknowledge a device interrupt.
+ *	@ap: Port on which interrupts are enabled.
+ *
+ *	Wait up to 10 ms for legacy IDE device to become idle (BUSY
+ *	or BUSY+DRQ clear).  Obtain dma status and port status from
+ *	device.  Clear the interrupt.  Return port status.
+ *
+ *	LOCKING:
+ */
+
 static inline u8 ata_irq_ack(struct ata_port *ap, unsigned int chk_drq)
 {
 	unsigned int bits = chk_drq ? ATA_BUSY | ATA_DRQ : ATA_BUSY;

commit aa8f0dc6c3dbf1cf3ff58f3e945c981be134814d
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Thu May 26 21:54:27 2005 -0400

    libata: Fix use-after-iounmap
    
    Jens Axboe pointed out that the iounmap() call in libata was occurring
    too early, and some drivers (ahci, probably others) were using ioremap'd
    memory after it had been unmapped.
    
    The patch should address that problem by way of improving the libata
    driver API:
    
    * move ->host_stop() call after all ->port_stop() calls have occurred.
    
    * create default helper function ata_host_stop(), and move iounmap()
    call there.
    
    * add ->host_stop_prewalk() hook, use it in sata_qstor.c (hi Mark).
    sata_qstor appears to require the host-stop-before-port-stop ordering
    that existed prior to applying the attached patch.

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 1f7e2039a04e..e74f301e9bae 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -410,6 +410,7 @@ extern u8 ata_chk_err(struct ata_port *ap);
 extern void ata_exec_command(struct ata_port *ap, struct ata_taskfile *tf);
 extern int ata_port_start (struct ata_port *ap);
 extern void ata_port_stop (struct ata_port *ap);
+extern void ata_host_stop (struct ata_host_set *host_set);
 extern irqreturn_t ata_interrupt (int irq, void *dev_instance, struct pt_regs *regs);
 extern void ata_qc_prep(struct ata_queued_cmd *qc);
 extern int ata_qc_issue_prot(struct ata_queued_cmd *qc);

commit cdcca89e1a90fa9112260bd6384f20fcc4280e21
Author: Brett Russ <russb@emc.com>
Date:   Mon Mar 28 15:10:27 2005 -0500

    [PATCH] libata: flush COMRESET set and clear
    
    Updated patch to fix erroneous flush of COMRESET set and missing flush
    of COMRESET clear.  Created a new routine scr_write_flush() to try to
    prevent this in the future.  Also, this patch is based on libata-2.6
    instead of the previous libata-dev-2.6 based patch.
    
    Signed-off-by: Brett Russ <russb@emc.com>
    
    Index: libata-2.6/drivers/scsi/libata-core.c
    ===================================================================

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 505160ab472b..1f7e2039a04e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -584,6 +584,13 @@ static inline void scr_write(struct ata_port *ap, unsigned int reg, u32 val)
 	ap->ops->scr_write(ap, reg, val);
 }
 
+static inline void scr_write_flush(struct ata_port *ap, unsigned int reg, 
+				   u32 val)
+{
+	ap->ops->scr_write(ap, reg, val);
+	(void) ap->ops->scr_read(ap, reg);
+}
+
 static inline unsigned int sata_dev_present(struct ata_port *ap)
 {
 	return ((scr_read(ap, SCR_STATUS) & 0xf) == 0x3) ? 1 : 0;

commit 8bf62ecee58360749c5f0e68bc97d5e02a6816b1
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Thu May 12 15:29:42 2005 -0400

    [libata] C/H/S support, for older devices

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 505160ab472b..bd0df84cfd87 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -95,6 +95,7 @@ enum {
 	ATA_DFLAG_LBA48		= (1 << 0), /* device supports LBA48 */
 	ATA_DFLAG_PIO		= (1 << 1), /* device currently in PIO mode */
 	ATA_DFLAG_LOCK_SECTORS	= (1 << 2), /* don't adjust max_sectors */
+	ATA_DFLAG_LBA		= (1 << 3), /* device supports LBA */
 
 	ATA_DEV_UNKNOWN		= 0,	/* unknown device */
 	ATA_DEV_ATA		= 1,	/* ATA device */
@@ -278,6 +279,11 @@ struct ata_device {
 	u8			xfer_protocol;	/* taskfile xfer protocol */
 	u8			read_cmd;	/* opcode to use on read */
 	u8			write_cmd;	/* opcode to use on write */
+
+	/* for CHS addressing */
+	u16			cylinders;	/* Number of cylinders */
+	u16			heads;		/* Number of heads */
+	u16			sectors;	/* Number of sectors per track */
 };
 
 struct ata_port {

commit 6f2f38128170814e151cfedf79532e19cd179567
Author: Brad Campbell <brad@wasp.net.au>
Date:   Thu May 12 15:07:47 2005 -0400

    [PATCH] libata basic detection and errata for PATA->SATA bridges
    
    This patch works around an issue with WD drives (and possibly others)
    over SiL PATA->SATA Bridges on SATA controllers locking up with
    transfers > 200 sectors.
    
    Signed-off-by: Brad Campbell <brad@wasp.net.au>

diff --git a/include/linux/libata.h b/include/linux/libata.h
index 505160ab472b..d33e70361a7d 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -420,6 +420,7 @@ extern void ata_sg_init(struct ata_queued_cmd *qc, struct scatterlist *sg,
 extern unsigned int ata_dev_classify(struct ata_taskfile *tf);
 extern void ata_dev_id_string(u16 *id, unsigned char *s,
 			      unsigned int ofs, unsigned int len);
+extern void ata_dev_config(struct ata_port *ap, unsigned int i);
 extern void ata_bmdma_setup (struct ata_queued_cmd *qc);
 extern void ata_bmdma_start (struct ata_queued_cmd *qc);
 extern void ata_bmdma_stop(struct ata_port *ap);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/libata.h b/include/linux/libata.h
new file mode 100644
index 000000000000..505160ab472b
--- /dev/null
+++ b/include/linux/libata.h
@@ -0,0 +1,599 @@
+/*
+   Copyright 2003-2004 Red Hat, Inc.  All rights reserved.
+   Copyright 2003-2004 Jeff Garzik
+
+   The contents of this file are subject to the Open
+   Software License version 1.1 that can be found at
+   http://www.opensource.org/licenses/osl-1.1.txt and is included herein
+   by reference.
+
+   Alternatively, the contents of this file may be used under the terms
+   of the GNU General Public License version 2 (the "GPL") as distributed
+   in the kernel source COPYING file, in which case the provisions of
+   the GPL are applicable instead of the above.  If you wish to allow
+   the use of your version of this file only under the terms of the
+   GPL and not to allow others to use your version of this file under
+   the OSL, indicate your decision by deleting the provisions above and
+   replace them with the notice and other provisions required by the GPL.
+   If you do not delete the provisions above, a recipient may use your
+   version of this file under either the OSL or the GPL.
+
+ */
+
+#ifndef __LINUX_LIBATA_H__
+#define __LINUX_LIBATA_H__
+
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <linux/ata.h>
+#include <linux/workqueue.h>
+
+/*
+ * compile-time options
+ */
+#undef ATA_DEBUG		/* debugging output */
+#undef ATA_VERBOSE_DEBUG	/* yet more debugging output */
+#undef ATA_IRQ_TRAP		/* define to ack screaming irqs */
+#undef ATA_NDEBUG		/* define to disable quick runtime checks */
+#undef ATA_ENABLE_ATAPI		/* define to enable ATAPI support */
+#undef ATA_ENABLE_PATA		/* define to enable PATA support in some
+				 * low-level drivers */
+#undef ATAPI_ENABLE_DMADIR	/* enables ATAPI DMADIR bridge support */
+
+
+/* note: prints function name for you */
+#ifdef ATA_DEBUG
+#define DPRINTK(fmt, args...) printk(KERN_ERR "%s: " fmt, __FUNCTION__, ## args)
+#ifdef ATA_VERBOSE_DEBUG
+#define VPRINTK(fmt, args...) printk(KERN_ERR "%s: " fmt, __FUNCTION__, ## args)
+#else
+#define VPRINTK(fmt, args...)
+#endif	/* ATA_VERBOSE_DEBUG */
+#else
+#define DPRINTK(fmt, args...)
+#define VPRINTK(fmt, args...)
+#endif	/* ATA_DEBUG */
+
+#ifdef ATA_NDEBUG
+#define assert(expr)
+#else
+#define assert(expr) \
+        if(unlikely(!(expr))) {                                   \
+        printk(KERN_ERR "Assertion failed! %s,%s,%s,line=%d\n", \
+        #expr,__FILE__,__FUNCTION__,__LINE__);          \
+        }
+#endif
+
+/* defines only for the constants which don't work well as enums */
+#define ATA_TAG_POISON		0xfafbfcfdU
+
+/* move to PCI layer? */
+static inline struct device *pci_dev_to_dev(struct pci_dev *pdev)
+{
+	return &pdev->dev;
+}
+
+enum {
+	/* various global constants */
+	LIBATA_MAX_PRD		= ATA_MAX_PRD / 2,
+	ATA_MAX_PORTS		= 8,
+	ATA_DEF_QUEUE		= 1,
+	ATA_MAX_QUEUE		= 1,
+	ATA_MAX_SECTORS		= 200,	/* FIXME */
+	ATA_MAX_BUS		= 2,
+	ATA_DEF_BUSY_WAIT	= 10000,
+	ATA_SHORT_PAUSE		= (HZ >> 6) + 1,
+
+	ATA_SHT_EMULATED	= 1,
+	ATA_SHT_CMD_PER_LUN	= 1,
+	ATA_SHT_THIS_ID		= -1,
+	ATA_SHT_USE_CLUSTERING	= 0,
+
+	/* struct ata_device stuff */
+	ATA_DFLAG_LBA48		= (1 << 0), /* device supports LBA48 */
+	ATA_DFLAG_PIO		= (1 << 1), /* device currently in PIO mode */
+	ATA_DFLAG_LOCK_SECTORS	= (1 << 2), /* don't adjust max_sectors */
+
+	ATA_DEV_UNKNOWN		= 0,	/* unknown device */
+	ATA_DEV_ATA		= 1,	/* ATA device */
+	ATA_DEV_ATA_UNSUP	= 2,	/* ATA device (unsupported) */
+	ATA_DEV_ATAPI		= 3,	/* ATAPI device */
+	ATA_DEV_ATAPI_UNSUP	= 4,	/* ATAPI device (unsupported) */
+	ATA_DEV_NONE		= 5,	/* no device */
+
+	/* struct ata_port flags */
+	ATA_FLAG_SLAVE_POSS	= (1 << 1), /* host supports slave dev */
+					    /* (doesn't imply presence) */
+	ATA_FLAG_PORT_DISABLED	= (1 << 2), /* port is disabled, ignore it */
+	ATA_FLAG_SATA		= (1 << 3),
+	ATA_FLAG_NO_LEGACY	= (1 << 4), /* no legacy mode check */
+	ATA_FLAG_SRST		= (1 << 5), /* use ATA SRST, not E.D.D. */
+	ATA_FLAG_MMIO		= (1 << 6), /* use MMIO, not PIO */
+	ATA_FLAG_SATA_RESET	= (1 << 7), /* use COMRESET */
+	ATA_FLAG_PIO_DMA	= (1 << 8), /* PIO cmds via DMA */
+
+	ATA_QCFLAG_ACTIVE	= (1 << 1), /* cmd not yet ack'd to scsi lyer */
+	ATA_QCFLAG_SG		= (1 << 3), /* have s/g table? */
+	ATA_QCFLAG_SINGLE	= (1 << 4), /* no s/g, just a single buffer */
+	ATA_QCFLAG_DMAMAP	= ATA_QCFLAG_SG | ATA_QCFLAG_SINGLE,
+
+	/* various lengths of time */
+	ATA_TMOUT_EDD		= 5 * HZ,	/* hueristic */
+	ATA_TMOUT_PIO		= 30 * HZ,
+	ATA_TMOUT_BOOT		= 30 * HZ,	/* hueristic */
+	ATA_TMOUT_BOOT_QUICK	= 7 * HZ,	/* hueristic */
+	ATA_TMOUT_CDB		= 30 * HZ,
+	ATA_TMOUT_CDB_QUICK	= 5 * HZ,
+
+	/* ATA bus states */
+	BUS_UNKNOWN		= 0,
+	BUS_DMA			= 1,
+	BUS_IDLE		= 2,
+	BUS_NOINTR		= 3,
+	BUS_NODATA		= 4,
+	BUS_TIMER		= 5,
+	BUS_PIO			= 6,
+	BUS_EDD			= 7,
+	BUS_IDENTIFY		= 8,
+	BUS_PACKET		= 9,
+
+	/* SATA port states */
+	PORT_UNKNOWN		= 0,
+	PORT_ENABLED		= 1,
+	PORT_DISABLED		= 2,
+
+	/* encoding various smaller bitmaps into a single
+	 * unsigned long bitmap
+	 */
+	ATA_SHIFT_UDMA		= 0,
+	ATA_SHIFT_MWDMA		= 8,
+	ATA_SHIFT_PIO		= 11,
+};
+
+enum pio_task_states {
+	PIO_ST_UNKNOWN,
+	PIO_ST_IDLE,
+	PIO_ST_POLL,
+	PIO_ST_TMOUT,
+	PIO_ST,
+	PIO_ST_LAST,
+	PIO_ST_LAST_POLL,
+	PIO_ST_ERR,
+};
+
+/* forward declarations */
+struct scsi_device;
+struct ata_port_operations;
+struct ata_port;
+struct ata_queued_cmd;
+
+/* typedefs */
+typedef int (*ata_qc_cb_t) (struct ata_queued_cmd *qc, u8 drv_stat);
+
+struct ata_ioports {
+	unsigned long		cmd_addr;
+	unsigned long		data_addr;
+	unsigned long		error_addr;
+	unsigned long		feature_addr;
+	unsigned long		nsect_addr;
+	unsigned long		lbal_addr;
+	unsigned long		lbam_addr;
+	unsigned long		lbah_addr;
+	unsigned long		device_addr;
+	unsigned long		status_addr;
+	unsigned long		command_addr;
+	unsigned long		altstatus_addr;
+	unsigned long		ctl_addr;
+	unsigned long		bmdma_addr;
+	unsigned long		scr_addr;
+};
+
+struct ata_probe_ent {
+	struct list_head	node;
+	struct device 		*dev;
+	struct ata_port_operations	*port_ops;
+	Scsi_Host_Template	*sht;
+	struct ata_ioports	port[ATA_MAX_PORTS];
+	unsigned int		n_ports;
+	unsigned int		hard_port_no;
+	unsigned int		pio_mask;
+	unsigned int		mwdma_mask;
+	unsigned int		udma_mask;
+	unsigned int		legacy_mode;
+	unsigned long		irq;
+	unsigned int		irq_flags;
+	unsigned long		host_flags;
+	void __iomem		*mmio_base;
+	void			*private_data;
+};
+
+struct ata_host_set {
+	spinlock_t		lock;
+	struct device 		*dev;
+	unsigned long		irq;
+	void __iomem		*mmio_base;
+	unsigned int		n_ports;
+	void			*private_data;
+	struct ata_port_operations *ops;
+	struct ata_port *	ports[0];
+};
+
+struct ata_queued_cmd {
+	struct ata_port		*ap;
+	struct ata_device	*dev;
+
+	struct scsi_cmnd	*scsicmd;
+	void			(*scsidone)(struct scsi_cmnd *);
+
+	struct ata_taskfile	tf;
+	u8			cdb[ATAPI_CDB_LEN];
+
+	unsigned long		flags;		/* ATA_QCFLAG_xxx */
+	unsigned int		tag;
+	unsigned int		n_elem;
+
+	int			dma_dir;
+
+	unsigned int		nsect;
+	unsigned int		cursect;
+
+	unsigned int		nbytes;
+	unsigned int		curbytes;
+
+	unsigned int		cursg;
+	unsigned int		cursg_ofs;
+
+	struct scatterlist	sgent;
+	void			*buf_virt;
+
+	struct scatterlist	*sg;
+
+	ata_qc_cb_t		complete_fn;
+
+	struct completion	*waiting;
+
+	void			*private_data;
+};
+
+struct ata_host_stats {
+	unsigned long		unhandled_irq;
+	unsigned long		idle_irq;
+	unsigned long		rw_reqbuf;
+};
+
+struct ata_device {
+	u64			n_sectors;	/* size of device, if ATA */
+	unsigned long		flags;		/* ATA_DFLAG_xxx */
+	unsigned int		class;		/* ATA_DEV_xxx */
+	unsigned int		devno;		/* 0 or 1 */
+	u16			id[ATA_ID_WORDS]; /* IDENTIFY xxx DEVICE data */
+	u8			pio_mode;
+	u8			dma_mode;
+	u8			xfer_mode;
+	unsigned int		xfer_shift;	/* ATA_SHIFT_xxx */
+
+	/* cache info about current transfer mode */
+	u8			xfer_protocol;	/* taskfile xfer protocol */
+	u8			read_cmd;	/* opcode to use on read */
+	u8			write_cmd;	/* opcode to use on write */
+};
+
+struct ata_port {
+	struct Scsi_Host	*host;	/* our co-allocated scsi host */
+	struct ata_port_operations	*ops;
+	unsigned long		flags;	/* ATA_FLAG_xxx */
+	unsigned int		id;	/* unique id req'd by scsi midlyr */
+	unsigned int		port_no; /* unique port #; from zero */
+	unsigned int		hard_port_no;	/* hardware port #; from zero */
+
+	struct ata_prd		*prd;	 /* our SG list */
+	dma_addr_t		prd_dma; /* and its DMA mapping */
+
+	struct ata_ioports	ioaddr;	/* ATA cmd/ctl/dma register blocks */
+
+	u8			ctl;	/* cache of ATA control register */
+	u8			last_ctl;	/* Cache last written value */
+	unsigned int		bus_state;
+	unsigned int		port_state;
+	unsigned int		pio_mask;
+	unsigned int		mwdma_mask;
+	unsigned int		udma_mask;
+	unsigned int		cbl;	/* cable type; ATA_CBL_xxx */
+	unsigned int		cdb_len;
+
+	struct ata_device	device[ATA_MAX_DEVICES];
+
+	struct ata_queued_cmd	qcmd[ATA_MAX_QUEUE];
+	unsigned long		qactive;
+	unsigned int		active_tag;
+
+	struct ata_host_stats	stats;
+	struct ata_host_set	*host_set;
+
+	struct work_struct	packet_task;
+
+	struct work_struct	pio_task;
+	unsigned int		pio_task_state;
+	unsigned long		pio_task_timeout;
+
+	void			*private_data;
+};
+
+struct ata_port_operations {
+	void (*port_disable) (struct ata_port *);
+
+	void (*dev_config) (struct ata_port *, struct ata_device *);
+
+	void (*set_piomode) (struct ata_port *, struct ata_device *);
+	void (*set_dmamode) (struct ata_port *, struct ata_device *);
+
+	void (*tf_load) (struct ata_port *ap, struct ata_taskfile *tf);
+	void (*tf_read) (struct ata_port *ap, struct ata_taskfile *tf);
+
+	void (*exec_command)(struct ata_port *ap, struct ata_taskfile *tf);
+	u8   (*check_status)(struct ata_port *ap);
+	u8   (*check_altstatus)(struct ata_port *ap);
+	u8   (*check_err)(struct ata_port *ap);
+	void (*dev_select)(struct ata_port *ap, unsigned int device);
+
+	void (*phy_reset) (struct ata_port *ap);
+	void (*post_set_mode) (struct ata_port *ap);
+
+	int (*check_atapi_dma) (struct ata_queued_cmd *qc);
+
+	void (*bmdma_setup) (struct ata_queued_cmd *qc);
+	void (*bmdma_start) (struct ata_queued_cmd *qc);
+
+	void (*qc_prep) (struct ata_queued_cmd *qc);
+	int (*qc_issue) (struct ata_queued_cmd *qc);
+
+	void (*eng_timeout) (struct ata_port *ap);
+
+	irqreturn_t (*irq_handler)(int, void *, struct pt_regs *);
+	void (*irq_clear) (struct ata_port *);
+
+	u32 (*scr_read) (struct ata_port *ap, unsigned int sc_reg);
+	void (*scr_write) (struct ata_port *ap, unsigned int sc_reg,
+			   u32 val);
+
+	int (*port_start) (struct ata_port *ap);
+	void (*port_stop) (struct ata_port *ap);
+
+	void (*host_stop) (struct ata_host_set *host_set);
+
+	void (*bmdma_stop) (struct ata_port *ap);
+	u8   (*bmdma_status) (struct ata_port *ap);
+};
+
+struct ata_port_info {
+	Scsi_Host_Template	*sht;
+	unsigned long		host_flags;
+	unsigned long		pio_mask;
+	unsigned long		mwdma_mask;
+	unsigned long		udma_mask;
+	struct ata_port_operations	*port_ops;
+};
+
+
+extern void ata_port_probe(struct ata_port *);
+extern void __sata_phy_reset(struct ata_port *ap);
+extern void sata_phy_reset(struct ata_port *ap);
+extern void ata_bus_reset(struct ata_port *ap);
+extern void ata_port_disable(struct ata_port *);
+extern void ata_std_ports(struct ata_ioports *ioaddr);
+#ifdef CONFIG_PCI
+extern int ata_pci_init_one (struct pci_dev *pdev, struct ata_port_info **port_info,
+			     unsigned int n_ports);
+extern void ata_pci_remove_one (struct pci_dev *pdev);
+#endif /* CONFIG_PCI */
+extern int ata_device_add(struct ata_probe_ent *ent);
+extern int ata_scsi_detect(Scsi_Host_Template *sht);
+extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
+extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));
+extern int ata_scsi_error(struct Scsi_Host *host);
+extern int ata_scsi_release(struct Scsi_Host *host);
+extern unsigned int ata_host_intr(struct ata_port *ap, struct ata_queued_cmd *qc);
+/*
+ * Default driver ops implementations
+ */
+extern void ata_tf_load(struct ata_port *ap, struct ata_taskfile *tf);
+extern void ata_tf_read(struct ata_port *ap, struct ata_taskfile *tf);
+extern void ata_tf_to_fis(struct ata_taskfile *tf, u8 *fis, u8 pmp);
+extern void ata_tf_from_fis(u8 *fis, struct ata_taskfile *tf);
+extern void ata_noop_dev_select (struct ata_port *ap, unsigned int device);
+extern void ata_std_dev_select (struct ata_port *ap, unsigned int device);
+extern u8 ata_check_status(struct ata_port *ap);
+extern u8 ata_altstatus(struct ata_port *ap);
+extern u8 ata_chk_err(struct ata_port *ap);
+extern void ata_exec_command(struct ata_port *ap, struct ata_taskfile *tf);
+extern int ata_port_start (struct ata_port *ap);
+extern void ata_port_stop (struct ata_port *ap);
+extern irqreturn_t ata_interrupt (int irq, void *dev_instance, struct pt_regs *regs);
+extern void ata_qc_prep(struct ata_queued_cmd *qc);
+extern int ata_qc_issue_prot(struct ata_queued_cmd *qc);
+extern void ata_sg_init_one(struct ata_queued_cmd *qc, void *buf,
+		unsigned int buflen);
+extern void ata_sg_init(struct ata_queued_cmd *qc, struct scatterlist *sg,
+		 unsigned int n_elem);
+extern unsigned int ata_dev_classify(struct ata_taskfile *tf);
+extern void ata_dev_id_string(u16 *id, unsigned char *s,
+			      unsigned int ofs, unsigned int len);
+extern void ata_bmdma_setup (struct ata_queued_cmd *qc);
+extern void ata_bmdma_start (struct ata_queued_cmd *qc);
+extern void ata_bmdma_stop(struct ata_port *ap);
+extern u8   ata_bmdma_status(struct ata_port *ap);
+extern void ata_bmdma_irq_clear(struct ata_port *ap);
+extern void ata_qc_complete(struct ata_queued_cmd *qc, u8 drv_stat);
+extern void ata_eng_timeout(struct ata_port *ap);
+extern void ata_scsi_simulate(u16 *id, struct scsi_cmnd *cmd,
+			      void (*done)(struct scsi_cmnd *));
+extern int ata_std_bios_param(struct scsi_device *sdev,
+			      struct block_device *bdev,
+			      sector_t capacity, int geom[]);
+extern int ata_scsi_slave_config(struct scsi_device *sdev);
+
+
+#ifdef CONFIG_PCI
+struct pci_bits {
+	unsigned int		reg;	/* PCI config register to read */
+	unsigned int		width;	/* 1 (8 bit), 2 (16 bit), 4 (32 bit) */
+	unsigned long		mask;
+	unsigned long		val;
+};
+
+extern struct ata_probe_ent *
+ata_pci_init_native_mode(struct pci_dev *pdev, struct ata_port_info **port);
+extern int pci_test_config_bits(struct pci_dev *pdev, struct pci_bits *bits);
+
+#endif /* CONFIG_PCI */
+
+
+static inline unsigned int ata_tag_valid(unsigned int tag)
+{
+	return (tag < ATA_MAX_QUEUE) ? 1 : 0;
+}
+
+static inline unsigned int ata_dev_present(struct ata_device *dev)
+{
+	return ((dev->class == ATA_DEV_ATA) ||
+		(dev->class == ATA_DEV_ATAPI));
+}
+
+static inline u8 ata_chk_status(struct ata_port *ap)
+{
+	return ap->ops->check_status(ap);
+}
+
+static inline void ata_pause(struct ata_port *ap)
+{
+	ata_altstatus(ap);
+	ndelay(400);
+}
+
+static inline u8 ata_busy_wait(struct ata_port *ap, unsigned int bits,
+			       unsigned int max)
+{
+	u8 status;
+
+	do {
+		udelay(10);
+		status = ata_chk_status(ap);
+		max--;
+	} while ((status & bits) && (max > 0));
+
+	return status;
+}
+
+static inline u8 ata_wait_idle(struct ata_port *ap)
+{
+	u8 status = ata_busy_wait(ap, ATA_BUSY | ATA_DRQ, 1000);
+
+	if (status & (ATA_BUSY | ATA_DRQ)) {
+		unsigned long l = ap->ioaddr.status_addr;
+		printk(KERN_WARNING
+		       "ATA: abnormal status 0x%X on port 0x%lX\n",
+		       status, l);
+	}
+
+	return status;
+}
+
+static inline void ata_qc_set_polling(struct ata_queued_cmd *qc)
+{
+	qc->tf.ctl |= ATA_NIEN;
+}
+
+static inline struct ata_queued_cmd *ata_qc_from_tag (struct ata_port *ap,
+						      unsigned int tag)
+{
+	if (likely(ata_tag_valid(tag)))
+		return &ap->qcmd[tag];
+	return NULL;
+}
+
+static inline void ata_tf_init(struct ata_port *ap, struct ata_taskfile *tf, unsigned int device)
+{
+	memset(tf, 0, sizeof(*tf));
+
+	tf->ctl = ap->ctl;
+	if (device == 0)
+		tf->device = ATA_DEVICE_OBS;
+	else
+		tf->device = ATA_DEVICE_OBS | ATA_DEV1;
+}
+
+static inline u8 ata_irq_on(struct ata_port *ap)
+{
+	struct ata_ioports *ioaddr = &ap->ioaddr;
+	u8 tmp;
+
+	ap->ctl &= ~ATA_NIEN;
+	ap->last_ctl = ap->ctl;
+
+	if (ap->flags & ATA_FLAG_MMIO)
+		writeb(ap->ctl, (void __iomem *) ioaddr->ctl_addr);
+	else
+		outb(ap->ctl, ioaddr->ctl_addr);
+	tmp = ata_wait_idle(ap);
+
+	ap->ops->irq_clear(ap);
+
+	return tmp;
+}
+
+static inline u8 ata_irq_ack(struct ata_port *ap, unsigned int chk_drq)
+{
+	unsigned int bits = chk_drq ? ATA_BUSY | ATA_DRQ : ATA_BUSY;
+	u8 host_stat, post_stat, status;
+
+	status = ata_busy_wait(ap, bits, 1000);
+	if (status & bits)
+		DPRINTK("abnormal status 0x%X\n", status);
+
+	/* get controller status; clear intr, err bits */
+	if (ap->flags & ATA_FLAG_MMIO) {
+		void __iomem *mmio = (void __iomem *) ap->ioaddr.bmdma_addr;
+		host_stat = readb(mmio + ATA_DMA_STATUS);
+		writeb(host_stat | ATA_DMA_INTR | ATA_DMA_ERR,
+		       mmio + ATA_DMA_STATUS);
+
+		post_stat = readb(mmio + ATA_DMA_STATUS);
+	} else {
+		host_stat = inb(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
+		outb(host_stat | ATA_DMA_INTR | ATA_DMA_ERR,
+		     ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
+
+		post_stat = inb(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
+	}
+
+	VPRINTK("irq ack: host_stat 0x%X, new host_stat 0x%X, drv_stat 0x%X\n",
+		host_stat, post_stat, status);
+
+	return status;
+}
+
+static inline u32 scr_read(struct ata_port *ap, unsigned int reg)
+{
+	return ap->ops->scr_read(ap, reg);
+}
+
+static inline void scr_write(struct ata_port *ap, unsigned int reg, u32 val)
+{
+	ap->ops->scr_write(ap, reg, val);
+}
+
+static inline unsigned int sata_dev_present(struct ata_port *ap)
+{
+	return ((scr_read(ap, SCR_STATUS) & 0xf) == 0x3) ? 1 : 0;
+}
+
+static inline int ata_try_flush_cache(struct ata_device *dev)
+{
+	return ata_id_wcache_enabled(dev->id) ||
+	       ata_id_has_flush(dev->id) ||
+	       ata_id_has_flush_ext(dev->id);
+}
+
+#endif /* __LINUX_LIBATA_H__ */
