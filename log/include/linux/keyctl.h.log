commit b4d0d230ccfb5d1a9ea85da64aa584df7c148ee9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 19:08:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 36
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public licence as published by
      the free software foundation either version 2 of the licence or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 114 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520170857.552531963@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/keyctl.h b/include/linux/keyctl.h
index c7c48c79ce0e..5b79847207ef 100644
--- a/include/linux/keyctl.h
+++ b/include/linux/keyctl.h
@@ -1,12 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /* keyctl kernel bits
  *
  * Copyright (C) 2016 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public Licence
- * as published by the Free Software Foundation; either version
- * 2 of the Licence, or (at your option) any later version.
  */
 
 #ifndef __LINUX_KEYCTL_H

commit 70025f84e5b79627a6739533c4fe7cef5b605886
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 9 17:46:51 2018 +0100

    KEYS: Provide key type operations for asymmetric key ops [ver #2]
    
    Provide five new operations in the key_type struct that can be used to
    provide access to asymmetric key operations.  These will be implemented for
    the asymmetric key type in a later patch and may refer to a key retained in
    RAM by the kernel or a key retained in crypto hardware.
    
         int (*asym_query)(const struct kernel_pkey_params *params,
                           struct kernel_pkey_query *info);
         int (*asym_eds_op)(struct kernel_pkey_params *params,
                            const void *in, void *out);
         int (*asym_verify_signature)(struct kernel_pkey_params *params,
                                      const void *in, const void *in2);
    
    Since encrypt, decrypt and sign are identical in their interfaces, they're
    rolled together in the asym_eds_op() operation and there's an operation ID
    in the params argument to distinguish them.
    
    Verify is different in that we supply the data and the signature instead
    and get an error value (or 0) as the only result on the expectation that
    this may well be how a hardware crypto device may work.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: Denis Kenzior <denkenz@gmail.com>
    Tested-by: Denis Kenzior <denkenz@gmail.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/include/linux/keyctl.h b/include/linux/keyctl.h
new file mode 100644
index 000000000000..c7c48c79ce0e
--- /dev/null
+++ b/include/linux/keyctl.h
@@ -0,0 +1,46 @@
+/* keyctl kernel bits
+ *
+ * Copyright (C) 2016 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public Licence
+ * as published by the Free Software Foundation; either version
+ * 2 of the Licence, or (at your option) any later version.
+ */
+
+#ifndef __LINUX_KEYCTL_H
+#define __LINUX_KEYCTL_H
+
+#include <uapi/linux/keyctl.h>
+
+struct kernel_pkey_query {
+	__u32		supported_ops;	/* Which ops are supported */
+	__u32		key_size;	/* Size of the key in bits */
+	__u16		max_data_size;	/* Maximum size of raw data to sign in bytes */
+	__u16		max_sig_size;	/* Maximum size of signature in bytes */
+	__u16		max_enc_size;	/* Maximum size of encrypted blob in bytes */
+	__u16		max_dec_size;	/* Maximum size of decrypted blob in bytes */
+};
+
+enum kernel_pkey_operation {
+	kernel_pkey_encrypt,
+	kernel_pkey_decrypt,
+	kernel_pkey_sign,
+	kernel_pkey_verify,
+};
+
+struct kernel_pkey_params {
+	struct key	*key;
+	const char	*encoding;	/* Encoding (eg. "oaep" or "raw" for none) */
+	const char	*hash_algo;	/* Digest algorithm used (eg. "sha1") or NULL if N/A */
+	char		*info;		/* Modified info string to be released later */
+	__u32		in_len;		/* Input data size */
+	union {
+		__u32	out_len;	/* Output buffer size (enc/dec/sign) */
+		__u32	in2_len;	/* 2nd input data size (verify) */
+	};
+	enum kernel_pkey_operation op : 8;
+};
+
+#endif /* __LINUX_KEYCTL_H */

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/keyctl.h b/include/linux/keyctl.h
deleted file mode 100644
index c9b7f4faf97a..000000000000
--- a/include/linux/keyctl.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/* keyctl.h: keyctl command IDs
- *
- * Copyright (C) 2004, 2008 Red Hat, Inc. All Rights Reserved.
- * Written by David Howells (dhowells@redhat.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- */
-
-#ifndef _LINUX_KEYCTL_H
-#define _LINUX_KEYCTL_H
-
-/* special process keyring shortcut IDs */
-#define KEY_SPEC_THREAD_KEYRING		-1	/* - key ID for thread-specific keyring */
-#define KEY_SPEC_PROCESS_KEYRING	-2	/* - key ID for process-specific keyring */
-#define KEY_SPEC_SESSION_KEYRING	-3	/* - key ID for session-specific keyring */
-#define KEY_SPEC_USER_KEYRING		-4	/* - key ID for UID-specific keyring */
-#define KEY_SPEC_USER_SESSION_KEYRING	-5	/* - key ID for UID-session keyring */
-#define KEY_SPEC_GROUP_KEYRING		-6	/* - key ID for GID-specific keyring */
-#define KEY_SPEC_REQKEY_AUTH_KEY	-7	/* - key ID for assumed request_key auth key */
-#define KEY_SPEC_REQUESTOR_KEYRING	-8	/* - key ID for request_key() dest keyring */
-
-/* request-key default keyrings */
-#define KEY_REQKEY_DEFL_NO_CHANGE		-1
-#define KEY_REQKEY_DEFL_DEFAULT			0
-#define KEY_REQKEY_DEFL_THREAD_KEYRING		1
-#define KEY_REQKEY_DEFL_PROCESS_KEYRING		2
-#define KEY_REQKEY_DEFL_SESSION_KEYRING		3
-#define KEY_REQKEY_DEFL_USER_KEYRING		4
-#define KEY_REQKEY_DEFL_USER_SESSION_KEYRING	5
-#define KEY_REQKEY_DEFL_GROUP_KEYRING		6
-#define KEY_REQKEY_DEFL_REQUESTOR_KEYRING	7
-
-/* keyctl commands */
-#define KEYCTL_GET_KEYRING_ID		0	/* ask for a keyring's ID */
-#define KEYCTL_JOIN_SESSION_KEYRING	1	/* join or start named session keyring */
-#define KEYCTL_UPDATE			2	/* update a key */
-#define KEYCTL_REVOKE			3	/* revoke a key */
-#define KEYCTL_CHOWN			4	/* set ownership of a key */
-#define KEYCTL_SETPERM			5	/* set perms on a key */
-#define KEYCTL_DESCRIBE			6	/* describe a key */
-#define KEYCTL_CLEAR			7	/* clear contents of a keyring */
-#define KEYCTL_LINK			8	/* link a key into a keyring */
-#define KEYCTL_UNLINK			9	/* unlink a key from a keyring */
-#define KEYCTL_SEARCH			10	/* search for a key in a keyring */
-#define KEYCTL_READ			11	/* read a key or keyring's contents */
-#define KEYCTL_INSTANTIATE		12	/* instantiate a partially constructed key */
-#define KEYCTL_NEGATE			13	/* negate a partially constructed key */
-#define KEYCTL_SET_REQKEY_KEYRING	14	/* set default request-key keyring */
-#define KEYCTL_SET_TIMEOUT		15	/* set key timeout */
-#define KEYCTL_ASSUME_AUTHORITY		16	/* assume request_key() authorisation */
-#define KEYCTL_GET_SECURITY		17	/* get key security label */
-#define KEYCTL_SESSION_TO_PARENT	18	/* apply session keyring to parent process */
-#define KEYCTL_REJECT			19	/* reject a partially constructed key */
-#define KEYCTL_INSTANTIATE_IOV		20	/* instantiate a partially constructed key */
-#define KEYCTL_INVALIDATE		21	/* invalidate a key */
-
-#endif /*  _LINUX_KEYCTL_H */

commit fd75815f727f157a05f4c96b5294a4617c0557da
Author: David Howells <dhowells@redhat.com>
Date:   Fri May 11 10:56:56 2012 +0100

    KEYS: Add invalidation support
    
    Add support for invalidating a key - which renders it immediately invisible to
    further searches and causes the garbage collector to immediately wake up,
    remove it from keyrings and then destroy it when it's no longer referenced.
    
    It's better not to do this with keyctl_revoke() as that marks the key to start
    returning -EKEYREVOKED to searches when what is actually desired is to have the
    key refetched.
    
    To invalidate a key the caller must be granted SEARCH permission by the key.
    This may be too strict.  It may be better to also permit invalidation if the
    caller has any of READ, WRITE or SETATTR permission.
    
    The primary use for this is to evict keys that are cached in special keyrings,
    such as the DNS resolver or an ID mapper.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/keyctl.h b/include/linux/keyctl.h
index 9b0b865ce622..c9b7f4faf97a 100644
--- a/include/linux/keyctl.h
+++ b/include/linux/keyctl.h
@@ -55,5 +55,6 @@
 #define KEYCTL_SESSION_TO_PARENT	18	/* apply session keyring to parent process */
 #define KEYCTL_REJECT			19	/* reject a partially constructed key */
 #define KEYCTL_INSTANTIATE_IOV		20	/* instantiate a partially constructed key */
+#define KEYCTL_INVALIDATE		21	/* invalidate a key */
 
 #endif /*  _LINUX_KEYCTL_H */

commit ee009e4a0d4555ed522a631bae9896399674f064
Author: David Howells <dhowells@redhat.com>
Date:   Mon Mar 7 15:06:20 2011 +0000

    KEYS: Add an iovec version of KEYCTL_INSTANTIATE
    
    Add a keyctl op (KEYCTL_INSTANTIATE_IOV) that is like KEYCTL_INSTANTIATE, but
    takes an iovec array and concatenates the data in-kernel into one buffer.
    Since the KEYCTL_INSTANTIATE copies the data anyway, this isn't too much of a
    problem.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/keyctl.h b/include/linux/keyctl.h
index 7022974def0c..9b0b865ce622 100644
--- a/include/linux/keyctl.h
+++ b/include/linux/keyctl.h
@@ -54,5 +54,6 @@
 #define KEYCTL_GET_SECURITY		17	/* get key security label */
 #define KEYCTL_SESSION_TO_PARENT	18	/* apply session keyring to parent process */
 #define KEYCTL_REJECT			19	/* reject a partially constructed key */
+#define KEYCTL_INSTANTIATE_IOV		20	/* instantiate a partially constructed key */
 
 #endif /*  _LINUX_KEYCTL_H */

commit fdd1b94581782a2ddf9124414e5b7a5f48ce2f9c
Author: David Howells <dhowells@redhat.com>
Date:   Mon Mar 7 15:06:09 2011 +0000

    KEYS: Add a new keyctl op to reject a key with a specified error code
    
    Add a new keyctl op to reject a key with a specified error code.  This works
    much the same as negating a key, and so keyctl_negate_key() is made a special
    case of keyctl_reject_key().  The difference is that keyctl_negate_key()
    selects ENOKEY as the error to be reported.
    
    Typically the key would be rejected with EKEYEXPIRED, EKEYREVOKED or
    EKEYREJECTED, but this is not mandatory.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/keyctl.h b/include/linux/keyctl.h
index bd383f1944fb..7022974def0c 100644
--- a/include/linux/keyctl.h
+++ b/include/linux/keyctl.h
@@ -53,5 +53,6 @@
 #define KEYCTL_ASSUME_AUTHORITY		16	/* assume request_key() authorisation */
 #define KEYCTL_GET_SECURITY		17	/* get key security label */
 #define KEYCTL_SESSION_TO_PARENT	18	/* apply session keyring to parent process */
+#define KEYCTL_REJECT			19	/* reject a partially constructed key */
 
 #endif /*  _LINUX_KEYCTL_H */

commit ee18d64c1f632043a02e6f5ba5e045bb26a5465f
Author: David Howells <dhowells@redhat.com>
Date:   Wed Sep 2 09:14:21 2009 +0100

    KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]
    
    Add a keyctl to install a process's session keyring onto its parent.  This
    replaces the parent's session keyring.  Because the COW credential code does
    not permit one process to change another process's credentials directly, the
    change is deferred until userspace next starts executing again.  Normally this
    will be after a wait*() syscall.
    
    To support this, three new security hooks have been provided:
    cred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in
    the blank security creds and key_session_to_parent() - which asks the LSM if
    the process may replace its parent's session keyring.
    
    The replacement may only happen if the process has the same ownership details
    as its parent, and the process has LINK permission on the session keyring, and
    the session keyring is owned by the process, and the LSM permits it.
    
    Note that this requires alteration to each architecture's notify_resume path.
    This has been done for all arches barring blackfin, m68k* and xtensa, all of
    which need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the
    replacement to be performed at the point the parent process resumes userspace
    execution.
    
    This allows the userspace AFS pioctl emulation to fully emulate newpag() and
    the VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to
    alter the parent process's PAG membership.  However, since kAFS doesn't use
    PAGs per se, but rather dumps the keys into the session keyring, the session
    keyring of the parent must be replaced if, for example, VIOCSETTOK is passed
    the newpag flag.
    
    This can be tested with the following program:
    
            #include <stdio.h>
            #include <stdlib.h>
            #include <keyutils.h>
    
            #define KEYCTL_SESSION_TO_PARENT        18
    
            #define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)
    
            int main(int argc, char **argv)
            {
                    key_serial_t keyring, key;
                    long ret;
    
                    keyring = keyctl_join_session_keyring(argv[1]);
                    OSERROR(keyring, "keyctl_join_session_keyring");
    
                    key = add_key("user", "a", "b", 1, keyring);
                    OSERROR(key, "add_key");
    
                    ret = keyctl(KEYCTL_SESSION_TO_PARENT);
                    OSERROR(ret, "KEYCTL_SESSION_TO_PARENT");
    
                    return 0;
            }
    
    Compiled and linked with -lkeyutils, you should see something like:
    
            [dhowells@andromeda ~]$ keyctl show
            Session Keyring
                   -3 --alswrv   4043  4043  keyring: _ses
            355907932 --alswrv   4043    -1   \_ keyring: _uid.4043
            [dhowells@andromeda ~]$ /tmp/newpag
            [dhowells@andromeda ~]$ keyctl show
            Session Keyring
                   -3 --alswrv   4043  4043  keyring: _ses
            1055658746 --alswrv   4043  4043   \_ user: a
            [dhowells@andromeda ~]$ /tmp/newpag hello
            [dhowells@andromeda ~]$ keyctl show
            Session Keyring
                   -3 --alswrv   4043  4043  keyring: hello
            340417692 --alswrv   4043  4043   \_ user: a
    
    Where the test program creates a new session keyring, sticks a user key named
    'a' into it and then installs it on its parent.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/keyctl.h b/include/linux/keyctl.h
index c0688eb72093..bd383f1944fb 100644
--- a/include/linux/keyctl.h
+++ b/include/linux/keyctl.h
@@ -52,5 +52,6 @@
 #define KEYCTL_SET_TIMEOUT		15	/* set key timeout */
 #define KEYCTL_ASSUME_AUTHORITY		16	/* assume request_key() authorisation */
 #define KEYCTL_GET_SECURITY		17	/* get key security label */
+#define KEYCTL_SESSION_TO_PARENT	18	/* apply session keyring to parent process */
 
 #endif /*  _LINUX_KEYCTL_H */

commit 8bbf4976b59fc9fc2861e79cab7beb3f6d647640
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:14 2008 +1100

    KEYS: Alter use of key instantiation link-to-keyring argument
    
    Alter the use of the key instantiation and negation functions' link-to-keyring
    arguments.  Currently this specifies a keyring in the target process to link
    the key into, creating the keyring if it doesn't exist.  This, however, can be
    a problem for copy-on-write credentials as it means that the instantiating
    process can alter the credentials of the requesting process.
    
    This patch alters the behaviour such that:
    
     (1) If keyctl_instantiate_key() or keyctl_negate_key() are given a specific
         keyring by ID (ringid >= 0), then that keyring will be used.
    
     (2) If keyctl_instantiate_key() or keyctl_negate_key() are given one of the
         special constants that refer to the requesting process's keyrings
         (KEY_SPEC_*_KEYRING, all <= 0), then:
    
         (a) If sys_request_key() was given a keyring to use (destringid) then the
             key will be attached to that keyring.
    
         (b) If sys_request_key() was given a NULL keyring, then the key being
             instantiated will be attached to the default keyring as set by
             keyctl_set_reqkey_keyring().
    
     (3) No extra link will be made.
    
    Decision point (1) follows current behaviour, and allows those instantiators
    who've searched for a specifically named keyring in the requestor's keyring so
    as to partition the keys by type to still have their named keyrings.
    
    Decision point (2) allows the requestor to make sure that the key or keys that
    get produced by request_key() go where they want, whilst allowing the
    instantiator to request that the key is retained.  This is mainly useful for
    situations where the instantiator makes a secondary request, the key for which
    should be retained by the initial requestor:
    
            +-----------+        +--------------+        +--------------+
            |           |        |              |        |              |
            | Requestor |------->| Instantiator |------->| Instantiator |
            |           |        |              |        |              |
            +-----------+        +--------------+        +--------------+
                       request_key()           request_key()
    
    This might be useful, for example, in Kerberos, where the requestor requests a
    ticket, and then the ticket instantiator requests the TGT, which someone else
    then has to go and fetch.  The TGT, however, should be retained in the
    keyrings of the requestor, not the first instantiator.  To make this explict
    an extra special keyring constant is also added.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: James Morris <jmorris@namei.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/keyctl.h b/include/linux/keyctl.h
index 656ee6b77a4a..c0688eb72093 100644
--- a/include/linux/keyctl.h
+++ b/include/linux/keyctl.h
@@ -1,6 +1,6 @@
 /* keyctl.h: keyctl command IDs
  *
- * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.
+ * Copyright (C) 2004, 2008 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
  *
  * This program is free software; you can redistribute it and/or
@@ -20,6 +20,7 @@
 #define KEY_SPEC_USER_SESSION_KEYRING	-5	/* - key ID for UID-session keyring */
 #define KEY_SPEC_GROUP_KEYRING		-6	/* - key ID for GID-specific keyring */
 #define KEY_SPEC_REQKEY_AUTH_KEY	-7	/* - key ID for assumed request_key auth key */
+#define KEY_SPEC_REQUESTOR_KEYRING	-8	/* - key ID for request_key() dest keyring */
 
 /* request-key default keyrings */
 #define KEY_REQKEY_DEFL_NO_CHANGE		-1
@@ -30,6 +31,7 @@
 #define KEY_REQKEY_DEFL_USER_KEYRING		4
 #define KEY_REQKEY_DEFL_USER_SESSION_KEYRING	5
 #define KEY_REQKEY_DEFL_GROUP_KEYRING		6
+#define KEY_REQKEY_DEFL_REQUESTOR_KEYRING	7
 
 /* keyctl commands */
 #define KEYCTL_GET_KEYRING_ID		0	/* ask for a keyring's ID */

commit 70a5bb72b55e82fbfbf1e22cae6975fac58a1e2d
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 29 01:01:26 2008 -0700

    keys: add keyctl function to get a security label
    
    Add a keyctl() function to get the security label of a key.
    
    The following is added to Documentation/keys.txt:
    
     (*) Get the LSM security context attached to a key.
    
            long keyctl(KEYCTL_GET_SECURITY, key_serial_t key, char *buffer,
                        size_t buflen)
    
         This function returns a string that represents the LSM security context
         attached to a key in the buffer provided.
    
         Unless there's an error, it always returns the amount of data it could
         produce, even if that's too big for the buffer, but it won't copy more
         than requested to userspace. If the buffer pointer is NULL then no copy
         will take place.
    
         A NUL character is included at the end of the string if the buffer is
         sufficiently big.  This is included in the returned count.  If no LSM is
         in force then an empty string will be returned.
    
         A process must have view permission on the key for this function to be
         successful.
    
    [akpm@linux-foundation.org: declare keyctl_get_security()]
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Paul Moore <paul.moore@hp.com>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Cc: James Morris <jmorris@namei.org>
    Cc: Kevin Coffman <kwc@citi.umich.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/keyctl.h b/include/linux/keyctl.h
index 3365945640c9..656ee6b77a4a 100644
--- a/include/linux/keyctl.h
+++ b/include/linux/keyctl.h
@@ -49,5 +49,6 @@
 #define KEYCTL_SET_REQKEY_KEYRING	14	/* set default request-key keyring */
 #define KEYCTL_SET_TIMEOUT		15	/* set key timeout */
 #define KEYCTL_ASSUME_AUTHORITY		16	/* assume request_key() authorisation */
+#define KEYCTL_GET_SECURITY		17	/* get key security label */
 
 #endif /*  _LINUX_KEYCTL_H */

commit b5f545c880a2a47947ba2118b2509644ab7a2969
Author: David Howells <dhowells@redhat.com>
Date:   Sun Jan 8 01:02:47 2006 -0800

    [PATCH] keys: Permit running process to instantiate keys
    
    Make it possible for a running process (such as gssapid) to be able to
    instantiate a key, as was requested by Trond Myklebust for NFS4.
    
    The patch makes the following changes:
    
     (1) A new, optional key type method has been added. This permits a key type
         to intercept requests at the point /sbin/request-key is about to be
         spawned and do something else with them - passing them over the
         rpc_pipefs files or netlink sockets for instance.
    
         The uninstantiated key, the authorisation key and the intended operation
         name are passed to the method.
    
     (2) The callout_info is no longer passed as an argument to /sbin/request-key
         to prevent unauthorised viewing of this data using ps or by looking in
         /proc/pid/cmdline.
    
         This means that the old /sbin/request-key program will not work with the
         patched kernel as it will expect to see an extra argument that is no
         longer there.
    
         A revised keyutils package will be made available tomorrow.
    
     (3) The callout_info is now attached to the authorisation key. Reading this
         key will retrieve the information.
    
     (4) A new field has been added to the task_struct. This holds the
         authorisation key currently active for a thread. Searches now look here
         for the caller's set of keys rather than looking for an auth key in the
         lowest level of the session keyring.
    
         This permits a thread to be servicing multiple requests at once and to
         switch between them. Note that this is per-thread, not per-process, and
         so is usable in multithreaded programs.
    
         The setting of this field is inherited across fork and exec.
    
     (5) A new keyctl function (KEYCTL_ASSUME_AUTHORITY) has been added that
         permits a thread to assume the authority to deal with an uninstantiated
         key. Assumption is only permitted if the authorisation key associated
         with the uninstantiated key is somewhere in the thread's keyrings.
    
         This function can also clear the assumption.
    
     (6) A new magic key specifier has been added to refer to the currently
         assumed authorisation key (KEY_SPEC_REQKEY_AUTH_KEY).
    
     (7) Instantiation will only proceed if the appropriate authorisation key is
         assumed first. The assumed authorisation key is discarded if
         instantiation is successful.
    
     (8) key_validate() is moved from the file of request_key functions to the
         file of permissions functions.
    
     (9) The documentation is updated.
    
    From: <Valdis.Kletnieks@vt.edu>
    
        Build fix.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Alexander Zangerl <az@bond.edu.au>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/keyctl.h b/include/linux/keyctl.h
index ec8f3d622a8d..3365945640c9 100644
--- a/include/linux/keyctl.h
+++ b/include/linux/keyctl.h
@@ -19,6 +19,7 @@
 #define KEY_SPEC_USER_KEYRING		-4	/* - key ID for UID-specific keyring */
 #define KEY_SPEC_USER_SESSION_KEYRING	-5	/* - key ID for UID-session keyring */
 #define KEY_SPEC_GROUP_KEYRING		-6	/* - key ID for GID-specific keyring */
+#define KEY_SPEC_REQKEY_AUTH_KEY	-7	/* - key ID for assumed request_key auth key */
 
 /* request-key default keyrings */
 #define KEY_REQKEY_DEFL_NO_CHANGE		-1
@@ -47,5 +48,6 @@
 #define KEYCTL_NEGATE			13	/* negate a partially constructed key */
 #define KEYCTL_SET_REQKEY_KEYRING	14	/* set default request-key keyring */
 #define KEYCTL_SET_TIMEOUT		15	/* set key timeout */
+#define KEYCTL_ASSUME_AUTHORITY		16	/* assume request_key() authorisation */
 
 #endif /*  _LINUX_KEYCTL_H */

commit 017679c4d45783158dba1dd6f79e712c22bb3d9a
Author: David Howells <dhowells@redhat.com>
Date:   Sun Jan 8 01:02:43 2006 -0800

    [PATCH] keys: Permit key expiry time to be set
    
    Add a new keyctl function that allows the expiry time to be set on a key or
    removed from a key, provided the caller has attribute modification access.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Alexander Zangerl <az@bond.edu.au>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/keyctl.h b/include/linux/keyctl.h
index 8d7c59a29e09..ec8f3d622a8d 100644
--- a/include/linux/keyctl.h
+++ b/include/linux/keyctl.h
@@ -46,5 +46,6 @@
 #define KEYCTL_INSTANTIATE		12	/* instantiate a partially constructed key */
 #define KEYCTL_NEGATE			13	/* negate a partially constructed key */
 #define KEYCTL_SET_REQKEY_KEYRING	14	/* set default request-key keyring */
+#define KEYCTL_SET_TIMEOUT		15	/* set key timeout */
 
 #endif /*  _LINUX_KEYCTL_H */

commit 3e30148c3d524a9c1c63ca28261bc24c457eb07a
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jun 23 22:00:56 2005 -0700

    [PATCH] Keys: Make request-key create an authorisation key
    
    The attached patch makes the following changes:
    
     (1) There's a new special key type called ".request_key_auth".
    
         This is an authorisation key for when one process requests a key and
         another process is started to construct it. This type of key cannot be
         created by the user; nor can it be requested by kernel services.
    
         Authorisation keys hold two references:
    
         (a) Each refers to a key being constructed. When the key being
             constructed is instantiated the authorisation key is revoked,
             rendering it of no further use.
    
         (b) The "authorising process". This is either:
    
             (i) the process that called request_key(), or:
    
             (ii) if the process that called request_key() itself had an
                  authorisation key in its session keyring, then the authorising
                  process referred to by that authorisation key will also be
                  referred to by the new authorisation key.
    
             This means that the process that initiated a chain of key requests
             will authorise the lot of them, and will, by default, wind up with
             the keys obtained from them in its keyrings.
    
     (2) request_key() creates an authorisation key which is then passed to
         /sbin/request-key in as part of a new session keyring.
    
     (3) When request_key() is searching for a key to hand back to the caller, if
         it comes across an authorisation key in the session keyring of the
         calling process, it will also search the keyrings of the process
         specified therein and it will use the specified process's credentials
         (fsuid, fsgid, groups) to do that rather than the calling process's
         credentials.
    
         This allows a process started by /sbin/request-key to find keys belonging
         to the authorising process.
    
     (4) A key can be read, even if the process executing KEYCTL_READ doesn't have
         direct read or search permission if that key is contained within the
         keyrings of a process specified by an authorisation key found within the
         calling process's session keyring, and is searchable using the
         credentials of the authorising process.
    
         This allows a process started by /sbin/request-key to read keys belonging
         to the authorising process.
    
     (5) The magic KEY_SPEC_*_KEYRING key IDs when passed to KEYCTL_INSTANTIATE or
         KEYCTL_NEGATE will specify a keyring of the authorising process, rather
         than the process doing the instantiation.
    
     (6) One of the process keyrings can be nominated as the default to which
         request_key() should attach new keys if not otherwise specified. This is
         done with KEYCTL_SET_REQKEY_KEYRING and one of the KEY_REQKEY_DEFL_*
         constants. The current setting can also be read using this call.
    
     (7) request_key() is partially interruptible. If it is waiting for another
         process to finish constructing a key, it can be interrupted. This permits
         a request-key cycle to be broken without recourse to rebooting.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-Off-By: Benoit Boissinot <benoit.boissinot@ens-lyon.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/keyctl.h b/include/linux/keyctl.h
index 381dedc370a3..8d7c59a29e09 100644
--- a/include/linux/keyctl.h
+++ b/include/linux/keyctl.h
@@ -20,6 +20,16 @@
 #define KEY_SPEC_USER_SESSION_KEYRING	-5	/* - key ID for UID-session keyring */
 #define KEY_SPEC_GROUP_KEYRING		-6	/* - key ID for GID-specific keyring */
 
+/* request-key default keyrings */
+#define KEY_REQKEY_DEFL_NO_CHANGE		-1
+#define KEY_REQKEY_DEFL_DEFAULT			0
+#define KEY_REQKEY_DEFL_THREAD_KEYRING		1
+#define KEY_REQKEY_DEFL_PROCESS_KEYRING		2
+#define KEY_REQKEY_DEFL_SESSION_KEYRING		3
+#define KEY_REQKEY_DEFL_USER_KEYRING		4
+#define KEY_REQKEY_DEFL_USER_SESSION_KEYRING	5
+#define KEY_REQKEY_DEFL_GROUP_KEYRING		6
+
 /* keyctl commands */
 #define KEYCTL_GET_KEYRING_ID		0	/* ask for a keyring's ID */
 #define KEYCTL_JOIN_SESSION_KEYRING	1	/* join or start named session keyring */
@@ -35,5 +45,6 @@
 #define KEYCTL_READ			11	/* read a key or keyring's contents */
 #define KEYCTL_INSTANTIATE		12	/* instantiate a partially constructed key */
 #define KEYCTL_NEGATE			13	/* negate a partially constructed key */
+#define KEYCTL_SET_REQKEY_KEYRING	14	/* set default request-key keyring */
 
 #endif /*  _LINUX_KEYCTL_H */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/keyctl.h b/include/linux/keyctl.h
new file mode 100644
index 000000000000..381dedc370a3
--- /dev/null
+++ b/include/linux/keyctl.h
@@ -0,0 +1,39 @@
+/* keyctl.h: keyctl command IDs
+ *
+ * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_KEYCTL_H
+#define _LINUX_KEYCTL_H
+
+/* special process keyring shortcut IDs */
+#define KEY_SPEC_THREAD_KEYRING		-1	/* - key ID for thread-specific keyring */
+#define KEY_SPEC_PROCESS_KEYRING	-2	/* - key ID for process-specific keyring */
+#define KEY_SPEC_SESSION_KEYRING	-3	/* - key ID for session-specific keyring */
+#define KEY_SPEC_USER_KEYRING		-4	/* - key ID for UID-specific keyring */
+#define KEY_SPEC_USER_SESSION_KEYRING	-5	/* - key ID for UID-session keyring */
+#define KEY_SPEC_GROUP_KEYRING		-6	/* - key ID for GID-specific keyring */
+
+/* keyctl commands */
+#define KEYCTL_GET_KEYRING_ID		0	/* ask for a keyring's ID */
+#define KEYCTL_JOIN_SESSION_KEYRING	1	/* join or start named session keyring */
+#define KEYCTL_UPDATE			2	/* update a key */
+#define KEYCTL_REVOKE			3	/* revoke a key */
+#define KEYCTL_CHOWN			4	/* set ownership of a key */
+#define KEYCTL_SETPERM			5	/* set perms on a key */
+#define KEYCTL_DESCRIBE			6	/* describe a key */
+#define KEYCTL_CLEAR			7	/* clear contents of a keyring */
+#define KEYCTL_LINK			8	/* link a key into a keyring */
+#define KEYCTL_UNLINK			9	/* unlink a key from a keyring */
+#define KEYCTL_SEARCH			10	/* search for a key in a keyring */
+#define KEYCTL_READ			11	/* read a key or keyring's contents */
+#define KEYCTL_INSTANTIATE		12	/* instantiate a partially constructed key */
+#define KEYCTL_NEGATE			13	/* negate a partially constructed key */
+
+#endif /*  _LINUX_KEYCTL_H */
