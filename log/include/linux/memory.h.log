commit 68c3a6ac65f675b4b783635787fa0ed896f5b3d5
Author: David Hildenbrand <david@redhat.com>
Date:   Mon Apr 6 20:06:40 2020 -0700

    drivers/base/memory.c: drop section_count
    
    Patch series "mm: drop superfluous section checks when onlining/offlining".
    
    Let's drop some superfluous section checks on the onlining/offlining path.
    
    This patch (of 3):
    
    Since commit c5e79ef561b0 ("mm/memory_hotplug.c: don't allow to
    online/offline memory blocks with holes") we have a generic check in
    offline_pages() that disallows offlining memory blocks with holes.
    
    Memory blocks with missing sections are just another variant of these type
    of blocks.  We can stop checking (and especially storing) present
    sections.  A proper error message is now printed why offlining failed.
    
    section_count was initially introduced in commit 07681215975e ("Driver
    core: Add section count to memory_block struct") in order to detect when
    it is okay to remove a memory block.  It was used in commit 26bbe7ef6d5c
    ("drivers/base/memory.c: prohibit offlining of memory blocks with missing
    sections") to disallow offlining memory blocks with missing sections.  As
    we refactored creation/removal of memory devices and have a proper check
    for holes in place, we can drop the section_count.
    
    This also removes a leftover comment regarding the mem_sysfs_mutex, which
    was removed in commit 848e19ad3c33 ("drivers/base/memory.c: drop the
    mem_sysfs_mutex").
    
    Signed-off-by: David Hildenbrand <david@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
    Cc: Anshuman Khandual <anshuman.khandual@arm.com>
    Link: http://lkml.kernel.org/r/20200127110424.5757-2-david@redhat.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 0b8d791b6669..439a89e758d8 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -26,7 +26,6 @@
 struct memory_block {
 	unsigned long start_section_nr;
 	unsigned long state;		/* serialized by the dev->lock */
-	int section_count;		/* serialized by mem_sysfs_mutex */
 	int online_type;		/* for passing data to online routine */
 	int phys_device;		/* to which fru does this belong? */
 	struct device dev;

commit 068964541db6dbacce26e75b390e87e63ad1c100
Author: Anshuman Khandual <anshuman.khandual@arm.com>
Date:   Thu Jan 30 22:15:16 2020 -0800

    include/linux/memory.h: drop fields 'hw' and 'phys_callback' from struct memory_block
    
    memory_block structure elements 'hw' and 'phys_callback' are not getting
    used.  This was originally added with commit 3947be1969a9 ("[PATCH]
    memory hotplug: sysfs and add/remove functions") but never seem to have
    been used.  Just drop them now.
    
    Link: http://lkml.kernel.org/r/1576728650-13867-1-git-send-email-anshuman.khandual@arm.com
    Signed-off-by: Anshuman Khandual <anshuman.khandual@arm.com>
    Reviewed-by: Dan Williams <dan.j.williams@intel.com>
    Reviewed-by: David Hildenbrand <david@redhat.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index de6bccb28f07..0b8d791b6669 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -29,8 +29,6 @@ struct memory_block {
 	int section_count;		/* serialized by mem_sysfs_mutex */
 	int online_type;		/* for passing data to online routine */
 	int phys_device;		/* to which fru does this belong? */
-	void *hw;			/* optional pointer to fw/hw data */
-	int (*phys_callback)(struct memory_block *);
 	struct device dev;
 	int nid;			/* NID for this memory block */
 };

commit 3f9903b9ca5e981b5862d7b10086d0e8caa20298
Author: David Hildenbrand <david@redhat.com>
Date:   Thu Jan 30 22:14:01 2020 -0800

    mm: remove the memory isolate notifier
    
    Luckily, we have no users left, so we can get rid of it.  Cleanup
    set_migratetype_isolate() a little bit.
    
    Link: http://lkml.kernel.org/r/20191114131911.11783-2-david@redhat.com
    Signed-off-by: David Hildenbrand <david@redhat.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Oscar Salvador <osalvador@suse.de>
    Cc: Qian Cai <cai@lca.pw>
    Cc: Anshuman Khandual <anshuman.khandual@arm.com>
    Cc: Pingfan Liu <kernelfans@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 4c75dae8dd29..de6bccb28f07 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -55,19 +55,6 @@ struct memory_notify {
 	int status_change_nid;
 };
 
-/*
- * During pageblock isolation, count the number of pages within the
- * range [start_pfn, start_pfn + nr_pages) which are owned by code
- * in the notifier chain.
- */
-#define MEM_ISOLATE_COUNT	(1<<0)
-
-struct memory_isolate_notify {
-	unsigned long start_pfn;	/* Start of range to check */
-	unsigned int nr_pages;		/* # pages in range to check */
-	unsigned int pages_found;	/* # pages owned found by callbacks */
-};
-
 struct notifier_block;
 struct mem_section;
 
@@ -94,27 +81,13 @@ static inline int memory_notify(unsigned long val, void *v)
 {
 	return 0;
 }
-static inline int register_memory_isolate_notifier(struct notifier_block *nb)
-{
-	return 0;
-}
-static inline void unregister_memory_isolate_notifier(struct notifier_block *nb)
-{
-}
-static inline int memory_isolate_notify(unsigned long val, void *v)
-{
-	return 0;
-}
 #else
 extern int register_memory_notifier(struct notifier_block *nb);
 extern void unregister_memory_notifier(struct notifier_block *nb);
-extern int register_memory_isolate_notifier(struct notifier_block *nb);
-extern void unregister_memory_isolate_notifier(struct notifier_block *nb);
 int create_memory_block_devices(unsigned long start, unsigned long size);
 void remove_memory_block_devices(unsigned long start, unsigned long size);
 extern void memory_dev_init(void);
 extern int memory_notify(unsigned long val, void *v);
-extern int memory_isolate_notify(unsigned long val, void *v);
 extern struct memory_block *find_memory_block(struct mem_section *);
 typedef int (*walk_memory_blocks_func_t)(struct memory_block *, void *);
 extern int walk_memory_blocks(unsigned long start, unsigned long size,

commit 2c91f8fc6c999fe10185d8ad99fda1759f662f70
Author: David Hildenbrand <david@redhat.com>
Date:   Fri Nov 15 17:34:57 2019 -0800

    mm/memory_hotplug: fix try_offline_node()
    
    try_offline_node() is pretty much broken right now:
    
     - The node span is updated when onlining memory, not when adding it. We
       ignore memory that was mever onlined. Bad.
    
     - We touch possible garbage memmaps. The pfn_to_nid(pfn) can easily
       trigger a kernel panic. Bad for memory that is offline but also bad
       for subsection hotadd with ZONE_DEVICE, whereby the memmap of the
       first PFN of a section might contain garbage.
    
     - Sections belonging to mixed nodes are not properly considered.
    
    As memory blocks might belong to multiple nodes, we would have to walk
    all pageblocks (or at least subsections) within present sections.
    However, we don't have a way to identify whether a memmap that is not
    online was initialized (relevant for ZONE_DEVICE).  This makes things
    more complicated.
    
    Luckily, we can piggy pack on the node span and the nid stored in memory
    blocks.  Currently, the node span is grown when calling
    move_pfn_range_to_zone() - e.g., when onlining memory, and shrunk when
    removing memory, before calling try_offline_node().  Sysfs links are
    created via link_mem_sections(), e.g., during boot or when adding
    memory.
    
    If the node still spans memory or if any memory block belongs to the
    nid, we don't set the node offline.  As memory blocks that span multiple
    nodes cannot get offlined, the nid stored in memory blocks is reliable
    enough (for such online memory blocks, the node still spans the memory).
    
    Introduce for_each_memory_block() to efficiently walk all memory blocks.
    
    Note: We will soon stop shrinking the ZONE_DEVICE zone and the node span
    when removing ZONE_DEVICE memory to fix similar issues (access of
    garbage memmaps) - until we have a reliable way to identify whether
    these memmaps were properly initialized.  This implies later, that once
    a node had ZONE_DEVICE memory, we won't be able to set a node offline -
    which should be acceptable.
    
    Since commit f1dd2cd13c4b ("mm, memory_hotplug: do not associate
    hotadded memory to zones until online") memory that is added is not
    assoziated with a zone/node (memmap not initialized).  The introducing
    commit 60a5a19e7419 ("memory-hotplug: remove sysfs file of node")
    already missed that we could have multiple nodes for a section and that
    the zone/node span is updated when onlining pages, not when adding them.
    
    I tested this by hotplugging two DIMMs to a memory-less and cpu-less
    NUMA node.  The node is properly onlined when adding the DIMMs.  When
    removing the DIMMs, the node is properly offlined.
    
    Masayoshi Mizuma reported:
    
    : Without this patch, memory hotplug fails as panic:
    :
    :  BUG: kernel NULL pointer dereference, address: 0000000000000000
    :  ...
    :  Call Trace:
    :   remove_memory_block_devices+0x81/0xc0
    :   try_remove_memory+0xb4/0x130
    :   __remove_memory+0xa/0x20
    :   acpi_memory_device_remove+0x84/0x100
    :   acpi_bus_trim+0x57/0x90
    :   acpi_bus_trim+0x2e/0x90
    :   acpi_device_hotplug+0x2b2/0x4d0
    :   acpi_hotplug_work_fn+0x1a/0x30
    :   process_one_work+0x171/0x380
    :   worker_thread+0x49/0x3f0
    :   kthread+0xf8/0x130
    :   ret_from_fork+0x35/0x40
    
    [david@redhat.com: v3]
      Link: http://lkml.kernel.org/r/20191102120221.7553-1-david@redhat.com
    Link: http://lkml.kernel.org/r/20191028105458.28320-1-david@redhat.com
    Fixes: 60a5a19e7419 ("memory-hotplug: remove sysfs file of node")
    Fixes: f1dd2cd13c4b ("mm, memory_hotplug: do not associate hotadded memory to zones until online") # visiable after d0dc12e86b319
    Signed-off-by: David Hildenbrand <david@redhat.com>
    Tested-by: Masayoshi Mizuma <m.mizuma@jp.fujitsu.com>
    Cc: Tang Chen <tangchen@cn.fujitsu.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: "Peter Zijlstra (Intel)" <peterz@infradead.org>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Nayna Jain <nayna@linux.ibm.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Oscar Salvador <osalvador@suse.de>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 0ebb105eb261..4c75dae8dd29 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -119,6 +119,7 @@ extern struct memory_block *find_memory_block(struct mem_section *);
 typedef int (*walk_memory_blocks_func_t)(struct memory_block *, void *);
 extern int walk_memory_blocks(unsigned long start, unsigned long size,
 			      void *arg, walk_memory_blocks_func_t func);
+extern int for_each_memory_block(void *arg, walk_memory_blocks_func_t func);
 #define CONFIG_MEM_BLOCK_SIZE	(PAGES_PER_SECTION<<PAGE_SHIFT)
 #endif /* CONFIG_MEMORY_HOTPLUG_SPARSE */
 

commit b6c88d3b9d38f9448e0fcf44847a075ea81d5ca2
Author: David Hildenbrand <david@redhat.com>
Date:   Mon Sep 23 15:35:49 2019 -0700

    drivers/base/memory.c: don't store end_section_nr in memory blocks
    
    Each memory block spans the same amount of sections/pages/bytes.  The size
    is determined before the first memory block is created.  No need to store
    what we can easily calculate - and the calculations even look simpler now.
    
    Michal brought up the idea of variable-sized memory blocks.  However, if
    we ever implement something like this, we will need an API compatibility
    switch and reworks at various places (most code assumes a fixed memory
    block size).  So let's cleanup what we have right now.
    
    While at it, fix the variable naming in register_mem_sect_under_node() -
    we no longer talk about a single section.
    
    Link: http://lkml.kernel.org/r/20190809110200.2746-1-david@redhat.com
    Signed-off-by: David Hildenbrand <david@redhat.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Oscar Salvador <osalvador@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index b3d9df060626..0ebb105eb261 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -25,7 +25,6 @@
 
 struct memory_block {
 	unsigned long start_section_nr;
-	unsigned long end_section_nr;
 	unsigned long state;		/* serialized by the dev->lock */
 	int section_count;		/* serialized by mem_sysfs_mutex */
 	int online_type;		/* for passing data to online routine */

commit 902ce63b337381092ff865f542e854ff3d0ebe2b
Author: David Hildenbrand <david@redhat.com>
Date:   Mon Sep 23 15:35:46 2019 -0700

    driver/base/memory.c: validate memory block size early
    
    Let's validate the memory block size early, when initializing the memory
    device infrastructure.  Fail hard in case the value is not suitable.
    
    As nobody checks the return value of memory_dev_init(), turn it into a
    void function and fail with a panic in all scenarios instead.  Otherwise,
    we'll crash later during boot when core/drivers expect that the memory
    device infrastructure (including memory_block_size_bytes()) works as
    expected.
    
    I think long term, we should move the whole memory block size
    configuration (set_memory_block_size_order() and
    memory_block_size_bytes()) into drivers/base/memory.c.
    
    Link: http://lkml.kernel.org/r/20190806090142.22709-1-david@redhat.com
    Signed-off-by: David Hildenbrand <david@redhat.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 02e633f3ede0..b3d9df060626 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -80,9 +80,9 @@ struct mem_section;
 #define IPC_CALLBACK_PRI        10
 
 #ifndef CONFIG_MEMORY_HOTPLUG_SPARSE
-static inline int memory_dev_init(void)
+static inline void memory_dev_init(void)
 {
-	return 0;
+	return;
 }
 static inline int register_memory_notifier(struct notifier_block *nb)
 {
@@ -113,7 +113,7 @@ extern int register_memory_isolate_notifier(struct notifier_block *nb);
 extern void unregister_memory_isolate_notifier(struct notifier_block *nb);
 int create_memory_block_devices(unsigned long start, unsigned long size);
 void remove_memory_block_devices(unsigned long start, unsigned long size);
-extern int memory_dev_init(void);
+extern void memory_dev_init(void);
 extern int memory_notify(unsigned long val, void *v);
 extern int memory_isolate_notify(unsigned long val, void *v);
 extern struct memory_block *find_memory_block(struct mem_section *);

commit dd625285910d3cff535fa76355e49949513918a4
Author: David Hildenbrand <david@redhat.com>
Date:   Thu Jul 18 15:57:53 2019 -0700

    drivers/base/memory.c: get rid of find_memory_block_hinted()
    
    No longer needed, let's remove it.  Also, drop the "hint" parameter
    completely from "find_memory_block_by_id", as nobody needs it anymore.
    
    [david@redhat.com: v3]
      Link: http://lkml.kernel.org/r/20190620183139.4352-7-david@redhat.com
    [david@redhat.com: handle zero-length walks]
      Link: http://lkml.kernel.org/r/1c2edc22-afd7-2211-c4c7-40e54e5007e8@redhat.com
    Link: http://lkml.kernel.org/r/20190614100114.311-7-david@redhat.com
    Signed-off-by: David Hildenbrand <david@redhat.com>
    Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
    Tested-by: Qian Cai <cai@lca.pw>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: David Hildenbrand <david@redhat.com>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
    Cc: Andrew Banman <andrew.banman@hpe.com>
    Cc: Mike Travis <mike.travis@hpe.com>
    Cc: Oscar Salvador <osalvador@suse.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Arun KS <arunks@codeaurora.org>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index b3b388775a30..02e633f3ede0 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -116,8 +116,6 @@ void remove_memory_block_devices(unsigned long start, unsigned long size);
 extern int memory_dev_init(void);
 extern int memory_notify(unsigned long val, void *v);
 extern int memory_isolate_notify(unsigned long val, void *v);
-extern struct memory_block *find_memory_block_hinted(struct mem_section *,
-							struct memory_block *);
 extern struct memory_block *find_memory_block(struct mem_section *);
 typedef int (*walk_memory_blocks_func_t)(struct memory_block *, void *);
 extern int walk_memory_blocks(unsigned long start, unsigned long size,

commit ea8846411ad686ff626e00bb2c3821b3db2ab56a
Author: David Hildenbrand <david@redhat.com>
Date:   Thu Jul 18 15:57:50 2019 -0700

    mm/memory_hotplug: move and simplify walk_memory_blocks()
    
    Let's move walk_memory_blocks() to the place where memory block logic
    resides and simplify it.  While at it, add a type for the callback
    function.
    
    Link: http://lkml.kernel.org/r/20190614100114.311-6-david@redhat.com
    Signed-off-by: David Hildenbrand <david@redhat.com>
    Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: David Hildenbrand <david@redhat.com>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
    Cc: Andrew Banman <andrew.banman@hpe.com>
    Cc: Mike Travis <mike.travis@hpe.com>
    Cc: Oscar Salvador <osalvador@suse.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Arun KS <arunks@codeaurora.org>
    Cc: Qian Cai <cai@lca.pw>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index f26a5417ec5d..b3b388775a30 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -119,6 +119,9 @@ extern int memory_isolate_notify(unsigned long val, void *v);
 extern struct memory_block *find_memory_block_hinted(struct mem_section *,
 							struct memory_block *);
 extern struct memory_block *find_memory_block(struct mem_section *);
+typedef int (*walk_memory_blocks_func_t)(struct memory_block *, void *);
+extern int walk_memory_blocks(unsigned long start, unsigned long size,
+			      void *arg, walk_memory_blocks_func_t func);
 #define CONFIG_MEM_BLOCK_SIZE	(PAGES_PER_SECTION<<PAGE_SHIFT)
 #endif /* CONFIG_MEMORY_HOTPLUG_SPARSE */
 

commit 4c4b7f9ba9486c565aead99a198ceeef73ae81f6
Author: David Hildenbrand <david@redhat.com>
Date:   Thu Jul 18 15:57:06 2019 -0700

    mm/memory_hotplug: remove memory block devices before arch_remove_memory()
    
    Let's factor out removing of memory block devices, which is only
    necessary for memory added via add_memory() and friends that created
    memory block devices.  Remove the devices before calling
    arch_remove_memory().
    
    This finishes factoring out memory block device handling from
    arch_add_memory() and arch_remove_memory().
    
    Link: http://lkml.kernel.org/r/20190527111152.16324-10-david@redhat.com
    Signed-off-by: David Hildenbrand <david@redhat.com>
    Reviewed-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: David Hildenbrand <david@redhat.com>
    Cc: "mike.travis@hpe.com" <mike.travis@hpe.com>
    Cc: Andrew Banman <andrew.banman@hpe.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Oscar Salvador <osalvador@suse.de>
    Cc: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Cc: Arun KS <arunks@codeaurora.org>
    Cc: Mathieu Malaterre <malat@debian.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Anshuman Khandual <anshuman.khandual@arm.com>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Baoquan He <bhe@redhat.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chintan Pandya <cpandya@codeaurora.org>
    Cc: Christophe Leroy <christophe.leroy@c-s.fr>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
    Cc: Jun Yao <yaojun8558363@gmail.com>
    Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
    Cc: Logan Gunthorpe <logang@deltatee.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Cc: Oscar Salvador <osalvador@suse.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Qian Cai <cai@lca.pw>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vasily Gorbik <gor@linux.ibm.com>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Yu Zhao <yuzhao@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index db3e8567f900..f26a5417ec5d 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -112,7 +112,7 @@ extern void unregister_memory_notifier(struct notifier_block *nb);
 extern int register_memory_isolate_notifier(struct notifier_block *nb);
 extern void unregister_memory_isolate_notifier(struct notifier_block *nb);
 int create_memory_block_devices(unsigned long start, unsigned long size);
-extern void unregister_memory_section(struct mem_section *);
+void remove_memory_block_devices(unsigned long start, unsigned long size);
 extern int memory_dev_init(void);
 extern int memory_notify(unsigned long val, void *v);
 extern int memory_isolate_notify(unsigned long val, void *v);

commit db051a0dac13db24d58470d75cee0ce7c6b031a1
Author: David Hildenbrand <david@redhat.com>
Date:   Thu Jul 18 15:56:56 2019 -0700

    mm/memory_hotplug: create memory block devices after arch_add_memory()
    
    Only memory to be added to the buddy and to be onlined/offlined by user
    space using /sys/devices/system/memory/...  needs (and should have!)
    memory block devices.
    
    Factor out creation of memory block devices.  Create all devices after
    arch_add_memory() succeeded.  We can later drop the want_memblock
    parameter, because it is now effectively stale.
    
    Only after memory block devices have been added, memory can be onlined
    by user space.  This implies, that memory is not visible to user space
    at all before arch_add_memory() succeeded.
    
    While at it
     - use WARN_ON_ONCE instead of BUG_ON in moved unregister_memory()
     - introduce find_memory_block_by_id() to search via block id
     - Use find_memory_block_by_id() in init_memory_block() to catch
       duplicates
    
    Link: http://lkml.kernel.org/r/20190527111152.16324-8-david@redhat.com
    Signed-off-by: David Hildenbrand <david@redhat.com>
    Reviewed-by: Pavel Tatashin <pasha.tatashin@soleen.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: David Hildenbrand <david@redhat.com>
    Cc: "mike.travis@hpe.com" <mike.travis@hpe.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Andrew Banman <andrew.banman@hpe.com>
    Cc: Oscar Salvador <osalvador@suse.de>
    Cc: Qian Cai <cai@lca.pw>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Arun KS <arunks@codeaurora.org>
    Cc: Mathieu Malaterre <malat@debian.org>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Anshuman Khandual <anshuman.khandual@arm.com>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Baoquan He <bhe@redhat.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chintan Pandya <cpandya@codeaurora.org>
    Cc: Christophe Leroy <christophe.leroy@c-s.fr>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
    Cc: Jun Yao <yaojun8558363@gmail.com>
    Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
    Cc: Logan Gunthorpe <logang@deltatee.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Cc: Oscar Salvador <osalvador@suse.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vasily Gorbik <gor@linux.ibm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Yu Zhao <yuzhao@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 474c7c60c8f2..db3e8567f900 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -111,7 +111,7 @@ extern int register_memory_notifier(struct notifier_block *nb);
 extern void unregister_memory_notifier(struct notifier_block *nb);
 extern int register_memory_isolate_notifier(struct notifier_block *nb);
 extern void unregister_memory_isolate_notifier(struct notifier_block *nb);
-int hotplug_memory_register(int nid, struct mem_section *section);
+int create_memory_block_devices(unsigned long start, unsigned long size);
 extern void unregister_memory_section(struct mem_section *);
 extern int memory_dev_init(void);
 extern int memory_notify(unsigned long val, void *v);

commit 80ec922dbd87fd38d15719c86a94457204648aeb
Author: David Hildenbrand <david@redhat.com>
Date:   Thu Jul 18 15:56:51 2019 -0700

    mm/memory_hotplug: allow arch_remove_memory() without CONFIG_MEMORY_HOTREMOVE
    
    We want to improve error handling while adding memory by allowing to use
    arch_remove_memory() and __remove_pages() even if
    CONFIG_MEMORY_HOTREMOVE is not set to e.g., implement something like:
    
            arch_add_memory()
            rc = do_something();
            if (rc) {
                    arch_remove_memory();
            }
    
    We won't get rid of CONFIG_MEMORY_HOTREMOVE for now, as it will require
    quite some dependencies for memory offlining.
    
    Link: http://lkml.kernel.org/r/20190527111152.16324-7-david@redhat.com
    Signed-off-by: David Hildenbrand <david@redhat.com>
    Reviewed-by: Pavel Tatashin <pasha.tatashin@soleen.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: David Hildenbrand <david@redhat.com>
    Cc: Oscar Salvador <osalvador@suse.com>
    Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Christophe Leroy <christophe.leroy@c-s.fr>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Cc: Vasily Gorbik <gor@linux.ibm.com>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: "mike.travis@hpe.com" <mike.travis@hpe.com>
    Cc: Andrew Banman <andrew.banman@hpe.com>
    Cc: Arun KS <arunks@codeaurora.org>
    Cc: Qian Cai <cai@lca.pw>
    Cc: Mathieu Malaterre <malat@debian.org>
    Cc: Baoquan He <bhe@redhat.com>
    Cc: Logan Gunthorpe <logang@deltatee.com>
    Cc: Anshuman Khandual <anshuman.khandual@arm.com>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chintan Pandya <cpandya@codeaurora.org>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
    Cc: Jun Yao <yaojun8558363@gmail.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Cc: Oscar Salvador <osalvador@suse.de>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Yu Zhao <yuzhao@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index e1dc1bb2b787..474c7c60c8f2 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -112,9 +112,7 @@ extern void unregister_memory_notifier(struct notifier_block *nb);
 extern int register_memory_isolate_notifier(struct notifier_block *nb);
 extern void unregister_memory_isolate_notifier(struct notifier_block *nb);
 int hotplug_memory_register(int nid, struct mem_section *section);
-#ifdef CONFIG_MEMORY_HOTREMOVE
 extern void unregister_memory_section(struct mem_section *);
-#endif
 extern int memory_dev_init(void);
 extern int memory_notify(unsigned long val, void *v);
 extern int memory_isolate_notify(unsigned long val, void *v);

commit cb7b3a3685b20d3b5900ff24b2cb96d002960189
Author: David Hildenbrand <david@redhat.com>
Date:   Mon May 13 17:21:37 2019 -0700

    mm/memory_hotplug: make unregister_memory_section() never fail
    
    Failing while removing memory is mostly ignored and cannot really be
    handled.  Let's treat errors in unregister_memory_section() in a nice way,
    warning, but continuing.
    
    Link: http://lkml.kernel.org/r/20190409100148.24703-3-david@redhat.com
    Signed-off-by: David Hildenbrand <david@redhat.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Andrew Banman <andrew.banman@hpe.com>
    Cc: Mike Travis <mike.travis@hpe.com>
    Cc: David Hildenbrand <david@redhat.com>
    Cc: Oscar Salvador <osalvador@suse.de>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Pavel Tatashin <pasha.tatashin@soleen.com>
    Cc: Qian Cai <cai@lca.pw>
    Cc: Wei Yang <richard.weiyang@gmail.com>
    Cc: Arun KS <arunks@codeaurora.org>
    Cc: Mathieu Malaterre <malat@debian.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Christophe Leroy <christophe.leroy@c-s.fr>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
    Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Cc: Oscar Salvador <osalvador@suse.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Stefan Agner <stefan@agner.ch>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vasily Gorbik <gor@linux.ibm.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index a6ddefc60517..e1dc1bb2b787 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -113,7 +113,7 @@ extern int register_memory_isolate_notifier(struct notifier_block *nb);
 extern void unregister_memory_isolate_notifier(struct notifier_block *nb);
 int hotplug_memory_register(int nid, struct mem_section *section);
 #ifdef CONFIG_MEMORY_HOTREMOVE
-extern int unregister_memory_section(struct mem_section *);
+extern void unregister_memory_section(struct mem_section *);
 #endif
 extern int memory_dev_init(void);
 extern int memory_notify(unsigned long val, void *v);

commit f642fb5864a6e3645edce6f85ffe7b44d5e9b990
Author: mike.travis@hpe.com <mike.travis@hpe.com>
Date:   Thu May 24 15:17:12 2018 -0500

    x86/platform/UV: Add adjustable set memory block size function
    
    Add a new function to "adjust" the current fixed UV memory block size
    of 2GB so it can be changed to a different physical boundary.  This is
    out of necessity so arch dependent code can accommodate specific BIOS
    requirements which can align these new PMEM modules at less than the
    default boundaries.
    
    A "set order" type of function was used to insure that the memory block
    size will be a power of two value without requiring a validity check.
    64GB was chosen as the upper limit for memory block size values to
    accommodate upcoming 4PB systems which have 6 more bits of physical
    address space (46 becoming 52).
    
    Signed-off-by: Mike Travis <mike.travis@hpe.com>
    Reviewed-by: Andrew Banman <andrew.banman@hpe.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Dimitri Sivanich <dimitri.sivanich@hpe.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Russ Anderson <russ.anderson@hpe.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: dan.j.williams@intel.com
    Cc: jgross@suse.com
    Cc: kirill.shutemov@linux.intel.com
    Cc: mhocko@suse.com
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/lkml/20180524201711.609546602@stormcage.americas.sgi.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 31ca3e28b0eb..a6ddefc60517 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -38,6 +38,7 @@ struct memory_block {
 
 int arch_get_memory_phys_device(unsigned long start_pfn);
 unsigned long memory_block_size_bytes(void);
+int set_memory_block_size_order(unsigned int order);
 
 /* These states are exposed to userspace as text strings in sysfs */
 #define	MEM_ONLINE		(1<<0) /* exposed to userspace */

commit d0dc12e86b3197a14a908d4fe7cb35b73dda82b5
Author: Pavel Tatashin <pasha.tatashin@oracle.com>
Date:   Thu Apr 5 16:23:00 2018 -0700

    mm/memory_hotplug: optimize memory hotplug
    
    During memory hotplugging we traverse struct pages three times:
    
    1. memset(0) in sparse_add_one_section()
    2. loop in __add_section() to set do: set_page_node(page, nid); and
       SetPageReserved(page);
    3. loop in memmap_init_zone() to call __init_single_pfn()
    
    This patch removes the first two loops, and leaves only loop 3.  All
    struct pages are initialized in one place, the same as it is done during
    boot.
    
    The benefits:
    
     - We improve memory hotplug performance because we are not evicting the
       cache several times and also reduce loop branching overhead.
    
     - Remove condition from hotpath in __init_single_pfn(), that was added
       in order to fix the problem that was reported by Bharata in the above
       email thread, thus also improve performance during normal boot.
    
     - Make memory hotplug more similar to the boot memory initialization
       path because we zero and initialize struct pages only in one
       function.
    
     - Simplifies memory hotplug struct page initialization code, and thus
       enables future improvements, such as multi-threading the
       initialization of struct pages in order to improve hotplug
       performance even further on larger machines.
    
    [pasha.tatashin@oracle.com: v5]
      Link: http://lkml.kernel.org/r/20180228030308.1116-7-pasha.tatashin@oracle.com
    Link: http://lkml.kernel.org/r/20180215165920.8570-7-pasha.tatashin@oracle.com
    Signed-off-by: Pavel Tatashin <pasha.tatashin@oracle.com>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Baoquan He <bhe@redhat.com>
    Cc: Bharata B Rao <bharata@linux.vnet.ibm.com>
    Cc: Daniel Jordan <daniel.m.jordan@oracle.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Mel Gorman <mgorman@techsingularity.net>
    Cc: Steven Sistare <steven.sistare@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 9f8cd856ca1e..31ca3e28b0eb 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -33,6 +33,7 @@ struct memory_block {
 	void *hw;			/* optional pointer to fw/hw data */
 	int (*phys_callback)(struct memory_block *);
 	struct device dev;
+	int nid;			/* NID for this memory block */
 };
 
 int arch_get_memory_phys_device(unsigned long start_pfn);

commit fc44f7f9231a73821fc858f5bc48883a9e78f6de
Author: Pavel Tatashin <pasha.tatashin@oracle.com>
Date:   Thu Apr 5 16:22:56 2018 -0700

    mm/memory_hotplug: don't read nid from struct page during hotplug
    
    During memory hotplugging the probe routine will leave struct pages
    uninitialized, the same as it is currently done during boot.  Therefore,
    we do not want to access the inside of struct pages before
    __init_single_page() is called during onlining.
    
    Because during hotplug we know that pages in one memory block belong to
    the same numa node, we can skip the checking.  We should keep checking
    for the boot case.
    
    [pasha.tatashin@oracle.com: s/register_new_memory()/hotplug_memory_register()]
      Link: http://lkml.kernel.org/r/20180228030308.1116-6-pasha.tatashin@oracle.com
    Link: http://lkml.kernel.org/r/20180215165920.8570-6-pasha.tatashin@oracle.com
    Signed-off-by: Pavel Tatashin <pasha.tatashin@oracle.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Cc: Baoquan He <bhe@redhat.com>
    Cc: Bharata B Rao <bharata@linux.vnet.ibm.com>
    Cc: Daniel Jordan <daniel.m.jordan@oracle.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Mel Gorman <mgorman@techsingularity.net>
    Cc: Steven Sistare <steven.sistare@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index f71e732c77b2..9f8cd856ca1e 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -109,7 +109,7 @@ extern int register_memory_notifier(struct notifier_block *nb);
 extern void unregister_memory_notifier(struct notifier_block *nb);
 extern int register_memory_isolate_notifier(struct notifier_block *nb);
 extern void unregister_memory_isolate_notifier(struct notifier_block *nb);
-extern int register_new_memory(int, struct mem_section *);
+int hotplug_memory_register(int nid, struct mem_section *section);
 #ifdef CONFIG_MEMORY_HOTREMOVE
 extern int unregister_memory_section(struct mem_section *);
 #endif

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index b723a686fc10..f71e732c77b2 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * include/linux/memory.h - generic memory definition
  *

commit dc18d706a4367454ad1fc51e06148d54e8ecfaa0
Author: Nathan Fontenot <nfont@linux.vnet.ibm.com>
Date:   Fri Feb 24 15:00:02 2017 -0800

    memory-hotplug: use dev_online for memhp_auto_online
    
    Commit 31bc3858ea3e ("add automatic onlining policy for the newly added
    memory") provides the capability to have added memory automatically
    onlined during add, but this appears to be slightly broken.
    
    The current implementation uses walk_memory_range() to call
    online_memory_block, which uses memory_block_change_state() to online
    the memory.  Instead, we should be calling device_online() for the
    memory block in online_memory_block().  This would online the memory
    (the memory bus online routine memory_subsys_online() called from
    device_online calls memory_block_change_state()) and properly update the
    device struct offline flag.
    
    As a result of the current implementation, attempting to remove a memory
    block after adding it using auto online fails.  This is because doing a
    remove, for instance
    
      echo offline > /sys/devices/system/memory/memoryXXX/state
    
    uses device_offline() which checks the dev->offline flag.
    
    Link: http://lkml.kernel.org/r/20170222220744.8119.19687.stgit@ltcalpine2-lp14.aus.stglabs.ibm.com
    Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michael Roth <mdroth@linux.vnet.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 093607f90b91..b723a686fc10 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -109,9 +109,6 @@ extern void unregister_memory_notifier(struct notifier_block *nb);
 extern int register_memory_isolate_notifier(struct notifier_block *nb);
 extern void unregister_memory_isolate_notifier(struct notifier_block *nb);
 extern int register_new_memory(int, struct mem_section *);
-extern int memory_block_change_state(struct memory_block *mem,
-				     unsigned long to_state,
-				     unsigned long from_state_req);
 #ifdef CONFIG_MEMORY_HOTREMOVE
 extern int unregister_memory_section(struct mem_section *);
 #endif

commit 8eee93e2576c303b6071368456dcd6c9a5a021c9
Merge: 1a4ab084afaa 16617535684f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 17 13:47:50 2016 -0700

    Merge tag 'char-misc-4.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc
    
    Pull char/misc updates from Greg KH:
     "Here is the big char/misc driver update for 4.6-rc1.
    
      The majority of the patches here is hwtracing and some new mic
      drivers, but there's a lot of other driver updates as well.  Full
      details in the shortlog.
    
      All have been in linux-next for a while with no reported issues"
    
    * tag 'char-misc-4.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc: (238 commits)
      goldfish: Fix build error of missing ioremap on UM
      nvmem: mediatek: Fix later provider initialization
      nvmem: imx-ocotp: Fix return value of imx_ocotp_read
      nvmem: Fix dependencies for !HAS_IOMEM archs
      char: genrtc: replace blacklist with whitelist
      drivers/hwtracing: make coresight-etm-perf.c explicitly non-modular
      drivers: char: mem: fix IS_ERROR_VALUE usage
      char: xillybus: Fix internal data structure initialization
      pch_phub: return -ENODATA if ROM can't be mapped
      Drivers: hv: vmbus: Support kexec on ws2012 r2 and above
      Drivers: hv: vmbus: Support handling messages on multiple CPUs
      Drivers: hv: utils: Remove util transport handler from list if registration fails
      Drivers: hv: util: Pass the channel information during the init call
      Drivers: hv: vmbus: avoid unneeded compiler optimizations in vmbus_wait_for_unload()
      Drivers: hv: vmbus: remove code duplication in message handling
      Drivers: hv: vmbus: avoid wait_for_completion() on crash
      Drivers: hv: vmbus: don't loose HVMSG_TIMER_EXPIRED messages
      misc: at24: replace memory_accessor with nvmem_device_read
      eeprom: 93xx46: extend driver to plug into the NVMEM framework
      eeprom: at25: extend driver to plug into the NVMEM framework
      ...

commit 31bc3858ea3ebcc3157b3f5f0e624c5962f5a7a6
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Tue Mar 15 14:56:48 2016 -0700

    memory-hotplug: add automatic onlining policy for the newly added memory
    
    Currently, all newly added memory blocks remain in 'offline' state
    unless someone onlines them, some linux distributions carry special udev
    rules like:
    
      SUBSYSTEM=="memory", ACTION=="add", ATTR{state}=="offline", ATTR{state}="online"
    
    to make this happen automatically.  This is not a great solution for
    virtual machines where memory hotplug is being used to address high
    memory pressure situations as such onlining is slow and a userspace
    process doing this (udev) has a chance of being killed by the OOM killer
    as it will probably require to allocate some memory.
    
    Introduce default policy for the newly added memory blocks in
    /sys/devices/system/memory/auto_online_blocks file with two possible
    values: "offline" which preserves the current behavior and "online"
    which causes all newly added memory blocks to go online as soon as
    they're added.  The default is "offline".
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Reviewed-by: Daniel Kiper <daniel.kiper@oracle.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Daniel Kiper <daniel.kiper@oracle.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Tang Chen <tangchen@cn.fujitsu.com>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Acked-by: David Rientjes <rientjes@google.com>
    Cc: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
    Cc: Xishi Qiu <qiuxishi@huawei.com>
    Cc: Mel Gorman <mgorman@techsingularity.net>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Igor Mammedov <imammedo@redhat.com>
    Cc: Kay Sievers <kay@vrfy.org>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 8b8d8d12348e..82730adba950 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -109,6 +109,9 @@ extern void unregister_memory_notifier(struct notifier_block *nb);
 extern int register_memory_isolate_notifier(struct notifier_block *nb);
 extern void unregister_memory_isolate_notifier(struct notifier_block *nb);
 extern int register_new_memory(int, struct mem_section *);
+extern int memory_block_change_state(struct memory_block *mem,
+				     unsigned long to_state,
+				     unsigned long from_state_req);
 #ifdef CONFIG_MEMORY_HOTREMOVE
 extern int unregister_memory_section(struct mem_section *);
 #endif

commit bec3c11bad0e7ac05fb90f204d0ab6f79945822b
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Fri Feb 26 20:59:24 2016 +0100

    misc: at24: replace memory_accessor with nvmem_device_read
    
    Now that the AT24 uses the NVMEM framework, replace the
    memory_accessor in the setup() callback with nvmem API calls.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Acked-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Tested-by: Sekhar Nori <nsekhar@ti.com>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 8b8d8d12348e..b723a686fc10 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -136,17 +136,6 @@ extern struct memory_block *find_memory_block(struct mem_section *);
 #define unregister_hotmemory_notifier(nb)  ({ (void)(nb); })
 #endif
 
-/*
- * 'struct memory_accessor' is a generic interface to provide
- * in-kernel access to persistent memory such as i2c or SPI EEPROMs
- */
-struct memory_accessor {
-	ssize_t (*read)(struct memory_accessor *, char *buf, off_t offset,
-			size_t count);
-	ssize_t (*write)(struct memory_accessor *, const char *buf,
-			 off_t offset, size_t count);
-};
-
 /*
  * Kernel text modification mutex, used for code patching. Users of this lock
  * can sleep.

commit e0a8400c6923a163265d52798cdd4c33f3f8ab5a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Oct 13 19:00:47 2014 -0600

    memory-hotplug: Remove "weak" from memory_block_size_bytes() declaration
    
    drivers/base/memory.c provides a default memory_block_size_bytes()
    definition explicitly marked "weak".  Several architectures provide their
    own definitions intended to override the default, but the "weak" attribute
    on the declaration applied to the arch definitions as well, so the linker
    chose one based on link order (see 10629d711ed7 ("PCI: Remove __weak
    annotation from pcibios_get_phb_of_node decl")).
    
    Remove the "weak" attribute from the declaration so we always prefer a
    non-weak definition over the weak one, independent of link order.
    
    Fixes: 41f107266b19 ("drivers: base: Add prototype declaration to the header file")
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Andrew Morton <akpm@linux-foundation.org>
    CC: Rashika Kheria <rashika.kheria@gmail.com>
    CC: Nathan Fontenot <nfont@austin.ibm.com>
    CC: Anton Blanchard <anton@au1.ibm.com>
    CC: Heiko Carstens <heiko.carstens@de.ibm.com>
    CC: Yinghai Lu <yinghai@kernel.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index bb7384e3c3d8..8b8d8d12348e 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -35,7 +35,7 @@ struct memory_block {
 };
 
 int arch_get_memory_phys_device(unsigned long start_pfn);
-unsigned long __weak memory_block_size_bytes(void);
+unsigned long memory_block_size_bytes(void);
 
 /* These states are exposed to userspace as text strings in sysfs */
 #define	MEM_ONLINE		(1<<0) /* exposed to userspace */

commit 41f107266b19d100c1bcef9e1e1aef00692c1209
Author: Rashika Kheria <rashika.kheria@gmail.com>
Date:   Fri Dec 20 20:38:23 2013 +0530

    drivers: base: Add prototype declaration to the header file
    
    Add prototype declaration of function memory_block_size_bytes() to
    the header file include/linux/memory.h.
    
    This eliminates the following warning in memory.c:
    drivers/base/memory.c:87:1: warning: no previous prototype for memory_block_size_bytes [-Wmissing-prototypes]
    
    Signed-off-by: Rashika Kheria <rashika.kheria@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 9a6bbf76452d..bb7384e3c3d8 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -35,6 +35,7 @@ struct memory_block {
 };
 
 int arch_get_memory_phys_device(unsigned long start_pfn);
+unsigned long __weak memory_block_size_bytes(void);
 
 /* These states are exposed to userspace as text strings in sysfs */
 #define	MEM_ONLINE		(1<<0) /* exposed to userspace */

commit fa2be40fe7c0aa3b7accbf6dfa9ef0976e191d4c
Author: Seth Jennings <sjenning@linux.vnet.ibm.com>
Date:   Tue Aug 20 16:05:05 2013 -0500

    drivers: base: use standard device online/offline for state change
    
    There are two ways to set the online/offline state for a memory block:
    echo 0|1 > online and echo online|online_kernel|online_movable|offline >
    state.
    
    The state attribute can online a memory block with extra data, the
    "online type", where the online attribute uses a default online type of
    ONLINE_KEEP, same as echo online > state.
    
    Currently there is a state_mutex that provides consistency between the
    memory block state and the underlying memory.
    
    The problem is that this code does a lot of things that the common
    device layer can do for us, such as the serialization of the
    online/offline handlers using the device lock, setting the dev->offline
    field, and calling kobject_uevent().
    
    This patch refactors the online/offline code to allow the common
    device_[online|offline] functions to be used.  The result is a simpler
    and more common code path for the two state setting mechanisms.  It also
    removes the state_mutex from the struct memory_block as the memory block
    device lock provides the state consistency.
    
    No functional change is intended by this patch.
    
    Signed-off-by: Seth Jennings <sjenning@linux.vnet.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 4c89fb0c8f4c..9a6bbf76452d 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -25,16 +25,9 @@
 struct memory_block {
 	unsigned long start_section_nr;
 	unsigned long end_section_nr;
-	unsigned long state;
-	int section_count;
-
-	/*
-	 * This serializes all state change requests.  It isn't
-	 * held during creation because the control files are
-	 * created long after the critical areas during
-	 * initialization.
-	 */
-	struct mutex state_mutex;
+	unsigned long state;		/* serialized by the dev->lock */
+	int section_count;		/* serialized by mem_sysfs_mutex */
+	int online_type;		/* for passing data to online routine */
 	int phys_device;		/* to which fru does this belong? */
 	void *hw;			/* optional pointer to fw/hw data */
 	int (*phys_callback)(struct memory_block *);

commit 37a7bd6255b415afe197489b5cd1f9568a7ae058
Author: Seth Jennings <sjenning@linux.vnet.ibm.com>
Date:   Tue Aug 20 12:13:01 2013 -0500

    drivers: base: reduce add_memory_section() for boot-time only
    
    Now that add_memory_section() is only called from boot time, reduce
    the logic and remove the enum.
    
    Signed-off-by: Seth Jennings <sjenning@linux.vnet.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 85c31a8e2904..4c89fb0c8f4c 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -125,7 +125,6 @@ extern struct memory_block *find_memory_block_hinted(struct mem_section *,
 							struct memory_block *);
 extern struct memory_block *find_memory_block(struct mem_section *);
 #define CONFIG_MEM_BLOCK_SIZE	(PAGES_PER_SECTION<<PAGE_SHIFT)
-enum mem_add_context { BOOT, HOTPLUG };
 #endif /* CONFIG_MEMORY_HOTPLUG_SPARSE */
 
 #ifdef CONFIG_MEMORY_HOTPLUG

commit ace6128d603d3f15238baba104d0b37ccf0b6c07
Author: Vincent Stehl <vincent.stehle@laposte.net>
Date:   Tue Apr 30 15:26:45 2013 -0700

    memory hotplug: fix warnings
    
    Fix the following compilation warnings:
    
      mm/slab.c: In function `kmem_cache_init_late':
      mm/slab.c:1778:2: warning: statement with no effect [-Wunused-value]
    
      mm/page_cgroup.c: In function `page_cgroup_init':
      mm/page_cgroup.c:305:2: warning: statement with no effect [-Wunused-value]
    
    Signed-off-by: Vincent Stehl <vincent.stehle@laposte.net>
    Cc: David Rientjes <rientjes@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 73817af8b480..85c31a8e2904 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -137,7 +137,7 @@ enum mem_add_context { BOOT, HOTPLUG };
 #define register_hotmemory_notifier(nb)		register_memory_notifier(nb)
 #define unregister_hotmemory_notifier(nb) 	unregister_memory_notifier(nb)
 #else
-#define hotplug_memory_notifier(fn, pri)	(0)
+#define hotplug_memory_notifier(fn, pri)	({ 0; })
 /* These aren't inline functions due to a GCC bug. */
 #define register_hotmemory_notifier(nb)    ({ (void)(nb); 0; })
 #define unregister_hotmemory_notifier(nb)  ({ (void)(nb); })

commit 4edd7ceff0662afde195da6f6c43e7cbe1ed2dc4
Author: David Rientjes <rientjes@google.com>
Date:   Mon Apr 29 15:08:22 2013 -0700

    mm, hotplug: avoid compiling memory hotremove functions when disabled
    
    __remove_pages() is only necessary for CONFIG_MEMORY_HOTREMOVE.  PowerPC
    pseries will return -EOPNOTSUPP if unsupported.
    
    Adding an #ifdef causes several other functions it depends on to also
    become unnecessary, which saves in .text when disabled (it's disabled in
    most defconfigs besides powerpc, including x86).  remove_memory_block()
    becomes static since it is not referenced outside of
    drivers/base/memory.c.
    
    Build tested on x86 and powerpc with CONFIG_MEMORY_HOTREMOVE both enabled
    and disabled.
    
    Signed-off-by: David Rientjes <rientjes@google.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Wen Congyang <wency@cn.fujitsu.com>
    Cc: Tang Chen <tangchen@cn.fujitsu.com>
    Cc: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 0ff6598ee62f..73817af8b480 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -115,9 +115,10 @@ extern void unregister_memory_notifier(struct notifier_block *nb);
 extern int register_memory_isolate_notifier(struct notifier_block *nb);
 extern void unregister_memory_isolate_notifier(struct notifier_block *nb);
 extern int register_new_memory(int, struct mem_section *);
+#ifdef CONFIG_MEMORY_HOTREMOVE
 extern int unregister_memory_section(struct mem_section *);
+#endif
 extern int memory_dev_init(void);
-extern int remove_memory_block(unsigned long, struct mem_section *, int);
 extern int memory_notify(unsigned long val, void *v);
 extern int memory_isolate_notify(unsigned long val, void *v);
 extern struct memory_block *find_memory_block_hinted(struct mem_section *,

commit f02c696800886382198df897b30bb796b46a8dae
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Mon Apr 29 15:08:04 2013 -0700

    include/linux/memory.h: implement register_hotmemory_notifier()
    
    When CONFIG_MEMORY_HOTPLUG=n, we don't want the memory-hotplug notifier
    handlers to be included in the .o files, for space reasons.
    
    The existing hotplug_memory_notifier() tries to handle this but testing
    with gcc-4.4.4 shows that it doesn't work - the hotplug functions are
    still present in the .o files.
    
    So implement a new register_hotmemory_notifier() which is a copy of
    register_hotcpu_notifier(), and which actually works as desired.
    hotplug_memory_notifier() and register_memory_notifier() callsites
    should be converted to use this new register_hotmemory_notifier().
    
    While we're there, let's repair the existing hotplug_memory_notifier():
    it simply stomps on the register_memory_notifier() return value, so
    well-behaved code cannot check for errors.  Apparently non of the
    existing callers were well-behaved :(
    
    Cc: Andrew Shewmaker <agshew@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 45e93b468878..0ff6598ee62f 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -18,6 +18,7 @@
 #include <linux/node.h>
 #include <linux/compiler.h>
 #include <linux/mutex.h>
+#include <linux/notifier.h>
 
 #define MIN_MEMORY_BLOCK_SIZE     (1UL << SECTION_SIZE_BITS)
 
@@ -127,13 +128,18 @@ enum mem_add_context { BOOT, HOTPLUG };
 #endif /* CONFIG_MEMORY_HOTPLUG_SPARSE */
 
 #ifdef CONFIG_MEMORY_HOTPLUG
-#define hotplug_memory_notifier(fn, pri) {			\
+#define hotplug_memory_notifier(fn, pri) ({		\
 	static __meminitdata struct notifier_block fn##_mem_nb =\
-		{ .notifier_call = fn, .priority = pri };	\
+		{ .notifier_call = fn, .priority = pri };\
 	register_memory_notifier(&fn##_mem_nb);			\
-}
+})
+#define register_hotmemory_notifier(nb)		register_memory_notifier(nb)
+#define unregister_hotmemory_notifier(nb) 	unregister_memory_notifier(nb)
 #else
-#define hotplug_memory_notifier(fn, pri) do { } while (0)
+#define hotplug_memory_notifier(fn, pri)	(0)
+/* These aren't inline functions due to a GCC bug. */
+#define register_hotmemory_notifier(nb)    ({ (void)(nb); 0; })
+#define unregister_hotmemory_notifier(nb)  ({ (void)(nb); })
 #endif
 
 /*

commit 6715ddf94576ff39f5d1cda8d4c568d3b79e82ec
Author: Lai Jiangshan <laijs@cn.fujitsu.com>
Date:   Wed Dec 12 13:51:49 2012 -0800

    hotplug: update nodemasks management
    
    Update nodemasks management for N_MEMORY.
    
    [lliubbo@gmail.com: fix build]
    Signed-off-by: Lai Jiangshan <laijs@cn.fujitsu.com>
    Signed-off-by: Wen Congyang <wency@cn.fujitsu.com>
    Cc: Christoph Lameter <cl@linux.com>
    Cc: Hillf Danton <dhillf@gmail.com>
    Cc: Lin Feng <linfeng@cn.fujitsu.com>
    Cc: David Rientjes <rientjes@google.com>
    Signed-off-by: Bob Liu <lliubbo@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index a09216d0dcc7..45e93b468878 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -54,6 +54,7 @@ struct memory_notify {
 	unsigned long start_pfn;
 	unsigned long nr_pages;
 	int status_change_nid_normal;
+	int status_change_nid_high;
 	int status_change_nid;
 };
 

commit d9713679dbd2a6ecb840cd5b65a3ec555c1ec3d4
Author: Lai Jiangshan <laijs@cn.fujitsu.com>
Date:   Tue Dec 11 16:01:03 2012 -0800

    memory_hotplug: fix possible incorrect node_states[N_NORMAL_MEMORY]
    
    Currently memory_hotplug only manages the node_states[N_HIGH_MEMORY], it
    forgets to manage node_states[N_NORMAL_MEMORY].  This may cause
    node_states[N_NORMAL_MEMORY] to become incorrect.
    
    Example, if a node is empty before online, and we online a memory which is
    in ZONE_NORMAL.  And after online, node_states[N_HIGH_MEMORY] is correct,
    but node_states[N_NORMAL_MEMORY] is incorrect, the online code doesn't set
    the new online node to node_states[N_NORMAL_MEMORY].
    
    The same thing will happen when offlining (the offline code doesn't clear
    the node from node_states[N_NORMAL_MEMORY] when needed).  Some memory
    managment code depends node_states[N_NORMAL_MEMORY], so we have to fix up
    the node_states[N_NORMAL_MEMORY].
    
    We add node_states_check_changes_online() and
    node_states_check_changes_offline() to detect whether
    node_states[N_HIGH_MEMORY] and node_states[N_NORMAL_MEMORY] are changed
    while hotpluging.
    
    Also add @status_change_nid_normal to struct memory_notify, thus the
    memory hotplug callbacks know whether the node_states[N_NORMAL_MEMORY] are
    changed.  (We can add a @flags and reuse @status_change_nid instead of
    introducing @status_change_nid_normal, but it will add much more
    complexity in memory hotplug callback in every subsystem.  So introducing
    @status_change_nid_normal is better and it doesn't change the sematics of
    @status_change_nid)
    
    Signed-off-by: Lai Jiangshan <laijs@cn.fujitsu.com>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Minchan Kim <minchan.kim@gmail.com>
    Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Cc: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Cc: Rob Landley <rob@landley.net>
    Cc: Jiang Liu <jiang.liu@huawei.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Wen Congyang <wency@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index ff9a9f8e0ed9..a09216d0dcc7 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -53,6 +53,7 @@ int arch_get_memory_phys_device(unsigned long start_pfn);
 struct memory_notify {
 	unsigned long start_pfn;
 	unsigned long nr_pages;
+	int status_change_nid_normal;
 	int status_change_nid;
 };
 

commit 05cf96398e1b6502f9e191291b715c7463c9d5dd
Author: Jianguo Wu <wujianguo@huawei.com>
Date:   Mon Sep 17 14:08:56 2012 -0700

    mm/ia64: fix a memory block size bug
    
    I found following definition in include/linux/memory.h, in my IA64
    platform, SECTION_SIZE_BITS is equal to 32, and MIN_MEMORY_BLOCK_SIZE
    will be 0.
    
      #define MIN_MEMORY_BLOCK_SIZE     (1 << SECTION_SIZE_BITS)
    
    Because MIN_MEMORY_BLOCK_SIZE is int type and length of 32bits,
    so MIN_MEMORY_BLOCK_SIZE(1 << 32) will will equal to 0.
    Actually when SECTION_SIZE_BITS >= 31, MIN_MEMORY_BLOCK_SIZE will be wrong.
    This will cause wrong system memory infomation in sysfs.
    I think it should be:
    
      #define MIN_MEMORY_BLOCK_SIZE     (1UL << SECTION_SIZE_BITS)
    
    And "echo offline > memory0/state" will cause following call trace:
    
      kernel BUG at mm/memory_hotplug.c:885!
      sh[6455]: bugcheck! 0 [1]
      Pid: 6455, CPU 0, comm:                   sh
      psr : 0000101008526030 ifs : 8000000000000fa4 ip  : [<a0000001008c40f0>]    Not tainted (3.6.0-rc1)
      ip is at offline_pages+0x210/0xee0
      Call Trace:
        show_stack+0x80/0xa0
        show_regs+0x640/0x920
        die+0x190/0x2c0
        die_if_kernel+0x50/0x80
        ia64_bad_break+0x3d0/0x6e0
        ia64_native_leave_kernel+0x0/0x270
        offline_pages+0x210/0xee0
        alloc_pages_current+0x180/0x2a0
    
    Signed-off-by: Jianguo Wu <wujianguo@huawei.com>
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Reviewed-by: Michal Hocko <mhocko@suse.cz>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 1ac7f6e405f9..ff9a9f8e0ed9 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -19,7 +19,7 @@
 #include <linux/compiler.h>
 #include <linux/mutex.h>
 
-#define MIN_MEMORY_BLOCK_SIZE     (1 << SECTION_SIZE_BITS)
+#define MIN_MEMORY_BLOCK_SIZE     (1UL << SECTION_SIZE_BITS)
 
 struct memory_block {
 	unsigned long start_section_nr;

commit 10fbcf4c6cb122005cdf36fc24d7683da92c7a27
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Dec 21 14:48:43 2011 -0800

    convert 'memory' sysdev_class to a regular subsystem
    
    This moves the 'memory sysdev_class' over to a regular 'memory' subsystem
    and converts the devices to regular devices. The sysdev drivers are
    implemented as subsystem interfaces now.
    
    After all sysdev classes are ported to regular driver core entities, the
    sysdev implementation will be entirely removed from the kernel.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 935699b30b7c..1ac7f6e405f9 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -15,7 +15,6 @@
 #ifndef _LINUX_MEMORY_H_
 #define _LINUX_MEMORY_H_
 
-#include <linux/sysdev.h>
 #include <linux/node.h>
 #include <linux/compiler.h>
 #include <linux/mutex.h>
@@ -38,7 +37,7 @@ struct memory_block {
 	int phys_device;		/* to which fru does this belong? */
 	void *hw;			/* optional pointer to fw/hw data */
 	int (*phys_callback)(struct memory_block *);
-	struct sys_device sysdev;
+	struct device dev;
 };
 
 int arch_get_memory_phys_device(unsigned long start_pfn);

commit a63fdc5156f2ef5690b6cf03d72b0c4917efbba7
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jun 14 10:57:50 2011 +1000

    mm: Move definition of MIN_MEMORY_BLOCK_SIZE to a header
    
    The macro MIN_MEMORY_BLOCK_SIZE is currently defined twice in two .c
    files, and I need it in a third one to fix a powerpc bug, so let's
    first move it into a header
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index e1e3b2b84f85..935699b30b7c 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -20,6 +20,8 @@
 #include <linux/compiler.h>
 #include <linux/mutex.h>
 
+#define MIN_MEMORY_BLOCK_SIZE     (1 << SECTION_SIZE_BITS)
+
 struct memory_block {
 	unsigned long start_section_nr;
 	unsigned long end_section_nr;

commit d33601644cd3b09afb2edd9474517edc441c8fad
Author: Nathan Fontenot <nfont@austin.ibm.com>
Date:   Thu Jan 20 10:44:29 2011 -0600

    memory hotplug: Update phys_index to [start|end]_section_nr
    
    Update the 'phys_index' property of a the memory_block struct to be
    called start_section_nr, and add a end_section_nr property.  The
    data tracked here is the same but the updated naming is more in line
    with what is stored here, namely the first and last section number
    that the memory block spans.
    
    The names presented to userspace remain the same, phys_index for
    start_section_nr and end_phys_index for end_section_nr, to avoid breaking
    anything in userspace.
    
    This also updates the node sysfs code to be aware of the new capability for
    a memory block to contain multiple memory sections and be aware of the memory
    block structure name changes (start_section_nr).  This requires an additional
    parameter to unregister_mem_sect_under_nodes so that we know which memory
    section of the memory block to unregister.
    
    Signed-off-by: Nathan Fontenot <nfont@austin.ibm.com>
    Reviewed-by: Robin Holt <holt@sgi.com>
    Reviewed-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 06c1fa0a5c7b..e1e3b2b84f85 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -21,7 +21,8 @@
 #include <linux/mutex.h>
 
 struct memory_block {
-	unsigned long phys_index;
+	unsigned long start_section_nr;
+	unsigned long end_section_nr;
 	unsigned long state;
 	int section_count;
 

commit 07681215975e05a1454b0afdeef07deb0db626ee
Author: Nathan Fontenot <nfont@austin.ibm.com>
Date:   Tue Oct 19 12:46:19 2010 -0500

    Driver core: Add section count to memory_block struct
    
    Add a section count property to the memory_block struct to track the number
    of memory sections that have been added/removed from a memory block. This
    allows us to know when the last memory section of a memory block has been
    removed so we can remove the memory block.
    
    Signed-off-by: Nathan Fontenot <nfont@austin.ibm.com>
    Reviewed-by: Robin Holt <holt@sgi.com>
    Reviewed-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index c4f3127dbd48..06c1fa0a5c7b 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -23,6 +23,8 @@
 struct memory_block {
 	unsigned long phys_index;
 	unsigned long state;
+	int section_count;
+
 	/*
 	 * This serializes all state change requests.  It isn't
 	 * held during creation because the control files are

commit 98383031ed77c6eb49ab612166fef9c0efe1604a
Author: Robin Holt <holt@sgi.com>
Date:   Wed Sep 29 14:00:55 2010 -0500

    driver core: Introduce find_memory_block_hinted which utilizes kset_find_obj_hinted.
    
    Introduce a find_memory_block_hinted() which utilizes the
    recently added kset_find_obj_hinted().
    
    Signed-off-by: Robin Holt <holt@sgi.com>
    To: Dave Hansen <haveblue@us.ibm.com>
    To: Matt Tolentino <matthew.e.tolentino@intel.com>
    Reviewed-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 85582e1bcee9..c4f3127dbd48 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -113,6 +113,8 @@ extern int memory_dev_init(void);
 extern int remove_memory_block(unsigned long, struct mem_section *, int);
 extern int memory_notify(unsigned long val, void *v);
 extern int memory_isolate_notify(unsigned long val, void *v);
+extern struct memory_block *find_memory_block_hinted(struct mem_section *,
+							struct memory_block *);
 extern struct memory_block *find_memory_block(struct mem_section *);
 #define CONFIG_MEM_BLOCK_SIZE	(PAGES_PER_SECTION<<PAGE_SHIFT)
 enum mem_add_context { BOOT, HOTPLUG };

commit bc32df00894f0e1dbf583cc3dab210d2969b078a
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Mon Mar 15 00:35:03 2010 -0400

    memory hotplug: allow setting of phys_device
    
    /sys/devices/system/memory/memoryX/phys_device is supposed to contain the
    number of the physical device that the corresponding piece of memory
    belongs to.
    
    In case a physical device should be replaced or taken offline for whatever
    reason it is necessary to set all corresponding memory pieces offline.
    The current implementation always sets phys_device to '0' and there is no
    way or hook to change that.  Seems like there was a plan to implement that
    but it wasn't finished for whatever reason.
    
    So add a weak function which architectures can override to actually set
    the phys_device from within add_memory_block().
    
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Dave Hansen <haveblue@us.ibm.com>
    Cc: Gerald Schaefer <gerald.schaefer@de.ibm.com>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 1adfe779eb99..85582e1bcee9 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -36,6 +36,8 @@ struct memory_block {
 	struct sys_device sysdev;
 };
 
+int arch_get_memory_phys_device(unsigned long start_pfn);
+
 /* These states are exposed to userspace as text strings in sysfs */
 #define	MEM_ONLINE		(1<<0) /* exposed to userspace */
 #define	MEM_GOING_OFFLINE	(1<<1) /* exposed to userspace */

commit 925cc71e512a29e2594bcc17dc58d0a0e9c4d524
Author: Robert Jennings <rcj@linux.vnet.ibm.com>
Date:   Thu Dec 17 14:44:38 2009 +0000

    mm: Add notifier in pageblock isolation for balloon drivers
    
    Memory balloon drivers can allocate a large amount of memory which is not
    movable but could be freed to accomodate memory hotplug remove.
    
    Prior to calling the memory hotplug notifier chain the memory in the
    pageblock is isolated.  Currently, if the migrate type is not
    MIGRATE_MOVABLE the isolation will not proceed, causing the memory removal
    for that page range to fail.
    
    Rather than failing pageblock isolation if the migrateteype is not
    MIGRATE_MOVABLE, this patch checks if all of the pages in the pageblock,
    and not on the LRU, are owned by a registered balloon driver (or other
    entity) using a notifier chain.  If all of the non-movable pages are owned
    by a balloon, they can be freed later through the memory notifier chain
    and the range can still be isolated in set_migratetype_isolate().
    
    Signed-off-by: Robert Jennings <rcj@linux.vnet.ibm.com>
    Cc: Mel Gorman <mel@csn.ul.ie>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Brian King <brking@linux.vnet.ibm.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Gerald Schaefer <geralds@linux.vnet.ibm.com>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 37fa19b34ef5..1adfe779eb99 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -50,6 +50,19 @@ struct memory_notify {
 	int status_change_nid;
 };
 
+/*
+ * During pageblock isolation, count the number of pages within the
+ * range [start_pfn, start_pfn + nr_pages) which are owned by code
+ * in the notifier chain.
+ */
+#define MEM_ISOLATE_COUNT	(1<<0)
+
+struct memory_isolate_notify {
+	unsigned long start_pfn;	/* Start of range to check */
+	unsigned int nr_pages;		/* # pages in range to check */
+	unsigned int pages_found;	/* # pages owned found by callbacks */
+};
+
 struct notifier_block;
 struct mem_section;
 
@@ -76,14 +89,28 @@ static inline int memory_notify(unsigned long val, void *v)
 {
 	return 0;
 }
+static inline int register_memory_isolate_notifier(struct notifier_block *nb)
+{
+	return 0;
+}
+static inline void unregister_memory_isolate_notifier(struct notifier_block *nb)
+{
+}
+static inline int memory_isolate_notify(unsigned long val, void *v)
+{
+	return 0;
+}
 #else
 extern int register_memory_notifier(struct notifier_block *nb);
 extern void unregister_memory_notifier(struct notifier_block *nb);
+extern int register_memory_isolate_notifier(struct notifier_block *nb);
+extern void unregister_memory_isolate_notifier(struct notifier_block *nb);
 extern int register_new_memory(int, struct mem_section *);
 extern int unregister_memory_section(struct mem_section *);
 extern int memory_dev_init(void);
 extern int remove_memory_block(unsigned long, struct mem_section *, int);
 extern int memory_notify(unsigned long val, void *v);
+extern int memory_isolate_notify(unsigned long val, void *v);
 extern struct memory_block *find_memory_block(struct mem_section *);
 #define CONFIG_MEM_BLOCK_SIZE	(PAGES_PER_SECTION<<PAGE_SHIFT)
 enum mem_add_context { BOOT, HOTPLUG };

commit 714f83d5d9f7c785f622259dad1f4fad12d64664
Merge: 8901e7ffc2fa 645dae969c3b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 5 11:04:19 2009 -0700

    Merge branch 'tracing-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'tracing-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (413 commits)
      tracing, net: fix net tree and tracing tree merge interaction
      tracing, powerpc: fix powerpc tree and tracing tree interaction
      ring-buffer: do not remove reader page from list on ring buffer free
      function-graph: allow unregistering twice
      trace: make argument 'mem' of trace_seq_putmem() const
      tracing: add missing 'extern' keywords to trace_output.h
      tracing: provide trace_seq_reserve()
      blktrace: print out BLK_TN_MESSAGE properly
      blktrace: extract duplidate code
      blktrace: fix memory leak when freeing struct blk_io_trace
      blktrace: fix blk_probes_ref chaos
      blktrace: make classic output more classic
      blktrace: fix off-by-one bug
      blktrace: fix the original blktrace
      blktrace: fix a race when creating blk_tree_root in debugfs
      blktrace: fix timestamp in binary output
      tracing, Text Edit Lock: cleanup
      tracing: filter fix for TRACE_EVENT_FORMAT events
      ftrace: Using FTRACE_WARN_ON() to check "freed record" in ftrace_release()
      x86: kretprobe-booster interrupt emulation code fix
      ...
    
    Fix up trivial conflicts in
     arch/parisc/include/asm/ftrace.h
     include/linux/memory.h
     kernel/extable.c
     kernel/module.c

commit 06c421ee0d5af95c8c6749ca0ba620cd5010707f
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Thu Apr 2 16:56:56 2009 -0700

    memory_accessor: new interface for reading/writing persistent memory
    
    Add an interface by which other kernel code can read/write persistent
    memory such as I2C or SPI EEPROMs, or devices which provide NVRAM.  Use
    cases include storage of board-specific configuration data like Ethernet
    addresses and sensor calibrations.
    
    Original idea, review and improvement suggestions by David Brownell.
    
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 3fdc10806d31..42767d1a62e7 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -99,4 +99,15 @@ enum mem_add_context { BOOT, HOTPLUG };
 #define hotplug_memory_notifier(fn, pri) do { } while (0)
 #endif
 
+/*
+ * 'struct memory_accessor' is a generic interface to provide
+ * in-kernel access to persistent memory such as i2c or SPI EEPROMs
+ */
+struct memory_accessor {
+	ssize_t (*read)(struct memory_accessor *, char *buf, off_t offset,
+			size_t count);
+	ssize_t (*write)(struct memory_accessor *, const char *buf,
+			 off_t offset, size_t count);
+};
+
 #endif /* _LINUX_MEMORY_H_ */

commit 0e39ac444636ff5be39b26f1cb56d79594654dda
Author: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date:   Fri Mar 6 10:35:52 2009 -0500

    tracing, Text Edit Lock - Architecture Independent Code
    
    This is an architecture independant synchronization around kernel text
    modifications through use of a global mutex.
    
    A mutex has been chosen so that kprobes, the main user of this, can sleep
    during memory allocation between the memory read of the instructions it
    must replace and the memory write of the breakpoint.
    
    Other user of this interface: immediate values.
    
    Paravirt and alternatives are always done when SMP is inactive, so there
    is no need to use locks.
    
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    LKML-Reference: <49B142D8.7020601@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 3fdc10806d31..86a6c0f0518d 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -99,4 +99,10 @@ enum mem_add_context { BOOT, HOTPLUG };
 #define hotplug_memory_notifier(fn, pri) do { } while (0)
 #endif
 
+/*
+ * Kernel text modification mutex, used for code patching. Users of this lock
+ * can sleep.
+ */
+extern struct mutex text_mutex;
+
 #endif /* _LINUX_MEMORY_H_ */

commit c04fc586c1a480ba198f03ae7b6cbd7b57380b91
Author: Gary Hade <garyhade@us.ibm.com>
Date:   Tue Jan 6 14:39:14 2009 -0800

    mm: show node to memory section relationship with symlinks in sysfs
    
    Show node to memory section relationship with symlinks in sysfs
    
    Add /sys/devices/system/node/nodeX/memoryY symlinks for all
    the memory sections located on nodeX.  For example:
    /sys/devices/system/node/node1/memory135 -> ../../memory/memory135
    indicates that memory section 135 resides on node1.
    
    Also revises documentation to cover this change as well as updating
    Documentation/ABI/testing/sysfs-devices-memory to include descriptions
    of memory hotremove files 'phys_device', 'phys_index', and 'state'
    that were previously not described there.
    
    In addition to it always being a good policy to provide users with
    the maximum possible amount of physical location information for
    resources that can be hot-added and/or hot-removed, the following
    are some (but likely not all) of the user benefits provided by
    this change.
    Immediate:
      - Provides information needed to determine the specific node
        on which a defective DIMM is located.  This will reduce system
        downtime when the node or defective DIMM is swapped out.
      - Prevents unintended onlining of a memory section that was
        previously offlined due to a defective DIMM.  This could happen
        during node hot-add when the user or node hot-add assist script
        onlines _all_ offlined sections due to user or script inability
        to identify the specific memory sections located on the hot-added
        node.  The consequences of reintroducing the defective memory
        could be ugly.
      - Provides information needed to vary the amount and distribution
        of memory on specific nodes for testing or debugging purposes.
    Future:
      - Will provide information needed to identify the memory
        sections that need to be offlined prior to physical removal
        of a specific node.
    
    Symlink creation during boot was tested on 2-node x86_64, 2-node
    ppc64, and 2-node ia64 systems.  Symlink creation during physical
    memory hot-add tested on a 2-node x86_64 system.
    
    Signed-off-by: Gary Hade <garyhade@us.ibm.com>
    Signed-off-by: Badari Pulavarty <pbadari@us.ibm.com>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 36c82c9e6ea7..3fdc10806d31 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -79,14 +79,14 @@ static inline int memory_notify(unsigned long val, void *v)
 #else
 extern int register_memory_notifier(struct notifier_block *nb);
 extern void unregister_memory_notifier(struct notifier_block *nb);
-extern int register_new_memory(struct mem_section *);
+extern int register_new_memory(int, struct mem_section *);
 extern int unregister_memory_section(struct mem_section *);
 extern int memory_dev_init(void);
 extern int remove_memory_block(unsigned long, struct mem_section *, int);
 extern int memory_notify(unsigned long val, void *v);
+extern struct memory_block *find_memory_block(struct mem_section *);
 #define CONFIG_MEM_BLOCK_SIZE	(PAGES_PER_SECTION<<PAGE_SHIFT)
-
-
+enum mem_add_context { BOOT, HOTPLUG };
 #endif /* CONFIG_MEMORY_HOTPLUG_SPARSE */
 
 #ifdef CONFIG_MEMORY_HOTPLUG

commit 02d0e6753d8ab0173b63338157929e52eac86d12
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Nov 22 17:38:34 2008 +0000

    hotplug_memory_notifier section annotation
    
    Same as for hotplug_cpu - we want static notifier_block in there in meminitdata,
    to avoid false positives whenever it's used.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 2f5f8a5ef2a0..36c82c9e6ea7 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -91,7 +91,7 @@ extern int memory_notify(unsigned long val, void *v);
 
 #ifdef CONFIG_MEMORY_HOTPLUG
 #define hotplug_memory_notifier(fn, pri) {			\
-	static struct notifier_block fn##_mem_nb =		\
+	static __meminitdata struct notifier_block fn##_mem_nb =\
 		{ .notifier_call = fn, .priority = pri };	\
 	register_memory_notifier(&fn##_mem_nb);			\
 }

commit b6b337ad1c1d6fe11b09b35d75464b84b3e11f07
Author: Nadia Derbey <Nadia.Derbey@bull.net>
Date:   Tue Apr 29 01:00:42 2008 -0700

    ipc: recompute msgmni on memory add / remove
    
    Introduce the registration of a callback routine that recomputes msg_ctlmni
    upon memory add / remove.
    
    A single notifier block is registered in the hotplug memory chain for all the
    ipc namespaces.
    
    Since the ipc namespaces are not linked together, they have their own
    notification chain: one notifier_block is defined per ipc namespace.
    
    Each time an ipc namespace is created (removed) it registers (unregisters) its
    notifier block in (from) the ipcns chain.  The callback routine registered in
    the memory chain invokes the ipcns notifier chain with the IPCNS_LOWMEM event.
     Each callback routine registered in the ipcns namespace, in turn, recomputes
    msgmni for the owning namespace.
    
    Signed-off-by: Nadia Derbey <Nadia.Derbey@bull.net>
    Cc: Yasunori Goto <y-goto@jp.fujitsu.com>
    Cc: Matt Helsley <matthltc@us.ibm.com>
    Cc: Mingming Cao <cmm@us.ibm.com>
    Cc: Pierre Peiffer <pierre.peiffer@bull.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 39628dfe4a4c..2f5f8a5ef2a0 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -58,6 +58,7 @@ struct mem_section;
  * order in the callback chain)
  */
 #define SLAB_CALLBACK_PRI       1
+#define IPC_CALLBACK_PRI        10
 
 #ifndef CONFIG_MEMORY_HOTPLUG_SPARSE
 static inline int memory_dev_init(void)

commit 0c40ba4fd64f98e7a5cba8ffaedbd68642a85700
Author: Nadia Derbey <Nadia.Derbey@bull.net>
Date:   Tue Apr 29 01:00:41 2008 -0700

    ipc: define the slab_memory_callback priority as a constant
    
    This is a trivial patch that defines the priority of slab_memory_callback in
    the callback chain as a constant.  This is to prepare for next patch in the
    series.
    
    Signed-off-by: Nadia Derbey <Nadia.Derbey@bull.net>
    Cc: Yasunori Goto <y-goto@jp.fujitsu.com>
    Cc: Matt Helsley <matthltc@us.ibm.com>
    Cc: Mingming Cao <cmm@us.ibm.com>
    Cc: Pierre Peiffer <pierre.peiffer@bull.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index f80e0e331cb7..39628dfe4a4c 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -53,6 +53,12 @@ struct memory_notify {
 struct notifier_block;
 struct mem_section;
 
+/*
+ * Priorities for the hotplug memory callback routines (stored in decreasing
+ * order in the callback chain)
+ */
+#define SLAB_CALLBACK_PRI       1
+
 #ifndef CONFIG_MEMORY_HOTPLUG_SPARSE
 static inline int memory_dev_init(void)
 {

commit da19cbcf71cde3c09587b5924d113f0c7f1fd23a
Author: Daniel Walker <dwalker@mvista.com>
Date:   Mon Feb 4 23:35:47 2008 -0800

    driver core: memory: semaphore to mutex
    
    Signed-off-by: Daniel Walker <dwalker@mvista.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 33f0ff0cf634..f80e0e331cb7 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -18,8 +18,7 @@
 #include <linux/sysdev.h>
 #include <linux/node.h>
 #include <linux/compiler.h>
-
-#include <asm/semaphore.h>
+#include <linux/mutex.h>
 
 struct memory_block {
 	unsigned long phys_index;
@@ -30,7 +29,7 @@ struct memory_block {
 	 * created long after the critical areas during
 	 * initialization.
 	 */
-	struct semaphore state_sem;
+	struct mutex state_mutex;
 	int phys_device;		/* to which fru does this belong? */
 	void *hw;			/* optional pointer to fw/hw data */
 	int (*phys_callback)(struct memory_block *);

commit b9049e234401e1fad8459d69a952b174d76c399d
Author: Yasunori Goto <y-goto@jp.fujitsu.com>
Date:   Sun Oct 21 16:41:37 2007 -0700

    memory hotplug: make kmem_cache_node for SLUB on memory online avoid panic
    
    Fix a panic due to access NULL pointer of kmem_cache_node at discard_slab()
    after memory online.
    
    When memory online is called, kmem_cache_nodes are created for all SLUBs
    for new node whose memory are available.
    
    slab_mem_going_online_callback() is called to make kmem_cache_node() in
    callback of memory online event.  If it (or other callbacks) fails, then
    slab_mem_offline_callback() is called for rollback.
    
    In memory offline, slab_mem_going_offline_callback() is called to shrink
    all slub cache, then slab_mem_offline_callback() is called later.
    
    [akpm@linux-foundation.org: coding-style fixes]
    [akpm@linux-foundation.org: locking fix]
    [akpm@linux-foundation.org: build fix]
    Signed-off-by: Yasunori Goto <y-goto@jp.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index ec376e482abb..33f0ff0cf634 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -83,10 +83,14 @@ extern int memory_notify(unsigned long val, void *v);
 
 #endif /* CONFIG_MEMORY_HOTPLUG_SPARSE */
 
+#ifdef CONFIG_MEMORY_HOTPLUG
 #define hotplug_memory_notifier(fn, pri) {			\
 	static struct notifier_block fn##_mem_nb =		\
 		{ .notifier_call = fn, .priority = pri };	\
 	register_memory_notifier(&fn##_mem_nb);			\
 }
+#else
+#define hotplug_memory_notifier(fn, pri) do { } while (0)
+#endif
 
 #endif /* _LINUX_MEMORY_H_ */

commit 7b78d335ac15b10bbcb0397c635d7f0d569b0270
Author: Yasunori Goto <y-goto@jp.fujitsu.com>
Date:   Sun Oct 21 16:41:36 2007 -0700

    memory hotplug: rearrange memory hotplug notifier
    
    Current memory notifier has some defects yet.  (Fortunately, nothing uses
    it.) This patch is to fix and rearrange for them.
    
      - Add information of start_pfn, nr_pages, and node id if node status is
        changes from/to memoryless node for callback functions.
        Callbacks can't do anything without those information.
      - Add notification going-online status.
        It is necessary for creating per node structure before the node's
        pages are available.
      - Move GOING_OFFLINE status notification after page isolation.
        It is good place for return memory like cache for callback,
        because returned page is not used again.
      - Make CANCEL events for rollingback when error occurs.
      - Delete MEM_MAPPING_INVALID notification. It will be not used.
      - Fix compile error of (un)register_memory_notifier().
    
    Signed-off-by: Yasunori Goto <y-goto@jp.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 654ef5544878..ec376e482abb 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -41,18 +41,15 @@ struct memory_block {
 #define	MEM_ONLINE		(1<<0) /* exposed to userspace */
 #define	MEM_GOING_OFFLINE	(1<<1) /* exposed to userspace */
 #define	MEM_OFFLINE		(1<<2) /* exposed to userspace */
+#define	MEM_GOING_ONLINE	(1<<3)
+#define	MEM_CANCEL_ONLINE	(1<<4)
+#define	MEM_CANCEL_OFFLINE	(1<<5)
 
-/*
- * All of these states are currently kernel-internal for notifying
- * kernel components and architectures.
- *
- * For MEM_MAPPING_INVALID, all notifier chains with priority >0
- * are called before pfn_to_page() becomes invalid.  The priority=0
- * entry is reserved for the function that actually makes
- * pfn_to_page() stop working.  Any notifiers that want to be called
- * after that should have priority <0.
- */
-#define	MEM_MAPPING_INVALID	(1<<3)
+struct memory_notify {
+	unsigned long start_pfn;
+	unsigned long nr_pages;
+	int status_change_nid;
+};
 
 struct notifier_block;
 struct mem_section;
@@ -69,12 +66,18 @@ static inline int register_memory_notifier(struct notifier_block *nb)
 static inline void unregister_memory_notifier(struct notifier_block *nb)
 {
 }
+static inline int memory_notify(unsigned long val, void *v)
+{
+	return 0;
+}
 #else
+extern int register_memory_notifier(struct notifier_block *nb);
+extern void unregister_memory_notifier(struct notifier_block *nb);
 extern int register_new_memory(struct mem_section *);
 extern int unregister_memory_section(struct mem_section *);
 extern int memory_dev_init(void);
 extern int remove_memory_block(unsigned long, struct mem_section *, int);
-
+extern int memory_notify(unsigned long val, void *v);
 #define CONFIG_MEM_BLOCK_SIZE	(PAGES_PER_SECTION<<PAGE_SHIFT)
 
 

commit 53947027ad90542ddb2bb746e3175827c270610a
Author: Keith Mannthey <kmannth@us.ibm.com>
Date:   Sat Sep 30 23:27:08 2006 -0700

    [PATCH] hot-add-mem x86_64: use CONFIG_MEMORY_HOTPLUG_SPARSE
    
    Migate CONFIG_MEMORY_HOTPLUG to CONFIG_MEMORY_HOTPLUG_SPARSE where needed.
    
    Signed-off-by: Keith Mannthey <kmannth@us.ibm.com>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Andi Kleen <ak@muc.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 8f04143ca363..654ef5544878 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -57,7 +57,7 @@ struct memory_block {
 struct notifier_block;
 struct mem_section;
 
-#ifndef CONFIG_MEMORY_HOTPLUG
+#ifndef CONFIG_MEMORY_HOTPLUG_SPARSE
 static inline int memory_dev_init(void)
 {
 	return 0;
@@ -78,7 +78,7 @@ extern int remove_memory_block(unsigned long, struct mem_section *, int);
 #define CONFIG_MEM_BLOCK_SIZE	(PAGES_PER_SECTION<<PAGE_SHIFT)
 
 
-#endif /* CONFIG_MEMORY_HOTPLUG */
+#endif /* CONFIG_MEMORY_HOTPLUG_SPARSE */
 
 #define hotplug_memory_notifier(fn, pri) {			\
 	static struct notifier_block fn##_mem_nb =		\

commit e041c683412d5bf44dc2b109053e3b837b71742d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Mar 27 01:16:30 2006 -0800

    [PATCH] Notifier chain update: API changes
    
    The kernel's implementation of notifier chains is unsafe.  There is no
    protection against entries being added to or removed from a chain while the
    chain is in use.  The issues were discussed in this thread:
    
        http://marc.theaimsgroup.com/?l=linux-kernel&m=113018709002036&w=2
    
    We noticed that notifier chains in the kernel fall into two basic usage
    classes:
    
            "Blocking" chains are always called from a process context
            and the callout routines are allowed to sleep;
    
            "Atomic" chains can be called from an atomic context and
            the callout routines are not allowed to sleep.
    
    We decided to codify this distinction and make it part of the API.  Therefore
    this set of patches introduces three new, parallel APIs: one for blocking
    notifiers, one for atomic notifiers, and one for "raw" notifiers (which is
    really just the old API under a new name).  New kinds of data structures are
    used for the heads of the chains, and new routines are defined for
    registration, unregistration, and calling a chain.  The three APIs are
    explained in include/linux/notifier.h and their implementation is in
    kernel/sys.c.
    
    With atomic and blocking chains, the implementation guarantees that the chain
    links will not be corrupted and that chain callers will not get messed up by
    entries being added or removed.  For raw chains the implementation provides no
    guarantees at all; users of this API must provide their own protections.  (The
    idea was that situations may come up where the assumptions of the atomic and
    blocking APIs are not appropriate, so it should be possible for users to
    handle these things in their own way.)
    
    There are some limitations, which should not be too hard to live with.  For
    atomic/blocking chains, registration and unregistration must always be done in
    a process context since the chain is protected by a mutex/rwsem.  Also, a
    callout routine for a non-raw chain must not try to register or unregister
    entries on its own chain.  (This did happen in a couple of places and the code
    had to be changed to avoid it.)
    
    Since atomic chains may be called from within an NMI handler, they cannot use
    spinlocks for synchronization.  Instead we use RCU.  The overhead falls almost
    entirely in the unregister routine, which is okay since unregistration is much
    less frequent that calling a chain.
    
    Here is the list of chains that we adjusted and their classifications.  None
    of them use the raw API, so for the moment it is only a placeholder.
    
      ATOMIC CHAINS
      -------------
    arch/i386/kernel/traps.c:               i386die_chain
    arch/ia64/kernel/traps.c:               ia64die_chain
    arch/powerpc/kernel/traps.c:            powerpc_die_chain
    arch/sparc64/kernel/traps.c:            sparc64die_chain
    arch/x86_64/kernel/traps.c:             die_chain
    drivers/char/ipmi/ipmi_si_intf.c:       xaction_notifier_list
    kernel/panic.c:                         panic_notifier_list
    kernel/profile.c:                       task_free_notifier
    net/bluetooth/hci_core.c:               hci_notifier
    net/ipv4/netfilter/ip_conntrack_core.c: ip_conntrack_chain
    net/ipv4/netfilter/ip_conntrack_core.c: ip_conntrack_expect_chain
    net/ipv6/addrconf.c:                    inet6addr_chain
    net/netfilter/nf_conntrack_core.c:      nf_conntrack_chain
    net/netfilter/nf_conntrack_core.c:      nf_conntrack_expect_chain
    net/netlink/af_netlink.c:               netlink_chain
    
      BLOCKING CHAINS
      ---------------
    arch/powerpc/platforms/pseries/reconfig.c:      pSeries_reconfig_chain
    arch/s390/kernel/process.c:             idle_chain
    arch/x86_64/kernel/process.c            idle_notifier
    drivers/base/memory.c:                  memory_chain
    drivers/cpufreq/cpufreq.c               cpufreq_policy_notifier_list
    drivers/cpufreq/cpufreq.c               cpufreq_transition_notifier_list
    drivers/macintosh/adb.c:                adb_client_list
    drivers/macintosh/via-pmu.c             sleep_notifier_list
    drivers/macintosh/via-pmu68k.c          sleep_notifier_list
    drivers/macintosh/windfarm_core.c       wf_client_list
    drivers/usb/core/notify.c               usb_notifier_list
    drivers/video/fbmem.c                   fb_notifier_list
    kernel/cpu.c                            cpu_chain
    kernel/module.c                         module_notify_list
    kernel/profile.c                        munmap_notifier
    kernel/profile.c                        task_exit_notifier
    kernel/sys.c                            reboot_notifier_list
    net/core/dev.c                          netdev_chain
    net/decnet/dn_dev.c:                    dnaddr_chain
    net/ipv4/devinet.c:                     inetaddr_chain
    
    It's possible that some of these classifications are wrong.  If they are,
    please let us know or submit a patch to fix them.  Note that any chain that
    gets called very frequently should be atomic, because the rwsem read-locking
    used for blocking chains is very likely to incur cache misses on SMP systems.
    (However, if the chain's callout routines may sleep then the chain cannot be
    atomic.)
    
    The patch set was written by Alan Stern and Chandra Seetharaman, incorporating
    material written by Keith Owens and suggestions from Paul McKenney and Andrew
    Morton.
    
    [jes@sgi.com: restructure the notifier chain initialization macros]
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Chandra Seetharaman <sekharan@us.ibm.com>
    Signed-off-by: Jes Sorensen <jes@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index e251dc43d0f5..8f04143ca363 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -77,7 +77,6 @@ extern int remove_memory_block(unsigned long, struct mem_section *, int);
 
 #define CONFIG_MEM_BLOCK_SIZE	(PAGES_PER_SECTION<<PAGE_SHIFT)
 
-struct notifier_block;
 
 #endif /* CONFIG_MEMORY_HOTPLUG */
 

commit b792de39d892e06b18ddea85be076bae123d6bf6
Author: Olaf Hering <olh@suse.de>
Date:   Sun Jan 8 01:00:32 2006 -0800

    [PATCH] Fix compilation with CONFIG_MEMORY_HOTPLUG=y and gcc41.
    
    Fix compilation with CONFIG_MEMORY_HOTPLUG=y and gcc41.
    Also remove unneeded declations, add a public function.
    
    drivers/base/memory.c:53: error: static declaration of 'register_memory_notifier' follows non-static declaration
    include/linux/memory.h:85: error: previous declaration of 'register_memory_notifier' was here
    drivers/base/memory.c:58: error: static declaration of 'unregister_memory_notifier' follows non-static declaration
    include/linux/memory.h:86: error: previous declaration of 'unregister_memory_notifier' was here
    drivers/base/memory.c:68: error: static declaration of 'register_memory' follows non-static declaration
    include/linux/memory.h:73: error: previous declaration of 'register_memory' was here
    
    Signed-off-by: Olaf Hering <olh@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index dc4081b6f161..e251dc43d0f5 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -70,21 +70,15 @@ static inline void unregister_memory_notifier(struct notifier_block *nb)
 {
 }
 #else
-extern int register_memory(struct memory_block *, struct mem_section *section, struct node *);
 extern int register_new_memory(struct mem_section *);
 extern int unregister_memory_section(struct mem_section *);
 extern int memory_dev_init(void);
-extern int register_memory_notifier(struct notifier_block *nb);
-extern void unregister_memory_notifier(struct notifier_block *nb);
+extern int remove_memory_block(unsigned long, struct mem_section *, int);
 
 #define CONFIG_MEM_BLOCK_SIZE	(PAGES_PER_SECTION<<PAGE_SHIFT)
 
-extern int invalidate_phys_mapping(unsigned long, unsigned long);
 struct notifier_block;
 
-extern int register_memory_notifier(struct notifier_block *nb);
-extern void unregister_memory_notifier(struct notifier_block *nb);
-
 #endif /* CONFIG_MEMORY_HOTPLUG */
 
 #define hotplug_memory_notifier(fn, pri) {			\

commit ff88a3b2f56ae4f3296ea957ea38f99f8bd0e5a8
Author: Andrew Morton <akpm@osdl.org>
Date:   Mon Nov 28 13:43:47 2005 -0800

    [PATCH] memory_sysdev_class is static
    
    So don't define it as extern in the header file.
    
    drivers/base/memory.c:28: error: static declaration of 'memory_sysdev_class' follows non-static declaration
    include/linux/memory.h:88: error: previous declaration of 'memory_sysdev_class' was here
    
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 9a424383e6c6..dc4081b6f161 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -85,7 +85,6 @@ struct notifier_block;
 extern int register_memory_notifier(struct notifier_block *nb);
 extern void unregister_memory_notifier(struct notifier_block *nb);
 
-extern struct sysdev_class memory_sysdev_class;
 #endif /* CONFIG_MEMORY_HOTPLUG */
 
 #define hotplug_memory_notifier(fn, pri) {			\

commit 8c65b4a60450590e79a28e9717ceffa9e4debb3f
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Mon Nov 7 00:59:43 2005 -0800

    [PATCH] fix remaining missing includes
    
    Fix more include file problems that surfaced since I submitted the previous
    fix-missing-includes.patch.  This should now allow not to include sched.h
    from module.h, which is done by a followup patch.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
index 0def328ab5cf..9a424383e6c6 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -54,6 +54,9 @@ struct memory_block {
  */
 #define	MEM_MAPPING_INVALID	(1<<3)
 
+struct notifier_block;
+struct mem_section;
+
 #ifndef CONFIG_MEMORY_HOTPLUG
 static inline int memory_dev_init(void)
 {

commit 3947be1969a9ce455ec30f60ef51efb10e4323d1
Author: Dave Hansen <haveblue@us.ibm.com>
Date:   Sat Oct 29 18:16:54 2005 -0700

    [PATCH] memory hotplug: sysfs and add/remove functions
    
    This adds generic memory add/remove and supporting functions for memory
    hotplug into a new file as well as a memory hotplug kernel config option.
    
    Individual architecture patches will follow.
    
    For now, disable memory hotplug when swsusp is enabled.  There's a lot of
    churn there right now.  We'll fix it up properly once it calms down.
    
    Signed-off-by: Matt Tolentino <matthew.e.tolentino@intel.com>
    Signed-off-by: Dave Hansen <haveblue@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/memory.h b/include/linux/memory.h
new file mode 100644
index 000000000000..0def328ab5cf
--- /dev/null
+++ b/include/linux/memory.h
@@ -0,0 +1,94 @@
+/*
+ * include/linux/memory.h - generic memory definition
+ *
+ * This is mainly for topological representation. We define the
+ * basic "struct memory_block" here, which can be embedded in per-arch
+ * definitions or NUMA information.
+ *
+ * Basic handling of the devices is done in drivers/base/memory.c
+ * and system devices are handled in drivers/base/sys.c.
+ *
+ * Memory block are exported via sysfs in the class/memory/devices/
+ * directory.
+ *
+ */
+#ifndef _LINUX_MEMORY_H_
+#define _LINUX_MEMORY_H_
+
+#include <linux/sysdev.h>
+#include <linux/node.h>
+#include <linux/compiler.h>
+
+#include <asm/semaphore.h>
+
+struct memory_block {
+	unsigned long phys_index;
+	unsigned long state;
+	/*
+	 * This serializes all state change requests.  It isn't
+	 * held during creation because the control files are
+	 * created long after the critical areas during
+	 * initialization.
+	 */
+	struct semaphore state_sem;
+	int phys_device;		/* to which fru does this belong? */
+	void *hw;			/* optional pointer to fw/hw data */
+	int (*phys_callback)(struct memory_block *);
+	struct sys_device sysdev;
+};
+
+/* These states are exposed to userspace as text strings in sysfs */
+#define	MEM_ONLINE		(1<<0) /* exposed to userspace */
+#define	MEM_GOING_OFFLINE	(1<<1) /* exposed to userspace */
+#define	MEM_OFFLINE		(1<<2) /* exposed to userspace */
+
+/*
+ * All of these states are currently kernel-internal for notifying
+ * kernel components and architectures.
+ *
+ * For MEM_MAPPING_INVALID, all notifier chains with priority >0
+ * are called before pfn_to_page() becomes invalid.  The priority=0
+ * entry is reserved for the function that actually makes
+ * pfn_to_page() stop working.  Any notifiers that want to be called
+ * after that should have priority <0.
+ */
+#define	MEM_MAPPING_INVALID	(1<<3)
+
+#ifndef CONFIG_MEMORY_HOTPLUG
+static inline int memory_dev_init(void)
+{
+	return 0;
+}
+static inline int register_memory_notifier(struct notifier_block *nb)
+{
+	return 0;
+}
+static inline void unregister_memory_notifier(struct notifier_block *nb)
+{
+}
+#else
+extern int register_memory(struct memory_block *, struct mem_section *section, struct node *);
+extern int register_new_memory(struct mem_section *);
+extern int unregister_memory_section(struct mem_section *);
+extern int memory_dev_init(void);
+extern int register_memory_notifier(struct notifier_block *nb);
+extern void unregister_memory_notifier(struct notifier_block *nb);
+
+#define CONFIG_MEM_BLOCK_SIZE	(PAGES_PER_SECTION<<PAGE_SHIFT)
+
+extern int invalidate_phys_mapping(unsigned long, unsigned long);
+struct notifier_block;
+
+extern int register_memory_notifier(struct notifier_block *nb);
+extern void unregister_memory_notifier(struct notifier_block *nb);
+
+extern struct sysdev_class memory_sysdev_class;
+#endif /* CONFIG_MEMORY_HOTPLUG */
+
+#define hotplug_memory_notifier(fn, pri) {			\
+	static struct notifier_block fn##_mem_nb =		\
+		{ .notifier_call = fn, .priority = pri };	\
+	register_memory_notifier(&fn##_mem_nb);			\
+}
+
+#endif /* _LINUX_MEMORY_H_ */
