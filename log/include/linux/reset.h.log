commit ec939e4c94bd3ef2fd4f34c15f8aaf79bd0c5ee1
Merge: 38206c24ab09 3f6939aec712
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 5 11:43:31 2019 -0800

    Merge tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc
    
    Pull ARM SoC driver updates from Olof Johansson:
     "Various driver updates for platforms:
    
       - A larger set of work on Tegra 2/3 around memory controller and
         regulator features, some fuse cleanups, etc..
    
       - MMP platform drivers, in particular for USB PHY, and other smaller
         additions.
    
       - Samsung Exynos 5422 driver for DMC (dynamic memory configuration),
         and ASV (adaptive voltage), allowing the platform to run at more
         optimal operating points.
    
       - Misc refactorings and support for RZ/G2N and R8A774B1 from Renesas
    
       - Clock/reset control driver for TI/OMAP
    
       - Meson-A1 reset controller support
    
       - Qualcomm sdm845 and sda845 SoC IDs for socinfo"
    
    * tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc: (150 commits)
      firmware: arm_scmi: Fix doorbell ring logic for !CONFIG_64BIT
      soc: fsl: add RCPM driver
      dt-bindings: fsl: rcpm: Add 'little-endian' and update Chassis definition
      memory: tegra: Consolidate registers definition into common header
      memory: tegra: Ensure timing control debug features are disabled
      memory: tegra: Introduce Tegra30 EMC driver
      memory: tegra: Do not handle error from wait_for_completion_timeout()
      memory: tegra: Increase handshake timeout on Tegra20
      memory: tegra: Print a brief info message about EMC timings
      memory: tegra: Pre-configure debug register on Tegra20
      memory: tegra: Include io.h instead of iopoll.h
      memory: tegra: Adapt for Tegra20 clock driver changes
      memory: tegra: Don't set EMC rate to maximum on probe for Tegra20
      memory: tegra: Add gr2d and gr3d to DRM IOMMU group
      memory: tegra: Set DMA mask based on supported address bits
      soc: at91: Add Atmel SFR SN (Serial Number) support
      memory: atmel-ebi: switch to SPDX license identifiers
      memory: atmel-ebi: move NUM_CS definition inside EBI driver
      soc: mediatek: Refactor bus protection control
      soc: mediatek: Refactor sram control
      ...

commit c2ffa00ad6152ad54940f942fc316b9c83d5e6f9
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Tue Oct 22 16:53:25 2019 +0200

    reset: document (devm_)reset_control_get_optional variants
    
    Add kerneldoc comments for the optional reset_control_get variants.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index e7793fc0fa93..bf7c7f188406 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -203,12 +203,34 @@ static inline struct reset_control *reset_control_get_shared(
 	return __reset_control_get(dev, id, 0, true, false, false);
 }
 
+/**
+ * reset_control_get_optional_exclusive - optional reset_control_get_exclusive()
+ * @dev: device to be reset by the controller
+ * @id: reset line name
+ *
+ * Optional variant of reset_control_get_exclusive(). If the requested reset
+ * is not specified in the device tree, this function returns NULL instead of
+ * an error.
+ *
+ * See reset_control_get_exclusive() for more information.
+ */
 static inline struct reset_control *reset_control_get_optional_exclusive(
 					struct device *dev, const char *id)
 {
 	return __reset_control_get(dev, id, 0, false, true, true);
 }
 
+/**
+ * reset_control_get_optional_shared - optional reset_control_get_shared()
+ * @dev: device to be reset by the controller
+ * @id: reset line name
+ *
+ * Optional variant of reset_control_get_shared(). If the requested reset
+ * is not specified in the device tree, this function returns NULL instead of
+ * an error.
+ *
+ * See reset_control_get_shared() for more information.
+ */
 static inline struct reset_control *reset_control_get_optional_shared(
 					struct device *dev, const char *id)
 {
@@ -354,12 +376,36 @@ static inline struct reset_control *devm_reset_control_get_shared(
 	return __devm_reset_control_get(dev, id, 0, true, false, false);
 }
 
+/**
+ * devm_reset_control_get_optional_exclusive - resource managed
+ *                                             reset_control_get_optional_exclusive()
+ * @dev: device to be reset by the controller
+ * @id: reset line name
+ *
+ * Managed reset_control_get_optional_exclusive(). For reset controllers
+ * returned from this function, reset_control_put() is called automatically on
+ * driver detach.
+ *
+ * See reset_control_get_optional_exclusive() for more information.
+ */
 static inline struct reset_control *devm_reset_control_get_optional_exclusive(
 					struct device *dev, const char *id)
 {
 	return __devm_reset_control_get(dev, id, 0, false, true, true);
 }
 
+/**
+ * devm_reset_control_get_optional_shared - resource managed
+ *                                          reset_control_get_optional_shared()
+ * @dev: device to be reset by the controller
+ * @id: reset line name
+ *
+ * Managed reset_control_get_optional_shared(). For reset controllers returned
+ * from this function, reset_control_put() is called automatically on driver
+ * detach.
+ *
+ * See reset_control_get_optional_shared() for more information.
+ */
 static inline struct reset_control *devm_reset_control_get_optional_shared(
 					struct device *dev, const char *id)
 {

commit b9e9348d381ea2e2a8782e753a686cf57c26ec60
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Tue Oct 22 18:19:22 2019 +0200

    reset: fix reset_control_get_exclusive kerneldoc comment
    
    Add missing parentheses to correctly hyperlink the reference to
    reset_control_get_shared().
    
    Fixes: 0b52297f2288 ("reset: Add support for shared reset controls")
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index e7793fc0fa93..eb597e8aa430 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -143,7 +143,7 @@ static inline int device_reset_optional(struct device *dev)
  * If this function is called more than once for the same reset_control it will
  * return -EBUSY.
  *
- * See reset_control_get_shared for details on shared references to
+ * See reset_control_get_shared() for details on shared references to
  * reset-controls.
  *
  * Use of id names is optional.

commit d005aa750c9b7ca7f77dafd6dda33a0fcb6e7ae3
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Tue Apr 2 08:20:08 2019 -0700

    reset: fix linux/reset.h errors
    
    The header file <linux/reset.h> uses errno constant(s) and the
    ERR_PTR() macro but does not #include the appropriate header files
    that provide those facilities, so add 2 header files to fix
    build errors.
    
      CC [M]  drivers/gpu/drm/lima/lima_device.o
    In file included from ../drivers/gpu/drm/lima/lima_device.c:5:0:
    ../include/linux/reset.h: In function ‘__device_reset’:
    ../include/linux/reset.h:77:25: error: ‘ENOTSUPP’ undeclared (first use in this function)
      return optional ? 0 : -ENOTSUPP;
    ../include/linux/reset.h:77:25: note: each undeclared identifier is reported only once for each function it appears in
    ../include/linux/reset.h: In function ‘__of_reset_control_get’:
    ../include/linux/reset.h:85:36: error: ‘ENOTSUPP’ undeclared (first use in this function)
      return optional ? NULL : ERR_PTR(-ENOTSUPP);
    ../include/linux/reset.h: In function ‘__reset_control_get’:
    ../include/linux/reset.h:93:36: error: ‘ENOTSUPP’ undeclared (first use in this function)
      return optional ? NULL : ERR_PTR(-ENOTSUPP);
    ../include/linux/reset.h: In function ‘__devm_reset_control_get’:
    ../include/linux/reset.h:101:36: error: ‘ENOTSUPP’ undeclared (first use in this function)
      return optional ? NULL : ERR_PTR(-ENOTSUPP);
    ../include/linux/reset.h: In function ‘devm_reset_control_array_get’:
    ../include/linux/reset.h:107:36: error: ‘ENOTSUPP’ undeclared (first use in this function)
      return optional ? NULL : ERR_PTR(-ENOTSUPP);
    ../include/linux/reset.h: In function ‘of_reset_control_array_get’:
    ../include/linux/reset.h:114:36: error: ‘ENOTSUPP’ undeclared (first use in this function)
      return optional ? NULL : ERR_PTR(-ENOTSUPP);
    In file included from ../drivers/gpu/drm/lima/lima_device.c:5:0:
    ../include/linux/reset.h: In function ‘__devm_reset_control_get’:
    ../include/linux/reset.h:102:1: warning: control reaches end of non-void function [-Wreturn-type]
     }
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index 95d555c2130a..e7793fc0fa93 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -2,6 +2,8 @@
 #ifndef _LINUX_RESET_H_
 #define _LINUX_RESET_H_
 
+#include <linux/err.h>
+#include <linux/errno.h>
 #include <linux/types.h>
 
 struct device;

commit 22815f1825e4c50314e7084ca375f7368704fdd4
Author: Thierry Reding <treding@nvidia.com>
Date:   Thu Feb 21 16:25:55 2019 +0100

    reset: Add acquire/release support for arrays
    
    Add implementations that apply acquire and release operations to all
    reset controls part of a reset control array.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index a01b32bf51d4..95d555c2130a 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -470,6 +470,12 @@ of_reset_control_array_get_exclusive(struct device_node *node)
 	return of_reset_control_array_get(node, false, false, true);
 }
 
+static inline struct reset_control *
+of_reset_control_array_get_exclusive_released(struct device_node *node)
+{
+	return of_reset_control_array_get(node, false, false, false);
+}
+
 static inline struct reset_control *
 of_reset_control_array_get_shared(struct device_node *node)
 {

commit f31d5c24fb2ea6fcfa4d300886eb87b662fbc0da
Author: Thierry Reding <treding@nvidia.com>
Date:   Thu Feb 21 16:25:54 2019 +0100

    reset: Add acquired flag to of_reset_control_array_get()
    
    In order to be able to request an array of reset controls in acquired or
    released mode, add the acquired flag to of_reset_control_array_get() and
    pass the flag to subsequent calls of __of_reset_control_get().
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index ea9a8a1ce4b1..a01b32bf51d4 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -32,7 +32,8 @@ struct reset_control *__devm_reset_control_get(struct device *dev,
 struct reset_control *devm_reset_control_array_get(struct device *dev,
 						   bool shared, bool optional);
 struct reset_control *of_reset_control_array_get(struct device_node *np,
-						 bool shared, bool optional);
+						 bool shared, bool optional,
+						 bool acquired);
 
 int reset_control_get_count(struct device *dev);
 
@@ -107,7 +108,8 @@ devm_reset_control_array_get(struct device *dev, bool shared, bool optional)
 }
 
 static inline struct reset_control *
-of_reset_control_array_get(struct device_node *np, bool shared, bool optional)
+of_reset_control_array_get(struct device_node *np, bool shared, bool optional,
+			   bool acquired)
 {
 	return optional ? NULL : ERR_PTR(-ENOTSUPP);
 }
@@ -465,24 +467,24 @@ devm_reset_control_array_get_optional_shared(struct device *dev)
 static inline struct reset_control *
 of_reset_control_array_get_exclusive(struct device_node *node)
 {
-	return of_reset_control_array_get(node, false, false);
+	return of_reset_control_array_get(node, false, false, true);
 }
 
 static inline struct reset_control *
 of_reset_control_array_get_shared(struct device_node *node)
 {
-	return of_reset_control_array_get(node, true, false);
+	return of_reset_control_array_get(node, true, false, true);
 }
 
 static inline struct reset_control *
 of_reset_control_array_get_optional_exclusive(struct device_node *node)
 {
-	return of_reset_control_array_get(node, false, true);
+	return of_reset_control_array_get(node, false, true, true);
 }
 
 static inline struct reset_control *
 of_reset_control_array_get_optional_shared(struct device_node *node)
 {
-	return of_reset_control_array_get(node, true, true);
+	return of_reset_control_array_get(node, true, true, true);
 }
 #endif

commit c84b0326d5e4fe08d493f6fff245da2ad473f4ae
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Thu Feb 21 16:25:53 2019 +0100

    reset: add acquired/released state for exclusive reset controls
    
    There are cases where a driver needs explicit control over a reset line
    that is exclusively conneted to its device, but this control has to be
    temporarily handed over to the power domain controller to handle reset
    requirements during power transitions.
    Allow multiple exclusive reset controls to be requested in 'released'
    state for the same physical reset line, only one of which can be
    acquired at the same time.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index c1901b61ca30..ea9a8a1ce4b1 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -14,18 +14,20 @@ int reset_control_reset(struct reset_control *rstc);
 int reset_control_assert(struct reset_control *rstc);
 int reset_control_deassert(struct reset_control *rstc);
 int reset_control_status(struct reset_control *rstc);
+int reset_control_acquire(struct reset_control *rstc);
+void reset_control_release(struct reset_control *rstc);
 
 struct reset_control *__of_reset_control_get(struct device_node *node,
 				     const char *id, int index, bool shared,
-				     bool optional);
+				     bool optional, bool acquired);
 struct reset_control *__reset_control_get(struct device *dev, const char *id,
 					  int index, bool shared,
-					  bool optional);
+					  bool optional, bool acquired);
 void reset_control_put(struct reset_control *rstc);
 int __device_reset(struct device *dev, bool optional);
 struct reset_control *__devm_reset_control_get(struct device *dev,
 				     const char *id, int index, bool shared,
-				     bool optional);
+				     bool optional, bool acquired);
 
 struct reset_control *devm_reset_control_array_get(struct device *dev,
 						   bool shared, bool optional);
@@ -56,6 +58,15 @@ static inline int reset_control_status(struct reset_control *rstc)
 	return 0;
 }
 
+static inline int reset_control_acquire(struct reset_control *rstc)
+{
+	return 0;
+}
+
+static inline void reset_control_release(struct reset_control *rstc)
+{
+}
+
 static inline void reset_control_put(struct reset_control *rstc)
 {
 }
@@ -68,21 +79,23 @@ static inline int __device_reset(struct device *dev, bool optional)
 static inline struct reset_control *__of_reset_control_get(
 					struct device_node *node,
 					const char *id, int index, bool shared,
-					bool optional)
+					bool optional, bool acquired)
 {
 	return optional ? NULL : ERR_PTR(-ENOTSUPP);
 }
 
 static inline struct reset_control *__reset_control_get(
 					struct device *dev, const char *id,
-					int index, bool shared, bool optional)
+					int index, bool shared, bool optional,
+					bool acquired)
 {
 	return optional ? NULL : ERR_PTR(-ENOTSUPP);
 }
 
 static inline struct reset_control *__devm_reset_control_get(
 					struct device *dev, const char *id,
-					int index, bool shared, bool optional)
+					int index, bool shared, bool optional,
+					bool acquired)
 {
 	return optional ? NULL : ERR_PTR(-ENOTSUPP);
 }
@@ -134,7 +147,28 @@ static inline int device_reset_optional(struct device *dev)
 static inline struct reset_control *
 __must_check reset_control_get_exclusive(struct device *dev, const char *id)
 {
-	return __reset_control_get(dev, id, 0, false, false);
+	return __reset_control_get(dev, id, 0, false, false, true);
+}
+
+/**
+ * reset_control_get_exclusive_released - Lookup and obtain a temoprarily
+ *                                        exclusive reference to a reset
+ *                                        controller.
+ * @dev: device to be reset by the controller
+ * @id: reset line name
+ *
+ * Returns a struct reset_control or IS_ERR() condition containing errno.
+ * reset-controls returned by this function must be acquired via
+ * reset_control_acquire() before they can be used and should be released
+ * via reset_control_release() afterwards.
+ *
+ * Use of id names is optional.
+ */
+static inline struct reset_control *
+__must_check reset_control_get_exclusive_released(struct device *dev,
+						  const char *id)
+{
+	return __reset_control_get(dev, id, 0, false, false, false);
 }
 
 /**
@@ -162,19 +196,19 @@ __must_check reset_control_get_exclusive(struct device *dev, const char *id)
 static inline struct reset_control *reset_control_get_shared(
 					struct device *dev, const char *id)
 {
-	return __reset_control_get(dev, id, 0, true, false);
+	return __reset_control_get(dev, id, 0, true, false, false);
 }
 
 static inline struct reset_control *reset_control_get_optional_exclusive(
 					struct device *dev, const char *id)
 {
-	return __reset_control_get(dev, id, 0, false, true);
+	return __reset_control_get(dev, id, 0, false, true, true);
 }
 
 static inline struct reset_control *reset_control_get_optional_shared(
 					struct device *dev, const char *id)
 {
-	return __reset_control_get(dev, id, 0, true, true);
+	return __reset_control_get(dev, id, 0, true, true, false);
 }
 
 /**
@@ -190,7 +224,7 @@ static inline struct reset_control *reset_control_get_optional_shared(
 static inline struct reset_control *of_reset_control_get_exclusive(
 				struct device_node *node, const char *id)
 {
-	return __of_reset_control_get(node, id, 0, false, false);
+	return __of_reset_control_get(node, id, 0, false, false, true);
 }
 
 /**
@@ -215,7 +249,7 @@ static inline struct reset_control *of_reset_control_get_exclusive(
 static inline struct reset_control *of_reset_control_get_shared(
 				struct device_node *node, const char *id)
 {
-	return __of_reset_control_get(node, id, 0, true, false);
+	return __of_reset_control_get(node, id, 0, true, false, false);
 }
 
 /**
@@ -232,7 +266,7 @@ static inline struct reset_control *of_reset_control_get_shared(
 static inline struct reset_control *of_reset_control_get_exclusive_by_index(
 					struct device_node *node, int index)
 {
-	return __of_reset_control_get(node, NULL, index, false, false);
+	return __of_reset_control_get(node, NULL, index, false, false, true);
 }
 
 /**
@@ -260,7 +294,7 @@ static inline struct reset_control *of_reset_control_get_exclusive_by_index(
 static inline struct reset_control *of_reset_control_get_shared_by_index(
 					struct device_node *node, int index)
 {
-	return __of_reset_control_get(node, NULL, index, true, false);
+	return __of_reset_control_get(node, NULL, index, true, false, false);
 }
 
 /**
@@ -279,7 +313,26 @@ static inline struct reset_control *
 __must_check devm_reset_control_get_exclusive(struct device *dev,
 					      const char *id)
 {
-	return __devm_reset_control_get(dev, id, 0, false, false);
+	return __devm_reset_control_get(dev, id, 0, false, false, true);
+}
+
+/**
+ * devm_reset_control_get_exclusive_released - resource managed
+ *                                             reset_control_get_exclusive_released()
+ * @dev: device to be reset by the controller
+ * @id: reset line name
+ *
+ * Managed reset_control_get_exclusive_released(). For reset controllers
+ * returned from this function, reset_control_put() is called automatically on
+ * driver detach.
+ *
+ * See reset_control_get_exclusive_released() for more information.
+ */
+static inline struct reset_control *
+__must_check devm_reset_control_get_exclusive_released(struct device *dev,
+						       const char *id)
+{
+	return __devm_reset_control_get(dev, id, 0, false, false, false);
 }
 
 /**
@@ -294,19 +347,19 @@ __must_check devm_reset_control_get_exclusive(struct device *dev,
 static inline struct reset_control *devm_reset_control_get_shared(
 					struct device *dev, const char *id)
 {
-	return __devm_reset_control_get(dev, id, 0, true, false);
+	return __devm_reset_control_get(dev, id, 0, true, false, false);
 }
 
 static inline struct reset_control *devm_reset_control_get_optional_exclusive(
 					struct device *dev, const char *id)
 {
-	return __devm_reset_control_get(dev, id, 0, false, true);
+	return __devm_reset_control_get(dev, id, 0, false, true, true);
 }
 
 static inline struct reset_control *devm_reset_control_get_optional_shared(
 					struct device *dev, const char *id)
 {
-	return __devm_reset_control_get(dev, id, 0, true, true);
+	return __devm_reset_control_get(dev, id, 0, true, true, false);
 }
 
 /**
@@ -324,7 +377,7 @@ static inline struct reset_control *devm_reset_control_get_optional_shared(
 static inline struct reset_control *
 devm_reset_control_get_exclusive_by_index(struct device *dev, int index)
 {
-	return __devm_reset_control_get(dev, NULL, index, false, false);
+	return __devm_reset_control_get(dev, NULL, index, false, false, true);
 }
 
 /**
@@ -340,7 +393,7 @@ devm_reset_control_get_exclusive_by_index(struct device *dev, int index)
 static inline struct reset_control *
 devm_reset_control_get_shared_by_index(struct device *dev, int index)
 {
-	return __devm_reset_control_get(dev, NULL, index, true, false);
+	return __devm_reset_control_get(dev, NULL, index, true, false, false);
 }
 
 /*

commit eaf91db0ab22dc2c664a9782f2f31dcbc410f3b5
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Nov 13 13:47:44 2018 +0100

    reset: Add reset_control_get_count()
    
    Currently the reset core has internal support for counting the number of
    resets for a device described in DT.  Generalize this to devices using
    lookup resets, and export it for public use.
    
    This will be used by generic drivers that need to be sure a device is
    controlled by a single, dedicated reset line (e.g. vfio-platform).
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    [p.zabel@pengutronix.de: fixed a typo in reset_control_get_count comment]
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index 76690cf2e3e0..c1901b61ca30 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -32,6 +32,8 @@ struct reset_control *devm_reset_control_array_get(struct device *dev,
 struct reset_control *of_reset_control_array_get(struct device_node *np,
 						 bool shared, bool optional);
 
+int reset_control_get_count(struct device *dev);
+
 #else
 
 static inline int reset_control_reset(struct reset_control *rstc)
@@ -97,6 +99,11 @@ of_reset_control_array_get(struct device_node *np, bool shared, bool optional)
 	return optional ? NULL : ERR_PTR(-ENOTSUPP);
 }
 
+static inline int reset_control_get_count(struct device *dev)
+{
+	return -ENOENT;
+}
+
 #endif /* CONFIG_RESET_CONTROLLER */
 
 static inline int __must_check device_reset(struct device *dev)

commit 12c62b9d6ce57d37f3c03cc902c30498909fbc42
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Oct 8 13:15:43 2018 +0200

    reset: Improve reset controller kernel docs
    
    Grammar and indentation fixes.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    [p.zabel@pengutronix.de: dropped "shared among" -> "shared between"]
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index 29af6d6b2f4b..76690cf2e3e0 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -138,7 +138,7 @@ __must_check reset_control_get_exclusive(struct device *dev, const char *id)
  *
  * Returns a struct reset_control or IS_ERR() condition containing errno.
  * This function is intended for use with reset-controls which are shared
- * between hardware-blocks.
+ * between hardware blocks.
  *
  * When a reset-control is shared, the behavior of reset_control_assert /
  * deassert is changed, the reset-core will keep track of a deassert_count
@@ -187,7 +187,7 @@ static inline struct reset_control *of_reset_control_get_exclusive(
 }
 
 /**
- * of_reset_control_get_shared - Lookup and obtain an shared reference
+ * of_reset_control_get_shared - Lookup and obtain a shared reference
  *                               to a reset controller.
  * @node: device to be reset by the controller
  * @id: reset line name
@@ -229,7 +229,7 @@ static inline struct reset_control *of_reset_control_get_exclusive_by_index(
 }
 
 /**
- * of_reset_control_get_shared_by_index - Lookup and obtain an shared
+ * of_reset_control_get_shared_by_index - Lookup and obtain a shared
  *                                        reference to a reset controller
  *                                        by index.
  * @node: device to be reset by the controller
@@ -322,7 +322,7 @@ devm_reset_control_get_exclusive_by_index(struct device *dev, int index)
 
 /**
  * devm_reset_control_get_shared_by_index - resource managed
- * reset_control_get_shared
+ *                                          reset_control_get_shared
  * @dev: device to be reset by the controller
  * @index: index of the reset controller
  *

commit 34845c939082093354a6ffbb1ebff599e30b9b22
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Sep 26 15:20:03 2018 +0200

    reset: Grammar s/more then once/more than once/
    
    Fix grammar in reset_control_get_exclusive() documentation comment.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index 09732c36f351..29af6d6b2f4b 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -116,7 +116,7 @@ static inline int device_reset_optional(struct device *dev)
  * @id: reset line name
  *
  * Returns a struct reset_control or IS_ERR() condition containing errno.
- * If this function is called more then once for the same reset_control it will
+ * If this function is called more than once for the same reset_control it will
  * return -EBUSY.
  *
  * See reset_control_get_shared for details on shared references to

commit 13fba8ef50db04c4a0e9722501d46ccb02d3a77c
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Oct 29 01:50:09 2017 +0900

    reset: remove reset_control_get(_optional)
    
    No more users of these two.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index e5d97ab4359c..09732c36f351 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -344,18 +344,6 @@ devm_reset_control_get_shared_by_index(struct device *dev, int index)
  * These inline function calls will be removed once all consumers
  * have been moved over to the new explicit API.
  */
-static inline struct reset_control *reset_control_get(
-				struct device *dev, const char *id)
-{
-	return reset_control_get_exclusive(dev, id);
-}
-
-static inline struct reset_control *reset_control_get_optional(
-					struct device *dev, const char *id)
-{
-	return reset_control_get_optional_exclusive(dev, id);
-}
-
 static inline struct reset_control *of_reset_control_get(
 				struct device_node *node, const char *id)
 {

commit dfc1d9b24719b13164cc4fdc328c0b3e422cac42
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Oct 29 01:50:08 2017 +0900

    reset: minimize the number of headers included from <linux/reset.h>
    
    Commit 62e24c5775ec ("reset: add exported __reset_control_get, return
    NULL if optional") moved the dev->of_node reference to core.c, so
    <linux/reset.h> does not need to know the members of struct device.
    Declaring device and device_node as structure is enough.
    
    <linux/types.h> is necessary for bool, true, and false.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index ed6fb0290797..e5d97ab4359c 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -2,8 +2,10 @@
 #ifndef _LINUX_RESET_H_
 #define _LINUX_RESET_H_
 
-#include <linux/device.h>
+#include <linux/types.h>
 
+struct device;
+struct device_node;
 struct reset_control;
 
 #ifdef CONFIG_RESET_CONTROLLER

commit bb6c7768385b200063a14d6615cc1246c3d00760
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Oct 29 01:50:07 2017 +0900

    reset: remove remaining WARN_ON() in <linux/reset.h>
    
    Commit bb475230b8e5 ("reset: make optional functions really optional")
    gave a new meaning to _get_optional variants.
    
    The differentiation by WARN_ON() is not needed any more.  We already
    have inconsistency about this; (devm_)reset_control_get_exclusive()
    has WARN_ON() check, but of_reset_control_get_exclusive() does not.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index b681019fc04c..ed6fb0290797 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -125,9 +125,6 @@ static inline int device_reset_optional(struct device *dev)
 static inline struct reset_control *
 __must_check reset_control_get_exclusive(struct device *dev, const char *id)
 {
-#ifndef CONFIG_RESET_CONTROLLER
-	WARN_ON(1);
-#endif
 	return __reset_control_get(dev, id, 0, false, false);
 }
 
@@ -273,9 +270,6 @@ static inline struct reset_control *
 __must_check devm_reset_control_get_exclusive(struct device *dev,
 					      const char *id)
 {
-#ifndef CONFIG_RESET_CONTROLLER
-	WARN_ON(1);
-#endif
 	return __devm_reset_control_get(dev, id, 0, false, false);
 }
 

commit 1554bbd4ad401b7f0f916c0891874111c10befe5
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Oct 29 01:50:06 2017 +0900

    reset: make device_reset_optional() really optional
    
    Commit bb475230b8e5 ("reset: make optional functions really optional")
    converted *_get_optional* functions, but device_reset_optional() was
    left behind.  Convert it in the same way.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index 4c7871ddf3c6..b681019fc04c 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -20,22 +20,16 @@ struct reset_control *__reset_control_get(struct device *dev, const char *id,
 					  int index, bool shared,
 					  bool optional);
 void reset_control_put(struct reset_control *rstc);
+int __device_reset(struct device *dev, bool optional);
 struct reset_control *__devm_reset_control_get(struct device *dev,
 				     const char *id, int index, bool shared,
 				     bool optional);
 
-int __must_check device_reset(struct device *dev);
-
 struct reset_control *devm_reset_control_array_get(struct device *dev,
 						   bool shared, bool optional);
 struct reset_control *of_reset_control_array_get(struct device_node *np,
 						 bool shared, bool optional);
 
-static inline int device_reset_optional(struct device *dev)
-{
-	return device_reset(dev);
-}
-
 #else
 
 static inline int reset_control_reset(struct reset_control *rstc)
@@ -62,15 +56,9 @@ static inline void reset_control_put(struct reset_control *rstc)
 {
 }
 
-static inline int __must_check device_reset(struct device *dev)
+static inline int __device_reset(struct device *dev, bool optional)
 {
-	WARN_ON(1);
-	return -ENOTSUPP;
-}
-
-static inline int device_reset_optional(struct device *dev)
-{
-	return -ENOTSUPP;
+	return optional ? 0 : -ENOTSUPP;
 }
 
 static inline struct reset_control *__of_reset_control_get(
@@ -109,6 +97,16 @@ of_reset_control_array_get(struct device_node *np, bool shared, bool optional)
 
 #endif /* CONFIG_RESET_CONTROLLER */
 
+static inline int __must_check device_reset(struct device *dev)
+{
+	return __device_reset(dev, false);
+}
+
+static inline int device_reset_optional(struct device *dev)
+{
+	return __device_reset(dev, true);
+}
+
 /**
  * reset_control_get_exclusive - Lookup and obtain an exclusive reference
  *                               to a reset controller.

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index 56463f37f3e6..4c7871ddf3c6 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _LINUX_RESET_H_
 #define _LINUX_RESET_H_
 

commit 17c82e206d2a3cd876b64921c59116f1ecdce6ad
Author: Vivek Gautam <vivek.gautam@codeaurora.org>
Date:   Mon May 22 16:53:25 2017 +0530

    reset: Add APIs to manage array of resets
    
    Many devices may want to request a bunch of resets and control them. So
    it's better to manage them as an array. Add APIs to _get() an array of
    reset_control, reusing the _assert(), _deassert(), and _reset() APIs for
    single reset controls. Since reset controls already may control multiple
    reset lines with a single hardware bit, from the user perspective, reset
    control arrays are not at all different from single reset controls.
    Note that these APIs don't guarantee that the reset lines managed in the
    array are handled in any particular order.
    
    Cc: Felipe Balbi <balbi@kernel.org>
    Cc: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Vivek Gautam <vivek.gautam@codeaurora.org>
    [p.zabel@pengutronix.de: changed API to hide reset control arrays behind
     struct reset_control]
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index 13d8681210d5..56463f37f3e6 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -25,6 +25,11 @@ struct reset_control *__devm_reset_control_get(struct device *dev,
 
 int __must_check device_reset(struct device *dev);
 
+struct reset_control *devm_reset_control_array_get(struct device *dev,
+						   bool shared, bool optional);
+struct reset_control *of_reset_control_array_get(struct device_node *np,
+						 bool shared, bool optional);
+
 static inline int device_reset_optional(struct device *dev)
 {
 	return device_reset(dev);
@@ -89,6 +94,18 @@ static inline struct reset_control *__devm_reset_control_get(
 	return optional ? NULL : ERR_PTR(-ENOTSUPP);
 }
 
+static inline struct reset_control *
+devm_reset_control_array_get(struct device *dev, bool shared, bool optional)
+{
+	return optional ? NULL : ERR_PTR(-ENOTSUPP);
+}
+
+static inline struct reset_control *
+of_reset_control_array_get(struct device_node *np, bool shared, bool optional)
+{
+	return optional ? NULL : ERR_PTR(-ENOTSUPP);
+}
+
 #endif /* CONFIG_RESET_CONTROLLER */
 
 /**
@@ -374,4 +391,55 @@ static inline struct reset_control *devm_reset_control_get_by_index(
 {
 	return devm_reset_control_get_exclusive_by_index(dev, index);
 }
+
+/*
+ * APIs to manage a list of reset controllers
+ */
+static inline struct reset_control *
+devm_reset_control_array_get_exclusive(struct device *dev)
+{
+	return devm_reset_control_array_get(dev, false, false);
+}
+
+static inline struct reset_control *
+devm_reset_control_array_get_shared(struct device *dev)
+{
+	return devm_reset_control_array_get(dev, true, false);
+}
+
+static inline struct reset_control *
+devm_reset_control_array_get_optional_exclusive(struct device *dev)
+{
+	return devm_reset_control_array_get(dev, false, true);
+}
+
+static inline struct reset_control *
+devm_reset_control_array_get_optional_shared(struct device *dev)
+{
+	return devm_reset_control_array_get(dev, true, true);
+}
+
+static inline struct reset_control *
+of_reset_control_array_get_exclusive(struct device_node *node)
+{
+	return of_reset_control_array_get(node, false, false);
+}
+
+static inline struct reset_control *
+of_reset_control_array_get_shared(struct device_node *node)
+{
+	return of_reset_control_array_get(node, true, false);
+}
+
+static inline struct reset_control *
+of_reset_control_array_get_optional_exclusive(struct device_node *node)
+{
+	return of_reset_control_array_get(node, false, true);
+}
+
+static inline struct reset_control *
+of_reset_control_array_get_optional_shared(struct device_node *node)
+{
+	return of_reset_control_array_get(node, true, true);
+}
 #endif

commit 62e24c5775ecb387a3eb33701378ccfa6dbc98ee
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Fri Feb 5 13:41:39 2016 +0100

    reset: add exported __reset_control_get, return NULL if optional
    
    Rename the internal __reset_control_get/put functions to
    __reset_control_get/put_internal and add an exported
    __reset_control_get equivalent to __of_reset_control_get
    that takes a struct device parameter.
    This avoids the confusing call to __of_reset_control_get in
    the non-DT case and fixes the devm_reset_control_get_optional
    function to return NULL if RESET_CONTROLLER is enabled but
    dev->of_node == NULL.
    
    Fixes: bb475230b8e5 ("reset: make optional functions really optional")
    Reported-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Ramiro Oliveira <Ramiro.Oliveira@synopsys.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index 96fb139bdd08..13d8681210d5 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -15,6 +15,9 @@ int reset_control_status(struct reset_control *rstc);
 struct reset_control *__of_reset_control_get(struct device_node *node,
 				     const char *id, int index, bool shared,
 				     bool optional);
+struct reset_control *__reset_control_get(struct device *dev, const char *id,
+					  int index, bool shared,
+					  bool optional);
 void reset_control_put(struct reset_control *rstc);
 struct reset_control *__devm_reset_control_get(struct device *dev,
 				     const char *id, int index, bool shared,
@@ -72,6 +75,13 @@ static inline struct reset_control *__of_reset_control_get(
 	return optional ? NULL : ERR_PTR(-ENOTSUPP);
 }
 
+static inline struct reset_control *__reset_control_get(
+					struct device *dev, const char *id,
+					int index, bool shared, bool optional)
+{
+	return optional ? NULL : ERR_PTR(-ENOTSUPP);
+}
+
 static inline struct reset_control *__devm_reset_control_get(
 					struct device *dev, const char *id,
 					int index, bool shared, bool optional)
@@ -102,8 +112,7 @@ __must_check reset_control_get_exclusive(struct device *dev, const char *id)
 #ifndef CONFIG_RESET_CONTROLLER
 	WARN_ON(1);
 #endif
-	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, false,
-									false);
+	return __reset_control_get(dev, id, 0, false, false);
 }
 
 /**
@@ -131,22 +140,19 @@ __must_check reset_control_get_exclusive(struct device *dev, const char *id)
 static inline struct reset_control *reset_control_get_shared(
 					struct device *dev, const char *id)
 {
-	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, true,
-									false);
+	return __reset_control_get(dev, id, 0, true, false);
 }
 
 static inline struct reset_control *reset_control_get_optional_exclusive(
 					struct device *dev, const char *id)
 {
-	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, false,
-									true);
+	return __reset_control_get(dev, id, 0, false, true);
 }
 
 static inline struct reset_control *reset_control_get_optional_shared(
 					struct device *dev, const char *id)
 {
-	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, true,
-									true);
+	return __reset_control_get(dev, id, 0, true, true);
 }
 
 /**

commit 0ca10b60ceeb5372da01798ca68c116ae45a6eb6
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Mon Mar 20 11:25:16 2017 +0100

    reset: fix optional reset_control_get stubs to return NULL
    
    When RESET_CONTROLLER is not enabled, the optional reset_control_get
    stubs should now also return NULL.
    
    Since it is now valid for reset_control_assert/deassert/reset/status/put
    to be called unconditionally, with NULL as an argument for optional
    resets, the stubs are not allowed to warn anymore.
    
    Fixes: bb475230b8e5 ("reset: make optional functions really optional")
    Reported-by: Andrzej Hajda <a.hajda@samsung.com>
    Tested-by: Andrzej Hajda <a.hajda@samsung.com>
    Reviewed-by: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Ramiro Oliveira <Ramiro.Oliveira@synopsys.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index 86b4ed75359e..96fb139bdd08 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -31,31 +31,26 @@ static inline int device_reset_optional(struct device *dev)
 
 static inline int reset_control_reset(struct reset_control *rstc)
 {
-	WARN_ON(1);
 	return 0;
 }
 
 static inline int reset_control_assert(struct reset_control *rstc)
 {
-	WARN_ON(1);
 	return 0;
 }
 
 static inline int reset_control_deassert(struct reset_control *rstc)
 {
-	WARN_ON(1);
 	return 0;
 }
 
 static inline int reset_control_status(struct reset_control *rstc)
 {
-	WARN_ON(1);
 	return 0;
 }
 
 static inline void reset_control_put(struct reset_control *rstc)
 {
-	WARN_ON(1);
 }
 
 static inline int __must_check device_reset(struct device *dev)
@@ -74,14 +69,14 @@ static inline struct reset_control *__of_reset_control_get(
 					const char *id, int index, bool shared,
 					bool optional)
 {
-	return ERR_PTR(-ENOTSUPP);
+	return optional ? NULL : ERR_PTR(-ENOTSUPP);
 }
 
 static inline struct reset_control *__devm_reset_control_get(
 					struct device *dev, const char *id,
 					int index, bool shared, bool optional)
 {
-	return ERR_PTR(-ENOTSUPP);
+	return optional ? NULL : ERR_PTR(-ENOTSUPP);
 }
 
 #endif /* CONFIG_RESET_CONTROLLER */

commit bb475230b8e59a547ab66ac3b02572df21a580e9
Author: Ramiro Oliveira <Ramiro.Oliveira@synopsys.com>
Date:   Fri Jan 13 17:57:41 2017 +0000

    reset: make optional functions really optional
    
    The *_get_optional_* functions weren't really optional so this patch
    makes them really optional.
    
    These *_get_optional_* functions will now return NULL instead of an error
    if no matching reset phandle is found in the DT, and all the
    reset_control_* functions now accept NULL rstc pointers.
    
    Signed-off-by: Ramiro Oliveira <Ramiro.Oliveira@synopsys.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index ec1d1fd28f5f..86b4ed75359e 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -13,10 +13,12 @@ int reset_control_deassert(struct reset_control *rstc);
 int reset_control_status(struct reset_control *rstc);
 
 struct reset_control *__of_reset_control_get(struct device_node *node,
-				     const char *id, int index, bool shared);
+				     const char *id, int index, bool shared,
+				     bool optional);
 void reset_control_put(struct reset_control *rstc);
 struct reset_control *__devm_reset_control_get(struct device *dev,
-				     const char *id, int index, bool shared);
+				     const char *id, int index, bool shared,
+				     bool optional);
 
 int __must_check device_reset(struct device *dev);
 
@@ -69,14 +71,15 @@ static inline int device_reset_optional(struct device *dev)
 
 static inline struct reset_control *__of_reset_control_get(
 					struct device_node *node,
-					const char *id, int index, bool shared)
+					const char *id, int index, bool shared,
+					bool optional)
 {
 	return ERR_PTR(-ENOTSUPP);
 }
 
 static inline struct reset_control *__devm_reset_control_get(
-					struct device *dev,
-					const char *id, int index, bool shared)
+					struct device *dev, const char *id,
+					int index, bool shared, bool optional)
 {
 	return ERR_PTR(-ENOTSUPP);
 }
@@ -104,7 +107,8 @@ __must_check reset_control_get_exclusive(struct device *dev, const char *id)
 #ifndef CONFIG_RESET_CONTROLLER
 	WARN_ON(1);
 #endif
-	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, 0);
+	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, false,
+									false);
 }
 
 /**
@@ -132,19 +136,22 @@ __must_check reset_control_get_exclusive(struct device *dev, const char *id)
 static inline struct reset_control *reset_control_get_shared(
 					struct device *dev, const char *id)
 {
-	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, true);
+	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, true,
+									false);
 }
 
 static inline struct reset_control *reset_control_get_optional_exclusive(
 					struct device *dev, const char *id)
 {
-	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, false);
+	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, false,
+									true);
 }
 
 static inline struct reset_control *reset_control_get_optional_shared(
 					struct device *dev, const char *id)
 {
-	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, true);
+	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, true,
+									true);
 }
 
 /**
@@ -160,7 +167,7 @@ static inline struct reset_control *reset_control_get_optional_shared(
 static inline struct reset_control *of_reset_control_get_exclusive(
 				struct device_node *node, const char *id)
 {
-	return __of_reset_control_get(node, id, 0, 0);
+	return __of_reset_control_get(node, id, 0, false, false);
 }
 
 /**
@@ -185,7 +192,7 @@ static inline struct reset_control *of_reset_control_get_exclusive(
 static inline struct reset_control *of_reset_control_get_shared(
 				struct device_node *node, const char *id)
 {
-	return __of_reset_control_get(node, id, 0, true);
+	return __of_reset_control_get(node, id, 0, true, false);
 }
 
 /**
@@ -202,7 +209,7 @@ static inline struct reset_control *of_reset_control_get_shared(
 static inline struct reset_control *of_reset_control_get_exclusive_by_index(
 					struct device_node *node, int index)
 {
-	return __of_reset_control_get(node, NULL, index, false);
+	return __of_reset_control_get(node, NULL, index, false, false);
 }
 
 /**
@@ -230,7 +237,7 @@ static inline struct reset_control *of_reset_control_get_exclusive_by_index(
 static inline struct reset_control *of_reset_control_get_shared_by_index(
 					struct device_node *node, int index)
 {
-	return __of_reset_control_get(node, NULL, index, true);
+	return __of_reset_control_get(node, NULL, index, true, false);
 }
 
 /**
@@ -252,7 +259,7 @@ __must_check devm_reset_control_get_exclusive(struct device *dev,
 #ifndef CONFIG_RESET_CONTROLLER
 	WARN_ON(1);
 #endif
-	return __devm_reset_control_get(dev, id, 0, false);
+	return __devm_reset_control_get(dev, id, 0, false, false);
 }
 
 /**
@@ -267,19 +274,19 @@ __must_check devm_reset_control_get_exclusive(struct device *dev,
 static inline struct reset_control *devm_reset_control_get_shared(
 					struct device *dev, const char *id)
 {
-	return __devm_reset_control_get(dev, id, 0, true);
+	return __devm_reset_control_get(dev, id, 0, true, false);
 }
 
 static inline struct reset_control *devm_reset_control_get_optional_exclusive(
 					struct device *dev, const char *id)
 {
-	return __devm_reset_control_get(dev, id, 0, false);
+	return __devm_reset_control_get(dev, id, 0, false, true);
 }
 
 static inline struct reset_control *devm_reset_control_get_optional_shared(
 					struct device *dev, const char *id)
 {
-	return __devm_reset_control_get(dev, id, 0, true);
+	return __devm_reset_control_get(dev, id, 0, true, true);
 }
 
 /**
@@ -297,7 +304,7 @@ static inline struct reset_control *devm_reset_control_get_optional_shared(
 static inline struct reset_control *
 devm_reset_control_get_exclusive_by_index(struct device *dev, int index)
 {
-	return __devm_reset_control_get(dev, NULL, index, false);
+	return __devm_reset_control_get(dev, NULL, index, false, false);
 }
 
 /**
@@ -313,7 +320,7 @@ devm_reset_control_get_exclusive_by_index(struct device *dev, int index)
 static inline struct reset_control *
 devm_reset_control_get_shared_by_index(struct device *dev, int index)
 {
-	return __devm_reset_control_get(dev, NULL, index, true);
+	return __devm_reset_control_get(dev, NULL, index, true, false);
 }
 
 /*

commit ee48c726d0b014ac8dd5ec803fb63ce0596a42cf
Author: Ramiro Oliveira <Ramiro.Oliveira@synopsys.com>
Date:   Fri Jan 13 17:57:40 2017 +0000

    reset: Change shared flag from int to bool
    
    Since the new parameter being added is going to be a bool this patch
    changes the shared flag from int to bool to match the new parameter.
    
    Signed-off-by: Ramiro Oliveira <Ramiro.Oliveira@synopsys.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index 5daff15722d3..ec1d1fd28f5f 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -13,10 +13,10 @@ int reset_control_deassert(struct reset_control *rstc);
 int reset_control_status(struct reset_control *rstc);
 
 struct reset_control *__of_reset_control_get(struct device_node *node,
-				     const char *id, int index, int shared);
+				     const char *id, int index, bool shared);
 void reset_control_put(struct reset_control *rstc);
 struct reset_control *__devm_reset_control_get(struct device *dev,
-				     const char *id, int index, int shared);
+				     const char *id, int index, bool shared);
 
 int __must_check device_reset(struct device *dev);
 
@@ -69,14 +69,14 @@ static inline int device_reset_optional(struct device *dev)
 
 static inline struct reset_control *__of_reset_control_get(
 					struct device_node *node,
-					const char *id, int index, int shared)
+					const char *id, int index, bool shared)
 {
 	return ERR_PTR(-ENOTSUPP);
 }
 
 static inline struct reset_control *__devm_reset_control_get(
 					struct device *dev,
-					const char *id, int index, int shared)
+					const char *id, int index, bool shared)
 {
 	return ERR_PTR(-ENOTSUPP);
 }
@@ -132,19 +132,19 @@ __must_check reset_control_get_exclusive(struct device *dev, const char *id)
 static inline struct reset_control *reset_control_get_shared(
 					struct device *dev, const char *id)
 {
-	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, 1);
+	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, true);
 }
 
 static inline struct reset_control *reset_control_get_optional_exclusive(
 					struct device *dev, const char *id)
 {
-	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, 0);
+	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, false);
 }
 
 static inline struct reset_control *reset_control_get_optional_shared(
 					struct device *dev, const char *id)
 {
-	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, 1);
+	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, true);
 }
 
 /**
@@ -185,7 +185,7 @@ static inline struct reset_control *of_reset_control_get_exclusive(
 static inline struct reset_control *of_reset_control_get_shared(
 				struct device_node *node, const char *id)
 {
-	return __of_reset_control_get(node, id, 0, 1);
+	return __of_reset_control_get(node, id, 0, true);
 }
 
 /**
@@ -202,7 +202,7 @@ static inline struct reset_control *of_reset_control_get_shared(
 static inline struct reset_control *of_reset_control_get_exclusive_by_index(
 					struct device_node *node, int index)
 {
-	return __of_reset_control_get(node, NULL, index, 0);
+	return __of_reset_control_get(node, NULL, index, false);
 }
 
 /**
@@ -230,7 +230,7 @@ static inline struct reset_control *of_reset_control_get_exclusive_by_index(
 static inline struct reset_control *of_reset_control_get_shared_by_index(
 					struct device_node *node, int index)
 {
-	return __of_reset_control_get(node, NULL, index, 1);
+	return __of_reset_control_get(node, NULL, index, true);
 }
 
 /**
@@ -252,7 +252,7 @@ __must_check devm_reset_control_get_exclusive(struct device *dev,
 #ifndef CONFIG_RESET_CONTROLLER
 	WARN_ON(1);
 #endif
-	return __devm_reset_control_get(dev, id, 0, 0);
+	return __devm_reset_control_get(dev, id, 0, false);
 }
 
 /**
@@ -267,19 +267,19 @@ __must_check devm_reset_control_get_exclusive(struct device *dev,
 static inline struct reset_control *devm_reset_control_get_shared(
 					struct device *dev, const char *id)
 {
-	return __devm_reset_control_get(dev, id, 0, 1);
+	return __devm_reset_control_get(dev, id, 0, true);
 }
 
 static inline struct reset_control *devm_reset_control_get_optional_exclusive(
 					struct device *dev, const char *id)
 {
-	return __devm_reset_control_get(dev, id, 0, 0);
+	return __devm_reset_control_get(dev, id, 0, false);
 }
 
 static inline struct reset_control *devm_reset_control_get_optional_shared(
 					struct device *dev, const char *id)
 {
-	return __devm_reset_control_get(dev, id, 0, 1);
+	return __devm_reset_control_get(dev, id, 0, true);
 }
 
 /**
@@ -297,7 +297,7 @@ static inline struct reset_control *devm_reset_control_get_optional_shared(
 static inline struct reset_control *
 devm_reset_control_get_exclusive_by_index(struct device *dev, int index)
 {
-	return __devm_reset_control_get(dev, NULL, index, 0);
+	return __devm_reset_control_get(dev, NULL, index, false);
 }
 
 /**
@@ -313,7 +313,7 @@ devm_reset_control_get_exclusive_by_index(struct device *dev, int index)
 static inline struct reset_control *
 devm_reset_control_get_shared_by_index(struct device *dev, int index)
 {
-	return __devm_reset_control_get(dev, NULL, index, 1);
+	return __devm_reset_control_get(dev, NULL, index, true);
 }
 
 /*

commit af3e1629c8d0d26627f3dcc237a6facda8bb1090
Merge: cc7c2bb1493c 0bcc0eab363a
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Wed Jun 29 23:39:52 2016 +0200

    Merge branch 'reset/explicit-api' into reset/next

commit 0bcc0eab363aa80f79769324bf3f2ab7781840f2
Author: Lee Jones <lee.jones@linaro.org>
Date:   Mon Jun 6 16:56:53 2016 +0100

    reset: TRIVIAL: Add line break at same place for similar APIs
    
    Standardise the way inline functions:
    
      devm_reset_control_get_shared_by_index
      devm_reset_control_get_exclusive_by_index
    
    ... are formatted.
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index c358106611af..45a4abeb6acb 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -310,8 +310,8 @@ devm_reset_control_get_exclusive_by_index(struct device *dev, int index)
  * this function, reset_control_put() is called automatically on driver detach.
  * See reset_control_get_shared() for more information.
  */
-static inline struct reset_control *devm_reset_control_get_shared_by_index(
-					struct device *dev, int index)
+static inline struct reset_control *
+devm_reset_control_get_shared_by_index(struct device *dev, int index)
 {
 	return __devm_reset_control_get(dev, NULL, index, 1);
 }

commit c33d61a0c400c50f378ef03a386e646abca292ca
Author: Lee Jones <lee.jones@linaro.org>
Date:   Mon Jun 6 16:56:52 2016 +0100

    reset: Supply *_shared variant calls when using *_optional APIs
    
    Consumers need to be able to specify whether they are requesting an
    'exclusive' or 'shared' reset line no matter which API (of_*, devm_*,
    etc) they are using.  This change allows users of the optional_* API
    in particular to specify that their request is for a 'shared' line.
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index fd69240907c8..c358106611af 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -141,6 +141,12 @@ static inline struct reset_control *reset_control_get_optional_exclusive(
 	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, 0);
 }
 
+static inline struct reset_control *reset_control_get_optional_shared(
+					struct device *dev, const char *id)
+{
+	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, 1);
+}
+
 /**
  * of_reset_control_get_exclusive - Lookup and obtain an exclusive reference
  *                                  to a reset controller.
@@ -270,6 +276,12 @@ static inline struct reset_control *devm_reset_control_get_optional_exclusive(
 	return __devm_reset_control_get(dev, id, 0, 0);
 }
 
+static inline struct reset_control *devm_reset_control_get_optional_shared(
+					struct device *dev, const char *id)
+{
+	return __devm_reset_control_get(dev, id, 0, 1);
+}
+
 /**
  * devm_reset_control_get_exclusive_by_index - resource managed
  *                                             reset_control_get_exclusive()

commit 40faee8ee471ae526344cd5c62ff520d356de841
Author: Lee Jones <lee.jones@linaro.org>
Date:   Mon Jun 6 16:56:51 2016 +0100

    reset: Supply *_shared variant calls when using of_* API
    
    Consumers need to be able to specify whether they are requesting an
    'exclusive' or 'shared' reset line no matter which API (of_*, devm_*,
    etc) they are using.  This change allows users of the of_* API in
    particular to specify that their request is for a 'shared' line.
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index 9cf4cf39bf1d..fd69240907c8 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -157,6 +157,31 @@ static inline struct reset_control *of_reset_control_get_exclusive(
 	return __of_reset_control_get(node, id, 0, 0);
 }
 
+/**
+ * of_reset_control_get_shared - Lookup and obtain an shared reference
+ *                               to a reset controller.
+ * @node: device to be reset by the controller
+ * @id: reset line name
+ *
+ * When a reset-control is shared, the behavior of reset_control_assert /
+ * deassert is changed, the reset-core will keep track of a deassert_count
+ * and only (re-)assert the reset after reset_control_assert has been called
+ * as many times as reset_control_deassert was called. Also see the remark
+ * about shared reset-controls in the reset_control_assert docs.
+ *
+ * Calling reset_control_assert without first calling reset_control_deassert
+ * is not allowed on a shared reset control. Calling reset_control_reset is
+ * also not allowed on a shared reset control.
+ * Returns a struct reset_control or IS_ERR() condition containing errno.
+ *
+ * Use of id names is optional.
+ */
+static inline struct reset_control *of_reset_control_get_shared(
+				struct device_node *node, const char *id)
+{
+	return __of_reset_control_get(node, id, 0, 1);
+}
+
 /**
  * of_reset_control_get_exclusive_by_index - Lookup and obtain an exclusive
  *                                           reference to a reset controller
@@ -174,6 +199,34 @@ static inline struct reset_control *of_reset_control_get_exclusive_by_index(
 	return __of_reset_control_get(node, NULL, index, 0);
 }
 
+/**
+ * of_reset_control_get_shared_by_index - Lookup and obtain an shared
+ *                                        reference to a reset controller
+ *                                        by index.
+ * @node: device to be reset by the controller
+ * @index: index of the reset controller
+ *
+ * When a reset-control is shared, the behavior of reset_control_assert /
+ * deassert is changed, the reset-core will keep track of a deassert_count
+ * and only (re-)assert the reset after reset_control_assert has been called
+ * as many times as reset_control_deassert was called. Also see the remark
+ * about shared reset-controls in the reset_control_assert docs.
+ *
+ * Calling reset_control_assert without first calling reset_control_deassert
+ * is not allowed on a shared reset control. Calling reset_control_reset is
+ * also not allowed on a shared reset control.
+ * Returns a struct reset_control or IS_ERR() condition containing errno.
+ *
+ * This is to be used to perform a list of resets for a device or power domain
+ * in whatever order. Returns a struct reset_control or IS_ERR() condition
+ * containing errno.
+ */
+static inline struct reset_control *of_reset_control_get_shared_by_index(
+					struct device_node *node, int index)
+{
+	return __of_reset_control_get(node, NULL, index, 1);
+}
+
 /**
  * devm_reset_control_get_exclusive - resource managed
  *                                    reset_control_get_exclusive()

commit a53e35db70d1638002e40d495d096181dbb0fe16
Author: Lee Jones <lee.jones@linaro.org>
Date:   Mon Jun 6 16:56:50 2016 +0100

    reset: Ensure drivers are explicit when requesting reset lines
    
    Phasing out generic reset line requests enables us to make some better
    decisions on when and how to (de)assert said lines.  If an 'exclusive'
    line is requested, we know a device *requires* a reset and that it's
    preferable to act upon a request right away.  However, if a 'shared'
    reset line is requested, we can reasonably assume sure that placing a
    device into reset isn't a hard requirement, but probably a measure to
    save power and is thus able to cope with not being asserted if another
    device is still in use.
    
    In order allow gentle adoption and not to forcing all consumers to
    move to the API immediately, causing administration headache between
    subsystems, this patch adds some temporary stand-in shim-calls.  This
    will ease the burden at merge time and allow subsystems to migrate over
    to the new API in a more realistic time-frame.
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index 33eaf11dabe2..9cf4cf39bf1d 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -84,8 +84,8 @@ static inline struct reset_control *__devm_reset_control_get(
 #endif /* CONFIG_RESET_CONTROLLER */
 
 /**
- * reset_control_get - Lookup and obtain an exclusive reference to a
- *                     reset controller.
+ * reset_control_get_exclusive - Lookup and obtain an exclusive reference
+ *                               to a reset controller.
  * @dev: device to be reset by the controller
  * @id: reset line name
  *
@@ -98,8 +98,8 @@ static inline struct reset_control *__devm_reset_control_get(
  *
  * Use of id names is optional.
  */
-static inline struct reset_control *__must_check reset_control_get(
-					struct device *dev, const char *id)
+static inline struct reset_control *
+__must_check reset_control_get_exclusive(struct device *dev, const char *id)
 {
 #ifndef CONFIG_RESET_CONTROLLER
 	WARN_ON(1);
@@ -135,15 +135,15 @@ static inline struct reset_control *reset_control_get_shared(
 	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, 1);
 }
 
-static inline struct reset_control *reset_control_get_optional(
+static inline struct reset_control *reset_control_get_optional_exclusive(
 					struct device *dev, const char *id)
 {
 	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, 0);
 }
 
 /**
- * of_reset_control_get - Lookup and obtain an exclusive reference to a
- *                        reset controller.
+ * of_reset_control_get_exclusive - Lookup and obtain an exclusive reference
+ *                                  to a reset controller.
  * @node: device to be reset by the controller
  * @id: reset line name
  *
@@ -151,15 +151,16 @@ static inline struct reset_control *reset_control_get_optional(
  *
  * Use of id names is optional.
  */
-static inline struct reset_control *of_reset_control_get(
+static inline struct reset_control *of_reset_control_get_exclusive(
 				struct device_node *node, const char *id)
 {
 	return __of_reset_control_get(node, id, 0, 0);
 }
 
 /**
- * of_reset_control_get_by_index - Lookup and obtain an exclusive reference to
- *                                 a reset controller by index.
+ * of_reset_control_get_exclusive_by_index - Lookup and obtain an exclusive
+ *                                           reference to a reset controller
+ *                                           by index.
  * @node: device to be reset by the controller
  * @index: index of the reset controller
  *
@@ -167,23 +168,27 @@ static inline struct reset_control *of_reset_control_get(
  * in whatever order. Returns a struct reset_control or IS_ERR() condition
  * containing errno.
  */
-static inline struct reset_control *of_reset_control_get_by_index(
+static inline struct reset_control *of_reset_control_get_exclusive_by_index(
 					struct device_node *node, int index)
 {
 	return __of_reset_control_get(node, NULL, index, 0);
 }
 
 /**
- * devm_reset_control_get - resource managed reset_control_get()
+ * devm_reset_control_get_exclusive - resource managed
+ *                                    reset_control_get_exclusive()
  * @dev: device to be reset by the controller
  * @id: reset line name
  *
- * Managed reset_control_get(). For reset controllers returned from this
- * function, reset_control_put() is called automatically on driver detach.
- * See reset_control_get() for more information.
+ * Managed reset_control_get_exclusive(). For reset controllers returned
+ * from this function, reset_control_put() is called automatically on driver
+ * detach.
+ *
+ * See reset_control_get_exclusive() for more information.
  */
-static inline struct reset_control *__must_check devm_reset_control_get(
-					struct device *dev, const char *id)
+static inline struct reset_control *
+__must_check devm_reset_control_get_exclusive(struct device *dev,
+					      const char *id)
 {
 #ifndef CONFIG_RESET_CONTROLLER
 	WARN_ON(1);
@@ -206,23 +211,26 @@ static inline struct reset_control *devm_reset_control_get_shared(
 	return __devm_reset_control_get(dev, id, 0, 1);
 }
 
-static inline struct reset_control *devm_reset_control_get_optional(
+static inline struct reset_control *devm_reset_control_get_optional_exclusive(
 					struct device *dev, const char *id)
 {
 	return __devm_reset_control_get(dev, id, 0, 0);
 }
 
 /**
- * devm_reset_control_get_by_index - resource managed reset_control_get
+ * devm_reset_control_get_exclusive_by_index - resource managed
+ *                                             reset_control_get_exclusive()
  * @dev: device to be reset by the controller
  * @index: index of the reset controller
  *
- * Managed reset_control_get(). For reset controllers returned from this
- * function, reset_control_put() is called automatically on driver detach.
- * See reset_control_get() for more information.
+ * Managed reset_control_get_exclusive(). For reset controllers returned from
+ * this function, reset_control_put() is called automatically on driver
+ * detach.
+ *
+ * See reset_control_get_exclusive() for more information.
  */
-static inline struct reset_control *devm_reset_control_get_by_index(
-					struct device *dev, int index)
+static inline struct reset_control *
+devm_reset_control_get_exclusive_by_index(struct device *dev, int index)
 {
 	return __devm_reset_control_get(dev, NULL, index, 0);
 }
@@ -243,4 +251,54 @@ static inline struct reset_control *devm_reset_control_get_shared_by_index(
 	return __devm_reset_control_get(dev, NULL, index, 1);
 }
 
+/*
+ * TEMPORARY calls to use during transition:
+ *
+ *   of_reset_control_get() => of_reset_control_get_exclusive()
+ *
+ * These inline function calls will be removed once all consumers
+ * have been moved over to the new explicit API.
+ */
+static inline struct reset_control *reset_control_get(
+				struct device *dev, const char *id)
+{
+	return reset_control_get_exclusive(dev, id);
+}
+
+static inline struct reset_control *reset_control_get_optional(
+					struct device *dev, const char *id)
+{
+	return reset_control_get_optional_exclusive(dev, id);
+}
+
+static inline struct reset_control *of_reset_control_get(
+				struct device_node *node, const char *id)
+{
+	return of_reset_control_get_exclusive(node, id);
+}
+
+static inline struct reset_control *of_reset_control_get_by_index(
+				struct device_node *node, int index)
+{
+	return of_reset_control_get_exclusive_by_index(node, index);
+}
+
+static inline struct reset_control *devm_reset_control_get(
+				struct device *dev, const char *id)
+{
+	return devm_reset_control_get_exclusive(dev, id);
+}
+
+static inline struct reset_control *devm_reset_control_get_optional(
+				struct device *dev, const char *id)
+{
+	return devm_reset_control_get_optional_exclusive(dev, id);
+
+}
+
+static inline struct reset_control *devm_reset_control_get_by_index(
+				struct device *dev, int index)
+{
+	return devm_reset_control_get_exclusive_by_index(dev, index);
+}
 #endif

commit 3c35f6edc09b239a60de87a5aeb78563fc372704
Author: Lee Jones <lee.jones@linaro.org>
Date:   Mon Jun 6 16:56:49 2016 +0100

    reset: Reorder inline reset_control_get*() wrappers
    
    We're about to split the current API into two, where consumers will
    be forced to be explicit when requesting reset lines.  The choice
    will be to either the call the *_exclusive or *_shared variant
    depending on whether they can actually tolorate not being asserted
    when that request is made.
    
    The new API will look like this once reorded and complete:
    
      reset_control_get_exclusive()
      reset_control_get_shared()
      reset_control_get_optional_exclusive()
      reset_control_get_optional_shared()
      of_reset_control_get_exclusive()
      of_reset_control_get_shared()
      of_reset_control_get_exclusive_by_index()
      of_reset_control_get_shared_by_index()
      devm_reset_control_get_exclusive()
      devm_reset_control_get_shared()
      devm_reset_control_get_optional_exclusive()
      devm_reset_control_get_optional_shared()
      devm_reset_control_get_exclusive_by_index()
      devm_reset_control_get_shared_by_index()
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index ec0306ce7b92..33eaf11dabe2 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -107,12 +107,6 @@ static inline struct reset_control *__must_check reset_control_get(
 	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, 0);
 }
 
-static inline struct reset_control *reset_control_get_optional(
-					struct device *dev, const char *id)
-{
-	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, 0);
-}
-
 /**
  * reset_control_get_shared - Lookup and obtain a shared reference to a
  *                            reset controller.
@@ -141,6 +135,12 @@ static inline struct reset_control *reset_control_get_shared(
 	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, 1);
 }
 
+static inline struct reset_control *reset_control_get_optional(
+					struct device *dev, const char *id)
+{
+	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, 0);
+}
+
 /**
  * of_reset_control_get - Lookup and obtain an exclusive reference to a
  *                        reset controller.
@@ -191,6 +191,21 @@ static inline struct reset_control *__must_check devm_reset_control_get(
 	return __devm_reset_control_get(dev, id, 0, 0);
 }
 
+/**
+ * devm_reset_control_get_shared - resource managed reset_control_get_shared()
+ * @dev: device to be reset by the controller
+ * @id: reset line name
+ *
+ * Managed reset_control_get_shared(). For reset controllers returned from
+ * this function, reset_control_put() is called automatically on driver detach.
+ * See reset_control_get_shared() for more information.
+ */
+static inline struct reset_control *devm_reset_control_get_shared(
+					struct device *dev, const char *id)
+{
+	return __devm_reset_control_get(dev, id, 0, 1);
+}
+
 static inline struct reset_control *devm_reset_control_get_optional(
 					struct device *dev, const char *id)
 {
@@ -212,21 +227,6 @@ static inline struct reset_control *devm_reset_control_get_by_index(
 	return __devm_reset_control_get(dev, NULL, index, 0);
 }
 
-/**
- * devm_reset_control_get_shared - resource managed reset_control_get_shared()
- * @dev: device to be reset by the controller
- * @id: reset line name
- *
- * Managed reset_control_get_shared(). For reset controllers returned from
- * this function, reset_control_put() is called automatically on driver detach.
- * See reset_control_get_shared() for more information.
- */
-static inline struct reset_control *devm_reset_control_get_shared(
-					struct device *dev, const char *id)
-{
-	return __devm_reset_control_get(dev, id, 0, 1);
-}
-
 /**
  * devm_reset_control_get_shared_by_index - resource managed
  * reset_control_get_shared

commit 168d7c4e8bb25c076ed8be67fcca84f5dcd0b2c6
Author: John Youn <johnyoun@synopsys.com>
Date:   Tue May 31 16:55:01 2016 -0700

    reset: Return -ENOTSUPP when not configured
    
    Prior to commit 6c96f05c8bb8 ("reset: Make [of_]reset_control_get[_foo]
    functions wrappers"), the "optional" functions returned -ENOTSUPP when
    CONFIG_RESET_CONTROLLER was not set.
    
    Revert back to the old behavior by changing the new
    __devm_reset_control_get() and __of_reset_control_get() functions to
    return ERR_PTR(-ENOTSUPP) when compiled without CONFIG_RESET_CONTROLLER.
    
    Otherwise they will return -EINVAL causing users to think that an error
    occurred when CONFIG_RESET_CONTROLLER is not set.
    
    Fixes: 6c96f05c8bb8 ("reset: Make [of_]reset_control_get[_foo] functions wrappers")
    Signed-off-by: John Youn <johnyoun@synopsys.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index ec0306ce7b92..067db57c81dc 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -71,14 +71,14 @@ static inline struct reset_control *__of_reset_control_get(
 					struct device_node *node,
 					const char *id, int index, int shared)
 {
-	return ERR_PTR(-EINVAL);
+	return ERR_PTR(-ENOTSUPP);
 }
 
 static inline struct reset_control *__devm_reset_control_get(
 					struct device *dev,
 					const char *id, int index, int shared)
 {
-	return ERR_PTR(-EINVAL);
+	return ERR_PTR(-ENOTSUPP);
 }
 
 #endif /* CONFIG_RESET_CONTROLLER */

commit 4113652252fad972e0c191b1e536dc74a6faebdc
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri Apr 1 21:38:16 2016 +0200

    reset: Add missing function stub for device_reset
    
    The Mediatek's thermal driver fails to compile when the RESET_CONTROLLER
    option is not set. Logically, as the driver depends on this option to compile,
    the Kconfig should select it but actually that is not correct because the
    Kconfig provides also the COMPILE_TEST to increase the compile test coverage.
    
    By providing the missing 'device_reset' stub for the driver in reset.h, that
    let the kernel to compile on different platforms with the Mediatek thermal
    driver enabled with the COMPILE_TEST option.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index a552134a209e..ec0306ce7b92 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -56,6 +56,12 @@ static inline void reset_control_put(struct reset_control *rstc)
 	WARN_ON(1);
 }
 
+static inline int __must_check device_reset(struct device *dev)
+{
+	WARN_ON(1);
+	return -ENOTSUPP;
+}
+
 static inline int device_reset_optional(struct device *dev)
 {
 	return -ENOTSUPP;

commit 0b52297f2288ca239e598afe6c92db83d8d2bfcd
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Feb 23 18:46:26 2016 +0100

    reset: Add support for shared reset controls
    
    In some SoCs some hw-blocks share a reset control. Add support for this
    setup by adding new:
    
    reset_control_get_shared()
    devm_reset_control_get_shared()
    devm_reset_control_get_shared_by_index()
    
    methods to get a reset_control. Note that this patch omits adding of_
    variants, if these are needed later they can be easily added.
    
    This patch also changes the behavior of the existing exclusive
    reset_control_get() variants, if these are now called more then once
    for the same reset_control they will return -EBUSY. To catch existing
    drivers triggering this error (there should not be any) a WARN_ON(1)
    is added in this path.
    
    When a reset_control is shared, the behavior of reset_control_assert /
    deassert is changed, for shared reset_controls these will work like the
    clock-enable/disable and regulator-on/off functions. They will keep a
    deassert_count, and only (re-)assert the reset after reset_control_assert
    has been called as many times as reset_control_deassert was called.
    
    Calling reset_control_assert without first calling reset_control_deassert
    is not allowed on a shared reset control. Calling reset_control_reset is
    also not allowed on a shared reset control.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index 1bb69a29d6db..a552134a209e 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -13,10 +13,10 @@ int reset_control_deassert(struct reset_control *rstc);
 int reset_control_status(struct reset_control *rstc);
 
 struct reset_control *__of_reset_control_get(struct device_node *node,
-					     const char *id, int index);
+				     const char *id, int index, int shared);
 void reset_control_put(struct reset_control *rstc);
 struct reset_control *__devm_reset_control_get(struct device *dev,
-					       const char *id, int index);
+				     const char *id, int index, int shared);
 
 int __must_check device_reset(struct device *dev);
 
@@ -63,14 +63,14 @@ static inline int device_reset_optional(struct device *dev)
 
 static inline struct reset_control *__of_reset_control_get(
 					struct device_node *node,
-					const char *id, int index)
+					const char *id, int index, int shared)
 {
 	return ERR_PTR(-EINVAL);
 }
 
 static inline struct reset_control *__devm_reset_control_get(
 					struct device *dev,
-					const char *id, int index)
+					const char *id, int index, int shared)
 {
 	return ERR_PTR(-EINVAL);
 }
@@ -78,11 +78,17 @@ static inline struct reset_control *__devm_reset_control_get(
 #endif /* CONFIG_RESET_CONTROLLER */
 
 /**
- * reset_control_get - Lookup and obtain a reference to a reset controller.
+ * reset_control_get - Lookup and obtain an exclusive reference to a
+ *                     reset controller.
  * @dev: device to be reset by the controller
  * @id: reset line name
  *
  * Returns a struct reset_control or IS_ERR() condition containing errno.
+ * If this function is called more then once for the same reset_control it will
+ * return -EBUSY.
+ *
+ * See reset_control_get_shared for details on shared references to
+ * reset-controls.
  *
  * Use of id names is optional.
  */
@@ -92,17 +98,46 @@ static inline struct reset_control *__must_check reset_control_get(
 #ifndef CONFIG_RESET_CONTROLLER
 	WARN_ON(1);
 #endif
-	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0);
+	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, 0);
 }
 
 static inline struct reset_control *reset_control_get_optional(
 					struct device *dev, const char *id)
 {
-	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0);
+	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, 0);
 }
 
 /**
- * of_reset_control_get - Lookup and obtain a reference to a reset controller.
+ * reset_control_get_shared - Lookup and obtain a shared reference to a
+ *                            reset controller.
+ * @dev: device to be reset by the controller
+ * @id: reset line name
+ *
+ * Returns a struct reset_control or IS_ERR() condition containing errno.
+ * This function is intended for use with reset-controls which are shared
+ * between hardware-blocks.
+ *
+ * When a reset-control is shared, the behavior of reset_control_assert /
+ * deassert is changed, the reset-core will keep track of a deassert_count
+ * and only (re-)assert the reset after reset_control_assert has been called
+ * as many times as reset_control_deassert was called. Also see the remark
+ * about shared reset-controls in the reset_control_assert docs.
+ *
+ * Calling reset_control_assert without first calling reset_control_deassert
+ * is not allowed on a shared reset control. Calling reset_control_reset is
+ * also not allowed on a shared reset control.
+ *
+ * Use of id names is optional.
+ */
+static inline struct reset_control *reset_control_get_shared(
+					struct device *dev, const char *id)
+{
+	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0, 1);
+}
+
+/**
+ * of_reset_control_get - Lookup and obtain an exclusive reference to a
+ *                        reset controller.
  * @node: device to be reset by the controller
  * @id: reset line name
  *
@@ -113,12 +148,12 @@ static inline struct reset_control *reset_control_get_optional(
 static inline struct reset_control *of_reset_control_get(
 				struct device_node *node, const char *id)
 {
-	return __of_reset_control_get(node, id, 0);
+	return __of_reset_control_get(node, id, 0, 0);
 }
 
 /**
- * of_reset_control_get_by_index - Lookup and obtain a reference to a reset
- * controller by index.
+ * of_reset_control_get_by_index - Lookup and obtain an exclusive reference to
+ *                                 a reset controller by index.
  * @node: device to be reset by the controller
  * @index: index of the reset controller
  *
@@ -129,7 +164,7 @@ static inline struct reset_control *of_reset_control_get(
 static inline struct reset_control *of_reset_control_get_by_index(
 					struct device_node *node, int index)
 {
-	return __of_reset_control_get(node, NULL, index);
+	return __of_reset_control_get(node, NULL, index, 0);
 }
 
 /**
@@ -147,13 +182,13 @@ static inline struct reset_control *__must_check devm_reset_control_get(
 #ifndef CONFIG_RESET_CONTROLLER
 	WARN_ON(1);
 #endif
-	return __devm_reset_control_get(dev, id, 0);
+	return __devm_reset_control_get(dev, id, 0, 0);
 }
 
 static inline struct reset_control *devm_reset_control_get_optional(
 					struct device *dev, const char *id)
 {
-	return __devm_reset_control_get(dev, id, 0);
+	return __devm_reset_control_get(dev, id, 0, 0);
 }
 
 /**
@@ -168,7 +203,38 @@ static inline struct reset_control *devm_reset_control_get_optional(
 static inline struct reset_control *devm_reset_control_get_by_index(
 					struct device *dev, int index)
 {
-	return __devm_reset_control_get(dev, NULL, index);
+	return __devm_reset_control_get(dev, NULL, index, 0);
+}
+
+/**
+ * devm_reset_control_get_shared - resource managed reset_control_get_shared()
+ * @dev: device to be reset by the controller
+ * @id: reset line name
+ *
+ * Managed reset_control_get_shared(). For reset controllers returned from
+ * this function, reset_control_put() is called automatically on driver detach.
+ * See reset_control_get_shared() for more information.
+ */
+static inline struct reset_control *devm_reset_control_get_shared(
+					struct device *dev, const char *id)
+{
+	return __devm_reset_control_get(dev, id, 0, 1);
+}
+
+/**
+ * devm_reset_control_get_shared_by_index - resource managed
+ * reset_control_get_shared
+ * @dev: device to be reset by the controller
+ * @index: index of the reset controller
+ *
+ * Managed reset_control_get_shared(). For reset controllers returned from
+ * this function, reset_control_put() is called automatically on driver detach.
+ * See reset_control_get_shared() for more information.
+ */
+static inline struct reset_control *devm_reset_control_get_shared_by_index(
+					struct device *dev, int index)
+{
+	return __devm_reset_control_get(dev, NULL, index, 1);
 }
 
 #endif

commit 6c96f05c8bb8bc4177613ef3c23a56b455e75887
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Feb 23 18:46:24 2016 +0100

    reset: Make [of_]reset_control_get[_foo] functions wrappers
    
    With both the regular, _by_index and _optional variants we already have
    quite a few variants of [of_]reset_control_get[_foo], the upcoming
    addition of shared reset lines support makes this worse.
    
    This commit changes all the variants into wrappers around common core
    functions. For completeness sake this commit also adds a new
    devm_get_reset_control_by_index wrapper.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index c4c097de0ba9..1bb69a29d6db 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -1,8 +1,8 @@
 #ifndef _LINUX_RESET_H_
 #define _LINUX_RESET_H_
 
-struct device;
-struct device_node;
+#include <linux/device.h>
+
 struct reset_control;
 
 #ifdef CONFIG_RESET_CONTROLLER
@@ -12,9 +12,11 @@ int reset_control_assert(struct reset_control *rstc);
 int reset_control_deassert(struct reset_control *rstc);
 int reset_control_status(struct reset_control *rstc);
 
-struct reset_control *reset_control_get(struct device *dev, const char *id);
+struct reset_control *__of_reset_control_get(struct device_node *node,
+					     const char *id, int index);
 void reset_control_put(struct reset_control *rstc);
-struct reset_control *devm_reset_control_get(struct device *dev, const char *id);
+struct reset_control *__devm_reset_control_get(struct device *dev,
+					       const char *id, int index);
 
 int __must_check device_reset(struct device *dev);
 
@@ -23,24 +25,6 @@ static inline int device_reset_optional(struct device *dev)
 	return device_reset(dev);
 }
 
-static inline struct reset_control *reset_control_get_optional(
-					struct device *dev, const char *id)
-{
-	return reset_control_get(dev, id);
-}
-
-static inline struct reset_control *devm_reset_control_get_optional(
-					struct device *dev, const char *id)
-{
-	return devm_reset_control_get(dev, id);
-}
-
-struct reset_control *of_reset_control_get(struct device_node *node,
-					   const char *id);
-
-struct reset_control *of_reset_control_get_by_index(
-					struct device_node *node, int index);
-
 #else
 
 static inline int reset_control_reset(struct reset_control *rstc)
@@ -77,44 +61,114 @@ static inline int device_reset_optional(struct device *dev)
 	return -ENOTSUPP;
 }
 
-static inline struct reset_control *__must_check reset_control_get(
-					struct device *dev, const char *id)
+static inline struct reset_control *__of_reset_control_get(
+					struct device_node *node,
+					const char *id, int index)
 {
-	WARN_ON(1);
 	return ERR_PTR(-EINVAL);
 }
 
-static inline struct reset_control *__must_check devm_reset_control_get(
-					struct device *dev, const char *id)
+static inline struct reset_control *__devm_reset_control_get(
+					struct device *dev,
+					const char *id, int index)
 {
-	WARN_ON(1);
 	return ERR_PTR(-EINVAL);
 }
 
-static inline struct reset_control *reset_control_get_optional(
+#endif /* CONFIG_RESET_CONTROLLER */
+
+/**
+ * reset_control_get - Lookup and obtain a reference to a reset controller.
+ * @dev: device to be reset by the controller
+ * @id: reset line name
+ *
+ * Returns a struct reset_control or IS_ERR() condition containing errno.
+ *
+ * Use of id names is optional.
+ */
+static inline struct reset_control *__must_check reset_control_get(
 					struct device *dev, const char *id)
 {
-	return ERR_PTR(-ENOTSUPP);
+#ifndef CONFIG_RESET_CONTROLLER
+	WARN_ON(1);
+#endif
+	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0);
 }
 
-static inline struct reset_control *devm_reset_control_get_optional(
+static inline struct reset_control *reset_control_get_optional(
 					struct device *dev, const char *id)
 {
-	return ERR_PTR(-ENOTSUPP);
+	return __of_reset_control_get(dev ? dev->of_node : NULL, id, 0);
 }
 
+/**
+ * of_reset_control_get - Lookup and obtain a reference to a reset controller.
+ * @node: device to be reset by the controller
+ * @id: reset line name
+ *
+ * Returns a struct reset_control or IS_ERR() condition containing errno.
+ *
+ * Use of id names is optional.
+ */
 static inline struct reset_control *of_reset_control_get(
 				struct device_node *node, const char *id)
 {
-	return ERR_PTR(-ENOTSUPP);
+	return __of_reset_control_get(node, id, 0);
 }
 
+/**
+ * of_reset_control_get_by_index - Lookup and obtain a reference to a reset
+ * controller by index.
+ * @node: device to be reset by the controller
+ * @index: index of the reset controller
+ *
+ * This is to be used to perform a list of resets for a device or power domain
+ * in whatever order. Returns a struct reset_control or IS_ERR() condition
+ * containing errno.
+ */
 static inline struct reset_control *of_reset_control_get_by_index(
-				struct device_node *node, int index)
+					struct device_node *node, int index)
 {
-	return ERR_PTR(-ENOTSUPP);
+	return __of_reset_control_get(node, NULL, index);
 }
 
-#endif /* CONFIG_RESET_CONTROLLER */
+/**
+ * devm_reset_control_get - resource managed reset_control_get()
+ * @dev: device to be reset by the controller
+ * @id: reset line name
+ *
+ * Managed reset_control_get(). For reset controllers returned from this
+ * function, reset_control_put() is called automatically on driver detach.
+ * See reset_control_get() for more information.
+ */
+static inline struct reset_control *__must_check devm_reset_control_get(
+					struct device *dev, const char *id)
+{
+#ifndef CONFIG_RESET_CONTROLLER
+	WARN_ON(1);
+#endif
+	return __devm_reset_control_get(dev, id, 0);
+}
+
+static inline struct reset_control *devm_reset_control_get_optional(
+					struct device *dev, const char *id)
+{
+	return __devm_reset_control_get(dev, id, 0);
+}
+
+/**
+ * devm_reset_control_get_by_index - resource managed reset_control_get
+ * @dev: device to be reset by the controller
+ * @index: index of the reset controller
+ *
+ * Managed reset_control_get(). For reset controllers returned from this
+ * function, reset_control_put() is called automatically on driver detach.
+ * See reset_control_get() for more information.
+ */
+static inline struct reset_control *devm_reset_control_get_by_index(
+					struct device *dev, int index)
+{
+	return __devm_reset_control_get(dev, NULL, index);
+}
 
 #endif

commit 39b4da71ca334354f30941067f214ea2f2b92f3e
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Thu Oct 29 09:55:00 2015 +0100

    reset: use ENOTSUPP instead of ENOSYS
    
    ENOSYS is reserved to report invalid syscalls to userspace.
    Consistently return ENOTSUPP to indicate that the driver doesn't support
    the functionality or the reset framework is not enabled at all.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index 6db74ad3dec7..c4c097de0ba9 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -74,7 +74,7 @@ static inline void reset_control_put(struct reset_control *rstc)
 
 static inline int device_reset_optional(struct device *dev)
 {
-	return -ENOSYS;
+	return -ENOTSUPP;
 }
 
 static inline struct reset_control *__must_check reset_control_get(
@@ -94,19 +94,19 @@ static inline struct reset_control *__must_check devm_reset_control_get(
 static inline struct reset_control *reset_control_get_optional(
 					struct device *dev, const char *id)
 {
-	return ERR_PTR(-ENOSYS);
+	return ERR_PTR(-ENOTSUPP);
 }
 
 static inline struct reset_control *devm_reset_control_get_optional(
 					struct device *dev, const char *id)
 {
-	return ERR_PTR(-ENOSYS);
+	return ERR_PTR(-ENOTSUPP);
 }
 
 static inline struct reset_control *of_reset_control_get(
 				struct device_node *node, const char *id)
 {
-	return ERR_PTR(-ENOSYS);
+	return ERR_PTR(-ENOTSUPP);
 }
 
 static inline struct reset_control *of_reset_control_get_by_index(

commit c0a13aa6da5da19f9eedb562b226ec585aabdca9
Author: Vince Hsu <vinceh@nvidia.com>
Date:   Mon Jul 13 13:39:39 2015 +0100

    reset: add of_reset_control_get_by_index()
    
    Add of_reset_control_get_by_index() to allow the drivers to get reset
    device without knowing its name.
    
    Signed-off-by: Vince Hsu <vinceh@nvidia.com>
    [jonathanh@nvidia.com: Updated stub function to return -ENOTSUPP instead
     of -ENOSYS which should only be used for system calls.]
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index 7f65f9cff951..6db74ad3dec7 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -38,6 +38,9 @@ static inline struct reset_control *devm_reset_control_get_optional(
 struct reset_control *of_reset_control_get(struct device_node *node,
 					   const char *id);
 
+struct reset_control *of_reset_control_get_by_index(
+					struct device_node *node, int index);
+
 #else
 
 static inline int reset_control_reset(struct reset_control *rstc)
@@ -106,6 +109,12 @@ static inline struct reset_control *of_reset_control_get(
 	return ERR_PTR(-ENOSYS);
 }
 
+static inline struct reset_control *of_reset_control_get_by_index(
+				struct device_node *node, int index)
+{
+	return ERR_PTR(-ENOTSUPP);
+}
+
 #endif /* CONFIG_RESET_CONTROLLER */
 
 #endif

commit 5bcd0b7f3c56c616abffd89e11c841834dd1528c
Author: Axel Lin <axel.lin@ingics.com>
Date:   Tue Sep 1 07:56:38 2015 +0800

    reset: Add (devm_)reset_control_get stub functions
    
    So the drivers can be compiled with CONFIG_RESET_CONTROLLER disabled.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index da5602bd77d7..7f65f9cff951 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -74,6 +74,20 @@ static inline int device_reset_optional(struct device *dev)
 	return -ENOSYS;
 }
 
+static inline struct reset_control *__must_check reset_control_get(
+					struct device *dev, const char *id)
+{
+	WARN_ON(1);
+	return ERR_PTR(-EINVAL);
+}
+
+static inline struct reset_control *__must_check devm_reset_control_get(
+					struct device *dev, const char *id)
+{
+	WARN_ON(1);
+	return ERR_PTR(-EINVAL);
+}
+
 static inline struct reset_control *reset_control_get_optional(
 					struct device *dev, const char *id)
 {

commit 729de41baf63e2172b9d61de61bbd53f231095ca
Author: Dinh Nguyen <dinguyen@opensource.altera.com>
Date:   Fri Oct 10 10:21:14 2014 -0500

    reset: add reset_control_status helper function
    
    There are cases where a system will want to read a reset status bit before
    doing any other toggling. Add a reset_control_status helper function to the
    reset controller API.
    
    Signed-off-by: Dinh Nguyen <dinguyen@opensource.altera.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index 349f150ae12c..da5602bd77d7 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -10,6 +10,7 @@ struct reset_control;
 int reset_control_reset(struct reset_control *rstc);
 int reset_control_assert(struct reset_control *rstc);
 int reset_control_deassert(struct reset_control *rstc);
+int reset_control_status(struct reset_control *rstc);
 
 struct reset_control *reset_control_get(struct device *dev, const char *id);
 void reset_control_put(struct reset_control *rstc);
@@ -57,6 +58,12 @@ static inline int reset_control_deassert(struct reset_control *rstc)
 	return 0;
 }
 
+static inline int reset_control_status(struct reset_control *rstc)
+{
+	WARN_ON(1);
+	return 0;
+}
+
 static inline void reset_control_put(struct reset_control *rstc)
 {
 	WARN_ON(1);

commit e3ec0a8c6eea4f22d5468f01c065caca4dd1ecca
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Apr 13 14:09:15 2014 +0200

    reset: Add of_reset_control_get to reset.h
    
    of_reset_control_get is not declared static in drivers/reset/core.c, which
    is correct as we want to use it elsewhere too. But it does not have a
    protype declared anywhere under include/linux. Add a prototype / stub for it
    to linux/reset.h to fix this.
    
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index c0eda5023d74..349f150ae12c 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -2,6 +2,7 @@
 #define _LINUX_RESET_H_
 
 struct device;
+struct device_node;
 struct reset_control;
 
 #ifdef CONFIG_RESET_CONTROLLER
@@ -33,6 +34,9 @@ static inline struct reset_control *devm_reset_control_get_optional(
 	return devm_reset_control_get(dev, id);
 }
 
+struct reset_control *of_reset_control_get(struct device_node *node,
+					   const char *id);
+
 #else
 
 static inline int reset_control_reset(struct reset_control *rstc)
@@ -75,6 +79,12 @@ static inline struct reset_control *devm_reset_control_get_optional(
 	return ERR_PTR(-ENOSYS);
 }
 
+static inline struct reset_control *of_reset_control_get(
+				struct device_node *node, const char *id)
+{
+	return ERR_PTR(-ENOSYS);
+}
+
 #endif /* CONFIG_RESET_CONTROLLER */
 
 #endif

commit b424080a9e086e683ad5fdc624a7cf3c024e0c0f
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Fri Mar 7 15:18:47 2014 +0100

    reset: Add optional resets and stubs
    
    This patch adds device_reset_optional and (devm_)reset_control_get_optional
    variants that drivers can use to indicate they can function without control
    over the reset line. For those functions, stubs are added so the drivers can
    be compiled with CONFIG_RESET_CONTROLLER disabled.
    Also, device_reset is annotated with __must_check. Drivers ignoring the return
    value should use device_reset_optional instead.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Reviewed-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Reviewed-by: Marek Vasut <marex@denx.de>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index a398025d1138..c0eda5023d74 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -1,21 +1,80 @@
 #ifndef _LINUX_RESET_H_
 #define _LINUX_RESET_H_
 
-#include <linux/of.h>
-
 struct device;
 struct reset_control;
 
+#ifdef CONFIG_RESET_CONTROLLER
+
 int reset_control_reset(struct reset_control *rstc);
 int reset_control_assert(struct reset_control *rstc);
 int reset_control_deassert(struct reset_control *rstc);
 
-struct reset_control *of_reset_control_get(struct device_node *node,
-					   const char *id);
 struct reset_control *reset_control_get(struct device *dev, const char *id);
 void reset_control_put(struct reset_control *rstc);
 struct reset_control *devm_reset_control_get(struct device *dev, const char *id);
 
-int device_reset(struct device *dev);
+int __must_check device_reset(struct device *dev);
+
+static inline int device_reset_optional(struct device *dev)
+{
+	return device_reset(dev);
+}
+
+static inline struct reset_control *reset_control_get_optional(
+					struct device *dev, const char *id)
+{
+	return reset_control_get(dev, id);
+}
+
+static inline struct reset_control *devm_reset_control_get_optional(
+					struct device *dev, const char *id)
+{
+	return devm_reset_control_get(dev, id);
+}
+
+#else
+
+static inline int reset_control_reset(struct reset_control *rstc)
+{
+	WARN_ON(1);
+	return 0;
+}
+
+static inline int reset_control_assert(struct reset_control *rstc)
+{
+	WARN_ON(1);
+	return 0;
+}
+
+static inline int reset_control_deassert(struct reset_control *rstc)
+{
+	WARN_ON(1);
+	return 0;
+}
+
+static inline void reset_control_put(struct reset_control *rstc)
+{
+	WARN_ON(1);
+}
+
+static inline int device_reset_optional(struct device *dev)
+{
+	return -ENOSYS;
+}
+
+static inline struct reset_control *reset_control_get_optional(
+					struct device *dev, const char *id)
+{
+	return ERR_PTR(-ENOSYS);
+}
+
+static inline struct reset_control *devm_reset_control_get_optional(
+					struct device *dev, const char *id)
+{
+	return ERR_PTR(-ENOSYS);
+}
+
+#endif /* CONFIG_RESET_CONTROLLER */
 
 #endif

commit fc0a5921561c71be2c334a335c1680f7930434d7
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Fri Dec 20 22:41:07 2013 +0100

    reset: Add of_reset_control_get
    
    In some cases, you might need to deassert from reset an hardware block that
    doesn't associated to a struct device (CPUs, timers, etc.).
    
    Add a small helper to retrieve the reset controller from the device tree
    without the need to pass a struct device.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/linux/reset.h b/include/linux/reset.h
index 6082247feab1..a398025d1138 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -1,6 +1,8 @@
 #ifndef _LINUX_RESET_H_
 #define _LINUX_RESET_H_
 
+#include <linux/of.h>
+
 struct device;
 struct reset_control;
 
@@ -8,6 +10,8 @@ int reset_control_reset(struct reset_control *rstc);
 int reset_control_assert(struct reset_control *rstc);
 int reset_control_deassert(struct reset_control *rstc);
 
+struct reset_control *of_reset_control_get(struct device_node *node,
+					   const char *id);
 struct reset_control *reset_control_get(struct device *dev, const char *id);
 void reset_control_put(struct reset_control *rstc);
 struct reset_control *devm_reset_control_get(struct device *dev, const char *id);

commit 61fc41317666be400802ac793f47de816ef7bd57
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Mon Nov 19 17:23:13 2012 +0100

    reset: Add reset controller API
    
    This adds a simple API for devices to request being reset
    by separate reset controller hardware and implements the
    reset signal device tree binding.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Reviewed-by: Stephen Warren <swarren@nvidia.com>
    Reviewed-by: Shawn Guo <shawn.guo@linaro.org>
    Reviewed-by: Marek Vasut <marex@denx.de>
    Reviewed-by: Pavel Machek <pavel@ucw.cz>

diff --git a/include/linux/reset.h b/include/linux/reset.h
new file mode 100644
index 000000000000..6082247feab1
--- /dev/null
+++ b/include/linux/reset.h
@@ -0,0 +1,17 @@
+#ifndef _LINUX_RESET_H_
+#define _LINUX_RESET_H_
+
+struct device;
+struct reset_control;
+
+int reset_control_reset(struct reset_control *rstc);
+int reset_control_assert(struct reset_control *rstc);
+int reset_control_deassert(struct reset_control *rstc);
+
+struct reset_control *reset_control_get(struct device *dev, const char *id);
+void reset_control_put(struct reset_control *rstc);
+struct reset_control *devm_reset_control_get(struct device *dev, const char *id);
+
+int device_reset(struct device *dev);
+
+#endif
