commit 65f0c90b7d468545590992c61a19f9dc0aac61ef
Author: Elliot Berman <eberman@codeaurora.org>
Date:   Tue Jan 7 13:04:24 2020 -0800

    firmware: qcom_scm: Order functions, definitions by service/command
    
    Definitions throughout qcom_scm are loosely grouped and loosely ordered.
    Sort all the functions/definitions by service ID/command ID to improve
    sanity when needing to add new functionality to this driver.
    
    Acked-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Tested-by: Brian Masney <masneyb@onstation.org> # arm32
    Tested-by: Stephan Gerhold <stephan@gerhold.net>
    Signed-off-by: Elliot Berman <eberman@codeaurora.org>
    Link: https://lore.kernel.org/r/1578431066-19600-16-git-send-email-eberman@codeaurora.org
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index 98e775d7a3ec..3d6a24697761 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
-/* Copyright (c) 2010-2015, 2018, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2015, 2018-2019 The Linux Foundation. All rights reserved.
  * Copyright (C) 2015 Linaro Ltd.
  */
 #ifndef __QCOM_SCM_H
@@ -55,81 +55,94 @@ enum qcom_scm_sec_dev_id {
 #define QCOM_SCM_PERM_RWX (QCOM_SCM_PERM_RW | QCOM_SCM_PERM_EXEC)
 
 #if IS_ENABLED(CONFIG_QCOM_SCM)
+extern bool qcom_scm_is_available(void);
+
 extern int qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus);
 extern int qcom_scm_set_warm_boot_addr(void *entry, const cpumask_t *cpus);
-extern bool qcom_scm_is_available(void);
-extern bool qcom_scm_hdcp_available(void);
-extern int qcom_scm_hdcp_req(struct qcom_scm_hdcp_req *req, u32 req_cnt,
-			     u32 *resp);
-extern bool qcom_scm_ocmem_lock_available(void);
-extern int qcom_scm_ocmem_lock(enum qcom_scm_ocmem_client id, u32 offset,
-			       u32 size, u32 mode);
-extern int qcom_scm_ocmem_unlock(enum qcom_scm_ocmem_client id, u32 offset,
-				 u32 size);
-extern bool qcom_scm_pas_supported(u32 peripheral);
+extern void qcom_scm_cpu_power_down(u32 flags);
+extern int qcom_scm_set_remote_state(u32 state, u32 id);
+
 extern int qcom_scm_pas_init_image(u32 peripheral, const void *metadata,
 				   size_t size);
 extern int qcom_scm_pas_mem_setup(u32 peripheral, phys_addr_t addr,
 				  phys_addr_t size);
 extern int qcom_scm_pas_auth_and_reset(u32 peripheral);
 extern int qcom_scm_pas_shutdown(u32 peripheral);
-extern int qcom_scm_assign_mem(phys_addr_t mem_addr, size_t mem_sz,
-			       unsigned int *src,
-			       const struct qcom_scm_vmperm *newvm,
-			       unsigned int dest_cnt);
-extern void qcom_scm_cpu_power_down(u32 flags);
-extern int qcom_scm_set_remote_state(u32 state, u32 id);
+extern bool qcom_scm_pas_supported(u32 peripheral);
+
+extern int qcom_scm_io_readl(phys_addr_t addr, unsigned int *val);
+extern int qcom_scm_io_writel(phys_addr_t addr, unsigned int val);
+
 extern bool qcom_scm_restore_sec_cfg_available(void);
 extern int qcom_scm_restore_sec_cfg(u32 device_id, u32 spare);
 extern int qcom_scm_iommu_secure_ptbl_size(u32 spare, size_t *size);
 extern int qcom_scm_iommu_secure_ptbl_init(u64 addr, u32 size, u32 spare);
+extern int qcom_scm_assign_mem(phys_addr_t mem_addr, size_t mem_sz,
+			       unsigned int *src,
+			       const struct qcom_scm_vmperm *newvm,
+			       unsigned int dest_cnt);
+
+extern bool qcom_scm_ocmem_lock_available(void);
+extern int qcom_scm_ocmem_lock(enum qcom_scm_ocmem_client id, u32 offset,
+			       u32 size, u32 mode);
+extern int qcom_scm_ocmem_unlock(enum qcom_scm_ocmem_client id, u32 offset,
+				 u32 size);
+
+extern bool qcom_scm_hdcp_available(void);
+extern int qcom_scm_hdcp_req(struct qcom_scm_hdcp_req *req, u32 req_cnt,
+			     u32 *resp);
+
 extern int qcom_scm_qsmmu500_wait_safe_toggle(bool en);
-extern int qcom_scm_io_readl(phys_addr_t addr, unsigned int *val);
-extern int qcom_scm_io_writel(phys_addr_t addr, unsigned int val);
 #else
 
 #include <linux/errno.h>
 
-static inline
-int qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus)
-{
-	return -ENODEV;
-}
-static inline
-int qcom_scm_set_warm_boot_addr(void *entry, const cpumask_t *cpus)
-{
-	return -ENODEV;
-}
 static inline bool qcom_scm_is_available(void) { return false; }
-static inline bool qcom_scm_hdcp_available(void) { return false; }
-static inline int qcom_scm_hdcp_req(struct qcom_scm_hdcp_req *req, u32 req_cnt,
-				    u32 *resp) { return -ENODEV; }
-static inline bool qcom_scm_ocmem_lock_available(void) { return false; }
-static inline int qcom_scm_ocmem_lock(enum qcom_scm_ocmem_client id, u32 offset,
-				      u32 size, u32 mode) { return -ENODEV; }
-static inline int qcom_scm_ocmem_unlock(enum qcom_scm_ocmem_client id, u32 offset,
-					u32 size) { return -ENODEV; }
-static inline bool qcom_scm_pas_supported(u32 peripheral) { return false; }
+
+static inline int qcom_scm_set_cold_boot_addr(void *entry,
+		const cpumask_t *cpus) { return -ENODEV; }
+static inline int qcom_scm_set_warm_boot_addr(void *entry,
+		const cpumask_t *cpus) { return -ENODEV; }
+static inline void qcom_scm_cpu_power_down(u32 flags) {}
+static inline u32 qcom_scm_set_remote_state(u32 state,u32 id)
+		{ return -ENODEV; }
+
 static inline int qcom_scm_pas_init_image(u32 peripheral, const void *metadata,
-					  size_t size) { return -ENODEV; }
+		size_t size) { return -ENODEV; }
 static inline int qcom_scm_pas_mem_setup(u32 peripheral, phys_addr_t addr,
-					 phys_addr_t size) { return -ENODEV; }
-static inline int
-qcom_scm_pas_auth_and_reset(u32 peripheral) { return -ENODEV; }
+		phys_addr_t size) { return -ENODEV; }
+static inline int qcom_scm_pas_auth_and_reset(u32 peripheral)
+		{ return -ENODEV; }
 static inline int qcom_scm_pas_shutdown(u32 peripheral) { return -ENODEV; }
-static inline int qcom_scm_assign_mem(phys_addr_t mem_addr, size_t mem_sz,
-				      unsigned int *src,
-				      const struct qcom_scm_vmperm *newvm,
-				      unsigned int dest_cnt) { return -ENODEV; }
-static inline void qcom_scm_cpu_power_down(u32 flags) {}
-static inline u32
-qcom_scm_set_remote_state(u32 state,u32 id) { return -ENODEV; }
+static inline bool qcom_scm_pas_supported(u32 peripheral) { return false; }
+
+static inline int qcom_scm_io_readl(phys_addr_t addr, unsigned int *val)
+		{ return -ENODEV; }
+static inline int qcom_scm_io_writel(phys_addr_t addr, unsigned int val)
+		{ return -ENODEV; }
+
 static inline bool qcom_scm_restore_sec_cfg_available(void) { return false; }
-static inline int qcom_scm_restore_sec_cfg(u32 device_id, u32 spare) { return -ENODEV; }
-static inline int qcom_scm_iommu_secure_ptbl_size(u32 spare, size_t *size) { return -ENODEV; }
-static inline int qcom_scm_iommu_secure_ptbl_init(u64 addr, u32 size, u32 spare) { return -ENODEV; }
-static inline int qcom_scm_qsmmu500_wait_safe_toggle(bool en) { return -ENODEV; }
-static inline int qcom_scm_io_readl(phys_addr_t addr, unsigned int *val) { return -ENODEV; }
-static inline int qcom_scm_io_writel(phys_addr_t addr, unsigned int val) { return -ENODEV; }
+static inline int qcom_scm_restore_sec_cfg(u32 device_id, u32 spare)
+		{ return -ENODEV; }
+static inline int qcom_scm_iommu_secure_ptbl_size(u32 spare, size_t *size)
+		{ return -ENODEV; }
+static inline int qcom_scm_iommu_secure_ptbl_init(u64 addr, u32 size, u32 spare)
+		{ return -ENODEV; }
+static inline int qcom_scm_assign_mem(phys_addr_t mem_addr, size_t mem_sz,
+		unsigned int *src, const struct qcom_scm_vmperm *newvm,
+		unsigned int dest_cnt) { return -ENODEV; }
+
+static inline bool qcom_scm_ocmem_lock_available(void) { return false; }
+static inline int qcom_scm_ocmem_lock(enum qcom_scm_ocmem_client id, u32 offset,
+		u32 size, u32 mode) { return -ENODEV; }
+static inline int qcom_scm_ocmem_unlock(enum qcom_scm_ocmem_client id,
+		u32 offset, u32 size) { return -ENODEV; }
+
+static inline bool qcom_scm_hdcp_available(void) { return false; }
+static inline int qcom_scm_hdcp_req(struct qcom_scm_hdcp_req *req, u32 req_cnt,
+		u32 *resp) { return -ENODEV; }
+
+static inline int qcom_scm_qsmmu500_wait_safe_toggle(bool en)
+		{ return -ENODEV; }
 #endif
 #endif

commit 9a1108d2b001cda1af17160c78afedfff92e2202
Author: Elliot Berman <eberman@codeaurora.org>
Date:   Tue Jan 7 13:04:12 2020 -0800

    firmware: qcom_scm: Remove unused qcom_scm_get_version
    
    Remove unused qcom_scm_get_version.
    
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Reviewed-by: Vinod Koul <vkoul@kernel.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Tested-by: Brian Masney <masneyb@onstation.org> # arm32
    Tested-by: Stephan Gerhold <stephan@gerhold.net>
    Signed-off-by: Elliot Berman <eberman@codeaurora.org>
    Link: https://lore.kernel.org/r/1578431066-19600-4-git-send-email-eberman@codeaurora.org
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index 2c1d20312ce0..98e775d7a3ec 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -78,7 +78,6 @@ extern int qcom_scm_assign_mem(phys_addr_t mem_addr, size_t mem_sz,
 			       const struct qcom_scm_vmperm *newvm,
 			       unsigned int dest_cnt);
 extern void qcom_scm_cpu_power_down(u32 flags);
-extern u32 qcom_scm_get_version(void);
 extern int qcom_scm_set_remote_state(u32 state, u32 id);
 extern bool qcom_scm_restore_sec_cfg_available(void);
 extern int qcom_scm_restore_sec_cfg(u32 device_id, u32 spare);
@@ -123,7 +122,6 @@ static inline int qcom_scm_assign_mem(phys_addr_t mem_addr, size_t mem_sz,
 				      const struct qcom_scm_vmperm *newvm,
 				      unsigned int dest_cnt) { return -ENODEV; }
 static inline void qcom_scm_cpu_power_down(u32 flags) {}
-static inline u32 qcom_scm_get_version(void) { return 0; }
 static inline u32
 qcom_scm_set_remote_state(u32 state,u32 id) { return -ENODEV; }
 static inline bool qcom_scm_restore_sec_cfg_available(void) { return false; }

commit a6a0bc7ca993e30e832314f5a8bd62a802f35ce9
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Fri Jan 3 23:08:25 2020 +0100

    firmware: scm: Add stubs for OCMEM and restore_sec_cfg_available
    
    Add few more stubs (for OCMEM-related functions and
    qcom_scm_restore_sec_cfg_available()) in case of !CONFIG_QCOM_SCM.
    These are actually not necessary for builds but provide them for
    completeness.
    
    Reviewed-by: Brian Masney <masneyb@onstation.org>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Link: https://lore.kernel.org/r/20200103220825.28710-1-krzk@kernel.org
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index d05ddac9a57e..2c1d20312ce0 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -105,6 +105,11 @@ static inline bool qcom_scm_is_available(void) { return false; }
 static inline bool qcom_scm_hdcp_available(void) { return false; }
 static inline int qcom_scm_hdcp_req(struct qcom_scm_hdcp_req *req, u32 req_cnt,
 				    u32 *resp) { return -ENODEV; }
+static inline bool qcom_scm_ocmem_lock_available(void) { return false; }
+static inline int qcom_scm_ocmem_lock(enum qcom_scm_ocmem_client id, u32 offset,
+				      u32 size, u32 mode) { return -ENODEV; }
+static inline int qcom_scm_ocmem_unlock(enum qcom_scm_ocmem_client id, u32 offset,
+					u32 size) { return -ENODEV; }
 static inline bool qcom_scm_pas_supported(u32 peripheral) { return false; }
 static inline int qcom_scm_pas_init_image(u32 peripheral, const void *metadata,
 					  size_t size) { return -ENODEV; }
@@ -121,6 +126,7 @@ static inline void qcom_scm_cpu_power_down(u32 flags) {}
 static inline u32 qcom_scm_get_version(void) { return 0; }
 static inline u32
 qcom_scm_set_remote_state(u32 state,u32 id) { return -ENODEV; }
+static inline bool qcom_scm_restore_sec_cfg_available(void) { return false; }
 static inline int qcom_scm_restore_sec_cfg(u32 device_id, u32 spare) { return -ENODEV; }
 static inline int qcom_scm_iommu_secure_ptbl_size(u32 spare, size_t *size) { return -ENODEV; }
 static inline int qcom_scm_iommu_secure_ptbl_init(u64 addr, u32 size, u32 spare) { return -ENODEV; }

commit 7ada90eb9c7ae4a8eb066f8e9b4d80122f0363db
Merge: 9feb1af97e73 9c1867d730a6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 6 10:28:09 2019 -0800

    Merge tag 'drm-next-2019-12-06' of git://anongit.freedesktop.org/drm/drm
    
    Pull more drm updates from Dave Airlie:
     "Rob pointed out I missed his pull request for msm-next, it's been in
      next for a while outside of my tree so shouldn't cause any unexpected
      issues, it has some OCMEM support in drivers/soc that is acked by
      other maintainers as it's outside my tree.
    
      Otherwise it's a usual fixes pull, i915, amdgpu, the main ones, with
      some tegra, omap, mgag200 and one core fix.
    
      Summary:
    
      msm-next:
       - OCMEM support for a3xx and a4xx GPUs.
       - a510 support + display support
    
      core:
       - mst payload deletion fix
    
      i915:
       - uapi alignment fix
       - fix for power usage regression due to security fixes
       - change default preemption timeout to 640ms from 100ms
       - EHL voltage level display fixes
       - TGL DGL PHY fix
       - gvt - MI_ATOMIC cmd parser fix, CFL non-priv warning
       - CI spotted deadlock fix
       - EHL port D programming fix
    
      amdgpu:
       - VRAM lost fixes on BACO for CI/VI
       - navi14 DC fixes
       - misc SR-IOV, gfx10 fixes
       - XGMI fixes for arcturus
       - SRIOV fixes
    
      amdkfd:
       - KFD on ppc64le enabled
       - page table optimisations
    
      radeon:
       - fix for r1xx/2xx register checker.
    
      tegra:
       - displayport regression fixes
       - DMA API regression fixes
    
      mgag200:
       - fix devices that can't scanout except at 0 addr
    
      omap:
       - fix dma_addr refcounting"
    
    * tag 'drm-next-2019-12-06' of git://anongit.freedesktop.org/drm/drm: (100 commits)
      drm/dp_mst: Correct the bug in drm_dp_update_payload_part1()
      drm/omap: fix dma_addr refcounting
      drm/tegra: Run hub cleanup on ->remove()
      drm/tegra: sor: Make the +5V HDMI supply optional
      drm/tegra: Silence expected errors on IOMMU attach
      drm/tegra: vic: Export module device table
      drm/tegra: sor: Implement system suspend/resume
      drm/tegra: Use proper IOVA address for cursor image
      drm/tegra: gem: Remove premature import restrictions
      drm/tegra: gem: Properly pin imported buffers
      drm/tegra: hub: Remove bogus connection mutex check
      ia64: agp: Replace empty define with do while
      agp: Add bridge parameter documentation
      agp: remove unused variable num_segments
      agp: move AGPGART_MINOR to include/linux/miscdevice.h
      agp: remove unused variable size in agp_generic_create_gatt_table
      drm/dp_mst: Fix build on systems with STACKTRACE_SUPPORT=n
      drm/radeon: fix r1xx/r2xx register checker for POT textures
      drm/amdgpu: fix GFX10 missing CSIB set(v3)
      drm/amdgpu: should stop GFX ring in hw_fini
      ...

commit 5eb0e0e4f90addc6b79ebf1cb4b06b56b09f09de
Author: Vivek Gautam <vivek.gautam@codeaurora.org>
Date:   Fri Sep 20 13:34:28 2019 +0530

    firmware/qcom_scm: Add scm call to handle smmu errata
    
    Qcom's smmu-500 needs to toggle wait-for-safe sequence to
    handle TLB invalidation sync's.
    Few firmwares allow doing that through SCM interface.
    Add API to toggle wait for safe from firmware through a
    SCM call.
    
    Signed-off-by: Vivek Gautam <vivek.gautam@codeaurora.org>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Acked-by: Andy Gross <agross@kernel.org>
    Signed-off-by: Sai Prakash Ranjan <saiprakash.ranjan@codeaurora.org>
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index 2d5eff506e13..ffd72b3b14ee 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -58,6 +58,7 @@ extern int qcom_scm_set_remote_state(u32 state, u32 id);
 extern int qcom_scm_restore_sec_cfg(u32 device_id, u32 spare);
 extern int qcom_scm_iommu_secure_ptbl_size(u32 spare, size_t *size);
 extern int qcom_scm_iommu_secure_ptbl_init(u64 addr, u32 size, u32 spare);
+extern int qcom_scm_qsmmu500_wait_safe_toggle(bool en);
 extern int qcom_scm_io_readl(phys_addr_t addr, unsigned int *val);
 extern int qcom_scm_io_writel(phys_addr_t addr, unsigned int val);
 #else
@@ -97,6 +98,7 @@ qcom_scm_set_remote_state(u32 state,u32 id) { return -ENODEV; }
 static inline int qcom_scm_restore_sec_cfg(u32 device_id, u32 spare) { return -ENODEV; }
 static inline int qcom_scm_iommu_secure_ptbl_size(u32 spare, size_t *size) { return -ENODEV; }
 static inline int qcom_scm_iommu_secure_ptbl_init(u64 addr, u32 size, u32 spare) { return -ENODEV; }
+static inline int qcom_scm_qsmmu500_wait_safe_toggle(bool en) { return -ENODEV; }
 static inline int qcom_scm_io_readl(phys_addr_t addr, unsigned int *val) { return -ENODEV; }
 static inline int qcom_scm_io_writel(phys_addr_t addr, unsigned int val) { return -ENODEV; }
 #endif

commit 0434a4061471a9afc2b2061add496e58ba4bb92d
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Aug 23 05:16:34 2019 -0700

    firmware: qcom: scm: add support to restore secure config to qcm_scm-32
    
    Add support to restore the secure configuration for qcm_scm-32.c. This
    is needed by the On Chip MEMory (OCMEM) that is present on some
    Snapdragon devices.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    [masneyb@onstation.org: ported to latest kernel; set ctx_bank_num to
     spare parameter.]
    Signed-off-by: Brian Masney <masneyb@onstation.org>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Tested-by: Gabriel Francisco <frc.gabrielgmail.com>
    Signed-off-by: Rob Clark <robdclark@chromium.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index b49b734d662c..04382e1798e4 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -34,6 +34,16 @@ enum qcom_scm_ocmem_client {
 	QCOM_SCM_OCMEM_DEBUG_ID,
 };
 
+enum qcom_scm_sec_dev_id {
+	QCOM_SCM_MDSS_DEV_ID    = 1,
+	QCOM_SCM_OCMEM_DEV_ID   = 5,
+	QCOM_SCM_PCIE0_DEV_ID   = 11,
+	QCOM_SCM_PCIE1_DEV_ID   = 12,
+	QCOM_SCM_GFX_DEV_ID     = 18,
+	QCOM_SCM_UFS_DEV_ID     = 19,
+	QCOM_SCM_ICE_DEV_ID     = 20,
+};
+
 #define QCOM_SCM_VMID_HLOS       0x3
 #define QCOM_SCM_VMID_MSS_MSA    0xF
 #define QCOM_SCM_VMID_WLAN       0x18
@@ -70,6 +80,7 @@ extern int qcom_scm_assign_mem(phys_addr_t mem_addr, size_t mem_sz,
 extern void qcom_scm_cpu_power_down(u32 flags);
 extern u32 qcom_scm_get_version(void);
 extern int qcom_scm_set_remote_state(u32 state, u32 id);
+extern bool qcom_scm_restore_sec_cfg_available(void);
 extern int qcom_scm_restore_sec_cfg(u32 device_id, u32 spare);
 extern int qcom_scm_iommu_secure_ptbl_size(u32 spare, size_t *size);
 extern int qcom_scm_iommu_secure_ptbl_init(u64 addr, u32 size, u32 spare);

commit b0a1614fb1f58520938968ebe1f4f11bcf34839e
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Aug 23 05:16:33 2019 -0700

    firmware: qcom: scm: add OCMEM lock/unlock interface
    
    Add support for the OCMEM lock/unlock interface that is needed by the
    On Chip MEMory (OCMEM) that is present on some Snapdragon devices.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    [masneyb@onstation.org: ported to latest kernel; minor reformatting.]
    Signed-off-by: Brian Masney <masneyb@onstation.org>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Tested-by: Gabriel Francisco <frc.gabrielgmail.com>
    Signed-off-by: Rob Clark <robdclark@chromium.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index 2d5eff506e13..b49b734d662c 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -24,6 +24,16 @@ struct qcom_scm_vmperm {
 	int perm;
 };
 
+enum qcom_scm_ocmem_client {
+	QCOM_SCM_OCMEM_UNUSED_ID = 0x0,
+	QCOM_SCM_OCMEM_GRAPHICS_ID,
+	QCOM_SCM_OCMEM_VIDEO_ID,
+	QCOM_SCM_OCMEM_LP_AUDIO_ID,
+	QCOM_SCM_OCMEM_SENSORS_ID,
+	QCOM_SCM_OCMEM_OTHER_OS_ID,
+	QCOM_SCM_OCMEM_DEBUG_ID,
+};
+
 #define QCOM_SCM_VMID_HLOS       0x3
 #define QCOM_SCM_VMID_MSS_MSA    0xF
 #define QCOM_SCM_VMID_WLAN       0x18
@@ -41,6 +51,11 @@ extern bool qcom_scm_is_available(void);
 extern bool qcom_scm_hdcp_available(void);
 extern int qcom_scm_hdcp_req(struct qcom_scm_hdcp_req *req, u32 req_cnt,
 			     u32 *resp);
+extern bool qcom_scm_ocmem_lock_available(void);
+extern int qcom_scm_ocmem_lock(enum qcom_scm_ocmem_client id, u32 offset,
+			       u32 size, u32 mode);
+extern int qcom_scm_ocmem_unlock(enum qcom_scm_ocmem_client id, u32 offset,
+				 u32 size);
 extern bool qcom_scm_pas_supported(u32 peripheral);
 extern int qcom_scm_pas_init_image(u32 peripheral, const void *metadata,
 				   size_t size);

commit af311ff9a69189a03548efd5a47d4bb44644fd45
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Fri May 17 14:09:22 2019 -0700

    firmware: qcom_scm: Cleanup code in qcom_scm_assign_mem()
    
    There are some questionable coding styles in this function. It looks
    quite odd to deref a pointer with array indexing that only uses the
    first element. Also, destroying an input/output variable halfway through
    the function and then overwriting it on success is not clear. It's
    better to use a local variable and the kernel macros to step through
    each bit set in a bitmask and clearly show where outputs are set.
    
    Cc: Ian Jackson <ian.jackson@citrix.com>
    Cc: Julien Grall <julien.grall@arm.com>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: Avaneesh Kumar Dwivedi <akdwived@codeaurora.org>
    Tested-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    [bjorn: Changed for_each_set_bit() size to BITS_PER_LONG]
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index 3f12cc77fb58..2d5eff506e13 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -49,8 +49,9 @@ extern int qcom_scm_pas_mem_setup(u32 peripheral, phys_addr_t addr,
 extern int qcom_scm_pas_auth_and_reset(u32 peripheral);
 extern int qcom_scm_pas_shutdown(u32 peripheral);
 extern int qcom_scm_assign_mem(phys_addr_t mem_addr, size_t mem_sz,
-			       unsigned int *src, struct qcom_scm_vmperm *newvm,
-			       int dest_cnt);
+			       unsigned int *src,
+			       const struct qcom_scm_vmperm *newvm,
+			       unsigned int dest_cnt);
 extern void qcom_scm_cpu_power_down(u32 flags);
 extern u32 qcom_scm_get_version(void);
 extern int qcom_scm_set_remote_state(u32 state, u32 id);
@@ -87,8 +88,8 @@ qcom_scm_pas_auth_and_reset(u32 peripheral) { return -ENODEV; }
 static inline int qcom_scm_pas_shutdown(u32 peripheral) { return -ENODEV; }
 static inline int qcom_scm_assign_mem(phys_addr_t mem_addr, size_t mem_sz,
 				      unsigned int *src,
-				      struct qcom_scm_vmperm *newvm,
-				      int dest_cnt) { return -ENODEV; }
+				      const struct qcom_scm_vmperm *newvm,
+				      unsigned int dest_cnt) { return -ENODEV; }
 static inline void qcom_scm_cpu_power_down(u32 flags) {}
 static inline u32 qcom_scm_get_version(void) { return 0; }
 static inline u32

commit 97fb5e8d9b57f10f294303c9a5d1bd033eded6bf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:58 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 284
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 and
      only version 2 as published by the free software foundation this
      program is distributed in the hope that it will be useful but
      without any warranty without even the implied warranty of
      merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 294 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.825281744@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index d0aecc04c54b..3f12cc77fb58 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /* Copyright (c) 2010-2015, 2018, The Linux Foundation. All rights reserved.
  * Copyright (C) 2015 Linaro Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 #ifndef __QCOM_SCM_H
 #define __QCOM_SCM_H

commit 2076607a20bd4dfba699185616cbbbce06d3fa59
Author: Fabio Estevam <festevam@gmail.com>
Date:   Wed Dec 26 10:06:19 2018 -0200

    qcom-scm: Include <linux/err.h> header
    
    Since commit e6f6d63ed14c ("drm/msm: add headless gpu device for imx5")
    the DRM_MSM symbol can be selected by SOC_IMX5 causing the following
    error when building imx_v6_v7_defconfig:
    
    In file included from ../drivers/gpu/drm/msm/adreno/a5xx_gpu.c:17:0:
    ../include/linux/qcom_scm.h: In function 'qcom_scm_set_cold_boot_addr':
    ../include/linux/qcom_scm.h:73:10: error: 'ENODEV' undeclared (first use in this function)
      return -ENODEV;
    
    Include the <linux/err.h> header file to fix this problem.
    
    Reported-by: kernelci.org bot <bot@kernelci.org>
    Fixes: e6f6d63ed14c ("drm/msm: add headless gpu device for imx5")
    Signed-off-by: Fabio Estevam <festevam@gmail.com>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Andy Gross <andy.gross@linaro.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index 1637385bcc17..d0aecc04c54b 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -13,6 +13,7 @@
 #ifndef __QCOM_SCM_H
 #define __QCOM_SCM_H
 
+#include <linux/err.h>
 #include <linux/types.h>
 #include <linux/cpumask.h>
 

commit 16ad9501b1f2edebe24f8cf3c09da0695871986b
Author: Jonathan Marek <jonathan@marek.ca>
Date:   Wed Nov 21 21:32:25 2018 -0500

    firmware: qcom: scm: fix compilation error when disabled
    
    This fixes the case when CONFIG_QCOM_SCM is not enabled, and linux/errno.h
    has not been included previously.
    
    Signed-off-by: Jonathan Marek <jonathan@marek.ca>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Andy Gross <andy.gross@linaro.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index 06996ad4f2bc..1637385bcc17 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -67,6 +67,9 @@ extern int qcom_scm_iommu_secure_ptbl_init(u64 addr, u32 size, u32 spare);
 extern int qcom_scm_io_readl(phys_addr_t addr, unsigned int *val);
 extern int qcom_scm_io_writel(phys_addr_t addr, unsigned int val);
 #else
+
+#include <linux/errno.h>
+
 static inline
 int qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus)
 {

commit cc53aabcc283c36274d3f3ce9adc4b40c21d4838
Author: Govind Singh <govinds@codeaurora.org>
Date:   Thu Oct 11 13:16:01 2018 +0300

    firmware: qcom: scm: Add WLAN VMID for Qualcomm SCM interface
    
    Add WLAN related VMID's to support wlan driver to set up
    the remote's permissions call via TrustZone.
    
    Signed-off-by: Govind Singh <govinds@codeaurora.org>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Acked-by: Niklas Cassel <niklas.cassel@linaro.org>
    Reviewed-by: Brian Norris <briannorris@chromium.org>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index 5d65521260b3..06996ad4f2bc 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2015, 2018, The Linux Foundation. All rights reserved.
  * Copyright (C) 2015 Linaro Ltd.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -33,6 +33,8 @@ struct qcom_scm_vmperm {
 
 #define QCOM_SCM_VMID_HLOS       0x3
 #define QCOM_SCM_VMID_MSS_MSA    0xF
+#define QCOM_SCM_VMID_WLAN       0x18
+#define QCOM_SCM_VMID_WLAN_CE    0x19
 #define QCOM_SCM_PERM_READ       0x4
 #define QCOM_SCM_PERM_WRITE      0x2
 #define QCOM_SCM_PERM_EXEC       0x1

commit a0b1561f846191a1967e8f5a26d8ef59c1b9162a
Author: Niklas Cassel <niklas.cassel@linaro.org>
Date:   Tue Jun 12 15:23:13 2018 +0200

    firmware: qcom: scm: add a dummy qcom_scm_assign_mem()
    
    Add a dummy qcom_scm_assign_mem() to enable building drivers when
    CONFIG_COMPILE_TEST=y && CONFIG_QCOM_SCM=n.
    
    All other qcom_scm_* functions already have a dummy version.
    
    Signed-off-by: Niklas Cassel <niklas.cassel@linaro.org>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Andy Gross <andy.gross@linaro.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index b401b962afff..5d65521260b3 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -87,6 +87,10 @@ static inline int qcom_scm_pas_mem_setup(u32 peripheral, phys_addr_t addr,
 static inline int
 qcom_scm_pas_auth_and_reset(u32 peripheral) { return -ENODEV; }
 static inline int qcom_scm_pas_shutdown(u32 peripheral) { return -ENODEV; }
+static inline int qcom_scm_assign_mem(phys_addr_t mem_addr, size_t mem_sz,
+				      unsigned int *src,
+				      struct qcom_scm_vmperm *newvm,
+				      int dest_cnt) { return -ENODEV; }
 static inline void qcom_scm_cpu_power_down(u32 flags) {}
 static inline u32 qcom_scm_get_version(void) { return 0; }
 static inline u32

commit 29ff62f7db108854cd98f5cdc92d15ccb37e81d1
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Mon Dec 4 10:18:46 2017 -0700

    firmware: qcom_scm: Add dependent headers to qcom_scm.h
    
    qcom_scm.h makes heavy use of <linux/types.h> and <linux/cpumask.h>.
    Add the dependent header files so that users of SCM don't need to
    include header files they don't otherwise use.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Acked-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Andy Gross <andy.gross@linaro.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index 1fd27d68926b..b401b962afff 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -13,6 +13,9 @@
 #ifndef __QCOM_SCM_H
 #define __QCOM_SCM_H
 
+#include <linux/types.h>
+#include <linux/cpumask.h>
+
 #define QCOM_SCM_VERSION(major, minor)	(((major) << 16) | ((minor) & 0xFF))
 #define QCOM_SCM_CPU_PWR_DOWN_L2_ON	0x0
 #define QCOM_SCM_CPU_PWR_DOWN_L2_OFF	0x1

commit 4f88bd23baab4335e96d38828ef38124ec717eb9
Merge: bedf57198699 1a5d5c592e90
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 17 20:14:10 2017 -0800

    Merge tag 'rproc-v4.15' of git://github.com/andersson/remoteproc
    
    Pull remoteproc updates from Bjorn Andersson:
     "This adds an interface for configuring Qualcomm's "secure SMMU" and
      adds support for booting the modem Hexagon on MSM8996.
    
      Two new debugfs entries are added in the remoteproc core to introspect
      the list of memory carveouts and the loaded resource table"
    
    * tag 'rproc-v4.15' of git://github.com/andersson/remoteproc:
      remoteproc: qcom: Fix error handling paths in order to avoid memory leaks
      remoteproc: qcom: Drop pr_err in q6v5_xfer_mem_ownership()
      remoteproc: debug: add carveouts list dump feature
      remoteproc: debug: add resource table dump feature
      remoteproc: qcom: Add support for mss remoteproc on msm8996
      remoteproc: qcom: Make secure world call for mem ownership switch
      remoteproc: qcom: refactor mss fw image loading sequence
      firmware: scm: Add new SCM call API for switching memory ownership

commit d82bd359972a7fe71a778396cf287bc9f9f3b981
Author: Avaneesh Kumar Dwivedi <akdwived@codeaurora.org>
Date:   Tue Oct 24 21:22:24 2017 +0530

    firmware: scm: Add new SCM call API for switching memory ownership
    
    Two different processors on a SOC need to switch memory ownership
    during load/unload. To enable this, second level memory map table
    need to be updated, which is done by secure layer.
    This patch adds the interface for making secure monitor call for
    memory ownership switching request.
    
    Acked-by: Andy Gross <andy.gross@linaro.org>
    Signed-off-by: Avaneesh Kumar Dwivedi <akdwived@codeaurora.org>
    [bjorn: Minor style and kerneldoc updates]
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index e5380471c2cd..6f8da9e182f9 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -23,6 +23,19 @@ struct qcom_scm_hdcp_req {
 	u32 val;
 };
 
+struct qcom_scm_vmperm {
+	int vmid;
+	int perm;
+};
+
+#define QCOM_SCM_VMID_HLOS       0x3
+#define QCOM_SCM_VMID_MSS_MSA    0xF
+#define QCOM_SCM_PERM_READ       0x4
+#define QCOM_SCM_PERM_WRITE      0x2
+#define QCOM_SCM_PERM_EXEC       0x1
+#define QCOM_SCM_PERM_RW (QCOM_SCM_PERM_READ | QCOM_SCM_PERM_WRITE)
+#define QCOM_SCM_PERM_RWX (QCOM_SCM_PERM_RW | QCOM_SCM_PERM_EXEC)
+
 #if IS_ENABLED(CONFIG_QCOM_SCM)
 extern int qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus);
 extern int qcom_scm_set_warm_boot_addr(void *entry, const cpumask_t *cpus);
@@ -37,6 +50,9 @@ extern int qcom_scm_pas_mem_setup(u32 peripheral, phys_addr_t addr,
 				  phys_addr_t size);
 extern int qcom_scm_pas_auth_and_reset(u32 peripheral);
 extern int qcom_scm_pas_shutdown(u32 peripheral);
+extern int qcom_scm_assign_mem(phys_addr_t mem_addr, size_t mem_sz,
+			       unsigned int *src, struct qcom_scm_vmperm *newvm,
+			       int dest_cnt);
 extern void qcom_scm_cpu_power_down(u32 flags);
 extern u32 qcom_scm_get_version(void);
 extern int qcom_scm_set_remote_state(u32 state, u32 id);

commit 4e659dbe2d02a56ca0df25c77e099760252a329c
Author: Bjorn Andersson <bjorn.andersson@linaro.org>
Date:   Mon Aug 14 15:46:17 2017 -0700

    firmware: qcom: scm: Expose secure IO service
    
    The secure IO service provides operations for reading and writing secure
    memory from non-secure mode, expose this API through SCM.
    
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Andy Gross <andy.gross@linaro.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index e5380471c2cd..e8357f570695 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -43,6 +43,8 @@ extern int qcom_scm_set_remote_state(u32 state, u32 id);
 extern int qcom_scm_restore_sec_cfg(u32 device_id, u32 spare);
 extern int qcom_scm_iommu_secure_ptbl_size(u32 spare, size_t *size);
 extern int qcom_scm_iommu_secure_ptbl_init(u64 addr, u32 size, u32 spare);
+extern int qcom_scm_io_readl(phys_addr_t addr, unsigned int *val);
+extern int qcom_scm_io_writel(phys_addr_t addr, unsigned int val);
 #else
 static inline
 int qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus)
@@ -73,5 +75,7 @@ qcom_scm_set_remote_state(u32 state,u32 id) { return -ENODEV; }
 static inline int qcom_scm_restore_sec_cfg(u32 device_id, u32 spare) { return -ENODEV; }
 static inline int qcom_scm_iommu_secure_ptbl_size(u32 spare, size_t *size) { return -ENODEV; }
 static inline int qcom_scm_iommu_secure_ptbl_init(u64 addr, u32 size, u32 spare) { return -ENODEV; }
+static inline int qcom_scm_io_readl(phys_addr_t addr, unsigned int *val) { return -ENODEV; }
+static inline int qcom_scm_io_writel(phys_addr_t addr, unsigned int val) { return -ENODEV; }
 #endif
 #endif

commit b182cc4d597a6e73ff04ee1b7fb4f1a28f56ae3d
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Tue Mar 14 11:18:04 2017 -0400

    firmware: qcom_scm: add two scm calls for iommu secure page table
    
    Those two new SCM calls are needed from qcom-iommu driver in order
    to initialize secure iommu page table.
    
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Andy Gross <andy.gross@linaro.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index 22017f5d17e0..e5380471c2cd 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -41,6 +41,8 @@ extern void qcom_scm_cpu_power_down(u32 flags);
 extern u32 qcom_scm_get_version(void);
 extern int qcom_scm_set_remote_state(u32 state, u32 id);
 extern int qcom_scm_restore_sec_cfg(u32 device_id, u32 spare);
+extern int qcom_scm_iommu_secure_ptbl_size(u32 spare, size_t *size);
+extern int qcom_scm_iommu_secure_ptbl_init(u64 addr, u32 size, u32 spare);
 #else
 static inline
 int qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus)
@@ -69,5 +71,7 @@ static inline u32 qcom_scm_get_version(void) { return 0; }
 static inline u32
 qcom_scm_set_remote_state(u32 state,u32 id) { return -ENODEV; }
 static inline int qcom_scm_restore_sec_cfg(u32 device_id, u32 spare) { return -ENODEV; }
+static inline int qcom_scm_iommu_secure_ptbl_size(u32 spare, size_t *size) { return -ENODEV; }
+static inline int qcom_scm_iommu_secure_ptbl_init(u64 addr, u32 size, u32 spare) { return -ENODEV; }
 #endif
 #endif

commit a2c680c6ce386e9ca6cdf362e8b01789126c9bf7
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Mar 14 11:18:03 2017 -0400

    firmware/qcom: add qcom_scm_restore_sec_cfg()
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Andy Gross <andy.gross@linaro.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index d32f6f1a5225..22017f5d17e0 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -40,6 +40,7 @@ extern int qcom_scm_pas_shutdown(u32 peripheral);
 extern void qcom_scm_cpu_power_down(u32 flags);
 extern u32 qcom_scm_get_version(void);
 extern int qcom_scm_set_remote_state(u32 state, u32 id);
+extern int qcom_scm_restore_sec_cfg(u32 device_id, u32 spare);
 #else
 static inline
 int qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus)
@@ -67,5 +68,6 @@ static inline void qcom_scm_cpu_power_down(u32 flags) {}
 static inline u32 qcom_scm_get_version(void) { return 0; }
 static inline u32
 qcom_scm_set_remote_state(u32 state,u32 id) { return -ENODEV; }
+static inline int qcom_scm_restore_sec_cfg(u32 device_id, u32 spare) { return -ENODEV; }
 #endif
 #endif

commit a811b420b6c13759540070c0e9541b7cd8569168
Author: Andy Gross <andy.gross@linaro.org>
Date:   Mon Jan 16 23:24:15 2017 -0600

    firmware: qcom_scm: Add set remote state API
    
    This patch adds a set remote state SCM API.  This will be used by the
    Venus and GPU subsystems to set state on the remote processors.
    
    This work was based on two patch sets by Jordan Crouse and Stanimir
    Varbanov.
    
    Signed-off-by: Andy Gross <andy.gross@linaro.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index 7e004fb57fc4..d32f6f1a5225 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -39,6 +39,7 @@ extern int qcom_scm_pas_auth_and_reset(u32 peripheral);
 extern int qcom_scm_pas_shutdown(u32 peripheral);
 extern void qcom_scm_cpu_power_down(u32 flags);
 extern u32 qcom_scm_get_version(void);
+extern int qcom_scm_set_remote_state(u32 state, u32 id);
 #else
 static inline
 int qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus)
@@ -64,6 +65,7 @@ qcom_scm_pas_auth_and_reset(u32 peripheral) { return -ENODEV; }
 static inline int qcom_scm_pas_shutdown(u32 peripheral) { return -ENODEV; }
 static inline void qcom_scm_cpu_power_down(u32 flags) {}
 static inline u32 qcom_scm_get_version(void) { return 0; }
+static inline u32
+qcom_scm_set_remote_state(u32 state,u32 id) { return -ENODEV; }
 #endif
-
 #endif

commit e12799125074c67cd30bc3d7a5ff5e2f29ea1411
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Tue Nov 22 19:03:09 2016 +0200

    firmware: qcom: scm: Add empty functions to help compile testing
    
    This will help to compile testing drivers which depends on scm
    functions with COMPILE_TEST Kconfig option.
    
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Andy Gross <andy.gross@linaro.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index cc32ab852fbc..7e004fb57fc4 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -13,9 +13,9 @@
 #ifndef __QCOM_SCM_H
 #define __QCOM_SCM_H
 
-extern int qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus);
-extern int qcom_scm_set_warm_boot_addr(void *entry, const cpumask_t *cpus);
-
+#define QCOM_SCM_VERSION(major, minor)	(((major) << 16) | ((minor) & 0xFF))
+#define QCOM_SCM_CPU_PWR_DOWN_L2_ON	0x0
+#define QCOM_SCM_CPU_PWR_DOWN_L2_OFF	0x1
 #define QCOM_SCM_HDCP_MAX_REQ_CNT	5
 
 struct qcom_scm_hdcp_req {
@@ -23,27 +23,47 @@ struct qcom_scm_hdcp_req {
 	u32 val;
 };
 
+#if IS_ENABLED(CONFIG_QCOM_SCM)
+extern int qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus);
+extern int qcom_scm_set_warm_boot_addr(void *entry, const cpumask_t *cpus);
 extern bool qcom_scm_is_available(void);
-
 extern bool qcom_scm_hdcp_available(void);
 extern int qcom_scm_hdcp_req(struct qcom_scm_hdcp_req *req, u32 req_cnt,
-		u32 *resp);
-
+			     u32 *resp);
 extern bool qcom_scm_pas_supported(u32 peripheral);
 extern int qcom_scm_pas_init_image(u32 peripheral, const void *metadata,
-		size_t size);
+				   size_t size);
 extern int qcom_scm_pas_mem_setup(u32 peripheral, phys_addr_t addr,
-		phys_addr_t size);
+				  phys_addr_t size);
 extern int qcom_scm_pas_auth_and_reset(u32 peripheral);
 extern int qcom_scm_pas_shutdown(u32 peripheral);
-
-#define QCOM_SCM_CPU_PWR_DOWN_L2_ON	0x0
-#define QCOM_SCM_CPU_PWR_DOWN_L2_OFF	0x1
-
 extern void qcom_scm_cpu_power_down(u32 flags);
-
-#define QCOM_SCM_VERSION(major, minor) (((major) << 16) | ((minor) & 0xFF))
-
 extern u32 qcom_scm_get_version(void);
+#else
+static inline
+int qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus)
+{
+	return -ENODEV;
+}
+static inline
+int qcom_scm_set_warm_boot_addr(void *entry, const cpumask_t *cpus)
+{
+	return -ENODEV;
+}
+static inline bool qcom_scm_is_available(void) { return false; }
+static inline bool qcom_scm_hdcp_available(void) { return false; }
+static inline int qcom_scm_hdcp_req(struct qcom_scm_hdcp_req *req, u32 req_cnt,
+				    u32 *resp) { return -ENODEV; }
+static inline bool qcom_scm_pas_supported(u32 peripheral) { return false; }
+static inline int qcom_scm_pas_init_image(u32 peripheral, const void *metadata,
+					  size_t size) { return -ENODEV; }
+static inline int qcom_scm_pas_mem_setup(u32 peripheral, phys_addr_t addr,
+					 phys_addr_t size) { return -ENODEV; }
+static inline int
+qcom_scm_pas_auth_and_reset(u32 peripheral) { return -ENODEV; }
+static inline int qcom_scm_pas_shutdown(u32 peripheral) { return -ENODEV; }
+static inline void qcom_scm_cpu_power_down(u32 flags) {}
+static inline u32 qcom_scm_get_version(void) { return 0; }
+#endif
 
 #endif

commit f01e90fe34f563a5e189d4070de4a23948105642
Author: Bjorn Andersson <bjorn.andersson@sonymobile.com>
Date:   Wed Sep 23 12:56:12 2015 -0700

    firmware: qcom: scm: Peripheral Authentication Service
    
    This adds the Peripheral Authentication Service (PAS) interface to the
    Qualcomm SCM interface. The API is used to authenticate and boot a range
    of external processors in various Qualcomm platforms.
    
    Signed-off-by: Bjorn Andersson <bjorn.andersson@sonymobile.com>
    Signed-off-by: Andy Gross <andy.gross@linaro.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index 9e12000914b3..cc32ab852fbc 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -29,6 +29,14 @@ extern bool qcom_scm_hdcp_available(void);
 extern int qcom_scm_hdcp_req(struct qcom_scm_hdcp_req *req, u32 req_cnt,
 		u32 *resp);
 
+extern bool qcom_scm_pas_supported(u32 peripheral);
+extern int qcom_scm_pas_init_image(u32 peripheral, const void *metadata,
+		size_t size);
+extern int qcom_scm_pas_mem_setup(u32 peripheral, phys_addr_t addr,
+		phys_addr_t size);
+extern int qcom_scm_pas_auth_and_reset(u32 peripheral);
+extern int qcom_scm_pas_shutdown(u32 peripheral);
+
 #define QCOM_SCM_CPU_PWR_DOWN_L2_ON	0x0
 #define QCOM_SCM_CPU_PWR_DOWN_L2_OFF	0x1
 

commit 2d3c277ca5b1a9c12cde1f760ff925b87608bc76
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Sep 29 15:48:55 2015 -0400

    qcom-scm: add missing prototype for qcom_scm_is_available()
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Andy Gross <agross@codeaurora.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index 6e7d5ec65838..9e12000914b3 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -23,6 +23,8 @@ struct qcom_scm_hdcp_req {
 	u32 val;
 };
 
+extern bool qcom_scm_is_available(void);
+
 extern bool qcom_scm_hdcp_available(void);
 extern int qcom_scm_hdcp_req(struct qcom_scm_hdcp_req *req, u32 req_cnt,
 		u32 *resp);

commit 9626b6993b2e6faf047d2d96958e8474edc9c7a5
Author: jilai wang <jilaiw@codeaurora.org>
Date:   Fri Apr 10 16:15:59 2015 -0400

    firmware: qcom: scm: Add HDCP Support
    
    HDCP driver needs to check if secure environment supports HDCP.  If it's
    supported, then it requires to program some registers through SCM.
    Add qcom_scm_hdcp_available and qcom_scm_hdcp_req to support these
    requirements.
    
    Signed-off-by: Jilai Wang <jilaiw@codeaurora.org>
    Signed-off-by: Kumar Gala <galak@codeaurora.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index d7a974d5f57c..6e7d5ec65838 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2015, The Linux Foundation. All rights reserved.
  * Copyright (C) 2015 Linaro Ltd.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -16,6 +16,17 @@
 extern int qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus);
 extern int qcom_scm_set_warm_boot_addr(void *entry, const cpumask_t *cpus);
 
+#define QCOM_SCM_HDCP_MAX_REQ_CNT	5
+
+struct qcom_scm_hdcp_req {
+	u32 addr;
+	u32 val;
+};
+
+extern bool qcom_scm_hdcp_available(void);
+extern int qcom_scm_hdcp_req(struct qcom_scm_hdcp_req *req, u32 req_cnt,
+		u32 *resp);
+
 #define QCOM_SCM_CPU_PWR_DOWN_L2_ON	0x0
 #define QCOM_SCM_CPU_PWR_DOWN_L2_OFF	0x1
 

commit 767b0235dd476596c0d4154839ae6880bec71b3c
Author: Lina Iyer <lina.iyer@linaro.org>
Date:   Mon Mar 2 16:30:30 2015 -0700

    firmware: qcom: scm: Support cpu power down through SCM
    
    Support powering down the calling cpu, by trapping into SCM. This
    termination function triggers the ARM cpu to execute WFI instruction,
    causing the power controller to safely power the cpu down.
    
    Caches may be flushed before powering down the cpu. If cache controller
    is set to turn off when the cpu is powered down, then the flags argument
    indicates to the secure mode to flush its cache lines before executing
    WFI.The warm boot reset address for the cpu should be set before the
    calling into this function for the cpu to resume.
    
    The original code for the qcom_scm_call_atomic1() comes from a patch by
    Stephen Boyd [1]. The function scm_call_atomic1() has been cherry picked
    and renamed to match the convention used in this file. Since there are
    no users of scm_call_atomic2(), the function is not included.
    
    [1]. https://lkml.org/lkml/2014/8/4/765
    
    Signed-off-by: Stephen Boyd <sboyd@codeauraro.org>
    Signed-off-by: Lina Iyer <lina.iyer@linaro.org>
    Signed-off-by: Kumar Gala <galak@codeaurora.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index 95ef72a47b0f..d7a974d5f57c 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2014, The Linux Foundation. All rights reserved.
  * Copyright (C) 2015 Linaro Ltd.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -16,6 +16,11 @@
 extern int qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus);
 extern int qcom_scm_set_warm_boot_addr(void *entry, const cpumask_t *cpus);
 
+#define QCOM_SCM_CPU_PWR_DOWN_L2_ON	0x0
+#define QCOM_SCM_CPU_PWR_DOWN_L2_OFF	0x1
+
+extern void qcom_scm_cpu_power_down(u32 flags);
+
 #define QCOM_SCM_VERSION(major, minor) (((major) << 16) | ((minor) & 0xFF))
 
 extern u32 qcom_scm_get_version(void);

commit 2ce76a6ad32fa076a2bb5561e859c97fceec8bb1
Author: Lina Iyer <lina.iyer@linaro.org>
Date:   Mon Mar 2 16:30:29 2015 -0700

    firmware: qcom: scm: Add qcom_scm_set_warm_boot_addr function
    
    A core can be powered down for cpuidle or when it is hotplugged off. In
    either case, the warmboot return address would be different. Allow
    setting the warmboot address for a specific cpu, optimize and write to
    the firmware, if the address is different than the previously set
    address.
    
    Export qcom_scm_set_warm_boot_addr function move the warm boot flags to
    implementation.
    
    Signed-off-by: Lina Iyer <lina.iyer@linaro.org>
    Signed-off-by: Kumar Gala <galak@codeaurora.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index 68a1d8801c6f..95ef72a47b0f 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -1,4 +1,5 @@
 /* Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+ * Copyright (C) 2015 Linaro Ltd.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -12,12 +13,8 @@
 #ifndef __QCOM_SCM_H
 #define __QCOM_SCM_H
 
-#define QCOM_SCM_FLAG_WARMBOOT_CPU0		0x04
-#define QCOM_SCM_FLAG_WARMBOOT_CPU1		0x02
-#define QCOM_SCM_FLAG_WARMBOOT_CPU2		0x10
-#define QCOM_SCM_FLAG_WARMBOOT_CPU3		0x40
-
 extern int qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus);
+extern int qcom_scm_set_warm_boot_addr(void *entry, const cpumask_t *cpus);
 
 #define QCOM_SCM_VERSION(major, minor) (((major) << 16) | ((minor) & 0xFF))
 

commit a353e4a06f24235138d483a2625726a5fc472949
Author: Lina Iyer <lina.iyer@linaro.org>
Date:   Mon Mar 2 16:30:28 2015 -0700

    firmware: qcom: scm: Clean cold boot entry to export only the API
    
    We dont need to export the SCM specific cold boot flags to the platform
    code. Export only a function to set the cold boot address.
    
    Signed-off-by: Lina Iyer <lina.iyer@linaro.org>
    Signed-off-by: Kumar Gala <galak@codeaurora.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
index 6bb84cffb396..68a1d8801c6f 100644
--- a/include/linux/qcom_scm.h
+++ b/include/linux/qcom_scm.h
@@ -12,15 +12,12 @@
 #ifndef __QCOM_SCM_H
 #define __QCOM_SCM_H
 
-#define QCOM_SCM_FLAG_COLDBOOT_CPU1		0x01
-#define QCOM_SCM_FLAG_COLDBOOT_CPU2		0x08
-#define QCOM_SCM_FLAG_COLDBOOT_CPU3		0x20
 #define QCOM_SCM_FLAG_WARMBOOT_CPU0		0x04
 #define QCOM_SCM_FLAG_WARMBOOT_CPU1		0x02
 #define QCOM_SCM_FLAG_WARMBOOT_CPU2		0x10
 #define QCOM_SCM_FLAG_WARMBOOT_CPU3		0x40
 
-extern int qcom_scm_set_boot_addr(u32 addr, int flags);
+extern int qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus);
 
 #define QCOM_SCM_VERSION(major, minor) (((major) << 16) | ((minor) & 0xFF))
 

commit 916f743da3546c28a2f350d197e3bea95d97ba15
Author: Kumar Gala <galak@codeaurora.org>
Date:   Thu Feb 26 15:49:09 2015 -0600

    firmware: qcom: scm: Move the scm driver to drivers/firmware
    
    Architectural changes in the ARM Linux kernel tree mandate the eventual
    removal of the mach-* directories. Move the scm driver to
    drivers/firmware and the scm header to include/linux to support that
    removal.
    
    Signed-off-by: Kumar Gala <galak@codeaurora.org>

diff --git a/include/linux/qcom_scm.h b/include/linux/qcom_scm.h
new file mode 100644
index 000000000000..6bb84cffb396
--- /dev/null
+++ b/include/linux/qcom_scm.h
@@ -0,0 +1,29 @@
+/* Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __QCOM_SCM_H
+#define __QCOM_SCM_H
+
+#define QCOM_SCM_FLAG_COLDBOOT_CPU1		0x01
+#define QCOM_SCM_FLAG_COLDBOOT_CPU2		0x08
+#define QCOM_SCM_FLAG_COLDBOOT_CPU3		0x20
+#define QCOM_SCM_FLAG_WARMBOOT_CPU0		0x04
+#define QCOM_SCM_FLAG_WARMBOOT_CPU1		0x02
+#define QCOM_SCM_FLAG_WARMBOOT_CPU2		0x10
+#define QCOM_SCM_FLAG_WARMBOOT_CPU3		0x40
+
+extern int qcom_scm_set_boot_addr(u32 addr, int flags);
+
+#define QCOM_SCM_VERSION(major, minor) (((major) << 16) | ((minor) & 0xFF))
+
+extern u32 qcom_scm_get_version(void);
+
+#endif
