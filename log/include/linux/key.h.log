commit 8c0637e950d68933a67f7438f779d79b049b5e5c
Author: David Howells <dhowells@redhat.com>
Date:   Tue May 12 15:16:29 2020 +0100

    keys: Make the KEY_NEED_* perms an enum rather than a mask
    
    Since the meaning of combining the KEY_NEED_* constants is undefined, make
    it so that you can't do that by turning them into an enum.
    
    The enum is also given some extra values to represent special
    circumstances, such as:
    
     (1) The '0' value is reserved and causes a warning to trap the parameter
         being unset.
    
     (2) The key is to be unlinked and we require no permissions on it, only
         the keyring, (this replaces the KEY_LOOKUP_FOR_UNLINK flag).
    
     (3) An override due to CAP_SYS_ADMIN.
    
     (4) An override due to an instantiation token being present.
    
     (5) The permissions check is being deferred to later key_permission()
         calls.
    
    The extra values give the opportunity for LSMs to audit these situations.
    
    [Note: This really needs overhauling so that lookup_user_key() tells
     key_task_permission() and the LSM what operation is being done and leaves
     it to those functions to decide how to map that onto the available
     permits.  However, I don't really want to make these change in the middle
     of the notifications patchset.]
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    cc: Paul Moore <paul@paul-moore.com>
    cc: Stephen Smalley <stephen.smalley.work@gmail.com>
    cc: Casey Schaufler <casey@schaufler-ca.com>
    cc: keyrings@vger.kernel.org
    cc: selinux@vger.kernel.org

diff --git a/include/linux/key.h b/include/linux/key.h
index b99b40db08fc..0f2e24f13c2b 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -71,6 +71,23 @@ struct net;
 
 #define KEY_PERM_UNDEF	0xffffffff
 
+/*
+ * The permissions required on a key that we're looking up.
+ */
+enum key_need_perm {
+	KEY_NEED_UNSPECIFIED,	/* Needed permission unspecified */
+	KEY_NEED_VIEW,		/* Require permission to view attributes */
+	KEY_NEED_READ,		/* Require permission to read content */
+	KEY_NEED_WRITE,		/* Require permission to update / modify */
+	KEY_NEED_SEARCH,	/* Require permission to search (keyring) or find (key) */
+	KEY_NEED_LINK,		/* Require permission to link */
+	KEY_NEED_SETATTR,	/* Require permission to change attributes */
+	KEY_NEED_UNLINK,	/* Require permission to unlink key */
+	KEY_SYSADMIN_OVERRIDE,	/* Special: override by CAP_SYS_ADMIN */
+	KEY_AUTHTOKEN_OVERRIDE,	/* Special: override by possession of auth token */
+	KEY_DEFER_PERM_CHECK,	/* Special: permission check is deferred */
+};
+
 struct seq_file;
 struct user_struct;
 struct signal_struct;
@@ -420,20 +437,9 @@ static inline key_serial_t key_serial(const struct key *key)
 extern void key_set_timeout(struct key *, unsigned);
 
 extern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,
-				 key_perm_t perm);
+				 enum key_need_perm need_perm);
 extern void key_free_user_ns(struct user_namespace *);
 
-/*
- * The permissions required on a key that we're looking up.
- */
-#define	KEY_NEED_VIEW	0x01	/* Require permission to view attributes */
-#define	KEY_NEED_READ	0x02	/* Require permission to read content */
-#define	KEY_NEED_WRITE	0x04	/* Require permission to update / modify */
-#define	KEY_NEED_SEARCH	0x08	/* Require permission to search (keyring) or find (key) */
-#define	KEY_NEED_LINK	0x10	/* Require permission to link */
-#define	KEY_NEED_SETATTR 0x20	/* Require permission to change attributes */
-#define	KEY_NEED_ALL	0x3f	/* All the above permissions */
-
 static inline short key_read_state(const struct key *key)
 {
 	/* Barrier versus mark_key_instantiated(). */

commit f7e47677e39a03057dcced2016c92a9c868693ec
Author: David Howells <dhowells@redhat.com>
Date:   Tue Jan 14 17:07:11 2020 +0000

    watch_queue: Add a key/keyring notification facility
    
    Add a key/keyring change notification facility whereby notifications about
    changes in key and keyring content and attributes can be received.
    
    Firstly, an event queue needs to be created:
    
            pipe2(fds, O_NOTIFICATION_PIPE);
            ioctl(fds[1], IOC_WATCH_QUEUE_SET_SIZE, 256);
    
    then a notification can be set up to report notifications via that queue:
    
            struct watch_notification_filter filter = {
                    .nr_filters = 1,
                    .filters = {
                            [0] = {
                                    .type = WATCH_TYPE_KEY_NOTIFY,
                                    .subtype_filter[0] = UINT_MAX,
                            },
                    },
            };
            ioctl(fds[1], IOC_WATCH_QUEUE_SET_FILTER, &filter);
            keyctl_watch_key(KEY_SPEC_SESSION_KEYRING, fds[1], 0x01);
    
    After that, records will be placed into the queue when events occur in
    which keys are changed in some way.  Records are of the following format:
    
            struct key_notification {
                    struct watch_notification watch;
                    __u32   key_id;
                    __u32   aux;
            } *n;
    
    Where:
    
            n->watch.type will be WATCH_TYPE_KEY_NOTIFY.
    
            n->watch.subtype will indicate the type of event, such as
            NOTIFY_KEY_REVOKED.
    
            n->watch.info & WATCH_INFO_LENGTH will indicate the length of the
            record.
    
            n->watch.info & WATCH_INFO_ID will be the second argument to
            keyctl_watch_key(), shifted.
    
            n->key will be the ID of the affected key.
    
            n->aux will hold subtype-dependent information, such as the key
            being linked into the keyring specified by n->key in the case of
            NOTIFY_KEY_LINKED.
    
    Note that it is permissible for event records to be of variable length -
    or, at least, the length may be dependent on the subtype.  Note also that
    the queue can be shared between multiple notifications of various types.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: James Morris <jamorris@linux.microsoft.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 6cf8e71cf8b7..b99b40db08fc 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -176,6 +176,9 @@ struct key {
 		struct list_head graveyard_link;
 		struct rb_node	serial_node;
 	};
+#ifdef CONFIG_KEY_NOTIFICATIONS
+	struct watch_list	*watchers;	/* Entities watching this key for changes */
+#endif
 	struct rw_semaphore	sem;		/* change vs change sem */
 	struct key_user		*user;		/* owner of this key */
 	void			*security;	/* security data for this key */

commit 8b6a666a97544bf307190a05947742b8357aa962
Author: David Howells <dhowells@redhat.com>
Date:   Mon May 20 08:48:46 2019 +0100

    afs: Provide an RCU-capable key lookup
    
    Provide an RCU-capable key lookup function.  We don't want to call
    afs_request_key() in RCU-mode pathwalk as request_key() might sleep, even if
    we don't ask it to construct anything as it might find a key that is currently
    undergoing construction.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 50028338a4cc..6cf8e71cf8b7 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -324,7 +324,7 @@ static inline struct key *request_key(struct key_type *type,
 }
 
 #ifdef CONFIG_NET
-/*
+/**
  * request_key_net - Request a key for a net namespace and wait for construction
  * @type: Type of key.
  * @description: The searchable description of the key.
@@ -341,6 +341,18 @@ static inline struct key *request_key(struct key_type *type,
  */
 #define request_key_net(type, description, net, callout_info) \
 	request_key_tag(type, description, net->key_domain, callout_info);
+
+/**
+ * request_key_net_rcu - Request a key for a net namespace under RCU conditions
+ * @type: Type of key.
+ * @description: The searchable description of the key.
+ * @net: The network namespace that is the key's domain of operation.
+ *
+ * As for request_key_rcu() except that only keys that operate the specified
+ * network namespace are used.
+ */
+#define request_key_net_rcu(type, description, net) \
+	request_key_rcu(type, description, net->key_domain);
 #endif /* CONFIG_NET */
 
 extern int wait_for_key_construction(struct key *key, bool intr);

commit 555df336c754ac9de1af9a5c72508918b3796b18
Author: David Howells <dhowells@redhat.com>
Date:   Mon Aug 19 16:02:01 2019 +0100

    keys: Fix description size
    
    The maximum key description size is 4095.  Commit f771fde82051 ("keys:
    Simplify key description management") inadvertantly reduced that to 255
    and made sizes between 256 and 4095 work weirdly, and any size whereby
    size & 255 == 0 would cause an assertion in __key_link_begin() at the
    following line:
    
            BUG_ON(index_key->desc_len == 0);
    
    This can be fixed by simply increasing the size of desc_len in struct
    keyring_index_key to a u16.
    
    Note the argument length test in keyutils only checked empty
    descriptions and descriptions with a size around the limit (ie.  4095)
    and not for all the values in between, so it missed this.  This has been
    addressed and
    
            https://git.kernel.org/pub/scm/linux/kernel/git/dhowells/keyutils.git/commit/?id=066bf56807c26cd3045a25f355b34c1d8a20a5aa
    
    now exhaustively tests all possible lengths of type, description and
    payload and then some.
    
    The assertion failure looks something like:
    
     kernel BUG at security/keys/keyring.c:1245!
     ...
     RIP: 0010:__key_link_begin+0x88/0xa0
     ...
     Call Trace:
      key_create_or_update+0x211/0x4b0
      __x64_sys_add_key+0x101/0x200
      do_syscall_64+0x5b/0x1e0
      entry_SYSCALL_64_after_hwframe+0x44/0xa9
    
    It can be triggered by:
    
            keyctl add user "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" a @s
    
    Fixes: f771fde82051 ("keys: Simplify key description management")
    Reported-by: kernel test robot <rong.a.chen@intel.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 91f391cd272e..50028338a4cc 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -94,11 +94,11 @@ struct keyring_index_key {
 	union {
 		struct {
 #ifdef __LITTLE_ENDIAN /* Put desc_len at the LSB of x */
-			u8	desc_len;
-			char	desc[sizeof(long) - 1];	/* First few chars of description */
+			u16	desc_len;
+			char	desc[sizeof(long) - 2];	/* First few chars of description */
 #else
-			char	desc[sizeof(long) - 1];	/* First few chars of description */
-			u8	desc_len;
+			char	desc[sizeof(long) - 2];	/* First few chars of description */
+			u16	desc_len;
 #endif
 		};
 		unsigned long x;

commit 028db3e290f15ac509084c0fc3b9d021f668f877
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 10 18:43:43 2019 -0700

    Revert "Merge tag 'keys-acl-20190703' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs"
    
    This reverts merge 0f75ef6a9cff49ff612f7ce0578bced9d0b38325 (and thus
    effectively commits
    
       7a1ade847596 ("keys: Provide KEYCTL_GRANT_PERMISSION")
       2e12256b9a76 ("keys: Replace uid/gid/perm permissions checking with an ACL")
    
    that the merge brought in).
    
    It turns out that it breaks booting with an encrypted volume, and Eric
    biggers reports that it also breaks the fscrypt tests [1] and loading of
    in-kernel X.509 certificates [2].
    
    The root cause of all the breakage is likely the same, but David Howells
    is off email so rather than try to work it out it's getting reverted in
    order to not impact the rest of the merge window.
    
     [1] https://lore.kernel.org/lkml/20190710011559.GA7973@sol.localdomain/
     [2] https://lore.kernel.org/lkml/20190710013225.GB7973@sol.localdomain/
    
    Link: https://lore.kernel.org/lkml/CAHk-=wjxoeMJfeBahnWH=9zShKp2bsVy527vo3_y8HfOdhwAAw@mail.gmail.com/
    Reported-by: Eric Biggers <ebiggers@kernel.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: James Morris <jmorris@namei.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 6fef6684501f..91f391cd272e 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -27,15 +27,50 @@
 /* key handle serial number */
 typedef int32_t key_serial_t;
 
+/* key handle permissions mask */
+typedef uint32_t key_perm_t;
+
 struct key;
 struct net;
 
 #ifdef CONFIG_KEYS
 
-#include <linux/keyctl.h>
-
 #undef KEY_DEBUGGING
 
+#define KEY_POS_VIEW	0x01000000	/* possessor can view a key's attributes */
+#define KEY_POS_READ	0x02000000	/* possessor can read key payload / view keyring */
+#define KEY_POS_WRITE	0x04000000	/* possessor can update key payload / add link to keyring */
+#define KEY_POS_SEARCH	0x08000000	/* possessor can find a key in search / search a keyring */
+#define KEY_POS_LINK	0x10000000	/* possessor can create a link to a key/keyring */
+#define KEY_POS_SETATTR	0x20000000	/* possessor can set key attributes */
+#define KEY_POS_ALL	0x3f000000
+
+#define KEY_USR_VIEW	0x00010000	/* user permissions... */
+#define KEY_USR_READ	0x00020000
+#define KEY_USR_WRITE	0x00040000
+#define KEY_USR_SEARCH	0x00080000
+#define KEY_USR_LINK	0x00100000
+#define KEY_USR_SETATTR	0x00200000
+#define KEY_USR_ALL	0x003f0000
+
+#define KEY_GRP_VIEW	0x00000100	/* group permissions... */
+#define KEY_GRP_READ	0x00000200
+#define KEY_GRP_WRITE	0x00000400
+#define KEY_GRP_SEARCH	0x00000800
+#define KEY_GRP_LINK	0x00001000
+#define KEY_GRP_SETATTR	0x00002000
+#define KEY_GRP_ALL	0x00003f00
+
+#define KEY_OTH_VIEW	0x00000001	/* third party permissions... */
+#define KEY_OTH_READ	0x00000002
+#define KEY_OTH_WRITE	0x00000004
+#define KEY_OTH_SEARCH	0x00000008
+#define KEY_OTH_LINK	0x00000010
+#define KEY_OTH_SETATTR	0x00000020
+#define KEY_OTH_ALL	0x0000003f
+
+#define KEY_PERM_UNDEF	0xffffffff
+
 struct seq_file;
 struct user_struct;
 struct signal_struct;
@@ -78,36 +113,6 @@ union key_payload {
 	void			*data[4];
 };
 
-struct key_ace {
-	unsigned int		type;
-	unsigned int		perm;
-	union {
-		kuid_t		uid;
-		kgid_t		gid;
-		unsigned int	subject_id;
-	};
-};
-
-struct key_acl {
-	refcount_t		usage;
-	unsigned short		nr_ace;
-	bool			possessor_viewable;
-	struct rcu_head		rcu;
-	struct key_ace		aces[];
-};
-
-#define KEY_POSSESSOR_ACE(perms) {			\
-		.type = KEY_ACE_SUBJ_STANDARD,		\
-		.perm = perms,				\
-		.subject_id = KEY_ACE_POSSESSOR		\
-	}
-
-#define KEY_OWNER_ACE(perms) {				\
-		.type = KEY_ACE_SUBJ_STANDARD,		\
-		.perm = perms,				\
-		.subject_id = KEY_ACE_OWNER		\
-	}
-
 /*****************************************************************************/
 /*
  * key reference with possession attribute handling
@@ -174,7 +179,6 @@ struct key {
 	struct rw_semaphore	sem;		/* change vs change sem */
 	struct key_user		*user;		/* owner of this key */
 	void			*security;	/* security data for this key */
-	struct key_acl		__rcu *acl;
 	union {
 		time64_t	expiry;		/* time at which key expires (or 0) */
 		time64_t	revoked_at;	/* time at which key was revoked */
@@ -182,6 +186,7 @@ struct key {
 	time64_t		last_used_at;	/* last time used for LRU keyring discard */
 	kuid_t			uid;
 	kgid_t			gid;
+	key_perm_t		perm;		/* access permissions */
 	unsigned short		quotalen;	/* length added to quota */
 	unsigned short		datalen;	/* payload data length
 						 * - may not match RCU dereferenced payload
@@ -205,7 +210,6 @@ struct key {
 #define KEY_FLAG_ROOT_CAN_INVAL	7	/* set if key can be invalidated by root without permission */
 #define KEY_FLAG_KEEP		8	/* set if key should not be removed */
 #define KEY_FLAG_UID_KEYRING	9	/* set if key is a user or user session keyring */
-#define KEY_FLAG_HAS_ACL	10	/* Set if KEYCTL_SETACL called on key */
 
 	/* the key type and key description string
 	 * - the desc is used to match a key against search criteria
@@ -254,7 +258,7 @@ extern struct key *key_alloc(struct key_type *type,
 			     const char *desc,
 			     kuid_t uid, kgid_t gid,
 			     const struct cred *cred,
-			     struct key_acl *acl,
+			     key_perm_t perm,
 			     unsigned long flags,
 			     struct key_restriction *restrict_link);
 
@@ -291,8 +295,7 @@ static inline void key_ref_put(key_ref_t key_ref)
 extern struct key *request_key_tag(struct key_type *type,
 				   const char *description,
 				   struct key_tag *domain_tag,
-				   const char *callout_info,
-				   struct key_acl *acl);
+				   const char *callout_info);
 
 extern struct key *request_key_rcu(struct key_type *type,
 				   const char *description,
@@ -303,24 +306,21 @@ extern struct key *request_key_with_auxdata(struct key_type *type,
 					    struct key_tag *domain_tag,
 					    const void *callout_info,
 					    size_t callout_len,
-					    void *aux,
-					    struct key_acl *acl);
+					    void *aux);
 
 /**
  * request_key - Request a key and wait for construction
  * @type: Type of key.
  * @description: The searchable description of the key.
  * @callout_info: The data to pass to the instantiation upcall (or NULL).
- * @acl: The ACL to attach to a new key (or NULL).
  *
  * As for request_key_tag(), but with the default global domain tag.
  */
 static inline struct key *request_key(struct key_type *type,
 				      const char *description,
-				      const char *callout_info,
-				      struct key_acl *acl)
+				      const char *callout_info)
 {
-	return request_key_tag(type, description, NULL, callout_info, acl);
+	return request_key_tag(type, description, NULL, callout_info);
 }
 
 #ifdef CONFIG_NET
@@ -330,7 +330,6 @@ static inline struct key *request_key(struct key_type *type,
  * @description: The searchable description of the key.
  * @net: The network namespace that is the key's domain of operation.
  * @callout_info: The data to pass to the instantiation upcall (or NULL).
- * @acl: The ACL to attach to a new key (or NULL).
  *
  * As for request_key() except that it does not add the returned key to a
  * keyring if found, new keys are always allocated in the user's quota, the
@@ -340,8 +339,8 @@ static inline struct key *request_key(struct key_type *type,
  * Furthermore, it then works as wait_for_key_construction() to wait for the
  * completion of keys undergoing construction with a non-interruptible wait.
  */
-#define request_key_net(type, description, net, callout_info, acl)	\
-	request_key_tag(type, description, net->key_domain, callout_info, acl);
+#define request_key_net(type, description, net, callout_info) \
+	request_key_tag(type, description, net->key_domain, callout_info);
 #endif /* CONFIG_NET */
 
 extern int wait_for_key_construction(struct key *key, bool intr);
@@ -353,7 +352,7 @@ extern key_ref_t key_create_or_update(key_ref_t keyring,
 				      const char *description,
 				      const void *payload,
 				      size_t plen,
-				      struct key_acl *acl,
+				      key_perm_t perm,
 				      unsigned long flags);
 
 extern int key_update(key_ref_t key,
@@ -373,7 +372,7 @@ extern int key_unlink(struct key *keyring,
 
 extern struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,
 				 const struct cred *cred,
-				 struct key_acl *acl,
+				 key_perm_t perm,
 				 unsigned long flags,
 				 struct key_restriction *restrict_link,
 				 struct key *dest);
@@ -406,29 +405,19 @@ static inline key_serial_t key_serial(const struct key *key)
 extern void key_set_timeout(struct key *, unsigned);
 
 extern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,
-				 u32 desired_perm);
+				 key_perm_t perm);
 extern void key_free_user_ns(struct user_namespace *);
 
 /*
  * The permissions required on a key that we're looking up.
  */
-#define	KEY_NEED_VIEW	0x001	/* Require permission to view attributes */
-#define	KEY_NEED_READ	0x002	/* Require permission to read content */
-#define	KEY_NEED_WRITE	0x004	/* Require permission to update / modify */
-#define	KEY_NEED_SEARCH	0x008	/* Require permission to search (keyring) or find (key) */
-#define	KEY_NEED_LINK	0x010	/* Require permission to link */
-#define	KEY_NEED_SETSEC	0x020	/* Require permission to set owner, group, ACL */
-#define	KEY_NEED_INVAL	0x040	/* Require permission to invalidate key */
-#define	KEY_NEED_REVOKE	0x080	/* Require permission to revoke key */
-#define	KEY_NEED_JOIN	0x100	/* Require permission to join keyring as session */
-#define	KEY_NEED_CLEAR	0x200	/* Require permission to clear a keyring */
-#define KEY_NEED_ALL	0x3ff
-
-#define OLD_KEY_NEED_SETATTR 0x20 /* Used to be Require permission to change attributes */
-
-extern struct key_acl internal_key_acl;
-extern struct key_acl internal_keyring_acl;
-extern struct key_acl internal_writable_keyring_acl;
+#define	KEY_NEED_VIEW	0x01	/* Require permission to view attributes */
+#define	KEY_NEED_READ	0x02	/* Require permission to read content */
+#define	KEY_NEED_WRITE	0x04	/* Require permission to update / modify */
+#define	KEY_NEED_SEARCH	0x08	/* Require permission to search (keyring) or find (key) */
+#define	KEY_NEED_LINK	0x10	/* Require permission to link */
+#define	KEY_NEED_SETATTR 0x20	/* Require permission to change attributes */
+#define	KEY_NEED_ALL	0x3f	/* All the above permissions */
 
 static inline short key_read_state(const struct key *key)
 {

commit 0f75ef6a9cff49ff612f7ce0578bced9d0b38325
Merge: c84ca912b079 7a1ade847596
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 19:56:57 2019 -0700

    Merge tag 'keys-acl-20190703' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs
    
    Pull keyring ACL support from David Howells:
     "This changes the permissions model used by keys and keyrings to be
      based on an internal ACL by the following means:
    
       - Replace the permissions mask internally with an ACL that contains a
         list of ACEs, each with a specific subject with a permissions mask.
         Potted default ACLs are available for new keys and keyrings.
    
         ACE subjects can be macroised to indicate the UID and GID specified
         on the key (which remain). Future commits will be able to add
         additional subject types, such as specific UIDs or domain
         tags/namespaces.
    
         Also split a number of permissions to give finer control. Examples
         include splitting the revocation permit from the change-attributes
         permit, thereby allowing someone to be granted permission to revoke
         a key without allowing them to change the owner; also the ability
         to join a keyring is split from the ability to link to it, thereby
         stopping a process accessing a keyring by joining it and thus
         acquiring use of possessor permits.
    
       - Provide a keyctl to allow the granting or denial of one or more
         permits to a specific subject. Direct access to the ACL is not
         granted, and the ACL cannot be viewed"
    
    * tag 'keys-acl-20190703' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs:
      keys: Provide KEYCTL_GRANT_PERMISSION
      keys: Replace uid/gid/perm permissions checking with an ACL

commit c84ca912b07901be528e5184fd254fca1dddf2ac
Merge: c236b6dd48dc a58946c158a0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 19:36:47 2019 -0700

    Merge tag 'keys-namespace-20190627' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs
    
    Pull keyring namespacing from David Howells:
     "These patches help make keys and keyrings more namespace aware.
    
      Firstly some miscellaneous patches to make the process easier:
    
       - Simplify key index_key handling so that the word-sized chunks
         assoc_array requires don't have to be shifted about, making it
         easier to add more bits into the key.
    
       - Cache the hash value in the key so that we don't have to calculate
         on every key we examine during a search (it involves a bunch of
         multiplications).
    
       - Allow keying_search() to search non-recursively.
    
      Then the main patches:
    
       - Make it so that keyring names are per-user_namespace from the point
         of view of KEYCTL_JOIN_SESSION_KEYRING so that they're not
         accessible cross-user_namespace.
    
         keyctl_capabilities() shows KEYCTL_CAPS1_NS_KEYRING_NAME for this.
    
       - Move the user and user-session keyrings to the user_namespace
         rather than the user_struct. This prevents them propagating
         directly across user_namespaces boundaries (ie. the KEY_SPEC_*
         flags will only pick from the current user_namespace).
    
       - Make it possible to include the target namespace in which the key
         shall operate in the index_key. This will allow the possibility of
         multiple keys with the same description, but different target
         domains to be held in the same keyring.
    
         keyctl_capabilities() shows KEYCTL_CAPS1_NS_KEY_TAG for this.
    
       - Make it so that keys are implicitly invalidated by removal of a
         domain tag, causing them to be garbage collected.
    
       - Institute a network namespace domain tag that allows keys to be
         differentiated by the network namespace in which they operate. New
         keys that are of a type marked 'KEY_TYPE_NET_DOMAIN' are assigned
         the network domain in force when they are created.
    
       - Make it so that the desired network namespace can be handed down
         into the request_key() mechanism. This allows AFS, NFS, etc. to
         request keys specific to the network namespace of the superblock.
    
         This also means that the keys in the DNS record cache are
         thenceforth namespaced, provided network filesystems pass the
         appropriate network namespace down into dns_query().
    
         For DNS, AFS and NFS are good, whilst CIFS and Ceph are not. Other
         cache keyrings, such as idmapper keyrings, also need to set the
         domain tag - for which they need access to the network namespace of
         the superblock"
    
    * tag 'keys-namespace-20190627' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs:
      keys: Pass the network namespace into request_key mechanism
      keys: Network namespace domain tag
      keys: Garbage collect keys for which the domain has been removed
      keys: Include target namespace in match criteria
      keys: Move the user and user-session keyrings to the user_namespace
      keys: Namespace keyring names
      keys: Add a 'recurse' flag for keyring searches
      keys: Cache the hash value to avoid lots of recalculation
      keys: Simplify key description management

commit c236b6dd48dcf2ae6ed14b9068830eccc3e181e6
Merge: d44a62742dec 3b8c4a08a471
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 19:19:37 2019 -0700

    Merge tag 'keys-request-20190626' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs
    
    Pull request_key improvements from David Howells:
     "These are all request_key()-related, including a fix and some improvements:
    
       - Fix the lack of a Link permission check on a key found by
         request_key(), thereby enabling request_key() to link keys that
         don't grant this permission to the target keyring (which must still
         grant Write permission).
    
         Note that the key must be in the caller's keyrings already to be
         found.
    
       - Invalidate used request_key authentication keys rather than
         revoking them, so that they get cleaned up immediately rather than
         hanging around till the expiry time is passed.
    
       - Move the RCU locks outwards from the keyring search functions so
         that a request_key_rcu() can be provided. This can be called in RCU
         mode, so it can't sleep and can't upcall - but it can be called
         from LOOKUP_RCU pathwalk mode.
    
       - Cache the latest positive result of request_key*() temporarily in
         task_struct so that filesystems that make a lot of request_key()
         calls during pathwalk can take advantage of it to avoid having to
         redo the searching. This requires CONFIG_KEYS_REQUEST_CACHE=y.
    
         It is assumed that the key just found is likely to be used multiple
         times in each step in an RCU pathwalk, and is likely to be reused
         for the next step too.
    
         Note that the cleanup of the cache is done on TIF_NOTIFY_RESUME,
         just before userspace resumes, and on exit"
    
    * tag 'keys-request-20190626' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs:
      keys: Kill off request_key_async{,_with_auxdata}
      keys: Cache result of request_key*() temporarily in task_struct
      keys: Provide request_key_rcu()
      keys: Move the RCU locks outwards from the keyring search functions
      keys: Invalidate used request_key authentication keys
      keys: Fix request_key() lack of Link perm check on found key

commit d44a62742decca5ae5688a562584dc0fe9fc63f6
Merge: 7c0f89634892 45e0f30c30bb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 19:02:11 2019 -0700

    Merge tag 'keys-misc-20190619' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs
    
    Pull misc keyring updates from David Howells:
     "These are some miscellaneous keyrings fixes and improvements:
    
       - Fix a bunch of warnings from sparse, including missing RCU bits and
         kdoc-function argument mismatches
    
       - Implement a keyctl to allow a key to be moved from one keyring to
         another, with the option of prohibiting key replacement in the
         destination keyring.
    
       - Grant Link permission to possessors of request_key_auth tokens so
         that upcall servicing daemons can more easily arrange things such
         that only the necessary auth key is passed to the actual service
         program, and not all the auth keys a daemon might possesss.
    
       - Improvement in lookup_user_key().
    
       - Implement a keyctl to allow keyrings subsystem capabilities to be
         queried.
    
      The keyutils next branch has commits to make available, document and
      test the move-key and capabilities code:
    
            https://git.kernel.org/pub/scm/linux/kernel/git/dhowells/keyutils.git/log
    
      They're currently on the 'next' branch"
    
    * tag 'keys-misc-20190619' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs:
      keys: Add capability-checking keyctl function
      keys: Reuse keyring_index_key::desc_len in lookup_user_key()
      keys: Grant Link permission to possessers of request_key auth keys
      keys: Add a keyctl to move a key between keyrings
      keys: Hoist locking out of __key_link_begin()
      keys: Break bits out of key_unlink()
      keys: Change keyring_serialise_link_sem to a mutex
      keys: sparse: Fix kdoc mismatches
      keys: sparse: Fix incorrect RCU accesses
      keys: sparse: Fix key_fs[ug]id_changed()

commit 2e12256b9a76584fa3a6da19210509d4775aee36
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jun 27 23:03:07 2019 +0100

    keys: Replace uid/gid/perm permissions checking with an ACL
    
    Replace the uid/gid/perm permissions checking on a key with an ACL to allow
    the SETATTR and SEARCH permissions to be split.  This will also allow a
    greater range of subjects to represented.
    
    ============
    WHY DO THIS?
    ============
    
    The problem is that SETATTR and SEARCH cover a slew of actions, not all of
    which should be grouped together.
    
    For SETATTR, this includes actions that are about controlling access to a
    key:
    
     (1) Changing a key's ownership.
    
     (2) Changing a key's security information.
    
     (3) Setting a keyring's restriction.
    
    And actions that are about managing a key's lifetime:
    
     (4) Setting an expiry time.
    
     (5) Revoking a key.
    
    and (proposed) managing a key as part of a cache:
    
     (6) Invalidating a key.
    
    Managing a key's lifetime doesn't really have anything to do with
    controlling access to that key.
    
    Expiry time is awkward since it's more about the lifetime of the content
    and so, in some ways goes better with WRITE permission.  It can, however,
    be set unconditionally by a process with an appropriate authorisation token
    for instantiating a key, and can also be set by the key type driver when a
    key is instantiated, so lumping it with the access-controlling actions is
    probably okay.
    
    As for SEARCH permission, that currently covers:
    
     (1) Finding keys in a keyring tree during a search.
    
     (2) Permitting keyrings to be joined.
    
     (3) Invalidation.
    
    But these don't really belong together either, since these actions really
    need to be controlled separately.
    
    Finally, there are number of special cases to do with granting the
    administrator special rights to invalidate or clear keys that I would like
    to handle with the ACL rather than key flags and special checks.
    
    
    ===============
    WHAT IS CHANGED
    ===============
    
    The SETATTR permission is split to create two new permissions:
    
     (1) SET_SECURITY - which allows the key's owner, group and ACL to be
         changed and a restriction to be placed on a keyring.
    
     (2) REVOKE - which allows a key to be revoked.
    
    The SEARCH permission is split to create:
    
     (1) SEARCH - which allows a keyring to be search and a key to be found.
    
     (2) JOIN - which allows a keyring to be joined as a session keyring.
    
     (3) INVAL - which allows a key to be invalidated.
    
    The WRITE permission is also split to create:
    
     (1) WRITE - which allows a key's content to be altered and links to be
         added, removed and replaced in a keyring.
    
     (2) CLEAR - which allows a keyring to be cleared completely.  This is
         split out to make it possible to give just this to an administrator.
    
     (3) REVOKE - see above.
    
    
    Keys acquire ACLs which consist of a series of ACEs, and all that apply are
    unioned together.  An ACE specifies a subject, such as:
    
     (*) Possessor - permitted to anyone who 'possesses' a key
     (*) Owner - permitted to the key owner
     (*) Group - permitted to the key group
     (*) Everyone - permitted to everyone
    
    Note that 'Other' has been replaced with 'Everyone' on the assumption that
    you wouldn't grant a permit to 'Other' that you wouldn't also grant to
    everyone else.
    
    Further subjects may be made available by later patches.
    
    The ACE also specifies a permissions mask.  The set of permissions is now:
    
            VIEW            Can view the key metadata
            READ            Can read the key content
            WRITE           Can update/modify the key content
            SEARCH          Can find the key by searching/requesting
            LINK            Can make a link to the key
            SET_SECURITY    Can change owner, ACL, expiry
            INVAL           Can invalidate
            REVOKE          Can revoke
            JOIN            Can join this keyring
            CLEAR           Can clear this keyring
    
    
    The KEYCTL_SETPERM function is then deprecated.
    
    The KEYCTL_SET_TIMEOUT function then is permitted if SET_SECURITY is set,
    or if the caller has a valid instantiation auth token.
    
    The KEYCTL_INVALIDATE function then requires INVAL.
    
    The KEYCTL_REVOKE function then requires REVOKE.
    
    The KEYCTL_JOIN_SESSION_KEYRING function then requires JOIN to join an
    existing keyring.
    
    The JOIN permission is enabled by default for session keyrings and manually
    created keyrings only.
    
    
    ======================
    BACKWARD COMPATIBILITY
    ======================
    
    To maintain backward compatibility, KEYCTL_SETPERM will translate the
    permissions mask it is given into a new ACL for a key - unless
    KEYCTL_SET_ACL has been called on that key, in which case an error will be
    returned.
    
    It will convert possessor, owner, group and other permissions into separate
    ACEs, if each portion of the mask is non-zero.
    
    SETATTR permission turns on all of INVAL, REVOKE and SET_SECURITY.  WRITE
    permission turns on WRITE, REVOKE and, if a keyring, CLEAR.  JOIN is turned
    on if a keyring is being altered.
    
    The KEYCTL_DESCRIBE function translates the ACL back into a permissions
    mask to return depending on possessor, owner, group and everyone ACEs.
    
    It will make the following mappings:
    
     (1) INVAL, JOIN -> SEARCH
    
     (2) SET_SECURITY -> SETATTR
    
     (3) REVOKE -> WRITE if SETATTR isn't already set
    
     (4) CLEAR -> WRITE
    
    Note that the value subsequently returned by KEYCTL_DESCRIBE may not match
    the value set with KEYCTL_SETATTR.
    
    
    =======
    TESTING
    =======
    
    This passes the keyutils testsuite for all but a couple of tests:
    
     (1) tests/keyctl/dh_compute/badargs: The first wrong-key-type test now
         returns EOPNOTSUPP rather than ENOKEY as READ permission isn't removed
         if the type doesn't have ->read().  You still can't actually read the
         key.
    
     (2) tests/keyctl/permitting/valid: The view-other-permissions test doesn't
         work as Other has been replaced with Everyone in the ACL.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 18d7f62ab6b0..bc4adfd254fe 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -32,49 +32,14 @@
 /* key handle serial number */
 typedef int32_t key_serial_t;
 
-/* key handle permissions mask */
-typedef uint32_t key_perm_t;
-
 struct key;
 struct net;
 
 #ifdef CONFIG_KEYS
 
-#undef KEY_DEBUGGING
+#include <linux/keyctl.h>
 
-#define KEY_POS_VIEW	0x01000000	/* possessor can view a key's attributes */
-#define KEY_POS_READ	0x02000000	/* possessor can read key payload / view keyring */
-#define KEY_POS_WRITE	0x04000000	/* possessor can update key payload / add link to keyring */
-#define KEY_POS_SEARCH	0x08000000	/* possessor can find a key in search / search a keyring */
-#define KEY_POS_LINK	0x10000000	/* possessor can create a link to a key/keyring */
-#define KEY_POS_SETATTR	0x20000000	/* possessor can set key attributes */
-#define KEY_POS_ALL	0x3f000000
-
-#define KEY_USR_VIEW	0x00010000	/* user permissions... */
-#define KEY_USR_READ	0x00020000
-#define KEY_USR_WRITE	0x00040000
-#define KEY_USR_SEARCH	0x00080000
-#define KEY_USR_LINK	0x00100000
-#define KEY_USR_SETATTR	0x00200000
-#define KEY_USR_ALL	0x003f0000
-
-#define KEY_GRP_VIEW	0x00000100	/* group permissions... */
-#define KEY_GRP_READ	0x00000200
-#define KEY_GRP_WRITE	0x00000400
-#define KEY_GRP_SEARCH	0x00000800
-#define KEY_GRP_LINK	0x00001000
-#define KEY_GRP_SETATTR	0x00002000
-#define KEY_GRP_ALL	0x00003f00
-
-#define KEY_OTH_VIEW	0x00000001	/* third party permissions... */
-#define KEY_OTH_READ	0x00000002
-#define KEY_OTH_WRITE	0x00000004
-#define KEY_OTH_SEARCH	0x00000008
-#define KEY_OTH_LINK	0x00000010
-#define KEY_OTH_SETATTR	0x00000020
-#define KEY_OTH_ALL	0x0000003f
-
-#define KEY_PERM_UNDEF	0xffffffff
+#undef KEY_DEBUGGING
 
 struct seq_file;
 struct user_struct;
@@ -118,6 +83,36 @@ union key_payload {
 	void			*data[4];
 };
 
+struct key_ace {
+	unsigned int		type;
+	unsigned int		perm;
+	union {
+		kuid_t		uid;
+		kgid_t		gid;
+		unsigned int	subject_id;
+	};
+};
+
+struct key_acl {
+	refcount_t		usage;
+	unsigned short		nr_ace;
+	bool			possessor_viewable;
+	struct rcu_head		rcu;
+	struct key_ace		aces[];
+};
+
+#define KEY_POSSESSOR_ACE(perms) {			\
+		.type = KEY_ACE_SUBJ_STANDARD,		\
+		.perm = perms,				\
+		.subject_id = KEY_ACE_POSSESSOR		\
+	}
+
+#define KEY_OWNER_ACE(perms) {				\
+		.type = KEY_ACE_SUBJ_STANDARD,		\
+		.perm = perms,				\
+		.subject_id = KEY_ACE_OWNER		\
+	}
+
 /*****************************************************************************/
 /*
  * key reference with possession attribute handling
@@ -184,6 +179,7 @@ struct key {
 	struct rw_semaphore	sem;		/* change vs change sem */
 	struct key_user		*user;		/* owner of this key */
 	void			*security;	/* security data for this key */
+	struct key_acl		__rcu *acl;
 	union {
 		time64_t	expiry;		/* time at which key expires (or 0) */
 		time64_t	revoked_at;	/* time at which key was revoked */
@@ -191,7 +187,6 @@ struct key {
 	time64_t		last_used_at;	/* last time used for LRU keyring discard */
 	kuid_t			uid;
 	kgid_t			gid;
-	key_perm_t		perm;		/* access permissions */
 	unsigned short		quotalen;	/* length added to quota */
 	unsigned short		datalen;	/* payload data length
 						 * - may not match RCU dereferenced payload
@@ -215,6 +210,7 @@ struct key {
 #define KEY_FLAG_ROOT_CAN_INVAL	7	/* set if key can be invalidated by root without permission */
 #define KEY_FLAG_KEEP		8	/* set if key should not be removed */
 #define KEY_FLAG_UID_KEYRING	9	/* set if key is a user or user session keyring */
+#define KEY_FLAG_HAS_ACL	10	/* Set if KEYCTL_SETACL called on key */
 
 	/* the key type and key description string
 	 * - the desc is used to match a key against search criteria
@@ -263,7 +259,7 @@ extern struct key *key_alloc(struct key_type *type,
 			     const char *desc,
 			     kuid_t uid, kgid_t gid,
 			     const struct cred *cred,
-			     key_perm_t perm,
+			     struct key_acl *acl,
 			     unsigned long flags,
 			     struct key_restriction *restrict_link);
 
@@ -300,7 +296,8 @@ static inline void key_ref_put(key_ref_t key_ref)
 extern struct key *request_key_tag(struct key_type *type,
 				   const char *description,
 				   struct key_tag *domain_tag,
-				   const char *callout_info);
+				   const char *callout_info,
+				   struct key_acl *acl);
 
 extern struct key *request_key_rcu(struct key_type *type,
 				   const char *description,
@@ -311,21 +308,24 @@ extern struct key *request_key_with_auxdata(struct key_type *type,
 					    struct key_tag *domain_tag,
 					    const void *callout_info,
 					    size_t callout_len,
-					    void *aux);
+					    void *aux,
+					    struct key_acl *acl);
 
 /**
  * request_key - Request a key and wait for construction
  * @type: Type of key.
  * @description: The searchable description of the key.
  * @callout_info: The data to pass to the instantiation upcall (or NULL).
+ * @acl: The ACL to attach to a new key (or NULL).
  *
  * As for request_key_tag(), but with the default global domain tag.
  */
 static inline struct key *request_key(struct key_type *type,
 				      const char *description,
-				      const char *callout_info)
+				      const char *callout_info,
+				      struct key_acl *acl)
 {
-	return request_key_tag(type, description, NULL, callout_info);
+	return request_key_tag(type, description, NULL, callout_info, acl);
 }
 
 #ifdef CONFIG_NET
@@ -335,6 +335,7 @@ static inline struct key *request_key(struct key_type *type,
  * @description: The searchable description of the key.
  * @net: The network namespace that is the key's domain of operation.
  * @callout_info: The data to pass to the instantiation upcall (or NULL).
+ * @acl: The ACL to attach to a new key (or NULL).
  *
  * As for request_key() except that it does not add the returned key to a
  * keyring if found, new keys are always allocated in the user's quota, the
@@ -344,8 +345,8 @@ static inline struct key *request_key(struct key_type *type,
  * Furthermore, it then works as wait_for_key_construction() to wait for the
  * completion of keys undergoing construction with a non-interruptible wait.
  */
-#define request_key_net(type, description, net, callout_info) \
-	request_key_tag(type, description, net->key_domain, callout_info);
+#define request_key_net(type, description, net, callout_info, acl)	\
+	request_key_tag(type, description, net->key_domain, callout_info, acl);
 #endif /* CONFIG_NET */
 
 extern int wait_for_key_construction(struct key *key, bool intr);
@@ -357,7 +358,7 @@ extern key_ref_t key_create_or_update(key_ref_t keyring,
 				      const char *description,
 				      const void *payload,
 				      size_t plen,
-				      key_perm_t perm,
+				      struct key_acl *acl,
 				      unsigned long flags);
 
 extern int key_update(key_ref_t key,
@@ -377,7 +378,7 @@ extern int key_unlink(struct key *keyring,
 
 extern struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,
 				 const struct cred *cred,
-				 key_perm_t perm,
+				 struct key_acl *acl,
 				 unsigned long flags,
 				 struct key_restriction *restrict_link,
 				 struct key *dest);
@@ -410,19 +411,29 @@ static inline key_serial_t key_serial(const struct key *key)
 extern void key_set_timeout(struct key *, unsigned);
 
 extern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,
-				 key_perm_t perm);
+				 u32 desired_perm);
 extern void key_free_user_ns(struct user_namespace *);
 
 /*
  * The permissions required on a key that we're looking up.
  */
-#define	KEY_NEED_VIEW	0x01	/* Require permission to view attributes */
-#define	KEY_NEED_READ	0x02	/* Require permission to read content */
-#define	KEY_NEED_WRITE	0x04	/* Require permission to update / modify */
-#define	KEY_NEED_SEARCH	0x08	/* Require permission to search (keyring) or find (key) */
-#define	KEY_NEED_LINK	0x10	/* Require permission to link */
-#define	KEY_NEED_SETATTR 0x20	/* Require permission to change attributes */
-#define	KEY_NEED_ALL	0x3f	/* All the above permissions */
+#define	KEY_NEED_VIEW	0x001	/* Require permission to view attributes */
+#define	KEY_NEED_READ	0x002	/* Require permission to read content */
+#define	KEY_NEED_WRITE	0x004	/* Require permission to update / modify */
+#define	KEY_NEED_SEARCH	0x008	/* Require permission to search (keyring) or find (key) */
+#define	KEY_NEED_LINK	0x010	/* Require permission to link */
+#define	KEY_NEED_SETSEC	0x020	/* Require permission to set owner, group, ACL */
+#define	KEY_NEED_INVAL	0x040	/* Require permission to invalidate key */
+#define	KEY_NEED_REVOKE	0x080	/* Require permission to revoke key */
+#define	KEY_NEED_JOIN	0x100	/* Require permission to join keyring as session */
+#define	KEY_NEED_CLEAR	0x200	/* Require permission to clear a keyring */
+#define KEY_NEED_ALL	0x3ff
+
+#define OLD_KEY_NEED_SETATTR 0x20 /* Used to be Require permission to change attributes */
+
+extern struct key_acl internal_key_acl;
+extern struct key_acl internal_keyring_acl;
+extern struct key_acl internal_writable_keyring_acl;
 
 static inline short key_read_state(const struct key *key)
 {

commit a58946c158a040068e7c94dc1d58bbd273258068
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 26 21:02:33 2019 +0100

    keys: Pass the network namespace into request_key mechanism
    
    Create a request_key_net() function and use it to pass the network
    namespace domain tag into DNS revolver keys and rxrpc/AFS keys so that keys
    for different domains can coexist in the same keyring.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: netdev@vger.kernel.org
    cc: linux-nfs@vger.kernel.org
    cc: linux-cifs@vger.kernel.org
    cc: linux-afs@lists.infradead.org

diff --git a/include/linux/key.h b/include/linux/key.h
index 60c076c6e47f..18d7f62ab6b0 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -36,6 +36,7 @@ typedef int32_t key_serial_t;
 typedef uint32_t key_perm_t;
 
 struct key;
+struct net;
 
 #ifdef CONFIG_KEYS
 
@@ -296,19 +297,57 @@ static inline void key_ref_put(key_ref_t key_ref)
 	key_put(key_ref_to_ptr(key_ref));
 }
 
-extern struct key *request_key(struct key_type *type,
-			       const char *description,
-			       const char *callout_info);
+extern struct key *request_key_tag(struct key_type *type,
+				   const char *description,
+				   struct key_tag *domain_tag,
+				   const char *callout_info);
 
 extern struct key *request_key_rcu(struct key_type *type,
-				   const char *description);
+				   const char *description,
+				   struct key_tag *domain_tag);
 
 extern struct key *request_key_with_auxdata(struct key_type *type,
 					    const char *description,
+					    struct key_tag *domain_tag,
 					    const void *callout_info,
 					    size_t callout_len,
 					    void *aux);
 
+/**
+ * request_key - Request a key and wait for construction
+ * @type: Type of key.
+ * @description: The searchable description of the key.
+ * @callout_info: The data to pass to the instantiation upcall (or NULL).
+ *
+ * As for request_key_tag(), but with the default global domain tag.
+ */
+static inline struct key *request_key(struct key_type *type,
+				      const char *description,
+				      const char *callout_info)
+{
+	return request_key_tag(type, description, NULL, callout_info);
+}
+
+#ifdef CONFIG_NET
+/*
+ * request_key_net - Request a key for a net namespace and wait for construction
+ * @type: Type of key.
+ * @description: The searchable description of the key.
+ * @net: The network namespace that is the key's domain of operation.
+ * @callout_info: The data to pass to the instantiation upcall (or NULL).
+ *
+ * As for request_key() except that it does not add the returned key to a
+ * keyring if found, new keys are always allocated in the user's quota, the
+ * callout_info must be a NUL-terminated string and no auxiliary data can be
+ * passed.  Only keys that operate the specified network namespace are used.
+ *
+ * Furthermore, it then works as wait_for_key_construction() to wait for the
+ * completion of keys undergoing construction with a non-interruptible wait.
+ */
+#define request_key_net(type, description, net, callout_info) \
+	request_key_tag(type, description, net->key_domain, callout_info);
+#endif /* CONFIG_NET */
+
 extern int wait_for_key_construction(struct key *key, bool intr);
 
 extern int key_validate(const struct key *key);

commit 218e6424e711ceee31eeba93212fed8ee92d6a11
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 26 21:02:32 2019 +0100

    keys: Garbage collect keys for which the domain has been removed
    
    If a key operation domain (such as a network namespace) has been removed
    then attempt to garbage collect all the keys that use it.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index abc68555bac3..60c076c6e47f 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -278,6 +278,7 @@ extern void key_revoke(struct key *key);
 extern void key_invalidate(struct key *key);
 extern void key_put(struct key *key);
 extern bool key_put_tag(struct key_tag *tag);
+extern void key_remove_domain(struct key_tag *domain_tag);
 
 static inline struct key *__key_get(struct key *key)
 {
@@ -446,6 +447,7 @@ extern void key_init(void);
 #define key_fsgid_changed(c)		do { } while(0)
 #define key_init()			do { } while(0)
 #define key_free_user_ns(ns)		do { } while(0)
+#define key_remove_domain(d)		do { } while(0)
 
 #endif /* CONFIG_KEYS */
 #endif /* __KERNEL__ */

commit 3b6e4de05e9ee2e2f94e4a3fe14d945e2418d9a8
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 26 21:02:32 2019 +0100

    keys: Include target namespace in match criteria
    
    Currently a key has a standard matching criteria of { type, description }
    and this is used to only allow keys with unique criteria in a keyring.
    This means, however, that you cannot have keys with the same type and
    description but a different target namespace in the same keyring.
    
    This is a potential problem for a containerised environment where, say, a
    container is made up of some parts of its mount space involving netfs
    superblocks from two different network namespaces.
    
    This is also a problem for shared system management keyrings such as the
    DNS records keyring or the NFS idmapper keyring that might contain keys
    from different network namespaces.
    
    Fix this by including a namespace component in a key's matching criteria.
    Keyring types are marked to indicate which, if any, namespace is relevant
    to keys of that type, and that namespace is set when the key is created
    from the current task's namespace set.
    
    The capability bit KEYCTL_CAPS1_NS_KEY_TAG is set if the kernel is
    employing this feature.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index ae1177302d70..abc68555bac3 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -82,9 +82,16 @@ struct cred;
 
 struct key_type;
 struct key_owner;
+struct key_tag;
 struct keyring_list;
 struct keyring_name;
 
+struct key_tag {
+	struct rcu_head		rcu;
+	refcount_t		usage;
+	bool			removed;	/* T when subject removed */
+};
+
 struct keyring_index_key {
 	/* [!] If this structure is altered, the union in struct key must change too! */
 	unsigned long		hash;			/* Hash value */
@@ -101,6 +108,7 @@ struct keyring_index_key {
 		unsigned long x;
 	};
 	struct key_type		*type;
+	struct key_tag		*domain_tag;	/* Domain of operation */
 	const char		*description;
 };
 
@@ -218,6 +226,7 @@ struct key {
 			unsigned long	hash;
 			unsigned long	len_desc;
 			struct key_type	*type;		/* type of key */
+			struct key_tag	*domain_tag;	/* Domain of operation */
 			char		*description;
 		};
 	};
@@ -268,6 +277,7 @@ extern struct key *key_alloc(struct key_type *type,
 extern void key_revoke(struct key *key);
 extern void key_invalidate(struct key *key);
 extern void key_put(struct key *key);
+extern bool key_put_tag(struct key_tag *tag);
 
 static inline struct key *__key_get(struct key *key)
 {

commit b206f281d0ee14969878469816a69db22d5838e8
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 26 21:02:32 2019 +0100

    keys: Namespace keyring names
    
    Keyring names are held in a single global list that any process can pick
    from by means of keyctl_join_session_keyring (provided the keyring grants
    Search permission).  This isn't very container friendly, however.
    
    Make the following changes:
    
     (1) Make default session, process and thread keyring names begin with a
         '.' instead of '_'.
    
     (2) Keyrings whose names begin with a '.' aren't added to the list.  Such
         keyrings are system specials.
    
     (3) Replace the global list with per-user_namespace lists.  A keyring adds
         its name to the list for the user_namespace that it is currently in.
    
     (4) When a user_namespace is deleted, it just removes itself from the
         keyring name list.
    
    The global keyring_name_lock is retained for accessing the name lists.
    This allows (4) to work.
    
    This can be tested by:
    
            # keyctl newring foo @s
            995906392
            # unshare -U
            $ keyctl show
            ...
             995906392 --alswrv  65534 65534   \_ keyring: foo
            ...
            $ keyctl session foo
            Joined session keyring: 935622349
    
    As can be seen, a new session keyring was created.
    
    The capability bit KEYCTL_CAPS1_NS_KEYRING_NAME is set if the kernel is
    employing this feature.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index ff102731b3db..ae1177302d70 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -361,6 +361,7 @@ extern void key_set_timeout(struct key *, unsigned);
 
 extern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,
 				 key_perm_t perm);
+extern void key_free_user_ns(struct user_namespace *);
 
 /*
  * The permissions required on a key that we're looking up.
@@ -434,6 +435,7 @@ extern void key_init(void);
 #define key_fsuid_changed(c)		do { } while(0)
 #define key_fsgid_changed(c)		do { } while(0)
 #define key_init()			do { } while(0)
+#define key_free_user_ns(ns)		do { } while(0)
 
 #endif /* CONFIG_KEYS */
 #endif /* __KERNEL__ */

commit dcf49dbc8077e278ddd1bc7298abc781496e8a08
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 26 21:02:32 2019 +0100

    keys: Add a 'recurse' flag for keyring searches
    
    Add a 'recurse' flag for keyring searches so that the flag can be omitted
    and recursion disabled, thereby allowing just the nominated keyring to be
    searched and none of the children.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index fb2debcacea0..ff102731b3db 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -341,7 +341,8 @@ extern int keyring_clear(struct key *keyring);
 
 extern key_ref_t keyring_search(key_ref_t keyring,
 				struct key_type *type,
-				const char *description);
+				const char *description,
+				bool recurse);
 
 extern int keyring_add_key(struct key *keyring,
 			   struct key *key);

commit 355ef8e15885020da88f5ba2d85ce42b1d01f537
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 26 21:02:32 2019 +0100

    keys: Cache the hash value to avoid lots of recalculation
    
    Cache the hash of the key's type and description in the index key so that
    we're not recalculating it every time we look at a key during a search.
    The hash function does a bunch of multiplications, so evading those is
    probably worthwhile - especially as this is done for every key examined
    during a search.
    
    This also allows the methods used by assoc_array to get chunks of index-key
    to be simplified.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 86ccc2d010f6..fb2debcacea0 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -86,6 +86,8 @@ struct keyring_list;
 struct keyring_name;
 
 struct keyring_index_key {
+	/* [!] If this structure is altered, the union in struct key must change too! */
+	unsigned long		hash;			/* Hash value */
 	union {
 		struct {
 #ifdef __LITTLE_ENDIAN /* Put desc_len at the LSB of x */
@@ -213,6 +215,7 @@ struct key {
 	union {
 		struct keyring_index_key index_key;
 		struct {
+			unsigned long	hash;
 			unsigned long	len_desc;
 			struct key_type	*type;		/* type of key */
 			char		*description;

commit f771fde82051976a6fc0fd570f8b86de4a92124b
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 26 21:02:31 2019 +0100

    keys: Simplify key description management
    
    Simplify key description management by cramming the word containing the
    length with the first few chars of the description also.  This simplifies
    the code that generates the index-key used by assoc_array.  It should speed
    up key searching a bit too.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 4cd5669184f3..86ccc2d010f6 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -86,9 +86,20 @@ struct keyring_list;
 struct keyring_name;
 
 struct keyring_index_key {
+	union {
+		struct {
+#ifdef __LITTLE_ENDIAN /* Put desc_len at the LSB of x */
+			u8	desc_len;
+			char	desc[sizeof(long) - 1];	/* First few chars of description */
+#else
+			char	desc[sizeof(long) - 1];	/* First few chars of description */
+			u8	desc_len;
+#endif
+		};
+		unsigned long x;
+	};
 	struct key_type		*type;
 	const char		*description;
-	size_t			desc_len;
 };
 
 union key_payload {
@@ -202,6 +213,7 @@ struct key {
 	union {
 		struct keyring_index_key index_key;
 		struct {
+			unsigned long	len_desc;
 			struct key_type	*type;		/* type of key */
 			char		*description;
 		};

commit 3b8c4a08a471d56ecaaca939c972fdf5b8255629
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 19 16:10:16 2019 +0100

    keys: Kill off request_key_async{,_with_auxdata}
    
    Kill off request_key_async{,_with_auxdata}() as they're not currently used.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 3604a554df99..4cd5669184f3 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -283,17 +283,6 @@ extern struct key *request_key_with_auxdata(struct key_type *type,
 					    size_t callout_len,
 					    void *aux);
 
-extern struct key *request_key_async(struct key_type *type,
-				     const char *description,
-				     const void *callout_info,
-				     size_t callout_len);
-
-extern struct key *request_key_async_with_auxdata(struct key_type *type,
-						  const char *description,
-						  const void *callout_info,
-						  size_t callout_len,
-						  void *aux);
-
 extern int wait_for_key_construction(struct key *key, bool intr);
 
 extern int key_validate(const struct key *key);

commit 896f1950e5944532b971d880a6bae7fba3b6a8d3
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 19 16:10:15 2019 +0100

    keys: Provide request_key_rcu()
    
    Provide a request_key_rcu() function that can be used to request a key
    under RCU conditions.  It can only search and check permissions; it cannot
    allocate a new key, upcall or wait for an upcall to complete.  It may
    return a partially constructed key.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 612e1cf84049..3604a554df99 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -274,6 +274,9 @@ extern struct key *request_key(struct key_type *type,
 			       const char *description,
 			       const char *callout_info);
 
+extern struct key *request_key_rcu(struct key_type *type,
+				   const char *description);
+
 extern struct key *request_key_with_auxdata(struct key_type *type,
 					    const char *description,
 					    const void *callout_info,

commit ed0ac5c7ec3763e3261c48e3c5d4b7528b60fd85
Author: David Howells <dhowells@redhat.com>
Date:   Mon May 20 21:51:50 2019 +0100

    keys: Add a keyctl to move a key between keyrings
    
    Add a keyctl to atomically move a link to a key from one keyring to
    another.  The key must exist in "from" keyring and a flag can be given to
    cause the operation to fail if there's a matching key already in the "to"
    keyring.
    
    This can be done with:
    
            keyctl(KEYCTL_MOVE,
                   key_serial_t key,
                   key_serial_t from_keyring,
                   key_serial_t to_keyring,
                   unsigned int flags);
    
    The key being moved must grant Link permission and both keyrings must grant
    Write permission.
    
    flags should be 0 or KEYCTL_MOVE_EXCL, with the latter preventing
    displacement of a matching key from the "to" keyring.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 1f09aad1c98c..612e1cf84049 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -310,6 +310,11 @@ extern int key_update(key_ref_t key,
 extern int key_link(struct key *keyring,
 		    struct key *key);
 
+extern int key_move(struct key *key,
+		    struct key *from_keyring,
+		    struct key *to_keyring,
+		    unsigned int flags);
+
 extern int key_unlink(struct key *keyring,
 		      struct key *key);
 

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 7099985e35a9..1c8b88b455ef 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -1,14 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /* Authentication token and access key management
  *
  * Copyright (C) 2004, 2007 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- *
  * See Documentation/security/keys/core.rst for information on keys/keyrings.
  */
 

commit 2e21865faf4fd7ca99eb2ace072c6d618059e342
Author: David Howells <dhowells@redhat.com>
Date:   Wed May 22 14:06:51 2019 +0100

    keys: sparse: Fix key_fs[ug]id_changed()
    
    Sparse warnings are incurred by key_fs[ug]id_changed() due to unprotected
    accesses of tsk->cred, which is marked __rcu.
    
    Fix this by passing the new cred struct to these functions from
    commit_creds() rather than the task pointer.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: James Morris <jamorris@linux.microsoft.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 7099985e35a9..1f09aad1c98c 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -402,8 +402,8 @@ extern struct ctl_table key_sysctls[];
  * the userspace interface
  */
 extern int install_thread_keyring_to_cred(struct cred *cred);
-extern void key_fsuid_changed(struct task_struct *tsk);
-extern void key_fsgid_changed(struct task_struct *tsk);
+extern void key_fsuid_changed(struct cred *new_cred);
+extern void key_fsgid_changed(struct cred *new_cred);
 extern void key_init(void);
 
 #else /* CONFIG_KEYS */
@@ -418,8 +418,8 @@ extern void key_init(void);
 #define make_key_ref(k, p)		NULL
 #define key_ref_to_ptr(k)		NULL
 #define is_key_possessed(k)		0
-#define key_fsuid_changed(t)		do { } while(0)
-#define key_fsgid_changed(t)		do { } while(0)
+#define key_fsuid_changed(c)		do { } while(0)
+#define key_fsgid_changed(c)		do { } while(0)
 #define key_init()			do { } while(0)
 
 #endif /* CONFIG_KEYS */

commit 76ef5e17252789da79db78341851922af0c16181
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Tue Dec 4 10:31:27 2018 -0800

    keys: Export lookup_user_key to external users
    
    Export lookup_user_key() symbol in order to allow nvdimm passphrase
    update to retrieve user injected keys.
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index e58ee10f6e58..7099985e35a9 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -346,6 +346,9 @@ static inline key_serial_t key_serial(const struct key *key)
 
 extern void key_set_timeout(struct key *, unsigned);
 
+extern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,
+				 key_perm_t perm);
+
 /*
  * The permissions required on a key that we're looking up.
  */

commit 074d58989569b39f04294c90ef36dd82b8c2cc1a
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Wed Nov 15 16:38:45 2017 +0000

    security: keys: Replace time_t/timespec with time64_t
    
    The 'struct key' will use 'time_t' which we try to remove in the
    kernel, since 'time_t' is not year 2038 safe on 32bit systems.
    Also the 'struct keyring_search_context' will use 'timespec' type
    to record current time, which is also not year 2038 safe on 32bit
    systems.
    
    Thus this patch replaces 'time_t' with 'time64_t' which is year 2038
    safe for 'struct key', and replace 'timespec' with 'time64_t' for the
    'struct keyring_search_context', since we only look at the the seconds
    part of 'timespec' variable. Moreover we also change the codes where
    using the 'time_t' and 'timespec', and we can get current time by
    ktime_get_real_seconds() instead of current_kernel_time(), and use
    'TIME64_MAX' macro to initialize the 'time64_t' type variable.
    
    Especially in proc.c file, we have replaced 'unsigned long' and 'timespec'
    type with 'u64' and 'time64_t' type to save the timeout value, which means
    user will get one 'u64' type timeout value by issuing proc_keys_show()
    function.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: James Morris <james.l.morris@oracle.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 8a15cabe928d..e58ee10f6e58 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -24,6 +24,7 @@
 #include <linux/atomic.h>
 #include <linux/assoc_array.h>
 #include <linux/refcount.h>
+#include <linux/time64.h>
 
 #ifdef __KERNEL__
 #include <linux/uidgid.h>
@@ -162,10 +163,10 @@ struct key {
 	struct key_user		*user;		/* owner of this key */
 	void			*security;	/* security data for this key */
 	union {
-		time_t		expiry;		/* time at which key expires (or 0) */
-		time_t		revoked_at;	/* time at which key was revoked */
+		time64_t	expiry;		/* time at which key expires (or 0) */
+		time64_t	revoked_at;	/* time at which key was revoked */
 	};
-	time_t			last_used_at;	/* last time used for LRU keyring discard */
+	time64_t		last_used_at;	/* last time used for LRU keyring discard */
 	kuid_t			uid;
 	kgid_t			gid;
 	key_perm_t		perm;		/* access permissions */

commit 363b02dab09b3226f3bd1420dad9c72b79a42a76
Author: David Howells <dhowells@redhat.com>
Date:   Wed Oct 4 16:43:25 2017 +0100

    KEYS: Fix race between updating and finding a negative key
    
    Consolidate KEY_FLAG_INSTANTIATED, KEY_FLAG_NEGATIVE and the rejection
    error into one field such that:
    
     (1) The instantiation state can be modified/read atomically.
    
     (2) The error can be accessed atomically with the state.
    
     (3) The error isn't stored unioned with the payload pointers.
    
    This deals with the problem that the state is spread over three different
    objects (two bits and a separate variable) and reading or updating them
    atomically isn't practical, given that not only can uninstantiated keys
    change into instantiated or rejected keys, but rejected keys can also turn
    into instantiated keys - and someone accessing the key might not be using
    any locking.
    
    The main side effect of this problem is that what was held in the payload
    may change, depending on the state.  For instance, you might observe the
    key to be in the rejected state.  You then read the cached error, but if
    the key semaphore wasn't locked, the key might've become instantiated
    between the two reads - and you might now have something in hand that isn't
    actually an error code.
    
    The state is now KEY_IS_UNINSTANTIATED, KEY_IS_POSITIVE or a negative error
    code if the key is negatively instantiated.  The key_is_instantiated()
    function is replaced with key_is_positive() to avoid confusion as negative
    keys are also 'instantiated'.
    
    Additionally, barriering is included:
    
     (1) Order payload-set before state-set during instantiation.
    
     (2) Order state-read before payload-read when using the key.
    
    Further separate barriering is necessary if RCU is being used to access the
    payload content after reading the payload pointers.
    
    Fixes: 146aa8b1453b ("KEYS: Merge the type-specific data with the payload data")
    Cc: stable@vger.kernel.org # v4.4+
    Reported-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Eric Biggers <ebiggers@google.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index e315e16b6ff8..8a15cabe928d 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -138,6 +138,11 @@ struct key_restriction {
 	struct key_type *keytype;
 };
 
+enum key_state {
+	KEY_IS_UNINSTANTIATED,
+	KEY_IS_POSITIVE,		/* Positively instantiated */
+};
+
 /*****************************************************************************/
 /*
  * authentication token / access credential / keyring
@@ -169,6 +174,7 @@ struct key {
 						 * - may not match RCU dereferenced payload
 						 * - payload should contain own length
 						 */
+	short			state;		/* Key state (+) or rejection error (-) */
 
 #ifdef KEY_DEBUGGING
 	unsigned		magic;
@@ -176,18 +182,16 @@ struct key {
 #endif
 
 	unsigned long		flags;		/* status flags (change with bitops) */
-#define KEY_FLAG_INSTANTIATED	0	/* set if key has been instantiated */
-#define KEY_FLAG_DEAD		1	/* set if key type has been deleted */
-#define KEY_FLAG_REVOKED	2	/* set if key had been revoked */
-#define KEY_FLAG_IN_QUOTA	3	/* set if key consumes quota */
-#define KEY_FLAG_USER_CONSTRUCT	4	/* set if key is being constructed in userspace */
-#define KEY_FLAG_NEGATIVE	5	/* set if key is negative */
-#define KEY_FLAG_ROOT_CAN_CLEAR	6	/* set if key can be cleared by root without permission */
-#define KEY_FLAG_INVALIDATED	7	/* set if key has been invalidated */
-#define KEY_FLAG_BUILTIN	8	/* set if key is built in to the kernel */
-#define KEY_FLAG_ROOT_CAN_INVAL	9	/* set if key can be invalidated by root without permission */
-#define KEY_FLAG_KEEP		10	/* set if key should not be removed */
-#define KEY_FLAG_UID_KEYRING	11	/* set if key is a user or user session keyring */
+#define KEY_FLAG_DEAD		0	/* set if key type has been deleted */
+#define KEY_FLAG_REVOKED	1	/* set if key had been revoked */
+#define KEY_FLAG_IN_QUOTA	2	/* set if key consumes quota */
+#define KEY_FLAG_USER_CONSTRUCT	3	/* set if key is being constructed in userspace */
+#define KEY_FLAG_ROOT_CAN_CLEAR	4	/* set if key can be cleared by root without permission */
+#define KEY_FLAG_INVALIDATED	5	/* set if key has been invalidated */
+#define KEY_FLAG_BUILTIN	6	/* set if key is built in to the kernel */
+#define KEY_FLAG_ROOT_CAN_INVAL	7	/* set if key can be invalidated by root without permission */
+#define KEY_FLAG_KEEP		8	/* set if key should not be removed */
+#define KEY_FLAG_UID_KEYRING	9	/* set if key is a user or user session keyring */
 
 	/* the key type and key description string
 	 * - the desc is used to match a key against search criteria
@@ -213,7 +217,6 @@ struct key {
 			struct list_head name_link;
 			struct assoc_array keys;
 		};
-		int reject_error;
 	};
 
 	/* This is set on a keyring to restrict the addition of a link to a key
@@ -353,17 +356,27 @@ extern void key_set_timeout(struct key *, unsigned);
 #define	KEY_NEED_SETATTR 0x20	/* Require permission to change attributes */
 #define	KEY_NEED_ALL	0x3f	/* All the above permissions */
 
+static inline short key_read_state(const struct key *key)
+{
+	/* Barrier versus mark_key_instantiated(). */
+	return smp_load_acquire(&key->state);
+}
+
 /**
- * key_is_instantiated - Determine if a key has been positively instantiated
+ * key_is_positive - Determine if a key has been positively instantiated
  * @key: The key to check.
  *
  * Return true if the specified key has been positively instantiated, false
  * otherwise.
  */
-static inline bool key_is_instantiated(const struct key *key)
+static inline bool key_is_positive(const struct key *key)
+{
+	return key_read_state(key) == KEY_IS_POSITIVE;
+}
+
+static inline bool key_is_negative(const struct key *key)
 {
-	return test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&
-		!test_bit(KEY_FLAG_NEGATIVE, &key->flags);
+	return key_read_state(key) < 0;
 }
 
 #define dereference_key_rcu(KEY)					\

commit 237bbd29f7a049d310d907f4b2716a7feef9abf3
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Sep 18 11:37:03 2017 -0700

    KEYS: prevent creating a different user's keyrings
    
    It was possible for an unprivileged user to create the user and user
    session keyrings for another user.  For example:
    
        sudo -u '#3000' sh -c 'keyctl add keyring _uid.4000 "" @u
                               keyctl add keyring _uid_ses.4000 "" @u
                               sleep 15' &
        sleep 1
        sudo -u '#4000' keyctl describe @u
        sudo -u '#4000' keyctl describe @us
    
    This is problematic because these "fake" keyrings won't have the right
    permissions.  In particular, the user who created them first will own
    them and will have full access to them via the possessor permissions,
    which can be used to compromise the security of a user's keys:
    
        -4: alswrv-----v------------  3000     0 keyring: _uid.4000
        -5: alswrv-----v------------  3000     0 keyring: _uid_ses.4000
    
    Fix it by marking user and user session keyrings with a flag
    KEY_FLAG_UID_KEYRING.  Then, when searching for a user or user session
    keyring by name, skip all keyrings that don't have the flag set.
    
    Fixes: 69664cf16af4 ("keys: don't generate user and user session keyrings unless they're accessed")
    Cc: <stable@vger.kernel.org>    [v2.6.26+]
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 044114185120..e315e16b6ff8 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -187,6 +187,7 @@ struct key {
 #define KEY_FLAG_BUILTIN	8	/* set if key is built in to the kernel */
 #define KEY_FLAG_ROOT_CAN_INVAL	9	/* set if key can be invalidated by root without permission */
 #define KEY_FLAG_KEEP		10	/* set if key should not be removed */
+#define KEY_FLAG_UID_KEYRING	11	/* set if key is a user or user session keyring */
 
 	/* the key type and key description string
 	 * - the desc is used to match a key against search criteria
@@ -243,6 +244,7 @@ extern struct key *key_alloc(struct key_type *type,
 #define KEY_ALLOC_NOT_IN_QUOTA		0x0002	/* not in quota */
 #define KEY_ALLOC_BUILT_IN		0x0004	/* Key is built into kernel */
 #define KEY_ALLOC_BYPASS_RESTRICTION	0x0008	/* Override the check on restricted keyrings */
+#define KEY_ALLOC_UID_KEYRING		0x0010	/* allocating a user or user session keyring */
 
 extern void key_revoke(struct key *key);
 extern void key_invalidate(struct key *key);

commit 650fc870a2ef35b83397eebd35b8c8df211bff78
Merge: f4dd029ee0b9 1cb566ba5634
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 3 21:13:25 2017 -0700

    Merge tag 'docs-4.13' of git://git.lwn.net/linux
    
    Pull documentation updates from Jonathan Corbet:
     "There has been a fair amount of activity in the docs tree this time
      around. Highlights include:
    
       - Conversion of a bunch of security documentation into RST
    
       - The conversion of the remaining DocBook templates by The Amazing
         Mauro Machine. We can now drop the entire DocBook build chain.
    
       - The usual collection of fixes and minor updates"
    
    * tag 'docs-4.13' of git://git.lwn.net/linux: (90 commits)
      scripts/kernel-doc: handle DECLARE_HASHTABLE
      Documentation: atomic_ops.txt is core-api/atomic_ops.rst
      Docs: clean up some DocBook loose ends
      Make the main documentation title less Geocities
      Docs: Use kernel-figure in vidioc-g-selection.rst
      Docs: fix table problems in ras.rst
      Docs: Fix breakage with Sphinx 1.5 and upper
      Docs: Include the Latex "ifthen" package
      doc/kokr/howto: Only send regression fixes after -rc1
      docs-rst: fix broken links to dynamic-debug-howto in kernel-parameters
      doc: Document suitability of IBM Verse for kernel development
      Doc: fix a markup error in coding-style.rst
      docs: driver-api: i2c: remove some outdated information
      Documentation: DMA API: fix a typo in a function name
      Docs: Insert missing space to separate link from text
      doc/ko_KR/memory-barriers: Update control-dependencies example
      Documentation, kbuild: fix typo "minimun" -> "minimum"
      docs: Fix some formatting issues in request-key.rst
      doc: ReSTify keys-trusted-encrypted.txt
      doc: ReSTify keys-request-key.txt
      ...

commit 0620fddb56dfaf0e1034eeb69d79c73b361debbf
Author: Eric Biggers <ebiggers@google.com>
Date:   Thu Jun 8 14:49:26 2017 +0100

    KEYS: sanitize key structs before freeing
    
    While a 'struct key' itself normally does not contain sensitive
    information, Documentation/security/keys.txt actually encourages this:
    
         "Having a payload is not required; and the payload can, in fact,
         just be a value stored in the struct key itself."
    
    In case someone has taken this advice, or will take this advice in the
    future, zero the key structure before freeing it.  We might as well, and
    as a bonus this could make it a bit more difficult for an adversary to
    determine which keys have recently been in use.
    
    This is safe because the key_jar cache does not use a constructor.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 0c9b93b0d1f7..78e25aabedaf 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -173,7 +173,6 @@ struct key {
 #ifdef KEY_DEBUGGING
 	unsigned		magic;
 #define KEY_DEBUG_MAGIC		0x18273645u
-#define KEY_DEBUG_MAGIC_X	0xf8e9dacbu
 #endif
 
 	unsigned long		flags;		/* status flags (change with bitops) */

commit b68101a1e8f0263dbc7b8375d2a7c57c6216fb76
Author: Kees Cook <keescook@chromium.org>
Date:   Sat May 13 04:51:50 2017 -0700

    doc: ReSTify keys.txt
    
    This creates a new section in the security development index for kernel
    keys, and adjusts for ReST markup.
    
    Cc: David Howells <dhowells@redhat.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/include/linux/key.h b/include/linux/key.h
index 0c9b93b0d1f7..24dfe6c1f8cb 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -9,7 +9,7 @@
  * 2 of the License, or (at your option) any later version.
  *
  *
- * See Documentation/security/keys.txt for information on keys/keyrings.
+ * See Documentation/security/keys/core.rst for information on keys/keyrings.
  */
 
 #ifndef _LINUX_KEY_H

commit 6563c91fd645556c7801748f15bc727c77fcd311
Author: Mat Martineau <mathew.j.martineau@linux.intel.com>
Date:   Wed Mar 1 16:44:09 2017 -0800

    KEYS: Add KEYCTL_RESTRICT_KEYRING
    
    Keyrings recently gained restrict_link capabilities that allow
    individual keys to be validated prior to linking.  This functionality
    was only available using internal kernel APIs.
    
    With the KEYCTL_RESTRICT_KEYRING command existing keyrings can be
    configured to check the content of keys before they are linked, and
    then allow or disallow linkage of that key to the keyring.
    
    To restrict a keyring, call:
    
      keyctl(KEYCTL_RESTRICT_KEYRING, key_serial_t keyring, const char *type,
             const char *restriction)
    
    where 'type' is the name of a registered key type and 'restriction' is a
    string describing how key linkage is to be restricted. The restriction
    option syntax is specific to each key type.
    
    Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index d2916363689c..0c9b93b0d1f7 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -219,7 +219,8 @@ struct key {
 	/* This is set on a keyring to restrict the addition of a link to a key
 	 * to it.  If this structure isn't provided then it is assumed that the
 	 * keyring is open to any addition.  It is ignored for non-keyring
-	 * keys.
+	 * keys. Only set this value using keyring_restrict(), keyring_alloc(),
+	 * or key_alloc().
 	 *
 	 * This is intended for use with rings of trusted keys whereby addition
 	 * to the keyring needs to be controlled.  KEY_ALLOC_BYPASS_RESTRICTION
@@ -328,6 +329,9 @@ extern key_ref_t keyring_search(key_ref_t keyring,
 extern int keyring_add_key(struct key *keyring,
 			   struct key *key);
 
+extern int keyring_restrict(key_ref_t keyring, const char *type,
+			    const char *restriction);
+
 extern struct key *key_lookup(key_serial_t id);
 
 static inline key_serial_t key_serial(const struct key *key)

commit 2b6aa412ff23a02ac777ad307249c60a839cfd25
Author: Mat Martineau <mathew.j.martineau@linux.intel.com>
Date:   Wed Aug 31 16:05:43 2016 -0700

    KEYS: Use structure to capture key restriction function and data
    
    Replace struct key's restrict_link function pointer with a pointer to
    the new struct key_restriction. The structure contains pointers to the
    restriction function as well as relevant data for evaluating the
    restriction.
    
    The garbage collector checks restrict_link->keytype when key types are
    unregistered. Restrictions involving a removed key type are converted
    to use restrict_link_reject so that restrictions cannot be removed by
    unregistering key types.
    
    Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index a06649f3223d..d2916363689c 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -217,7 +217,7 @@ struct key {
 	};
 
 	/* This is set on a keyring to restrict the addition of a link to a key
-	 * to it.  If this method isn't provided then it is assumed that the
+	 * to it.  If this structure isn't provided then it is assumed that the
 	 * keyring is open to any addition.  It is ignored for non-keyring
 	 * keys.
 	 *
@@ -226,7 +226,7 @@ struct key {
 	 * overrides this, allowing the kernel to add extra keys without
 	 * restriction.
 	 */
-	key_restrict_link_func_t restrict_link;
+	struct key_restriction *restrict_link;
 };
 
 extern struct key *key_alloc(struct key_type *type,
@@ -235,7 +235,7 @@ extern struct key *key_alloc(struct key_type *type,
 			     const struct cred *cred,
 			     key_perm_t perm,
 			     unsigned long flags,
-			     key_restrict_link_func_t restrict_link);
+			     struct key_restriction *restrict_link);
 
 
 #define KEY_ALLOC_IN_QUOTA		0x0000	/* add to quota, reject if would overrun */
@@ -311,7 +311,7 @@ extern struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid
 				 const struct cred *cred,
 				 key_perm_t perm,
 				 unsigned long flags,
-				 key_restrict_link_func_t restrict_link,
+				 struct key_restriction *restrict_link,
 				 struct key *dest);
 
 extern int restrict_link_reject(struct key *keyring,

commit e9cc0f689a7c0c9be6fed6861b3a3f49ad0e7a52
Author: Mat Martineau <mathew.j.martineau@linux.intel.com>
Date:   Mon Jun 27 16:10:59 2016 -0700

    KEYS: Add a key restriction struct
    
    Key link restrictions require restriction-specific data as well as a
    restriction-specific function pointer. As a first step toward replacing
    the restrict_link pointer in struct key, define a more general
    key_restriction structure that captures the required function, key, and
    key type pointers. Key type modules should not be pinned on account of
    this key type pointer because the pointer will be cleared by the garbage
    collector if the key type is unregistered.
    
    Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index c59d1008c4fc..a06649f3223d 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -132,6 +132,12 @@ typedef int (*key_restrict_link_func_t)(struct key *dest_keyring,
 					const union key_payload *payload,
 					struct key *restriction_key);
 
+struct key_restriction {
+	key_restrict_link_func_t check;
+	struct key *key;
+	struct key_type *keytype;
+};
+
 /*****************************************************************************/
 /*
  * authentication token / access credential / keyring

commit aaf66c883813f0078e3dafe7d20d1461321ac14f
Author: Mat Martineau <mathew.j.martineau@linux.intel.com>
Date:   Tue Aug 30 11:33:13 2016 -0700

    KEYS: Split role of the keyring pointer for keyring restrict functions
    
    The first argument to the restrict_link_func_t functions was a keyring
    pointer. These functions are called by the key subsystem with this
    argument set to the destination keyring, but restrict_link_by_signature
    expects a pointer to the relevant trusted keyring.
    
    Restrict functions may need something other than a single struct key
    pointer to allow or reject key linkage, so the data used to make that
    decision (such as the trust keyring) is moved to a new, fourth
    argument. The first argument is now always the destination keyring.
    
    Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 3bb327043869..c59d1008c4fc 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -127,9 +127,10 @@ static inline bool is_key_possessed(const key_ref_t key_ref)
 	return (unsigned long) key_ref & 1UL;
 }
 
-typedef int (*key_restrict_link_func_t)(struct key *keyring,
+typedef int (*key_restrict_link_func_t)(struct key *dest_keyring,
 					const struct key_type *type,
-					const union key_payload *payload);
+					const union key_payload *payload,
+					struct key *restriction_key);
 
 /*****************************************************************************/
 /*
@@ -309,7 +310,8 @@ extern struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid
 
 extern int restrict_link_reject(struct key *keyring,
 				const struct key_type *type,
-				const union key_payload *payload);
+				const union key_payload *payload,
+				struct key *restriction_key);
 
 extern int keyring_clear(struct key *keyring);
 

commit 469ff8f7d46d75b36de68a0411a2ce80109ad00b
Author: Mat Martineau <mathew.j.martineau@linux.intel.com>
Date:   Mon Apr 25 11:30:39 2016 -0700

    KEYS: Use a typedef for restrict_link function pointers
    
    This pointer type needs to be returned from a lookup function, and
    without a typedef the syntax gets cumbersome.
    
    Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 9d9fac583dd3..3bb327043869 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -127,6 +127,10 @@ static inline bool is_key_possessed(const key_ref_t key_ref)
 	return (unsigned long) key_ref & 1UL;
 }
 
+typedef int (*key_restrict_link_func_t)(struct key *keyring,
+					const struct key_type *type,
+					const union key_payload *payload);
+
 /*****************************************************************************/
 /*
  * authentication token / access credential / keyring
@@ -215,9 +219,7 @@ struct key {
 	 * overrides this, allowing the kernel to add extra keys without
 	 * restriction.
 	 */
-	int (*restrict_link)(struct key *keyring,
-			     const struct key_type *type,
-			     const union key_payload *payload);
+	key_restrict_link_func_t restrict_link;
 };
 
 extern struct key *key_alloc(struct key_type *type,
@@ -226,9 +228,7 @@ extern struct key *key_alloc(struct key_type *type,
 			     const struct cred *cred,
 			     key_perm_t perm,
 			     unsigned long flags,
-			     int (*restrict_link)(struct key *,
-						  const struct key_type *,
-						  const union key_payload *));
+			     key_restrict_link_func_t restrict_link);
 
 
 #define KEY_ALLOC_IN_QUOTA		0x0000	/* add to quota, reject if would overrun */
@@ -304,9 +304,7 @@ extern struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid
 				 const struct cred *cred,
 				 key_perm_t perm,
 				 unsigned long flags,
-				 int (*restrict_link)(struct key *,
-						      const struct key_type *,
-						      const union key_payload *),
+				 key_restrict_link_func_t restrict_link,
 				 struct key *dest);
 
 extern int restrict_link_reject(struct key *keyring,

commit fff292914d3a2f1efd05ca71c2ba72a3c663201e
Author: Elena Reshetova <elena.reshetova@intel.com>
Date:   Fri Mar 31 15:20:48 2017 +0300

    security, keys: convert key.usage from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index e45212f2777e..9d9fac583dd3 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -23,6 +23,7 @@
 #include <linux/rwsem.h>
 #include <linux/atomic.h>
 #include <linux/assoc_array.h>
+#include <linux/refcount.h>
 
 #ifdef __KERNEL__
 #include <linux/uidgid.h>
@@ -135,7 +136,7 @@ static inline bool is_key_possessed(const key_ref_t key_ref)
  *   - Kerberos TGTs and tickets
  */
 struct key {
-	atomic_t		usage;		/* number of references */
+	refcount_t		usage;		/* number of references */
 	key_serial_t		serial;		/* key serial number */
 	union {
 		struct list_head graveyard_link;
@@ -242,7 +243,7 @@ extern void key_put(struct key *key);
 
 static inline struct key *__key_get(struct key *key)
 {
-	atomic_inc(&key->usage);
+	refcount_inc(&key->usage);
 	return key;
 }
 

commit 0837e49ab3fa8d903a499984575d71efee8097ce
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 1 15:11:23 2017 +0000

    KEYS: Differentiate uses of rcu_dereference_key() and user_key_payload()
    
    rcu_dereference_key() and user_key_payload() are currently being used in
    two different, incompatible ways:
    
     (1) As a wrapper to rcu_dereference() - when only the RCU read lock used
         to protect the key.
    
     (2) As a wrapper to rcu_dereference_protected() - when the key semaphor is
         used to protect the key and the may be being modified.
    
    Fix this by splitting both of the key wrappers to produce:
    
     (1) RCU accessors for keys when caller has the key semaphore locked:
    
            dereference_key_locked()
            user_key_payload_locked()
    
     (2) RCU accessors for keys when caller holds the RCU read lock:
    
            dereference_key_rcu()
            user_key_payload_rcu()
    
    This should fix following warning in the NFS idmapper
    
      ===============================
      [ INFO: suspicious RCU usage. ]
      4.10.0 #1 Tainted: G        W
      -------------------------------
      ./include/keys/user-type.h:53 suspicious rcu_dereference_protected() usage!
      other info that might help us debug this:
      rcu_scheduler_active = 2, debug_locks = 0
      1 lock held by mount.nfs/5987:
        #0:  (rcu_read_lock){......}, at: [<d000000002527abc>] nfs_idmap_get_key+0x15c/0x420 [nfsv4]
      stack backtrace:
      CPU: 1 PID: 5987 Comm: mount.nfs Tainted: G        W       4.10.0 #1
      Call Trace:
        dump_stack+0xe8/0x154 (unreliable)
        lockdep_rcu_suspicious+0x140/0x190
        nfs_idmap_get_key+0x380/0x420 [nfsv4]
        nfs_map_name_to_uid+0x2a0/0x3b0 [nfsv4]
        decode_getfattr_attrs+0xfac/0x16b0 [nfsv4]
        decode_getfattr_generic.constprop.106+0xbc/0x150 [nfsv4]
        nfs4_xdr_dec_lookup_root+0xac/0xb0 [nfsv4]
        rpcauth_unwrap_resp+0xe8/0x140 [sunrpc]
        call_decode+0x29c/0x910 [sunrpc]
        __rpc_execute+0x140/0x8f0 [sunrpc]
        rpc_run_task+0x170/0x200 [sunrpc]
        nfs4_call_sync_sequence+0x68/0xa0 [nfsv4]
        _nfs4_lookup_root.isra.44+0xd0/0xf0 [nfsv4]
        nfs4_lookup_root+0xe0/0x350 [nfsv4]
        nfs4_lookup_root_sec+0x70/0xa0 [nfsv4]
        nfs4_find_root_sec+0xc4/0x100 [nfsv4]
        nfs4_proc_get_rootfh+0x5c/0xf0 [nfsv4]
        nfs4_get_rootfh+0x6c/0x190 [nfsv4]
        nfs4_server_common_setup+0xc4/0x260 [nfsv4]
        nfs4_create_server+0x278/0x3c0 [nfsv4]
        nfs4_remote_mount+0x50/0xb0 [nfsv4]
        mount_fs+0x74/0x210
        vfs_kern_mount+0x78/0x220
        nfs_do_root_mount+0xb0/0x140 [nfsv4]
        nfs4_try_mount+0x60/0x100 [nfsv4]
        nfs_fs_mount+0x5ec/0xda0 [nfs]
        mount_fs+0x74/0x210
        vfs_kern_mount+0x78/0x220
        do_mount+0x254/0xf70
        SyS_mount+0x94/0x100
        system_call+0x38/0xe0
    
    Reported-by: Jan Stancek <jstancek@redhat.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Jan Stancek <jstancek@redhat.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 722914798f37..e45212f2777e 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -354,7 +354,10 @@ static inline bool key_is_instantiated(const struct key *key)
 		!test_bit(KEY_FLAG_NEGATIVE, &key->flags);
 }
 
-#define rcu_dereference_key(KEY)					\
+#define dereference_key_rcu(KEY)					\
+	(rcu_dereference((KEY)->payload.rcu_data0))
+
+#define dereference_key_locked(KEY)					\
 	(rcu_dereference_protected((KEY)->payload.rcu_data0,		\
 				   rwsem_is_locked(&((struct key *)(KEY))->sem)))
 

commit 77f68bac9481ad440f4f34dda3d28c2dce6eb87b
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:14:26 2016 +0100

    KEYS: Remove KEY_FLAG_TRUSTED and KEY_ALLOC_TRUSTED
    
    Remove KEY_FLAG_TRUSTED and KEY_ALLOC_TRUSTED as they're no longer
    meaningful.  Also we can drop the trusted flag from the preparse structure.
    
    Given this, we no longer need to pass the key flags through to
    restrict_link().
    
    Further, we can now get rid of keyring_restrict_trusted_only() also.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 83b603639d2e..722914798f37 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -173,10 +173,9 @@ struct key {
 #define KEY_FLAG_NEGATIVE	5	/* set if key is negative */
 #define KEY_FLAG_ROOT_CAN_CLEAR	6	/* set if key can be cleared by root without permission */
 #define KEY_FLAG_INVALIDATED	7	/* set if key has been invalidated */
-#define KEY_FLAG_TRUSTED	8	/* set if key is trusted */
-#define KEY_FLAG_BUILTIN	9	/* set if key is built in to the kernel */
-#define KEY_FLAG_ROOT_CAN_INVAL	10	/* set if key can be invalidated by root without permission */
-#define KEY_FLAG_KEEP		11	/* set if key should not be removed */
+#define KEY_FLAG_BUILTIN	8	/* set if key is built in to the kernel */
+#define KEY_FLAG_ROOT_CAN_INVAL	9	/* set if key can be invalidated by root without permission */
+#define KEY_FLAG_KEEP		10	/* set if key should not be removed */
 
 	/* the key type and key description string
 	 * - the desc is used to match a key against search criteria
@@ -217,7 +216,6 @@ struct key {
 	 */
 	int (*restrict_link)(struct key *keyring,
 			     const struct key_type *type,
-			     unsigned long flags,
 			     const union key_payload *payload);
 };
 
@@ -229,16 +227,14 @@ extern struct key *key_alloc(struct key_type *type,
 			     unsigned long flags,
 			     int (*restrict_link)(struct key *,
 						  const struct key_type *,
-						  unsigned long,
 						  const union key_payload *));
 
 
 #define KEY_ALLOC_IN_QUOTA		0x0000	/* add to quota, reject if would overrun */
 #define KEY_ALLOC_QUOTA_OVERRUN		0x0001	/* add to quota, permit even if overrun */
 #define KEY_ALLOC_NOT_IN_QUOTA		0x0002	/* not in quota */
-#define KEY_ALLOC_TRUSTED		0x0004	/* Key should be flagged as trusted */
-#define KEY_ALLOC_BUILT_IN		0x0008	/* Key is built into kernel */
-#define KEY_ALLOC_BYPASS_RESTRICTION	0x0010	/* Override the check on restricted keyrings */
+#define KEY_ALLOC_BUILT_IN		0x0004	/* Key is built into kernel */
+#define KEY_ALLOC_BYPASS_RESTRICTION	0x0008	/* Override the check on restricted keyrings */
 
 extern void key_revoke(struct key *key);
 extern void key_invalidate(struct key *key);
@@ -309,18 +305,11 @@ extern struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid
 				 unsigned long flags,
 				 int (*restrict_link)(struct key *,
 						      const struct key_type *,
-						      unsigned long,
 						      const union key_payload *),
 				 struct key *dest);
 
-extern int keyring_restrict_trusted_only(struct key *keyring,
-					 const struct key_type *type,
-					 unsigned long,
-					 const union key_payload *payload);
-
 extern int restrict_link_reject(struct key *keyring,
 				const struct key_type *type,
-				unsigned long flags,
 				const union key_payload *payload);
 
 extern int keyring_clear(struct key *keyring);

commit 5ac7eace2d00eab5ae0e9fdee63e38aee6001f7c
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:14:24 2016 +0100

    KEYS: Add a facility to restrict new links into a keyring
    
    Add a facility whereby proposed new links to be added to a keyring can be
    vetted, permitting them to be rejected if necessary.  This can be used to
    block public keys from which the signature cannot be verified or for which
    the signature verification fails.  It could also be used to provide
    blacklisting.
    
    This affects operations like add_key(), KEYCTL_LINK and KEYCTL_INSTANTIATE.
    
    To this end:
    
     (1) A function pointer is added to the key struct that, if set, points to
         the vetting function.  This is called as:
    
            int (*restrict_link)(struct key *keyring,
                                 const struct key_type *key_type,
                                 unsigned long key_flags,
                                 const union key_payload *key_payload),
    
         where 'keyring' will be the keyring being added to, key_type and
         key_payload will describe the key being added and key_flags[*] can be
         AND'ed with KEY_FLAG_TRUSTED.
    
         [*] This parameter will be removed in a later patch when
             KEY_FLAG_TRUSTED is removed.
    
         The function should return 0 to allow the link to take place or an
         error (typically -ENOKEY, -ENOPKG or -EKEYREJECTED) to reject the
         link.
    
         The pointer should not be set directly, but rather should be set
         through keyring_alloc().
    
         Note that if called during add_key(), preparse is called before this
         method, but a key isn't actually allocated until after this function
         is called.
    
     (2) KEY_ALLOC_BYPASS_RESTRICTION is added.  This can be passed to
         key_create_or_update() or key_instantiate_and_link() to bypass the
         restriction check.
    
     (3) KEY_FLAG_TRUSTED_ONLY is removed.  The entire contents of a keyring
         with this restriction emplaced can be considered 'trustworthy' by
         virtue of being in the keyring when that keyring is consulted.
    
     (4) key_alloc() and keyring_alloc() take an extra argument that will be
         used to set restrict_link in the new key.  This ensures that the
         pointer is set before the key is published, thus preventing a window
         of unrestrictedness.  Normally this argument will be NULL.
    
     (5) As a temporary affair, keyring_restrict_trusted_only() is added.  It
         should be passed to keyring_alloc() as the extra argument instead of
         setting KEY_FLAG_TRUSTED_ONLY on a keyring.  This will be replaced in
         a later patch with functions that look in the appropriate places for
         authoritative keys.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 5f5b1129dc92..83b603639d2e 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -174,10 +174,9 @@ struct key {
 #define KEY_FLAG_ROOT_CAN_CLEAR	6	/* set if key can be cleared by root without permission */
 #define KEY_FLAG_INVALIDATED	7	/* set if key has been invalidated */
 #define KEY_FLAG_TRUSTED	8	/* set if key is trusted */
-#define KEY_FLAG_TRUSTED_ONLY	9	/* set if keyring only accepts links to trusted keys */
-#define KEY_FLAG_BUILTIN	10	/* set if key is builtin */
-#define KEY_FLAG_ROOT_CAN_INVAL	11	/* set if key can be invalidated by root without permission */
-#define KEY_FLAG_KEEP		12	/* set if key should not be removed */
+#define KEY_FLAG_BUILTIN	9	/* set if key is built in to the kernel */
+#define KEY_FLAG_ROOT_CAN_INVAL	10	/* set if key can be invalidated by root without permission */
+#define KEY_FLAG_KEEP		11	/* set if key should not be removed */
 
 	/* the key type and key description string
 	 * - the desc is used to match a key against search criteria
@@ -205,6 +204,21 @@ struct key {
 		};
 		int reject_error;
 	};
+
+	/* This is set on a keyring to restrict the addition of a link to a key
+	 * to it.  If this method isn't provided then it is assumed that the
+	 * keyring is open to any addition.  It is ignored for non-keyring
+	 * keys.
+	 *
+	 * This is intended for use with rings of trusted keys whereby addition
+	 * to the keyring needs to be controlled.  KEY_ALLOC_BYPASS_RESTRICTION
+	 * overrides this, allowing the kernel to add extra keys without
+	 * restriction.
+	 */
+	int (*restrict_link)(struct key *keyring,
+			     const struct key_type *type,
+			     unsigned long flags,
+			     const union key_payload *payload);
 };
 
 extern struct key *key_alloc(struct key_type *type,
@@ -212,14 +226,19 @@ extern struct key *key_alloc(struct key_type *type,
 			     kuid_t uid, kgid_t gid,
 			     const struct cred *cred,
 			     key_perm_t perm,
-			     unsigned long flags);
+			     unsigned long flags,
+			     int (*restrict_link)(struct key *,
+						  const struct key_type *,
+						  unsigned long,
+						  const union key_payload *));
 
 
-#define KEY_ALLOC_IN_QUOTA	0x0000	/* add to quota, reject if would overrun */
-#define KEY_ALLOC_QUOTA_OVERRUN	0x0001	/* add to quota, permit even if overrun */
-#define KEY_ALLOC_NOT_IN_QUOTA	0x0002	/* not in quota */
-#define KEY_ALLOC_TRUSTED	0x0004	/* Key should be flagged as trusted */
-#define KEY_ALLOC_BUILT_IN	0x0008	/* Key is built into kernel */
+#define KEY_ALLOC_IN_QUOTA		0x0000	/* add to quota, reject if would overrun */
+#define KEY_ALLOC_QUOTA_OVERRUN		0x0001	/* add to quota, permit even if overrun */
+#define KEY_ALLOC_NOT_IN_QUOTA		0x0002	/* not in quota */
+#define KEY_ALLOC_TRUSTED		0x0004	/* Key should be flagged as trusted */
+#define KEY_ALLOC_BUILT_IN		0x0008	/* Key is built into kernel */
+#define KEY_ALLOC_BYPASS_RESTRICTION	0x0010	/* Override the check on restricted keyrings */
 
 extern void key_revoke(struct key *key);
 extern void key_invalidate(struct key *key);
@@ -288,8 +307,22 @@ extern struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid
 				 const struct cred *cred,
 				 key_perm_t perm,
 				 unsigned long flags,
+				 int (*restrict_link)(struct key *,
+						      const struct key_type *,
+						      unsigned long,
+						      const union key_payload *),
 				 struct key *dest);
 
+extern int keyring_restrict_trusted_only(struct key *keyring,
+					 const struct key_type *type,
+					 unsigned long,
+					 const union key_payload *payload);
+
+extern int restrict_link_reject(struct key *keyring,
+				const struct key_type *type,
+				unsigned long flags,
+				const union key_payload *payload);
+
 extern int keyring_clear(struct key *keyring);
 
 extern key_ref_t keyring_search(key_ref_t keyring,

commit 5d2787cf0b210d2925e8d44e2e79241385249d6b
Author: David Howells <dhowells@redhat.com>
Date:   Tue Feb 9 16:40:46 2016 +0000

    KEYS: Add an alloc flag to convey the builtinness of a key
    
    Add KEY_ALLOC_BUILT_IN to convey that a key should have KEY_FLAG_BUILTIN
    set rather than setting it after the fact.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 7321ab8ef949..5f5b1129dc92 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -219,6 +219,7 @@ extern struct key *key_alloc(struct key_type *type,
 #define KEY_ALLOC_QUOTA_OVERRUN	0x0001	/* add to quota, permit even if overrun */
 #define KEY_ALLOC_NOT_IN_QUOTA	0x0002	/* not in quota */
 #define KEY_ALLOC_TRUSTED	0x0004	/* Key should be flagged as trusted */
+#define KEY_ALLOC_BUILT_IN	0x0008	/* Key is built into kernel */
 
 extern void key_revoke(struct key *key);
 extern void key_invalidate(struct key *key);

commit d3600bcf9d64d88dc1d189a754dcfab960ce751f
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Tue Nov 10 08:34:46 2015 -0500

    KEYS: prevent keys from being removed from specified keyrings
    
    Userspace should not be allowed to remove keys from certain keyrings
    (eg. blacklist), though the keys themselves can expire.
    
    This patch defines a new key flag named KEY_FLAG_KEEP to prevent
    userspace from being able to unlink, revoke, invalidate or timed
    out a key on a keyring.  When this flag is set on the keyring, all
    keys subsequently added are flagged.
    
    In addition, when this flag is set, the keyring itself can not be
    cleared.
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Cc: David Howells <dhowells@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 66f705243985..7321ab8ef949 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -177,6 +177,7 @@ struct key {
 #define KEY_FLAG_TRUSTED_ONLY	9	/* set if keyring only accepts links to trusted keys */
 #define KEY_FLAG_BUILTIN	10	/* set if key is builtin */
 #define KEY_FLAG_ROOT_CAN_INVAL	11	/* set if key can be invalidated by root without permission */
+#define KEY_FLAG_KEEP		12	/* set if key should not be removed */
 
 	/* the key type and key description string
 	 * - the desc is used to match a key against search criteria

commit 146aa8b1453bd8f1ff2304ffb71b4ee0eb9acdcc
Author: David Howells <dhowells@redhat.com>
Date:   Wed Oct 21 14:04:48 2015 +0100

    KEYS: Merge the type-specific data with the payload data
    
    Merge the type-specific data with the payload data into one four-word chunk
    as it seems pointless to keep them separate.
    
    Use user_key_payload() for accessing the payloads of overloaded
    user-defined keys.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-cifs@vger.kernel.org
    cc: ecryptfs@vger.kernel.org
    cc: linux-ext4@vger.kernel.org
    cc: linux-f2fs-devel@lists.sourceforge.net
    cc: linux-nfs@vger.kernel.org
    cc: ceph-devel@vger.kernel.org
    cc: linux-ima-devel@lists.sourceforge.net

diff --git a/include/linux/key.h b/include/linux/key.h
index e1d4715f3222..66f705243985 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -89,6 +89,11 @@ struct keyring_index_key {
 	size_t			desc_len;
 };
 
+union key_payload {
+	void __rcu		*rcu_data0;
+	void			*data[4];
+};
+
 /*****************************************************************************/
 /*
  * key reference with possession attribute handling
@@ -186,28 +191,18 @@ struct key {
 		};
 	};
 
-	/* type specific data
-	 * - this is used by the keyring type to index the name
-	 */
-	union {
-		struct list_head	link;
-		unsigned long		x[2];
-		void			*p[2];
-		int			reject_error;
-	} type_data;
-
 	/* key data
 	 * - this is used to hold the data actually used in cryptography or
 	 *   whatever
 	 */
 	union {
-		union {
-			unsigned long		value;
-			void __rcu		*rcudata;
-			void			*data;
-			void			*data2[2];
-		} payload;
-		struct assoc_array keys;
+		union key_payload payload;
+		struct {
+			/* Keyring bits */
+			struct list_head name_link;
+			struct assoc_array keys;
+		};
+		int reject_error;
 	};
 };
 
@@ -336,12 +331,12 @@ static inline bool key_is_instantiated(const struct key *key)
 }
 
 #define rcu_dereference_key(KEY)					\
-	(rcu_dereference_protected((KEY)->payload.rcudata,		\
+	(rcu_dereference_protected((KEY)->payload.rcu_data0,		\
 				   rwsem_is_locked(&((struct key *)(KEY))->sem)))
 
 #define rcu_assign_keypointer(KEY, PAYLOAD)				\
 do {									\
-	rcu_assign_pointer((KEY)->payload.rcudata, (PAYLOAD));		\
+	rcu_assign_pointer((KEY)->payload.rcu_data0, (PAYLOAD));	\
 } while (0)
 
 #ifdef CONFIG_SYSCTL

commit 633706a2ee81637be37b6bc02c5336950cc163b5
Merge: 64724cfc6eea 0d1f64f60b4c
Author: David Howells <dhowells@redhat.com>
Date:   Tue Jul 22 21:55:45 2014 +0100

    Merge branch 'keys-fixes' into keys-next
    
    Signed-off-by: David Howells <dhowells@redhat.com>

commit 0c7774abb41bd00d5836d9ba098825a40fa94133
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jul 17 20:45:08 2014 +0100

    KEYS: Allow special keys (eg. DNS results) to be invalidated by CAP_SYS_ADMIN
    
    Special kernel keys, such as those used to hold DNS results for AFS, CIFS and
    NFS and those used to hold idmapper results for NFS, used to be
    'invalidateable' with key_revoke().  However, since the default permissions for
    keys were reduced:
    
            Commit: 96b5c8fea6c0861621051290d705ec2e971963f1
            KEYS: Reduce initial permissions on keys
    
    it has become impossible to do this.
    
    Add a key flag (KEY_FLAG_ROOT_CAN_INVAL) that will permit a key to be
    invalidated by root.  This should not be used for system keyrings as the
    garbage collector will try and remove any invalidate key.  For system keyrings,
    KEY_FLAG_ROOT_CAN_CLEAR can be used instead.
    
    After this, from userspace, keyctl_invalidate() and "keyctl invalidate" can be
    used by any possessor of CAP_SYS_ADMIN (typically root) to invalidate DNS and
    idmapper keys.  Invalidated keys are immediately garbage collected and will be
    immediately rerequested if needed again.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Steve Dickson <steved@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 017b0826642f..e37a4d807185 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -170,6 +170,7 @@ struct key {
 #define KEY_FLAG_INVALIDATED	7	/* set if key has been invalidated */
 #define KEY_FLAG_TRUSTED	8	/* set if key is trusted */
 #define KEY_FLAG_TRUSTED_ONLY	9	/* set if keyring only accepts links to trusted keys */
+#define KEY_FLAG_ROOT_CAN_INVAL	11	/* set if key can be invalidated by root without permission */
 
 	/* the key type and key description string
 	 * - the desc is used to match a key against search criteria

commit 32c4741cb66703a3c282f41d77deff4afd93342a
Author: Dmitry Kasatkin <d.kasatkin@samsung.com>
Date:   Tue Jun 17 11:56:59 2014 +0300

    KEYS: validate certificate trust only with builtin keys
    
    Instead of allowing public keys, with certificates signed by any
    key on the system trusted keyring, to be added to a trusted keyring,
    this patch further restricts the certificates to those signed only by
    builtin keys on the system keyring.
    
    This patch defines a new option 'builtin' for the kernel parameter
    'keys_ownerid' to allow trust validation using builtin keys.
    
    Simplified Mimi's "KEYS: define an owner trusted keyring" patch
    
    Changelog v7:
    - rename builtin_keys to use_builtin_keys
    
    Signed-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 017b0826642f..65316f7ae794 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -170,6 +170,7 @@ struct key {
 #define KEY_FLAG_INVALIDATED	7	/* set if key has been invalidated */
 #define KEY_FLAG_TRUSTED	8	/* set if key is trusted */
 #define KEY_FLAG_TRUSTED_ONLY	9	/* set if keyring only accepts links to trusted keys */
+#define KEY_FLAG_BUILTIN	10	/* set if key is builtin */
 
 	/* the key type and key description string
 	 * - the desc is used to match a key against search criteria

commit fad0701eaa091beb8ce5ef2eef04b5e833617368
Merge: d53b47c08d8f f9b2a735bddd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 10 10:05:36 2014 -0700

    Merge branch 'serge-next-1' of git://git.kernel.org/pub/scm/linux/kernel/git/sergeh/linux-security
    
    Pull security layer updates from Serge Hallyn:
     "This is a merge of James Morris' security-next tree from 3.14 to
      yesterday's master, plus four patches from Paul Moore which are in
      linux-next, plus one patch from Mimi"
    
    * 'serge-next-1' of git://git.kernel.org/pub/scm/linux/kernel/git/sergeh/linux-security:
      ima: audit log files opened with O_DIRECT flag
      selinux: conditionally reschedule in hashtab_insert while loading selinux policy
      selinux: conditionally reschedule in mls_convert_context while loading selinux policy
      selinux: reject setexeccon() on MNT_NOSUID applications with -EACCES
      selinux:  Report permissive mode in avc: denied messages.
      Warning in scanf string typing
      Smack: Label cgroup files for systemd
      Smack: Verify read access on file open - v3
      security: Convert use of typedef ctl_table to struct ctl_table
      Smack: bidirectional UDS connect check
      Smack: Correctly remove SMACK64TRANSMUTE attribute
      SMACK: Fix handling value==NULL in post setxattr
      bugfix patch for SMACK
      Smack: adds smackfs/ptrace interface
      Smack: unify all ptrace accesses in the smack
      Smack: fix the subject/object order in smack_ptrace_traceme()
      Minor improvement of 'smack_sb_kern_mount'
      smack: fix key permission verification
      KEYS: Move the flags representing required permission to linux/key.h

commit d6f50c95e0e44fa722852ae24aa51d4b7f0d56ed
Author: Joe Perches <joe@perches.com>
Date:   Fri Jun 6 14:38:06 2014 -0700

    key: convert use of typedef ctl_table to struct ctl_table
    
    This typedef is unnecessary and should just be removed.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 80d677483e31..3ae45f09589b 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -332,7 +332,7 @@ do {									\
 } while (0)
 
 #ifdef CONFIG_SYSCTL
-extern ctl_table key_sysctls[];
+extern struct ctl_table key_sysctls[];
 #endif
 /*
  * the userspace interface

commit f5895943d91b41b0368830cdb6eaffb8eda0f4c8
Author: David Howells <dhowells@redhat.com>
Date:   Fri Mar 14 17:44:49 2014 +0000

    KEYS: Move the flags representing required permission to linux/key.h
    
    Move the flags representing required permission to linux/key.h as the perm
    parameter of security_key_permission() is in terms of them - and not the
    permissions mask flags used in key->perm.
    
    Whilst we're at it:
    
     (1) Rename them to be KEY_NEED_xxx rather than KEY_xxx to avoid collisions
         with symbols in uapi/linux/input.h.
    
     (2) Don't use key_perm_t for a mask of required permissions, but rather limit
         it to the permissions mask attached to the key and arguments related
         directly to that.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Dmitry Kasatkin <d.kasatkin@samsung.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 80d677483e31..cd0abb8c9c33 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -309,6 +309,17 @@ static inline key_serial_t key_serial(const struct key *key)
 
 extern void key_set_timeout(struct key *, unsigned);
 
+/*
+ * The permissions required on a key that we're looking up.
+ */
+#define	KEY_NEED_VIEW	0x01	/* Require permission to view attributes */
+#define	KEY_NEED_READ	0x02	/* Require permission to read content */
+#define	KEY_NEED_WRITE	0x04	/* Require permission to update / modify */
+#define	KEY_NEED_SEARCH	0x08	/* Require permission to search (keyring) or find (key) */
+#define	KEY_NEED_LINK	0x10	/* Require permission to link */
+#define	KEY_NEED_SETATTR 0x20	/* Require permission to change attributes */
+#define	KEY_NEED_ALL	0x3f	/* All the above permissions */
+
 /**
  * key_is_instantiated - Determine if a key has been positively instantiated
  * @key: The key to check.

commit 008643b86c5f33c115c84ccdda1725cac3ad50ad
Author: David Howells <dhowells@redhat.com>
Date:   Fri Aug 30 16:07:37 2013 +0100

    KEYS: Add a 'trusted' flag and a 'trusted only' flag
    
    Add KEY_FLAG_TRUSTED to indicate that a key either comes from a trusted source
    or had a cryptographic signature chain that led back to a trusted key the
    kernel already possessed.
    
    Add KEY_FLAGS_TRUSTED_ONLY to indicate that a keyring will only accept links to
    keys marked with KEY_FLAGS_TRUSTED.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 010dbb618aca..80d677483e31 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -168,6 +168,8 @@ struct key {
 #define KEY_FLAG_NEGATIVE	5	/* set if key is negative */
 #define KEY_FLAG_ROOT_CAN_CLEAR	6	/* set if key can be cleared by root without permission */
 #define KEY_FLAG_INVALIDATED	7	/* set if key has been invalidated */
+#define KEY_FLAG_TRUSTED	8	/* set if key is trusted */
+#define KEY_FLAG_TRUSTED_ONLY	9	/* set if keyring only accepts links to trusted keys */
 
 	/* the key type and key description string
 	 * - the desc is used to match a key against search criteria
@@ -218,6 +220,7 @@ extern struct key *key_alloc(struct key_type *type,
 #define KEY_ALLOC_IN_QUOTA	0x0000	/* add to quota, reject if would overrun */
 #define KEY_ALLOC_QUOTA_OVERRUN	0x0001	/* add to quota, permit even if overrun */
 #define KEY_ALLOC_NOT_IN_QUOTA	0x0002	/* not in quota */
+#define KEY_ALLOC_TRUSTED	0x0004	/* Key should be flagged as trusted */
 
 extern void key_revoke(struct key *key);
 extern void key_invalidate(struct key *key);

commit ab3c3587f8cda9083209a61dbe3a4407d3cada10
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 24 10:35:18 2013 +0100

    KEYS: Implement a big key type that can save to tmpfs
    
    Implement a big key type that can save its contents to tmpfs and thus
    swapspace when memory is tight.  This is useful for Kerberos ticket caches.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Simo Sorce <simo@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 2417f789d29b..010dbb618aca 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -201,6 +201,7 @@ struct key {
 			unsigned long		value;
 			void __rcu		*rcudata;
 			void			*data;
+			void			*data2[2];
 		} payload;
 		struct assoc_array keys;
 	};

commit b2a4df200d570b2c33a57e1ebfa5896e4bc81b69
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 24 10:35:18 2013 +0100

    KEYS: Expand the capacity of a keyring
    
    Expand the capacity of a keyring to be able to hold a lot more keys by using
    the previously added associative array implementation.  Currently the maximum
    capacity is:
    
            (PAGE_SIZE - sizeof(header)) / sizeof(struct key *)
    
    which, on a 64-bit system, is a little more 500.  However, since this is being
    used for the NFS uid mapper, we need more than that.  The new implementation
    gives us effectively unlimited capacity.
    
    With some alterations, the keyutils testsuite runs successfully to completion
    after this patch is applied.  The alterations are because (a) keyrings that
    are simply added to no longer appear ordered and (b) some of the errors have
    changed a bit.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index ef596c7af585..2417f789d29b 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -22,6 +22,7 @@
 #include <linux/sysctl.h>
 #include <linux/rwsem.h>
 #include <linux/atomic.h>
+#include <linux/assoc_array.h>
 
 #ifdef __KERNEL__
 #include <linux/uidgid.h>
@@ -196,11 +197,13 @@ struct key {
 	 *   whatever
 	 */
 	union {
-		unsigned long		value;
-		void __rcu		*rcudata;
-		void			*data;
-		struct keyring_list __rcu *subscriptions;
-	} payload;
+		union {
+			unsigned long		value;
+			void __rcu		*rcudata;
+			void			*data;
+		} payload;
+		struct assoc_array keys;
+	};
 };
 
 extern struct key *key_alloc(struct key_type *type,

commit ccc3e6d9c9aea07a0b60b2b0bfc5b05a704b66d5
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 24 10:35:16 2013 +0100

    KEYS: Define a __key_get() wrapper to use rather than atomic_inc()
    
    Define a __key_get() wrapper to use rather than atomic_inc() on the key usage
    count as this makes it easier to hook in refcount error debugging.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index d573e820a23d..ef596c7af585 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -219,13 +219,17 @@ extern void key_revoke(struct key *key);
 extern void key_invalidate(struct key *key);
 extern void key_put(struct key *key);
 
-static inline struct key *key_get(struct key *key)
+static inline struct key *__key_get(struct key *key)
 {
-	if (key)
-		atomic_inc(&key->usage);
+	atomic_inc(&key->usage);
 	return key;
 }
 
+static inline struct key *key_get(struct key *key)
+{
+	return key ? __key_get(key) : key;
+}
+
 static inline void key_ref_put(key_ref_t key_ref)
 {
 	key_put(key_ref_to_ptr(key_ref));

commit 16feef4340172b7dbb9cba60850e78fa6388adf1
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 24 10:35:15 2013 +0100

    KEYS: Consolidate the concept of an 'index key' for key access
    
    Consolidate the concept of an 'index key' for accessing keys.  The index key
    is the search term needed to find a key directly - basically the key type and
    the key description.  We can add to that the description length.
    
    This will be useful when turning a keyring into an associative array rather
    than just a pointer block.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 51bce2950de4..d573e820a23d 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -82,6 +82,12 @@ struct key_owner;
 struct keyring_list;
 struct keyring_name;
 
+struct keyring_index_key {
+	struct key_type		*type;
+	const char		*description;
+	size_t			desc_len;
+};
+
 /*****************************************************************************/
 /*
  * key reference with possession attribute handling
@@ -129,7 +135,6 @@ struct key {
 		struct list_head graveyard_link;
 		struct rb_node	serial_node;
 	};
-	struct key_type		*type;		/* type of key */
 	struct rw_semaphore	sem;		/* change vs change sem */
 	struct key_user		*user;		/* owner of this key */
 	void			*security;	/* security data for this key */
@@ -163,12 +168,18 @@ struct key {
 #define KEY_FLAG_ROOT_CAN_CLEAR	6	/* set if key can be cleared by root without permission */
 #define KEY_FLAG_INVALIDATED	7	/* set if key has been invalidated */
 
-	/* the description string
-	 * - this is used to match a key against search criteria
-	 * - this should be a printable string
+	/* the key type and key description string
+	 * - the desc is used to match a key against search criteria
+	 * - it should be a printable string
 	 * - eg: for krb5 AFS, this might be "afs@REDHAT.COM"
 	 */
-	char			*description;
+	union {
+		struct keyring_index_key index_key;
+		struct {
+			struct key_type	*type;		/* type of key */
+			char		*description;
+		};
+	};
 
 	/* type specific data
 	 * - this is used by the keyring type to index the name

commit a5b4bd2874d9032b42db8cc4880058576c561b06
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 24 10:35:14 2013 +0100

    KEYS: Use bool in make_key_ref() and is_key_possessed()
    
    Make make_key_ref() take a bool possession parameter and make
    is_key_possessed() return a bool.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 4dfde1161c5e..51bce2950de4 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -99,7 +99,7 @@ struct keyring_name;
 typedef struct __key_reference_with_attributes *key_ref_t;
 
 static inline key_ref_t make_key_ref(const struct key *key,
-				     unsigned long possession)
+				     bool possession)
 {
 	return (key_ref_t) ((unsigned long) key | possession);
 }
@@ -109,7 +109,7 @@ static inline struct key *key_ref_to_ptr(const key_ref_t key_ref)
 	return (struct key *) ((unsigned long) key_ref & ~1UL);
 }
 
-static inline unsigned long is_key_possessed(const key_ref_t key_ref)
+static inline bool is_key_possessed(const key_ref_t key_ref)
 {
 	return (unsigned long) key_ref & 1UL;
 }

commit 2a74dbb9a86e8102dcd07d284135b4530a84826e
Merge: 770b6cb4d21f e93072374112
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 16 15:40:50 2012 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull security subsystem updates from James Morris:
     "A quiet cycle for the security subsystem with just a few maintenance
      updates."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security:
      Smack: create a sysfs mount point for smackfs
      Smack: use select not depends in Kconfig
      Yama: remove locking from delete path
      Yama: add RCU to drop read locking
      drivers/char/tpm: remove tasklet and cleanup
      KEYS: Use keyring_alloc() to create special keyrings
      KEYS: Reduce initial permissions on keys
      KEYS: Make the session and process keyrings per-thread
      seccomp: Make syscall skipping and nr changes more consistent
      key: Fix resource leak
      keys: Fix unreachable code
      KEYS: Add payload preparsing opportunity prior to key instantiate or update

commit 96b5c8fea6c0861621051290d705ec2e971963f1
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 2 19:24:56 2012 +0100

    KEYS: Reduce initial permissions on keys
    
    Reduce the initial permissions on new keys to grant the possessor everything,
    view permission only to the user (so the keys can be seen in /proc/keys) and
    nothing else.
    
    This gives the creator a chance to adjust the permissions mask before other
    processes can access the new key or create a link to it.
    
    To aid with this, keyring_alloc() now takes a permission argument rather than
    setting the permissions itself.
    
    The following permissions are now set:
    
     (1) The user and user-session keyrings grant the user that owns them full
         permissions and grant a possessor everything bar SETATTR.
    
     (2) The process and thread keyrings grant the possessor full permissions but
         only grant the user VIEW.  This permits the user to see them in
         /proc/keys, but not to do anything with them.
    
     (3) Anonymous session keyrings grant the possessor full permissions, but only
         grant the user VIEW and READ.  This means that the user can see them in
         /proc/keys and can list them, but nothing else.  Possibly READ shouldn't
         be provided either.
    
     (4) Named session keyrings grant everything an anonymous session keyring does,
         plus they grant the user LINK permission.  The whole point of named
         session keyrings is that others can also subscribe to them.  Possibly this
         should be a separate permission to LINK.
    
     (5) The temporary session keyring created by call_sbin_request_key() gets the
         same permissions as an anonymous session keyring.
    
     (6) Keys created by add_key() get VIEW, SEARCH, LINK and SETATTR for the
         possessor, plus READ and/or WRITE if the key type supports them.  The used
         only gets VIEW now.
    
     (7) Keys created by request_key() now get the same as those created by
         add_key().
    
    Reported-by: Lennart Poettering <lennart@poettering.net>
    Reported-by: Stef Walter <stefw@redhat.com>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index cef3b315ba7c..890699815212 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -264,6 +264,7 @@ extern int key_unlink(struct key *keyring,
 
 extern struct key *keyring_alloc(const char *description, uid_t uid, gid_t gid,
 				 const struct cred *cred,
+				 key_perm_t perm,
 				 unsigned long flags,
 				 struct key *dest);
 

commit 9a56c2db49e7349c7963f0ce66c1ef578d44ebd3
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Feb 8 07:53:04 2012 -0800

    userns: Convert security/keys to the new userns infrastructure
    
    - Replace key_user ->user_ns equality checks with kuid_has_mapping checks.
    - Use from_kuid to generate key descriptions
    - Use kuid_t and kgid_t and the associated helpers instead of uid_t and gid_t
    - Avoid potential problems with file descriptor passing by displaying
      keys in the user namespace of the opener of key status proc files.
    
    Cc: linux-security-module@vger.kernel.org
    Cc: keyrings@linux-nfs.org
    Cc: David Howells <dhowells@redhat.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index cef3b315ba7c..2393b1c040b6 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -24,6 +24,7 @@
 #include <linux/atomic.h>
 
 #ifdef __KERNEL__
+#include <linux/uidgid.h>
 
 /* key handle serial number */
 typedef int32_t key_serial_t;
@@ -137,8 +138,8 @@ struct key {
 		time_t		revoked_at;	/* time at which key was revoked */
 	};
 	time_t			last_used_at;	/* last time used for LRU keyring discard */
-	uid_t			uid;
-	gid_t			gid;
+	kuid_t			uid;
+	kgid_t			gid;
 	key_perm_t		perm;		/* access permissions */
 	unsigned short		quotalen;	/* length added to quota */
 	unsigned short		datalen;	/* payload data length
@@ -193,7 +194,7 @@ struct key {
 
 extern struct key *key_alloc(struct key_type *type,
 			     const char *desc,
-			     uid_t uid, gid_t gid,
+			     kuid_t uid, kgid_t gid,
 			     const struct cred *cred,
 			     key_perm_t perm,
 			     unsigned long flags);
@@ -262,7 +263,7 @@ extern int key_link(struct key *keyring,
 extern int key_unlink(struct key *keyring,
 		      struct key *key);
 
-extern struct key *keyring_alloc(const char *description, uid_t uid, gid_t gid,
+extern struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,
 				 const struct cred *cred,
 				 unsigned long flags,
 				 struct key *dest);

commit e5c1f444d28b1a9eaf9c3927041db0414f684ef4
Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Date:   Wed May 16 16:31:38 2012 -0700

    key: Remove extraneous parentheses from rcu_assign_keypointer()
    
    This commit removes the extraneous parentheses from rcu_assign_keypointer()
    so that rcu_assign_pointer() can be wrapped in do-while.  It also wraps
    rcu_assign_keypointer() in a do-while and parenthesizes its final argument,
    as suggested by David Howells.
    
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 4cd22ed627ef..cef3b315ba7c 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -303,7 +303,9 @@ static inline bool key_is_instantiated(const struct key *key)
 				   rwsem_is_locked(&((struct key *)(KEY))->sem)))
 
 #define rcu_assign_keypointer(KEY, PAYLOAD)				\
-	(rcu_assign_pointer((KEY)->payload.rcudata, PAYLOAD))
+do {									\
+	rcu_assign_pointer((KEY)->payload.rcudata, (PAYLOAD));		\
+} while (0)
 
 #ifdef CONFIG_SYSCTL
 extern ctl_table key_sysctls[];

commit dea649b8ac1861107c5d91e1a71121434fc64193
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Fri May 11 10:59:09 2012 +1000

    keys: kill the dummy key_replace_session_keyring()
    
    After the previouse change key_replace_session_keyring() becomes a nop.
    Remove the dummy definition in key.h and update the callers in
    arch/*/kernel/signal.c.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Alexander Gordeev <agordeev@redhat.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: David Smith <dsmith@redhat.com>
    Cc: "Frank Ch. Eigler" <fche@redhat.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Larry Woodman <lwoodman@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/key.h b/include/linux/key.h
index 2a0ee11584e9..4cd22ed627ef 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -33,8 +33,6 @@ typedef uint32_t key_perm_t;
 
 struct key;
 
-#define key_replace_session_keyring()	do { } while (0)
-
 #ifdef CONFIG_KEYS
 
 #undef KEY_DEBUGGING

commit 413cd3d9abeaef590e5ce00564f7a443165db238
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Fri May 11 10:59:08 2012 +1000

    keys: change keyctl_session_to_parent() to use task_work_add()
    
    Change keyctl_session_to_parent() to use task_work_add() and move
    key_replace_session_keyring() logic into task_work->func().
    
    Note that we do task_work_cancel() before task_work_add() to ensure that
    only one work can be pending at any time.  This is important, we must not
    allow user-space to abuse the parent's ->task_works list.
    
    The callback, replace_session_keyring(), checks PF_EXITING.  I guess this
    is not really needed but looks better.
    
    As a side effect, this fixes the (unlikely) race.  The callers of
    key_replace_session_keyring() and keyctl_session_to_parent() lack the
    necessary barriers, the parent can miss the request.
    
    Now we can remove task_struct->replacement_session_keyring and related
    code.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Alexander Gordeev <agordeev@redhat.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: David Smith <dsmith@redhat.com>
    Cc: "Frank Ch. Eigler" <fche@redhat.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Larry Woodman <lwoodman@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/key.h b/include/linux/key.h
index 5231800770e1..2a0ee11584e9 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -33,6 +33,8 @@ typedef uint32_t key_perm_t;
 
 struct key;
 
+#define key_replace_session_keyring()	do { } while (0)
+
 #ifdef CONFIG_KEYS
 
 #undef KEY_DEBUGGING
@@ -308,9 +310,6 @@ static inline bool key_is_instantiated(const struct key *key)
 #ifdef CONFIG_SYSCTL
 extern ctl_table key_sysctls[];
 #endif
-
-extern void key_replace_session_keyring(void);
-
 /*
  * the userspace interface
  */
@@ -334,7 +333,6 @@ extern void key_init(void);
 #define key_fsuid_changed(t)		do { } while(0)
 #define key_fsgid_changed(t)		do { } while(0)
 #define key_init()			do { } while(0)
-#define key_replace_session_keyring()	do { } while(0)
 
 #endif /* CONFIG_KEYS */
 #endif /* __KERNEL__ */

commit b404aef72fdafb601c945c714164c0ee2b04c364
Author: David Howells <dhowells@redhat.com>
Date:   Tue May 15 14:11:11 2012 +0100

    KEYS: Don't check for NULL key pointer in key_validate()
    
    Don't bother checking for NULL key pointer in key_validate() as all of the
    places that call it will crash anyway if the relevant key pointer is NULL by
    the time they call key_validate().  Therefore, the checking must be done prior
    to calling here.
    
    Whilst we're at it, simplify the key_validate() function a bit and mark its
    argument const.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index b145b054b3e0..5231800770e1 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -242,7 +242,7 @@ extern struct key *request_key_async_with_auxdata(struct key_type *type,
 
 extern int wait_for_key_construction(struct key *key, bool intr);
 
-extern int key_validate(struct key *key);
+extern int key_validate(const struct key *key);
 
 extern key_ref_t key_create_or_update(key_ref_t keyring,
 				      const char *type,

commit fd75815f727f157a05f4c96b5294a4617c0557da
Author: David Howells <dhowells@redhat.com>
Date:   Fri May 11 10:56:56 2012 +0100

    KEYS: Add invalidation support
    
    Add support for invalidating a key - which renders it immediately invisible to
    further searches and causes the garbage collector to immediately wake up,
    remove it from keyrings and then destroy it when it's no longer referenced.
    
    It's better not to do this with keyctl_revoke() as that marks the key to start
    returning -EKEYREVOKED to searches when what is actually desired is to have the
    key refetched.
    
    To invalidate a key the caller must be granted SEARCH permission by the key.
    This may be too strict.  It may be better to also permit invalidation if the
    caller has any of READ, WRITE or SETATTR permission.
    
    The primary use for this is to evict keys that are cached in special keyrings,
    such as the DNS resolver or an ID mapper.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 13c0dcd8ee48..b145b054b3e0 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -160,6 +160,7 @@ struct key {
 #define KEY_FLAG_USER_CONSTRUCT	4	/* set if key is being constructed in userspace */
 #define KEY_FLAG_NEGATIVE	5	/* set if key is negative */
 #define KEY_FLAG_ROOT_CAN_CLEAR	6	/* set if key can be cleared by root without permission */
+#define KEY_FLAG_INVALIDATED	7	/* set if key has been invalidated */
 
 	/* the description string
 	 * - this is used to match a key against search criteria
@@ -203,6 +204,7 @@ extern struct key *key_alloc(struct key_type *type,
 #define KEY_ALLOC_NOT_IN_QUOTA	0x0002	/* not in quota */
 
 extern void key_revoke(struct key *key);
+extern void key_invalidate(struct key *key);
 extern void key_put(struct key *key);
 
 static inline struct key *key_get(struct key *key)
@@ -323,6 +325,7 @@ extern void key_init(void);
 #define key_serial(k)			0
 #define key_get(k) 			({ NULL; })
 #define key_revoke(k)			do { } while(0)
+#define key_invalidate(k)		do { } while(0)
 #define key_put(k)			do { } while(0)
 #define key_ref_put(k)			do { } while(0)
 #define make_key_ref(k, p)		NULL

commit 31d5a79d7f3d436da176a78ebc12d53c06da402e
Author: David Howells <dhowells@redhat.com>
Date:   Fri May 11 10:56:56 2012 +0100

    KEYS: Do LRU discard in full keyrings
    
    Do an LRU discard in keyrings that are full rather than returning ENFILE.  To
    perform this, a time_t is added to the key struct and updated by the creation
    of a link to a key and by a key being found as the result of a search.  At the
    completion of a successful search, the keyrings in the path between the root of
    the search and the first found link to it also have their last-used times
    updated.
    
    Note that discarding a link to a key from a keyring does not necessarily
    destroy the key as there may be references held by other places.
    
    An alternate discard method that might suffice is to perform FIFO discard from
    the keyring, using the spare 2-byte hole in the keylist header as the index of
    the next link to be discarded.
    
    This is useful when using a keyring as a cache for DNS results or foreign
    filesystem IDs.
    
    
    This can be tested by the following.  As root do:
    
            echo 1000 >/proc/sys/kernel/keys/root_maxkeys
    
            kr=`keyctl newring foo @s`
            for ((i=0; i<2000; i++)); do keyctl add user a$i a $kr; done
    
    Without this patch ENFILE should be reported when the keyring fills up.  With
    this patch, the keyring discards keys in an LRU fashion.  Note that the stored
    LRU time has a granularity of 1s.
    
    After doing this, /proc/key-users can be observed and should show that most of
    the 2000 keys have been discarded:
    
            [root@andromeda ~]# cat /proc/key-users
                0:   517 516/516 513/1000 5249/20000
    
    The "513/1000" here is the number of quota-accounted keys present for this user
    out of the maximum permitted.
    
    In /proc/keys, the keyring shows the number of keys it has and the number of
    slots it has allocated:
    
            [root@andromeda ~]# grep foo /proc/keys
            200c64c4 I--Q--     1 perm 3b3f0000     0     0 keyring   foo: 509/509
    
    The maximum is (PAGE_SIZE - header) / key pointer size.  That's typically 509
    on a 64-bit system and 1020 on a 32-bit system.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index c505f83c9691..13c0dcd8ee48 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -136,6 +136,7 @@ struct key {
 		time_t		expiry;		/* time at which key expires (or 0) */
 		time_t		revoked_at;	/* time at which key was revoked */
 	};
+	time_t			last_used_at;	/* last time used for LRU keyring discard */
 	uid_t			uid;
 	gid_t			gid;
 	key_perm_t		perm;		/* access permissions */

commit 65d87fe68abf2fc226a9e96be61160f65d6b4680
Author: David Howells <dhowells@redhat.com>
Date:   Fri May 11 10:56:56 2012 +0100

    KEYS: Perform RCU synchronisation on keys prior to key destruction
    
    Make the keys garbage collector invoke synchronize_rcu() prior to destroying
    keys with a zero usage count.  This means that a key can be examined under the
    RCU read lock in the safe knowledge that it won't get deallocated until after
    the lock is released - even if its usage count becomes zero whilst we're
    looking at it.
    
    This is useful in keyring search vs key link.  Consider a keyring containing a
    link to a key.  That link can be replaced in-place in the keyring without
    requiring an RCU copy-and-replace on the keyring contents without breaking a
    search underway on that keyring when the displaced key is released, provided
    the key is actually destroyed only after the RCU read lock held by the search
    algorithm is released.
    
    This permits __key_link() to replace a key without having to reallocate the key
    payload.  A key gets replaced if a new key being linked into a keyring has the
    same type and description.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Jeff Layton <jlayton@redhat.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 96933b1e5d24..c505f83c9691 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -124,7 +124,10 @@ static inline unsigned long is_key_possessed(const key_ref_t key_ref)
 struct key {
 	atomic_t		usage;		/* number of references */
 	key_serial_t		serial;		/* key serial number */
-	struct rb_node		serial_node;
+	union {
+		struct list_head graveyard_link;
+		struct rb_node	serial_node;
+	};
 	struct key_type		*type;		/* type of key */
 	struct rw_semaphore	sem;		/* change vs change sem */
 	struct key_user		*user;		/* owner of this key */

commit f63d395d47f37a4fe771e6d4b1db9d2cdae5ffc5
Merge: 643ac9fc5429 5a7c9eec9fde
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 23 08:53:47 2012 -0700

    Merge tag 'nfs-for-3.4-1' of git://git.linux-nfs.org/projects/trondmy/linux-nfs
    
    Pull NFS client updates for Linux 3.4 from Trond Myklebust:
     "New features include:
       - Add NFS client support for containers.
    
         This should enable most of the necessary functionality, including
         lockd support, and support for rpc.statd, NFSv4 idmapper and
         RPCSEC_GSS upcalls into the correct network namespace from which
         the mount system call was issued.
    
       - NFSv4 idmapper scalability improvements
    
         Base the idmapper cache on the keyring interface to allow
         concurrent access to idmapper entries.  Start the process of
         migrating users from the single-threaded daemon-based approach to
         the multi-threaded request-key based approach.
    
       - NFSv4.1 implementation id.
    
         Allows the NFSv4.1 client and server to mutually identify each
         other for logging and debugging purposes.
    
       - Support the 'vers=4.1' mount option for mounting NFSv4.1 instead of
         having to use the more counterintuitive 'vers=4,minorversion=1'.
    
       - SUNRPC tracepoints.
    
         Start the process of adding tracepoints in order to improve
         debugging of the RPC layer.
    
       - pNFS object layout support for autologin.
    
      Important bugfixes include:
    
       - Fix a bug in rpc_wake_up/rpc_wake_up_status that caused them to
         fail to wake up all tasks when applied to priority waitqueues.
    
       - Ensure that we handle read delegations correctly, when we try to
         truncate a file.
    
       - A number of fixes for NFSv4 state manager loops (mostly to do with
         delegation recovery)."
    
    * tag 'nfs-for-3.4-1' of git://git.linux-nfs.org/projects/trondmy/linux-nfs: (224 commits)
      NFS: fix sb->s_id in nfs debug prints
      xprtrdma: Remove assumption that each segment is <= PAGE_SIZE
      xprtrdma: The transport should not bug-check when a dup reply is received
      pnfs-obj: autologin: Add support for protocol autologin
      NFS: Remove nfs4_setup_sequence from generic rename code
      NFS: Remove nfs4_setup_sequence from generic unlink code
      NFS: Remove nfs4_setup_sequence from generic read code
      NFS: Remove nfs4_setup_sequence from generic write code
      NFS: Fix more NFS debug related build warnings
      SUNRPC/LOCKD: Fix build warnings when CONFIG_SUNRPC_DEBUG is undefined
      nfs: non void functions must return a value
      SUNRPC: Kill compiler warning when RPC_DEBUG is unset
      SUNRPC/NFS: Add Kbuild dependencies for NFS_DEBUG/RPC_DEBUG
      NFS: Use cond_resched_lock() to reduce latencies in the commit scans
      NFSv4: It is not safe to dereference lsp->ls_state in release_lockowner
      NFS: ncommit count is being double decremented
      SUNRPC: We must not use list_for_each_entry_safe() in rpc_wake_up()
      Try using machine credentials for RENEW calls
      NFSv4.1: Fix a few issues in filelayout_commit_pagelist
      NFSv4.1: Clean ups and bugfixes for the pNFS read/writeback/commit code
      ...

commit 59e6b9c11341e3b8ac5925427c903d4eae435bd8
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Fri Feb 24 14:14:50 2012 -0500

    Created a function for setting timeouts on keys
    
    The keyctl_set_timeout function isn't exported to other parts of the
    kernel, but I want to use it for the NFS idmapper.  I already have the
    key, but I wanted a generic way to set the timeout.
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/key.h b/include/linux/key.h
index 5253471cd2ea..be3995d1024a 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -276,6 +276,8 @@ static inline key_serial_t key_serial(const struct key *key)
 	return key ? key->serial : 0;
 }
 
+extern void key_set_timeout(struct key *, unsigned);
+
 /**
  * key_is_instantiated - Determine if a key has been positively instantiated
  * @key: The key to check.

commit 9e3ff38647a316e4f92d59b14c8f0eb13b33bb2c
Merge: 2eb6038c5103 4c2c392763a6
Author: James Morris <jmorris@namei.org>
Date:   Thu Feb 9 17:02:34 2012 +1100

    Merge branch 'next-queue' into next

commit 456a8167e94b66f406c27400a46a707b870452b0
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jan 18 10:04:29 2012 +0000

    KEYS: Permit key_serial() to be called with a const key pointer
    
    Permit key_serial() to be called with a const key pointer.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index bfc014c57351..5253471cd2ea 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -271,7 +271,7 @@ extern int keyring_add_key(struct key *keyring,
 
 extern struct key *key_lookup(key_serial_t id);
 
-static inline key_serial_t key_serial(struct key *key)
+static inline key_serial_t key_serial(const struct key *key)
 {
 	return key ? key->serial : 0;
 }

commit 700920eb5ba4de5417b446c9a8bb008df2b973e0
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jan 18 15:31:45 2012 +0000

    KEYS: Allow special keyrings to be cleared
    
    The kernel contains some special internal keyrings, for instance the DNS
    resolver keyring :
    
    2a93faf1 I-----     1 perm 1f030000     0     0 keyring   .dns_resolver: empty
    
    It would occasionally be useful to allow the contents of such keyrings to be
    flushed by root (cache invalidation).
    
    Allow a flag to be set on a keyring to mark that someone possessing the
    sysadmin capability can clear the keyring, even without normal write access to
    the keyring.
    
    Set this flag on the special keyrings created by the DNS resolver, the NFS
    identity mapper and the CIFS identity mapper.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Acked-by: Steve Dickson <steved@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 183a6af7715d..3ac412855d83 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -155,6 +155,7 @@ struct key {
 #define KEY_FLAG_IN_QUOTA	3	/* set if key consumes quota */
 #define KEY_FLAG_USER_CONSTRUCT	4	/* set if key is being constructed in userspace */
 #define KEY_FLAG_NEGATIVE	5	/* set if key is negative */
+#define KEY_FLAG_ROOT_CAN_CLEAR	6	/* set if key can be cleared by root without permission */
 
 	/* the description string
 	 * - this is used to match a key against search criteria

commit ee0b31a25a010116f44fca6c96f4516d417793dd
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Tue Jan 17 20:39:51 2012 +0000

    keys: fix trusted/encrypted keys sparse rcu_assign_pointer messages
    
    Define rcu_assign_keypointer(), which uses the key payload.rcudata instead
    of payload.data, to resolve the CONFIG_SPARSE_RCU_POINTER message:
    "incompatible types in comparison expression (different address spaces)"
    
    Replace the rcu_assign_pointer() calls in encrypted/trusted keys with
    rcu_assign_keypointer().
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 183a6af7715d..bfc014c57351 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -293,6 +293,9 @@ static inline bool key_is_instantiated(const struct key *key)
 	(rcu_dereference_protected((KEY)->payload.rcudata,		\
 				   rwsem_is_locked(&((struct key *)(KEY))->sem)))
 
+#define rcu_assign_keypointer(KEY, PAYLOAD)				\
+	(rcu_assign_pointer((KEY)->payload.rcudata, PAYLOAD))
+
 #ifdef CONFIG_SYSCTL
 extern ctl_table key_sysctls[];
 #endif

commit 60063497a95e716c9a689af3be2687d261f115b4
Author: Arun Sharma <asharma@fb.com>
Date:   Tue Jul 26 16:09:06 2011 -0700

    atomic: use <linux/atomic.h>
    
    This allows us to move duplicated code in <asm/atomic.h>
    (atomic_inc_not_zero() for now) to <linux/atomic.h>
    
    Signed-off-by: Arun Sharma <asharma@fb.com>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 6ea4eebd3467..183a6af7715d 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -21,7 +21,7 @@
 #include <linux/rcupdate.h>
 #include <linux/sysctl.h>
 #include <linux/rwsem.h>
-#include <asm/atomic.h>
+#include <linux/atomic.h>
 
 #ifdef __KERNEL__
 

commit e52e713ec30a31e9a4663d9aebbaae5ec07466a6
Merge: bdf7cf1c8387 2f3e4af471e3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 27 10:25:02 2011 -0700

    Merge branch 'docs-move' of git://git.kernel.org/pub/scm/linux/kernel/git/rdunlap/linux-docs
    
    * 'docs-move' of git://git.kernel.org/pub/scm/linux/kernel/git/rdunlap/linux-docs:
      Create Documentation/security/, move LSM-, credentials-, and keys-related files from Documentation/   to Documentation/security/, add Documentation/security/00-INDEX, and update all occurrences of Documentation/<moved_file>   to Documentation/security/<moved_file>.

commit d410fa4ef99112386de5f218dd7df7b4fca910b4
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Thu May 19 15:59:38 2011 -0700

    Create Documentation/security/,
    move LSM-, credentials-, and keys-related files from Documentation/
      to Documentation/security/,
    add Documentation/security/00-INDEX, and
    update all occurrences of Documentation/<moved_file>
      to Documentation/security/<moved_file>.

diff --git a/include/linux/key.h b/include/linux/key.h
index b2bb01719561..303982a69933 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -9,7 +9,7 @@
  * 2 of the License, or (at your option) any later version.
  *
  *
- * See Documentation/keys.txt for information on keys/keyrings.
+ * See Documentation/security/keys.txt for information on keys/keyrings.
  */
 
 #ifndef _LINUX_KEY_H

commit 78b7280cce23293f7570ad52c1ffe1485c6d9669
Author: David Howells <dhowells@redhat.com>
Date:   Fri Mar 11 17:57:23 2011 +0000

    KEYS: Improve /proc/keys
    
    Improve /proc/keys by:
    
     (1) Don't attempt to summarise the payload of a negated key.  It won't have
         one.  To this end, a helper function - key_is_instantiated() has been
         added that allows the caller to find out whether the key is positively
         instantiated (as opposed to being uninstantiated or negatively
         instantiated).
    
     (2) Do show keys that are negative, expired or revoked rather than hiding
         them.  This requires an override flag (no_state_check) to be passed to
         search_my_process_keyrings() and keyring_search_aux() to suppress this
         check.
    
         Without this, keys that are possessed by the caller, but only grant
         permissions to the caller if possessed are skipped as the possession check
         fails.
    
         Keys that are visible due to user, group or other checks are visible with
         or without this patch.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index b2bb01719561..ef19b99aff98 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -276,6 +276,19 @@ static inline key_serial_t key_serial(struct key *key)
 	return key ? key->serial : 0;
 }
 
+/**
+ * key_is_instantiated - Determine if a key has been positively instantiated
+ * @key: The key to check.
+ *
+ * Return true if the specified key has been positively instantiated, false
+ * otherwise.
+ */
+static inline bool key_is_instantiated(const struct key *key)
+{
+	return test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&
+		!test_bit(KEY_FLAG_NEGATIVE, &key->flags);
+}
+
 #define rcu_dereference_key(KEY)					\
 	(rcu_dereference_protected((KEY)->payload.rcudata,		\
 				   rwsem_is_locked(&((struct key *)(KEY))->sem)))

commit fdd1b94581782a2ddf9124414e5b7a5f48ce2f9c
Author: David Howells <dhowells@redhat.com>
Date:   Mon Mar 7 15:06:09 2011 +0000

    KEYS: Add a new keyctl op to reject a key with a specified error code
    
    Add a new keyctl op to reject a key with a specified error code.  This works
    much the same as negating a key, and so keyctl_negate_key() is made a special
    case of keyctl_reject_key().  The difference is that keyctl_negate_key()
    selects ENOKEY as the error to be reported.
    
    Typically the key would be rejected with EKEYEXPIRED, EKEYREVOKED or
    EKEYREJECTED, but this is not mandatory.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index a6b1edcffc34..b2bb01719561 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -170,6 +170,7 @@ struct key {
 		struct list_head	link;
 		unsigned long		x[2];
 		void			*p[2];
+		int			reject_error;
 	} type_data;
 
 	/* key data

commit 633e804e89464d3875e59de1959a53f9041d3094
Author: David Howells <dhowells@redhat.com>
Date:   Mon Mar 7 15:05:51 2011 +0000

    KEYS: Add an RCU payload dereference macro
    
    Add an RCU payload dereference macro as this seems to be a common piece of code
    amongst key types that use RCU referenced payloads.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 3db0adce1fda..a6b1edcffc34 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -275,6 +275,10 @@ static inline key_serial_t key_serial(struct key *key)
 	return key ? key->serial : 0;
 }
 
+#define rcu_dereference_key(KEY)					\
+	(rcu_dereference_protected((KEY)->payload.rcudata,		\
+				   rwsem_is_locked(&((struct key *)(KEY))->sem)))
+
 #ifdef CONFIG_SYSCTL
 extern ctl_table key_sysctls[];
 #endif

commit e63ba744a64d234c8a07c469ab1806443cb0a6ff
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Feb 26 18:01:20 2010 +0100

    keys: __rcu annotations
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index cd50dfa1d4c2..3db0adce1fda 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -178,8 +178,9 @@ struct key {
 	 */
 	union {
 		unsigned long		value;
+		void __rcu		*rcudata;
 		void			*data;
-		struct keyring_list	*subscriptions;
+		struct keyring_list __rcu *subscriptions;
 	} payload;
 };
 

commit ee18d64c1f632043a02e6f5ba5e045bb26a5465f
Author: David Howells <dhowells@redhat.com>
Date:   Wed Sep 2 09:14:21 2009 +0100

    KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]
    
    Add a keyctl to install a process's session keyring onto its parent.  This
    replaces the parent's session keyring.  Because the COW credential code does
    not permit one process to change another process's credentials directly, the
    change is deferred until userspace next starts executing again.  Normally this
    will be after a wait*() syscall.
    
    To support this, three new security hooks have been provided:
    cred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in
    the blank security creds and key_session_to_parent() - which asks the LSM if
    the process may replace its parent's session keyring.
    
    The replacement may only happen if the process has the same ownership details
    as its parent, and the process has LINK permission on the session keyring, and
    the session keyring is owned by the process, and the LSM permits it.
    
    Note that this requires alteration to each architecture's notify_resume path.
    This has been done for all arches barring blackfin, m68k* and xtensa, all of
    which need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the
    replacement to be performed at the point the parent process resumes userspace
    execution.
    
    This allows the userspace AFS pioctl emulation to fully emulate newpag() and
    the VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to
    alter the parent process's PAG membership.  However, since kAFS doesn't use
    PAGs per se, but rather dumps the keys into the session keyring, the session
    keyring of the parent must be replaced if, for example, VIOCSETTOK is passed
    the newpag flag.
    
    This can be tested with the following program:
    
            #include <stdio.h>
            #include <stdlib.h>
            #include <keyutils.h>
    
            #define KEYCTL_SESSION_TO_PARENT        18
    
            #define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)
    
            int main(int argc, char **argv)
            {
                    key_serial_t keyring, key;
                    long ret;
    
                    keyring = keyctl_join_session_keyring(argv[1]);
                    OSERROR(keyring, "keyctl_join_session_keyring");
    
                    key = add_key("user", "a", "b", 1, keyring);
                    OSERROR(key, "add_key");
    
                    ret = keyctl(KEYCTL_SESSION_TO_PARENT);
                    OSERROR(ret, "KEYCTL_SESSION_TO_PARENT");
    
                    return 0;
            }
    
    Compiled and linked with -lkeyutils, you should see something like:
    
            [dhowells@andromeda ~]$ keyctl show
            Session Keyring
                   -3 --alswrv   4043  4043  keyring: _ses
            355907932 --alswrv   4043    -1   \_ keyring: _uid.4043
            [dhowells@andromeda ~]$ /tmp/newpag
            [dhowells@andromeda ~]$ keyctl show
            Session Keyring
                   -3 --alswrv   4043  4043  keyring: _ses
            1055658746 --alswrv   4043  4043   \_ user: a
            [dhowells@andromeda ~]$ /tmp/newpag hello
            [dhowells@andromeda ~]$ keyctl show
            Session Keyring
                   -3 --alswrv   4043  4043  keyring: hello
            340417692 --alswrv   4043  4043   \_ user: a
    
    Where the test program creates a new session keyring, sticks a user key named
    'a' into it and then installs it on its parent.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 33e0165de100..cd50dfa1d4c2 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -278,6 +278,8 @@ static inline key_serial_t key_serial(struct key *key)
 extern ctl_table key_sysctls[];
 #endif
 
+extern void key_replace_session_keyring(void);
+
 /*
  * the userspace interface
  */
@@ -300,6 +302,7 @@ extern void key_init(void);
 #define key_fsuid_changed(t)		do { } while(0)
 #define key_fsgid_changed(t)		do { } while(0)
 #define key_init()			do { } while(0)
+#define key_replace_session_keyring()	do { } while(0)
 
 #endif /* CONFIG_KEYS */
 #endif /* __KERNEL__ */

commit 5d135440faf7db8d566de0c6fab36b16cf9cfc3b
Author: David Howells <dhowells@redhat.com>
Date:   Wed Sep 2 09:14:00 2009 +0100

    KEYS: Add garbage collection for dead, revoked and expired keys. [try #6]
    
    Add garbage collection for dead, revoked and expired keys.  This involved
    erasing all links to such keys from keyrings that point to them.  At that
    point, the key will be deleted in the normal manner.
    
    Keyrings from which garbage collection occurs are shrunk and their quota
    consumption reduced as appropriate.
    
    Dead keys (for which the key type has been removed) will be garbage collected
    immediately.
    
    Revoked and expired keys will hang around for a number of seconds, as set in
    /proc/sys/kernel/keys/gc_delay before being automatically removed.  The default
    is 5 minutes.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index e544f466d69a..33e0165de100 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -129,7 +129,10 @@ struct key {
 	struct rw_semaphore	sem;		/* change vs change sem */
 	struct key_user		*user;		/* owner of this key */
 	void			*security;	/* security data for this key */
-	time_t			expiry;		/* time at which key expires (or 0) */
+	union {
+		time_t		expiry;		/* time at which key expires (or 0) */
+		time_t		revoked_at;	/* time at which key was revoked */
+	};
 	uid_t			uid;
 	gid_t			gid;
 	key_perm_t		perm;		/* access permissions */

commit aa84442d674ef83e1cbf2bce52a20ecff4ce515e
Author: Pekka Enberg <penberg@cs.helsinki.fi>
Date:   Tue Mar 24 10:54:46 2009 +0200

    kmemtrace, security: fix linux/key.h header file dependencies
    
    Impact: cleanup
    
    We want to remove percpu.h from rcupdate.h (for upcoming kmemtrace
    changes), but this is not possible currently without breaking the
    build because key.h has an implicit include file dependency on
    rwsem.h:
    
        CC [M]  fs/cifs/cifs_spnego.o
      In file included from include/keys/user-type.h:15,
                       from fs/cifs/cifs_spnego.c:24:
      include/linux/key.h:128: error: field sem has incomplete type
      make[2]: *** [fs/cifs/cifs_spnego.o] Error 1
      make[1]: *** [fs/cifs] Error 2
      make: *** [fs] Error 2
    
    Fix it by making the dependency explicit.
    
    Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Cc: Eduard - Gabriel Munteanu <eduard.munteanu@linux360.ro>
    LKML-Reference: <1237884886.25315.39.camel@penberg-laptop>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/key.h b/include/linux/key.h
index 21d32a142c00..e544f466d69a 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -20,6 +20,7 @@
 #include <linux/rbtree.h>
 #include <linux/rcupdate.h>
 #include <linux/sysctl.h>
+#include <linux/rwsem.h>
 #include <asm/atomic.h>
 
 #ifdef __KERNEL__

commit a6f76f23d297f70e2a6b3ec607f7aeeea9e37e8d
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:24 2008 +1100

    CRED: Make execve() take advantage of copy-on-write credentials
    
    Make execve() take advantage of copy-on-write credentials, allowing it to set
    up the credentials in advance, and then commit the whole lot after the point
    of no return.
    
    This patch and the preceding patches have been tested with the LTP SELinux
    testsuite.
    
    This patch makes several logical sets of alteration:
    
     (1) execve().
    
         The credential bits from struct linux_binprm are, for the most part,
         replaced with a single credentials pointer (bprm->cred).  This means that
         all the creds can be calculated in advance and then applied at the point
         of no return with no possibility of failure.
    
         I would like to replace bprm->cap_effective with:
    
            cap_isclear(bprm->cap_effective)
    
         but this seems impossible due to special behaviour for processes of pid 1
         (they always retain their parent's capability masks where normally they'd
         be changed - see cap_bprm_set_creds()).
    
         The following sequence of events now happens:
    
         (a) At the start of do_execve, the current task's cred_exec_mutex is
             locked to prevent PTRACE_ATTACH from obsoleting the calculation of
             creds that we make.
    
         (a) prepare_exec_creds() is then called to make a copy of the current
             task's credentials and prepare it.  This copy is then assigned to
             bprm->cred.
    
             This renders security_bprm_alloc() and security_bprm_free()
             unnecessary, and so they've been removed.
    
         (b) The determination of unsafe execution is now performed immediately
             after (a) rather than later on in the code.  The result is stored in
             bprm->unsafe for future reference.
    
         (c) prepare_binprm() is called, possibly multiple times.
    
             (i) This applies the result of set[ug]id binaries to the new creds
                 attached to bprm->cred.  Personality bit clearance is recorded,
                 but now deferred on the basis that the exec procedure may yet
                 fail.
    
             (ii) This then calls the new security_bprm_set_creds().  This should
                 calculate the new LSM and capability credentials into *bprm->cred.
    
                 This folds together security_bprm_set() and parts of
                 security_bprm_apply_creds() (these two have been removed).
                 Anything that might fail must be done at this point.
    
             (iii) bprm->cred_prepared is set to 1.
    
                 bprm->cred_prepared is 0 on the first pass of the security
                 calculations, and 1 on all subsequent passes.  This allows SELinux
                 in (ii) to base its calculations only on the initial script and
                 not on the interpreter.
    
         (d) flush_old_exec() is called to commit the task to execution.  This
             performs the following steps with regard to credentials:
    
             (i) Clear pdeath_signal and set dumpable on certain circumstances that
                 may not be covered by commit_creds().
    
             (ii) Clear any bits in current->personality that were deferred from
                 (c.i).
    
         (e) install_exec_creds() [compute_creds() as was] is called to install the
             new credentials.  This performs the following steps with regard to
             credentials:
    
             (i) Calls security_bprm_committing_creds() to apply any security
                 requirements, such as flushing unauthorised files in SELinux, that
                 must be done before the credentials are changed.
    
                 This is made up of bits of security_bprm_apply_creds() and
                 security_bprm_post_apply_creds(), both of which have been removed.
                 This function is not allowed to fail; anything that might fail
                 must have been done in (c.ii).
    
             (ii) Calls commit_creds() to apply the new credentials in a single
                 assignment (more or less).  Possibly pdeath_signal and dumpable
                 should be part of struct creds.
    
             (iii) Unlocks the task's cred_replace_mutex, thus allowing
                 PTRACE_ATTACH to take place.
    
             (iv) Clears The bprm->cred pointer as the credentials it was holding
                 are now immutable.
    
             (v) Calls security_bprm_committed_creds() to apply any security
                 alterations that must be done after the creds have been changed.
                 SELinux uses this to flush signals and signal handlers.
    
         (f) If an error occurs before (d.i), bprm_free() will call abort_creds()
             to destroy the proposed new credentials and will then unlock
             cred_replace_mutex.  No changes to the credentials will have been
             made.
    
     (2) LSM interface.
    
         A number of functions have been changed, added or removed:
    
         (*) security_bprm_alloc(), ->bprm_alloc_security()
         (*) security_bprm_free(), ->bprm_free_security()
    
             Removed in favour of preparing new credentials and modifying those.
    
         (*) security_bprm_apply_creds(), ->bprm_apply_creds()
         (*) security_bprm_post_apply_creds(), ->bprm_post_apply_creds()
    
             Removed; split between security_bprm_set_creds(),
             security_bprm_committing_creds() and security_bprm_committed_creds().
    
         (*) security_bprm_set(), ->bprm_set_security()
    
             Removed; folded into security_bprm_set_creds().
    
         (*) security_bprm_set_creds(), ->bprm_set_creds()
    
             New.  The new credentials in bprm->creds should be checked and set up
             as appropriate.  bprm->cred_prepared is 0 on the first call, 1 on the
             second and subsequent calls.
    
         (*) security_bprm_committing_creds(), ->bprm_committing_creds()
         (*) security_bprm_committed_creds(), ->bprm_committed_creds()
    
             New.  Apply the security effects of the new credentials.  This
             includes closing unauthorised files in SELinux.  This function may not
             fail.  When the former is called, the creds haven't yet been applied
             to the process; when the latter is called, they have.
    
             The former may access bprm->cred, the latter may not.
    
     (3) SELinux.
    
         SELinux has a number of changes, in addition to those to support the LSM
         interface changes mentioned above:
    
         (a) The bprm_security_struct struct has been removed in favour of using
             the credentials-under-construction approach.
    
         (c) flush_unauthorized_files() now takes a cred pointer and passes it on
             to inode_has_perm(), file_has_perm() and dentry_open().
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: James Morris <jmorris@namei.org>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 69ecf0934b02..21d32a142c00 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -278,7 +278,6 @@ extern ctl_table key_sysctls[];
  * the userspace interface
  */
 extern int install_thread_keyring_to_cred(struct cred *cred);
-extern int exec_keys(struct task_struct *tsk);
 extern void key_fsuid_changed(struct task_struct *tsk);
 extern void key_fsgid_changed(struct task_struct *tsk);
 extern void key_init(void);
@@ -294,7 +293,6 @@ extern void key_init(void);
 #define make_key_ref(k, p)		NULL
 #define key_ref_to_ptr(k)		NULL
 #define is_key_possessed(k)		0
-#define exec_keys(t)			do { } while(0)
 #define key_fsuid_changed(t)		do { } while(0)
 #define key_fsgid_changed(t)		do { } while(0)
 #define key_init()			do { } while(0)

commit d84f4f992cbd76e8f39c488cf0c5d123843923b1
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:23 2008 +1100

    CRED: Inaugurate COW credentials
    
    Inaugurate copy-on-write credentials management.  This uses RCU to manage the
    credentials pointer in the task_struct with respect to accesses by other tasks.
    A process may only modify its own credentials, and so does not need locking to
    access or modify its own credentials.
    
    A mutex (cred_replace_mutex) is added to the task_struct to control the effect
    of PTRACE_ATTACHED on credential calculations, particularly with respect to
    execve().
    
    With this patch, the contents of an active credentials struct may not be
    changed directly; rather a new set of credentials must be prepared, modified
    and committed using something like the following sequence of events:
    
            struct cred *new = prepare_creds();
            int ret = blah(new);
            if (ret < 0) {
                    abort_creds(new);
                    return ret;
            }
            return commit_creds(new);
    
    There are some exceptions to this rule: the keyrings pointed to by the active
    credentials may be instantiated - keyrings violate the COW rule as managing
    COW keyrings is tricky, given that it is possible for a task to directly alter
    the keys in a keyring in use by another task.
    
    To help enforce this, various pointers to sets of credentials, such as those in
    the task_struct, are declared const.  The purpose of this is compile-time
    discouragement of altering credentials through those pointers.  Once a set of
    credentials has been made public through one of these pointers, it may not be
    modified, except under special circumstances:
    
      (1) Its reference count may incremented and decremented.
    
      (2) The keyrings to which it points may be modified, but not replaced.
    
    The only safe way to modify anything else is to create a replacement and commit
    using the functions described in Documentation/credentials.txt (which will be
    added by a later patch).
    
    This patch and the preceding patches have been tested with the LTP SELinux
    testsuite.
    
    This patch makes several logical sets of alteration:
    
     (1) execve().
    
         This now prepares and commits credentials in various places in the
         security code rather than altering the current creds directly.
    
     (2) Temporary credential overrides.
    
         do_coredump() and sys_faccessat() now prepare their own credentials and
         temporarily override the ones currently on the acting thread, whilst
         preventing interference from other threads by holding cred_replace_mutex
         on the thread being dumped.
    
         This will be replaced in a future patch by something that hands down the
         credentials directly to the functions being called, rather than altering
         the task's objective credentials.
    
     (3) LSM interface.
    
         A number of functions have been changed, added or removed:
    
         (*) security_capset_check(), ->capset_check()
         (*) security_capset_set(), ->capset_set()
    
             Removed in favour of security_capset().
    
         (*) security_capset(), ->capset()
    
             New.  This is passed a pointer to the new creds, a pointer to the old
             creds and the proposed capability sets.  It should fill in the new
             creds or return an error.  All pointers, barring the pointer to the
             new creds, are now const.
    
         (*) security_bprm_apply_creds(), ->bprm_apply_creds()
    
             Changed; now returns a value, which will cause the process to be
             killed if it's an error.
    
         (*) security_task_alloc(), ->task_alloc_security()
    
             Removed in favour of security_prepare_creds().
    
         (*) security_cred_free(), ->cred_free()
    
             New.  Free security data attached to cred->security.
    
         (*) security_prepare_creds(), ->cred_prepare()
    
             New. Duplicate any security data attached to cred->security.
    
         (*) security_commit_creds(), ->cred_commit()
    
             New. Apply any security effects for the upcoming installation of new
             security by commit_creds().
    
         (*) security_task_post_setuid(), ->task_post_setuid()
    
             Removed in favour of security_task_fix_setuid().
    
         (*) security_task_fix_setuid(), ->task_fix_setuid()
    
             Fix up the proposed new credentials for setuid().  This is used by
             cap_set_fix_setuid() to implicitly adjust capabilities in line with
             setuid() changes.  Changes are made to the new credentials, rather
             than the task itself as in security_task_post_setuid().
    
         (*) security_task_reparent_to_init(), ->task_reparent_to_init()
    
             Removed.  Instead the task being reparented to init is referred
             directly to init's credentials.
    
             NOTE!  This results in the loss of some state: SELinux's osid no
             longer records the sid of the thread that forked it.
    
         (*) security_key_alloc(), ->key_alloc()
         (*) security_key_permission(), ->key_permission()
    
             Changed.  These now take cred pointers rather than task pointers to
             refer to the security context.
    
     (4) sys_capset().
    
         This has been simplified and uses less locking.  The LSM functions it
         calls have been merged.
    
     (5) reparent_to_kthreadd().
    
         This gives the current thread the same credentials as init by simply using
         commit_thread() to point that way.
    
     (6) __sigqueue_alloc() and switch_uid()
    
         __sigqueue_alloc() can't stop the target task from changing its creds
         beneath it, so this function gets a reference to the currently applicable
         user_struct which it then passes into the sigqueue struct it returns if
         successful.
    
         switch_uid() is now called from commit_creds(), and possibly should be
         folded into that.  commit_creds() should take care of protecting
         __sigqueue_alloc().
    
     (7) [sg]et[ug]id() and co and [sg]et_current_groups.
    
         The set functions now all use prepare_creds(), commit_creds() and
         abort_creds() to build and check a new set of credentials before applying
         it.
    
         security_task_set[ug]id() is called inside the prepared section.  This
         guarantees that nothing else will affect the creds until we've finished.
    
         The calling of set_dumpable() has been moved into commit_creds().
    
         Much of the functionality of set_user() has been moved into
         commit_creds().
    
         The get functions all simply access the data directly.
    
     (8) security_task_prctl() and cap_task_prctl().
    
         security_task_prctl() has been modified to return -ENOSYS if it doesn't
         want to handle a function, or otherwise return the return value directly
         rather than through an argument.
    
         Additionally, cap_task_prctl() now prepares a new set of credentials, even
         if it doesn't end up using it.
    
     (9) Keyrings.
    
         A number of changes have been made to the keyrings code:
    
         (a) switch_uid_keyring(), copy_keys(), exit_keys() and suid_keys() have
             all been dropped and built in to the credentials functions directly.
             They may want separating out again later.
    
         (b) key_alloc() and search_process_keyrings() now take a cred pointer
             rather than a task pointer to specify the security context.
    
         (c) copy_creds() gives a new thread within the same thread group a new
             thread keyring if its parent had one, otherwise it discards the thread
             keyring.
    
         (d) The authorisation key now points directly to the credentials to extend
             the search into rather pointing to the task that carries them.
    
         (e) Installing thread, process or session keyrings causes a new set of
             credentials to be created, even though it's not strictly necessary for
             process or session keyrings (they're shared).
    
    (10) Usermode helper.
    
         The usermode helper code now carries a cred struct pointer in its
         subprocess_info struct instead of a new session keyring pointer.  This set
         of credentials is derived from init_cred and installed on the new process
         after it has been cloned.
    
         call_usermodehelper_setup() allocates the new credentials and
         call_usermodehelper_freeinfo() discards them if they haven't been used.  A
         special cred function (prepare_usermodeinfo_creds()) is provided
         specifically for call_usermodehelper_setup() to call.
    
         call_usermodehelper_setkeys() adjusts the credentials to sport the
         supplied keyring as the new session keyring.
    
    (11) SELinux.
    
         SELinux has a number of changes, in addition to those to support the LSM
         interface changes mentioned above:
    
         (a) selinux_setprocattr() no longer does its check for whether the
             current ptracer can access processes with the new SID inside the lock
             that covers getting the ptracer's SID.  Whilst this lock ensures that
             the check is done with the ptracer pinned, the result is only valid
             until the lock is released, so there's no point doing it inside the
             lock.
    
    (12) is_single_threaded().
    
         This function has been extracted from selinux_setprocattr() and put into
         a file of its own in the lib/ directory as join_session_keyring() now
         wants to use it too.
    
         The code in SELinux just checked to see whether a task shared mm_structs
         with other tasks (CLONE_VM), but that isn't good enough.  We really want
         to know if they're part of the same thread group (CLONE_THREAD).
    
    (13) nfsd.
    
         The NFS server daemon now has to use the COW credentials to set the
         credentials it is going to use.  It really needs to pass the credentials
         down to the functions it calls, but it can't do that until other patches
         in this series have been applied.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: James Morris <jmorris@namei.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 0836cc838b0c..69ecf0934b02 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -73,6 +73,7 @@ struct key;
 struct seq_file;
 struct user_struct;
 struct signal_struct;
+struct cred;
 
 struct key_type;
 struct key_owner;
@@ -181,7 +182,7 @@ struct key {
 extern struct key *key_alloc(struct key_type *type,
 			     const char *desc,
 			     uid_t uid, gid_t gid,
-			     struct task_struct *ctx,
+			     const struct cred *cred,
 			     key_perm_t perm,
 			     unsigned long flags);
 
@@ -249,7 +250,7 @@ extern int key_unlink(struct key *keyring,
 		      struct key *key);
 
 extern struct key *keyring_alloc(const char *description, uid_t uid, gid_t gid,
-				 struct task_struct *ctx,
+				 const struct cred *cred,
 				 unsigned long flags,
 				 struct key *dest);
 
@@ -276,22 +277,12 @@ extern ctl_table key_sysctls[];
 /*
  * the userspace interface
  */
-extern void switch_uid_keyring(struct user_struct *new_user);
-extern int copy_keys(unsigned long clone_flags, struct task_struct *tsk);
-extern void exit_keys(struct task_struct *tsk);
-extern int suid_keys(struct task_struct *tsk);
+extern int install_thread_keyring_to_cred(struct cred *cred);
 extern int exec_keys(struct task_struct *tsk);
 extern void key_fsuid_changed(struct task_struct *tsk);
 extern void key_fsgid_changed(struct task_struct *tsk);
 extern void key_init(void);
 
-#define __install_session_keyring(keyring)				\
-({									\
-	struct key *old_session = current->cred->tgcred->session_keyring; \
-	current->cred->tgcred->session_keyring = keyring;		\
-	old_session;							\
-})
-
 #else /* CONFIG_KEYS */
 
 #define key_validate(k)			0
@@ -303,11 +294,6 @@ extern void key_init(void);
 #define make_key_ref(k, p)		NULL
 #define key_ref_to_ptr(k)		NULL
 #define is_key_possessed(k)		0
-#define switch_uid_keyring(u)		do { } while(0)
-#define __install_session_keyring(k)	({ NULL; })
-#define copy_keys(f,t)			0
-#define exit_keys(t)			do { } while(0)
-#define suid_keys(t)			do { } while(0)
 #define exec_keys(t)			do { } while(0)
 #define key_fsuid_changed(t)		do { } while(0)
 #define key_fsgid_changed(t)		do { } while(0)

commit bb952bb98a7e479262c7eb25d5592545a3af147d
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:20 2008 +1100

    CRED: Separate per-task-group keyrings from signal_struct
    
    Separate per-task-group keyrings from signal_struct and dangle their anchor
    from the cred struct rather than the signal_struct.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: James Morris <jmorris@namei.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index df709e1af3cd..0836cc838b0c 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -278,9 +278,7 @@ extern ctl_table key_sysctls[];
  */
 extern void switch_uid_keyring(struct user_struct *new_user);
 extern int copy_keys(unsigned long clone_flags, struct task_struct *tsk);
-extern int copy_thread_group_keys(struct task_struct *tsk);
 extern void exit_keys(struct task_struct *tsk);
-extern void exit_thread_group_keys(struct signal_struct *tg);
 extern int suid_keys(struct task_struct *tsk);
 extern int exec_keys(struct task_struct *tsk);
 extern void key_fsuid_changed(struct task_struct *tsk);
@@ -289,8 +287,8 @@ extern void key_init(void);
 
 #define __install_session_keyring(keyring)				\
 ({									\
-	struct key *old_session = current->signal->session_keyring;	\
-	current->signal->session_keyring = keyring;			\
+	struct key *old_session = current->cred->tgcred->session_keyring; \
+	current->cred->tgcred->session_keyring = keyring;		\
 	old_session;							\
 })
 
@@ -308,9 +306,7 @@ extern void key_init(void);
 #define switch_uid_keyring(u)		do { } while(0)
 #define __install_session_keyring(k)	({ NULL; })
 #define copy_keys(f,t)			0
-#define copy_thread_group_keys(t)	0
 #define exit_keys(t)			do { } while(0)
-#define exit_thread_group_keys(tg)	do { } while(0)
 #define suid_keys(t)			do { } while(0)
 #define exec_keys(t)			do { } while(0)
 #define key_fsuid_changed(t)		do { } while(0)

commit 8bbf4976b59fc9fc2861e79cab7beb3f6d647640
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:14 2008 +1100

    KEYS: Alter use of key instantiation link-to-keyring argument
    
    Alter the use of the key instantiation and negation functions' link-to-keyring
    arguments.  Currently this specifies a keyring in the target process to link
    the key into, creating the keyring if it doesn't exist.  This, however, can be
    a problem for copy-on-write credentials as it means that the instantiating
    process can alter the credentials of the requesting process.
    
    This patch alters the behaviour such that:
    
     (1) If keyctl_instantiate_key() or keyctl_negate_key() are given a specific
         keyring by ID (ringid >= 0), then that keyring will be used.
    
     (2) If keyctl_instantiate_key() or keyctl_negate_key() are given one of the
         special constants that refer to the requesting process's keyrings
         (KEY_SPEC_*_KEYRING, all <= 0), then:
    
         (a) If sys_request_key() was given a keyring to use (destringid) then the
             key will be attached to that keyring.
    
         (b) If sys_request_key() was given a NULL keyring, then the key being
             instantiated will be attached to the default keyring as set by
             keyctl_set_reqkey_keyring().
    
     (3) No extra link will be made.
    
    Decision point (1) follows current behaviour, and allows those instantiators
    who've searched for a specifically named keyring in the requestor's keyring so
    as to partition the keys by type to still have their named keyrings.
    
    Decision point (2) allows the requestor to make sure that the key or keys that
    get produced by request_key() go where they want, whilst allowing the
    instantiator to request that the key is retained.  This is mainly useful for
    situations where the instantiator makes a secondary request, the key for which
    should be retained by the initial requestor:
    
            +-----------+        +--------------+        +--------------+
            |           |        |              |        |              |
            | Requestor |------->| Instantiator |------->| Instantiator |
            |           |        |              |        |              |
            +-----------+        +--------------+        +--------------+
                       request_key()           request_key()
    
    This might be useful, for example, in Kerberos, where the requestor requests a
    ticket, and then the ticket instantiator requests the TGT, which someone else
    then has to go and fetch.  The TGT, however, should be retained in the
    keyrings of the requestor, not the first instantiator.  To make this explict
    an extra special keyring constant is also added.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: James Morris <jmorris@namei.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 1b70e35a71e3..df709e1af3cd 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -287,11 +287,11 @@ extern void key_fsuid_changed(struct task_struct *tsk);
 extern void key_fsgid_changed(struct task_struct *tsk);
 extern void key_init(void);
 
-#define __install_session_keyring(tsk, keyring)			\
-({								\
-	struct key *old_session = tsk->signal->session_keyring;	\
-	tsk->signal->session_keyring = keyring;			\
-	old_session;						\
+#define __install_session_keyring(keyring)				\
+({									\
+	struct key *old_session = current->signal->session_keyring;	\
+	current->signal->session_keyring = keyring;			\
+	old_session;							\
 })
 
 #else /* CONFIG_KEYS */
@@ -302,11 +302,11 @@ extern void key_init(void);
 #define key_revoke(k)			do { } while(0)
 #define key_put(k)			do { } while(0)
 #define key_ref_put(k)			do { } while(0)
-#define make_key_ref(k, p)			({ NULL; })
-#define key_ref_to_ptr(k)		({ NULL; })
+#define make_key_ref(k, p)		NULL
+#define key_ref_to_ptr(k)		NULL
 #define is_key_possessed(k)		0
 #define switch_uid_keyring(u)		do { } while(0)
-#define __install_session_keyring(t, k)	({ NULL; })
+#define __install_session_keyring(k)	({ NULL; })
 #define copy_keys(f,t)			0
 #define copy_thread_group_keys(t)	0
 #define exit_keys(t)			do { } while(0)

commit 0dab9cfa17179d1f5b067a32a3bca06cd31a3149
Author: Adrian Bunk <bunk@kernel.org>
Date:   Sun Oct 12 07:10:50 2008 +0300

    add key_revoke() dummy for KEYS=n
    
    This fixes the following build error with CONFIG_KEYS=n, caused by
    commit dfd15c46a6c2cafb006183c0c14f07e59eee4ac0 ("cifs: explicitly
    revoke SPNEGO key after session setup"):
    
        CC [M]  fs/cifs/sess.o
      fs/cifs/sess.c: In function 'CIFS_SessSetup':
      fs/cifs/sess.c:628: error: implicit declaration of function 'key_revoke'
      make[3]: *** [fs/cifs/sess.o] Error 1
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index c45c962d1cc5..1b70e35a71e3 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -299,6 +299,7 @@ extern void key_init(void);
 #define key_validate(k)			0
 #define key_serial(k)			0
 #define key_get(k) 			({ NULL; })
+#define key_revoke(k)			do { } while(0)
 #define key_put(k)			do { } while(0)
 #define key_ref_put(k)			do { } while(0)
 #define make_key_ref(k, p)			({ NULL; })

commit 7249db2c281ac688977ecc6862cdee9969d310e2
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 29 01:01:34 2008 -0700

    keys: make key_serial() a function if CONFIG_KEYS=y
    
    Make key_serial() an inline function rather than a macro if CONFIG_KEYS=y.
    This prevents double evaluation of the key pointer and also provides better
    type checking.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index ad02d9cfe170..c45c962d1cc5 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -264,7 +264,10 @@ extern int keyring_add_key(struct key *keyring,
 
 extern struct key *key_lookup(key_serial_t id);
 
-#define key_serial(key) ((key) ? (key)->serial : 0)
+static inline key_serial_t key_serial(struct key *key)
+{
+	return key ? key->serial : 0;
+}
 
 #ifdef CONFIG_SYSCTL
 extern ctl_table key_sysctls[];

commit 0b77f5bfb45c13e1e5142374f9d6ca75292252a4
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 29 01:01:32 2008 -0700

    keys: make the keyring quotas controllable through /proc/sys
    
    Make the keyring quotas controllable through /proc/sys files:
    
     (*) /proc/sys/kernel/keys/root_maxkeys
         /proc/sys/kernel/keys/root_maxbytes
    
         Maximum number of keys that root may have and the maximum total number of
         bytes of data that root may have stored in those keys.
    
     (*) /proc/sys/kernel/keys/maxkeys
         /proc/sys/kernel/keys/maxbytes
    
         Maximum number of keys that each non-root user may have and the maximum
         total number of bytes of data that each of those users may have stored in
         their keys.
    
    Also increase the quotas as a number of people have been complaining that it's
    not big enough.  I'm not sure that it's big enough now either, but on the
    other hand, it can now be set in /etc/sysctl.conf.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: <kwc@citi.umich.edu>
    Cc: <arunsr@cse.iitk.ac.in>
    Cc: <dwalsh@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 2effd031a817..ad02d9cfe170 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -19,6 +19,7 @@
 #include <linux/list.h>
 #include <linux/rbtree.h>
 #include <linux/rcupdate.h>
+#include <linux/sysctl.h>
 #include <asm/atomic.h>
 
 #ifdef __KERNEL__
@@ -265,6 +266,10 @@ extern struct key *key_lookup(key_serial_t id);
 
 #define key_serial(key) ((key) ? (key)->serial : 0)
 
+#ifdef CONFIG_SYSCTL
+extern ctl_table key_sysctls[];
+#endif
+
 /*
  * the userspace interface
  */

commit 69664cf16af4f31cd54d77948a4baf9c7e0ca7b9
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 29 01:01:31 2008 -0700

    keys: don't generate user and user session keyrings unless they're accessed
    
    Don't generate the per-UID user and user session keyrings unless they're
    explicitly accessed.  This solves a problem during a login process whereby
    set*uid() is called before the SELinux PAM module, resulting in the per-UID
    keyrings having the wrong security labels.
    
    This also cures the problem of multiple per-UID keyrings sometimes appearing
    due to PAM modules (including pam_keyinit) setuiding and causing user_structs
    to come into and go out of existence whilst the session keyring pins the user
    keyring.  This is achieved by first searching for extant per-UID keyrings
    before inventing new ones.
    
    The serial bound argument is also dropped from find_keyring_by_name() as it's
    not currently made use of (setting it to 0 disables the feature).
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: <kwc@citi.umich.edu>
    Cc: <arunsr@cse.iitk.ac.in>
    Cc: <dwalsh@redhat.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: James Morris <jmorris@namei.org>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 8b0bd3393abc..2effd031a817 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -268,9 +268,6 @@ extern struct key *key_lookup(key_serial_t id);
 /*
  * the userspace interface
  */
-extern struct key root_user_keyring, root_session_keyring;
-extern int alloc_uid_keyring(struct user_struct *user,
-			     struct task_struct *ctx);
 extern void switch_uid_keyring(struct user_struct *new_user);
 extern int copy_keys(unsigned long clone_flags, struct task_struct *tsk);
 extern int copy_thread_group_keys(struct task_struct *tsk);
@@ -299,7 +296,6 @@ extern void key_init(void);
 #define make_key_ref(k, p)			({ NULL; })
 #define key_ref_to_ptr(k)		({ NULL; })
 #define is_key_possessed(k)		0
-#define alloc_uid_keyring(u,c)		0
 #define switch_uid_keyring(u)		do { } while(0)
 #define __install_session_keyring(t, k)	({ NULL; })
 #define copy_keys(f,t)			0
@@ -312,10 +308,6 @@ extern void key_init(void);
 #define key_fsgid_changed(t)		do { } while(0)
 #define key_init()			do { } while(0)
 
-/* Initial keyrings */
-extern struct key root_user_keyring;
-extern struct key root_session_keyring;
-
 #endif /* CONFIG_KEYS */
 #endif /* __KERNEL__ */
 #endif /* _LINUX_KEY_H */

commit 6b79ccb5144f9ffb4d4596c23e7570238dd12abc
Author: Arun Raghavan <arunsr@cse.iitk.ac.in>
Date:   Tue Apr 29 01:01:28 2008 -0700

    keys: allow clients to set key perms in key_create_or_update()
    
    The key_create_or_update() function provided by the keyring code has a default
    set of permissions that are always applied to the key when created.  This
    might not be desirable to all clients.
    
    Here's a patch that adds a "perm" parameter to the function to address this,
    which can be set to KEY_PERM_UNDEF to revert to the current behaviour.
    
    Signed-off-by: Arun Raghavan <arunsr@cse.iitk.ac.in>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: Satyam Sharma <ssatyam@cse.iitk.ac.in>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 163f864b6bd4..8b0bd3393abc 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -67,6 +67,8 @@ struct key;
 #define KEY_OTH_SETATTR	0x00000020
 #define KEY_OTH_ALL	0x0000003f
 
+#define KEY_PERM_UNDEF	0xffffffff
+
 struct seq_file;
 struct user_struct;
 struct signal_struct;
@@ -232,6 +234,7 @@ extern key_ref_t key_create_or_update(key_ref_t keyring,
 				      const char *description,
 				      const void *payload,
 				      size_t plen,
+				      key_perm_t perm,
 				      unsigned long flags);
 
 extern int key_update(key_ref_t key,

commit 4a38e122e2cc6294779021ff4ccc784a3997059e
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 29 01:01:24 2008 -0700

    keys: allow the callout data to be passed as a blob rather than a string
    
    Allow the callout data to be passed as a blob rather than a string for
    internal kernel services that call any request_key_*() interface other than
    request_key().  request_key() itself still takes a NUL-terminated string.
    
    The functions that change are:
    
            request_key_with_auxdata()
            request_key_async()
            request_key_async_with_auxdata()
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: Paul Moore <paul.moore@hp.com>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: James Morris <jmorris@namei.org>
    Cc: Kevin Coffman <kwc@citi.umich.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index a70b8a8f2005..163f864b6bd4 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -208,16 +208,19 @@ extern struct key *request_key(struct key_type *type,
 
 extern struct key *request_key_with_auxdata(struct key_type *type,
 					    const char *description,
-					    const char *callout_info,
+					    const void *callout_info,
+					    size_t callout_len,
 					    void *aux);
 
 extern struct key *request_key_async(struct key_type *type,
 				     const char *description,
-				     const char *callout_info);
+				     const void *callout_info,
+				     size_t callout_len);
 
 extern struct key *request_key_async_with_auxdata(struct key_type *type,
 						  const char *description,
-						  const char *callout_info,
+						  const void *callout_info,
+						  size_t callout_len,
 						  void *aux);
 
 extern int wait_for_key_construction(struct key *key, bool intr);

commit 5b7741b3325d0d94c88b2ad46657a536890aaa2f
Author: Sebastian Siewior <sebastian@breakpoint.cc>
Date:   Tue Jan 8 15:32:47 2008 -0800

    KEYS: fix macro
    
    Commit 664cceb0093b755739e56572b836a99104ee8a75 changed the parameters of
    the function make_key_ref().  The macros that are used in case CONFIG_KEY
    is not defined did not change.
    
    Cc: David Howells <dhowells@redhat.com>
    Signed-off-by: Sebastian Siewior <sebastian@breakpoint.cc>
    Acked-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index fcdbd5ed227b..a70b8a8f2005 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -290,7 +290,7 @@ extern void key_init(void);
 #define key_get(k) 			({ NULL; })
 #define key_put(k)			do { } while(0)
 #define key_ref_put(k)			do { } while(0)
-#define make_key_ref(k)			({ NULL; })
+#define make_key_ref(k, p)			({ NULL; })
 #define key_ref_to_ptr(k)		({ NULL; })
 #define is_key_possessed(k)		0
 #define alloc_uid_keyring(u,c)		0

commit 76181c134f87479fa13bf2548ddf2999055d34d4
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 16 23:29:46 2007 -0700

    KEYS: Make request_key() and co fundamentally asynchronous
    
    Make request_key() and co fundamentally asynchronous to make it easier for
    NFS to make use of them.  There are now accessor functions that do
    asynchronous constructions, a wait function to wait for construction to
    complete, and a completion function for the key type to indicate completion
    of construction.
    
    Note that the construction queue is now gone.  Instead, keys under
    construction are linked in to the appropriate keyring in advance, and that
    anyone encountering one must wait for it to be complete before they can use
    it.  This is done automatically for userspace.
    
    The following auxiliary changes are also made:
    
     (1) Key type implementation stuff is split from linux/key.h into
         linux/key-type.h.
    
     (2) AF_RXRPC provides a way to allocate null rxrpc-type keys so that AFS does
         not need to call key_instantiate_and_link() directly.
    
     (3) Adjust the debugging macros so that they're -Wformat checked even if
         they are disabled, and make it so they can be enabled simply by defining
         __KDEBUG to be consistent with other code of mine.
    
     (3) Documentation.
    
    [alan@lxorguk.ukuu.org.uk: keys: missing word in documentation]
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index a9220e75782e..fcdbd5ed227b 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -1,6 +1,6 @@
-/* key.h: authentication token and access key management
+/* Authentication token and access key management
  *
- * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.
+ * Copyright (C) 2004, 2007 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
  *
  * This program is free software; you can redistribute it and/or
@@ -175,78 +175,6 @@ struct key {
 	} payload;
 };
 
-/*****************************************************************************/
-/*
- * kernel managed key type definition
- */
-typedef int (*request_key_actor_t)(struct key *key, struct key *authkey,
-				   const char *op, void *aux);
-
-struct key_type {
-	/* name of the type */
-	const char *name;
-
-	/* default payload length for quota precalculation (optional)
-	 * - this can be used instead of calling key_payload_reserve(), that
-	 *   function only needs to be called if the real datalen is different
-	 */
-	size_t def_datalen;
-
-	/* instantiate a key of this type
-	 * - this method should call key_payload_reserve() to determine if the
-	 *   user's quota will hold the payload
-	 */
-	int (*instantiate)(struct key *key, const void *data, size_t datalen);
-
-	/* update a key of this type (optional)
-	 * - this method should call key_payload_reserve() to recalculate the
-	 *   quota consumption
-	 * - the key must be locked against read when modifying
-	 */
-	int (*update)(struct key *key, const void *data, size_t datalen);
-
-	/* match a key against a description */
-	int (*match)(const struct key *key, const void *desc);
-
-	/* clear some of the data from a key on revokation (optional)
-	 * - the key's semaphore will be write-locked by the caller
-	 */
-	void (*revoke)(struct key *key);
-
-	/* clear the data from a key (optional) */
-	void (*destroy)(struct key *key);
-
-	/* describe a key */
-	void (*describe)(const struct key *key, struct seq_file *p);
-
-	/* read a key's data (optional)
-	 * - permission checks will be done by the caller
-	 * - the key's semaphore will be readlocked by the caller
-	 * - should return the amount of data that could be read, no matter how
-	 *   much is copied into the buffer
-	 * - shouldn't do the copy if the buffer is NULL
-	 */
-	long (*read)(const struct key *key, char __user *buffer, size_t buflen);
-
-	/* handle request_key() for this type instead of invoking
-	 * /sbin/request-key (optional)
-	 * - key is the key to instantiate
-	 * - authkey is the authority to assume when instantiating this key
-	 * - op is the operation to be done, usually "create"
-	 * - the call must not return until the instantiation process has run
-	 *   its course
-	 */
-	request_key_actor_t request_key;
-
-	/* internal fields */
-	struct list_head	link;		/* link in types list */
-};
-
-extern struct key_type key_type_keyring;
-
-extern int register_key_type(struct key_type *ktype);
-extern void unregister_key_type(struct key_type *ktype);
-
 extern struct key *key_alloc(struct key_type *type,
 			     const char *desc,
 			     uid_t uid, gid_t gid,
@@ -259,16 +187,6 @@ extern struct key *key_alloc(struct key_type *type,
 #define KEY_ALLOC_QUOTA_OVERRUN	0x0001	/* add to quota, permit even if overrun */
 #define KEY_ALLOC_NOT_IN_QUOTA	0x0002	/* not in quota */
 
-extern int key_payload_reserve(struct key *key, size_t datalen);
-extern int key_instantiate_and_link(struct key *key,
-				    const void *data,
-				    size_t datalen,
-				    struct key *keyring,
-				    struct key *instkey);
-extern int key_negate_and_link(struct key *key,
-			       unsigned timeout,
-			       struct key *keyring,
-			       struct key *instkey);
 extern void key_revoke(struct key *key);
 extern void key_put(struct key *key);
 
@@ -293,6 +211,17 @@ extern struct key *request_key_with_auxdata(struct key_type *type,
 					    const char *callout_info,
 					    void *aux);
 
+extern struct key *request_key_async(struct key_type *type,
+				     const char *description,
+				     const char *callout_info);
+
+extern struct key *request_key_async_with_auxdata(struct key_type *type,
+						  const char *description,
+						  const char *callout_info,
+						  void *aux);
+
+extern int wait_for_key_construction(struct key *key, bool intr);
+
 extern int key_validate(struct key *key);
 
 extern key_ref_t key_create_or_update(key_ref_t keyring,
@@ -328,8 +257,6 @@ extern int keyring_add_key(struct key *keyring,
 
 extern struct key *key_lookup(key_serial_t id);
 
-extern void keyring_replace_payload(struct key *key, void *replacement);
-
 #define key_serial(key) ((key) ? (key)->serial : 0)
 
 /*

commit 7318226ea2931a627f3572e5f4804c91ca19ecbc
Author: David Howells <dhowells@redhat.com>
Date:   Thu Apr 26 15:46:23 2007 -0700

    [AF_RXRPC]: Key facility changes for AF_RXRPC
    
    Export the keyring key type definition and document its availability.
    
    Add alternative types into the key's type_data union to make it more useful.
    Not all users necessarily want to use it as a list_head (AF_RXRPC doesn't, for
    example), so make it clear that it can be used in other ways.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/key.h b/include/linux/key.h
index 169f05e4863e..a9220e75782e 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -160,6 +160,8 @@ struct key {
 	 */
 	union {
 		struct list_head	link;
+		unsigned long		x[2];
+		void			*p[2];
 	} type_data;
 
 	/* key data

commit 4e54f08543d05e519e601368571cc3787fefae96
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jun 29 02:24:28 2006 -0700

    [PATCH] Keys: Allow in-kernel key requestor to pass auxiliary data to upcaller
    
    The proposed NFS key type uses its own method of passing key requests to
    userspace (upcalling) rather than invoking /sbin/request-key.  This is
    because the responsible userspace daemon should already be running and will
    be contacted through rpc_pipefs.
    
    This patch permits the NFS filesystem to pass auxiliary data to the upcall
    operation (struct key_type::request_key) so that the upcaller can use a
    pre-existing communications channel more easily.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-By: Kevin Coffman <kwc@citi.umich.edu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index e693e729bc92..169f05e4863e 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -177,7 +177,8 @@ struct key {
 /*
  * kernel managed key type definition
  */
-typedef int (*request_key_actor_t)(struct key *key, struct key *authkey, const char *op);
+typedef int (*request_key_actor_t)(struct key *key, struct key *authkey,
+				   const char *op, void *aux);
 
 struct key_type {
 	/* name of the type */
@@ -285,6 +286,11 @@ extern struct key *request_key(struct key_type *type,
 			       const char *description,
 			       const char *callout_info);
 
+extern struct key *request_key_with_auxdata(struct key_type *type,
+					    const char *description,
+					    const char *callout_info,
+					    void *aux);
+
 extern int key_validate(struct key *key);
 
 extern key_ref_t key_create_or_update(key_ref_t keyring,

commit 7e047ef5fe2d52e83020e856b1bf2556a6a2ce98
Author: David Howells <dhowells@redhat.com>
Date:   Mon Jun 26 00:24:50 2006 -0700

    [PATCH] keys: sort out key quota system
    
    Add the ability for key creation to overrun the user's quota in some
    circumstances - notably when a session keyring is created and assigned to a
    process that didn't previously have one.
    
    This means it's still possible to log in, should PAM require the creation of a
    new session keyring, and fix an overburdened key quota.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index e81ebf910d0b..e693e729bc92 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -248,7 +248,14 @@ extern struct key *key_alloc(struct key_type *type,
 			     const char *desc,
 			     uid_t uid, gid_t gid,
 			     struct task_struct *ctx,
-			     key_perm_t perm, int not_in_quota);
+			     key_perm_t perm,
+			     unsigned long flags);
+
+
+#define KEY_ALLOC_IN_QUOTA	0x0000	/* add to quota, reject if would overrun */
+#define KEY_ALLOC_QUOTA_OVERRUN	0x0001	/* add to quota, permit even if overrun */
+#define KEY_ALLOC_NOT_IN_QUOTA	0x0002	/* not in quota */
+
 extern int key_payload_reserve(struct key *key, size_t datalen);
 extern int key_instantiate_and_link(struct key *key,
 				    const void *data,
@@ -285,7 +292,7 @@ extern key_ref_t key_create_or_update(key_ref_t keyring,
 				      const char *description,
 				      const void *payload,
 				      size_t plen,
-				      int not_in_quota);
+				      unsigned long flags);
 
 extern int key_update(key_ref_t key,
 		      const void *payload,
@@ -299,7 +306,7 @@ extern int key_unlink(struct key *keyring,
 
 extern struct key *keyring_alloc(const char *description, uid_t uid, gid_t gid,
 				 struct task_struct *ctx,
-				 int not_in_quota,
+				 unsigned long flags,
 				 struct key *dest);
 
 extern int keyring_clear(struct key *keyring);

commit 04c567d9313e4927b9835361d8ac0318ce65af6b
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jun 22 14:47:18 2006 -0700

    [PATCH] Keys: Fix race between two instantiators of a key
    
    Add a revocation notification method to the key type and calls it whilst
    the key's semaphore is still write-locked after setting the revocation
    flag.
    
    The patch then uses this to maintain a reference on the task_struct of the
    process that calls request_key() for as long as the authorisation key
    remains unrevoked.
    
    This fixes a potential race between two processes both of which have
    assumed the authority to instantiate a key (one may have forked the other
    for example).  The problem is that there's no locking around the check for
    revocation of the auth key and the use of the task_struct it points to, nor
    does the auth key keep a reference on the task_struct.
    
    Access to the "context" pointer in the auth key must thenceforth be done
    with the auth key semaphore held.  The revocation method is called with the
    target key semaphore held write-locked and the search of the context
    process's keyrings is done with the auth key semaphore read-locked.
    
    The check for the revocation state of the auth key just prior to searching
    it is done after the auth key is read-locked for the search.  This ensures
    that the auth key can't be revoked between the check and the search.
    
    The revocation notification method is added so that the context task_struct
    can be released as soon as instantiation happens rather than waiting for
    the auth key to be destroyed, thus avoiding the unnecessary pinning of the
    requesting process.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 8c275d12ef63..e81ebf910d0b 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -205,6 +205,11 @@ struct key_type {
 	/* match a key against a description */
 	int (*match)(const struct key *key, const void *desc);
 
+	/* clear some of the data from a key on revokation (optional)
+	 * - the key's semaphore will be write-locked by the caller
+	 */
+	void (*revoke)(struct key *key);
+
 	/* clear the data from a key (optional) */
 	void (*destroy)(struct key *key);
 

commit d720024e94de4e8b7f10ee83c532926f3ad5d708
Author: Michael LeMay <mdlemay@epoch.ncsc.mil>
Date:   Thu Jun 22 14:47:17 2006 -0700

    [PATCH] selinux: add hooks for key subsystem
    
    Introduce SELinux hooks to support the access key retention subsystem
    within the kernel.  Incorporate new flask headers from a modified version
    of the SELinux reference policy, with support for the new security class
    representing retained keys.  Extend the "key_alloc" security hook with a
    task parameter representing the intended ownership context for the key
    being allocated.  Attach security information to root's default keyrings
    within the SELinux initialization routine.
    
    Has passed David's testsuite.
    
    Signed-off-by: Michael LeMay <mdlemay@epoch.ncsc.mil>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>
    Acked-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index cbf464ad9589..8c275d12ef63 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -241,8 +241,9 @@ extern void unregister_key_type(struct key_type *ktype);
 
 extern struct key *key_alloc(struct key_type *type,
 			     const char *desc,
-			     uid_t uid, gid_t gid, key_perm_t perm,
-			     int not_in_quota);
+			     uid_t uid, gid_t gid,
+			     struct task_struct *ctx,
+			     key_perm_t perm, int not_in_quota);
 extern int key_payload_reserve(struct key *key, size_t datalen);
 extern int key_instantiate_and_link(struct key *key,
 				    const void *data,
@@ -292,7 +293,9 @@ extern int key_unlink(struct key *keyring,
 		      struct key *key);
 
 extern struct key *keyring_alloc(const char *description, uid_t uid, gid_t gid,
-				 int not_in_quota, struct key *dest);
+				 struct task_struct *ctx,
+				 int not_in_quota,
+				 struct key *dest);
 
 extern int keyring_clear(struct key *keyring);
 
@@ -313,7 +316,8 @@ extern void keyring_replace_payload(struct key *key, void *replacement);
  * the userspace interface
  */
 extern struct key root_user_keyring, root_session_keyring;
-extern int alloc_uid_keyring(struct user_struct *user);
+extern int alloc_uid_keyring(struct user_struct *user,
+			     struct task_struct *ctx);
 extern void switch_uid_keyring(struct user_struct *new_user);
 extern int copy_keys(unsigned long clone_flags, struct task_struct *tsk);
 extern int copy_thread_group_keys(struct task_struct *tsk);
@@ -342,7 +346,7 @@ extern void key_init(void);
 #define make_key_ref(k)			({ NULL; })
 #define key_ref_to_ptr(k)		({ NULL; })
 #define is_key_possessed(k)		0
-#define alloc_uid_keyring(u)		0
+#define alloc_uid_keyring(u,c)		0
 #define switch_uid_keyring(u)		do { } while(0)
 #define __install_session_keyring(t, k)	({ NULL; })
 #define copy_keys(f,t)			0
@@ -355,6 +359,10 @@ extern void key_init(void);
 #define key_fsgid_changed(t)		do { } while(0)
 #define key_init()			do { } while(0)
 
+/* Initial keyrings */
+extern struct key root_user_keyring;
+extern struct key root_session_keyring;
+
 #endif /* CONFIG_KEYS */
 #endif /* __KERNEL__ */
 #endif /* _LINUX_KEY_H */

commit b5f545c880a2a47947ba2118b2509644ab7a2969
Author: David Howells <dhowells@redhat.com>
Date:   Sun Jan 8 01:02:47 2006 -0800

    [PATCH] keys: Permit running process to instantiate keys
    
    Make it possible for a running process (such as gssapid) to be able to
    instantiate a key, as was requested by Trond Myklebust for NFS4.
    
    The patch makes the following changes:
    
     (1) A new, optional key type method has been added. This permits a key type
         to intercept requests at the point /sbin/request-key is about to be
         spawned and do something else with them - passing them over the
         rpc_pipefs files or netlink sockets for instance.
    
         The uninstantiated key, the authorisation key and the intended operation
         name are passed to the method.
    
     (2) The callout_info is no longer passed as an argument to /sbin/request-key
         to prevent unauthorised viewing of this data using ps or by looking in
         /proc/pid/cmdline.
    
         This means that the old /sbin/request-key program will not work with the
         patched kernel as it will expect to see an extra argument that is no
         longer there.
    
         A revised keyutils package will be made available tomorrow.
    
     (3) The callout_info is now attached to the authorisation key. Reading this
         key will retrieve the information.
    
     (4) A new field has been added to the task_struct. This holds the
         authorisation key currently active for a thread. Searches now look here
         for the caller's set of keys rather than looking for an auth key in the
         lowest level of the session keyring.
    
         This permits a thread to be servicing multiple requests at once and to
         switch between them. Note that this is per-thread, not per-process, and
         so is usable in multithreaded programs.
    
         The setting of this field is inherited across fork and exec.
    
     (5) A new keyctl function (KEYCTL_ASSUME_AUTHORITY) has been added that
         permits a thread to assume the authority to deal with an uninstantiated
         key. Assumption is only permitted if the authorisation key associated
         with the uninstantiated key is somewhere in the thread's keyrings.
    
         This function can also clear the assumption.
    
     (6) A new magic key specifier has been added to refer to the currently
         assumed authorisation key (KEY_SPEC_REQKEY_AUTH_KEY).
    
     (7) Instantiation will only proceed if the appropriate authorisation key is
         assumed first. The assumed authorisation key is discarded if
         instantiation is successful.
    
     (8) key_validate() is moved from the file of request_key functions to the
         file of permissions functions.
    
     (9) The documentation is updated.
    
    From: <Valdis.Kletnieks@vt.edu>
    
        Build fix.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Alexander Zangerl <az@bond.edu.au>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 4d189e51bc6c..cbf464ad9589 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -177,6 +177,8 @@ struct key {
 /*
  * kernel managed key type definition
  */
+typedef int (*request_key_actor_t)(struct key *key, struct key *authkey, const char *op);
+
 struct key_type {
 	/* name of the type */
 	const char *name;
@@ -218,6 +220,16 @@ struct key_type {
 	 */
 	long (*read)(const struct key *key, char __user *buffer, size_t buflen);
 
+	/* handle request_key() for this type instead of invoking
+	 * /sbin/request-key (optional)
+	 * - key is the key to instantiate
+	 * - authkey is the authority to assume when instantiating this key
+	 * - op is the operation to be done, usually "create"
+	 * - the call must not return until the instantiation process has run
+	 *   its course
+	 */
+	request_key_actor_t request_key;
+
 	/* internal fields */
 	struct list_head	link;		/* link in types list */
 };

commit 8d9067bda99c68e1a17d93e78cf3a5a3f67e0c35
Author: David Howells <dhowells@redhat.com>
Date:   Fri Jan 6 00:11:24 2006 -0800

    [PATCH] Keys: Remove key duplication
    
    Remove the key duplication stuff since there's nothing that uses it, no way
    to get at it and it's awkward to deal with for LSM purposes.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 53513a3be53b..4d189e51bc6c 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -193,14 +193,6 @@ struct key_type {
 	 */
 	int (*instantiate)(struct key *key, const void *data, size_t datalen);
 
-	/* duplicate a key of this type (optional)
-	 * - the source key will be locked against change
-	 * - the new description will be attached
-	 * - the quota will have been adjusted automatically from
-	 *   source->quotalen
-	 */
-	int (*duplicate)(struct key *key, const struct key *source);
-
 	/* update a key of this type (optional)
 	 * - this method should call key_payload_reserve() to recalculate the
 	 *   quota consumption

commit 29db9190634067c5a328ee5fcc2890251b836b4b
Author: David Howells <dhowells@redhat.com>
Date:   Sun Oct 30 15:02:44 2005 -0800

    [PATCH] Keys: Add LSM hooks for key management [try #3]
    
    The attached patch adds LSM hooks for key management facilities. The notable
    changes are:
    
     (1) The key struct now supports a security pointer for the use of security
         modules. This will permit key labelling and restrictions on which
         programs may access a key.
    
     (2) Security modules get a chance to note (or abort) the allocation of a key.
    
     (3) The key permission checking can now be enhanced by the security modules;
         the permissions check consults LSM if all other checks bear out.
    
     (4) The key permissions checking functions now return an error code rather
         than a boolean value.
    
     (5) An extra permission has been added to govern the modification of
         attributes (UID, GID, permissions).
    
    Note that there isn't an LSM hook specifically for each keyctl() operation,
    but rather the permissions hook allows control of individual operations based
    on the permission request bits.
    
    Key management access control through LSM is enabled by automatically if both
    CONFIG_KEYS and CONFIG_SECURITY are enabled.
    
    This should be applied on top of the patch ensubjected:
    
            [PATCH] Keys: Possessor permissions should be additive
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-off-by: Chris Wright <chrisw@osdl.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index f1efa016dbf3..53513a3be53b 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -40,28 +40,32 @@ struct key;
 #define KEY_POS_WRITE	0x04000000	/* possessor can update key payload / add link to keyring */
 #define KEY_POS_SEARCH	0x08000000	/* possessor can find a key in search / search a keyring */
 #define KEY_POS_LINK	0x10000000	/* possessor can create a link to a key/keyring */
-#define KEY_POS_ALL	0x1f000000
+#define KEY_POS_SETATTR	0x20000000	/* possessor can set key attributes */
+#define KEY_POS_ALL	0x3f000000
 
 #define KEY_USR_VIEW	0x00010000	/* user permissions... */
 #define KEY_USR_READ	0x00020000
 #define KEY_USR_WRITE	0x00040000
 #define KEY_USR_SEARCH	0x00080000
 #define KEY_USR_LINK	0x00100000
-#define KEY_USR_ALL	0x001f0000
+#define KEY_USR_SETATTR	0x00200000
+#define KEY_USR_ALL	0x003f0000
 
 #define KEY_GRP_VIEW	0x00000100	/* group permissions... */
 #define KEY_GRP_READ	0x00000200
 #define KEY_GRP_WRITE	0x00000400
 #define KEY_GRP_SEARCH	0x00000800
 #define KEY_GRP_LINK	0x00001000
-#define KEY_GRP_ALL	0x00001f00
+#define KEY_GRP_SETATTR	0x00002000
+#define KEY_GRP_ALL	0x00003f00
 
 #define KEY_OTH_VIEW	0x00000001	/* third party permissions... */
 #define KEY_OTH_READ	0x00000002
 #define KEY_OTH_WRITE	0x00000004
 #define KEY_OTH_SEARCH	0x00000008
 #define KEY_OTH_LINK	0x00000010
-#define KEY_OTH_ALL	0x0000001f
+#define KEY_OTH_SETATTR	0x00000020
+#define KEY_OTH_ALL	0x0000003f
 
 struct seq_file;
 struct user_struct;
@@ -119,6 +123,7 @@ struct key {
 	struct key_type		*type;		/* type of key */
 	struct rw_semaphore	sem;		/* change vs change sem */
 	struct key_user		*user;		/* owner of this key */
+	void			*security;	/* security data for this key */
 	time_t			expiry;		/* time at which key expires (or 0) */
 	uid_t			uid;
 	gid_t			gid;

commit 664cceb0093b755739e56572b836a99104ee8a75
Author: David Howells <dhowells@redhat.com>
Date:   Wed Sep 28 17:03:15 2005 +0100

    [PATCH] Keys: Add possessor permissions to keys [try #3]
    
    The attached patch adds extra permission grants to keys for the possessor of a
    key in addition to the owner, group and other permissions bits. This makes
    SUID binaries easier to support without going as far as labelling keys and key
    targets using the LSM facilities.
    
    This patch adds a second "pointer type" to key structures (struct key_ref *)
    that can have the bottom bit of the address set to indicate the possession of
    a key. This is propagated through searches from the keyring to the discovered
    key. It has been made a separate type so that the compiler can spot attempts
    to dereference a potentially incorrect pointer.
    
    The "possession" attribute can't be attached to a key structure directly as
    it's not an intrinsic property of a key.
    
    Pointers to keys have been replaced with struct key_ref *'s wherever
    possession information needs to be passed through.
    
    This does assume that the bottom bit of the pointer will always be zero on
    return from kmem_cache_alloc().
    
    The key reference type has been made into a typedef so that at least it can be
    located in the sources, even though it's basically a pointer to an undefined
    type. I've also renamed the accessor functions to be more useful, and all
    reference variables should now end in "_ref".
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 970bbd916cf4..f1efa016dbf3 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -35,11 +35,18 @@ struct key;
 
 #undef KEY_DEBUGGING
 
-#define KEY_USR_VIEW	0x00010000	/* user can view a key's attributes */
-#define KEY_USR_READ	0x00020000	/* user can read key payload / view keyring */
-#define KEY_USR_WRITE	0x00040000	/* user can update key payload / add link to keyring */
-#define KEY_USR_SEARCH	0x00080000	/* user can find a key in search / search a keyring */
-#define KEY_USR_LINK	0x00100000	/* user can create a link to a key/keyring */
+#define KEY_POS_VIEW	0x01000000	/* possessor can view a key's attributes */
+#define KEY_POS_READ	0x02000000	/* possessor can read key payload / view keyring */
+#define KEY_POS_WRITE	0x04000000	/* possessor can update key payload / add link to keyring */
+#define KEY_POS_SEARCH	0x08000000	/* possessor can find a key in search / search a keyring */
+#define KEY_POS_LINK	0x10000000	/* possessor can create a link to a key/keyring */
+#define KEY_POS_ALL	0x1f000000
+
+#define KEY_USR_VIEW	0x00010000	/* user permissions... */
+#define KEY_USR_READ	0x00020000
+#define KEY_USR_WRITE	0x00040000
+#define KEY_USR_SEARCH	0x00080000
+#define KEY_USR_LINK	0x00100000
 #define KEY_USR_ALL	0x001f0000
 
 #define KEY_GRP_VIEW	0x00000100	/* group permissions... */
@@ -65,6 +72,38 @@ struct key_owner;
 struct keyring_list;
 struct keyring_name;
 
+/*****************************************************************************/
+/*
+ * key reference with possession attribute handling
+ *
+ * NOTE! key_ref_t is a typedef'd pointer to a type that is not actually
+ * defined. This is because we abuse the bottom bit of the reference to carry a
+ * flag to indicate whether the calling process possesses that key in one of
+ * its keyrings.
+ *
+ * the key_ref_t has been made a separate type so that the compiler can reject
+ * attempts to dereference it without proper conversion.
+ *
+ * the three functions are used to assemble and disassemble references
+ */
+typedef struct __key_reference_with_attributes *key_ref_t;
+
+static inline key_ref_t make_key_ref(const struct key *key,
+				     unsigned long possession)
+{
+	return (key_ref_t) ((unsigned long) key | possession);
+}
+
+static inline struct key *key_ref_to_ptr(const key_ref_t key_ref)
+{
+	return (struct key *) ((unsigned long) key_ref & ~1UL);
+}
+
+static inline unsigned long is_key_possessed(const key_ref_t key_ref)
+{
+	return (unsigned long) key_ref & 1UL;
+}
+
 /*****************************************************************************/
 /*
  * authentication token / access credential / keyring
@@ -215,20 +254,25 @@ static inline struct key *key_get(struct key *key)
 	return key;
 }
 
+static inline void key_ref_put(key_ref_t key_ref)
+{
+	key_put(key_ref_to_ptr(key_ref));
+}
+
 extern struct key *request_key(struct key_type *type,
 			       const char *description,
 			       const char *callout_info);
 
 extern int key_validate(struct key *key);
 
-extern struct key *key_create_or_update(struct key *keyring,
-					const char *type,
-					const char *description,
-					const void *payload,
-					size_t plen,
-					int not_in_quota);
+extern key_ref_t key_create_or_update(key_ref_t keyring,
+				      const char *type,
+				      const char *description,
+				      const void *payload,
+				      size_t plen,
+				      int not_in_quota);
 
-extern int key_update(struct key *key,
+extern int key_update(key_ref_t key,
 		      const void *payload,
 		      size_t plen);
 
@@ -243,9 +287,9 @@ extern struct key *keyring_alloc(const char *description, uid_t uid, gid_t gid,
 
 extern int keyring_clear(struct key *keyring);
 
-extern struct key *keyring_search(struct key *keyring,
-				  struct key_type *type,
-				  const char *description);
+extern key_ref_t keyring_search(key_ref_t keyring,
+				struct key_type *type,
+				const char *description);
 
 extern int keyring_add_key(struct key *keyring,
 			   struct key *key);
@@ -285,6 +329,10 @@ extern void key_init(void);
 #define key_serial(k)			0
 #define key_get(k) 			({ NULL; })
 #define key_put(k)			do { } while(0)
+#define key_ref_put(k)			do { } while(0)
+#define make_key_ref(k)			({ NULL; })
+#define key_ref_to_ptr(k)		({ NULL; })
+#define is_key_possessed(k)		0
 #define alloc_uid_keyring(u)		0
 #define switch_uid_keyring(u)		do { } while(0)
 #define __install_session_keyring(t, k)	({ NULL; })

commit 3e30148c3d524a9c1c63ca28261bc24c457eb07a
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jun 23 22:00:56 2005 -0700

    [PATCH] Keys: Make request-key create an authorisation key
    
    The attached patch makes the following changes:
    
     (1) There's a new special key type called ".request_key_auth".
    
         This is an authorisation key for when one process requests a key and
         another process is started to construct it. This type of key cannot be
         created by the user; nor can it be requested by kernel services.
    
         Authorisation keys hold two references:
    
         (a) Each refers to a key being constructed. When the key being
             constructed is instantiated the authorisation key is revoked,
             rendering it of no further use.
    
         (b) The "authorising process". This is either:
    
             (i) the process that called request_key(), or:
    
             (ii) if the process that called request_key() itself had an
                  authorisation key in its session keyring, then the authorising
                  process referred to by that authorisation key will also be
                  referred to by the new authorisation key.
    
             This means that the process that initiated a chain of key requests
             will authorise the lot of them, and will, by default, wind up with
             the keys obtained from them in its keyrings.
    
     (2) request_key() creates an authorisation key which is then passed to
         /sbin/request-key in as part of a new session keyring.
    
     (3) When request_key() is searching for a key to hand back to the caller, if
         it comes across an authorisation key in the session keyring of the
         calling process, it will also search the keyrings of the process
         specified therein and it will use the specified process's credentials
         (fsuid, fsgid, groups) to do that rather than the calling process's
         credentials.
    
         This allows a process started by /sbin/request-key to find keys belonging
         to the authorising process.
    
     (4) A key can be read, even if the process executing KEYCTL_READ doesn't have
         direct read or search permission if that key is contained within the
         keyrings of a process specified by an authorisation key found within the
         calling process's session keyring, and is searchable using the
         credentials of the authorising process.
    
         This allows a process started by /sbin/request-key to read keys belonging
         to the authorising process.
    
     (5) The magic KEY_SPEC_*_KEYRING key IDs when passed to KEYCTL_INSTANTIATE or
         KEYCTL_NEGATE will specify a keyring of the authorising process, rather
         than the process doing the instantiation.
    
     (6) One of the process keyrings can be nominated as the default to which
         request_key() should attach new keys if not otherwise specified. This is
         done with KEYCTL_SET_REQKEY_KEYRING and one of the KEY_REQKEY_DEFL_*
         constants. The current setting can also be read using this call.
    
     (7) request_key() is partially interruptible. If it is waiting for another
         process to finish constructing a key, it can be interrupted. This permits
         a request-key cycle to be broken without recourse to rebooting.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-Off-By: Benoit Boissinot <benoit.boissinot@ens-lyon.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 2bfbf88d2740..970bbd916cf4 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -199,10 +199,12 @@ extern int key_payload_reserve(struct key *key, size_t datalen);
 extern int key_instantiate_and_link(struct key *key,
 				    const void *data,
 				    size_t datalen,
-				    struct key *keyring);
+				    struct key *keyring,
+				    struct key *instkey);
 extern int key_negate_and_link(struct key *key,
 			       unsigned timeout,
-			       struct key *keyring);
+			       struct key *keyring,
+			       struct key *instkey);
 extern void key_revoke(struct key *key);
 extern void key_put(struct key *key);
 
@@ -245,9 +247,6 @@ extern struct key *keyring_search(struct key *keyring,
 				  struct key_type *type,
 				  const char *description);
 
-extern struct key *search_process_keyrings(struct key_type *type,
-					   const char *description);
-
 extern int keyring_add_key(struct key *keyring,
 			   struct key *key);
 

commit 7888e7ff4ee579442128d7d12a9c9dbf2cf7de6a
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jun 23 22:00:51 2005 -0700

    [PATCH] Keys: Pass session keyring to call_usermodehelper()
    
    The attached patch makes it possible to pass a session keyring through to the
    process spawned by call_usermodehelper().  This allows patch 3/3 to pass an
    authorisation key through to /sbin/request-key, thus permitting better access
    controls when doing just-in-time key creation.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 2c24ffaca86f..2bfbf88d2740 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -273,14 +273,22 @@ extern void key_fsuid_changed(struct task_struct *tsk);
 extern void key_fsgid_changed(struct task_struct *tsk);
 extern void key_init(void);
 
+#define __install_session_keyring(tsk, keyring)			\
+({								\
+	struct key *old_session = tsk->signal->session_keyring;	\
+	tsk->signal->session_keyring = keyring;			\
+	old_session;						\
+})
+
 #else /* CONFIG_KEYS */
 
 #define key_validate(k)			0
 #define key_serial(k)			0
-#define key_get(k) 			NULL
+#define key_get(k) 			({ NULL; })
 #define key_put(k)			do { } while(0)
 #define alloc_uid_keyring(u)		0
 #define switch_uid_keyring(u)		do { } while(0)
+#define __install_session_keyring(t, k)	({ NULL; })
 #define copy_keys(f,t)			0
 #define copy_thread_group_keys(t)	0
 #define exit_keys(t)			do { } while(0)

commit 76d8aeabfeb1c42641a81c44280177b9a08670d8
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jun 23 22:00:49 2005 -0700

    [PATCH] keys: Discard key spinlock and use RCU for key payload
    
    The attached patch changes the key implementation in a number of ways:
    
     (1) It removes the spinlock from the key structure.
    
     (2) The key flags are now accessed using atomic bitops instead of
         write-locking the key spinlock and using C bitwise operators.
    
         The three instantiation flags are dealt with with the construction
         semaphore held during the request_key/instantiate/negate sequence, thus
         rendering the spinlock superfluous.
    
         The key flags are also now bit numbers not bit masks.
    
     (3) The key payload is now accessed using RCU. This permits the recursive
         keyring search algorithm to be simplified greatly since no locks need be
         taken other than the usual RCU preemption disablement. Searching now does
         not require any locks or semaphores to be held; merely that the starting
         keyring be pinned.
    
     (4) The keyring payload now includes an RCU head so that it can be disposed
         of by call_rcu(). This requires that the payload be copied on unlink to
         prevent introducing races in copy-down vs search-up.
    
     (5) The user key payload is now a structure with the data following it. It
         includes an RCU head like the keyring payload and for the same reason. It
         also contains a data length because the data length in the key may be
         changed on another CPU whilst an RCU protected read is in progress on the
         payload. This would then see the supposed RCU payload and the on-key data
         length getting out of sync.
    
         I'm tempted to drop the key's datalen entirely, except that it's used in
         conjunction with quota management and so is a little tricky to get rid
         of.
    
     (6) Update the keys documentation.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/key.h b/include/linux/key.h
index 6aa46d0e812f..2c24ffaca86f 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -18,7 +18,7 @@
 #include <linux/types.h>
 #include <linux/list.h>
 #include <linux/rbtree.h>
-#include <linux/spinlock.h>
+#include <linux/rcupdate.h>
 #include <asm/atomic.h>
 
 #ifdef __KERNEL__
@@ -78,7 +78,6 @@ struct key {
 	key_serial_t		serial;		/* key serial number */
 	struct rb_node		serial_node;
 	struct key_type		*type;		/* type of key */
-	rwlock_t		lock;		/* examination vs change lock */
 	struct rw_semaphore	sem;		/* change vs change sem */
 	struct key_user		*user;		/* owner of this key */
 	time_t			expiry;		/* time at which key expires (or 0) */
@@ -86,14 +85,10 @@ struct key {
 	gid_t			gid;
 	key_perm_t		perm;		/* access permissions */
 	unsigned short		quotalen;	/* length added to quota */
-	unsigned short		datalen;	/* payload data length */
-	unsigned short		flags;		/* status flags (change with lock writelocked) */
-#define KEY_FLAG_INSTANTIATED	0x00000001	/* set if key has been instantiated */
-#define KEY_FLAG_DEAD		0x00000002	/* set if key type has been deleted */
-#define KEY_FLAG_REVOKED	0x00000004	/* set if key had been revoked */
-#define KEY_FLAG_IN_QUOTA	0x00000008	/* set if key consumes quota */
-#define KEY_FLAG_USER_CONSTRUCT	0x00000010	/* set if key is being constructed in userspace */
-#define KEY_FLAG_NEGATIVE	0x00000020	/* set if key is negative */
+	unsigned short		datalen;	/* payload data length
+						 * - may not match RCU dereferenced payload
+						 * - payload should contain own length
+						 */
 
 #ifdef KEY_DEBUGGING
 	unsigned		magic;
@@ -101,6 +96,14 @@ struct key {
 #define KEY_DEBUG_MAGIC_X	0xf8e9dacbu
 #endif
 
+	unsigned long		flags;		/* status flags (change with bitops) */
+#define KEY_FLAG_INSTANTIATED	0	/* set if key has been instantiated */
+#define KEY_FLAG_DEAD		1	/* set if key type has been deleted */
+#define KEY_FLAG_REVOKED	2	/* set if key had been revoked */
+#define KEY_FLAG_IN_QUOTA	3	/* set if key consumes quota */
+#define KEY_FLAG_USER_CONSTRUCT	4	/* set if key is being constructed in userspace */
+#define KEY_FLAG_NEGATIVE	5	/* set if key is negative */
+
 	/* the description string
 	 * - this is used to match a key against search criteria
 	 * - this should be a printable string
@@ -250,6 +253,8 @@ extern int keyring_add_key(struct key *keyring,
 
 extern struct key *key_lookup(key_serial_t id);
 
+extern void keyring_replace_payload(struct key *key, void *replacement);
+
 #define key_serial(key) ((key) ? (key)->serial : 0)
 
 /*

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/key.h b/include/linux/key.h
new file mode 100644
index 000000000000..6aa46d0e812f
--- /dev/null
+++ b/include/linux/key.h
@@ -0,0 +1,291 @@
+/* key.h: authentication token and access key management
+ *
+ * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ *
+ * See Documentation/keys.txt for information on keys/keyrings.
+ */
+
+#ifndef _LINUX_KEY_H
+#define _LINUX_KEY_H
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/rbtree.h>
+#include <linux/spinlock.h>
+#include <asm/atomic.h>
+
+#ifdef __KERNEL__
+
+/* key handle serial number */
+typedef int32_t key_serial_t;
+
+/* key handle permissions mask */
+typedef uint32_t key_perm_t;
+
+struct key;
+
+#ifdef CONFIG_KEYS
+
+#undef KEY_DEBUGGING
+
+#define KEY_USR_VIEW	0x00010000	/* user can view a key's attributes */
+#define KEY_USR_READ	0x00020000	/* user can read key payload / view keyring */
+#define KEY_USR_WRITE	0x00040000	/* user can update key payload / add link to keyring */
+#define KEY_USR_SEARCH	0x00080000	/* user can find a key in search / search a keyring */
+#define KEY_USR_LINK	0x00100000	/* user can create a link to a key/keyring */
+#define KEY_USR_ALL	0x001f0000
+
+#define KEY_GRP_VIEW	0x00000100	/* group permissions... */
+#define KEY_GRP_READ	0x00000200
+#define KEY_GRP_WRITE	0x00000400
+#define KEY_GRP_SEARCH	0x00000800
+#define KEY_GRP_LINK	0x00001000
+#define KEY_GRP_ALL	0x00001f00
+
+#define KEY_OTH_VIEW	0x00000001	/* third party permissions... */
+#define KEY_OTH_READ	0x00000002
+#define KEY_OTH_WRITE	0x00000004
+#define KEY_OTH_SEARCH	0x00000008
+#define KEY_OTH_LINK	0x00000010
+#define KEY_OTH_ALL	0x0000001f
+
+struct seq_file;
+struct user_struct;
+struct signal_struct;
+
+struct key_type;
+struct key_owner;
+struct keyring_list;
+struct keyring_name;
+
+/*****************************************************************************/
+/*
+ * authentication token / access credential / keyring
+ * - types of key include:
+ *   - keyrings
+ *   - disk encryption IDs
+ *   - Kerberos TGTs and tickets
+ */
+struct key {
+	atomic_t		usage;		/* number of references */
+	key_serial_t		serial;		/* key serial number */
+	struct rb_node		serial_node;
+	struct key_type		*type;		/* type of key */
+	rwlock_t		lock;		/* examination vs change lock */
+	struct rw_semaphore	sem;		/* change vs change sem */
+	struct key_user		*user;		/* owner of this key */
+	time_t			expiry;		/* time at which key expires (or 0) */
+	uid_t			uid;
+	gid_t			gid;
+	key_perm_t		perm;		/* access permissions */
+	unsigned short		quotalen;	/* length added to quota */
+	unsigned short		datalen;	/* payload data length */
+	unsigned short		flags;		/* status flags (change with lock writelocked) */
+#define KEY_FLAG_INSTANTIATED	0x00000001	/* set if key has been instantiated */
+#define KEY_FLAG_DEAD		0x00000002	/* set if key type has been deleted */
+#define KEY_FLAG_REVOKED	0x00000004	/* set if key had been revoked */
+#define KEY_FLAG_IN_QUOTA	0x00000008	/* set if key consumes quota */
+#define KEY_FLAG_USER_CONSTRUCT	0x00000010	/* set if key is being constructed in userspace */
+#define KEY_FLAG_NEGATIVE	0x00000020	/* set if key is negative */
+
+#ifdef KEY_DEBUGGING
+	unsigned		magic;
+#define KEY_DEBUG_MAGIC		0x18273645u
+#define KEY_DEBUG_MAGIC_X	0xf8e9dacbu
+#endif
+
+	/* the description string
+	 * - this is used to match a key against search criteria
+	 * - this should be a printable string
+	 * - eg: for krb5 AFS, this might be "afs@REDHAT.COM"
+	 */
+	char			*description;
+
+	/* type specific data
+	 * - this is used by the keyring type to index the name
+	 */
+	union {
+		struct list_head	link;
+	} type_data;
+
+	/* key data
+	 * - this is used to hold the data actually used in cryptography or
+	 *   whatever
+	 */
+	union {
+		unsigned long		value;
+		void			*data;
+		struct keyring_list	*subscriptions;
+	} payload;
+};
+
+/*****************************************************************************/
+/*
+ * kernel managed key type definition
+ */
+struct key_type {
+	/* name of the type */
+	const char *name;
+
+	/* default payload length for quota precalculation (optional)
+	 * - this can be used instead of calling key_payload_reserve(), that
+	 *   function only needs to be called if the real datalen is different
+	 */
+	size_t def_datalen;
+
+	/* instantiate a key of this type
+	 * - this method should call key_payload_reserve() to determine if the
+	 *   user's quota will hold the payload
+	 */
+	int (*instantiate)(struct key *key, const void *data, size_t datalen);
+
+	/* duplicate a key of this type (optional)
+	 * - the source key will be locked against change
+	 * - the new description will be attached
+	 * - the quota will have been adjusted automatically from
+	 *   source->quotalen
+	 */
+	int (*duplicate)(struct key *key, const struct key *source);
+
+	/* update a key of this type (optional)
+	 * - this method should call key_payload_reserve() to recalculate the
+	 *   quota consumption
+	 * - the key must be locked against read when modifying
+	 */
+	int (*update)(struct key *key, const void *data, size_t datalen);
+
+	/* match a key against a description */
+	int (*match)(const struct key *key, const void *desc);
+
+	/* clear the data from a key (optional) */
+	void (*destroy)(struct key *key);
+
+	/* describe a key */
+	void (*describe)(const struct key *key, struct seq_file *p);
+
+	/* read a key's data (optional)
+	 * - permission checks will be done by the caller
+	 * - the key's semaphore will be readlocked by the caller
+	 * - should return the amount of data that could be read, no matter how
+	 *   much is copied into the buffer
+	 * - shouldn't do the copy if the buffer is NULL
+	 */
+	long (*read)(const struct key *key, char __user *buffer, size_t buflen);
+
+	/* internal fields */
+	struct list_head	link;		/* link in types list */
+};
+
+extern struct key_type key_type_keyring;
+
+extern int register_key_type(struct key_type *ktype);
+extern void unregister_key_type(struct key_type *ktype);
+
+extern struct key *key_alloc(struct key_type *type,
+			     const char *desc,
+			     uid_t uid, gid_t gid, key_perm_t perm,
+			     int not_in_quota);
+extern int key_payload_reserve(struct key *key, size_t datalen);
+extern int key_instantiate_and_link(struct key *key,
+				    const void *data,
+				    size_t datalen,
+				    struct key *keyring);
+extern int key_negate_and_link(struct key *key,
+			       unsigned timeout,
+			       struct key *keyring);
+extern void key_revoke(struct key *key);
+extern void key_put(struct key *key);
+
+static inline struct key *key_get(struct key *key)
+{
+	if (key)
+		atomic_inc(&key->usage);
+	return key;
+}
+
+extern struct key *request_key(struct key_type *type,
+			       const char *description,
+			       const char *callout_info);
+
+extern int key_validate(struct key *key);
+
+extern struct key *key_create_or_update(struct key *keyring,
+					const char *type,
+					const char *description,
+					const void *payload,
+					size_t plen,
+					int not_in_quota);
+
+extern int key_update(struct key *key,
+		      const void *payload,
+		      size_t plen);
+
+extern int key_link(struct key *keyring,
+		    struct key *key);
+
+extern int key_unlink(struct key *keyring,
+		      struct key *key);
+
+extern struct key *keyring_alloc(const char *description, uid_t uid, gid_t gid,
+				 int not_in_quota, struct key *dest);
+
+extern int keyring_clear(struct key *keyring);
+
+extern struct key *keyring_search(struct key *keyring,
+				  struct key_type *type,
+				  const char *description);
+
+extern struct key *search_process_keyrings(struct key_type *type,
+					   const char *description);
+
+extern int keyring_add_key(struct key *keyring,
+			   struct key *key);
+
+extern struct key *key_lookup(key_serial_t id);
+
+#define key_serial(key) ((key) ? (key)->serial : 0)
+
+/*
+ * the userspace interface
+ */
+extern struct key root_user_keyring, root_session_keyring;
+extern int alloc_uid_keyring(struct user_struct *user);
+extern void switch_uid_keyring(struct user_struct *new_user);
+extern int copy_keys(unsigned long clone_flags, struct task_struct *tsk);
+extern int copy_thread_group_keys(struct task_struct *tsk);
+extern void exit_keys(struct task_struct *tsk);
+extern void exit_thread_group_keys(struct signal_struct *tg);
+extern int suid_keys(struct task_struct *tsk);
+extern int exec_keys(struct task_struct *tsk);
+extern void key_fsuid_changed(struct task_struct *tsk);
+extern void key_fsgid_changed(struct task_struct *tsk);
+extern void key_init(void);
+
+#else /* CONFIG_KEYS */
+
+#define key_validate(k)			0
+#define key_serial(k)			0
+#define key_get(k) 			NULL
+#define key_put(k)			do { } while(0)
+#define alloc_uid_keyring(u)		0
+#define switch_uid_keyring(u)		do { } while(0)
+#define copy_keys(f,t)			0
+#define copy_thread_group_keys(t)	0
+#define exit_keys(t)			do { } while(0)
+#define exit_thread_group_keys(tg)	do { } while(0)
+#define suid_keys(t)			do { } while(0)
+#define exec_keys(t)			do { } while(0)
+#define key_fsuid_changed(t)		do { } while(0)
+#define key_fsgid_changed(t)		do { } while(0)
+#define key_init()			do { } while(0)
+
+#endif /* CONFIG_KEYS */
+#endif /* __KERNEL__ */
+#endif /* _LINUX_KEY_H */
