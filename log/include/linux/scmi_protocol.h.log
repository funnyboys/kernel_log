commit 70771c69ab9be6e37618b1ec6c105f370e510f94
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Fri Apr 3 18:10:17 2020 +0100

    firmware: arm_scmi: Add include guard to linux/scmi_protocol.h
    
    If this header is include twice, it will generate loads of compile
    time error with the following below error pattern. It was reported by
    0day kbuild robot on a branch pushed with double inclusion by accident.
    
            error: conflicting types for ‘...’
            note: previous declaration of ‘...’ was here
            error: redefinition of ‘...’
    
    Add a header include guard just in case.
    
    Link: https://lore.kernel.org/r/20200403171018.1230-1-sudeep.holla@arm.com
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index 5c873a59b387..ce2f5c28b2df 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -4,6 +4,10 @@
  *
  * Copyright (C) 2018 ARM Ltd.
  */
+
+#ifndef _LINUX_SCMI_PROTOCOL_H
+#define _LINUX_SCMI_PROTOCOL_H
+
 #include <linux/device.h>
 #include <linux/types.h>
 
@@ -319,3 +323,5 @@ static inline void scmi_driver_unregister(struct scmi_driver *driver) {}
 typedef int (*scmi_prot_init_fn_t)(struct scmi_handle *);
 int scmi_protocol_register(int protocol_id, scmi_prot_init_fn_t fn);
 void scmi_protocol_unregister(int protocol_id);
+
+#endif /* _LINUX_SCMI_PROTOCOL_H */

commit ee7a9c9f67c59008b330deff2762bd8cf1407eec
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Fri Dec 21 18:08:08 2018 +0000

    firmware: arm_scmi: Add support for multiple device per protocol
    
    Currently only one scmi device is created for each protocol enumerated.
    However, there is requirement to make use of some procotols by multiple
    kernel subsystems/frameworks. One such example is SCMI PERFORMANCE
    protocol which can be used by both cpufreq and devfreq drivers.
    Similarly, SENSOR protocol may be used by hwmon and iio subsystems,
    and POWER protocol may be used by genpd and regulator drivers.
    
    In order to achieve that, let us extend the scmi bus to match based
    not only protocol id but also the scmi device name if one is available.
    
    Reviewed-by: Cristian Marussi <cristian.marussi@arm.com>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index 881fea47c83d..5c873a59b387 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -257,6 +257,7 @@ enum scmi_std_protocol {
 struct scmi_device {
 	u32 id;
 	u8 protocol_id;
+	const char *name;
 	struct device dev;
 	struct scmi_handle *handle;
 };
@@ -264,11 +265,13 @@ struct scmi_device {
 #define to_scmi_dev(d) container_of(d, struct scmi_device, dev)
 
 struct scmi_device *
-scmi_device_create(struct device_node *np, struct device *parent, int protocol);
+scmi_device_create(struct device_node *np, struct device *parent, int protocol,
+		   const char *name);
 void scmi_device_destroy(struct scmi_device *scmi_dev);
 
 struct scmi_device_id {
 	u8 protocol_id;
+	const char *name;
 };
 
 struct scmi_driver {

commit 95a15d80aa0de938299acfcbc6aa6f2b16f5d7e5
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Mon Jul 8 09:41:06 2019 +0100

    firmware: arm_scmi: Add RESET protocol in SCMI v2.0
    
    SCMIv2.0 adds a new Reset Management Protocol to manage various reset
    states a given device or domain can enter. Device(s) that can be
    collectively reset through a common reset signal constitute a reset
    domain for the firmware.
    
    A reset domain can be reset autonomously or explicitly through assertion
    and de-assertion of the signal. When autonomous reset is chosen, the
    firmware is responsible for taking the necessary steps to reset the
    domain and to subsequently bring it out of reset. When explicit reset is
    chosen, the caller has to specifically assert and then de-assert the
    reset signal by issuing two separate RESET commands.
    
    Add the basic SCMI reset infrastructure that can be used by Linux
    reset controller driver.
    
    Reviewed-by: Peng Fan <peng.fan@nxp.com>
    Reviewed-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index f0f2b53a1dac..881fea47c83d 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -187,6 +187,26 @@ struct scmi_sensor_ops {
 			   u64 *value);
 };
 
+/**
+ * struct scmi_reset_ops - represents the various operations provided
+ *	by SCMI Reset Protocol
+ *
+ * @num_domains_get: get the count of reset domains provided by SCMI
+ * @name_get: gets the name of a reset domain
+ * @latency_get: gets the reset latency for the specified reset domain
+ * @reset: resets the specified reset domain
+ * @assert: explicitly assert reset signal of the specified reset domain
+ * @deassert: explicitly deassert reset signal of the specified reset domain
+ */
+struct scmi_reset_ops {
+	int (*num_domains_get)(const struct scmi_handle *handle);
+	char *(*name_get)(const struct scmi_handle *handle, u32 domain);
+	int (*latency_get)(const struct scmi_handle *handle, u32 domain);
+	int (*reset)(const struct scmi_handle *handle, u32 domain);
+	int (*assert)(const struct scmi_handle *handle, u32 domain);
+	int (*deassert)(const struct scmi_handle *handle, u32 domain);
+};
+
 /**
  * struct scmi_handle - Handle returned to ARM SCMI clients for usage.
  *
@@ -196,6 +216,7 @@ struct scmi_sensor_ops {
  * @perf_ops: pointer to set of performance protocol operations
  * @clk_ops: pointer to set of clock protocol operations
  * @sensor_ops: pointer to set of sensor protocol operations
+ * @reset_ops: pointer to set of reset protocol operations
  * @perf_priv: pointer to private data structure specific to performance
  *	protocol(for internal use only)
  * @clk_priv: pointer to private data structure specific to clock
@@ -204,6 +225,8 @@ struct scmi_sensor_ops {
  *	protocol(for internal use only)
  * @sensor_priv: pointer to private data structure specific to sensors
  *	protocol(for internal use only)
+ * @reset_priv: pointer to private data structure specific to reset
+ *	protocol(for internal use only)
  */
 struct scmi_handle {
 	struct device *dev;
@@ -212,11 +235,13 @@ struct scmi_handle {
 	struct scmi_clk_ops *clk_ops;
 	struct scmi_power_ops *power_ops;
 	struct scmi_sensor_ops *sensor_ops;
+	struct scmi_reset_ops *reset_ops;
 	/* for protocol internal use */
 	void *perf_priv;
 	void *clk_priv;
 	void *power_priv;
 	void *sensor_priv;
+	void *reset_priv;
 };
 
 enum scmi_std_protocol {
@@ -226,6 +251,7 @@ enum scmi_std_protocol {
 	SCMI_PROTOCOL_PERF = 0x13,
 	SCMI_PROTOCOL_CLOCK = 0x14,
 	SCMI_PROTOCOL_SENSOR = 0x15,
+	SCMI_PROTOCOL_RESET = 0x16,
 };
 
 struct scmi_device {

commit d0aba11614552d43a61c3acdf36876b00060286e
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Mon Jul 8 09:42:22 2019 +0100

    firmware: arm_scmi: Drop config flag in clk_ops->rate_set
    
    CLOCK_PROTOCOL_ATTRIBUTES provides attributes to indicate the maximum
    number of pending asynchronous clock rate changes supported by the
    platform. If it's non-zero, then we should be able to use asynchronous
    clock rate set for any clocks until the maximum limit is reached.
    
    In order to add that support, let's drop the config flag passed to
    clk_ops->rate_set and handle the asynchronous requests dynamically.
    
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: linux-clk@vger.kernel.org
    Acked-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index ae7381413f1f..f0f2b53a1dac 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -71,7 +71,7 @@ struct scmi_clk_ops {
 	int (*rate_get)(const struct scmi_handle *handle, u32 clk_id,
 			u64 *rate);
 	int (*rate_set)(const struct scmi_handle *handle, u32 clk_id,
-			u32 config, u64 rate);
+			u64 rate);
 	int (*enable)(const struct scmi_handle *handle, u32 clk_id);
 	int (*disable)(const struct scmi_handle *handle, u32 clk_id);
 };

commit d09aac0eb17c6ce2b66095e1e324f60ec9dd8988
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Mon Jul 8 09:41:01 2019 +0100

    firmware: arm_scmi: Add asynchronous sensor read if it supports
    
    SENSOR_DESCRIPTION_GET provides attributes to indicate if the sensor
    supports asynchronous read. We can read that flag and use asynchronous
    reads for any sensors with that attribute set.
    
    Let's use the new scmi_do_xfer_with_response to support asynchronous
    sensor reads.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index 2ace5af210ad..ae7381413f1f 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -145,6 +145,8 @@ struct scmi_sensor_info {
 	u32 id;
 	u8 type;
 	s8 scale;
+	u8 num_trip_points;
+	bool async;
 	char name[SCMI_MAX_STR_SIZE];
 };
 

commit 6a55331c87d86a7406d8126ae75bdd07244a91b1
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Mon Jul 8 09:40:57 2019 +0100

    firmware: arm_scmi: Drop async flag in sensor_ops->reading_get
    
    SENSOR_DESCRIPTION_GET provides attributes to indicate if the sensor
    supports asynchronous read. Ideally we should be able to read that flag
    and use asynchronous reads for any sensors with that attribute set.
    
    In order to add that support, let's drop the async flag passed to
    sensor_ops->reading_get and dynamically switch between sync and async
    flags based on the attributes as provided by the firmware.
    
    Cc: linux-hwmon@vger.kernel.org
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index 1383d47e6435..2ace5af210ad 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -182,7 +182,7 @@ struct scmi_sensor_ops {
 	int (*trip_point_config)(const struct scmi_handle *handle,
 				 u32 sensor_id, u8 trip_id, u64 trip_value);
 	int (*reading_get)(const struct scmi_handle *handle, u32 sensor_id,
-			   bool async, u64 *value);
+			   u64 *value);
 };
 
 /**

commit 9eefa43a1a03960c7458e1463132f893702741be
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Mon Jul 8 09:40:33 2019 +0100

    firmware: arm_scmi: Align few names in sensors protocol with SCMI specification
    
    Looks like more code developed during the draft versions of the
    specification slipped through and they don't match the final
    released version. This seem to have happened only with sensor
    protocol.
    
    Renaming few command and function names here to match exactly with
    the released version of SCMI specification for ease of maintenance.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index aa1e791779b4..1383d47e6435 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -167,9 +167,9 @@ enum scmi_sensor_class {
  *
  * @count_get: get the count of sensors provided by SCMI
  * @info_get: get the information of the specified sensor
- * @configuration_set: control notifications on cross-over events for
+ * @trip_point_notify: control notifications on cross-over events for
  *	the trip-points
- * @trip_point_set: selects and configures a trip-point of interest
+ * @trip_point_config: selects and configures a trip-point of interest
  * @reading_get: gets the current value of the sensor
  */
 struct scmi_sensor_ops {
@@ -177,10 +177,10 @@ struct scmi_sensor_ops {
 
 	const struct scmi_sensor_info *(*info_get)
 		(const struct scmi_handle *handle, u32 sensor_id);
-	int (*configuration_set)(const struct scmi_handle *handle,
-				 u32 sensor_id);
-	int (*trip_point_set)(const struct scmi_handle *handle, u32 sensor_id,
-			      u8 trip_id, u64 trip_value);
+	int (*trip_point_notify)(const struct scmi_handle *handle,
+				 u32 sensor_id, bool enable);
+	int (*trip_point_config)(const struct scmi_handle *handle,
+				 u32 sensor_id, u8 trip_id, u64 trip_value);
 	int (*reading_get)(const struct scmi_handle *handle, u32 sensor_id,
 			   bool async, u64 *value);
 };

commit 4752544a447b52b9949eb648a3b7719357853f91
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Tue Jul 23 14:00:09 2019 +0100

    firmware: arm_scmi: Use the correct style for SPDX License Identifier
    
    Fix to correct the SPDX License Identifier style in header file related
    to firmware frivers for ARM SCMI message protocol.
    
    For C header files Documentation/process/license-rules.rst mandates
    C-like comments(opposed to C source files where C++ style should be
    used).
    
    While at it, change GPL-2.0 to GPL-2.0-only similar to the ones in
    psci.h and scpi_protocol.h
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index 9ff2e9357e9a..aa1e791779b4 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * SCMI Message Protocol driver header
  *

commit 0b673b6486998061b0489b09447ebe8452da0146
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Wed May 8 11:46:34 2019 -0700

    firmware: arm_scmi: fetch and store sensor scale
    
    In preparation for dealing with scales within the SCMI HWMON driver,
    fetch and store the sensor unit scale into the scmi_sensor_info
    structure. In order to simplify computations for upper layer, take care
    of sign extending the scale to a full 8-bit signed value.
    
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    [sudeep.holla: update bitfield values as per specification]
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index 3105055c00a7..9ff2e9357e9a 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -144,6 +144,7 @@ struct scmi_power_ops {
 struct scmi_sensor_info {
 	u32 id;
 	u8 type;
+	s8 scale;
 	char name[SCMI_MAX_STR_SIZE];
 };
 

commit 1a63fe9a2b1f47af5b2b7436b41824b14999c17a
Author: Quentin Perret <quentin.perret@arm.com>
Date:   Mon Sep 10 17:28:10 2018 +0100

    firmware: arm_scmi: add a getter for power of performance states
    
    The SCMI protocol can be used to get power estimates from firmware
    corresponding to each performance state of a device. Although these power
    costs are already managed by the SCMI firmware driver, they are not
    exposed to any external subsystem yet.
    
    Fix this by adding a new get_power() interface to the exisiting perf_ops
    defined for the SCMI protocol.
    
    Signed-off-by: Quentin Perret <quentin.perret@arm.com>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index f4c9fc0fc755..3105055c00a7 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -91,6 +91,8 @@ struct scmi_clk_ops {
  *	to sustained performance level mapping
  * @freq_get: gets the frequency for a given device using sustained frequency
  *	to sustained performance level mapping
+ * @est_power_get: gets the estimated power cost for a given performance domain
+ *	at a given frequency
  */
 struct scmi_perf_ops {
 	int (*limits_set)(const struct scmi_handle *handle, u32 domain,
@@ -110,6 +112,8 @@ struct scmi_perf_ops {
 			unsigned long rate, bool poll);
 	int (*freq_get)(const struct scmi_handle *handle, u32 domain,
 			unsigned long *rate, bool poll);
+	int (*est_power_get)(const struct scmi_handle *handle, u32 domain,
+			     unsigned long *rate, unsigned long *power);
 };
 
 /**

commit 7859e08c1bdef00841d29e8ff320264fd6f9257b
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Wed May 9 17:52:06 2018 +0100

    firmware: arm_scmi: rename get_transition_latency and add_opps_to_device
    
    Most of the scmi code follows the suggestion from Greg KH on a totally
    different thread[0] to have the subsystem name first, followed by the
    noun and finally the verb with couple of these exceptions.
    
    This patch fixes them so that all the functions names are aligned to
    that practice.
    
    [0] https://www.spinics.net/lists/arm-kernel/msg583673.html
    
    Acked-by: Rafael J. Wysocki <rafael@kernel.org>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index a171c1e293e8..f4c9fc0fc755 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -85,8 +85,8 @@ struct scmi_clk_ops {
  * @level_set: sets the performance level of a domain
  * @level_get: gets the performance level of a domain
  * @device_domain_id: gets the scmi domain id for a given device
- * @get_transition_latency: gets the DVFS transition latency for a given device
- * @add_opps_to_device: adds all the OPPs for a given device
+ * @transition_latency_get: gets the DVFS transition latency for a given device
+ * @device_opps_add: adds all the OPPs for a given device
  * @freq_set: sets the frequency for a given device using sustained frequency
  *	to sustained performance level mapping
  * @freq_get: gets the frequency for a given device using sustained frequency
@@ -102,10 +102,10 @@ struct scmi_perf_ops {
 	int (*level_get)(const struct scmi_handle *handle, u32 domain,
 			 u32 *level, bool poll);
 	int (*device_domain_id)(struct device *dev);
-	int (*get_transition_latency)(const struct scmi_handle *handle,
+	int (*transition_latency_get)(const struct scmi_handle *handle,
 				      struct device *dev);
-	int (*add_opps_to_device)(const struct scmi_handle *handle,
-				  struct device *dev);
+	int (*device_opps_add)(const struct scmi_handle *handle,
+			       struct device *dev);
 	int (*freq_set)(const struct scmi_handle *handle, u32 domain,
 			unsigned long rate, bool poll);
 	int (*freq_get)(const struct scmi_handle *handle, u32 domain,

commit 1baf47c2e5c946fd17ef07597b9d25722d13ff14
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Wed May 9 17:52:06 2018 +0100

    firmware: arm_scmi: fix kernel-docs documentation
    
    There are few missing descriptions for function parameters and structure
    members along with certain instances where excessive function parameters
    or structure members are described.
    
    This patch fixes all of those warnings.
    
    Reported-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index b458c87b866c..a171c1e293e8 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -189,6 +189,14 @@ struct scmi_sensor_ops {
  * @perf_ops: pointer to set of performance protocol operations
  * @clk_ops: pointer to set of clock protocol operations
  * @sensor_ops: pointer to set of sensor protocol operations
+ * @perf_priv: pointer to private data structure specific to performance
+ *	protocol(for internal use only)
+ * @clk_priv: pointer to private data structure specific to clock
+ *	protocol(for internal use only)
+ * @power_priv: pointer to private data structure specific to power
+ *	protocol(for internal use only)
+ * @sensor_priv: pointer to private data structure specific to sensors
+ *	protocol(for internal use only)
  */
 struct scmi_handle {
 	struct device *dev;

commit 5c4ba3cc85296398855d621bf90b78866ea80444
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Fri Jul 21 11:42:24 2017 +0100

    firmware: arm_scmi: add option for polling based performance domain operations
    
    In order to implement fast CPU DVFS switching, we need to perform all
    DVFS operations atomically. Since SCMI transfer already provide option
    to choose between pooling vs interrupt driven(default), we can opt for
    polling based transfers for set,get performance domain operations.
    
    This patch adds option to choose between polling vs interrupt driven
    SCMI transfers for set,get performance level operations.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index 5d63da9435ba..b458c87b866c 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -98,18 +98,18 @@ struct scmi_perf_ops {
 	int (*limits_get)(const struct scmi_handle *handle, u32 domain,
 			  u32 *max_perf, u32 *min_perf);
 	int (*level_set)(const struct scmi_handle *handle, u32 domain,
-			 u32 level);
+			 u32 level, bool poll);
 	int (*level_get)(const struct scmi_handle *handle, u32 domain,
-			 u32 *level);
+			 u32 *level, bool poll);
 	int (*device_domain_id)(struct device *dev);
 	int (*get_transition_latency)(const struct scmi_handle *handle,
 				      struct device *dev);
 	int (*add_opps_to_device)(const struct scmi_handle *handle,
 				  struct device *dev);
 	int (*freq_set)(const struct scmi_handle *handle, u32 domain,
-			unsigned long rate);
+			unsigned long rate, bool poll);
 	int (*freq_get)(const struct scmi_handle *handle, u32 domain,
-			unsigned long *rate);
+			unsigned long *rate, bool poll);
 };
 
 /**

commit 5179c523c1eae4b80fbafe9656bc24a375217cac
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Tue Jun 6 11:38:10 2017 +0100

    firmware: arm_scmi: add initial support for sensor protocol
    
    The sensor protocol provides functions to manage platform sensors, and
    provides the commands to describe the protocol version and the various
    attribute flags. It also provides commands to discover various sensors
    implemented and managed by the platform, read any sensor synchronously
    or asynchronously as allowed by the platform, program sensor attributes
    and/or configurations, if applicable.
    
    This patch adds support for most of the above features.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index 8cd0348787bc..5d63da9435ba 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -137,6 +137,49 @@ struct scmi_power_ops {
 			 u32 *state);
 };
 
+struct scmi_sensor_info {
+	u32 id;
+	u8 type;
+	char name[SCMI_MAX_STR_SIZE];
+};
+
+/*
+ * Partial list from Distributed Management Task Force (DMTF) specification:
+ * DSP0249 (Platform Level Data Model specification)
+ */
+enum scmi_sensor_class {
+	NONE = 0x0,
+	TEMPERATURE_C = 0x2,
+	VOLTAGE = 0x5,
+	CURRENT = 0x6,
+	POWER = 0x7,
+	ENERGY = 0x8,
+};
+
+/**
+ * struct scmi_sensor_ops - represents the various operations provided
+ *	by SCMI Sensor Protocol
+ *
+ * @count_get: get the count of sensors provided by SCMI
+ * @info_get: get the information of the specified sensor
+ * @configuration_set: control notifications on cross-over events for
+ *	the trip-points
+ * @trip_point_set: selects and configures a trip-point of interest
+ * @reading_get: gets the current value of the sensor
+ */
+struct scmi_sensor_ops {
+	int (*count_get)(const struct scmi_handle *handle);
+
+	const struct scmi_sensor_info *(*info_get)
+		(const struct scmi_handle *handle, u32 sensor_id);
+	int (*configuration_set)(const struct scmi_handle *handle,
+				 u32 sensor_id);
+	int (*trip_point_set)(const struct scmi_handle *handle, u32 sensor_id,
+			      u8 trip_id, u64 trip_value);
+	int (*reading_get)(const struct scmi_handle *handle, u32 sensor_id,
+			   bool async, u64 *value);
+};
+
 /**
  * struct scmi_handle - Handle returned to ARM SCMI clients for usage.
  *
@@ -145,6 +188,7 @@ struct scmi_power_ops {
  * @power_ops: pointer to set of power protocol operations
  * @perf_ops: pointer to set of performance protocol operations
  * @clk_ops: pointer to set of clock protocol operations
+ * @sensor_ops: pointer to set of sensor protocol operations
  */
 struct scmi_handle {
 	struct device *dev;
@@ -152,10 +196,12 @@ struct scmi_handle {
 	struct scmi_perf_ops *perf_ops;
 	struct scmi_clk_ops *clk_ops;
 	struct scmi_power_ops *power_ops;
+	struct scmi_sensor_ops *sensor_ops;
 	/* for protocol internal use */
 	void *perf_priv;
 	void *clk_priv;
 	void *power_priv;
+	void *sensor_priv;
 };
 
 enum scmi_std_protocol {

commit 76a6550990e296a7acbb4d33201c9740be912a8c
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Tue Jun 6 11:32:24 2017 +0100

    firmware: arm_scmi: add initial support for power protocol
    
    The power protocol is intended for management of power states of various
    power domains. The power domain management protocol provides commands to
    describe the protocol version, discover the implementation specific
    attributes, set and get the power state of a domain.
    
    This patch adds support for the above mention features of the protocol.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    --
     drivers/firmware/arm_scmi/Makefile |   2 +-
     drivers/firmware/arm_scmi/power.c  | 242 +++++++++++++++++++++++++++++++++++++
     include/linux/scmi_protocol.h      |  28 +++++
     3 files changed, 271 insertions(+), 1 deletion(-)
     create mode 100644 drivers/firmware/arm_scmi/power.c

diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index 5a3092f05011..8cd0348787bc 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -112,11 +112,37 @@ struct scmi_perf_ops {
 			unsigned long *rate);
 };
 
+/**
+ * struct scmi_power_ops - represents the various operations provided
+ *	by SCMI Power Protocol
+ *
+ * @num_domains_get: get the count of power domains provided by SCMI
+ * @name_get: gets the name of a power domain
+ * @state_set: sets the power state of a power domain
+ * @state_get: gets the power state of a power domain
+ */
+struct scmi_power_ops {
+	int (*num_domains_get)(const struct scmi_handle *handle);
+	char *(*name_get)(const struct scmi_handle *handle, u32 domain);
+#define SCMI_POWER_STATE_TYPE_SHIFT	30
+#define SCMI_POWER_STATE_ID_MASK	(BIT(28) - 1)
+#define SCMI_POWER_STATE_PARAM(type, id) \
+	((((type) & BIT(0)) << SCMI_POWER_STATE_TYPE_SHIFT) | \
+		((id) & SCMI_POWER_STATE_ID_MASK))
+#define SCMI_POWER_STATE_GENERIC_ON	SCMI_POWER_STATE_PARAM(0, 0)
+#define SCMI_POWER_STATE_GENERIC_OFF	SCMI_POWER_STATE_PARAM(1, 0)
+	int (*state_set)(const struct scmi_handle *handle, u32 domain,
+			 u32 state);
+	int (*state_get)(const struct scmi_handle *handle, u32 domain,
+			 u32 *state);
+};
+
 /**
  * struct scmi_handle - Handle returned to ARM SCMI clients for usage.
  *
  * @dev: pointer to the SCMI device
  * @version: pointer to the structure containing SCMI version information
+ * @power_ops: pointer to set of power protocol operations
  * @perf_ops: pointer to set of performance protocol operations
  * @clk_ops: pointer to set of clock protocol operations
  */
@@ -125,9 +151,11 @@ struct scmi_handle {
 	struct scmi_revision_info *version;
 	struct scmi_perf_ops *perf_ops;
 	struct scmi_clk_ops *clk_ops;
+	struct scmi_power_ops *power_ops;
 	/* for protocol internal use */
 	void *perf_priv;
 	void *clk_priv;
+	void *power_priv;
 };
 
 enum scmi_std_protocol {

commit 5f6c6430e904d21bfe5d0076b1ff3e8b9ed94ba0
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Tue Jun 6 11:27:57 2017 +0100

    firmware: arm_scmi: add initial support for clock protocol
    
    The clock protocol is intended for management of clocks. It is used to
    enable or disable clocks, and to set and get the clock rates. This
    protocol provides commands to describe the protocol version, discover
    various implementation specific attributes, describe a clock, enable
    and disable a clock and get/set the rate of the clock synchronously or
    asynchronously.
    
    This patch adds initial support for the clock protocol.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index 57d4b1c099e5..5a3092f05011 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -8,6 +8,7 @@
 #include <linux/types.h>
 
 #define SCMI_MAX_STR_SIZE	16
+#define SCMI_MAX_NUM_RATES	16
 
 /**
  * struct scmi_revision_info - version information structure
@@ -33,8 +34,48 @@ struct scmi_revision_info {
 	char sub_vendor_id[SCMI_MAX_STR_SIZE];
 };
 
+struct scmi_clock_info {
+	char name[SCMI_MAX_STR_SIZE];
+	bool rate_discrete;
+	union {
+		struct {
+			int num_rates;
+			u64 rates[SCMI_MAX_NUM_RATES];
+		} list;
+		struct {
+			u64 min_rate;
+			u64 max_rate;
+			u64 step_size;
+		} range;
+	};
+};
+
 struct scmi_handle;
 
+/**
+ * struct scmi_clk_ops - represents the various operations provided
+ *	by SCMI Clock Protocol
+ *
+ * @count_get: get the count of clocks provided by SCMI
+ * @info_get: get the information of the specified clock
+ * @rate_get: request the current clock rate of a clock
+ * @rate_set: set the clock rate of a clock
+ * @enable: enables the specified clock
+ * @disable: disables the specified clock
+ */
+struct scmi_clk_ops {
+	int (*count_get)(const struct scmi_handle *handle);
+
+	const struct scmi_clock_info *(*info_get)
+		(const struct scmi_handle *handle, u32 clk_id);
+	int (*rate_get)(const struct scmi_handle *handle, u32 clk_id,
+			u64 *rate);
+	int (*rate_set)(const struct scmi_handle *handle, u32 clk_id,
+			u32 config, u64 rate);
+	int (*enable)(const struct scmi_handle *handle, u32 clk_id);
+	int (*disable)(const struct scmi_handle *handle, u32 clk_id);
+};
+
 /**
  * struct scmi_perf_ops - represents the various operations provided
  *	by SCMI Performance Protocol
@@ -77,13 +118,16 @@ struct scmi_perf_ops {
  * @dev: pointer to the SCMI device
  * @version: pointer to the structure containing SCMI version information
  * @perf_ops: pointer to set of performance protocol operations
+ * @clk_ops: pointer to set of clock protocol operations
  */
 struct scmi_handle {
 	struct device *dev;
 	struct scmi_revision_info *version;
 	struct scmi_perf_ops *perf_ops;
+	struct scmi_clk_ops *clk_ops;
 	/* for protocol internal use */
 	void *perf_priv;
+	void *clk_priv;
 };
 
 enum scmi_std_protocol {

commit a9e3fbfaa0ff885aacafe6f33e72448a2993d072
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Tue Jun 6 11:22:51 2017 +0100

    firmware: arm_scmi: add initial support for performance protocol
    
    The performance protocol is intended for the performance management of
    group(s) of device(s) that run in the same performance domain. It
    includes even the CPUs. A performance domain is defined by a set of
    devices that always have to run at the same performance level.
    For example, a set of CPUs that share a voltage domain, and have a
    common frequency control, is said to be in the same performance domain.
    
    The commands in this protocol provide functionality to describe the
    protocol version, describe various attribute flags, set and get the
    performance level of a domain. It also supports discovery of the list
    of performance levels supported by a performance domain, and the
    properties of each performance level.
    
    This patch adds basic support for the performance protocol.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index 464086b9d8c5..57d4b1c099e5 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -33,15 +33,57 @@ struct scmi_revision_info {
 	char sub_vendor_id[SCMI_MAX_STR_SIZE];
 };
 
+struct scmi_handle;
+
+/**
+ * struct scmi_perf_ops - represents the various operations provided
+ *	by SCMI Performance Protocol
+ *
+ * @limits_set: sets limits on the performance level of a domain
+ * @limits_get: gets limits on the performance level of a domain
+ * @level_set: sets the performance level of a domain
+ * @level_get: gets the performance level of a domain
+ * @device_domain_id: gets the scmi domain id for a given device
+ * @get_transition_latency: gets the DVFS transition latency for a given device
+ * @add_opps_to_device: adds all the OPPs for a given device
+ * @freq_set: sets the frequency for a given device using sustained frequency
+ *	to sustained performance level mapping
+ * @freq_get: gets the frequency for a given device using sustained frequency
+ *	to sustained performance level mapping
+ */
+struct scmi_perf_ops {
+	int (*limits_set)(const struct scmi_handle *handle, u32 domain,
+			  u32 max_perf, u32 min_perf);
+	int (*limits_get)(const struct scmi_handle *handle, u32 domain,
+			  u32 *max_perf, u32 *min_perf);
+	int (*level_set)(const struct scmi_handle *handle, u32 domain,
+			 u32 level);
+	int (*level_get)(const struct scmi_handle *handle, u32 domain,
+			 u32 *level);
+	int (*device_domain_id)(struct device *dev);
+	int (*get_transition_latency)(const struct scmi_handle *handle,
+				      struct device *dev);
+	int (*add_opps_to_device)(const struct scmi_handle *handle,
+				  struct device *dev);
+	int (*freq_set)(const struct scmi_handle *handle, u32 domain,
+			unsigned long rate);
+	int (*freq_get)(const struct scmi_handle *handle, u32 domain,
+			unsigned long *rate);
+};
+
 /**
  * struct scmi_handle - Handle returned to ARM SCMI clients for usage.
  *
  * @dev: pointer to the SCMI device
  * @version: pointer to the structure containing SCMI version information
+ * @perf_ops: pointer to set of performance protocol operations
  */
 struct scmi_handle {
 	struct device *dev;
 	struct scmi_revision_info *version;
+	struct scmi_perf_ops *perf_ops;
+	/* for protocol internal use */
+	void *perf_priv;
 };
 
 enum scmi_std_protocol {

commit 933c504424a2bc784fdb4cd5c318049d55da20e0
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Mon Oct 30 18:33:30 2017 +0000

    firmware: arm_scmi: add scmi protocol bus to enumerate protocol devices
    
    The SCMI specification encompasses various protocols. However, not every
    protocol has to be present on a given platform/implementation as not
    every protocol is relevant for it.
    
    Furthermore, the platform chooses which protocols it exposes to a given
    agent. The only protocol that must be implemented is the base protocol.
    The base protocol is used by an agent to discover which protocols are
    available to it.
    
    In order to enumerate the discovered implemented protocols, this patch
    adds support for a separate scmi protocol bus. It also adds mechanism to
    register support for different protocols.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index 08fcc1dd0276..464086b9d8c5 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -4,6 +4,7 @@
  *
  * Copyright (C) 2018 ARM Ltd.
  */
+#include <linux/device.h>
 #include <linux/types.h>
 
 #define SCMI_MAX_STR_SIZE	16
@@ -51,3 +52,66 @@ enum scmi_std_protocol {
 	SCMI_PROTOCOL_CLOCK = 0x14,
 	SCMI_PROTOCOL_SENSOR = 0x15,
 };
+
+struct scmi_device {
+	u32 id;
+	u8 protocol_id;
+	struct device dev;
+	struct scmi_handle *handle;
+};
+
+#define to_scmi_dev(d) container_of(d, struct scmi_device, dev)
+
+struct scmi_device *
+scmi_device_create(struct device_node *np, struct device *parent, int protocol);
+void scmi_device_destroy(struct scmi_device *scmi_dev);
+
+struct scmi_device_id {
+	u8 protocol_id;
+};
+
+struct scmi_driver {
+	const char *name;
+	int (*probe)(struct scmi_device *sdev);
+	void (*remove)(struct scmi_device *sdev);
+	const struct scmi_device_id *id_table;
+
+	struct device_driver driver;
+};
+
+#define to_scmi_driver(d) container_of(d, struct scmi_driver, driver)
+
+#ifdef CONFIG_ARM_SCMI_PROTOCOL
+int scmi_driver_register(struct scmi_driver *driver,
+			 struct module *owner, const char *mod_name);
+void scmi_driver_unregister(struct scmi_driver *driver);
+#else
+static inline int
+scmi_driver_register(struct scmi_driver *driver, struct module *owner,
+		     const char *mod_name)
+{
+	return -EINVAL;
+}
+
+static inline void scmi_driver_unregister(struct scmi_driver *driver) {}
+#endif /* CONFIG_ARM_SCMI_PROTOCOL */
+
+#define scmi_register(driver) \
+	scmi_driver_register(driver, THIS_MODULE, KBUILD_MODNAME)
+#define scmi_unregister(driver) \
+	scmi_driver_unregister(driver)
+
+/**
+ * module_scmi_driver() - Helper macro for registering a scmi driver
+ * @__scmi_driver: scmi_driver structure
+ *
+ * Helper macro for scmi drivers to set up proper module init / exit
+ * functions.  Replaces module_init() and module_exit() and keeps people from
+ * printing pointless things to the kernel log when their driver is loaded.
+ */
+#define module_scmi_driver(__scmi_driver)	\
+	module_driver(__scmi_driver, scmi_register, scmi_unregister)
+
+typedef int (*scmi_prot_init_fn_t)(struct scmi_handle *);
+int scmi_protocol_register(int protocol_id, scmi_prot_init_fn_t fn);
+void scmi_protocol_unregister(int protocol_id);

commit b6f20ff8bd94ad34032804a60bab5ee56752007e
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Tue Jun 6 11:16:15 2017 +0100

    firmware: arm_scmi: add common infrastructure and support for base protocol
    
    The base protocol describes the properties of the implementation and
    provide generic error management. The base protocol provides commands
    to describe protocol version, discover implementation specific
    attributes and vendor/sub-vendor identification, list of protocols
    implemented and the various agents are in the system including OSPM
    and the platform. It also supports registering for notifications of
    platform errors.
    
    This protocol is mandatory. This patch adds support for the same along
    with some basic infrastructure to add support for other protocols.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index 1f0e89b270c6..08fcc1dd0276 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -6,11 +6,48 @@
  */
 #include <linux/types.h>
 
+#define SCMI_MAX_STR_SIZE	16
+
+/**
+ * struct scmi_revision_info - version information structure
+ *
+ * @major_ver: Major ABI version. Change here implies risk of backward
+ *	compatibility break.
+ * @minor_ver: Minor ABI version. Change here implies new feature addition,
+ *	or compatible change in ABI.
+ * @num_protocols: Number of protocols that are implemented, excluding the
+ *	base protocol.
+ * @num_agents: Number of agents in the system.
+ * @impl_ver: A vendor-specific implementation version.
+ * @vendor_id: A vendor identifier(Null terminated ASCII string)
+ * @sub_vendor_id: A sub-vendor identifier(Null terminated ASCII string)
+ */
+struct scmi_revision_info {
+	u16 major_ver;
+	u16 minor_ver;
+	u8 num_protocols;
+	u8 num_agents;
+	u32 impl_ver;
+	char vendor_id[SCMI_MAX_STR_SIZE];
+	char sub_vendor_id[SCMI_MAX_STR_SIZE];
+};
+
 /**
  * struct scmi_handle - Handle returned to ARM SCMI clients for usage.
  *
  * @dev: pointer to the SCMI device
+ * @version: pointer to the structure containing SCMI version information
  */
 struct scmi_handle {
 	struct device *dev;
+	struct scmi_revision_info *version;
+};
+
+enum scmi_std_protocol {
+	SCMI_PROTOCOL_BASE = 0x10,
+	SCMI_PROTOCOL_POWER = 0x11,
+	SCMI_PROTOCOL_SYSTEM = 0x12,
+	SCMI_PROTOCOL_PERF = 0x13,
+	SCMI_PROTOCOL_CLOCK = 0x14,
+	SCMI_PROTOCOL_SENSOR = 0x15,
 };

commit aa4f886f3893f88146e8e02fd1e9c5c9e43cbcc1
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Tue Mar 28 11:36:07 2017 +0100

    firmware: arm_scmi: add basic driver infrastructure for SCMI
    
    The SCMI is intended to allow OSPM to manage various functions that are
    provided by the hardware platform it is running on, including power and
    performance functions. SCMI provides two levels of abstraction, protocols
    and transports. Protocols define individual groups of system control and
    management messages. A protocol specification describes the messages
    that it supports. Transports describe the method by which protocol
    messages are communicated between agents and the platform.
    
    This patch adds basic infrastructure to manage the message allocation,
    initialisation, packing/unpacking and shared memory management.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
new file mode 100644
index 000000000000..1f0e89b270c6
--- /dev/null
+++ b/include/linux/scmi_protocol.h
@@ -0,0 +1,16 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * SCMI Message Protocol driver header
+ *
+ * Copyright (C) 2018 ARM Ltd.
+ */
+#include <linux/types.h>
+
+/**
+ * struct scmi_handle - Handle returned to ARM SCMI clients for usage.
+ *
+ * @dev: pointer to the SCMI device
+ */
+struct scmi_handle {
+	struct device *dev;
+};
