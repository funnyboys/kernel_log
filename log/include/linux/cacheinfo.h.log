commit 9a83c84c3a491cbe7fc9dea3c43e26a8e67204d2
Author: Shaokun Zhang <zhangshaokun@hisilicon.com>
Date:   Tue May 28 10:16:53 2019 +0800

    drivers: base: cacheinfo: Add variable to record max cache line size
    
    Add coherency_max_size variable to record the maximum cache line size
    for different cache levels. If it is available, we will synchronize
    it as cache line size, otherwise we will use CTR_EL0.CWG reporting
    in cache_line_size() for arm64.
    
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Jeremy Linton <jeremy.linton@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Reviewed-by: Sudeep Holla <sudeep.holla@arm.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Shaokun Zhang <zhangshaokun@hisilicon.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/include/linux/cacheinfo.h b/include/linux/cacheinfo.h
index 70e19bc6cc9f..46b92cd61d0c 100644
--- a/include/linux/cacheinfo.h
+++ b/include/linux/cacheinfo.h
@@ -17,6 +17,8 @@ enum cache_type {
 	CACHE_TYPE_UNIFIED = BIT(2),
 };
 
+extern unsigned int coherency_max_size;
+
 /**
  * struct cacheinfo - represent a cache leaf node
  * @id: This cache's id. It is unique among caches with the same (type, level).

commit 2520e627dbeecf7ccccc50c969504b59e1a3294b
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Tue Jun 5 15:35:03 2018 +0100

    ACPI / PPTT: fix build when CONFIG_ACPI_PPTT is not enabled
    
    Though CONFIG_ACPI_PPTT is selected by platforms and nor user visible,
    it may be useful to support the build with CONFIG_ACPI_PPTT disabled.
    
    This patch adds the missing dummy/boiler plate implementation to fix
    the build.
    
    Acked-by: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/include/linux/cacheinfo.h b/include/linux/cacheinfo.h
index 89397e30e269..70e19bc6cc9f 100644
--- a/include/linux/cacheinfo.h
+++ b/include/linux/cacheinfo.h
@@ -98,7 +98,7 @@ struct cpu_cacheinfo *get_cpu_cacheinfo(unsigned int cpu);
 int init_cache_level(unsigned int cpu);
 int populate_cache_leaves(unsigned int cpu);
 int cache_setup_acpi(unsigned int cpu);
-#ifndef CONFIG_ACPI
+#ifndef CONFIG_ACPI_PPTT
 /*
  * acpi_find_last_cache_level is only called on ACPI enabled
  * platforms using the PPTT for topology. This means that if

commit 582b468bdc6d9c287a432a63225cf7922e985e15
Author: Jeremy Linton <jeremy.linton@arm.com>
Date:   Fri May 11 18:58:02 2018 -0500

    drivers: base cacheinfo: Add support for ACPI based firmware tables
    
    Call ACPI cache parsing routines from base cacheinfo code if ACPI
    is enabled. Also stub out cache_setup_acpi and acpi_find_last_cache_level
    so that individual architectures can enable ACPI topology parsing.
    
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Tested-by: Vijaya Kumar K <vkilari@codeaurora.org>
    Tested-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Tested-by: Tomasz Nowicki <Tomasz.Nowicki@cavium.com>
    Acked-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Jeremy Linton <jeremy.linton@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/include/linux/cacheinfo.h b/include/linux/cacheinfo.h
index 0c6f658054d2..89397e30e269 100644
--- a/include/linux/cacheinfo.h
+++ b/include/linux/cacheinfo.h
@@ -97,6 +97,23 @@ int func(unsigned int cpu)					\
 struct cpu_cacheinfo *get_cpu_cacheinfo(unsigned int cpu);
 int init_cache_level(unsigned int cpu);
 int populate_cache_leaves(unsigned int cpu);
+int cache_setup_acpi(unsigned int cpu);
+#ifndef CONFIG_ACPI
+/*
+ * acpi_find_last_cache_level is only called on ACPI enabled
+ * platforms using the PPTT for topology. This means that if
+ * the platform supports other firmware configuration methods
+ * we need to stub out the call when ACPI is disabled.
+ * ACPI enabled platforms not using PPTT won't be making calls
+ * to this function so we need not worry about them.
+ */
+static inline int acpi_find_last_cache_level(unsigned int cpu)
+{
+	return 0;
+}
+#else
+int acpi_find_last_cache_level(unsigned int cpu);
+#endif
 
 const struct attribute_group *cache_get_priv_group(struct cacheinfo *this_leaf);
 

commit 9b97387c5c4260ffcdf3b913bdef0d98cb2d4a74
Author: Jeremy Linton <jeremy.linton@arm.com>
Date:   Fri May 11 18:57:58 2018 -0500

    cacheinfo: rename of_node to fw_token
    
    Rename and change the type of of_node to indicate
    it is a generic pointer which is generally only used
    for comparison purposes. In a later patch we will put
    an ACPI/PPTT token pointer in fw_token so that
    the code which builds the shared cpu masks can be reused.
    
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Tested-by: Vijaya Kumar K <vkilari@codeaurora.org>
    Tested-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Tested-by: Tomasz Nowicki <Tomasz.Nowicki@cavium.com>
    Acked-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Jeremy Linton <jeremy.linton@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/include/linux/cacheinfo.h b/include/linux/cacheinfo.h
index 3d9805297cda..0c6f658054d2 100644
--- a/include/linux/cacheinfo.h
+++ b/include/linux/cacheinfo.h
@@ -34,9 +34,8 @@ enum cache_type {
  * @shared_cpu_map: logical cpumask representing all the cpus sharing
  *	this cache node
  * @attributes: bitfield representing various cache attributes
- * @of_node: if devicetree is used, this represents either the cpu node in
- *	case there's no explicit cache node or the cache node itself in the
- *	device tree
+ * @fw_token: Unique value used to determine if different cacheinfo
+ *	structures represent a single hardware cache instance.
  * @disable_sysfs: indicates whether this node is visible to the user via
  *	sysfs or not
  * @priv: pointer to any private data structure specific to particular
@@ -65,8 +64,7 @@ struct cacheinfo {
 #define CACHE_ALLOCATE_POLICY_MASK	\
 	(CACHE_READ_ALLOCATE | CACHE_WRITE_ALLOCATE)
 #define CACHE_ID		BIT(4)
-
-	struct device_node *of_node;
+	void *fw_token;
 	bool disable_sysfs;
 	void *priv;
 };

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/cacheinfo.h b/include/linux/cacheinfo.h
index 6a524bf6a06d..3d9805297cda 100644
--- a/include/linux/cacheinfo.h
+++ b/include/linux/cacheinfo.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _LINUX_CACHEINFO_H
 #define _LINUX_CACHEINFO_H
 

commit eb254f323bd50ab7e3cc385f2fc641a595cc8b37
Merge: f79f7b1b4f91 76ae054c69a7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 22 09:25:45 2016 -0800

    Merge branch 'x86-cache-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 cache allocation interface from Thomas Gleixner:
     "This provides support for Intel's Cache Allocation Technology, a cache
      partitioning mechanism.
    
      The interface is odd, but the hardware interface of that CAT stuff is
      odd as well.
    
      We tried hard to come up with an abstraction, but that only allows
      rather simple partitioning, but no way of sharing and dealing with the
      per package nature of this mechanism.
    
      In the end we decided to expose the allocation bitmaps directly so all
      combinations of the hardware can be utilized.
    
      There are two ways of associating a cache partition:
    
       - Task
    
         A task can be added to a resource group. It uses the cache
         partition associated to the group.
    
       - CPU
    
         All tasks which are not member of a resource group use the group to
         which the CPU they are running on is associated with.
    
         That allows for simple CPU based partitioning schemes.
    
      The main expected user sare:
    
       - Virtualization so a VM can only trash only the associated part of
         the cash w/o disturbing others
    
       - Real-Time systems to seperate RT and general workloads.
    
       - Latency sensitive enterprise workloads
    
       - In theory this also can be used to protect against cache side
         channel attacks"
    
    [ Intel RDT is "Resource Director Technology". The interface really is
      rather odd and very specific, which delayed this pull request while I
      was thinking about it. The pull request itself came in early during
      the merge window, I just delayed it until things had calmed down and I
      had more time.
    
      But people tell me they'll use this, and the good news is that it is
      _so_ specific that it's rather independent of anything else, and no
      user is going to depend on the interface since it's pretty rare. So if
      push comes to shove, we can just remove the interface and nothing will
      break ]
    
    * 'x86-cache-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (31 commits)
      x86/intel_rdt: Implement show_options() for resctrlfs
      x86/intel_rdt: Call intel_rdt_sched_in() with preemption disabled
      x86/intel_rdt: Update task closid immediately on CPU in rmdir and unmount
      x86/intel_rdt: Fix setting of closid when adding CPUs to a group
      x86/intel_rdt: Update percpu closid immeditately on CPUs affected by changee
      x86/intel_rdt: Reset per cpu closids on unmount
      x86/intel_rdt: Select KERNFS when enabling INTEL_RDT_A
      x86/intel_rdt: Prevent deadlock against hotplug lock
      x86/intel_rdt: Protect info directory from removal
      x86/intel_rdt: Add info files to Documentation
      x86/intel_rdt: Export the minimum number of set mask bits in sysfs
      x86/intel_rdt: Propagate error in rdt_mount() properly
      x86/intel_rdt: Add a missing #include
      MAINTAINERS: Add maintainer for Intel RDT resource allocation
      x86/intel_rdt: Add scheduler hook
      x86/intel_rdt: Add schemata file
      x86/intel_rdt: Add tasks files
      x86/intel_rdt: Add cpus file
      x86/intel_rdt: Add mkdir to resctrl file system
      x86/intel_rdt: Add "info" files to resctrl file system
      ...

commit fac51482577d5e05bbb0efa8d602a3c2111098bf
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Fri Oct 28 09:45:28 2016 +0100

    drivers: base: cacheinfo: fix x86 with CONFIG_OF enabled
    
    With CONFIG_OF enabled on x86, we get the following error on boot:
    "
            Failed to find cpu0 device node
            Unable to detect cache hierarchy from DT for CPU 0
    "
    and the cacheinfo fails to get populated in the corresponding sysfs
    entries. This is because cache_setup_of_node looks for of_node for
    setting up the shared cpu_map without checking that it's already
    populated in the architecture specific callback.
    
    In order to indicate that the shared cpu_map is already populated, this
    patch introduces a boolean `cpu_map_populated` in struct cpu_cacheinfo
    that can be used by the generic code to skip cache_shared_cpu_map_setup.
    
    This patch also sets that boolean for x86.
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/cacheinfo.h b/include/linux/cacheinfo.h
index 2189935075b4..a951fd10aaaa 100644
--- a/include/linux/cacheinfo.h
+++ b/include/linux/cacheinfo.h
@@ -71,6 +71,7 @@ struct cpu_cacheinfo {
 	struct cacheinfo *info_list;
 	unsigned int num_levels;
 	unsigned int num_leaves;
+	bool cpu_map_populated;
 };
 
 /*

commit e9a2ea5a1ba09c35258f3663842fb8d8cf2e00c2
Author: Fenghua Yu <fenghua.yu@intel.com>
Date:   Sat Oct 22 06:19:49 2016 -0700

    cacheinfo: Introduce cache id
    
    Cache management software needs an id for each instance of a cache of
    a particular type.
    
    The current cacheinfo structure does not provide any information about
    the underlying hardware so there is no way to expose it.
    
    Hardware with cache management features provides means (cpuid, enumeration
    etc.) to retrieve the hardware id of a particular cache instance. Cache
    instances which share hardware have the same hardware id.
    
    Add an 'id' field to struct cacheinfo to store this information. Expose
    this information under the /sys/devices/system/cpu/cpu*/cache/index*/
    directory as well.
    
    Signed-off-by: Fenghua Yu <fenghua.yu@intel.com>
    Cc: "Ravi V Shankar" <ravi.v.shankar@intel.com>
    Cc: "Tony Luck" <tony.luck@intel.com>
    Cc: "David Carrillo-Cisneros" <davidcc@google.com>
    Cc: "Sai Prakhya" <sai.praneeth.prakhya@intel.com>
    Cc: "Peter Zijlstra" <peterz@infradead.org>
    Cc: "Stephane Eranian" <eranian@google.com>
    Cc: "Dave Hansen" <dave.hansen@intel.com>
    Cc: "Shaohua Li" <shli@fb.com>
    Cc: "Nilay Vaish" <nilayvaish@gmail.com>
    Cc: "Vikas Shivappa" <vikas.shivappa@linux.intel.com>
    Cc: "Ingo Molnar" <mingo@elte.hu>
    Cc: "Borislav Petkov" <bp@suse.de>
    Cc: "H. Peter Anvin" <h.peter.anvin@intel.com>
    Link: http://lkml.kernel.org/r/1477142405-32078-3-git-send-email-fenghua.yu@intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/cacheinfo.h b/include/linux/cacheinfo.h
index 2189935075b4..0bcbb674da9d 100644
--- a/include/linux/cacheinfo.h
+++ b/include/linux/cacheinfo.h
@@ -18,6 +18,7 @@ enum cache_type {
 
 /**
  * struct cacheinfo - represent a cache leaf node
+ * @id: This cache's id. It is unique among caches with the same (type, level).
  * @type: type of the cache - data, inst or unified
  * @level: represents the hierarchy in the multi-level cache
  * @coherency_line_size: size of each cache line usually representing
@@ -44,6 +45,7 @@ enum cache_type {
  * keeping, the remaining members form the core properties of the cache
  */
 struct cacheinfo {
+	unsigned int id;
 	enum cache_type type;
 	unsigned int level;
 	unsigned int coherency_line_size;
@@ -61,6 +63,7 @@ struct cacheinfo {
 #define CACHE_WRITE_ALLOCATE	BIT(3)
 #define CACHE_ALLOCATE_POLICY_MASK	\
 	(CACHE_READ_ALLOCATE | CACHE_WRITE_ALLOCATE)
+#define CACHE_ID		BIT(4)
 
 	struct device_node *of_node;
 	bool disable_sysfs;

commit 2539b258ec028351af954c169ea1b0ff72023a9f
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri May 8 14:45:34 2015 +0100

    drivers/base: cacheinfo: fix annoying typo when DT nodes are absent
    
    s/hierarcy/hierarchy/
    
    Maybe the typo will annoy people enough so that they add the missing
    nodes to their device-tree files, but I still think this is better off
    fixed.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/cacheinfo.h b/include/linux/cacheinfo.h
index 3daf5ed392c9..2189935075b4 100644
--- a/include/linux/cacheinfo.h
+++ b/include/linux/cacheinfo.h
@@ -19,7 +19,7 @@ enum cache_type {
 /**
  * struct cacheinfo - represent a cache leaf node
  * @type: type of the cache - data, inst or unified
- * @level: represents the hierarcy in the multi-level cache
+ * @level: represents the hierarchy in the multi-level cache
  * @coherency_line_size: size of each cache line usually representing
  *	the minimum amount of data that gets transferred from memory
  * @number_of_sets: total number of sets, a set is a collection of cache

commit 246246cbde5e840012f853e27630ebb59f409486
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Tue Sep 30 14:48:25 2014 +0100

    drivers: base: support cpu cache information interface to userspace via sysfs
    
    This patch adds initial support for providing processor cache information
    to userspace through sysfs interface. This is based on already existing
    implementations(x86, ia64, s390 and powerpc) and hence the interface is
    intended to be fully compatible.
    
    The main purpose of this generic support is to avoid further code
    duplication to support new architectures and also to unify all the existing
    different implementations.
    
    This implementation maintains the hierarchy of cache objects which reflects
    the system's cache topology. Cache devices are instantiated as needed as
    CPUs come online. The cache information is replicated per-cpu even if they are
    shared. A per-cpu array of cache information maintained is used mainly for
    sysfs-related book keeping.
    
    It also implements the shared_cpu_map attribute, which is essential for
    enabling both kernel and user-space to discover the system's overall cache
    topology.
    
    This patch also add the missing ABI documentation for the cacheinfo sysfs
    interface already, which is well defined and widely used.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Tested-by: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: linux-api@vger.kernel.org
    Cc: linux390@de.ibm.com
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-ia64@vger.kernel.org
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: linux-s390@vger.kernel.org
    Cc: x86@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/cacheinfo.h b/include/linux/cacheinfo.h
new file mode 100644
index 000000000000..3daf5ed392c9
--- /dev/null
+++ b/include/linux/cacheinfo.h
@@ -0,0 +1,100 @@
+#ifndef _LINUX_CACHEINFO_H
+#define _LINUX_CACHEINFO_H
+
+#include <linux/bitops.h>
+#include <linux/cpumask.h>
+#include <linux/smp.h>
+
+struct device_node;
+struct attribute;
+
+enum cache_type {
+	CACHE_TYPE_NOCACHE = 0,
+	CACHE_TYPE_INST = BIT(0),
+	CACHE_TYPE_DATA = BIT(1),
+	CACHE_TYPE_SEPARATE = CACHE_TYPE_INST | CACHE_TYPE_DATA,
+	CACHE_TYPE_UNIFIED = BIT(2),
+};
+
+/**
+ * struct cacheinfo - represent a cache leaf node
+ * @type: type of the cache - data, inst or unified
+ * @level: represents the hierarcy in the multi-level cache
+ * @coherency_line_size: size of each cache line usually representing
+ *	the minimum amount of data that gets transferred from memory
+ * @number_of_sets: total number of sets, a set is a collection of cache
+ *	lines sharing the same index
+ * @ways_of_associativity: number of ways in which a particular memory
+ *	block can be placed in the cache
+ * @physical_line_partition: number of physical cache lines sharing the
+ *	same cachetag
+ * @size: Total size of the cache
+ * @shared_cpu_map: logical cpumask representing all the cpus sharing
+ *	this cache node
+ * @attributes: bitfield representing various cache attributes
+ * @of_node: if devicetree is used, this represents either the cpu node in
+ *	case there's no explicit cache node or the cache node itself in the
+ *	device tree
+ * @disable_sysfs: indicates whether this node is visible to the user via
+ *	sysfs or not
+ * @priv: pointer to any private data structure specific to particular
+ *	cache design
+ *
+ * While @of_node, @disable_sysfs and @priv are used for internal book
+ * keeping, the remaining members form the core properties of the cache
+ */
+struct cacheinfo {
+	enum cache_type type;
+	unsigned int level;
+	unsigned int coherency_line_size;
+	unsigned int number_of_sets;
+	unsigned int ways_of_associativity;
+	unsigned int physical_line_partition;
+	unsigned int size;
+	cpumask_t shared_cpu_map;
+	unsigned int attributes;
+#define CACHE_WRITE_THROUGH	BIT(0)
+#define CACHE_WRITE_BACK	BIT(1)
+#define CACHE_WRITE_POLICY_MASK		\
+	(CACHE_WRITE_THROUGH | CACHE_WRITE_BACK)
+#define CACHE_READ_ALLOCATE	BIT(2)
+#define CACHE_WRITE_ALLOCATE	BIT(3)
+#define CACHE_ALLOCATE_POLICY_MASK	\
+	(CACHE_READ_ALLOCATE | CACHE_WRITE_ALLOCATE)
+
+	struct device_node *of_node;
+	bool disable_sysfs;
+	void *priv;
+};
+
+struct cpu_cacheinfo {
+	struct cacheinfo *info_list;
+	unsigned int num_levels;
+	unsigned int num_leaves;
+};
+
+/*
+ * Helpers to make sure "func" is executed on the cpu whose cache
+ * attributes are being detected
+ */
+#define DEFINE_SMP_CALL_CACHE_FUNCTION(func)			\
+static inline void _##func(void *ret)				\
+{								\
+	int cpu = smp_processor_id();				\
+	*(int *)ret = __##func(cpu);				\
+}								\
+								\
+int func(unsigned int cpu)					\
+{								\
+	int ret;						\
+	smp_call_function_single(cpu, _##func, &ret, true);	\
+	return ret;						\
+}
+
+struct cpu_cacheinfo *get_cpu_cacheinfo(unsigned int cpu);
+int init_cache_level(unsigned int cpu);
+int populate_cache_leaves(unsigned int cpu);
+
+const struct attribute_group *cache_get_priv_group(struct cacheinfo *this_leaf);
+
+#endif /* _LINUX_CACHEINFO_H */
