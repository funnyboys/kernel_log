commit ce2b617ce8cbb7ba7a956299061bbc784131333c
Author: Jessica Yu <jeyu@kernel.org>
Date:   Tue Nov 12 12:35:59 2019 +0100

    export.h: reduce __ksymtab_strings string duplication by using "MS" section flags
    
    Commit c3a6cf19e695 ("export: avoid code duplication in
    include/linux/export.h") refactors export.h quite nicely, but introduces
    a slight increase in memory usage due to using the empty string ""
    instead of NULL to indicate that an exported symbol has no namespace. As
    mentioned in that commit, this meant an increase of 1 byte per exported
    symbol without a namespace. For example, if a kernel configuration has
    about 10k exported symbols, this would mean that the size of
    __ksymtab_strings would increase by roughly 10kB.
    
    We can alleviate this situation by utilizing the SHF_MERGE and
    SHF_STRING section flags. SHF_MERGE|SHF_STRING indicate to the linker
    that the data in the section are null-terminated strings that can be
    merged to eliminate duplication. More specifically, from the binutils
    documentation - "for sections with both M and S, a string which is a
    suffix of a larger string is considered a duplicate. Thus "def" will be
    merged with "abcdef"; A reference to the first "def" will be changed to
    a reference to "abcdef"+3". Thus, all the empty strings would be merged
    as well as any strings that can be merged according to the cited method
    above. For example, "memset" and "__memset" would be merged to just
    "__memset" in __ksymtab_strings.
    
    As of v5.4-rc5, the following statistics were gathered with x86
    defconfig with approximately 10.7k exported symbols.
    
    Size of __ksymtab_strings in vmlinux:
    -------------------------------------
    v5.4-rc5: 213834 bytes
    v5.4-rc5 with commit c3a6cf19e695: 224455 bytes
    v5.4-rc5 with this patch: 205759 bytes
    
    So, we already see memory savings of ~8kB compared to vanilla -rc5 and
    savings of nearly 18.7kB compared to -rc5 with commit c3a6cf19e695 on top.
    
    Unfortunately, as of this writing, strings will not get deduplicated for
    kernel modules, as ld does not do the deduplication for
    SHF_MERGE|SHF_STRINGS sections for relocatable files (ld -r), which
    kernel modules are. A patch for ld is currently being worked on to
    hopefully allow for string deduplication in relocatable files in the
    future.
    
    Suggested-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Reviewed-by: Masahiro Yamada <masahiroy@kernel.org>
    Reviewed-by: Matthias Maennich <maennich@google.com>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/include/asm-generic/export.h b/include/asm-generic/export.h
index afddc5442e92..365345f9a9e3 100644
--- a/include/asm-generic/export.h
+++ b/include/asm-generic/export.h
@@ -27,9 +27,11 @@
 .endm
 
 /*
- * note on .section use: @progbits vs %progbits nastiness doesn't matter,
- * since we immediately emit into those sections anyway.
+ * note on .section use: we specify progbits since usage of the "M" (SHF_MERGE)
+ * section flag requires it. Use '%progbits' instead of '@progbits' since the
+ * former apparently works on all arches according to the binutils source.
  */
+
 .macro ___EXPORT_SYMBOL name,val,sec
 #ifdef CONFIG_MODULES
 	.section ___ksymtab\sec+\name,"a"
@@ -37,7 +39,7 @@
 __ksymtab_\name:
 	__put \val, __kstrtab_\name
 	.previous
-	.section __ksymtab_strings,"a"
+	.section __ksymtab_strings,"aMS",%progbits,1
 __kstrtab_\name:
 	.asciz "\name"
 	.previous

commit 388c645a33a739bb96aa5ffe283ec68786ea7890
Merge: 537bd0a159a0 bf49d9dd6fef
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 3 14:20:21 2019 -0800

    Merge tag 'spdx-5.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/spdx
    
    Pull SPDX fix from Greg KH:
     "Here is a single SPDX fixup for 5.5-rc1
    
      It resolves an issue where we had missed a few .h files with the
      auto-tagging scripts because they had "GPL" text in strings within the
      file themselves. This single patch fixes up the issue and provides the
      proper SPDX tags at the top of them as needed.
    
      This patch has been in linux-next for many many weeks now with no
      reported issues"
    
    * tag 'spdx-5.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/spdx:
      export,module: add SPDX GPL-2.0 license identifier to headers with no license

commit bf49d9dd6fef688733e2ddbd55f7bcb57df194e4
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Oct 18 13:50:53 2019 +0900

    export,module: add SPDX GPL-2.0 license identifier to headers with no license
    
    Commit b24413180f56 ("License cleanup: add SPDX GPL-2.0 license
    identifier to files with no license") took care of a lot of files
    without any license information.
    
    These headers were not processed by the tool perhaps because they
    contain "GPL" in the code.
    
    I do not see any license boilerplate in them, so they fall back to
    GPL version 2 only, which is the project default.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Link: https://lore.kernel.org/r/20191018045053.8424-1-yamada.masahiro@socionext.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/asm-generic/export.h b/include/asm-generic/export.h
index fa577978fbbd..d0166115a825 100644
--- a/include/asm-generic/export.h
+++ b/include/asm-generic/export.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 #ifndef __ASM_GENERIC_EXPORT_H
 #define __ASM_GENERIC_EXPORT_H
 

commit 03034dbdaed8b47282d647c1100dbb0f522798f3
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Oct 18 13:31:48 2019 +0900

    asm-generic/export.h: remove unneeded __kcrctab_* symbols
    
    EXPORT_SYMBOL from assembly code produces an unused symbol __kcrctab_*.
    
    kcrctab is used as a section name (prefixed with three underscores),
    but never used as a symbol.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/include/asm-generic/export.h b/include/asm-generic/export.h
index 80ef2dc0c8be..a3983e2ce0fd 100644
--- a/include/asm-generic/export.h
+++ b/include/asm-generic/export.h
@@ -43,7 +43,6 @@ __kstrtab_\name:
 #ifdef CONFIG_MODVERSIONS
 	.section ___kcrctab\sec+\name,"a"
 	.balign KCRC_ALIGN
-__kcrctab_\name:
 #if defined(CONFIG_MODULE_REL_CRCS)
 	.long __crc_\name - .
 #else

commit a31ec048ef01a76ff893e0fa482e569d04d0c4b4
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Oct 18 13:31:47 2019 +0900

    asm-generic/export.h: make __ksymtab_* local symbols
    
    For EXPORT_SYMBOL from C files, <linux/export.h> defines __ksymtab_*
    as local symbols.
    
    For EXPORT_SYMBOL from assembly, in contrast, <asm-generic/export.h>
    produces globally-visible __ksymtab_* symbols due to this .globl
    directive.
    
    I do not know why this must be global. It still works without this.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/include/asm-generic/export.h b/include/asm-generic/export.h
index fa577978fbbd..80ef2dc0c8be 100644
--- a/include/asm-generic/export.h
+++ b/include/asm-generic/export.h
@@ -31,7 +31,6 @@
  */
 .macro ___EXPORT_SYMBOL name,val,sec
 #ifdef CONFIG_MODULES
-	.globl __ksymtab_\name
 	.section ___ksymtab\sec+\name,"a"
 	.balign KSYM_ALIGN
 __ksymtab_\name:

commit 2e6fcfeb9df6048a63fe0d5f7dfa39274bacbb71
Author: Will Deacon <will@kernel.org>
Date:   Thu Sep 12 00:00:18 2019 +0100

    module: Remove leftover '#undef' from export header
    
    Commit 7290d5809571 ("module: use relative references for __ksymtab
    entries") converted the '__put' #define into an assembly macro in
    asm-generic/export.h but forgot to remove the corresponding '#undef'.
    
    Remove the leftover '#undef'.
    
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Jessica Yu <jeyu@kernel.org>
    Signed-off-by: Will Deacon <will@kernel.org>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/include/asm-generic/export.h b/include/asm-generic/export.h
index d0912c7ac2fc..fa577978fbbd 100644
--- a/include/asm-generic/export.h
+++ b/include/asm-generic/export.h
@@ -55,7 +55,6 @@ __kcrctab_\name:
 #endif
 #endif
 .endm
-#undef __put
 
 #if defined(CONFIG_TRIM_UNUSED_KSYMS)
 

commit 069e1c07c18ac2ccecdfb5ac287a37d6fb2d7a00
Author: Will Deacon <will@kernel.org>
Date:   Wed Sep 11 13:26:46 2019 +0100

    module: Fix link failure due to invalid relocation on namespace offset
    
    Commit 8651ec01daed ("module: add support for symbol namespaces.")
    broke linking for arm64 defconfig:
    
      | lib/crypto/arc4.o: In function `__ksymtab_arc4_setkey':
      | arc4.c:(___ksymtab+arc4_setkey+0x8): undefined reference to `no symbol'
      | lib/crypto/arc4.o: In function `__ksymtab_arc4_crypt':
      | arc4.c:(___ksymtab+arc4_crypt+0x8): undefined reference to `no symbol'
    
    This is because the dummy initialisation of the 'namespace_offset' field
    in 'struct kernel_symbol' when using EXPORT_SYMBOL on architectures with
    support for PREL32 locations uses an offset from an absolute address (0)
    in an effort to trick 'offset_to_pointer' into behaving as a NOP,
    allowing non-namespaced symbols to be treated in the same way as those
    belonging to a namespace.
    
    Unfortunately, place-relative relocations require a symbol reference
    rather than an absolute value and, although x86 appears to get away with
    this due to placing the kernel text at the top of the address space, it
    almost certainly results in a runtime failure if the kernel is relocated
    dynamically as a result of KASLR.
    
    Rework 'namespace_offset' so that a value of 0, which cannot occur for a
    valid namespaced symbol, indicates that the corresponding symbol does
    not belong to a namespace.
    
    Cc: Matthias Maennich <maennich@google.com>
    Cc: Jessica Yu <jeyu@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Fixes: 8651ec01daed ("module: add support for symbol namespaces.")
    Reported-by: kbuild test robot <lkp@intel.com>
    Tested-by: Matthias Maennich <maennich@google.com>
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Matthias Maennich <maennich@google.com>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Will Deacon <will@kernel.org>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/include/asm-generic/export.h b/include/asm-generic/export.h
index e2b5d0f569d3..d0912c7ac2fc 100644
--- a/include/asm-generic/export.h
+++ b/include/asm-generic/export.h
@@ -17,7 +17,7 @@
 
 .macro __put, val, name
 #ifdef CONFIG_HAVE_ARCH_PREL32_RELOCATIONS
-	.long	\val - ., \name - ., 0 - .
+	.long	\val - ., \name - ., 0
 #elif defined(CONFIG_64BIT)
 	.quad	\val, \name, 0
 #else

commit 8651ec01daedad26290f76beeb4736f9d2da4b87
Author: Matthias Maennich <maennich@google.com>
Date:   Fri Sep 6 11:32:27 2019 +0100

    module: add support for symbol namespaces.
    
    The EXPORT_SYMBOL_NS() and EXPORT_SYMBOL_NS_GPL() macros can be used to
    export a symbol to a specific namespace.  There are no _GPL_FUTURE and
    _UNUSED variants because these are currently unused, and I'm not sure
    they are necessary.
    
    I didn't add EXPORT_SYMBOL_NS() for ASM exports; this patch sets the
    namespace of ASM exports to NULL by default. In case of relative
    references, it will be relocatable to NULL. If there's a need, this
    should be pretty easy to add.
    
    A module that wants to use a symbol exported to a namespace must add a
    MODULE_IMPORT_NS() statement to their module code; otherwise, modpost
    will complain when building the module, and the kernel module loader
    will emit an error and fail when loading the module.
    
    MODULE_IMPORT_NS() adds a modinfo tag 'import_ns' to the module. That
    tag can be observed by the modinfo command, modpost and kernel/module.c
    at the time of loading the module.
    
    The ELF symbols are renamed to include the namespace with an asm label;
    for example, symbol 'usb_stor_suspend' in namespace USB_STORAGE becomes
    'usb_stor_suspend.USB_STORAGE'.  This allows modpost to do namespace
    checking, without having to go through all the effort of parsing ELF and
    relocation records just to get to the struct kernel_symbols.
    
    On x86_64 I saw no difference in binary size (compression), but at
    runtime this will require a word of memory per export to hold the
    namespace. An alternative could be to store namespaced symbols in their
    own section and use a separate 'struct namespaced_kernel_symbol' for
    that section, at the cost of making the module loader more complex.
    
    Co-developed-by: Martijn Coenen <maco@android.com>
    Signed-off-by: Martijn Coenen <maco@android.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Matthias Maennich <maennich@google.com>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/include/asm-generic/export.h b/include/asm-generic/export.h
index 63f54907317b..e2b5d0f569d3 100644
--- a/include/asm-generic/export.h
+++ b/include/asm-generic/export.h
@@ -17,11 +17,11 @@
 
 .macro __put, val, name
 #ifdef CONFIG_HAVE_ARCH_PREL32_RELOCATIONS
-	.long	\val - ., \name - .
+	.long	\val - ., \name - ., 0 - .
 #elif defined(CONFIG_64BIT)
-	.quad	\val, \name
+	.quad	\val, \name, 0
 #else
-	.long	\val, \name
+	.long	\val, \name, 0
 #endif
 .endm
 

commit ed13fc33f763035a7c290f11c7111877c3a5daab
Author: Matthias Maennich <maennich@google.com>
Date:   Fri Sep 6 11:32:26 2019 +0100

    export: explicitly align struct kernel_symbol
    
    This change allows growing struct kernel_symbol without wasting bytes to
    alignment. It also concretized the alignment of ksymtab entries if
    relative references are used for ksymtab entries.
    
    struct kernel_symbol was already implicitly being aligned to the word
    size, except on x86_64 and m68k, where it is aligned to 16 and 2 bytes,
    respectively.
    
    As far as I can tell there is no requirement for aligning struct
    kernel_symbol to 16 bytes on x86_64, but gcc aligns structs to their
    size, and the linker aligns the custom __ksymtab sections to the largest
    data type contained within, so setting KSYM_ALIGN to 16 was necessary to
    stay consistent with the code generated for non-ASM EXPORT_SYMBOL(). Now
    that non-ASM EXPORT_SYMBOL() explicitly aligns to word size (8),
    KSYM_ALIGN is no longer necessary.
    
    In case of relative references, the alignment has been changed
    accordingly to not waste space when adding new struct members.
    
    As for m68k, struct kernel_symbol is aligned to 2 bytes even though the
    structure itself is 8 bytes; using a 4-byte alignment shouldn't hurt.
    
    I manually verified the output of the __ksymtab sections didn't change
    on x86, x86_64, arm, arm64 and m68k. As expected, the section contents
    didn't change, and the ELF section alignment only changed on x86_64 and
    m68k. Feedback from other archs more than welcome.
    
    Co-developed-by: Martijn Coenen <maco@android.com>
    Signed-off-by: Martijn Coenen <maco@android.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Matthias Maennich <maennich@google.com>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/include/asm-generic/export.h b/include/asm-generic/export.h
index 294d6ae785d4..63f54907317b 100644
--- a/include/asm-generic/export.h
+++ b/include/asm-generic/export.h
@@ -4,15 +4,13 @@
 #ifndef KSYM_FUNC
 #define KSYM_FUNC(x) x
 #endif
-#ifdef CONFIG_64BIT
-#ifndef KSYM_ALIGN
+#ifdef CONFIG_HAVE_ARCH_PREL32_RELOCATIONS
+#define KSYM_ALIGN 4
+#elif defined(CONFIG_64BIT)
 #define KSYM_ALIGN 8
-#endif
 #else
-#ifndef KSYM_ALIGN
 #define KSYM_ALIGN 4
 #endif
-#endif
 #ifndef KCRC_ALIGN
 #define KCRC_ALIGN 4
 #endif

commit bbda5ec671d3fe62faefa1cab7270aa586042a4b
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 30 10:05:26 2018 +0900

    kbuild: simplify dependency generation for CONFIG_TRIM_UNUSED_KSYMS
    
    My main motivation of this commit is to clean up scripts/Kbuild.include
    and scripts/Makefile.build.
    
    Currently, CONFIG_TRIM_UNUSED_KSYMS works with a tricky gimmick;
    possibly exported symbols are detected by letting $(CPP) replace
    EXPORT_SYMBOL* with a special string '=== __KSYM_*===', which is
    post-processed by sed, and passed to fixdep. The extra preprocessing
    is costly, and hacking cmd_and_fixdep is ugly.
    
    I came up with a new way to find exported symbols; insert a dummy
    symbol __ksym_marker_* to each potentially exported symbol. Those
    dummy symbols are picked up by $(NM), post-processed by sed, then
    appended to .*.cmd files. I collected the post-process part to a
    new shell script scripts/gen_ksymdeps.sh for readability. The dummy
    symbols are put into the .discard.* section so that the linker
    script rips them off the final vmlinux or modules.
    
    A nice side-effect is building with CONFIG_TRIM_UNUSED_KSYMS will
    be much faster.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Nicolas Pitre <nico@linaro.org>

diff --git a/include/asm-generic/export.h b/include/asm-generic/export.h
index 4d73e6e3c66c..294d6ae785d4 100644
--- a/include/asm-generic/export.h
+++ b/include/asm-generic/export.h
@@ -59,16 +59,19 @@ __kcrctab_\name:
 .endm
 #undef __put
 
-#if defined(__KSYM_DEPS__)
-
-#define __EXPORT_SYMBOL(sym, val, sec)	=== __KSYM_##sym ===
-
-#elif defined(CONFIG_TRIM_UNUSED_KSYMS)
+#if defined(CONFIG_TRIM_UNUSED_KSYMS)
 
 #include <linux/kconfig.h>
 #include <generated/autoksyms.h>
 
+.macro __ksym_marker sym
+	.section ".discard.ksym","a"
+__ksym_marker_\sym:
+	 .previous
+.endm
+
 #define __EXPORT_SYMBOL(sym, val, sec)				\
+	__ksym_marker sym;					\
 	__cond_export_sym(sym, val, sec, __is_defined(__KSYM_##sym))
 #define __cond_export_sym(sym, val, sec, conf)			\
 	___cond_export_sym(sym, val, sec, conf)

commit 7290d58095712a89f845e1bca05334796dd49ed2
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Aug 21 21:56:09 2018 -0700

    module: use relative references for __ksymtab entries
    
    An ordinary arm64 defconfig build has ~64 KB worth of __ksymtab entries,
    each consisting of two 64-bit fields containing absolute references, to
    the symbol itself and to a char array containing its name, respectively.
    
    When we build the same configuration with KASLR enabled, we end up with an
    additional ~192 KB of relocations in the .init section, i.e., one 24 byte
    entry for each absolute reference, which all need to be processed at boot
    time.
    
    Given how the struct kernel_symbol that describes each entry is completely
    local to module.c (except for the references emitted by EXPORT_SYMBOL()
    itself), we can easily modify it to contain two 32-bit relative references
    instead.  This reduces the size of the __ksymtab section by 50% for all
    64-bit architectures, and gets rid of the runtime relocations entirely for
    architectures implementing KASLR, either via standard PIE linking (arm64)
    or using custom host tools (x86).
    
    Note that the binary search involving __ksymtab contents relies on each
    section being sorted by symbol name.  This is implemented based on the
    input section names, not the names in the ksymtab entries, so this patch
    does not interfere with that.
    
    Given that the use of place-relative relocations requires support both in
    the toolchain and in the module loader, we cannot enable this feature for
    all architectures.  So make it dependent on whether
    CONFIG_HAVE_ARCH_PREL32_RELOCATIONS is defined.
    
    Link: http://lkml.kernel.org/r/20180704083651.24360-4-ard.biesheuvel@linaro.org
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Jessica Yu <jeyu@kernel.org>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>
    Reviewed-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: James Morris <james.morris@microsoft.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Nicolas Pitre <nico@linaro.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: "Serge E. Hallyn" <serge@hallyn.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Garnier <thgarnie@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/asm-generic/export.h b/include/asm-generic/export.h
index 68efb950a918..4d73e6e3c66c 100644
--- a/include/asm-generic/export.h
+++ b/include/asm-generic/export.h
@@ -5,12 +5,10 @@
 #define KSYM_FUNC(x) x
 #endif
 #ifdef CONFIG_64BIT
-#define __put .quad
 #ifndef KSYM_ALIGN
 #define KSYM_ALIGN 8
 #endif
 #else
-#define __put .long
 #ifndef KSYM_ALIGN
 #define KSYM_ALIGN 4
 #endif
@@ -19,6 +17,16 @@
 #define KCRC_ALIGN 4
 #endif
 
+.macro __put, val, name
+#ifdef CONFIG_HAVE_ARCH_PREL32_RELOCATIONS
+	.long	\val - ., \name - .
+#elif defined(CONFIG_64BIT)
+	.quad	\val, \name
+#else
+	.long	\val, \name
+#endif
+.endm
+
 /*
  * note on .section use: @progbits vs %progbits nastiness doesn't matter,
  * since we immediately emit into those sections anyway.

commit 94e58e0ac31284fa26597c0e00a9b1d87a691d02
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed May 9 16:23:49 2018 +0900

    export.h: remove code for prefixing symbols with underscore
    
    CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX was selected by BLACKFIN, METAG.
    They were removed by commit 4ba66a976072 ("arch: remove blackfin port"),
    commit bb6fb6dfcc17 ("metag: Remove arch/metag/"), respectively.
    
    No more architecture enables CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX.
    Clean up the export.h headers.  I am keeping VMLINUX_SYMBOL() and
    VMLINUX_SYMBOL_STR() because they are widely used.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/include/asm-generic/export.h b/include/asm-generic/export.h
index 719db1968d81..68efb950a918 100644
--- a/include/asm-generic/export.h
+++ b/include/asm-generic/export.h
@@ -19,42 +19,32 @@
 #define KCRC_ALIGN 4
 #endif
 
-#ifdef CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX
-#define KSYM(name) _##name
-#else
-#define KSYM(name) name
-#endif
-
 /*
  * note on .section use: @progbits vs %progbits nastiness doesn't matter,
  * since we immediately emit into those sections anyway.
  */
 .macro ___EXPORT_SYMBOL name,val,sec
 #ifdef CONFIG_MODULES
-	.globl KSYM(__ksymtab_\name)
+	.globl __ksymtab_\name
 	.section ___ksymtab\sec+\name,"a"
 	.balign KSYM_ALIGN
-KSYM(__ksymtab_\name):
-	__put \val, KSYM(__kstrtab_\name)
+__ksymtab_\name:
+	__put \val, __kstrtab_\name
 	.previous
 	.section __ksymtab_strings,"a"
-KSYM(__kstrtab_\name):
-#ifdef CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX
-	.asciz "_\name"
-#else
+__kstrtab_\name:
 	.asciz "\name"
-#endif
 	.previous
 #ifdef CONFIG_MODVERSIONS
 	.section ___kcrctab\sec+\name,"a"
 	.balign KCRC_ALIGN
-KSYM(__kcrctab_\name):
+__kcrctab_\name:
 #if defined(CONFIG_MODULE_REL_CRCS)
-	.long KSYM(__crc_\name) - .
+	.long __crc_\name - .
 #else
-	.long KSYM(__crc_\name)
+	.long __crc_\name
 #endif
-	.weak KSYM(__crc_\name)
+	.weak __crc_\name
 	.previous
 #endif
 #endif
@@ -84,12 +74,12 @@ KSYM(__kcrctab_\name):
 #endif
 
 #define EXPORT_SYMBOL(name)					\
-	__EXPORT_SYMBOL(name, KSYM_FUNC(KSYM(name)),)
+	__EXPORT_SYMBOL(name, KSYM_FUNC(name),)
 #define EXPORT_SYMBOL_GPL(name) 				\
-	__EXPORT_SYMBOL(name, KSYM_FUNC(KSYM(name)), _gpl)
+	__EXPORT_SYMBOL(name, KSYM_FUNC(name), _gpl)
 #define EXPORT_DATA_SYMBOL(name)				\
-	__EXPORT_SYMBOL(name, KSYM(name),)
+	__EXPORT_SYMBOL(name, name,)
 #define EXPORT_DATA_SYMBOL_GPL(name)				\
-	__EXPORT_SYMBOL(name, KSYM(name),_gpl)
+	__EXPORT_SYMBOL(name, name,_gpl)
 
 #endif

commit 71810db27c1c853b335675bee335d893bc3d324b
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Feb 3 09:54:06 2017 +0000

    modversions: treat symbol CRCs as 32 bit quantities
    
    The modversion symbol CRCs are emitted as ELF symbols, which allows us
    to easily populate the kcrctab sections by relying on the linker to
    associate each kcrctab slot with the correct value.
    
    This has a couple of downsides:
    
     - Given that the CRCs are treated as memory addresses, we waste 4 bytes
       for each CRC on 64 bit architectures,
    
     - On architectures that support runtime relocation, a R_<arch>_RELATIVE
       relocation entry is emitted for each CRC value, which identifies it
       as a quantity that requires fixing up based on the actual runtime
       load offset of the kernel. This results in corrupted CRCs unless we
       explicitly undo the fixup (and this is currently being handled in the
       core module code)
    
     - Such runtime relocation entries take up 24 bytes of __init space
       each, resulting in a x8 overhead in [uncompressed] kernel size for
       CRCs.
    
    Switching to explicit 32 bit values on 64 bit architectures fixes most
    of these issues, given that 32 bit values are not treated as quantities
    that require fixing up based on the actual runtime load offset.  Note
    that on some ELF64 architectures [such as PPC64], these 32-bit values
    are still emitted as [absolute] runtime relocatable quantities, even if
    the value resolves to a build time constant.  Since relative relocations
    are always resolved at build time, this patch enables MODULE_REL_CRCS on
    powerpc when CONFIG_RELOCATABLE=y, which turns the absolute CRC
    references into relative references into .rodata where the actual CRC
    value is stored.
    
    So redefine all CRC fields and variables as u32, and redefine the
    __CRC_SYMBOL() macro for 64 bit builds to emit the CRC reference using
    inline assembler (which is necessary since 64-bit C code cannot use
    32-bit types to hold memory addresses, even if they are ultimately
    resolved using values that do not exceed 0xffffffff).  To avoid
    potential problems with legacy 32-bit architectures using legacy
    toolchains, the equivalent C definition of the kcrctab entry is retained
    for 32-bit architectures.
    
    Note that this mostly reverts commit d4703aefdbc8 ("module: handle ppc64
    relocating kcrctabs when CONFIG_RELOCATABLE=y")
    
    Acked-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/asm-generic/export.h b/include/asm-generic/export.h
index 63554e9f6e0c..719db1968d81 100644
--- a/include/asm-generic/export.h
+++ b/include/asm-generic/export.h
@@ -9,18 +9,15 @@
 #ifndef KSYM_ALIGN
 #define KSYM_ALIGN 8
 #endif
-#ifndef KCRC_ALIGN
-#define KCRC_ALIGN 8
-#endif
 #else
 #define __put .long
 #ifndef KSYM_ALIGN
 #define KSYM_ALIGN 4
 #endif
+#endif
 #ifndef KCRC_ALIGN
 #define KCRC_ALIGN 4
 #endif
-#endif
 
 #ifdef CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX
 #define KSYM(name) _##name
@@ -52,7 +49,11 @@ KSYM(__kstrtab_\name):
 	.section ___kcrctab\sec+\name,"a"
 	.balign KCRC_ALIGN
 KSYM(__kcrctab_\name):
-	__put KSYM(__crc_\name)
+#if defined(CONFIG_MODULE_REL_CRCS)
+	.long KSYM(__crc_\name) - .
+#else
+	.long KSYM(__crc_\name)
+#endif
 	.weak KSYM(__crc_\name)
 	.previous
 #endif

commit f27c2f69cc8edc03ea8086f974811b9b45b2f3a5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 7 08:39:00 2016 -0800

    Revert "default exported asm symbols to zero"
    
    This reverts commit 8ab2ae655bfe384335c5b6b0d6041e0ddce26b00.
    
    I loved that commit because of how it explained what the problem with
    newer versions of binutils were, but the actual patch itself turns out
    to not work very well.
    
    It has two problems:
    
     - a zero CRC value isn't actually right.  It happens to work for the
       case where both sides of the equation fail at giving the symbol a
       crc, but there are cases where the users of the exported symbol get
       the right crc (due to seeing the C declarations), but the actual
       exporting itself does not (due to the whole weak asm symbol issue).
    
       So then the module load fails after all - we did have a crc for the
       symbol, but we couldn't match it with the loaded module.
    
     - it seems that the alpha assembler has special semantics for the
       '.set' directive, and on alpha it doesn't actually set the value of
       the specified symbol at all, it is instead used to set various
       assembly modes (eg ".set noat" and ".set noreorder").
    
       So using ".set" to set the symbol value would just cause build
       failures on alpha.
    
    I'm sure we'll find some other workaround for these issues (hopefully
    that involves getting rid of modversions entirely some day, but people
    are also talking about just using smarter tools).  But for now we'll
    just fall back on commit faaae2a58143 ("Re-enable CONFIG_MODVERSIONS in
    a slightly weaker form") that just let's a missing crc through.
    
    Reported-by: Jan Stancek <jstancek@redhat.com>
    Reported-by: Philip Müller <philm@manjaro.org>
    Reported-by: Guenter Roeck <linux@roeck-us.net>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/asm-generic/export.h b/include/asm-generic/export.h
index 59a3b2f58c22..63554e9f6e0c 100644
--- a/include/asm-generic/export.h
+++ b/include/asm-generic/export.h
@@ -54,7 +54,6 @@ KSYM(__kstrtab_\name):
 KSYM(__kcrctab_\name):
 	__put KSYM(__crc_\name)
 	.weak KSYM(__crc_\name)
-	.set KSYM(__crc_\name), 0
 	.previous
 #endif
 #endif

commit 8ab2ae655bfe384335c5b6b0d6041e0ddce26b00
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Dec 2 13:40:27 2016 +0100

    default exported asm symbols to zero
    
    With binutils-2.26 and before, a weak missing symbol was kept during the
    final link, and a missing CRC for an export would lead to that CRC being
    treated as zero implicitly.  With binutils-2.27, the crc symbol gets
    dropped, and any module trying to use it will fail to load.
    
    This sets the weak CRC symbol to zero explicitly, making it defined in
    vmlinux, which in turn lets us load the modules referring to that CRC.
    
    The comment above the __CRC_SYMBOL macro suggests that this was always
    the intention, although it also seems that all symbols defined in C have
    a correct CRC these days, and only the exports that are now done in
    assembly need this.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Tested-by: Adam Borowski <kilobyte@angband.pl>
    Cc: stable@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/asm-generic/export.h b/include/asm-generic/export.h
index 63554e9f6e0c..59a3b2f58c22 100644
--- a/include/asm-generic/export.h
+++ b/include/asm-generic/export.h
@@ -54,6 +54,7 @@ KSYM(__kstrtab_\name):
 KSYM(__kcrctab_\name):
 	__put KSYM(__crc_\name)
 	.weak KSYM(__crc_\name)
+	.set KSYM(__crc_\name), 0
 	.previous
 #endif
 #endif

commit c0a0aba8e478229b2f0956918542152fbad3f794
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Oct 27 17:46:38 2016 -0700

    kconfig.h: remove config_enabled() macro
    
    The use of config_enabled() is ambiguous.  For config options,
    IS_ENABLED(), IS_REACHABLE(), etc.  will make intention clearer.
    Sometimes config_enabled() has been used for non-config options because
    it is useful to check whether the given symbol is defined or not.
    
    I have been tackling on deprecating config_enabled(), and now is the
    time to finish this work.
    
    Some new users have appeared for v4.9-rc1, but it is trivial to replace
    them:
    
     - arch/x86/mm/kaslr.c
      replace config_enabled() with IS_ENABLED() because
      CONFIG_X86_ESPFIX64 and CONFIG_EFI are boolean.
    
     - include/asm-generic/export.h
      replace config_enabled() with __is_defined().
    
    Then, config_enabled() can be removed now.
    
    Going forward, please use IS_ENABLED(), IS_REACHABLE(), etc. for config
    options, and __is_defined() for non-config symbols.
    
    Link: http://lkml.kernel.org/r/1476616078-32252-1-git-send-email-yamada.masahiro@socionext.com
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Cc: Peter Oberparleiter <oberpar@linux.vnet.ibm.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Michal Marek <mmarek@suse.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Thomas Garnier <thgarnie@google.com>
    Cc: Paul Bolle <pebolle@tiscali.nl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/asm-generic/export.h b/include/asm-generic/export.h
index 43199a049da5..63554e9f6e0c 100644
--- a/include/asm-generic/export.h
+++ b/include/asm-generic/export.h
@@ -70,7 +70,7 @@ KSYM(__kcrctab_\name):
 #include <generated/autoksyms.h>
 
 #define __EXPORT_SYMBOL(sym, val, sec)				\
-	__cond_export_sym(sym, val, sec, config_enabled(__KSYM_##sym))
+	__cond_export_sym(sym, val, sec, __is_defined(__KSYM_##sym))
 #define __cond_export_sym(sym, val, sec, conf)			\
 	___cond_export_sym(sym, val, sec, conf)
 #define ___cond_export_sym(sym, val, sec, enabled)		\

commit 22823ab419d8ed884195cfa75483fd3a99bb1462
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jan 11 10:54:54 2016 -0500

    EXPORT_SYMBOL() for asm
    
    Add asm-usable variants of EXPORT_SYMBOL/EXPORT_SYMBOL_GPL.  This
    commit just adds the default implementation; most of the architectures
    can simply add export.h to asm/Kbuild and start using <asm/export.h>
    from assembler.  The rest needs to have their <asm/export.h> define
    everal macros and then explicitly include <asm-generic/export.h>
    
    One area where the things might diverge from default is the alignment;
    normally it's 8 bytes on 64bit targets and 4 on 32bit ones, both for
    unsigned long and for struct kernel_symbol.  Unfortunately, amd64 and
    m68k are unusual - m68k aligns to 2 bytes (for both) and amd64 aligns
    struct kernel_symbol to 16 bytes.  For those we'll need asm/export.h to
    override the constants used by generic version - KSYM_ALIGN and KCRC_ALIGN
    for kernel_symbol and unsigned long resp.  And no, __alignof__ would not
    do the trick - on amd64 __alignof__ of struct kernel_symbol is 8, not 16.
    
    More serious source of unpleasantness is treatment of function
    descriptors on architectures that have those.  Things like ppc64,
    parisc, ia64, etc.  need more than the address of the first insn to
    call an arbitrary function.  As the result, their representation of
    pointers to functions is not the typical "address of the entry point" -
    it's an address of a small static structure containing all the required
    information (including the entry point, of course).  Sadly, the asm-side
    conventions differ in what the function name refers to - entry point or
    the function descriptor.  On ppc64 we do the latter;
            bar: .quad foo
    is what void (*bar)(void) = foo; turns into and the rare places where
    we need to explicitly work with the label of entry point are dealt with
    as DOTSYM(foo).  For our purposes it's ideal - generic macros are usable.
    However, parisc would have foo and P%foo used for label of entry point
    and address of the function descriptor and
            bar: .long P%foo
    woudl be used instead.  ia64 goes similar to parisc in that respect,
    except that there it's @fptr(foo) rather than P%foo.  Such architectures
    need to define KSYM_FUNC that would turn a function name into whatever
    is needed to refer to function descriptor.
    
    What's more, on such architectures we need to know whether we are exporting
    a function or an object - in assembler we have to tell that explicitly, to
    decide whether we want EXPORT_SYMBOL(foo) produce e.g.
            __ksymtab_foo: .quad foo
    or
            __ksymtab_foo: .quad @fptr(foo)
    
    For that reason we introduce EXPORT_DATA_SYMBOL{,_GPL}(), to be used for
    exports of data objects.  On normal architectures it's the same thing
    as EXPORT_SYMBOL{,_GPL}(), but on parisc-like ones they differ and the
    right one needs to be used.  Most of the exports are functions, so we
    keep EXPORT_SYMBOL for those...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/asm-generic/export.h b/include/asm-generic/export.h
new file mode 100644
index 000000000000..43199a049da5
--- /dev/null
+++ b/include/asm-generic/export.h
@@ -0,0 +1,94 @@
+#ifndef __ASM_GENERIC_EXPORT_H
+#define __ASM_GENERIC_EXPORT_H
+
+#ifndef KSYM_FUNC
+#define KSYM_FUNC(x) x
+#endif
+#ifdef CONFIG_64BIT
+#define __put .quad
+#ifndef KSYM_ALIGN
+#define KSYM_ALIGN 8
+#endif
+#ifndef KCRC_ALIGN
+#define KCRC_ALIGN 8
+#endif
+#else
+#define __put .long
+#ifndef KSYM_ALIGN
+#define KSYM_ALIGN 4
+#endif
+#ifndef KCRC_ALIGN
+#define KCRC_ALIGN 4
+#endif
+#endif
+
+#ifdef CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX
+#define KSYM(name) _##name
+#else
+#define KSYM(name) name
+#endif
+
+/*
+ * note on .section use: @progbits vs %progbits nastiness doesn't matter,
+ * since we immediately emit into those sections anyway.
+ */
+.macro ___EXPORT_SYMBOL name,val,sec
+#ifdef CONFIG_MODULES
+	.globl KSYM(__ksymtab_\name)
+	.section ___ksymtab\sec+\name,"a"
+	.balign KSYM_ALIGN
+KSYM(__ksymtab_\name):
+	__put \val, KSYM(__kstrtab_\name)
+	.previous
+	.section __ksymtab_strings,"a"
+KSYM(__kstrtab_\name):
+#ifdef CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX
+	.asciz "_\name"
+#else
+	.asciz "\name"
+#endif
+	.previous
+#ifdef CONFIG_MODVERSIONS
+	.section ___kcrctab\sec+\name,"a"
+	.balign KCRC_ALIGN
+KSYM(__kcrctab_\name):
+	__put KSYM(__crc_\name)
+	.weak KSYM(__crc_\name)
+	.previous
+#endif
+#endif
+.endm
+#undef __put
+
+#if defined(__KSYM_DEPS__)
+
+#define __EXPORT_SYMBOL(sym, val, sec)	=== __KSYM_##sym ===
+
+#elif defined(CONFIG_TRIM_UNUSED_KSYMS)
+
+#include <linux/kconfig.h>
+#include <generated/autoksyms.h>
+
+#define __EXPORT_SYMBOL(sym, val, sec)				\
+	__cond_export_sym(sym, val, sec, config_enabled(__KSYM_##sym))
+#define __cond_export_sym(sym, val, sec, conf)			\
+	___cond_export_sym(sym, val, sec, conf)
+#define ___cond_export_sym(sym, val, sec, enabled)		\
+	__cond_export_sym_##enabled(sym, val, sec)
+#define __cond_export_sym_1(sym, val, sec) ___EXPORT_SYMBOL sym, val, sec
+#define __cond_export_sym_0(sym, val, sec) /* nothing */
+
+#else
+#define __EXPORT_SYMBOL(sym, val, sec) ___EXPORT_SYMBOL sym, val, sec
+#endif
+
+#define EXPORT_SYMBOL(name)					\
+	__EXPORT_SYMBOL(name, KSYM_FUNC(KSYM(name)),)
+#define EXPORT_SYMBOL_GPL(name) 				\
+	__EXPORT_SYMBOL(name, KSYM_FUNC(KSYM(name)), _gpl)
+#define EXPORT_DATA_SYMBOL(name)				\
+	__EXPORT_SYMBOL(name, KSYM(name),)
+#define EXPORT_DATA_SYMBOL_GPL(name)				\
+	__EXPORT_SYMBOL(name, KSYM(name),_gpl)
+
+#endif
