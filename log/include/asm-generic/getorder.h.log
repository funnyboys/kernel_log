commit cbedfe11347fe418621bd188d58a206beb676218
Author: Qian Cai <cai@lca.pw>
Date:   Fri Aug 2 21:49:19 2019 -0700

    asm-generic: fix -Wtype-limits compiler warnings
    
    Commit d66acc39c7ce ("bitops: Optimise get_order()") introduced a
    compilation warning because "rx_frag_size" is an "ushort" while
    PAGE_SHIFT here is 16.
    
    The commit changed the get_order() to be a multi-line macro where
    compilers insist to check all statements in the macro even when
    __builtin_constant_p(rx_frag_size) will return false as "rx_frag_size"
    is a module parameter.
    
    In file included from ./arch/powerpc/include/asm/page_64.h:107,
                     from ./arch/powerpc/include/asm/page.h:242,
                     from ./arch/powerpc/include/asm/mmu.h:132,
                     from ./arch/powerpc/include/asm/lppaca.h:47,
                     from ./arch/powerpc/include/asm/paca.h:17,
                     from ./arch/powerpc/include/asm/current.h:13,
                     from ./include/linux/thread_info.h:21,
                     from ./arch/powerpc/include/asm/processor.h:39,
                     from ./include/linux/prefetch.h:15,
                     from drivers/net/ethernet/emulex/benet/be_main.c:14:
    drivers/net/ethernet/emulex/benet/be_main.c: In function 'be_rx_cqs_create':
    ./include/asm-generic/getorder.h:54:9: warning: comparison is always
    true due to limited range of data type [-Wtype-limits]
       (((n) < (1UL << PAGE_SHIFT)) ? 0 :  \
             ^
    drivers/net/ethernet/emulex/benet/be_main.c:3138:33: note: in expansion
    of macro 'get_order'
      adapter->big_page_size = (1 << get_order(rx_frag_size)) * PAGE_SIZE;
                                     ^~~~~~~~~
    
    Fix it by moving all of this multi-line macro into a proper function,
    and killing __get_order() off.
    
    [akpm@linux-foundation.org: remove __get_order() altogether]
    [cai@lca.pw: v2]
      Link: http://lkml.kernel.org/r/1564000166-31428-1-git-send-email-cai@lca.pw
    Link: http://lkml.kernel.org/r/1563914986-26502-1-git-send-email-cai@lca.pw
    Fixes: d66acc39c7ce ("bitops: Optimise get_order()")
    Signed-off-by: Qian Cai <cai@lca.pw>
    Reviewed-by: Nathan Chancellor <natechancellor@gmail.com>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Jakub Jelinek <jakub@redhat.com>
    Cc: Nick Desaulniers <ndesaulniers@google.com>
    Cc: Bill Wendling <morbo@google.com>
    Cc: James Y Knight <jyknight@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/asm-generic/getorder.h b/include/asm-generic/getorder.h
index c64bea7a52be..e9f20b813a69 100644
--- a/include/asm-generic/getorder.h
+++ b/include/asm-generic/getorder.h
@@ -7,24 +7,6 @@
 #include <linux/compiler.h>
 #include <linux/log2.h>
 
-/*
- * Runtime evaluation of get_order()
- */
-static inline __attribute_const__
-int __get_order(unsigned long size)
-{
-	int order;
-
-	size--;
-	size >>= PAGE_SHIFT;
-#if BITS_PER_LONG == 32
-	order = fls(size);
-#else
-	order = fls64(size);
-#endif
-	return order;
-}
-
 /**
  * get_order - Determine the allocation order of a memory size
  * @size: The size for which to get the order
@@ -43,19 +25,27 @@ int __get_order(unsigned long size)
  * to hold an object of the specified size.
  *
  * The result is undefined if the size is 0.
- *
- * This function may be used to initialise variables with compile time
- * evaluations of constants.
  */
-#define get_order(n)						\
-(								\
-	__builtin_constant_p(n) ? (				\
-		((n) == 0UL) ? BITS_PER_LONG - PAGE_SHIFT :	\
-		(((n) < (1UL << PAGE_SHIFT)) ? 0 :		\
-		 ilog2((n) - 1) - PAGE_SHIFT + 1)		\
-	) :							\
-	__get_order(n)						\
-)
+static inline __attribute_const__ int get_order(unsigned long size)
+{
+	if (__builtin_constant_p(size)) {
+		if (!size)
+			return BITS_PER_LONG - PAGE_SHIFT;
+
+		if (size < (1UL << PAGE_SHIFT))
+			return 0;
+
+		return ilog2((size) - 1) - PAGE_SHIFT + 1;
+	}
+
+	size--;
+	size >>= PAGE_SHIFT;
+#if BITS_PER_LONG == 32
+	return fls(size);
+#else
+	return fls64(size);
+#endif
+}
 
 #endif	/* __ASSEMBLY__ */
 

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/asm-generic/getorder.h b/include/asm-generic/getorder.h
index 65e4468ac53d..c64bea7a52be 100644
--- a/include/asm-generic/getorder.h
+++ b/include/asm-generic/getorder.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __ASM_GENERIC_GETORDER_H
 #define __ASM_GENERIC_GETORDER_H
 

commit b893485db994b17402524d3d700b950294cb6c97
Author: Joerg Roedel <joerg.roedel@amd.com>
Date:   Fri Feb 24 13:58:15 2012 +0100

    bitops: Add missing parentheses to new get_order macro
    
    The new get_order macro introcuded in commit
    
            d66acc39c7cee323733c8503b9de1821a56dff7e
    
    does not use parentheses around all uses of the parameter n.
    This causes new compile warnings, for example in the
    amd_iommu_init.c function:
    
    drivers/iommu/amd_iommu_init.c:561:6: warning: suggest parentheses around comparison in operand of ‘&’ [-Wparentheses]
    drivers/iommu/amd_iommu_init.c:561:6: warning: suggest parentheses around comparison in operand of ‘&’ [-Wparentheses]
    
    Fix those warnings by adding the missing parentheses.
    
    Reported-by: Ingo Molnar <mingo@elte.hu>
    Cc: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>
    Link: http://lkml.kernel.org/r/1330088295-28732-1-git-send-email-joerg.roedel@amd.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/asm-generic/getorder.h b/include/asm-generic/getorder.h
index e0fb4bf9f160..65e4468ac53d 100644
--- a/include/asm-generic/getorder.h
+++ b/include/asm-generic/getorder.h
@@ -49,8 +49,8 @@ int __get_order(unsigned long size)
 #define get_order(n)						\
 (								\
 	__builtin_constant_p(n) ? (				\
-		(n == 0UL) ? BITS_PER_LONG - PAGE_SHIFT :	\
-		((n < (1UL << PAGE_SHIFT)) ? 0 :		\
+		((n) == 0UL) ? BITS_PER_LONG - PAGE_SHIFT :	\
+		(((n) < (1UL << PAGE_SHIFT)) ? 0 :		\
 		 ilog2((n) - 1) - PAGE_SHIFT + 1)		\
 	) :							\
 	__get_order(n)						\

commit d66acc39c7cee323733c8503b9de1821a56dff7e
Author: David Howells <dhowells@redhat.com>
Date:   Mon Feb 20 22:39:29 2012 +0000

    bitops: Optimise get_order()
    
    Optimise get_order() to use bit scanning instructions if such exist rather than
    a loop.  Also, make it possible to use get_order() in static initialisations
    too by building it on top of ilog2() in the constant parameter case.
    
    This has been tested for i386 and x86_64 using the following userspace program,
    and for FRV by making appropriate substitutions for fls() and fls64().  It will
    abort if the case for get_order() deviates from the original except for the
    order of 0, for which get_order() produces an undefined result.  This program
    tests both dynamic and static parameters.
    
            #include <stdlib.h>
            #include <stdio.h>
    
            #ifdef __x86_64__
            #define BITS_PER_LONG 64
            #else
            #define BITS_PER_LONG 32
            #endif
    
            #define PAGE_SHIFT 12
    
            typedef unsigned long long __u64, u64;
            typedef unsigned int __u32, u32;
            #define noinline        __attribute__((noinline))
    
            static inline int fls(int x)
            {
                    int bitpos = -1;
    
                    asm("bsrl %1,%0"
                        : "+r" (bitpos)
                        : "rm" (x));
                    return bitpos + 1;
            }
    
            static __always_inline int fls64(__u64 x)
            {
            #if BITS_PER_LONG == 64
                    long bitpos = -1;
    
                    asm("bsrq %1,%0"
                        : "+r" (bitpos)
                        : "rm" (x));
                    return bitpos + 1;
            #else
                    __u32 h = x >> 32, l = x;
                    int bitpos = -1;
    
                    asm("bsrl       %1,%0   \n"
                        "subl       %2,%0   \n"
                        "bsrl       %3,%0   \n"
                        : "+r" (bitpos)
                        : "rm" (l), "i"(32), "rm" (h));
    
                    return bitpos + 33;
            #endif
            }
    
            static inline __attribute__((const))
            int __ilog2_u32(u32 n)
            {
                    return fls(n) - 1;
            }
    
            static inline __attribute__((const))
            int __ilog2_u64(u64 n)
            {
                    return fls64(n) - 1;
            }
    
            extern __attribute__((const, noreturn))
            int ____ilog2_NaN(void);
    
            #define ilog2(n)                                \
            (                                               \
                    __builtin_constant_p(n) ? (             \
                            (n) < 1 ? ____ilog2_NaN() :     \
                            (n) & (1ULL << 63) ? 63 :       \
                            (n) & (1ULL << 62) ? 62 :       \
                            (n) & (1ULL << 61) ? 61 :       \
                            (n) & (1ULL << 60) ? 60 :       \
                            (n) & (1ULL << 59) ? 59 :       \
                            (n) & (1ULL << 58) ? 58 :       \
                            (n) & (1ULL << 57) ? 57 :       \
                            (n) & (1ULL << 56) ? 56 :       \
                            (n) & (1ULL << 55) ? 55 :       \
                            (n) & (1ULL << 54) ? 54 :       \
                            (n) & (1ULL << 53) ? 53 :       \
                            (n) & (1ULL << 52) ? 52 :       \
                            (n) & (1ULL << 51) ? 51 :       \
                            (n) & (1ULL << 50) ? 50 :       \
                            (n) & (1ULL << 49) ? 49 :       \
                            (n) & (1ULL << 48) ? 48 :       \
                            (n) & (1ULL << 47) ? 47 :       \
                            (n) & (1ULL << 46) ? 46 :       \
                            (n) & (1ULL << 45) ? 45 :       \
                            (n) & (1ULL << 44) ? 44 :       \
                            (n) & (1ULL << 43) ? 43 :       \
                            (n) & (1ULL << 42) ? 42 :       \
                            (n) & (1ULL << 41) ? 41 :       \
                            (n) & (1ULL << 40) ? 40 :       \
                            (n) & (1ULL << 39) ? 39 :       \
                            (n) & (1ULL << 38) ? 38 :       \
                            (n) & (1ULL << 37) ? 37 :       \
                            (n) & (1ULL << 36) ? 36 :       \
                            (n) & (1ULL << 35) ? 35 :       \
                            (n) & (1ULL << 34) ? 34 :       \
                            (n) & (1ULL << 33) ? 33 :       \
                            (n) & (1ULL << 32) ? 32 :       \
                            (n) & (1ULL << 31) ? 31 :       \
                            (n) & (1ULL << 30) ? 30 :       \
                            (n) & (1ULL << 29) ? 29 :       \
                            (n) & (1ULL << 28) ? 28 :       \
                            (n) & (1ULL << 27) ? 27 :       \
                            (n) & (1ULL << 26) ? 26 :       \
                            (n) & (1ULL << 25) ? 25 :       \
                            (n) & (1ULL << 24) ? 24 :       \
                            (n) & (1ULL << 23) ? 23 :       \
                            (n) & (1ULL << 22) ? 22 :       \
                            (n) & (1ULL << 21) ? 21 :       \
                            (n) & (1ULL << 20) ? 20 :       \
                            (n) & (1ULL << 19) ? 19 :       \
                            (n) & (1ULL << 18) ? 18 :       \
                            (n) & (1ULL << 17) ? 17 :       \
                            (n) & (1ULL << 16) ? 16 :       \
                            (n) & (1ULL << 15) ? 15 :       \
                            (n) & (1ULL << 14) ? 14 :       \
                            (n) & (1ULL << 13) ? 13 :       \
                            (n) & (1ULL << 12) ? 12 :       \
                            (n) & (1ULL << 11) ? 11 :       \
                            (n) & (1ULL << 10) ? 10 :       \
                            (n) & (1ULL <<  9) ?  9 :       \
                            (n) & (1ULL <<  8) ?  8 :       \
                            (n) & (1ULL <<  7) ?  7 :       \
                            (n) & (1ULL <<  6) ?  6 :       \
                            (n) & (1ULL <<  5) ?  5 :       \
                            (n) & (1ULL <<  4) ?  4 :       \
                            (n) & (1ULL <<  3) ?  3 :       \
                            (n) & (1ULL <<  2) ?  2 :       \
                            (n) & (1ULL <<  1) ?  1 :       \
                            (n) & (1ULL <<  0) ?  0 :       \
                            ____ilog2_NaN()                 \
                                               ) :          \
                    (sizeof(n) <= 4) ?                      \
                    __ilog2_u32(n) :                        \
                    __ilog2_u64(n)                          \
             )
    
            static noinline __attribute__((const))
            int old_get_order(unsigned long size)
            {
                    int order;
    
                    size = (size - 1) >> (PAGE_SHIFT - 1);
                    order = -1;
                    do {
                            size >>= 1;
                            order++;
                    } while (size);
                    return order;
            }
    
            static noinline __attribute__((const))
            int __get_order(unsigned long size)
            {
                    int order;
                    size--;
                    size >>= PAGE_SHIFT;
            #if BITS_PER_LONG == 32
                    order = fls(size);
            #else
                    order = fls64(size);
            #endif
                    return order;
            }
    
            #define get_order(n)                                            \
            (                                                               \
                    __builtin_constant_p(n) ? (                             \
                            (n == 0UL) ? BITS_PER_LONG - PAGE_SHIFT :       \
                            ((n < (1UL << PAGE_SHIFT)) ? 0 :                \
                             ilog2((n) - 1) - PAGE_SHIFT + 1)               \
                    ) :                                                     \
                    __get_order(n)                                          \
            )
    
            #define order(N) \
                    { (1UL << N) - 1,       get_order((1UL << N) - 1)       },      \
                    { (1UL << N),           get_order((1UL << N))           },      \
                    { (1UL << N) + 1,       get_order((1UL << N) + 1)       }
    
            struct order {
                    unsigned long n, order;
            };
    
            static const struct order order_table[] = {
                    order(0),
                    order(1),
                    order(2),
                    order(3),
                    order(4),
                    order(5),
                    order(6),
                    order(7),
                    order(8),
                    order(9),
                    order(10),
                    order(11),
                    order(12),
                    order(13),
                    order(14),
                    order(15),
                    order(16),
                    order(17),
                    order(18),
                    order(19),
                    order(20),
                    order(21),
                    order(22),
                    order(23),
                    order(24),
                    order(25),
                    order(26),
                    order(27),
                    order(28),
                    order(29),
                    order(30),
                    order(31),
            #if BITS_PER_LONG == 64
                    order(32),
                    order(33),
                    order(34),
                    order(35),
            #endif
                    { 0x2929 }
            };
    
            void check(int loop, unsigned long n)
            {
                    unsigned long old, new;
    
                    printf("[%2d]: %09lx | ", loop, n);
    
                    old = old_get_order(n);
                    new = get_order(n);
    
                    printf("%3ld, %3ld\n", old, new);
                    if (n != 0 && old != new)
                            abort();
            }
    
            int main(int argc, char **argv)
            {
                    const struct order *p;
                    unsigned long n;
                    int loop;
    
                    for (loop = 0; loop <= BITS_PER_LONG - 1; loop++) {
                            n = 1UL << loop;
                            check(loop, n - 1);
                            check(loop, n);
                            check(loop, n + 1);
                    }
    
                    for (p = order_table; p->n != 0x2929; p++) {
                            unsigned long old, new;
    
                            old = old_get_order(p->n);
                            new = p->order;
                            printf("%09lx\t%3ld, %3ld\n", p->n, old, new);
                            if (p->n != 0 && old != new)
                                    abort();
                    }
    
                    return 0;
            }
    
    Disassembling the x86_64 version of the above code shows:
    
            0000000000400510 <old_get_order>:
              400510:       48 83 ef 01             sub    $0x1,%rdi
              400514:       b8 ff ff ff ff          mov    $0xffffffff,%eax
              400519:       48 c1 ef 0b             shr    $0xb,%rdi
              40051d:       0f 1f 00                nopl   (%rax)
              400520:       83 c0 01                add    $0x1,%eax
              400523:       48 d1 ef                shr    %rdi
              400526:       75 f8                   jne    400520 <old_get_order+0x10>
              400528:       f3 c3                   repz retq
              40052a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    
            0000000000400530 <__get_order>:
              400530:       48 83 ef 01             sub    $0x1,%rdi
              400534:       48 c7 c0 ff ff ff ff    mov    $0xffffffffffffffff,%rax
              40053b:       48 c1 ef 0c             shr    $0xc,%rdi
              40053f:       48 0f bd c7             bsr    %rdi,%rax
              400543:       83 c0 01                add    $0x1,%eax
              400546:       c3                      retq
              400547:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
              40054e:       00 00
    
    As can be seen, the new __get_order() function is simpler than the
    old_get_order() function.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Link: http://lkml.kernel.org/r/20120220223928.16199.29548.stgit@warthog.procyon.org.uk
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/include/asm-generic/getorder.h b/include/asm-generic/getorder.h
index 76e9687a3c86..e0fb4bf9f160 100644
--- a/include/asm-generic/getorder.h
+++ b/include/asm-generic/getorder.h
@@ -4,6 +4,25 @@
 #ifndef __ASSEMBLY__
 
 #include <linux/compiler.h>
+#include <linux/log2.h>
+
+/*
+ * Runtime evaluation of get_order()
+ */
+static inline __attribute_const__
+int __get_order(unsigned long size)
+{
+	int order;
+
+	size--;
+	size >>= PAGE_SHIFT;
+#if BITS_PER_LONG == 32
+	order = fls(size);
+#else
+	order = fls64(size);
+#endif
+	return order;
+}
 
 /**
  * get_order - Determine the allocation order of a memory size
@@ -27,18 +46,15 @@
  * This function may be used to initialise variables with compile time
  * evaluations of constants.
  */
-static inline __attribute_const__ int get_order(unsigned long size)
-{
-	int order;
-
-	size = (size - 1) >> (PAGE_SHIFT - 1);
-	order = -1;
-	do {
-		size >>= 1;
-		order++;
-	} while (size);
-	return order;
-}
+#define get_order(n)						\
+(								\
+	__builtin_constant_p(n) ? (				\
+		(n == 0UL) ? BITS_PER_LONG - PAGE_SHIFT :	\
+		((n < (1UL << PAGE_SHIFT)) ? 0 :		\
+		 ilog2((n) - 1) - PAGE_SHIFT + 1)		\
+	) :							\
+	__get_order(n)						\
+)
 
 #endif	/* __ASSEMBLY__ */
 

commit e0891a9816316b5e05fd5b0453ffe9fd6a56f489
Author: David Howells <dhowells@redhat.com>
Date:   Mon Feb 20 22:39:18 2012 +0000

    bitops: Adjust the comment on get_order() to describe the size==0 case
    
    Adjust the comment on get_order() to note that the result of passing a size of
    0 results in an undefined value.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Link: http://lkml.kernel.org/r/20120220223917.16199.9416.stgit@warthog.procyon.org.uk
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/include/asm-generic/getorder.h b/include/asm-generic/getorder.h
index 67e7245dc9b3..76e9687a3c86 100644
--- a/include/asm-generic/getorder.h
+++ b/include/asm-generic/getorder.h
@@ -5,7 +5,28 @@
 
 #include <linux/compiler.h>
 
-/* Pure 2^n version of get_order */
+/**
+ * get_order - Determine the allocation order of a memory size
+ * @size: The size for which to get the order
+ *
+ * Determine the allocation order of a particular sized block of memory.  This
+ * is on a logarithmic scale, where:
+ *
+ *	0 -> 2^0 * PAGE_SIZE and below
+ *	1 -> 2^1 * PAGE_SIZE to 2^0 * PAGE_SIZE + 1
+ *	2 -> 2^2 * PAGE_SIZE to 2^1 * PAGE_SIZE + 1
+ *	3 -> 2^3 * PAGE_SIZE to 2^2 * PAGE_SIZE + 1
+ *	4 -> 2^4 * PAGE_SIZE to 2^3 * PAGE_SIZE + 1
+ *	...
+ *
+ * The order returned is used to find the smallest allocation granule required
+ * to hold an object of the specified size.
+ *
+ * The result is undefined if the size is 0.
+ *
+ * This function may be used to initialise variables with compile time
+ * evaluations of constants.
+ */
 static inline __attribute_const__ int get_order(unsigned long size)
 {
 	int order;

commit 5b17e1cd8928ae65932758ce6478ac6d3e9a86b2
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed May 13 22:56:30 2009 +0000

    asm-generic: rename page.h and uaccess.h
    
    The current asm-generic/page.h only contains the get_order
    function, and asm-generic/uaccess.h only implements
    unaligned accesses. This renames the file to getorder.h
    and uaccess-unaligned.h to make room for new page.h
    and uaccess.h file that will be usable by all simple
    (e.g. nommu) architectures.
    
    Signed-off-by: Remis Lima Baima <remis.developer@googlemail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/asm-generic/getorder.h b/include/asm-generic/getorder.h
new file mode 100644
index 000000000000..67e7245dc9b3
--- /dev/null
+++ b/include/asm-generic/getorder.h
@@ -0,0 +1,24 @@
+#ifndef __ASM_GENERIC_GETORDER_H
+#define __ASM_GENERIC_GETORDER_H
+
+#ifndef __ASSEMBLY__
+
+#include <linux/compiler.h>
+
+/* Pure 2^n version of get_order */
+static inline __attribute_const__ int get_order(unsigned long size)
+{
+	int order;
+
+	size = (size - 1) >> (PAGE_SHIFT - 1);
+	order = -1;
+	do {
+		size >>= 1;
+		order++;
+	} while (size);
+	return order;
+}
+
+#endif	/* __ASSEMBLY__ */
+
+#endif	/* __ASM_GENERIC_GETORDER_H */
