commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/asm-generic/cmpxchg.h b/include/asm-generic/cmpxchg.h
index e5f9080e8e86..9a24510cd8c1 100644
--- a/include/asm-generic/cmpxchg.h
+++ b/include/asm-generic/cmpxchg.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Generic UP xchg and cmpxchg using interrupt disablement.  Does not
  * support SMP.

commit d975440bf80cfe4afa628141760a4a4151e58dc4
Author: Marek Vasut <marex@denx.de>
Date:   Sat Sep 19 06:42:21 2015 +0200

    asm-generic: cmpxchg: avoid warnings from macro-ized cmpxchg() implementations
    
    This change is similar to e001bbae7147b111fe1aa42beaf835635f3c016e
    ARM: cmpxchg: avoid warnings from macro-ized cmpxchg() implementations
    
    A recent change in kernel/acct.c added a new warning for many
    configurations using generic __xchg() implementation:
    
    In file included from ./arch/nios2/include/asm/cmpxchg.h:12:0,
                     from include/asm-generic/atomic.h:18,
                     from arch/nios2/include/generated/asm/atomic.h:1,
                     from include/linux/atomic.h:4,
                     from include/linux/spinlock.h:406,
                     from include/linux/mmzone.h:7,
                     from include/linux/gfp.h:5,
                     from include/linux/mm.h:9,
                     from kernel/acct.c:46:
    kernel/acct.c: In function 'acct_pin_kill':
    include/asm-generic/cmpxchg.h:94:3: warning: value computed is not used [-Wunused-value]
      ((__typeof__(*(ptr)))__cmpxchg_local_generic((ptr), (unsigned long)(o),\
       ^
    include/asm-generic/cmpxchg.h:102:28: note: in expansion of macro 'cmpxchg_local'
     #define cmpxchg(ptr, o, n) cmpxchg_local((ptr), (o), (n))
                                ^
    kernel/acct.c:177:2: note: in expansion of macro 'cmpxchg'
      cmpxchg(&acct->ns->bacct, pin, NULL);
      ^
    
    The code is in fact correct, it's just a cmpxchg() call that
    intentionally ignores the result, and no other code does that.  The
    warning does not show up on x86 because of the way that its cmpxchg()
    macro is written. This changes the asm-ggeneric implementation to use
    a similar construct with a compound expression instead of a typecast,
    which causes the compiler to not complain about an unused result.
    
    Fix the other macros in this file in a similar way, and place them
    just below their function implementations.
    
    Signed-off-by: Marek Vasut <marex@denx.de>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/asm-generic/cmpxchg.h b/include/asm-generic/cmpxchg.h
index 3766ab34aa45..e5f9080e8e86 100644
--- a/include/asm-generic/cmpxchg.h
+++ b/include/asm-generic/cmpxchg.h
@@ -79,8 +79,10 @@ unsigned long __xchg(unsigned long x, volatile void *ptr, int size)
 	}
 }
 
-#define xchg(ptr, x) \
-	((__typeof__(*(ptr))) __xchg((unsigned long)(x), (ptr), sizeof(*(ptr))))
+#define xchg(ptr, x) ({							\
+	((__typeof__(*(ptr)))						\
+		__xchg((unsigned long)(x), (ptr), sizeof(*(ptr))));	\
+})
 
 #endif /* xchg */
 
@@ -90,9 +92,10 @@ unsigned long __xchg(unsigned long x, volatile void *ptr, int size)
 #include <asm-generic/cmpxchg-local.h>
 
 #ifndef cmpxchg_local
-#define cmpxchg_local(ptr, o, n)				  	       \
+#define cmpxchg_local(ptr, o, n) ({					       \
 	((__typeof__(*(ptr)))__cmpxchg_local_generic((ptr), (unsigned long)(o),\
-			(unsigned long)(n), sizeof(*(ptr))))
+			(unsigned long)(n), sizeof(*(ptr))));		       \
+})
 #endif
 
 #ifndef cmpxchg64_local

commit cede88418b385b50f6841e4b2f1586888b8ab924
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed Feb 25 18:56:13 2015 +0100

    locking/rtmutex: Drop usage of __HAVE_ARCH_CMPXCHG
    
    The rtmutex code is the only user of __HAVE_ARCH_CMPXCHG and we have a few
    other user of cmpxchg() which do not care about __HAVE_ARCH_CMPXCHG. This
    define was first introduced in 23f78d4a0 ("[PATCH] pi-futex: rt mutex core")
    which is v2.6.18. The generic cmpxchg was introduced later in 068fbad288
    ("Add cmpxchg_local to asm-generic for per cpu atomic operations") which is
    v2.6.25.
    Back then something was required to get rtmutex working with the fast
    path on architectures without cmpxchg and this seems to be the result.
    
    It popped up recently on rt-users because ARM (v6+) does not define
    __HAVE_ARCH_CMPXCHG (even that it implements it) which results in slower
    locking performance in the fast path.
    To put some numbers on it: preempt -RT, am335x, 10 loops of
    100000 invocations of rt_spin_lock() + rt_spin_unlock() (time "total" is
    the average of the 10 loops for the 100000 invocations, "loop" is
    "total / 100000 * 1000"):
    
         cmpxchg |    slowpath used  ||    cmpxchg used
                 |   total   | loop  ||   total    | loop
         --------|-----------|-------||------------|-------
         ARMv6   | 9129.4 us | 91 ns ||  3311.9 us |  33 ns
         generic | 9360.2 us | 94 ns || 10834.6 us | 108 ns
         ----------------------------||--------------------
    
    Forcing it to generic cmpxchg() made things worse for the slowpath and
    even worse in cmpxchg() path. It boils down to 14ns more per lock+unlock
    in a cache hot loop so it might not be that much in real world.
    The last test was a substitute for pre ARMv6 machine but then I was able
    to perform the comparison on imx28 which is ARMv5 and therefore is
    always is using the generic cmpxchg implementation. And the numbers:
    
                  |   total     | loop
         -------- |-----------  |--------
         slowpath | 263937.2 us | 2639 ns
         cmpxchg  |  16934.2 us |  169 ns
         --------------------------------
    
    The numbers are larger since the machine is slower in general. However,
    letting rtmutex use cmpxchg() instead the slowpath seem to improve things.
    
    Since from the ARM (tested on am335x + imx28) point of view always
    using cmpxchg() in rt_mutex_lock() + rt_mutex_unlock() makes sense I
    would drop the define.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: will.deacon@arm.com
    Cc: linux-arm-kernel@lists.infradead.org
    Link: http://lkml.kernel.org/r/20150225175613.GE6823@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/asm-generic/cmpxchg.h b/include/asm-generic/cmpxchg.h
index 811fb1e9b061..3766ab34aa45 100644
--- a/include/asm-generic/cmpxchg.h
+++ b/include/asm-generic/cmpxchg.h
@@ -86,9 +86,6 @@ unsigned long __xchg(unsigned long x, volatile void *ptr, int size)
 
 /*
  * Atomic compare and exchange.
- *
- * Do not define __HAVE_ARCH_CMPXCHG because we want to use it to check whether
- * a cmpxchg primitive faster than repeated local irq save/restore exists.
  */
 #include <asm-generic/cmpxchg-local.h>
 

commit 00c30e0681bf5563c8670c0ab419886f56626430
Author: Jonas Bonn <jonas@southpole.se>
Date:   Thu Feb 28 06:37:05 2013 +0100

    asm-generic: move cmpxchg*_local defs to cmpxchg.h
    
    asm/cmpxchg.h can be included on its own and needs to be self-consistent.
    The definitions for the cmpxchg*_local macros, as such, need to be part
    of this file.
    
    This fixes a build issue on OpenRISC since the system.h smashing patch
    96f951edb1f1bdbbc99b0cd458f9808bb83d58ae that introdued the direct inclusion
    asm/cmpxchg.h into linux/llist.h.
    
    CC: David Howells <dhowells@redhat.com>
    Signed-off-by: Jonas Bonn <jonas@southpole.se>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/asm-generic/cmpxchg.h b/include/asm-generic/cmpxchg.h
index 14883026015d..811fb1e9b061 100644
--- a/include/asm-generic/cmpxchg.h
+++ b/include/asm-generic/cmpxchg.h
@@ -92,6 +92,16 @@ unsigned long __xchg(unsigned long x, volatile void *ptr, int size)
  */
 #include <asm-generic/cmpxchg-local.h>
 
+#ifndef cmpxchg_local
+#define cmpxchg_local(ptr, o, n)				  	       \
+	((__typeof__(*(ptr)))__cmpxchg_local_generic((ptr), (unsigned long)(o),\
+			(unsigned long)(n), sizeof(*(ptr))))
+#endif
+
+#ifndef cmpxchg64_local
+#define cmpxchg64_local(ptr, o, n) __cmpxchg64_local_generic((ptr), (o), (n))
+#endif
+
 #define cmpxchg(ptr, o, n)	cmpxchg_local((ptr), (o), (n))
 #define cmpxchg64(ptr, o, n)	cmpxchg64_local((ptr), (o), (n))
 

commit 80da6a4feeb9e4d6554f771f14f5b994e6c6c7e8
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Apr 1 16:38:47 2012 -0400

    asm-generic: add linux/types.h to cmpxchg.h
    
    Builds of the openrisc or1ksim_defconfig show the following:
    
      In file included from arch/openrisc/include/generated/asm/cmpxchg.h:1:0,
                       from include/asm-generic/atomic.h:18,
                       from arch/openrisc/include/generated/asm/atomic.h:1,
                       from include/linux/atomic.h:4,
                       from include/linux/dcache.h:4,
                       from fs/notify/fsnotify.c:19:
      include/asm-generic/cmpxchg.h: In function '__xchg':
      include/asm-generic/cmpxchg.h:34:20: error: expected ')' before 'u8'
      include/asm-generic/cmpxchg.h:34:20: warning: type defaults to 'int' in type name
    
    and many more lines of similar errors.  It seems specific to the or32
    because most other platforms have an arch specific component that would
    have already included types.h ahead of time, but the o32 does not.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Jonas Bonn <jonas@southpole.se>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Acked-by: David Howells <dhowells@redhat.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/asm-generic/cmpxchg.h b/include/asm-generic/cmpxchg.h
index 8a361834dc25..14883026015d 100644
--- a/include/asm-generic/cmpxchg.h
+++ b/include/asm-generic/cmpxchg.h
@@ -10,6 +10,7 @@
 #error "Cannot use generic cmpxchg on SMP"
 #endif
 
+#include <linux/types.h>
 #include <linux/irqflags.h>
 
 #ifndef xchg

commit b4816afa3986704d1404fc48e931da5135820472
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Move the asm-generic/system.h xchg() implementation to asm-generic/cmpxchg.h
    
    Move the asm-generic/system.h xchg() implementation to asm-generic/cmpxchg.h
    to simplify disintegration of asm/system.h.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/asm-generic/cmpxchg.h b/include/asm-generic/cmpxchg.h
index e0449af91f60..8a361834dc25 100644
--- a/include/asm-generic/cmpxchg.h
+++ b/include/asm-generic/cmpxchg.h
@@ -1,16 +1,87 @@
+/*
+ * Generic UP xchg and cmpxchg using interrupt disablement.  Does not
+ * support SMP.
+ */
+
 #ifndef __ASM_GENERIC_CMPXCHG_H
 #define __ASM_GENERIC_CMPXCHG_H
 
-/*
- * Generic cmpxchg
- *
- * Uses the local cmpxchg. Does not support SMP.
- */
 #ifdef CONFIG_SMP
 #error "Cannot use generic cmpxchg on SMP"
 #endif
 
-#include <asm-generic/cmpxchg-local.h>
+#include <linux/irqflags.h>
+
+#ifndef xchg
+
+/*
+ * This function doesn't exist, so you'll get a linker error if
+ * something tries to do an invalidly-sized xchg().
+ */
+extern void __xchg_called_with_bad_pointer(void);
+
+static inline
+unsigned long __xchg(unsigned long x, volatile void *ptr, int size)
+{
+	unsigned long ret, flags;
+
+	switch (size) {
+	case 1:
+#ifdef __xchg_u8
+		return __xchg_u8(x, ptr);
+#else
+		local_irq_save(flags);
+		ret = *(volatile u8 *)ptr;
+		*(volatile u8 *)ptr = x;
+		local_irq_restore(flags);
+		return ret;
+#endif /* __xchg_u8 */
+
+	case 2:
+#ifdef __xchg_u16
+		return __xchg_u16(x, ptr);
+#else
+		local_irq_save(flags);
+		ret = *(volatile u16 *)ptr;
+		*(volatile u16 *)ptr = x;
+		local_irq_restore(flags);
+		return ret;
+#endif /* __xchg_u16 */
+
+	case 4:
+#ifdef __xchg_u32
+		return __xchg_u32(x, ptr);
+#else
+		local_irq_save(flags);
+		ret = *(volatile u32 *)ptr;
+		*(volatile u32 *)ptr = x;
+		local_irq_restore(flags);
+		return ret;
+#endif /* __xchg_u32 */
+
+#ifdef CONFIG_64BIT
+	case 8:
+#ifdef __xchg_u64
+		return __xchg_u64(x, ptr);
+#else
+		local_irq_save(flags);
+		ret = *(volatile u64 *)ptr;
+		*(volatile u64 *)ptr = x;
+		local_irq_restore(flags);
+		return ret;
+#endif /* __xchg_u64 */
+#endif /* CONFIG_64BIT */
+
+	default:
+		__xchg_called_with_bad_pointer();
+		return x;
+	}
+}
+
+#define xchg(ptr, x) \
+	((__typeof__(*(ptr))) __xchg((unsigned long)(x), (ptr), sizeof(*(ptr))))
+
+#endif /* xchg */
 
 /*
  * Atomic compare and exchange.
@@ -18,7 +89,9 @@
  * Do not define __HAVE_ARCH_CMPXCHG because we want to use it to check whether
  * a cmpxchg primitive faster than repeated local irq save/restore exists.
  */
+#include <asm-generic/cmpxchg-local.h>
+
 #define cmpxchg(ptr, o, n)	cmpxchg_local((ptr), (o), (n))
 #define cmpxchg64(ptr, o, n)	cmpxchg64_local((ptr), (o), (n))
 
-#endif
+#endif /* __ASM_GENERIC_CMPXCHG_H */

commit 34484277b173d0af1bb00532a264940b57920429
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Make asm-generic/cmpxchg.h #include asm-generic/cmpxchg-local.h
    
    Make asm-generic/cmpxchg.h #include asm-generic/cmpxchg-local.h as all arch
    files that #include the former also #include the latter.  See:
    
            grep -rl asm-generic/cmpxchg-local[.]h arch/ | sort > b
            grep -rl asm-generic/cmpxchg[.]h arch/ | sort > a
            comm a b
    
    This simplifies the disintegration of asm-generic/system.h for arches that
    don't have their own.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/asm-generic/cmpxchg.h b/include/asm-generic/cmpxchg.h
index 213ac6e8fe39..e0449af91f60 100644
--- a/include/asm-generic/cmpxchg.h
+++ b/include/asm-generic/cmpxchg.h
@@ -10,6 +10,8 @@
 #error "Cannot use generic cmpxchg on SMP"
 #endif
 
+#include <asm-generic/cmpxchg-local.h>
+
 /*
  * Atomic compare and exchange.
  *

commit 068fbad288a2c18b75b0425fb56d241f018a1cb5
Author: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date:   Thu Feb 7 00:16:07 2008 -0800

    Add cmpxchg_local to asm-generic for per cpu atomic operations
    
    Emulates the cmpxchg_local by disabling interrupts around variable modification.
    This is not reentrant wrt NMIs and MCEs. It is only protected against normal
    interrupts, but this is enough for architectures without such interrupt sources
    or if used in a context where the data is not shared with such handlers.
    
    It can be used as a fallback for architectures lacking a real cmpxchg
    instruction.
    
    For architectures that have a real cmpxchg but does not have NMIs or MCE,
    testing which of the generic vs architecture specific cmpxchg is the fastest
    should be done.
    
    asm-generic/cmpxchg.h defines a cmpxchg that uses cmpxchg_local. It is meant to
    be used as a cmpxchg fallback for architectures that do not support SMP.
    
    * Patch series comments
    
    Using cmpxchg_local shows a performance improvements of the fast path goes from
    a 66% speedup on a Pentium 4 to a 14% speedup on AMD64.
    
    In detail:
    
    Tested-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Measurements on a Pentium4, 3GHz, Hyperthread.
    SLUB Performance testing
    ========================
    1. Kmalloc: Repeatedly allocate then free test
    
    * slub HEAD, test 1
    kmalloc(8) = 201 cycles         kfree = 351 cycles
    kmalloc(16) = 198 cycles        kfree = 359 cycles
    kmalloc(32) = 200 cycles        kfree = 381 cycles
    kmalloc(64) = 224 cycles        kfree = 394 cycles
    kmalloc(128) = 285 cycles       kfree = 424 cycles
    kmalloc(256) = 411 cycles       kfree = 546 cycles
    kmalloc(512) = 480 cycles       kfree = 619 cycles
    kmalloc(1024) = 623 cycles      kfree = 750 cycles
    kmalloc(2048) = 686 cycles      kfree = 811 cycles
    kmalloc(4096) = 482 cycles      kfree = 538 cycles
    kmalloc(8192) = 680 cycles      kfree = 734 cycles
    kmalloc(16384) = 713 cycles     kfree = 843 cycles
    
    * Slub HEAD, test 2
    kmalloc(8) = 190 cycles         kfree = 351 cycles
    kmalloc(16) = 195 cycles        kfree = 360 cycles
    kmalloc(32) = 201 cycles        kfree = 370 cycles
    kmalloc(64) = 245 cycles        kfree = 389 cycles
    kmalloc(128) = 283 cycles       kfree = 413 cycles
    kmalloc(256) = 409 cycles       kfree = 547 cycles
    kmalloc(512) = 476 cycles       kfree = 616 cycles
    kmalloc(1024) = 628 cycles      kfree = 753 cycles
    kmalloc(2048) = 684 cycles      kfree = 811 cycles
    kmalloc(4096) = 480 cycles      kfree = 539 cycles
    kmalloc(8192) = 661 cycles      kfree = 746 cycles
    kmalloc(16384) = 741 cycles     kfree = 856 cycles
    
    * cmpxchg_local Slub test
    kmalloc(8) = 83 cycles          kfree = 363 cycles
    kmalloc(16) = 85 cycles         kfree = 372 cycles
    kmalloc(32) = 92 cycles         kfree = 377 cycles
    kmalloc(64) = 115 cycles        kfree = 397 cycles
    kmalloc(128) = 179 cycles       kfree = 438 cycles
    kmalloc(256) = 314 cycles       kfree = 564 cycles
    kmalloc(512) = 398 cycles       kfree = 615 cycles
    kmalloc(1024) = 573 cycles      kfree = 745 cycles
    kmalloc(2048) = 629 cycles      kfree = 816 cycles
    kmalloc(4096) = 473 cycles      kfree = 548 cycles
    kmalloc(8192) = 659 cycles      kfree = 745 cycles
    kmalloc(16384) = 724 cycles     kfree = 843 cycles
    
    2. Kmalloc: alloc/free test
    
    * slub HEAD, test 1
    kmalloc(8)/kfree = 322 cycles
    kmalloc(16)/kfree = 318 cycles
    kmalloc(32)/kfree = 318 cycles
    kmalloc(64)/kfree = 325 cycles
    kmalloc(128)/kfree = 318 cycles
    kmalloc(256)/kfree = 328 cycles
    kmalloc(512)/kfree = 328 cycles
    kmalloc(1024)/kfree = 328 cycles
    kmalloc(2048)/kfree = 328 cycles
    kmalloc(4096)/kfree = 678 cycles
    kmalloc(8192)/kfree = 1013 cycles
    kmalloc(16384)/kfree = 1157 cycles
    
    * Slub HEAD, test 2
    kmalloc(8)/kfree = 323 cycles
    kmalloc(16)/kfree = 318 cycles
    kmalloc(32)/kfree = 318 cycles
    kmalloc(64)/kfree = 318 cycles
    kmalloc(128)/kfree = 318 cycles
    kmalloc(256)/kfree = 328 cycles
    kmalloc(512)/kfree = 328 cycles
    kmalloc(1024)/kfree = 328 cycles
    kmalloc(2048)/kfree = 328 cycles
    kmalloc(4096)/kfree = 648 cycles
    kmalloc(8192)/kfree = 1009 cycles
    kmalloc(16384)/kfree = 1105 cycles
    
    * cmpxchg_local Slub test
    kmalloc(8)/kfree = 112 cycles
    kmalloc(16)/kfree = 103 cycles
    kmalloc(32)/kfree = 103 cycles
    kmalloc(64)/kfree = 103 cycles
    kmalloc(128)/kfree = 112 cycles
    kmalloc(256)/kfree = 111 cycles
    kmalloc(512)/kfree = 111 cycles
    kmalloc(1024)/kfree = 111 cycles
    kmalloc(2048)/kfree = 121 cycles
    kmalloc(4096)/kfree = 650 cycles
    kmalloc(8192)/kfree = 1042 cycles
    kmalloc(16384)/kfree = 1149 cycles
    
    Tested-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Measurements on a AMD64 2.0 GHz dual-core
    
    In this test, we seem to remove 10 cycles from the kmalloc fast path.
    On small allocations, it gives a 14% performance increase. kfree fast
    path also seems to have a 10 cycles improvement.
    
    1. Kmalloc: Repeatedly allocate then free test
    
    * cmpxchg_local slub
    kmalloc(8) = 63 cycles      kfree = 126 cycles
    kmalloc(16) = 66 cycles     kfree = 129 cycles
    kmalloc(32) = 76 cycles     kfree = 138 cycles
    kmalloc(64) = 100 cycles    kfree = 288 cycles
    kmalloc(128) = 128 cycles   kfree = 309 cycles
    kmalloc(256) = 170 cycles   kfree = 315 cycles
    kmalloc(512) = 221 cycles   kfree = 357 cycles
    kmalloc(1024) = 324 cycles  kfree = 393 cycles
    kmalloc(2048) = 354 cycles  kfree = 440 cycles
    kmalloc(4096) = 394 cycles  kfree = 330 cycles
    kmalloc(8192) = 523 cycles  kfree = 481 cycles
    kmalloc(16384) = 643 cycles kfree = 649 cycles
    
    * Base
    kmalloc(8) = 74 cycles      kfree = 113 cycles
    kmalloc(16) = 76 cycles     kfree = 116 cycles
    kmalloc(32) = 85 cycles     kfree = 133 cycles
    kmalloc(64) = 111 cycles    kfree = 279 cycles
    kmalloc(128) = 138 cycles   kfree = 294 cycles
    kmalloc(256) = 181 cycles   kfree = 304 cycles
    kmalloc(512) = 237 cycles   kfree = 327 cycles
    kmalloc(1024) = 340 cycles  kfree = 379 cycles
    kmalloc(2048) = 378 cycles  kfree = 433 cycles
    kmalloc(4096) = 399 cycles  kfree = 329 cycles
    kmalloc(8192) = 528 cycles  kfree = 624 cycles
    kmalloc(16384) = 651 cycles kfree = 737 cycles
    
    2. Kmalloc: alloc/free test
    
    * cmpxchg_local slub
    kmalloc(8)/kfree = 96 cycles
    kmalloc(16)/kfree = 97 cycles
    kmalloc(32)/kfree = 97 cycles
    kmalloc(64)/kfree = 97 cycles
    kmalloc(128)/kfree = 97 cycles
    kmalloc(256)/kfree = 105 cycles
    kmalloc(512)/kfree = 108 cycles
    kmalloc(1024)/kfree = 105 cycles
    kmalloc(2048)/kfree = 107 cycles
    kmalloc(4096)/kfree = 390 cycles
    kmalloc(8192)/kfree = 626 cycles
    kmalloc(16384)/kfree = 662 cycles
    
    * Base
    kmalloc(8)/kfree = 116 cycles
    kmalloc(16)/kfree = 116 cycles
    kmalloc(32)/kfree = 116 cycles
    kmalloc(64)/kfree = 116 cycles
    kmalloc(128)/kfree = 116 cycles
    kmalloc(256)/kfree = 126 cycles
    kmalloc(512)/kfree = 126 cycles
    kmalloc(1024)/kfree = 126 cycles
    kmalloc(2048)/kfree = 126 cycles
    kmalloc(4096)/kfree = 384 cycles
    kmalloc(8192)/kfree = 749 cycles
    kmalloc(16384)/kfree = 786 cycles
    
    Tested-by: Christoph Lameter <clameter@sgi.com>
    I can confirm Mathieus' measurement now:
    
    Athlon64:
    
    regular NUMA/discontig
    
    1. Kmalloc: Repeatedly allocate then free test
    10000 times kmalloc(8) -> 79 cycles kfree -> 92 cycles
    10000 times kmalloc(16) -> 79 cycles kfree -> 93 cycles
    10000 times kmalloc(32) -> 88 cycles kfree -> 95 cycles
    10000 times kmalloc(64) -> 124 cycles kfree -> 132 cycles
    10000 times kmalloc(128) -> 157 cycles kfree -> 247 cycles
    10000 times kmalloc(256) -> 200 cycles kfree -> 257 cycles
    10000 times kmalloc(512) -> 250 cycles kfree -> 277 cycles
    10000 times kmalloc(1024) -> 337 cycles kfree -> 314 cycles
    10000 times kmalloc(2048) -> 365 cycles kfree -> 330 cycles
    10000 times kmalloc(4096) -> 352 cycles kfree -> 240 cycles
    10000 times kmalloc(8192) -> 456 cycles kfree -> 340 cycles
    10000 times kmalloc(16384) -> 646 cycles kfree -> 471 cycles
    2. Kmalloc: alloc/free test
    10000 times kmalloc(8)/kfree -> 124 cycles
    10000 times kmalloc(16)/kfree -> 124 cycles
    10000 times kmalloc(32)/kfree -> 124 cycles
    10000 times kmalloc(64)/kfree -> 124 cycles
    10000 times kmalloc(128)/kfree -> 124 cycles
    10000 times kmalloc(256)/kfree -> 132 cycles
    10000 times kmalloc(512)/kfree -> 132 cycles
    10000 times kmalloc(1024)/kfree -> 132 cycles
    10000 times kmalloc(2048)/kfree -> 132 cycles
    10000 times kmalloc(4096)/kfree -> 319 cycles
    10000 times kmalloc(8192)/kfree -> 486 cycles
    10000 times kmalloc(16384)/kfree -> 539 cycles
    
    cmpxchg_local NUMA/discontig
    
    1. Kmalloc: Repeatedly allocate then free test
    10000 times kmalloc(8) -> 55 cycles kfree -> 90 cycles
    10000 times kmalloc(16) -> 55 cycles kfree -> 92 cycles
    10000 times kmalloc(32) -> 70 cycles kfree -> 91 cycles
    10000 times kmalloc(64) -> 100 cycles kfree -> 141 cycles
    10000 times kmalloc(128) -> 128 cycles kfree -> 233 cycles
    10000 times kmalloc(256) -> 172 cycles kfree -> 251 cycles
    10000 times kmalloc(512) -> 225 cycles kfree -> 275 cycles
    10000 times kmalloc(1024) -> 325 cycles kfree -> 311 cycles
    10000 times kmalloc(2048) -> 346 cycles kfree -> 330 cycles
    10000 times kmalloc(4096) -> 351 cycles kfree -> 238 cycles
    10000 times kmalloc(8192) -> 450 cycles kfree -> 342 cycles
    10000 times kmalloc(16384) -> 630 cycles kfree -> 546 cycles
    2. Kmalloc: alloc/free test
    10000 times kmalloc(8)/kfree -> 81 cycles
    10000 times kmalloc(16)/kfree -> 81 cycles
    10000 times kmalloc(32)/kfree -> 81 cycles
    10000 times kmalloc(64)/kfree -> 81 cycles
    10000 times kmalloc(128)/kfree -> 81 cycles
    10000 times kmalloc(256)/kfree -> 91 cycles
    10000 times kmalloc(512)/kfree -> 90 cycles
    10000 times kmalloc(1024)/kfree -> 91 cycles
    10000 times kmalloc(2048)/kfree -> 90 cycles
    10000 times kmalloc(4096)/kfree -> 318 cycles
    10000 times kmalloc(8192)/kfree -> 483 cycles
    10000 times kmalloc(16384)/kfree -> 536 cycles
    
    Changelog:
    - Ran though checkpatch.
    
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Cc: <linux-arch@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/asm-generic/cmpxchg.h b/include/asm-generic/cmpxchg.h
new file mode 100644
index 000000000000..213ac6e8fe39
--- /dev/null
+++ b/include/asm-generic/cmpxchg.h
@@ -0,0 +1,22 @@
+#ifndef __ASM_GENERIC_CMPXCHG_H
+#define __ASM_GENERIC_CMPXCHG_H
+
+/*
+ * Generic cmpxchg
+ *
+ * Uses the local cmpxchg. Does not support SMP.
+ */
+#ifdef CONFIG_SMP
+#error "Cannot use generic cmpxchg on SMP"
+#endif
+
+/*
+ * Atomic compare and exchange.
+ *
+ * Do not define __HAVE_ARCH_CMPXCHG because we want to use it to check whether
+ * a cmpxchg primitive faster than repeated local irq save/restore exists.
+ */
+#define cmpxchg(ptr, o, n)	cmpxchg_local((ptr), (o), (n))
+#define cmpxchg64(ptr, o, n)	cmpxchg64_local((ptr), (o), (n))
+
+#endif
