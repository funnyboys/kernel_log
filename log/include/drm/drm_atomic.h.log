commit 91ea83306bfa1fb0784ca09e55886a58345e0323
Author: Boris Brezillon <boris.brezillon@collabora.com>
Date:   Tue Feb 18 16:15:03 2020 +0100

    drm/bridge: Fix the bridge kernel doc
    
    Commit 751465913f04 ("drm/bridge: Add a drm_bridge_state object")
    introduced new helpers and hooks but the kernel was slightly broken.
    Fix that now.
    
    v2:
    * Fix the drm_atomic_add_encoder_bridges() doc
    
    Fixes: 751465913f04 ("drm/bridge: Add a drm_bridge_state object")
    Signed-off-by: Boris Brezillon <boris.brezillon@collabora.com>
    Reviewed-by: Neil Armstrong <narmstrong@baylibre.com>
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200218151503.595825-1-boris.brezillon@collabora.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 52d65a055491..7b6cb4774e7d 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -1016,7 +1016,7 @@ struct drm_bus_cfg {
 	 * @format: format used on this bus (one of the MEDIA_BUS_FMT_* format)
 	 *
 	 * This field should not be directly modified by drivers
-	 * (&drm_atomic_bridge_chain_select_bus_fmts() takes care of the bus
+	 * (drm_atomic_bridge_chain_select_bus_fmts() takes care of the bus
 	 * format negotiation).
 	 */
 	u32 format;

commit f32df58acc68b4fae118e00e7fc272b4fb8d5fda
Author: Boris Brezillon <boris.brezillon@collabora.com>
Date:   Tue Jan 28 14:55:08 2020 +0100

    drm/bridge: Add the necessary bits to support bus format negotiation
    
    drm_bridge_state is extended to describe the input and output bus
    configurations. These bus configurations are exposed through the
    drm_bus_cfg struct which encodes the configuration of a physical
    bus between two components in an output pipeline, usually between
    two bridges, an encoder and a bridge, or a bridge and a connector.
    
    The bus configuration is stored in drm_bridge_state separately for
    the input and output buses, as seen from the point of view of each
    bridge. The bus configuration of a bridge output is usually identical
    to the configuration of the next bridge's input, but may differ if
    the signals are modified between the two bridges, for instance by an
    inverter on the board. The input and output configurations of a
    bridge may differ if the bridge modifies the signals internally,
    for instance by performing format conversion, or*modifying signals
    polarities.
    
    Bus format negotiation is automated by the core, drivers just have
    to implement the ->atomic_get_{output,input}_bus_fmts() hooks if they
    want to take part to this negotiation. Negotiation happens in reverse
    order, starting from the last element of the chain (the one directly
    connected to the display) up to the first element of the chain (the one
    connected to the encoder).
    During this negotiation all supported formats are tested until we find
    one that works, meaning that the formats array should be in decreasing
    preference order (assuming the driver has a preference order).
    
    Note that the bus format negotiation works even if some elements in the
    chain don't implement the ->atomic_get_{output,input}_bus_fmts() hooks.
    In that case, the core advertises only MEDIA_BUS_FMT_FIXED and lets
    the previous bridge element decide what to do (most of the time, bridge
    drivers will pick a default bus format or extract this piece of
    information from somewhere else, like a FW property).
    
    v10:
    * Add changelog to the commit message
    
    v9:
    * No changes
    
    v8:
    * Fix a test in drm_atomic_bridge_chain_select_bus_fmts() (Reported by
      Jonas)
    
    v7:
    * Adapt the code to deal with the fact that not all bridges in the
      chain have a bridge state
    
    v5 -> v6:
    * No changes
    
    v4:
    * Enhance the doc
    * Fix typos
    * Rename some parameters/fields
    * Reword the commit message
    
    v3:
    * Fix the commit message (Reported by Laurent)
    * Document the fact that bus formats should not be directly modified by
      drivers (Suggested by Laurent)
    * Document the fact that format order matters (Suggested by Laurent)
    * Propagate bus flags by default
    * Document the fact that drivers can tweak bus flags if needed
    * Let ->atomic_get_{output,input}_bus_fmts() allocate the bus format
      array (Suggested by Laurent)
    * Add a drm_atomic_helper_bridge_propagate_bus_fmt()
    * Mandate that bridge drivers return accurate input_fmts even if they
      are known to be the first element in the bridge chain
    
    v2:
    * Rework things to support more complex use cases
    
    Signed-off-by: Boris Brezillon <boris.brezillon@collabora.com>
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    [narmstrong: fixed doc in include/drm/drm_bridge.h:69 fmt->format]
    Reviewed-by: Jernej Skrabec <jernej.skrabec@siol.net>
    Tested-by: Jonas Karlman <jonas@kwiboo.se>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200128135514.108171-7-boris.brezillon@collabora.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 82a888769b3d..52d65a055491 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -995,6 +995,38 @@ drm_atomic_crtc_effectively_active(const struct drm_crtc_state *state)
 	return state->active || state->self_refresh_active;
 }
 
+/**
+ * struct drm_bus_cfg - bus configuration
+ *
+ * This structure stores the configuration of a physical bus between two
+ * components in an output pipeline, usually between two bridges, an encoder
+ * and a bridge, or a bridge and a connector.
+ *
+ * The bus configuration is stored in &drm_bridge_state separately for the
+ * input and output buses, as seen from the point of view of each bridge. The
+ * bus configuration of a bridge output is usually identical to the
+ * configuration of the next bridge's input, but may differ if the signals are
+ * modified between the two bridges, for instance by an inverter on the board.
+ * The input and output configurations of a bridge may differ if the bridge
+ * modifies the signals internally, for instance by performing format
+ * conversion, or modifying signals polarities.
+ */
+struct drm_bus_cfg {
+	/**
+	 * @format: format used on this bus (one of the MEDIA_BUS_FMT_* format)
+	 *
+	 * This field should not be directly modified by drivers
+	 * (&drm_atomic_bridge_chain_select_bus_fmts() takes care of the bus
+	 * format negotiation).
+	 */
+	u32 format;
+
+	/**
+	 * @flags: DRM_BUS_* flags used on this bus
+	 */
+	u32 flags;
+};
+
 /**
  * struct drm_bridge_state - Atomic bridge state object
  */
@@ -1008,6 +1040,16 @@ struct drm_bridge_state {
 	 * @bridge: the bridge this state refers to
 	 */
 	struct drm_bridge *bridge;
+
+	/**
+	 * @input_bus_cfg: input bus configuration
+	 */
+	struct drm_bus_cfg input_bus_cfg;
+
+	/**
+	 * @output_bus_cfg: input bus configuration
+	 */
+	struct drm_bus_cfg output_bus_cfg;
 };
 
 static inline struct drm_bridge_state *

commit 751465913f045a1120188ec91ed46d90ea5fd539
Author: Boris Brezillon <boris.brezillon@collabora.com>
Date:   Tue Jan 28 14:55:03 2020 +0100

    drm/bridge: Add a drm_bridge_state object
    
    One of the last remaining objects to not have its atomic state.
    
    This is being motivated by our attempt to support runtime bus-format
    negotiation between elements of the bridge chain.
    This patch just paves the road for such a feature by adding a new
    drm_bridge_state object inheriting from drm_private_obj so we can
    re-use some of the existing state initialization/tracking logic.
    
    v10:
    * Add changelog to the commit message
    
    v9:
    * Clarify the fact that the bridge->atomic_reset() and
      {connector,plane,crtc,...}->reset() semantics are different
    * Move the drm_atomic_private_obj_init() call back to
      drm_bridge_attach()
    * Check the presence of ->atomic_duplicate_state instead of
      ->atomic_reset in drm_atomic_add_encoder_bridges()
    * Fix copy&paste errors in the atomic bridge state helpers doc
    * Add A-b/R-b tags
    
    v8:
    * Move bridge state helpers out of the CONFIG_DEBUGFS section
    
    v7:
    * Move helpers, struct-defs, ... to atomic helper files to avoid the
      drm -> drm_kms_helper -> drm circular dep
    * Stop providing default implementation for atomic state reset,
      duplicate and destroy hooks (has to do with the helper/core split)
    * Drop all R-b/T-b as helpers have now be moved to other places
    
    v6:
    * Made helpers private, removed doc and moved them to satisfy dependencies
    * Renamed helpers to _default_
    
    v5:
    * Re-introduced the helpers from v4
    
    v4:
    * Fix the doc
    * Kill default helpers (inlined)
    * Fix drm_atomic_get_bridge_state() to check for an ERR_PTR()
    * Add Neil's R-b
    
    v3:
    * No changes
    
    v2:
    * Use drm_for_each_bridge_in_chain()
    * Rename helpers to be more consistent with the rest of the DRM API
    * Improve/fix the doc
    
    Signed-off-by: Boris Brezillon <boris.brezillon@collabora.com>
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Reviewed-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200128135514.108171-2-boris.brezillon@collabora.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 951dfb15c27b..82a888769b3d 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -669,6 +669,9 @@ __drm_atomic_get_current_plane_state(struct drm_atomic_state *state,
 	return plane->state;
 }
 
+int __must_check
+drm_atomic_add_encoder_bridges(struct drm_atomic_state *state,
+			       struct drm_encoder *encoder);
 int __must_check
 drm_atomic_add_affected_connectors(struct drm_atomic_state *state,
 				   struct drm_crtc *crtc);
@@ -992,4 +995,35 @@ drm_atomic_crtc_effectively_active(const struct drm_crtc_state *state)
 	return state->active || state->self_refresh_active;
 }
 
+/**
+ * struct drm_bridge_state - Atomic bridge state object
+ */
+struct drm_bridge_state {
+	/**
+	 * @base: inherit from &drm_private_state
+	 */
+	struct drm_private_state base;
+
+	/**
+	 * @bridge: the bridge this state refers to
+	 */
+	struct drm_bridge *bridge;
+};
+
+static inline struct drm_bridge_state *
+drm_priv_to_bridge_state(struct drm_private_state *priv)
+{
+	return container_of(priv, struct drm_bridge_state, base);
+}
+
+struct drm_bridge_state *
+drm_atomic_get_bridge_state(struct drm_atomic_state *state,
+			    struct drm_bridge *bridge);
+struct drm_bridge_state *
+drm_atomic_get_old_bridge_state(struct drm_atomic_state *state,
+				struct drm_bridge *bridge);
+struct drm_bridge_state *
+drm_atomic_get_new_bridge_state(struct drm_atomic_state *state,
+				struct drm_bridge *bridge);
+
 #endif /* DRM_ATOMIC_H_ */

commit 09912635230374bdca2aca620d183f1834b3140c
Author: Boris Brezillon <boris.brezillon@collabora.com>
Date:   Tue Jan 7 19:58:07 2020 +0100

    Revert "drm/bridge: Add a drm_bridge_state object"
    
    This reverts commit 6ed7e9625fa6 ("drm/bridge: Add a drm_bridge_state
    object") which introduced a circular dependency between drm.ko and
    drm_kms_helper.ko. Looks like the helper/core split is not appropriate
    and fixing that is not simple.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@collabora.com>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200107185807.606999-6-boris.brezillon@collabora.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index ccce65e14917..951dfb15c27b 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -669,9 +669,6 @@ __drm_atomic_get_current_plane_state(struct drm_atomic_state *state,
 	return plane->state;
 }
 
-int __must_check
-drm_atomic_add_encoder_bridges(struct drm_atomic_state *state,
-			       struct drm_encoder *encoder);
 int __must_check
 drm_atomic_add_affected_connectors(struct drm_atomic_state *state,
 				   struct drm_crtc *crtc);

commit 6ed7e9625fa6a6ee8230945820544767ed5799c4
Author: Boris Brezillon <boris.brezillon@collabora.com>
Date:   Mon Jan 6 15:34:06 2020 +0100

    drm/bridge: Add a drm_bridge_state object
    
    One of the last remaining objects to not have its atomic state.
    
    This is being motivated by our attempt to support runtime bus-format
    negotiation between elements of the bridge chain.
    This patch just paves the road for such a feature by adding a new
    drm_bridge_state object inheriting from drm_private_obj so we can
    re-use some of the existing state initialization/tracking logic.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@collabora.com>
    Reviewed-by: Neil Armstrong <narmstrong@baylibre.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Reviewed by: Jernej Skrabec <jernej.skrabec@siol.net>
    Tested-by: Jonas Karlman <jonas@kwiboo.se>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200106143409.32321-2-narmstrong@baylibre.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 951dfb15c27b..ccce65e14917 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -669,6 +669,9 @@ __drm_atomic_get_current_plane_state(struct drm_atomic_state *state,
 	return plane->state;
 }
 
+int __must_check
+drm_atomic_add_encoder_bridges(struct drm_atomic_state *state,
+			       struct drm_encoder *encoder);
 int __must_check
 drm_atomic_add_affected_connectors(struct drm_atomic_state *state,
 				   struct drm_crtc *crtc);

commit 42240c90e3b03deb52c224609e1b2b132ff40f8b
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Dec 6 14:53:36 2019 +0100

    drm/atomic: Spell CRTC consistently
    
    CRTC is an abbreviation and should be all caps in prose. Update all
    kerneldoc comments to use a consistent spelling.
    
    v2: remove hunk unrelated to the CRTC spelling fixes
    
    Reviewed-by: Thomas Zimmermann <tzimmermann@suse.de>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191206135336.2084564-2-thierry.reding@gmail.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index c552d2dc9717..951dfb15c27b 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -363,7 +363,7 @@ struct drm_atomic_state {
 	 * When a connector or plane is not bound to any CRTC, it's still important
 	 * to preserve linearity to prevent the atomic states from being freed to early.
 	 *
-	 * This commit (if set) is not bound to any crtc, but will be completed when
+	 * This commit (if set) is not bound to any CRTC, but will be completed when
 	 * drm_atomic_helper_commit_hw_done() is called.
 	 */
 	struct drm_crtc_commit *fake_commit;
@@ -476,12 +476,12 @@ drm_atomic_get_new_connector_for_encoder(struct drm_atomic_state *state,
 					 struct drm_encoder *encoder);
 
 /**
- * drm_atomic_get_existing_crtc_state - get crtc state, if it exists
+ * drm_atomic_get_existing_crtc_state - get CRTC state, if it exists
  * @state: global atomic state object
- * @crtc: crtc to grab
+ * @crtc: CRTC to grab
  *
- * This function returns the crtc state for the given crtc, or NULL
- * if the crtc is not part of the global atomic state.
+ * This function returns the CRTC state for the given CRTC, or NULL
+ * if the CRTC is not part of the global atomic state.
  *
  * This function is deprecated, @drm_atomic_get_old_crtc_state or
  * @drm_atomic_get_new_crtc_state should be used instead.
@@ -494,12 +494,12 @@ drm_atomic_get_existing_crtc_state(struct drm_atomic_state *state,
 }
 
 /**
- * drm_atomic_get_old_crtc_state - get old crtc state, if it exists
+ * drm_atomic_get_old_crtc_state - get old CRTC state, if it exists
  * @state: global atomic state object
- * @crtc: crtc to grab
+ * @crtc: CRTC to grab
  *
- * This function returns the old crtc state for the given crtc, or
- * NULL if the crtc is not part of the global atomic state.
+ * This function returns the old CRTC state for the given CRTC, or
+ * NULL if the CRTC is not part of the global atomic state.
  */
 static inline struct drm_crtc_state *
 drm_atomic_get_old_crtc_state(struct drm_atomic_state *state,
@@ -508,12 +508,12 @@ drm_atomic_get_old_crtc_state(struct drm_atomic_state *state,
 	return state->crtcs[drm_crtc_index(crtc)].old_state;
 }
 /**
- * drm_atomic_get_new_crtc_state - get new crtc state, if it exists
+ * drm_atomic_get_new_crtc_state - get new CRTC state, if it exists
  * @state: global atomic state object
- * @crtc: crtc to grab
+ * @crtc: CRTC to grab
  *
- * This function returns the new crtc state for the given crtc, or
- * NULL if the crtc is not part of the global atomic state.
+ * This function returns the new CRTC state for the given CRTC, or
+ * NULL if the CRTC is not part of the global atomic state.
  */
 static inline struct drm_crtc_state *
 drm_atomic_get_new_crtc_state(struct drm_atomic_state *state,
@@ -978,11 +978,11 @@ drm_atomic_crtc_needs_modeset(const struct drm_crtc_state *state)
 }
 
 /**
- * drm_atomic_crtc_effectively_active - compute whether crtc is actually active
+ * drm_atomic_crtc_effectively_active - compute whether CRTC is actually active
  * @state: &drm_crtc_state for the CRTC
  *
  * When in self refresh mode, the crtc_state->active value will be false, since
- * the crtc is off. However in some cases we're interested in whether the crtc
+ * the CRTC is off. However in some cases we're interested in whether the CRTC
  * is active, or effectively active (ie: it's connected to an active display).
  * In these cases, use this function instead of just checking active.
  */

commit dbe2d2bf79d2675e647d6a22fcb213e30a9b9706
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Dec 6 14:53:35 2019 +0100

    drm: Fix a couple of typos, punctation and whitespace issues
    
    These are just a couple of things that I came across as I was reading
    through the code and comments.
    
    v2: added one more hunk that ended up in the wrong patch
    
    Reviewed-by: Thomas Zimmermann <tzimmermann@suse.de>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191206135336.2084564-1-thierry.reding@gmail.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 5923819dcd68..c552d2dc9717 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -35,7 +35,7 @@
  * struct drm_crtc_commit - track modeset commits on a CRTC
  *
  * This structure is used to track pending modeset changes and atomic commit on
- * a per-CRTC basis. Since updating the list should never block this structure
+ * a per-CRTC basis. Since updating the list should never block, this structure
  * is reference counted to allow waiters to safely wait on an event to complete,
  * without holding any locks.
  *

commit 0380c6846a4be705b2d5c964b01ba1e5aaa3f5df
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Dec 4 11:00:11 2019 +0100

    drm/atomic: Update docs around locking and commit sequencing
    
    Both locking and especially sequencing of nonblocking commits have
    evolved a lot. The details are all there, but I noticed that the big
    picture and connections have fallen behind a bit. Apply polish.
    
    Motivated by some review discussions with Thierry.
    
    v2: Review from Thierry
    
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Cc: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191204100011.859468-1-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index b6c73fd9f55a..5923819dcd68 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -60,8 +60,8 @@
  * 	wait for flip_done		<----
  * 	clean up atomic state
  *
- * The important bit to know is that cleanup_done is the terminal event, but the
- * ordering between flip_done and hw_done is entirely up to the specific driver
+ * The important bit to know is that &cleanup_done is the terminal event, but the
+ * ordering between &flip_done and &hw_done is entirely up to the specific driver
  * and modeset state change.
  *
  * For an implementation of how to use this look at
@@ -92,6 +92,9 @@ struct drm_crtc_commit {
 	 * commit is sent to userspace, or when an out-fence is singalled. Note
 	 * that for most hardware, in most cases this happens after @hw_done is
 	 * signalled.
+	 *
+	 * Completion of this stage is signalled implicitly by calling
+	 * drm_crtc_send_vblank_event() on &drm_crtc_state.event.
 	 */
 	struct completion flip_done;
 
@@ -107,6 +110,9 @@ struct drm_crtc_commit {
 	 * Note that this does not need to include separately reference-counted
 	 * resources like backing storage buffer pinning, or runtime pm
 	 * management.
+	 *
+	 * Drivers should call drm_atomic_helper_commit_hw_done() to signal
+	 * completion of this stage.
 	 */
 	struct completion hw_done;
 
@@ -118,6 +124,9 @@ struct drm_crtc_commit {
 	 * a vblank wait completed it might be a bit later. This completion is
 	 * useful to throttle updates and avoid hardware updates getting ahead
 	 * of the buffer cleanup too much.
+	 *
+	 * Drivers should call drm_atomic_helper_commit_cleanup_done() to signal
+	 * completion of this stage.
 	 */
 	struct completion cleanup_done;
 

commit bf5d837a0a4ced7cc223befc9e76d4ad30697d27
Author: Benjamin Gaignard <benjamin.gaignard@st.com>
Date:   Tue Oct 8 14:42:54 2019 +0200

    drm: atomic helper: fix W=1 warnings
    
    Few for_each macro set variables that are never used later which led
    to generate unused-but-set-variable warnings.
    Add (void)(foo) inside the macros to remove these warnings
    
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@st.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191008124254.2144-1-benjamin.gaignard@st.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 927e1205d7aa..b6c73fd9f55a 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -693,6 +693,7 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)								\
 		for_each_if ((__state)->connectors[__i].ptr &&			\
 			     ((connector) = (__state)->connectors[__i].ptr,	\
+			     (void)(connector) /* Only to avoid unused-but-set-variable warning */, \
 			     (old_connector_state) = (__state)->connectors[__i].old_state,	\
 			     (new_connector_state) = (__state)->connectors[__i].new_state, 1))
 
@@ -714,6 +715,7 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)								\
 		for_each_if ((__state)->connectors[__i].ptr &&			\
 			     ((connector) = (__state)->connectors[__i].ptr,	\
+			     (void)(connector) /* Only to avoid unused-but-set-variable warning */, \
 			     (old_connector_state) = (__state)->connectors[__i].old_state, 1))
 
 /**
@@ -734,7 +736,9 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)								\
 		for_each_if ((__state)->connectors[__i].ptr &&			\
 			     ((connector) = (__state)->connectors[__i].ptr,	\
-			     (new_connector_state) = (__state)->connectors[__i].new_state, 1))
+			     (void)(connector) /* Only to avoid unused-but-set-variable warning */, \
+			     (new_connector_state) = (__state)->connectors[__i].new_state, \
+			     (void)(new_connector_state) /* Only to avoid unused-but-set-variable warning */, 1))
 
 /**
  * for_each_oldnew_crtc_in_state - iterate over all CRTCs in an atomic update
@@ -754,7 +758,9 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)							\
 		for_each_if ((__state)->crtcs[__i].ptr &&		\
 			     ((crtc) = (__state)->crtcs[__i].ptr,	\
+			      (void)(crtc) /* Only to avoid unused-but-set-variable warning */, \
 			     (old_crtc_state) = (__state)->crtcs[__i].old_state, \
+			     (void)(old_crtc_state) /* Only to avoid unused-but-set-variable warning */, \
 			     (new_crtc_state) = (__state)->crtcs[__i].new_state, 1))
 
 /**
@@ -793,7 +799,9 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)							\
 		for_each_if ((__state)->crtcs[__i].ptr &&		\
 			     ((crtc) = (__state)->crtcs[__i].ptr,	\
-			     (new_crtc_state) = (__state)->crtcs[__i].new_state, 1))
+			     (void)(crtc) /* Only to avoid unused-but-set-variable warning */, \
+			     (new_crtc_state) = (__state)->crtcs[__i].new_state, \
+			     (void)(new_crtc_state) /* Only to avoid unused-but-set-variable warning */, 1))
 
 /**
  * for_each_oldnew_plane_in_state - iterate over all planes in an atomic update
@@ -813,6 +821,7 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)							\
 		for_each_if ((__state)->planes[__i].ptr &&		\
 			     ((plane) = (__state)->planes[__i].ptr,	\
+			      (void)(plane) /* Only to avoid unused-but-set-variable warning */, \
 			      (old_plane_state) = (__state)->planes[__i].old_state,\
 			      (new_plane_state) = (__state)->planes[__i].new_state, 1))
 
@@ -873,7 +882,9 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)							\
 		for_each_if ((__state)->planes[__i].ptr &&		\
 			     ((plane) = (__state)->planes[__i].ptr,	\
-			      (new_plane_state) = (__state)->planes[__i].new_state, 1))
+			      (void)(plane) /* Only to avoid unused-but-set-variable warning */, \
+			      (new_plane_state) = (__state)->planes[__i].new_state, \
+			      (void)(new_plane_state) /* Only to avoid unused-but-set-variable warning */, 1))
 
 /**
  * for_each_oldnew_private_obj_in_state - iterate over all private objects in an atomic update

commit 1452c25b0e60278820f3d2155c65f1bfcce5ee79
Author: Sean Paul <seanpaul@chromium.org>
Date:   Wed Jun 12 10:50:19 2019 -0400

    drm: Add helpers to kick off self refresh mode in drivers
    
    This patch adds a new drm helper library to help drivers implement
    self refresh. Drivers choosing to use it will register crtcs and
    will receive callbacks when it's time to enter or exit self refresh
    mode.
    
    In its current form, it has a timer which will trigger after a
    driver-specified amount of inactivity. When the timer triggers, the
    helpers will submit a new atomic commit to shut the refreshing pipe
    off. On the next atomic commit, the drm core will revert the self
    refresh state and bring everything back up to be actively driven.
    
    From the driver's perspective, this works like a regular disable/enable
    cycle. The driver need only check the 'self_refresh_active' state in
    crtc_state. It should initiate self refresh mode on the panel and enter
    an off or low-power state.
    
    Changes in v2:
    - s/psr/self_refresh/ (Daniel)
    - integrated the psr exit into the commit that wakes it up (Jose/Daniel)
    - made the psr state per-crtc (Jose/Daniel)
    Changes in v3:
    - Remove the self_refresh_(active|changed) from connector state (Daniel)
    - Simplify loop in drm_self_refresh_helper_alter_state (Daniel)
    - Improve self_refresh_aware comment (Daniel)
    - s/self_refresh_state/self_refresh_data/ (Daniel)
    Changes in v4:
    - Move docbook location below panel (Daniel)
    - Improve docbook with references and more detailed explanation (Daniel)
    - Instead of register/unregister, use init/cleanup (Daniel)
    Changes in v5:
    - Resolved conflict in drm_atomic_helper.c #include block
    - Resolved conflict in rst with HDCP helper docs
    Changes in v6:
    - Fix include ordering, clean up forward declarations (Sam)
    
    Link to v1: https://patchwork.freedesktop.org/patch/msgid/20190228210939.83386-2-sean@poorly.run
    Link to v2: https://patchwork.freedesktop.org/patch/msgid/20190326204509.96515-1-sean@poorly.run
    Link to v3: https://patchwork.freedesktop.org/patch/msgid/20190502194956.218441-6-sean@poorly.run
    Link to v4: https://patchwork.freedesktop.org/patch/msgid/20190508160920.144739-6-sean@poorly.run
    Link to v5: https://patchwork.freedesktop.org/patch/msgid/20190611160844.257498-6-sean@poorly.run
    
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Jose Souza <jose.souza@intel.com>
    Cc: Zain Wang <wzz@rock-chips.com>
    Cc: Tomasz Figa <tfiga@chromium.org>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Reviewed-by: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190612145026.191846-1-sean@poorly.run

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index f12215647801..927e1205d7aa 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -957,4 +957,19 @@ drm_atomic_crtc_needs_modeset(const struct drm_crtc_state *state)
 	       state->connectors_changed;
 }
 
+/**
+ * drm_atomic_crtc_effectively_active - compute whether crtc is actually active
+ * @state: &drm_crtc_state for the CRTC
+ *
+ * When in self refresh mode, the crtc_state->active value will be false, since
+ * the crtc is off. However in some cases we're interested in whether the crtc
+ * is active, or effectively active (ie: it's connected to an active display).
+ * In these cases, use this function instead of just checking active.
+ */
+static inline bool
+drm_atomic_crtc_effectively_active(const struct drm_crtc_state *state)
+{
+	return state->active || state->self_refresh_active;
+}
+
 #endif /* DRM_ATOMIC_H_ */

commit 1b27fbdde1df172dba604855c45078d741f8c858
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Jun 11 16:51:43 2019 -0400

    drm: Add drm_atomic_get_(old|new)_connector_for_encoder() helpers
    
    Add functions to the atomic core to retrieve the old and new connectors
    associated with an encoder in a drm_atomic_state. This is useful for
    encoders and bridges that need to access the connector, for instance for
    the drm_display_info.
    
    The CRTC associated with the encoder can also be retrieved through the
    connector state, and from it, the old and new CRTC states.
    
    Changed in v4:
    - Added to the set
    Changed in v5:
    - Fix up docbook (Daniel & Laurent)
    Changed in v6:
    - Updated commit subject (Sam)
    
    Link to v4: https://patchwork.freedesktop.org/patch/msgid/20190508160920.144739-3-sean@poorly.run
    Link to v5: https://patchwork.freedesktop.org/patch/msgid/20190611160844.257498-3-sean@poorly.run
    
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Reviewed-by: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    
    [seanpaul removed WARNs from helpers and added docs to explain why
    returning NULL might be valid]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190611205147.181298-1-sean@poorly.run

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index e937ff2beb04..f12215647801 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -459,6 +459,13 @@ struct drm_private_state *
 drm_atomic_get_new_private_obj_state(struct drm_atomic_state *state,
 				     struct drm_private_obj *obj);
 
+struct drm_connector *
+drm_atomic_get_old_connector_for_encoder(struct drm_atomic_state *state,
+					 struct drm_encoder *encoder);
+struct drm_connector *
+drm_atomic_get_new_connector_for_encoder(struct drm_atomic_state *state,
+					 struct drm_encoder *encoder);
+
 /**
  * drm_atomic_get_existing_crtc_state - get crtc state, if it exists
  * @state: global atomic state object

commit 9801a7eadf4cc29cdc90583a49f12decbb832ced
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jan 22 11:05:41 2019 +0000

    drm: Add drm_atomic_get_old/new_private_obj_state
    
    This pair of functions return the old/new private object state for the
    given private_obj, or NULL if the private_obj is not part of the global
    atomic state.
    
    Reviewed-by: Alexandru Gheorghe <alexandru-cosmin.gheorghe@arm.com>
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 824a5ed4e216..e937ff2beb04 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -452,6 +452,12 @@ void drm_atomic_private_obj_fini(struct drm_private_obj *obj);
 struct drm_private_state * __must_check
 drm_atomic_get_private_obj_state(struct drm_atomic_state *state,
 				 struct drm_private_obj *obj);
+struct drm_private_state *
+drm_atomic_get_old_private_obj_state(struct drm_atomic_state *state,
+				     struct drm_private_obj *obj);
+struct drm_private_state *
+drm_atomic_get_new_private_obj_state(struct drm_atomic_state *state,
+				     struct drm_private_obj *obj);
 
 /**
  * drm_atomic_get_existing_crtc_state - get crtc state, if it exists

commit 022debad063e4d3fb456218273821c010757f6f7
Author: Lyude Paul <lyude@redhat.com>
Date:   Fri Feb 1 19:20:03 2019 -0500

    drm/atomic: Add drm_atomic_state->duplicated
    
    Since
    
    commit 39b50c603878 ("drm/atomic_helper: Stop modesets on unregistered
    connectors harder")
    
    We've been failing atomic checks if they try to enable new displays on
    unregistered connectors. This is fine except for the one situation that
    breaks atomic assumptions: suspend/resume. If a connector is
    unregistered before we attempt to restore the atomic state, something we
    end up failing the atomic check that happens when trying to restore the
    state during resume.
    
    Normally this would be OK: we try our best to make sure that the atomic
    state pre-suspend can be restored post-suspend, but failures at that
    point usually don't cause problems. That is of course, until we
    introduced the new atomic MST VCPI helpers:
    
    [drm:drm_atomic_helper_check_modeset [drm_kms_helper]] [CRTC:65:pipe B] active changed
    [drm:drm_atomic_helper_check_modeset [drm_kms_helper]] Updating routing for [CONNECTOR:123:DP-5]
    [drm:drm_atomic_helper_check_modeset [drm_kms_helper]] Disabling [CONNECTOR:123:DP-5]
    [drm:drm_atomic_get_private_obj_state [drm]] Added new private object 0000000025844636 state 000000009fd2899a to 000000003a13d7b8
    WARNING: CPU: 6 PID: 1070 at drivers/gpu/drm/drm_dp_mst_topology.c:3153 drm_dp_atomic_release_vcpi_slots+0xb9/0x200 [drm_kms_helper]
    Modules linked in: fuse vfat fat snd_hda_codec_hdmi snd_hda_codec_realtek snd_hda_codec_generic joydev iTCO_wdt i915(O) wmi_bmof intel_rapl btusb btrtl x86_pkg_temp_thermal btbcm btintel coretemp i2c_algo_bit drm_kms_helper(O) crc32_pclmul snd_hda_intel syscopyarea sysfillrect snd_hda_codec sysimgblt snd_hda_core bluetooth fb_sys_fops snd_pcm pcspkr drm(O) psmouse snd_timer mei_me ecdh_generic i2c_i801 mei i2c_core ucsi_acpi typec_ucsi typec wmi thinkpad_acpi ledtrig_audio snd soundcore tpm_tis rfkill tpm_tis_core video tpm acpi_pad pcc_cpufreq uas usb_storage crc32c_intel nvme serio_raw xhci_pci nvme_core xhci_hcd
    CPU: 6 PID: 1070 Comm: gnome-shell Tainted: G        W  O      5.0.0-rc2Lyude-Test+ #1
    Hardware name: LENOVO 20L8S2N800/20L8S2N800, BIOS N22ET35W (1.12 ) 04/09/2018
    RIP: 0010:drm_dp_atomic_release_vcpi_slots+0xb9/0x200 [drm_kms_helper]
    Code: 00 4c 39 6d f0 74 49 48 8d 7b 10 48 89 f9 48 c1 e9 03 42 80 3c 21 00 0f 85 d2 00 00 00 48 8b 6b 10 48 8d 5d f0 49 39 ee 75 c5 <0f> 0b 48 c7 c7 c0 78 b3 a0 48 89 c2 4c 89 ee e8 03 6c aa ff b8 ea
    RSP: 0018:ffff88841235f268 EFLAGS: 00010246
    RAX: ffff88841bf12ab0 RBX: ffff88841bf12aa8 RCX: 1ffff110837e2557
    RDX: dffffc0000000000 RSI: 0000000000000000 RDI: ffffed108246bde0
    RBP: ffff88841bf12ab8 R08: ffffed1083db3c93 R09: ffffed1083db3c92
    R10: ffffed1083db3c92 R11: ffff88841ed9e497 R12: ffff888419555d80
    R13: ffff8883bc499100 R14: ffff88841bf12ab8 R15: 0000000000000000
    FS:  00007f16fbd4cd00(0000) GS:ffff88841ed80000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007f1687c9f000 CR3: 00000003ba3cc003 CR4: 00000000003606e0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    Call Trace:
     drm_atomic_helper_check_modeset+0xf21/0x2f50 [drm_kms_helper]
     ? drm_atomic_helper_commit_modeset_enables+0xa90/0xa90 [drm_kms_helper]
     ? __printk_safe_exit+0x10/0x10
     ? save_stack+0x8c/0xb0
     ? vprintk_func+0x96/0x1bf
     ? __printk_safe_exit+0x10/0x10
     intel_atomic_check+0x234/0x4750 [i915]
     ? printk+0x9f/0xc5
     ? kmsg_dump_rewind_nolock+0xd9/0xd9
     ? _raw_spin_lock_irqsave+0xa4/0x140
     ? drm_atomic_check_only+0xb1/0x28b0 [drm]
     ? drm_dbg+0x186/0x1b0 [drm]
     ? drm_dev_dbg+0x200/0x200 [drm]
     ? intel_link_compute_m_n+0xb0/0xb0 [i915]
     ? drm_mode_put_tile_group+0x20/0x20 [drm]
     ? skl_plane_format_mod_supported+0x17f/0x1b0 [i915]
     ? drm_plane_check_pixel_format+0x14a/0x310 [drm]
     drm_atomic_check_only+0x13c4/0x28b0 [drm]
     ? drm_state_info+0x220/0x220 [drm]
     ? drm_atomic_helper_disable_plane+0x1d0/0x1d0 [drm_kms_helper]
     ? pick_single_encoder_for_connector+0xe0/0xe0 [drm_kms_helper]
     ? kasan_unpoison_shadow+0x35/0x40
     drm_atomic_commit+0x3b/0x100 [drm]
     drm_atomic_helper_set_config+0xd5/0x100 [drm_kms_helper]
     drm_mode_setcrtc+0x636/0x1660 [drm]
     ? vprintk_func+0x96/0x1bf
     ? drm_dev_dbg+0x200/0x200 [drm]
     ? drm_mode_getcrtc+0x790/0x790 [drm]
     ? printk+0x9f/0xc5
     ? mutex_unlock+0x1d/0x40
     ? drm_mode_addfb2+0x2e9/0x3a0 [drm]
     ? rcu_sync_dtor+0x2e0/0x2e0
     ? drm_dbg+0x186/0x1b0 [drm]
     ? set_page_dirty+0x271/0x4d0
     drm_ioctl_kernel+0x203/0x290 [drm]
     ? drm_mode_getcrtc+0x790/0x790 [drm]
     ? drm_setversion+0x7f0/0x7f0 [drm]
     ? __switch_to_asm+0x34/0x70
     ? __switch_to_asm+0x34/0x70
     drm_ioctl+0x445/0x950 [drm]
     ? drm_mode_getcrtc+0x790/0x790 [drm]
     ? drm_getunique+0x220/0x220 [drm]
     ? expand_files.part.10+0x920/0x920
     do_vfs_ioctl+0x1a1/0x13d0
     ? ioctl_preallocate+0x2b0/0x2b0
     ? __fget_light+0x2d6/0x390
     ? schedule+0xd7/0x2e0
     ? fget_raw+0x10/0x10
     ? apic_timer_interrupt+0xa/0x20
     ? apic_timer_interrupt+0xa/0x20
     ? rcu_cleanup_dead_rnp+0x2c0/0x2c0
     ksys_ioctl+0x60/0x90
     __x64_sys_ioctl+0x6f/0xb0
     do_syscall_64+0x136/0x440
     ? syscall_return_slowpath+0x2d0/0x2d0
     ? do_page_fault+0x89/0x330
     ? __do_page_fault+0x9c0/0x9c0
     ? prepare_exit_to_usermode+0x188/0x200
     ? perf_trace_sys_enter+0x1090/0x1090
     ? __x64_sys_sigaltstack+0x280/0x280
     ? __put_user_4+0x1c/0x30
     entry_SYSCALL_64_after_hwframe+0x44/0xa9
    RIP: 0033:0x7f16ff89a09b
    Code: 0f 1e fa 48 8b 05 ed bd 0c 00 64 c7 00 26 00 00 00 48 c7 c0 ff ff ff ff c3 66 0f 1f 44 00 00 f3 0f 1e fa b8 10 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d bd bd 0c 00 f7 d8 64 89 01 48
    RSP: 002b:00007fff001232b8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
    RAX: ffffffffffffffda RBX: 00007fff001232f0 RCX: 00007f16ff89a09b
    RDX: 00007fff001232f0 RSI: 00000000c06864a2 RDI: 000000000000000b
    RBP: 00007fff001232f0 R08: 0000000000000000 R09: 000055a79d484460
    R10: 000055a79d44e770 R11: 0000000000000246 R12: 00000000c06864a2
    R13: 000000000000000b R14: 0000000000000000 R15: 000055a79d44e770
    WARNING: CPU: 6 PID: 1070 at drivers/gpu/drm/drm_dp_mst_topology.c:3153 drm_dp_atomic_release_vcpi_slots+0xb9/0x200 [drm_kms_helper]
    ---[ end trace d536c05c13c83be2 ]---
    [drm:drm_dp_atomic_release_vcpi_slots [drm_kms_helper]] *ERROR* no VCPI for [MST PORT:00000000f9e2b143] found in mst state 000000009fd2899a
    
    This appears to be happening because we destroy the VCPI allocations
    when disabling all connected displays while suspending, and those VCPI
    allocations don't get restored on resume due to failing to restore the
    atomic state.
    
    So, fix this by introducing the suspending option to
    drm_atomic_helper_duplicate_state() and use that to indicate in the
    atomic state that it's being used for suspending or resuming the system,
    and thus needs to be fixed up by the driver. We can then use the new
    state->duplicated hook to tell update_connector_routing() in
    drm_atomic_check_modeset() to allow for modesets on unregistered
    connectors, which allows us to restore atomic states that contain MST
    topologies that were removed after the state was duplicated and thus:
    mostly fixing suspend and resume. This just leaves some issues that were
    introduced with nouveau, that will be addressed next.
    
    Changes since v3:
    * Remove ->duplicated hunks that I left in the VCPI helpers by accident.
      These don't need to be here, that was the supposed to be the purpose
      of the last revision
    Changes since v2:
    * Remove the changes in this patch to the VCPI helpers, they aren't
      needed anymore
    Changes since v1:
    * Rename suspend_or_resume to duplicated
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Fixes: eceae1472467 ("drm/dp_mst: Start tracking per-port VCPI allocations")
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190202002023.29665-4-lyude@redhat.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 3b97b2bfaad9..824a5ed4e216 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -329,6 +329,15 @@ struct drm_atomic_state {
 	bool allow_modeset : 1;
 	bool legacy_cursor_update : 1;
 	bool async_update : 1;
+	/**
+	 * @duplicated:
+	 *
+	 * Indicates whether or not this atomic state was duplicated using
+	 * drm_atomic_helper_duplicate_state(). Drivers and atomic helpers
+	 * should use this to fixup normal  inconsistencies in duplicated
+	 * states.
+	 */
+	bool duplicated : 1;
 	struct __drm_planes_state *planes;
 	struct __drm_crtcs_state *crtcs;
 	int num_connector;

commit 1e55a53a28d3e52a68e11917dd25a216c3e7c182
Author: Matt Roper <matthew.d.roper@intel.com>
Date:   Fri Feb 1 17:23:26 2019 -0800

    drm: Trivial comment grammar cleanups
    
    Most of these are just cases where code comments used contractions
    (it's, who's) where they actually mean to use a possessive pronoun (its,
    whose) or vice-versa.
    
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190202012326.20096-1-matthew.d.roper@intel.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 811b4a92568f..3b97b2bfaad9 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -192,7 +192,7 @@ struct drm_private_state;
  * private objects. The structure itself is used as a vtable to identify the
  * associated private object type. Each private object type that needs to be
  * added to the atomic states is expected to have an implementation of these
- * hooks and pass a pointer to it's drm_private_state_funcs struct to
+ * hooks and pass a pointer to its drm_private_state_funcs struct to
  * drm_atomic_get_private_obj_state().
  */
 struct drm_private_state_funcs {

commit 7d0250ed8e69fb6a66caecf60b8753a21224cc1a
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Oct 12 09:34:41 2018 +0200

    drm/atomic: Add missing () to function ref in kerneldoc
    
    Pure drive-by while reading code&docs.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181012073441.21774-1-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index cac4a1b6b0e8..811b4a92568f 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -139,9 +139,9 @@ struct drm_crtc_commit {
 	/**
 	 * @abort_completion:
 	 *
-	 * A flag that's set after drm_atomic_helper_setup_commit takes a second
-	 * reference for the completion of $drm_crtc_state.event. It's used by
-	 * the free code to remove the second reference if commit fails.
+	 * A flag that's set after drm_atomic_helper_setup_commit() takes a
+	 * second reference for the completion of $drm_crtc_state.event. It's
+	 * used by the free code to remove the second reference if commit fails.
 	 */
 	bool abort_completion;
 };

commit b962a12050a387e4bbf3a48745afe1d29d396b0d
Author: Rob Clark <robdclark@gmail.com>
Date:   Mon Oct 22 14:31:22 2018 +0200

    drm/atomic: integrate modeset lock with private objects
    
    Follow the same pattern of locking as with other state objects. This
    avoids boilerplate in the driver.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181022123122.30468-1-boris.brezillon@bootlin.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index f9b35834c45d..cac4a1b6b0e8 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -228,8 +228,30 @@ struct drm_private_state_funcs {
  * Currently only tracks the state update functions and the opaque driver
  * private state itself, but in the future might also track which
  * &drm_modeset_lock is required to duplicate and update this object's state.
+ *
+ * All private objects must be initialized before the DRM device they are
+ * attached to is registered to the DRM subsystem (call to drm_dev_register())
+ * and should stay around until this DRM device is unregistered (call to
+ * drm_dev_unregister()). In other words, private objects lifetime is tied
+ * to the DRM device lifetime. This implies that:
+ *
+ * 1/ all calls to drm_atomic_private_obj_init() must be done before calling
+ *    drm_dev_register()
+ * 2/ all calls to drm_atomic_private_obj_fini() must be done after calling
+ *    drm_dev_unregister()
  */
 struct drm_private_obj {
+	/**
+	 * @head: List entry used to attach a private object to a &drm_device
+	 * (queued to &drm_mode_config.privobj_list).
+	 */
+	struct list_head head;
+
+	/**
+	 * @lock: Modeset lock to protect the state object.
+	 */
+	struct drm_modeset_lock lock;
+
 	/**
 	 * @state: Current atomic state for this driver private object.
 	 */
@@ -244,6 +266,18 @@ struct drm_private_obj {
 	const struct drm_private_state_funcs *funcs;
 };
 
+/**
+ * drm_for_each_privobj() - private object iterator
+ *
+ * @privobj: pointer to the current private object. Updated after each
+ *	     iteration
+ * @dev: the DRM device we want get private objects from
+ *
+ * Allows one to iterate over all private objects attached to @dev
+ */
+#define drm_for_each_privobj(privobj, dev) \
+	list_for_each_entry(privobj, &(dev)->mode_config.privobj_list, head)
+
 /**
  * struct drm_private_state - base struct for driver private object state
  * @state: backpointer to global drm_atomic_state
@@ -400,7 +434,8 @@ struct drm_connector_state * __must_check
 drm_atomic_get_connector_state(struct drm_atomic_state *state,
 			       struct drm_connector *connector);
 
-void drm_atomic_private_obj_init(struct drm_private_obj *obj,
+void drm_atomic_private_obj_init(struct drm_device *dev,
+				 struct drm_private_obj *obj,
 				 struct drm_private_state *state,
 				 const struct drm_private_state_funcs *funcs);
 void drm_atomic_private_obj_fini(struct drm_private_obj *obj);

commit 0ea0397a3a12f9720d6acb78a48da796a54e81aa
Merge: 913240696ec6 651022382c7f
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Tue Nov 13 10:58:49 2018 +0100

    Merge remote-tracking branch 'drm/drm-next' into drm-misc-next
    
    drm-next is forwarded to v4.20-rc1, and we need this to make
    a patch series apply.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>

commit 53b3b6bbfde6aae8d1ededc86ad4e0e1e00eb5f8
Merge: 746bb4ed6d62 f2bfc71aee75
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Oct 28 17:49:53 2018 -0700

    Merge tag 'drm-next-2018-10-24' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm updates from Dave Airlie:
     "This is going to rebuild more than drm as it adds a new helper to
      list.h for doing bulk updates. Seemed like a reasonable addition to
      me.
    
      Otherwise the usual merge window stuff lots of i915 and amdgpu, not so
      much nouveau, and piles of everything else.
    
      Core:
       - Adds a new list.h helper for doing bulk list updates for TTM.
       - Don't leak fb address in smem_start to userspace (comes with EXPORT
         workaround for people using mali out of tree hacks)
       - udmabuf device to turn memfd regions into dma-buf
       - Per-plane blend mode property
       - ref/unref replacements with get/put
       - fbdev conflicting framebuffers code cleaned up
       - host-endian format variants
       - panel orientation quirk for Acer One 10
    
      bridge:
       - TI SN65DSI86 chip support
    
      vkms:
       - GEM support.
       - Cursor support
    
      amdgpu:
       - Merge amdkfd and amdgpu into one module
       - CEC over DP AUX support
       - Picasso APU support + VCN dynamic powergating
       - Raven2 APU support
       - Vega20 enablement + kfd support
       - ACP powergating improvements
       - ABGR/XBGR display support
       - VCN jpeg support
       - xGMI support
       - DC i2c/aux cleanup
       - Ycbcr 4:2:0 support
       - GPUVM improvements
       - Powerplay and powerplay endian fixes
       - Display underflow fixes
    
      vmwgfx:
       - Move vmwgfx specific TTM code to vmwgfx
       - Split out vmwgfx buffer/resource validation code
       - Atomic operation rework
    
      bochs:
       - use more helpers
       - format/byteorder improvements
    
      qxl:
       - use more helpers
    
      i915:
       - GGTT coherency getparam
       - Turn off resource streamer API
       - More Icelake enablement + DMC firmware
       - Full PPGTT for Ivybridge, Haswell and Valleyview
       - DDB distribution based on resolution
       - Limited range DP display support
    
      nouveau:
       - CEC over DP AUX support
       - Initial HDMI 2.0 support
    
      virtio-gpu:
       - vmap support for PRIME objects
    
      tegra:
       - Initial Tegra194 support
       - DMA/IOMMU integration fixes
    
      msm:
       - a6xx perf improvements + clock prefix
       - GPU preemption optimisations
       - a6xx devfreq support
       - cursor support
    
      rockchip:
       - PX30 support
       - rgb output interface support
    
      mediatek:
       - HDMI output support on mt2701 and mt7623
    
      rcar-du:
       - Interlaced modes on Gen3
       - LVDS on R8A77980
       - D3 and E3 SoC support
    
      hisilicon:
       - misc fixes
    
      mxsfb:
       - runtime pm support
    
      sun4i:
       - R40 TCON support
       - Allwinner A64 support
       - R40 HDMI support
    
      omapdrm:
       - Driver rework changing display pipeline ordering to use common code
       - DMM memory barrier and irq fixes
       - Errata workarounds
    
      exynos:
       - out-bridge support for LVDS bridge driver
       - Samsung 16x16 tiled format support
       - Plane alpha and pixel blend mode support
    
      tilcdc:
       - suspend/resume update
    
      mali-dp:
       - misc updates"
    
    * tag 'drm-next-2018-10-24' of git://anongit.freedesktop.org/drm/drm: (1382 commits)
      firmware/dmc/icl: Add missing MODULE_FIRMWARE() for Icelake.
      drm/i915/icl: Fix signal_levels
      drm/i915/icl: Fix DDI/TC port clk_off bits
      drm/i915/icl: create function to identify combophy port
      drm/i915/gen9+: Fix initial readout for Y tiled framebuffers
      drm/i915: Large page offsets for pread/pwrite
      drm/i915/selftests: Disable shrinker across mmap-exhaustion
      drm/i915/dp: Link train Fallback on eDP only if fallback link BW can fit panel's native mode
      drm/i915: Fix intel_dp_mst_best_encoder()
      drm/i915: Skip vcpi allocation for MSTB ports that are gone
      drm/i915: Don't unset intel_connector->mst_port
      drm/i915: Only reset seqno if actually idle
      drm/i915: Use the correct crtc when sanitizing plane mapping
      drm/i915: Restore vblank interrupts earlier
      drm/i915: Check fb stride against plane max stride
      drm/amdgpu/vcn:Fix uninitialized symbol error
      drm: panel-orientation-quirks: Add quirk for Acer One 10 (S1003)
      drm/amd/amdgpu: Fix debugfs error handling
      drm/amdgpu: Update gc_9_0 golden settings.
      drm/amd/powerplay: update PPtable with DC BTC and Tvr SocLimit fields
      ...

commit 4364bcb2cd21d042bde4776448417ddffbc54045
Author: Leo Li <sunpeng.li@amd.com>
Date:   Mon Oct 15 09:46:40 2018 -0400

    drm: Get ref on CRTC commit object when waiting for flip_done
    
    This fixes a general protection fault, caused by accessing the contents
    of a flip_done completion object that has already been freed. It occurs
    due to the preemption of a non-blocking commit worker thread W by
    another commit thread X. X continues to clear its atomic state at the
    end, destroying the CRTC commit object that W still needs. Switching
    back to W and accessing the commit objects then leads to bad results.
    
    Worker W becomes preemptable when waiting for flip_done to complete. At
    this point, a frequently occurring commit thread X can take over. Here's
    an example where W is a worker thread that flips on both CRTCs, and X
    does a legacy cursor update on both CRTCs:
    
            ...
         1. W does flip work
         2. W runs commit_hw_done()
         3. W waits for flip_done on CRTC 1
         4. > flip_done for CRTC 1 completes
         5. W finishes waiting for CRTC 1
         6. W waits for flip_done on CRTC 2
    
         7. > Preempted by X
         8. > flip_done for CRTC 2 completes
         9. X atomic_check: hw_done and flip_done are complete on all CRTCs
        10. X updates cursor on both CRTCs
        11. X destroys atomic state
        12. X done
    
        13. > Switch back to W
        14. W waits for flip_done on CRTC 2
        15. W raises general protection fault
    
    The error looks like so:
    
        general protection fault: 0000 [#1] PREEMPT SMP PTI
        **snip**
        Call Trace:
         lock_acquire+0xa2/0x1b0
         _raw_spin_lock_irq+0x39/0x70
         wait_for_completion_timeout+0x31/0x130
         drm_atomic_helper_wait_for_flip_done+0x64/0x90 [drm_kms_helper]
         amdgpu_dm_atomic_commit_tail+0xcae/0xdd0 [amdgpu]
         commit_tail+0x3d/0x70 [drm_kms_helper]
         process_one_work+0x212/0x650
         worker_thread+0x49/0x420
         kthread+0xfb/0x130
         ret_from_fork+0x3a/0x50
        Modules linked in: x86_pkg_temp_thermal amdgpu(O) chash(O)
        gpu_sched(O) drm_kms_helper(O) syscopyarea sysfillrect sysimgblt
        fb_sys_fops ttm(O) drm(O)
    
    Note that i915 has this issue masked, since hw_done is signaled after
    waiting for flip_done. Doing so will block the cursor update from
    happening until hw_done is signaled, preventing the cursor commit from
    destroying the state.
    
    v2: The reference on the commit object needs to be obtained before
        hw_done() is signaled, since that's the point where another commit
        is allowed to modify the state. Assuming that the
        new_crtc_state->commit object still exists within flip_done() is
        incorrect.
    
        Fix by getting a reference in setup_commit(), and releasing it
        during default_clear().
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/1539611200-6184-1-git-send-email-sunpeng.li@amd.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index da9d95a19580..1e713154f00e 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -153,6 +153,17 @@ struct __drm_planes_state {
 struct __drm_crtcs_state {
 	struct drm_crtc *ptr;
 	struct drm_crtc_state *state, *old_state, *new_state;
+
+	/**
+	 * @commit:
+	 *
+	 * A reference to the CRTC commit object that is kept for use by
+	 * drm_atomic_helper_wait_for_flip_done() after
+	 * drm_atomic_helper_commit_hw_done() is called. This ensures that a
+	 * concurrent commit won't free a commit object that is still in use.
+	 */
+	struct drm_crtc_commit *commit;
+
 	s32 __user *out_fence_ptr;
 	u64 last_vblank_count;
 };

commit ec9b0a9e2c9e2543aa391c6006fde3f9b6e54576
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Oct 4 22:24:31 2018 +0200

    drm/atomic: Improve docs for drm_atomic_state->allow_modeset
    
    Motivated by vmwgfx digging around in core uapi bits it shouldn't dig
    around in.
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181004202446.22905-7-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index d6adebcd6ea4..c09ecaf43825 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -254,7 +254,6 @@ struct __drm_private_objs_state {
  * struct drm_atomic_state - the global state object for atomic updates
  * @ref: count of all references to this state (will not be freed until zero)
  * @dev: parent DRM device
- * @allow_modeset: allow full modeset
  * @legacy_cursor_update: hint to enforce legacy cursor IOCTL semantics
  * @async_update: hint for asynchronous plane update
  * @planes: pointer to array of structures with per-plane data
@@ -273,6 +272,15 @@ struct drm_atomic_state {
 	struct kref ref;
 
 	struct drm_device *dev;
+
+	/**
+	 * @allow_modeset:
+	 *
+	 * Allow full modeset. This is used by the ATOMIC IOCTL handler to
+	 * implement the DRM_MODE_ATOMIC_ALLOW_MODESET flag. Drivers should
+	 * never consult this flag, instead looking at the output of
+	 * drm_atomic_crtc_needs_modeset().
+	 */
 	bool allow_modeset : 1;
 	bool legacy_cursor_update : 1;
 	bool async_update : 1;

commit 72fdb40c1a4b48f5fa6f6083ea7419b94639ed57
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Sep 5 15:57:11 2018 +0200

    drm: extract drm_atomic_uapi.c
    
    This leaves all the commit/check and state handling in drm_atomic.c,
    while pulling all the uapi glue and the huge ioctl itself into a
    seprate file.
    
    This seems to almost perfectly split the rather big drm_atomic.c file
    into 2 equal sizes.
    
    Also adjust the kerneldoc and type a very terse overview text.
    
    v2: Rebase.
    
    v3: Fix tiny typo.
    
    v4:
    - Fixup armada, newly converted atomic driver hooray!
    - Fixup msm/dpu1, newly added too.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Gustavo Padovan <gustavo@padovan.org>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: intel-gfx@lists.freedesktop.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Acked-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180905135711.28370-7-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 93d29af34024..d6adebcd6ea4 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -584,22 +584,6 @@ __drm_atomic_get_current_plane_state(struct drm_atomic_state *state,
 	return plane->state;
 }
 
-int __must_check
-drm_atomic_set_mode_for_crtc(struct drm_crtc_state *state,
-			     const struct drm_display_mode *mode);
-int __must_check
-drm_atomic_set_mode_prop_for_crtc(struct drm_crtc_state *state,
-				  struct drm_property_blob *blob);
-int __must_check
-drm_atomic_set_crtc_for_plane(struct drm_plane_state *plane_state,
-			      struct drm_crtc *crtc);
-void drm_atomic_set_fb_for_plane(struct drm_plane_state *plane_state,
-				 struct drm_framebuffer *fb);
-void drm_atomic_set_fence_for_plane(struct drm_plane_state *plane_state,
-				    struct dma_fence *fence);
-int __must_check
-drm_atomic_set_crtc_for_connector(struct drm_connector_state *conn_state,
-				  struct drm_crtc *crtc);
 int __must_check
 drm_atomic_add_affected_connectors(struct drm_atomic_state *state,
 				   struct drm_crtc *crtc);

commit d86552efe10a321a78ab3d093bbe9b8ecf778c4e
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Sep 5 15:57:09 2018 +0200

    drm/atomic: trim driver interface/docs
    
    Remove the kerneldoc and EXPORT_SYMBOL which aren't used and really
    shouldn't ever be used by drivers directly.
    
    Unfortunately this means we need to move the set_writeback_fb function
    around to avoid a forward decl.
    
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Gustavo Padovan <gustavo@padovan.org>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180905135711.28370-5-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index d621232a469a..93d29af34024 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -374,9 +374,6 @@ void drm_atomic_state_default_release(struct drm_atomic_state *state);
 struct drm_crtc_state * __must_check
 drm_atomic_get_crtc_state(struct drm_atomic_state *state,
 			  struct drm_crtc *crtc);
-int drm_atomic_crtc_set_property(struct drm_crtc *crtc,
-		struct drm_crtc_state *state, struct drm_property *property,
-		uint64_t val);
 struct drm_plane_state * __must_check
 drm_atomic_get_plane_state(struct drm_atomic_state *state,
 			   struct drm_plane *plane);
@@ -603,9 +600,6 @@ void drm_atomic_set_fence_for_plane(struct drm_plane_state *plane_state,
 int __must_check
 drm_atomic_set_crtc_for_connector(struct drm_connector_state *conn_state,
 				  struct drm_crtc *crtc);
-int drm_atomic_set_writeback_fb_for_connector(
-		struct drm_connector_state *conn_state,
-		struct drm_framebuffer *fb);
 int __must_check
 drm_atomic_add_affected_connectors(struct drm_atomic_state *state,
 				   struct drm_crtc *crtc);

commit d78aa650670d2257099469c344d4d147a43652d9
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Sep 5 15:57:05 2018 +0200

    drm: Add drm/drm_util.h header file
    
    We have a bunch of neat little macros all over the place which should
    move to kernel.h. But some of them died in bikesheds on lkml, and we
    need a decent home for them.
    
    Start out by moving the for_each_if macro there.
    
    v2: Rename to drm_util.h instead (Dave&Sean)
    
    Cc: Sean Paul <seanpaul@chromium.org>
    Acked-by: Sean Paul <seanpaul@chromium.org>
    Cc: Dave Airlie <airlied@gmail.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180905135711.28370-1-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index da9d95a19580..d621232a469a 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -29,6 +29,7 @@
 #define DRM_ATOMIC_H_
 
 #include <drm/drm_crtc.h>
+#include <drm/drm_util.h>
 
 /**
  * struct drm_crtc_commit - track modeset commits on a CRTC

commit b13cc8dd588434e2aec781e6d12224e4c408ac18
Author: Brian Starkey <brian.starkey@arm.com>
Date:   Wed Mar 29 17:42:33 2017 +0100

    drm: writeback: Add out-fences for writeback connectors
    
    Add the WRITEBACK_OUT_FENCE_PTR property to writeback connectors, to
    enable userspace to get a fence which will signal once the writeback is
    complete. It is not allowed to request an out-fence without a
    framebuffer attached to the connector.
    
    A timeline is added to drm_writeback_connector for use by the writeback
    out-fences.
    
    In the case of a commit failure or DRM_MODE_ATOMIC_TEST_ONLY, the fence
    is set to -1.
    
    Changes from v2:
     - Rebase onto Gustavo Padovan's v9 explicit sync series
     - Change out_fence_ptr type to s32 __user *
     - Set *out_fence_ptr to -1 in drm_atomic_connector_set_property
     - Store fence in drm_writeback_job
     Gustavo Padovan:
     - Move out_fence_ptr out of connector_state
     - Signal fence from drm_writeback_signal_completion instead of
       in driver directly
    
    Changes from v3:
     - Rebase onto commit 7e9081c5aac7 ("drm/fence: fix memory overwrite
       when setting out_fence fd") (change out_fence_ptr to s32 __user *,
       for real this time.)
     - Update documentation around WRITEBACK_OUT_FENCE_PTR
    
    Signed-off-by: Brian Starkey <brian.starkey@arm.com>
    [rebased and fixed conflicts]
    Signed-off-by: Mihail Atanassov <mihail.atanassov@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/229036/

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 8254521b4583..da9d95a19580 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -160,6 +160,14 @@ struct __drm_crtcs_state {
 struct __drm_connnectors_state {
 	struct drm_connector *ptr;
 	struct drm_connector_state *state, *old_state, *new_state;
+	/**
+	 * @out_fence_ptr:
+	 *
+	 * User-provided pointer which the kernel uses to return a sync_file
+	 * file descriptor. Used by writeback connectors to signal completion of
+	 * the writeback.
+	 */
+	s32 __user *out_fence_ptr;
 };
 
 struct drm_private_obj;

commit 935774cd71fe604cc8ed24adcb507d7784255672
Author: Brian Starkey <brian.starkey@arm.com>
Date:   Wed Mar 29 17:42:32 2017 +0100

    drm: Add writeback connector type
    
    Writeback connectors represent writeback engines which can write the
    CRTC output to a memory framebuffer. Add a writeback connector type and
    related support functions.
    
    Drivers should initialize a writeback connector with
    drm_writeback_connector_init() which takes care of setting up all the
    writeback-specific details on top of the normal functionality of
    drm_connector_init().
    
    Writeback connectors have a WRITEBACK_FB_ID property, used to set the
    output framebuffer, and a WRITEBACK_PIXEL_FORMATS blob used to expose the
    supported writeback formats to userspace.
    
    When a framebuffer is attached to a writeback connector with the
    WRITEBACK_FB_ID property, it is used only once (for the commit in which
    it was included), and userspace can never read back the value of
    WRITEBACK_FB_ID. WRITEBACK_FB_ID can only be set if the connector is
    attached to a CRTC.
    
    Changes since v1:
     - Added drm_writeback.c + documentation
     - Added helper to initialize writeback connector in one go
     - Added core checks
     - Squashed into a single commit
     - Dropped the client cap
     - Writeback framebuffers are no longer persistent
    
    Changes since v2:
     Daniel Vetter:
     - Subclass drm_connector to drm_writeback_connector
     - Relax check to allow CRTC to be set without an FB
     - Add some writeback_ prefixes
     - Drop PIXEL_FORMATS_SIZE property, as it was unnecessary
     Gustavo Padovan:
     - Add drm_writeback_job to handle writeback signalling centrally
    
    Changes since v3:
     - Rebased
     - Rename PIXEL_FORMATS -> WRITEBACK_PIXEL_FORMATS
    
    Chances since v4:
     - Embed a drm_encoder inside the drm_writeback_connector to
       reduce the amount of boilerplate code required from the drivers
       that are using it.
    
    Changes since v5:
     - Added Rob Clark's atomic_commit() vfunc to connector helper
       funcs, so that writeback jobs are committed from atomic helpers
     - Updated create_writeback_properties() signature to return an
       error code rather than a boolean false for failure.
     - Free writeback job with the connector state rather than when
       doing the cleanup_work()
    
    Changes since v7:
     - fix extraneous use of out_fence that is only introduced in a
       subsequent patch.
    
    Changes since v8:
     - whitespace changes pull from subsequent patch
    
    Changes since v9:
     - Revert the v6 changes that free the writeback job in the connector
       state cleanup and return to doing it in the cleanup_work() function
    
    Signed-off-by: Brian Starkey <brian.starkey@arm.com>
    [rebased and fixed conflicts]
    Signed-off-by: Mihail Atanassov <mihail.atanassov@arm.com>
    [rebased and added atomic_commit() vfunc for writeback jobs]
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Link: https://patchwork.freedesktop.org/patch/229037/

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index ca461b6cf71f..8254521b4583 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -594,6 +594,9 @@ void drm_atomic_set_fence_for_plane(struct drm_plane_state *plane_state,
 int __must_check
 drm_atomic_set_crtc_for_connector(struct drm_connector_state *conn_state,
 				  struct drm_crtc *crtc);
+int drm_atomic_set_writeback_fb_for_connector(
+		struct drm_connector_state *conn_state,
+		struct drm_framebuffer *fb);
 int __must_check
 drm_atomic_add_affected_connectors(struct drm_atomic_state *state,
 				   struct drm_crtc *crtc);

commit e00fb8564ee98c5c3a72c74b1a27e441abff6cca
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri May 25 21:50:45 2018 +0300

    drm: Stop updating plane->crtc/fb/old_fb on atomic drivers
    
    Stop playing around with plane->crtc/fb/old_fb with atomic
    drivers. Make life a lot simpler when we don't have to do the
    magic old_fb vs. fb dance around plane updates. That way we
    can't risk plane->fb getting out of sync with plane->state->fb
    and we're less likely to leak any refcounts as well.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180525185045.29689-14-ville.syrjala@linux.intel.com
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index a57a8aa90ffb..ca461b6cf71f 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -601,9 +601,6 @@ int __must_check
 drm_atomic_add_affected_planes(struct drm_atomic_state *state,
 			       struct drm_crtc *crtc);
 
-void
-drm_atomic_clean_old_fb(struct drm_device *dev, unsigned plane_mask, int ret);
-
 int __must_check drm_atomic_check_only(struct drm_atomic_state *state);
 int __must_check drm_atomic_commit(struct drm_atomic_state *state);
 int __must_check drm_atomic_nonblocking_commit(struct drm_atomic_state *state);

commit 0b8eeac5c6ca6dcb19cce04bf8910006ac73dbd3
Merge: 62ccb6533920 60beeccc72ca
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Mar 14 10:59:16 2018 +1000

    Merge tag 'drm-misc-next-2018-03-09-3' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for 4.17:
    
    UAPI Changes:
     plane: Add color encoding/range properties (Jyri)
     nouveau: Replace iturbt_709 property with color_encoding property (Ville)
    
    Core Changes:
     atomic: Move plane clipping into plane check helper (Ville)
     property: Multiple new property checks/verification (Ville)
    
    Driver Changes:
     rockchip: Fixes & improvements for rk3399/chromebook plus (various)
     sun4i: Add H3/H5 HDMI support (Jernej)
     i915: Add support for limited/full-range ycbcr toggling (Ville)
     pl111: Add bandwidth checking/limiting (Linus)
    
    Cc: Jernej Skrabec <jernej.skrabec@siol.net>
    Cc: Jyri Sarha <jsarha@ti.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    
    * tag 'drm-misc-next-2018-03-09-3' of git://anongit.freedesktop.org/drm/drm-misc: (85 commits)
      drm/rockchip: Don't use atomic constructs for psr
      drm/rockchip: analogix_dp: set psr activate/deactivate when enable/disable bridge
      drm/rockchip: dw_hdmi: Move HDMI vpll clock enable to bind()
      drm/rockchip: inno_hdmi: reorder clk_disable_unprepare call in unbind
      drm/rockchip: inno_hdmi: Fix error handling path.
      drm/rockchip: dw-mipi-dsi: Fix connector and encoder cleanup.
      drm/nouveau: Replace the iturbt_709 prop with the standard COLOR_ENCODING prop
      drm/pl111: Use max memory bandwidth for resolution
      drm/bridge: sii902x: Retry status read after DDI I2C
      drm/pl111: Handle the RealView variant separately
      drm/pl111: Make the default BPP a per-variant variable
      drm: simple_kms_helper: Fix .mode_valid() documentation
      bridge: Elaborate a bit on dumb VGA bridges in Kconfig
      drm/atomic: Add new reverse iterator over all plane state (V2)
      drm: Reject bad property flag combinations
      drm: Make property flags u32
      drm/uapi: Deprecate DRM_MODE_PROP_PENDING
      drm: WARN when trying to add enum value > 63 to a bitmask property
      drm: WARN when trying add enum values to non-enum/bitmask properties
      drm: Reject replacing property enum values
      ...

commit 55de2923847c3318459758931ff175996facce69
Author: Shirish S <Shirish.S@amd.com>
Date:   Wed Mar 7 08:40:03 2018 +0530

    drm/atomic: Add new reverse iterator over all plane state (V2)
    
    Add reverse iterator for_each_oldnew_plane_in_state_reverse to
    compliment the for_each_oldnew_plane_in_state way or reading plane
    states.
    
    The plane states are required to be read in reverse order for
    amd drivers, cause the z order convention followed in linux is
    opposite to how the planes are supposed to be presented to DC
    engine, which is in common to both windows and linux.
    
    V2: fix compile time errors due to -Werror flag.
    
    Signed-off-by: Shirish S <shirish.s@amd.com>
    Signed-off-by: Pratik Vishwakarma <Pratik.Vishwakarma@amd.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/1520392203-6885-1-git-send-email-shirish.s@amd.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index cf13842a6dbd..3fe8dde320e5 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -753,6 +753,28 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 			      (old_plane_state) = (__state)->planes[__i].old_state,\
 			      (new_plane_state) = (__state)->planes[__i].new_state, 1))
 
+/**
+ * for_each_oldnew_plane_in_state_reverse - iterate over all planes in an atomic
+ * update in reverse order
+ * @__state: &struct drm_atomic_state pointer
+ * @plane: &struct drm_plane iteration cursor
+ * @old_plane_state: &struct drm_plane_state iteration cursor for the old state
+ * @new_plane_state: &struct drm_plane_state iteration cursor for the new state
+ * @__i: int iteration cursor, for macro-internal use
+ *
+ * This iterates over all planes in an atomic update in reverse order,
+ * tracking both old and  new state. This is useful in places where the
+ * state delta needs to be considered, for example in atomic check functions.
+ */
+#define for_each_oldnew_plane_in_state_reverse(__state, plane, old_plane_state, new_plane_state, __i) \
+	for ((__i) = ((__state)->dev->mode_config.num_total_plane - 1);	\
+	     (__i) >= 0;						\
+	     (__i)--)							\
+		for_each_if ((__state)->planes[__i].ptr &&		\
+			     ((plane) = (__state)->planes[__i].ptr,	\
+			      (old_plane_state) = (__state)->planes[__i].old_state,\
+			      (new_plane_state) = (__state)->planes[__i].new_state, 1))
+
 /**
  * for_each_old_plane_in_state - iterate over all planes in an atomic update
  * @__state: &struct drm_atomic_state pointer

commit f073d78eeb8efd85718e611c15f9a78647751dea
Merge: 0feeb106c795 fed8165851e2
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Mar 1 14:07:22 2018 +1000

    Merge tag 'drm-intel-next-2018-02-21' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    Driver Changes:
    
    - Lift alpha_support protection from Cannonlake (Rodrigo)
            * Meaning the driver should mostly work for the hardware we had
              at our disposal when testing
            * Used to be preliminary_hw_support
    - Add missing Cannonlake PCI device ID of 0x5A4C (Rodrigo)
    - Cannonlake port register fix (Mahesh)
    
    - Fix Dell Venue 8 Pro black screen after modeset (Hans)
    - Fix for always returning zero out-fence from execbuf (Daniele)
    - Fix HDMI audio when no no relevant video output is active (Jani)
    - Fix memleak of VBT data on driver_unload (Hans)
    
    - Fix for KASAN found locking issue (Maarten)
    - RCU barrier consolidation to improve igt/gem_sync/idle (Chris)
    - Optimizations to IRQ handlers (Chris)
    - vblank tracking improvements (64-bit resolution, PM) (Dhinakaran)
    - Pipe select bit corrections (Ville)
    - Reduce runtime computed device_info fields (Chris)
    - Tune down some WARN_ONs to GEM_BUG_ON now that CI has good coverage (Chris)
    - A bunch of kerneldoc warning fixes (Chris)
    
    * tag 'drm-intel-next-2018-02-21' of git://anongit.freedesktop.org/drm/drm-intel: (113 commits)
      drm/i915: Update DRIVER_DATE to 20180221
      drm/i915/fbc: Use PLANE_HAS_FENCE to determine if the plane is fenced
      drm/i915/fbdev: Use the PLANE_HAS_FENCE flags from the time of pinning
      drm/i915: Move the policy for placement of the GGTT vma into the caller
      drm/i915: Also check view->type for a normal GGTT view
      drm/i915: Drop WaDoubleCursorLP3Latency:ivb
      drm/i915: Set the primary plane pipe select bits on gen4
      drm/i915: Don't set cursor pipe select bits on g4x+
      drm/i915: Assert that we don't overflow frontbuffer tracking bits
      drm/i915: Track number of pending freed objects
      drm/i915/: Initialise trans_min for skl_compute_transition_wm()
      drm/i915: Clear the in-use marker on execbuf failure
      drm/i915: Prune gen8_gt_irq_handler
      drm/i915: Track GT interrupt handling using the master iir
      drm/i915: Remove WARN_ONCE for failing to pm_runtime_if_in_use
      drm: intel_dpio_phy: fix kernel-doc comments at nested struct
      drm/i915: Release connector iterator on a digital port conflict.
      drm/i915/execlists: Remove too early assert
      drm/i915: Assert that we always complete a submission to guc/execlists
      drm: move read_domains and write_domain into i915
      ...

commit f4c0468e4bd64b7cd00e2db309925728fc72bf8b
Author: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
Date:   Fri Feb 2 21:12:59 2018 -0800

    drm/atomic: Handle 64-bit return from drm_crtc_vblank_count()
    
    570e86963a51 ("drm: Widen vblank count to 64-bits [v3]") changed the
    return type for drm_crtc_vblank_count() to u64.
    
    The flip ioctl receives a 32-bit target sequence from user space and is
    compared against the current sequence from drm_crtc_vblank_count(). So,
    typecast return from drm_crtc_vblank_count() explicitly to add clarity.
    
    __drm_crtcs_state.last_vblank_count however only ever stores the value from
    drm_crtc_vblank_count() and can be upgraded to u64.
    
    Cc: Keith Packard <keithp@keithp.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Reviewed-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180203051302.9974-7-dhinakaran.pandiyan@intel.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 1c27526c499e..6649baa19b65 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -145,7 +145,7 @@ struct __drm_crtcs_state {
 	struct drm_crtc *ptr;
 	struct drm_crtc_state *state, *old_state, *new_state;
 	s32 __user *out_fence_ptr;
-	unsigned last_vblank_count;
+	u64 last_vblank_count;
 };
 
 struct __drm_connnectors_state {

commit 1c6ceeee6ebbcdf9839dbce00719162591180524
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Wed Jan 17 12:51:08 2018 +0100

    drm/atomic: Fix memleak on ERESTARTSYS during non-blocking commits
    
    During a non-blocking commit, it is possible to return before the
    commit_tail work is queued (-ERESTARTSYS, for example).
    
    Since a reference on the crtc commit object is obtained for the pending
    vblank event when preparing the commit, the above situation will leave
    us with an extra reference.
    
    Therefore, if the commit_tail worker has not consumed the event at the
    end of a commit, release it's reference.
    
    Changes since v1:
    - Also check for state->event->base.completion being set, to
      handle the case where stall_checks() fails in setup_crtc_commit().
    Changes since v2:
    - Add a flag to drm_crtc_commit, to prevent dereferencing a freed event.
      i915 may unreference the state in a worker.
    
    Fixes: 24835e442f28 ("drm: reference count event->completion")
    Cc: <stable@vger.kernel.org> # v4.11+
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com> #v1
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180117115108.29608-1-maarten.lankhorst@linux.intel.com
    Reviewed-by: Sean Paul <seanpaul@chromium.org>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 1c27526c499e..cf13842a6dbd 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -134,6 +134,15 @@ struct drm_crtc_commit {
 	 * &drm_pending_vblank_event pointer to clean up private events.
 	 */
 	struct drm_pending_vblank_event *event;
+
+	/**
+	 * @abort_completion:
+	 *
+	 * A flag that's set after drm_atomic_helper_setup_commit takes a second
+	 * reference for the completion of $drm_crtc_state.event. It's used by
+	 * the free code to remove the second reference if commit fails.
+	 */
+	bool abort_completion;
 };
 
 struct __drm_planes_state {

commit 5fca5ece6af8dd507c0459262766369e057e6d60
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Dec 14 21:30:54 2017 +0100

    drm/doc: Move legacy kms helpers to the very end
    
    We don't want people to accidentally stumble over there.
    
    Also rename the plane helpers to legacy plane helpers. After Ville's
    patch to make the clipping helper atomic and move it to
    drm_atomic_helper.c there's nothing left in there that should be
    useful for modern drivers.
    
    v2: Laurent had a few questions around how state is added to
    drm_atomic_state, tried to clarify that. And spotted another sentence
    where the docs suggested subclassing.
    
    v3: Small polish (Alex).
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171214203054.20141-6-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 22b60075142e..1c27526c499e 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -246,6 +246,10 @@ struct __drm_private_objs_state {
  * @num_private_objs: size of the @private_objs array
  * @private_objs: pointer to array of private object pointers
  * @acquire_ctx: acquire context for this atomic modeset state update
+ *
+ * States are added to an atomic update by calling drm_atomic_get_crtc_state(),
+ * drm_atomic_get_plane_state(), drm_atomic_get_connector_state(), or for
+ * private state structures, drm_atomic_get_private_obj_state().
  */
 struct drm_atomic_state {
 	struct kref ref;

commit da6c05969785a0f4108a089ef33c55f46ae21775
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Dec 14 21:30:53 2017 +0100

    drm/atomic: document how to handle driver private objects
    
    DK put some nice docs into the commit introducing driver private
    state, but in the git history alone it'll be lost.
    
    Also, since Ville remove the void* usage it's a good opportunity to
    give the driver private stuff some tlc on the doc front.
    
    Finally try to explain why the "let's just subclass drm_atomic_state"
    approach wasn't the greatest, and annotate all those functions as
    deprecated in favour of more standardized driver private states. Also
    note where we could/should extend driver private states going forward
    (atm neither locking nor synchronization is handled in core/helpers,
    which isn't really all that great).
    
    v2: Spelling and phrasing improvements (Alex, DK).
    
    Cc: Harry Wentland <harry.wentland@amd.com>
    Cc: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Reviewed-by: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171214203054.20141-5-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 5afd6e364fb6..22b60075142e 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -189,12 +189,40 @@ struct drm_private_state_funcs {
 				     struct drm_private_state *state);
 };
 
+/**
+ * struct drm_private_obj - base struct for driver private atomic object
+ *
+ * A driver private object is initialized by calling
+ * drm_atomic_private_obj_init() and cleaned up by calling
+ * drm_atomic_private_obj_fini().
+ *
+ * Currently only tracks the state update functions and the opaque driver
+ * private state itself, but in the future might also track which
+ * &drm_modeset_lock is required to duplicate and update this object's state.
+ */
 struct drm_private_obj {
+	/**
+	 * @state: Current atomic state for this driver private object.
+	 */
 	struct drm_private_state *state;
 
+	/**
+	 * @funcs:
+	 *
+	 * Functions to manipulate the state of this driver private object, see
+	 * &drm_private_state_funcs.
+	 */
 	const struct drm_private_state_funcs *funcs;
 };
 
+/**
+ * struct drm_private_state - base struct for driver private object state
+ * @state: backpointer to global drm_atomic_state
+ *
+ * Currently only contains a backpointer to the overall atomic update, but in
+ * the future also might hold synchronization information similar to e.g.
+ * &drm_crtc.commit.
+ */
 struct drm_private_state {
 	struct drm_atomic_state *state;
 };

commit 331494eb51002d0ee99414e3918e06d5e9a3962d
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Wed Sep 27 10:35:32 2017 +0200

    drm/atomic: Make atomic iterators less surprising
    
    Commit 669c9215afea ("drm/atomic: Make async plane update checks work as
    intended, v2.") assumed incorrectly that if only 1 plane is matched in
    the loop, the variables will be set to that plane. In reality we reset
    them to NULL every time a new plane was iterated. This behavior is
    surprising, so fix this by making the for loops only assign the
    variables on a match.
    
    When we have not added all the planes/crtc/connector to the state, and
    there's a few NULL ones after the last one we iterated, te assumption
    is broken that the pointers will hold the values from the last loop
    iteration, which holds true for all other for_each macros we're using.
    Except of course the iterator pointer itself, but that one really is
    entirely internal.
    
    Cc: Dmitry Osipenko <digetx@gmail.com>
    Fixes: 669c9215afea ("drm/atomic: Make async plane update checks work as intended, v2.")
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170927083532.5756-2-maarten.lankhorst@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Tested-by: Dmitry Osipenko <digetx@gmail.com>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 6fae95f28e10..5afd6e364fb6 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -585,12 +585,12 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
  */
 #define for_each_oldnew_connector_in_state(__state, connector, old_connector_state, new_connector_state, __i) \
 	for ((__i) = 0;								\
-	     (__i) < (__state)->num_connector &&				\
-	     ((connector) = (__state)->connectors[__i].ptr,			\
-	     (old_connector_state) = (__state)->connectors[__i].old_state,	\
-	     (new_connector_state) = (__state)->connectors[__i].new_state, 1); 	\
-	     (__i)++)							\
-		for_each_if (connector)
+	     (__i) < (__state)->num_connector;					\
+	     (__i)++)								\
+		for_each_if ((__state)->connectors[__i].ptr &&			\
+			     ((connector) = (__state)->connectors[__i].ptr,	\
+			     (old_connector_state) = (__state)->connectors[__i].old_state,	\
+			     (new_connector_state) = (__state)->connectors[__i].new_state, 1))
 
 /**
  * for_each_old_connector_in_state - iterate over all connectors in an atomic update
@@ -606,11 +606,11 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
  */
 #define for_each_old_connector_in_state(__state, connector, old_connector_state, __i) \
 	for ((__i) = 0;								\
-	     (__i) < (__state)->num_connector &&				\
-	     ((connector) = (__state)->connectors[__i].ptr,			\
-	     (old_connector_state) = (__state)->connectors[__i].old_state, 1); 	\
-	     (__i)++)							\
-		for_each_if (connector)
+	     (__i) < (__state)->num_connector;					\
+	     (__i)++)								\
+		for_each_if ((__state)->connectors[__i].ptr &&			\
+			     ((connector) = (__state)->connectors[__i].ptr,	\
+			     (old_connector_state) = (__state)->connectors[__i].old_state, 1))
 
 /**
  * for_each_new_connector_in_state - iterate over all connectors in an atomic update
@@ -626,11 +626,11 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
  */
 #define for_each_new_connector_in_state(__state, connector, new_connector_state, __i) \
 	for ((__i) = 0;								\
-	     (__i) < (__state)->num_connector &&				\
-	     ((connector) = (__state)->connectors[__i].ptr,			\
-	     (new_connector_state) = (__state)->connectors[__i].new_state, 1); 	\
-	     (__i)++)							\
-		for_each_if (connector)
+	     (__i) < (__state)->num_connector;					\
+	     (__i)++)								\
+		for_each_if ((__state)->connectors[__i].ptr &&			\
+			     ((connector) = (__state)->connectors[__i].ptr,	\
+			     (new_connector_state) = (__state)->connectors[__i].new_state, 1))
 
 /**
  * for_each_oldnew_crtc_in_state - iterate over all CRTCs in an atomic update
@@ -646,12 +646,12 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
  */
 #define for_each_oldnew_crtc_in_state(__state, crtc, old_crtc_state, new_crtc_state, __i) \
 	for ((__i) = 0;							\
-	     (__i) < (__state)->dev->mode_config.num_crtc &&		\
-	     ((crtc) = (__state)->crtcs[__i].ptr,			\
-	     (old_crtc_state) = (__state)->crtcs[__i].old_state,	\
-	     (new_crtc_state) = (__state)->crtcs[__i].new_state, 1);	\
+	     (__i) < (__state)->dev->mode_config.num_crtc;		\
 	     (__i)++)							\
-		for_each_if (crtc)
+		for_each_if ((__state)->crtcs[__i].ptr &&		\
+			     ((crtc) = (__state)->crtcs[__i].ptr,	\
+			     (old_crtc_state) = (__state)->crtcs[__i].old_state, \
+			     (new_crtc_state) = (__state)->crtcs[__i].new_state, 1))
 
 /**
  * for_each_old_crtc_in_state - iterate over all CRTCs in an atomic update
@@ -666,11 +666,11 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
  */
 #define for_each_old_crtc_in_state(__state, crtc, old_crtc_state, __i)	\
 	for ((__i) = 0;							\
-	     (__i) < (__state)->dev->mode_config.num_crtc &&		\
-	     ((crtc) = (__state)->crtcs[__i].ptr,			\
-	     (old_crtc_state) = (__state)->crtcs[__i].old_state, 1);	\
+	     (__i) < (__state)->dev->mode_config.num_crtc;		\
 	     (__i)++)							\
-		for_each_if (crtc)
+		for_each_if ((__state)->crtcs[__i].ptr &&		\
+			     ((crtc) = (__state)->crtcs[__i].ptr,	\
+			     (old_crtc_state) = (__state)->crtcs[__i].old_state, 1))
 
 /**
  * for_each_new_crtc_in_state - iterate over all CRTCs in an atomic update
@@ -685,11 +685,11 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
  */
 #define for_each_new_crtc_in_state(__state, crtc, new_crtc_state, __i)	\
 	for ((__i) = 0;							\
-	     (__i) < (__state)->dev->mode_config.num_crtc &&		\
-	     ((crtc) = (__state)->crtcs[__i].ptr,			\
-	     (new_crtc_state) = (__state)->crtcs[__i].new_state, 1);	\
+	     (__i) < (__state)->dev->mode_config.num_crtc;		\
 	     (__i)++)							\
-		for_each_if (crtc)
+		for_each_if ((__state)->crtcs[__i].ptr &&		\
+			     ((crtc) = (__state)->crtcs[__i].ptr,	\
+			     (new_crtc_state) = (__state)->crtcs[__i].new_state, 1))
 
 /**
  * for_each_oldnew_plane_in_state - iterate over all planes in an atomic update
@@ -705,12 +705,12 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
  */
 #define for_each_oldnew_plane_in_state(__state, plane, old_plane_state, new_plane_state, __i) \
 	for ((__i) = 0;							\
-	     (__i) < (__state)->dev->mode_config.num_total_plane &&	\
-	     ((plane) = (__state)->planes[__i].ptr,			\
-	     (old_plane_state) = (__state)->planes[__i].old_state,	\
-	     (new_plane_state) = (__state)->planes[__i].new_state, 1);	\
+	     (__i) < (__state)->dev->mode_config.num_total_plane;	\
 	     (__i)++)							\
-		for_each_if (plane)
+		for_each_if ((__state)->planes[__i].ptr &&		\
+			     ((plane) = (__state)->planes[__i].ptr,	\
+			      (old_plane_state) = (__state)->planes[__i].old_state,\
+			      (new_plane_state) = (__state)->planes[__i].new_state, 1))
 
 /**
  * for_each_old_plane_in_state - iterate over all planes in an atomic update
@@ -725,12 +725,11 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
  */
 #define for_each_old_plane_in_state(__state, plane, old_plane_state, __i) \
 	for ((__i) = 0;							\
-	     (__i) < (__state)->dev->mode_config.num_total_plane &&	\
-	     ((plane) = (__state)->planes[__i].ptr,			\
-	     (old_plane_state) = (__state)->planes[__i].old_state, 1);	\
+	     (__i) < (__state)->dev->mode_config.num_total_plane;	\
 	     (__i)++)							\
-		for_each_if (plane)
-
+		for_each_if ((__state)->planes[__i].ptr &&		\
+			     ((plane) = (__state)->planes[__i].ptr,	\
+			      (old_plane_state) = (__state)->planes[__i].old_state, 1))
 /**
  * for_each_new_plane_in_state - iterate over all planes in an atomic update
  * @__state: &struct drm_atomic_state pointer
@@ -744,11 +743,11 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
  */
 #define for_each_new_plane_in_state(__state, plane, new_plane_state, __i) \
 	for ((__i) = 0;							\
-	     (__i) < (__state)->dev->mode_config.num_total_plane &&	\
-	     ((plane) = (__state)->planes[__i].ptr,			\
-	     (new_plane_state) = (__state)->planes[__i].new_state, 1);	\
+	     (__i) < (__state)->dev->mode_config.num_total_plane;	\
 	     (__i)++)							\
-		for_each_if (plane)
+		for_each_if ((__state)->planes[__i].ptr &&		\
+			     ((plane) = (__state)->planes[__i].ptr,	\
+			      (new_plane_state) = (__state)->planes[__i].new_state, 1))
 
 /**
  * for_each_oldnew_private_obj_in_state - iterate over all private objects in an atomic update

commit f0d2e86c1b9ecd9cbe967b94e2f0d197f30cb3e7
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Wed Sep 27 10:35:31 2017 +0200

    drm/atomic: Remove unneeded null check for private objects
    
    It can be seen in drm_atomic_get_private_obj_state() that
    ptr will never be NULL, so skip the check for that case.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170927083532.5756-1-maarten.lankhorst@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 5834580d75bc..6fae95f28e10 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -768,8 +768,7 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 		     ((obj) = (__state)->private_objs[__i].ptr, \
 		      (old_obj_state) = (__state)->private_objs[__i].old_state,	\
 		      (new_obj_state) = (__state)->private_objs[__i].new_state, 1); \
-	     (__i)++) \
-		for_each_if (obj)
+	     (__i)++)
 
 /**
  * for_each_old_private_obj_in_state - iterate over all private objects in an atomic update
@@ -787,8 +786,7 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i) < (__state)->num_private_objs && \
 		     ((obj) = (__state)->private_objs[__i].ptr, \
 		      (old_obj_state) = (__state)->private_objs[__i].old_state, 1); \
-	     (__i)++) \
-		for_each_if (obj)
+	     (__i)++)
 
 /**
  * for_each_new_private_obj_in_state - iterate over all private objects in an atomic update
@@ -806,8 +804,7 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i) < (__state)->num_private_objs && \
 		     ((obj) = (__state)->private_objs[__i].ptr, \
 		      (new_obj_state) = (__state)->private_objs[__i].new_state, 1); \
-	     (__i)++) \
-		for_each_if (obj)
+	     (__i)++)
 
 /**
  * drm_atomic_crtc_needs_modeset - compute combined modeset need

commit 77ac3b00b13185741effd0d5e2f1f05e4bfef7dc
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Wed Jul 19 16:39:20 2017 +0200

    drm/atomic: Remove deprecated accessor macros
    
    Now that the last users have been converted, we can finally get rid of
    for_each_obj_in_state, we have better macros to replace them with.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: David Airlie <airlied@linux.ie>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170719143920.25685-8-maarten.lankhorst@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 07a71daa3582..5834580d75bc 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -569,31 +569,6 @@ int __must_check drm_atomic_nonblocking_commit(struct drm_atomic_state *state);
 
 void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 
-/**
- * for_each_connector_in_state - iterate over all connectors in an atomic update
- * @__state: &struct drm_atomic_state pointer
- * @connector: &struct drm_connector iteration cursor
- * @connector_state: &struct drm_connector_state iteration cursor
- * @__i: int iteration cursor, for macro-internal use
- *
- * This iterates over all connectors in an atomic update. Note that before the
- * software state is committed (by calling drm_atomic_helper_swap_state(), this
- * points to the new state, while afterwards it points to the old state. Due to
- * this tricky confusion this macro is deprecated.
- *
- * FIXME:
- *
- * Replace all usage of this with one of the explicit iterators below and then
- * remove this macro.
- */
-#define for_each_connector_in_state(__state, connector, connector_state, __i) \
-	for ((__i) = 0;							\
-	     (__i) < (__state)->num_connector &&				\
-	     ((connector) = (__state)->connectors[__i].ptr,			\
-	     (connector_state) = (__state)->connectors[__i].state, 1); 	\
-	     (__i)++)							\
-		for_each_if (connector)
-
 /**
  * for_each_oldnew_connector_in_state - iterate over all connectors in an atomic update
  * @__state: &struct drm_atomic_state pointer
@@ -657,31 +632,6 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)							\
 		for_each_if (connector)
 
-/**
- * for_each_crtc_in_state - iterate over all CRTCs in an atomic update
- * @__state: &struct drm_atomic_state pointer
- * @crtc: &struct drm_crtc iteration cursor
- * @crtc_state: &struct drm_crtc_state iteration cursor
- * @__i: int iteration cursor, for macro-internal use
- *
- * This iterates over all CRTCs in an atomic update. Note that before the
- * software state is committed (by calling drm_atomic_helper_swap_state(), this
- * points to the new state, while afterwards it points to the old state. Due to
- * this tricky confusion this macro is deprecated.
- *
- * FIXME:
- *
- * Replace all usage of this with one of the explicit iterators below and then
- * remove this macro.
- */
-#define for_each_crtc_in_state(__state, crtc, crtc_state, __i)	\
-	for ((__i) = 0;						\
-	     (__i) < (__state)->dev->mode_config.num_crtc &&	\
-	     ((crtc) = (__state)->crtcs[__i].ptr,			\
-	     (crtc_state) = (__state)->crtcs[__i].state, 1);	\
-	     (__i)++)						\
-		for_each_if (crtc_state)
-
 /**
  * for_each_oldnew_crtc_in_state - iterate over all CRTCs in an atomic update
  * @__state: &struct drm_atomic_state pointer
@@ -741,31 +691,6 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)							\
 		for_each_if (crtc)
 
-/**
- * for_each_plane_in_state - iterate over all planes in an atomic update
- * @__state: &struct drm_atomic_state pointer
- * @plane: &struct drm_plane iteration cursor
- * @plane_state: &struct drm_plane_state iteration cursor
- * @__i: int iteration cursor, for macro-internal use
- *
- * This iterates over all planes in an atomic update. Note that before the
- * software state is committed (by calling drm_atomic_helper_swap_state(), this
- * points to the new state, while afterwards it points to the old state. Due to
- * this tricky confusion this macro is deprecated.
- *
- * FIXME:
- *
- * Replace all usage of this with one of the explicit iterators below and then
- * remove this macro.
- */
-#define for_each_plane_in_state(__state, plane, plane_state, __i)		\
-	for ((__i) = 0;							\
-	     (__i) < (__state)->dev->mode_config.num_total_plane &&	\
-	     ((plane) = (__state)->planes[__i].ptr,				\
-	     (plane_state) = (__state)->planes[__i].state, 1);		\
-	     (__i)++)							\
-		for_each_if (plane_state)
-
 /**
  * for_each_oldnew_plane_in_state - iterate over all planes in an atomic update
  * @__state: &struct drm_atomic_state pointer

commit 21a01abbe32a3cbeb903378a24e504bfd9fe0648
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Mon Sep 4 12:48:37 2017 +0200

    drm/atomic: Fix freeing connector/plane state too early by tracking commits, v3.
    
    Currently we neatly track the crtc state, but forget to look at
    plane/connector state.
    
    When doing a nonblocking modeset, immediately followed by a setprop
    before the modeset completes, the setprop will see the modesets new
    state as the old state and free it.
    
    This has to be solved by waiting for hw_done on the connector, even
    if it's not assigned to a crtc. When a connector is unbound we take
    the last crtc commit, and when it stays unbound we create a new
    fake crtc commit for that gets signaled on hw_done for all the
    planes/connectors.
    
    We wait for it the same way as we do for crtc's, which will make
    sure we never run into a use-after-free situation.
    
    Changes since v1:
    - Only create a single disable commit. (danvet)
    - Fix leak in intel_legacy_cursor_update.
    Changes since v2:
    - Make reference counting in drm_atomic_helper_setup_commit
      more obvious. (pinchartl)
    - Call cleanup_done for fake commit. (danvet)
    - Add comments to drm_atomic_helper_setup_commit. (danvet, pinchartl)
    - Add comment to drm_atomic_helper_swap_state. (pinchartl)
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Testcase: kms_atomic_transition.plane-use-after-nonblocking-unbind*
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170904104838.23822-6-maarten.lankhorst@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index a80a8dadef00..07a71daa3582 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -235,6 +235,18 @@ struct drm_atomic_state {
 
 	struct drm_modeset_acquire_ctx *acquire_ctx;
 
+	/**
+	 * @fake_commit:
+	 *
+	 * Used for signaling unbound planes/connectors.
+	 * When a connector or plane is not bound to any CRTC, it's still important
+	 * to preserve linearity to prevent the atomic states from being freed to early.
+	 *
+	 * This commit (if set) is not bound to any crtc, but will be completed when
+	 * drm_atomic_helper_commit_hw_done() is called.
+	 */
+	struct drm_crtc_commit *fake_commit;
+
 	/**
 	 * @commit_work:
 	 *

commit 163bcc2c74a22c891c1906e6e343e28a70a54978
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Mon Sep 4 17:04:56 2017 +0200

    drm/atomic: Move drm_crtc_commit to drm_crtc_state, v4.
    
    Most code only cares about the current commit or previous commit.
    Fortuantely we already have a place to track those. Move it to
    drm_crtc_state where it belongs. :)
    
    The per-crtc commit_list is kept for places where we have to look
    deeper than the current or previous commit for checking whether to stall
    on unpin. This is used in drm_atomic_helper_setup_commit and
    intel_has_pending_fb_unpin.
    
    Changes since v1:
    - Update kerneldoc for drm_crtc.commit_list. (danvet)
    Changes since v2:
    - Remove drm_atomic_helper_async_check hunk. (pinchartl)
    Changes since v3:
    - Fix use-after-free in drm_atomic_helper_commit_cleanup_done().
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170904150456.31049-1-maarten.lankhorst@linux.intel.com
    [mlankhorst: preceeding -> preceding (checkpatch)]

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index c0451e2a51af..a80a8dadef00 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -144,7 +144,6 @@ struct __drm_planes_state {
 struct __drm_crtcs_state {
 	struct drm_crtc *ptr;
 	struct drm_crtc_state *state, *old_state, *new_state;
-	struct drm_crtc_commit *commit;
 	s32 __user *out_fence_ptr;
 	unsigned last_vblank_count;
 };

commit f46640b931e588aeec5285b4a9547b354ad10cd0
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Mon Sep 4 12:48:36 2017 +0200

    drm/atomic: Return commit in drm_crtc_commit_get for better annotation
    
    This will allow code to do x->commit = drm_crtc_commit_get(commit),
    making it clearer where references are used.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170904104838.23822-5-maarten.lankhorst@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index f73b663c1f76..c0451e2a51af 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -252,10 +252,14 @@ void __drm_crtc_commit_free(struct kref *kref);
  * @commit: CRTC commit
  *
  * Increases the reference of @commit.
+ *
+ * Returns:
+ * The pointer to @commit, with reference increased.
  */
-static inline void drm_crtc_commit_get(struct drm_crtc_commit *commit)
+static inline struct drm_crtc_commit *drm_crtc_commit_get(struct drm_crtc_commit *commit)
 {
 	kref_get(&commit->ref);
+	return commit;
 }
 
 /**

commit 46ad42a3756d5e2078ed05bc99aa197815afac5d
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Sep 1 16:40:42 2017 +0200

    drm/atomic: Fix typo in kerneldoc
    
    The for_each_crtc_in_state() is used to iterate over CRTCs rather than
    connectors.
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170901144042.6023-2-thierry.reding@gmail.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 8a5808eb5628..f73b663c1f76 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -643,7 +643,7 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 		for_each_if (connector)
 
 /**
- * for_each_crtc_in_state - iterate over all connectors in an atomic update
+ * for_each_crtc_in_state - iterate over all CRTCs in an atomic update
  * @__state: &struct drm_atomic_state pointer
  * @crtc: &struct drm_crtc iteration cursor
  * @crtc_state: &struct drm_crtc_state iteration cursor

commit 16fece0153d5b6573c3fcb8cfbe483f83ca8eb01
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jul 25 10:01:22 2017 +0200

    drm: Nuke drm_atomic_legacy_backoff
    
    Finally all users are gone!
    
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170725080122.20548-9-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 711617fdf032..8a5808eb5628 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -545,8 +545,6 @@ int __must_check
 drm_atomic_add_affected_planes(struct drm_atomic_state *state,
 			       struct drm_crtc *crtc);
 
-void drm_atomic_legacy_backoff(struct drm_atomic_state *state);
-
 void
 drm_atomic_clean_old_fb(struct drm_device *dev, unsigned plane_mask, int ret);
 

commit 482b0e3c2fd73b5c27a4459638b682147ce8119e
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jul 25 10:01:20 2017 +0200

    drm: Nuke drm_atomic_helper_connector_set_property
    
    It's dead code, the core handles all this directly now. This also
    allows us to unexport drm_atomic_helper_connector_set_property.
    
    The only special case is nouveau which used one function for both
    pre-nv50 legacy modeset code and post-nv50 atomic world instead of 2
    vtables. But amounts to exactly the same.
    
    What is rather strange here is how few drivers set this up, I suspect
    the earlier patch to handle properties in the core did end up fixing a
    pile of possible issues.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Vincent Abriou <vincent.abriou@st.com>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: intel-gfx@lists.freedesktop.org
    Cc: nouveau@lists.freedesktop.org
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170725080122.20548-7-daniel.vetter@ffwll.ch
    Acked-by: Vincent Abriou <vincent.abriou@st.com>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 7d0d110f911d..711617fdf032 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -318,9 +318,6 @@ drm_atomic_get_plane_state(struct drm_atomic_state *state,
 struct drm_connector_state * __must_check
 drm_atomic_get_connector_state(struct drm_atomic_state *state,
 			       struct drm_connector *connector);
-int drm_atomic_connector_set_property(struct drm_connector *connector,
-		struct drm_connector_state *state, struct drm_property *property,
-		uint64_t val);
 
 void drm_atomic_private_obj_init(struct drm_private_obj *obj,
 				 struct drm_private_state *state,

commit e90271bc07edde70945662aaaad8860d59712234
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jul 25 10:01:19 2017 +0200

    drm: Nuke drm_atomic_helper_plane_set_property
    
    It's dead code, the core handles all this directly now. This also
    allows us to unexport drm_atomic_plane_set_property.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Brian Starkey <brian.starkey@arm.com>
    Cc: Mali DP Maintainers <malidp@foss.arm.com>
    Cc: Boris Brezillon <boris.brezillon@free-electrons.com>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Joonyoung Shim <jy0922.shim@samsung.com>
    Cc: Seung-Woo Kim <sw0312.kim@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Vincent Abriou <vincent.abriou@st.com>
    Cc: Yannick Fertre <yannick.fertre@st.com>
    Cc: Philippe Cornu <philippe.cornu@st.com>
    Cc: Jyri Sarha <jsarha@ti.com>
    Cc: "Ville Syrjälä" <ville.syrjala@linux.intel.com>
    Cc: Rongrong Zou <zourongrong@gmail.com>
    Cc: Shawn Guo <shawn.guo@linaro.org>
    Cc: Alexey Brodkin <abrodkin@synopsys.com>
    Cc: Eric Engestrom <eric@engestrom.ch>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Archit Taneja <architt@codeaurora.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: nouveau@lists.freedesktop.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170725080122.20548-6-daniel.vetter@ffwll.ch
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Acked-by: Philippe Cornu <philippe.cornu@st.com>
    Tested-by: Philippe Cornu <philippe.cornu@st.com>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Acked-by: Vincent Abriou <vincent.abriou@st.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index a7adbf57b886..7d0d110f911d 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -315,9 +315,6 @@ int drm_atomic_crtc_set_property(struct drm_crtc *crtc,
 struct drm_plane_state * __must_check
 drm_atomic_get_plane_state(struct drm_atomic_state *state,
 			   struct drm_plane *plane);
-int drm_atomic_plane_set_property(struct drm_plane *plane,
-		struct drm_plane_state *state, struct drm_property *property,
-		uint64_t val);
 struct drm_connector_state * __must_check
 drm_atomic_get_connector_state(struct drm_atomic_state *state,
 			       struct drm_connector *connector);

commit 96bf51df6a90fc62de973ba7a9762d4150f26b94
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Jul 31 11:13:43 2017 +0200

    drm/atomic: Update comment to match the code
    
    The kerneldoc for drm_atomic_crtc_needs_modeset() is outdated and no
    longer reflects the actual code. Fix that up to remove confusion.
    
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170731091343.21363-1-thierry.reding@gmail.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 7cd0f303f5a3..a7adbf57b886 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -883,7 +883,7 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
  *
  * To give drivers flexibility &struct drm_crtc_state has 3 booleans to track
  * whether the state CRTC changed enough to need a full modeset cycle:
- * planes_changed, mode_changed and active_changed. This helper simply
+ * mode_changed, active_changed and connectors_changed. This helper simply
  * combines these three to compute the overall need for a modeset for @state.
  *
  * The atomic helper code sets these booleans, but drivers can and should

commit a4370c777406c2810e37fafd166ccddecdb2a60c
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Jul 12 18:51:02 2017 +0300

    drm/atomic: Make private objs proper objects
    
    Make the atomic private object stuff less special by introducing proper
    base classes for the object and its state. Drivers can embed these in
    their own appropriate objects, after which these things will work
    exactly like the plane/crtc/connector states during atomic operations.
    
    v2: Reorder to not depend on drm_dynarray (Daniel)
    
    Cc: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch> #v1
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170712155102.26276-3-ville.syrjala@linux.intel.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index dcc8e0cdb7ff..7cd0f303f5a3 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -154,6 +154,9 @@ struct __drm_connnectors_state {
 	struct drm_connector_state *state, *old_state, *new_state;
 };
 
+struct drm_private_obj;
+struct drm_private_state;
+
 /**
  * struct drm_private_state_funcs - atomic state functions for private objects
  *
@@ -166,7 +169,7 @@ struct __drm_connnectors_state {
  */
 struct drm_private_state_funcs {
 	/**
-	 * @duplicate_state:
+	 * @atomic_duplicate_state:
 	 *
 	 * Duplicate the current state of the private object and return it. It
 	 * is an error to call this before obj->state has been initialized.
@@ -176,29 +179,30 @@ struct drm_private_state_funcs {
 	 * Duplicated atomic state or NULL when obj->state is not
 	 * initialized or allocation failed.
 	 */
-	void *(*duplicate_state)(struct drm_atomic_state *state, void *obj);
+	struct drm_private_state *(*atomic_duplicate_state)(struct drm_private_obj *obj);
 
 	/**
-	 * @swap_state:
+	 * @atomic_destroy_state:
 	 *
-	 * This function swaps the existing state of a private object @obj with
-	 * it's newly created state, the pointer to which is passed as
-	 * @obj_state_ptr.
+	 * Frees the private object state created with @atomic_duplicate_state.
 	 */
-	void (*swap_state)(void *obj, void **obj_state_ptr);
+	void (*atomic_destroy_state)(struct drm_private_obj *obj,
+				     struct drm_private_state *state);
+};
 
-	/**
-	 * @destroy_state:
-	 *
-	 * Frees the private object state created with @duplicate_state.
-	 */
-	void (*destroy_state)(void *obj_state);
+struct drm_private_obj {
+	struct drm_private_state *state;
+
+	const struct drm_private_state_funcs *funcs;
+};
+
+struct drm_private_state {
+	struct drm_atomic_state *state;
 };
 
 struct __drm_private_objs_state {
-	void *obj;
-	void *obj_state;
-	const struct drm_private_state_funcs *funcs;
+	struct drm_private_obj *ptr;
+	struct drm_private_state *state, *old_state, *new_state;
 };
 
 /**
@@ -321,10 +325,14 @@ int drm_atomic_connector_set_property(struct drm_connector *connector,
 		struct drm_connector_state *state, struct drm_property *property,
 		uint64_t val);
 
-void * __must_check
+void drm_atomic_private_obj_init(struct drm_private_obj *obj,
+				 struct drm_private_state *state,
+				 const struct drm_private_state_funcs *funcs);
+void drm_atomic_private_obj_fini(struct drm_private_obj *obj);
+
+struct drm_private_state * __must_check
 drm_atomic_get_private_obj_state(struct drm_atomic_state *state,
-			      void *obj,
-			      const struct drm_private_state_funcs *funcs);
+				 struct drm_private_obj *obj);
 
 /**
  * drm_atomic_get_existing_crtc_state - get crtc state, if it exists
@@ -811,43 +819,63 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 		for_each_if (plane)
 
 /**
- * __for_each_private_obj - iterate over all private objects
+ * for_each_oldnew_private_obj_in_state - iterate over all private objects in an atomic update
  * @__state: &struct drm_atomic_state pointer
- * @obj: private object iteration cursor
- * @obj_state: private object state iteration cursor
+ * @obj: &struct drm_private_obj iteration cursor
+ * @old_obj_state: &struct drm_private_state iteration cursor for the old state
+ * @new_obj_state: &struct drm_private_state iteration cursor for the new state
  * @__i: int iteration cursor, for macro-internal use
- * @__funcs: &struct drm_private_state_funcs iteration cursor
  *
- * This macro iterates over the array containing private object data in atomic
- * state
+ * This iterates over all private objects in an atomic update, tracking both
+ * old and new state. This is useful in places where the state delta needs
+ * to be considered, for example in atomic check functions.
  */
-#define __for_each_private_obj(__state, obj, obj_state, __i, __funcs)	\
-	for ((__i) = 0;							\
-	     (__i) < (__state)->num_private_objs &&			\
-	     ((obj) = (__state)->private_objs[__i].obj,			\
-	      (__funcs) = (__state)->private_objs[__i].funcs,		\
-	      (obj_state) = (__state)->private_objs[__i].obj_state,	\
-	      1);							\
-	     (__i)++)							\
+#define for_each_oldnew_private_obj_in_state(__state, obj, old_obj_state, new_obj_state, __i) \
+	for ((__i) = 0; \
+	     (__i) < (__state)->num_private_objs && \
+		     ((obj) = (__state)->private_objs[__i].ptr, \
+		      (old_obj_state) = (__state)->private_objs[__i].old_state,	\
+		      (new_obj_state) = (__state)->private_objs[__i].new_state, 1); \
+	     (__i)++) \
+		for_each_if (obj)
+
+/**
+ * for_each_old_private_obj_in_state - iterate over all private objects in an atomic update
+ * @__state: &struct drm_atomic_state pointer
+ * @obj: &struct drm_private_obj iteration cursor
+ * @old_obj_state: &struct drm_private_state iteration cursor for the old state
+ * @__i: int iteration cursor, for macro-internal use
+ *
+ * This iterates over all private objects in an atomic update, tracking only
+ * the old state. This is useful in disable functions, where we need the old
+ * state the hardware is still in.
+ */
+#define for_each_old_private_obj_in_state(__state, obj, old_obj_state, __i) \
+	for ((__i) = 0; \
+	     (__i) < (__state)->num_private_objs && \
+		     ((obj) = (__state)->private_objs[__i].ptr, \
+		      (old_obj_state) = (__state)->private_objs[__i].old_state, 1); \
+	     (__i)++) \
+		for_each_if (obj)
 
 /**
- * for_each_private_obj - iterate over a specify type of private object
+ * for_each_new_private_obj_in_state - iterate over all private objects in an atomic update
  * @__state: &struct drm_atomic_state pointer
- * @obj_funcs: &struct drm_private_state_funcs function table to filter
- * 	private objects
- * @obj: private object iteration cursor
- * @obj_state: private object state iteration cursor
+ * @obj: &struct drm_private_obj iteration cursor
+ * @new_obj_state: &struct drm_private_state iteration cursor for the new state
  * @__i: int iteration cursor, for macro-internal use
- * @__funcs: &struct drm_private_state_funcs iteration cursor
  *
- * This macro iterates over the private objects state array while filtering the
- * objects based on the vfunc table that is passed as @obj_funcs. New macros
- * can be created by passing in the vfunc table associated with a specific
- * private object.
+ * This iterates over all private objects in an atomic update, tracking only
+ * the new state. This is useful in enable functions, where we need the new state the
+ * hardware should be in when the atomic commit operation has completed.
  */
-#define for_each_private_obj(__state, obj_funcs, obj, obj_state, __i, __funcs)	\
-	__for_each_private_obj(__state, obj, obj_state, __i, __funcs)		\
-		for_each_if (__funcs == obj_funcs)
+#define for_each_new_private_obj_in_state(__state, obj, new_obj_state, __i) \
+	for ((__i) = 0; \
+	     (__i) < (__state)->num_private_objs && \
+		     ((obj) = (__state)->private_objs[__i].ptr, \
+		      (new_obj_state) = (__state)->private_objs[__i].new_state, 1); \
+	     (__i)++) \
+		for_each_if (obj)
 
 /**
  * drm_atomic_crtc_needs_modeset - compute combined modeset need

commit fef9df8b594531a4257b6a3bf7e190570c17be29
Author: Gustavo Padovan <gustavo.padovan@collabora.com>
Date:   Fri Jun 30 15:03:17 2017 -0300

    drm/atomic: initial support for asynchronous plane update
    
    In some cases, like cursor updates, it is interesting to update the
    plane in an asynchronous fashion to avoid big delays. The current queued
    update could be still waiting for a fence to signal and thus block any
    subsequent update until its scan out. In cases like this if we update the
    cursor synchronously through the atomic API it will cause significant
    delays that would even be noticed by the final user.
    
    This patch creates a fast path to jump ahead the current queued state and
    do single planes updates without going through all atomic steps in
    drm_atomic_helper_commit(). We take this path for legacy cursor updates.
    
    For now only single plane updates are supported, but we plan to support
    multiple planes updates and async PageFlips through this interface as well
    in the near future.
    
    v6:     - move check code to drm_atomic_helper.c (Daniel Vetter)
    
    v5:
            - improve comments (Eric Anholt)
    
    v4:
            - fix state->crtc NULL check (Archit Taneja)
    
    v3:
            - fix iteration on the wrong crtc state
            - put back code to forbid updates if there is a queued update for
            the same plane (Ville Syrjälä)
            - move size checks back to drivers (Ville Syrjälä)
            - move ASYNC_UPDATE flag addition to its own patch (Ville Syrjälä)
    
    v2:
            - allow updates even if there is a queued update for the same
            plane.
            - fixes on the documentation (Emil Velikov)
            - unconditionally call ->atomic_async_update (Emil Velikov)
            - check for ->atomic_async_update earlier (Daniel Vetter)
            - make ->atomic_async_check() the last step (Daniel Vetter)
            - add ASYNC_UPDATE flag (Eric Anholt)
            - update state in core after ->atomic_async_update (Eric Anholt)
            - update docs (Eric Anholt)
    
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Eric Anholt <eric@anholt.net>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.com>
    Reviewed-by: Archit Taneja <architt@codeaurora.org> (v5)
    Acked-by: Eric Anholt <eric@anholt.net> (v5)
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170630180322.29007-2-gustavo@padovan.org

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 0196f264a418..dcc8e0cdb7ff 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -207,6 +207,7 @@ struct __drm_private_objs_state {
  * @dev: parent DRM device
  * @allow_modeset: allow full modeset
  * @legacy_cursor_update: hint to enforce legacy cursor IOCTL semantics
+ * @async_update: hint for asynchronous plane update
  * @planes: pointer to array of structures with per-plane data
  * @crtcs: pointer to array of CRTC pointers
  * @num_connector: size of the @connectors and @connector_states arrays
@@ -221,6 +222,7 @@ struct drm_atomic_state {
 	struct drm_device *dev;
 	bool allow_modeset : 1;
 	bool legacy_cursor_update : 1;
+	bool async_update : 1;
 	struct __drm_planes_state *planes;
 	struct __drm_crtcs_state *crtcs;
 	int num_connector;

commit 91110a4b64fe0bdbac084b79dbd5f10c458327e9
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu May 18 22:38:36 2017 +0300

    drm/atomic: Consitfy mode parameter to drm_atomic_set_mode_for_crtc()
    
    drm_atomic_set_mode_for_crtc() doesn't modify the passed mode, so let's
    make it const.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170518193837.393-1-ville.syrjala@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 8645dcdef031..0196f264a418 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -520,7 +520,7 @@ __drm_atomic_get_current_plane_state(struct drm_atomic_state *state,
 
 int __must_check
 drm_atomic_set_mode_for_crtc(struct drm_crtc_state *state,
-			     struct drm_display_mode *mode);
+			     const struct drm_display_mode *mode);
 int __must_check
 drm_atomic_set_mode_prop_for_crtc(struct drm_crtc_state *state,
 				  struct drm_property_blob *blob);

commit b430c27a7de3ccfb51b7e07b2dceba981df279ef
Author: Pandiyan, Dhinakaran <dhinakaran.pandiyan@intel.com>
Date:   Thu Apr 20 22:51:30 2017 -0700

    drm: Add driver-private objects to atomic state
    
    It is necessary to track states for objects other than connector, crtc
    and plane for atomic modesets. But adding objects like DP MST link
    bandwidth to drm_atomic_state would mean that a non-core object will be
    modified by the core helper functions for swapping and clearing
    it's state. So, lets add void * objects and helper functions that operate
    on void * types to keep these objects and states private to the core.
    Drivers can then implement specific functions to swap and clear states.
    The other advantage having just void * for these objects in
    drm_atomic_state is that objects of different types can be managed in the
    same state array.
    
    v7: Use __for_each_private_obj to define for_each_private_obj (Maarten)
    v6: More kernel-doc to keep 0-day happy
    v5: Remove more NULL checks (Maarten)
    v4: Avoid redundant NULL checks when private_objs array is empty (Maarten)
    v3: Macro alignment (Chris)
    v2: Added docs and new iterator to filter private objects (Daniel)
    
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Archit Taneja <architt@codeaurora.org>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Harry Wentland <Harry.wentland@amd.com>
    
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Suggested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1492753893-3748-2-git-send-email-dhinakaran.pandiyan@intel.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 788daf756f48..8645dcdef031 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -154,6 +154,53 @@ struct __drm_connnectors_state {
 	struct drm_connector_state *state, *old_state, *new_state;
 };
 
+/**
+ * struct drm_private_state_funcs - atomic state functions for private objects
+ *
+ * These hooks are used by atomic helpers to create, swap and destroy states of
+ * private objects. The structure itself is used as a vtable to identify the
+ * associated private object type. Each private object type that needs to be
+ * added to the atomic states is expected to have an implementation of these
+ * hooks and pass a pointer to it's drm_private_state_funcs struct to
+ * drm_atomic_get_private_obj_state().
+ */
+struct drm_private_state_funcs {
+	/**
+	 * @duplicate_state:
+	 *
+	 * Duplicate the current state of the private object and return it. It
+	 * is an error to call this before obj->state has been initialized.
+	 *
+	 * RETURNS:
+	 *
+	 * Duplicated atomic state or NULL when obj->state is not
+	 * initialized or allocation failed.
+	 */
+	void *(*duplicate_state)(struct drm_atomic_state *state, void *obj);
+
+	/**
+	 * @swap_state:
+	 *
+	 * This function swaps the existing state of a private object @obj with
+	 * it's newly created state, the pointer to which is passed as
+	 * @obj_state_ptr.
+	 */
+	void (*swap_state)(void *obj, void **obj_state_ptr);
+
+	/**
+	 * @destroy_state:
+	 *
+	 * Frees the private object state created with @duplicate_state.
+	 */
+	void (*destroy_state)(void *obj_state);
+};
+
+struct __drm_private_objs_state {
+	void *obj;
+	void *obj_state;
+	const struct drm_private_state_funcs *funcs;
+};
+
 /**
  * struct drm_atomic_state - the global state object for atomic updates
  * @ref: count of all references to this state (will not be freed until zero)
@@ -164,6 +211,8 @@ struct __drm_connnectors_state {
  * @crtcs: pointer to array of CRTC pointers
  * @num_connector: size of the @connectors and @connector_states arrays
  * @connectors: pointer to array of structures with per-connector data
+ * @num_private_objs: size of the @private_objs array
+ * @private_objs: pointer to array of private object pointers
  * @acquire_ctx: acquire context for this atomic modeset state update
  */
 struct drm_atomic_state {
@@ -176,6 +225,8 @@ struct drm_atomic_state {
 	struct __drm_crtcs_state *crtcs;
 	int num_connector;
 	struct __drm_connnectors_state *connectors;
+	int num_private_objs;
+	struct __drm_private_objs_state *private_objs;
 
 	struct drm_modeset_acquire_ctx *acquire_ctx;
 
@@ -268,6 +319,11 @@ int drm_atomic_connector_set_property(struct drm_connector *connector,
 		struct drm_connector_state *state, struct drm_property *property,
 		uint64_t val);
 
+void * __must_check
+drm_atomic_get_private_obj_state(struct drm_atomic_state *state,
+			      void *obj,
+			      const struct drm_private_state_funcs *funcs);
+
 /**
  * drm_atomic_get_existing_crtc_state - get crtc state, if it exists
  * @state: global atomic state object
@@ -752,6 +808,45 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)							\
 		for_each_if (plane)
 
+/**
+ * __for_each_private_obj - iterate over all private objects
+ * @__state: &struct drm_atomic_state pointer
+ * @obj: private object iteration cursor
+ * @obj_state: private object state iteration cursor
+ * @__i: int iteration cursor, for macro-internal use
+ * @__funcs: &struct drm_private_state_funcs iteration cursor
+ *
+ * This macro iterates over the array containing private object data in atomic
+ * state
+ */
+#define __for_each_private_obj(__state, obj, obj_state, __i, __funcs)	\
+	for ((__i) = 0;							\
+	     (__i) < (__state)->num_private_objs &&			\
+	     ((obj) = (__state)->private_objs[__i].obj,			\
+	      (__funcs) = (__state)->private_objs[__i].funcs,		\
+	      (obj_state) = (__state)->private_objs[__i].obj_state,	\
+	      1);							\
+	     (__i)++)							\
+
+/**
+ * for_each_private_obj - iterate over a specify type of private object
+ * @__state: &struct drm_atomic_state pointer
+ * @obj_funcs: &struct drm_private_state_funcs function table to filter
+ * 	private objects
+ * @obj: private object iteration cursor
+ * @obj_state: private object state iteration cursor
+ * @__i: int iteration cursor, for macro-internal use
+ * @__funcs: &struct drm_private_state_funcs iteration cursor
+ *
+ * This macro iterates over the private objects state array while filtering the
+ * objects based on the vfunc table that is passed as @obj_funcs. New macros
+ * can be created by passing in the vfunc table associated with a specific
+ * private object.
+ */
+#define for_each_private_obj(__state, obj_funcs, obj, obj_state, __i, __funcs)	\
+	__for_each_private_obj(__state, obj, obj_state, __i, __funcs)		\
+		for_each_if (__funcs == obj_funcs)
+
 /**
  * drm_atomic_crtc_needs_modeset - compute combined modeset need
  * @state: &drm_crtc_state for the CRTC

commit 44596b8c4750d9a2323f52aecdeecf34f6aaa2e0
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Thu Apr 6 13:19:00 2017 +0200

    drm/atomic: Unify conflicting encoder handling.
    
    Currently we use a flag to change behavior in atomic commit
    whether a conflicting encoder should be enabled or disabled.
    This is used for the legacy set_config helper, which disables
    connectors that have a conflicting encoder but not part of the
    active crtc list.
    
    There's no need for this to be handled in atomic commit, it
    could be done in the set_config helper instead. This will
    let the atomic check function reject any conflicting encoders,
    while set_config can disable conflicting crtc's. This makes it
    possible to recalculate the changed flags in 1 loop.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1491477543-31257-2-git-send-email-maarten.lankhorst@linux.intel.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index fd33ed5eaeb4..788daf756f48 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -160,7 +160,6 @@ struct __drm_connnectors_state {
  * @dev: parent DRM device
  * @allow_modeset: allow full modeset
  * @legacy_cursor_update: hint to enforce legacy cursor IOCTL semantics
- * @legacy_set_config: Disable conflicting encoders instead of failing with -EINVAL.
  * @planes: pointer to array of structures with per-plane data
  * @crtcs: pointer to array of CRTC pointers
  * @num_connector: size of the @connectors and @connector_states arrays
@@ -173,7 +172,6 @@ struct drm_atomic_state {
 	struct drm_device *dev;
 	bool allow_modeset : 1;
 	bool legacy_cursor_update : 1;
-	bool legacy_set_config : 1;
 	struct __drm_planes_state *planes;
 	struct __drm_crtcs_state *crtcs;
 	int num_connector;

commit f9a769555db4c5c384a1d92b471461ef95923feb
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Mar 28 17:53:49 2017 +0200

    drm: document the all the atomic iterators
    
    Mostly because I want the links from the newly-added @state functions
    to work. But I think explaining when they're useful and that the
    implicit one is deprecated is good either way. Slightly repetitive
    unfortunately.
    
    Cc: Harry Wentland <harry.wentland@amd.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170328155349.5972-3-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 0147a047878d..fd33ed5eaeb4 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -498,6 +498,23 @@ int __must_check drm_atomic_nonblocking_commit(struct drm_atomic_state *state);
 
 void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 
+/**
+ * for_each_connector_in_state - iterate over all connectors in an atomic update
+ * @__state: &struct drm_atomic_state pointer
+ * @connector: &struct drm_connector iteration cursor
+ * @connector_state: &struct drm_connector_state iteration cursor
+ * @__i: int iteration cursor, for macro-internal use
+ *
+ * This iterates over all connectors in an atomic update. Note that before the
+ * software state is committed (by calling drm_atomic_helper_swap_state(), this
+ * points to the new state, while afterwards it points to the old state. Due to
+ * this tricky confusion this macro is deprecated.
+ *
+ * FIXME:
+ *
+ * Replace all usage of this with one of the explicit iterators below and then
+ * remove this macro.
+ */
 #define for_each_connector_in_state(__state, connector, connector_state, __i) \
 	for ((__i) = 0;							\
 	     (__i) < (__state)->num_connector &&				\
@@ -506,6 +523,20 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)							\
 		for_each_if (connector)
 
+/**
+ * for_each_oldnew_connector_in_state - iterate over all connectors in an atomic update
+ * @__state: &struct drm_atomic_state pointer
+ * @connector: &struct drm_connector iteration cursor
+ * @old_connector_state: &struct drm_connector_state iteration cursor for the
+ * 	old state
+ * @new_connector_state: &struct drm_connector_state iteration cursor for the
+ * 	new state
+ * @__i: int iteration cursor, for macro-internal use
+ *
+ * This iterates over all connectors in an atomic update, tracking both old and
+ * new state. This is useful in places where the state delta needs to be
+ * considered, for example in atomic check functions.
+ */
 #define for_each_oldnew_connector_in_state(__state, connector, old_connector_state, new_connector_state, __i) \
 	for ((__i) = 0;								\
 	     (__i) < (__state)->num_connector &&				\
@@ -515,6 +546,18 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)							\
 		for_each_if (connector)
 
+/**
+ * for_each_old_connector_in_state - iterate over all connectors in an atomic update
+ * @__state: &struct drm_atomic_state pointer
+ * @connector: &struct drm_connector iteration cursor
+ * @old_connector_state: &struct drm_connector_state iteration cursor for the
+ * 	old state
+ * @__i: int iteration cursor, for macro-internal use
+ *
+ * This iterates over all connectors in an atomic update, tracking only the old
+ * state. This is useful in disable functions, where we need the old state the
+ * hardware is still in.
+ */
 #define for_each_old_connector_in_state(__state, connector, old_connector_state, __i) \
 	for ((__i) = 0;								\
 	     (__i) < (__state)->num_connector &&				\
@@ -523,6 +566,18 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)							\
 		for_each_if (connector)
 
+/**
+ * for_each_new_connector_in_state - iterate over all connectors in an atomic update
+ * @__state: &struct drm_atomic_state pointer
+ * @connector: &struct drm_connector iteration cursor
+ * @new_connector_state: &struct drm_connector_state iteration cursor for the
+ * 	new state
+ * @__i: int iteration cursor, for macro-internal use
+ *
+ * This iterates over all connectors in an atomic update, tracking only the new
+ * state. This is useful in enable functions, where we need the new state the
+ * hardware should be in when the atomic commit operation has completed.
+ */
 #define for_each_new_connector_in_state(__state, connector, new_connector_state, __i) \
 	for ((__i) = 0;								\
 	     (__i) < (__state)->num_connector &&				\
@@ -531,6 +586,23 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)							\
 		for_each_if (connector)
 
+/**
+ * for_each_crtc_in_state - iterate over all connectors in an atomic update
+ * @__state: &struct drm_atomic_state pointer
+ * @crtc: &struct drm_crtc iteration cursor
+ * @crtc_state: &struct drm_crtc_state iteration cursor
+ * @__i: int iteration cursor, for macro-internal use
+ *
+ * This iterates over all CRTCs in an atomic update. Note that before the
+ * software state is committed (by calling drm_atomic_helper_swap_state(), this
+ * points to the new state, while afterwards it points to the old state. Due to
+ * this tricky confusion this macro is deprecated.
+ *
+ * FIXME:
+ *
+ * Replace all usage of this with one of the explicit iterators below and then
+ * remove this macro.
+ */
 #define for_each_crtc_in_state(__state, crtc, crtc_state, __i)	\
 	for ((__i) = 0;						\
 	     (__i) < (__state)->dev->mode_config.num_crtc &&	\
@@ -539,6 +611,18 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)						\
 		for_each_if (crtc_state)
 
+/**
+ * for_each_oldnew_crtc_in_state - iterate over all CRTCs in an atomic update
+ * @__state: &struct drm_atomic_state pointer
+ * @crtc: &struct drm_crtc iteration cursor
+ * @old_crtc_state: &struct drm_crtc_state iteration cursor for the old state
+ * @new_crtc_state: &struct drm_crtc_state iteration cursor for the new state
+ * @__i: int iteration cursor, for macro-internal use
+ *
+ * This iterates over all CRTCs in an atomic update, tracking both old and
+ * new state. This is useful in places where the state delta needs to be
+ * considered, for example in atomic check functions.
+ */
 #define for_each_oldnew_crtc_in_state(__state, crtc, old_crtc_state, new_crtc_state, __i) \
 	for ((__i) = 0;							\
 	     (__i) < (__state)->dev->mode_config.num_crtc &&		\
@@ -548,6 +632,17 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)							\
 		for_each_if (crtc)
 
+/**
+ * for_each_old_crtc_in_state - iterate over all CRTCs in an atomic update
+ * @__state: &struct drm_atomic_state pointer
+ * @crtc: &struct drm_crtc iteration cursor
+ * @old_crtc_state: &struct drm_crtc_state iteration cursor for the old state
+ * @__i: int iteration cursor, for macro-internal use
+ *
+ * This iterates over all CRTCs in an atomic update, tracking only the old
+ * state. This is useful in disable functions, where we need the old state the
+ * hardware is still in.
+ */
 #define for_each_old_crtc_in_state(__state, crtc, old_crtc_state, __i)	\
 	for ((__i) = 0;							\
 	     (__i) < (__state)->dev->mode_config.num_crtc &&		\
@@ -556,6 +651,17 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)							\
 		for_each_if (crtc)
 
+/**
+ * for_each_new_crtc_in_state - iterate over all CRTCs in an atomic update
+ * @__state: &struct drm_atomic_state pointer
+ * @crtc: &struct drm_crtc iteration cursor
+ * @new_crtc_state: &struct drm_crtc_state iteration cursor for the new state
+ * @__i: int iteration cursor, for macro-internal use
+ *
+ * This iterates over all CRTCs in an atomic update, tracking only the new
+ * state. This is useful in enable functions, where we need the new state the
+ * hardware should be in when the atomic commit operation has completed.
+ */
 #define for_each_new_crtc_in_state(__state, crtc, new_crtc_state, __i)	\
 	for ((__i) = 0;							\
 	     (__i) < (__state)->dev->mode_config.num_crtc &&		\
@@ -564,6 +670,23 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)							\
 		for_each_if (crtc)
 
+/**
+ * for_each_plane_in_state - iterate over all planes in an atomic update
+ * @__state: &struct drm_atomic_state pointer
+ * @plane: &struct drm_plane iteration cursor
+ * @plane_state: &struct drm_plane_state iteration cursor
+ * @__i: int iteration cursor, for macro-internal use
+ *
+ * This iterates over all planes in an atomic update. Note that before the
+ * software state is committed (by calling drm_atomic_helper_swap_state(), this
+ * points to the new state, while afterwards it points to the old state. Due to
+ * this tricky confusion this macro is deprecated.
+ *
+ * FIXME:
+ *
+ * Replace all usage of this with one of the explicit iterators below and then
+ * remove this macro.
+ */
 #define for_each_plane_in_state(__state, plane, plane_state, __i)		\
 	for ((__i) = 0;							\
 	     (__i) < (__state)->dev->mode_config.num_total_plane &&	\
@@ -572,6 +695,18 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)							\
 		for_each_if (plane_state)
 
+/**
+ * for_each_oldnew_plane_in_state - iterate over all planes in an atomic update
+ * @__state: &struct drm_atomic_state pointer
+ * @plane: &struct drm_plane iteration cursor
+ * @old_plane_state: &struct drm_plane_state iteration cursor for the old state
+ * @new_plane_state: &struct drm_plane_state iteration cursor for the new state
+ * @__i: int iteration cursor, for macro-internal use
+ *
+ * This iterates over all planes in an atomic update, tracking both old and
+ * new state. This is useful in places where the state delta needs to be
+ * considered, for example in atomic check functions.
+ */
 #define for_each_oldnew_plane_in_state(__state, plane, old_plane_state, new_plane_state, __i) \
 	for ((__i) = 0;							\
 	     (__i) < (__state)->dev->mode_config.num_total_plane &&	\
@@ -581,6 +716,17 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)							\
 		for_each_if (plane)
 
+/**
+ * for_each_old_plane_in_state - iterate over all planes in an atomic update
+ * @__state: &struct drm_atomic_state pointer
+ * @plane: &struct drm_plane iteration cursor
+ * @old_plane_state: &struct drm_plane_state iteration cursor for the old state
+ * @__i: int iteration cursor, for macro-internal use
+ *
+ * This iterates over all planes in an atomic update, tracking only the old
+ * state. This is useful in disable functions, where we need the old state the
+ * hardware is still in.
+ */
 #define for_each_old_plane_in_state(__state, plane, old_plane_state, __i) \
 	for ((__i) = 0;							\
 	     (__i) < (__state)->dev->mode_config.num_total_plane &&	\
@@ -589,6 +735,17 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)							\
 		for_each_if (plane)
 
+/**
+ * for_each_new_plane_in_state - iterate over all planes in an atomic update
+ * @__state: &struct drm_atomic_state pointer
+ * @plane: &struct drm_plane iteration cursor
+ * @new_plane_state: &struct drm_plane_state iteration cursor for the new state
+ * @__i: int iteration cursor, for macro-internal use
+ *
+ * This iterates over all planes in an atomic update, tracking only the new
+ * state. This is useful in enable functions, where we need the new state the
+ * hardware should be in when the atomic commit operation has completed.
+ */
 #define for_each_new_plane_in_state(__state, plane, new_plane_state, __i) \
 	for ((__i) = 0;							\
 	     (__i) < (__state)->dev->mode_config.num_total_plane &&	\
@@ -603,7 +760,7 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
  *
  * To give drivers flexibility &struct drm_crtc_state has 3 booleans to track
  * whether the state CRTC changed enough to need a full modeset cycle:
- * connectors_changed, mode_changed and active_changed. This helper simply
+ * planes_changed, mode_changed and active_changed. This helper simply
  * combines these three to compute the overall need for a modeset for @state.
  *
  * The atomic helper code sets these booleans, but drivers can and should

commit 2107777c0249e95f9493f3341dcb4fd89b965385
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Thu Feb 16 15:47:08 2017 +0100

    drm/atomic: Add macros to access existing old/new state, v2.
    
    After atomic commit, these macros should be used in place of
    get_existing_state. Also after commit get_xx_state should no longer
    be used because it may not have the required locks.
    
    The calls to drm_atomic_get_existing_$obj_state should no longer be
    used, and converted over to these new calls.
    
    Changes since v1:
    - Expand commit message.
    - Deprecate get_existing_*_state functions in the documentation.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1487256430-7625-4-git-send-email-maarten.lankhorst@linux.intel.com
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Tested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index c6f355a970d2..0147a047878d 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -277,6 +277,9 @@ int drm_atomic_connector_set_property(struct drm_connector *connector,
  *
  * This function returns the crtc state for the given crtc, or NULL
  * if the crtc is not part of the global atomic state.
+ *
+ * This function is deprecated, @drm_atomic_get_old_crtc_state or
+ * @drm_atomic_get_new_crtc_state should be used instead.
  */
 static inline struct drm_crtc_state *
 drm_atomic_get_existing_crtc_state(struct drm_atomic_state *state,
@@ -285,6 +288,35 @@ drm_atomic_get_existing_crtc_state(struct drm_atomic_state *state,
 	return state->crtcs[drm_crtc_index(crtc)].state;
 }
 
+/**
+ * drm_atomic_get_old_crtc_state - get old crtc state, if it exists
+ * @state: global atomic state object
+ * @crtc: crtc to grab
+ *
+ * This function returns the old crtc state for the given crtc, or
+ * NULL if the crtc is not part of the global atomic state.
+ */
+static inline struct drm_crtc_state *
+drm_atomic_get_old_crtc_state(struct drm_atomic_state *state,
+			      struct drm_crtc *crtc)
+{
+	return state->crtcs[drm_crtc_index(crtc)].old_state;
+}
+/**
+ * drm_atomic_get_new_crtc_state - get new crtc state, if it exists
+ * @state: global atomic state object
+ * @crtc: crtc to grab
+ *
+ * This function returns the new crtc state for the given crtc, or
+ * NULL if the crtc is not part of the global atomic state.
+ */
+static inline struct drm_crtc_state *
+drm_atomic_get_new_crtc_state(struct drm_atomic_state *state,
+			      struct drm_crtc *crtc)
+{
+	return state->crtcs[drm_crtc_index(crtc)].new_state;
+}
+
 /**
  * drm_atomic_get_existing_plane_state - get plane state, if it exists
  * @state: global atomic state object
@@ -292,6 +324,9 @@ drm_atomic_get_existing_crtc_state(struct drm_atomic_state *state,
  *
  * This function returns the plane state for the given plane, or NULL
  * if the plane is not part of the global atomic state.
+ *
+ * This function is deprecated, @drm_atomic_get_old_plane_state or
+ * @drm_atomic_get_new_plane_state should be used instead.
  */
 static inline struct drm_plane_state *
 drm_atomic_get_existing_plane_state(struct drm_atomic_state *state,
@@ -300,6 +335,36 @@ drm_atomic_get_existing_plane_state(struct drm_atomic_state *state,
 	return state->planes[drm_plane_index(plane)].state;
 }
 
+/**
+ * drm_atomic_get_old_plane_state - get plane state, if it exists
+ * @state: global atomic state object
+ * @plane: plane to grab
+ *
+ * This function returns the old plane state for the given plane, or
+ * NULL if the plane is not part of the global atomic state.
+ */
+static inline struct drm_plane_state *
+drm_atomic_get_old_plane_state(struct drm_atomic_state *state,
+			       struct drm_plane *plane)
+{
+	return state->planes[drm_plane_index(plane)].old_state;
+}
+
+/**
+ * drm_atomic_get_new_plane_state - get plane state, if it exists
+ * @state: global atomic state object
+ * @plane: plane to grab
+ *
+ * This function returns the new plane state for the given plane, or
+ * NULL if the plane is not part of the global atomic state.
+ */
+static inline struct drm_plane_state *
+drm_atomic_get_new_plane_state(struct drm_atomic_state *state,
+			       struct drm_plane *plane)
+{
+	return state->planes[drm_plane_index(plane)].new_state;
+}
+
 /**
  * drm_atomic_get_existing_connector_state - get connector state, if it exists
  * @state: global atomic state object
@@ -307,6 +372,9 @@ drm_atomic_get_existing_plane_state(struct drm_atomic_state *state,
  *
  * This function returns the connector state for the given connector,
  * or NULL if the connector is not part of the global atomic state.
+ *
+ * This function is deprecated, @drm_atomic_get_old_connector_state or
+ * @drm_atomic_get_new_connector_state should be used instead.
  */
 static inline struct drm_connector_state *
 drm_atomic_get_existing_connector_state(struct drm_atomic_state *state,
@@ -320,6 +388,46 @@ drm_atomic_get_existing_connector_state(struct drm_atomic_state *state,
 	return state->connectors[index].state;
 }
 
+/**
+ * drm_atomic_get_old_connector_state - get connector state, if it exists
+ * @state: global atomic state object
+ * @connector: connector to grab
+ *
+ * This function returns the old connector state for the given connector,
+ * or NULL if the connector is not part of the global atomic state.
+ */
+static inline struct drm_connector_state *
+drm_atomic_get_old_connector_state(struct drm_atomic_state *state,
+				   struct drm_connector *connector)
+{
+	int index = drm_connector_index(connector);
+
+	if (index >= state->num_connector)
+		return NULL;
+
+	return state->connectors[index].old_state;
+}
+
+/**
+ * drm_atomic_get_new_connector_state - get connector state, if it exists
+ * @state: global atomic state object
+ * @connector: connector to grab
+ *
+ * This function returns the new connector state for the given connector,
+ * or NULL if the connector is not part of the global atomic state.
+ */
+static inline struct drm_connector_state *
+drm_atomic_get_new_connector_state(struct drm_atomic_state *state,
+				   struct drm_connector *connector)
+{
+	int index = drm_connector_index(connector);
+
+	if (index >= state->num_connector)
+		return NULL;
+
+	return state->connectors[index].new_state;
+}
+
 /**
  * __drm_atomic_get_current_plane_state - get current plane state
  * @state: global atomic state object

commit 8e22e1b3499a446df48c2b26667ca36c55bf864c
Merge: 00d3c14f14d5 64a577196d66
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sun Feb 26 21:34:42 2017 +0100

    Merge airlied/drm-next into drm-misc-next
    
    Backmerge the main pull request to sync up with all the newly landed
    drivers. Otherwise we'll have chaos even before 4.12 started in
    earnest.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

commit 94000cc32988a0674923309d35ab9c2405c4b39b
Merge: a5eb76d9c892 7089db84e356
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Feb 23 12:10:12 2017 +1000

    Merge tag 'v4.10-rc8' into drm-next
    
    Linux 4.10-rc8
    
    Backmerge Linus rc8 to fix some conflicts, but also
    to avoid pulling it in via a fixes pull from someone.

commit 581e49fe6b411f407102a7f2377648849e0fa37f
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Mon Jan 16 10:37:38 2017 +0100

    drm/atomic: Add new iterators over all state, v3.
    
    Add for_each_(old)(new)_(plane,connector,crtc)_in_state iterators to
    replace the old for_each_xxx_in_state ones. This is useful for >1 flip
    depth and getting rid of all xxx->state dereferences.
    
    This requires extra fixups done when committing a state after
    duplicating, which in general isn't valid but is used by suspend/resume.
    To handle these, introduce drm_atomic_helper_commit_duplicated_state
    which performs those fixups before checking & committing the state.
    
    Changes since v1:
    - Remove nonblock parameter for commit_duplicated_state.
    Changes since v2:
    - Use commit_duplicated_state for i915 load detection.
    - Add WARN_ON(old_state != obj->state) before swapping.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1484559464-27107-2-git-send-email-maarten.lankhorst@linux.intel.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 2e28fdca9c3d..3fa6e8dcb9d8 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -138,12 +138,12 @@ struct drm_crtc_commit {
 
 struct __drm_planes_state {
 	struct drm_plane *ptr;
-	struct drm_plane_state *state;
+	struct drm_plane_state *state, *old_state, *new_state;
 };
 
 struct __drm_crtcs_state {
 	struct drm_crtc *ptr;
-	struct drm_crtc_state *state;
+	struct drm_crtc_state *state, *old_state, *new_state;
 	struct drm_crtc_commit *commit;
 	s64 __user *out_fence_ptr;
 	unsigned last_vblank_count;
@@ -151,7 +151,7 @@ struct __drm_crtcs_state {
 
 struct __drm_connnectors_state {
 	struct drm_connector *ptr;
-	struct drm_connector_state *state;
+	struct drm_connector_state *state, *old_state, *new_state;
 };
 
 /**
@@ -398,6 +398,31 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)							\
 		for_each_if (connector)
 
+#define for_each_oldnew_connector_in_state(__state, connector, old_connector_state, new_connector_state, __i) \
+	for ((__i) = 0;								\
+	     (__i) < (__state)->num_connector &&				\
+	     ((connector) = (__state)->connectors[__i].ptr,			\
+	     (old_connector_state) = (__state)->connectors[__i].old_state,	\
+	     (new_connector_state) = (__state)->connectors[__i].new_state, 1); 	\
+	     (__i)++)							\
+		for_each_if (connector)
+
+#define for_each_old_connector_in_state(__state, connector, old_connector_state, __i) \
+	for ((__i) = 0;								\
+	     (__i) < (__state)->num_connector &&				\
+	     ((connector) = (__state)->connectors[__i].ptr,			\
+	     (old_connector_state) = (__state)->connectors[__i].old_state, 1); 	\
+	     (__i)++)							\
+		for_each_if (connector)
+
+#define for_each_new_connector_in_state(__state, connector, new_connector_state, __i) \
+	for ((__i) = 0;								\
+	     (__i) < (__state)->num_connector &&				\
+	     ((connector) = (__state)->connectors[__i].ptr,			\
+	     (new_connector_state) = (__state)->connectors[__i].new_state, 1); 	\
+	     (__i)++)							\
+		for_each_if (connector)
+
 #define for_each_crtc_in_state(__state, crtc, crtc_state, __i)	\
 	for ((__i) = 0;						\
 	     (__i) < (__state)->dev->mode_config.num_crtc &&	\
@@ -406,6 +431,31 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)						\
 		for_each_if (crtc_state)
 
+#define for_each_oldnew_crtc_in_state(__state, crtc, old_crtc_state, new_crtc_state, __i) \
+	for ((__i) = 0;							\
+	     (__i) < (__state)->dev->mode_config.num_crtc &&		\
+	     ((crtc) = (__state)->crtcs[__i].ptr,			\
+	     (old_crtc_state) = (__state)->crtcs[__i].old_state,	\
+	     (new_crtc_state) = (__state)->crtcs[__i].new_state, 1);	\
+	     (__i)++)							\
+		for_each_if (crtc)
+
+#define for_each_old_crtc_in_state(__state, crtc, old_crtc_state, __i)	\
+	for ((__i) = 0;							\
+	     (__i) < (__state)->dev->mode_config.num_crtc &&		\
+	     ((crtc) = (__state)->crtcs[__i].ptr,			\
+	     (old_crtc_state) = (__state)->crtcs[__i].old_state, 1);	\
+	     (__i)++)							\
+		for_each_if (crtc)
+
+#define for_each_new_crtc_in_state(__state, crtc, new_crtc_state, __i)	\
+	for ((__i) = 0;							\
+	     (__i) < (__state)->dev->mode_config.num_crtc &&		\
+	     ((crtc) = (__state)->crtcs[__i].ptr,			\
+	     (new_crtc_state) = (__state)->crtcs[__i].new_state, 1);	\
+	     (__i)++)							\
+		for_each_if (crtc)
+
 #define for_each_plane_in_state(__state, plane, plane_state, __i)		\
 	for ((__i) = 0;							\
 	     (__i) < (__state)->dev->mode_config.num_total_plane &&	\
@@ -414,6 +464,31 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 	     (__i)++)							\
 		for_each_if (plane_state)
 
+#define for_each_oldnew_plane_in_state(__state, plane, old_plane_state, new_plane_state, __i) \
+	for ((__i) = 0;							\
+	     (__i) < (__state)->dev->mode_config.num_total_plane &&	\
+	     ((plane) = (__state)->planes[__i].ptr,			\
+	     (old_plane_state) = (__state)->planes[__i].old_state,	\
+	     (new_plane_state) = (__state)->planes[__i].new_state, 1);	\
+	     (__i)++)							\
+		for_each_if (plane)
+
+#define for_each_old_plane_in_state(__state, plane, old_plane_state, __i) \
+	for ((__i) = 0;							\
+	     (__i) < (__state)->dev->mode_config.num_total_plane &&	\
+	     ((plane) = (__state)->planes[__i].ptr,			\
+	     (old_plane_state) = (__state)->planes[__i].old_state, 1);	\
+	     (__i)++)							\
+		for_each_if (plane)
+
+#define for_each_new_plane_in_state(__state, plane, new_plane_state, __i) \
+	for ((__i) = 0;							\
+	     (__i) < (__state)->dev->mode_config.num_total_plane &&	\
+	     ((plane) = (__state)->planes[__i].ptr,			\
+	     (new_plane_state) = (__state)->planes[__i].new_state, 1);	\
+	     (__i)++)							\
+		for_each_if (plane)
+
 /**
  * drm_atomic_crtc_needs_modeset - compute combined modeset need
  * @state: &drm_crtc_state for the CRTC

commit d574528a64c3a3b2a9c6a125e2428b38bddbdf3c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jan 25 07:26:45 2017 +0100

    drm/kms-core: Use recommened kerneldoc for struct member refs
    
    I just learned that &struct_name.member_name works and looks pretty
    even. It doesn't (yet) link to the member directly though, which would
    be really good for big structures or vfunc tables (where the
    per-member kerneldoc tends to be long).
    
    Also some minor drive-by polish where it makes sense, I read a lot
    of docs ...
    
    v2: Review from Eric.
    
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Eric Engestrom <eric.engestrom@imgtec.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170125062657.19270-4-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index f96220ed4004..2e28fdca9c3d 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -123,7 +123,8 @@ struct drm_crtc_commit {
 	/**
 	 * @commit_entry:
 	 *
-	 * Entry on the per-CRTC commit_list. Protected by crtc->commit_lock.
+	 * Entry on the per-CRTC &drm_crtc.commit_list. Protected by
+	 * $drm_crtc.commit_lock.
 	 */
 	struct list_head commit_entry;
 
@@ -429,7 +430,8 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
  *
  * For example if the CRTC mode has changed, and the hardware is able to enact
  * the requested mode change without going through a full modeset, the driver
- * should clear mode_changed during its ->atomic_check.
+ * should clear mode_changed in its &drm_mode_config_funcs.atomic_check
+ * implementation.
  */
 static inline bool
 drm_atomic_crtc_needs_modeset(const struct drm_crtc_state *state)

commit 7e9081c5aac73b8a0bc22e0b3e7a12c3e9cf5256
Author: Gustavo Padovan <gustavo.padovan@collabora.com>
Date:   Fri Jan 13 12:22:09 2017 -0200

    drm/fence: fix memory overwrite when setting out_fence fd
    
    Currently if the userspace declares a int variable to store the out_fence
    fd and pass it to OUT_FENCE_PTR the kernel will overwrite the 32 bits
    above the int variable on 64 bits systems.
    
    Fix this by making the internal storage of out_fence in the kernel a s32
    pointer.
    
    Reported-by: Chad Versace <chadversary@chromium.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.com>
    Fixes: beaf5af48034 ("drm/fence: add out-fences support")
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Rafael Antognolli <rafael.antognolli@intel.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-and-Tested-by: Chad Versace <chadversary@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1484317329-9293-1-git-send-email-gustavo@padovan.org

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index d6d241f63b9f..56814e8ae7ea 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -144,7 +144,7 @@ struct __drm_crtcs_state {
 	struct drm_crtc *ptr;
 	struct drm_crtc_state *state;
 	struct drm_crtc_commit *commit;
-	s64 __user *out_fence_ptr;
+	s32 __user *out_fence_ptr;
 };
 
 struct __drm_connnectors_state {

commit b3ba3f6fab873a8d757fbcd9f83c3f69e369cddf
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Dec 21 14:03:35 2016 +0100

    drm: Add kernel-doc for drm_crtc_commit_get/put
    
    I was lazy, rectify that! Also align with drm_atomic_state_get/put for
    ocd.
    
    v2: Git add helps.
    
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161221130335.5321-1-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index fd2d971bca32..f96220ed4004 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -189,12 +189,31 @@ struct drm_atomic_state {
 	struct work_struct commit_work;
 };
 
-void drm_crtc_commit_put(struct drm_crtc_commit *commit);
+void __drm_crtc_commit_free(struct kref *kref);
+
+/**
+ * drm_crtc_commit_get - acquire a reference to the CRTC commit
+ * @commit: CRTC commit
+ *
+ * Increases the reference of @commit.
+ */
 static inline void drm_crtc_commit_get(struct drm_crtc_commit *commit)
 {
 	kref_get(&commit->ref);
 }
 
+/**
+ * drm_crtc_commit_put - release a reference to the CRTC commmit
+ * @commit: CRTC commit
+ *
+ * This releases a reference to @commit which is freed after removing the
+ * final reference. No locking required and callable from any context.
+ */
+static inline void drm_crtc_commit_put(struct drm_crtc_commit *commit)
+{
+	kref_put(&commit->ref, __drm_crtc_commit_free);
+}
+
 struct drm_atomic_state * __must_check
 drm_atomic_state_alloc(struct drm_device *dev);
 void drm_atomic_state_clear(struct drm_atomic_state *state);

commit ea0dd85a75f15174cc2bf75f805e378391995931
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Dec 29 21:48:26 2016 +0100

    drm/doc: use preferred struct reference in kernel-doc
    
    sed -e 's/\( \* .*\)struct &\([_a-z]*\)/\1\&struct \2/' -i
    
    Originally I wasnt a friend of this style because I thought a
    line-break between the "&struct" and "foo" part would break it. But a
    quick test shows that " * &struct \n * foo\n" works pefectly well with
    current kernel-doc. So time to mass-apply these changes!
    
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1483044517-5770-6-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index b0ebe0fafc41..fd2d971bca32 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -398,7 +398,7 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
  * drm_atomic_crtc_needs_modeset - compute combined modeset need
  * @state: &drm_crtc_state for the CRTC
  *
- * To give drivers flexibility struct &drm_crtc_state has 3 booleans to track
+ * To give drivers flexibility &struct drm_crtc_state has 3 booleans to track
  * whether the state CRTC changed enough to need a full modeset cycle:
  * connectors_changed, mode_changed and active_changed. This helper simply
  * combines these three to compute the overall need for a modeset for @state.

commit a743d7582db9aba0e7078d6386bdad2756309dba
Author: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
Date:   Thu Dec 22 00:50:42 2016 -0800

    drm: Wrap the check for atomic_commit implementation
    
    This check is useful for drivers that do not have DRIVER_ATOMIC set but
    have atomic modesetting internally implemented. Wrap the check into a
    function since this is used in many places and as a bonus, the function
    name helps to document what the check is for.
    
    v2:
    Change return type to bool (Ville)
    Move the function drm_atomic.h (Daniel)
    Fixed comment marker for documentation
    
    Suggested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Signed-off-by: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    [danvet: Move back to drmP.h because include hell.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1482396643-32456-1-git-send-email-dhinakaran.pandiyan@intel.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 8cc7ca2079fb..b0ebe0fafc41 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -419,5 +419,4 @@ drm_atomic_crtc_needs_modeset(const struct drm_crtc_state *state)
 	       state->connectors_changed;
 }
 
-
 #endif /* DRM_ATOMIC_H_ */

commit bdc571464c49740ce56c56e108d60f825336eb89
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Thu Dec 15 12:51:42 2016 +0100

    drm/atomic: Clean up wait_for_vblanks, v2.
    
    Stop relying on a per crtc_state last_vblank_count, we shouldn't touch
    crtc_state after commit. Move it to atomic_state->crtcs.
    
    Also stop re-using new_crtc_state->enable, we can now simply set a
    bitmask with crtc_crtc_mask.
    
    Changes since v1:
    - Keep last_vblank_count in __drm_crtc_state.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/8e4759a4-24d3-3f80-bd1a-1e7a9c83b612@linux.intel.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index b74f04c49713..8cc7ca2079fb 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -145,6 +145,7 @@ struct __drm_crtcs_state {
 	struct drm_crtc_state *state;
 	struct drm_crtc_commit *commit;
 	s64 __user *out_fence_ptr;
+	unsigned last_vblank_count;
 };
 
 struct __drm_connnectors_state {

commit 5bc9cb4dfbe8fcae02f8421e3102c78681f53b8c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Dec 14 00:08:03 2016 +0100

    drm: Move atomic debugfs functions into drm_crtc_internal.h
    
    This is not driver interface stuff.
    
    Fixes: 6559c901cb48 ("drm/atomic: add debugfs file to dump out atomic state")
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161213230814.19598-3-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index d6d241f63b9f..b74f04c49713 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -369,12 +369,6 @@ int __must_check drm_atomic_nonblocking_commit(struct drm_atomic_state *state);
 
 void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 
-#ifdef CONFIG_DEBUG_FS
-struct drm_minor;
-int drm_atomic_debugfs_init(struct drm_minor *minor);
-int drm_atomic_debugfs_cleanup(struct drm_minor *minor);
-#endif
-
 #define for_each_connector_in_state(__state, connector, connector_state, __i) \
 	for ((__i) = 0;							\
 	     (__i) < (__state)->num_connector &&				\

commit 79b95552336478b0465b74a1bda1f74239f5da3a
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Nov 24 19:47:02 2016 +0200

    drm/atomic: Constify drm_atomic_crtc_needs_modeset()
    
    drm_atomic_crtc_needs_modeset() doesn't change the passed in
    crtc state, so pass it as const.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1480009622-28127-1-git-send-email-ville.syrjala@linux.intel.com
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 5d5f85db43f0..d6d241f63b9f 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -418,7 +418,7 @@ int drm_atomic_debugfs_cleanup(struct drm_minor *minor);
  * should clear mode_changed during its ->atomic_check.
  */
 static inline bool
-drm_atomic_crtc_needs_modeset(struct drm_crtc_state *state)
+drm_atomic_crtc_needs_modeset(const struct drm_crtc_state *state)
 {
 	return state->mode_changed || state->active_changed ||
 	       state->connectors_changed;

commit 8c0b55e22aff84cb6938a993d86c3ce02006236e
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Thu Nov 17 11:41:29 2016 +0000

    drm/atomic: cleanup debugfs entries on un-registering the driver.
    
    Cleanup the debugfs entries created by
    commit 6559c901cb48:  drm/atomic: add debugfs file to dump out atomic state
    when the driver's minor gets un-registered. Without it, DRM drivers
    compiled as modules cannot be rmmod-ed and modprobed again.
    
    Tested-by: Brian Starkey <brian.starkey@arm.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161117114129.2627-1-Liviu.Dudau@arm.com
    Fixes: 6559c901cb48 ("drm/atomic: add debugfs file to dump out atomic state")

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index c0eaec70a203..5d5f85db43f0 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -372,6 +372,7 @@ void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
 #ifdef CONFIG_DEBUG_FS
 struct drm_minor;
 int drm_atomic_debugfs_init(struct drm_minor *minor);
+int drm_atomic_debugfs_cleanup(struct drm_minor *minor);
 #endif
 
 #define for_each_connector_in_state(__state, connector, connector_state, __i) \

commit beaf5af48034c9e2ebb8b2b1fb12dc4d8aeba99e
Author: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Date:   Wed Nov 16 22:00:21 2016 +0900

    drm/fence: add out-fences support
    
    Support DRM out-fences by creating a sync_file with a fence for each CRTC
    that sets the OUT_FENCE_PTR property.
    
    We use the out_fence pointer received in the OUT_FENCE_PTR prop to send
    the sync_file fd back to userspace.
    
    The sync_file and fd are allocated/created before commit, but the
    fd_install operation only happens after we know that commit succeed.
    
    v2: Comment by Rob Clark:
            - Squash commit that adds DRM_MODE_ATOMIC_OUT_FENCE flag here.
    
        Comment by Daniel Vetter:
            - Add clean up code for out_fences
    
    v3: Comments by Daniel Vetter:
            - create DRM_MODE_ATOMIC_EVENT_MASK
            - userspace should fill out_fences_ptr with the crtc_ids for which
            it wants fences back.
    
    v4: Create OUT_FENCE_PTR properties and remove old approach.
    
    v5: Comments by Brian Starkey:
            - Remove extra fence_get() in atomic_ioctl()
            - Check ret before iterating on the crtc_state
            - check ret before fd_install
            - set fence_state to NULL at the beginning
            - check fence_state->out_fence_ptr before put_user()
            - change order of fput() and put_unused_fd() on failure
    
         - Add access_ok() check to the out_fence_ptr received
         - Rebase after fence -> dma_fence rename
         - Store out_fence_ptr in the drm_atomic_state
         - Split crtc_setup_out_fence()
         - return -1 as out_fence with TEST_ONLY flag
    
    v6: Comments by Daniel Vetter
            - Add prepare/unprepare_crtc_signaling()
            - move struct drm_out_fence_state to drm_atomic.c
            - mark get_crtc_fence() as static
    
        Comments by Brian Starkey
            - proper set fence_ptr fence_state array
            - isolate fence_idx increment
    
        - improve error handling
    
    v7: Comments by Daniel Vetter
            - remove prefix from internal functions
            - make out_fence_ptr an s64 pointer
            - degrade DRM_INFO to DRM_DEBUG_ATOMIC when put_user fail
            - fix doc issues
            - filter out OUT_FENCE_PTR == NULL and do not fail in this case
            - add complete_crtc_signalling()
            - krealloc fence_state on demand
    
        Comment by Brian Starkey
            - remove unused crtc_state arg from get_out_fence()
    
    v8: Comment by Brian Starkey
            - cancel events before check for !fence_state
            - convert a few lefovers u64 types for out_fence_ptr
            - fix memleak by assign fence_state earlier after realloc
            - proper accout num_fences in case of error
    
    v9: Comment by Brian Starkey
            - memset last position of fence_state after krealloc
        Comments by Sean Paul
            - pass install_fds in complete_crtc_signaling() instead of ret
    
         - put_user(-1, fence_ptr) when decoding props
    
    v10: Comment by Brian Starkey
            - remove unneeded num_fences increment on error path
            - kfree fence_state after installing fences fd
    
    v11: rebase against latest drm-misc
    
    v12: rebase again against latest drm-misc
    
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Reviewed-by: Brian Starkey <brian.starkey@arm.com> (v10)
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Tested-by: Robert Foss <robert.foss@collabora.com> (v10)
    [danvet: Appease checkpatch.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1479301221-13056-1-git-send-email-gustavo@padovan.org

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 331bb100b718..c0eaec70a203 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -144,6 +144,7 @@ struct __drm_crtcs_state {
 	struct drm_crtc *ptr;
 	struct drm_crtc_state *state;
 	struct drm_crtc_commit *commit;
+	s64 __user *out_fence_ptr;
 };
 
 struct __drm_connnectors_state {

commit 6559c901cb4840e46893d587d8af435aac9c4c3f
Author: Rob Clark <robdclark@gmail.com>
Date:   Sat Nov 5 11:08:10 2016 -0400

    drm/atomic: add debugfs file to dump out atomic state
    
    Useful to dump current state from debugfs, if turning on the drm.debug
    bit is too much overhead.
    
    The drm_state_dump() can also be used by drivers, for example to
    implement a module param that dumps state on error irqs.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1478358492-30738-6-git-send-email-robdclark@gmail.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 2d1e9c944b54..331bb100b718 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -366,6 +366,13 @@ int __must_check drm_atomic_check_only(struct drm_atomic_state *state);
 int __must_check drm_atomic_commit(struct drm_atomic_state *state);
 int __must_check drm_atomic_nonblocking_commit(struct drm_atomic_state *state);
 
+void drm_state_dump(struct drm_device *dev, struct drm_printer *p);
+
+#ifdef CONFIG_DEBUG_FS
+struct drm_minor;
+int drm_atomic_debugfs_init(struct drm_minor *minor);
+#endif
+
 #define for_each_connector_in_state(__state, connector, connector_state, __i) \
 	for ((__i) = 0;							\
 	     (__i) < (__state)->num_connector &&				\

commit 13b55664eec7b85607c4ab9d26a62b4af413a771
Author: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Date:   Mon Nov 7 19:03:30 2016 +0900

    drm/atomic: add drm_atomic_set_fence_for_plane()
    
    This new function should be used by drivers when setting a implicit
    fence for the plane. It abstracts the fact that the user might have
    chosen explicit fencing instead.
    
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1478513013-3221-1-git-send-email-gustavo@padovan.org

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index fc8af53b18aa..2d1e9c944b54 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -345,6 +345,8 @@ drm_atomic_set_crtc_for_plane(struct drm_plane_state *plane_state,
 			      struct drm_crtc *crtc);
 void drm_atomic_set_fb_for_plane(struct drm_plane_state *plane_state,
 				 struct drm_framebuffer *fb);
+void drm_atomic_set_fence_for_plane(struct drm_plane_state *plane_state,
+				    struct dma_fence *fence);
 int __must_check
 drm_atomic_set_crtc_for_connector(struct drm_connector_state *conn_state,
 				  struct drm_crtc *crtc);

commit 0853695c3ba46f97dfc0b5885f7b7e640ca212dd
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Oct 14 13:18:18 2016 +0100

    drm: Add reference counting to drm_atomic_state
    
    drm_atomic_state has a complicated single owner model that tracks the
    single reference from allocation through to destruction on another
    thread - or perhaps on a local error path. We can simplify this tracking
    by using reference counting (at a cost of a few more atomics). This is
    even more beneficial when the lifetime of the state becomes more
    convoluted than being passed to a single worker thread for the commit.
    
    v2: Double check !intel atomic_commit functions for missing gets
    v3: Update kerneldocs
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: dri-devel@lists.freedesktop.org
    Reviewed-by: Eric Engestrom <eric.engestrom@imgtec.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161014121833.439-27-chris@chris-wilson.co.uk

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index c52f99415c55..fc8af53b18aa 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -153,6 +153,7 @@ struct __drm_connnectors_state {
 
 /**
  * struct drm_atomic_state - the global state object for atomic updates
+ * @ref: count of all references to this state (will not be freed until zero)
  * @dev: parent DRM device
  * @allow_modeset: allow full modeset
  * @legacy_cursor_update: hint to enforce legacy cursor IOCTL semantics
@@ -164,6 +165,8 @@ struct __drm_connnectors_state {
  * @acquire_ctx: acquire context for this atomic modeset state update
  */
 struct drm_atomic_state {
+	struct kref ref;
+
 	struct drm_device *dev;
 	bool allow_modeset : 1;
 	bool legacy_cursor_update : 1;
@@ -193,7 +196,33 @@ static inline void drm_crtc_commit_get(struct drm_crtc_commit *commit)
 struct drm_atomic_state * __must_check
 drm_atomic_state_alloc(struct drm_device *dev);
 void drm_atomic_state_clear(struct drm_atomic_state *state);
-void drm_atomic_state_free(struct drm_atomic_state *state);
+
+/**
+ * drm_atomic_state_get - acquire a reference to the atomic state
+ * @state: The atomic state
+ *
+ * Returns a new reference to the @state
+ */
+static inline struct drm_atomic_state *
+drm_atomic_state_get(struct drm_atomic_state *state)
+{
+	kref_get(&state->ref);
+	return state;
+}
+
+void __drm_atomic_state_free(struct kref *ref);
+
+/**
+ * drm_atomic_state_put - release a reference to the atomic state
+ * @state: The atomic state
+ *
+ * This releases a reference to @state which is freed after removing the
+ * final reference. No locking required and callable from any context.
+ */
+static inline void drm_atomic_state_put(struct drm_atomic_state *state)
+{
+	kref_put(&state->ref, __drm_atomic_state_free);
+}
 
 int  __must_check
 drm_atomic_state_init(struct drm_device *dev, struct drm_atomic_state *state);

commit d807ed1c55fb1b2dcfb2bc49385e227f6bee7669
Author: Brian Starkey <brian.starkey@arm.com>
Date:   Thu Oct 13 10:47:08 2016 +0100

    drm: atomic: Clarify documentation around drm_atomic_crtc_needs_modeset
    
    Add some additional comments to more explicitly describe the meaning and
    usage of the three CRTC modeset detection booleans: mode_changed,
    connectors_changed and active_changed.
    
    Suggested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Brian Starkey <brian.starkey@arm.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1476352028-16701-1-git-send-email-brian.starkey@arm.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 9701f2dfb784..c52f99415c55 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -365,8 +365,17 @@ int __must_check drm_atomic_nonblocking_commit(struct drm_atomic_state *state);
  *
  * To give drivers flexibility struct &drm_crtc_state has 3 booleans to track
  * whether the state CRTC changed enough to need a full modeset cycle:
- * connectors_changed, mode_changed and active_change. This helper simply
+ * connectors_changed, mode_changed and active_changed. This helper simply
  * combines these three to compute the overall need for a modeset for @state.
+ *
+ * The atomic helper code sets these booleans, but drivers can and should
+ * change them appropriately to accurately represent whether a modeset is
+ * really needed. In general, drivers should avoid full modesets whenever
+ * possible.
+ *
+ * For example if the CRTC mode has changed, and the hardware is able to enact
+ * the requested mode change without going through a full modeset, the driver
+ * should clear mode_changed during its ->atomic_check.
  */
 static inline bool
 drm_atomic_crtc_needs_modeset(struct drm_crtc_state *state)

commit 43968d7b806d7a7e021261294c583a216fddf0e5
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Sep 21 10:59:24 2016 +0200

    drm: Extract drm_plane.[hc]
    
    Just pure code movement, cleanup and polish will happen in later
    patches.
    
    v2: Don't forget all the ioctl! To extract those cleanly I decided to
    put check_src_coords into drm_framebuffer.c (and give it a
    drm_framebuffer_ prefix), since that just checks framebuffer
    constraints.
    
    v3: rebase over PAGE_FLIP_TARGET.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    
    [seanpaul]
    This patch as posted on the list was rebased on:
    
    commit 6f00975c619064a18c23fd3aced325ae165a73b9
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Sat Aug 20 12:22:11 2016 +0200
    
        drm: Reject page_flip for !DRIVER_MODESET
    
    so as a result of moving the page_flip ioctl, this fix has
    been rolled into this patch.
    
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 856a9c85a838..9701f2dfb784 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -30,6 +30,160 @@
 
 #include <drm/drm_crtc.h>
 
+/**
+ * struct drm_crtc_commit - track modeset commits on a CRTC
+ *
+ * This structure is used to track pending modeset changes and atomic commit on
+ * a per-CRTC basis. Since updating the list should never block this structure
+ * is reference counted to allow waiters to safely wait on an event to complete,
+ * without holding any locks.
+ *
+ * It has 3 different events in total to allow a fine-grained synchronization
+ * between outstanding updates::
+ *
+ *	atomic commit thread			hardware
+ *
+ * 	write new state into hardware	---->	...
+ * 	signal hw_done
+ * 						switch to new state on next
+ * 	...					v/hblank
+ *
+ *	wait for buffers to show up		...
+ *
+ *	...					send completion irq
+ *						irq handler signals flip_done
+ *	cleanup old buffers
+ *
+ * 	signal cleanup_done
+ *
+ * 	wait for flip_done		<----
+ * 	clean up atomic state
+ *
+ * The important bit to know is that cleanup_done is the terminal event, but the
+ * ordering between flip_done and hw_done is entirely up to the specific driver
+ * and modeset state change.
+ *
+ * For an implementation of how to use this look at
+ * drm_atomic_helper_setup_commit() from the atomic helper library.
+ */
+struct drm_crtc_commit {
+	/**
+	 * @crtc:
+	 *
+	 * DRM CRTC for this commit.
+	 */
+	struct drm_crtc *crtc;
+
+	/**
+	 * @ref:
+	 *
+	 * Reference count for this structure. Needed to allow blocking on
+	 * completions without the risk of the completion disappearing
+	 * meanwhile.
+	 */
+	struct kref ref;
+
+	/**
+	 * @flip_done:
+	 *
+	 * Will be signaled when the hardware has flipped to the new set of
+	 * buffers. Signals at the same time as when the drm event for this
+	 * commit is sent to userspace, or when an out-fence is singalled. Note
+	 * that for most hardware, in most cases this happens after @hw_done is
+	 * signalled.
+	 */
+	struct completion flip_done;
+
+	/**
+	 * @hw_done:
+	 *
+	 * Will be signalled when all hw register changes for this commit have
+	 * been written out. Especially when disabling a pipe this can be much
+	 * later than than @flip_done, since that can signal already when the
+	 * screen goes black, whereas to fully shut down a pipe more register
+	 * I/O is required.
+	 *
+	 * Note that this does not need to include separately reference-counted
+	 * resources like backing storage buffer pinning, or runtime pm
+	 * management.
+	 */
+	struct completion hw_done;
+
+	/**
+	 * @cleanup_done:
+	 *
+	 * Will be signalled after old buffers have been cleaned up by calling
+	 * drm_atomic_helper_cleanup_planes(). Since this can only happen after
+	 * a vblank wait completed it might be a bit later. This completion is
+	 * useful to throttle updates and avoid hardware updates getting ahead
+	 * of the buffer cleanup too much.
+	 */
+	struct completion cleanup_done;
+
+	/**
+	 * @commit_entry:
+	 *
+	 * Entry on the per-CRTC commit_list. Protected by crtc->commit_lock.
+	 */
+	struct list_head commit_entry;
+
+	/**
+	 * @event:
+	 *
+	 * &drm_pending_vblank_event pointer to clean up private events.
+	 */
+	struct drm_pending_vblank_event *event;
+};
+
+struct __drm_planes_state {
+	struct drm_plane *ptr;
+	struct drm_plane_state *state;
+};
+
+struct __drm_crtcs_state {
+	struct drm_crtc *ptr;
+	struct drm_crtc_state *state;
+	struct drm_crtc_commit *commit;
+};
+
+struct __drm_connnectors_state {
+	struct drm_connector *ptr;
+	struct drm_connector_state *state;
+};
+
+/**
+ * struct drm_atomic_state - the global state object for atomic updates
+ * @dev: parent DRM device
+ * @allow_modeset: allow full modeset
+ * @legacy_cursor_update: hint to enforce legacy cursor IOCTL semantics
+ * @legacy_set_config: Disable conflicting encoders instead of failing with -EINVAL.
+ * @planes: pointer to array of structures with per-plane data
+ * @crtcs: pointer to array of CRTC pointers
+ * @num_connector: size of the @connectors and @connector_states arrays
+ * @connectors: pointer to array of structures with per-connector data
+ * @acquire_ctx: acquire context for this atomic modeset state update
+ */
+struct drm_atomic_state {
+	struct drm_device *dev;
+	bool allow_modeset : 1;
+	bool legacy_cursor_update : 1;
+	bool legacy_set_config : 1;
+	struct __drm_planes_state *planes;
+	struct __drm_crtcs_state *crtcs;
+	int num_connector;
+	struct __drm_connnectors_state *connectors;
+
+	struct drm_modeset_acquire_ctx *acquire_ctx;
+
+	/**
+	 * @commit_work:
+	 *
+	 * Work item which can be used by the driver or helpers to execute the
+	 * commit without blocking.
+	 */
+	struct work_struct commit_work;
+};
+
 void drm_crtc_commit_put(struct drm_crtc_commit *commit);
 static inline void drm_crtc_commit_get(struct drm_crtc_commit *commit)
 {

commit 3b24f7d6758165919ba7b83b3c8365c38ffacc0b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jun 8 14:19:00 2016 +0200

    drm/atomic: Add struct drm_crtc_commit to track async updates
    
    Split out from my big nonblocking atomic commit helper code as prep
    work. While add it, also add some neat asciiart to document how it's
    supposed to be used.
    
    v2: Resurrect misplaced hunk in the kerneldoc.
    
    v3: Wording improvements from Liviu.
    
    Tested-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Tomeu Vizoso <tomeu.vizoso@gmail.com>
    Cc: Daniel Stone <daniels@collabora.com>
    Tested-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1465388359-8070-8-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index a16861c882aa..856a9c85a838 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -30,6 +30,12 @@
 
 #include <drm/drm_crtc.h>
 
+void drm_crtc_commit_put(struct drm_crtc_commit *commit);
+static inline void drm_crtc_commit_get(struct drm_crtc_commit *commit)
+{
+	kref_get(&commit->ref);
+}
+
 struct drm_atomic_state * __must_check
 drm_atomic_state_alloc(struct drm_device *dev);
 void drm_atomic_state_clear(struct drm_atomic_state *state);

commit 081e9c0f8b5f88758376f50310d60d0dc4ace9e0
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jun 8 14:18:59 2016 +0200

    drm/atomic: kerneldoc for drm_atomic_crtc_needs_modeset
    
    Just a bit of drive-by ocd.
    
    v2: Improve per Liviu's feedback.
    
    Cc: Liviu Dudau <Liviu.Dudau@arm.com>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1465388359-8070-7-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index d12cfb9c6062..a16861c882aa 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -198,6 +198,16 @@ int __must_check drm_atomic_nonblocking_commit(struct drm_atomic_state *state);
 	     (plane_state) = (__state)->planes[__i].state, 1);		\
 	     (__i)++)							\
 		for_each_if (plane_state)
+
+/**
+ * drm_atomic_crtc_needs_modeset - compute combined modeset need
+ * @state: &drm_crtc_state for the CRTC
+ *
+ * To give drivers flexibility struct &drm_crtc_state has 3 booleans to track
+ * whether the state CRTC changed enough to need a full modeset cycle:
+ * connectors_changed, mode_changed and active_change. This helper simply
+ * combines these three to compute the overall need for a modeset for @state.
+ */
 static inline bool
 drm_atomic_crtc_needs_modeset(struct drm_crtc_state *state)
 {

commit 60c9e19003763cf2f234f30411c7bafa82dd1c65
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jun 2 17:39:14 2016 +0200

    drm/atomic-docs: Spelling fixups
    
    Eric nicely pointed these out, but I failed at git add and lost them.
    This fixes up
    
    commit 2f196b7c4b82eeff3574eb2999e78add33ef4361
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Thu Jun 2 16:21:44 2016 +0200
    
        drm/atomic: Add drm_atomic_crtc_state_for_each_plane_state
    
    to actually do what it says on the tin^Wcommit message.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index d9504dfcd1cc..d12cfb9c6062 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -124,9 +124,9 @@ drm_atomic_get_existing_connector_state(struct drm_atomic_state *state,
  *
  * Note that this function is in general unsafe since it doesn't check for the
  * required locking for access state structures. Drivers must ensure that it is
- * save to access the returned state structure through other means. One commone
+ * safe to access the returned state structure through other means. One common
  * example is when planes are fixed to a single CRTC, and the driver knows that
- * the CRTC locks is held already. In that case holding the CRTC locks gives a
+ * the CRTC lock is held already. In that case holding the CRTC lock gives a
  * read-lock on all planes connected to that CRTC. But if planes can be
  * reassigned things get more tricky. In that case it's better to use
  * drm_atomic_get_plane_state and wire up full error handling.

commit 5d943aa6c0d424f4d4a1c96fb2fa2a81e55e1e85
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jun 2 00:06:34 2016 +0200

    drm: Consolidate crtc arrays in drm_atomic_state
    
    It's silly to have 2 mallocs when we could tie these two together.
    
    Also, Gustavo adds another one in his per-crtc out-fence patches. And
    I want to add more stuff here for nonblocking commit helpers.
    
    In the future we can use this to store a pointer to the preceeding
    state, making an atomic update entirely free-standing. This will be
    needed to be able to queue them up with a depth > 1.
    
    Cc: Gustavo Padovan <gustavo@padovan.org>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1464818821-5736-12-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 8e616d39353b..d9504dfcd1cc 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -71,7 +71,7 @@ static inline struct drm_crtc_state *
 drm_atomic_get_existing_crtc_state(struct drm_atomic_state *state,
 				   struct drm_crtc *crtc)
 {
-	return state->crtc_states[drm_crtc_index(crtc)];
+	return state->crtcs[drm_crtc_index(crtc)].state;
 }
 
 /**
@@ -183,11 +183,11 @@ int __must_check drm_atomic_nonblocking_commit(struct drm_atomic_state *state);
 	     (__i)++)							\
 		for_each_if (connector)
 
-#define for_each_crtc_in_state(state, crtc, crtc_state, __i)	\
+#define for_each_crtc_in_state(__state, crtc, crtc_state, __i)	\
 	for ((__i) = 0;						\
-	     (__i) < (state)->dev->mode_config.num_crtc &&	\
-	     ((crtc) = (state)->crtcs[__i],			\
-	     (crtc_state) = (state)->crtc_states[__i], 1);	\
+	     (__i) < (__state)->dev->mode_config.num_crtc &&	\
+	     ((crtc) = (__state)->crtcs[__i].ptr,			\
+	     (crtc_state) = (__state)->crtcs[__i].state, 1);	\
 	     (__i)++)						\
 		for_each_if (crtc_state)
 

commit b8b5342b699b9b3d1b3455861a68b96424146959
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jun 2 00:06:33 2016 +0200

    drm: Consolidate plane arrays in drm_atomic_state
    
    It's kinda pointless to have 2 separate mallocs for these. And when we
    add more per-plane state in the future it's even more pointless.
    
    Right now there's no such thing planned, but both Gustavo's per-crtc
    fence patches, and some nonblocking commit helpers I'm playing around
    with will add more per-crtc stuff. It makes sense to also consolidate
    planes, just for consistency.
    
    In the future we can use this to store a pointer to the preceeding
    state, making an atomic update entirely free-standing. This will be
    needed to be able to queue them up with a depth > 1.
    
    Cc: Gustavo Padovan <gustavo@padovan.org>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1464818821-5736-11-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 37478adb6a16..8e616d39353b 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -86,7 +86,7 @@ static inline struct drm_plane_state *
 drm_atomic_get_existing_plane_state(struct drm_atomic_state *state,
 				    struct drm_plane *plane)
 {
-	return state->plane_states[drm_plane_index(plane)];
+	return state->planes[drm_plane_index(plane)].state;
 }
 
 /**
@@ -139,8 +139,8 @@ static inline const struct drm_plane_state *
 __drm_atomic_get_current_plane_state(struct drm_atomic_state *state,
 				     struct drm_plane *plane)
 {
-	if (state->plane_states[drm_plane_index(plane)])
-		return state->plane_states[drm_plane_index(plane)];
+	if (state->planes[drm_plane_index(plane)].state)
+		return state->planes[drm_plane_index(plane)].state;
 
 	return plane->state;
 }
@@ -191,11 +191,11 @@ int __must_check drm_atomic_nonblocking_commit(struct drm_atomic_state *state);
 	     (__i)++)						\
 		for_each_if (crtc_state)
 
-#define for_each_plane_in_state(state, plane, plane_state, __i)		\
+#define for_each_plane_in_state(__state, plane, plane_state, __i)		\
 	for ((__i) = 0;							\
-	     (__i) < (state)->dev->mode_config.num_total_plane &&	\
-	     ((plane) = (state)->planes[__i],				\
-	     (plane_state) = (state)->plane_states[__i], 1);		\
+	     (__i) < (__state)->dev->mode_config.num_total_plane &&	\
+	     ((plane) = (__state)->planes[__i].ptr,				\
+	     (plane_state) = (__state)->planes[__i].state, 1);		\
 	     (__i)++)							\
 		for_each_if (plane_state)
 static inline bool

commit 63e83c1dba5490de84c2d558a2425730db7fb134
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jun 2 00:06:32 2016 +0200

    drm: Consolidate connector arrays in drm_atomic_state
    
    It's kinda pointless to have 2 separate mallocs for these. And when we
    add more per-connector state in the future it's even more pointless.
    
    Right now there's no such thing planned, but both Gustavo's per-crtc
    fence patches, and some nonblocking commit helpers I'm playing around
    with will add more per-crtc stuff. It makes sense to also consolidate
    connectors, just for consistency.
    
    In the future we can use this to store a pointer to the preceeding
    state, making an atomic update entirely free-standing. This will be
    needed to be able to queue them up with a depth > 1.
    
    Cc: Gustavo Padovan <gustavo@padovan.org>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1464818821-5736-10-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 4e97186293be..37478adb6a16 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -106,7 +106,7 @@ drm_atomic_get_existing_connector_state(struct drm_atomic_state *state,
 	if (index >= state->num_connector)
 		return NULL;
 
-	return state->connector_states[index];
+	return state->connectors[index].state;
 }
 
 /**
@@ -175,11 +175,11 @@ int __must_check drm_atomic_check_only(struct drm_atomic_state *state);
 int __must_check drm_atomic_commit(struct drm_atomic_state *state);
 int __must_check drm_atomic_nonblocking_commit(struct drm_atomic_state *state);
 
-#define for_each_connector_in_state(state, connector, connector_state, __i) \
+#define for_each_connector_in_state(__state, connector, connector_state, __i) \
 	for ((__i) = 0;							\
-	     (__i) < (state)->num_connector &&				\
-	     ((connector) = (state)->connectors[__i],			\
-	     (connector_state) = (state)->connector_states[__i], 1); 	\
+	     (__i) < (__state)->num_connector &&				\
+	     ((connector) = (__state)->connectors[__i].ptr,			\
+	     (connector_state) = (__state)->connectors[__i].state, 1); 	\
 	     (__i)++)							\
 		for_each_if (connector)
 

commit 2f196b7c4b82eeff3574eb2999e78add33ef4361
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jun 2 16:21:44 2016 +0200

    drm/atomic: Add drm_atomic_crtc_state_for_each_plane_state
    
    ... and use it in msm&vc4. Again just want to encapsulate
    drm_atomic_state internals a bit.
    
    The const threading is a bit awkward in vc4 since C sucks, but I still
    think it's worth to enforce this. Eventually I want to make all the
    obj->state pointers const too, but that's a lot more work ...
    
    v2: Provide safe macro to wrap up the unsafe helper better, suggested
    by Maarten.
    
    v3: Fixup subject (Maarten) and spelling fixes (Eric Engestrom).
    
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Eric Engestrom <eric.engestrom@imgtec.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1464877304-4213-1-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 92c84e9ab09a..4e97186293be 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -109,6 +109,42 @@ drm_atomic_get_existing_connector_state(struct drm_atomic_state *state,
 	return state->connector_states[index];
 }
 
+/**
+ * __drm_atomic_get_current_plane_state - get current plane state
+ * @state: global atomic state object
+ * @plane: plane to grab
+ *
+ * This function returns the plane state for the given plane, either from
+ * @state, or if the plane isn't part of the atomic state update, from @plane.
+ * This is useful in atomic check callbacks, when drivers need to peek at, but
+ * not change, state of other planes, since it avoids threading an error code
+ * back up the call chain.
+ *
+ * WARNING:
+ *
+ * Note that this function is in general unsafe since it doesn't check for the
+ * required locking for access state structures. Drivers must ensure that it is
+ * save to access the returned state structure through other means. One commone
+ * example is when planes are fixed to a single CRTC, and the driver knows that
+ * the CRTC locks is held already. In that case holding the CRTC locks gives a
+ * read-lock on all planes connected to that CRTC. But if planes can be
+ * reassigned things get more tricky. In that case it's better to use
+ * drm_atomic_get_plane_state and wire up full error handling.
+ *
+ * Returns:
+ *
+ * Read-only pointer to the current plane state.
+ */
+static inline const struct drm_plane_state *
+__drm_atomic_get_current_plane_state(struct drm_atomic_state *state,
+				     struct drm_plane *plane)
+{
+	if (state->plane_states[drm_plane_index(plane)])
+		return state->plane_states[drm_plane_index(plane)];
+
+	return plane->state;
+}
+
 int __must_check
 drm_atomic_set_mode_for_crtc(struct drm_crtc_state *state,
 			     struct drm_display_mode *mode);

commit b837ba0ad95bb5c08626a49321f07f271bdaf512
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Tue Apr 26 16:11:35 2016 +0200

    drm/atomic: Rename drm_atomic_async_commit to nonblocking.
    
    Another step in renaming async to nonblocking for atomic commit.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1461679905-30177-3-git-send-email-maarten.lankhorst@linux.intel.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index d3eaa5df187a..92c84e9ab09a 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -137,7 +137,7 @@ drm_atomic_clean_old_fb(struct drm_device *dev, unsigned plane_mask, int ret);
 
 int __must_check drm_atomic_check_only(struct drm_atomic_state *state);
 int __must_check drm_atomic_commit(struct drm_atomic_state *state);
-int __must_check drm_atomic_async_commit(struct drm_atomic_state *state);
+int __must_check drm_atomic_nonblocking_commit(struct drm_atomic_state *state);
 
 #define for_each_connector_in_state(state, connector, connector_state, __i) \
 	for ((__i) = 0;							\

commit 14de6c44d149c68df1800ded42bbab51485ef67a
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Mon Jan 4 12:53:20 2016 +0100

    drm/atomic: Remove drm_atomic_connectors_for_crtc.
    
    Now that connector_mask is reliable there's no need for this
    function any more.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1451908400-25147-6-git-send-email-maarten.lankhorst@linux.intel.com
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index d8576ac55693..d3eaa5df187a 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -130,10 +130,6 @@ int __must_check
 drm_atomic_add_affected_planes(struct drm_atomic_state *state,
 			       struct drm_crtc *crtc);
 
-int
-drm_atomic_connectors_for_crtc(struct drm_atomic_state *state,
-			       struct drm_crtc *crtc);
-
 void drm_atomic_legacy_backoff(struct drm_atomic_state *state);
 
 void

commit 373701b1fc7d7c0013ae4fffd8103615c150751e
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Nov 24 21:21:55 2015 +0200

    drm: fix potential dangling else problems in for_each_ macros
    
    We have serious dangling else bugs waiting to happen in our for_each_
    style macros with ifs. Consider, for example,
    
     #define drm_for_each_plane_mask(plane, dev, plane_mask) \
             list_for_each_entry((plane), &(dev)->mode_config.plane_list, head) \
                     if ((plane_mask) & (1 << drm_plane_index(plane)))
    
    If this is used in context:
    
            if (condition)
                    drm_for_each_plane_mask(plane, dev, plane_mask);
            else
                    foo();
    
    foo() will be called for each plane *not* in plane_mask, if condition
    holds, and not at all if condition doesn't hold.
    
    Fix this by reversing the conditions in the macros, and adding an else
    branch for the "for each" block, so that other if/else blocks can't
    interfere. Provide a "for_each_if" helper macro to make it easier to get
    this right.
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1448392916-2281-1-git-send-email-jani.nikula@intel.com
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 4b74c97d297a..d8576ac55693 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -149,7 +149,7 @@ int __must_check drm_atomic_async_commit(struct drm_atomic_state *state);
 	     ((connector) = (state)->connectors[__i],			\
 	     (connector_state) = (state)->connector_states[__i], 1); 	\
 	     (__i)++)							\
-		if (connector)
+		for_each_if (connector)
 
 #define for_each_crtc_in_state(state, crtc, crtc_state, __i)	\
 	for ((__i) = 0;						\
@@ -157,7 +157,7 @@ int __must_check drm_atomic_async_commit(struct drm_atomic_state *state);
 	     ((crtc) = (state)->crtcs[__i],			\
 	     (crtc_state) = (state)->crtc_states[__i], 1);	\
 	     (__i)++)						\
-		if (crtc_state)
+		for_each_if (crtc_state)
 
 #define for_each_plane_in_state(state, plane, plane_state, __i)		\
 	for ((__i) = 0;							\
@@ -165,7 +165,7 @@ int __must_check drm_atomic_async_commit(struct drm_atomic_state *state);
 	     ((plane) = (state)->planes[__i],				\
 	     (plane_state) = (state)->plane_states[__i], 1);		\
 	     (__i)++)							\
-		if (plane_state)
+		for_each_if (plane_state)
 static inline bool
 drm_atomic_crtc_needs_modeset(struct drm_crtc_state *state)
 {

commit 0f45c26fc302c02b0576db37d4849baa53a2bb41
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Wed Nov 11 11:29:09 2015 +0100

    drm/atomic: add a drm_atomic_clean_old_fb helper.
    
    This is useful for all the boilerplate code about cleaning old_fb.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1447237751-9663-4-git-send-email-maarten.lankhorst@ubuntu.com

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index e67aeac2aee0..4b74c97d297a 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -136,6 +136,9 @@ drm_atomic_connectors_for_crtc(struct drm_atomic_state *state,
 
 void drm_atomic_legacy_backoff(struct drm_atomic_state *state);
 
+void
+drm_atomic_clean_old_fb(struct drm_device *dev, unsigned plane_mask, int ret);
+
 int __must_check drm_atomic_check_only(struct drm_atomic_state *state);
 int __must_check drm_atomic_commit(struct drm_atomic_state *state);
 int __must_check drm_atomic_async_commit(struct drm_atomic_state *state);

commit fc596660dd4e83f7f84e3cd7b25dc5e8e83000ef
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Tue Jul 21 13:28:57 2015 +0200

    drm/atomic: add connectors_changed to separate it from mode_changed, v2
    
    This can be a separate case from mode_changed, when connectors stay the
    same but only the mode is different. Drivers may choose to implement specific
    optimizations to prevent a full modeset for this case.
    
    Changes since v1:
    - Update kerneldocs slightly.
    
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Ander Conselvan de Oliveira <conselvan2@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 8a3a913320eb..e67aeac2aee0 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -166,7 +166,8 @@ int __must_check drm_atomic_async_commit(struct drm_atomic_state *state);
 static inline bool
 drm_atomic_crtc_needs_modeset(struct drm_crtc_state *state)
 {
-	return state->mode_changed || state->active_changed;
+	return state->mode_changed || state->active_changed ||
+	       state->connectors_changed;
 }
 
 

commit 2465ff6217f1b63e194cfd57018fa42abe7fcdf0
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jun 18 09:58:55 2015 +0200

    drm/atomic: Extract needs_modeset function
    
    We use the same check already in the atomic core, so might as well
    make this official. And it's also reused in e.g. i915.
    
    Motivated by Maarten's idea to extract a connector_changed state out
    of mode_changed.
    
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-By: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 1bbfedf466b9..8a3a913320eb 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -163,5 +163,11 @@ int __must_check drm_atomic_async_commit(struct drm_atomic_state *state);
 	     (plane_state) = (state)->plane_states[__i], 1);		\
 	     (__i)++)							\
 		if (plane_state)
+static inline bool
+drm_atomic_crtc_needs_modeset(struct drm_crtc_state *state)
+{
+	return state->mode_changed || state->active_changed;
+}
+
 
 #endif /* DRM_ATOMIC_H_ */

commit 60f207a5b6d8f23c2e8388b415e8d5c7311cc79d
Author: Andrey Ryabinin <a.ryabinin@samsung.com>
Date:   Mon May 25 13:29:44 2015 +0300

    drm/atomic: fix out of bounds read in for_each_*_in_state helpers
    
    for_each_*_in_state validate array index after
    access to array elements, thus perform out of bounds read.
    
    Fix this by validating index in the first place and read
    array element iff validation was successful.
    
    Fixes: df63b9994eaf ("drm/atomic: Add for_each_{connector,crtc,plane}_in_state helper macros")
    Signed-off-by: Andrey Ryabinin <a.ryabinin@samsung.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 55f46049e4a0..1bbfedf466b9 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -142,26 +142,26 @@ int __must_check drm_atomic_async_commit(struct drm_atomic_state *state);
 
 #define for_each_connector_in_state(state, connector, connector_state, __i) \
 	for ((__i) = 0;							\
-	     (connector) = (state)->connectors[__i],			\
-	     (connector_state) = (state)->connector_states[__i],	\
-	     (__i) < (state)->num_connector;				\
+	     (__i) < (state)->num_connector &&				\
+	     ((connector) = (state)->connectors[__i],			\
+	     (connector_state) = (state)->connector_states[__i], 1); 	\
 	     (__i)++)							\
 		if (connector)
 
 #define for_each_crtc_in_state(state, crtc, crtc_state, __i)	\
 	for ((__i) = 0;						\
-	     (crtc) = (state)->crtcs[__i],			\
-	     (crtc_state) = (state)->crtc_states[__i],		\
-	     (__i) < (state)->dev->mode_config.num_crtc;	\
+	     (__i) < (state)->dev->mode_config.num_crtc &&	\
+	     ((crtc) = (state)->crtcs[__i],			\
+	     (crtc_state) = (state)->crtc_states[__i], 1);	\
 	     (__i)++)						\
 		if (crtc_state)
 
-#define for_each_plane_in_state(state, plane, plane_state, __i)	\
-	for ((__i) = 0;						\
-	     (plane) = (state)->planes[__i],			\
-	     (plane_state) = (state)->plane_states[__i],	\
-	     (__i) < (state)->dev->mode_config.num_total_plane;	\
-	     (__i)++)						\
+#define for_each_plane_in_state(state, plane, plane_state, __i)		\
+	for ((__i) = 0;							\
+	     (__i) < (state)->dev->mode_config.num_total_plane &&	\
+	     ((plane) = (state)->planes[__i],				\
+	     (plane_state) = (state)->plane_states[__i], 1);		\
+	     (__i)++)							\
 		if (plane_state)
 
 #endif /* DRM_ATOMIC_H_ */

commit 955f3c334f0fb2b843efad5cc6d3b7e141e9d666
Author: Daniel Stone <daniels@collabora.com>
Date:   Mon May 25 19:11:52 2015 +0100

    drm/atomic: Add MODE_ID property
    
    Atomic modesetting: now with modesetting support.
    
    v2: Moved drm_atomic_set_mode_prop_for_crtc from previous patch; removed
        state->active fiddling, documented return code. Changed property
        type to DRM_MODE_PROP_BLOB.
    
    Signed-off-by: Daniel Stone <daniels@collabora.com>
    Tested-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 1e8c61f23294..55f46049e4a0 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -113,6 +113,9 @@ int __must_check
 drm_atomic_set_mode_for_crtc(struct drm_crtc_state *state,
 			     struct drm_display_mode *mode);
 int __must_check
+drm_atomic_set_mode_prop_for_crtc(struct drm_crtc_state *state,
+				  struct drm_property_blob *blob);
+int __must_check
 drm_atomic_set_crtc_for_plane(struct drm_plane_state *plane_state,
 			      struct drm_crtc *crtc);
 void drm_atomic_set_fb_for_plane(struct drm_plane_state *plane_state,

commit 819364da20fd914aba2fd03e95ee0467286752f5
Author: Daniel Stone <daniels@collabora.com>
Date:   Tue May 26 14:36:48 2015 +0100

    drm: Add drm_atomic_set_mode_for_crtc
    
    Add a new helper, to be used later for blob property management, that
    sets the mode for a CRTC state, as well as updating the CRTC enable/active
    state at the same time.
    
    v2: Do not touch active/mode_changed in CRTC state. Document return
        value. Remove stray drm_atomic_set_mode_prop_for_crtc declaration.
    
    v3: Remove i915 changes, and leave it directly bashing crtc_state->mode
        for the meantime.
    
    Signed-off-by: Daniel Stone <daniels@collabora.com>
    Tested-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index e89db0c377ba..1e8c61f23294 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -109,6 +109,9 @@ drm_atomic_get_existing_connector_state(struct drm_atomic_state *state,
 	return state->connector_states[index];
 }
 
+int __must_check
+drm_atomic_set_mode_for_crtc(struct drm_crtc_state *state,
+			     struct drm_display_mode *mode);
 int __must_check
 drm_atomic_set_crtc_for_plane(struct drm_plane_state *plane_state,
 			      struct drm_crtc *crtc);

commit e01e9f75a0c4e6cdbf1f139e37e9161408e49b7c
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Tue May 19 16:41:02 2015 +0200

    drm/atomic: add drm_atomic_add_affected_planes
    
    This is a convenience function to add all planes for a crtc,
    similar to add_affected_connectors. This will be used in
    drm_atomic_helper_check_modeset, but drivers can call it too
    when they need to recalculate all state.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    [danvet: Amend kerneldoc a bit.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index f0d3a7387d99..e89db0c377ba 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -120,6 +120,10 @@ drm_atomic_set_crtc_for_connector(struct drm_connector_state *conn_state,
 int __must_check
 drm_atomic_add_affected_connectors(struct drm_atomic_state *state,
 				   struct drm_crtc *crtc);
+int __must_check
+drm_atomic_add_affected_planes(struct drm_atomic_state *state,
+			       struct drm_crtc *crtc);
+
 int
 drm_atomic_connectors_for_crtc(struct drm_atomic_state *state,
 			       struct drm_crtc *crtc);

commit 036ef5733ba433760a3512bb5f7a155946e2df05
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Mon May 18 10:06:40 2015 +0200

    drm/atomic: Allow drivers to subclass drm_atomic_state, v3
    
    Drivers may need to store the state of shared resources, such as PLLs
    or FIFO space, into the atomic state. Allow this by making it possible
    to subclass drm_atomic_state.
    
    Changes since v1:
    - Change member names for functions to atomic_state_(alloc,clear)
    - Change __drm_atomic_state_new to drm_atomic_state_init
    - Allow free function to be overridden too, in case extra memory is
      allocated in alloc.
    Changes since v2:
    - Rename *_default_free to default_release, to make clear it doesn't
      free the state object itself.
    
    Cc: dri-devel@lists.freedesktop.org
    Acked-by: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index d78543067700..f0d3a7387d99 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -35,6 +35,11 @@ drm_atomic_state_alloc(struct drm_device *dev);
 void drm_atomic_state_clear(struct drm_atomic_state *state);
 void drm_atomic_state_free(struct drm_atomic_state *state);
 
+int  __must_check
+drm_atomic_state_init(struct drm_device *dev, struct drm_atomic_state *state);
+void drm_atomic_state_default_clear(struct drm_atomic_state *state);
+void drm_atomic_state_default_release(struct drm_atomic_state *state);
+
 struct drm_crtc_state * __must_check
 drm_atomic_get_crtc_state(struct drm_atomic_state *state,
 			  struct drm_crtc *crtc);

commit 1b26a5e1932beb34c4213934d8faf02217fc40e4
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Wed May 13 10:37:25 2015 +0200

    drm/atomic: add drm_atomic_get_existing_*_state helpers
    
    There are cases where we want to test if a given object is
    part of the state, but don't want to add them if they're not.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index c157103492b0..d78543067700 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -54,6 +54,56 @@ int drm_atomic_connector_set_property(struct drm_connector *connector,
 		struct drm_connector_state *state, struct drm_property *property,
 		uint64_t val);
 
+/**
+ * drm_atomic_get_existing_crtc_state - get crtc state, if it exists
+ * @state: global atomic state object
+ * @crtc: crtc to grab
+ *
+ * This function returns the crtc state for the given crtc, or NULL
+ * if the crtc is not part of the global atomic state.
+ */
+static inline struct drm_crtc_state *
+drm_atomic_get_existing_crtc_state(struct drm_atomic_state *state,
+				   struct drm_crtc *crtc)
+{
+	return state->crtc_states[drm_crtc_index(crtc)];
+}
+
+/**
+ * drm_atomic_get_existing_plane_state - get plane state, if it exists
+ * @state: global atomic state object
+ * @plane: plane to grab
+ *
+ * This function returns the plane state for the given plane, or NULL
+ * if the plane is not part of the global atomic state.
+ */
+static inline struct drm_plane_state *
+drm_atomic_get_existing_plane_state(struct drm_atomic_state *state,
+				    struct drm_plane *plane)
+{
+	return state->plane_states[drm_plane_index(plane)];
+}
+
+/**
+ * drm_atomic_get_existing_connector_state - get connector state, if it exists
+ * @state: global atomic state object
+ * @connector: connector to grab
+ *
+ * This function returns the connector state for the given connector,
+ * or NULL if the connector is not part of the global atomic state.
+ */
+static inline struct drm_connector_state *
+drm_atomic_get_existing_connector_state(struct drm_atomic_state *state,
+					struct drm_connector *connector)
+{
+	int index = drm_connector_index(connector);
+
+	if (index >= state->num_connector)
+		return NULL;
+
+	return state->connector_states[index];
+}
+
 int __must_check
 drm_atomic_set_crtc_for_plane(struct drm_plane_state *plane_state,
 			      struct drm_crtc *crtc);

commit df63b9994eaf942afcdb946d27a28661d7dfbf2a
Author: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
Date:   Fri Apr 10 14:58:39 2015 +0300

    drm/atomic: Add for_each_{connector,crtc,plane}_in_state helper macros
    
    This saves some typing whenever a iteration over all the connector,
    crtc or plane states in the atomic state is written, which happens
    quite often.
    
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 51168a8b723a..c157103492b0 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -75,4 +75,28 @@ int __must_check drm_atomic_check_only(struct drm_atomic_state *state);
 int __must_check drm_atomic_commit(struct drm_atomic_state *state);
 int __must_check drm_atomic_async_commit(struct drm_atomic_state *state);
 
+#define for_each_connector_in_state(state, connector, connector_state, __i) \
+	for ((__i) = 0;							\
+	     (connector) = (state)->connectors[__i],			\
+	     (connector_state) = (state)->connector_states[__i],	\
+	     (__i) < (state)->num_connector;				\
+	     (__i)++)							\
+		if (connector)
+
+#define for_each_crtc_in_state(state, crtc, crtc_state, __i)	\
+	for ((__i) = 0;						\
+	     (crtc) = (state)->crtcs[__i],			\
+	     (crtc_state) = (state)->crtc_states[__i],		\
+	     (__i) < (state)->dev->mode_config.num_crtc;	\
+	     (__i)++)						\
+		if (crtc_state)
+
+#define for_each_plane_in_state(state, plane, plane_state, __i)	\
+	for ((__i) = 0;						\
+	     (plane) = (state)->planes[__i],			\
+	     (plane_state) = (state)->plane_states[__i],	\
+	     (__i) < (state)->dev->mode_config.num_total_plane;	\
+	     (__i)++)						\
+		if (plane_state)
+
 #endif /* DRM_ATOMIC_H_ */

commit a97df1ccd3c30f16385696964767adf854878021
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Dec 18 22:49:02 2014 +0100

    drm/atomic: Hide drm.ko internal interfaces
    
    This is just a bit fallout from patch polishing and moving the
    get_prop logic fully into the core:
    - Drop EXPORT_SYMBOL and make the helpers static.
    - Drop kerneldoc since not used by drivers.
    - Move the cross-file function declarations only used by drm.ko
      internally to an internal header.
    
    v2: keep the gist of the comments, requested by Rob.
    
    Cc: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 231fb485abb3..51168a8b723a 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -41,30 +41,18 @@ drm_atomic_get_crtc_state(struct drm_atomic_state *state,
 int drm_atomic_crtc_set_property(struct drm_crtc *crtc,
 		struct drm_crtc_state *state, struct drm_property *property,
 		uint64_t val);
-int drm_atomic_crtc_get_property(struct drm_crtc *crtc,
-		const struct drm_crtc_state *state,
-		struct drm_property *property, uint64_t *val);
 struct drm_plane_state * __must_check
 drm_atomic_get_plane_state(struct drm_atomic_state *state,
 			   struct drm_plane *plane);
 int drm_atomic_plane_set_property(struct drm_plane *plane,
 		struct drm_plane_state *state, struct drm_property *property,
 		uint64_t val);
-int drm_atomic_plane_get_property(struct drm_plane *plane,
-		const struct drm_plane_state *state,
-		struct drm_property *property, uint64_t *val);
 struct drm_connector_state * __must_check
 drm_atomic_get_connector_state(struct drm_atomic_state *state,
 			       struct drm_connector *connector);
 int drm_atomic_connector_set_property(struct drm_connector *connector,
 		struct drm_connector_state *state, struct drm_property *property,
 		uint64_t val);
-int drm_atomic_connector_get_property(struct drm_connector *connector,
-		const struct drm_connector_state *state,
-		struct drm_property *property, uint64_t *val);
-
-int drm_atomic_get_property(struct drm_mode_object *obj,
-			   struct drm_property *property, uint64_t *val);
 
 int __must_check
 drm_atomic_set_crtc_for_plane(struct drm_plane_state *plane_state,

commit 88a48e297b3a3bac6022c03babfb038f1a886cea
Author: Rob Clark <robdclark@gmail.com>
Date:   Thu Dec 18 16:01:50 2014 -0500

    drm: add atomic properties
    
    Once a driver is using atomic helpers for modeset, the next step is to
    switch over to atomic properties.  To do this, make sure that any
    modeset objects have their ->atomic_{get,set}_property() vfuncs suitably
    populated if they have custom properties (you did already remember to
    plug in atomic-helper func for the legacy ->set_property() vfuncs,
    right?), and then set DRIVER_ATOMIC bit in driver_features flag.
    
    A new cap is introduced, DRM_CLIENT_CAP_ATOMIC, for the purposes of
    shielding legacy userspace from atomic properties.  Mostly for the
    benefit of legacy DDX drivers that do silly things like getting/setting
    each property at startup (since some of the new atomic properties will
    be able to trigger modeset).
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    [danvet: Squash in fixup patch to check for DRM_MODE_PROP_ATOMIC
    instaed of the CAP define when filtering properties. Reported by
    Tvrtko Uruslin, acked by Rob.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index d41233ccbc9e..231fb485abb3 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -63,6 +63,9 @@ int drm_atomic_connector_get_property(struct drm_connector *connector,
 		const struct drm_connector_state *state,
 		struct drm_property *property, uint64_t *val);
 
+int drm_atomic_get_property(struct drm_mode_object *obj,
+			   struct drm_property *property, uint64_t *val);
+
 int __must_check
 drm_atomic_set_crtc_for_plane(struct drm_plane_state *plane_state,
 			      struct drm_crtc *crtc);

commit ac9c925616028f1f03f631f229bca49b3a92ce9a
Author: Rob Clark <robdclark@gmail.com>
Date:   Thu Dec 18 16:01:47 2014 -0500

    drm: add atomic_get_property
    
    Since we won't be using the obj->properties->values[] array to shadow
    property values for atomic drivers, we are going to need a vfunc for
    getting prop values.  Add that along w/ mandatory wrapper fxns.
    
    v2: more comments and copypasta comment typo fix
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 51168a8b723a..d41233ccbc9e 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -41,18 +41,27 @@ drm_atomic_get_crtc_state(struct drm_atomic_state *state,
 int drm_atomic_crtc_set_property(struct drm_crtc *crtc,
 		struct drm_crtc_state *state, struct drm_property *property,
 		uint64_t val);
+int drm_atomic_crtc_get_property(struct drm_crtc *crtc,
+		const struct drm_crtc_state *state,
+		struct drm_property *property, uint64_t *val);
 struct drm_plane_state * __must_check
 drm_atomic_get_plane_state(struct drm_atomic_state *state,
 			   struct drm_plane *plane);
 int drm_atomic_plane_set_property(struct drm_plane *plane,
 		struct drm_plane_state *state, struct drm_property *property,
 		uint64_t val);
+int drm_atomic_plane_get_property(struct drm_plane *plane,
+		const struct drm_plane_state *state,
+		struct drm_property *property, uint64_t *val);
 struct drm_connector_state * __must_check
 drm_atomic_get_connector_state(struct drm_atomic_state *state,
 			       struct drm_connector *connector);
 int drm_atomic_connector_set_property(struct drm_connector *connector,
 		struct drm_connector_state *state, struct drm_property *property,
 		uint64_t val);
+int drm_atomic_connector_get_property(struct drm_connector *connector,
+		const struct drm_connector_state *state,
+		struct drm_property *property, uint64_t *val);
 
 int __must_check
 drm_atomic_set_crtc_for_plane(struct drm_plane_state *plane_state,

commit 40ecc694e114a06b9ed77e3e94641b0f5490693c
Author: Rob Clark <robdclark@gmail.com>
Date:   Thu Dec 18 16:01:46 2014 -0500

    drm: add atomic_set_property wrappers
    
    As we add properties for all the standard plane/crtc/connector
    attributes (in preperation for the atomic ioctl), we are going to want
    to handle core state in core (rather than per driver).  Intercepting the
    core properties will be easier if the atomic_set_property vfuncs are not
    called directly, but instead have a mandatory wrapper function (which
    will later serve as the point to intercept core properties).
    
    v2: more verbose comments and copypasta comment fix
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index e224ccfa11ca..51168a8b723a 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -38,12 +38,21 @@ void drm_atomic_state_free(struct drm_atomic_state *state);
 struct drm_crtc_state * __must_check
 drm_atomic_get_crtc_state(struct drm_atomic_state *state,
 			  struct drm_crtc *crtc);
+int drm_atomic_crtc_set_property(struct drm_crtc *crtc,
+		struct drm_crtc_state *state, struct drm_property *property,
+		uint64_t val);
 struct drm_plane_state * __must_check
 drm_atomic_get_plane_state(struct drm_atomic_state *state,
 			   struct drm_plane *plane);
+int drm_atomic_plane_set_property(struct drm_plane *plane,
+		struct drm_plane_state *state, struct drm_property *property,
+		uint64_t val);
 struct drm_connector_state * __must_check
 drm_atomic_get_connector_state(struct drm_atomic_state *state,
 			       struct drm_connector *connector);
+int drm_atomic_connector_set_property(struct drm_connector *connector,
+		struct drm_connector_state *state, struct drm_property *property,
+		uint64_t val);
 
 int __must_check
 drm_atomic_set_crtc_for_plane(struct drm_plane_state *plane_state,

commit 07cc0ef67fa873c8d21e0b626d57753bfd190095
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Nov 27 15:49:39 2014 +0100

    drm/atomic: Introduce state->obj backpointers
    
    Useful since this way we can pass around just the state objects and
    will get ther real object, too.
    
    Specifically this allows us to again simplify the parameters for
    set_crtc_for_plane.
    
    v2: msm already has it's own specific plane_reset hook, don't forget
    that one!
    
    v3: Fixup kerneldoc, reported by 0-day builder.
    
    Cc: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com> (v2)
    Tested-by: Rob Clark <robdclark@gmail.com> (v2)
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index ad2229574dd9..e224ccfa11ca 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -46,8 +46,8 @@ drm_atomic_get_connector_state(struct drm_atomic_state *state,
 			       struct drm_connector *connector);
 
 int __must_check
-drm_atomic_set_crtc_for_plane(struct drm_atomic_state *state,
-			      struct drm_plane *plane, struct drm_crtc *crtc);
+drm_atomic_set_crtc_for_plane(struct drm_plane_state *plane_state,
+			      struct drm_crtc *crtc);
 void drm_atomic_set_fb_for_plane(struct drm_plane_state *plane_state,
 				 struct drm_framebuffer *fb);
 int __must_check

commit 6ddd388ab222b66b596342becc76d5031c0e2fc8
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Nov 21 15:28:31 2014 -0500

    drm/atomic: track bitmask of planes attached to crtc
    
    Chasing plane->state->crtc of planes that are *not* part of the same
    atomic update is racy, making it incredibly awkward (or impossible) to
    do something simple like iterate over all planes and figure out which
    ones are attached to a crtc.
    
    Solve this by adding a bitmask of currently attached planes in the
    crtc-state.
    
    Note that the transitional helpers do not maintain the plane_mask.  But
    they only support the legacy ioctls, which have sufficient brute-force
    locking around plane updates that they can continue to loop over all
    planes to see what is attached to a crtc the old way.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    [danvet:
    - Drop comments about locking in set_crtc_for_plane since they're a
      bit misleading - we already should hold lock for the current crtc.
    - Also WARN_ON if get_state on the old crtc fails since that should
      have been done already.
    - Squash in fixup to check get_plane_state return value, reported by
      Dan Carpenter and acked by Rob Clark.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index e224ccfa11ca..ad2229574dd9 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -46,8 +46,8 @@ drm_atomic_get_connector_state(struct drm_atomic_state *state,
 			       struct drm_connector *connector);
 
 int __must_check
-drm_atomic_set_crtc_for_plane(struct drm_plane_state *plane_state,
-			      struct drm_crtc *crtc);
+drm_atomic_set_crtc_for_plane(struct drm_atomic_state *state,
+			      struct drm_plane *plane, struct drm_crtc *crtc);
 void drm_atomic_set_fb_for_plane(struct drm_plane_state *plane_state,
 				 struct drm_framebuffer *fb);
 int __must_check

commit 37cc0148773abbd8e7dbf8b2cb3399e887233fc2
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Nov 25 12:09:48 2014 +0100

    drm: Make drm_atomic.h standalone includible
    
    This header file makes use of a bunch of structures declared in the
    drm_crtc.h header file. Include that to make sure the drm_atomic.h
    header can be included standalone.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 9d919168bc11..e224ccfa11ca 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -28,6 +28,8 @@
 #ifndef DRM_ATOMIC_H_
 #define DRM_ATOMIC_H_
 
+#include <drm/drm_crtc.h>
+
 struct drm_atomic_state * __must_check
 drm_atomic_state_alloc(struct drm_device *dev);
 void drm_atomic_state_clear(struct drm_atomic_state *state);

commit 321ebf04dc7ab5c54d658f93db0ffe35277664ab
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Nov 4 22:57:27 2014 +0100

    drm/atomic: Refcounting for plane_state->fb
    
    So my original plan was that the drm core refcounts framebuffers like
    with the legacy ioctls. But that doesn't work for a bunch of reasons:
    
    - State objects might live longer than until the next fb change
      happens for a plane. For example delayed cleanup work only happens
      _after_ the pageflip ioctl has completed. So this definitely doesn't
      work without the plane state holding its own references.
    
    - The other issue is transition from legacy to atomic implementations,
      where the driver works under a mix of both worlds. Which means
      legacy paths might not properly update the ->fb pointer under
      plane->state->fb. Which is a bit a problem when then someone comes
      around and _does_ try to clean it up when it's long gone.
    
    The second issue is just a bit a transition bug, since drivers should
    update plane->state->fb in all the paths that aren't converted yet.
    But a bit more robustness for the transition can't hurt - we pull
    similar tricks with cleaning up the old fb in the transitional helpers
    already.
    
    The pattern for drivers that transition is
    
            if (plane->state)
                    drm_atomic_set_fb_for_plane(plane->state, plane->fb);
    
    inserted after the fb update has logically completed at the end of
    ->set_config (or ->set_base/mode_set if using the crtc helpers),
    ->page_flip, ->update_plane or any other entry point which updates
    plane->fb.
    
    v2: Update kerneldoc - copypasta fail.
    
    v3: Fix spelling in the commit message (Sean).
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index 5bb15f550c42..9d919168bc11 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -46,6 +46,8 @@ drm_atomic_get_connector_state(struct drm_atomic_state *state,
 int __must_check
 drm_atomic_set_crtc_for_plane(struct drm_plane_state *plane_state,
 			      struct drm_crtc *crtc);
+void drm_atomic_set_fb_for_plane(struct drm_plane_state *plane_state,
+				 struct drm_framebuffer *fb);
 int __must_check
 drm_atomic_set_crtc_for_connector(struct drm_connector_state *conn_state,
 				  struct drm_crtc *crtc);

commit cc4ceb484b37b9369e0d4e8682b7ae1849ae4579
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jul 25 21:30:38 2014 +0200

    drm: Global atomic state handling
    
    Some differences compared to Rob's patches again:
    - Dropped the committed and checked booleans. Checking will be
      internally enforced by always calling ->atomic_check before
      ->atomic_commit. And async handling needs to be solved differently
      because the current scheme completely side-steps ww mutex deadlock
      avoidance (and so either reinvents a new deadlock avoidance wheel or
      like the current code just deadlocks).
    
    - State for connectors needed to be added, since now they have a
      full-blown drm_connector_state (so that drivers have something to
      attach their own stuff to).
    
    - Refcounting is gone. I plane to solve async updates differently,
      since the lock-passing scheme doesn't cut it (since it abuses ww
      mutexes). Essentially what we need for async is a simple ownership
      transfer from the caller to the driver. That doesn't need full-blown
      refcounting.
    
    - The acquire ctx is a pointer. Real atomic callers should have that
      on their stack, legacy entry points need to put the right one
      (obtained by drm_modeset_legacy_acuire_ctx) in there.
    
    - I've dropped all hooks except check/commit. All the begin/end
      handling is done by core functions and is the same.
    
    - commit/check are just thin wrappers that ensure that ->check is
      always called.
    
    - To help out with locking in the legacy implementations I've added a
      helper to just grab all locks in the backoff case.
    
    v2: Add notices that check/commit can fail with EDEADLK.
    
    v3:
    - More consistent naming for state_alloc.
    - Add state_clear which is needed for backoff and retry.
    
    v4: Planes/connectors can switch between crtcs, and we need to be
    careful that we grab the state (and locks) for both the old and new
    crtc. Improve the interface functions to ensure this.
    
    v5: Add functions to grab affected connectors for a crtc and to recompute
    the crtc->enable state. This is useful for both helper and atomic ioctl
    code when e.g. removing a connector.
    
    v6: Squash in fixup from Fengguang to use ERR_CAST.
    
    v7: Add debug output.
    
    v8: Make checkpatch happy about kcalloc argument ordering.
    
    v9: Improve kerneldoc in drm_crtc.h
    
    v10:
    - Fix another kcalloc argument misorder I've missed.
    - More polish for kerneldoc.
    
    v11: Clarify the ownership rules for the state object. The new rule is
    that a successful drm_atomic_commit (whether synchronous or asnyc)
    always inherits the state and is responsible for the clean-up. That
    way async and sync ->commit functions are more similar.
    
    v12: A few bugfixes:
    - Assign state->state pointers correctly when grabbing state objects -
      we need to link them up with the global state.
    - Handle a NULL crtc in set_crtc_for_plane to simplify code flow a bit
      for the callers of this function.
    
    v13: Review from Sean:
    - kerneldoc spelling fixes
    - Don't overallocate states->planes.
    - Handle NULL crtc in set_crtc_for_connector.
    
    v14: Sprinkle __must_check over all functions which do wait/wound
    locking to make sure callers don't forget this. Since I have ;-)
    
    v15: Be more explicit in the kerneldoc when functions can return
    -EDEADLK what to do. And that every other -errno is fatal.
    
    v16: Indent with tabs instead of space, spotted by Ander.
    
    v17: Review from Thierry, small kerneldoc and other naming polish.
    
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Ander Conselvan de Oliveira <conselvan2@gmail.com>
    Cc: Daniel Thompson <daniel.thompson@linaro.org>
    Cc: Fengguang Wu <fengguang.wu@intel.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: Matt Roper <matthew.d.roper@intel.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
new file mode 100644
index 000000000000..5bb15f550c42
--- /dev/null
+++ b/include/drm/drm_atomic.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2014 Red Hat
+ * Copyright (C) 2014 Intel Corp.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ * Rob Clark <robdclark@gmail.com>
+ * Daniel Vetter <daniel.vetter@ffwll.ch>
+ */
+
+#ifndef DRM_ATOMIC_H_
+#define DRM_ATOMIC_H_
+
+struct drm_atomic_state * __must_check
+drm_atomic_state_alloc(struct drm_device *dev);
+void drm_atomic_state_clear(struct drm_atomic_state *state);
+void drm_atomic_state_free(struct drm_atomic_state *state);
+
+struct drm_crtc_state * __must_check
+drm_atomic_get_crtc_state(struct drm_atomic_state *state,
+			  struct drm_crtc *crtc);
+struct drm_plane_state * __must_check
+drm_atomic_get_plane_state(struct drm_atomic_state *state,
+			   struct drm_plane *plane);
+struct drm_connector_state * __must_check
+drm_atomic_get_connector_state(struct drm_atomic_state *state,
+			       struct drm_connector *connector);
+
+int __must_check
+drm_atomic_set_crtc_for_plane(struct drm_plane_state *plane_state,
+			      struct drm_crtc *crtc);
+int __must_check
+drm_atomic_set_crtc_for_connector(struct drm_connector_state *conn_state,
+				  struct drm_crtc *crtc);
+int __must_check
+drm_atomic_add_affected_connectors(struct drm_atomic_state *state,
+				   struct drm_crtc *crtc);
+int
+drm_atomic_connectors_for_crtc(struct drm_atomic_state *state,
+			       struct drm_crtc *crtc);
+
+void drm_atomic_legacy_backoff(struct drm_atomic_state *state);
+
+int __must_check drm_atomic_check_only(struct drm_atomic_state *state);
+int __must_check drm_atomic_commit(struct drm_atomic_state *state);
+int __must_check drm_atomic_async_commit(struct drm_atomic_state *state);
+
+#endif /* DRM_ATOMIC_H_ */
