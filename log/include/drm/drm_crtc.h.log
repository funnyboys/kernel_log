commit 7fe3f0d15aac6c98a97e6d7086f5a6b7bc4ccae4
Author: Thomas Zimmermann <tzimmermann@suse.de>
Date:   Thu Jan 23 14:59:24 2020 +0100

    drm: Add get_vblank_timestamp() to struct drm_crtc_funcs
    
    The callback get_vblank_timestamp() is currently located in struct
    drm_driver, but really belongs into struct drm_crtc_funcs. Add an
    equivalent there. Driver will be converted in separate patches.
    
    The default implementation is drm_calc_vbltimestamp_from_scanoutpos().
    The patch adds drm_crtc_vblank_helper_get_vblank_timestamp(), which is
    an implementation for the CRTC callback.
    
    v4:
            * more readable code for setting high_prec (Ville, Jani)
    v3:
            * use refactored timestamp calculation to minimize duplicated code
            * do more checks for crtc != NULL to support legacy drivers
    v2:
            * rename helper to drm_crtc_vblank_helper_get_vblank_timestamp()
            * replace drm_calc_vbltimestamp_from_scanoutpos() with
              drm_crtc_vblank_helper_get_vblank_timestamp() in docs
    
    Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200123135943.24140-4-tzimmermann@suse.de

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 6bef2f41d4d7..59b51a09cae6 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -887,6 +887,47 @@ struct drm_crtc_funcs {
 	 * new drivers as the replacement of &drm_driver.disable_vblank hook.
 	 */
 	void (*disable_vblank)(struct drm_crtc *crtc);
+
+	/**
+	 * @get_vblank_timestamp:
+	 *
+	 * Called by drm_get_last_vbltimestamp(). Should return a precise
+	 * timestamp when the most recent vblank interval ended or will end.
+	 *
+	 * Specifically, the timestamp in @vblank_time should correspond as
+	 * closely as possible to the time when the first video scanline of
+	 * the video frame after the end of vblank will start scanning out,
+	 * the time immediately after end of the vblank interval. If the
+	 * @crtc is currently inside vblank, this will be a time in the future.
+	 * If the @crtc is currently scanning out a frame, this will be the
+	 * past start time of the current scanout. This is meant to adhere
+	 * to the OpenML OML_sync_control extension specification.
+	 *
+	 * Parameters:
+	 *
+	 * crtc:
+	 *     CRTC for which timestamp should be returned.
+	 * max_error:
+	 *     Maximum allowable timestamp error in nanoseconds.
+	 *     Implementation should strive to provide timestamp
+	 *     with an error of at most max_error nanoseconds.
+	 *     Returns true upper bound on error for timestamp.
+	 * vblank_time:
+	 *     Target location for returned vblank timestamp.
+	 * in_vblank_irq:
+	 *     True when called from drm_crtc_handle_vblank().  Some drivers
+	 *     need to apply some workarounds for gpu-specific vblank irq quirks
+	 *     if flag is set.
+	 *
+	 * Returns:
+	 *
+	 * True on success, false on failure, which means the core should
+	 * fallback to a simple timestamp taken in drm_crtc_handle_vblank().
+	 */
+	bool (*get_vblank_timestamp)(struct drm_crtc *crtc,
+				     int *max_error,
+				     ktime_t *vblank_time,
+				     bool in_vblank_irq);
 };
 
 /**
@@ -994,11 +1035,12 @@ struct drm_crtc {
 	 * Programmed mode in hw, after adjustments for encoders, crtc, panel
 	 * scaling etc. Should only be used by legacy drivers, for high
 	 * precision vblank timestamps in
-	 * drm_calc_vbltimestamp_from_scanoutpos().
+	 * drm_crtc_vblank_helper_get_vblank_timestamp().
 	 *
 	 * Note that atomic drivers should not use this, but instead use
 	 * &drm_crtc_state.adjusted_mode. And for high-precision timestamps
-	 * drm_calc_vbltimestamp_from_scanoutpos() used &drm_vblank_crtc.hwmode,
+	 * drm_crtc_vblank_helper_get_vblank_timestamp() used
+	 * &drm_vblank_crtc.hwmode,
 	 * which is filled out by calling drm_calc_timestamping_constants().
 	 */
 	struct drm_display_mode hwmode;

commit 7beb691f1e6f349c9df3384a85e7a53c5601aaaf
Author: Thomas Zimmermann <tzimmermann@suse.de>
Date:   Wed Jan 29 13:05:17 2020 +0100

    drm: Initialize struct drm_crtc_state.no_vblank from device settings
    
    At the end of a commit, atomic helpers can generate a fake VBLANK event
    automatically. Originally implemented for writeback connectors, the
    functionality can be used by any driver and/or hardware without proper
    VBLANK interrupt.
    
    The patch updates the documentation to make this behaviour official:
    settings struct drm_crtc_state.no_vblank to true enables automatic
    generation of fake VBLANK events.
    
    The new interface drm_dev_has_vblank() returns true if vblanking has
    been initialized for a device, or false otherwise. Atomic helpers use
    this function when initializing no_vblank in the CRTC state in
    drm_atomic_helper_check_modeset(). If vblanking has been initialized
    for a device, no_blank is disabled. Otherwise it's enabled. Hence,
    atomic helpers will automatically send out fake VBLANK events with any
    driver that did not initialize vblanking.
    
    v5:
            * more precise documentation and commit message
    v4:
            * replace drm_crtc_has_vblank() with drm_dev_has_vblank()
            * add drm_dev_has_vblank() in this patch
            * move driver changes into separate patches
    v3:
            * squash all related changes patches into this patch
    
    Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
    Acked-by: Gerd Hoffmann <kraxel@redhat.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200129120531.6891-2-tzimmermann@suse.de

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 5e9b15a0e8c5..6bef2f41d4d7 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -174,12 +174,25 @@ struct drm_crtc_state {
 	 * @no_vblank:
 	 *
 	 * Reflects the ability of a CRTC to send VBLANK events. This state
-	 * usually depends on the pipeline configuration, and the main usuage
-	 * is CRTCs feeding a writeback connector operating in oneshot mode.
-	 * In this case the VBLANK event is only generated when a job is queued
-	 * to the writeback connector, and we want the core to fake VBLANK
-	 * events when this part of the pipeline hasn't changed but others had
-	 * or when the CRTC and connectors are being disabled.
+	 * usually depends on the pipeline configuration. If set to true, DRM
+	 * atomic helpers will send out a fake VBLANK event during display
+	 * updates after all hardware changes have been committed. This is
+	 * implemented in drm_atomic_helper_fake_vblank().
+	 *
+	 * One usage is for drivers and/or hardware without support for VBLANK
+	 * interrupts. Such drivers typically do not initialize vblanking
+	 * (i.e., call drm_vblank_init() with the number of CRTCs). For CRTCs
+	 * without initialized vblanking, this field is set to true in
+	 * drm_atomic_helper_check_modeset(), and a fake VBLANK event will be
+	 * send out on each update of the display pipeline by
+	 * drm_atomic_helper_fake_vblank().
+	 *
+	 * Another usage is CRTCs feeding a writeback connector operating in
+	 * oneshot mode. In this case the fake VBLANK event is only generated
+	 * when a job is queued to the writeback connector, and we want the
+	 * core to fake VBLANK events when this part of the pipeline hasn't
+	 * changed but others had or when the CRTC and connectors are being
+	 * disabled.
 	 *
 	 * __drm_atomic_helper_crtc_duplicate_state() will not reset the value
 	 * from the current state, the CRTC driver is then responsible for
@@ -335,7 +348,14 @@ struct drm_crtc_state {
 	 *  - Events for disabled CRTCs are not allowed, and drivers can ignore
 	 *    that case.
 	 *
-	 * This can be handled by the drm_crtc_send_vblank_event() function,
+	 * For very simple hardware without VBLANK interrupt, enabling
+	 * &struct drm_crtc_state.no_vblank makes DRM's atomic commit helpers
+	 * send a fake VBLANK event at the end of the display update after all
+	 * hardware changes have been applied. See
+	 * drm_atomic_helper_fake_vblank().
+	 *
+	 * For more complex hardware this
+	 * can be handled by the drm_crtc_send_vblank_event() function,
 	 * which the driver should call on the provided event upon completion of
 	 * the atomic commit. Note that if the driver supports vblank signalling
 	 * and timestamping the vblank counters and timestamps must agree with

commit 4092de1ba34eb376791809fb366bc15f8a9e0b7c
Merge: a00d17e0a71a 54ecb8f7028c
Author: Maxime Ripard <mripard@kernel.org>
Date:   Thu Oct 3 16:38:50 2019 +0200

    Merge drm/drm-next into drm-misc-next
    
    We haven't done any backmerge for a while due to the merge window, and it
    starts to become an issue for komeda. Let's bring 5.4-rc1 in.
    
    Signed-off-by: Maxime Ripard <mripard@kernel.org>

commit 2d2e0b90a08f1e3a47b3ee852b27c219295423ef
Author: Sean Paul <seanpaul@chromium.org>
Date:   Wed Sep 18 16:07:28 2019 -0400

    drm: Fix kerneldoc and remove unused struct member in self_refresh helper
    
    Artifacts of previous revisions.
    
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link to v1: https://patchwork.freedesktop.org/patch/msgid/20190917200443.64481-1-sean@poorly.run
    Link: https://patchwork.freedesktop.org/patch/msgid/20190918200734.149876-1-sean@poorly.run
    
    Changes in v2:
    - None

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c4528eb5d168..408b6f4e63c0 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1108,7 +1108,7 @@ struct drm_crtc {
 	/**
 	 * @self_refresh_data: Holds the state for the self refresh helpers
 	 *
-	 * Initialized via drm_self_refresh_helper_register().
+	 * Initialized via drm_self_refresh_helper_init().
 	 */
 	struct drm_self_refresh_data *self_refresh_data;
 };

commit 4d85f45c73a22bc0ee900c7505b7210a87a7966d
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Sep 3 21:06:42 2019 +0200

    drm/atomic: Rename crtc_state->pageflip_flags to async_flip
    
    It's the only flag anyone actually cares about. Plus if we're unlucky,
    the atomic ioctl might need a different flag for async flips. So
    better to abstract this away from the uapi a bit.
    
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Michel Dänzer <michel@daenzer.net>
    Cc: Alex Deucher <alexdeucher@gmail.com>
    Cc: Adam Jackson <ajax@redhat.com>
    Cc: Sean Paul <sean@poorly.run>
    Cc: David Airlie <airlied@linux.ie>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Cc: Leo Li <sunpeng.li@amd.com>
    Cc: Harry Wentland <harry.wentland@amd.com>
    Cc: David Francis <David.Francis@amd.com>
    Cc: Mario Kleiner <mario.kleiner.de@gmail.com>
    Cc: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: "Christian König" <christian.koenig@amd.com>
    Cc: Ilia Mirkin <imirkin@alum.mit.edu>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190903190642.32588-3-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 7d14c11bdc0a..c4528eb5d168 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -285,12 +285,12 @@ struct drm_crtc_state {
 	u32 target_vblank;
 
 	/**
-	 * @pageflip_flags:
+	 * @async_flip:
 	 *
-	 * DRM_MODE_PAGE_FLIP_* flags, as passed to the page flip ioctl.
-	 * Zero in any other case.
+	 * This is set when DRM_MODE_PAGE_FLIP_ASYNC is set in the legacy
+	 * PAGE_FLIP IOCTL. It's not wired up for the atomic IOCTL itself yet.
 	 */
-	u32 pageflip_flags;
+	bool async_flip;
 
 	/**
 	 * @vrr_enabled:

commit ee68c743f8d0747585b4c0c171c039d6635bda7c
Author: Boris Brezillon <boris.brezillon@collabora.com>
Date:   Mon Aug 26 17:26:29 2019 +0200

    drm: Stop including drm_bridge.h from drm_crtc.h
    
    We are about to add a drm_bridge_state that inherits from
    drm_private_state which is defined in drm_atomic.h. Problem is,
    drm_atomic.h includes drm_crtc.h which in turn includes drm_bridge.h,
    leading to "drm_private_state has incomplete type" error.
    
    Let's force all users of the drm_bridge API to explicitly include
    drm_bridge.h.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@collabora.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190826152649.13820-2-boris.brezillon@collabora.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 7d14c11bdc0a..7e2963cad543 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -41,7 +41,6 @@
 #include <drm/drm_connector.h>
 #include <drm/drm_device.h>
 #include <drm/drm_property.h>
-#include <drm/drm_bridge.h>
 #include <drm/drm_edid.h>
 #include <drm/drm_plane.h>
 #include <drm/drm_blend.h>

commit 178e5f3a5bc1d67d1248a74c0abab41040abe7c4
Author: Brian Starkey <brian.starkey@arm.com>
Date:   Tue Aug 6 13:46:22 2019 +0100

    drm/crc-debugfs: Add notes about CRC<->commit interactions
    
    CRC generation can be impacted by commits coming from userspace, and
    enabling CRC generation may itself trigger a commit. Add notes about
    this to the kerneldoc.
    
    Changes since v1:
     - Clarified that anything that would disable CRCs counts as a full
       modeset, and so userspace needs to reconfigure after full modesets
    
    Changes since v2:
     - Add these notes
     - Rebase onto drm-misc-next (trivial conflict in comment)
    
    Signed-off-by: Brian Starkey <brian.starkey@arm.com>
    Signed-off-by: Ayan Kumar Halder <ayan.halder@arm.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    
    Link:- https://patchwork.freedesktop.org/patch/321974/

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 128d8b210621..7d14c11bdc0a 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -756,6 +756,9 @@ struct drm_crtc_funcs {
 	 * provided from the configured source. Drivers must accept an "auto"
 	 * source name that will select a default source for this CRTC.
 	 *
+	 * This may trigger an atomic modeset commit if necessary, to enable CRC
+	 * generation.
+	 *
 	 * Note that "auto" can depend upon the current modeset configuration,
 	 * e.g. it could pick an encoder or output specific CRC sampling point.
 	 *
@@ -767,6 +770,7 @@ struct drm_crtc_funcs {
 	 * 0 on success or a negative error code on failure.
 	 */
 	int (*set_crc_source)(struct drm_crtc *crtc, const char *source);
+
 	/**
 	 * @verify_crc_source:
 	 *

commit 1452c25b0e60278820f3d2155c65f1bfcce5ee79
Author: Sean Paul <seanpaul@chromium.org>
Date:   Wed Jun 12 10:50:19 2019 -0400

    drm: Add helpers to kick off self refresh mode in drivers
    
    This patch adds a new drm helper library to help drivers implement
    self refresh. Drivers choosing to use it will register crtcs and
    will receive callbacks when it's time to enter or exit self refresh
    mode.
    
    In its current form, it has a timer which will trigger after a
    driver-specified amount of inactivity. When the timer triggers, the
    helpers will submit a new atomic commit to shut the refreshing pipe
    off. On the next atomic commit, the drm core will revert the self
    refresh state and bring everything back up to be actively driven.
    
    From the driver's perspective, this works like a regular disable/enable
    cycle. The driver need only check the 'self_refresh_active' state in
    crtc_state. It should initiate self refresh mode on the panel and enter
    an off or low-power state.
    
    Changes in v2:
    - s/psr/self_refresh/ (Daniel)
    - integrated the psr exit into the commit that wakes it up (Jose/Daniel)
    - made the psr state per-crtc (Jose/Daniel)
    Changes in v3:
    - Remove the self_refresh_(active|changed) from connector state (Daniel)
    - Simplify loop in drm_self_refresh_helper_alter_state (Daniel)
    - Improve self_refresh_aware comment (Daniel)
    - s/self_refresh_state/self_refresh_data/ (Daniel)
    Changes in v4:
    - Move docbook location below panel (Daniel)
    - Improve docbook with references and more detailed explanation (Daniel)
    - Instead of register/unregister, use init/cleanup (Daniel)
    Changes in v5:
    - Resolved conflict in drm_atomic_helper.c #include block
    - Resolved conflict in rst with HDCP helper docs
    Changes in v6:
    - Fix include ordering, clean up forward declarations (Sam)
    
    Link to v1: https://patchwork.freedesktop.org/patch/msgid/20190228210939.83386-2-sean@poorly.run
    Link to v2: https://patchwork.freedesktop.org/patch/msgid/20190326204509.96515-1-sean@poorly.run
    Link to v3: https://patchwork.freedesktop.org/patch/msgid/20190502194956.218441-6-sean@poorly.run
    Link to v4: https://patchwork.freedesktop.org/patch/msgid/20190508160920.144739-6-sean@poorly.run
    Link to v5: https://patchwork.freedesktop.org/patch/msgid/20190611160844.257498-6-sean@poorly.run
    
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Jose Souza <jose.souza@intel.com>
    Cc: Zain Wang <wzz@rock-chips.com>
    Cc: Tomasz Figa <tfiga@chromium.org>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Reviewed-by: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190612145026.191846-1-sean@poorly.run

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index dc42b9e35333..128d8b210621 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -54,6 +54,7 @@ struct drm_mode_set;
 struct drm_file;
 struct drm_clip_rect;
 struct drm_printer;
+struct drm_self_refresh_data;
 struct device_node;
 struct dma_fence;
 struct edid;
@@ -300,6 +301,17 @@ struct drm_crtc_state {
 	 */
 	bool vrr_enabled;
 
+	/**
+	 * @self_refresh_active:
+	 *
+	 * Used by the self refresh helpers to denote when a self refresh
+	 * transition is occurring. This will be set on enable/disable callbacks
+	 * when self refresh is being enabled or disabled. In some cases, it may
+	 * not be desirable to fully shut off the crtc during self refresh.
+	 * CRTC's can inspect this flag and determine the best course of action.
+	 */
+	bool self_refresh_active;
+
 	/**
 	 * @event:
 	 *
@@ -1088,6 +1100,13 @@ struct drm_crtc {
 	 * The name of the CRTC's fence timeline.
 	 */
 	char timeline_name[32];
+
+	/**
+	 * @self_refresh_data: Holds the state for the self refresh helpers
+	 *
+	 * Initialized via drm_self_refresh_helper_register().
+	 */
+	struct drm_self_refresh_data *self_refresh_data;
 };
 
 /**

commit 75f3f70f0462f443283e66d8448bed9330073178
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Jun 8 10:02:35 2019 +0200

    drm: drm_crtc.h self-contained
    
    While removing drmP.h from drm/radeon a few files ended
    up including drm_crtc.h as the first file.
    This failed build due to a missing dependency in drm_crtc.h.
    
    Add the missing include file.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: Sean Paul <sean@poorly.run>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190608080241.4958-2-sam@ravnborg.org

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 58ad983d7cd6..dc42b9e35333 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -39,6 +39,7 @@
 #include <drm/drm_framebuffer.h>
 #include <drm/drm_modes.h>
 #include <drm/drm_connector.h>
+#include <drm/drm_device.h>
 #include <drm/drm_property.h>
 #include <drm/drm_bridge.h>
 #include <drm/drm_edid.h>

commit bb10211058880b14da5ec2ff927ff7d3b424aa05
Author: Kieran Bingham <kieran.bingham+renesas@ideasonboard.com>
Date:   Thu Mar 14 22:04:18 2019 +0000

    drm: Fix subtle spelling error in drm_crtc_state
    
    The drm_crtc_state documentation contains a subtle misspelling of the
    word subtle. Correct it.
    
    Signed-off-by: Kieran Bingham <kieran.bingham+renesas@ideasonboard.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Reviewed-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f7c3022dbdf4..58ad983d7cd6 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -78,7 +78,7 @@ struct drm_plane_helper_funcs;
 /**
  * struct drm_crtc_state - mutable CRTC state
  *
- * Note that the distinction between @enable and @active is rather subtile:
+ * Note that the distinction between @enable and @active is rather subtle:
  * Flipping @active while @enable is set without changing anything else may
  * never return in a failure from the &drm_mode_config_funcs.atomic_check
  * callback. Userspace assumes that a DPMS On will always succeed. In other

commit b49996cb304ae85b63526791b76f5aec3dae8e9c
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Thu Feb 28 13:25:43 2019 +0100

    drm/doc: Fix copy paste error in drm_crtc_funcs.destroy()
    
    The function is about cleaning up CRTC resources, not plane resources,
    fix this in docbook.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 85abd3fe9e83..f7c3022dbdf4 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -472,7 +472,7 @@ struct drm_crtc_funcs {
 	/**
 	 * @destroy:
 	 *
-	 * Clean up plane resources. This is only called at driver unload time
+	 * Clean up CRTC resources. This is only called at driver unload time
 	 * through drm_mode_config_cleanup() since a CRTC cannot be hotplugged
 	 * in DRM.
 	 */

commit c2d88e06bcb98540bb83fac874574eaa4f320363
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Dec 17 20:43:00 2018 +0100

    drm: Move the legacy kms disable_all helper to crtc helpers
    
    It's not a core function, and the matching atomic functions are also
    not in the core. Plus the suspend/resume helper is also already there.
    
    Needs a tiny bit of open-coding, but less midlayer beats that I think.
    
    v2: Rebase onto ast (which gained a new user).
    
    Cc: Sam Bobroff <sbobroff@linux.ibm.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Sean Paul <sean@poorly.run>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: Sean Paul <sean@poorly.run>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian König" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: Rex Zhu <Rex.Zhu@amd.com>
    Cc: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
    Cc: Huang Rui <ray.huang@amd.com>
    Cc: Shaoyun Liu <Shaoyun.Liu@amd.com>
    Cc: Monk Liu <Monk.Liu@amd.com>
    Cc: nouveau@lists.freedesktop.org
    Cc: amd-gfx@lists.freedesktop.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20181217194303.14397-4-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b45bec0b7a9c..85abd3fe9e83 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1149,8 +1149,6 @@ static inline uint32_t drm_crtc_mask(const struct drm_crtc *crtc)
 	return 1 << drm_crtc_index(crtc);
 }
 
-int drm_crtc_force_disable_all(struct drm_device *dev);
-
 int drm_mode_set_config_internal(struct drm_mode_set *set);
 struct drm_crtc *drm_crtc_from_index(struct drm_device *dev, int idx);
 

commit 23d19ba06b9c5614d6457f5fed349ec8f6d4dac9
Merge: 7d0250ed8e69 e3d093070eb0
Author: Maxime Ripard <maxime.ripard@bootlin.com>
Date:   Fri Jan 11 16:32:10 2019 +0100

    Merge drm/drm-next into drm-misc-next
    
    drm-next has been forwarded to 5.0-rc1, and we need it to apply the damage
    helper for dirtyfb series from Noralf Trønnes.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>

commit 1e9080ac21d182913df404d634a7c847af5e35be
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Dec 17 20:42:59 2018 +0100

    drm: Unexport drm_crtc_force_disable
    
    It's a legacy kms only thing, good to hide it better now that all
    those old drivers use the legacy crtc helpers directly.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: Sean Paul <sean@poorly.run>
    Cc: David Airlie <airlied@linux.ie>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181217194303.14397-3-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b21437bc95bf..b955ef1f1e3e 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1140,7 +1140,6 @@ static inline uint32_t drm_crtc_mask(const struct drm_crtc *crtc)
 	return 1 << drm_crtc_index(crtc);
 }
 
-int drm_crtc_force_disable(struct drm_crtc *crtc);
 int drm_crtc_force_disable_all(struct drm_device *dev);
 
 int drm_mode_set_config_internal(struct drm_mode_set *set);

commit 1398958cfd8d331342d657d37151791dd7256b40
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Thu Oct 4 11:46:07 2018 -0400

    drm: Add vrr_enabled property to drm CRTC
    
    This patch introduces the 'vrr_enabled' CRTC property to allow
    dynamic control over variable refresh rate support for a CRTC.
    
    This property should be treated like a content hint to the driver -
    if the hardware or driver is not capable of driving variable refresh
    timings then this is not considered an error.
    
    Capability for variable refresh rate support should be determined
    by querying the vrr_capable drm connector property.
    
    It is worth noting that while the property is intended for atomic use
    it isn't filtered from legacy userspace queries. This allows for Xorg
    userspace drivers to implement support.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b21437bc95bf..39c3900aab3c 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -290,6 +290,15 @@ struct drm_crtc_state {
 	 */
 	u32 pageflip_flags;
 
+	/**
+	 * @vrr_enabled:
+	 *
+	 * Indicates if variable refresh rate should be enabled for the CRTC.
+	 * Support for the requested vrr state will depend on driver and
+	 * hardware capabiltiy - lacking support is not treated as failure.
+	 */
+	bool vrr_enabled;
+
 	/**
 	 * @event:
 	 *

commit c0811a7d5befe34a17772760100e26b09a561c0e
Author: Mahesh Kumar <mahesh1.kumar@intel.com>
Date:   Tue Aug 21 14:08:56 2018 +0530

    drm/crc: Cleanup crtc_crc_open function
    
    This patch make changes to allocate crc-entries buffer before
    enabling CRC generation.
    It moves all the failure check early in the function before setting
    the source or memory allocation.
    Now set_crc_source takes only two variable inputs, values_cnt we
    already gets as part of verify_crc_source.
    
    Changes since V1:
     - refactor code to use single spin lock
    Changes since V2:
     - rebase
    Changes since V3:
     - rebase on top of VKMS driver
    
    Signed-off-by: Mahesh Kumar <mahesh1.kumar@intel.com>
    Cc: dri-devel@lists.freedesktop.org
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Haneen Mohammed <hamohammed.sa@gmail.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Acked-by: Leo Li <sunpeng.li@amd.com> (V2)
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com> (V3)
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180821083858.26275-3-mahesh1.kumar@intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f2dd180a867a..b21437bc95bf 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -744,8 +744,7 @@ struct drm_crtc_funcs {
 	 *
 	 * 0 on success or a negative error code on failure.
 	 */
-	int (*set_crc_source)(struct drm_crtc *crtc, const char *source,
-			      size_t *values_cnt);
+	int (*set_crc_source)(struct drm_crtc *crtc, const char *source);
 	/**
 	 * @verify_crc_source:
 	 *

commit 4396551e9cf3e7233d45a2ce92f73e085bcad4b2
Author: Mahesh Kumar <mahesh1.kumar@intel.com>
Date:   Fri Jul 13 19:29:34 2018 +0530

    drm: crc: Introduce get_crc_sources callback
    
    This patch introduce a callback function "get_crc_sources" which
    will be called during read of control node. It is an optional
    callback function and if driver implements this callback, driver
    should return a constant pointer to an array of crc sources list
    and update count according to the number of source in the list.
    
    Changes Since V1: (Daniel)
     - return const pointer to an array of crc sources list
     - do validation of sources in CRC-core
    Changes Since V2:
     - update commit message
     - update callback documentation
     - print one source name per line
    
    Signed-off-by: Mahesh Kumar <mahesh1.kumar@intel.com>
    Cc: dri-devel@lists.freedesktop.org
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180713135942.25061-3-mahesh1.kumar@intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 9dcbce93aeae..f2dd180a867a 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -762,6 +762,28 @@ struct drm_crtc_funcs {
 	 */
 	int (*verify_crc_source)(struct drm_crtc *crtc, const char *source,
 				 size_t *values_cnt);
+	/**
+	 * @get_crc_sources:
+	 *
+	 * Driver callback for getting a list of all the available sources for
+	 * CRC generation. This callback depends upon verify_crc_source, So
+	 * verify_crc_source callback should be implemented before implementing
+	 * this. Driver can pass full list of available crc sources, this
+	 * callback does the verification on each crc-source before passing it
+	 * to userspace.
+	 *
+	 * This callback is optional if the driver does not support exporting of
+	 * possible CRC sources list.
+	 *
+	 * RETURNS:
+	 *
+	 * a constant character pointer to the list of all the available CRC
+	 * sources. On failure driver should return NULL. count should be
+	 * updated with number of sources in list. if zero we don't process any
+	 * source from the list.
+	 */
+	const char *const *(*get_crc_sources)(struct drm_crtc *crtc,
+					      size_t *count);
 
 	/**
 	 * @atomic_print_state:

commit d5cc15a0c66e207d5a7f1b92f32899cc8f380468
Author: Mahesh Kumar <mahesh1.kumar@intel.com>
Date:   Fri Jul 13 19:29:33 2018 +0530

    drm: crc: Introduce verify_crc_source callback
    
    This patch adds a new callback function "verify_crc_source" which will
    be used during setting the crc source in control node. This will help
    in avoiding setting of wrong string for source.
    
    Changes since V1:
     - do not yet verify_crc_source during open.
    Changes since V1:
     - improve callback description
    
    Signed-off-by: Mahesh Kumar <mahesh1.kumar@intel.com>
    Cc: dri-devel@lists.freedesktop.org
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180713135942.25061-2-mahesh1.kumar@intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 92e7fc7f05a4..9dcbce93aeae 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -746,6 +746,22 @@ struct drm_crtc_funcs {
 	 */
 	int (*set_crc_source)(struct drm_crtc *crtc, const char *source,
 			      size_t *values_cnt);
+	/**
+	 * @verify_crc_source:
+	 *
+	 * verifies the source of CRC checksums of frames before setting the
+	 * source for CRC and during crc open. Source parameter can be NULL
+	 * while disabling crc source.
+	 *
+	 * This callback is optional if the driver does not support any CRC
+	 * generation functionality.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 on success or a negative error code on failure.
+	 */
+	int (*verify_crc_source)(struct drm_crtc *crtc, const char *source,
+				 size_t *values_cnt);
 
 	/**
 	 * @atomic_print_state:

commit 620eec75f35ce470cb59410b2ed91ad750b867a2
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jul 9 10:40:15 2018 +0200

    drm/doc: use inline kerneldoc style for drm_crtc_state
    
    Lots of added text here since I think the various control flow bits
    are worth explaining a bit better.
    
    v2: Fix conflict with Boris' no_vblank addition.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180709084016.23750-15-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 7fe06ad6e5f0..92e7fc7f05a4 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -77,21 +77,6 @@ struct drm_plane_helper_funcs;
 
 /**
  * struct drm_crtc_state - mutable CRTC state
- * @crtc: backpointer to the CRTC
- * @enable: whether the CRTC should be enabled, gates all other state
- * @active: whether the CRTC is actively displaying (used for DPMS)
- * @planes_changed: planes on this crtc are updated
- * @mode_changed: @mode or @enable has been changed
- * @active_changed: @active has been toggled.
- * @connectors_changed: connectors to this crtc have been updated
- * @zpos_changed: zpos values of planes on this crtc have been updated
- * @color_mgmt_changed: color management properties have changed (degamma or
- *	gamma LUT or CSC matrix)
- * @plane_mask: bitmask of (1 << drm_plane_index(plane)) of attached planes
- * @connector_mask: bitmask of (1 << drm_connector_index(connector)) of attached connectors
- * @encoder_mask: bitmask of (1 << drm_encoder_index(encoder)) of attached encoders
- * @mode_blob: &drm_property_blob for @mode
- * @state: backpointer to global drm_atomic_state
  *
  * Note that the distinction between @enable and @active is rather subtile:
  * Flipping @active while @enable is set without changing anything else may
@@ -102,21 +87,86 @@ struct drm_plane_helper_funcs;
  *
  * The three booleans active_changed, connectors_changed and mode_changed are
  * intended to indicate whether a full modeset is needed, rather than strictly
- * describing what has changed in a commit.
- * See also: drm_atomic_crtc_needs_modeset()
+ * describing what has changed in a commit. See also:
+ * drm_atomic_crtc_needs_modeset()
+ *
+ * WARNING: Transitional helpers (like drm_helper_crtc_mode_set() or
+ * drm_helper_crtc_mode_set_base()) do not maintain many of the derived control
+ * state like @plane_mask so drivers not converted over to atomic helpers should
+ * not rely on these being accurate!
  */
 struct drm_crtc_state {
+	/** @crtc: backpointer to the CRTC */
 	struct drm_crtc *crtc;
 
+	/**
+	 * @enable: Whether the CRTC should be enabled, gates all other state.
+	 * This controls reservations of shared resources. Actual hardware state
+	 * is controlled by @active.
+	 */
 	bool enable;
+
+	/**
+	 * @active: Whether the CRTC is actively displaying (used for DPMS).
+	 * Implies that @enable is set. The driver must not release any shared
+	 * resources if @active is set to false but @enable still true, because
+	 * userspace expects that a DPMS ON always succeeds.
+	 *
+	 * Hence drivers must not consult @active in their various
+	 * &drm_mode_config_funcs.atomic_check callback to reject an atomic
+	 * commit. They can consult it to aid in the computation of derived
+	 * hardware state, since even in the DPMS OFF state the display hardware
+	 * should be as much powered down as when the CRTC is completely
+	 * disabled through setting @enable to false.
+	 */
 	bool active;
 
-	/* computed state bits used by helpers and drivers */
+	/**
+	 * @planes_changed: Planes on this crtc are updated. Used by the atomic
+	 * helpers and drivers to steer the atomic commit control flow.
+	 */
 	bool planes_changed : 1;
+
+	/**
+	 * @mode_changed: @mode or @enable has been changed. Used by the atomic
+	 * helpers and drivers to steer the atomic commit control flow. See also
+	 * drm_atomic_crtc_needs_modeset().
+	 *
+	 * Drivers are supposed to set this for any CRTC state changes that
+	 * require a full modeset. They can also reset it to false if e.g. a
+	 * @mode change can be done without a full modeset by only changing
+	 * scaler settings.
+	 */
 	bool mode_changed : 1;
+
+	/**
+	 * @active_changed: @active has been toggled. Used by the atomic
+	 * helpers and drivers to steer the atomic commit control flow. See also
+	 * drm_atomic_crtc_needs_modeset().
+	 */
 	bool active_changed : 1;
+
+	/**
+	 * @connectors_changed: Connectors to this crtc have been updated,
+	 * either in their state or routing. Used by the atomic
+	 * helpers and drivers to steer the atomic commit control flow. See also
+	 * drm_atomic_crtc_needs_modeset().
+	 *
+	 * Drivers are supposed to set this as-needed from their own atomic
+	 * check code, e.g. from &drm_encoder_helper_funcs.atomic_check
+	 */
 	bool connectors_changed : 1;
+	/**
+	 * @zpos_changed: zpos values of planes on this crtc have been updated.
+	 * Used by the atomic helpers and drivers to steer the atomic commit
+	 * control flow.
+	 */
 	bool zpos_changed : 1;
+	/**
+	 * @color_mgmt_changed: Color management properties have changed
+	 * (@gamma_lut, @degamma_lut or @ctm). Used by the atomic helpers and
+	 * drivers to steer the atomic commit control flow.
+	 */
 	bool color_mgmt_changed : 1;
 
 	/**
@@ -142,14 +192,22 @@ struct drm_crtc_state {
 	 */
 	bool no_vblank : 1;
 
-	/* attached planes bitmask:
-	 * WARNING: transitional helpers do not maintain plane_mask so
-	 * drivers not converted over to atomic helpers should not rely
-	 * on plane_mask being accurate!
+	/**
+	 * @plane_mask: Bitmask of drm_plane_mask(plane) of planes attached to
+	 * this CRTC.
 	 */
 	u32 plane_mask;
 
+	/**
+	 * @connector_mask: Bitmask of drm_connector_mask(connector) of
+	 * connectors attached to this CRTC.
+	 */
 	u32 connector_mask;
+
+	/**
+	 * @encoder_mask: Bitmask of drm_encoder_mask(encoder) of encoders
+	 * attached to this CRTC.
+	 */
 	u32 encoder_mask;
 
 	/**
@@ -159,7 +217,7 @@ struct drm_crtc_state {
 	 * differences between the mode requested by userspace in @mode and what
 	 * is actually programmed into the hardware.
 	 *
-	 * For drivers using drm_bridge, this stores hardware display timings
+	 * For drivers using &drm_bridge, this stores hardware display timings
 	 * used between the CRTC and the first bridge. For other drivers, the
 	 * meaning of the adjusted_mode field is purely driver implementation
 	 * defined information, and will usually be used to store the hardware
@@ -184,7 +242,10 @@ struct drm_crtc_state {
 	 */
 	struct drm_display_mode mode;
 
-	/* blob property to expose current mode to atomic userspace */
+	/**
+	 * @mode_blob: &drm_property_blob for @mode, for exposing the mode to
+	 * atomic userspace.
+	 */
 	struct drm_property_blob *mode_blob;
 
 	/**
@@ -288,6 +349,7 @@ struct drm_crtc_state {
 	 */
 	struct drm_crtc_commit *commit;
 
+	/** @state: backpointer to global drm_atomic_state */
 	struct drm_atomic_state *state;
 };
 

commit 15185aa20cbdf4404198b74f86a1ce9f6fe0fad7
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jul 9 10:40:12 2018 +0200

    drm/doc: move struct drm_crtc to in-line comments
    
    And clean them up a bit, as usual.
    
    v2: Fix nits (Sean).
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180709084016.23750-12-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 71b276a05e36..7fe06ad6e5f0 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -747,35 +747,25 @@ struct drm_crtc_funcs {
 
 /**
  * struct drm_crtc - central CRTC control structure
- * @dev: parent DRM device
- * @port: OF node used by drm_of_find_possible_crtcs()
- * @head: list management
- * @name: human readable name, can be overwritten by the driver
- * @mutex: per-CRTC locking
- * @base: base KMS object for ID tracking etc.
- * @primary: primary plane for this CRTC
- * @cursor: cursor plane for this CRTC
- * @cursor_x: current x position of the cursor, used for universal cursor planes
- * @cursor_y: current y position of the cursor, used for universal cursor planes
- * @enabled: is this CRTC enabled?
- * @mode: current mode timings
- * @hwmode: mode timings as programmed to hw regs
- * @x: x position on screen
- * @y: y position on screen
- * @funcs: CRTC control functions
- * @gamma_size: size of gamma ramp
- * @gamma_store: gamma ramp values
- * @helper_private: mid-layer private data
- * @properties: property tracking for this CRTC
  *
  * Each CRTC may have one or more connectors associated with it.  This structure
  * allows the CRTC to be controlled.
  */
 struct drm_crtc {
+	/** @dev: parent DRM device */
 	struct drm_device *dev;
+	/** @port: OF node used by drm_of_find_possible_crtcs(). */
 	struct device_node *port;
+	/**
+	 * @head:
+	 *
+	 * List of all CRTCs on @dev, linked from &drm_mode_config.crtc_list.
+	 * Invariant over the lifetime of @dev and therefore does not need
+	 * locking.
+	 */
 	struct list_head head;
 
+	/** @name: human readable name, can be overwritten by the driver */
 	char *name;
 
 	/**
@@ -790,10 +780,25 @@ struct drm_crtc {
 	 */
 	struct drm_modeset_lock mutex;
 
+	/** @base: base KMS object for ID tracking etc. */
 	struct drm_mode_object base;
 
-	/* primary and cursor planes for CRTC */
+	/**
+	 * @primary:
+	 * Primary plane for this CRTC. Note that this is only
+	 * relevant for legacy IOCTL, it specifies the plane implicitly used by
+	 * the SETCRTC and PAGE_FLIP IOCTLs. It does not have any significance
+	 * beyond that.
+	 */
 	struct drm_plane *primary;
+
+	/**
+	 * @cursor:
+	 * Cursor plane for this CRTC. Note that this is only relevant for
+	 * legacy IOCTL, it specifies the plane implicitly used by the SETCURSOR
+	 * and SETCURSOR2 IOCTLs. It does not have any significance
+	 * beyond that.
+	 */
 	struct drm_plane *cursor;
 
 	/**
@@ -802,30 +807,94 @@ struct drm_crtc {
 	 */
 	unsigned index;
 
-	/* position of cursor plane on crtc */
+	/**
+	 * @cursor_x: Current x position of the cursor, used for universal
+	 * cursor planes because the SETCURSOR IOCTL only can update the
+	 * framebuffer without supplying the coordinates. Drivers should not use
+	 * this directly, atomic drivers should look at &drm_plane_state.crtc_x
+	 * of the cursor plane instead.
+	 */
 	int cursor_x;
+	/**
+	 * @cursor_y: Current y position of the cursor, used for universal
+	 * cursor planes because the SETCURSOR IOCTL only can update the
+	 * framebuffer without supplying the coordinates. Drivers should not use
+	 * this directly, atomic drivers should look at &drm_plane_state.crtc_y
+	 * of the cursor plane instead.
+	 */
 	int cursor_y;
 
+	/**
+	 * @enabled:
+	 *
+	 * Is this CRTC enabled? Should only be used by legacy drivers, atomic
+	 * drivers should instead consult &drm_crtc_state.enable and
+	 * &drm_crtc_state.active. Atomic drivers can update this by calling
+	 * drm_atomic_helper_update_legacy_modeset_state().
+	 */
 	bool enabled;
 
-	/* Requested mode from modesetting. */
+	/**
+	 * @mode:
+	 *
+	 * Current mode timings. Should only be used by legacy drivers, atomic
+	 * drivers should instead consult &drm_crtc_state.mode. Atomic drivers
+	 * can update this by calling
+	 * drm_atomic_helper_update_legacy_modeset_state().
+	 */
 	struct drm_display_mode mode;
 
-	/* Programmed mode in hw, after adjustments for encoders,
-	 * crtc, panel scaling etc. Needed for timestamping etc.
+	/**
+	 * @hwmode:
+	 *
+	 * Programmed mode in hw, after adjustments for encoders, crtc, panel
+	 * scaling etc. Should only be used by legacy drivers, for high
+	 * precision vblank timestamps in
+	 * drm_calc_vbltimestamp_from_scanoutpos().
+	 *
+	 * Note that atomic drivers should not use this, but instead use
+	 * &drm_crtc_state.adjusted_mode. And for high-precision timestamps
+	 * drm_calc_vbltimestamp_from_scanoutpos() used &drm_vblank_crtc.hwmode,
+	 * which is filled out by calling drm_calc_timestamping_constants().
 	 */
 	struct drm_display_mode hwmode;
 
-	int x, y;
+	/**
+	 * @x:
+	 * x position on screen. Should only be used by legacy drivers, atomic
+	 * drivers should look at &drm_plane_state.crtc_x of the primary plane
+	 * instead. Updated by calling
+	 * drm_atomic_helper_update_legacy_modeset_state().
+	 */
+	int x;
+	/**
+	 * @y:
+	 * y position on screen. Should only be used by legacy drivers, atomic
+	 * drivers should look at &drm_plane_state.crtc_y of the primary plane
+	 * instead. Updated by calling
+	 * drm_atomic_helper_update_legacy_modeset_state().
+	 */
+	int y;
+
+	/** @funcs: CRTC control functions */
 	const struct drm_crtc_funcs *funcs;
 
-	/* Legacy FB CRTC gamma size for reporting to userspace */
+	/**
+	 * @gamma_size: Size of legacy gamma ramp reported to userspace. Set up
+	 * by calling drm_mode_crtc_set_gamma_size().
+	 */
 	uint32_t gamma_size;
+
+	/**
+	 * @gamma_store: Gamma ramp values used by the legacy SETGAMMA and
+	 * GETGAMMA IOCTls. Set up by calling drm_mode_crtc_set_gamma_size().
+	 */
 	uint16_t *gamma_store;
 
-	/* if you are using the helper */
+	/** @helper_private: mid-layer private data */
 	const struct drm_crtc_helper_funcs *helper_private;
 
+	/** @properties: property tracking for this CRTC */
 	struct drm_object_properties properties;
 
 	/**
@@ -895,7 +964,6 @@ struct drm_crtc {
 	 *
 	 * spinlock to protect the fences in the fence_context.
 	 */
-
 	spinlock_t fence_lock;
 	/**
 	 * @fence_seqno:

commit 268bc24e861efd6892d2911bf25a3d1192aa51f5
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jul 9 10:40:10 2018 +0200

    drm: switch drm_plane to inline comments
    
    And use that opportunity to polish the kernel doc all around:
    - Beef up some of the documentation.
    - Intro text for drm_plane and better links
    - Fix all the hyperlinks!
    
    v2: Fix linebreaks.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180709084016.23750-10-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 17f4f93340b8..71b276a05e36 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -965,8 +965,8 @@ static inline unsigned int drm_crtc_index(const struct drm_crtc *crtc)
  * drm_crtc_mask - find the mask of a registered CRTC
  * @crtc: CRTC to find mask for
  *
- * Given a registered CRTC, return the mask bit of that CRTC for an
- * encoder's possible_crtcs field.
+ * Given a registered CRTC, return the mask bit of that CRTC for the
+ * &drm_encoder.possible_crtcs and &drm_plane.possible_crtcs fields.
  */
 static inline uint32_t drm_crtc_mask(const struct drm_crtc *crtc)
 {

commit b25c60af7a8773694a505cdb0d2e67807243217d
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Tue Jul 3 09:50:19 2018 +0200

    drm/crtc: Add a generic infrastructure to fake VBLANK events
    
    In some cases CRTCs are active but are not able to generating events, at
    least not at every frame at it's expected to.
    This is typically the case when the CRTC is feeding a writeback connector
    that has no job queued. In this situation the CRTC is usually stopped
    until a new job is queued, and this can lead to timeouts when part of
    the pipeline is updated but no new jobs are queued to the active
    writeback connector.
    
    In order to solve that, we add a ->no_vblank flag to drm_crtc_state
    and ask the CRTC drivers to set it to true when they know they're not
    able to generate VBLANK events. The core drm_atomic_helper_fake_vblank()
    helper can then be used to fake VBLANKs at commit time.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Liviu Dudau <liviu.dudau@arm.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180703075022.15138-6-boris.brezillon@bootlin.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 23eddbccab10..17f4f93340b8 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -119,6 +119,29 @@ struct drm_crtc_state {
 	bool zpos_changed : 1;
 	bool color_mgmt_changed : 1;
 
+	/**
+	 * @no_vblank:
+	 *
+	 * Reflects the ability of a CRTC to send VBLANK events. This state
+	 * usually depends on the pipeline configuration, and the main usuage
+	 * is CRTCs feeding a writeback connector operating in oneshot mode.
+	 * In this case the VBLANK event is only generated when a job is queued
+	 * to the writeback connector, and we want the core to fake VBLANK
+	 * events when this part of the pipeline hasn't changed but others had
+	 * or when the CRTC and connectors are being disabled.
+	 *
+	 * __drm_atomic_helper_crtc_duplicate_state() will not reset the value
+	 * from the current state, the CRTC driver is then responsible for
+	 * updating this field when needed.
+	 *
+	 * Note that the combination of &drm_crtc_state.event == NULL and
+	 * &drm_crtc_state.no_blank == true is valid and usually used when the
+	 * writeback connector attached to the CRTC has a new job queued. In
+	 * this case the driver will send the VBLANK event on its own when the
+	 * writeback job is complete.
+	 */
+	bool no_vblank : 1;
+
 	/* attached planes bitmask:
 	 * WARNING: transitional helpers do not maintain plane_mask so
 	 * drivers not converted over to atomic helpers should not rely

commit ba1f665f161ce112a2703649317bfdc9b6521613
Author: Haneen Mohammed <hamohammed.sa@gmail.com>
Date:   Fri May 25 04:25:55 2018 +0300

    drm: Add checks for atomic_[duplicate/destroy]_state with atomic drivers
    
    This patch add checks for atomic_[duplicate/destroy]_state of
    drm_[connector/crtc/plane]_funcs for atomic drivers in the relevant
    drm_*_init functions since these callback are mandatory for atomic drivers.
    
    Update the kerneldoc comments for those callbacks.
    
    Signed-off-by: Haneen Mohammed <hamohammed.sa@gmail.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180525012555.GA8448@haneen-vb

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 5cf7adeae6a5..23eddbccab10 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -506,6 +506,8 @@ struct drm_crtc_funcs {
 	 * cleaned up by calling the @atomic_destroy_state hook in this
 	 * structure.
 	 *
+	 * This callback is mandatory for atomic drivers.
+	 *
 	 * Atomic drivers which don't subclass &struct drm_crtc_state should use
 	 * drm_atomic_helper_crtc_duplicate_state(). Drivers that subclass the
 	 * state structure to extend it with driver-private state should use
@@ -532,6 +534,8 @@ struct drm_crtc_funcs {
 	 *
 	 * Destroy a state duplicated with @atomic_duplicate_state and release
 	 * or unreference all resources it references
+	 *
+	 * This callback is mandatory for atomic drivers.
 	 */
 	void (*atomic_destroy_state)(struct drm_crtc *crtc,
 				     struct drm_crtc_state *state);

commit 584a0146ec4989f30d0aef46ce1ea6f6ba22a690
Author: Philippe Cornu <philippe.cornu@st.com>
Date:   Mon Apr 9 17:24:27 2018 +0200

    drm: clarify adjusted_mode documentation for bridges
    
    This patch clarifies the adjusted_mode documentation
    for bridges.
    
    Signed-off-by: Philippe Cornu <philippe.cornu@st.com>
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180409152427.12449-1-philippe.cornu@st.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index a2d81d2907a9..5cf7adeae6a5 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -134,10 +134,13 @@ struct drm_crtc_state {
 	 *
 	 * Internal display timings which can be used by the driver to handle
 	 * differences between the mode requested by userspace in @mode and what
-	 * is actually programmed into the hardware. It is purely driver
-	 * implementation defined what exactly this adjusted mode means. Usually
-	 * it is used to store the hardware display timings used between the
-	 * CRTC and encoder blocks.
+	 * is actually programmed into the hardware.
+	 *
+	 * For drivers using drm_bridge, this stores hardware display timings
+	 * used between the CRTC and the first bridge. For other drivers, the
+	 * meaning of the adjusted_mode field is purely driver implementation
+	 * defined information, and will usually be used to store the hardware
+	 * display timings used between the CRTC and encoder blocks.
 	 */
 	struct drm_display_mode adjusted_mode;
 

commit e7e62c7ef382f5db0de5e492e558efc9c3d60943
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Nov 9 09:35:04 2017 +1000

    drm/mode_object: fix documentation for object lookups.
    
    The lease updates missed a few bits of docs, fixed up
    the wrong name on the property lookup fn as well.
    
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f7fcceef46d9..a2d81d2907a9 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -952,6 +952,7 @@ struct drm_crtc *drm_crtc_from_index(struct drm_device *dev, int idx);
 /**
  * drm_crtc_find - look up a CRTC object from its ID
  * @dev: DRM device
+ * @file_priv: drm file to check for lease against.
  * @id: &drm_mode_object ID
  *
  * This can be used to look up a CRTC from its userspace ID. Only used by

commit 418da17214aca5ef5f0b6f7588905ee7df92f98f
Author: Keith Packard <keithp@keithp.com>
Date:   Tue Mar 14 23:25:07 2017 -0700

    drm: Pass struct drm_file * to __drm_mode_object_find [v2]
    
    This will allow __drm_mode_object_file to be extended to perform
    access control checks based on the file in use.
    
    v2: Also fix up vboxvideo driver in staging
    
    [airlied: merging early as this is an API change]
    
    Suggested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 80c97210eda5..f7fcceef46d9 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -959,10 +959,11 @@ struct drm_crtc *drm_crtc_from_index(struct drm_device *dev, int idx);
  * userspace interface should be done using &drm_property.
  */
 static inline struct drm_crtc *drm_crtc_find(struct drm_device *dev,
-	uint32_t id)
+		struct drm_file *file_priv,
+		uint32_t id)
 {
 	struct drm_mode_object *mo;
-	mo = drm_mode_object_find(dev, id, DRM_MODE_OBJECT_CRTC);
+	mo = drm_mode_object_find(dev, file_priv, id, DRM_MODE_OBJECT_CRTC);
 	return mo ? obj_to_crtc(mo) : NULL;
 }
 

commit 77ac3b00b13185741effd0d5e2f1f05e4bfef7dc
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Wed Jul 19 16:39:20 2017 +0200

    drm/atomic: Remove deprecated accessor macros
    
    Now that the last users have been converted, we can finally get rid of
    for_each_obj_in_state, we have better macros to replace them with.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: David Airlie <airlied@linux.ie>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170719143920.25685-8-maarten.lankhorst@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 901f5c054a2c..80c97210eda5 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -806,10 +806,10 @@ struct drm_crtc {
 	 * This is protected by @mutex. Note that nonblocking atomic commits
 	 * access the current CRTC state without taking locks. Either by going
 	 * through the &struct drm_atomic_state pointers, see
-	 * for_each_crtc_in_state(), for_each_oldnew_crtc_in_state(),
-	 * for_each_old_crtc_in_state() and for_each_new_crtc_in_state(). Or
-	 * through careful ordering of atomic commit operations as implemented
-	 * in the atomic helpers, see &struct drm_crtc_commit.
+	 * for_each_oldnew_crtc_in_state(), for_each_old_crtc_in_state() and
+	 * for_each_new_crtc_in_state(). Or through careful ordering of atomic
+	 * commit operations as implemented in the atomic helpers, see
+	 * &struct drm_crtc_commit.
 	 */
 	struct drm_crtc_state *state;
 

commit 163bcc2c74a22c891c1906e6e343e28a70a54978
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Mon Sep 4 17:04:56 2017 +0200

    drm/atomic: Move drm_crtc_commit to drm_crtc_state, v4.
    
    Most code only cares about the current commit or previous commit.
    Fortuantely we already have a place to track those. Move it to
    drm_crtc_state where it belongs. :)
    
    The per-crtc commit_list is kept for places where we have to look
    deeper than the current or previous commit for checking whether to stall
    on unpin. This is used in drm_atomic_helper_setup_commit and
    intel_has_pending_fb_unpin.
    
    Changes since v1:
    - Update kerneldoc for drm_crtc.commit_list. (danvet)
    Changes since v2:
    - Remove drm_atomic_helper_async_check hunk. (pinchartl)
    Changes since v3:
    - Fix use-after-free in drm_atomic_helper_commit_cleanup_done().
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170904150456.31049-1-maarten.lankhorst@linux.intel.com
    [mlankhorst: preceeding -> preceding (checkpatch)]

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 1a642020e306..901f5c054a2c 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -253,6 +253,15 @@ struct drm_crtc_state {
 	 */
 	struct drm_pending_vblank_event *event;
 
+	/**
+	 * @commit:
+	 *
+	 * This tracks how the commit for this update proceeds through the
+	 * various phases. This is never cleared, except when we destroy the
+	 * state, so that subsequent commits can synchronize with previous ones.
+	 */
+	struct drm_crtc_commit *commit;
+
 	struct drm_atomic_state *state;
 };
 
@@ -808,10 +817,16 @@ struct drm_crtc {
 	 * @commit_list:
 	 *
 	 * List of &drm_crtc_commit structures tracking pending commits.
-	 * Protected by @commit_lock. This list doesn't hold its own full
-	 * reference, but burrows it from the ongoing commit. Commit entries
-	 * must be removed from this list once the commit is fully completed,
-	 * but before it's correspoding &drm_atomic_state gets destroyed.
+	 * Protected by @commit_lock. This list holds its own full reference,
+	 * as does the ongoing commit.
+	 *
+	 * "Note that the commit for a state change is also tracked in
+	 * &drm_crtc_state.commit. For accessing the immediately preceding
+	 * commit in an atomic update it is recommended to just use that
+	 * pointer in the old CRTC state, since accessing that doesn't need
+	 * any locking or list-walking. @commit_list should only be used to
+	 * stall for framebuffer cleanup that's signalled through
+	 * &drm_crtc_commit.cleanup_done."
 	 */
 	struct list_head commit_list;
 

commit 144a7999d6334be5237d5926ab19c56bc24d0204
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jul 25 14:02:04 2017 +0200

    drm: Handle properties in the core for atomic drivers
    
    The reason behind the original indirection through the helper
    functions was to allow existing drivers to overwrite how they handle
    properties. For example when a vendor-specific userspace had
    expectations that didn't match atomic. That seemed likely, since
    atomic is standardizing a _lot_ more of the behaviour of a kms driver.
    
    But 20 drivers later there's no such need at all. Worse, this forces
    all drivers to hook up the default behaviour, breaking userspace if
    they forget to do that. And it forces us to export a bunch of core
    function just for those helpers.
    
    And finally, these helpers are the last places using
    drm_atomic_legacy_backoff() and the implicit acquire_ctx.
    
    This patch here just implements the new behaviour and updates the
    docs. Follow-up patches will garbage-collect all the dead code.
    
    v2: Fixup docs even better!
    
    v3: Make it actually work ...
    
    v4: Drop the uses_atomic_modeset() checks from the previous patch
    again, since they're now moved up in the callchain.
    
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Archit Taneja <architt@codeaurora.org> (v3)
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170725120204.2107-1-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 0cc89623abe6..1a642020e306 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -473,11 +473,9 @@ struct drm_crtc_funcs {
 	 * This is the legacy entry point to update a property attached to the
 	 * CRTC.
 	 *
-	 * Drivers implementing atomic modeset should use
-	 * drm_atomic_helper_crtc_set_property() to implement this hook.
-	 *
 	 * This callback is optional if the driver does not support any legacy
-	 * driver-private properties.
+	 * driver-private properties. For atomic drivers it is not used because
+	 * property handling is done entirely in the DRM core.
 	 *
 	 * RETURNS:
 	 *

commit 2cd575aabd4db9b22f68847fcb0e3d88cc2d0fb1
Author: Peter Rosin <peda@axentia.se>
Date:   Thu Jul 13 18:25:38 2017 +0200

    drm: remove unused and redundant callbacks
    
    Drivers no longer have any need for these callbacks, and there are no
    users. Zap. Zap-zap-zzzap-p-pp-p.
    
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Peter Rosin <peda@axentia.se>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170713162538.22788-15-peda@axentia.se

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 3a911a64c257..0cc89623abe6 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -358,14 +358,6 @@ struct drm_crtc_funcs {
 	 * drm_crtc_enable_color_mgmt(), which then supports the legacy gamma
 	 * interface through the drm_atomic_helper_legacy_gamma_set()
 	 * compatibility implementation.
-	 *
-	 * NOTE:
-	 *
-	 * Drivers that support gamma tables and also fbdev emulation through
-	 * the provided helper library need to take care to fill out the gamma
-	 * hooks for both. Currently there's a bit an unfortunate duplication
-	 * going on, which should eventually be unified to just one set of
-	 * hooks.
 	 */
 	int (*gamma_set)(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,
 			 uint32_t size,

commit 57d30230c573e3f1a49ae7e0f7f8b73b17881415
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed May 24 16:51:45 2017 +0200

    drm/doc: vblank cleanup
    
    Unify and review everything, plus make sure it's all correct markup.
    Drop the kernel-doc for internal functions. Also rework the overview
    section, it's become rather outdated.
    
    Unfortuantely the kernel-doc in drm_driver isn't rendered yet, but
    that will change as soon as drm_driver is kernel-docified properly.
    
    Also document properly that drm_vblank_cleanup is optional, the core
    calls this already.
    
    v2: Make it clear that cleanup happens in drm_dev_fini for drivers
    with their own ->release callback (Thierry).
    
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170524145212.27837-11-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 629a5fe075b3..3a911a64c257 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -685,6 +685,9 @@ struct drm_crtc_funcs {
 	 * drm_crtc_vblank_off() and drm_crtc_vblank_on() when disabling or
 	 * enabling a CRTC.
 	 *
+	 * See also &drm_device.vblank_disable_immediate and
+	 * &drm_device.max_vblank_count.
+	 *
 	 * Returns:
 	 *
 	 * Raw vblank counter value.

commit 8938d13585bc91e3c5217dc76534759eec2b6e69
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed May 24 16:51:48 2017 +0200

    drm: better document how to send out the crtc disable event
    
    The kernel doc explained what needs to happen, but not how to most
    easily accomplish that using the functions. Fix that.
    
    Cc: Boris Brezillon <boris.brezillon@free-electrons.com>
    Reviewed-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Reviewed-by: Neil Armstrong <narmstrong@baylibre.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170524145212.27837-14-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b6e3713bd7a9..629a5fe075b3 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -214,7 +214,9 @@ struct drm_crtc_state {
 	 *    atomic commit. In that case the event can be send out any time
 	 *    after the hardware has stopped scanning out the current
 	 *    framebuffers. It should contain the timestamp and counter for the
-	 *    last vblank before the display pipeline was shut off.
+	 *    last vblank before the display pipeline was shut off. The simplest
+	 *    way to achieve that is calling drm_crtc_send_vblank_event()
+	 *    somewhen after drm_crtc_vblank_off() has been called.
 	 *
 	 *  - For a CRTC which is enabled at the end of the commit (even when it
 	 *    undergoes an full modeset) the vblank timestamp and counter must

commit 9de5d4a61cc2a99634e3b51bda0f8e2fdd8f4287
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon May 15 11:11:35 2017 +0200

    drm/doc: Document adjusted/request modes a bit better
    
    Laurent started a massive discussion on IRC about this. Let's try to
    document common usage a bit better.
    
    v2: Cross-links+typos.
    
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Jose Abreu <Jose.Abreu@synopsys.com>
    Reviewed-by: Jose Abreu <joabreu@synopsys.com>
    Reviewed-by: Andrzej Hajda <a.hajda@samsung.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170515091136.26307-1-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index adf4e91a9399..b6e3713bd7a9 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -90,8 +90,6 @@ struct drm_plane_helper_funcs;
  * @plane_mask: bitmask of (1 << drm_plane_index(plane)) of attached planes
  * @connector_mask: bitmask of (1 << drm_connector_index(connector)) of attached connectors
  * @encoder_mask: bitmask of (1 << drm_encoder_index(encoder)) of attached encoders
- * @adjusted_mode: for use by helpers and drivers to compute adjusted mode timings
- * @mode: current mode timings
  * @mode_blob: &drm_property_blob for @mode
  * @state: backpointer to global drm_atomic_state
  *
@@ -131,9 +129,33 @@ struct drm_crtc_state {
 	u32 connector_mask;
 	u32 encoder_mask;
 
-	/* adjusted_mode: for use by helpers and drivers */
+	/**
+	 * @adjusted_mode:
+	 *
+	 * Internal display timings which can be used by the driver to handle
+	 * differences between the mode requested by userspace in @mode and what
+	 * is actually programmed into the hardware. It is purely driver
+	 * implementation defined what exactly this adjusted mode means. Usually
+	 * it is used to store the hardware display timings used between the
+	 * CRTC and encoder blocks.
+	 */
 	struct drm_display_mode adjusted_mode;
 
+	/**
+	 * @mode:
+	 *
+	 * Display timings requested by userspace. The driver should try to
+	 * match the refresh rate as close as possible (but note that it's
+	 * undefined what exactly is close enough, e.g. some of the HDMI modes
+	 * only differ in less than 1% of the refresh rate). The active width
+	 * and height as observed by userspace for positioning planes must match
+	 * exactly.
+	 *
+	 * For external connectors where the sink isn't fixed (like with a
+	 * built-in panel), this mode here should match the physical mode on the
+	 * wire to the last details (i.e. including sync polarities and
+	 * everything).
+	 */
 	struct drm_display_mode mode;
 
 	/* blob property to expose current mode to atomic userspace */

commit 2e38178e23e63b193654af9a11bb4a3cb4b999a5
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Apr 12 17:20:06 2017 +0200

    drm/doc: Interlink color manager docs better
    
    Motivated by a request from Eric.
    
    v2: Take in suggestions from Lionel
    
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170412152006.12233-1-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index a8176a836e25..adf4e91a9399 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -93,11 +93,6 @@ struct drm_plane_helper_funcs;
  * @adjusted_mode: for use by helpers and drivers to compute adjusted mode timings
  * @mode: current mode timings
  * @mode_blob: &drm_property_blob for @mode
- * @degamma_lut: Lookup table for converting framebuffer pixel data
- *	before apply the conversion matrix
- * @ctm: Transformation matrix
- * @gamma_lut: Lookup table for converting pixel data after the
- *	conversion matrix
  * @state: backpointer to global drm_atomic_state
  *
  * Note that the distinction between @enable and @active is rather subtile:
@@ -144,9 +139,30 @@ struct drm_crtc_state {
 	/* blob property to expose current mode to atomic userspace */
 	struct drm_property_blob *mode_blob;
 
-	/* blob property to expose color management to userspace */
+	/**
+	 * @degamma_lut:
+	 *
+	 * Lookup table for converting framebuffer pixel data before apply the
+	 * color conversion matrix @ctm. See drm_crtc_enable_color_mgmt(). The
+	 * blob (if not NULL) is an array of &struct drm_color_lut.
+	 */
 	struct drm_property_blob *degamma_lut;
+
+	/**
+	 * @ctm:
+	 *
+	 * Color transformation matrix. See drm_crtc_enable_color_mgmt(). The
+	 * blob (if not NULL) is a &struct drm_color_ctm.
+	 */
 	struct drm_property_blob *ctm;
+
+	/**
+	 * @gamma_lut:
+	 *
+	 * Lookup table for converting pixel data after the color conversion
+	 * matrix @ctm.  See drm_crtc_enable_color_mgmt(). The blob (if not
+	 * NULL) is an array of &struct drm_color_lut.
+	 */
 	struct drm_property_blob *gamma_lut;
 
 	/**
@@ -313,6 +329,12 @@ struct drm_crtc_funcs {
 	 *
 	 * This callback is optional.
 	 *
+	 * Atomic drivers who want to support gamma tables should implement the
+	 * atomic color management support, enabled by calling
+	 * drm_crtc_enable_color_mgmt(), which then supports the legacy gamma
+	 * interface through the drm_atomic_helper_legacy_gamma_set()
+	 * compatibility implementation.
+	 *
 	 * NOTE:
 	 *
 	 * Drivers that support gamma tables and also fbdev emulation through

commit 6d124ff845334bc466f56c059147e7ad587c2e7e
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Apr 3 10:33:01 2017 +0200

    drm: Add acquire ctx to ->gamma_set hook
    
    Atomic helpers really want this instead of the hacked-up legacy
    backoff trick, which unfortunately prevents drivers from using their
    own private drm_modeset_locks.
    
    Aside: There's a few atomic drivers (nv50, vc4, soon vmwgfx) which
    don't yet use the new atomic color mgmt/gamma table stuff. Would be
    nice if they could switch over and just hook up
    drm_atomic_helper_legacy_gamma_set() instead.
    
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Christian König <christian.koenig@amd.com>
    Cc: Gerd Hoffmann <kraxel@redhat.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Sinclair Yeh <syeh@vmware.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Eric Anholt <eric@anholt.net>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170403083304.9083-13-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index ede60d67976f..a8176a836e25 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -322,7 +322,8 @@ struct drm_crtc_funcs {
 	 * hooks.
 	 */
 	int (*gamma_set)(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,
-			 uint32_t size);
+			 uint32_t size,
+			 struct drm_modeset_acquire_ctx *ctx);
 
 	/**
 	 * @destroy:

commit b260ac3ebef5eb748207cd542dba00af6c5caaa5
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Apr 3 10:32:52 2017 +0200

    drm: Remove drm_modeset_legacy_acquire_ctx and crtc->acquire_ctx
    
    With all the callers of drm_modeset_lock_crtc gone, and all the places
    it was formerly used properly wiring the acquire ctx through, we can
    remove this.
    
    The only hidden context magic we still have is now the global one.
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170403083304.9083-4-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 2be2192b1373..ede60d67976f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -782,15 +782,6 @@ struct drm_crtc {
 	 */
 	spinlock_t commit_lock;
 
-	/**
-	 * @acquire_ctx:
-	 *
-	 * Per-CRTC implicit acquire context used by atomic drivers for legacy
-	 * IOCTLs, so that atomic drivers can get at the locking acquire
-	 * context.
-	 */
-	struct drm_modeset_acquire_ctx *acquire_ctx;
-
 #ifdef CONFIG_DEBUG_FS
 	/**
 	 * @debugfs_entry:

commit a4eff9aa6db8eb3d1864118f3558214b26f630b4
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Mar 22 22:50:57 2017 +0100

    drm: Add acquire ctx parameter to ->set_config
    
    Surprisingly a lot of legacy drivers roll their own, for
    runtime pm and because vmwgfx.
    
    Also make nouveau's set_config static while at it.
    
    Cc: Sinclair Yeh <syeh@vmware.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Patrik Jakobsson <patrik.r.jakobsson@gmail.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Christian König <christian.koenig@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170322215058.8671-19-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 1a525ce66468..2be2192b1373 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -347,7 +347,8 @@ struct drm_crtc_funcs {
 	 *
 	 * 0 on success or a negative error code on failure.
 	 */
-	int (*set_config)(struct drm_mode_set *set);
+	int (*set_config)(struct drm_mode_set *set,
+			  struct drm_modeset_acquire_ctx *ctx);
 
 	/**
 	 * @page_flip:

commit 41292b1fa13a894c1108d4a1c7f8a59fbb307aa6
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Mar 22 22:50:50 2017 +0100

    drm: Add acquire ctx parameter to ->page_flip(_target)
    
    Again just going through the motions, no functional changes in here.
    
    Cc: Gerd Hoffmann <kraxel@redhat.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Christian König <christian.koenig@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>t
    Link: http://patchwork.freedesktop.org/patch/msgid/20170322215058.8671-12-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c1a75a9c81c2..1a525ce66468 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -405,7 +405,8 @@ struct drm_crtc_funcs {
 	int (*page_flip)(struct drm_crtc *crtc,
 			 struct drm_framebuffer *fb,
 			 struct drm_pending_vblank_event *event,
-			 uint32_t flags);
+			 uint32_t flags,
+			 struct drm_modeset_acquire_ctx *ctx);
 
 	/**
 	 * @page_flip_target:
@@ -423,7 +424,8 @@ struct drm_crtc_funcs {
 	int (*page_flip_target)(struct drm_crtc *crtc,
 				struct drm_framebuffer *fb,
 				struct drm_pending_vblank_event *event,
-				uint32_t flags, uint32_t target);
+				uint32_t flags, uint32_t target,
+				struct drm_modeset_acquire_ctx *ctx);
 
 	/**
 	 * @set_property:

commit c9e42b72b44acc67ede9726e6434b12ba153d901
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Mar 28 17:53:48 2017 +0200

    drm: Document kms locking a bit better
    
    The rules are getting real hard, better to dump my brain into text a
    bit. This is by far not complete, but I think I reasonable start at
    least.
    
    Some of the older kms structures would need a full doc review anyway
    ...
    
    Cc: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170328155349.5972-2-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 24dcb121bad4..c1a75a9c81c2 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -699,10 +699,12 @@ struct drm_crtc {
 	/**
 	 * @mutex:
 	 *
-	 * This provides a read lock for the overall crtc state (mode, dpms
+	 * This provides a read lock for the overall CRTC state (mode, dpms
 	 * state, ...) and a write lock for everything which can be update
-	 * without a full modeset (fb, cursor data, crtc properties ...). A full
+	 * without a full modeset (fb, cursor data, CRTC properties ...). A full
 	 * modeset also need to grab &drm_mode_config.connection_mutex.
+	 *
+	 * For atomic drivers specifically this protects @state.
 	 */
 	struct drm_modeset_lock mutex;
 
@@ -748,6 +750,14 @@ struct drm_crtc {
 	 * @state:
 	 *
 	 * Current atomic state for this CRTC.
+	 *
+	 * This is protected by @mutex. Note that nonblocking atomic commits
+	 * access the current CRTC state without taking locks. Either by going
+	 * through the &struct drm_atomic_state pointers, see
+	 * for_each_crtc_in_state(), for_each_oldnew_crtc_in_state(),
+	 * for_each_old_crtc_in_state() and for_each_new_crtc_in_state(). Or
+	 * through careful ordering of atomic commit operations as implemented
+	 * in the atomic helpers, see &struct drm_crtc_commit.
 	 */
 	struct drm_crtc_state *state;
 

commit 760f71e72eb5c64b12d85d4e6dc79d28a708e09e
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Mar 22 09:36:04 2017 +0100

    drm: document driver interface for CRC capturing
    
    This was missed in Tomeu's patch. Also remove the kerneldoc for the
    internal function, we don't document that in general.
    
    While at it word-smith the docs slightly for more clarity.
    
    Cc: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170322083617.13361-4-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 6ef59da3fd8e..24dcb121bad4 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -590,9 +590,12 @@ struct drm_crtc_funcs {
 	 * When CRC generation is enabled, the driver should call
 	 * drm_crtc_add_crc_entry() at each frame, providing any information
 	 * that characterizes the frame contents in the crcN arguments, as
-	 * provided from the configured source. Drivers must accept a "auto"
+	 * provided from the configured source. Drivers must accept an "auto"
 	 * source name that will select a default source for this CRTC.
 	 *
+	 * Note that "auto" can depend upon the current modeset configuration,
+	 * e.g. it could pick an encoder or output specific CRC sampling point.
+	 *
 	 * This callback is optional if the driver does not support any CRC
 	 * generation functionality.
 	 *

commit 66f8c10003966130b0b2812fcbdfa6389bccd577
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Mar 8 15:12:39 2017 +0100

    drm/doc: document fallback behaviour for atomic events
    
    Worst case if the hw can't support completion signalling in a
    race-free way we want the event to be too late, not too early.
    
    Text adapted from a proposal from Laurent - the other side of how to
    make hw work correctly where it's possible is imo already sufficiently
    documented.
    
    v2: Review from Laurent.
    
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170308141257.12119-7-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index cba29ffedafd..6ef59da3fd8e 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -204,6 +204,12 @@ struct drm_crtc_state {
 	 * drm_crtc_arm_vblank_event(). See the documentation of that function
 	 * for a detailed discussion of the constraints it needs to be used
 	 * safely.
+	 *
+	 * If the device can't notify of flip completion in a race-free way
+	 * at all, then the event should be armed just after the page flip is
+	 * committed. In the worst case the driver will send the event to
+	 * userspace one frame too late. This doesn't allow for a real atomic
+	 * update, but it should avoid tearing.
 	 */
 	struct drm_pending_vblank_event *event;
 

commit 47f6cdd2cb0bed3d8337626d45efc9301337bf1d
Author: Sean Paul <seanpaul@chromium.org>
Date:   Mon Mar 6 15:00:17 2017 -0500

    drm: Fix compilation error when CONFIG_DEBUG_FS is undefined
    
    This patch fixes the following compilation error when CONFIG_DEBUG_FS is not defined.
    
    ../drivers/gpu/drm/drm_dp_helper.c: In function ‘drm_dp_aux_crc_work’:
    ../drivers/gpu/drm/drm_dp_helper.c:1029:13: error: ‘struct drm_crtc’ has no member named ‘crc’
    ../drivers/gpu/drm/drm_dp_helper.c:1031:12: error: ‘struct drm_crtc’ has no member named ‘crc’
      make[4]: *** [drivers/gpu/drm/drm_dp_helper.o] Error 1
      make[4]: *** Waiting for unfinished jobs....
    
    Fixes: 79c1da7c3bf7 ("drm/dp: add helpers for capture of frame CRCs")
    Cc: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: dri-devel@lists.freedesktop.org
    Reviewed-by: Emil Velikov <emil.l.velikov@gmail.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index bda9347554a1..cba29ffedafd 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -776,6 +776,7 @@ struct drm_crtc {
 	 * Debugfs directory for this CRTC.
 	 */
 	struct dentry *debugfs_entry;
+#endif
 
 	/**
 	 * @crc:
@@ -783,7 +784,6 @@ struct drm_crtc {
 	 * Configuration settings of CRC capture.
 	 */
 	struct drm_crtc_crc crc;
-#endif
 
 	/**
 	 * @fence_context:

commit 84e354839b158d87318eb7fa9828d52baceb23c3
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Tue Feb 7 17:16:13 2017 +0800

    drm: add vblank hooks to struct drm_crtc_funcs
    
    The vblank is mostly CRTC specific and implemented as part of CRTC
    driver.  Let's keep the vblank hooks struct drm_driver for legacy
    drivers, and add corresponding hooks in struct drm_crtc_funcs.  These
    hooks take struct drm_crtc pointer as argument, and will be called by
    core vblank handling code for DRIVER_MODESET drivers.
    
    The new hooks get plugged into core by adding wrapper functions for
    vblank handling code.  The .get_vblank_counter hook is effectively
    optional, as we provide drm_vblank_no_hw_counter() as the default
    fallback in the wrapper function.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Reviewed-by: Andrzej Hajda <a.hajda@samsung.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1486458995-31018-2-git-send-email-shawnguo@kernel.org

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c38a572c16aa..bda9347554a1 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -608,6 +608,50 @@ struct drm_crtc_funcs {
 	 */
 	void (*atomic_print_state)(struct drm_printer *p,
 				   const struct drm_crtc_state *state);
+
+	/**
+	 * @get_vblank_counter:
+	 *
+	 * Driver callback for fetching a raw hardware vblank counter for the
+	 * CRTC. It's meant to be used by new drivers as the replacement of
+	 * &drm_driver.get_vblank_counter hook.
+	 *
+	 * This callback is optional. If a device doesn't have a hardware
+	 * counter, the driver can simply leave the hook as NULL. The DRM core
+	 * will account for missed vblank events while interrupts where disabled
+	 * based on system timestamps.
+	 *
+	 * Wraparound handling and loss of events due to modesetting is dealt
+	 * with in the DRM core code, as long as drivers call
+	 * drm_crtc_vblank_off() and drm_crtc_vblank_on() when disabling or
+	 * enabling a CRTC.
+	 *
+	 * Returns:
+	 *
+	 * Raw vblank counter value.
+	 */
+	u32 (*get_vblank_counter)(struct drm_crtc *crtc);
+
+	/**
+	 * @enable_vblank:
+	 *
+	 * Enable vblank interrupts for the CRTC. It's meant to be used by
+	 * new drivers as the replacement of &drm_driver.enable_vblank hook.
+	 *
+	 * Returns:
+	 *
+	 * Zero on success, appropriate errno if the vblank interrupt cannot
+	 * be enabled.
+	 */
+	int (*enable_vblank)(struct drm_crtc *crtc);
+
+	/**
+	 * @disable_vblank:
+	 *
+	 * Disable vblank interrupts for the CRTC. It's meant to be used by
+	 * new drivers as the replacement of &drm_driver.disable_vblank hook.
+	 */
+	void (*disable_vblank)(struct drm_crtc *crtc);
 };
 
 /**

commit 6cbe5c466d73360506a24d98a2e71e47ae02e3ef
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Thu Feb 2 16:56:29 2017 -0500

    drm/atomic: Save flip flags in drm_crtc_state
    
    Allows using atomic flip helpers for drivers
    using ASYNC flip.
    Remove ASYNC_FLIP restriction in helpers and
    caches the page flip flags in drm_crtc_state
    to be used in the low level drivers.
    
    v2:
    Resending the patch since the original was broken.
    
    v3:
    Save flag in crtc_state instead of plane_state
    
    v4:
    Reset the flag before using again.
    
    v5:
    Fix type in header.
    Rename the field to pageflip_flags.
    Remove unrelated hunk.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1486072591-3893-2-git-send-email-Andrey.Grodzovsky@amd.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 8f0b195e4a59..c38a572c16aa 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -155,9 +155,16 @@ struct drm_crtc_state {
 	 * Target vertical blank period when a page flip
 	 * should take effect.
 	 */
-
 	u32 target_vblank;
 
+	/**
+	 * @pageflip_flags:
+	 *
+	 * DRM_MODE_PAGE_FLIP_* flags, as passed to the page flip ioctl.
+	 * Zero in any other case.
+	 */
+	u32 pageflip_flags;
+
 	/**
 	 * @event:
 	 *

commit 559bdaf729bfd4e112c3efce95eb3c894288d281
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jan 25 07:26:55 2017 +0100

    drm/doc: Fix typos for early_unregister doc
    
    There's no late_unregister. While at it switch to the new canonical
    reference style.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170125062657.19270-14-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c2f9fdaf2a66..8f0b195e4a59 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -560,7 +560,7 @@ struct drm_crtc_funcs {
 	 *
 	 * This optional hook should be used to unregister the additional
 	 * userspace interfaces attached to the crtc from
-	 * late_unregister(). It is called from drm_dev_unregister(),
+	 * @late_register. It is called from drm_dev_unregister(),
 	 * early in the driver unload sequence to disable userspace access
 	 * before data structures are torndown.
 	 */

commit 196cd5d3758cbf587fc0254cae7132d95993461e
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jan 25 07:26:56 2017 +0100

    drm: s/drm_crtc_get_hv_timings/drm_mode_get_hv_timings/
    
    The function operates on modes, not CRTCs. Also move it into
    drm_modes.[hc]. Spotted while reviewing CRTC docs.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170125062657.19270-15-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 2404b23cddb4..c2f9fdaf2a66 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -824,8 +824,6 @@ static inline uint32_t drm_crtc_mask(const struct drm_crtc *crtc)
 	return 1 << drm_crtc_index(crtc);
 }
 
-void drm_crtc_get_hv_timing(const struct drm_display_mode *mode,
-			    int *hdisplay, int *vdisplay);
 int drm_crtc_force_disable(struct drm_crtc *crtc);
 int drm_crtc_force_disable_all(struct drm_device *dev);
 

commit d5d487eb07c3e4652cde70651373d6a85173f685
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jan 25 07:26:57 2017 +0100

    drm: Update kerneldoc for drm_crtc.[hc]
    
    After going through all the trouble of splitting out parts from
    drm_crtc.[hc] and then properly documenting each I've entirely
    forgotten to show the same TLC for CRTCs themselves!
    
    Let's make amends asap.
    
    v2: Review from Eric.
    
    Reviewed-by: Eric Engestrom <eric.engestrom@imgtec.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 10661e156d89..2404b23cddb4 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -641,7 +641,7 @@ struct drm_crtc {
 	 *
 	 * This provides a read lock for the overall crtc state (mode, dpms
 	 * state, ...) and a write lock for everything which can be update
-	 * without a full modeset (fb, cursor data, crtc properties ...). Full
+	 * without a full modeset (fb, cursor data, crtc properties ...). A full
 	 * modeset also need to grab &drm_mode_config.connection_mutex.
 	 */
 	struct drm_modeset_lock mutex;
@@ -774,10 +774,8 @@ struct drm_crtc {
  * @connectors: array of connectors to drive with this CRTC if possible
  * @num_connectors: size of @connectors array
  *
- * Represents a single crtc the connectors that it drives with what mode
- * and from which framebuffer it scans out from.
- *
- * This is used to set modes.
+ * This represents a modeset configuration for the legacy SETCRTC ioctl and is
+ * also used internally. Atomic drivers instead use &drm_atomic_state.
  */
 struct drm_mode_set {
 	struct drm_framebuffer *fb;
@@ -834,7 +832,15 @@ int drm_crtc_force_disable_all(struct drm_device *dev);
 int drm_mode_set_config_internal(struct drm_mode_set *set);
 struct drm_crtc *drm_crtc_from_index(struct drm_device *dev, int idx);
 
-/* Helpers */
+/**
+ * drm_crtc_find - look up a CRTC object from its ID
+ * @dev: DRM device
+ * @id: &drm_mode_object ID
+ *
+ * This can be used to look up a CRTC from its userspace ID. Only used by
+ * drivers for legacy IOCTLs and interface, nowadays extensions to the KMS
+ * userspace interface should be done using &drm_property.
+ */
 static inline struct drm_crtc *drm_crtc_find(struct drm_device *dev,
 	uint32_t id)
 {
@@ -843,6 +849,13 @@ static inline struct drm_crtc *drm_crtc_find(struct drm_device *dev,
 	return mo ? obj_to_crtc(mo) : NULL;
 }
 
+/**
+ * drm_for_each_crtc - iterate over all CRTCs
+ * @crtc: a &struct drm_crtc as the loop cursor
+ * @dev: the &struct drm_device
+ *
+ * Iterate over all CRTCs of @dev.
+ */
 #define drm_for_each_crtc(crtc, dev) \
 	list_for_each_entry(crtc, &(dev)->mode_config.crtc_list, head)
 

commit d574528a64c3a3b2a9c6a125e2428b38bddbdf3c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jan 25 07:26:45 2017 +0100

    drm/kms-core: Use recommened kerneldoc for struct member refs
    
    I just learned that &struct_name.member_name works and looks pretty
    even. It doesn't (yet) link to the member directly though, which would
    be really good for big structures or vfunc tables (where the
    per-member kerneldoc tends to be long).
    
    Also some minor drive-by polish where it makes sense, I read a lot
    of docs ...
    
    v2: Review from Eric.
    
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Eric Engestrom <eric.engestrom@imgtec.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170125062657.19270-4-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 06c943d1e04c..10661e156d89 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -81,8 +81,8 @@ struct drm_plane_helper_funcs;
  * @enable: whether the CRTC should be enabled, gates all other state
  * @active: whether the CRTC is actively displaying (used for DPMS)
  * @planes_changed: planes on this crtc are updated
- * @mode_changed: crtc_state->mode or crtc_state->enable has been changed
- * @active_changed: crtc_state->active has been toggled.
+ * @mode_changed: @mode or @enable has been changed
+ * @active_changed: @active has been toggled.
  * @connectors_changed: connectors to this crtc have been updated
  * @zpos_changed: zpos values of planes on this crtc have been updated
  * @color_mgmt_changed: color management properties have changed (degamma or
@@ -102,9 +102,10 @@ struct drm_plane_helper_funcs;
  *
  * Note that the distinction between @enable and @active is rather subtile:
  * Flipping @active while @enable is set without changing anything else may
- * never return in a failure from the ->atomic_check callback. Userspace assumes
- * that a DPMS On will always succeed. In other words: @enable controls resource
- * assignment, @active controls the actual hardware state.
+ * never return in a failure from the &drm_mode_config_funcs.atomic_check
+ * callback. Userspace assumes that a DPMS On will always succeed. In other
+ * words: @enable controls resource assignment, @active controls the actual
+ * hardware state.
  *
  * The three booleans active_changed, connectors_changed and mode_changed are
  * intended to indicate whether a full modeset is needed, rather than strictly
@@ -346,8 +347,8 @@ struct drm_crtc_funcs {
 	 * through the DRM_MODE_PAGE_FLIP_ASYNC flag). When an application
 	 * requests a page flip the DRM core verifies that the new frame buffer
 	 * is large enough to be scanned out by the CRTC in the currently
-	 * configured mode and then calls the CRTC ->page_flip() operation with a
-	 * pointer to the new frame buffer.
+	 * configured mode and then calls this hook with a pointer to the new
+	 * frame buffer.
 	 *
 	 * The driver must wait for any pending rendering to the new framebuffer
 	 * to complete before executing the flip. It should also wait for any
@@ -382,7 +383,7 @@ struct drm_crtc_funcs {
 	 * RETURNS:
 	 *
 	 * 0 on success or a negative error code on failure. Note that if a
-	 * ->page_flip() operation is already pending the callback should return
+	 * page flip operation is already pending the callback should return
 	 * -EBUSY. Pageflips on a disabled CRTC (either by setting a NULL mode
 	 * or just runtime disabled through DPMS respectively the new atomic
 	 * "ACTIVE" state) should result in an -EINVAL error code. Note that
@@ -434,19 +435,19 @@ struct drm_crtc_funcs {
 	 * @atomic_duplicate_state:
 	 *
 	 * Duplicate the current atomic state for this CRTC and return it.
-	 * The core and helpers gurantee that any atomic state duplicated with
+	 * The core and helpers guarantee that any atomic state duplicated with
 	 * this hook and still owned by the caller (i.e. not transferred to the
-	 * driver by calling ->atomic_commit() from struct
-	 * &drm_mode_config_funcs) will be cleaned up by calling the
-	 * @atomic_destroy_state hook in this structure.
+	 * driver by calling &drm_mode_config_funcs.atomic_commit) will be
+	 * cleaned up by calling the @atomic_destroy_state hook in this
+	 * structure.
 	 *
-	 * Atomic drivers which don't subclass &struct drm_crtc should use
+	 * Atomic drivers which don't subclass &struct drm_crtc_state should use
 	 * drm_atomic_helper_crtc_duplicate_state(). Drivers that subclass the
 	 * state structure to extend it with driver-private state should use
 	 * __drm_atomic_helper_crtc_duplicate_state() to make sure shared state is
 	 * duplicated in a consistent fashion across drivers.
 	 *
-	 * It is an error to call this hook before crtc->state has been
+	 * It is an error to call this hook before &drm_crtc.state has been
 	 * initialized correctly.
 	 *
 	 * NOTE:
@@ -641,7 +642,7 @@ struct drm_crtc {
 	 * This provides a read lock for the overall crtc state (mode, dpms
 	 * state, ...) and a write lock for everything which can be update
 	 * without a full modeset (fb, cursor data, crtc properties ...). Full
-	 * modeset also need to grab dev->mode_config.connection_mutex.
+	 * modeset also need to grab &drm_mode_config.connection_mutex.
 	 */
 	struct drm_modeset_lock mutex;
 

commit f869a6ecf254194d96f82c71f528a2bcc048d44b
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Fri Jan 6 15:39:40 2017 -0500

    drm/atomic: Add target_vblank support in atomic helpers (v2)
    
    Allows usage of the new page_flip_target hook for drivers implementing
    the atomic path.
    Provides default atomic helper for the new hook.
    
    v2:
    Update code sharing logic between exsiting and the new flip hooks.
    Improve kerneldoc.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1483735180-4173-1-git-send-email-Andrey.Grodzovsky@amd.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 17c9f52d6ecb..06c943d1e04c 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -148,6 +148,15 @@ struct drm_crtc_state {
 	struct drm_property_blob *ctm;
 	struct drm_property_blob *gamma_lut;
 
+	/**
+	 * @target_vblank:
+	 *
+	 * Target vertical blank period when a page flip
+	 * should take effect.
+	 */
+
+	u32 target_vblank;
+
 	/**
 	 * @event:
 	 *

commit 347e89034a3b70123d0481712883c03cc704eb68
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Dec 29 21:48:27 2016 +0100

    drm: Nuke connector_list locking assert
    
    I've forgotten to remove this when revamping the
    connector_list locking.
    
    Cc: seanpaul@chromium.org
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1483044517-5770-7-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index e9bc21950439..17c9f52d6ecb 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -836,18 +836,4 @@ static inline struct drm_crtc *drm_crtc_find(struct drm_device *dev,
 #define drm_for_each_crtc(crtc, dev) \
 	list_for_each_entry(crtc, &(dev)->mode_config.crtc_list, head)
 
-static inline void
-assert_drm_connector_list_read_locked(struct drm_mode_config *mode_config)
-{
-	/*
-	 * The connector hotadd/remove code currently grabs both locks when
-	 * updating lists. Hence readers need only hold either of them to be
-	 * safe and the check amounts to
-	 *
-	 * WARN_ON(not_holding(A) && not_holding(B)).
-	 */
-	WARN_ON(!mutex_is_locked(&mode_config->mutex) &&
-		!drm_modeset_is_locked(&mode_config->connection_mutex));
-}
-
 #endif /* __DRM_CRTC_H__ */

commit ea0dd85a75f15174cc2bf75f805e378391995931
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Dec 29 21:48:26 2016 +0100

    drm/doc: use preferred struct reference in kernel-doc
    
    sed -e 's/\( \* .*\)struct &\([_a-z]*\)/\1\&struct \2/' -i
    
    Originally I wasnt a friend of this style because I thought a
    line-break between the "&struct" and "foo" part would break it. But a
    quick test shows that " * &struct \n * foo\n" works pefectly well with
    current kernel-doc. So time to mass-apply these changes!
    
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1483044517-5770-6-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 89daa77c37fc..e9bc21950439 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -315,7 +315,7 @@ struct drm_crtc_funcs {
 	 *
 	 * This is the main legacy entry point to change the modeset state on a
 	 * CRTC. All the details of the desired configuration are passed in a
-	 * struct &drm_mode_set - see there for details.
+	 * &struct drm_mode_set - see there for details.
 	 *
 	 * Drivers implementing atomic modeset should use
 	 * drm_atomic_helper_set_config() to implement this hook.
@@ -346,7 +346,7 @@ struct drm_crtc_funcs {
 	 * shared dma-buf.
 	 *
 	 * An application can request to be notified when the page flip has
-	 * completed. The drm core will supply a struct &drm_event in the event
+	 * completed. The drm core will supply a &struct drm_event in the event
 	 * parameter in this case. This can be handled by the
 	 * drm_crtc_send_vblank_event() function, which the driver should call on
 	 * the provided event upon completion of the flip. Note that if
@@ -431,7 +431,7 @@ struct drm_crtc_funcs {
 	 * &drm_mode_config_funcs) will be cleaned up by calling the
 	 * @atomic_destroy_state hook in this structure.
 	 *
-	 * Atomic drivers which don't subclass struct &drm_crtc should use
+	 * Atomic drivers which don't subclass &struct drm_crtc should use
 	 * drm_atomic_helper_crtc_duplicate_state(). Drivers that subclass the
 	 * state structure to extend it with driver-private state should use
 	 * __drm_atomic_helper_crtc_duplicate_state() to make sure shared state is
@@ -583,7 +583,7 @@ struct drm_crtc_funcs {
 	/**
 	 * @atomic_print_state:
 	 *
-	 * If driver subclasses struct &drm_crtc_state, it should implement
+	 * If driver subclasses &struct drm_crtc_state, it should implement
 	 * this optional hook for printing additional driver specific state.
 	 *
 	 * Do not call this directly, use drm_atomic_crtc_print_state()

commit 6d1b81d8e25d81b4ed4363fa3e7d70aa563b7112
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Thu Dec 29 20:41:28 2016 +0800

    drm: add crtc helper drm_crtc_from_index()
    
    It adds a crtc helper drm_crtc_from_index() to find the registered CRTC
    with a given index, just like drm_plane_from_index().
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1483015290-16660-2-git-send-email-shawnguo@kernel.org

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 6920dee3a2d1..89daa77c37fc 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -822,6 +822,7 @@ int drm_crtc_force_disable(struct drm_crtc *crtc);
 int drm_crtc_force_disable_all(struct drm_device *dev);
 
 int drm_mode_set_config_internal(struct drm_mode_set *set);
+struct drm_crtc *drm_crtc_from_index(struct drm_device *dev, int idx);
 
 /* Helpers */
 static inline struct drm_crtc *drm_crtc_find(struct drm_device *dev,

commit bdc571464c49740ce56c56e108d60f825336eb89
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Thu Dec 15 12:51:42 2016 +0100

    drm/atomic: Clean up wait_for_vblanks, v2.
    
    Stop relying on a per crtc_state last_vblank_count, we shouldn't touch
    crtc_state after commit. Move it to atomic_state->crtcs.
    
    Also stop re-using new_crtc_state->enable, we can now simply set a
    bitmask with crtc_crtc_mask.
    
    Changes since v1:
    - Keep last_vblank_count in __drm_crtc_state.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/8e4759a4-24d3-3f80-bd1a-1e7a9c83b612@linux.intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 9ef0ac0ce69f..6920dee3a2d1 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -90,8 +90,6 @@ struct drm_plane_helper_funcs;
  * @plane_mask: bitmask of (1 << drm_plane_index(plane)) of attached planes
  * @connector_mask: bitmask of (1 << drm_connector_index(connector)) of attached connectors
  * @encoder_mask: bitmask of (1 << drm_encoder_index(encoder)) of attached encoders
- * @last_vblank_count: for helpers and drivers to capture the vblank of the
- * 	update to ensure framebuffer cleanup isn't done too early
  * @adjusted_mode: for use by helpers and drivers to compute adjusted mode timings
  * @mode: current mode timings
  * @mode_blob: &drm_property_blob for @mode
@@ -137,9 +135,6 @@ struct drm_crtc_state {
 	u32 connector_mask;
 	u32 encoder_mask;
 
-	/* last_vblank_count: for vblank waits before cleanup */
-	u32 last_vblank_count;
-
 	/* adjusted_mode: for use by helpers and drivers */
 	struct drm_display_mode adjusted_mode;
 

commit 9338203c4f03ffe323b67f0b2fa17b9811fa9bb6
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Nov 28 20:51:09 2016 +0200

    drm: Don't include <drm/drm_encoder.h> in <drm/drm_crtc.h>
    
    <drm/drm_crtc.h> used to define most of the in-kernel KMS API. It has
    now been split into separate files for each object type, but still
    includes most other KMS headers to avoid breaking driver compilation.
    
    As a step towards fixing that problem, remove the inclusion of
    <drm/drm_encoder.h> from <drm/drm_crtc.h> and include it instead where
    appropriate. Also remove the forward declarations of the drm_encoder and
    drm_encoder_helper_funcs structures from <drm/drm_crtc.h> as they're not
    needed in the header.
    
    <drm/drm_encoder.h> now has to include <drm/drm_mode.h> and contain a
    forward declaration of struct drm_encoder in order to allow including it
    as the first header in a compilation unit.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com> # For vmwgfx
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1481709550-29226-2-git-send-email-laurent.pinchart+renesas@ideasonboard.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 946672f97e1e..9ef0ac0ce69f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -39,7 +39,6 @@
 #include <drm/drm_framebuffer.h>
 #include <drm/drm_modes.h>
 #include <drm/drm_connector.h>
-#include <drm/drm_encoder.h>
 #include <drm/drm_property.h>
 #include <drm/drm_bridge.h>
 #include <drm/drm_edid.h>
@@ -68,14 +67,12 @@ static inline uint64_t I642U64(int64_t val)
 }
 
 struct drm_crtc;
-struct drm_encoder;
 struct drm_pending_vblank_event;
 struct drm_plane;
 struct drm_bridge;
 struct drm_atomic_state;
 
 struct drm_crtc_helper_funcs;
-struct drm_encoder_helper_funcs;
 struct drm_plane_helper_funcs;
 
 /**

commit 6d6003c4b613c93973e4e870d83f4bed2ad9ac34
Author: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Date:   Tue Nov 15 23:37:08 2016 +0900

    drm/fence: add fence timeline to drm_crtc
    
    Create one timeline context for each CRTC to be able to handle out-fences
    and signal them. It adds a few members to struct drm_crtc: fence_context,
    where we store the context we get from fence_context_alloc(), the
    fence seqno and the fence lock, that we pass in fence_init() to be
    used by the fence.
    
    v2: Comment by Daniel Stone:
            - add BUG_ON() to fence_to_crtc() macro
    
    v3: Comment by Ville Syrjälä
            - Use more meaningful name as crtc timeline name
    
    v4: Comments by Brian Starkey
            - Use even more meaninful name for the crtc timeline
            - add doc for timeline_name
        Comment by Daniel Vetter
            - use in-line style for comments
    
        - rebase after fence -> dma_fence rename
    
    v5: Comment by Daniel Vetter
            - Add doc for drm_crtc_fence_ops
    
    v6: Comment by Chris Wilson
            - Move fence_to_crtc to drm_crtc.c
            - Move export of drm_crtc_fence_ops to drm_crtc_internal.h
    
        - rebase against latest drm-misc
    
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch> (v5)
    Reviewed-by: Sean Paul <seanpaul@chromium.org> (v5)
    Tested-by: Robert Foss <robert.foss@collabora.com> (v5)
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1479220628-10204-1-git-send-email-gustavo@padovan.org

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index bcc1a4d1d1a6..946672f97e1e 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -731,6 +731,35 @@ struct drm_crtc {
 	 */
 	struct drm_crtc_crc crc;
 #endif
+
+	/**
+	 * @fence_context:
+	 *
+	 * timeline context used for fence operations.
+	 */
+	unsigned int fence_context;
+
+	/**
+	 * @fence_lock:
+	 *
+	 * spinlock to protect the fences in the fence_context.
+	 */
+
+	spinlock_t fence_lock;
+	/**
+	 * @fence_seqno:
+	 *
+	 * Seqno variable used as monotonic counter for the fences
+	 * created on the CRTC's timeline.
+	 */
+	unsigned long fence_seqno;
+
+	/**
+	 * @timeline_name:
+	 *
+	 * The name of the CRTC's fence timeline.
+	 */
+	char timeline_name[32];
 };
 
 /**

commit edd420eaffb3a618ddc8740683abc039ad97237f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Nov 14 12:58:25 2016 +0100

    drm: Drop externs from drm_crtc.h
    
    Just noise.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161114115825.22050-11-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index cf96b393091a..bcc1a4d1d1a6 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -762,14 +762,14 @@ struct drm_mode_set {
 
 #define obj_to_crtc(x) container_of(x, struct drm_crtc, base)
 
-extern __printf(6, 7)
+__printf(6, 7)
 int drm_crtc_init_with_planes(struct drm_device *dev,
 			      struct drm_crtc *crtc,
 			      struct drm_plane *primary,
 			      struct drm_plane *cursor,
 			      const struct drm_crtc_funcs *funcs,
 			      const char *name, ...);
-extern void drm_crtc_cleanup(struct drm_crtc *crtc);
+void drm_crtc_cleanup(struct drm_crtc *crtc);
 
 /**
  * drm_crtc_index - find the index of a registered CRTC
@@ -795,12 +795,12 @@ static inline uint32_t drm_crtc_mask(const struct drm_crtc *crtc)
 	return 1 << drm_crtc_index(crtc);
 }
 
-extern void drm_crtc_get_hv_timing(const struct drm_display_mode *mode,
-				   int *hdisplay, int *vdisplay);
-extern int drm_crtc_force_disable(struct drm_crtc *crtc);
-extern int drm_crtc_force_disable_all(struct drm_device *dev);
+void drm_crtc_get_hv_timing(const struct drm_display_mode *mode,
+			    int *hdisplay, int *vdisplay);
+int drm_crtc_force_disable(struct drm_crtc *crtc);
+int drm_crtc_force_disable_all(struct drm_device *dev);
 
-extern int drm_mode_set_config_internal(struct drm_mode_set *set);
+int drm_mode_set_config_internal(struct drm_mode_set *set);
 
 /* Helpers */
 static inline struct drm_crtc *drm_crtc_find(struct drm_device *dev,

commit 9498c19b3f53e08c61b344ce8dbc92c9c96f23c5
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Nov 14 12:58:24 2016 +0100

    drm: Move tile group code into drm_connector.c
    
    And also put the overview section into the KMS Properties part of the
    docs, instead of randomly-placed within the helpers - this is part of
    the uabi.
    
    With this patch I think drm_crtc.[hc] is cleaned up and entirely
    documented.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 98de488a95a5..cf96b393091a 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -67,14 +67,6 @@ static inline uint64_t I642U64(int64_t val)
 	return (uint64_t)*((uint64_t *)&val);
 }
 
-/* data corresponds to displayid vend/prod/serial */
-struct drm_tile_group {
-	struct kref refcount;
-	struct drm_device *dev;
-	int id;
-	u8 group_data[8];
-};
-
 struct drm_crtc;
 struct drm_encoder;
 struct drm_pending_vblank_event;
@@ -810,13 +802,6 @@ extern int drm_crtc_force_disable_all(struct drm_device *dev);
 
 extern int drm_mode_set_config_internal(struct drm_mode_set *set);
 
-extern struct drm_tile_group *drm_mode_create_tile_group(struct drm_device *dev,
-							 char topology[8]);
-extern struct drm_tile_group *drm_mode_get_tile_group(struct drm_device *dev,
-					       char topology[8]);
-extern void drm_mode_put_tile_group(struct drm_device *dev,
-				   struct drm_tile_group *tg);
-
 /* Helpers */
 static inline struct drm_crtc *drm_crtc_find(struct drm_device *dev,
 	uint32_t id)

commit 28575f165d36051310d7ea2350e2011f8095b6fb
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Nov 14 12:58:23 2016 +0100

    drm: Extract drm_mode_config.[hc]
    
    And shuffle the kernel-doc structure a bit since drm_crtc.[hc] now
    only contains CRTC-related functions and structures.
    
    v2:
    - rebase onto drm-misc
    - don't forget to move drm_mode_config_cleanup.
    - move 2 internal decls under the right heading (Chris)
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 8cca2a895981..98de488a95a5 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -28,7 +28,6 @@
 #include <linux/i2c.h>
 #include <linux/spinlock.h>
 #include <linux/types.h>
-#include <linux/idr.h>
 #include <linux/fb.h>
 #include <linux/hdmi.h>
 #include <linux/media-bus-format.h>
@@ -48,6 +47,7 @@
 #include <drm/drm_blend.h>
 #include <drm/drm_color_mgmt.h>
 #include <drm/drm_debugfs_crc.h>
+#include <drm/drm_mode_config.h>
 
 struct drm_device;
 struct drm_mode_set;
@@ -768,616 +768,6 @@ struct drm_mode_set {
 	size_t num_connectors;
 };
 
-/**
- * struct drm_mode_config_funcs - basic driver provided mode setting functions
- *
- * Some global (i.e. not per-CRTC, connector, etc) mode setting functions that
- * involve drivers.
- */
-struct drm_mode_config_funcs {
-	/**
-	 * @fb_create:
-	 *
-	 * Create a new framebuffer object. The core does basic checks on the
-	 * requested metadata, but most of that is left to the driver. See
-	 * struct &drm_mode_fb_cmd2 for details.
-	 *
-	 * If the parameters are deemed valid and the backing storage objects in
-	 * the underlying memory manager all exist, then the driver allocates
-	 * a new &drm_framebuffer structure, subclassed to contain
-	 * driver-specific information (like the internal native buffer object
-	 * references). It also needs to fill out all relevant metadata, which
-	 * should be done by calling drm_helper_mode_fill_fb_struct().
-	 *
-	 * The initialization is finalized by calling drm_framebuffer_init(),
-	 * which registers the framebuffer and makes it accessible to other
-	 * threads.
-	 *
-	 * RETURNS:
-	 *
-	 * A new framebuffer with an initial reference count of 1 or a negative
-	 * error code encoded with ERR_PTR().
-	 */
-	struct drm_framebuffer *(*fb_create)(struct drm_device *dev,
-					     struct drm_file *file_priv,
-					     const struct drm_mode_fb_cmd2 *mode_cmd);
-
-	/**
-	 * @output_poll_changed:
-	 *
-	 * Callback used by helpers to inform the driver of output configuration
-	 * changes.
-	 *
-	 * Drivers implementing fbdev emulation with the helpers can call
-	 * drm_fb_helper_hotplug_changed from this hook to inform the fbdev
-	 * helper of output changes.
-	 *
-	 * FIXME:
-	 *
-	 * Except that there's no vtable for device-level helper callbacks
-	 * there's no reason this is a core function.
-	 */
-	void (*output_poll_changed)(struct drm_device *dev);
-
-	/**
-	 * @atomic_check:
-	 *
-	 * This is the only hook to validate an atomic modeset update. This
-	 * function must reject any modeset and state changes which the hardware
-	 * or driver doesn't support. This includes but is of course not limited
-	 * to:
-	 *
-	 *  - Checking that the modes, framebuffers, scaling and placement
-	 *    requirements and so on are within the limits of the hardware.
-	 *
-	 *  - Checking that any hidden shared resources are not oversubscribed.
-	 *    This can be shared PLLs, shared lanes, overall memory bandwidth,
-	 *    display fifo space (where shared between planes or maybe even
-	 *    CRTCs).
-	 *
-	 *  - Checking that virtualized resources exported to userspace are not
-	 *    oversubscribed. For various reasons it can make sense to expose
-	 *    more planes, crtcs or encoders than which are physically there. One
-	 *    example is dual-pipe operations (which generally should be hidden
-	 *    from userspace if when lockstepped in hardware, exposed otherwise),
-	 *    where a plane might need 1 hardware plane (if it's just on one
-	 *    pipe), 2 hardware planes (when it spans both pipes) or maybe even
-	 *    shared a hardware plane with a 2nd plane (if there's a compatible
-	 *    plane requested on the area handled by the other pipe).
-	 *
-	 *  - Check that any transitional state is possible and that if
-	 *    requested, the update can indeed be done in the vblank period
-	 *    without temporarily disabling some functions.
-	 *
-	 *  - Check any other constraints the driver or hardware might have.
-	 *
-	 *  - This callback also needs to correctly fill out the &drm_crtc_state
-	 *    in this update to make sure that drm_atomic_crtc_needs_modeset()
-	 *    reflects the nature of the possible update and returns true if and
-	 *    only if the update cannot be applied without tearing within one
-	 *    vblank on that CRTC. The core uses that information to reject
-	 *    updates which require a full modeset (i.e. blanking the screen, or
-	 *    at least pausing updates for a substantial amount of time) if
-	 *    userspace has disallowed that in its request.
-	 *
-	 *  - The driver also does not need to repeat basic input validation
-	 *    like done for the corresponding legacy entry points. The core does
-	 *    that before calling this hook.
-	 *
-	 * See the documentation of @atomic_commit for an exhaustive list of
-	 * error conditions which don't have to be checked at the
-	 * ->atomic_check() stage?
-	 *
-	 * See the documentation for struct &drm_atomic_state for how exactly
-	 * an atomic modeset update is described.
-	 *
-	 * Drivers using the atomic helpers can implement this hook using
-	 * drm_atomic_helper_check(), or one of the exported sub-functions of
-	 * it.
-	 *
-	 * RETURNS:
-	 *
-	 * 0 on success or one of the below negative error codes:
-	 *
-	 *  - -EINVAL, if any of the above constraints are violated.
-	 *
-	 *  - -EDEADLK, when returned from an attempt to acquire an additional
-	 *    &drm_modeset_lock through drm_modeset_lock().
-	 *
-	 *  - -ENOMEM, if allocating additional state sub-structures failed due
-	 *    to lack of memory.
-	 *
-	 *  - -EINTR, -EAGAIN or -ERESTARTSYS, if the IOCTL should be restarted.
-	 *    This can either be due to a pending signal, or because the driver
-	 *    needs to completely bail out to recover from an exceptional
-	 *    situation like a GPU hang. From a userspace point all errors are
-	 *    treated equally.
-	 */
-	int (*atomic_check)(struct drm_device *dev,
-			    struct drm_atomic_state *state);
-
-	/**
-	 * @atomic_commit:
-	 *
-	 * This is the only hook to commit an atomic modeset update. The core
-	 * guarantees that @atomic_check has been called successfully before
-	 * calling this function, and that nothing has been changed in the
-	 * interim.
-	 *
-	 * See the documentation for struct &drm_atomic_state for how exactly
-	 * an atomic modeset update is described.
-	 *
-	 * Drivers using the atomic helpers can implement this hook using
-	 * drm_atomic_helper_commit(), or one of the exported sub-functions of
-	 * it.
-	 *
-	 * Nonblocking commits (as indicated with the nonblock parameter) must
-	 * do any preparatory work which might result in an unsuccessful commit
-	 * in the context of this callback. The only exceptions are hardware
-	 * errors resulting in -EIO. But even in that case the driver must
-	 * ensure that the display pipe is at least running, to avoid
-	 * compositors crashing when pageflips don't work. Anything else,
-	 * specifically committing the update to the hardware, should be done
-	 * without blocking the caller. For updates which do not require a
-	 * modeset this must be guaranteed.
-	 *
-	 * The driver must wait for any pending rendering to the new
-	 * framebuffers to complete before executing the flip. It should also
-	 * wait for any pending rendering from other drivers if the underlying
-	 * buffer is a shared dma-buf. Nonblocking commits must not wait for
-	 * rendering in the context of this callback.
-	 *
-	 * An application can request to be notified when the atomic commit has
-	 * completed. These events are per-CRTC and can be distinguished by the
-	 * CRTC index supplied in &drm_event to userspace.
-	 *
-	 * The drm core will supply a struct &drm_event in the event
-	 * member of each CRTC's &drm_crtc_state structure. See the
-	 * documentation for &drm_crtc_state for more details about the precise
-	 * semantics of this event.
-	 *
-	 * NOTE:
-	 *
-	 * Drivers are not allowed to shut down any display pipe successfully
-	 * enabled through an atomic commit on their own. Doing so can result in
-	 * compositors crashing if a page flip is suddenly rejected because the
-	 * pipe is off.
-	 *
-	 * RETURNS:
-	 *
-	 * 0 on success or one of the below negative error codes:
-	 *
-	 *  - -EBUSY, if a nonblocking updated is requested and there is
-	 *    an earlier updated pending. Drivers are allowed to support a queue
-	 *    of outstanding updates, but currently no driver supports that.
-	 *    Note that drivers must wait for preceding updates to complete if a
-	 *    synchronous update is requested, they are not allowed to fail the
-	 *    commit in that case.
-	 *
-	 *  - -ENOMEM, if the driver failed to allocate memory. Specifically
-	 *    this can happen when trying to pin framebuffers, which must only
-	 *    be done when committing the state.
-	 *
-	 *  - -ENOSPC, as a refinement of the more generic -ENOMEM to indicate
-	 *    that the driver has run out of vram, iommu space or similar GPU
-	 *    address space needed for framebuffer.
-	 *
-	 *  - -EIO, if the hardware completely died.
-	 *
-	 *  - -EINTR, -EAGAIN or -ERESTARTSYS, if the IOCTL should be restarted.
-	 *    This can either be due to a pending signal, or because the driver
-	 *    needs to completely bail out to recover from an exceptional
-	 *    situation like a GPU hang. From a userspace point of view all errors are
-	 *    treated equally.
-	 *
-	 * This list is exhaustive. Specifically this hook is not allowed to
-	 * return -EINVAL (any invalid requests should be caught in
-	 * @atomic_check) or -EDEADLK (this function must not acquire
-	 * additional modeset locks).
-	 */
-	int (*atomic_commit)(struct drm_device *dev,
-			     struct drm_atomic_state *state,
-			     bool nonblock);
-
-	/**
-	 * @atomic_state_alloc:
-	 *
-	 * This optional hook can be used by drivers that want to subclass struct
-	 * &drm_atomic_state to be able to track their own driver-private global
-	 * state easily. If this hook is implemented, drivers must also
-	 * implement @atomic_state_clear and @atomic_state_free.
-	 *
-	 * RETURNS:
-	 *
-	 * A new &drm_atomic_state on success or NULL on failure.
-	 */
-	struct drm_atomic_state *(*atomic_state_alloc)(struct drm_device *dev);
-
-	/**
-	 * @atomic_state_clear:
-	 *
-	 * This hook must clear any driver private state duplicated into the
-	 * passed-in &drm_atomic_state. This hook is called when the caller
-	 * encountered a &drm_modeset_lock deadlock and needs to drop all
-	 * already acquired locks as part of the deadlock avoidance dance
-	 * implemented in drm_modeset_lock_backoff().
-	 *
-	 * Any duplicated state must be invalidated since a concurrent atomic
-	 * update might change it, and the drm atomic interfaces always apply
-	 * updates as relative changes to the current state.
-	 *
-	 * Drivers that implement this must call drm_atomic_state_default_clear()
-	 * to clear common state.
-	 */
-	void (*atomic_state_clear)(struct drm_atomic_state *state);
-
-	/**
-	 * @atomic_state_free:
-	 *
-	 * This hook needs driver private resources and the &drm_atomic_state
-	 * itself. Note that the core first calls drm_atomic_state_clear() to
-	 * avoid code duplicate between the clear and free hooks.
-	 *
-	 * Drivers that implement this must call drm_atomic_state_default_free()
-	 * to release common resources.
-	 */
-	void (*atomic_state_free)(struct drm_atomic_state *state);
-};
-
-/**
- * struct drm_mode_config - Mode configuration control structure
- * @mutex: mutex protecting KMS related lists and structures
- * @connection_mutex: ww mutex protecting connector state and routing
- * @acquire_ctx: global implicit acquire context used by atomic drivers for
- * 	legacy IOCTLs
- * @fb_lock: mutex to protect fb state and lists
- * @num_fb: number of fbs available
- * @fb_list: list of framebuffers available
- * @num_encoder: number of encoders on this device
- * @encoder_list: list of encoder objects
- * @num_overlay_plane: number of overlay planes on this device
- * @num_total_plane: number of universal (i.e. with primary/curso) planes on this device
- * @plane_list: list of plane objects
- * @num_crtc: number of CRTCs on this device
- * @crtc_list: list of CRTC objects
- * @property_list: list of property objects
- * @min_width: minimum pixel width on this device
- * @min_height: minimum pixel height on this device
- * @max_width: maximum pixel width on this device
- * @max_height: maximum pixel height on this device
- * @funcs: core driver provided mode setting functions
- * @fb_base: base address of the framebuffer
- * @poll_enabled: track polling support for this device
- * @poll_running: track polling status for this device
- * @delayed_event: track delayed poll uevent deliver for this device
- * @output_poll_work: delayed work for polling in process context
- * @property_blob_list: list of all the blob property objects
- * @blob_lock: mutex for blob property allocation and management
- * @*_property: core property tracking
- * @preferred_depth: preferred RBG pixel depth, used by fb helpers
- * @prefer_shadow: hint to userspace to prefer shadow-fb rendering
- * @cursor_width: hint to userspace for max cursor width
- * @cursor_height: hint to userspace for max cursor height
- * @helper_private: mid-layer private data
- *
- * Core mode resource tracking structure.  All CRTC, encoders, and connectors
- * enumerated by the driver are added here, as are global properties.  Some
- * global restrictions are also here, e.g. dimension restrictions.
- */
-struct drm_mode_config {
-	struct mutex mutex; /* protects configuration (mode lists etc.) */
-	struct drm_modeset_lock connection_mutex; /* protects connector->encoder and encoder->crtc links */
-	struct drm_modeset_acquire_ctx *acquire_ctx; /* for legacy _lock_all() / _unlock_all() */
-
-	/**
-	 * @idr_mutex:
-	 *
-	 * Mutex for KMS ID allocation and management. Protects both @crtc_idr
-	 * and @tile_idr.
-	 */
-	struct mutex idr_mutex;
-
-	/**
-	 * @crtc_idr:
-	 *
-	 * Main KMS ID tracking object. Use this idr for all IDs, fb, crtc,
-	 * connector, modes - just makes life easier to have only one.
-	 */
-	struct idr crtc_idr;
-
-	/**
-	 * @tile_idr:
-	 *
-	 * Use this idr for allocating new IDs for tiled sinks like use in some
-	 * high-res DP MST screens.
-	 */
-	struct idr tile_idr;
-
-	struct mutex fb_lock; /* proctects global and per-file fb lists */
-	int num_fb;
-	struct list_head fb_list;
-
-	/**
-	 * @num_connector: Number of connectors on this device.
-	 */
-	int num_connector;
-	/**
-	 * @connector_ida: ID allocator for connector indices.
-	 */
-	struct ida connector_ida;
-	/**
-	 * @connector_list: List of connector objects.
-	 */
-	struct list_head connector_list;
-	int num_encoder;
-	struct list_head encoder_list;
-
-	/*
-	 * Track # of overlay planes separately from # of total planes.  By
-	 * default we only advertise overlay planes to userspace; if userspace
-	 * sets the "universal plane" capability bit, we'll go ahead and
-	 * expose all planes.
-	 */
-	int num_overlay_plane;
-	int num_total_plane;
-	struct list_head plane_list;
-
-	int num_crtc;
-	struct list_head crtc_list;
-
-	struct list_head property_list;
-
-	int min_width, min_height;
-	int max_width, max_height;
-	const struct drm_mode_config_funcs *funcs;
-	resource_size_t fb_base;
-
-	/* output poll support */
-	bool poll_enabled;
-	bool poll_running;
-	bool delayed_event;
-	struct delayed_work output_poll_work;
-
-	struct mutex blob_lock;
-
-	/* pointers to standard properties */
-	struct list_head property_blob_list;
-	/**
-	 * @edid_property: Default connector property to hold the EDID of the
-	 * currently connected sink, if any.
-	 */
-	struct drm_property *edid_property;
-	/**
-	 * @dpms_property: Default connector property to control the
-	 * connector's DPMS state.
-	 */
-	struct drm_property *dpms_property;
-	/**
-	 * @path_property: Default connector property to hold the DP MST path
-	 * for the port.
-	 */
-	struct drm_property *path_property;
-	/**
-	 * @tile_property: Default connector property to store the tile
-	 * position of a tiled screen, for sinks which need to be driven with
-	 * multiple CRTCs.
-	 */
-	struct drm_property *tile_property;
-	/**
-	 * @plane_type_property: Default plane property to differentiate
-	 * CURSOR, PRIMARY and OVERLAY legacy uses of planes.
-	 */
-	struct drm_property *plane_type_property;
-	/**
-	 * @prop_src_x: Default atomic plane property for the plane source
-	 * position in the connected &drm_framebuffer.
-	 */
-	struct drm_property *prop_src_x;
-	/**
-	 * @prop_src_y: Default atomic plane property for the plane source
-	 * position in the connected &drm_framebuffer.
-	 */
-	struct drm_property *prop_src_y;
-	/**
-	 * @prop_src_w: Default atomic plane property for the plane source
-	 * position in the connected &drm_framebuffer.
-	 */
-	struct drm_property *prop_src_w;
-	/**
-	 * @prop_src_h: Default atomic plane property for the plane source
-	 * position in the connected &drm_framebuffer.
-	 */
-	struct drm_property *prop_src_h;
-	/**
-	 * @prop_crtc_x: Default atomic plane property for the plane destination
-	 * position in the &drm_crtc is is being shown on.
-	 */
-	struct drm_property *prop_crtc_x;
-	/**
-	 * @prop_crtc_y: Default atomic plane property for the plane destination
-	 * position in the &drm_crtc is is being shown on.
-	 */
-	struct drm_property *prop_crtc_y;
-	/**
-	 * @prop_crtc_w: Default atomic plane property for the plane destination
-	 * position in the &drm_crtc is is being shown on.
-	 */
-	struct drm_property *prop_crtc_w;
-	/**
-	 * @prop_crtc_h: Default atomic plane property for the plane destination
-	 * position in the &drm_crtc is is being shown on.
-	 */
-	struct drm_property *prop_crtc_h;
-	/**
-	 * @prop_fb_id: Default atomic plane property to specify the
-	 * &drm_framebuffer.
-	 */
-	struct drm_property *prop_fb_id;
-	/**
-	 * @prop_crtc_id: Default atomic plane property to specify the
-	 * &drm_crtc.
-	 */
-	struct drm_property *prop_crtc_id;
-	/**
-	 * @prop_active: Default atomic CRTC property to control the active
-	 * state, which is the simplified implementation for DPMS in atomic
-	 * drivers.
-	 */
-	struct drm_property *prop_active;
-	/**
-	 * @prop_mode_id: Default atomic CRTC property to set the mode for a
-	 * CRTC. A 0 mode implies that the CRTC is entirely disabled - all
-	 * connectors must be of and active must be set to disabled, too.
-	 */
-	struct drm_property *prop_mode_id;
-
-	/**
-	 * @dvi_i_subconnector_property: Optional DVI-I property to
-	 * differentiate between analog or digital mode.
-	 */
-	struct drm_property *dvi_i_subconnector_property;
-	/**
-	 * @dvi_i_select_subconnector_property: Optional DVI-I property to
-	 * select between analog or digital mode.
-	 */
-	struct drm_property *dvi_i_select_subconnector_property;
-
-	/**
-	 * @tv_subconnector_property: Optional TV property to differentiate
-	 * between different TV connector types.
-	 */
-	struct drm_property *tv_subconnector_property;
-	/**
-	 * @tv_select_subconnector_property: Optional TV property to select
-	 * between different TV connector types.
-	 */
-	struct drm_property *tv_select_subconnector_property;
-	/**
-	 * @tv_mode_property: Optional TV property to select
-	 * the output TV mode.
-	 */
-	struct drm_property *tv_mode_property;
-	/**
-	 * @tv_left_margin_property: Optional TV property to set the left
-	 * margin.
-	 */
-	struct drm_property *tv_left_margin_property;
-	/**
-	 * @tv_right_margin_property: Optional TV property to set the right
-	 * margin.
-	 */
-	struct drm_property *tv_right_margin_property;
-	/**
-	 * @tv_top_margin_property: Optional TV property to set the right
-	 * margin.
-	 */
-	struct drm_property *tv_top_margin_property;
-	/**
-	 * @tv_bottom_margin_property: Optional TV property to set the right
-	 * margin.
-	 */
-	struct drm_property *tv_bottom_margin_property;
-	/**
-	 * @tv_brightness_property: Optional TV property to set the
-	 * brightness.
-	 */
-	struct drm_property *tv_brightness_property;
-	/**
-	 * @tv_contrast_property: Optional TV property to set the
-	 * contrast.
-	 */
-	struct drm_property *tv_contrast_property;
-	/**
-	 * @tv_flicker_reduction_property: Optional TV property to control the
-	 * flicker reduction mode.
-	 */
-	struct drm_property *tv_flicker_reduction_property;
-	/**
-	 * @tv_overscan_property: Optional TV property to control the overscan
-	 * setting.
-	 */
-	struct drm_property *tv_overscan_property;
-	/**
-	 * @tv_saturation_property: Optional TV property to set the
-	 * saturation.
-	 */
-	struct drm_property *tv_saturation_property;
-	/**
-	 * @tv_hue_property: Optional TV property to set the hue.
-	 */
-	struct drm_property *tv_hue_property;
-
-	/**
-	 * @scaling_mode_property: Optional connector property to control the
-	 * upscaling, mostly used for built-in panels.
-	 */
-	struct drm_property *scaling_mode_property;
-	/**
-	 * @aspect_ratio_property: Optional connector property to control the
-	 * HDMI infoframe aspect ratio setting.
-	 */
-	struct drm_property *aspect_ratio_property;
-	/**
-	 * @degamma_lut_property: Optional CRTC property to set the LUT used to
-	 * convert the framebuffer's colors to linear gamma.
-	 */
-	struct drm_property *degamma_lut_property;
-	/**
-	 * @degamma_lut_size_property: Optional CRTC property for the size of
-	 * the degamma LUT as supported by the driver (read-only).
-	 */
-	struct drm_property *degamma_lut_size_property;
-	/**
-	 * @ctm_property: Optional CRTC property to set the
-	 * matrix used to convert colors after the lookup in the
-	 * degamma LUT.
-	 */
-	struct drm_property *ctm_property;
-	/**
-	 * @gamma_lut_property: Optional CRTC property to set the LUT used to
-	 * convert the colors, after the CTM matrix, to the gamma space of the
-	 * connected screen.
-	 */
-	struct drm_property *gamma_lut_property;
-	/**
-	 * @gamma_lut_size_property: Optional CRTC property for the size of the
-	 * gamma LUT as supported by the driver (read-only).
-	 */
-	struct drm_property *gamma_lut_size_property;
-
-	/**
-	 * @suggested_x_property: Optional connector property with a hint for
-	 * the position of the output on the host's screen.
-	 */
-	struct drm_property *suggested_x_property;
-	/**
-	 * @suggested_y_property: Optional connector property with a hint for
-	 * the position of the output on the host's screen.
-	 */
-	struct drm_property *suggested_y_property;
-
-	/* dumb ioctl parameters */
-	uint32_t preferred_depth, prefer_shadow;
-
-	/**
-	 * @async_page_flip: Does this device support async flips on the primary
-	 * plane?
-	 */
-	bool async_page_flip;
-
-	/**
-	 * @allow_fb_modifiers:
-	 *
-	 * Whether the driver supports fb modifiers in the ADDFB2.1 ioctl call.
-	 */
-	bool allow_fb_modifiers;
-
-	/* cursor size */
-	uint32_t cursor_width, cursor_height;
-
-	struct drm_mode_config_helper_funcs *helper_private;
-};
-
 #define obj_to_crtc(x) container_of(x, struct drm_crtc, base)
 
 extern __printf(6, 7)
@@ -1418,10 +808,6 @@ extern void drm_crtc_get_hv_timing(const struct drm_display_mode *mode,
 extern int drm_crtc_force_disable(struct drm_crtc *crtc);
 extern int drm_crtc_force_disable_all(struct drm_device *dev);
 
-extern void drm_mode_config_init(struct drm_device *dev);
-extern void drm_mode_config_reset(struct drm_device *dev);
-extern void drm_mode_config_cleanup(struct drm_device *dev);
-
 extern int drm_mode_set_config_internal(struct drm_mode_set *set);
 
 extern struct drm_tile_group *drm_mode_create_tile_group(struct drm_device *dev,

commit fceffb325b30f6a9f0bdee22e65d0b8bb35883af
Author: Rob Clark <robdclark@gmail.com>
Date:   Sat Nov 5 11:08:09 2016 -0400

    drm/atomic: add new drm_debug bit to dump atomic state
    
    The contents of drm_{plane,crtc,connector}_state is dumped before
    commit.  If a driver extends any of the state structs, it can implement
    the corresponding funcs->atomic_print_state() to add it's own driver
    specific state.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    [seanpaul resolved conflict in drm_plane.h]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index fa1aa214c8ea..8cca2a895981 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -53,6 +53,7 @@ struct drm_device;
 struct drm_mode_set;
 struct drm_file;
 struct drm_clip_rect;
+struct drm_printer;
 struct device_node;
 struct dma_fence;
 struct edid;
@@ -594,6 +595,18 @@ struct drm_crtc_funcs {
 	 */
 	int (*set_crc_source)(struct drm_crtc *crtc, const char *source,
 			      size_t *values_cnt);
+
+	/**
+	 * @atomic_print_state:
+	 *
+	 * If driver subclasses struct &drm_crtc_state, it should implement
+	 * this optional hook for printing additional driver specific state.
+	 *
+	 * Do not call this directly, use drm_atomic_crtc_print_state()
+	 * instead.
+	 */
+	void (*atomic_print_state)(struct drm_printer *p,
+				   const struct drm_crtc_state *state);
 };
 
 /**

commit f54d1867005c3323f5d8ad83eed823e84226c429
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Oct 25 13:00:45 2016 +0100

    dma-buf: Rename struct fence to dma_fence
    
    I plan to usurp the short name of struct fence for a core kernel struct,
    and so I need to rename the specialised fence/timeline for DMA
    operations to make room.
    
    A consensus was reached in
    https://lists.freedesktop.org/archives/dri-devel/2016-July/113083.html
    that making clear this fence applies to DMA operations was a good thing.
    Since then the patch has grown a bit as usage increases, so hopefully it
    remains a good thing!
    
    (v2...: rebase, rerun spatch)
    v3: Compile on msm, spotted a manual fixup that I broke.
    v4: Try again for msm, sorry Daniel
    
    coccinelle script:
    @@
    
    @@
    - struct fence
    + struct dma_fence
    @@
    
    @@
    - struct fence_ops
    + struct dma_fence_ops
    @@
    
    @@
    - struct fence_cb
    + struct dma_fence_cb
    @@
    
    @@
    - struct fence_array
    + struct dma_fence_array
    @@
    
    @@
    - enum fence_flag_bits
    + enum dma_fence_flag_bits
    @@
    
    @@
    (
    - fence_init
    + dma_fence_init
    |
    - fence_release
    + dma_fence_release
    |
    - fence_free
    + dma_fence_free
    |
    - fence_get
    + dma_fence_get
    |
    - fence_get_rcu
    + dma_fence_get_rcu
    |
    - fence_put
    + dma_fence_put
    |
    - fence_signal
    + dma_fence_signal
    |
    - fence_signal_locked
    + dma_fence_signal_locked
    |
    - fence_default_wait
    + dma_fence_default_wait
    |
    - fence_add_callback
    + dma_fence_add_callback
    |
    - fence_remove_callback
    + dma_fence_remove_callback
    |
    - fence_enable_sw_signaling
    + dma_fence_enable_sw_signaling
    |
    - fence_is_signaled_locked
    + dma_fence_is_signaled_locked
    |
    - fence_is_signaled
    + dma_fence_is_signaled
    |
    - fence_is_later
    + dma_fence_is_later
    |
    - fence_later
    + dma_fence_later
    |
    - fence_wait_timeout
    + dma_fence_wait_timeout
    |
    - fence_wait_any_timeout
    + dma_fence_wait_any_timeout
    |
    - fence_wait
    + dma_fence_wait
    |
    - fence_context_alloc
    + dma_fence_context_alloc
    |
    - fence_array_create
    + dma_fence_array_create
    |
    - to_fence_array
    + to_dma_fence_array
    |
    - fence_is_array
    + dma_fence_is_array
    |
    - trace_fence_emit
    + trace_dma_fence_emit
    |
    - FENCE_TRACE
    + DMA_FENCE_TRACE
    |
    - FENCE_WARN
    + DMA_FENCE_WARN
    |
    - FENCE_ERR
    + DMA_FENCE_ERR
    )
     (
     ...
     )
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Acked-by: Sumit Semwal <sumit.semwal@linaro.org>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161025120045.28839-1-chris@chris-wilson.co.uk

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index bc860cfc67ca..fa1aa214c8ea 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -54,7 +54,7 @@ struct drm_mode_set;
 struct drm_file;
 struct drm_clip_rect;
 struct device_node;
-struct fence;
+struct dma_fence;
 struct edid;
 
 static inline int64_t U642I64(uint64_t val)

commit 6686df8cf1cf589c54343372e3524bf52cda038e
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Oct 21 22:22:45 2016 +0300

    drm: RIP mode_config->rotation_property
    
    Now that all drivers have been converted over to the per-plane rotation
    property, we can just nuke the global rotation property.
    
    v2: Rebase due to BIT(),__builtin_ffs() & co.
        Deal with superfluous code shuffling
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1477077768-4274-4-git-send-email-ville.syrjala@linux.intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 284c1b3aec10..bc860cfc67ca 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1155,11 +1155,6 @@ struct drm_mode_config {
 	 * CURSOR, PRIMARY and OVERLAY legacy uses of planes.
 	 */
 	struct drm_property *plane_type_property;
-	/**
-	 * @rotation_property: Optional property for planes or CRTCs to specifiy
-	 * rotation.
-	 */
-	struct drm_property *rotation_property;
 	/**
 	 * @prop_src_x: Default atomic plane property for the plane source
 	 * position in the connected &drm_framebuffer.

commit 9edbf1fa600a2ef17c7553c2103d0055d0320d15
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Thu Oct 6 17:21:06 2016 +0200

    drm: Add API for capturing frame CRCs
    
    Adds files and directories to debugfs for controlling and reading frame
    CRCs, per CRTC:
    
    dri/0/crtc-0/crc
    dri/0/crtc-0/crc/control
    dri/0/crtc-0/crc/data
    
    Drivers can implement the set_crc_source callback() in drm_crtc_funcs to
    start and stop generating frame CRCs and can add entries to the output
    by calling drm_crtc_add_crc_entry.
    
    v2:
        - Lots of good fixes suggested by Thierry.
        - Added documentation.
        - Changed the debugfs layout.
        - Moved to allocate the entries circular queue once when frame
          generation gets enabled for the first time.
    v3:
        - Use the control file just to select the source, and start and stop
          capture when the data file is opened and closed, respectively.
        - Make variable the number of CRC values per entry, per source.
        - Allocate entries queue each time we start capturing as now there
          isn't a fixed number of CRC values per entry.
        - Store the frame counter in the data file as a 8-digit hex number.
        - For sources that cannot provide useful frame numbers, place
          XXXXXXXX in the frame field.
    
    v4:
        - Build only if CONFIG_DEBUG_FS is enabled.
        - Use memdup_user_nul.
        - Consolidate calculation of the size of an entry in a helper.
        - Add 0x prefix to hex numbers in the data file.
        - Remove unnecessary snprintf and strlen usage in read callback.
    
    v5:
        - Made the crcs array in drm_crtc_crc_entry fixed-size
        - Lots of other smaller improvements suggested by Emil Velikov
    
    v7:
        - Move definition of drm_debugfs_crtc_crc_add to drm_internal.h
    
    v8:
        - Call debugfs_remove_recursive when we fail to create the minor
          device
    
    v9:
        - Register the debugfs directory for a crtc from
          drm_crtc_register_all()
    
    v10:
        - Don't let debugfs failures interrupt CRTC registration (Emil
          Velikov)
    
    v11:
        - Remove extra brace that broke compilation. Sorry!
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Acked-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1475767268-14379-3-git-send-email-tomeu.vizoso@collabora.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 4633915cb51b..284c1b3aec10 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -47,6 +47,7 @@
 #include <drm/drm_plane.h>
 #include <drm/drm_blend.h>
 #include <drm/drm_color_mgmt.h>
+#include <drm/drm_debugfs_crc.h>
 
 struct drm_device;
 struct drm_mode_set;
@@ -569,6 +570,30 @@ struct drm_crtc_funcs {
 	 * before data structures are torndown.
 	 */
 	void (*early_unregister)(struct drm_crtc *crtc);
+
+	/**
+	 * @set_crc_source:
+	 *
+	 * Changes the source of CRC checksums of frames at the request of
+	 * userspace, typically for testing purposes. The sources available are
+	 * specific of each driver and a %NULL value indicates that CRC
+	 * generation is to be switched off.
+	 *
+	 * When CRC generation is enabled, the driver should call
+	 * drm_crtc_add_crc_entry() at each frame, providing any information
+	 * that characterizes the frame contents in the crcN arguments, as
+	 * provided from the configured source. Drivers must accept a "auto"
+	 * source name that will select a default source for this CRTC.
+	 *
+	 * This callback is optional if the driver does not support any CRC
+	 * generation functionality.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 on success or a negative error code on failure.
+	 */
+	int (*set_crc_source)(struct drm_crtc *crtc, const char *source,
+			      size_t *values_cnt);
 };
 
 /**
@@ -685,6 +710,22 @@ struct drm_crtc {
 	 * context.
 	 */
 	struct drm_modeset_acquire_ctx *acquire_ctx;
+
+#ifdef CONFIG_DEBUG_FS
+	/**
+	 * @debugfs_entry:
+	 *
+	 * Debugfs directory for this CRTC.
+	 */
+	struct dentry *debugfs_entry;
+
+	/**
+	 * @crc:
+	 *
+	 * Configuration settings of CRC capture.
+	 */
+	struct drm_crtc_crc crc;
+#endif
 };
 
 /**

commit 1dfdb0ed34b28b086ffc1f9fb9f538ab60298029
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Thu Oct 13 10:38:11 2016 +0200

    drm/crtc: constify drm_crtc_mask parameter
    
    Now that drm_crtc_index takes a const, the same can be done for drm_crtc_mask.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/6e32d013-6fee-34ad-f8d2-59139f3dc4c1@linux.intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 92246619947c..4633915cb51b 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1359,7 +1359,7 @@ static inline unsigned int drm_crtc_index(const struct drm_crtc *crtc)
  * Given a registered CRTC, return the mask bit of that CRTC for an
  * encoder's possible_crtcs field.
  */
-static inline uint32_t drm_crtc_mask(struct drm_crtc *crtc)
+static inline uint32_t drm_crtc_mask(const struct drm_crtc *crtc)
 {
 	return 1 << drm_crtc_index(crtc);
 }

commit d807ed1c55fb1b2dcfb2bc49385e227f6bee7669
Author: Brian Starkey <brian.starkey@arm.com>
Date:   Thu Oct 13 10:47:08 2016 +0100

    drm: atomic: Clarify documentation around drm_atomic_crtc_needs_modeset
    
    Add some additional comments to more explicitly describe the meaning and
    usage of the three CRTC modeset detection booleans: mode_changed,
    connectors_changed and active_changed.
    
    Suggested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Brian Starkey <brian.starkey@arm.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1476352028-16701-1-git-send-email-brian.starkey@arm.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 0aa292526567..92246619947c 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -116,6 +116,11 @@ struct drm_plane_helper_funcs;
  * never return in a failure from the ->atomic_check callback. Userspace assumes
  * that a DPMS On will always succeed. In other words: @enable controls resource
  * assignment, @active controls the actual hardware state.
+ *
+ * The three booleans active_changed, connectors_changed and mode_changed are
+ * intended to indicate whether a full modeset is needed, rather than strictly
+ * describing what has changed in a commit.
+ * See also: drm_atomic_crtc_needs_modeset()
  */
 struct drm_crtc_state {
 	struct drm_crtc *crtc;

commit a5bd451b6e6ece69be07a425381c4f3438eadba0
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Oct 10 18:26:10 2016 +0300

    drm/crtc: constify drm_crtc_index parameter
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1476113170-13816-1-git-send-email-jani.nikula@intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 61932f55f788..0aa292526567 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1342,7 +1342,7 @@ extern void drm_crtc_cleanup(struct drm_crtc *crtc);
  * Given a registered CRTC, return the index of that CRTC within a DRM
  * device's list of CRTCs.
  */
-static inline unsigned int drm_crtc_index(struct drm_crtc *crtc)
+static inline unsigned int drm_crtc_index(const struct drm_crtc *crtc)
 {
 	return crtc->index;
 }

commit 61802130d85fdaf9646340bf1cc64b3e06d0b19c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Sep 30 12:04:56 2016 +0200

    drm: Document caveats around atomic event handling
    
    It's not that obvious how a driver can all race the atomic commit with
    handling the completion event. And there's unfortunately a pile of
    drivers with rather bad event handling which misdirect people into the
    wrong direction.
    
    Try to remedy this by documenting everything better.
    
    v2: Type fixes Alex spotted.
    
    v3: More typos Alex spotted.
    
    Cc: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Alex Deucher <alexdeucher@gmail.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1475229896-6047-1-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index a544b7502493..61932f55f788 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -109,8 +109,6 @@ struct drm_plane_helper_funcs;
  * @ctm: Transformation matrix
  * @gamma_lut: Lookup table for converting pixel data after the
  *	conversion matrix
- * @event: optional pointer to a DRM event to signal upon completion of the
- * 	state update
  * @state: backpointer to global drm_atomic_state
  *
  * Note that the distinction between @enable and @active is rather subtile:
@@ -159,6 +157,46 @@ struct drm_crtc_state {
 	struct drm_property_blob *ctm;
 	struct drm_property_blob *gamma_lut;
 
+	/**
+	 * @event:
+	 *
+	 * Optional pointer to a DRM event to signal upon completion of the
+	 * state update. The driver must send out the event when the atomic
+	 * commit operation completes. There are two cases:
+	 *
+	 *  - The event is for a CRTC which is being disabled through this
+	 *    atomic commit. In that case the event can be send out any time
+	 *    after the hardware has stopped scanning out the current
+	 *    framebuffers. It should contain the timestamp and counter for the
+	 *    last vblank before the display pipeline was shut off.
+	 *
+	 *  - For a CRTC which is enabled at the end of the commit (even when it
+	 *    undergoes an full modeset) the vblank timestamp and counter must
+	 *    be for the vblank right before the first frame that scans out the
+	 *    new set of buffers. Again the event can only be sent out after the
+	 *    hardware has stopped scanning out the old buffers.
+	 *
+	 *  - Events for disabled CRTCs are not allowed, and drivers can ignore
+	 *    that case.
+	 *
+	 * This can be handled by the drm_crtc_send_vblank_event() function,
+	 * which the driver should call on the provided event upon completion of
+	 * the atomic commit. Note that if the driver supports vblank signalling
+	 * and timestamping the vblank counters and timestamps must agree with
+	 * the ones returned from page flip events. With the current vblank
+	 * helper infrastructure this can be achieved by holding a vblank
+	 * reference while the page flip is pending, acquired through
+	 * drm_crtc_vblank_get() and released with drm_crtc_vblank_put().
+	 * Drivers are free to implement their own vblank counter and timestamp
+	 * tracking though, e.g. if they have accurate timestamp registers in
+	 * hardware.
+	 *
+	 * For hardware which supports some means to synchronize vblank
+	 * interrupt delivery with committing display state there's also
+	 * drm_crtc_arm_vblank_event(). See the documentation of that function
+	 * for a detailed discussion of the constraints it needs to be used
+	 * safely.
+	 */
 	struct drm_pending_vblank_event *event;
 
 	struct drm_atomic_state *state;
@@ -835,17 +873,9 @@ struct drm_mode_config_funcs {
 	 * CRTC index supplied in &drm_event to userspace.
 	 *
 	 * The drm core will supply a struct &drm_event in the event
-	 * member of each CRTC's &drm_crtc_state structure. This can be handled by the
-	 * drm_crtc_send_vblank_event() function, which the driver should call on
-	 * the provided event upon completion of the atomic commit. Note that if
-	 * the driver supports vblank signalling and timestamping the vblank
-	 * counters and timestamps must agree with the ones returned from page
-	 * flip events. With the current vblank helper infrastructure this can
-	 * be achieved by holding a vblank reference while the page flip is
-	 * pending, acquired through drm_crtc_vblank_get() and released with
-	 * drm_crtc_vblank_put(). Drivers are free to implement their own vblank
-	 * counter and timestamp tracking though, e.g. if they have accurate
-	 * timestamp registers in hardware.
+	 * member of each CRTC's &drm_crtc_state structure. See the
+	 * documentation for &drm_crtc_state for more details about the precise
+	 * semantics of this event.
 	 *
 	 * NOTE:
 	 *

commit f1e2f66ce2d9f732fec184ab885fba4b53c06016
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Sep 21 10:59:28 2016 +0200

    drm: Extract drm_color_mgmt.[hc]
    
    For both the new degamm/lut/gamma atomic combo, and the old legacy
    gamma tables.
    
    Acked-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Cc: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1474448370-32227-5-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 8d06cabede59..a544b7502493 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -46,6 +46,7 @@
 #include <drm/drm_edid.h>
 #include <drm/drm_plane.h>
 #include <drm/drm_blend.h>
+#include <drm/drm_color_mgmt.h>
 
 struct drm_device;
 struct drm_mode_set;
@@ -1337,9 +1338,6 @@ extern void drm_mode_config_init(struct drm_device *dev);
 extern void drm_mode_config_reset(struct drm_device *dev);
 extern void drm_mode_config_cleanup(struct drm_device *dev);
 
-extern int drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,
-					 int gamma_size);
-
 extern int drm_mode_set_config_internal(struct drm_mode_set *set);
 
 extern struct drm_tile_group *drm_mode_create_tile_group(struct drm_device *dev,
@@ -1349,11 +1347,6 @@ extern struct drm_tile_group *drm_mode_get_tile_group(struct drm_device *dev,
 extern void drm_mode_put_tile_group(struct drm_device *dev,
 				   struct drm_tile_group *tg);
 
-extern void drm_crtc_enable_color_mgmt(struct drm_crtc *crtc,
-				       uint degamma_lut_size,
-				       bool has_ctm,
-				       uint gamma_lut_size);
-
 /* Helpers */
 static inline struct drm_crtc *drm_crtc_find(struct drm_device *dev,
 	uint32_t id)
@@ -1363,25 +1356,6 @@ static inline struct drm_crtc *drm_crtc_find(struct drm_device *dev,
 	return mo ? obj_to_crtc(mo) : NULL;
 }
 
-/*
- * Extract a degamma/gamma LUT value provided by user and round it to the
- * precision supported by the hardware.
- */
-static inline uint32_t drm_color_lut_extract(uint32_t user_input,
-					     uint32_t bit_precision)
-{
-	uint32_t val = user_input;
-	uint32_t max = 0xffff >> (16 - bit_precision);
-
-	/* Round only if we're not using full precision. */
-	if (bit_precision < 16) {
-		val += 1UL << (16 - bit_precision - 1);
-		val >>= 16 - bit_precision;
-	}
-
-	return clamp_val(val, 0, max);
-}
-
 #define drm_for_each_crtc(crtc, dev) \
 	list_for_each_entry(crtc, &(dev)->mode_config.crtc_list, head)
 

commit 18733802466d032cd84e57f1e4b21ecae635f192
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Sep 21 10:59:26 2016 +0200

    drm: Conslidate blending properties in drm_blend.[hc]
    
    Imo zpos, rotatation, blending eq (once we have it) and all that
    should be in drm_blend.c, since those are all about how exactly the
    pixels are rendered onto the CRTC's visible area. Also noticed that
    one exported function accidentally ended up in drm_crtc_internal.h,
    move it to the right place too.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1474448370-32227-3-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 9375e5c9cddb..8d06cabede59 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -45,6 +45,7 @@
 #include <drm/drm_bridge.h>
 #include <drm/drm_edid.h>
 #include <drm/drm_plane.h>
+#include <drm/drm_blend.h>
 
 struct drm_device;
 struct drm_mode_set;
@@ -63,21 +64,6 @@ static inline uint64_t I642U64(int64_t val)
 	return (uint64_t)*((uint64_t *)&val);
 }
 
-/*
- * Rotation property bits. DRM_ROTATE_<degrees> rotates the image by the
- * specified amount in degrees in counter clockwise direction. DRM_REFLECT_X and
- * DRM_REFLECT_Y reflects the image along the specified axis prior to rotation
- */
-#define DRM_ROTATE_0	BIT(0)
-#define DRM_ROTATE_90	BIT(1)
-#define DRM_ROTATE_180	BIT(2)
-#define DRM_ROTATE_270	BIT(3)
-#define DRM_ROTATE_MASK (DRM_ROTATE_0   | DRM_ROTATE_90 | \
-			 DRM_ROTATE_180 | DRM_ROTATE_270)
-#define DRM_REFLECT_X	BIT(4)
-#define DRM_REFLECT_Y	BIT(5)
-#define DRM_REFLECT_MASK (DRM_REFLECT_X | DRM_REFLECT_Y)
-
 /* data corresponds to displayid vend/prod/serial */
 struct drm_tile_group {
 	struct kref refcount;
@@ -1363,22 +1349,11 @@ extern struct drm_tile_group *drm_mode_get_tile_group(struct drm_device *dev,
 extern void drm_mode_put_tile_group(struct drm_device *dev,
 				   struct drm_tile_group *tg);
 
-extern struct drm_property *drm_mode_create_rotation_property(struct drm_device *dev,
-							      unsigned int supported_rotations);
-extern unsigned int drm_rotation_simplify(unsigned int rotation,
-					  unsigned int supported_rotations);
 extern void drm_crtc_enable_color_mgmt(struct drm_crtc *crtc,
 				       uint degamma_lut_size,
 				       bool has_ctm,
 				       uint gamma_lut_size);
 
-int drm_plane_create_zpos_property(struct drm_plane *plane,
-				   unsigned int zpos,
-				   unsigned int min, unsigned int max);
-
-int drm_plane_create_zpos_immutable_property(struct drm_plane *plane,
-					     unsigned int zpos);
-
 /* Helpers */
 static inline struct drm_crtc *drm_crtc_find(struct drm_device *dev,
 	uint32_t id)

commit 43968d7b806d7a7e021261294c583a216fddf0e5
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Sep 21 10:59:24 2016 +0200

    drm: Extract drm_plane.[hc]
    
    Just pure code movement, cleanup and polish will happen in later
    patches.
    
    v2: Don't forget all the ioctl! To extract those cleanly I decided to
    put check_src_coords into drm_framebuffer.c (and give it a
    drm_framebuffer_ prefix), since that just checks framebuffer
    constraints.
    
    v3: rebase over PAGE_FLIP_TARGET.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    
    [seanpaul]
    This patch as posted on the list was rebased on:
    
    commit 6f00975c619064a18c23fd3aced325ae165a73b9
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Sat Aug 20 12:22:11 2016 +0200
    
        drm: Reject page_flip for !DRIVER_MODESET
    
    so as a result of moving the page_flip ioctl, this fix has
    been rolled into this patch.
    
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 35b13fc6bbc1..9375e5c9cddb 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -44,6 +44,7 @@
 #include <drm/drm_property.h>
 #include <drm/drm_bridge.h>
 #include <drm/drm_edid.h>
+#include <drm/drm_plane.h>
 
 struct drm_device;
 struct drm_mode_set;
@@ -656,525 +657,6 @@ struct drm_crtc {
 	struct drm_modeset_acquire_ctx *acquire_ctx;
 };
 
-/**
- * struct drm_plane_state - mutable plane state
- * @plane: backpointer to the plane
- * @crtc: currently bound CRTC, NULL if disabled
- * @fb: currently bound framebuffer
- * @fence: optional fence to wait for before scanning out @fb
- * @crtc_x: left position of visible portion of plane on crtc
- * @crtc_y: upper position of visible portion of plane on crtc
- * @crtc_w: width of visible portion of plane on crtc
- * @crtc_h: height of visible portion of plane on crtc
- * @src_x: left position of visible portion of plane within
- *	plane (in 16.16)
- * @src_y: upper position of visible portion of plane within
- *	plane (in 16.16)
- * @src_w: width of visible portion of plane (in 16.16)
- * @src_h: height of visible portion of plane (in 16.16)
- * @rotation: rotation of the plane
- * @zpos: priority of the given plane on crtc (optional)
- * @normalized_zpos: normalized value of zpos: unique, range from 0 to N-1
- *	where N is the number of active planes for given crtc
- * @src: clipped source coordinates of the plane (in 16.16)
- * @dst: clipped destination coordinates of the plane
- * @visible: visibility of the plane
- * @state: backpointer to global drm_atomic_state
- */
-struct drm_plane_state {
-	struct drm_plane *plane;
-
-	struct drm_crtc *crtc;   /* do not write directly, use drm_atomic_set_crtc_for_plane() */
-	struct drm_framebuffer *fb;  /* do not write directly, use drm_atomic_set_fb_for_plane() */
-	struct fence *fence;
-
-	/* Signed dest location allows it to be partially off screen */
-	int32_t crtc_x, crtc_y;
-	uint32_t crtc_w, crtc_h;
-
-	/* Source values are 16.16 fixed point */
-	uint32_t src_x, src_y;
-	uint32_t src_h, src_w;
-
-	/* Plane rotation */
-	unsigned int rotation;
-
-	/* Plane zpos */
-	unsigned int zpos;
-	unsigned int normalized_zpos;
-
-	/* Clipped coordinates */
-	struct drm_rect src, dst;
-
-	/*
-	 * Is the plane actually visible? Can be false even
-	 * if fb!=NULL and crtc!=NULL, due to clipping.
-	 */
-	bool visible;
-
-	struct drm_atomic_state *state;
-};
-
-
-/**
- * struct drm_plane_funcs - driver plane control functions
- */
-struct drm_plane_funcs {
-	/**
-	 * @update_plane:
-	 *
-	 * This is the legacy entry point to enable and configure the plane for
-	 * the given CRTC and framebuffer. It is never called to disable the
-	 * plane, i.e. the passed-in crtc and fb paramters are never NULL.
-	 *
-	 * The source rectangle in frame buffer memory coordinates is given by
-	 * the src_x, src_y, src_w and src_h parameters (as 16.16 fixed point
-	 * values). Devices that don't support subpixel plane coordinates can
-	 * ignore the fractional part.
-	 *
-	 * The destination rectangle in CRTC coordinates is given by the
-	 * crtc_x, crtc_y, crtc_w and crtc_h parameters (as integer values).
-	 * Devices scale the source rectangle to the destination rectangle. If
-	 * scaling is not supported, and the source rectangle size doesn't match
-	 * the destination rectangle size, the driver must return a
-	 * -<errorname>EINVAL</errorname> error.
-	 *
-	 * Drivers implementing atomic modeset should use
-	 * drm_atomic_helper_update_plane() to implement this hook.
-	 *
-	 * RETURNS:
-	 *
-	 * 0 on success or a negative error code on failure.
-	 */
-	int (*update_plane)(struct drm_plane *plane,
-			    struct drm_crtc *crtc, struct drm_framebuffer *fb,
-			    int crtc_x, int crtc_y,
-			    unsigned int crtc_w, unsigned int crtc_h,
-			    uint32_t src_x, uint32_t src_y,
-			    uint32_t src_w, uint32_t src_h);
-
-	/**
-	 * @disable_plane:
-	 *
-	 * This is the legacy entry point to disable the plane. The DRM core
-	 * calls this method in response to a DRM_IOCTL_MODE_SETPLANE IOCTL call
-	 * with the frame buffer ID set to 0.  Disabled planes must not be
-	 * processed by the CRTC.
-	 *
-	 * Drivers implementing atomic modeset should use
-	 * drm_atomic_helper_disable_plane() to implement this hook.
-	 *
-	 * RETURNS:
-	 *
-	 * 0 on success or a negative error code on failure.
-	 */
-	int (*disable_plane)(struct drm_plane *plane);
-
-	/**
-	 * @destroy:
-	 *
-	 * Clean up plane resources. This is only called at driver unload time
-	 * through drm_mode_config_cleanup() since a plane cannot be hotplugged
-	 * in DRM.
-	 */
-	void (*destroy)(struct drm_plane *plane);
-
-	/**
-	 * @reset:
-	 *
-	 * Reset plane hardware and software state to off. This function isn't
-	 * called by the core directly, only through drm_mode_config_reset().
-	 * It's not a helper hook only for historical reasons.
-	 *
-	 * Atomic drivers can use drm_atomic_helper_plane_reset() to reset
-	 * atomic state using this hook.
-	 */
-	void (*reset)(struct drm_plane *plane);
-
-	/**
-	 * @set_property:
-	 *
-	 * This is the legacy entry point to update a property attached to the
-	 * plane.
-	 *
-	 * Drivers implementing atomic modeset should use
-	 * drm_atomic_helper_plane_set_property() to implement this hook.
-	 *
-	 * This callback is optional if the driver does not support any legacy
-	 * driver-private properties.
-	 *
-	 * RETURNS:
-	 *
-	 * 0 on success or a negative error code on failure.
-	 */
-	int (*set_property)(struct drm_plane *plane,
-			    struct drm_property *property, uint64_t val);
-
-	/**
-	 * @atomic_duplicate_state:
-	 *
-	 * Duplicate the current atomic state for this plane and return it.
-	 * The core and helpers gurantee that any atomic state duplicated with
-	 * this hook and still owned by the caller (i.e. not transferred to the
-	 * driver by calling ->atomic_commit() from struct
-	 * &drm_mode_config_funcs) will be cleaned up by calling the
-	 * @atomic_destroy_state hook in this structure.
-	 *
-	 * Atomic drivers which don't subclass struct &drm_plane_state should use
-	 * drm_atomic_helper_plane_duplicate_state(). Drivers that subclass the
-	 * state structure to extend it with driver-private state should use
-	 * __drm_atomic_helper_plane_duplicate_state() to make sure shared state is
-	 * duplicated in a consistent fashion across drivers.
-	 *
-	 * It is an error to call this hook before plane->state has been
-	 * initialized correctly.
-	 *
-	 * NOTE:
-	 *
-	 * If the duplicate state references refcounted resources this hook must
-	 * acquire a reference for each of them. The driver must release these
-	 * references again in @atomic_destroy_state.
-	 *
-	 * RETURNS:
-	 *
-	 * Duplicated atomic state or NULL when the allocation failed.
-	 */
-	struct drm_plane_state *(*atomic_duplicate_state)(struct drm_plane *plane);
-
-	/**
-	 * @atomic_destroy_state:
-	 *
-	 * Destroy a state duplicated with @atomic_duplicate_state and release
-	 * or unreference all resources it references
-	 */
-	void (*atomic_destroy_state)(struct drm_plane *plane,
-				     struct drm_plane_state *state);
-
-	/**
-	 * @atomic_set_property:
-	 *
-	 * Decode a driver-private property value and store the decoded value
-	 * into the passed-in state structure. Since the atomic core decodes all
-	 * standardized properties (even for extensions beyond the core set of
-	 * properties which might not be implemented by all drivers) this
-	 * requires drivers to subclass the state structure.
-	 *
-	 * Such driver-private properties should really only be implemented for
-	 * truly hardware/vendor specific state. Instead it is preferred to
-	 * standardize atomic extension and decode the properties used to expose
-	 * such an extension in the core.
-	 *
-	 * Do not call this function directly, use
-	 * drm_atomic_plane_set_property() instead.
-	 *
-	 * This callback is optional if the driver does not support any
-	 * driver-private atomic properties.
-	 *
-	 * NOTE:
-	 *
-	 * This function is called in the state assembly phase of atomic
-	 * modesets, which can be aborted for any reason (including on
-	 * userspace's request to just check whether a configuration would be
-	 * possible). Drivers MUST NOT touch any persistent state (hardware or
-	 * software) or data structures except the passed in @state parameter.
-	 *
-	 * Also since userspace controls in which order properties are set this
-	 * function must not do any input validation (since the state update is
-	 * incomplete and hence likely inconsistent). Instead any such input
-	 * validation must be done in the various atomic_check callbacks.
-	 *
-	 * RETURNS:
-	 *
-	 * 0 if the property has been found, -EINVAL if the property isn't
-	 * implemented by the driver (which shouldn't ever happen, the core only
-	 * asks for properties attached to this plane). No other validation is
-	 * allowed by the driver. The core already checks that the property
-	 * value is within the range (integer, valid enum value, ...) the driver
-	 * set when registering the property.
-	 */
-	int (*atomic_set_property)(struct drm_plane *plane,
-				   struct drm_plane_state *state,
-				   struct drm_property *property,
-				   uint64_t val);
-
-	/**
-	 * @atomic_get_property:
-	 *
-	 * Reads out the decoded driver-private property. This is used to
-	 * implement the GETPLANE IOCTL.
-	 *
-	 * Do not call this function directly, use
-	 * drm_atomic_plane_get_property() instead.
-	 *
-	 * This callback is optional if the driver does not support any
-	 * driver-private atomic properties.
-	 *
-	 * RETURNS:
-	 *
-	 * 0 on success, -EINVAL if the property isn't implemented by the
-	 * driver (which should never happen, the core only asks for
-	 * properties attached to this plane).
-	 */
-	int (*atomic_get_property)(struct drm_plane *plane,
-				   const struct drm_plane_state *state,
-				   struct drm_property *property,
-				   uint64_t *val);
-	/**
-	 * @late_register:
-	 *
-	 * This optional hook can be used to register additional userspace
-	 * interfaces attached to the plane like debugfs interfaces.
-	 * It is called late in the driver load sequence from drm_dev_register().
-	 * Everything added from this callback should be unregistered in
-	 * the early_unregister callback.
-	 *
-	 * Returns:
-	 *
-	 * 0 on success, or a negative error code on failure.
-	 */
-	int (*late_register)(struct drm_plane *plane);
-
-	/**
-	 * @early_unregister:
-	 *
-	 * This optional hook should be used to unregister the additional
-	 * userspace interfaces attached to the plane from
-	 * late_unregister(). It is called from drm_dev_unregister(),
-	 * early in the driver unload sequence to disable userspace access
-	 * before data structures are torndown.
-	 */
-	void (*early_unregister)(struct drm_plane *plane);
-};
-
-enum drm_plane_type {
-	DRM_PLANE_TYPE_OVERLAY,
-	DRM_PLANE_TYPE_PRIMARY,
-	DRM_PLANE_TYPE_CURSOR,
-};
-
-
-/**
- * struct drm_plane - central DRM plane control structure
- * @dev: DRM device this plane belongs to
- * @head: for list management
- * @name: human readable name, can be overwritten by the driver
- * @base: base mode object
- * @possible_crtcs: pipes this plane can be bound to
- * @format_types: array of formats supported by this plane
- * @format_count: number of formats supported
- * @format_default: driver hasn't supplied supported formats for the plane
- * @crtc: currently bound CRTC
- * @fb: currently bound fb
- * @old_fb: Temporary tracking of the old fb while a modeset is ongoing. Used by
- * 	drm_mode_set_config_internal() to implement correct refcounting.
- * @funcs: helper functions
- * @properties: property tracking for this plane
- * @type: type of plane (overlay, primary, cursor)
- * @state: current atomic state for this plane
- * @zpos_property: zpos property for this plane
- * @helper_private: mid-layer private data
- */
-struct drm_plane {
-	struct drm_device *dev;
-	struct list_head head;
-
-	char *name;
-
-	/**
-	 * @mutex:
-	 *
-	 * Protects modeset plane state, together with the mutex of &drm_crtc
-	 * this plane is linked to (when active, getting actived or getting
-	 * disabled).
-	 */
-	struct drm_modeset_lock mutex;
-
-	struct drm_mode_object base;
-
-	uint32_t possible_crtcs;
-	uint32_t *format_types;
-	unsigned int format_count;
-	bool format_default;
-
-	struct drm_crtc *crtc;
-	struct drm_framebuffer *fb;
-
-	struct drm_framebuffer *old_fb;
-
-	const struct drm_plane_funcs *funcs;
-
-	struct drm_object_properties properties;
-
-	enum drm_plane_type type;
-
-	/**
-	 * @index: Position inside the mode_config.list, can be used as an array
-	 * index. It is invariant over the lifetime of the plane.
-	 */
-	unsigned index;
-
-	const struct drm_plane_helper_funcs *helper_private;
-
-	struct drm_plane_state *state;
-
-	struct drm_property *zpos_property;
-};
-
-/**
- * struct drm_crtc_commit - track modeset commits on a CRTC
- *
- * This structure is used to track pending modeset changes and atomic commit on
- * a per-CRTC basis. Since updating the list should never block this structure
- * is reference counted to allow waiters to safely wait on an event to complete,
- * without holding any locks.
- *
- * It has 3 different events in total to allow a fine-grained synchronization
- * between outstanding updates::
- *
- *	atomic commit thread			hardware
- *
- * 	write new state into hardware	---->	...
- * 	signal hw_done
- * 						switch to new state on next
- * 	...					v/hblank
- *
- *	wait for buffers to show up		...
- *
- *	...					send completion irq
- *						irq handler signals flip_done
- *	cleanup old buffers
- *
- * 	signal cleanup_done
- *
- * 	wait for flip_done		<----
- * 	clean up atomic state
- *
- * The important bit to know is that cleanup_done is the terminal event, but the
- * ordering between flip_done and hw_done is entirely up to the specific driver
- * and modeset state change.
- *
- * For an implementation of how to use this look at
- * drm_atomic_helper_setup_commit() from the atomic helper library.
- */
-struct drm_crtc_commit {
-	/**
-	 * @crtc:
-	 *
-	 * DRM CRTC for this commit.
-	 */
-	struct drm_crtc *crtc;
-
-	/**
-	 * @ref:
-	 *
-	 * Reference count for this structure. Needed to allow blocking on
-	 * completions without the risk of the completion disappearing
-	 * meanwhile.
-	 */
-	struct kref ref;
-
-	/**
-	 * @flip_done:
-	 *
-	 * Will be signaled when the hardware has flipped to the new set of
-	 * buffers. Signals at the same time as when the drm event for this
-	 * commit is sent to userspace, or when an out-fence is singalled. Note
-	 * that for most hardware, in most cases this happens after @hw_done is
-	 * signalled.
-	 */
-	struct completion flip_done;
-
-	/**
-	 * @hw_done:
-	 *
-	 * Will be signalled when all hw register changes for this commit have
-	 * been written out. Especially when disabling a pipe this can be much
-	 * later than than @flip_done, since that can signal already when the
-	 * screen goes black, whereas to fully shut down a pipe more register
-	 * I/O is required.
-	 *
-	 * Note that this does not need to include separately reference-counted
-	 * resources like backing storage buffer pinning, or runtime pm
-	 * management.
-	 */
-	struct completion hw_done;
-
-	/**
-	 * @cleanup_done:
-	 *
-	 * Will be signalled after old buffers have been cleaned up by calling
-	 * drm_atomic_helper_cleanup_planes(). Since this can only happen after
-	 * a vblank wait completed it might be a bit later. This completion is
-	 * useful to throttle updates and avoid hardware updates getting ahead
-	 * of the buffer cleanup too much.
-	 */
-	struct completion cleanup_done;
-
-	/**
-	 * @commit_entry:
-	 *
-	 * Entry on the per-CRTC commit_list. Protected by crtc->commit_lock.
-	 */
-	struct list_head commit_entry;
-
-	/**
-	 * @event:
-	 *
-	 * &drm_pending_vblank_event pointer to clean up private events.
-	 */
-	struct drm_pending_vblank_event *event;
-};
-
-struct __drm_planes_state {
-	struct drm_plane *ptr;
-	struct drm_plane_state *state;
-};
-
-struct __drm_crtcs_state {
-	struct drm_crtc *ptr;
-	struct drm_crtc_state *state;
-	struct drm_crtc_commit *commit;
-};
-
-struct __drm_connnectors_state {
-	struct drm_connector *ptr;
-	struct drm_connector_state *state;
-};
-
-/**
- * struct drm_atomic_state - the global state object for atomic updates
- * @dev: parent DRM device
- * @allow_modeset: allow full modeset
- * @legacy_cursor_update: hint to enforce legacy cursor IOCTL semantics
- * @legacy_set_config: Disable conflicting encoders instead of failing with -EINVAL.
- * @planes: pointer to array of structures with per-plane data
- * @crtcs: pointer to array of CRTC pointers
- * @num_connector: size of the @connectors and @connector_states arrays
- * @connectors: pointer to array of structures with per-connector data
- * @acquire_ctx: acquire context for this atomic modeset state update
- */
-struct drm_atomic_state {
-	struct drm_device *dev;
-	bool allow_modeset : 1;
-	bool legacy_cursor_update : 1;
-	bool legacy_set_config : 1;
-	struct __drm_planes_state *planes;
-	struct __drm_crtcs_state *crtcs;
-	int num_connector;
-	struct __drm_connnectors_state *connectors;
-
-	struct drm_modeset_acquire_ctx *acquire_ctx;
-
-	/**
-	 * @commit_work:
-	 *
-	 * Work item which can be used by the driver or helpers to execute the
-	 * commit without blocking.
-	 */
-	struct work_struct commit_work;
-};
-
-
 /**
  * struct drm_mode_set - new values for a CRTC config change
  * @fb: framebuffer to use for new config
@@ -1825,20 +1307,7 @@ struct drm_mode_config {
 	struct drm_mode_config_helper_funcs *helper_private;
 };
 
-/**
- * drm_for_each_plane_mask - iterate over planes specified by bitmask
- * @plane: the loop cursor
- * @dev: the DRM device
- * @plane_mask: bitmask of plane indices
- *
- * Iterate over all planes specified by bitmask.
- */
-#define drm_for_each_plane_mask(plane, dev, plane_mask) \
-	list_for_each_entry((plane), &(dev)->mode_config.plane_list, head) \
-		for_each_if ((plane_mask) & (1 << drm_plane_index(plane)))
-
 #define obj_to_crtc(x) container_of(x, struct drm_crtc, base)
-#define obj_to_plane(x) container_of(x, struct drm_plane, base)
 
 extern __printf(6, 7)
 int drm_crtc_init_with_planes(struct drm_device *dev,
@@ -1873,36 +1342,6 @@ static inline uint32_t drm_crtc_mask(struct drm_crtc *crtc)
 	return 1 << drm_crtc_index(crtc);
 }
 
-extern __printf(8, 9)
-int drm_universal_plane_init(struct drm_device *dev,
-			     struct drm_plane *plane,
-			     unsigned long possible_crtcs,
-			     const struct drm_plane_funcs *funcs,
-			     const uint32_t *formats,
-			     unsigned int format_count,
-			     enum drm_plane_type type,
-			     const char *name, ...);
-extern int drm_plane_init(struct drm_device *dev,
-			  struct drm_plane *plane,
-			  unsigned long possible_crtcs,
-			  const struct drm_plane_funcs *funcs,
-			  const uint32_t *formats, unsigned int format_count,
-			  bool is_primary);
-extern void drm_plane_cleanup(struct drm_plane *plane);
-
-/**
- * drm_plane_index - find the index of a registered plane
- * @plane: plane to find index for
- *
- * Given a registered plane, return the index of that plane within a DRM
- * device's list of planes.
- */
-static inline unsigned int drm_plane_index(struct drm_plane *plane)
-{
-	return plane->index;
-}
-extern struct drm_plane * drm_plane_from_index(struct drm_device *dev, int idx);
-extern void drm_plane_force_disable(struct drm_plane *plane);
 extern void drm_crtc_get_hv_timing(const struct drm_display_mode *mode,
 				   int *hdisplay, int *vdisplay);
 extern int drm_crtc_force_disable(struct drm_crtc *crtc);
@@ -1924,10 +1363,6 @@ extern struct drm_tile_group *drm_mode_get_tile_group(struct drm_device *dev,
 extern void drm_mode_put_tile_group(struct drm_device *dev,
 				   struct drm_tile_group *tg);
 
-extern int drm_mode_plane_set_obj_prop(struct drm_plane *plane,
-				       struct drm_property *property,
-				       uint64_t value);
-
 extern struct drm_property *drm_mode_create_rotation_property(struct drm_device *dev,
 							      unsigned int supported_rotations);
 extern unsigned int drm_rotation_simplify(unsigned int rotation,
@@ -1945,14 +1380,6 @@ int drm_plane_create_zpos_immutable_property(struct drm_plane *plane,
 					     unsigned int zpos);
 
 /* Helpers */
-static inline struct drm_plane *drm_plane_find(struct drm_device *dev,
-		uint32_t id)
-{
-	struct drm_mode_object *mo;
-	mo = drm_mode_object_find(dev, id, DRM_MODE_OBJECT_PLANE);
-	return mo ? obj_to_plane(mo) : NULL;
-}
-
 static inline struct drm_crtc *drm_crtc_find(struct drm_device *dev,
 	uint32_t id)
 {
@@ -1980,14 +1407,6 @@ static inline uint32_t drm_color_lut_extract(uint32_t user_input,
 	return clamp_val(val, 0, max);
 }
 
-/* Plane list iterator for legacy (overlay only) planes. */
-#define drm_for_each_legacy_plane(plane, dev) \
-	list_for_each_entry(plane, &(dev)->mode_config.plane_list, head) \
-		for_each_if (plane->type == DRM_PLANE_TYPE_OVERLAY)
-
-#define drm_for_each_plane(plane, dev) \
-	list_for_each_entry(plane, &(dev)->mode_config.plane_list, head)
-
 #define drm_for_each_crtc(crtc, dev) \
 	list_for_each_entry(crtc, &(dev)->mode_config.crtc_list, head)
 

commit cdc3d09fe2a9acd3f79049a70f89a4a8ef07d812
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Aug 31 18:09:06 2016 +0200

    drm: Move all decl for drm_edid.c to drm_edid.h
    
    Some were still left in drm_crtc.h. Also include drm_edid.h in the
    rst files.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160831160913.12991-4-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index a2d1108c7c2c..35b13fc6bbc1 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -43,6 +43,7 @@
 #include <drm/drm_encoder.h>
 #include <drm/drm_property.h>
 #include <drm/drm_bridge.h>
+#include <drm/drm_edid.h>
 
 struct drm_device;
 struct drm_mode_set;
@@ -2004,33 +2005,4 @@ assert_drm_connector_list_read_locked(struct drm_mode_config *mode_config)
 		!drm_modeset_is_locked(&mode_config->connection_mutex));
 }
 
-/* drm_edid.c */
-bool drm_probe_ddc(struct i2c_adapter *adapter);
-struct edid *drm_get_edid(struct drm_connector *connector,
-			  struct i2c_adapter *adapter);
-struct edid *drm_get_edid_switcheroo(struct drm_connector *connector,
-				     struct i2c_adapter *adapter);
-struct edid *drm_edid_duplicate(const struct edid *edid);
-int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid);
-
-u8 drm_match_cea_mode(const struct drm_display_mode *to_match);
-enum hdmi_picture_aspect drm_get_cea_aspect_ratio(const u8 video_code);
-bool drm_detect_hdmi_monitor(struct edid *edid);
-bool drm_detect_monitor_audio(struct edid *edid);
-bool drm_rgb_quant_range_selectable(struct edid *edid);
-int drm_add_modes_noedid(struct drm_connector *connector,
-			 int hdisplay, int vdisplay);
-void drm_set_preferred_mode(struct drm_connector *connector,
-			    int hpref, int vpref);
-
-int drm_edid_header_is_valid(const u8 *raw_edid);
-bool drm_edid_block_valid(u8 *raw_edid, int block, bool print_bad_edid,
-			  bool *edid_corrupt);
-bool drm_edid_is_valid(struct edid *edid);
-void drm_edid_get_monitor_name(struct edid *edid, char *name,
-			       int buflen);
-struct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,
-					   int hsize, int vsize, int fresh,
-					   bool rb);
-
 #endif /* __DRM_CRTC_H__ */

commit 199e4e967af476bdcab96c76237e6a1f9244d6ca
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Aug 31 18:09:05 2016 +0200

    drm: Extract drm_bridge.h
    
    We don't want to burry the bridge structures kerneldoc in drm_crtc.h.
    
    Cc: Archit Taneja <archit.taneja@gmail.com>
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160831160913.12991-3-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 749d3b2017fd..a2d1108c7c2c 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -42,6 +42,7 @@
 #include <drm/drm_connector.h>
 #include <drm/drm_encoder.h>
 #include <drm/drm_property.h>
+#include <drm/drm_bridge.h>
 
 struct drm_device;
 struct drm_mode_set;
@@ -1018,174 +1019,6 @@ struct drm_plane {
 	struct drm_property *zpos_property;
 };
 
-/**
- * struct drm_bridge_funcs - drm_bridge control functions
- */
-struct drm_bridge_funcs {
-	/**
-	 * @attach:
-	 *
-	 * This callback is invoked whenever our bridge is being attached to a
-	 * &drm_encoder.
-	 *
-	 * The attach callback is optional.
-	 *
-	 * RETURNS:
-	 *
-	 * Zero on success, error code on failure.
-	 */
-	int (*attach)(struct drm_bridge *bridge);
-
-	/**
-	 * @detach:
-	 *
-	 * This callback is invoked whenever our bridge is being detached from a
-	 * &drm_encoder.
-	 *
-	 * The detach callback is optional.
-	 */
-	void (*detach)(struct drm_bridge *bridge);
-
-	/**
-	 * @mode_fixup:
-	 *
-	 * This callback is used to validate and adjust a mode. The paramater
-	 * mode is the display mode that should be fed to the next element in
-	 * the display chain, either the final &drm_connector or the next
-	 * &drm_bridge. The parameter adjusted_mode is the input mode the bridge
-	 * requires. It can be modified by this callback and does not need to
-	 * match mode.
-	 *
-	 * This is the only hook that allows a bridge to reject a modeset. If
-	 * this function passes all other callbacks must succeed for this
-	 * configuration.
-	 *
-	 * The mode_fixup callback is optional.
-	 *
-	 * NOTE:
-	 *
-	 * This function is called in the check phase of atomic modesets, which
-	 * can be aborted for any reason (including on userspace's request to
-	 * just check whether a configuration would be possible). Drivers MUST
-	 * NOT touch any persistent state (hardware or software) or data
-	 * structures except the passed in @state parameter.
-	 *
-	 * RETURNS:
-	 *
-	 * True if an acceptable configuration is possible, false if the modeset
-	 * operation should be rejected.
-	 */
-	bool (*mode_fixup)(struct drm_bridge *bridge,
-			   const struct drm_display_mode *mode,
-			   struct drm_display_mode *adjusted_mode);
-	/**
-	 * @disable:
-	 *
-	 * This callback should disable the bridge. It is called right before
-	 * the preceding element in the display pipe is disabled. If the
-	 * preceding element is a bridge this means it's called before that
-	 * bridge's ->disable() function. If the preceding element is a
-	 * &drm_encoder it's called right before the encoder's ->disable(),
-	 * ->prepare() or ->dpms() hook from struct &drm_encoder_helper_funcs.
-	 *
-	 * The bridge can assume that the display pipe (i.e. clocks and timing
-	 * signals) feeding it is still running when this callback is called.
-	 *
-	 * The disable callback is optional.
-	 */
-	void (*disable)(struct drm_bridge *bridge);
-
-	/**
-	 * @post_disable:
-	 *
-	 * This callback should disable the bridge. It is called right after
-	 * the preceding element in the display pipe is disabled. If the
-	 * preceding element is a bridge this means it's called after that
-	 * bridge's ->post_disable() function. If the preceding element is a
-	 * &drm_encoder it's called right after the encoder's ->disable(),
-	 * ->prepare() or ->dpms() hook from struct &drm_encoder_helper_funcs.
-	 *
-	 * The bridge must assume that the display pipe (i.e. clocks and timing
-	 * singals) feeding it is no longer running when this callback is
-	 * called.
-	 *
-	 * The post_disable callback is optional.
-	 */
-	void (*post_disable)(struct drm_bridge *bridge);
-
-	/**
-	 * @mode_set:
-	 *
-	 * This callback should set the given mode on the bridge. It is called
-	 * after the ->mode_set() callback for the preceding element in the
-	 * display pipeline has been called already. The display pipe (i.e.
-	 * clocks and timing signals) is off when this function is called.
-	 */
-	void (*mode_set)(struct drm_bridge *bridge,
-			 struct drm_display_mode *mode,
-			 struct drm_display_mode *adjusted_mode);
-	/**
-	 * @pre_enable:
-	 *
-	 * This callback should enable the bridge. It is called right before
-	 * the preceding element in the display pipe is enabled. If the
-	 * preceding element is a bridge this means it's called before that
-	 * bridge's ->pre_enable() function. If the preceding element is a
-	 * &drm_encoder it's called right before the encoder's ->enable(),
-	 * ->commit() or ->dpms() hook from struct &drm_encoder_helper_funcs.
-	 *
-	 * The display pipe (i.e. clocks and timing signals) feeding this bridge
-	 * will not yet be running when this callback is called. The bridge must
-	 * not enable the display link feeding the next bridge in the chain (if
-	 * there is one) when this callback is called.
-	 *
-	 * The pre_enable callback is optional.
-	 */
-	void (*pre_enable)(struct drm_bridge *bridge);
-
-	/**
-	 * @enable:
-	 *
-	 * This callback should enable the bridge. It is called right after
-	 * the preceding element in the display pipe is enabled. If the
-	 * preceding element is a bridge this means it's called after that
-	 * bridge's ->enable() function. If the preceding element is a
-	 * &drm_encoder it's called right after the encoder's ->enable(),
-	 * ->commit() or ->dpms() hook from struct &drm_encoder_helper_funcs.
-	 *
-	 * The bridge can assume that the display pipe (i.e. clocks and timing
-	 * signals) feeding it is running when this callback is called. This
-	 * callback must enable the display link feeding the next bridge in the
-	 * chain if there is one.
-	 *
-	 * The enable callback is optional.
-	 */
-	void (*enable)(struct drm_bridge *bridge);
-};
-
-/**
- * struct drm_bridge - central DRM bridge control structure
- * @dev: DRM device this bridge belongs to
- * @encoder: encoder to which this bridge is connected
- * @next: the next bridge in the encoder chain
- * @of_node: device node pointer to the bridge
- * @list: to keep track of all added bridges
- * @funcs: control functions
- * @driver_private: pointer to the bridge driver's internal context
- */
-struct drm_bridge {
-	struct drm_device *dev;
-	struct drm_encoder *encoder;
-	struct drm_bridge *next;
-#ifdef CONFIG_OF
-	struct device_node *of_node;
-#endif
-	struct list_head list;
-
-	const struct drm_bridge_funcs *funcs;
-	void *driver_private;
-};
-
 /**
  * struct drm_crtc_commit - track modeset commits on a CRTC
  *
@@ -2200,22 +2033,4 @@ struct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,
 					   int hsize, int vsize, int fresh,
 					   bool rb);
 
-/* drm_bridge.c */
-extern int drm_bridge_add(struct drm_bridge *bridge);
-extern void drm_bridge_remove(struct drm_bridge *bridge);
-extern struct drm_bridge *of_drm_find_bridge(struct device_node *np);
-extern int drm_bridge_attach(struct drm_device *dev, struct drm_bridge *bridge);
-extern void drm_bridge_detach(struct drm_bridge *bridge);
-
-bool drm_bridge_mode_fixup(struct drm_bridge *bridge,
-			const struct drm_display_mode *mode,
-			struct drm_display_mode *adjusted_mode);
-void drm_bridge_disable(struct drm_bridge *bridge);
-void drm_bridge_post_disable(struct drm_bridge *bridge);
-void drm_bridge_mode_set(struct drm_bridge *bridge,
-			struct drm_display_mode *mode,
-			struct drm_display_mode *adjusted_mode);
-void drm_bridge_pre_enable(struct drm_bridge *bridge);
-void drm_bridge_enable(struct drm_bridge *bridge);
-
 #endif /* __DRM_CRTC_H__ */

commit afb21ea63d815d05f6081ee3efef6772a16317eb
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Aug 31 18:09:04 2016 +0200

    drm: Move a few macros away from drm_crtc.h
    
    Now that there's less stuff in there I noticed that I overlooked them.
    Sprinkle some docs over them while at it.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160831160913.12991-2-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 8ca71d66282b..749d3b2017fd 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2003,22 +2003,7 @@ struct drm_mode_config {
 	list_for_each_entry((plane), &(dev)->mode_config.plane_list, head) \
 		for_each_if ((plane_mask) & (1 << drm_plane_index(plane)))
 
-/**
- * drm_for_each_encoder_mask - iterate over encoders specified by bitmask
- * @encoder: the loop cursor
- * @dev: the DRM device
- * @encoder_mask: bitmask of encoder indices
- *
- * Iterate over all encoders specified by bitmask.
- */
-#define drm_for_each_encoder_mask(encoder, dev, encoder_mask) \
-	list_for_each_entry((encoder), &(dev)->mode_config.encoder_list, head) \
-		for_each_if ((encoder_mask) & (1 << drm_encoder_index(encoder)))
-
 #define obj_to_crtc(x) container_of(x, struct drm_crtc, base)
-#define obj_to_mode(x) container_of(x, struct drm_display_mode, base)
-#define obj_to_fb(x) container_of(x, struct drm_framebuffer, base)
-#define obj_to_blob(x) container_of(x, struct drm_property_blob, base)
 #define obj_to_plane(x) container_of(x, struct drm_plane, base)
 
 extern __printf(6, 7)
@@ -2186,23 +2171,6 @@ assert_drm_connector_list_read_locked(struct drm_mode_config *mode_config)
 		!drm_modeset_is_locked(&mode_config->connection_mutex));
 }
 
-#define drm_for_each_connector(connector, dev) \
-	for (assert_drm_connector_list_read_locked(&(dev)->mode_config),	\
-	     connector = list_first_entry(&(dev)->mode_config.connector_list,	\
-					  struct drm_connector, head);		\
-	     &connector->head != (&(dev)->mode_config.connector_list);		\
-	     connector = list_next_entry(connector, head))
-
-#define drm_for_each_encoder(encoder, dev) \
-	list_for_each_entry(encoder, &(dev)->mode_config.encoder_list, head)
-
-#define drm_for_each_fb(fb, dev) \
-	for (WARN_ON(!mutex_is_locked(&(dev)->mode_config.fb_lock)),		\
-	     fb = list_first_entry(&(dev)->mode_config.fb_list,	\
-					  struct drm_framebuffer, head);	\
-	     &fb->head != (&(dev)->mode_config.fb_list);			\
-	     fb = list_next_entry(fb, head))
-
 /* drm_edid.c */
 bool drm_probe_ddc(struct i2c_adapter *adapter);
 struct edid *drm_get_edid(struct drm_connector *connector,

commit 5e7a1d0170b06b1557768d6ddc93da1aed02961a
Merge: e9c3ddee6a08 339fd36238dd
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Sep 1 06:15:38 2016 +1000

    Merge tag 'topic/drm-misc-2016-08-31' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    More -misc stuff
    - moar drm_crtc.c split up&documentation
    - some fixes for the simple kms helpers (Andrea)
    - I included all the dri1 patches from David - we're not removing any code
      or drivers, and it seems to have worked as a wake-up call to motivate a
      few more people to upstream kms conversions for these. Feel free to
      revert if you disagree strongly.
    - a few other single patches
    
    * tag 'topic/drm-misc-2016-08-31' of git://anongit.freedesktop.org/drm-intel: (24 commits)
      drm: drm_probe_helper: Fix output_poll_work scheduling
      drm: bridge/dw-hdmi: Fix colorspace and scan information registers values
      drm/doc: Polish docs for drm_property&drm_property_blob
      drm: Unify handling of blob and object properties
      drm: Extract drm_property.[hc]
      drm: move drm_mode_legacy_fb_format to drm_fourcc.c
      drm/doc: Polish docs for drm_mode_object
      drm: Remove drm_mode_object->atomic_count
      drm: Extract drm_mode_object.[hc]
      drm/doc: Polish kerneldoc for encoders
      drm: Extract drm_encoder.[hc]
      drm/fb-helper: don't call remove_conflicting_framebuffers for FB=m && DRM=y
      drm/atomic-helper: Add NO_DISABLE_AFTER_MODESET flag support for plane commit
      drm/atomic-helper: Disable appropriate planes in disable_planes_on_crtc()
      drm/atomic-helper: Add atomic_disable CRTC helper callback
      drm: simple_kms_helper: add support for bridges
      drm: simple_kms_helper: make connector optional at init time
      drm/bridge: introduce bridge detaching mechanism
      drm/simple-helpers: Always add planes to the state update
      drm: reduce GETCLIENT to a minimum
      ...

commit 59e71ee746a37fe077b73cecf189de1d27efd6eb
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Aug 29 10:27:55 2016 +0200

    drm: Extract drm_property.[hc]
    
    This just contains the base property classes and all the code to
    handle blobs. I think for any kind of standardized/shared properties
    it's better to have separate files - this is fairly big already as-is.
    
    v2: resurrect misplaced hunk (Daniel Stone)
    
    Cc: Daniel Stone <daniel@fooishbar.org>
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160829082757.17913-7-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 63f03490e987..3d33c90da9e5 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -41,6 +41,7 @@
 #include <drm/drm_modes.h>
 #include <drm/drm_connector.h>
 #include <drm/drm_encoder.h>
+#include <drm/drm_property.h>
 
 struct drm_device;
 struct drm_mode_set;
@@ -82,33 +83,6 @@ struct drm_tile_group {
 	u8 group_data[8];
 };
 
-struct drm_property_blob {
-	struct drm_mode_object base;
-	struct drm_device *dev;
-	struct list_head head_global;
-	struct list_head head_file;
-	size_t length;
-	unsigned char data[];
-};
-
-struct drm_property_enum {
-	uint64_t value;
-	struct list_head head;
-	char name[DRM_PROP_NAME_LEN];
-};
-
-struct drm_property {
-	struct list_head head;
-	struct drm_mode_object base;
-	uint32_t flags;
-	char name[DRM_PROP_NAME_LEN];
-	uint32_t num_values;
-	uint64_t *values;
-	struct drm_device *dev;
-
-	struct list_head enum_list;
-};
-
 struct drm_crtc;
 struct drm_encoder;
 struct drm_pending_vblank_event;
@@ -2026,15 +2000,9 @@ struct drm_mode_config {
 #define obj_to_crtc(x) container_of(x, struct drm_crtc, base)
 #define obj_to_mode(x) container_of(x, struct drm_display_mode, base)
 #define obj_to_fb(x) container_of(x, struct drm_framebuffer, base)
-#define obj_to_property(x) container_of(x, struct drm_property, base)
 #define obj_to_blob(x) container_of(x, struct drm_property_blob, base)
 #define obj_to_plane(x) container_of(x, struct drm_plane, base)
 
-struct drm_prop_enum_list {
-	int type;
-	char *name;
-};
-
 extern __printf(6, 7)
 int drm_crtc_init_with_planes(struct drm_device *dev,
 			      struct drm_crtc *crtc,
@@ -2107,52 +2075,6 @@ extern void drm_mode_config_init(struct drm_device *dev);
 extern void drm_mode_config_reset(struct drm_device *dev);
 extern void drm_mode_config_cleanup(struct drm_device *dev);
 
-static inline bool drm_property_type_is(struct drm_property *property,
-		uint32_t type)
-{
-	/* instanceof for props.. handles extended type vs original types: */
-	if (property->flags & DRM_MODE_PROP_EXTENDED_TYPE)
-		return (property->flags & DRM_MODE_PROP_EXTENDED_TYPE) == type;
-	return property->flags & type;
-}
-
-extern struct drm_property *drm_property_create(struct drm_device *dev, int flags,
-						const char *name, int num_values);
-extern struct drm_property *drm_property_create_enum(struct drm_device *dev, int flags,
-					 const char *name,
-					 const struct drm_prop_enum_list *props,
-					 int num_values);
-struct drm_property *drm_property_create_bitmask(struct drm_device *dev,
-					 int flags, const char *name,
-					 const struct drm_prop_enum_list *props,
-					 int num_props,
-					 uint64_t supported_bits);
-struct drm_property *drm_property_create_range(struct drm_device *dev, int flags,
-					 const char *name,
-					 uint64_t min, uint64_t max);
-struct drm_property *drm_property_create_signed_range(struct drm_device *dev,
-					 int flags, const char *name,
-					 int64_t min, int64_t max);
-struct drm_property *drm_property_create_object(struct drm_device *dev,
-					 int flags, const char *name, uint32_t type);
-struct drm_property *drm_property_create_bool(struct drm_device *dev, int flags,
-					 const char *name);
-struct drm_property_blob *drm_property_create_blob(struct drm_device *dev,
-                                                   size_t length,
-                                                   const void *data);
-struct drm_property_blob *drm_property_lookup_blob(struct drm_device *dev,
-                                                   uint32_t id);
-int drm_property_replace_global_blob(struct drm_device *dev,
-				     struct drm_property_blob **replace,
-				     size_t length,
-				     const void *data,
-				     struct drm_mode_object *obj_holds_id,
-				     struct drm_property *prop_holds_id);
-struct drm_property_blob *drm_property_reference_blob(struct drm_property_blob *blob);
-void drm_property_unreference_blob(struct drm_property_blob *blob);
-extern void drm_property_destroy(struct drm_device *dev, struct drm_property *property);
-extern int drm_property_add_enum(struct drm_property *property, int index,
-				 uint64_t value, const char *name);
 extern int drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,
 					 int gamma_size);
 
@@ -2202,14 +2124,6 @@ static inline struct drm_crtc *drm_crtc_find(struct drm_device *dev,
 	return mo ? obj_to_crtc(mo) : NULL;
 }
 
-static inline struct drm_property *drm_property_find(struct drm_device *dev,
-		uint32_t id)
-{
-	struct drm_mode_object *mo;
-	mo = drm_mode_object_find(dev, id, DRM_MODE_OBJECT_PROPERTY);
-	return mo ? obj_to_property(mo) : NULL;
-}
-
 /*
  * Extract a degamma/gamma LUT value provided by user and round it to the
  * precision supported by the hardware.

commit ec5e304747241823435b160d3eabf1295c06d2e3
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Aug 29 10:27:54 2016 +0200

    drm: move drm_mode_legacy_fb_format to drm_fourcc.c
    
    It's part of the drm fourcc handling code, mapping the old depth/bpp
    values to new fourcc codes.
    
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160829082757.17913-6-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 8ea3e65fe0c2..63f03490e987 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2158,8 +2158,6 @@ extern int drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,
 
 extern int drm_mode_set_config_internal(struct drm_mode_set *set);
 
-extern uint32_t drm_mode_legacy_fb_format(uint32_t bpp, uint32_t depth);
-
 extern struct drm_tile_group *drm_mode_create_tile_group(struct drm_device *dev,
 							 char topology[8]);
 extern struct drm_tile_group *drm_mode_get_tile_group(struct drm_device *dev,

commit 949619f32eee37a6385de1e976523501c8256768
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Aug 29 10:27:51 2016 +0200

    drm: Extract drm_mode_object.[hc]
    
    Just for the struct drm_mode_object base class. The header file was
    already partially extracted to help untangle the include loops.
    
    v2:
    - Also move the generic get/set property ioctls. At first this seemed
      like a bad idea since it requires making drm_mode_crtc_set_obj_prop
      non-static. But eventually that will get split away too (like
      the connector version already is) for both crtc and planes. Hence I
      reconsidered.
    
    - drm_mode_object.[hc] instead of drm_modeset.[hc], which requires
      renaming the drm_modeset.h header I already started building up.
      This is more consistent (matches the name of the main structure),
      and I want to be able to use drm_modeset.[hc] for the basic modeset
      init/cleanup functionality like drm_mode_config_init.
    
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160829082757.17913-3-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c459867ecb9c..8ea3e65fe0c2 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -36,7 +36,7 @@
 #include <uapi/drm/drm_fourcc.h>
 #include <drm/drm_modeset_lock.h>
 #include <drm/drm_rect.h>
-#include <drm/drm_modeset.h>
+#include <drm/drm_mode_object.h>
 #include <drm/drm_framebuffer.h>
 #include <drm/drm_modes.h>
 #include <drm/drm_connector.h>
@@ -2116,16 +2116,6 @@ static inline bool drm_property_type_is(struct drm_property *property,
 	return property->flags & type;
 }
 
-extern int drm_object_property_set_value(struct drm_mode_object *obj,
-					 struct drm_property *property,
-					 uint64_t val);
-extern int drm_object_property_get_value(struct drm_mode_object *obj,
-					 struct drm_property *property,
-					 uint64_t *value);
-
-extern void drm_object_attach_property(struct drm_mode_object *obj,
-				       struct drm_property *property,
-				       uint64_t init_val);
 extern struct drm_property *drm_property_create(struct drm_device *dev, int flags,
 						const char *name, int num_values);
 extern struct drm_property *drm_property_create_enum(struct drm_device *dev, int flags,

commit 321a95ae35f2ec4f58c4cda28d3606cc6f2b97d1
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Aug 29 10:27:49 2016 +0200

    drm: Extract drm_encoder.[hc]
    
    Same treatment as before. Only hiccup is drm_crtc_mask, which
    unfortunately can't be resolved until drm_crtc.h is less of a monster.
    Untangle the header loop with a forward declaration for that static
    inline.
    
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160829082757.17913-1-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index bb214a114329..c459867ecb9c 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -40,6 +40,7 @@
 #include <drm/drm_framebuffer.h>
 #include <drm/drm_modes.h>
 #include <drm/drm_connector.h>
+#include <drm/drm_encoder.h>
 
 struct drm_device;
 struct drm_mode_set;
@@ -661,97 +662,6 @@ struct drm_crtc {
 	struct drm_modeset_acquire_ctx *acquire_ctx;
 };
 
-/**
- * struct drm_encoder_funcs - encoder controls
- *
- * Encoders sit between CRTCs and connectors.
- */
-struct drm_encoder_funcs {
-	/**
-	 * @reset:
-	 *
-	 * Reset encoder hardware and software state to off. This function isn't
-	 * called by the core directly, only through drm_mode_config_reset().
-	 * It's not a helper hook only for historical reasons.
-	 */
-	void (*reset)(struct drm_encoder *encoder);
-
-	/**
-	 * @destroy:
-	 *
-	 * Clean up encoder resources. This is only called at driver unload time
-	 * through drm_mode_config_cleanup() since an encoder cannot be
-	 * hotplugged in DRM.
-	 */
-	void (*destroy)(struct drm_encoder *encoder);
-
-	/**
-	 * @late_register:
-	 *
-	 * This optional hook can be used to register additional userspace
-	 * interfaces attached to the encoder like debugfs interfaces.
-	 * It is called late in the driver load sequence from drm_dev_register().
-	 * Everything added from this callback should be unregistered in
-	 * the early_unregister callback.
-	 *
-	 * Returns:
-	 *
-	 * 0 on success, or a negative error code on failure.
-	 */
-	int (*late_register)(struct drm_encoder *encoder);
-
-	/**
-	 * @early_unregister:
-	 *
-	 * This optional hook should be used to unregister the additional
-	 * userspace interfaces attached to the encoder from
-	 * late_unregister(). It is called from drm_dev_unregister(),
-	 * early in the driver unload sequence to disable userspace access
-	 * before data structures are torndown.
-	 */
-	void (*early_unregister)(struct drm_encoder *encoder);
-};
-
-/**
- * struct drm_encoder - central DRM encoder structure
- * @dev: parent DRM device
- * @head: list management
- * @base: base KMS object
- * @name: human readable name, can be overwritten by the driver
- * @encoder_type: one of the DRM_MODE_ENCODER_<foo> types in drm_mode.h
- * @possible_crtcs: bitmask of potential CRTC bindings
- * @possible_clones: bitmask of potential sibling encoders for cloning
- * @crtc: currently bound CRTC
- * @bridge: bridge associated to the encoder
- * @funcs: control functions
- * @helper_private: mid-layer private data
- *
- * CRTCs drive pixels to encoders, which convert them into signals
- * appropriate for a given connector or set of connectors.
- */
-struct drm_encoder {
-	struct drm_device *dev;
-	struct list_head head;
-
-	struct drm_mode_object base;
-	char *name;
-	int encoder_type;
-
-	/**
-	 * @index: Position inside the mode_config.list, can be used as an array
-	 * index. It is invariant over the lifetime of the encoder.
-	 */
-	unsigned index;
-
-	uint32_t possible_crtcs;
-	uint32_t possible_clones;
-
-	struct drm_crtc *crtc;
-	struct drm_bridge *bridge;
-	const struct drm_encoder_funcs *funcs;
-	const struct drm_encoder_helper_funcs *helper_private;
-};
-
 /**
  * struct drm_plane_state - mutable plane state
  * @plane: backpointer to the plane
@@ -2114,7 +2024,6 @@ struct drm_mode_config {
 		for_each_if ((encoder_mask) & (1 << drm_encoder_index(encoder)))
 
 #define obj_to_crtc(x) container_of(x, struct drm_crtc, base)
-#define obj_to_encoder(x) container_of(x, struct drm_encoder, base)
 #define obj_to_mode(x) container_of(x, struct drm_display_mode, base)
 #define obj_to_fb(x) container_of(x, struct drm_framebuffer, base)
 #define obj_to_property(x) container_of(x, struct drm_property, base)
@@ -2159,37 +2068,6 @@ static inline uint32_t drm_crtc_mask(struct drm_crtc *crtc)
 	return 1 << drm_crtc_index(crtc);
 }
 
-extern __printf(5, 6)
-int drm_encoder_init(struct drm_device *dev,
-		     struct drm_encoder *encoder,
-		     const struct drm_encoder_funcs *funcs,
-		     int encoder_type, const char *name, ...);
-
-/**
- * drm_encoder_index - find the index of a registered encoder
- * @encoder: encoder to find index for
- *
- * Given a registered encoder, return the index of that encoder within a DRM
- * device's list of encoders.
- */
-static inline unsigned int drm_encoder_index(struct drm_encoder *encoder)
-{
-	return encoder->index;
-}
-
-/**
- * drm_encoder_crtc_ok - can a given crtc drive a given encoder?
- * @encoder: encoder to test
- * @crtc: crtc to test
- *
- * Return false if @encoder can't be driven by @crtc, true otherwise.
- */
-static inline bool drm_encoder_crtc_ok(struct drm_encoder *encoder,
-				       struct drm_crtc *crtc)
-{
-	return !!(encoder->possible_crtcs & drm_crtc_mask(crtc));
-}
-
 extern __printf(8, 9)
 int drm_universal_plane_init(struct drm_device *dev,
 			     struct drm_plane *plane,
@@ -2225,8 +2103,6 @@ extern void drm_crtc_get_hv_timing(const struct drm_display_mode *mode,
 extern int drm_crtc_force_disable(struct drm_crtc *crtc);
 extern int drm_crtc_force_disable_all(struct drm_device *dev);
 
-extern void drm_encoder_cleanup(struct drm_encoder *encoder);
-
 extern void drm_mode_config_init(struct drm_device *dev);
 extern void drm_mode_config_reset(struct drm_device *dev);
 extern void drm_mode_config_cleanup(struct drm_device *dev);
@@ -2338,14 +2214,6 @@ static inline struct drm_crtc *drm_crtc_find(struct drm_device *dev,
 	return mo ? obj_to_crtc(mo) : NULL;
 }
 
-static inline struct drm_encoder *drm_encoder_find(struct drm_device *dev,
-	uint32_t id)
-{
-	struct drm_mode_object *mo;
-	mo = drm_mode_object_find(dev, id, DRM_MODE_OBJECT_ENCODER);
-	return mo ? obj_to_encoder(mo) : NULL;
-}
-
 static inline struct drm_property *drm_property_find(struct drm_device *dev,
 		uint32_t id)
 {

commit cf3bef95e1014233cb1ce89da8cfa5cd22e7412c
Author: Andrea Merello <andrea.merello@gmail.com>
Date:   Thu Aug 25 11:04:32 2016 +0200

    drm/bridge: introduce bridge detaching mechanism
    
    Up to now, once a bridge has been attached to a DRM device, it cannot
    be undone.
    
    In particular you couldn't rmmod/insmod a DRM driver that uses a bridge,
    because the bridge would remain bound to the first (dead) driver instance.
    
    This patch fixes this by introducing drm_encoder_detach() and a ->detach
    callback in drm_bridge_funcs for the bridge to be notified about detaches.
    
    It's DRM/KMS driver responsibility to call drm_encoder_detach().
    
    While adding the bridge detach callback, with its kerneldoc, I also added
    kerneldoc for attach callback.
    
    Few other kerneldocs fixes around there are included.
    
    Suggested-by: Daniel Vetter <daniel@ffwll.ch>
    Suggested-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Andrea Merello <andrea.merello@gmail.com>
    Cc: Archit Taneja <architt@codeaurora.org>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1472115874-6219-1-git-send-email-andrea.merello@gmail.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 3fa0275e509f..bb214a114329 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1118,11 +1118,32 @@ struct drm_plane {
 
 /**
  * struct drm_bridge_funcs - drm_bridge control functions
- * @attach: Called during drm_bridge_attach
  */
 struct drm_bridge_funcs {
+	/**
+	 * @attach:
+	 *
+	 * This callback is invoked whenever our bridge is being attached to a
+	 * &drm_encoder.
+	 *
+	 * The attach callback is optional.
+	 *
+	 * RETURNS:
+	 *
+	 * Zero on success, error code on failure.
+	 */
 	int (*attach)(struct drm_bridge *bridge);
 
+	/**
+	 * @detach:
+	 *
+	 * This callback is invoked whenever our bridge is being detached from a
+	 * &drm_encoder.
+	 *
+	 * The detach callback is optional.
+	 */
+	void (*detach)(struct drm_bridge *bridge);
+
 	/**
 	 * @mode_fixup:
 	 *
@@ -1137,6 +1158,8 @@ struct drm_bridge_funcs {
 	 * this function passes all other callbacks must succeed for this
 	 * configuration.
 	 *
+	 * The mode_fixup callback is optional.
+	 *
 	 * NOTE:
 	 *
 	 * This function is called in the check phase of atomic modesets, which
@@ -2426,6 +2449,7 @@ extern int drm_bridge_add(struct drm_bridge *bridge);
 extern void drm_bridge_remove(struct drm_bridge *bridge);
 extern struct drm_bridge *of_drm_find_bridge(struct device_node *np);
 extern int drm_bridge_attach(struct drm_device *dev, struct drm_bridge *bridge);
+extern void drm_bridge_detach(struct drm_bridge *bridge);
 
 bool drm_bridge_mode_fixup(struct drm_bridge *bridge,
 			const struct drm_display_mode *mode,

commit e9c3ddee6a08c5b25cdb06b524320a5a98250513
Merge: 51d6120792ab 7b4d3e297e8a
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Aug 25 12:59:50 2016 +1000

    Merge branch 'drm-next-4.9' of git://people.freedesktop.org/~agd5f/linux into drm-next
    
    First drm-next pull for radeon and amdgpu for 4.9.  Highlights:
    - powerplay support for iceland asics
    - improved GPU reset (both full asic and per block)
    - UVD and VCE powergating for CZ and ST
    - VCE clockgating for CZ and ST
    - Support for pre-initialized (e.g., zeroed) vram buffers
    - ttm cleanups
    - virtual display support
    - core and radeon/amdgpu support for page_flip_target
    - lots of bug fixes and clean ups
    
    * 'drm-next-4.9' of git://people.freedesktop.org/~agd5f/linux: (171 commits)
      drm/amdgpu: use memcpy_toio for VCE firmware upload
      drm/amdgpu: use memcpy_to/fromio for UVD fw upload
      drm/amd/powerplay: delete useless code in iceland_hwmgr.c.
      drm/radeon: switch UVD code to use UVD_NO_OP for padding
      drm/amdgpu: switch UVD code to use UVD_NO_OP for padding
      drm/radeon: add support for UVD_NO_OP register
      drm/amdgpu: add support for UVD_NO_OP register
      drm/amdgpu: fix VCE ib alignment value
      drm/amdgpu: fix IB alignment for UVD
      drm/amd/amdgpu: Print ring name in amdgpu_ib_schedule()
      drm/radeon: remove dead code, si_mc_load_microcode (v2)
      drm/radeon/cik: remove dead code (v2)
      drm/amd/powerplay: avoid NULL dereference, cz_hwmgr.c
      drm/amd/powerplay: avoid NULL pointer dereference
      drm/amdgpu/gmc8: remove dead code (v2)
      drm/amdgpu/gmc7: remove dead code (v2)
      drm/amdgpu: Fix indentation in dce_v8_0_audio_write_sad_regs()
      drm/amdgpu: Use correct mask in dce_v8_0_afmt_setmode() and fix comment typos.
      drm/amdgpu: cleanup amdgpu_vm_bo_update params
      drm/amdgpu: stop adding dummy entry in amdgpu_ttm_placement_init
      ...

commit b3c6c8bfe378309f8185d591579a3cb3aa2fe2e8
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Aug 12 22:48:55 2016 +0200

    drm: document drm_display_info
    
    We seem to have a bit a mess in how to describe the bus formats, with
    a multitude of competing ways. Might be best to consolidate it all and
    use MEDIA_BUS_FMT_ also for the hdmi color formats and high color
    modes.
    
    Also move all the display_info related functions into drm_connector.c
    (there's only one) to group it all together. I did decided against
    also moving the edid related display info functions, they seem to fit
    better in drm_edid.c. Instead sprinkle a few cross references around.
    While at that reduce the kerneldoc for static functions, there's not
    point in documenting internals with that much detail really.
    
    v2: Fix typo and move misplaced hunk (Sean).
    
    Cc: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1471034937-651-19-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index e30ea0be6417..3fa0275e509f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2208,10 +2208,6 @@ extern void drm_mode_config_init(struct drm_device *dev);
 extern void drm_mode_config_reset(struct drm_device *dev);
 extern void drm_mode_config_cleanup(struct drm_device *dev);
 
-extern int drm_display_info_set_bus_formats(struct drm_display_info *info,
-					    const u32 *formats,
-					    unsigned int num_formats);
-
 static inline bool drm_property_type_is(struct drm_property *property,
 		uint32_t type)
 {

commit 522171951761153172c75b94ae1f4bc9ab631745
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Aug 12 22:48:50 2016 +0200

    drm: Extract drm_connector.[hc]
    
    Pulls in quite a lot of connector related structures (cmdline mode,
    force/status enums, display info), but I think that all makes perfect
    sense.
    
    Also had to move a few more core kms object stuff into drm_modeset.h.
    
    And as a first cleanup remove the kerneldoc for the 2 connector IOCTL
    - DRM core docs are aimed at drivers, no point documenting internal in
    excruciating detail.
    
    v2: And also pull in all the connector property code.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1471034937-651-14-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f4d041800551..e30ea0be6417 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -39,31 +39,16 @@
 #include <drm/drm_modeset.h>
 #include <drm/drm_framebuffer.h>
 #include <drm/drm_modes.h>
+#include <drm/drm_connector.h>
 
 struct drm_device;
 struct drm_mode_set;
-struct drm_object_properties;
 struct drm_file;
 struct drm_clip_rect;
 struct device_node;
 struct fence;
 struct edid;
 
-#define DRM_OBJECT_MAX_PROPERTY 24
-struct drm_object_properties {
-	int count, atomic_count;
-	/* NOTE: if we ever start dynamically destroying properties (ie.
-	 * not at drm_mode_config_cleanup() time), then we'd have to do
-	 * a better job of detaching property from mode objects to avoid
-	 * dangling property pointers:
-	 */
-	struct drm_property *properties[DRM_OBJECT_MAX_PROPERTY];
-	/* do not read/write values directly, but use drm_object_property_get_value()
-	 * and drm_object_property_set_value():
-	 */
-	uint64_t values[DRM_OBJECT_MAX_PROPERTY];
-};
-
 static inline int64_t U642I64(uint64_t val)
 {
 	return (int64_t)*((int64_t *)&val);
@@ -88,61 +73,6 @@ static inline uint64_t I642U64(int64_t val)
 #define DRM_REFLECT_Y	BIT(5)
 #define DRM_REFLECT_MASK (DRM_REFLECT_X | DRM_REFLECT_Y)
 
-enum drm_connector_status {
-	connector_status_connected = 1,
-	connector_status_disconnected = 2,
-	connector_status_unknown = 3,
-};
-
-enum subpixel_order {
-	SubPixelUnknown = 0,
-	SubPixelHorizontalRGB,
-	SubPixelHorizontalBGR,
-	SubPixelVerticalRGB,
-	SubPixelVerticalBGR,
-	SubPixelNone,
-};
-
-#define DRM_COLOR_FORMAT_RGB444		(1<<0)
-#define DRM_COLOR_FORMAT_YCRCB444	(1<<1)
-#define DRM_COLOR_FORMAT_YCRCB422	(1<<2)
-
-#define DRM_BUS_FLAG_DE_LOW		(1<<0)
-#define DRM_BUS_FLAG_DE_HIGH		(1<<1)
-/* drive data on pos. edge */
-#define DRM_BUS_FLAG_PIXDATA_POSEDGE	(1<<2)
-/* drive data on neg. edge */
-#define DRM_BUS_FLAG_PIXDATA_NEGEDGE	(1<<3)
-
-/*
- * Describes a given display (e.g. CRT or flat panel) and its limitations.
- */
-struct drm_display_info {
-	char name[DRM_DISPLAY_INFO_LEN];
-
-	/* Physical size */
-        unsigned int width_mm;
-	unsigned int height_mm;
-
-	/* Clock limits FIXME: storage format */
-	unsigned int min_vfreq, max_vfreq;
-	unsigned int min_hfreq, max_hfreq;
-	unsigned int pixel_clock;
-	unsigned int bpc;
-
-	enum subpixel_order subpixel_order;
-	u32 color_formats;
-
-	const u32 *bus_formats;
-	unsigned int num_bus_formats;
-	u32 bus_flags;
-
-	/* Mask of supported hdmi deep color modes */
-	u8 edid_hdmi_dc_modes;
-
-	u8 cea_rev;
-};
-
 /* data corresponds to displayid vend/prod/serial */
 struct drm_tile_group {
 	struct kref refcount;
@@ -179,7 +109,6 @@ struct drm_property {
 };
 
 struct drm_crtc;
-struct drm_connector;
 struct drm_encoder;
 struct drm_pending_vblank_event;
 struct drm_plane;
@@ -188,7 +117,6 @@ struct drm_atomic_state;
 
 struct drm_crtc_helper_funcs;
 struct drm_encoder_helper_funcs;
-struct drm_connector_helper_funcs;
 struct drm_plane_helper_funcs;
 
 /**
@@ -733,291 +661,6 @@ struct drm_crtc {
 	struct drm_modeset_acquire_ctx *acquire_ctx;
 };
 
-/**
- * struct drm_connector_state - mutable connector state
- * @connector: backpointer to the connector
- * @crtc: CRTC to connect connector to, NULL if disabled
- * @best_encoder: can be used by helpers and drivers to select the encoder
- * @state: backpointer to global drm_atomic_state
- */
-struct drm_connector_state {
-	struct drm_connector *connector;
-
-	struct drm_crtc *crtc;  /* do not write directly, use drm_atomic_set_crtc_for_connector() */
-
-	struct drm_encoder *best_encoder;
-
-	struct drm_atomic_state *state;
-};
-
-/**
- * struct drm_connector_funcs - control connectors on a given device
- *
- * Each CRTC may have one or more connectors attached to it.  The functions
- * below allow the core DRM code to control connectors, enumerate available modes,
- * etc.
- */
-struct drm_connector_funcs {
-	/**
-	 * @dpms:
-	 *
-	 * Legacy entry point to set the per-connector DPMS state. Legacy DPMS
-	 * is exposed as a standard property on the connector, but diverted to
-	 * this callback in the drm core. Note that atomic drivers don't
-	 * implement the 4 level DPMS support on the connector any more, but
-	 * instead only have an on/off "ACTIVE" property on the CRTC object.
-	 *
-	 * Drivers implementing atomic modeset should use
-	 * drm_atomic_helper_connector_dpms() to implement this hook.
-	 *
-	 * RETURNS:
-	 *
-	 * 0 on success or a negative error code on failure.
-	 */
-	int (*dpms)(struct drm_connector *connector, int mode);
-
-	/**
-	 * @reset:
-	 *
-	 * Reset connector hardware and software state to off. This function isn't
-	 * called by the core directly, only through drm_mode_config_reset().
-	 * It's not a helper hook only for historical reasons.
-	 *
-	 * Atomic drivers can use drm_atomic_helper_connector_reset() to reset
-	 * atomic state using this hook.
-	 */
-	void (*reset)(struct drm_connector *connector);
-
-	/**
-	 * @detect:
-	 *
-	 * Check to see if anything is attached to the connector. The parameter
-	 * force is set to false whilst polling, true when checking the
-	 * connector due to a user request. force can be used by the driver to
-	 * avoid expensive, destructive operations during automated probing.
-	 *
-	 * FIXME:
-	 *
-	 * Note that this hook is only called by the probe helper. It's not in
-	 * the helper library vtable purely for historical reasons. The only DRM
-	 * core	entry point to probe connector state is @fill_modes.
-	 *
-	 * RETURNS:
-	 *
-	 * drm_connector_status indicating the connector's status.
-	 */
-	enum drm_connector_status (*detect)(struct drm_connector *connector,
-					    bool force);
-
-	/**
-	 * @force:
-	 *
-	 * This function is called to update internal encoder state when the
-	 * connector is forced to a certain state by userspace, either through
-	 * the sysfs interfaces or on the kernel cmdline. In that case the
-	 * @detect callback isn't called.
-	 *
-	 * FIXME:
-	 *
-	 * Note that this hook is only called by the probe helper. It's not in
-	 * the helper library vtable purely for historical reasons. The only DRM
-	 * core	entry point to probe connector state is @fill_modes.
-	 */
-	void (*force)(struct drm_connector *connector);
-
-	/**
-	 * @fill_modes:
-	 *
-	 * Entry point for output detection and basic mode validation. The
-	 * driver should reprobe the output if needed (e.g. when hotplug
-	 * handling is unreliable), add all detected modes to connector->modes
-	 * and filter out any the device can't support in any configuration. It
-	 * also needs to filter out any modes wider or higher than the
-	 * parameters max_width and max_height indicate.
-	 *
-	 * The drivers must also prune any modes no longer valid from
-	 * connector->modes. Furthermore it must update connector->status and
-	 * connector->edid.  If no EDID has been received for this output
-	 * connector->edid must be NULL.
-	 *
-	 * Drivers using the probe helpers should use
-	 * drm_helper_probe_single_connector_modes() or
-	 * drm_helper_probe_single_connector_modes_nomerge() to implement this
-	 * function.
-	 *
-	 * RETURNS:
-	 *
-	 * The number of modes detected and filled into connector->modes.
-	 */
-	int (*fill_modes)(struct drm_connector *connector, uint32_t max_width, uint32_t max_height);
-
-	/**
-	 * @set_property:
-	 *
-	 * This is the legacy entry point to update a property attached to the
-	 * connector.
-	 *
-	 * Drivers implementing atomic modeset should use
-	 * drm_atomic_helper_connector_set_property() to implement this hook.
-	 *
-	 * This callback is optional if the driver does not support any legacy
-	 * driver-private properties.
-	 *
-	 * RETURNS:
-	 *
-	 * 0 on success or a negative error code on failure.
-	 */
-	int (*set_property)(struct drm_connector *connector, struct drm_property *property,
-			     uint64_t val);
-
-	/**
-	 * @late_register:
-	 *
-	 * This optional hook can be used to register additional userspace
-	 * interfaces attached to the connector, light backlight control, i2c,
-	 * DP aux or similar interfaces. It is called late in the driver load
-	 * sequence from drm_connector_register() when registering all the
-	 * core drm connector interfaces. Everything added from this callback
-	 * should be unregistered in the early_unregister callback.
-	 *
-	 * Returns:
-	 *
-	 * 0 on success, or a negative error code on failure.
-	 */
-	int (*late_register)(struct drm_connector *connector);
-
-	/**
-	 * @early_unregister:
-	 *
-	 * This optional hook should be used to unregister the additional
-	 * userspace interfaces attached to the connector from
-	 * late_unregister(). It is called from drm_connector_unregister(),
-	 * early in the driver unload sequence to disable userspace access
-	 * before data structures are torndown.
-	 */
-	void (*early_unregister)(struct drm_connector *connector);
-
-	/**
-	 * @destroy:
-	 *
-	 * Clean up connector resources. This is called at driver unload time
-	 * through drm_mode_config_cleanup(). It can also be called at runtime
-	 * when a connector is being hot-unplugged for drivers that support
-	 * connector hotplugging (e.g. DisplayPort MST).
-	 */
-	void (*destroy)(struct drm_connector *connector);
-
-	/**
-	 * @atomic_duplicate_state:
-	 *
-	 * Duplicate the current atomic state for this connector and return it.
-	 * The core and helpers gurantee that any atomic state duplicated with
-	 * this hook and still owned by the caller (i.e. not transferred to the
-	 * driver by calling ->atomic_commit() from struct
-	 * &drm_mode_config_funcs) will be cleaned up by calling the
-	 * @atomic_destroy_state hook in this structure.
-	 *
-	 * Atomic drivers which don't subclass struct &drm_connector_state should use
-	 * drm_atomic_helper_connector_duplicate_state(). Drivers that subclass the
-	 * state structure to extend it with driver-private state should use
-	 * __drm_atomic_helper_connector_duplicate_state() to make sure shared state is
-	 * duplicated in a consistent fashion across drivers.
-	 *
-	 * It is an error to call this hook before connector->state has been
-	 * initialized correctly.
-	 *
-	 * NOTE:
-	 *
-	 * If the duplicate state references refcounted resources this hook must
-	 * acquire a reference for each of them. The driver must release these
-	 * references again in @atomic_destroy_state.
-	 *
-	 * RETURNS:
-	 *
-	 * Duplicated atomic state or NULL when the allocation failed.
-	 */
-	struct drm_connector_state *(*atomic_duplicate_state)(struct drm_connector *connector);
-
-	/**
-	 * @atomic_destroy_state:
-	 *
-	 * Destroy a state duplicated with @atomic_duplicate_state and release
-	 * or unreference all resources it references
-	 */
-	void (*atomic_destroy_state)(struct drm_connector *connector,
-				     struct drm_connector_state *state);
-
-	/**
-	 * @atomic_set_property:
-	 *
-	 * Decode a driver-private property value and store the decoded value
-	 * into the passed-in state structure. Since the atomic core decodes all
-	 * standardized properties (even for extensions beyond the core set of
-	 * properties which might not be implemented by all drivers) this
-	 * requires drivers to subclass the state structure.
-	 *
-	 * Such driver-private properties should really only be implemented for
-	 * truly hardware/vendor specific state. Instead it is preferred to
-	 * standardize atomic extension and decode the properties used to expose
-	 * such an extension in the core.
-	 *
-	 * Do not call this function directly, use
-	 * drm_atomic_connector_set_property() instead.
-	 *
-	 * This callback is optional if the driver does not support any
-	 * driver-private atomic properties.
-	 *
-	 * NOTE:
-	 *
-	 * This function is called in the state assembly phase of atomic
-	 * modesets, which can be aborted for any reason (including on
-	 * userspace's request to just check whether a configuration would be
-	 * possible). Drivers MUST NOT touch any persistent state (hardware or
-	 * software) or data structures except the passed in @state parameter.
-	 *
-	 * Also since userspace controls in which order properties are set this
-	 * function must not do any input validation (since the state update is
-	 * incomplete and hence likely inconsistent). Instead any such input
-	 * validation must be done in the various atomic_check callbacks.
-	 *
-	 * RETURNS:
-	 *
-	 * 0 if the property has been found, -EINVAL if the property isn't
-	 * implemented by the driver (which shouldn't ever happen, the core only
-	 * asks for properties attached to this connector). No other validation
-	 * is allowed by the driver. The core already checks that the property
-	 * value is within the range (integer, valid enum value, ...) the driver
-	 * set when registering the property.
-	 */
-	int (*atomic_set_property)(struct drm_connector *connector,
-				   struct drm_connector_state *state,
-				   struct drm_property *property,
-				   uint64_t val);
-
-	/**
-	 * @atomic_get_property:
-	 *
-	 * Reads out the decoded driver-private property. This is used to
-	 * implement the GETCONNECTOR IOCTL.
-	 *
-	 * Do not call this function directly, use
-	 * drm_atomic_connector_get_property() instead.
-	 *
-	 * This callback is optional if the driver does not support any
-	 * driver-private atomic properties.
-	 *
-	 * RETURNS:
-	 *
-	 * 0 on success, -EINVAL if the property isn't implemented by the
-	 * driver (which shouldn't ever happen, the core only asks for
-	 * properties attached to this connector).
-	 */
-	int (*atomic_get_property)(struct drm_connector *connector,
-				   const struct drm_connector_state *state,
-				   struct drm_property *property,
-				   uint64_t *val);
-};
-
 /**
  * struct drm_encoder_funcs - encoder controls
  *
@@ -1069,8 +712,6 @@ struct drm_encoder_funcs {
 	void (*early_unregister)(struct drm_encoder *encoder);
 };
 
-#define DRM_CONNECTOR_MAX_ENCODER 3
-
 /**
  * struct drm_encoder - central DRM encoder structure
  * @dev: parent DRM device
@@ -1111,171 +752,6 @@ struct drm_encoder {
 	const struct drm_encoder_helper_funcs *helper_private;
 };
 
-/* should we poll this connector for connects and disconnects */
-/* hot plug detectable */
-#define DRM_CONNECTOR_POLL_HPD (1 << 0)
-/* poll for connections */
-#define DRM_CONNECTOR_POLL_CONNECT (1 << 1)
-/* can cleanly poll for disconnections without flickering the screen */
-/* DACs should rarely do this without a lot of testing */
-#define DRM_CONNECTOR_POLL_DISCONNECT (1 << 2)
-
-#define MAX_ELD_BYTES	128
-
-/**
- * struct drm_connector - central DRM connector control structure
- * @dev: parent DRM device
- * @kdev: kernel device for sysfs attributes
- * @attr: sysfs attributes
- * @head: list management
- * @base: base KMS object
- * @name: human readable name, can be overwritten by the driver
- * @connector_type: one of the DRM_MODE_CONNECTOR_<foo> types from drm_mode.h
- * @connector_type_id: index into connector type enum
- * @interlace_allowed: can this connector handle interlaced modes?
- * @doublescan_allowed: can this connector handle doublescan?
- * @stereo_allowed: can this connector handle stereo modes?
- * @registered: is this connector exposed (registered) with userspace?
- * @modes: modes available on this connector (from fill_modes() + user)
- * @status: one of the drm_connector_status enums (connected, not, or unknown)
- * @probed_modes: list of modes derived directly from the display
- * @display_info: information about attached display (e.g. from EDID)
- * @funcs: connector control functions
- * @edid_blob_ptr: DRM property containing EDID if present
- * @properties: property tracking for this connector
- * @polled: a DRM_CONNECTOR_POLL_<foo> value for core driven polling
- * @dpms: current dpms state
- * @helper_private: mid-layer private data
- * @cmdline_mode: mode line parsed from the kernel cmdline for this connector
- * @force: a DRM_FORCE_<foo> state for forced mode sets
- * @override_edid: has the EDID been overwritten through debugfs for testing?
- * @encoder_ids: valid encoders for this connector
- * @encoder: encoder driving this connector, if any
- * @eld: EDID-like data, if present
- * @dvi_dual: dual link DVI, if found
- * @max_tmds_clock: max clock rate, if found
- * @latency_present: AV delay info from ELD, if found
- * @video_latency: video latency info from ELD, if found
- * @audio_latency: audio latency info from ELD, if found
- * @null_edid_counter: track sinks that give us all zeros for the EDID
- * @bad_edid_counter: track sinks that give us an EDID with invalid checksum
- * @edid_corrupt: indicates whether the last read EDID was corrupt
- * @debugfs_entry: debugfs directory for this connector
- * @state: current atomic state for this connector
- * @has_tile: is this connector connected to a tiled monitor
- * @tile_group: tile group for the connected monitor
- * @tile_is_single_monitor: whether the tile is one monitor housing
- * @num_h_tile: number of horizontal tiles in the tile group
- * @num_v_tile: number of vertical tiles in the tile group
- * @tile_h_loc: horizontal location of this tile
- * @tile_v_loc: vertical location of this tile
- * @tile_h_size: horizontal size of this tile.
- * @tile_v_size: vertical size of this tile.
- *
- * Each connector may be connected to one or more CRTCs, or may be clonable by
- * another connector if they can share a CRTC.  Each connector also has a specific
- * position in the broader display (referred to as a 'screen' though it could
- * span multiple monitors).
- */
-struct drm_connector {
-	struct drm_device *dev;
-	struct device *kdev;
-	struct device_attribute *attr;
-	struct list_head head;
-
-	struct drm_mode_object base;
-
-	char *name;
-
-	/**
-	 * @index: Compacted connector index, which matches the position inside
-	 * the mode_config.list for drivers not supporting hot-add/removing. Can
-	 * be used as an array index. It is invariant over the lifetime of the
-	 * connector.
-	 */
-	unsigned index;
-
-	int connector_type;
-	int connector_type_id;
-	bool interlace_allowed;
-	bool doublescan_allowed;
-	bool stereo_allowed;
-	bool registered;
-	struct list_head modes; /* list of modes on this connector */
-
-	enum drm_connector_status status;
-
-	/* these are modes added by probing with DDC or the BIOS */
-	struct list_head probed_modes;
-
-	struct drm_display_info display_info;
-	const struct drm_connector_funcs *funcs;
-
-	struct drm_property_blob *edid_blob_ptr;
-	struct drm_object_properties properties;
-
-	/**
-	 * @path_blob_ptr:
-	 *
-	 * DRM blob property data for the DP MST path property.
-	 */
-	struct drm_property_blob *path_blob_ptr;
-
-	/**
-	 * @tile_blob_ptr:
-	 *
-	 * DRM blob property data for the tile property (used mostly by DP MST).
-	 * This is meant for screens which are driven through separate display
-	 * pipelines represented by &drm_crtc, which might not be running with
-	 * genlocked clocks. For tiled panels which are genlocked, like
-	 * dual-link LVDS or dual-link DSI, the driver should try to not expose
-	 * the tiling and virtualize both &drm_crtc and &drm_plane if needed.
-	 */
-	struct drm_property_blob *tile_blob_ptr;
-
-	uint8_t polled; /* DRM_CONNECTOR_POLL_* */
-
-	/* requested DPMS state */
-	int dpms;
-
-	const struct drm_connector_helper_funcs *helper_private;
-
-	/* forced on connector */
-	struct drm_cmdline_mode cmdline_mode;
-	enum drm_connector_force force;
-	bool override_edid;
-	uint32_t encoder_ids[DRM_CONNECTOR_MAX_ENCODER];
-	struct drm_encoder *encoder; /* currently active encoder */
-
-	/* EDID bits */
-	uint8_t eld[MAX_ELD_BYTES];
-	bool dvi_dual;
-	int max_tmds_clock;	/* in MHz */
-	bool latency_present[2];
-	int video_latency[2];	/* [0]: progressive, [1]: interlaced */
-	int audio_latency[2];
-	int null_edid_counter; /* needed to workaround some HW bugs where we get all 0s */
-	unsigned bad_edid_counter;
-
-	/* Flag for raw EDID header corruption - used in Displayport
-	 * compliance testing - * Displayport Link CTS Core 1.2 rev1.1 4.2.2.6
-	 */
-	bool edid_corrupt;
-
-	struct dentry *debugfs_entry;
-
-	struct drm_connector_state *state;
-
-	/* DisplayID bits */
-	bool has_tile;
-	struct drm_tile_group *tile_group;
-	bool tile_is_single_monitor;
-
-	uint8_t num_h_tile, num_v_tile;
-	uint8_t tile_h_loc, tile_v_loc;
-	uint16_t tile_h_size, tile_v_size;
-};
-
 /**
  * struct drm_plane_state - mutable plane state
  * @plane: backpointer to the plane
@@ -2615,7 +2091,6 @@ struct drm_mode_config {
 		for_each_if ((encoder_mask) & (1 << drm_encoder_index(encoder)))
 
 #define obj_to_crtc(x) container_of(x, struct drm_crtc, base)
-#define obj_to_connector(x) container_of(x, struct drm_connector, base)
 #define obj_to_encoder(x) container_of(x, struct drm_encoder, base)
 #define obj_to_mode(x) container_of(x, struct drm_display_mode, base)
 #define obj_to_fb(x) container_of(x, struct drm_framebuffer, base)
@@ -2661,19 +2136,6 @@ static inline uint32_t drm_crtc_mask(struct drm_crtc *crtc)
 	return 1 << drm_crtc_index(crtc);
 }
 
-int drm_connector_init(struct drm_device *dev,
-		       struct drm_connector *connector,
-		       const struct drm_connector_funcs *funcs,
-		       int connector_type);
-int drm_connector_register(struct drm_connector *connector);
-void drm_connector_unregister(struct drm_connector *connector);
-
-extern void drm_connector_cleanup(struct drm_connector *connector);
-static inline unsigned drm_connector_index(struct drm_connector *connector)
-{
-	return connector->index;
-}
-
 extern __printf(5, 6)
 int drm_encoder_init(struct drm_device *dev,
 		     struct drm_encoder *encoder,
@@ -2742,23 +2204,10 @@ extern int drm_crtc_force_disable_all(struct drm_device *dev);
 
 extern void drm_encoder_cleanup(struct drm_encoder *encoder);
 
-extern const char *drm_get_connector_status_name(enum drm_connector_status status);
-extern const char *drm_get_subpixel_order_name(enum subpixel_order order);
-extern const char *drm_get_dpms_name(int val);
-extern const char *drm_get_dvi_i_subconnector_name(int val);
-extern const char *drm_get_dvi_i_select_name(int val);
-extern const char *drm_get_tv_subconnector_name(int val);
-extern const char *drm_get_tv_select_name(int val);
 extern void drm_mode_config_init(struct drm_device *dev);
 extern void drm_mode_config_reset(struct drm_device *dev);
 extern void drm_mode_config_cleanup(struct drm_device *dev);
 
-extern int drm_mode_connector_set_path_property(struct drm_connector *connector,
-						const char *path);
-int drm_mode_connector_set_tile_property(struct drm_connector *connector);
-extern int drm_mode_connector_update_edid_property(struct drm_connector *connector,
-						   const struct edid *edid);
-
 extern int drm_display_info_set_bus_formats(struct drm_display_info *info,
 					    const u32 *formats,
 					    unsigned int num_formats);
@@ -2819,16 +2268,6 @@ void drm_property_unreference_blob(struct drm_property_blob *blob);
 extern void drm_property_destroy(struct drm_device *dev, struct drm_property *property);
 extern int drm_property_add_enum(struct drm_property *property, int index,
 				 uint64_t value, const char *name);
-extern int drm_mode_create_dvi_i_properties(struct drm_device *dev);
-extern int drm_mode_create_tv_properties(struct drm_device *dev,
-					 unsigned int num_modes,
-					 const char * const modes[]);
-extern int drm_mode_create_scaling_mode_property(struct drm_device *dev);
-extern int drm_mode_create_aspect_ratio_property(struct drm_device *dev);
-extern int drm_mode_create_suggested_offset_properties(struct drm_device *dev);
-
-extern int drm_mode_connector_attach_encoder(struct drm_connector *connector,
-					     struct drm_encoder *encoder);
 extern int drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,
 					 int gamma_size);
 
@@ -2888,22 +2327,6 @@ static inline struct drm_encoder *drm_encoder_find(struct drm_device *dev,
 	return mo ? obj_to_encoder(mo) : NULL;
 }
 
-/**
- * drm_connector_lookup - lookup connector object
- * @dev: DRM device
- * @id: connector object id
- *
- * This function looks up the connector object specified by id
- * add takes a reference to it.
- */
-static inline struct drm_connector *drm_connector_lookup(struct drm_device *dev,
-		uint32_t id)
-{
-	struct drm_mode_object *mo;
-	mo = drm_mode_object_find(dev, id, DRM_MODE_OBJECT_CONNECTOR);
-	return mo ? obj_to_connector(mo) : NULL;
-}
-
 static inline struct drm_property *drm_property_find(struct drm_device *dev,
 		uint32_t id)
 {
@@ -2931,28 +2354,6 @@ static inline uint32_t drm_color_lut_extract(uint32_t user_input,
 	return clamp_val(val, 0, max);
 }
 
-/**
- * drm_connector_reference - incr the connector refcnt
- * @connector: connector
- *
- * This function increments the connector's refcount.
- */
-static inline void drm_connector_reference(struct drm_connector *connector)
-{
-	drm_mode_object_reference(&connector->base);
-}
-
-/**
- * drm_connector_unreference - unref a connector
- * @connector: connector to unref
- *
- * This function decrements the connector's refcount and frees it if it drops to zero.
- */
-static inline void drm_connector_unreference(struct drm_connector *connector)
-{
-	drm_mode_object_unreference(&connector->base);
-}
-
 /* Plane list iterator for legacy (overlay only) planes. */
 #define drm_for_each_legacy_plane(plane, dev) \
 	list_for_each_entry(plane, &(dev)->mode_config.plane_list, head) \

commit adebd6fe9f0b75e5466cd6e559cd4339b037440f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Aug 12 22:48:49 2016 +0200

    drm: Export drm_property_replace_global_blob
    
    It's really part of the core blob interface, and the drm_connector.c
    extraction needs it too.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1471034937-651-13-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 0119161cad57..f4d041800551 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2808,6 +2808,12 @@ struct drm_property_blob *drm_property_create_blob(struct drm_device *dev,
                                                    const void *data);
 struct drm_property_blob *drm_property_lookup_blob(struct drm_device *dev,
                                                    uint32_t id);
+int drm_property_replace_global_blob(struct drm_device *dev,
+				     struct drm_property_blob **replace,
+				     size_t length,
+				     const void *data,
+				     struct drm_mode_object *obj_holds_id,
+				     struct drm_property *prop_holds_id);
 struct drm_property_blob *drm_property_reference_blob(struct drm_property_blob *blob);
 void drm_property_unreference_blob(struct drm_property_blob *blob);
 extern void drm_property_destroy(struct drm_device *dev, struct drm_property *property);

commit 7520a277d97be6e8a8ec038bb5ed01f40d4f9aeb
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Aug 15 16:07:02 2016 +0200

    drm: Extract drm_framebuffer.[hc]
    
    Also start with drm_modeset.h with the core bits, since we need
    to untangle this mess somehow. That allows us to move the drm_modes.h
    include to the right spot, except for the temporary connector status
    enum. That will get fixed as soon as drm_connector.h exists.
    
    v2: Rebase.
    
    v3: Move drm_crtc_force_disable_all back again, that wasn't meant to
    be moved (Sean).
    
    v4: Rebase.
    
    Cc: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 5a7809f029ba..0119161cad57 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -36,10 +36,12 @@
 #include <uapi/drm/drm_fourcc.h>
 #include <drm/drm_modeset_lock.h>
 #include <drm/drm_rect.h>
+#include <drm/drm_modeset.h>
+#include <drm/drm_framebuffer.h>
+#include <drm/drm_modes.h>
 
 struct drm_device;
 struct drm_mode_set;
-struct drm_framebuffer;
 struct drm_object_properties;
 struct drm_file;
 struct drm_clip_rect;
@@ -47,14 +49,6 @@ struct device_node;
 struct fence;
 struct edid;
 
-struct drm_mode_object {
-	uint32_t id;
-	uint32_t type;
-	struct drm_object_properties *properties;
-	struct kref refcount;
-	void (*free_cb)(struct kref *kref);
-};
-
 #define DRM_OBJECT_MAX_PROPERTY 24
 struct drm_object_properties {
 	int count, atomic_count;
@@ -94,15 +88,6 @@ static inline uint64_t I642U64(int64_t val)
 #define DRM_REFLECT_Y	BIT(5)
 #define DRM_REFLECT_MASK (DRM_REFLECT_X | DRM_REFLECT_Y)
 
-enum drm_connector_force {
-	DRM_FORCE_UNSPECIFIED,
-	DRM_FORCE_OFF,
-	DRM_FORCE_ON,         /* force on analog part normally */
-	DRM_FORCE_ON_DIGITAL, /* for DVI-I use digital connector */
-};
-
-#include <drm/drm_modes.h>
-
 enum drm_connector_status {
 	connector_status_connected = 1,
 	connector_status_disconnected = 2,
@@ -166,101 +151,6 @@ struct drm_tile_group {
 	u8 group_data[8];
 };
 
-/**
- * struct drm_framebuffer_funcs - framebuffer hooks
- */
-struct drm_framebuffer_funcs {
-	/**
-	 * @destroy:
-	 *
-	 * Clean up framebuffer resources, specifically also unreference the
-	 * backing storage. The core guarantees to call this function for every
-	 * framebuffer successfully created by ->fb_create() in
-	 * &drm_mode_config_funcs. Drivers must also call
-	 * drm_framebuffer_cleanup() to release DRM core resources for this
-	 * framebuffer.
-	 */
-	void (*destroy)(struct drm_framebuffer *framebuffer);
-
-	/**
-	 * @create_handle:
-	 *
-	 * Create a buffer handle in the driver-specific buffer manager (either
-	 * GEM or TTM) valid for the passed-in struct &drm_file. This is used by
-	 * the core to implement the GETFB IOCTL, which returns (for
-	 * sufficiently priviledged user) also a native buffer handle. This can
-	 * be used for seamless transitions between modesetting clients by
-	 * copying the current screen contents to a private buffer and blending
-	 * between that and the new contents.
-	 *
-	 * GEM based drivers should call drm_gem_handle_create() to create the
-	 * handle.
-	 *
-	 * RETURNS:
-	 *
-	 * 0 on success or a negative error code on failure.
-	 */
-	int (*create_handle)(struct drm_framebuffer *fb,
-			     struct drm_file *file_priv,
-			     unsigned int *handle);
-	/**
-	 * @dirty:
-	 *
-	 * Optional callback for the dirty fb IOCTL.
-	 *
-	 * Userspace can notify the driver via this callback that an area of the
-	 * framebuffer has changed and should be flushed to the display
-	 * hardware. This can also be used internally, e.g. by the fbdev
-	 * emulation, though that's not the case currently.
-	 *
-	 * See documentation in drm_mode.h for the struct drm_mode_fb_dirty_cmd
-	 * for more information as all the semantics and arguments have a one to
-	 * one mapping on this function.
-	 *
-	 * RETURNS:
-	 *
-	 * 0 on success or a negative error code on failure.
-	 */
-	int (*dirty)(struct drm_framebuffer *framebuffer,
-		     struct drm_file *file_priv, unsigned flags,
-		     unsigned color, struct drm_clip_rect *clips,
-		     unsigned num_clips);
-};
-
-struct drm_framebuffer {
-	struct drm_device *dev;
-	/*
-	 * Note that the fb is refcounted for the benefit of driver internals,
-	 * for example some hw, disabling a CRTC/plane is asynchronous, and
-	 * scanout does not actually complete until the next vblank.  So some
-	 * cleanup (like releasing the reference(s) on the backing GEM bo(s))
-	 * should be deferred.  In cases like this, the driver would like to
-	 * hold a ref to the fb even though it has already been removed from
-	 * userspace perspective.
-	 * The refcount is stored inside the mode object.
-	 */
-	/*
-	 * Place on the dev->mode_config.fb_list, access protected by
-	 * dev->mode_config.fb_lock.
-	 */
-	struct list_head head;
-	struct drm_mode_object base;
-	const struct drm_framebuffer_funcs *funcs;
-	unsigned int pitches[4];
-	unsigned int offsets[4];
-	uint64_t modifier[4];
-	unsigned int width;
-	unsigned int height;
-	/* depth can be 15 or 16 */
-	unsigned int depth;
-	int bits_per_pixel;
-	int flags;
-	uint32_t pixel_format; /* fourcc format */
-	int hot_x;
-	int hot_y;
-	struct list_head filp_head;
-};
-
 struct drm_property_blob {
 	struct drm_mode_object base;
 	struct drm_device *dev;
@@ -2888,14 +2778,6 @@ extern int drm_object_property_set_value(struct drm_mode_object *obj,
 extern int drm_object_property_get_value(struct drm_mode_object *obj,
 					 struct drm_property *property,
 					 uint64_t *value);
-extern int drm_framebuffer_init(struct drm_device *dev,
-				struct drm_framebuffer *fb,
-				const struct drm_framebuffer_funcs *funcs);
-extern struct drm_framebuffer *drm_framebuffer_lookup(struct drm_device *dev,
-						      uint32_t id);
-extern void drm_framebuffer_remove(struct drm_framebuffer *fb);
-extern void drm_framebuffer_cleanup(struct drm_framebuffer *fb);
-extern void drm_framebuffer_unregister_private(struct drm_framebuffer *fb);
 
 extern void drm_object_attach_property(struct drm_mode_object *obj,
 				       struct drm_property *property,
@@ -2976,11 +2858,6 @@ int drm_plane_create_zpos_immutable_property(struct drm_plane *plane,
 					     unsigned int zpos);
 
 /* Helpers */
-struct drm_mode_object *drm_mode_object_find(struct drm_device *dev,
-					     uint32_t id, uint32_t type);
-void drm_mode_object_reference(struct drm_mode_object *obj);
-void drm_mode_object_unreference(struct drm_mode_object *obj);
-
 static inline struct drm_plane *drm_plane_find(struct drm_device *dev,
 		uint32_t id)
 {
@@ -3048,39 +2925,6 @@ static inline uint32_t drm_color_lut_extract(uint32_t user_input,
 	return clamp_val(val, 0, max);
 }
 
-/**
- * drm_framebuffer_reference - incr the fb refcnt
- * @fb: framebuffer
- *
- * This functions increments the fb's refcount.
- */
-static inline void drm_framebuffer_reference(struct drm_framebuffer *fb)
-{
-	drm_mode_object_reference(&fb->base);
-}
-
-/**
- * drm_framebuffer_unreference - unref a framebuffer
- * @fb: framebuffer to unref
- *
- * This functions decrements the fb's refcount and frees it if it drops to zero.
- */
-static inline void drm_framebuffer_unreference(struct drm_framebuffer *fb)
-{
-	drm_mode_object_unreference(&fb->base);
-}
-
-/**
- * drm_framebuffer_read_refcount - read the framebuffer reference count.
- * @fb: framebuffer
- *
- * This functions returns the framebuffer's reference count.
- */
-static inline uint32_t drm_framebuffer_read_refcount(struct drm_framebuffer *fb)
-{
-	return atomic_read(&fb->base.refcount.refcount);
-}
-
 /**
  * drm_connector_reference - incr the connector refcnt
  * @connector: connector

commit 6ab10b76ff6252bd9be0849c40f5865e39a29961
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Aug 12 22:48:45 2016 +0200

    drm/kms: Nuke dirty_info property
    
    It was added way back together with the dirty_fb ioctl, but neither
    generic xfree86-modesetting nor the vmware driver use it. Everyone is
    supposed to just unconditionally call the dirtyfb when they do
    frontbuffer rendering.
    
    And since unused uabi is bad uabi (there's reasons we require open
    source userspace for everything) let's nuke this.
    
    For reference see
    
    commit 884840aa3ce3214259e69557be5b4ce0d781ffa4
    Author: Jakob Bornecrantz <jakob@vmware.com>
    Date:   Thu Dec 3 23:25:47 2009 +0000
    
        drm: Add dirty ioctl and property
    
    Cc: Jakob Bornecrantz <jakob@vmware.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Sinclair Yeh <syeh@vmware.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Acked-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1471034937-651-9-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 410175be4c6a..5a7809f029ba 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2639,12 +2639,6 @@ struct drm_mode_config {
 	 * HDMI infoframe aspect ratio setting.
 	 */
 	struct drm_property *aspect_ratio_property;
-	/**
-	 * @dirty_info_property: Optional connector property to give userspace a
-	 * hint that the DIRTY_FB ioctl should be used.
-	 */
-	struct drm_property *dirty_info_property;
-
 	/**
 	 * @degamma_lut_property: Optional CRTC property to set the LUT used to
 	 * convert the framebuffer's colors to linear gamma.
@@ -2943,7 +2937,6 @@ extern int drm_mode_create_tv_properties(struct drm_device *dev,
 					 const char * const modes[]);
 extern int drm_mode_create_scaling_mode_property(struct drm_device *dev);
 extern int drm_mode_create_aspect_ratio_property(struct drm_device *dev);
-extern int drm_mode_create_dirty_info_property(struct drm_device *dev);
 extern int drm_mode_create_suggested_offset_properties(struct drm_device *dev);
 
 extern int drm_mode_connector_attach_encoder(struct drm_connector *connector,

commit ecfd8efcf7f9ba9eadb23a98d9eb9d5586b868e7
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Aug 12 22:48:44 2016 +0200

    drm/doc: Remove outdated FIXME for the page_flip callback
    
    Since the drm_event cleanup work (as prep for fence support) drivers
    don't need to bother themselves any more with this, the drm event core
    takes care of that.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1471034937-651-8-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 194eebb2f9d7..410175be4c6a 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -547,16 +547,6 @@ struct drm_crtc_funcs {
 	 * counter and timestamp tracking though, e.g. if they have accurate
 	 * timestamp registers in hardware.
 	 *
-	 * FIXME:
-	 *
-	 * Up to that point drivers need to manage events themselves and can use
-	 * even->base.list freely for that. Specifically they need to ensure
-	 * that they don't send out page flip (or vblank) events for which the
-	 * corresponding drm file has been closed already. The drm core
-	 * unfortunately does not (yet) take care of that. Therefore drivers
-	 * currently must clean up and release pending events in their
-	 * ->preclose driver function.
-	 *
 	 * This callback is optional.
 	 *
 	 * NOTE:

commit 62cacc79398383d3ff47011557c77e71369126ca
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Aug 12 22:48:37 2016 +0200

    drm/doc: Fix more kerneldoc/sphinx warnings
    
    These are the leftovers I could only track down using keep_warnings =
    True. For some of them we might want to update our style guide on how
    to reference structures and constants, not sure ...
    
    Cc: Markus Heiser <markus.heiser@darmarit.de>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: linux-doc@vger.kernel.org
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1471034937-651-1-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b618b506b04d..194eebb2f9d7 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1197,7 +1197,7 @@ struct drm_encoder_funcs {
  * @head: list management
  * @base: base KMS object
  * @name: human readable name, can be overwritten by the driver
- * @encoder_type: one of the %DRM_MODE_ENCODER_<foo> types in drm_mode.h
+ * @encoder_type: one of the DRM_MODE_ENCODER_<foo> types in drm_mode.h
  * @possible_crtcs: bitmask of potential CRTC bindings
  * @possible_clones: bitmask of potential sibling encoders for cloning
  * @crtc: currently bound CRTC
@@ -1250,7 +1250,7 @@ struct drm_encoder {
  * @head: list management
  * @base: base KMS object
  * @name: human readable name, can be overwritten by the driver
- * @connector_type: one of the %DRM_MODE_CONNECTOR_<foo> types from drm_mode.h
+ * @connector_type: one of the DRM_MODE_CONNECTOR_<foo> types from drm_mode.h
  * @connector_type_id: index into connector type enum
  * @interlace_allowed: can this connector handle interlaced modes?
  * @doublescan_allowed: can this connector handle doublescan?
@@ -1263,11 +1263,11 @@ struct drm_encoder {
  * @funcs: connector control functions
  * @edid_blob_ptr: DRM property containing EDID if present
  * @properties: property tracking for this connector
- * @polled: a %DRM_CONNECTOR_POLL_<foo> value for core driven polling
+ * @polled: a DRM_CONNECTOR_POLL_<foo> value for core driven polling
  * @dpms: current dpms state
  * @helper_private: mid-layer private data
  * @cmdline_mode: mode line parsed from the kernel cmdline for this connector
- * @force: a %DRM_FORCE_<foo> state for forced mode sets
+ * @force: a DRM_FORCE_<foo> state for forced mode sets
  * @override_edid: has the EDID been overwritten through debugfs for testing?
  * @encoder_ids: valid encoders for this connector
  * @encoder: encoder driving this connector, if any

commit c229bfbbd04ac112bd15331d3a06d12e4e86a45c
Author: Michel Dänzer <michel.daenzer@amd.com>
Date:   Mon Aug 8 16:23:03 2016 +0900

    drm: Add page_flip_target CRTC hook v2
    
    Mostly the same as the existing page_flip hook, but takes an additional
    parameter specifying the target vertical blank period when the flip
    should take effect.
    
    v2:
    * Add curly braces around else statement corresponding to an if block
      with curly braces (Alex Deucher)
    * Call drm_crtc_vblank_put in the error case (Daniel Vetter)
    * Clarify entry point documentation comment (Daniel Vetter)
    
    Acked-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Michel Dänzer <michel.daenzer@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 44e070800b6d..3c90563e1a54 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -580,6 +580,24 @@ struct drm_crtc_funcs {
 			 struct drm_pending_vblank_event *event,
 			 uint32_t flags);
 
+	/**
+	 * @page_flip_target:
+	 *
+	 * Same as @page_flip but with an additional parameter specifying the
+	 * absolute target vertical blank period (as reported by
+	 * drm_crtc_vblank_count()) when the flip should take effect.
+	 *
+	 * Note that the core code calls drm_crtc_vblank_get before this entry
+	 * point, and will call drm_crtc_vblank_put if this entry point returns
+	 * any non-0 error code. It's the driver's responsibility to call
+	 * drm_crtc_vblank_put after this entry point returns 0, typically when
+	 * the flip completes.
+	 */
+	int (*page_flip_target)(struct drm_crtc *crtc,
+				struct drm_framebuffer *fb,
+				struct drm_pending_vblank_event *event,
+				uint32_t flags, uint32_t target);
+
 	/**
 	 * @set_property:
 	 *

commit d7da824d9edeb7d83676c11d800b8243d87eafbf
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Jul 26 19:06:57 2016 +0300

    drm: Store clipped src/dst coordinatee in drm_plane_state
    
    Pretty much all driver will have need for the clipped plane
    coordinates, so let's stuff then into drm_plane_state.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1469549224-1860-3-git-send-email-ville.syrjala@linux.intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 6c12fec20e37..b618b506b04d 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -35,6 +35,7 @@
 #include <uapi/drm/drm_mode.h>
 #include <uapi/drm/drm_fourcc.h>
 #include <drm/drm_modeset_lock.h>
+#include <drm/drm_rect.h>
 
 struct drm_device;
 struct drm_mode_set;
@@ -1415,6 +1416,9 @@ struct drm_connector {
  * @zpos: priority of the given plane on crtc (optional)
  * @normalized_zpos: normalized value of zpos: unique, range from 0 to N-1
  *	where N is the number of active planes for given crtc
+ * @src: clipped source coordinates of the plane (in 16.16)
+ * @dst: clipped destination coordinates of the plane
+ * @visible: visibility of the plane
  * @state: backpointer to global drm_atomic_state
  */
 struct drm_plane_state {
@@ -1439,6 +1443,15 @@ struct drm_plane_state {
 	unsigned int zpos;
 	unsigned int normalized_zpos;
 
+	/* Clipped coordinates */
+	struct drm_rect src, dst;
+
+	/*
+	 * Is the plane actually visible? Can be false even
+	 * if fb!=NULL and crtc!=NULL, due to clipping.
+	 */
+	bool visible;
+
 	struct drm_atomic_state *state;
 };
 

commit 31ad61e4afa53a7b2e364f7c021546fbc6ce0d85
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Fri Jul 29 08:50:05 2016 +0300

    drm: BIT(DRM_ROTATE_?) -> DRM_ROTATE_?
    
    Only property creation uses the rotation as an index, so convert the
    to figure the index when needed.
    
    v2: Use the new defines to build the _MASK defines (Sean)
    
    Cc: intel-gfx@lists.freedesktop.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: malidp@foss.arm.com
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Liviu Dudau <Liviu.Dudau@arm.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com> (v1)
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1469771405-17653-1-git-send-email-joonas.lahtinen@linux.intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 44e070800b6d..6c12fec20e37 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -83,14 +83,15 @@ static inline uint64_t I642U64(int64_t val)
  * specified amount in degrees in counter clockwise direction. DRM_REFLECT_X and
  * DRM_REFLECT_Y reflects the image along the specified axis prior to rotation
  */
-#define DRM_ROTATE_MASK 0x0f
-#define DRM_ROTATE_0	0
-#define DRM_ROTATE_90	1
-#define DRM_ROTATE_180	2
-#define DRM_ROTATE_270	3
-#define DRM_REFLECT_MASK (~DRM_ROTATE_MASK)
-#define DRM_REFLECT_X	4
-#define DRM_REFLECT_Y	5
+#define DRM_ROTATE_0	BIT(0)
+#define DRM_ROTATE_90	BIT(1)
+#define DRM_ROTATE_180	BIT(2)
+#define DRM_ROTATE_270	BIT(3)
+#define DRM_ROTATE_MASK (DRM_ROTATE_0   | DRM_ROTATE_90 | \
+			 DRM_ROTATE_180 | DRM_ROTATE_270)
+#define DRM_REFLECT_X	BIT(4)
+#define DRM_REFLECT_Y	BIT(5)
+#define DRM_REFLECT_MASK (DRM_REFLECT_X | DRM_REFLECT_Y)
 
 enum drm_connector_force {
 	DRM_FORCE_UNSPECIFIED,

commit 44d1240d006c9cd0249263b5449c8e4752500f6a
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Mon Jun 13 11:11:26 2016 +0200

    drm: add generic zpos property
    
    version 8:
    - move drm_blend.o from drm-y to drm_kms_helper-y to avoid
      EXPORT_SYMBOL(drm_atomic_helper_normalize_zpos)
    - remove dead function declarations in drm_crtc.h
    
    version 7:
    - remove useless EXPORT_SYMBOL()
    - better z-order wording in Documentation
    
    version 6:
    - add zpos in gpu documentation file
    - merge Ville patch about zpos initial value and API improvement.
      I have split Ville patch between zpos core and drivers
    
    version 5:
    - remove zpos range check and comeback to 0 to N-1
      normalization algorithm
    
    version 4:
    - make sure that normalized zpos value is stay
      in the defined property range and warn user if not
    
    This patch adds support for generic plane's zpos property property with
    well-defined semantics:
    - added zpos properties to plane and plane state structures
    - added helpers for normalizing zpos properties of given set of planes
    - well defined semantics: planes are sorted by zpos values and then plane
      id value if zpos equals
    
    Normalized zpos values are calculated automatically when generic
    muttable zpos property has been initialized. Drivers can simply use
    plane_state->normalized_zpos in their atomic_check and/or plane_update
    callbacks without any additional calls to DRM core.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    
    Compare to Marek's original patch zpos property is now specific to each
    plane and no more to the core.
    Normalize function take care of the range of per plane defined range
    before set normalized_zpos.
    
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Tested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Ville Syrjala <ville.syrjala@linux.intel.com>
    Cc: Joonyoung Shim <jy0922.shim@samsung.com>
    Cc: Seung-Woo Kim <sw0312.kim@samsung.com>
    Cc: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Cc: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Cc: Tobias Jakobi <tjakobi@math.uni-bielefeld.de>
    Cc: Gustavo Padovan <gustavo@padovan.org>
    Cc: vincent.abriou@st.com
    Cc: fabien.dessenne@st.com
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 3edeaf88ebc0..44e070800b6d 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -308,6 +308,7 @@ struct drm_plane_helper_funcs;
  * @mode_changed: crtc_state->mode or crtc_state->enable has been changed
  * @active_changed: crtc_state->active has been toggled.
  * @connectors_changed: connectors to this crtc have been updated
+ * @zpos_changed: zpos values of planes on this crtc have been updated
  * @color_mgmt_changed: color management properties have changed (degamma or
  *	gamma LUT or CSC matrix)
  * @plane_mask: bitmask of (1 << drm_plane_index(plane)) of attached planes
@@ -344,6 +345,7 @@ struct drm_crtc_state {
 	bool mode_changed : 1;
 	bool active_changed : 1;
 	bool connectors_changed : 1;
+	bool zpos_changed : 1;
 	bool color_mgmt_changed : 1;
 
 	/* attached planes bitmask:
@@ -1409,6 +1411,9 @@ struct drm_connector {
  * @src_w: width of visible portion of plane (in 16.16)
  * @src_h: height of visible portion of plane (in 16.16)
  * @rotation: rotation of the plane
+ * @zpos: priority of the given plane on crtc (optional)
+ * @normalized_zpos: normalized value of zpos: unique, range from 0 to N-1
+ *	where N is the number of active planes for given crtc
  * @state: backpointer to global drm_atomic_state
  */
 struct drm_plane_state {
@@ -1429,6 +1434,10 @@ struct drm_plane_state {
 	/* Plane rotation */
 	unsigned int rotation;
 
+	/* Plane zpos */
+	unsigned int zpos;
+	unsigned int normalized_zpos;
+
 	struct drm_atomic_state *state;
 };
 
@@ -1688,6 +1697,7 @@ enum drm_plane_type {
  * @properties: property tracking for this plane
  * @type: type of plane (overlay, primary, cursor)
  * @state: current atomic state for this plane
+ * @zpos_property: zpos property for this plane
  * @helper_private: mid-layer private data
  */
 struct drm_plane {
@@ -1732,6 +1742,8 @@ struct drm_plane {
 	const struct drm_plane_helper_funcs *helper_private;
 
 	struct drm_plane_state *state;
+
+	struct drm_property *zpos_property;
 };
 
 /**
@@ -2958,6 +2970,14 @@ extern void drm_crtc_enable_color_mgmt(struct drm_crtc *crtc,
 				       uint degamma_lut_size,
 				       bool has_ctm,
 				       uint gamma_lut_size);
+
+int drm_plane_create_zpos_property(struct drm_plane *plane,
+				   unsigned int zpos,
+				   unsigned int min, unsigned int max);
+
+int drm_plane_create_zpos_immutable_property(struct drm_plane *plane,
+					     unsigned int zpos);
+
 /* Helpers */
 struct drm_mode_object *drm_mode_object_find(struct drm_device *dev,
 					     uint32_t id, uint32_t type);

commit 6942559980c036b240c60b135a4bf23bf3252b48
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jul 19 18:25:01 2016 +0200

    drm: drm_connector->s/connector_id/index/ for consistency
    
    connector_id in the uapi actually means drm_connector->base.id, which
    is something entirely different. And ->index is also consistent with
    plane/encoder/CRTCS and the various drm_*_index() functions.
    
    While at it also improve/align the kerneldoc comment.
    
    v2: Mention where those ids are from ...
    
    v3: Add -ing to supporting and try to not break the world.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1468945501-23166-1-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f8ba5aab5d28..3edeaf88ebc0 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1246,7 +1246,6 @@ struct drm_encoder {
  * @head: list management
  * @base: base KMS object
  * @name: human readable name, can be overwritten by the driver
- * @connector_id: compacted connector id useful indexing arrays
  * @connector_type: one of the %DRM_MODE_CONNECTOR_<foo> types from drm_mode.h
  * @connector_type_id: index into connector type enum
  * @interlace_allowed: can this connector handle interlaced modes?
@@ -1303,7 +1302,15 @@ struct drm_connector {
 	struct drm_mode_object base;
 
 	char *name;
-	int connector_id;
+
+	/**
+	 * @index: Compacted connector index, which matches the position inside
+	 * the mode_config.list for drivers not supporting hot-add/removing. Can
+	 * be used as an array index. It is invariant over the lifetime of the
+	 * connector.
+	 */
+	unsigned index;
+
 	int connector_type;
 	int connector_type_id;
 	bool interlace_allowed;
@@ -2764,7 +2771,7 @@ void drm_connector_unregister(struct drm_connector *connector);
 extern void drm_connector_cleanup(struct drm_connector *connector);
 static inline unsigned drm_connector_index(struct drm_connector *connector)
 {
-	return connector->connector_id;
+	return connector->index;
 }
 
 extern __printf(5, 6)

commit 9a6bc03cd63479a40757865e5ff2e510fc2dcdb9
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jul 15 21:48:00 2016 +0200

    drm/doc: document all the properties in drm_mode_config
    
    I'm fed up with the warning noise from kernel-doc.
    
    Aside: I stumbled over dirty_info_property, which is only set by udl
    and qxl. But we have a _lot_ more drivers implementing a dirty
    callback on framebuffers. Not entirely sure what the ABI is supposed
    to be here, but it seems confusing for sure.
    
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1468612088-9721-3-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f60d34a43c5b..f8ba5aab5d28 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2348,18 +2348,8 @@ struct drm_mode_config_funcs {
  * @property_blob_list: list of all the blob property objects
  * @blob_lock: mutex for blob property allocation and management
  * @*_property: core property tracking
- * @degamma_lut_property: LUT used to convert the framebuffer's colors to linear
- *	gamma
- * @degamma_lut_size_property: size of the degamma LUT as supported by the
- *	driver (read-only)
- * @ctm_property: Matrix used to convert colors after the lookup in the
- *	degamma LUT
- * @gamma_lut_property: LUT used to convert the colors, after the CSC matrix, to
- *	the gamma space of the connected screen (read-only)
- * @gamma_lut_size_property: size of the gamma LUT as supported by the driver
  * @preferred_depth: preferred RBG pixel depth, used by fb helpers
  * @prefer_shadow: hint to userspace to prefer shadow-fb rendering
- * @async_page_flip: does this device support async flips on the primary plane?
  * @cursor_width: hint to userspace for max cursor width
  * @cursor_height: hint to userspace for max cursor height
  * @helper_private: mid-layer private data
@@ -2446,64 +2436,238 @@ struct drm_mode_config {
 
 	/* pointers to standard properties */
 	struct list_head property_blob_list;
+	/**
+	 * @edid_property: Default connector property to hold the EDID of the
+	 * currently connected sink, if any.
+	 */
 	struct drm_property *edid_property;
+	/**
+	 * @dpms_property: Default connector property to control the
+	 * connector's DPMS state.
+	 */
 	struct drm_property *dpms_property;
+	/**
+	 * @path_property: Default connector property to hold the DP MST path
+	 * for the port.
+	 */
 	struct drm_property *path_property;
+	/**
+	 * @tile_property: Default connector property to store the tile
+	 * position of a tiled screen, for sinks which need to be driven with
+	 * multiple CRTCs.
+	 */
 	struct drm_property *tile_property;
+	/**
+	 * @plane_type_property: Default plane property to differentiate
+	 * CURSOR, PRIMARY and OVERLAY legacy uses of planes.
+	 */
 	struct drm_property *plane_type_property;
+	/**
+	 * @rotation_property: Optional property for planes or CRTCs to specifiy
+	 * rotation.
+	 */
 	struct drm_property *rotation_property;
+	/**
+	 * @prop_src_x: Default atomic plane property for the plane source
+	 * position in the connected &drm_framebuffer.
+	 */
 	struct drm_property *prop_src_x;
+	/**
+	 * @prop_src_y: Default atomic plane property for the plane source
+	 * position in the connected &drm_framebuffer.
+	 */
 	struct drm_property *prop_src_y;
+	/**
+	 * @prop_src_w: Default atomic plane property for the plane source
+	 * position in the connected &drm_framebuffer.
+	 */
 	struct drm_property *prop_src_w;
+	/**
+	 * @prop_src_h: Default atomic plane property for the plane source
+	 * position in the connected &drm_framebuffer.
+	 */
 	struct drm_property *prop_src_h;
+	/**
+	 * @prop_crtc_x: Default atomic plane property for the plane destination
+	 * position in the &drm_crtc is is being shown on.
+	 */
 	struct drm_property *prop_crtc_x;
+	/**
+	 * @prop_crtc_y: Default atomic plane property for the plane destination
+	 * position in the &drm_crtc is is being shown on.
+	 */
 	struct drm_property *prop_crtc_y;
+	/**
+	 * @prop_crtc_w: Default atomic plane property for the plane destination
+	 * position in the &drm_crtc is is being shown on.
+	 */
 	struct drm_property *prop_crtc_w;
+	/**
+	 * @prop_crtc_h: Default atomic plane property for the plane destination
+	 * position in the &drm_crtc is is being shown on.
+	 */
 	struct drm_property *prop_crtc_h;
+	/**
+	 * @prop_fb_id: Default atomic plane property to specify the
+	 * &drm_framebuffer.
+	 */
 	struct drm_property *prop_fb_id;
+	/**
+	 * @prop_crtc_id: Default atomic plane property to specify the
+	 * &drm_crtc.
+	 */
 	struct drm_property *prop_crtc_id;
+	/**
+	 * @prop_active: Default atomic CRTC property to control the active
+	 * state, which is the simplified implementation for DPMS in atomic
+	 * drivers.
+	 */
 	struct drm_property *prop_active;
+	/**
+	 * @prop_mode_id: Default atomic CRTC property to set the mode for a
+	 * CRTC. A 0 mode implies that the CRTC is entirely disabled - all
+	 * connectors must be of and active must be set to disabled, too.
+	 */
 	struct drm_property *prop_mode_id;
 
-	/* DVI-I properties */
+	/**
+	 * @dvi_i_subconnector_property: Optional DVI-I property to
+	 * differentiate between analog or digital mode.
+	 */
 	struct drm_property *dvi_i_subconnector_property;
+	/**
+	 * @dvi_i_select_subconnector_property: Optional DVI-I property to
+	 * select between analog or digital mode.
+	 */
 	struct drm_property *dvi_i_select_subconnector_property;
 
-	/* TV properties */
+	/**
+	 * @tv_subconnector_property: Optional TV property to differentiate
+	 * between different TV connector types.
+	 */
 	struct drm_property *tv_subconnector_property;
+	/**
+	 * @tv_select_subconnector_property: Optional TV property to select
+	 * between different TV connector types.
+	 */
 	struct drm_property *tv_select_subconnector_property;
+	/**
+	 * @tv_mode_property: Optional TV property to select
+	 * the output TV mode.
+	 */
 	struct drm_property *tv_mode_property;
+	/**
+	 * @tv_left_margin_property: Optional TV property to set the left
+	 * margin.
+	 */
 	struct drm_property *tv_left_margin_property;
+	/**
+	 * @tv_right_margin_property: Optional TV property to set the right
+	 * margin.
+	 */
 	struct drm_property *tv_right_margin_property;
+	/**
+	 * @tv_top_margin_property: Optional TV property to set the right
+	 * margin.
+	 */
 	struct drm_property *tv_top_margin_property;
+	/**
+	 * @tv_bottom_margin_property: Optional TV property to set the right
+	 * margin.
+	 */
 	struct drm_property *tv_bottom_margin_property;
+	/**
+	 * @tv_brightness_property: Optional TV property to set the
+	 * brightness.
+	 */
 	struct drm_property *tv_brightness_property;
+	/**
+	 * @tv_contrast_property: Optional TV property to set the
+	 * contrast.
+	 */
 	struct drm_property *tv_contrast_property;
+	/**
+	 * @tv_flicker_reduction_property: Optional TV property to control the
+	 * flicker reduction mode.
+	 */
 	struct drm_property *tv_flicker_reduction_property;
+	/**
+	 * @tv_overscan_property: Optional TV property to control the overscan
+	 * setting.
+	 */
 	struct drm_property *tv_overscan_property;
+	/**
+	 * @tv_saturation_property: Optional TV property to set the
+	 * saturation.
+	 */
 	struct drm_property *tv_saturation_property;
+	/**
+	 * @tv_hue_property: Optional TV property to set the hue.
+	 */
 	struct drm_property *tv_hue_property;
 
-	/* Optional properties */
+	/**
+	 * @scaling_mode_property: Optional connector property to control the
+	 * upscaling, mostly used for built-in panels.
+	 */
 	struct drm_property *scaling_mode_property;
+	/**
+	 * @aspect_ratio_property: Optional connector property to control the
+	 * HDMI infoframe aspect ratio setting.
+	 */
 	struct drm_property *aspect_ratio_property;
+	/**
+	 * @dirty_info_property: Optional connector property to give userspace a
+	 * hint that the DIRTY_FB ioctl should be used.
+	 */
 	struct drm_property *dirty_info_property;
 
-	/* Optional color correction properties */
+	/**
+	 * @degamma_lut_property: Optional CRTC property to set the LUT used to
+	 * convert the framebuffer's colors to linear gamma.
+	 */
 	struct drm_property *degamma_lut_property;
+	/**
+	 * @degamma_lut_size_property: Optional CRTC property for the size of
+	 * the degamma LUT as supported by the driver (read-only).
+	 */
 	struct drm_property *degamma_lut_size_property;
+	/**
+	 * @ctm_property: Optional CRTC property to set the
+	 * matrix used to convert colors after the lookup in the
+	 * degamma LUT.
+	 */
 	struct drm_property *ctm_property;
+	/**
+	 * @gamma_lut_property: Optional CRTC property to set the LUT used to
+	 * convert the colors, after the CTM matrix, to the gamma space of the
+	 * connected screen.
+	 */
 	struct drm_property *gamma_lut_property;
+	/**
+	 * @gamma_lut_size_property: Optional CRTC property for the size of the
+	 * gamma LUT as supported by the driver (read-only).
+	 */
 	struct drm_property *gamma_lut_size_property;
 
-	/* properties for virtual machine layout */
+	/**
+	 * @suggested_x_property: Optional connector property with a hint for
+	 * the position of the output on the host's screen.
+	 */
 	struct drm_property *suggested_x_property;
+	/**
+	 * @suggested_y_property: Optional connector property with a hint for
+	 * the position of the output on the host's screen.
+	 */
 	struct drm_property *suggested_y_property;
 
 	/* dumb ioctl parameters */
 	uint32_t preferred_depth, prefer_shadow;
 
-	/* whether async page flip is supported or not */
+	/**
+	 * @async_page_flip: Does this device support async flips on the primary
+	 * plane?
+	 */
 	bool async_page_flip;
 
 	/**

commit 96094081ae9586b7b99373814e81788448ff127e
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jul 15 21:47:59 2016 +0200

    drm/doc: Add kerneldoc for @index
    
    Was forgotten when adding them all over. 0-day should complain about
    new missing kernel-doc, not sure why that wasn't caught/fixed.
    
    v2: Clarify that @index is invariant, as discussed with Chris Wilson.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1468612088-9721-2-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 6b9df1137818..f60d34a43c5b 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -782,7 +782,10 @@ struct drm_crtc {
 	struct drm_plane *primary;
 	struct drm_plane *cursor;
 
-	/* position inside the mode_config.list, can be used as a [] idx */
+	/**
+	 * @index: Position inside the mode_config.list, can be used as an array
+	 * index. It is invariant over the lifetime of the CRTC.
+	 */
 	unsigned index;
 
 	/* position of cursor plane on crtc */
@@ -1209,7 +1212,10 @@ struct drm_encoder {
 	char *name;
 	int encoder_type;
 
-	/* position inside the mode_config.list, can be used as a [] idx */
+	/**
+	 * @index: Position inside the mode_config.list, can be used as an array
+	 * index. It is invariant over the lifetime of the encoder.
+	 */
 	unsigned index;
 
 	uint32_t possible_crtcs;
@@ -1710,7 +1716,10 @@ struct drm_plane {
 
 	enum drm_plane_type type;
 
-	/* position inside the mode_config.list, can be used as a [] idx */
+	/**
+	 * @index: Position inside the mode_config.list, can be used as an array
+	 * index. It is invariant over the lifetime of the plane.
+	 */
 	unsigned index;
 
 	const struct drm_plane_helper_funcs *helper_private;
@@ -2318,8 +2327,6 @@ struct drm_mode_config_funcs {
  * @fb_lock: mutex to protect fb state and lists
  * @num_fb: number of fbs available
  * @fb_list: list of framebuffers available
- * @num_connector: number of connectors on this device
- * @connector_list: list of connector objects
  * @num_encoder: number of encoders on this device
  * @encoder_list: list of encoder objects
  * @num_overlay_plane: number of overlay planes on this device
@@ -2394,8 +2401,17 @@ struct drm_mode_config {
 	int num_fb;
 	struct list_head fb_list;
 
+	/**
+	 * @num_connector: Number of connectors on this device.
+	 */
 	int num_connector;
+	/**
+	 * @connector_ida: ID allocator for connector indices.
+	 */
 	struct ida connector_ida;
+	/**
+	 * @connector_list: List of connector objects.
+	 */
 	struct list_head connector_list;
 	int num_encoder;
 	struct list_head encoder_list;

commit 6100598c4a2772bfc7a7a6518a4fea377337952b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Jul 13 17:39:07 2016 +0100

    drm: Unexport drm_connector_unregister_all()
    
    This has now been removed from all drivers as it is performed centrally
    as a part of device unregistration for modesetting drivers. With the last
    user gone, we can unexport it from the DRM module. That requires us to
    move the code slightly to avoid the need for a forward declaration.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: dri-devel@lists.freedesktop.org
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1468427947-28037-2-git-send-email-chris@chris-wilson.co.uk

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 9e6ab4a0c274..6b9df1137818 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2587,9 +2587,6 @@ static inline unsigned drm_connector_index(struct drm_connector *connector)
 	return connector->connector_id;
 }
 
-/* helpers to {un}register all connectors from sysfs for device */
-extern void drm_connector_unregister_all(struct drm_device *dev);
-
 extern __printf(5, 6)
 int drm_encoder_init(struct drm_device *dev,
 		     struct drm_encoder *encoder,

commit 041401ffdf7d6e5c9ea49a86eb4410ad9c3f89fd
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jun 24 15:36:18 2016 +0100

    drm: Unexport drm_connector_register_all()
    
    This has now been removed from all drivers as it is performed centrally
    as a part of device registration for modesetting drivers. With the last
    user gone, we can unexport it from the DRM module.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1466778982-6974-1-git-send-email-chris@chris-wilson.co.uk
    Link: http://patchwork.freedesktop.org/patch/msgid/1466778982-6974-2-git-send-email-chris@chris-wilson.co.uk

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 781695c74528..9e6ab4a0c274 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2588,7 +2588,6 @@ static inline unsigned drm_connector_index(struct drm_connector *connector)
 }
 
 /* helpers to {un}register all connectors from sysfs for device */
-extern int drm_connector_register_all(struct drm_device *dev);
 extern void drm_connector_unregister_all(struct drm_device *dev);
 
 extern __printf(5, 6)

commit 6a0d95285035c43361c72776b4c618f60c0f4ab4
Author: Lukas Wunner <lukas@wunner.de>
Date:   Wed Jun 8 18:47:27 2016 +0200

    drm: Add helpers to turn off CRTCs
    
    Turning off a single CRTC or all active CRTCs of a DRM device is a
    fairly common pattern. Add helpers to avoid open coding this everywhere.
    
    The name was chosen to be consistent with drm_plane_force_disable().
    
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f5469d3a46dd..781695c74528 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2654,6 +2654,8 @@ extern struct drm_plane * drm_plane_from_index(struct drm_device *dev, int idx);
 extern void drm_plane_force_disable(struct drm_plane *plane);
 extern void drm_crtc_get_hv_timing(const struct drm_display_mode *mode,
 				   int *hdisplay, int *vdisplay);
+extern int drm_crtc_force_disable(struct drm_crtc *crtc);
+extern int drm_crtc_force_disable_all(struct drm_device *dev);
 
 extern void drm_encoder_cleanup(struct drm_encoder *encoder);
 

commit 81065548aefc0edfc18f046fa5879ff233b11c0f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jun 21 10:54:13 2016 +0200

    drm: Clean up drm_crtc.h
    
    - Group declarations for separate files (drm_bridge.c, drm_edid.c)
    - Move declarations only used within drm.ko to drm_crtc_internal.h
    - drm_property_type_valid to drm_crtc.c, its only callsite
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Emil Velikov <emil.l.velikov@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1466499262-18717-2-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b4ab33f3fb63..f5469d3a46dd 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -44,6 +44,7 @@ struct drm_file;
 struct drm_clip_rect;
 struct device_node;
 struct fence;
+struct edid;
 
 struct drm_mode_object {
 	uint32_t id;
@@ -2573,12 +2574,10 @@ static inline uint32_t drm_crtc_mask(struct drm_crtc *crtc)
 	return 1 << drm_crtc_index(crtc);
 }
 
-extern void drm_connector_ida_init(void);
-extern void drm_connector_ida_destroy(void);
-extern int drm_connector_init(struct drm_device *dev,
-			      struct drm_connector *connector,
-			      const struct drm_connector_funcs *funcs,
-			      int connector_type);
+int drm_connector_init(struct drm_device *dev,
+		       struct drm_connector *connector,
+		       const struct drm_connector_funcs *funcs,
+		       int connector_type);
 int drm_connector_register(struct drm_connector *connector);
 void drm_connector_unregister(struct drm_connector *connector);
 
@@ -2592,22 +2591,6 @@ static inline unsigned drm_connector_index(struct drm_connector *connector)
 extern int drm_connector_register_all(struct drm_device *dev);
 extern void drm_connector_unregister_all(struct drm_device *dev);
 
-extern int drm_bridge_add(struct drm_bridge *bridge);
-extern void drm_bridge_remove(struct drm_bridge *bridge);
-extern struct drm_bridge *of_drm_find_bridge(struct device_node *np);
-extern int drm_bridge_attach(struct drm_device *dev, struct drm_bridge *bridge);
-
-bool drm_bridge_mode_fixup(struct drm_bridge *bridge,
-			const struct drm_display_mode *mode,
-			struct drm_display_mode *adjusted_mode);
-void drm_bridge_disable(struct drm_bridge *bridge);
-void drm_bridge_post_disable(struct drm_bridge *bridge);
-void drm_bridge_mode_set(struct drm_bridge *bridge,
-			struct drm_display_mode *mode,
-			struct drm_display_mode *adjusted_mode);
-void drm_bridge_pre_enable(struct drm_bridge *bridge);
-void drm_bridge_enable(struct drm_bridge *bridge);
-
 extern __printf(5, 6)
 int drm_encoder_init(struct drm_device *dev,
 		     struct drm_encoder *encoder,
@@ -2669,14 +2652,8 @@ static inline unsigned int drm_plane_index(struct drm_plane *plane)
 }
 extern struct drm_plane * drm_plane_from_index(struct drm_device *dev, int idx);
 extern void drm_plane_force_disable(struct drm_plane *plane);
-extern int drm_plane_check_pixel_format(const struct drm_plane *plane,
-					u32 format);
 extern void drm_crtc_get_hv_timing(const struct drm_display_mode *mode,
 				   int *hdisplay, int *vdisplay);
-extern int drm_crtc_check_viewport(const struct drm_crtc *crtc,
-				   int x, int y,
-				   const struct drm_display_mode *mode,
-				   const struct drm_framebuffer *fb);
 
 extern void drm_encoder_cleanup(struct drm_encoder *encoder);
 
@@ -2687,16 +2664,6 @@ extern const char *drm_get_dvi_i_subconnector_name(int val);
 extern const char *drm_get_dvi_i_select_name(int val);
 extern const char *drm_get_tv_subconnector_name(int val);
 extern const char *drm_get_tv_select_name(int val);
-extern void drm_fb_release(struct drm_file *file_priv);
-extern void drm_property_destroy_user_blobs(struct drm_device *dev,
-                                            struct drm_file *file_priv);
-extern bool drm_probe_ddc(struct i2c_adapter *adapter);
-extern struct edid *drm_get_edid(struct drm_connector *connector,
-				 struct i2c_adapter *adapter);
-extern struct edid *drm_get_edid_switcheroo(struct drm_connector *connector,
-					    struct i2c_adapter *adapter);
-extern struct edid *drm_edid_duplicate(const struct edid *edid);
-extern int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid);
 extern void drm_mode_config_init(struct drm_device *dev);
 extern void drm_mode_config_reset(struct drm_device *dev);
 extern void drm_mode_config_cleanup(struct drm_device *dev);
@@ -2720,13 +2687,6 @@ static inline bool drm_property_type_is(struct drm_property *property,
 	return property->flags & type;
 }
 
-static inline bool drm_property_type_valid(struct drm_property *property)
-{
-	if (property->flags & DRM_MODE_PROP_EXTENDED_TYPE)
-		return !(property->flags & DRM_MODE_PROP_LEGACY_TYPE);
-	return !!(property->flags & DRM_MODE_PROP_LEGACY_TYPE);
-}
-
 extern int drm_object_property_set_value(struct drm_mode_object *obj,
 					 struct drm_property *property,
 					 uint64_t val);
@@ -2784,86 +2744,15 @@ extern int drm_mode_create_scaling_mode_property(struct drm_device *dev);
 extern int drm_mode_create_aspect_ratio_property(struct drm_device *dev);
 extern int drm_mode_create_dirty_info_property(struct drm_device *dev);
 extern int drm_mode_create_suggested_offset_properties(struct drm_device *dev);
-extern bool drm_property_change_valid_get(struct drm_property *property,
-					 uint64_t value, struct drm_mode_object **ref);
-extern void drm_property_change_valid_put(struct drm_property *property,
-		struct drm_mode_object *ref);
 
 extern int drm_mode_connector_attach_encoder(struct drm_connector *connector,
 					     struct drm_encoder *encoder);
 extern int drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,
 					 int gamma_size);
-extern struct drm_mode_object *drm_mode_object_find(struct drm_device *dev,
-		uint32_t id, uint32_t type);
-void drm_mode_object_reference(struct drm_mode_object *obj);
-void drm_mode_object_unreference(struct drm_mode_object *obj);
 
-/* IOCTLs */
-extern int drm_mode_getresources(struct drm_device *dev,
-				 void *data, struct drm_file *file_priv);
-extern int drm_mode_getplane_res(struct drm_device *dev, void *data,
-				   struct drm_file *file_priv);
-extern int drm_mode_getcrtc(struct drm_device *dev,
-			    void *data, struct drm_file *file_priv);
-extern int drm_mode_getconnector(struct drm_device *dev,
-			      void *data, struct drm_file *file_priv);
 extern int drm_mode_set_config_internal(struct drm_mode_set *set);
-extern int drm_mode_setcrtc(struct drm_device *dev,
-			    void *data, struct drm_file *file_priv);
-extern int drm_mode_getplane(struct drm_device *dev,
-			       void *data, struct drm_file *file_priv);
-extern int drm_mode_setplane(struct drm_device *dev,
-			       void *data, struct drm_file *file_priv);
-extern int drm_mode_cursor_ioctl(struct drm_device *dev,
-				void *data, struct drm_file *file_priv);
-extern int drm_mode_cursor2_ioctl(struct drm_device *dev,
-				void *data, struct drm_file *file_priv);
-extern int drm_mode_addfb(struct drm_device *dev,
-			  void *data, struct drm_file *file_priv);
-extern int drm_mode_addfb2(struct drm_device *dev,
-			   void *data, struct drm_file *file_priv);
+
 extern uint32_t drm_mode_legacy_fb_format(uint32_t bpp, uint32_t depth);
-extern int drm_mode_rmfb(struct drm_device *dev,
-			 void *data, struct drm_file *file_priv);
-extern int drm_mode_getfb(struct drm_device *dev,
-			  void *data, struct drm_file *file_priv);
-extern int drm_mode_dirtyfb_ioctl(struct drm_device *dev,
-				  void *data, struct drm_file *file_priv);
-
-extern int drm_mode_getproperty_ioctl(struct drm_device *dev,
-				      void *data, struct drm_file *file_priv);
-extern int drm_mode_getblob_ioctl(struct drm_device *dev,
-				  void *data, struct drm_file *file_priv);
-extern int drm_mode_createblob_ioctl(struct drm_device *dev,
-				     void *data, struct drm_file *file_priv);
-extern int drm_mode_destroyblob_ioctl(struct drm_device *dev,
-				      void *data, struct drm_file *file_priv);
-extern int drm_mode_connector_property_set_ioctl(struct drm_device *dev,
-					      void *data, struct drm_file *file_priv);
-extern int drm_mode_getencoder(struct drm_device *dev,
-			       void *data, struct drm_file *file_priv);
-extern int drm_mode_gamma_get_ioctl(struct drm_device *dev,
-				    void *data, struct drm_file *file_priv);
-extern int drm_mode_gamma_set_ioctl(struct drm_device *dev,
-				    void *data, struct drm_file *file_priv);
-extern u8 drm_match_cea_mode(const struct drm_display_mode *to_match);
-extern enum hdmi_picture_aspect drm_get_cea_aspect_ratio(const u8 video_code);
-extern bool drm_detect_hdmi_monitor(struct edid *edid);
-extern bool drm_detect_monitor_audio(struct edid *edid);
-extern bool drm_rgb_quant_range_selectable(struct edid *edid);
-extern int drm_mode_page_flip_ioctl(struct drm_device *dev,
-				    void *data, struct drm_file *file_priv);
-extern int drm_add_modes_noedid(struct drm_connector *connector,
-				int hdisplay, int vdisplay);
-extern void drm_set_preferred_mode(struct drm_connector *connector,
-				   int hpref, int vpref);
-
-extern int drm_edid_header_is_valid(const u8 *raw_edid);
-extern bool drm_edid_block_valid(u8 *raw_edid, int block, bool print_bad_edid,
-				 bool *edid_corrupt);
-extern bool drm_edid_is_valid(struct edid *edid);
-extern void drm_edid_get_monitor_name(struct edid *edid, char *name,
-				      int buflen);
 
 extern struct drm_tile_group *drm_mode_create_tile_group(struct drm_device *dev,
 							 char topology[8]);
@@ -2871,25 +2760,10 @@ extern struct drm_tile_group *drm_mode_get_tile_group(struct drm_device *dev,
 					       char topology[8]);
 extern void drm_mode_put_tile_group(struct drm_device *dev,
 				   struct drm_tile_group *tg);
-struct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,
-					   int hsize, int vsize, int fresh,
-					   bool rb);
 
-extern int drm_mode_create_dumb_ioctl(struct drm_device *dev,
-				      void *data, struct drm_file *file_priv);
-extern int drm_mode_mmap_dumb_ioctl(struct drm_device *dev,
-				    void *data, struct drm_file *file_priv);
-extern int drm_mode_destroy_dumb_ioctl(struct drm_device *dev,
-				      void *data, struct drm_file *file_priv);
-extern int drm_mode_obj_get_properties_ioctl(struct drm_device *dev, void *data,
-					     struct drm_file *file_priv);
-extern int drm_mode_obj_set_property_ioctl(struct drm_device *dev, void *data,
-					   struct drm_file *file_priv);
 extern int drm_mode_plane_set_obj_prop(struct drm_plane *plane,
 				       struct drm_property *property,
 				       uint64_t value);
-extern int drm_mode_atomic_ioctl(struct drm_device *dev,
-				 void *data, struct drm_file *file_priv);
 
 extern struct drm_property *drm_mode_create_rotation_property(struct drm_device *dev,
 							      unsigned int supported_rotations);
@@ -2900,6 +2774,10 @@ extern void drm_crtc_enable_color_mgmt(struct drm_crtc *crtc,
 				       bool has_ctm,
 				       uint gamma_lut_size);
 /* Helpers */
+struct drm_mode_object *drm_mode_object_find(struct drm_device *dev,
+					     uint32_t id, uint32_t type);
+void drm_mode_object_reference(struct drm_mode_object *obj);
+void drm_mode_object_unreference(struct drm_mode_object *obj);
 
 static inline struct drm_plane *drm_plane_find(struct drm_device *dev,
 		uint32_t id)
@@ -3065,4 +2943,50 @@ assert_drm_connector_list_read_locked(struct drm_mode_config *mode_config)
 	     &fb->head != (&(dev)->mode_config.fb_list);			\
 	     fb = list_next_entry(fb, head))
 
+/* drm_edid.c */
+bool drm_probe_ddc(struct i2c_adapter *adapter);
+struct edid *drm_get_edid(struct drm_connector *connector,
+			  struct i2c_adapter *adapter);
+struct edid *drm_get_edid_switcheroo(struct drm_connector *connector,
+				     struct i2c_adapter *adapter);
+struct edid *drm_edid_duplicate(const struct edid *edid);
+int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid);
+
+u8 drm_match_cea_mode(const struct drm_display_mode *to_match);
+enum hdmi_picture_aspect drm_get_cea_aspect_ratio(const u8 video_code);
+bool drm_detect_hdmi_monitor(struct edid *edid);
+bool drm_detect_monitor_audio(struct edid *edid);
+bool drm_rgb_quant_range_selectable(struct edid *edid);
+int drm_add_modes_noedid(struct drm_connector *connector,
+			 int hdisplay, int vdisplay);
+void drm_set_preferred_mode(struct drm_connector *connector,
+			    int hpref, int vpref);
+
+int drm_edid_header_is_valid(const u8 *raw_edid);
+bool drm_edid_block_valid(u8 *raw_edid, int block, bool print_bad_edid,
+			  bool *edid_corrupt);
+bool drm_edid_is_valid(struct edid *edid);
+void drm_edid_get_monitor_name(struct edid *edid, char *name,
+			       int buflen);
+struct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,
+					   int hsize, int vsize, int fresh,
+					   bool rb);
+
+/* drm_bridge.c */
+extern int drm_bridge_add(struct drm_bridge *bridge);
+extern void drm_bridge_remove(struct drm_bridge *bridge);
+extern struct drm_bridge *of_drm_find_bridge(struct device_node *np);
+extern int drm_bridge_attach(struct drm_device *dev, struct drm_bridge *bridge);
+
+bool drm_bridge_mode_fixup(struct drm_bridge *bridge,
+			const struct drm_display_mode *mode,
+			struct drm_display_mode *adjusted_mode);
+void drm_bridge_disable(struct drm_bridge *bridge);
+void drm_bridge_post_disable(struct drm_bridge *bridge);
+void drm_bridge_mode_set(struct drm_bridge *bridge,
+			struct drm_display_mode *mode,
+			struct drm_display_mode *adjusted_mode);
+void drm_bridge_pre_enable(struct drm_bridge *bridge);
+void drm_bridge_enable(struct drm_bridge *bridge);
+
 #endif /* __DRM_CRTC_H__ */

commit 79190ea2658a93818791335aa99969ca779161c6
Author: Benjamin Gaignard <benjamin.gaignard@linaro.org>
Date:   Tue Jun 21 16:37:09 2016 +0200

    drm: Add callbacks for late registering
    
    Like what has been done for connectors add callbacks on encoder,
    crtc and plane to let driver do actions after drm device registration.
    
    Correspondingly, add callbacks called before unregister drm device.
    
    version 2:
    add drm_modeset_register_all() and drm_modeset_unregister_all()
    to centralize all calls
    
    version 3:
    in error case unwind registers in drm_modeset_register_all
    fix uninitialed return value
    inverse order of unregistration in drm_modeset_unregister_all
    
    version 4:
    move function definitions in drm_crtc_internal.h
    remove not needed documentation
    
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1466519829-4000-1-git-send-email-benjamin.gaignard@linaro.org

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c2734979f164..b4ab33f3fb63 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -704,6 +704,32 @@ struct drm_crtc_funcs {
 				   const struct drm_crtc_state *state,
 				   struct drm_property *property,
 				   uint64_t *val);
+
+	/**
+	 * @late_register:
+	 *
+	 * This optional hook can be used to register additional userspace
+	 * interfaces attached to the crtc like debugfs interfaces.
+	 * It is called late in the driver load sequence from drm_dev_register().
+	 * Everything added from this callback should be unregistered in
+	 * the early_unregister callback.
+	 *
+	 * Returns:
+	 *
+	 * 0 on success, or a negative error code on failure.
+	 */
+	int (*late_register)(struct drm_crtc *crtc);
+
+	/**
+	 * @early_unregister:
+	 *
+	 * This optional hook should be used to unregister the additional
+	 * userspace interfaces attached to the crtc from
+	 * late_unregister(). It is called from drm_dev_unregister(),
+	 * early in the driver unload sequence to disable userspace access
+	 * before data structures are torndown.
+	 */
+	void (*early_unregister)(struct drm_crtc *crtc);
 };
 
 /**
@@ -1127,6 +1153,32 @@ struct drm_encoder_funcs {
 	 * hotplugged in DRM.
 	 */
 	void (*destroy)(struct drm_encoder *encoder);
+
+	/**
+	 * @late_register:
+	 *
+	 * This optional hook can be used to register additional userspace
+	 * interfaces attached to the encoder like debugfs interfaces.
+	 * It is called late in the driver load sequence from drm_dev_register().
+	 * Everything added from this callback should be unregistered in
+	 * the early_unregister callback.
+	 *
+	 * Returns:
+	 *
+	 * 0 on success, or a negative error code on failure.
+	 */
+	int (*late_register)(struct drm_encoder *encoder);
+
+	/**
+	 * @early_unregister:
+	 *
+	 * This optional hook should be used to unregister the additional
+	 * userspace interfaces attached to the encoder from
+	 * late_unregister(). It is called from drm_dev_unregister(),
+	 * early in the driver unload sequence to disable userspace access
+	 * before data structures are torndown.
+	 */
+	void (*early_unregister)(struct drm_encoder *encoder);
 };
 
 #define DRM_CONNECTOR_MAX_ENCODER 3
@@ -1570,6 +1622,31 @@ struct drm_plane_funcs {
 				   const struct drm_plane_state *state,
 				   struct drm_property *property,
 				   uint64_t *val);
+	/**
+	 * @late_register:
+	 *
+	 * This optional hook can be used to register additional userspace
+	 * interfaces attached to the plane like debugfs interfaces.
+	 * It is called late in the driver load sequence from drm_dev_register().
+	 * Everything added from this callback should be unregistered in
+	 * the early_unregister callback.
+	 *
+	 * Returns:
+	 *
+	 * 0 on success, or a negative error code on failure.
+	 */
+	int (*late_register)(struct drm_plane *plane);
+
+	/**
+	 * @early_unregister:
+	 *
+	 * This optional hook should be used to unregister the additional
+	 * userspace interfaces attached to the plane from
+	 * late_unregister(). It is called from drm_dev_unregister(),
+	 * early in the driver unload sequence to disable userspace access
+	 * before data structures are torndown.
+	 */
+	void (*early_unregister)(struct drm_plane *plane);
 };
 
 enum drm_plane_type {

commit 40daac6136948dc83c1dec14fe4a2444915b22df
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Jun 15 13:17:48 2016 +0100

    drm: Make drm_connector_register() safe against multiple calls
    
    Protect against drivers that may try to register the connector more
    than once, or who try to unregister it multiple times.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: dri-devel@lists.freedesktop.org
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1465993109-19523-4-git-send-email-chris@chris-wilson.co.uk

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 4cc170cfc8fd..c2734979f164 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1193,6 +1193,7 @@ struct drm_encoder {
  * @interlace_allowed: can this connector handle interlaced modes?
  * @doublescan_allowed: can this connector handle doublescan?
  * @stereo_allowed: can this connector handle stereo modes?
+ * @registered: is this connector exposed (registered) with userspace?
  * @modes: modes available on this connector (from fill_modes() + user)
  * @status: one of the drm_connector_status enums (connected, not, or unknown)
  * @probed_modes: list of modes derived directly from the display
@@ -1249,6 +1250,7 @@ struct drm_connector {
 	bool interlace_allowed;
 	bool doublescan_allowed;
 	bool stereo_allowed;
+	bool registered;
 	struct list_head modes; /* list of modes on this connector */
 
 	enum drm_connector_status status;

commit aaf285e2e0ff490e924dbcdfd08e8274c3093354
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Jun 15 13:17:47 2016 +0100

    drm: Add a callback from connector registering
    
    If a driver wants to more precisely control its initialisation and in
    particular, defer registering its interfaces with userspace until after
    everything is setup, it also needs to defer registering the connectors.
    As some devices need more work during registration, add a callback so
    that drivers can do additional work if required for a connector.
    
    Correspondingly, we also require an unregister callback.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: dri-devel@lists.freedesktop.org
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    [danvet: go ocd and remvoe unecessary empty kerneldoc line.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1465993109-19523-3-git-send-email-chris@chris-wilson.co.uk

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 914baa8c161d..4cc170cfc8fd 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -956,6 +956,33 @@ struct drm_connector_funcs {
 	int (*set_property)(struct drm_connector *connector, struct drm_property *property,
 			     uint64_t val);
 
+	/**
+	 * @late_register:
+	 *
+	 * This optional hook can be used to register additional userspace
+	 * interfaces attached to the connector, light backlight control, i2c,
+	 * DP aux or similar interfaces. It is called late in the driver load
+	 * sequence from drm_connector_register() when registering all the
+	 * core drm connector interfaces. Everything added from this callback
+	 * should be unregistered in the early_unregister callback.
+	 *
+	 * Returns:
+	 *
+	 * 0 on success, or a negative error code on failure.
+	 */
+	int (*late_register)(struct drm_connector *connector);
+
+	/**
+	 * @early_unregister:
+	 *
+	 * This optional hook should be used to unregister the additional
+	 * userspace interfaces attached to the connector from
+	 * late_unregister(). It is called from drm_connector_unregister(),
+	 * early in the driver unload sequence to disable userspace access
+	 * before data structures are torndown.
+	 */
+	void (*early_unregister)(struct drm_connector *connector);
+
 	/**
 	 * @destroy:
 	 *

commit 9f2a7950e77abf00a2a87f3b4cbefa36e9b6009b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jun 8 14:19:02 2016 +0200

    drm/atomic-helper: nonblocking commit support
    
    Design ideas:
    
    - split up the actual commit into different phases, and have
      completions for each of them. This will be useful for the future
      when we want to interleave phases much more aggressively, for e.g.
      queue depth > 1. For not it's just a minimal optimization compared
      to current common nonblocking implementation patterns from drivers,
      which all stall for the entire commit to complete, including vblank
      waits and cleanups.
    
    - Extract a separate atomic_commit_hw hook since that's the part most
      drivers will need to overwrite, hopefully allowing even more shared
      code.
    
    - Enforce EBUSY seamntics by attaching one of the completions to the
      flip_done vblank event. Side benefit of forcing atomic drivers using
      these helpers to implement event handlign at least semi-correct. I'm
      evil that way ;-)
    
    - Ridiculously modular, as usual.
    
    - The main tracking unit for a commit stays struct drm_atomic_state,
      and the ownership rules for that are unchanged. Ownership still
      gets transferred to the driver (and subsequently to the worker) on
      successful commits. What is added is a small, per-crtc, refcounted
      structure to track pending commits called struct drm_crtc_commit.
      No actual state is attached to that though, it's purely for ordering
      and waiting.
    
    - Dependencies are implicitly handled by assuming that any CRTC part
      of &drm_atomic_state is a dependency, and that the current commit
      must wait for any commits to complete on those CRTC. This way
      drivers can easily add more depencies using
      drm_atomic_get_crtc_state(), which is very natural since in most
      case a dependency exists iff there's some bit of state that needs to
      be cross checked.
    
      Removing depencies is not possible, drivers simply need to be
      careful to not include every CRTC in a commit if that's not
      necessary. Which is a good idea anyway, since that also avoids
      ww_mutex lock contention.
    
    - Queue depth > 1 sees some prep work in this patch by adding a stall
      paramater to drm_atomic_helper_swap_states(). To be able to push
      commits entirely free-standing and in a deeper queue through the
      back-end the driver must not access any obj->state pointers. This
      means we need to track the old state in drm_atomic_state (much
      easier with the consolidated arrays), and pass them all explicitly
      to driver backends (this will be serious amounts of churn).
    
      Once that's done stall can be set to false in swap_states.
    
    v2: Dont ask for flip_done signalling when the CRTC is off and stays
    off: Drivers don't handle events in that case. Instead complete right
    away. This way future commits don't need to have special-case logic,
    but can keep blocking for the flip_done completion.
    
    v3: Tons of fixes:
    - Stall for preceeding commit for real, not the current one by
      accident.
    - Add WARN_ON in case drivers don't fire the drm event.
    - Don't double-free drm events.
    
    v4: Make legacy cursor not stall.
    
    v5: Extend the helper hook to cover the entire commit tail. Some
    drivers need special code for cleanup and vblank waiting, this makes
    it a bit more useful. Inspired by the rockchip driver.
    
    v6: Add WARN_ON to catch drivers who forget to send out the
    drm event.
    
    v7: Fixup the stalls in swap_state for real!!
    
    v8:
    - Fixup trailing whitespace, spotted by Maarten.
    - Actually wait for flip_done in cleanup_done, like the comment says
      we should do. Thanks a lot for Tomeu for helping with debugging this
      on.
    
    v9: Now with awesome kerneldoc!
    
    v10: Split out drm_crtc_commit tracking infrastructure.
    
    v:
    - Add missing static (Gustavo).
    - Split out the sync functions, only do the actual nonblocking
      logic in this patch (Maarten).
    
    Cc: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Tested-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Tomeu Vizoso <tomeu.vizoso@gmail.com>
    Cc: Daniel Stone <daniels@collabora.com>
    Tested-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Testcase: igt/kms_flip/*
    Testcase: igt/kms_cursor*
    Testcase: igt/kms*plane*
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1465388359-8070-10-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 5eb1f0884848..914baa8c161d 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2248,6 +2248,7 @@ struct drm_mode_config_funcs {
  * @async_page_flip: does this device support async flips on the primary plane?
  * @cursor_width: hint to userspace for max cursor width
  * @cursor_height: hint to userspace for max cursor height
+ * @helper_private: mid-layer private data
  *
  * Core mode resource tracking structure.  All CRTC, encoders, and connectors
  * enumerated by the driver are added here, as are global properties.  Some
@@ -2391,6 +2392,8 @@ struct drm_mode_config {
 
 	/* cursor size */
 	uint32_t cursor_width, cursor_height;
+
+	struct drm_mode_config_helper_funcs *helper_private;
 };
 
 /**

commit 3b24f7d6758165919ba7b83b3c8365c38ffacc0b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jun 8 14:19:00 2016 +0200

    drm/atomic: Add struct drm_crtc_commit to track async updates
    
    Split out from my big nonblocking atomic commit helper code as prep
    work. While add it, also add some neat asciiart to document how it's
    supposed to be used.
    
    v2: Resurrect misplaced hunk in the kerneldoc.
    
    v3: Wording improvements from Liviu.
    
    Tested-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Tomeu Vizoso <tomeu.vizoso@gmail.com>
    Cc: Daniel Stone <daniels@collabora.com>
    Tested-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1465388359-8070-8-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 7bf065b61316..5eb1f0884848 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -728,9 +728,6 @@ struct drm_crtc_funcs {
  * @gamma_store: gamma ramp values
  * @helper_private: mid-layer private data
  * @properties: property tracking for this CRTC
- * @state: current atomic state for this CRTC
- * @acquire_ctx: per-CRTC implicit acquire context used by atomic drivers for
- * 	legacy IOCTLs
  *
  * Each CRTC may have one or more connectors associated with it.  This structure
  * allows the CRTC to be controlled.
@@ -787,11 +784,37 @@ struct drm_crtc {
 
 	struct drm_object_properties properties;
 
+	/**
+	 * @state:
+	 *
+	 * Current atomic state for this CRTC.
+	 */
 	struct drm_crtc_state *state;
 
-	/*
-	 * For legacy crtc IOCTLs so that atomic drivers can get at the locking
-	 * acquire context.
+	/**
+	 * @commit_list:
+	 *
+	 * List of &drm_crtc_commit structures tracking pending commits.
+	 * Protected by @commit_lock. This list doesn't hold its own full
+	 * reference, but burrows it from the ongoing commit. Commit entries
+	 * must be removed from this list once the commit is fully completed,
+	 * but before it's correspoding &drm_atomic_state gets destroyed.
+	 */
+	struct list_head commit_list;
+
+	/**
+	 * @commit_lock:
+	 *
+	 * Spinlock to protect @commit_list.
+	 */
+	spinlock_t commit_lock;
+
+	/**
+	 * @acquire_ctx:
+	 *
+	 * Per-CRTC implicit acquire context used by atomic drivers for legacy
+	 * IOCTLs, so that atomic drivers can get at the locking acquire
+	 * context.
 	 */
 	struct drm_modeset_acquire_ctx *acquire_ctx;
 };
@@ -1733,6 +1756,111 @@ struct drm_bridge {
 	void *driver_private;
 };
 
+/**
+ * struct drm_crtc_commit - track modeset commits on a CRTC
+ *
+ * This structure is used to track pending modeset changes and atomic commit on
+ * a per-CRTC basis. Since updating the list should never block this structure
+ * is reference counted to allow waiters to safely wait on an event to complete,
+ * without holding any locks.
+ *
+ * It has 3 different events in total to allow a fine-grained synchronization
+ * between outstanding updates::
+ *
+ *	atomic commit thread			hardware
+ *
+ * 	write new state into hardware	---->	...
+ * 	signal hw_done
+ * 						switch to new state on next
+ * 	...					v/hblank
+ *
+ *	wait for buffers to show up		...
+ *
+ *	...					send completion irq
+ *						irq handler signals flip_done
+ *	cleanup old buffers
+ *
+ * 	signal cleanup_done
+ *
+ * 	wait for flip_done		<----
+ * 	clean up atomic state
+ *
+ * The important bit to know is that cleanup_done is the terminal event, but the
+ * ordering between flip_done and hw_done is entirely up to the specific driver
+ * and modeset state change.
+ *
+ * For an implementation of how to use this look at
+ * drm_atomic_helper_setup_commit() from the atomic helper library.
+ */
+struct drm_crtc_commit {
+	/**
+	 * @crtc:
+	 *
+	 * DRM CRTC for this commit.
+	 */
+	struct drm_crtc *crtc;
+
+	/**
+	 * @ref:
+	 *
+	 * Reference count for this structure. Needed to allow blocking on
+	 * completions without the risk of the completion disappearing
+	 * meanwhile.
+	 */
+	struct kref ref;
+
+	/**
+	 * @flip_done:
+	 *
+	 * Will be signaled when the hardware has flipped to the new set of
+	 * buffers. Signals at the same time as when the drm event for this
+	 * commit is sent to userspace, or when an out-fence is singalled. Note
+	 * that for most hardware, in most cases this happens after @hw_done is
+	 * signalled.
+	 */
+	struct completion flip_done;
+
+	/**
+	 * @hw_done:
+	 *
+	 * Will be signalled when all hw register changes for this commit have
+	 * been written out. Especially when disabling a pipe this can be much
+	 * later than than @flip_done, since that can signal already when the
+	 * screen goes black, whereas to fully shut down a pipe more register
+	 * I/O is required.
+	 *
+	 * Note that this does not need to include separately reference-counted
+	 * resources like backing storage buffer pinning, or runtime pm
+	 * management.
+	 */
+	struct completion hw_done;
+
+	/**
+	 * @cleanup_done:
+	 *
+	 * Will be signalled after old buffers have been cleaned up by calling
+	 * drm_atomic_helper_cleanup_planes(). Since this can only happen after
+	 * a vblank wait completed it might be a bit later. This completion is
+	 * useful to throttle updates and avoid hardware updates getting ahead
+	 * of the buffer cleanup too much.
+	 */
+	struct completion cleanup_done;
+
+	/**
+	 * @commit_entry:
+	 *
+	 * Entry on the per-CRTC commit_list. Protected by crtc->commit_lock.
+	 */
+	struct list_head commit_entry;
+
+	/**
+	 * @event:
+	 *
+	 * &drm_pending_vblank_event pointer to clean up private events.
+	 */
+	struct drm_pending_vblank_event *event;
+};
+
 struct __drm_planes_state {
 	struct drm_plane *ptr;
 	struct drm_plane_state *state;
@@ -1741,6 +1869,7 @@ struct __drm_planes_state {
 struct __drm_crtcs_state {
 	struct drm_crtc *ptr;
 	struct drm_crtc_state *state;
+	struct drm_crtc_commit *commit;
 };
 
 struct __drm_connnectors_state {
@@ -1771,6 +1900,14 @@ struct drm_atomic_state {
 	struct __drm_connnectors_state *connectors;
 
 	struct drm_modeset_acquire_ctx *acquire_ctx;
+
+	/**
+	 * @commit_work:
+	 *
+	 * Work item which can be used by the driver or helpers to execute the
+	 * commit without blocking.
+	 */
+	struct work_struct commit_work;
 };
 
 

commit ae4df11a0f538b83781cf120a78dde32b0070600
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Jun 9 12:54:08 2016 +0300

    drm: Move format-related helpers to drm_fourcc.c
    
    The drm_crtc.c file is a mess, making the ABI documentation confusing
    since all functions are in the same bag. Split the format-related
    helpers to a new drm_fourcc.c file.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1465466048-2020-1-git-send-email-laurent.pinchart@ideasonboard.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 1a8d66ca677c..7bf065b61316 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2645,15 +2645,6 @@ extern int drm_mode_plane_set_obj_prop(struct drm_plane *plane,
 extern int drm_mode_atomic_ioctl(struct drm_device *dev,
 				 void *data, struct drm_file *file_priv);
 
-extern void drm_fb_get_bpp_depth(uint32_t format, unsigned int *depth,
-				 int *bpp);
-extern int drm_format_num_planes(uint32_t format);
-extern int drm_format_plane_cpp(uint32_t format, int plane);
-extern int drm_format_horz_chroma_subsampling(uint32_t format);
-extern int drm_format_vert_chroma_subsampling(uint32_t format);
-extern int drm_format_plane_width(int width, uint32_t format, int plane);
-extern int drm_format_plane_height(int height, uint32_t format, int plane);
-extern const char *drm_get_format_name(uint32_t format);
 extern struct drm_property *drm_mode_create_rotation_property(struct drm_device *dev,
 							      unsigned int supported_rotations);
 extern unsigned int drm_rotation_simplify(unsigned int rotation,

commit 3c85f20a289d044f303f473ee6ab7502303fc3b0
Merge: 76c6dccf3441 492a426a2fc5
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jun 9 12:20:11 2016 +1000

    Merge tag 'omapdrm-4.8' of git://git.kernel.org/pub/scm/linux/kernel/git/tomba/linux into drm-next
    
    omapdrm changes for 4.8
    
    * Update MAINTAINERS file for omapdrm and tilcdc
    * PLL refactoring to allow versatile use of the PLL clocks
    * Public omapdss header refactoring to separate omapfb and omapdrm
    * Gamma table support
    * Support reset GPIO and vcc regulator in omapdrm's panel-dpi
    * Minor cleanups
    
    * tag 'omapdrm-4.8' of git://git.kernel.org/pub/scm/linux/kernel/git/tomba/linux: (69 commits)
      drm/omapdrm: Implement gamma_lut atomic crtc properties
      drm/omapdrm: Workaround for errata i734 (LCD1 Gamma) in DSS dispc
      drm/omapdrm: Add gamma table support to DSS dispc
      drm: drm_helper_crtc_enable_color_mgmt() => drm_crtc_enable_color_mgmt()
      drm/omap: rename panel/encoder Kconfig names
      drm: omapdrm: add DSI mapping
      drm: omapdrm: Remove unused omap_framebuffer_bo function
      drm: omapdrm: Remove unused omap_gem_tiled_size function
      drm: omapdrm: panel-lgphilips-lb035q02: Remove unused backlight GPIO
      drm/omap: panel-dpi: implement support for a vcc regulator
      drm/omap: panel-dpi: make (limited) use of a reset gpio
      devicetree/bindings: add reset-gpios and vcc-supply for panel-dpi
      MAINTAINERS: Add maintainer for TI LCDC DRM driver
      MAINTAINERS: Add maintainer for OMAP DRM driver
      drm/omap: fix pitch round-up
      drm/omap: remove align_pitch()
      drm/omap: remove unnecessary pitch round-up
      drm/omap: remove unneeded gpio includes
      drm/omap: Remove the video/omapdss.h and move it's content to local header file
      [media] omap_vout: Switch to use the video/omapfb_dss.h header file
      ...

commit 76c6dccf34413ca460372fde027bedcdc2f59f86
Merge: 5b735940aa11 0062795e3069
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jun 9 12:14:24 2016 +1000

    Merge branch 'virtio-gpu-for-airlied' of git://git.kraxel.org/linux into drm-next
    
    Virtio-gpu updates
    
    * 'virtio-gpu-for-airlied' of git://git.kraxel.org/linux:
      virtio-gpu: use src not crtc
      virtio-gpu: pick up hotspot from framebuffer
      add cursor hotspot to drm_framebuffer
      virtio-gpu: switch to atomic cursor interfaces
      virtio-gpu: add atomic_commit function
      virtio-gpu: fix output lookup

commit f8ed34ac7b453296cf36d6eb7ae911de353e1351
Author: Jyri Sarha <jsarha@ti.com>
Date:   Tue Jun 7 15:09:14 2016 +0300

    drm: drm_helper_crtc_enable_color_mgmt() => drm_crtc_enable_color_mgmt()
    
    Add drm_crtc_enable_color_mgmt(), remove drm_helper_crtc_enable_color_mgmt()
    and update drm/i915-driver (the only user of the old function).
    
    The new function is more flexible. It allows driver to enable only the
    features it has without forcing to enable all three color management
    properties: degamma lut, csc matrix (ctm), and gamma lut.
    
    Suggested-by: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index d1559cd04e3d..36d3bbf9ea75 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2553,7 +2553,10 @@ extern struct drm_property *drm_mode_create_rotation_property(struct drm_device
 							      unsigned int supported_rotations);
 extern unsigned int drm_rotation_simplify(unsigned int rotation,
 					  unsigned int supported_rotations);
-
+extern void drm_crtc_enable_color_mgmt(struct drm_crtc *crtc,
+				       uint degamma_lut_size,
+				       bool has_ctm,
+				       uint gamma_lut_size);
 /* Helpers */
 
 static inline struct drm_plane *drm_plane_find(struct drm_device *dev,

commit 7ea7728387820a21a89a7c3845dbe60926f82dc4
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Tue Jun 7 12:49:30 2016 +0200

    drm/core: Change declaration for gamma_set.
    
    Change return value to int to propagate errors from gamma_set,
    and remove start parameter. Updates always use the full size,
    and some drivers even ignore the start parameter altogether.
    
    This is needed for atomic drivers, where an atomic commit can
    fail with -EINTR or -ENOMEM and should be restarted. This is already
    and issue for drm_atomic_helper_legacy_set_gamma, which this patch
    fixes up.
    
    Changes since v1:
    - Fix compiler warning. (Emil)
    - Fix commit message (Daniel)
    
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: Christian König <christian.koenig@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Patrik Jakobsson <patrik.r.jakobsson@gmail.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: VMware Graphics <linux-graphics-maintainer@vmware.com>
    Cc: Mathieu Larouche <mathieu.larouche@matrox.com>
    Cc: Thierry Reding <treding@nvidia.com>
    Acked-by: Patrik Jakobsson <patrik.r.jakobsson@gmail.com>
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    [danvet: Improve commit message a bit more, mention that this fixes
    the helper.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/742944bc-9f41-1acb-df4f-0fd4c8a10168@linux.intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f59d8a2d8920..411be4f45506 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -479,8 +479,8 @@ struct drm_crtc_funcs {
 	 * going on, which should eventually be unified to just one set of
 	 * hooks.
 	 */
-	void (*gamma_set)(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,
-			  uint32_t start, uint32_t size);
+	int (*gamma_set)(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,
+			 uint32_t size);
 
 	/**
 	 * @destroy:

commit dd5465910740ad74a318cf7464dad1136a2e0ca9
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Tue May 31 08:54:52 2016 +0200

    add cursor hotspot to drm_framebuffer
    
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index d1559cd04e3d..1460f660bf96 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -253,6 +253,8 @@ struct drm_framebuffer {
 	int bits_per_pixel;
 	int flags;
 	uint32_t pixel_format; /* fourcc format */
+	int hot_x;
+	int hot_y;
 	struct list_head filp_head;
 };
 

commit ac3ba4a5968e4a009898504926220395c44f5ecb
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue May 31 23:11:10 2016 +0200

    drm/doc: Update kerneldoc for drm_crtc.h
    
    Apparently not everyone has been super dutiful with updating this
    stuff.
    
    I still decided to leave out the documentation for all the *_property
    pointers we have in drm_mode_config.
    
    v2: Feedback from Liviu.
    
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index e690021ce4cc..f59d8a2d8920 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -314,6 +314,7 @@ struct drm_plane_helper_funcs;
  * 	update to ensure framebuffer cleanup isn't done too early
  * @adjusted_mode: for use by helpers and drivers to compute adjusted mode timings
  * @mode: current mode timings
+ * @mode_blob: &drm_property_blob for @mode
  * @degamma_lut: Lookup table for converting framebuffer pixel data
  *	before apply the conversion matrix
  * @ctm: Transformation matrix
@@ -708,6 +709,7 @@ struct drm_crtc_funcs {
  * @dev: parent DRM device
  * @port: OF node used by drm_of_find_possible_crtcs()
  * @head: list management
+ * @name: human readable name, can be overwritten by the driver
  * @mutex: per-CRTC locking
  * @base: base KMS object for ID tracking etc.
  * @primary: primary plane for this CRTC
@@ -738,12 +740,13 @@ struct drm_crtc {
 
 	char *name;
 
-	/*
-	 * crtc mutex
+	/**
+	 * @mutex:
 	 *
 	 * This provides a read lock for the overall crtc state (mode, dpms
 	 * state, ...) and a write lock for everything which can be update
-	 * without a full modeset (fb, cursor data, ...)
+	 * without a full modeset (fb, cursor data, crtc properties ...). Full
+	 * modeset also need to grab dev->mode_config.connection_mutex.
 	 */
 	struct drm_modeset_lock mutex;
 
@@ -1081,7 +1084,7 @@ struct drm_encoder_funcs {
  * @dev: parent DRM device
  * @head: list management
  * @base: base KMS object
- * @name: encoder name
+ * @name: human readable name, can be overwritten by the driver
  * @encoder_type: one of the %DRM_MODE_ENCODER_<foo> types in drm_mode.h
  * @possible_crtcs: bitmask of potential CRTC bindings
  * @possible_clones: bitmask of potential sibling encoders for cloning
@@ -1131,7 +1134,8 @@ struct drm_encoder {
  * @attr: sysfs attributes
  * @head: list management
  * @base: base KMS object
- * @name: connector name
+ * @name: human readable name, can be overwritten by the driver
+ * @connector_id: compacted connector id useful indexing arrays
  * @connector_type: one of the %DRM_MODE_CONNECTOR_<foo> types from drm_mode.h
  * @connector_type_id: index into connector type enum
  * @interlace_allowed: can this connector handle interlaced modes?
@@ -1144,7 +1148,6 @@ struct drm_encoder {
  * @funcs: connector control functions
  * @edid_blob_ptr: DRM property containing EDID if present
  * @properties: property tracking for this connector
- * @path_blob_ptr: DRM blob property data for the DP MST path property
  * @polled: a %DRM_CONNECTOR_POLL_<foo> value for core driven polling
  * @dpms: current dpms state
  * @helper_private: mid-layer private data
@@ -1207,8 +1210,23 @@ struct drm_connector {
 	struct drm_property_blob *edid_blob_ptr;
 	struct drm_object_properties properties;
 
+	/**
+	 * @path_blob_ptr:
+	 *
+	 * DRM blob property data for the DP MST path property.
+	 */
 	struct drm_property_blob *path_blob_ptr;
 
+	/**
+	 * @tile_blob_ptr:
+	 *
+	 * DRM blob property data for the tile property (used mostly by DP MST).
+	 * This is meant for screens which are driven through separate display
+	 * pipelines represented by &drm_crtc, which might not be running with
+	 * genlocked clocks. For tiled panels which are genlocked, like
+	 * dual-link LVDS or dual-link DSI, the driver should try to not expose
+	 * the tiling and virtualize both &drm_crtc and &drm_plane if needed.
+	 */
 	struct drm_property_blob *tile_blob_ptr;
 
 	uint8_t polled; /* DRM_CONNECTOR_POLL_* */
@@ -1270,6 +1288,7 @@ struct drm_connector {
  *	plane (in 16.16)
  * @src_w: width of visible portion of plane (in 16.16)
  * @src_h: height of visible portion of plane (in 16.16)
+ * @rotation: rotation of the plane
  * @state: backpointer to global drm_atomic_state
  */
 struct drm_plane_state {
@@ -1510,6 +1529,7 @@ enum drm_plane_type {
  * struct drm_plane - central DRM plane control structure
  * @dev: DRM device this plane belongs to
  * @head: for list management
+ * @name: human readable name, can be overwritten by the driver
  * @base: base mode object
  * @possible_crtcs: pipes this plane can be bound to
  * @format_types: array of formats supported by this plane
@@ -1523,6 +1543,7 @@ enum drm_plane_type {
  * @properties: property tracking for this plane
  * @type: type of plane (overlay, primary, cursor)
  * @state: current atomic state for this plane
+ * @helper_private: mid-layer private data
  */
 struct drm_plane {
 	struct drm_device *dev;
@@ -1530,6 +1551,13 @@ struct drm_plane {
 
 	char *name;
 
+	/**
+	 * @mutex:
+	 *
+	 * Protects modeset plane state, together with the mutex of &drm_crtc
+	 * this plane is linked to (when active, getting actived or getting
+	 * disabled).
+	 */
 	struct drm_modeset_lock mutex;
 
 	struct drm_mode_object base;
@@ -1726,7 +1754,6 @@ struct __drm_connnectors_state {
  * @legacy_set_config: Disable conflicting encoders instead of failing with -EINVAL.
  * @planes: pointer to array of structures with per-plane data
  * @crtcs: pointer to array of CRTC pointers
- * @crtc_states: pointer to array of CRTC states pointers
  * @num_connector: size of the @connectors and @connector_states arrays
  * @connectors: pointer to array of structures with per-connector data
  * @acquire_ctx: acquire context for this atomic modeset state update
@@ -2042,8 +2069,6 @@ struct drm_mode_config_funcs {
  * @connection_mutex: ww mutex protecting connector state and routing
  * @acquire_ctx: global implicit acquire context used by atomic drivers for
  * 	legacy IOCTLs
- * @idr_mutex: mutex for KMS ID allocation and management
- * @crtc_idr: main KMS ID tracking object
  * @fb_lock: mutex to protect fb state and lists
  * @num_fb: number of fbs available
  * @fb_list: list of framebuffers available
@@ -2065,6 +2090,7 @@ struct drm_mode_config_funcs {
  * @fb_base: base address of the framebuffer
  * @poll_enabled: track polling support for this device
  * @poll_running: track polling status for this device
+ * @delayed_event: track delayed poll uevent deliver for this device
  * @output_poll_work: delayed work for polling in process context
  * @property_blob_list: list of all the blob property objects
  * @blob_lock: mutex for blob property allocation and management
@@ -2092,10 +2118,30 @@ struct drm_mode_config {
 	struct mutex mutex; /* protects configuration (mode lists etc.) */
 	struct drm_modeset_lock connection_mutex; /* protects connector->encoder and encoder->crtc links */
 	struct drm_modeset_acquire_ctx *acquire_ctx; /* for legacy _lock_all() / _unlock_all() */
-	struct mutex idr_mutex; /* for IDR management */
-	struct idr crtc_idr; /* use this idr for all IDs, fb, crtc, connector, modes - just makes life easier */
-	struct idr tile_idr; /* use this idr for all IDs, fb, crtc, connector, modes - just makes life easier */
-	/* this is limited to one for now */
+
+	/**
+	 * @idr_mutex:
+	 *
+	 * Mutex for KMS ID allocation and management. Protects both @crtc_idr
+	 * and @tile_idr.
+	 */
+	struct mutex idr_mutex;
+
+	/**
+	 * @crtc_idr:
+	 *
+	 * Main KMS ID tracking object. Use this idr for all IDs, fb, crtc,
+	 * connector, modes - just makes life easier to have only one.
+	 */
+	struct idr crtc_idr;
+
+	/**
+	 * @tile_idr:
+	 *
+	 * Use this idr for allocating new IDs for tiled sinks like use in some
+	 * high-res DP MST screens.
+	 */
+	struct idr tile_idr;
 
 	struct mutex fb_lock; /* proctects global and per-file fb lists */
 	int num_fb;
@@ -2197,7 +2243,11 @@ struct drm_mode_config {
 	/* whether async page flip is supported or not */
 	bool async_page_flip;
 
-	/* whether the driver supports fb modifiers */
+	/**
+	 * @allow_fb_modifiers:
+	 *
+	 * Whether the driver supports fb modifiers in the ADDFB2.1 ioctl call.
+	 */
 	bool allow_fb_modifiers;
 
 	/* cursor size */

commit 490d3d1b91201fd3d3d01d64e11df4eac1d92bd4
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri May 27 20:05:00 2016 +0100

    drm: Store the plane's index
    
    Currently the plane's index is determined by walking the list of all
    planes in the mode and finding the position of that plane in the list. A
    linear walk, especially a linear walk within a linear walk as frequently
    conceived by i915.ko [O(N^2)] quickly comes to dominate profiles.
    
    The plane's index is constant for as long as no earlier planes are
    removed from the list. For all drivers, planes are static, determined
    at boot and then untouched until shutdown. In fact, there is no locking
    provided to allow for dynamic removal of planes/encoders/crtcs.
    
    v2: Convert drm_crtc_index() and drm_encoder_index() as well.
    v3: Stop adjusting the indices upon removal; consider the list
    construct-only.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Matt Roper <matthew.d.roper@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    [danvet: Fixup typo in kerneldoc that Matt spotted.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1464375900-2542-1-git-send-email-chris@chris-wilson.co.uk

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 07a410144b07..e690021ce4cc 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -753,6 +753,9 @@ struct drm_crtc {
 	struct drm_plane *primary;
 	struct drm_plane *cursor;
 
+	/* position inside the mode_config.list, can be used as a [] idx */
+	unsigned index;
+
 	/* position of cursor plane on crtc */
 	int cursor_x;
 	int cursor_y;
@@ -1097,6 +1100,10 @@ struct drm_encoder {
 	struct drm_mode_object base;
 	char *name;
 	int encoder_type;
+
+	/* position inside the mode_config.list, can be used as a [] idx */
+	unsigned index;
+
 	uint32_t possible_crtcs;
 	uint32_t possible_clones;
 
@@ -1543,6 +1550,9 @@ struct drm_plane {
 
 	enum drm_plane_type type;
 
+	/* position inside the mode_config.list, can be used as a [] idx */
+	unsigned index;
+
 	const struct drm_plane_helper_funcs *helper_private;
 
 	struct drm_plane_state *state;
@@ -2240,7 +2250,18 @@ int drm_crtc_init_with_planes(struct drm_device *dev,
 			      const struct drm_crtc_funcs *funcs,
 			      const char *name, ...);
 extern void drm_crtc_cleanup(struct drm_crtc *crtc);
-extern unsigned int drm_crtc_index(struct drm_crtc *crtc);
+
+/**
+ * drm_crtc_index - find the index of a registered CRTC
+ * @crtc: CRTC to find index for
+ *
+ * Given a registered CRTC, return the index of that CRTC within a DRM
+ * device's list of CRTCs.
+ */
+static inline unsigned int drm_crtc_index(struct drm_crtc *crtc)
+{
+	return crtc->index;
+}
 
 /**
  * drm_crtc_mask - find the mask of a registered CRTC
@@ -2294,7 +2315,18 @@ int drm_encoder_init(struct drm_device *dev,
 		     struct drm_encoder *encoder,
 		     const struct drm_encoder_funcs *funcs,
 		     int encoder_type, const char *name, ...);
-extern unsigned int drm_encoder_index(struct drm_encoder *encoder);
+
+/**
+ * drm_encoder_index - find the index of a registered encoder
+ * @encoder: encoder to find index for
+ *
+ * Given a registered encoder, return the index of that encoder within a DRM
+ * device's list of encoders.
+ */
+static inline unsigned int drm_encoder_index(struct drm_encoder *encoder)
+{
+	return encoder->index;
+}
 
 /**
  * drm_encoder_crtc_ok - can a given crtc drive a given encoder?
@@ -2325,7 +2357,18 @@ extern int drm_plane_init(struct drm_device *dev,
 			  const uint32_t *formats, unsigned int format_count,
 			  bool is_primary);
 extern void drm_plane_cleanup(struct drm_plane *plane);
-extern unsigned int drm_plane_index(struct drm_plane *plane);
+
+/**
+ * drm_plane_index - find the index of a registered plane
+ * @plane: plane to find index for
+ *
+ * Given a registered plane, return the index of that plane within a DRM
+ * device's list of planes.
+ */
+static inline unsigned int drm_plane_index(struct drm_plane *plane)
+{
+	return plane->index;
+}
 extern struct drm_plane * drm_plane_from_index(struct drm_device *dev, int idx);
 extern void drm_plane_force_disable(struct drm_plane *plane);
 extern int drm_plane_check_pixel_format(const struct drm_plane *plane,

commit 5d943aa6c0d424f4d4a1c96fb2fa2a81e55e1e85
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jun 2 00:06:34 2016 +0200

    drm: Consolidate crtc arrays in drm_atomic_state
    
    It's silly to have 2 mallocs when we could tie these two together.
    
    Also, Gustavo adds another one in his per-crtc out-fence patches. And
    I want to add more stuff here for nonblocking commit helpers.
    
    In the future we can use this to store a pointer to the preceeding
    state, making an atomic update entirely free-standing. This will be
    needed to be able to queue them up with a depth > 1.
    
    Cc: Gustavo Padovan <gustavo@padovan.org>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1464818821-5736-12-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 821398ce52d0..07a410144b07 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1698,6 +1698,11 @@ struct __drm_planes_state {
 	struct drm_plane_state *state;
 };
 
+struct __drm_crtcs_state {
+	struct drm_crtc *ptr;
+	struct drm_crtc_state *state;
+};
+
 struct __drm_connnectors_state {
 	struct drm_connector *ptr;
 	struct drm_connector_state *state;
@@ -1722,8 +1727,7 @@ struct drm_atomic_state {
 	bool legacy_cursor_update : 1;
 	bool legacy_set_config : 1;
 	struct __drm_planes_state *planes;
-	struct drm_crtc **crtcs;
-	struct drm_crtc_state **crtc_states;
+	struct __drm_crtcs_state *crtcs;
 	int num_connector;
 	struct __drm_connnectors_state *connectors;
 

commit b8b5342b699b9b3d1b3455861a68b96424146959
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jun 2 00:06:33 2016 +0200

    drm: Consolidate plane arrays in drm_atomic_state
    
    It's kinda pointless to have 2 separate mallocs for these. And when we
    add more per-plane state in the future it's even more pointless.
    
    Right now there's no such thing planned, but both Gustavo's per-crtc
    fence patches, and some nonblocking commit helpers I'm playing around
    with will add more per-crtc stuff. It makes sense to also consolidate
    planes, just for consistency.
    
    In the future we can use this to store a pointer to the preceeding
    state, making an atomic update entirely free-standing. This will be
    needed to be able to queue them up with a depth > 1.
    
    Cc: Gustavo Padovan <gustavo@padovan.org>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1464818821-5736-11-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 751990a3bc7a..821398ce52d0 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1693,6 +1693,11 @@ struct drm_bridge {
 	void *driver_private;
 };
 
+struct __drm_planes_state {
+	struct drm_plane *ptr;
+	struct drm_plane_state *state;
+};
+
 struct __drm_connnectors_state {
 	struct drm_connector *ptr;
 	struct drm_connector_state *state;
@@ -1704,8 +1709,7 @@ struct __drm_connnectors_state {
  * @allow_modeset: allow full modeset
  * @legacy_cursor_update: hint to enforce legacy cursor IOCTL semantics
  * @legacy_set_config: Disable conflicting encoders instead of failing with -EINVAL.
- * @planes: pointer to array of plane pointers
- * @plane_states: pointer to array of plane states pointers
+ * @planes: pointer to array of structures with per-plane data
  * @crtcs: pointer to array of CRTC pointers
  * @crtc_states: pointer to array of CRTC states pointers
  * @num_connector: size of the @connectors and @connector_states arrays
@@ -1717,8 +1721,7 @@ struct drm_atomic_state {
 	bool allow_modeset : 1;
 	bool legacy_cursor_update : 1;
 	bool legacy_set_config : 1;
-	struct drm_plane **planes;
-	struct drm_plane_state **plane_states;
+	struct __drm_planes_state *planes;
 	struct drm_crtc **crtcs;
 	struct drm_crtc_state **crtc_states;
 	int num_connector;

commit 63e83c1dba5490de84c2d558a2425730db7fb134
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jun 2 00:06:32 2016 +0200

    drm: Consolidate connector arrays in drm_atomic_state
    
    It's kinda pointless to have 2 separate mallocs for these. And when we
    add more per-connector state in the future it's even more pointless.
    
    Right now there's no such thing planned, but both Gustavo's per-crtc
    fence patches, and some nonblocking commit helpers I'm playing around
    with will add more per-crtc stuff. It makes sense to also consolidate
    connectors, just for consistency.
    
    In the future we can use this to store a pointer to the preceeding
    state, making an atomic update entirely free-standing. This will be
    needed to be able to queue them up with a depth > 1.
    
    Cc: Gustavo Padovan <gustavo@padovan.org>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1464818821-5736-10-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index d1559cd04e3d..751990a3bc7a 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1693,6 +1693,11 @@ struct drm_bridge {
 	void *driver_private;
 };
 
+struct __drm_connnectors_state {
+	struct drm_connector *ptr;
+	struct drm_connector_state *state;
+};
+
 /**
  * struct drm_atomic_state - the global state object for atomic updates
  * @dev: parent DRM device
@@ -1704,8 +1709,7 @@ struct drm_bridge {
  * @crtcs: pointer to array of CRTC pointers
  * @crtc_states: pointer to array of CRTC states pointers
  * @num_connector: size of the @connectors and @connector_states arrays
- * @connectors: pointer to array of connector pointers
- * @connector_states: pointer to array of connector states pointers
+ * @connectors: pointer to array of structures with per-connector data
  * @acquire_ctx: acquire context for this atomic modeset state update
  */
 struct drm_atomic_state {
@@ -1718,8 +1722,7 @@ struct drm_atomic_state {
 	struct drm_crtc **crtcs;
 	struct drm_crtc_state **crtc_states;
 	int num_connector;
-	struct drm_connector **connectors;
-	struct drm_connector_state **connector_states;
+	struct __drm_connnectors_state *connectors;
 
 	struct drm_modeset_acquire_ctx *acquire_ctx;
 };

commit f0aa08387b92e432166d7143993da2635c8821e8
Author: Stefan Agner <stefan@agner.ch>
Date:   Mon Feb 8 11:38:14 2016 -0800

    drm: introduce bus_flags in drm_display_info
    
    Introduce bus_flags to specify display bus properties like signal
    polarities. This is useful for parallel display buses, e.g. to
    specify the pixel clock or data enable polarity.
    
    Suggested-by: Thierry Reding <thierry.reding@gmail.com>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Manfred Schlaegl <manfred.schlaegl@gmx.at>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Stefan Agner <stefan@agner.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 4acdaf5e283d..d1559cd04e3d 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -118,6 +118,14 @@ enum subpixel_order {
 #define DRM_COLOR_FORMAT_RGB444		(1<<0)
 #define DRM_COLOR_FORMAT_YCRCB444	(1<<1)
 #define DRM_COLOR_FORMAT_YCRCB422	(1<<2)
+
+#define DRM_BUS_FLAG_DE_LOW		(1<<0)
+#define DRM_BUS_FLAG_DE_HIGH		(1<<1)
+/* drive data on pos. edge */
+#define DRM_BUS_FLAG_PIXDATA_POSEDGE	(1<<2)
+/* drive data on neg. edge */
+#define DRM_BUS_FLAG_PIXDATA_NEGEDGE	(1<<3)
+
 /*
  * Describes a given display (e.g. CRT or flat panel) and its limitations.
  */
@@ -139,6 +147,7 @@ struct drm_display_info {
 
 	const u32 *bus_formats;
 	unsigned int num_bus_formats;
+	u32 bus_flags;
 
 	/* Mask of supported hdmi deep color modes */
 	u8 edid_hdmi_dc_modes;

commit b164d31f50b2923a7a92c2a40cb46973a6ba8c36
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Apr 27 11:10:09 2016 +1000

    drm/modes: add connector reference counting. (v2)
    
    This uses the previous changes to add reference counts
    to drm connector objects.
    
    v2: move fbdev changes to their own patch.
    add some kerneldoc
    
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Daniel Stone <daniels@collabora.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 0cc1eb7b4fd2..4acdaf5e283d 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2571,7 +2571,15 @@ static inline struct drm_encoder *drm_encoder_find(struct drm_device *dev,
 	return mo ? obj_to_encoder(mo) : NULL;
 }
 
-static inline struct drm_connector *drm_connector_find(struct drm_device *dev,
+/**
+ * drm_connector_lookup - lookup connector object
+ * @dev: DRM device
+ * @id: connector object id
+ *
+ * This function looks up the connector object specified by id
+ * add takes a reference to it.
+ */
+static inline struct drm_connector *drm_connector_lookup(struct drm_device *dev,
 		uint32_t id)
 {
 	struct drm_mode_object *mo;
@@ -2639,6 +2647,28 @@ static inline uint32_t drm_framebuffer_read_refcount(struct drm_framebuffer *fb)
 	return atomic_read(&fb->base.refcount.refcount);
 }
 
+/**
+ * drm_connector_reference - incr the connector refcnt
+ * @connector: connector
+ *
+ * This function increments the connector's refcount.
+ */
+static inline void drm_connector_reference(struct drm_connector *connector)
+{
+	drm_mode_object_reference(&connector->base);
+}
+
+/**
+ * drm_connector_unreference - unref a connector
+ * @connector: connector to unref
+ *
+ * This function decrements the connector's refcount and frees it if it drops to zero.
+ */
+static inline void drm_connector_unreference(struct drm_connector *connector)
+{
+	drm_mode_object_unreference(&connector->base);
+}
+
 /* Plane list iterator for legacy (overlay only) planes. */
 #define drm_for_each_legacy_plane(plane, dev) \
 	list_for_each_entry(plane, &(dev)->mode_config.plane_list, head) \

commit e76d399f21f3fd20c470233af73cab2e5307d566
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue May 3 10:17:52 2016 +1000

    drm/fb: fix missing /** in kerneldoc comment.
    
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Daniel Stone <daniels@collabora.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 2f2bf23d9675..0cc1eb7b4fd2 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2606,7 +2606,7 @@ static inline uint32_t drm_color_lut_extract(uint32_t user_input,
 	return clamp_val(val, 0, max);
 }
 
-/*
+/**
  * drm_framebuffer_reference - incr the fb refcnt
  * @fb: framebuffer
  *

commit 21daaeee9f55ee407422ad225790dee57f0d5171
Merge: 4946dd2e14d2 6d3e7fddb39a
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu May 5 09:56:30 2016 +1000

    Merge tag 'topic/drm-misc-2016-05-04' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    Ofc I promise just a few leftovers for drm-misc and somehow it's the
    biggest pull. But really mostly trivial stuff:
    - MAINTAINERS updates from Emil
    - rename async to nonblock in atomic_commit to avoid the confusion between
      nonblocking ioctl and async flip (= not vblank synced), from Maarten.
      Needs to be regened with newer drivers, but probably only after -rc1 to
      catch them all.
    - actually lockless gem_object_free, plus acked driver conversion patches.
      All the trickier prep stuff already is in drm-next.
    - Noralf's nice work for generic defio support in our fbdev emulation.
      Keeps the udl hack, and qxl is tested by Gerd.
    
    * tag 'topic/drm-misc-2016-05-04' of git://anongit.freedesktop.org/drm-intel: (47 commits)
      drm: Fixup locking WARN_ON mistake around gem_object_free_unlocked
      drm/etnaviv: Use lockless gem BO free callback
      drm/imx: Use lockless gem BO free callback
      drm/radeon: Use lockless gem BO free callback
      drm/amdgpu: Use lockless gem BO free callback
      drm/gem: support BO freeing without dev->struct_mutex
      MAINTAINERS: Add myself for the new VC4 (RPi GPU) graphics driver.
      MAINTAINERS: Add a bunch of legacy (UMS) DRM drivers
      MAINTAINERS: Add a few DRM drivers by Dave Airlie
      MAINTAINERS: List the correct git repo for the Renesas DRM drivers
      MAINTAINERS: Update the files list for the Renesas DRM drivers
      MAINTAINERS: Update the files list for the Armada DRM driver
      MAINTAINERS: Update the files list for the Rockchip DRM driver
      MAINTAINERS: Update the files list for the Exynos DRM driver
      MAINTAINERS: Add maintainer entry for the VMWGFX DRM driver
      MAINTAINERS: Add maintainer entry for the MSM DRM driver
      MAINTAINERS: Add maintainer entry for the Nouveau DRM driver
      MAINTAINERS: Update the files list for the Etnaviv DRM driver
      MAINTAINERS: Remove unneded wildcard for the i915 DRM driver
      drm/atomic: Add WARN_ON when state->acquire_ctx is not set.
      ...

commit 286dbb8d5d800dcca23d43bb62d9f3cd96fe479c
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Tue Apr 26 16:11:34 2016 +0200

    drm/atomic: Rename async parameter to nonblocking.
    
    This is the first step of renaming async commit to nonblocking commit.
    The flag passed by userspace is NONBLOCKING, and async has a different
    meaning for page flips, where it means as soon as possible.
    
    Fixing up comments in drm core is done manually, to make sure I didn't
    miss anything.
    
    For drivers, the following cocci script is used to rename bool async to bool
    nonblock:
    @@
    identifier I =~ "^async";
    identifier func;
    @@
    func(..., bool
    - I
    + nonblock
    , ...)
    {
    <...
    - I
    + nonblock
    ...>
    }
    @@
    identifier func;
    type T;
    identifier I =~ "^async";
    @@
    T func(..., bool
    - I
    + nonblock
    , ...);
    
    Thanks to Tvrtko Ursulin for the cocci script.
    
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1461679905-30177-2-git-send-email-maarten.lankhorst@linux.intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 43c31496a5a7..800c48e80811 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1887,7 +1887,7 @@ struct drm_mode_config_funcs {
 	 * drm_atomic_helper_commit(), or one of the exported sub-functions of
 	 * it.
 	 *
-	 * Asynchronous commits (as indicated with the async parameter) must
+	 * Nonblocking commits (as indicated with the nonblock parameter) must
 	 * do any preparatory work which might result in an unsuccessful commit
 	 * in the context of this callback. The only exceptions are hardware
 	 * errors resulting in -EIO. But even in that case the driver must
@@ -1900,7 +1900,7 @@ struct drm_mode_config_funcs {
 	 * The driver must wait for any pending rendering to the new
 	 * framebuffers to complete before executing the flip. It should also
 	 * wait for any pending rendering from other drivers if the underlying
-	 * buffer is a shared dma-buf. Asynchronous commits must not wait for
+	 * buffer is a shared dma-buf. Nonblocking commits must not wait for
 	 * rendering in the context of this callback.
 	 *
 	 * An application can request to be notified when the atomic commit has
@@ -1931,7 +1931,7 @@ struct drm_mode_config_funcs {
 	 *
 	 * 0 on success or one of the below negative error codes:
 	 *
-	 *  - -EBUSY, if an asynchronous updated is requested and there is
+	 *  - -EBUSY, if a nonblocking updated is requested and there is
 	 *    an earlier updated pending. Drivers are allowed to support a queue
 	 *    of outstanding updates, but currently no driver supports that.
 	 *    Note that drivers must wait for preceding updates to complete if a
@@ -1961,7 +1961,7 @@ struct drm_mode_config_funcs {
 	 */
 	int (*atomic_commit)(struct drm_device *dev,
 			     struct drm_atomic_state *state,
-			     bool async);
+			     bool nonblock);
 
 	/**
 	 * @atomic_state_alloc:

commit 152ef5fa9e14e93e7efc43adad7dbcf35d7780f5
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Apr 22 22:10:30 2016 +0200

    drm: Switch blobs to the new generic modeset obj refcounting
    
    Need to move the free function around a bit, but otherwise mostly
    just removing code.
    
    Specifically we can nuke all the _locked variants since the weak idr
    reference is now protected by the idr_mutex, which we never hold
    anywhere expect in the lookup/reg/unreg functions. And those never
    call anything else.
    
    Another benefit of this is that this patch switches the weak reference
    logic from kref_put_mutex to kref_get_unless_zero. And the later is in
    general more flexible wrt accomodating multiple weak references
    protected by different locks, which might or might not come handy
    eventually.
    
    But one consequence of that switch is that we need to acquire the
    blob_lock from the free function for the list_del calls. That's a bit
    tricky to pull off, but works well if we pick the exact same scheme as
    is already used for framebuffers. Most important changes:
    
    - filp list is maintainer by create/destroy_blob ioctls directly
      (already the case, so we can just remove the redundant list_del from
      the free function).
    
    - filp close handler walks the filp-private list lockless - works
      because we know no one else can access it. I copied the same comment
      from the fb code over to explain this.
    
    - Otherwise we need to sufficiently restrict blob_lock critical
      sections to avoid all the unreference calls. Easy to do once the
      blob_lock only protects the list, and no longer the weak reference.
    
    Cc: Dave Airlie <airlied@gmail.com>
    Cc: Daniel Stone <daniels@collabora.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 43c31496a5a7..297e527f1cac 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -250,7 +250,6 @@ struct drm_framebuffer {
 struct drm_property_blob {
 	struct drm_mode_object base;
 	struct drm_device *dev;
-	struct kref refcount;
 	struct list_head head_global;
 	struct list_head head_file;
 	size_t length;

commit d0f37cf62979e65558c1b7bd4d4c221c5281bae1
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Apr 15 15:10:36 2016 +1000

    drm/mode: move framebuffer reference into object.
    
    This is the initial code to add references to some mode objects.
    In the future we need to start reference counting connectors so
    firstly I want to reorganise the code so the framebuffer ref counting
    uses the same paths.
    
    This patch shouldn't change any functionality, just moves the kref.
    
    [airlied: move kerneldoc as well]
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 1c99ee09c9a0..43c31496a5a7 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -49,6 +49,8 @@ struct drm_mode_object {
 	uint32_t id;
 	uint32_t type;
 	struct drm_object_properties *properties;
+	struct kref refcount;
+	void (*free_cb)(struct kref *kref);
 };
 
 #define DRM_OBJECT_MAX_PROPERTY 24
@@ -223,8 +225,8 @@ struct drm_framebuffer {
 	 * should be deferred.  In cases like this, the driver would like to
 	 * hold a ref to the fb even though it has already been removed from
 	 * userspace perspective.
+	 * The refcount is stored inside the mode object.
 	 */
-	struct kref refcount;
 	/*
 	 * Place on the dev->mode_config.fb_list, access protected by
 	 * dev->mode_config.fb_lock.
@@ -2377,8 +2379,6 @@ extern int drm_framebuffer_init(struct drm_device *dev,
 				const struct drm_framebuffer_funcs *funcs);
 extern struct drm_framebuffer *drm_framebuffer_lookup(struct drm_device *dev,
 						      uint32_t id);
-extern void drm_framebuffer_unreference(struct drm_framebuffer *fb);
-extern void drm_framebuffer_reference(struct drm_framebuffer *fb);
 extern void drm_framebuffer_remove(struct drm_framebuffer *fb);
 extern void drm_framebuffer_cleanup(struct drm_framebuffer *fb);
 extern void drm_framebuffer_unregister_private(struct drm_framebuffer *fb);
@@ -2436,6 +2436,8 @@ extern int drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,
 					 int gamma_size);
 extern struct drm_mode_object *drm_mode_object_find(struct drm_device *dev,
 		uint32_t id, uint32_t type);
+void drm_mode_object_reference(struct drm_mode_object *obj);
+void drm_mode_object_unreference(struct drm_mode_object *obj);
 
 /* IOCTLs */
 extern int drm_mode_getresources(struct drm_device *dev,
@@ -2605,6 +2607,28 @@ static inline uint32_t drm_color_lut_extract(uint32_t user_input,
 	return clamp_val(val, 0, max);
 }
 
+/*
+ * drm_framebuffer_reference - incr the fb refcnt
+ * @fb: framebuffer
+ *
+ * This functions increments the fb's refcount.
+ */
+static inline void drm_framebuffer_reference(struct drm_framebuffer *fb)
+{
+	drm_mode_object_reference(&fb->base);
+}
+
+/**
+ * drm_framebuffer_unreference - unref a framebuffer
+ * @fb: framebuffer to unref
+ *
+ * This functions decrements the fb's refcount and frees it if it drops to zero.
+ */
+static inline void drm_framebuffer_unreference(struct drm_framebuffer *fb)
+{
+	drm_mode_object_unreference(&fb->base);
+}
+
 /**
  * drm_framebuffer_read_refcount - read the framebuffer reference count.
  * @fb: framebuffer
@@ -2613,7 +2637,7 @@ static inline uint32_t drm_color_lut_extract(uint32_t user_input,
  */
 static inline uint32_t drm_framebuffer_read_refcount(struct drm_framebuffer *fb)
 {
-	return atomic_read(&fb->refcount.refcount);
+	return atomic_read(&fb->base.refcount.refcount);
 }
 
 /* Plane list iterator for legacy (overlay only) planes. */

commit 747a598ffa7dff499ee93d414b74a08af6ec657e
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Apr 15 15:10:35 2016 +1000

    drm/mode: introduce wrapper to read framebuffer refcount.
    
    Avoids drivers knowing where the kref is stored.
    
    [airlied: add kerneldoc]
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 6f43f9487aee..1c99ee09c9a0 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2605,6 +2605,17 @@ static inline uint32_t drm_color_lut_extract(uint32_t user_input,
 	return clamp_val(val, 0, max);
 }
 
+/**
+ * drm_framebuffer_read_refcount - read the framebuffer reference count.
+ * @fb: framebuffer
+ *
+ * This functions returns the framebuffer's reference count.
+ */
+static inline uint32_t drm_framebuffer_read_refcount(struct drm_framebuffer *fb)
+{
+	return atomic_read(&fb->refcount.refcount);
+}
+
 /* Plane list iterator for legacy (overlay only) planes. */
 #define drm_for_each_legacy_plane(plane, dev) \
 	list_for_each_entry(plane, &(dev)->mode_config.plane_list, head) \

commit 54d2c2da0946368b96b63e6daed7920f3681243e
Author: Alexey Brodkin <Alexey.Brodkin@synopsys.com>
Date:   Tue Apr 19 15:24:51 2016 +0300

    drm: Introduce drm_connector_register_all() helper
    
    As a pair to already existing drm_connector_unregister_all() we're adding
    generic implementation of what is already done in some drivers.
    
    Once this helper is implemented we'll be ready to switch existing
    driver-specific implementations with the generic one.
    
    Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1461068693-11260-2-git-send-email-abrodkin@synopsys.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index a6fbc9e5e896..6f43f9487aee 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2249,7 +2249,8 @@ static inline unsigned drm_connector_index(struct drm_connector *connector)
 	return connector->connector_id;
 }
 
-/* helper to unregister all connectors from sysfs for device */
+/* helpers to {un}register all connectors from sysfs for device */
+extern int drm_connector_register_all(struct drm_device *dev);
 extern void drm_connector_unregister_all(struct drm_device *dev);
 
 extern int drm_bridge_add(struct drm_bridge *bridge);

commit 644a80508f918e488aad70814b65b7007438ef4c
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Tue Mar 22 14:10:33 2016 +0000

    drm: fix lut value extraction function
    
    When extracting the value at full precision (16 bits), no need to
    round the value.
    
    This was spotted by Jani when running sparse. Unfortunately this fix
    doesn't get rid of the warning.
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reported-by: Jani Nikula <jani.nikula@intel.com>
    Cc: Daniel Stone <daniels@collabora.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Matt Roper <matthew.d.roper@intel.com>
    Cc: dri-devel@lists.freedesktop.org
    Fixes: 5488dc16fde7 ("drm: introduce pipe color correction properties")
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1458655833-19547-1-git-send-email-lionel.g.landwerlin@intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 6d4684242a00..a6fbc9e5e896 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2592,10 +2592,14 @@ static inline struct drm_property *drm_property_find(struct drm_device *dev,
 static inline uint32_t drm_color_lut_extract(uint32_t user_input,
 					     uint32_t bit_precision)
 {
-	uint32_t val = user_input + (1 << (16 - bit_precision - 1));
+	uint32_t val = user_input;
 	uint32_t max = 0xffff >> (16 - bit_precision);
 
-	val >>= 16 - bit_precision;
+	/* Round only if we're not using full precision. */
+	if (bit_precision < 16) {
+		val += 1UL << (16 - bit_precision - 1);
+		val >>= 16 - bit_precision;
+	}
 
 	return clamp_val(val, 0, max);
 }

commit 59f7c0fa325e5661188a174a435ea4925543985b
Author: Jim Bride <jim.bride@linux.intel.com>
Date:   Thu Apr 14 10:18:35 2016 -0700

    drm/edid: Add drm_edid_get_monitor_name()
    
    In order to include monitor name information in debugfs
    output we needed to add a function that would extract the
    monitor name from the EDID, and that function needed to
    reside in the file  where the rest of the EDID helper
    functions are implemented.
    
    v2: Refactor to have drm_edid_get_monitor_name() and drm_edid_to_eld()
        use a common helper function to extract the monitor name from the
        edid. [Jani] + rebase.
    
    v3: Minor changes suggested by Jani + rebase.
    
    v4: Few more minor changes suggested by Jani + rebase.
    
    cc: dri-devel@lists.freedesktop.org
    cc: Jani Nikula <jani.nikula@linux.intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Jim Bride <jim.bride@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1460654317-31288-1-git-send-email-jim.bride@linux.intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 8cb377c5eb93..6d4684242a00 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2500,6 +2500,8 @@ extern int drm_edid_header_is_valid(const u8 *raw_edid);
 extern bool drm_edid_block_valid(u8 *raw_edid, int block, bool print_bad_edid,
 				 bool *edid_corrupt);
 extern bool drm_edid_is_valid(struct edid *edid);
+extern void drm_edid_get_monitor_name(struct edid *edid, char *name,
+				      int buflen);
 
 extern struct drm_tile_group *drm_mode_create_tile_group(struct drm_device *dev,
 							 char topology[8]);

commit e7c8e54440bcae3f883ca8801f6558fe29bf0198
Merge: 9735a22799b9 249c4f538b1a
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Apr 6 09:39:01 2016 +1000

    Merge tag 'topic/drm-misc-2016-04-01' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    * tag 'topic/drm-misc-2016-04-01' of git://anongit.freedesktop.org/drm-intel:
      drm: Add new DCS commands in the enum list
      drm: Make uapi headers C89 pendantic compliant
      drm/atomic: export drm_atomic_helper_wait_for_fences()
      drm: Untangle __KERNEL__ guards
      drm: Move DRM_MODE_OBJECT_* to uapi headers
      drm: align #include directives with libdrm in uapi headers
      drm: Make drm.h uapi header safe for C++
      vgacon: dummy implementation for vgacon_text_force
      drm/sysfs: Nuke TV/DVI property files
      drm/ttm: Remove TTM_HAS_AGP
      drm: bridge/dw-hdmi: Remove pre_enable/post_disable dummy funcs
      Revert "drm: Don't pass negative delta to ktime_sub_ns()"
      drm/atmel: Fixup drm_connector_/unplug/unregister/_all
      drm: Rename drm_connector_unplug_all() to drm_connector_unregister_all()
      drm: bridge: Make (pre/post) enable/disable callbacks optional

commit 8812f3814120873ac625d0085e64e4b83ff5aff3
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Mar 30 16:19:44 2016 +0200

    drm: Move DRM_MODE_OBJECT_* to uapi headers
    
    These type defines are officially part of the uapi, but ended up in
    the wrong headers somehow when we split them all.
    
    Cc: Emil Velikov <emil.l.velikov@gmail.com>
    Reviewed-by: Emil Velikov <emil.l.velikov@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1459347584-30566-3-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 12f2bd4cf38a..dc5cbf2b09aa 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -45,16 +45,6 @@ struct drm_clip_rect;
 struct device_node;
 struct fence;
 
-#define DRM_MODE_OBJECT_CRTC 0xcccccccc
-#define DRM_MODE_OBJECT_CONNECTOR 0xc0c0c0c0
-#define DRM_MODE_OBJECT_ENCODER 0xe0e0e0e0
-#define DRM_MODE_OBJECT_MODE 0xdededede
-#define DRM_MODE_OBJECT_PROPERTY 0xb0b0b0b0
-#define DRM_MODE_OBJECT_FB 0xfbfbfbfb
-#define DRM_MODE_OBJECT_BLOB 0xbbbbbbbb
-#define DRM_MODE_OBJECT_PLANE 0xeeeeeeee
-#define DRM_MODE_OBJECT_ANY 0
-
 struct drm_mode_object {
 	uint32_t id;
 	uint32_t type;

commit 6c87e5c3ec6db052f3744804a517b6fb003906e1
Author: Alexey Brodkin <Alexey.Brodkin@synopsys.com>
Date:   Wed Mar 23 11:42:54 2016 +0300

    drm: Rename drm_connector_unplug_all() to drm_connector_unregister_all()
    
    Current name is a bit misleading because what that helper function
    really does it calls drm_connector_unregister() for all connectors.
    
    This all has nothing to do with hotplugging so let's name things
    properly.
    
    And while at it remove potentially dangerous locking around
    drm_connector_unregister() in rcar_du_remove() as mentioned
    in kerneldoc for drm_connector_unregister_all().
    
    Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Boris Brezillon <boris.brezillon@free-electrons.com>
    Cc: linux-renesas-soc@vger.kernel.org
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1458722577-20283-2-git-send-email-abrodkin@synopsys.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f048a7b06529..12f2bd4cf38a 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2253,8 +2253,8 @@ void drm_connector_unregister(struct drm_connector *connector);
 
 extern void drm_connector_cleanup(struct drm_connector *connector);
 extern unsigned int drm_connector_index(struct drm_connector *connector);
-/* helper to unplug all connectors from sysfs for device */
-extern void drm_connector_unplug_all(struct drm_device *dev);
+/* helper to unregister all connectors from sysfs for device */
+extern void drm_connector_unregister_all(struct drm_device *dev);
 
 extern int drm_bridge_add(struct drm_bridge *bridge);
 extern void drm_bridge_remove(struct drm_bridge *bridge);

commit 11622d4c638ad3dd229e39064d0e5726c4f3b454
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Feb 26 11:51:06 2016 +0200

    drm: bridge: Make (pre/post) enable/disable callbacks optional
    
    Instead of forcing bridges to implement empty callbacks make them all
    optional.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1456480266-7904-1-git-send-email-laurent.pinchart+renesas@ideasonboard.com
    Acked-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b10eba23a744..f048a7b06529 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1596,6 +1596,8 @@ struct drm_bridge_funcs {
 	 *
 	 * The bridge can assume that the display pipe (i.e. clocks and timing
 	 * signals) feeding it is still running when this callback is called.
+	 *
+	 * The disable callback is optional.
 	 */
 	void (*disable)(struct drm_bridge *bridge);
 
@@ -1612,6 +1614,8 @@ struct drm_bridge_funcs {
 	 * The bridge must assume that the display pipe (i.e. clocks and timing
 	 * singals) feeding it is no longer running when this callback is
 	 * called.
+	 *
+	 * The post_disable callback is optional.
 	 */
 	void (*post_disable)(struct drm_bridge *bridge);
 
@@ -1640,6 +1644,8 @@ struct drm_bridge_funcs {
 	 * will not yet be running when this callback is called. The bridge must
 	 * not enable the display link feeding the next bridge in the chain (if
 	 * there is one) when this callback is called.
+	 *
+	 * The pre_enable callback is optional.
 	 */
 	void (*pre_enable)(struct drm_bridge *bridge);
 
@@ -1657,6 +1663,8 @@ struct drm_bridge_funcs {
 	 * signals) feeding it is running when this callback is called. This
 	 * callback must enable the display link feeding the next bridge in the
 	 * chain if there is one.
+	 *
+	 * The enable callback is optional.
 	 */
 	void (*enable)(struct drm_bridge *bridge);
 };

commit 5e2368a3bbb36d24c038d87d61ebf291e4be5197
Merge: 0e5dc9a8ee2f c8a3b2ae0713
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Mar 17 08:09:44 2016 +1000

    Merge tag 'drm/panel/for-4.6-rc1' of http://anongit.freedesktop.org/git/tegra/linux into drm-next
    
    drm/panel: Changes for v4.6-rc1
    
    This contains a refactoring of parts of the DSI core to allow creating
    DSI devices from non-DSI control busses (i.e. I2C, SPI, ...).
    
    Other than that there's support for a couple of new panels as well as
    a few cleanup patches.
    
    * tag 'drm/panel/for-4.6-rc1' of http://anongit.freedesktop.org/git/tegra/linux:
      drm/bridge: Make (pre/post) enable/disable callbacks optional
      drm/panel: simple: Add URT UMSH-8596MD-xT panels support
      dt-bindings: Add URT UMSH-8596MD-xT panel bindings
      of: Add United Radiant Technology Corporation vendor prefix
      drm/panel: simple: Support for LG lp120up1 panel
      dt-bindings: Add LG lp120up1 panel bindings
      drm/panel: simple: Fix g121x1_l03 hsync/vsync polarity
      drm/dsi: Get DSI host by DT device node
      drm/dsi: Add routine to unregister a DSI device
      drm/dsi: Try to match non-DT DSI devices
      drm/dsi: Use mipi_dsi_device_register_full() for DSI device creation
      drm/dsi: Check for CONFIG_OF when defining of_mipi_dsi_device_add()

commit 1a4be38a3a46898fee61b3ec1631d273dd66fcf2
Merge: c51e034fedb0 c1f415c9acb5
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Mar 16 11:09:26 2016 +1000

    Merge tag 'topic/drm-misc-2016-03-14' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    * tag 'topic/drm-misc-2016-03-14' of git://anongit.freedesktop.org/drm-intel: (27 commits)
      drm: atomic helper: do not unreference error pointer
      drm/edid: Extract SADs properly from multiple audio data blocks
      drm: fix blob pointer check
      drm: introduce pipe color correction properties
      drm/atomic: Clean up update_connector_routing.
      drm/atomic: Clean up steal_encoder, v2.
      drm/atomic: Handle encoder assignment conflicts in a separate check, v3.
      drm/atomic: Handle encoder stealing from set_config better.
      drm/atomic: Always call steal_encoder, v2.
      drm/ast: removed optional dummy crtc mode_fixup function.
      drm/bochs: removed optional dummy crtc mode_fixup function.
      drm/fsl-dcu: removed optional dummy crtc mode_fixup function.
      drm/virtio: removed optional dummy crtc mode_fixup function.
      drm/nouveau/dispnv04: removed optional dummy crtc mode_fixup function.
      drm/atmel-hlcdc: remove optional dummy crtc mode_fixup function.
      drm/sti: removed optional dummy crtc mode_fixup function.
      drm/shmobile: removed optional dummy crtc mode_fixup function.
      drm/msm/mdp: removed optional dummy crtc mode_fixup function.
      drm/omapdrm: removed optional dummy crtc mode_fixup function.
      drm/rcar-du: removed optional dummy crtc mode_fixup function.
      ...

commit 9b61c0fcdf0cfd20a85d9856d46142e7f297de0a
Merge: 550e3b23a53c 125234dc8b1c
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Mar 14 09:42:34 2016 +1000

    Merge drm-fixes into drm-next.
    
    Nouveau wanted this to avoid some worse conflicts when I merge that.

commit 5488dc16fde74595a40c5d20ae52d978313f0b4e
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Fri Feb 26 17:05:00 2016 +0000

    drm: introduce pipe color correction properties
    
    Patch based on a previous series by Shashank Sharma.
    
    This introduces optional properties to enable color correction at the
    pipe level. It relies on 3 transformations applied to every pixels
    displayed. First a lookup into a degamma table, then a multiplication
    of the rgb components by a 3x3 matrix and finally another lookup into
    a gamma table.
    
    The following properties can be added to a pipe :
      - DEGAMMA_LUT : blob containing degamma LUT
      - DEGAMMA_LUT_SIZE : number of elements in DEGAMMA_LUT
      - CTM : transformation matrix applied after the degamma LUT
      - GAMMA_LUT : blob containing gamma LUT
      - GAMMA_LUT_SIZE : number of elements in GAMMA_LUT
    
    DEGAMMA_LUT_SIZE and GAMMA_LUT_SIZE are read only properties, set by
    the driver to tell userspace applications what sizes should be the
    lookup tables in DEGAMMA_LUT and GAMMA_LUT.
    
    A helper is also provided so legacy gamma correction is redirected
    through these new properties.
    
    v2: Register LUT size properties as range
    
    v3: Fix round in drm_color_lut_get_value() helper
        More docs on how degamma/gamma properties are used
    
    v4: Update contributors
    
    v5: Rename CTM_MATRIX property to CTM (Doh!)
        Add legacy gamma_set atomic helper
        Describe CTM/LUT acronyms in the kernel doc
    
    v6: Fix missing blob unref in drm_atomic_helper_crtc_reset
    
    Signed-off-by: Shashank Sharma <shashank.sharma@intel.com>
    Signed-off-by: Kumar, Kiran S <kiran.s.kumar@intel.com>
    Signed-off-by: Kausal Malladi <kausalmalladi@gmail.com>
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Acked-by: Rob Bradford <robert.bradford@intel.com>
    [danvet: CrOS maintainers are also happy with the userspacde side:
    https://codereview.chromium.org/1182063002/ ]
    Reviewed-by: Daniel Stone <daniels@collabora.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1456506302-640-4-git-send-email-lionel.g.landwerlin@intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 75b28deeaf24..b10eba23a744 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -305,6 +305,8 @@ struct drm_plane_helper_funcs;
  * @mode_changed: crtc_state->mode or crtc_state->enable has been changed
  * @active_changed: crtc_state->active has been toggled.
  * @connectors_changed: connectors to this crtc have been updated
+ * @color_mgmt_changed: color management properties have changed (degamma or
+ *	gamma LUT or CSC matrix)
  * @plane_mask: bitmask of (1 << drm_plane_index(plane)) of attached planes
  * @connector_mask: bitmask of (1 << drm_connector_index(connector)) of attached connectors
  * @encoder_mask: bitmask of (1 << drm_encoder_index(encoder)) of attached encoders
@@ -312,6 +314,11 @@ struct drm_plane_helper_funcs;
  * 	update to ensure framebuffer cleanup isn't done too early
  * @adjusted_mode: for use by helpers and drivers to compute adjusted mode timings
  * @mode: current mode timings
+ * @degamma_lut: Lookup table for converting framebuffer pixel data
+ *	before apply the conversion matrix
+ * @ctm: Transformation matrix
+ * @gamma_lut: Lookup table for converting pixel data after the
+ *	conversion matrix
  * @event: optional pointer to a DRM event to signal upon completion of the
  * 	state update
  * @state: backpointer to global drm_atomic_state
@@ -333,6 +340,7 @@ struct drm_crtc_state {
 	bool mode_changed : 1;
 	bool active_changed : 1;
 	bool connectors_changed : 1;
+	bool color_mgmt_changed : 1;
 
 	/* attached planes bitmask:
 	 * WARNING: transitional helpers do not maintain plane_mask so
@@ -355,6 +363,11 @@ struct drm_crtc_state {
 	/* blob property to expose current mode to atomic userspace */
 	struct drm_property_blob *mode_blob;
 
+	/* blob property to expose color management to userspace */
+	struct drm_property_blob *degamma_lut;
+	struct drm_property_blob *ctm;
+	struct drm_property_blob *gamma_lut;
+
 	struct drm_pending_vblank_event *event;
 
 	struct drm_atomic_state *state;
@@ -757,7 +770,7 @@ struct drm_crtc {
 	int x, y;
 	const struct drm_crtc_funcs *funcs;
 
-	/* CRTC gamma size for reporting to userspace */
+	/* Legacy FB CRTC gamma size for reporting to userspace */
 	uint32_t gamma_size;
 	uint16_t *gamma_store;
 
@@ -2027,6 +2040,15 @@ struct drm_mode_config_funcs {
  * @property_blob_list: list of all the blob property objects
  * @blob_lock: mutex for blob property allocation and management
  * @*_property: core property tracking
+ * @degamma_lut_property: LUT used to convert the framebuffer's colors to linear
+ *	gamma
+ * @degamma_lut_size_property: size of the degamma LUT as supported by the
+ *	driver (read-only)
+ * @ctm_property: Matrix used to convert colors after the lookup in the
+ *	degamma LUT
+ * @gamma_lut_property: LUT used to convert the colors, after the CSC matrix, to
+ *	the gamma space of the connected screen (read-only)
+ * @gamma_lut_size_property: size of the gamma LUT as supported by the driver
  * @preferred_depth: preferred RBG pixel depth, used by fb helpers
  * @prefer_shadow: hint to userspace to prefer shadow-fb rendering
  * @async_page_flip: does this device support async flips on the primary plane?
@@ -2128,6 +2150,13 @@ struct drm_mode_config {
 	struct drm_property *aspect_ratio_property;
 	struct drm_property *dirty_info_property;
 
+	/* Optional color correction properties */
+	struct drm_property *degamma_lut_property;
+	struct drm_property *degamma_lut_size_property;
+	struct drm_property *ctm_property;
+	struct drm_property *gamma_lut_property;
+	struct drm_property *gamma_lut_size_property;
+
 	/* properties for virtual machine layout */
 	struct drm_property *suggested_x_property;
 	struct drm_property *suggested_y_property;
@@ -2550,6 +2579,21 @@ static inline struct drm_property *drm_property_find(struct drm_device *dev,
 	return mo ? obj_to_property(mo) : NULL;
 }
 
+/*
+ * Extract a degamma/gamma LUT value provided by user and round it to the
+ * precision supported by the hardware.
+ */
+static inline uint32_t drm_color_lut_extract(uint32_t user_input,
+					     uint32_t bit_precision)
+{
+	uint32_t val = user_input + (1 << (16 - bit_precision - 1));
+	uint32_t max = 0xffff >> (16 - bit_precision);
+
+	val >>= 16 - bit_precision;
+
+	return clamp_val(val, 0, max);
+}
+
 /* Plane list iterator for legacy (overlay only) planes. */
 #define drm_for_each_legacy_plane(plane, dev) \
 	list_for_each_entry(plane, &(dev)->mode_config.plane_list, head) \

commit 40616a26d1c68e4c80e2358a02297ba492f4cc17
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Thu Mar 3 10:17:39 2016 +0100

    drm/atomic: Handle encoder stealing from set_config better.
    
    Instead of failing with -EINVAL when conflicting encoders are found,
    the legacy set_config will disable other connectors when encoders
    conflict.
    
    With the previous commit this becomes a lot easier to implement.
    set_config only adds connectors to the state that are modified,
    and because of the previous commit that calls add_affected_connectors
    only on set->crtc it means any connector not part of the modeset can
    be stolen from. We disable the connector in that case, and possibly
    the crtc if required.
    
    Atomic modeset itself still doesn't allow encoder stealing, the results
    would be too unpredictable.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1456996662-8704-5-git-send-email-maarten.lankhorst@linux.intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 8c7fb3d0f9d0..75b28deeaf24 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1676,6 +1676,7 @@ struct drm_bridge {
  * @dev: parent DRM device
  * @allow_modeset: allow full modeset
  * @legacy_cursor_update: hint to enforce legacy cursor IOCTL semantics
+ * @legacy_set_config: Disable conflicting encoders instead of failing with -EINVAL.
  * @planes: pointer to array of plane pointers
  * @plane_states: pointer to array of plane states pointers
  * @crtcs: pointer to array of CRTC pointers
@@ -1689,6 +1690,7 @@ struct drm_atomic_state {
 	struct drm_device *dev;
 	bool allow_modeset : 1;
 	bool legacy_cursor_update : 1;
+	bool legacy_set_config : 1;
 	struct drm_plane **planes;
 	struct drm_plane_state **plane_states;
 	struct drm_crtc **crtcs;

commit c8a3b2ae07130042682bc8e031bcfbae3754463d
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Feb 26 11:51:06 2016 +0200

    drm/bridge: Make (pre/post) enable/disable callbacks optional
    
    Instead of forcing bridges to implement empty callbacks make them all
    optional.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c65a212db77e..f336671ca932 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1581,6 +1581,8 @@ struct drm_bridge_funcs {
 	 *
 	 * The bridge can assume that the display pipe (i.e. clocks and timing
 	 * signals) feeding it is still running when this callback is called.
+	 *
+	 * The disable callback is optional.
 	 */
 	void (*disable)(struct drm_bridge *bridge);
 
@@ -1597,6 +1599,8 @@ struct drm_bridge_funcs {
 	 * The bridge must assume that the display pipe (i.e. clocks and timing
 	 * singals) feeding it is no longer running when this callback is
 	 * called.
+	 *
+	 * The post_disable callback is optional.
 	 */
 	void (*post_disable)(struct drm_bridge *bridge);
 
@@ -1625,6 +1629,8 @@ struct drm_bridge_funcs {
 	 * will not yet be running when this callback is called. The bridge must
 	 * not enable the display link feeding the next bridge in the chain (if
 	 * there is one) when this callback is called.
+	 *
+	 * The pre_enable callback is optional.
 	 */
 	void (*pre_enable)(struct drm_bridge *bridge);
 
@@ -1642,6 +1648,8 @@ struct drm_bridge_funcs {
 	 * signals) feeding it is running when this callback is called. This
 	 * callback must enable the display link feeding the next bridge in the
 	 * chain if there is one.
+	 *
+	 * The enable callback is optional.
 	 */
 	void (*enable)(struct drm_bridge *bridge);
 };

commit 5fff80bbdb6b84a94f90391ba674471d37b57eb2
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Wed Feb 17 08:32:05 2016 +0100

    drm/atomic: Allow for holes in connector state, v2.
    
    Because we record connector_mask using 1 << drm_connector_index now
    the connector_mask should stay the same even when other connectors
    are removed. This was not the case with MST, in that case when removing
    a connector all other connectors may change their index.
    
    This is fixed by waiting until the first get_connector_state to allocate
    connector_state, and force reallocation when state is too small.
    
    As a side effect connector arrays no longer have to be preallocated,
    and can be allocated on first use which means a less allocations in
    the page flip only path.
    
    Changes since v1:
    - Whitespace. (Ville)
    - Call ida_remove when destroying the connector. (Ville)
    - u32 alloc -> int. (Ville)
    
    Fixes: 14de6c44d149 ("drm/atomic: Remove drm_atomic_connectors_for_crtc.")
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Lyude <cpaul@redhat.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c65a212db77e..c5b4b81a831b 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1166,6 +1166,7 @@ struct drm_connector {
 	struct drm_mode_object base;
 
 	char *name;
+	int connector_id;
 	int connector_type;
 	int connector_type_id;
 	bool interlace_allowed;
@@ -2047,6 +2048,7 @@ struct drm_mode_config {
 	struct list_head fb_list;
 
 	int num_connector;
+	struct ida connector_ida;
 	struct list_head connector_list;
 	int num_encoder;
 	struct list_head encoder_list;
@@ -2200,7 +2202,11 @@ int drm_connector_register(struct drm_connector *connector);
 void drm_connector_unregister(struct drm_connector *connector);
 
 extern void drm_connector_cleanup(struct drm_connector *connector);
-extern unsigned int drm_connector_index(struct drm_connector *connector);
+static inline unsigned drm_connector_index(struct drm_connector *connector)
+{
+	return connector->connector_id;
+}
+
 /* helper to unplug all connectors from sysfs for device */
 extern void drm_connector_unplug_all(struct drm_device *dev);
 

commit 4c61716c2bfaaf1b8837a67775662008b4f42225
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Feb 9 17:29:44 2016 +0200

    drm: Add drm_format_plane_width() and drm_format_plane_height()
    
    Add a few helpers to get the dimensions of the chroma plane(s).
    
    v2: Add kernel-doc (Daniel)
    v3: Fix kerneldoc "Returns:" style (Daniel)
        Uninline the functions and check for num_planes (Daniel)
    v4: Add the required EXPORT_SYMBOL()s
    
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1455031784-10941-1-git-send-email-ville.syrjala@linux.intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index ad53d2ffd48c..8c7fb3d0f9d0 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2498,6 +2498,8 @@ extern int drm_format_num_planes(uint32_t format);
 extern int drm_format_plane_cpp(uint32_t format, int plane);
 extern int drm_format_horz_chroma_subsampling(uint32_t format);
 extern int drm_format_vert_chroma_subsampling(uint32_t format);
+extern int drm_format_plane_width(int width, uint32_t format, int plane);
+extern int drm_format_plane_height(int height, uint32_t format, int plane);
 extern const char *drm_get_format_name(uint32_t format);
 extern struct drm_property *drm_mode_create_rotation_property(struct drm_device *dev,
 							      unsigned int supported_rotations);

commit 5cb8eaa227d1870a68fc99a90edc8be0dbacca41
Author: Lukas Wunner <lukas@wunner.de>
Date:   Mon Jan 11 20:09:20 2016 +0100

    drm/edid: Switch DDC when reading the EDID
    
    Originally by Seth Forshee <seth.forshee@canonical.com>, 2012-10-04:
        Some dual graphics machines support muxing the DDC separately from
        the display, so make use of this functionality when reading the EDID
        on the inactive GPU. Also serialize drm_get_edid() with a mutex to
        avoid races on the DDC mux state.
    
    Modified by Dave Airlie <airlied@gmail.com>, 2012-12-22:
        I can't figure out why I didn't like this, but I rewrote this [...]
        to lock/unlock the ddc lines [...]. I think I'd prefer something
        like that otherwise the interface got really ugly.
    
    Modified by Lukas Wunner <lukas@wunner.de>, 2015-04 - 2015-09:
        v3:   Move vga_switcheroo calls to a wrapper around drm_get_edid()
              which drivers can call on muxed machines. This avoids other
              drivers having to go through the vga_switcheroo motions even
              though they are never used on a muxed platform
              (Thierry Reding, Daniel Vetter, Alex Deucher)
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=88861
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=61115
    Tested-by: Pierre Moreau <pierre.morrow@free.fr>
        [MBP  5,3 2009  nvidia MCP79 + G96        pre-retina  15"]
    Tested-by: William Brown <william@blackhats.net.au>
        [MBP  8,2 2011  intel SNB + amd turks     pre-retina  15"]
    Tested-by: Lukas Wunner <lukas@wunner.de>
        [MBP  9,1 2012  intel IVB + nvidia GK107  pre-retina  15"]
    Cc: Seth Forshee <seth.forshee@canonical.com>
    Cc: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/b898d0da4c134f2642d0122479006863e1830723.1452525860.git.lukas@wunner.de

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 51287f36b214..ad53d2ffd48c 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2296,6 +2296,8 @@ extern void drm_property_destroy_user_blobs(struct drm_device *dev,
 extern bool drm_probe_ddc(struct i2c_adapter *adapter);
 extern struct edid *drm_get_edid(struct drm_connector *connector,
 				 struct i2c_adapter *adapter);
+extern struct edid *drm_get_edid_switcheroo(struct drm_connector *connector,
+					    struct i2c_adapter *adapter);
 extern struct edid *drm_edid_duplicate(const struct edid *edid);
 extern int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid);
 extern void drm_mode_config_init(struct drm_device *dev);

commit e87a52b38943608531ff63ea397b1ae5dd48e341
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Thu Jan 28 15:04:58 2016 +0100

    drm/atomic: Add encoder_mask to crtc_state, v3.
    
    This allows iteration over encoders without requiring connection_mutex.
    
    Changes since v1:
    - Add a set_best_encoder helper function and update encoder_mask inside
      it.
    Changes since v2:
    - Relax the WARN_ON(!crtc), with explanation.
    - Call set_best_encoder when connector is moved between crtc's.
    - Add some paranoia to steal_encoder to prevent accidentally setting
      best_encoder to NULL.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/56AA200A.6070501@linux.intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c0226f945d62..51287f36b214 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -307,6 +307,7 @@ struct drm_plane_helper_funcs;
  * @connectors_changed: connectors to this crtc have been updated
  * @plane_mask: bitmask of (1 << drm_plane_index(plane)) of attached planes
  * @connector_mask: bitmask of (1 << drm_connector_index(connector)) of attached connectors
+ * @encoder_mask: bitmask of (1 << drm_encoder_index(encoder)) of attached encoders
  * @last_vblank_count: for helpers and drivers to capture the vblank of the
  * 	update to ensure framebuffer cleanup isn't done too early
  * @adjusted_mode: for use by helpers and drivers to compute adjusted mode timings
@@ -341,6 +342,7 @@ struct drm_crtc_state {
 	u32 plane_mask;
 
 	u32 connector_mask;
+	u32 encoder_mask;
 
 	/* last_vblank_count: for vblank waits before cleanup */
 	u32 last_vblank_count;

commit ead8b665705a0926442fbd3f4dbccbec36e5b8f4
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Thu Jan 7 10:59:19 2016 +0100

    drm/core: Add drm_for_each_encoder_mask, v2.
    
    This is similar to the other drm_for_each_*_mask functions.
    
    Changes since v1:
    - Use for_each_if
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1452160762-30487-3-git-send-email-maarten.lankhorst@linux.intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index fd2ace4a18de..c0226f945d62 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2153,6 +2153,17 @@ struct drm_mode_config {
 	list_for_each_entry((plane), &(dev)->mode_config.plane_list, head) \
 		for_each_if ((plane_mask) & (1 << drm_plane_index(plane)))
 
+/**
+ * drm_for_each_encoder_mask - iterate over encoders specified by bitmask
+ * @encoder: the loop cursor
+ * @dev: the DRM device
+ * @encoder_mask: bitmask of encoder indices
+ *
+ * Iterate over all encoders specified by bitmask.
+ */
+#define drm_for_each_encoder_mask(encoder, dev, encoder_mask) \
+	list_for_each_entry((encoder), &(dev)->mode_config.encoder_list, head) \
+		for_each_if ((encoder_mask) & (1 << drm_encoder_index(encoder)))
 
 #define obj_to_crtc(x) container_of(x, struct drm_crtc, base)
 #define obj_to_connector(x) container_of(x, struct drm_connector, base)

commit 47d7777f99da283ff0d6248dd9e83593cf06760c
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Thu Jan 7 10:59:18 2016 +0100

    drm/core: Add drm_encoder_index.
    
    This is useful for adding encoder_mask in crtc_state.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1452160762-30487-2-git-send-email-maarten.lankhorst@linux.intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c65a212db77e..fd2ace4a18de 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2225,6 +2225,7 @@ int drm_encoder_init(struct drm_device *dev,
 		     struct drm_encoder *encoder,
 		     const struct drm_encoder_funcs *funcs,
 		     int encoder_type, const char *name, ...);
+extern unsigned int drm_encoder_index(struct drm_encoder *encoder);
 
 /**
  * drm_encoder_crtc_ok - can a given crtc drive a given encoder?

commit 4cba68507cf58db99752cf79198beb4a85a9f8ce
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Dec 8 09:49:20 2015 +0100

    drm/atomic-helper: Reject legacy flips on a disabled pipe
    
    We want this for consistency with existing page_flip semantics.
    
    Since this spurred quite a discussion on IRC also document why we
    reject event generation when the pipe is off: It's not that it's hard
    to implement, but userspace has a track recording which proves that it's
    way too easy to accidentally abuse and cause havoc. We want to make
    sure userspace doesn't get away with that.
    
    v2: Somehow thought we do reject events already, but that code only
    existed in my imagination ... Also suggestions from Thierry.
    
    Cc: Daniel Stone <daniels@collabora.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Reviewed-by: Daniel Stone <daniels@collabora.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449564561-3896-4-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index e3c4d486e1af..c65a212db77e 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -551,7 +551,8 @@ struct drm_crtc_funcs {
 	 * ->page_flip() operation is already pending the callback should return
 	 * -EBUSY. Pageflips on a disabled CRTC (either by setting a NULL mode
 	 * or just runtime disabled through DPMS respectively the new atomic
-	 * "ACTIVE" state) should result in an -EINVAL error code.
+	 * "ACTIVE" state) should result in an -EINVAL error code. Note that
+	 * drm_atomic_helper_page_flip() checks this already for atomic drivers.
 	 */
 	int (*page_flip)(struct drm_crtc *crtc,
 			 struct drm_framebuffer *fb,

commit 4cd9fa529d77dde8f760adb3d934dfac6e169b1e
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Mon Jan 4 12:53:18 2016 +0100

    drm/atomic: add connector mask to drm_crtc_state.
    
    It can be useful to iterate over connectors without grabbing
    connection_mutex. It can also be used to see how many connectors
    are on a crtc without iterating over the list.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1451908400-25147-4-git-send-email-maarten.lankhorst@linux.intel.com
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 3b040b355472..e3c4d486e1af 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -306,6 +306,7 @@ struct drm_plane_helper_funcs;
  * @active_changed: crtc_state->active has been toggled.
  * @connectors_changed: connectors to this crtc have been updated
  * @plane_mask: bitmask of (1 << drm_plane_index(plane)) of attached planes
+ * @connector_mask: bitmask of (1 << drm_connector_index(connector)) of attached connectors
  * @last_vblank_count: for helpers and drivers to capture the vblank of the
  * 	update to ensure framebuffer cleanup isn't done too early
  * @adjusted_mode: for use by helpers and drivers to compute adjusted mode timings
@@ -339,6 +340,8 @@ struct drm_crtc_state {
 	 */
 	u32 plane_mask;
 
+	u32 connector_mask;
+
 	/* last_vblank_count: for vblank waits before cleanup */
 	u32 last_vblank_count;
 

commit d55f5320c7811d3858edaef5f2d4a9a7e43b1af8
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Dec 8 09:49:19 2015 +0100

    drm: Move more framebuffer doc from docbook to kerneldoc
    
    I missed a few paragraphs in the docbook that need to be pulled into
    the fbdev vfunc docs.
    
    v2: Spelling fixes from Thierry.
    
    Cc: Thierry Reding <treding@nvidia.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449564561-3896-3-git-send-email-daniel.vetter@ffwll.ch
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c2f98ba2bb98..3b040b355472 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -172,7 +172,9 @@ struct drm_framebuffer_funcs {
 	 * Clean up framebuffer resources, specifically also unreference the
 	 * backing storage. The core guarantees to call this function for every
 	 * framebuffer successfully created by ->fb_create() in
-	 * &drm_mode_config_funcs.
+	 * &drm_mode_config_funcs. Drivers must also call
+	 * drm_framebuffer_cleanup() to release DRM core resources for this
+	 * framebuffer.
 	 */
 	void (*destroy)(struct drm_framebuffer *framebuffer);
 
@@ -187,6 +189,9 @@ struct drm_framebuffer_funcs {
 	 * copying the current screen contents to a private buffer and blending
 	 * between that and the new contents.
 	 *
+	 * GEM based drivers should call drm_gem_handle_create() to create the
+	 * handle.
+	 *
 	 * RETURNS:
 	 *
 	 * 0 on success or a negative error code on failure.
@@ -1731,6 +1736,17 @@ struct drm_mode_config_funcs {
 	 * requested metadata, but most of that is left to the driver. See
 	 * struct &drm_mode_fb_cmd2 for details.
 	 *
+	 * If the parameters are deemed valid and the backing storage objects in
+	 * the underlying memory manager all exist, then the driver allocates
+	 * a new &drm_framebuffer structure, subclassed to contain
+	 * driver-specific information (like the internal native buffer object
+	 * references). It also needs to fill out all relevant metadata, which
+	 * should be done by calling drm_helper_mode_fill_fb_struct().
+	 *
+	 * The initialization is finalized by calling drm_framebuffer_init(),
+	 * which registers the framebuffer and makes it accessible to other
+	 * threads.
+	 *
 	 * RETURNS:
 	 *
 	 * A new framebuffer with an initial reference count of 1 or a negative

commit 9f4c97a236d35b9fe45168a979adb5e1522c0968
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Dec 8 18:41:54 2015 +0200

    drm: Add plane->name and use it in debug prints
    
    Show a sensible name for the plane in debug mesages. The driver
    may supply its own name, otherwise the core genrates the name
    ("plane-0", "plane-1" etc.).
    
    v2: kstrdup() the name passed by the caller (Jani)
    v3: Generate a default name if the driver doesn't supply one
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449592922-5545-7-git-send-email-ville.syrjala@linux.intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 4bea0a1151bc..c2f98ba2bb98 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1496,6 +1496,8 @@ struct drm_plane {
 	struct drm_device *dev;
 	struct list_head head;
 
+	char *name;
+
 	struct drm_modeset_lock mutex;
 
 	struct drm_mode_object base;

commit fa3ab4c2113c74a9eae9b6a718b167f7c8833e78
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Dec 8 18:41:53 2015 +0200

    drm: Add crtc->name and use it in debug messages
    
    Show a sensible name for the crtc in debug mesages. The driver may
    supply its own name, otherwise the core genrates the name
    ("crtc-0", "crtc-1" etc.).
    
    v2: kstrdup() the name passed by the caller (Jani)
    v3: Generate a default name if the driver doesn't supply one
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449592922-5545-6-git-send-email-ville.syrjala@linux.intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 5b5e6b650c11..4bea0a1151bc 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -712,6 +712,8 @@ struct drm_crtc {
 	struct device_node *port;
 	struct list_head head;
 
+	char *name;
+
 	/*
 	 * crtc mutex
 	 *

commit 13a3d91f17a5f7ed2acd275d18b6acfdb131fb15
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Dec 9 16:20:18 2015 +0200

    drm: Pass 'name' to drm_encoder_init()
    
    Done with coccinelle for the most part. However, it thinks '...' is
    part of the semantic patch, so I put an 'int DOTDOTDOT' placeholder
    in its place and got rid of it with sed afterwards.
    
    @@
    identifier dev, encoder, funcs;
    @@
     int drm_encoder_init(struct drm_device *dev,
                          struct drm_encoder *encoder,
                          const struct drm_encoder_funcs *funcs,
                          int encoder_type
    +                     ,const char *name, int DOTDOTDOT
                          )
    { ... }
    
    @@
    identifier dev, encoder, funcs;
    @@
     int drm_encoder_init(struct drm_device *dev,
                          struct drm_encoder *encoder,
                          const struct drm_encoder_funcs *funcs,
                          int encoder_type
    +                     ,const char *name, int DOTDOTDOT
                          );
    
    @@
    expression E1, E2, E3, E4;
    @@
     drm_encoder_init(E1, E2, E3, E4
    +                 ,NULL
                      )
    
    v2: Add ', or NULL...' to @name kernel doc (Jani)
        Annotate the function with __printf() attribute (Jani)
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449670818-2966-1-git-send-email-ville.syrjala@linux.intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index a6f0e25cbd51..5b5e6b650c11 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2196,10 +2196,11 @@ void drm_bridge_mode_set(struct drm_bridge *bridge,
 void drm_bridge_pre_enable(struct drm_bridge *bridge);
 void drm_bridge_enable(struct drm_bridge *bridge);
 
-extern int drm_encoder_init(struct drm_device *dev,
-			    struct drm_encoder *encoder,
-			    const struct drm_encoder_funcs *funcs,
-			    int encoder_type);
+extern __printf(5, 6)
+int drm_encoder_init(struct drm_device *dev,
+		     struct drm_encoder *encoder,
+		     const struct drm_encoder_funcs *funcs,
+		     int encoder_type, const char *name, ...);
 
 /**
  * drm_encoder_crtc_ok - can a given crtc drive a given encoder?

commit b0b3b7951114315d65398c27648705ca1c322faa
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Dec 9 16:19:55 2015 +0200

    drm: Pass 'name' to drm_universal_plane_init()
    
    Done with coccinelle for the most part. It choked on
    msm/mdp/mdp5/mdp5_plane.c like so:
    "BAD:!!!!!  enum drm_plane_type type;"
    No idea how to deal with that, so I just fixed that up
    by hand.
    
    Also it thinks '...' is part of the semantic patch, so I put an
    'int DOTDOTDOT' placeholder in its place and got rid of it with
    sed afterwards.
    
    I didn't convert drm_plane_init() since passing the varargs through
    would mean either cpp macros or va_list, and I figured we don't
    care about these legacy functions enough to warrant the extra pain.
    
    @@
    typedef uint32_t;
    identifier dev, plane, possible_crtcs, funcs, formats, format_count, type;
    @@
     int drm_universal_plane_init(struct drm_device *dev,
                                  struct drm_plane *plane,
                                  unsigned long possible_crtcs,
                                  const struct drm_plane_funcs *funcs,
                                  const uint32_t *formats,
                                  unsigned int format_count,
                                  enum drm_plane_type type
    +                             ,const char *name, int DOTDOTDOT
                                  )
    { ... }
    
    @@
    identifier dev, plane, possible_crtcs, funcs, formats, format_count, type;
    @@
     int drm_universal_plane_init(struct drm_device *dev,
                                  struct drm_plane *plane,
                                  unsigned long possible_crtcs,
                                  const struct drm_plane_funcs *funcs,
                                  const uint32_t *formats,
                                  unsigned int format_count,
                                  enum drm_plane_type type
    +                             ,const char *name, int DOTDOTDOT
                                  );
    
    @@
    expression E1, E2, E3, E4, E5, E6, E7;
    @@
     drm_universal_plane_init(E1, E2, E3, E4, E5, E6, E7
    +                         ,NULL
                              )
    
    v2: Split crtc and plane changes apart
        Pass NUL for no-name instead of ""
        Leave drm_plane_init() alone
    v3: Add ', or NULL...' to @name kernel doc (Jani)
        Annotate the function with __printf() attribute (Jani)
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449670795-2853-1-git-send-email-ville.syrjala@linux.intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f0127e7b0ee2..a6f0e25cbd51 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2214,13 +2214,15 @@ static inline bool drm_encoder_crtc_ok(struct drm_encoder *encoder,
 	return !!(encoder->possible_crtcs & drm_crtc_mask(crtc));
 }
 
-extern int drm_universal_plane_init(struct drm_device *dev,
-				    struct drm_plane *plane,
-				    unsigned long possible_crtcs,
-				    const struct drm_plane_funcs *funcs,
-				    const uint32_t *formats,
-				    unsigned int format_count,
-				    enum drm_plane_type type);
+extern __printf(8, 9)
+int drm_universal_plane_init(struct drm_device *dev,
+			     struct drm_plane *plane,
+			     unsigned long possible_crtcs,
+			     const struct drm_plane_funcs *funcs,
+			     const uint32_t *formats,
+			     unsigned int format_count,
+			     enum drm_plane_type type,
+			     const char *name, ...);
 extern int drm_plane_init(struct drm_device *dev,
 			  struct drm_plane *plane,
 			  unsigned long possible_crtcs,

commit f98828769c8838f526703ef180b3088a714af2f9
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Dec 9 16:19:31 2015 +0200

    drm: Pass 'name' to drm_crtc_init_with_planes()
    
    Done with coccinelle for the most part. However, it thinks '...' is
    part of the semantic patch, so I put an 'int DOTDOTDOT' placeholder
    in its place and got rid of it with sed afterwards.
    
    I didn't convert drm_crtc_init() since passing the varargs through
    would mean either cpp macros or va_list, and I figured we don't
    care about these legacy functions enough to warrant the extra pain.
    
    @@
    identifier dev, crtc, primary, cursor, funcs;
    @@
     int drm_crtc_init_with_planes(struct drm_device *dev,
                                   struct drm_crtc *crtc,
                                   struct drm_plane *primary, struct drm_plane *cursor,
                                   const struct drm_crtc_funcs *funcs
    +                              ,const char *name, int DOTDOTDOT
                                   )
    { ... }
    
    @@
    identifier dev, crtc, primary, cursor, funcs;
    @@
     int drm_crtc_init_with_planes(struct drm_device *dev,
                                   struct drm_crtc *crtc,
                                   struct drm_plane *primary, struct drm_plane *cursor,
                                   const struct drm_crtc_funcs *funcs
    +                              ,const char *name, int DOTDOTDOT
                                   );
    
    @@
    expression E1, E2, E3, E4, E5;
    @@
     drm_crtc_init_with_planes(E1, E2, E3, E4, E5
    +                          ,NULL
                               )
    
    v2: Split crtc and plane changes apart
        Pass NULL for no-name instead of ""
        Leave drm_crtc_init() alone
    v3: Add ', or NULL...' to @name kernel doc (Jani)
        Annotate the function with __printf() attribute (Jani)
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449670771-2751-1-git-send-email-ville.syrjala@linux.intel.com

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 4f587a5bc88f..f0127e7b0ee2 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -2144,11 +2144,13 @@ struct drm_prop_enum_list {
 	char *name;
 };
 
-extern int drm_crtc_init_with_planes(struct drm_device *dev,
-				     struct drm_crtc *crtc,
-				     struct drm_plane *primary,
-				     struct drm_plane *cursor,
-				     const struct drm_crtc_funcs *funcs);
+extern __printf(6, 7)
+int drm_crtc_init_with_planes(struct drm_device *dev,
+			      struct drm_crtc *crtc,
+			      struct drm_plane *primary,
+			      struct drm_plane *cursor,
+			      const struct drm_crtc_funcs *funcs,
+			      const char *name, ...);
 extern void drm_crtc_cleanup(struct drm_crtc *crtc);
 extern unsigned int drm_crtc_index(struct drm_crtc *crtc);
 

commit 9953f41799bdad34c367196541a7a9a3b6e13a6c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Dec 4 09:46:02 2015 +0100

    drm: Kerneldoc for drm_mode_config_funcs
    
    The meat here is definitely the detailed specs for what atomic_check
    and atomic_commit are supposed to do.
    
    And another candidate for a core vfunc that should be in a helper really
    (output_poll_changed this time around).
    
    v2: Feedback from Eric on irc:
    - spelling fixes.
    - spec what async should do
    - copy the event related paragraphs from page_flip and adjust
    - make it clear that a successful async commit is not allowed to leave
      the pipe dead or disabled.
    
    v3: Use FIXME comments to annotate functions that we should move to
    some helpers.
    
    v4: Suggestions from Thierry.
    
    Cc: Eric Anholt <eric@anholt.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449218769-16577-22-git-send-email-daniel.vetter@ffwll.ch
    Reviewed-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f09391f9cac0..4f587a5bc88f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1715,31 +1715,254 @@ struct drm_mode_set {
 
 /**
  * struct drm_mode_config_funcs - basic driver provided mode setting functions
- * @fb_create: create a new framebuffer object
- * @output_poll_changed: function to handle output configuration changes
- * @atomic_check: check whether a given atomic state update is possible
- * @atomic_commit: commit an atomic state update previously verified with
- * 	atomic_check()
- * @atomic_state_alloc: allocate a new atomic state
- * @atomic_state_clear: clear the atomic state
- * @atomic_state_free: free the atomic state
  *
  * Some global (i.e. not per-CRTC, connector, etc) mode setting functions that
  * involve drivers.
  */
 struct drm_mode_config_funcs {
+	/**
+	 * @fb_create:
+	 *
+	 * Create a new framebuffer object. The core does basic checks on the
+	 * requested metadata, but most of that is left to the driver. See
+	 * struct &drm_mode_fb_cmd2 for details.
+	 *
+	 * RETURNS:
+	 *
+	 * A new framebuffer with an initial reference count of 1 or a negative
+	 * error code encoded with ERR_PTR().
+	 */
 	struct drm_framebuffer *(*fb_create)(struct drm_device *dev,
 					     struct drm_file *file_priv,
 					     const struct drm_mode_fb_cmd2 *mode_cmd);
+
+	/**
+	 * @output_poll_changed:
+	 *
+	 * Callback used by helpers to inform the driver of output configuration
+	 * changes.
+	 *
+	 * Drivers implementing fbdev emulation with the helpers can call
+	 * drm_fb_helper_hotplug_changed from this hook to inform the fbdev
+	 * helper of output changes.
+	 *
+	 * FIXME:
+	 *
+	 * Except that there's no vtable for device-level helper callbacks
+	 * there's no reason this is a core function.
+	 */
 	void (*output_poll_changed)(struct drm_device *dev);
 
+	/**
+	 * @atomic_check:
+	 *
+	 * This is the only hook to validate an atomic modeset update. This
+	 * function must reject any modeset and state changes which the hardware
+	 * or driver doesn't support. This includes but is of course not limited
+	 * to:
+	 *
+	 *  - Checking that the modes, framebuffers, scaling and placement
+	 *    requirements and so on are within the limits of the hardware.
+	 *
+	 *  - Checking that any hidden shared resources are not oversubscribed.
+	 *    This can be shared PLLs, shared lanes, overall memory bandwidth,
+	 *    display fifo space (where shared between planes or maybe even
+	 *    CRTCs).
+	 *
+	 *  - Checking that virtualized resources exported to userspace are not
+	 *    oversubscribed. For various reasons it can make sense to expose
+	 *    more planes, crtcs or encoders than which are physically there. One
+	 *    example is dual-pipe operations (which generally should be hidden
+	 *    from userspace if when lockstepped in hardware, exposed otherwise),
+	 *    where a plane might need 1 hardware plane (if it's just on one
+	 *    pipe), 2 hardware planes (when it spans both pipes) or maybe even
+	 *    shared a hardware plane with a 2nd plane (if there's a compatible
+	 *    plane requested on the area handled by the other pipe).
+	 *
+	 *  - Check that any transitional state is possible and that if
+	 *    requested, the update can indeed be done in the vblank period
+	 *    without temporarily disabling some functions.
+	 *
+	 *  - Check any other constraints the driver or hardware might have.
+	 *
+	 *  - This callback also needs to correctly fill out the &drm_crtc_state
+	 *    in this update to make sure that drm_atomic_crtc_needs_modeset()
+	 *    reflects the nature of the possible update and returns true if and
+	 *    only if the update cannot be applied without tearing within one
+	 *    vblank on that CRTC. The core uses that information to reject
+	 *    updates which require a full modeset (i.e. blanking the screen, or
+	 *    at least pausing updates for a substantial amount of time) if
+	 *    userspace has disallowed that in its request.
+	 *
+	 *  - The driver also does not need to repeat basic input validation
+	 *    like done for the corresponding legacy entry points. The core does
+	 *    that before calling this hook.
+	 *
+	 * See the documentation of @atomic_commit for an exhaustive list of
+	 * error conditions which don't have to be checked at the
+	 * ->atomic_check() stage?
+	 *
+	 * See the documentation for struct &drm_atomic_state for how exactly
+	 * an atomic modeset update is described.
+	 *
+	 * Drivers using the atomic helpers can implement this hook using
+	 * drm_atomic_helper_check(), or one of the exported sub-functions of
+	 * it.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 on success or one of the below negative error codes:
+	 *
+	 *  - -EINVAL, if any of the above constraints are violated.
+	 *
+	 *  - -EDEADLK, when returned from an attempt to acquire an additional
+	 *    &drm_modeset_lock through drm_modeset_lock().
+	 *
+	 *  - -ENOMEM, if allocating additional state sub-structures failed due
+	 *    to lack of memory.
+	 *
+	 *  - -EINTR, -EAGAIN or -ERESTARTSYS, if the IOCTL should be restarted.
+	 *    This can either be due to a pending signal, or because the driver
+	 *    needs to completely bail out to recover from an exceptional
+	 *    situation like a GPU hang. From a userspace point all errors are
+	 *    treated equally.
+	 */
 	int (*atomic_check)(struct drm_device *dev,
-			    struct drm_atomic_state *a);
+			    struct drm_atomic_state *state);
+
+	/**
+	 * @atomic_commit:
+	 *
+	 * This is the only hook to commit an atomic modeset update. The core
+	 * guarantees that @atomic_check has been called successfully before
+	 * calling this function, and that nothing has been changed in the
+	 * interim.
+	 *
+	 * See the documentation for struct &drm_atomic_state for how exactly
+	 * an atomic modeset update is described.
+	 *
+	 * Drivers using the atomic helpers can implement this hook using
+	 * drm_atomic_helper_commit(), or one of the exported sub-functions of
+	 * it.
+	 *
+	 * Asynchronous commits (as indicated with the async parameter) must
+	 * do any preparatory work which might result in an unsuccessful commit
+	 * in the context of this callback. The only exceptions are hardware
+	 * errors resulting in -EIO. But even in that case the driver must
+	 * ensure that the display pipe is at least running, to avoid
+	 * compositors crashing when pageflips don't work. Anything else,
+	 * specifically committing the update to the hardware, should be done
+	 * without blocking the caller. For updates which do not require a
+	 * modeset this must be guaranteed.
+	 *
+	 * The driver must wait for any pending rendering to the new
+	 * framebuffers to complete before executing the flip. It should also
+	 * wait for any pending rendering from other drivers if the underlying
+	 * buffer is a shared dma-buf. Asynchronous commits must not wait for
+	 * rendering in the context of this callback.
+	 *
+	 * An application can request to be notified when the atomic commit has
+	 * completed. These events are per-CRTC and can be distinguished by the
+	 * CRTC index supplied in &drm_event to userspace.
+	 *
+	 * The drm core will supply a struct &drm_event in the event
+	 * member of each CRTC's &drm_crtc_state structure. This can be handled by the
+	 * drm_crtc_send_vblank_event() function, which the driver should call on
+	 * the provided event upon completion of the atomic commit. Note that if
+	 * the driver supports vblank signalling and timestamping the vblank
+	 * counters and timestamps must agree with the ones returned from page
+	 * flip events. With the current vblank helper infrastructure this can
+	 * be achieved by holding a vblank reference while the page flip is
+	 * pending, acquired through drm_crtc_vblank_get() and released with
+	 * drm_crtc_vblank_put(). Drivers are free to implement their own vblank
+	 * counter and timestamp tracking though, e.g. if they have accurate
+	 * timestamp registers in hardware.
+	 *
+	 * NOTE:
+	 *
+	 * Drivers are not allowed to shut down any display pipe successfully
+	 * enabled through an atomic commit on their own. Doing so can result in
+	 * compositors crashing if a page flip is suddenly rejected because the
+	 * pipe is off.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 on success or one of the below negative error codes:
+	 *
+	 *  - -EBUSY, if an asynchronous updated is requested and there is
+	 *    an earlier updated pending. Drivers are allowed to support a queue
+	 *    of outstanding updates, but currently no driver supports that.
+	 *    Note that drivers must wait for preceding updates to complete if a
+	 *    synchronous update is requested, they are not allowed to fail the
+	 *    commit in that case.
+	 *
+	 *  - -ENOMEM, if the driver failed to allocate memory. Specifically
+	 *    this can happen when trying to pin framebuffers, which must only
+	 *    be done when committing the state.
+	 *
+	 *  - -ENOSPC, as a refinement of the more generic -ENOMEM to indicate
+	 *    that the driver has run out of vram, iommu space or similar GPU
+	 *    address space needed for framebuffer.
+	 *
+	 *  - -EIO, if the hardware completely died.
+	 *
+	 *  - -EINTR, -EAGAIN or -ERESTARTSYS, if the IOCTL should be restarted.
+	 *    This can either be due to a pending signal, or because the driver
+	 *    needs to completely bail out to recover from an exceptional
+	 *    situation like a GPU hang. From a userspace point of view all errors are
+	 *    treated equally.
+	 *
+	 * This list is exhaustive. Specifically this hook is not allowed to
+	 * return -EINVAL (any invalid requests should be caught in
+	 * @atomic_check) or -EDEADLK (this function must not acquire
+	 * additional modeset locks).
+	 */
 	int (*atomic_commit)(struct drm_device *dev,
-			     struct drm_atomic_state *a,
+			     struct drm_atomic_state *state,
 			     bool async);
+
+	/**
+	 * @atomic_state_alloc:
+	 *
+	 * This optional hook can be used by drivers that want to subclass struct
+	 * &drm_atomic_state to be able to track their own driver-private global
+	 * state easily. If this hook is implemented, drivers must also
+	 * implement @atomic_state_clear and @atomic_state_free.
+	 *
+	 * RETURNS:
+	 *
+	 * A new &drm_atomic_state on success or NULL on failure.
+	 */
 	struct drm_atomic_state *(*atomic_state_alloc)(struct drm_device *dev);
+
+	/**
+	 * @atomic_state_clear:
+	 *
+	 * This hook must clear any driver private state duplicated into the
+	 * passed-in &drm_atomic_state. This hook is called when the caller
+	 * encountered a &drm_modeset_lock deadlock and needs to drop all
+	 * already acquired locks as part of the deadlock avoidance dance
+	 * implemented in drm_modeset_lock_backoff().
+	 *
+	 * Any duplicated state must be invalidated since a concurrent atomic
+	 * update might change it, and the drm atomic interfaces always apply
+	 * updates as relative changes to the current state.
+	 *
+	 * Drivers that implement this must call drm_atomic_state_default_clear()
+	 * to clear common state.
+	 */
 	void (*atomic_state_clear)(struct drm_atomic_state *state);
+
+	/**
+	 * @atomic_state_free:
+	 *
+	 * This hook needs driver private resources and the &drm_atomic_state
+	 * itself. Note that the core first calls drm_atomic_state_clear() to
+	 * avoid code duplicate between the clear and free hooks.
+	 *
+	 * Drivers that implement this must call drm_atomic_state_default_free()
+	 * to release common resources.
+	 */
 	void (*atomic_state_free)(struct drm_atomic_state *state);
 };
 

commit c6b0ca3ea8366d1954c7825d0f67bc833b8e10df
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Dec 4 09:46:01 2015 +0100

    drm: Add kerneldoc for drm_framebuffer_funcs
    
    While typing these I noticed that ->dirty is a bit a can of worms
    and even supports blt/fill semantics ... shocked me a bit.
    
    Oh well it's defined in a way that nothing bad (just a bit of inefficiency)
    will happen for drivers which supports this. So I didn't bother copying
    the detailed spec into the new kerneldoc.
    
    v2: Suggestions from Thierry.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449218769-16577-21-git-send-email-daniel.vetter@ffwll.ch
    Reviewed-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 44a98082d409..f09391f9cac0 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -162,23 +162,55 @@ struct drm_tile_group {
 	u8 group_data[8];
 };
 
+/**
+ * struct drm_framebuffer_funcs - framebuffer hooks
+ */
 struct drm_framebuffer_funcs {
-	/* note: use drm_framebuffer_remove() */
+	/**
+	 * @destroy:
+	 *
+	 * Clean up framebuffer resources, specifically also unreference the
+	 * backing storage. The core guarantees to call this function for every
+	 * framebuffer successfully created by ->fb_create() in
+	 * &drm_mode_config_funcs.
+	 */
 	void (*destroy)(struct drm_framebuffer *framebuffer);
+
+	/**
+	 * @create_handle:
+	 *
+	 * Create a buffer handle in the driver-specific buffer manager (either
+	 * GEM or TTM) valid for the passed-in struct &drm_file. This is used by
+	 * the core to implement the GETFB IOCTL, which returns (for
+	 * sufficiently priviledged user) also a native buffer handle. This can
+	 * be used for seamless transitions between modesetting clients by
+	 * copying the current screen contents to a private buffer and blending
+	 * between that and the new contents.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 on success or a negative error code on failure.
+	 */
 	int (*create_handle)(struct drm_framebuffer *fb,
 			     struct drm_file *file_priv,
 			     unsigned int *handle);
-	/*
-	 * Optional callback for the dirty fb ioctl.
+	/**
+	 * @dirty:
 	 *
-	 * Userspace can notify the driver via this callback
-	 * that a area of the framebuffer has changed and should
-	 * be flushed to the display hardware.
+	 * Optional callback for the dirty fb IOCTL.
 	 *
-	 * See documentation in drm_mode.h for the struct
-	 * drm_mode_fb_dirty_cmd for more information as all
-	 * the semantics and arguments have a one to one mapping
-	 * on this function.
+	 * Userspace can notify the driver via this callback that an area of the
+	 * framebuffer has changed and should be flushed to the display
+	 * hardware. This can also be used internally, e.g. by the fbdev
+	 * emulation, though that's not the case currently.
+	 *
+	 * See documentation in drm_mode.h for the struct drm_mode_fb_dirty_cmd
+	 * for more information as all the semantics and arguments have a one to
+	 * one mapping on this function.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 on success or a negative error code on failure.
 	 */
 	int (*dirty)(struct drm_framebuffer *framebuffer,
 		     struct drm_file *file_priv, unsigned flags,
@@ -627,7 +659,7 @@ struct drm_crtc_funcs {
 	 * @atomic_get_property:
 	 *
 	 * Reads out the decoded driver-private property. This is used to
-	 * implement the GETCRTC ioctl.
+	 * implement the GETCRTC IOCTL.
 	 *
 	 * Do not call this function directly, use
 	 * drm_atomic_crtc_get_property() instead.
@@ -670,7 +702,7 @@ struct drm_crtc_funcs {
  * @properties: property tracking for this CRTC
  * @state: current atomic state for this CRTC
  * @acquire_ctx: per-CRTC implicit acquire context used by atomic drivers for
- * 	legacy ioctls
+ * 	legacy IOCTLs
  *
  * Each CRTC may have one or more connectors associated with it.  This structure
  * allows the CRTC to be controlled.
@@ -724,7 +756,7 @@ struct drm_crtc {
 	struct drm_crtc_state *state;
 
 	/*
-	 * For legacy crtc ioctls so that atomic drivers can get at the locking
+	 * For legacy crtc IOCTLs so that atomic drivers can get at the locking
 	 * acquire context.
 	 */
 	struct drm_modeset_acquire_ctx *acquire_ctx;
@@ -968,7 +1000,7 @@ struct drm_connector_funcs {
 	 * @atomic_get_property:
 	 *
 	 * Reads out the decoded driver-private property. This is used to
-	 * implement the GETCONNECTOR ioctl.
+	 * implement the GETCONNECTOR IOCTL.
 	 *
 	 * Do not call this function directly, use
 	 * drm_atomic_connector_get_property() instead.
@@ -1269,7 +1301,7 @@ struct drm_plane_funcs {
 	 * @disable_plane:
 	 *
 	 * This is the legacy entry point to disable the plane. The DRM core
-	 * calls this method in response to a DRM_IOCTL_MODE_SETPLANE ioctl call
+	 * calls this method in response to a DRM_IOCTL_MODE_SETPLANE IOCTL call
 	 * with the frame buffer ID set to 0.  Disabled planes must not be
 	 * processed by the CRTC.
 	 *
@@ -1413,7 +1445,7 @@ struct drm_plane_funcs {
 	 * @atomic_get_property:
 	 *
 	 * Reads out the decoded driver-private property. This is used to
-	 * implement the GETPLANE ioctl.
+	 * implement the GETPLANE IOCTL.
 	 *
 	 * Do not call this function directly, use
 	 * drm_atomic_plane_get_property() instead.
@@ -1628,7 +1660,7 @@ struct drm_bridge {
  * struct drm_atomic_state - the global state object for atomic updates
  * @dev: parent DRM device
  * @allow_modeset: allow full modeset
- * @legacy_cursor_update: hint to enforce legacy cursor ioctl semantics
+ * @legacy_cursor_update: hint to enforce legacy cursor IOCTL semantics
  * @planes: pointer to array of plane pointers
  * @plane_states: pointer to array of plane states pointers
  * @crtcs: pointer to array of CRTC pointers
@@ -1716,7 +1748,7 @@ struct drm_mode_config_funcs {
  * @mutex: mutex protecting KMS related lists and structures
  * @connection_mutex: ww mutex protecting connector state and routing
  * @acquire_ctx: global implicit acquire context used by atomic drivers for
- * 	legacy ioctls
+ * 	legacy IOCTLs
  * @idr_mutex: mutex for KMS ID allocation and management
  * @crtc_idr: main KMS ID tracking object
  * @fb_lock: mutex to protect fb state and lists

commit f6da8c6e5ee378c82f20ad07f84556befc7b58e9
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Dec 4 09:46:00 2015 +0100

    drm: document drm_crtc_funcs
    
    And merge any docbook we have into the kerneldoc comments.
    
    Since it's a legacy entry point with only two implementation (one each
    in atomic and legacy crtc helpers) I've made the documentation for
    set_config fairly sparse - no one should ever need to look at this
    again, all the ABI we have is baked into code.
    
    For ->page_flip otoh I kept all the extensive docs from the docbook
    and even extended it where it was lacking: Currently we have a pile of
    legacy page_flip implemantations, and even for atomic drivers there's
    not yet a standard implementation in the helpers. Which means every
    driver needs to implement this itself, and precise specs are really
    valuable.
    
    Otherwise there's just cursor, which really just boils down to "use at
    least universal planes". And gamma tables (where we have a bit a mess
    with the fbdev helper gamma hooks).
    
    v2: Spelling fixes (Eric).
    
    v3: Suggestions from Thierry.
    
    Cc: Eric Anholt <eric@anholt.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449218769-16577-20-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 819eb45821cd..44a98082d409 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -320,12 +320,6 @@ struct drm_crtc_state {
 
 /**
  * struct drm_crtc_funcs - control CRTCs for a given device
- * @cursor_set: setup the cursor
- * @cursor_set2: setup the cursor with hotspot, superseeds @cursor_set if set
- * @cursor_move: move the cursor
- * @gamma_set: specify color ramp for CRTC
- * @set_config: apply a new CRTC configuration
- * @page_flip: initiate a page flip
  *
  * The drm_crtc_funcs structure is the central CRTC management structure
  * in the DRM.  Each CRTC controls one or more connectors (note that the name
@@ -349,15 +343,86 @@ struct drm_crtc_funcs {
 	 */
 	void (*reset)(struct drm_crtc *crtc);
 
-	/* cursor controls */
+	/**
+	 * @cursor_set:
+	 *
+	 * Update the cursor image. The cursor position is relative to the CRTC
+	 * and can be partially or fully outside of the visible area.
+	 *
+	 * Note that contrary to all other KMS functions the legacy cursor entry
+	 * points don't take a framebuffer object, but instead take directly a
+	 * raw buffer object id from the driver's buffer manager (which is
+	 * either GEM or TTM for current drivers).
+	 *
+	 * This entry point is deprecated, drivers should instead implement
+	 * universal plane support and register a proper cursor plane using
+	 * drm_crtc_init_with_planes().
+	 *
+	 * This callback is optional
+	 *
+	 * RETURNS:
+	 *
+	 * 0 on success or a negative error code on failure.
+	 */
 	int (*cursor_set)(struct drm_crtc *crtc, struct drm_file *file_priv,
 			  uint32_t handle, uint32_t width, uint32_t height);
+
+	/**
+	 * @cursor_set2:
+	 *
+	 * Update the cursor image, including hotspot information. The hotspot
+	 * must not affect the cursor position in CRTC coordinates, but is only
+	 * meant as a hint for virtualized display hardware to coordinate the
+	 * guests and hosts cursor position. The cursor hotspot is relative to
+	 * the cursor image. Otherwise this works exactly like @cursor_set.
+	 *
+	 * This entry point is deprecated, drivers should instead implement
+	 * universal plane support and register a proper cursor plane using
+	 * drm_crtc_init_with_planes().
+	 *
+	 * This callback is optional.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 on success or a negative error code on failure.
+	 */
 	int (*cursor_set2)(struct drm_crtc *crtc, struct drm_file *file_priv,
 			   uint32_t handle, uint32_t width, uint32_t height,
 			   int32_t hot_x, int32_t hot_y);
+
+	/**
+	 * @cursor_move:
+	 *
+	 * Update the cursor position. The cursor does not need to be visible
+	 * when this hook is called.
+	 *
+	 * This entry point is deprecated, drivers should instead implement
+	 * universal plane support and register a proper cursor plane using
+	 * drm_crtc_init_with_planes().
+	 *
+	 * This callback is optional.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 on success or a negative error code on failure.
+	 */
 	int (*cursor_move)(struct drm_crtc *crtc, int x, int y);
 
-	/* Set gamma on the CRTC */
+	/**
+	 * @gamma_set:
+	 *
+	 * Set gamma on the CRTC.
+	 *
+	 * This callback is optional.
+	 *
+	 * NOTE:
+	 *
+	 * Drivers that support gamma tables and also fbdev emulation through
+	 * the provided helper library need to take care to fill out the gamma
+	 * hooks for both. Currently there's a bit an unfortunate duplication
+	 * going on, which should eventually be unified to just one set of
+	 * hooks.
+	 */
 	void (*gamma_set)(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,
 			  uint32_t start, uint32_t size);
 
@@ -370,16 +435,83 @@ struct drm_crtc_funcs {
 	 */
 	void (*destroy)(struct drm_crtc *crtc);
 
+	/**
+	 * @set_config:
+	 *
+	 * This is the main legacy entry point to change the modeset state on a
+	 * CRTC. All the details of the desired configuration are passed in a
+	 * struct &drm_mode_set - see there for details.
+	 *
+	 * Drivers implementing atomic modeset should use
+	 * drm_atomic_helper_set_config() to implement this hook.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 on success or a negative error code on failure.
+	 */
 	int (*set_config)(struct drm_mode_set *set);
 
-	/*
-	 * Flip to the given framebuffer.  This implements the page
-	 * flip ioctl described in drm_mode.h, specifically, the
-	 * implementation must return immediately and block all
-	 * rendering to the current fb until the flip has completed.
-	 * If userspace set the event flag in the ioctl, the event
-	 * argument will point to an event to send back when the flip
-	 * completes, otherwise it will be NULL.
+	/**
+	 * @page_flip:
+	 *
+	 * Legacy entry point to schedule a flip to the given framebuffer.
+	 *
+	 * Page flipping is a synchronization mechanism that replaces the frame
+	 * buffer being scanned out by the CRTC with a new frame buffer during
+	 * vertical blanking, avoiding tearing (except when requested otherwise
+	 * through the DRM_MODE_PAGE_FLIP_ASYNC flag). When an application
+	 * requests a page flip the DRM core verifies that the new frame buffer
+	 * is large enough to be scanned out by the CRTC in the currently
+	 * configured mode and then calls the CRTC ->page_flip() operation with a
+	 * pointer to the new frame buffer.
+	 *
+	 * The driver must wait for any pending rendering to the new framebuffer
+	 * to complete before executing the flip. It should also wait for any
+	 * pending rendering from other drivers if the underlying buffer is a
+	 * shared dma-buf.
+	 *
+	 * An application can request to be notified when the page flip has
+	 * completed. The drm core will supply a struct &drm_event in the event
+	 * parameter in this case. This can be handled by the
+	 * drm_crtc_send_vblank_event() function, which the driver should call on
+	 * the provided event upon completion of the flip. Note that if
+	 * the driver supports vblank signalling and timestamping the vblank
+	 * counters and timestamps must agree with the ones returned from page
+	 * flip events. With the current vblank helper infrastructure this can
+	 * be achieved by holding a vblank reference while the page flip is
+	 * pending, acquired through drm_crtc_vblank_get() and released with
+	 * drm_crtc_vblank_put(). Drivers are free to implement their own vblank
+	 * counter and timestamp tracking though, e.g. if they have accurate
+	 * timestamp registers in hardware.
+	 *
+	 * FIXME:
+	 *
+	 * Up to that point drivers need to manage events themselves and can use
+	 * even->base.list freely for that. Specifically they need to ensure
+	 * that they don't send out page flip (or vblank) events for which the
+	 * corresponding drm file has been closed already. The drm core
+	 * unfortunately does not (yet) take care of that. Therefore drivers
+	 * currently must clean up and release pending events in their
+	 * ->preclose driver function.
+	 *
+	 * This callback is optional.
+	 *
+	 * NOTE:
+	 *
+	 * Very early versions of the KMS ABI mandated that the driver must
+	 * block (but not reject) any rendering to the old framebuffer until the
+	 * flip operation has completed and the old framebuffer is no longer
+	 * visible. This requirement has been lifted, and userspace is instead
+	 * expected to request delivery of an event and wait with recycling old
+	 * buffers until such has been received.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 on success or a negative error code on failure. Note that if a
+	 * ->page_flip() operation is already pending the callback should return
+	 * -EBUSY. Pageflips on a disabled CRTC (either by setting a NULL mode
+	 * or just runtime disabled through DPMS respectively the new atomic
+	 * "ACTIVE" state) should result in an -EINVAL error code.
 	 */
 	int (*page_flip)(struct drm_crtc *crtc,
 			 struct drm_framebuffer *fb,

commit 6fe14acd496e7ca27d6dfbeaa71b4f16656d10c2
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Dec 4 09:45:58 2015 +0100

    drm: Document drm_connector_funcs
    
    The special case here is that both ->detect and ->force are actually
    functions only called by the probe helpers and hence really shouldn't
    be here. But since they've used by pretty much every driver I figured
    it's better to just document this for now instead of holding this doc
    patch hostage until that's all fixed. For that reason also group force
    right next to detect.
    
    v2: Use FIXME comments to annotate where we should move a hook to
    helpers.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449218769-16577-18-git-send-email-daniel.vetter@ffwll.ch
    Reviewed-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index e75b06b61143..819eb45821cd 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -617,16 +617,28 @@ struct drm_connector_state {
 
 /**
  * struct drm_connector_funcs - control connectors on a given device
- * @dpms: set power state
- * @detect: is this connector active?
- * @fill_modes: fill mode list for this connector
- * @force: notify the driver that the connector is forced on
  *
  * Each CRTC may have one or more connectors attached to it.  The functions
  * below allow the core DRM code to control connectors, enumerate available modes,
  * etc.
  */
 struct drm_connector_funcs {
+	/**
+	 * @dpms:
+	 *
+	 * Legacy entry point to set the per-connector DPMS state. Legacy DPMS
+	 * is exposed as a standard property on the connector, but diverted to
+	 * this callback in the drm core. Note that atomic drivers don't
+	 * implement the 4 level DPMS support on the connector any more, but
+	 * instead only have an on/off "ACTIVE" property on the CRTC object.
+	 *
+	 * Drivers implementing atomic modeset should use
+	 * drm_atomic_helper_connector_dpms() to implement this hook.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 on success or a negative error code on failure.
+	 */
 	int (*dpms)(struct drm_connector *connector, int mode);
 
 	/**
@@ -641,14 +653,67 @@ struct drm_connector_funcs {
 	 */
 	void (*reset)(struct drm_connector *connector);
 
-	/* Check to see if anything is attached to the connector.
-	 * @force is set to false whilst polling, true when checking the
-	 * connector due to user request. @force can be used by the driver
-	 * to avoid expensive, destructive operations during automated
-	 * probing.
+	/**
+	 * @detect:
+	 *
+	 * Check to see if anything is attached to the connector. The parameter
+	 * force is set to false whilst polling, true when checking the
+	 * connector due to a user request. force can be used by the driver to
+	 * avoid expensive, destructive operations during automated probing.
+	 *
+	 * FIXME:
+	 *
+	 * Note that this hook is only called by the probe helper. It's not in
+	 * the helper library vtable purely for historical reasons. The only DRM
+	 * core	entry point to probe connector state is @fill_modes.
+	 *
+	 * RETURNS:
+	 *
+	 * drm_connector_status indicating the connector's status.
 	 */
 	enum drm_connector_status (*detect)(struct drm_connector *connector,
 					    bool force);
+
+	/**
+	 * @force:
+	 *
+	 * This function is called to update internal encoder state when the
+	 * connector is forced to a certain state by userspace, either through
+	 * the sysfs interfaces or on the kernel cmdline. In that case the
+	 * @detect callback isn't called.
+	 *
+	 * FIXME:
+	 *
+	 * Note that this hook is only called by the probe helper. It's not in
+	 * the helper library vtable purely for historical reasons. The only DRM
+	 * core	entry point to probe connector state is @fill_modes.
+	 */
+	void (*force)(struct drm_connector *connector);
+
+	/**
+	 * @fill_modes:
+	 *
+	 * Entry point for output detection and basic mode validation. The
+	 * driver should reprobe the output if needed (e.g. when hotplug
+	 * handling is unreliable), add all detected modes to connector->modes
+	 * and filter out any the device can't support in any configuration. It
+	 * also needs to filter out any modes wider or higher than the
+	 * parameters max_width and max_height indicate.
+	 *
+	 * The drivers must also prune any modes no longer valid from
+	 * connector->modes. Furthermore it must update connector->status and
+	 * connector->edid.  If no EDID has been received for this output
+	 * connector->edid must be NULL.
+	 *
+	 * Drivers using the probe helpers should use
+	 * drm_helper_probe_single_connector_modes() or
+	 * drm_helper_probe_single_connector_modes_nomerge() to implement this
+	 * function.
+	 *
+	 * RETURNS:
+	 *
+	 * The number of modes detected and filled into connector->modes.
+	 */
 	int (*fill_modes)(struct drm_connector *connector, uint32_t max_width, uint32_t max_height);
 
 	/**
@@ -679,7 +744,6 @@ struct drm_connector_funcs {
 	 * connector hotplugging (e.g. DisplayPort MST).
 	 */
 	void (*destroy)(struct drm_connector *connector);
-	void (*force)(struct drm_connector *connector);
 
 	/**
 	 * @atomic_duplicate_state:

commit 813b0f3e00d402279718403aeb621c965f97180e
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Dec 4 09:45:55 2015 +0100

    drm: Remove crtc/connector->save/restore hooks
    
    They're not how system suspend/resume should be done with atomic
    (there's new helpers for that developed by Thierry Reding), and for
    legacy drivers this really should be a helper hook and not a core one.
    
    But there's not even helper code to use them, and only 2 drivers
    (which now have their own private hooks) set them. Ditch them.
    
    Saves me typing some kerneldoc, too ;-)
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449218769-16577-15-git-send-email-daniel.vetter@ffwll.ch
    Reviewed-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 1bcfa094af16..e75b06b61143 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -320,8 +320,6 @@ struct drm_crtc_state {
 
 /**
  * struct drm_crtc_funcs - control CRTCs for a given device
- * @save: save CRTC state
- * @restore: restore CRTC state
  * @cursor_set: setup the cursor
  * @cursor_set2: setup the cursor with hotspot, superseeds @cursor_set if set
  * @cursor_move: move the cursor
@@ -339,11 +337,6 @@ struct drm_crtc_state {
  * bus accessors.
  */
 struct drm_crtc_funcs {
-	/* Save CRTC state */
-	void (*save)(struct drm_crtc *crtc); /* suspend? */
-	/* Restore CRTC state */
-	void (*restore)(struct drm_crtc *crtc); /* resume? */
-
 	/**
 	 * @reset:
 	 *
@@ -625,8 +618,6 @@ struct drm_connector_state {
 /**
  * struct drm_connector_funcs - control connectors on a given device
  * @dpms: set power state
- * @save: save connector state
- * @restore: restore connector state
  * @detect: is this connector active?
  * @fill_modes: fill mode list for this connector
  * @force: notify the driver that the connector is forced on
@@ -637,8 +628,6 @@ struct drm_connector_state {
  */
 struct drm_connector_funcs {
 	int (*dpms)(struct drm_connector *connector, int mode);
-	void (*save)(struct drm_connector *connector);
-	void (*restore)(struct drm_connector *connector);
 
 	/**
 	 * @reset:

commit 88548636406c08ef4b3d32d12d1860a216389177
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Dec 4 09:45:48 2015 +0100

    drm: Update drm_plane_funcs kerneldoc
    
    - Merge the docbook into the kerneldoc comments.
    
    - Spec in detail the precise semantics of the callbacks.
    
    - For consistency in wording and easier review roll out kerneldoc also
      for crtc, encoder and connector for the standard hooks they share
      with planes.
    
    v2: Suggestions from Thierry.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449218769-16577-8-git-send-email-daniel.vetter@ffwll.ch
    Reviewed-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 7f80fae1a45f..1bcfa094af16 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -322,21 +322,12 @@ struct drm_crtc_state {
  * struct drm_crtc_funcs - control CRTCs for a given device
  * @save: save CRTC state
  * @restore: restore CRTC state
- * @reset: reset CRTC after state has been invalidated (e.g. resume)
  * @cursor_set: setup the cursor
  * @cursor_set2: setup the cursor with hotspot, superseeds @cursor_set if set
  * @cursor_move: move the cursor
  * @gamma_set: specify color ramp for CRTC
- * @destroy: deinit and free object
- * @set_property: called when a property is changed
  * @set_config: apply a new CRTC configuration
  * @page_flip: initiate a page flip
- * @atomic_duplicate_state: duplicate the atomic state for this CRTC
- * @atomic_destroy_state: destroy an atomic state for this CRTC
- * @atomic_set_property: set a property on an atomic state for this CRTC
- *    (do not call directly, use drm_atomic_crtc_set_property())
- * @atomic_get_property: get a property on an atomic state for this CRTC
- *    (do not call directly, use drm_atomic_crtc_get_property())
  *
  * The drm_crtc_funcs structure is the central CRTC management structure
  * in the DRM.  Each CRTC controls one or more connectors (note that the name
@@ -352,7 +343,17 @@ struct drm_crtc_funcs {
 	void (*save)(struct drm_crtc *crtc); /* suspend? */
 	/* Restore CRTC state */
 	void (*restore)(struct drm_crtc *crtc); /* resume? */
-	/* Reset CRTC state */
+
+	/**
+	 * @reset:
+	 *
+	 * Reset CRTC hardware and software state to off. This function isn't
+	 * called by the core directly, only through drm_mode_config_reset().
+	 * It's not a helper hook only for historical reasons.
+	 *
+	 * Atomic drivers can use drm_atomic_helper_crtc_reset() to reset
+	 * atomic state using this hook.
+	 */
 	void (*reset)(struct drm_crtc *crtc);
 
 	/* cursor controls */
@@ -366,7 +367,14 @@ struct drm_crtc_funcs {
 	/* Set gamma on the CRTC */
 	void (*gamma_set)(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,
 			  uint32_t start, uint32_t size);
-	/* Object destroy routine */
+
+	/**
+	 * @destroy:
+	 *
+	 * Clean up plane resources. This is only called at driver unload time
+	 * through drm_mode_config_cleanup() since a CRTC cannot be hotplugged
+	 * in DRM.
+	 */
 	void (*destroy)(struct drm_crtc *crtc);
 
 	int (*set_config)(struct drm_mode_set *set);
@@ -385,17 +393,129 @@ struct drm_crtc_funcs {
 			 struct drm_pending_vblank_event *event,
 			 uint32_t flags);
 
+	/**
+	 * @set_property:
+	 *
+	 * This is the legacy entry point to update a property attached to the
+	 * CRTC.
+	 *
+	 * Drivers implementing atomic modeset should use
+	 * drm_atomic_helper_crtc_set_property() to implement this hook.
+	 *
+	 * This callback is optional if the driver does not support any legacy
+	 * driver-private properties.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 on success or a negative error code on failure.
+	 */
 	int (*set_property)(struct drm_crtc *crtc,
 			    struct drm_property *property, uint64_t val);
 
-	/* atomic update handling */
+	/**
+	 * @atomic_duplicate_state:
+	 *
+	 * Duplicate the current atomic state for this CRTC and return it.
+	 * The core and helpers gurantee that any atomic state duplicated with
+	 * this hook and still owned by the caller (i.e. not transferred to the
+	 * driver by calling ->atomic_commit() from struct
+	 * &drm_mode_config_funcs) will be cleaned up by calling the
+	 * @atomic_destroy_state hook in this structure.
+	 *
+	 * Atomic drivers which don't subclass struct &drm_crtc should use
+	 * drm_atomic_helper_crtc_duplicate_state(). Drivers that subclass the
+	 * state structure to extend it with driver-private state should use
+	 * __drm_atomic_helper_crtc_duplicate_state() to make sure shared state is
+	 * duplicated in a consistent fashion across drivers.
+	 *
+	 * It is an error to call this hook before crtc->state has been
+	 * initialized correctly.
+	 *
+	 * NOTE:
+	 *
+	 * If the duplicate state references refcounted resources this hook must
+	 * acquire a reference for each of them. The driver must release these
+	 * references again in @atomic_destroy_state.
+	 *
+	 * RETURNS:
+	 *
+	 * Duplicated atomic state or NULL when the allocation failed.
+	 */
 	struct drm_crtc_state *(*atomic_duplicate_state)(struct drm_crtc *crtc);
+
+	/**
+	 * @atomic_destroy_state:
+	 *
+	 * Destroy a state duplicated with @atomic_duplicate_state and release
+	 * or unreference all resources it references
+	 */
 	void (*atomic_destroy_state)(struct drm_crtc *crtc,
 				     struct drm_crtc_state *state);
+
+	/**
+	 * @atomic_set_property:
+	 *
+	 * Decode a driver-private property value and store the decoded value
+	 * into the passed-in state structure. Since the atomic core decodes all
+	 * standardized properties (even for extensions beyond the core set of
+	 * properties which might not be implemented by all drivers) this
+	 * requires drivers to subclass the state structure.
+	 *
+	 * Such driver-private properties should really only be implemented for
+	 * truly hardware/vendor specific state. Instead it is preferred to
+	 * standardize atomic extension and decode the properties used to expose
+	 * such an extension in the core.
+	 *
+	 * Do not call this function directly, use
+	 * drm_atomic_crtc_set_property() instead.
+	 *
+	 * This callback is optional if the driver does not support any
+	 * driver-private atomic properties.
+	 *
+	 * NOTE:
+	 *
+	 * This function is called in the state assembly phase of atomic
+	 * modesets, which can be aborted for any reason (including on
+	 * userspace's request to just check whether a configuration would be
+	 * possible). Drivers MUST NOT touch any persistent state (hardware or
+	 * software) or data structures except the passed in @state parameter.
+	 *
+	 * Also since userspace controls in which order properties are set this
+	 * function must not do any input validation (since the state update is
+	 * incomplete and hence likely inconsistent). Instead any such input
+	 * validation must be done in the various atomic_check callbacks.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 if the property has been found, -EINVAL if the property isn't
+	 * implemented by the driver (which should never happen, the core only
+	 * asks for properties attached to this CRTC). No other validation is
+	 * allowed by the driver. The core already checks that the property
+	 * value is within the range (integer, valid enum value, ...) the driver
+	 * set when registering the property.
+	 */
 	int (*atomic_set_property)(struct drm_crtc *crtc,
 				   struct drm_crtc_state *state,
 				   struct drm_property *property,
 				   uint64_t val);
+	/**
+	 * @atomic_get_property:
+	 *
+	 * Reads out the decoded driver-private property. This is used to
+	 * implement the GETCRTC ioctl.
+	 *
+	 * Do not call this function directly, use
+	 * drm_atomic_crtc_get_property() instead.
+	 *
+	 * This callback is optional if the driver does not support any
+	 * driver-private atomic properties.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 on success, -EINVAL if the property isn't implemented by the
+	 * driver (which should never happen, the core only asks for
+	 * properties attached to this CRTC).
+	 */
 	int (*atomic_get_property)(struct drm_crtc *crtc,
 				   const struct drm_crtc_state *state,
 				   struct drm_property *property,
@@ -507,18 +627,9 @@ struct drm_connector_state {
  * @dpms: set power state
  * @save: save connector state
  * @restore: restore connector state
- * @reset: reset connector after state has been invalidated (e.g. resume)
  * @detect: is this connector active?
  * @fill_modes: fill mode list for this connector
- * @set_property: property for this connector may need an update
- * @destroy: make object go away
  * @force: notify the driver that the connector is forced on
- * @atomic_duplicate_state: duplicate the atomic state for this connector
- * @atomic_destroy_state: destroy an atomic state for this connector
- * @atomic_set_property: set a property on an atomic state for this connector
- *    (do not call directly, use drm_atomic_connector_set_property())
- * @atomic_get_property: get a property on an atomic state for this connector
- *    (do not call directly, use drm_atomic_connector_get_property())
  *
  * Each CRTC may have one or more connectors attached to it.  The functions
  * below allow the core DRM code to control connectors, enumerate available modes,
@@ -528,6 +639,17 @@ struct drm_connector_funcs {
 	int (*dpms)(struct drm_connector *connector, int mode);
 	void (*save)(struct drm_connector *connector);
 	void (*restore)(struct drm_connector *connector);
+
+	/**
+	 * @reset:
+	 *
+	 * Reset connector hardware and software state to off. This function isn't
+	 * called by the core directly, only through drm_mode_config_reset().
+	 * It's not a helper hook only for historical reasons.
+	 *
+	 * Atomic drivers can use drm_atomic_helper_connector_reset() to reset
+	 * atomic state using this hook.
+	 */
 	void (*reset)(struct drm_connector *connector);
 
 	/* Check to see if anything is attached to the connector.
@@ -539,19 +661,142 @@ struct drm_connector_funcs {
 	enum drm_connector_status (*detect)(struct drm_connector *connector,
 					    bool force);
 	int (*fill_modes)(struct drm_connector *connector, uint32_t max_width, uint32_t max_height);
+
+	/**
+	 * @set_property:
+	 *
+	 * This is the legacy entry point to update a property attached to the
+	 * connector.
+	 *
+	 * Drivers implementing atomic modeset should use
+	 * drm_atomic_helper_connector_set_property() to implement this hook.
+	 *
+	 * This callback is optional if the driver does not support any legacy
+	 * driver-private properties.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 on success or a negative error code on failure.
+	 */
 	int (*set_property)(struct drm_connector *connector, struct drm_property *property,
 			     uint64_t val);
+
+	/**
+	 * @destroy:
+	 *
+	 * Clean up connector resources. This is called at driver unload time
+	 * through drm_mode_config_cleanup(). It can also be called at runtime
+	 * when a connector is being hot-unplugged for drivers that support
+	 * connector hotplugging (e.g. DisplayPort MST).
+	 */
 	void (*destroy)(struct drm_connector *connector);
 	void (*force)(struct drm_connector *connector);
 
-	/* atomic update handling */
+	/**
+	 * @atomic_duplicate_state:
+	 *
+	 * Duplicate the current atomic state for this connector and return it.
+	 * The core and helpers gurantee that any atomic state duplicated with
+	 * this hook and still owned by the caller (i.e. not transferred to the
+	 * driver by calling ->atomic_commit() from struct
+	 * &drm_mode_config_funcs) will be cleaned up by calling the
+	 * @atomic_destroy_state hook in this structure.
+	 *
+	 * Atomic drivers which don't subclass struct &drm_connector_state should use
+	 * drm_atomic_helper_connector_duplicate_state(). Drivers that subclass the
+	 * state structure to extend it with driver-private state should use
+	 * __drm_atomic_helper_connector_duplicate_state() to make sure shared state is
+	 * duplicated in a consistent fashion across drivers.
+	 *
+	 * It is an error to call this hook before connector->state has been
+	 * initialized correctly.
+	 *
+	 * NOTE:
+	 *
+	 * If the duplicate state references refcounted resources this hook must
+	 * acquire a reference for each of them. The driver must release these
+	 * references again in @atomic_destroy_state.
+	 *
+	 * RETURNS:
+	 *
+	 * Duplicated atomic state or NULL when the allocation failed.
+	 */
 	struct drm_connector_state *(*atomic_duplicate_state)(struct drm_connector *connector);
+
+	/**
+	 * @atomic_destroy_state:
+	 *
+	 * Destroy a state duplicated with @atomic_duplicate_state and release
+	 * or unreference all resources it references
+	 */
 	void (*atomic_destroy_state)(struct drm_connector *connector,
 				     struct drm_connector_state *state);
+
+	/**
+	 * @atomic_set_property:
+	 *
+	 * Decode a driver-private property value and store the decoded value
+	 * into the passed-in state structure. Since the atomic core decodes all
+	 * standardized properties (even for extensions beyond the core set of
+	 * properties which might not be implemented by all drivers) this
+	 * requires drivers to subclass the state structure.
+	 *
+	 * Such driver-private properties should really only be implemented for
+	 * truly hardware/vendor specific state. Instead it is preferred to
+	 * standardize atomic extension and decode the properties used to expose
+	 * such an extension in the core.
+	 *
+	 * Do not call this function directly, use
+	 * drm_atomic_connector_set_property() instead.
+	 *
+	 * This callback is optional if the driver does not support any
+	 * driver-private atomic properties.
+	 *
+	 * NOTE:
+	 *
+	 * This function is called in the state assembly phase of atomic
+	 * modesets, which can be aborted for any reason (including on
+	 * userspace's request to just check whether a configuration would be
+	 * possible). Drivers MUST NOT touch any persistent state (hardware or
+	 * software) or data structures except the passed in @state parameter.
+	 *
+	 * Also since userspace controls in which order properties are set this
+	 * function must not do any input validation (since the state update is
+	 * incomplete and hence likely inconsistent). Instead any such input
+	 * validation must be done in the various atomic_check callbacks.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 if the property has been found, -EINVAL if the property isn't
+	 * implemented by the driver (which shouldn't ever happen, the core only
+	 * asks for properties attached to this connector). No other validation
+	 * is allowed by the driver. The core already checks that the property
+	 * value is within the range (integer, valid enum value, ...) the driver
+	 * set when registering the property.
+	 */
 	int (*atomic_set_property)(struct drm_connector *connector,
 				   struct drm_connector_state *state,
 				   struct drm_property *property,
 				   uint64_t val);
+
+	/**
+	 * @atomic_get_property:
+	 *
+	 * Reads out the decoded driver-private property. This is used to
+	 * implement the GETCONNECTOR ioctl.
+	 *
+	 * Do not call this function directly, use
+	 * drm_atomic_connector_get_property() instead.
+	 *
+	 * This callback is optional if the driver does not support any
+	 * driver-private atomic properties.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 on success, -EINVAL if the property isn't implemented by the
+	 * driver (which shouldn't ever happen, the core only asks for
+	 * properties attached to this connector).
+	 */
 	int (*atomic_get_property)(struct drm_connector *connector,
 				   const struct drm_connector_state *state,
 				   struct drm_property *property,
@@ -560,13 +805,26 @@ struct drm_connector_funcs {
 
 /**
  * struct drm_encoder_funcs - encoder controls
- * @reset: reset state (e.g. at init or resume time)
- * @destroy: cleanup and free associated data
  *
  * Encoders sit between CRTCs and connectors.
  */
 struct drm_encoder_funcs {
+	/**
+	 * @reset:
+	 *
+	 * Reset encoder hardware and software state to off. This function isn't
+	 * called by the core directly, only through drm_mode_config_reset().
+	 * It's not a helper hook only for historical reasons.
+	 */
 	void (*reset)(struct drm_encoder *encoder);
+
+	/**
+	 * @destroy:
+	 *
+	 * Clean up encoder resources. This is only called at driver unload time
+	 * through drm_mode_config_cleanup() since an encoder cannot be
+	 * hotplugged in DRM.
+	 */
 	void (*destroy)(struct drm_encoder *encoder);
 };
 
@@ -787,40 +1045,203 @@ struct drm_plane_state {
 
 /**
  * struct drm_plane_funcs - driver plane control functions
- * @update_plane: update the plane configuration
- * @disable_plane: shut down the plane
- * @destroy: clean up plane resources
- * @reset: reset plane after state has been invalidated (e.g. resume)
- * @set_property: called when a property is changed
- * @atomic_duplicate_state: duplicate the atomic state for this plane
- * @atomic_destroy_state: destroy an atomic state for this plane
- * @atomic_set_property: set a property on an atomic state for this plane
- *    (do not call directly, use drm_atomic_plane_set_property())
- * @atomic_get_property: get a property on an atomic state for this plane
- *    (do not call directly, use drm_atomic_plane_get_property())
  */
 struct drm_plane_funcs {
+	/**
+	 * @update_plane:
+	 *
+	 * This is the legacy entry point to enable and configure the plane for
+	 * the given CRTC and framebuffer. It is never called to disable the
+	 * plane, i.e. the passed-in crtc and fb paramters are never NULL.
+	 *
+	 * The source rectangle in frame buffer memory coordinates is given by
+	 * the src_x, src_y, src_w and src_h parameters (as 16.16 fixed point
+	 * values). Devices that don't support subpixel plane coordinates can
+	 * ignore the fractional part.
+	 *
+	 * The destination rectangle in CRTC coordinates is given by the
+	 * crtc_x, crtc_y, crtc_w and crtc_h parameters (as integer values).
+	 * Devices scale the source rectangle to the destination rectangle. If
+	 * scaling is not supported, and the source rectangle size doesn't match
+	 * the destination rectangle size, the driver must return a
+	 * -<errorname>EINVAL</errorname> error.
+	 *
+	 * Drivers implementing atomic modeset should use
+	 * drm_atomic_helper_update_plane() to implement this hook.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 on success or a negative error code on failure.
+	 */
 	int (*update_plane)(struct drm_plane *plane,
 			    struct drm_crtc *crtc, struct drm_framebuffer *fb,
 			    int crtc_x, int crtc_y,
 			    unsigned int crtc_w, unsigned int crtc_h,
 			    uint32_t src_x, uint32_t src_y,
 			    uint32_t src_w, uint32_t src_h);
+
+	/**
+	 * @disable_plane:
+	 *
+	 * This is the legacy entry point to disable the plane. The DRM core
+	 * calls this method in response to a DRM_IOCTL_MODE_SETPLANE ioctl call
+	 * with the frame buffer ID set to 0.  Disabled planes must not be
+	 * processed by the CRTC.
+	 *
+	 * Drivers implementing atomic modeset should use
+	 * drm_atomic_helper_disable_plane() to implement this hook.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 on success or a negative error code on failure.
+	 */
 	int (*disable_plane)(struct drm_plane *plane);
+
+	/**
+	 * @destroy:
+	 *
+	 * Clean up plane resources. This is only called at driver unload time
+	 * through drm_mode_config_cleanup() since a plane cannot be hotplugged
+	 * in DRM.
+	 */
 	void (*destroy)(struct drm_plane *plane);
+
+	/**
+	 * @reset:
+	 *
+	 * Reset plane hardware and software state to off. This function isn't
+	 * called by the core directly, only through drm_mode_config_reset().
+	 * It's not a helper hook only for historical reasons.
+	 *
+	 * Atomic drivers can use drm_atomic_helper_plane_reset() to reset
+	 * atomic state using this hook.
+	 */
 	void (*reset)(struct drm_plane *plane);
 
+	/**
+	 * @set_property:
+	 *
+	 * This is the legacy entry point to update a property attached to the
+	 * plane.
+	 *
+	 * Drivers implementing atomic modeset should use
+	 * drm_atomic_helper_plane_set_property() to implement this hook.
+	 *
+	 * This callback is optional if the driver does not support any legacy
+	 * driver-private properties.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 on success or a negative error code on failure.
+	 */
 	int (*set_property)(struct drm_plane *plane,
 			    struct drm_property *property, uint64_t val);
 
-	/* atomic update handling */
+	/**
+	 * @atomic_duplicate_state:
+	 *
+	 * Duplicate the current atomic state for this plane and return it.
+	 * The core and helpers gurantee that any atomic state duplicated with
+	 * this hook and still owned by the caller (i.e. not transferred to the
+	 * driver by calling ->atomic_commit() from struct
+	 * &drm_mode_config_funcs) will be cleaned up by calling the
+	 * @atomic_destroy_state hook in this structure.
+	 *
+	 * Atomic drivers which don't subclass struct &drm_plane_state should use
+	 * drm_atomic_helper_plane_duplicate_state(). Drivers that subclass the
+	 * state structure to extend it with driver-private state should use
+	 * __drm_atomic_helper_plane_duplicate_state() to make sure shared state is
+	 * duplicated in a consistent fashion across drivers.
+	 *
+	 * It is an error to call this hook before plane->state has been
+	 * initialized correctly.
+	 *
+	 * NOTE:
+	 *
+	 * If the duplicate state references refcounted resources this hook must
+	 * acquire a reference for each of them. The driver must release these
+	 * references again in @atomic_destroy_state.
+	 *
+	 * RETURNS:
+	 *
+	 * Duplicated atomic state or NULL when the allocation failed.
+	 */
 	struct drm_plane_state *(*atomic_duplicate_state)(struct drm_plane *plane);
+
+	/**
+	 * @atomic_destroy_state:
+	 *
+	 * Destroy a state duplicated with @atomic_duplicate_state and release
+	 * or unreference all resources it references
+	 */
 	void (*atomic_destroy_state)(struct drm_plane *plane,
 				     struct drm_plane_state *state);
+
+	/**
+	 * @atomic_set_property:
+	 *
+	 * Decode a driver-private property value and store the decoded value
+	 * into the passed-in state structure. Since the atomic core decodes all
+	 * standardized properties (even for extensions beyond the core set of
+	 * properties which might not be implemented by all drivers) this
+	 * requires drivers to subclass the state structure.
+	 *
+	 * Such driver-private properties should really only be implemented for
+	 * truly hardware/vendor specific state. Instead it is preferred to
+	 * standardize atomic extension and decode the properties used to expose
+	 * such an extension in the core.
+	 *
+	 * Do not call this function directly, use
+	 * drm_atomic_plane_set_property() instead.
+	 *
+	 * This callback is optional if the driver does not support any
+	 * driver-private atomic properties.
+	 *
+	 * NOTE:
+	 *
+	 * This function is called in the state assembly phase of atomic
+	 * modesets, which can be aborted for any reason (including on
+	 * userspace's request to just check whether a configuration would be
+	 * possible). Drivers MUST NOT touch any persistent state (hardware or
+	 * software) or data structures except the passed in @state parameter.
+	 *
+	 * Also since userspace controls in which order properties are set this
+	 * function must not do any input validation (since the state update is
+	 * incomplete and hence likely inconsistent). Instead any such input
+	 * validation must be done in the various atomic_check callbacks.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 if the property has been found, -EINVAL if the property isn't
+	 * implemented by the driver (which shouldn't ever happen, the core only
+	 * asks for properties attached to this plane). No other validation is
+	 * allowed by the driver. The core already checks that the property
+	 * value is within the range (integer, valid enum value, ...) the driver
+	 * set when registering the property.
+	 */
 	int (*atomic_set_property)(struct drm_plane *plane,
 				   struct drm_plane_state *state,
 				   struct drm_property *property,
 				   uint64_t val);
+
+	/**
+	 * @atomic_get_property:
+	 *
+	 * Reads out the decoded driver-private property. This is used to
+	 * implement the GETPLANE ioctl.
+	 *
+	 * Do not call this function directly, use
+	 * drm_atomic_plane_get_property() instead.
+	 *
+	 * This callback is optional if the driver does not support any
+	 * driver-private atomic properties.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 on success, -EINVAL if the property isn't implemented by the
+	 * driver (which should never happen, the core only asks for
+	 * properties attached to this plane).
+	 */
 	int (*atomic_get_property)(struct drm_plane *plane,
 				   const struct drm_plane_state *state,
 				   struct drm_property *property,
@@ -833,6 +1254,7 @@ enum drm_plane_type {
 	DRM_PLANE_TYPE_CURSOR,
 };
 
+
 /**
  * struct drm_plane - central DRM plane control structure
  * @dev: DRM device this plane belongs to
@@ -907,7 +1329,7 @@ struct drm_bridge_funcs {
 	 * can be aborted for any reason (including on userspace's request to
 	 * just check whether a configuration would be possible). Drivers MUST
 	 * NOT touch any persistent state (hardware or software) or data
-	 * structures except the passed in adjusted_mode parameter.
+	 * structures except the passed in @state parameter.
 	 *
 	 * RETURNS:
 	 *

commit da024fe58680a46346cfbeba5db705d33f39b313
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Dec 4 09:45:47 2015 +0100

    drm/bridge: Improve kerneldoc
    
    Especially document the assumptions and semantics of the callbacks
    carefully. Just a warm-up excercise really.
    
    v2: Spelling fixes (Eric).
    
    v3: Consolidate more with existing docs:
    
    - Remove the overview section explaining the bridge funcs, that's
      now all in the drm_bridge_funcs kerneldoc in much more detail.
    
    - Use & to reference structs so that kerneldoc automatically inserts
      hyperlinks.
    
    v4: Review from Thierry.
    
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Archit Taneja <architt@codeaurora.org> (v3)
    Link: http://patchwork.freedesktop.org/patch/msgid/1449218769-16577-7-git-send-email-daniel.vetter@ffwll.ch
    Reviewed-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index e8f8e4e9a6a1..7f80fae1a45f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -883,24 +883,114 @@ struct drm_plane {
 /**
  * struct drm_bridge_funcs - drm_bridge control functions
  * @attach: Called during drm_bridge_attach
- * @mode_fixup: Try to fixup (or reject entirely) proposed mode for this bridge
- * @disable: Called right before encoder prepare, disables the bridge
- * @post_disable: Called right after encoder prepare, for lockstepped disable
- * @mode_set: Set this mode to the bridge
- * @pre_enable: Called right before encoder commit, for lockstepped commit
- * @enable: Called right after encoder commit, enables the bridge
  */
 struct drm_bridge_funcs {
 	int (*attach)(struct drm_bridge *bridge);
+
+	/**
+	 * @mode_fixup:
+	 *
+	 * This callback is used to validate and adjust a mode. The paramater
+	 * mode is the display mode that should be fed to the next element in
+	 * the display chain, either the final &drm_connector or the next
+	 * &drm_bridge. The parameter adjusted_mode is the input mode the bridge
+	 * requires. It can be modified by this callback and does not need to
+	 * match mode.
+	 *
+	 * This is the only hook that allows a bridge to reject a modeset. If
+	 * this function passes all other callbacks must succeed for this
+	 * configuration.
+	 *
+	 * NOTE:
+	 *
+	 * This function is called in the check phase of atomic modesets, which
+	 * can be aborted for any reason (including on userspace's request to
+	 * just check whether a configuration would be possible). Drivers MUST
+	 * NOT touch any persistent state (hardware or software) or data
+	 * structures except the passed in adjusted_mode parameter.
+	 *
+	 * RETURNS:
+	 *
+	 * True if an acceptable configuration is possible, false if the modeset
+	 * operation should be rejected.
+	 */
 	bool (*mode_fixup)(struct drm_bridge *bridge,
 			   const struct drm_display_mode *mode,
 			   struct drm_display_mode *adjusted_mode);
+	/**
+	 * @disable:
+	 *
+	 * This callback should disable the bridge. It is called right before
+	 * the preceding element in the display pipe is disabled. If the
+	 * preceding element is a bridge this means it's called before that
+	 * bridge's ->disable() function. If the preceding element is a
+	 * &drm_encoder it's called right before the encoder's ->disable(),
+	 * ->prepare() or ->dpms() hook from struct &drm_encoder_helper_funcs.
+	 *
+	 * The bridge can assume that the display pipe (i.e. clocks and timing
+	 * signals) feeding it is still running when this callback is called.
+	 */
 	void (*disable)(struct drm_bridge *bridge);
+
+	/**
+	 * @post_disable:
+	 *
+	 * This callback should disable the bridge. It is called right after
+	 * the preceding element in the display pipe is disabled. If the
+	 * preceding element is a bridge this means it's called after that
+	 * bridge's ->post_disable() function. If the preceding element is a
+	 * &drm_encoder it's called right after the encoder's ->disable(),
+	 * ->prepare() or ->dpms() hook from struct &drm_encoder_helper_funcs.
+	 *
+	 * The bridge must assume that the display pipe (i.e. clocks and timing
+	 * singals) feeding it is no longer running when this callback is
+	 * called.
+	 */
 	void (*post_disable)(struct drm_bridge *bridge);
+
+	/**
+	 * @mode_set:
+	 *
+	 * This callback should set the given mode on the bridge. It is called
+	 * after the ->mode_set() callback for the preceding element in the
+	 * display pipeline has been called already. The display pipe (i.e.
+	 * clocks and timing signals) is off when this function is called.
+	 */
 	void (*mode_set)(struct drm_bridge *bridge,
 			 struct drm_display_mode *mode,
 			 struct drm_display_mode *adjusted_mode);
+	/**
+	 * @pre_enable:
+	 *
+	 * This callback should enable the bridge. It is called right before
+	 * the preceding element in the display pipe is enabled. If the
+	 * preceding element is a bridge this means it's called before that
+	 * bridge's ->pre_enable() function. If the preceding element is a
+	 * &drm_encoder it's called right before the encoder's ->enable(),
+	 * ->commit() or ->dpms() hook from struct &drm_encoder_helper_funcs.
+	 *
+	 * The display pipe (i.e. clocks and timing signals) feeding this bridge
+	 * will not yet be running when this callback is called. The bridge must
+	 * not enable the display link feeding the next bridge in the chain (if
+	 * there is one) when this callback is called.
+	 */
 	void (*pre_enable)(struct drm_bridge *bridge);
+
+	/**
+	 * @enable:
+	 *
+	 * This callback should enable the bridge. It is called right after
+	 * the preceding element in the display pipe is enabled. If the
+	 * preceding element is a bridge this means it's called after that
+	 * bridge's ->enable() function. If the preceding element is a
+	 * &drm_encoder it's called right after the encoder's ->enable(),
+	 * ->commit() or ->dpms() hook from struct &drm_encoder_helper_funcs.
+	 *
+	 * The bridge can assume that the display pipe (i.e. clocks and timing
+	 * signals) feeding it is running when this callback is called. This
+	 * callback must enable the display link feeding the next bridge in the
+	 * chain if there is one.
+	 */
 	void (*enable)(struct drm_bridge *bridge);
 };
 

commit 4490d4c7111e1ebf748ea2c3e1e64d103d73bae7
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Dec 4 09:45:45 2015 +0100

    drm: Make helper vtable pointers type-safe
    
    Originally the idea behind void* was to allow different sets of
    helpers. But now we have that (with probe, plane, crtc and atomic
    helpers) and we still just use the same set of vtables. That's the
    only way to make the individual helpers modular and allow drivers to
    pick&choose and transition between them. So this flexibility isn't
    really needed. Also we have lots of non-vtable data meanwhile in core
    structures too, this is not the first one at all.
    
    Given that the void * is only trouble since gcc can't warn you if you
    mix them up. Let's fix that and make them typesafe.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449218769-16577-5-git-send-email-daniel.vetter@ffwll.ch
    Reviewed-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 4765df331002..e8f8e4e9a6a1 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -254,6 +254,11 @@ struct drm_plane;
 struct drm_bridge;
 struct drm_atomic_state;
 
+struct drm_crtc_helper_funcs;
+struct drm_encoder_helper_funcs;
+struct drm_connector_helper_funcs;
+struct drm_plane_helper_funcs;
+
 /**
  * struct drm_crtc_state - mutable CRTC state
  * @crtc: backpointer to the CRTC
@@ -467,7 +472,7 @@ struct drm_crtc {
 	uint16_t *gamma_store;
 
 	/* if you are using the helper */
-	const void *helper_private;
+	const struct drm_crtc_helper_funcs *helper_private;
 
 	struct drm_object_properties properties;
 
@@ -597,7 +602,7 @@ struct drm_encoder {
 	struct drm_crtc *crtc;
 	struct drm_bridge *bridge;
 	const struct drm_encoder_funcs *funcs;
-	const void *helper_private;
+	const struct drm_encoder_helper_funcs *helper_private;
 };
 
 /* should we poll this connector for connects and disconnects */
@@ -702,7 +707,7 @@ struct drm_connector {
 	/* requested DPMS state */
 	int dpms;
 
-	const void *helper_private;
+	const struct drm_connector_helper_funcs *helper_private;
 
 	/* forced on connector */
 	struct drm_cmdline_mode cmdline_mode;
@@ -870,7 +875,7 @@ struct drm_plane {
 
 	enum drm_plane_type type;
 
-	const void *helper_private;
+	const struct drm_plane_helper_funcs *helper_private;
 
 	struct drm_plane_state *state;
 };

commit 373701b1fc7d7c0013ae4fffd8103615c150751e
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Nov 24 21:21:55 2015 +0200

    drm: fix potential dangling else problems in for_each_ macros
    
    We have serious dangling else bugs waiting to happen in our for_each_
    style macros with ifs. Consider, for example,
    
     #define drm_for_each_plane_mask(plane, dev, plane_mask) \
             list_for_each_entry((plane), &(dev)->mode_config.plane_list, head) \
                     if ((plane_mask) & (1 << drm_plane_index(plane)))
    
    If this is used in context:
    
            if (condition)
                    drm_for_each_plane_mask(plane, dev, plane_mask);
            else
                    foo();
    
    foo() will be called for each plane *not* in plane_mask, if condition
    holds, and not at all if condition doesn't hold.
    
    Fix this by reversing the conditions in the macros, and adding an else
    branch for the "for each" block, so that other if/else blocks can't
    interfere. Provide a "for_each_if" helper macro to make it easier to get
    this right.
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1448392916-2281-1-git-send-email-jani.nikula@intel.com
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 173535a35d65..4765df331002 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1170,7 +1170,7 @@ struct drm_mode_config {
  */
 #define drm_for_each_plane_mask(plane, dev, plane_mask) \
 	list_for_each_entry((plane), &(dev)->mode_config.plane_list, head) \
-		if ((plane_mask) & (1 << drm_plane_index(plane)))
+		for_each_if ((plane_mask) & (1 << drm_plane_index(plane)))
 
 
 #define obj_to_crtc(x) container_of(x, struct drm_crtc, base)
@@ -1547,7 +1547,7 @@ static inline struct drm_property *drm_property_find(struct drm_device *dev,
 /* Plane list iterator for legacy (overlay only) planes. */
 #define drm_for_each_legacy_plane(plane, dev) \
 	list_for_each_entry(plane, &(dev)->mode_config.plane_list, head) \
-		if (plane->type == DRM_PLANE_TYPE_OVERLAY)
+		for_each_if (plane->type == DRM_PLANE_TYPE_OVERLAY)
 
 #define drm_for_each_plane(plane, dev) \
 	list_for_each_entry(plane, &(dev)->mode_config.plane_list, head)

commit 1eb83451ba55d7a8c82b76b1591894ff2d4a95f2
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Nov 11 19:11:29 2015 +0200

    drm: Pass the user drm_mode_fb_cmd2 as const to .fb_create()
    
    Drivers shouldn't clobber the passed in addfb ioctl parameters.
    i915 was doing just that. To prevent it from happening again,
    pass the struct around as const, starting all the way from
    internal_framebuffer_create().
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f47cefa37ef3..173535a35d65 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -996,7 +996,7 @@ struct drm_mode_set {
 struct drm_mode_config_funcs {
 	struct drm_framebuffer *(*fb_create)(struct drm_device *dev,
 					     struct drm_file *file_priv,
-					     struct drm_mode_fb_cmd2 *mode_cmd);
+					     const struct drm_mode_fb_cmd2 *mode_cmd);
 	void (*output_poll_changed)(struct drm_device *dev);
 
 	int (*atomic_check)(struct drm_device *dev,

commit d9c382421771560c6b282c100752a3c194cb5827
Author: Robert Fekete <robert.fekete@linux.intel.com>
Date:   Mon Nov 2 16:14:08 2015 +0100

    drm: Describe the Rotation property bits.
    
    Adds clarification of the rotation property bits. I.e. rotation is
    counter clockwise and that reflects are applied before any rotation.
    
    v2: Refer to the define names instead of the property values.
    
    Signed-off-by: Robert Fekete <robert.fekete@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 3f0c6909dda1..f47cefa37ef3 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -85,7 +85,11 @@ static inline uint64_t I642U64(int64_t val)
 	return (uint64_t)*((uint64_t *)&val);
 }
 
-/* rotation property bits */
+/*
+ * Rotation property bits. DRM_ROTATE_<degrees> rotates the image by the
+ * specified amount in degrees in counter clockwise direction. DRM_REFLECT_X and
+ * DRM_REFLECT_Y reflects the image along the specified axis prior to rotation
+ */
 #define DRM_ROTATE_MASK 0x0f
 #define DRM_ROTATE_0	0
 #define DRM_ROTATE_90	1

commit 33e0be63759d472e7a6996d1277ff66e92a8685d
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Oct 16 18:38:39 2015 +0300

    drm: Check crtc viewport correctly with rotated primary plane on atomic drivers
    
    On atomic drivers we can dig out the primary plane rotation from the
    plane state instead of looking at the legacy crtc->invert_dimensions
    flag. The flag is not set by anyone except omapdrm, and it would be
    racy to set it the same way in the atomic helpers.
    
    v2: Kill crtc->invert_dimensions totally since omap is state based
        already and no one else ever used it (Matt)
    
    Cc: Matt Roper <matthew.d.roper@intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1445009919-22746-1-git-send-email-ville.syrjala@linux.intel.com
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 33ddedd36038..3f0c6909dda1 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -407,9 +407,6 @@ struct drm_crtc_funcs {
  * @enabled: is this CRTC enabled?
  * @mode: current mode timings
  * @hwmode: mode timings as programmed to hw regs
- * @invert_dimensions: for purposes of error checking crtc vs fb sizes,
- *    invert the width/height of the crtc.  This is used if the driver
- *    is performing 90 or 270 degree rotated scanout
  * @x: x position on screen
  * @y: y position on screen
  * @funcs: CRTC control functions
@@ -458,8 +455,6 @@ struct drm_crtc {
 	 */
 	struct drm_display_mode hwmode;
 
-	bool invert_dimensions;
-
 	int x, y;
 	const struct drm_crtc_funcs *funcs;
 

commit 6220907089cc3eb4ab2fa7073bbf617b019666c5
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Thu Oct 1 10:00:57 2015 +0300

    drm: Add DRM_ROTATE_MASK and DRM_REFLECT_MASK
    
    Makes it cleaner to separate the two from rotation variable.
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 683f1421a825..33ddedd36038 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -86,10 +86,12 @@ static inline uint64_t I642U64(int64_t val)
 }
 
 /* rotation property bits */
+#define DRM_ROTATE_MASK 0x0f
 #define DRM_ROTATE_0	0
 #define DRM_ROTATE_90	1
 #define DRM_ROTATE_180	2
 #define DRM_ROTATE_270	3
+#define DRM_REFLECT_MASK (~DRM_ROTATE_MASK)
 #define DRM_REFLECT_X	4
 #define DRM_REFLECT_Y	5
 

commit eba1f35dfe145247c7eb690c7c32740fde8ec699
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Sep 14 22:43:43 2015 +0300

    drm: Move timestamping constants into drm_vblank_crtc
    
    Collect the timestamping constants alongside the rest of the relevant
    stuff under drm_vblank_crtc.
    
    We can now get rid of the 'refcrtc' parameter to
    drm_calc_vbltimestamp_from_scanoutpos().
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 6566f72fc505..683f1421a825 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -413,9 +413,6 @@ struct drm_crtc_funcs {
  * @funcs: CRTC control functions
  * @gamma_size: size of gamma ramp
  * @gamma_store: gamma ramp values
- * @framedur_ns: precise frame timing
- * @linedur_ns: precise line timing
- * @pixeldur_ns: precise pixel timing
  * @helper_private: mid-layer private data
  * @properties: property tracking for this CRTC
  * @state: current atomic state for this CRTC
@@ -468,9 +465,6 @@ struct drm_crtc {
 	uint32_t gamma_size;
 	uint16_t *gamma_store;
 
-	/* Constants needed for precise vblank and swap timestamping. */
-	int framedur_ns, linedur_ns, pixeldur_ns;
-
 	/* if you are using the helper */
 	const void *helper_private;
 

commit 5e7d49446b5964d2866ea1912cc9f65ab33ed76f
Author: Geliang Tang <geliangtang@163.com>
Date:   Wed Sep 16 23:25:22 2015 -0700

    drm: fix kernel-doc warnings in drm_crtc.h
    
    Fix the following 'make htmldocs' warning:
    
      .//include/drm/drm_crtc.h:929: warning: Excess struct/union/enum/typedef member 'base' description in 'drm_bridge'
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c0366e9152e2..6566f72fc505 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -911,7 +911,6 @@ struct drm_bridge_funcs {
  * @next: the next bridge in the encoder chain
  * @of_node: device node pointer to the bridge
  * @list: to keep track of all added bridges
- * @base: base mode object
  * @funcs: control functions
  * @driver_private: pointer to the bridge driver's internal context
  */

commit c86fb9d997428e0d55ab5a47488b6ba3bc4b5c5b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Sep 10 22:39:22 2015 +0200

    drm: Nuke drm_framebuffer->helper_private
    
    It's completely unused and there's really no reason for this:
    - drm_framebuffer structures are invariant after creation, no need for
      helpers to manipulate them.
    - drm_framebuffer structures should just be embedded (and that's what
      all the drivers do).
    
    Stumbled over this since some folks are apparently concerned with the
    overhead of struct drm_framebuffer and this is an easy 8 byte saving.
    
    More could be gained by ditching the legacy fields and recomputing
    stuff from the fourcc value. But that would require some drm-wide
    cocci and real justification.
    
    Cc: gary.k.smith@intel.com
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 75f49c1ef8bb..c0366e9152e2 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -210,8 +210,6 @@ struct drm_framebuffer {
 	int flags;
 	uint32_t pixel_format; /* fourcc format */
 	struct list_head filp_head;
-	/* if you are using the helper */
-	void *helper_private;
 };
 
 struct drm_property_blob {

commit b7c914b3d94e93bd9b442226231b0bba84c9fa2c
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Aug 31 15:09:26 2015 +0300

    drm: Constify TV mode names
    
    Make the mode names passed to drm_mode_create_tv_properties() const.
    
     drivers/gpu/drm/i2c/ch7006.ko:
    -.rodata                       596
    +.rodata                       664
    -.data                        7064
    +.data                        6992
    
     drivers/gpu/drm/nouveau/nouveau.ko:
    -.rodata                      146808
    +.rodata                      146904
    -.data                        178624
    +.data                        178528
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index faaeff7db684..75f49c1ef8bb 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1390,7 +1390,7 @@ extern int drm_property_add_enum(struct drm_property *property, int index,
 extern int drm_mode_create_dvi_i_properties(struct drm_device *dev);
 extern int drm_mode_create_tv_properties(struct drm_device *dev,
 					 unsigned int num_modes,
-					 char *modes[]);
+					 const char * const modes[]);
 extern int drm_mode_create_scaling_mode_property(struct drm_device *dev);
 extern int drm_mode_create_aspect_ratio_property(struct drm_device *dev);
 extern int drm_mode_create_dirty_info_property(struct drm_device *dev);

commit 3732ce72b45a2a145803558758821bf198751276
Merge: e829d7ef9f17 c13dcf9f2d6f
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Aug 24 16:36:42 2015 +1000

    Merge tag 'v4.2-rc8' into drm-next
    
    Linux 4.2-rc8
    
    Backmerge required for Intel so they can fix their -next tree up properly.

commit 45e3743aff6f3fbe3f08d43d443dc2d7b5396a31
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Aug 12 16:54:28 2015 +0200

    drm/plane: Use consistent data types for format count
    
    Rather than a mix of the the sized uint32_t and signed integer, use an
    unsized unsigned int to specify the format count.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 574656965126..6e5afc30b596 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -865,7 +865,7 @@ struct drm_plane {
 
 	uint32_t possible_crtcs;
 	uint32_t *format_types;
-	uint32_t format_count;
+	unsigned int format_count;
 	bool format_default;
 
 	struct drm_crtc *crtc;
@@ -1270,13 +1270,13 @@ extern int drm_universal_plane_init(struct drm_device *dev,
 				    unsigned long possible_crtcs,
 				    const struct drm_plane_funcs *funcs,
 				    const uint32_t *formats,
-				    uint32_t format_count,
+				    unsigned int format_count,
 				    enum drm_plane_type type);
 extern int drm_plane_init(struct drm_device *dev,
 			  struct drm_plane *plane,
 			  unsigned long possible_crtcs,
 			  const struct drm_plane_funcs *funcs,
-			  const uint32_t *formats, uint32_t format_count,
+			  const uint32_t *formats, unsigned int format_count,
 			  bool is_primary);
 extern void drm_plane_cleanup(struct drm_plane *plane);
 extern unsigned int drm_plane_index(struct drm_plane *plane);

commit 4772ff03df8094fd99d28de5fcf5df3a3e9c68bb
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Tue Aug 11 09:54:29 2015 +0200

    drm/dp/mst: Remove port after removing connector.
    
    The port is removed synchronously, but the connector delayed.
    This causes a use after free which can cause a kernel BUG with
    slug_debug=FPZU. This is fixed by freeing the port after the
    connector.
    
    This fixes a regression introduced with
    6b8eeca65b18ae77e175cc2b6571731f0ee413bf
    "drm/dp/mst: close deadlock in connector destruction."
    
    Cc: stable@vger.kernel.org
    Cc: Dave Airlie <airlied@redhat.com>
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 57ca8cc383a6..3b4d8a4a23fb 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -743,8 +743,6 @@ struct drm_connector {
 	uint8_t num_h_tile, num_v_tile;
 	uint8_t tile_h_loc, tile_v_loc;
 	uint16_t tile_h_size, tile_v_size;
-
-	struct list_head destroy_list;
 };
 
 /**

commit 9a69a9ac20f7f3435dd18019f902351c61a9ad1d
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Tue Jul 21 11:34:55 2015 +0200

    drm: Make the connector dpms callback return a value, v2.
    
    This is required to properly handle failing dpms calls.
    When making a wait in i915 interruptible, I've noticed
    that the dpms sequence could fail with -ERESTARTSYS because
    it was waiting interruptibly for flips. So from now on
    allow drivers to fail in their connector dpms callback.
    
    Encoder and crtc dpms callbacks are unaffected.
    
    Changes since v1:
    - Update kerneldoc for the drm helper functions.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    [danvet: Resolve conflicts due to different merge order.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 90a0ff70384a..574656965126 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -527,7 +527,7 @@ struct drm_connector_state {
  * etc.
  */
 struct drm_connector_funcs {
-	void (*dpms)(struct drm_connector *connector, int mode);
+	int (*dpms)(struct drm_connector *connector, int mode);
 	void (*save)(struct drm_connector *connector);
 	void (*restore)(struct drm_connector *connector);
 	void (*reset)(struct drm_connector *connector);

commit fc596660dd4e83f7f84e3cd7b25dc5e8e83000ef
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Tue Jul 21 13:28:57 2015 +0200

    drm/atomic: add connectors_changed to separate it from mode_changed, v2
    
    This can be a separate case from mode_changed, when connectors stay the
    same but only the mode is different. Drivers may choose to implement specific
    optimizations to prevent a full modeset for this case.
    
    Changes since v1:
    - Update kerneldocs slightly.
    
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Ander Conselvan de Oliveira <conselvan2@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 3071319ea194..90a0ff70384a 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -255,12 +255,13 @@ struct drm_atomic_state;
  * @crtc: backpointer to the CRTC
  * @enable: whether the CRTC should be enabled, gates all other state
  * @active: whether the CRTC is actively displaying (used for DPMS)
- * @mode_changed: for use by helpers and drivers when computing state updates
- * @active_changed: for use by helpers and drivers when computing state updates
+ * @planes_changed: planes on this crtc are updated
+ * @mode_changed: crtc_state->mode or crtc_state->enable has been changed
+ * @active_changed: crtc_state->active has been toggled.
+ * @connectors_changed: connectors to this crtc have been updated
  * @plane_mask: bitmask of (1 << drm_plane_index(plane)) of attached planes
  * @last_vblank_count: for helpers and drivers to capture the vblank of the
  * 	update to ensure framebuffer cleanup isn't done too early
- * @planes_changed: for use by helpers and drivers when computing state updates
  * @adjusted_mode: for use by helpers and drivers to compute adjusted mode timings
  * @mode: current mode timings
  * @event: optional pointer to a DRM event to signal upon completion of the
@@ -283,6 +284,7 @@ struct drm_crtc_state {
 	bool planes_changed : 1;
 	bool mode_changed : 1;
 	bool active_changed : 1;
+	bool connectors_changed : 1;
 
 	/* attached planes bitmask:
 	 * WARNING: transitional helpers do not maintain plane_mask so

commit 3fdefa399e4644399ce3e74e65a75122d52dba6a
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jul 9 23:44:37 2015 +0200

    drm: gc now dead mode_group code
    
    Two nice things here:
    - drm_dev_register will truly register everything in the right order
      if the driver doesn't have a ->load callback. Before this we had to
      init the primary mode_group after the device nodes where already
      registered.
    
    - Less things to keep track of when reworking the connector locking,
      yay!
    
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index fe3100115a41..3071319ea194 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1017,29 +1017,6 @@ struct drm_mode_config_funcs {
 	void (*atomic_state_free)(struct drm_atomic_state *state);
 };
 
-/**
- * struct drm_mode_group - group of mode setting resources for potential sub-grouping
- * @num_crtcs: CRTC count
- * @num_encoders: encoder count
- * @num_connectors: connector count
- * @num_bridges: bridge count
- * @id_list: list of KMS object IDs in this group
- *
- * Currently this simply tracks the global mode setting state.  But in the
- * future it could allow groups of objects to be set aside into independent
- * control groups for use by different user level processes (e.g. two X servers
- * running simultaneously on different heads, each with their own mode
- * configuration and freedom of mode setting).
- */
-struct drm_mode_group {
-	uint32_t num_crtcs;
-	uint32_t num_encoders;
-	uint32_t num_connectors;
-
-	/* list of object IDs for this group */
-	uint32_t *id_list;
-};
-
 /**
  * struct drm_mode_config - Mode configuration control structure
  * @mutex: mutex protecting KMS related lists and structures
@@ -1324,9 +1301,6 @@ extern const char *drm_get_tv_select_name(int val);
 extern void drm_fb_release(struct drm_file *file_priv);
 extern void drm_property_destroy_user_blobs(struct drm_device *dev,
                                             struct drm_file *file_priv);
-extern int drm_mode_group_init_legacy_group(struct drm_device *dev, struct drm_mode_group *group);
-extern void drm_mode_group_destroy(struct drm_mode_group *group);
-extern void drm_reinit_primary_mode_group(struct drm_device *dev);
 extern bool drm_probe_ddc(struct i2c_adapter *adapter);
 extern struct edid *drm_get_edid(struct drm_connector *connector,
 				 struct i2c_adapter *adapter);

commit cff20ba2758d6b82978be5b1f40536bfc121af88
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jul 9 23:44:33 2015 +0200

    drm: Amend connector list locking rules
    
    Now that dp mst hotplug takes all locks we can amend the locking rules
    for the iterators. This is needed before we can roll these out in the
    atomic code to avoid getting burried in WARNINGs.
    
    v2: Rebase onto the extracted list locking assert and add a comment to
    explain the rules.
    
    v3: Fixup German->English translation fail in the comment.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 10547be5684a..fe3100115a41 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1592,7 +1592,15 @@ static inline struct drm_property *drm_property_find(struct drm_device *dev,
 static inline void
 assert_drm_connector_list_read_locked(struct drm_mode_config *mode_config)
 {
-	WARN_ON(!mutex_is_locked(&mode_config->mutex));
+	/*
+	 * The connector hotadd/remove code currently grabs both locks when
+	 * updating lists. Hence readers need only hold either of them to be
+	 * safe and the check amounts to
+	 *
+	 * WARN_ON(not_holding(A) && not_holding(B)).
+	 */
+	WARN_ON(!mutex_is_locked(&mode_config->mutex) &&
+		!drm_modeset_is_locked(&mode_config->connection_mutex));
 }
 
 #define drm_for_each_connector(connector, dev) \

commit 4676ba0be756b2b02b9737147713d458042962f7
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jul 9 23:44:30 2015 +0200

    drm: Check locking in drm_for_each_fb
    
    Ever since framebuffers are reference counted we have a special lock
    for the global fb list. Make sure users of that list do hold that
    lock when using the new iterators.
    
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 499562274353..10547be5684a 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1606,6 +1606,10 @@ assert_drm_connector_list_read_locked(struct drm_mode_config *mode_config)
 	list_for_each_entry(encoder, &(dev)->mode_config.encoder_list, head)
 
 #define drm_for_each_fb(fb, dev) \
-	list_for_each_entry(fb, &(dev)->mode_config.fb_list, head)
+	for (WARN_ON(!mutex_is_locked(&(dev)->mode_config.fb_lock)),		\
+	     fb = list_first_entry(&(dev)->mode_config.fb_list,	\
+					  struct drm_framebuffer, head);	\
+	     &fb->head != (&(dev)->mode_config.fb_list);			\
+	     fb = list_next_entry(fb, head))
 
 #endif /* __DRM_CRTC_H__ */

commit 7a3f3d6667f5f9ffd1517f6b21d64bbf5312042c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jul 9 23:44:28 2015 +0200

    drm: Check locking in drm_for_each_connector
    
    Because of DP MST connectors can now be hotplugged and we must hold
    the right lock when walking the connector lists.  Enforce this by
    checking the locking in our shiny new list walking macros.
    
    v2: Extract the locking check into a small static inline helper to
    help readability. This will be more important when we make the
    read list access rules more complicated in later patches. Inspired by
    comments from Chris. Unfortunately, due to header loops around the
    definition of struct drm_device the function interface is a bit funny.
    
    v3: Encoders aren't hotadded/removed. For each dp mst encoder we
    statically create one fake encoder per pipe so that we can support as
    many mst sinks as the hw can (Dave).
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 7c95a7df6065..499562274353 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1589,8 +1589,18 @@ static inline struct drm_property *drm_property_find(struct drm_device *dev,
 #define drm_for_each_crtc(crtc, dev) \
 	list_for_each_entry(crtc, &(dev)->mode_config.crtc_list, head)
 
+static inline void
+assert_drm_connector_list_read_locked(struct drm_mode_config *mode_config)
+{
+	WARN_ON(!mutex_is_locked(&mode_config->mutex));
+}
+
 #define drm_for_each_connector(connector, dev) \
-	list_for_each_entry(connector, &(dev)->mode_config.connector_list, head)
+	for (assert_drm_connector_list_read_locked(&(dev)->mode_config),	\
+	     connector = list_first_entry(&(dev)->mode_config.connector_list,	\
+					  struct drm_connector, head);		\
+	     &connector->head != (&(dev)->mode_config.connector_list);		\
+	     connector = list_next_entry(connector, head))
 
 #define drm_for_each_encoder(encoder, dev) \
 	list_for_each_entry(encoder, &(dev)->mode_config.encoder_list, head)

commit 6295d607ad34ee4e43aab3f20714c2ef7a6adea1
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jul 9 23:44:25 2015 +0200

    drm: Add modeset object iterators
    
    And roll them out across drm_* files. The point here isn't code
    prettification (it helps with that too) but that some of these lists
    aren't static any more. And having macros will gives us a convenient
    place to put locking checks into.
    
    I didn't add an iterator for props since that's only used by a
    list_for_each_entry_safe in the driver teardown code.
    
    Search&replace was done with the below cocci spatch. Note that there's
    a bunch more places that didn't match and which would need some manual
    changes, but I've intentially left these out for this mostly automated
    patch.
    
    iterator name drm_for_each_crtc;
    struct drm_crtc *crtc;
    struct drm_device *dev;
    expression head;
    @@
    - list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
    + drm_for_each_crtc (crtc, dev) {
    ...
    }
    
    @@
    iterator name drm_for_each_encoder;
    struct drm_encoder *encoder;
    struct drm_device *dev;
    expression head;
    @@
    - list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
    + drm_for_each_encoder (encoder, dev) {
    ...
    }
    
    @@
    iterator name drm_for_each_fb;
    struct drm_framebuffer *fb;
    struct drm_device *dev;
    expression head;
    @@
    - list_for_each_entry(fb, &dev->mode_config.fb_list, head) {
    + drm_for_each_fb (fb, dev) {
    ...
    }
    
    @@
    iterator name drm_for_each_connector;
    struct drm_connector *connector;
    struct drm_device *dev;
    expression head;
    @@
    - list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
    + drm_for_each_connector (connector, dev) {
    ...
    }
    
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 5cf0e6c3fc41..7c95a7df6065 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1583,4 +1583,19 @@ static inline struct drm_property *drm_property_find(struct drm_device *dev,
 	list_for_each_entry(plane, &(dev)->mode_config.plane_list, head) \
 		if (plane->type == DRM_PLANE_TYPE_OVERLAY)
 
+#define drm_for_each_plane(plane, dev) \
+	list_for_each_entry(plane, &(dev)->mode_config.plane_list, head)
+
+#define drm_for_each_crtc(crtc, dev) \
+	list_for_each_entry(crtc, &(dev)->mode_config.crtc_list, head)
+
+#define drm_for_each_connector(connector, dev) \
+	list_for_each_entry(connector, &(dev)->mode_config.connector_list, head)
+
+#define drm_for_each_encoder(encoder, dev) \
+	list_for_each_entry(encoder, &(dev)->mode_config.encoder_list, head)
+
+#define drm_for_each_fb(fb, dev) \
+	list_for_each_entry(fb, &(dev)->mode_config.fb_list, head)
+
 #endif /* __DRM_CRTC_H__ */

commit 4ea50e99bd3501aea394aa7a9e9bd3115faabf37
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jul 9 23:44:24 2015 +0200

    drm: Simplify drm_for_each_legacy_plane arguments
    
    No need to pass the planelist when everyone just uses
    dev->mode_config.plane_list anyway.
    
    I want to add a pile more of iterators with unified (obj, dev)
    arguments. This is just prep.
    
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 57ca8cc383a6..5cf0e6c3fc41 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1579,8 +1579,8 @@ static inline struct drm_property *drm_property_find(struct drm_device *dev,
 }
 
 /* Plane list iterator for legacy (overlay only) planes. */
-#define drm_for_each_legacy_plane(plane, planelist) \
-	list_for_each_entry(plane, planelist, head) \
+#define drm_for_each_legacy_plane(plane, dev) \
+	list_for_each_entry(plane, &(dev)->mode_config.plane_list, head) \
 		if (plane->type == DRM_PLANE_TYPE_OVERLAY)
 
 #endif /* __DRM_CRTC_H__ */

commit 6b8eeca65b18ae77e175cc2b6571731f0ee413bf
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Jun 15 10:34:28 2015 +1000

    drm/dp/mst: close deadlock in connector destruction.
    
    I've only seen this once, and I failed to capture the
    lockdep backtrace, but I did some investigations.
    
    If we are calling into the MST layer from EDID probing,
    we have the mode_config mutex held, if during that EDID
    probing, the MST hub goes away, then we can get a deadlock
    where the connector destruction function in the driver
    tries to retake the mode config mutex.
    
    This offloads connector destruction to a workqueue,
    and avoid the subsequenct lock ordering issue.
    
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 3b4d8a4a23fb..57ca8cc383a6 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -743,6 +743,8 @@ struct drm_connector {
 	uint8_t num_h_tile, num_v_tile;
 	uint8_t tile_h_loc, tile_v_loc;
 	uint16_t tile_h_size, tile_v_size;
+
+	struct list_head destroy_list;
 };
 
 /**

commit 955f3c334f0fb2b843efad5cc6d3b7e141e9d666
Author: Daniel Stone <daniels@collabora.com>
Date:   Mon May 25 19:11:52 2015 +0100

    drm/atomic: Add MODE_ID property
    
    Atomic modesetting: now with modesetting support.
    
    v2: Moved drm_atomic_set_mode_prop_for_crtc from previous patch; removed
        state->active fiddling, documented return code. Changed property
        type to DRM_MODE_PROP_BLOB.
    
    Signed-off-by: Daniel Stone <daniels@collabora.com>
    Tested-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c54fa4add792..3b4d8a4a23fb 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1146,6 +1146,7 @@ struct drm_mode_config {
 	struct drm_property *prop_fb_id;
 	struct drm_property *prop_crtc_id;
 	struct drm_property *prop_active;
+	struct drm_property *prop_mode_id;
 
 	/* DVI-I properties */
 	struct drm_property *dvi_i_subconnector_property;

commit 99cf4a29fa24461bbfe22125967188a18383eb5c
Author: Daniel Stone <daniels@collabora.com>
Date:   Mon May 25 19:11:51 2015 +0100

    drm/atomic: Add current-mode blob to CRTC state
    
    Add a blob property tracking the current mode to the CRTC state, and
    ensure it is properly updated and referenced.
    
    v2: Continue using crtc_state->mode inside getcrtc, instead of reading
        out the mode blob. Use IS_ERR and PTR_ERR from create_blob. Move
        set_mode_prop_for_crtc to later patch where it actually gets used.
        Enforce !!state->enable == !!state->mode_blob inside
        drm_atomic_crtc_check.
    
    Signed-off-by: Daniel Stone <daniels@collabora.com>
    Tested-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 72b60dbe0891..c54fa4add792 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -299,6 +299,9 @@ struct drm_crtc_state {
 
 	struct drm_display_mode mode;
 
+	/* blob property to expose current mode to atomic userspace */
+	struct drm_property_blob *mode_blob;
+
 	struct drm_pending_vblank_event *event;
 
 	struct drm_atomic_state *state;

commit e2f5d2ea479b9b2619965d43db70939589afe43a
Author: Daniel Stone <daniels@collabora.com>
Date:   Fri May 22 13:34:51 2015 +0100

    drm/mode: Add user blob-creation ioctl
    
    Add an ioctl which allows users to create blob properties from supplied
    data. Currently this only supports modes, creating a drm_display_mode from
    the userspace drm_mode_modeinfo.
    
    v2: Removed size/type checks.
        Rebased on new patches to allow error propagation from create_blob,
        as well as avoiding double-allocation.
    
    Signed-off-by: Daniel Stone <daniels@collabora.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@intel.com>
    Tested-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index dace1b635685..72b60dbe0891 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -218,7 +218,8 @@ struct drm_property_blob {
 	struct drm_mode_object base;
 	struct drm_device *dev;
 	struct kref refcount;
-	struct list_head head;
+	struct list_head head_global;
+	struct list_head head_file;
 	size_t length;
 	unsigned char data[];
 };
@@ -1315,6 +1316,8 @@ extern const char *drm_get_dvi_i_select_name(int val);
 extern const char *drm_get_tv_subconnector_name(int val);
 extern const char *drm_get_tv_select_name(int val);
 extern void drm_fb_release(struct drm_file *file_priv);
+extern void drm_property_destroy_user_blobs(struct drm_device *dev,
+                                            struct drm_file *file_priv);
 extern int drm_mode_group_init_legacy_group(struct drm_device *dev, struct drm_mode_group *group);
 extern void drm_mode_group_destroy(struct drm_mode_group *group);
 extern void drm_reinit_primary_mode_group(struct drm_device *dev);
@@ -1460,6 +1463,10 @@ extern int drm_mode_getproperty_ioctl(struct drm_device *dev,
 				      void *data, struct drm_file *file_priv);
 extern int drm_mode_getblob_ioctl(struct drm_device *dev,
 				  void *data, struct drm_file *file_priv);
+extern int drm_mode_createblob_ioctl(struct drm_device *dev,
+				     void *data, struct drm_file *file_priv);
+extern int drm_mode_destroyblob_ioctl(struct drm_device *dev,
+				      void *data, struct drm_file *file_priv);
 extern int drm_mode_connector_property_set_ioctl(struct drm_device *dev,
 					      void *data, struct drm_file *file_priv);
 extern int drm_mode_getencoder(struct drm_device *dev,

commit 862e686ce40299250d21ba425ea5078e947397ff
Author: Archit Taneja <architt@codeaurora.org>
Date:   Thu May 21 11:03:16 2015 +0530

    drm: bridge: Allow daisy chaining of bridges
    
    Allow drm_bridge objects to link to each other in order to form an encoder
    chain. The requirement for creating a chain of bridges comes because the
    MSM drm driver uses up its encoder and bridge objects for blocks within
    the SoC itself. There isn't anything left to use if the SoC display output
    is connected to an external encoder IC. Having an additional bridge
    connected to the existing bridge helps here. In general, it is possible for
    platforms to have  multiple devices between the encoder and the
    connector/panel that require some sort of configuration.
    
    We create drm bridge helper functions corresponding to each op in
    'drm_bridge_funcs'. These helpers call the corresponding
    'drm_bridge_funcs' op for the entire chain of bridges. These helpers are
    used internally by drm_atomic_helper.c and drm_crtc_helper.c.
    
    The drm_bridge_enable/pre_enable helpers execute enable/pre_enable ops of
    the bridge closet to the encoder, and proceed until the last bridge in the
    chain is enabled. The same holds for drm_bridge_mode_set/mode_fixup
    helpers. The drm_bridge_disable/post_disable helpers disable the last
    bridge in the chain first, and proceed until the first bridge in the chain
    is disabled.
    
    drm_bridge_attach() remains the same. As before, the driver calling this
    function should make sure it has set the links correctly. The order in
    which the bridges are connected to each other determines the order in which
    the calls are made. One requirement is that every bridge in the chain
    should point the parent encoder object. This is required since bridge
    drivers expect a valid encoder pointer in drm_bridge. For example, consider
    a chain where an encoder's output is connected to bridge1, and bridge1's
    output is connected to bridge2:
    
            /* Like before, attach bridge to an encoder */
            bridge1->encoder = encoder;
            ret = drm_bridge_attach(dev, bridge1);
            ..
    
            /*
             * set the first bridge's 'next' bridge to bridge2, set its encoder
             * as bridge1's encoder
             */
            bridge1->next = bridge2
            bridge2->encoder = bridge1->encoder;
            ret = drm_bridge_attach(dev, bridge2);
    
            ...
            ...
    
    This method of bridge chaining isn't intrusive and existing drivers that
    use drm_bridge will behave the same way as before. The bridge helpers also
    cleans up the atomic and crtc helper files a bit.
    
    Reviewed-by: Jani Nikula <jani.nikula@linux.intel.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index bff25b0cada9..dace1b635685 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -903,6 +903,8 @@ struct drm_bridge_funcs {
 /**
  * struct drm_bridge - central DRM bridge control structure
  * @dev: DRM device this bridge belongs to
+ * @encoder: encoder to which this bridge is connected
+ * @next: the next bridge in the encoder chain
  * @of_node: device node pointer to the bridge
  * @list: to keep track of all added bridges
  * @base: base mode object
@@ -912,6 +914,7 @@ struct drm_bridge_funcs {
 struct drm_bridge {
 	struct drm_device *dev;
 	struct drm_encoder *encoder;
+	struct drm_bridge *next;
 #ifdef CONFIG_OF
 	struct device_node *of_node;
 #endif
@@ -1247,6 +1250,17 @@ extern void drm_bridge_remove(struct drm_bridge *bridge);
 extern struct drm_bridge *of_drm_find_bridge(struct device_node *np);
 extern int drm_bridge_attach(struct drm_device *dev, struct drm_bridge *bridge);
 
+bool drm_bridge_mode_fixup(struct drm_bridge *bridge,
+			const struct drm_display_mode *mode,
+			struct drm_display_mode *adjusted_mode);
+void drm_bridge_disable(struct drm_bridge *bridge);
+void drm_bridge_post_disable(struct drm_bridge *bridge);
+void drm_bridge_mode_set(struct drm_bridge *bridge,
+			struct drm_display_mode *mode,
+			struct drm_display_mode *adjusted_mode);
+void drm_bridge_pre_enable(struct drm_bridge *bridge);
+void drm_bridge_enable(struct drm_bridge *bridge);
+
 extern int drm_encoder_init(struct drm_device *dev,
 			    struct drm_encoder *encoder,
 			    const struct drm_encoder_funcs *funcs,

commit 9c37bf2db0a707be4a3025240b009cf63691e0d7
Merge: d0093404f808 036ef5733ba4
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed May 20 09:19:58 2015 +1000

    Merge tag 'topic/drm-misc-2015-05-19' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    Scattering of random drm core patches. Bunch of atomic prep work too, but
    the final bits for blob properties, atomic modesets and lifting the
    experimental tag on the atomic ioctl are still blocked on Daniel Stone
    finalizing and testing the weston support for it. I hope that we can get
    it all ready for 4.2 though.
    
    * tag 'topic/drm-misc-2015-05-19' of git://anongit.freedesktop.org/drm-intel: (22 commits)
      drm/atomic: Allow drivers to subclass drm_atomic_state, v3
      drm/atomic: remove duplicated assignment of old_plane_state
      drm/dp: Fix comment in DP helper
      drm/atomic: add drm_atomic_get_existing_*_state helpers
      drm/core: get rid of -Iinclude/drm
      drm/i915: get rid of -Iinclude/drm
      drm/atomic-helpers: Export drm_atomic_helper_update_legacy_modeset_state
      drm/atomic-helpers: Update vblank timestamping constants
      drm/sysfs: remove unnecessary connector type checks
      drm/sysfs: split DVI-I and TV-out attributes
      drm/sysfs: make optional attribute groups per connector type
      drm/sysfs: add a helper for extracting connector type from kobject
      drm/edid: Add CEA modes before inferred modes
      drm/prime: Allow internal imports without import_sg_table
      drm: Add reference counting to blob properties
      drm: Introduce blob_lock
      drm: Introduce helper for replacing blob properties
      drm: Don't leak path blob property when updating
      drm/atomic: Don't open-code CRTC state destroy
      drm/edid: Add DMT modes with ID > 0x50
      ...

commit 036ef5733ba433760a3512bb5f7a155946e2df05
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Mon May 18 10:06:40 2015 +0200

    drm/atomic: Allow drivers to subclass drm_atomic_state, v3
    
    Drivers may need to store the state of shared resources, such as PLLs
    or FIFO space, into the atomic state. Allow this by making it possible
    to subclass drm_atomic_state.
    
    Changes since v1:
    - Change member names for functions to atomic_state_(alloc,clear)
    - Change __drm_atomic_state_new to drm_atomic_state_init
    - Allow free function to be overridden too, in case extra memory is
      allocated in alloc.
    Changes since v2:
    - Rename *_default_free to default_release, to make clear it doesn't
      free the state object itself.
    
    Cc: dri-devel@lists.freedesktop.org
    Acked-by: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 5626191f3af0..37c44f27cb9f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -979,6 +979,9 @@ struct drm_mode_set {
  * @atomic_check: check whether a given atomic state update is possible
  * @atomic_commit: commit an atomic state update previously verified with
  * 	atomic_check()
+ * @atomic_state_alloc: allocate a new atomic state
+ * @atomic_state_clear: clear the atomic state
+ * @atomic_state_free: free the atomic state
  *
  * Some global (i.e. not per-CRTC, connector, etc) mode setting functions that
  * involve drivers.
@@ -994,6 +997,9 @@ struct drm_mode_config_funcs {
 	int (*atomic_commit)(struct drm_device *dev,
 			     struct drm_atomic_state *a,
 			     bool async);
+	struct drm_atomic_state *(*atomic_state_alloc)(struct drm_device *dev);
+	void (*atomic_state_clear)(struct drm_atomic_state *state);
+	void (*atomic_state_free)(struct drm_atomic_state *state);
 };
 
 /**

commit 6bcacf51d050d412e5c302e0dd5e582212c5f7be
Author: Daniel Stone <daniels@collabora.com>
Date:   Mon Apr 20 19:22:55 2015 +0100

    drm: Add reference counting to blob properties
    
    Reference-count drm_property_blob objects, changing the API to
    ref/unref.
    
    Signed-off-by: Daniel Stone <daniels@collabora.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    [danvet: Squash in kerneldoc fixup from Daniel Stone.]
    [danvet: Squash in Oops fix from Thiery Reding.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 55ed8f9f45be..5626191f3af0 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -216,6 +216,8 @@ struct drm_framebuffer {
 
 struct drm_property_blob {
 	struct drm_mode_object base;
+	struct drm_device *dev;
+	struct kref refcount;
 	struct list_head head;
 	size_t length;
 	unsigned char data[];
@@ -1365,6 +1367,13 @@ struct drm_property *drm_property_create_object(struct drm_device *dev,
 					 int flags, const char *name, uint32_t type);
 struct drm_property *drm_property_create_bool(struct drm_device *dev, int flags,
 					 const char *name);
+struct drm_property_blob *drm_property_create_blob(struct drm_device *dev,
+                                                   size_t length,
+                                                   const void *data);
+struct drm_property_blob *drm_property_lookup_blob(struct drm_device *dev,
+                                                   uint32_t id);
+struct drm_property_blob *drm_property_reference_blob(struct drm_property_blob *blob);
+void drm_property_unreference_blob(struct drm_property_blob *blob);
 extern void drm_property_destroy(struct drm_device *dev, struct drm_property *property);
 extern int drm_property_add_enum(struct drm_property *property, int index,
 				 uint64_t value, const char *name);
@@ -1528,14 +1537,6 @@ static inline struct drm_property *drm_property_find(struct drm_device *dev,
 	return mo ? obj_to_property(mo) : NULL;
 }
 
-static inline struct drm_property_blob *
-drm_property_blob_find(struct drm_device *dev, uint32_t id)
-{
-	struct drm_mode_object *mo;
-	mo = drm_mode_object_find(dev, id, DRM_MODE_OBJECT_BLOB);
-	return mo ? obj_to_blob(mo) : NULL;
-}
-
 /* Plane list iterator for legacy (overlay only) planes. */
 #define drm_for_each_legacy_plane(plane, planelist) \
 	list_for_each_entry(plane, planelist, head) \

commit ac6f2e29bb08a2313b0480c6cea94b01ab274970
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri May 8 16:15:41 2015 +0200

    drm/edid: Kerneldoc for newly added edid_corrupt
    
    Also treat it as a proper boolean.
    
    Cc: Todd Previte <tprevite@gmail.com>
    Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b9fcdc824997..0a4a040d6bb7 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -647,6 +647,7 @@ struct drm_encoder {
  * @audio_latency: audio latency info from ELD, if found
  * @null_edid_counter: track sinks that give us all zeros for the EDID
  * @bad_edid_counter: track sinks that give us an EDID with invalid checksum
+ * @edid_corrupt: indicates whether the last read EDID was corrupt
  * @debugfs_entry: debugfs directory for this connector
  * @state: current atomic state for this connector
  * @has_tile: is this connector connected to a tiled monitor

commit 8fb6e7a579670d5b71fc0d5641c1523b3df612e8
Author: Daniel Stone <daniels@collabora.com>
Date:   Mon Apr 20 19:22:54 2015 +0100

    drm: Introduce blob_lock
    
    Create a new global blob_lock mutex, which protects the blob property
    list from insertion and/or deletion.
    
    Signed-off-by: Daniel Stone <daniels@collabora.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index ca71c03143d1..55ed8f9f45be 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1048,6 +1048,7 @@ struct drm_mode_group {
  * @poll_running: track polling status for this device
  * @output_poll_work: delayed work for polling in process context
  * @property_blob_list: list of all the blob property objects
+ * @blob_lock: mutex for blob property allocation and management
  * @*_property: core property tracking
  * @preferred_depth: preferred RBG pixel depth, used by fb helpers
  * @prefer_shadow: hint to userspace to prefer shadow-fb rendering
@@ -1103,6 +1104,8 @@ struct drm_mode_config {
 	bool delayed_event;
 	struct delayed_work output_poll_work;
 
+	struct mutex blob_lock;
+
 	/* pointers to standard properties */
 	struct list_head property_blob_list;
 	struct drm_property *edid_property;

commit 6ba2bd3da7d3f9af3db83f704ca055943fd9ee40
Author: Todd Previte <tprevite@gmail.com>
Date:   Tue Apr 21 11:09:41 2015 -0700

    drm: Add edid_corrupt flag for Displayport Link CTS 4.2.2.6
    
    Displayport compliance test 4.2.2.6 requires that a source device be capable of
    detecting a corrupt EDID. The test specification states that the sink device
    sets up the EDID with an invalid checksum. To do this, the sink sets up an
    invalid EDID header, expecting the source device to generate the checksum and
    compare it to the value stored in the last byte of the block data.
    
    Unfortunately, the DRM EDID reading and parsing functions are actually too good
    in this case; the header is fixed before the checksum is computed and thus the
    test never sees the invalid checksum. This results in a failure to pass the
    compliance test.
    
    To correct this issue, when the EDID code detects that the header is invalid,
    a flag is set to indicate that the EDID is corrupted. In this case, it sets
    edid_corrupt flag and continues with its fix-up code. This flag is also set in
    the case of a more seriously damaged header (fixup score less than the
    threshold). For consistency, the edid_corrupt flag is also set when the
    checksum is invalid as well.
    
    V2:
    - Removed the static bool global
    - Added a bool to the drm_connector struct to reaplce the static one for
      holding the status of raw edid header corruption detection
    - Modified the function signature of the is_valid function to take an
      additional parameter to store the corruption detected value
    - Fixed the other callers of the above is_valid function
    V3:
    - Updated the commit message to be more clear about what and why this
      patch does what it does.
    - Added comment in code to clarify the operations there
    - Removed compliance variable and check_link_status update; those
      have been moved to a later patch
    - Removed variable assignment from the bottom of the test handler
    V4:
    - Removed i915 tag from subject line as the patch is not i915-specific
    V5:
    - Moved code causing a compilation error to this patch where the variable
      is actually declared
    - Maintained blank lines / spacing so as to not contaminate the patch
    V6:
    - Removed extra debug messages
    - Added documentation to for the added parameter on drm_edid_block_valid
    - Fixed more whitespace issues in check_link_status
    - Added a clear of the header_corrupt flag to the end of the test handler
      in intel_dp.c
    - Changed the usage of the new function prototype in several places to use
      NULL where it is not needed by compliance testing
    V7:
    - Updated to account for long_pulse flag propagation
    V8:
    - Removed clearing of header_corrupt flag from the test handler in intel_dp.c
    - Added clearing of header_corrupt flag in the drm_edid_block_valid function
    V9:
    - Renamed header_corrupt flag to edid_corrupt to more accurately reflect its
      value and purpose
    - Updated commit message
    V10:
    - Updated for versioning and patch swizzle
    - Revised the title to more accurately reflect the nature and contents of
      the patch
    - Fixed formatting/whitespace problems
    - Added set flag when computed checksum is invalid
    
    Signed-off-by: Todd Previte <tprevite@gmail.com>
    Cc: dri-devel@lists.freedesktop.org
    Acked-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index db9a30f10bc4..b9fcdc824997 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -719,6 +719,11 @@ struct drm_connector {
 	int null_edid_counter; /* needed to workaround some HW bugs where we get all 0s */
 	unsigned bad_edid_counter;
 
+	/* Flag for raw EDID header corruption - used in Displayport
+	 * compliance testing - * Displayport Link CTS Core 1.2 rev1.1 4.2.2.6
+	 */
+	bool edid_corrupt;
+
 	struct dentry *debugfs_entry;
 
 	struct drm_connector_state *state;
@@ -1443,7 +1448,8 @@ extern void drm_set_preferred_mode(struct drm_connector *connector,
 				   int hpref, int vpref);
 
 extern int drm_edid_header_is_valid(const u8 *raw_edid);
-extern bool drm_edid_block_valid(u8 *raw_edid, int block, bool print_bad_edid);
+extern bool drm_edid_block_valid(u8 *raw_edid, int block, bool print_bad_edid,
+				 bool *edid_corrupt);
 extern bool drm_edid_is_valid(struct edid *edid);
 
 extern struct drm_tile_group *drm_mode_create_tile_group(struct drm_device *dev,

commit e1dee1973c74a0408b108d88c57a15be8a2d6d84
Merge: c0fe07aa50be 93a96c6f049d
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri May 8 20:51:06 2015 +1000

    Merge tag 'drm-intel-next-2015-04-23-fixed' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    drm-intel-next-2015-04-23:
    - dither support for ns2501 dvo (Thomas Richter)
    - some polish for the gtt code and fixes to finally enable the cmd parser on hsw
    - first pile of bxt stage 1 enabling (too many different people to list ...)
    - more psr fixes from Rodrigo
    - skl rotation support from Chandra
    - more atomic work from Ander and Matt
    - pile of cleanups and micro-ops for execlist from Chris
    drm-intel-next-2015-04-10:
    - cdclk handling cleanup and fixes from Ville
    - more prep patches for olr removal from John Harrison
    - gmbus pin naming rework from Jani (prep for bxt)
    - remove ->new_config from Ander (more atomic conversion work)
    - rps (boost) tuning and unification with byt/bsw from Chris
    - cmd parser batch bool tuning from Chris
    - gen8 dynamic pte allocation (Michel Thierry, based on work from Ben Widawsky)
    - execlist tuning (not yet all of it) from Chris
    - add drm_plane_from_index (Chandra)
    - various small things all over
    
    * tag 'drm-intel-next-2015-04-23-fixed' of git://anongit.freedesktop.org/drm-intel: (204 commits)
      drm/i915/gtt: Allocate va range only if vma is not bound
      drm/i915: Enable cmd parser to do secure batch promotion for aliasing ppgtt
      drm/i915: fix intel_prepare_ddi
      drm/i915: factor out ddi_get_encoder_port
      drm/i915/hdmi: check port in ibx_infoframe_enabled
      drm/i915/hdmi: fix vlv infoframe port check
      drm/i915: Silence compiler warning in dvo
      drm/i915: Update DRIVER_DATE to 20150423
      drm/i915: Enable dithering on NatSemi DVO2501 for Fujitsu S6010
      rm/i915: Move i915_get_ggtt_vma_pages into ggtt_bind_vma
      drm/i915: Don't try to outsmart gcc in i915_gem_gtt.c
      drm/i915: Unduplicate i915_ggtt_unbind/bind_vma
      drm/i915: Move ppgtt_bind/unbind around
      drm/i915: move i915_gem_restore_gtt_mappings around
      drm/i915: Fix up the vma aliasing ppgtt binding
      drm/i915: Remove misleading comment around bind_to_vm
      drm/i915: Don't use atomics for pg_dirty_rings
      drm/i915: Don't look at pg_dirty_rings for aliasing ppgtt
      drm/i915/skl: Support Y tiling in MMIO flips
      drm/i915: Fixup kerneldoc for struct intel_context
      ...
    
    Conflicts:
            drivers/gpu/drm/i915/i915_drv.c

commit 4a11248856933f33ca061ed55470ea7e1783b40b
Merge: 52139bdea155 2b1193d52870
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Apr 16 08:34:24 2015 +1000

    Merge tag 'topic/drm-misc-2015-04-15' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    One more drm-misch pull for 4.1 with mostly simple stuff and boring
    refactoring. Even the cursor fix from Matt is just to make a really anal
    igt happy.
    
    * tag 'topic/drm-misc-2015-04-15' of git://anongit.freedesktop.org/drm-intel:
      drm: fix trivial typo mistake
      drm: Make integer overflow checking cover universal cursor updates (v2)
      drm: make crtc/encoder/connector/plane helper_private a const pointer
      drm/armada: constify struct drm_encoder_helper_funcs pointer
      drm/radeon: constify more struct drm_*_helper funcs pointers
      drm/edid: add #defines for ELD versions
      drm/atomic: Add for_each_{connector,crtc,plane}_in_state helper macros
      drm: Use kref_put_mutex in drm_gem_object_unreference_unlocked
      drm/drm: constify all struct drm_*_helper funcs pointers
      drm/qxl: constify all struct drm_*_helper funcs pointers
      drm/nouveau: constify all struct drm_*_helper funcs pointers
      drm/radeon: constify all struct drm_*_helper funcs pointers
      drm/gma500: constify all struct drm_*_helper funcs pointers
      drm/mgag200: constify all struct drm_*_helper funcs pointers
      drm/exynos: constify all struct drm_*_helper funcs pointers
      drm: Fix some typos

commit c5fe557ddec423afa13410fc5927bb90a7c96765
Merge: 30154650b8b5 c776eb2edfce
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Apr 14 14:00:56 2015 +0200

    Merge branch 'topic/bxt-stage1' into drm-intel-next-queued
    
    Separate topic branch for bxt didn't work out since we needed to
    refactor the gmbus code a bit to make it look decent. So backmerge.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

commit 2b1193d5287004edfbf89407149a3159656f47f1
Author: John Hunter <zhaojunwang@pku.edu.cn>
Date:   Tue Apr 14 17:07:22 2015 +0800

    drm: fix trivial typo mistake
    
    Signed-off-by: John Hunter <zhjwpku@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 97c33b40005f..b009d707f562 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -975,7 +975,7 @@ struct drm_mode_set {
  * struct drm_mode_config_funcs - basic driver provided mode setting functions
  * @fb_create: create a new framebuffer object
  * @output_poll_changed: function to handle output configuration changes
- * @atomic_check: check whether a give atomic state update is possible
+ * @atomic_check: check whether a given atomic state update is possible
  * @atomic_commit: commit an atomic state update previously verified with
  * 	atomic_check()
  *

commit 9a436ee6c3f311f2ae604d775d7de06a49f8c9a0
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Apr 13 11:21:42 2015 +0300

    drm: make crtc/encoder/connector/plane helper_private a const pointer
    
    They're only used to store const pointers anyway. This helps to keep
    Ville and the compiler happy.
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 7b5c661b37d8..97c33b40005f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -467,7 +467,7 @@ struct drm_crtc {
 	int framedur_ns, linedur_ns, pixeldur_ns;
 
 	/* if you are using the helper */
-	void *helper_private;
+	const void *helper_private;
 
 	struct drm_object_properties properties;
 
@@ -597,7 +597,7 @@ struct drm_encoder {
 	struct drm_crtc *crtc;
 	struct drm_bridge *bridge;
 	const struct drm_encoder_funcs *funcs;
-	void *helper_private;
+	const void *helper_private;
 };
 
 /* should we poll this connector for connects and disconnects */
@@ -701,7 +701,7 @@ struct drm_connector {
 	/* requested DPMS state */
 	int dpms;
 
-	void *helper_private;
+	const void *helper_private;
 
 	/* forced on connector */
 	struct drm_cmdline_mode cmdline_mode;
@@ -864,7 +864,7 @@ struct drm_plane {
 
 	enum drm_plane_type type;
 
-	void *helper_private;
+	const void *helper_private;
 
 	struct drm_plane_state *state;
 };

commit f81338a52a82009863b0dc9d597fe1000d1caff6
Author: Chandra Konduru <chandra.konduru@intel.com>
Date:   Thu Apr 9 17:36:21 2015 -0700

    drm: Adding drm helper function drm_plane_from_index().
    
    Adding drm helper function to return plane pointer from index where
    index is a returned by drm_plane_index.
    
    v2:
    -avoided nested loop by adding loop count (Daniel)
    
    v3:
    -updated patch header prefix to 'drm' (Matt)
    
    v4:
    -fixed a kerneldoc issue (kbuild-internal)
    
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Chandra Konduru <chandra.konduru@intel.com>
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Acked-by: Dave Airlie <airlied@redhat.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index adc9ea5acf02..ed769e79c675 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1264,6 +1264,7 @@ extern int drm_plane_init(struct drm_device *dev,
 			  bool is_primary);
 extern void drm_plane_cleanup(struct drm_plane *plane);
 extern unsigned int drm_plane_index(struct drm_plane *plane);
+extern struct drm_plane * drm_plane_from_index(struct drm_device *dev, int idx);
 extern void drm_plane_force_disable(struct drm_plane *plane);
 extern int drm_plane_check_pixel_format(const struct drm_plane *plane,
 					u32 format);

commit a08aad54be7fca595af2cc7f482961e1af99c4a8
Merge: 1ddd36eda1a5 1c550fa193d0
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Apr 8 11:14:10 2015 +1000

    Merge tag 'drm/panel/for-4.1-rc1' of git://anongit.freedesktop.org/tegra/linux into drm-next
    
    drm/panel: Changes for v4.1-rc1
    
    This set of changes adds support for a whole bunch of new panels, mostly
    simple ones. There's now also support for panels to provide display
    timings rather than fixed modes, which should allow panels to work with
    a larger number of display drivers. Eventually drivers should migrate to
    this new interface and the fixed modes removed from panels.
    
    There are also a couple of sparse fixes for the PS8622 and PS8625 bridge
    drivers.
    
    * tag 'drm/panel/for-4.1-rc1' of git://anongit.freedesktop.org/tegra/linux:
      drm/panel: Add support for Ampire AM-800480R3TMQW-A1H 800x480 7" panel
      of: Add vendor prefix for Ampire Co., Ltd.
      drm/panel: Add display timing for HannStar HSD070PWW1
      drm/panel: simple: Add display timing support
      drm/panel: Add display timing support
      drm/panel: Add support for OrtusTech COM43H4M85ULC panel
      of: Add vendor prefix for Ortus Technology Co., Ltd.
      drm/panel: Add bus format for Giantplus GPG482739QS5 panel
      drm/panel: simple: Add support for AUO b101ean01 panel
      drm/panel: simple: Add support for Innolux ZJ070NA-01P
      drm/panel: simple: Add support for Innolux AT043TN24
      drm/panel: simple: Add support for Shelly SCA07010-BFN-LNN
      drm/panel: simple: Add support for Samsung LTN140AT29 panel
      drm: Remove unused DRM_MODE_OBJECT_BRIDGE
      drm/bridge: ptn3460: Fix sparse warnings
      drm/bridge: ps8622: Fix sparse warnings
      drm/bridge: Add I2C based driver for ps8622/ps8625 bridge

commit 6321fd6b6f0942e986b297e8192febfc860b83b3
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Jan 30 12:36:12 2015 +0100

    drm: Remove unused DRM_MODE_OBJECT_BRIDGE
    
    With bridges now moving to a separate registry they are no longer DRM
    objects, hence this define is no longer needed.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 920e21a8f3fd..f924b81d48ff 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -53,7 +53,6 @@ struct fence;
 #define DRM_MODE_OBJECT_FB 0xfbfbfbfb
 #define DRM_MODE_OBJECT_BLOB 0xbbbbbbbb
 #define DRM_MODE_OBJECT_PLANE 0xeeeeeeee
-#define DRM_MODE_OBJECT_BRIDGE 0xbdbdbdbd
 #define DRM_MODE_OBJECT_ANY 0
 
 struct drm_mode_object {

commit 08855fae10f088d83527bdf108199d3e35be503b
Author: Rob Clark <robdclark@gmail.com>
Date:   Wed Mar 11 10:23:09 2015 -0400

    drm/atomic: minor kerneldoc typo fix
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index adc9ea5acf02..7b5c661b37d8 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -915,7 +915,7 @@ struct drm_bridge {
 };
 
 /**
- * struct struct drm_atomic_state - the global state object for atomic updates
+ * struct drm_atomic_state - the global state object for atomic updates
  * @dev: parent DRM device
  * @allow_modeset: allow full modeset
  * @legacy_cursor_update: hint to enforce legacy cursor ioctl semantics

commit 7eb5f302bbe78b88da8b2008c502c1975e75db05
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Mar 9 10:41:07 2015 +0200

    drm: Check in setcrtc if the primary plane supports the fb pixel format
    
    Drivers implementing the universal planes API report the list of
    supported pixel formats for the primary plane. Make sure the fb passed
    to the setcrtc ioctl is compatible.
    
    Drivers not implementing the universal planes API will have no format
    reported for the primary plane, skip the check in that case.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index da83d39e37d4..adc9ea5acf02 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -830,6 +830,7 @@ enum drm_plane_type {
  * @possible_crtcs: pipes this plane can be bound to
  * @format_types: array of formats supported by this plane
  * @format_count: number of formats supported
+ * @format_default: driver hasn't supplied supported formats for the plane
  * @crtc: currently bound CRTC
  * @fb: currently bound fb
  * @old_fb: Temporary tracking of the old fb while a modeset is ongoing. Used by
@@ -850,6 +851,7 @@ struct drm_plane {
 	uint32_t possible_crtcs;
 	uint32_t *format_types;
 	uint32_t format_count;
+	bool format_default;
 
 	struct drm_crtc *crtc;
 	struct drm_framebuffer *fb;

commit ead8610d42105a3d01f755522f11b96c60dc648f
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 5 02:25:43 2015 +0200

    drm: Share plane pixel format check code between legacy and atomic
    
    Both the legacy and atomic helpers need to check whether a plane
    supports a given pixel format. The code is currently duplicated, share
    it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    [danvet: Slightly extend the docbook.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b1465d6fbe94..da83d39e37d4 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1263,6 +1263,8 @@ extern int drm_plane_init(struct drm_device *dev,
 extern void drm_plane_cleanup(struct drm_plane *plane);
 extern unsigned int drm_plane_index(struct drm_plane *plane);
 extern void drm_plane_force_disable(struct drm_plane *plane);
+extern int drm_plane_check_pixel_format(const struct drm_plane *plane,
+					u32 format);
 extern void drm_crtc_get_hv_timing(const struct drm_display_mode *mode,
 				   int *hdisplay, int *vdisplay);
 extern int drm_crtc_check_viewport(const struct drm_crtc *crtc,

commit 7547af91868f0ea940abc25460accc4025c5ce0a
Merge: 87dc8b6cbdd9 d4495cbaa586
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Mar 5 09:41:09 2015 +1000

    Merge tag 'drm-intel-next-2015-02-14' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - use the atomic helpers for plane_upate/disable hooks (Matt Roper)
    - refactor the initial plane config code (Damien)
    - ppgtt prep patches for dynamic pagetable alloc (Ben Widawsky, reworked and
      rebased by a lot of other people)
    - framebuffer modifier support from Tvrtko Ursulin, drm core code from Rob Clark
    - piles of workaround patches for skl from Damien and Nick Hoath
    - vGPU support for xengt on the client side (Yu Zhang)
    - and the usual smaller things all over
    
    * tag 'drm-intel-next-2015-02-14' of git://anongit.freedesktop.org/drm-intel: (88 commits)
      drm/i915: Update DRIVER_DATE to 20150214
      drm/i915: Remove references to previously removed UMS config option
      drm/i915/skl: Use a LRI for WaDisableDgMirrorFixInHalfSliceChicken5
      drm/i915/skl: Fix always true comparison in a revision id check
      drm/i915/skl: Implement WaEnableLbsSlaRetryTimerDecrement
      drm/i915/skl: Implement WaSetDisablePixMaskCammingAndRhwoInCommonSliceChicken
      drm/i915: Add process identifier to requests
      drm/i915/skl: Implement WaBarrierPerformanceFixDisable
      drm/i915/skl: Implement WaCcsTlbPrefetchDisable:skl
      drm/i915/skl: Implement WaDisableChickenBitTSGBarrierAckForFFSliceCS
      drm/i915/skl: Implement WaDisableHDCInvalidation
      drm/i915/skl: Implement WaDisableLSQCROPERFforOCL
      drm/i915/skl: Implement WaDisablePartialResolveInVc
      drm/i915/skl: Introduce a SKL specific init_workarounds()
      drm/i915/skl: Document that we implement WaRsClearFWBitsAtReset
      drm/i915/skl: Implement WaSetGAPSunitClckGateDisable
      drm/i915/skl: Make the init clock gating function skylake specific
      drm/i915/skl: Provide a gen9 specific init_render_ring()
      drm/i915/skl: Document the WM read latency W/A with its name
      drm/i915/skl: Also detect eDRAM on SKL
      ...

commit e3eb3250d84ef97b766312345774367b6a310db8
Author: Rob Clark <robdclark@gmail.com>
Date:   Thu Feb 5 14:41:52 2015 +0000

    drm: add support for tiled/compressed/etc modifier in addfb2
    
    In DRM/KMS we are lacking a good way to deal with tiled/compressed
    formats.  Especially in the case of dmabuf/prime buffer sharing, where
    we cannot always rely on under-the-hood flags passed to driver specific
    gem-create ioctl to pass around these extra flags.
    
    The proposal is to add a per-plane format modifier.  This allows to, if
    necessary, use different tiling patters for sub-sampled planes, etc.
    The format modifiers are added at the end of the ioctl struct, so for
    legacy userspace it will be zero padded.
    
    v1: original
    v1.5: increase modifier to 64b
    
    v2: Incorporate review comments from the big thread, plus a few more.
    
    - Add a getcap so that userspace doesn't have to jump through hoops.
    - Allow modifiers only when a flag is set. That way drivers know when
      they're dealing with old userspace and need to fish out e.g. tiling
      from other information.
    - After rolling out checks for ->modifier to all drivers I've decided
      that this is way too fragile and needs an explicit opt-in flag. So
      do that instead.
    - Add a define (just for documentation really) for the "NONE"
      modifier. Imo we don't need to add mask #defines since drivers
      really should only do exact matches against values defined with
      fourcc_mod_code.
    - Drop the Samsung tiling modifier on Rob's request since he's not yet
      sure whether that one is accurate.
    
    v3:
    - Also add a new ->modifier[] array to struct drm_framebuffer and fill
      it in drm_helper_mode_fill_fb_struct. Requested by Tvrkto Uruslin.
    - Remove TODO in comment and add code comment that modifiers should be
      properly documented, requested by Rob.
    
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Daniel Stone <daniel@fooishbar.org>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Michel Dänzer <michel@daenzer.net>
    Signed-off-by: Rob Clark <robdclark@gmail.com> (v1.5)
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Daniel Stone <daniels@collabora.com>
    Acked-by: Dave Airlie <airlied@redhat.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 0ebd9286b332..cee54c45eba9 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -202,6 +202,7 @@ struct drm_framebuffer {
 	const struct drm_framebuffer_funcs *funcs;
 	unsigned int pitches[4];
 	unsigned int offsets[4];
+	uint64_t modifier[4];
 	unsigned int width;
 	unsigned int height;
 	/* depth can be 15 or 16 */
@@ -1152,6 +1153,9 @@ struct drm_mode_config {
 	/* whether async page flip is supported or not */
 	bool async_page_flip;
 
+	/* whether the driver supports fb modifiers */
+	bool allow_fb_modifiers;
+
 	/* cursor size */
 	uint32_t cursor_width, cursor_height;
 };

commit 3d3f8b1f8b62c3a010976269df454baa9246fc65
Author: Ajay Kumar <ajaykumar.rs@samsung.com>
Date:   Tue Jan 20 22:08:44 2015 +0530

    drm/bridge: make bridge registration independent of drm flow
    
    Currently, third party bridge drivers(ptn3460) are dependent
    on the corresponding encoder driver init, since bridge driver
    needs a drm_device pointer to finish drm initializations.
    The encoder driver passes the drm_device pointer to the
    bridge driver. Because of this dependency, third party drivers
    like ptn3460 doesn't adhere to the driver model.
    
    In this patch, we reframe the bridge registration framework
    so that bridge initialization is split into 2 steps, and
    bridge registration happens independent of drm flow:
    --Step 1: gather all the bridge settings independent of drm and
              add the bridge onto a global list of bridges.
    --Step 2: when the encoder driver is probed, call drm_bridge_attach
              for the corresponding bridge so that the bridge receives
              drm_device pointer and continues with connector and other
              drm initializations.
    
    The old set of bridge helpers are removed, and a set of new helpers
    are added to accomplish the 2 step initialization.
    
    The bridge devices register themselves onto global list of bridges
    when they get probed by calling "drm_bridge_add".
    
    The parent encoder driver waits till the bridge is available
    in the lookup table(by calling "of_drm_find_bridge") and then
    continues with its initialization.
    
    The encoder driver should also call "drm_bridge_attach" to pass
    on the drm_device to the bridge object.
    
    drm_bridge_attach inturn calls "bridge->funcs->attach" so that
    bridge can continue with drm related initializations.
    
    Signed-off-by: Ajay Kumar <ajaykumar.rs@samsung.com>
    Acked-by: Inki Dae <inki.dae@samsung.com>
    Tested-by: Rahul Sharma <rahul.sharma@samsung.com>
    Tested-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Tested-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Tested-by: Sjoerd Simons <sjoerd.simons@collabora.co.uk>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 15bb762fb316..920e21a8f3fd 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -868,15 +868,16 @@ struct drm_plane {
 
 /**
  * struct drm_bridge_funcs - drm_bridge control functions
+ * @attach: Called during drm_bridge_attach
  * @mode_fixup: Try to fixup (or reject entirely) proposed mode for this bridge
  * @disable: Called right before encoder prepare, disables the bridge
  * @post_disable: Called right after encoder prepare, for lockstepped disable
  * @mode_set: Set this mode to the bridge
  * @pre_enable: Called right before encoder commit, for lockstepped commit
  * @enable: Called right after encoder commit, enables the bridge
- * @destroy: make object go away
  */
 struct drm_bridge_funcs {
+	int (*attach)(struct drm_bridge *bridge);
 	bool (*mode_fixup)(struct drm_bridge *bridge,
 			   const struct drm_display_mode *mode,
 			   struct drm_display_mode *adjusted_mode);
@@ -887,22 +888,24 @@ struct drm_bridge_funcs {
 			 struct drm_display_mode *adjusted_mode);
 	void (*pre_enable)(struct drm_bridge *bridge);
 	void (*enable)(struct drm_bridge *bridge);
-	void (*destroy)(struct drm_bridge *bridge);
 };
 
 /**
  * struct drm_bridge - central DRM bridge control structure
  * @dev: DRM device this bridge belongs to
- * @head: list management
+ * @of_node: device node pointer to the bridge
+ * @list: to keep track of all added bridges
  * @base: base mode object
  * @funcs: control functions
  * @driver_private: pointer to the bridge driver's internal context
  */
 struct drm_bridge {
 	struct drm_device *dev;
-	struct list_head head;
-
-	struct drm_mode_object base;
+	struct drm_encoder *encoder;
+#ifdef CONFIG_OF
+	struct device_node *of_node;
+#endif
+	struct list_head list;
 
 	const struct drm_bridge_funcs *funcs;
 	void *driver_private;
@@ -1007,7 +1010,6 @@ struct drm_mode_group {
 	uint32_t num_crtcs;
 	uint32_t num_encoders;
 	uint32_t num_connectors;
-	uint32_t num_bridges;
 
 	/* list of object IDs for this group */
 	uint32_t *id_list;
@@ -1026,8 +1028,6 @@ struct drm_mode_group {
  * @fb_list: list of framebuffers available
  * @num_connector: number of connectors on this device
  * @connector_list: list of connector objects
- * @num_bridge: number of bridges on this device
- * @bridge_list: list of bridge objects
  * @num_encoder: number of encoders on this device
  * @encoder_list: list of encoder objects
  * @num_overlay_plane: number of overlay planes on this device
@@ -1072,8 +1072,6 @@ struct drm_mode_config {
 
 	int num_connector;
 	struct list_head connector_list;
-	int num_bridge;
-	struct list_head bridge_list;
 	int num_encoder;
 	struct list_head encoder_list;
 
@@ -1222,8 +1220,10 @@ extern unsigned int drm_connector_index(struct drm_connector *connector);
 /* helper to unplug all connectors from sysfs for device */
 extern void drm_connector_unplug_all(struct drm_device *dev);
 
-extern int drm_bridge_init(struct drm_device *dev, struct drm_bridge *bridge);
-extern void drm_bridge_cleanup(struct drm_bridge *bridge);
+extern int drm_bridge_add(struct drm_bridge *bridge);
+extern void drm_bridge_remove(struct drm_bridge *bridge);
+extern struct drm_bridge *of_drm_find_bridge(struct device_node *np);
+extern int drm_bridge_attach(struct drm_device *dev, struct drm_bridge *bridge);
 
 extern int drm_encoder_init(struct drm_device *dev,
 			    struct drm_encoder *encoder,

commit b07b90fd178a4797b0454ead491b717b41046bee
Author: Ajay Kumar <ajaykumar.rs@samsung.com>
Date:   Tue Jan 20 22:08:43 2015 +0530

    drm/bridge: do not pass drm_bridge_funcs to drm_bridge_init
    
    Assign the pointer to bridge ops structure(drm_bridge_funcs) in
    the bridge driver itself, instead of passing it to drm_bridge_init.
    
    This will allow bridge driver developer to pack bridge private
    information inside the bridge object and pass only the drm-relevant
    information to drm_bridge_init.
    
    Signed-off-by: Ajay Kumar <ajaykumar.rs@samsung.com>
    Acked-by: Inki Dae <inki.dae@samsung.com>
    Tested-by: Rahul Sharma <rahul.sharma@samsung.com>
    Tested-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Tested-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Tested-by: Sjoerd Simons <sjoerd.simons@collabora.co.uk>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 02614170c034..15bb762fb316 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1222,8 +1222,7 @@ extern unsigned int drm_connector_index(struct drm_connector *connector);
 /* helper to unplug all connectors from sysfs for device */
 extern void drm_connector_unplug_all(struct drm_device *dev);
 
-extern int drm_bridge_init(struct drm_device *dev, struct drm_bridge *bridge,
-			   const struct drm_bridge_funcs *funcs);
+extern int drm_bridge_init(struct drm_device *dev, struct drm_bridge *bridge);
 extern void drm_bridge_cleanup(struct drm_bridge *bridge);
 
 extern int drm_encoder_init(struct drm_device *dev,

commit 21773f16f2cb3c056051c679da542f0b494252e2
Merge: 2f5b4ef15c60 9469244d8696
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Jan 28 09:34:27 2015 +1000

    Merge tag 'topic/atomic-core-2015-01-27' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    * tag 'topic/atomic-core-2015-01-27' of git://anongit.freedesktop.org/drm-intel:
      drm/atomic: Fix potential use of state after free
      drm/atomic-helper: debug output for modesets
      drm/atomic-helpers: Saner encoder/crtc callbacks
      drm/atomic-helpers: Recover full cursor plane behaviour
      drm/atomic-helper: add connector->dpms() implementation
      drm/atomic: Add drm_crtc_state->active
      drm: Add standardized boolean props
      drm/plane-helper: Fix transitional helper kerneldocs
      drm/plane-helper: Skip prepare_fb/cleanup_fb when newfb==oldfb
    
    Conflicts:
            include/drm/drm_crtc_helper.h

commit f02ad907cd9e7fe3a6405d2d005840912f1ed258
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 22 16:36:23 2015 +0100

    drm/atomic-helpers: Recover full cursor plane behaviour
    
    Cursor plane updates have historically been fully async and mutliple
    updates batched together for the next vsync. And userspace relies upon
    that. Since implementing a full queue of async atomic updates is a bit
    of work lets just recover the cursor specific behaviour with a hint
    flag and some hacks to drop the vblank wait.
    
    v2: Fix kerneldoc, reported by Wu Fengguang.
    
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 0a738e1d4f37..019c9b562144 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -909,6 +909,7 @@ struct drm_bridge {
  * struct struct drm_atomic_state - the global state object for atomic updates
  * @dev: parent DRM device
  * @allow_modeset: allow full modeset
+ * @legacy_cursor_update: hint to enforce legacy cursor ioctl semantics
  * @planes: pointer to array of plane pointers
  * @plane_states: pointer to array of plane states pointers
  * @crtcs: pointer to array of CRTC pointers
@@ -921,6 +922,7 @@ struct drm_bridge {
 struct drm_atomic_state {
 	struct drm_device *dev;
 	bool allow_modeset : 1;
+	bool legacy_cursor_update : 1;
 	struct drm_plane **planes;
 	struct drm_plane_state **plane_states;
 	struct drm_crtc **crtcs;

commit eab3bbeffd152125ae0f90863b8e9bc8eef49423
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 22 16:36:21 2015 +0100

    drm/atomic: Add drm_crtc_state->active
    
    This is the infrastructure for DPMS ported to the atomic world.
    Fundamental changes compare to legacy DPMS are:
    
    - No more per-connector dpms state, instead there's just one per each
      display pipeline. So if you clone either you have to unclone first
      if you only want to switch off one screen, or you just switch of
      everything (like all desktops do). This massively reduces complexity
      for cloning since now there's no more half-enabled cloned configs to
      consider.
    
    - Only on/off, dpms standby/suspend are as dead as real CRTs. Again
      reduces complexity a lot.
    
    Now especially for backwards compat the really important part for dpms
    support is that dpms on always succeeds (except for hw death and
    unplugged cables ofc). Which means everything that could fail (like
    configuration checking, resources assignments and buffer management)
    must be done irrespective from ->active. ->active is really only a
    toggle to change the hardware state. More precisely:
    
    - Drivers MUST NOT look at ->active in their ->atomic_check callbacks.
      Changes to ->active MUST always suceed if nothing else changes.
    
    - Drivers using the atomic helpers MUST NOT look at ->active anywhere,
      period. The helpers will take care of calling the respective
      enable/modeset/disable hooks as necessary. As before the helpers
      will carefully keep track of the state and not call any hooks
      unecessarily, so still no double-disables or enables like with crtc
      helpers.
    
    - ->mode_set hooks are only called when the mode or output
      configuration changes, not for changes in ->active state.
    
    - Drivers which reconstruct the state objects in their ->reset hooks
      or through some other hw state readout infrastructure must ensure
      that ->active reflects actual hw state.
    
    This just implements the core bits and helper logic, a subsequent
    patch will implement the helper code to implement legacy dpms with
    this.
    
    v2: Rebase on top of the drm ioctl work:
    - Move crtc checks to the core check function.
    - Also check for ->active_changed when deciding whether a modeset
      might happen (for the ALLOW_MODESET mode).
    - Expose the ->active state with an atomic prop.
    
    v3: Review from Rob
    - Spelling fix in comment.
    - Extract needs_modeset helper to consolidate the ->mode_changed ||
      ->active_changed checks.
    
    v4: Fixup fumble between crtc->state and crtc_state.
    
    Cc: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Tested-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c4e36f60b3ef..0a738e1d4f37 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -253,6 +253,7 @@ struct drm_atomic_state;
  * @enable: whether the CRTC should be enabled, gates all other state
  * @active: whether the CRTC is actively displaying (used for DPMS)
  * @mode_changed: for use by helpers and drivers when computing state updates
+ * @active_changed: for use by helpers and drivers when computing state updates
  * @plane_mask: bitmask of (1 << drm_plane_index(plane)) of attached planes
  * @last_vblank_count: for helpers and drivers to capture the vblank of the
  * 	update to ensure framebuffer cleanup isn't done too early
@@ -278,6 +279,7 @@ struct drm_crtc_state {
 	/* computed state bits used by helpers and drivers */
 	bool planes_changed : 1;
 	bool mode_changed : 1;
+	bool active_changed : 1;
 
 	/* attached planes bitmask:
 	 * WARNING: transitional helpers do not maintain plane_mask so
@@ -1113,6 +1115,7 @@ struct drm_mode_config {
 	struct drm_property *prop_crtc_h;
 	struct drm_property *prop_fb_id;
 	struct drm_property *prop_crtc_id;
+	struct drm_property *prop_active;
 
 	/* DVI-I properties */
 	struct drm_property *dvi_i_subconnector_property;

commit 960cd9d4fef6dd9e235c0e5c0d4ed027f8a48025
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jan 21 08:47:38 2015 +0100

    drm: Add standardized boolean props
    
    Not a new type exposed to userspace, just a standard way to create
    them since between range, bitmask and enum there's 3 different ways to
    pull out a boolean prop.
    
    Also add the kerneldoc for the recently added new prop types, which
    Rob forgot all about.
    
    v2: Fixup kerneldoc, spotted by Rob.
    
    Cc: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 0ecfb7c80601..c4e36f60b3ef 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1345,6 +1345,8 @@ struct drm_property *drm_property_create_signed_range(struct drm_device *dev,
 					 int64_t min, int64_t max);
 struct drm_property *drm_property_create_object(struct drm_device *dev,
 					 int flags, const char *name, uint32_t type);
+struct drm_property *drm_property_create_bool(struct drm_device *dev, int flags,
+					 const char *name);
 extern void drm_property_destroy(struct drm_device *dev, struct drm_property *property);
 extern int drm_property_add_enum(struct drm_property *property, int index,
 				 uint64_t value, const char *name);

commit 1da30627fc511a57c9bd23a02c97f0576379f761
Author: Matt Roper <matthew.d.roper@intel.com>
Date:   Wed Jan 21 16:35:40 2015 -0800

    drm: Add rotation value to plane state
    
    The rotation property is shared by multiple drivers, so it makes sense
    to store the rotation value (for atomic-converted drivers) in the common
    plane state so that core code can eventually access it as well.
    
    Cc: dri-devel@lists.freedesktop.org
    Suggested-by: Daniel Vetter <daniel@ffwll.ch>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index ac55ab0dc88b..0ebd9286b332 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -764,6 +764,9 @@ struct drm_plane_state {
 	uint32_t src_x, src_y;
 	uint32_t src_h, src_w;
 
+	/* Plane rotation */
+	unsigned int rotation;
+
 	struct drm_atomic_state *state;
 };
 

commit e4514003c6d0afd0a2d7e23e397530d746f34057
Merge: bdfcea4bdcd3 b77037262511
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Jan 27 08:54:11 2015 +1000

    Merge tag 'topic/core-stuff-2015-01-23' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    Just flushing out my drm-misc branch, nothing major. Well too old patches
    I've dug out from years since a patch from Rob look eerily familiar ;-)
    
    * tag 'topic/core-stuff-2015-01-23' of git://anongit.freedesktop.org/drm-intel:
      drm/probe-helper: clamp unknown connector status in the poll work
      drm/probe-helper: don't lose hotplug event
      next: drm/atomic: Use copy_from_user to copy 64 bit data from user space
      drm: Make drm_read() more robust against multithreaded races
      drm/fb-helper: Propagate errors from initial config failure
      drm: Drop superfluous "select VT_HW_CONSOLE_BINDING"

commit 162b6a57ac50eec236530a16c071ffa50e87362a
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jan 21 08:45:21 2015 +0100

    drm/probe-helper: don't lose hotplug event
    
    There's a race window (small for hpd, 10s large for polled outputs)
    where userspace could sneak in with an unrelated connnector probe
    ioctl call and eat the hotplug event (since neither the hpd nor the
    poll code see a state change).
    
    To avoid this, check whether the connector state changes in all other
    ->detect calls (in the current helper code that's only probe_single)
    and if that's the case, fire off a hotplug event. Note that we can't
    directly call the hotplug event handler, since that expects that no
    locks are held (due to reentrancy with the fb code to update the kms
    console).
    
    Also, this requires that drivers using the probe_single helper
    function set up the poll work. All current drivers do that already,
    and with the reworked hpd handling there'll be no downside to
    unconditionally setting up the poll work any more.
    
    v2: Review from Rob Clark
    - Don't bail out of the output poll work immediately if it's disabled
      to make sure we deliver the delayed hoptplug events. Instead just
      jump to the tail.
    - Don't scheduel the work when it's not set up. Would be a driver bug
      since using probe helpers for anything dynamic without them
      initialized makes them all noops.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk> (v1)
    Cc: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Tested-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f444263055c5..65da9fb939a7 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1089,6 +1089,7 @@ struct drm_mode_config {
 	/* output poll support */
 	bool poll_enabled;
 	bool poll_running;
+	bool delayed_event;
 	struct delayed_work output_poll_work;
 
 	/* pointers to standard properties */

commit b5571e9df66c1bfb81a4a7947726c3d627d3cb41
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Tue Jul 22 12:09:10 2014 +0200

    drm: add bus_formats and num_bus_formats fields to drm_display_info
    
    Add bus_formats and num_bus_formats fields and
    drm_display_info_set_bus_formats helper function to specify the bus
    formats supported by a given display.
    
    This information can be used by display controller drivers to configure
    the output interface appropriately (i.e. RGB565, RGB666 or RGB888 on raw
    RGB or LVDS busses).
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f444263055c5..0ecfb7c80601 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -31,6 +31,7 @@
 #include <linux/idr.h>
 #include <linux/fb.h>
 #include <linux/hdmi.h>
+#include <linux/media-bus-format.h>
 #include <uapi/drm/drm_mode.h>
 #include <uapi/drm/drm_fourcc.h>
 #include <drm/drm_modeset_lock.h>
@@ -139,6 +140,9 @@ struct drm_display_info {
 	enum subpixel_order subpixel_order;
 	u32 color_formats;
 
+	const u32 *bus_formats;
+	unsigned int num_bus_formats;
+
 	/* Mask of supported hdmi deep color modes */
 	u8 edid_hdmi_dc_modes;
 
@@ -1282,6 +1286,10 @@ int drm_mode_connector_set_tile_property(struct drm_connector *connector);
 extern int drm_mode_connector_update_edid_property(struct drm_connector *connector,
 						   const struct edid *edid);
 
+extern int drm_display_info_set_bus_formats(struct drm_display_info *info,
+					    const u32 *formats,
+					    unsigned int num_formats);
+
 static inline bool drm_property_type_is(struct drm_property *property,
 		uint32_t type)
 {

commit adc31849b27fefeca6c225d3895143a2ec6970fa
Merge: c93546a5e32b 0e2cfc005b37
Author: Dave Airlie <airlied@redhat.com>
Date:   Sat Jan 10 08:46:24 2015 +1000

    Merge tag 'drm-intel-next-2014-12-19' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - plane handling refactoring from Matt Roper and Gustavo Padovan in prep for
      atomic updates
    - fixes and more patches for the seqno to request transformation from John
    - docbook for fbc from Rodrigo
    - prep work for dual-link dsi from Gaurav Signh
    - crc fixes from Ville
    - special ggtt views infrastructure from Tvrtko Ursulin
    - shadow patch copying for the cmd parser from Brad Volkin
    - execlist and full ppgtt by default on gen8, for testing for now
    
    * tag 'drm-intel-next-2014-12-19' of git://anongit.freedesktop.org/drm-intel: (131 commits)
      drm/i915: Update DRIVER_DATE to 20141219
      drm/i915: Hold runtime PM during plane commit
      drm/i915: Organize bind_vma funcs
      drm/i915: Organize INSTDONE report for future.
      drm/i915: Organize PDP regs report for future.
      drm/i915: Organize PPGTT init
      drm/i915: Organize Fence registers for future enablement.
      drm/i915: tame the chattermouth (v2)
      drm/i915: Warn about missing context state workarounds only once
      drm/i915: Use true PPGTT in Gen8+ when execlists are enabled
      drm/i915: Skip gunit save/restore for cherryview
      drm/i915/chv: Use timeout mode for RC6 on chv
      drm/i915: Add GPGPU_THREADS_DISPATCHED to the register whitelist
      drm/i915: Tidy up execbuffer command parsing code
      drm/i915: Mark shadow batch buffers as purgeable
      drm/i915: Use batch length instead of object size in command parser
      drm/i915: Use batch pools with the command parser
      drm/i915: Implement a framework for batch buffer pools
      drm/i915: fix use after free during eDP encoder destroying
      drm/i915/skl: Skylake also supports DP MST
      ...

commit c93546a5e32bd788c22aefa072385f3784551c13
Merge: e5202a2289d7 179f158ccf15
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Jan 9 09:22:40 2015 +1000

    Merge tag 'topic/atomic-core-2015-01-05' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    Next batch of atomic work. Most important is the propertification from Rob
    and the nth iteration of the actual atomic ioctl originally from Ville.
    Big differences compared to earlier revisions:
    - Core properties are now fully handled by the core, drivers can only
      handle driver-specific properties.
    - Atomic props&ioctl are opt-in per file_priv, userspace needs to
      explicitly ask for it (like universal plane support).
    - For now all hidden behind the atomic module option until this has
      settled a bit.
    - Atomic modesets are currently not possible since the exact abi for how
      to handle the mode property is still under discussion.
    
    Besides this some cleanup patches from me and the addition of per-object
    state to global state backpointers to simplify drivers.
    
    * tag 'topic/atomic-core-2015-01-05' of git://anongit.freedesktop.org/drm-intel:
      drm: Ensure universal_planes is set for atomic
      drm/atomic: Hide drm.ko internal interfaces
      drm: Atomic modeset ioctl
      drm/atomic: atomic connector properties
      drm/atomic: atomic plane properties
      drm: small property creation cleanup
      drm/atomic: atomic_check functions
      drm: add atomic properties
      drm: refactor getproperties/getconnector
      drm: tweak getconnector locking
      drm: add atomic_get_property
      drm: add atomic_set_property wrappers
      drm: get rid of direct property value access
      drm: store property instead of id in obj attachment
      drm: allow property validation for refcnted props
      drm/atomic: Introduce state->obj backpointers
      drm/atomic-helper: Again check modeset *before* plane states
      drm/atomic-helper: Export both plane and modeset check helpers

commit e5202a2289d746a94703ad937157d398fb2607cf
Merge: b1940cd21c0f 7552e7dd9527
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Jan 9 09:13:41 2015 +1000

    Merge tag 'topic/core-stuff-2014-12-19' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    Misc drm patches with mostly polish patches from Thierry, with a bit of
    generic mode validation from Ville and a few other oddball things.
    
    * tag 'topic/core-stuff-2014-12-19' of git://anongit.freedesktop.org/drm-intel: (25 commits)
      drm: Include drm_crtc_helper.h in DocBook
      drm: Make drm_crtc_helper.h standalone includible
      drm: Move IRQ related fields to proper section
      drm: Remove stale comment
      drm: Do basic sanity checks for user modes
      drm: Perform basic sanity checks on probed modes
      drm: Reorganize probed mode validation
      drm/doc: Remove duplicate "by"
      drm/info: Remove unused code
      drm/cache: Use wbinvd helpers
      drm/plane-helper: Test for plane disable earlier
      drm/doc: Document drm_add_modes_noedid() usage
      drm: bit of spell-check / editorializing.
      drm: Prefer sizeof(type) over sizeof type
      drm: Remove useless else block
      drm: Remove unneeded braces for single statement blocks
      drm: Do not assign in if condition
      drm: Prefer kmalloc_array() over kmalloc() with multiply
      drm: Prefer kcalloc() over kzalloc() with multiply
      drm: Miscellaneous checkpatch whitespace cleanups
      ...

commit d34f20d6e2f21bd3531b969dc40913181a8ae31a
Author: Rob Clark <robdclark@gmail.com>
Date:   Thu Dec 18 16:01:56 2014 -0500

    drm: Atomic modeset ioctl
    
    The atomic modeset ioctl can be used to push any number of new values
    for object properties. The driver can then check the full device
    configuration as single unit, and try to apply the changes atomically.
    
    The ioctl simply takes a list of object IDs and property IDs and their
    values.
    
    Originally based on a patch from Ville Syrjälä, although it has mutated
    (mutilated?) enough since then that you probably shouldn't blame it on
    him ;-)
    
    The atomic support is hidden behind the DRM_CLIENT_CAP_ATOMIC cap (to
    protect legacy userspace) and drm.atomic module param (for now).
    
    v2: Check for file_priv->atomic to make sure we only allow userspace
    in-the-know to use atomic.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index fc4767fa723b..1dcfb685d15f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -902,7 +902,7 @@ struct drm_bridge {
 /**
  * struct struct drm_atomic_state - the global state object for atomic updates
  * @dev: parent DRM device
- * @flags: state flags like async update
+ * @allow_modeset: allow full modeset
  * @planes: pointer to array of plane pointers
  * @plane_states: pointer to array of plane states pointers
  * @crtcs: pointer to array of CRTC pointers
@@ -914,7 +914,7 @@ struct drm_bridge {
  */
 struct drm_atomic_state {
 	struct drm_device *dev;
-	uint32_t flags;
+	bool allow_modeset : 1;
 	struct drm_plane **planes;
 	struct drm_plane_state **plane_states;
 	struct drm_crtc **crtcs;
@@ -1346,6 +1346,10 @@ extern int drm_mode_create_scaling_mode_property(struct drm_device *dev);
 extern int drm_mode_create_aspect_ratio_property(struct drm_device *dev);
 extern int drm_mode_create_dirty_info_property(struct drm_device *dev);
 extern int drm_mode_create_suggested_offset_properties(struct drm_device *dev);
+extern bool drm_property_change_valid_get(struct drm_property *property,
+					 uint64_t value, struct drm_mode_object **ref);
+extern void drm_property_change_valid_put(struct drm_property *property,
+		struct drm_mode_object *ref);
 
 extern int drm_mode_connector_attach_encoder(struct drm_connector *connector,
 					     struct drm_encoder *encoder);
@@ -1437,6 +1441,8 @@ extern int drm_mode_obj_set_property_ioctl(struct drm_device *dev, void *data,
 extern int drm_mode_plane_set_obj_prop(struct drm_plane *plane,
 				       struct drm_property *property,
 				       uint64_t value);
+extern int drm_mode_atomic_ioctl(struct drm_device *dev,
+				 void *data, struct drm_file *file_priv);
 
 extern void drm_fb_get_bpp_depth(uint32_t format, unsigned int *depth,
 				 int *bpp);

commit 6b4959f43a04e12d39c5700607727f2cbcfeac31
Author: Rob Clark <robdclark@gmail.com>
Date:   Thu Dec 18 16:01:53 2014 -0500

    drm/atomic: atomic plane properties
    
    Expose the core plane state as properties, so they can be updated via
    atomic ioctl.
    
    v2: atomic property flag
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b5ab673add29..fc4767fa723b 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1099,6 +1099,16 @@ struct drm_mode_config {
 	struct drm_property *tile_property;
 	struct drm_property *plane_type_property;
 	struct drm_property *rotation_property;
+	struct drm_property *prop_src_x;
+	struct drm_property *prop_src_y;
+	struct drm_property *prop_src_w;
+	struct drm_property *prop_src_h;
+	struct drm_property *prop_crtc_x;
+	struct drm_property *prop_crtc_y;
+	struct drm_property *prop_crtc_w;
+	struct drm_property *prop_crtc_h;
+	struct drm_property *prop_fb_id;
+	struct drm_property *prop_crtc_id;
 
 	/* DVI-I properties */
 	struct drm_property *dvi_i_subconnector_property;

commit 88a48e297b3a3bac6022c03babfb038f1a886cea
Author: Rob Clark <robdclark@gmail.com>
Date:   Thu Dec 18 16:01:50 2014 -0500

    drm: add atomic properties
    
    Once a driver is using atomic helpers for modeset, the next step is to
    switch over to atomic properties.  To do this, make sure that any
    modeset objects have their ->atomic_{get,set}_property() vfuncs suitably
    populated if they have custom properties (you did already remember to
    plug in atomic-helper func for the legacy ->set_property() vfuncs,
    right?), and then set DRIVER_ATOMIC bit in driver_features flag.
    
    A new cap is introduced, DRM_CLIENT_CAP_ATOMIC, for the purposes of
    shielding legacy userspace from atomic properties.  Mostly for the
    benefit of legacy DDX drivers that do silly things like getting/setting
    each property at startup (since some of the new atomic properties will
    be able to trigger modeset).
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    [danvet: Squash in fixup patch to check for DRM_MODE_PROP_ATOMIC
    instaed of the CAP define when filtering properties. Reported by
    Tvrtko Uruslin, acked by Rob.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index e1f34694fcff..b5ab673add29 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -63,7 +63,7 @@ struct drm_mode_object {
 
 #define DRM_OBJECT_MAX_PROPERTY 24
 struct drm_object_properties {
-	int count;
+	int count, atomic_count;
 	/* NOTE: if we ever start dynamically destroying properties (ie.
 	 * not at drm_mode_config_cleanup() time), then we'd have to do
 	 * a better job of detaching property from mode objects to avoid

commit ac9c925616028f1f03f631f229bca49b3a92ce9a
Author: Rob Clark <robdclark@gmail.com>
Date:   Thu Dec 18 16:01:47 2014 -0500

    drm: add atomic_get_property
    
    Since we won't be using the obj->properties->values[] array to shadow
    property values for atomic drivers, we are going to need a vfunc for
    getting prop values.  Add that along w/ mandatory wrapper fxns.
    
    v2: more comments and copypasta comment typo fix
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 7f158963ef87..e1f34694fcff 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -312,6 +312,8 @@ struct drm_crtc_state {
  * @atomic_destroy_state: destroy an atomic state for this CRTC
  * @atomic_set_property: set a property on an atomic state for this CRTC
  *    (do not call directly, use drm_atomic_crtc_set_property())
+ * @atomic_get_property: get a property on an atomic state for this CRTC
+ *    (do not call directly, use drm_atomic_crtc_get_property())
  *
  * The drm_crtc_funcs structure is the central CRTC management structure
  * in the DRM.  Each CRTC controls one or more connectors (note that the name
@@ -371,6 +373,10 @@ struct drm_crtc_funcs {
 				   struct drm_crtc_state *state,
 				   struct drm_property *property,
 				   uint64_t val);
+	int (*atomic_get_property)(struct drm_crtc *crtc,
+				   const struct drm_crtc_state *state,
+				   struct drm_property *property,
+				   uint64_t *val);
 };
 
 /**
@@ -499,6 +505,8 @@ struct drm_connector_state {
  * @atomic_destroy_state: destroy an atomic state for this connector
  * @atomic_set_property: set a property on an atomic state for this connector
  *    (do not call directly, use drm_atomic_connector_set_property())
+ * @atomic_get_property: get a property on an atomic state for this connector
+ *    (do not call directly, use drm_atomic_connector_get_property())
  *
  * Each CRTC may have one or more connectors attached to it.  The functions
  * below allow the core DRM code to control connectors, enumerate available modes,
@@ -532,6 +540,10 @@ struct drm_connector_funcs {
 				   struct drm_connector_state *state,
 				   struct drm_property *property,
 				   uint64_t val);
+	int (*atomic_get_property)(struct drm_connector *connector,
+				   const struct drm_connector_state *state,
+				   struct drm_property *property,
+				   uint64_t *val);
 };
 
 /**
@@ -763,6 +775,8 @@ struct drm_plane_state {
  * @atomic_destroy_state: destroy an atomic state for this plane
  * @atomic_set_property: set a property on an atomic state for this plane
  *    (do not call directly, use drm_atomic_plane_set_property())
+ * @atomic_get_property: get a property on an atomic state for this plane
+ *    (do not call directly, use drm_atomic_plane_get_property())
  */
 struct drm_plane_funcs {
 	int (*update_plane)(struct drm_plane *plane,
@@ -786,6 +800,10 @@ struct drm_plane_funcs {
 				   struct drm_plane_state *state,
 				   struct drm_property *property,
 				   uint64_t val);
+	int (*atomic_get_property)(struct drm_plane *plane,
+				   const struct drm_plane_state *state,
+				   struct drm_property *property,
+				   uint64_t *val);
 };
 
 enum drm_plane_type {

commit 40ecc694e114a06b9ed77e3e94641b0f5490693c
Author: Rob Clark <robdclark@gmail.com>
Date:   Thu Dec 18 16:01:46 2014 -0500

    drm: add atomic_set_property wrappers
    
    As we add properties for all the standard plane/crtc/connector
    attributes (in preperation for the atomic ioctl), we are going to want
    to handle core state in core (rather than per driver).  Intercepting the
    core properties will be easier if the atomic_set_property vfuncs are not
    called directly, but instead have a mandatory wrapper function (which
    will later serve as the point to intercept core properties).
    
    v2: more verbose comments and copypasta comment fix
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f7c0b7bb9d5f..7f158963ef87 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -311,6 +311,7 @@ struct drm_crtc_state {
  * @atomic_duplicate_state: duplicate the atomic state for this CRTC
  * @atomic_destroy_state: destroy an atomic state for this CRTC
  * @atomic_set_property: set a property on an atomic state for this CRTC
+ *    (do not call directly, use drm_atomic_crtc_set_property())
  *
  * The drm_crtc_funcs structure is the central CRTC management structure
  * in the DRM.  Each CRTC controls one or more connectors (note that the name
@@ -497,6 +498,7 @@ struct drm_connector_state {
  * @atomic_duplicate_state: duplicate the atomic state for this connector
  * @atomic_destroy_state: destroy an atomic state for this connector
  * @atomic_set_property: set a property on an atomic state for this connector
+ *    (do not call directly, use drm_atomic_connector_set_property())
  *
  * Each CRTC may have one or more connectors attached to it.  The functions
  * below allow the core DRM code to control connectors, enumerate available modes,
@@ -760,6 +762,7 @@ struct drm_plane_state {
  * @atomic_duplicate_state: duplicate the atomic state for this plane
  * @atomic_destroy_state: destroy an atomic state for this plane
  * @atomic_set_property: set a property on an atomic state for this plane
+ *    (do not call directly, use drm_atomic_plane_set_property())
  */
 struct drm_plane_funcs {
 	int (*update_plane)(struct drm_plane *plane,

commit 22b8b13b6f436ffbb6e540f5f8039b1084a72794
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Dec 16 18:05:31 2014 -0500

    drm: get rid of direct property value access
    
    For atomic drivers, we won't use the values array but instead shunt
    things off to obj->atomic_get_property().  So to simplify things make
    all read/write of properties values go through the accessors.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 265f90afcac4..f7c0b7bb9d5f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -70,6 +70,9 @@ struct drm_object_properties {
 	 * dangling property pointers:
 	 */
 	struct drm_property *properties[DRM_OBJECT_MAX_PROPERTY];
+	/* do not read/write values directly, but use drm_object_property_get_value()
+	 * and drm_object_property_set_value():
+	 */
 	uint64_t values[DRM_OBJECT_MAX_PROPERTY];
 };
 

commit b17cd757a3f61e4519b70b4673f0467ec0153a10
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Dec 16 18:05:30 2014 -0500

    drm: store property instead of id in obj attachment
    
    Keep property pointer, instead of id, in per mode-object attachments.
    This will simplify things in later patches.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index fd8139ca629a..265f90afcac4 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -64,7 +64,12 @@ struct drm_mode_object {
 #define DRM_OBJECT_MAX_PROPERTY 24
 struct drm_object_properties {
 	int count;
-	uint32_t ids[DRM_OBJECT_MAX_PROPERTY];
+	/* NOTE: if we ever start dynamically destroying properties (ie.
+	 * not at drm_mode_config_cleanup() time), then we'd have to do
+	 * a better job of detaching property from mode objects to avoid
+	 * dangling property pointers:
+	 */
+	struct drm_property *properties[DRM_OBJECT_MAX_PROPERTY];
 	uint64_t values[DRM_OBJECT_MAX_PROPERTY];
 };
 

commit 07cc0ef67fa873c8d21e0b626d57753bfd190095
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Nov 27 15:49:39 2014 +0100

    drm/atomic: Introduce state->obj backpointers
    
    Useful since this way we can pass around just the state objects and
    will get ther real object, too.
    
    Specifically this allows us to again simplify the parameters for
    set_crtc_for_plane.
    
    v2: msm already has it's own specific plane_reset hook, don't forget
    that one!
    
    v3: Fixup kerneldoc, reported by 0-day builder.
    
    Cc: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com> (v2)
    Tested-by: Rob Clark <robdclark@gmail.com> (v2)
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 4ee78212f8bf..fd8139ca629a 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -237,6 +237,7 @@ struct drm_atomic_state;
 
 /**
  * struct drm_crtc_state - mutable CRTC state
+ * @crtc: backpointer to the CRTC
  * @enable: whether the CRTC should be enabled, gates all other state
  * @active: whether the CRTC is actively displaying (used for DPMS)
  * @mode_changed: for use by helpers and drivers when computing state updates
@@ -257,6 +258,8 @@ struct drm_atomic_state;
  * assignment, @active controls the actual hardware state.
  */
 struct drm_crtc_state {
+	struct drm_crtc *crtc;
+
 	bool enable;
 	bool active;
 
@@ -457,11 +460,14 @@ struct drm_crtc {
 
 /**
  * struct drm_connector_state - mutable connector state
+ * @connector: backpointer to the connector
  * @crtc: CRTC to connect connector to, NULL if disabled
  * @best_encoder: can be used by helpers and drivers to select the encoder
  * @state: backpointer to global drm_atomic_state
  */
 struct drm_connector_state {
+	struct drm_connector *connector;
+
 	struct drm_crtc *crtc;  /* do not write directly, use drm_atomic_set_crtc_for_connector() */
 
 	struct drm_encoder *best_encoder;
@@ -701,6 +707,7 @@ struct drm_connector {
 
 /**
  * struct drm_plane_state - mutable plane state
+ * @plane: backpointer to the plane
  * @crtc: currently bound CRTC, NULL if disabled
  * @fb: currently bound framebuffer
  * @fence: optional fence to wait for before scanning out @fb
@@ -717,6 +724,8 @@ struct drm_connector {
  * @state: backpointer to global drm_atomic_state
  */
 struct drm_plane_state {
+	struct drm_plane *plane;
+
 	struct drm_crtc *crtc;   /* do not write directly, use drm_atomic_set_crtc_for_plane() */
 	struct drm_framebuffer *fb;  /* do not write directly, use drm_atomic_set_fb_for_plane() */
 	struct fence *fence;

commit d9b13620fa09d2652008f96e083592c772532fd1
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Nov 26 16:57:41 2014 +0100

    drm/atomic-helper: Export both plane and modeset check helpers
    
    The default call sequence for these two parts won't fit for all
    drivers. So export the two pieces and explain with a bit of kerneldoc
    when each should be called.
    
    v2: Squash in fixup from Rob to actually add the newly exported
    functions to headers
    
    Cc: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b86329813ad3..4ee78212f8bf 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -238,6 +238,7 @@ struct drm_atomic_state;
 /**
  * struct drm_crtc_state - mutable CRTC state
  * @enable: whether the CRTC should be enabled, gates all other state
+ * @active: whether the CRTC is actively displaying (used for DPMS)
  * @mode_changed: for use by helpers and drivers when computing state updates
  * @plane_mask: bitmask of (1 << drm_plane_index(plane)) of attached planes
  * @last_vblank_count: for helpers and drivers to capture the vblank of the
@@ -248,9 +249,16 @@ struct drm_atomic_state;
  * @event: optional pointer to a DRM event to signal upon completion of the
  * 	state update
  * @state: backpointer to global drm_atomic_state
+ *
+ * Note that the distinction between @enable and @active is rather subtile:
+ * Flipping @active while @enable is set without changing anything else may
+ * never return in a failure from the ->atomic_check callback. Userspace assumes
+ * that a DPMS On will always succeed. In other words: @enable controls resource
+ * assignment, @active controls the actual hardware state.
  */
 struct drm_crtc_state {
 	bool enable;
+	bool active;
 
 	/* computed state bits used by helpers and drivers */
 	bool planes_changed : 1;

commit 261ea74f3689a997502f1264494f1749951a05a8
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Dec 17 16:41:40 2014 +0100

    drm: Remove stale comment
    
    The struct drm_connector_funcs kerneldoc refers to a part of struct
    drm_crtc_funcs that no longer exists.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index dd2c16e43333..eb32b09b3bab 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -455,7 +455,7 @@ struct drm_connector_state {
 
 /**
  * struct drm_connector_funcs - control connectors on a given device
- * @dpms: set power state (see drm_crtc_funcs above)
+ * @dpms: set power state
  * @save: save connector state
  * @restore: restore connector state
  * @reset: reset connector after state has been invalidated (e.g. resume)

commit 6f134d7bb4347ab4c66ef123efb838fedb54186f
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Oct 20 16:30:50 2014 +1000

    drm/tile: expose the tile property to userspace (v3)
    
    This takes the tiling info from the connector and
    exposes it to userspace, as a blob object in a
    connector property.
    
    The contents of the blob is ABI.
    
    v2: add property + function documentation.
    
    v3: move property setup from previous patch.
    add boilerplate + fix long line (Daniel)
    
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 01744ed79250..b86329813ad3 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -651,6 +651,8 @@ struct drm_connector {
 
 	struct drm_property_blob *path_blob_ptr;
 
+	struct drm_property_blob *tile_blob_ptr;
+
 	uint8_t polled; /* DRM_CONNECTOR_POLL_* */
 
 	/* requested DPMS state */
@@ -1048,6 +1050,7 @@ struct drm_mode_config {
 	struct drm_property *edid_property;
 	struct drm_property *dpms_property;
 	struct drm_property *path_property;
+	struct drm_property *tile_property;
 	struct drm_property *plane_type_property;
 	struct drm_property *rotation_property;
 
@@ -1217,6 +1220,7 @@ extern void drm_mode_config_cleanup(struct drm_device *dev);
 
 extern int drm_mode_connector_set_path_property(struct drm_connector *connector,
 						const char *path);
+int drm_mode_connector_set_tile_property(struct drm_connector *connector);
 extern int drm_mode_connector_update_edid_property(struct drm_connector *connector,
 						   const struct edid *edid);
 

commit 40d9b043a89e2301e1f97ade055a73ecc28e9afe
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Oct 20 16:29:33 2014 +1000

    drm/connector: store tile information from displayid (v3)
    
    This creates a tile group from DisplayID block, and
    stores the pieces of parsed info from the DisplayID block
    into the connector.
    
    v2: add missing signoff, add new connector bits to docs.
    
    v3: remove some debugging.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 8f760a2373f9..01744ed79250 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -607,6 +607,15 @@ struct drm_encoder {
  * @bad_edid_counter: track sinks that give us an EDID with invalid checksum
  * @debugfs_entry: debugfs directory for this connector
  * @state: current atomic state for this connector
+ * @has_tile: is this connector connected to a tiled monitor
+ * @tile_group: tile group for the connected monitor
+ * @tile_is_single_monitor: whether the tile is one monitor housing
+ * @num_h_tile: number of horizontal tiles in the tile group
+ * @num_v_tile: number of vertical tiles in the tile group
+ * @tile_h_loc: horizontal location of this tile
+ * @tile_v_loc: vertical location of this tile
+ * @tile_h_size: horizontal size of this tile.
+ * @tile_v_size: vertical size of this tile.
  *
  * Each connector may be connected to one or more CRTCs, or may be clonable by
  * another connector if they can share a CRTC.  Each connector also has a specific
@@ -669,6 +678,15 @@ struct drm_connector {
 	struct dentry *debugfs_entry;
 
 	struct drm_connector_state *state;
+
+	/* DisplayID bits */
+	bool has_tile;
+	struct drm_tile_group *tile_group;
+	bool tile_is_single_monitor;
+
+	uint8_t num_h_tile, num_v_tile;
+	uint8_t tile_h_loc, tile_v_loc;
+	uint16_t tile_h_size, tile_v_size;
 };
 
 /**

commit 138f9ebb9755a8cf09fd6a9ff8d011aaf5fb478f
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Oct 20 16:17:17 2014 +1000

    drm: add tile_group support. (v3)
    
    A tile group is an identifier shared by a single monitor,
    DisplayID topology has 8 bytes we can use for this, just
    use those for now until something else comes up in the
    future. We assign these to an idr and use the idr to
    tell userspace what connectors are in the same tile group.
    
    DisplayID v1.3 says the serial number must be unique for
    displays from the same manufacturer.
    
    v2:
    destroy idr (dvdhrm)
    add docbook (danvet)
    airlied:- not sure how to make docbook add fns to tile group section.
    
    v3: fix missing unlock.
    
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index dd2c16e43333..8f760a2373f9 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -137,6 +137,14 @@ struct drm_display_info {
 	u8 cea_rev;
 };
 
+/* data corresponds to displayid vend/prod/serial */
+struct drm_tile_group {
+	struct kref refcount;
+	struct drm_device *dev;
+	int id;
+	u8 group_data[8];
+};
+
 struct drm_framebuffer_funcs {
 	/* note: use drm_framebuffer_remove() */
 	void (*destroy)(struct drm_framebuffer *framebuffer);
@@ -978,6 +986,7 @@ struct drm_mode_config {
 	struct drm_modeset_acquire_ctx *acquire_ctx; /* for legacy _lock_all() / _unlock_all() */
 	struct mutex idr_mutex; /* for IDR management */
 	struct idr crtc_idr; /* use this idr for all IDs, fb, crtc, connector, modes - just makes life easier */
+	struct idr tile_idr; /* use this idr for all IDs, fb, crtc, connector, modes - just makes life easier */
 	/* this is limited to one for now */
 
 	struct mutex fb_lock; /* proctects global and per-file fb lists */
@@ -1326,6 +1335,13 @@ extern void drm_set_preferred_mode(struct drm_connector *connector,
 extern int drm_edid_header_is_valid(const u8 *raw_edid);
 extern bool drm_edid_block_valid(u8 *raw_edid, int block, bool print_bad_edid);
 extern bool drm_edid_is_valid(struct edid *edid);
+
+extern struct drm_tile_group *drm_mode_create_tile_group(struct drm_device *dev,
+							 char topology[8]);
+extern struct drm_tile_group *drm_mode_get_tile_group(struct drm_device *dev,
+					       char topology[8]);
+extern void drm_mode_put_tile_group(struct drm_device *dev,
+				   struct drm_tile_group *tg);
 struct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,
 					   int hsize, int vsize, int fresh,
 					   bool rb);

commit ecb7e16bf187bc369cf6a5cd108582c01329980d
Author: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Date:   Mon Dec 1 15:40:09 2014 -0800

    drm: add helper to get crtc timings (v5)
    
    We need to get hdisplay and vdisplay in a few places so create a
    helper to make our job easier.
    
    Note that drm_crtc_check_viewport() and intel_modeset_pipe_config() were
    previously making adjustments for doublescan modes and vscan > 1 modes,
    which was incorrect.  Using our new helper fixes this mistake.
    
    v2 (by Matt): Use new stereo doubling function (suggested by Ville)
    
    v3 (by Matt):
     - Add missing kerneldoc (Daniel)
     - Use drm_mode_copy() (Jani)
    
    v4 (by Matt):
     - Drop stereo doubling function again; add 'stereo only' flag
       to drm_mode_set_crtcinfo() instead (Ville)
    
    v5 (by Matt):
     - Note behavioral change in drm_crtc_check_viewport() and
       intel_modeset_pipe_config(). (Ander)
     - Describe new adjustment flags in drm_mode_set_crtcinfo()'s
       kerneldoc. (Ander)
    
    Cc: dri-devel@lists.freedesktop.org
    Suggested-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Reviewed-by: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index dd2c16e43333..969da0f1ded8 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1161,6 +1161,8 @@ extern int drm_plane_init(struct drm_device *dev,
 extern void drm_plane_cleanup(struct drm_plane *plane);
 extern unsigned int drm_plane_index(struct drm_plane *plane);
 extern void drm_plane_force_disable(struct drm_plane *plane);
+extern void drm_crtc_get_hv_timing(const struct drm_display_mode *mode,
+				   int *hdisplay, int *vdisplay);
 extern int drm_crtc_check_viewport(const struct drm_crtc *crtc,
 				   int x, int y,
 				   const struct drm_display_mode *mode,

commit dd275956aa176cf2ff00d5437c45f1552f1f3a11
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Nov 25 20:29:46 2014 -0500

    drm/atomic: add plane iterator macros
    
    Add helper macros to iterate the current, or incoming set of planes
    attached to a crtc.  These helpers are only available for drivers
    converted to use atomic-helpers.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    [danvet: Squash in fixup from Rob to move the planemask iterator to
    drm_crtc.h and document it. That one is needed by the atomic ioctl so
    can't be in a helper library.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 4cf6905b57f5..dd2c16e43333 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1062,6 +1062,19 @@ struct drm_mode_config {
 	uint32_t cursor_width, cursor_height;
 };
 
+/**
+ * drm_for_each_plane_mask - iterate over planes specified by bitmask
+ * @plane: the loop cursor
+ * @dev: the DRM device
+ * @plane_mask: bitmask of plane indices
+ *
+ * Iterate over all planes specified by bitmask.
+ */
+#define drm_for_each_plane_mask(plane, dev, plane_mask) \
+	list_for_each_entry((plane), &(dev)->mode_config.plane_list, head) \
+		if ((plane_mask) & (1 << drm_plane_index(plane)))
+
+
 #define obj_to_crtc(x) container_of(x, struct drm_crtc, base)
 #define obj_to_connector(x) container_of(x, struct drm_connector, base)
 #define obj_to_encoder(x) container_of(x, struct drm_encoder, base)

commit 6ddd388ab222b66b596342becc76d5031c0e2fc8
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Nov 21 15:28:31 2014 -0500

    drm/atomic: track bitmask of planes attached to crtc
    
    Chasing plane->state->crtc of planes that are *not* part of the same
    atomic update is racy, making it incredibly awkward (or impossible) to
    do something simple like iterate over all planes and figure out which
    ones are attached to a crtc.
    
    Solve this by adding a bitmask of currently attached planes in the
    crtc-state.
    
    Note that the transitional helpers do not maintain the plane_mask.  But
    they only support the legacy ioctls, which have sufficient brute-force
    locking around plane updates that they can continue to loop over all
    planes to see what is attached to a crtc the old way.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    [danvet:
    - Drop comments about locking in set_crtc_for_plane since they're a
      bit misleading - we already should hold lock for the current crtc.
    - Also WARN_ON if get_state on the old crtc fails since that should
      have been done already.
    - Squash in fixup to check get_plane_state return value, reported by
      Dan Carpenter and acked by Rob Clark.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b459e8fbbc25..4cf6905b57f5 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -231,6 +231,7 @@ struct drm_atomic_state;
  * struct drm_crtc_state - mutable CRTC state
  * @enable: whether the CRTC should be enabled, gates all other state
  * @mode_changed: for use by helpers and drivers when computing state updates
+ * @plane_mask: bitmask of (1 << drm_plane_index(plane)) of attached planes
  * @last_vblank_count: for helpers and drivers to capture the vblank of the
  * 	update to ensure framebuffer cleanup isn't done too early
  * @planes_changed: for use by helpers and drivers when computing state updates
@@ -247,6 +248,13 @@ struct drm_crtc_state {
 	bool planes_changed : 1;
 	bool mode_changed : 1;
 
+	/* attached planes bitmask:
+	 * WARNING: transitional helpers do not maintain plane_mask so
+	 * drivers not converted over to atomic helpers should not rely
+	 * on plane_mask being accurate!
+	 */
+	u32 plane_mask;
+
 	/* last_vblank_count: for vblank waits before cleanup */
 	u32 last_vblank_count;
 
@@ -438,7 +446,7 @@ struct drm_crtc {
  * @state: backpointer to global drm_atomic_state
  */
 struct drm_connector_state {
-	struct drm_crtc *crtc;
+	struct drm_crtc *crtc;  /* do not write directly, use drm_atomic_set_crtc_for_connector() */
 
 	struct drm_encoder *best_encoder;
 
@@ -673,8 +681,8 @@ struct drm_connector {
  * @state: backpointer to global drm_atomic_state
  */
 struct drm_plane_state {
-	struct drm_crtc *crtc;
-	struct drm_framebuffer *fb;
+	struct drm_crtc *crtc;   /* do not write directly, use drm_atomic_set_crtc_for_plane() */
+	struct drm_framebuffer *fb;  /* do not write directly, use drm_atomic_set_fb_for_plane() */
 	struct fence *fence;
 
 	/* Signed dest location allows it to be partially off screen */

commit 3758b34193638f664177565f1692faa1bec7d9ed
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Nov 19 18:38:10 2014 +0100

    drm: s/enum_blob_list/enum_list/ in drm_property
    
    I guess for hysterical raisins this was meant to be the way to read
    blob properties. But that's done with the two-stage approach which
    uses separate blob kms object and the special-purpose get_blob ioctl.
    
    Shipping userspace seems to have never relied on this, and the kernel
    also never put any blob thing onto that property. And nowadays it
    would blow up, e.g. in drm_property_destroy. Also it makes no sense to
    return values in an ioctl that only returns metadata about everything.
    
    So let's ditch all the internal code for the blob list, rename the
    list to be unambiguous and sprinkle comments all over the place to
    explain this peculiar piece of api.
    
    v2: Squash in fixup from Rob to remove now unused variables.
    
    Cc: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f3142c64e3d5..b459e8fbbc25 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -216,7 +216,7 @@ struct drm_property {
 	uint64_t *values;
 	struct drm_device *dev;
 
-	struct list_head enum_blob_list;
+	struct list_head enum_list;
 };
 
 struct drm_crtc;

commit f52b69f1ecfdd7ef6867a257620258c09e569552
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Nov 19 18:38:08 2014 +0100

    drm/atomic: Don't overrun the connector array when hotplugging
    
    Yet another fallout from not considering DP MST hotplug. With the
    previous patches we have stable indices, but it might still happen
    that a connector gets added between when we allocate the array and
    when we actually add a connector. Especially when we back off due to
    ww mutex contention or similar issues.
    
    So store the sizes of the arrays in struct drm_atomic_state and double
    check them. We don't really care about races except that we want to
    use a consistent value, so ACCESS_ONCE is all we need. And if we
    indeed notice that we'd overrun the array then just give up and
    restart the entire ioctl.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 7b28ab032a88..f3142c64e3d5 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -825,6 +825,7 @@ struct drm_bridge {
  * @plane_states: pointer to array of plane states pointers
  * @crtcs: pointer to array of CRTC pointers
  * @crtc_states: pointer to array of CRTC states pointers
+ * @num_connector: size of the @connectors and @connector_states arrays
  * @connectors: pointer to array of connector pointers
  * @connector_states: pointer to array of connector states pointers
  * @acquire_ctx: acquire context for this atomic modeset state update
@@ -836,6 +837,7 @@ struct drm_atomic_state {
 	struct drm_plane_state **plane_states;
 	struct drm_crtc **crtcs;
 	struct drm_crtc_state **crtc_states;
+	int num_connector;
 	struct drm_connector **connectors;
 	struct drm_connector_state **connector_states;
 

commit 5bb2bbf596a0ca35b8ba2b0d5b734a1f270040ff
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Nov 10 10:18:15 2014 +1000

    drm: add properties for suggested x/y offset for connectors. (v2)
    
    Virtual GPUs would like to give the guest some indication where on the screen
    the outputs are layed out. So far we only provide modes, these
    properties could be exposed to userspace so the desktop environment
    could use them as hints to set the correct offsets.
    
    v2: rename properties to be more consistent.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c95941076aaf..7b28ab032a88 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1038,6 +1038,10 @@ struct drm_mode_config {
 	struct drm_property *aspect_ratio_property;
 	struct drm_property *dirty_info_property;
 
+	/* properties for virtual machine layout */
+	struct drm_property *suggested_x_property;
+	struct drm_property *suggested_y_property;
+
 	/* dumb ioctl parameters */
 	uint32_t preferred_depth, prefer_shadow;
 
@@ -1231,6 +1235,7 @@ extern int drm_mode_create_tv_properties(struct drm_device *dev,
 extern int drm_mode_create_scaling_mode_property(struct drm_device *dev);
 extern int drm_mode_create_aspect_ratio_property(struct drm_device *dev);
 extern int drm_mode_create_dirty_info_property(struct drm_device *dev);
+extern int drm_mode_create_suggested_offset_properties(struct drm_device *dev);
 
 extern int drm_mode_connector_attach_encoder(struct drm_connector *connector,
 					     struct drm_encoder *encoder);

commit 4fb2ac6ebe3ece9cafb2bb6d4a2e8e4edb124637
Merge: 8aa3dc3c17f8 37d74578d819
Author: Dave Airlie <airlied@redhat.com>
Date:   Sat Nov 15 09:37:20 2014 +1000

    Merge tag 'drm/fixes/for-3.19-rc1' of git://people.freedesktop.org/~tagr/linux into drm-next
    
    drm: Miscellaneous fixes for v3.19-rc1
    
    This is a small collection of fixes that I've been carrying around for a
    while now. Many of these have been posted and reviewed or acked. The few
    that haven't I deemed too trivial to bother.
    
    * tag 'drm/fixes/for-3.19-rc1' of git://people.freedesktop.org/~tagr/linux:
      video/hdmi: Relicense header under MIT license
      drm/gma500: mdfld: Reuse video/mipi_display.h
      drm: Make drm_mode_create_tv_properties() signature consistent
      drm: Implement drm_get_pci_dev() dummy for !PCI
      drm/prime: Use unsigned type for number of pages
      drm/gem: Fix typo in kerneldoc
      drm: Use const data when creating blob properties
      drm: Use size_t for blob property sizes

commit 2f7633125a1ca8a03b63bf91b5eca60551141ddb
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Oct 13 12:45:57 2014 +0200

    drm: Make drm_mode_create_tv_properties() signature consistent
    
    The prototype and the function implementation differ in their signature.
    Make them consistent and use an unsigned integer for the number of modes
    while at it.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index ce0dd6c2d73d..48255076d1bd 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1041,8 +1041,9 @@ extern void drm_property_destroy(struct drm_device *dev, struct drm_property *pr
 extern int drm_property_add_enum(struct drm_property *property, int index,
 				 uint64_t value, const char *name);
 extern int drm_mode_create_dvi_i_properties(struct drm_device *dev);
-extern int drm_mode_create_tv_properties(struct drm_device *dev, int num_formats,
-				     char *formats[]);
+extern int drm_mode_create_tv_properties(struct drm_device *dev,
+					 unsigned int num_modes,
+					 char *modes[]);
 extern int drm_mode_create_scaling_mode_property(struct drm_device *dev);
 extern int drm_mode_create_aspect_ratio_property(struct drm_device *dev);
 extern int drm_mode_create_dirty_info_property(struct drm_device *dev);

commit 12e6cecd55e541d3e8110f7dfbb6a601e81733ff
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue May 13 11:38:36 2014 +0200

    drm: Use const data when creating blob properties
    
    Creating a blob property will always copy the input data so the data
    that is passed in can be const.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 628369c08503..ce0dd6c2d73d 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -978,9 +978,9 @@ extern void drm_mode_config_reset(struct drm_device *dev);
 extern void drm_mode_config_cleanup(struct drm_device *dev);
 
 extern int drm_mode_connector_set_path_property(struct drm_connector *connector,
-						char *path);
+						const char *path);
 extern int drm_mode_connector_update_edid_property(struct drm_connector *connector,
-						struct edid *edid);
+						   const struct edid *edid);
 
 static inline bool drm_property_type_is(struct drm_property *property,
 		uint32_t type)

commit ecbbe59bbb1cd2973e031c5b6ba28653d66a17de
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue May 13 11:36:13 2014 +0200

    drm: Use size_t for blob property sizes
    
    size_t is the standard type when dealing with sizes of all kinds. Use it
    consistently when instantiating DRM blob properties.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c40070a92d6b..628369c08503 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -196,7 +196,7 @@ struct drm_framebuffer {
 struct drm_property_blob {
 	struct drm_mode_object base;
 	struct list_head head;
-	unsigned int length;
+	size_t length;
 	unsigned char data[];
 };
 

commit 4d02e2de0e80a786452e70d7f3a20a50641e6620
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Nov 11 10:12:00 2014 +0100

    drm: Per-plane locking
    
    Turned out to be much simpler on top of my latest atomic stuff than
    what I've feared. Some details:
    
    - Drop the modeset_lock_all snakeoil in drm_plane_init. Same
      justification as for the equivalent change in drm_crtc_init done in
    
            commit d0fa1af40e784aaf7ebb7ba8a17b229bb3fa4c21
            Author: Daniel Vetter <daniel.vetter@ffwll.ch>
            Date:   Mon Sep 8 09:02:49 2014 +0200
    
                drm: Drop modeset locking from crtc init function
    
      Without these the drm_modeset_lock_init would fall over the exact
      same way.
    
    - Since the atomic core code wraps the locking switching it to
      per-plane locks was a one-line change.
    
    - For the legacy ioctls add a plane argument to the locking helper so
      that we can grab the right plane lock (cursor or primary). Since the
      universal cursor plane might not be there, or someone really crazy
      might forgoe the primary plane even accept NULL.
    
    - Add some locking WARN_ON to the atomic helpers for good paranoid
      measure and to check that it all works out.
    
    Tested on my exynos atomic hackfest with full lockdep checks and ww
    backoff injection.
    
    v2: I've forgotten about the load-detect code in i915.
    
    v3: Thierry reported that in latest 3.18-rc vmwgfx doesn't compile any
    more due to
    
    commit 21e88620aa21b48d4f62d29275e3e2944a5ea2b5
    Author: Rob Clark <robdclark@gmail.com>
    Date:   Thu Oct 30 13:39:04 2014 -0400
    
        drm/vmwgfx: fix lock breakage
    
    Rebased and fix this up.
    
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index bc1cc3ce05c4..cbb475654b1c 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -751,6 +751,8 @@ struct drm_plane {
 	struct drm_device *dev;
 	struct list_head head;
 
+	struct drm_modeset_lock mutex;
+
 	struct drm_mode_object base;
 
 	uint32_t possible_crtcs;

commit e2330f0719515e41090a4d9685b931888b7c01d6
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Oct 29 11:34:56 2014 +0100

    drm/atomic: Integrate fence support
    
    This patch is for enabling async commits. It replaces an earlier
    approach which added an async boolean paramter to the ->prepare_fb
    callbacks. The idea is that prepare_fb picks up the right fence to
    synchronize against, which is then used by the synchronous commit
    helper. For async commits drivers can either register a callback to
    the fence or simply do the synchronous wait in their async work queue.
    
    v2: Remove unused variable.
    
    v3: Only wait for fences after the point of no return in the part
    of the commit function which can be run asynchronously. This is after
    the atomic state has been swapped in, hence now check
    plane->state->fence.
    
    Also add a WARN_ON to make sure we don't try to wait on a fence when
    there's no fb, just as a sanity check.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index bc47d11cb126..bc1cc3ce05c4 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -42,6 +42,7 @@ struct drm_object_properties;
 struct drm_file;
 struct drm_clip_rect;
 struct device_node;
+struct fence;
 
 #define DRM_MODE_OBJECT_CRTC 0xcccccccc
 #define DRM_MODE_OBJECT_CONNECTOR 0xc0c0c0c0
@@ -658,6 +659,7 @@ struct drm_connector {
  * struct drm_plane_state - mutable plane state
  * @crtc: currently bound CRTC, NULL if disabled
  * @fb: currently bound framebuffer
+ * @fence: optional fence to wait for before scanning out @fb
  * @crtc_x: left position of visible portion of plane on crtc
  * @crtc_y: upper position of visible portion of plane on crtc
  * @crtc_w: width of visible portion of plane on crtc
@@ -673,6 +675,7 @@ struct drm_connector {
 struct drm_plane_state {
 	struct drm_crtc *crtc;
 	struct drm_framebuffer *fb;
+	struct fence *fence;
 
 	/* Signed dest location allows it to be partially off screen */
 	int32_t crtc_x, crtc_y;

commit 623369e533e8a5f85999d605723efa4523554bae
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Sep 16 17:50:47 2014 +0200

    drm: Atomic crtc/connector updates using crtc/plane helper interfaces
    
    So this is finally the integration of the crtc and plane helper
    interfaces into the atomic helper functions.
    
    In the check function we now have a few steps:
    
    - First we update the output routing and figure out which crtcs need a
      full mode set. Suitable encoders are selected using ->best_encoder,
      with the same semantics as the crtc helpers of implicitly disabling
      all connectors currently using the encoder.
    
    - Then we pull all other connectors into the state update which feed
      from a crtc which changes. This must be done do catch mode changes
      and similar updates - atomic updates are differences on top of the
      current state.
    
    - Then we call all the various ->mode_fixup to compute the adjusted
      mode. Note that here we have a slight semantic difference compared
      to the crtc helpers: We have not yet updated the encoder->crtc link
      when calling the encoder's ->mode_fixup function. But that's a
      requirement when converting to atomic since we want to prepare the
      entire state completely contained with the over drm_atomic_state
      structure. So this must be carefully checked when converting drivers
      over to atomic helpers.
    
    - Finally we do call the atomic_check functions on planes and crtcs.
    
    The commit function is also quite a beast:
    
    - The only step that can fail is done first, namely pinning the
      framebuffers. After that we cross the point of no return, an async
      commit would push all that into the worker thread.
    
    - The disabling of encoders and connectors is a bit tricky, since
      depending upon the final state we need to select different crtc
      helper functions.
    
    - Software tracking is a bit clarified compared to the crtc helpers:
      We commit the software state before starting to touch the hardware,
      like crtc helpers. But since we just swap them we still have the old
      state (i.e. the current hw state) around, which is really handy to
      write simple disable functions. So no more
      drm_crtc_helper_disable_all_unused_functions kind of fun because
      we're leaving unused crtcs/encoders behind. Everything gets shut
      down in-order now, which is one of the key differences of the i915
      helpers compared to crtc helpers and a really nice additional
      guarantee.
    
    - Like with the plane helpers the atomic commit function waits for one
      vblank to pass before calling the framebuffer cleanup function.
    
    Compared to Rob's helper approach there's a bunch of upsides:
    
    - All the interfaces which can fail are called in the ->check hook
      (i.e. ->best_match and the various ->mode_fixup hooks). This means
      that drivers can just reuse those functions and don't need to move
      everything into ->atomic_check callbacks. If drivers have no need
      for additional constraint checking beyong their existing crtc
      helper callbacks they don't need to do anything.
    
    - The actual commit operation is properly stage: First we prepare
      framebuffers, which can potentially still fail (due to memory
      exhausting). This is important for the async case, where this must
      be done synchronously to correctly return errors.
    
    - The output configuration changes (done with crtc helper functions)
      and the plane update (using atomic plane helpers) are correctly
      interleaved: First we shut down any crtcs that need changing, then
      we update planes and finally we enable everything again. Hardware
      without GO bits must be more careful with ordering, which this
      sequence enables.
    
    - Also for hardware with shared output resources (like display PLLs)
      we first must shut down the old configuration before we can enable
      the new one. Otherwise we can hit an impossible intermediate state
      where there's not enough PLLs (which is the point behind atomic
      updates).
    
    v2:
    - Ensure that users of ->check update crtc_state->enable correctly.
    - Update the legacy state in crtc/plane structures. Eventually we want
      to remove that, but for now the drm core still expects this (especially
      the plane->fb pointer).
    
    v3: A few changes for better async handling:
    
    - Reorder the software side state commit so that it happens all before
      we touch the hardware. This way async support becomes very easy
      since we can punt all the actual hw touching to a worker thread. And
      as long as we synchronize with that thread (flushing or cancelling,
      depending upon what the driver can handle) before we commit the next
      software state there's no need for any locking in the worker thread
      at all. Which greatly simplifies things.
    
      And as long as we synchronize with all relevant threads we can have
      a lot of them (e.g. per-crtc for per-crtc updates) running in
      parallel.
    
    - Expose pre/post plane commit steps separately. We need to expose the
      actual hw commit step anyway for drivers to be able to implement
      asynchronous commit workers. But if we expose pre/post and plane
      commit steps individually we allow drivers to selectively use atomic
      helpers.
    
    - I've forgotten to call encoder/bridge ->mode_set functions, fix
      this.
    
    v4: Add debug output and fix a mixup between current and new state
    that resulted in crtcs not getting updated correctly. And in an
    Oops ...
    
    v5:
    - Be kind to driver writers in the vblank wait functions.. if thing
      aren't working yet, and vblank irq will never come, then let's not
      block forever.. especially under console-lock.
    - Correctly clear connector_state->best_encoder when disabling.
      Spotted while trying to understand a report from Rob Clark.
    - Only steal encoder if it actually changed, otherwise hilarity ensues
      if we steal from the current connector and so set the ->crtc pointer
      unexpectedly to NULL. Reported by Rob Clark.
    - Bail out in disable_outputs if an output currently doesn't have a
      best_encoder - this means it's already disabled.
    
    v6: Fixupe kerneldoc as reported by Paulo. And also fix up kerneldoc
    in drm_crtc.h.
    
    v7: Take ownership of the atomic state and clean it up with
    drm_atomic_state_free().
    
    v8 Various improvements all over:
    - Polish code comments and kerneldoc.
    - Improve debug output to make sure all failure cases are logged.
    - Treat enabled crtc with no connectors as invalid input from userspace.
    - Don't ignore the return value from mode_fixup().
    
    v9:
    - Improve debug output for crtc_state->mode_changed.
    
    v10:
    - Fixup the vblank waiting code to properly balance the vblank_get/put
      calls.
    - Better comments when checking/computing crtc->mode_changed
    
    v11: Fixup the encoder stealing logic: We can't look at encoder->crtc
    since that's not in the atomic state structures and might be updated
    asynchronously in and async commit. Instead we need to inspect all the
    connector states and check whether the encoder is currently in used
    and if so, on which crtc.
    
    v12: Review from Sean:
    - A few spelling fixes.
    - Flatten control flow indent by converting if blocks to early
      continue/return in 2 places.
    - Capture connectors_for_crtc return value in int num_connectors
      instead of bool has_connectors and do an explicit int->bool
      conversion with !!. I think the helper is more useful for drivers if
      it returns the number of connectors (e.g. to detect cloning
      configurations), so decided to keep that return value.
    
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: Paulo Zanoni <przanoni@gmail.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 53c8638592d4..bc47d11cb126 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -229,6 +229,9 @@ struct drm_atomic_state;
 /**
  * struct drm_crtc_state - mutable CRTC state
  * @enable: whether the CRTC should be enabled, gates all other state
+ * @mode_changed: for use by helpers and drivers when computing state updates
+ * @last_vblank_count: for helpers and drivers to capture the vblank of the
+ * 	update to ensure framebuffer cleanup isn't done too early
  * @planes_changed: for use by helpers and drivers when computing state updates
  * @adjusted_mode: for use by helpers and drivers to compute adjusted mode timings
  * @mode: current mode timings
@@ -241,6 +244,10 @@ struct drm_crtc_state {
 
 	/* computed state bits used by helpers and drivers */
 	bool planes_changed : 1;
+	bool mode_changed : 1;
+
+	/* last_vblank_count: for vblank waits before cleanup */
+	u32 last_vblank_count;
 
 	/* adjusted_mode: for use by helpers and drivers */
 	struct drm_display_mode adjusted_mode;
@@ -426,11 +433,14 @@ struct drm_crtc {
 /**
  * struct drm_connector_state - mutable connector state
  * @crtc: CRTC to connect connector to, NULL if disabled
+ * @best_encoder: can be used by helpers and drivers to select the encoder
  * @state: backpointer to global drm_atomic_state
  */
 struct drm_connector_state {
 	struct drm_crtc *crtc;
 
+	struct drm_encoder *best_encoder;
+
 	struct drm_atomic_state *state;
 };
 

commit 2f324b42b7b24a48fe3f8a7af60ec3c9024255fa
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Oct 29 11:13:47 2014 +0100

    drm/crtc-helper: Transitional functions using atomic plane helpers
    
    These two functions allow drivers to reuse their atomic plane helpers
    functions for the primary plane to implement the interfaces required
    by the crtc helpers for the legacy ->set_config callback.
    
    This is purely transitional and won't be used once the driver is fully
    converted. But it allows partial conversions to the atomic plane
    helpers which are functional.
    
    v2:
    - Use ->atomic_duplicate_state if available.
    - Don't forget to run crtc_funcs->atomic_check.
    
    v3: Shift source coordinates correctly for 16.16 fixed point.
    
    v4: Don't forget to call ->atomic_destroy_state if available.
    
    v5: Fixup kerneldoc.
    
    v6: Reuse the plane_commit function from the transitional plane
    helpers to avoid too much duplication.
    
    v7:
    - Remove some stale comment.
    - Correctly handle the lack of plane->state object, necessary for
      transitional use.
    
    v8: Fixup an embarrassing h/vdisplay mixup.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 56147409408d..53c8638592d4 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -230,6 +230,7 @@ struct drm_atomic_state;
  * struct drm_crtc_state - mutable CRTC state
  * @enable: whether the CRTC should be enabled, gates all other state
  * @planes_changed: for use by helpers and drivers when computing state updates
+ * @adjusted_mode: for use by helpers and drivers to compute adjusted mode timings
  * @mode: current mode timings
  * @event: optional pointer to a DRM event to signal upon completion of the
  * 	state update
@@ -241,6 +242,9 @@ struct drm_crtc_state {
 	/* computed state bits used by helpers and drivers */
 	bool planes_changed : 1;
 
+	/* adjusted_mode: for use by helpers and drivers */
+	struct drm_display_mode adjusted_mode;
+
 	struct drm_display_mode mode;
 
 	struct drm_pending_vblank_event *event;

commit c2fcd274bce521cd824d96d7f26dfa57ea06478c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Nov 5 00:14:14 2014 +0100

    drm: Add atomic/plane helpers
    
    This is the first cut of atomic helper code. As-is it's only useful to
    implement a pure atomic interface for plane updates.
    
    Later patches will integrate this with the crtc helpers so that full
    atomic updates are possible. We also need a pile of helpers to aid
    drivers in transitioning from the legacy world to the shiny new atomic
    age. Finally we need helpers to implement legacy ioctls on top of the
    atomic interface.
    
    The design of the overall helpers<->driver interaction is fairly
    simple, but has an unfortunate large interface:
    
    - We have ->atomic_check callbacks for crtcs and planes. The idea is
      that connectors don't need any checking, and if they do they can
      adjust the relevant crtc driver-private state. So no connector hooks
      should be needed. Also the crtc helpers integration will do the
      ->best_encoder checks, so no need for that.
    
    - Framebuffer pinning needs to be done before we can commit to the hw
      state. This is especially important for async updates where we must
      pin all buffers before returning to userspace, so that really only
      hw failures can happen in the asynchronous worker.
    
      Hence we add ->prepare_fb and ->cleanup_fb hooks for this resources
      management.
    
    - The actual atomic plane commit can't fail (except hw woes), so has
      void return type. It has three stages:
      1. Prepare all affected crtcs with crtc->atomic_begin. Drivers can
         use this to unset the GO bit or similar latches to prevent plane
         updates.
      2. Update plane state by looping over all changed planes and calling
         plane->atomic_update. Presuming the hardware is sane and has GO
         bits drivers can simply bash the state into the hardware in this
         function. Other drivers might use this to precompute hw state for
         the final step.
      3. Finally latch the update for the next vblank with
         crtc->atomic_flush. Note that this function doesn't need to wait
         for the vblank to happen even for the synchronous case.
    
    v2: Clear drm_<obj>_state->state to NULL when swapping in state.
    
    v3: Add TODO that we don't short-circuit plane updates for now. Likely
    no one will care.
    
    v4: Squash in a bit of polish that somehow landed in the wrong (later)
    patche.
    
    v5: Integrate atomic functions into the drm docbook and fixup the
    kerneldoc.
    
    v6: Fixup fixup patch squashing fumble.
    
    v7: Don't touch the legacy plane state plane->fb and plane->crtc. This
    is only used by the legacy ioctl code in the drm core, and that code
    already takes care of updating the pointers in all relevant cases.
    This is in stark contrast to connector->encoder->crtc links on the
    modeset side, which we still need to set since the core doesn't touch
    them.
    
    Also some more kerneldoc polish.
    
    v8: Drop outdated comment.
    
    v9: Handle the state->state pointer correctly: Only clearing the
    ->state pointer when assigning the state to the kms object isn't good
    enough. We also need to re-link the swapped out state into the
    drm_atomic_state structure.
    
    v10: Shuffle the misplaced docbook template hunk around that Sean spotted.
    
    Cc: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c7a3400173a8..56147409408d 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -229,6 +229,7 @@ struct drm_atomic_state;
 /**
  * struct drm_crtc_state - mutable CRTC state
  * @enable: whether the CRTC should be enabled, gates all other state
+ * @planes_changed: for use by helpers and drivers when computing state updates
  * @mode: current mode timings
  * @event: optional pointer to a DRM event to signal upon completion of the
  * 	state update
@@ -237,6 +238,9 @@ struct drm_atomic_state;
 struct drm_crtc_state {
 	bool enable;
 
+	/* computed state bits used by helpers and drivers */
+	bool planes_changed : 1;
+
 	struct drm_display_mode mode;
 
 	struct drm_pending_vblank_event *event;
@@ -747,6 +751,8 @@ struct drm_plane {
 
 	enum drm_plane_type type;
 
+	void *helper_private;
+
 	struct drm_plane_state *state;
 };
 

commit cc4ceb484b37b9369e0d4e8682b7ae1849ae4579
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jul 25 21:30:38 2014 +0200

    drm: Global atomic state handling
    
    Some differences compared to Rob's patches again:
    - Dropped the committed and checked booleans. Checking will be
      internally enforced by always calling ->atomic_check before
      ->atomic_commit. And async handling needs to be solved differently
      because the current scheme completely side-steps ww mutex deadlock
      avoidance (and so either reinvents a new deadlock avoidance wheel or
      like the current code just deadlocks).
    
    - State for connectors needed to be added, since now they have a
      full-blown drm_connector_state (so that drivers have something to
      attach their own stuff to).
    
    - Refcounting is gone. I plane to solve async updates differently,
      since the lock-passing scheme doesn't cut it (since it abuses ww
      mutexes). Essentially what we need for async is a simple ownership
      transfer from the caller to the driver. That doesn't need full-blown
      refcounting.
    
    - The acquire ctx is a pointer. Real atomic callers should have that
      on their stack, legacy entry points need to put the right one
      (obtained by drm_modeset_legacy_acuire_ctx) in there.
    
    - I've dropped all hooks except check/commit. All the begin/end
      handling is done by core functions and is the same.
    
    - commit/check are just thin wrappers that ensure that ->check is
      always called.
    
    - To help out with locking in the legacy implementations I've added a
      helper to just grab all locks in the backoff case.
    
    v2: Add notices that check/commit can fail with EDEADLK.
    
    v3:
    - More consistent naming for state_alloc.
    - Add state_clear which is needed for backoff and retry.
    
    v4: Planes/connectors can switch between crtcs, and we need to be
    careful that we grab the state (and locks) for both the old and new
    crtc. Improve the interface functions to ensure this.
    
    v5: Add functions to grab affected connectors for a crtc and to recompute
    the crtc->enable state. This is useful for both helper and atomic ioctl
    code when e.g. removing a connector.
    
    v6: Squash in fixup from Fengguang to use ERR_CAST.
    
    v7: Add debug output.
    
    v8: Make checkpatch happy about kcalloc argument ordering.
    
    v9: Improve kerneldoc in drm_crtc.h
    
    v10:
    - Fix another kcalloc argument misorder I've missed.
    - More polish for kerneldoc.
    
    v11: Clarify the ownership rules for the state object. The new rule is
    that a successful drm_atomic_commit (whether synchronous or asnyc)
    always inherits the state and is responsible for the clean-up. That
    way async and sync ->commit functions are more similar.
    
    v12: A few bugfixes:
    - Assign state->state pointers correctly when grabbing state objects -
      we need to link them up with the global state.
    - Handle a NULL crtc in set_crtc_for_plane to simplify code flow a bit
      for the callers of this function.
    
    v13: Review from Sean:
    - kerneldoc spelling fixes
    - Don't overallocate states->planes.
    - Handle NULL crtc in set_crtc_for_connector.
    
    v14: Sprinkle __must_check over all functions which do wait/wound
    locking to make sure callers don't forget this. Since I have ;-)
    
    v15: Be more explicit in the kerneldoc when functions can return
    -EDEADLK what to do. And that every other -errno is fatal.
    
    v16: Indent with tabs instead of space, spotted by Ander.
    
    v17: Review from Thierry, small kerneldoc and other naming polish.
    
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Ander Conselvan de Oliveira <conselvan2@gmail.com>
    Cc: Daniel Thompson <daniel.thompson@linaro.org>
    Cc: Fengguang Wu <fengguang.wu@intel.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: Matt Roper <matthew.d.roper@intel.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 3554868dbf09..c7a3400173a8 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -227,7 +227,7 @@ struct drm_bridge;
 struct drm_atomic_state;
 
 /**
- * struct drm_crtc_state - mutable crtc state
+ * struct drm_crtc_state - mutable CRTC state
  * @enable: whether the CRTC should be enabled, gates all other state
  * @mode: current mode timings
  * @event: optional pointer to a DRM event to signal upon completion of the
@@ -235,7 +235,7 @@ struct drm_atomic_state;
  * @state: backpointer to global drm_atomic_state
  */
 struct drm_crtc_state {
-	bool enable        : 1;
+	bool enable;
 
 	struct drm_display_mode mode;
 
@@ -314,7 +314,7 @@ struct drm_crtc_funcs {
 	/* atomic update handling */
 	struct drm_crtc_state *(*atomic_duplicate_state)(struct drm_crtc *crtc);
 	void (*atomic_destroy_state)(struct drm_crtc *crtc,
-				     struct drm_crtc_state *cstate);
+				     struct drm_crtc_state *state);
 	int (*atomic_set_property)(struct drm_crtc *crtc,
 				   struct drm_crtc_state *state,
 				   struct drm_property *property,
@@ -417,7 +417,7 @@ struct drm_crtc {
 
 /**
  * struct drm_connector_state - mutable connector state
- * @crtc: crtc to connect connector to, NULL if disabled
+ * @crtc: CRTC to connect connector to, NULL if disabled
  * @state: backpointer to global drm_atomic_state
  */
 struct drm_connector_state {
@@ -441,7 +441,6 @@ struct drm_connector_state {
  * @atomic_destroy_state: destroy an atomic state for this connector
  * @atomic_set_property: set a property on an atomic state for this connector
  *
- *
  * Each CRTC may have one or more connectors attached to it.  The functions
  * below allow the core DRM code to control connectors, enumerate available modes,
  * etc.
@@ -469,7 +468,7 @@ struct drm_connector_funcs {
 	/* atomic update handling */
 	struct drm_connector_state *(*atomic_duplicate_state)(struct drm_connector *connector);
 	void (*atomic_destroy_state)(struct drm_connector *connector,
-				     struct drm_connector_state *cstate);
+				     struct drm_connector_state *state);
 	int (*atomic_set_property)(struct drm_connector *connector,
 				   struct drm_connector_state *state,
 				   struct drm_property *property,
@@ -640,7 +639,7 @@ struct drm_connector {
 /**
  * struct drm_plane_state - mutable plane state
  * @crtc: currently bound CRTC, NULL if disabled
- * @fb: currently bound fb
+ * @fb: currently bound framebuffer
  * @crtc_x: left position of visible portion of plane on crtc
  * @crtc_y: upper position of visible portion of plane on crtc
  * @crtc_w: width of visible portion of plane on crtc
@@ -697,7 +696,7 @@ struct drm_plane_funcs {
 	/* atomic update handling */
 	struct drm_plane_state *(*atomic_duplicate_state)(struct drm_plane *plane);
 	void (*atomic_destroy_state)(struct drm_plane *plane,
-				     struct drm_plane_state *cstate);
+				     struct drm_plane_state *state);
 	int (*atomic_set_property)(struct drm_plane *plane,
 				   struct drm_plane_state *state,
 				   struct drm_property *property,
@@ -793,6 +792,32 @@ struct drm_bridge {
 	void *driver_private;
 };
 
+/**
+ * struct struct drm_atomic_state - the global state object for atomic updates
+ * @dev: parent DRM device
+ * @flags: state flags like async update
+ * @planes: pointer to array of plane pointers
+ * @plane_states: pointer to array of plane states pointers
+ * @crtcs: pointer to array of CRTC pointers
+ * @crtc_states: pointer to array of CRTC states pointers
+ * @connectors: pointer to array of connector pointers
+ * @connector_states: pointer to array of connector states pointers
+ * @acquire_ctx: acquire context for this atomic modeset state update
+ */
+struct drm_atomic_state {
+	struct drm_device *dev;
+	uint32_t flags;
+	struct drm_plane **planes;
+	struct drm_plane_state **plane_states;
+	struct drm_crtc **crtcs;
+	struct drm_crtc_state **crtc_states;
+	struct drm_connector **connectors;
+	struct drm_connector_state **connector_states;
+
+	struct drm_modeset_acquire_ctx *acquire_ctx;
+};
+
+
 /**
  * struct drm_mode_set - new values for a CRTC config change
  * @fb: framebuffer to use for new config
@@ -824,6 +849,9 @@ struct drm_mode_set {
  * struct drm_mode_config_funcs - basic driver provided mode setting functions
  * @fb_create: create a new framebuffer object
  * @output_poll_changed: function to handle output configuration changes
+ * @atomic_check: check whether a give atomic state update is possible
+ * @atomic_commit: commit an atomic state update previously verified with
+ * 	atomic_check()
  *
  * Some global (i.e. not per-CRTC, connector, etc) mode setting functions that
  * involve drivers.
@@ -833,6 +861,12 @@ struct drm_mode_config_funcs {
 					     struct drm_file *file_priv,
 					     struct drm_mode_fb_cmd2 *mode_cmd);
 	void (*output_poll_changed)(struct drm_device *dev);
+
+	int (*atomic_check)(struct drm_device *dev,
+			    struct drm_atomic_state *a);
+	int (*atomic_commit)(struct drm_device *dev,
+			     struct drm_atomic_state *a,
+			     bool async);
 };
 
 /**

commit 144ecb97cd57d2a61cc455730a3337e413499cae
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Oct 27 20:28:44 2014 +0100

    drm: Add atomic driver interface definitions for objects
    
    Heavily based upon Rob Clark's atomic series.
    - Dropped the connector state from the crtc state, instead opting for a
      full-blown connector state. The only thing it has is the desired
      crtc, but drivers which have connector properties have now a
      data-structure to subclass.
    
    - Rename create_state to duplicate_state. Especially for legacy ioctls
      we want updates on top of existing state, so we need a way to get at
      the current state. We need to be careful to clear the backpointers
      to the global state correctly though.
    
    - Drop property values. Drivers with properties simply need to
      subclass the datastructures and track the decoded values in there. I
      also think that common properties (like rotation) should be decoded
      and stored in the core structures.
    
    - Create a new set of ->atomic_set_prop functions, for smoother
      transitions from legacy to atomic operations.
    
    - Pass the ->atomic_set_prop ioctl the right structure to avoid
      chasing pointers in drivers.
    
    - Drop temporary boolean state for now until we resurrect them with
      the helper functions.
    
    - Drop invert_dimensions. For now we don't need any checking since
      that's done by the higher-level legacy ioctls. But even then we
      should also add rotation/flip tracking to the core drm_crtc_state,
      not just whether the dimensions are inverted.
    
    - Track crtc state with an enable/disable. That's equivalent to
      mode_valid, but a bit clearer that it means the entire crtc.
    
    The global interface will follow in subsequent patches.
    
    v2: We need to allow drivers to somehow set up the initial state and
    clear it on resume. So add a plane->reset callback for that. Helpers
    will be provided with default behaviour for all these.
    
    v3: Split out the plane->reset into a separate patch.
    
    v4: Improve kerneldoc in drm_crtc.h
    
    v5: Remove unused inline functions for handling state objects, those
    callbacks are now mandatory for full atomic support.
    
    v6: Fix commit message nit Sean noticed.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 125bb7f290a1..3554868dbf09 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -224,6 +224,25 @@ struct drm_encoder;
 struct drm_pending_vblank_event;
 struct drm_plane;
 struct drm_bridge;
+struct drm_atomic_state;
+
+/**
+ * struct drm_crtc_state - mutable crtc state
+ * @enable: whether the CRTC should be enabled, gates all other state
+ * @mode: current mode timings
+ * @event: optional pointer to a DRM event to signal upon completion of the
+ * 	state update
+ * @state: backpointer to global drm_atomic_state
+ */
+struct drm_crtc_state {
+	bool enable        : 1;
+
+	struct drm_display_mode mode;
+
+	struct drm_pending_vblank_event *event;
+
+	struct drm_atomic_state *state;
+};
 
 /**
  * struct drm_crtc_funcs - control CRTCs for a given device
@@ -238,6 +257,9 @@ struct drm_bridge;
  * @set_property: called when a property is changed
  * @set_config: apply a new CRTC configuration
  * @page_flip: initiate a page flip
+ * @atomic_duplicate_state: duplicate the atomic state for this CRTC
+ * @atomic_destroy_state: destroy an atomic state for this CRTC
+ * @atomic_set_property: set a property on an atomic state for this CRTC
  *
  * The drm_crtc_funcs structure is the central CRTC management structure
  * in the DRM.  Each CRTC controls one or more connectors (note that the name
@@ -288,6 +310,15 @@ struct drm_crtc_funcs {
 
 	int (*set_property)(struct drm_crtc *crtc,
 			    struct drm_property *property, uint64_t val);
+
+	/* atomic update handling */
+	struct drm_crtc_state *(*atomic_duplicate_state)(struct drm_crtc *crtc);
+	void (*atomic_destroy_state)(struct drm_crtc *crtc,
+				     struct drm_crtc_state *cstate);
+	int (*atomic_set_property)(struct drm_crtc *crtc,
+				   struct drm_crtc_state *state,
+				   struct drm_property *property,
+				   uint64_t val);
 };
 
 /**
@@ -317,6 +348,7 @@ struct drm_crtc_funcs {
  * @pixeldur_ns: precise pixel timing
  * @helper_private: mid-layer private data
  * @properties: property tracking for this CRTC
+ * @state: current atomic state for this CRTC
  * @acquire_ctx: per-CRTC implicit acquire context used by atomic drivers for
  * 	legacy ioctls
  *
@@ -374,6 +406,8 @@ struct drm_crtc {
 
 	struct drm_object_properties properties;
 
+	struct drm_crtc_state *state;
+
 	/*
 	 * For legacy crtc ioctls so that atomic drivers can get at the locking
 	 * acquire context.
@@ -381,6 +415,16 @@ struct drm_crtc {
 	struct drm_modeset_acquire_ctx *acquire_ctx;
 };
 
+/**
+ * struct drm_connector_state - mutable connector state
+ * @crtc: crtc to connect connector to, NULL if disabled
+ * @state: backpointer to global drm_atomic_state
+ */
+struct drm_connector_state {
+	struct drm_crtc *crtc;
+
+	struct drm_atomic_state *state;
+};
 
 /**
  * struct drm_connector_funcs - control connectors on a given device
@@ -393,6 +437,10 @@ struct drm_crtc {
  * @set_property: property for this connector may need an update
  * @destroy: make object go away
  * @force: notify the driver that the connector is forced on
+ * @atomic_duplicate_state: duplicate the atomic state for this connector
+ * @atomic_destroy_state: destroy an atomic state for this connector
+ * @atomic_set_property: set a property on an atomic state for this connector
+ *
  *
  * Each CRTC may have one or more connectors attached to it.  The functions
  * below allow the core DRM code to control connectors, enumerate available modes,
@@ -417,6 +465,15 @@ struct drm_connector_funcs {
 			     uint64_t val);
 	void (*destroy)(struct drm_connector *connector);
 	void (*force)(struct drm_connector *connector);
+
+	/* atomic update handling */
+	struct drm_connector_state *(*atomic_duplicate_state)(struct drm_connector *connector);
+	void (*atomic_destroy_state)(struct drm_connector *connector,
+				     struct drm_connector_state *cstate);
+	int (*atomic_set_property)(struct drm_connector *connector,
+				   struct drm_connector_state *state,
+				   struct drm_property *property,
+				   uint64_t val);
 };
 
 /**
@@ -515,6 +572,7 @@ struct drm_encoder {
  * @null_edid_counter: track sinks that give us all zeros for the EDID
  * @bad_edid_counter: track sinks that give us an EDID with invalid checksum
  * @debugfs_entry: debugfs directory for this connector
+ * @state: current atomic state for this connector
  *
  * Each connector may be connected to one or more CRTCs, or may be clonable by
  * another connector if they can share a CRTC.  Each connector also has a specific
@@ -575,8 +633,42 @@ struct drm_connector {
 	unsigned bad_edid_counter;
 
 	struct dentry *debugfs_entry;
+
+	struct drm_connector_state *state;
+};
+
+/**
+ * struct drm_plane_state - mutable plane state
+ * @crtc: currently bound CRTC, NULL if disabled
+ * @fb: currently bound fb
+ * @crtc_x: left position of visible portion of plane on crtc
+ * @crtc_y: upper position of visible portion of plane on crtc
+ * @crtc_w: width of visible portion of plane on crtc
+ * @crtc_h: height of visible portion of plane on crtc
+ * @src_x: left position of visible portion of plane within
+ *	plane (in 16.16)
+ * @src_y: upper position of visible portion of plane within
+ *	plane (in 16.16)
+ * @src_w: width of visible portion of plane (in 16.16)
+ * @src_h: height of visible portion of plane (in 16.16)
+ * @state: backpointer to global drm_atomic_state
+ */
+struct drm_plane_state {
+	struct drm_crtc *crtc;
+	struct drm_framebuffer *fb;
+
+	/* Signed dest location allows it to be partially off screen */
+	int32_t crtc_x, crtc_y;
+	uint32_t crtc_w, crtc_h;
+
+	/* Source values are 16.16 fixed point */
+	uint32_t src_x, src_y;
+	uint32_t src_h, src_w;
+
+	struct drm_atomic_state *state;
 };
 
+
 /**
  * struct drm_plane_funcs - driver plane control functions
  * @update_plane: update the plane configuration
@@ -584,6 +676,9 @@ struct drm_connector {
  * @destroy: clean up plane resources
  * @reset: reset plane after state has been invalidated (e.g. resume)
  * @set_property: called when a property is changed
+ * @atomic_duplicate_state: duplicate the atomic state for this plane
+ * @atomic_destroy_state: destroy an atomic state for this plane
+ * @atomic_set_property: set a property on an atomic state for this plane
  */
 struct drm_plane_funcs {
 	int (*update_plane)(struct drm_plane *plane,
@@ -598,6 +693,15 @@ struct drm_plane_funcs {
 
 	int (*set_property)(struct drm_plane *plane,
 			    struct drm_property *property, uint64_t val);
+
+	/* atomic update handling */
+	struct drm_plane_state *(*atomic_duplicate_state)(struct drm_plane *plane);
+	void (*atomic_destroy_state)(struct drm_plane *plane,
+				     struct drm_plane_state *cstate);
+	int (*atomic_set_property)(struct drm_plane *plane,
+				   struct drm_plane_state *state,
+				   struct drm_property *property,
+				   uint64_t val);
 };
 
 enum drm_plane_type {
@@ -621,6 +725,7 @@ enum drm_plane_type {
  * @funcs: helper functions
  * @properties: property tracking for this plane
  * @type: type of plane (overlay, primary, cursor)
+ * @state: current atomic state for this plane
  */
 struct drm_plane {
 	struct drm_device *dev;
@@ -642,6 +747,8 @@ struct drm_plane {
 	struct drm_object_properties properties;
 
 	enum drm_plane_type type;
+
+	struct drm_plane_state *state;
 };
 
 /**

commit 2c0c33d41e0ecb46c37583a6179eeb1f16767296
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Oct 27 20:19:38 2014 +0100

    drm: fixup kerneldoc in drm_crtc.h
    
    I've tried to cc all the people who have recently added new stuff
    but forgotten to update documentation.
    
    I've also decided not to bother documenting the massive property list
    in struct drm_mode_config. If that beast keeps on growing we might want
    to extract it into a separate structure which we won't document.
    
    Cc: Thomas Wood <thomas.wood@intel.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 3a8060575628..125bb7f290a1 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -231,6 +231,7 @@ struct drm_bridge;
  * @restore: restore CRTC state
  * @reset: reset CRTC after state has been invalidated (e.g. resume)
  * @cursor_set: setup the cursor
+ * @cursor_set2: setup the cursor with hotspot, superseeds @cursor_set if set
  * @cursor_move: move the cursor
  * @gamma_set: specify color ramp for CRTC
  * @destroy: deinit and free object
@@ -292,11 +293,14 @@ struct drm_crtc_funcs {
 /**
  * struct drm_crtc - central CRTC control structure
  * @dev: parent DRM device
+ * @port: OF node used by drm_of_find_possible_crtcs()
  * @head: list management
  * @mutex: per-CRTC locking
  * @base: base KMS object for ID tracking etc.
  * @primary: primary plane for this CRTC
  * @cursor: cursor plane for this CRTC
+ * @cursor_x: current x position of the cursor, used for universal cursor planes
+ * @cursor_y: current y position of the cursor, used for universal cursor planes
  * @enabled: is this CRTC enabled?
  * @mode: current mode timings
  * @hwmode: mode timings as programmed to hw regs
@@ -309,10 +313,12 @@ struct drm_crtc_funcs {
  * @gamma_size: size of gamma ramp
  * @gamma_store: gamma ramp values
  * @framedur_ns: precise frame timing
- * @framedur_ns: precise line timing
+ * @linedur_ns: precise line timing
  * @pixeldur_ns: precise pixel timing
  * @helper_private: mid-layer private data
  * @properties: property tracking for this CRTC
+ * @acquire_ctx: per-CRTC implicit acquire context used by atomic drivers for
+ * 	legacy ioctls
  *
  * Each CRTC may have one or more connectors associated with it.  This structure
  * allows the CRTC to be controlled.
@@ -483,6 +489,7 @@ struct drm_encoder {
  * @connector_type_id: index into connector type enum
  * @interlace_allowed: can this connector handle interlaced modes?
  * @doublescan_allowed: can this connector handle doublescan?
+ * @stereo_allowed: can this connector handle stereo modes?
  * @modes: modes available on this connector (from fill_modes() + user)
  * @status: one of the drm_connector_status enums (connected, not, or unknown)
  * @probed_modes: list of modes derived directly from the display
@@ -490,10 +497,13 @@ struct drm_encoder {
  * @funcs: connector control functions
  * @edid_blob_ptr: DRM property containing EDID if present
  * @properties: property tracking for this connector
+ * @path_blob_ptr: DRM blob property data for the DP MST path property
  * @polled: a %DRM_CONNECTOR_POLL_<foo> value for core driven polling
  * @dpms: current dpms state
  * @helper_private: mid-layer private data
+ * @cmdline_mode: mode line parsed from the kernel cmdline for this connector
  * @force: a %DRM_FORCE_<foo> state for forced mode sets
+ * @override_edid: has the EDID been overwritten through debugfs for testing?
  * @encoder_ids: valid encoders for this connector
  * @encoder: encoder driving this connector, if any
  * @eld: EDID-like data, if present
@@ -503,6 +513,8 @@ struct drm_encoder {
  * @video_latency: video latency info from ELD, if found
  * @audio_latency: audio latency info from ELD, if found
  * @null_edid_counter: track sinks that give us all zeros for the EDID
+ * @bad_edid_counter: track sinks that give us an EDID with invalid checksum
+ * @debugfs_entry: debugfs directory for this connector
  *
  * Each connector may be connected to one or more CRTCs, or may be clonable by
  * another connector if they can share a CRTC.  Each connector also has a specific
@@ -570,6 +582,7 @@ struct drm_connector {
  * @update_plane: update the plane configuration
  * @disable_plane: shut down the plane
  * @destroy: clean up plane resources
+ * @reset: reset plane after state has been invalidated (e.g. resume)
  * @set_property: called when a property is changed
  */
 struct drm_plane_funcs {
@@ -603,6 +616,8 @@ enum drm_plane_type {
  * @format_count: number of formats supported
  * @crtc: currently bound CRTC
  * @fb: currently bound fb
+ * @old_fb: Temporary tracking of the old fb while a modeset is ongoing. Used by
+ * 	drm_mode_set_config_internal() to implement correct refcounting.
  * @funcs: helper functions
  * @properties: property tracking for this plane
  * @type: type of plane (overlay, primary, cursor)
@@ -620,8 +635,6 @@ struct drm_plane {
 	struct drm_crtc *crtc;
 	struct drm_framebuffer *fb;
 
-	/* Temporary tracking of the old fb while a modeset is ongoing. Used
-	 * by drm_mode_set_config_internal to implement correct refcounting. */
 	struct drm_framebuffer *old_fb;
 
 	const struct drm_plane_funcs *funcs;
@@ -675,7 +688,6 @@ struct drm_bridge {
 
 /**
  * struct drm_mode_set - new values for a CRTC config change
- * @head: list management
  * @fb: framebuffer to use for new config
  * @crtc: CRTC whose configuration we're about to change
  * @mode: mode timings to use
@@ -717,10 +729,11 @@ struct drm_mode_config_funcs {
 };
 
 /**
- * drm_mode_group - group of mode setting resources for potential sub-grouping
+ * struct drm_mode_group - group of mode setting resources for potential sub-grouping
  * @num_crtcs: CRTC count
  * @num_encoders: encoder count
  * @num_connectors: connector count
+ * @num_bridges: bridge count
  * @id_list: list of KMS object IDs in this group
  *
  * Currently this simply tracks the global mode setting state.  But in the
@@ -740,10 +753,14 @@ struct drm_mode_group {
 };
 
 /**
- * drm_mode_config - Mode configuration control structure
+ * struct drm_mode_config - Mode configuration control structure
  * @mutex: mutex protecting KMS related lists and structures
+ * @connection_mutex: ww mutex protecting connector state and routing
+ * @acquire_ctx: global implicit acquire context used by atomic drivers for
+ * 	legacy ioctls
  * @idr_mutex: mutex for KMS ID allocation and management
  * @crtc_idr: main KMS ID tracking object
+ * @fb_lock: mutex to protect fb state and lists
  * @num_fb: number of fbs available
  * @fb_list: list of framebuffers available
  * @num_connector: number of connectors on this device
@@ -752,17 +769,28 @@ struct drm_mode_group {
  * @bridge_list: list of bridge objects
  * @num_encoder: number of encoders on this device
  * @encoder_list: list of encoder objects
+ * @num_overlay_plane: number of overlay planes on this device
+ * @num_total_plane: number of universal (i.e. with primary/curso) planes on this device
+ * @plane_list: list of plane objects
  * @num_crtc: number of CRTCs on this device
  * @crtc_list: list of CRTC objects
+ * @property_list: list of property objects
  * @min_width: minimum pixel width on this device
  * @min_height: minimum pixel height on this device
  * @max_width: maximum pixel width on this device
  * @max_height: maximum pixel height on this device
  * @funcs: core driver provided mode setting functions
  * @fb_base: base address of the framebuffer
- * @poll_enabled: track polling status for this device
+ * @poll_enabled: track polling support for this device
+ * @poll_running: track polling status for this device
  * @output_poll_work: delayed work for polling in process context
+ * @property_blob_list: list of all the blob property objects
  * @*_property: core property tracking
+ * @preferred_depth: preferred RBG pixel depth, used by fb helpers
+ * @prefer_shadow: hint to userspace to prefer shadow-fb rendering
+ * @async_page_flip: does this device support async flips on the primary plane?
+ * @cursor_width: hint to userspace for max cursor width
+ * @cursor_height: hint to userspace for max cursor height
  *
  * Core mode resource tracking structure.  All CRTC, encoders, and connectors
  * enumerated by the driver are added here, as are global properties.  Some
@@ -776,14 +804,7 @@ struct drm_mode_config {
 	struct idr crtc_idr; /* use this idr for all IDs, fb, crtc, connector, modes - just makes life easier */
 	/* this is limited to one for now */
 
-
-	/**
-	 * fb_lock - mutex to protect fb state
-	 *
-	 * Besides the global fb list his also protects the fbs list in the
-	 * file_priv
-	 */
-	struct mutex fb_lock;
+	struct mutex fb_lock; /* proctects global and per-file fb lists */
 	int num_fb;
 	struct list_head fb_list;
 

commit 3bf0401cddc00e90bd07f24cbf3fed88be24c399
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Oct 27 16:54:27 2014 +0100

    drm: Pull drm_crtc.h into the kerneldoc template
    
    While writing atomic docs I've noticed that I don't get any errors
    for my screw-ups in drm_crtc.h. Fix this immediately.
    
    This just does the bare minimum to get starts, lots of stuff isn't
    properly documented yet unfortunately.
    
    v2: Fix adjacent spelling error Sean noticed.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Cc: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c3baaee09498..3a8060575628 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -142,8 +142,8 @@ struct drm_framebuffer_funcs {
 	int (*create_handle)(struct drm_framebuffer *fb,
 			     struct drm_file *file_priv,
 			     unsigned int *handle);
-	/**
-	 * Optinal callback for the dirty fb ioctl.
+	/*
+	 * Optional callback for the dirty fb ioctl.
 	 *
 	 * Userspace can notify the driver via this callback
 	 * that a area of the framebuffer has changed and should
@@ -226,7 +226,7 @@ struct drm_plane;
 struct drm_bridge;
 
 /**
- * drm_crtc_funcs - control CRTCs for a given device
+ * struct drm_crtc_funcs - control CRTCs for a given device
  * @save: save CRTC state
  * @restore: restore CRTC state
  * @reset: reset CRTC after state has been invalidated (e.g. resume)
@@ -290,7 +290,7 @@ struct drm_crtc_funcs {
 };
 
 /**
- * drm_crtc - central CRTC control structure
+ * struct drm_crtc - central CRTC control structure
  * @dev: parent DRM device
  * @head: list management
  * @mutex: per-CRTC locking
@@ -322,7 +322,7 @@ struct drm_crtc {
 	struct device_node *port;
 	struct list_head head;
 
-	/**
+	/*
 	 * crtc mutex
 	 *
 	 * This provides a read lock for the overall crtc state (mode, dpms
@@ -377,7 +377,7 @@ struct drm_crtc {
 
 
 /**
- * drm_connector_funcs - control connectors on a given device
+ * struct drm_connector_funcs - control connectors on a given device
  * @dpms: set power state (see drm_crtc_funcs above)
  * @save: save connector state
  * @restore: restore connector state
@@ -414,7 +414,7 @@ struct drm_connector_funcs {
 };
 
 /**
- * drm_encoder_funcs - encoder controls
+ * struct drm_encoder_funcs - encoder controls
  * @reset: reset state (e.g. at init or resume time)
  * @destroy: cleanup and free associated data
  *
@@ -428,7 +428,7 @@ struct drm_encoder_funcs {
 #define DRM_CONNECTOR_MAX_ENCODER 3
 
 /**
- * drm_encoder - central DRM encoder structure
+ * struct drm_encoder - central DRM encoder structure
  * @dev: parent DRM device
  * @head: list management
  * @base: base KMS object
@@ -472,7 +472,7 @@ struct drm_encoder {
 #define MAX_ELD_BYTES	128
 
 /**
- * drm_connector - central DRM connector control structure
+ * struct drm_connector - central DRM connector control structure
  * @dev: parent DRM device
  * @kdev: kernel device for sysfs attributes
  * @attr: sysfs attributes
@@ -566,7 +566,7 @@ struct drm_connector {
 };
 
 /**
- * drm_plane_funcs - driver plane control functions
+ * struct drm_plane_funcs - driver plane control functions
  * @update_plane: update the plane configuration
  * @disable_plane: shut down the plane
  * @destroy: clean up plane resources
@@ -594,7 +594,7 @@ enum drm_plane_type {
 };
 
 /**
- * drm_plane - central DRM plane control structure
+ * struct drm_plane - central DRM plane control structure
  * @dev: DRM device this plane belongs to
  * @head: for list management
  * @base: base mode object
@@ -632,7 +632,7 @@ struct drm_plane {
 };
 
 /**
- * drm_bridge_funcs - drm_bridge control functions
+ * struct drm_bridge_funcs - drm_bridge control functions
  * @mode_fixup: Try to fixup (or reject entirely) proposed mode for this bridge
  * @disable: Called right before encoder prepare, disables the bridge
  * @post_disable: Called right after encoder prepare, for lockstepped disable
@@ -656,7 +656,7 @@ struct drm_bridge_funcs {
 };
 
 /**
- * drm_bridge - central DRM bridge control structure
+ * struct drm_bridge - central DRM bridge control structure
  * @dev: DRM device this bridge belongs to
  * @head: list management
  * @base: base mode object
@@ -674,7 +674,7 @@ struct drm_bridge {
 };
 
 /**
- * drm_mode_set - new values for a CRTC config change
+ * struct drm_mode_set - new values for a CRTC config change
  * @head: list management
  * @fb: framebuffer to use for new config
  * @crtc: CRTC whose configuration we're about to change

commit 3cb9ae4fd82ebc9759bc59998c88c385d35496fe
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Oct 29 10:03:57 2014 +0100

    drm: Move drm_crtc_init from drm_crtc.h to drm_plane_helper.h
    
    Just a bit of OCD cleanup on headers - this function isn't the core
    interface any more but just a helper for drivers who haven't yet
    transitioned to universal planes. Put the declaration at the right
    spot and sprinkle necessary #includes over all drivers.
    
    Maybe this helps to encourage driver maintainers to do the switch.
    
    v2: Fix #include ordering for tegra, reported by 0-day builder.
    
    v3: Include required headers, reported by Thierry.
    
    Cc: Matt Roper <matthew.d.roper@intel.com>
    Cc: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c40070a92d6b..c3baaee09498 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -880,9 +880,6 @@ extern int drm_crtc_init_with_planes(struct drm_device *dev,
 				     struct drm_plane *primary,
 				     struct drm_plane *cursor,
 				     const struct drm_crtc_funcs *funcs);
-extern int drm_crtc_init(struct drm_device *dev,
-			 struct drm_crtc *crtc,
-			 const struct drm_crtc_funcs *funcs);
 extern void drm_crtc_cleanup(struct drm_crtc *crtc);
 extern unsigned int drm_crtc_index(struct drm_crtc *crtc);
 

commit d7d2c48e5cfe27dc7378e48d4f22efcf417317d9
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Fri Aug 29 12:12:40 2014 +0200

    drm: move remaining includes in drmP.h to the top
    
    Including headers somewhere else but at the top is ugly, deprecated and
    was used in early days only to speed up compile-times. Those days are
    over. Make headers independent and then move the inclusions to the top.
    
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 31344bf7887e..c40070a92d6b 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -31,8 +31,8 @@
 #include <linux/idr.h>
 #include <linux/fb.h>
 #include <linux/hdmi.h>
-#include <drm/drm_mode.h>
-#include <drm/drm_fourcc.h>
+#include <uapi/drm/drm_mode.h>
+#include <uapi/drm/drm_fourcc.h>
 #include <drm/drm_modeset_lock.h>
 
 struct drm_device;

commit a18b29f0c6bd17703b5eb88c3b2184a26d173135
Merge: 04cd214516d8 604effb782a8
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Sep 3 08:30:48 2014 +1000

    Merge tag 'drm-intel-next-2014-09-01' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    drm-intel-next-2014-08-22:
    - basic code for execlist, which is the fancy new cmd submission on gen8. Still
      disabled by default (Ben, Oscar Mateo, Thomas Daniel et al)
    - remove the useless usage of console_lock for I915_FBDEV=n (Chris)
    - clean up relations between ctx and ppgtt
    - clean up ppgtt lifetime handling (Michel Thierry)
    - various cursor code improvements from Ville
    - execbuffer code cleanups and secure batch fixes (Chris)
    - prep work for dev -> dev_priv transition (Chris)
    - some of the prep patches for the seqno -> request object transition (Chris)
    - various small improvements all over
    
    * tag 'drm-intel-next-2014-09-01' of git://anongit.freedesktop.org/drm-intel: (86 commits)
      drm/i915: fix suspend/resume for GENs w/o runtime PM support
      drm/i915: Update DRIVER_DATE to 20140822
      drm: fix plane rotation when restoring fbdev configuration
      drm/i915/bdw: Disable execlists by default
      drm/i915/bdw: Enable Logical Ring Contexts (hence, Execlists)
      drm/i915/bdw: Document Logical Rings, LR contexts and Execlists
      drm/i915/bdw: Print context state in debugfs
      drm/i915/bdw: Display context backing obj & ringbuffer info in debugfs
      drm/i915/bdw: Display execlists info in debugfs
      drm/i915/bdw: Disable semaphores for Execlists
      drm/i915/bdw: Make sure gpu reset still works with Execlists
      drm/i915/bdw: Don't write PDP in the legacy way when using LRCs
      drm/i915: Track cursor changes as frontbuffer tracking flushes
      drm/i915/bdw: Help out the ctx switch interrupt handler
      drm/i915/bdw: Avoid non-lite-restore preemptions
      drm/i915/bdw: Handle context switch events
      drm/i915/bdw: Two-stage execlist submit process
      drm/i915/bdw: Write the tail pointer, LRC style
      drm/i915/bdw: Implement context switching (somewhat)
      drm/i915/bdw: Emission of requests with logical rings
      ...
    
    Conflicts:
            drivers/gpu/drm/i915/i915_drv.c

commit d5a0f2e7be20d29c5a23fdbc65c1f8307690413c
Merge: c0ee755fc573 2c0827cffca8
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Aug 26 09:04:32 2014 +1000

    Merge tag 'drm-intel-next-2014-08-08' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - Setting dp M2/N2 values plus state checker support (Vandana Kannan)
    - chv power well support (Ville)
    - DP training pattern 3 support for chv (Ville)
    - cleanup of the hsw/bdw ddi pll code, prep work for skl (Damien)
    - dsi video burst mode support (Shobhit)
    - piles of other chv fixes all over (Ville et. al.)
    - cleanup of the ddi translation tables setup code (Damien)
    - 180 deg rotation support (Ville & Sonika Jindal)
    
    * tag 'drm-intel-next-2014-08-08' of git://anongit.freedesktop.org/drm-intel: (59 commits)
      drm/i915: Update DRIVER_DATE to 20140808
      drm/i915: No busy-loop wait_for in the ring init code
      drm/i915: Add sprite watermark programming for VLV and CHV
      drm/i915: Round-up clock and limit drain latency
      drm/i915: Generalize drain latency computation
      drm/i915: Free pending page flip events at .preclose()
      drm/i915: clean up PPGTT checking logic
      drm/i915: Polish the chv cmnlane resrt macros
      drm/i915: Hack to tie both common lanes together on chv
      drm/i915: Add cherryview_update_wm()
      drm/i915: Update DDL only for current CRTC
      drm/i915: Parametrize VLV_DDL registers
      drm/i915: Fill out the FWx watermark register defines
      drm: Resetting rotation property
      drm/i915: Add rotation property for sprites
      drm: Add rotation_property to mode_config
      drm/i915: Make intel_plane_restore() return an error
      drm/i915: Add 180 degree sprite rotation support
      drm/i915: Introduce a for_each_intel_encoder() macro
      drm/i915: Demote the DRRS messages to debug messages
      ...

commit 3a5f87c286515c54ff5c52c3e64d0c522b7570c0
Author: Thomas Wood <thomas.wood@intel.com>
Date:   Wed Aug 20 14:45:00 2014 +0100

    drm: fix plane rotation when restoring fbdev configuration
    
    Make sure plane rotation is reset correctly when restoring the fbdev
    configuration by using drm_mode_plane_set_obj_prop which calls the
    driver's set_property callback.
    
    The rotation reset feature was introduced in commit 9783de2 (drm:
    Resetting rotation property) and the callback issue was originally
    addressed in a previous version of the patch, but the fix was not
    present in the final version.
    
    v2: Fix documentation warning
        Add some more details to the commit message (Daniel Vetter)
    
    Testcase: igt/kms_rotation_crc
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=82236
    Cc: Sonika Jindal <sonika.jindal@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Dave Airlie <airlied@gmail.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Thomas Wood <thomas.wood@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 62f73bdbcc47..38fae5d9ad73 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1121,6 +1121,9 @@ extern int drm_mode_obj_get_properties_ioctl(struct drm_device *dev, void *data,
 					     struct drm_file *file_priv);
 extern int drm_mode_obj_set_property_ioctl(struct drm_device *dev, void *data,
 					   struct drm_file *file_priv);
+extern int drm_mode_plane_set_obj_prop(struct drm_plane *plane,
+				       struct drm_property *property,
+				       uint64_t value);
 
 extern void drm_fb_get_bpp_depth(uint32_t format, unsigned int *depth,
 				 int *bpp);

commit 2a0d7cfd9482ca4c10a4d8794791760a6a7ce40c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jul 29 15:32:37 2014 +0200

    drm: Add a plane->reset hook
    
    In general having this can't hurt, and the atomic helpers will need
    it to be able to reset the state objects properly. The overall idea
    is to reset in the order pixels flow, so planes -> crtcs ->
    encoders -> connectors.
    
    v2: Squash in fixup from Ville to correctly deference struct drm_plane
    instead of drm_crtc when walking the plane list. Fixes an oops in
    driver init and resume.
    
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 279565aa0c33..2c1f58d6957a 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -581,6 +581,7 @@ struct drm_plane_funcs {
 			    uint32_t src_w, uint32_t src_h);
 	int (*disable_plane)(struct drm_plane *plane);
 	void (*destroy)(struct drm_plane *plane);
+	void (*reset)(struct drm_plane *plane);
 
 	int (*set_property)(struct drm_plane *plane,
 			    struct drm_property *property, uint64_t val);

commit 3d30a59bfcb7c96d4aacdb053c2ccc49394b2311
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sun Jul 27 13:42:42 2014 +0200

    drm: Move ->old_fb from crtc to plane
    
    Atomic implemenations for legacy ioctls must be able to drop locks.
    Which doesn't cause havoc since we only do that while constructing
    the new state, so no driver or hardware state change has happened.
    
    The only troubling bit is the fb refcounting the core does - if
    someone else has snuck in then it might potentially unref an
    outdated framebuffer. To fix that move the old_fb temporary storage
    into struct drm_plane for all ioctls, so that the atomic helpers can
    update it.
    
    v2: Fix up the error case handling as suggested by Matt Roper and just
    grab locks uncoditionally - there's no point in optimizing the locking
    for when userspace gets it wrong.
    
    Cc: Matt Roper <matthew.d.roper@intel.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 508817bae538..279565aa0c33 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -341,10 +341,6 @@ struct drm_crtc {
 	int cursor_x;
 	int cursor_y;
 
-	/* Temporary tracking of the old fb while a modeset is ongoing. Used
-	 * by drm_mode_set_config_internal to implement correct refcounting. */
-	struct drm_framebuffer *old_fb;
-
 	bool enabled;
 
 	/* Requested mode from modesetting. */
@@ -623,6 +619,10 @@ struct drm_plane {
 	struct drm_crtc *crtc;
 	struct drm_framebuffer *fb;
 
+	/* Temporary tracking of the old fb while a modeset is ongoing. Used
+	 * by drm_mode_set_config_internal to implement correct refcounting. */
+	struct drm_framebuffer *old_fb;
+
 	const struct drm_plane_funcs *funcs;
 
 	struct drm_object_properties properties;

commit d059f652e73c35678d28d4cd09ab2cec89696af9
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jul 25 18:07:40 2014 +0200

    drm: Handle legacy per-crtc locking with full acquire ctx
    
    So drivers using the atomic interfaces expect that they can acquire
    additional locks internal to the driver as-needed. Examples would be
    locks to protect shared state like shared display PLLs.
    
    Unfortunately the legacy ioctls assume that all locking is fully done
    by the drm core. Now for those paths which grab all locks we already
    have to keep around an acquire context in dev->mode_config. Helper
    functions that implement legacy interfaces in terms of atomic support
    can therefore grab this acquire contexts and reuse it.
    
    The only interfaces left are the cursor and pageflip ioctls. So add
    functions to grab the crtc lock these need using an acquire context
    and preserve it for atomic drivers to reuse.
    
    v2:
    - Fixup comments&kerneldoc.
    - Drop the WARNING from modeset_lock_all_crtcs since that can be used
      in legacy paths with crtc locking.
    
    v3: Fix a type on the kerneldoc Dave spotted.
    
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index a11d73422e7f..508817bae538 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -371,6 +371,12 @@ struct drm_crtc {
 	void *helper_private;
 
 	struct drm_object_properties properties;
+
+	/*
+	 * For legacy crtc ioctls so that atomic drivers can get at the locking
+	 * acquire context.
+	 */
+	struct drm_modeset_acquire_ctx *acquire_ctx;
 };
 
 

commit a6a8bb848d5ca40bc0eb708ddeb23df2b0eca1fb
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jul 25 17:47:18 2014 +0200

    drm: Move modeset_lock_all helpers to drm_modeset_lock.[hc]
    
    Somehow we've forgotten about this little bit of OCD.
    
    Reviewed-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 9f18e7022ab3..a11d73422e7f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -218,10 +218,6 @@ struct drm_property {
 	struct list_head enum_blob_list;
 };
 
-void drm_modeset_lock_all(struct drm_device *dev);
-void drm_modeset_unlock_all(struct drm_device *dev);
-void drm_warn_on_modeset_not_all_locked(struct drm_device *dev);
-
 struct drm_crtc;
 struct drm_connector;
 struct drm_encoder;

commit 10f637bf292ba501f9b9e9df6dfe21d8fa521fbd
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jul 29 13:47:11 2014 +0200

    drm: Add drm_plane/connector_index
    
    In the atomic state we'll have an array of states for crtcs, planes
    and connectors and need to be able to at them by their index. We
    already have a drm_crtc_index function so add the missing ones for
    planes and connectors.
    
    If it later on turns out that the list walking is too expensive we can
    add the index to the relevant modeset objects.
    
    Rob Clark doesn't like the loops too much, but we can always add an
    obj->idx parameter later on. And for now reiterating is actually safer
    since nowadays we have hotpluggable connectors (thanks to DP MST).
    
    v2: Fix embarrassing copypasta fail in kerneldoc and header
    declarations, spotted by Matt Roper.
    
    Cc: Matt Roper <matthew.d.roper@intel.com>
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c530b4920a09..9f18e7022ab3 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -904,6 +904,7 @@ int drm_connector_register(struct drm_connector *connector);
 void drm_connector_unregister(struct drm_connector *connector);
 
 extern void drm_connector_cleanup(struct drm_connector *connector);
+extern unsigned int drm_connector_index(struct drm_connector *connector);
 /* helper to unplug all connectors from sysfs for device */
 extern void drm_connector_unplug_all(struct drm_device *dev);
 
@@ -943,6 +944,7 @@ extern int drm_plane_init(struct drm_device *dev,
 			  const uint32_t *formats, uint32_t format_count,
 			  bool is_primary);
 extern void drm_plane_cleanup(struct drm_plane *plane);
+extern unsigned int drm_plane_index(struct drm_plane *plane);
 extern void drm_plane_force_disable(struct drm_plane *plane);
 extern int drm_crtc_check_viewport(const struct drm_crtc *crtc,
 				   int x, int y,

commit 2a297cce2e775812e9d6ca84c3ab92cee5c38e25
Author: Sonika Jindal <sonika.jindal@intel.com>
Date:   Tue Aug 5 11:26:54 2014 +0530

    drm: Add rotation_property to mode_config
    
    Signed-off-by: Sonika Jindal <sonika.jindal@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f1105d0da059..62f73bdbcc47 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -821,6 +821,7 @@ struct drm_mode_config {
 	struct drm_property *dpms_property;
 	struct drm_property *path_property;
 	struct drm_property *plane_type_property;
+	struct drm_property *rotation_property;
 
 	/* DVI-I properties */
 	struct drm_property *dvi_i_subconnector_property;

commit eaf99c749d43ae74ac7ffece5512f3c73f01dfd2
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Aug 6 10:08:32 2014 +0200

    drm: Perform cmdline mode parsing during connector initialisation
    
    i915.ko has a custom fbdev initialisation routine that aims to preserve
    the current mode set by the BIOS, unless overruled by the user. The
    user's wishes are determined by what, if any, mode is specified on the
    command line (via the video= parameter). However, that command line mode
    is first parsed by drm_fb_helper_initial_config() which is called after
    i915.ko's custom initial_config() as a fallback method. So in order for
    us to honour it, we need to move the cmdline parser earlier. If we
    perform the connector cmdline parsing as soon as we initialise the
    connector, that cmdline mode and forced status is then available even if
    the fbdev helper is not compiled in or never called.
    
    We also then expose the cmdline user mode in the connector mode lists.
    
    v2: Rebase after connector->name upheaval.
    
    v3: Adapt mga200 to look for the cmdline mode in the new place. Nicely
    simplifies things while at that.
    
    v4: Fix checkpatch.
    
    v5: Select FB_CMDLINE to adapt to the changed fbdev patch.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=73154
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk> (v2)
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org> (v2)
    Cc: dri-devel@lists.freedesktop.org
    Cc: Julia Lemire <jlemire@matrox.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f1105d0da059..c530b4920a09 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -548,6 +548,7 @@ struct drm_connector {
 	void *helper_private;
 
 	/* forced on connector */
+	struct drm_cmdline_mode cmdline_mode;
 	enum drm_connector_force force;
 	bool override_edid;
 	uint32_t encoder_ids[DRM_CONNECTOR_MAX_ENCODER];

commit 4dac3edfe68e5e1b3c2216b84ba160572420fa40
Merge: 487777673e35 e05444be705b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jul 29 20:49:36 2014 +0200

    Merge remote-tracking branch 'airlied/drm-next' into drm-intel-next
    
    Pull in drm-next with Dave's DP MST support so that I can merge some
    conflicting patches which also touch the driver load sequencing around
    interrupt handling.
    
    Conflicts:
            drivers/gpu/drm/i915/intel_display.c
            drivers/gpu/drm/i915/intel_dp.c
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit ff587e45a1a1690f5cd713a2782672c579460365
Author: Vandana Kannan <vandana.kannan@intel.com>
Date:   Wed Jun 11 10:46:48 2014 +0530

    drm/crtc: Add property for aspect ratio
    
    Added a property to enable user space to set aspect ratio.
    This patch contains declaration of the property and code to create the
    property.
    
    v2: Thierry's review comments.
            - Made aspect ratio enum generic instead of HDMI/CEA specfic
            - Removed usage of temporary aspect_ratio variable
    
    v3: Thierry's review comments.
            - Fixed indentation
    
    v4: Thierry's review comments.
            - Return ENOMEM when property creation fails
    
    Signed-off-by: Vandana Kannan <vandana.kannan@intel.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 08ed55e02762..be7114e76d1b 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -835,6 +835,7 @@ struct drm_mode_config {
 
 	/* Optional properties */
 	struct drm_property *scaling_mode_property;
+	struct drm_property *aspect_ratio_property;
 	struct drm_property *dirty_info_property;
 
 	/* dumb ioctl parameters */
@@ -1023,6 +1024,7 @@ extern int drm_mode_create_dvi_i_properties(struct drm_device *dev);
 extern int drm_mode_create_tv_properties(struct drm_device *dev, int num_formats,
 				     char *formats[]);
 extern int drm_mode_create_scaling_mode_property(struct drm_device *dev);
+extern int drm_mode_create_aspect_ratio_property(struct drm_device *dev);
 extern int drm_mode_create_dirty_info_property(struct drm_device *dev);
 
 extern int drm_mode_connector_attach_encoder(struct drm_connector *connector,

commit 8a105aaa25f4504d26ca828f12d709d2213a230e
Merge: 7296c849bf2e 9611cb93fa65
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Jul 23 13:01:56 2014 +1000

    Merge branch 'drm-armada-devel' of git://ftp.arm.linux.org.uk/~rmk/linux-arm into drm-next
    
    Merge armada changes, I've confirmed the componenet changes are same as in Greg's tree.
    * 'drm-armada-devel' of git://ftp.arm.linux.org.uk/~rmk/linux-arm:
      drm/armada: register crtc with port
      drm/armada: permit CRTCs to be registered as separate devices
      dt-bindings: add Marvell Dove LCD controller documentation
      drm/armada: update Armada 510 (Dove) to use "ext_ref_clk1" as the clock
      drm/armada: convert to componentized support
      drm: add of_graph endpoint helper to find possible CRTCs
      component: fix bug with legacy API
      drm/armada: make variant a CRTC thing
      drm/armada: move variant initialisation to CRTC init
      drm/armada: use number of CRTCs registered
      drm/armada: move IRQ handling into CRTC
      component: add support for component match array
      component: ignore multiple additions of the same component
      component: fix missed cleanup in case of devres failure

commit 3c9855f6dc1c68f7c4028f49bd8e3df7e4faae67
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Jul 8 10:31:56 2014 +0530

    drm: Add drm_rotation_simplify()
    
    drm_rotation_simplify() can be used to eliminate unsupported rotation
    flags. It will check if any unsupported flags are present, and if so
    it will modify the rotation to an alternate form by adding 180 degrees
    to rotation angle, and flipping the reflect x and y bits. The hope is
    that this identity transform will eliminate the unsupported flags.
    
    Of course that might not result in any more supported rotation, so
    the caller is still responsible for checking the result afterwards.
    
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Acked-by: Dave Airlie <airlied@linux.ie>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f7b383bcb6b6..08ed55e02762 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1115,6 +1115,8 @@ extern int drm_format_vert_chroma_subsampling(uint32_t format);
 extern const char *drm_get_format_name(uint32_t format);
 extern struct drm_property *drm_mode_create_rotation_property(struct drm_device *dev,
 							      unsigned int supported_rotations);
+extern unsigned int drm_rotation_simplify(unsigned int rotation,
+					  unsigned int supported_rotations);
 
 /* Helpers */
 

commit c1df5f3c2d665f1a5b365d1e352e99832f188fda
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Jul 8 10:31:53 2014 +0530

    drm: Add drm_mode_create_rotation_property()
    
    Add a function to create a standards compliant rotation property.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Acked-by: Dave Airlie <airlied@linux.ie>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index cb4850a2b0c1..f7b383bcb6b6 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1113,6 +1113,8 @@ extern int drm_format_plane_cpp(uint32_t format, int plane);
 extern int drm_format_horz_chroma_subsampling(uint32_t format);
 extern int drm_format_vert_chroma_subsampling(uint32_t format);
 extern const char *drm_get_format_name(uint32_t format);
+extern struct drm_property *drm_mode_create_rotation_property(struct drm_device *dev,
+							      unsigned int supported_rotations);
 
 /* Helpers */
 

commit 7689ffb32fa314cc6f128b433b5a285f2699cb70
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Jul 8 10:31:52 2014 +0530

    drm: Add support_bits parameter to drm_property_create_bitmask()
    
    Make drm_property_create_bitmask() a bit more generic by allowing the
    caller to specify which bits are in fact supported. This allows multiple
    callers to use the same enum list, but still create different versions
    of the same property with different list of supported bits.
    
    v2: Populate values[] array as non-sparse
        Make supported_bits 64bit
        Fix up omapdrm call site (Rob)
    
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Sagar Kamble <sagar.a.kamble@intel.com>
    Acked-by: Dave Airlie <airlied@linux.ie>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index bfc7235a9c0e..cb4850a2b0c1 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1006,7 +1006,8 @@ extern struct drm_property *drm_property_create_enum(struct drm_device *dev, int
 struct drm_property *drm_property_create_bitmask(struct drm_device *dev,
 					 int flags, const char *name,
 					 const struct drm_prop_enum_list *props,
-					 int num_values);
+					 int num_props,
+					 uint64_t supported_bits);
 struct drm_property *drm_property_create_range(struct drm_device *dev, int flags,
 					 const char *name,
 					 uint64_t min, uint64_t max);

commit 06596961966bfeb128bc07f250b68fb9c5f177ef
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Jul 8 10:31:51 2014 +0530

    drm: Move DRM_ROTATE bits out of omapdrm into drm_crtc.h
    
    The rotation property stuff should be standardized among all drivers.
    Move the bits to drm_crtc.h from omap_drv.h.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Acked-by: Dave Airlie <airlied@linux.ie>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 4ee7e26a012f..bfc7235a9c0e 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -75,6 +75,14 @@ static inline uint64_t I642U64(int64_t val)
 	return (uint64_t)*((uint64_t *)&val);
 }
 
+/* rotation property bits */
+#define DRM_ROTATE_0	0
+#define DRM_ROTATE_90	1
+#define DRM_ROTATE_180	2
+#define DRM_ROTATE_270	3
+#define DRM_REFLECT_X	4
+#define DRM_REFLECT_Y	5
+
 enum drm_connector_force {
 	DRM_FORCE_UNSPECIFIED,
 	DRM_FORCE_OFF,

commit 7e435aad38083f378ba7889d8b8fdcdbfe7088e7
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Jun 15 11:07:12 2014 +0100

    drm: add of_graph endpoint helper to find possible CRTCs
    
    Add a helper to allow encoders to find their possible CRTCs from the
    OF graph without having to re-implement this functionality.  We add a
    device_node to drm_crtc which corresponds with the port node in the
    DT description of the CRTC device.
    
    We can then scan the DRM device list for CRTCs to find their index,
    matching the appropriate CRTC using the port device_node, thus building
    up the possible CRTC mask.
    
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 251b75e6bf7a..6a94909f1ca9 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -41,6 +41,7 @@ struct drm_framebuffer;
 struct drm_object_properties;
 struct drm_file;
 struct drm_clip_rect;
+struct device_node;
 
 #define DRM_MODE_OBJECT_CRTC 0xcccccccc
 #define DRM_MODE_OBJECT_CONNECTOR 0xc0c0c0c0
@@ -314,6 +315,7 @@ struct drm_crtc_funcs {
  */
 struct drm_crtc {
 	struct drm_device *dev;
+	struct device_node *port;
 	struct list_head head;
 
 	/**

commit ca5a1b9ba0fb5291b555a23b76dbe5f6c30bfd7a
Merge: c7dbc6c9ae5c 34882298b93e
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Jul 9 10:38:42 2014 +1000

    Merge tag 'drm-intel-next-2014-06-20' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - Accurate frontbuffer tracking and frontbuffer rendering invalidate, flush and
      flip events. This is prep work for proper PSR support and should also be
      useful for DRRS&fbc.
    - Runtime suspend hardware on system suspend to support the new SOix sleep
      states, from Jesse.
    - PSR updates for broadwell (Rodrigo)
    - Universal plane support for cursors (Matt Roper), including core drm patches.
    - Prefault gtt mappings (Chris)
    - baytrail write-enable pte bit support (Akash Goel)
    - mmio based flips (Sourab Gupta) instead of blitter ring flips
    - interrupt handling race fixes (Oscar Mateo)
    
    And old, not yet merged features from the previous round:
    - rps/turbo support for chv (Deepak)
    - some other straggling chv patches (Ville)
    - proper universal plane conversion for the primary plane (Matt Roper)
    - ppgtt on vlv from Jesse
    - pile of cleanups, little fixes for insane corner cases and improved debug
      support all over
    
    * tag 'drm-intel-next-2014-06-20' of git://anongit.freedesktop.org/drm-intel: (99 commits)
      drm/i915: Update DRIVER_DATE to 20140620
      drivers/i915: Fix unnoticed failure of init_ring_common()
      drm/i915: Track frontbuffer invalidation/flushing
      drm/i915: Use new frontbuffer bits to increase pll clock
      drm/i915: don't take runtime PM reference around freeze/thaw
      drm/i915: use runtime irq suspend/resume in freeze/thaw
      drm/i915: Properly track domain of the fbcon fb
      drm/i915: Print obj->frontbuffer_bits in debugfs output
      drm/i915: Introduce accurate frontbuffer tracking
      drm/i915: Drop schedule_back from psr_exit
      drm/i915: Ditch intel_edp_psr_update
      drm/i915: Drop unecessary complexity from psr_inactivate
      drm/i915: Remove ctx->last_ring
      drm/i915/chv: Ack interrupts before handling them (CHV)
      drm/i915/bdw: Ack interrupts before handling them (GEN8)
      drm/i915/vlv: Ack interrupts before handling them (VLV)
      drm/i915: Ack interrupts before handling them (GEN5 - GEN7)
      drm/i915: Don't BUG_ON in i915_gem_obj_offset
      drm/i915: Grab dev->struct_mutex in i915_gem_pageflip_info
      drm/i915: Add some L3 registers to the parser whitelist
      ...
    
    Conflicts:
            drivers/gpu/drm/i915/i915_drv.c

commit 43aba7eb0dc052d84e88f3569ea3f030868d49b2
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jun 5 14:01:31 2014 +1000

    drm: add a path blob property
    
    This property will be used by the MST code to provide userspace
    with a path to parse so it can recognise connectors around hotplugs.
    
    Reviewed-by: Todd Previte <tprevite@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index eb0f6f36385e..4da62072701c 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -524,6 +524,8 @@ struct drm_connector {
 	struct drm_property_blob *edid_blob_ptr;
 	struct drm_object_properties properties;
 
+	struct drm_property_blob *path_blob_ptr;
+
 	uint8_t polled; /* DRM_CONNECTOR_POLL_* */
 
 	/* requested DPMS state */
@@ -803,6 +805,7 @@ struct drm_mode_config {
 	struct list_head property_blob_list;
 	struct drm_property *edid_property;
 	struct drm_property *dpms_property;
+	struct drm_property *path_property;
 	struct drm_property *plane_type_property;
 
 	/* DVI-I properties */
@@ -952,6 +955,8 @@ extern void drm_mode_config_init(struct drm_device *dev);
 extern void drm_mode_config_reset(struct drm_device *dev);
 extern void drm_mode_config_cleanup(struct drm_device *dev);
 
+extern int drm_mode_connector_set_path_property(struct drm_connector *connector,
+						char *path);
 extern int drm_mode_connector_update_edid_property(struct drm_connector *connector,
 						struct edid *edid);
 

commit 2390cd11bfbe8d2b1b28c4e0f01fe7e122f7196d
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jun 5 14:01:29 2014 +1000

    drm/crtc: add interface to reinitialise the legacy mode group
    
    This can be called to update things after dynamic connectors/encoders
    are created/deleted.
    
    Reviewed-by: Todd Previte <tprevite@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 857bbb1551f8..eb0f6f36385e 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -942,6 +942,7 @@ extern const char *drm_get_tv_select_name(int val);
 extern void drm_fb_release(struct drm_file *file_priv);
 extern int drm_mode_group_init_legacy_group(struct drm_device *dev, struct drm_mode_group *group);
 extern void drm_mode_group_destroy(struct drm_mode_group *group);
+extern void drm_reinit_primary_mode_group(struct drm_device *dev);
 extern bool drm_probe_ddc(struct i2c_adapter *adapter);
 extern struct edid *drm_get_edid(struct drm_connector *connector,
 				 struct i2c_adapter *adapter);

commit 4cf2b28146713d39f78bd62002a8ab00075c63b7
Author: Thomas Wood <thomas.wood@intel.com>
Date:   Wed Jun 18 17:52:33 2014 +0100

    drm/debugfs: add an "edid_override" file per connector
    
    Add a file to debugfs for each connector to allow the EDID to be
    overridden.
    
    v2: Copy ubuf before accessing it and reject invalid length data. (David
        Herrmann)
        Ensure override_edid is reset when a new EDID value is written.
        (David Herrmann)
        Fix the debugfs file permissions. (David Herrmann)
    
    Signed-off-by: Thomas Wood <thomas.wood@intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index d4b0a6a4ad9b..857bbb1551f8 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -533,6 +533,7 @@ struct drm_connector {
 
 	/* forced on connector */
 	enum drm_connector_force force;
+	bool override_edid;
 	uint32_t encoder_ids[DRM_CONNECTOR_MAX_ENCODER];
 	struct drm_encoder *encoder; /* currently active encoder */
 

commit 30f6570798f6c897df4f1f2c676d803728bfec27
Author: Thomas Wood <thomas.wood@intel.com>
Date:   Wed Jun 18 17:52:32 2014 +0100

    drm/debugfs: add a "force" file per connector
    
    Add a file to debugfs for each connector to enable modification of the
    "force" connector attribute. This allows connectors to be enabled or
    disabled for testing and debugging purposes.
    
    v2: Add stricter value checking and clean up debugfs_entry if file
        creation fails in drm_debugfs_connector_add. (David Herrmann)
    
    Signed-off-by: Thomas Wood <thomas.wood@intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 5512c9968d77..d4b0a6a4ad9b 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -545,6 +545,8 @@ struct drm_connector {
 	int audio_latency[2];
 	int null_edid_counter; /* needed to workaround some HW bugs where we get all 0s */
 	unsigned bad_edid_counter;
+
+	struct dentry *debugfs_entry;
 };
 
 /**

commit 34ea3d386347cd6de4c2fa2491dd85c9e753e7e4
Author: Thomas Wood <thomas.wood@intel.com>
Date:   Thu May 29 16:57:41 2014 +0100

    drm: add register and unregister functions for connectors
    
    Introduce generic functions to register and unregister connectors. This
    provides a common place to add and remove associated user space
    interfaces.
    
    Signed-off-by: Thomas Wood <thomas.wood@intel.com>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 251b75e6bf7a..5512c9968d77 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -878,6 +878,8 @@ extern int drm_connector_init(struct drm_device *dev,
 			      struct drm_connector *connector,
 			      const struct drm_connector_funcs *funcs,
 			      int connector_type);
+int drm_connector_register(struct drm_connector *connector);
+void drm_connector_unregister(struct drm_connector *connector);
 
 extern void drm_connector_cleanup(struct drm_connector *connector);
 /* helper to unplug all connectors from sysfs for device */

commit fc1d3e44ef7c1db93384150fdbf8948dcf949f15
Author: Matt Roper <matthew.d.roper@intel.com>
Date:   Tue Jun 10 08:28:11 2014 -0700

    drm: Allow drivers to register cursor planes with crtc
    
    Universal plane support had placeholders for cursor planes, but didn't
    actually do anything with them.  Save the cursor plane reference inside
    the crtc and update the cursor plane parameter from void* to drm_plane.
    
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Reviewed-by: Pallavi G<pallavi.g@intel.com>
    Acked-by: Dave Airlie <airlied@linux.ie>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b8c7a9a8cb6b..4ee7e26a012f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -856,7 +856,7 @@ struct drm_prop_enum_list {
 extern int drm_crtc_init_with_planes(struct drm_device *dev,
 				     struct drm_crtc *crtc,
 				     struct drm_plane *primary,
-				     void *cursor,
+				     struct drm_plane *cursor,
 				     const struct drm_crtc_funcs *funcs);
 extern int drm_crtc_init(struct drm_device *dev,
 			 struct drm_crtc *crtc,

commit 161d0dc1dccb17ff7a38f462c7c0d4ef8bcc5662
Author: Matt Roper <matthew.d.roper@intel.com>
Date:   Tue Jun 10 08:28:10 2014 -0700

    drm: Support legacy cursor ioctls via universal planes when possible (v4)
    
    If drivers support universal planes and have registered a cursor plane
    with the DRM core, we should use that universal plane support when
    handling legacy cursor ioctls.  Drivers that transition to universal
    planes won't have to maintain separate legacy ioctl handling; drivers
    that don't transition to universal planes will continue to operate
    without any change to behavior.
    
    Note that there's a bit of a mismatch between the legacy cursor ioctls
    and the universal plane API's --- legacy ioctl's use driver buffer
    handles directly whereas the universal plane API takes drm_framebuffers.
    Since there's no way to recover the driver handle from a
    drm_framebuffer, we can implement legacy ioctl's in terms of universal
    plane interfaces, but cannot implement universal plane interfaces in
    terms of legacy ioctls.  Specifically, there's no way to create a
    general cursor helper in the way we previously created a primary plane
    helper.
    
    It's important to land this patch before any patches that add universal
    cursor support to individual drivers so that drivers don't have to worry
    about juggling two different styles of reference counting for cursor
    buffers when userspace mixes and matches legacy and universal cursor
    calls.  With this patch, a driver that switches to universal cursor
    support may assume that all cursor buffers are wrapped in a
    drm_framebuffer and can rely on framebuffer reference counting for all
    cursor operations.
    
    v4:
     - Add comments pointing out setplane_internal's reference-eating
       semantics.
    v3:
     - Drop drm_mode_rmfb() call that is no longer needed now that we're
       using setplane_internal(), which takes care of deref'ing the
       appropriate framebuffer.
    v2:
     - Use new add_framebuffer_internal() function to create framebuffer
       rather than trying to call directly into the ioctl interface and
       look up the handle returned.
     - Use new setplane_internal() function to update the cursor plane
       rather than calling through the ioctl interface.  Note that since
       we're no longer looking up an fb_id, no extra reference will be
       taken here.
     - Grab extra reference to fb under lock in !BO case to avoid issues
       where racing userspace could cause the fb to be destroyed out from
       under us after we grab the fb pointer.
    
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Reviewed-by: Pallavi G<pallavi.g@intel.com>
    Acked-by: Dave Airlie <airlied@linux.ie>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 251b75e6bf7a..b8c7a9a8cb6b 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -331,6 +331,10 @@ struct drm_crtc {
 	struct drm_plane *primary;
 	struct drm_plane *cursor;
 
+	/* position of cursor plane on crtc */
+	int cursor_x;
+	int cursor_y;
+
 	/* Temporary tracking of the old fb while a modeset is ongoing. Used
 	 * by drm_mode_set_config_internal to implement correct refcounting. */
 	struct drm_framebuffer *old_fb;

commit 5d02626d3167cd4214bf611362e08dfd1e98c62e
Author: Mario Kleiner <mario.kleiner.de@gmail.com>
Date:   Thu Jun 5 09:52:10 2014 -0400

    drm/edid: Store all supported hdmi deep color modes in drm_display_info
    
    HDMI deep color setup must know which modes are supported if
    it needs to degrade gracefully, as only 12 bpc / dc_36 is
    guaranteed, but 10 bpc / dc_30 is optional. The maximum bpc
    is not sufficient for this.
    
    Signed-off-by: Mario Kleiner <mario.kleiner.de@gmail.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index a7fac5686915..251b75e6bf7a 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -121,6 +121,9 @@ struct drm_display_info {
 	enum subpixel_order subpixel_order;
 	u32 color_formats;
 
+	/* Mask of supported hdmi deep color modes */
+	u8 edid_hdmi_dc_modes;
+
 	u8 cea_rev;
 };
 

commit 51fd371bbaf94018a1223b4e2cf20b9880fd92d4
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Nov 19 12:10:12 2013 -0500

    drm: convert crtc and connection_mutex to ww_mutex (v5)
    
    For atomic, it will be quite necessary to not need to care so much
    about locking order.  And 'state' gives us a convenient place to stash a
    ww_ctx for any sort of update that needs to grab multiple crtc locks.
    
    Because we will want to eventually make locking even more fine grained
    (giving locks to planes, connectors, etc), split out drm_modeset_lock
    and drm_modeset_acquire_ctx to track acquired locks.
    
    Atomic will use this to keep track of which locks have been acquired
    in a transaction.
    
    v1: original
    v2: remove a few things not needed until atomic, for now
    v3: update for v3 of connection_mutex patch..
    v4: squash in docbook
    v5: doc tweaks/fixes
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 6c295df7b0df..a7fac5686915 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -33,6 +33,7 @@
 #include <linux/hdmi.h>
 #include <drm/drm_mode.h>
 #include <drm/drm_fourcc.h>
+#include <drm/drm_modeset_lock.h>
 
 struct drm_device;
 struct drm_mode_set;
@@ -205,6 +206,10 @@ struct drm_property {
 	struct list_head enum_blob_list;
 };
 
+void drm_modeset_lock_all(struct drm_device *dev);
+void drm_modeset_unlock_all(struct drm_device *dev);
+void drm_warn_on_modeset_not_all_locked(struct drm_device *dev);
+
 struct drm_crtc;
 struct drm_connector;
 struct drm_encoder;
@@ -280,6 +285,7 @@ struct drm_crtc_funcs {
  * drm_crtc - central CRTC control structure
  * @dev: parent DRM device
  * @head: list management
+ * @mutex: per-CRTC locking
  * @base: base KMS object for ID tracking etc.
  * @primary: primary plane for this CRTC
  * @cursor: cursor plane for this CRTC
@@ -314,7 +320,7 @@ struct drm_crtc {
 	 * state, ...) and a write lock for everything which can be update
 	 * without a full modeset (fb, cursor data, ...)
 	 */
-	struct mutex mutex;
+	struct drm_modeset_lock mutex;
 
 	struct drm_mode_object base;
 
@@ -738,7 +744,8 @@ struct drm_mode_group {
  */
 struct drm_mode_config {
 	struct mutex mutex; /* protects configuration (mode lists etc.) */
-	struct mutex connection_mutex; /* protects connector->encoder and encoder->crtc links */
+	struct drm_modeset_lock connection_mutex; /* protects connector->encoder and encoder->crtc links */
+	struct drm_modeset_acquire_ctx *acquire_ctx; /* for legacy _lock_all() / _unlock_all() */
 	struct mutex idr_mutex; /* for IDR management */
 	struct idr crtc_idr; /* use this idr for all IDs, fb, crtc, connector, modes - just makes life easier */
 	/* this is limited to one for now */
@@ -839,10 +846,6 @@ struct drm_prop_enum_list {
 	char *name;
 };
 
-extern void drm_modeset_lock_all(struct drm_device *dev);
-extern void drm_modeset_unlock_all(struct drm_device *dev);
-extern void drm_warn_on_modeset_not_all_locked(struct drm_device *dev);
-
 extern int drm_crtc_init_with_planes(struct drm_device *dev,
 				     struct drm_crtc *crtc,
 				     struct drm_plane *primary,

commit 6e9f798d91c526982cca0026cd451e8fdbf18aaf
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu May 29 23:54:47 2014 +0200

    drm: Split connection_mutex out of mode_config.mutex (v3)
    
    After the split-out of crtc locks from the big mode_config.mutex
    there's still two major areas it protects:
    - Various connector probe states, like connector->status, EDID
      properties, probed mode lists and similar information.
    - The links from connector->encoder and encoder->crtc and other
      modeset-relevant connector state (e.g. properties which control the
      panel fitter).
    
    The later is used by modeset operations. But they don't really care
    about the former since it's allowed to e.g. enable a disconnected VGA
    output or with a mode not in the probed list.
    
    Thus far this hasn't been a problem, but for the atomic modeset
    conversion Rob Clark needs to convert all modeset relevant locks into
    w/w locks. This is required because the order of acquisition is
    determined by how userspace supplies the atomic modeset data. This has
    run into troubles in the detect path since the i915 load detect code
    needs _both_ protections offered by the mode_config.mutex: It updates
    probe state and it needs to change the modeset configuration to enable
    the temporary load detect pipe.
    
    The big deal here is that for the probe/detect users of this lock a
    plain mutex fits best, but for atomic modesets we really want a w/w
    mutex. To fix this lets split out a new connection_mutex lock for the
    modeset relevant parts.
    
    For simplicity I've decided to only add one additional lock for all
    connector/encoder links and modeset configuration states. We have
    piles of different modeset objects in addition to those (like bridges
    or panels), so adding per-object locks would be much more effort.
    
    Also, we're guaranteed (at least for now) to do a full modeset if we
    need to acquire this lock. Which means that fine-grained locking is
    fairly irrelevant compared to the amount of time the full modeset will
    take.
    
    I've done a full audit, and there's just a few things that justify
    special focus:
    - Locking in drm_sysfs.c is almost completely absent. We should
      sprinkle mode_config.connection_mutex over this file a bit, but
      since it already lacks mode_config.mutex this patch wont make the
      situation any worse. This is material for a follow-up patch.
    
    - omap has a omap_framebuffer_flush function which walks the
      connector->encoder->crtc links and is called from many contexts.
      Some look like they don't acquire mode_config.mutex, so this is
      already racy. Again fixing this is material for a separate patch.
    
    - The radeon hot_plug function to retrain DP links looks at
      connector->dpms. Currently this happens without any locking, so is
      already racy. I think radeon_hotplug_work_func should gain
      mutex_lock/unlock calls for the mode_config.connection_mutex.
    
    - Same applies to i915's intel_dp_hot_plug. But again, this is already
      racy.
    
    - i915 load_detect code needs to acquire this lock. Which means the
      w/w dance due to Rob's work will be nicely contained to _just_ this
      function.
    
    I've added fixme comments everywhere where it looks suspicious but in
    the sysfs code. After a quick irc discussion with Dave Airlie it
    sounds like the lack of locking in there is due to sysfs cleanup fun
    at module unload.
    
    v1: original (only compile tested)
    
    v2: missing mutex_init(), etc (from Rob Clark)
    
    v3: i915 needs more care in the conversion:
    - Protect the edp pp logic with the connection_mutex.
    - Use connection_mutex in the backlight code due to
      get_pipe_from_connector.
    - Use drm_modeset_lock_all in suspend/resume paths.
    - Update lock checks in the overlay code.
    
    Cc: Alex Deucher <alexdeucher@gmail.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Rob Clark <robdclark@gmail.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 849cfdccff09..6c295df7b0df 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -738,6 +738,7 @@ struct drm_mode_group {
  */
 struct drm_mode_config {
 	struct mutex mutex; /* protects configuration (mode lists etc.) */
+	struct mutex connection_mutex; /* protects connector->encoder and encoder->crtc links */
 	struct mutex idr_mutex; /* for IDR management */
 	struct idr crtc_idr; /* use this idr for all IDs, fb, crtc, connector, modes - just makes life easier */
 	/* this is limited to one for now */

commit ebc44cf386734374983922c6fc1ae8ac47f88bef
Author: Rob Clark <robdclark@gmail.com>
Date:   Wed Sep 12 22:22:31 2012 -0500

    drm: add signed-range property type
    
    Like range, but values are signed.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index cb2e599f769f..849cfdccff09 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -65,6 +65,15 @@ struct drm_object_properties {
 	uint64_t values[DRM_OBJECT_MAX_PROPERTY];
 };
 
+static inline int64_t U642I64(uint64_t val)
+{
+	return (int64_t)*((int64_t *)&val);
+}
+static inline uint64_t I642U64(int64_t val)
+{
+	return (uint64_t)*((uint64_t *)&val);
+}
+
 enum drm_connector_force {
 	DRM_FORCE_UNSPECIFIED,
 	DRM_FORCE_OFF,
@@ -982,6 +991,9 @@ struct drm_property *drm_property_create_bitmask(struct drm_device *dev,
 struct drm_property *drm_property_create_range(struct drm_device *dev, int flags,
 					 const char *name,
 					 uint64_t min, uint64_t max);
+struct drm_property *drm_property_create_signed_range(struct drm_device *dev,
+					 int flags, const char *name,
+					 int64_t min, int64_t max);
 struct drm_property *drm_property_create_object(struct drm_device *dev,
 					 int flags, const char *name, uint32_t type);
 extern void drm_property_destroy(struct drm_device *dev, struct drm_property *property);

commit 98f75de40e9d83c3a90d294b8fd25fa2874212a9
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri May 30 11:37:03 2014 -0400

    drm: add object property type
    
    An object property is an id (idr) for a drm mode object.  This
    will allow a property to be used set/get a framebuffer, CRTC, etc.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 92f6ec2de86a..cb2e599f769f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -50,6 +50,7 @@ struct drm_clip_rect;
 #define DRM_MODE_OBJECT_BLOB 0xbbbbbbbb
 #define DRM_MODE_OBJECT_PLANE 0xeeeeeeee
 #define DRM_MODE_OBJECT_BRIDGE 0xbdbdbdbd
+#define DRM_MODE_OBJECT_ANY 0
 
 struct drm_mode_object {
 	uint32_t id;
@@ -190,6 +191,7 @@ struct drm_property {
 	char name[DRM_PROP_NAME_LEN];
 	uint32_t num_values;
 	uint64_t *values;
+	struct drm_device *dev;
 
 	struct list_head enum_blob_list;
 };
@@ -980,6 +982,8 @@ struct drm_property *drm_property_create_bitmask(struct drm_device *dev,
 struct drm_property *drm_property_create_range(struct drm_device *dev, int flags,
 					 const char *name,
 					 uint64_t min, uint64_t max);
+struct drm_property *drm_property_create_object(struct drm_device *dev,
+					 int flags, const char *name, uint32_t type);
 extern void drm_property_destroy(struct drm_device *dev, struct drm_property *property);
 extern int drm_property_add_enum(struct drm_property *property, int index,
 				 uint64_t value, const char *name);
@@ -995,6 +999,7 @@ extern int drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,
 					 int gamma_size);
 extern struct drm_mode_object *drm_mode_object_find(struct drm_device *dev,
 		uint32_t id, uint32_t type);
+
 /* IOCTLs */
 extern int drm_mode_getresources(struct drm_device *dev,
 				 void *data, struct drm_file *file_priv);

commit 5ea22f24d77b511d68c4ecaf4e6fd5d6ab462b8f
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri May 30 11:34:01 2014 -0400

    drm: add extended property types
    
    If we continue to use bitmask for type, we will quickly run out of room
    to add new types.  Split this up so existing part of bitmask range
    continues to function as before, but reserve a chunk of the remaining
    space for an integer type-id.  Wrap this all up in some type-check
    helpers to keep the backwards-compat uglyness contained.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 90bd1a25e2c6..92f6ec2de86a 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -930,6 +930,23 @@ extern void drm_mode_config_cleanup(struct drm_device *dev);
 
 extern int drm_mode_connector_update_edid_property(struct drm_connector *connector,
 						struct edid *edid);
+
+static inline bool drm_property_type_is(struct drm_property *property,
+		uint32_t type)
+{
+	/* instanceof for props.. handles extended type vs original types: */
+	if (property->flags & DRM_MODE_PROP_EXTENDED_TYPE)
+		return (property->flags & DRM_MODE_PROP_EXTENDED_TYPE) == type;
+	return property->flags & type;
+}
+
+static inline bool drm_property_type_valid(struct drm_property *property)
+{
+	if (property->flags & DRM_MODE_PROP_EXTENDED_TYPE)
+		return !(property->flags & DRM_MODE_PROP_LEGACY_TYPE);
+	return !!(property->flags & DRM_MODE_PROP_LEGACY_TYPE);
+}
+
 extern int drm_object_property_set_value(struct drm_mode_object *obj,
 					 struct drm_property *property,
 					 uint64_t val);

commit a2b34e226ac9fbd20179091fad0ee1a24ad48669
Author: Rob Clark <robdclark@gmail.com>
Date:   Sat Oct 5 16:36:52 2013 -0400

    drm: helpers to find mode objects
    
    Add a few more useful helpers to find mode objects.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index e8fe9d8e135c..90bd1a25e2c6 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1061,6 +1061,15 @@ extern int drm_format_vert_chroma_subsampling(uint32_t format);
 extern const char *drm_get_format_name(uint32_t format);
 
 /* Helpers */
+
+static inline struct drm_plane *drm_plane_find(struct drm_device *dev,
+		uint32_t id)
+{
+	struct drm_mode_object *mo;
+	mo = drm_mode_object_find(dev, id, DRM_MODE_OBJECT_PLANE);
+	return mo ? obj_to_plane(mo) : NULL;
+}
+
 static inline struct drm_crtc *drm_crtc_find(struct drm_device *dev,
 	uint32_t id)
 {
@@ -1077,6 +1086,30 @@ static inline struct drm_encoder *drm_encoder_find(struct drm_device *dev,
 	return mo ? obj_to_encoder(mo) : NULL;
 }
 
+static inline struct drm_connector *drm_connector_find(struct drm_device *dev,
+		uint32_t id)
+{
+	struct drm_mode_object *mo;
+	mo = drm_mode_object_find(dev, id, DRM_MODE_OBJECT_CONNECTOR);
+	return mo ? obj_to_connector(mo) : NULL;
+}
+
+static inline struct drm_property *drm_property_find(struct drm_device *dev,
+		uint32_t id)
+{
+	struct drm_mode_object *mo;
+	mo = drm_mode_object_find(dev, id, DRM_MODE_OBJECT_PROPERTY);
+	return mo ? obj_to_property(mo) : NULL;
+}
+
+static inline struct drm_property_blob *
+drm_property_blob_find(struct drm_device *dev, uint32_t id)
+{
+	struct drm_mode_object *mo;
+	mo = drm_mode_object_find(dev, id, DRM_MODE_OBJECT_BLOB);
+	return mo ? obj_to_blob(mo) : NULL;
+}
+
 /* Plane list iterator for legacy (overlay only) planes. */
 #define drm_for_each_legacy_plane(plane, planelist) \
 	list_for_each_entry(plane, planelist, head) \

commit d5ab2b430b3cec65ba5b30b2e1de8ea46715cb93
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Jun 3 14:56:23 2014 +0300

    drm: drop drm_get_connector_name() and drm_get_encoder_name()
    
    No longer used or needed as the structs have a name field.
    
    Acked-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 5c1c31cc11cd..e8fe9d8e135c 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -909,7 +909,6 @@ extern int drm_crtc_check_viewport(const struct drm_crtc *crtc,
 
 extern void drm_encoder_cleanup(struct drm_encoder *encoder);
 
-extern const char *drm_get_connector_name(const struct drm_connector *connector);
 extern const char *drm_get_connector_status_name(enum drm_connector_status status);
 extern const char *drm_get_subpixel_order_name(enum subpixel_order order);
 extern const char *drm_get_dpms_name(int val);
@@ -972,7 +971,6 @@ extern int drm_mode_create_tv_properties(struct drm_device *dev, int num_formats
 				     char *formats[]);
 extern int drm_mode_create_scaling_mode_property(struct drm_device *dev);
 extern int drm_mode_create_dirty_info_property(struct drm_device *dev);
-extern const char *drm_get_encoder_name(const struct drm_encoder *encoder);
 
 extern int drm_mode_connector_attach_encoder(struct drm_connector *connector,
 					     struct drm_encoder *encoder);

commit e5748946e907f767e7bb73e5ed31584981f0ff65
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Wed May 14 16:58:20 2014 +0300

    drm: store encoder name in encoder struct
    
    This makes drm_get_encoder_name() thread safe.
    
    Reference: http://lkml.kernel.org/r/645ee6e22cad47d38a2b35c21c8d5fe3@DC1-MBX-01\
    .ptsecurity.ru
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b5c97d5b2654..5c1c31cc11cd 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -400,6 +400,7 @@ struct drm_encoder_funcs {
  * @dev: parent DRM device
  * @head: list management
  * @base: base KMS object
+ * @name: encoder name
  * @encoder_type: one of the %DRM_MODE_ENCODER_<foo> types in drm_mode.h
  * @possible_crtcs: bitmask of potential CRTC bindings
  * @possible_clones: bitmask of potential sibling encoders for cloning
@@ -416,6 +417,7 @@ struct drm_encoder {
 	struct list_head head;
 
 	struct drm_mode_object base;
+	char *name;
 	int encoder_type;
 	uint32_t possible_crtcs;
 	uint32_t possible_clones;

commit 2abdd3137e78adca69b0722307aa2ef89f2cf3b6
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Wed May 14 16:58:19 2014 +0300

    drm: store connector name in connector struct (v2)
    
    This makes drm_get_connector_name() thread safe.
    
    [airlied: fix to build.]
    
    Reference: http://lkml.kernel.org/r/645ee6e22cad47d38a2b35c21c8d5fe3@DC1-MBX-01.ptsecurity.ru
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 698d54e27f39..b5c97d5b2654 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -444,6 +444,7 @@ struct drm_encoder {
  * @attr: sysfs attributes
  * @head: list management
  * @base: base KMS object
+ * @name: connector name
  * @connector_type: one of the %DRM_MODE_CONNECTOR_<foo> types from drm_mode.h
  * @connector_type_id: index into connector type enum
  * @interlace_allowed: can this connector handle interlaced modes?
@@ -482,6 +483,7 @@ struct drm_connector {
 
 	struct drm_mode_object base;
 
+	char *name;
 	int connector_type;
 	int connector_type_id;
 	bool interlace_allowed;

commit 425a9a3ad1e64a00b4dbc827ae58df2aaf10ef43
Merge: ad222799bec3 a74591d781a8
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri May 16 11:47:13 2014 +1000

    Merge tag 'topic/core-stuff-2014-05-05' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    Update pull request with drm core patches. Mostly some polish for the
    primary plane stuff and a pile of patches all over from Thierry. Has
    survived a few days in drm-intel-nightly without causing ill.
    
    I've frobbed my scripts a bit to also tag my topic branches so that you
    have something stable to pull - I've accidentally pushed a bunch more
    patches onto this branch before you've taken the old pull request.
    
    * tag 'topic/core-stuff-2014-05-05' of git://anongit.freedesktop.org/drm-intel:
      drm: Make drm_crtc_helper_disable() return void
      drm: Fix indentation of closing brace
      drm/dp: Fix typo in comment
      drm: Fixup flip-work kerneldoc
      drm/fb: Fix typos
      drm/edid: Cleanup kerneldoc
      drm/edid: Drop revision argument for drm_mode_std()
      drm: Try to acquire modeset lock on panic or sysrq
      drm: remove unused argument from drm_open_helper
      drm: Handle ->disable_plane failures correctly
      drm: Simplify fb refcounting rules around ->update_plane
      drm/crtc-helper: gc usless connector loop in disable_unused_functions
      drm/plane_helper: don't disable plane in destroy function
      drm/plane-helper: Fix primary plane scaling check
      drm: make mode_valid callback optional
      drm/edid: Fill PAR in AVI infoframe based on CEA mode list

commit ad222799bec32a2db99c12b4dfa5dc19a1f6eaac
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri May 2 13:22:19 2014 +1000

    drm: fix memory leak around mode_group (v2)
    
    This mode group id_list was never being freed.
    
    v2: take David's suggestion to free in minor_free.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index e55fccbe7c42..c6b9e8ab0a26 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -915,6 +915,7 @@ extern const char *drm_get_tv_subconnector_name(int val);
 extern const char *drm_get_tv_select_name(int val);
 extern void drm_fb_release(struct drm_file *file_priv);
 extern int drm_mode_group_init_legacy_group(struct drm_device *dev, struct drm_mode_group *group);
+extern void drm_mode_group_destroy(struct drm_mode_group *group);
 extern bool drm_probe_ddc(struct i2c_adapter *adapter);
 extern struct edid *drm_get_edid(struct drm_connector *connector,
 				 struct i2c_adapter *adapter);

commit 0967e6a5070e336507ce52f09f7297413b966981
Author: Vandana Kannan <vandana.kannan@intel.com>
Date:   Tue Apr 1 16:26:59 2014 +0530

    drm/edid: Fill PAR in AVI infoframe based on CEA mode list
    
    Populate PAR in infoframe structure. If there is a user setting for PAR, then
    that value is set. Else, value is taken from CEA mode list if VIC is found.
    Else, PAR is calculated from resolution. If none of these conditions are
    satisfied, PAR is NONE as per initialization.
    
    v2: Removed the part which sets PAR according to user input, based on
    Daniel's review comments.
    
    A separate patch will be submitted to create a property that would enable a
    user space app to set aspect ratio for AVI infoframe.
    
    v2: Removed the part which sets PAR according to user input, based on
    Daniel's review comments.
    
    v3: Removed calculation of PAR for non-CEA modes as per discussion with
    Ville.
    
    A separate patch will be submitted to create a property that would enable a
    user space app to set aspect ratio for AVI infoframe.
    
    Signed-off-by: Vandana Kannan <vandana.kannan@intel.com>
    Cc: Jesse Barnes <jesse.barnes@intel.com>
    Cc: Vijay Purushothaman <vijay.a.purushothaman@intel.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: intel-gfx@lists.freedesktop.org
    Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    [danvet: Squash in fixup for htmldocs.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index e55fccbe7c42..c061bb372199 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1020,6 +1020,7 @@ extern int drm_mode_gamma_get_ioctl(struct drm_device *dev,
 extern int drm_mode_gamma_set_ioctl(struct drm_device *dev,
 				    void *data, struct drm_file *file_priv);
 extern u8 drm_match_cea_mode(const struct drm_display_mode *to_match);
+extern enum hdmi_picture_aspect drm_get_cea_aspect_ratio(const u8 video_code);
 extern bool drm_detect_hdmi_monitor(struct edid *edid);
 extern bool drm_detect_monitor_audio(struct edid *edid);
 extern bool drm_rgb_quant_range_selectable(struct edid *edid);

commit 780f59847193eac97901ab6e74683956b4b0cf20
Author: Matt Roper <matthew.d.roper@intel.com>
Date:   Tue Apr 1 15:22:41 2014 -0700

    drm: Remove unused drm_crtc->fb
    
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 46790c0de845..e55fccbe7c42 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -311,9 +311,6 @@ struct drm_crtc {
 	struct drm_plane *primary;
 	struct drm_plane *cursor;
 
-	/* framebuffer the connector is currently bound to */
-	struct drm_framebuffer *fb;
-
 	/* Temporary tracking of the old fb while a modeset is ongoing. Used
 	 * by drm_mode_set_config_internal to implement correct refcounting. */
 	struct drm_framebuffer *old_fb;

commit e13161af80c185ecd8dc4641d0f5df58f9e3e0af
Author: Matt Roper <matthew.d.roper@intel.com>
Date:   Tue Apr 1 15:22:38 2014 -0700

    drm: Add drm_crtc_init_with_planes() (v2)
    
    Add a new drm_crtc_init_with_planes() to allow drivers to provide
    specific primary and cursor planes at CRTC initialization.  The existing
    drm_crtc_init() interface remains to avoid driver churn in existing
    drivers; it will initialize the CRTC with a plane helper-created primary
    plane and no cursor plane.
    
    v2:
      - Move drm_crtc_init() to plane helper file so that nothing in the DRM
        core depends on helpers.  [suggested by Daniel Vetter]
      - Keep cursor parameter to drm_crtc_init_with_planes() a void* until
        we actually add cursor support.  [suggested by Daniel Vetter]
    
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 4c4f792588e9..46790c0de845 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -270,6 +270,8 @@ struct drm_crtc_funcs {
  * @dev: parent DRM device
  * @head: list management
  * @base: base KMS object for ID tracking etc.
+ * @primary: primary plane for this CRTC
+ * @cursor: cursor plane for this CRTC
  * @enabled: is this CRTC enabled?
  * @mode: current mode timings
  * @hwmode: mode timings as programmed to hw regs
@@ -305,6 +307,10 @@ struct drm_crtc {
 
 	struct drm_mode_object base;
 
+	/* primary and cursor planes for CRTC */
+	struct drm_plane *primary;
+	struct drm_plane *cursor;
+
 	/* framebuffer the connector is currently bound to */
 	struct drm_framebuffer *fb;
 
@@ -824,6 +830,11 @@ extern void drm_modeset_lock_all(struct drm_device *dev);
 extern void drm_modeset_unlock_all(struct drm_device *dev);
 extern void drm_warn_on_modeset_not_all_locked(struct drm_device *dev);
 
+extern int drm_crtc_init_with_planes(struct drm_device *dev,
+				     struct drm_crtc *crtc,
+				     struct drm_plane *primary,
+				     void *cursor,
+				     const struct drm_crtc_funcs *funcs);
 extern int drm_crtc_init(struct drm_device *dev,
 			 struct drm_crtc *crtc,
 			 const struct drm_crtc_funcs *funcs);

commit 9922ab5a7e4a4e089b2abfb1425590b97a7a90a3
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Apr 1 20:16:57 2014 -0400

    drm: Add plane type property (v2)
    
    Add a plane type property to allow userspace to distinguish plane types.
    
    v2: Driver-specific churn eliminated now that drm_plane_init() and
        drm_universal_plane_init() were separated out in a previous patch.
    
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 201d8c29a7cd..4c4f792588e9 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -771,6 +771,7 @@ struct drm_mode_config {
 	struct list_head property_blob_list;
 	struct drm_property *edid_property;
 	struct drm_property *dpms_property;
+	struct drm_property *plane_type_property;
 
 	/* DVI-I properties */
 	struct drm_property *dvi_i_subconnector_property;

commit dc415ff97d6b8f21cc6d264962f3a857a8d44650
Author: Matt Roper <matthew.d.roper@intel.com>
Date:   Tue Apr 1 15:22:36 2014 -0700

    drm: Add drm_universal_plane_init()
    
    Add a new plane initialization interface for universal plane support
    that allows a specific plane type (primary, cursor, or overlay) to
    be specified.
    
    drm_plane_init() remains as a compatibility API to reduce churn in
    existing drivers.  The 'bool priv' parameter has been changed to
    'bool is_primary' under the assumption that all existing uses of
    private planes were representing primary planes.
    
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 2765a4eea4cc..201d8c29a7cd 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -874,12 +874,19 @@ static inline bool drm_encoder_crtc_ok(struct drm_encoder *encoder,
 	return !!(encoder->possible_crtcs & drm_crtc_mask(crtc));
 }
 
+extern int drm_universal_plane_init(struct drm_device *dev,
+				    struct drm_plane *plane,
+				    unsigned long possible_crtcs,
+				    const struct drm_plane_funcs *funcs,
+				    const uint32_t *formats,
+				    uint32_t format_count,
+				    enum drm_plane_type type);
 extern int drm_plane_init(struct drm_device *dev,
 			  struct drm_plane *plane,
 			  unsigned long possible_crtcs,
 			  const struct drm_plane_funcs *funcs,
 			  const uint32_t *formats, uint32_t format_count,
-			  bool priv);
+			  bool is_primary);
 extern void drm_plane_cleanup(struct drm_plane *plane);
 extern void drm_plane_force_disable(struct drm_plane *plane);
 extern int drm_crtc_check_viewport(const struct drm_crtc *crtc,

commit af93629d1524dfff7df215b7de692f4de5ee855f
Author: Matt Roper <matthew.d.roper@intel.com>
Date:   Tue Apr 1 15:22:34 2014 -0700

    drm: Make drm_crtc_check_viewport non-static
    
    This function will be used by the universal plane helpers and may also
    be useful for individual drivers.
    
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 3894f85dcdff..2765a4eea4cc 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -882,6 +882,10 @@ extern int drm_plane_init(struct drm_device *dev,
 			  bool priv);
 extern void drm_plane_cleanup(struct drm_plane *plane);
 extern void drm_plane_force_disable(struct drm_plane *plane);
+extern int drm_crtc_check_viewport(const struct drm_crtc *crtc,
+				   int x, int y,
+				   const struct drm_display_mode *mode,
+				   const struct drm_framebuffer *fb);
 
 extern void drm_encoder_cleanup(struct drm_encoder *encoder);
 

commit e27dde3e1c5117149c50b89d688528e279756113
Author: Matt Roper <matthew.d.roper@intel.com>
Date:   Tue Apr 1 15:22:30 2014 -0700

    drm: Add support for multiple plane types (v2)
    
    The DRM core currently only tracks "overlay"-style planes.  Start
    refactoring the plane handling to allow other plane types (primary and
    cursor) to also be placed on the DRM plane list.
    
    v2: Add drm_for_each_legacy_plane() iterator to smooth transition
        of drivers with plane loops.
    
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 27f828c9d7f2..3894f85dcdff 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -541,6 +541,12 @@ struct drm_plane_funcs {
 			    struct drm_property *property, uint64_t val);
 };
 
+enum drm_plane_type {
+	DRM_PLANE_TYPE_OVERLAY,
+	DRM_PLANE_TYPE_PRIMARY,
+	DRM_PLANE_TYPE_CURSOR,
+};
+
 /**
  * drm_plane - central DRM plane control structure
  * @dev: DRM device this plane belongs to
@@ -553,6 +559,7 @@ struct drm_plane_funcs {
  * @fb: currently bound fb
  * @funcs: helper functions
  * @properties: property tracking for this plane
+ * @type: type of plane (overlay, primary, cursor)
  */
 struct drm_plane {
 	struct drm_device *dev;
@@ -570,6 +577,8 @@ struct drm_plane {
 	const struct drm_plane_funcs *funcs;
 
 	struct drm_object_properties properties;
+
+	enum drm_plane_type type;
 };
 
 /**
@@ -732,7 +741,15 @@ struct drm_mode_config {
 	struct list_head bridge_list;
 	int num_encoder;
 	struct list_head encoder_list;
-	int num_plane;
+
+	/*
+	 * Track # of overlay planes separately from # of total planes.  By
+	 * default we only advertise overlay planes to userspace; if userspace
+	 * sets the "universal plane" capability bit, we'll go ahead and
+	 * expose all planes.
+	 */
+	int num_overlay_plane;
+	int num_total_plane;
 	struct list_head plane_list;
 
 	int num_crtc;
@@ -1036,4 +1053,9 @@ static inline struct drm_encoder *drm_encoder_find(struct drm_device *dev,
 	return mo ? obj_to_encoder(mo) : NULL;
 }
 
+/* Plane list iterator for legacy (overlay only) planes. */
+#define drm_for_each_legacy_plane(plane, planelist) \
+	list_for_each_entry(plane, planelist, head) \
+		if (plane->type == DRM_PLANE_TYPE_OVERLAY)
+
 #endif /* __DRM_CRTC_H__ */

commit 55310008684309985110fdb99fa7b61c649778b2
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 23 15:52:20 2014 +0100

    drm: extract drm_modes.h for drm_crtc.h functions
    
    I want to also include kerneldoc from the header (for static inline
    functions and structs), but fishing the right pieces out of a giant
    header is a real pain. So split things out.
    
    Note that it's not a really clean header with sane include orders, but
    given's drm historical knack for giant headers detangling this is a
    major task.
    
    v2: Also extract struct drm_cmdline_mode.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 44c8576ddbe3..27f828c9d7f2 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -32,7 +32,6 @@
 #include <linux/fb.h>
 #include <linux/hdmi.h>
 #include <drm/drm_mode.h>
-
 #include <drm/drm_fourcc.h>
 
 struct drm_device;
@@ -65,130 +64,14 @@ struct drm_object_properties {
 	uint64_t values[DRM_OBJECT_MAX_PROPERTY];
 };
 
-/*
- * Note on terminology:  here, for brevity and convenience, we refer to connector
- * control chips as 'CRTCs'.  They can control any type of connector, VGA, LVDS,
- * DVI, etc.  And 'screen' refers to the whole of the visible display, which
- * may span multiple monitors (and therefore multiple CRTC and connector
- * structures).
- */
-
-enum drm_mode_status {
-    MODE_OK	= 0,	/* Mode OK */
-    MODE_HSYNC,		/* hsync out of range */
-    MODE_VSYNC,		/* vsync out of range */
-    MODE_H_ILLEGAL,	/* mode has illegal horizontal timings */
-    MODE_V_ILLEGAL,	/* mode has illegal horizontal timings */
-    MODE_BAD_WIDTH,	/* requires an unsupported linepitch */
-    MODE_NOMODE,	/* no mode with a matching name */
-    MODE_NO_INTERLACE,	/* interlaced mode not supported */
-    MODE_NO_DBLESCAN,	/* doublescan mode not supported */
-    MODE_NO_VSCAN,	/* multiscan mode not supported */
-    MODE_MEM,		/* insufficient video memory */
-    MODE_VIRTUAL_X,	/* mode width too large for specified virtual size */
-    MODE_VIRTUAL_Y,	/* mode height too large for specified virtual size */
-    MODE_MEM_VIRT,	/* insufficient video memory given virtual size */
-    MODE_NOCLOCK,	/* no fixed clock available */
-    MODE_CLOCK_HIGH,	/* clock required is too high */
-    MODE_CLOCK_LOW,	/* clock required is too low */
-    MODE_CLOCK_RANGE,	/* clock/mode isn't in a ClockRange */
-    MODE_BAD_HVALUE,	/* horizontal timing was out of range */
-    MODE_BAD_VVALUE,	/* vertical timing was out of range */
-    MODE_BAD_VSCAN,	/* VScan value out of range */
-    MODE_HSYNC_NARROW,	/* horizontal sync too narrow */
-    MODE_HSYNC_WIDE,	/* horizontal sync too wide */
-    MODE_HBLANK_NARROW,	/* horizontal blanking too narrow */
-    MODE_HBLANK_WIDE,	/* horizontal blanking too wide */
-    MODE_VSYNC_NARROW,	/* vertical sync too narrow */
-    MODE_VSYNC_WIDE,	/* vertical sync too wide */
-    MODE_VBLANK_NARROW,	/* vertical blanking too narrow */
-    MODE_VBLANK_WIDE,	/* vertical blanking too wide */
-    MODE_PANEL,         /* exceeds panel dimensions */
-    MODE_INTERLACE_WIDTH, /* width too large for interlaced mode */
-    MODE_ONE_WIDTH,     /* only one width is supported */
-    MODE_ONE_HEIGHT,    /* only one height is supported */
-    MODE_ONE_SIZE,      /* only one resolution is supported */
-    MODE_NO_REDUCED,    /* monitor doesn't accept reduced blanking */
-    MODE_NO_STEREO,	/* stereo modes not supported */
-    MODE_UNVERIFIED = -3, /* mode needs to reverified */
-    MODE_BAD = -2,	/* unspecified reason */
-    MODE_ERROR	= -1	/* error condition */
-};
-
-#define DRM_MODE_TYPE_CLOCK_CRTC_C (DRM_MODE_TYPE_CLOCK_C | \
-				    DRM_MODE_TYPE_CRTC_C)
-
-#define DRM_MODE(nm, t, c, hd, hss, hse, ht, hsk, vd, vss, vse, vt, vs, f) \
-	.name = nm, .status = 0, .type = (t), .clock = (c), \
-	.hdisplay = (hd), .hsync_start = (hss), .hsync_end = (hse), \
-	.htotal = (ht), .hskew = (hsk), .vdisplay = (vd), \
-	.vsync_start = (vss), .vsync_end = (vse), .vtotal = (vt), \
-	.vscan = (vs), .flags = (f), \
-	.base.type = DRM_MODE_OBJECT_MODE
-
-#define CRTC_INTERLACE_HALVE_V	(1 << 0) /* halve V values for interlacing */
-#define CRTC_STEREO_DOUBLE	(1 << 1) /* adjust timings for stereo modes */
-
-#define DRM_MODE_FLAG_3D_MAX	DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF
-
-struct drm_display_mode {
-	/* Header */
-	struct list_head head;
-	struct drm_mode_object base;
-
-	char name[DRM_DISPLAY_MODE_LEN];
-
-	enum drm_mode_status status;
-	unsigned int type;
-
-	/* Proposed mode values */
-	int clock;		/* in kHz */
-	int hdisplay;
-	int hsync_start;
-	int hsync_end;
-	int htotal;
-	int hskew;
-	int vdisplay;
-	int vsync_start;
-	int vsync_end;
-	int vtotal;
-	int vscan;
-	unsigned int flags;
-
-	/* Addressable image size (may be 0 for projectors, etc.) */
-	int width_mm;
-	int height_mm;
-
-	/* Actual mode we give to hw */
-	int crtc_clock;		/* in KHz */
-	int crtc_hdisplay;
-	int crtc_hblank_start;
-	int crtc_hblank_end;
-	int crtc_hsync_start;
-	int crtc_hsync_end;
-	int crtc_htotal;
-	int crtc_hskew;
-	int crtc_vdisplay;
-	int crtc_vblank_start;
-	int crtc_vblank_end;
-	int crtc_vsync_start;
-	int crtc_vsync_end;
-	int crtc_vtotal;
-
-	/* Driver private mode info */
-	int private_size;
-	int *private;
-	int private_flags;
-
-	int vrefresh;		/* in Hz */
-	int hsync;		/* in kHz */
-	enum hdmi_picture_aspect picture_aspect_ratio;
+enum drm_connector_force {
+	DRM_FORCE_UNSPECIFIED,
+	DRM_FORCE_OFF,
+	DRM_FORCE_ON,         /* force on analog part normally */
+	DRM_FORCE_ON_DIGITAL, /* for DVI-I use digital connector */
 };
 
-static inline bool drm_mode_is_stereo(const struct drm_display_mode *mode)
-{
-	return mode->flags & DRM_MODE_FLAG_3D_MASK;
-}
+#include <drm/drm_modes.h>
 
 enum drm_connector_status {
 	connector_status_connected = 1,
@@ -540,13 +423,6 @@ struct drm_encoder {
 	void *helper_private;
 };
 
-enum drm_connector_force {
-	DRM_FORCE_UNSPECIFIED,
-	DRM_FORCE_OFF,
-	DRM_FORCE_ON,         /* force on analog part normally */
-	DRM_FORCE_ON_DIGITAL, /* for DVI-I use digital connector */
-};
-
 /* should we poll this connector for connects and disconnects */
 /* hot plug detectable */
 #define DRM_CONNECTOR_POLL_HPD (1 << 0)
@@ -1007,34 +883,10 @@ extern struct edid *drm_get_edid(struct drm_connector *connector,
 				 struct i2c_adapter *adapter);
 extern struct edid *drm_edid_duplicate(const struct edid *edid);
 extern int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid);
-extern void drm_mode_probed_add(struct drm_connector *connector, struct drm_display_mode *mode);
-extern void drm_mode_copy(struct drm_display_mode *dst, const struct drm_display_mode *src);
-extern struct drm_display_mode *drm_mode_duplicate(struct drm_device *dev,
-						   const struct drm_display_mode *mode);
-extern void drm_mode_debug_printmodeline(const struct drm_display_mode *mode);
 extern void drm_mode_config_init(struct drm_device *dev);
 extern void drm_mode_config_reset(struct drm_device *dev);
 extern void drm_mode_config_cleanup(struct drm_device *dev);
-extern void drm_mode_set_name(struct drm_display_mode *mode);
-extern bool drm_mode_equal(const struct drm_display_mode *mode1, const struct drm_display_mode *mode2);
-extern bool drm_mode_equal_no_clocks_no_stereo(const struct drm_display_mode *mode1, const struct drm_display_mode *mode2);
-extern int drm_mode_width(const struct drm_display_mode *mode);
-extern int drm_mode_height(const struct drm_display_mode *mode);
-
-/* for us by fb module */
-extern struct drm_display_mode *drm_mode_create(struct drm_device *dev);
-extern void drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode);
-extern void drm_mode_validate_size(struct drm_device *dev,
-				   struct list_head *mode_list,
-				   int maxX, int maxY, int maxPitch);
-extern void drm_mode_prune_invalid(struct drm_device *dev,
-				   struct list_head *mode_list, bool verbose);
-extern void drm_mode_sort(struct list_head *mode_list);
-extern int drm_mode_hsync(const struct drm_display_mode *mode);
-extern int drm_mode_vrefresh(const struct drm_display_mode *mode);
-extern void drm_mode_set_crtcinfo(struct drm_display_mode *p,
-				  int adjust_flags);
-extern void drm_mode_connector_list_update(struct drm_connector *connector);
+
 extern int drm_mode_connector_update_edid_property(struct drm_connector *connector,
 						struct edid *edid);
 extern int drm_object_property_set_value(struct drm_mode_object *obj,
@@ -1136,16 +988,6 @@ extern bool drm_detect_monitor_audio(struct edid *edid);
 extern bool drm_rgb_quant_range_selectable(struct edid *edid);
 extern int drm_mode_page_flip_ioctl(struct drm_device *dev,
 				    void *data, struct drm_file *file_priv);
-extern struct drm_display_mode *drm_cvt_mode(struct drm_device *dev,
-				int hdisplay, int vdisplay, int vrefresh,
-				bool reduced, bool interlaced, bool margins);
-extern struct drm_display_mode *drm_gtf_mode(struct drm_device *dev,
-				int hdisplay, int vdisplay, int vrefresh,
-				bool interlaced, int margins);
-extern struct drm_display_mode *drm_gtf_mode_complex(struct drm_device *dev,
-				int hdisplay, int vdisplay, int vrefresh,
-				bool interlaced, int margins, int GTF_M,
-				int GTF_2C, int GTF_K, int GTF_2J);
 extern int drm_add_modes_noedid(struct drm_connector *connector,
 				int hdisplay, int vdisplay);
 extern void drm_set_preferred_mode(struct drm_connector *connector,

commit 69fa5293bf8d0ade3fd726848c7af925227e9180
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 23 01:28:49 2014 +0100

    drm/kms: rip out drm_mode_connector_detach_encoder
    
    It's only used by imx, and that one gets it wrong - there's no need
    to deteach the encoder before removing it.
    
    And really, neither current drm modesetting code nor all the userspace
    we have can handle dynamic changes in the set of possible encoders for
    a given connector. So let's just remove this before someone starts
    doing something really nasty with it.
    
    As a plus, one less kerneldoc comment to write.
    
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f7646548660d..44c8576ddbe3 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1082,8 +1082,6 @@ extern const char *drm_get_encoder_name(const struct drm_encoder *encoder);
 
 extern int drm_mode_connector_attach_encoder(struct drm_connector *connector,
 					     struct drm_encoder *encoder);
-extern void drm_mode_connector_detach_encoder(struct drm_connector *connector,
-					   struct drm_encoder *encoder);
 extern int drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,
 					 int gamma_size);
 extern struct drm_mode_object *drm_mode_object_find(struct drm_device *dev,

commit 4d33f3aa1cc7869c5ea4d57f3715b37bdcf515db
Merge: 4d538b791979 4c0e55288211
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Mar 4 07:51:41 2014 +1000

    Merge tag 'drm-intel-next-2014-02-14' of ssh://git.freedesktop.org/git/drm-intel into drm-next
    
    - Fix the execbuf rebind performance regression due to topic/ppgtt (Chris).
    - Fix up the connector cleanup ordering for sdvod i2c and dp aux devices (Imre).
    - Try to preserve the firmware modeset config on driver load. And a bit of prep
      work for smooth takeover of the fb contents (Jesse).
    - Prep cleanup for larger gtt address spaces on bdw (Ben).
    - Improve our vblank_wait code to make hsw modesets faster (Paulo).
    - Display debugfs file (Jesse).
    - DRRS prep work from Vandana Kannan.
    - pipestat interrupt handler to fix a few races around vblank/pageflip handling
      on byt (Imre).
    - Improve display fuse handling for display-less SKUs (Damien).
    - Drop locks while stalling for the gpu when serving pagefaults to improve
      interactivity (Chris).
    - And as usual piles of other improvements and small fixes all over.
    
    * tag 'drm-intel-next-2014-02-14' of ssh://git.freedesktop.org/git/drm-intel: (65 commits)
      drm/i915: fix NULL deref in the load detect code
      drm/i915: Only bind each object rather than for every execbuffer
      drm/i915: Directly return the vma from bind_to_vm
      drm/i915: Simplify i915_gem_object_ggtt_unpin
      drm/i915: Allow blocking in the PDE alloc when running low on gtt space
      drm/i915: Don't allocate context pages as mappable
      drm/i915: Handle set_cache_level errors in the status page setup
      drm/i915: Don't pin the status page as mappable
      drm/i915: Don't set PIN_MAPPABLE for legacy ringbuffers
      drm/i915: Handle set_cache_level errors in the pipe control scratch setup
      drm/i915: split PIN_GLOBAL out from PIN_MAPPABLE
      drm/i915: Consolidate binding parameters into flags
      drm/i915: sdvo: add i2c sysfs symlink to the connector's directory
      drm/i915: sdvo: fix error path in sdvo_connector_init
      drm/i915: dp: fix order of dp aux i2c device cleanup
      drm/i915: add unregister callback to connector
      drm/i915: don't reference null pointer at i915_sink_crc
      drm/i915/lvds: Remove dead code from failing case
      drm/i915: don't preserve inherited configs with nothing on v2
      drm/i915/bdw: Split up PPGTT cleanup
      ...

commit 8716ed4e7bed4e4c7e3f37940e950ddc0362f450
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Feb 12 12:48:23 2014 -0500

    drm: add DRM_CAPs for cursor size
    
    Some hardware may not support standard 64x64 cursors.  Add
    a drm cap to query the cursor size from the kernel.  Some examples
    include radeon CIK parts (128x128 cursors) and armada (32x64 or 64x32).
    This allows things like device specific ddxes to remove asics specific
    logic and also allows xf86-video-modesetting to work properly with hw
    cursors on this hardware. Default to 64 if the driver doesn't specify
    a size.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 71727b6210ae..8f3dee097579 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -907,6 +907,9 @@ struct drm_mode_config {
 
 	/* whether async page flip is supported or not */
 	bool async_page_flip;
+
+	/* cursor size */
+	uint32_t cursor_width, cursor_height;
 };
 
 #define obj_to_crtc(x) container_of(x, struct drm_crtc, base)

commit ac1bb36c4e28b53b3494bc8afbe6ffa0588bfe4a
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Feb 10 15:32:44 2014 -0800

    drm: expose subpixel order name routine v3
    
    Just like we have for connector type etc.
    
    v2: drop static array (Chris)
    v3: add kdoc (Daniel)
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 71727b6210ae..ce9ee60f4d68 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -991,6 +991,7 @@ extern void drm_encoder_cleanup(struct drm_encoder *encoder);
 
 extern const char *drm_get_connector_name(const struct drm_connector *connector);
 extern const char *drm_get_connector_status_name(enum drm_connector_status status);
+extern const char *drm_get_subpixel_order_name(enum subpixel_order order);
 extern const char *drm_get_dpms_name(int val);
 extern const char *drm_get_dvi_i_subconnector_name(int val);
 extern const char *drm_get_dvi_i_select_name(int val);

commit 45ab1e07808585c645bc82afd7487a91390f5511
Merge: f4b4718b61d1 13411ddd3190
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Jan 29 12:03:56 2014 +1000

    Merge tag 'drm/for-3.14-rc1-20140123' of git://anongit.freedesktop.org/tegra/linux into drm-next
    
    drm/tegra: Changes for v3.14-rc1 (update)
    
    These patches fix some issues caused by the DRM panel support from the
    previous pull request and add two more panels (for the Toshiba AC100 as
    well as the Seaboard and Ventana).
    
    * tag 'drm/for-3.14-rc1-20140123' of git://anongit.freedesktop.org/tegra/linux:
      drm/tegra: Obtain head number from DT
      drm/panel: update EDID BLOB in panel_simple_get_modes()
      gpu: host1x: Remove unnecessary include
      drm/tegra: Use proper data type
      drm/tegra: Clarify how panel modes override others
      drm/tegra: Fix possible CRTC mask for RGB outputs
      drm/i915: Use drm_encoder_crtc_ok()
      drm: Move drm_encoder_crtc_ok() to core
      drm: provide a helper for the encoder possible_crtcs mask
      drm/tegra: Don't check resource with devm_ioremap_resource()
      drm/panel: Add support for Chunghwa CLAA101WA01A panel
      drm/panel: Add support for Samsung LTN101NT05 panel

commit f5395ba35f2ae52eb5839f8046e4aeef6df7f357
Merge: 2b76a676f797 095163bad59b
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Jan 22 09:13:13 2014 +1000

    Merge branch 'drm-vbl-timestamp' of git://gitorious.org/vsyrjala/linux into drm-next
    
    Here's the vblank timestamp pull request you wanted.
    
    I addressed the few bugs that Mario pointed out and added
    the r-bs.
    
    As it has been a while since I made the changes, I gave it a
    quick spin on a few different i915 machines. Fortunately
    everything still seems to be fine.
    
    * 'drm-vbl-timestamp' of git://gitorious.org/vsyrjala/linux:
      drm/i915: Add a kludge for DSL incrementing too late and ISR not working
      drm/radeon: Move the early vblank IRQ fixup to radeon_get_crtc_scanoutpos()
      drm: Pass 'flags' from the caller to .get_scanout_position()
      drm: Fix vblank timestamping constants for interlaced modes
      drm/i915: Fix scanoutpos calculations for interlaced modes
      drm: Change {pixel,line,frame}dur_ns from s64 to int
      drm: Use crtc_clock in drm_calc_timestamping_constants()
      drm/radeon: Populate crtc_clock in radeon_atom_get_tv_timings()
      drm: Simplify the math in drm_calc_timestamping_constants()
      drm: Improve drm_calc_timestamping_constants() documentation
      drm/i915: Call drm_calc_timestamping_constants() earlier
      drm/i915: Kill hwmode save/restore
      drm: Pass the display mode to drm_calc_vbltimestamp_from_scanoutpos()
      drm: Pass the display mode to drm_calc_timestamping_constants()

commit 985e5dc207e133b4ad26c35deec4de82bcb44e68
Author: Vandana Kannan <vandana.kannan@intel.com>
Date:   Thu Dec 19 15:34:07 2013 +0530

    drm/edid: Populate picture aspect ratio for CEA modes
    
    Adding picture aspect ratio for CEA modes based on CEA-861D Table 3 or
    CEA-861E Table 4. This is useful for filling up the detail in AVI
    infoframe.
    
    v2: Ville's review comments incorporated
    Added picture aspect ratio as part of edid_cea_modes instead of DRM_MODE
    
    Signed-off-by: Vandana Kannan <vandana.kannan@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f32c5cd51f41..e51e8975dd6f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -30,6 +30,7 @@
 #include <linux/types.h>
 #include <linux/idr.h>
 #include <linux/fb.h>
+#include <linux/hdmi.h>
 #include <drm/drm_mode.h>
 
 #include <drm/drm_fourcc.h>
@@ -181,6 +182,7 @@ struct drm_display_mode {
 
 	int vrefresh;		/* in Hz */
 	int hsync;		/* in kHz */
+	enum hdmi_picture_aspect picture_aspect_ratio;
 };
 
 static inline bool drm_mode_is_stereo(const struct drm_display_mode *mode)

commit 3c184f69917d16e295934fcbe0803355b544df64
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Sat Oct 26 17:38:52 2013 +0300

    drm: Change {pixel,line,frame}dur_ns from s64 to int
    
    Using s64 for the timestamping constants is wasteful. Signed 32bit
    integers get us a range of over +-2 seconds. Presuming that no-one
    wants to a vrefresh rate less than 0.5, we can switch to using int
    for the timestamping constants. We save a few bytes in drm_crtc and
    avoid a bunch of 64bit math.
    
    Reviewed-by: mario.kleiner.de@gmail.com
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f32c5cd51f41..a158ec0f97ab 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -447,7 +447,7 @@ struct drm_crtc {
 	uint16_t *gamma_store;
 
 	/* Constants needed for precise vblank and swap timestamping. */
-	s64 framedur_ns, linedur_ns, pixeldur_ns;
+	int framedur_ns, linedur_ns, pixeldur_ns;
 
 	/* if you are using the helper */
 	void *helper_private;

commit 3d887368701ef78fe17fc998fe5a74ac8f7c6d4c
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Jan 13 14:33:20 2014 +0100

    drm: Move drm_encoder_crtc_ok() to core
    
    Using the new drm_crtc_mask() function, drm_encoder_crtc_ok() can now be
    written in a significantly shorter way, so it can be moved to a header
    file and be made static inline.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 4f2e3e82f014..b3865a0e39f4 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -963,6 +963,19 @@ extern int drm_encoder_init(struct drm_device *dev,
 			    const struct drm_encoder_funcs *funcs,
 			    int encoder_type);
 
+/**
+ * drm_encoder_crtc_ok - can a given crtc drive a given encoder?
+ * @encoder: encoder to test
+ * @crtc: crtc to test
+ *
+ * Return false if @encoder can't be driven by @crtc, true otherwise.
+ */
+static inline bool drm_encoder_crtc_ok(struct drm_encoder *encoder,
+				       struct drm_crtc *crtc)
+{
+	return !!(encoder->possible_crtcs & drm_crtc_mask(crtc));
+}
+
 extern int drm_plane_init(struct drm_device *dev,
 			  struct drm_plane *plane,
 			  unsigned long possible_crtcs,

commit db5f7a6e78303fd96dc87487d6976145f70ab84a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jan 2 21:27:33 2014 +0000

    drm: provide a helper for the encoder possible_crtcs mask
    
    The encoder possible_crtcs mask identifies which CRTCs can be bound to
    a particular encoder.  Each bit from bit 0 defines an index in the list
    of CRTCs held in the DRM mode_config crtc_list.  Rather than having
    drivers trying to track the position of their CRTCs in the list, expose
    the code which already exists for calculating the appropriate mask bit
    for a CRTC.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    [treding@nvidia.com: add drm_crtc_index(), move to core]
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f32c5cd51f41..4f2e3e82f014 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -929,6 +929,19 @@ extern int drm_crtc_init(struct drm_device *dev,
 			 struct drm_crtc *crtc,
 			 const struct drm_crtc_funcs *funcs);
 extern void drm_crtc_cleanup(struct drm_crtc *crtc);
+extern unsigned int drm_crtc_index(struct drm_crtc *crtc);
+
+/**
+ * drm_crtc_mask - find the mask of a registered CRTC
+ * @crtc: CRTC to find mask for
+ *
+ * Given a registered CRTC, return the mask bit of that CRTC for an
+ * encoder's possible_crtcs field.
+ */
+static inline uint32_t drm_crtc_mask(struct drm_crtc *crtc)
+{
+	return 1 << drm_crtc_index(crtc);
+}
 
 extern void drm_connector_ida_init(void);
 extern void drm_connector_ida_destroy(void);

commit 3cf70dafd7bbbc91df0a9ecb081d46f9f3d867f6
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Fri Oct 11 10:01:08 2013 +0200

    drm: add drm_set_preferred_mode
    
    New helper function to set the preferred video mode.  Can be called
    after drm_add_modes_noedid if you don't want the largest supported
    video mode be used by default.
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index d3a91ade1d37..f32c5cd51f41 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1118,6 +1118,8 @@ extern struct drm_display_mode *drm_gtf_mode_complex(struct drm_device *dev,
 				int GTF_2C, int GTF_K, int GTF_2J);
 extern int drm_add_modes_noedid(struct drm_connector *connector,
 				int hdisplay, int vdisplay);
+extern void drm_set_preferred_mode(struct drm_connector *connector,
+				   int hpref, int vpref);
 
 extern int drm_edid_header_is_valid(const u8 *raw_edid);
 extern bool drm_edid_block_valid(u8 *raw_edid, int block, bool print_bad_edid);

commit 5e4e3ba997af8c756c23ffaa86652d3a4df5bdfa
Merge: 5bdebb183c97 585b691e2180
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Oct 22 09:38:18 2013 +0100

    Merge branch 'drm-tda998x-3.12' of git://ftp.arm.linux.org.uk/~rmk/linux-cubox into drm-next
    
    This adds support for the Armada 510 display subsystem found on the
    Marvell Dove devices.  This IP is re-used across several different Marvell
    SoCs with various tweaks, and this driver has been structured to allow
    the other IPs to re-use the bulk of this code; further work in this area
    is expected from interested parties.
    
    This has been extensively tested on the SolidRun Cubox platform and
    appears to work well there.
    
    [airlied: update for api changes merged previous to this]

commit 5bdebb183c9702a8c57a01dff09337be3de337a6
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Oct 11 14:07:25 2013 +1000

    drm/sysfs: sort out minor and connector device object lifetimes.
    
    So drm was abusing device lifetimes, by having embedded device structures
    in the minor and connector it meant that the lifetime of the internal drm
    objects (drm_minor and drm_connector) were tied to the lifetime of the device
    files in sysfs, so if something kept those files opened the current code
    would kfree the objects and things would go downhill from there.
    
    Now in reality there is no need for these lifetimes to be so intertwined,
    especailly with hotplugging of devices where we wish to remove the sysfs
    and userspace facing pieces before we can unwind the internal objects due
    to open userspace files or mmaps, so split the objects out so the struct
    device is no longer embedded and do what fbdev does and just allocate
    and remove the sysfs inodes separately.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index ba407f6b4f1f..755dd2532612 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -595,7 +595,7 @@ enum drm_connector_force {
  */
 struct drm_connector {
 	struct drm_device *dev;
-	struct device kdev;
+	struct device *kdev;
 	struct device_attribute *attr;
 	struct list_head head;
 

commit 96f60e37dc66091bde8d5de136ff6fda09f2d799
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Aug 15 13:59:49 2012 +0100

    DRM: Armada: Add Armada DRM driver
    
    This patch adds support for the pair of LCD controllers on the Marvell
    Armada 510 SoCs.  This driver supports:
    - multiple contiguous scanout buffers for video and graphics
    - shm backed cacheable buffer objects for X pixmaps for Vivante GPU
      acceleration
    - dual lcd0 and lcd1 crt operation
    - video overlay on each LCD crt via DRM planes
    - page flipping of the main scanout buffers
    - DRM prime for buffer export/import
    
    This driver is trivial to extend to other Armada SoCs.
    
    Included in this commit is the core driver with no output support; output
    support is platform and encoder driver dependent.
    
    Tested-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 24f499569a2f..e5e6e9124cbc 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1135,4 +1135,21 @@ extern int drm_format_horz_chroma_subsampling(uint32_t format);
 extern int drm_format_vert_chroma_subsampling(uint32_t format);
 extern const char *drm_get_format_name(uint32_t format);
 
+/* Helpers */
+static inline struct drm_crtc *drm_crtc_find(struct drm_device *dev,
+	uint32_t id)
+{
+	struct drm_mode_object *mo;
+	mo = drm_mode_object_find(dev, id, DRM_MODE_OBJECT_CRTC);
+	return mo ? obj_to_crtc(mo) : NULL;
+}
+
+static inline struct drm_encoder *drm_encoder_find(struct drm_device *dev,
+	uint32_t id)
+{
+	struct drm_mode_object *mo;
+	mo = drm_mode_object_find(dev, id, DRM_MODE_OBJECT_ENCODER);
+	return mo ? obj_to_encoder(mo) : NULL;
+}
+
 #endif /* __DRM_CRTC_H__ */

commit 967ad7f1489da7babbe0746f81c283458ecd3f84
Merge: d7bf63f2465b 6aba5b6cf098
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Oct 10 12:44:43 2013 +0200

    Merge remote-tracking branch 'airlied/drm-next' into drm-intel-next
    
    The conflict in intel_drv.h tripped me up a bit since a patch in dinq
    moves all the functions around, but another one in drm-next removes a
    single function. So I'ev figured backing this into a backmerge would
    be good.
    
    i915_dma.c is just adjacent lines changed, nothing nefarious there.
    
    Conflicts:
            drivers/gpu/drm/i915/i915_dma.c
            drivers/gpu/drm/i915/intel_drv.h
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 5848ad409c1817f5b70507e6b4440fcbd002f6c5
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Fri Sep 27 12:11:50 2013 +0100

    drm: Reject stereo modes with an unknown layout
    
    The kernel shouldn't accept invalid modes, just say No.
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index eb6b8dc971d9..50cedadc9fcc 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -128,6 +128,8 @@ enum drm_mode_status {
 #define CRTC_INTERLACE_HALVE_V	(1 << 0) /* halve V values for interlacing */
 #define CRTC_STEREO_DOUBLE	(1 << 1) /* adjust timings for stereo modes */
 
+#define DRM_MODE_FLAG_3D_MAX	DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF
+
 struct drm_display_mode {
 	/* Header */
 	struct list_head head;

commit f7e121b76469624459152542c1b809a1ebc835fe
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Fri Sep 27 12:11:48 2013 +0100

    drm: Code stereo layouts as an enum rather than a bit field
    
    This allows us to use fewer bits in the mode structure, leaving room for
    future work while allowing more stereo layouts types than we could have
    ever dreamt of.
    
    I also exposed the previously private DRM_MODE_FLAG_3D_MASK to set in
    stone that we are using 5 bits for the stereo layout enum, reserving 32
    values.
    
    Even with that reservation, we gain 3 bits from the previous encoding.
    
    The code adding the mandatory stereo modes needeed to be adapted as it was
    relying or being able to or stereo layouts together.
    
    Suggested-by: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b2d08ca68ee7..eb6b8dc971d9 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -181,15 +181,6 @@ struct drm_display_mode {
 	int hsync;		/* in kHz */
 };
 
-#define DRM_MODE_FLAG_3D_MASK	(DRM_MODE_FLAG_3D_FRAME_PACKING		| \
-				 DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE	| \
-				 DRM_MODE_FLAG_3D_LINE_ALTERNATIVE	| \
-				 DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL	| \
-				 DRM_MODE_FLAG_3D_L_DEPTH		| \
-				 DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH | \
-				 DRM_MODE_FLAG_3D_TOP_AND_BOTTOM	| \
-				 DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF)
-
 static inline bool drm_mode_is_stereo(const struct drm_display_mode *mode)
 {
 	return mode->flags & DRM_MODE_FLAG_3D_MASK;

commit 448cce25f408be4c933f88ed8962455a0c16d0f8
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Wed Sep 25 16:45:35 2013 +0100

    drm: Implement timings adjustments for frame packing
    
    When using the frame packing and a single big framebuffer, some hardware
    requires that we do everything like if we were scanning out the big
    buffer itself. Let's instrument drm_mode_set_crtcinfo() to be able to do
    this adjustement if the driver is asking for it.
    
    v2: Use crtc_vtotal and multiply the clock by 2 instead of
        reconstructing it (Ville Syrjälä)
    
    Suggested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 73478bc8f9ee..b2d08ca68ee7 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -125,7 +125,8 @@ enum drm_mode_status {
 	.vscan = (vs), .flags = (f), \
 	.base.type = DRM_MODE_OBJECT_MODE
 
-#define CRTC_INTERLACE_HALVE_V 0x1 /* halve V values for interlacing */
+#define CRTC_INTERLACE_HALVE_V	(1 << 0) /* halve V values for interlacing */
+#define CRTC_STEREO_DOUBLE	(1 << 1) /* adjust timings for stereo modes */
 
 struct drm_display_mode {
 	/* Header */

commit bde2dcf701db9fa6d010afa8e9254c3d7b0331fb
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Wed Sep 25 16:45:34 2013 +0100

    drm: Introduce a crtc_clock for struct drm_display_mode
    
    Just like the various timings, make it possible to have a clock field
    what we can tweak before giving it to hardware.
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 8e9716e362e1..73478bc8f9ee 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -156,6 +156,7 @@ struct drm_display_mode {
 	int height_mm;
 
 	/* Actual mode we give to hw */
+	int crtc_clock;		/* in KHz */
 	int crtc_hdisplay;
 	int crtc_hblank_start;
 	int crtc_hblank_end;

commit 65427b1e94eca5923e0f723d1dd000f47e6d1696
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Wed Sep 25 16:45:33 2013 +0100

    drm: Remove synth_clock from struct drm_display_mode
    
    This field is unused. Garbage collect it.
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 011baaa159a2..8e9716e362e1 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -156,7 +156,6 @@ struct drm_display_mode {
 	int height_mm;
 
 	/* Actual mode we give to hw */
-	int synth_clock;
 	int crtc_hdisplay;
 	int crtc_hblank_start;
 	int crtc_hblank_end;

commit 99b314a0b37c1f637929db7f20d7e47eb2374c97
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Wed Sep 25 16:45:32 2013 +0100

    drm: Remove clock_index from struct drm_display_mode
    
    This field was only accessed by the nouveau driver, but never set. So
    concluded we can rid of this one.
    
    Acked-by: Ben Skeggs <bskeggs@redhat.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 1b69407f3f0f..011baaa159a2 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -156,7 +156,6 @@ struct drm_display_mode {
 	int height_mm;
 
 	/* Actual mode we give to hw */
-	int clock_index;
 	int synth_clock;
 	int crtc_hdisplay;
 	int crtc_hblank_start;

commit 560a067a93520a18a1dd7cf07ebd759a45270855
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Wed Sep 25 16:45:29 2013 +0100

    drm: Make exposing stereo modes a per-connector opt-in
    
    Just like with interlaced or double scan modes, make stereo modes a
    per-connector opt-in to give a chance to driver authors to make it work
    before enabling it.
    
    Suggested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 6b7f9c766b4e..1b69407f3f0f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -108,6 +108,7 @@ enum drm_mode_status {
     MODE_ONE_HEIGHT,    /* only one height is supported */
     MODE_ONE_SIZE,      /* only one resolution is supported */
     MODE_NO_REDUCED,    /* monitor doesn't accept reduced blanking */
+    MODE_NO_STEREO,	/* stereo modes not supported */
     MODE_UNVERIFIED = -3, /* mode needs to reverified */
     MODE_BAD = -2,	/* unspecified reason */
     MODE_ERROR	= -1	/* error condition */
@@ -611,6 +612,7 @@ struct drm_connector {
 	int connector_type_id;
 	bool interlace_allowed;
 	bool doublescan_allowed;
+	bool stereo_allowed;
 	struct list_head modes; /* list of modes on this connector */
 
 	enum drm_connector_status status;

commit f2ecf2e3bc01868f244fc6ba9cf8fe5d8446db5b
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Wed Sep 25 16:45:27 2013 +0100

    drm: Make drm_match_cea_mode() return the underlying 2D VIC for 3d modes
    
    When scanning out a stereo mode, the AVI infoframe vic field has to be
    the underlyng 2D VIC. Before that commit, we weren't matching the CEA
    mode because of the extra stereo flag and then were setting the VIC
    field in the AVI infoframe to 0.
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 825d6fad0981..6b7f9c766b4e 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -989,7 +989,7 @@ extern void drm_mode_config_reset(struct drm_device *dev);
 extern void drm_mode_config_cleanup(struct drm_device *dev);
 extern void drm_mode_set_name(struct drm_display_mode *mode);
 extern bool drm_mode_equal(const struct drm_display_mode *mode1, const struct drm_display_mode *mode2);
-extern bool drm_mode_equal_no_clocks(const struct drm_display_mode *mode1, const struct drm_display_mode *mode2);
+extern bool drm_mode_equal_no_clocks_no_stereo(const struct drm_display_mode *mode1, const struct drm_display_mode *mode2);
 extern int drm_mode_width(const struct drm_display_mode *mode);
 extern int drm_mode_height(const struct drm_display_mode *mode);
 

commit 4aa17cf0d889cfc984b68a78ae02070cef21bb6b
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Wed Sep 25 16:45:21 2013 +0100

    drm: Add HDMI stereo 3D flags to struct drm_mode_modeinfo
    
    HDMI 1.4a defines a few layouts that we'd like to expose. This commits
    add new modeinfo flags that can be used to list the supported stereo
    layouts (when querying the list of modes) and to set a given stereo 3D
    mode (when setting a mode).
    
    v2: Add a drm_mode_is_stereo() helper
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 24f499569a2f..825d6fad0981 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -180,6 +180,20 @@ struct drm_display_mode {
 	int hsync;		/* in kHz */
 };
 
+#define DRM_MODE_FLAG_3D_MASK	(DRM_MODE_FLAG_3D_FRAME_PACKING		| \
+				 DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE	| \
+				 DRM_MODE_FLAG_3D_LINE_ALTERNATIVE	| \
+				 DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL	| \
+				 DRM_MODE_FLAG_3D_L_DEPTH		| \
+				 DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH | \
+				 DRM_MODE_FLAG_3D_TOP_AND_BOTTOM	| \
+				 DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF)
+
+static inline bool drm_mode_is_stereo(const struct drm_display_mode *mode)
+{
+	return mode->flags & DRM_MODE_FLAG_3D_MASK;
+}
+
 enum drm_connector_status {
 	connector_status_connected = 1,
 	connector_status_disconnected = 2,

commit 51f8da5916f85c18b696f74f97970e5a7330147e
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Fri Sep 27 15:08:27 2013 +0300

    drm/edid: add drm_edid_duplicate
    
    We have some code duplication related to EDID duplication. Add a helper.
    
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 24f499569a2f..92e782060199 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -964,6 +964,7 @@ extern int drm_mode_group_init_legacy_group(struct drm_device *dev, struct drm_m
 extern bool drm_probe_ddc(struct i2c_adapter *adapter);
 extern struct edid *drm_get_edid(struct drm_connector *connector,
 				 struct i2c_adapter *adapter);
+extern struct edid *drm_edid_duplicate(const struct edid *edid);
 extern int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid);
 extern void drm_mode_probed_add(struct drm_connector *connector, struct drm_display_mode *mode);
 extern void drm_mode_copy(struct drm_display_mode *dst, const struct drm_display_mode *src);

commit 3b336ec4c5460833ad7573d0b6e22793f6a389ab
Author: Sean Paul <seanpaul@chromium.org>
Date:   Wed Aug 14 16:47:37 2013 -0400

    drm: Add drm_bridge
    
    This patch adds the notion of a drm_bridge. A bridge is a chained
    device which hangs off an encoder. The drm driver using the bridge
    should provide the association between encoder and bridge. Once a
    bridge is associated with an encoder, it will participate in mode
    set, and dpms (via the enable/disable hooks).
    
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 78ca1512c73f..24f499569a2f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -49,6 +49,7 @@ struct drm_clip_rect;
 #define DRM_MODE_OBJECT_FB 0xfbfbfbfb
 #define DRM_MODE_OBJECT_BLOB 0xbbbbbbbb
 #define DRM_MODE_OBJECT_PLANE 0xeeeeeeee
+#define DRM_MODE_OBJECT_BRIDGE 0xbdbdbdbd
 
 struct drm_mode_object {
 	uint32_t id;
@@ -305,6 +306,7 @@ struct drm_connector;
 struct drm_encoder;
 struct drm_pending_vblank_event;
 struct drm_plane;
+struct drm_bridge;
 
 /**
  * drm_crtc_funcs - control CRTCs for a given device
@@ -506,6 +508,7 @@ struct drm_encoder_funcs {
  * @possible_crtcs: bitmask of potential CRTC bindings
  * @possible_clones: bitmask of potential sibling encoders for cloning
  * @crtc: currently bound CRTC
+ * @bridge: bridge associated to the encoder
  * @funcs: control functions
  * @helper_private: mid-layer private data
  *
@@ -522,6 +525,7 @@ struct drm_encoder {
 	uint32_t possible_clones;
 
 	struct drm_crtc *crtc;
+	struct drm_bridge *bridge;
 	const struct drm_encoder_funcs *funcs;
 	void *helper_private;
 };
@@ -681,6 +685,48 @@ struct drm_plane {
 	struct drm_object_properties properties;
 };
 
+/**
+ * drm_bridge_funcs - drm_bridge control functions
+ * @mode_fixup: Try to fixup (or reject entirely) proposed mode for this bridge
+ * @disable: Called right before encoder prepare, disables the bridge
+ * @post_disable: Called right after encoder prepare, for lockstepped disable
+ * @mode_set: Set this mode to the bridge
+ * @pre_enable: Called right before encoder commit, for lockstepped commit
+ * @enable: Called right after encoder commit, enables the bridge
+ * @destroy: make object go away
+ */
+struct drm_bridge_funcs {
+	bool (*mode_fixup)(struct drm_bridge *bridge,
+			   const struct drm_display_mode *mode,
+			   struct drm_display_mode *adjusted_mode);
+	void (*disable)(struct drm_bridge *bridge);
+	void (*post_disable)(struct drm_bridge *bridge);
+	void (*mode_set)(struct drm_bridge *bridge,
+			 struct drm_display_mode *mode,
+			 struct drm_display_mode *adjusted_mode);
+	void (*pre_enable)(struct drm_bridge *bridge);
+	void (*enable)(struct drm_bridge *bridge);
+	void (*destroy)(struct drm_bridge *bridge);
+};
+
+/**
+ * drm_bridge - central DRM bridge control structure
+ * @dev: DRM device this bridge belongs to
+ * @head: list management
+ * @base: base mode object
+ * @funcs: control functions
+ * @driver_private: pointer to the bridge driver's internal context
+ */
+struct drm_bridge {
+	struct drm_device *dev;
+	struct list_head head;
+
+	struct drm_mode_object base;
+
+	const struct drm_bridge_funcs *funcs;
+	void *driver_private;
+};
+
 /**
  * drm_mode_set - new values for a CRTC config change
  * @head: list management
@@ -741,6 +787,7 @@ struct drm_mode_group {
 	uint32_t num_crtcs;
 	uint32_t num_encoders;
 	uint32_t num_connectors;
+	uint32_t num_bridges;
 
 	/* list of object IDs for this group */
 	uint32_t *id_list;
@@ -755,6 +802,8 @@ struct drm_mode_group {
  * @fb_list: list of framebuffers available
  * @num_connector: number of connectors on this device
  * @connector_list: list of connector objects
+ * @num_bridge: number of bridges on this device
+ * @bridge_list: list of bridge objects
  * @num_encoder: number of encoders on this device
  * @encoder_list: list of encoder objects
  * @num_crtc: number of CRTCs on this device
@@ -792,6 +841,8 @@ struct drm_mode_config {
 
 	int num_connector;
 	struct list_head connector_list;
+	int num_bridge;
+	struct list_head bridge_list;
 	int num_encoder;
 	struct list_head encoder_list;
 	int num_plane;
@@ -881,6 +932,10 @@ extern void drm_connector_cleanup(struct drm_connector *connector);
 /* helper to unplug all connectors from sysfs for device */
 extern void drm_connector_unplug_all(struct drm_device *dev);
 
+extern int drm_bridge_init(struct drm_device *dev, struct drm_bridge *bridge,
+			   const struct drm_bridge_funcs *funcs);
+extern void drm_bridge_cleanup(struct drm_bridge *bridge);
+
 extern int drm_encoder_init(struct drm_device *dev,
 			    struct drm_encoder *encoder,
 			    const struct drm_encoder_funcs *funcs,

commit 62f2104f3fc11c4cfd1307429cb955bfa48dcb37
Author: Keith Packard <keithp@keithp.com>
Date:   Mon Jul 22 18:50:00 2013 -0700

    drm: Advertise async page flip ability through GETCAP ioctl
    
    Let applications know whether the kernel supports asynchronous page
    flipping.
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Dave Airlie <airlied@gmail.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 0c7fec5b8fef..78ca1512c73f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -842,6 +842,9 @@ struct drm_mode_config {
 
 	/* dumb ioctl parameters */
 	uint32_t preferred_depth, prefer_shadow;
+
+	/* whether async page flip is supported or not */
+	bool async_page_flip;
 };
 
 #define obj_to_crtc(x) container_of(x, struct drm_crtc, base)

commit ed8d19756e80ec63003a93aa4d70406e6ba61522
Author: Keith Packard <keithp@keithp.com>
Date:   Mon Jul 22 18:49:58 2013 -0700

    drm: Pass page flip ioctl flags to driver
    
    This lets drivers see the flags requested by the application
    
    [airlied: fixup for rcar/imx/msm]
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Dave Airlie <airlied@gmail.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c4b1e6311467..0c7fec5b8fef 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -363,7 +363,8 @@ struct drm_crtc_funcs {
 	 */
 	int (*page_flip)(struct drm_crtc *crtc,
 			 struct drm_framebuffer *fb,
-			 struct drm_pending_vblank_event *event);
+			 struct drm_pending_vblank_event *event,
+			 uint32_t flags);
 
 	int (*set_property)(struct drm_crtc *crtc,
 			    struct drm_property *property, uint64_t val);

commit 807ac202f20aa0a5e991851931dbfa4e4fac558d
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Thu Aug 22 19:06:08 2013 +0100

    drm: Remove the dithering_mode_property field
    
    Unfortunately, I haven't been thorough enough in:
    
      commit ddecb10cf402a8325579f298fd4986a90f33496b
      Author: Lespiau, Damien <damien.lespiau@intel.com>
      Date:   Tue Aug 20 00:53:04 2013 +0100
    
          drm: Remove drm_mode_create_dithering_property()
    
    And forgot to remove the dithering_mode_property member of struct
    drm_mode_config.
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Dave Airlie <airlied@gmail.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 7987eff5dab2..c4b1e6311467 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -837,7 +837,6 @@ struct drm_mode_config {
 
 	/* Optional properties */
 	struct drm_property *scaling_mode_property;
-	struct drm_property *dithering_mode_property;
 	struct drm_property *dirty_info_property;
 
 	/* dumb ioctl parameters */

commit d4e4a31da334224d686d07983517831eab999798
Author: Lespiau, Damien <damien.lespiau@intel.com>
Date:   Mon Aug 19 16:58:52 2013 +0100

    drm: Don't export drm_find_cea_extension() any more
    
    This function is only used inside drm_edid.c.
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Dave Airlie <airlied@gmail.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 0a9f73e8be26..7987eff5dab2 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1032,7 +1032,6 @@ extern int drm_mode_gamma_get_ioctl(struct drm_device *dev,
 				    void *data, struct drm_file *file_priv);
 extern int drm_mode_gamma_set_ioctl(struct drm_device *dev,
 				    void *data, struct drm_file *file_priv);
-extern u8 *drm_find_cea_extension(struct edid *edid);
 extern u8 drm_match_cea_mode(const struct drm_display_mode *to_match);
 extern bool drm_detect_hdmi_monitor(struct edid *edid);
 extern bool drm_detect_monitor_audio(struct edid *edid);

commit a03eb8388d91eb1c8dae79b790e6560134977a15
Author: Lespiau, Damien <damien.lespiau@intel.com>
Date:   Tue Aug 20 00:53:07 2013 +0100

    drm: Remove 2 unused defines
    
    These were introduced in the very first DRM commit:
    
      commit f453ba0460742ad027ae0c4c7d61e62817b3e7ef
      Author: Dave Airlie <airlied@redhat.com>
      Date:   Fri Nov 7 14:05:41 2008 -0800
    
          DRM: add mode setting support
    
          Add mode setting support to the DRM layer.
    
    But are unused.
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 014e491c3c1c..0a9f73e8be26 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -494,8 +494,6 @@ struct drm_encoder_funcs {
 	void (*destroy)(struct drm_encoder *encoder);
 };
 
-#define DRM_CONNECTOR_MAX_UMODES 16
-#define DRM_CONNECTOR_LEN 32
 #define DRM_CONNECTOR_MAX_ENCODER 3
 
 /**

commit 86f422d5be001cfe311fc46d60a6e3ef6868dd40
Author: Lespiau, Damien <damien.lespiau@intel.com>
Date:   Tue Aug 20 00:53:06 2013 +0100

    drm: Make drm_mode_remove() static
    
    It's only used in drm_crtc.c.
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 39d84dc7abcf..014e491c3c1c 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -910,7 +910,6 @@ extern struct edid *drm_get_edid(struct drm_connector *connector,
 				 struct i2c_adapter *adapter);
 extern int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid);
 extern void drm_mode_probed_add(struct drm_connector *connector, struct drm_display_mode *mode);
-extern void drm_mode_remove(struct drm_connector *connector, struct drm_display_mode *mode);
 extern void drm_mode_copy(struct drm_display_mode *dst, const struct drm_display_mode *src);
 extern struct drm_display_mode *drm_mode_duplicate(struct drm_device *dev,
 						   const struct drm_display_mode *mode);

commit 67587e8689ffbb788468c738f07a9678bde51084
Author: Lespiau, Damien <damien.lespiau@intel.com>
Date:   Tue Aug 20 00:53:05 2013 +0100

    drm: Remove drm_mode_list_concat()
    
    The last user was removed in
    
      commit 575dc34ee0de867ba83abf25998e0963bff451fa
      Author: Dave Airlie <airlied@redhat.com>
      Date:   Mon Sep 7 18:43:26 2009 +1000
    
          drm/kms: remove old std mode fallback code.
    
          The new code adds modes in the helper, which makes more sense
          I disliked the non-driver code adding modes.
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 781988f637ec..39d84dc7abcf 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -927,8 +927,6 @@ extern int drm_mode_height(const struct drm_display_mode *mode);
 /* for us by fb module */
 extern struct drm_display_mode *drm_mode_create(struct drm_device *dev);
 extern void drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode);
-extern void drm_mode_list_concat(struct list_head *head,
-				 struct list_head *new);
 extern void drm_mode_validate_size(struct drm_device *dev,
 				   struct list_head *mode_list,
 				   int maxX, int maxY, int maxPitch);

commit ddecb10cf402a8325579f298fd4986a90f33496b
Author: Lespiau, Damien <damien.lespiau@intel.com>
Date:   Tue Aug 20 00:53:04 2013 +0100

    drm: Remove drm_mode_create_dithering_property()
    
    This was last used by nouveau, replaced by a driver-specific property
    in:
    
      commit de69185573586302ada2e59ba41835df36986277
      Author: Ben Skeggs <bskeggs@redhat.com>
      Date:   Mon Oct 17 12:23:41 2011 +1000
    
          drm/nouveau: improve dithering properties, and implement proper auto mode
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index eb40a967fc65..781988f637ec 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -982,7 +982,6 @@ extern int drm_mode_create_dvi_i_properties(struct drm_device *dev);
 extern int drm_mode_create_tv_properties(struct drm_device *dev, int num_formats,
 				     char *formats[]);
 extern int drm_mode_create_scaling_mode_property(struct drm_device *dev);
-extern int drm_mode_create_dithering_property(struct drm_device *dev);
 extern int drm_mode_create_dirty_info_property(struct drm_device *dev);
 extern const char *drm_get_encoder_name(const struct drm_encoder *encoder);
 

commit f51607ac8d4d09b59faf7c6d718f413f537a7b34
Author: Lespiau, Damien <damien.lespiau@intel.com>
Date:   Tue Aug 20 00:53:03 2013 +0100

    drm: Remove stale prototypes
    
    A few prototypes have been left in the headers, their function friends
    long gone.
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 45f133228553..eb40a967fc65 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -948,9 +948,6 @@ extern int drm_object_property_set_value(struct drm_mode_object *obj,
 extern int drm_object_property_get_value(struct drm_mode_object *obj,
 					 struct drm_property *property,
 					 uint64_t *value);
-extern struct drm_display_mode *drm_crtc_mode_create(struct drm_device *dev);
-extern void drm_framebuffer_set_object(struct drm_device *dev,
-				       unsigned long handle);
 extern int drm_framebuffer_init(struct drm_device *dev,
 				struct drm_framebuffer *fb,
 				const struct drm_framebuffer_funcs *funcs);
@@ -961,10 +958,6 @@ extern void drm_framebuffer_reference(struct drm_framebuffer *fb);
 extern void drm_framebuffer_remove(struct drm_framebuffer *fb);
 extern void drm_framebuffer_cleanup(struct drm_framebuffer *fb);
 extern void drm_framebuffer_unregister_private(struct drm_framebuffer *fb);
-extern int drmfb_probe(struct drm_device *dev, struct drm_crtc *crtc);
-extern int drmfb_remove(struct drm_device *dev, struct drm_framebuffer *fb);
-extern void drm_crtc_probe_connector_modes(struct drm_device *dev, int maxX, int maxY);
-extern bool drm_crtc_in_use(struct drm_crtc *crtc);
 
 extern void drm_object_attach_property(struct drm_mode_object *obj,
 				       struct drm_property *property,
@@ -1039,10 +1032,6 @@ extern int drm_mode_getblob_ioctl(struct drm_device *dev,
 				  void *data, struct drm_file *file_priv);
 extern int drm_mode_connector_property_set_ioctl(struct drm_device *dev,
 					      void *data, struct drm_file *file_priv);
-extern int drm_mode_hotplug_ioctl(struct drm_device *dev,
-				  void *data, struct drm_file *file_priv);
-extern int drm_mode_replacefb(struct drm_device *dev,
-			      void *data, struct drm_file *file_priv);
 extern int drm_mode_getencoder(struct drm_device *dev,
 			       void *data, struct drm_file *file_priv);
 extern int drm_mode_gamma_get_ioctl(struct drm_device *dev,

commit b21e3afe2357c0f49348a5fb61247012bf8262ec
Author: Ilia Mirkin <imirkin@alum.mit.edu>
Date:   Wed Aug 7 22:34:48 2013 -0400

    drm: use ida to allocate connector ids
    
    This makes it so that reloading a module does not cause all the
    connector ids to change, which are user-visible and sometimes used
    for configuration.
    
    Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 32e0820357e6..45f133228553 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -869,6 +869,8 @@ extern int drm_crtc_init(struct drm_device *dev,
 			 const struct drm_crtc_funcs *funcs);
 extern void drm_crtc_cleanup(struct drm_crtc *crtc);
 
+extern void drm_connector_ida_init(void);
+extern void drm_connector_ida_destroy(void);
 extern int drm_connector_init(struct drm_device *dev,
 			      struct drm_connector *connector,
 			      const struct drm_connector_funcs *funcs,

commit b17df86ece5e674c6f50b9a219067b9a80ea9dd1
Author: Stéphane Marchesin <marcheu@chromium.org>
Date:   Tue Aug 13 11:55:12 2013 -0700

    drm: Remove drm_mode_validate_clocks
    
    This function is unused.
    
    Signed-off-by: Stéphane Marchesin <marcheu@chromium.org>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index fa12a2fa4293..32e0820357e6 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -930,9 +930,6 @@ extern void drm_mode_list_concat(struct list_head *head,
 extern void drm_mode_validate_size(struct drm_device *dev,
 				   struct list_head *mode_list,
 				   int maxX, int maxY, int maxPitch);
-extern void drm_mode_validate_clocks(struct drm_device *dev,
-				     struct list_head *mode_list,
-				     int *min, int *max, int n_ranges);
 extern void drm_mode_prune_invalid(struct drm_device *dev,
 				   struct list_head *mode_list, bool verbose);
 extern void drm_mode_sort(struct list_head *mode_list);

commit d482e5fa299c2cfbb4700143dd766273730e2357
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Jun 28 20:31:34 2013 +1000

    Revert "drm: kms_helper: don't lose hotplug event"
    
    This reverts commit 160954b7bca43da7cd3cfbce310e6df919a8216e.
    
    This was rearming the workqueue with a 0 timeout, causing
    a WARN_ON, and possible loop.
    
    Daniel writes:
    "I've looked a bit into this and I think we need to have a separate
    work struct for recovering these lost hotplug events since the
    continuous self-rearming case is a real risk (e.g. if a connector
    flip-flops all the time). At least I don't see a sane way to block out
    re-arming with the current code in a simple way. So reverting the
    offender seems like the right thing and I'll go back to the drawing
    board for 3.12."
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 663c3ab47752..fa12a2fa4293 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -811,7 +811,6 @@ struct drm_mode_config {
 	/* output poll support */
 	bool poll_enabled;
 	bool poll_running;
-	bool delayed_event;
 	struct delayed_work output_poll_work;
 
 	/* pointers to standard properties */

commit 4c813d4d759c0e6b83bfd73795e9526493556dc2
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jun 20 11:48:52 2013 +1000

    drm: add hotspot support for cursors.
    
    So it looks like for virtual hw cursors on QXL we need to inform
    the "hw" device what the cursor hotspot parameters are. This
    makes sense if you think the host has to draw the cursor and interpret
    clicks from it. However the current modesetting interface doesn't support
    passing the hotspot information from userspace.
    
    This implements a new cursor ioctl, that takes the hotspot info as well,
    userspace can try calling the new interface and if it gets -ENOSYS it means
    its on an older kernel and can just fallback.
    
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 0fd007af8de9..663c3ab47752 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -339,6 +339,9 @@ struct drm_crtc_funcs {
 	/* cursor controls */
 	int (*cursor_set)(struct drm_crtc *crtc, struct drm_file *file_priv,
 			  uint32_t handle, uint32_t width, uint32_t height);
+	int (*cursor_set2)(struct drm_crtc *crtc, struct drm_file *file_priv,
+			   uint32_t handle, uint32_t width, uint32_t height,
+			   int32_t hot_x, int32_t hot_y);
 	int (*cursor_move)(struct drm_crtc *crtc, int x, int y);
 
 	/* Set gamma on the CRTC */
@@ -1018,6 +1021,8 @@ extern int drm_mode_setplane(struct drm_device *dev,
 			       void *data, struct drm_file *file_priv);
 extern int drm_mode_cursor_ioctl(struct drm_device *dev,
 				void *data, struct drm_file *file_priv);
+extern int drm_mode_cursor2_ioctl(struct drm_device *dev,
+				void *data, struct drm_file *file_priv);
 extern int drm_mode_addfb(struct drm_device *dev,
 			  void *data, struct drm_file *file_priv);
 extern int drm_mode_addfb2(struct drm_device *dev,

commit 160954b7bca43da7cd3cfbce310e6df919a8216e
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jun 6 00:17:25 2013 +0200

    drm: kms_helper: don't lose hotplug event
    
    There's a race window (small for hpd, 10s large for polled outputs)
    where userspace could sneak in with an unrelated connnector probe
    ioctl call and eat the hotplug event (since neither the hpd nor the
    poll code see a state change).
    
    To avoid this, check whether the connector state changes in all other
    ->detect calls (in the current helper code that's only probe_single)
    and if that's the case, fire off a hotplug event. Note that we can't
    directly call the hotplug event handler, since that expects that no
    locks are held (due to reentrancy with the fb code to update the kms
    console).
    
    Also, this requires that drivers using the probe_single helper
    function set up the poll work. All current drivers do that already,
    and with the reworked hpd handling there'll be no downside to
    unconditionally setting up the poll work any more.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b9ddd3d42acf..0fd007af8de9 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -808,6 +808,7 @@ struct drm_mode_config {
 	/* output poll support */
 	bool poll_enabled;
 	bool poll_running;
+	bool delayed_event;
 	struct delayed_work output_poll_work;
 
 	/* pointers to standard properties */

commit 5cef29aa5227e6347145940a7bccde92fd9a1afa
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sat Jun 15 00:13:16 2013 +0200

    drm: fix fb leak in setcrtc
    
    Drivers are allowed (actually have to) disable unrelated crtcs in
    their ->set_config callback (when we steal all the connectors from
    that crtc). If they do that they'll clear crtc->fb to NULL.
    
    Which results in a refcount leak, since the drm core is keeping track
    of that reference.
    
    To fix this track the old fb of all crtcs and adjust references for
    all of them. Of course, since we only hold an additional reference for
    the fb for the current crtc we need to increase refcounts before we
    drop the old one.
    
    This approach has the benefit that it inches us a bit closer to an
    atomic modeset world, where we want to update the config of all crtcs
    in one step.
    
    This regression has been introduce in the framebuffer refcount
    conversion, specifically in
    
    commit b0d1232589df5575c5971224ac4cb30e7e525884
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Tue Dec 11 01:07:12 2012 +0100
    
        drm: refcounting for crtc framebuffers
    
    Reported-by: Russell King <linux@arm.linux.org.uk>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: stable@vger.kernel.org
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 9779ea11e63d..b9ddd3d42acf 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -409,6 +409,10 @@ struct drm_crtc {
 	/* framebuffer the connector is currently bound to */
 	struct drm_framebuffer *fb;
 
+	/* Temporary tracking of the old fb while a modeset is ongoing. Used
+	 * by drm_mode_set_config_internal to implement correct refcounting. */
+	struct drm_framebuffer *old_fb;
+
 	bool enabled;
 
 	/* Requested mode from modesetting. */

commit 778ad903f951a45a309a5a70dbdcf38eccabeaf0
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Jun 3 16:11:42 2013 +0300

    drm: Remove some unused stuff from drm_plane
    
    There's a bunch of unused members inside drm_plane, bloating the size of
    the structure needlessly. Eliminate them.
    
    v2: Remove all of it from kernel-doc too
    
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Dave Airlie <airlied@gmail.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index da137e732ac2..9779ea11e63d 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -654,11 +654,7 @@ struct drm_plane_funcs {
  * @format_count: number of formats supported
  * @crtc: currently bound CRTC
  * @fb: currently bound fb
- * @gamma_size: size of gamma table
- * @gamma_store: gamma correction table
- * @enabled: enabled flag
  * @funcs: helper functions
- * @helper_private: storage for drver layer
  * @properties: property tracking for this plane
  */
 struct drm_plane {
@@ -674,14 +670,7 @@ struct drm_plane {
 	struct drm_crtc *crtc;
 	struct drm_framebuffer *fb;
 
-	/* CRTC gamma size for reporting to userspace */
-	uint32_t gamma_size;
-	uint16_t *gamma_store;
-
-	bool enabled;
-
 	const struct drm_plane_funcs *funcs;
-	void *helper_private;
 
 	struct drm_object_properties properties;
 };

commit 9125e6186822b2698da17690416cd1b55c030115
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Jun 3 16:10:40 2013 +0300

    drm: Add drm_plane_force_disable()
    
    drm_plane_force_disable() will forcibly disable the plane even if user
    had previously requested the plane to be enabled.
    
    This can be used to force planes to be off when restoring the fbdev
    mode.
    
    The code was simply pulled from drm_framebuffer_remove(), which now
    calls the new function as well.
    
    v2: Check plane->fb in drm_plane_force_disable(), drop bogus comment
        about disabling crtc
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Dave Airlie <airlied@gmail.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 53c33e28a2f7..da137e732ac2 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -894,6 +894,7 @@ extern int drm_plane_init(struct drm_device *dev,
 			  const uint32_t *formats, uint32_t format_count,
 			  bool priv);
 extern void drm_plane_cleanup(struct drm_plane *plane);
+extern void drm_plane_force_disable(struct drm_plane *plane);
 
 extern void drm_encoder_cleanup(struct drm_encoder *encoder);
 

commit d20d3174806ef6589cb912a488657d21fcd7ece2
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Jun 7 15:43:07 2013 +0000

    drm: Constify the pretty-print functions
    
    The structures and strings involved with various pretty-print functions
    aren't meant to be modified, so make them all const. The exception is
    drm_connector_enum_list which does get modified in drm_connector_init().
    
    While at it move the drm_get_connector_status_name() prototype from
    drmP.h to drm_crtc.h where it belongs.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 2cbbfd44c6df..53c33e28a2f7 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -897,12 +897,13 @@ extern void drm_plane_cleanup(struct drm_plane *plane);
 
 extern void drm_encoder_cleanup(struct drm_encoder *encoder);
 
-extern char *drm_get_connector_name(struct drm_connector *connector);
-extern char *drm_get_dpms_name(int val);
-extern char *drm_get_dvi_i_subconnector_name(int val);
-extern char *drm_get_dvi_i_select_name(int val);
-extern char *drm_get_tv_subconnector_name(int val);
-extern char *drm_get_tv_select_name(int val);
+extern const char *drm_get_connector_name(const struct drm_connector *connector);
+extern const char *drm_get_connector_status_name(enum drm_connector_status status);
+extern const char *drm_get_dpms_name(int val);
+extern const char *drm_get_dvi_i_subconnector_name(int val);
+extern const char *drm_get_dvi_i_select_name(int val);
+extern const char *drm_get_tv_subconnector_name(int val);
+extern const char *drm_get_tv_select_name(int val);
 extern void drm_fb_release(struct drm_file *file_priv);
 extern int drm_mode_group_init_legacy_group(struct drm_device *dev, struct drm_mode_group *group);
 extern bool drm_probe_ddc(struct i2c_adapter *adapter);
@@ -994,7 +995,7 @@ extern int drm_mode_create_tv_properties(struct drm_device *dev, int num_formats
 extern int drm_mode_create_scaling_mode_property(struct drm_device *dev);
 extern int drm_mode_create_dithering_property(struct drm_device *dev);
 extern int drm_mode_create_dirty_info_property(struct drm_device *dev);
-extern char *drm_get_encoder_name(struct drm_encoder *encoder);
+extern const char *drm_get_encoder_name(const struct drm_encoder *encoder);
 
 extern int drm_mode_connector_attach_encoder(struct drm_connector *connector,
 					     struct drm_encoder *encoder);
@@ -1094,6 +1095,6 @@ extern int drm_format_num_planes(uint32_t format);
 extern int drm_format_plane_cpp(uint32_t format, int plane);
 extern int drm_format_horz_chroma_subsampling(uint32_t format);
 extern int drm_format_vert_chroma_subsampling(uint32_t format);
-extern char *drm_get_format_name(uint32_t format);
+extern const char *drm_get_format_name(uint32_t format);
 
 #endif /* __DRM_CRTC_H__ */

commit 6ba6d03e69125ef42a63e90d45e49c659ea3c34f
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Jun 10 11:15:10 2013 +0300

    drm: Print pretty names for pixel formats
    
    Rather than just printing the pixel format as a hex number, decode the
    fourcc into human readable form, and also decode the LE vs. BE flag.
    
    Keep printing the raw hex number too in case it contains non-printable
    characters.
    
    Some examples what the new drm_get_format_name() produces:
    DRM_FORMAT_XRGB8888: "XR24 little-endian (0x34325258)"
    DRM_FORMAT_YUYV: "YUYV little-endian (0x56595559)"
    DRM_FORMAT_RGB565|DRM_FORMAT_BIG_ENDIAN: "RG16 big-endian (0xb6314752)"
    Unprintable characters: "D??? big-endian (0xff7f0244)"
    
    v2: Fix patch author
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index adb3f9b625f6..2cbbfd44c6df 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1094,5 +1094,6 @@ extern int drm_format_num_planes(uint32_t format);
 extern int drm_format_plane_cpp(uint32_t format, int plane);
 extern int drm_format_horz_chroma_subsampling(uint32_t format);
 extern int drm_format_vert_chroma_subsampling(uint32_t format);
+extern char *drm_get_format_name(uint32_t format);
 
 #endif /* __DRM_CRTC_H__ */

commit c55b6b3da25aa3af36ec51a13a4ed15fef0d7a73
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Apr 26 17:40:28 2013 +0300

    drm: Kill user_modes list and the associated ioctls
    
    There is no way to use modes added to the user_modes list. We never
    look at the contents of said list in the kernel, and the only operations
    userspace can do are attach and detach. So the only "benefit" of this
    interface is wasting kernel memory.
    
    Fortunately it seems no real user space application ever used these
    ioctls. So just kill them.
    
    Also remove the prototypes for the non-existing drm_mode_addmode_ioctl()
    and drm_mode_rmmode_ioctl() functions.
    
    v2: Use drm_noop instead of completely removing the ioctls
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index cf474498cee0..adb3f9b625f6 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -554,7 +554,6 @@ enum drm_connector_force {
  * @probed_modes: list of modes derived directly from the display
  * @display_info: information about attached display (e.g. from EDID)
  * @funcs: connector control functions
- * @user_modes: user added mode list
  * @edid_blob_ptr: DRM property containing EDID if present
  * @properties: property tracking for this connector
  * @polled: a %DRM_CONNECTOR_POLL_<foo> value for core driven polling
@@ -598,7 +597,6 @@ struct drm_connector {
 	struct drm_display_info display_info;
 	const struct drm_connector_funcs *funcs;
 
-	struct list_head user_modes;
 	struct drm_property_blob *edid_blob_ptr;
 	struct drm_object_properties properties;
 
@@ -927,11 +925,6 @@ extern int drm_mode_width(const struct drm_display_mode *mode);
 extern int drm_mode_height(const struct drm_display_mode *mode);
 
 /* for us by fb module */
-extern int drm_mode_attachmode_crtc(struct drm_device *dev,
-				    struct drm_crtc *crtc,
-				    const struct drm_display_mode *mode);
-extern int drm_mode_detachmode_crtc(struct drm_device *dev, struct drm_display_mode *mode);
-
 extern struct drm_display_mode *drm_mode_create(struct drm_device *dev);
 extern void drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode);
 extern void drm_mode_list_concat(struct list_head *head,
@@ -1040,14 +1033,6 @@ extern int drm_mode_getfb(struct drm_device *dev,
 			  void *data, struct drm_file *file_priv);
 extern int drm_mode_dirtyfb_ioctl(struct drm_device *dev,
 				  void *data, struct drm_file *file_priv);
-extern int drm_mode_addmode_ioctl(struct drm_device *dev,
-				  void *data, struct drm_file *file_priv);
-extern int drm_mode_rmmode_ioctl(struct drm_device *dev,
-				 void *data, struct drm_file *file_priv);
-extern int drm_mode_attachmode_ioctl(struct drm_device *dev,
-				     void *data, struct drm_file *file_priv);
-extern int drm_mode_detachmode_ioctl(struct drm_device *dev,
-				     void *data, struct drm_file *file_priv);
 
 extern int drm_mode_getproperty_ioctl(struct drm_device *dev,
 				      void *data, struct drm_file *file_priv);

commit ea9cbb063ce7509d98febdc756e77d6b69a10b56
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Apr 25 20:09:20 2013 +0300

    drm: Silence some sparse warnings
    
    drivers/gpu/drm/drm_pci.c:155:5: warning: symbol 'drm_pci_set_busid' was not declared. Should it be static?
    drivers/gpu/drm/drm_pci.c:197:5: warning: symbol 'drm_pci_set_unique' was not declared. Should it be static?
    drivers/gpu/drm/drm_pci.c:269:5: warning: symbol 'drm_pci_agp_init' was not declared. Should it be static?
    
    drivers/gpu/drm/drm_crtc.c:181:1: warning: symbol 'drm_get_dirty_info_name' was not declared. Should it be static?
    drivers/gpu/drm/drm_crtc.c:1123:5: warning: symbol 'drm_mode_group_init' was not declared. Should it be static?
    
    drivers/gpu/drm/drm_modes.c:918:6: warning: symbol 'drm_mode_validate_clocks' was not declared. Should it be static?
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 836438dfb331..cf474498cee0 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -939,6 +939,9 @@ extern void drm_mode_list_concat(struct list_head *head,
 extern void drm_mode_validate_size(struct drm_device *dev,
 				   struct list_head *mode_list,
 				   int maxX, int maxY, int maxPitch);
+extern void drm_mode_validate_clocks(struct drm_device *dev,
+				     struct list_head *mode_list,
+				     int *min, int *max, int n_ranges);
 extern void drm_mode_prune_invalid(struct drm_device *dev,
 				   struct list_head *mode_list, bool verbose);
 extern void drm_mode_sort(struct list_head *mode_list);

commit 8cc3f23caf4066880f54f636beb3e30b4d383eca
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Apr 24 19:07:16 2013 +0300

    drm: Add drm_mode_equal_no_clocks()
    
    drm_mode_equal_no_clocks() is like drm_mode_equal() except it doesn't
    compare the clock or vrefresh values. drm_mode_equal() is now
    implemented by first doing the clock checks, and then calling
    drm_mode_equal_no_clocks().
    
    v2: Add missing EXPORT_SYMBOL()
    
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b85575bb82e6..836438dfb331 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -922,6 +922,7 @@ extern void drm_mode_config_reset(struct drm_device *dev);
 extern void drm_mode_config_cleanup(struct drm_device *dev);
 extern void drm_mode_set_name(struct drm_display_mode *mode);
 extern bool drm_mode_equal(const struct drm_display_mode *mode1, const struct drm_display_mode *mode2);
+extern bool drm_mode_equal_no_clocks(const struct drm_display_mode *mode1, const struct drm_display_mode *mode2);
 extern int drm_mode_width(const struct drm_display_mode *mode);
 extern int drm_mode_height(const struct drm_display_mode *mode);
 

commit 67af116e4ac0ebbb3d7849a1d3e2344e289dd76d
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Apr 24 19:07:15 2013 +0300

    drm: Remove explicit vrefresh initialization from DRM_MODE()
    
    No need to zero initialize .vrefresh in DRM_MODE() since it's using
    desgignated initializers.
    
    This will also avoid some duplicate initialization warnings later.
    
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 8c7846bd74f4..b85575bb82e6 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -120,7 +120,7 @@ enum drm_mode_status {
 	.hdisplay = (hd), .hsync_start = (hss), .hsync_end = (hse), \
 	.htotal = (ht), .hskew = (hsk), .vdisplay = (vd), \
 	.vsync_start = (vss), .vsync_end = (vse), .vtotal = (vt), \
-	.vscan = (vs), .flags = (f), .vrefresh = 0, \
+	.vscan = (vs), .flags = (f), \
 	.base.type = DRM_MODE_OBJECT_MODE
 
 #define CRTC_INTERLACE_HALVE_V 0x1 /* halve V values for interlacing */

commit 715f59cc2391cb4e28a4d464a0564a60a00ecca4
Author: Christopher Harvey <charvey@matrox.com>
Date:   Fri Apr 5 15:28:32 2013 +0000

    drm: Misc comment cleanup
    
    Signed-off-by: Christopher Harvey <charvey@matrox.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index e3e0d651c6ca..8c7846bd74f4 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -310,7 +310,7 @@ struct drm_plane;
  * drm_crtc_funcs - control CRTCs for a given device
  * @save: save CRTC state
  * @restore: restore CRTC state
- * @reset: reset CRTC after state has been invalidate (e.g. resume)
+ * @reset: reset CRTC after state has been invalidated (e.g. resume)
  * @cursor_set: setup the cursor
  * @cursor_move: move the cursor
  * @gamma_set: specify color ramp for CRTC

commit 13bcf01b33e6e19a7fe7ff396f9ed02803e225ec
Author: Christopher Harvey <charvey@matrox.com>
Date:   Thu Mar 7 10:42:25 2013 -0500

    drm: Documentation typo fixes
    
    Signed-off-by: Christopher Harvey <charvey@matrox.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 8839b3a24660..e3e0d651c6ca 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -443,12 +443,12 @@ struct drm_crtc {
  * @dpms: set power state (see drm_crtc_funcs above)
  * @save: save connector state
  * @restore: restore connector state
- * @reset: reset connector after state has been invalidate (e.g. resume)
+ * @reset: reset connector after state has been invalidated (e.g. resume)
  * @detect: is this connector active?
  * @fill_modes: fill mode list for this connector
- * @set_property: property for this connector may need update
+ * @set_property: property for this connector may need an update
  * @destroy: make object go away
- * @force: notify the driver the connector is forced on
+ * @force: notify the driver that the connector is forced on
  *
  * Each CRTC may have one or more connectors attached to it.  The functions
  * below allow the core DRM code to control connectors, enumerate available modes,

commit 595887eb90b7e74a3e276b8f17d35236d85b0d37
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Wed Nov 21 15:00:47 2012 +0100

    drm: Add some missing forward declarations
    
    The drm_file and drm_clip_rect structures are used throughout the file
    but they are never declared nor pulled in through an include. Add
    forward declarations to make them available.
    
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 77627184775c..8839b3a24660 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -38,7 +38,8 @@ struct drm_device;
 struct drm_mode_set;
 struct drm_framebuffer;
 struct drm_object_properties;
-
+struct drm_file;
+struct drm_clip_rect;
 
 #define DRM_MODE_OBJECT_CRTC 0xcccccccc
 #define DRM_MODE_OBJECT_CONNECTOR 0xc0c0c0c0

commit 18316c8c39a85c8b6e3db0a150b1bee5b6c4c053
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Thu Dec 20 15:41:44 2012 +0100

    drm: Remove duplicate drm_mode_cea_vic()
    
    The same function had already been merged with a different name. Remove
    the duplicate one but reuse some of its kerneldoc fragments for the
    existing implementation.
    
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 8b7762728639..77627184775c 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1061,7 +1061,7 @@ extern int drm_mode_gamma_get_ioctl(struct drm_device *dev,
 extern int drm_mode_gamma_set_ioctl(struct drm_device *dev,
 				    void *data, struct drm_file *file_priv);
 extern u8 *drm_find_cea_extension(struct edid *edid);
-extern u8 drm_match_cea_mode(struct drm_display_mode *to_match);
+extern u8 drm_match_cea_mode(const struct drm_display_mode *to_match);
 extern bool drm_detect_hdmi_monitor(struct edid *edid);
 extern bool drm_detect_monitor_audio(struct edid *edid);
 extern bool drm_rgb_quant_range_selectable(struct edid *edid);
@@ -1079,7 +1079,6 @@ extern struct drm_display_mode *drm_gtf_mode_complex(struct drm_device *dev,
 				int GTF_2C, int GTF_K, int GTF_2J);
 extern int drm_add_modes_noedid(struct drm_connector *connector,
 				int hdisplay, int vdisplay);
-extern uint8_t drm_mode_cea_vic(const struct drm_display_mode *mode);
 
 extern int drm_edid_header_is_valid(const u8 *raw_edid);
 extern bool drm_edid_block_valid(u8 *raw_edid, int block, bool print_bad_edid);

commit 6aed8ec3f76a22217c9ae183d32b1aa990bed069
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sun Jan 20 17:32:21 2013 +0100

    drm: review locking for drm_fb_helper_restore_fbdev_mode
    
    ... it's required. Fix up exynos and the cma helper, and add a
    corresponding WARN_ON to drm_fb_helper_restore_fbdev_mode.
    
    Note that tegra calls the fbdev cma helper restore function also from
    it's driver-load callback. Which is a bit against current practice,
    since usually the call is only from ->lastclose, and initial setup is
    done by drm_fb_helper_initial_config.
    
    Also add the relevant drm DocBook entry.
    
    v2: Add promised WARN to restore_fbdev_mode.
    
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index e90c8dcc028d..8b7762728639 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -867,6 +867,7 @@ struct drm_prop_enum_list {
 
 extern void drm_modeset_lock_all(struct drm_device *dev);
 extern void drm_modeset_unlock_all(struct drm_device *dev);
+extern void drm_warn_on_modeset_not_all_locked(struct drm_device *dev);
 
 extern int drm_crtc_init(struct drm_device *dev,
 			 struct drm_crtc *crtc,

commit cd17ef4114ad5c514b17e6a0bb02a309ab90b692
Merge: 67c964000236 7d37beaaf3db
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Feb 8 11:08:10 2013 +1000

    Merge tag 'drm-intel-next-2013-02-01' of git://people.freedesktop.org/~danvet/drm-intel into drm-next
    
    Daniel writes:
    "Probably the last feature pull for 3.9, there's some fixes outstanding
    thought that I'd like to sneak in. And maybe 3.8 takes a bit longer ...
    Anyway, highlights of this pull:
    - Kill the horrible IS_DISPLAYREG hack to handle the mmio offset movements
      on vlv, big thanks to Ville.
    - Dynamic power well support for Haswell, shaves away a bit when only
      using the eDP port on pipe A (Paulo). Plus unclaimed register fixes
      uncovered by this.
    - Clarifications of the gpu hang/reset state transitions, hopefully fixing
      a few spurious -EIO deaths in userspace.
    - Haswell ELD fixes.
    - Some more (pp)gtt cleanups from Ben.
    - A few smaller things all over.
    
    Plus all the stuff from the previous rather small pull request:
    - Broadcast RBG improvements and reduced color range fixes from Ville.
    - Ben is on a "kill legacy gtt code for good" spree, first pile of patches
      included.
    - No-relocs and bo lut improvements for faster execbuf from Chris.
    - Some refactorings from Imre."
    
    * tag 'drm-intel-next-2013-02-01' of git://people.freedesktop.org/~danvet/drm-intel: (101 commits)
      GPU/i915: Fix acpi_bus_get_device() check in drivers/gpu/drm/i915/intel_opregion.c
      drm/i915: Set the SR01 "screen off" bit in i915_redisable_vga() too
      drm/i915: Kill IS_DISPLAYREG()
      drm/i915: Introduce i915_vgacntrl_reg()
      drm/i915: gen6_gmch_remove can be static
      drm/i915: dynamic Haswell display power well support
      drm/i915: check the power down well on assert_pipe()
      drm/i915: don't send DP "idle" pattern before "normal" on HSW PORT_A
      drm/i915: don't run hsw power well code on !hsw
      drm/i915: kill cargo-culted locking from power well code
      drm/i915: Only run idle processing from i915_gem_retire_requests_worker
      drm/i915: Fix CAGF for HSW
      drm/i915: Reclaim GTT space for failed PPGTT
      drm/i915: remove intel_gtt structure
      drm/i915: Add probe and remove to the gtt ops
      drm/i915: extract hw ppgtt setup/cleanup code
      drm/i915: pte_encode is gen6+
      drm/i915: vfuncs for ppgtt
      drm/i915: vfuncs for gtt_clear_range/insert_entries
      drm/i915: Error state should print /sys/kernel/debug
      ...

commit 362063619cf67c2c2fc2eb90951b2623cbb69a7c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Dec 10 20:42:17 2012 +0100

    drm: revamp framebuffer cleanup interfaces
    
    We have two classes of framebuffer
    - Created by the driver (atm only for fbdev), and the driver holds
      onto the last reference count until destruction.
    - Created by userspace and associated with a given fd. These
      framebuffers will be reaped when their assoiciated fb is closed.
    
    Now these two cases are set up differently, the framebuffers are on
    different lists and hence destruction needs to clean up different
    things. Also, for userspace framebuffers we remove them from any
    current usage, whereas for internal framebuffers it is assumed that
    the driver has done this already.
    
    Long story short, we need two different ways to cleanup such drivers.
    Three functions are involved in total:
    - drm_framebuffer_remove: Convenience function which removes the fb
      from all active usage and then drops the passed-in reference.
    - drm_framebuffer_unregister_private: Will remove driver-private
      framebuffers from relevant lists and drop the corresponding
      references. Should be called for driver-private framebuffers before
      dropping the last reference (or like for a lot of the drivers where
      the fbdev is embedded someplace else, before doing the cleanup
      manually).
    - drm_framebuffer_cleanup: Final cleanup for both classes of fbs,
      should be called by the driver's ->destroy callback once the last
      reference is gone.
    
    This patch just rolls out the new interfaces and updates all drivers
    (by adding calls to drm_framebuffer_unregister_private at all the
    right places)- no functional changes yet. Follow-on patches will move
    drm core code around and update the lifetime management for
    framebuffers, so that we are no longer required to keep framebuffers
    alive by locking mode_config.mutex.
    
    I've also updated the kerneldoc already.
    
    vmwgfx seems to again be a bit special, at least I haven't figured out
    how the fbdev support in that driver works. It smells like it's
    external though.
    
    v2: The i915 driver creates another private framebuffer in the
    load-detect code. Adjust its cleanup code, too.
    
    Reviewed-by: Rob Clark <rob@ti.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 7dc1b31059d4..66b2732f175a 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -964,6 +964,7 @@ extern void drm_framebuffer_unreference(struct drm_framebuffer *fb);
 extern void drm_framebuffer_reference(struct drm_framebuffer *fb);
 extern void drm_framebuffer_remove(struct drm_framebuffer *fb);
 extern void drm_framebuffer_cleanup(struct drm_framebuffer *fb);
+extern void drm_framebuffer_unregister_private(struct drm_framebuffer *fb);
 extern int drmfb_probe(struct drm_device *dev, struct drm_crtc *crtc);
 extern int drmfb_remove(struct drm_device *dev, struct drm_framebuffer *fb);
 extern void drm_crtc_probe_connector_modes(struct drm_device *dev, int maxX, int maxY);

commit 786b99ed13223d8ac58a937dd348aead45eb8191
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sun Dec 2 21:53:40 2012 +0100

    drm: create drm_framebuffer_lookup
    
    And replace all fb lookups with it. Also add a WARN to
    drm_mode_object_find since that is now no longer the blessed interface
    to look up an fb. And add kerneldoc to both functions.
    
    This only updates all callsites, but immediately drops the acquired
    refence again. Hence all callers still rely on the fact that a mode fb
    can't disappear while they're holding the struct mutex. Subsequent
    patches will instate proper use of refcounts, and then rework the rmfb
    and unref code to no longer serialize fb destruction with the
    mode_config lock. We don't want that since otherwise a compositor
    might end up stalling for a few frames in rmfb.
    
    v2: Don't use kref_get_unless_zero - Greg KH doesn't like that kind of
    interface.
    
    Reviewed-by: Rob Clark <rob@ti.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c35a807d7e5c..7dc1b31059d4 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -958,6 +958,8 @@ extern void drm_framebuffer_set_object(struct drm_device *dev,
 extern int drm_framebuffer_init(struct drm_device *dev,
 				struct drm_framebuffer *fb,
 				const struct drm_framebuffer_funcs *funcs);
+extern struct drm_framebuffer *drm_framebuffer_lookup(struct drm_device *dev,
+						      uint32_t id);
 extern void drm_framebuffer_unreference(struct drm_framebuffer *fb);
 extern void drm_framebuffer_reference(struct drm_framebuffer *fb);
 extern void drm_framebuffer_remove(struct drm_framebuffer *fb);

commit 4b096ac10da0b63f09bd123b86fed8deb80646ce
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Dec 10 21:19:18 2012 +0100

    drm: revamp locking around fb creation/destruction
    
    Well, at least step 1. The goal here is that framebuffer objects can
    survive outside of the mode_config lock, with just a reference held
    as protection. The first step to get there is to introduce a special
    fb_lock which protects fb lookup, creation and destruction, to make
    them appear atomic.
    
    This new fb_lock can nest within the mode_config lock. But the idea is
    (once the reference counting part is completed) that we only quickly
    take that fb_lock to lookup a framebuffer and grab a reference,
    without any other locks involved.
    
    vmwgfx is the only driver which does framebuffer lookups itself, also
    wrap those calls to drm_mode_object_find with the new lock.
    
    Also protect the fb_list walking in i915 and omapdrm with the new lock.
    
    As a slight complication there's also the list of user-created fbs
    attached to the file private. The problem now is that at fclose() time
    we need to walk that list, eventually do a modeset call to remove the
    fb from active usage (and are required to be able to take the
    mode_config lock), but in the end we need to grab the new fb_lock to
    remove the fb from the list. The easiest solution is to add another
    mutex to protect this per-file list.
    
    Currently that new fbs_lock nests within the modeset locks and so
    appears redudant. But later patches will switch around this sequence
    so that taking the modeset locks in the fb destruction path is
    optional in the fastpath. Ultimately the goal is that addfb and rmfb
    do not require the mode_config lock, since otherwise they have the
    potential to introduce stalls in the pageflip sequence of a compositor
    (if the compositor e.g. switches to a fullscreen client or if it
    enables a plane). But that requires a few more steps and hoops to jump
    through.
    
    Note that framebuffer creation/destruction is now double-protected -
    once by the fb_lock and in parts by the idr_lock. The later would be
    unnecessariy if framebuffers would have their own idr allocator. But
    that's material for another patch (series).
    
    v2: Properly initialize the fb->filp_head list in _init, otherwise the
    newly added WARN to check whether the fb isn't on a fpriv list any
    more will fail for driver-private objects.
    
    v3: Fixup two error-case unlock bugs spotted by Richard Wilbur.
    
    Reviewed-by: Rob Clark <rob@ti.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c89b1161f0be..c35a807d7e5c 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -254,6 +254,10 @@ struct drm_framebuffer {
 	 * userspace perspective.
 	 */
 	struct kref refcount;
+	/*
+	 * Place on the dev->mode_config.fb_list, access protected by
+	 * dev->mode_config.fb_lock.
+	 */
 	struct list_head head;
 	struct drm_mode_object base;
 	const struct drm_framebuffer_funcs *funcs;
@@ -780,8 +784,18 @@ struct drm_mode_config {
 	struct mutex idr_mutex; /* for IDR management */
 	struct idr crtc_idr; /* use this idr for all IDs, fb, crtc, connector, modes - just makes life easier */
 	/* this is limited to one for now */
+
+
+	/**
+	 * fb_lock - mutex to protect fb state
+	 *
+	 * Besides the global fb list his also protects the fbs list in the
+	 * file_priv
+	 */
+	struct mutex fb_lock;
 	int num_fb;
 	struct list_head fb_list;
+
 	int num_connector;
 	struct list_head connector_list;
 	int num_encoder;

commit 29494c174dc4793ebd236aa522a2a1ed73b7180e
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sun Dec 2 02:18:25 2012 +0100

    drm: add per-crtc locks
    
    *drumroll*
    
    The basic idea is to protect per-crtc state which can change without
    touching the output configuration with separate mutexes, i.e.  all the
    input side state to a crtc like framebuffers, cursor settings or plane
    configuration. Holding such a crtc lock gives a read-lock on all the
    other crtc state which can be changed by e.g. a modeset.
    
    All non-crtc state is still protected by the mode_config mutex.
    Callers that need to change modeset state of a crtc (e.g. dpms or
    set_mode) need to grab both the mode_config lock and nested within any
    crtc locks.
    
    Note that since there can only ever be one holder of the mode_config
    lock we can grab the subordinate crtc locks in any order (if we need
    to grab more than one of them). Lockdep can handle such nesting with
    the mutex_lock_nest_lock call correctly.
    
    With this functions that only touch connectors/encoders but not crtcs
    only need to take the mode_config lock. The biggest such case is the
    output probing, which means that we can now pageflip and move cursors
    while the output probe code is reading an edid.
    
    Most cases neatly fall into the three buckets:
    - Only touches connectors and similar output state and so only needs
      the mode_config lock.
    - Touches the global configuration and so needs all locks.
    - Only touches the crtc input side and so only needs the crtc lock.
    
    But a few cases that need special consideration:
    
    - Load detection which requires a crtc. The mode_config lock already
      prevents a modeset change, so we can use any unused crtc as we like
      to do load detection. The only thing to consider is that such
      temporary state changes don't leak out to userspace through ioctls
      that only take the crtc look (like a pageflip). Hence the load
      detect code needs to grab the crtc of any output pipes it touches
      (but only if it touches state used by the pageflip or cursor
      ioctls).
    
    - Atomic pageflip when moving planes. The first case is sane hw, where
      planes have a fixed association with crtcs - nothing needs to be
      done there. More insane^Wflexible hw needs to have plane->crtc
      mapping which is separately protect with a lock that nests within
      the crtc lock. If the plane is unused we can just assign it to the
      current crtc and continue. But if a plane is already in use by
      another crtc we can't just reassign it.
    
      Two solution present themselves: Either go back to a slow-path which
      takes all modeset locks, potentially incure quite a hefty delay. Or
      simply disallowing such changes in one atomic pageflip - in general
      the vblanks of two crtcs are not synced, so there's no sane way to
      atomically flip such plane changes accross more than one crtc. I'd
      heavily favour the later approach, going as far as mandating it as
      part of the ABI of such a new a nuclear pageflip.
    
      And if we _really_ want such semantics, we can always get them by
      introducing another pageflip mutex between the mode_config.mutex and
      the individual crtc locks. Pageflips crossing more than one crtc
      would then need to take that lock first, to lock out concurrent
      multi-crtc pageflips.
    
    - Optimized global modeset operations: We could just take the
      mode_config lock and then lazily lock all crtc which are affected by
      a modeset operation. This has the advantage that pageflip could
      continue unhampered on unaffected crtc. But if e.g. global resources
      like plls need to be reassigned and so affect unrelated crtcs we can
      still do that - nested locking works in any order.
    
    This patch just adds the locks and takes them in drm_modeset_lock_all,
    no real locking changes yet.
    
    v2: Need to initialize the new lock in crtc_init and lock it righ
    away, for otherwise the modeset_unlock_all below will try to unlock a
    not-locked mutex.
    
    Reviewed-by: Rob Clark <rob@ti.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 9f0524d507f0..c89b1161f0be 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -390,6 +390,15 @@ struct drm_crtc {
 	struct drm_device *dev;
 	struct list_head head;
 
+	/**
+	 * crtc mutex
+	 *
+	 * This provides a read lock for the overall crtc state (mode, dpms
+	 * state, ...) and a write lock for everything which can be update
+	 * without a full modeset (fb, cursor data, ...)
+	 */
+	struct mutex mutex;
+
 	struct drm_mode_object base;
 
 	/* framebuffer the connector is currently bound to */

commit 848499032504b1defdebdcf930aa70bd01a45ac1
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sun Dec 2 00:28:11 2012 +0100

    drm: add drm_modeset_lock|unlock_all
    
    This is the first step towards introducing the new modeset locking
    scheme. The plan is to put helper functions into place at all the
    right places step-by-step, so that the final patch to switch on the
    new locking scheme doesn't need to touch every single driver.
    
    This helper here will serve as the shotgun solutions for all places
    where a more fine-grained locking isn't (yet) implemented.
    
    v2: Fixup kerneldoc for unlock_all.
    
    Reviewed-by: Rob Clark <rob@ti.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 665289a68cca..9f0524d507f0 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -842,6 +842,9 @@ struct drm_prop_enum_list {
 	char *name;
 };
 
+extern void drm_modeset_lock_all(struct drm_device *dev);
+extern void drm_modeset_unlock_all(struct drm_device *dev);
+
 extern int drm_crtc_init(struct drm_device *dev,
 			 struct drm_crtc *crtc,
 			 const struct drm_crtc_funcs *funcs);

commit 2d13b6796e420ed00389b7399a5d5ac7b1fed436
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Dec 11 13:47:23 2012 +0100

    drm: encapsulate crtc->set_config calls
    
    With refcounting we need to adjust framebuffer refcounts at each
    callsite - much easier to do if they all call the same little helper
    function.
    
    Reviewed-by: Rob Clark <rob@ti.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 00d78b5161c0..665289a68cca 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -985,6 +985,7 @@ extern int drm_mode_getcrtc(struct drm_device *dev,
 			    void *data, struct drm_file *file_priv);
 extern int drm_mode_getconnector(struct drm_device *dev,
 			      void *data, struct drm_file *file_priv);
+extern int drm_mode_set_config_internal(struct drm_mode_set *set);
 extern int drm_mode_setcrtc(struct drm_device *dev,
 			    void *data, struct drm_file *file_priv);
 extern int drm_mode_getplane(struct drm_device *dev,

commit b1edd6a6ecd436af33f210a5c75e0249466fd200
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Jan 17 16:31:30 2013 +0200

    drm/edid: Add drm_rgb_quant_range_selectable()
    
    drm_rgb_quant_range_selectable() will report whether the monitor
    claims to support for RGB quantization range selection.
    
    The information can be found in the CEA Video capability block.
    
    v2: s/quantzation/quantization/ in the comment
    
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Acked-by: David Airlie <airlied@linux.ie>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 00d78b5161c0..30892dc9376e 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1033,6 +1033,7 @@ extern u8 *drm_find_cea_extension(struct edid *edid);
 extern u8 drm_match_cea_mode(struct drm_display_mode *to_match);
 extern bool drm_detect_hdmi_monitor(struct edid *edid);
 extern bool drm_detect_monitor_audio(struct edid *edid);
+extern bool drm_rgb_quant_range_selectable(struct edid *edid);
 extern int drm_mode_page_flip_ioctl(struct drm_device *dev,
 				    void *data, struct drm_file *file_priv);
 extern struct drm_display_mode *drm_cvt_mode(struct drm_device *dev,

commit 55bde6b1442fed8af67b92d21acce67db454c9f9
Merge: 2f3f24061c5c 20652097dadd
Author: Dave Airlie <airlied@redhat.com>
Date:   Sun Dec 16 06:05:03 2012 +0000

    Merge branch 'drm-intel-fixes' of git://people.freedesktop.org/~danvet/drm-intel into drm-next
    
    Daniel writes:
    A few leftover fixes for 3.8:
    - VIC support for hdmi infoframes with the associated drm helper, fixes
      some black TVs (Paulo Zanoni)
    - Modeset state check (and fixup if the BIOS messed with the hw) for
      lid-open. modeset-rework fallout. Somehow the original reporter went
      awol, so this stalled for way too long until we've found a new
      victim^Wreporter with broken BIOS.
    - seqno wrap fixes from Mika and Chris.
    - Some minor fixes all over from various people.
    - Another race fix in the pageflip vs. unpin code from Chris.
    - hsw vga resume support and a few more fdi link fixes (only used for vga
      on hsw) from Paulo.
    - Regression fix for DMAR from Zhenyu Wang - I've scavenged memory from my
      DMAR for a while and it broke right away :(
    - Regression fix from Takashi Iwai for ivb lvds - some w/a needs to be
      (partially) moved back into place. Note that these are regressions in
      -next.
    - One more fix for ivb 3 pipe support - it now actually seems to work.
    
    * 'drm-intel-fixes' of git://people.freedesktop.org/~danvet/drm-intel: (25 commits)
      drm/i915: Fix missed needs_dmar setting
      drm/i915: Fix shifted screen on top of LVDS on IVY laptop
      drm/i915: disable cpt phase pointer fdi rx workaround
      drm/i915: set the LPT FDI RX polarity reversal bit when needed
      drm/i915: add lpt_init_pch_refclk
      drm/i915: add support for mPHY destination on intel_sbi_{read, write}
      drm/i915: reject modes the LPT FDI receiver can't handle
      drm/i915: fix hsw_fdi_link_train "retry" code
      drm/i915: Close race between processing unpin task and queueing the flip
      drm/i915: fixup l3 parity sysfs access check
      drm/i915: Clear the existing watermarks for g4x when modifying the cursor sr
      drm/i915: do not access BLC_PWM_CTL2 on pre-gen4 hardware
      drm/i915: Don't allow ring tail to reach the same cacheline as head
      drm/i915: Decouple the object from the unbound list before freeing pages
      drm/i915: Set sync_seqno properly after seqno wrap
      drm/i915: Include the last semaphore sync point in the error-state
      drm/i915: Rearrange code to only have a single method for waiting upon the ring
      drm/i915: Simplify flushing activity on the ring
      drm/i915: Preallocate next seqno before touching the ring
      drm/i915: force restore on lid open
      ...

commit 584955632841c069678833f3320b4f6d21a8215e
Author: Rob Clark <rob@ti.com>
Date:   Thu Oct 11 20:50:56 2012 -0500

    drm: remove legacy drm_connector_property fxns
    
    Replace references to and remove the connector property fxns, which
    have been superseded with the more general object property fxns:
    
      + drm_connector_attach_property -> drm_object_attach_property
      + drm_connector_property_set_value -> drm_object_property_set_value
      + drm_connector_property_get_value -> drm_object_property_get_value
    
    Signed-off-by: Rob Clark <rob@ti.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c0635b7f8696..ee9b0b59237f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -920,12 +920,6 @@ extern void drm_mode_set_crtcinfo(struct drm_display_mode *p,
 extern void drm_mode_connector_list_update(struct drm_connector *connector);
 extern int drm_mode_connector_update_edid_property(struct drm_connector *connector,
 						struct edid *edid);
-extern int drm_connector_property_set_value(struct drm_connector *connector,
-					 struct drm_property *property,
-					 uint64_t value);
-extern int drm_connector_property_get_value(struct drm_connector *connector,
-					 struct drm_property *property,
-					 uint64_t *value);
 extern int drm_object_property_set_value(struct drm_mode_object *obj,
 					 struct drm_property *property,
 					 uint64_t val);
@@ -947,8 +941,6 @@ extern int drmfb_remove(struct drm_device *dev, struct drm_framebuffer *fb);
 extern void drm_crtc_probe_connector_modes(struct drm_device *dev, int maxX, int maxY);
 extern bool drm_crtc_in_use(struct drm_crtc *crtc);
 
-extern void drm_connector_attach_property(struct drm_connector *connector,
-					  struct drm_property *property, uint64_t init_val);
 extern void drm_object_attach_property(struct drm_mode_object *obj,
 				       struct drm_property *property,
 				       uint64_t init_val);

commit 374a868a726eb8a1cb28ba88805e51ce34222f8d
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Fri Nov 23 12:09:26 2012 -0200

    drm: add drm_mode_cea_vic
    
    This function returns the VIC of the mode. This value can be used when
    creating AVI InfoFrames.
    
    Cc: Thierry Reding <thierry.reding@avionic-design.de>
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=50371
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Thierry Reding <thierry.reding@avionic-design.de>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c0635b7f8696..3538eda94ef5 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1055,6 +1055,7 @@ extern struct drm_display_mode *drm_gtf_mode_complex(struct drm_device *dev,
 				int GTF_2C, int GTF_K, int GTF_2J);
 extern int drm_add_modes_noedid(struct drm_connector *connector,
 				int hdisplay, int vdisplay);
+extern uint8_t drm_mode_cea_vic(const struct drm_display_mode *mode);
 
 extern int drm_edid_header_is_valid(const u8 *raw_edid);
 extern bool drm_edid_block_valid(u8 *raw_edid, int block, bool print_bad_edid);

commit 905bc9ff6575f78aab24c0261e8785425b5a0397
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Oct 23 18:23:36 2012 +0000

    drm: don't start the poll engine in probe_single_connector
    
    Actually there's a reason this stuff is there, and it's called
    
    commit e58f637bb96d5a0ae0919b9998b891d1ba7e47c9
    Author: Chris Wilson <chris@chris-wilson.co.uk>
    Date:   Fri Aug 20 09:13:36 2010 +0100
    
        drm/kms: Add a module parameter to disable polling
    
    The idea has been that users can enable/disable polling at runtime. So
    the quick hack has been to just re-enable the output polling if xrandr
    asks for the latest state of the connectors.
    
    The problem with that hack is that when we force connectors to another
    state than what would be detected, we nicely ping-pong:
    - Userspace calls probe, gets the forced state, but polling starts
      again.
    - Polling notices that the state is actually different, wakes up
      userspace.
    - Repeat.
    
    As that commit already explains, the right fix would be to make the
    locking more fine-grained, so that hotplug detection on one output
    does not interfere with cursor updates on another crtc.
    
    But that is way too much work. So let's just safe this gross hack by
    caching the last-seen state of drm_kms_helper_poll for that driver,
    and only fire up the poll engine again if it changed from off to on.
    
    v2: Fixup the edge detection of drm_kms_helper_poll.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=49907
    Tested-by: Tvrtko Ursulin <tvrtko.ursulin@onelan.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 1f5f1d642a98..c0635b7f8696 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -792,6 +792,7 @@ struct drm_mode_config {
 
 	/* output poll support */
 	bool poll_enabled;
+	bool poll_running;
 	struct delayed_work output_poll_work;
 
 	/* pointers to standard properties */

commit 69787f7da6b2adc4054357a661aaa1701a9ca76f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Oct 23 18:23:34 2012 +0000

    drm: run the hpd irq event code directly
    
    All drivers already have a work item to run the hpd code, so we don't
    need to launch a new one in the helper code. Dave Airlie mentioned
    that the cancel+re-queue might paper over DP related hpd ping-pongs,
    hence why this is split out.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index ccff8c9b3780..1f5f1d642a98 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -793,7 +793,6 @@ struct drm_mode_config {
 	/* output poll support */
 	bool poll_enabled;
 	struct delayed_work output_poll_work;
-	struct delayed_work hpd_irq_work;
 
 	/* pointers to standard properties */
 	struct list_head property_blob_list;

commit 816da85a0990c2b52cfffa77637d1c770d6790e9
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Oct 23 18:23:33 2012 +0000

    drm: handle HPD and polled connectors separately
    
    Instead of reusing the polling code for hpd handling, split them up.
    This has a few consequences:
    - Don't touch HPD capable connectors in the poll loop.
    - Only touch HPD capable connectors in drm_helper_hpd_irq_event.
    - We could run the HPD handling directly (because all callers already
      use their own work item), but for easier bisect that happens in it's
      own patch.
    
    The ultimate goal is that drivers grow some smarts about which
    connectors have received a hotplug event and only call the detect code
    of that connector. But that's a second step.
    
    v2: s/hdp/hpd/, noticed by Adam Jackson. I can't type.
    
    v3: Split out the work item removal as requested by Dave Airlie. This
    results in a temporary mode_config.hpd_irq_work item to keep things
    the same.
    
    v4: In the hpd_irq_event handler don't bail out if other bits than HPD
    are set. This is useful where e.g. hpd is unreliably, but mostly
    works. Drivers can then set both HPD and POLL flags, and users get the
    best of both worlds: Quick hotplug feedback if the hpd works, but
    still reliable detection with the polling. The poll loop already works
    the same, and doesn't bail if HPD is set.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 1f5f1d642a98..ccff8c9b3780 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -793,6 +793,7 @@ struct drm_mode_config {
 	/* output poll support */
 	bool poll_enabled;
 	struct delayed_work output_poll_work;
+	struct delayed_work hpd_irq_work;
 
 	/* pointers to standard properties */
 	struct list_head property_blob_list;

commit a4799037c3234830e9feb1823d87f905fb4d080a
Author: Stephane Marchesin <marcheu@chromium.org>
Date:   Fri Nov 9 16:21:05 2012 +0000

    drm: get cea video id code for a given display mode
    
    This patch adds support for getting CEA Video ID Code for a given
    display mode after matching with edid_cea_modes list. Its index in
    the list added with one, gives the desired code.
    
    This exported function will be used by hdmi drivers for composing
    AVI info frame data.
    
    Signed-off-by: Stephane Marchesin <marcheu@chromium.org>
    Signed-off-by: Rahul Sharma <rahul.sharma@samsung.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 49dd8c2eea7d..1f5f1d642a98 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1037,6 +1037,7 @@ extern int drm_mode_gamma_get_ioctl(struct drm_device *dev,
 extern int drm_mode_gamma_set_ioctl(struct drm_device *dev,
 				    void *data, struct drm_file *file_priv);
 extern u8 *drm_find_cea_extension(struct edid *edid);
+extern u8 drm_match_cea_mode(struct drm_display_mode *to_match);
 extern bool drm_detect_hdmi_monitor(struct edid *edid);
 extern bool drm_detect_monitor_audio(struct edid *edid);
 extern int drm_mode_page_flip_ioctl(struct drm_device *dev,

commit 0b3904ab2a48488e23332ac1ecd2d45961ec6718
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Oct 25 18:05:05 2012 +0000

    drm: Constify some function arguments
    
    None of drm_mode_debug_printmodeline(), drm_mode_equal(), drm_mode_width()
    or drm_mode_height() change the mode passed in, so make the arguments
    const.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 3fa18b7e9497..49dd8c2eea7d 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -887,14 +887,14 @@ extern void drm_mode_remove(struct drm_connector *connector, struct drm_display_
 extern void drm_mode_copy(struct drm_display_mode *dst, const struct drm_display_mode *src);
 extern struct drm_display_mode *drm_mode_duplicate(struct drm_device *dev,
 						   const struct drm_display_mode *mode);
-extern void drm_mode_debug_printmodeline(struct drm_display_mode *mode);
+extern void drm_mode_debug_printmodeline(const struct drm_display_mode *mode);
 extern void drm_mode_config_init(struct drm_device *dev);
 extern void drm_mode_config_reset(struct drm_device *dev);
 extern void drm_mode_config_cleanup(struct drm_device *dev);
 extern void drm_mode_set_name(struct drm_display_mode *mode);
-extern bool drm_mode_equal(struct drm_display_mode *mode1, struct drm_display_mode *mode2);
-extern int drm_mode_width(struct drm_display_mode *mode);
-extern int drm_mode_height(struct drm_display_mode *mode);
+extern bool drm_mode_equal(const struct drm_display_mode *mode1, const struct drm_display_mode *mode2);
+extern int drm_mode_width(const struct drm_display_mode *mode);
+extern int drm_mode_height(const struct drm_display_mode *mode);
 
 /* for us by fb module */
 extern int drm_mode_attachmode_crtc(struct drm_device *dev,

commit 1f31c69dac71bebc0f00bc8534a6345782045501
Merge: a5a0fc674355 f8f2ac9a76b0
Author: Dave Airlie <airlied@redhat.com>
Date:   Sun Oct 7 21:13:54 2012 +1000

    Merge branch 'drm-intel-fixes' of git://people.freedesktop.org/~danvet/drm-intel into drm-next
    
    Daniel writes:
    
    Bigger -fixes pile, mostly because I've included Ajax' DP dongle stuff,
    as discussed on irc. Otherwise just small things:
    - regression fix to finally make 6bpc auto-dither on dp work (Jani)
    - reinstate an snb ctx w/a that accidentally got lost in a rework (Chris)
    - fixup the DP train sequence, logic-goof-up uncovered by Coverty (Chris)
    - fix set_caching locking (Ben)
    - fix spurious segfault on con-current gtt mmap faulting (Dimitry and Mika)
    - some pageflip correctness fixes (still hunting down some issues, but
      these are the worst offenders of confused code that we've tracked down
      thus far) from Chris and me
    - fixup swizzling settings on vlv (Jesse)
    - gt_mode w/a from Ben added, fixes snb gt1 rc6+hw ctx hangs.
    
    * 'drm-intel-fixes' of git://people.freedesktop.org/~danvet/drm-intel:
      drm/i915: Fix GT_MODE default value
      drm/i915: don't frob the vblank ts in finish_page_flip
      drm/i915: call drm_handle_vblank before finish_page_flip
      drm/i915: print warning if vmi915_gem_fault error is not handled
      drm/i915: EBUSY status handling added to i915_gem_fault().
      drm/i915: Try harder to complete DP training pattern 1
      drm/i915: set swizzling to none on VLV
      drm/dp: Make sink count DP 1.2 aware
      drm/dp: Document DP spec versions for various DPCD registers
      drm/i915/dp: Be smarter about connection sense for branch devices
      drm/i915/dp: Fetch downstream port info if needed during DPCD fetch
      drm/dp: Update DPCD defines
      drm: Export drm_probe_ddc()
      drm/i915: Flush the pending flips on the CRTC before modification
      drm/i915: Actually invalidate the TLB for the SandyBridge HW contexts w/a
      drm/i915: Fix set_caching locking
      drm/i915: use adjusted_mode instead of mode for checking the 6bpc force flag

commit 612a9aab56a93533e76e3ad91642db7033e03b69
Merge: 3a494318b14b 268d28371cd3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 3 23:29:23 2012 -0700

    Merge branch 'drm-next' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm merge (part 1) from Dave Airlie:
     "So first of all my tree and uapi stuff has a conflict mess, its my
      fault as the nouveau stuff didn't hit -next as were trying to rebase
      regressions out of it before we merged.
    
      Highlights:
       - SH mobile modesetting driver and associated helpers
       - some DRM core documentation
       - i915 modesetting rework, haswell hdmi, haswell and vlv fixes, write
         combined pte writing, ilk rc6 support,
       - nouveau: major driver rework into a hw core driver, makes features
         like SLI a lot saner to implement,
       - psb: add eDP/DP support for Cedarview
       - radeon: 2 layer page tables, async VM pte updates, better PLL
         selection for > 2 screens, better ACPI interactions
    
      The rest is general grab bag of fixes.
    
      So why part 1? well I have the exynos pull req which came in a bit
      late but was waiting for me to do something they shouldn't have and it
      looks fairly safe, and David Howells has some more header cleanups
      he'd like me to pull, that seem like a good idea, but I'd like to get
      this merge out of the way so -next dosen't get blocked."
    
    Tons of conflicts mostly due to silly include line changes, but mostly
    mindless.  A few other small semantic conflicts too, noted from Dave's
    pre-merged branch.
    
    * 'drm-next' of git://people.freedesktop.org/~airlied/linux: (447 commits)
      drm/nv98/crypt: fix fuc build with latest envyas
      drm/nouveau/devinit: fixup various issues with subdev ctor/init ordering
      drm/nv41/vm: fix and enable use of "real" pciegart
      drm/nv44/vm: fix and enable use of "real" pciegart
      drm/nv04/dmaobj: fixup vm target handling in preparation for nv4x pcie
      drm/nouveau: store supported dma mask in vmmgr
      drm/nvc0/ibus: initial implementation of subdev
      drm/nouveau/therm: add support for fan-control modes
      drm/nouveau/hwmon: rename pwm0* to pmw1* to follow hwmon's rules
      drm/nouveau/therm: calculate the pwm divisor on nv50+
      drm/nouveau/fan: rewrite the fan tachometer driver to get more precision, faster
      drm/nouveau/therm: move thermal-related functions to the therm subdev
      drm/nouveau/bios: parse the pwm divisor from the perf table
      drm/nouveau/therm: use the EXTDEV table to detect i2c monitoring devices
      drm/nouveau/therm: rework thermal table parsing
      drm/nouveau/gpio: expose the PWM/TOGGLE parameter found in the gpio vbios table
      drm/nouveau: fix pm initialization order
      drm/nouveau/bios: check that fixed tvdac gpio data is valid before using it
      drm/nouveau: log channel debug/error messages from client object rather than drm client
      drm/nouveau: have drm debugging macros build on top of core macros
      ...

commit 19218e482d3f023166b26143c1a1c6d166a30415
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 2 18:01:03 2012 +0100

    UAPI: Refer to the DRM UAPI headers with <...> and from certain headers only
    
    Only refer to the DRM UAPI headers (drm.h, drm_mode.h and drm_sarea.h) from
    within drmP.h and drm_crtc.h, and use #include <...> to refer to them so that
    when the UAPI split happens they can still be accessed.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Dave Airlie <airlied@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index bfacf0d5a225..86a0da4635a6 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -30,6 +30,7 @@
 #include <linux/types.h>
 #include <linux/idr.h>
 #include <linux/fb.h>
+#include <drm/drm_mode.h>
 
 #include <drm/drm_fourcc.h>
 

commit fbff4690b8f23289797b18ad8939e19525c403d1
Author: Adam Jackson <ajax@redhat.com>
Date:   Tue Sep 18 10:58:47 2012 -0400

    drm: Export drm_probe_ddc()
    
    Tested-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Adam Jackson <ajax@redhat.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index eb91d520ce0b..07e2956d9644 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -861,6 +861,7 @@ extern char *drm_get_tv_subconnector_name(int val);
 extern char *drm_get_tv_select_name(int val);
 extern void drm_fb_release(struct drm_file *file_priv);
 extern int drm_mode_group_init_legacy_group(struct drm_device *dev, struct drm_mode_group *group);
+extern bool drm_probe_ddc(struct i2c_adapter *adapter);
 extern struct edid *drm_get_edid(struct drm_connector *connector,
 				 struct i2c_adapter *adapter);
 extern int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid);

commit 7c80e128429d639742043f8fbdd7f1551c940ea3
Author: Rob Clark <rob@ti.com>
Date:   Tue Sep 4 16:35:56 2012 +0000

    drm: support for rotated scanout
    
    For drivers that can support rotated scanout, the extra parameter
    checking in drm-core, while nice, tends to get confused.  To solve
    this drivers can set the crtc or plane invert_dimensions field so
    that the dimension checking takes into account the rotation that
    the driver is performing.
    
    v1: original
    v2: remove invert_dimensions from plane, at Ville's suggestion.
        Userspace can give rotated src coordinates, so invert_dimensions
        is not required for planes.
    
    Signed-off-by: Rob Clark <rob@ti.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 68fdb299e39f..8e405b82707d 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -368,6 +368,9 @@ struct drm_crtc_funcs {
  * @enabled: is this CRTC enabled?
  * @mode: current mode timings
  * @hwmode: mode timings as programmed to hw regs
+ * @invert_dimensions: for purposes of error checking crtc vs fb sizes,
+ *    invert the width/height of the crtc.  This is used if the driver
+ *    is performing 90 or 270 degree rotated scanout
  * @x: x position on screen
  * @y: y position on screen
  * @funcs: CRTC control functions
@@ -401,6 +404,8 @@ struct drm_crtc {
 	 */
 	struct drm_display_mode hwmode;
 
+	bool invert_dimensions;
+
 	int x, y;
 	const struct drm_crtc_funcs *funcs;
 

commit f7eff60ea0e4e35732604e3591e2ff7b3ef41981
Author: Rob Clark <rob@ti.com>
Date:   Wed Sep 5 21:48:38 2012 +0000

    drm: refcnt drm_framebuffer (v4.1)
    
    This simplifies drm fb lifetime, and if the crtc/plane needs to hold
    a ref to the fb when disabling a pipe until the next vblank, this
    avoids the need to make disabling an overlay synchronous.  This is a
    problem that shows up when userspace is using a drm plane to
    implement a hw cursor.. making overlay disable synchronous causes
    a performance problem when x11 is rapidly enabling/disabling the
    hw cursor.  But not making it synchronous opens up a race condition
    for crashing if userspace turns around and immediately deletes the
    fb.  Refcnt'ing the fb makes it possible to solve this problem.
    
    v1: original
    v2: add drm_framebuffer_remove() which is called in all paths where
        fb->funcs->destroy() was directly called before.  This cleans
        up the CRTCs/planes that the fb was attached to.  You should
        only directly use drm_framebuffer_unreference() if you are also
        using drm_framebuffer_reference() to keep a ref to the fb.
    v3: add comment explaining the fb refcount
    v4: remove duplicate 'list_del(&fb->filp_head)'
    
    [airlied: v4.1: fix local rejection]
    
    Signed-off-by: Rob Clark <rob@ti.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index eb91d520ce0b..68fdb299e39f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -218,6 +218,7 @@ struct drm_display_info {
 };
 
 struct drm_framebuffer_funcs {
+	/* note: use drm_framebuffer_remove() */
 	void (*destroy)(struct drm_framebuffer *framebuffer);
 	int (*create_handle)(struct drm_framebuffer *fb,
 			     struct drm_file *file_priv,
@@ -242,6 +243,16 @@ struct drm_framebuffer_funcs {
 
 struct drm_framebuffer {
 	struct drm_device *dev;
+	/*
+	 * Note that the fb is refcounted for the benefit of driver internals,
+	 * for example some hw, disabling a CRTC/plane is asynchronous, and
+	 * scanout does not actually complete until the next vblank.  So some
+	 * cleanup (like releasing the reference(s) on the backing GEM bo(s))
+	 * should be deferred.  In cases like this, the driver would like to
+	 * hold a ref to the fb even though it has already been removed from
+	 * userspace perspective.
+	 */
+	struct kref refcount;
 	struct list_head head;
 	struct drm_mode_object base;
 	const struct drm_framebuffer_funcs *funcs;
@@ -919,6 +930,9 @@ extern void drm_framebuffer_set_object(struct drm_device *dev,
 extern int drm_framebuffer_init(struct drm_device *dev,
 				struct drm_framebuffer *fb,
 				const struct drm_framebuffer_funcs *funcs);
+extern void drm_framebuffer_unreference(struct drm_framebuffer *fb);
+extern void drm_framebuffer_reference(struct drm_framebuffer *fb);
+extern void drm_framebuffer_remove(struct drm_framebuffer *fb);
 extern void drm_framebuffer_cleanup(struct drm_framebuffer *fb);
 extern int drmfb_probe(struct drm_device *dev, struct drm_crtc *crtc);
 extern int drmfb_remove(struct drm_device *dev, struct drm_framebuffer *fb);

commit 398b7a1b882a655ee84bd985f6c2ba89082404ae
Merge: 57df2ae9df6e 979570e02981
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Sep 24 18:07:48 2012 +0200

    Merge tag 'v3.6-rc7' into drm-intel-next-queued
    
    Manual backmerge of -rc7 to resolve a silent conflict leading to
    compile failure in drivers/gpu/drm/i915/intel_hdmi.c.
    
    This is due to the bugfix in -rc7:
    
    commit b98b60167279df3acac9422c3c9820d9ebbcf9fb
    Author: Wang Xingchao <xingchao.wang@intel.com>
    Date:   Thu Sep 13 07:43:22 2012 +0800
    
        drm/i915: HDMI - Clear Audio Enable bit for Hot Plug
    
    Since this code moved around a lot in -next git put that snippet at
    the wrong spot. I've tried to fix this by making the conflict explicit
    by merging a version for next with:
    
    commit 3cce574f0190dd149472059fb69267cf83d290f9
    Author: Wang Xingchao <xingchao.wang@intel.com>
    Date:   Thu Sep 13 11:19:00 2012 +0800
    
        drm/i915: HDMI - Clear Audio Enable bit for Hot Plug unconditionally
    
    But that failed to solve the entire problem. To avoid pushing out
    further -nightly branch to our QA where this is broken, do the
    backmerge and manually add the stuff git adds to -next from the patch
    in -fixes.
    
    Note that this doesn't show up in git's merge diff (and hence is also
    not handled by git rerere), which adds to the reasons why I'd like to
    fix this with a verbose backmerge. The git merge diff only shows a
    bunch of trivial conflicts of the "code changed in lines next to each
    another" kind.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 0b2443ed4e07d7973e4554a2cc166bc35447b59e
Author: Jerome Glisse <jglisse@redhat.com>
Date:   Thu Aug 9 11:25:51 2012 -0400

    drm/edid: limit printk when facing bad edid
    
    Limit printing bad edid information at one time per connector.
    Connector that are connected to a bad monitor/kvm will likely
    stay connected to the same bad monitor/kvm and it makes no
    sense to keep printing the bad edid message.
    
    Signed-off-by: Jerome Glisse <jglisse@redhat.com>
    Reviewed-by: Adam Jackson <ajax@redhat.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 617d87ae2b1a..316ce64e5590 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -590,6 +590,7 @@ struct drm_connector {
 	int video_latency[2];	/* [0]: progressive, [1]: interlaced */
 	int audio_latency[2];
 	int null_edid_counter; /* needed to workaround some HW bugs where we get all 0s */
+	unsigned bad_edid_counter;
 };
 
 /**
@@ -1032,7 +1033,7 @@ extern int drm_add_modes_noedid(struct drm_connector *connector,
 				int hdisplay, int vdisplay);
 
 extern int drm_edid_header_is_valid(const u8 *raw_edid);
-extern bool drm_edid_block_valid(u8 *raw_edid, int block);
+extern bool drm_edid_block_valid(u8 *raw_edid, int block, bool print_bad_edid);
 extern bool drm_edid_is_valid(struct edid *edid);
 struct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,
 					   int hsize, int vsize, int fresh,

commit 93bb70e0c00f1be4cc857e4d8375c44058cce71e
Merge: 6f314ebbaa26 c182ae42cc36
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Aug 27 16:22:20 2012 +1000

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux into drm-next
    
    There was some merge conflicts in -next and they weren't so pretty, so
    backmerge now to avoid them.
    
    Conflicts:
            drivers/gpu/drm/i915/i915_gem.c
            drivers/gpu/drm/i915/intel_modes.c

commit 22f5d115a2b087c977128f84ee557ad71530330e
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Aug 14 10:53:38 2012 +0000

    drm: Initialize object type when using DRM_MODE() macro
    
    DRM_MODE() macro doesn't initialize the type of the base drm object.
    When a copy is made of the mode, the object type is overwritten with
    zero, and the the object can no longer be found by
    drm_mode_object_find() due to the type check failing.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index ced362533e3c..bfacf0d5a225 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -118,7 +118,8 @@ enum drm_mode_status {
 	.hdisplay = (hd), .hsync_start = (hss), .hsync_end = (hse), \
 	.htotal = (ht), .hskew = (hsk), .vdisplay = (vd), \
 	.vsync_start = (vss), .vsync_end = (vse), .vtotal = (vt), \
-	.vscan = (vs), .flags = (f), .vrefresh = 0
+	.vscan = (vs), .flags = (f), .vrefresh = 0, \
+	.base.type = DRM_MODE_OBJECT_MODE
 
 #define CRTC_INTERLACE_HALVE_V 0x1 /* halve V values for interlacing */
 

commit 451023dc32d4542c21b52ad1692e6e01cb75b099
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Wed Aug 15 09:32:39 2012 +0000

    drm: remove the raw_edid field from struct drm_display_info
    
    Neither the drm core nor any of the drivers really need the raw_edid field
    of struct drm_display_info for anything. Instead of being useful, it
    creates confusion about who is responsible for freeing the memory it points
    to and setting the field to NULL afterwards, leading to memory leaks and
    dangling pointers.
    
    Remove the raw_edid field, and fix drivers as necessary.
    
    Reported-by: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Inki Dae <inki.dae@samsung.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index a1a0386e0160..0522044b7498 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -216,8 +216,6 @@ struct drm_display_info {
 	u32 color_formats;
 
 	u8 cea_rev;
-
-	char *raw_edid; /* if any */
 };
 
 struct drm_framebuffer_funcs {

commit 04ccfe77f132b973659f11954443214659014072
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Fri Aug 17 14:20:02 2012 +0000

    drm: Remove two unused fields from struct drm_display_mode
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index a1a0386e0160..ced362533e3c 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -166,8 +166,6 @@ struct drm_display_mode {
 	int crtc_vsync_start;
 	int crtc_vsync_end;
 	int crtc_vtotal;
-	int crtc_hadjusted;
-	int crtc_vadjusted;
 
 	/* Driver private mode info */
 	int private_size;

commit 59fd415ded4aa9ac2f80ca3ac36e3a014c7e552e
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jul 11 16:28:08 2012 +0200

    drm: remove the list_head from drm_mode_set
    
    It's unused. At it confused me quite a bit until I've discovered that.
    
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index bac55c215113..a1a0386e0160 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -676,8 +676,6 @@ struct drm_plane {
  * This is used to set modes.
  */
 struct drm_mode_set {
-	struct list_head head;
-
 	struct drm_framebuffer *fb;
 	struct drm_crtc *crtc;
 	struct drm_display_mode *mode;

commit fe4561680519019cc15d660862dce513ded2f3a7
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Tue Jun 12 11:27:01 2012 -0300

    drm: increase DRM_OBJECT_MAX_PROPERTY to 24
    
    Before Kernel 3.5, no one was checking for the return value of
    drm_connector_attach_property, so we never noticed that we were unable
    to create some properties. Commit "drm: WARN() when
    drm_connector_attach_property fails" added a WARN when we fail to
    create a property, and the transition from "connector properties" to
    "object properties" changed the warning message a little bit.
    
    On i915 machines with many TV connectors we hit the maximum number of
    properties (since each TV connector uses a lot of properties), so we
    get a few backtraces in our logs. This commit increases the maximum
    number of properties to 24 hoping we'll have enough room for
    everybody.
    
    Chris suggested that we convert this code to "lists", but I believe
    this conversion can come after we make sure people's dmesgs are not
    spammed by our driver.
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reported-by: Dave Jones <davej@redhat.com>
    Tested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 73e45600f95d..bac55c215113 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -54,7 +54,7 @@ struct drm_mode_object {
 	struct drm_object_properties *properties;
 };
 
-#define DRM_OBJECT_MAX_PROPERTY 16
+#define DRM_OBJECT_MAX_PROPERTY 24
 struct drm_object_properties {
 	int count;
 	uint32_t ids[DRM_OBJECT_MAX_PROPERTY];

commit 4d93914ae3db4a897ead4b1e33eca7cdfff4c6f7
Author: Rob Clark <rob@ti.com>
Date:   Thu May 17 02:23:27 2012 -0600

    drm: add plane properties
    
    The omapdrm driver uses this for setting per-overlay rotation.  It
    is likely also useful for setting YUV->RGB colorspace conversion
    matrix, etc.
    
    Signed-off-by: Rob Clark <rob@ti.com>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 9b33629e654c..73e45600f95d 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -601,6 +601,7 @@ struct drm_connector {
  * @update_plane: update the plane configuration
  * @disable_plane: shut down the plane
  * @destroy: clean up plane resources
+ * @set_property: called when a property is changed
  */
 struct drm_plane_funcs {
 	int (*update_plane)(struct drm_plane *plane,
@@ -611,6 +612,9 @@ struct drm_plane_funcs {
 			    uint32_t src_w, uint32_t src_h);
 	int (*disable_plane)(struct drm_plane *plane);
 	void (*destroy)(struct drm_plane *plane);
+
+	int (*set_property)(struct drm_plane *plane,
+			    struct drm_property *property, uint64_t val);
 };
 
 /**
@@ -628,6 +632,7 @@ struct drm_plane_funcs {
  * @enabled: enabled flag
  * @funcs: helper functions
  * @helper_private: storage for drver layer
+ * @properties: property tracking for this plane
  */
 struct drm_plane {
 	struct drm_device *dev;
@@ -650,6 +655,8 @@ struct drm_plane {
 
 	const struct drm_plane_funcs *funcs;
 	void *helper_private;
+
+	struct drm_object_properties properties;
 };
 
 /**

commit 49e2754578b9f99bde18ad318d888a462d271479
Author: Rob Clark <rob@ti.com>
Date:   Thu May 17 02:23:26 2012 -0600

    drm: add bitmask property type
    
    A bitmask property is similar to an enum.  The enum value is a bit
    position (0-63), and valid property values consist of a mask of
    zero or more of (1 << enum_val[n]).
    
    [airlied: 1LL -> 1ULL]
    
    Signed-off-by: Rob Clark <rob@ti.com>
    Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b88b28f45f9e..9b33629e654c 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -933,6 +933,10 @@ extern struct drm_property *drm_property_create_enum(struct drm_device *dev, int
 					 const char *name,
 					 const struct drm_prop_enum_list *props,
 					 int num_values);
+struct drm_property *drm_property_create_bitmask(struct drm_device *dev,
+					 int flags, const char *name,
+					 const struct drm_prop_enum_list *props,
+					 int num_values);
 struct drm_property *drm_property_create_range(struct drm_device *dev, int flags,
 					 const char *name,
 					 uint64_t min, uint64_t max);

commit e6ecefaadfcdb03db8ac9e739b4ba7a93a8811b3
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu May 17 13:27:23 2012 +0200

    drm: Constify drm_mode_config_funcs pointer
    
    The DRM mode config functions structure declared by drivers and pointed
    to by the drm_mode_config funcs field is never modified. Make it a const
    pointer.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Rob Clark <rob.clark@linaro.org>
    Reviwed-by: Alex Deucher <alexdeucher@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 3ecee192db06..b88b28f45f9e 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -767,7 +767,7 @@ struct drm_mode_config {
 
 	int min_width, min_height;
 	int max_width, max_height;
-	struct drm_mode_config_funcs *funcs;
+	const struct drm_mode_config_funcs *funcs;
 	resource_size_t fb_base;
 
 	/* output poll support */

commit 3b02ab8893d45f17ae104588e337188127068a92
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu May 17 13:27:20 2012 +0200

    drm: Miscellaneous typo fixes and documentation updates
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index d59bb7d93657..3ecee192db06 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -294,20 +294,16 @@ struct drm_plane;
 
 /**
  * drm_crtc_funcs - control CRTCs for a given device
- * @reset: reset CRTC after state has been invalidate (e.g. resume)
- * @dpms: control display power levels
  * @save: save CRTC state
- * @resore: restore CRTC state
- * @lock: lock the CRTC
- * @unlock: unlock the CRTC
- * @shadow_allocate: allocate shadow pixmap
- * @shadow_create: create shadow pixmap for rotation support
- * @shadow_destroy: free shadow pixmap
- * @mode_fixup: fixup proposed mode
- * @mode_set: set the desired mode on the CRTC
+ * @restore: restore CRTC state
+ * @reset: reset CRTC after state has been invalidate (e.g. resume)
+ * @cursor_set: setup the cursor
+ * @cursor_move: move the cursor
  * @gamma_set: specify color ramp for CRTC
  * @destroy: deinit and free object
  * @set_property: called when a property is changed
+ * @set_config: apply a new CRTC configuration
+ * @page_flip: initiate a page flip
  *
  * The drm_crtc_funcs structure is the central CRTC management structure
  * in the DRM.  Each CRTC controls one or more connectors (note that the name
@@ -420,11 +416,8 @@ struct drm_crtc {
  * @save: save connector state
  * @restore: restore connector state
  * @reset: reset connector after state has been invalidate (e.g. resume)
- * @mode_valid: is this mode valid on the given connector?
- * @mode_fixup: try to fixup proposed mode for this connector
- * @mode_set: set this mode
  * @detect: is this connector active?
- * @get_modes: get mode list for this connector
+ * @fill_modes: fill mode list for this connector
  * @set_property: property for this connector may need update
  * @destroy: make object go away
  * @force: notify the driver the connector is forced on

commit bffd9de0297702566e6aec0678c7ebc3806fe3db
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Tue May 15 18:09:05 2012 -0300

    drm: add CRTC properties
    
    The i915 driver needs this for the rotation and overscan compensation
    properties. Other drivers might need this too.
    
    Reviewed-by: Rob Clark <rob.clark@linaro.org>
    Tested-by: Rob Clark <rob.clark@linaro.org>
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 6d36552899ae..d59bb7d93657 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -306,7 +306,8 @@ struct drm_plane;
  * @mode_fixup: fixup proposed mode
  * @mode_set: set the desired mode on the CRTC
  * @gamma_set: specify color ramp for CRTC
- * @destroy: deinit and free object.
+ * @destroy: deinit and free object
+ * @set_property: called when a property is changed
  *
  * The drm_crtc_funcs structure is the central CRTC management structure
  * in the DRM.  Each CRTC controls one or more connectors (note that the name
@@ -350,6 +351,9 @@ struct drm_crtc_funcs {
 	int (*page_flip)(struct drm_crtc *crtc,
 			 struct drm_framebuffer *fb,
 			 struct drm_pending_vblank_event *event);
+
+	int (*set_property)(struct drm_crtc *crtc,
+			    struct drm_property *property, uint64_t val);
 };
 
 /**
@@ -369,6 +373,7 @@ struct drm_crtc_funcs {
  * @framedur_ns: precise line timing
  * @pixeldur_ns: precise pixel timing
  * @helper_private: mid-layer private data
+ * @properties: property tracking for this CRTC
  *
  * Each CRTC may have one or more connectors associated with it.  This structure
  * allows the CRTC to be controlled.
@@ -404,6 +409,8 @@ struct drm_crtc {
 
 	/* if you are using the helper */
 	void *helper_private;
+
+	struct drm_object_properties properties;
 };
 
 

commit 7f88a9bedfb814a2d4d537db8295c524298256cb
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Tue May 15 18:09:04 2012 -0300

    drm: add 'count' to struct drm_object_properties
    
    This way, we don't need to count every time, so we're a little bit
    faster and code is a little bit smaller.
    
    Change suggested by Ville Syrjälä.
    
    Reviewed-by: Rob Clark <rob.clark@linaro.org>
    Tested-by: Rob Clark <rob.clark@linaro.org>
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b0c32499fcd4..6d36552899ae 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -56,6 +56,7 @@ struct drm_mode_object {
 
 #define DRM_OBJECT_MAX_PROPERTY 16
 struct drm_object_properties {
+	int count;
 	uint32_t ids[DRM_OBJECT_MAX_PROPERTY];
 	uint64_t values[DRM_OBJECT_MAX_PROPERTY];
 };

commit c543188afb7a83e66161c026dc6fd5eb38dc0b63
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Tue May 15 18:09:02 2012 -0300

    drm: add generic ioctls to get/set properties on any object
    
    Useless for connector properties (since they already have their own
    ioctls), but useful when we add properties to CRTCs, planes and other
    objects.
    
    Reviewed-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Reviewed-by: Rob Clark <rob.clark@linaro.org>
    Tested-by: Rob Clark <rob.clark@linaro.org>
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 77606794308b..b0c32499fcd4 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -903,6 +903,12 @@ extern int drm_connector_property_set_value(struct drm_connector *connector,
 extern int drm_connector_property_get_value(struct drm_connector *connector,
 					 struct drm_property *property,
 					 uint64_t *value);
+extern int drm_object_property_set_value(struct drm_mode_object *obj,
+					 struct drm_property *property,
+					 uint64_t val);
+extern int drm_object_property_get_value(struct drm_mode_object *obj,
+					 struct drm_property *property,
+					 uint64_t *value);
 extern struct drm_display_mode *drm_crtc_mode_create(struct drm_device *dev);
 extern void drm_framebuffer_set_object(struct drm_device *dev,
 				       unsigned long handle);
@@ -917,6 +923,9 @@ extern bool drm_crtc_in_use(struct drm_crtc *crtc);
 
 extern void drm_connector_attach_property(struct drm_connector *connector,
 					  struct drm_property *property, uint64_t init_val);
+extern void drm_object_attach_property(struct drm_mode_object *obj,
+				       struct drm_property *property,
+				       uint64_t init_val);
 extern struct drm_property *drm_property_create(struct drm_device *dev, int flags,
 						const char *name, int num_values);
 extern struct drm_property *drm_property_create_enum(struct drm_device *dev, int flags,
@@ -1029,6 +1038,10 @@ extern int drm_mode_mmap_dumb_ioctl(struct drm_device *dev,
 				    void *data, struct drm_file *file_priv);
 extern int drm_mode_destroy_dumb_ioctl(struct drm_device *dev,
 				      void *data, struct drm_file *file_priv);
+extern int drm_mode_obj_get_properties_ioctl(struct drm_device *dev, void *data,
+					     struct drm_file *file_priv);
+extern int drm_mode_obj_set_property_ioctl(struct drm_device *dev, void *data,
+					   struct drm_file *file_priv);
 
 extern void drm_fb_get_bpp_depth(uint32_t format, unsigned int *depth,
 				 int *bpp);

commit 7e3bdf4a6dca9eb153cc20d69d717308a68bec00
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Tue May 15 18:09:01 2012 -0300

    drm: create struct drm_object_properties and use it
    
    For now, only connectors have it. In the future, all objects that need
    properties should use it. Since the structure is referenced inside
    struct drm_mode_object, we will be able to deal with object properties
    without knowing the real type of the object.
    
    Reviewed-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
    Reviewed-by: Rob Clark <rob.clark@linaro.org>
    Tested-by: Rob Clark <rob.clark@linaro.org>
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 036faec8a6fe..77606794308b 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -36,6 +36,7 @@
 struct drm_device;
 struct drm_mode_set;
 struct drm_framebuffer;
+struct drm_object_properties;
 
 
 #define DRM_MODE_OBJECT_CRTC 0xcccccccc
@@ -50,6 +51,13 @@ struct drm_framebuffer;
 struct drm_mode_object {
 	uint32_t id;
 	uint32_t type;
+	struct drm_object_properties *properties;
+};
+
+#define DRM_OBJECT_MAX_PROPERTY 16
+struct drm_object_properties {
+	uint32_t ids[DRM_OBJECT_MAX_PROPERTY];
+	uint64_t values[DRM_OBJECT_MAX_PROPERTY];
 };
 
 /*
@@ -451,7 +459,6 @@ struct drm_encoder_funcs {
 };
 
 #define DRM_CONNECTOR_MAX_UMODES 16
-#define DRM_CONNECTOR_MAX_PROPERTY 16
 #define DRM_CONNECTOR_LEN 32
 #define DRM_CONNECTOR_MAX_ENCODER 3
 
@@ -520,8 +527,7 @@ enum drm_connector_force {
  * @funcs: connector control functions
  * @user_modes: user added mode list
  * @edid_blob_ptr: DRM property containing EDID if present
- * @property_ids: property tracking for this connector
- * @property_values: value pointers or data for properties
+ * @properties: property tracking for this connector
  * @polled: a %DRM_CONNECTOR_POLL_<foo> value for core driven polling
  * @dpms: current dpms state
  * @helper_private: mid-layer private data
@@ -565,8 +571,7 @@ struct drm_connector {
 
 	struct list_head user_modes;
 	struct drm_property_blob *edid_blob_ptr;
-	u32 property_ids[DRM_CONNECTOR_MAX_PROPERTY];
-	uint64_t property_values[DRM_CONNECTOR_MAX_PROPERTY];
+	struct drm_object_properties properties;
 
 	uint8_t polled; /* DRM_CONNECTOR_POLL_* */
 

commit afea2ad53f1fef0b57d0e59fa062f54797158b14
Author: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date:   Tue May 15 18:09:00 2012 -0300

    drm: WARN() when drm_connector_attach_property fails
    
    Also return void instead of int. We have more than 100 callers and
    no one checks for the return value.
    
    If this function fails the property won't be exposed by the get/set
    ioctls, but we should probably survive. If this starts happening,
    the solution will be to increase DRM_CONNECTOR_MAX_PROPERTY and
    recompile the Kernel.
    
    Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
    Reviewed-by: Rob Clark <rob.clark@linaro.org>
    Tested-by: Rob Clark <rob.clark@linaro.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f35e7edd7de2..036faec8a6fe 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -910,8 +910,8 @@ extern int drmfb_remove(struct drm_device *dev, struct drm_framebuffer *fb);
 extern void drm_crtc_probe_connector_modes(struct drm_device *dev, int maxX, int maxY);
 extern bool drm_crtc_in_use(struct drm_crtc *crtc);
 
-extern int drm_connector_attach_property(struct drm_connector *connector,
-				      struct drm_property *property, uint64_t init_val);
+extern void drm_connector_attach_property(struct drm_connector *connector,
+					  struct drm_property *property, uint64_t init_val);
 extern struct drm_property *drm_property_create(struct drm_device *dev, int flags,
 						const char *name, int num_values);
 extern struct drm_property *drm_property_create_enum(struct drm_device *dev, int flags,

commit f89ec8a456dde7f18a13de77b4d79e6b05ca7c84
Author: Adam Jackson <ajax@redhat.com>
Date:   Mon Apr 16 10:40:08 2012 -0400

    drm/edid: Try harder to fix up base EDID blocks
    
    Requiring the first byte of the EDID base block header to be 0 means we
    don't fix up as many transfer errors as we could.  Instead have the
    callers specify whether it's meant to be block 0 or not, and
    conditionally run header fixup based on that.
    
    Bugzilla: https://bugzilla.redhat.com/812890
    Signed-off-by: Adam Jackson <ajax@redhat.com>
    Reviewed-by: Alex Deucher <alexdeucher@gmail.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 6f5faf669959..f35e7edd7de2 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1012,7 +1012,7 @@ extern int drm_add_modes_noedid(struct drm_connector *connector,
 				int hdisplay, int vdisplay);
 
 extern int drm_edid_header_is_valid(const u8 *raw_edid);
-extern bool drm_edid_block_valid(u8 *raw_edid);
+extern bool drm_edid_block_valid(u8 *raw_edid, int block);
 extern bool drm_edid_is_valid(struct edid *edid);
 struct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,
 					   int hsize, int vsize, int fresh,

commit f6e252bac45cab5edc30c2ede971def51e272c9b
Author: Adam Jackson <ajax@redhat.com>
Date:   Fri Apr 13 16:33:31 2012 -0400

    drm/edid: Allow drm_mode_find_dmt to hunt for reduced-blanking modes
    
    It won't find any, yet.  Fix up callers to match: standard mode codes
    will look prefer r-b modes for a given size if present, EST3 mode codes
    will look for exactly the r-b-ness mentioned in the mode code.  This
    might mean fewer modes matched for EST3 mode codes between now and when
    the DMT mode list regrows the r-b modes, but practically speaking EST3
    codes don't exist in the wild.
    
    Signed-off-by: Adam Jackson <ajax@redhat.com>
    Tested-by: Takashi Iwai <tiwai@suse.de>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 2d63a02571ff..6f5faf669959 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1015,7 +1015,8 @@ extern int drm_edid_header_is_valid(const u8 *raw_edid);
 extern bool drm_edid_block_valid(u8 *raw_edid);
 extern bool drm_edid_is_valid(struct edid *edid);
 struct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,
-					   int hsize, int vsize, int fresh);
+					   int hsize, int vsize, int fresh,
+					   bool rb);
 
 extern int drm_mode_create_dumb_ioctl(struct drm_device *dev,
 				      void *data, struct drm_file *file_priv);

commit 01b68b0483627631c738dcfca0dee7e22892c420
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Apr 5 21:35:17 2012 +0300

    drm: Add drm_format_{horz, vert}_chroma_subsampling() utility functions
    
    These functions return the chroma subsampling factors for the specified
    pixel format.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 2d128eb4293f..2d63a02571ff 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1028,5 +1028,7 @@ extern void drm_fb_get_bpp_depth(uint32_t format, unsigned int *depth,
 				 int *bpp);
 extern int drm_format_num_planes(uint32_t format);
 extern int drm_format_plane_cpp(uint32_t format, int plane);
+extern int drm_format_horz_chroma_subsampling(uint32_t format);
+extern int drm_format_vert_chroma_subsampling(uint32_t format);
 
 #endif /* __DRM_CRTC_H__ */

commit 5a86bd552407bd6b3e0df4e88636797484d06430
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Apr 5 21:35:16 2012 +0300

    drm: Add drm_format_plane_cpp() utility function
    
    This function returns the bytes per pixel value based on the pixel
    format and plane index.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 9dd3ed85547d..2d128eb4293f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1027,5 +1027,6 @@ extern int drm_mode_destroy_dumb_ioctl(struct drm_device *dev,
 extern void drm_fb_get_bpp_depth(uint32_t format, unsigned int *depth,
 				 int *bpp);
 extern int drm_format_num_planes(uint32_t format);
+extern int drm_format_plane_cpp(uint32_t format, int plane);
 
 #endif /* __DRM_CRTC_H__ */

commit 141670e9b4356b59b5b39a99e10ac0118d12b16d
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Apr 5 21:35:15 2012 +0300

    drm: Move drm_format_num_planes() to drm_crtc.c
    
    There will be a need for this function in drm_crtc.c later. This
    avoids making drm_crtc.c depend on drm_crtc_helper.c.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index e250eda4e3a8..9dd3ed85547d 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1026,4 +1026,6 @@ extern int drm_mode_destroy_dumb_ioctl(struct drm_device *dev,
 
 extern void drm_fb_get_bpp_depth(uint32_t format, unsigned int *depth,
 				 int *bpp);
+extern int drm_format_num_planes(uint32_t format);
+
 #endif /* __DRM_CRTC_H__ */

commit da0df92b57311aa1b26a2a90599ed16e1e968b90
Author: Carsten Emde <C.Emde@osadl.org>
Date:   Sun Mar 18 22:37:33 2012 +0100

    drm: allow loading an EDID as firmware to override broken monitor
    
    Broken monitors and/or broken graphic boards may send erroneous or no
    EDID data. This also applies to broken KVM devices that are unable to
    correctly forward the EDID data of the connected monitor but invent
    their own fantasy data.
    
    This patch allows to specify an EDID data set to be used instead of
    probing the monitor for it. It contains built-in data sets of frequently
    used screen resolutions. In addition, a particular EDID data set may be
    provided in the /lib/firmware directory and loaded via the firmware
    interface. The name is passed to the kernel as module parameter of the
    drm_kms_helper module either when loaded
      options drm_kms_helper edid_firmware=edid/1280x1024.bin
    or as kernel commandline parameter
      drm_kms_helper.edid_firmware=edid/1280x1024.bin
    
    It is also possible to restrict the usage of a specified EDID data set
    to a particular connector. This is done by prepending the name of the
    connector to the name of the EDID data set using the syntax
      edid_firmware=[<connector>:]<edid>
    such as, for example,
      edid_firmware=DVI-I-1:edid/1920x1080.bin
    in which case no other connector will be affected.
    
    The built-in data sets are
    Resolution    Name
    --------------------------------
    1024x768      edid/1024x768.bin
    1280x1024     edid/1280x1024.bin
    1680x1050     edid/1680x1050.bin
    1920x1080     edid/1920x1080.bin
    
    They are ignored, if a file with the same name is available in the
    /lib/firmware directory.
    
    The built-in EDID data sets are based on standard timings that may not
    apply to a particular monitor and even crash it. Ideally, EDID data of
    the connected monitor should be used. They may be obtained through the
    drm/cardX/cardX-<connector>/edid entry in the /sys/devices PCI directory
    of a correctly working graphics adapter.
    
    It is even possible to specify the name of an EDID data set on-the-fly
    via the /sys/module interface, e.g.
    echo edid/myedid.bin >/sys/module/drm_kms_helper/parameters/edid_firmware
    The new screen mode is considered when the related kernel function is
    called for the first time after the change. Such calls are made when the
    X server is started or when the display settings dialog is opened in an
    already running X server.
    
    Signed-off-by: Carsten Emde <C.Emde@osadl.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 3401761d6391..e250eda4e3a8 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -1012,6 +1012,7 @@ extern int drm_add_modes_noedid(struct drm_connector *connector,
 				int hdisplay, int vdisplay);
 
 extern int drm_edid_header_is_valid(const u8 *raw_edid);
+extern bool drm_edid_block_valid(u8 *raw_edid);
 extern bool drm_edid_is_valid(struct edid *edid);
 struct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,
 					   int hsize, int vsize, int fresh);

commit cbc7e22151d99ed1dd7649d268ad3d81b9e6255a
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Feb 20 14:16:40 2012 +0000

    drm/modeset: add helper to unplug all connectors from sysfs
    
    In order to get correct ordering at hot-unplug for userspace,
    we need to tear down all the sysfs bits at the correct time.
    
    This adds a helper to allow drivers to remove the sysfs nodes
    for all connectors.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 9595c2c9adc7..3401761d6391 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -826,6 +826,8 @@ extern int drm_connector_init(struct drm_device *dev,
 			      int connector_type);
 
 extern void drm_connector_cleanup(struct drm_connector *connector);
+/* helper to unplug all connectors from sysfs for device */
+extern void drm_connector_unplug_all(struct drm_device *dev);
 
 extern int drm_encoder_init(struct drm_device *dev,
 			    struct drm_encoder *encoder,

commit c3c50e8b651887bcefcc13beb3739c00b2379b5c
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Mar 13 12:35:51 2012 +0200

    drm: Add drm_mode_copy()
    
    Add a helper function to copy a display mode. Use it in
    drm_mode_duplicate() and nouveau mode_fixup hooks.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 53cb49a13e17..9595c2c9adc7 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -855,6 +855,7 @@ extern struct edid *drm_get_edid(struct drm_connector *connector,
 extern int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid);
 extern void drm_mode_probed_add(struct drm_connector *connector, struct drm_display_mode *mode);
 extern void drm_mode_remove(struct drm_connector *connector, struct drm_display_mode *mode);
+extern void drm_mode_copy(struct drm_display_mode *dst, const struct drm_display_mode *src);
 extern struct drm_display_mode *drm_mode_duplicate(struct drm_device *dev,
 						   const struct drm_display_mode *mode);
 extern void drm_mode_debug_printmodeline(struct drm_display_mode *mode);

commit d63f5e6bf6f2a1573ea39c9937cdf5ab0b3a4b77
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Mar 13 12:35:49 2012 +0200

    drm: Use a flexible array member for blob property data
    
    The blob property data is always allocated immediately after the object
    header. No need for the extra indirection when accessing it, just use
    a flexible array member.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 00f4007a6d04..53cb49a13e17 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -257,7 +257,7 @@ struct drm_property_blob {
 	struct drm_mode_object base;
 	struct list_head head;
 	unsigned int length;
-	void *data;
+	unsigned char data[];
 };
 
 struct drm_property_enum {

commit 6bfc56aa89f963becbafbaeb105b6a84e0eb0db7
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Mar 13 12:35:48 2012 +0200

    drm: Handle drm_object_get() failures
    
    Check drm_mode_object_get() return value everywhere.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index fe7ebc6b8c93..00f4007a6d04 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -815,22 +815,22 @@ struct drm_prop_enum_list {
 	char *name;
 };
 
-extern void drm_crtc_init(struct drm_device *dev,
-			  struct drm_crtc *crtc,
-			  const struct drm_crtc_funcs *funcs);
+extern int drm_crtc_init(struct drm_device *dev,
+			 struct drm_crtc *crtc,
+			 const struct drm_crtc_funcs *funcs);
 extern void drm_crtc_cleanup(struct drm_crtc *crtc);
 
-extern void drm_connector_init(struct drm_device *dev,
-			    struct drm_connector *connector,
-			    const struct drm_connector_funcs *funcs,
-			    int connector_type);
+extern int drm_connector_init(struct drm_device *dev,
+			      struct drm_connector *connector,
+			      const struct drm_connector_funcs *funcs,
+			      int connector_type);
 
 extern void drm_connector_cleanup(struct drm_connector *connector);
 
-extern void drm_encoder_init(struct drm_device *dev,
-			     struct drm_encoder *encoder,
-			     const struct drm_encoder_funcs *funcs,
-			     int encoder_type);
+extern int drm_encoder_init(struct drm_device *dev,
+			    struct drm_encoder *encoder,
+			    const struct drm_encoder_funcs *funcs,
+			    int encoder_type);
 
 extern int drm_plane_init(struct drm_device *dev,
 			  struct drm_plane *plane,

commit ac235dafb60d3ba4fa4e7341503b16d6e0645ee7
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Mar 13 12:35:46 2012 +0200

    drm: Fix drm_mode_attachmode_crtc()
    
    Change drm_mode_attachmode_crtc() to take an "all or nothing" approach.
    If an error is returned, there are no side effects visible.
    
    Also change the function to always duplicate the mode passed in.
    
    Also change the function to not give up when it finds the first
    connector without and encoder.
    
    A simpler approach would be to just remove the function completely as
    it's unused currently.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 31715bd4f42a..fe7ebc6b8c93 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -869,7 +869,7 @@ extern int drm_mode_height(struct drm_display_mode *mode);
 /* for us by fb module */
 extern int drm_mode_attachmode_crtc(struct drm_device *dev,
 				    struct drm_crtc *crtc,
-				    struct drm_display_mode *mode);
+				    const struct drm_display_mode *mode);
 extern int drm_mode_detachmode_crtc(struct drm_device *dev, struct drm_display_mode *mode);
 
 extern struct drm_display_mode *drm_mode_create(struct drm_device *dev);

commit 2fcfc75b112e897609faed30bcf80565fb005087
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Mar 13 12:35:39 2012 +0200

    drm: Change drm_display_mode::type to unsigned
    
    The drm_display_mode type is a bitmask so it should be unsigned.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 2a0872cac333..31715bd4f42a 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -121,7 +121,7 @@ struct drm_display_mode {
 	char name[DRM_DISPLAY_MODE_LEN];
 
 	enum drm_mode_status status;
-	int type;
+	unsigned int type;
 
 	/* Proposed mode values */
 	int clock;		/* in kHz */

commit 019d96cb55ade38a4b4a52bba0304e8cd681f30a
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Sep 29 16:20:42 2011 +0100

    drm: add some caps for userspace to discover more info for dumb KMS driver (v2)
    
    For the simple KMS driver case we need some more info about what the preferred
    depth and if a shadow framebuffer is preferred.
    
    I've only added this for intel/radeon which support the dumb ioctls so far.
    
    If you need something really fancy you should be writing a real X.org driver.
    
    v2: drop cursor information, just return an error from the cursor ioctls
    and we can make userspace fallback to sw cursor in that case, cursor
    info was getting too messy, best to start smaller.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 823531454799..2a0872cac333 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -796,6 +796,9 @@ struct drm_mode_config {
 	struct drm_property *scaling_mode_property;
 	struct drm_property *dithering_mode_property;
 	struct drm_property *dirty_info_property;
+
+	/* dumb ioctl parameters */
+	uint32_t preferred_depth, prefer_shadow;
 };
 
 #define obj_to_crtc(x) container_of(x, struct drm_crtc, base)

commit d9bc3c02e36d844c2d980e65ddda5c7699e073f8
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Mon Feb 6 10:58:18 2012 +0100

    drm: add convenience function to create an range property
    
    Creating a range property is a common pattern, so create
    a convenience function for this and use it where appropriate.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 3b93cdccea49..823531454799 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -912,6 +912,9 @@ extern struct drm_property *drm_property_create_enum(struct drm_device *dev, int
 					 const char *name,
 					 const struct drm_prop_enum_list *props,
 					 int num_values);
+struct drm_property *drm_property_create_range(struct drm_device *dev, int flags,
+					 const char *name,
+					 uint64_t min, uint64_t max);
 extern void drm_property_destroy(struct drm_device *dev, struct drm_property *property);
 extern int drm_property_add_enum(struct drm_property *property, int index,
 				 uint64_t value, const char *name);

commit 4a67d39190315558631d944b1cea4466ed4c86d8
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Mon Feb 6 10:58:17 2012 +0100

    drm: add convenience function to create an enum property
    
    Creating an enum property is a common pattern, so create
    a convenience function for this and use it where appropriate.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 8d593ad95f16..3b93cdccea49 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -807,6 +807,10 @@ struct drm_mode_config {
 #define obj_to_blob(x) container_of(x, struct drm_property_blob, base)
 #define obj_to_plane(x) container_of(x, struct drm_plane, base)
 
+struct drm_prop_enum_list {
+	int type;
+	char *name;
+};
 
 extern void drm_crtc_init(struct drm_device *dev,
 			  struct drm_crtc *crtc,
@@ -904,6 +908,10 @@ extern int drm_connector_attach_property(struct drm_connector *connector,
 				      struct drm_property *property, uint64_t init_val);
 extern struct drm_property *drm_property_create(struct drm_device *dev, int flags,
 						const char *name, int num_values);
+extern struct drm_property *drm_property_create_enum(struct drm_device *dev, int flags,
+					 const char *name,
+					 const struct drm_prop_enum_list *props,
+					 int num_values);
 extern void drm_property_destroy(struct drm_device *dev, struct drm_property *property);
 extern int drm_property_add_enum(struct drm_property *property, int index,
 				 uint64_t value, const char *name);

commit 4cae5b84628d5df76247d494e51b89d07e28e6aa
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Wed Feb 1 11:38:23 2012 +0100

    drm: add proper return value for drm_mode_crtc_set_gamma_size
    
    drm_mode_crtc_set_gamma_size returns boolean true for success
    and false for failure. This is not very kernel conform, so
    change it to return 0 for success and a propert error code
    otherwise. Noone checks the return value, so no users have to
    be fixed.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 4cd4be26722c..8d593ad95f16 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -919,7 +919,7 @@ extern int drm_mode_connector_attach_encoder(struct drm_connector *connector,
 					     struct drm_encoder *encoder);
 extern void drm_mode_connector_detach_encoder(struct drm_connector *connector,
 					   struct drm_encoder *encoder);
-extern bool drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,
+extern int drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,
 					 int gamma_size);
 extern struct drm_mode_object *drm_mode_object_find(struct drm_device *dev,
 		uint32_t id, uint32_t type);

commit afe887df1c3806da98d4edfeef7794d11eb0fe16
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Jan 12 16:00:57 2012 +1000

    drm: bump DRM_CONNECTOR_MAX_ENCODER from 2 to 3
    
    There exists at least one NVIDIA GPU (Quadro NVS 300) that has a DMS-59
    connector which is capable of supporting DisplayPort, TMDS and VGA on
    a single connector.
    
    We need to bump the allowed encoder limit to support all three configs.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 63e4fce67288..4cd4be26722c 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -453,7 +453,7 @@ struct drm_encoder_funcs {
 #define DRM_CONNECTOR_MAX_UMODES 16
 #define DRM_CONNECTOR_MAX_PROPERTY 16
 #define DRM_CONNECTOR_LEN 32
-#define DRM_CONNECTOR_MAX_ENCODER 2
+#define DRM_CONNECTOR_MAX_ENCODER 3
 
 /**
  * drm_encoder - central DRM encoder structure

commit 0a7eb243db7864640134f8c57e6856f8eb3ed7c6
Author: Rob Clark <rob@ti.com>
Date:   Tue Dec 13 20:19:36 2011 -0600

    drm: add support for private planes
    
    In cases where the scanout hw is sufficiently similar between "overlay"
    and traditional crtc layers, it might be convenient to allow the driver
    to create internal drm_plane helper objects used by the drm_crtc
    implementation, rather than duplicate code between the plane and crtc.
    A private plane is not exposed to userspace.
    
    Signed-off-by: Rob Clark <rob@ti.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 2deb6f99f950..63e4fce67288 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -829,7 +829,8 @@ extern int drm_plane_init(struct drm_device *dev,
 			  struct drm_plane *plane,
 			  unsigned long possible_crtcs,
 			  const struct drm_plane_funcs *funcs,
-			  const uint32_t *formats, uint32_t format_count);
+			  const uint32_t *formats, uint32_t format_count,
+			  bool priv);
 extern void drm_plane_cleanup(struct drm_plane *plane);
 
 extern void drm_encoder_cleanup(struct drm_encoder *encoder);

commit 01f2c7730e188077026c5f766f85f329c7000c54
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Dec 20 00:06:49 2011 +0200

    drm: Replace pitch with pitches[] in drm_framebuffer
    
    Otherwise each driver would need to keep the information inside
    their own framebuffer object structure. Also add offsets[]. BOs
    on the other hand are driver specific, so those can be kept in
    driver specific structures.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 42c89b201ffd..2deb6f99f950 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -239,7 +239,8 @@ struct drm_framebuffer {
 	struct list_head head;
 	struct drm_mode_object base;
 	const struct drm_framebuffer_funcs *funcs;
-	unsigned int pitch;
+	unsigned int pitches[4];
+	unsigned int offsets[4];
 	unsigned int width;
 	unsigned int height;
 	/* depth can be 15 or 16 */

commit 22cd7c625837e520c94ffda7bc926396bbc4ba67
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Dec 20 00:06:46 2011 +0200

    drm: plane: Make 'formats' parameter to drm_plane_init() const
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index dd557272eca7..42c89b201ffd 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -828,7 +828,7 @@ extern int drm_plane_init(struct drm_device *dev,
 			  struct drm_plane *plane,
 			  unsigned long possible_crtcs,
 			  const struct drm_plane_funcs *funcs,
-			  uint32_t *formats, uint32_t format_count);
+			  const uint32_t *formats, uint32_t format_count);
 extern void drm_plane_cleanup(struct drm_plane *plane);
 
 extern void drm_encoder_cleanup(struct drm_encoder *encoder);

commit a62c93d5df1695535afa1413f6496adc219a196e
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Nov 7 12:03:22 2011 -0800

    drm: document the drm_mode_config structure
    
    Including a comment about what the locks are for.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Alex Deucher <alexdeucher@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 2f8a4ac2432f..dd557272eca7 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -714,7 +714,30 @@ struct drm_mode_group {
 
 /**
  * drm_mode_config - Mode configuration control structure
+ * @mutex: mutex protecting KMS related lists and structures
+ * @idr_mutex: mutex for KMS ID allocation and management
+ * @crtc_idr: main KMS ID tracking object
+ * @num_fb: number of fbs available
+ * @fb_list: list of framebuffers available
+ * @num_connector: number of connectors on this device
+ * @connector_list: list of connector objects
+ * @num_encoder: number of encoders on this device
+ * @encoder_list: list of encoder objects
+ * @num_crtc: number of CRTCs on this device
+ * @crtc_list: list of CRTC objects
+ * @min_width: minimum pixel width on this device
+ * @min_height: minimum pixel height on this device
+ * @max_width: maximum pixel width on this device
+ * @max_height: maximum pixel height on this device
+ * @funcs: core driver provided mode setting functions
+ * @fb_base: base address of the framebuffer
+ * @poll_enabled: track polling status for this device
+ * @output_poll_work: delayed work for polling in process context
+ * @*_property: core property tracking
  *
+ * Core mode resource tracking structure.  All CRTC, encoders, and connectors
+ * enumerated by the driver are added here, as are global properties.  Some
+ * global restrictions are also here, e.g. dimension restrictions.
  */
 struct drm_mode_config {
 	struct mutex mutex; /* protects configuration (mode lists etc.) */

commit c1aaca237c6d4d9a60390e69048d1eff1dc7506a
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Nov 7 12:03:21 2011 -0800

    drm: document the drm_mode_group structure
    
    This is actually a core structure with a big future ahead of it.  Make
    it a little less mysterious.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 671e3c3bf9f4..2f8a4ac2432f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -690,6 +690,19 @@ struct drm_mode_config_funcs {
 	void (*output_poll_changed)(struct drm_device *dev);
 };
 
+/**
+ * drm_mode_group - group of mode setting resources for potential sub-grouping
+ * @num_crtcs: CRTC count
+ * @num_encoders: encoder count
+ * @num_connectors: connector count
+ * @id_list: list of KMS object IDs in this group
+ *
+ * Currently this simply tracks the global mode setting state.  But in the
+ * future it could allow groups of objects to be set aside into independent
+ * control groups for use by different user level processes (e.g. two X servers
+ * running simultaneously on different heads, each with their own mode
+ * configuration and freedom of mode setting).
+ */
 struct drm_mode_group {
 	uint32_t num_crtcs;
 	uint32_t num_encoders;

commit 550cebcdb5bebc655812b631156a162cec908794
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Nov 7 12:03:20 2011 -0800

    drm: document and cleanup drm_mode_config_funcs
    
    Just fix the wrapping mostly.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Alex Deucher <alexdeucher@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f3bcff473f6e..671e3c3bf9f4 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -676,10 +676,17 @@ struct drm_mode_set {
 };
 
 /**
- * struct drm_mode_config_funcs - configure CRTCs for a given screen layout
+ * struct drm_mode_config_funcs - basic driver provided mode setting functions
+ * @fb_create: create a new framebuffer object
+ * @output_poll_changed: function to handle output configuration changes
+ *
+ * Some global (i.e. not per-CRTC, connector, etc) mode setting functions that
+ * involve drivers.
  */
 struct drm_mode_config_funcs {
-	struct drm_framebuffer *(*fb_create)(struct drm_device *dev, struct drm_file *file_priv, struct drm_mode_fb_cmd2 *mode_cmd);
+	struct drm_framebuffer *(*fb_create)(struct drm_device *dev,
+					     struct drm_file *file_priv,
+					     struct drm_mode_fb_cmd2 *mode_cmd);
 	void (*output_poll_changed)(struct drm_device *dev);
 };
 

commit ef27351ae1ee83bdd5114523fef9eff405c25a35
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Nov 7 12:03:19 2011 -0800

    drm: document drm_mode_set structure
    
    This is a core mode setting structure that deserves a little verbiage.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Alex Deucher <alexdeucher@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 738323659f9c..f3bcff473f6e 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -646,7 +646,15 @@ struct drm_plane {
 };
 
 /**
- * struct drm_mode_set
+ * drm_mode_set - new values for a CRTC config change
+ * @head: list management
+ * @fb: framebuffer to use for new config
+ * @crtc: CRTC whose configuration we're about to change
+ * @mode: mode timings to use
+ * @x: position of this CRTC relative to @fb
+ * @y: position of this CRTC relative to @fb
+ * @connectors: array of connectors to drive with this CRTC if possible
+ * @num_connectors: size of @connectors array
  *
  * Represents a single crtc the connectors that it drives with what mode
  * and from which framebuffer it scans out from.

commit 722525481a058829f0bae0ec3aab96370f9ab455
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Nov 7 12:03:18 2011 -0800

    drm: remove unused fields in drm_connector and document the rest
    
    We never used initial_x/y or the force_encoder_id, so drop those fields
    and proide a basic description of the others.
    
    Really, the ELD bits belong in drm_display_info rather than directly in
    the connector, but that's a separate cleanup.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Alex Deucher <alexdeucher@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 1cdef2e4dfd2..738323659f9c 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -503,14 +503,37 @@ enum drm_connector_force {
 
 /**
  * drm_connector - central DRM connector control structure
- * @crtc: CRTC this connector is currently connected to, NULL if none
+ * @dev: parent DRM device
+ * @kdev: kernel device for sysfs attributes
+ * @attr: sysfs attributes
+ * @head: list management
+ * @base: base KMS object
+ * @connector_type: one of the %DRM_MODE_CONNECTOR_<foo> types from drm_mode.h
+ * @connector_type_id: index into connector type enum
  * @interlace_allowed: can this connector handle interlaced modes?
  * @doublescan_allowed: can this connector handle doublescan?
- * @available_modes: modes available on this connector (from get_modes() + user)
- * @initial_x: initial x position for this connector
- * @initial_y: initial y position for this connector
- * @status: connector connected?
+ * @modes: modes available on this connector (from fill_modes() + user)
+ * @status: one of the drm_connector_status enums (connected, not, or unknown)
+ * @probed_modes: list of modes derived directly from the display
+ * @display_info: information about attached display (e.g. from EDID)
  * @funcs: connector control functions
+ * @user_modes: user added mode list
+ * @edid_blob_ptr: DRM property containing EDID if present
+ * @property_ids: property tracking for this connector
+ * @property_values: value pointers or data for properties
+ * @polled: a %DRM_CONNECTOR_POLL_<foo> value for core driven polling
+ * @dpms: current dpms state
+ * @helper_private: mid-layer private data
+ * @force: a %DRM_FORCE_<foo> state for forced mode sets
+ * @encoder_ids: valid encoders for this connector
+ * @encoder: encoder driving this connector, if any
+ * @eld: EDID-like data, if present
+ * @dvi_dual: dual link DVI, if found
+ * @max_tmds_clock: max clock rate, if found
+ * @latency_present: AV delay info from ELD, if found
+ * @video_latency: video latency info from ELD, if found
+ * @audio_latency: audio latency info from ELD, if found
+ * @null_edid_counter: track sinks that give us all zeros for the EDID
  *
  * Each connector may be connected to one or more CRTCs, or may be clonable by
  * another connector if they can share a CRTC.  Each connector also has a specific
@@ -531,7 +554,6 @@ struct drm_connector {
 	bool doublescan_allowed;
 	struct list_head modes; /* list of modes on this connector */
 
-	int initial_x, initial_y;
 	enum drm_connector_status status;
 
 	/* these are modes added by probing with DDC or the BIOS */
@@ -555,7 +577,6 @@ struct drm_connector {
 	/* forced on connector */
 	enum drm_connector_force force;
 	uint32_t encoder_ids[DRM_CONNECTOR_MAX_ENCODER];
-	uint32_t force_encoder_id;
 	struct drm_encoder *encoder; /* currently active encoder */
 
 	/* EDID bits */

commit db3e44996f23a2a7e826ede2dd9cb1571687a60f
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Nov 7 12:03:17 2011 -0800

    drm: add drm_encoder comments
    
    Just some basic comments about the place and function of the structure
    and fields.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Alex Deucher <alexdeucher@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 7db2ce52c5a4..1cdef2e4dfd2 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -456,6 +456,18 @@ struct drm_encoder_funcs {
 
 /**
  * drm_encoder - central DRM encoder structure
+ * @dev: parent DRM device
+ * @head: list management
+ * @base: base KMS object
+ * @encoder_type: one of the %DRM_MODE_ENCODER_<foo> types in drm_mode.h
+ * @possible_crtcs: bitmask of potential CRTC bindings
+ * @possible_clones: bitmask of potential sibling encoders for cloning
+ * @crtc: currently bound CRTC
+ * @funcs: control functions
+ * @helper_private: mid-layer private data
+ *
+ * CRTCs drive pixels to encoders, which convert them into signals
+ * appropriate for a given connector or set of connectors.
  */
 struct drm_encoder {
 	struct drm_device *dev;

commit 6c3db9200b75f0fd736c9d766b754b971ad07eb1
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Nov 7 12:03:16 2011 -0800

    drm: add comments for drm_encoder_funcs
    
    Just basic verbiage.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Alex Deucher <alexdeucher@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 9014599791a5..7db2ce52c5a4 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -437,6 +437,13 @@ struct drm_connector_funcs {
 	void (*force)(struct drm_connector *connector);
 };
 
+/**
+ * drm_encoder_funcs - encoder controls
+ * @reset: reset state (e.g. at init or resume time)
+ * @destroy: cleanup and free associated data
+ *
+ * Encoders sit between CRTCs and connectors.
+ */
 struct drm_encoder_funcs {
 	void (*reset)(struct drm_encoder *encoder);
 	void (*destroy)(struct drm_encoder *encoder);

commit 7749163efe5b366d53a3609229263c7a7994a8df
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Nov 7 12:03:14 2011 -0800

    drm: fix comments for drm_crtc struct
    
    Remove stale entries and update with the latest stuff.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Alex Deucher <alexdeucher@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 4f2feee4f479..9014599791a5 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -344,10 +344,21 @@ struct drm_crtc_funcs {
 
 /**
  * drm_crtc - central CRTC control structure
+ * @dev: parent DRM device
+ * @head: list management
+ * @base: base KMS object for ID tracking etc.
  * @enabled: is this CRTC enabled?
+ * @mode: current mode timings
+ * @hwmode: mode timings as programmed to hw regs
  * @x: x position on screen
  * @y: y position on screen
  * @funcs: CRTC control functions
+ * @gamma_size: size of gamma ramp
+ * @gamma_store: gamma ramp values
+ * @framedur_ns: precise frame timing
+ * @framedur_ns: precise line timing
+ * @pixeldur_ns: precise pixel timing
+ * @helper_private: mid-layer private data
  *
  * Each CRTC may have one or more connectors associated with it.  This structure
  * allows the CRTC to be controlled.

commit 6f215f9f86eedd8dd8709ba2f725b042da6b6e89
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Nov 7 12:03:12 2011 -0800

    drm: remove unused connector_count field from drm_display_mode
    
    Doesn't really belong here anyway.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Alex Deucher <alexdeucher@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 6718b1873dfc..4f2feee4f479 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -120,7 +120,6 @@ struct drm_display_mode {
 
 	char name[DRM_DISPLAY_MODE_LEN];
 
-	int connector_count;
 	enum drm_mode_status status;
 	int type;
 

commit 248dbc2350501e2c7b9f5ceb60c75515d82f4134
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Nov 29 20:02:54 2011 +0000

    drm: move the fb bpp/depth helper into the core.
    
    This is used by nearly everyone including vmwgfx which doesn't generally
    use the fb helper.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index a2fbf3399682..6718b1873dfc 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -902,4 +902,7 @@ extern int drm_mode_mmap_dumb_ioctl(struct drm_device *dev,
 				    void *data, struct drm_file *file_priv);
 extern int drm_mode_destroy_dumb_ioctl(struct drm_device *dev,
 				      void *data, struct drm_file *file_priv);
+
+extern void drm_fb_get_bpp_depth(uint32_t format, unsigned int *depth,
+				 int *bpp);
 #endif /* __DRM_CRTC_H__ */

commit 308e5bcbdb10452e8aba31aa21432fb67ee46d72
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Nov 14 14:51:28 2011 -0800

    drm: add an fb creation ioctl that takes a pixel format v5
    
    To properly support the various plane formats supported by different
    hardware, the kernel must know the pixel format of a framebuffer object.
    So add a new ioctl taking a format argument corresponding to a fourcc
    name from the new drm_fourcc.h header file.  Implement the fb creation
    hooks in terms of the new mode_fb_cmd2 using helpers where the old
    bpp/depth values are needed.
    
    v2: create DRM specific fourcc header file for sharing with libdrm etc
    v3: fix rebase failure and use DRM fourcc codes in intel_display.c and
        update commit message
    v4: make fb_cmd2 handle field into an array for multi-object formats
        pull in Ville's fix for the memcpy in drm_plane_init
        apply Ville's cleanup to zero out fb_cmd2 arg in drm_mode_addfb
    v5: add 'flags' field for interlaced support (from Ville)
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Acked-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Reviewed-by: Rob Clark <rob.clark@linaro.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index e20867ed7c90..a2fbf3399682 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -29,9 +29,10 @@
 #include <linux/spinlock.h>
 #include <linux/types.h>
 #include <linux/idr.h>
-
 #include <linux/fb.h>
 
+#include <drm/drm_fourcc.h>
+
 struct drm_device;
 struct drm_mode_set;
 struct drm_framebuffer;
@@ -246,6 +247,7 @@ struct drm_framebuffer {
 	unsigned int depth;
 	int bits_per_pixel;
 	int flags;
+	uint32_t pixel_format; /* fourcc format */
 	struct list_head filp_head;
 	/* if you are using the helper */
 	void *helper_private;
@@ -619,7 +621,7 @@ struct drm_mode_set {
  * struct drm_mode_config_funcs - configure CRTCs for a given screen layout
  */
 struct drm_mode_config_funcs {
-	struct drm_framebuffer *(*fb_create)(struct drm_device *dev, struct drm_file *file_priv, struct drm_mode_fb_cmd *mode_cmd);
+	struct drm_framebuffer *(*fb_create)(struct drm_device *dev, struct drm_file *file_priv, struct drm_mode_fb_cmd2 *mode_cmd);
 	void (*output_poll_changed)(struct drm_device *dev);
 };
 
@@ -837,6 +839,9 @@ extern int drm_mode_cursor_ioctl(struct drm_device *dev,
 				void *data, struct drm_file *file_priv);
 extern int drm_mode_addfb(struct drm_device *dev,
 			  void *data, struct drm_file *file_priv);
+extern int drm_mode_addfb2(struct drm_device *dev,
+			   void *data, struct drm_file *file_priv);
+extern uint32_t drm_mode_legacy_fb_format(uint32_t bpp, uint32_t depth);
 extern int drm_mode_rmfb(struct drm_device *dev,
 			 void *data, struct drm_file *file_priv);
 extern int drm_mode_getfb(struct drm_device *dev,

commit 8cf5c9177151537e73ff1816540e4ba24b174391
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Nov 14 14:51:27 2011 -0800

    drm: add plane support v3
    
    Planes are a bit like half-CRTCs.  They have a location and fb, but
    don't drive outputs directly.  Add support for handling them to the core
    KMS code.
    
    v2: fix ABI of get_plane - move format_type_ptr to the end
    v3: add 'flags' field for interlaced support (from Ville)
    
    Acked-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Reviewed-by: Rob Clark <rob.clark@linaro.org>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 802079809282..e20867ed7c90 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -44,6 +44,7 @@ struct drm_framebuffer;
 #define DRM_MODE_OBJECT_PROPERTY 0xb0b0b0b0
 #define DRM_MODE_OBJECT_FB 0xfbfbfbfb
 #define DRM_MODE_OBJECT_BLOB 0xbbbbbbbb
+#define DRM_MODE_OBJECT_PLANE 0xeeeeeeee
 
 struct drm_mode_object {
 	uint32_t id;
@@ -278,6 +279,7 @@ struct drm_crtc;
 struct drm_connector;
 struct drm_encoder;
 struct drm_pending_vblank_event;
+struct drm_plane;
 
 /**
  * drm_crtc_funcs - control CRTCs for a given device
@@ -535,6 +537,62 @@ struct drm_connector {
 	int null_edid_counter; /* needed to workaround some HW bugs where we get all 0s */
 };
 
+/**
+ * drm_plane_funcs - driver plane control functions
+ * @update_plane: update the plane configuration
+ * @disable_plane: shut down the plane
+ * @destroy: clean up plane resources
+ */
+struct drm_plane_funcs {
+	int (*update_plane)(struct drm_plane *plane,
+			    struct drm_crtc *crtc, struct drm_framebuffer *fb,
+			    int crtc_x, int crtc_y,
+			    unsigned int crtc_w, unsigned int crtc_h,
+			    uint32_t src_x, uint32_t src_y,
+			    uint32_t src_w, uint32_t src_h);
+	int (*disable_plane)(struct drm_plane *plane);
+	void (*destroy)(struct drm_plane *plane);
+};
+
+/**
+ * drm_plane - central DRM plane control structure
+ * @dev: DRM device this plane belongs to
+ * @head: for list management
+ * @base: base mode object
+ * @possible_crtcs: pipes this plane can be bound to
+ * @format_types: array of formats supported by this plane
+ * @format_count: number of formats supported
+ * @crtc: currently bound CRTC
+ * @fb: currently bound fb
+ * @gamma_size: size of gamma table
+ * @gamma_store: gamma correction table
+ * @enabled: enabled flag
+ * @funcs: helper functions
+ * @helper_private: storage for drver layer
+ */
+struct drm_plane {
+	struct drm_device *dev;
+	struct list_head head;
+
+	struct drm_mode_object base;
+
+	uint32_t possible_crtcs;
+	uint32_t *format_types;
+	uint32_t format_count;
+
+	struct drm_crtc *crtc;
+	struct drm_framebuffer *fb;
+
+	/* CRTC gamma size for reporting to userspace */
+	uint32_t gamma_size;
+	uint16_t *gamma_store;
+
+	bool enabled;
+
+	const struct drm_plane_funcs *funcs;
+	void *helper_private;
+};
+
 /**
  * struct drm_mode_set
  *
@@ -589,6 +647,8 @@ struct drm_mode_config {
 	struct list_head connector_list;
 	int num_encoder;
 	struct list_head encoder_list;
+	int num_plane;
+	struct list_head plane_list;
 
 	int num_crtc;
 	struct list_head crtc_list;
@@ -641,6 +701,7 @@ struct drm_mode_config {
 #define obj_to_fb(x) container_of(x, struct drm_framebuffer, base)
 #define obj_to_property(x) container_of(x, struct drm_property, base)
 #define obj_to_blob(x) container_of(x, struct drm_property_blob, base)
+#define obj_to_plane(x) container_of(x, struct drm_plane, base)
 
 
 extern void drm_crtc_init(struct drm_device *dev,
@@ -660,6 +721,13 @@ extern void drm_encoder_init(struct drm_device *dev,
 			     const struct drm_encoder_funcs *funcs,
 			     int encoder_type);
 
+extern int drm_plane_init(struct drm_device *dev,
+			  struct drm_plane *plane,
+			  unsigned long possible_crtcs,
+			  const struct drm_plane_funcs *funcs,
+			  uint32_t *formats, uint32_t format_count);
+extern void drm_plane_cleanup(struct drm_plane *plane);
+
 extern void drm_encoder_cleanup(struct drm_encoder *encoder);
 
 extern char *drm_get_connector_name(struct drm_connector *connector);
@@ -753,13 +821,18 @@ extern struct drm_mode_object *drm_mode_object_find(struct drm_device *dev,
 /* IOCTLs */
 extern int drm_mode_getresources(struct drm_device *dev,
 				 void *data, struct drm_file *file_priv);
-
+extern int drm_mode_getplane_res(struct drm_device *dev, void *data,
+				   struct drm_file *file_priv);
 extern int drm_mode_getcrtc(struct drm_device *dev,
 			    void *data, struct drm_file *file_priv);
 extern int drm_mode_getconnector(struct drm_device *dev,
 			      void *data, struct drm_file *file_priv);
 extern int drm_mode_setcrtc(struct drm_device *dev,
 			    void *data, struct drm_file *file_priv);
+extern int drm_mode_getplane(struct drm_device *dev,
+			       void *data, struct drm_file *file_priv);
+extern int drm_mode_setplane(struct drm_device *dev,
+			       void *data, struct drm_file *file_priv);
 extern int drm_mode_cursor_ioctl(struct drm_device *dev,
 				void *data, struct drm_file *file_priv);
 extern int drm_mode_addfb(struct drm_device *dev,

commit 76adaa34db407f174dd06370cb60f6029c33b465
Author: Wu Fengguang <fengguang.wu@intel.com>
Date:   Mon Sep 5 14:23:20 2011 +0800

    drm: support routines for HDMI/DP ELD
    
    ELD (EDID-Like Data) describes to the HDMI/DP audio driver the audio
    capabilities of the plugged monitor.
    
    This adds drm_edid_to_eld() for converting EDID to ELD. The converted
    ELD will be saved in a new drm_connector.eld[128] data field. This is
    necessary because the graphics driver will need to fixup some of the
    data fields (eg. HDMI/DP connection type, AV sync delay) before writing
    to the hardware ELD buffer. drm_av_sync_delay() will help the graphics
    drivers dynamically compute the AV sync delay for fixing-up the ELD.
    
    ELD selection policy: it's possible for one encoder to be associated
    with multiple connectors (ie. monitors), in which case the first found
    ELD will be returned by drm_select_eld(). This policy may not be
    suitable for all users, but let's start it simple first.
    
    The impact of ELD selection policy: assume there are two monitors, one
    supports stereo playback and the other has 8-channel output; cloned
    display mode is used, so that the two monitors are associated with the
    same internal encoder. If only the stereo playback capability is reported,
    the user won't be able to start 8-channel playback; if the 8-channel ELD
    is reported, then user space applications may send 8-channel samples
    down, however the user may actually be listening to the 2-channel
    monitor and not connecting speakers to the 8-channel monitor.
    
    According to James, many TVs will either refuse the display anything or
    pop-up an OSD warning whenever they receive hdmi audio which they cannot
    handle. Eventually we will require configurability and/or per-monitor
    audio control even when the video is cloned.
    
    CC: Zhao Yakui <yakui.zhao@intel.com>
    CC: Wang Zhenyu <zhenyu.z.wang@intel.com>
    CC: Jeremy Bush <contractfrombelow@gmail.com>
    CC: Christopher White <c.white@pulseforce.com>
    CC: Pierre-Louis Bossart <pierre-louis.bossart@intel.com>
    CC: Paul Menzel <paulepanter@users.sourceforge.net>
    CC: James Cloos <cloos@jhcloos.com>
    CC: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Signed-off-by: Wu Fengguang <fengguang.wu@intel.com>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 44335e57eaaa..802079809282 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -466,6 +466,8 @@ enum drm_connector_force {
 /* DACs should rarely do this without a lot of testing */
 #define DRM_CONNECTOR_POLL_DISCONNECT (1 << 2)
 
+#define MAX_ELD_BYTES	128
+
 /**
  * drm_connector - central DRM connector control structure
  * @crtc: CRTC this connector is currently connected to, NULL if none
@@ -523,6 +525,13 @@ struct drm_connector {
 	uint32_t force_encoder_id;
 	struct drm_encoder *encoder; /* currently active encoder */
 
+	/* EDID bits */
+	uint8_t eld[MAX_ELD_BYTES];
+	bool dvi_dual;
+	int max_tmds_clock;	/* in MHz */
+	bool latency_present[2];
+	int video_latency[2];	/* [0]: progressive, [1]: interlaced */
+	int audio_latency[2];
 	int null_edid_counter; /* needed to workaround some HW bugs where we get all 0s */
 };
 

commit 051963d4832ed61e5ae74f5330b0a94489e101b9
Author: Thomas Reim <reimth@gmail.com>
Date:   Fri Jul 29 14:28:57 2011 +0000

    drm: Separate EDID Header Check from EDID Block Check
    
        Provides function drm_edid_header_is_valid() for EDID header check
        and replaces EDID header check part of function drm_edid_block_valid()
        by a call of drm_edid_header_is_valid().
        This is a prerequisite to extend DDC probing, e. g. in function
        radeon_ddc_probe() for Radeon devices, by a central EDID header check.
    
        Tested for kernel 2.6.35, 2.6.38 and 3.0
    
    Cc: <stable@kernel.org>
    Signed-off-by: Thomas Reim <reimth@gmail.com>
    Reviewed-by: Alex Deucher <alexdeucher@gmail.com>
    Acked-by: Stephen Michaels <Stephen.Micheals@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index d515bc8f4ba7..44335e57eaaa 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -804,6 +804,7 @@ extern struct drm_display_mode *drm_gtf_mode_complex(struct drm_device *dev,
 extern int drm_add_modes_noedid(struct drm_connector *connector,
 				int hdisplay, int vdisplay);
 
+extern int drm_edid_header_is_valid(const u8 *raw_edid);
 extern bool drm_edid_is_valid(struct edid *edid);
 struct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,
 					   int hsize, int vsize, int fresh);

commit ebec9a7bf11f843b0602b06c402f04bf4213b35a
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Wed Aug 3 09:22:54 2011 -0700

    drm: track CEA version number if present
    
    Drivers need to know the CEA version number in addition to other display
    info (like whether the display is an HDMI sink) before enabling certain
    features.  So track the CEA version number in the display info
    structure.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 33d12f87f0e0..d515bc8f4ba7 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -205,6 +205,8 @@ struct drm_display_info {
 	enum subpixel_order subpixel_order;
 	u32 color_formats;
 
+	u8 cea_rev;
+
 	char *raw_edid; /* if any */
 };
 

commit 4a9a8b71e12d41abb71c4e741bff524f016cfef4
Author: Dave Airlie <airlied@linux.ie>
Date:   Tue Jun 14 06:13:55 2011 +0000

    drm/radeon: workaround a hw bug on some radeon chipsets with all-0 EDIDs.
    
    Some RS690 chipsets seem to end up with floating connectors, either
    a DVI connector isn't actually populated, or an add-in HDMI card
    is available but not installed. In this case we seem to get a NULL byte
    response for each byte of the i2c transaction, so we detect this
    case and if we see it we don't do anymore DDC transactions on this
    connector.
    
    I've tested this on my RS690 without the HDMI card installed and
    it seems to work fine.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Alex Deucher <alexdeucher@gmail.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 9573e0ce3120..33d12f87f0e0 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -520,6 +520,8 @@ struct drm_connector {
 	uint32_t encoder_ids[DRM_CONNECTOR_MAX_ENCODER];
 	uint32_t force_encoder_id;
 	struct drm_encoder *encoder; /* currently active encoder */
+
+	int null_edid_counter; /* needed to workaround some HW bugs where we get all 0s */
 };
 
 /**

commit da05a5a71ad8fc7c51d526151be193b7ef6e6c95
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Fri Apr 15 13:48:57 2011 -0700

    drm: parse color format support for digital displays
    
    EDID 1.4 digital displays report the color spaces they support in the
    features block.  Add support for grabbing this data and stuffing it into
    the display_info struct for driver use.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Alex Deucher <alexdeucher@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index ee1cb7012e56..9573e0ce3120 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -183,7 +183,9 @@ enum subpixel_order {
 	SubPixelNone,
 };
 
-
+#define DRM_COLOR_FORMAT_RGB444		(1<<0)
+#define DRM_COLOR_FORMAT_YCRCB444	(1<<1)
+#define DRM_COLOR_FORMAT_YCRCB422	(1<<2)
 /*
  * Describes a given display (e.g. CRT or flat panel) and its limitations.
  */
@@ -201,6 +203,7 @@ struct drm_display_info {
 	unsigned int bpc;
 
 	enum subpixel_order subpixel_order;
+	u32 color_formats;
 
 	char *raw_edid; /* if any */
 };

commit 3b11228b54cc6bda4a72bb22984203c6eff4338a
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Fri Apr 15 12:49:23 2011 -0700

    drm: add bit depth parsing
    
    EDID 1.4 digital monitors report the bit depth supported in the input
    field.  Add support for parsing this out and storing the info in the
    display_info structure for use by drivers.
    
    [airlied: tweaked to fix inter-patch dependency]
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Adam Jackson <ajax@redhat.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index d94684b7ba34..ee1cb7012e56 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -198,6 +198,7 @@ struct drm_display_info {
 	unsigned int min_vfreq, max_vfreq;
 	unsigned int min_hfreq, max_hfreq;
 	unsigned int pixel_clock;
+	unsigned int bpc;
 
 	enum subpixel_order subpixel_order;
 

commit 42933bac11e811f02200c944d8562a15f8ec4ff0
Merge: 2b9accbee563 25985edcedea
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 7 11:14:49 2011 -0700

    Merge branch 'for-linus2' of git://git.profusion.mobi/users/lucas/linux-2.6
    
    * 'for-linus2' of git://git.profusion.mobi/users/lucas/linux-2.6:
      Fix common misspellings

commit eccaca28e29861a63ebc067bfff59c7efa427371
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Mar 30 05:03:47 2011 +0000

    drm: export drm_find_cea_extension to drivers
    
    Nouveau needs access to this structure to build an ELD block for use
    by the HDA audio codec.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 60edf9be31e5..aaec09713bee 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -778,6 +778,7 @@ extern int drm_mode_gamma_get_ioctl(struct drm_device *dev,
 				    void *data, struct drm_file *file_priv);
 extern int drm_mode_gamma_set_ioctl(struct drm_device *dev,
 				    void *data, struct drm_file *file_priv);
+extern u8 *drm_find_cea_extension(struct edid *edid);
 extern bool drm_detect_hdmi_monitor(struct edid *edid);
 extern bool drm_detect_monitor_audio(struct edid *edid);
 extern int drm_mode_page_flip_ioctl(struct drm_device *dev,

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 60edf9be31e5..e2ed98b175f6 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -65,7 +65,7 @@ enum drm_mode_status {
     MODE_H_ILLEGAL,	/* mode has illegal horizontal timings */
     MODE_V_ILLEGAL,	/* mode has illegal horizontal timings */
     MODE_BAD_WIDTH,	/* requires an unsupported linepitch */
-    MODE_NOMODE,	/* no mode with a maching name */
+    MODE_NOMODE,	/* no mode with a matching name */
     MODE_NO_INTERLACE,	/* interlaced mode not supported */
     MODE_NO_DBLESCAN,	/* doublescan mode not supported */
     MODE_NO_VSCAN,	/* multiscan mode not supported */
@@ -321,7 +321,7 @@ struct drm_crtc_funcs {
 
 	/*
 	 * Flip to the given framebuffer.  This implements the page
-	 * flip ioctl descibed in drm_mode.h, specifically, the
+	 * flip ioctl described in drm_mode.h, specifically, the
 	 * implementation must return immediately and block all
 	 * rendering to the current fb until the flip has completed.
 	 * If userspace set the event flag in the ioctl, the event

commit b1f559ecdc6026ef783ccadc62a61e7da906fcb4
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Jan 26 09:49:47 2011 +0000

    drm: Mark constant arrays of drm_display_mode const
    
    ... and fixup some methods to accept the constant argument.
    
    Now that constant module arrays are loaded into read-only memory, using
    const appropriately has some benefits beyond warning the programmer
    about likely mistakes.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 080a6e33470e..60edf9be31e5 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -659,7 +659,7 @@ extern int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid
 extern void drm_mode_probed_add(struct drm_connector *connector, struct drm_display_mode *mode);
 extern void drm_mode_remove(struct drm_connector *connector, struct drm_display_mode *mode);
 extern struct drm_display_mode *drm_mode_duplicate(struct drm_device *dev,
-						   struct drm_display_mode *mode);
+						   const struct drm_display_mode *mode);
 extern void drm_mode_debug_printmodeline(struct drm_display_mode *mode);
 extern void drm_mode_config_init(struct drm_device *dev);
 extern void drm_mode_config_reset(struct drm_device *dev);
@@ -685,8 +685,8 @@ extern void drm_mode_validate_size(struct drm_device *dev,
 extern void drm_mode_prune_invalid(struct drm_device *dev,
 				   struct list_head *mode_list, bool verbose);
 extern void drm_mode_sort(struct list_head *mode_list);
-extern int drm_mode_hsync(struct drm_display_mode *mode);
-extern int drm_mode_vrefresh(struct drm_display_mode *mode);
+extern int drm_mode_hsync(const struct drm_display_mode *mode);
+extern int drm_mode_vrefresh(const struct drm_display_mode *mode);
 extern void drm_mode_set_crtcinfo(struct drm_display_mode *p,
 				  int adjust_flags);
 extern void drm_mode_connector_list_update(struct drm_connector *connector);

commit ff72145badb834e8051719ea66e024784d000cb4
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Feb 7 12:16:14 2011 +1000

    drm: dumb scanout create/mmap for intel/radeon (v3)
    
    This is just an idea that might or might not be a good idea,
    it basically adds two ioctls to create a dumb and map a dumb buffer
    suitable for scanout. The handle can be passed to the KMS ioctls to create
    a framebuffer.
    
    It looks to me like it would be useful in the following cases:
    a) in development drivers - we can always provide a shadowfb fallback.
    b) libkms users - we can clean up libkms a lot and avoid linking
    to libdrm_*.
    c) plymouth via libkms is a lot easier.
    
    Userspace bits would be just calls + mmaps. We could probably
    mark these handles somehow as not being suitable for acceleartion
    so as top stop people who are dumber than dumb.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 801be59f4f15..080a6e33470e 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -798,4 +798,11 @@ extern int drm_add_modes_noedid(struct drm_connector *connector,
 extern bool drm_edid_is_valid(struct edid *edid);
 struct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,
 					   int hsize, int vsize, int fresh);
+
+extern int drm_mode_create_dumb_ioctl(struct drm_device *dev,
+				      void *data, struct drm_file *file_priv);
+extern int drm_mode_mmap_dumb_ioctl(struct drm_device *dev,
+				    void *data, struct drm_file *file_priv);
+extern int drm_mode_destroy_dumb_ioctl(struct drm_device *dev,
+				      void *data, struct drm_file *file_priv);
 #endif /* __DRM_CRTC_H__ */

commit eb03355660b44cf6b1ed2f895085b9de8f74efbc
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jan 24 15:11:08 2011 +0000

    drm: Add an interface to reset the device
    
    Iterate over the attached CRTCs, encoders and connectors and call the
    supplied reset vfunc in order to reset any cached state back to unknown.
    Useful after an invalidation event such as a GPU reset or resuming.
    
    Tested-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index acd7fade160d..801be59f4f15 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -275,6 +275,7 @@ struct drm_pending_vblank_event;
 
 /**
  * drm_crtc_funcs - control CRTCs for a given device
+ * @reset: reset CRTC after state has been invalidate (e.g. resume)
  * @dpms: control display power levels
  * @save: save CRTC state
  * @resore: restore CRTC state
@@ -302,6 +303,8 @@ struct drm_crtc_funcs {
 	void (*save)(struct drm_crtc *crtc); /* suspend? */
 	/* Restore CRTC state */
 	void (*restore)(struct drm_crtc *crtc); /* resume? */
+	/* Reset CRTC state */
+	void (*reset)(struct drm_crtc *crtc);
 
 	/* cursor controls */
 	int (*cursor_set)(struct drm_crtc *crtc, struct drm_file *file_priv,
@@ -379,6 +382,7 @@ struct drm_crtc {
  * @dpms: set power state (see drm_crtc_funcs above)
  * @save: save connector state
  * @restore: restore connector state
+ * @reset: reset connector after state has been invalidate (e.g. resume)
  * @mode_valid: is this mode valid on the given connector?
  * @mode_fixup: try to fixup proposed mode for this connector
  * @mode_set: set this mode
@@ -396,6 +400,7 @@ struct drm_connector_funcs {
 	void (*dpms)(struct drm_connector *connector, int mode);
 	void (*save)(struct drm_connector *connector);
 	void (*restore)(struct drm_connector *connector);
+	void (*reset)(struct drm_connector *connector);
 
 	/* Check to see if anything is attached to the connector.
 	 * @force is set to false whilst polling, true when checking the
@@ -413,6 +418,7 @@ struct drm_connector_funcs {
 };
 
 struct drm_encoder_funcs {
+	void (*reset)(struct drm_encoder *encoder);
 	void (*destroy)(struct drm_encoder *encoder);
 };
 
@@ -656,6 +662,7 @@ extern struct drm_display_mode *drm_mode_duplicate(struct drm_device *dev,
 						   struct drm_display_mode *mode);
 extern void drm_mode_debug_printmodeline(struct drm_display_mode *mode);
 extern void drm_mode_config_init(struct drm_device *dev);
+extern void drm_mode_config_reset(struct drm_device *dev);
 extern void drm_mode_config_cleanup(struct drm_device *dev);
 extern void drm_mode_set_name(struct drm_display_mode *mode);
 extern bool drm_mode_equal(struct drm_display_mode *mode1, struct drm_display_mode *mode2);

commit 27641c3f003e7f3b6585c01d8a788883603eb262
Author: Mario Kleiner <mario.kleiner@tuebingen.mpg.de>
Date:   Sat Oct 23 04:20:23 2010 +0200

    drm/vblank: Add support for precise vblank timestamping.
    
    The DRI2 swap & sync implementation needs precise
    vblank counts and precise timestamps corresponding
    to those vblank counts. For conformance to the OpenML
    OML_sync_control extension specification the DRM
    timestamp associated with a vblank count should
    correspond to the start of video scanout of the first
    scanline of the video frame following the vblank
    interval for that vblank count.
    
    Therefore we need to carry around precise timestamps
    for vblanks. Currently the DRM and KMS drivers generate
    timestamps ad-hoc via do_gettimeofday() in some
    places. The resulting timestamps are sometimes not
    very precise due to interrupt handling delays, they
    don't conform to OML_sync_control and some are wrong,
    as they aren't taken synchronized to the vblank.
    
    This patch implements support inside the drm core
    for precise and robust timestamping. It consists
    of the following interrelated pieces.
    
    1. Vblank timestamp caching:
    
    A per-crtc ringbuffer stores the most recent vblank
    timestamps corresponding to vblank counts.
    
    The ringbuffer can be read out lock-free via the
    accessor function:
    
    struct timeval timestamp;
    vblankcount = drm_vblank_count_and_time(dev, crtcid, &timestamp).
    
    The function returns the current vblank count and
    the corresponding timestamp for start of video
    scanout following the vblank interval. It can be
    used anywhere between enclosing drm_vblank_get(dev, crtcid)
    and drm_vblank_put(dev,crtcid) statements. It is used
    inside the drmWaitVblank ioctl and in the vblank event
    queueing and handling. It should be used by kms drivers for
    timestamping of bufferswap completion.
    
    The timestamp ringbuffer is reinitialized each time
    vblank irq's get reenabled in drm_vblank_get()/
    drm_update_vblank_count(). It is invalidated when
    vblank irq's get disabled.
    
    The ringbuffer is updated inside drm_handle_vblank()
    at each vblank irq.
    
    2. Calculation of precise vblank timestamps:
    
    drm_get_last_vbltimestamp() is used to compute the
    timestamp for the end of the most recent vblank (if
    inside active scanout), or the expected end of the
    current vblank interval (if called inside a vblank
    interval). The function calls into a new optional kms
    driver entry point dev->driver->get_vblank_timestamp()
    which is supposed to provide the precise timestamp.
    If a kms driver doesn't implement the entry point or
    if the call fails, a simple do_gettimeofday() timestamp
    is returned as crude approximation of the true vblank time.
    
    A new drm module parameter drm.timestamp_precision_usec
    allows to disable high precision timestamps (if set to
    zero) or to specify the maximum acceptable error in
    the timestamps in microseconds.
    
    Kms drivers could implement their get_vblank_timestamp()
    function in a gpu specific way, as long as returned
    timestamps conform to OML_sync_control, e.g., by use
    of gpu specific hardware timestamps.
    
    Optionally, kms drivers can simply wrap and use the new
    utility function drm_calc_vbltimestamp_from_scanoutpos().
    This function calls a new optional kms driver function
    dev->driver->get_scanout_position() which returns the
    current horizontal and vertical video scanout position
    of the crtc. The scanout position together with the
    drm_display_timing of the current video mode is used
    to calculate elapsed time relative to start of active scanout
    for the current video frame. This elapsed time is subtracted
    from the current do_gettimeofday() time to get the timestamp
    corresponding to start of video scanout. Currently
    non-interlaced, non-doublescan video modes, with or
    without panel scaling are handled correctly. Interlaced/
    doublescan modes are tbd in a future patch.
    
    3. Filtering of redundant vblank irq's and removal of
    some race-conditions in the vblank irq enable/disable path:
    
    Some gpu's (e.g., Radeon R500/R600) send spurious vblank
    irq's outside the vblank if vblank irq's get reenabled.
    These get detected by use of the vblank timestamps and
    filtered out to avoid miscounting of vblanks.
    
    Some race-conditions between the vblank irq enable/disable
    functions, the vblank irq handler and the gpu itself (updating
    its hardware vblank counter in the "wrong" moment) are
    fixed inside vblank_disable_and_save() and
    drm_update_vblank_count() by use of the vblank timestamps and
    a new spinlock dev->vblank_time_lock.
    
    The time until vblank irq disable is now configurable via
    a new drm module parameter drm.vblankoffdelay to allow
    experimentation with timeouts that are much shorter than
    the current 5 seconds and should allow longer vblank off
    periods for better power savings.
    
    Followup patches will use these new functions to
    implement precise timestamping for the intel and radeon
    kms drivers.
    
    Signed-off-by: Mario Kleiner <mario.kleiner@tuebingen.mpg.de>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 029aa688e787..acd7fade160d 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -351,8 +351,14 @@ struct drm_crtc {
 
 	bool enabled;
 
+	/* Requested mode from modesetting. */
 	struct drm_display_mode mode;
 
+	/* Programmed mode in hw, after adjustments for encoders,
+	 * crtc, panel scaling etc. Needed for timestamping etc.
+	 */
+	struct drm_display_mode hwmode;
+
 	int x, y;
 	const struct drm_crtc_funcs *funcs;
 
@@ -360,6 +366,9 @@ struct drm_crtc {
 	uint32_t gamma_size;
 	uint16_t *gamma_store;
 
+	/* Constants needed for precise vblank and swap timestamping. */
+	s64 framedur_ns, linedur_ns, pixeldur_ns;
+
 	/* if you are using the helper */
 	void *helper_private;
 };

commit 8fe9790d1652e7c306c862ea102a5e6126b412e1
Author: Zhenyu Wang <zhenyuw@linux.intel.com>
Date:   Sun Sep 19 14:27:28 2010 +0800

    drm/edid: add helper function to detect monitor audio capability
    
    To help to determine if digital display port needs to enable
    audio output or not. This one adds a helper to get monitor's
    audio capability via EDID CEA extension block.
    
    Tested-by: Wu Fengguang <fengguang.wu@intel.com>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Reviewed-by: Adam Jackson <ajax@redhat.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 15c4796fd467..029aa688e787 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -763,6 +763,7 @@ extern int drm_mode_gamma_get_ioctl(struct drm_device *dev,
 extern int drm_mode_gamma_set_ioctl(struct drm_device *dev,
 				    void *data, struct drm_file *file_priv);
 extern bool drm_detect_hdmi_monitor(struct edid *edid);
+extern bool drm_detect_monitor_audio(struct edid *edid);
 extern int drm_mode_page_flip_ioctl(struct drm_device *dev,
 				    void *data, struct drm_file *file_priv);
 extern struct drm_display_mode *drm_cvt_mode(struct drm_device *dev,

commit 02b001624f0384540299d9288fdaf37b7d37c814
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Tue Oct 5 12:43:02 2010 +0200

    drm: vmwgfx: Add a struct drm_file parameter to the dirty framebuffer callback
    
    This is needed for the callback to identify the caller and take
    appropriate locks if needed.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 3e5a51af757c..15c4796fd467 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -221,7 +221,8 @@ struct drm_framebuffer_funcs {
 	 * the semantics and arguments have a one to one mapping
 	 * on this function.
 	 */
-	int (*dirty)(struct drm_framebuffer *framebuffer, unsigned flags,
+	int (*dirty)(struct drm_framebuffer *framebuffer,
+		     struct drm_file *file_priv, unsigned flags,
 		     unsigned color, struct drm_clip_rect *clips,
 		     unsigned num_clips);
 };

commit 930a9e283516a3a3595c0c515113f1b78d07f695
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Sep 14 11:07:23 2010 +0100

    drm: Use a nondestructive mode for output detect when polling (v2)
    
    v2: Julien Cristau pointed out that @nondestructive results in
    double-negatives and confusion when trying to interpret the parameter,
    so use @force instead. Much easier to type as well. ;-)
    
    And fix the miscompilation of vmgfx reported by Sedat Dilek.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: stable@kernel.org
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 5536223fbac8..3e5a51af757c 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -386,8 +386,15 @@ struct drm_connector_funcs {
 	void (*dpms)(struct drm_connector *connector, int mode);
 	void (*save)(struct drm_connector *connector);
 	void (*restore)(struct drm_connector *connector);
+
+	/* Check to see if anything is attached to the connector.
+	 * @force is set to false whilst polling, true when checking the
+	 * connector due to user request. @force can be used by the driver
+	 * to avoid expensive, destructive operations during automated
+	 * probing.
+	 */
 	enum drm_connector_status (*detect)(struct drm_connector *connector,
-					    bool nondestructive);
+					    bool force);
 	int (*fill_modes)(struct drm_connector *connector, uint32_t max_width, uint32_t max_height);
 	int (*set_property)(struct drm_connector *connector, struct drm_property *property,
 			     uint64_t val);

commit 7b334fcb45b757ffb093696ca3de1b0c8b4a33f1
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Sep 9 23:51:02 2010 +0100

    drm: Use a nondestructive mode for output detect when polling
    
    Destructive load-detection is very expensive and due to failings
    elsewhere can trigger system wide stalls of up to 600ms. A simple
    first step to correcting this is not to invoke such an expensive
    and destructive load-detection operation automatically.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=29536
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=16265
    Reported-by: Bruno Prémont <bonbons@linux-vserver.org>
    Tested-by: Sitsofe Wheeler <sitsofe@yahoo.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: stable@kernel.org
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c9f3cc5949a8..5536223fbac8 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -386,7 +386,8 @@ struct drm_connector_funcs {
 	void (*dpms)(struct drm_connector *connector, int mode);
 	void (*save)(struct drm_connector *connector);
 	void (*restore)(struct drm_connector *connector);
-	enum drm_connector_status (*detect)(struct drm_connector *connector);
+	enum drm_connector_status (*detect)(struct drm_connector *connector,
+					    bool nondestructive);
 	int (*fill_modes)(struct drm_connector *connector, uint32_t max_width, uint32_t max_height);
 	int (*set_property)(struct drm_connector *connector, struct drm_property *property,
 			     uint64_t val);

commit aa9f56b66d278aba2f278c75761b7e19fbaca97a
Merge: 58d4ea65b98f 31ce4bfdfd10
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Aug 12 09:21:39 2010 -0700

    Merge branch 'drm-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/airlied/drm-2.6
    
    * 'drm-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/airlied/drm-2.6: (55 commits)
      io-mapping: move asm include inside the config option
      vgaarb: drop vga.h include
      drm/radeon: Add probing of clocks from device-tree
      drm/radeon: drop old and broken mesa warning
      drm/radeon: Fix pci_map_page() error checking
      drm: Remove count_lock for calling lastclose() after 58474713 (v2)
      drm/radeon/kms: allow FG_ALPHA_VALUE on r5xx
      drm/radeon/kms: another r6xx/r7xx CS checker fix
      DRM: Replace kmalloc/memset combos with kzalloc
      drm: expand gamma_set
      drm/edid: Split mode lists out to their own header for readability
      drm/edid: Rewrite mode parse to use the generic detailed block walk
      drm/edid: Add detailed block walk for VTB extensions
      drm/edid: Add detailed block walk for CEA extensions
      drm: Remove unused fields from drm_display_info
      drm: Use ENOENT consistently for the error return for an unmatched handle.
      drm/radeon/kms: mark 3D power states as performance
      drm: Only set DPMS once on the CRTC not after every encoder.
      drm/radeon/kms: add additional quirk for Acer rv620 laptop
      drm: Propagate error code from fb_create()
      ...
    
    Fix up trivial conflicts in drivers/gpu/drm/drm_edid.c

commit 7203425a943eb3e189ba6b512827e0deb5f23872
Author: James Simmons <jsimmons@infradead.org>
Date:   Tue Aug 3 01:33:19 2010 +0100

    drm: expand gamma_set
    
    Expand the crtc_gamma_set function to accept a starting offset. The
    reason for this is to eventually use this function for setcolreg from
    drm_fb_helper.c. The fbdev colormap function can start at any offset in
    the color map.
    
    Signed-by: James Simmons <jsimmons@infradead.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 606eb93d7db0..692cc55eeab6 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -310,7 +310,7 @@ struct drm_crtc_funcs {
 
 	/* Set gamma on the CRTC */
 	void (*gamma_set)(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,
-			  uint32_t size);
+			  uint32_t start, uint32_t size);
 	/* Object destroy routine */
 	void (*destroy)(struct drm_crtc *crtc);
 

commit fb439640145df0d3af7eacb83a19d8eb0a24002a
Author: Adam Jackson <ajax@redhat.com>
Date:   Tue Aug 3 14:38:16 2010 -0400

    drm: Remove unused fields from drm_display_info
    
    Signed-off-by: Adam Jackson <ajax@redhat.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 93a1a31b9c2d..606eb93d7db0 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -190,49 +190,16 @@ enum subpixel_order {
  */
 struct drm_display_info {
 	char name[DRM_DISPLAY_INFO_LEN];
-	/* Input info */
-	bool serration_vsync;
-	bool sync_on_green;
-	bool composite_sync;
-	bool separate_syncs;
-	bool blank_to_black;
-	unsigned char video_level;
-	bool digital;
+
 	/* Physical size */
         unsigned int width_mm;
 	unsigned int height_mm;
 
-	/* Display parameters */
-	unsigned char gamma; /* FIXME: storage format */
-	bool gtf_supported;
-	bool standard_color;
-	enum {
-		monochrome = 0,
-		rgb,
-		other,
-		unknown,
-	} display_type;
-	bool active_off_supported;
-	bool suspend_supported;
-	bool standby_supported;
-
-	/* Color info FIXME: storage format */
-	unsigned short redx, redy;
-	unsigned short greenx, greeny;
-	unsigned short bluex, bluey;
-	unsigned short whitex, whitey;
-
 	/* Clock limits FIXME: storage format */
 	unsigned int min_vfreq, max_vfreq;
 	unsigned int min_hfreq, max_hfreq;
 	unsigned int pixel_clock;
 
-	/* White point indices FIXME: storage format */
-	unsigned int wpx1, wpy1;
-	unsigned int wpgamma1;
-	unsigned int wpx2, wpy2;
-	unsigned int wpgamma2;
-
 	enum subpixel_order subpixel_order;
 
 	char *raw_edid; /* if any */

commit 991ea75cb1df7188d209274b3d51c105b4f18ffe
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Jul 20 22:09:02 2010 +0200

    drm: use workqueue instead of slow-work
    
    Workqueue can now handle high concurrency.  Convert drm_crtc_helper to
    use system_nrt_wq instead of slow-work.  The conversion is mostly
    straight forward.  One difference is that drm_helper_hpd_irq_event()
    no longer blocks and can be called from any context.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: David Airlie <airlied@linux.ie>
    Cc: dri-devel@lists.freedesktop.org

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 93a1a31b9c2d..c707270bff5a 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -31,7 +31,6 @@
 #include <linux/idr.h>
 
 #include <linux/fb.h>
-#include <linux/slow-work.h>
 
 struct drm_device;
 struct drm_mode_set;
@@ -595,7 +594,7 @@ struct drm_mode_config {
 
 	/* output poll support */
 	bool poll_enabled;
-	struct delayed_slow_work output_poll_slow_work;
+	struct delayed_work output_poll_work;
 
 	/* pointers to standard properties */
 	struct list_head property_blob_list;

commit 1d42bbc8f7f9ce4d852692ef7aa336b133b0830a
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri May 7 05:02:30 2010 +0000

    drm/fbdev: fix cloning on fbcon
    
    Simple cloning rules compared to server:
    (a) single crtc
    (b) > 1 connector active
    (c) check command line mode
    (d) try and find 1024x768 DMT mode if no command line.
    (e) fail to clone
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 2e4bf92faa85..93a1a31b9c2d 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -804,4 +804,6 @@ extern int drm_add_modes_noedid(struct drm_connector *connector,
 				int hdisplay, int vdisplay);
 
 extern bool drm_edid_is_valid(struct edid *edid);
+struct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,
+					   int hsize, int vsize, int fresh);
 #endif /* __DRM_CRTC_H__ */

commit eb1f8e4f3be898df808e2dfc131099f5831d491d
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri May 7 06:42:51 2010 +0000

    drm/fbdev: rework output polling to be back in the core. (v4)
    
    After thinking it over a lot it made more sense for the core to deal with
    the output polling especially so it can notify X.
    
    v2: drop plans for fake connector - per Michel's comments - fix X patch sent to xorg-devel, add intel polled/hpd setting, add initial nouveau polled/hpd settings.
    
    v3: add config lock take inside polling, add intel/nouveau poll init/fini calls
    
    v4: config lock was a bit agressive, only needed around connector list reading.
    otherwise it could re-enter.
    
    glisse: discard drm_helper_hpd_irq_event
    
    v3: Reviewed-by: Michel DÃ¤nzer <michel@daenzer.net>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c560364663a5..2e4bf92faa85 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -31,6 +31,7 @@
 #include <linux/idr.h>
 
 #include <linux/fb.h>
+#include <linux/slow-work.h>
 
 struct drm_device;
 struct drm_mode_set;
@@ -460,6 +461,15 @@ enum drm_connector_force {
 	DRM_FORCE_ON_DIGITAL, /* for DVI-I use digital connector */
 };
 
+/* should we poll this connector for connects and disconnects */
+/* hot plug detectable */
+#define DRM_CONNECTOR_POLL_HPD (1 << 0)
+/* poll for connections */
+#define DRM_CONNECTOR_POLL_CONNECT (1 << 1)
+/* can cleanly poll for disconnections without flickering the screen */
+/* DACs should rarely do this without a lot of testing */
+#define DRM_CONNECTOR_POLL_DISCONNECT (1 << 2)
+
 /**
  * drm_connector - central DRM connector control structure
  * @crtc: CRTC this connector is currently connected to, NULL if none
@@ -504,6 +514,8 @@ struct drm_connector {
 	u32 property_ids[DRM_CONNECTOR_MAX_PROPERTY];
 	uint64_t property_values[DRM_CONNECTOR_MAX_PROPERTY];
 
+	uint8_t polled; /* DRM_CONNECTOR_POLL_* */
+
 	/* requested DPMS state */
 	int dpms;
 
@@ -543,6 +555,7 @@ struct drm_mode_set {
  */
 struct drm_mode_config_funcs {
 	struct drm_framebuffer *(*fb_create)(struct drm_device *dev, struct drm_file *file_priv, struct drm_mode_fb_cmd *mode_cmd);
+	void (*output_poll_changed)(struct drm_device *dev);
 };
 
 struct drm_mode_group {
@@ -580,6 +593,10 @@ struct drm_mode_config {
 	struct drm_mode_config_funcs *funcs;
 	resource_size_t fb_base;
 
+	/* output poll support */
+	bool poll_enabled;
+	struct delayed_slow_work output_poll_slow_work;
+
 	/* pointers to standard properties */
 	struct list_head property_blob_list;
 	struct drm_property *edid_property;

commit 7fff400be6fbf64f10abca9939718aaf1d61c255
Merge: 0bcb1d844ac6 b1f201980eb4
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Apr 20 13:16:04 2010 +1000

    Merge branch 'drm-fbdev-cleanup' into drm-core-next
    
    * drm-fbdev-cleanup:
      drm/fb: remove drm_fb_helper_setcolreg
      drm/kms/fb: use slow work mechanism for normal hotplug also.
      drm/kms/fb: add polling support for when nothing is connected.
      drm/kms/fb: provide a 1024x768 fbcon if no outputs found.
      drm/kms/fb: separate fbdev connector list from core drm connectors
      drm/kms/fb: move to using fb helper crtc grouping instead of core crtc list
      drm/fb: fix fbdev object model + cleanup properly.
    
    Conflicts:
            drivers/gpu/drm/i915/i915_drv.h
            drivers/gpu/drm/nouveau/nouveau_drv.h

commit 0b4c0f3f0eceacb691e2b5570d9b16d751ce1b48
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Mar 30 05:34:15 2010 +0000

    drm/kms/fb: separate fbdev connector list from core drm connectors
    
    This breaks the connection between the core drm connector list
    and the fbdev connector usage, and allows them to become disjoint
    in the future. It also removes the untype void* that was in the
    connector struct to support this.
    
    All connectors are added to the fbdev now but this could be
    changed in the future.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index e4e34bae22cd..fce2042ad0a5 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -514,7 +514,6 @@ struct drm_connector {
 	uint32_t encoder_ids[DRM_CONNECTOR_MAX_ENCODER];
 	uint32_t force_encoder_id;
 	struct drm_encoder *encoder; /* currently active encoder */
-	void *fb_helper_private;
 };
 
 /**

commit 8be48d924c307e72e3797ab5bde81b07a1ccc52d
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Mar 30 05:34:14 2010 +0000

    drm/kms/fb: move to using fb helper crtc grouping instead of core crtc list
    
    This move to using the list of crtcs in the fb helper and cleans up the
    whole picking code, now we store the crtc/connectors we want directly
    into the modeset and we use the modeset directly to set the mode.
    
    Fixes from James Simmons and Ben Skeggs.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index c70814b184e8..e4e34bae22cd 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -367,9 +367,6 @@ struct drm_crtc_funcs {
  * @enabled: is this CRTC enabled?
  * @x: x position on screen
  * @y: y position on screen
- * @desired_mode: new desired mode
- * @desired_x: desired x for desired_mode
- * @desired_y: desired y for desired_mode
  * @funcs: CRTC control functions
  *
  * Each CRTC may have one or more connectors associated with it.  This structure
@@ -389,8 +386,6 @@ struct drm_crtc {
 	struct drm_display_mode mode;
 
 	int x, y;
-	struct drm_display_mode *desired_mode;
-	int desired_x, desired_y;
 	const struct drm_crtc_funcs *funcs;
 
 	/* CRTC gamma size for reporting to userspace */

commit 386516744ba45d50f42c6999151cc210cb4f96e4
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Mar 30 05:34:13 2010 +0000

    drm/fb: fix fbdev object model + cleanup properly.
    
    The fbdev layer in the kms code should act like a consumer of the kms services and avoid having relying on information being store in the kms core structures in order for it to work.
    
    This patch
    
    a) removes the info pointer/psuedo palette from the core drm_framebuffer structure and moves it to the fbdev helper layer, it also removes the core drm keeping a list of kernel kms fbdevs.
    b) migrated all the fb helper functions out of the crtc helper file into the fb helper file.
    c) pushed the fb probing/hotplug control into the driver
    d) makes the surface sizes into a structure for ease of passing
    This changes the intel/radeon/nouveau drivers to use the new helper.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 1347524a8e30..c70814b184e8 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -271,8 +271,6 @@ struct drm_framebuffer {
 	unsigned int depth;
 	int bits_per_pixel;
 	int flags;
-	struct fb_info *fbdev;
-	u32 pseudo_palette[17];
 	struct list_head filp_head;
 	/* if you are using the helper */
 	void *helper_private;
@@ -548,16 +546,9 @@ struct drm_mode_set {
 
 /**
  * struct drm_mode_config_funcs - configure CRTCs for a given screen layout
- * @resize: adjust CRTCs as necessary for the proposed layout
- *
- * Currently only a resize hook is available.  DRM will call back into the
- * driver with a new screen width and height.  If the driver can't support
- * the proposed size, it can return false.  Otherwise it should adjust
- * the CRTC<->connector mappings as needed and update its view of the screen.
  */
 struct drm_mode_config_funcs {
 	struct drm_framebuffer *(*fb_create)(struct drm_device *dev, struct drm_file *file_priv, struct drm_mode_fb_cmd *mode_cmd);
-	int (*fb_changed)(struct drm_device *dev);
 };
 
 struct drm_mode_group {
@@ -590,9 +581,6 @@ struct drm_mode_config {
 
 	struct list_head property_list;
 
-	/* in-kernel framebuffers - hung of filp_head in drm_framebuffer */
-	struct list_head fb_kernel_list;
-
 	int min_width, min_height;
 	int max_width, max_height;
 	struct drm_mode_config_funcs *funcs;

commit 7a37435008b0ffea2442eb1134ddd4adeea81e19
Author: Adam Jackson <ajax@redhat.com>
Date:   Mon Mar 29 21:43:30 2010 +0000

    drm/edid: Add secondary GTF curve support
    
    Before CVT-R, some monitors would advertise support for an alternative
    GTF formula with lower blanking intervals.  Correctly identify such
    monitors, and use the alternative formula when generating modes for
    them.
    
    Note that we only do this for "standard" timing descriptors (tuples of
    hsize in characters / aspect ratio / vertical refresh).  Range-based
    mode lists still only refer to the primary GTF curve.  It would be
    possible to do better for the latter case, but monitors are required to
    support the primary curve over the entire advertised range, so all it
    would win you is a lower pixel clock and therefore possibly better image
    quality on analog links.
    
    Signed-off-by: Adam Jackson <ajax@redhat.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index f74523a299c9..8eb3630ee67d 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -797,6 +797,10 @@ extern struct drm_display_mode *drm_cvt_mode(struct drm_device *dev,
 extern struct drm_display_mode *drm_gtf_mode(struct drm_device *dev,
 				int hdisplay, int vdisplay, int vrefresh,
 				bool interlaced, int margins);
+extern struct drm_display_mode *drm_gtf_mode_complex(struct drm_device *dev,
+				int hdisplay, int vdisplay, int vrefresh,
+				bool interlaced, int margins, int GTF_M,
+				int GTF_2C, int GTF_K, int GTF_2J);
 extern int drm_add_modes_noedid(struct drm_connector *connector,
 				int hdisplay, int vdisplay);
 

commit 61e57a8d72f2336faf39b5d940215cf085e01e6e
Author: Adam Jackson <ajax@redhat.com>
Date:   Mon Mar 29 21:43:18 2010 +0000

    drm/edid: Fix secondary block fetch.
    
    This makes fetching the second EDID block on HDMI monitors actually
    work.  DDC can't transfer more than 128 bytes at a time.  Also,
    rearrange the code so the pure DDC bits are separate from block parse.
    
    Signed-off-by: Adam Jackson <ajax@redhat.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 1347524a8e30..f74523a299c9 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -666,8 +666,6 @@ extern void drm_fb_release(struct drm_file *file_priv);
 extern int drm_mode_group_init_legacy_group(struct drm_device *dev, struct drm_mode_group *group);
 extern struct edid *drm_get_edid(struct drm_connector *connector,
 				 struct i2c_adapter *adapter);
-extern int drm_do_probe_ddc_edid(struct i2c_adapter *adapter,
-				 unsigned char *buf, int len);
 extern int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid);
 extern void drm_mode_probed_add(struct drm_connector *connector, struct drm_display_mode *mode);
 extern void drm_mode_remove(struct drm_connector *connector, struct drm_display_mode *mode);

commit 3c537889e17232e9073f75ae8710ea0f008c5a29
Author: Alex Deucher <alexdeucher@gmail.com>
Date:   Fri Feb 5 04:21:19 2010 -0500

    drm/radeon/kms: add support for hardcoded edids in rom (v2)
    
    Some servers hardcode an edid in rom so that they will
    work properly with KVMs.  This is a port of the relevant
    code from the ddx.
    
    [airlied: reworked to validate edid at boot stage - and
    remove special quirk, if there is a valid EDID in the BIOS rom
    we'll just try and use it.]
    
    Signed-off-by: Alex Deucher <alexdeucher@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index fdf43abc36db..1347524a8e30 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -801,4 +801,6 @@ extern struct drm_display_mode *drm_gtf_mode(struct drm_device *dev,
 				bool interlaced, int margins);
 extern int drm_add_modes_noedid(struct drm_connector *connector,
 				int hdisplay, int vdisplay);
+
+extern bool drm_edid_is_valid(struct edid *edid);
 #endif /* __DRM_CRTC_H__ */

commit 3ff99164f67aae78a2bd2313f65ad55bddb1ffea
Merge: 1bd049fa895f f2b115e69d46
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Dec 8 14:03:47 2009 +1000

    Merge remote branch 'anholt/drm-intel-next' into drm-linus
    
    This merges the upstream Intel tree and fixes up numerous conflicts
    due to patches merged into Linus tree later in -rc cycle.
    
    Conflicts:
            drivers/char/agp/intel-agp.c
            drivers/gpu/drm/drm_dp_i2c_helper.c
            drivers/gpu/drm/i915/i915_irq.c
            drivers/gpu/drm/i915/i915_suspend.c

commit 884840aa3ce3214259e69557be5b4ce0d781ffa4
Author: Jakob Bornecrantz <jakob@vmware.com>
Date:   Thu Dec 3 23:25:47 2009 +0000

    drm: Add dirty ioctl and property
    
    This commit adds a ioctl and property to allow userspace
    to notify the kernel that a framebuffer has changed. Instead
    of snooping the command stream this allows finer grained
    tracking of which areas have changed.
    
    The primary user for this functionality is virtual hardware
    like the vmware svga device, but also Xen hardware likes to
    be notify. There is also real hardware like DisplayLink and
    DisplayPort that might take advantage of this ioctl.
    
    Signed-off-by: Jakob Bornecrantz <jakob@vmware.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 938f327a2a3b..219f075d2733 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -242,6 +242,21 @@ struct drm_framebuffer_funcs {
 	int (*create_handle)(struct drm_framebuffer *fb,
 			     struct drm_file *file_priv,
 			     unsigned int *handle);
+	/**
+	 * Optinal callback for the dirty fb ioctl.
+	 *
+	 * Userspace can notify the driver via this callback
+	 * that a area of the framebuffer has changed and should
+	 * be flushed to the display hardware.
+	 *
+	 * See documentation in drm_mode.h for the struct
+	 * drm_mode_fb_dirty_cmd for more information as all
+	 * the semantics and arguments have a one to one mapping
+	 * on this function.
+	 */
+	int (*dirty)(struct drm_framebuffer *framebuffer, unsigned flags,
+		     unsigned color, struct drm_clip_rect *clips,
+		     unsigned num_clips);
 };
 
 struct drm_framebuffer {
@@ -610,6 +625,7 @@ struct drm_mode_config {
 	/* Optional properties */
 	struct drm_property *scaling_mode_property;
 	struct drm_property *dithering_mode_property;
+	struct drm_property *dirty_info_property;
 };
 
 #define obj_to_crtc(x) container_of(x, struct drm_crtc, base)
@@ -718,6 +734,7 @@ extern int drm_mode_create_tv_properties(struct drm_device *dev, int num_formats
 				     char *formats[]);
 extern int drm_mode_create_scaling_mode_property(struct drm_device *dev);
 extern int drm_mode_create_dithering_property(struct drm_device *dev);
+extern int drm_mode_create_dirty_info_property(struct drm_device *dev);
 extern char *drm_get_encoder_name(struct drm_encoder *encoder);
 
 extern int drm_mode_connector_attach_encoder(struct drm_connector *connector,
@@ -745,6 +762,8 @@ extern int drm_mode_rmfb(struct drm_device *dev,
 			 void *data, struct drm_file *file_priv);
 extern int drm_mode_getfb(struct drm_device *dev,
 			  void *data, struct drm_file *file_priv);
+extern int drm_mode_dirtyfb_ioctl(struct drm_device *dev,
+				  void *data, struct drm_file *file_priv);
 extern int drm_mode_addmode_ioctl(struct drm_device *dev,
 				  void *data, struct drm_file *file_priv);
 extern int drm_mode_rmmode_ioctl(struct drm_device *dev,

commit 7ac96a9cb4982140e206bf3b58236efb2498ab3f
Author: Adam Jackson <ajax@redhat.com>
Date:   Thu Dec 3 17:44:37 2009 -0500

    drm/modes: Add drm_mode_hsync()
    
    Signed-off-by: Adam Jackson <ajax@redhat.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index d84fba15c9d8..938f327a2a3b 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -123,7 +123,7 @@ struct drm_display_mode {
 	int type;
 
 	/* Proposed mode values */
-	int clock;
+	int clock;		/* in kHz */
 	int hdisplay;
 	int hsync_start;
 	int hsync_end;
@@ -164,8 +164,8 @@ struct drm_display_mode {
 	int *private;
 	int private_flags;
 
-	int vrefresh;
-	float hsync;
+	int vrefresh;		/* in Hz */
+	int hsync;		/* in kHz */
 };
 
 enum drm_connector_status {
@@ -681,6 +681,7 @@ extern void drm_mode_validate_size(struct drm_device *dev,
 extern void drm_mode_prune_invalid(struct drm_device *dev,
 				   struct list_head *mode_list, bool verbose);
 extern void drm_mode_sort(struct list_head *mode_list);
+extern int drm_mode_hsync(struct drm_display_mode *mode);
 extern int drm_mode_vrefresh(struct drm_display_mode *mode);
 extern void drm_mode_set_crtcinfo(struct drm_display_mode *p,
 				  int adjust_flags);

commit f40d6817a5c2bf84f5fe7b5d1a83f1e8f8669951
Merge: 103a196f4224 46557bef3f38
Author: Eric Anholt <eric@anholt.net>
Date:   Tue Dec 1 09:01:54 2009 -0800

    Merge remote branch 'airlied/drm-next' into drm-intel-next

commit 7a654158bdf9dc318fd451fbf606ed100d6ba25f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Nov 4 09:42:56 2009 +0100

    drm: set the type of the drm_framebuffer::fbdev field
    
    The fbdev field of the drm_framebuffer structure is always used to store
    a pointer to a fb_info, so there is no reason for it to be void*.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 4cc8a32dc4cf..d84fba15c9d8 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -256,7 +256,7 @@ struct drm_framebuffer {
 	unsigned int depth;
 	int bits_per_pixel;
 	int flags;
-	void *fbdev;
+	struct fb_info *fbdev;
 	u32 pseudo_palette[17];
 	struct list_head filp_head;
 	/* if you are using the helper */

commit d91d8a3f88059d93e34ac70d059153ec69a9ffc7
Author: Kristian Høgsberg <krh@bitplanet.net>
Date:   Tue Nov 17 12:43:55 2009 -0500

    drm/kms: add page flipping ioctl
    
    This adds a page flipping ioctl to the KMS API.  The ioctl takes an fb ID
    and a ctrc ID and flips the crtc to the given fb at the next vblank.
    The ioctl returns immediately but the flip doesn't happen until after
    any rendering that's currently queued up against the new framebuffer
    is done.  After submitting a page flip, any execbuffer involving the
    old front buffer will block until the flip is completed.
    
    Optionally, a vblank event can be generated when the swap eventually
    happens.
    
    Signed-off-by: Kristian Høgsberg <krh@bitplanet.net>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b69347b8904f..4cc8a32dc4cf 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -290,6 +290,7 @@ struct drm_property {
 struct drm_crtc;
 struct drm_connector;
 struct drm_encoder;
+struct drm_pending_vblank_event;
 
 /**
  * drm_crtc_funcs - control CRTCs for a given device
@@ -333,6 +334,19 @@ struct drm_crtc_funcs {
 	void (*destroy)(struct drm_crtc *crtc);
 
 	int (*set_config)(struct drm_mode_set *set);
+
+	/*
+	 * Flip to the given framebuffer.  This implements the page
+	 * flip ioctl descibed in drm_mode.h, specifically, the
+	 * implementation must return immediately and block all
+	 * rendering to the current fb until the flip has completed.
+	 * If userspace set the event flag in the ioctl, the event
+	 * argument will point to an event to send back when the flip
+	 * completes, otherwise it will be NULL.
+	 */
+	int (*page_flip)(struct drm_crtc *crtc,
+			 struct drm_framebuffer *fb,
+			 struct drm_pending_vblank_event *event);
 };
 
 /**
@@ -756,6 +770,8 @@ extern int drm_mode_gamma_get_ioctl(struct drm_device *dev,
 extern int drm_mode_gamma_set_ioctl(struct drm_device *dev,
 				    void *data, struct drm_file *file_priv);
 extern bool drm_detect_hdmi_monitor(struct edid *edid);
+extern int drm_mode_page_flip_ioctl(struct drm_device *dev,
+				    void *data, struct drm_file *file_priv);
 extern struct drm_display_mode *drm_cvt_mode(struct drm_device *dev,
 				int hdisplay, int vdisplay, int vrefresh,
 				bool reduced, bool interlaced, bool margins);

commit 7a9c906094de8b3dc227de448019dbc386cd25d4
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Sep 15 22:57:31 2009 +0200

    drm: make drm_mode_object_find typesafe
    
    I've wasted half a day hunting a bug that could easily be spotted by
    gcc. Prevent this from reoccurring.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b69347b8904f..bfcc60d101db 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -711,7 +711,8 @@ extern void drm_mode_connector_detach_encoder(struct drm_connector *connector,
 					   struct drm_encoder *encoder);
 extern bool drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,
 					 int gamma_size);
-extern void *drm_mode_object_find(struct drm_device *dev, uint32_t id, uint32_t type);
+extern struct drm_mode_object *drm_mode_object_find(struct drm_device *dev,
+		uint32_t id, uint32_t type);
 /* IOCTLs */
 extern int drm_mode_getresources(struct drm_device *dev,
 				 void *data, struct drm_file *file_priv);

commit d50ba256b5f1478e15accfcfda9b72fd7a661364
Author: Dave Airlie <airlied@linux.ie>
Date:   Wed Sep 23 14:44:08 2009 +1000

    drm/kms: start adding command line interface using fb.
    
    [note this requires an fb patch posted to linux-fbdev-devel already]
    
    This uses the normal video= command line option to control the kms
    output setup at boot time. It is used to override the autodetection
    done by kms.
    
    video= normally takes a framebuffer as the first parameter, in kms
    it will take a connector name, DVI-I-1, or LVDS-1 etc. If no output
    connector is specified the mode string will apply to all connectors.
    
    The mode specification used will match down the probed modes, and if
    no mode is found it will add a CVT mode that matches.
    
    video=1024x768 - all connectors match a 1024x768 mode or add a CVT on
    video=VGA-1:1024x768, VGA-1 connector gets mode only.
    
    The same strings as used in current fb modedb.c are used, except I've
    added three more letters, e, D, d, e = enable, D = enable Digital,
    d = disable, which allow a connector to be forced into a certain state.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index ae1e9e166959..b69347b8904f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -387,6 +387,7 @@ struct drm_crtc {
  * @get_modes: get mode list for this connector
  * @set_property: property for this connector may need update
  * @destroy: make object go away
+ * @force: notify the driver the connector is forced on
  *
  * Each CRTC may have one or more connectors attached to it.  The functions
  * below allow the core DRM code to control connectors, enumerate available modes,
@@ -401,6 +402,7 @@ struct drm_connector_funcs {
 	int (*set_property)(struct drm_connector *connector, struct drm_property *property,
 			     uint64_t val);
 	void (*destroy)(struct drm_connector *connector);
+	void (*force)(struct drm_connector *connector);
 };
 
 struct drm_encoder_funcs {
@@ -429,6 +431,13 @@ struct drm_encoder {
 	void *helper_private;
 };
 
+enum drm_connector_force {
+	DRM_FORCE_UNSPECIFIED,
+	DRM_FORCE_OFF,
+	DRM_FORCE_ON,         /* force on analog part normally */
+	DRM_FORCE_ON_DIGITAL, /* for DVI-I use digital connector */
+};
+
 /**
  * drm_connector - central DRM connector control structure
  * @crtc: CRTC this connector is currently connected to, NULL if none
@@ -478,9 +487,12 @@ struct drm_connector {
 
 	void *helper_private;
 
+	/* forced on connector */
+	enum drm_connector_force force;
 	uint32_t encoder_ids[DRM_CONNECTOR_MAX_ENCODER];
 	uint32_t force_encoder_id;
 	struct drm_encoder *encoder; /* currently active encoder */
+	void *fb_helper_private;
 };
 
 /**
@@ -746,7 +758,7 @@ extern int drm_mode_gamma_set_ioctl(struct drm_device *dev,
 extern bool drm_detect_hdmi_monitor(struct edid *edid);
 extern struct drm_display_mode *drm_cvt_mode(struct drm_device *dev,
 				int hdisplay, int vdisplay, int vrefresh,
-				bool reduced, bool interlaced);
+				bool reduced, bool interlaced, bool margins);
 extern struct drm_display_mode *drm_gtf_mode(struct drm_device *dev,
 				int hdisplay, int vdisplay, int vrefresh,
 				bool interlaced, int margins);

commit f0fda0a47b26aba986fe65897891956c1792b526
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Thu Sep 3 09:33:48 2009 +0800

    drm/kms: add a function that can add the mode for the output device without EDID
    
    Add a function that can be used to add the default mode for the output device
    without EDID.
    It will add the default mode that meets with the requirements of given
    hdisplay/vdisplay limit.
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index b0427a70fcbd..ae1e9e166959 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -750,4 +750,6 @@ extern struct drm_display_mode *drm_cvt_mode(struct drm_device *dev,
 extern struct drm_display_mode *drm_gtf_mode(struct drm_device *dev,
 				int hdisplay, int vdisplay, int vrefresh,
 				bool interlaced, int margins);
+extern int drm_add_modes_noedid(struct drm_connector *connector,
+				int hdisplay, int vdisplay);
 #endif /* __DRM_CRTC_H__ */

commit 785b93ef8c309730c2de84ce9c229e40e2d01480
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Aug 28 15:46:53 2009 +1000

    drm/kms: move driver specific fb common code to helper functions (v2)
    
    Initially I always meant this code to be shared, but things
    ran away from me before I got to it.
    
    This refactors the i915 and radeon kms fbdev interaction layers
    out into generic helpers + driver specific pieces.
    
    It moves all the panic/sysrq enhancements to the core file,
    and stores a linked list of kernel fbs. This could possibly be
    improved to only store the fb which has fbcon on it for panics
    etc.
    
    radeon retains some specific codes used for a big endian
    workaround.
    
    changes:
    fix oops in v1
    fix freeing path for crtc_info
    
    Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index db92a83f8ca9..b0427a70fcbd 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -259,6 +259,8 @@ struct drm_framebuffer {
 	void *fbdev;
 	u32 pseudo_palette[17];
 	struct list_head filp_head;
+	/* if you are using the helper */
+	void *helper_private;
 };
 
 struct drm_property_blob {

commit a75f0236292a5fca65f26efedca48bd07db1834d
Author: Francisco Jerez <currojerez@riseup.net>
Date:   Wed Aug 12 02:30:10 2009 +0200

    drm: Add more standard TV properties.
    
    Overscan, saturation, hue. Used in the nouveau driver for GPUs with
    integrated TV encoders.
    
    Signed-off-by: Francisco Jerez <currojerez@riseup.net>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 5f2cc0ca4c7d..db92a83f8ca9 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -575,6 +575,9 @@ struct drm_mode_config {
 	struct drm_property *tv_brightness_property;
 	struct drm_property *tv_contrast_property;
 	struct drm_property *tv_flicker_reduction_property;
+	struct drm_property *tv_overscan_property;
+	struct drm_property *tv_saturation_property;
+	struct drm_property *tv_hue_property;
 
 	/* Optional properties */
 	struct drm_property *scaling_mode_property;

commit b6b7902e54c7e8abbc213d8bdc290350c00ccfe5
Author: Francisco Jerez <currojerez@riseup.net>
Date:   Sun Aug 2 04:19:20 2009 +0200

    drm: Define some new standard TV properties.
    
    Namely "brightness", "contrast" and "flicker reduction".
    
    Signed-off-by: Francisco Jerez <currojerez@riseup.net>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 125994d8ac0b..5f2cc0ca4c7d 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -572,6 +572,9 @@ struct drm_mode_config {
 	struct drm_property *tv_right_margin_property;
 	struct drm_property *tv_top_margin_property;
 	struct drm_property *tv_bottom_margin_property;
+	struct drm_property *tv_brightness_property;
+	struct drm_property *tv_contrast_property;
+	struct drm_property *tv_flicker_reduction_property;
 
 	/* Optional properties */
 	struct drm_property *scaling_mode_property;

commit 26bbdadad356ec02d33657858d91675f3e9aca94
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Mon Jun 22 13:17:09 2009 +0800

    drm/mode: add the GTF algorithm in kernel space
    
    Add the GTF algorithm in kernel space. And this function can be called to
    generate the required modeline.
    
    I copied it from the file of xserver/hw/xfree86/modes/xf86gtf.c. What I have
    done is to translate it by using integer calculation. This is to avoid
    the float-point calculation in kernel space.
    At the same tie I also refer to the function of fb_get_mode in
    drivers/video/fbmon.c
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Dave Airlie <airlied@linux.ie>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 820bc0977e5e..125994d8ac0b 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -739,4 +739,7 @@ extern bool drm_detect_hdmi_monitor(struct edid *edid);
 extern struct drm_display_mode *drm_cvt_mode(struct drm_device *dev,
 				int hdisplay, int vdisplay, int vrefresh,
 				bool reduced, bool interlaced);
+extern struct drm_display_mode *drm_gtf_mode(struct drm_device *dev,
+				int hdisplay, int vdisplay, int vrefresh,
+				bool interlaced, int margins);
 #endif /* __DRM_CRTC_H__ */

commit d782c3f95c9263dc0b98e7115f75f1e18b9600b3
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Mon Jun 22 13:17:08 2009 +0800

    drm/mode: add the CVT algorithm in kernel space
    
    Add the CVT algorithm in kernel space. And this function can be called to
    generate the required modeline.
    
    I copied it from the file of xserver/hw/xfree86/modes/xf86cvt.c. What I have
    done is to translate it by using integer calculation. This is to avoid
    the float-point calculation in kernel space.
    
    [airlied:- cleaned up some bits]
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Dave Airlie <airlied@linux.ie>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 7300fb866767..820bc0977e5e 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -736,4 +736,7 @@ extern int drm_mode_gamma_get_ioctl(struct drm_device *dev,
 extern int drm_mode_gamma_set_ioctl(struct drm_device *dev,
 				    void *data, struct drm_file *file_priv);
 extern bool drm_detect_hdmi_monitor(struct edid *edid);
+extern struct drm_display_mode *drm_cvt_mode(struct drm_device *dev,
+				int hdisplay, int vdisplay, int vrefresh,
+				bool reduced, bool interlaced);
 #endif /* __DRM_CRTC_H__ */

commit c9fb15f60eb517c958dec64dca9357bf62bf2201
Author: Keith Packard <keithp@keithp.com>
Date:   Sat May 30 20:42:28 2009 -0700

    drm: Hook up DPMS property handling in drm_crtc.c. Add drm_helper_connector_dpms.
    
    Making the drm_crtc.c code recognize the DPMS property and invoke the
    connector->dpms function doesn't remove any capability from the driver while
    reducing code duplication.
    
    That just highlighted the problem with the existing DPMS functions which
    could turn off the connector, but failed to turn off any relevant crtcs. The
    new drm_helper_connector_dpms function manages all of that, using the
    drm_helper-specific crtc and encoder dpms functions, automatically computing
    the appropriate DPMS level for each object in the system.
    
    This fixes the current troubles in the i915 driver which left PLLs, pipes
    and planes running while in DPMS_OFF mode or even while they were unused.
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 3c1924c010e8..7300fb866767 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -471,6 +471,9 @@ struct drm_connector {
 	u32 property_ids[DRM_CONNECTOR_MAX_PROPERTY];
 	uint64_t property_values[DRM_CONNECTOR_MAX_PROPERTY];
 
+	/* requested DPMS state */
+	int dpms;
+
 	void *helper_private;
 
 	uint32_t encoder_ids[DRM_CONNECTOR_MAX_ENCODER];

commit f23c20c83d523e5f8cda1f8f7ed52fe6afffbe29
Author: Ma Ling <ling.ma@intel.com>
Date:   Thu Mar 26 19:26:23 2009 +0800

    drm: detect hdmi monitor by hdmi identifier (v3)
    
    Sometime we need to communicate with HDMI monitor by sending audio or video
    info frame, so we have to know monitor type. However if user utilize HDMI-DVI adapter to connect DVI monitor, hardware detection will incorrectly show the monitor is HDMI. HDMI spec tell us that any device containing IEEE registration Identifier will be treated as HDMI device.  The patch intends to detect HDMI monitor by this rule.
    
    Signed-off-by: Ma Ling <ling.ma@intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 9022b2468182..3c1924c010e8 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -732,4 +732,5 @@ extern int drm_mode_gamma_get_ioctl(struct drm_device *dev,
 				    void *data, struct drm_file *file_priv);
 extern int drm_mode_gamma_set_ioctl(struct drm_device *dev,
 				    void *data, struct drm_file *file_priv);
+extern bool drm_detect_hdmi_monitor(struct edid *edid);
 #endif /* __DRM_CRTC_H__ */

commit 167f3a04d7366d65c7fa9a92f0d604cdcf4a11ae
Author: Ma Ling <ling.ma@intel.com>
Date:   Fri Mar 20 14:09:48 2009 +0800

    drm: read EDID extensions from monitor
    
    Usually drm read basic EDID, that is enough for us, but since igital display
    were introduced i.e. HDMI monitor, sometime we need to interact with monitor by
    EDID extension information,
    
    EDID extensions include audio/video data block, speaker allocation and vendor specific data blocks.
    
    This patch intends to read EDID extensions from digital monitor for users.
    
    Signed-off-by: Ma Ling <ling.ma@intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 33ae98ced80e..9022b2468182 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -613,7 +613,8 @@ extern void drm_fb_release(struct drm_file *file_priv);
 extern int drm_mode_group_init_legacy_group(struct drm_device *dev, struct drm_mode_group *group);
 extern struct edid *drm_get_edid(struct drm_connector *connector,
 				 struct i2c_adapter *adapter);
-extern unsigned char *drm_do_probe_ddc_edid(struct i2c_adapter *adapter);
+extern int drm_do_probe_ddc_edid(struct i2c_adapter *adapter,
+				 unsigned char *buf, int len);
 extern int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid);
 extern void drm_mode_probed_add(struct drm_connector *connector, struct drm_display_mode *mode);
 extern void drm_mode_remove(struct drm_connector *connector, struct drm_display_mode *mode);

commit d883f7f1b75c8dcafa891f7b9e69c5a2f0ff6d66
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Feb 2 16:55:45 2009 +1100

    drm: Use resource_size_t for drm_get_resource_{start, len}
    
    The DRM uses its own wrappers to obtain resources from PCI devices,
    which currently convert the resource_size_t into an unsigned long.
    
    This is broken on 32-bit platforms with >32-bit physical address
    space.
    
    This fixes them, along with a few occurences of unsigned long used
    to store such a resource in drivers.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Dave Airlie <airlied@linux.ie>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 5ded1acfb543..33ae98ced80e 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -550,7 +550,7 @@ struct drm_mode_config {
 	int min_width, min_height;
 	int max_width, max_height;
 	struct drm_mode_config_funcs *funcs;
-	unsigned long fb_base;
+	resource_size_t fb_base;
 
 	/* pointers to standard properties */
 	struct list_head property_blob_list;

commit ea39f835168f60b01e59d0f348da25d297e7cf94
Author: Kristian Høgsberg <krh@redhat.com>
Date:   Thu Feb 12 14:37:56 2009 -0500

    drm: Release user fbs in drm_release
    
    Avoids leaking fbs and associated buffers on release.
    
    Signed-off-by: Kristian Høgsberg <krh@redhat.com>
    Tested-by: Tested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Dave Airlie <airlied@linux.ie>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index d54de24bf371..5ded1acfb543 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -609,7 +609,7 @@ extern char *drm_get_dvi_i_subconnector_name(int val);
 extern char *drm_get_dvi_i_select_name(int val);
 extern char *drm_get_tv_subconnector_name(int val);
 extern char *drm_get_tv_select_name(int val);
-extern void drm_fb_release(struct file *filp);
+extern void drm_fb_release(struct drm_file *file_priv);
 extern int drm_mode_group_init_legacy_group(struct drm_device *dev, struct drm_mode_group *group);
 extern struct edid *drm_get_edid(struct drm_connector *connector,
 				 struct i2c_adapter *adapter);

commit ad2563c2e42fc67b0976aeb70e9f3faf1c1196e8
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Jan 19 17:21:45 2009 +1000

    drm: create mode_config idr lock
    
    Create a separate mode_config IDR lock for simplicity.  The core DRM
    config structures (connector, mode, etc. lists) are still protected by
    the mode_config mutex, but the CRTC IDR (used for the various identifier
    IDs) is now protected by the mode_config idr_mutex.  Simplifies the
    locking a bit and removes a warning.
    
    All objects are protected by the config mutex, we may in the future,
    split the object further to have reference counts.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 47809ac94bc3..d54de24bf371 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -528,7 +528,8 @@ struct drm_mode_group {
  *
  */
 struct drm_mode_config {
-	struct mutex mutex; /* protects configuration and IDR */
+	struct mutex mutex; /* protects configuration (mode lists etc.) */
+	struct mutex idr_mutex; /* for IDR management */
 	struct idr crtc_idr; /* use this idr for all IDs, fb, crtc, connector, modes - just makes life easier */
 	/* this is limited to one for now */
 	int num_fb;

commit 40a518d9f1fd8ed1061b8b4e2ce8a44794f4eb03
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Jan 12 12:05:32 2009 -0800

    drm: initial KMS config fixes
    
    When mode setting is first initialized, the driver will call into
    drm_helper_initial_config() to set up an initial output and framebuffer
    configuration.  This routine is responsible for probing the available
    connectors, encoders, and crtcs, looking for modes and putting together
    something reasonable (where reasonable is defined as "allows kernel
    messages to be visible on as many displays as possible").
    
    However, the code was a bit too aggressive in setting default modes when
    none were found on a given connector.  Even if some connectors had modes,
    any connectors found lacking modes would have the default 800x600 mode added
    to their mode list, which in some cases could cause problems later down the
    line.  In my case, the LVDS was perfectly available, but the initial config
    code added 800x600 modes to both of the detected but unavailable HDMI
    connectors (which are on my non-existent docking station).  This ended up
    preventing later code from setting a mode on my LVDS, which is bad.
    
    This patch fixes that behavior by making the initial config code walk
    through the connectors first, counting the available modes, before it decides
    to add any default modes to a possibly connected output.  It also fixes the
    logic in drm_target_preferred() that was causing zeroed out modes to be set
    as the preferred mode for a given connector, even if no modes were available.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Dave Airlie <airlied@linux.ie>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 0acb07f31fa4..47809ac94bc3 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -395,7 +395,7 @@ struct drm_connector_funcs {
 	void (*save)(struct drm_connector *connector);
 	void (*restore)(struct drm_connector *connector);
 	enum drm_connector_status (*detect)(struct drm_connector *connector);
-	void (*fill_modes)(struct drm_connector *connector, uint32_t max_width, uint32_t max_height);
+	int (*fill_modes)(struct drm_connector *connector, uint32_t max_width, uint32_t max_height);
 	int (*set_property)(struct drm_connector *connector, struct drm_property *property,
 			     uint64_t val);
 	void (*destroy)(struct drm_connector *connector);

commit 0c7c26647579e9e647e8b969bb0e7b3f5f1a1492
Author: Kristian H�gsberg <krh@redhat.com>
Date:   Thu Dec 18 13:14:37 2008 +1000

    drm: drop DRM_IOCTL_MODE_REPLACEFB, add+remove works just as well.
    
    The replace fb ioctl replaces the backing buffer object for a modesetting
    framebuffer object.  This can be acheived by just creating a new
    framebuffer backed by the new buffer object, setting that for the crtcs
    in question and then removing the old framebuffer object.
    
    Signed-off-by: Kristian Hogsberg <krh@redhat.com>
    Acked-by: Jakob Bornecrantz <jakob@vmware.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 395c6139c893..0acb07f31fa4 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -510,7 +510,6 @@ struct drm_mode_set {
  * the CRTC<->connector mappings as needed and update its view of the screen.
  */
 struct drm_mode_config_funcs {
-	int (*resize_fb)(struct drm_device *dev, struct drm_file *file_priv, struct drm_framebuffer *fb, struct drm_mode_fb_cmd *mode_cmd);
 	struct drm_framebuffer *(*fb_create)(struct drm_device *dev, struct drm_file *file_priv, struct drm_mode_fb_cmd *mode_cmd);
 	int (*fb_changed)(struct drm_device *dev);
 };

commit e0c8463a8b00b467611607df0ff369d062528875
Author: Jakob Bornecrantz <jakob@tungstengraphics.com>
Date:   Fri Dec 19 14:50:50 2008 +1000

    drm: sanitise drm modesetting API + remove unused hotplug
    
    The initially merged modesetting API has some uglies in it, this
    cleans up the struct members and ioctl ordering for initial submission.
    
    It also removes the unneeded hotplug infrastructure.
    
    airlied:- I've pulled this patch in from git modesetting-gem tree.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 08a884bea446..395c6139c893 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -573,9 +573,6 @@ struct drm_mode_config {
 	/* Optional properties */
 	struct drm_property *scaling_mode_property;
 	struct drm_property *dithering_mode_property;
-
-	/* hotplug */
-	uint32_t hotplug_counter;
 };
 
 #define obj_to_crtc(x) container_of(x, struct drm_crtc, base)

commit f453ba0460742ad027ae0c4c7d61e62817b3e7ef
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Nov 7 14:05:41 2008 -0800

    DRM: add mode setting support
    
    Add mode setting support to the DRM layer.
    
    This is a fairly big chunk of work that allows DRM drivers to provide
    full output control and configuration capabilities to userspace.  It was
    motivated by several factors:
      - the fb layer's APIs aren't suited for anything but simple
        configurations
      - coordination between the fb layer, DRM layer, and various userspace
        drivers is poor to non-existent (radeonfb excepted)
      - user level mode setting drivers makes displaying panic & oops
        messages more difficult
      - suspend/resume of graphics state is possible in many more
        configurations with kernel level support
    
    This commit just adds the core DRM part of the mode setting APIs.
    Driver specific commits using these new structure and APIs will follow.
    
    Co-authors: Jesse Barnes <jbarnes@virtuousgeek.org>, Jakob Bornecrantz <jakob@tungstengraphics.com>
    Contributors: Alan Hourihane <alanh@tungstengraphics.com>, Maarten Maathuis <madman2003@gmail.com>
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
new file mode 100644
index 000000000000..08a884bea446
--- /dev/null
+++ b/include/drm/drm_crtc.h
@@ -0,0 +1,737 @@
+/*
+ * Copyright © 2006 Keith Packard
+ * Copyright © 2007-2008 Dave Airlie
+ * Copyright © 2007-2008 Intel Corporation
+ *   Jesse Barnes <jesse.barnes@intel.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef __DRM_CRTC_H__
+#define __DRM_CRTC_H__
+
+#include <linux/i2c.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <linux/idr.h>
+
+#include <linux/fb.h>
+
+struct drm_device;
+struct drm_mode_set;
+struct drm_framebuffer;
+
+
+#define DRM_MODE_OBJECT_CRTC 0xcccccccc
+#define DRM_MODE_OBJECT_CONNECTOR 0xc0c0c0c0
+#define DRM_MODE_OBJECT_ENCODER 0xe0e0e0e0
+#define DRM_MODE_OBJECT_MODE 0xdededede
+#define DRM_MODE_OBJECT_PROPERTY 0xb0b0b0b0
+#define DRM_MODE_OBJECT_FB 0xfbfbfbfb
+#define DRM_MODE_OBJECT_BLOB 0xbbbbbbbb
+
+struct drm_mode_object {
+	uint32_t id;
+	uint32_t type;
+};
+
+/*
+ * Note on terminology:  here, for brevity and convenience, we refer to connector
+ * control chips as 'CRTCs'.  They can control any type of connector, VGA, LVDS,
+ * DVI, etc.  And 'screen' refers to the whole of the visible display, which
+ * may span multiple monitors (and therefore multiple CRTC and connector
+ * structures).
+ */
+
+enum drm_mode_status {
+    MODE_OK	= 0,	/* Mode OK */
+    MODE_HSYNC,		/* hsync out of range */
+    MODE_VSYNC,		/* vsync out of range */
+    MODE_H_ILLEGAL,	/* mode has illegal horizontal timings */
+    MODE_V_ILLEGAL,	/* mode has illegal horizontal timings */
+    MODE_BAD_WIDTH,	/* requires an unsupported linepitch */
+    MODE_NOMODE,	/* no mode with a maching name */
+    MODE_NO_INTERLACE,	/* interlaced mode not supported */
+    MODE_NO_DBLESCAN,	/* doublescan mode not supported */
+    MODE_NO_VSCAN,	/* multiscan mode not supported */
+    MODE_MEM,		/* insufficient video memory */
+    MODE_VIRTUAL_X,	/* mode width too large for specified virtual size */
+    MODE_VIRTUAL_Y,	/* mode height too large for specified virtual size */
+    MODE_MEM_VIRT,	/* insufficient video memory given virtual size */
+    MODE_NOCLOCK,	/* no fixed clock available */
+    MODE_CLOCK_HIGH,	/* clock required is too high */
+    MODE_CLOCK_LOW,	/* clock required is too low */
+    MODE_CLOCK_RANGE,	/* clock/mode isn't in a ClockRange */
+    MODE_BAD_HVALUE,	/* horizontal timing was out of range */
+    MODE_BAD_VVALUE,	/* vertical timing was out of range */
+    MODE_BAD_VSCAN,	/* VScan value out of range */
+    MODE_HSYNC_NARROW,	/* horizontal sync too narrow */
+    MODE_HSYNC_WIDE,	/* horizontal sync too wide */
+    MODE_HBLANK_NARROW,	/* horizontal blanking too narrow */
+    MODE_HBLANK_WIDE,	/* horizontal blanking too wide */
+    MODE_VSYNC_NARROW,	/* vertical sync too narrow */
+    MODE_VSYNC_WIDE,	/* vertical sync too wide */
+    MODE_VBLANK_NARROW,	/* vertical blanking too narrow */
+    MODE_VBLANK_WIDE,	/* vertical blanking too wide */
+    MODE_PANEL,         /* exceeds panel dimensions */
+    MODE_INTERLACE_WIDTH, /* width too large for interlaced mode */
+    MODE_ONE_WIDTH,     /* only one width is supported */
+    MODE_ONE_HEIGHT,    /* only one height is supported */
+    MODE_ONE_SIZE,      /* only one resolution is supported */
+    MODE_NO_REDUCED,    /* monitor doesn't accept reduced blanking */
+    MODE_UNVERIFIED = -3, /* mode needs to reverified */
+    MODE_BAD = -2,	/* unspecified reason */
+    MODE_ERROR	= -1	/* error condition */
+};
+
+#define DRM_MODE_TYPE_CLOCK_CRTC_C (DRM_MODE_TYPE_CLOCK_C | \
+				    DRM_MODE_TYPE_CRTC_C)
+
+#define DRM_MODE(nm, t, c, hd, hss, hse, ht, hsk, vd, vss, vse, vt, vs, f) \
+	.name = nm, .status = 0, .type = (t), .clock = (c), \
+	.hdisplay = (hd), .hsync_start = (hss), .hsync_end = (hse), \
+	.htotal = (ht), .hskew = (hsk), .vdisplay = (vd), \
+	.vsync_start = (vss), .vsync_end = (vse), .vtotal = (vt), \
+	.vscan = (vs), .flags = (f), .vrefresh = 0
+
+#define CRTC_INTERLACE_HALVE_V 0x1 /* halve V values for interlacing */
+
+struct drm_display_mode {
+	/* Header */
+	struct list_head head;
+	struct drm_mode_object base;
+
+	char name[DRM_DISPLAY_MODE_LEN];
+
+	int connector_count;
+	enum drm_mode_status status;
+	int type;
+
+	/* Proposed mode values */
+	int clock;
+	int hdisplay;
+	int hsync_start;
+	int hsync_end;
+	int htotal;
+	int hskew;
+	int vdisplay;
+	int vsync_start;
+	int vsync_end;
+	int vtotal;
+	int vscan;
+	unsigned int flags;
+
+	/* Addressable image size (may be 0 for projectors, etc.) */
+	int width_mm;
+	int height_mm;
+
+	/* Actual mode we give to hw */
+	int clock_index;
+	int synth_clock;
+	int crtc_hdisplay;
+	int crtc_hblank_start;
+	int crtc_hblank_end;
+	int crtc_hsync_start;
+	int crtc_hsync_end;
+	int crtc_htotal;
+	int crtc_hskew;
+	int crtc_vdisplay;
+	int crtc_vblank_start;
+	int crtc_vblank_end;
+	int crtc_vsync_start;
+	int crtc_vsync_end;
+	int crtc_vtotal;
+	int crtc_hadjusted;
+	int crtc_vadjusted;
+
+	/* Driver private mode info */
+	int private_size;
+	int *private;
+	int private_flags;
+
+	int vrefresh;
+	float hsync;
+};
+
+enum drm_connector_status {
+	connector_status_connected = 1,
+	connector_status_disconnected = 2,
+	connector_status_unknown = 3,
+};
+
+enum subpixel_order {
+	SubPixelUnknown = 0,
+	SubPixelHorizontalRGB,
+	SubPixelHorizontalBGR,
+	SubPixelVerticalRGB,
+	SubPixelVerticalBGR,
+	SubPixelNone,
+};
+
+
+/*
+ * Describes a given display (e.g. CRT or flat panel) and its limitations.
+ */
+struct drm_display_info {
+	char name[DRM_DISPLAY_INFO_LEN];
+	/* Input info */
+	bool serration_vsync;
+	bool sync_on_green;
+	bool composite_sync;
+	bool separate_syncs;
+	bool blank_to_black;
+	unsigned char video_level;
+	bool digital;
+	/* Physical size */
+        unsigned int width_mm;
+	unsigned int height_mm;
+
+	/* Display parameters */
+	unsigned char gamma; /* FIXME: storage format */
+	bool gtf_supported;
+	bool standard_color;
+	enum {
+		monochrome = 0,
+		rgb,
+		other,
+		unknown,
+	} display_type;
+	bool active_off_supported;
+	bool suspend_supported;
+	bool standby_supported;
+
+	/* Color info FIXME: storage format */
+	unsigned short redx, redy;
+	unsigned short greenx, greeny;
+	unsigned short bluex, bluey;
+	unsigned short whitex, whitey;
+
+	/* Clock limits FIXME: storage format */
+	unsigned int min_vfreq, max_vfreq;
+	unsigned int min_hfreq, max_hfreq;
+	unsigned int pixel_clock;
+
+	/* White point indices FIXME: storage format */
+	unsigned int wpx1, wpy1;
+	unsigned int wpgamma1;
+	unsigned int wpx2, wpy2;
+	unsigned int wpgamma2;
+
+	enum subpixel_order subpixel_order;
+
+	char *raw_edid; /* if any */
+};
+
+struct drm_framebuffer_funcs {
+	void (*destroy)(struct drm_framebuffer *framebuffer);
+	int (*create_handle)(struct drm_framebuffer *fb,
+			     struct drm_file *file_priv,
+			     unsigned int *handle);
+};
+
+struct drm_framebuffer {
+	struct drm_device *dev;
+	struct list_head head;
+	struct drm_mode_object base;
+	const struct drm_framebuffer_funcs *funcs;
+	unsigned int pitch;
+	unsigned int width;
+	unsigned int height;
+	/* depth can be 15 or 16 */
+	unsigned int depth;
+	int bits_per_pixel;
+	int flags;
+	void *fbdev;
+	u32 pseudo_palette[17];
+	struct list_head filp_head;
+};
+
+struct drm_property_blob {
+	struct drm_mode_object base;
+	struct list_head head;
+	unsigned int length;
+	void *data;
+};
+
+struct drm_property_enum {
+	uint64_t value;
+	struct list_head head;
+	char name[DRM_PROP_NAME_LEN];
+};
+
+struct drm_property {
+	struct list_head head;
+	struct drm_mode_object base;
+	uint32_t flags;
+	char name[DRM_PROP_NAME_LEN];
+	uint32_t num_values;
+	uint64_t *values;
+
+	struct list_head enum_blob_list;
+};
+
+struct drm_crtc;
+struct drm_connector;
+struct drm_encoder;
+
+/**
+ * drm_crtc_funcs - control CRTCs for a given device
+ * @dpms: control display power levels
+ * @save: save CRTC state
+ * @resore: restore CRTC state
+ * @lock: lock the CRTC
+ * @unlock: unlock the CRTC
+ * @shadow_allocate: allocate shadow pixmap
+ * @shadow_create: create shadow pixmap for rotation support
+ * @shadow_destroy: free shadow pixmap
+ * @mode_fixup: fixup proposed mode
+ * @mode_set: set the desired mode on the CRTC
+ * @gamma_set: specify color ramp for CRTC
+ * @destroy: deinit and free object.
+ *
+ * The drm_crtc_funcs structure is the central CRTC management structure
+ * in the DRM.  Each CRTC controls one or more connectors (note that the name
+ * CRTC is simply historical, a CRTC may control LVDS, VGA, DVI, TV out, etc.
+ * connectors, not just CRTs).
+ *
+ * Each driver is responsible for filling out this structure at startup time,
+ * in addition to providing other modesetting features, like i2c and DDC
+ * bus accessors.
+ */
+struct drm_crtc_funcs {
+	/* Save CRTC state */
+	void (*save)(struct drm_crtc *crtc); /* suspend? */
+	/* Restore CRTC state */
+	void (*restore)(struct drm_crtc *crtc); /* resume? */
+
+	/* cursor controls */
+	int (*cursor_set)(struct drm_crtc *crtc, struct drm_file *file_priv,
+			  uint32_t handle, uint32_t width, uint32_t height);
+	int (*cursor_move)(struct drm_crtc *crtc, int x, int y);
+
+	/* Set gamma on the CRTC */
+	void (*gamma_set)(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,
+			  uint32_t size);
+	/* Object destroy routine */
+	void (*destroy)(struct drm_crtc *crtc);
+
+	int (*set_config)(struct drm_mode_set *set);
+};
+
+/**
+ * drm_crtc - central CRTC control structure
+ * @enabled: is this CRTC enabled?
+ * @x: x position on screen
+ * @y: y position on screen
+ * @desired_mode: new desired mode
+ * @desired_x: desired x for desired_mode
+ * @desired_y: desired y for desired_mode
+ * @funcs: CRTC control functions
+ *
+ * Each CRTC may have one or more connectors associated with it.  This structure
+ * allows the CRTC to be controlled.
+ */
+struct drm_crtc {
+	struct drm_device *dev;
+	struct list_head head;
+
+	struct drm_mode_object base;
+
+	/* framebuffer the connector is currently bound to */
+	struct drm_framebuffer *fb;
+
+	bool enabled;
+
+	struct drm_display_mode mode;
+
+	int x, y;
+	struct drm_display_mode *desired_mode;
+	int desired_x, desired_y;
+	const struct drm_crtc_funcs *funcs;
+
+	/* CRTC gamma size for reporting to userspace */
+	uint32_t gamma_size;
+	uint16_t *gamma_store;
+
+	/* if you are using the helper */
+	void *helper_private;
+};
+
+
+/**
+ * drm_connector_funcs - control connectors on a given device
+ * @dpms: set power state (see drm_crtc_funcs above)
+ * @save: save connector state
+ * @restore: restore connector state
+ * @mode_valid: is this mode valid on the given connector?
+ * @mode_fixup: try to fixup proposed mode for this connector
+ * @mode_set: set this mode
+ * @detect: is this connector active?
+ * @get_modes: get mode list for this connector
+ * @set_property: property for this connector may need update
+ * @destroy: make object go away
+ *
+ * Each CRTC may have one or more connectors attached to it.  The functions
+ * below allow the core DRM code to control connectors, enumerate available modes,
+ * etc.
+ */
+struct drm_connector_funcs {
+	void (*dpms)(struct drm_connector *connector, int mode);
+	void (*save)(struct drm_connector *connector);
+	void (*restore)(struct drm_connector *connector);
+	enum drm_connector_status (*detect)(struct drm_connector *connector);
+	void (*fill_modes)(struct drm_connector *connector, uint32_t max_width, uint32_t max_height);
+	int (*set_property)(struct drm_connector *connector, struct drm_property *property,
+			     uint64_t val);
+	void (*destroy)(struct drm_connector *connector);
+};
+
+struct drm_encoder_funcs {
+	void (*destroy)(struct drm_encoder *encoder);
+};
+
+#define DRM_CONNECTOR_MAX_UMODES 16
+#define DRM_CONNECTOR_MAX_PROPERTY 16
+#define DRM_CONNECTOR_LEN 32
+#define DRM_CONNECTOR_MAX_ENCODER 2
+
+/**
+ * drm_encoder - central DRM encoder structure
+ */
+struct drm_encoder {
+	struct drm_device *dev;
+	struct list_head head;
+
+	struct drm_mode_object base;
+	int encoder_type;
+	uint32_t possible_crtcs;
+	uint32_t possible_clones;
+
+	struct drm_crtc *crtc;
+	const struct drm_encoder_funcs *funcs;
+	void *helper_private;
+};
+
+/**
+ * drm_connector - central DRM connector control structure
+ * @crtc: CRTC this connector is currently connected to, NULL if none
+ * @interlace_allowed: can this connector handle interlaced modes?
+ * @doublescan_allowed: can this connector handle doublescan?
+ * @available_modes: modes available on this connector (from get_modes() + user)
+ * @initial_x: initial x position for this connector
+ * @initial_y: initial y position for this connector
+ * @status: connector connected?
+ * @funcs: connector control functions
+ *
+ * Each connector may be connected to one or more CRTCs, or may be clonable by
+ * another connector if they can share a CRTC.  Each connector also has a specific
+ * position in the broader display (referred to as a 'screen' though it could
+ * span multiple monitors).
+ */
+struct drm_connector {
+	struct drm_device *dev;
+	struct device kdev;
+	struct device_attribute *attr;
+	struct list_head head;
+
+	struct drm_mode_object base;
+
+	int connector_type;
+	int connector_type_id;
+	bool interlace_allowed;
+	bool doublescan_allowed;
+	struct list_head modes; /* list of modes on this connector */
+
+	int initial_x, initial_y;
+	enum drm_connector_status status;
+
+	/* these are modes added by probing with DDC or the BIOS */
+	struct list_head probed_modes;
+
+	struct drm_display_info display_info;
+	const struct drm_connector_funcs *funcs;
+
+	struct list_head user_modes;
+	struct drm_property_blob *edid_blob_ptr;
+	u32 property_ids[DRM_CONNECTOR_MAX_PROPERTY];
+	uint64_t property_values[DRM_CONNECTOR_MAX_PROPERTY];
+
+	void *helper_private;
+
+	uint32_t encoder_ids[DRM_CONNECTOR_MAX_ENCODER];
+	uint32_t force_encoder_id;
+	struct drm_encoder *encoder; /* currently active encoder */
+};
+
+/**
+ * struct drm_mode_set
+ *
+ * Represents a single crtc the connectors that it drives with what mode
+ * and from which framebuffer it scans out from.
+ *
+ * This is used to set modes.
+ */
+struct drm_mode_set {
+	struct list_head head;
+
+	struct drm_framebuffer *fb;
+	struct drm_crtc *crtc;
+	struct drm_display_mode *mode;
+
+	uint32_t x;
+	uint32_t y;
+
+	struct drm_connector **connectors;
+	size_t num_connectors;
+};
+
+/**
+ * struct drm_mode_config_funcs - configure CRTCs for a given screen layout
+ * @resize: adjust CRTCs as necessary for the proposed layout
+ *
+ * Currently only a resize hook is available.  DRM will call back into the
+ * driver with a new screen width and height.  If the driver can't support
+ * the proposed size, it can return false.  Otherwise it should adjust
+ * the CRTC<->connector mappings as needed and update its view of the screen.
+ */
+struct drm_mode_config_funcs {
+	int (*resize_fb)(struct drm_device *dev, struct drm_file *file_priv, struct drm_framebuffer *fb, struct drm_mode_fb_cmd *mode_cmd);
+	struct drm_framebuffer *(*fb_create)(struct drm_device *dev, struct drm_file *file_priv, struct drm_mode_fb_cmd *mode_cmd);
+	int (*fb_changed)(struct drm_device *dev);
+};
+
+struct drm_mode_group {
+	uint32_t num_crtcs;
+	uint32_t num_encoders;
+	uint32_t num_connectors;
+
+	/* list of object IDs for this group */
+	uint32_t *id_list;
+};
+
+/**
+ * drm_mode_config - Mode configuration control structure
+ *
+ */
+struct drm_mode_config {
+	struct mutex mutex; /* protects configuration and IDR */
+	struct idr crtc_idr; /* use this idr for all IDs, fb, crtc, connector, modes - just makes life easier */
+	/* this is limited to one for now */
+	int num_fb;
+	struct list_head fb_list;
+	int num_connector;
+	struct list_head connector_list;
+	int num_encoder;
+	struct list_head encoder_list;
+
+	int num_crtc;
+	struct list_head crtc_list;
+
+	struct list_head property_list;
+
+	/* in-kernel framebuffers - hung of filp_head in drm_framebuffer */
+	struct list_head fb_kernel_list;
+
+	int min_width, min_height;
+	int max_width, max_height;
+	struct drm_mode_config_funcs *funcs;
+	unsigned long fb_base;
+
+	/* pointers to standard properties */
+	struct list_head property_blob_list;
+	struct drm_property *edid_property;
+	struct drm_property *dpms_property;
+
+	/* DVI-I properties */
+	struct drm_property *dvi_i_subconnector_property;
+	struct drm_property *dvi_i_select_subconnector_property;
+
+	/* TV properties */
+	struct drm_property *tv_subconnector_property;
+	struct drm_property *tv_select_subconnector_property;
+	struct drm_property *tv_mode_property;
+	struct drm_property *tv_left_margin_property;
+	struct drm_property *tv_right_margin_property;
+	struct drm_property *tv_top_margin_property;
+	struct drm_property *tv_bottom_margin_property;
+
+	/* Optional properties */
+	struct drm_property *scaling_mode_property;
+	struct drm_property *dithering_mode_property;
+
+	/* hotplug */
+	uint32_t hotplug_counter;
+};
+
+#define obj_to_crtc(x) container_of(x, struct drm_crtc, base)
+#define obj_to_connector(x) container_of(x, struct drm_connector, base)
+#define obj_to_encoder(x) container_of(x, struct drm_encoder, base)
+#define obj_to_mode(x) container_of(x, struct drm_display_mode, base)
+#define obj_to_fb(x) container_of(x, struct drm_framebuffer, base)
+#define obj_to_property(x) container_of(x, struct drm_property, base)
+#define obj_to_blob(x) container_of(x, struct drm_property_blob, base)
+
+
+extern void drm_crtc_init(struct drm_device *dev,
+			  struct drm_crtc *crtc,
+			  const struct drm_crtc_funcs *funcs);
+extern void drm_crtc_cleanup(struct drm_crtc *crtc);
+
+extern void drm_connector_init(struct drm_device *dev,
+			    struct drm_connector *connector,
+			    const struct drm_connector_funcs *funcs,
+			    int connector_type);
+
+extern void drm_connector_cleanup(struct drm_connector *connector);
+
+extern void drm_encoder_init(struct drm_device *dev,
+			     struct drm_encoder *encoder,
+			     const struct drm_encoder_funcs *funcs,
+			     int encoder_type);
+
+extern void drm_encoder_cleanup(struct drm_encoder *encoder);
+
+extern char *drm_get_connector_name(struct drm_connector *connector);
+extern char *drm_get_dpms_name(int val);
+extern char *drm_get_dvi_i_subconnector_name(int val);
+extern char *drm_get_dvi_i_select_name(int val);
+extern char *drm_get_tv_subconnector_name(int val);
+extern char *drm_get_tv_select_name(int val);
+extern void drm_fb_release(struct file *filp);
+extern int drm_mode_group_init_legacy_group(struct drm_device *dev, struct drm_mode_group *group);
+extern struct edid *drm_get_edid(struct drm_connector *connector,
+				 struct i2c_adapter *adapter);
+extern unsigned char *drm_do_probe_ddc_edid(struct i2c_adapter *adapter);
+extern int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid);
+extern void drm_mode_probed_add(struct drm_connector *connector, struct drm_display_mode *mode);
+extern void drm_mode_remove(struct drm_connector *connector, struct drm_display_mode *mode);
+extern struct drm_display_mode *drm_mode_duplicate(struct drm_device *dev,
+						   struct drm_display_mode *mode);
+extern void drm_mode_debug_printmodeline(struct drm_display_mode *mode);
+extern void drm_mode_config_init(struct drm_device *dev);
+extern void drm_mode_config_cleanup(struct drm_device *dev);
+extern void drm_mode_set_name(struct drm_display_mode *mode);
+extern bool drm_mode_equal(struct drm_display_mode *mode1, struct drm_display_mode *mode2);
+extern int drm_mode_width(struct drm_display_mode *mode);
+extern int drm_mode_height(struct drm_display_mode *mode);
+
+/* for us by fb module */
+extern int drm_mode_attachmode_crtc(struct drm_device *dev,
+				    struct drm_crtc *crtc,
+				    struct drm_display_mode *mode);
+extern int drm_mode_detachmode_crtc(struct drm_device *dev, struct drm_display_mode *mode);
+
+extern struct drm_display_mode *drm_mode_create(struct drm_device *dev);
+extern void drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode);
+extern void drm_mode_list_concat(struct list_head *head,
+				 struct list_head *new);
+extern void drm_mode_validate_size(struct drm_device *dev,
+				   struct list_head *mode_list,
+				   int maxX, int maxY, int maxPitch);
+extern void drm_mode_prune_invalid(struct drm_device *dev,
+				   struct list_head *mode_list, bool verbose);
+extern void drm_mode_sort(struct list_head *mode_list);
+extern int drm_mode_vrefresh(struct drm_display_mode *mode);
+extern void drm_mode_set_crtcinfo(struct drm_display_mode *p,
+				  int adjust_flags);
+extern void drm_mode_connector_list_update(struct drm_connector *connector);
+extern int drm_mode_connector_update_edid_property(struct drm_connector *connector,
+						struct edid *edid);
+extern int drm_connector_property_set_value(struct drm_connector *connector,
+					 struct drm_property *property,
+					 uint64_t value);
+extern int drm_connector_property_get_value(struct drm_connector *connector,
+					 struct drm_property *property,
+					 uint64_t *value);
+extern struct drm_display_mode *drm_crtc_mode_create(struct drm_device *dev);
+extern void drm_framebuffer_set_object(struct drm_device *dev,
+				       unsigned long handle);
+extern int drm_framebuffer_init(struct drm_device *dev,
+				struct drm_framebuffer *fb,
+				const struct drm_framebuffer_funcs *funcs);
+extern void drm_framebuffer_cleanup(struct drm_framebuffer *fb);
+extern int drmfb_probe(struct drm_device *dev, struct drm_crtc *crtc);
+extern int drmfb_remove(struct drm_device *dev, struct drm_framebuffer *fb);
+extern void drm_crtc_probe_connector_modes(struct drm_device *dev, int maxX, int maxY);
+extern bool drm_crtc_in_use(struct drm_crtc *crtc);
+
+extern int drm_connector_attach_property(struct drm_connector *connector,
+				      struct drm_property *property, uint64_t init_val);
+extern struct drm_property *drm_property_create(struct drm_device *dev, int flags,
+						const char *name, int num_values);
+extern void drm_property_destroy(struct drm_device *dev, struct drm_property *property);
+extern int drm_property_add_enum(struct drm_property *property, int index,
+				 uint64_t value, const char *name);
+extern int drm_mode_create_dvi_i_properties(struct drm_device *dev);
+extern int drm_mode_create_tv_properties(struct drm_device *dev, int num_formats,
+				     char *formats[]);
+extern int drm_mode_create_scaling_mode_property(struct drm_device *dev);
+extern int drm_mode_create_dithering_property(struct drm_device *dev);
+extern char *drm_get_encoder_name(struct drm_encoder *encoder);
+
+extern int drm_mode_connector_attach_encoder(struct drm_connector *connector,
+					     struct drm_encoder *encoder);
+extern void drm_mode_connector_detach_encoder(struct drm_connector *connector,
+					   struct drm_encoder *encoder);
+extern bool drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,
+					 int gamma_size);
+extern void *drm_mode_object_find(struct drm_device *dev, uint32_t id, uint32_t type);
+/* IOCTLs */
+extern int drm_mode_getresources(struct drm_device *dev,
+				 void *data, struct drm_file *file_priv);
+
+extern int drm_mode_getcrtc(struct drm_device *dev,
+			    void *data, struct drm_file *file_priv);
+extern int drm_mode_getconnector(struct drm_device *dev,
+			      void *data, struct drm_file *file_priv);
+extern int drm_mode_setcrtc(struct drm_device *dev,
+			    void *data, struct drm_file *file_priv);
+extern int drm_mode_cursor_ioctl(struct drm_device *dev,
+				void *data, struct drm_file *file_priv);
+extern int drm_mode_addfb(struct drm_device *dev,
+			  void *data, struct drm_file *file_priv);
+extern int drm_mode_rmfb(struct drm_device *dev,
+			 void *data, struct drm_file *file_priv);
+extern int drm_mode_getfb(struct drm_device *dev,
+			  void *data, struct drm_file *file_priv);
+extern int drm_mode_addmode_ioctl(struct drm_device *dev,
+				  void *data, struct drm_file *file_priv);
+extern int drm_mode_rmmode_ioctl(struct drm_device *dev,
+				 void *data, struct drm_file *file_priv);
+extern int drm_mode_attachmode_ioctl(struct drm_device *dev,
+				     void *data, struct drm_file *file_priv);
+extern int drm_mode_detachmode_ioctl(struct drm_device *dev,
+				     void *data, struct drm_file *file_priv);
+
+extern int drm_mode_getproperty_ioctl(struct drm_device *dev,
+				      void *data, struct drm_file *file_priv);
+extern int drm_mode_getblob_ioctl(struct drm_device *dev,
+				  void *data, struct drm_file *file_priv);
+extern int drm_mode_connector_property_set_ioctl(struct drm_device *dev,
+					      void *data, struct drm_file *file_priv);
+extern int drm_mode_hotplug_ioctl(struct drm_device *dev,
+				  void *data, struct drm_file *file_priv);
+extern int drm_mode_replacefb(struct drm_device *dev,
+			      void *data, struct drm_file *file_priv);
+extern int drm_mode_getencoder(struct drm_device *dev,
+			       void *data, struct drm_file *file_priv);
+extern int drm_mode_gamma_get_ioctl(struct drm_device *dev,
+				    void *data, struct drm_file *file_priv);
+extern int drm_mode_gamma_set_ioctl(struct drm_device *dev,
+				    void *data, struct drm_file *file_priv);
+#endif /* __DRM_CRTC_H__ */
