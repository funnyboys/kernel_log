commit 1aa63ddf726ea049279989b93b69b57ce6efd75b
Merge: 774f1eeb18b0 14d0066b8477
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Apr 22 10:40:34 2020 +1000

    Merge tag 'drm-misc-next-2020-04-14' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for 5.8:
    
    UAPI Changes:
    
      - drm: error out with EBUSY when device has existing master
      - drm: rework SET_MASTER and DROP_MASTER perm handling
    
    Cross-subsystem Changes:
    
      - mm: export two symbols from slub/slob
      - fbdev: savage: fix -Wextra build warning
      - video: omap2: Use scnprintf() for avoiding potential buffer overflow
    
    Core Changes:
    
      - Remove drm_pci.h
      - drm_pci_{alloc/free)() are now legacy
      - Introduce managed DRM resourcesA
      - Allow drivers to subclass struct drm_framebuffer
      - Introduce struct drm_afbc_framebuffer and helpers
      - fbdev: remove return value from generic fbdev setup
      - Introduce simple-encoder helper
      - vram-helpers: set fence on plane
      - dp_mst: ACT timeout improvements
      - dp_mst: Remove drm_dp_mst_has_audio()
      - TTM: ttm_trace_dma_{map/unmap}() cleanups
      - dma-buf: add flag for PCIP2P support
      - EDID: Various improvements
      - Encoder: cleanup semantics of possible_clones and possible_crtcs
      - VBLANK documentation updates
      - Writeback documentation updates
    
    Driver Changes:
    
      - Convert several drivers to i2c_new_client_device()
      - Drop explicit drm_mode_config_cleanup() calls from drivers
      - Auto-release device structures with drmm_add_final_kfree()
      - Init bfdev console after registering DRM device
      - Make various .debugfs functions return 0 unconditionally; ignore errors
      - video: Use scnprintf() to avoid buffer overflows
      - Convert drivers to simple encoders
    
      - drm/amdgpu: note that we can handle peer2peer DMA-buf
      - drm/amdgpu: add support for exporting VRAM using DMA-buf v3
      - drm/kirin: Revert change to register connectors
      - drm/lima: Add optional devfreq and cooling device support
      - drm/lima: Various improvements wrt. task handling
      - drm/panel: nt39016: Support multiple modes and 50Hz
      - drm/panel: Support Leadtek LTK050H3146W
      - drm/rockchip: Add support for afbc
      - drm/virtio: Various cleanups
      - drm/hisilicon/hibmc: Enforce 128-byte stride alignment
      - drm/qxl: Fix notify port address of cursor ring buffer
      - drm/sun4i: Improvements to format handling
      - drm/bridge: dw-hdmi: Various improvements
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Thomas Zimmermann <tzimmermann@suse.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200414090738.GA16827@linux-uq9g

commit 45bc3d26c95a8fc63a7d8668ca9e57ef0883351c
Author: Emil Velikov <emil.velikov@collabora.com>
Date:   Thu Mar 19 17:29:29 2020 +0000

    drm: rework SET_MASTER and DROP_MASTER perm handling
    
    This commit reworks the permission handling of the two ioctls. In
    particular it enforced the CAP_SYS_ADMIN check only, if:
     - we're issuing the ioctl from process other than the one which opened
    the node, and
     - we are, or were master in the past
    
    This ensures that we:
     - do not regress the systemd-logind style of DRM_MASTER arbitrator
     - allow applications which do not use systemd-logind to drop their
    master capabilities (and regain them at later point) ... w/o running as
    root.
    
    See the comment above drm_master_check_perm() for more details.
    
    v1:
     - Tweak wording, fixup all checks, add igt test
    
    v2:
     - Add a few more comments, grammar nitpicks.
    
    Cc: Adam Jackson <ajax@redhat.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Pekka Paalanen <ppaalanen@gmail.com>
    Testcase: igt/core_setmaster/master-drop-set-user
    Signed-off-by: Emil Velikov <emil.velikov@collabora.com>
    Reviewed-by: Adam Jackson <ajax@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200319172930.230583-1-emil.l.velikov@gmail.com

diff --git a/include/drm/drm_file.h b/include/drm/drm_file.h
index 19df8028a6c4..c4746c9d3619 100644
--- a/include/drm/drm_file.h
+++ b/include/drm/drm_file.h
@@ -201,6 +201,17 @@ struct drm_file {
 	 */
 	bool writeback_connectors;
 
+	/**
+	 * @was_master:
+	 *
+	 * This client has or had, master capability. Protected by struct
+	 * &drm_device.master_mutex.
+	 *
+	 * This is used to ensure that CAP_SYS_ADMIN is not enforced, if the
+	 * client is or was master in the past.
+	 */
+	bool was_master;
+
 	/**
 	 * @is_master:
 	 *

commit b182341667091c8edfb24a7caae600a2f08d7857
Author: Thomas Hellstrom (VMware) <thomas_os@shipmail.org>
Date:   Tue Mar 24 18:49:26 2020 +0100

    drm: Add a drm_get_unmapped_area() helper
    
    Unaligned virtual addresses makes it unlikely that huge page-table entries
    can be used.
    So align virtual buffer object address huge page boundaries to the
    underlying physical address huge page boundaries taking buffer object
    sizes into account to determine when it might be possible to use huge
    page-table entries.
    
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: "Matthew Wilcox (Oracle)" <willy@infradead.org>
    Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
    Cc: Ralph Campbell <rcampbell@nvidia.com>
    Cc: "Jérôme Glisse" <jglisse@redhat.com>
    Cc: "Christian König" <christian.koenig@amd.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Thomas Hellstrom (VMware) <thomas_os@shipmail.org>
    Reviewed-by: Roland Scheidegger <sroland@vmware.com>
    Acked-by: Christian König <christian.koenig@amd.com>

diff --git a/include/drm/drm_file.h b/include/drm/drm_file.h
index 19df8028a6c4..5aaf1c4593a9 100644
--- a/include/drm/drm_file.h
+++ b/include/drm/drm_file.h
@@ -391,4 +391,13 @@ void drm_send_event(struct drm_device *dev, struct drm_pending_event *e);
 
 struct file *mock_drm_getfile(struct drm_minor *minor, unsigned int flags);
 
+#ifdef CONFIG_MMU
+struct drm_vma_offset_manager;
+unsigned long drm_get_unmapped_area(struct file *file,
+				    unsigned long uaddr, unsigned long len,
+				    unsigned long pgoff, unsigned long flags,
+				    struct drm_vma_offset_manager *mgr);
+#endif /* CONFIG_MMU */
+
+
 #endif /* _DRM_FILE_H_ */

commit 7a2c65dd32b1cfa8bae55250dfdfe3d049e2f336
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jan 24 12:56:26 2020 +0000

    drm: Release filp before global lock
    
    The file is not part of the global drm resource and can be released
    prior to take the global mutex to drop the open_count (and potentially
    close) the drm device. As the global mutex is indeed global, not only
    within the device but across devices, a slow file release mechanism can
    bottleneck the entire system.
    
    However, inside drm_close_helper() there are a number of dev->driver
    callbacks that take the drm_device as the first parameter... Worryingly
    some of those callbacks may be (implicitly) depending on the global
    mutex.
    
    v2: Drop the debug message for the open-count, it's included with the
    drm_file_free() debug message -- and for good measure make that up as
    reading outside of the mutex.
    
    v3: Separate the calling of the filp cleanup outside of
    drm_global_mutex into a new drm_release_noglobal() hook, so that we can
    phase the transition. drm/savage relies on the global mutex, and there
    may be more, so be cautious.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Thomas Hellström (VMware) <thomas_os@shipmail.org>
    Reviewed-by: Thomas Hellström (VMware) <thomas_os@shipmail.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200124125627.125042-1-chris@chris-wilson.co.uk

diff --git a/include/drm/drm_file.h b/include/drm/drm_file.h
index 8b099b347817..19df8028a6c4 100644
--- a/include/drm/drm_file.h
+++ b/include/drm/drm_file.h
@@ -374,6 +374,7 @@ int drm_open(struct inode *inode, struct file *filp);
 ssize_t drm_read(struct file *filp, char __user *buffer,
 		 size_t count, loff_t *offset);
 int drm_release(struct inode *inode, struct file *filp);
+int drm_release_noglobal(struct inode *inode, struct file *filp);
 __poll_t drm_poll(struct file *filp, struct poll_table_struct *wait);
 int drm_event_reserve_init_locked(struct drm_device *dev,
 				  struct drm_file *file_priv,

commit 4748aa16d5273bf4b42d3581e5e33da1faa69722
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Nov 7 18:05:58 2019 +0000

    drm: Expose a method for creating anonymous struct file around drm_minor
    
    Sometimes we need to create a struct file to wrap a drm_device, as it
    the user were to have opened /dev/dri/card0 but to do so anonymously
    (i.e. for internal use). Provide a utility method to create a struct
    file with the drm_device->driver.fops, that wrap the drm_device.
    
    v2: Restrict usage to selftests
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191107180601.30815-2-chris@chris-wilson.co.uk

diff --git a/include/drm/drm_file.h b/include/drm/drm_file.h
index 67af60bb527a..8b099b347817 100644
--- a/include/drm/drm_file.h
+++ b/include/drm/drm_file.h
@@ -42,6 +42,7 @@ struct dma_fence;
 struct drm_file;
 struct drm_device;
 struct device;
+struct file;
 
 /*
  * FIXME: Not sure we want to have drm_minor here in the end, but to avoid
@@ -387,4 +388,6 @@ void drm_event_cancel_free(struct drm_device *dev,
 void drm_send_event_locked(struct drm_device *dev, struct drm_pending_event *e);
 void drm_send_event(struct drm_device *dev, struct drm_pending_event *e);
 
+struct file *mock_drm_getfile(struct drm_minor *minor, unsigned int flags);
+
 #endif /* _DRM_FILE_H_ */

commit ee22f76306a68359c33809f8895eff603e71584b
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Apr 23 10:01:50 2019 +1000

    drm/legacy: remove some legacy lock struct members
    
    This removes these unless legacy is enabled.
    
    The lock count init is unneeded anyways since it's kzalloc.
    
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_file.h b/include/drm/drm_file.h
index 6710b612e2f6..67af60bb527a 100644
--- a/include/drm/drm_file.h
+++ b/include/drm/drm_file.h
@@ -335,7 +335,9 @@ struct drm_file {
 	struct drm_prime_file_private prime;
 
 	/* private: */
+#if IS_ENABLED(CONFIG_DRM_LEGACY)
 	unsigned long lock_count; /* DRI1 legacy lock count */
+#endif
 };
 
 /**

commit 39e23674809b0fab008e32c268d7c5ef4a019c8b
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Thu Dec 27 14:56:38 2018 +0200

    drm: include idr.h from drm_file.h
    
    drm_file.h embeds idr structures in DRM-specific structures. Include the
    corresponding header to make drm_file.h self-contained. Make it easier
    to drop drmP.h includes.
    
    [Updated commit message per Laurent's review while applying.]
    
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/2818b15332ab562722dfc324cf977b7eb4a04401.1545915059.git.jani.nikula@intel.com

diff --git a/include/drm/drm_file.h b/include/drm/drm_file.h
index 84ac79219e4c..6710b612e2f6 100644
--- a/include/drm/drm_file.h
+++ b/include/drm/drm_file.h
@@ -32,6 +32,7 @@
 
 #include <linux/types.h>
 #include <linux/completion.h>
+#include <linux/idr.h>
 
 #include <uapi/drm/drm.h>
 

commit 078b7de41249b989a574339078696663e095cf37
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Nov 2 14:25:42 2018 +0100

    drm/file: Uncompact the feature flags
    
    This essentially undoes
    
    commit 39868bd7668bd47308b1dfd97c212757caee764f
    Author: Chris Wilson <chris@chris-wilson.co.uk>
    Date:   Tue Oct 29 08:55:58 2013 +0000
    
        drm: Compact booleans within struct drm_file
    
    We do lockless access to these flags everywhere, and it's kinda not a
    great idea to mix lockless and bitfields. Aside from that gcc isn't
    generating great code for these.
    
    If this ever becomes an issue size-wise, I think we need atomic_t here
    and atomic bitflag ops.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: David Herrmann <dh.herrmann@gmail.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181102132543.16486-2-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_file.h b/include/drm/drm_file.h
index 26485acc51d7..84ac79219e4c 100644
--- a/include/drm/drm_file.h
+++ b/include/drm/drm_file.h
@@ -164,14 +164,14 @@ struct drm_file {
 	 * See also the :ref:`section on primary nodes and authentication
 	 * <drm_primary_node>`.
 	 */
-	unsigned authenticated :1;
+	bool authenticated;
 
 	/**
 	 * @stereo_allowed:
 	 *
 	 * True when the client has asked us to expose stereo 3D mode flags.
 	 */
-	unsigned stereo_allowed :1;
+	bool stereo_allowed;
 
 	/**
 	 * @universal_planes:
@@ -179,10 +179,10 @@ struct drm_file {
 	 * True if client understands CRTC primary planes and cursor planes
 	 * in the plane list. Automatically set when @atomic is set.
 	 */
-	unsigned universal_planes:1;
+	bool universal_planes;
 
 	/** @atomic: True if client understands atomic properties. */
-	unsigned atomic:1;
+	bool atomic;
 
 	/**
 	 * @aspect_ratio_allowed:
@@ -190,14 +190,14 @@ struct drm_file {
 	 * True, if client can handle picture aspect ratios, and has requested
 	 * to pass this information along with the mode.
 	 */
-	unsigned aspect_ratio_allowed:1;
+	bool aspect_ratio_allowed;
 
 	/**
 	 * @writeback_connectors:
 	 *
 	 * True if client understands writeback connectors
 	 */
-	unsigned writeback_connectors:1;
+	bool writeback_connectors;
 
 	/**
 	 * @is_master:
@@ -208,7 +208,7 @@ struct drm_file {
 	 * See also the :ref:`section on primary nodes and authentication
 	 * <drm_primary_node>`.
 	 */
-	unsigned is_master:1;
+	bool is_master;
 
 	/**
 	 * @master:

commit d67b6a2065076d763c7df626b8c54f16038ad862
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Wed Feb 28 14:11:23 2018 +0000

    drm: writeback: Add client capability for exposing writeback connectors
    
    Due to the fact that writeback connectors behave in a special way
    in DRM (they always report being disconnected) we might confuse some
    userspace. Add a client capability for writeback connectors that will
    filter them out for clients that don't understand the capability.
    
    Changelog:
     - only accept the capability if the client has already set the
    DRM_CLIENT_CAP_ATOMIC one.
    
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: Brian Starkey <brian.starkey@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Reviewed-by: Brian Starkey <brian.starkey@arm.com>
    Link: https://patchwork.freedesktop.org/patch/229038/

diff --git a/include/drm/drm_file.h b/include/drm/drm_file.h
index 027ac16da3d1..26485acc51d7 100644
--- a/include/drm/drm_file.h
+++ b/include/drm/drm_file.h
@@ -192,6 +192,13 @@ struct drm_file {
 	 */
 	unsigned aspect_ratio_allowed:1;
 
+	/**
+	 * @writeback_connectors:
+	 *
+	 * True if client understands writeback connectors
+	 */
+	unsigned writeback_connectors:1;
+
 	/**
 	 * @is_master:
 	 *

commit c9ac371d4b5982d2f179d42bb99781e510d55f50
Author: Eric Anholt <eric@anholt.net>
Date:   Tue May 8 17:14:25 2018 -0700

    drm: Fix render node numbering regression from control node removal.
    
    drm_minor_alloc() does multiplication on this enum, so the removal
    ended up moving render nodes down from 128 base to 64.  This caused
    Mesa's surfaceless backend to be unable to open the render nodes,
    since it was still looking up at 128.
    
    v2: Add a comment warning the next person.
    
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Fixes: 0d49f303e8a7 ("drm: remove all control node code")
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180509001425.12574-1-eric@anholt.net

diff --git a/include/drm/drm_file.h b/include/drm/drm_file.h
index 91a65a360079..027ac16da3d1 100644
--- a/include/drm/drm_file.h
+++ b/include/drm/drm_file.h
@@ -47,8 +47,12 @@ struct device;
  * header include loops we need it here for now.
  */
 
+/* Note that the order of this enum is ABI (it determines
+ * /dev/dri/renderD* numbers).
+ */
 enum drm_minor_type {
 	DRM_MINOR_PRIMARY,
+	DRM_MINOR_CONTROL,
 	DRM_MINOR_RENDER,
 };
 

commit 7595bda2fb4378ccbb8db1d0e8de56d15ea7f7fa
Author: Ankit Nautiyal <ankit.k.nautiyal@intel.com>
Date:   Tue May 8 16:39:41 2018 +0530

    drm: Add DRM client cap for aspect-ratio
    
    To enable aspect-ratio support in DRM, blindly exposing the aspect
    ratio information along with mode, can break things in existing
    non-atomic user-spaces which have no intention or support to use this
    aspect ratio information.
    
    To avoid this, a new drm client cap is required to enable a non-atomic
    user-space to advertise if it supports modes with aspect-ratio. Based
    on this cap value, the kernel will take a call on exposing the aspect
    ratio info in modes or not.
    
    This patch adds the client cap for aspect-ratio.
    
    Since no atomic-userspaces blow up on receiving aspect-ratio
    information, the client cap for aspect-ratio is always enabled
    for atomic clients.
    
    Cc: Ville Syrjala <ville.syrjala@linux.intel.com>
    Cc: Shashank Sharma <shashank.sharma@intel.com>
    Signed-off-by: Ankit Nautiyal <ankit.k.nautiyal@intel.com>
    
    V3: rebase
    V4: As suggested by Marteen Lankhorst modified the commit message
        explaining the need to use the DRM cap for aspect-ratio. Also,
        tweaked the comment lines in the code for better understanding and
        clarity, as recommended by Shashank Sharma.
    V5: rebase
    V6: rebase
    V7: rebase
    V8: rebase
    V9: rebase
    V10: rebase
    V11: rebase
    V12: As suggested by Daniel Vetter and Ville Syrjala,
         always enable aspect-ratio client cap for atomic userspaces,
         if no atomic userspace breaks on aspect-ratio bits.
    V13: rebase
    V14: rebase
    
    Reviewed-by: Shashank Sharma <shashank.sharma@intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/1525777785-9740-7-git-send-email-ankit.k.nautiyal@intel.com

diff --git a/include/drm/drm_file.h b/include/drm/drm_file.h
index 99ab50cbab00..91a65a360079 100644
--- a/include/drm/drm_file.h
+++ b/include/drm/drm_file.h
@@ -180,6 +180,14 @@ struct drm_file {
 	/** @atomic: True if client understands atomic properties. */
 	unsigned atomic:1;
 
+	/**
+	 * @aspect_ratio_allowed:
+	 *
+	 * True, if client can handle picture aspect ratios, and has requested
+	 * to pass this information along with the mode.
+	 */
+	unsigned aspect_ratio_allowed:1;
+
 	/**
 	 * @is_master:
 	 *

commit 0d49f303e8a7006e0af3b58ed3809e1cad0900fb
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Apr 20 08:51:59 2018 +0200

    drm: remove all control node code
    
    With the ioctl and driver prep done, we can remove everything else.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Gustavo Padovan <gustavo@padovan.org>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: David Airlie <airlied@linux.ie>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180420065159.4531-4-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_file.h b/include/drm/drm_file.h
index 5176c3797680..99ab50cbab00 100644
--- a/include/drm/drm_file.h
+++ b/include/drm/drm_file.h
@@ -49,7 +49,6 @@ struct device;
 
 enum drm_minor_type {
 	DRM_MINOR_PRIMARY,
-	DRM_MINOR_CONTROL,
 	DRM_MINOR_RENDER,
 };
 
@@ -348,18 +347,6 @@ static inline bool drm_is_render_client(const struct drm_file *file_priv)
 	return file_priv->minor->type == DRM_MINOR_RENDER;
 }
 
-/**
- * drm_is_control_client - is this an open file of the control node
- * @file_priv: DRM file
- *
- * Control nodes are deprecated and in the process of getting removed from the
- * DRM userspace API. Do not ever use!
- */
-static inline bool drm_is_control_client(const struct drm_file *file_priv)
-{
-	return file_priv->minor->type == DRM_MINOR_CONTROL;
-}
-
 int drm_open(struct inode *inode, struct file *filp);
 ssize_t drm_read(struct file *filp, char __user *buffer,
 		 size_t count, loff_t *offset);

commit afc9a42b7464f76e1388cad87d8543c69f6f74ed
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jul 3 06:39:46 2017 -0400

    the rest of drivers/*: annotate ->poll() instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/drm/drm_file.h b/include/drm/drm_file.h
index 0e0c868451a5..5176c3797680 100644
--- a/include/drm/drm_file.h
+++ b/include/drm/drm_file.h
@@ -364,7 +364,7 @@ int drm_open(struct inode *inode, struct file *filp);
 ssize_t drm_read(struct file *filp, char __user *buffer,
 		 size_t count, loff_t *offset);
 int drm_release(struct inode *inode, struct file *filp);
-unsigned int drm_poll(struct file *filp, struct poll_table_struct *wait);
+__poll_t drm_poll(struct file *filp, struct poll_table_struct *wait);
 int drm_event_reserve_init_locked(struct drm_device *dev,
 				  struct drm_file *file_priv,
 				  struct drm_pending_event *p,

commit e9083420bbacce27e43d418064d0d2dfb4b37aaa
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Apr 4 13:26:24 2017 +1000

    drm: introduce sync objects (v4)
    
    Sync objects are new toplevel drm object, that contain a
    pointer to a fence. This fence can be updated via command
    submission ioctls via drivers.
    
    There is also a generic wait obj API modelled on the vulkan
    wait API (with code modelled on some amdgpu code).
    
    These objects can be converted to an opaque fd that can be
    passes between processes.
    
    v2: rename reference/unreference to put/get (Chris)
    fix leaked reference (David Zhou)
    drop mutex in favour of cmpxchg (Chris)
    v3: cleanups from danvet, rebase on drm_fops rename
    check fd_flags is 0 in ioctls.
    v4: export find/free, change replace fence to take a
    syncobj. In order to support lookup first, replace
    later semantics which seem in the end to be cleaner.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_file.h b/include/drm/drm_file.h
index d66f7ee07fb5..0e0c868451a5 100644
--- a/include/drm/drm_file.h
+++ b/include/drm/drm_file.h
@@ -232,6 +232,11 @@ struct drm_file {
 	/** @table_lock: Protects @object_idr. */
 	spinlock_t table_lock;
 
+	/** @syncobj_idr: Mapping of sync object handles to object pointers. */
+	struct idr syncobj_idr;
+	/** @syncobj_table_lock: Protects @syncobj_idr. */
+	spinlock_t syncobj_table_lock;
+
 	/** @filp: Pointer to the core file structure. */
 	struct file *filp;
 

commit 3ed4351a83ca05d3cd886ade6900be1067aa7903
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed May 31 11:21:46 2017 +0200

    drm: Extract drm_vblank.[hc]
    
    drm_irq.c contains both the irq helper library (optional) and the
    vblank support (optional, but part of the modeset uapi, and doesn't
    require the use of the irq helpers at all.
    
    Split this up for more clarity of the scope of the individual bits.
    
    v2: Move misplaced hunks to this patch (Stefan).
    
    Cc: Stefan Agner <stefan@agner.ch>
    Reviewed-by: Stefan Agner <stefan@agner.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170531092146.12528-1-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_file.h b/include/drm/drm_file.h
index 5dd27ae5c47c..d66f7ee07fb5 100644
--- a/include/drm/drm_file.h
+++ b/include/drm/drm_file.h
@@ -40,6 +40,7 @@
 struct dma_fence;
 struct drm_file;
 struct drm_device;
+struct device;
 
 /*
  * FIXME: Not sure we want to have drm_minor here in the end, but to avoid

commit b93658f83fa7f89cde5cfba7158da2be8cac42b2
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Mar 8 15:12:44 2017 +0100

    drm/doc: Document drm_file.[hc]
    
    Well, mostly drm_file.h, and clean up all related things:
    
    - I didnt' figure out the difference between preclose and postclose.
      The existing explanation in drm-internals.rst didn't convince me,
      since it's also really outdated - we clean up pending DRM events in
      the core nowadays. I put a FIXME in for the future.
    
    - Another FIXME is to have a macro for default fops.
    
    - Lots of links all around, main areas are to tie the overview in
      drm_file.c more into the callbacks in struct drm_device, and the
      other is to link render/primary node code to the right sections in
      drm-uapi.rst.
    
    - Also moved the open/close stuff to drm_drv.h from drm-internals.rst,
      seems like the better place for that information. Since that section
      was rather outdated this amounted to full-on rewrite.
    
    A big missing piece here is some overview graph, but I think better to
    wait with that one until drm_device and drm_driver are also fully
    documented.
    
    v2: Nits from Sean.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170308141257.12119-12-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_file.h b/include/drm/drm_file.h
index 4e347399a7bd..5dd27ae5c47c 100644
--- a/include/drm/drm_file.h
+++ b/include/drm/drm_file.h
@@ -45,6 +45,7 @@ struct drm_device;
  * FIXME: Not sure we want to have drm_minor here in the end, but to avoid
  * header include loops we need it here for now.
  */
+
 enum drm_minor_type {
 	DRM_MINOR_PRIMARY,
 	DRM_MINOR_CONTROL,
@@ -52,12 +53,19 @@ enum drm_minor_type {
 };
 
 /**
- * DRM minor structure. This structure represents a drm minor number.
+ * struct drm_minor - DRM device minor structure
+ *
+ * This structure represents a DRM minor number for device nodes in /dev.
+ * Entirely opaque to drivers and should never be inspected directly by drivers.
+ * Drivers instead should only interact with &struct drm_file and of course
+ * &struct drm_device, which is also where driver-private data and resources can
+ * be attached to.
  */
 struct drm_minor {
-	int index;			/**< Minor device number */
-	int type;                       /**< Control or render */
-	struct device *kdev;		/**< Linux device */
+	/* private: */
+	int index;			/* Minor device number */
+	int type;                       /* Control or render */
+	struct device *kdev;		/* Linux device */
 	struct drm_device *dev;
 
 	struct dentry *debugfs_root;
@@ -66,89 +74,286 @@ struct drm_minor {
 	struct mutex debugfs_lock; /* Protects debugfs_list. */
 };
 
-/* Event queued up for userspace to read */
+/**
+ * struct drm_pending_event - Event queued up for userspace to read
+ *
+ * This represents a DRM event. Drivers can use this as a generic completion
+ * mechanism, which supports kernel-internal &struct completion, &struct dma_fence
+ * and also the DRM-specific &struct drm_event delivery mechanism.
+ */
 struct drm_pending_event {
+	/**
+	 * @completion:
+	 *
+	 * Optional pointer to a kernel internal completion signalled when
+	 * drm_send_event() is called, useful to internally synchronize with
+	 * nonblocking operations.
+	 */
 	struct completion *completion;
+
+	/**
+	 * @completion_release:
+	 *
+	 * Optional callback currently only used by the atomic modeset helpers
+	 * to clean up the reference count for the structure @completion is
+	 * stored in.
+	 */
 	void (*completion_release)(struct completion *completion);
+
+	/**
+	 * @event:
+	 *
+	 * Pointer to the actual event that should be sent to userspace to be
+	 * read using drm_read(). Can be optional, since nowadays events are
+	 * also used to signal kernel internal threads with @completion or DMA
+	 * transactions using @fence.
+	 */
 	struct drm_event *event;
+
+	/**
+	 * @fence:
+	 *
+	 * Optional DMA fence to unblock other hardware transactions which
+	 * depend upon the nonblocking DRM operation this event represents.
+	 */
 	struct dma_fence *fence;
+
+	/**
+	 * @file_priv:
+	 *
+	 * &struct drm_file where @event should be delivered to. Only set when
+	 * @event is set.
+	 */
+	struct drm_file *file_priv;
+
+	/**
+	 * @link:
+	 *
+	 * Double-linked list to keep track of this event. Can be used by the
+	 * driver up to the point when it calls drm_send_event(), after that
+	 * this list entry is owned by the core for its own book-keeping.
+	 */
 	struct list_head link;
+
+	/**
+	 * @pending_link:
+	 *
+	 * Entry on &drm_file.pending_event_list, to keep track of all pending
+	 * events for @file_priv, to allow correct unwinding of them when
+	 * userspace closes the file before the event is delivered.
+	 */
 	struct list_head pending_link;
-	struct drm_file *file_priv;
 };
 
-/** File private data */
+/**
+ * struct drm_file - DRM file private data
+ *
+ * This structure tracks DRM state per open file descriptor.
+ */
 struct drm_file {
+	/**
+	 * @authenticated:
+	 *
+	 * Whether the client is allowed to submit rendering, which for legacy
+	 * nodes means it must be authenticated.
+	 *
+	 * See also the :ref:`section on primary nodes and authentication
+	 * <drm_primary_node>`.
+	 */
 	unsigned authenticated :1;
-	/* true when the client has asked us to expose stereo 3D mode flags */
+
+	/**
+	 * @stereo_allowed:
+	 *
+	 * True when the client has asked us to expose stereo 3D mode flags.
+	 */
 	unsigned stereo_allowed :1;
-	/*
-	 * true if client understands CRTC primary planes and cursor planes
-	 * in the plane list
+
+	/**
+	 * @universal_planes:
+	 *
+	 * True if client understands CRTC primary planes and cursor planes
+	 * in the plane list. Automatically set when @atomic is set.
 	 */
 	unsigned universal_planes:1;
-	/* true if client understands atomic properties */
+
+	/** @atomic: True if client understands atomic properties. */
 	unsigned atomic:1;
-	/*
-	 * This client is the creator of @master.
-	 * Protected by struct drm_device::master_mutex.
+
+	/**
+	 * @is_master:
+	 *
+	 * This client is the creator of @master. Protected by struct
+	 * &drm_device.master_mutex.
+	 *
+	 * See also the :ref:`section on primary nodes and authentication
+	 * <drm_primary_node>`.
 	 */
 	unsigned is_master:1;
 
+	/**
+	 * @master:
+	 *
+	 * Master this node is currently associated with. Only relevant if
+	 * drm_is_primary_client() returns true. Note that this only
+	 * matches &drm_device.master if the master is the currently active one.
+	 *
+	 * See also @authentication and @is_master and the :ref:`section on
+	 * primary nodes and authentication <drm_primary_node>`.
+	 */
+	struct drm_master *master;
+
+	/** @pid: Process that opened this file. */
 	struct pid *pid;
+
+	/** @magic: Authentication magic, see @authenticated. */
 	drm_magic_t magic;
+
+	/**
+	 * @lhead:
+	 *
+	 * List of all open files of a DRM device, linked into
+	 * &drm_device.filelist. Protected by &drm_device.filelist_mutex.
+	 */
 	struct list_head lhead;
+
+	/** @minor: &struct drm_minor for this file. */
 	struct drm_minor *minor;
-	unsigned long lock_count;
 
-	/** Mapping of mm object handles to object pointers. */
+	/**
+	 * @object_idr:
+	 *
+	 * Mapping of mm object handles to object pointers. Used by the GEM
+	 * subsystem. Protected by @table_lock.
+	 */
 	struct idr object_idr;
-	/** Lock for synchronization of access to object_idr. */
+
+	/** @table_lock: Protects @object_idr. */
 	spinlock_t table_lock;
 
+	/** @filp: Pointer to the core file structure. */
 	struct file *filp;
+
+	/**
+	 * @driver_priv:
+	 *
+	 * Optional pointer for driver private data. Can be allocated in
+	 * &drm_driver.open and should be freed in &drm_driver.postclose.
+	 */
 	void *driver_priv;
 
-	struct drm_master *master; /* master this node is currently associated with
-				      N.B. not always dev->master */
 	/**
-	 * fbs - List of framebuffers associated with this file.
+	 * @fbs:
+	 *
+	 * List of &struct drm_framebuffer associated with this file, using the
+	 * &drm_framebuffer.filp_head entry.
 	 *
-	 * Protected by fbs_lock. Note that the fbs list holds a reference on
-	 * the fb object to prevent it from untimely disappearing.
+	 * Protected by @fbs_lock. Note that the @fbs list holds a reference on
+	 * the framebuffer object to prevent it from untimely disappearing.
 	 */
 	struct list_head fbs;
+
+	/** @fbs_lock: Protects @fbs. */
 	struct mutex fbs_lock;
 
-	/** User-created blob properties; this retains a reference on the
-	 *  property. */
+	/**
+	 * @blobs:
+	 *
+	 * User-created blob properties; this retains a reference on the
+	 * property.
+	 *
+	 * Protected by @drm_mode_config.blob_lock;
+	 */
 	struct list_head blobs;
 
+	/** @event_wait: Waitqueue for new events added to @event_list. */
 	wait_queue_head_t event_wait;
+
+	/**
+	 * @pending_event_list:
+	 *
+	 * List of pending &struct drm_pending_event, used to clean up pending
+	 * events in case this file gets closed before the event is signalled.
+	 * Uses the &drm_pending_event.pending_link entry.
+	 *
+	 * Protect by &drm_device.event_lock.
+	 */
 	struct list_head pending_event_list;
+
+	/**
+	 * @event_list:
+	 *
+	 * List of &struct drm_pending_event, ready for delivery to userspace
+	 * through drm_read(). Uses the &drm_pending_event.link entry.
+	 *
+	 * Protect by &drm_device.event_lock.
+	 */
 	struct list_head event_list;
+
+	/**
+	 * @event_space:
+	 *
+	 * Available event space to prevent userspace from
+	 * exhausting kernel memory. Currently limited to the fairly arbitrary
+	 * value of 4KB.
+	 */
 	int event_space;
 
+	/** @event_read_lock: Serializes drm_read(). */
 	struct mutex event_read_lock;
 
+	/**
+	 * @prime:
+	 *
+	 * Per-file buffer caches used by the PRIME buffer sharing code.
+	 */
 	struct drm_prime_file_private prime;
+
+	/* private: */
+	unsigned long lock_count; /* DRI1 legacy lock count */
 };
 
+/**
+ * drm_is_primary_client - is this an open file of the primary node
+ * @file_priv: DRM file
+ *
+ * Returns true if this is an open file of the primary node, i.e.
+ * &drm_file.minor of @file_priv is a primary minor.
+ *
+ * See also the :ref:`section on primary nodes and authentication
+ * <drm_primary_node>`.
+ */
+static inline bool drm_is_primary_client(const struct drm_file *file_priv)
+{
+	return file_priv->minor->type == DRM_MINOR_PRIMARY;
+}
+
+/**
+ * drm_is_render_client - is this an open file of the render node
+ * @file_priv: DRM file
+ *
+ * Returns true if this is an open file of the render node, i.e.
+ * &drm_file.minor of @file_priv is a render minor.
+ *
+ * See also the :ref:`section on render nodes <drm_render_node>`.
+ */
 static inline bool drm_is_render_client(const struct drm_file *file_priv)
 {
 	return file_priv->minor->type == DRM_MINOR_RENDER;
 }
 
+/**
+ * drm_is_control_client - is this an open file of the control node
+ * @file_priv: DRM file
+ *
+ * Control nodes are deprecated and in the process of getting removed from the
+ * DRM userspace API. Do not ever use!
+ */
 static inline bool drm_is_control_client(const struct drm_file *file_priv)
 {
 	return file_priv->minor->type == DRM_MINOR_CONTROL;
 }
 
-static inline bool drm_is_primary_client(const struct drm_file *file_priv)
-{
-	return file_priv->minor->type == DRM_MINOR_PRIMARY;
-}
-
 int drm_open(struct inode *inode, struct file *filp);
 ssize_t drm_read(struct file *filp, char __user *buffer,
 		 size_t count, loff_t *offset);

commit 7d52cb88c9ca20c32288de6ed62b32410c936ccc
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Mar 8 15:12:43 2017 +0100

    drm: Remove drm_pending_event->pid
    
    We might as well dump the drm_file pointer, that's about as useful
    a cookie as the pid. Noticed while typing docs for drm_file and friends.
    
    Since the only consumer of this is the tracepoints I think we can safely
    change this - those tracepoints should not be uapi relevant at all. It
    all goes back to
    
    commit b9c2c9ae882f058084e13e339925dbf8d2d20271
    Author: Jesse Barnes <jbarnes@virtuousgeek.org>
    Date:   Thu Jul 1 16:48:09 2010 -0700
    
        drm: add per-event vblank event trace points
    
    which doesn't give a special justification for using pid over a pointer.
    
    Also note that the nouveau code setting it is entirely pointless:
    Since this isn't a vblank event, it will never hit the vblank
    tracepoints.
    
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170308141257.12119-11-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_file.h b/include/drm/drm_file.h
index d1a25cc17fd1..4e347399a7bd 100644
--- a/include/drm/drm_file.h
+++ b/include/drm/drm_file.h
@@ -75,8 +75,6 @@ struct drm_pending_event {
 	struct list_head link;
 	struct list_head pending_link;
 	struct drm_file *file_priv;
-	pid_t pid; /* pid of requester, no guarantee it's valid by the time
-		      we deliver the event, for tracing only */
 };
 
 /** File private data */

commit a8f8b1d9b8701465f1309d551fba2ebda6760f49
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Mar 8 15:12:42 2017 +0100

    drm: Extract drm_file.h
    
    I'm torn on whether drm_minor really should be here or somewhere else.
    Maybe with more clarity after untangling drmP.h more this is easier to
    decide, for now I've put a FIXME comment right next to it. Right now
    we need struct drm_minor for the inline drm_file type helpers, and so
    it does kinda make sense to have them here.
    
    Next patch will kerneldoc-ify the entire pile.
    
    Reviewed-by: Gustavo Padovan <gustavo.padovan@collabora.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170308141257.12119-10-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_file.h b/include/drm/drm_file.h
new file mode 100644
index 000000000000..d1a25cc17fd1
--- /dev/null
+++ b/include/drm/drm_file.h
@@ -0,0 +1,172 @@
+/*
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * Copyright (c) 2009-2010, Code Aurora Forum.
+ * All rights reserved.
+ *
+ * Author: Rickard E. (Rik) Faith <faith@valinux.com>
+ * Author: Gareth Hughes <gareth@valinux.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _DRM_FILE_H_
+#define _DRM_FILE_H_
+
+#include <linux/types.h>
+#include <linux/completion.h>
+
+#include <uapi/drm/drm.h>
+
+#include <drm/drm_prime.h>
+
+struct dma_fence;
+struct drm_file;
+struct drm_device;
+
+/*
+ * FIXME: Not sure we want to have drm_minor here in the end, but to avoid
+ * header include loops we need it here for now.
+ */
+enum drm_minor_type {
+	DRM_MINOR_PRIMARY,
+	DRM_MINOR_CONTROL,
+	DRM_MINOR_RENDER,
+};
+
+/**
+ * DRM minor structure. This structure represents a drm minor number.
+ */
+struct drm_minor {
+	int index;			/**< Minor device number */
+	int type;                       /**< Control or render */
+	struct device *kdev;		/**< Linux device */
+	struct drm_device *dev;
+
+	struct dentry *debugfs_root;
+
+	struct list_head debugfs_list;
+	struct mutex debugfs_lock; /* Protects debugfs_list. */
+};
+
+/* Event queued up for userspace to read */
+struct drm_pending_event {
+	struct completion *completion;
+	void (*completion_release)(struct completion *completion);
+	struct drm_event *event;
+	struct dma_fence *fence;
+	struct list_head link;
+	struct list_head pending_link;
+	struct drm_file *file_priv;
+	pid_t pid; /* pid of requester, no guarantee it's valid by the time
+		      we deliver the event, for tracing only */
+};
+
+/** File private data */
+struct drm_file {
+	unsigned authenticated :1;
+	/* true when the client has asked us to expose stereo 3D mode flags */
+	unsigned stereo_allowed :1;
+	/*
+	 * true if client understands CRTC primary planes and cursor planes
+	 * in the plane list
+	 */
+	unsigned universal_planes:1;
+	/* true if client understands atomic properties */
+	unsigned atomic:1;
+	/*
+	 * This client is the creator of @master.
+	 * Protected by struct drm_device::master_mutex.
+	 */
+	unsigned is_master:1;
+
+	struct pid *pid;
+	drm_magic_t magic;
+	struct list_head lhead;
+	struct drm_minor *minor;
+	unsigned long lock_count;
+
+	/** Mapping of mm object handles to object pointers. */
+	struct idr object_idr;
+	/** Lock for synchronization of access to object_idr. */
+	spinlock_t table_lock;
+
+	struct file *filp;
+	void *driver_priv;
+
+	struct drm_master *master; /* master this node is currently associated with
+				      N.B. not always dev->master */
+	/**
+	 * fbs - List of framebuffers associated with this file.
+	 *
+	 * Protected by fbs_lock. Note that the fbs list holds a reference on
+	 * the fb object to prevent it from untimely disappearing.
+	 */
+	struct list_head fbs;
+	struct mutex fbs_lock;
+
+	/** User-created blob properties; this retains a reference on the
+	 *  property. */
+	struct list_head blobs;
+
+	wait_queue_head_t event_wait;
+	struct list_head pending_event_list;
+	struct list_head event_list;
+	int event_space;
+
+	struct mutex event_read_lock;
+
+	struct drm_prime_file_private prime;
+};
+
+static inline bool drm_is_render_client(const struct drm_file *file_priv)
+{
+	return file_priv->minor->type == DRM_MINOR_RENDER;
+}
+
+static inline bool drm_is_control_client(const struct drm_file *file_priv)
+{
+	return file_priv->minor->type == DRM_MINOR_CONTROL;
+}
+
+static inline bool drm_is_primary_client(const struct drm_file *file_priv)
+{
+	return file_priv->minor->type == DRM_MINOR_PRIMARY;
+}
+
+int drm_open(struct inode *inode, struct file *filp);
+ssize_t drm_read(struct file *filp, char __user *buffer,
+		 size_t count, loff_t *offset);
+int drm_release(struct inode *inode, struct file *filp);
+unsigned int drm_poll(struct file *filp, struct poll_table_struct *wait);
+int drm_event_reserve_init_locked(struct drm_device *dev,
+				  struct drm_file *file_priv,
+				  struct drm_pending_event *p,
+				  struct drm_event *e);
+int drm_event_reserve_init(struct drm_device *dev,
+			   struct drm_file *file_priv,
+			   struct drm_pending_event *p,
+			   struct drm_event *e);
+void drm_event_cancel_free(struct drm_device *dev,
+			   struct drm_pending_event *p);
+void drm_send_event_locked(struct drm_device *dev, struct drm_pending_event *e);
+void drm_send_event(struct drm_device *dev, struct drm_pending_event *e);
+
+#endif /* _DRM_FILE_H_ */
