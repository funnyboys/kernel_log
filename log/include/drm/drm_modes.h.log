commit faa392181a0bd42c5478175cef601adeecdc91b6
Merge: cfa3b8068b09 9ca1f474cea0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 2 15:04:15 2020 -0700

    Merge tag 'drm-next-2020-06-02' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm updates from Dave Airlie:
     "Highlights:
    
       - Core DRM had a lot of refactoring around managed drm resources to
         make drivers simpler.
    
       - Intel Tigerlake support is on by default
    
       - amdgpu now support p2p PCI buffer sharing and encrypted GPU memory
    
      Details:
    
      core:
       - uapi: error out EBUSY when existing master
       - uapi: rework SET/DROP MASTER permission handling
       - remove drm_pci.h
       - drm_pci* are now legacy
       - introduced managed DRM resources
       - subclassing support for drm_framebuffer
       - simple encoder helper
       - edid improvements
       - vblank + writeback documentation improved
       - drm/mm - optimise tree searches
       - port drivers to use devm_drm_dev_alloc
    
      dma-buf:
       - add flag for p2p buffer support
    
      mst:
       - ACT timeout improvements
       - remove drm_dp_mst_has_audio
       - don't use 2nd TX slot - spec recommends against it
    
      bridge:
       - dw-hdmi various improvements
       - chrontel ch7033 support
       - fix stack issues with old gcc
    
      hdmi:
       - add unpack function for drm infoframe
    
      fbdev:
       - misc fbdev driver fixes
    
      i915:
       - uapi: global sseu pinning
       - uapi: OA buffer polling
       - uapi: remove generated perf code
       - uapi: per-engine default property values in sysfs
       - Tigerlake GEN12 enabled.
       - Lots of gem refactoring
       - Tigerlake enablement patches
       - move to drm_device logging
       - Icelake gamma HW readout
       - push MST link retrain to hotplug work
       - bandwidth atomic helpers
       - ICL fixes
       - RPS/GT refactoring
       - Cherryview full-ppgtt support
       - i915 locking guidelines documented
       - require linear fb stride to be 512 multiple on gen9
       - Tigerlake SAGV support
    
      amdgpu:
       - uapi: encrypted GPU memory handling
       - uapi: add MEM_SYNC IB flag
       - p2p dma-buf support
       - export VRAM dma-bufs
       - FRU chip access support
       - RAS/SR-IOV updates
       - Powerplay locking fixes
       - VCN DPG (powergating) enablement
       - GFX10 clockgating fixes
       - DC fixes
       - GPU reset fixes
       - navi SDMA fix
       - expose FP16 for modesetting
       - DP 1.4 compliance fixes
       - gfx10 soft recovery
       - Improved Critical Thermal Faults handling
       - resizable BAR on gmc10
    
      amdkfd:
       - uapi: GWS resource management
       - track GPU memory per process
       - report PCI domain in topology
    
      radeon:
       - safe reg list generator fixes
    
      nouveau:
       - HD audio fixes on recent systems
       - vGPU detection (fail probe if we're on one, for now)
       - Interlaced mode fixes (mostly avoidance on Turing, which doesn't support it)
       - SVM improvements/fixes
       - NVIDIA format modifier support
       - Misc other fixes.
    
      adv7511:
       - HDMI SPDIF support
    
      ast:
       - allocate crtc state size
       - fix double assignment
       - fix suspend
    
      bochs:
       - drop connector register
    
      cirrus:
       - move to tiny drivers.
    
      exynos:
       - fix imported dma-buf mapping
       - enable runtime PM
       - fixes and cleanups
    
      mediatek:
       - DPI pin mode swap
       - config mipi_tx current/impedance
    
      lima:
       - devfreq + cooling device support
       - task handling improvements
       - runtime PM support
    
      pl111:
       - vexpress init improvements
       - fix module auto-load
    
      rcar-du:
       - DT bindings conversion to YAML
       - Planes zpos sanity check and fix
       - MAINTAINERS entry for LVDS panel driver
    
      mcde:
       - fix return value
    
      mgag200:
       - use managed config init
    
      stm:
       - read endpoints from DT
    
      vboxvideo:
       - use PCI managed functions
       - drop WC mtrr
    
      vkms:
       - enable cursor by default
    
      rockchip:
       - afbc support
    
      virtio:
       - various cleanups
    
      qxl:
       - fix cursor notify port
    
      hisilicon:
       - 128-byte stride alignment fix
    
      sun4i:
       - improved format handling"
    
    * tag 'drm-next-2020-06-02' of git://anongit.freedesktop.org/drm/drm: (1401 commits)
      drm/amd/display: Fix potential integer wraparound resulting in a hang
      drm/amd/display: drop cursor position check in atomic test
      drm/amdgpu: fix device attribute node create failed with multi gpu
      drm/nouveau: use correct conflicting framebuffer API
      drm/vblank: Fix -Wformat compile warnings on some arches
      drm/amdgpu: Sync with VM root BO when switching VM to CPU update mode
      drm/amd/display: Handle GPU reset for DC block
      drm/amdgpu: add apu flags (v2)
      drm/amd/powerpay: Disable gfxoff when setting manual mode on picasso and raven
      drm/amdgpu: fix pm sysfs node handling (v2)
      drm/amdgpu: move gpu_info parsing after common early init
      drm/amdgpu: move discovery gfx config fetching
      drm/nouveau/dispnv50: fix runtime pm imbalance on error
      drm/nouveau: fix runtime pm imbalance on error
      drm/nouveau: fix runtime pm imbalance on error
      drm/nouveau/debugfs: fix runtime pm imbalance on error
      drm/nouveau/nouveau/hmm: fix migrate zero page to GPU
      drm/nouveau/nouveau/hmm: fix nouveau_dmem_chunk allocations
      drm/nouveau/kms/nv50-: Share DP SST mode_valid() handling with MST
      drm/nouveau/kms/nv50-: Move 8BPC limit for MST into nv50_mstc_get_modes()
      ...

commit 995b819f291e872b191893a2e8b0f9c9d8a570d9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 11 10:48:53 2020 -0700

    drm: fix trivial field description cut-and-paste error
    
    As reported by Amarnath Baliyase, the drm_mode_status enumeration
    documentation describes MODE_V_ILLEGAL as "mode has illegal horizontal
    timings".  But that's just a cut-and-paste error from the previous line.
    The "V" stands for vertical, of course.
    
    I'm just fixing this directly rather than bothering with going through
    the proper channels.  Less work for everybody.
    
    Reported-by: Amarnath Baliyase <baliyaseamarnath@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 99134d4f35eb..320f8112a0f8 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -48,7 +48,7 @@ struct videomode;
  * @MODE_HSYNC: hsync out of range
  * @MODE_VSYNC: vsync out of range
  * @MODE_H_ILLEGAL: mode has illegal horizontal timings
- * @MODE_V_ILLEGAL: mode has illegal horizontal timings
+ * @MODE_V_ILLEGAL: mode has illegal vertical timings
  * @MODE_BAD_WIDTH: requires an unsupported linepitch
  * @MODE_NOMODE: no mode with a matching name
  * @MODE_NO_INTERLACE: interlaced mode not supported

commit 58911c240783e0d1e7d457832416eb3347b8abbb
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Apr 28 20:19:25 2020 +0300

    drm: Nuke mode->hsync
    
    Let's just calculate the hsync rate on demand. No point in wasting
    space storing it and risking the cached value getting out of sync
    with reality.
    
    v2: Move drm_mode_hsync() next to its only users
        Drop the TODO
    
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com> #v1
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200428171940.19552-2-ville.syrjala@linux.intel.com

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 99134d4f35eb..730fc31de4fb 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -390,16 +390,6 @@ struct drm_display_mode {
 	 */
 	int vrefresh;
 
-	/**
-	 * @hsync:
-	 *
-	 * Horizontal refresh rate, for debug output in human readable form. Not
-	 * used in a functional way.
-	 *
-	 * This value is in kHz.
-	 */
-	int hsync;
-
 	/**
 	 * @picture_aspect_ratio:
 	 *
@@ -493,7 +483,6 @@ int of_get_drm_display_mode(struct device_node *np,
 			    int index);
 
 void drm_mode_set_name(struct drm_display_mode *mode);
-int drm_mode_hsync(const struct drm_display_mode *mode);
 int drm_mode_vrefresh(const struct drm_display_mode *mode);
 void drm_mode_get_hv_timing(const struct drm_display_mode *mode,
 			    int *hdisplay, int *vdisplay);

commit 885a066e9603add45a70b93ecf243b1aae4a4423
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Feb 15 19:35:03 2020 +0100

    drm: drop unused drm_display_mode.private
    
    drm_display_mode.private was only referenced in one place where
    is was copied but never assigned.
    
    Drop the copy and drop the field in drm_display_mode.
    Adjust the comment of private_flags as is referred to the comment for
    private.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200215183503.GA17310@ravnborg.org

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index e946e20c61d8..99134d4f35eb 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -371,20 +371,13 @@ struct drm_display_mode {
 	int crtc_vtotal;
 
 	/**
-	 * @private:
+	 * @private_flags:
 	 *
-	 * Pointer for driver private data. This can only be used for mode
+	 * Driver private flags. private_flags can only be used for mode
 	 * objects passed to drivers in modeset operations. It shouldn't be used
 	 * by atomic drivers since they can store any additional data by
 	 * subclassing state structures.
 	 */
-	int *private;
-
-	/**
-	 * @private_flags:
-	 *
-	 * Similar to @private, but just an integer.
-	 */
 	int private_flags;
 
 	/**

commit c0898fca3fce00f824e7f5d48e1edd0900378a03
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jun 28 14:16:45 2019 +0200

    drm/selftests: reduce stack usage
    
    Putting a large drm_connector object on the stack can lead to warnings
    in some configuration, such as:
    
    drivers/gpu/drm/selftests/test-drm_cmdline_parser.c:18:12: error: stack frame size of 1040 bytes in function 'drm_cmdline_test_res' [-Werror,-Wframe-larger-than=]
    static int drm_cmdline_test_res(void *ignored)
    
    Since the object is never modified, just declare it as 'static const'
    and allow this to be passed down.
    
    Fixes: b7ced38916a9 ("drm/selftests: Add command line parser selftests")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190628121712.1928142-1-arnd@arndb.de

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 083f16747369..e946e20c61d8 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -537,7 +537,7 @@ void drm_connector_list_update(struct drm_connector *connector);
 /* parsing cmdline modes */
 bool
 drm_mode_parse_command_line_for_connector(const char *mode_option,
-					  struct drm_connector *connector,
+					  const struct drm_connector *connector,
 					  struct drm_cmdline_mode *mode);
 struct drm_display_mode *
 drm_mode_create_from_cmdline_mode(struct drm_device *dev,

commit 06db4b8b26284133333bd01504a029139ccf872c
Author: Noralf Trønnes <noralf@tronnes.org>
Date:   Sun Feb 10 14:10:31 2019 +0100

    drm/modes: Add DRM_SIMPLE_MODE()
    
    This adds a helper macro to specify modes that only contain info about
    resolution.
    
    v2: Actually set the width and height (Ilia Mirkin)
    
    Cc: Ilia Mirkin <imirkin@alum.mit.edu>
    Signed-off-by: Noralf Trønnes <noralf@tronnes.org>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190210131039.52664-5-noralf@tronnes.org

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index be4fed97e727..083f16747369 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -138,6 +138,23 @@ enum drm_mode_status {
 	.vsync_start = (vss), .vsync_end = (vse), .vtotal = (vt), \
 	.vscan = (vs), .flags = (f)
 
+/**
+ * DRM_SIMPLE_MODE - Simple display mode
+ * @hd: Horizontal resolution, width
+ * @vd: Vertical resolution, height
+ * @hd_mm: Display width in millimeters
+ * @vd_mm: Display height in millimeters
+ *
+ * This macro initializes a &drm_display_mode that only contains info about
+ * resolution and physical size.
+ */
+#define DRM_SIMPLE_MODE(hd, vd, hd_mm, vd_mm) \
+	.type = DRM_MODE_TYPE_DRIVER, .clock = 1 /* pass validation */, \
+	.hdisplay = (hd), .hsync_start = (hd), .hsync_end = (hd), \
+	.htotal = (hd), .vdisplay = (vd), .vsync_start = (vd), \
+	.vsync_end = (vd), .vtotal = (vd), .width_mm = (hd_mm), \
+	.height_mm = (vd_mm)
+
 #define CRTC_INTERLACE_HALVE_V	(1 << 0) /* halve V values for interlacing */
 #define CRTC_STEREO_DOUBLE	(1 << 1) /* adjust timings for stereo modes */
 #define CRTC_NO_DBLSCAN		(1 << 2) /* don't adjust doublescan */

commit a3004db01f85c3f6dc400c9dc663d91b9b3899b4
Author: Shayenne Moura <shayenneluzmoura@gmail.com>
Date:   Fri Jan 11 12:47:29 2019 -0200

    drm: Complete remove drm_mode_object dependency
    
    This patch finalizes the KMS cleanup task dependency from
    drm_display_mode. It removes the use of drm_mode_object
    from drm_display_mode struct and it removes the use of
    base.id and base.type from drm_display_mode struct
    print string.
    
    Signed-off-by: Shayenne Moura <shayenneluzmoura@gmail.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/f40e904e665fe3e3ae3ae86e837024bee3b8ca6d.1547214023.git.shayenneluzmoura@gmail.com

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index baded6514456..be4fed97e727 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -136,8 +136,7 @@ enum drm_mode_status {
 	.hdisplay = (hd), .hsync_start = (hss), .hsync_end = (hse), \
 	.htotal = (ht), .hskew = (hsk), .vdisplay = (vd), \
 	.vsync_start = (vss), .vsync_end = (vse), .vtotal = (vt), \
-	.vscan = (vs), .flags = (f), \
-	.base.type = DRM_MODE_OBJECT_MODE
+	.vscan = (vs), .flags = (f)
 
 #define CRTC_INTERLACE_HALVE_V	(1 << 0) /* halve V values for interlacing */
 #define CRTC_STEREO_DOUBLE	(1 << 1) /* adjust timings for stereo modes */
@@ -213,20 +212,6 @@ struct drm_display_mode {
 	 */
 	struct list_head head;
 
-	/**
-	 * @base:
-	 *
-	 * A display mode is a normal modeset object, possibly including public
-	 * userspace id.
-	 *
-	 * FIXME:
-	 *
-	 * This can probably be removed since the entire concept of userspace
-	 * managing modes explicitly has never landed in upstream kernel mode
-	 * setting support.
-	 */
-	struct drm_mode_object base;
-
 	/**
 	 * @name:
 	 *
@@ -429,14 +414,14 @@ struct drm_display_mode {
 /**
  * DRM_MODE_FMT - printf string for &struct drm_display_mode
  */
-#define DRM_MODE_FMT    "%d:\"%s\" %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x"
+#define DRM_MODE_FMT    "\"%s\": %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x"
 
 /**
  * DRM_MODE_ARG - printf arguments for &struct drm_display_mode
  * @m: display mode
  */
 #define DRM_MODE_ARG(m) \
-	(m)->base.id, (m)->name, (m)->vrefresh, (m)->clock, \
+	(m)->name, (m)->vrefresh, (m)->clock, \
 	(m)->hdisplay, (m)->hsync_start, (m)->hsync_end, (m)->htotal, \
 	(m)->vdisplay, (m)->vsync_start, (m)->vsync_end, (m)->vtotal, \
 	(m)->type, (m)->flags

commit 97e14fbeb53fe060c5f6a7a07e37fd24c087ed0c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jul 9 10:40:08 2018 +0200

    drm: drop _mode_ from remaining connector functions
    
    Since there's very few callers of these I've decided to do them all in
    one patch. With this the unecessarily long drm_mode_connector_ prefix
    is gone from the codebase! The only exception being struct
    drm_mode_connector_set_property, which is part of the uapi so can't be
    renamed.
    
    Again done with sed+some manual fixups for indent issues.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180709084016.23750-8-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index b159fe07fcf9..baded6514456 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -530,7 +530,7 @@ drm_mode_validate_ycbcr420(const struct drm_display_mode *mode,
 void drm_mode_prune_invalid(struct drm_device *dev,
 			    struct list_head *mode_list, bool verbose);
 void drm_mode_sort(struct list_head *mode_list);
-void drm_mode_connector_list_update(struct drm_connector *connector);
+void drm_connector_list_update(struct drm_connector *connector);
 
 /* parsing cmdline modes */
 bool

commit c3ff0cdb354f89a5b877eee61af70e6ae51de50b
Author: Ankit Nautiyal <ankit.k.nautiyal@intel.com>
Date:   Tue May 8 16:39:43 2018 +0530

    drm: Expose modes with aspect ratio, only if requested
    
    We parse the EDID and add all the modes in the connector's modelist.
    This adds CEA modes with aspect ratio information too, regardless of
    whether user space requested this information or not.
    
    This patch:
    -prunes the modes with aspect-ratio information, from the
     drm_mode_get_connector modelist supplied to the user, if the
     user-space has not set the aspect ratio DRM client cap. However if
     such a mode is unique in the list, it is kept in the list, with
     aspect-ratio flags reset.
    -prepares a list of exposed modes, which is used to find unique modes
     if aspect-ratio is not allowed.
    -adds a new list_head 'exposed_head' in drm_mode_display, to traverse
     the list of exposed modes.
    
    Cc: Ville Syrjala <ville.syrjala@linux.intel.com>
    Cc: Shashank Sharma <shashank.sharma@intel.com>
    Cc: Jose Abreu <jose.abreu@synopsys.com>
    
    Signed-off-by: Ankit Nautiyal <ankit.k.nautiyal@intel.com>
    
    V3: As suggested by Ville, modified the mechanism of pruning of modes
        with aspect-ratio, if the aspect-ratio is not supported. Instead
        of straight away pruning such a mode, the mode is retained with
        aspect ratio bits set to zero, provided it is unique.
    V4: rebase
    V5: Addressed review comments from Ville:
        -used a pointer to store last valid mode.
        -avoided, modifying of picture_aspect_ratio in kernel mode,
         instead only flags bits of user mode are reset (if aspect-ratio
         is not supported).
    V6: As suggested by Ville, corrected the mode pruning logic and
        elaborated the mode pruning logic and the assumptions taken.
    V7: rebase
    V8: rebase
    V9: rebase
    V10: rebase
    V11: Fixed the issue caused in kms_3d test, and enhanced the pruning
         logic to correctly identify and prune modes with aspect-ratio,
         if aspect-ratio cap is not set.
    V12: As suggested by Ville, added another list_head in
         drm_mode_display to traverse the list of exposed modes and
         avoided duplication of modes.
    V13: Minor modifications, as suggested by Ville.
    v14: As suggested by Daniel Vetter and Ville Syrjala, corrected the
         pruning logic to avoid any dependency in the order of mode with
         aspect-ratio.
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/1525777785-9740-9-git-send-email-ankit.k.nautiyal@intel.com

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 2f78b7ee4824..b159fe07fcf9 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -411,6 +411,19 @@ struct drm_display_mode {
 	 * Field for setting the HDMI picture aspect ratio of a mode.
 	 */
 	enum hdmi_picture_aspect picture_aspect_ratio;
+
+	/**
+	 * @export_head:
+	 *
+	 * struct list_head for modes to be exposed to the userspace.
+	 * This is to maintain a list of exposed modes while preparing
+	 * user-mode's list in drm_mode_getconnector ioctl. The purpose of this
+	 * list_head only lies in the ioctl function, and is not expected to be
+	 * used outside the function.
+	 * Once used, the stale pointers are not reset, but left as it is, to
+	 * avoid overhead of protecting it by mode_config.mutex.
+	 */
+	struct list_head export_head;
 };
 
 /**

commit dd7c2626329468c0344a794187b467d34c3640cb
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue May 8 16:39:36 2018 +0530

    drm/modes: Introduce drm_mode_match()
    
    Make mode matching less confusing by allowing the caller to specify
    which parts of the modes should match via some flags.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Shashank Sharma <shashank.sharma@intel.com>
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/1525777785-9740-2-git-send-email-ankit.k.nautiyal@intel.com

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 0d310beae6af..2f78b7ee4824 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -147,6 +147,12 @@ enum drm_mode_status {
 
 #define DRM_MODE_FLAG_3D_MAX	DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF
 
+#define DRM_MODE_MATCH_TIMINGS (1 << 0)
+#define DRM_MODE_MATCH_CLOCK (1 << 1)
+#define DRM_MODE_MATCH_FLAGS (1 << 2)
+#define DRM_MODE_MATCH_3D_FLAGS (1 << 3)
+#define DRM_MODE_MATCH_ASPECT_RATIO (1 << 4)
+
 /**
  * struct drm_display_mode - DRM kernel-internal display mode structure
  * @hdisplay: horizontal display size
@@ -490,6 +496,9 @@ void drm_mode_copy(struct drm_display_mode *dst,
 		   const struct drm_display_mode *src);
 struct drm_display_mode *drm_mode_duplicate(struct drm_device *dev,
 					    const struct drm_display_mode *mode);
+bool drm_mode_match(const struct drm_display_mode *mode1,
+		    const struct drm_display_mode *mode2,
+		    unsigned int match_flags);
 bool drm_mode_equal(const struct drm_display_mode *mode1,
 		    const struct drm_display_mode *mode2);
 bool drm_mode_equal_no_clocks(const struct drm_display_mode *mode1,

commit 75a655e0a26cf0bfbaaa8df0ff5a9d1807bb1f4e
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Nov 14 20:32:57 2017 +0200

    drm/modes: Provide global mode_valid hook
    
    Allow drivers to provide a device wide .mode_valid() hook in addition to
    the already existing crtc/encoder/bridge/connector hooks. This can be
    used to validate device/driver wide constraings without having to add
    those to the other hooks. And since we call this hook also for user
    modes later on in the modeset we don't have to worry about anything the
    hook has already rejected.
    
    I also have some further ideas for this hook. Eg. we could replace the
    drm_mode_set_crtcinfo(HALVE_V) call in drm_mode_convert_umode()/etc.
    with a driver specific variant via this hook. At least on i915 we would
    like to pass CRTC_STEREO_DOUBLE to that function instead, and then
    we could safely use the crtc_ timings in all our .mode_valid() hooks,
    which would allow us to reuse those hooks for validating the
    adjusted_mode during a modeset.
    
    v2: Fix the language fails in the kernel docs (Daniel)
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171114183258.16976-10-ville.syrjala@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 71cbb10e22dc..0d310beae6af 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -444,7 +444,8 @@ struct drm_display_mode *drm_mode_create(struct drm_device *dev);
 void drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode);
 void drm_mode_convert_to_umode(struct drm_mode_modeinfo *out,
 			       const struct drm_display_mode *in);
-int drm_mode_convert_umode(struct drm_display_mode *out,
+int drm_mode_convert_umode(struct drm_device *dev,
+			   struct drm_display_mode *out,
 			   const struct drm_mode_modeinfo *in);
 void drm_mode_probed_add(struct drm_connector *connector, struct drm_display_mode *mode);
 void drm_mode_debug_printmodeline(const struct drm_display_mode *mode);
@@ -497,7 +498,8 @@ bool drm_mode_equal_no_clocks_no_stereo(const struct drm_display_mode *mode1,
 					const struct drm_display_mode *mode2);
 
 /* for use by the crtc helper probe functions */
-enum drm_mode_status drm_mode_validate_basic(const struct drm_display_mode *mode);
+enum drm_mode_status drm_mode_validate_driver(struct drm_device *dev,
+					      const struct drm_display_mode *mode);
 enum drm_mode_status drm_mode_validate_size(const struct drm_display_mode *mode,
 					    int maxX, int maxY);
 enum drm_mode_status

commit b7245cc536b95167d67b53e27adff964400045f1
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Nov 15 17:45:04 2017 +0200

    drm/uapi: Deprecate nonsense kms mode types
    
    BUILTIN, CRTC_C, CLOCK_C, and DEFULT mode types are unused. Let's
    refuse to generate them or accept them from userspace either. A
    cursory check didn't reveal any userspace code that would depend
    on these.
    
    v2: Recommend DRIVER instead of BUILTIN (ajax)
    
    Cc: Jose Abreu <Jose.Abreu@synopsys.com>
    Cc: Adam Jackson <ajax@redhat.com>
    Cc: Keith Packard <keithp@keithp.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Adam Jackson <ajax@redhat.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171115154504.14338-1-ville.syrjala@linux.intel.com
    Reviewed-by: Jose Abreu <joabreu@synopsys.com>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 99dd815269e9..71cbb10e22dc 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -242,8 +242,6 @@ struct drm_display_mode {
 	 * A bitmask of flags, mostly about the source of a mode. Possible flags
 	 * are:
 	 *
-	 *  - DRM_MODE_TYPE_BUILTIN: Meant for hard-coded modes, effectively
-	 *    unused.
 	 *  - DRM_MODE_TYPE_PREFERRED: Preferred mode, usually the native
 	 *    resolution of an LCD panel. There should only be one preferred
 	 *    mode per connector at any given time.
@@ -253,8 +251,11 @@ struct drm_display_mode {
 	 *  - DRM_MODE_TYPE_USERDEF: Mode defined via kernel command line
 	 *
 	 * Plus a big list of flags which shouldn't be used at all, but are
-	 * still around since these flags are also used in the userspace ABI:
+	 * still around since these flags are also used in the userspace ABI.
+	 * We no longer accept modes with these types though:
 	 *
+	 *  - DRM_MODE_TYPE_BUILTIN: Meant for hard-coded modes, unused.
+	 *    Use DRM_MODE_TYPE_DRIVER instead.
 	 *  - DRM_MODE_TYPE_DEFAULT: Again a leftover, use
 	 *    DRM_MODE_TYPE_PREFERRED instead.
 	 *  - DRM_MODE_TYPE_CLOCK_C and DRM_MODE_TYPE_CRTC_C: Define leftovers

commit 538af6cbdf9df485dc0ef43817d4195f11b4e9ac
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Nov 14 20:32:55 2017 +0200

    drm/modes: Kill DRM_MODE_TYPE_CLOCK_CRTC_C define
    
    No idea what the DRM_MODE_TYPE_CLOCK_CRTC_C define is supposed to
    achieve. Totally unused so kill if off.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171114183258.16976-8-ville.syrjala@linux.intel.com
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 8ddf7adb98df..99dd815269e9 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -131,9 +131,6 @@ enum drm_mode_status {
 	MODE_ERROR = -1
 };
 
-#define DRM_MODE_TYPE_CLOCK_CRTC_C (DRM_MODE_TYPE_CLOCK_C | \
-				    DRM_MODE_TYPE_CRTC_C)
-
 #define DRM_MODE(nm, t, c, hd, hss, hse, ht, hsk, vd, vss, vse, vt, vs, f) \
 	.name = nm, .status = 0, .type = (t), .clock = (c), \
 	.hdisplay = (hd), .hsync_start = (hss), .hsync_end = (hse), \

commit d5f26476ab534596f2a3c16cb3b3955ea8bf6380
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Nov 14 20:32:53 2017 +0200

    drm/modes: Fix description of DRM_MODE_TYPE_USERDEF
    
    These days DRM_MODE_TYPE_USERDEF is used to flag modes defined via the
    kernel command line. Update the docs to reflect that fact.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171114183258.16976-6-ville.syrjala@linux.intel.com
    Acked-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 09773e766e1f..8ddf7adb98df 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -253,6 +253,7 @@ struct drm_display_mode {
 	 *  - DRM_MODE_TYPE_DRIVER: Mode created by the driver, which is all of
 	 *    them really. Drivers must set this bit for all modes they create
 	 *    and expose to userspace.
+	 *  - DRM_MODE_TYPE_USERDEF: Mode defined via kernel command line
 	 *
 	 * Plus a big list of flags which shouldn't be used at all, but are
 	 * still around since these flags are also used in the userspace ABI:
@@ -262,9 +263,6 @@ struct drm_display_mode {
 	 *  - DRM_MODE_TYPE_CLOCK_C and DRM_MODE_TYPE_CRTC_C: Define leftovers
 	 *    which are stuck around for hysterical raisins only. No one has an
 	 *    idea what they were meant for. Don't use.
-	 *  - DRM_MODE_TYPE_USERDEF: Mode defined by userspace, again a vestige
-	 *    from older kms designs where userspace had to first add a custom
-	 *    mode to the kernel's mode list before it could use it. Don't use.
 	 */
 	unsigned int type;
 

commit 05ebac0980543cf93dbd4a29e6b03c1c9b883c70
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Nov 14 20:32:52 2017 +0200

    drm/uapi: Deprecate DRM_MODE_FLAG_BCAST
    
    Reject any mode with DRM_MODE_FLAG_BCAST. We have no code that even
    checks for this flag hence it can't possibly do any good.
    
    I think this maybe originated from fbdev where it was supposed to
    indicate PAL/NTSC broadcast timings. I have no idea why those would
    have to be identified by a flag rather than by just the timings
    themselves. And then I assume it got copied into xfree86 for
    fbdevhw, and later on it leaked into the randr protocol and kms uapi.
    
    Since kms fbdev emulation never uses the corresponding fbdev flag
    there should be no sane way for this to come back into kms via
    userspace either.
    
    Cc: Jose Abreu <Jose.Abreu@synopsys.com>
    Cc: Adam Jackson <ajax@redhat.com>
    Cc: Keith Packard <keithp@keithp.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171114183258.16976-5-ville.syrjala@linux.intel.com
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Jose Abreu <joabreu@synopsys.com>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index bce573375dd8..09773e766e1f 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -299,7 +299,7 @@ struct drm_display_mode {
 	 *  - DRM_MODE_FLAG_PCSYNC: composite sync is active high.
 	 *  - DRM_MODE_FLAG_NCSYNC: composite sync is active low.
 	 *  - DRM_MODE_FLAG_HSKEW: hskew provided (not used?).
-	 *  - DRM_MODE_FLAG_BCAST: not used?
+	 *  - DRM_MODE_FLAG_BCAST: <deprecated>
 	 *  - DRM_MODE_FLAG_PIXMUX: <deprecated>
 	 *  - DRM_MODE_FLAG_DBLCLK: double-clocked mode.
 	 *  - DRM_MODE_FLAG_CLKDIV2: half-clocked mode.

commit d15f40c84cdd2c4ac717d3c1e0146c07b5996d18
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Nov 14 20:32:51 2017 +0200

    drm/uapi: Deprecate DRM_MODE_FLAG_PIXMUX
    
    Reject any mode with DRM_MODE_FLAG_PIXMUX. We have no code that even
    checks for this flag hence it can't possibly do any good.
    
    Looks like this flag had something to do the the controller<->ramdac
    interface with some ancient S3 graphics adapters. Why someone though
    it would be a good idea to expose it directly to users I don't know.
    And later on it got copied into the randr protocol and kms uapi.
    
    Cc: Jose Abreu <Jose.Abreu@synopsys.com>
    Cc: Adam Jackson <ajax@redhat.com>
    Cc: Keith Packard <keithp@keithp.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171114183258.16976-4-ville.syrjala@linux.intel.com
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Jose Abreu <joabreu@synopsys.com>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 9f3421c8efcd..bce573375dd8 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -300,7 +300,7 @@ struct drm_display_mode {
 	 *  - DRM_MODE_FLAG_NCSYNC: composite sync is active low.
 	 *  - DRM_MODE_FLAG_HSKEW: hskew provided (not used?).
 	 *  - DRM_MODE_FLAG_BCAST: not used?
-	 *  - DRM_MODE_FLAG_PIXMUX: not used?
+	 *  - DRM_MODE_FLAG_PIXMUX: <deprecated>
 	 *  - DRM_MODE_FLAG_DBLCLK: double-clocked mode.
 	 *  - DRM_MODE_FLAG_CLKDIV2: half-clocked mode.
 	 *

commit 2570fe2586254ff174c2ba5a20dabbde707dbb9b
Author: Shashank Sharma <shashank.sharma@intel.com>
Date:   Thu Jul 13 21:03:14 2017 +0530

    drm: add helper functions for YCBCR420 handling
    
    This patch adds helper functions for YCBCR 420 handling.
    These functions do:
    - check if a given video mode is YCBCR 420 only mode.
    - check if a given video mode is YCBCR 420 also mode.
    
    V2: Added YCBCR functions as helpers in DRM layer, instead of
        keeping it in I915 layer.
    V3: Added handling for YCBCR-420 only modes too.
    V4: EXPORT_SYMBOL(drm_find_hdmi_output_type)
    V5: Addressed review comments from Danvet:
        - %s/drm_find_hdmi_output_type/drm_display_info_hdmi_output_type
        - %s/drm_can_support_ycbcr_output/drm_display_supports_ycbcr_output
        - %s/drm_can_support_this_ycbcr_output/
                    drm_display_supports_this_ycbcr_output
        - pass drm_display_info instead of drm_connector for consistency
        - For drm_get_highest_quality_ycbcr_supported doc, move the variable
          description above, and then the function description.
    V6: Add only YCBCR420 helpers (Ville)
    V7: Addressed review comments from Ville
        - Remove cea_vic_valid() check.
        - Fix indentation.
        - Make input parameters to helpers, const.
    
    Cc: Ville Syrjala <ville.syrjala@linux.intel.com>
    Cc: Jose Abreu <Jose.Abreu@synopsys.com>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Shashank Sharma <shashank.sharma@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1499960000-9232-9-git-send-email-shashank.sharma@intel.com
    [vsyrjala: Fix sparse indentation warn]
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index f8a1268dfbcb..9f3421c8efcd 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -452,6 +452,12 @@ int drm_mode_convert_umode(struct drm_display_mode *out,
 			   const struct drm_mode_modeinfo *in);
 void drm_mode_probed_add(struct drm_connector *connector, struct drm_display_mode *mode);
 void drm_mode_debug_printmodeline(const struct drm_display_mode *mode);
+bool drm_mode_is_420_only(const struct drm_display_info *display,
+			  const struct drm_display_mode *mode);
+bool drm_mode_is_420_also(const struct drm_display_info *display,
+			  const struct drm_display_mode *mode);
+bool drm_mode_is_420(const struct drm_display_info *display,
+		     const struct drm_display_mode *mode);
 
 struct drm_display_mode *drm_cvt_mode(struct drm_device *dev,
 				      int hdisplay, int vdisplay, int vrefresh,

commit d85231530b0719e23a62d92ee35712da966e281a
Author: Shashank Sharma <shashank.sharma@intel.com>
Date:   Thu Jul 13 21:03:11 2017 +0530

    drm: add helper to validate YCBCR420 modes
    
    YCBCR420 modes are supported only on HDMI 2.0 capable sources.
    This patch adds:
    - A drm helper to validate YCBCR420-only mode on a particular
      connector. This function will help pruning the YCBCR420-only
      modes from the connector's modelist.
    - A bool variable (ycbcr_420_allowed) in the drm connector structure.
      While handling the EDID from HDMI 2.0 sinks, its important to know
      if the source is capable of handling YCBCR420 output, so that no
      YCBCR 420 modes will be listed for sources which can't handle it.
      A driver should set this variable if it wants to see YCBCR420 modes
      in the modedb.
    
    V5: Introduced the patch in series.
    V6: Squashed two patches (validate YCBCR420 and add YCBCR420
               identifier)
    V7: Addressed review comments from Vile:
        - Move this patch before we add 420 modes from EDID.
        - No need for drm_valid_cea_vic() check, function back to non-static.
        - Update MODE_STATUS with NO_420 condition.
        - Introduce y420_vdb_modes variable in this patch
    
    Cc: Ville Syrjala <ville.syrjala@linux.intel.com>
    Signed-off-by: Shashank Sharma <shashank.sharma@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1499960000-9232-6-git-send-email-shashank.sharma@intel.com
    [vsyrjala: Drop the now bogus EXPORT_SYMBOL(drm_valid_cea_vic)]
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 94ac771fe460..f8a1268dfbcb 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -80,6 +80,7 @@ struct videomode;
  * @MODE_ONE_SIZE: only one resolution is supported
  * @MODE_NO_REDUCED: monitor doesn't accept reduced blanking
  * @MODE_NO_STEREO: stereo modes not supported
+ * @MODE_NO_420: ycbcr 420 modes not supported
  * @MODE_STALE: mode has become stale
  * @MODE_BAD: unspecified reason
  * @MODE_ERROR: error condition
@@ -124,6 +125,7 @@ enum drm_mode_status {
 	MODE_ONE_SIZE,
 	MODE_NO_REDUCED,
 	MODE_NO_STEREO,
+	MODE_NO_420,
 	MODE_STALE = -3,
 	MODE_BAD = -2,
 	MODE_ERROR = -1
@@ -496,6 +498,9 @@ bool drm_mode_equal_no_clocks_no_stereo(const struct drm_display_mode *mode1,
 enum drm_mode_status drm_mode_validate_basic(const struct drm_display_mode *mode);
 enum drm_mode_status drm_mode_validate_size(const struct drm_display_mode *mode,
 					    int maxX, int maxY);
+enum drm_mode_status
+drm_mode_validate_ycbcr420(const struct drm_display_mode *mode,
+			   struct drm_connector *connector);
 void drm_mode_prune_invalid(struct drm_device *dev,
 			    struct list_head *mode_list, bool verbose);
 void drm_mode_sort(struct list_head *mode_list);

commit 99cdb35e787b277bc66ed9fe7d5f9852de9e0eb0
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed May 24 16:51:36 2017 +0200

    drm/doc: move printf helpers out of drmP.h
    
    And document them lightly. Unfortunately kernel-doc isn't the most
    awesome for documenting #defines that don't look like functions, it
    makes functions out of them :-/
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Neil Armstrong <narmstrong@baylibre.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170524145212.27837-2-daniel.vetter@ffwll.ch
    Link: http://patchwork.freedesktop.org/patch/msgid/20170524145212.27837-3-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 6dd34280e892..94ac771fe460 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -197,6 +197,8 @@ enum drm_mode_status {
  * there's the hardware timings, which are corrected for interlacing,
  * double-clocking and similar things. They are provided as a convenience, and
  * can be appropriately computed using drm_mode_set_crtcinfo().
+ *
+ * For printing you can use %DRM_MODE_FMT and DRM_MODE_ARG().
  */
 struct drm_display_mode {
 	/**
@@ -407,6 +409,21 @@ struct drm_display_mode {
 	enum hdmi_picture_aspect picture_aspect_ratio;
 };
 
+/**
+ * DRM_MODE_FMT - printf string for &struct drm_display_mode
+ */
+#define DRM_MODE_FMT    "%d:\"%s\" %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x"
+
+/**
+ * DRM_MODE_ARG - printf arguments for &struct drm_display_mode
+ * @m: display mode
+ */
+#define DRM_MODE_ARG(m) \
+	(m)->base.id, (m)->name, (m)->vrefresh, (m)->clock, \
+	(m)->hdisplay, (m)->hsync_start, (m)->hsync_end, (m)->htotal, \
+	(m)->vdisplay, (m)->vsync_start, (m)->vsync_end, (m)->vtotal, \
+	(m)->type, (m)->flags
+
 #define obj_to_mode(x) container_of(x, struct drm_display_mode, base)
 
 /**

commit 196cd5d3758cbf587fc0254cae7132d95993461e
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jan 25 07:26:56 2017 +0100

    drm: s/drm_crtc_get_hv_timings/drm_mode_get_hv_timings/
    
    The function operates on modes, not CRTCs. Also move it into
    drm_modes.[hc]. Spotted while reviewing CRTC docs.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170125062657.19270-15-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 9934d91619c1..6dd34280e892 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -459,6 +459,8 @@ int of_get_drm_display_mode(struct device_node *np,
 void drm_mode_set_name(struct drm_display_mode *mode);
 int drm_mode_hsync(const struct drm_display_mode *mode);
 int drm_mode_vrefresh(const struct drm_display_mode *mode);
+void drm_mode_get_hv_timing(const struct drm_display_mode *mode,
+			    int *hdisplay, int *vdisplay);
 
 void drm_mode_set_crtcinfo(struct drm_display_mode *p,
 			   int adjust_flags);

commit 199e4e967af476bdcab96c76237e6a1f9244d6ca
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Aug 31 18:09:05 2016 +0200

    drm: Extract drm_bridge.h
    
    We don't want to burry the bridge structures kerneldoc in drm_crtc.h.
    
    Cc: Archit Taneja <archit.taneja@gmail.com>
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160831160913.12991-3-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 986ed6ff635a..9934d91619c1 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -27,9 +27,13 @@
 #ifndef __DRM_MODES_H__
 #define __DRM_MODES_H__
 
+#include <linux/hdmi.h>
+
 #include <drm/drm_mode_object.h>
 #include <drm/drm_connector.h>
 
+struct videomode;
+
 /*
  * Note on terminology:  here, for brevity and convenience, we refer to connector
  * control chips as 'CRTCs'.  They can control any type of connector, VGA, LVDS,

commit afb21ea63d815d05f6081ee3efef6772a16317eb
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Aug 31 18:09:04 2016 +0200

    drm: Move a few macros away from drm_crtc.h
    
    Now that there's less stuff in there I noticed that I overlooked them.
    Sprinkle some docs over them while at it.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160831160913.12991-2-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 011f199d3bcf..986ed6ff635a 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -403,6 +403,8 @@ struct drm_display_mode {
 	enum hdmi_picture_aspect picture_aspect_ratio;
 };
 
+#define obj_to_mode(x) container_of(x, struct drm_display_mode, base)
+
 /**
  * drm_mode_is_stereo - check for stereo mode flags
  * @mode: drm_display_mode to check

commit 949619f32eee37a6385de1e976523501c8256768
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Aug 29 10:27:51 2016 +0200

    drm: Extract drm_mode_object.[hc]
    
    Just for the struct drm_mode_object base class. The header file was
    already partially extracted to help untangle the include loops.
    
    v2:
    - Also move the generic get/set property ioctls. At first this seemed
      like a bad idea since it requires making drm_mode_crtc_set_obj_prop
      non-static. But eventually that will get split away too (like
      the connector version already is) for both crtc and planes. Hence I
      reconsidered.
    
    - drm_mode_object.[hc] instead of drm_modeset.[hc], which requires
      renaming the drm_modeset.h header I already started building up.
      This is more consistent (matches the name of the main structure),
      and I want to be able to use drm_modeset.[hc] for the basic modeset
      init/cleanup functionality like drm_mode_config_init.
    
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160829082757.17913-3-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 1621e9b32330..011f199d3bcf 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -27,7 +27,7 @@
 #ifndef __DRM_MODES_H__
 #define __DRM_MODES_H__
 
-#include <drm/drm_modeset.h>
+#include <drm/drm_mode_object.h>
 #include <drm/drm_connector.h>
 
 /*

commit 522171951761153172c75b94ae1f4bc9ab631745
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Aug 12 22:48:50 2016 +0200

    drm: Extract drm_connector.[hc]
    
    Pulls in quite a lot of connector related structures (cmdline mode,
    force/status enums, display info), but I think that all makes perfect
    sense.
    
    Also had to move a few more core kms object stuff into drm_modeset.h.
    
    And as a first cleanup remove the kerneldoc for the 2 connector IOCTL
    - DRM core docs are aimed at drivers, no point documenting internal in
    excruciating detail.
    
    v2: And also pull in all the connector property code.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1471034937-651-14-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index fed9fe81590c..1621e9b32330 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -28,6 +28,7 @@
 #define __DRM_MODES_H__
 
 #include <drm/drm_modeset.h>
+#include <drm/drm_connector.h>
 
 /*
  * Note on terminology:  here, for brevity and convenience, we refer to connector
@@ -402,21 +403,6 @@ struct drm_display_mode {
 	enum hdmi_picture_aspect picture_aspect_ratio;
 };
 
-/* mode specified on the command line */
-struct drm_cmdline_mode {
-	bool specified;
-	bool refresh_specified;
-	bool bpp_specified;
-	int xres, yres;
-	int bpp;
-	int refresh;
-	bool rb;
-	bool interlace;
-	bool cvt;
-	bool margins;
-	enum drm_connector_force force;
-};
-
 /**
  * drm_mode_is_stereo - check for stereo mode flags
  * @mode: drm_display_mode to check

commit 7520a277d97be6e8a8ec038bb5ed01f40d4f9aeb
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Aug 15 16:07:02 2016 +0200

    drm: Extract drm_framebuffer.[hc]
    
    Also start with drm_modeset.h with the core bits, since we need
    to untangle this mess somehow. That allows us to move the drm_modes.h
    include to the right spot, except for the temporary connector status
    enum. That will get fixed as soon as drm_connector.h exists.
    
    v2: Rebase.
    
    v3: Move drm_crtc_force_disable_all back again, that wasn't meant to
    be moved (Sean).
    
    v4: Rebase.
    
    Cc: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 48e1a56ea283..fed9fe81590c 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -27,6 +27,8 @@
 #ifndef __DRM_MODES_H__
 #define __DRM_MODES_H__
 
+#include <drm/drm_modeset.h>
+
 /*
  * Note on terminology:  here, for brevity and convenience, we refer to connector
  * control chips as 'CRTCs'.  They can control any type of connector, VGA, LVDS,

commit fafc79ef2e9148d0085585b6b71bc7154c14ebb6
Author: Lothar Waßmann <LW@KARO-electronics.de>
Date:   Tue Jul 12 15:30:03 2016 +0200

    drm/imx: convey the pixelclk-active and de-active flags from DT to the ipu-di driver
    
    The 'de-active' and 'pixelclk-active' DT properties are evaluated
    by of_parse_display_timing() called from  of_get_drm_display_mode(),
    but later lost in the conversion from videomode.flags to
    drm_display_mode.flags.
    Enhance of_get_drm_display_mode() to also return the bus flags in a
    separate variable, so that they can be passed on to the ipu-di
    driver.
    
    Signed-off-by: Lothar Waßmann <LW@KARO-electronics.de>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index a8164d2336e6..48e1a56ea283 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -459,7 +459,7 @@ void drm_display_mode_to_videomode(const struct drm_display_mode *dmode,
 				   struct videomode *vm);
 void drm_bus_flags_from_videomode(const struct videomode *vm, u32 *bus_flags);
 int of_get_drm_display_mode(struct device_node *np,
-			    struct drm_display_mode *dmode,
+			    struct drm_display_mode *dmode, u32 *bus_flags,
 			    int index);
 
 void drm_mode_set_name(struct drm_display_mode *mode);

commit d72daa0d75e8fe71368113350254b9da2c64b235
Author: Lothar Waßmann <LW@KARO-electronics.de>
Date:   Tue Jul 12 15:30:02 2016 +0200

    drm: add a helper function to extract 'de-active' and 'pixelclk-active' from DT
    
    add a helper function to extract information about pixel clock and DE
    polarity from DT for use by of_get_drm_display_mode().
    While at it, convert spaces to tabs in indentation in drm_modes.h.
    
    Signed-off-by: Lothar Waßmann <LW@KARO-electronics.de>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index ff481770d76b..a8164d2336e6 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -434,7 +434,7 @@ struct drm_cmdline_mode;
 struct drm_display_mode *drm_mode_create(struct drm_device *dev);
 void drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode);
 void drm_mode_convert_to_umode(struct drm_mode_modeinfo *out,
-                               const struct drm_display_mode *in);
+			       const struct drm_display_mode *in);
 int drm_mode_convert_umode(struct drm_display_mode *out,
 			   const struct drm_mode_modeinfo *in);
 void drm_mode_probed_add(struct drm_connector *connector, struct drm_display_mode *mode);
@@ -457,6 +457,7 @@ void drm_display_mode_from_videomode(const struct videomode *vm,
 				     struct drm_display_mode *dmode);
 void drm_display_mode_to_videomode(const struct drm_display_mode *dmode,
 				   struct videomode *vm);
+void drm_bus_flags_from_videomode(const struct videomode *vm, u32 *bus_flags);
 int of_get_drm_display_mode(struct device_node *np,
 			    struct drm_display_mode *dmode,
 			    int index);

commit da5335b8bd4aabc2362e2b3d5af7df49d7ec89e6
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue May 31 22:55:13 2016 +0200

    drm/doc: Switch to sphinx/rst fixed-width quoting
    
    Just fallout from switching from asciidoc to sphinx/rst.
    
    v2: Found more. Also s/\//#/ in the vgpu ascii-art - sphinx treats
    those as comments and switch to variable-width, which wreaks the
    layout.
    
    v3: Undo some of the hacks, rebasing onto latest version of Jani's
    series fixed it.
    
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 625966a906f2..ff481770d76b 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -169,6 +169,8 @@ enum drm_mode_status {
  *
  * The horizontal and vertical timings are defined per the following diagram.
  *
+ * ::
+ *
  *
  *               Active                 Front           Sync           Back
  *              Region                 Porch                          Porch

commit 6af3e6561243f167dabc03f732d27ff5365cd4a4
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Dec 3 23:14:14 2015 +0200

    drm: Drop drm_helper_probe_single_connector_modes_nomerge()
    
    Now that the mode type bit merge logic is fixed to only merge
    between new probed modes, hopefully we can eliminat the special
    case for qxl and virtio. That is make the merge the mode type
    bits from all matching new probed modes, just like every other
    driver.
    
    qxl and virtio got excluded from the merging in
    commit 3fbd6439e463 ("drm: copy mode type in drm_mode_connector_list_update()")
    commit abce1ec9b08a ("Revert "drm: copy mode type in drm_mode_connector_list_update()"")
    commit b87577b7c768 ("drm: try harder to avoid regression when merging mode bits")
    
    Cc: Marc-André Lureau <marcandre.lureau@redhat.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Adam Jackson <ajax@redhat.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    [danvet: Resolve conflicts with doc updates.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index d7445ccd958d..625966a906f2 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -483,7 +483,7 @@ enum drm_mode_status drm_mode_validate_size(const struct drm_display_mode *mode,
 void drm_mode_prune_invalid(struct drm_device *dev,
 			    struct list_head *mode_list, bool verbose);
 void drm_mode_sort(struct list_head *mode_list);
-void drm_mode_connector_list_update(struct drm_connector *connector, bool merge_type_bits);
+void drm_mode_connector_list_update(struct drm_connector *connector);
 
 /* parsing cmdline modes */
 bool

commit 5ba894064d98547c82a1efd50eba40a92df777a1
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Dec 10 22:39:08 2015 +0200

    drm: Rename MODE_UNVERIFIED to MODE_STALE
    
    MODE_UNVERIFIED actually means that the mode came from a previous probe,
    and if the new probe doesn't produce a matching mode it will get pruned
    from the list. Rename the flag to MODE_STALE to better convey the
    meaning.
    
    v2: Rebased due to conflicts with Daniel's doc stuff
    
    Cc: Adam Jackson <ajax@redhat.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449779948-10906-1-git-send-email-ville.syrjala@linux.intel.com

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 9e6d7a1cd19b..d7445ccd958d 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -73,7 +73,7 @@
  * @MODE_ONE_SIZE: only one resolution is supported
  * @MODE_NO_REDUCED: monitor doesn't accept reduced blanking
  * @MODE_NO_STEREO: stereo modes not supported
- * @MODE_UNVERIFIED: mode needs to reverified
+ * @MODE_STALE: mode has become stale
  * @MODE_BAD: unspecified reason
  * @MODE_ERROR: error condition
  *
@@ -117,7 +117,7 @@ enum drm_mode_status {
 	MODE_ONE_SIZE,
 	MODE_NO_REDUCED,
 	MODE_NO_STEREO,
-	MODE_UNVERIFIED = -3,
+	MODE_STALE = -3,
 	MODE_BAD = -2,
 	MODE_ERROR = -1
 };

commit 30ecad77fe849b60c9a1f8df24dca50e3f083d41
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Dec 9 09:29:36 2015 +0100

    drm: Move drm_display_mode an related docs into kerneldoc
    
    This was in the documentation for modeset helper hooks, where it is a
    bit misplaced.
    
    v2: Reindent the drm_mode_status enum, inspired by Ville.
    
    v3: Suggestions from Ville and Thierry.
    
    v4: Small fixup that 0day spotted.
    
    v5: Slight change to avoid accidental headings in kerneldoc output.
    
    Cc: ville.syrjala@linux.intel.com
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449218769-16577-27-git-send-email-daniel.vetter@ffwll.ch
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com> (v3)
    Reviewed-by: Thierry Reding <treding@nvidia.com> (v3)

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index f9115aee43f4..9e6d7a1cd19b 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -35,46 +35,91 @@
  * structures).
  */
 
+/**
+ * enum drm_mode_status - hardware support status of a mode
+ * @MODE_OK: Mode OK
+ * @MODE_HSYNC: hsync out of range
+ * @MODE_VSYNC: vsync out of range
+ * @MODE_H_ILLEGAL: mode has illegal horizontal timings
+ * @MODE_V_ILLEGAL: mode has illegal horizontal timings
+ * @MODE_BAD_WIDTH: requires an unsupported linepitch
+ * @MODE_NOMODE: no mode with a matching name
+ * @MODE_NO_INTERLACE: interlaced mode not supported
+ * @MODE_NO_DBLESCAN: doublescan mode not supported
+ * @MODE_NO_VSCAN: multiscan mode not supported
+ * @MODE_MEM: insufficient video memory
+ * @MODE_VIRTUAL_X: mode width too large for specified virtual size
+ * @MODE_VIRTUAL_Y: mode height too large for specified virtual size
+ * @MODE_MEM_VIRT: insufficient video memory given virtual size
+ * @MODE_NOCLOCK: no fixed clock available
+ * @MODE_CLOCK_HIGH: clock required is too high
+ * @MODE_CLOCK_LOW: clock required is too low
+ * @MODE_CLOCK_RANGE: clock/mode isn't in a ClockRange
+ * @MODE_BAD_HVALUE: horizontal timing was out of range
+ * @MODE_BAD_VVALUE: vertical timing was out of range
+ * @MODE_BAD_VSCAN: VScan value out of range
+ * @MODE_HSYNC_NARROW: horizontal sync too narrow
+ * @MODE_HSYNC_WIDE: horizontal sync too wide
+ * @MODE_HBLANK_NARROW: horizontal blanking too narrow
+ * @MODE_HBLANK_WIDE: horizontal blanking too wide
+ * @MODE_VSYNC_NARROW: vertical sync too narrow
+ * @MODE_VSYNC_WIDE: vertical sync too wide
+ * @MODE_VBLANK_NARROW: vertical blanking too narrow
+ * @MODE_VBLANK_WIDE: vertical blanking too wide
+ * @MODE_PANEL: exceeds panel dimensions
+ * @MODE_INTERLACE_WIDTH: width too large for interlaced mode
+ * @MODE_ONE_WIDTH: only one width is supported
+ * @MODE_ONE_HEIGHT: only one height is supported
+ * @MODE_ONE_SIZE: only one resolution is supported
+ * @MODE_NO_REDUCED: monitor doesn't accept reduced blanking
+ * @MODE_NO_STEREO: stereo modes not supported
+ * @MODE_UNVERIFIED: mode needs to reverified
+ * @MODE_BAD: unspecified reason
+ * @MODE_ERROR: error condition
+ *
+ * This enum is used to filter out modes not supported by the driver/hardware
+ * combination.
+ */
 enum drm_mode_status {
-    MODE_OK	= 0,	/* Mode OK */
-    MODE_HSYNC,		/* hsync out of range */
-    MODE_VSYNC,		/* vsync out of range */
-    MODE_H_ILLEGAL,	/* mode has illegal horizontal timings */
-    MODE_V_ILLEGAL,	/* mode has illegal horizontal timings */
-    MODE_BAD_WIDTH,	/* requires an unsupported linepitch */
-    MODE_NOMODE,	/* no mode with a matching name */
-    MODE_NO_INTERLACE,	/* interlaced mode not supported */
-    MODE_NO_DBLESCAN,	/* doublescan mode not supported */
-    MODE_NO_VSCAN,	/* multiscan mode not supported */
-    MODE_MEM,		/* insufficient video memory */
-    MODE_VIRTUAL_X,	/* mode width too large for specified virtual size */
-    MODE_VIRTUAL_Y,	/* mode height too large for specified virtual size */
-    MODE_MEM_VIRT,	/* insufficient video memory given virtual size */
-    MODE_NOCLOCK,	/* no fixed clock available */
-    MODE_CLOCK_HIGH,	/* clock required is too high */
-    MODE_CLOCK_LOW,	/* clock required is too low */
-    MODE_CLOCK_RANGE,	/* clock/mode isn't in a ClockRange */
-    MODE_BAD_HVALUE,	/* horizontal timing was out of range */
-    MODE_BAD_VVALUE,	/* vertical timing was out of range */
-    MODE_BAD_VSCAN,	/* VScan value out of range */
-    MODE_HSYNC_NARROW,	/* horizontal sync too narrow */
-    MODE_HSYNC_WIDE,	/* horizontal sync too wide */
-    MODE_HBLANK_NARROW,	/* horizontal blanking too narrow */
-    MODE_HBLANK_WIDE,	/* horizontal blanking too wide */
-    MODE_VSYNC_NARROW,	/* vertical sync too narrow */
-    MODE_VSYNC_WIDE,	/* vertical sync too wide */
-    MODE_VBLANK_NARROW,	/* vertical blanking too narrow */
-    MODE_VBLANK_WIDE,	/* vertical blanking too wide */
-    MODE_PANEL,         /* exceeds panel dimensions */
-    MODE_INTERLACE_WIDTH, /* width too large for interlaced mode */
-    MODE_ONE_WIDTH,     /* only one width is supported */
-    MODE_ONE_HEIGHT,    /* only one height is supported */
-    MODE_ONE_SIZE,      /* only one resolution is supported */
-    MODE_NO_REDUCED,    /* monitor doesn't accept reduced blanking */
-    MODE_NO_STEREO,	/* stereo modes not supported */
-    MODE_UNVERIFIED = -3, /* mode needs to reverified */
-    MODE_BAD = -2,	/* unspecified reason */
-    MODE_ERROR	= -1	/* error condition */
+	MODE_OK = 0,
+	MODE_HSYNC,
+	MODE_VSYNC,
+	MODE_H_ILLEGAL,
+	MODE_V_ILLEGAL,
+	MODE_BAD_WIDTH,
+	MODE_NOMODE,
+	MODE_NO_INTERLACE,
+	MODE_NO_DBLESCAN,
+	MODE_NO_VSCAN,
+	MODE_MEM,
+	MODE_VIRTUAL_X,
+	MODE_VIRTUAL_Y,
+	MODE_MEM_VIRT,
+	MODE_NOCLOCK,
+	MODE_CLOCK_HIGH,
+	MODE_CLOCK_LOW,
+	MODE_CLOCK_RANGE,
+	MODE_BAD_HVALUE,
+	MODE_BAD_VVALUE,
+	MODE_BAD_VSCAN,
+	MODE_HSYNC_NARROW,
+	MODE_HSYNC_WIDE,
+	MODE_HBLANK_NARROW,
+	MODE_HBLANK_WIDE,
+	MODE_VSYNC_NARROW,
+	MODE_VSYNC_WIDE,
+	MODE_VBLANK_NARROW,
+	MODE_VBLANK_WIDE,
+	MODE_PANEL,
+	MODE_INTERLACE_WIDTH,
+	MODE_ONE_WIDTH,
+	MODE_ONE_HEIGHT,
+	MODE_ONE_SIZE,
+	MODE_NO_REDUCED,
+	MODE_NO_STEREO,
+	MODE_UNVERIFIED = -3,
+	MODE_BAD = -2,
+	MODE_ERROR = -1
 };
 
 #define DRM_MODE_TYPE_CLOCK_CRTC_C (DRM_MODE_TYPE_CLOCK_C | \
@@ -96,17 +141,125 @@ enum drm_mode_status {
 
 #define DRM_MODE_FLAG_3D_MAX	DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF
 
+/**
+ * struct drm_display_mode - DRM kernel-internal display mode structure
+ * @hdisplay: horizontal display size
+ * @hsync_start: horizontal sync start
+ * @hsync_end: horizontal sync end
+ * @htotal: horizontal total size
+ * @hskew: horizontal skew?!
+ * @vdisplay: vertical display size
+ * @vsync_start: vertical sync start
+ * @vsync_end: vertical sync end
+ * @vtotal: vertical total size
+ * @vscan: vertical scan?!
+ * @crtc_hdisplay: hardware mode horizontal display size
+ * @crtc_hblank_start: hardware mode horizontal blank start
+ * @crtc_hblank_end: hardware mode horizontal blank end
+ * @crtc_hsync_start: hardware mode horizontal sync start
+ * @crtc_hsync_end: hardware mode horizontal sync end
+ * @crtc_htotal: hardware mode horizontal total size
+ * @crtc_hskew: hardware mode horizontal skew?!
+ * @crtc_vdisplay: hardware mode vertical display size
+ * @crtc_vblank_start: hardware mode vertical blank start
+ * @crtc_vblank_end: hardware mode vertical blank end
+ * @crtc_vsync_start: hardware mode vertical sync start
+ * @crtc_vsync_end: hardware mode vertical sync end
+ * @crtc_vtotal: hardware mode vertical total size
+ *
+ * The horizontal and vertical timings are defined per the following diagram.
+ *
+ *
+ *               Active                 Front           Sync           Back
+ *              Region                 Porch                          Porch
+ *     <-----------------------><----------------><-------------><-------------->
+ *       //////////////////////|
+ *      ////////////////////// |
+ *     //////////////////////  |..................               ................
+ *                                                _______________
+ *     <----- [hv]display ----->
+ *     <------------- [hv]sync_start ------------>
+ *     <--------------------- [hv]sync_end --------------------->
+ *     <-------------------------------- [hv]total ----------------------------->*
+ *
+ * This structure contains two copies of timings. First are the plain timings,
+ * which specify the logical mode, as it would be for a progressive 1:1 scanout
+ * at the refresh rate userspace can observe through vblank timestamps. Then
+ * there's the hardware timings, which are corrected for interlacing,
+ * double-clocking and similar things. They are provided as a convenience, and
+ * can be appropriately computed using drm_mode_set_crtcinfo().
+ */
 struct drm_display_mode {
-	/* Header */
+	/**
+	 * @head:
+	 *
+	 * struct list_head for mode lists.
+	 */
 	struct list_head head;
+
+	/**
+	 * @base:
+	 *
+	 * A display mode is a normal modeset object, possibly including public
+	 * userspace id.
+	 *
+	 * FIXME:
+	 *
+	 * This can probably be removed since the entire concept of userspace
+	 * managing modes explicitly has never landed in upstream kernel mode
+	 * setting support.
+	 */
 	struct drm_mode_object base;
 
+	/**
+	 * @name:
+	 *
+	 * Human-readable name of the mode, filled out with drm_mode_set_name().
+	 */
 	char name[DRM_DISPLAY_MODE_LEN];
 
+	/**
+	 * @status:
+	 *
+	 * Status of the mode, used to filter out modes not supported by the
+	 * hardware. See enum &drm_mode_status.
+	 */
 	enum drm_mode_status status;
+
+	/**
+	 * @type:
+	 *
+	 * A bitmask of flags, mostly about the source of a mode. Possible flags
+	 * are:
+	 *
+	 *  - DRM_MODE_TYPE_BUILTIN: Meant for hard-coded modes, effectively
+	 *    unused.
+	 *  - DRM_MODE_TYPE_PREFERRED: Preferred mode, usually the native
+	 *    resolution of an LCD panel. There should only be one preferred
+	 *    mode per connector at any given time.
+	 *  - DRM_MODE_TYPE_DRIVER: Mode created by the driver, which is all of
+	 *    them really. Drivers must set this bit for all modes they create
+	 *    and expose to userspace.
+	 *
+	 * Plus a big list of flags which shouldn't be used at all, but are
+	 * still around since these flags are also used in the userspace ABI:
+	 *
+	 *  - DRM_MODE_TYPE_DEFAULT: Again a leftover, use
+	 *    DRM_MODE_TYPE_PREFERRED instead.
+	 *  - DRM_MODE_TYPE_CLOCK_C and DRM_MODE_TYPE_CRTC_C: Define leftovers
+	 *    which are stuck around for hysterical raisins only. No one has an
+	 *    idea what they were meant for. Don't use.
+	 *  - DRM_MODE_TYPE_USERDEF: Mode defined by userspace, again a vestige
+	 *    from older kms designs where userspace had to first add a custom
+	 *    mode to the kernel's mode list before it could use it. Don't use.
+	 */
 	unsigned int type;
 
-	/* Proposed mode values */
+	/**
+	 * @clock:
+	 *
+	 * Pixel clock in kHz.
+	 */
 	int clock;		/* in kHz */
 	int hdisplay;
 	int hsync_start;
@@ -118,14 +271,74 @@ struct drm_display_mode {
 	int vsync_end;
 	int vtotal;
 	int vscan;
+	/**
+	 * @flags:
+	 *
+	 * Sync and timing flags:
+	 *
+	 *  - DRM_MODE_FLAG_PHSYNC: horizontal sync is active high.
+	 *  - DRM_MODE_FLAG_NHSYNC: horizontal sync is active low.
+	 *  - DRM_MODE_FLAG_PVSYNC: vertical sync is active high.
+	 *  - DRM_MODE_FLAG_NVSYNC: vertical sync is active low.
+	 *  - DRM_MODE_FLAG_INTERLACE: mode is interlaced.
+	 *  - DRM_MODE_FLAG_DBLSCAN: mode uses doublescan.
+	 *  - DRM_MODE_FLAG_CSYNC: mode uses composite sync.
+	 *  - DRM_MODE_FLAG_PCSYNC: composite sync is active high.
+	 *  - DRM_MODE_FLAG_NCSYNC: composite sync is active low.
+	 *  - DRM_MODE_FLAG_HSKEW: hskew provided (not used?).
+	 *  - DRM_MODE_FLAG_BCAST: not used?
+	 *  - DRM_MODE_FLAG_PIXMUX: not used?
+	 *  - DRM_MODE_FLAG_DBLCLK: double-clocked mode.
+	 *  - DRM_MODE_FLAG_CLKDIV2: half-clocked mode.
+	 *
+	 * Additionally there's flags to specify how 3D modes are packed:
+	 *
+	 *  - DRM_MODE_FLAG_3D_NONE: normal, non-3D mode.
+	 *  - DRM_MODE_FLAG_3D_FRAME_PACKING: 2 full frames for left and right.
+	 *  - DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE: interleaved like fields.
+	 *  - DRM_MODE_FLAG_3D_LINE_ALTERNATIVE: interleaved lines.
+	 *  - DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL: side-by-side full frames.
+	 *  - DRM_MODE_FLAG_3D_L_DEPTH: ?
+	 *  - DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH: ?
+	 *  - DRM_MODE_FLAG_3D_TOP_AND_BOTTOM: frame split into top and bottom
+	 *    parts.
+	 *  - DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF: frame split into left and
+	 *    right parts.
+	 */
 	unsigned int flags;
 
-	/* Addressable image size (may be 0 for projectors, etc.) */
+	/**
+	 * @width_mm:
+	 *
+	 * Addressable size of the output in mm, projectors should set this to
+	 * 0.
+	 */
 	int width_mm;
+
+	/**
+	 * @height_mm:
+	 *
+	 * Addressable size of the output in mm, projectors should set this to
+	 * 0.
+	 */
 	int height_mm;
 
-	/* Actual mode we give to hw */
-	int crtc_clock;		/* in KHz */
+	/**
+	 * @crtc_clock:
+	 *
+	 * Actual pixel or dot clock in the hardware. This differs from the
+	 * logical @clock when e.g. using interlacing, double-clocking, stereo
+	 * modes or other fancy stuff that changes the timings and signals
+	 * actually sent over the wire.
+	 *
+	 * This is again in kHz.
+	 *
+	 * Note that with digital outputs like HDMI or DP there's usually a
+	 * massive confusion between the dot clock and the signal clock at the
+	 * bit encoding level. Especially when a 8b/10b encoding is used and the
+	 * difference is exactly a factor of 10.
+	 */
+	int crtc_clock;
 	int crtc_hdisplay;
 	int crtc_hblank_start;
 	int crtc_hblank_end;
@@ -140,12 +353,48 @@ struct drm_display_mode {
 	int crtc_vsync_end;
 	int crtc_vtotal;
 
-	/* Driver private mode info */
+	/**
+	 * @private:
+	 *
+	 * Pointer for driver private data. This can only be used for mode
+	 * objects passed to drivers in modeset operations. It shouldn't be used
+	 * by atomic drivers since they can store any additional data by
+	 * subclassing state structures.
+	 */
 	int *private;
+
+	/**
+	 * @private_flags:
+	 *
+	 * Similar to @private, but just an integer.
+	 */
 	int private_flags;
 
-	int vrefresh;		/* in Hz */
-	int hsync;		/* in kHz */
+	/**
+	 * @vrefresh:
+	 *
+	 * Vertical refresh rate, for debug output in human readable form. Not
+	 * used in a functional way.
+	 *
+	 * This value is in Hz.
+	 */
+	int vrefresh;
+
+	/**
+	 * @hsync:
+	 *
+	 * Horizontal refresh rate, for debug output in human readable form. Not
+	 * used in a functional way.
+	 *
+	 * This value is in kHz.
+	 */
+	int hsync;
+
+	/**
+	 * @picture_aspect_ratio:
+	 *
+	 * Field for setting the HDMI picture aspect ratio of a mode.
+	 */
 	enum hdmi_picture_aspect picture_aspect_ratio;
 };
 

commit 4c6bcf44549907cb50b67f98eb13717a4adc6b33
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Nov 16 21:05:12 2015 +0200

    drm/edid: Make the detailed timing CEA/HDMI mode fixup accept up to 5kHz clock difference
    
    Rather than using drm_match_cea_mode() to see if the EDID detailed
    timings are supposed to represent one of the CEA/HDMI modes, add a
    special version of that function that takes in an explicit clock
    tolerance value (in kHz). When looking at the detailed timings specify
    the tolerance as 5kHz due to the 10kHz clock resolution limit inherent
    in detailed timings.
    
    drm_match_cea_mode() uses the normal KHZ2PICOS() matching of clocks,
    which only allows smaller errors for lower clocks (eg. for 25200 it
    won't allow any error) and a bigger error for higher clocks (eg. for
    297000 it actually matches 296913-297000). So it doesn't really match
    what we want for the fixup. Using the explicit +-5kHz is much better
    for this use case.
    
    Not sure if we should change the normal mode matching to also use
    something else besides KHZ2PICOS() since it allows a different
    proportion of error depending on the clock. I believe VESA CVT
    allows a maximum deviation of .5%, so using that for normal mode
    matching might be a good idea?
    
    Cc: Adam Jackson <ajax@redhat.com>
    Tested-by: nathan.d.ciobanu@linux.intel.com
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=92217
    Fixes: fa3a7340eaa1 ("drm/edid: Fix up clock for CEA/HDMI modes specified via detailed timings")
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Adam Jackson <ajax@redhat.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 08a8cac9e555..f9115aee43f4 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -222,6 +222,8 @@ struct drm_display_mode *drm_mode_duplicate(struct drm_device *dev,
 					    const struct drm_display_mode *mode);
 bool drm_mode_equal(const struct drm_display_mode *mode1,
 		    const struct drm_display_mode *mode2);
+bool drm_mode_equal_no_clocks(const struct drm_display_mode *mode1,
+			      const struct drm_display_mode *mode2);
 bool drm_mode_equal_no_clocks_no_stereo(const struct drm_display_mode *mode1,
 					const struct drm_display_mode *mode2);
 

commit 934a8a899a7275ed187810fe9a15a93397e88c6b
Author: Daniel Stone <daniels@collabora.com>
Date:   Fri May 22 13:34:48 2015 +0100

    drm/mode: Unstatic kernel-userspace mode conversion
    
    Move the drm_display_mode <-> drm_mode_modeinfo conversion functions
    from drm_crtc.c to drm_modes.c, and make them non-static so that others
    can use them.
    
    Signed-off-by: Daniel Stone <daniels@collabora.com>
    Tested-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 0616188c7801..08a8cac9e555 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -182,6 +182,10 @@ struct drm_cmdline_mode;
 
 struct drm_display_mode *drm_mode_create(struct drm_device *dev);
 void drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode);
+void drm_mode_convert_to_umode(struct drm_mode_modeinfo *out,
+                               const struct drm_display_mode *in);
+int drm_mode_convert_umode(struct drm_display_mode *out,
+			   const struct drm_mode_modeinfo *in);
 void drm_mode_probed_add(struct drm_connector *connector, struct drm_display_mode *mode);
 void drm_mode_debug_printmodeline(const struct drm_display_mode *mode);
 

commit 498b8738485ab1a327163f771953f32cf35ca3b5
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Mon Feb 16 15:12:31 2015 +0000

    drm: Fix the CRTC_STEREO_DOUBLE_ONLY define to include stero modes
    
    The CRTC_STEREO_DOUBLE_ONLY define was introduced in commit:
    
      commit ecb7e16bf187bc369cf6a5cd108582c01329980d
      Author: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
      Date:   Mon Dec 1 15:40:09 2014 -0800
    
          drm: add helper to get crtc timings (v5)
    
    but if we want the stereo h/v adjustments, we need to set the
    CRTC_STEREO_DOUBLE flag. Otherwise, we'll get the wrong h/v for frame packing
    stereo 3d modes.
    
    Cc: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Cc: Matt Roper <matthew.d.roper@intel.com>
    Cc: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index d92f6dd1fb11..0616188c7801 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -92,7 +92,7 @@ enum drm_mode_status {
 #define CRTC_STEREO_DOUBLE	(1 << 1) /* adjust timings for stereo modes */
 #define CRTC_NO_DBLSCAN		(1 << 2) /* don't adjust doublescan */
 #define CRTC_NO_VSCAN		(1 << 3) /* don't adjust doublescan */
-#define CRTC_STEREO_DOUBLE_ONLY	(CRTC_NO_DBLSCAN | CRTC_NO_VSCAN)
+#define CRTC_STEREO_DOUBLE_ONLY	(CRTC_STEREO_DOUBLE | CRTC_NO_DBLSCAN | CRTC_NO_VSCAN)
 
 #define DRM_MODE_FLAG_3D_MAX	DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF
 

commit fc83975348ebce07793e6b9f780edc3cbcffa9fc
Merge: b2eb0489809c d50141d8072e
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Jan 21 10:17:16 2015 +1000

    Merge tag 'imx-drm-next-2015-01-09' of git://git.pengutronix.de/git/pza/linux into drm-next
    
    imx-drm mode fixup support, imx-hdmi bridge conversion and imx-drm cleanup
    
    - Implement mode_fixup for a DI vertical timing limitation
    - Use generic DRM OF helpers in DRM core
    - Convert imx-hdmi to dw_hdmi drm_bridge and add rockchip
      driver
    - Add DC use counter to fix multi-display support
    - Simplify handling of DI clock flags
    - A few small fixes and cleanup
    
    * tag 'imx-drm-next-2015-01-09' of git://git.pengutronix.de/git/pza/linux: (26 commits)
      imx-drm: core: handling of DI clock flags to ipu_crtc_mode_set()
      gpu: ipu-di: Switch to DIV_ROUND_CLOSEST for DI clock divider calc
      gpu: ipu-v3: Use videomode in struct ipu_di_signal_cfg
      imx-drm: encoder prepare/mode_set must use adjusted mode
      imx-drm: ipuv3-crtc: Implement mode_fixup
      drm_modes: add drm_display_mode_to_videomode
      gpu: ipu-di: remove some non-functional code
      gpu: ipu-di: Add ipu_di_adjust_videomode()
      drm: rockchip: export functions needed by rockchip dw_hdmi bridge driver
      drm: bridge/dw_hdmi: request interrupt only after initializing the mutes
      drm: bridge/dw_hdmi: add rockchip rk3288 support
      dt-bindings: Add documentation for rockchip dw hdmi
      drm: bridge/dw_hdmi: add function dw_hdmi_phy_enable_spare
      drm: bridge/dw_hdmi: clear i2cmphy_stat0 reg in hdmi_phy_wait_i2c_done
      drm: bridge/dw_hdmi: add mode_valid support
      drm: bridge/dw_hdmi: add support for multi-byte register width access
      dt-bindings: add document for dw_hdmi
      drm: imx: imx-hdmi: move imx-hdmi to bridge/dw_hdmi
      drm: imx: imx-hdmi: split phy configuration to platform driver
      drm: imx: imx-hdmi: convert imx-hdmi to drm_bridge mode
      ...

commit adc31849b27fefeca6c225d3895143a2ec6970fa
Merge: c93546a5e32b 0e2cfc005b37
Author: Dave Airlie <airlied@redhat.com>
Date:   Sat Jan 10 08:46:24 2015 +1000

    Merge tag 'drm-intel-next-2014-12-19' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - plane handling refactoring from Matt Roper and Gustavo Padovan in prep for
      atomic updates
    - fixes and more patches for the seqno to request transformation from John
    - docbook for fbc from Rodrigo
    - prep work for dual-link dsi from Gaurav Signh
    - crc fixes from Ville
    - special ggtt views infrastructure from Tvrtko Ursulin
    - shadow patch copying for the cmd parser from Brad Volkin
    - execlist and full ppgtt by default on gen8, for testing for now
    
    * tag 'drm-intel-next-2014-12-19' of git://anongit.freedesktop.org/drm-intel: (131 commits)
      drm/i915: Update DRIVER_DATE to 20141219
      drm/i915: Hold runtime PM during plane commit
      drm/i915: Organize bind_vma funcs
      drm/i915: Organize INSTDONE report for future.
      drm/i915: Organize PDP regs report for future.
      drm/i915: Organize PPGTT init
      drm/i915: Organize Fence registers for future enablement.
      drm/i915: tame the chattermouth (v2)
      drm/i915: Warn about missing context state workarounds only once
      drm/i915: Use true PPGTT in Gen8+ when execlists are enabled
      drm/i915: Skip gunit save/restore for cherryview
      drm/i915/chv: Use timeout mode for RC6 on chv
      drm/i915: Add GPGPU_THREADS_DISPATCHED to the register whitelist
      drm/i915: Tidy up execbuffer command parsing code
      drm/i915: Mark shadow batch buffers as purgeable
      drm/i915: Use batch length instead of object size in command parser
      drm/i915: Use batch pools with the command parser
      drm/i915: Implement a framework for batch buffer pools
      drm/i915: fix use after free during eDP encoder destroying
      drm/i915/skl: Skylake also supports DP MST
      ...

commit d490f455f4ac3d97fbf109deae1e017b26acffda
Author: Steve Longerbeam <slongerbeam@gmail.com>
Date:   Thu Dec 18 18:00:22 2014 -0800

    drm_modes: add drm_display_mode_to_videomode
    
    Add conversion from drm_display_mode to videomode.
    
    Signed-off-by: Steve Longerbeam <steve_longerbeam@mentor.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 91d0582f924e..321ae6411546 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -197,6 +197,8 @@ struct drm_display_mode *drm_gtf_mode_complex(struct drm_device *dev,
 					      int GTF_K, int GTF_2J);
 void drm_display_mode_from_videomode(const struct videomode *vm,
 				     struct drm_display_mode *dmode);
+void drm_display_mode_to_videomode(const struct drm_display_mode *dmode,
+				   struct videomode *vm);
 int of_get_drm_display_mode(struct device_node *np,
 			    struct drm_display_mode *dmode,
 			    int index);

commit abc0b1447d4974963548777a5ba4a4457c82c426
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Dec 17 13:56:23 2014 +0200

    drm: Perform basic sanity checks on probed modes
    
    Make sure the timings of probed modes at least pass some very basic
    sanity checks.
    
    The checks include:
     - clock,hdisplay,vdisplay are non zero
     - sync pulse fits within the blanking period
     - htotal,vtotal are big enough
    
    I have not checked all the drivers to see if the modes the generate
    might violate these constraints. I'm hoping not, because that would mean
    either abandoning the idea of doing this from the core code, or fixing
    the drivers.
    
    I'm not entirely sure about limiting the sync pulse to the blanking
    period. Intel hardware doesn't support such things, but some other
    hardware might. However at least HDMI doesn't allow having sync pulse
    edges within the active period, so I'm thinking the check is probably
    OK to have in the common code.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 6c531140d458..a36a5bfce2f5 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -217,6 +217,7 @@ bool drm_mode_equal_no_clocks_no_stereo(const struct drm_display_mode *mode1,
 					const struct drm_display_mode *mode2);
 
 /* for use by the crtc helper probe functions */
+enum drm_mode_status drm_mode_validate_basic(const struct drm_display_mode *mode);
 enum drm_mode_status drm_mode_validate_size(const struct drm_display_mode *mode,
 					    int maxX, int maxY);
 void drm_mode_prune_invalid(struct drm_device *dev,

commit 05acaec334fcc1132d1e48c5042e044651e0b75b
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Dec 17 13:56:22 2014 +0200

    drm: Reorganize probed mode validation
    
    Make drm_mode_validate_size() and drm_mode_validate_flag() deal with a
    single mode instead of having each iterate through the mode list.
    
    The hope is that in the future we might be able to share various mode
    validation functions between modeset and get_modes.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 91d0582f924e..6c531140d458 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -217,9 +217,8 @@ bool drm_mode_equal_no_clocks_no_stereo(const struct drm_display_mode *mode1,
 					const struct drm_display_mode *mode2);
 
 /* for use by the crtc helper probe functions */
-void drm_mode_validate_size(struct drm_device *dev,
-			    struct list_head *mode_list,
-			    int maxX, int maxY);
+enum drm_mode_status drm_mode_validate_size(const struct drm_display_mode *mode,
+					    int maxX, int maxY);
 void drm_mode_prune_invalid(struct drm_device *dev,
 			    struct list_head *mode_list, bool verbose);
 void drm_mode_sort(struct list_head *mode_list);

commit ecb7e16bf187bc369cf6a5cd108582c01329980d
Author: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Date:   Mon Dec 1 15:40:09 2014 -0800

    drm: add helper to get crtc timings (v5)
    
    We need to get hdisplay and vdisplay in a few places so create a
    helper to make our job easier.
    
    Note that drm_crtc_check_viewport() and intel_modeset_pipe_config() were
    previously making adjustments for doublescan modes and vscan > 1 modes,
    which was incorrect.  Using our new helper fixes this mistake.
    
    v2 (by Matt): Use new stereo doubling function (suggested by Ville)
    
    v3 (by Matt):
     - Add missing kerneldoc (Daniel)
     - Use drm_mode_copy() (Jani)
    
    v4 (by Matt):
     - Drop stereo doubling function again; add 'stereo only' flag
       to drm_mode_set_crtcinfo() instead (Ville)
    
    v5 (by Matt):
     - Note behavioral change in drm_crtc_check_viewport() and
       intel_modeset_pipe_config(). (Ander)
     - Describe new adjustment flags in drm_mode_set_crtcinfo()'s
       kerneldoc. (Ander)
    
    Cc: dri-devel@lists.freedesktop.org
    Suggested-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Reviewed-by: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 91d0582f924e..8f17811d27f5 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -90,6 +90,9 @@ enum drm_mode_status {
 
 #define CRTC_INTERLACE_HALVE_V	(1 << 0) /* halve V values for interlacing */
 #define CRTC_STEREO_DOUBLE	(1 << 1) /* adjust timings for stereo modes */
+#define CRTC_NO_DBLSCAN		(1 << 2) /* don't adjust doublescan */
+#define CRTC_NO_VSCAN		(1 << 3) /* don't adjust doublescan */
+#define CRTC_STEREO_DOUBLE_ONLY	(CRTC_NO_DBLSCAN | CRTC_NO_VSCAN)
 
 #define DRM_MODE_FLAG_3D_MAX	DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF
 

commit b87577b7c768683736eea28f70779e8c75b4df62
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu May 1 09:26:53 2014 +1000

    drm: try harder to avoid regression when merging mode bits
    
    For QXL hw we really want the bits to be replaced as we change
    the preferred mode on the fly, and the same goes for virgl when
    I get to it, however the original fix for this seems to have caused
    a wierd regression on Intel G33 that in a stunning display of failure
    at opposition to his normal self, Daniel failed to diagnose.
    
    So we are left doing this, ugly ugly ugly ugly, Daniel you fixed
    that G33 yet?, ugly, ugly.
    
    Tested-by: Marc-André Lureau <marcandre.lureau@redhat.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 2dbbf9976669..91d0582f924e 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -223,7 +223,7 @@ void drm_mode_validate_size(struct drm_device *dev,
 void drm_mode_prune_invalid(struct drm_device *dev,
 			    struct list_head *mode_list, bool verbose);
 void drm_mode_sort(struct list_head *mode_list);
-void drm_mode_connector_list_update(struct drm_connector *connector);
+void drm_mode_connector_list_update(struct drm_connector *connector, bool merge_type_bits);
 
 /* parsing cmdline modes */
 bool

commit fa54143f924ac49ff1a40d4d30452ff33097c236
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 23 21:34:33 2014 +0100

    drm: remove drm_display_mode->private_size
    
    It' unused and there's also not really any way to make it work with
    the current code. So better rip it out.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 995c34d91ef1..2dbbf9976669 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -138,7 +138,6 @@ struct drm_display_mode {
 	int crtc_vtotal;
 
 	/* Driver private mode info */
-	int private_size;
 	int *private;
 	int private_flags;
 

commit f5aabb978d1dcd850d329bcce6dc782bb8621984
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 23 20:05:00 2014 +0100

    drm: polish function kerneldoc for drm_modes.[hc]
    
    - Tune down yelling RETURNS.
    - OCD align all the parameters the same.
    - Add missing kerneldoc, which also means that we need to include the
      kerneldoc from the drm_modes.h header now.
    - Add missing Returns: sections.
    - General polish and clarification - especially the kerneldoc for the
      mode creation helpers seems to have been some good specimen of
      copypasta gone wrong.
    
    All actual code changes have all been extracted into prep patches
    since there was simply too much to polish.
    
    v2: More polish for the command line modeline functions.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index b3507f15d010..995c34d91ef1 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -162,6 +162,14 @@ struct drm_cmdline_mode {
 	enum drm_connector_force force;
 };
 
+/**
+ * drm_mode_is_stereo - check for stereo mode flags
+ * @mode: drm_display_mode to check
+ *
+ * Returns:
+ * True if the mode is one of the stereo modes (like side-by-side), false if
+ * not.
+ */
 static inline bool drm_mode_is_stereo(const struct drm_display_mode *mode)
 {
 	return mode->flags & DRM_MODE_FLAG_3D_MASK;

commit 3e70292cd4a002cd799a1cd4115286cba3933d6d
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 23 16:39:31 2014 +0100

    drm/modes: drop maxPitch from drm_mode_validate_size
    
    Totally unused and actually redundant with maxX for display mode
    validation. The fb helper otoh needs to check pitch limits,
    but that is delegated into drivers instead.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index b23628b22cff..b3507f15d010 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -212,7 +212,7 @@ bool drm_mode_equal_no_clocks_no_stereo(const struct drm_display_mode *mode1,
 /* for use by the crtc helper probe functions */
 void drm_mode_validate_size(struct drm_device *dev,
 			    struct list_head *mode_list,
-			    int maxX, int maxY, int maxPitch);
+			    int maxX, int maxY);
 void drm_mode_prune_invalid(struct drm_device *dev,
 			    struct list_head *mode_list, bool verbose);
 void drm_mode_sort(struct list_head *mode_list);

commit ba0c2422d7cda623acbbcde24542b52c4999bc84
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 23 16:28:50 2014 +0100

    drm/modes: drop return value from drm_display_mode_from_videomode
    
    It never fails and no one ever checked anyway.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 2769b05f7458..b23628b22cff 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -188,8 +188,8 @@ struct drm_display_mode *drm_gtf_mode_complex(struct drm_device *dev,
 					      int margins,
 					      int GTF_M, int GTF_2C,
 					      int GTF_K, int GTF_2J);
-int drm_display_mode_from_videomode(const struct videomode *vm,
-				    struct drm_display_mode *dmode);
+void drm_display_mode_from_videomode(const struct videomode *vm,
+				     struct drm_display_mode *dmode);
 int of_get_drm_display_mode(struct device_node *np,
 			    struct drm_display_mode *dmode,
 			    int index);

commit 9d3de1389ba970d0d35ce6960774dc046b6dd723
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 23 16:27:56 2014 +0100

    drm/modes: remove drm_mode_height/width
    
    There's a neat FIXME asking whether this is really need. I'd
    say really no.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
index 4bd1c122cd39..2769b05f7458 100644
--- a/include/drm/drm_modes.h
+++ b/include/drm/drm_modes.h
@@ -195,8 +195,6 @@ int of_get_drm_display_mode(struct device_node *np,
 			    int index);
 
 void drm_mode_set_name(struct drm_display_mode *mode);
-int drm_mode_width(const struct drm_display_mode *mode);
-int drm_mode_height(const struct drm_display_mode *mode);
 int drm_mode_hsync(const struct drm_display_mode *mode);
 int drm_mode_vrefresh(const struct drm_display_mode *mode);
 

commit 55310008684309985110fdb99fa7b61c649778b2
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 23 15:52:20 2014 +0100

    drm: extract drm_modes.h for drm_crtc.h functions
    
    I want to also include kerneldoc from the header (for static inline
    functions and structs), but fishing the right pieces out of a giant
    header is a real pain. So split things out.
    
    Note that it's not a really clean header with sane include orders, but
    given's drm historical knack for giant headers detangling this is a
    major task.
    
    v2: Also extract struct drm_cmdline_mode.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_modes.h b/include/drm/drm_modes.h
new file mode 100644
index 000000000000..4bd1c122cd39
--- /dev/null
+++ b/include/drm/drm_modes.h
@@ -0,0 +1,232 @@
+/*
+ * Copyright © 2006 Keith Packard
+ * Copyright © 2007-2008 Dave Airlie
+ * Copyright © 2007-2008 Intel Corporation
+ *   Jesse Barnes <jesse.barnes@intel.com>
+ * Copyright © 2014 Intel Corporation
+ *   Daniel Vetter <daniel.vetter@ffwll.ch>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef __DRM_MODES_H__
+#define __DRM_MODES_H__
+
+/*
+ * Note on terminology:  here, for brevity and convenience, we refer to connector
+ * control chips as 'CRTCs'.  They can control any type of connector, VGA, LVDS,
+ * DVI, etc.  And 'screen' refers to the whole of the visible display, which
+ * may span multiple monitors (and therefore multiple CRTC and connector
+ * structures).
+ */
+
+enum drm_mode_status {
+    MODE_OK	= 0,	/* Mode OK */
+    MODE_HSYNC,		/* hsync out of range */
+    MODE_VSYNC,		/* vsync out of range */
+    MODE_H_ILLEGAL,	/* mode has illegal horizontal timings */
+    MODE_V_ILLEGAL,	/* mode has illegal horizontal timings */
+    MODE_BAD_WIDTH,	/* requires an unsupported linepitch */
+    MODE_NOMODE,	/* no mode with a matching name */
+    MODE_NO_INTERLACE,	/* interlaced mode not supported */
+    MODE_NO_DBLESCAN,	/* doublescan mode not supported */
+    MODE_NO_VSCAN,	/* multiscan mode not supported */
+    MODE_MEM,		/* insufficient video memory */
+    MODE_VIRTUAL_X,	/* mode width too large for specified virtual size */
+    MODE_VIRTUAL_Y,	/* mode height too large for specified virtual size */
+    MODE_MEM_VIRT,	/* insufficient video memory given virtual size */
+    MODE_NOCLOCK,	/* no fixed clock available */
+    MODE_CLOCK_HIGH,	/* clock required is too high */
+    MODE_CLOCK_LOW,	/* clock required is too low */
+    MODE_CLOCK_RANGE,	/* clock/mode isn't in a ClockRange */
+    MODE_BAD_HVALUE,	/* horizontal timing was out of range */
+    MODE_BAD_VVALUE,	/* vertical timing was out of range */
+    MODE_BAD_VSCAN,	/* VScan value out of range */
+    MODE_HSYNC_NARROW,	/* horizontal sync too narrow */
+    MODE_HSYNC_WIDE,	/* horizontal sync too wide */
+    MODE_HBLANK_NARROW,	/* horizontal blanking too narrow */
+    MODE_HBLANK_WIDE,	/* horizontal blanking too wide */
+    MODE_VSYNC_NARROW,	/* vertical sync too narrow */
+    MODE_VSYNC_WIDE,	/* vertical sync too wide */
+    MODE_VBLANK_NARROW,	/* vertical blanking too narrow */
+    MODE_VBLANK_WIDE,	/* vertical blanking too wide */
+    MODE_PANEL,         /* exceeds panel dimensions */
+    MODE_INTERLACE_WIDTH, /* width too large for interlaced mode */
+    MODE_ONE_WIDTH,     /* only one width is supported */
+    MODE_ONE_HEIGHT,    /* only one height is supported */
+    MODE_ONE_SIZE,      /* only one resolution is supported */
+    MODE_NO_REDUCED,    /* monitor doesn't accept reduced blanking */
+    MODE_NO_STEREO,	/* stereo modes not supported */
+    MODE_UNVERIFIED = -3, /* mode needs to reverified */
+    MODE_BAD = -2,	/* unspecified reason */
+    MODE_ERROR	= -1	/* error condition */
+};
+
+#define DRM_MODE_TYPE_CLOCK_CRTC_C (DRM_MODE_TYPE_CLOCK_C | \
+				    DRM_MODE_TYPE_CRTC_C)
+
+#define DRM_MODE(nm, t, c, hd, hss, hse, ht, hsk, vd, vss, vse, vt, vs, f) \
+	.name = nm, .status = 0, .type = (t), .clock = (c), \
+	.hdisplay = (hd), .hsync_start = (hss), .hsync_end = (hse), \
+	.htotal = (ht), .hskew = (hsk), .vdisplay = (vd), \
+	.vsync_start = (vss), .vsync_end = (vse), .vtotal = (vt), \
+	.vscan = (vs), .flags = (f), \
+	.base.type = DRM_MODE_OBJECT_MODE
+
+#define CRTC_INTERLACE_HALVE_V	(1 << 0) /* halve V values for interlacing */
+#define CRTC_STEREO_DOUBLE	(1 << 1) /* adjust timings for stereo modes */
+
+#define DRM_MODE_FLAG_3D_MAX	DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF
+
+struct drm_display_mode {
+	/* Header */
+	struct list_head head;
+	struct drm_mode_object base;
+
+	char name[DRM_DISPLAY_MODE_LEN];
+
+	enum drm_mode_status status;
+	unsigned int type;
+
+	/* Proposed mode values */
+	int clock;		/* in kHz */
+	int hdisplay;
+	int hsync_start;
+	int hsync_end;
+	int htotal;
+	int hskew;
+	int vdisplay;
+	int vsync_start;
+	int vsync_end;
+	int vtotal;
+	int vscan;
+	unsigned int flags;
+
+	/* Addressable image size (may be 0 for projectors, etc.) */
+	int width_mm;
+	int height_mm;
+
+	/* Actual mode we give to hw */
+	int crtc_clock;		/* in KHz */
+	int crtc_hdisplay;
+	int crtc_hblank_start;
+	int crtc_hblank_end;
+	int crtc_hsync_start;
+	int crtc_hsync_end;
+	int crtc_htotal;
+	int crtc_hskew;
+	int crtc_vdisplay;
+	int crtc_vblank_start;
+	int crtc_vblank_end;
+	int crtc_vsync_start;
+	int crtc_vsync_end;
+	int crtc_vtotal;
+
+	/* Driver private mode info */
+	int private_size;
+	int *private;
+	int private_flags;
+
+	int vrefresh;		/* in Hz */
+	int hsync;		/* in kHz */
+	enum hdmi_picture_aspect picture_aspect_ratio;
+};
+
+/* mode specified on the command line */
+struct drm_cmdline_mode {
+	bool specified;
+	bool refresh_specified;
+	bool bpp_specified;
+	int xres, yres;
+	int bpp;
+	int refresh;
+	bool rb;
+	bool interlace;
+	bool cvt;
+	bool margins;
+	enum drm_connector_force force;
+};
+
+static inline bool drm_mode_is_stereo(const struct drm_display_mode *mode)
+{
+	return mode->flags & DRM_MODE_FLAG_3D_MASK;
+}
+
+struct drm_connector;
+struct drm_cmdline_mode;
+
+struct drm_display_mode *drm_mode_create(struct drm_device *dev);
+void drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode);
+void drm_mode_probed_add(struct drm_connector *connector, struct drm_display_mode *mode);
+void drm_mode_debug_printmodeline(const struct drm_display_mode *mode);
+
+struct drm_display_mode *drm_cvt_mode(struct drm_device *dev,
+				      int hdisplay, int vdisplay, int vrefresh,
+				      bool reduced, bool interlaced,
+				      bool margins);
+struct drm_display_mode *drm_gtf_mode(struct drm_device *dev,
+				      int hdisplay, int vdisplay, int vrefresh,
+				      bool interlaced, int margins);
+struct drm_display_mode *drm_gtf_mode_complex(struct drm_device *dev,
+					      int hdisplay, int vdisplay,
+					      int vrefresh, bool interlaced,
+					      int margins,
+					      int GTF_M, int GTF_2C,
+					      int GTF_K, int GTF_2J);
+int drm_display_mode_from_videomode(const struct videomode *vm,
+				    struct drm_display_mode *dmode);
+int of_get_drm_display_mode(struct device_node *np,
+			    struct drm_display_mode *dmode,
+			    int index);
+
+void drm_mode_set_name(struct drm_display_mode *mode);
+int drm_mode_width(const struct drm_display_mode *mode);
+int drm_mode_height(const struct drm_display_mode *mode);
+int drm_mode_hsync(const struct drm_display_mode *mode);
+int drm_mode_vrefresh(const struct drm_display_mode *mode);
+
+void drm_mode_set_crtcinfo(struct drm_display_mode *p,
+			   int adjust_flags);
+void drm_mode_copy(struct drm_display_mode *dst,
+		   const struct drm_display_mode *src);
+struct drm_display_mode *drm_mode_duplicate(struct drm_device *dev,
+					    const struct drm_display_mode *mode);
+bool drm_mode_equal(const struct drm_display_mode *mode1,
+		    const struct drm_display_mode *mode2);
+bool drm_mode_equal_no_clocks_no_stereo(const struct drm_display_mode *mode1,
+					const struct drm_display_mode *mode2);
+
+/* for use by the crtc helper probe functions */
+void drm_mode_validate_size(struct drm_device *dev,
+			    struct list_head *mode_list,
+			    int maxX, int maxY, int maxPitch);
+void drm_mode_prune_invalid(struct drm_device *dev,
+			    struct list_head *mode_list, bool verbose);
+void drm_mode_sort(struct list_head *mode_list);
+void drm_mode_connector_list_update(struct drm_connector *connector);
+
+/* parsing cmdline modes */
+bool
+drm_mode_parse_command_line_for_connector(const char *mode_option,
+					  struct drm_connector *connector,
+					  struct drm_cmdline_mode *mode);
+struct drm_display_mode *
+drm_mode_create_from_cmdline_mode(struct drm_device *dev,
+				  struct drm_cmdline_mode *cmd);
+
+#endif /* __DRM_MODES_H__ */
