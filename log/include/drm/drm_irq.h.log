commit 3ed4351a83ca05d3cd886ade6900be1067aa7903
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed May 31 11:21:46 2017 +0200

    drm: Extract drm_vblank.[hc]
    
    drm_irq.c contains both the irq helper library (optional) and the
    vblank support (optional, but part of the modeset uapi, and doesn't
    require the use of the irq helpers at all.
    
    Split this up for more clarity of the scope of the individual bits.
    
    v2: Move misplaced hunks to this patch (Stefan).
    
    Cc: Stefan Agner <stefan@agner.ch>
    Reviewed-by: Stefan Agner <stefan@agner.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170531092146.12528-1-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_irq.h b/include/drm/drm_irq.h
index 569ca86d4e1f..d77f6e65b1c6 100644
--- a/include/drm/drm_irq.h
+++ b/include/drm/drm_irq.h
@@ -24,165 +24,9 @@
 #ifndef _DRM_IRQ_H_
 #define _DRM_IRQ_H_
 
-#include <linux/seqlock.h>
-
-/**
- * struct drm_pending_vblank_event - pending vblank event tracking
- */
-struct drm_pending_vblank_event {
-	/**
-	 * @base: Base structure for tracking pending DRM events.
-	 */
-	struct drm_pending_event base;
-	/**
-	 * @pipe: drm_crtc_index() of the &drm_crtc this event is for.
-	 */
-	unsigned int pipe;
-	/**
-	 * @event: Actual event which will be sent to userspace.
-	 */
-	struct drm_event_vblank event;
-};
-
-/**
- * struct drm_vblank_crtc - vblank tracking for a CRTC
- *
- * This structure tracks the vblank state for one CRTC.
- *
- * Note that for historical reasons - the vblank handling code is still shared
- * with legacy/non-kms drivers - this is a free-standing structure not directly
- * connected to &struct drm_crtc. But all public interface functions are taking
- * a &struct drm_crtc to hide this implementation detail.
- */
-struct drm_vblank_crtc {
-	/**
-	 * @dev: Pointer to the &drm_device.
-	 */
-	struct drm_device *dev;
-	/**
-	 * @queue: Wait queue for vblank waiters.
-	 */
-	wait_queue_head_t queue;	/**< VBLANK wait queue */
-	/**
-	 * @disable_timer: Disable timer for the delayed vblank disabling
-	 * hysteresis logic. Vblank disabling is controlled through the
-	 * drm_vblank_offdelay module option and the setting of the
-	 * &drm_device.max_vblank_count value.
-	 */
-	struct timer_list disable_timer;
-
-	/**
-	 * @seqlock: Protect vblank count and time.
-	 */
-	seqlock_t seqlock;		/* protects vblank count and time */
-
-	/**
-	 * @count: Current software vblank counter.
-	 */
-	u32 count;
-	/**
-	 * @time: Vblank timestamp corresponding to @count.
-	 */
-	struct timeval time;
-
-	/**
-	 * @refcount: Number of users/waiters of the vblank interrupt. Only when
-	 * this refcount reaches 0 can the hardware interrupt be disabled using
-	 * @disable_timer.
-	 */
-	atomic_t refcount;		/* number of users of vblank interruptsper crtc */
-	/**
-	 * @last: Protected by &drm_device.vbl_lock, used for wraparound handling.
-	 */
-	u32 last;
-	/**
-	 * @inmodeset: Tracks whether the vblank is disabled due to a modeset.
-	 * For legacy driver bit 2 additionally tracks whether an additional
-	 * temporary vblank reference has been acquired to paper over the
-	 * hardware counter resetting/jumping. KMS drivers should instead just
-	 * call drm_crtc_vblank_off() and drm_crtc_vblank_on(), which explicitly
-	 * save and restore the vblank count.
-	 */
-	unsigned int inmodeset;		/* Display driver is setting mode */
-	/**
-	 * @pipe: drm_crtc_index() of the &drm_crtc corresponding to this
-	 * structure.
-	 */
-	unsigned int pipe;
-	/**
-	 * @framedur_ns: Frame/Field duration in ns, used by
-	 * drm_calc_vbltimestamp_from_scanoutpos() and computed by
-	 * drm_calc_timestamping_constants().
-	 */
-	int framedur_ns;
-	/**
-	 * @linedur_ns: Line duration in ns, used by
-	 * drm_calc_vbltimestamp_from_scanoutpos() and computed by
-	 * drm_calc_timestamping_constants().
-	 */
-	int linedur_ns;
-
-	/**
-	 * @hwmode:
-	 *
-	 * Cache of the current hardware display mode. Only valid when @enabled
-	 * is set. This is used by helpers like
-	 * drm_calc_vbltimestamp_from_scanoutpos(). We can't just access the
-	 * hardware mode by e.g. looking at &drm_crtc_state.adjusted_mode,
-	 * because that one is really hard to get from interrupt context.
-	 */
-	struct drm_display_mode hwmode;
-
-	/**
-	 * @enabled: Tracks the enabling state of the corresponding &drm_crtc to
-	 * avoid double-disabling and hence corrupting saved state. Needed by
-	 * drivers not using atomic KMS, since those might go through their CRTC
-	 * disabling functions multiple times.
-	 */
-	bool enabled;
-};
+struct drm_device;
 
 int drm_irq_install(struct drm_device *dev, int irq);
 int drm_irq_uninstall(struct drm_device *dev);
 
-int drm_vblank_init(struct drm_device *dev, unsigned int num_crtcs);
-u32 drm_crtc_vblank_count(struct drm_crtc *crtc);
-u32 drm_crtc_vblank_count_and_time(struct drm_crtc *crtc,
-				   struct timeval *vblanktime);
-void drm_crtc_send_vblank_event(struct drm_crtc *crtc,
-			       struct drm_pending_vblank_event *e);
-void drm_crtc_arm_vblank_event(struct drm_crtc *crtc,
-			      struct drm_pending_vblank_event *e);
-bool drm_handle_vblank(struct drm_device *dev, unsigned int pipe);
-bool drm_crtc_handle_vblank(struct drm_crtc *crtc);
-int drm_crtc_vblank_get(struct drm_crtc *crtc);
-void drm_crtc_vblank_put(struct drm_crtc *crtc);
-void drm_wait_one_vblank(struct drm_device *dev, unsigned int pipe);
-void drm_crtc_wait_one_vblank(struct drm_crtc *crtc);
-void drm_crtc_vblank_off(struct drm_crtc *crtc);
-void drm_crtc_vblank_reset(struct drm_crtc *crtc);
-void drm_crtc_vblank_on(struct drm_crtc *crtc);
-void drm_vblank_cleanup(struct drm_device *dev);
-u32 drm_accurate_vblank_count(struct drm_crtc *crtc);
-
-bool drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev,
-					   unsigned int pipe, int *max_error,
-					   struct timeval *vblank_time,
-					   bool in_vblank_irq);
-void drm_calc_timestamping_constants(struct drm_crtc *crtc,
-				     const struct drm_display_mode *mode);
-
-/**
- * drm_crtc_vblank_waitqueue - get vblank waitqueue for the CRTC
- * @crtc: which CRTC's vblank waitqueue to retrieve
- *
- * This function returns a pointer to the vblank waitqueue for the CRTC.
- * Drivers can use this to implement vblank waits using wait_event() and related
- * functions.
- */
-static inline wait_queue_head_t *drm_crtc_vblank_waitqueue(struct drm_crtc *crtc)
-{
-	return &crtc->dev->vblank[drm_crtc_index(crtc)].queue;
-}
-
 #endif

commit 1bf6ad622b9be58484279978f85716fbb10d545b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue May 9 16:03:28 2017 +0200

    drm/vblank: drop the mode argument from drm_calc_vbltimestamp_from_scanoutpos
    
    If we restrict this helper to only kms drivers (which is the case) we
    can look up the correct mode easily ourselves. But it's a bit tricky:
    
    - All legacy drivers look at crtc->hwmode. But that is updated already
      at the beginning of the modeset helper, which means when we disable
      a pipe. Hence the final timestamps might be a bit off. But since
      this is an existing bug I'm not going to change it, but just try to
      be bug-for-bug compatible with the current code. This only applies
      to radeon&amdgpu.
    
    - i915 tries to get it perfect by updating crtc->hwmode when the pipe
      is off (i.e. vblank->enabled = false).
    
    - All other atomic drivers look at crtc->state->adjusted_mode. Those
      that look at state->requested_mode simply don't adjust their mode,
      so it's the same. That has two problems: Accessing crtc->state from
      interrupt handling code is unsafe, and it's updated before we shut
      down the pipe. For nonblocking modesets it's even worse.
    
    For atomic drivers try to implement what i915 does. To do that we add
    a new hwmode field to the vblank structure, and update it from
    drm_calc_timestamping_constants(). For atomic drivers that's called
    from the right spot by the helper library already, so all fine. But
    for safety let's enforce that.
    
    For legacy driver this function is only called at the end (oh the
    fun), which is broken, so again let's not bother and just stay
    bug-for-bug compatible.
    
    The  benefit is that we can use drm_calc_vbltimestamp_from_scanoutpos
    directly to implement ->get_vblank_timestamp in every driver, deleting
    a lot of code.
    
    v2: Completely new approach, trying to mimick the i915 solution.
    
    v3: Fixup kerneldoc.
    
    v4: Drop the WARN_ON to check that the vblank is off, atomic helpers
    currently unconditionally call this. Recomputing the same stuff should
    be harmless.
    
    v5: Fix typos and move misplaced hunks to the right patches (Neil).
    
    v6: Undo hunk movement (kbuild).
    
    Cc: Mario Kleiner <mario.kleiner@tuebingen.mpg.de>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Christian König <christian.koenig@amd.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Reviewed-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170509140329.24114-4-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_irq.h b/include/drm/drm_irq.h
index 445406efb8dc..569ca86d4e1f 100644
--- a/include/drm/drm_irq.h
+++ b/include/drm/drm_irq.h
@@ -121,6 +121,18 @@ struct drm_vblank_crtc {
 	 * drm_calc_timestamping_constants().
 	 */
 	int linedur_ns;
+
+	/**
+	 * @hwmode:
+	 *
+	 * Cache of the current hardware display mode. Only valid when @enabled
+	 * is set. This is used by helpers like
+	 * drm_calc_vbltimestamp_from_scanoutpos(). We can't just access the
+	 * hardware mode by e.g. looking at &drm_crtc_state.adjusted_mode,
+	 * because that one is really hard to get from interrupt context.
+	 */
+	struct drm_display_mode hwmode;
+
 	/**
 	 * @enabled: Tracks the enabling state of the corresponding &drm_crtc to
 	 * avoid double-disabling and hence corrupting saved state. Needed by
@@ -156,8 +168,7 @@ u32 drm_accurate_vblank_count(struct drm_crtc *crtc);
 bool drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev,
 					   unsigned int pipe, int *max_error,
 					   struct timeval *vblank_time,
-					   bool in_vblank_irq,
-					   const struct drm_display_mode *mode);
+					   bool in_vblank_irq);
 void drm_calc_timestamping_constants(struct drm_crtc *crtc,
 				     const struct drm_display_mode *mode);
 

commit 3fcdcb270936ae69a069bab4c52ebd9fde594669
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue May 9 16:03:26 2017 +0200

    drm/vblank: Switch to bool in_vblank_irq in get_vblank_timestamp
    
    It's overkill to have a flag parameter which is essentially used just
    as a boolean. This takes care of core + adjusting drivers.
    
    Adjusting the scanout position callback is a bit harder, since radeon
    also supplies it's own driver-private flags in there.
    
    v2: Fixup misplaced hunks (Neil).
    
    v3: kbuild says v1 was better ...
    
    Cc: Mario Kleiner <mario.kleiner@tuebingen.mpg.de>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Christian König <christian.koenig@amd.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Neil Armstrong <narmstrong@baylibre.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170509140329.24114-2-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_irq.h b/include/drm/drm_irq.h
index f0d5ccf9b282..445406efb8dc 100644
--- a/include/drm/drm_irq.h
+++ b/include/drm/drm_irq.h
@@ -156,7 +156,7 @@ u32 drm_accurate_vblank_count(struct drm_crtc *crtc);
 bool drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev,
 					   unsigned int pipe, int *max_error,
 					   struct timeval *vblank_time,
-					   unsigned flags,
+					   bool in_vblank_irq,
 					   const struct drm_display_mode *mode);
 void drm_calc_timestamping_constants(struct drm_crtc *crtc,
 				     const struct drm_display_mode *mode);

commit d673c02c4bdbcbe3076a2680f9c954be26b525c8
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue May 9 16:03:25 2017 +0200

    drm/vblank: Switch drm_driver->get_vblank_timestamp to return a bool
    
    There's really no reason for anything more:
    - Calling this while the crtc vblank stuff isn't set up is a driver
      bug. Those places alrready DRM_ERROR.
    - Calling this when the crtc is off is either a driver bug (calling
      drm_crtc_handle_vblank at the wrong time) or a core bug (for
      anything else). Again, we DRM_ERROR.
    - EINVAL is checked at higher levels already, and if we'd use struct
      drm_crtc * instead of (dev, pipe) it would be real obvious that
      those are again core bugs.
    
    The only valid failure mode is crap hardware that couldn't sample a
    useful timestamp, to ask the core to just grab a not-so-accurate
    timestamp. Bool is perfectly fine for that.
    
    v2: Also fix up the one caller, I lost that in the shuffling (Jani).
    
    v3: Fixup commit message (Neil).
    
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Mario Kleiner <mario.kleiner@tuebingen.mpg.de>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Christian König <christian.koenig@amd.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Reviewed-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170509140329.24114-1-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_irq.h b/include/drm/drm_irq.h
index cf0be6594c8c..f0d5ccf9b282 100644
--- a/include/drm/drm_irq.h
+++ b/include/drm/drm_irq.h
@@ -153,11 +153,11 @@ void drm_crtc_vblank_on(struct drm_crtc *crtc);
 void drm_vblank_cleanup(struct drm_device *dev);
 u32 drm_accurate_vblank_count(struct drm_crtc *crtc);
 
-int drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev,
-					  unsigned int pipe, int *max_error,
-					  struct timeval *vblank_time,
-					  unsigned flags,
-					  const struct drm_display_mode *mode);
+bool drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev,
+					   unsigned int pipe, int *max_error,
+					   struct timeval *vblank_time,
+					   unsigned flags,
+					   const struct drm_display_mode *mode);
 void drm_calc_timestamping_constants(struct drm_crtc *crtc,
 				     const struct drm_display_mode *mode);
 

commit 5ac74757eef78d69cd3aabe503b29aff471fdd56
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Tue Feb 7 17:16:15 2017 +0800

    drm: unexport function drm_vblank_no_hw_counter()
    
    The function drm_vblank_no_hw_counter() is now only used in core vblank
    wrapper code.  Let's unexport it by making it a static function.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1486458995-31018-4-git-send-email-shawnguo@kernel.org

diff --git a/include/drm/drm_irq.h b/include/drm/drm_irq.h
index 2fb880462a57..cf0be6594c8c 100644
--- a/include/drm/drm_irq.h
+++ b/include/drm/drm_irq.h
@@ -152,7 +152,6 @@ void drm_crtc_vblank_reset(struct drm_crtc *crtc);
 void drm_crtc_vblank_on(struct drm_crtc *crtc);
 void drm_vblank_cleanup(struct drm_device *dev);
 u32 drm_accurate_vblank_count(struct drm_crtc *crtc);
-u32 drm_vblank_no_hw_counter(struct drm_device *dev, unsigned int pipe);
 
 int drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev,
 					  unsigned int pipe, int *max_error,

commit ef40cbf9998528e4f4457df52624d56ae95a7dee
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jan 25 07:26:47 2017 +0100

    drm/core: Use recommened kerneldoc for struct member refs
    
    I just learned that &struct_name.member_name works and looks pretty
    even. It doesn't (yet) link to the member directly though, which would
    be really good for big structures or vfunc tables (where the
    per-member kerneldoc tends to be long).
    
    Also some minor drive-by polish where it makes sense, I read a lot
    of docs ...
    
    v2: Review from Gustavo.
    
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Gustavo Padovan <gustavo.padovan@collabora.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170125062657.19270-6-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_irq.h b/include/drm/drm_irq.h
index 18cfd11307e1..2fb880462a57 100644
--- a/include/drm/drm_irq.h
+++ b/include/drm/drm_irq.h
@@ -67,7 +67,7 @@ struct drm_vblank_crtc {
 	 * @disable_timer: Disable timer for the delayed vblank disabling
 	 * hysteresis logic. Vblank disabling is controlled through the
 	 * drm_vblank_offdelay module option and the setting of the
-	 * max_vblank_count value in the &drm_device structure.
+	 * &drm_device.max_vblank_count value.
 	 */
 	struct timer_list disable_timer;
 
@@ -92,7 +92,7 @@ struct drm_vblank_crtc {
 	 */
 	atomic_t refcount;		/* number of users of vblank interruptsper crtc */
 	/**
-	 * @last: Protected by dev->vbl_lock, used for wraparound handling.
+	 * @last: Protected by &drm_device.vbl_lock, used for wraparound handling.
 	 */
 	u32 last;
 	/**

commit ea0dd85a75f15174cc2bf75f805e378391995931
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Dec 29 21:48:26 2016 +0100

    drm/doc: use preferred struct reference in kernel-doc
    
    sed -e 's/\( \* .*\)struct &\([_a-z]*\)/\1\&struct \2/' -i
    
    Originally I wasnt a friend of this style because I thought a
    line-break between the "&struct" and "foo" part would break it. But a
    quick test shows that " * &struct \n * foo\n" works pefectly well with
    current kernel-doc. So time to mass-apply these changes!
    
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1483044517-5770-6-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_irq.h b/include/drm/drm_irq.h
index 293d08caab60..18cfd11307e1 100644
--- a/include/drm/drm_irq.h
+++ b/include/drm/drm_irq.h
@@ -51,8 +51,8 @@ struct drm_pending_vblank_event {
  *
  * Note that for historical reasons - the vblank handling code is still shared
  * with legacy/non-kms drivers - this is a free-standing structure not directly
- * connected to struct &drm_crtc. But all public interface functions are taking
- * a struct &drm_crtc to hide this implementation detail.
+ * connected to &struct drm_crtc. But all public interface functions are taking
+ * a &struct drm_crtc to hide this implementation detail.
  */
 struct drm_vblank_crtc {
 	/**

commit b9876d5061a068ba647c8b9923aff8c975bb73a3
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Nov 14 10:02:55 2016 +0100

    drm: drm_irq.h header cleanup
    
    - Drop extern for functions, it's noise.
    - Move&consolidate drm.ko internal parts into drm-internal.h.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161114090255.31595-6-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_irq.h b/include/drm/drm_irq.h
index 92e59d0a5ddb..293d08caab60 100644
--- a/include/drm/drm_irq.h
+++ b/include/drm/drm_irq.h
@@ -130,39 +130,37 @@ struct drm_vblank_crtc {
 	bool enabled;
 };
 
-extern int drm_irq_install(struct drm_device *dev, int irq);
-extern int drm_irq_uninstall(struct drm_device *dev);
+int drm_irq_install(struct drm_device *dev, int irq);
+int drm_irq_uninstall(struct drm_device *dev);
 
-extern int drm_vblank_init(struct drm_device *dev, unsigned int num_crtcs);
-extern int drm_wait_vblank(struct drm_device *dev, void *data,
-			   struct drm_file *filp);
-extern u32 drm_crtc_vblank_count(struct drm_crtc *crtc);
-extern u32 drm_crtc_vblank_count_and_time(struct drm_crtc *crtc,
-					  struct timeval *vblanktime);
-extern void drm_crtc_send_vblank_event(struct drm_crtc *crtc,
-				       struct drm_pending_vblank_event *e);
-extern void drm_crtc_arm_vblank_event(struct drm_crtc *crtc,
-				      struct drm_pending_vblank_event *e);
-extern bool drm_handle_vblank(struct drm_device *dev, unsigned int pipe);
-extern bool drm_crtc_handle_vblank(struct drm_crtc *crtc);
-extern int drm_crtc_vblank_get(struct drm_crtc *crtc);
-extern void drm_crtc_vblank_put(struct drm_crtc *crtc);
-extern void drm_wait_one_vblank(struct drm_device *dev, unsigned int pipe);
-extern void drm_crtc_wait_one_vblank(struct drm_crtc *crtc);
-extern void drm_crtc_vblank_off(struct drm_crtc *crtc);
-extern void drm_crtc_vblank_reset(struct drm_crtc *crtc);
-extern void drm_crtc_vblank_on(struct drm_crtc *crtc);
-extern void drm_vblank_cleanup(struct drm_device *dev);
-extern u32 drm_accurate_vblank_count(struct drm_crtc *crtc);
-extern u32 drm_vblank_no_hw_counter(struct drm_device *dev, unsigned int pipe);
+int drm_vblank_init(struct drm_device *dev, unsigned int num_crtcs);
+u32 drm_crtc_vblank_count(struct drm_crtc *crtc);
+u32 drm_crtc_vblank_count_and_time(struct drm_crtc *crtc,
+				   struct timeval *vblanktime);
+void drm_crtc_send_vblank_event(struct drm_crtc *crtc,
+			       struct drm_pending_vblank_event *e);
+void drm_crtc_arm_vblank_event(struct drm_crtc *crtc,
+			      struct drm_pending_vblank_event *e);
+bool drm_handle_vblank(struct drm_device *dev, unsigned int pipe);
+bool drm_crtc_handle_vblank(struct drm_crtc *crtc);
+int drm_crtc_vblank_get(struct drm_crtc *crtc);
+void drm_crtc_vblank_put(struct drm_crtc *crtc);
+void drm_wait_one_vblank(struct drm_device *dev, unsigned int pipe);
+void drm_crtc_wait_one_vblank(struct drm_crtc *crtc);
+void drm_crtc_vblank_off(struct drm_crtc *crtc);
+void drm_crtc_vblank_reset(struct drm_crtc *crtc);
+void drm_crtc_vblank_on(struct drm_crtc *crtc);
+void drm_vblank_cleanup(struct drm_device *dev);
+u32 drm_accurate_vblank_count(struct drm_crtc *crtc);
+u32 drm_vblank_no_hw_counter(struct drm_device *dev, unsigned int pipe);
 
-extern int drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev,
-						 unsigned int pipe, int *max_error,
-						 struct timeval *vblank_time,
-						 unsigned flags,
-						 const struct drm_display_mode *mode);
-extern void drm_calc_timestamping_constants(struct drm_crtc *crtc,
-					    const struct drm_display_mode *mode);
+int drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev,
+					  unsigned int pipe, int *max_error,
+					  struct timeval *vblank_time,
+					  unsigned flags,
+					  const struct drm_display_mode *mode);
+void drm_calc_timestamping_constants(struct drm_crtc *crtc,
+				     const struct drm_display_mode *mode);
 
 /**
  * drm_crtc_vblank_waitqueue - get vblank waitqueue for the CRTC

commit 2d1e331fa942c963a92f50e3a2a5761fee006369
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Nov 14 10:02:54 2016 +0100

    drm/irq: Unexport drm_vblank_on/off
    
    Only remaining use was in amdgpu, and trivial to convert over to
    drm_crtc_vblank_* variants.
    
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Christian König <christian.koenig@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161114090255.31595-5-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_irq.h b/include/drm/drm_irq.h
index 2401b14d301f..92e59d0a5ddb 100644
--- a/include/drm/drm_irq.h
+++ b/include/drm/drm_irq.h
@@ -136,7 +136,6 @@ extern int drm_irq_uninstall(struct drm_device *dev);
 extern int drm_vblank_init(struct drm_device *dev, unsigned int num_crtcs);
 extern int drm_wait_vblank(struct drm_device *dev, void *data,
 			   struct drm_file *filp);
-extern u32 drm_vblank_count(struct drm_device *dev, unsigned int pipe);
 extern u32 drm_crtc_vblank_count(struct drm_crtc *crtc);
 extern u32 drm_crtc_vblank_count_and_time(struct drm_crtc *crtc,
 					  struct timeval *vblanktime);
@@ -150,8 +149,6 @@ extern int drm_crtc_vblank_get(struct drm_crtc *crtc);
 extern void drm_crtc_vblank_put(struct drm_crtc *crtc);
 extern void drm_wait_one_vblank(struct drm_device *dev, unsigned int pipe);
 extern void drm_crtc_wait_one_vblank(struct drm_crtc *crtc);
-extern void drm_vblank_off(struct drm_device *dev, unsigned int pipe);
-extern void drm_vblank_on(struct drm_device *dev, unsigned int pipe);
 extern void drm_crtc_vblank_off(struct drm_crtc *crtc);
 extern void drm_crtc_vblank_reset(struct drm_crtc *crtc);
 extern void drm_crtc_vblank_on(struct drm_crtc *crtc);

commit 34a67dd7f33f3476bc9978c3d353703d3821f6c2
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jul 15 21:48:01 2016 +0200

    drm: Extract&Document drm_irq.h
    
    The drm_irq docs want one function from drmP.h, but that one is a
    serious mess. Extract it, and while at it improve the docs a bit.
    There's a bit a header loop issue since core data structures like
    drm_device and drm_driver aren't in their own headers yet, which means
    the drm_irq.h include in drmP.h needs to be in just the right spot :(
    
    Also noticed that drm_vblank_crtc->last_wait is entirely unused,
    remove it.
    
    v2: git add drm_irq.h ...
    
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_irq.h b/include/drm/drm_irq.h
new file mode 100644
index 000000000000..2401b14d301f
--- /dev/null
+++ b/include/drm/drm_irq.h
@@ -0,0 +1,183 @@
+/*
+ * Copyright 2016 Intel Corp.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _DRM_IRQ_H_
+#define _DRM_IRQ_H_
+
+#include <linux/seqlock.h>
+
+/**
+ * struct drm_pending_vblank_event - pending vblank event tracking
+ */
+struct drm_pending_vblank_event {
+	/**
+	 * @base: Base structure for tracking pending DRM events.
+	 */
+	struct drm_pending_event base;
+	/**
+	 * @pipe: drm_crtc_index() of the &drm_crtc this event is for.
+	 */
+	unsigned int pipe;
+	/**
+	 * @event: Actual event which will be sent to userspace.
+	 */
+	struct drm_event_vblank event;
+};
+
+/**
+ * struct drm_vblank_crtc - vblank tracking for a CRTC
+ *
+ * This structure tracks the vblank state for one CRTC.
+ *
+ * Note that for historical reasons - the vblank handling code is still shared
+ * with legacy/non-kms drivers - this is a free-standing structure not directly
+ * connected to struct &drm_crtc. But all public interface functions are taking
+ * a struct &drm_crtc to hide this implementation detail.
+ */
+struct drm_vblank_crtc {
+	/**
+	 * @dev: Pointer to the &drm_device.
+	 */
+	struct drm_device *dev;
+	/**
+	 * @queue: Wait queue for vblank waiters.
+	 */
+	wait_queue_head_t queue;	/**< VBLANK wait queue */
+	/**
+	 * @disable_timer: Disable timer for the delayed vblank disabling
+	 * hysteresis logic. Vblank disabling is controlled through the
+	 * drm_vblank_offdelay module option and the setting of the
+	 * max_vblank_count value in the &drm_device structure.
+	 */
+	struct timer_list disable_timer;
+
+	/**
+	 * @seqlock: Protect vblank count and time.
+	 */
+	seqlock_t seqlock;		/* protects vblank count and time */
+
+	/**
+	 * @count: Current software vblank counter.
+	 */
+	u32 count;
+	/**
+	 * @time: Vblank timestamp corresponding to @count.
+	 */
+	struct timeval time;
+
+	/**
+	 * @refcount: Number of users/waiters of the vblank interrupt. Only when
+	 * this refcount reaches 0 can the hardware interrupt be disabled using
+	 * @disable_timer.
+	 */
+	atomic_t refcount;		/* number of users of vblank interruptsper crtc */
+	/**
+	 * @last: Protected by dev->vbl_lock, used for wraparound handling.
+	 */
+	u32 last;
+	/**
+	 * @inmodeset: Tracks whether the vblank is disabled due to a modeset.
+	 * For legacy driver bit 2 additionally tracks whether an additional
+	 * temporary vblank reference has been acquired to paper over the
+	 * hardware counter resetting/jumping. KMS drivers should instead just
+	 * call drm_crtc_vblank_off() and drm_crtc_vblank_on(), which explicitly
+	 * save and restore the vblank count.
+	 */
+	unsigned int inmodeset;		/* Display driver is setting mode */
+	/**
+	 * @pipe: drm_crtc_index() of the &drm_crtc corresponding to this
+	 * structure.
+	 */
+	unsigned int pipe;
+	/**
+	 * @framedur_ns: Frame/Field duration in ns, used by
+	 * drm_calc_vbltimestamp_from_scanoutpos() and computed by
+	 * drm_calc_timestamping_constants().
+	 */
+	int framedur_ns;
+	/**
+	 * @linedur_ns: Line duration in ns, used by
+	 * drm_calc_vbltimestamp_from_scanoutpos() and computed by
+	 * drm_calc_timestamping_constants().
+	 */
+	int linedur_ns;
+	/**
+	 * @enabled: Tracks the enabling state of the corresponding &drm_crtc to
+	 * avoid double-disabling and hence corrupting saved state. Needed by
+	 * drivers not using atomic KMS, since those might go through their CRTC
+	 * disabling functions multiple times.
+	 */
+	bool enabled;
+};
+
+extern int drm_irq_install(struct drm_device *dev, int irq);
+extern int drm_irq_uninstall(struct drm_device *dev);
+
+extern int drm_vblank_init(struct drm_device *dev, unsigned int num_crtcs);
+extern int drm_wait_vblank(struct drm_device *dev, void *data,
+			   struct drm_file *filp);
+extern u32 drm_vblank_count(struct drm_device *dev, unsigned int pipe);
+extern u32 drm_crtc_vblank_count(struct drm_crtc *crtc);
+extern u32 drm_crtc_vblank_count_and_time(struct drm_crtc *crtc,
+					  struct timeval *vblanktime);
+extern void drm_crtc_send_vblank_event(struct drm_crtc *crtc,
+				       struct drm_pending_vblank_event *e);
+extern void drm_crtc_arm_vblank_event(struct drm_crtc *crtc,
+				      struct drm_pending_vblank_event *e);
+extern bool drm_handle_vblank(struct drm_device *dev, unsigned int pipe);
+extern bool drm_crtc_handle_vblank(struct drm_crtc *crtc);
+extern int drm_crtc_vblank_get(struct drm_crtc *crtc);
+extern void drm_crtc_vblank_put(struct drm_crtc *crtc);
+extern void drm_wait_one_vblank(struct drm_device *dev, unsigned int pipe);
+extern void drm_crtc_wait_one_vblank(struct drm_crtc *crtc);
+extern void drm_vblank_off(struct drm_device *dev, unsigned int pipe);
+extern void drm_vblank_on(struct drm_device *dev, unsigned int pipe);
+extern void drm_crtc_vblank_off(struct drm_crtc *crtc);
+extern void drm_crtc_vblank_reset(struct drm_crtc *crtc);
+extern void drm_crtc_vblank_on(struct drm_crtc *crtc);
+extern void drm_vblank_cleanup(struct drm_device *dev);
+extern u32 drm_accurate_vblank_count(struct drm_crtc *crtc);
+extern u32 drm_vblank_no_hw_counter(struct drm_device *dev, unsigned int pipe);
+
+extern int drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev,
+						 unsigned int pipe, int *max_error,
+						 struct timeval *vblank_time,
+						 unsigned flags,
+						 const struct drm_display_mode *mode);
+extern void drm_calc_timestamping_constants(struct drm_crtc *crtc,
+					    const struct drm_display_mode *mode);
+
+/**
+ * drm_crtc_vblank_waitqueue - get vblank waitqueue for the CRTC
+ * @crtc: which CRTC's vblank waitqueue to retrieve
+ *
+ * This function returns a pointer to the vblank waitqueue for the CRTC.
+ * Drivers can use this to implement vblank waits using wait_event() and related
+ * functions.
+ */
+static inline wait_queue_head_t *drm_crtc_vblank_waitqueue(struct drm_crtc *crtc)
+{
+	return &crtc->dev->vblank[drm_crtc_index(crtc)].queue;
+}
+
+#endif
