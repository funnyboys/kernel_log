commit 4fb419b216245297312aeafcadf8b4e852a6cfe4
Author: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Date:   Mon Jul 8 15:53:07 2019 +0300

    drm: Add drm_modeset_lock_assert_held()
    
    Add a small wrapper around lockdep_assert_held() to make
    it a bit more conventinet to use with modeset locks.
    
    Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190708125325.16576-2-ville.syrjala@linux.intel.com
    Reviewed-by: Juha-Pekka Heikkila <juhapekka.heikkila@gmail.com>

diff --git a/include/drm/drm_modeset_lock.h b/include/drm/drm_modeset_lock.h
index 7b8841065b11..4fc9a43ac45a 100644
--- a/include/drm/drm_modeset_lock.h
+++ b/include/drm/drm_modeset_lock.h
@@ -114,6 +114,15 @@ static inline bool drm_modeset_is_locked(struct drm_modeset_lock *lock)
 	return ww_mutex_is_locked(&lock->mutex);
 }
 
+/**
+ * drm_modeset_lock_assert_held - equivalent to lockdep_assert_held()
+ * @lock: lock to check
+ */
+static inline void drm_modeset_lock_assert_held(struct drm_modeset_lock *lock)
+{
+	lockdep_assert_held(&lock->mutex.base);
+}
+
 int drm_modeset_lock(struct drm_modeset_lock *lock,
 		struct drm_modeset_acquire_ctx *ctx);
 int __must_check drm_modeset_lock_single_interruptible(struct drm_modeset_lock *lock);

commit 1e55a53a28d3e52a68e11917dd25a216c3e7c182
Author: Matt Roper <matthew.d.roper@intel.com>
Date:   Fri Feb 1 17:23:26 2019 -0800

    drm: Trivial comment grammar cleanups
    
    Most of these are just cases where code comments used contractions
    (it's, who's) where they actually mean to use a possessive pronoun (its,
    whose) or vice-versa.
    
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190202012326.20096-1-matthew.d.roper@intel.com

diff --git a/include/drm/drm_modeset_lock.h b/include/drm/drm_modeset_lock.h
index a308f2d6496f..7b8841065b11 100644
--- a/include/drm/drm_modeset_lock.h
+++ b/include/drm/drm_modeset_lock.h
@@ -68,7 +68,7 @@ struct drm_modeset_acquire_ctx {
 /**
  * struct drm_modeset_lock - used for locking modeset resources.
  * @mutex: resource locking
- * @head: used to hold it's place on &drm_atomi_state.locked list when
+ * @head: used to hold its place on &drm_atomi_state.locked list when
  *    part of an atomic update
  *
  * Used for locking CRTCs and other modeset resources.

commit b7ea04d299c78b6cf96ab281a1683ff62a74f969
Author: Sean Paul <seanpaul@chromium.org>
Date:   Thu Nov 29 10:04:17 2018 -0500

    drm: Add DRM_MODESET_LOCK_BEGIN/END helpers
    
    This patch adds a couple of helpers to remove the boilerplate involved
    in grabbing all of the modeset locks.
    
    I've also converted the obvious cases in drm core to use the helpers.
    
    The only remaining instance of drm_modeset_lock_all_ctx() is in
    drm_framebuffer. It's complicated by the state clear that occurs on
    deadlock. ATM, there's no way to inject code in the deadlock path with
    the helpers, so it's unfit for conversion.
    
    Changes in v2:
    - Relocate ret argument to the end of the list (Daniel)
    - Incorporate Daniel's doc suggestions (Daniel)
    
    Suggested-by: Daniel Vetter <daniel@ffwll.ch>
    Reviewed-by: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181129150423.239081-4-sean@poorly.run

diff --git a/include/drm/drm_modeset_lock.h b/include/drm/drm_modeset_lock.h
index a685d1bb21f2..a308f2d6496f 100644
--- a/include/drm/drm_modeset_lock.h
+++ b/include/drm/drm_modeset_lock.h
@@ -130,4 +130,63 @@ void drm_warn_on_modeset_not_all_locked(struct drm_device *dev);
 int drm_modeset_lock_all_ctx(struct drm_device *dev,
 			     struct drm_modeset_acquire_ctx *ctx);
 
+/**
+ * DRM_MODESET_LOCK_ALL_BEGIN - Helper to acquire modeset locks
+ * @dev: drm device
+ * @ctx: local modeset acquire context, will be dereferenced
+ * @flags: DRM_MODESET_ACQUIRE_* flags to pass to drm_modeset_acquire_init()
+ * @ret: local ret/err/etc variable to track error status
+ *
+ * Use these macros to simplify grabbing all modeset locks using a local
+ * context. This has the advantage of reducing boilerplate, but also properly
+ * checking return values where appropriate.
+ *
+ * Any code run between BEGIN and END will be holding the modeset locks.
+ *
+ * This must be paired with DRM_MODESET_LOCK_ALL_END(). We will jump back and
+ * forth between the labels on deadlock and error conditions.
+ *
+ * Drivers can acquire additional modeset locks. If any lock acquisition
+ * fails, the control flow needs to jump to DRM_MODESET_LOCK_ALL_END() with
+ * the @ret parameter containing the return value of drm_modeset_lock().
+ *
+ * Returns:
+ * The only possible value of ret immediately after DRM_MODESET_LOCK_ALL_BEGIN()
+ * is 0, so no error checking is necessary
+ */
+#define DRM_MODESET_LOCK_ALL_BEGIN(dev, ctx, flags, ret)		\
+	drm_modeset_acquire_init(&ctx, flags);				\
+modeset_lock_retry:							\
+	ret = drm_modeset_lock_all_ctx(dev, &ctx);			\
+	if (ret)							\
+		goto modeset_lock_fail;
+
+/**
+ * DRM_MODESET_LOCK_ALL_END - Helper to release and cleanup modeset locks
+ * @ctx: local modeset acquire context, will be dereferenced
+ * @ret: local ret/err/etc variable to track error status
+ *
+ * The other side of DRM_MODESET_LOCK_ALL_BEGIN(). It will bounce back to BEGIN
+ * if ret is -EDEADLK.
+ *
+ * It's important that you use the same ret variable for begin and end so
+ * deadlock conditions are properly handled.
+ *
+ * Returns:
+ * ret will be untouched unless it is -EDEADLK on entry. That means that if you
+ * successfully acquire the locks, ret will be whatever your code sets it to. If
+ * there is a deadlock or other failure with acquire or backoff, ret will be set
+ * to that failure. In both of these cases the code between BEGIN/END will not
+ * be run, so the failure will reflect the inability to grab the locks.
+ */
+#define DRM_MODESET_LOCK_ALL_END(ctx, ret)				\
+modeset_lock_fail:							\
+	if (ret == -EDEADLK) {						\
+		ret = drm_modeset_backoff(&ctx);			\
+		if (!ret)						\
+			goto modeset_lock_retry;			\
+	}								\
+	drm_modeset_drop_locks(&ctx);					\
+	drm_modeset_acquire_fini(&ctx);
+
 #endif /* DRM_MODESET_LOCK_H_ */

commit 6f8bcc744aad50d719845e4ce06a7831e96e1109
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Tue Sep 12 15:37:44 2017 +0200

    drm/atomic: Prepare drm_modeset_lock infrastructure for interruptible waiting, v2.
    
    When we want to make drm_atomic_commit interruptible, there are a lot of
    places that call the lock function, which we don't have control over.
    
    Rather than trying to convert every single one, it's easier to toggle
    interruptible waiting per acquire_ctx. If drm_modeset_acquire_init is
    called with DRM_MODESET_ACQUIRE_INTERRUPTIBLE, then we will perform
    interruptible waits in drm_modeset_lock and drm_modeset_backoff.
    
    Changes since v1:
    - Fix locking example in drm_modeset_lock.c to be compatible
      with interruptible waiting (xexaxo) and make it default.
      Uninterruptible waiting shouldn't happen except in corner cases,
      but the example will still apply if the flag is removed.
    - Add drm_modeset_lock_single_interruptible() to documentation.
    - Fix dead link to removed drm_modeset_lock_interruptible() in
      drm_modeset_lock().
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch> #v1
    Cc: Emil Velikov <emil.l.velikov@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170912133749.6532-2-maarten.lankhorst@linux.intel.com
    Reviewed-by: Emil Velikov <emil.l.velikov@gmail.com>

diff --git a/include/drm/drm_modeset_lock.h b/include/drm/drm_modeset_lock.h
index 4b27c2bb955c..a685d1bb21f2 100644
--- a/include/drm/drm_modeset_lock.h
+++ b/include/drm/drm_modeset_lock.h
@@ -34,6 +34,7 @@ struct drm_modeset_lock;
  * @contended: used internally for -EDEADLK handling
  * @locked: list of held locks
  * @trylock_only: trylock mode used in atomic contexts/panic notifiers
+ * @interruptible: whether interruptible locking should be used.
  *
  * Each thread competing for a set of locks must use one acquire
  * ctx.  And if any lock fxn returns -EDEADLK, it must backoff and
@@ -59,6 +60,9 @@ struct drm_modeset_acquire_ctx {
 	 * Trylock mode, use only for panic handlers!
 	 */
 	bool trylock_only;
+
+	/* Perform interruptible waits on this context. */
+	bool interruptible;
 };
 
 /**
@@ -82,12 +86,13 @@ struct drm_modeset_lock {
 	struct list_head head;
 };
 
+#define DRM_MODESET_ACQUIRE_INTERRUPTIBLE BIT(0)
+
 void drm_modeset_acquire_init(struct drm_modeset_acquire_ctx *ctx,
 		uint32_t flags);
 void drm_modeset_acquire_fini(struct drm_modeset_acquire_ctx *ctx);
 void drm_modeset_drop_locks(struct drm_modeset_acquire_ctx *ctx);
-void drm_modeset_backoff(struct drm_modeset_acquire_ctx *ctx);
-int drm_modeset_backoff_interruptible(struct drm_modeset_acquire_ctx *ctx);
+int drm_modeset_backoff(struct drm_modeset_acquire_ctx *ctx);
 
 void drm_modeset_lock_init(struct drm_modeset_lock *lock);
 
@@ -111,8 +116,7 @@ static inline bool drm_modeset_is_locked(struct drm_modeset_lock *lock)
 
 int drm_modeset_lock(struct drm_modeset_lock *lock,
 		struct drm_modeset_acquire_ctx *ctx);
-int drm_modeset_lock_interruptible(struct drm_modeset_lock *lock,
-		struct drm_modeset_acquire_ctx *ctx);
+int __must_check drm_modeset_lock_single_interruptible(struct drm_modeset_lock *lock);
 void drm_modeset_unlock(struct drm_modeset_lock *lock);
 
 struct drm_device;

commit b260ac3ebef5eb748207cd542dba00af6c5caaa5
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Apr 3 10:32:52 2017 +0200

    drm: Remove drm_modeset_legacy_acquire_ctx and crtc->acquire_ctx
    
    With all the callers of drm_modeset_lock_crtc gone, and all the places
    it was formerly used properly wiring the acquire ctx through, we can
    remove this.
    
    The only hidden context magic we still have is now the global one.
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170403083304.9083-4-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_modeset_lock.h b/include/drm/drm_modeset_lock.h
index 2bb065bf0593..4b27c2bb955c 100644
--- a/include/drm/drm_modeset_lock.h
+++ b/include/drm/drm_modeset_lock.h
@@ -122,8 +122,6 @@ struct drm_plane;
 void drm_modeset_lock_all(struct drm_device *dev);
 void drm_modeset_unlock_all(struct drm_device *dev);
 void drm_warn_on_modeset_not_all_locked(struct drm_device *dev);
-struct drm_modeset_acquire_ctx *
-drm_modeset_legacy_acquire_ctx(struct drm_crtc *crtc);
 
 int drm_modeset_lock_all_ctx(struct drm_device *dev,
 			     struct drm_modeset_acquire_ctx *ctx);

commit b95ff0319a829d5e707d64a3994c75f012f6b6ec
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Apr 3 10:32:51 2017 +0200

    drm: Remove drm_modeset_(un)lock_crtc
    
    The last user, the cursor ioctl, can just open-code this too. We
    simply have to move the acquire ctx dance from the universal function
    up into the top-level ioctl handler.
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170403083304.9083-3-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_modeset_lock.h b/include/drm/drm_modeset_lock.h
index 88d35bfc9cd8..2bb065bf0593 100644
--- a/include/drm/drm_modeset_lock.h
+++ b/include/drm/drm_modeset_lock.h
@@ -121,7 +121,6 @@ struct drm_plane;
 
 void drm_modeset_lock_all(struct drm_device *dev);
 void drm_modeset_unlock_all(struct drm_device *dev);
-void drm_modeset_unlock_crtc(struct drm_crtc *crtc);
 void drm_warn_on_modeset_not_all_locked(struct drm_device *dev);
 struct drm_modeset_acquire_ctx *
 drm_modeset_legacy_acquire_ctx(struct drm_crtc *crtc);

commit 5f27502655f657989dac0622ecf70b9e173e90f8
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Apr 3 10:32:50 2017 +0200

    drm: Make drm_modeset_lock_crtc internal
    
    This is only for legacy paths that need to grab the crtc/plane lock
    combo. If you want to lock a crtc, just use drm_modeset_lock().
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170403083304.9083-2-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_modeset_lock.h b/include/drm/drm_modeset_lock.h
index 96d39fbd12ca..88d35bfc9cd8 100644
--- a/include/drm/drm_modeset_lock.h
+++ b/include/drm/drm_modeset_lock.h
@@ -121,8 +121,6 @@ struct drm_plane;
 
 void drm_modeset_lock_all(struct drm_device *dev);
 void drm_modeset_unlock_all(struct drm_device *dev);
-void drm_modeset_lock_crtc(struct drm_crtc *crtc,
-			   struct drm_plane *plane);
 void drm_modeset_unlock_crtc(struct drm_crtc *crtc);
 void drm_warn_on_modeset_not_all_locked(struct drm_device *dev);
 struct drm_modeset_acquire_ctx *

commit d574528a64c3a3b2a9c6a125e2428b38bddbdf3c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jan 25 07:26:45 2017 +0100

    drm/kms-core: Use recommened kerneldoc for struct member refs
    
    I just learned that &struct_name.member_name works and looks pretty
    even. It doesn't (yet) link to the member directly though, which would
    be really good for big structures or vfunc tables (where the
    per-member kerneldoc tends to be long).
    
    Also some minor drive-by polish where it makes sense, I read a lot
    of docs ...
    
    v2: Review from Eric.
    
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Eric Engestrom <eric.engestrom@imgtec.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170125062657.19270-4-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_modeset_lock.h b/include/drm/drm_modeset_lock.h
index d918ce45ec2c..96d39fbd12ca 100644
--- a/include/drm/drm_modeset_lock.h
+++ b/include/drm/drm_modeset_lock.h
@@ -64,7 +64,7 @@ struct drm_modeset_acquire_ctx {
 /**
  * struct drm_modeset_lock - used for locking modeset resources.
  * @mutex: resource locking
- * @head: used to hold it's place on state->locked list when
+ * @head: used to hold it's place on &drm_atomi_state.locked list when
  *    part of an atomic update
  *
  * Used for locking CRTCs and other modeset resources.

commit 35cf03508d8466ecc5199c9d609e74e85bec785b
Author: Rob Clark <robdclark@gmail.com>
Date:   Mon Nov 14 17:40:57 2016 -0500

    drm: don't let crtc_ww_class leak out
    
    kbuild spotted this error, with drm/msm patches that add a new
    modeset-lock in the driver and driver built as a module:
    
      ERROR: "crtc_ww_class" [drivers/gpu/drm/msm/msm.ko] undefined!
    
    Really the only reason for crtc_ww_class not being internal to
    drm_modeset_lock.c is that drm_modeset_lock_init() was static-inline
    (for no particularly good reason).
    
    Fix that, and move crtc_ww_class into drm_modeset_lock.c.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1479163257-18703-1-git-send-email-robdclark@gmail.com

diff --git a/include/drm/drm_modeset_lock.h b/include/drm/drm_modeset_lock.h
index c5576fbcb909..d918ce45ec2c 100644
--- a/include/drm/drm_modeset_lock.h
+++ b/include/drm/drm_modeset_lock.h
@@ -82,8 +82,6 @@ struct drm_modeset_lock {
 	struct list_head head;
 };
 
-extern struct ww_class crtc_ww_class;
-
 void drm_modeset_acquire_init(struct drm_modeset_acquire_ctx *ctx,
 		uint32_t flags);
 void drm_modeset_acquire_fini(struct drm_modeset_acquire_ctx *ctx);
@@ -91,15 +89,7 @@ void drm_modeset_drop_locks(struct drm_modeset_acquire_ctx *ctx);
 void drm_modeset_backoff(struct drm_modeset_acquire_ctx *ctx);
 int drm_modeset_backoff_interruptible(struct drm_modeset_acquire_ctx *ctx);
 
-/**
- * drm_modeset_lock_init - initialize lock
- * @lock: lock to init
- */
-static inline void drm_modeset_lock_init(struct drm_modeset_lock *lock)
-{
-	ww_mutex_init(&lock->mutex, &crtc_ww_class);
-	INIT_LIST_HEAD(&lock->head);
-}
+void drm_modeset_lock_init(struct drm_modeset_lock *lock);
 
 /**
  * drm_modeset_lock_fini - cleanup lock

commit 06eaae46381737a6236ad6fe81e5358fad3bbbe5
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Dec 2 17:50:03 2015 +0100

    drm: Implement drm_modeset_lock_all_ctx()
    
    This function is like drm_modeset_lock_all(), but it takes the lock
    acquisition context as a parameter rather than storing it in the DRM
    device's mode_config structure.
    
    Implement drm_modeset_{,un}lock_all() in terms of the new function for
    better code reuse, and add a note to the kerneldoc that new code should
    use the new functions.
    
    v2: improve kerneldoc
    v4: rename drm_modeset_lock_all_crtcs() to drm_modeset_lock_all_ctx()
        and take mode_config's .connection_mutex instead of .mutex lock to
        avoid lock inversion (Daniel Vetter), use drm_modeset_drop_locks()
        which is now the equivalent of drm_modeset_unlock_all_ctx()
    v5: do not take the dev->mode_config.connection_mutex in
        drm_atomic_legacy_backoff() since drm_modeset_lock_all_ctx()
        already keeps it, enhance kerneldoc for drm_modeset_lock_all_ctx()
        (Daniel Vetter)
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449075005-13937-1-git-send-email-thierry.reding@gmail.com
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_modeset_lock.h b/include/drm/drm_modeset_lock.h
index 94938d89347c..c5576fbcb909 100644
--- a/include/drm/drm_modeset_lock.h
+++ b/include/drm/drm_modeset_lock.h
@@ -138,7 +138,7 @@ void drm_warn_on_modeset_not_all_locked(struct drm_device *dev);
 struct drm_modeset_acquire_ctx *
 drm_modeset_legacy_acquire_ctx(struct drm_crtc *crtc);
 
-int drm_modeset_lock_all_crtcs(struct drm_device *dev,
-		struct drm_modeset_acquire_ctx *ctx);
+int drm_modeset_lock_all_ctx(struct drm_device *dev,
+			     struct drm_modeset_acquire_ctx *ctx);
 
 #endif /* DRM_MODESET_LOCK_H_ */

commit fe8660acd8853ad9f95b94a04cce384949ddecfe
Author: Danilo Cesar Lemes de Paula <danilo.cesar@collabora.co.uk>
Date:   Fri Aug 21 16:46:14 2015 -0300

    drm/doc: Fixing xml documentation warning
    
    "/**" should be used for kernel-doc documentation only.
    It causes a warning with the new "in struct body" format.
    
    Signed-off-by: Danilo Cesar Lemes de Paula <danilo.cesar@collabora.co.uk>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Stephan Mueller <smueller@chronox.de>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-doc@vger.kernel.org
    Cc: intel-gfx <intel-gfx@lists.freedesktop.org>
    Cc: dri-devel <dri-devel@lists.freedesktop.org>
    Cc: Graham Whaley <graham.whaley@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_modeset_lock.h b/include/drm/drm_modeset_lock.h
index 5dd18bfdf601..94938d89347c 100644
--- a/include/drm/drm_modeset_lock.h
+++ b/include/drm/drm_modeset_lock.h
@@ -43,19 +43,19 @@ struct drm_modeset_acquire_ctx {
 
 	struct ww_acquire_ctx ww_ctx;
 
-	/**
+	/*
 	 * Contended lock: if a lock is contended you should only call
 	 * drm_modeset_backoff() which drops locks and slow-locks the
 	 * contended lock.
 	 */
 	struct drm_modeset_lock *contended;
 
-	/**
+	/*
 	 * list of held locks (drm_modeset_lock)
 	 */
 	struct list_head locked;
 
-	/**
+	/*
 	 * Trylock mode, use only for panic handlers!
 	 */
 	bool trylock_only;
@@ -70,12 +70,12 @@ struct drm_modeset_acquire_ctx {
  * Used for locking CRTCs and other modeset resources.
  */
 struct drm_modeset_lock {
-	/**
+	/*
 	 * modeset lock
 	 */
 	struct ww_mutex mutex;
 
-	/**
+	/*
 	 * Resources that are locked as part of an atomic update are added
 	 * to a list (so we know what to unlock at the end).
 	 */

commit bf9e37baac6db7318862447973bd68b5acae4bef
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jul 28 13:18:42 2015 +0200

    drm: Remove __drm_modeset_lock_all
    
    The last user is gone, no need for trylocking any more in this legacy
    helper.
    
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_modeset_lock.h b/include/drm/drm_modeset_lock.h
index 70595ff565ba..5dd18bfdf601 100644
--- a/include/drm/drm_modeset_lock.h
+++ b/include/drm/drm_modeset_lock.h
@@ -130,7 +130,6 @@ struct drm_crtc;
 struct drm_plane;
 
 void drm_modeset_lock_all(struct drm_device *dev);
-int __drm_modeset_lock_all(struct drm_device *dev, bool trylock);
 void drm_modeset_unlock_all(struct drm_device *dev);
 void drm_modeset_lock_crtc(struct drm_crtc *crtc,
 			   struct drm_plane *plane);

commit 4d02e2de0e80a786452e70d7f3a20a50641e6620
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Nov 11 10:12:00 2014 +0100

    drm: Per-plane locking
    
    Turned out to be much simpler on top of my latest atomic stuff than
    what I've feared. Some details:
    
    - Drop the modeset_lock_all snakeoil in drm_plane_init. Same
      justification as for the equivalent change in drm_crtc_init done in
    
            commit d0fa1af40e784aaf7ebb7ba8a17b229bb3fa4c21
            Author: Daniel Vetter <daniel.vetter@ffwll.ch>
            Date:   Mon Sep 8 09:02:49 2014 +0200
    
                drm: Drop modeset locking from crtc init function
    
      Without these the drm_modeset_lock_init would fall over the exact
      same way.
    
    - Since the atomic core code wraps the locking switching it to
      per-plane locks was a one-line change.
    
    - For the legacy ioctls add a plane argument to the locking helper so
      that we can grab the right plane lock (cursor or primary). Since the
      universal cursor plane might not be there, or someone really crazy
      might forgoe the primary plane even accept NULL.
    
    - Add some locking WARN_ON to the atomic helpers for good paranoid
      measure and to check that it all works out.
    
    Tested on my exynos atomic hackfest with full lockdep checks and ww
    backoff injection.
    
    v2: I've forgotten about the load-detect code in i915.
    
    v3: Thierry reported that in latest 3.18-rc vmwgfx doesn't compile any
    more due to
    
    commit 21e88620aa21b48d4f62d29275e3e2944a5ea2b5
    Author: Rob Clark <robdclark@gmail.com>
    Date:   Thu Oct 30 13:39:04 2014 -0400
    
        drm/vmwgfx: fix lock breakage
    
    Rebased and fix this up.
    
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_modeset_lock.h b/include/drm/drm_modeset_lock.h
index 28931a23d96c..70595ff565ba 100644
--- a/include/drm/drm_modeset_lock.h
+++ b/include/drm/drm_modeset_lock.h
@@ -127,11 +127,13 @@ void drm_modeset_unlock(struct drm_modeset_lock *lock);
 
 struct drm_device;
 struct drm_crtc;
+struct drm_plane;
 
 void drm_modeset_lock_all(struct drm_device *dev);
 int __drm_modeset_lock_all(struct drm_device *dev, bool trylock);
 void drm_modeset_unlock_all(struct drm_device *dev);
-void drm_modeset_lock_crtc(struct drm_crtc *crtc);
+void drm_modeset_lock_crtc(struct drm_crtc *crtc,
+			   struct drm_plane *plane);
 void drm_modeset_unlock_crtc(struct drm_crtc *crtc);
 void drm_warn_on_modeset_not_all_locked(struct drm_device *dev);
 struct drm_modeset_acquire_ctx *

commit b7a1aafda61c27d54230ce7c8a4806a749ecf2f3
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Oct 27 20:37:37 2014 +0100

    drm/modeset_lock: document trylock_only in kerneldoc
    
    I've forgotten to do this in:
    
    commit cb597bb3a2fbfc871cc1c703fb330d247bd21394
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Sun Jul 27 19:09:33 2014 +0200
    
        drm: trylock modest locking for fbdev panics
    
    Oops, fix this asap.
    
    In my defense kerneldoc is really awful and there's no way it can pick
    up structured comments per struct member. Which means we need both
    since people won't scroll up even a few lines.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/drm/drm_modeset_lock.h b/include/drm/drm_modeset_lock.h
index 75a5c45e21c7..28931a23d96c 100644
--- a/include/drm/drm_modeset_lock.h
+++ b/include/drm/drm_modeset_lock.h
@@ -33,6 +33,7 @@ struct drm_modeset_lock;
  * @ww_ctx: base acquire ctx
  * @contended: used internally for -EDEADLK handling
  * @locked: list of held locks
+ * @trylock_only: trylock mode used in atomic contexts/panic notifiers
  *
  * Each thread competing for a set of locks must use one acquire
  * ctx.  And if any lock fxn returns -EDEADLK, it must backoff and

commit f3a808817fdb48a9fa3e4ed40e7f8a8dec50014c
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Sat Aug 16 14:15:34 2014 -0700

    drm: fix drm_modeset_lock.h kernel-doc notation
    
    Fix drm kernel-doc notation to squelch these warnings:
    
    Warning(..//include/drm/drm_modeset_lock.h:41): cannot understand function prototype: 'struct drm_modeset_acquire_ctx '
    Warning(..//include/drm/drm_modeset_lock.h:66): cannot understand function prototype: 'struct drm_modeset_lock '
    
    Need to include the keyword 'struct' for structure descriptions.
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_modeset_lock.h b/include/drm/drm_modeset_lock.h
index a3f736d24382..75a5c45e21c7 100644
--- a/include/drm/drm_modeset_lock.h
+++ b/include/drm/drm_modeset_lock.h
@@ -29,7 +29,7 @@
 struct drm_modeset_lock;
 
 /**
- * drm_modeset_acquire_ctx - locking context (see ww_acquire_ctx)
+ * struct drm_modeset_acquire_ctx - locking context (see ww_acquire_ctx)
  * @ww_ctx: base acquire ctx
  * @contended: used internally for -EDEADLK handling
  * @locked: list of held locks
@@ -61,7 +61,7 @@ struct drm_modeset_acquire_ctx {
 };
 
 /**
- * drm_modeset_lock - used for locking modeset resources.
+ * struct drm_modeset_lock - used for locking modeset resources.
  * @mutex: resource locking
  * @head: used to hold it's place on state->locked list when
  *    part of an atomic update

commit cb597bb3a2fbfc871cc1c703fb330d247bd21394
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sun Jul 27 19:09:33 2014 +0200

    drm: trylock modest locking for fbdev panics
    
    In the fbdev code we want to do trylocks only to avoid deadlocks and
    other ugly issues. Thus far we've only grabbed the overall modeset
    lock, but that already failed to exclude a pile of potential
    concurrent operations. With proper atomic support this will be worse.
    
    So add a trylock mode to the modeset locking code which attempts all
    locks only with trylocks, if possible. We need to track this in the
    locking functions themselves and can't restrict this to drivers since
    driver-private w/w mutexes must be treated the same way.
    
    There's still the issue that other driver private locks aren't handled
    here at all, but well can't have everything. With this we will at
    least not regress, even once atomic allows lots of concurrent kms
    activity.
    
    Aside: We should move the acquire context to stack-based allocation in
    the callers to get rid of that awful WARN_ON(kmalloc_failed) control
    flow which just blows up when memory is short. But that's material for
    separate patches.
    
    v2:
    - Fix logic inversion fumble in the fb helper.
    - Add proper kerneldoc.
    
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_modeset_lock.h b/include/drm/drm_modeset_lock.h
index d38e1508f11a..a3f736d24382 100644
--- a/include/drm/drm_modeset_lock.h
+++ b/include/drm/drm_modeset_lock.h
@@ -53,6 +53,11 @@ struct drm_modeset_acquire_ctx {
 	 * list of held locks (drm_modeset_lock)
 	 */
 	struct list_head locked;
+
+	/**
+	 * Trylock mode, use only for panic handlers!
+	 */
+	bool trylock_only;
 };
 
 /**
@@ -123,6 +128,7 @@ struct drm_device;
 struct drm_crtc;
 
 void drm_modeset_lock_all(struct drm_device *dev);
+int __drm_modeset_lock_all(struct drm_device *dev, bool trylock);
 void drm_modeset_unlock_all(struct drm_device *dev);
 void drm_modeset_lock_crtc(struct drm_crtc *crtc);
 void drm_modeset_unlock_crtc(struct drm_crtc *crtc);

commit d059f652e73c35678d28d4cd09ab2cec89696af9
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jul 25 18:07:40 2014 +0200

    drm: Handle legacy per-crtc locking with full acquire ctx
    
    So drivers using the atomic interfaces expect that they can acquire
    additional locks internal to the driver as-needed. Examples would be
    locks to protect shared state like shared display PLLs.
    
    Unfortunately the legacy ioctls assume that all locking is fully done
    by the drm core. Now for those paths which grab all locks we already
    have to keep around an acquire context in dev->mode_config. Helper
    functions that implement legacy interfaces in terms of atomic support
    can therefore grab this acquire contexts and reuse it.
    
    The only interfaces left are the cursor and pageflip ioctls. So add
    functions to grab the crtc lock these need using an acquire context
    and preserve it for atomic drivers to reuse.
    
    v2:
    - Fixup comments&kerneldoc.
    - Drop the WARNING from modeset_lock_all_crtcs since that can be used
      in legacy paths with crtc locking.
    
    v3: Fix a type on the kerneldoc Dave spotted.
    
    Cc: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_modeset_lock.h b/include/drm/drm_modeset_lock.h
index cf61e857bc06..d38e1508f11a 100644
--- a/include/drm/drm_modeset_lock.h
+++ b/include/drm/drm_modeset_lock.h
@@ -120,10 +120,15 @@ int drm_modeset_lock_interruptible(struct drm_modeset_lock *lock,
 void drm_modeset_unlock(struct drm_modeset_lock *lock);
 
 struct drm_device;
+struct drm_crtc;
 
 void drm_modeset_lock_all(struct drm_device *dev);
 void drm_modeset_unlock_all(struct drm_device *dev);
+void drm_modeset_lock_crtc(struct drm_crtc *crtc);
+void drm_modeset_unlock_crtc(struct drm_crtc *crtc);
 void drm_warn_on_modeset_not_all_locked(struct drm_device *dev);
+struct drm_modeset_acquire_ctx *
+drm_modeset_legacy_acquire_ctx(struct drm_crtc *crtc);
 
 int drm_modeset_lock_all_crtcs(struct drm_device *dev,
 		struct drm_modeset_acquire_ctx *ctx);

commit a6a8bb848d5ca40bc0eb708ddeb23df2b0eca1fb
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jul 25 17:47:18 2014 +0200

    drm: Move modeset_lock_all helpers to drm_modeset_lock.[hc]
    
    Somehow we've forgotten about this little bit of OCD.
    
    Reviewed-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_modeset_lock.h b/include/drm/drm_modeset_lock.h
index 402aa7a6a058..cf61e857bc06 100644
--- a/include/drm/drm_modeset_lock.h
+++ b/include/drm/drm_modeset_lock.h
@@ -120,6 +120,11 @@ int drm_modeset_lock_interruptible(struct drm_modeset_lock *lock,
 void drm_modeset_unlock(struct drm_modeset_lock *lock);
 
 struct drm_device;
+
+void drm_modeset_lock_all(struct drm_device *dev);
+void drm_modeset_unlock_all(struct drm_device *dev);
+void drm_warn_on_modeset_not_all_locked(struct drm_device *dev);
+
 int drm_modeset_lock_all_crtcs(struct drm_device *dev,
 		struct drm_modeset_acquire_ctx *ctx);
 

commit 51fd371bbaf94018a1223b4e2cf20b9880fd92d4
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Nov 19 12:10:12 2013 -0500

    drm: convert crtc and connection_mutex to ww_mutex (v5)
    
    For atomic, it will be quite necessary to not need to care so much
    about locking order.  And 'state' gives us a convenient place to stash a
    ww_ctx for any sort of update that needs to grab multiple crtc locks.
    
    Because we will want to eventually make locking even more fine grained
    (giving locks to planes, connectors, etc), split out drm_modeset_lock
    and drm_modeset_acquire_ctx to track acquired locks.
    
    Atomic will use this to keep track of which locks have been acquired
    in a transaction.
    
    v1: original
    v2: remove a few things not needed until atomic, for now
    v3: update for v3 of connection_mutex patch..
    v4: squash in docbook
    v5: doc tweaks/fixes
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_modeset_lock.h b/include/drm/drm_modeset_lock.h
new file mode 100644
index 000000000000..402aa7a6a058
--- /dev/null
+++ b/include/drm/drm_modeset_lock.h
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2014 Red Hat
+ * Author: Rob Clark <robdclark@gmail.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef DRM_MODESET_LOCK_H_
+#define DRM_MODESET_LOCK_H_
+
+#include <linux/ww_mutex.h>
+
+struct drm_modeset_lock;
+
+/**
+ * drm_modeset_acquire_ctx - locking context (see ww_acquire_ctx)
+ * @ww_ctx: base acquire ctx
+ * @contended: used internally for -EDEADLK handling
+ * @locked: list of held locks
+ *
+ * Each thread competing for a set of locks must use one acquire
+ * ctx.  And if any lock fxn returns -EDEADLK, it must backoff and
+ * retry.
+ */
+struct drm_modeset_acquire_ctx {
+
+	struct ww_acquire_ctx ww_ctx;
+
+	/**
+	 * Contended lock: if a lock is contended you should only call
+	 * drm_modeset_backoff() which drops locks and slow-locks the
+	 * contended lock.
+	 */
+	struct drm_modeset_lock *contended;
+
+	/**
+	 * list of held locks (drm_modeset_lock)
+	 */
+	struct list_head locked;
+};
+
+/**
+ * drm_modeset_lock - used for locking modeset resources.
+ * @mutex: resource locking
+ * @head: used to hold it's place on state->locked list when
+ *    part of an atomic update
+ *
+ * Used for locking CRTCs and other modeset resources.
+ */
+struct drm_modeset_lock {
+	/**
+	 * modeset lock
+	 */
+	struct ww_mutex mutex;
+
+	/**
+	 * Resources that are locked as part of an atomic update are added
+	 * to a list (so we know what to unlock at the end).
+	 */
+	struct list_head head;
+};
+
+extern struct ww_class crtc_ww_class;
+
+void drm_modeset_acquire_init(struct drm_modeset_acquire_ctx *ctx,
+		uint32_t flags);
+void drm_modeset_acquire_fini(struct drm_modeset_acquire_ctx *ctx);
+void drm_modeset_drop_locks(struct drm_modeset_acquire_ctx *ctx);
+void drm_modeset_backoff(struct drm_modeset_acquire_ctx *ctx);
+int drm_modeset_backoff_interruptible(struct drm_modeset_acquire_ctx *ctx);
+
+/**
+ * drm_modeset_lock_init - initialize lock
+ * @lock: lock to init
+ */
+static inline void drm_modeset_lock_init(struct drm_modeset_lock *lock)
+{
+	ww_mutex_init(&lock->mutex, &crtc_ww_class);
+	INIT_LIST_HEAD(&lock->head);
+}
+
+/**
+ * drm_modeset_lock_fini - cleanup lock
+ * @lock: lock to cleanup
+ */
+static inline void drm_modeset_lock_fini(struct drm_modeset_lock *lock)
+{
+	WARN_ON(!list_empty(&lock->head));
+}
+
+/**
+ * drm_modeset_is_locked - equivalent to mutex_is_locked()
+ * @lock: lock to check
+ */
+static inline bool drm_modeset_is_locked(struct drm_modeset_lock *lock)
+{
+	return ww_mutex_is_locked(&lock->mutex);
+}
+
+int drm_modeset_lock(struct drm_modeset_lock *lock,
+		struct drm_modeset_acquire_ctx *ctx);
+int drm_modeset_lock_interruptible(struct drm_modeset_lock *lock,
+		struct drm_modeset_acquire_ctx *ctx);
+void drm_modeset_unlock(struct drm_modeset_lock *lock);
+
+struct drm_device;
+int drm_modeset_lock_all_crtcs(struct drm_device *dev,
+		struct drm_modeset_acquire_ctx *ctx);
+
+#endif /* DRM_MODESET_LOCK_H_ */
