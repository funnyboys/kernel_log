commit 9e1ed9fb1eb0a4bc43a26365c592d3095286038b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Mar 23 15:49:50 2020 +0100

    drm: Add docs for managed resources
    
    All collected together to provide a consistent story in one patch,
    instead of the somewhat bumpy refactor-evolution leading to this.
    
    Also some thoughts on what the next steps could be:
    
    - Create a macro called devm_drm_dev_alloc() which essentially wraps
      the kzalloc(); devm_drm_dev_init(); drmm_add_final_kfree() combo.
      Needs to be a macro since we'll have to do some typeof trickery and
      casting to make this fully generic for all drivers that embed struct
      drm_device into their own thing.
    
    - A lot of the simple drivers now have essentially just
      drm_dev_unplug(); drm_atomic_helper_shutdown(); as their
      $bus_driver->remove hook. We could create a devm_mode_config_reset
      which sets drm_atomic_helper_shutdown as it's cleanup action, and a
      devm_drm_dev_register with drm_dev_unplug as it's cleanup action,
      and simple drivers wouldn't have a need for a ->remove function at
      all, and we could delete them.
    
    - For more complicated drivers we need drmm_ versions of a _lot_ more
      things. All the userspace visible objects (crtc, plane, encoder,
      crtc), anything else hanging of those (maybe a drmm_get_edid, at
      least for panels and other built-in stuff).
    
    Also some more thoughts on why we're not reusing devm_ with maybe a
    fake struct device embedded into the drm_device (we can't use the
    kdev, since that's in each drm_minor).
    
    - Code review gets extremely tricky, since every time you see a devm_
      you need to carefully check whether the fake device (with the
      drm_device lifetim) or the real device (with the lifetim of the
      underlying physical device and driver binding) are used. That's not
      going to help at all, and we have enormous amounts of drivers who
      use devm_ where they really shouldn't. Having different types makes
      sure the compiler type checks this for us and ensures correctness.
    
    - The set of functions are very much non-overlapping. E.g.
      devm_ioremap makes total sense, drmm_ioremap has the wrong lifetime,
      since hw resources need to be cleaned out at driver unbind and wont
      outlive that like a drm_device. Similar, but other way round for
      drmm_connector_init (which is the only correct version, devm_ for
      drm_connector is just buggy). Simply not having the wrong version
      again prevents bugs.
    
    Finally I guess this opens a huge todo for all the drivers. I'm
    semi-tempted to do a tree-wide s/devm_kzalloc/drmm_kzalloc/ since most
    likely that'll fix an enormous amount of bugs and most likely not
    cause any issues at all (aside from maybe holding onto memory slightly
    too long).
    
    v2:
    - Doc improvements from Laurent.
    - Also add kerneldoc for the new drmm_add_action_or_reset.
    
    v3:
    - Remove kerneldoc for drmm_remove_action.
    
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: linux-doc@vger.kernel.org
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    
    fixup docs
    Link: https://patchwork.freedesktop.org/patch/msgid/20200323144950.3018436-52-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_managed.h b/include/drm/drm_managed.h
index 191d8d206ff4..ca4114633bf9 100644
--- a/include/drm/drm_managed.h
+++ b/include/drm/drm_managed.h
@@ -11,6 +11,16 @@ struct drm_device;
 
 typedef void (*drmres_release_t)(struct drm_device *dev, void *res);
 
+/**
+ * drmm_add_action - add a managed release action to a &drm_device
+ * @dev: DRM device
+ * @action: function which should be called when @dev is released
+ * @data: opaque pointer, passed to @action
+ *
+ * This function adds the @release action with optional parameter @data to the
+ * list of cleanup actions for @dev. The cleanup actions will be run in reverse
+ * order in the final drm_dev_put() call for @dev.
+ */
 #define drmm_add_action(dev, action, data) \
 	__drmm_add_action(dev, action, data, #action)
 
@@ -18,6 +28,15 @@ int __must_check __drmm_add_action(struct drm_device *dev,
 				   drmres_release_t action,
 				   void *data, const char *name);
 
+/**
+ * drmm_add_action_or_reset - add a managed release action to a &drm_device
+ * @dev: DRM device
+ * @action: function which should be called when @dev is released
+ * @data: opaque pointer, passed to @action
+ *
+ * Similar to drmm_add_action(), with the only difference that upon failure
+ * @action is directly called for any cleanup work necessary on failures.
+ */
 #define drmm_add_action_or_reset(dev, action, data) \
 	__drmm_add_action_or_reset(dev, action, data, #action)
 
@@ -28,10 +47,33 @@ int __must_check __drmm_add_action_or_reset(struct drm_device *dev,
 void drmm_add_final_kfree(struct drm_device *dev, void *container);
 
 void *drmm_kmalloc(struct drm_device *dev, size_t size, gfp_t gfp) __malloc;
+
+/**
+ * drmm_kzalloc - &drm_device managed kzalloc()
+ * @dev: DRM device
+ * @size: size of the memory allocation
+ * @gfp: GFP allocation flags
+ *
+ * This is a &drm_device managed version of kzalloc(). The allocated memory is
+ * automatically freed on the final drm_dev_put(). Memory can also be freed
+ * before the final drm_dev_put() by calling drmm_kfree().
+ */
 static inline void *drmm_kzalloc(struct drm_device *dev, size_t size, gfp_t gfp)
 {
 	return drmm_kmalloc(dev, size, gfp | __GFP_ZERO);
 }
+
+/**
+ * drmm_kmalloc_array - &drm_device managed kmalloc_array()
+ * @dev: DRM device
+ * @n: number of array elements to allocate
+ * @size: size of array member
+ * @flags: GFP allocation flags
+ *
+ * This is a &drm_device managed version of kmalloc_array(). The allocated
+ * memory is automatically freed on the final drm_dev_put() and works exactly
+ * like a memory allocation obtained by drmm_kmalloc().
+ */
 static inline void *drmm_kmalloc_array(struct drm_device *dev,
 				       size_t n, size_t size, gfp_t flags)
 {
@@ -42,11 +84,24 @@ static inline void *drmm_kmalloc_array(struct drm_device *dev,
 
 	return drmm_kmalloc(dev, bytes, flags);
 }
+
+/**
+ * drmm_kcalloc - &drm_device managed kcalloc()
+ * @dev: DRM device
+ * @n: number of array elements to allocate
+ * @size: size of array member
+ * @flags: GFP allocation flags
+ *
+ * This is a &drm_device managed version of kcalloc(). The allocated memory is
+ * automatically freed on the final drm_dev_put() and works exactly like a
+ * memory allocation obtained by drmm_kmalloc().
+ */
 static inline void *drmm_kcalloc(struct drm_device *dev,
 				 size_t n, size_t size, gfp_t flags)
 {
 	return drmm_kmalloc_array(dev, n, size, flags | __GFP_ZERO);
 }
+
 char *drmm_kstrdup(struct drm_device *dev, const char *s, gfp_t gfp);
 
 void drmm_kfree(struct drm_device *dev, void *data);

commit c23d686f1960a91006bfb4da1bb5edf88eef57c6
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Mar 23 15:49:23 2020 +0100

    drm: Manage drm_vblank_cleanup with drmm_
    
    Nothing special here, except that this is the first time that we
    automatically clean up something that's initialized with an explicit
    driver call. But the cleanup was done at the very end of the release
    sequence for all drivers, and that's still the case. At least without
    more uses of drmm_ through explicit driver calls.
    
    Also for this one we need drmm_kcalloc, so lets add those.
    
    The motivation here is to allow us to remove the explicit calls to
    drm_dev_fini() from all drivers.
    
    v2: Sort includes (Laurent)
    
    v3: Motivate the change in the commit message better (Sam)
    
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200323144950.3018436-25-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_managed.h b/include/drm/drm_managed.h
index 2d1e29a2200c..191d8d206ff4 100644
--- a/include/drm/drm_managed.h
+++ b/include/drm/drm_managed.h
@@ -4,6 +4,7 @@
 #define _DRM_MANAGED_H_
 
 #include <linux/gfp.h>
+#include <linux/overflow.h>
 #include <linux/types.h>
 
 struct drm_device;
@@ -31,6 +32,21 @@ static inline void *drmm_kzalloc(struct drm_device *dev, size_t size, gfp_t gfp)
 {
 	return drmm_kmalloc(dev, size, gfp | __GFP_ZERO);
 }
+static inline void *drmm_kmalloc_array(struct drm_device *dev,
+				       size_t n, size_t size, gfp_t flags)
+{
+	size_t bytes;
+
+	if (unlikely(check_mul_overflow(n, size, &bytes)))
+		return NULL;
+
+	return drmm_kmalloc(dev, bytes, flags);
+}
+static inline void *drmm_kcalloc(struct drm_device *dev,
+				 size_t n, size_t size, gfp_t flags)
+{
+	return drmm_kmalloc_array(dev, n, size, flags | __GFP_ZERO);
+}
 char *drmm_kstrdup(struct drm_device *dev, const char *s, gfp_t gfp);
 
 void drmm_kfree(struct drm_device *dev, void *data);

commit f96306f9892b3a28ece4c65c4d1b95f631b3e63c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Mar 24 21:39:36 2020 +0100

    drm: manage drm_minor cleanup with drmm_
    
    The cleanup here is somewhat tricky, since we can't tell apart the
    allocated minor index from 0. So register a cleanup action first, and
    if the index allocation fails, unregister that cleanup action again to
    avoid bad mistakes.
    
    The kdev for the minor already handles NULL, so no problem there.
    
    Hence add drmm_remove_action() to the drm_managed library.
    
    v2: Make pointer math around void ** consistent with what Laurent
    suggested.
    
    v3: Use drmm_add_action_or_reset and remove drmm_remove_action. Noticed
    because of some questions from Thomas. This also means we need to move
    the drmm_add_action_or_reset helper earlier in the series.
    
    v4: Uh ... fix slightly embarrassing bug CI spotted.
    
    Acked-by: Thomas Zimmermann <tzimmermann@suse.de>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Thomas Zimmermann <tzimmermann@suse.de>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200324203936.3330994-1-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_managed.h b/include/drm/drm_managed.h
index 89e6fce9f689..2d1e29a2200c 100644
--- a/include/drm/drm_managed.h
+++ b/include/drm/drm_managed.h
@@ -17,7 +17,14 @@ int __must_check __drmm_add_action(struct drm_device *dev,
 				   drmres_release_t action,
 				   void *data, const char *name);
 
-void drmm_add_final_kfree(struct drm_device *dev, void *parent);
+#define drmm_add_action_or_reset(dev, action, data) \
+	__drmm_add_action_or_reset(dev, action, data, #action)
+
+int __must_check __drmm_add_action_or_reset(struct drm_device *dev,
+					    drmres_release_t action,
+					    void *data, const char *name);
+
+void drmm_add_final_kfree(struct drm_device *dev, void *container);
 
 void *drmm_kmalloc(struct drm_device *dev, size_t size, gfp_t gfp) __malloc;
 static inline void *drmm_kzalloc(struct drm_device *dev, size_t size, gfp_t gfp)

commit a5c71fdba9dfeff1f47713a641ef5ce2eadf5e8f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Mar 23 15:49:19 2020 +0100

    drm: Handle dev->unique with drmm_
    
    We need to add a drmm_kstrdup for this, but let's start somewhere.
    
    This is not exactly perfect onion unwinding, but it's jsut a kfree so
    doesn't really matter at all.
    
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Acked-by: Thomas Zimmermann <tzimmermann@suse.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200323144950.3018436-21-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_managed.h b/include/drm/drm_managed.h
index 7b5df7d09b19..89e6fce9f689 100644
--- a/include/drm/drm_managed.h
+++ b/include/drm/drm_managed.h
@@ -24,6 +24,7 @@ static inline void *drmm_kzalloc(struct drm_device *dev, size_t size, gfp_t gfp)
 {
 	return drmm_kmalloc(dev, size, gfp | __GFP_ZERO);
 }
+char *drmm_kstrdup(struct drm_device *dev, const char *s, gfp_t gfp);
 
 void drmm_kfree(struct drm_device *dev, void *data);
 

commit c6603c740e0e3492c9c95fdab833375bf7117b6b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Mar 24 13:45:40 2020 +0100

    drm: add managed resources tied to drm_device
    
    We have lots of these. And the cleanup code tends to be of dubious
    quality. The biggest wrong pattern is that developers use devm_, which
    ties the release action to the underlying struct device, whereas
    all the userspace visible stuff attached to a drm_device can long
    outlive that one (e.g. after a hotunplug while userspace has open
    files and mmap'ed buffers). Give people what they want, but with more
    correctness.
    
    Mostly copied from devres.c, with types adjusted to fit drm_device and
    a few simplifications - I didn't (yet) copy over everything. Since
    the types don't match code sharing looked like a hopeless endeavour.
    
    For now it's only super simplified, no groups, you can't remove
    actions (but kfree exists, we'll need that soon). Plus all specific to
    drm_device ofc, including the logging. Which I didn't bother to make
    compile-time optional, since none of the other drm logging is compile
    time optional either.
    
    One tricky bit here is the chicken&egg between allocating your
    drm_device structure and initiliazing it with drm_dev_init. For
    perfect onion unwinding we'd need to have the action to kfree the
    allocation registered before drm_dev_init registers any of its own
    release handlers. But drm_dev_init doesn't know where exactly the
    drm_device is emebedded into the overall structure, and by the time it
    returns it'll all be too late. And forcing drivers to be able clean up
    everything except the one kzalloc is silly.
    
    Work around this by having a very special final_kfree pointer. This
    also avoids troubles with the list head possibly disappearing from
    underneath us when we release all resources attached to the
    drm_device.
    
    v2: Do all the kerneldoc at the end, to avoid lots of fairly pointless
    shuffling while getting everything into shape.
    
    v3: Add static to add/del_dr (Neil)
    Move typo fix to the right patch (Neil)
    
    v4: Enforce contract for drmm_add_final_kfree:
    
    Use ksize() to check that the drm_device is indeed contained somewhere
    in the final kfree(). Because we need that or the entire managed
    release logic blows up in a pile of use-after-frees. Motivated by a
    discussion with Laurent.
    
    v5: Review from Laurent:
    - %zu instead of casting size_t
    - header guards
    - sorting of includes
    - guarding of data assignment if we didn't allocate it for a NULL
      pointer
    - delete spurious newline
    - cast void* data parameter correctly in ->release call, no idea how
      this even worked before
    
    v6: Review from Sam
    - Add the kerneldoc for the managed sub-struct back in, even if it
      doesn't show up in the generated html somehow.
    - Explain why __always_inline.
    - Fix bisectability around the final kfree() in drm_dev_relase(). This
      is just interim code which will disappear again.
    - Some whitespace polish.
    - Add debug output when drmm_add_action or drmm_kmalloc fail.
    
    v7: My bisectability fix wasn't up to par as noticed by smatch.
    
    v8: Remove unecessary {} around if else
    
    v9: Use kstrdup_const, which requires kfree_const and introducing a free_dr()
    helper (Thomas).
    
    v10: kfree_const goes boom on the plain "kmalloc" assignment, somehow
    we need to wrap that in kstrdup_const() too!! Also renumber revision
    log, I somehow reset it midway thruh.
    
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Thomas Zimmermann <tzimmermann@suse.de>
    Cc: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Neil Armstrong <narmstrong@baylibre.com
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200324124540.3227396-1-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_managed.h b/include/drm/drm_managed.h
new file mode 100644
index 000000000000..7b5df7d09b19
--- /dev/null
+++ b/include/drm/drm_managed.h
@@ -0,0 +1,30 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#ifndef _DRM_MANAGED_H_
+#define _DRM_MANAGED_H_
+
+#include <linux/gfp.h>
+#include <linux/types.h>
+
+struct drm_device;
+
+typedef void (*drmres_release_t)(struct drm_device *dev, void *res);
+
+#define drmm_add_action(dev, action, data) \
+	__drmm_add_action(dev, action, data, #action)
+
+int __must_check __drmm_add_action(struct drm_device *dev,
+				   drmres_release_t action,
+				   void *data, const char *name);
+
+void drmm_add_final_kfree(struct drm_device *dev, void *parent);
+
+void *drmm_kmalloc(struct drm_device *dev, size_t size, gfp_t gfp) __malloc;
+static inline void *drmm_kzalloc(struct drm_device *dev, size_t size, gfp_t gfp)
+{
+	return drmm_kmalloc(dev, size, gfp | __GFP_ZERO);
+}
+
+void drmm_kfree(struct drm_device *dev, void *data);
+
+#endif
