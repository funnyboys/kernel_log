commit 48e678076e58341a70369d2db67770272181aa41
Author: Thomas Zimmermann <tzimmermann@suse.de>
Date:   Thu Jan 23 14:59:43 2020 +0100

    drm: Remove legacy version of get_scanout_position()
    
    The legacy version of get_scanout_position() was only useful while
    drivers still used drm_driver.get_scanout_position(). With no such
    drivers left, the related typedef and code can be removed
    
    Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200123135943.24140-23-tzimmermann@suse.de

diff --git a/include/drm/drm_vblank.h b/include/drm/drm_vblank.h
index e20eb254b0c4..dd9f5b9e56e4 100644
--- a/include/drm/drm_vblank.h
+++ b/include/drm/drm_vblank.h
@@ -247,22 +247,12 @@ typedef bool (*drm_vblank_get_scanout_position_func)(struct drm_crtc *crtc,
 						     ktime_t *etime,
 						     const struct drm_display_mode *mode);
 
-typedef bool (*drm_vblank_get_scanout_position_legacy_func)(struct drm_device *dev,
-							    unsigned int pipe,
-							    bool in_vblank_irq,
-							    int *vpos,
-							    int *hpos,
-							    ktime_t *stime,
-							    ktime_t *etime,
-							    const struct drm_display_mode *mode);
-
 bool
 drm_crtc_vblank_helper_get_vblank_timestamp_internal(struct drm_crtc *crtc,
 						     int *max_error,
 						     ktime_t *vblank_time,
 						     bool in_vblank_irq,
-						     drm_vblank_get_scanout_position_func get_scanout_position,
-						     drm_vblank_get_scanout_position_legacy_func get_scanout_position_legacy);
+						     drm_vblank_get_scanout_position_func get_scanout_position);
 bool drm_crtc_vblank_helper_get_vblank_timestamp(struct drm_crtc *crtc,
 						 int *max_error,
 						 ktime_t *vblank_time,

commit f397d66b31ab4f1380d3f31e2770e160a3e5a73b
Author: Thomas Zimmermann <tzimmermann@suse.de>
Date:   Thu Jan 23 14:59:42 2020 +0100

    drm: Clean-up VBLANK-related callbacks in struct drm_driver
    
    All non-legacy users of VBLANK functions in struct drm_driver have been
    converted to use the respective interfaces in struct drm_crtc_funcs. The
    remaining users of VBLANK callbacks in struct drm_driver are legacy drivers
    with userspace modesetting.
    
    All users of struct drm_driver.get_scanout_position() have been
    converted to the respective CRTC helper function. Remove the callback
    from struct drm_driver.
    
    There are no users left of get_vblank_timestamp(), so the callback is
    being removed. The other VBLANK callbacks are being moved to the legacy
    section at the end of struct drm_driver.
    
    Also removed is drm_calc_vbltimestamp_from_scanoutpos(). Callers of this
    function have been converted to use the CRTC instead.
    
    v4:
            * more readable code for setting high_prec (Ville, Jani)
    v2:
            * merge with removal of struct drm_driver.get_scanout_position()
            * remove drm_calc_vbltimestamp_from_scanoutpos()
    
    Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Tested-by: Yannick Fertré <yannick.fertre@st.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200123135943.24140-22-tzimmermann@suse.de

diff --git a/include/drm/drm_vblank.h b/include/drm/drm_vblank.h
index 91f8e35d588d..e20eb254b0c4 100644
--- a/include/drm/drm_vblank.h
+++ b/include/drm/drm_vblank.h
@@ -230,10 +230,6 @@ u64 drm_crtc_accurate_vblank_count(struct drm_crtc *crtc);
 void drm_vblank_restore(struct drm_device *dev, unsigned int pipe);
 void drm_crtc_vblank_restore(struct drm_crtc *crtc);
 
-bool drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev,
-					   unsigned int pipe, int *max_error,
-					   ktime_t *vblank_time,
-					   bool in_vblank_irq);
 void drm_calc_timestamping_constants(struct drm_crtc *crtc,
 				     const struct drm_display_mode *mode);
 wait_queue_head_t *drm_crtc_vblank_waitqueue(struct drm_crtc *crtc);

commit 7fe3f0d15aac6c98a97e6d7086f5a6b7bc4ccae4
Author: Thomas Zimmermann <tzimmermann@suse.de>
Date:   Thu Jan 23 14:59:24 2020 +0100

    drm: Add get_vblank_timestamp() to struct drm_crtc_funcs
    
    The callback get_vblank_timestamp() is currently located in struct
    drm_driver, but really belongs into struct drm_crtc_funcs. Add an
    equivalent there. Driver will be converted in separate patches.
    
    The default implementation is drm_calc_vbltimestamp_from_scanoutpos().
    The patch adds drm_crtc_vblank_helper_get_vblank_timestamp(), which is
    an implementation for the CRTC callback.
    
    v4:
            * more readable code for setting high_prec (Ville, Jani)
    v3:
            * use refactored timestamp calculation to minimize duplicated code
            * do more checks for crtc != NULL to support legacy drivers
    v2:
            * rename helper to drm_crtc_vblank_helper_get_vblank_timestamp()
            * replace drm_calc_vbltimestamp_from_scanoutpos() with
              drm_crtc_vblank_helper_get_vblank_timestamp() in docs
    
    Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200123135943.24140-4-tzimmermann@suse.de

diff --git a/include/drm/drm_vblank.h b/include/drm/drm_vblank.h
index fd28741e64ed..91f8e35d588d 100644
--- a/include/drm/drm_vblank.h
+++ b/include/drm/drm_vblank.h
@@ -174,13 +174,13 @@ struct drm_vblank_crtc {
 	unsigned int pipe;
 	/**
 	 * @framedur_ns: Frame/Field duration in ns, used by
-	 * drm_calc_vbltimestamp_from_scanoutpos() and computed by
+	 * drm_crtc_vblank_helper_get_vblank_timestamp() and computed by
 	 * drm_calc_timestamping_constants().
 	 */
 	int framedur_ns;
 	/**
 	 * @linedur_ns: Line duration in ns, used by
-	 * drm_calc_vbltimestamp_from_scanoutpos() and computed by
+	 * drm_crtc_vblank_helper_get_vblank_timestamp() and computed by
 	 * drm_calc_timestamping_constants().
 	 */
 	int linedur_ns;
@@ -190,8 +190,8 @@ struct drm_vblank_crtc {
 	 *
 	 * Cache of the current hardware display mode. Only valid when @enabled
 	 * is set. This is used by helpers like
-	 * drm_calc_vbltimestamp_from_scanoutpos(). We can't just access the
-	 * hardware mode by e.g. looking at &drm_crtc_state.adjusted_mode,
+	 * drm_crtc_vblank_helper_get_vblank_timestamp(). We can't just access
+	 * the hardware mode by e.g. looking at &drm_crtc_state.adjusted_mode,
 	 * because that one is really hard to get from interrupt context.
 	 */
 	struct drm_display_mode hwmode;
@@ -240,6 +240,10 @@ wait_queue_head_t *drm_crtc_vblank_waitqueue(struct drm_crtc *crtc);
 void drm_crtc_set_max_vblank_count(struct drm_crtc *crtc,
 				   u32 max_vblank_count);
 
+/*
+ * Helpers for struct drm_crtc_funcs
+ */
+
 typedef bool (*drm_vblank_get_scanout_position_func)(struct drm_crtc *crtc,
 						     bool in_vblank_irq,
 						     int *vpos, int *hpos,
@@ -263,5 +267,9 @@ drm_crtc_vblank_helper_get_vblank_timestamp_internal(struct drm_crtc *crtc,
 						     bool in_vblank_irq,
 						     drm_vblank_get_scanout_position_func get_scanout_position,
 						     drm_vblank_get_scanout_position_legacy_func get_scanout_position_legacy);
+bool drm_crtc_vblank_helper_get_vblank_timestamp(struct drm_crtc *crtc,
+						 int *max_error,
+						 ktime_t *vblank_time,
+						 bool in_vblank_irq);
 
 #endif

commit f1e2b6371c12aec5e772e5fdedaa4455c20a787f
Author: Thomas Zimmermann <tzimmermann@suse.de>
Date:   Thu Jan 23 14:59:23 2020 +0100

    drm: Add get_scanout_position() to struct drm_crtc_helper_funcs
    
    The new callback get_scanout_position() reads the current location
    of the scanout process. The operation is currently located in struct
    drm_driver, but really belongs to the CRTC. Drivers will be converted
    in separate patches.
    
    To help with the conversion, the timestamp calculation has been
    moved from drm_calc_vbltimestamp_from_scanoutpos() to
    drm_crtc_vblank_helper_get_vblank_timestamp_internal(). The helper
    function supports the new and old interface of get_scanout_position().
    drm_calc_vbltimestamp_from_scanoutpos() remains as a wrapper around
    the new function.
    
    Callback functions return the scanout position from the CRTC. The
    legacy version of the interface receives the device and pipe index,
    the modern version receives a pointer to the CRTC. We keep the
    legacy version until all drivers have been converted.
    
    v4:
            * 80-character line fixes
    v3:
            * refactor drm_calc_vbltimestamp_from_scanoutpos() to minimize
              code duplication
            * define types for get_scanout_position() callbacks
    v2:
            * fix logical op in drm_calc_vbltimestamp_from_scanoutpos()
    
    Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
    Tested-by: Yannick Fertré <yannick.fertre@st.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200123135943.24140-3-tzimmermann@suse.de

diff --git a/include/drm/drm_vblank.h b/include/drm/drm_vblank.h
index 94275e93fd27..fd28741e64ed 100644
--- a/include/drm/drm_vblank.h
+++ b/include/drm/drm_vblank.h
@@ -239,4 +239,29 @@ void drm_calc_timestamping_constants(struct drm_crtc *crtc,
 wait_queue_head_t *drm_crtc_vblank_waitqueue(struct drm_crtc *crtc);
 void drm_crtc_set_max_vblank_count(struct drm_crtc *crtc,
 				   u32 max_vblank_count);
+
+typedef bool (*drm_vblank_get_scanout_position_func)(struct drm_crtc *crtc,
+						     bool in_vblank_irq,
+						     int *vpos, int *hpos,
+						     ktime_t *stime,
+						     ktime_t *etime,
+						     const struct drm_display_mode *mode);
+
+typedef bool (*drm_vblank_get_scanout_position_legacy_func)(struct drm_device *dev,
+							    unsigned int pipe,
+							    bool in_vblank_irq,
+							    int *vpos,
+							    int *hpos,
+							    ktime_t *stime,
+							    ktime_t *etime,
+							    const struct drm_display_mode *mode);
+
+bool
+drm_crtc_vblank_helper_get_vblank_timestamp_internal(struct drm_crtc *crtc,
+						     int *max_error,
+						     ktime_t *vblank_time,
+						     bool in_vblank_irq,
+						     drm_vblank_get_scanout_position_func get_scanout_position,
+						     drm_vblank_get_scanout_position_legacy_func get_scanout_position_legacy);
+
 #endif

commit 7beb691f1e6f349c9df3384a85e7a53c5601aaaf
Author: Thomas Zimmermann <tzimmermann@suse.de>
Date:   Wed Jan 29 13:05:17 2020 +0100

    drm: Initialize struct drm_crtc_state.no_vblank from device settings
    
    At the end of a commit, atomic helpers can generate a fake VBLANK event
    automatically. Originally implemented for writeback connectors, the
    functionality can be used by any driver and/or hardware without proper
    VBLANK interrupt.
    
    The patch updates the documentation to make this behaviour official:
    settings struct drm_crtc_state.no_vblank to true enables automatic
    generation of fake VBLANK events.
    
    The new interface drm_dev_has_vblank() returns true if vblanking has
    been initialized for a device, or false otherwise. Atomic helpers use
    this function when initializing no_vblank in the CRTC state in
    drm_atomic_helper_check_modeset(). If vblanking has been initialized
    for a device, no_blank is disabled. Otherwise it's enabled. Hence,
    atomic helpers will automatically send out fake VBLANK events with any
    driver that did not initialize vblanking.
    
    v5:
            * more precise documentation and commit message
    v4:
            * replace drm_crtc_has_vblank() with drm_dev_has_vblank()
            * add drm_dev_has_vblank() in this patch
            * move driver changes into separate patches
    v3:
            * squash all related changes patches into this patch
    
    Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
    Acked-by: Gerd Hoffmann <kraxel@redhat.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200129120531.6891-2-tzimmermann@suse.de

diff --git a/include/drm/drm_vblank.h b/include/drm/drm_vblank.h
index c16c44052b3d..94275e93fd27 100644
--- a/include/drm/drm_vblank.h
+++ b/include/drm/drm_vblank.h
@@ -206,6 +206,7 @@ struct drm_vblank_crtc {
 };
 
 int drm_vblank_init(struct drm_device *dev, unsigned int num_crtcs);
+bool drm_dev_has_vblank(const struct drm_device *dev);
 u64 drm_crtc_vblank_count(struct drm_crtc *crtc);
 u64 drm_crtc_vblank_count_and_time(struct drm_crtc *crtc,
 				   ktime_t *vblanktime);

commit bd7e3f3ba1efab5c2c188d097589b9bc93ffaeaa
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jul 23 15:13:37 2019 +0200

    drm/vblank: Document and fix vblank count barrier semantics
    
    Noticed while reviewing code. I'm not sure whether this might or might
    not explain some of the missed vblank hilarity we've been seeing on
    various drivers (but those got tracked down to driver issues, at least
    mostly). I think those all go through the vblank completion event,
    which has unconditional barriers - it always takes the spinlock.
    Therefore no cc stable.
    
    v2:
    - Barrriers are hard, put them in in the right order (Chris).
    - Improve the comments a bit.
    
    v3:
    
    Ville noticed that on 32bit we might be breaking up the load/stores,
    now that the vblank counter has been switched over to be 64 bit. Fix
    that up by switching to atomic64_t. This this happens so rarely in
    practice I figured no need to cc: stable ...
    
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Keith Packard <keithp@keithp.com>
    References: 570e86963a51 ("drm: Widen vblank count to 64-bits [v3]")
    Cc: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190723131337.22031-1-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_vblank.h b/include/drm/drm_vblank.h
index 9fe4ba8bc622..c16c44052b3d 100644
--- a/include/drm/drm_vblank.h
+++ b/include/drm/drm_vblank.h
@@ -109,9 +109,20 @@ struct drm_vblank_crtc {
 	seqlock_t seqlock;
 
 	/**
-	 * @count: Current software vblank counter.
+	 * @count:
+	 *
+	 * Current software vblank counter.
+	 *
+	 * Note that for a given vblank counter value drm_crtc_handle_vblank()
+	 * and drm_crtc_vblank_count() or drm_crtc_vblank_count_and_time()
+	 * provide a barrier: Any writes done before calling
+	 * drm_crtc_handle_vblank() will be visible to callers of the later
+	 * functions, iff the vblank count is the same or a later one.
+	 *
+	 * IMPORTANT: This guarantee requires barriers, therefor never access
+	 * this field directly. Use drm_crtc_vblank_count() instead.
 	 */
-	u64 count;
+	atomic64_t count;
 	/**
 	 * @time: Vblank timestamp corresponding to @count.
 	 */

commit 3e37c7156e94442025e88de58de5ed966f2b64a0
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Thu Jul 18 18:14:59 2019 +0200

    drm: drop uapi dependency from drm_vblank.h
    
    drm_vblank.h included uapi/drm/drm.h.
    It turns out this include was not required - delete it.
    
    Note: uapi/drm/drm.h is included indirect via drm_file.h,
    but there are no dependencies in drm_vblank.h so the removal
    is legit.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Sean Paul <sean@poorly.run>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Stefan Agner <stefan@agner.ch>
    Cc: Thierry Reding <treding@nvidia.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190718161507.2047-4-sam@ravnborg.org

diff --git a/include/drm/drm_vblank.h b/include/drm/drm_vblank.h
index e528bb2f659d..9fe4ba8bc622 100644
--- a/include/drm/drm_vblank.h
+++ b/include/drm/drm_vblank.h
@@ -30,7 +30,6 @@
 
 #include <drm/drm_file.h>
 #include <drm/drm_modes.h>
-#include <uapi/drm/drm.h>
 
 struct drm_device;
 struct drm_crtc;

commit ed20151a7699bb2c77eba3610199789a126940c4
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Nov 27 20:20:04 2018 +0200

    drm/vblank: Allow dynamic per-crtc max_vblank_count
    
    On i965gm we need to adjust max_vblank_count dynamically
    depending on whether the TV encoder is used or not. To
    that end add a per-crtc max_vblank_count that takes
    precedence over its device wide counterpart. The driver
    can now call drm_crtc_set_max_vblank_count() to configure
    the per-crtc value before calling drm_vblank_on().
    
    Also looks like there was some discussion about exynos needing
    similar treatment.
    
    v2: Drop the extra max_vblank_count!=0 check for the
        WARN(last!=current), will take care of it in i915 code (Daniel)
        WARN_ON(!inmodeset) (Daniel)
        WARN_ON(dev->max_vblank_count)
        Pimp up the docs (Daniel)
    
    Cc: stable@vger.kernel.org
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181127182004.28885-1-ville.syrjala@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_vblank.h b/include/drm/drm_vblank.h
index 6ad9630d4f48..e528bb2f659d 100644
--- a/include/drm/drm_vblank.h
+++ b/include/drm/drm_vblank.h
@@ -128,6 +128,26 @@ struct drm_vblank_crtc {
 	 * @last: Protected by &drm_device.vbl_lock, used for wraparound handling.
 	 */
 	u32 last;
+	/**
+	 * @max_vblank_count:
+	 *
+	 * Maximum value of the vblank registers for this crtc. This value +1
+	 * will result in a wrap-around of the vblank register. It is used
+	 * by the vblank core to handle wrap-arounds.
+	 *
+	 * If set to zero the vblank core will try to guess the elapsed vblanks
+	 * between times when the vblank interrupt is disabled through
+	 * high-precision timestamps. That approach is suffering from small
+	 * races and imprecision over longer time periods, hence exposing a
+	 * hardware vblank counter is always recommended.
+	 *
+	 * This is the runtime configurable per-crtc maximum set through
+	 * drm_crtc_set_max_vblank_count(). If this is used the driver
+	 * must leave the device wide &drm_device.max_vblank_count at zero.
+	 *
+	 * If non-zero, &drm_crtc_funcs.get_vblank_counter must be set.
+	 */
+	u32 max_vblank_count;
 	/**
 	 * @inmodeset: Tracks whether the vblank is disabled due to a modeset.
 	 * For legacy driver bit 2 additionally tracks whether an additional
@@ -206,4 +226,6 @@ bool drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev,
 void drm_calc_timestamping_constants(struct drm_crtc *crtc,
 				     const struct drm_display_mode *mode);
 wait_queue_head_t *drm_crtc_vblank_waitqueue(struct drm_crtc *crtc);
+void drm_crtc_set_max_vblank_count(struct drm_crtc *crtc,
+				   u32 max_vblank_count);
 #endif

commit 9e37ee7913b44b1fbaea327111ad991c7315d245
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Oct 5 09:36:36 2018 +0200

    drm/vblank: Remove old-style comments
    
    Somehow I forgot a few when typing all the shiny new kerneldoc. Drop
    them.
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181005073636.27291-1-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_vblank.h b/include/drm/drm_vblank.h
index d25a9603ab57..6ad9630d4f48 100644
--- a/include/drm/drm_vblank.h
+++ b/include/drm/drm_vblank.h
@@ -95,7 +95,7 @@ struct drm_vblank_crtc {
 	/**
 	 * @queue: Wait queue for vblank waiters.
 	 */
-	wait_queue_head_t queue;	/**< VBLANK wait queue */
+	wait_queue_head_t queue;
 	/**
 	 * @disable_timer: Disable timer for the delayed vblank disabling
 	 * hysteresis logic. Vblank disabling is controlled through the
@@ -107,7 +107,7 @@ struct drm_vblank_crtc {
 	/**
 	 * @seqlock: Protect vblank count and time.
 	 */
-	seqlock_t seqlock;		/* protects vblank count and time */
+	seqlock_t seqlock;
 
 	/**
 	 * @count: Current software vblank counter.
@@ -123,7 +123,7 @@ struct drm_vblank_crtc {
 	 * this refcount reaches 0 can the hardware interrupt be disabled using
 	 * @disable_timer.
 	 */
-	atomic_t refcount;		/* number of users of vblank interruptsper crtc */
+	atomic_t refcount;
 	/**
 	 * @last: Protected by &drm_device.vbl_lock, used for wraparound handling.
 	 */
@@ -136,7 +136,7 @@ struct drm_vblank_crtc {
 	 * call drm_crtc_vblank_off() and drm_crtc_vblank_on(), which explicitly
 	 * save and restore the vblank count.
 	 */
-	unsigned int inmodeset;		/* Display driver is setting mode */
+	unsigned int inmodeset;
 	/**
 	 * @pipe: drm_crtc_index() of the &drm_crtc corresponding to this
 	 * structure.

commit f073d78eeb8efd85718e611c15f9a78647751dea
Merge: 0feeb106c795 fed8165851e2
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Mar 1 14:07:22 2018 +1000

    Merge tag 'drm-intel-next-2018-02-21' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    Driver Changes:
    
    - Lift alpha_support protection from Cannonlake (Rodrigo)
            * Meaning the driver should mostly work for the hardware we had
              at our disposal when testing
            * Used to be preliminary_hw_support
    - Add missing Cannonlake PCI device ID of 0x5A4C (Rodrigo)
    - Cannonlake port register fix (Mahesh)
    
    - Fix Dell Venue 8 Pro black screen after modeset (Hans)
    - Fix for always returning zero out-fence from execbuf (Daniele)
    - Fix HDMI audio when no no relevant video output is active (Jani)
    - Fix memleak of VBT data on driver_unload (Hans)
    
    - Fix for KASAN found locking issue (Maarten)
    - RCU barrier consolidation to improve igt/gem_sync/idle (Chris)
    - Optimizations to IRQ handlers (Chris)
    - vblank tracking improvements (64-bit resolution, PM) (Dhinakaran)
    - Pipe select bit corrections (Ville)
    - Reduce runtime computed device_info fields (Chris)
    - Tune down some WARN_ONs to GEM_BUG_ON now that CI has good coverage (Chris)
    - A bunch of kerneldoc warning fixes (Chris)
    
    * tag 'drm-intel-next-2018-02-21' of git://anongit.freedesktop.org/drm/drm-intel: (113 commits)
      drm/i915: Update DRIVER_DATE to 20180221
      drm/i915/fbc: Use PLANE_HAS_FENCE to determine if the plane is fenced
      drm/i915/fbdev: Use the PLANE_HAS_FENCE flags from the time of pinning
      drm/i915: Move the policy for placement of the GGTT vma into the caller
      drm/i915: Also check view->type for a normal GGTT view
      drm/i915: Drop WaDoubleCursorLP3Latency:ivb
      drm/i915: Set the primary plane pipe select bits on gen4
      drm/i915: Don't set cursor pipe select bits on g4x+
      drm/i915: Assert that we don't overflow frontbuffer tracking bits
      drm/i915: Track number of pending freed objects
      drm/i915/: Initialise trans_min for skl_compute_transition_wm()
      drm/i915: Clear the in-use marker on execbuf failure
      drm/i915: Prune gen8_gt_irq_handler
      drm/i915: Track GT interrupt handling using the master iir
      drm/i915: Remove WARN_ONCE for failing to pm_runtime_if_in_use
      drm: intel_dpio_phy: fix kernel-doc comments at nested struct
      drm/i915: Release connector iterator on a digital port conflict.
      drm/i915/execlists: Remove too early assert
      drm/i915: Assert that we always complete a submission to guc/execlists
      drm: move read_domains and write_domain into i915
      ...

commit 83a7dff07f5a08b90271a34cf7cf5cb280cf5bd9
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Feb 19 23:53:56 2018 +0100

    drm/doc: Use new substruct support
    
    Support for this just recently landed in linux-next.
    
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180219225356.24996-5-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_vblank.h b/include/drm/drm_vblank.h
index 848b463a0af5..425ad80ed2ac 100644
--- a/include/drm/drm_vblank.h
+++ b/include/drm/drm_vblank.h
@@ -55,8 +55,24 @@ struct drm_pending_vblank_event {
 	 * @event: Actual event which will be sent to userspace.
 	 */
 	union {
+		/**
+		 * @event.base: DRM event base class.
+		 */
 		struct drm_event base;
+
+		/**
+		 * @event.vbl:
+		 *
+		 * Event payload for vblank events, requested through
+		 * either the MODE_PAGE_FLIP or MODE_ATOMIC IOCTL. Also
+		 * generated by the legacy WAIT_VBLANK IOCTL, but new userspace
+		 * should use MODE_QUEUE_SEQUENCE and &event.seq instead.
+		 */
 		struct drm_event_vblank vbl;
+
+		/**
+		 * @event.seq: Event payload for the MODE_QUEUEU_SEQUENCE IOCTL.
+		 */
 		struct drm_event_crtc_sequence seq;
 	} event;
 };

commit d0bb96b4be69feea97f16de5306c35e280658931
Author: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
Date:   Fri Feb 2 21:13:01 2018 -0800

    drm/vblank: Restoring vblank counts after device PM events.
    
    The HW frame counter can get reset if device enters a low power state after
    vblank interrupts were disabled. This messes up any following vblank count
    update as a negative diff (huge unsigned diff) is calculated from the HW
    frame counter change. We cannot ignore negative diffs altogther as there
    could be legitimate wrap arounds. So, allow drivers to update vblank->count
    with missed vblanks for the time interrupts were disabled. This is similar
    to _crtc_vblank_on() except that vblanks interrupts are not enabled at the
    end as this function is expected to be called from the driver
    _enable_vblank() vfunc.
    
    v2: drm_crtc_vblank_restore should take crtc as arg. (Chris)
        Add docs and sprinkle some asserts.
    
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Michel Dänzer <michel@daenzer.net>
    Signed-off-by: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180203051302.9974-9-dhinakaran.pandiyan@intel.com

diff --git a/include/drm/drm_vblank.h b/include/drm/drm_vblank.h
index a4c3b0a0a197..16d46e2a6854 100644
--- a/include/drm/drm_vblank.h
+++ b/include/drm/drm_vblank.h
@@ -180,6 +180,8 @@ void drm_crtc_vblank_off(struct drm_crtc *crtc);
 void drm_crtc_vblank_reset(struct drm_crtc *crtc);
 void drm_crtc_vblank_on(struct drm_crtc *crtc);
 u64 drm_crtc_accurate_vblank_count(struct drm_crtc *crtc);
+void drm_vblank_restore(struct drm_device *dev, unsigned int pipe);
+void drm_crtc_vblank_restore(struct drm_crtc *crtc);
 
 bool drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev,
 					   unsigned int pipe, int *max_error,

commit 3b765c0b765d2cc03ef02276f1af2658a03b3ced
Author: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
Date:   Fri Feb 2 21:12:53 2018 -0800

    drm/vblank: Data type fixes for 64-bit vblank sequences.
    
    drm_vblank_count() has an u32 type returning what is a 64-bit vblank count.
    The effect of this is when drm_wait_vblank_ioctl() tries to widen the user
    space requested vblank sequence using this clipped 32-bit count(when the
    value is >= 2^32) as reference, the requested sequence remains a 32-bit
    value and gets queued like that. However, the code that checks if the
    requested sequence has passed compares this against the 64-bit vblank
    count.
    
    With drm_vblank_count() returning all bits of the vblank count, update
    drm_crtc_accurate_vblank_count() so that drm_crtc_arm_vblank_event() queues
    the correct sequence. Otherwise, this leads to prolonged waits for a vblank
    sequence when the current count is >=2^32.
    
    Finally, fix drm_wait_one_vblank() too.
    
    v2: Commit message fix (Keith)
        Squash commits (Rodrigo)
    
    Fixes: 570e86963a51 ("drm: Widen vblank count to 64-bits [v3]")
    Cc: Keith Packard <keithp@keithp.com>
    Cc: Michel Dänzer <michel@daenzer.net>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180203051302.9974-1-dhinakaran.pandiyan@intel.com

diff --git a/include/drm/drm_vblank.h b/include/drm/drm_vblank.h
index 848b463a0af5..a4c3b0a0a197 100644
--- a/include/drm/drm_vblank.h
+++ b/include/drm/drm_vblank.h
@@ -179,7 +179,7 @@ void drm_crtc_wait_one_vblank(struct drm_crtc *crtc);
 void drm_crtc_vblank_off(struct drm_crtc *crtc);
 void drm_crtc_vblank_reset(struct drm_crtc *crtc);
 void drm_crtc_vblank_on(struct drm_crtc *crtc);
-u32 drm_crtc_accurate_vblank_count(struct drm_crtc *crtc);
+u64 drm_crtc_accurate_vblank_count(struct drm_crtc *crtc);
 
 bool drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev,
 					   unsigned int pipe, int *max_error,

commit 3064abfa932bd09faf8da01741d171d476cf7193
Author: Keith Packard <keithp@keithp.com>
Date:   Thu Jun 29 22:49:31 2017 -0700

    drm: Add CRTC_GET_SEQUENCE and CRTC_QUEUE_SEQUENCE ioctls [v3]
    
    These provide crtc-id based functions instead of pipe-number, while
    also offering higher resolution time (ns) and wider frame count (64)
    as required by the Vulkan API.
    
    v2:
    
     * Check for DRIVER_MODESET in new crtc-based vblank ioctls
    
            Failing to check this will oops the driver.
    
     * Ensure vblank interupt is running in crtc_get_sequence ioctl
    
            The sequence and timing values are not correct while the
            interrupt is off, so make sure it's running before asking for
            them.
    
     * Short-circuit get_sequence if the counter is enabled and accurate
    
            Steal the idea from the code in wait_vblank to avoid the
            expense of drm_vblank_get/put
    
     * Return active state of crtc in crtc_get_sequence ioctl
    
            Might be useful for applications that aren't in charge of
            modesetting?
    
     * Use drm_crtc_vblank_get/put in new crtc-based vblank sequence ioctls
    
            Daniel Vetter prefers these over the old drm_vblank_put/get
            APIs.
    
     * Return s64 ns instead of u64 in new sequence event
    
    Suggested-by: Daniel Vetter <daniel@ffwll.ch>
    Suggested-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    
    v3:
    
     * Removed FIRST_PIXEL_OUT_FLAG
     * Document that the timestamp in the query and event are
       that of the first pixel leaving the display engine for
       the display (using the same wording as the Vulkan spec).
    
    Suggested-by: Michel Dänzer <michel@daenzer.net>
    Acked-by: Dave Airlie <airlied@redhat.com>
    
    [airlied: left->leaves (Michel)]
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_vblank.h b/include/drm/drm_vblank.h
index bf8e07035a0a..848b463a0af5 100644
--- a/include/drm/drm_vblank.h
+++ b/include/drm/drm_vblank.h
@@ -57,6 +57,7 @@ struct drm_pending_vblank_event {
 	union {
 		struct drm_event base;
 		struct drm_event_vblank vbl;
+		struct drm_event_crtc_sequence seq;
 	} event;
 };
 

commit bd386e51805632abed4a0873a84af35f0c6461e3
Author: Keith Packard <keithp@keithp.com>
Date:   Wed Jul 5 14:34:23 2017 -0700

    drm: Reorganize drm_pending_event to support future event types [v2]
    
    Place drm_event_vblank in a new union that includes that and a bare
    drm_event structure. This will allow new members of that union to be
    added in the future without changing code related to the existing vbl
    event type.
    
    Assignments to the crtc_id field are now done when the event is
    allocated, rather than when delievered. This way, delivery doesn't
    need to have the crtc ID available.
    
    v2:
     * Remove 'dev' argument from create_vblank_event
    
            It wasn't being used anyways, and if we need it in the future,
            we can always get it from crtc->dev.
    
     * Check for MODESETTING before looking for crtc in queue_vblank_event
    
            UMS drivers will oops if we try to get a crtc, so make sure
            we're modesetting before we try to find a crtc_id to fill into
            the event.
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    (cherry picked from commit dc695b85fde88eca3ef3b03fcd82f15b6bc6e462)

diff --git a/include/drm/drm_vblank.h b/include/drm/drm_vblank.h
index cce53130510f..bf8e07035a0a 100644
--- a/include/drm/drm_vblank.h
+++ b/include/drm/drm_vblank.h
@@ -54,7 +54,10 @@ struct drm_pending_vblank_event {
 	/**
 	 * @event: Actual event which will be sent to userspace.
 	 */
-	struct drm_event_vblank event;
+	union {
+		struct drm_event base;
+		struct drm_event_vblank vbl;
+	} event;
 };
 
 /**
@@ -163,6 +166,9 @@ void drm_crtc_send_vblank_event(struct drm_crtc *crtc,
 			       struct drm_pending_vblank_event *e);
 void drm_crtc_arm_vblank_event(struct drm_crtc *crtc,
 			      struct drm_pending_vblank_event *e);
+void drm_vblank_set_event(struct drm_pending_vblank_event *e,
+			  u64 *seq,
+			  ktime_t *now);
 bool drm_handle_vblank(struct drm_device *dev, unsigned int pipe);
 bool drm_crtc_handle_vblank(struct drm_crtc *crtc);
 int drm_crtc_vblank_get(struct drm_crtc *crtc);

commit 570e86963a511c1b404e81c72d2c42169faf9324
Author: Keith Packard <keithp@keithp.com>
Date:   Thu Oct 12 11:57:49 2017 -0700

    drm: Widen vblank count to 64-bits [v3]
    
    This modifies the datatypes used by the vblank code to provide 64 bits
    of vblank count.
    
    The driver interfaces have been left using 32 bits of vblank count;
    all of the code necessary to widen that value for the user API was
    already included to handle devices returning fewer than 32-bits.
    
    This will provide the necessary datatypes for the Vulkan API.
    
    v2:
    
     * Re-write wait_vblank ioctl to ABSOLUTE sequence
    
        When an application uses the WAIT_VBLANK ioctl with RELATIVE
        or NEXTONMISS bits set, the target vblank interval is updated
        within the kernel. We need to write that target back to the
        ioctl buffer and update the flags bits so that if the wait is
        interrupted by a signal, when it is re-started, it will target
        precisely the same vblank count as before.
    
     * Leave driver API with 32-bit vblank count
    
    v3:
    
     * Rebase on top of Arnd Bergmann's patch which had
       the switch to ktime_t parts.
    
    [airlied: fix conflict with Ville vblank change].
    
    Suggested-by:  Michel Dänzer <michel@daenzer.net>
    Suggested-by: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    (cherry picked from commit 2affbc16983e4fc90960bc7f70e7615f4228199b)

diff --git a/include/drm/drm_vblank.h b/include/drm/drm_vblank.h
index 6a58e2e91a0f..cce53130510f 100644
--- a/include/drm/drm_vblank.h
+++ b/include/drm/drm_vblank.h
@@ -47,6 +47,10 @@ struct drm_pending_vblank_event {
 	 * @pipe: drm_crtc_index() of the &drm_crtc this event is for.
 	 */
 	unsigned int pipe;
+	/**
+	 * @sequence: frame event should be triggered at
+	 */
+	u64 sequence;
 	/**
 	 * @event: Actual event which will be sent to userspace.
 	 */
@@ -88,7 +92,7 @@ struct drm_vblank_crtc {
 	/**
 	 * @count: Current software vblank counter.
 	 */
-	u32 count;
+	u64 count;
 	/**
 	 * @time: Vblank timestamp corresponding to @count.
 	 */
@@ -152,8 +156,8 @@ struct drm_vblank_crtc {
 };
 
 int drm_vblank_init(struct drm_device *dev, unsigned int num_crtcs);
-u32 drm_crtc_vblank_count(struct drm_crtc *crtc);
-u32 drm_crtc_vblank_count_and_time(struct drm_crtc *crtc,
+u64 drm_crtc_vblank_count(struct drm_crtc *crtc);
+u64 drm_crtc_vblank_count_and_time(struct drm_crtc *crtc,
 				   ktime_t *vblanktime);
 void drm_crtc_send_vblank_event(struct drm_crtc *crtc,
 			       struct drm_pending_vblank_event *e);

commit 67680d3c046450b3901aa4e5a9cf2f8fbd7ed9a2
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Oct 11 17:20:12 2017 +0200

    drm: vblank: use ktime_t instead of timeval
    
    The drm vblank handling uses 'timeval' to store timestamps in either
    monotonic or wall-clock time base. In either case, it reads the current
    time as a ktime_t in get_drm_timestamp() and converts it from there.
    
    This is a bit suspicious, as users of 'timeval' often suffer from
    the time_t overflow in y2038. I have gone through this code and
    found that it is unlikely to cause problems here:
    
    - The user space ABI does not use time_t or timeval, but uses
      'u32' and 'long' as the types. This means at least that rebuilding
      user programs against a new libc with 64-bit time_t does not
      change the ABI.
    
    - As of commit c61eef726a78 ("drm: add support for monotonic vblank
      timestamps") in linux-3.8, the monotonic timestamp is the default
      and can only get reverted to wall-clock through a module-parameter.
    
    - With the default monotonic timestamps, there is no problem at all.
    
    - The drm_wait_vblank_ioctl() interface is alway safe on 64-bit
      architectures, on 32-bit it might overflow the 'long' timestamps
      in 2038 with wall-clock timestamps.
    
    - The event handling uses 'u32' seconds, which overflow in 2106
      on both 32-bit and 64-bit machines, when wall-clock timestamps
      are used.
    
    - The effect of overflowing either of the two is only temporary
      (during the overflow, and is likely to keep working again
      afterwards. It is likely the same problem as observing a
      'settimeofday()' call, which was the reason for moving to the
      monotonic timestamps in the first place.
    
    Overall, this seems good enough, so my patch removes the use of
    'timeval' from the vblank handling altogether and uses ktime_t
    consistently, except for the part where we copy the data to user
    space structures in the existing format.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_vblank.h b/include/drm/drm_vblank.h
index 7fba9efe4951..6a58e2e91a0f 100644
--- a/include/drm/drm_vblank.h
+++ b/include/drm/drm_vblank.h
@@ -92,7 +92,7 @@ struct drm_vblank_crtc {
 	/**
 	 * @time: Vblank timestamp corresponding to @count.
 	 */
-	struct timeval time;
+	ktime_t time;
 
 	/**
 	 * @refcount: Number of users/waiters of the vblank interrupt. Only when
@@ -154,7 +154,7 @@ struct drm_vblank_crtc {
 int drm_vblank_init(struct drm_device *dev, unsigned int num_crtcs);
 u32 drm_crtc_vblank_count(struct drm_crtc *crtc);
 u32 drm_crtc_vblank_count_and_time(struct drm_crtc *crtc,
-				   struct timeval *vblanktime);
+				   ktime_t *vblanktime);
 void drm_crtc_send_vblank_event(struct drm_crtc *crtc,
 			       struct drm_pending_vblank_event *e);
 void drm_crtc_arm_vblank_event(struct drm_crtc *crtc,
@@ -172,7 +172,7 @@ u32 drm_crtc_accurate_vblank_count(struct drm_crtc *crtc);
 
 bool drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev,
 					   unsigned int pipe, int *max_error,
-					   struct timeval *vblank_time,
+					   ktime_t *vblank_time,
 					   bool in_vblank_irq);
 void drm_calc_timestamping_constants(struct drm_crtc *crtc,
 				     const struct drm_display_mode *mode);

commit b4164d66c4a2adf7beac7cd5e3f8cc5d06723d57
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jun 26 18:19:49 2017 +0200

    drm/vblank: Unexport drm_vblank_cleanup
    
    There's no reason for drivers to call this, and all the ones I've
    removed looked very fishy:
    - Proper quiescenting of the vblank machinery should be done by
      calling drm_crtc_vblank_off(), which is best done by shutting down
      the entire display engine with drm_atomic_helper_shutdown.
    
    - Releasing of allocated memory is done by the core already, it calls
      drm_vblank_cleanup as a fallback.
    
    - drm_vblank_cleanup also has checks for drivers which forget to clean
      up vblank interrupts.
    
    This essentially reverts
    
    commit e77cef9c2d87db835ad9d70cde4a9b00b0ca2262
    Author: Jerome Glisse <jglisse@redhat.com>
    Date:   Thu Jan 7 15:39:13 2010 +0100
    
        drm: Avoid calling vblank function is vblank wasn't initialized
    
    which was done to fix a bug in radeon code with msi interrupts:
    
    commit 003e69f9862bcda89a75c27750efdbc17ac02945
    Author: Jerome Glisse <jglisse@redhat.com>
    Date:   Thu Jan 7 15:39:14 2010 +0100
    
        drm/radeon/kms: Don't try to enable IRQ if we have no handler installed
    
    Afaict from digging around in old code, this was needed to avoid
    blowing up in the ums fallback, and has stopped serving it's purpose
    long ago - if irq init fails, the driver fails to load, and there's
    really no way to blow up anymore.
    
    Long story short, this was most likely a small ums compat/fallback
    hack that became a thing of it's own and got cargo-cult duplicated all
    over the drm codebase for essentially no gain at all.
    
    v2: Mention that for drivers with a ->release callback cleanup is
    handled by drm_dev_fini() (Thierry).
    
    Cc: Thierry Reding <treding@nvidia.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170626161949.25629-2-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_vblank.h b/include/drm/drm_vblank.h
index 4ceef128582f..7fba9efe4951 100644
--- a/include/drm/drm_vblank.h
+++ b/include/drm/drm_vblank.h
@@ -168,7 +168,6 @@ void drm_crtc_wait_one_vblank(struct drm_crtc *crtc);
 void drm_crtc_vblank_off(struct drm_crtc *crtc);
 void drm_crtc_vblank_reset(struct drm_crtc *crtc);
 void drm_crtc_vblank_on(struct drm_crtc *crtc);
-void drm_vblank_cleanup(struct drm_device *dev);
 u32 drm_crtc_accurate_vblank_count(struct drm_crtc *crtc);
 
 bool drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev,

commit ca814b25538a5b2c0a8de6665191725f41608f2c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed May 24 16:51:47 2017 +0200

    drm/vblank: Consistent drm_crtc_ prefix
    
    We use drm_crtc_ for all the new-style vblank functions which directly
    take a struct drm_crtc *. drm_accurate_vblank_count was the odd one
    out, correct this to appease my OCD.
    
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170524145212.27837-13-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_vblank.h b/include/drm/drm_vblank.h
index 4cde47332dfa..4ceef128582f 100644
--- a/include/drm/drm_vblank.h
+++ b/include/drm/drm_vblank.h
@@ -169,7 +169,7 @@ void drm_crtc_vblank_off(struct drm_crtc *crtc);
 void drm_crtc_vblank_reset(struct drm_crtc *crtc);
 void drm_crtc_vblank_on(struct drm_crtc *crtc);
 void drm_vblank_cleanup(struct drm_device *dev);
-u32 drm_accurate_vblank_count(struct drm_crtc *crtc);
+u32 drm_crtc_accurate_vblank_count(struct drm_crtc *crtc);
 
 bool drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev,
 					   unsigned int pipe, int *max_error,

commit 3ed4351a83ca05d3cd886ade6900be1067aa7903
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed May 31 11:21:46 2017 +0200

    drm: Extract drm_vblank.[hc]
    
    drm_irq.c contains both the irq helper library (optional) and the
    vblank support (optional, but part of the modeset uapi, and doesn't
    require the use of the irq helpers at all.
    
    Split this up for more clarity of the scope of the individual bits.
    
    v2: Move misplaced hunks to this patch (Stefan).
    
    Cc: Stefan Agner <stefan@agner.ch>
    Reviewed-by: Stefan Agner <stefan@agner.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170531092146.12528-1-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_vblank.h b/include/drm/drm_vblank.h
new file mode 100644
index 000000000000..4cde47332dfa
--- /dev/null
+++ b/include/drm/drm_vblank.h
@@ -0,0 +1,181 @@
+/*
+ * Copyright 2016 Intel Corp.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _DRM_VBLANK_H_
+#define _DRM_VBLANK_H_
+
+#include <linux/seqlock.h>
+#include <linux/idr.h>
+#include <linux/poll.h>
+
+#include <drm/drm_file.h>
+#include <drm/drm_modes.h>
+#include <uapi/drm/drm.h>
+
+struct drm_device;
+struct drm_crtc;
+
+/**
+ * struct drm_pending_vblank_event - pending vblank event tracking
+ */
+struct drm_pending_vblank_event {
+	/**
+	 * @base: Base structure for tracking pending DRM events.
+	 */
+	struct drm_pending_event base;
+	/**
+	 * @pipe: drm_crtc_index() of the &drm_crtc this event is for.
+	 */
+	unsigned int pipe;
+	/**
+	 * @event: Actual event which will be sent to userspace.
+	 */
+	struct drm_event_vblank event;
+};
+
+/**
+ * struct drm_vblank_crtc - vblank tracking for a CRTC
+ *
+ * This structure tracks the vblank state for one CRTC.
+ *
+ * Note that for historical reasons - the vblank handling code is still shared
+ * with legacy/non-kms drivers - this is a free-standing structure not directly
+ * connected to &struct drm_crtc. But all public interface functions are taking
+ * a &struct drm_crtc to hide this implementation detail.
+ */
+struct drm_vblank_crtc {
+	/**
+	 * @dev: Pointer to the &drm_device.
+	 */
+	struct drm_device *dev;
+	/**
+	 * @queue: Wait queue for vblank waiters.
+	 */
+	wait_queue_head_t queue;	/**< VBLANK wait queue */
+	/**
+	 * @disable_timer: Disable timer for the delayed vblank disabling
+	 * hysteresis logic. Vblank disabling is controlled through the
+	 * drm_vblank_offdelay module option and the setting of the
+	 * &drm_device.max_vblank_count value.
+	 */
+	struct timer_list disable_timer;
+
+	/**
+	 * @seqlock: Protect vblank count and time.
+	 */
+	seqlock_t seqlock;		/* protects vblank count and time */
+
+	/**
+	 * @count: Current software vblank counter.
+	 */
+	u32 count;
+	/**
+	 * @time: Vblank timestamp corresponding to @count.
+	 */
+	struct timeval time;
+
+	/**
+	 * @refcount: Number of users/waiters of the vblank interrupt. Only when
+	 * this refcount reaches 0 can the hardware interrupt be disabled using
+	 * @disable_timer.
+	 */
+	atomic_t refcount;		/* number of users of vblank interruptsper crtc */
+	/**
+	 * @last: Protected by &drm_device.vbl_lock, used for wraparound handling.
+	 */
+	u32 last;
+	/**
+	 * @inmodeset: Tracks whether the vblank is disabled due to a modeset.
+	 * For legacy driver bit 2 additionally tracks whether an additional
+	 * temporary vblank reference has been acquired to paper over the
+	 * hardware counter resetting/jumping. KMS drivers should instead just
+	 * call drm_crtc_vblank_off() and drm_crtc_vblank_on(), which explicitly
+	 * save and restore the vblank count.
+	 */
+	unsigned int inmodeset;		/* Display driver is setting mode */
+	/**
+	 * @pipe: drm_crtc_index() of the &drm_crtc corresponding to this
+	 * structure.
+	 */
+	unsigned int pipe;
+	/**
+	 * @framedur_ns: Frame/Field duration in ns, used by
+	 * drm_calc_vbltimestamp_from_scanoutpos() and computed by
+	 * drm_calc_timestamping_constants().
+	 */
+	int framedur_ns;
+	/**
+	 * @linedur_ns: Line duration in ns, used by
+	 * drm_calc_vbltimestamp_from_scanoutpos() and computed by
+	 * drm_calc_timestamping_constants().
+	 */
+	int linedur_ns;
+
+	/**
+	 * @hwmode:
+	 *
+	 * Cache of the current hardware display mode. Only valid when @enabled
+	 * is set. This is used by helpers like
+	 * drm_calc_vbltimestamp_from_scanoutpos(). We can't just access the
+	 * hardware mode by e.g. looking at &drm_crtc_state.adjusted_mode,
+	 * because that one is really hard to get from interrupt context.
+	 */
+	struct drm_display_mode hwmode;
+
+	/**
+	 * @enabled: Tracks the enabling state of the corresponding &drm_crtc to
+	 * avoid double-disabling and hence corrupting saved state. Needed by
+	 * drivers not using atomic KMS, since those might go through their CRTC
+	 * disabling functions multiple times.
+	 */
+	bool enabled;
+};
+
+int drm_vblank_init(struct drm_device *dev, unsigned int num_crtcs);
+u32 drm_crtc_vblank_count(struct drm_crtc *crtc);
+u32 drm_crtc_vblank_count_and_time(struct drm_crtc *crtc,
+				   struct timeval *vblanktime);
+void drm_crtc_send_vblank_event(struct drm_crtc *crtc,
+			       struct drm_pending_vblank_event *e);
+void drm_crtc_arm_vblank_event(struct drm_crtc *crtc,
+			      struct drm_pending_vblank_event *e);
+bool drm_handle_vblank(struct drm_device *dev, unsigned int pipe);
+bool drm_crtc_handle_vblank(struct drm_crtc *crtc);
+int drm_crtc_vblank_get(struct drm_crtc *crtc);
+void drm_crtc_vblank_put(struct drm_crtc *crtc);
+void drm_wait_one_vblank(struct drm_device *dev, unsigned int pipe);
+void drm_crtc_wait_one_vblank(struct drm_crtc *crtc);
+void drm_crtc_vblank_off(struct drm_crtc *crtc);
+void drm_crtc_vblank_reset(struct drm_crtc *crtc);
+void drm_crtc_vblank_on(struct drm_crtc *crtc);
+void drm_vblank_cleanup(struct drm_device *dev);
+u32 drm_accurate_vblank_count(struct drm_crtc *crtc);
+
+bool drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev,
+					   unsigned int pipe, int *max_error,
+					   struct timeval *vblank_time,
+					   bool in_vblank_irq);
+void drm_calc_timestamping_constants(struct drm_crtc *crtc,
+				     const struct drm_display_mode *mode);
+wait_queue_head_t *drm_crtc_vblank_waitqueue(struct drm_crtc *crtc);
+#endif
