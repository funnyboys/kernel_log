commit 74aae1c42f4a7f69934762f9e9f90a3ec335fef2
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Apr 3 15:57:47 2020 +0200

    drm/device: Deprecate dev_private harder
    
    We've had lots of conversions to embeddeding, but didn't stop using
    ->dev_private. Which defeats the point of this.
    
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200403135828.2542770-4-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_device.h b/include/drm/drm_device.h
index d39132b477dd..a55874db9dd4 100644
--- a/include/drm/drm_device.h
+++ b/include/drm/drm_device.h
@@ -88,9 +88,12 @@ struct drm_device {
 	/**
 	 * @dev_private:
 	 *
-	 * DRM driver private data. Instead of using this pointer it is
-	 * recommended that drivers use drm_dev_init() and embed struct
-	 * &drm_device in their larger per-device structure.
+	 * DRM driver private data. This is deprecated and should be left set to
+	 * NULL.
+	 *
+	 * Instead of using this pointer it is recommended that drivers use
+	 * drm_dev_init() and embed struct &drm_device in their larger
+	 * per-device structure.
 	 */
 	void *dev_private;
 

commit c6603c740e0e3492c9c95fdab833375bf7117b6b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Mar 24 13:45:40 2020 +0100

    drm: add managed resources tied to drm_device
    
    We have lots of these. And the cleanup code tends to be of dubious
    quality. The biggest wrong pattern is that developers use devm_, which
    ties the release action to the underlying struct device, whereas
    all the userspace visible stuff attached to a drm_device can long
    outlive that one (e.g. after a hotunplug while userspace has open
    files and mmap'ed buffers). Give people what they want, but with more
    correctness.
    
    Mostly copied from devres.c, with types adjusted to fit drm_device and
    a few simplifications - I didn't (yet) copy over everything. Since
    the types don't match code sharing looked like a hopeless endeavour.
    
    For now it's only super simplified, no groups, you can't remove
    actions (but kfree exists, we'll need that soon). Plus all specific to
    drm_device ofc, including the logging. Which I didn't bother to make
    compile-time optional, since none of the other drm logging is compile
    time optional either.
    
    One tricky bit here is the chicken&egg between allocating your
    drm_device structure and initiliazing it with drm_dev_init. For
    perfect onion unwinding we'd need to have the action to kfree the
    allocation registered before drm_dev_init registers any of its own
    release handlers. But drm_dev_init doesn't know where exactly the
    drm_device is emebedded into the overall structure, and by the time it
    returns it'll all be too late. And forcing drivers to be able clean up
    everything except the one kzalloc is silly.
    
    Work around this by having a very special final_kfree pointer. This
    also avoids troubles with the list head possibly disappearing from
    underneath us when we release all resources attached to the
    drm_device.
    
    v2: Do all the kerneldoc at the end, to avoid lots of fairly pointless
    shuffling while getting everything into shape.
    
    v3: Add static to add/del_dr (Neil)
    Move typo fix to the right patch (Neil)
    
    v4: Enforce contract for drmm_add_final_kfree:
    
    Use ksize() to check that the drm_device is indeed contained somewhere
    in the final kfree(). Because we need that or the entire managed
    release logic blows up in a pile of use-after-frees. Motivated by a
    discussion with Laurent.
    
    v5: Review from Laurent:
    - %zu instead of casting size_t
    - header guards
    - sorting of includes
    - guarding of data assignment if we didn't allocate it for a NULL
      pointer
    - delete spurious newline
    - cast void* data parameter correctly in ->release call, no idea how
      this even worked before
    
    v6: Review from Sam
    - Add the kerneldoc for the managed sub-struct back in, even if it
      doesn't show up in the generated html somehow.
    - Explain why __always_inline.
    - Fix bisectability around the final kfree() in drm_dev_relase(). This
      is just interim code which will disappear again.
    - Some whitespace polish.
    - Add debug output when drmm_add_action or drmm_kmalloc fail.
    
    v7: My bisectability fix wasn't up to par as noticed by smatch.
    
    v8: Remove unecessary {} around if else
    
    v9: Use kstrdup_const, which requires kfree_const and introducing a free_dr()
    helper (Thomas).
    
    v10: kfree_const goes boom on the plain "kmalloc" assignment, somehow
    we need to wrap that in kstrdup_const() too!! Also renumber revision
    log, I somehow reset it midway thruh.
    
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Thomas Zimmermann <tzimmermann@suse.de>
    Cc: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Neil Armstrong <narmstrong@baylibre.com
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200324124540.3227396-1-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_device.h b/include/drm/drm_device.h
index bb60a949f416..d39132b477dd 100644
--- a/include/drm/drm_device.h
+++ b/include/drm/drm_device.h
@@ -67,6 +67,21 @@ struct drm_device {
 	/** @dev: Device structure of bus-device */
 	struct device *dev;
 
+	/**
+	 * @managed:
+	 *
+	 * Managed resources linked to the lifetime of this &drm_device as
+	 * tracked by @ref.
+	 */
+	struct {
+		/** @managed.resources: managed resources list */
+		struct list_head resources;
+		/** @managed.final_kfree: pointer for final kfree() call */
+		void *final_kfree;
+		/** @managed.lock: protects @managed.resources */
+		spinlock_t lock;
+	} managed;
+
 	/** @driver: DRM driver managing the device */
 	struct drm_driver *driver;
 

commit 7e13ad896484a0165a68197a2e64091ea28c9602
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jan 24 13:01:07 2020 +0000

    drm: Avoid drm_global_mutex for simple inc/dec of dev->open_count
    
    Since drm_global_mutex is a true global mutex across devices, we don't
    want to acquire it unless absolutely necessary. For maintaining the
    device local open_count, we can use atomic operations on the counter
    itself, except when making the transition to/from 0. Here, we tackle the
    easy portion of delaying acquiring the drm_global_mutex for the final
    release by using atomic_dec_and_mutex_lock(), leaving the global
    serialisation across the device opens.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Thomas Hellström (VMware) <thomas_os@shipmail.org>
    Reviewed-by: Thomas Hellström <thellstrom@vmware.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200124130107.125404-1-chris@chris-wilson.co.uk

diff --git a/include/drm/drm_device.h b/include/drm/drm_device.h
index 1acfc3bbd3fb..bb60a949f416 100644
--- a/include/drm/drm_device.h
+++ b/include/drm/drm_device.h
@@ -144,7 +144,7 @@ struct drm_device {
 	 * Usage counter for outstanding files open,
 	 * protected by drm_global_mutex
 	 */
-	int open_count;
+	atomic_t open_count;
 
 	/** @filelist_mutex: Protects @filelist. */
 	struct mutex filelist_mutex;

commit 59f5989ad42b6edd089b47895986ef15259822dc
Author: Thomas Zimmermann <tzimmermann@suse.de>
Date:   Wed May 8 10:26:18 2019 +0200

    drm: Integrate VRAM MM into struct drm_device
    
    There's now a pointer to struct drm_vram_mm stored in struct drm_device.
    DRM drivers that use VRAM MM should use this field to refer to their
    instance of the data structure. Appropriate helpers are now provided as
    well.
    
    Adding struct drm_vram_mm to struct drm_device further avoids wrappers
    and boilerplate code in drivers. This patch implements default functions
    for callbacks in struct drm_driver and struct file_operations that use
    the struct drm_vram_mm stored in struct drm_device. Drivers that need to
    provide their own implementations can still do so.
    
    The patch also adds documentation for the VRAM helper library in general.
    
    v5:
            * set .llseek to no_llseek() from DRM_VRAM_MM_FILE_OPERATIONS
    v4:
            * cleanups from checkpatch.pl
            * document VRAM helper library
    
    Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
    Link: http://patchwork.freedesktop.org/patch/msgid/20190508082630.15116-9-tzimmermann@suse.de
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>

diff --git a/include/drm/drm_device.h b/include/drm/drm_device.h
index 7f9ef709b2b6..1acfc3bbd3fb 100644
--- a/include/drm/drm_device.h
+++ b/include/drm/drm_device.h
@@ -17,6 +17,7 @@ struct drm_vblank_crtc;
 struct drm_sg_mem;
 struct drm_local_map;
 struct drm_vma_offset_manager;
+struct drm_vram_mm;
 struct drm_fb_helper;
 
 struct inode;
@@ -286,6 +287,9 @@ struct drm_device {
 	/** @vma_offset_manager: GEM information */
 	struct drm_vma_offset_manager *vma_offset_manager;
 
+	/** @vram_mm: VRAM MM memory manager */
+	struct drm_vram_mm *vram_mm;
+
 	/**
 	 * @switch_power_state:
 	 *

commit 83c163f7eb5948051b6fcb084ab3b81880c147dd
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Apr 23 09:56:01 2019 +1000

    drm/legacy: place all drm legacy members under DRM_LEGACY.
    
    This places a bunch of the legacy members of drm_device into
    only being there when legacy is enabled.
    
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_device.h b/include/drm/drm_device.h
index d5e092dccf3e..7f9ef709b2b6 100644
--- a/include/drm/drm_device.h
+++ b/include/drm/drm_device.h
@@ -306,7 +306,7 @@ struct drm_device {
 
 	/* Everything below here is for legacy driver, never use! */
 	/* private: */
-
+#if IS_ENABLED(CONFIG_DRM_LEGACY)
 	/* Context handle management - linked list of context handles */
 	struct list_head ctxlist;
 
@@ -353,6 +353,7 @@ struct drm_device {
 
 	/* Scatter gather memory */
 	struct drm_sg_mem *sg;
+#endif
 };
 
 #endif

commit ed20151a7699bb2c77eba3610199789a126940c4
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Nov 27 20:20:04 2018 +0200

    drm/vblank: Allow dynamic per-crtc max_vblank_count
    
    On i965gm we need to adjust max_vblank_count dynamically
    depending on whether the TV encoder is used or not. To
    that end add a per-crtc max_vblank_count that takes
    precedence over its device wide counterpart. The driver
    can now call drm_crtc_set_max_vblank_count() to configure
    the per-crtc value before calling drm_vblank_on().
    
    Also looks like there was some discussion about exynos needing
    similar treatment.
    
    v2: Drop the extra max_vblank_count!=0 check for the
        WARN(last!=current), will take care of it in i915 code (Daniel)
        WARN_ON(!inmodeset) (Daniel)
        WARN_ON(dev->max_vblank_count)
        Pimp up the docs (Daniel)
    
    Cc: stable@vger.kernel.org
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181127182004.28885-1-ville.syrjala@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/drm/drm_device.h b/include/drm/drm_device.h
index a6f8e5abb66f..d5e092dccf3e 100644
--- a/include/drm/drm_device.h
+++ b/include/drm/drm_device.h
@@ -240,6 +240,12 @@ struct drm_device {
 	 * races and imprecision over longer time periods, hence exposing a
 	 * hardware vblank counter is always recommended.
 	 *
+	 * This is the statically configured device wide maximum. The driver
+	 * can instead choose to use a runtime configurable per-crtc value
+	 * &drm_vblank_crtc.max_vblank_count, in which case @max_vblank_count
+	 * must be left at zero. See drm_crtc_set_max_vblank_count() on how
+	 * to use the per-crtc value.
+	 *
 	 * If non-zero, &drm_crtc_funcs.get_vblank_counter must be set.
 	 */
 	u32 max_vblank_count;

commit 3214a16684468f5429469c3b59dc25b312b9d6cc
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jan 11 17:40:48 2019 +0100

    drm/doc: Polish kerneldoc for drm_device.h
    
    - Move all the legacy gunk at the bottom, and exclude it from
      kerneldoc.
    - Documentation for the remaining bits.
    
    v2: Fix typo (Sam).
    
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190111164048.29067-5-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_device.h b/include/drm/drm_device.h
index d7cedbac66a3..a6f8e5abb66f 100644
--- a/include/drm/drm_device.h
+++ b/include/drm/drm_device.h
@@ -69,7 +69,13 @@ struct drm_device {
 	/** @driver: DRM driver managing the device */
 	struct drm_driver *driver;
 
-	/** @dev_private: DRM driver private data */
+	/**
+	 * @dev_private:
+	 *
+	 * DRM driver private data. Instead of using this pointer it is
+	 * recommended that drivers use drm_dev_init() and embed struct
+	 * &drm_device in their larger per-device structure.
+	 */
 	void *dev_private;
 
 	/** @primary: Primary node */
@@ -78,6 +84,11 @@ struct drm_device {
 	/** @render: Render node */
 	struct drm_minor *render;
 
+	/**
+	 * @registered:
+	 *
+	 * Internally used by drm_dev_register() and drm_connector_register().
+	 */
 	bool registered;
 
 	/**
@@ -134,16 +145,13 @@ struct drm_device {
 	 */
 	int open_count;
 
-	/** @buf_lock: Lock for &buf_use and a few other things. */
-	spinlock_t buf_lock;
-
-	/** @buf_use: Usage counter for buffers in use -- cannot alloc */
-	int buf_use;
-
-	/** @buf_alloc: Buffer allocation in progress */
-	atomic_t buf_alloc;
-
+	/** @filelist_mutex: Protects @filelist. */
 	struct mutex filelist_mutex;
+	/**
+	 * @filelist:
+	 *
+	 * List of userspace clients, linked through &drm_file.lhead.
+	 */
 	struct list_head filelist;
 
 	/**
@@ -168,46 +176,6 @@ struct drm_device {
 	 */
 	struct list_head clientlist;
 
-	/** @maplist: Memory management - linked list of regions */
-	struct list_head maplist;
-
-	/** @map_hash: Memory management - user token hash table for maps */
-	struct drm_open_hash map_hash;
-
-	/**
-	 * @ctxlist:
-	 * Context handle management - linked list of context handles
-	 */
-	struct list_head ctxlist;
-
-	/**
-	 * @ctxlist_mutex:
-	 *
-	 * Context handle management - mutex for &ctxlist
-	 */
-	struct mutex ctxlist_mutex;
-
-	/**
-	 * @ctx_idr:
-	 * Context handle management
-	 */
-	struct idr ctx_idr;
-
-	/**
-	 * @vmalist:
-	 * Context handle management - list of vmas (for debugging)
-	 */
-	struct list_head vmalist;
-
-	/** @dma: Optional pointer for DMA support */
-	struct drm_device_dma *dma;
-
-	/** @context_flag: Context swapping flag */
-	__volatile__ long context_flag;
-
-	/** @last_context: Last current context */
-	int last_context;
-
 	/**
 	 * @irq_enabled:
 	 *
@@ -216,6 +184,10 @@ struct drm_device {
 	 * to true manually.
 	 */
 	bool irq_enabled;
+
+	/**
+	 * @irq: Used by the drm_irq_install() and drm_irq_unistall() helpers.
+	 */
 	int irq;
 
 	/**
@@ -249,6 +221,10 @@ struct drm_device {
 	 *  Protects vblank count and time updates during vblank enable/disable
 	 */
 	spinlock_t vblank_time_lock;
+	/**
+	 * @vbl_lock: Top-level vblank references lock, wraps the low-level
+	 * @vblank_time_lock.
+	 */
 	spinlock_t vbl_lock;
 
 	/**
@@ -264,14 +240,19 @@ struct drm_device {
 	 * races and imprecision over longer time periods, hence exposing a
 	 * hardware vblank counter is always recommended.
 	 *
-	 * If non-zeor, &drm_crtc_funcs.get_vblank_counter must be set.
+	 * If non-zero, &drm_crtc_funcs.get_vblank_counter must be set.
 	 */
-
-	/** @max_vblank_count: Size of vblank counter register */
 	u32 max_vblank_count;
 
 	/** @vblank_event_list: List of vblank events */
 	struct list_head vblank_event_list;
+
+	/**
+	 * @event_lock:
+	 *
+	 * Protects @vblank_event_list and event delivery in
+	 * general. See drm_send_event() and drm_send_event_locked().
+	 */
 	spinlock_t event_lock;
 
 	/** @agp: AGP data */
@@ -281,23 +262,12 @@ struct drm_device {
 	struct pci_dev *pdev;
 
 #ifdef __alpha__
+	/** @hose: PCI hose, only used on ALPHA platforms. */
 	struct pci_controller *hose;
 #endif
-
-	/** @sg: Scatter gather memory */
-	struct drm_sg_mem *sg;
-
 	/** @num_crtcs: Number of CRTCs on this device */
 	unsigned int num_crtcs;
 
-	struct {
-		int context;
-		struct drm_hw_lock *lock;
-	} sigdata;
-
-	struct drm_local_map *agp_buffer_map;
-	unsigned int agp_buffer_token;
-
 	/** @mode_config: Current mode config */
 	struct drm_mode_config mode_config;
 
@@ -327,6 +297,56 @@ struct drm_device {
 	 * Set by drm_fb_helper_init() and cleared by drm_fb_helper_fini().
 	 */
 	struct drm_fb_helper *fb_helper;
+
+	/* Everything below here is for legacy driver, never use! */
+	/* private: */
+
+	/* Context handle management - linked list of context handles */
+	struct list_head ctxlist;
+
+	/* Context handle management - mutex for &ctxlist */
+	struct mutex ctxlist_mutex;
+
+	/* Context handle management */
+	struct idr ctx_idr;
+
+	/* Memory management - linked list of regions */
+	struct list_head maplist;
+
+	/* Memory management - user token hash table for maps */
+	struct drm_open_hash map_hash;
+
+	/* Context handle management - list of vmas (for debugging) */
+	struct list_head vmalist;
+
+	/* Optional pointer for DMA support */
+	struct drm_device_dma *dma;
+
+	/* Context swapping flag */
+	__volatile__ long context_flag;
+
+	/* Last current context */
+	int last_context;
+
+	/* Lock for &buf_use and a few other things. */
+	spinlock_t buf_lock;
+
+	/* Usage counter for buffers in use -- cannot alloc */
+	int buf_use;
+
+	/* Buffer allocation in progress */
+	atomic_t buf_alloc;
+
+	struct {
+		int context;
+		struct drm_hw_lock *lock;
+	} sigdata;
+
+	struct drm_local_map *agp_buffer_map;
+	unsigned int agp_buffer_token;
+
+	/* Scatter gather memory */
+	struct drm_sg_mem *sg;
 };
 
 #endif

commit 7af78f406119366fb15a15823f720ebf06bb5652
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Tue Jan 8 20:29:29 2019 +0100

    drm: move DRM_SWITCH_POWER defines to drm_device.h
    
    Move DRM_SWITCH_POWER out of drmP.h to allow users
    to get rid of the drmP include.
    Moved to drm_device.h because drm_device.switch_power_state
    is the only user.
    
    Converted to enum and added sparse kerneldoc comments.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: Sean Paul <sean@poorly.run>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190108192939.15255-3-sam@ravnborg.org

diff --git a/include/drm/drm_device.h b/include/drm/drm_device.h
index 2b154ead9efc..d7cedbac66a3 100644
--- a/include/drm/drm_device.h
+++ b/include/drm/drm_device.h
@@ -24,6 +24,25 @@ struct inode;
 struct pci_dev;
 struct pci_controller;
 
+
+/**
+ * enum drm_switch_power - power state of drm device
+ */
+
+enum switch_power_state {
+	/** @DRM_SWITCH_POWER_ON: Power state is ON */
+	DRM_SWITCH_POWER_ON = 0,
+
+	/** @DRM_SWITCH_POWER_OFF: Power state is OFF */
+	DRM_SWITCH_POWER_OFF = 1,
+
+	/** @DRM_SWITCH_POWER_CHANGING: Power state is changing */
+	DRM_SWITCH_POWER_CHANGING = 2,
+
+	/** @DRM_SWITCH_POWER_DYNAMIC_OFF: Suspended */
+	DRM_SWITCH_POWER_DYNAMIC_OFF = 3,
+};
+
 /**
  * struct drm_device - DRM device structure
  *
@@ -291,7 +310,15 @@ struct drm_device {
 	/** @vma_offset_manager: GEM information */
 	struct drm_vma_offset_manager *vma_offset_manager;
 
-	int switch_power_state;
+	/**
+	 * @switch_power_state:
+	 *
+	 * Power state of the client.
+	 * Used by drivers supporting the switcheroo driver.
+	 * The state is maintained in the
+	 * &vga_switcheroo_client_ops.set_gpu_state callback
+	 */
+	enum switch_power_state switch_power_state;
 
 	/**
 	 * @fb_helper:

commit ac4f24c213b81ce668574cebaf3e1b2bc92fcff6
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Tue Jan 8 20:29:28 2019 +0100

    drm: drm_device.h: update comments to kernel-doc style
    
    Updated comment style to kernel-doc format in drm_device.h
    
    In struct drm_device there are 12 struct members without doc:
    - registered
    - filelist_mutex
    - filelist
    - irq
    - vbl_lock
    - event_lock
    - hose
    - sigdata
    - sigdata.context
    - sigdata.lock
    - agp_buffer_map
    - agp_buffer_token
    
    They all need proper documentation, a task left for someone
    that knows their usage.
    
    drm_device is not plugged into Documentation/gpu/drm-internals.rst
    as this would create a new load of warnings.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: Sean Paul <sean@poorly.run>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190108192939.15255-2-sam@ravnborg.org

diff --git a/include/drm/drm_device.h b/include/drm/drm_device.h
index 42411b3ea0c8..2b154ead9efc 100644
--- a/include/drm/drm_device.h
+++ b/include/drm/drm_device.h
@@ -25,24 +25,48 @@ struct pci_dev;
 struct pci_controller;
 
 /**
- * DRM device structure. This structure represent a complete card that
+ * struct drm_device - DRM device structure
+ *
+ * This structure represent a complete card that
  * may contain multiple heads.
  */
 struct drm_device {
-	struct list_head legacy_dev_list;/**< list of devices per driver for stealth attach cleanup */
-	int if_version;			/**< Highest interface version set */
-
-	/** \name Lifetime Management */
-	/*@{ */
-	struct kref ref;		/**< Object ref-count */
-	struct device *dev;		/**< Device structure of bus-device */
-	struct drm_driver *driver;	/**< DRM driver managing the device */
-	void *dev_private;		/**< DRM driver private data */
-	struct drm_minor *primary;		/**< Primary node */
-	struct drm_minor *render;		/**< Render node */
+	/**
+	 * @legacy_dev_list:
+	 *
+	 * List of devices per driver for stealth attach cleanup
+	 */
+	struct list_head legacy_dev_list;
+
+	/** @if_version: Highest interface version set */
+	int if_version;
+
+	/** @ref: Object ref-count */
+	struct kref ref;
+
+	/** @dev: Device structure of bus-device */
+	struct device *dev;
+
+	/** @driver: DRM driver managing the device */
+	struct drm_driver *driver;
+
+	/** @dev_private: DRM driver private data */
+	void *dev_private;
+
+	/** @primary: Primary node */
+	struct drm_minor *primary;
+
+	/** @render: Render node */
+	struct drm_minor *render;
+
 	bool registered;
 
-	/* currently active master for this device. Protected by master_mutex */
+	/**
+	 * @master:
+	 *
+	 * Currently active master for this device.
+	 * Protected by &master_mutex
+	 */
 	struct drm_master *master;
 
 	/**
@@ -63,23 +87,42 @@ struct drm_device {
 	 */
 	bool unplugged;
 
-	struct inode *anon_inode;		/**< inode for private address-space */
-	char *unique;				/**< unique name of the device */
-	/*@} */
+	/** @anon_inode: inode for private address-space */
+	struct inode *anon_inode;
+
+	/** @unique: Unique name of the device */
+	char *unique;
+
+	/**
+	 * @struct_mutex:
+	 *
+	 * Lock for others (not &drm_minor.master and &drm_file.is_master)
+	 */
+	struct mutex struct_mutex;
+
+	/**
+	 * @master_mutex:
+	 *
+	 * Lock for &drm_minor.master and &drm_file.is_master
+	 */
+	struct mutex master_mutex;
+
+	/**
+	 * @open_count:
+	 *
+	 * Usage counter for outstanding files open,
+	 * protected by drm_global_mutex
+	 */
+	int open_count;
+
+	/** @buf_lock: Lock for &buf_use and a few other things. */
+	spinlock_t buf_lock;
 
-	/** \name Locks */
-	/*@{ */
-	struct mutex struct_mutex;	/**< For others */
-	struct mutex master_mutex;      /**< For drm_minor::master and drm_file::is_master */
-	/*@} */
+	/** @buf_use: Usage counter for buffers in use -- cannot alloc */
+	int buf_use;
 
-	/** \name Usage Counters */
-	/*@{ */
-	int open_count;			/**< Outstanding files open, protected by drm_global_mutex. */
-	spinlock_t buf_lock;		/**< For drm_device::buf_use and a few other things. */
-	int buf_use;			/**< Buffers in use -- cannot alloc */
-	atomic_t buf_alloc;		/**< Buffer allocation in progress */
-	/*@} */
+	/** @buf_alloc: Buffer allocation in progress */
+	atomic_t buf_alloc;
 
 	struct mutex filelist_mutex;
 	struct list_head filelist;
@@ -87,51 +130,64 @@ struct drm_device {
 	/**
 	 * @filelist_internal:
 	 *
-	 * List of open DRM files for in-kernel clients. Protected by @filelist_mutex.
+	 * List of open DRM files for in-kernel clients.
+	 * Protected by &filelist_mutex.
 	 */
 	struct list_head filelist_internal;
 
 	/**
 	 * @clientlist_mutex:
 	 *
-	 * Protects @clientlist access.
+	 * Protects &clientlist access.
 	 */
 	struct mutex clientlist_mutex;
 
 	/**
 	 * @clientlist:
 	 *
-	 * List of in-kernel clients. Protected by @clientlist_mutex.
+	 * List of in-kernel clients. Protected by &clientlist_mutex.
 	 */
 	struct list_head clientlist;
 
-	/** \name Memory management */
-	/*@{ */
-	struct list_head maplist;	/**< Linked list of regions */
-	struct drm_open_hash map_hash;	/**< User token hash table for maps */
+	/** @maplist: Memory management - linked list of regions */
+	struct list_head maplist;
 
-	/** \name Context handle management */
-	/*@{ */
-	struct list_head ctxlist;	/**< Linked list of context handles */
-	struct mutex ctxlist_mutex;	/**< For ctxlist */
+	/** @map_hash: Memory management - user token hash table for maps */
+	struct drm_open_hash map_hash;
 
-	struct idr ctx_idr;
+	/**
+	 * @ctxlist:
+	 * Context handle management - linked list of context handles
+	 */
+	struct list_head ctxlist;
 
-	struct list_head vmalist;	/**< List of vmas (for debugging) */
+	/**
+	 * @ctxlist_mutex:
+	 *
+	 * Context handle management - mutex for &ctxlist
+	 */
+	struct mutex ctxlist_mutex;
 
-	/*@} */
+	/**
+	 * @ctx_idr:
+	 * Context handle management
+	 */
+	struct idr ctx_idr;
 
-	/** \name DMA support */
-	/*@{ */
-	struct drm_device_dma *dma;		/**< Optional pointer for DMA support */
-	/*@} */
+	/**
+	 * @vmalist:
+	 * Context handle management - list of vmas (for debugging)
+	 */
+	struct list_head vmalist;
+
+	/** @dma: Optional pointer for DMA support */
+	struct drm_device_dma *dma;
 
-	/** \name Context support */
-	/*@{ */
+	/** @context_flag: Context swapping flag */
+	__volatile__ long context_flag;
 
-	__volatile__ long context_flag;	/**< Context swapping flag */
-	int last_context;		/**< Last current context */
-	/*@} */
+	/** @last_context: Last current context */
+	int last_context;
 
 	/**
 	 * @irq_enabled:
@@ -168,7 +224,12 @@ struct drm_device {
 	 */
 	struct drm_vblank_crtc *vblank;
 
-	spinlock_t vblank_time_lock;    /**< Protects vblank count and time updates during vblank enable/disable */
+	/**
+	 * @vblank_time_lock:
+	 *
+	 *  Protects vblank count and time updates during vblank enable/disable
+	 */
+	spinlock_t vblank_time_lock;
 	spinlock_t vbl_lock;
 
 	/**
@@ -186,25 +247,29 @@ struct drm_device {
 	 *
 	 * If non-zeor, &drm_crtc_funcs.get_vblank_counter must be set.
 	 */
-	u32 max_vblank_count;           /**< size of vblank counter register */
 
-	/**
-	 * List of events
-	 */
+	/** @max_vblank_count: Size of vblank counter register */
+	u32 max_vblank_count;
+
+	/** @vblank_event_list: List of vblank events */
 	struct list_head vblank_event_list;
 	spinlock_t event_lock;
 
-	/*@} */
+	/** @agp: AGP data */
+	struct drm_agp_head *agp;
 
-	struct drm_agp_head *agp;	/**< AGP data */
+	/** @pdev: PCI device structure */
+	struct pci_dev *pdev;
 
-	struct pci_dev *pdev;		/**< PCI device structure */
 #ifdef __alpha__
 	struct pci_controller *hose;
 #endif
 
-	struct drm_sg_mem *sg;	/**< Scatter gather memory */
-	unsigned int num_crtcs;                  /**< Number of CRTCs on this device */
+	/** @sg: Scatter gather memory */
+	struct drm_sg_mem *sg;
+
+	/** @num_crtcs: Number of CRTCs on this device */
+	unsigned int num_crtcs;
 
 	struct {
 		int context;
@@ -214,14 +279,18 @@ struct drm_device {
 	struct drm_local_map *agp_buffer_map;
 	unsigned int agp_buffer_token;
 
-	struct drm_mode_config mode_config;	/**< Current mode config */
+	/** @mode_config: Current mode config */
+	struct drm_mode_config mode_config;
 
-	/** \name GEM information */
-	/*@{ */
+	/** @object_name_lock: GEM information */
 	struct mutex object_name_lock;
+
+	/** @object_name_idr: GEM information */
 	struct idr object_name_idr;
+
+	/** @vma_offset_manager: GEM information */
 	struct drm_vma_offset_manager *vma_offset_manager;
-	/*@} */
+
 	int switch_power_state;
 
 	/**

commit 18ace11f87e69454379a3a1247a657b70ca142fc
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Sep 13 16:16:21 2018 +0300

    drm: Introduce per-device driver_features
    
    We wish to control certain driver_features flags on a per-device basis
    while still sharing a single drm_driver instance across all the
    devices. To that end introduce device.driver_features. By default
    it will be set to ~0 to not impose any limits beyond
    driver.driver_features. Drivers can then clear specific flags
    in the per-device bitmask to limit the capabilities of the device.
    
    An alternative approach would be to copy the driver_features from
    the driver into the device in drm_dev_init(), however that would
    require verifying that no driver is currently changing
    driver.driver_features after drm_dev_init(). Hence the ~0 apporach
    was easier.
    
    Ideally we'd also make drm_driver const but there is plenty of code
    left that wants to mutate it (eg. various vfunc assignments). We'll
    need to fix all that up before we can make it const.
    
    And while at it fix up the type of the feature flag passed to
    drm_core_check_feature().
    
    v2: Streamline the && vs. & (Chris)
        s/int/u32/ in drm_core_check_feature() args
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180913131622.17690-1-ville.syrjala@linux.intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Michel Dänzer <michel.daenzer@amd.com>

diff --git a/include/drm/drm_device.h b/include/drm/drm_device.h
index f9c6e0e3aec7..42411b3ea0c8 100644
--- a/include/drm/drm_device.h
+++ b/include/drm/drm_device.h
@@ -45,6 +45,16 @@ struct drm_device {
 	/* currently active master for this device. Protected by master_mutex */
 	struct drm_master *master;
 
+	/**
+	 * @driver_features: per-device driver features
+	 *
+	 * Drivers can clear specific flags here to disallow
+	 * certain features on a per-device basis while still
+	 * sharing a single &struct drm_driver instance across
+	 * all devices.
+	 */
+	u32 driver_features;
+
 	/**
 	 * @unplugged:
 	 *

commit c76f0f7cb546b661b5e0ac769850a5c854927f65
Author: Noralf Trønnes <noralf@tronnes.org>
Date:   Tue Jul 3 18:03:47 2018 +0200

    drm: Begin an API for in-kernel clients
    
    This the beginning of an API for in-kernel clients.
    First out is a way to get a framebuffer backed by a dumb buffer.
    
    Only GEM drivers are supported.
    The original idea of using an exported dma-buf was dropped because it
    also creates an anonomous file descriptor which doesn't work when the
    buffer is created from a kernel thread. The easy way out is to use
    drm_driver.gem_prime_vmap to get the virtual address, which requires a
    GEM object. This excludes the vmwgfx driver which is the only non-GEM
    driver apart from the legacy ones. A solution for vmwgfx will have to be
    worked out later if it wants to support the client API which it probably
    will when we have a bootsplash client.
    
    Suggested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Noralf Trønnes <noralf@tronnes.org>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180703160354.59955-2-noralf@tronnes.org

diff --git a/include/drm/drm_device.h b/include/drm/drm_device.h
index 858ba19a3e29..f9c6e0e3aec7 100644
--- a/include/drm/drm_device.h
+++ b/include/drm/drm_device.h
@@ -74,6 +74,27 @@ struct drm_device {
 	struct mutex filelist_mutex;
 	struct list_head filelist;
 
+	/**
+	 * @filelist_internal:
+	 *
+	 * List of open DRM files for in-kernel clients. Protected by @filelist_mutex.
+	 */
+	struct list_head filelist_internal;
+
+	/**
+	 * @clientlist_mutex:
+	 *
+	 * Protects @clientlist access.
+	 */
+	struct mutex clientlist_mutex;
+
+	/**
+	 * @clientlist:
+	 *
+	 * List of in-kernel clients. Protected by @clientlist_mutex.
+	 */
+	struct list_head clientlist;
+
 	/** \name Memory management */
 	/*@{ */
 	struct list_head maplist;	/**< Linked list of regions */

commit 0d49f303e8a7006e0af3b58ed3809e1cad0900fb
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Apr 20 08:51:59 2018 +0200

    drm: remove all control node code
    
    With the ioctl and driver prep done, we can remove everything else.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Gustavo Padovan <gustavo@padovan.org>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: David Airlie <airlied@linux.ie>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180420065159.4531-4-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_device.h b/include/drm/drm_device.h
index 3a0eac2885b7..858ba19a3e29 100644
--- a/include/drm/drm_device.h
+++ b/include/drm/drm_device.h
@@ -38,7 +38,6 @@ struct drm_device {
 	struct device *dev;		/**< Device structure of bus-device */
 	struct drm_driver *driver;	/**< DRM driver managing the device */
 	void *dev_private;		/**< DRM driver private data */
-	struct drm_minor *control;		/**< Control node */
 	struct drm_minor *primary;		/**< Primary node */
 	struct drm_minor *render;		/**< Render node */
 	bool registered;

commit bee330f3d67273a68dcb99f59480d59553c008b2
Author: Noralf Trønnes <noralf@tronnes.org>
Date:   Wed Mar 28 10:38:35 2018 +0300

    drm: Use srcu to protect drm_device.unplugged
    
    Use srcu to protect drm_device.unplugged in a race free manner.
    Drivers can use drm_dev_enter()/drm_dev_exit() to protect and mark
    sections preventing access to device resources that are not available
    after the device is gone.
    
    Suggested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Noralf Trønnes <noralf@tronnes.org>
    Signed-off-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
    Reviewed-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
    Tested-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
    Cc: intel-gfx@lists.freedesktop.org
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/1522222715-11814-1-git-send-email-andr2000@gmail.com

diff --git a/include/drm/drm_device.h b/include/drm/drm_device.h
index 7c4fa32f3fc6..3a0eac2885b7 100644
--- a/include/drm/drm_device.h
+++ b/include/drm/drm_device.h
@@ -46,7 +46,14 @@ struct drm_device {
 	/* currently active master for this device. Protected by master_mutex */
 	struct drm_master *master;
 
-	atomic_t unplugged;			/**< Flag whether dev is dead */
+	/**
+	 * @unplugged:
+	 *
+	 * Flag to tell if the device has been unplugged.
+	 * See drm_dev_enter() and drm_dev_is_unplugged().
+	 */
+	bool unplugged;
+
 	struct inode *anon_inode;		/**< inode for private address-space */
 	char *unique;				/**< unique name of the device */
 	/*@} */

commit 29ad20b22c8f3ab35e91c2f68b4c7956cee30fd0
Author: Noralf Trønnes <noralf@tronnes.org>
Date:   Mon Oct 30 16:39:38 2017 +0100

    drm: Add drm_device->fb_helper pointer
    
    drm_fb_helper is *the* way of doing fbdev emulation so add a pointer to
    struct drm_device. This makes it possible to add callback helpers for
    .last_close and .output_poll_changed further reducing fbdev emulation
    footprint in drivers. The pointer is set by drm_fb_helper_init() and
    cleared by drm_fb_helper_fini().
    
    Signed-off-by: Noralf Trønnes <noralf@tronnes.org>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171030153951.56269-3-noralf@tronnes.org

diff --git a/include/drm/drm_device.h b/include/drm/drm_device.h
index e21af87a2f3c..7c4fa32f3fc6 100644
--- a/include/drm/drm_device.h
+++ b/include/drm/drm_device.h
@@ -17,6 +17,7 @@ struct drm_vblank_crtc;
 struct drm_sg_mem;
 struct drm_local_map;
 struct drm_vma_offset_manager;
+struct drm_fb_helper;
 
 struct inode;
 
@@ -185,6 +186,14 @@ struct drm_device {
 	struct drm_vma_offset_manager *vma_offset_manager;
 	/*@} */
 	int switch_power_state;
+
+	/**
+	 * @fb_helper:
+	 *
+	 * Pointer to the fbdev emulation structure.
+	 * Set by drm_fb_helper_init() and cleared by drm_fb_helper_fini().
+	 */
+	struct drm_fb_helper *fb_helper;
 };
 
 #endif

commit e4672e55d6f3428ae9f27542e05c891f2af71051
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Aug 2 13:56:01 2017 +0200

    drm: Extract drm_device.h
    
    I need this to untangle an include loop in the next patch.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170802115604.12734-2-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_device.h b/include/drm/drm_device.h
new file mode 100644
index 000000000000..e21af87a2f3c
--- /dev/null
+++ b/include/drm/drm_device.h
@@ -0,0 +1,190 @@
+#ifndef _DRM_DEVICE_H_
+#define _DRM_DEVICE_H_
+
+#include <linux/list.h>
+#include <linux/kref.h>
+#include <linux/mutex.h>
+#include <linux/idr.h>
+
+#include <drm/drm_hashtab.h>
+#include <drm/drm_mode_config.h>
+
+struct drm_driver;
+struct drm_minor;
+struct drm_master;
+struct drm_device_dma;
+struct drm_vblank_crtc;
+struct drm_sg_mem;
+struct drm_local_map;
+struct drm_vma_offset_manager;
+
+struct inode;
+
+struct pci_dev;
+struct pci_controller;
+
+/**
+ * DRM device structure. This structure represent a complete card that
+ * may contain multiple heads.
+ */
+struct drm_device {
+	struct list_head legacy_dev_list;/**< list of devices per driver for stealth attach cleanup */
+	int if_version;			/**< Highest interface version set */
+
+	/** \name Lifetime Management */
+	/*@{ */
+	struct kref ref;		/**< Object ref-count */
+	struct device *dev;		/**< Device structure of bus-device */
+	struct drm_driver *driver;	/**< DRM driver managing the device */
+	void *dev_private;		/**< DRM driver private data */
+	struct drm_minor *control;		/**< Control node */
+	struct drm_minor *primary;		/**< Primary node */
+	struct drm_minor *render;		/**< Render node */
+	bool registered;
+
+	/* currently active master for this device. Protected by master_mutex */
+	struct drm_master *master;
+
+	atomic_t unplugged;			/**< Flag whether dev is dead */
+	struct inode *anon_inode;		/**< inode for private address-space */
+	char *unique;				/**< unique name of the device */
+	/*@} */
+
+	/** \name Locks */
+	/*@{ */
+	struct mutex struct_mutex;	/**< For others */
+	struct mutex master_mutex;      /**< For drm_minor::master and drm_file::is_master */
+	/*@} */
+
+	/** \name Usage Counters */
+	/*@{ */
+	int open_count;			/**< Outstanding files open, protected by drm_global_mutex. */
+	spinlock_t buf_lock;		/**< For drm_device::buf_use and a few other things. */
+	int buf_use;			/**< Buffers in use -- cannot alloc */
+	atomic_t buf_alloc;		/**< Buffer allocation in progress */
+	/*@} */
+
+	struct mutex filelist_mutex;
+	struct list_head filelist;
+
+	/** \name Memory management */
+	/*@{ */
+	struct list_head maplist;	/**< Linked list of regions */
+	struct drm_open_hash map_hash;	/**< User token hash table for maps */
+
+	/** \name Context handle management */
+	/*@{ */
+	struct list_head ctxlist;	/**< Linked list of context handles */
+	struct mutex ctxlist_mutex;	/**< For ctxlist */
+
+	struct idr ctx_idr;
+
+	struct list_head vmalist;	/**< List of vmas (for debugging) */
+
+	/*@} */
+
+	/** \name DMA support */
+	/*@{ */
+	struct drm_device_dma *dma;		/**< Optional pointer for DMA support */
+	/*@} */
+
+	/** \name Context support */
+	/*@{ */
+
+	__volatile__ long context_flag;	/**< Context swapping flag */
+	int last_context;		/**< Last current context */
+	/*@} */
+
+	/**
+	 * @irq_enabled:
+	 *
+	 * Indicates that interrupt handling is enabled, specifically vblank
+	 * handling. Drivers which don't use drm_irq_install() need to set this
+	 * to true manually.
+	 */
+	bool irq_enabled;
+	int irq;
+
+	/**
+	 * @vblank_disable_immediate:
+	 *
+	 * If true, vblank interrupt will be disabled immediately when the
+	 * refcount drops to zero, as opposed to via the vblank disable
+	 * timer.
+	 *
+	 * This can be set to true it the hardware has a working vblank counter
+	 * with high-precision timestamping (otherwise there are races) and the
+	 * driver uses drm_crtc_vblank_on() and drm_crtc_vblank_off()
+	 * appropriately. See also @max_vblank_count and
+	 * &drm_crtc_funcs.get_vblank_counter.
+	 */
+	bool vblank_disable_immediate;
+
+	/**
+	 * @vblank:
+	 *
+	 * Array of vblank tracking structures, one per &struct drm_crtc. For
+	 * historical reasons (vblank support predates kernel modesetting) this
+	 * is free-standing and not part of &struct drm_crtc itself. It must be
+	 * initialized explicitly by calling drm_vblank_init().
+	 */
+	struct drm_vblank_crtc *vblank;
+
+	spinlock_t vblank_time_lock;    /**< Protects vblank count and time updates during vblank enable/disable */
+	spinlock_t vbl_lock;
+
+	/**
+	 * @max_vblank_count:
+	 *
+	 * Maximum value of the vblank registers. This value +1 will result in a
+	 * wrap-around of the vblank register. It is used by the vblank core to
+	 * handle wrap-arounds.
+	 *
+	 * If set to zero the vblank core will try to guess the elapsed vblanks
+	 * between times when the vblank interrupt is disabled through
+	 * high-precision timestamps. That approach is suffering from small
+	 * races and imprecision over longer time periods, hence exposing a
+	 * hardware vblank counter is always recommended.
+	 *
+	 * If non-zeor, &drm_crtc_funcs.get_vblank_counter must be set.
+	 */
+	u32 max_vblank_count;           /**< size of vblank counter register */
+
+	/**
+	 * List of events
+	 */
+	struct list_head vblank_event_list;
+	spinlock_t event_lock;
+
+	/*@} */
+
+	struct drm_agp_head *agp;	/**< AGP data */
+
+	struct pci_dev *pdev;		/**< PCI device structure */
+#ifdef __alpha__
+	struct pci_controller *hose;
+#endif
+
+	struct drm_sg_mem *sg;	/**< Scatter gather memory */
+	unsigned int num_crtcs;                  /**< Number of CRTCs on this device */
+
+	struct {
+		int context;
+		struct drm_hw_lock *lock;
+	} sigdata;
+
+	struct drm_local_map *agp_buffer_map;
+	unsigned int agp_buffer_token;
+
+	struct drm_mode_config mode_config;	/**< Current mode config */
+
+	/** \name GEM information */
+	/*@{ */
+	struct mutex object_name_lock;
+	struct idr object_name_idr;
+	struct drm_vma_offset_manager *vma_offset_manager;
+	/*@} */
+	int switch_power_state;
+};
+
+#endif
