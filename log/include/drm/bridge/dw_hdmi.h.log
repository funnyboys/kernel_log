commit f14d3f6c39f39acf0eec90f4dcf1105f7be1fc1b
Author: Neil Armstrong <narmstrong@baylibre.com>
Date:   Wed Mar 4 11:40:46 2020 +0100

    drm/bridge: synopsys: dw-hdmi: allow ycbcr420 modes for >= 0x200a
    
    Now the DW-HDMI Controller supports the HDMI2.0 modes, enable support
    for these modes in the connector if the platform supports them.
    We limit these modes to DW-HDMI IP version >= 0x200a which
    are designed to support HDMI2.0 display modes.
    
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Reviewed-by: Andrzej Hajda <a.hajda@samsung.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Jernej Å krabec <jernej.skrabec@siol.net>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200304104052.17196-6-narmstrong@baylibre.com

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index 9d4d5cc47969..0b34a12c4a1c 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -129,6 +129,7 @@ struct dw_hdmi_plat_data {
 	unsigned long input_bus_format;
 	unsigned long input_bus_encoding;
 	bool use_drm_infoframe;
+	bool ycbcr_420_allowed;
 
 	/* Vendor PHY support */
 	const struct dw_hdmi_phy_ops *phy_ops;

commit a6ed68d6468bd5a3da78a103344ded1435fed57a
Merge: 8c39f71ee201 acc61b892936
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 27 17:45:48 2019 -0800

    Merge tag 'drm-next-2019-11-27' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm updates from Dave Airlie:
     "Lots of stuff in here, though it hasn't been too insane this merge
      apart from dealing with the security fun.
    
      uapi:
       - export different colorspace properties on DP vs HDMI
       - new fourcc for ARM 16x16 block format
       - syncobj: allow querying last submitted timeline value
       - DRM_FORMAT_BIG_ENDIAN defined as unsigned
    
      core:
       - allow using gem vma manager in ttm
       - connector/encoder/bridge doc fixes
       - allow more than 3 encoders for a connector
       - displayport mst suspend/resume reprobing support
       - vram lazy unmapping, uniform vram mm and gem vram
       - edid cleanups + AVI informframe bar info
       - displayport helpers - dpcd parser added
    
      dp_cec:
       - Allow a connector to be associated with a cec device
    
      ttm:
       - pipelining with no_gpu_wait fix
       - always keep BOs on the LRU
    
      sched:
       - allow free_job routine to sleep
    
      i915:
       - Block userptr from mappable GTT
       - i915 perf uapi versioning
       - OA stream dynamic reconfiguration
       - make context persistence optional
       - introduce DRM_I915_UNSTABLE Kconfig
       - add fake lmem testing under unstable
       - BT.2020 support for DP MSA
       - struct mutex elimination
       - Tigerlake display/PLL/power management improvements
       - Jasper Lake PCH support
       - refactor PMU for multiple GPUs
       - Icelake firmware update
       - Split out vga + switcheroo code
    
      amdgpu:
       - implement dma-buf import/export without helpers
       - vega20 RAS enablement
       - DC i2c over aux fixes
       - renoir GPU reset
       - DC HDCP support
       - BACO support for CI/VI asics
       - MSI-X support
       - Arcturus EEPROM support
       - Arcturus VCN encode support
       - VCN dynamic powergating on RV/RV2
    
      amdkfd:
       - add navi12/14/renoir support to kfd
    
      radeon:
       - SI dpm fix ported from amdgpu
       - fix bad DMA on ppc platforms
    
      gma500:
       - memory leak fixes
    
      qxl:
       - convert to new gem mmap
    
      exynos:
       - build warning fix
    
      komeda:
       - add aclk sysfs attribute
    
      v3d:
       - userspace cleanup uapi change
    
      i810:
       - fix for underflow in dispatch ioctls
    
      ast:
       - refactor show_cursor
    
      mgag200:
       - refactor show_cursor
    
      arcgpu:
       - encoder finding improvements
    
      mediatek:
       - mipi_tx, dsi and partial crtc support for MT8183 SoC
       - rotation support
    
      meson:
       - add suspend/resume support
    
      omap:
       - misc refactors
    
      tegra:
       - DisplayPort support for Tegra 210, 186 and 194.
       - IOMMU-backed DMA API fixes
    
      panfrost:
       - fix lockdep issue
       - simplify devfreq integration
    
      rcar-du:
       - R8A774B1 SoC support
       - fixes for H2 ES2.0
    
      sun4i:
       - vcc-dsi regulator support
    
      virtio-gpu:
       - vmexit vs spinlock fix
       - move to gem shmem helpers
       - handle large command buffers with cma"
    
    * tag 'drm-next-2019-11-27' of git://anongit.freedesktop.org/drm/drm: (1855 commits)
      drm/amdgpu: invalidate mmhub semaphore workaround in gmc9/gmc10
      drm/amdgpu: initialize vm_inv_eng0_sem for gfxhub and mmhub
      drm/amd/amdgpu/sriov skip RLCG s/r list for arcturus VF.
      drm/amd/amdgpu/sriov temporarily skip ras,dtm,hdcp for arcturus VF
      drm/amdgpu/gfx10: re-init clear state buffer after gpu reset
      merge fix for "ftrace: Rework event_create_dir()"
      drm/amdgpu: Update Arcturus golden registers
      drm/amdgpu/gfx10: fix out-of-bound mqd_backup array access
      drm/amdgpu/gfx10: explicitly wait for cp idle after halt/unhalt
      Revert "drm/amd/display: enable S/G for RAVEN chip"
      drm/amdgpu: disable gfxoff on original raven
      drm/amdgpu: remove experimental flag for Navi14
      drm/amdgpu: disable gfxoff when using register read interface
      drm/amdgpu/powerplay: properly set PP_GFXOFF_MASK (v2)
      drm/amdgpu: fix bad DMA from INTERRUPT_CNTL2
      drm/radeon: fix bad DMA from INTERRUPT_CNTL2
      drm/amd/display: Fix debugfs on MST connectors
      drm/amdgpu/nv: add asic func for fetching vbios from rom directly
      drm/amdgpu: put flush_delayed_work at first
      drm/amdgpu/vcn2.5: fix the enc loop with hw fini
      ...

commit a9c82d63ca4819d3d03964dbf4aa427b36c5a67f
Author: Cheng-Yi Chiang <cychiang@chromium.org>
Date:   Mon Oct 28 15:19:25 2019 +0800

    drm: bridge: dw-hdmi: Report connector status using callback
    
    Allow codec driver register callback function for plug event.
    
    The callback registration flow:
    dw-hdmi <--- hw-hdmi-i2s-audio <--- hdmi-codec
    
    dw-hdmi-i2s-audio implements hook_plugged_cb op
    so codec driver can register the callback.
    
    dw-hdmi exports a function dw_hdmi_set_plugged_cb so platform device
    can register the callback.
    
    When connector plug/unplug event happens, report this event using the
    callback.
    
    Make sure that audio and drm are using the single source of truth for
    connector status.
    
    Signed-off-by: Cheng-Yi Chiang <cychiang@chromium.org>
    Link: https://lore.kernel.org/r/20191028071930.145899-2-cychiang@chromium.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index cf528c289857..9a0c8381a069 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -6,6 +6,8 @@
 #ifndef __DW_HDMI__
 #define __DW_HDMI__
 
+#include <sound/hdmi-codec.h>
+
 struct drm_connector;
 struct drm_display_mode;
 struct drm_encoder;
@@ -154,6 +156,8 @@ void dw_hdmi_resume(struct dw_hdmi *hdmi);
 
 void dw_hdmi_setup_rx_sense(struct dw_hdmi *hdmi, bool hpd, bool rx_sense);
 
+int dw_hdmi_set_plugged_cb(struct dw_hdmi *hdmi, hdmi_codec_plugged_cb fn,
+			   struct device *codec_dev);
 void dw_hdmi_set_sample_rate(struct dw_hdmi *hdmi, unsigned int rate);
 void dw_hdmi_set_channel_count(struct dw_hdmi *hdmi, unsigned int cnt);
 void dw_hdmi_set_channel_allocation(struct dw_hdmi *hdmi, unsigned int ca);

commit 7cea855922cb6a84d56ee8f12783f5b5e14c6129
Author: Jonas Karlman <jonas@kwiboo.se>
Date:   Mon Oct 7 19:21:48 2019 +0000

    drm/bridge: dw-hdmi: Add Dynamic Range and Mastering InfoFrame support
    
    Add support for configuring Dynamic Range and Mastering InfoFrame from
    the hdr_output_metadata connector property.
    
    This patch adds a use_drm_infoframe flag to dw_hdmi_plat_data that platform
    drivers use to signal when Dynamic Range and Mastering infoframes is supported.
    This flag is needed because Amlogic GXBB and GXL report same DW-HDMI version,
    and only GXL support DRM InfoFrame.
    
    These changes were based on work done by Zheng Yang <zhengyang@rock-chips.com>
    to support DRM InfoFrame on the Rockchip 4.4 BSP kernel at [1] and [2]
    
    [1] https://github.com/rockchip-linux/kernel/tree/develop-4.4
    [2] https://github.com/rockchip-linux/kernel/commit/d1943fde81ff41d7cca87f4a42f03992e90bddd5
    
    Cc: Zheng Yang <zhengyang@rock-chips.com>
    Signed-off-by: Jonas Karlman <jonas@kwiboo.se>
    Reviewed-by: Neil Armstrong <narmstrong@baylibre.com>
    Reviewed-by: Andrzej Hajda <a.hajda@samsung.com>
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/HE1PR06MB4011D7B916CBF8B740ACC45FAC9B0@HE1PR06MB4011.eurprd06.prod.outlook.com

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index 4b3e863c4f8a..fbf3812c4326 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -126,6 +126,7 @@ struct dw_hdmi_plat_data {
 					   const struct drm_display_mode *mode);
 	unsigned long input_bus_format;
 	unsigned long input_bus_encoding;
+	bool use_drm_infoframe;
 
 	/* Vendor PHY support */
 	const struct dw_hdmi_phy_ops *phy_ops;

commit 3250cdf938dce5447cf4f895bb3ec3b929a95e09
Author: Yakir Yang <ykk@rock-chips.com>
Date:   Wed Sep 11 16:26:46 2019 +0800

    drm: bridge/dw_hdmi: add audio sample channel status setting
    
    When transmitting IEC60985 linear PCM audio, we configure the
    Aduio Sample Channel Status information in the IEC60958 frame.
    The status bit is already available in iec.status of hdmi_codec_params.
    
    This fix the issue that audio does not come out on some monitors
    (e.g. LG 22CV241)
    
    Note that these registers are only for interfaces:
    I2S audio interface, General Purpose Audio (GPA), or AHB audio DMA
    (AHBAUDDMA).
    For S/PDIF interface this information comes from the stream.
    
    Currently this function dw_hdmi_set_channel_status is only called
    from dw-hdmi-i2s-audio in I2S setup.
    
    Signed-off-by: Yakir Yang <ykk@rock-chips.com>
    Signed-off-by: Cheng-Yi Chiang <cychiang@chromium.org>
    Reviewed-by: Jonas Karlman <jonas@kwiboo.se>
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190911082646.134347-1-cychiang@chromium.org

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index cf528c289857..4b3e863c4f8a 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -156,6 +156,7 @@ void dw_hdmi_setup_rx_sense(struct dw_hdmi *hdmi, bool hpd, bool rx_sense);
 
 void dw_hdmi_set_sample_rate(struct dw_hdmi *hdmi, unsigned int rate);
 void dw_hdmi_set_channel_count(struct dw_hdmi *hdmi, unsigned int cnt);
+void dw_hdmi_set_channel_status(struct dw_hdmi *hdmi, u8 *channel_status);
 void dw_hdmi_set_channel_allocation(struct dw_hdmi *hdmi, unsigned int ca);
 void dw_hdmi_audio_enable(struct dw_hdmi *hdmi);
 void dw_hdmi_audio_disable(struct dw_hdmi *hdmi);

commit 2a2a3d2ff799d62f25a9d222ad0fc73753c8a6c6
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Mon Aug 12 14:07:20 2019 +0200

    drm/bridge: dw-hdmi: move audio channel setup out of ahb
    
    Part of the channel count setup done in dw-hdmi ahb should
    actually be done whatever the interface providing the data.
    
    Let's move it to dw-hdmi driver instead.
    
    Reviewed-by: Jonas Karlman <jonas@kwiboo.se>
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Reviewed-by: Neil Armstrong <narmstrong@baylibre.com>
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190812120726.1528-3-jbrunet@baylibre.com

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index c402364aec0d..cf528c289857 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -155,6 +155,8 @@ void dw_hdmi_resume(struct dw_hdmi *hdmi);
 void dw_hdmi_setup_rx_sense(struct dw_hdmi *hdmi, bool hpd, bool rx_sense);
 
 void dw_hdmi_set_sample_rate(struct dw_hdmi *hdmi, unsigned int rate);
+void dw_hdmi_set_channel_count(struct dw_hdmi *hdmi, unsigned int cnt);
+void dw_hdmi_set_channel_allocation(struct dw_hdmi *hdmi, unsigned int ca);
 void dw_hdmi_audio_enable(struct dw_hdmi *hdmi);
 void dw_hdmi_audio_disable(struct dw_hdmi *hdmi);
 void dw_hdmi_set_high_tmds_clock_ratio(struct dw_hdmi *hdmi);

commit 52d2d44eee8091e740d0d275df1311fb8373c9a9
Merge: 2454fcea338a 9e0babf2c06c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jun 19 12:04:55 2019 +0200

    Merge v5.2-rc5 into drm-next
    
    Maarten needs -rc4 backmerged so he can pull in the fbcon notifier
    removal topic branch into drm-misc-next.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 99d02ed523dcaf5be0c6a778708df2779cfb3ed6
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue Jun 4 13:42:06 2019 -0700

    drm: bridge: dw-hdmi: Add hook for resume
    
    On Rockchip rk3288-based Chromebooks when you do a suspend/resume
    cycle:
    
    1. You lose the ability to detect an HDMI device being plugged in.
    
    2. If you're using the i2c bus built in to dw_hdmi then it stops
    working.
    
    Let's add a hook to the core dw-hdmi driver so that we can call it in
    dw_hdmi-rockchip in the next commit.
    
    NOTE: the exact set of steps I've done here in resume come from
    looking at the normal dw_hdmi init sequence in upstream Linux plus the
    sequence that we did in downstream Chrome OS 3.14.  Testing show that
    it seems to work, but if an extra step is needed or something here is
    not needed we could improve it.
    
    As part of this change we'll refactor the hardware init bits of
    dw-hdmi to happen all in one function and all at the same time.  Since
    we need to init the interrupt mutes before we request the IRQ, this
    means moving the hardware init earlier in the function, but there
    should be no problems with that.  Also as part of this we now
    unconditionally init the "i2c" parts of dw-hdmi, but again that ought
    to be fine.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190604204207.168085-1-dianders@chromium.org

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index 66e70770cce5..601243b56b69 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -154,6 +154,8 @@ struct dw_hdmi *dw_hdmi_bind(struct platform_device *pdev,
 			     struct drm_encoder *encoder,
 			     const struct dw_hdmi_plat_data *plat_data);
 
+void dw_hdmi_resume(struct dw_hdmi *hdmi);
+
 void dw_hdmi_setup_rx_sense(struct dw_hdmi *hdmi, bool hpd, bool rx_sense);
 
 void dw_hdmi_set_sample_rate(struct dw_hdmi *hdmi, unsigned int rate);

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index 66e70770cce5..b4ca970a5b75 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -1,10 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Copyright (C) 2011 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
  */
 
 #ifndef __DW_HDMI__

commit 264fce6cc2c1b06d14c345b0b31b281087feb99b
Author: Neil Armstrong <narmstrong@baylibre.com>
Date:   Fri Feb 1 12:07:46 2019 +0000

    drm/bridge: dw-hdmi: Add SCDC and TMDS Scrambling support
    
    Add support for SCDC Setup for TMDS Clock > 3.4GHz and enable TMDS
    Scrambling when supported or mandatory.
    
    This patch also adds an helper to setup the control bit to support
    the high TMDS Bit Period/TMDS Clock-Period Ratio as required with
    TMDS Clock > 3.4GHz for HDMI2.0 3840x2160@60/50 modes.
    
    These changes were based on work done by Huicong Xu <xhc@rock-chips.com>
    and Nickey Yang <nickey.yang@rock-chips.com> to support HDMI2.0 modes
    on the Rockchip 4.4 BSP kernel at [1]
    
    [1] https://github.com/rockchip-linux/kernel/tree/release-4.4
    
    Cc: Nickey Yang <nickey.yang@rock-chips.com>
    Cc: Huicong Xu <xhc@rock-chips.com>
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Reviewed-by: Andrzej Hajda <a.hajda@samsung.com>
    Signed-off-by: Andrzej Hajda <a.hajda@samsung.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/1549022873-40549-2-git-send-email-narmstrong@baylibre.com

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index 9f93895dde88..66e70770cce5 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -159,6 +159,7 @@ void dw_hdmi_setup_rx_sense(struct dw_hdmi *hdmi, bool hpd, bool rx_sense);
 void dw_hdmi_set_sample_rate(struct dw_hdmi *hdmi, unsigned int rate);
 void dw_hdmi_audio_enable(struct dw_hdmi *hdmi);
 void dw_hdmi_audio_disable(struct dw_hdmi *hdmi);
+void dw_hdmi_set_high_tmds_clock_ratio(struct dw_hdmi *hdmi);
 
 /* PHY configuration */
 void dw_hdmi_phy_i2c_set_addr(struct dw_hdmi *hdmi, u8 address);

commit 428747ae5cca2ca13983b768513f13cb8896de04
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Tue Jan 8 20:29:33 2019 +0100

    drm: remove include of drmP.h from bridge/dw_hdmi.h
    
    drmP.h is an relic from the days when there was a single header file.
    To enable the removal of drmP.h from all users drop include
    of drmP.h from bridge/dw_hdmi.h.
    
    A few files relied on the file included in drmP.h - add explicit
    include statements or forward declarations to these files.
    Build tested with arm and x86.
    
    v2:
    - prefer forward declarations when possible (Laurent Pinchart)
    - sort include files (Laurent Pinchart)
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Archit Taneja <architt@codeaurora.org>
    Cc: Andrzej Hajda <a.hajda@samsung.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Kieran Bingham <kieran.bingham+renesas@ideasonboard.com>
    Cc: Fabio Estevam <fabio.estevam@nxp.com>
    Cc: Neil Armstrong <narmstrong@baylibre.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190108192939.15255-7-sam@ravnborg.org

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index 9c56412bb2cf..9f93895dde88 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -10,9 +10,11 @@
 #ifndef __DW_HDMI__
 #define __DW_HDMI__
 
-#include <drm/drmP.h>
-
+struct drm_connector;
+struct drm_display_mode;
+struct drm_encoder;
 struct dw_hdmi;
+struct platform_device;
 
 /**
  * DOC: Supported input formats and encodings

commit 8faff37409fb47d86c839bb2da9f2cff371a3ef1
Author: Heiko Stuebner <heiko@sntech.de>
Date:   Wed Sep 12 14:47:35 2018 +0200

    drm/bridge: dw-hdmi: allow forcing vendor phy-type
    
    In some IP implementations the reading of the phy-type may be broken.
    One example are the Rockchip rk3228 and rk3328 socs that use a separate
    vendor-type phy from Innosilicon but still report the HDMI20_TX type.
    
    So allow the glue driver to force the vendor-phy for these cases.
    In the future it may be necessary to allow forcing other types, but
    for now we'll keep it simply to the case actually seen in the wild.
    
    changes in v3:
    - only allow forcing vendor type, as suggested by Laurent
    
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Tested-by: Robin Murphy <robin.murphy@arm.com>
    Reviewed-by: Andrzej Hajda <a.hajda@samsung.com>
    Reviewed-by: Zheng Yang <zhengyang@rock-chips.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180912124740.20343-2-heiko@sntech.de
    Link: https://patchwork.freedesktop.org/patch/msgid/20180912124740.20343-3-heiko@sntech.de

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index ccb5aa8468e0..9c56412bb2cf 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -133,6 +133,7 @@ struct dw_hdmi_plat_data {
 	const struct dw_hdmi_phy_ops *phy_ops;
 	const char *phy_name;
 	void *phy_data;
+	unsigned int phy_force_vendor;
 
 	/* Synopsys PHY support */
 	const struct dw_hdmi_mpll_config *mpll_cfg;

commit c32048d9e93a5ab925d745396c63e7b912147f0a
Author: Neil Armstrong <narmstrong@baylibre.com>
Date:   Wed May 30 11:43:58 2018 +0200

    drm/bridge/synopsys: dw-hdmi: fix dw_hdmi_setup_rx_sense
    
    The dw_hdmi_setup_rx_sense exported function should not use struct device
    to recover the dw-hdmi context using drvdata, but take struct dw_hdmi
    directly like other exported functions.
    
    This caused a regression using Meson DRM on S905X since v4.17-rc1 :
    
    Internal error: Oops: 96000007 [#1] PREEMPT SMP
    [...]
    CPU: 0 PID: 124 Comm: irq/32-dw_hdmi_ Not tainted 4.17.0-rc7 #2
    Hardware name: Libre Technology CC (DT)
    [...]
    pc : osq_lock+0x54/0x188
    lr : __mutex_lock.isra.0+0x74/0x530
    [...]
    Process irq/32-dw_hdmi_ (pid: 124, stack limit = 0x00000000adf418cb)
    Call trace:
      osq_lock+0x54/0x188
      __mutex_lock_slowpath+0x10/0x18
      mutex_lock+0x30/0x38
      __dw_hdmi_setup_rx_sense+0x28/0x98
      dw_hdmi_setup_rx_sense+0x10/0x18
      dw_hdmi_top_thread_irq+0x2c/0x50
      irq_thread_fn+0x28/0x68
      irq_thread+0x10c/0x1a0
      kthread+0x128/0x130
      ret_from_fork+0x10/0x18
     Code: 34000964 d00050a2 51000484 9135c042 (f864d844)
     ---[ end trace 945641e1fbbc07da ]---
     note: irq/32-dw_hdmi_[124] exited with preempt_count 1
     genirq: exiting task "irq/32-dw_hdmi_" (124) is an active IRQ thread (irq 32)
    
    Fixes: eea034af90c6 ("drm/bridge/synopsys: dw-hdmi: don't clobber drvdata")
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Tested-by: Koen Kooi <koen@dominion.thruhere.net>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/1527673438-20643-1-git-send-email-narmstrong@baylibre.com

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index dd2a8cf7d20b..ccb5aa8468e0 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -151,7 +151,7 @@ struct dw_hdmi *dw_hdmi_bind(struct platform_device *pdev,
 			     struct drm_encoder *encoder,
 			     const struct dw_hdmi_plat_data *plat_data);
 
-void dw_hdmi_setup_rx_sense(struct device *dev, bool hpd, bool rx_sense);
+void dw_hdmi_setup_rx_sense(struct dw_hdmi *hdmi, bool hpd, bool rx_sense);
 
 void dw_hdmi_set_sample_rate(struct dw_hdmi *hdmi, unsigned int rate);
 void dw_hdmi_audio_enable(struct dw_hdmi *hdmi);

commit eea034af90c64802fd747a9dc534c26a7ebe7754
Author: Jernej Skrabec <jernej.skrabec@siol.net>
Date:   Wed Feb 14 21:08:59 2018 +0100

    drm/bridge/synopsys: dw-hdmi: don't clobber drvdata
    
    dw_hdmi shouldn't set drvdata since some drivers might need to store
    it's own data there. Rework dw_hdmi in a way to return struct dw_hdmi
    instead to store it in drvdata. This way drivers are responsible to
    store and pass structure when needed.
    
    Idea was taken from the following commit:
    8242ecbd597d ("drm/bridge/synopsys: stop clobbering drvdata")
    
    Cc: p.zabel@pengutronix.de
    Cc: Laurent.pinchart@ideasonboard.com
    Cc: hjc@rock-chips.com
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180214200906.31509-6-jernej.skrabec@siol.net

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index f3f3f0e1b2d3..dd2a8cf7d20b 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -143,12 +143,13 @@ struct dw_hdmi_plat_data {
 			     unsigned long mpixelclock);
 };
 
-int dw_hdmi_probe(struct platform_device *pdev,
-		  const struct dw_hdmi_plat_data *plat_data);
-void dw_hdmi_remove(struct platform_device *pdev);
-void dw_hdmi_unbind(struct device *dev);
-int dw_hdmi_bind(struct platform_device *pdev, struct drm_encoder *encoder,
-		 const struct dw_hdmi_plat_data *plat_data);
+struct dw_hdmi *dw_hdmi_probe(struct platform_device *pdev,
+			      const struct dw_hdmi_plat_data *plat_data);
+void dw_hdmi_remove(struct dw_hdmi *hdmi);
+void dw_hdmi_unbind(struct dw_hdmi *hdmi);
+struct dw_hdmi *dw_hdmi_bind(struct platform_device *pdev,
+			     struct drm_encoder *encoder,
+			     const struct dw_hdmi_plat_data *plat_data);
 
 void dw_hdmi_setup_rx_sense(struct device *dev, bool hpd, bool rx_sense);
 

commit 5765916afa4e859b92457a4a14f82ef2a9876758
Author: Jernej Skrabec <jernej.skrabec@siol.net>
Date:   Wed Feb 14 21:08:58 2018 +0100

    drm/bridge/synopsys: dw-hdmi: Export some PHY related functions
    
    Parts of PHY code could be useful also for custom PHYs. For example,
    Allwinner A83T has custom PHY which is probably Synopsys gen2 PHY
    with few additional memory mapped registers, so most of the Synopsys PHY
    related code could be reused.
    
    Functions exported here are actually not specific to Synopsys PHYs but
    to DWC HDMI controller PHY interface. This means that even if the PHY is
    completely custom, i.e. not designed by Synopsys, exported functions can
    be useful.
    
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Reviewed-by: Neil Armstrong <narmstrong@baylibre.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180214200906.31509-5-jernej.skrabec@siol.net

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index 182f83283e24..f3f3f0e1b2d3 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -157,7 +157,18 @@ void dw_hdmi_audio_enable(struct dw_hdmi *hdmi);
 void dw_hdmi_audio_disable(struct dw_hdmi *hdmi);
 
 /* PHY configuration */
+void dw_hdmi_phy_i2c_set_addr(struct dw_hdmi *hdmi, u8 address);
 void dw_hdmi_phy_i2c_write(struct dw_hdmi *hdmi, unsigned short data,
 			   unsigned char addr);
 
+void dw_hdmi_phy_gen2_pddq(struct dw_hdmi *hdmi, u8 enable);
+void dw_hdmi_phy_gen2_txpwron(struct dw_hdmi *hdmi, u8 enable);
+void dw_hdmi_phy_reset(struct dw_hdmi *hdmi);
+
+enum drm_connector_status dw_hdmi_phy_read_hpd(struct dw_hdmi *hdmi,
+					       void *data);
+void dw_hdmi_phy_update_hpd(struct dw_hdmi *hdmi, void *data,
+			    bool force, bool disabled, bool rxsense);
+void dw_hdmi_phy_setup_hpd(struct dw_hdmi *hdmi, void *data);
+
 #endif /* __IMX_HDMI_H__ */

commit 38cb266ad1a24e037220dc563ab46364595b17b6
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Fri Jun 23 14:00:13 2017 -0600

    DRM: Fix an incorrectly formatted table
    
    The "supported input formats" table in dw_hdmi.h was incorrectly formatted,
    using "+" signs where "|" needs to be.  That, in turn, causes the PDF build
    to fail.
    
    Fixes: def23aa7e982 ("drm: bridge: dw-hdmi: Switch to V4L bus format and encodings")
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170623140013.0703107a@lwn.net

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index 4c8d4c81a0e8..182f83283e24 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -22,56 +22,56 @@ struct dw_hdmi;
  * 48bit bus.
  *
  * +----------------------+----------------------------------+------------------------------+
- * + Format Name          + Format Code                      + Encodings                    +
+ * | Format Name          | Format Code                      | Encodings                    |
  * +----------------------+----------------------------------+------------------------------+
- * + RGB 4:4:4 8bit       + ``MEDIA_BUS_FMT_RGB888_1X24``    + ``V4L2_YCBCR_ENC_DEFAULT``   +
+ * | RGB 4:4:4 8bit       | ``MEDIA_BUS_FMT_RGB888_1X24``    | ``V4L2_YCBCR_ENC_DEFAULT``   |
  * +----------------------+----------------------------------+------------------------------+
- * + RGB 4:4:4 10bits     + ``MEDIA_BUS_FMT_RGB101010_1X30`` + ``V4L2_YCBCR_ENC_DEFAULT``   +
+ * | RGB 4:4:4 10bits     | ``MEDIA_BUS_FMT_RGB101010_1X30`` | ``V4L2_YCBCR_ENC_DEFAULT``   |
  * +----------------------+----------------------------------+------------------------------+
- * + RGB 4:4:4 12bits     + ``MEDIA_BUS_FMT_RGB121212_1X36`` + ``V4L2_YCBCR_ENC_DEFAULT``   +
+ * | RGB 4:4:4 12bits     | ``MEDIA_BUS_FMT_RGB121212_1X36`` | ``V4L2_YCBCR_ENC_DEFAULT``   |
  * +----------------------+----------------------------------+------------------------------+
- * + RGB 4:4:4 16bits     + ``MEDIA_BUS_FMT_RGB161616_1X48`` + ``V4L2_YCBCR_ENC_DEFAULT``   +
+ * | RGB 4:4:4 16bits     | ``MEDIA_BUS_FMT_RGB161616_1X48`` | ``V4L2_YCBCR_ENC_DEFAULT``   |
  * +----------------------+----------------------------------+------------------------------+
- * + YCbCr 4:4:4 8bit     + ``MEDIA_BUS_FMT_YUV8_1X24``      + ``V4L2_YCBCR_ENC_601``       +
- * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
- * +                      +                                  + or ``V4L2_YCBCR_ENC_XV601``  +
- * +                      +                                  + or ``V4L2_YCBCR_ENC_XV709``  +
+ * | YCbCr 4:4:4 8bit     | ``MEDIA_BUS_FMT_YUV8_1X24``      | ``V4L2_YCBCR_ENC_601``       |
+ * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
+ * |                      |                                  | or ``V4L2_YCBCR_ENC_XV601``  |
+ * |                      |                                  | or ``V4L2_YCBCR_ENC_XV709``  |
  * +----------------------+----------------------------------+------------------------------+
- * + YCbCr 4:4:4 10bits   + ``MEDIA_BUS_FMT_YUV10_1X30``     + ``V4L2_YCBCR_ENC_601``       +
- * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
- * +                      +                                  + or ``V4L2_YCBCR_ENC_XV601``  +
- * +                      +                                  + or ``V4L2_YCBCR_ENC_XV709``  +
+ * | YCbCr 4:4:4 10bits   | ``MEDIA_BUS_FMT_YUV10_1X30``     | ``V4L2_YCBCR_ENC_601``       |
+ * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
+ * |                      |                                  | or ``V4L2_YCBCR_ENC_XV601``  |
+ * |                      |                                  | or ``V4L2_YCBCR_ENC_XV709``  |
  * +----------------------+----------------------------------+------------------------------+
- * + YCbCr 4:4:4 12bits   + ``MEDIA_BUS_FMT_YUV12_1X36``     + ``V4L2_YCBCR_ENC_601``       +
- * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
- * +                      +                                  + or ``V4L2_YCBCR_ENC_XV601``  +
- * +                      +                                  + or ``V4L2_YCBCR_ENC_XV709``  +
+ * | YCbCr 4:4:4 12bits   | ``MEDIA_BUS_FMT_YUV12_1X36``     | ``V4L2_YCBCR_ENC_601``       |
+ * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
+ * |                      |                                  | or ``V4L2_YCBCR_ENC_XV601``  |
+ * |                      |                                  | or ``V4L2_YCBCR_ENC_XV709``  |
  * +----------------------+----------------------------------+------------------------------+
- * + YCbCr 4:4:4 16bits   + ``MEDIA_BUS_FMT_YUV16_1X48``     + ``V4L2_YCBCR_ENC_601``       +
- * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
- * +                      +                                  + or ``V4L2_YCBCR_ENC_XV601``  +
- * +                      +                                  + or ``V4L2_YCBCR_ENC_XV709``  +
+ * | YCbCr 4:4:4 16bits   | ``MEDIA_BUS_FMT_YUV16_1X48``     | ``V4L2_YCBCR_ENC_601``       |
+ * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
+ * |                      |                                  | or ``V4L2_YCBCR_ENC_XV601``  |
+ * |                      |                                  | or ``V4L2_YCBCR_ENC_XV709``  |
  * +----------------------+----------------------------------+------------------------------+
- * + YCbCr 4:2:2 8bit     + ``MEDIA_BUS_FMT_UYVY8_1X16``     + ``V4L2_YCBCR_ENC_601``       +
- * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * | YCbCr 4:2:2 8bit     | ``MEDIA_BUS_FMT_UYVY8_1X16``     | ``V4L2_YCBCR_ENC_601``       |
+ * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
  * +----------------------+----------------------------------+------------------------------+
- * + YCbCr 4:2:2 10bits   + ``MEDIA_BUS_FMT_UYVY10_1X20``    + ``V4L2_YCBCR_ENC_601``       +
- * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * | YCbCr 4:2:2 10bits   | ``MEDIA_BUS_FMT_UYVY10_1X20``    | ``V4L2_YCBCR_ENC_601``       |
+ * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
  * +----------------------+----------------------------------+------------------------------+
- * + YCbCr 4:2:2 12bits   + ``MEDIA_BUS_FMT_UYVY12_1X24``    + ``V4L2_YCBCR_ENC_601``       +
- * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * | YCbCr 4:2:2 12bits   | ``MEDIA_BUS_FMT_UYVY12_1X24``    | ``V4L2_YCBCR_ENC_601``       |
+ * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
  * +----------------------+----------------------------------+------------------------------+
- * + YCbCr 4:2:0 8bit     + ``MEDIA_BUS_FMT_UYYVYY8_0_5X24`` + ``V4L2_YCBCR_ENC_601``       +
- * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * | YCbCr 4:2:0 8bit     | ``MEDIA_BUS_FMT_UYYVYY8_0_5X24`` | ``V4L2_YCBCR_ENC_601``       |
+ * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
  * +----------------------+----------------------------------+------------------------------+
- * + YCbCr 4:2:0 10bits   + ``MEDIA_BUS_FMT_UYYVYY10_0_5X30``+ ``V4L2_YCBCR_ENC_601``       +
- * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * | YCbCr 4:2:0 10bits   | ``MEDIA_BUS_FMT_UYYVYY10_0_5X30``| ``V4L2_YCBCR_ENC_601``       |
+ * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
  * +----------------------+----------------------------------+------------------------------+
- * + YCbCr 4:2:0 12bits   + ``MEDIA_BUS_FMT_UYYVYY12_0_5X36``+ ``V4L2_YCBCR_ENC_601``       +
- * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * | YCbCr 4:2:0 12bits   | ``MEDIA_BUS_FMT_UYYVYY12_0_5X36``| ``V4L2_YCBCR_ENC_601``       |
+ * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
  * +----------------------+----------------------------------+------------------------------+
- * + YCbCr 4:2:0 16bits   + ``MEDIA_BUS_FMT_UYYVYY16_0_5X48``+ ``V4L2_YCBCR_ENC_601``       +
- * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * | YCbCr 4:2:0 16bits   | ``MEDIA_BUS_FMT_UYYVYY16_0_5X48``| ``V4L2_YCBCR_ENC_601``       |
+ * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
  * +----------------------+----------------------------------+------------------------------+
  */
 

commit b0febde779fd5d2e3e6f83843a828726117fe0a7
Author: Jose Abreu <Jose.Abreu@synopsys.com>
Date:   Thu May 25 15:19:19 2017 +0100

    drm/bridge/synopsys: dw-hdmi: Use bridge->mode_valid() callback
    
    Now that we have a callback to check if bridge supports a given mode
    we can use it in Synopsys Designware HDMI bridge so that we restrict
    the number of probbed modes to the ones we can actually display.
    
    Also, there is no need to use mode_fixup() callback as mode_valid()
    will handle the mode validation.
    
    NOTE: I also had to change the pdata declaration of mode_valid
    custom callback so that the passed modes are const. I also changed
    in the platforms I found. Not even compiled it though.
    
    Signed-off-by: Jose Abreu <joabreu@synopsys.com>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: Carlos Palminha <palminha@synopsys.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Archit Taneja <architt@codeaurora.org>
    Cc: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Laurent Pinchart <Laurent.pinchart@ideasonboard.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: Carlo Caione <carlo@caione.org>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Mark Yao <mark.yao@rock-chips.com>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/3d8d449e4d13d2535fa292c75f5fa931de4a4fa8.1495720737.git.joabreu@synopsys.com

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index ed599bea3f6c..4c8d4c81a0e8 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -125,7 +125,7 @@ struct dw_hdmi_phy_ops {
 struct dw_hdmi_plat_data {
 	struct regmap *regm;
 	enum drm_mode_status (*mode_valid)(struct drm_connector *connector,
-					   struct drm_display_mode *mode);
+					   const struct drm_display_mode *mode);
 	unsigned long input_bus_format;
 	unsigned long input_bus_encoding;
 

commit 386d3299ef7298a3bc57e2ff3498ce41ac7f6184
Author: Neil Armstrong <narmstrong@baylibre.com>
Date:   Tue Apr 4 14:31:59 2017 +0200

    drm: bridge: dw-hdmi: Move HPD handling to PHY operations
    
    The HDMI TX controller support HPD and RXSENSE signaling from the PHY
    via it's STAT0 PHY interface, but some vendor PHYs can manage these
    signals independently from the controller, thus these STAT0 handling
    should be moved to PHY specific operations and become optional.
    
    The existing STAT0 HPD and RXSENSE handling code is refactored into
    a supplementaty set of default PHY operations that are used automatically
    when the platform glue doesn't provide its own operations.
    
    Reviewed-by: Jose Abreu <joabreu@synopsys.com>
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1491309119-24220-2-git-send-email-narmstrong@baylibre.com

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index 5d6b92c6c0bc..ed599bea3f6c 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -117,6 +117,9 @@ struct dw_hdmi_phy_ops {
 		    struct drm_display_mode *mode);
 	void (*disable)(struct dw_hdmi *hdmi, void *data);
 	enum drm_connector_status (*read_hpd)(struct dw_hdmi *hdmi, void *data);
+	void (*update_hpd)(struct dw_hdmi *hdmi, void *data,
+			   bool force, bool disabled, bool rxsense);
+	void (*setup_hpd)(struct dw_hdmi *hdmi, void *data);
 };
 
 struct dw_hdmi_plat_data {
@@ -147,6 +150,8 @@ void dw_hdmi_unbind(struct device *dev);
 int dw_hdmi_bind(struct platform_device *pdev, struct drm_encoder *encoder,
 		 const struct dw_hdmi_plat_data *plat_data);
 
+void dw_hdmi_setup_rx_sense(struct device *dev, bool hpd, bool rx_sense);
+
 void dw_hdmi_set_sample_rate(struct dw_hdmi *hdmi, unsigned int rate);
 void dw_hdmi_audio_enable(struct dw_hdmi *hdmi);
 void dw_hdmi_audio_disable(struct dw_hdmi *hdmi);

commit def23aa7e9821a3dfe3fb7b139dd0229a89fdeb0
Author: Neil Armstrong <narmstrong@baylibre.com>
Date:   Tue Apr 4 14:31:57 2017 +0200

    drm: bridge: dw-hdmi: Switch to V4L bus format and encodings
    
    Switch code to use the newly introduced V4L bus formats IDs instead of custom
    defines. Also use the V4L encoding defines.
    
    Some display pipelines can only provide non-RBG input pixels to the HDMI TX
    Controller, this patch takes the pixel format from the plat_data if provided.
    
    Reviewed-by: Jose Abreu <joabreu@synopsys.com>
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index bcceee8114a4..5d6b92c6c0bc 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -14,6 +14,67 @@
 
 struct dw_hdmi;
 
+/**
+ * DOC: Supported input formats and encodings
+ *
+ * Depending on the Hardware configuration of the Controller IP, it supports
+ * a subset of the following input formats and encodings on its internal
+ * 48bit bus.
+ *
+ * +----------------------+----------------------------------+------------------------------+
+ * + Format Name          + Format Code                      + Encodings                    +
+ * +----------------------+----------------------------------+------------------------------+
+ * + RGB 4:4:4 8bit       + ``MEDIA_BUS_FMT_RGB888_1X24``    + ``V4L2_YCBCR_ENC_DEFAULT``   +
+ * +----------------------+----------------------------------+------------------------------+
+ * + RGB 4:4:4 10bits     + ``MEDIA_BUS_FMT_RGB101010_1X30`` + ``V4L2_YCBCR_ENC_DEFAULT``   +
+ * +----------------------+----------------------------------+------------------------------+
+ * + RGB 4:4:4 12bits     + ``MEDIA_BUS_FMT_RGB121212_1X36`` + ``V4L2_YCBCR_ENC_DEFAULT``   +
+ * +----------------------+----------------------------------+------------------------------+
+ * + RGB 4:4:4 16bits     + ``MEDIA_BUS_FMT_RGB161616_1X48`` + ``V4L2_YCBCR_ENC_DEFAULT``   +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:4:4 8bit     + ``MEDIA_BUS_FMT_YUV8_1X24``      + ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_XV601``  +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_XV709``  +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:4:4 10bits   + ``MEDIA_BUS_FMT_YUV10_1X30``     + ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_XV601``  +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_XV709``  +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:4:4 12bits   + ``MEDIA_BUS_FMT_YUV12_1X36``     + ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_XV601``  +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_XV709``  +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:4:4 16bits   + ``MEDIA_BUS_FMT_YUV16_1X48``     + ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_XV601``  +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_XV709``  +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:2:2 8bit     + ``MEDIA_BUS_FMT_UYVY8_1X16``     + ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:2:2 10bits   + ``MEDIA_BUS_FMT_UYVY10_1X20``    + ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:2:2 12bits   + ``MEDIA_BUS_FMT_UYVY12_1X24``    + ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:2:0 8bit     + ``MEDIA_BUS_FMT_UYYVYY8_0_5X24`` + ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:2:0 10bits   + ``MEDIA_BUS_FMT_UYYVYY10_0_5X30``+ ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:2:0 12bits   + ``MEDIA_BUS_FMT_UYYVYY12_0_5X36``+ ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:2:0 16bits   + ``MEDIA_BUS_FMT_UYYVYY16_0_5X48``+ ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +----------------------+----------------------------------+------------------------------+
+ */
+
 enum {
 	DW_HDMI_RES_8,
 	DW_HDMI_RES_10,
@@ -62,6 +123,8 @@ struct dw_hdmi_plat_data {
 	struct regmap *regm;
 	enum drm_mode_status (*mode_valid)(struct drm_connector *connector,
 					   struct drm_display_mode *mode);
+	unsigned long input_bus_format;
+	unsigned long input_bus_encoding;
 
 	/* Vendor PHY support */
 	const struct dw_hdmi_phy_ops *phy_ops;

commit 80e2f97968b537fc9c1789fce1b7f61609a5aae4
Author: Neil Armstrong <narmstrong@baylibre.com>
Date:   Fri Mar 3 19:20:06 2017 +0200

    drm: bridge: dw-hdmi: Switch to regmap for register access
    
    The Synopsys Designware HDMI TX Controller does not enforce register
    access on platforms instanciating it. The current driver supports two
    different types of memory-mapped flat register access, but in order to
    support the Amlogic Meson SoCs integration, and provide a more generic
    way to handle all sorts of register mapping, switch the register access
    to use the regmap infrastructure.
    
    In the case of registers that are not flat memory-mapped or do not
    conform to the current driver implementation, a regmap struct can be
    given in the plat_data and be used at probe or bind.
    
    Since the AHB audio driver is only available with direct memory access,
    only allow the I2S audio driver to be registered is directly
    memory-mapped.
    
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Tested-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Tested-by: Neil Armstrong <narmstrong@baylibre.com>
    Reviewed-by: Jose Abreu <Jose.Abreu@synopsys.com>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170303172007.26541-10-laurent.pinchart+renesas@ideasonboard.com

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index 545f04fae3b6..bcceee8114a4 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -59,6 +59,7 @@ struct dw_hdmi_phy_ops {
 };
 
 struct dw_hdmi_plat_data {
+	struct regmap *regm;
 	enum drm_mode_status (*mode_valid)(struct drm_connector *connector,
 					   struct drm_display_mode *mode);
 

commit 2e6777e8d5dd883b983c8de8797ff92bcb158f7c
Author: Kieran Bingham <kieran.bingham+renesas@ideasonboard.com>
Date:   Fri Mar 3 19:20:05 2017 +0200

    drm: bridge: dw-hdmi: Remove device type from platform data
    
    The device type isn't used anymore now that workarounds and PHY-specific
    operations are performed based on version information read at runtime.
    Remove it.
    
    Signed-off-by: Kieran Bingham <kieran.bingham+renesas@ideasonboard.com>
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Tested-by: Neil Armstrong <narmstrong@baylibre.com>
    Reviewed-by: Jose Abreu <joabreu@synopsys.com>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170303172007.26541-9-laurent.pinchart+renesas@ideasonboard.com

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index dd330259a3dc..545f04fae3b6 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -21,12 +21,6 @@ enum {
 	DW_HDMI_RES_MAX,
 };
 
-enum dw_hdmi_devtype {
-	IMX6Q_HDMI,
-	IMX6DL_HDMI,
-	RK3288_HDMI,
-};
-
 enum dw_hdmi_phy_type {
 	DW_HDMI_PHY_DWC_HDMI_TX_PHY = 0x00,
 	DW_HDMI_PHY_DWC_MHL_PHY_HEAC = 0xb2,
@@ -65,7 +59,6 @@ struct dw_hdmi_phy_ops {
 };
 
 struct dw_hdmi_plat_data {
-	enum dw_hdmi_devtype dev_type;
 	enum drm_mode_status (*mode_valid)(struct drm_connector *connector,
 					   struct drm_display_mode *mode);
 

commit 2ef9dfedefd60a12d2b02b1ee0a42be3506c43f2
Author: Kieran Bingham <kieran.bingham+renesas@ideasonboard.com>
Date:   Fri Mar 3 19:20:04 2017 +0200

    drm: bridge: dw-hdmi: Add support for custom PHY configuration
    
    The DWC HDMI TX controller interfaces with a companion PHY. While
    Synopsys provides multiple standard PHYs, SoC vendors can also integrate
    a custom PHY.
    
    Modularize PHY configuration to support vendor PHYs through platform
    data. The existing PHY configuration code was originally written to
    support the DWC HDMI 3D TX PHY, and seems to be compatible with the DWC
    MLP PHY. The HDMI 2.0 PHY will require a separate configuration
    function.
    
    Signed-off-by: Kieran Bingham <kieran.bingham+renesas@ideasonboard.com>
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Tested-by: Neil Armstrong <narmstrong@baylibre.com>
    Reviewed-by: Jose Abreu <Jose.Abreu@synopsys.com>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170303172007.26541-8-laurent.pinchart+renesas@ideasonboard.com

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index 0f583ca7e66e..dd330259a3dc 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -78,6 +78,9 @@ struct dw_hdmi_plat_data {
 	const struct dw_hdmi_mpll_config *mpll_cfg;
 	const struct dw_hdmi_curr_ctrl *cur_ctr;
 	const struct dw_hdmi_phy_config *phy_config;
+	int (*configure_phy)(struct dw_hdmi *hdmi,
+			     const struct dw_hdmi_plat_data *pdata,
+			     unsigned long mpixelclock);
 };
 
 int dw_hdmi_probe(struct platform_device *pdev,
@@ -91,4 +94,8 @@ void dw_hdmi_set_sample_rate(struct dw_hdmi *hdmi, unsigned int rate);
 void dw_hdmi_audio_enable(struct dw_hdmi *hdmi);
 void dw_hdmi_audio_disable(struct dw_hdmi *hdmi);
 
+/* PHY configuration */
+void dw_hdmi_phy_i2c_write(struct dw_hdmi *hdmi, unsigned short data,
+			   unsigned char addr);
+
 #endif /* __IMX_HDMI_H__ */

commit f1585f6e29f5aba34e2cd6e3db9f0dd33b046809
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Mar 6 01:36:15 2017 +0200

    drm: bridge: dw-hdmi: Create PHY operations
    
    The HDMI TX controller support different PHYs whose programming
    interface can vary significantly, especially with vendor PHYs that are
    not provided by Synopsys. To support them, create a PHY operation
    structure that can be provided by the platform glue layer. The existing
    PHY handling code (limited to Synopsys PHY support) is refactored into a
    set of default PHY operations that are used automatically when the
    platform glue doesn't provide its own operations.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Tested-by: Neil Armstrong <narmstrong@baylibre.com>
    Reviewed-by: Jose Abreu <joabreu@synopsys.com>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170305233615.11993-1-laurent.pinchart+renesas@ideasonboard.com

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index b080a171a23f..0f583ca7e66e 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -57,13 +57,27 @@ struct dw_hdmi_phy_config {
 	u16 vlev_ctr;   /* voltage level control */
 };
 
+struct dw_hdmi_phy_ops {
+	int (*init)(struct dw_hdmi *hdmi, void *data,
+		    struct drm_display_mode *mode);
+	void (*disable)(struct dw_hdmi *hdmi, void *data);
+	enum drm_connector_status (*read_hpd)(struct dw_hdmi *hdmi, void *data);
+};
+
 struct dw_hdmi_plat_data {
 	enum dw_hdmi_devtype dev_type;
+	enum drm_mode_status (*mode_valid)(struct drm_connector *connector,
+					   struct drm_display_mode *mode);
+
+	/* Vendor PHY support */
+	const struct dw_hdmi_phy_ops *phy_ops;
+	const char *phy_name;
+	void *phy_data;
+
+	/* Synopsys PHY support */
 	const struct dw_hdmi_mpll_config *mpll_cfg;
 	const struct dw_hdmi_curr_ctrl *cur_ctr;
 	const struct dw_hdmi_phy_config *phy_config;
-	enum drm_mode_status (*mode_valid)(struct drm_connector *connector,
-					   struct drm_display_mode *mode);
 };
 
 int dw_hdmi_probe(struct platform_device *pdev,

commit faba6c3cff177689aec132291b1cf537831d9a2e
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Tue Jan 17 10:29:06 2017 +0200

    drm: bridge: dw-hdmi: Detect PHY type at runtime
    
    Detect the PHY type and use it to handle the PHY type-specific SVSRET
    signal.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170117082910.27023-17-laurent.pinchart+renesas@ideasonboard.com

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index 3bb22a849830..b080a171a23f 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -27,6 +27,16 @@ enum dw_hdmi_devtype {
 	RK3288_HDMI,
 };
 
+enum dw_hdmi_phy_type {
+	DW_HDMI_PHY_DWC_HDMI_TX_PHY = 0x00,
+	DW_HDMI_PHY_DWC_MHL_PHY_HEAC = 0xb2,
+	DW_HDMI_PHY_DWC_MHL_PHY = 0xc2,
+	DW_HDMI_PHY_DWC_HDMI_3D_TX_PHY_HEAC = 0xe2,
+	DW_HDMI_PHY_DWC_HDMI_3D_TX_PHY = 0xf2,
+	DW_HDMI_PHY_DWC_HDMI20_TX_PHY = 0xf3,
+	DW_HDMI_PHY_VENDOR_PHY = 0xfe,
+};
+
 struct dw_hdmi_mpll_config {
 	unsigned long mpixelclock;
 	struct {

commit 69497eb9234eb34994b9a0d2f2c17c4c09f2e969
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Tue Jan 17 10:29:00 2017 +0200

    drm: bridge: dw-hdmi: Implement DRM bridge registration
    
    As an option for drivers not based on the component framework, register
    the bridge with the DRM core with the DRM bridge API. Existing drivers
    based on dw_hdmi_bind() and dw_hdmi_unbind() are not affected as those
    functions are preserved with their current behaviour.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Reviewed-by: Jose Abreu <joabreu@synopsys.com>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170117082910.27023-11-laurent.pinchart+renesas@ideasonboard.com

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index 94ff6edd070b..3bb22a849830 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -56,6 +56,9 @@ struct dw_hdmi_plat_data {
 					   struct drm_display_mode *mode);
 };
 
+int dw_hdmi_probe(struct platform_device *pdev,
+		  const struct dw_hdmi_plat_data *plat_data);
+void dw_hdmi_remove(struct platform_device *pdev);
 void dw_hdmi_unbind(struct device *dev);
 int dw_hdmi_bind(struct platform_device *pdev, struct drm_encoder *encoder,
 		 const struct dw_hdmi_plat_data *plat_data);

commit c608119dfdde9710e4bd068d632beb68bb3517db
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Tue Jan 17 10:28:57 2017 +0200

    drm: bridge: dw-hdmi: Move IRQ and IO resource allocation to common code
    
    There's no need to duplicate identical code in multiple drivers (two at
    the moment, one more to come soon). Move it to the dw-hdmi core where it
    can be shared. If resource allocation ever becomes device-specific later
    we'll always have the option of splitting it out again.
    
    While it at pass the platform device to the bind function to avoid
    having to cast struct device to struct platform_device.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Reviewed-by: Jose Abreu <joabreu@synopsys.com>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170117082910.27023-8-laurent.pinchart+renesas@ideasonboard.com

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index 11edda631a9d..94ff6edd070b 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -57,8 +57,7 @@ struct dw_hdmi_plat_data {
 };
 
 void dw_hdmi_unbind(struct device *dev);
-int dw_hdmi_bind(struct device *dev, struct drm_encoder *encoder,
-		 struct resource *iores, int irq,
+int dw_hdmi_bind(struct platform_device *pdev, struct drm_encoder *encoder,
 		 const struct dw_hdmi_plat_data *plat_data);
 
 void dw_hdmi_set_sample_rate(struct dw_hdmi *hdmi, unsigned int rate);

commit ecaa98f1e6f7ed3f79def1861f21ff2eac82b8e9
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Tue Jan 17 10:28:52 2017 +0200

    drm: bridge: dw-hdmi: Remove unneeded arguments to bind/unbind functions
    
    The master argument isn't used. The data argument, a void pointer, is
    used by the bind function only where it's cast to a drm_device pointer,
    which can easily be obtained from the encoder argument instead. Remove
    them.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Reviewed-by: Jose Abreu <joabreu@synopsys.com>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170117082910.27023-3-laurent.pinchart+renesas@ideasonboard.com

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index bae79f3c4d28..11edda631a9d 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -56,9 +56,8 @@ struct dw_hdmi_plat_data {
 					   struct drm_display_mode *mode);
 };
 
-void dw_hdmi_unbind(struct device *dev, struct device *master, void *data);
-int dw_hdmi_bind(struct device *dev, struct device *master,
-		 void *data, struct drm_encoder *encoder,
+void dw_hdmi_unbind(struct device *dev);
+int dw_hdmi_bind(struct device *dev, struct drm_encoder *encoder,
 		 struct resource *iores, int irq,
 		 const struct dw_hdmi_plat_data *plat_data);
 

commit b90120a9660884b8f11bbb9904fbaa4c12d17e0a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Mar 27 12:59:58 2015 +0000

    drm: bridge/dw_hdmi: introduce interfaces to enable and disable audio
    
    iMX6 devices suffer from an errata (ERR005174) where the audio FIFO can
    be emptied while it is partially full, resulting in misalignment of the
    audio samples.
    
    To prevent this, the errata workaround recommends writing N as zero
    until the audio FIFO has been loaded by DMA.  Writing N=0 prevents the
    HDMI bridge from reading from the audio FIFO, effectively disabling
    audio.
    
    This means we need to provide the audio driver with a pair of functions
    to enable/disable audio.  These are dw_hdmi_audio_enable() and
    dw_hdmi_audio_disable().
    
    A spinlock is introduced to ensure that setting the CTS/N values can't
    race, ensuring that the audio driver calling the enable/disable
    functions (which are called in an atomic context) can't race with a
    modeset.
    
    Tested-by: Yakir Yang <ykk@rock-chips.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index 763af51e1d60..bae79f3c4d28 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -63,5 +63,7 @@ int dw_hdmi_bind(struct device *dev, struct device *master,
 		 const struct dw_hdmi_plat_data *plat_data);
 
 void dw_hdmi_set_sample_rate(struct dw_hdmi *hdmi, unsigned int rate);
+void dw_hdmi_audio_enable(struct dw_hdmi *hdmi);
+void dw_hdmi_audio_disable(struct dw_hdmi *hdmi);
 
 #endif /* __IMX_HDMI_H__ */

commit b5814fff27c6d0212b86306bdd01fe3aea99cabb
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Mar 27 12:50:58 2015 +0000

    drm: bridge/dw_hdmi: introduce interface to setting sample rate
    
    Introduce dw_hdmi_set_sample_rate(), which allows us to configure the
    audio sample rate, setting the CTS/N values appropriately.
    
    Tested-by: Yakir Yang <ykk@rock-chips.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index de13bfc35634..763af51e1d60 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -12,6 +12,8 @@
 
 #include <drm/drmP.h>
 
+struct dw_hdmi;
+
 enum {
 	DW_HDMI_RES_8,
 	DW_HDMI_RES_10,
@@ -59,4 +61,7 @@ int dw_hdmi_bind(struct device *dev, struct device *master,
 		 void *data, struct drm_encoder *encoder,
 		 struct resource *iores, int irq,
 		 const struct dw_hdmi_plat_data *plat_data);
+
+void dw_hdmi_set_sample_rate(struct dw_hdmi *hdmi, unsigned int rate);
+
 #endif /* __IMX_HDMI_H__ */

commit 034705a48bcae9d51661c461b7dd21e0d5b85afc
Author: Yakir Yang <ykk@rock-chips.com>
Date:   Tue Mar 31 23:56:10 2015 -0400

    drm: bridge/dw_hdmi: separate VLEVCTRL settting into platform driver
    
    Because of iMX6 & Rockchip have differnet mpll config parameter,
    the VLEVCTRL parameter would be different. In this case we should
    separate VLEVCTRL setting from the common dw_hdmi driver, config
    this parameter in platform driver(dw_hdmi-imx and dw_hdmi-rockchip)
    
    Signed-off-by: Yakir Yang <ykk@rock-chips.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index 5a4f49005169..de13bfc35634 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -38,17 +38,18 @@ struct dw_hdmi_curr_ctrl {
 	u16 curr[DW_HDMI_RES_MAX];
 };
 
-struct dw_hdmi_sym_term {
+struct dw_hdmi_phy_config {
 	unsigned long mpixelclock;
 	u16 sym_ctr;    /*clock symbol and transmitter control*/
 	u16 term;       /*transmission termination value*/
+	u16 vlev_ctr;   /* voltage level control */
 };
 
 struct dw_hdmi_plat_data {
 	enum dw_hdmi_devtype dev_type;
 	const struct dw_hdmi_mpll_config *mpll_cfg;
 	const struct dw_hdmi_curr_ctrl *cur_ctr;
-	const struct dw_hdmi_sym_term *sym_term;
+	const struct dw_hdmi_phy_config *phy_config;
 	enum drm_mode_status (*mode_valid)(struct drm_connector *connector,
 					   struct drm_display_mode *mode);
 };

commit 12b9f204e804b2a6c65a6662b1fbe2449bca677f
Author: Andy Yan <andy.yan@rock-chips.com>
Date:   Wed Jan 7 15:48:27 2015 +0800

    drm: bridge/dw_hdmi: add rockchip rk3288 support
    
    Rockchip RK3288 hdmi is compatible with dw_hdmi
    
    Signed-off-by: Andy Yan <andy.yan@rock-chips.com>
    Tested-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index b64e58a92057..5a4f49005169 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -22,6 +22,7 @@ enum {
 enum dw_hdmi_devtype {
 	IMX6Q_HDMI,
 	IMX6DL_HDMI,
+	RK3288_HDMI,
 };
 
 struct dw_hdmi_mpll_config {

commit b21f4b658df885068c65852ef3d9d2f4f2821b03
Author: Andy Yan <andy.yan@rock-chips.com>
Date:   Fri Dec 5 14:26:31 2014 +0800

    drm: imx: imx-hdmi: move imx-hdmi to bridge/dw_hdmi
    
    the original imx hdmi driver is under drm/imx/,
    which depends on imx-drm, so move the imx hdmi
    driver out to drm/bridge and rename it to dw_hdmi
    
    Signed-off-by: Andy Yan <andy.yan@rock-chips.com>
    Tested-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
new file mode 100644
index 000000000000..b64e58a92057
--- /dev/null
+++ b/include/drm/bridge/dw_hdmi.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __DW_HDMI__
+#define __DW_HDMI__
+
+#include <drm/drmP.h>
+
+enum {
+	DW_HDMI_RES_8,
+	DW_HDMI_RES_10,
+	DW_HDMI_RES_12,
+	DW_HDMI_RES_MAX,
+};
+
+enum dw_hdmi_devtype {
+	IMX6Q_HDMI,
+	IMX6DL_HDMI,
+};
+
+struct dw_hdmi_mpll_config {
+	unsigned long mpixelclock;
+	struct {
+		u16 cpce;
+		u16 gmp;
+	} res[DW_HDMI_RES_MAX];
+};
+
+struct dw_hdmi_curr_ctrl {
+	unsigned long mpixelclock;
+	u16 curr[DW_HDMI_RES_MAX];
+};
+
+struct dw_hdmi_sym_term {
+	unsigned long mpixelclock;
+	u16 sym_ctr;    /*clock symbol and transmitter control*/
+	u16 term;       /*transmission termination value*/
+};
+
+struct dw_hdmi_plat_data {
+	enum dw_hdmi_devtype dev_type;
+	const struct dw_hdmi_mpll_config *mpll_cfg;
+	const struct dw_hdmi_curr_ctrl *cur_ctr;
+	const struct dw_hdmi_sym_term *sym_term;
+	enum drm_mode_status (*mode_valid)(struct drm_connector *connector,
+					   struct drm_display_mode *mode);
+};
+
+void dw_hdmi_unbind(struct device *dev, struct device *master, void *data);
+int dw_hdmi_bind(struct device *dev, struct device *master,
+		 void *data, struct drm_encoder *encoder,
+		 struct resource *iores, int irq,
+		 const struct dw_hdmi_plat_data *plat_data);
+#endif /* __IMX_HDMI_H__ */
