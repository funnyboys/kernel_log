commit a012024571d98e2e4bf29a9168fb7ddc44b7ab86
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Wed Apr 18 14:51:21 2018 +0200

    drm/crc: Only report a single overflow when a CRC fd is opened
    
    This reduces the amount of spam when you debug a CRC reading
    program.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    [mlankhorst: Change bool overflow to was_overflow (Ville)]
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180418125121.72081-1-maarten.lankhorst@linux.intel.com

diff --git a/include/drm/drm_debugfs_crc.h b/include/drm/drm_debugfs_crc.h
index 7d63b1d4adb9..b225eeb30d05 100644
--- a/include/drm/drm_debugfs_crc.h
+++ b/include/drm/drm_debugfs_crc.h
@@ -43,6 +43,7 @@ struct drm_crtc_crc_entry {
  * @lock: protects the fields in this struct
  * @source: name of the currently configured source of CRCs
  * @opened: whether userspace has opened the data file for reading
+ * @overflow: whether an overflow occured.
  * @entries: array of entries, with size of %DRM_CRC_ENTRIES_NR
  * @head: head of circular queue
  * @tail: tail of circular queue
@@ -52,7 +53,7 @@ struct drm_crtc_crc_entry {
 struct drm_crtc_crc {
 	spinlock_t lock;
 	const char *source;
-	bool opened;
+	bool opened, overflow;
 	struct drm_crtc_crc_entry *entries;
 	int head, tail;
 	size_t values_cnt;

commit 9edbf1fa600a2ef17c7553c2103d0055d0320d15
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Thu Oct 6 17:21:06 2016 +0200

    drm: Add API for capturing frame CRCs
    
    Adds files and directories to debugfs for controlling and reading frame
    CRCs, per CRTC:
    
    dri/0/crtc-0/crc
    dri/0/crtc-0/crc/control
    dri/0/crtc-0/crc/data
    
    Drivers can implement the set_crc_source callback() in drm_crtc_funcs to
    start and stop generating frame CRCs and can add entries to the output
    by calling drm_crtc_add_crc_entry.
    
    v2:
        - Lots of good fixes suggested by Thierry.
        - Added documentation.
        - Changed the debugfs layout.
        - Moved to allocate the entries circular queue once when frame
          generation gets enabled for the first time.
    v3:
        - Use the control file just to select the source, and start and stop
          capture when the data file is opened and closed, respectively.
        - Make variable the number of CRC values per entry, per source.
        - Allocate entries queue each time we start capturing as now there
          isn't a fixed number of CRC values per entry.
        - Store the frame counter in the data file as a 8-digit hex number.
        - For sources that cannot provide useful frame numbers, place
          XXXXXXXX in the frame field.
    
    v4:
        - Build only if CONFIG_DEBUG_FS is enabled.
        - Use memdup_user_nul.
        - Consolidate calculation of the size of an entry in a helper.
        - Add 0x prefix to hex numbers in the data file.
        - Remove unnecessary snprintf and strlen usage in read callback.
    
    v5:
        - Made the crcs array in drm_crtc_crc_entry fixed-size
        - Lots of other smaller improvements suggested by Emil Velikov
    
    v7:
        - Move definition of drm_debugfs_crtc_crc_add to drm_internal.h
    
    v8:
        - Call debugfs_remove_recursive when we fail to create the minor
          device
    
    v9:
        - Register the debugfs directory for a crtc from
          drm_crtc_register_all()
    
    v10:
        - Don't let debugfs failures interrupt CRTC registration (Emil
          Velikov)
    
    v11:
        - Remove extra brace that broke compilation. Sorry!
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Acked-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1475767268-14379-3-git-send-email-tomeu.vizoso@collabora.com

diff --git a/include/drm/drm_debugfs_crc.h b/include/drm/drm_debugfs_crc.h
new file mode 100644
index 000000000000..7d63b1d4adb9
--- /dev/null
+++ b/include/drm/drm_debugfs_crc.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright © 2016 Collabora Ltd.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef __DRM_DEBUGFS_CRC_H__
+#define __DRM_DEBUGFS_CRC_H__
+
+#define DRM_MAX_CRC_NR		10
+
+/**
+ * struct drm_crtc_crc_entry - entry describing a frame's content
+ * @has_frame_counter: whether the source was able to provide a frame number
+ * @frame: number of the frame this CRC is about, if @has_frame_counter is true
+ * @crc: array of values that characterize the frame
+ */
+struct drm_crtc_crc_entry {
+	bool has_frame_counter;
+	uint32_t frame;
+	uint32_t crcs[DRM_MAX_CRC_NR];
+};
+
+#define DRM_CRC_ENTRIES_NR	128
+
+/**
+ * struct drm_crtc_crc - data supporting CRC capture on a given CRTC
+ * @lock: protects the fields in this struct
+ * @source: name of the currently configured source of CRCs
+ * @opened: whether userspace has opened the data file for reading
+ * @entries: array of entries, with size of %DRM_CRC_ENTRIES_NR
+ * @head: head of circular queue
+ * @tail: tail of circular queue
+ * @values_cnt: number of CRC values per entry, up to %DRM_MAX_CRC_NR
+ * @wq: workqueue used to synchronize reading and writing
+ */
+struct drm_crtc_crc {
+	spinlock_t lock;
+	const char *source;
+	bool opened;
+	struct drm_crtc_crc_entry *entries;
+	int head, tail;
+	size_t values_cnt;
+	wait_queue_head_t wq;
+};
+
+#if defined(CONFIG_DEBUG_FS)
+int drm_crtc_add_crc_entry(struct drm_crtc *crtc, bool has_frame,
+			   uint32_t frame, uint32_t *crcs);
+#else
+static inline int drm_crtc_add_crc_entry(struct drm_crtc *crtc, bool has_frame,
+					 uint32_t frame, uint32_t *crcs)
+{
+	return -EINVAL;
+}
+#endif /* defined(CONFIG_DEBUG_FS) */
+
+#endif /* __DRM_DEBUGFS_CRC_H__ */
