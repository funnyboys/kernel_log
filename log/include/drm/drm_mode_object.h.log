commit e007488b2fbbda00bc504e37ffdc8866c8f59c5e
Author: Haneen Mohammed <hamohammed.sa@gmail.com>
Date:   Mon Mar 19 01:58:20 2018 -0400

    drm: remove drm_mode_object_{un/reference} aliases
    
    This patch remove the compatibility aliases
    drm_mode_object_{reference/unreference} of drm_mode_object_{get/put}
    since all callers have been converted to the prefered _{get/put}.
    
    Remove the helpers from the semantic patch drm-get-put-cocci.
    
    Signed-off-by: Haneen Mohammed <hamohammed.sa@gmail.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180319055820.GA17502@haneen-VirtualBox

diff --git a/include/drm/drm_mode_object.h b/include/drm/drm_mode_object.h
index 7ba3913f30b5..c34a3e8030e1 100644
--- a/include/drm/drm_mode_object.h
+++ b/include/drm/drm_mode_object.h
@@ -120,30 +120,6 @@ struct drm_mode_object *drm_mode_object_find(struct drm_device *dev,
 void drm_mode_object_get(struct drm_mode_object *obj);
 void drm_mode_object_put(struct drm_mode_object *obj);
 
-/**
- * drm_mode_object_reference - acquire a mode object reference
- * @obj: DRM mode object
- *
- * This is a compatibility alias for drm_mode_object_get() and should not be
- * used by new code.
- */
-static inline void drm_mode_object_reference(struct drm_mode_object *obj)
-{
-	drm_mode_object_get(obj);
-}
-
-/**
- * drm_mode_object_unreference - release a mode object reference
- * @obj: DRM mode object
- *
- * This is a compatibility alias for drm_mode_object_put() and should not be
- * used by new code.
- */
-static inline void drm_mode_object_unreference(struct drm_mode_object *obj)
-{
-	drm_mode_object_put(obj);
-}
-
 int drm_object_property_set_value(struct drm_mode_object *obj,
 				  struct drm_property *property,
 				  uint64_t val);

commit 62884cd386b876638720ef88374b31a84ca7ee5f
Author: Keith Packard <keithp@keithp.com>
Date:   Thu Mar 16 17:56:28 2017 -0700

    drm: Add four ioctls for managing drm mode object leases [v7]
    
    drm_mode_create_lease
    
            Creates a lease for a list of drm mode objects, returning an
            fd for the new drm_master and a 64-bit identifier for the lessee
    
    drm_mode_list_lesees
    
            List the identifiers of the lessees for a master file
    
    drm_mode_get_lease
    
            List the leased objects for a master file
    
    drm_mode_revoke_lease
    
            Erase the set of objects managed by a lease.
    
    This should suffice to at least create and query leases.
    
    Changes for v2 as suggested by Daniel Vetter <daniel.vetter@ffwll.ch>:
    
     * query ioctls only query the master associated with
       the provided file.
    
     * 'mask_lease' value has been removed
    
     * change ioctl has been removed.
    
    Changes for v3 suggested in part by Dave Airlie <airlied@gmail.com>
    
     * Add revoke ioctl.
    
    Changes for v4 suggested by Dave Airlie <airlied@gmail.com>
    
     * Expand on the comment about the magic use of &drm_lease_idr_object
     * Pad lease ioctl structures to align on 64-bit boundaries
    
    Changes for v5 suggested by Dave Airlie <airlied@gmail.com>
    
     * Check for non-negative object_id in create_lease to avoid debug
       output from the kernel.
    
    Changes for v6 provided by Dave Airlie <airlied@gmail.com>
    
     * For non-universal planes add primary/cursor planes to lease
    
       If we aren't exposing universal planes to this userspace client,
       and it requests a lease on a crtc, we should implicitly export the
       primary and cursor planes for the crtc.
    
       If the lessee doesn't request universal planes, it will just see
       the crtc, but if it does request them it will then see the plane
       objects as well.
    
       This also moves the object look ups earlier as a side effect, so
       we'd exit the ioctl quicker for non-existant objects.
    
     * Restrict leases to crtc/connector/planes.
    
       This only allows leasing for objects we wish to allow.
    
    Changes for v7 provided by Dave Airlie <airlied@gmail.com>
    
     * Check pad args are 0
     * Check create flags and object count are valid.
     * Check return from fd allocation
     * Refactor lease idr setup and add some simple validation
     * Use idr_mutex uniformly (Keith)
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_mode_object.h b/include/drm/drm_mode_object.h
index c8155cb5a932..7ba3913f30b5 100644
--- a/include/drm/drm_mode_object.h
+++ b/include/drm/drm_mode_object.h
@@ -154,4 +154,6 @@ int drm_object_property_get_value(struct drm_mode_object *obj,
 void drm_object_attach_property(struct drm_mode_object *obj,
 				struct drm_property *property,
 				uint64_t init_val);
+
+bool drm_mode_object_lease_required(uint32_t type);
 #endif

commit 2ed077e467eedb033032bc4b6e349365517662d6
Author: Keith Packard <keithp@keithp.com>
Date:   Tue Mar 14 22:26:41 2017 -0700

    drm: Add drm_object lease infrastructure [v5]
    
    This provides new data structures to hold "lease" information about
    drm mode setting objects, and provides for creating new drm_masters
    which have access to a subset of the available drm resources.
    
    An 'owner' is a drm_master which is not leasing the objects from
    another drm_master, and hence 'owns' them.
    
    A 'lessee' is a drm_master which is leasing objects from some other
    drm_master. Each lessee holds the set of objects which it is leasing
    from the lessor.
    
    A 'lessor' is a drm_master which is leasing objects to another
    drm_master. This is the same as the owner in the current code.
    
    The set of objects any drm_master 'controls' is limited to the set of
    objects it leases (for lessees) or all objects (for owners).
    
    Objects not controlled by a drm_master cannot be modified through the
    various state manipulating ioctls, and any state reported back to user
    space will be edited to make them appear idle and/or unusable. For
    instance, connectors always report 'disconnected', while encoders
    report no possible crtcs or clones.
    
    The full list of lessees leasing objects from an owner (either
    directly, or indirectly through another lessee), can be searched from
    an idr in the drm_master of the owner.
    
    Changes for v2 as suggested by Daniel Vetter <daniel.vetter@ffwll.ch>:
    
    * Sub-leasing has been disabled.
    
    * BUG_ON for lock checking replaced with lockdep_assert_held
    
    * 'change' ioctl has been removed.
    
    * Leased objects can always be controlled by the lessor; the
      'mask_lease' flag has been removed
    
    * Checking for leased status has been simplified, replacing
      the drm_lease_check function with drm_lease_held.
    
    Changes in v3, some suggested by Dave Airlie <airlied@gmail.com>
    
    * Add revocation. This allows leases to be effectively revoked by
      removing all of the objects they have access to. The lease itself
      hangs around as it's hanging off a file.
    
    * Free the leases IDR when the master is destroyed
    
    * _drm_lease_held should look at lessees, not lessor
    
    * Allow non-master files to check for lease status
    
    Changes in v4, suggested by Dave Airlie <airlied@gmail.com>
    
    * Formatting and whitespace changes
    
    Changes in v5 (airlied)
    
    * check DRIVER_MODESET before lease destroy call
    * check DRIVER_MODESET for lease revoke (Chris)
    * Use idr_mutex uniformly for all lease elements of struct drm_master. (Keith)
    
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/include/drm/drm_mode_object.h b/include/drm/drm_mode_object.h
index b2f920b518e3..c8155cb5a932 100644
--- a/include/drm/drm_mode_object.h
+++ b/include/drm/drm_mode_object.h
@@ -24,6 +24,7 @@
 #define __DRM_MODESET_H__
 
 #include <linux/kref.h>
+#include <drm/drm_lease.h>
 struct drm_object_properties;
 struct drm_property;
 struct drm_device;

commit 418da17214aca5ef5f0b6f7588905ee7df92f98f
Author: Keith Packard <keithp@keithp.com>
Date:   Tue Mar 14 23:25:07 2017 -0700

    drm: Pass struct drm_file * to __drm_mode_object_find [v2]
    
    This will allow __drm_mode_object_file to be extended to perform
    access control checks based on the file in use.
    
    v2: Also fix up vboxvideo driver in staging
    
    [airlied: merging early as this is an API change]
    
    Suggested-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/drm/drm_mode_object.h b/include/drm/drm_mode_object.h
index a767b4a30a6d..b2f920b518e3 100644
--- a/include/drm/drm_mode_object.h
+++ b/include/drm/drm_mode_object.h
@@ -27,6 +27,7 @@
 struct drm_object_properties;
 struct drm_property;
 struct drm_device;
+struct drm_file;
 
 /**
  * struct drm_mode_object - base structure for modeset objects
@@ -113,6 +114,7 @@ struct drm_object_properties {
 	}
 
 struct drm_mode_object *drm_mode_object_find(struct drm_device *dev,
+					     struct drm_file *file_priv,
 					     uint32_t id, uint32_t type);
 void drm_mode_object_get(struct drm_mode_object *obj);
 void drm_mode_object_put(struct drm_mode_object *obj);

commit 020a218f95bd3ceff7dd1022ff7ebc0497bc7bf9
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Feb 28 15:46:38 2017 +0100

    drm: Introduce drm_mode_object_{get,put}()
    
    For consistency with other reference counting APIs in the kernel, add
    drm_mode_object_get() and drm_mode_object_put() to reference count DRM
    mode objects.
    
    Compatibility aliases are added to keep existing code working. To help
    speed up the transition, all the instances of the old functions in the
    DRM core are already replaced in this commit.
    
    A semantic patch is provided that can be used to convert all drivers to
    the new helpers.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170228144643.5668-3-thierry.reding@gmail.com

diff --git a/include/drm/drm_mode_object.h b/include/drm/drm_mode_object.h
index 2c017adf6d74..a767b4a30a6d 100644
--- a/include/drm/drm_mode_object.h
+++ b/include/drm/drm_mode_object.h
@@ -45,10 +45,10 @@ struct drm_device;
  *   drm_object_attach_property() before the object is visible to userspace.
  *
  * - For objects with dynamic lifetimes (as indicated by a non-NULL @free_cb) it
- *   provides reference counting through drm_mode_object_reference() and
- *   drm_mode_object_unreference(). This is used by &drm_framebuffer,
- *   &drm_connector and &drm_property_blob. These objects provide specialized
- *   reference counting wrappers.
+ *   provides reference counting through drm_mode_object_get() and
+ *   drm_mode_object_put(). This is used by &drm_framebuffer, &drm_connector
+ *   and &drm_property_blob. These objects provide specialized reference
+ *   counting wrappers.
  */
 struct drm_mode_object {
 	uint32_t id;
@@ -114,8 +114,32 @@ struct drm_object_properties {
 
 struct drm_mode_object *drm_mode_object_find(struct drm_device *dev,
 					     uint32_t id, uint32_t type);
-void drm_mode_object_reference(struct drm_mode_object *obj);
-void drm_mode_object_unreference(struct drm_mode_object *obj);
+void drm_mode_object_get(struct drm_mode_object *obj);
+void drm_mode_object_put(struct drm_mode_object *obj);
+
+/**
+ * drm_mode_object_reference - acquire a mode object reference
+ * @obj: DRM mode object
+ *
+ * This is a compatibility alias for drm_mode_object_get() and should not be
+ * used by new code.
+ */
+static inline void drm_mode_object_reference(struct drm_mode_object *obj)
+{
+	drm_mode_object_get(obj);
+}
+
+/**
+ * drm_mode_object_unreference - release a mode object reference
+ * @obj: DRM mode object
+ *
+ * This is a compatibility alias for drm_mode_object_put() and should not be
+ * used by new code.
+ */
+static inline void drm_mode_object_unreference(struct drm_mode_object *obj)
+{
+	drm_mode_object_put(obj);
+}
 
 int drm_object_property_set_value(struct drm_mode_object *obj,
 				  struct drm_property *property,

commit d574528a64c3a3b2a9c6a125e2428b38bddbdf3c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Jan 25 07:26:45 2017 +0100

    drm/kms-core: Use recommened kerneldoc for struct member refs
    
    I just learned that &struct_name.member_name works and looks pretty
    even. It doesn't (yet) link to the member directly though, which would
    be really good for big structures or vfunc tables (where the
    per-member kerneldoc tends to be long).
    
    Also some minor drive-by polish where it makes sense, I read a lot
    of docs ...
    
    v2: Review from Eric.
    
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Eric Engestrom <eric.engestrom@imgtec.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170125062657.19270-4-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_mode_object.h b/include/drm/drm_mode_object.h
index 43460b21d112..2c017adf6d74 100644
--- a/include/drm/drm_mode_object.h
+++ b/include/drm/drm_mode_object.h
@@ -86,10 +86,15 @@ struct drm_object_properties {
 	 *
 	 * Note that atomic drivers do not store mutable properties in this
 	 * array, but only the decoded values in the corresponding state
-	 * structure. The decoding is done using the ->atomic_get_property and
-	 * ->atomic_set_property hooks of the corresponding object. Hence atomic
-	 * drivers should not use drm_object_property_set_value() and
-	 * drm_object_property_get_value() on mutable objects, i.e. those
+	 * structure. The decoding is done using the &drm_crtc.atomic_get_property and
+	 * &drm_crtc.atomic_set_property hooks for &struct drm_crtc. For
+	 * &struct drm_plane the hooks are &drm_plane_funcs.atomic_get_property and
+	 * &drm_plane_funcs.atomic_set_property. And for &struct drm_connector
+	 * the hooks are &drm_connector_funcs.atomic_get_property and
+	 * &drm_connector_funcs.atomic_set_property .
+	 *
+	 * Hence atomic drivers should not use drm_object_property_set_value()
+	 * and drm_object_property_get_value() on mutable objects, i.e. those
 	 * without the DRM_MODE_PROP_IMMUTABLE flag set.
 	 */
 	uint64_t values[DRM_OBJECT_MAX_PROPERTY];

commit 199e4e967af476bdcab96c76237e6a1f9244d6ca
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Aug 31 18:09:05 2016 +0200

    drm: Extract drm_bridge.h
    
    We don't want to burry the bridge structures kerneldoc in drm_crtc.h.
    
    Cc: Archit Taneja <archit.taneja@gmail.com>
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160831160913.12991-3-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_mode_object.h b/include/drm/drm_mode_object.h
index be3d93839ae2..43460b21d112 100644
--- a/include/drm/drm_mode_object.h
+++ b/include/drm/drm_mode_object.h
@@ -26,6 +26,7 @@
 #include <linux/kref.h>
 struct drm_object_properties;
 struct drm_property;
+struct drm_device;
 
 /**
  * struct drm_mode_object - base structure for modeset objects

commit a2511a557eb868dc5fb28808ef58bd8af2e51f3b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Aug 29 10:27:53 2016 +0200

    drm/doc: Polish docs for drm_mode_object
    
    I figured an overview section here is overkill, and better
    to just document the 2 structures themselves well enough.
    
    v2: Review from Archit:
    - Appease checkpatch in moved code.
    - Spelling fixes in the kerneldoc.
    
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160829082757.17913-5-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_mode_object.h b/include/drm/drm_mode_object.h
index b8adb6425f2a..be3d93839ae2 100644
--- a/include/drm/drm_mode_object.h
+++ b/include/drm/drm_mode_object.h
@@ -27,6 +27,28 @@
 struct drm_object_properties;
 struct drm_property;
 
+/**
+ * struct drm_mode_object - base structure for modeset objects
+ * @id: userspace visible identifier
+ * @type: type of the object, one of DRM_MODE_OBJECT\_\*
+ * @properties: properties attached to this object, including values
+ * @refcount: reference count for objects which with dynamic lifetime
+ * @free_cb: free function callback, only set for objects with dynamic lifetime
+ *
+ * Base structure for modeset objects visible to userspace. Objects can be
+ * looked up using drm_mode_object_find(). Besides basic uapi interface
+ * properties like @id and @type it provides two services:
+ *
+ * - It tracks attached properties and their values. This is used by &drm_crtc,
+ *   &drm_plane and &drm_connector. Properties are attached by calling
+ *   drm_object_attach_property() before the object is visible to userspace.
+ *
+ * - For objects with dynamic lifetimes (as indicated by a non-NULL @free_cb) it
+ *   provides reference counting through drm_mode_object_reference() and
+ *   drm_mode_object_unreference(). This is used by &drm_framebuffer,
+ *   &drm_connector and &drm_property_blob. These objects provide specialized
+ *   reference counting wrappers.
+ */
 struct drm_mode_object {
 	uint32_t id;
 	uint32_t type;
@@ -36,16 +58,38 @@ struct drm_mode_object {
 };
 
 #define DRM_OBJECT_MAX_PROPERTY 24
+/**
+ * struct drm_object_properties - property tracking for &drm_mode_object
+ */
 struct drm_object_properties {
+	/**
+	 * @count: number of valid properties, must be less than or equal to
+	 * DRM_OBJECT_MAX_PROPERTY.
+	 */
+
 	int count;
-	/* NOTE: if we ever start dynamically destroying properties (ie.
+	/**
+	 * @properties: Array of pointers to &drm_property.
+	 *
+	 * NOTE: if we ever start dynamically destroying properties (ie.
 	 * not at drm_mode_config_cleanup() time), then we'd have to do
 	 * a better job of detaching property from mode objects to avoid
 	 * dangling property pointers:
 	 */
 	struct drm_property *properties[DRM_OBJECT_MAX_PROPERTY];
-	/* do not read/write values directly, but use drm_object_property_get_value()
-	 * and drm_object_property_set_value():
+
+	/**
+	 * @values: Array to store the property values, matching @properties. Do
+	 * not read/write values directly, but use
+	 * drm_object_property_get_value() and drm_object_property_set_value().
+	 *
+	 * Note that atomic drivers do not store mutable properties in this
+	 * array, but only the decoded values in the corresponding state
+	 * structure. The decoding is done using the ->atomic_get_property and
+	 * ->atomic_set_property hooks of the corresponding object. Hence atomic
+	 * drivers should not use drm_object_property_set_value() and
+	 * drm_object_property_get_value() on mutable objects, i.e. those
+	 * without the DRM_MODE_PROP_IMMUTABLE flag set.
 	 */
 	uint64_t values[DRM_OBJECT_MAX_PROPERTY];
 };

commit f094d881954982b559e98e90aca1bf6f45141420
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Aug 29 10:27:52 2016 +0200

    drm: Remove drm_mode_object->atomic_count
    
    It's only used in drm_mode_object_get_properties, and we can compute
    it there directly with a bit of code shuffling.
    
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160829082757.17913-4-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_mode_object.h b/include/drm/drm_mode_object.h
index c0e4414299f7..b8adb6425f2a 100644
--- a/include/drm/drm_mode_object.h
+++ b/include/drm/drm_mode_object.h
@@ -37,7 +37,7 @@ struct drm_mode_object {
 
 #define DRM_OBJECT_MAX_PROPERTY 24
 struct drm_object_properties {
-	int count, atomic_count;
+	int count;
 	/* NOTE: if we ever start dynamically destroying properties (ie.
 	 * not at drm_mode_config_cleanup() time), then we'd have to do
 	 * a better job of detaching property from mode objects to avoid

commit 949619f32eee37a6385de1e976523501c8256768
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Aug 29 10:27:51 2016 +0200

    drm: Extract drm_mode_object.[hc]
    
    Just for the struct drm_mode_object base class. The header file was
    already partially extracted to help untangle the include loops.
    
    v2:
    - Also move the generic get/set property ioctls. At first this seemed
      like a bad idea since it requires making drm_mode_crtc_set_obj_prop
      non-static. But eventually that will get split away too (like
      the connector version already is) for both crtc and planes. Hence I
      reconsidered.
    
    - drm_mode_object.[hc] instead of drm_modeset.[hc], which requires
      renaming the drm_modeset.h header I already started building up.
      This is more consistent (matches the name of the main structure),
      and I want to be able to use drm_modeset.[hc] for the basic modeset
      init/cleanup functionality like drm_mode_config_init.
    
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160829082757.17913-3-daniel.vetter@ffwll.ch

diff --git a/include/drm/drm_mode_object.h b/include/drm/drm_mode_object.h
new file mode 100644
index 000000000000..c0e4414299f7
--- /dev/null
+++ b/include/drm/drm_mode_object.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2016 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef __DRM_MODESET_H__
+#define __DRM_MODESET_H__
+
+#include <linux/kref.h>
+struct drm_object_properties;
+struct drm_property;
+
+struct drm_mode_object {
+	uint32_t id;
+	uint32_t type;
+	struct drm_object_properties *properties;
+	struct kref refcount;
+	void (*free_cb)(struct kref *kref);
+};
+
+#define DRM_OBJECT_MAX_PROPERTY 24
+struct drm_object_properties {
+	int count, atomic_count;
+	/* NOTE: if we ever start dynamically destroying properties (ie.
+	 * not at drm_mode_config_cleanup() time), then we'd have to do
+	 * a better job of detaching property from mode objects to avoid
+	 * dangling property pointers:
+	 */
+	struct drm_property *properties[DRM_OBJECT_MAX_PROPERTY];
+	/* do not read/write values directly, but use drm_object_property_get_value()
+	 * and drm_object_property_set_value():
+	 */
+	uint64_t values[DRM_OBJECT_MAX_PROPERTY];
+};
+
+/* Avoid boilerplate.  I'm tired of typing. */
+#define DRM_ENUM_NAME_FN(fnname, list)				\
+	const char *fnname(int val)				\
+	{							\
+		int i;						\
+		for (i = 0; i < ARRAY_SIZE(list); i++) {	\
+			if (list[i].type == val)		\
+				return list[i].name;		\
+		}						\
+		return "(unknown)";				\
+	}
+
+struct drm_mode_object *drm_mode_object_find(struct drm_device *dev,
+					     uint32_t id, uint32_t type);
+void drm_mode_object_reference(struct drm_mode_object *obj);
+void drm_mode_object_unreference(struct drm_mode_object *obj);
+
+int drm_object_property_set_value(struct drm_mode_object *obj,
+				  struct drm_property *property,
+				  uint64_t val);
+int drm_object_property_get_value(struct drm_mode_object *obj,
+				  struct drm_property *property,
+				  uint64_t *value);
+
+void drm_object_attach_property(struct drm_mode_object *obj,
+				struct drm_property *property,
+				uint64_t init_val);
+#endif
