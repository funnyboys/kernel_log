commit cb09ea2924cbf1a42da59bd30a59cc1836240bcb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 21 22:05:44 2020 +0200

    x86/entry: Convert XEN hypercall vector to IDTENTRY_SYSVEC
    
    Convert the last oldstyle defined vector to IDTENTRY_SYSVEC:
    
      - Implement the C entry point with DEFINE_IDTENTRY_SYSVEC
      - Emit the ASM stub with DECLARE_IDTENTRY_SYSVEC
      - Remove the ASM idtentries in 64-bit
      - Remove the BUILD_INTERRUPT entries in 32-bit
      - Remove the old prototypes
    
    Fixup the related XEN code by providing the primary C entry point in x86 to
    avoid cluttering the generic code with X86'isms.
    
    No functional change.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Andy Lutomirski <luto@kernel.org>
    Link: https://lore.kernel.org/r/20200521202119.741950104@linutronix.de

diff --git a/include/xen/events.h b/include/xen/events.h
index 12b0dcb6a120..df1e6391f63f 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -90,13 +90,6 @@ unsigned int irq_from_evtchn(evtchn_port_t evtchn);
 int irq_from_virq(unsigned int cpu, unsigned int virq);
 evtchn_port_t evtchn_from_irq(unsigned irq);
 
-#ifdef CONFIG_XEN_PVHVM
-/* Xen HVM evtchn vector callback */
-void xen_hvm_callback_vector(void);
-#ifdef CONFIG_TRACING
-#define trace_xen_hvm_callback_vector xen_hvm_callback_vector
-#endif
-#endif
 int xen_set_callback_via(uint64_t via);
 void xen_evtchn_do_upcall(struct pt_regs *regs);
 void xen_hvm_evtchn_do_upcall(void);

commit 0102e4efda76d0721bc744dd80258eb6cfa25fc3
Author: Yan Yankovskyi <yyankovskyi@gmail.com>
Date:   Mon Mar 23 18:15:11 2020 +0200

    xen: Use evtchn_type_t as a type for event channels
    
    Make event channel functions pass event channel port using
    evtchn_port_t type. It eliminates signed <-> unsigned conversion.
    
    Signed-off-by: Yan Yankovskyi <yyankovskyi@gmail.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Link: https://lore.kernel.org/r/20200323152343.GA28422@kbp1-lhp-F74019
    Signed-off-by: Juergen Gross <jgross@suse.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index c0e6a0598397..12b0dcb6a120 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -14,8 +14,8 @@
 
 unsigned xen_evtchn_nr_channels(void);
 
-int bind_evtchn_to_irq(unsigned int evtchn);
-int bind_evtchn_to_irqhandler(unsigned int evtchn,
+int bind_evtchn_to_irq(evtchn_port_t evtchn);
+int bind_evtchn_to_irqhandler(evtchn_port_t evtchn,
 			      irq_handler_t handler,
 			      unsigned long irqflags, const char *devname,
 			      void *dev_id);
@@ -31,9 +31,9 @@ int bind_ipi_to_irqhandler(enum ipi_vector ipi,
 			   const char *devname,
 			   void *dev_id);
 int bind_interdomain_evtchn_to_irq(unsigned int remote_domain,
-				   unsigned int remote_port);
+				   evtchn_port_t remote_port);
 int bind_interdomain_evtchn_to_irqhandler(unsigned int remote_domain,
-					  unsigned int remote_port,
+					  evtchn_port_t remote_port,
 					  irq_handler_t handler,
 					  unsigned long irqflags,
 					  const char *devname,
@@ -54,15 +54,15 @@ int xen_set_irq_priority(unsigned irq, unsigned priority);
 /*
  * Allow extra references to event channels exposed to userspace by evtchn
  */
-int evtchn_make_refcounted(unsigned int evtchn);
-int evtchn_get(unsigned int evtchn);
-void evtchn_put(unsigned int evtchn);
+int evtchn_make_refcounted(evtchn_port_t evtchn);
+int evtchn_get(evtchn_port_t evtchn);
+void evtchn_put(evtchn_port_t evtchn);
 
 void xen_send_IPI_one(unsigned int cpu, enum ipi_vector vector);
-void rebind_evtchn_irq(int evtchn, int irq);
+void rebind_evtchn_irq(evtchn_port_t evtchn, int irq);
 int xen_set_affinity_evtchn(struct irq_desc *desc, unsigned int tcpu);
 
-static inline void notify_remote_via_evtchn(int port)
+static inline void notify_remote_via_evtchn(evtchn_port_t port)
 {
 	struct evtchn_send send = { .port = port };
 	(void)HYPERVISOR_event_channel_op(EVTCHNOP_send, &send);
@@ -86,9 +86,9 @@ void xen_poll_irq(int irq);
 void xen_poll_irq_timeout(int irq, u64 timeout);
 
 /* Determine the IRQ which is bound to an event channel */
-unsigned irq_from_evtchn(unsigned int evtchn);
+unsigned int irq_from_evtchn(evtchn_port_t evtchn);
 int irq_from_virq(unsigned int cpu, unsigned int virq);
-unsigned int evtchn_from_irq(unsigned irq);
+evtchn_port_t evtchn_from_irq(unsigned irq);
 
 #ifdef CONFIG_XEN_PVHVM
 /* Xen HVM evtchn vector callback */

commit bce5963bcb4f9934faa52be323994511d59fd13c
Author: Juergen Gross <jgross@suse.com>
Date:   Fri Jun 21 20:47:03 2019 +0200

    xen/events: fix binding user event channels to cpus
    
    When binding an interdomain event channel to a vcpu via
    IOCTL_EVTCHN_BIND_INTERDOMAIN not only the event channel needs to be
    bound, but the affinity of the associated IRQi must be changed, too.
    Otherwise the IRQ and the event channel won't be moved to another vcpu
    in case the original vcpu they were bound to is going offline.
    
    Cc: <stable@vger.kernel.org> # 4.13
    Fixes: c48f64ab472389df ("xen-evtchn: Bind dyn evtchn:qemu-dm interrupt to next online VCPU")
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: Juergen Gross <jgross@suse.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index a48897199975..c0e6a0598397 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -3,6 +3,7 @@
 #define _XEN_EVENTS_H
 
 #include <linux/interrupt.h>
+#include <linux/irq.h>
 #ifdef CONFIG_PCI_MSI
 #include <linux/msi.h>
 #endif
@@ -59,7 +60,7 @@ void evtchn_put(unsigned int evtchn);
 
 void xen_send_IPI_one(unsigned int cpu, enum ipi_vector vector);
 void rebind_evtchn_irq(int evtchn, int irq);
-int xen_rebind_evtchn_to_cpu(int evtchn, unsigned tcpu);
+int xen_set_affinity_evtchn(struct irq_desc *desc, unsigned int tcpu);
 
 static inline void notify_remote_via_evtchn(int port)
 {

commit 28c11b0f798c6727355bd44603b16bb04e3a044d
Author: Juergen Gross <jgross@suse.com>
Date:   Tue Aug 28 09:40:12 2018 +0200

    x86/xen: Move pv irq related functions under CONFIG_XEN_PV umbrella
    
    All functions in arch/x86/xen/irq.c and arch/x86/xen/xen-asm*.S are
    specific to PV guests. Include them in the kernel with CONFIG_XEN_PV only.
    
    Make the PV specific code in arch/x86/entry/entry_*.S dependent on
    CONFIG_XEN_PV instead of CONFIG_XEN.
    
    The HVM specific code should depend on CONFIG_XEN_PVHVM.
    
    While at it reformat the Makefile to make it more readable.
    
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: xen-devel@lists.xenproject.org
    Cc: virtualization@lists.linux-foundation.org
    Cc: akataria@vmware.com
    Cc: rusty@rustcorp.com.au
    Cc: hpa@zytor.com
    Link: https://lkml.kernel.org/r/20180828074026.820-2-jgross@suse.com

diff --git a/include/xen/events.h b/include/xen/events.h
index c3e6bc643a7b..a48897199975 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -89,11 +89,13 @@ unsigned irq_from_evtchn(unsigned int evtchn);
 int irq_from_virq(unsigned int cpu, unsigned int virq);
 unsigned int evtchn_from_irq(unsigned irq);
 
+#ifdef CONFIG_XEN_PVHVM
 /* Xen HVM evtchn vector callback */
 void xen_hvm_callback_vector(void);
 #ifdef CONFIG_TRACING
 #define trace_xen_hvm_callback_vector xen_hvm_callback_vector
 #endif
+#endif
 int xen_set_callback_via(uint64_t via);
 void xen_evtchn_do_upcall(struct pt_regs *regs);
 void xen_hvm_evtchn_do_upcall(void);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/xen/events.h b/include/xen/events.h
index f442ca5fcd82..c3e6bc643a7b 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _XEN_EVENTS_H
 #define _XEN_EVENTS_H
 

commit c48f64ab472389df6f48171899c9d337adfadc5b
Author: Anoob Soman <anoob.soman@citrix.com>
Date:   Wed Jun 7 12:46:56 2017 +0100

    xen-evtchn: Bind dyn evtchn:qemu-dm interrupt to next online VCPU
    
    A HVM domian booting generates around 200K (evtchn:qemu-dm xen-dyn)
    interrupts,in a short period of time. All these evtchn:qemu-dm are bound
    to VCPU 0, until irqbalance sees these IRQ and moves it to a different VCPU.
    In one configuration, irqbalance runs every 10 seconds, which means
    irqbalance doesn't get to see these burst of interrupts and doesn't
    re-balance interrupts most of the time, making all evtchn:qemu-dm to be
    processed by VCPU0. This cause VCPU0 to spend most of time processing
    hardirq and very little time on softirq. Moreover, if dom0 kernel PREEMPTION
    is disabled, VCPU0 never runs watchdog (process context), triggering a
    softlockup detection code to panic.
    
    Binding evtchn:qemu-dm to next online VCPU, will spread hardirq
    processing evenly across different CPU. Later, irqbalance will try to balance
    evtchn:qemu-dm, if required.
    
    Signed-off-by: Anoob Soman <anoob.soman@citrix.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: Juergen Gross <jgross@suse.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 88da2abaf535..f442ca5fcd82 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -58,6 +58,7 @@ void evtchn_put(unsigned int evtchn);
 
 void xen_send_IPI_one(unsigned int cpu, enum ipi_vector vector);
 void rebind_evtchn_irq(int evtchn, int irq);
+int xen_rebind_evtchn_to_cpu(int evtchn, unsigned tcpu);
 
 static inline void notify_remote_via_evtchn(int port)
 {

commit 4a5b69464e51f4a8dd432e8c2a1468630df1a53c
Author: Julien Grall <julien.grall@citrix.com>
Date:   Tue Jul 28 10:10:42 2015 +0100

    xen/events: Support event channel rebind on ARM
    
    Currently, the event channel rebind code is gated with the presence of
    the vector callback.
    
    The virtual interrupt controller on ARM has the concept of per-CPU
    interrupt (PPI) which allow us to support per-VCPU event channel.
    Therefore there is no need of vector callback for ARM.
    
    Xen is already using a free PPI to notify the guest VCPU of an event.
    Furthermore, the xen code initialization in Linux (see
    arch/arm/xen/enlighten.c) is requesting correctly a per-CPU IRQ.
    
    Introduce new helper xen_support_evtchn_rebind to allow architecture
    decide whether rebind an event is support or not. It will always return
    true on ARM and keep the same behavior on x86.
    
    This is also allow us to drop the usage of xen_have_vector_callback
    entirely in the ARM code.
    
    Signed-off-by: Julien Grall <julien.grall@citrix.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 7d95fdf9cf3e..88da2abaf535 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -92,7 +92,6 @@ void xen_hvm_callback_vector(void);
 #ifdef CONFIG_TRACING
 #define trace_xen_hvm_callback_vector xen_hvm_callback_vector
 #endif
-extern int xen_have_vector_callback;
 int xen_set_callback_via(uint64_t via);
 void xen_evtchn_do_upcall(struct pt_regs *regs);
 void xen_hvm_evtchn_do_upcall(void);

commit 77bb3dfdc0d554befad58fdefbc41be5bc3ed38a
Author: David Vrabel <david.vrabel@citrix.com>
Date:   Tue May 19 18:40:49 2015 +0100

    xen/events: don't bind non-percpu VIRQs with percpu chip
    
    A non-percpu VIRQ (e.g., VIRQ_CONSOLE) may be freed on a different
    VCPU than it is bound to.  This can result in a race between
    handle_percpu_irq() and removing the action in __free_irq() because
    handle_percpu_irq() does not take desc->lock.  The interrupt handler
    sees a NULL action and oopses.
    
    Only use the percpu chip/handler for per-CPU VIRQs (like VIRQ_TIMER).
    
      # cat /proc/interrupts | grep virq
       40:      87246          0  xen-percpu-virq      timer0
       44:          0          0  xen-percpu-virq      debug0
       47:          0      20995  xen-percpu-virq      timer1
       51:          0          0  xen-percpu-virq      debug1
       69:          0          0   xen-dyn-virq      xen-pcpu
       74:          0          0   xen-dyn-virq      mce
       75:         29          0   xen-dyn-virq      hvc_console
    
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Cc: <stable@vger.kernel.org>

diff --git a/include/xen/events.h b/include/xen/events.h
index 5321cd9636e6..7d95fdf9cf3e 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -17,7 +17,7 @@ int bind_evtchn_to_irqhandler(unsigned int evtchn,
 			      irq_handler_t handler,
 			      unsigned long irqflags, const char *devname,
 			      void *dev_id);
-int bind_virq_to_irq(unsigned int virq, unsigned int cpu);
+int bind_virq_to_irq(unsigned int virq, unsigned int cpu, bool percpu);
 int bind_virq_to_irqhandler(unsigned int virq, unsigned int cpu,
 			    irq_handler_t handler,
 			    unsigned long irqflags, const char *devname,

commit 854072dd0f73b8e4238c88bdf0dd2a8db0239c1c
Author: Juergen Gross <jgross@suse.com>
Date:   Thu Aug 28 06:44:09 2014 +0200

    xen/events: support threaded irqs for interdomain event channels
    
    Export bind_interdomain_evtchn_to_irq() so drivers can use threaded
    interrupt handlers with:
    
     irq = bind_interdomain_evtchn_to_irq(remote_dom, remote_port);
     if (irq < 0)
         /* error */
     ret = request_threaded_irq(...);
    
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 8bee7a75e850..5321cd9636e6 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -28,6 +28,8 @@ int bind_ipi_to_irqhandler(enum ipi_vector ipi,
 			   unsigned long irqflags,
 			   const char *devname,
 			   void *dev_id);
+int bind_interdomain_evtchn_to_irq(unsigned int remote_domain,
+				   unsigned int remote_port);
 int bind_interdomain_evtchn_to_irqhandler(unsigned int remote_domain,
 					  unsigned int remote_port,
 					  irq_handler_t handler,

commit 4892c9b4ada9f9a71a0da7a268f95e988d88064b
Author: Roger Pau Monne <roger.pau@citrix.com>
Date:   Thu Feb 27 19:15:35 2014 +0100

    xen: add support for MSI message groups
    
    Add support for MSI message groups for Xen Dom0 using the
    MAP_PIRQ_TYPE_MULTI_MSI pirq map type.
    
    In order to keep track of which pirq is the first one in the group all
    pirqs in the MSI group except for the first one have the newly
    introduced PIRQ_MSI_GROUP flag set. This prevents calling
    PHYSDEVOP_unmap_pirq on them, since the unmap must be done with the
    first pirq in the group.
    
    Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index a6d92378354c..8bee7a75e850 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -2,6 +2,9 @@
 #define _XEN_EVENTS_H
 
 #include <linux/interrupt.h>
+#ifdef CONFIG_PCI_MSI
+#include <linux/msi.h>
+#endif
 
 #include <xen/interface/event_channel.h>
 #include <asm/xen/hypercall.h>
@@ -101,7 +104,7 @@ int xen_bind_pirq_gsi_to_irq(unsigned gsi,
 int xen_allocate_pirq_msi(struct pci_dev *dev, struct msi_desc *msidesc);
 /* Bind an PSI pirq to an irq. */
 int xen_bind_pirq_msi_to_irq(struct pci_dev *dev, struct msi_desc *msidesc,
-			     int pirq, const char *name, domid_t domid);
+			     int pirq, int nvec, const char *name, domid_t domid);
 #endif
 
 /* De-allocates the above mentioned physical interrupt. */

commit 4640ddf5efe71c1338cbb76e73278cfdbcd6426f
Author: David Vrabel <david.vrabel@citrix.com>
Date:   Mon Feb 17 17:45:16 2014 +0000

    xen/events: remove the unused resend_irq_on_evtchn()
    
    resend_irq_on_evtchn() was only used by ia64 (which no longer has Xen
    support).
    
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index c9c85cf84895..a6d92378354c 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -52,7 +52,6 @@ int evtchn_get(unsigned int evtchn);
 void evtchn_put(unsigned int evtchn);
 
 void xen_send_IPI_one(unsigned int cpu, enum ipi_vector vector);
-int resend_irq_on_evtchn(unsigned int irq);
 void rebind_evtchn_irq(int evtchn, int irq);
 
 static inline void notify_remote_via_evtchn(int port)

commit 6ccecb0fbc0494c7221459e6358a016f3281a0ca
Author: David Vrabel <david.vrabel@citrix.com>
Date:   Mon Sep 23 12:47:26 2013 +0100

    xen/events: allow event channel priority to be set
    
    Add xen_irq_set_priority() to set an event channels priority.  This function
    will only work with event channel ABIs that support priority (i.e., the
    FIFO-based ABI).
    
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 55b42cc997f6..c9c85cf84895 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -39,6 +39,11 @@ int bind_interdomain_evtchn_to_irqhandler(unsigned int remote_domain,
  */
 void unbind_from_irqhandler(unsigned int irq, void *dev_id);
 
+#define XEN_IRQ_PRIORITY_MAX     EVTCHN_FIFO_PRIORITY_MAX
+#define XEN_IRQ_PRIORITY_DEFAULT EVTCHN_FIFO_PRIORITY_DEFAULT
+#define XEN_IRQ_PRIORITY_MIN     EVTCHN_FIFO_PRIORITY_MIN
+int xen_set_irq_priority(unsigned irq, unsigned priority);
+
 /*
  * Allow extra references to event channels exposed to userspace by evtchn
  */

commit 0dc0064add422bc0ef5165ebe9ece3052bbd457d
Author: David Vrabel <david.vrabel@citrix.com>
Date:   Mon Sep 23 21:03:38 2013 +0100

    xen/evtchn: support more than 4096 ports
    
    Remove the check during unbind for NR_EVENT_CHANNELS as this limits
    support to less than 4096 ports.
    
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 32ae0f263749..55b42cc997f6 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -7,6 +7,8 @@
 #include <asm/xen/hypercall.h>
 #include <asm/xen/events.h>
 
+unsigned xen_evtchn_nr_channels(void);
+
 int bind_evtchn_to_irq(unsigned int evtchn);
 int bind_evtchn_to_irqhandler(unsigned int evtchn,
 			      irq_handler_t handler,

commit 9a489f45a155fe96b9b55fbbef2b757ef7737cfc
Author: David Vrabel <david.vrabel@citrix.com>
Date:   Wed Mar 13 15:29:25 2013 +0000

    xen/events: move 2-level specific code into its own file
    
    In preparation for alternative event channel ABIs, move all the
    functions accessing the shared data structures into their own file.
    
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index c9ea10ee2273..32ae0f263749 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -73,6 +73,8 @@ void xen_poll_irq_timeout(int irq, u64 timeout);
 
 /* Determine the IRQ which is bound to an event channel */
 unsigned irq_from_evtchn(unsigned int evtchn);
+int irq_from_virq(unsigned int cpu, unsigned int virq);
+unsigned int evtchn_from_irq(unsigned irq);
 
 /* Xen HVM evtchn vector callback */
 void xen_hvm_callback_vector(void);

commit cf910e83ae23692fdeefc7e506e504c4c468d38a
Author: Seiji Aguchi <seiji.aguchi@hds.com>
Date:   Thu Jun 20 11:46:53 2013 -0400

    x86, trace: Add irq vector tracepoints
    
    [Purpose of this patch]
    
    As Vaibhav explained in the thread below, tracepoints for irq vectors
    are useful.
    
    http://www.spinics.net/lists/mm-commits/msg85707.html
    
    <snip>
    The current interrupt traces from irq_handler_entry and irq_handler_exit
    provide when an interrupt is handled.  They provide good data about when
    the system has switched to kernel space and how it affects the currently
    running processes.
    
    There are some IRQ vectors which trigger the system into kernel space,
    which are not handled in generic IRQ handlers.  Tracing such events gives
    us the information about IRQ interaction with other system events.
    
    The trace also tells where the system is spending its time.  We want to
    know which cores are handling interrupts and how they are affecting other
    processes in the system.  Also, the trace provides information about when
    the cores are idle and which interrupts are changing that state.
    <snip>
    
    On the other hand, my usecase is tracing just local timer event and
    getting a value of instruction pointer.
    
    I suggested to add an argument local timer event to get instruction pointer before.
    But there is another way to get it with external module like systemtap.
    So, I don't need to add any argument to irq vector tracepoints now.
    
    [Patch Description]
    
    Vaibhav's patch shared a trace point ,irq_vector_entry/irq_vector_exit, in all events.
    But there is an above use case to trace specific irq_vector rather than tracing all events.
    In this case, we are concerned about overhead due to unwanted events.
    
    So, add following tracepoints instead of introducing irq_vector_entry/exit.
    so that we can enable them independently.
       - local_timer_vector
       - reschedule_vector
       - call_function_vector
       - call_function_single_vector
       - irq_work_entry_vector
       - error_apic_vector
       - thermal_apic_vector
       - threshold_apic_vector
       - spurious_apic_vector
       - x86_platform_ipi_vector
    
    Also, introduce a logic switching IDT at enabling/disabling time so that a time penalty
    makes a zero when tracepoints are disabled. Detailed explanations are as follows.
     - Create trace irq handlers with entering_irq()/exiting_irq().
     - Create a new IDT, trace_idt_table, at boot time by adding a logic to
       _set_gate(). It is just a copy of original idt table.
     - Register the new handlers for tracpoints to the new IDT by introducing
       macros to alloc_intr_gate() called at registering time of irq_vector handlers.
     - Add checking, whether irq vector tracing is on/off, into load_current_idt().
       This has to be done below debug checking for these reasons.
       - Switching to debug IDT may be kicked while tracing is enabled.
       - On the other hands, switching to trace IDT is kicked only when debugging
         is disabled.
    
    In addition, the new IDT is created only when CONFIG_TRACING is enabled to avoid being
    used for other purposes.
    
    Signed-off-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Link: http://lkml.kernel.org/r/51C323ED.5050708@hds.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/xen/events.h b/include/xen/events.h
index b2b27c6a0f7b..c9ea10ee2273 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -76,6 +76,9 @@ unsigned irq_from_evtchn(unsigned int evtchn);
 
 /* Xen HVM evtchn vector callback */
 void xen_hvm_callback_vector(void);
+#ifdef CONFIG_TRACING
+#define trace_xen_hvm_callback_vector xen_hvm_callback_vector
+#endif
 extern int xen_have_vector_callback;
 int xen_set_callback_via(uint64_t via);
 void xen_evtchn_do_upcall(struct pt_regs *regs);

commit dec02dea1c159b69aa88cbfe9c89b2b46eadd28f
Author: Jan Beulich <JBeulich@suse.com>
Date:   Wed Apr 3 15:52:50 2013 +0100

    xen: drop tracking of IRQ vector
    
    For quite a few Xen versions, this wasn't the IRQ vector anymore
    anyway, and it is not being used by the kernel for anything. Hence
    drop the field from struct irq_info, and respective function
    parameters.
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Acked-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index c6bfe01acf6b..b2b27c6a0f7b 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -90,8 +90,7 @@ int xen_bind_pirq_gsi_to_irq(unsigned gsi,
 int xen_allocate_pirq_msi(struct pci_dev *dev, struct msi_desc *msidesc);
 /* Bind an PSI pirq to an irq. */
 int xen_bind_pirq_msi_to_irq(struct pci_dev *dev, struct msi_desc *msidesc,
-			     int pirq, int vector, const char *name,
-			     domid_t domid);
+			     int pirq, const char *name, domid_t domid);
 #endif
 
 /* De-allocates the above mentioned physical interrupt. */

commit 0ec53ecf38bcbf95b4b057328a8fbba4d22ef28b
Author: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
Date:   Fri Sep 14 13:37:32 2012 +0000

    xen/arm: receive Xen events on ARM
    
    Compile events.c on ARM.
    Parse, map and enable the IRQ to get event notifications from the device
    tree (node "/xen").
    
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 04399b28e821..c6bfe01acf6b 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -109,4 +109,6 @@ int xen_irq_from_gsi(unsigned gsi);
 /* Determine whether to ignore this IRQ if it is passed to a guest. */
 int xen_test_irq_shared(int irq);
 
+/* initialize Xen IRQ subsystem */
+void xen_init_IRQ(void);
 #endif	/* _XEN_EVENTS_H */

commit 68c2c39a76b094e9b2773e5846424ea674bf2c46
Author: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
Date:   Mon May 21 16:54:10 2012 +0100

    xen: do not map the same GSI twice in PVHVM guests.
    
    PV on HVM guests map GSIs into event channels. At restore time the
    event channels are resumed by restore_pirqs.
    
    Device drivers might try to register the same GSI again through ACPI at
    restore time, but the GSI has already been mapped and bound by
    restore_pirqs. This patch detects these situations and avoids
     mapping the same GSI multiple times.
    
    Without this patch we get:
    (XEN) irq.c:2235: dom4: pirq 23 or emuirq 28 already mapped
    and waste a pirq.
    
    CC: stable@kernel.org
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 0f773708e02c..04399b28e821 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -103,6 +103,9 @@ int xen_irq_from_pirq(unsigned pirq);
 /* Return the pirq allocated to the irq. */
 int xen_pirq_from_irq(unsigned irq);
 
+/* Return the irq allocated to the gsi */
+int xen_irq_from_gsi(unsigned gsi);
+
 /* Determine whether to ignore this IRQ if it is passed to a guest. */
 int xen_test_irq_shared(int irq);
 

commit 420eb554d5ee6daad743d8190383219f757dd66c
Author: Daniel De Graaf <dgdegra@tycho.nsa.gov>
Date:   Thu Oct 27 17:58:47 2011 -0400

    xen/event: Add reference counting to event channels
    
    Event channels exposed to userspace by the evtchn module may be used by
    other modules in an asynchronous manner, which requires that reference
    counting be used to prevent the event channel from being closed before
    the signals are delivered.
    
    The reference count on new event channels defaults to -1 which indicates
    the event channel is not referenced outside the kernel; evtchn_get fails
    if called on such an event channel. The event channels made visible to
    userspace by evtchn have a normal reference count.
    
    Signed-off-by: Daniel De Graaf <dgdegra@tycho.nsa.gov>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index d287997d3eab..0f773708e02c 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -37,6 +37,13 @@ int bind_interdomain_evtchn_to_irqhandler(unsigned int remote_domain,
  */
 void unbind_from_irqhandler(unsigned int irq, void *dev_id);
 
+/*
+ * Allow extra references to event channels exposed to userspace by evtchn
+ */
+int evtchn_make_refcounted(unsigned int evtchn);
+int evtchn_get(unsigned int evtchn);
+void evtchn_put(unsigned int evtchn);
+
 void xen_send_IPI_one(unsigned int cpu, enum ipi_vector vector);
 int resend_irq_on_evtchn(unsigned int irq);
 void rebind_evtchn_irq(int evtchn, int irq);

commit 78316ada2222b5e3abc043eea7644e12319042d6
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Wed Jul 6 15:15:23 2011 -0400

    xen/pci: Remove 'xen_allocate_pirq_gsi'.
    
    In the past (2.6.38) the 'xen_allocate_pirq_gsi' would allocate
    an entry in a Linux IRQ -> {XEN_IRQ, type, event, ..} array. All
    of that has been removed in 2.6.39 and the Xen IRQ subsystem uses
    an linked list that is populated when the call to
    'xen_allocate_irq_gsi' (universally done from any of the xen_bind_*
    calls) is done. The 'xen_allocate_pirq_gsi' is a NOP and there is
    no need for it anymore so lets remove it.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 9af21e19545a..d287997d3eab 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -74,8 +74,6 @@ int xen_set_callback_via(uint64_t via);
 void xen_evtchn_do_upcall(struct pt_regs *regs);
 void xen_hvm_evtchn_do_upcall(void);
 
-/* Allocate a pirq for a physical interrupt, given a gsi. */
-int xen_allocate_pirq_gsi(unsigned gsi);
 /* Bind a pirq for a physical interrupt to an irq. */
 int xen_bind_pirq_gsi_to_irq(unsigned gsi,
 			     unsigned pirq, int shareable, char *name);

commit e6197acc726ab3baa60375a5891d58c2ee87e0f3
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Thu Feb 24 14:20:12 2011 -0500

    xen/irq: Export 'xen_pirq_from_irq' function.
    
    We need this to find the real Xen PIRQ value for a device
    that requests an MSI or MSI-X. In the past we used
    'xen_gsi_from_irq' since that function would return
    an Xen PIRQ or GSI depending on the provided IRQ. Now that
    we have seperated that we need to use the correct
    function.
    
    [v2: Deal with rebase on stable/irq.cleanup]
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 932e54051d3e..9af21e19545a 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -95,6 +95,9 @@ int xen_destroy_irq(int irq);
 /* Return irq from pirq */
 int xen_irq_from_pirq(unsigned pirq);
 
+/* Return the pirq allocated to the irq. */
+int xen_pirq_from_irq(unsigned irq);
+
 /* Determine whether to ignore this IRQ if it is passed to a guest. */
 int xen_test_irq_shared(int irq);
 

commit c7c2c3a28657cfdcef50c02b18ccca3761209e17
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Mon Nov 8 14:26:36 2010 -0500

    xen/irq: Add support to check if IRQ line is shared with other domains.
    
    We do this via the PHYSDEVOP_irq_status_query support hypervisor call.
    We will get a positive value if another domain has binded its
    PIRQ to the specified GSI (IRQ line).
    
    [v2: Deal with v2.6.37-rc1 rebase fallout]
    [v3: Deal with stable/irq.cleanup fallout]
    [v4: xen_ignore_irq->xen_test_irq_shared]
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 9aecc0b5a0e6..932e54051d3e 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -95,4 +95,7 @@ int xen_destroy_irq(int irq);
 /* Return irq from pirq */
 int xen_irq_from_pirq(unsigned pirq);
 
+/* Determine whether to ignore this IRQ if it is passed to a guest. */
+int xen_test_irq_shared(int irq);
+
 #endif	/* _XEN_EVENTS_H */

commit beafbdc1df02877612dc9039c1de0639921fddec
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Thu Apr 14 11:17:36 2011 -0400

    xen/irq: Check if the PCI device is owned by a domain different than DOMID_SELF.
    
    We check if there is a domain owner for the PCI device. In case of failure
    (meaning no domain has registered for this device) we make DOMID_SELF the owner.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    [v2: deal with rebasing on v2.6.37-1]
    [v3: deal with rebasing on stable/irq.cleanup]
    [v4: deal with rebasing on stable/irq.ween_of_nr_irqs]
    [v5: deal with rebasing on v2.6.39-rc3]
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Acked-by: Xiantao Zhang <xiantao.zhang@intel.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index f1b87ad48ac7..9aecc0b5a0e6 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -85,7 +85,8 @@ int xen_bind_pirq_gsi_to_irq(unsigned gsi,
 int xen_allocate_pirq_msi(struct pci_dev *dev, struct msi_desc *msidesc);
 /* Bind an PSI pirq to an irq. */
 int xen_bind_pirq_msi_to_irq(struct pci_dev *dev, struct msi_desc *msidesc,
-			     int pirq, int vector, const char *name);
+			     int pirq, int vector, const char *name,
+			     domid_t domid);
 #endif
 
 /* De-allocates the above mentioned physical interrupt. */

commit 5a39837f76b7ded29afdf6ed2c2d5e56107179b7
Merge: 514af9f7904a 3b7bcdf2823a 44626e4a3bd7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 17 18:27:49 2011 -0700

    Merge branches 'stable/irq.fairness' and 'stable/irq.ween_of_nr_irqs' of git://git.kernel.org/pub/scm/linux/kernel/git/konrad/xen
    
    * 'stable/irq.fairness' of git://git.kernel.org/pub/scm/linux/kernel/git/konrad/xen:
      xen: events: Remove redundant clear of l2i at end of round-robin loop
      xen: events: Make round-robin scan fairer by snapshotting each l2 word once only
      xen: events: Clean up round-robin evtchn scan.
      xen: events: Make last processed event channel a per-cpu variable.
      xen: events: Process event channels notifications in round-robin order.
    
    * 'stable/irq.ween_of_nr_irqs' of git://git.kernel.org/pub/scm/linux/kernel/git/konrad/xen:
      xen: events: Fix compile error if CONFIG_SMP is not defined.
      xen: events: correct locking in xen_irq_from_pirq
      xen: events: propagate irq allocation failure instead of panicking
      xen: events: do not workaround too-small nr_irqs
      xen: events: remove use of nr_irqs as upper bound on number of pirqs
      xen: events: dynamically allocate irq info structures
      xen: events: maintain a list of Xen interrupts
      xen: events: push setup of irq<->{evtchn,ipi,virq,pirq} maps into irq_info init functions
      xen: events: turn irq_info constructors into initialiser functions
      xen: events: use per-cpu variable for cpu_evtchn_mask
      xen: events: refactor GSI pirq bindings functions
      xen: events: rename restore_cpu_pirqs -> restore_pirqs
      xen: events: remove unused public functions
      xen: events: fix xen_map_pirq_gsi error return
      xen: events: simplify comment
      xen: events: separate two unrelated halves of if condition
    
    Fix up trivial conflicts in drivers/xen/events.c

commit 7a6362800cb7d1d618a697a650c7aaed3eb39320
Merge: 6445ced8670f ceda86a10867
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 16 16:29:25 2011 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6: (1480 commits)
      bonding: enable netpoll without checking link status
      xfrm: Refcount destination entry on xfrm_lookup
      net: introduce rx_handler results and logic around that
      bonding: get rid of IFF_SLAVE_INACTIVE netdev->priv_flag
      bonding: wrap slave state work
      net: get rid of multiple bond-related netdevice->priv_flags
      bonding: register slave pointer for rx_handler
      be2net: Bump up the version number
      be2net: Copyright notice change. Update to Emulex instead of ServerEngines
      e1000e: fix kconfig for crc32 dependency
      netfilter ebtables: fix xt_AUDIT to work with ebtables
      xen network backend driver
      bonding: Improve syslog message at device creation time
      bonding: Call netif_carrier_off after register_netdevice
      bonding: Incorrect TX queue offset
      net_sched: fix ip_tos2prio
      xfrm: fix __xfrm_route_forward()
      be2net: Fix UDP packet detected status in RX compl
      Phonet: fix aligned-mode pipe socket buffer header reserve
      netxen: support for GbE port settings
      ...
    
    Fix up conflicts in drivers/staging/brcm80211/brcmsmac/wl_mac80211.c
    with the staging updates.

commit f4d0635bf8894b7ba43d7a54733f3e26fe6ced2e
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Mar 10 16:08:07 2011 +0000

    xen: events: refactor GSI pirq bindings functions
    
    Following the example set by xen_allocate_pirq_msi and
    xen_bind_pirq_msi_to_irq:
    
    xen_allocate_pirq becomes xen_allocate_pirq_gsi and now only allocates
    a pirq number and does not bind it.
    
    xen_map_pirq_gsi becomes xen_bind_pirq_gsi_to_irq and binds an
    existing pirq.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 99a64f045732..32ebebacee7f 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -68,12 +68,16 @@ int xen_set_callback_via(uint64_t via);
 void xen_evtchn_do_upcall(struct pt_regs *regs);
 void xen_hvm_evtchn_do_upcall(void);
 
-/* Allocate an irq for a physical interrupt, given a gsi. */
-int xen_allocate_pirq(unsigned gsi, int shareable, char *name);
-int xen_map_pirq_gsi(unsigned pirq, unsigned gsi, int shareable, char *name);
+/* Allocate a pirq for a physical interrupt, given a gsi. */
+int xen_allocate_pirq_gsi(unsigned gsi);
+/* Bind a pirq for a physical interrupt to an irq. */
+int xen_bind_pirq_gsi_to_irq(unsigned gsi,
+			     unsigned pirq, int shareable, char *name);
 
 #ifdef CONFIG_PCI_MSI
+/* Allocate a pirq for a MSI style physical interrupt. */
 int xen_allocate_pirq_msi(struct pci_dev *dev, struct msi_desc *msidesc);
+/* Bind an PSI pirq to an irq. */
 int xen_bind_pirq_msi_to_irq(struct pci_dev *dev, struct msi_desc *msidesc,
 			     int pirq, int vector, const char *name);
 #endif

commit 76465b2dafb8ce471f115b6af80f7a67a1fda377
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Mar 10 16:08:05 2011 +0000

    xen: events: remove unused public functions
    
    I was unable to find any user of these functions in either the
    functionality pending for 2.6.39 or the xen/next-2.6.32 branch of
    xen.git
    
    An exception to this was xen_gsi_from_irq which did appear to be used
    in xen/next-2.6.32's pciback. However in the 2.6.39 version of pciback
    xen_pirq_from_irq is, correctly AFAICT, used instead.
    
    Only a minority of functions in events.h use "extern" so drop it from
    those places for consistency.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index f6fed9498aa3..99a64f045732 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -41,9 +41,9 @@ static inline void notify_remote_via_evtchn(int port)
 	(void)HYPERVISOR_event_channel_op(EVTCHNOP_send, &send);
 }
 
-extern void notify_remote_via_irq(int irq);
+void notify_remote_via_irq(int irq);
 
-extern void xen_irq_resume(void);
+void xen_irq_resume(void);
 
 /* Clear an irq's pending state, in preparation for polling on it */
 void xen_clear_irq_pending(int irq);
@@ -62,7 +62,7 @@ void xen_poll_irq_timeout(int irq, u64 timeout);
 unsigned irq_from_evtchn(unsigned int evtchn);
 
 /* Xen HVM evtchn vector callback */
-extern void xen_hvm_callback_vector(void);
+void xen_hvm_callback_vector(void);
 extern int xen_have_vector_callback;
 int xen_set_callback_via(uint64_t via);
 void xen_evtchn_do_upcall(struct pt_regs *regs);
@@ -81,12 +81,6 @@ int xen_bind_pirq_msi_to_irq(struct pci_dev *dev, struct msi_desc *msidesc,
 /* De-allocates the above mentioned physical interrupt. */
 int xen_destroy_irq(int irq);
 
-/* Return vector allocated to pirq */
-int xen_vector_from_irq(unsigned pirq);
-
-/* Return gsi allocated to pirq */
-int xen_gsi_from_irq(unsigned pirq);
-
 /* Return irq from pirq */
 int xen_irq_from_pirq(unsigned pirq);
 

commit 653378acdd477a299f468e396c7719911ac57881
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Mar 10 16:08:04 2011 +0000

    xen: events: simplify comment
    
    It is never valid assume any particular relationship between a Xen
    PIRQ number and and Linux IRQ number so there is no need to hedge when
    saying so.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 962da2ced5b4..f6fed9498aa3 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -68,9 +68,7 @@ int xen_set_callback_via(uint64_t via);
 void xen_evtchn_do_upcall(struct pt_regs *regs);
 void xen_hvm_evtchn_do_upcall(void);
 
-/* Allocate an irq for a physical interrupt, given a gsi.  "Legacy"
- * GSIs are identity mapped; others are dynamically allocated as
- * usual. */
+/* Allocate an irq for a physical interrupt, given a gsi. */
 int xen_allocate_pirq(unsigned gsi, int shareable, char *name);
 int xen_map_pirq_gsi(unsigned pirq, unsigned gsi, int shareable, char *name);
 

commit 71eef7d1e3d9df760897fdd2cad6949a8bcf1620
Author: Ian Campbell <Ian.Campbell@citrix.com>
Date:   Fri Feb 18 17:06:55 2011 +0000

    xen: events: remove dom0 specific xen_create_msi_irq
    
    The function name does not distinguish it from xen_allocate_pirq_msi
    (which operates on domU and pvhvm domains rather than dom0).
    
    Hoist domain 0 specific functionality up into the only caller leaving
    functionality common to all guest types in xen_bind_pirq_msi_to_irq.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 45c08a0d580a..962da2ced5b4 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -78,7 +78,6 @@ int xen_map_pirq_gsi(unsigned pirq, unsigned gsi, int shareable, char *name);
 int xen_allocate_pirq_msi(struct pci_dev *dev, struct msi_desc *msidesc);
 int xen_bind_pirq_msi_to_irq(struct pci_dev *dev, struct msi_desc *msidesc,
 			     int pirq, int vector, const char *name);
-int xen_create_msi_irq(struct pci_dev *dev, struct msi_desc *msidesc, int type);
 #endif
 
 /* De-allocates the above mentioned physical interrupt. */

commit ca1d8fe9521fb67c95cfa736c08f4bbbc282b5bd
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Fri Feb 18 16:43:36 2011 +0000

    xen: events: use xen_bind_pirq_msi_to_irq from xen_create_msi_irq
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 18bf825bac66..45c08a0d580a 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -77,7 +77,7 @@ int xen_map_pirq_gsi(unsigned pirq, unsigned gsi, int shareable, char *name);
 #ifdef CONFIG_PCI_MSI
 int xen_allocate_pirq_msi(struct pci_dev *dev, struct msi_desc *msidesc);
 int xen_bind_pirq_msi_to_irq(struct pci_dev *dev, struct msi_desc *msidesc,
-			     int pirq, const char *name);
+			     int pirq, int vector, const char *name);
 int xen_create_msi_irq(struct pci_dev *dev, struct msi_desc *msidesc, int type);
 #endif
 

commit bf480d952bcf25e8ff7e95d2a23964107513ac51
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Fri Feb 18 16:43:32 2011 +0000

    xen: events: separate MSI PIRQ allocation from PIRQ binding to IRQ
    
    Split the binding aspect of xen_allocate_pirq_msi out into a new
    xen_bind_pirq_to_irq function.
    
    In xen_hvm_setup_msi_irq when allocating a pirq write the MSI message
    to signal the PIRQ as soon as the pirq is obtained. There is no way to
    free the pirq back so if the subsequent binding to an IRQ fails we
    want to ensure that we will reuse the PIRQ next time rather than leak
    it.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index f70536af921c..18bf825bac66 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -75,7 +75,9 @@ int xen_allocate_pirq(unsigned gsi, int shareable, char *name);
 int xen_map_pirq_gsi(unsigned pirq, unsigned gsi, int shareable, char *name);
 
 #ifdef CONFIG_PCI_MSI
-int xen_allocate_pirq_msi(char *name, int *pirq, int alloc_pirq);
+int xen_allocate_pirq_msi(struct pci_dev *dev, struct msi_desc *msidesc);
+int xen_bind_pirq_msi_to_irq(struct pci_dev *dev, struct msi_desc *msidesc,
+			     int pirq, const char *name);
 int xen_create_msi_irq(struct pci_dev *dev, struct msi_desc *msidesc, int type);
 #endif
 

commit 4b41df7f6e0b5684378d9155773c42a4577e8582
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Fri Feb 18 16:43:29 2011 +0000

    xen: events: return irq from xen_allocate_pirq_msi
    
    consistent with other similar functions.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 8d98861e4d92..f70536af921c 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -75,7 +75,7 @@ int xen_allocate_pirq(unsigned gsi, int shareable, char *name);
 int xen_map_pirq_gsi(unsigned pirq, unsigned gsi, int shareable, char *name);
 
 #ifdef CONFIG_PCI_MSI
-void xen_allocate_pirq_msi(char *name, int *irq, int *pirq, int alloc_pirq);
+int xen_allocate_pirq_msi(char *name, int *pirq, int alloc_pirq);
 int xen_create_msi_irq(struct pci_dev *dev, struct msi_desc *msidesc, int type);
 #endif
 

commit bb5d079aefa828c292c267ed34ed2282947fa233
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Fri Feb 18 16:43:28 2011 +0000

    xen: events: drop XEN_ALLOC_IRQ flag to xen_allocate_pirq_msi
    
    All callers pass this flag so it is pointless.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 00f53ddcc062..8d98861e4d92 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -75,10 +75,7 @@ int xen_allocate_pirq(unsigned gsi, int shareable, char *name);
 int xen_map_pirq_gsi(unsigned pirq, unsigned gsi, int shareable, char *name);
 
 #ifdef CONFIG_PCI_MSI
-/* Allocate an irq and a pirq to be used with MSIs. */
-#define XEN_ALLOC_PIRQ (1 << 0)
-#define XEN_ALLOC_IRQ  (1 << 1)
-void xen_allocate_pirq_msi(char *name, int *irq, int *pirq, int alloc_mask);
+void xen_allocate_pirq_msi(char *name, int *irq, int *pirq, int alloc_pirq);
 int xen_create_msi_irq(struct pci_dev *dev, struct msi_desc *msidesc, int type);
 #endif
 

commit 2e820f58f7ad8eaca2f194ccdfea0de63e9c6d78
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Mon Feb 9 12:05:50 2009 -0800

    xen/irq: implement bind_interdomain_evtchn_to_irqhandler for backend drivers
    
    Impact: new Xen-internal API
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 00f53ddcc062..bd03b1e4a2f4 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -23,6 +23,12 @@ int bind_ipi_to_irqhandler(enum ipi_vector ipi,
 			   unsigned long irqflags,
 			   const char *devname,
 			   void *dev_id);
+int bind_interdomain_evtchn_to_irqhandler(unsigned int remote_domain,
+					  unsigned int remote_port,
+					  irq_handler_t handler,
+					  unsigned long irqflags,
+					  const char *devname,
+					  void *dev_id);
 
 /*
  * Common unbind function for all event sources. Takes IRQ to unbind from.

commit af42b8d12f8adec6711cb824549a0edac6a4ae8f
Author: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
Date:   Wed Dec 1 14:51:44 2010 +0000

    xen: fix MSI setup and teardown for PV on HVM guests
    
    When remapping MSIs into pirqs for PV on HVM guests, qemu is responsible
    for doing the actual mapping and unmapping.
    We only give qemu the desired pirq number when we ask to do the mapping
    the first time, after that we should be reading back the pirq number
    from qemu every time we want to re-enable the MSI.
    
    This fixes a bug in xen_hvm_setup_msi_irqs that manifests itself when
    trying to enable the same MSI for the second time: the old MSI to pirq
    mapping is still valid at this point but xen_hvm_setup_msi_irqs would
    try to assign a new pirq anyway.
    A simple way to reproduce this bug is to assign an MSI capable network
    card to a PV on HVM guest, if the user brings down the corresponding
    ethernet interface and up again, Linux would fail to enable MSIs on the
    device.
    
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 646dd17d3aa4..00f53ddcc062 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -76,7 +76,9 @@ int xen_map_pirq_gsi(unsigned pirq, unsigned gsi, int shareable, char *name);
 
 #ifdef CONFIG_PCI_MSI
 /* Allocate an irq and a pirq to be used with MSIs. */
-void xen_allocate_pirq_msi(char *name, int *irq, int *pirq);
+#define XEN_ALLOC_PIRQ (1 << 0)
+#define XEN_ALLOC_IRQ  (1 << 1)
+void xen_allocate_pirq_msi(char *name, int *irq, int *pirq, int alloc_mask);
 int xen_create_msi_irq(struct pci_dev *dev, struct msi_desc *msidesc, int type);
 #endif
 
@@ -89,4 +91,7 @@ int xen_vector_from_irq(unsigned pirq);
 /* Return gsi allocated to pirq */
 int xen_gsi_from_irq(unsigned pirq);
 
+/* Return irq from pirq */
+int xen_irq_from_pirq(unsigned pirq);
+
 #endif	/* _XEN_EVENTS_H */

commit 4fe7d5a708a955b35e3fdc4dea3e0b7a6ae2eb06
Author: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
Date:   Thu Sep 2 16:17:06 2010 +0100

    xen: make hvc_xen console work for dom0.
    
    Use the console hypercalls for dom0 console.
    
    [ Impact: Add Xen dom0 console ]
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Juan Quintela <quintela@redhat.com>
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 8fa27dc7358b..646dd17d3aa4 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -12,6 +12,7 @@ int bind_evtchn_to_irqhandler(unsigned int evtchn,
 			      irq_handler_t handler,
 			      unsigned long irqflags, const char *devname,
 			      void *dev_id);
+int bind_virq_to_irq(unsigned int virq, unsigned int cpu);
 int bind_virq_to_irqhandler(unsigned int virq, unsigned int cpu,
 			    irq_handler_t handler,
 			    unsigned long irqflags, const char *devname,

commit f731e3ef02b4744f4d7ca2f63539b900e47db31f
Author: Qing He <qing.he@intel.com>
Date:   Mon Oct 11 15:30:09 2010 +0100

    xen: remap MSIs into pirqs when running as initial domain
    
    Implement xen_create_msi_irq to create an msi and remap it as pirq.
    Use xen_create_msi_irq to implement an initial domain specific version
    of setup_msi_irqs.
    
    Signed-off-by: Qing He <qing.he@intel.com>
    Signed-off-by: Yunhong Jiang <yunhong.jiang@intel.com>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 0c58db6ea3f4..8fa27dc7358b 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -72,8 +72,12 @@ void xen_hvm_evtchn_do_upcall(void);
  * usual. */
 int xen_allocate_pirq(unsigned gsi, int shareable, char *name);
 int xen_map_pirq_gsi(unsigned pirq, unsigned gsi, int shareable, char *name);
+
+#ifdef CONFIG_PCI_MSI
 /* Allocate an irq and a pirq to be used with MSIs. */
 void xen_allocate_pirq_msi(char *name, int *irq, int *pirq);
+int xen_create_msi_irq(struct pci_dev *dev, struct msi_desc *msidesc, int type);
+#endif
 
 /* De-allocates the above mentioned physical interrupt. */
 int xen_destroy_irq(int irq);

commit 809f9267bbaba7765cdb86a47f2e6e4bf4951b69
Author: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
Date:   Thu Jul 1 17:10:39 2010 +0100

    xen: map MSIs into pirqs
    
    Map MSIs into pirqs, writing 0 in the MSI vector data field and the pirq
    number in the MSI destination id field.
    
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index deec8faace22..0c58db6ea3f4 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -72,6 +72,8 @@ void xen_hvm_evtchn_do_upcall(void);
  * usual. */
 int xen_allocate_pirq(unsigned gsi, int shareable, char *name);
 int xen_map_pirq_gsi(unsigned pirq, unsigned gsi, int shareable, char *name);
+/* Allocate an irq and a pirq to be used with MSIs. */
+void xen_allocate_pirq_msi(char *name, int *irq, int *pirq);
 
 /* De-allocates the above mentioned physical interrupt. */
 int xen_destroy_irq(int irq);

commit 7a043f119c0e4b460306f868d9638ac55c6afa6f
Author: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
Date:   Thu Jul 1 17:08:14 2010 +0100

    xen: support pirq != irq
    
    PHYSDEVOP_map_pirq might return a pirq different from what we asked if
    we are running as an HVM guest, so we need to be able to support pirqs
    that are different from linux irqs.
    
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index c1717ca5ac13..deec8faace22 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -71,6 +71,7 @@ void xen_hvm_evtchn_do_upcall(void);
  * GSIs are identity mapped; others are dynamically allocated as
  * usual. */
 int xen_allocate_pirq(unsigned gsi, int shareable, char *name);
+int xen_map_pirq_gsi(unsigned pirq, unsigned gsi, int shareable, char *name);
 
 /* De-allocates the above mentioned physical interrupt. */
 int xen_destroy_irq(int irq);

commit b5401a96b59475c1c878439caecb8c521bdfd4ad
Author: Alex Nixon <alex.nixon@citrix.com>
Date:   Thu Mar 18 16:31:34 2010 -0400

    xen/x86/PCI: Add support for the Xen PCI subsystem
    
    The frontend stub lives in arch/x86/pci/xen.c, alongside other
    sub-arch PCI init code (e.g. olpc.c).
    
    It provides a mechanism for Xen PCI frontend to setup/destroy
    legacy interrupts, MSI/MSI-X, and PCI configuration operations.
    
    [ Impact: add core of Xen PCI support ]
    [ v2: Removed the IOMMU code and only focusing on PCI.]
    [ v3: removed usage of pci_scan_all_fns as that does not exist]
    [ v4: introduced pci_xen value to fix compile warnings]
    [ v5: squished fixes+features in one patch, changed Reviewed-by to Ccs]
    [ v7: added Acked-by]
    Signed-off-by: Alex Nixon <alex.nixon@citrix.com>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Matthew Wilcox <willy@linux.intel.com>
    Cc: Qing He <qing.he@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: x86@kernel.org

diff --git a/include/xen/events.h b/include/xen/events.h
index d7a4ca7d17b5..c1717ca5ac13 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -72,6 +72,9 @@ void xen_hvm_evtchn_do_upcall(void);
  * usual. */
 int xen_allocate_pirq(unsigned gsi, int shareable, char *name);
 
+/* De-allocates the above mentioned physical interrupt. */
+int xen_destroy_irq(int irq);
+
 /* Return vector allocated to pirq */
 int xen_vector_from_irq(unsigned pirq);
 

commit 15ebbb82bac700db3c91e662fb70cb3559e9d930
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Mon Oct 4 13:43:27 2010 -0400

    xen: fix shared irq device passthrough
    
    In driver/xen/events.c, whether bind_pirq is shareable or not is
    determined by desc->action is NULL or not. But in __setup_irq,
    startup(irq) is invoked before desc->action is assigned with
    new action. So desc->action in startup_irq is always NULL, and
    bind_pirq is always not shareable. This results in pt_irq_create_bind
    failure when passthrough a device which shares irq to other devices.
    
    This patch doesn't use probing_irq to determine if pirq is shareable
    or not, instead set shareable flag in irq_info according to trigger
    mode in xen_allocate_pirq. Set level triggered interrupts shareable.
    Thus use this flag to set bind_pirq flag accordingly.
    
    [v2: arch/x86/xen/pci.c no more, so file skipped]
    
    Signed-off-by: Weidong Han <weidong.han@intel.com>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 2532f8bd2401..d7a4ca7d17b5 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -70,7 +70,7 @@ void xen_hvm_evtchn_do_upcall(void);
 /* Allocate an irq for a physical interrupt, given a gsi.  "Legacy"
  * GSIs are identity mapped; others are dynamically allocated as
  * usual. */
-int xen_allocate_pirq(unsigned gsi, char *name);
+int xen_allocate_pirq(unsigned gsi, int shareable, char *name);
 
 /* Return vector allocated to pirq */
 int xen_vector_from_irq(unsigned pirq);

commit d9a8814f27080cec6126fca3ef0c210d9f56181e
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Thu Nov 5 16:33:09 2009 -0500

    xen: Provide a variant of xen_poll_irq with timeout.
    
    The 'xen_poll_irq_timeout' provides a method to pass in
    the poll timeout for IRQs if requested. We also export
    those two poll functions as Xen PCI fronted uses them.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 8227da8f7165..2532f8bd2401 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -53,6 +53,10 @@ bool xen_test_irq_pending(int irq);
    irq will be disabled so it won't deliver an interrupt. */
 void xen_poll_irq(int irq);
 
+/* Poll waiting for an irq to become pending with a timeout.  In the usual case,
+ * the irq will be disabled so it won't deliver an interrupt. */
+void xen_poll_irq_timeout(int irq, u64 timeout);
+
 /* Determine the IRQ which is bound to an event channel */
 unsigned irq_from_evtchn(unsigned int evtchn);
 

commit 1a60d05f40882303dad13f8f0e077e2e49ea8996
Author: Gerd Hoffmann <kraxel@xeni.home.kraxel.org>
Date:   Mon Oct 4 13:42:27 2010 -0400

    xen: set pirq name to something useful.
    
    Impact: cleanup
    
    Make pirq show useful information in /proc/interrupts
    
    [v2: Removed the parts for arch/x86/xen/pci.c ]
    
    Signed-off-by: Gerd Hoffmann <kraxel@xeni.home.kraxel.org>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 8f6232023b75..8227da8f7165 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -66,7 +66,7 @@ void xen_hvm_evtchn_do_upcall(void);
 /* Allocate an irq for a physical interrupt, given a gsi.  "Legacy"
  * GSIs are identity mapped; others are dynamically allocated as
  * usual. */
-int xen_allocate_pirq(unsigned gsi);
+int xen_allocate_pirq(unsigned gsi, char *name);
 
 /* Return vector allocated to pirq */
 int xen_vector_from_irq(unsigned pirq);

commit d46a78b05c0e37f76ddf4a7a67bf0b6c68bada55
Author: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
Date:   Fri Oct 1 12:20:09 2010 -0400

    xen: implement pirq type event channels
    
    A privileged PV Xen domain can get direct access to hardware.  In
    order for this to be useful, it must be able to get hardware
    interrupts.
    
    Being a PV Xen domain, all interrupts are delivered as event channels.
    PIRQ event channels are bound to a pirq number and an interrupt
    vector.  When a IO APIC raises a hardware interrupt on that vector, it
    is delivered as an event channel, which we can deliver to the
    appropriate device driver(s).
    
    This patch simply implements the infrastructure for dealing with pirq
    event channels.
    
    [ Impact: integrate hardware interrupts into Xen's event scheme ]
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index a15d93262e30..8f6232023b75 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -63,4 +63,15 @@ int xen_set_callback_via(uint64_t via);
 void xen_evtchn_do_upcall(struct pt_regs *regs);
 void xen_hvm_evtchn_do_upcall(void);
 
+/* Allocate an irq for a physical interrupt, given a gsi.  "Legacy"
+ * GSIs are identity mapped; others are dynamically allocated as
+ * usual. */
+int xen_allocate_pirq(unsigned gsi);
+
+/* Return vector allocated to pirq */
+int xen_vector_from_irq(unsigned pirq);
+
+/* Return gsi allocated to pirq */
+int xen_gsi_from_irq(unsigned pirq);
+
 #endif	/* _XEN_EVENTS_H */

commit 38e20b07efd541a959de367dc90a17f92ce2e8a6
Author: Sheng Yang <sheng@linux.intel.com>
Date:   Fri May 14 12:40:51 2010 +0100

    x86/xen: event channels delivery on HVM.
    
    Set the callback to receive evtchns from Xen, using the
    callback vector delivery mechanism.
    
    The traditional way for receiving event channel notifications from Xen
    is via the interrupts from the platform PCI device.
    The callback vector is a newer alternative that allow us to receive
    notifications on any vcpu and doesn't need any PCI support: we allocate
    a vector exclusively to receive events, in the vector handler we don't
    need to interact with the vlapic, therefore we avoid a VMEXIT.
    
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Signed-off-by: Sheng Yang <sheng@linux.intel.com>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index e68d59a90ca8..a15d93262e30 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -56,4 +56,11 @@ void xen_poll_irq(int irq);
 /* Determine the IRQ which is bound to an event channel */
 unsigned irq_from_evtchn(unsigned int evtchn);
 
+/* Xen HVM evtchn vector callback */
+extern void xen_hvm_callback_vector(void);
+extern int xen_have_vector_callback;
+int xen_set_callback_via(uint64_t via);
+void xen_evtchn_do_upcall(struct pt_regs *regs);
+void xen_hvm_evtchn_do_upcall(void);
+
 #endif	/* _XEN_EVENTS_H */

commit d4c045364d3107603187f21a56ec231e74d26441
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Fri Feb 6 19:20:31 2009 -0800

    xen: add irq_from_evtchn
    
    Given an evtchn, return the corresponding irq.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>

diff --git a/include/xen/events.h b/include/xen/events.h
index 0d5f1adc0363..e68d59a90ca8 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -53,4 +53,7 @@ bool xen_test_irq_pending(int irq);
    irq will be disabled so it won't deliver an interrupt. */
 void xen_poll_irq(int irq);
 
+/* Determine the IRQ which is bound to an event channel */
+unsigned irq_from_evtchn(unsigned int evtchn);
+
 #endif	/* _XEN_EVENTS_H */

commit 168d2f464ab9860f0d1e66cf1f9684973222f1c6
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Wed Aug 20 17:02:18 2008 -0700

    xen: save previous spinlock when blocking
    
    A spinlock can be interrupted while spinning, so make sure we preserve
    the previous lock of interest if we're taking a lock from within an
    interrupt handler.
    
    We also need to deal with the case where the blocking path gets
    interrupted between testing to see if the lock is free and actually
    blocking.  If we get interrupted there and end up in the state where
    the lock is free but the irq isn't pending, then we'll block
    indefinitely in the hypervisor.  This fix is to make sure that any
    nested lock-takers will always leave the irq pending if there's any
    chance the outer lock became free.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Acked-by: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/xen/events.h b/include/xen/events.h
index 4680ff3fbc91..0d5f1adc0363 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -46,6 +46,8 @@ extern void xen_irq_resume(void);
 
 /* Clear an irq's pending state, in preparation for polling on it */
 void xen_clear_irq_pending(int irq);
+void xen_set_irq_pending(int irq);
+bool xen_test_irq_pending(int irq);
 
 /* Poll waiting for an irq to become pending.  In the usual case, the
    irq will be disabled so it won't deliver an interrupt. */

commit 2d9e1e2f58b5612aa4eab0ab54c84308a29dbd79
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Mon Jul 7 12:07:53 2008 -0700

    xen: implement Xen-specific spinlocks
    
    The standard ticket spinlocks are very expensive in a virtual
    environment, because their performance depends on Xen's scheduler
    giving vcpus time in the order that they're supposed to take the
    spinlock.
    
    This implements a Xen-specific spinlock, which should be much more
    efficient.
    
    The fast-path is essentially the old Linux-x86 locks, using a single
    lock byte.  The locker decrements the byte; if the result is 0, then
    they have the lock.  If the lock is negative, then locker must spin
    until the lock is positive again.
    
    When there's contention, the locker spin for 2^16[*] iterations waiting
    to get the lock.  If it fails to get the lock in that time, it adds
    itself to the contention count in the lock and blocks on a per-cpu
    event channel.
    
    When unlocking the spinlock, the locker looks to see if there's anyone
    blocked waiting for the lock by checking for a non-zero waiter count.
    If there's a waiter, it traverses the per-cpu "lock_spinners"
    variable, which contains which lock each CPU is waiting on.  It picks
    one CPU waiting on the lock and sends it an event to wake it up.
    
    This allows efficient fast-path spinlock operation, while allowing
    spinning vcpus to give up their processor time while waiting for a
    contended lock.
    
    [*] 2^16 iterations is threshold at which 98% locks have been taken
    according to Thomas Friebel's Xen Summit talk "Preventing Guests from
    Spinning Around".  Therefore, we'd expect the lock and unlock slow
    paths will only be entered 2% of the time.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Christoph Lameter <clameter@linux-foundation.org>
    Cc: Petr Tesarik <ptesarik@suse.cz>
    Cc: Virtualization <virtualization@lists.linux-foundation.org>
    Cc: Xen devel <xen-devel@lists.xensource.com>
    Cc: Thomas Friebel <thomas.friebel@amd.com>
    Cc: Nick Piggin <nickpiggin@yahoo.com.au>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/xen/events.h b/include/xen/events.h
index 67c4436554a9..4680ff3fbc91 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -44,4 +44,11 @@ extern void notify_remote_via_irq(int irq);
 
 extern void xen_irq_resume(void);
 
+/* Clear an irq's pending state, in preparation for polling on it */
+void xen_clear_irq_pending(int irq);
+
+/* Poll waiting for an irq to become pending.  In the usual case, the
+   irq will be disabled so it won't deliver an interrupt. */
+void xen_poll_irq(int irq);
+
 #endif	/* _XEN_EVENTS_H */

commit 0e91398f2a5d4eb6b07df8115917d0d1cf3e9b58
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Mon May 26 23:31:27 2008 +0100

    xen: implement save/restore
    
    This patch implements Xen save/restore and migration.
    
    Saving is triggered via xenbus, which is polled in
    drivers/xen/manage.c.  When a suspend request comes in, the kernel
    prepares itself for saving by:
    
    1 - Freeze all processes.  This is primarily to prevent any
        partially-completed pagetable updates from confusing the suspend
        process.  If CONFIG_PREEMPT isn't defined, then this isn't necessary.
    
    2 - Suspend xenbus and other devices
    
    3 - Stop_machine, to make sure all the other vcpus are quiescent.  The
        Xen tools require the domain to run its save off vcpu0.
    
    4 - Within the stop_machine state, it pins any unpinned pgds (under
        construction or destruction), performs canonicalizes various other
        pieces of state (mostly converting mfns to pfns), and finally
    
    5 - Suspend the domain
    
    Restore reverses the steps used to save the domain, ending when all
    the frozen processes are thawed.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/xen/events.h b/include/xen/events.h
index a82ec0c45c38..67c4436554a9 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -41,4 +41,7 @@ static inline void notify_remote_via_evtchn(int port)
 }
 
 extern void notify_remote_via_irq(int irq);
+
+extern void xen_irq_resume(void);
+
 #endif	/* _XEN_EVENTS_H */

commit eb1e305f4ef201e549ffd475b7dcbcd4ec36d7dc
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Mon May 26 23:31:23 2008 +0100

    xen: add rebind_evtchn_irq
    
    Add rebind_evtchn_irq(), which will rebind an device driver's existing
    irq to a new event channel on restore.  Since the new event channel
    will be masked and bound to vcpu0, we update the state accordingly and
    unmask the irq once everything is set up.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/xen/events.h b/include/xen/events.h
index acd8e062c85f..a82ec0c45c38 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -32,6 +32,7 @@ void unbind_from_irqhandler(unsigned int irq, void *dev_id);
 
 void xen_send_IPI_one(unsigned int cpu, enum ipi_vector vector);
 int resend_irq_on_evtchn(unsigned int irq);
+void rebind_evtchn_irq(int evtchn, int irq);
 
 static inline void notify_remote_via_evtchn(int port)
 {

commit 642e0c882cd5369429c833d97e4804c8be473e8a
Author: Isaku Yamahata <yamahata@valinux.co.jp>
Date:   Wed Apr 2 10:53:57 2008 -0700

    xen: add resend_irq_on_evtchn() definition into events.c
    
    Define resend_irq_on_evtchn() which ia64/xen uses.
    Although it isn't used by current x86/xen code, it's arch generic
    so that put it into common code.
    
    Signed-off-by: Isaku Yamahata <yamahata@valinux.co.jp>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/xen/events.h b/include/xen/events.h
index d99a3e0df880..acd8e062c85f 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -31,6 +31,7 @@ int bind_ipi_to_irqhandler(enum ipi_vector ipi,
 void unbind_from_irqhandler(unsigned int irq, void *dev_id);
 
 void xen_send_IPI_one(unsigned int cpu, enum ipi_vector vector);
+int resend_irq_on_evtchn(unsigned int irq);
 
 static inline void notify_remote_via_evtchn(int port)
 {

commit e849c3e9e0b786619c451d89ef0c47ac9a28fbc1
Author: Isaku Yamahata <yamahata@valinux.co.jp>
Date:   Wed Apr 2 10:53:56 2008 -0700

    Xen: make events.c portable for ia64/xen support
    
    Remove x86 dependency in drivers/xen/events.c for ia64/xen support
    introducing include/asm/xen/events.h.
    Introduce xen_irqs_disabled() to hide regs->flags
    Introduce xen_do_IRQ() to hide regs->orig_ax.
    make enum ipi_vector definition arch specific. ia64/xen needs four vectors.
    Add one rmb() because on ia64 xchg() isn't barrier.
    
    Signed-off-by: Isaku Yamahata <yamahata@valinux.co.jp>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/xen/events.h b/include/xen/events.h
index 2bde54d29be5..d99a3e0df880 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -5,13 +5,7 @@
 
 #include <xen/interface/event_channel.h>
 #include <asm/xen/hypercall.h>
-
-enum ipi_vector {
-	XEN_RESCHEDULE_VECTOR,
-	XEN_CALL_FUNCTION_VECTOR,
-
-	XEN_NR_IPIS,
-};
+#include <asm/xen/events.h>
 
 int bind_evtchn_to_irq(unsigned int evtchn);
 int bind_evtchn_to_irqhandler(unsigned int evtchn,

commit b536b4b9623084d86f2b1f19cb44a2d6d74f00bf
Author: Jeremy Fitzhardinge <jeremy@xensource.com>
Date:   Tue Jul 17 18:37:06 2007 -0700

    xen: use the hvc console infrastructure for Xen console
    
    Implement a Xen back-end for hvc console.
    
    * * *
    Add early printk support via hvc console, enable using
    "earlyprintk=xen" on the kernel command line.
    
    From: Gerd Hoffmann <kraxel@suse.de>
    Signed-off-by: Jeremy Fitzhardinge <jeremy@xensource.com>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Olof Johansson <olof@lixom.net>

diff --git a/include/xen/events.h b/include/xen/events.h
index 7abe4ddfac54..2bde54d29be5 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -13,6 +13,7 @@ enum ipi_vector {
 	XEN_NR_IPIS,
 };
 
+int bind_evtchn_to_irq(unsigned int evtchn);
 int bind_evtchn_to_irqhandler(unsigned int evtchn,
 			      irq_handler_t handler,
 			      unsigned long irqflags, const char *devname,

commit f87e4cac4f4e940b328d3deb5b53e642e3881f43
Author: Jeremy Fitzhardinge <jeremy@xensource.com>
Date:   Tue Jul 17 18:37:06 2007 -0700

    xen: SMP guest support
    
    This is a fairly straightforward Xen implementation of smp_ops.
    
    Xen has its own IPI mechanisms, and has no dependency on any
    APIC-based IPI.  The smp_ops hooks and the flush_tlb_others pv_op
    allow a Xen guest to avoid all APIC code in arch/i386 (the only apic
    operation is a single apic_read for the apic version number).
    
    One subtle point which needs to be addressed is unpinning pagetables
    when another cpu may have a lazy tlb reference to the pagetable. Xen
    will not allow an in-use pagetable to be unpinned, so we must find any
    other cpus with a reference to the pagetable and get them to shoot
    down their references.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy@xensource.com>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Cc: Benjamin LaHaise <bcrl@kvack.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Andi Kleen <ak@suse.de>

diff --git a/include/xen/events.h b/include/xen/events.h
index 77f71c906823..7abe4ddfac54 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -1,15 +1,32 @@
 #ifndef _XEN_EVENTS_H
 #define _XEN_EVENTS_H
 
-#include <linux/irq.h>
+#include <linux/interrupt.h>
+
+#include <xen/interface/event_channel.h>
+#include <asm/xen/hypercall.h>
+
+enum ipi_vector {
+	XEN_RESCHEDULE_VECTOR,
+	XEN_CALL_FUNCTION_VECTOR,
+
+	XEN_NR_IPIS,
+};
 
 int bind_evtchn_to_irqhandler(unsigned int evtchn,
-			      irqreturn_t (*handler)(int, void *),
+			      irq_handler_t handler,
 			      unsigned long irqflags, const char *devname,
 			      void *dev_id);
 int bind_virq_to_irqhandler(unsigned int virq, unsigned int cpu,
-			    irqreturn_t (*handler)(int, void *),
-			    unsigned long irqflags, const char *devname, void *dev_id);
+			    irq_handler_t handler,
+			    unsigned long irqflags, const char *devname,
+			    void *dev_id);
+int bind_ipi_to_irqhandler(enum ipi_vector ipi,
+			   unsigned int cpu,
+			   irq_handler_t handler,
+			   unsigned long irqflags,
+			   const char *devname,
+			   void *dev_id);
 
 /*
  * Common unbind function for all event sources. Takes IRQ to unbind from.
@@ -18,6 +35,8 @@ int bind_virq_to_irqhandler(unsigned int virq, unsigned int cpu,
  */
 void unbind_from_irqhandler(unsigned int irq, void *dev_id);
 
+void xen_send_IPI_one(unsigned int cpu, enum ipi_vector vector);
+
 static inline void notify_remote_via_evtchn(int port)
 {
 	struct evtchn_send send = { .port = port };

commit e46cdb66c8fc1c8d61cfae0f219ff47ac4b9d531
Author: Jeremy Fitzhardinge <jeremy@xensource.com>
Date:   Tue Jul 17 18:37:05 2007 -0700

    xen: event channels
    
    Xen implements interrupts in terms of event channels.  Each guest
    domain gets 1024 event channels which can be used for a variety of
    purposes, such as Xen timer events, inter-domain events,
    inter-processor events (IPI) or for real hardware IRQs.
    
    Within the kernel, we map the event channels to IRQs, and implement
    the whole interrupt handling using a Xen irq_chip.
    
    Rather than setting NR_IRQ to 1024 under PARAVIRT in order to
    accomodate Xen, we create a dynamic mapping between event channels and
    IRQs.  Ideally, Linux will eventually move towards dynamically
    allocating per-irq structures, and we can use a 1:1 mapping between
    event channels and irqs.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy@xensource.com>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/xen/events.h b/include/xen/events.h
new file mode 100644
index 000000000000..77f71c906823
--- /dev/null
+++ b/include/xen/events.h
@@ -0,0 +1,28 @@
+#ifndef _XEN_EVENTS_H
+#define _XEN_EVENTS_H
+
+#include <linux/irq.h>
+
+int bind_evtchn_to_irqhandler(unsigned int evtchn,
+			      irqreturn_t (*handler)(int, void *),
+			      unsigned long irqflags, const char *devname,
+			      void *dev_id);
+int bind_virq_to_irqhandler(unsigned int virq, unsigned int cpu,
+			    irqreturn_t (*handler)(int, void *),
+			    unsigned long irqflags, const char *devname, void *dev_id);
+
+/*
+ * Common unbind function for all event sources. Takes IRQ to unbind from.
+ * Automatically closes the underlying event channel (even for bindings
+ * made with bind_evtchn_to_irqhandler()).
+ */
+void unbind_from_irqhandler(unsigned int irq, void *dev_id);
+
+static inline void notify_remote_via_evtchn(int port)
+{
+	struct evtchn_send send = { .port = port };
+	(void)HYPERVISOR_event_channel_op(EVTCHNOP_send, &send);
+}
+
+extern void notify_remote_via_irq(int irq);
+#endif	/* _XEN_EVENTS_H */
