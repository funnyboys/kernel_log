commit 2434f7d2d488c3301ae81f1031e1c66c6f076fb7
Author: Nayna Jain <nayna@linux.ibm.com>
Date:   Wed Oct 30 23:31:31 2019 -0400

    certs: Add wrapper function to check blacklisted binary hash
    
    The -EKEYREJECTED error returned by existing is_hash_blacklisted() is
    misleading when called for checking against blacklisted hash of a
    binary.
    
    This patch adds a wrapper function is_binary_blacklisted() to return
    -EPERM error if binary is blacklisted.
    
    Signed-off-by: Nayna Jain <nayna@linux.ibm.com>
    Reviewed-by: Mimi Zohar <zohar@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/1572492694-6520-7-git-send-email-zohar@linux.ibm.com

diff --git a/include/keys/system_keyring.h b/include/keys/system_keyring.h
index c1a96fdf598b..fb8b07daa9d1 100644
--- a/include/keys/system_keyring.h
+++ b/include/keys/system_keyring.h
@@ -35,12 +35,18 @@ extern int restrict_link_by_builtin_and_secondary_trusted(
 extern int mark_hash_blacklisted(const char *hash);
 extern int is_hash_blacklisted(const u8 *hash, size_t hash_len,
 			       const char *type);
+extern int is_binary_blacklisted(const u8 *hash, size_t hash_len);
 #else
 static inline int is_hash_blacklisted(const u8 *hash, size_t hash_len,
 				      const char *type)
 {
 	return 0;
 }
+
+static inline int is_binary_blacklisted(const u8 *hash, size_t hash_len)
+{
+	return 0;
+}
 #endif
 
 #ifdef CONFIG_IMA_BLACKLIST_KEYRING

commit b4d0d230ccfb5d1a9ea85da64aa584df7c148ee9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 19:08:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 36
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public licence as published by
      the free software foundation either version 2 of the licence or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 114 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520170857.552531963@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/keys/system_keyring.h b/include/keys/system_keyring.h
index 42a93eda331c..c1a96fdf598b 100644
--- a/include/keys/system_keyring.h
+++ b/include/keys/system_keyring.h
@@ -1,12 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /* System keyring containing trusted public keys.
  *
  * Copyright (C) 2013 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public Licence
- * as published by the Free Software Foundation; either version
- * 2 of the Licence, or (at your option) any later version.
  */
 
 #ifndef _KEYS_SYSTEM_KEYRING_H

commit 219a3e8676f3132d27b530c7d2d6bcab89536b57
Author: Kairui Song <kasong@redhat.com>
Date:   Mon Jan 21 17:59:28 2019 +0800

    integrity, KEYS: add a reference to platform keyring
    
    commit 9dc92c45177a ("integrity: Define a trusted platform keyring")
    introduced a .platform keyring for storing preboot keys, used for
    verifying kernel image signatures. Currently only IMA-appraisal is able
    to use the keyring to verify kernel images that have their signature
    stored in xattr.
    
    This patch exposes the .platform keyring, making it accessible for
    verifying PE signed kernel images as well.
    
    Suggested-by: Mimi Zohar <zohar@linux.ibm.com>
    Signed-off-by: Kairui Song <kasong@redhat.com>
    Cc: David Howells <dhowells@redhat.com>
    [zohar@linux.ibm.com: fixed checkpatch errors, squashed with patch fix]
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/include/keys/system_keyring.h b/include/keys/system_keyring.h
index 359c2f936004..42a93eda331c 100644
--- a/include/keys/system_keyring.h
+++ b/include/keys/system_keyring.h
@@ -61,5 +61,13 @@ static inline struct key *get_ima_blacklist_keyring(void)
 }
 #endif /* CONFIG_IMA_BLACKLIST_KEYRING */
 
+#if defined(CONFIG_INTEGRITY_PLATFORM_KEYRING) && \
+	defined(CONFIG_SYSTEM_TRUSTED_KEYRING)
+extern void __init set_platform_trusted_keys(struct key *keyring);
+#else
+static inline void set_platform_trusted_keys(struct key *keyring)
+{
+}
+#endif
 
 #endif /* _KEYS_SYSTEM_KEYRING_H */

commit aaf66c883813f0078e3dafe7d20d1461321ac14f
Author: Mat Martineau <mathew.j.martineau@linux.intel.com>
Date:   Tue Aug 30 11:33:13 2016 -0700

    KEYS: Split role of the keyring pointer for keyring restrict functions
    
    The first argument to the restrict_link_func_t functions was a keyring
    pointer. These functions are called by the key subsystem with this
    argument set to the destination keyring, but restrict_link_by_signature
    expects a pointer to the relevant trusted keyring.
    
    Restrict functions may need something other than a single struct key
    pointer to allow or reject key linkage, so the data used to make that
    decision (such as the trust keyring) is moved to a new, fourth
    argument. The first argument is now always the destination keyring.
    
    Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>

diff --git a/include/keys/system_keyring.h b/include/keys/system_keyring.h
index 0d8762622ab9..359c2f936004 100644
--- a/include/keys/system_keyring.h
+++ b/include/keys/system_keyring.h
@@ -18,7 +18,8 @@
 
 extern int restrict_link_by_builtin_trusted(struct key *keyring,
 					    const struct key_type *type,
-					    const union key_payload *payload);
+					    const union key_payload *payload,
+					    struct key *restriction_key);
 
 #else
 #define restrict_link_by_builtin_trusted restrict_link_reject
@@ -28,7 +29,8 @@ extern int restrict_link_by_builtin_trusted(struct key *keyring,
 extern int restrict_link_by_builtin_and_secondary_trusted(
 	struct key *keyring,
 	const struct key_type *type,
-	const union key_payload *payload);
+	const union key_payload *payload,
+	struct key *restriction_key);
 #else
 #define restrict_link_by_builtin_and_secondary_trusted restrict_link_by_builtin_trusted
 #endif

commit 734114f8782f6c3398762f2353fe9101d87b6d06
Author: David Howells <dhowells@redhat.com>
Date:   Mon Apr 3 16:07:24 2017 +0100

    KEYS: Add a system blacklist keyring
    
    Add the following:
    
     (1) A new system keyring that is used to store information about
         blacklisted certificates and signatures.
    
     (2) A new key type (called 'blacklist') that is used to store a
         blacklisted hash in its description as a hex string.  The key accepts
         no payload.
    
     (3) The ability to configure a list of blacklisted hashes into the kernel
         at build time.  This is done by setting
         CONFIG_SYSTEM_BLACKLIST_HASH_LIST to the filename of a list of hashes
         that are in the form:
    
            "<hash>", "<hash>", ..., "<hash>"
    
         where each <hash> is a hex string representation of the hash and must
         include all necessary leading zeros to pad the hash to the right size.
    
    The above are enabled with CONFIG_SYSTEM_BLACKLIST_KEYRING.
    
    Once the kernel is booted, the blacklist keyring can be listed:
    
            root@andromeda ~]# keyctl show %:.blacklist
            Keyring
             723359729 ---lswrv      0     0  keyring: .blacklist
             676257228 ---lswrv      0     0   \_ blacklist: 123412341234c55c1dcc601ab8e172917706aa32fb5eaf826813547fdf02dd46
    
    The blacklist cannot currently be modified by userspace, but it will be
    possible to load it, for example, from the UEFI blacklist database.
    
    A later commit will make it possible to load blacklisted asymmetric keys in
    here too.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/keys/system_keyring.h b/include/keys/system_keyring.h
index fbd4647767e9..0d8762622ab9 100644
--- a/include/keys/system_keyring.h
+++ b/include/keys/system_keyring.h
@@ -33,6 +33,18 @@ extern int restrict_link_by_builtin_and_secondary_trusted(
 #define restrict_link_by_builtin_and_secondary_trusted restrict_link_by_builtin_trusted
 #endif
 
+#ifdef CONFIG_SYSTEM_BLACKLIST_KEYRING
+extern int mark_hash_blacklisted(const char *hash);
+extern int is_hash_blacklisted(const u8 *hash, size_t hash_len,
+			       const char *type);
+#else
+static inline int is_hash_blacklisted(const u8 *hash, size_t hash_len,
+				      const char *type)
+{
+	return 0;
+}
+#endif
+
 #ifdef CONFIG_IMA_BLACKLIST_KEYRING
 extern struct key *ima_blacklist_keyring;
 

commit 56104cf2b8d20eed32c14eac8ac574c35377ab38
Author: David Howells <dhowells@redhat.com>
Date:   Thu Apr 7 09:45:23 2016 +0100

    IMA: Use the the system trusted keyrings instead of .ima_mok
    
    Add a config option (IMA_KEYRINGS_PERMIT_SIGNED_BY_BUILTIN_OR_SECONDARY)
    that, when enabled, allows keys to be added to the IMA keyrings by
    userspace - with the restriction that each must be signed by a key in the
    system trusted keyrings.
    
    EPERM will be returned if this option is disabled, ENOKEY will be returned if
    no authoritative key can be found and EKEYREJECTED will be returned if the
    signature doesn't match.  Other errors such as ENOPKG may also be returned.
    
    If this new option is enabled, the builtin system keyring is searched, as is
    the secondary system keyring if that is also enabled.  Intermediate keys
    between the builtin system keyring and the key being added can be added to
    the secondary keyring (which replaces .ima_mok) to form a trust chain -
    provided they are also validly signed by a key in one of the trusted keyrings.
    
    The .ima_mok keyring is then removed and the IMA blacklist keyring gets its
    own config option (IMA_BLACKLIST_KEYRING).
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/include/keys/system_keyring.h b/include/keys/system_keyring.h
index 614424029de7..fbd4647767e9 100644
--- a/include/keys/system_keyring.h
+++ b/include/keys/system_keyring.h
@@ -33,28 +33,19 @@ extern int restrict_link_by_builtin_and_secondary_trusted(
 #define restrict_link_by_builtin_and_secondary_trusted restrict_link_by_builtin_trusted
 #endif
 
-#ifdef CONFIG_IMA_MOK_KEYRING
-extern struct key *ima_mok_keyring;
+#ifdef CONFIG_IMA_BLACKLIST_KEYRING
 extern struct key *ima_blacklist_keyring;
 
-static inline struct key *get_ima_mok_keyring(void)
-{
-	return ima_mok_keyring;
-}
 static inline struct key *get_ima_blacklist_keyring(void)
 {
 	return ima_blacklist_keyring;
 }
 #else
-static inline struct key *get_ima_mok_keyring(void)
-{
-	return NULL;
-}
 static inline struct key *get_ima_blacklist_keyring(void)
 {
 	return NULL;
 }
-#endif /* CONFIG_IMA_MOK_KEYRING */
+#endif /* CONFIG_IMA_BLACKLIST_KEYRING */
 
 
 #endif /* _KEYS_SYSTEM_KEYRING_H */

commit d3bfe84129f65e0af2450743ebdab33d161d01c9
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:14:27 2016 +0100

    certs: Add a secondary system keyring that can be added to dynamically
    
    Add a secondary system keyring that can be added to by root whilst the
    system is running - provided the key being added is vouched for by a key
    built into the kernel or already added to the secondary keyring.
    
    Rename .system_keyring to .builtin_trusted_keys to distinguish it more
    obviously from the new keyring (called .secondary_trusted_keys).
    
    The new keyring needs to be enabled with CONFIG_SECONDARY_TRUSTED_KEYRING.
    
    If the secondary keyring is enabled, a link is created from that to
    .builtin_trusted_keys so that the the latter will automatically be searched
    too if the secondary keyring is searched.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/keys/system_keyring.h b/include/keys/system_keyring.h
index c72330ae76df..614424029de7 100644
--- a/include/keys/system_keyring.h
+++ b/include/keys/system_keyring.h
@@ -24,6 +24,15 @@ extern int restrict_link_by_builtin_trusted(struct key *keyring,
 #define restrict_link_by_builtin_trusted restrict_link_reject
 #endif
 
+#ifdef CONFIG_SECONDARY_TRUSTED_KEYRING
+extern int restrict_link_by_builtin_and_secondary_trusted(
+	struct key *keyring,
+	const struct key_type *type,
+	const union key_payload *payload);
+#else
+#define restrict_link_by_builtin_and_secondary_trusted restrict_link_by_builtin_trusted
+#endif
+
 #ifdef CONFIG_IMA_MOK_KEYRING
 extern struct key *ima_mok_keyring;
 extern struct key *ima_blacklist_keyring;

commit 77f68bac9481ad440f4f34dda3d28c2dce6eb87b
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:14:26 2016 +0100

    KEYS: Remove KEY_FLAG_TRUSTED and KEY_ALLOC_TRUSTED
    
    Remove KEY_FLAG_TRUSTED and KEY_ALLOC_TRUSTED as they're no longer
    meaningful.  Also we can drop the trusted flag from the preparse structure.
    
    Given this, we no longer need to pass the key flags through to
    restrict_link().
    
    Further, we can now get rid of keyring_restrict_trusted_only() also.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/keys/system_keyring.h b/include/keys/system_keyring.h
index 93715913a0b1..c72330ae76df 100644
--- a/include/keys/system_keyring.h
+++ b/include/keys/system_keyring.h
@@ -18,7 +18,6 @@
 
 extern int restrict_link_by_builtin_trusted(struct key *keyring,
 					    const struct key_type *type,
-					    unsigned long flags,
 					    const union key_payload *payload);
 
 #else

commit a511e1af8b12f44c6e55786c463c9f093c214fb6
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:14:26 2016 +0100

    KEYS: Move the point of trust determination to __key_link()
    
    Move the point at which a key is determined to be trustworthy to
    __key_link() so that we use the contents of the keyring being linked in to
    to determine whether the key being linked in is trusted or not.
    
    What is 'trusted' then becomes a matter of what's in the keyring.
    
    Currently, the test is done when the key is parsed, but given that at that
    point we can only sensibly refer to the contents of the system trusted
    keyring, we can only use that as the basis for working out the
    trustworthiness of a new key.
    
    With this change, a trusted keyring is a set of keys that once the
    trusted-only flag is set cannot be added to except by verification through
    one of the contained keys.
    
    Further, adding a key into a trusted keyring, whilst it might grant
    trustworthiness in the context of that keyring, does not automatically
    grant trustworthiness in the context of a second keyring to which it could
    be secondarily linked.
    
    To accomplish this, the authentication data associated with the key source
    must now be retained.  For an X.509 cert, this means the contents of the
    AuthorityKeyIdentifier and the signature data.
    
    
    If system keyrings are disabled then restrict_link_by_builtin_trusted()
    resolves to restrict_link_reject().  The integrity digital signature code
    still works correctly with this as it was previously using
    KEY_FLAG_TRUSTED_ONLY, which doesn't permit anything to be added if there
    is no system keyring against which trust can be determined.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/keys/system_keyring.h b/include/keys/system_keyring.h
index b2d645ac35a0..93715913a0b1 100644
--- a/include/keys/system_keyring.h
+++ b/include/keys/system_keyring.h
@@ -12,22 +12,17 @@
 #ifndef _KEYS_SYSTEM_KEYRING_H
 #define _KEYS_SYSTEM_KEYRING_H
 
+#include <linux/key.h>
+
 #ifdef CONFIG_SYSTEM_TRUSTED_KEYRING
 
-#include <linux/key.h>
-#include <linux/verification.h>
-#include <crypto/public_key.h>
+extern int restrict_link_by_builtin_trusted(struct key *keyring,
+					    const struct key_type *type,
+					    unsigned long flags,
+					    const union key_payload *payload);
 
-extern struct key *system_trusted_keyring;
-static inline struct key *get_system_trusted_keyring(void)
-{
-	return system_trusted_keyring;
-}
 #else
-static inline struct key *get_system_trusted_keyring(void)
-{
-	return NULL;
-}
+#define restrict_link_by_builtin_trusted restrict_link_reject
 #endif
 
 #ifdef CONFIG_IMA_MOK_KEYRING

commit e68503bd6836ba765dc8e0ee77ea675fedc07e41
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:14:24 2016 +0100

    KEYS: Generalise system_verify_data() to provide access to internal content
    
    Generalise system_verify_data() to provide access to internal content
    through a callback.  This allows all the PKCS#7 stuff to be hidden inside
    this function and removed from the PE file parser and the PKCS#7 test key.
    
    If external content is not required, NULL should be passed as data to the
    function.  If the callback is not required, that can be set to NULL.
    
    The function is now called verify_pkcs7_signature() to contrast with
    verify_pefile_signature() and the definitions of both have been moved into
    linux/verification.h along with the key_being_used_for enum.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/keys/system_keyring.h b/include/keys/system_keyring.h
index 39fd38cfa8c9..b2d645ac35a0 100644
--- a/include/keys/system_keyring.h
+++ b/include/keys/system_keyring.h
@@ -15,6 +15,7 @@
 #ifdef CONFIG_SYSTEM_TRUSTED_KEYRING
 
 #include <linux/key.h>
+#include <linux/verification.h>
 #include <crypto/public_key.h>
 
 extern struct key *system_trusted_keyring;
@@ -29,12 +30,6 @@ static inline struct key *get_system_trusted_keyring(void)
 }
 #endif
 
-#ifdef CONFIG_SYSTEM_DATA_VERIFICATION
-extern int system_verify_data(const void *data, unsigned long len,
-			      const void *raw_pkcs7, size_t pkcs7_len,
-			      enum key_being_used_for usage);
-#endif
-
 #ifdef CONFIG_IMA_MOK_KEYRING
 extern struct key *ima_mok_keyring;
 extern struct key *ima_blacklist_keyring;

commit 41c89b64d7184a780f12f2cccdabe65cb2408893
Author: Petko Manolov <petkan@mip-labs.com>
Date:   Wed Dec 2 17:47:55 2015 +0200

    IMA: create machine owner and blacklist keyrings
    
    This option creates IMA MOK and blacklist keyrings.  IMA MOK is an
    intermediate keyring that sits between .system and .ima keyrings,
    effectively forming a simple CA hierarchy.  To successfully import a key
    into .ima_mok it must be signed by a key which CA is in .system keyring.
    On turn any key that needs to go in .ima keyring must be signed by CA in
    either .system or .ima_mok keyrings. IMA MOK is empty at kernel boot.
    
    IMA blacklist keyring contains all revoked IMA keys.  It is consulted
    before any other keyring.  If the search is successful the requested
    operation is rejected and error is returned to the caller.
    
    Signed-off-by: Petko Manolov <petkan@mip-labs.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/include/keys/system_keyring.h b/include/keys/system_keyring.h
index b20cd885c1fd..39fd38cfa8c9 100644
--- a/include/keys/system_keyring.h
+++ b/include/keys/system_keyring.h
@@ -35,4 +35,28 @@ extern int system_verify_data(const void *data, unsigned long len,
 			      enum key_being_used_for usage);
 #endif
 
+#ifdef CONFIG_IMA_MOK_KEYRING
+extern struct key *ima_mok_keyring;
+extern struct key *ima_blacklist_keyring;
+
+static inline struct key *get_ima_mok_keyring(void)
+{
+	return ima_mok_keyring;
+}
+static inline struct key *get_ima_blacklist_keyring(void)
+{
+	return ima_blacklist_keyring;
+}
+#else
+static inline struct key *get_ima_mok_keyring(void)
+{
+	return NULL;
+}
+static inline struct key *get_ima_blacklist_keyring(void)
+{
+	return NULL;
+}
+#endif /* CONFIG_IMA_MOK_KEYRING */
+
+
 #endif /* _KEYS_SYSTEM_KEYRING_H */

commit 99db44350672c8a5ee9a7b0a6f4cd6ff10136065
Author: David Howells <dhowells@redhat.com>
Date:   Wed Aug 5 15:22:27 2015 +0100

    PKCS#7: Appropriately restrict authenticated attributes and content type
    
    A PKCS#7 or CMS message can have per-signature authenticated attributes
    that are digested as a lump and signed by the authorising key for that
    signature.  If such attributes exist, the content digest isn't itself
    signed, but rather it is included in a special authattr which then
    contributes to the signature.
    
    Further, we already require the master message content type to be
    pkcs7_signedData - but there's also a separate content type for the data
    itself within the SignedData object and this must be repeated inside the
    authattrs for each signer [RFC2315 9.2, RFC5652 11.1].
    
    We should really validate the authattrs if they exist or forbid them
    entirely as appropriate.  To this end:
    
     (1) Alter the PKCS#7 parser to reject any message that has more than one
         signature where at least one signature has authattrs and at least one
         that does not.
    
     (2) Validate authattrs if they are present and strongly restrict them.
         Only the following authattrs are permitted and all others are
         rejected:
    
         (a) contentType.  This is checked to be an OID that matches the
             content type in the SignedData object.
    
         (b) messageDigest.  This must match the crypto digest of the data.
    
         (c) signingTime.  If present, we check that this is a valid, parseable
             UTCTime or GeneralTime and that the date it encodes fits within
             the validity window of the matching X.509 cert.
    
         (d) S/MIME capabilities.  We don't check the contents.
    
         (e) Authenticode SP Opus Info.  We don't check the contents.
    
         (f) Authenticode Statement Type.  We don't check the contents.
    
         The message is rejected if (a) or (b) are missing.  If the message is
         an Authenticode type, the message is rejected if (e) is missing; if
         not Authenticode, the message is rejected if (d) - (f) are present.
    
         The S/MIME capabilities authattr (d) unfortunately has to be allowed
         to support kernels already signed by the pesign program.  This only
         affects kexec.  sign-file suppresses them (CMS_NOSMIMECAP).
    
         The message is also rejected if an authattr is given more than once or
         if it contains more than one element in its set of values.
    
     (3) Add a parameter to pkcs7_verify() to select one of the following
         restrictions and pass in the appropriate option from the callers:
    
         (*) VERIFYING_MODULE_SIGNATURE
    
             This requires that the SignedData content type be pkcs7-data and
             forbids authattrs.  sign-file sets CMS_NOATTR.  We could be more
             flexible and permit authattrs optionally, but only permit minimal
             content.
    
         (*) VERIFYING_FIRMWARE_SIGNATURE
    
             This requires that the SignedData content type be pkcs7-data and
             requires authattrs.  In future, this will require an attribute
             holding the target firmware name in addition to the minimal set.
    
         (*) VERIFYING_UNSPECIFIED_SIGNATURE
    
             This requires that the SignedData content type be pkcs7-data but
             allows either no authattrs or only permits the minimal set.
    
         (*) VERIFYING_KEXEC_PE_SIGNATURE
    
             This only supports the Authenticode SPC_INDIRECT_DATA content type
             and requires at least an SpcSpOpusInfo authattr in addition to the
             minimal set.  It also permits an SPC_STATEMENT_TYPE authattr (and
             an S/MIME capabilities authattr because the pesign program doesn't
             remove these).
    
         (*) VERIFYING_KEY_SIGNATURE
         (*) VERIFYING_KEY_SELF_SIGNATURE
    
             These are invalid in this context but are included for later use
             when limiting the use of X.509 certs.
    
     (4) The pkcs7_test key type is given a module parameter to select between
         the above options for testing purposes.  For example:
    
            echo 1 >/sys/module/pkcs7_test_key/parameters/usage
            keyctl padd pkcs7_test foo @s </tmp/stuff.pkcs7
    
         will attempt to check the signature on stuff.pkcs7 as if it contains a
         firmware blob (1 being VERIFYING_FIRMWARE_SIGNATURE).
    
    Suggested-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/keys/system_keyring.h b/include/keys/system_keyring.h
index 9791c907cdb7..b20cd885c1fd 100644
--- a/include/keys/system_keyring.h
+++ b/include/keys/system_keyring.h
@@ -15,6 +15,7 @@
 #ifdef CONFIG_SYSTEM_TRUSTED_KEYRING
 
 #include <linux/key.h>
+#include <crypto/public_key.h>
 
 extern struct key *system_trusted_keyring;
 static inline struct key *get_system_trusted_keyring(void)
@@ -30,7 +31,8 @@ static inline struct key *get_system_trusted_keyring(void)
 
 #ifdef CONFIG_SYSTEM_DATA_VERIFICATION
 extern int system_verify_data(const void *data, unsigned long len,
-			      const void *raw_pkcs7, size_t pkcs7_len);
+			      const void *raw_pkcs7, size_t pkcs7_len,
+			      enum key_being_used_for usage);
 #endif
 
 #endif /* _KEYS_SYSTEM_KEYRING_H */

commit 091f6e26eb326adbd718f406e440c838bed8ebb6
Author: David Howells <dhowells@redhat.com>
Date:   Mon Jul 20 21:16:28 2015 +0100

    MODSIGN: Extract the blob PKCS#7 signature verifier from module signing
    
    Extract the function that drives the PKCS#7 signature verification given a
    data blob and a PKCS#7 blob out from the module signing code and lump it with
    the system keyring code as it's generic.  This makes it independent of module
    config options and opens it to use by the firmware loader.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: Luis R. Rodriguez <mcgrof@suse.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Ming Lei <ming.lei@canonical.com>
    Cc: Seth Forshee <seth.forshee@canonical.com>
    Cc: Kyle McMartin <kyle@kernel.org>

diff --git a/include/keys/system_keyring.h b/include/keys/system_keyring.h
index 72665eb80692..9791c907cdb7 100644
--- a/include/keys/system_keyring.h
+++ b/include/keys/system_keyring.h
@@ -28,4 +28,9 @@ static inline struct key *get_system_trusted_keyring(void)
 }
 #endif
 
+#ifdef CONFIG_SYSTEM_DATA_VERIFICATION
+extern int system_verify_data(const void *data, unsigned long len,
+			      const void *raw_pkcs7, size_t pkcs7_len);
+#endif
+
 #endif /* _KEYS_SYSTEM_KEYRING_H */

commit 3be4beaf7c91ec9c6fefa5f11173af37113d10ae
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Tue Aug 20 14:36:27 2013 -0400

    KEYS: verify a certificate is signed by a 'trusted' key
    
    Only public keys, with certificates signed by an existing
    'trusted' key on the system trusted keyring, should be added
    to a trusted keyring.  This patch adds support for verifying
    a certificate's signature.
    
    This is derived from David Howells pkcs7_request_asymmetric_key() patch.
    
    Changelog v6:
    - on error free key - Dmitry
    - validate trust only for not already trusted keys - Dmitry
    - formatting cleanup
    
    Changelog:
    - define get_system_trusted_keyring() to fix kbuild issues
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Dmitry Kasatkin <dmitry.kasatkin@gmail.com>

diff --git a/include/keys/system_keyring.h b/include/keys/system_keyring.h
index 8dabc399bd1d..72665eb80692 100644
--- a/include/keys/system_keyring.h
+++ b/include/keys/system_keyring.h
@@ -17,7 +17,15 @@
 #include <linux/key.h>
 
 extern struct key *system_trusted_keyring;
-
+static inline struct key *get_system_trusted_keyring(void)
+{
+	return system_trusted_keyring;
+}
+#else
+static inline struct key *get_system_trusted_keyring(void)
+{
+	return NULL;
+}
 #endif
 
 #endif /* _KEYS_SYSTEM_KEYRING_H */

commit b56e5a17b6b9acd16997960504b9940d0d7984e7
Author: David Howells <dhowells@redhat.com>
Date:   Fri Aug 30 16:07:30 2013 +0100

    KEYS: Separate the kernel signature checking keyring from module signing
    
    Separate the kernel signature checking keyring from module signing so that it
    can be used by code other than the module-signing code.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/keys/system_keyring.h b/include/keys/system_keyring.h
new file mode 100644
index 000000000000..8dabc399bd1d
--- /dev/null
+++ b/include/keys/system_keyring.h
@@ -0,0 +1,23 @@
+/* System keyring containing trusted public keys.
+ *
+ * Copyright (C) 2013 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public Licence
+ * as published by the Free Software Foundation; either version
+ * 2 of the Licence, or (at your option) any later version.
+ */
+
+#ifndef _KEYS_SYSTEM_KEYRING_H
+#define _KEYS_SYSTEM_KEYRING_H
+
+#ifdef CONFIG_SYSTEM_TRUSTED_KEYRING
+
+#include <linux/key.h>
+
+extern struct key *system_trusted_keyring;
+
+#endif
+
+#endif /* _KEYS_SYSTEM_KEYRING_H */
