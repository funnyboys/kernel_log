commit 0ac8903cbbe618d947b5815d6e0f7b044ee83aa3
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Tue May 19 10:27:05 2020 +0300

    RDMA/core: Allow the ioctl layer to abort a fully created uobject
    
    While creating a uobject every create reaches a point where the uobject is
    fully initialized. For ioctls that go on to copy_to_user this means they
    need to open code the destruction of a fully created uobject - ie the
    RDMA_REMOVE_DESTROY sort of flow.
    
    Open coding this creates bugs, eg the CQ does not properly flush the
    events list when it does its error unwind.
    
    Provide a uverbs_finalize_uobj_create() function which indicates that the
    uobject is fully initialized and that abort should call to destroy_hw to
    destroy the uobj->object and related.
    
    Methods can call this function if they go on to have error cases after
    setting uobj->object. Once done those error cases can simply do return,
    without an error unwind.
    
    Link: https://lore.kernel.org/r/20200519072711.257271-2-leon@kernel.org
    Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index f1cbdae67250..c15b298aa62f 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -139,7 +139,8 @@ void rdma_lookup_put_uobject(struct ib_uobject *uobj,
 struct ib_uobject *rdma_alloc_begin_uobject(const struct uverbs_api_object *obj,
 					    struct uverbs_attr_bundle *attrs);
 void rdma_alloc_abort_uobject(struct ib_uobject *uobj,
-			      struct uverbs_attr_bundle *attrs);
+			      struct uverbs_attr_bundle *attrs,
+			      bool hw_obj_valid);
 void rdma_alloc_commit_uobject(struct ib_uobject *uobj,
 			       struct uverbs_attr_bundle *attrs);
 

commit 39e83af817610e80a9582df94d44173bcb6f85e4
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Wed Jan 8 19:22:04 2020 +0200

    RDMA/core: Remove the ufile arg from rdma_alloc_begin_uobject
    
    Now that all callers provide a non-NULL attrs the ufile is redundant.
    Adjust things so that the context handling is done inside alloc_uobj,
    and the ib_uverbs_get_ucontext_file() is avoided if we already have the
    context.
    
    Link: https://lore.kernel.org/r/1578504126-9400-13-git-send-email-yishaih@mellanox.com
    Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index 01d59df4e9e7..f1cbdae67250 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -83,7 +83,7 @@ enum rdma_lookup_mode {
  */
 struct uverbs_obj_type_class {
 	struct ib_uobject *(*alloc_begin)(const struct uverbs_api_object *obj,
-					  struct ib_uverbs_file *ufile);
+					  struct uverbs_attr_bundle *attrs);
 	/* This consumes the kref on uobj */
 	void (*alloc_commit)(struct ib_uobject *uobj);
 	/* This does not consume the kref on uobj */
@@ -137,7 +137,6 @@ struct ib_uobject *rdma_lookup_get_uobject(const struct uverbs_api_object *obj,
 void rdma_lookup_put_uobject(struct ib_uobject *uobj,
 			     enum rdma_lookup_mode mode);
 struct ib_uobject *rdma_alloc_begin_uobject(const struct uverbs_api_object *obj,
-					    struct ib_uverbs_file *ufile,
 					    struct uverbs_attr_bundle *attrs);
 void rdma_alloc_abort_uobject(struct ib_uobject *uobj,
 			      struct uverbs_attr_bundle *attrs);

commit 849e149063bd10eb6211c14617491a0bc9516c2f
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Wed Jan 8 19:21:56 2020 +0200

    RDMA/core: Do not allow alloc_commit to fail
    
    This is a left over from an earlier version that creates a lot of
    complexity for error unwind, particularly for FD uobjects.
    
    The only reason this was done is so that anon_inode_get_file() could be
    called with the final fops and a fully setup uobject. Both need to be
    setup since unwinding anon_inode_get_file() via fput will call the
    driver's release().
    
    Now that the driver does not provide release, we no longer need to worry
    about this complicated sequence, simply create the struct file at the
    start and allow the core code's release function to deal with the abort
    case.
    
    This allows all the confusing error paths around commit to be removed.
    
    Link: https://lore.kernel.org/r/1578504126-9400-5-git-send-email-yishaih@mellanox.com
    Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index b633fa2543e3..01d59df4e9e7 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -85,7 +85,7 @@ struct uverbs_obj_type_class {
 	struct ib_uobject *(*alloc_begin)(const struct uverbs_api_object *obj,
 					  struct ib_uverbs_file *ufile);
 	/* This consumes the kref on uobj */
-	int (*alloc_commit)(struct ib_uobject *uobj);
+	void (*alloc_commit)(struct ib_uobject *uobj);
 	/* This does not consume the kref on uobj */
 	void (*alloc_abort)(struct ib_uobject *uobj);
 
@@ -141,8 +141,8 @@ struct ib_uobject *rdma_alloc_begin_uobject(const struct uverbs_api_object *obj,
 					    struct uverbs_attr_bundle *attrs);
 void rdma_alloc_abort_uobject(struct ib_uobject *uobj,
 			      struct uverbs_attr_bundle *attrs);
-int __must_check rdma_alloc_commit_uobject(struct ib_uobject *uobj,
-					   struct uverbs_attr_bundle *attrs);
+void rdma_alloc_commit_uobject(struct ib_uobject *uobj,
+			       struct uverbs_attr_bundle *attrs);
 
 /*
  * uverbs_uobject_get is called in order to increase the reference count on

commit f7c8416ccea52b41e29227b3a5066540f51ee471
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Wed Jan 8 19:21:54 2020 +0200

    RDMA/core: Simplify destruction of FD uobjects
    
    FD uobjects have a weird split between the struct file and uobject
    world. Simplify this to make them pure uobjects and use a generic release
    method for all struct file operations.
    
    This fixes the control flow so that mlx5_cmd_cleanup_async_ctx() is always
    called before erasing the linked list contents to make the concurrancy
    simpler to understand.
    
    For this to work the uobject destruction must fence anything that it is
    cleaning up - the design must not rely on struct file lifetime.
    
    Only deliver_event() relies on the struct file to when adding new events
    to the queue, add a is_destroyed check under lock to block it.
    
    Link: https://lore.kernel.org/r/1578504126-9400-3-git-send-email-yishaih@mellanox.com
    Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index ca65d4704b4b..b633fa2543e3 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -161,11 +161,11 @@ struct uverbs_obj_fd_type {
 	 * In fd based objects, uverbs_obj_type_ops points to generic
 	 * fd operations. In order to specialize the underlying types (e.g.
 	 * completion_channel), we use fops, name and flags for fd creation.
-	 * context_closed is called when the context is closed either when
-	 * the driver is removed or the process terminated.
+	 * destroy_object is called when the uobject is to be destroyed,
+	 * because the driver is removed or the FD is closed.
 	 */
 	struct uverbs_obj_type  type;
-	int (*context_closed)(struct ib_uobject *uobj,
+	int (*destroy_object)(struct ib_uobject *uobj,
 			      enum rdma_remove_reason why);
 	const struct file_operations	*fops;
 	const char			*name;
@@ -174,11 +174,11 @@ struct uverbs_obj_fd_type {
 
 extern const struct uverbs_obj_type_class uverbs_idr_class;
 extern const struct uverbs_obj_type_class uverbs_fd_class;
-void uverbs_close_fd(struct file *f);
+int uverbs_uobject_fd_release(struct inode *inode, struct file *filp);
 
 #define UVERBS_BUILD_BUG_ON(cond) (sizeof(char[1 - 2 * !!(cond)]) -	\
 				   sizeof(char))
-#define UVERBS_TYPE_ALLOC_FD(_obj_size, _context_closed, _fops, _name, _flags)\
+#define UVERBS_TYPE_ALLOC_FD(_obj_size, _destroy_object, _fops, _name, _flags) \
 	((&((const struct uverbs_obj_fd_type)				\
 	 {.type = {							\
 		.type_class = &uverbs_fd_class,				\
@@ -186,7 +186,7 @@ void uverbs_close_fd(struct file *f);
 			UVERBS_BUILD_BUG_ON((_obj_size) <               \
 					    sizeof(struct ib_uobject)), \
 	 },								\
-	 .context_closed = _context_closed,				\
+	 .destroy_object = _destroy_object,				\
 	 .fops = _fops,							\
 	 .name = _name,							\
 	 .flags = _flags}))->type)

commit 6898d1c661d79f4707d8ba82991b2195822780ca
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Wed Jan 8 19:21:53 2020 +0200

    RDMA/mlx5: Use RCU and direct refcounts to keep memory alive
    
    dispatch_event_fd() runs from a notifier with minimal locking, and relies
    on RCU and a file refcount to keep the uobject and eventfd alive.
    
    As the next patch wants to remove the file_operations release function
    from the drivers, re-organize things so that the devx_event_notifier()
    path uses the existing RCU to manage the lifetime of the uobject and
    eventfd.
    
    Move the refcount puts to a call_rcu so that the objects are guaranteed to
    exist and remove the indirect file refcount.
    
    Link: https://lore.kernel.org/r/1578504126-9400-2-git-send-email-yishaih@mellanox.com
    Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index 0b0f5a5f392d..ca65d4704b4b 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -144,6 +144,18 @@ void rdma_alloc_abort_uobject(struct ib_uobject *uobj,
 int __must_check rdma_alloc_commit_uobject(struct ib_uobject *uobj,
 					   struct uverbs_attr_bundle *attrs);
 
+/*
+ * uverbs_uobject_get is called in order to increase the reference count on
+ * an uobject. This is useful when a handler wants to keep the uobject's memory
+ * alive, regardless if this uobject is still alive in the context's objects
+ * repository. Objects are put via uverbs_uobject_put.
+ */
+static inline void uverbs_uobject_get(struct ib_uobject *uobject)
+{
+	kref_get(&uobject->ref);
+}
+void uverbs_uobject_put(struct ib_uobject *uobject);
+
 struct uverbs_obj_fd_type {
 	/*
 	 * In fd based objects, uverbs_obj_type_ops points to generic

commit 8bdf9dd984c18375d1090ddeb1792511f619c5c1
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Mon Jan 13 14:33:10 2020 +0000

    RDMA/uverbs: Remove needs_kfree_rcu from uverbs_obj_type_class
    
    After device disassociation the uapi_objects are destroyed and freed,
    however it is still possible that core code can be holding a kref on the
    uobject. When it finally goes to uverbs_uobject_free() via the kref_put()
    it can trigger a use-after-free on the uapi_object.
    
    Since needs_kfree_rcu is a micro optimization that only benefits file
    uobjects, just get rid of it. There is no harm in using kfree_rcu even if
    it isn't required, and the number of involved objects is small.
    
    Link: https://lore.kernel.org/r/20200113143306.GA28717@ziepe.ca
    Signed-off-by: Michael Guralnik <michaelgur@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index d57a5ba00c74..0b0f5a5f392d 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -98,7 +98,6 @@ struct uverbs_obj_type_class {
 				       enum rdma_remove_reason why,
 				       struct uverbs_attr_bundle *attrs);
 	void (*remove_handle)(struct ib_uobject *uobj);
-	u8    needs_kfree_rcu;
 };
 
 struct uverbs_obj_type {

commit a6a3797df2741aa81f33fe48f609247dba98f3f7
Author: Shamir Rabinovitch <shamir.rabinovitch@oracle.com>
Date:   Sun Mar 31 19:10:04 2019 +0300

    IB: Pass uverbs_attr_bundle down uobject destroy path
    
    Pass uverbs_attr_bundle down the uobject destroy path. The next patch will
    use this to eliminate the dependecy of the drivers in ib_x->uobject
    pointers.
    
    Signed-off-by: Shamir Rabinovitch <shamir.rabinovitch@oracle.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index b68f1b92c25d..d57a5ba00c74 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -95,7 +95,8 @@ struct uverbs_obj_type_class {
 	void (*lookup_put)(struct ib_uobject *uobj, enum rdma_lookup_mode mode);
 	/* This does not consume the kref on uobj */
 	int __must_check (*destroy_hw)(struct ib_uobject *uobj,
-				       enum rdma_remove_reason why);
+				       enum rdma_remove_reason why,
+				       struct uverbs_attr_bundle *attrs);
 	void (*remove_handle)(struct ib_uobject *uobj);
 	u8    needs_kfree_rcu;
 };
@@ -126,7 +127,8 @@ struct uverbs_obj_idr_type {
 	 * completely unchanged.
 	 */
 	int __must_check (*destroy_object)(struct ib_uobject *uobj,
-					   enum rdma_remove_reason why);
+					   enum rdma_remove_reason why,
+					   struct uverbs_attr_bundle *attrs);
 };
 
 struct ib_uobject *rdma_lookup_get_uobject(const struct uverbs_api_object *obj,
@@ -138,8 +140,10 @@ void rdma_lookup_put_uobject(struct ib_uobject *uobj,
 struct ib_uobject *rdma_alloc_begin_uobject(const struct uverbs_api_object *obj,
 					    struct ib_uverbs_file *ufile,
 					    struct uverbs_attr_bundle *attrs);
-void rdma_alloc_abort_uobject(struct ib_uobject *uobj);
-int __must_check rdma_alloc_commit_uobject(struct ib_uobject *uobj);
+void rdma_alloc_abort_uobject(struct ib_uobject *uobj,
+			      struct uverbs_attr_bundle *attrs);
+int __must_check rdma_alloc_commit_uobject(struct ib_uobject *uobj,
+					   struct uverbs_attr_bundle *attrs);
 
 struct uverbs_obj_fd_type {
 	/*

commit 70f06b26f07ea42d158b41bba460ce06ffa3510a
Author: Shamir Rabinovitch <shamir.rabinovitch@oracle.com>
Date:   Sun Mar 31 19:10:03 2019 +0300

    IB: ucontext should be set properly for all cmd & ioctl paths
    
    the Attempt to use the below commit to initialize the ucontext for the
    uobject destroy path has shown that the below commit is incomplete.
    
    Parts were reverted and the ucontext set up in the uverbs_attr_bundle was
    moved to rdma_lookup_get_uobject which is called from the uobj_get_XXX
    macros and rdma_alloc_begin_uobject which is called when uobject is
    created.
    
    Fixes: 3d9dfd060391 ("IB/uverbs: Add ib_ucontext to uverbs_attr_bundle sent from ioctl and cmd flows")
    Signed-off-by: Shamir Rabinovitch <shamir.rabinovitch@oracle.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index 175d761695e1..b68f1b92c25d 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -131,11 +131,13 @@ struct uverbs_obj_idr_type {
 
 struct ib_uobject *rdma_lookup_get_uobject(const struct uverbs_api_object *obj,
 					   struct ib_uverbs_file *ufile, s64 id,
-					   enum rdma_lookup_mode mode);
+					   enum rdma_lookup_mode mode,
+					   struct uverbs_attr_bundle *attrs);
 void rdma_lookup_put_uobject(struct ib_uobject *uobj,
 			     enum rdma_lookup_mode mode);
 struct ib_uobject *rdma_alloc_begin_uobject(const struct uverbs_api_object *obj,
-					    struct ib_uverbs_file *ufile);
+					    struct ib_uverbs_file *ufile,
+					    struct uverbs_attr_bundle *attrs);
 void rdma_alloc_abort_uobject(struct ib_uobject *uobj);
 int __must_check rdma_alloc_commit_uobject(struct ib_uobject *uobj);
 

commit 6bf8f22aea0ddd93af822aed8afeeee4acdf7694
Author: Yishai Hadas <yishaih@mellanox.com>
Date:   Tue Jan 22 08:29:56 2019 +0200

    IB/mlx5: Introduce MLX5_IB_OBJECT_DEVX_ASYNC_CMD_FD
    
    Introduce MLX5_IB_OBJECT_DEVX_ASYNC_CMD_FD and its initial implementation.
    
    This object is from type class FD and will be used to read DEVX async
    commands completion.
    
    The core layer should allow the driver to set object from type FD in a
    safe mode, this option was added with a matching comment in place.
    
    Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index acb1bfa3cc99..175d761695e1 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -157,6 +157,7 @@ struct uverbs_obj_fd_type {
 
 extern const struct uverbs_obj_type_class uverbs_idr_class;
 extern const struct uverbs_obj_type_class uverbs_fd_class;
+void uverbs_close_fd(struct file *f);
 
 #define UVERBS_BUILD_BUG_ON(cond) (sizeof(char[1 - 2 * !!(cond)]) -	\
 				   sizeof(char))

commit 6b0d08f4a27134e6fb49aa33ceb53356081bc92e
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Thu Aug 9 20:14:37 2018 -0600

    IB/uverbs: Use uverbs_api to manage the object type inside the uobject
    
    Currently the struct uverbs_obj_type stored in the ib_uobject is part of
    the .rodata segment of the module that defines the object. This is a
    problem if drivers define new uapi objects as we will be left with a
    dangling pointer after device disassociation.
    
    Switch the uverbs_obj_type for struct uverbs_api_object, which is
    allocated memory that is part of the uverbs_api and is guaranteed to
    always exist. Further this moves the 'type_class' into this memory which
    means access to the IDR/FD function pointers is also guaranteed. Drivers
    cannot define new types.
    
    This makes it safe to continue to use all uobjects, including driver
    defined ones, after disassociation.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index 1ab9a85eebd9..acb1bfa3cc99 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -37,6 +37,7 @@
 #include <rdma/ib_verbs.h>
 
 struct uverbs_obj_type;
+struct uverbs_api_object;
 
 enum rdma_lookup_mode {
 	UVERBS_LOOKUP_READ,
@@ -81,14 +82,14 @@ enum rdma_lookup_mode {
  * alloc_abort returns.
  */
 struct uverbs_obj_type_class {
-	struct ib_uobject *(*alloc_begin)(const struct uverbs_obj_type *type,
+	struct ib_uobject *(*alloc_begin)(const struct uverbs_api_object *obj,
 					  struct ib_uverbs_file *ufile);
 	/* This consumes the kref on uobj */
 	int (*alloc_commit)(struct ib_uobject *uobj);
 	/* This does not consume the kref on uobj */
 	void (*alloc_abort)(struct ib_uobject *uobj);
 
-	struct ib_uobject *(*lookup_get)(const struct uverbs_obj_type *type,
+	struct ib_uobject *(*lookup_get)(const struct uverbs_api_object *obj,
 					 struct ib_uverbs_file *ufile, s64 id,
 					 enum rdma_lookup_mode mode);
 	void (*lookup_put)(struct ib_uobject *uobj, enum rdma_lookup_mode mode);
@@ -128,12 +129,12 @@ struct uverbs_obj_idr_type {
 					   enum rdma_remove_reason why);
 };
 
-struct ib_uobject *rdma_lookup_get_uobject(const struct uverbs_obj_type *type,
+struct ib_uobject *rdma_lookup_get_uobject(const struct uverbs_api_object *obj,
 					   struct ib_uverbs_file *ufile, s64 id,
 					   enum rdma_lookup_mode mode);
 void rdma_lookup_put_uobject(struct ib_uobject *uobj,
 			     enum rdma_lookup_mode mode);
-struct ib_uobject *rdma_alloc_begin_uobject(const struct uverbs_obj_type *type,
+struct ib_uobject *rdma_alloc_begin_uobject(const struct uverbs_api_object *obj,
 					    struct ib_uverbs_file *ufile);
 void rdma_alloc_abort_uobject(struct ib_uobject *uobj);
 int __must_check rdma_alloc_commit_uobject(struct ib_uobject *uobj);

commit 0f50d88a6e9ae6d9dd14ed1a7d6b309280a9c23b
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Wed Jul 25 21:40:20 2018 -0600

    IB/uverbs: Allow all DESTROY commands to succeed after disassociate
    
    The disassociate function was broken by design because it failed all
    commands. This prevents userspace from calling destroy on a uobject after
    it has detected a device fatal error and thus reclaiming the resources in
    userspace is prevented.
    
    This fix is now straightforward, when anything destroys a uobject that is
    not the user the object remains on the IDR with a NULL context and object
    pointer. All lookup locking modes other than DESTROY will fail. When the
    user ultimately calls the destroy function it is simply dropped from the
    IDR while any related information is returned.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index f64f413cecac..1ab9a85eebd9 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -61,6 +61,7 @@ enum rdma_lookup_mode {
  * Destruction flow:
  *   lookup_get(exclusive=true) & uverbs_try_lock_object
  *   remove_commit
+ *   remove_handle (optional)
  *   lookup_put(exclusive=true) via rdma_lookup_put_uobject
  *
  * Allocate Error flow #1
@@ -92,8 +93,9 @@ struct uverbs_obj_type_class {
 					 enum rdma_lookup_mode mode);
 	void (*lookup_put)(struct ib_uobject *uobj, enum rdma_lookup_mode mode);
 	/* This does not consume the kref on uobj */
-	int __must_check (*remove_commit)(struct ib_uobject *uobj,
-					  enum rdma_remove_reason why);
+	int __must_check (*destroy_hw)(struct ib_uobject *uobj,
+				       enum rdma_remove_reason why);
+	void (*remove_handle)(struct ib_uobject *uobj);
 	u8    needs_kfree_rcu;
 };
 

commit 7452a3c745a2e7eb70d09dc5bb870759b1f26c91
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Wed Jul 25 21:40:14 2018 -0600

    IB/uverbs: Allow RDMA_REMOVE_DESTROY to work concurrently with disassociate
    
    After all the recent structural changes this is now straightfoward, hoist
    the hw_destroy_rwsem up out of rdma_destroy_explicit and wrap it around
    the uobject write lock as well as the destroy.
    
    This is necessary as obtaining a write lock concurrently with
    uverbs_destroy_ufile_hw() will cause malfunction.
    
    After this change none of the destroy callbacks require the
    disassociate_srcu lock to be correct.
    
    This requires introducing a new lookup mode, UVERBS_LOOKUP_DESTROY as the
    IOCTL interface needs to hold an unlocked kref until all command
    verification is completed.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index 0676672dbbb9..f64f413cecac 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -41,6 +41,12 @@ struct uverbs_obj_type;
 enum rdma_lookup_mode {
 	UVERBS_LOOKUP_READ,
 	UVERBS_LOOKUP_WRITE,
+	/*
+	 * Destroy is like LOOKUP_WRITE, except that the uobject is not
+	 * locked.  uobj_destroy is used to convert a LOOKUP_DESTROY lock into
+	 * a LOOKUP_WRITE lock.
+	 */
+	UVERBS_LOOKUP_DESTROY,
 };
 
 /*
@@ -129,7 +135,6 @@ struct ib_uobject *rdma_alloc_begin_uobject(const struct uverbs_obj_type *type,
 					    struct ib_uverbs_file *ufile);
 void rdma_alloc_abort_uobject(struct ib_uobject *uobj);
 int __must_check rdma_alloc_commit_uobject(struct ib_uobject *uobj);
-int rdma_explicit_destroy(struct ib_uobject *uobject);
 
 struct uverbs_obj_fd_type {
 	/*

commit 9867f5c6695f0a17cde9a4dc140fe026b4e40d4a
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Wed Jul 25 21:40:13 2018 -0600

    IB/uverbs: Convert 'bool exclusive' into an enum
    
    This is more readable, and future patches will need a 3rd lookup type.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index 875dd8c16ba3..0676672dbbb9 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -38,6 +38,11 @@
 
 struct uverbs_obj_type;
 
+enum rdma_lookup_mode {
+	UVERBS_LOOKUP_READ,
+	UVERBS_LOOKUP_WRITE,
+};
+
 /*
  * The following sequences are valid:
  * Success flow:
@@ -78,8 +83,8 @@ struct uverbs_obj_type_class {
 
 	struct ib_uobject *(*lookup_get)(const struct uverbs_obj_type *type,
 					 struct ib_uverbs_file *ufile, s64 id,
-					 bool exclusive);
-	void (*lookup_put)(struct ib_uobject *uobj, bool exclusive);
+					 enum rdma_lookup_mode mode);
+	void (*lookup_put)(struct ib_uobject *uobj, enum rdma_lookup_mode mode);
 	/* This does not consume the kref on uobj */
 	int __must_check (*remove_commit)(struct ib_uobject *uobj,
 					  enum rdma_remove_reason why);
@@ -116,9 +121,10 @@ struct uverbs_obj_idr_type {
 };
 
 struct ib_uobject *rdma_lookup_get_uobject(const struct uverbs_obj_type *type,
-					   struct ib_uverbs_file *ufile,
-					   s64 id, bool exclusive);
-void rdma_lookup_put_uobject(struct ib_uobject *uobj, bool exclusive);
+					   struct ib_uverbs_file *ufile, s64 id,
+					   enum rdma_lookup_mode mode);
+void rdma_lookup_put_uobject(struct ib_uobject *uobj,
+			     enum rdma_lookup_mode mode);
 struct ib_uobject *rdma_alloc_begin_uobject(const struct uverbs_obj_type *type,
 					    struct ib_uverbs_file *ufile);
 void rdma_alloc_abort_uobject(struct ib_uobject *uobj);

commit 87ad80abc70d2d5a4e383bc7e63867c9bc660838
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Wed Jul 25 21:40:12 2018 -0600

    IB/uverbs: Consolidate uobject destruction
    
    There are several flows that can destroy a uobject and each one is
    minimized and sprinkled throughout the code base, making it difficult to
    understand and very hard to modify the destroy path.
    
    Consolidate all of these into uverbs_destroy_uobject() and call it in all
    cases where a uobject has to be destroyed.
    
    This makes one change to the lifecycle, during any abort (eg when
    alloc_commit is not called) we always call out to alloc_abort, even if
    remove_commit needs to be called to delete a HW object.
    
    This also renames RDMA_REMOVE_DURING_CLEANUP to RDMA_REMOVE_ABORT to
    clarify its actual usage and revises some of the comments to reflect what
    the life cycle is for the type implementation.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index 8bae28dd2e4f..875dd8c16ba3 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -38,53 +38,49 @@
 
 struct uverbs_obj_type;
 
+/*
+ * The following sequences are valid:
+ * Success flow:
+ *   alloc_begin
+ *   alloc_commit
+ *    [..]
+ * Access flow:
+ *   lookup_get(exclusive=false) & uverbs_try_lock_object
+ *   lookup_put(exclusive=false) via rdma_lookup_put_uobject
+ * Destruction flow:
+ *   lookup_get(exclusive=true) & uverbs_try_lock_object
+ *   remove_commit
+ *   lookup_put(exclusive=true) via rdma_lookup_put_uobject
+ *
+ * Allocate Error flow #1
+ *   alloc_begin
+ *   alloc_abort
+ * Allocate Error flow #2
+ *   alloc_begin
+ *   remove_commit
+ *   alloc_abort
+ * Allocate Error flow #3
+ *   alloc_begin
+ *   alloc_commit (fails)
+ *   remove_commit
+ *   alloc_abort
+ *
+ * In all cases the caller must hold the ufile kref until alloc_commit or
+ * alloc_abort returns.
+ */
 struct uverbs_obj_type_class {
-	/*
-	 * Get an ib_uobject that corresponds to the given id from ucontext,
-	 * These functions could create or destroy objects if required.
-	 * The action will be finalized only when commit, abort or put fops are
-	 * called.
-	 * The flow of the different actions is:
-	 * [alloc]:	 Starts with alloc_begin. The handlers logic is than
-	 *		 executed. If the handler is successful, alloc_commit
-	 *		 is called and the object is inserted to the repository.
-	 *		 Once alloc_commit completes the object is visible to
-	 *		 other threads and userspace.
-	 e		 Otherwise, alloc_abort is called and the object is
-	 *		 destroyed.
-	 * [lookup]:	 Starts with lookup_get which fetches and locks the
-	 *		 object. After the handler finished using the object, it
-	 *		 needs to call lookup_put to unlock it. The exclusive
-	 *		 flag indicates if the object is locked for exclusive
-	 *		 access.
-	 * [remove]:	 Starts with lookup_get with exclusive flag set. This
-	 *		 locks the object for exclusive access. If the handler
-	 *		 code completed successfully, remove_commit is called
-	 *		 and the ib_uobject is removed from the context's
-	 *		 uobjects repository and put. The object itself is
-	 *		 destroyed as well. Once remove succeeds new krefs to
-	 *		 the object cannot be acquired by other threads or
-	 *		 userspace and the hardware driver is removed from the
-	 *		 object. Other krefs on the object may still exist.
-	 *		 If the handler code failed, lookup_put should be
-	 *		 called. This callback is used when the context
-	 *		 is destroyed as well (process termination,
-	 *		 reset flow).
-	 */
 	struct ib_uobject *(*alloc_begin)(const struct uverbs_obj_type *type,
 					  struct ib_uverbs_file *ufile);
+	/* This consumes the kref on uobj */
 	int (*alloc_commit)(struct ib_uobject *uobj);
+	/* This does not consume the kref on uobj */
 	void (*alloc_abort)(struct ib_uobject *uobj);
 
 	struct ib_uobject *(*lookup_get)(const struct uverbs_obj_type *type,
 					 struct ib_uverbs_file *ufile, s64 id,
 					 bool exclusive);
 	void (*lookup_put)(struct ib_uobject *uobj, bool exclusive);
-	/*
-	 * Must be called with the exclusive lock held. If successful uobj is
-	 * invalid on return. On failure uobject is left completely
-	 * unchanged
-	 */
+	/* This does not consume the kref on uobj */
 	int __must_check (*remove_commit)(struct ib_uobject *uobj,
 					  enum rdma_remove_reason why);
 	u8    needs_kfree_rcu;

commit 32ed5c00ac5fdea49058fd49bf8707e101dc3dfe
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Wed Jul 25 21:40:11 2018 -0600

    IB/uverbs: Make the write path destroy methods use the same flow as ioctl
    
    The ridiculous dance with uobj_remove_commit() is not needed, the write
    path can follow the same flow as ioctl - lock and destroy the HW object
    then use the data left over in the uobject to form the response to
    userspace.
    
    Two helpers are introduced to make this flow straightforward for the
    caller.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index cfc50fcdbff6..8bae28dd2e4f 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -126,7 +126,6 @@ void rdma_lookup_put_uobject(struct ib_uobject *uobj, bool exclusive);
 struct ib_uobject *rdma_alloc_begin_uobject(const struct uverbs_obj_type *type,
 					    struct ib_uverbs_file *ufile);
 void rdma_alloc_abort_uobject(struct ib_uobject *uobj);
-int __must_check rdma_remove_commit_uobject(struct ib_uobject *uobj);
 int __must_check rdma_alloc_commit_uobject(struct ib_uobject *uobj);
 int rdma_explicit_destroy(struct ib_uobject *uobject);
 

commit aba94548c9e49939fafc92bb406a7f8e7ed87643
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Tue Jul 10 20:55:21 2018 -0600

    IB/uverbs: Move the FD uobj type struct file allocation to alloc_commit
    
    Allocating the struct file during alloc_begin creates this strange
    asymmetry with IDR, where the FD has two krefs pointing at it during the
    pre-commit phase. In particular this makes the abort process for FD very
    strange and confusing.
    
    For instance abort currently calls the type's destroy_object twice, and
    the fops release once if abort is done. This is very counter intuitive. No
    fops should be called until alloc_commit succeeds, and destroy_object
    should only ever be called once.
    
    Moving the struct file allocation to the alloc_commit is now simple, as we
    already support failure of rdma_alloc_commit_uobject, with all the
    required rollback pieces.
    
    This creates an understandable symmetry with IDR and simplifies/fixes the
    abort handling for FD types.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index 9b82e36128aa..cfc50fcdbff6 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -73,7 +73,7 @@ struct uverbs_obj_type_class {
 	 */
 	struct ib_uobject *(*alloc_begin)(const struct uverbs_obj_type *type,
 					  struct ib_uverbs_file *ufile);
-	void (*alloc_commit)(struct ib_uobject *uobj);
+	int (*alloc_commit)(struct ib_uobject *uobj);
 	void (*alloc_abort)(struct ib_uobject *uobj);
 
 	struct ib_uobject *(*lookup_get)(const struct uverbs_obj_type *type,

commit 2c96eb7d62de5048aa08e9ee4fbb607f29e2638c
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Tue Jul 10 20:55:20 2018 -0600

    IB/uverbs: Always propagate errors from rdma_alloc_commit_uobject()
    
    The ioctl framework already does this correctly, but the write path did
    not. This is trivially fixed by simply using a standard pattern to return
    uobj_alloc_commit() as the last statement in every function.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index 2f50cc6def3c..9b82e36128aa 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -127,7 +127,7 @@ struct ib_uobject *rdma_alloc_begin_uobject(const struct uverbs_obj_type *type,
 					    struct ib_uverbs_file *ufile);
 void rdma_alloc_abort_uobject(struct ib_uobject *uobj);
 int __must_check rdma_remove_commit_uobject(struct ib_uobject *uobj);
-int rdma_alloc_commit_uobject(struct ib_uobject *uobj);
+int __must_check rdma_alloc_commit_uobject(struct ib_uobject *uobj);
 int rdma_explicit_destroy(struct ib_uobject *uobject);
 
 struct uverbs_obj_fd_type {

commit 1250c3048cf1632f5dbb99a0242410baff67955d
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Tue Jul 10 20:55:14 2018 -0600

    IB/uverbs: Handle IDR and FD types without truncation
    
    Our ABI for write() uses a s32 for FDs and a u32 for IDRs, but internally
    we ended up implicitly casting these ABI values into an 'int'. For ioctl()
    we use a s64 for FDs and a u64 for IDRs, again casting to an int.
    
    The various casts to int are all missing range checks which can cause
    userspace values that should be considered invalid to be accepted.
    
    Fix this by making the generic lookup routine accept a s64, which does not
    truncate the write API's u32/s32 or the ioctl API's s64. Then push the
    detailed range checking down to the actual type implementations to be
    shared by both interfaces.
    
    Finally, change the copy of the uobj->id to sign extend into a s64, so eg,
    if we ever wish to return a negative value for a FD it is carried
    properly.
    
    This ensures that userspace values are never weirdly interpreted due to
    the various trunctations and everything that is really out of range gets
    an EINVAL.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index e2fc9db466d3..2f50cc6def3c 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -77,7 +77,7 @@ struct uverbs_obj_type_class {
 	void (*alloc_abort)(struct ib_uobject *uobj);
 
 	struct ib_uobject *(*lookup_get)(const struct uverbs_obj_type *type,
-					 struct ib_uverbs_file *ufile, int id,
+					 struct ib_uverbs_file *ufile, s64 id,
 					 bool exclusive);
 	void (*lookup_put)(struct ib_uobject *uobj, bool exclusive);
 	/*
@@ -121,7 +121,7 @@ struct uverbs_obj_idr_type {
 
 struct ib_uobject *rdma_lookup_get_uobject(const struct uverbs_obj_type *type,
 					   struct ib_uverbs_file *ufile,
-					   int id, bool exclusive);
+					   s64 id, bool exclusive);
 void rdma_lookup_put_uobject(struct ib_uobject *uobj, bool exclusive);
 struct ib_uobject *rdma_alloc_begin_uobject(const struct uverbs_obj_type *type,
 					    struct ib_uverbs_file *ufile);

commit d0259e82e7d214340aed33732e9a5ce448564921
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Wed Jul 4 11:32:11 2018 +0300

    IB/uverbs: Remove ib_uobject_file
    
    The only purpose for this structure was to hold the ib_uobject_file
    pointer, but now that is part of the standard ib_uobject the structure
    no longer makes any sense, so get rid of it.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index 5290d8d34e9a..e2fc9db466d3 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -139,7 +139,7 @@ struct uverbs_obj_fd_type {
 	 * the driver is removed or the process terminated.
 	 */
 	struct uverbs_obj_type  type;
-	int (*context_closed)(struct ib_uobject_file *uobj_file,
+	int (*context_closed)(struct ib_uobject *uobj,
 			      enum rdma_remove_reason why);
 	const struct file_operations	*fops;
 	const char			*name;
@@ -156,7 +156,8 @@ extern const struct uverbs_obj_type_class uverbs_fd_class;
 	 {.type = {							\
 		.type_class = &uverbs_fd_class,				\
 		.obj_size = (_obj_size) +				\
-			UVERBS_BUILD_BUG_ON((_obj_size) < sizeof(struct ib_uobject_file)), \
+			UVERBS_BUILD_BUG_ON((_obj_size) <               \
+					    sizeof(struct ib_uobject)), \
 	 },								\
 	 .context_closed = _context_closed,				\
 	 .fops = _fops,							\

commit 6ef1c82821b2ae9bfa26fe65e6f0a66dfd79b7d7
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Wed Jul 4 11:32:08 2018 +0300

    IB/uverbs: Replace ib_ucontext with ib_uverbs_file in core function calls
    
    The correct handle to refer to the idr/etc is ib_uverbs_file, revise all
    the core APIs to use this instead. The user API are left as wrappers
    that automatically convert a ucontext to a ufile for now.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index 175495d1b0b8..5290d8d34e9a 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -72,12 +72,12 @@ struct uverbs_obj_type_class {
 	 *		 reset flow).
 	 */
 	struct ib_uobject *(*alloc_begin)(const struct uverbs_obj_type *type,
-					  struct ib_ucontext *ucontext);
+					  struct ib_uverbs_file *ufile);
 	void (*alloc_commit)(struct ib_uobject *uobj);
 	void (*alloc_abort)(struct ib_uobject *uobj);
 
 	struct ib_uobject *(*lookup_get)(const struct uverbs_obj_type *type,
-					 struct ib_ucontext *ucontext, int id,
+					 struct ib_uverbs_file *ufile, int id,
 					 bool exclusive);
 	void (*lookup_put)(struct ib_uobject *uobj, bool exclusive);
 	/*
@@ -120,11 +120,11 @@ struct uverbs_obj_idr_type {
 };
 
 struct ib_uobject *rdma_lookup_get_uobject(const struct uverbs_obj_type *type,
-					   struct ib_ucontext *ucontext,
+					   struct ib_uverbs_file *ufile,
 					   int id, bool exclusive);
 void rdma_lookup_put_uobject(struct ib_uobject *uobj, bool exclusive);
 struct ib_uobject *rdma_alloc_begin_uobject(const struct uverbs_obj_type *type,
-					    struct ib_ucontext *ucontext);
+					    struct ib_uverbs_file *ufile);
 void rdma_alloc_abort_uobject(struct ib_uobject *uobj);
 int __must_check rdma_remove_commit_uobject(struct ib_uobject *uobj);
 int rdma_alloc_commit_uobject(struct ib_uobject *uobj);

commit 1c77483e4c50339b0306572167ccbff6b55d051b
Author: Yishai Hadas <yishaih@mellanox.com>
Date:   Wed Jun 20 17:11:39 2018 +0300

    IB: Improve uverbs_cleanup_ucontext algorithm
    
    Improve uverbs_cleanup_ucontext algorithm to work properly when the
    topology graph of the objects cannot be determined at compile time.  This
    is the case with objects created via the devx interface in mlx5.
    
    Typically uverbs objects must be created in a strict topologically sorted
    order, so that LIFO ordering will generally cause them to be freed
    properly. There are only a few cases (eg memory windows) where objects can
    point to things out of the strict LIFO order.
    
    Instead of using an explicit ordering scheme where the HW destroy is not
    allowed to fail, go over the list multiple times and allow the destroy
    function to fail. If progress halts then a final, desperate, cleanup is
    done before leaking the memory. This indicates a driver bug.
    
    Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index cc04ec65588d..175495d1b0b8 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -93,7 +93,6 @@ struct uverbs_obj_type_class {
 struct uverbs_obj_type {
 	const struct uverbs_obj_type_class * const type_class;
 	size_t	     obj_size;
-	unsigned int destroy_order;
 };
 
 /*
@@ -152,10 +151,9 @@ extern const struct uverbs_obj_type_class uverbs_fd_class;
 
 #define UVERBS_BUILD_BUG_ON(cond) (sizeof(char[1 - 2 * !!(cond)]) -	\
 				   sizeof(char))
-#define UVERBS_TYPE_ALLOC_FD(_order, _obj_size, _context_closed, _fops, _name, _flags)\
+#define UVERBS_TYPE_ALLOC_FD(_obj_size, _context_closed, _fops, _name, _flags)\
 	((&((const struct uverbs_obj_fd_type)				\
 	 {.type = {							\
-		.destroy_order = _order,				\
 		.type_class = &uverbs_fd_class,				\
 		.obj_size = (_obj_size) +				\
 			UVERBS_BUILD_BUG_ON((_obj_size) < sizeof(struct ib_uobject_file)), \
@@ -164,18 +162,17 @@ extern const struct uverbs_obj_type_class uverbs_fd_class;
 	 .fops = _fops,							\
 	 .name = _name,							\
 	 .flags = _flags}))->type)
-#define UVERBS_TYPE_ALLOC_IDR_SZ(_size, _order, _destroy_object)	\
+#define UVERBS_TYPE_ALLOC_IDR_SZ(_size, _destroy_object)	\
 	((&((const struct uverbs_obj_idr_type)				\
 	 {.type = {							\
-		.destroy_order = _order,				\
 		.type_class = &uverbs_idr_class,			\
 		.obj_size = (_size) +					\
 			UVERBS_BUILD_BUG_ON((_size) <			\
 					    sizeof(struct ib_uobject))	\
 	 },								\
 	 .destroy_object = _destroy_object,}))->type)
-#define UVERBS_TYPE_ALLOC_IDR(_order, _destroy_object)			\
-	 UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uobject), _order,	\
+#define UVERBS_TYPE_ALLOC_IDR(_destroy_object)			\
+	 UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uobject),	\
 				  _destroy_object)
 
 #endif

commit 4da70da23e9ba03f7f9e067fbe0eec6ebbfee401
Author: Matan Barak <matanb@mellanox.com>
Date:   Thu Aug 3 16:07:02 2017 +0300

    IB/core: Explicitly destroy an object while keeping uobject
    
    When some objects are destroyed, we need to extract their status at
    destruction. After object's destruction, this status
    (e.g. events_reported) relies in the uobject. In order to have the
    latest and correct status, the underlying object should be destroyed,
    but we should keep the uobject alive and read this information off the
    uobject. We introduce a rdma_explicit_destroy function. This function
    destroys the class type object (for example, the IDR class type which
    destroys the underlying object as well) and then convert the uobject
    to be of a null class type. This uobject will then be destroyed as any
    other uobject once uverbs_finalize_object[s] is called.
    
    Signed-off-by: Matan Barak <matanb@mellanox.com>
    Reviewed-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index 9760b6d70744..cc04ec65588d 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -129,6 +129,7 @@ struct ib_uobject *rdma_alloc_begin_uobject(const struct uverbs_obj_type *type,
 void rdma_alloc_abort_uobject(struct ib_uobject *uobj);
 int __must_check rdma_remove_commit_uobject(struct ib_uobject *uobj);
 int rdma_alloc_commit_uobject(struct ib_uobject *uobj);
+int rdma_explicit_destroy(struct ib_uobject *uobject);
 
 struct uverbs_obj_fd_type {
 	/*

commit 5009010fbf54bdc27e57baca490e1f9d6a4609e0
Author: Matan Barak <matanb@mellanox.com>
Date:   Thu Aug 3 16:06:58 2017 +0300

    IB/core: Declare an object instead of declaring only type attributes
    
    Switch all uverbs_type_attrs_xxxx with DECLARE_UVERBS_OBJECT
    macros. This will be later used in order to embed the object
    specific methods in the objects as well.
    
    Signed-off-by: Matan Barak <matanb@mellanox.com>
    Reviewed-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index 351ea185df44..9760b6d70744 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -151,22 +151,30 @@ extern const struct uverbs_obj_type_class uverbs_fd_class;
 
 #define UVERBS_BUILD_BUG_ON(cond) (sizeof(char[1 - 2 * !!(cond)]) -	\
 				   sizeof(char))
-#define UVERBS_TYPE_ALLOC_FD(_size, _order)				 \
-	{								 \
-		.destroy_order = _order,				 \
-		.type_class = &uverbs_fd_class,				 \
-		.obj_size = (_size) +					 \
-			  UVERBS_BUILD_BUG_ON((_size) <			 \
-					      sizeof(struct ib_uobject_file)),\
-	}
-#define UVERBS_TYPE_ALLOC_IDR_SZ(_size, _order)				\
-	{								\
+#define UVERBS_TYPE_ALLOC_FD(_order, _obj_size, _context_closed, _fops, _name, _flags)\
+	((&((const struct uverbs_obj_fd_type)				\
+	 {.type = {							\
+		.destroy_order = _order,				\
+		.type_class = &uverbs_fd_class,				\
+		.obj_size = (_obj_size) +				\
+			UVERBS_BUILD_BUG_ON((_obj_size) < sizeof(struct ib_uobject_file)), \
+	 },								\
+	 .context_closed = _context_closed,				\
+	 .fops = _fops,							\
+	 .name = _name,							\
+	 .flags = _flags}))->type)
+#define UVERBS_TYPE_ALLOC_IDR_SZ(_size, _order, _destroy_object)	\
+	((&((const struct uverbs_obj_idr_type)				\
+	 {.type = {							\
 		.destroy_order = _order,				\
 		.type_class = &uverbs_idr_class,			\
 		.obj_size = (_size) +					\
-			  UVERBS_BUILD_BUG_ON((_size) <			\
-					      sizeof(struct ib_uobject)), \
-	}
-#define UVERBS_TYPE_ALLOC_IDR(_order)					\
-	 UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uobject), _order)
+			UVERBS_BUILD_BUG_ON((_size) <			\
+					    sizeof(struct ib_uobject))	\
+	 },								\
+	 .destroy_object = _destroy_object,}))->type)
+#define UVERBS_TYPE_ALLOC_IDR(_order, _destroy_object)			\
+	 UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uobject), _order,	\
+				  _destroy_object)
+
 #endif

commit 30004b861afd99aebf34237373cb8ee9e890418e
Author: Matan Barak <matanb@mellanox.com>
Date:   Tue Apr 18 12:03:37 2017 +0300

    IB/core: Rename write flag to exclusive in rdma_core
    
    We rename the "write" flags to "exclusive", as it's used for both
    WRITE and DESTROY actions.
    
    Fixes: 3832125624b7 ('IB/core: Add support for idr types')
    Signed-off-by: Matan Barak <matanb@mellanox.com>
    Reviewed-by: Sean Hefty <sean.hefty@intel.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index a37692167a45..351ea185df44 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -54,17 +54,18 @@ struct uverbs_obj_type_class {
 	 *		 destroyed.
 	 * [lookup]:	 Starts with lookup_get which fetches and locks the
 	 *		 object. After the handler finished using the object, it
-	 *		 needs to call lookup_put to unlock it. The write flag
-	 *		 indicates if the object is locked for exclusive access.
-	 * [remove]:	 Starts with lookup_get with write flag set. This locks
-	 *		 the object for exclusive access. If the handler code
-	 *		 completed successfully, remove_commit is called and
-	 *		 the ib_uobject is removed from the context's uobjects
-	 *		 repository and put. The object itself is destroyed as
-	 *		 well. Once remove succeeds new krefs to the object
-	 *		 cannot be acquired by other threads or userspace and
-	 *		 the hardware driver is removed from the object.
-	 *		 Other krefs on the object may still exist.
+	 *		 needs to call lookup_put to unlock it. The exclusive
+	 *		 flag indicates if the object is locked for exclusive
+	 *		 access.
+	 * [remove]:	 Starts with lookup_get with exclusive flag set. This
+	 *		 locks the object for exclusive access. If the handler
+	 *		 code completed successfully, remove_commit is called
+	 *		 and the ib_uobject is removed from the context's
+	 *		 uobjects repository and put. The object itself is
+	 *		 destroyed as well. Once remove succeeds new krefs to
+	 *		 the object cannot be acquired by other threads or
+	 *		 userspace and the hardware driver is removed from the
+	 *		 object. Other krefs on the object may still exist.
 	 *		 If the handler code failed, lookup_put should be
 	 *		 called. This callback is used when the context
 	 *		 is destroyed as well (process termination,
@@ -77,10 +78,10 @@ struct uverbs_obj_type_class {
 
 	struct ib_uobject *(*lookup_get)(const struct uverbs_obj_type *type,
 					 struct ib_ucontext *ucontext, int id,
-					 bool write);
-	void (*lookup_put)(struct ib_uobject *uobj, bool write);
+					 bool exclusive);
+	void (*lookup_put)(struct ib_uobject *uobj, bool exclusive);
 	/*
-	 * Must be called with the write lock held. If successful uobj is
+	 * Must be called with the exclusive lock held. If successful uobj is
 	 * invalid on return. On failure uobject is left completely
 	 * unchanged
 	 */
@@ -121,8 +122,8 @@ struct uverbs_obj_idr_type {
 
 struct ib_uobject *rdma_lookup_get_uobject(const struct uverbs_obj_type *type,
 					   struct ib_ucontext *ucontext,
-					   int id, bool write);
-void rdma_lookup_put_uobject(struct ib_uobject *uobj, bool write);
+					   int id, bool exclusive);
+void rdma_lookup_put_uobject(struct ib_uobject *uobj, bool exclusive);
 struct ib_uobject *rdma_alloc_begin_uobject(const struct uverbs_obj_type *type,
 					    struct ib_ucontext *ucontext);
 void rdma_alloc_abort_uobject(struct ib_uobject *uobj);

commit 1e7710f3f6563940bb6bbc94aa8eadfd344a86af
Author: Matan Barak <matanb@mellanox.com>
Date:   Tue Apr 4 13:31:47 2017 +0300

    IB/core: Change completion channel to use the reworked objects schema
    
    This patch adds the standard fd based type - completion_channel.
    The completion_channel is now prefixed with ib_uobject, similarly
    to the rest of the uobjects.
    This requires a few changes:
    (1) We define a new completion channel fd based object type.
    (2) completion_event and async_event are now two different types.
        This means they use different fops.
    (3) We release the completion_channel exactly as we release other
        idr based objects.
    (4) Since ib_uobjects are already kref-ed, we only add the kref to the
        async event.
    
    A fd object requires filling out several parameters. Its op pointer
    should point to uverbs_fd_ops and its size should be at least the
    size if ib_uobject. We use a macro to make the type declaration
    easier.
    
    Signed-off-by: Matan Barak <matanb@mellanox.com>
    Reviewed-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index 58674290fab0..a37692167a45 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -146,9 +146,18 @@ struct uverbs_obj_fd_type {
 };
 
 extern const struct uverbs_obj_type_class uverbs_idr_class;
+extern const struct uverbs_obj_type_class uverbs_fd_class;
 
 #define UVERBS_BUILD_BUG_ON(cond) (sizeof(char[1 - 2 * !!(cond)]) -	\
 				   sizeof(char))
+#define UVERBS_TYPE_ALLOC_FD(_size, _order)				 \
+	{								 \
+		.destroy_order = _order,				 \
+		.type_class = &uverbs_fd_class,				 \
+		.obj_size = (_size) +					 \
+			  UVERBS_BUILD_BUG_ON((_size) <			 \
+					      sizeof(struct ib_uobject_file)),\
+	}
 #define UVERBS_TYPE_ALLOC_IDR_SZ(_size, _order)				\
 	{								\
 		.destroy_order = _order,				\

commit cf8966b3477d5e6545393bb4499f2051ea554c62
Author: Matan Barak <matanb@mellanox.com>
Date:   Tue Apr 4 13:31:46 2017 +0300

    IB/core: Add support for fd objects
    
    The completion channel we use in verbs infrastructure is FD based.
    Previously, we had a separate way to manage this object. Since we
    strive for a single way to manage any kind of object in this
    infrastructure, we conceptually treat all objects as subclasses
    of ib_uobject.
    
    This commit adds the necessary mechanism to support FD based objects
    like their IDR counterparts. FD objects release need to be synchronized
    with context release. We use the cleanup_mutex on the uverbs_file for
    that.
    
    Signed-off-by: Matan Barak <matanb@mellanox.com>
    Reviewed-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index 66368b5a3006..58674290fab0 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -129,6 +129,22 @@ void rdma_alloc_abort_uobject(struct ib_uobject *uobj);
 int __must_check rdma_remove_commit_uobject(struct ib_uobject *uobj);
 int rdma_alloc_commit_uobject(struct ib_uobject *uobj);
 
+struct uverbs_obj_fd_type {
+	/*
+	 * In fd based objects, uverbs_obj_type_ops points to generic
+	 * fd operations. In order to specialize the underlying types (e.g.
+	 * completion_channel), we use fops, name and flags for fd creation.
+	 * context_closed is called when the context is closed either when
+	 * the driver is removed or the process terminated.
+	 */
+	struct uverbs_obj_type  type;
+	int (*context_closed)(struct ib_uobject_file *uobj_file,
+			      enum rdma_remove_reason why);
+	const struct file_operations	*fops;
+	const char			*name;
+	int				flags;
+};
+
 extern const struct uverbs_obj_type_class uverbs_idr_class;
 
 #define UVERBS_BUILD_BUG_ON(cond) (sizeof(char[1 - 2 * !!(cond)]) -	\

commit 6be60aed126ccd4dfb4a60d1dc2ecec0bca21b2e
Author: Matan Barak <matanb@mellanox.com>
Date:   Tue Apr 4 13:31:43 2017 +0300

    IB/core: Add idr based standard types
    
    This patch adds the standard idr based types. These types are
    used in downstream patches in order to initialize, destroy and
    lookup IB standard objects which are based on idr objects.
    
    An idr object requires filling out several parameters. Its op pointer
    should point to uverbs_idr_ops and its size should be at least the
    size of ib_uobject. We add a macro to make the type declaration easier.
    
    Signed-off-by: Matan Barak <matanb@mellanox.com>
    Reviewed-by: Yishai Hadas <yishaih@mellanox.com>
    Reviewed-by: Sean Hefty <sean.hefty@intel.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
index 0777e405f22a..66368b5a3006 100644
--- a/include/rdma/uverbs_types.h
+++ b/include/rdma/uverbs_types.h
@@ -129,4 +129,18 @@ void rdma_alloc_abort_uobject(struct ib_uobject *uobj);
 int __must_check rdma_remove_commit_uobject(struct ib_uobject *uobj);
 int rdma_alloc_commit_uobject(struct ib_uobject *uobj);
 
+extern const struct uverbs_obj_type_class uverbs_idr_class;
+
+#define UVERBS_BUILD_BUG_ON(cond) (sizeof(char[1 - 2 * !!(cond)]) -	\
+				   sizeof(char))
+#define UVERBS_TYPE_ALLOC_IDR_SZ(_size, _order)				\
+	{								\
+		.destroy_order = _order,				\
+		.type_class = &uverbs_idr_class,			\
+		.obj_size = (_size) +					\
+			  UVERBS_BUILD_BUG_ON((_size) <			\
+					      sizeof(struct ib_uobject)), \
+	}
+#define UVERBS_TYPE_ALLOC_IDR(_order)					\
+	 UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uobject), _order)
 #endif

commit 3832125624b75b54567be906e9aa67e1343be569
Author: Matan Barak <matanb@mellanox.com>
Date:   Tue Apr 4 13:31:42 2017 +0300

    IB/core: Add support for idr types
    
    The new ioctl infrastructure supports driver specific objects.
    Each such object type has a hot unplug function, allocation size and
    an order of destruction.
    
    When a ucontext is created, a new list is created in this ib_ucontext.
    This list contains all objects created under this ib_ucontext.
    When a ib_ucontext is destroyed, we traverse this list several time
    destroying the various objects by the order mentioned in the object
    type description. If few object types have the same destruction order,
    they are destroyed in an order opposite to their creation.
    
    Adding an object is done in two parts.
    First, an object is allocated and added to idr tree. Then, the
    command's handlers (in downstream patches) could work on this object
    and fill in its required details.
    After a successful command, the commit part is called and the user
    objects become ucontext visible. If the handler failed, alloc_abort
    should be called.
    
    Removing an uboject is done by calling lookup_get with the write flag
    and finalizing it with destroy_commit. A major change from the previous
    code is that we actually destroy the kernel object itself in
    destroy_commit (rather than just the uobject).
    
    We should make sure idr (per-uverbs-file) and list (per-ucontext) could
    be accessed concurrently without corrupting them.
    
    Signed-off-by: Matan Barak <matanb@mellanox.com>
    Reviewed-by: Yishai Hadas <yishaih@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/include/rdma/uverbs_types.h b/include/rdma/uverbs_types.h
new file mode 100644
index 000000000000..0777e405f22a
--- /dev/null
+++ b/include/rdma/uverbs_types.h
@@ -0,0 +1,132 @@
+/*
+ * Copyright (c) 2017, Mellanox Technologies inc.  All rights reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef _UVERBS_TYPES_
+#define _UVERBS_TYPES_
+
+#include <linux/kernel.h>
+#include <rdma/ib_verbs.h>
+
+struct uverbs_obj_type;
+
+struct uverbs_obj_type_class {
+	/*
+	 * Get an ib_uobject that corresponds to the given id from ucontext,
+	 * These functions could create or destroy objects if required.
+	 * The action will be finalized only when commit, abort or put fops are
+	 * called.
+	 * The flow of the different actions is:
+	 * [alloc]:	 Starts with alloc_begin. The handlers logic is than
+	 *		 executed. If the handler is successful, alloc_commit
+	 *		 is called and the object is inserted to the repository.
+	 *		 Once alloc_commit completes the object is visible to
+	 *		 other threads and userspace.
+	 e		 Otherwise, alloc_abort is called and the object is
+	 *		 destroyed.
+	 * [lookup]:	 Starts with lookup_get which fetches and locks the
+	 *		 object. After the handler finished using the object, it
+	 *		 needs to call lookup_put to unlock it. The write flag
+	 *		 indicates if the object is locked for exclusive access.
+	 * [remove]:	 Starts with lookup_get with write flag set. This locks
+	 *		 the object for exclusive access. If the handler code
+	 *		 completed successfully, remove_commit is called and
+	 *		 the ib_uobject is removed from the context's uobjects
+	 *		 repository and put. The object itself is destroyed as
+	 *		 well. Once remove succeeds new krefs to the object
+	 *		 cannot be acquired by other threads or userspace and
+	 *		 the hardware driver is removed from the object.
+	 *		 Other krefs on the object may still exist.
+	 *		 If the handler code failed, lookup_put should be
+	 *		 called. This callback is used when the context
+	 *		 is destroyed as well (process termination,
+	 *		 reset flow).
+	 */
+	struct ib_uobject *(*alloc_begin)(const struct uverbs_obj_type *type,
+					  struct ib_ucontext *ucontext);
+	void (*alloc_commit)(struct ib_uobject *uobj);
+	void (*alloc_abort)(struct ib_uobject *uobj);
+
+	struct ib_uobject *(*lookup_get)(const struct uverbs_obj_type *type,
+					 struct ib_ucontext *ucontext, int id,
+					 bool write);
+	void (*lookup_put)(struct ib_uobject *uobj, bool write);
+	/*
+	 * Must be called with the write lock held. If successful uobj is
+	 * invalid on return. On failure uobject is left completely
+	 * unchanged
+	 */
+	int __must_check (*remove_commit)(struct ib_uobject *uobj,
+					  enum rdma_remove_reason why);
+	u8    needs_kfree_rcu;
+};
+
+struct uverbs_obj_type {
+	const struct uverbs_obj_type_class * const type_class;
+	size_t	     obj_size;
+	unsigned int destroy_order;
+};
+
+/*
+ * Objects type classes which support a detach state (object is still alive but
+ * it's not attached to any context need to make sure:
+ * (a) no call through to a driver after a detach is called
+ * (b) detach isn't called concurrently with context_cleanup
+ */
+
+struct uverbs_obj_idr_type {
+	/*
+	 * In idr based objects, uverbs_obj_type_class points to a generic
+	 * idr operations. In order to specialize the underlying types (e.g. CQ,
+	 * QPs, etc.), we add destroy_object specific callbacks.
+	 */
+	struct uverbs_obj_type  type;
+
+	/* Free driver resources from the uobject, make the driver uncallable,
+	 * and move the uobject to the detached state. If the object was
+	 * destroyed by the user's request, a failure should leave the uobject
+	 * completely unchanged.
+	 */
+	int __must_check (*destroy_object)(struct ib_uobject *uobj,
+					   enum rdma_remove_reason why);
+};
+
+struct ib_uobject *rdma_lookup_get_uobject(const struct uverbs_obj_type *type,
+					   struct ib_ucontext *ucontext,
+					   int id, bool write);
+void rdma_lookup_put_uobject(struct ib_uobject *uobj, bool write);
+struct ib_uobject *rdma_alloc_begin_uobject(const struct uverbs_obj_type *type,
+					    struct ib_ucontext *ucontext);
+void rdma_alloc_abort_uobject(struct ib_uobject *uobj);
+int __must_check rdma_remove_commit_uobject(struct ib_uobject *uobj);
+int rdma_alloc_commit_uobject(struct ib_uobject *uobj);
+
+#endif
