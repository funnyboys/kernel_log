commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index c9bd935f4fd1..c25fb86ffae9 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * iSCSI lib definitions
  *
@@ -5,20 +6,6 @@
  * Copyright (C) 2004 - 2006 Mike Christie
  * Copyright (C) 2004 - 2005 Dmitry Yusupov
  * Copyright (C) 2004 - 2005 Alex Aizman
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 #ifndef LIBISCSI_H
 #define LIBISCSI_H

commit 8d5e72dfdf0fa29a21143fd72746c6f43295ce9f
Merge: 2bd804017435 e7731da36f10
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 4 12:19:44 2017 -0700

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This update includes the usual round of major driver updates
      (hisi_sas, ufs, fnic, cxlflash, be2iscsi, ipr, stex). There's also the
      usual amount of cosmetic and spelling stuff"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (155 commits)
      scsi: qla4xxx: fix spelling mistake: "Tempalate" -> "Template"
      scsi: stex: make S6flag static
      scsi: mac_esp: fix to pass correct device identity to free_irq()
      scsi: aacraid: pci_alloc_consistent() failures on ARM64
      scsi: ufs: make ufshcd_get_lists_status() register operation obvious
      scsi: ufs: use MASK_EE_STATUS
      scsi: mac_esp: Replace bogus memory barrier with spinlock
      scsi: fcoe: make fcoe_e_d_tov and fcoe_r_a_tov static
      scsi: sd_zbc: Do not write lock zones for reset
      scsi: sd_zbc: Remove superfluous assignments
      scsi: sd: sd_zbc: Rename sd_zbc_setup_write_cmnd
      scsi: Improve scsi_get_sense_info_fld
      scsi: sd: Cleanup sd_done sense data handling
      scsi: sd: Improve sd_completed_bytes
      scsi: sd: Fix function descriptions
      scsi: mpt3sas: remove redundant wmb
      scsi: mpt: Move scsi_remove_host() out of mptscsih_remove_host()
      scsi: sg: reset 'res_in_use' after unlinking reserved array
      scsi: mvumi: remove code handling zero scsi_sg_count(scmd) case
      scsi: fusion: fix spelling mistake: "Persistancy" -> "Persistency"
      ...

commit 6dc618cdd6b896791313926becb1f86ede0e046a
Author: Elena Reshetova <elena.reshetova@intel.com>
Date:   Thu Mar 9 13:46:58 2017 +0200

    scsi: libiscsi: qedi: convert iscsi_task.refcount from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be used instead of atomic_t
    when the variable is used as a reference counter. This allows to avoid
    accidental refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Acked-by: Chris Leech <cleech@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index b0e275de6dec..24d74b5bcb24 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -29,6 +29,7 @@
 #include <linux/timer.h>
 #include <linux/workqueue.h>
 #include <linux/kfifo.h>
+#include <linux/refcount.h>
 #include <scsi/iscsi_proto.h>
 #include <scsi/iscsi_if.h>
 #include <scsi/scsi_transport_iscsi.h>
@@ -139,7 +140,7 @@ struct iscsi_task {
 
 	/* state set/tested under session->lock */
 	int			state;
-	atomic_t		refcount;
+	refcount_t		refcount;
 	struct list_head	running;	/* running cmd list */
 	void			*dd_data;	/* driver/transport data */
 };

commit 6f8830f5bbab16e54f261de187f3df4644a5b977
Author: Chris Leech <cleech@redhat.com>
Date:   Mon Feb 27 16:58:36 2017 -0800

    scsi: libiscsi: add lock around task lists to fix list corruption regression
    
    There's a rather long standing regression from the commit "libiscsi:
    Reduce locking contention in fast path"
    
    Depending on iSCSI target behavior, it's possible to hit the case in
    iscsi_complete_task where the task is still on a pending list
    (!list_empty(&task->running)).  When that happens the task is removed
    from the list while holding the session back_lock, but other task list
    modification occur under the frwd_lock.  That leads to linked list
    corruption and eventually a panicked system.
    
    Rather than back out the session lock split entirely, in order to try
    and keep some of the performance gains this patch adds another lock to
    maintain the task lists integrity.
    
    Major enterprise supported kernels have been backing out the lock split
    for while now, thanks to the efforts at IBM where a lab setup has the
    most reliable reproducer I've seen on this issue.  This patch has been
    tested there successfully.
    
    Signed-off-by: Chris Leech <cleech@redhat.com>
    Fixes: 659743b02c41 ("[SCSI] libiscsi: Reduce locking contention in fast path")
    Reported-by: Prashantha Subbarao <psubbara@us.ibm.com>
    Reviewed-by: Guilherme G. Piccoli <gpiccoli@linux.vnet.ibm.com>
    Cc: <stable@vger.kernel.org> # v3.15+
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index b0e275de6dec..583875ea136a 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -196,6 +196,7 @@ struct iscsi_conn {
 	struct iscsi_task	*task;		/* xmit task in progress */
 
 	/* xmit */
+	spinlock_t		taskqueuelock;  /* protects the next three lists */
 	struct list_head	mgmtqueue;	/* mgmt (control) xmit queue */
 	struct list_head	cmdqueue;	/* data-path cmd queue */
 	struct list_head	requeue;	/* tasks needing another run */

commit b6a05c823fc573a65efc4466f174abf05f922e0f
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 30 13:18:58 2017 +0100

    scsi: remove eh_timed_out methods in the transport template
    
    Instead define the timeout behavior purely based on the host_template
    eh_timed_out method and wire up the existing transport implementations
    in the host templates.  This also clears up the confusion that the
    transport template method overrides the host template one, so some
    drivers have to re-override the transport template one.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 4d1c46aac331..b0e275de6dec 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -383,6 +383,7 @@ extern int iscsi_eh_recover_target(struct scsi_cmnd *sc);
 extern int iscsi_eh_session_reset(struct scsi_cmnd *sc);
 extern int iscsi_eh_device_reset(struct scsi_cmnd *sc);
 extern int iscsi_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *sc);
+extern enum blk_eh_timer_return iscsi_eh_cmd_timed_out(struct scsi_cmnd *sc);
 
 /*
  * iSCSI host helpers.

commit db5ed4dfd5dd0142ec36ff7b335e0ec3b836b3e6
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Nov 13 15:08:42 2014 +0100

    scsi: drop reason argument from ->change_queue_depth
    
    Drop the now unused reason argument from the ->change_queue_depth method.
    Also add a return value to scsi_adjust_queue_depth, and rename it to
    scsi_change_queue_depth now that it can be used as the default
    ->change_queue_depth implementation.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 728c9ad9feb0..4d1c46aac331 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -378,8 +378,6 @@ struct iscsi_host {
 /*
  * scsi host template
  */
-extern int iscsi_change_queue_depth(struct scsi_device *sdev, int depth,
-				    int reason);
 extern int iscsi_eh_abort(struct scsi_cmnd *sc);
 extern int iscsi_eh_recover_target(struct scsi_cmnd *sc);
 extern int iscsi_eh_session_reset(struct scsi_cmnd *sc);

commit 877f075aac900288ce2e6a64075cceff09210a7e
Merge: 3cf59142bcd3 f7eaa7ed8fd4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 3 16:57:19 2014 -0700

    Merge tag 'rdma-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/roland/infiniband
    
    Pull infiniband updates from Roland Dreier:
     "Main batch of InfiniBand/RDMA changes for 3.15:
    
       - The biggest change is core API extensions and mlx5 low-level driver
         support for handling DIF/DIX-style protection information, and the
         addition of PI support to the iSER initiator.  Target support will
         be arriving shortly through the SCSI target tree.
    
       - A nice simplification to the "umem" memory pinning library now that
         we have chained sg lists.  Kudos to Yishai Hadas for realizing our
         code didn't have to be so crazy.
    
       - Another nice simplification to the sg wrappers used by qib, ipath
         and ehca to handle their mapping of memory to adapter.
    
       - The usual batch of fixes to bugs found by static checkers etc.
         from intrepid people like Dan Carpenter and Yann Droneaud.
    
       - A large batch of cxgb4, ocrdma, qib driver updates"
    
    * tag 'rdma-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/roland/infiniband: (102 commits)
      RDMA/ocrdma: Unregister inet notifier when unloading ocrdma
      RDMA/ocrdma: Fix warnings about pointer <-> integer casts
      RDMA/ocrdma: Code clean-up
      RDMA/ocrdma: Display FW version
      RDMA/ocrdma: Query controller information
      RDMA/ocrdma: Support non-embedded mailbox commands
      RDMA/ocrdma: Handle CQ overrun error
      RDMA/ocrdma: Display proper value for max_mw
      RDMA/ocrdma: Use non-zero tag in SRQ posting
      RDMA/ocrdma: Memory leak fix in ocrdma_dereg_mr()
      RDMA/ocrdma: Increment abi version count
      RDMA/ocrdma: Update version string
      be2net: Add abi version between be2net and ocrdma
      RDMA/ocrdma: ABI versioning between ocrdma and be2net
      RDMA/ocrdma: Allow DPP QP creation
      RDMA/ocrdma: Read ASIC_ID register to select asic_gen
      RDMA/ocrdma: SQ and RQ doorbell offset clean up
      RDMA/ocrdma: EQ full catastrophe avoidance
      RDMA/cxgb4: Disable DSGL use by default
      RDMA/cxgb4: rx_data() needs to hold the ep mutex
      ...

commit 55e51eda4820ec5a1c1fc8693a51029f74eac2b9
Author: Sagi Grimberg <sagig@mellanox.com>
Date:   Wed Mar 5 19:43:49 2014 +0200

    SCSI/libiscsi: Add check_protection callback for transports
    
    iSCSI needs to be at least aware that a task involves protection
    information.  In case it does, after the transaction completed libiscsi
    will ask the transport to check the protection status of the
    transaction.
    
    Unlike transport errors, DIF errors should not prevent successful
    completion of the transaction from the transport point of view, but
    should be escelated to scsi mid-layer when constructing the scsi
    result and sense data.
    
    check_protection routine will return the ascq corresponding to the DIF
    error that occured (or 0 if no error happened).
    
    return ascq:
    - 0x1: GUARD_CHECK_FAILED
    - 0x2: APPTAG_CHECK_FAILED
    - 0x3: REFTAG_CHECK_FAILED
    
    Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
    Signed-off-by: Alex Tabachnik <alext@mellanox.com>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 309f51336fb9..1457c26dfc58 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -133,6 +133,10 @@ struct iscsi_task {
 	unsigned long		last_xfer;
 	unsigned long		last_timeout;
 	bool			have_checked_conn;
+
+	/* T10 protection information */
+	bool			protected;
+
 	/* state set/tested under session->lock */
 	int			state;
 	atomic_t		refcount;

commit 659743b02c411075b26601725947b21df0bb29c8
Author: Shlomo Pongratz <shlomop@mellanox.com>
Date:   Fri Feb 7 00:41:38 2014 -0600

    [SCSI] libiscsi: Reduce locking contention in fast path
    
    Replace the session lock with two locks, a forward lock and
    a backwards lock named frwd_lock and back_lock respectively.
    
    The forward lock protects resources that change while sending a
    request to the target, such as cmdsn, queued_cmdsn, and allocating
    task from the commands' pool with kfifo_out.
    
    The backward lock protects resources that change while processing
    a response or in error path, such as cmdsn_exp, cmdsn_max, and
    returning tasks to the commands' pool with kfifo_in.
    
    Under a steady state fast-path situation, that is when one
    or more processes/threads submit IO to an iscsi device and
    a single kernel upcall (e.g softirq) is dealing with processing
    of responses without errors, this patch eliminates the contention
    between the queuecommand()/request response/scsi_done() flows
    associated with iscsi sessions.
    
    Between the forward and the backward locks exists a strict locking
    hierarchy. The mutual exclusion zone protected by the forward lock can
    enclose the mutual exclusion zone protected by the backward lock but not
    vice versa.
    
    For example, in iscsi_conn_teardown or in iscsi_xmit_data when there is
    a failure and __iscsi_put_task is called, the backward lock is taken while
    the forward lock is still taken. On the other hand, if in the RX path a nop
    is to be sent, for example in iscsi_handle_reject or __iscsi_complete_pdu
    than the forward lock is released and the backward lock is taken for the
    duration of iscsi_send_nopout, later the backward lock is released and the
    forward lock is retaken.
    
    libiscsi_tcp uses two kernel fifos the r2t pool and the r2t queue.
    
    The insertion and deletion from these queues didn't corespond to the
    assumption taken by the new forward/backwards session locking paradigm.
    
    That is, in iscsi_tcp_clenup_task which belongs to the RX (backwards)
    path, r2t is taken out from r2t queue and inserted to the r2t pool.
    In iscsi_tcp_get_curr_r2t which belong to the TX (forward) path, r2t
    is also inserted to the r2t pool and another r2t is pulled from r2t
    queue.
    
    Only in iscsi_tcp_r2t_rsp which is called in the RX path but can requeue
    to the TX path, r2t is taken from the r2t pool and inserted to the r2t
    queue.
    
    In order to cope with this situation, two spin locks were added,
    pool2queue and queue2pool. The former protects extracting from the
    r2t pool and inserting to the r2t queue, and the later protects the
    extracing from the r2t queue and inserting to the r2t pool.
    
    Signed-off-by: Shlomo Pongratz <shlomop@mellanox.com>
    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    [minor fix up to apply cleanly and compile fix]
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 309f51336fb9..7221a24e821b 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -327,12 +327,19 @@ struct iscsi_session {
 	struct iscsi_transport	*tt;
 	struct Scsi_Host	*host;
 	struct iscsi_conn	*leadconn;	/* leading connection */
-	spinlock_t		lock;		/* protects session state, *
-						 * sequence numbers,       *
+	/* Between the forward and the backward locks exists a strict locking
+	 * hierarchy. The mutual exclusion zone protected by the forward lock
+	 * can enclose the mutual exclusion zone protected by the backward lock
+	 * but not vice versa.
+	 */
+	spinlock_t		frwd_lock;	/* protects session state, *
+						 * cmdsn, queued_cmdsn     *
 						 * session resources:      *
-						 * - cmdpool,		   *
-						 * - mgmtpool,		   *
-						 * - r2tpool		   */
+						 * - cmdpool kfifo_out ,   *
+						 * - mgmtpool,		   */
+	spinlock_t		back_lock;	/* protects cmdsn_exp      *
+						 * cmdsn_max,              *
+						 * cmdpool kfifo_in        */
 	int			state;		/* session state           */
 	int			age;		/* counts session re-opens */
 

commit ae56ff4084129c7d8a5bf946d48602f551bff2f5
Author: Adheer Chandravanshi <adheer.chandravanshi@qlogic.com>
Date:   Fri Nov 22 05:28:21 2013 -0500

    [SCSI] libiscsi: Add local_ipaddr parameter in iscsi_conn struct
    
    Add local_ipaddr param and support get/set operations on it.
    
    Signed-off-by: Adheer Chandravanshi <adheer.chandravanshi@qlogic.com>
    Signed-off-by: Vikas Chaudhary <vikas.chaudhary@qlogic.com>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 6ac9e17acdc4..309f51336fb9 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -231,6 +231,7 @@ struct iscsi_conn {
 	uint8_t			ipv6_traffic_class;
 	uint8_t			ipv6_flow_label;
 	uint8_t			is_fw_assigned_ipv6;
+	char			*local_ipaddr;
 
 	/* MIB-statistics */
 	uint64_t		txdata_octets;

commit f8525eb4cff0c5df5b513a5f30ffebcda43460bb
Author: Adheer Chandravanshi <adheer.chandravanshi@qlogic.com>
Date:   Mon Jul 1 05:54:12 2013 -0400

    [SCSI] libiscsi: Exporting new attrs for iscsi session and connection in sysfs
    
    Signed-off-by: Adheer Chandravanshi <adheer.chandravanshi@qlogic.com>
    Signed-off-by: Vikas Chaudhary <vikas.chaudhary@qlogic.com>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 4265a4bb83cd..6ac9e17acdc4 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -62,6 +62,8 @@ enum {
 	TMF_NOT_FOUND,
 };
 
+#define ISID_SIZE			6
+
 /* Connection suspend "bit" */
 #define ISCSI_SUSPEND_BIT		1
 
@@ -173,6 +175,7 @@ struct iscsi_conn {
 
 	/* iSCSI connection-wide sequencing */
 	uint32_t		exp_statsn;
+	uint32_t		statsn;
 
 	/* control data */
 	int			id;		/* CID */
@@ -213,6 +216,22 @@ struct iscsi_conn {
 	int			persistent_port;
 	char			*persistent_address;
 
+	unsigned		max_segment_size;
+	unsigned		tcp_xmit_wsf;
+	unsigned		tcp_recv_wsf;
+	uint16_t		keepalive_tmo;
+	uint16_t		local_port;
+	uint8_t			tcp_timestamp_stat;
+	uint8_t			tcp_nagle_disable;
+	uint8_t			tcp_wsf_disable;
+	uint8_t			tcp_timer_scale;
+	uint8_t			tcp_timestamp_en;
+	uint8_t			fragment_disable;
+	uint8_t			ipv4_tos;
+	uint8_t			ipv6_traffic_class;
+	uint8_t			ipv6_flow_label;
+	uint8_t			is_fw_assigned_ipv6;
+
 	/* MIB-statistics */
 	uint64_t		txdata_octets;
 	uint64_t		rxdata_octets;
@@ -290,6 +309,18 @@ struct iscsi_session {
 	char			*boot_root;
 	char			*boot_nic;
 	char			*boot_target;
+	char			*portal_type;
+	char			*discovery_parent_type;
+	uint16_t		discovery_parent_idx;
+	uint16_t		def_taskmgmt_tmo;
+	uint16_t		tsid;
+	uint8_t			auto_snd_tgt_disable;
+	uint8_t			discovery_sess;
+	uint8_t			chap_auth_en;
+	uint8_t			discovery_logout_en;
+	uint8_t			bidi_chap_en;
+	uint8_t			discovery_auth_optional;
+	uint8_t			isid[ISID_SIZE];
 
 	/* control data */
 	struct iscsi_transport	*tt;

commit 3b9373e95a6019cf89abe6c8b17c07828db96ad4
Author: Eddie Wai <eddie.wai@broadcom.com>
Date:   Thu Jun 20 10:21:26 2013 -0700

    [SCSI] libiscsi: Added new boot entries in the session sysfs
    
    This is the kernel part of the modification to extract the net params
    from the ibft sysfs to the iface struct used for the connection
    request upon sync_session in the open-iscsi util.
    
    Three new session sysfs params are defined:
    boot_root - holds the name of the /sys/firmware/ibft or iscsi_rootN
    boot_nic  - holds the ethernetN name
    boot_target - holds the targetN name
    
    Signed-off-by: Eddie Wai <eddie.wai@broadcom.com>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 09c041e6c35f..4265a4bb83cd 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -287,6 +287,10 @@ struct iscsi_session {
 	char			*targetalias;
 	char			*ifacename;
 	char			*initiatorname;
+	char			*boot_root;
+	char			*boot_nic;
+	char			*boot_target;
+
 	/* control data */
 	struct iscsi_transport	*tt;
 	struct Scsi_Host	*host;

commit adaf6990ddf50b301c38eda7c0cb7b182df01c3b
Author: Adheer Chandravanshi <adheer.chandravanshi@qlogic.com>
Date:   Fri Mar 22 07:41:30 2013 -0400

    [SCSI] libiscsi: export function iscsi_switch_str_param
    
    Signed-off-by: Adheer Chandravanshi <adheer.chandravanshi@qlogic.com>
    Signed-off-by: Vikas Chaudhary <vikas.chaudhary@qlogic.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 6e33386a3898..09c041e6c35f 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -427,6 +427,7 @@ extern void iscsi_complete_scsi_task(struct iscsi_task *task,
  */
 extern void iscsi_pool_free(struct iscsi_pool *);
 extern int iscsi_pool_init(struct iscsi_pool *, int, void ***, int);
+extern int iscsi_switch_str_param(char **, char *);
 
 /*
  * inline functions to deal with padding.

commit 1304be5fe0efb42b7ec6a50dd8e1a9bce2adae17
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Jan 26 21:13:10 2012 -0600

    [SCSI] libiscsi_tcp: fix max_r2t manipulation
    
    Problem description from Xi Wang:
    A large max_r2t could lead to integer overflow in subsequent call to
    iscsi_tcp_r2tpool_alloc(), allocating a smaller buffer than expected
    and leading to out-of-bounds write.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 2e42e9a0e0b6..6e33386a3898 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -268,7 +268,7 @@ struct iscsi_session {
 	int			lu_reset_timeout;
 	int			tgt_reset_timeout;
 	int			initial_r2t_en;
-	unsigned		max_r2t;
+	unsigned short		max_r2t;
 	int			imm_data_en;
 	unsigned		first_burst;
 	unsigned		max_burst;

commit 3c5c48011809045881d30e197577ef1dca9a3e72
Author: Vikas Chaudhary <vikas.chaudhary@qlogic.com>
Date:   Thu Jan 19 03:06:53 2012 -0800

    [SCSI] libiscsi: Added support to show targetalias in sysfs
    
    sysfs patch to view target alias:
      /sys/class/iscsi_session/session*/targetalias
    
    Signed-off-by: Vikas Chaudhary <vikas.chaudhary@qlogic.com>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index cedcff371c88..2e42e9a0e0b6 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -284,6 +284,7 @@ struct iscsi_session {
 	char			*password;
 	char			*password_in;
 	char			*targetname;
+	char			*targetalias;
 	char			*ifacename;
 	char			*initiatorname;
 	/* control data */

commit 516f43a2a555000e77c1d59b8298cb46aad9ecc1
Author: Andy Grover <agrover@redhat.com>
Date:   Thu Jun 16 15:57:09 2011 -0700

    [SCSI] iscsi: Use struct scsi_lun in iscsi structs instead of u8[8]
    
    struct scsi_lun is also just a struct with an array of 8 octets (64 bits)
    but using it instead in iscsi structs lets us call scsilun_to_int
    without a cast, and also lets us copy it using assignment, instead of
    memcpy().
    
    Signed-off-by: Andy Grover <agrover@redhat.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 0f4367751b71..cedcff371c88 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -115,7 +115,7 @@ struct iscsi_task {
 	/* copied values in case we need to send tmfs */
 	itt_t			hdr_itt;
 	__be32			cmdsn;
-	uint8_t			lun[8];
+	struct scsi_lun		lun;
 
 	int			itt;		/* this ITT */
 

commit c71b9b669e1243623f7ed4332877d3f2beafc6ab
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed Feb 16 15:04:38 2011 -0600

    [SCSI] cxgbi: convert to use iscsi_conn_get_addr_param
    
    This has cxgbi use the iscsi_conn_get_addr_param helper
    and the get ep callback.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 4bef19fb3a65..0f4367751b71 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -212,9 +212,6 @@ struct iscsi_conn {
 	/* values userspace uses to id a conn */
 	int			persistent_port;
 	char			*persistent_address;
-	/* remote portal currently connected to */
-	int			portal_port;
-	char			portal_address[ISCSI_ADDRESS_BUF_LEN];
 
 	/* MIB-statistics */
 	uint64_t		txdata_octets;
@@ -319,9 +316,6 @@ struct iscsi_host {
 	/* hw address or netdev iscsi connection is bound to */
 	char			*hwaddress;
 	char			*netdev;
-	/* local address */
-	int			local_port;
-	char			local_address[ISCSI_ADDRESS_BUF_LEN];
 
 	wait_queue_head_t	session_removal_wq;
 	/* protects sessions and state */

commit 00f3708e6ed1698d6aee3901ea991197e31a8007
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed Feb 16 15:04:35 2011 -0600

    [SCSI] libiscsi: add helper to convert addr to string
    
    This adds a helper to convert a addr struct to
    a string. This will be used by the drivers in
    the next patches.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 748382b32b52..4bef19fb3a65 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -394,6 +394,8 @@ extern void iscsi_session_failure(struct iscsi_session *session,
 				  enum iscsi_err err);
 extern int iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
 				enum iscsi_param param, char *buf);
+extern int iscsi_conn_get_addr_param(struct sockaddr_storage *addr,
+				     enum iscsi_param param, char *buf);
 extern void iscsi_suspend_tx(struct iscsi_conn *conn);
 extern void iscsi_suspend_queue(struct iscsi_conn *conn);
 extern void iscsi_conn_queue_work(struct iscsi_conn *conn);

commit f41d472179a0d7c8e8160c85180ab1124947068e
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Fri Dec 31 02:22:21 2010 -0600

    [SCSI] libiscsi: do not take host lock in queuecommand
    
    iscsi_tcp, ib_iser, cxgb*, be2iscsi and bnx2i do not use
    the host lock and do not take the session lock against
    a irq, so this patch drops the DEF_SCSI_QCMD use. Instead
    we just take the session lock and disable bhs.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 68e951d79f0b..748382b32b52 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -89,6 +89,7 @@ enum {
 	ISCSI_TASK_RUNNING,
 	ISCSI_TASK_ABRT_TMF,		/* aborted due to TMF */
 	ISCSI_TASK_ABRT_SESS_RECOV,	/* aborted due to session recovery */
+	ISCSI_TASK_REQUEUE_SCSIQ,	/* qcmd requeueing to scsi-ml */
 };
 
 struct iscsi_r2t_info {
@@ -341,7 +342,7 @@ extern int iscsi_eh_abort(struct scsi_cmnd *sc);
 extern int iscsi_eh_recover_target(struct scsi_cmnd *sc);
 extern int iscsi_eh_session_reset(struct scsi_cmnd *sc);
 extern int iscsi_eh_device_reset(struct scsi_cmnd *sc);
-extern int iscsi_queuecommand(struct Scsi_Host *h, struct scsi_cmnd *sc);
+extern int iscsi_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *sc);
 
 /*
  * iSCSI host helpers.

commit 8eea2f55a65b9471276e78e5c86ddd19c4c0365c
Author: Eddie Wai <eddie.wai@broadcom.com>
Date:   Tue Nov 23 15:29:21 2010 -0800

    [SCSI] bnx2i: Added fix for NOP-Out response panic from unsolicited NOP-In
    
    The patch fixes the following situations where NOP-Out pkt is called for:
    - local unsolicited NOP-Out requests (requesting no NOP-In response)
    - local NOP-Out responses to unsolicited NOP-In requests
    
    kernel panic is observed due to double session spin_lock requests; one in the
    bnx2i_process_nopin_local_cmpl routine in bnx2i_hwi.c and the other in the
    iscsi_put_task routine in libiscsi.c
    
    The proposed fix is to export the currently static __iscsi_put_task() routine
    and have bnx2i call it directly instead of the iscsi_put_task() routine which
    holds the session spin lock.
    
    Signed-off-by: Eddie Wai <eddie.wai@broadcom.com>
    Reviewed-by: Michael Chan <mchan@broadcom.com>
    Reviewed-by: Anil Veerabhadrappa <anilgv@broadcom.com>
    Acked-by: Benjamin Li <benli@broadcom.com>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index b81d969ddc67..68e951d79f0b 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -419,6 +419,7 @@ extern struct iscsi_task *iscsi_itt_to_ctask(struct iscsi_conn *, itt_t);
 extern struct iscsi_task *iscsi_itt_to_task(struct iscsi_conn *, itt_t);
 extern void iscsi_requeue_task(struct iscsi_task *task);
 extern void iscsi_put_task(struct iscsi_task *task);
+extern void __iscsi_put_task(struct iscsi_task *task);
 extern void __iscsi_get_task(struct iscsi_task *task);
 extern void iscsi_complete_scsi_task(struct iscsi_task *task,
 				     uint32_t exp_cmdsn, uint32_t max_cmdsn);

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index ae5196aae1a5..b81d969ddc67 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -341,8 +341,7 @@ extern int iscsi_eh_abort(struct scsi_cmnd *sc);
 extern int iscsi_eh_recover_target(struct scsi_cmnd *sc);
 extern int iscsi_eh_session_reset(struct scsi_cmnd *sc);
 extern int iscsi_eh_device_reset(struct scsi_cmnd *sc);
-extern int iscsi_queuecommand(struct scsi_cmnd *sc,
-			      void (*done)(struct scsi_cmnd *));
+extern int iscsi_queuecommand(struct Scsi_Host *h, struct scsi_cmnd *sc);
 
 /*
  * iSCSI host helpers.

commit 309ce156aa27f29338438011d292a8d6496623d3
Author: Jayamohan Kallickal <jayamohank@serverengines.com>
Date:   Sat Feb 20 08:02:10 2010 +0530

    [SCSI] libiscsi: Make iscsi_eh_target_reset start with session reset
    
    The iscsi_eh_target_reset has been modified to attempt
    target reset only. If it fails, then iscsi_eh_session_reset
    will be called.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: Jayamohan Kallickal <jayamohank@serverengines.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index ff92b46f5153..ae5196aae1a5 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -338,7 +338,8 @@ struct iscsi_host {
 extern int iscsi_change_queue_depth(struct scsi_device *sdev, int depth,
 				    int reason);
 extern int iscsi_eh_abort(struct scsi_cmnd *sc);
-extern int iscsi_eh_target_reset(struct scsi_cmnd *sc);
+extern int iscsi_eh_recover_target(struct scsi_cmnd *sc);
+extern int iscsi_eh_session_reset(struct scsi_cmnd *sc);
 extern int iscsi_eh_device_reset(struct scsi_cmnd *sc);
 extern int iscsi_queuecommand(struct scsi_cmnd *sc,
 			      void (*done)(struct scsi_cmnd *));

commit 45465487897a1c6d508b14b904dc5777f7ec7e04
Author: Stefani Seibold <stefani@seibold.net>
Date:   Mon Dec 21 14:37:26 2009 -0800

    kfifo: move struct kfifo in place
    
    This is a new generic kernel FIFO implementation.
    
    The current kernel fifo API is not very widely used, because it has to
    many constrains.  Only 17 files in the current 2.6.31-rc5 used it.
    FIFO's are like list's a very basic thing and a kfifo API which handles
    the most use case would save a lot of development time and memory
    resources.
    
    I think this are the reasons why kfifo is not in use:
    
     - The API is to simple, important functions are missing
     - A fifo can be only allocated dynamically
     - There is a requirement of a spinlock whether you need it or not
     - There is no support for data records inside a fifo
    
    So I decided to extend the kfifo in a more generic way without blowing up
    the API to much.  The new API has the following benefits:
    
     - Generic usage: For kernel internal use and/or device driver.
     - Provide an API for the most use case.
     - Slim API: The whole API provides 25 functions.
     - Linux style habit.
     - DECLARE_KFIFO, DEFINE_KFIFO and INIT_KFIFO Macros
     - Direct copy_to_user from the fifo and copy_from_user into the fifo.
     - The kfifo itself is an in place member of the using data structure, this save an
       indirection access and does not waste the kernel allocator.
     - Lockless access: if only one reader and one writer is active on the fifo,
       which is the common use case, no additional locking is necessary.
     - Remove spinlock - give the user the freedom of choice what kind of locking to use if
       one is required.
     - Ability to handle records. Three type of records are supported:
       - Variable length records between 0-255 bytes, with a record size
         field of 1 bytes.
       - Variable length records between 0-65535 bytes, with a record size
         field of 2 bytes.
       - Fixed size records, which no record size field.
     - Preserve memory resource.
     - Performance!
     - Easy to use!
    
    This patch:
    
    Since most users want to have the kfifo as part of another object,
    reorganize the code to allow including struct kfifo in another data
    structure.  This requires changing the kfifo_alloc and kfifo_init
    prototypes so that we pass an existing kfifo pointer into them.  This
    patch changes the implementation and all existing users.
    
    [akpm@linux-foundation.org: fix warning]
    Signed-off-by: Stefani Seibold <stefani@seibold.net>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Acked-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 7394e3bc8f4b..ff92b46f5153 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -28,6 +28,7 @@
 #include <linux/mutex.h>
 #include <linux/timer.h>
 #include <linux/workqueue.h>
+#include <linux/kfifo.h>
 #include <scsi/iscsi_proto.h>
 #include <scsi/iscsi_if.h>
 #include <scsi/scsi_transport_iscsi.h>
@@ -231,7 +232,7 @@ struct iscsi_conn {
 };
 
 struct iscsi_pool {
-	struct kfifo		*queue;		/* FIFO Queue */
+	struct kfifo		queue;		/* FIFO Queue */
 	void			**pool;		/* Pool of elements */
 	int			max;		/* Max number of elements */
 };

commit 3fe5ae8b4c4d3a82c755074878da7ddb9dde381e
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed Nov 11 16:34:33 2009 -0600

    [SCSI] libiscsi: add warm target reset tmf support
    
    This implements warm target reset tmf support for
    the scsi-ml target reset callback. Previously we would
    just drop the session in that callback. This patch will
    now try a target reset and if that fails drop the session.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 2db2bc26b1e9..7394e3bc8f4b 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -267,6 +267,7 @@ struct iscsi_session {
 	/* configuration */
 	int			abort_timeout;
 	int			lu_reset_timeout;
+	int			tgt_reset_timeout;
 	int			initial_r2t_en;
 	unsigned		max_r2t;
 	int			imm_data_en;

commit e881a172dac4d9ea3b2a1540041d872963c269bd
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Oct 15 17:46:39 2009 -0700

    [SCSI] modify change_queue_depth to take in reason why it is being called
    
    This patch modifies scsi_host_template->change_queue_depth so that
    it takes an argument indicating why it is being called. This will be
    used so that if a LLD needs to do some extra processing when
    handling queue fulls or later ramp ups, it can do so.
    
    This is a simple port of the drivers setting a change_queue_depth
    callback. In the patch I just have these LLDs adjust the queue depth
    if the user was requesting it.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    
    [Vasu.Dev: v2
            Also converted pmcraid_change_queue_depth and then verified
    all modules compile  using "make allmodconfig" for any new build
    warnings on X86_64.
    
            Updated original description after combing two original
    patches from Mike to make this patch git bisectable.]
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    [jejb: fixed up 53c700]
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index a72edd4eceec..2db2bc26b1e9 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -333,7 +333,8 @@ struct iscsi_host {
 /*
  * scsi host template
  */
-extern int iscsi_change_queue_depth(struct scsi_device *sdev, int depth);
+extern int iscsi_change_queue_depth(struct scsi_device *sdev, int depth,
+				    int reason);
 extern int iscsi_eh_abort(struct scsi_cmnd *sc);
 extern int iscsi_eh_target_reset(struct scsi_cmnd *sc);
 extern int iscsi_eh_device_reset(struct scsi_cmnd *sc);

commit b8b9e1b8128d8854cf55740f9ceba3010143520d
Author: Jayamohan Kallickal <jayamohank@serverengines.com>
Date:   Tue Sep 22 08:21:22 2009 +0530

    [SCSI] libiscsi: iscsi_session_setup to allow for private space
    
    This patch contains changes that allow iscsi_session_setup
    to allocate private space for LLD's
    
    Signed-off-by: Jayamohan Kallickal <jayamohank@serverengines.com>
    Acked-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 887e57e3e223..a72edd4eceec 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -303,6 +303,7 @@ struct iscsi_session {
 	int			cmds_max;	/* size of cmds array */
 	struct iscsi_task	**cmds;		/* Original Cmds arr */
 	struct iscsi_pool	cmdpool;	/* PDU's pool */
+	void			*dd_data;	/* LLD private data */
 };
 
 enum {
@@ -363,7 +364,7 @@ extern int iscsi_target_alloc(struct scsi_target *starget);
  */
 extern struct iscsi_cls_session *
 iscsi_session_setup(struct iscsi_transport *, struct Scsi_Host *shost,
-		    uint16_t, int, uint32_t, unsigned int);
+		    uint16_t, int, int, uint32_t, unsigned int);
 extern void iscsi_session_teardown(struct iscsi_cls_session *);
 extern void iscsi_session_recovery_timedout(struct iscsi_cls_session *);
 extern int iscsi_set_param(struct iscsi_cls_conn *cls_conn,

commit 661134ad3765348ecd6150a92e736bf28ba40f80
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Sat Sep 5 07:35:33 2009 +0530

    [SCSI] libiscsi, bnx2i: make bound ep check common
    
    bnx2i currently has a check for if a ep is properly bound, so if
    iscsi_queuecommand/xmit_task is called while there is no ep
    we will not queue IO.
    
    be2iscsi sends IO from queuecommand/xmit_task like how bnx2i does
    and needs a similar test. This patch has us just use the suspend_bit
    test for this.
    
    When ep_poll has succeeed iscsid will call conn_bind, the LLD will
    then call iscsi_conn_bind which will clear the suspend bit.
    When ep_disconnect is called (or if there is a conn error) we set
    the suspend bit. For the ep_disconnect case I am adding a helper
    in this patch that will take the session lock to make sure
    iscsi_queuecommand/xmit_task is not running and it will set
    the suspend bit.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: Jayamohan Kallickal <jayamohank@serverengines.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 439c8b75cb69..887e57e3e223 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -390,6 +390,7 @@ extern void iscsi_session_failure(struct iscsi_session *session,
 extern int iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
 				enum iscsi_param param, char *buf);
 extern void iscsi_suspend_tx(struct iscsi_conn *conn);
+extern void iscsi_suspend_queue(struct iscsi_conn *conn);
 extern void iscsi_conn_queue_work(struct iscsi_conn *conn);
 
 #define iscsi_conn_printk(prefix, _c, fmt, a...) \

commit 4c0ba5d2593b5156327263f3ef6d7399dc0717b8
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Sat Sep 5 07:34:23 2009 +0530

    [SCSI] libiscsi: add completion function for drivers that do not need pdu processing
    
    beiscsi does not need the iscsi scsi cmd processing. It does not
    even get this info on the completion path. This adds a function
    to just update the sequencing numbers and complete a task.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: Jayamohan Kallickal <jayamohank@serverengines.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 61afeb59a836..439c8b75cb69 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -415,6 +415,8 @@ extern struct iscsi_task *iscsi_itt_to_task(struct iscsi_conn *, itt_t);
 extern void iscsi_requeue_task(struct iscsi_task *task);
 extern void iscsi_put_task(struct iscsi_task *task);
 extern void __iscsi_get_task(struct iscsi_task *task);
+extern void iscsi_complete_scsi_task(struct iscsi_task *task,
+				     uint32_t exp_cmdsn, uint32_t max_cmdsn);
 
 /*
  * generic helpers

commit d355e57d58193b89283b0c8153649f0427b0bdad
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Mon Jun 15 22:11:08 2009 -0500

    libiscsi: don't run scsi eh if iscsi task is making progress
    
    If we are sending or receiving data for the task successfully do
    not run the scsi eh, because we know the task is making progress.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 196525cd402f..61afeb59a836 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -125,6 +125,10 @@ struct iscsi_task {
 	struct scsi_cmnd	*sc;		/* associated SCSI cmd*/
 	struct iscsi_conn	*conn;		/* used connection    */
 
+	/* data processing tracking */
+	unsigned long		last_xfer;
+	unsigned long		last_timeout;
+	bool			have_checked_conn;
 	/* state set/tested under session->lock */
 	int			state;
 	atomic_t		refcount;

commit b3cd5050bf8eb32ceecee129cac7c59e6f1668c4
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 13 17:57:49 2009 -0500

    [SCSI] libiscsi: add task aborted state
    
    If a task did not complete normally due to a TMF, libiscsi will
    now complete the task with the state ISCSI_TASK_ABRT_TMF. Drivers
    like bnx2i that need to free resources if a command did not complete normally
    can then check the task state. If a driver does not need to send
    a special command if we have dropped the session then they can check
    for ISCSI_TASK_ABRT_SESS_RECOV.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index facae71183a5..196525cd402f 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -86,6 +86,8 @@ enum {
 	ISCSI_TASK_COMPLETED,
 	ISCSI_TASK_PENDING,
 	ISCSI_TASK_RUNNING,
+	ISCSI_TASK_ABRT_TMF,		/* aborted due to TMF */
+	ISCSI_TASK_ABRT_SESS_RECOV,	/* aborted due to session recovery */
 };
 
 struct iscsi_r2t_info {

commit 3bbaaad95fd38dedb7c66a601f14825b4e0c5a59
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 13 17:57:46 2009 -0500

    [SCSI] libiscsi: handle cleanup task races
    
    bnx2i needs to send a hardware specific cleanup command if
    a command has not completed normally (iscsi/scsi response from
    target), and the session is still ok (this is the case when we
    send a TMF to stop the command).
    
    At this time it will need to drop the session lock. The problem
    with the current code is that fail_all_commands assumes we
    will hold the lock the entire time, so it uses list_for_each_entry_safe.
    If while bnx2i drops the session lock multiple cmds complete then
    list_for_each_entry_safe will not handle this correctly.
    
    This patch removes the running lists and just has us loop over
    the cmds array (in later patches we will then replace that
    array with a block tag map at the session level). It also fixes
    up the completion path so that if the TMF code and the normal recv
    path were completing the same command then they both do not try
    to do release the refcount taken when the task is queued.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 88d33a46efa5..facae71183a5 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -82,6 +82,7 @@ enum {
 
 
 enum {
+	ISCSI_TASK_FREE,
 	ISCSI_TASK_COMPLETED,
 	ISCSI_TASK_PENDING,
 	ISCSI_TASK_RUNNING,
@@ -181,9 +182,7 @@ struct iscsi_conn {
 
 	/* xmit */
 	struct list_head	mgmtqueue;	/* mgmt (control) xmit queue */
-	struct list_head	mgmt_run_list;	/* list of control tasks */
-	struct list_head	xmitqueue;	/* data-path cmd queue */
-	struct list_head	run_list;	/* list of cmds in progress */
+	struct list_head	cmdqueue;	/* data-path cmd queue */
 	struct list_head	requeue;	/* tasks needing another run */
 	struct work_struct	xmitwork;	/* per-conn. xmit workqueue */
 	unsigned long		suspend_tx;	/* suspend Tx */

commit 8f9256cea10ca43ac80f66e176643eb41db34244
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 13 17:57:41 2009 -0500

    [SCSI] libiscsi: export iscsi_itt_to_task for bnx2i
    
    bnx2i needs to be able to look up mgmt task like login and nop, because
    it does some processing of them on the completion path. This exports
    iscsi_itt_to_task so it can look up the task.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 0289f5745fb9..88d33a46efa5 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -406,6 +406,7 @@ extern int __iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,
 				char *, int);
 extern int iscsi_verify_itt(struct iscsi_conn *, itt_t);
 extern struct iscsi_task *iscsi_itt_to_ctask(struct iscsi_conn *, itt_t);
+extern struct iscsi_task *iscsi_itt_to_task(struct iscsi_conn *, itt_t);
 extern void iscsi_requeue_task(struct iscsi_task *task);
 extern void iscsi_put_task(struct iscsi_task *task);
 extern void __iscsi_get_task(struct iscsi_task *task);

commit 6b5d6c443a9b4fd71b633cef66b5db4de8a85787
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Tue Apr 21 15:32:32 2009 -0500

    [SCSI] cxgb3i, iser, iscsi_tcp: set target can queue
    
    Set target can queue limit to the number of preallocated
    session tasks we have.
    
    This along with the cxgb3i can_queue patch will fix a throughput
    problem where it could only queue one LU worth of data at a time.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 7ffaed2f94dd..0289f5745fb9 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -36,6 +36,7 @@ struct scsi_transport_template;
 struct scsi_host_template;
 struct scsi_device;
 struct Scsi_Host;
+struct scsi_target;
 struct scsi_cmnd;
 struct socket;
 struct iscsi_transport;
@@ -350,6 +351,7 @@ extern struct Scsi_Host *iscsi_host_alloc(struct scsi_host_template *sht,
 					  bool xmit_can_sleep);
 extern void iscsi_host_remove(struct Scsi_Host *shost);
 extern void iscsi_host_free(struct Scsi_Host *shost);
+extern int iscsi_target_alloc(struct scsi_target *starget);
 
 /*
  * session management

commit 40a06e755d8524cd0b24f795e8bdce5ad19fc41b
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Mar 5 14:46:05 2009 -0600

    [SCSI] libiscsi: pass session failure a session struct
    
    The api for conn and session failures is akward because
    one takes a conn from the lib and one takes a session
    from the class. This syncs up the interfaces to use
    structs from the lib.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 84eded91b945..7ffaed2f94dd 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -378,7 +378,7 @@ extern void iscsi_conn_stop(struct iscsi_cls_conn *, int);
 extern int iscsi_conn_bind(struct iscsi_cls_session *, struct iscsi_cls_conn *,
 			   int);
 extern void iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err);
-extern void iscsi_session_failure(struct iscsi_cls_session *cls_session,
+extern void iscsi_session_failure(struct iscsi_session *session,
 				  enum iscsi_err err);
 extern int iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
 				enum iscsi_param param, char *buf);

commit 4d1083509a69a36cc1394f188b7b8956e5526a16
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Mar 5 14:46:04 2009 -0600

    [SCSI] iscsi lib: remove qdepth param from iscsi host allocation
    
    The qdepth setting was useful when we needed libiscsi to verify
    the setting. Now we just need to make sure if older tools
    passed in zero then we need to set some default.
    
    So this patch just has us use the sht->cmd_per_lun or if
    for LLD does a host per session then we can set it on per
    host basis.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index b0b8a6992497..84eded91b945 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -346,7 +346,7 @@ extern int iscsi_host_get_param(struct Scsi_Host *shost,
 				enum iscsi_host_param param, char *buf);
 extern int iscsi_host_add(struct Scsi_Host *shost, struct device *pdev);
 extern struct Scsi_Host *iscsi_host_alloc(struct scsi_host_template *sht,
-					  int dd_data_size, uint16_t qdepth,
+					  int dd_data_size,
 					  bool xmit_can_sleep);
 extern void iscsi_host_remove(struct Scsi_Host *shost);
 extern void iscsi_host_free(struct Scsi_Host *shost);

commit 32ae763e3fce4192cd008956a340353a2e5c3192
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Mar 5 14:46:03 2009 -0600

    [SCSI] iscsi lib: have lib create work queue for transmitting IO
    
    We were using the shost work queue which ended up being
    a little akward since all iscsi hosts need a thread for
    scanning, but only drivers hooked into libiscsi need
    a workqueue for transmitting. So this patch moves the
    xmit workqueue to the lib.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 898de4a73727..b0b8a6992497 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -318,6 +318,9 @@ struct iscsi_host {
 	spinlock_t		lock;
 	int			num_sessions;
 	int			state;
+
+	struct workqueue_struct	*workq;
+	char			workq_name[20];
 };
 
 /*
@@ -343,7 +346,8 @@ extern int iscsi_host_get_param(struct Scsi_Host *shost,
 				enum iscsi_host_param param, char *buf);
 extern int iscsi_host_add(struct Scsi_Host *shost, struct device *pdev);
 extern struct Scsi_Host *iscsi_host_alloc(struct scsi_host_template *sht,
-					  int dd_data_size, uint16_t qdepth);
+					  int dd_data_size, uint16_t qdepth,
+					  bool xmit_can_sleep);
 extern void iscsi_host_remove(struct Scsi_Host *shost);
 extern void iscsi_host_free(struct Scsi_Host *shost);
 
@@ -379,6 +383,7 @@ extern void iscsi_session_failure(struct iscsi_cls_session *cls_session,
 extern int iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
 				enum iscsi_param param, char *buf);
 extern void iscsi_suspend_tx(struct iscsi_conn *conn);
+extern void iscsi_conn_queue_work(struct iscsi_conn *conn);
 
 #define iscsi_conn_printk(prefix, _c, fmt, a...) \
 	iscsi_cls_conn_printk(prefix, ((struct iscsi_conn *)_c)->cls_conn, \

commit e28f3d5b51ed07d822f135cd941b01e2d485270e
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Mar 5 14:46:01 2009 -0600

    [SCSI] libiscsi: don't cap queue depth in iscsi modules
    
    There is no need to cap the queue depth in the modules. We set
    this in userspace and can do that there. For performance testing
    with ram based targets, this is helpful since we can have very
    high queue depths.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 67542aa3aedc..898de4a73727 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -48,8 +48,7 @@ struct device;
 #define ISCSI_DEF_XMIT_CMDS_MAX	128	/* must be power of 2 */
 #define ISCSI_MGMT_CMDS_MAX	15
 
-#define ISCSI_DEF_CMD_PER_LUN		32
-#define ISCSI_MAX_CMD_PER_LUN		128
+#define ISCSI_DEF_CMD_PER_LUN	32
 
 /* Task Mgmt states */
 enum {

commit 1b2c7af877f427a2b25583c9033616c9ebd30aed
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Mar 5 14:45:58 2009 -0600

    [SCSI] libiscsi: replace scsi_debug logging with session/conn logging
    
    This makes the logging a compile time option and replaces
    the scsi_debug macro with session and connection ones
    that print out a driver model id prefix.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 7360e1916e75..67542aa3aedc 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -45,13 +45,6 @@ struct iscsi_session;
 struct iscsi_nopin;
 struct device;
 
-/* #define DEBUG_SCSI */
-#ifdef DEBUG_SCSI
-#define debug_scsi(fmt...) printk(KERN_INFO "iscsi: " fmt)
-#else
-#define debug_scsi(fmt...)
-#endif
-
 #define ISCSI_DEF_XMIT_CMDS_MAX	128	/* must be power of 2 */
 #define ISCSI_MGMT_CMDS_MAX	15
 

commit 262ef63627977acb7d8dd38c4f0f290bf49fbbfd
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Tue Dec 2 00:32:13 2008 -0600

    [SCSI] libiscsi: allow drivers to modify the itt sent to the target
    
    bnx2i and cxgb3i need to encode LLD info in the itt so that
    the firmware/hardware can process the pdu. This patch allows
    the LLDs to encode info in the task->hdr->itt that they
    setup in the alloc_pdu callout (any resources that are allocated
    can be freed with the pdu in the cleanup_task callout). If
    the LLD encodes info in the itt they should implement a
    parse_pdu_itt callout. If parse_pdu_itt is not implemented
    libiscsi will do the right thing for the LLD.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 51500573c0b8..7360e1916e75 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -30,6 +30,7 @@
 #include <linux/workqueue.h>
 #include <scsi/iscsi_proto.h>
 #include <scsi/iscsi_if.h>
+#include <scsi/scsi_transport_iscsi.h>
 
 struct scsi_transport_template;
 struct scsi_host_template;
@@ -70,12 +71,12 @@ enum {
 /* Connection suspend "bit" */
 #define ISCSI_SUSPEND_BIT		1
 
-#define ISCSI_ITT_MASK			(0x1fff)
+#define ISCSI_ITT_MASK			0x1fff
 #define ISCSI_TOTAL_CMDS_MAX		4096
 /* this must be a power of two greater than ISCSI_MGMT_CMDS_MAX */
 #define ISCSI_TOTAL_CMDS_MIN		16
 #define ISCSI_AGE_SHIFT			28
-#define ISCSI_AGE_MASK			(0xf << ISCSI_AGE_SHIFT)
+#define ISCSI_AGE_MASK			0xf
 
 #define ISCSI_ADDRESS_BUF_LEN		64
 

commit 577577da6d197ea3dcf3ee19c4f902fbd3a9390a
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Tue Dec 2 00:32:05 2008 -0600

    [SCSI] libiscsi: prepare libiscsi for new offload engines by modifying unsol data code
    
    cxgb3i offloads data transfers. It does not offload the entire scsi/iscsi
    procssing like qla4xxx and it does not offload the iscsi sequence
    processing like how bnx2i does. cxgb3i relies on iscsi_tcp for the
    seqeunce handling so this changes how we transfer unsolicitied data by
    adding a common r2t struct and helpers.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 61e53f14f7e1..51500573c0b8 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -93,24 +93,38 @@ enum {
 	ISCSI_TASK_RUNNING,
 };
 
+struct iscsi_r2t_info {
+	__be32			ttt;		/* copied from R2T */
+	__be32			exp_statsn;	/* copied from R2T */
+	uint32_t		data_length;	/* copied from R2T */
+	uint32_t		data_offset;	/* copied from R2T */
+	int			data_count;	/* DATA-Out payload progress */
+	int			datasn;
+	/* LLDs should set/update these values */
+	int			sent;		/* R2T sequence progress */
+};
+
 struct iscsi_task {
 	/*
 	 * Because LLDs allocate their hdr differently, this is a pointer
 	 * and length to that storage. It must be setup at session
 	 * creation time.
 	 */
-	struct iscsi_cmd	*hdr;
+	struct iscsi_hdr	*hdr;
 	unsigned short		hdr_max;
 	unsigned short		hdr_len;	/* accumulated size of hdr used */
+	/* copied values in case we need to send tmfs */
+	itt_t			hdr_itt;
+	__be32			cmdsn;
+	uint8_t			lun[8];
+
 	int			itt;		/* this ITT */
 
-	uint32_t		unsol_datasn;
 	unsigned		imm_count;	/* imm-data (bytes)   */
-	unsigned		unsol_count;	/* unsolicited (bytes)*/
 	/* offset in unsolicited stream (bytes); */
-	unsigned		unsol_offset;
-	unsigned		data_count;	/* remaining Data-Out */
+	struct iscsi_r2t_info	unsol_r2t;
 	char			*data;		/* mgmt payload */
+	unsigned		data_count;
 	struct scsi_cmnd	*sc;		/* associated SCSI cmd*/
 	struct iscsi_conn	*conn;		/* used connection    */
 
@@ -121,6 +135,11 @@ struct iscsi_task {
 	void			*dd_data;	/* driver/transport data */
 };
 
+static inline int iscsi_task_has_unsol_data(struct iscsi_task *task)
+{
+	return task->unsol_r2t.data_length > task->unsol_r2t.sent;
+}
+
 static inline void* iscsi_next_hdr(struct iscsi_task *task)
 {
 	return (void*)task->hdr + task->hdr_len;
@@ -376,8 +395,9 @@ extern void iscsi_suspend_tx(struct iscsi_conn *conn);
  * pdu and task processing
  */
 extern void iscsi_update_cmdsn(struct iscsi_session *, struct iscsi_nopin *);
-extern void iscsi_prep_unsolicit_data_pdu(struct iscsi_task *,
-					struct iscsi_data *hdr);
+extern void iscsi_prep_data_out_pdu(struct iscsi_task *task,
+				    struct iscsi_r2t_info *r2t,
+				    struct iscsi_data *hdr);
 extern int iscsi_conn_send_pdu(struct iscsi_cls_conn *, struct iscsi_hdr *,
 				char *, uint32_t);
 extern int iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,

commit 8e12452549ba2dfa17db97bc495172fac221a7ab
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed Sep 24 11:46:12 2008 -0500

    [SCSI] libiscsi: rename host reset to target reset
    
    I had this in my patchset to add target reset support, but
    it got dropped due to patching conflicts. This initial patch
    just renames the function and users. We are actually just
    dropping the session, and so this does not have anything to do
    with the host exactly. It does for software iscsi because
    we allocate a host per session, but for cxgb3i this makes no
    sense.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 7d8cd159f592..61e53f14f7e1 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -313,7 +313,7 @@ struct iscsi_host {
  */
 extern int iscsi_change_queue_depth(struct scsi_device *sdev, int depth);
 extern int iscsi_eh_abort(struct scsi_cmnd *sc);
-extern int iscsi_eh_host_reset(struct scsi_cmnd *sc);
+extern int iscsi_eh_target_reset(struct scsi_cmnd *sc);
 extern int iscsi_eh_device_reset(struct scsi_cmnd *sc);
 extern int iscsi_queuecommand(struct scsi_cmnd *sc,
 			      void (*done)(struct scsi_cmnd *));

commit e5bd7b54e93ef7151469a12b8c28d863b9f8a088
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed Sep 24 11:46:10 2008 -0500

    [SCSI] libiscsi: Support drivers initiating session removal
    
    If the driver knows when hardware is removed like with cxgb3i,
    bnx2i, qla4xxx and iser then we will want to remove the sessions/devices
    that are bound to that device before removing the host.
    
    cxgb3i and in the future bnx2i will remove the host and that will
    remove all the sessions on the hba. iser can call iscsi_kill_session
    when it gets an event that indicates that a hca is removed.
    And when qla4xxx is hooked in to the lib (it is only hooked into
    the class right now) it can call iscsi remove host like the
    partial offload card drivers.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 5e75bb7f311c..7d8cd159f592 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -287,6 +287,11 @@ struct iscsi_session {
 	struct iscsi_pool	cmdpool;	/* PDU's pool */
 };
 
+enum {
+	ISCSI_HOST_SETUP,
+	ISCSI_HOST_REMOVED,
+};
+
 struct iscsi_host {
 	char			*initiatorname;
 	/* hw address or netdev iscsi connection is bound to */
@@ -295,6 +300,12 @@ struct iscsi_host {
 	/* local address */
 	int			local_port;
 	char			local_address[ISCSI_ADDRESS_BUF_LEN];
+
+	wait_queue_head_t	session_removal_wq;
+	/* protects sessions and state */
+	spinlock_t		lock;
+	int			num_sessions;
+	int			state;
 };
 
 /*
@@ -351,6 +362,8 @@ extern void iscsi_conn_stop(struct iscsi_cls_conn *, int);
 extern int iscsi_conn_bind(struct iscsi_cls_session *, struct iscsi_cls_conn *,
 			   int);
 extern void iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err);
+extern void iscsi_session_failure(struct iscsi_cls_session *cls_session,
+				  enum iscsi_err err);
 extern int iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
 				enum iscsi_param param, char *buf);
 extern void iscsi_suspend_tx(struct iscsi_conn *conn);

commit 913e5bf435617aa529919a4f7567f849f9f35f9f
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 21 15:54:18 2008 -0500

    [SCSI] libiscsi, iser, tcp: remove recv_lock
    
    The recv lock was defined so the iscsi layer could block
    the recv path from processing IO during recovery. It
    turns out iser just set a lock to that pointer which was pointless.
    
    We now disconnect the transport connection before doing recovery
    so we do not need the recv lock. For iscsi_tcp we still stop
    the recv path incase older tools are being used.
    
    This patch also has iscsi_itt_to_ctask user grab the session lock
    and has the caller access the task with the lock or get a ref
    to it in case the target is broken and sends a tmf success response
    then sends data or a response for the command that was supposed to
    be affected bty the tmf.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 5bf0187e7520..5e75bb7f311c 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -138,11 +138,6 @@ struct iscsi_conn {
 	struct iscsi_cls_conn	*cls_conn;	/* ptr to class connection */
 	void			*dd_data;	/* iscsi_transport data */
 	struct iscsi_session	*session;	/* parent session */
-	/*
-	 * LLDs should set this lock. It protects the transport recv
-	 * code
-	 */
-	rwlock_t		*recv_lock;
 	/*
 	 * conn_stop() flag: stop to recover, stop to terminate
 	 */
@@ -374,10 +369,13 @@ extern int iscsi_conn_send_pdu(struct iscsi_cls_conn *, struct iscsi_hdr *,
 				char *, uint32_t);
 extern int iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,
 			      char *, int);
+extern int __iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,
+				char *, int);
 extern int iscsi_verify_itt(struct iscsi_conn *, itt_t);
 extern struct iscsi_task *iscsi_itt_to_ctask(struct iscsi_conn *, itt_t);
 extern void iscsi_requeue_task(struct iscsi_task *task);
 extern void iscsi_put_task(struct iscsi_task *task);
+extern void __iscsi_get_task(struct iscsi_task *task);
 
 /*
  * generic helpers

commit 3cf7b233ffc45d4fc381221f74d24f10e692c4ea
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 21 15:54:17 2008 -0500

    [SCSI] libiscsi: fix cmds_max setting
    
    Drivers expect that the cmds_max value they pass to the iscsi layer
    is the max scsi commands  + mgmt tasks. This patch implements that
    and fixes some checks for nr cmd limits.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 21cfb1d5483f..5bf0187e7520 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -52,9 +52,7 @@ struct device;
 #endif
 
 #define ISCSI_DEF_XMIT_CMDS_MAX	128	/* must be power of 2 */
-#define ISCSI_MGMT_CMDS_MAX	16	/* must be power of 2 */
-
-#define ISCSI_MGMT_ITT_OFFSET	0xa00
+#define ISCSI_MGMT_CMDS_MAX	15
 
 #define ISCSI_DEF_CMD_PER_LUN		32
 #define ISCSI_MAX_CMD_PER_LUN		128
@@ -72,7 +70,10 @@ enum {
 /* Connection suspend "bit" */
 #define ISCSI_SUSPEND_BIT		1
 
-#define ISCSI_ITT_MASK			(0xfff)
+#define ISCSI_ITT_MASK			(0x1fff)
+#define ISCSI_TOTAL_CMDS_MAX		4096
+/* this must be a power of two greater than ISCSI_MGMT_CMDS_MAX */
+#define ISCSI_TOTAL_CMDS_MIN		16
 #define ISCSI_AGE_SHIFT			28
 #define ISCSI_AGE_MASK			(0xf << ISCSI_AGE_SHIFT)
 

commit 88dfd340b9dece8fcaa1a2d4c782338926c017f7
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 21 15:54:16 2008 -0500

    [SCSI] iscsi class: Add session initiatorname and ifacename sysfs attrs.
    
    This adds two new attrs used for creating initiator ports and
    binding sessions to hardware.
    
    The session level initiatorname:
    
    Since bnx2i does a scsi_host per host device, we need to add the
    iface initiator port settings on the session, so we can create
    multiple initiator ports (each with different inames) per device/scsi_host.
    
    The current iname reflects that qla4xxx can have one iname per hba, and we are
    allocating a host per session for software. The iname on the host will
    remain so we can export and set the hba level qla4xxx setting.
    
    The ifacename attr:
    
    To bind a session to a some peice of hardware in userspace we maintain
    some mappings, but during boot or iscsid restart (iscsid contains the user
    space part of the driver) we need to be able to figure out which of those
    host mappings abstractions maps to certain sessions. This patch adds
    a ifacename attr, which userspace can set to id the host side of the
    endpoint across pivot_roots and iscsid restarts.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 13c92d7ba969..21cfb1d5483f 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -270,6 +270,8 @@ struct iscsi_session {
 	char			*password;
 	char			*password_in;
 	char			*targetname;
+	char			*ifacename;
+	char			*initiatorname;
 	/* control data */
 	struct iscsi_transport	*tt;
 	struct Scsi_Host	*host;

commit 7970634b81a6e3561954517bca42615542c4535b
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 21 15:54:12 2008 -0500

    [SCSI] iscsi class: user device_for_each_child instead of duplicating session list
    
    Currently we duplicate the list of sessions, because we were using the
    test for if a session was on the host list to indicate if the session
    was bound or unbound. We can instead use the target_id and fix up
    the class so that drivers like bnx2i do not have to manage the target id
    space.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 176353c117b6..13c92d7ba969 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -331,7 +331,7 @@ extern void iscsi_host_free(struct Scsi_Host *shost);
  */
 extern struct iscsi_cls_session *
 iscsi_session_setup(struct iscsi_transport *, struct Scsi_Host *shost,
-		    uint16_t, int, uint32_t);
+		    uint16_t, int, uint32_t, unsigned int);
 extern void iscsi_session_teardown(struct iscsi_cls_session *);
 extern void iscsi_session_recovery_timedout(struct iscsi_cls_session *);
 extern int iscsi_set_param(struct iscsi_cls_conn *cls_conn,

commit 9c19a7d0387124a508d2cdb38ebf8cd484631ad0
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 21 15:54:09 2008 -0500

    [SCSI] libiscsi: rename iscsi_cmd_task to iscsi_task
    
    This is the second part of the iscsi task merging, and
    all it does it rename iscsi_cmd_task to iscsi_task and
    mtask/ctask to just task.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index d1c36759b350..176353c117b6 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -92,7 +92,7 @@ enum {
 	ISCSI_TASK_RUNNING,
 };
 
-struct iscsi_cmd_task {
+struct iscsi_task {
 	/*
 	 * Because LLDs allocate their hdr differently, this is a pointer
 	 * and length to that storage. It must be setup at session
@@ -120,9 +120,9 @@ struct iscsi_cmd_task {
 	void			*dd_data;	/* driver/transport data */
 };
 
-static inline void* iscsi_next_hdr(struct iscsi_cmd_task *ctask)
+static inline void* iscsi_next_hdr(struct iscsi_task *task)
 {
-	return (void*)ctask->hdr + ctask->hdr_len;
+	return (void*)task->hdr + task->hdr_len;
 }
 
 /* Connection's states */
@@ -151,7 +151,7 @@ struct iscsi_conn {
 	unsigned long		last_ping;
 	int			ping_timeout;
 	int			recv_timeout;
-	struct iscsi_cmd_task 	*ping_ctask;
+	struct iscsi_task 	*ping_task;
 
 	/* iSCSI connection-wide sequencing */
 	uint32_t		exp_statsn;
@@ -167,8 +167,8 @@ struct iscsi_conn {
 	 * should always fit in this buffer
 	 */
 	char			*data;
-	struct iscsi_cmd_task 	*login_ctask;	/* mtask used for login/text */
-	struct iscsi_cmd_task	*ctask;		/* xmit task in progress */
+	struct iscsi_task 	*login_task;	/* mtask used for login/text */
+	struct iscsi_task	*task;		/* xmit task in progress */
 
 	/* xmit */
 	struct list_head	mgmtqueue;	/* mgmt (control) xmit queue */
@@ -285,7 +285,7 @@ struct iscsi_session {
 
 	int			scsi_cmds_max; 	/* max scsi commands */
 	int			cmds_max;	/* size of cmds array */
-	struct iscsi_cmd_task	**cmds;		/* Original Cmds arr */
+	struct iscsi_task	**cmds;		/* Original Cmds arr */
 	struct iscsi_pool	cmdpool;	/* PDU's pool */
 };
 
@@ -365,16 +365,16 @@ extern void iscsi_suspend_tx(struct iscsi_conn *conn);
  * pdu and task processing
  */
 extern void iscsi_update_cmdsn(struct iscsi_session *, struct iscsi_nopin *);
-extern void iscsi_prep_unsolicit_data_pdu(struct iscsi_cmd_task *,
+extern void iscsi_prep_unsolicit_data_pdu(struct iscsi_task *,
 					struct iscsi_data *hdr);
 extern int iscsi_conn_send_pdu(struct iscsi_cls_conn *, struct iscsi_hdr *,
 				char *, uint32_t);
 extern int iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,
 			      char *, int);
 extern int iscsi_verify_itt(struct iscsi_conn *, itt_t);
-extern struct iscsi_cmd_task *iscsi_itt_to_ctask(struct iscsi_conn *, itt_t);
-extern void iscsi_requeue_ctask(struct iscsi_cmd_task *ctask);
-extern void iscsi_put_ctask(struct iscsi_cmd_task *ctask);
+extern struct iscsi_task *iscsi_itt_to_ctask(struct iscsi_conn *, itt_t);
+extern void iscsi_requeue_task(struct iscsi_task *task);
+extern void iscsi_put_task(struct iscsi_task *task);
 
 /*
  * generic helpers

commit 3e5c28ad0391389959ccae81c938c7533efb3490
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 21 15:54:06 2008 -0500

    [SCSI] libiscsi: merge iscsi_mgmt_task and iscsi_cmd_task
    
    There is no need to have the mgmt and cmd tasks separate
    structs. It used to save a lot of memory when we overprealocated
    memory for tasks, but the next patches will set up the
    driver so in the future they can use a mempool or some other
    common scsi command allocator and common tagging.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 9be6a70faff5..d1c36759b350 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -85,18 +85,6 @@ enum {
 	ISCSI_DIGEST_SIZE = sizeof(__u32),
 };
 
-struct iscsi_mgmt_task {
-	/*
-	 * Becuae LLDs allocate their hdr differently, this is a pointer to
-	 * that storage. It must be setup at session creation time.
-	 */
-	struct iscsi_hdr	*hdr;
-	char			*data;		/* mgmt payload */
-	unsigned		data_count;	/* counts data to be sent */
-	uint32_t		itt;		/* this ITT */
-	void			*dd_data;	/* driver/transport data */
-	struct list_head	running;
-};
 
 enum {
 	ISCSI_TASK_COMPLETED,
@@ -121,6 +109,7 @@ struct iscsi_cmd_task {
 	/* offset in unsolicited stream (bytes); */
 	unsigned		unsol_offset;
 	unsigned		data_count;	/* remaining Data-Out */
+	char			*data;		/* mgmt payload */
 	struct scsi_cmnd	*sc;		/* associated SCSI cmd*/
 	struct iscsi_conn	*conn;		/* used connection    */
 
@@ -162,7 +151,7 @@ struct iscsi_conn {
 	unsigned long		last_ping;
 	int			ping_timeout;
 	int			recv_timeout;
-	struct iscsi_mgmt_task	*ping_mtask;
+	struct iscsi_cmd_task 	*ping_ctask;
 
 	/* iSCSI connection-wide sequencing */
 	uint32_t		exp_statsn;
@@ -178,9 +167,8 @@ struct iscsi_conn {
 	 * should always fit in this buffer
 	 */
 	char			*data;
-	struct iscsi_mgmt_task	*login_mtask;	/* mtask used for login/text */
-	struct iscsi_mgmt_task	*mtask;		/* xmit mtask in progress */
-	struct iscsi_cmd_task	*ctask;		/* xmit ctask in progress */
+	struct iscsi_cmd_task 	*login_ctask;	/* mtask used for login/text */
+	struct iscsi_cmd_task	*ctask;		/* xmit task in progress */
 
 	/* xmit */
 	struct list_head	mgmtqueue;	/* mgmt (control) xmit queue */
@@ -295,12 +283,10 @@ struct iscsi_session {
 	int			state;		/* session state           */
 	int			age;		/* counts session re-opens */
 
+	int			scsi_cmds_max; 	/* max scsi commands */
 	int			cmds_max;	/* size of cmds array */
 	struct iscsi_cmd_task	**cmds;		/* Original Cmds arr */
 	struct iscsi_pool	cmdpool;	/* PDU's pool */
-	int			mgmtpool_max;	/* size of mgmt array */
-	struct iscsi_mgmt_task	**mgmt_cmds;	/* Original mgmt arr */
-	struct iscsi_pool	mgmtpool;	/* Mgmt PDU's pool */
 };
 
 struct iscsi_host {
@@ -345,7 +331,7 @@ extern void iscsi_host_free(struct Scsi_Host *shost);
  */
 extern struct iscsi_cls_session *
 iscsi_session_setup(struct iscsi_transport *, struct Scsi_Host *shost,
-		    uint16_t, int, int, uint32_t);
+		    uint16_t, int, uint32_t);
 extern void iscsi_session_teardown(struct iscsi_cls_session *);
 extern void iscsi_session_recovery_timedout(struct iscsi_cls_session *);
 extern int iscsi_set_param(struct iscsi_cls_conn *cls_conn,
@@ -388,8 +374,7 @@ extern int iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,
 extern int iscsi_verify_itt(struct iscsi_conn *, itt_t);
 extern struct iscsi_cmd_task *iscsi_itt_to_ctask(struct iscsi_conn *, itt_t);
 extern void iscsi_requeue_ctask(struct iscsi_cmd_task *ctask);
-extern void iscsi_free_mgmt_task(struct iscsi_conn *conn,
-				 struct iscsi_mgmt_task *mtask);
+extern void iscsi_put_ctask(struct iscsi_cmd_task *ctask);
 
 /*
  * generic helpers

commit 0af967f5d4f2dd1e00618d34ac988037d37a6c3b
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 21 15:54:04 2008 -0500

    [SCSI] libiscsi, iscsi_tcp, iser: add session cmds array accessor
    
    Currently to get a ctask from the session cmd array, you have to
    know to use the itt modifier. To make this easier on LLDs and
    so in the future we can easilly kill the session array and use
    the host shared map instead, this patch adds a nice wrapper
    to strip the itt into a session->cmds index and return a ctask.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index f54aeb1e8ae3..9be6a70faff5 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -385,8 +385,8 @@ extern int iscsi_conn_send_pdu(struct iscsi_cls_conn *, struct iscsi_hdr *,
 				char *, uint32_t);
 extern int iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,
 			      char *, int);
-extern int iscsi_verify_itt(struct iscsi_conn *, struct iscsi_hdr *,
-			    uint32_t *);
+extern int iscsi_verify_itt(struct iscsi_conn *, itt_t);
+extern struct iscsi_cmd_task *iscsi_itt_to_ctask(struct iscsi_conn *, itt_t);
 extern void iscsi_requeue_ctask(struct iscsi_cmd_task *ctask);
 extern void iscsi_free_mgmt_task(struct iscsi_conn *conn,
 				 struct iscsi_mgmt_task *mtask);

commit 5af3e91d232b7e022f258202f72ebb79b8b0c706
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 21 15:54:02 2008 -0500

    [SCSI] iscsi: modify iscsi printk so it can take driver data pointers
    
    Some drivers want to be able to just pass in the driver data pointers
    to the iscsi objects. To enable this we need the iscsi printk macro
    to cast the object.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 4e1c14f20ddd..f54aeb1e8ae3 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -369,9 +369,11 @@ extern int iscsi_conn_bind(struct iscsi_cls_session *, struct iscsi_cls_conn *,
 extern void iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err);
 extern int iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
 				enum iscsi_param param, char *buf);
+extern void iscsi_suspend_tx(struct iscsi_conn *conn);
 
 #define iscsi_conn_printk(prefix, _c, fmt, a...) \
-	iscsi_cls_conn_printk(prefix, _c->cls_conn, fmt, ##a)
+	iscsi_cls_conn_printk(prefix, ((struct iscsi_conn *)_c)->cls_conn, \
+			      fmt, ##a)
 
 /*
  * pdu and task processing

commit 5d91e209fb21fb9cc765729d4c6a85a9fb6c9187
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 21 15:54:01 2008 -0500

    [SCSI] iscsi: remove session/conn_data_size from iscsi_transport
    
    This removes the session and conn data_size fields from the iscsi_transport.
    Just pass in the value like with host allocation. This patch also makes
    it so the LLD iscsi_conn data is allocated with the iscsi_cls_conn.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 9a26d715a953..4e1c14f20ddd 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -313,8 +313,6 @@ struct iscsi_host {
 	char			local_address[ISCSI_ADDRESS_BUF_LEN];
 };
 
-#define iscsi_host_priv(_shost) \
-	(shost_priv(_shost) + sizeof(struct iscsi_host))
 /*
  * scsi host template
  */
@@ -325,10 +323,12 @@ extern int iscsi_eh_device_reset(struct scsi_cmnd *sc);
 extern int iscsi_queuecommand(struct scsi_cmnd *sc,
 			      void (*done)(struct scsi_cmnd *));
 
-
 /*
  * iSCSI host helpers.
  */
+#define iscsi_host_priv(_shost) \
+	(shost_priv(_shost) + sizeof(struct iscsi_host))
+
 extern int iscsi_host_set_param(struct Scsi_Host *shost,
 				enum iscsi_host_param param, char *buf,
 				int buflen);
@@ -360,7 +360,7 @@ extern int iscsi_session_get_param(struct iscsi_cls_session *cls_session,
  * connection management
  */
 extern struct iscsi_cls_conn *iscsi_conn_setup(struct iscsi_cls_session *,
-					       uint32_t);
+					       int, uint32_t);
 extern void iscsi_conn_teardown(struct iscsi_cls_conn *);
 extern int iscsi_conn_start(struct iscsi_cls_conn *);
 extern void iscsi_conn_stop(struct iscsi_cls_conn *, int);

commit a4804cd6eb19318ae8d08ea967cfeaaf5c5b68a6
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 21 15:54:00 2008 -0500

    [SCSI] iscsi: add iscsi host helpers
    
    This finishes the host/session unbinding, by adding some helpers
    to add and remove hosts and the session they manage.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 8a6271c20935..9a26d715a953 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -32,6 +32,7 @@
 #include <scsi/iscsi_if.h>
 
 struct scsi_transport_template;
+struct scsi_host_template;
 struct scsi_device;
 struct Scsi_Host;
 struct scsi_cmnd;
@@ -41,6 +42,7 @@ struct iscsi_cls_session;
 struct iscsi_cls_conn;
 struct iscsi_session;
 struct iscsi_nopin;
+struct device;
 
 /* #define DEBUG_SCSI */
 #ifdef DEBUG_SCSI
@@ -311,6 +313,8 @@ struct iscsi_host {
 	char			local_address[ISCSI_ADDRESS_BUF_LEN];
 };
 
+#define iscsi_host_priv(_shost) \
+	(shost_priv(_shost) + sizeof(struct iscsi_host))
 /*
  * scsi host template
  */
@@ -330,8 +334,11 @@ extern int iscsi_host_set_param(struct Scsi_Host *shost,
 				int buflen);
 extern int iscsi_host_get_param(struct Scsi_Host *shost,
 				enum iscsi_host_param param, char *buf);
-extern void iscsi_host_setup(struct Scsi_Host *shost, uint16_t qdepth);
-extern void iscsi_host_teardown(struct Scsi_Host *shost);
+extern int iscsi_host_add(struct Scsi_Host *shost, struct device *pdev);
+extern struct Scsi_Host *iscsi_host_alloc(struct scsi_host_template *sht,
+					  int dd_data_size, uint16_t qdepth);
+extern void iscsi_host_remove(struct Scsi_Host *shost);
+extern void iscsi_host_free(struct Scsi_Host *shost);
 
 /*
  * session management

commit 756135215ec743be6fdce2bdebe8cdb9f8a231f6
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 21 15:53:59 2008 -0500

    [SCSI] iscsi: remove session and host binding in libiscsi
    
    bnx2i allocates a host per netdevice but will use libiscsi,
    so this unbinds the session from the host in that code.
    
    This will also be useful for the iser parent device dma settings
    fixes.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index f24cf0246739..8a6271c20935 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -209,9 +209,6 @@ struct iscsi_conn {
 	/* remote portal currently connected to */
 	int			portal_port;
 	char			portal_address[ISCSI_ADDRESS_BUF_LEN];
-	/* local address */
-	int			local_port;
-	char			local_address[ISCSI_ADDRESS_BUF_LEN];
 
 	/* MIB-statistics */
 	uint64_t		txdata_octets;
@@ -247,6 +244,7 @@ enum {
 };
 
 struct iscsi_session {
+	struct iscsi_cls_session *cls_session;
 	/*
 	 * Syncs up the scsi eh thread with the iscsi eh thread when sending
 	 * task management functions. This must be taken before the session
@@ -282,10 +280,6 @@ struct iscsi_session {
 	char			*password;
 	char			*password_in;
 	char			*targetname;
-	char			*initiatorname;
-	/* hw address or netdev iscsi connection is bound to */
-	char			*hwaddress;
-	char			*netdev;
 	/* control data */
 	struct iscsi_transport	*tt;
 	struct Scsi_Host	*host;
@@ -307,6 +301,16 @@ struct iscsi_session {
 	struct iscsi_pool	mgmtpool;	/* Mgmt PDU's pool */
 };
 
+struct iscsi_host {
+	char			*initiatorname;
+	/* hw address or netdev iscsi connection is bound to */
+	char			*hwaddress;
+	char			*netdev;
+	/* local address */
+	int			local_port;
+	char			local_address[ISCSI_ADDRESS_BUF_LEN];
+};
+
 /*
  * scsi host template
  */
@@ -326,27 +330,24 @@ extern int iscsi_host_set_param(struct Scsi_Host *shost,
 				int buflen);
 extern int iscsi_host_get_param(struct Scsi_Host *shost,
 				enum iscsi_host_param param, char *buf);
+extern void iscsi_host_setup(struct Scsi_Host *shost, uint16_t qdepth);
+extern void iscsi_host_teardown(struct Scsi_Host *shost);
 
 /*
  * session management
  */
 extern struct iscsi_cls_session *
-iscsi_session_setup(struct iscsi_transport *, struct scsi_transport_template *,
-		    uint16_t, uint16_t, int, int, uint32_t, uint32_t *);
+iscsi_session_setup(struct iscsi_transport *, struct Scsi_Host *shost,
+		    uint16_t, int, int, uint32_t);
 extern void iscsi_session_teardown(struct iscsi_cls_session *);
-extern struct iscsi_session *class_to_transport_session(struct iscsi_cls_session *);
 extern void iscsi_session_recovery_timedout(struct iscsi_cls_session *);
 extern int iscsi_set_param(struct iscsi_cls_conn *cls_conn,
 			   enum iscsi_param param, char *buf, int buflen);
 extern int iscsi_session_get_param(struct iscsi_cls_session *cls_session,
 				   enum iscsi_param param, char *buf);
 
-#define session_to_cls(_sess) \
-	hostdata_session(_sess->host->hostdata)
-
 #define iscsi_session_printk(prefix, _sess, fmt, a...)	\
-	iscsi_cls_session_printk(prefix,		\
-		(struct iscsi_cls_session *)session_to_cls(_sess), fmt, ##a)
+	iscsi_cls_session_printk(prefix, _sess->cls_session, fmt, ##a)
 
 /*
  * connection management

commit 40753caa364bfba60ebd5e2a8bdf366ef175d03c
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 21 15:53:56 2008 -0500

    [SCSI] iscsi class, iscsi_tcp/iser: add host arg to session creation
    
    iscsi offload (bnx2i and qla4xx) allocate a scsi host per hba,
    so the session creation path needs a shost/host_no argument.
    Software iscsi/iser will follow the same behabior as before
    where it allcoates a host per session, but in the future iser
    will probably look more like bnx2i where the host's parent is
    the hardware (rnic for iser and for bnx2i it is the nic), because
    it does not use a socket layer like how iscsi_tcp does.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index cd3ca63d4fb1..f24cf0246739 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -24,6 +24,7 @@
 #define LIBISCSI_H
 
 #include <linux/types.h>
+#include <linux/wait.h>
 #include <linux/mutex.h>
 #include <linux/timer.h>
 #include <linux/workqueue.h>

commit 87528227dfa8776d12779d073c217f0835fd6d20
Author: Eli Dorfman <dorfman.eli@gmail.com>
Date:   Tue Apr 29 13:46:52 2008 -0700

    IB/iser: Count FMR alignment violations per session
    
    Count FMR alignment violations per session as part of the iscsi
    statistics.
    
    Signed-off-by: Eli Dorfman <elid@voltaire.com>
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 7b90b63fb5c7..cd3ca63d4fb1 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -225,6 +225,7 @@ struct iscsi_conn {
 
 	/* custom statistics */
 	uint32_t		eh_abort_cnt;
+	uint32_t		fmr_unalign_cnt;
 };
 
 struct iscsi_pool {

commit 8b1d03434ee44b08c57f50403eaeab099facebf5
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Jan 31 13:36:53 2008 -0600

    [SCSI] libiscsi: fix session age rollover and remove cid encoding
    
    The session age mask is only 4 bits, but session->age is 32. When
    it gets larger then 15 and we try to or the bits some bits get
    dropped and the check for session age in iscsi_verify_itt is useless.
    
    The ISCSI_CID_MASK related bits are also useless since cid is always
    one.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 5784e4ff8edc..7b90b63fb5c7 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -70,8 +70,6 @@ enum {
 #define ISCSI_SUSPEND_BIT		1
 
 #define ISCSI_ITT_MASK			(0xfff)
-#define ISCSI_CID_SHIFT			12
-#define ISCSI_CID_MASK			(0xffff << ISCSI_CID_SHIFT)
 #define ISCSI_AGE_SHIFT			28
 #define ISCSI_AGE_MASK			(0xf << ISCSI_AGE_SHIFT)
 

commit 322d739da83bbff0309c202181f79c08d9534880
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Jan 31 13:36:52 2008 -0600

    [SCSI] iscsi: fix up iscsi printk prefix
    
    Some iscsi class messages have the dev_printk prefix and some libiscsi
    and iscsi_tcp messages have "iscsi" or the module name as a prefix which
    is normally pretty useless when trying to figure out which session
    or connection the message is attached to. This patch adds iscsi lib
    and class dev_printks so all messages have a common prefix that
    can be used to figure out which object printed it.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 278011fb3c2f..5784e4ff8edc 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -344,6 +344,10 @@ extern int iscsi_session_get_param(struct iscsi_cls_session *cls_session,
 #define session_to_cls(_sess) \
 	hostdata_session(_sess->host->hostdata)
 
+#define iscsi_session_printk(prefix, _sess, fmt, a...)	\
+	iscsi_cls_session_printk(prefix,		\
+		(struct iscsi_cls_session *)session_to_cls(_sess), fmt, ##a)
+
 /*
  * connection management
  */
@@ -358,6 +362,9 @@ extern void iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err);
 extern int iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
 				enum iscsi_param param, char *buf);
 
+#define iscsi_conn_printk(prefix, _c, fmt, a...) \
+	iscsi_cls_conn_printk(prefix, _c->cls_conn, fmt, ##a)
+
 /*
  * pdu and task processing
  */

commit 6eabafbe6616266e8de61980a7dac5ecc1ba1113
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Jan 31 13:36:43 2008 -0600

    [SCSI] iscsi class, libiscsi: add iscsi sysfs session state file
    
    This adds a iscsi session state file which exports the session
    state for both software and hardware iscsi. It also hooks libiscsi
    in.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 71eda24114e9..278011fb3c2f 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -135,6 +135,14 @@ static inline void* iscsi_next_hdr(struct iscsi_cmd_task *ctask)
 	return (void*)ctask->hdr + ctask->hdr_len;
 }
 
+/* Connection's states */
+enum {
+	ISCSI_CONN_INITIAL_STAGE,
+	ISCSI_CONN_STARTED,
+	ISCSI_CONN_STOPPED,
+	ISCSI_CONN_CLEANUP_WAIT,
+};
+
 struct iscsi_conn {
 	struct iscsi_cls_conn	*cls_conn;	/* ptr to class connection */
 	void			*dd_data;	/* iscsi_transport data */
@@ -227,6 +235,17 @@ struct iscsi_pool {
 	int			max;		/* Max number of elements */
 };
 
+/* Session's states */
+enum {
+	ISCSI_STATE_FREE = 1,
+	ISCSI_STATE_LOGGED_IN,
+	ISCSI_STATE_FAILED,
+	ISCSI_STATE_TERMINATE,
+	ISCSI_STATE_IN_RECOVERY,
+	ISCSI_STATE_RECOVERY_FAILED,
+	ISCSI_STATE_LOGGING_OUT,
+};
+
 struct iscsi_session {
 	/*
 	 * Syncs up the scsi eh thread with the iscsi eh thread when sending

commit f8d9d654fcc7dd87f5d0b222e233eaab15d650c4
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Jan 29 00:11:27 2008 +0200

    [SCSI] libiscsi: make __iscsi_complete_pdu() static
    
    __iscsi_complete_pdu() can now become static.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 889f51fabab9..71eda24114e9 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -349,8 +349,6 @@ extern int iscsi_conn_send_pdu(struct iscsi_cls_conn *, struct iscsi_hdr *,
 				char *, uint32_t);
 extern int iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,
 			      char *, int);
-extern int __iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,
-				char *, int);
 extern int iscsi_verify_itt(struct iscsi_conn *, struct iscsi_hdr *,
 			    uint32_t *);
 extern void iscsi_requeue_ctask(struct iscsi_cmd_task *ctask);

commit f6d5180c78780d63b0577edeb3ce41eeb3e93eea
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Dec 13 12:43:30 2007 -0600

    [SCSI] libiscsi: fix nop handling
    
    During root boot and shutdown the target could send us nops.
    At this time iscsid cannot be running, so the target will drop
    the session and the boot or shutdown will hang.
    
    To handle this and allow us to better control when to check the network
    this patch moves the nop handling to the kernel.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index d68f74523f2e..889f51fabab9 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -148,6 +148,12 @@ struct iscsi_conn {
 	 * conn_stop() flag: stop to recover, stop to terminate
 	 */
         int			stop_stage;
+	struct timer_list	transport_timer;
+	unsigned long		last_recv;
+	unsigned long		last_ping;
+	int			ping_timeout;
+	int			recv_timeout;
+	struct iscsi_mgmt_task	*ping_mtask;
 
 	/* iSCSI connection-wide sequencing */
 	uint32_t		exp_statsn;
@@ -238,6 +244,8 @@ struct iscsi_session {
 	uint32_t		queued_cmdsn;
 
 	/* configuration */
+	int			abort_timeout;
+	int			lu_reset_timeout;
 	int			initial_r2t_en;
 	unsigned		max_r2t;
 	int			imm_data_en;

commit b3a7ea8d50f6028964b468d13a095dfb2508b2fb
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Dec 13 12:43:26 2007 -0600

    [SCSI] libiscsi: do not block session during logout
    
    There is not need to block the session during logout. Since
    we are going to fail the commands that were blocked just fail them
    immediately instead.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 4b3e3c15121a..d68f74523f2e 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -346,6 +346,8 @@ extern int __iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,
 extern int iscsi_verify_itt(struct iscsi_conn *, struct iscsi_hdr *,
 			    uint32_t *);
 extern void iscsi_requeue_ctask(struct iscsi_cmd_task *ctask);
+extern void iscsi_free_mgmt_task(struct iscsi_conn *conn,
+				 struct iscsi_mgmt_task *mtask);
 
 /*
  * generic helpers

commit 6320377fd94316e58f75d0be6f6e7a644950a4ee
Author: Olaf Kirch <olaf.kirch@oracle.com>
Date:   Thu Dec 13 12:43:25 2007 -0600

    [SCSI] libiscsi, iscsi_tcp: iscsi pool cleanup
    
    iscsi_pool_init simplified
    
    iscsi_pool_init currently has a lot of duplicate kfree() calls it does
    when some allocation fails. This patch simplifies the code a little by
    using iscsi_pool_free to tear down the pool in case of an error.
    
    iscsi_pool_init also returns a copy of the item array to the caller.
    Not all callers use this array, so we make it optional.
    
    Instead of allocating a second array and return that, allocate just one
    array, of twice the size.
    
    Update users of iscsi_pool_{init,free}
    
    This patch drops the (now useless) second argument to
    iscsi_pool_free, and updates all callers.
    
    It also removes the ctask->r2ts array, which was never
    used anyway. Since the items argument to iscsi_pool_init
    is now optional, we can pass NULL instead.
    
    Signed-off-by: Olaf Kirch <olaf.kirch@oracle.com>
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index a9a9e869188d..4b3e3c15121a 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -215,7 +215,7 @@ struct iscsi_conn {
 	uint32_t		eh_abort_cnt;
 };
 
-struct iscsi_queue {
+struct iscsi_pool {
 	struct kfifo		*queue;		/* FIFO Queue */
 	void			**pool;		/* Pool of elements */
 	int			max;		/* Max number of elements */
@@ -274,10 +274,10 @@ struct iscsi_session {
 
 	int			cmds_max;	/* size of cmds array */
 	struct iscsi_cmd_task	**cmds;		/* Original Cmds arr */
-	struct iscsi_queue	cmdpool;	/* PDU's pool */
+	struct iscsi_pool	cmdpool;	/* PDU's pool */
 	int			mgmtpool_max;	/* size of mgmt array */
 	struct iscsi_mgmt_task	**mgmt_cmds;	/* Original mgmt arr */
-	struct iscsi_queue	mgmtpool;	/* Mgmt PDU's pool */
+	struct iscsi_pool	mgmtpool;	/* Mgmt PDU's pool */
 };
 
 /*
@@ -350,8 +350,8 @@ extern void iscsi_requeue_ctask(struct iscsi_cmd_task *ctask);
 /*
  * generic helpers
  */
-extern void iscsi_pool_free(struct iscsi_queue *, void **);
-extern int iscsi_pool_init(struct iscsi_queue *, int, void ***, int);
+extern void iscsi_pool_free(struct iscsi_pool *);
+extern int iscsi_pool_init(struct iscsi_pool *, int, void ***, int);
 
 /*
  * inline functions to deal with padding.

commit 004d6530f83bee43a55b51bb5960db96e7ae0ffa
Author: Boaz Harrosh <bharrosh@panasas.com>
Date:   Thu Dec 13 12:43:23 2007 -0600

    [SCSI] iscsi_tcp, libiscsi: initial AHS Support
    
      at libiscsi generic code
      - currently code assumes a storage space of pdu header is allocated
        at llds ctask and is pointed to by iscsi_cmd_task->hdr. Here I add
        a hdr_max field pertaining to that storage, and an hdr_len that
        accumulates the current use of the pdu-header.
    
      - Add an iscsi_next_hdr() inline which returns the next free space
        to write new Header at. Also iscsi_next_hdr() is used to retrieve
        the address at which to write the header-digest.
    
      - Add iscsi_add_hdr(length). What the user do is calls iscsi_next_hdr()
        for address of the new header, than calls iscsi_add_hdr(length) with
        the size of the new header. iscsi_add_hdr() will check if space is
        available and update to the new size. length must be padded according
        to standard.
    
      - Add 2 padding inline helpers thanks to Olaf. Current patch does not
        use them but Following patches will.
        Also moved definition of ISCSI_PAD_LEN to iscsi_proto.h which had
        PAD_WORD_LEN that was never used anywhere.
    
      - Let iscsi_prep_scsi_cmd_pdu() signal an Error return since now  it is
        possible that it will fail.
    
      - I was tired of yet again writing a "this is a digest" comment next to
        sizeof(__u32) so I defined a new ISCSI_DIGEST_SIZE. Now I don't need
        any comments. Changed all places that used sizeof(__u32) or "4" in
        connection to a digest.
    
      iscsi_tcp specific code
      - At struct iscsi_tcp_cmd_task allocate maximum space allowed in
        standard for all headers following the iscsi_cmd header. and mark
        it so in iscsi_tcp_session_create()
      - At iscsi_send_cmd_hdr() retrieve the correct headers size and
        write header digest at iscsi_next_hdr().
    
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    Signed-off-by: Olaf Kirch <olaf.kirch@oracle.com>
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index e1fb3d0927b0..a9a9e869188d 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -78,6 +78,9 @@ enum {
 #define ISCSI_ADDRESS_BUF_LEN		64
 
 enum {
+	/* this is the maximum possible storage for AHSs */
+	ISCSI_MAX_AHS_SIZE = sizeof(struct iscsi_ecdb_ahdr) +
+				sizeof(struct iscsi_rlength_ahdr),
 	ISCSI_DIGEST_SIZE = sizeof(__u32),
 };
 
@@ -102,10 +105,13 @@ enum {
 
 struct iscsi_cmd_task {
 	/*
-	 * Becuae LLDs allocate their hdr differently, this is a pointer to
-	 * that storage. It must be setup at session creation time.
+	 * Because LLDs allocate their hdr differently, this is a pointer
+	 * and length to that storage. It must be setup at session
+	 * creation time.
 	 */
 	struct iscsi_cmd	*hdr;
+	unsigned short		hdr_max;
+	unsigned short		hdr_len;	/* accumulated size of hdr used */
 	int			itt;		/* this ITT */
 
 	uint32_t		unsol_datasn;
@@ -124,6 +130,11 @@ struct iscsi_cmd_task {
 	void			*dd_data;	/* driver/transport data */
 };
 
+static inline void* iscsi_next_hdr(struct iscsi_cmd_task *ctask)
+{
+	return (void*)ctask->hdr + ctask->hdr_len;
+}
+
 struct iscsi_conn {
 	struct iscsi_cls_conn	*cls_conn;	/* ptr to class connection */
 	void			*dd_data;	/* iscsi_transport data */
@@ -342,4 +353,22 @@ extern void iscsi_requeue_ctask(struct iscsi_cmd_task *ctask);
 extern void iscsi_pool_free(struct iscsi_queue *, void **);
 extern int iscsi_pool_init(struct iscsi_queue *, int, void ***, int);
 
+/*
+ * inline functions to deal with padding.
+ */
+static inline unsigned int
+iscsi_padded(unsigned int len)
+{
+	return (len + ISCSI_PAD_LEN - 1) & ~(ISCSI_PAD_LEN - 1);
+}
+
+static inline unsigned int
+iscsi_padding(unsigned int len)
+{
+	len &= (ISCSI_PAD_LEN - 1);
+	if (len)
+		len = ISCSI_PAD_LEN - len;
+	return len;
+}
+
 #endif

commit da32dd681f7a1a17073c42b375fc23cf73c92155
Author: Olaf Kirch <olaf.kirch@oracle.com>
Date:   Thu Dec 13 12:43:21 2007 -0600

    [SCSI] iscsi_tcp: rewrite recv path
    
    Rewrite recv path. Fixes:
    - data digest processing and error handling.
    - ahs support.
    
    Some fixups by Mike Christie
    
    Signed-off-by: Olaf Kirch <olaf.kirch@oracle.com>
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 89429f433f85..e1fb3d0927b0 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -77,6 +77,10 @@ enum {
 
 #define ISCSI_ADDRESS_BUF_LEN		64
 
+enum {
+	ISCSI_DIGEST_SIZE = sizeof(__u32),
+};
+
 struct iscsi_mgmt_task {
 	/*
 	 * Becuae LLDs allocate their hdr differently, this is a pointer to

commit 843c0a8a76078cf961b244b839683d0667313740
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Dec 13 12:43:20 2007 -0600

    [SCSI] libiscsi, iscsi_tcp: add device support
    
    This patch adds logical unit reset support. This should work for ib_iser,
    but I have not finished testing that driver so it is not hooked in yet.
    
    This patch also temporarily reverts the iscsi_tcp r2t write out patch.
    That code is completely rewritten in this patchset.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index b4b31132618b..89429f433f85 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -57,11 +57,14 @@ struct iscsi_nopin;
 #define ISCSI_MAX_CMD_PER_LUN		128
 
 /* Task Mgmt states */
-#define TMABORT_INITIAL			0x0
-#define TMABORT_SUCCESS			0x1
-#define TMABORT_FAILED			0x2
-#define TMABORT_TIMEDOUT		0x3
-#define TMABORT_NOT_FOUND		0x4
+enum {
+	TMF_INITIAL,
+	TMF_QUEUED,
+	TMF_SUCCESS,
+	TMF_FAILED,
+	TMF_TIMEDOUT,
+	TMF_NOT_FOUND,
+};
 
 /* Connection suspend "bit" */
 #define ISCSI_SUSPEND_BIT		1
@@ -91,7 +94,6 @@ enum {
 	ISCSI_TASK_COMPLETED,
 	ISCSI_TASK_PENDING,
 	ISCSI_TASK_RUNNING,
-	ISCSI_TASK_ABORTING,
 };
 
 struct iscsi_cmd_task {
@@ -110,7 +112,6 @@ struct iscsi_cmd_task {
 	unsigned		data_count;	/* remaining Data-Out */
 	struct scsi_cmnd	*sc;		/* associated SCSI cmd*/
 	struct iscsi_conn	*conn;		/* used connection    */
-	struct iscsi_mgmt_task	*mtask;		/* tmf mtask in progr */
 
 	/* state set/tested under session->lock */
 	int			state;
@@ -152,10 +153,11 @@ struct iscsi_conn {
 	struct iscsi_cmd_task	*ctask;		/* xmit ctask in progress */
 
 	/* xmit */
-	struct kfifo		*mgmtqueue;	/* mgmt (control) xmit queue */
+	struct list_head	mgmtqueue;	/* mgmt (control) xmit queue */
 	struct list_head	mgmt_run_list;	/* list of control tasks */
 	struct list_head	xmitqueue;	/* data-path cmd queue */
 	struct list_head	run_list;	/* list of cmds in progress */
+	struct list_head	requeue;	/* tasks needing another run */
 	struct work_struct	xmitwork;	/* per-conn. xmit workqueue */
 	unsigned long		suspend_tx;	/* suspend Tx */
 	unsigned long		suspend_rx;	/* suspend Rx */
@@ -163,8 +165,8 @@ struct iscsi_conn {
 	/* abort */
 	wait_queue_head_t	ehwait;		/* used in eh_abort() */
 	struct iscsi_tm		tmhdr;
-	struct timer_list	tmabort_timer;
-	int			tmabort_state;	/* see TMABORT_INITIAL, etc.*/
+	struct timer_list	tmf_timer;
+	int			tmf_state;	/* see TMF_INITIAL, etc.*/
 
 	/* negotiated params */
 	unsigned		max_recv_dlength; /* initiator_max_recv_dsl*/
@@ -231,6 +233,7 @@ struct iscsi_session {
 	int			pdu_inorder_en;
 	int			dataseq_inorder_en;
 	int			erl;
+	int			fast_abort;
 	int			tpgt;
 	char			*username;
 	char			*username_in;
@@ -268,6 +271,7 @@ struct iscsi_session {
 extern int iscsi_change_queue_depth(struct scsi_device *sdev, int depth);
 extern int iscsi_eh_abort(struct scsi_cmnd *sc);
 extern int iscsi_eh_host_reset(struct scsi_cmnd *sc);
+extern int iscsi_eh_device_reset(struct scsi_cmnd *sc);
 extern int iscsi_queuecommand(struct scsi_cmnd *sc,
 			      void (*done)(struct scsi_cmnd *));
 
@@ -326,6 +330,7 @@ extern int __iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,
 				char *, int);
 extern int iscsi_verify_itt(struct iscsi_conn *, struct iscsi_hdr *,
 			    uint32_t *);
+extern void iscsi_requeue_ctask(struct iscsi_cmd_task *ctask);
 
 /*
  * generic helpers

commit 6724add1b5cfb020ba8f5532efe430d1ccd5fc30
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed Aug 15 01:38:30 2007 -0500

    [SCSI] libiscsi: sync up iscsi and scsi eh's access to the connection
    
    The iscsi eh could be tearing down the session/connection while
    the scsi eh is still sending task management functions. If when
    we drop the session lock to grab the recv lock, the iscsi eh
    tears down the connection we will oops.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 007d442412e2..b4b31132618b 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -205,6 +205,13 @@ struct iscsi_queue {
 };
 
 struct iscsi_session {
+	/*
+	 * Syncs up the scsi eh thread with the iscsi eh thread when sending
+	 * task management functions. This must be taken before the session
+	 * and recv lock.
+	 */
+	struct mutex		eh_mutex;
+
 	/* iSCSI session-wide sequencing */
 	uint32_t		cmdsn;
 	uint32_t		exp_cmdsn;

commit e07264071f7f2b02a2973cb28d9fdf5eb8866cc1
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Jul 26 12:46:48 2007 -0500

    [SCSI] libiscsi: fix cmd seqeunce number checking
    
    We should not be checking the cmd windown for just handling r2t responses.
    And if the window closes in on us, always have scsi-ml requeue the command
    from our queuecommand function.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 3f631b08a1ab..007d442412e2 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -210,6 +210,9 @@ struct iscsi_session {
 	uint32_t		exp_cmdsn;
 	uint32_t		max_cmdsn;
 
+	/* This tracks the reqs queued into the initiator */
+	uint32_t		queued_cmdsn;
+
 	/* configuration */
 	int			initial_r2t_en;
 	unsigned		max_r2t;

commit d8196ed2181b4595eaf464a5bcbddb6c28649a39
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 30 12:57:25 2007 -0500

    [SCSI] iscsi class, iscsi_tcp, iser, qla4xxx: add netdevname sysfs attr
    
    iSCSI must support software iscsi (iscsi_tcp, iser), hardware iscsi (qla4xxx),
    and partial offload (broadcom). To be able to allow each stack or driver
    or port (virtual or physical) to be able to log into the same target portal
    we use the initiator tuple [[HWADDRESS | NETDEVNAME], INITIATOR_NAME] and
    the target tuple [TARGETNAME, CONN_ADDRESS, CONN_PORT] to id a session.
    This patch adds the netdev name, which is used by software iscsi when
    it binds a session to a netdevice using the SO_BINDTODEVICE sock opt.
    It cannot use HWADDRESS because if someone did vlans then the same netdevice
    will have the same mac and the initiator,target id will not be unique.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Cc: Roland Dreier <rdreier@cisco.com>
    Cc: David C Somayajulu <david.somayajulu@qlogic.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index eea33f7b1544..3f631b08a1ab 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -228,8 +228,9 @@ struct iscsi_session {
 	char			*password_in;
 	char			*targetname;
 	char			*initiatorname;
-	/* hw address being used for iscsi connection */
+	/* hw address or netdev iscsi connection is bound to */
 	char			*hwaddress;
+	char			*netdev;
 	/* control data */
 	struct iscsi_transport	*tt;
 	struct Scsi_Host	*host;

commit 2223696192c687f2853e42b7c1e0d3ef002081fd
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 30 12:57:24 2007 -0500

    [SCSI] iscsi class, qla4xxx, iscsi_tcp: export local address
    
    This patch exports the local address for the session. For
    qla4xxx this is the ip of the hba's port. For software
    this is the src addr of the socket.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Cc: David C Somayajulu <david.somayajulu@qlogic.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 2f303a3b270e..eea33f7b1544 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -72,6 +72,8 @@ struct iscsi_nopin;
 #define ISCSI_AGE_SHIFT			28
 #define ISCSI_AGE_MASK			(0xf << ISCSI_AGE_SHIFT)
 
+#define ISCSI_ADDRESS_BUF_LEN		64
+
 struct iscsi_mgmt_task {
 	/*
 	 * Becuae LLDs allocate their hdr differently, this is a pointer to
@@ -174,6 +176,12 @@ struct iscsi_conn {
 	/* values userspace uses to id a conn */
 	int			persistent_port;
 	char			*persistent_address;
+	/* remote portal currently connected to */
+	int			portal_port;
+	char			portal_address[ISCSI_ADDRESS_BUF_LEN];
+	/* local address */
+	int			local_port;
+	char			local_address[ISCSI_ADDRESS_BUF_LEN];
 
 	/* MIB-statistics */
 	uint64_t		txdata_octets;

commit 1548271ece9e9312fd5feb41fd58773b56a71d39
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 30 12:57:19 2007 -0500

    [SCSI] libiscsi: make can_queue configurable
    
    This patch allows us to set can_queue and cmds_per_lun from userspace
    when we create the session/host. From there we can set it on a per
    target basis. The patch fully converts iscsi_tcp, but only hooks
    up ib_iser for cmd_per_lun since it currently has a lots of preallocations
    based on can_queue.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Cc: Roland Dreier <rdreier@cisco.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 8d48cf8f2e3f..2f303a3b270e 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -48,9 +48,8 @@ struct iscsi_nopin;
 #define debug_scsi(fmt...)
 #endif
 
-#define ISCSI_XMIT_CMDS_MAX	128	/* must be power of 2 */
-#define ISCSI_MGMT_CMDS_MAX	32	/* must be power of 2 */
-#define ISCSI_CONN_MAX			1
+#define ISCSI_DEF_XMIT_CMDS_MAX	128	/* must be power of 2 */
+#define ISCSI_MGMT_CMDS_MAX	16	/* must be power of 2 */
 
 #define ISCSI_MGMT_ITT_OFFSET	0xa00
 
@@ -268,7 +267,7 @@ extern int iscsi_host_get_param(struct Scsi_Host *shost,
  */
 extern struct iscsi_cls_session *
 iscsi_session_setup(struct iscsi_transport *, struct scsi_transport_template *,
-		    int, int, uint32_t, uint32_t *);
+		    uint16_t, uint16_t, int, int, uint32_t, uint32_t *);
 extern void iscsi_session_teardown(struct iscsi_cls_session *);
 extern struct iscsi_session *class_to_transport_session(struct iscsi_cls_session *);
 extern void iscsi_session_recovery_timedout(struct iscsi_cls_session *);

commit 77a23c21aaa723f6b0ffc4a701be8c8e5a32346d
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 30 12:57:18 2007 -0500

    [SCSI] libiscsi: fix iscsi cmdsn allocation
    
    The cmdsn allocation and pdu transmit code can race, and we can end
    up sending a pdu with cmdsn 10 before a pdu with 5. The target will
    then fail the connection/session. This patch fixes the problem by
    delaying the cmdsn allocation until we are about to send the pdu.
    
    This also removes the xmitmutex. We were using the connection xmitmutex
    during error handling to handle races with mtask and ctask cleanup and
    completion. For ctasks we now have nice refcounting and for the mtask,
    if we hit the case where the mtask timesout and it is floating
    around somewhere in the driver, we end up dropping the session.
    And to handle session level cleanup, we use the xmit suspend bit
    along with scsi_flush_queue and the session lock to make sure
    that the xmit thread is not possibly transmitting a task while
    we are trying to kill it.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Cc: Roland Dreier <rdreier@cisco.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 61bc8f75b267..8d48cf8f2e3f 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -90,6 +90,7 @@ enum {
 	ISCSI_TASK_COMPLETED,
 	ISCSI_TASK_PENDING,
 	ISCSI_TASK_RUNNING,
+	ISCSI_TASK_ABORTING,
 };
 
 struct iscsi_cmd_task {
@@ -150,18 +151,11 @@ struct iscsi_conn {
 	struct iscsi_cmd_task	*ctask;		/* xmit ctask in progress */
 
 	/* xmit */
-	struct kfifo		*immqueue;	/* immediate xmit queue */
 	struct kfifo		*mgmtqueue;	/* mgmt (control) xmit queue */
 	struct list_head	mgmt_run_list;	/* list of control tasks */
 	struct list_head	xmitqueue;	/* data-path cmd queue */
 	struct list_head	run_list;	/* list of cmds in progress */
 	struct work_struct	xmitwork;	/* per-conn. xmit workqueue */
-	/*
-	 * serializes connection xmit, access to kfifos:
-	 * xmitqueue, immqueue, mgmtqueue
-	 */
-	struct mutex		xmitmutex;
-
 	unsigned long		suspend_tx;	/* suspend Tx */
 	unsigned long		suspend_rx;	/* suspend Rx */
 
@@ -303,8 +297,7 @@ extern int iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
 /*
  * pdu and task processing
  */
-extern int iscsi_check_assign_cmdsn(struct iscsi_session *,
-				    struct iscsi_nopin *);
+extern void iscsi_update_cmdsn(struct iscsi_session *, struct iscsi_nopin *);
 extern void iscsi_prep_unsolicit_data_pdu(struct iscsi_cmd_task *,
 					struct iscsi_data *hdr);
 extern int iscsi_conn_send_pdu(struct iscsi_cls_conn *, struct iscsi_hdr *,

commit b2c6416736b847b91950bd43cc5153e11a1f83ee
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 30 12:57:16 2007 -0500

    [SCSI] iscsi class, iscsi_tcp, ib_iser: add sysfs chap file
    
    The attached patches add sysfs files for the chap settings
    to the iscsi transport class, iscsi_tcp and ib_iser. This is
    needed for software iscsi because there are times when iscsid
    can die and it will need to reread the values it was using.
    And it is needed by qla4xxx for basic management opertaions.
    This patch does not hook in qla4xxx yet, because I am not sure
    the mbx command to use.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Cc: Roland Dreier <rdreier@cisco.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 348265d4a27e..61bc8f75b267 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -221,6 +221,10 @@ struct iscsi_session {
 	int			dataseq_inorder_en;
 	int			erl;
 	int			tpgt;
+	char			*username;
+	char			*username_in;
+	char			*password;
+	char			*password_in;
 	char			*targetname;
 	char			*initiatorname;
 	/* hw address being used for iscsi connection */

commit 857ae0bdb72999936a28ce621e38e2e288c485da
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 30 12:57:15 2007 -0500

    [SCSI] iscsi: Some fixes in preparation for bidirectional support - total_length
    
    - Remove shadow of request length from struct iscsi_cmd_task.
    - change all users to use scsi_cmnd->request_bufflen directly
    
    (With bidi we will use scsi-ml API to retrieve in/out length)
    
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Cc: Roland Dreier <rdreier@cisco.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 61e069206ac5..348265d4a27e 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -80,7 +80,7 @@ struct iscsi_mgmt_task {
 	 */
 	struct iscsi_hdr	*hdr;
 	char			*data;		/* mgmt payload */
-	int			data_count;	/* counts data to be sent */
+	unsigned		data_count;	/* counts data to be sent */
 	uint32_t		itt;		/* this ITT */
 	void			*dd_data;	/* driver/transport data */
 	struct list_head	running;
@@ -101,13 +101,12 @@ struct iscsi_cmd_task {
 	int			itt;		/* this ITT */
 
 	uint32_t		unsol_datasn;
-	int			imm_count;	/* imm-data (bytes)   */
-	int			unsol_count;	/* unsolicited (bytes)*/
+	unsigned		imm_count;	/* imm-data (bytes)   */
+	unsigned		unsol_count;	/* unsolicited (bytes)*/
 	/* offset in unsolicited stream (bytes); */
-	int			unsol_offset;
-	int			data_count;	/* remaining Data-Out */
+	unsigned		unsol_offset;
+	unsigned		data_count;	/* remaining Data-Out */
 	struct scsi_cmnd	*sc;		/* associated SCSI cmd*/
-	int			total_length;
 	struct iscsi_conn	*conn;		/* used connection    */
 	struct iscsi_mgmt_task	*mtask;		/* tmf mtask in progr */
 
@@ -173,8 +172,8 @@ struct iscsi_conn {
 	int			tmabort_state;	/* see TMABORT_INITIAL, etc.*/
 
 	/* negotiated params */
-	int			max_recv_dlength; /* initiator_max_recv_dsl*/
-	int			max_xmit_dlength; /* target_max_recv_dsl */
+	unsigned		max_recv_dlength; /* initiator_max_recv_dsl*/
+	unsigned		max_xmit_dlength; /* target_max_recv_dsl */
 	int			hdrdgst_en;
 	int			datadgst_en;
 	int			ifmarker_en;
@@ -212,10 +211,10 @@ struct iscsi_session {
 
 	/* configuration */
 	int			initial_r2t_en;
-	int			max_r2t;
+	unsigned		max_r2t;
 	int			imm_data_en;
-	int			first_burst;
-	int			max_burst;
+	unsigned		first_burst;
+	unsigned		max_burst;
 	int			time2wait;
 	int			time2retain;
 	int			pdu_inorder_en;

commit d473cc7f15f64ab8a90c3d7288ef30f46785d8d5
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 30 12:57:14 2007 -0500

    [SCSI] iscsi: Some fixes in preparation for bidirectional support - exp_datasn
    
    This patch fixes handling of expected datasn/r2tsn as received from
    target. It is done according to: T10 rfc3720 section 3.2.2.3. Data Sequencing.
    
    . unify expected datasn/r2tsn into one counter
    . calculate than check expected datasn/r2tsn. On error print a message
      and fail the request. (TODO use iscsi retransmits)
    . remove the FIXME   ;)
    . avoid zero length memset
    
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index deae90a56a0d..61e069206ac5 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -99,7 +99,6 @@ struct iscsi_cmd_task {
 	 */
 	struct iscsi_cmd	*hdr;
 	int			itt;		/* this ITT */
-	int			datasn;		/* DataSN */
 
 	uint32_t		unsol_datasn;
 	int			imm_count;	/* imm-data (bytes)   */

commit 8ad5781ae9702a8f95cfdf30967752e4297613ee
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 30 12:57:13 2007 -0500

    [SCSI] iscsi class, qla4xxx, iscsi_tcp, ib_iser: export/set initiator name
    
    For iscsi root boot, software iscsi needs to know what the BIOS/OF
    initiator used for the initiator name so this puts it in sysfs
    for userspace to be able to pick up.
    
    For hw iscsi, it is nice to see what the card is using.
    
    This patch adds the new param, and hooks in qla4xxx, iscsi_tcp, and ib_iser.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Cc: Roland Dreier <rdreier@cisco.com>
    Cc: David C Somayajulu <david.somayajulu@qlogic.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index e202cc00c8e7..deae90a56a0d 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -224,6 +224,7 @@ struct iscsi_session {
 	int			erl;
 	int			tpgt;
 	char			*targetname;
+	char			*initiatorname;
 	/* hw address being used for iscsi connection */
 	char			*hwaddress;
 	/* control data */

commit 0801c242a33426fddc005c2f559a3d2fa6fca7eb
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed May 30 12:57:12 2007 -0500

    [SCSI] libiscsi, iscsi_tcp, ib_iser : add sw iscsi host get/set params helpers
    
    iscsid and udev need to key off the hw address being
    used so add some helpers for iser and iscsi tcp.
    
    Also convert them
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Cc: Roland Dreier <rdreier@cisco.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index ea0816d4904d..e202cc00c8e7 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -224,7 +224,8 @@ struct iscsi_session {
 	int			erl;
 	int			tpgt;
 	char			*targetname;
-
+	/* hw address being used for iscsi connection */
+	char			*hwaddress;
 	/* control data */
 	struct iscsi_transport	*tt;
 	struct Scsi_Host	*host;
@@ -255,6 +256,16 @@ extern int iscsi_eh_host_reset(struct scsi_cmnd *sc);
 extern int iscsi_queuecommand(struct scsi_cmnd *sc,
 			      void (*done)(struct scsi_cmnd *));
 
+
+/*
+ * iSCSI host helpers.
+ */
+extern int iscsi_host_set_param(struct Scsi_Host *shost,
+				enum iscsi_host_param param, char *buf,
+				int buflen);
+extern int iscsi_host_get_param(struct Scsi_Host *shost,
+				enum iscsi_host_param param, char *buf);
+
 /*
  * session management
  */

commit f6a570333e554b48ad589e7137c77c57809eee81
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Oct 18 01:47:25 2006 -0400

    [PATCH] severing module.h->sched.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 61eebec00a7b..ea0816d4904d 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -25,6 +25,8 @@
 
 #include <linux/types.h>
 #include <linux/mutex.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
 #include <scsi/iscsi_proto.h>
 #include <scsi/iscsi_if.h>
 

commit 98644047916c24258fb47c3dab2bed8a44f53b83
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Mon Oct 16 18:09:39 2006 -0400

    [SCSI] libiscsi: fix oops in connection create failure path
    
    If connection creation fails we end up calling list_del
    on a invalid struct. This then causes an oops. We are not
    acutally using the lists (old MCS code we thought might
    be useful elsewhere) so this patch just removes that
    code.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 401192e56e50..61eebec00a7b 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -136,7 +136,6 @@ struct iscsi_conn {
 
 	/* control data */
 	int			id;		/* CID */
-	struct list_head	item;		/* maintains list of conns */
 	int			c_stage;	/* connection state */
 	/*
 	 * Preallocated buffer for pdus that have data but do not
@@ -235,10 +234,8 @@ struct iscsi_session {
 						 * - mgmtpool,		   *
 						 * - r2tpool		   */
 	int			state;		/* session state           */
-	struct list_head	item;
 	int			age;		/* counts session re-opens */
 
-	struct list_head	connections;	/* list of connections */
 	int			cmds_max;	/* size of cmds array */
 	struct iscsi_cmd_task	**cmds;		/* Original Cmds arr */
 	struct iscsi_queue	cmdpool;	/* PDU's pool */

commit 60ecebf5a10e42f5e2d6e07eb9e24bdee8500b81
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Aug 31 18:09:25 2006 -0400

    [SCSI] add refcouting around ctask usage in main IO patch
    
    It is possible that a ctask could be completing and getting
    cleaned up at the same time, we are finishing up the last
    data transfer. This could then result in the data transfer
    code using stale or invalid values. This patch adds a refcount
    to the ctask. When the count goes to zero then we know the
    transmit thread and recv thread or softirq are not touching
    it and we can safely release it.
    
    The eh should not need to grab a reference because it only cleans
    up a task if it has both the xmit mutex and recv lock (or recv
    side suspended).
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 4900650bd081..401192e56e50 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -112,6 +112,7 @@ struct iscsi_cmd_task {
 
 	/* state set/tested under session->lock */
 	int			state;
+	atomic_t		refcount;
 	struct list_head	running;	/* running cmd list */
 	void			*dd_data;	/* driver/transport data */
 };

commit ffd0436ed2e5a741c8d30062b489b989acf0a526
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Aug 31 18:09:24 2006 -0400

    [SCSI] libiscsi, iscsi_tcp, iscsi_iser: check that burst lengths are valid.
    
    iSCSI RFC states that the first burst length must be smaller than the
    max burst length. We currently assume targets will be good, but that may
    not be the case, so this patch adds a check.
    
    This patch also moves the unsol data out offset to the lib so the LLDs
    do not have to track it.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 41904f611d12..4900650bd081 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -102,6 +102,8 @@ struct iscsi_cmd_task {
 	uint32_t		unsol_datasn;
 	int			imm_count;	/* imm-data (bytes)   */
 	int			unsol_count;	/* unsolicited (bytes)*/
+	/* offset in unsolicited stream (bytes); */
+	int			unsol_offset;
 	int			data_count;	/* remaining Data-Out */
 	struct scsi_cmnd	*sc;		/* associated SCSI cmd*/
 	int			total_length;
@@ -290,8 +292,7 @@ extern int iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
 extern int iscsi_check_assign_cmdsn(struct iscsi_session *,
 				    struct iscsi_nopin *);
 extern void iscsi_prep_unsolicit_data_pdu(struct iscsi_cmd_task *,
-					struct iscsi_data *hdr,
-					int transport_data_cnt);
+					struct iscsi_data *hdr);
 extern int iscsi_conn_send_pdu(struct iscsi_cls_conn *, struct iscsi_hdr *,
 				char *, uint32_t);
 extern int iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,

commit c8dc1e523b0f1e6dd71cdabd8c7d7587c6dc27f9
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Mon Jul 24 15:47:39 2006 -0500

    [SCSI] iscsi bugfixes: reduce memory allocations
    
    We currently try to allocate a max_recv_data_segment_length
    which can be very large (default is 64K), and common uses
    are up to 1MB. It is very very difficult to allocte this
    much contiguous memory and it turns out we never even use it.
    We really only need a couple of pages, so this patch has us
    allocates just what we know what we need today.
    
    Later if vendors start adding vendor specific data and
    we need to handle large buffers we can do this, but for
    the last 4 years we have not seen anyone do this or request
    it.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 3f69f7e58f89..41904f611d12 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -135,6 +135,14 @@ struct iscsi_conn {
 	int			id;		/* CID */
 	struct list_head	item;		/* maintains list of conns */
 	int			c_stage;	/* connection state */
+	/*
+	 * Preallocated buffer for pdus that have data but do not
+	 * originate from scsi-ml. We never have two pdus using the
+	 * buffer at the same time. It is only allocated to
+	 * the default max recv size because the pdus we support
+	 * should always fit in this buffer
+	 */
+	char			*data;
 	struct iscsi_mgmt_task	*login_mtask;	/* mtask used for login/text */
 	struct iscsi_mgmt_task	*mtask;		/* xmit mtask in progress */
 	struct iscsi_cmd_task	*ctask;		/* xmit ctask in progress */

commit 7ea8b82847293c2311cf08fc3ed31ab0e452a27e
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Mon Jul 24 15:47:22 2006 -0500

    [SCSI] iscsi bugfixes: fix abort handling
    
    Abort handler fixes.
    
    If a connection is dropped and reconnected while an abort is
    running then we should assume the recovery code will clean up
    the abort. Not doing so causes a oops.
    
    And if a command completes then we get the status for the abort, we do not
    need to call into the LLD to cleanup the resources. Doing this causes
    and oops in iser because it ends up freeing some resources twice.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index e71d6e96eca6..3f69f7e58f89 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -60,6 +60,7 @@ struct iscsi_nopin;
 #define TMABORT_SUCCESS			0x1
 #define TMABORT_FAILED			0x2
 #define TMABORT_TIMEDOUT		0x3
+#define TMABORT_NOT_FOUND		0x4
 
 /* Connection suspend "bit" */
 #define ISCSI_SUSPEND_BIT		1

commit b6c395ed0387c824ddf125d3b74b576a2575c149
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Mon Jul 24 15:47:15 2006 -0500

    [SCSI] iscsi bugfixes: fix r2t handling
    
    The iscsi tcp code can pluck multiple rt2s from the tasks's r2tqueue
    in the xmit code. This can result in the task being queued on the xmit queue
    but gettting completed at the same time.
    
    This patch fixes the above bug by making the fifo a list so
    we always remove the entry on the list del.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index ba2760802ded..e71d6e96eca6 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -83,6 +83,12 @@ struct iscsi_mgmt_task {
 	struct list_head	running;
 };
 
+enum {
+	ISCSI_TASK_COMPLETED,
+	ISCSI_TASK_PENDING,
+	ISCSI_TASK_RUNNING,
+};
+
 struct iscsi_cmd_task {
 	/*
 	 * Becuae LLDs allocate their hdr differently, this is a pointer to
@@ -101,6 +107,8 @@ struct iscsi_cmd_task {
 	struct iscsi_conn	*conn;		/* used connection    */
 	struct iscsi_mgmt_task	*mtask;		/* tmf mtask in progr */
 
+	/* state set/tested under session->lock */
+	int			state;
 	struct list_head	running;	/* running cmd list */
 	void			*dd_data;	/* driver/transport data */
 };
@@ -134,7 +142,7 @@ struct iscsi_conn {
 	struct kfifo		*immqueue;	/* immediate xmit queue */
 	struct kfifo		*mgmtqueue;	/* mgmt (control) xmit queue */
 	struct list_head	mgmt_run_list;	/* list of control tasks */
-	struct kfifo		*xmitqueue;	/* data-path cmd queue */
+	struct list_head	xmitqueue;	/* data-path cmd queue */
 	struct list_head	run_list;	/* list of cmds in progress */
 	struct work_struct	xmitwork;	/* per-conn. xmit workqueue */
 	/*

commit a54a52caad4bd6166cb7fa64e4e93031fa2fda5d
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed Jun 28 12:00:23 2006 -0500

    [SCSI] iscsi: fixup set/get param functions
    
    Reduce duplication in the software iscsi_transport modules by
    adding a libiscsi function to handle the common grunt work.
    
    This also has the drivers return specifc -EXXX values for different
    errors so userspace can finally handle them in a sane way.
    
    Also just pass the sysfs buffers to the drivers so HW iscsi can
    get/set its string values, like targetname, and initiatorname.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index cbf7e58bd6f9..ba2760802ded 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -157,6 +157,11 @@ struct iscsi_conn {
 	int			max_xmit_dlength; /* target_max_recv_dsl */
 	int			hdrdgst_en;
 	int			datadgst_en;
+	int			ifmarker_en;
+	int			ofmarker_en;
+	/* values userspace uses to id a conn */
+	int			persistent_port;
+	char			*persistent_address;
 
 	/* MIB-statistics */
 	uint64_t		txdata_octets;
@@ -196,8 +201,8 @@ struct iscsi_session {
 	int			pdu_inorder_en;
 	int			dataseq_inorder_en;
 	int			erl;
-	int			ifmarker_en;
-	int			ofmarker_en;
+	int			tpgt;
+	char			*targetname;
 
 	/* control data */
 	struct iscsi_transport	*tt;
@@ -240,6 +245,10 @@ iscsi_session_setup(struct iscsi_transport *, struct scsi_transport_template *,
 extern void iscsi_session_teardown(struct iscsi_cls_session *);
 extern struct iscsi_session *class_to_transport_session(struct iscsi_cls_session *);
 extern void iscsi_session_recovery_timedout(struct iscsi_cls_session *);
+extern int iscsi_set_param(struct iscsi_cls_conn *cls_conn,
+			   enum iscsi_param param, char *buf, int buflen);
+extern int iscsi_session_get_param(struct iscsi_cls_session *cls_session,
+				   enum iscsi_param param, char *buf);
 
 #define session_to_cls(_sess) \
 	hostdata_session(_sess->host->hostdata)
@@ -255,6 +264,8 @@ extern void iscsi_conn_stop(struct iscsi_cls_conn *, int);
 extern int iscsi_conn_bind(struct iscsi_cls_session *, struct iscsi_cls_conn *,
 			   int);
 extern void iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err);
+extern int iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
+				enum iscsi_param param, char *buf);
 
 /*
  * pdu and task processing

commit 67a611149b2ac5f4af1e36bfffbfe3198cd3712c
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Tue May 30 00:37:20 2006 -0500

    [SCSI] iscsi: don't switch states when just cleaning up
    
    If recovery failed or we are in recovery only overwrite the state
    if we are going to terminate the session or if we logged back in.
    
    STOP_CONN_SUSPEND and conn_cnt are not used. We only support
    a single connection session ATM, so cleanup that code while
    we are working around it.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 17b28f08b692..cbf7e58bd6f9 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -211,7 +211,6 @@ struct iscsi_session {
 						 * - r2tpool		   */
 	int			state;		/* session state           */
 	struct list_head	item;
-	int			conn_cnt;
 	int			age;		/* counts session re-opens */
 
 	struct list_head	connections;	/* list of connections */

commit 656cffc95f0cb8211aa75eaca249e6ff4f59ec83
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu May 18 20:31:42 2006 -0500

    [SCSI] iscsi: fix command requeues during iscsi recovery
    
    Do not flush queues then block session. This will cause commands
    to needlessly swing around on us and remove goofy
    recovery_failed field and replace with state value.
    
    And do not start recovery from within the host reset function.
    This causeis too many problems becuase open-iscsi was desinged to
    call out to userspace then have userpscae decide if we should
    go into recovery or kill the session.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 2dba929a2a05..17b28f08b692 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -210,7 +210,6 @@ struct iscsi_session {
 						 * - mgmtpool,		   *
 						 * - r2tpool		   */
 	int			state;		/* session state           */
-	int			recovery_failed;
 	struct list_head	item;
 	int			conn_cnt;
 	int			age;		/* counts session re-opens */
@@ -241,8 +240,6 @@ iscsi_session_setup(struct iscsi_transport *, struct scsi_transport_template *,
 		    int, int, uint32_t, uint32_t *);
 extern void iscsi_session_teardown(struct iscsi_cls_session *);
 extern struct iscsi_session *class_to_transport_session(struct iscsi_cls_session *);
-extern void iscsi_start_session_recovery(struct iscsi_session *,
-					struct iscsi_conn *, int);
 extern void iscsi_session_recovery_timedout(struct iscsi_cls_session *);
 
 #define session_to_cls(_sess) \

commit be2df72e7ec5fa5e6e1ccccab6cef97ecbb9c191
Author: Or Gerlitz <ogerlitz@voltaire.com>
Date:   Tue May 2 19:46:43 2006 -0500

    [SCSI] iscsi: align printks
    
    align printk output
    
    Signed-off-by: Or Gerlitz <ogerlitz@voltaire.com>
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 830700a4ed69..2dba929a2a05 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -41,7 +41,7 @@ struct iscsi_nopin;
 
 /* #define DEBUG_SCSI */
 #ifdef DEBUG_SCSI
-#define debug_scsi(fmt...) printk(KERN_INFO "scsi: " fmt)
+#define debug_scsi(fmt...) printk(KERN_INFO "iscsi: " fmt)
 #else
 #define debug_scsi(fmt...)
 #endif

commit 7996a778ff8c717cb1a7a294475c59cc8f1e9fb8
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Apr 6 21:13:41 2006 -0500

    [SCSI] iscsi: add libiscsi
    
    There is a lot of code duplcited between iscsi_tcp
    and the upcoming iscsi_iser driver. This patch puts
    the duplicated code in a lib. There is more code
    to move around but this takes care of the
    basics. For iscsi_offload if they use the lib we will
    probably move some things around. For example in the
    queuecommand we will not assume that the LLD wants
    to do queue_work, but it is better to handle that
    later when we know for sure what iscsi_offload looks
    like (we could probably do this for iscsi_iser though to).
    
    Ideally I would like to get the iscsi_transports modules
    to a place where all they really have to do is put data
    on the wire, but how to do that will hopefully be more clear
    when we see other modules like iscsi_offload. Or maybe
    iscsi_offload will not use the lib and it will just be
    iscsi_iser and iscsi_tcp and maybe the iscsi_tcp_tgt if that
    is allowed in mainline.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
new file mode 100644
index 000000000000..830700a4ed69
--- /dev/null
+++ b/include/scsi/libiscsi.h
@@ -0,0 +1,286 @@
+/*
+ * iSCSI lib definitions
+ *
+ * Copyright (C) 2006 Red Hat, Inc.  All rights reserved.
+ * Copyright (C) 2004 - 2006 Mike Christie
+ * Copyright (C) 2004 - 2005 Dmitry Yusupov
+ * Copyright (C) 2004 - 2005 Alex Aizman
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef LIBISCSI_H
+#define LIBISCSI_H
+
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <scsi/iscsi_proto.h>
+#include <scsi/iscsi_if.h>
+
+struct scsi_transport_template;
+struct scsi_device;
+struct Scsi_Host;
+struct scsi_cmnd;
+struct socket;
+struct iscsi_transport;
+struct iscsi_cls_session;
+struct iscsi_cls_conn;
+struct iscsi_session;
+struct iscsi_nopin;
+
+/* #define DEBUG_SCSI */
+#ifdef DEBUG_SCSI
+#define debug_scsi(fmt...) printk(KERN_INFO "scsi: " fmt)
+#else
+#define debug_scsi(fmt...)
+#endif
+
+#define ISCSI_XMIT_CMDS_MAX	128	/* must be power of 2 */
+#define ISCSI_MGMT_CMDS_MAX	32	/* must be power of 2 */
+#define ISCSI_CONN_MAX			1
+
+#define ISCSI_MGMT_ITT_OFFSET	0xa00
+
+#define ISCSI_DEF_CMD_PER_LUN		32
+#define ISCSI_MAX_CMD_PER_LUN		128
+
+/* Task Mgmt states */
+#define TMABORT_INITIAL			0x0
+#define TMABORT_SUCCESS			0x1
+#define TMABORT_FAILED			0x2
+#define TMABORT_TIMEDOUT		0x3
+
+/* Connection suspend "bit" */
+#define ISCSI_SUSPEND_BIT		1
+
+#define ISCSI_ITT_MASK			(0xfff)
+#define ISCSI_CID_SHIFT			12
+#define ISCSI_CID_MASK			(0xffff << ISCSI_CID_SHIFT)
+#define ISCSI_AGE_SHIFT			28
+#define ISCSI_AGE_MASK			(0xf << ISCSI_AGE_SHIFT)
+
+struct iscsi_mgmt_task {
+	/*
+	 * Becuae LLDs allocate their hdr differently, this is a pointer to
+	 * that storage. It must be setup at session creation time.
+	 */
+	struct iscsi_hdr	*hdr;
+	char			*data;		/* mgmt payload */
+	int			data_count;	/* counts data to be sent */
+	uint32_t		itt;		/* this ITT */
+	void			*dd_data;	/* driver/transport data */
+	struct list_head	running;
+};
+
+struct iscsi_cmd_task {
+	/*
+	 * Becuae LLDs allocate their hdr differently, this is a pointer to
+	 * that storage. It must be setup at session creation time.
+	 */
+	struct iscsi_cmd	*hdr;
+	int			itt;		/* this ITT */
+	int			datasn;		/* DataSN */
+
+	uint32_t		unsol_datasn;
+	int			imm_count;	/* imm-data (bytes)   */
+	int			unsol_count;	/* unsolicited (bytes)*/
+	int			data_count;	/* remaining Data-Out */
+	struct scsi_cmnd	*sc;		/* associated SCSI cmd*/
+	int			total_length;
+	struct iscsi_conn	*conn;		/* used connection    */
+	struct iscsi_mgmt_task	*mtask;		/* tmf mtask in progr */
+
+	struct list_head	running;	/* running cmd list */
+	void			*dd_data;	/* driver/transport data */
+};
+
+struct iscsi_conn {
+	struct iscsi_cls_conn	*cls_conn;	/* ptr to class connection */
+	void			*dd_data;	/* iscsi_transport data */
+	struct iscsi_session	*session;	/* parent session */
+	/*
+	 * LLDs should set this lock. It protects the transport recv
+	 * code
+	 */
+	rwlock_t		*recv_lock;
+	/*
+	 * conn_stop() flag: stop to recover, stop to terminate
+	 */
+        int			stop_stage;
+
+	/* iSCSI connection-wide sequencing */
+	uint32_t		exp_statsn;
+
+	/* control data */
+	int			id;		/* CID */
+	struct list_head	item;		/* maintains list of conns */
+	int			c_stage;	/* connection state */
+	struct iscsi_mgmt_task	*login_mtask;	/* mtask used for login/text */
+	struct iscsi_mgmt_task	*mtask;		/* xmit mtask in progress */
+	struct iscsi_cmd_task	*ctask;		/* xmit ctask in progress */
+
+	/* xmit */
+	struct kfifo		*immqueue;	/* immediate xmit queue */
+	struct kfifo		*mgmtqueue;	/* mgmt (control) xmit queue */
+	struct list_head	mgmt_run_list;	/* list of control tasks */
+	struct kfifo		*xmitqueue;	/* data-path cmd queue */
+	struct list_head	run_list;	/* list of cmds in progress */
+	struct work_struct	xmitwork;	/* per-conn. xmit workqueue */
+	/*
+	 * serializes connection xmit, access to kfifos:
+	 * xmitqueue, immqueue, mgmtqueue
+	 */
+	struct mutex		xmitmutex;
+
+	unsigned long		suspend_tx;	/* suspend Tx */
+	unsigned long		suspend_rx;	/* suspend Rx */
+
+	/* abort */
+	wait_queue_head_t	ehwait;		/* used in eh_abort() */
+	struct iscsi_tm		tmhdr;
+	struct timer_list	tmabort_timer;
+	int			tmabort_state;	/* see TMABORT_INITIAL, etc.*/
+
+	/* negotiated params */
+	int			max_recv_dlength; /* initiator_max_recv_dsl*/
+	int			max_xmit_dlength; /* target_max_recv_dsl */
+	int			hdrdgst_en;
+	int			datadgst_en;
+
+	/* MIB-statistics */
+	uint64_t		txdata_octets;
+	uint64_t		rxdata_octets;
+	uint32_t		scsicmd_pdus_cnt;
+	uint32_t		dataout_pdus_cnt;
+	uint32_t		scsirsp_pdus_cnt;
+	uint32_t		datain_pdus_cnt;
+	uint32_t		r2t_pdus_cnt;
+	uint32_t		tmfcmd_pdus_cnt;
+	int32_t			tmfrsp_pdus_cnt;
+
+	/* custom statistics */
+	uint32_t		eh_abort_cnt;
+};
+
+struct iscsi_queue {
+	struct kfifo		*queue;		/* FIFO Queue */
+	void			**pool;		/* Pool of elements */
+	int			max;		/* Max number of elements */
+};
+
+struct iscsi_session {
+	/* iSCSI session-wide sequencing */
+	uint32_t		cmdsn;
+	uint32_t		exp_cmdsn;
+	uint32_t		max_cmdsn;
+
+	/* configuration */
+	int			initial_r2t_en;
+	int			max_r2t;
+	int			imm_data_en;
+	int			first_burst;
+	int			max_burst;
+	int			time2wait;
+	int			time2retain;
+	int			pdu_inorder_en;
+	int			dataseq_inorder_en;
+	int			erl;
+	int			ifmarker_en;
+	int			ofmarker_en;
+
+	/* control data */
+	struct iscsi_transport	*tt;
+	struct Scsi_Host	*host;
+	struct iscsi_conn	*leadconn;	/* leading connection */
+	spinlock_t		lock;		/* protects session state, *
+						 * sequence numbers,       *
+						 * session resources:      *
+						 * - cmdpool,		   *
+						 * - mgmtpool,		   *
+						 * - r2tpool		   */
+	int			state;		/* session state           */
+	int			recovery_failed;
+	struct list_head	item;
+	int			conn_cnt;
+	int			age;		/* counts session re-opens */
+
+	struct list_head	connections;	/* list of connections */
+	int			cmds_max;	/* size of cmds array */
+	struct iscsi_cmd_task	**cmds;		/* Original Cmds arr */
+	struct iscsi_queue	cmdpool;	/* PDU's pool */
+	int			mgmtpool_max;	/* size of mgmt array */
+	struct iscsi_mgmt_task	**mgmt_cmds;	/* Original mgmt arr */
+	struct iscsi_queue	mgmtpool;	/* Mgmt PDU's pool */
+};
+
+/*
+ * scsi host template
+ */
+extern int iscsi_change_queue_depth(struct scsi_device *sdev, int depth);
+extern int iscsi_eh_abort(struct scsi_cmnd *sc);
+extern int iscsi_eh_host_reset(struct scsi_cmnd *sc);
+extern int iscsi_queuecommand(struct scsi_cmnd *sc,
+			      void (*done)(struct scsi_cmnd *));
+
+/*
+ * session management
+ */
+extern struct iscsi_cls_session *
+iscsi_session_setup(struct iscsi_transport *, struct scsi_transport_template *,
+		    int, int, uint32_t, uint32_t *);
+extern void iscsi_session_teardown(struct iscsi_cls_session *);
+extern struct iscsi_session *class_to_transport_session(struct iscsi_cls_session *);
+extern void iscsi_start_session_recovery(struct iscsi_session *,
+					struct iscsi_conn *, int);
+extern void iscsi_session_recovery_timedout(struct iscsi_cls_session *);
+
+#define session_to_cls(_sess) \
+	hostdata_session(_sess->host->hostdata)
+
+/*
+ * connection management
+ */
+extern struct iscsi_cls_conn *iscsi_conn_setup(struct iscsi_cls_session *,
+					       uint32_t);
+extern void iscsi_conn_teardown(struct iscsi_cls_conn *);
+extern int iscsi_conn_start(struct iscsi_cls_conn *);
+extern void iscsi_conn_stop(struct iscsi_cls_conn *, int);
+extern int iscsi_conn_bind(struct iscsi_cls_session *, struct iscsi_cls_conn *,
+			   int);
+extern void iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err);
+
+/*
+ * pdu and task processing
+ */
+extern int iscsi_check_assign_cmdsn(struct iscsi_session *,
+				    struct iscsi_nopin *);
+extern void iscsi_prep_unsolicit_data_pdu(struct iscsi_cmd_task *,
+					struct iscsi_data *hdr,
+					int transport_data_cnt);
+extern int iscsi_conn_send_pdu(struct iscsi_cls_conn *, struct iscsi_hdr *,
+				char *, uint32_t);
+extern int iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,
+			      char *, int);
+extern int __iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,
+				char *, int);
+extern int iscsi_verify_itt(struct iscsi_conn *, struct iscsi_hdr *,
+			    uint32_t *);
+
+/*
+ * generic helpers
+ */
+extern void iscsi_pool_free(struct iscsi_queue *, void **);
+extern int iscsi_pool_init(struct iscsi_queue *, int, void ***, int);
+
+#endif
